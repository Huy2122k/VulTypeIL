cve_id,cwe_ids,cvss_vector,cvss_is_v3,repo_name,commit_msg,commit_hash,git_url,file_path,func_name,func_before,abstract_func_before,func_graph_path_before,func,abstract_func,func_graph_path,diff_func,diff_line_info,is_vul,description,Base Score,Base Severity,severity,source,commit_time,task
CVE-2021-33657,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,libsdl-org/SDL,"Always create a full 256-entry map in case color values are out of range

Fixes https://github.com/libsdl-org/SDL/issues/5042",8c91cf7dba5193f5ce12d06db1336515851c9ee9,https://github.com/libsdl-org/SDL/commit/8c91cf7dba5193f5ce12d06db1336515851c9ee9,src/video/SDL_pixels.c,Map1toN,"static Uint8 *
Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,
SDL_PixelFormat * dst)
{
Uint8 *map;
int i;
int bpp;
SDL_Palette *pal = src->palette;
bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);
map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);
if (map == NULL) {
SDL_OutOfMemory();
return (NULL);
}
for (i = 0; i < pal->ncolors; ++i) {
Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255);
Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255);
Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255);
Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);
ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);
}
return (map);
}","static Uint8 *
Map1toN(SDL_PixelFormat * VAR_0, Uint8 VAR_1, Uint8 VAR_2, Uint8 VAR_3, Uint8 VAR_4,
SDL_PixelFormat * VAR_5)
{
Uint8 *VAR_6;
int VAR_7;
int VAR_8;
SDL_Palette *VAR_9 = VAR_0->palette;
VAR_8 = ((VAR_5->BytesPerPixel == 3) ? 4 : VAR_5->BytesPerPixel);
VAR_6 = (Uint8 *) SDL_malloc(VAR_9->ncolors * VAR_8);
if (VAR_6 == NULL) {
SDL_OutOfMemory();
return (NULL);
}
for (VAR_7 = 0; VAR_7 < VAR_9->ncolors; ++VAR_7) {
Uint8 VAR_10 = (Uint8) ((VAR_9->colors[VAR_7].r * VAR_1) / 255);
Uint8 VAR_11 = (Uint8) ((VAR_9->colors[VAR_7].g * VAR_2) / 255);
Uint8 VAR_12 = (Uint8) ((VAR_9->colors[VAR_7].b * VAR_3) / 255);
Uint8 VAR_13 = (Uint8) ((VAR_9->colors[VAR_7].a * VAR_4) / 255);
ASSEMBLE_RGBA(&VAR_6[VAR_7 * VAR_8], VAR_5->BytesPerPixel, VAR_5, (Uint32)VAR_10, (Uint32)VAR_11, (Uint32)VAR_12, (Uint32)VAR_13);
}
return (VAR_6);
}",libsdl-org/SDL/8c91cf7dba5193f5ce12d06db1336515851c9ee9/SDL_pixels.c/vul/before/0.json,"static Uint8 *
Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,
        SDL_PixelFormat * dst)
{
    Uint8 *map;
    int i;
    int bpp;
    SDL_Palette *pal = src->palette;

    bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);
    map = (Uint8 *) SDL_calloc(256, bpp);
    if (map == NULL) {
        SDL_OutOfMemory();
        return (NULL);
    }

    /* We memory copy to the pixel map so the endianness is preserved */
    for (i = 0; i < pal->ncolors; ++i) {
        Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255);
        Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255);
        Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255);
        Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);
        ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);
    }
    return (map);
}","static Uint8 *
Map1toN(SDL_PixelFormat * VAR_0, Uint8 VAR_1, Uint8 VAR_2, Uint8 VAR_3, Uint8 VAR_4,
        SDL_PixelFormat * VAR_5)
{
    Uint8 *VAR_6;
    int VAR_7;
    int VAR_8;
    SDL_Palette *VAR_9 = VAR_0->palette;

    VAR_8 = ((VAR_5->BytesPerPixel == 3) ? 4 : VAR_5->BytesPerPixel);
    VAR_6 = (Uint8 *) SDL_calloc(256, VAR_8);
    if (VAR_6 == NULL) {
        SDL_OutOfMemory();
        return (NULL);
    }

    /* COMMENT_0 */
    for (VAR_7 = 0; VAR_7 < VAR_9->ncolors; ++VAR_7) {
        Uint8 VAR_10 = (Uint8) ((VAR_9->colors[VAR_7].r * VAR_1) / 255);
        Uint8 VAR_11 = (Uint8) ((VAR_9->colors[VAR_7].g * VAR_2) / 255);
        Uint8 VAR_12 = (Uint8) ((VAR_9->colors[VAR_7].b * VAR_3) / 255);
        Uint8 VAR_13 = (Uint8) ((VAR_9->colors[VAR_7].a * VAR_4) / 255);
        ASSEMBLE_RGBA(&VAR_6[VAR_7 * VAR_8], VAR_5->BytesPerPixel, VAR_5, (Uint32)VAR_10, (Uint32)VAR_11, (Uint32)VAR_12, (Uint32)VAR_13);
    }
    return (VAR_6);
}",libsdl-org/SDL/8c91cf7dba5193f5ce12d06db1336515851c9ee9/SDL_pixels.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,7 +8,7 @@
     SDL_Palette *pal = src->palette;
 
     bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);
-    map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);
+    map = (Uint8 *) SDL_calloc(256, bpp);
     if (map == NULL) {
         SDL_OutOfMemory();
         return (NULL);","{'deleted_lines': ['    map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);'], 'added_lines': ['    map = (Uint8 *) SDL_calloc(256, bpp);']}",True,"There is a heap overflow problem in video/SDL_pixels.c in SDL (Simple DirectMedia Layer) 2.x to 2.0.18 versions. By crafting a malicious .BMP file, an attacker can cause the application using this library to crash, denial of service or Code execution.",8.8,HIGH,2,test,2021-11-30T20:36:46Z,4
CVE-2021-33657,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,libsdl-org/SDL,"Always create a full 256-entry map in case color values are out of range

Fixes https://github.com/libsdl-org/SDL/issues/5042",8c91cf7dba5193f5ce12d06db1336515851c9ee9,https://github.com/libsdl-org/SDL/commit/8c91cf7dba5193f5ce12d06db1336515851c9ee9,src/video/SDL_pixels.c,Map1to1,"static Uint8 *
Map1to1(SDL_Palette * src, SDL_Palette * dst, int *identical)
{
Uint8 *map;
int i;
if (identical) {
if (src->ncolors <= dst->ncolors) {
if (src == dst
||
(SDL_memcmp
(src->colors, dst->colors,
src->ncolors * sizeof(SDL_Color)) == 0)) {
*identical = 1;
return (NULL);
}
}
*identical = 0;
}
map = (Uint8 *) SDL_malloc(src->ncolors);
if (map == NULL) {
SDL_OutOfMemory();
return (NULL);
}
for (i = 0; i < src->ncolors; ++i) {
map[i] = SDL_FindColor(dst,
src->colors[i].r, src->colors[i].g,
src->colors[i].b, src->colors[i].a);
}
return (map);
}","static Uint8 *
Map1to1(SDL_Palette * VAR_0, SDL_Palette * VAR_1, int *VAR_2)
{
Uint8 *VAR_3;
int VAR_4;
if (VAR_2) {
if (VAR_0->ncolors <= VAR_1->ncolors) {
if (VAR_0 == VAR_1
||
(SDL_memcmp
(VAR_0->colors, VAR_1->colors,
VAR_0->ncolors * sizeof(VAR_5)) == 0)) {
*VAR_2 = 1;
return (NULL);
}
}
*VAR_2 = 0;
}
VAR_3 = (Uint8 *) SDL_malloc(VAR_0->ncolors);
if (VAR_3 == NULL) {
SDL_OutOfMemory();
return (NULL);
}
for (VAR_4 = 0; VAR_4 < VAR_0->ncolors; ++VAR_4) {
VAR_3[VAR_4] = SDL_FindColor(VAR_1,
VAR_0->colors[VAR_4].r, VAR_0->colors[VAR_4].g,
VAR_0->colors[VAR_4].b, VAR_0->colors[VAR_4].a);
}
return (VAR_3);
}",libsdl-org/SDL/8c91cf7dba5193f5ce12d06db1336515851c9ee9/SDL_pixels.c/vul/before/1.json,"static Uint8 *
Map1to1(SDL_Palette * src, SDL_Palette * dst, int *identical)
{
    Uint8 *map;
    int i;

    if (identical) {
        if (src->ncolors <= dst->ncolors) {
            /* If an identical palette, no need to map */
            if (src == dst
                ||
                (SDL_memcmp
                 (src->colors, dst->colors,
                  src->ncolors * sizeof(SDL_Color)) == 0)) {
                *identical = 1;
                return (NULL);
            }
        }
        *identical = 0;
    }
    map = (Uint8 *) SDL_calloc(256, sizeof(Uint8));
    if (map == NULL) {
        SDL_OutOfMemory();
        return (NULL);
    }
    for (i = 0; i < src->ncolors; ++i) {
        map[i] = SDL_FindColor(dst,
                               src->colors[i].r, src->colors[i].g,
                               src->colors[i].b, src->colors[i].a);
    }
    return (map);
}","static Uint8 *
Map1to1(SDL_Palette * VAR_0, SDL_Palette * VAR_1, int *VAR_2)
{
    Uint8 *VAR_3;
    int VAR_4;

    if (VAR_2) {
        if (VAR_0->ncolors <= VAR_1->ncolors) {
            /* COMMENT_0 */
            if (VAR_0 == VAR_1
                ||
                (SDL_memcmp
                 (VAR_0->colors, VAR_1->colors,
                  VAR_0->ncolors * sizeof(VAR_5)) == 0)) {
                *VAR_2 = 1;
                return (NULL);
            }
        }
        *VAR_2 = 0;
    }
    VAR_3 = (Uint8 *) SDL_calloc(256, sizeof(Uint8));
    if (VAR_3 == NULL) {
        SDL_OutOfMemory();
        return (NULL);
    }
    for (VAR_4 = 0; VAR_4 < VAR_0->ncolors; ++VAR_4) {
        VAR_3[VAR_4] = SDL_FindColor(VAR_1,
                               VAR_0->colors[VAR_4].r, VAR_0->colors[VAR_4].g,
                               VAR_0->colors[VAR_4].b, VAR_0->colors[VAR_4].a);
    }
    return (VAR_3);
}",libsdl-org/SDL/8c91cf7dba5193f5ce12d06db1336515851c9ee9/SDL_pixels.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -18,7 +18,7 @@
         }
         *identical = 0;
     }
-    map = (Uint8 *) SDL_malloc(src->ncolors);
+    map = (Uint8 *) SDL_calloc(256, sizeof(Uint8));
     if (map == NULL) {
         SDL_OutOfMemory();
         return (NULL);","{'deleted_lines': ['    map = (Uint8 *) SDL_malloc(src->ncolors);'], 'added_lines': ['    map = (Uint8 *) SDL_calloc(256, sizeof(Uint8));']}",True,"There is a heap overflow problem in video/SDL_pixels.c in SDL (Simple DirectMedia Layer) 2.x to 2.0.18 versions. By crafting a malicious .BMP file, an attacker can cause the application using this library to crash, denial of service or Code execution.",8.8,HIGH,2,test,2021-11-30T20:36:46Z,4
CVE-2022-22890,['CWE-617'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,jerryscript-project/jerryscript,"Prevent arguments object creation if 'arguments' function argument is present

This patch fixes #4847.

JerryScript-DCO-1.0-Signed-off-by: Robert Fancsik robert.fancsik@h-lab.eu",3bb042b49153dafb4cb47e8c6c032692a78ba0c7,https://github.com/jerryscript-project/jerryscript/commit/3bb042b49153dafb4cb47e8c6c032692a78ba0c7,jerry-core/parser/js/js-scanner-util.c,scanner_filter_arguments,"void
scanner_filter_arguments (parser_context_t *context_p, 
scanner_context_t *scanner_context_p) 
{
scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
scanner_literal_pool_t *prev_literal_pool_p = literal_pool_p->prev_p;
parser_list_iterator_t literal_iterator;
lexer_lit_location_t *literal_p;
bool can_eval = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) != 0;
bool has_arguments = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS) == 0;
JERRY_ASSERT (SCANNER_LITERAL_POOL_MAY_HAVE_ARGUMENTS (literal_pool_p->status_flags));
if (can_eval)
{
if (prev_literal_pool_p != NULL)
{
prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;
}
if (has_arguments)
{
literal_pool_p->status_flags |= (SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS | SCANNER_LITERAL_POOL_NO_ARGUMENTS);
}
}
literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_CAN_EVAL;
parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
while (true)
{
literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator);
if (literal_p == NULL)
{
return;
}
if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE))
{
literal_p->type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE;
}
uint8_t type = literal_p->type;
const uint8_t mask =
(SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG);
if ((type & mask) != SCANNER_LITERAL_IS_ARG)
{
break;
}
}
bool has_destructured_arg = false;
scanner_literal_pool_t *new_literal_pool_p;
new_literal_pool_p = (scanner_literal_pool_t *) scanner_malloc (context_p, sizeof (scanner_literal_pool_t));
new_literal_pool_p->prev_p = literal_pool_p;
scanner_context_p->active_literal_pool_p = new_literal_pool_p;
*new_literal_pool_p = *literal_pool_p;
parser_list_init (&new_literal_pool_p->literal_pool,
sizeof (lexer_lit_location_t),
(uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_lit_location_t)));
parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
{
uint8_t type = literal_p->type;
if (type & SCANNER_LITERAL_IS_ARG)
{
if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE))
{
type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE;
literal_p->type = type;
}
if (type & (SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG))
{
has_destructured_arg = true;
if (type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG)
{
continue;
}
type &= (uint8_t) ~SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG;
type |= SCANNER_LITERAL_IS_DESTRUCTURED_ARG;
literal_p->type = type;
continue;
}
lexer_lit_location_t *new_literal_p;
new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool);
*new_literal_p = *literal_p;
}
else if (has_arguments && scanner_literal_is_arguments (literal_p))
{
new_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS;
if (type & SCANNER_LITERAL_NO_REG)
{
new_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_NO_ARGUMENTS;
}
}
else if (prev_literal_pool_p != NULL)
{
lexer_lit_location_t *literal_location_p = scanner_add_custom_literal (context_p, prev_literal_pool_p, literal_p);
type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_IS_USED;
literal_location_p->type |= type;
}
}
if (has_destructured_arg)
{
parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
{
const uint8_t expected_flags = SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG;
if ((literal_p->type & expected_flags) == expected_flags)
{
lexer_lit_location_t *new_literal_p;
new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool);
*new_literal_p = *literal_p;
}
}
}
new_literal_pool_p->prev_p = prev_literal_pool_p;
parser_list_free (&literal_pool_p->literal_pool);
scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));
}","void
scanner_filter_arguments (parser_context_t *VAR_0, 
scanner_context_t *VAR_1) 
{
scanner_literal_pool_t *VAR_2 = VAR_1->active_literal_pool_p;
scanner_literal_pool_t *VAR_3 = VAR_2->prev_p;
parser_list_iterator_t VAR_4;
lexer_lit_location_t *VAR_5;
bool VAR_6 = (VAR_2->status_flags & VAR_7) != 0;
bool VAR_8 = (VAR_2->status_flags & VAR_9) == 0;
JERRY_ASSERT (SCANNER_LITERAL_POOL_MAY_HAVE_ARGUMENTS (VAR_2->status_flags));
if (VAR_6)
{
if (VAR_3 != NULL)
{
VAR_3->status_flags |= VAR_7;
}
if (VAR_8)
{
VAR_2->status_flags |= (VAR_10 | VAR_9);
}
}
VAR_2->status_flags &= (uint16_t) ~VAR_7;
parser_list_iterator_init (&VAR_2->literal_pool, &VAR_4);
while (true)
{
VAR_5 = (lexer_lit_location_t *) parser_list_iterator_next (&VAR_4);
if (VAR_5 == NULL)
{
return;
}
if (VAR_6 || (VAR_5->type & VAR_11))
{
VAR_5->type |= VAR_12 | VAR_11;
}
uint8_t VAR_13 = VAR_5->type;
const uint8_t VAR_14 =
(VAR_15 | VAR_16 | VAR_17);
if ((VAR_13 & VAR_14) != VAR_15)
{
break;
}
}
bool VAR_18 = false;
scanner_literal_pool_t *VAR_19;
VAR_19 = (scanner_literal_pool_t *) scanner_malloc (VAR_0, sizeof (scanner_literal_pool_t));
VAR_19->prev_p = VAR_2;
VAR_1->active_literal_pool_p = VAR_19;
*VAR_19 = *VAR_2;
parser_list_init (&VAR_19->literal_pool,
sizeof (lexer_lit_location_t),
(uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_lit_location_t)));
parser_list_iterator_init (&VAR_2->literal_pool, &VAR_4);
while ((VAR_5 = (lexer_lit_location_t *) parser_list_iterator_next (&VAR_4)) != NULL)
{
uint8_t VAR_13 = VAR_5->type;
if (VAR_13 & VAR_15)
{
if (VAR_6 || (VAR_5->type & VAR_11))
{
VAR_13 |= VAR_12 | VAR_11;
VAR_5->type = VAR_13;
}
if (VAR_13 & (VAR_16 | VAR_17))
{
VAR_18 = true;
if (VAR_13 & VAR_16)
{
continue;
}
VAR_13 &= (uint8_t) ~VAR_17;
VAR_13 |= VAR_16;
VAR_5->type = VAR_13;
continue;
}
lexer_lit_location_t *VAR_20;
VAR_20 = (lexer_lit_location_t *) parser_list_append (VAR_0, &VAR_19->literal_pool);
*VAR_20 = *VAR_5;
}
else if (VAR_8 && scanner_literal_is_arguments (VAR_5))
{
VAR_19->status_flags |= VAR_10;
if (VAR_13 & VAR_12)
{
VAR_19->status_flags |= VAR_9;
}
}
else if (VAR_3 != NULL)
{
lexer_lit_location_t *VAR_21 = scanner_add_custom_literal (VAR_0, VAR_3, VAR_5);
VAR_13 |= VAR_12 | VAR_22;
VAR_21->type |= VAR_13;
}
}
if (VAR_18)
{
parser_list_iterator_init (&VAR_2->literal_pool, &VAR_4);
while ((VAR_5 = (lexer_lit_location_t *) parser_list_iterator_next (&VAR_4)) != NULL)
{
const uint8_t VAR_23 = VAR_15 | VAR_16;
if ((VAR_5->type & VAR_23) == VAR_23)
{
lexer_lit_location_t *VAR_20;
VAR_20 = (lexer_lit_location_t *) parser_list_append (VAR_0, &VAR_19->literal_pool);
*VAR_20 = *VAR_5;
}
}
}
VAR_19->prev_p = VAR_3;
parser_list_free (&VAR_2->literal_pool);
scanner_free (VAR_2, sizeof (scanner_literal_pool_t));
}",jerryscript-project/jerryscript/3bb042b49153dafb4cb47e8c6c032692a78ba0c7/js-scanner-util.c/vul/before/0.json,"void
scanner_filter_arguments (parser_context_t *context_p, /**< context */
                          scanner_context_t *scanner_context_p) /**< scanner context */
{
  /* Fast case: check whether all literals are arguments. */
  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
  scanner_literal_pool_t *prev_literal_pool_p = literal_pool_p->prev_p;
  parser_list_iterator_t literal_iterator;
  lexer_lit_location_t *literal_p;
  bool can_eval = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) != 0;
  bool has_arguments = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS) == 0;

  JERRY_ASSERT (SCANNER_LITERAL_POOL_MAY_HAVE_ARGUMENTS (literal_pool_p->status_flags));

  if (can_eval)
  {
    if (prev_literal_pool_p != NULL)
    {
      prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;
    }

    if (has_arguments)
    {
      /* Force the lexically stored arguments object creation */
      literal_pool_p->status_flags |= (SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS | SCANNER_LITERAL_POOL_NO_ARGUMENTS);
    }
  }

  literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_CAN_EVAL;

  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);

  while (true)
  {
    literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator);

    if (literal_p == NULL)
    {
      return;
    }

    if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE))
    {
      literal_p->type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE;
    }

    uint8_t type = literal_p->type;
    const uint8_t mask =
      (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG);

    if ((type & mask) != SCANNER_LITERAL_IS_ARG)
    {
      break;
    }
  }

  /* Destructured args are placed after the other arguments because of register assignments. */
  bool has_destructured_arg = false;
  scanner_literal_pool_t *new_literal_pool_p;

  new_literal_pool_p = (scanner_literal_pool_t *) scanner_malloc (context_p, sizeof (scanner_literal_pool_t));

  new_literal_pool_p->prev_p = literal_pool_p;
  scanner_context_p->active_literal_pool_p = new_literal_pool_p;

  *new_literal_pool_p = *literal_pool_p;
  parser_list_init (&new_literal_pool_p->literal_pool,
                    sizeof (lexer_lit_location_t),
                    (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_lit_location_t)));

  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);

  while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
  {
    uint8_t type = literal_p->type;

    if (type & SCANNER_LITERAL_IS_ARG)
    {
      if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE))
      {
        type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE;
        literal_p->type = type;
      }

      if (has_arguments && scanner_literal_is_arguments (literal_p))
      {
        /* 'arguments' function argument existence should prevent the arguments object construction */
        new_literal_pool_p->status_flags =
          (uint16_t) (new_literal_pool_p->status_flags
                      & ~(SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS | SCANNER_LITERAL_POOL_NO_ARGUMENTS));
      }

      if (type & (SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG))
      {
        has_destructured_arg = true;

        if (type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG)
        {
          continue;
        }

        type &= (uint8_t) ~SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG;
        type |= SCANNER_LITERAL_IS_DESTRUCTURED_ARG;

        literal_p->type = type;
        continue;
      }

      lexer_lit_location_t *new_literal_p;
      new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool);
      *new_literal_p = *literal_p;
    }
    else if (has_arguments && scanner_literal_is_arguments (literal_p))
    {
      /* Arguments object is directly referenced from the function arguments */
      new_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS;

      if (type & SCANNER_LITERAL_NO_REG)
      {
        new_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_NO_ARGUMENTS;
      }
    }
    else if (prev_literal_pool_p != NULL)
    {
      /* Propagate literal to upper level. */
      lexer_lit_location_t *literal_location_p = scanner_add_custom_literal (context_p, prev_literal_pool_p, literal_p);
      type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_IS_USED;
      literal_location_p->type |= type;
    }
  }

  if (has_destructured_arg)
  {
    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);

    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
    {
      const uint8_t expected_flags = SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG;

      if ((literal_p->type & expected_flags) == expected_flags)
      {
        lexer_lit_location_t *new_literal_p;
        new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool);
        *new_literal_p = *literal_p;
      }
    }
  }

  new_literal_pool_p->prev_p = prev_literal_pool_p;

  parser_list_free (&literal_pool_p->literal_pool);
  scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));
}","void
scanner_filter_arguments (parser_context_t *VAR_0, /* COMMENT_0 */
                          scanner_context_t *VAR_1) /* COMMENT_1 */
{
  /* COMMENT_2 */
  scanner_literal_pool_t *VAR_2 = VAR_1->active_literal_pool_p;
  scanner_literal_pool_t *VAR_3 = VAR_2->prev_p;
  parser_list_iterator_t VAR_4;
  lexer_lit_location_t *VAR_5;
  bool VAR_6 = (VAR_2->status_flags & VAR_7) != 0;
  bool VAR_8 = (VAR_2->status_flags & VAR_9) == 0;

  JERRY_ASSERT (SCANNER_LITERAL_POOL_MAY_HAVE_ARGUMENTS (VAR_2->status_flags));

  if (VAR_6)
  {
    if (VAR_3 != NULL)
    {
      VAR_3->status_flags |= VAR_7;
    }

    if (VAR_8)
    {
      /* COMMENT_3 */
      VAR_2->status_flags |= (VAR_10 | VAR_9);
    }
  }

  VAR_2->status_flags &= (uint16_t) ~VAR_7;

  parser_list_iterator_init (&VAR_2->literal_pool, &VAR_4);

  while (true)
  {
    VAR_5 = (lexer_lit_location_t *) parser_list_iterator_next (&VAR_4);

    if (VAR_5 == NULL)
    {
      return;
    }

    if (VAR_6 || (VAR_5->type & VAR_11))
    {
      VAR_5->type |= VAR_12 | VAR_11;
    }

    uint8_t VAR_13 = VAR_5->type;
    const uint8_t VAR_14 =
      (VAR_15 | VAR_16 | VAR_17);

    if ((VAR_13 & VAR_14) != VAR_15)
    {
      break;
    }
  }

  /* COMMENT_4 */
  bool VAR_18 = false;
  scanner_literal_pool_t *VAR_19;

  VAR_19 = (scanner_literal_pool_t *) scanner_malloc (VAR_0, sizeof (scanner_literal_pool_t));

  VAR_19->prev_p = VAR_2;
  VAR_1->active_literal_pool_p = VAR_19;

  *VAR_19 = *VAR_2;
  parser_list_init (&VAR_19->literal_pool,
                    sizeof (lexer_lit_location_t),
                    (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_lit_location_t)));

  parser_list_iterator_init (&VAR_2->literal_pool, &VAR_4);

  while ((VAR_5 = (lexer_lit_location_t *) parser_list_iterator_next (&VAR_4)) != NULL)
  {
    uint8_t VAR_13 = VAR_5->type;

    if (VAR_13 & VAR_15)
    {
      if (VAR_6 || (VAR_5->type & VAR_11))
      {
        VAR_13 |= VAR_12 | VAR_11;
        VAR_5->type = VAR_13;
      }

      if (VAR_8 && scanner_literal_is_arguments (VAR_5))
      {
        /* COMMENT_5 */
        VAR_19->status_flags =
          (uint16_t) (VAR_19->status_flags
                      & ~(VAR_10 | VAR_9));
      }

      if (VAR_13 & (VAR_16 | VAR_17))
      {
        VAR_18 = true;

        if (VAR_13 & VAR_16)
        {
          continue;
        }

        VAR_13 &= (uint8_t) ~VAR_17;
        VAR_13 |= VAR_16;

        VAR_5->type = VAR_13;
        continue;
      }

      lexer_lit_location_t *VAR_20;
      VAR_20 = (lexer_lit_location_t *) parser_list_append (VAR_0, &VAR_19->literal_pool);
      *VAR_20 = *VAR_5;
    }
    else if (VAR_8 && scanner_literal_is_arguments (VAR_5))
    {
      /* COMMENT_6 */
      VAR_19->status_flags |= VAR_10;

      if (VAR_13 & VAR_12)
      {
        VAR_19->status_flags |= VAR_9;
      }
    }
    else if (VAR_3 != NULL)
    {
      /* COMMENT_7 */
      lexer_lit_location_t *VAR_21 = scanner_add_custom_literal (VAR_0, VAR_3, VAR_5);
      VAR_13 |= VAR_12 | VAR_22;
      VAR_21->type |= VAR_13;
    }
  }

  if (VAR_18)
  {
    parser_list_iterator_init (&VAR_2->literal_pool, &VAR_4);

    while ((VAR_5 = (lexer_lit_location_t *) parser_list_iterator_next (&VAR_4)) != NULL)
    {
      const uint8_t VAR_23 = VAR_15 | VAR_16;

      if ((VAR_5->type & VAR_23) == VAR_23)
      {
        lexer_lit_location_t *VAR_20;
        VAR_20 = (lexer_lit_location_t *) parser_list_append (VAR_0, &VAR_19->literal_pool);
        *VAR_20 = *VAR_5;
      }
    }
  }

  VAR_19->prev_p = VAR_3;

  parser_list_free (&VAR_2->literal_pool);
  scanner_free (VAR_2, sizeof (scanner_literal_pool_t));
}",jerryscript-project/jerryscript/3bb042b49153dafb4cb47e8c6c032692a78ba0c7/js-scanner-util.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -21,6 +21,7 @@
 
     if (has_arguments)
     {
+      /* Force the lexically stored arguments object creation */
       literal_pool_p->status_flags |= (SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS | SCANNER_LITERAL_POOL_NO_ARGUMENTS);
     }
   }
@@ -81,6 +82,14 @@
         literal_p->type = type;
       }
 
+      if (has_arguments && scanner_literal_is_arguments (literal_p))
+      {
+        /* 'arguments' function argument existence should prevent the arguments object construction */
+        new_literal_pool_p->status_flags =
+          (uint16_t) (new_literal_pool_p->status_flags
+                      & ~(SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS | SCANNER_LITERAL_POOL_NO_ARGUMENTS));
+      }
+
       if (type & (SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG))
       {
         has_destructured_arg = true;
@@ -103,6 +112,7 @@
     }
     else if (has_arguments && scanner_literal_is_arguments (literal_p))
     {
+      /* Arguments object is directly referenced from the function arguments */
       new_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS;
 
       if (type & SCANNER_LITERAL_NO_REG)","{'deleted_lines': [], 'added_lines': ['      /* Force the lexically stored arguments object creation */', '      if (has_arguments && scanner_literal_is_arguments (literal_p))', '      {', ""        /* 'arguments' function argument existence should prevent the arguments object construction */"", '        new_literal_pool_p->status_flags =', '          (uint16_t) (new_literal_pool_p->status_flags', '                      & ~(SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS | SCANNER_LITERAL_POOL_NO_ARGUMENTS));', '      }', '', '      /* Arguments object is directly referenced from the function arguments */']}",True,There is an Assertion 'arguments_type != SCANNER_ARGUMENTS_PRESENT && arguments_type != SCANNER_ARGUMENTS_PRESENT_NO_REG' failed at /jerry-core/parser/js/js-scanner-util.c in Jerryscript 3.0.0.,5.5,MEDIUM,1,test,2021-12-07T11:23:52Z,4
CVE-2022-23591,['CWE-674'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,tensorflow,"Prevent stack overflow when FunctionLib in GraphDef has a self-recursive function.

It is likely that no recursivity is supported, but we should handle this separately.

PiperOrigin-RevId: 414860329
Change-Id: I02a2270e86282b37362ddd485eeef16fb986a9e0",448a16182065bd08a202d9057dd8ca541e67996c,https://github.com/tensorflow/tensorflow/commit/448a16182065bd08a202d9057dd8ca541e67996c,tensorflow/cc/saved_model/loader.cc,ValidateSavedTensors,"static Status ValidateSavedTensors(const GraphDef& graph_def) {
for (const auto& node : graph_def.node()) {
TF_RETURN_IF_ERROR(ValidateNode(node));
}
if (graph_def.has_library()) {
const FunctionDefLibrary& library = graph_def.library();
for (const auto& function : library.function()) {
for (const auto& node : function.node_def()) {
TF_RETURN_IF_ERROR(ValidateNode(node));
}
}
}
return Status::OK();
}","static Status ValidateSavedTensors(const GraphDef& VAR_0) {
for (const auto& VAR_1 : VAR_0.node()) {
TF_RETURN_IF_ERROR(ValidateNode(VAR_1));
}
if (VAR_0.has_library()) {
const FunctionDefLibrary& VAR_2 = VAR_0.library();
for (const auto& VAR_3 : VAR_2.function()) {
for (const auto& VAR_1 : VAR_3.node_def()) {
TF_RETURN_IF_ERROR(ValidateNode(VAR_1));
}
}
}
return Status::OK();
}",tensorflow/448a16182065bd08a202d9057dd8ca541e67996c/loader.cc/vul/before/0.json,"static Status ValidateSavedTensors(const GraphDef& graph_def) {
  for (const auto& node : graph_def.node()) {
    TF_RETURN_IF_ERROR(ValidateNode(node));
  }

  if (graph_def.has_library()) {
    const FunctionDefLibrary& library = graph_def.library();
    for (const auto& function : library.function()) {
      for (const auto& node : function.node_def()) {
        TF_RETURN_IF_ERROR(ValidateNode(node));
      }

      // Also check that there is no recursivity in the library
      // TODO(mihaimaruseac): Do more than self-recursivity
      TF_RETURN_IF_ERROR(ValidateFunctionNotRecursive(function));
    }
  }

  return Status::OK();
}","static Status ValidateSavedTensors(const GraphDef& VAR_0) {
  for (const auto& VAR_1 : VAR_0.node()) {
    TF_RETURN_IF_ERROR(ValidateNode(VAR_1));
  }

  if (VAR_0.has_library()) {
    const FunctionDefLibrary& VAR_2 = VAR_0.library();
    for (const auto& VAR_3 : VAR_2.function()) {
      for (const auto& VAR_1 : VAR_3.node_def()) {
        TF_RETURN_IF_ERROR(ValidateNode(VAR_1));
      }

      /* COMMENT_0 */
      /* COMMENT_1 */
      TF_RETURN_IF_ERROR(ValidateFunctionNotRecursive(VAR_3));
    }
  }

  return Status::OK();
}",tensorflow/448a16182065bd08a202d9057dd8ca541e67996c/loader.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,6 +9,10 @@
       for (const auto& node : function.node_def()) {
         TF_RETURN_IF_ERROR(ValidateNode(node));
       }
+
+      // Also check that there is no recursivity in the library
+      // TODO(mihaimaruseac): Do more than self-recursivity
+      TF_RETURN_IF_ERROR(ValidateFunctionNotRecursive(function));
     }
   }
 ","{'deleted_lines': [], 'added_lines': ['', '      // Also check that there is no recursivity in the library', '      // TODO(mihaimaruseac): Do more than self-recursivity', '      TF_RETURN_IF_ERROR(ValidateFunctionNotRecursive(function));']}",True,"Tensorflow is an Open Source Machine Learning Framework. The `GraphDef` format in TensorFlow does not allow self recursive functions. The runtime assumes that this invariant is satisfied. However, a `GraphDef` containing a fragment such as the following can be consumed when loading a `SavedModel`. This would result in a stack overflow during execution as resolving each `NodeDef` means resolving the function itself and its nodes. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.",7.5,HIGH,2,test,2021-12-08T00:49:32Z,4
CVE-2023-23003,['CWE-252'],CVSS:3.1/AV:L/AC:H/PR:H/UI:R/S:U/C:N/I:N/A:H,1,torvalds/linux,"perf expr: Fix missing check for return value of hashmap__new()

The hashmap__new() function may return ERR_PTR(-ENOMEM) when malloc()
fails, add IS_ERR() checking for ctx->ids.

Signed-off-by: Miaoqian Lin <linmq006@gmail.com>
Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Cc: Andi Kleen <ak@linux.intel.com>
Cc: Ian Rogers <irogers@google.com>
Cc: Jiri Olsa <jolsa@redhat.com>
Cc: Mark Rutland <mark.rutland@arm.com>
Cc: Namhyung Kim <namhyung@kernel.org>
Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lore.kernel.org/lkml/20211212062504.25841-1-linmq006@gmail.com
[ s/kfree()/free()/ and add missing linux/err.h include ]
Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>",0a515a06c5ebfa46fee3ac519e418f801e718da4,https://github.com/torvalds/linux/commit/0a515a06c5ebfa46fee3ac519e418f801e718da4,tools/perf/util/expr.c,expr__ctx_new,"struct expr_parse_ctx *expr__ctx_new(void)
{
struct expr_parse_ctx *ctx;
ctx = malloc(sizeof(struct expr_parse_ctx));
if (!ctx)
return NULL;
ctx->ids = hashmap__new(key_hash, key_equal, NULL);
ctx->runtime = 0;
return ctx;
}","struct expr_parse_ctx *expr__ctx_new(void)
{
struct expr_parse_ctx *VAR_0;
VAR_0 = malloc(sizeof(struct expr_parse_ctx));
if (!VAR_0)
return NULL;
VAR_0->ids = hashmap__new(VAR_1, VAR_2, NULL);
VAR_0->runtime = 0;
return VAR_0;
}",torvalds/linux/0a515a06c5ebfa46fee3ac519e418f801e718da4/expr.c/vul/before/0.json,"struct expr_parse_ctx *expr__ctx_new(void)
{
	struct expr_parse_ctx *ctx;

	ctx = malloc(sizeof(struct expr_parse_ctx));
	if (!ctx)
		return NULL;

	ctx->ids = hashmap__new(key_hash, key_equal, NULL);
	if (IS_ERR(ctx->ids)) {
		free(ctx);
		return NULL;
	}
	ctx->runtime = 0;

	return ctx;
}","struct expr_parse_ctx *expr__ctx_new(void)
{
	struct expr_parse_ctx *VAR_0;

	VAR_0 = malloc(sizeof(struct expr_parse_ctx));
	if (!VAR_0)
		return NULL;

	VAR_0->ids = hashmap__new(VAR_1, VAR_2, NULL);
	if (IS_ERR(VAR_0->ids)) {
		free(VAR_0);
		return NULL;
	}
	VAR_0->runtime = 0;

	return VAR_0;
}",torvalds/linux/0a515a06c5ebfa46fee3ac519e418f801e718da4/expr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,6 +7,10 @@
 		return NULL;
 
 	ctx->ids = hashmap__new(key_hash, key_equal, NULL);
+	if (IS_ERR(ctx->ids)) {
+		free(ctx);
+		return NULL;
+	}
 	ctx->runtime = 0;
 
 	return ctx;","{'deleted_lines': [], 'added_lines': ['\tif (IS_ERR(ctx->ids)) {', '\t\tfree(ctx);', '\t\treturn NULL;', '\t}']}",True,"In the Linux kernel before 5.16, tools/perf/util/expr.c lacks a check for the hashmap__new return value.",4.0,MEDIUM,1,test,2021-12-12T06:25:02Z,4
CVE-2021-44921,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #1964,5b4a6417a90223f1ef6c0b41b055716f7bfbbca2,https://github.com/gpac/gpac/commit/5b4a6417a90223f1ef6c0b41b055716f7bfbbca2,src/isomedia/box_funcs.c,gf_isom_box_parse_ex,"GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box)
{
u32 type, uuid_type, hdr_size, restore_type;
u64 size, start, comp_start, end;
char uuid[16];
GF_Err e;
GF_BitStream *uncomp_bs = NULL;
u8 *uncomp_data = NULL;
u32 compressed_size=0;
GF_Box *newBox;
Bool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;
Bool is_special = GF_TRUE;
if ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;
*outBox = NULL;
if (gf_bs_available(bs) < 8) {
return GF_ISOM_INCOMPLETE_FILE;
}
comp_start = start = gf_bs_get_position(bs);
uuid_type = 0;
size = (u64) gf_bs_read_u32(bs);
hdr_size = 4;
if ((size >= 2) && (size <= 4)) {
size = 4;
type = GF_ISOM_BOX_TYPE_VOID;
} else {
type = gf_bs_read_u32(bs);
hdr_size += 4;
if (type == GF_ISOM_BOX_TYPE_TOTL)
size = 12;
if (!size) {
if (is_root_box) {
if (!skip_logs) {
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\n"", gf_4cc_to_str(type), type));
}
size = gf_bs_available(bs) + 8;
} else {
if (!skip_logs) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box type %s (0x%08X) at position ""LLU"" has size 0 but is not at root/file level, skipping\n"", gf_4cc_to_str(type), type, start));
return GF_EOS;
}
return GF_OK;
}
}
if (is_root_box && (size>=8)) {
Bool do_uncompress = GF_FALSE;
u8 *compb = NULL;
u32 osize = 0;
u32 otype = type;
if (type==GF_4CC('!', 'm', 'o', 'f')) {
do_uncompress = GF_TRUE;
type = GF_ISOM_BOX_TYPE_MOOF;
}
else if (type==GF_4CC('!', 'm', 'o', 'v')) {
do_uncompress = GF_TRUE;
type = GF_ISOM_BOX_TYPE_MOOV;
}
else if (type==GF_4CC('!', 's', 'i', 'x')) {
do_uncompress = GF_TRUE;
type = GF_ISOM_BOX_TYPE_SIDX;
}
else if (type==GF_4CC('!', 's', 's', 'x')) {
do_uncompress = GF_TRUE;
type = GF_ISOM_BOX_TYPE_SSIX;
}
if (do_uncompress) {
compb = gf_malloc((u32) (size-8));
compressed_size = (u32) (size - 8);
gf_bs_read_data(bs, compb, compressed_size);
e = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize);
if (e) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Failed to uncompress payload for box type %s (0x%08X)\n"", gf_4cc_to_str(otype), otype));
return e;
}
size = osize + 8;
uncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ);
bs = uncomp_bs;
start = 0;
gf_free(compb);
}
}
}
memset(uuid, 0, 16);
if (type == GF_ISOM_BOX_TYPE_UUID ) {
if (gf_bs_available(bs) < 16) {
return GF_ISOM_INCOMPLETE_FILE;
}
gf_bs_read_data(bs, uuid, 16);
hdr_size += 16;
uuid_type = gf_isom_solve_uuid_box(uuid);
}
if (size == 1) {
if (gf_bs_available(bs) < 8) {
return GF_ISOM_INCOMPLETE_FILE;
}
size = gf_bs_read_u64(bs);
hdr_size += 8;
}
if (!skip_logs)
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Read Box type %s size ""LLD"" start ""LLD""\n"", gf_4cc_to_str(type), size,  start));
if ( size < hdr_size ) {
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Box size ""LLD"" less than box header size %d\n"", size, hdr_size));
return GF_ISOM_INVALID_FILE;
}
restore_type = 0;
if ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) {
u64 cookie = gf_bs_get_cookie(bs);
restore_type = type;
if (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK)
type = GF_QT_SUBTYPE_RAW_VID;
else
type = GF_QT_SUBTYPE_RAW_AUD;
}
if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {
newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);
if (!newBox) return GF_OUT_OF_MEM;
((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;
} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {
newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);
if (!newBox) return GF_OUT_OF_MEM;
((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;
} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {
newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);
if (!newBox) return GF_OUT_OF_MEM;
((GF_TrackGroupTypeBox*)newBox)->group_type = type;
} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {
newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);
if (!newBox) return GF_OUT_OF_MEM;
((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;
} else {
is_special = GF_FALSE;
newBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);
if (!newBox) return GF_OUT_OF_MEM;
}
if (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {
memcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);
((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;
}
if (!newBox->type) newBox->type = type;
if (restore_type)
newBox->type = restore_type;
end = gf_bs_available(bs);
if (size - hdr_size > end ) {
newBox->size = size - hdr_size - end;
*outBox = newBox;
return GF_ISOM_INCOMPLETE_FILE;
}
newBox->size = size - hdr_size;
e = gf_isom_full_box_read(newBox, bs);
if (!e) e = gf_isom_box_read(newBox, bs);
if (e) {
if (gf_opts_get_bool(""core"", ""no-check""))
e = GF_OK;
}
newBox->size = size;
end = gf_bs_get_position(bs);
if (uncomp_bs) {
gf_free(uncomp_data);
gf_bs_del(uncomp_bs);
if (e) {
gf_isom_box_del(newBox);
*outBox = NULL;
return e;
}
size -= 8;
if (type==GF_ISOM_BOX_TYPE_MOOF) {
((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
}
else if (type==GF_ISOM_BOX_TYPE_MOOV) {
((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
((GF_MovieBox *)newBox)->file_offset = comp_start;
}
else if (type==GF_ISOM_BOX_TYPE_SIDX) {
((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
}
else if (type==GF_ISOM_BOX_TYPE_SSIX) {
((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
}
newBox->internal_flags = GF_ISOM_BOX_COMPRESSED;
}
if (e && (e != GF_ISOM_INCOMPLETE_FILE)) {
gf_isom_box_del(newBox);
*outBox = NULL;
if (!skip_logs) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box \""%s\"" (start ""LLU"") failed (%s) - skipping\n"", gf_4cc_to_str(type), start, gf_error_to_string(e)));
}
return e;
}
if (end-start > size) {
if (!skip_logs) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" size ""LLU"" (start ""LLU"") invalid (read ""LLU"")\n"", gf_4cc_to_str(type), size, start, (end-start) ));
}
gf_bs_seek(bs, start+size);
} else if (end-start < size) {
u32 to_skip = (u32) (size-(end-start));
if (!skip_logs) {
if ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" (start ""LLU"") has %u extra bytes\n"", gf_4cc_to_str(type), start, to_skip));
unused_bytes += to_skip;
}
}
gf_bs_skip_bytes(bs, to_skip);
}
*outBox = newBox;
return e;
}","GF_Err gf_isom_box_parse_ex(GF_Box **VAR_0, GF_BitStream *VAR_1, u32 VAR_2, Bool VAR_3)
{
u32 VAR_4, VAR_5, VAR_6, VAR_7;
u64 VAR_8, VAR_9, VAR_10, VAR_11;
char VAR_12[16];
GF_Err VAR_13;
GF_BitStream *VAR_14 = NULL;
u8 *VAR_15 = NULL;
u32 VAR_16=0;
GF_Box *VAR_17;
Bool VAR_18 = (gf_bs_get_cookie(VAR_1) & VAR_19 ) ? VAR_20 : VAR_21;
Bool VAR_22 = VAR_20;
if ((VAR_1 == NULL) || (VAR_0 == NULL) ) return VAR_23;
*VAR_0 = NULL;
if (gf_bs_available(VAR_1) < 8) {
return VAR_24;
}
VAR_10 = VAR_9 = gf_bs_get_position(VAR_1);
VAR_5 = 0;
VAR_8 = (u64) gf_bs_read_u32(VAR_1);
VAR_6 = 4;
if ((VAR_8 >= 2) && (VAR_8 <= 4)) {
VAR_8 = 4;
VAR_4 = VAR_25;
} else {
VAR_4 = gf_bs_read_u32(VAR_1);
VAR_6 += 4;
if (VAR_4 == VAR_26)
VAR_8 = 12;
if (!VAR_8) {
if (VAR_3) {
if (!VAR_18) {
GF_LOG(VAR_27, VAR_28, (""[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\n"", gf_4cc_to_str(VAR_4), VAR_4));
}
VAR_8 = gf_bs_available(VAR_1) + 8;
} else {
if (!VAR_18) {
GF_LOG(VAR_29, VAR_28, (""[iso file] Read Box type %s (0x%08X) at position ""VAR_30"" has size 0 but is not at root/file level, skipping\n"", gf_4cc_to_str(VAR_4), VAR_4, VAR_9));
return VAR_31;
}
return VAR_32;
}
}
if (VAR_3 && (VAR_8>=8)) {
Bool VAR_33 = VAR_21;
u8 *VAR_34 = NULL;
u32 VAR_35 = 0;
u32 VAR_36 = VAR_4;
if (VAR_4==GF_4CC('!', 'm', 'o', 'f')) {
VAR_33 = VAR_20;
VAR_4 = VAR_37;
}
else if (VAR_4==GF_4CC('!', 'm', 'o', 'v')) {
VAR_33 = VAR_20;
VAR_4 = VAR_38;
}
else if (VAR_4==GF_4CC('!', 's', 'i', 'x')) {
VAR_33 = VAR_20;
VAR_4 = VAR_39;
}
else if (VAR_4==GF_4CC('!', 's', 's', 'x')) {
VAR_33 = VAR_20;
VAR_4 = VAR_40;
}
if (VAR_33) {
VAR_34 = gf_malloc((u32) (VAR_8-8));
VAR_16 = (u32) (VAR_8 - 8);
gf_bs_read_data(VAR_1, VAR_34, VAR_16);
VAR_13 = gf_gz_decompress_payload(VAR_34, VAR_16, &VAR_15, &VAR_35);
if (VAR_13) {
GF_LOG(VAR_29, VAR_28, (""[iso file] Failed to uncompress payload for box type %s (0x%08X)\n"", gf_4cc_to_str(VAR_36), VAR_36));
return VAR_13;
}
VAR_8 = VAR_35 + 8;
VAR_14 = gf_bs_new(VAR_15, VAR_35, VAR_41);
VAR_1 = VAR_14;
VAR_9 = 0;
gf_free(VAR_34);
}
}
}
memset(VAR_12, 0, 16);
if (VAR_4 == VAR_42 ) {
if (gf_bs_available(VAR_1) < 16) {
return VAR_24;
}
gf_bs_read_data(VAR_1, VAR_12, 16);
VAR_6 += 16;
VAR_5 = gf_isom_solve_uuid_box(VAR_12);
}
if (VAR_8 == 1) {
if (gf_bs_available(VAR_1) < 8) {
return VAR_24;
}
VAR_8 = gf_bs_read_u64(VAR_1);
VAR_6 += 8;
}
if (!VAR_18)
GF_LOG(VAR_27, VAR_28, (""[iso file] Read Box type %s size ""VAR_43"" start ""VAR_43""\n"", gf_4cc_to_str(VAR_4), VAR_8,  VAR_9));
if ( VAR_8 < VAR_6 ) {
GF_LOG(VAR_27, VAR_28, (""[iso file] Box size ""VAR_43"" less than box header size %d\n"", VAR_8, VAR_6));
return VAR_44;
}
VAR_7 = 0;
if ((VAR_2==VAR_45) && (VAR_4==VAR_46) ) {
u64 VAR_47 = gf_bs_get_cookie(VAR_1);
VAR_7 = VAR_4;
if (VAR_47 & VAR_48)
VAR_4 = VAR_49;
else
VAR_4 = VAR_50;
}
if (VAR_2 && (VAR_2 == VAR_51)) {
VAR_17 = gf_isom_box_new(VAR_52);
if (!VAR_17) return VAR_53;
((GF_TrackReferenceTypeBox*)VAR_17)->reference_type = VAR_4;
} else if (VAR_2 && (VAR_2 == VAR_54)) {
VAR_17 = gf_isom_box_new(VAR_55);
if (!VAR_17) return VAR_53;
((GF_ItemReferenceTypeBox*)VAR_17)->reference_type = VAR_4;
} else if (VAR_2 && (VAR_2 == VAR_56)) {
VAR_17 = gf_isom_box_new(VAR_57);
if (!VAR_17) return VAR_53;
((GF_TrackGroupTypeBox*)VAR_17)->group_type = VAR_4;
} else if (VAR_2 && (VAR_2 == VAR_58)) {
VAR_17 = gf_isom_box_new(VAR_59);
if (!VAR_17) return VAR_53;
((GF_EntityToGroupTypeBox*)VAR_17)->grouping_type = VAR_4;
} else {
VAR_22 = VAR_21;
VAR_17 = gf_isom_box_new_ex(VAR_5 ? VAR_5 : VAR_4, VAR_2, VAR_18, VAR_3);
if (!VAR_17) return VAR_53;
}
if (VAR_4==VAR_42 && !VAR_22) {
memcpy(((GF_UUIDBox *)VAR_17)->uuid, VAR_12, 16);
((GF_UUIDBox *)VAR_17)->internal_4cc = VAR_5;
}
if (!VAR_17->type) VAR_17->type = VAR_4;
if (VAR_7)
VAR_17->type = VAR_7;
VAR_11 = gf_bs_available(VAR_1);
if (VAR_8 - VAR_6 > VAR_11 ) {
VAR_17->size = VAR_8 - VAR_6 - VAR_11;
*VAR_0 = VAR_17;
return VAR_24;
}
VAR_17->size = VAR_8 - VAR_6;
VAR_13 = gf_isom_full_box_read(VAR_17, VAR_1);
if (!VAR_13) VAR_13 = gf_isom_box_read(VAR_17, VAR_1);
if (VAR_13) {
if (gf_opts_get_bool(""core"", ""no-check""))
VAR_13 = VAR_32;
}
VAR_17->size = VAR_8;
VAR_11 = gf_bs_get_position(VAR_1);
if (VAR_14) {
gf_free(VAR_15);
gf_bs_del(VAR_14);
if (VAR_13) {
gf_isom_box_del(VAR_17);
*VAR_0 = NULL;
return VAR_13;
}
VAR_8 -= 8;
if (VAR_4==VAR_37) {
((GF_MovieFragmentBox *)VAR_17)->compressed_diff = (s32)VAR_8 - (s32)VAR_16;
}
else if (VAR_4==VAR_38) {
((GF_MovieBox *)VAR_17)->compressed_diff = (s32)VAR_8 - (s32)VAR_16;
((GF_MovieBox *)VAR_17)->file_offset = VAR_10;
}
else if (VAR_4==VAR_39) {
((GF_SegmentIndexBox *)VAR_17)->compressed_diff = (s32)VAR_8 - (s32)VAR_16;
}
else if (VAR_4==VAR_40) {
((GF_SubsegmentIndexBox *)VAR_17)->compressed_diff = (s32)VAR_8 - (s32)VAR_16;
}
VAR_17->internal_flags = VAR_60;
}
if (VAR_13 && (VAR_13 != VAR_24)) {
gf_isom_box_del(VAR_17);
*VAR_0 = NULL;
if (!VAR_18) {
GF_LOG(VAR_29, VAR_28, (""[iso file] Read Box \""%s\"" (start ""VAR_30"") failed (%s) - skipping\n"", gf_4cc_to_str(VAR_4), VAR_9, gf_error_to_string(VAR_13)));
}
return VAR_13;
}
if (VAR_11-VAR_9 > VAR_8) {
if (!VAR_18) {
GF_LOG(VAR_61, VAR_28, (""[iso file] Box \""%s\"" size ""VAR_30"" (start ""VAR_30"") invalid (read ""VAR_30"")\n"", gf_4cc_to_str(VAR_4), VAR_8, VAR_9, (VAR_11-VAR_9) ));
}
gf_bs_seek(VAR_1, VAR_9+VAR_8);
} else if (VAR_11-VAR_9 < VAR_8) {
u32 VAR_62 = (u32) (VAR_8-(VAR_11-VAR_9));
if (!VAR_18) {
if ((VAR_62!=4) || gf_bs_peek_bits(VAR_1, 32, 0)) {
GF_LOG(VAR_61, VAR_28, (""[iso file] Box \""%s\"" (start ""VAR_30"") has %u extra bytes\n"", gf_4cc_to_str(VAR_4), VAR_9, VAR_62));
VAR_63 += VAR_62;
}
}
gf_bs_skip_bytes(VAR_1, VAR_62);
}
*VAR_0 = VAR_17;
return VAR_13;
}",gpac/5b4a6417a90223f1ef6c0b41b055716f7bfbbca2/box_funcs.c/vul/before/0.json,"GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box)
{
	u32 type, uuid_type, hdr_size, restore_type;
	u64 size, start, comp_start, end;
	char uuid[16];
	GF_Err e;
	GF_BitStream *uncomp_bs = NULL;
	u8 *uncomp_data = NULL;
	u32 compressed_size=0;
	GF_Box *newBox;
	Bool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;
	Bool is_special = GF_TRUE;
	
	if ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;
	*outBox = NULL;
	if (gf_bs_available(bs) < 8) {
		return GF_ISOM_INCOMPLETE_FILE;
	}

	comp_start = start = gf_bs_get_position(bs);

	uuid_type = 0;
	size = (u64) gf_bs_read_u32(bs);
	hdr_size = 4;
	/*fix for some boxes found in some old hinted files*/
	if ((size >= 2) && (size <= 4)) {
		size = 4;
		type = GF_ISOM_BOX_TYPE_VOID;
	} else {
		type = gf_bs_read_u32(bs);
		hdr_size += 4;
		/*no size means till end of file - EXCEPT FOR some old QuickTime boxes...*/
		if (type == GF_ISOM_BOX_TYPE_TOTL)
			size = 12;
		if (!size) {
			if (is_root_box) {
				if (!skip_logs) {
					GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\n"", gf_4cc_to_str(type), type));
				}
				size = gf_bs_available(bs) + 8;
			} else {
				if (!skip_logs) {
					GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box type %s (0x%08X) at position ""LLU"" has size 0 but is not at root/file level !\n"", gf_4cc_to_str(type), type, start));
					return GF_ISOM_INVALID_FILE;
				}
				return GF_OK;
			}
		}
		if (is_root_box && (size>=8)) {
			Bool do_uncompress = GF_FALSE;
			u8 *compb = NULL;
			u32 osize = 0;
			u32 otype = type;
			if (type==GF_4CC('!', 'm', 'o', 'f')) {
				do_uncompress = GF_TRUE;
				type = GF_ISOM_BOX_TYPE_MOOF;
			}
			else if (type==GF_4CC('!', 'm', 'o', 'v')) {
				do_uncompress = GF_TRUE;
				type = GF_ISOM_BOX_TYPE_MOOV;
			}
			else if (type==GF_4CC('!', 's', 'i', 'x')) {
				do_uncompress = GF_TRUE;
				type = GF_ISOM_BOX_TYPE_SIDX;
			}
			else if (type==GF_4CC('!', 's', 's', 'x')) {
				do_uncompress = GF_TRUE;
				type = GF_ISOM_BOX_TYPE_SSIX;
			}

			if (do_uncompress) {
				compb = gf_malloc((u32) (size-8));

				compressed_size = (u32) (size - 8);
				gf_bs_read_data(bs, compb, compressed_size);
				e = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize);
				if (e) {
					GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Failed to uncompress payload for box type %s (0x%08X)\n"", gf_4cc_to_str(otype), otype));
					return e;
				}

				//keep size as complete box size for tests below
				size = osize + 8;
				uncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ);
				bs = uncomp_bs;
				start = 0;
				gf_free(compb);
			}
		}
	}
	/*handle uuid*/
	memset(uuid, 0, 16);
	if (type == GF_ISOM_BOX_TYPE_UUID ) {
		if (gf_bs_available(bs) < 16) {
			return GF_ISOM_INCOMPLETE_FILE;
		}
		gf_bs_read_data(bs, uuid, 16);
		hdr_size += 16;
		uuid_type = gf_isom_solve_uuid_box(uuid);
	}

	//handle large box
	if (size == 1) {
		if (gf_bs_available(bs) < 8) {
			return GF_ISOM_INCOMPLETE_FILE;
		}
		size = gf_bs_read_u64(bs);
		hdr_size += 8;
	}
	if (!skip_logs)
		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Read Box type %s size ""LLD"" start ""LLD""\n"", gf_4cc_to_str(type), size,  start));

	if ( size < hdr_size ) {
		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Box size ""LLD"" less than box header size %d\n"", size, hdr_size));
		return GF_ISOM_INVALID_FILE;
	}
	restore_type = 0;
	if ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) {
		u64 cookie = gf_bs_get_cookie(bs);
		restore_type = type;
		if (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK)
			type = GF_QT_SUBTYPE_RAW_VID;
		else
			type = GF_QT_SUBTYPE_RAW_AUD;

	}

	//some special boxes (references and track groups) are handled by a single generic box with an associated ref/group type
	if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {
		newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);
		if (!newBox) return GF_OUT_OF_MEM;
		((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;
	} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {
		newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);
		if (!newBox) return GF_OUT_OF_MEM;
		((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;
	} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {
		newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);
		if (!newBox) return GF_OUT_OF_MEM;
		((GF_TrackGroupTypeBox*)newBox)->group_type = type;
	} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {
		newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);
		if (!newBox) return GF_OUT_OF_MEM;
		((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;
	} else {
		//OK, create the box based on the type
		is_special = GF_FALSE;
		newBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);
		if (!newBox) return GF_OUT_OF_MEM;
	}

	//OK, init and read this box
	if (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {
		memcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);
		((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;
	}

	if (!newBox->type) newBox->type = type;
	if (restore_type)
		newBox->type = restore_type;

	end = gf_bs_available(bs);
	if (size - hdr_size > end ) {
		newBox->size = size - hdr_size - end;
		*outBox = newBox;
		return GF_ISOM_INCOMPLETE_FILE;
	}

	newBox->size = size - hdr_size;

	e = gf_isom_full_box_read(newBox, bs);
	if (!e) e = gf_isom_box_read(newBox, bs);
	if (e) {
		if (gf_opts_get_bool(""core"", ""no-check""))
			e = GF_OK;
	}
	newBox->size = size;
	end = gf_bs_get_position(bs);

	if (uncomp_bs) {
		gf_free(uncomp_data);
		gf_bs_del(uncomp_bs);
		if (e) {
			gf_isom_box_del(newBox);
			*outBox = NULL;
			return e;
		}
		//move size to real bitstream offsets for tests below
		size -= 8;
		//remember compressed vs real size info for moof in order to properly recompute data_offset/base_data_offset
		if (type==GF_ISOM_BOX_TYPE_MOOF) {
			((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
		}
		//remember compressed vs real size info for moov in order to properly recompute chunk offset
		else if (type==GF_ISOM_BOX_TYPE_MOOV) {
			((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
			((GF_MovieBox *)newBox)->file_offset = comp_start;
		}
		//remember compressed vs real size info for dump
		else if (type==GF_ISOM_BOX_TYPE_SIDX) {
			((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
		}
		//remember compressed vs real size info for dump
		else if (type==GF_ISOM_BOX_TYPE_SSIX) {
			((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
		}
		newBox->internal_flags = GF_ISOM_BOX_COMPRESSED;
	}


	if (e && (e != GF_ISOM_INCOMPLETE_FILE)) {
		gf_isom_box_del(newBox);
		*outBox = NULL;

		if (!skip_logs) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box \""%s\"" (start ""LLU"") failed (%s) - skipping\n"", gf_4cc_to_str(type), start, gf_error_to_string(e)));
		}
		//we don't try to reparse known boxes that have been failing (too dangerous)
		return e;
	}

	if (end-start > size) {
		if (!skip_logs) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" size ""LLU"" (start ""LLU"") invalid (read ""LLU"")\n"", gf_4cc_to_str(type), size, start, (end-start) ));
		}
		/*let's still try to load the file since no error was notified*/
		gf_bs_seek(bs, start+size);
	} else if (end-start < size) {
		u32 to_skip = (u32) (size-(end-start));
		if (!skip_logs) {
			if ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" (start ""LLU"") has %u extra bytes\n"", gf_4cc_to_str(type), start, to_skip));
				unused_bytes += to_skip;
			}
		}
		gf_bs_skip_bytes(bs, to_skip);
	}
	*outBox = newBox;

	return e;
}","GF_Err gf_isom_box_parse_ex(GF_Box **VAR_0, GF_BitStream *VAR_1, u32 VAR_2, Bool VAR_3)
{
	u32 VAR_4, VAR_5, VAR_6, VAR_7;
	u64 VAR_8, VAR_9, VAR_10, VAR_11;
	char VAR_12[16];
	GF_Err VAR_13;
	GF_BitStream *VAR_14 = NULL;
	u8 *VAR_15 = NULL;
	u32 VAR_16=0;
	GF_Box *VAR_17;
	Bool VAR_18 = (gf_bs_get_cookie(VAR_1) & VAR_19 ) ? VAR_20 : VAR_21;
	Bool VAR_22 = VAR_20;
	
	if ((VAR_1 == NULL) || (VAR_0 == NULL) ) return VAR_23;
	*VAR_0 = NULL;
	if (gf_bs_available(VAR_1) < 8) {
		return VAR_24;
	}

	VAR_10 = VAR_9 = gf_bs_get_position(VAR_1);

	VAR_5 = 0;
	VAR_8 = (u64) gf_bs_read_u32(VAR_1);
	VAR_6 = 4;
	/* COMMENT_0 */
	if ((VAR_8 >= 2) && (VAR_8 <= 4)) {
		VAR_8 = 4;
		VAR_4 = VAR_25;
	} else {
		VAR_4 = gf_bs_read_u32(VAR_1);
		VAR_6 += 4;
		/* COMMENT_1 */
		if (VAR_4 == VAR_26)
			VAR_8 = 12;
		if (!VAR_8) {
			if (VAR_3) {
				if (!VAR_18) {
					GF_LOG(VAR_27, VAR_28, (""[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\n"", gf_4cc_to_str(VAR_4), VAR_4));
				}
				VAR_8 = gf_bs_available(VAR_1) + 8;
			} else {
				if (!VAR_18) {
					GF_LOG(VAR_29, VAR_28, (""[iso file] Read Box type %s (0x%08X) at position ""VAR_30"" has size 0 but is not at root/file level !\n"", gf_4cc_to_str(VAR_4), VAR_4, VAR_9));
					return VAR_31;
				}
				return VAR_32;
			}
		}
		if (VAR_3 && (VAR_8>=8)) {
			Bool VAR_33 = VAR_21;
			u8 *VAR_34 = NULL;
			u32 VAR_35 = 0;
			u32 VAR_36 = VAR_4;
			if (VAR_4==GF_4CC('!', 'm', 'o', 'f')) {
				VAR_33 = VAR_20;
				VAR_4 = VAR_37;
			}
			else if (VAR_4==GF_4CC('!', 'm', 'o', 'v')) {
				VAR_33 = VAR_20;
				VAR_4 = VAR_38;
			}
			else if (VAR_4==GF_4CC('!', 's', 'i', 'x')) {
				VAR_33 = VAR_20;
				VAR_4 = VAR_39;
			}
			else if (VAR_4==GF_4CC('!', 's', 's', 'x')) {
				VAR_33 = VAR_20;
				VAR_4 = VAR_40;
			}

			if (VAR_33) {
				VAR_34 = gf_malloc((u32) (VAR_8-8));

				VAR_16 = (u32) (VAR_8 - 8);
				gf_bs_read_data(VAR_1, VAR_34, VAR_16);
				VAR_13 = gf_gz_decompress_payload(VAR_34, VAR_16, &VAR_15, &VAR_35);
				if (VAR_13) {
					GF_LOG(VAR_29, VAR_28, (""[iso file] Failed to uncompress payload for box type %s (0x%08X)\n"", gf_4cc_to_str(VAR_36), VAR_36));
					return VAR_13;
				}

				/* COMMENT_2 */
				VAR_8 = VAR_35 + 8;
				VAR_14 = gf_bs_new(VAR_15, VAR_35, VAR_41);
				VAR_1 = VAR_14;
				VAR_9 = 0;
				gf_free(VAR_34);
			}
		}
	}
	/* COMMENT_3 */
	memset(VAR_12, 0, 16);
	if (VAR_4 == VAR_42 ) {
		if (gf_bs_available(VAR_1) < 16) {
			return VAR_24;
		}
		gf_bs_read_data(VAR_1, VAR_12, 16);
		VAR_6 += 16;
		VAR_5 = gf_isom_solve_uuid_box(VAR_12);
	}

	/* COMMENT_4 */
	if (VAR_8 == 1) {
		if (gf_bs_available(VAR_1) < 8) {
			return VAR_24;
		}
		VAR_8 = gf_bs_read_u64(VAR_1);
		VAR_6 += 8;
	}
	if (!VAR_18)
		GF_LOG(VAR_27, VAR_28, (""[iso file] Read Box type %s size ""VAR_43"" start ""VAR_43""\n"", gf_4cc_to_str(VAR_4), VAR_8,  VAR_9));

	if ( VAR_8 < VAR_6 ) {
		GF_LOG(VAR_27, VAR_28, (""[iso file] Box size ""VAR_43"" less than box header size %d\n"", VAR_8, VAR_6));
		return VAR_31;
	}
	VAR_7 = 0;
	if ((VAR_2==VAR_44) && (VAR_4==VAR_45) ) {
		u64 VAR_46 = gf_bs_get_cookie(VAR_1);
		VAR_7 = VAR_4;
		if (VAR_46 & VAR_47)
			VAR_4 = VAR_48;
		else
			VAR_4 = VAR_49;

	}

	/* COMMENT_5 */
	if (VAR_2 && (VAR_2 == VAR_50)) {
		VAR_17 = gf_isom_box_new(VAR_51);
		if (!VAR_17) return VAR_52;
		((GF_TrackReferenceTypeBox*)VAR_17)->reference_type = VAR_4;
	} else if (VAR_2 && (VAR_2 == VAR_53)) {
		VAR_17 = gf_isom_box_new(VAR_54);
		if (!VAR_17) return VAR_52;
		((GF_ItemReferenceTypeBox*)VAR_17)->reference_type = VAR_4;
	} else if (VAR_2 && (VAR_2 == VAR_55)) {
		VAR_17 = gf_isom_box_new(VAR_56);
		if (!VAR_17) return VAR_52;
		((GF_TrackGroupTypeBox*)VAR_17)->group_type = VAR_4;
	} else if (VAR_2 && (VAR_2 == VAR_57)) {
		VAR_17 = gf_isom_box_new(VAR_58);
		if (!VAR_17) return VAR_52;
		((GF_EntityToGroupTypeBox*)VAR_17)->grouping_type = VAR_4;
	} else {
		/* COMMENT_6 */
		VAR_22 = VAR_21;
		VAR_17 = gf_isom_box_new_ex(VAR_5 ? VAR_5 : VAR_4, VAR_2, VAR_18, VAR_3);
		if (!VAR_17) return VAR_52;
	}

	/* COMMENT_7 */
	if (VAR_4==VAR_42 && !VAR_22) {
		memcpy(((GF_UUIDBox *)VAR_17)->uuid, VAR_12, 16);
		((GF_UUIDBox *)VAR_17)->internal_4cc = VAR_5;
	}

	if (!VAR_17->type) VAR_17->type = VAR_4;
	if (VAR_7)
		VAR_17->type = VAR_7;

	VAR_11 = gf_bs_available(VAR_1);
	if (VAR_8 - VAR_6 > VAR_11 ) {
		VAR_17->size = VAR_8 - VAR_6 - VAR_11;
		*VAR_0 = VAR_17;
		return VAR_24;
	}

	VAR_17->size = VAR_8 - VAR_6;

	VAR_13 = gf_isom_full_box_read(VAR_17, VAR_1);
	if (!VAR_13) VAR_13 = gf_isom_box_read(VAR_17, VAR_1);
	if (VAR_13) {
		if (gf_opts_get_bool(""core"", ""no-check""))
			VAR_13 = VAR_32;
	}
	VAR_17->size = VAR_8;
	VAR_11 = gf_bs_get_position(VAR_1);

	if (VAR_14) {
		gf_free(VAR_15);
		gf_bs_del(VAR_14);
		if (VAR_13) {
			gf_isom_box_del(VAR_17);
			*VAR_0 = NULL;
			return VAR_13;
		}
		/* COMMENT_8 */
		VAR_8 -= 8;
		/* COMMENT_9 */
		if (VAR_4==VAR_37) {
			((GF_MovieFragmentBox *)VAR_17)->compressed_diff = (s32)VAR_8 - (s32)VAR_16;
		}
		/* COMMENT_10 */
		else if (VAR_4==VAR_38) {
			((GF_MovieBox *)VAR_17)->compressed_diff = (s32)VAR_8 - (s32)VAR_16;
			((GF_MovieBox *)VAR_17)->file_offset = VAR_10;
		}
		/* COMMENT_11 */
		else if (VAR_4==VAR_39) {
			((GF_SegmentIndexBox *)VAR_17)->compressed_diff = (s32)VAR_8 - (s32)VAR_16;
		}
		/* COMMENT_11 */
		else if (VAR_4==VAR_40) {
			((GF_SubsegmentIndexBox *)VAR_17)->compressed_diff = (s32)VAR_8 - (s32)VAR_16;
		}
		VAR_17->internal_flags = VAR_59;
	}


	if (VAR_13 && (VAR_13 != VAR_24)) {
		gf_isom_box_del(VAR_17);
		*VAR_0 = NULL;

		if (!VAR_18) {
			GF_LOG(VAR_29, VAR_28, (""[iso file] Read Box \""%s\"" (start ""VAR_30"") failed (%s) - skipping\n"", gf_4cc_to_str(VAR_4), VAR_9, gf_error_to_string(VAR_13)));
		}
		/* COMMENT_12 */
		return VAR_13;
	}

	if (VAR_11-VAR_9 > VAR_8) {
		if (!VAR_18) {
			GF_LOG(VAR_60, VAR_28, (""[iso file] Box \""%s\"" size ""VAR_30"" (start ""VAR_30"") invalid (read ""VAR_30"")\n"", gf_4cc_to_str(VAR_4), VAR_8, VAR_9, (VAR_11-VAR_9) ));
		}
		/* COMMENT_13 */
		gf_bs_seek(VAR_1, VAR_9+VAR_8);
	} else if (VAR_11-VAR_9 < VAR_8) {
		u32 VAR_61 = (u32) (VAR_8-(VAR_11-VAR_9));
		if (!VAR_18) {
			if ((VAR_61!=4) || gf_bs_peek_bits(VAR_1, 32, 0)) {
				GF_LOG(VAR_60, VAR_28, (""[iso file] Box \""%s\"" (start ""VAR_30"") has %u extra bytes\n"", gf_4cc_to_str(VAR_4), VAR_9, VAR_61));
				VAR_62 += VAR_61;
			}
		}
		gf_bs_skip_bytes(VAR_1, VAR_61);
	}
	*VAR_0 = VAR_17;

	return VAR_13;
}",gpac/5b4a6417a90223f1ef6c0b41b055716f7bfbbca2/box_funcs.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -40,8 +40,8 @@
 				size = gf_bs_available(bs) + 8;
 			} else {
 				if (!skip_logs) {
-					GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box type %s (0x%08X) at position ""LLU"" has size 0 but is not at root/file level, skipping\n"", gf_4cc_to_str(type), type, start));
-					return GF_EOS;
+					GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box type %s (0x%08X) at position ""LLU"" has size 0 but is not at root/file level !\n"", gf_4cc_to_str(type), type, start));
+					return GF_ISOM_INVALID_FILE;
 				}
 				return GF_OK;
 			}","{'deleted_lines': ['\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box type %s (0x%08X) at position ""LLU"" has size 0 but is not at root/file level, skipping\\n"", gf_4cc_to_str(type), type, start));', '\t\t\t\t\treturn GF_EOS;'], 'added_lines': ['\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box type %s (0x%08X) at position ""LLU"" has size 0 but is not at root/file level !\\n"", gf_4cc_to_str(type), type, start));', '\t\t\t\t\treturn GF_ISOM_INVALID_FILE;']}",True,"A null pointer dereference vulnerability exists in gpac 1.1.0 in the gf_isom_parse_movie_boxes_internal function, which causes a segmentation fault and application crash.",5.5,MEDIUM,1,test,2021-12-13T10:18:32Z,4
CVE-2021-45767,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #1982,830548acd030467e857f4cf0b79af8ebf1e04dde,https://github.com/gpac/gpac/commit/830548acd030467e857f4cf0b79af8ebf1e04dde,src/laser/lsr_dec.c,lsr_read_paint,"static void lsr_read_paint(GF_LASeRCodec *lsr, SVG_Paint *paint, const char *name)
{
u32 val;
GF_LSR_READ_INT(lsr, val, 1, ""hasIndex"");
if (val) {
GF_LSR_READ_INT(lsr, val, lsr->colorIndexBits, name);
lsr_get_color(lsr, val, &paint->color);
paint->type = SVG_PAINT_COLOR;
paint->color.type = 0;
} else {
GF_LSR_READ_INT(lsr, val, 2, ""enum"");
switch (val) {
case 0:
GF_LSR_READ_INT(lsr, val, 2, ""choice"");
switch (val) {
case 0:
paint->type = SVG_PAINT_INHERIT;
break;
case 1:
paint->type = SVG_PAINT_COLOR;
paint->color.type = SVG_COLOR_CURRENTCOLOR;
break;
default:
paint->type = SVG_PAINT_NONE;
break;
}
break;
case 1:
{
XMLRI iri;
memset(&iri, 0, sizeof(XMLRI));
iri.type = 0xFF;
lsr_read_any_uri(lsr, &iri, name);
gf_node_unregister_iri(lsr->sg, &iri);
paint->type = SVG_PAINT_URI;
if (iri.string) {
paint->type = SVG_PAINT_URI;
paint->iri.type = XMLRI_STRING;
paint->iri.string = iri.string;
} else if (iri.target) {
paint->iri.type = XMLRI_ELEMENTID;
paint->iri.target = iri.target;
}
}
break;
case 2:
{
char *sysPaint=NULL;
lsr_read_byte_align_string(lsr, &sysPaint, ""systemsPaint"");
if (sysPaint) {
paint->type = SVG_PAINT_COLOR;
paint->color.type = gf_svg_get_system_paint_server_type(sysPaint);
gf_free(sysPaint);
}
}
break;
case 3:
lsr_read_extension(lsr, name);
break;
}
}
}","static void lsr_read_paint(GF_LASeRCodec *VAR_0, SVG_Paint *VAR_1, const char *VAR_2)
{
u32 VAR_3;
GF_LSR_READ_INT(VAR_0, VAR_3, 1, ""hasIndex"");
if (VAR_3) {
GF_LSR_READ_INT(VAR_0, VAR_3, VAR_0->colorIndexBits, VAR_2);
lsr_get_color(VAR_0, VAR_3, &VAR_1->color);
VAR_1->type = VAR_4;
VAR_1->color.type = 0;
} else {
GF_LSR_READ_INT(VAR_0, VAR_3, 2, ""enum"");
switch (VAR_3) {
case 0:
GF_LSR_READ_INT(VAR_0, VAR_3, 2, ""choice"");
switch (VAR_3) {
case 0:
VAR_1->type = VAR_5;
break;
case 1:
VAR_1->type = VAR_4;
VAR_1->color.type = VAR_6;
break;
default:
VAR_1->type = VAR_7;
break;
}
break;
case 1:
{
XMLRI VAR_8;
memset(&VAR_8, 0, sizeof(XMLRI));
VAR_8.type = 0xFF;
lsr_read_any_uri(VAR_0, &VAR_8, VAR_2);
gf_node_unregister_iri(VAR_0->sg, &VAR_8);
VAR_1->type = VAR_9;
if (VAR_8.string) {
VAR_1->type = VAR_9;
VAR_1->iri.type = VAR_10;
VAR_1->iri.string = VAR_8.string;
} else if (VAR_8.target) {
VAR_1->iri.type = VAR_11;
VAR_1->iri.target = VAR_8.target;
}
}
break;
case 2:
{
char *VAR_12=NULL;
lsr_read_byte_align_string(VAR_0, &VAR_12, ""systemsPaint"");
if (VAR_12) {
VAR_1->type = VAR_4;
VAR_1->color.type = gf_svg_get_system_paint_server_type(VAR_12);
gf_free(VAR_12);
}
}
break;
case 3:
lsr_read_extension(VAR_0, VAR_2);
break;
}
}
}",gpac/830548acd030467e857f4cf0b79af8ebf1e04dde/lsr_dec.c/vul/before/0.json,"static void lsr_read_paint(GF_LASeRCodec *lsr, SVG_Paint *paint, const char *name)
{
	u32 val;
	GF_LSR_READ_INT(lsr, val, 1, ""hasIndex"");
	if (val) {
		GF_LSR_READ_INT(lsr, val, lsr->colorIndexBits, name);
		lsr_get_color(lsr, val, &paint->color);
		paint->type = SVG_PAINT_COLOR;
		paint->color.type = 0;
	} else {
		GF_LSR_READ_INT(lsr, val, 2, ""enum"");
		switch (val) {
		case 0:
			GF_LSR_READ_INT(lsr, val, 2, ""choice"");
			switch (val) {
			case 0:
				paint->type = SVG_PAINT_INHERIT;
				break;
			case 1:
				paint->type = SVG_PAINT_COLOR;
				paint->color.type = SVG_COLOR_CURRENTCOLOR;
				break;
			default:
				paint->type = SVG_PAINT_NONE;
				break;
			}
			break;
		case 1:
		{
			XMLRI iri;
			memset(&iri, 0, sizeof(XMLRI));
			iri.type = 0xFF;
			lsr_read_any_uri(lsr, &iri, name);
			gf_node_unregister_iri(lsr->sg, &iri);
			gf_list_del_item(lsr->deferred_hrefs, &iri);

			paint->type = SVG_PAINT_URI;
			if (iri.string) {
				paint->type = SVG_PAINT_URI;
				paint->iri.type = XMLRI_STRING;
				paint->iri.string = iri.string;
			} else if (iri.target) {
				paint->iri.type = XMLRI_ELEMENTID;
				paint->iri.target = iri.target;
			}
		}
		break;
		case 2:
		{
			char *sysPaint=NULL;
			lsr_read_byte_align_string(lsr, &sysPaint, ""systemsPaint"");
			if (sysPaint) {
				paint->type = SVG_PAINT_COLOR;
				paint->color.type = gf_svg_get_system_paint_server_type(sysPaint);
				gf_free(sysPaint);
			}
		}
		break;
		case 3:
			lsr_read_extension(lsr, name);
			break;
		}
	}
}","static void lsr_read_paint(GF_LASeRCodec *VAR_0, SVG_Paint *VAR_1, const char *VAR_2)
{
	u32 VAR_3;
	GF_LSR_READ_INT(VAR_0, VAR_3, 1, ""hasIndex"");
	if (VAR_3) {
		GF_LSR_READ_INT(VAR_0, VAR_3, VAR_0->colorIndexBits, VAR_2);
		lsr_get_color(VAR_0, VAR_3, &VAR_1->color);
		VAR_1->type = VAR_4;
		VAR_1->color.type = 0;
	} else {
		GF_LSR_READ_INT(VAR_0, VAR_3, 2, ""enum"");
		switch (VAR_3) {
		case 0:
			GF_LSR_READ_INT(VAR_0, VAR_3, 2, ""choice"");
			switch (VAR_3) {
			case 0:
				VAR_1->type = VAR_5;
				break;
			case 1:
				VAR_1->type = VAR_4;
				VAR_1->color.type = VAR_6;
				break;
			default:
				VAR_1->type = VAR_7;
				break;
			}
			break;
		case 1:
		{
			XMLRI VAR_8;
			memset(&VAR_8, 0, sizeof(XMLRI));
			VAR_8.type = 0xFF;
			lsr_read_any_uri(VAR_0, &VAR_8, VAR_2);
			gf_node_unregister_iri(VAR_0->sg, &VAR_8);
			gf_list_del_item(VAR_0->deferred_hrefs, &VAR_8);

			VAR_1->type = VAR_9;
			if (VAR_8.string) {
				VAR_1->type = VAR_9;
				VAR_1->iri.type = VAR_10;
				VAR_1->iri.string = VAR_8.string;
			} else if (VAR_8.target) {
				VAR_1->iri.type = VAR_11;
				VAR_1->iri.target = VAR_8.target;
			}
		}
		break;
		case 2:
		{
			char *VAR_12=NULL;
			lsr_read_byte_align_string(VAR_0, &VAR_12, ""systemsPaint"");
			if (VAR_12) {
				VAR_1->type = VAR_4;
				VAR_1->color.type = gf_svg_get_system_paint_server_type(VAR_12);
				gf_free(VAR_12);
			}
		}
		break;
		case 3:
			lsr_read_extension(VAR_0, VAR_2);
			break;
		}
	}
}",gpac/830548acd030467e857f4cf0b79af8ebf1e04dde/lsr_dec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -32,6 +32,8 @@
 			iri.type = 0xFF;
 			lsr_read_any_uri(lsr, &iri, name);
 			gf_node_unregister_iri(lsr->sg, &iri);
+			gf_list_del_item(lsr->deferred_hrefs, &iri);
+
 			paint->type = SVG_PAINT_URI;
 			if (iri.string) {
 				paint->type = SVG_PAINT_URI;","{'deleted_lines': [], 'added_lines': ['\t\t\tgf_list_del_item(lsr->deferred_hrefs, &iri);', '']}",True,GPAC 1.1.0 was discovered to contain an invalid memory address dereference via the function lsr_read_id(). This vulnerability can lead to a Denial of Service (DoS).,5.5,MEDIUM,1,test,2021-12-14T09:00:33Z,4
CVE-2021-45266,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,gpac,fixed #1985,76b9e3f578a056fee07a4b317f5b36a83d01810e,https://github.com/gpac/gpac/commit/76b9e3f578a056fee07a4b317f5b36a83d01810e,src/laser/lsr_dec.c,lsr_translate_anim_trans_values,"static void lsr_translate_anim_trans_values(GF_LASeRCodec *lsr, SMIL_AnimateValues *val, u32 transform_type)
{
u32 count, i, coded_type;
SVG_Point_Angle *p;
SVG_Point *pt;
Fixed *f;
GF_List *l;
Bool handled = GF_FALSE;
coded_type = val->type;
switch(transform_type) {
case SVG_TRANSFORM_TRANSLATE:
val->type = SVG_Transform_Translate_datatype;
break;
case SVG_TRANSFORM_SCALE:
if (coded_type==8) handled = GF_TRUE;
val->type = SVG_Transform_Scale_datatype;
break;
case SVG_TRANSFORM_ROTATE:
if ((coded_type==8) || (coded_type==1)) handled = GF_TRUE;
val->type = SVG_Transform_Rotate_datatype;
break;
case SVG_TRANSFORM_SKEWX:
if ((coded_type==1) || (coded_type==4)) handled = GF_TRUE;
val->type = SVG_Transform_SkewX_datatype;
break;
case SVG_TRANSFORM_SKEWY:
if ((coded_type==1) || (coded_type==4)) handled = GF_TRUE;
val->type = SVG_Transform_SkewY_datatype;
break;
case SVG_TRANSFORM_MATRIX:
val->type = SVG_Transform_datatype;
break;
default:
GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (""[SVG Parsing] unknown datatype for animate transform.\n""));
break;
}
if (!handled) {
while (gf_list_count(val->values)) {
SMIL_AnimateValue a_val;
a_val.type = 0;
a_val.value = gf_list_pop_back(val->values);
lsr_delete_anim_value(lsr, &a_val, coded_type);
}
return;
}
count = gf_list_count(val->values);
if (!count) return;
if (transform_type==SVG_TRANSFORM_TRANSLATE)
return;
for (i=0; i<count; i++) {
void *a_val = gf_list_get(val->values, i);
switch (transform_type) {
case SVG_TRANSFORM_ROTATE:
GF_SAFEALLOC(p, SVG_Point_Angle);
if (!p) return;
if (coded_type==8) {
l = (GF_List*)a_val;
f = (Fixed*)gf_list_get(l, 0);
p->angle = *f;
f = (Fixed*)gf_list_get(l, 1);
if (f) p->x = *f;
f = (Fixed*)gf_list_get(l, 2);
if (f) p->y = *f;
while (gf_list_count(l)) {
f = (Fixed*)gf_list_last(l);
gf_list_rem_last(l);
gf_free(f);
}
gf_list_del(l);
} else if (coded_type==1) {
p->angle = ((SVG_Number *)a_val)->value;
gf_free(a_val);
}
p->angle = gf_muldiv(p->angle, GF_PI, INT2FIX(180) );
gf_list_rem(val->values, i);
gf_list_insert(val->values, p, i);
break;
case SVG_TRANSFORM_SKEWX:
case SVG_TRANSFORM_SKEWY:
f = (Fixed*)gf_malloc(sizeof(Fixed));
*f = ((SVG_Number *)a_val)->value;
gf_free(a_val);
gf_list_rem(val->values, i);
gf_list_insert(val->values, f, i);
break;
case SVG_TRANSFORM_SCALE:
pt = (SVG_Point*)gf_malloc(sizeof(SVG_Point));
l = (GF_List*)a_val;
f = (Fixed*)gf_list_get(l, 0);
if (f) pt->x = *f;
f = (Fixed*)gf_list_get(l, 1);
if (f) pt->y = *f;
else pt->y = pt->x;
while (gf_list_count(l)) {
f = (Fixed*)gf_list_last(l);
gf_list_rem_last(l);
gf_free(f);
}
gf_list_del(l);
gf_list_rem(val->values, i);
gf_list_insert(val->values, pt, i);
break;
default:
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[LASeR] unknown transform type %d\n"", transform_type));
break;
}
}
}","static void lsr_translate_anim_trans_values(GF_LASeRCodec *VAR_0, SMIL_AnimateValues *VAR_1, u32 VAR_2)
{
u32 VAR_3, VAR_4, VAR_5;
SVG_Point_Angle *VAR_6;
SVG_Point *VAR_7;
Fixed *VAR_8;
GF_List *VAR_9;
Bool VAR_10 = VAR_11;
VAR_5 = VAR_1->type;
switch(VAR_2) {
case VAR_12:
VAR_1->type = VAR_13;
break;
case VAR_14:
if (VAR_5==8) VAR_10 = VAR_15;
VAR_1->type = VAR_16;
break;
case VAR_17:
if ((VAR_5==8) || (VAR_5==1)) VAR_10 = VAR_15;
VAR_1->type = VAR_18;
break;
case VAR_19:
if ((VAR_5==1) || (VAR_5==4)) VAR_10 = VAR_15;
VAR_1->type = VAR_20;
break;
case VAR_21:
if ((VAR_5==1) || (VAR_5==4)) VAR_10 = VAR_15;
VAR_1->type = VAR_22;
break;
case VAR_23:
VAR_1->type = VAR_24;
break;
default:
GF_LOG(VAR_25, VAR_26, (""[SVG Parsing] unknown datatype for animate transform.\n""));
break;
}
if (!VAR_10) {
while (gf_list_count(VAR_1->values)) {
SMIL_AnimateValue VAR_27;
VAR_27.type = 0;
VAR_27.value = gf_list_pop_back(VAR_1->values);
lsr_delete_anim_value(VAR_0, &VAR_27, VAR_5);
}
return;
}
VAR_3 = gf_list_count(VAR_1->values);
if (!VAR_3) return;
if (VAR_2==VAR_12)
return;
for (VAR_4=0; VAR_4<VAR_3; VAR_4++) {
void *VAR_27 = gf_list_get(VAR_1->values, VAR_4);
switch (VAR_2) {
case VAR_17:
GF_SAFEALLOC(VAR_6, SVG_Point_Angle);
if (!VAR_6) return;
if (VAR_5==8) {
VAR_9 = (GF_List*)VAR_27;
VAR_8 = (Fixed*)gf_list_get(VAR_9, 0);
VAR_6->angle = *VAR_8;
VAR_8 = (Fixed*)gf_list_get(VAR_9, 1);
if (VAR_8) VAR_6->x = *VAR_8;
VAR_8 = (Fixed*)gf_list_get(VAR_9, 2);
if (VAR_8) VAR_6->y = *VAR_8;
while (gf_list_count(VAR_9)) {
VAR_8 = (Fixed*)gf_list_last(VAR_9);
gf_list_rem_last(VAR_9);
gf_free(VAR_8);
}
gf_list_del(VAR_9);
} else if (VAR_5==1) {
VAR_6->angle = ((SVG_Number *)VAR_27)->value;
gf_free(VAR_27);
}
VAR_6->angle = gf_muldiv(VAR_6->angle, VAR_28, INT2FIX(180) );
gf_list_rem(VAR_1->values, VAR_4);
gf_list_insert(VAR_1->values, VAR_6, VAR_4);
break;
case VAR_19:
case VAR_21:
VAR_8 = (Fixed*)gf_malloc(sizeof(Fixed));
*VAR_8 = ((SVG_Number *)VAR_27)->value;
gf_free(VAR_27);
gf_list_rem(VAR_1->values, VAR_4);
gf_list_insert(VAR_1->values, VAR_8, VAR_4);
break;
case VAR_14:
VAR_7 = (SVG_Point*)gf_malloc(sizeof(SVG_Point));
VAR_9 = (GF_List*)VAR_27;
VAR_8 = (Fixed*)gf_list_get(VAR_9, 0);
if (VAR_8) VAR_7->x = *VAR_8;
VAR_8 = (Fixed*)gf_list_get(VAR_9, 1);
if (VAR_8) VAR_7->y = *VAR_8;
else VAR_7->y = VAR_7->x;
while (gf_list_count(VAR_9)) {
VAR_8 = (Fixed*)gf_list_last(VAR_9);
gf_list_rem_last(VAR_9);
gf_free(VAR_8);
}
gf_list_del(VAR_9);
gf_list_rem(VAR_1->values, VAR_4);
gf_list_insert(VAR_1->values, VAR_7, VAR_4);
break;
default:
GF_LOG(VAR_25, VAR_29, (""[LASeR] unknown transform type %d\n"", VAR_2));
break;
}
}
}",gpac/76b9e3f578a056fee07a4b317f5b36a83d01810e/lsr_dec.c/vul/before/0.json,"static void lsr_translate_anim_trans_values(GF_LASeRCodec *lsr, SMIL_AnimateValues *val, u32 transform_type)
{
	u32 count, i, coded_type;
	SVG_Point_Angle *p;
	SVG_Point *pt;
	Fixed *f;
	GF_List *l;
	Bool handled = GF_FALSE;

	coded_type = val->type;
	switch(transform_type) {
	case SVG_TRANSFORM_TRANSLATE:
		val->type = SVG_Transform_Translate_datatype;
		break;
	case SVG_TRANSFORM_SCALE:
		if (coded_type==8) handled = GF_TRUE;
		val->type = SVG_Transform_Scale_datatype;
		break;
	case SVG_TRANSFORM_ROTATE:
		if ((coded_type==8) || (coded_type==1)) handled = GF_TRUE;
		val->type = SVG_Transform_Rotate_datatype;
		break;
	case SVG_TRANSFORM_SKEWX:
		if ((coded_type==1) || (coded_type==4)) handled = GF_TRUE;
		val->type = SVG_Transform_SkewX_datatype;
		break;
	case SVG_TRANSFORM_SKEWY:
		if ((coded_type==1) || (coded_type==4)) handled = GF_TRUE;
		val->type = SVG_Transform_SkewY_datatype;
		break;
	case SVG_TRANSFORM_MATRIX:
		val->type = SVG_Transform_datatype;
		break;
	default:
		GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (""[SVG Parsing] unknown datatype for animate transform.\n""));
		break;
	}

	if (!handled) {
		while (gf_list_count(val->values)) {
			SMIL_AnimateValue a_val;
			a_val.type = 0;
			a_val.value = gf_list_pop_back(val->values);
			lsr_delete_anim_value(lsr, &a_val, coded_type);
		}
		return;
	}

	count = gf_list_count(val->values);
	if (!count) return;

	if (transform_type==SVG_TRANSFORM_TRANSLATE)
		return;

	for (i=0; i<count; i++) {
		void *a_val = gf_list_get(val->values, i);
		switch (transform_type) {
		case SVG_TRANSFORM_ROTATE:
			GF_SAFEALLOC(p, SVG_Point_Angle);
			if (!p) return;

			if (coded_type==8) {
				l = (GF_List*)a_val;
				f = (Fixed*)gf_list_get(l, 0);
				if (f) p->angle = *f;
				f = (Fixed*)gf_list_get(l, 1);
				if (f) p->x = *f;
				f = (Fixed*)gf_list_get(l, 2);
				if (f) p->y = *f;
				while (gf_list_count(l)) {
					f = (Fixed*)gf_list_last(l);
					gf_list_rem_last(l);
					gf_free(f);
				}
				gf_list_del(l);
			} else if (coded_type==1) {
				p->angle = ((SVG_Number *)a_val)->value;
				gf_free(a_val);
			}
			p->angle = gf_muldiv(p->angle, GF_PI, INT2FIX(180) );
			gf_list_rem(val->values, i);
			gf_list_insert(val->values, p, i);
			break;
		case SVG_TRANSFORM_SKEWX:
		case SVG_TRANSFORM_SKEWY:
			f = (Fixed*)gf_malloc(sizeof(Fixed));
			*f = ((SVG_Number *)a_val)->value;
			gf_free(a_val);
			gf_list_rem(val->values, i);
			gf_list_insert(val->values, f, i);
			break;
		case SVG_TRANSFORM_SCALE:
			pt = (SVG_Point*)gf_malloc(sizeof(SVG_Point));
			l = (GF_List*)a_val;
			f = (Fixed*)gf_list_get(l, 0);
			if (f) pt->x = *f;
			f = (Fixed*)gf_list_get(l, 1);
			if (f) pt->y = *f;
			else pt->y = pt->x;
			while (gf_list_count(l)) {
				f = (Fixed*)gf_list_last(l);
				gf_list_rem_last(l);
				gf_free(f);
			}
			gf_list_del(l);
			gf_list_rem(val->values, i);
			gf_list_insert(val->values, pt, i);
			break;
		default:
			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[LASeR] unknown transform type %d\n"", transform_type));
			break;
		}
	}
}","static void lsr_translate_anim_trans_values(GF_LASeRCodec *VAR_0, SMIL_AnimateValues *VAR_1, u32 VAR_2)
{
	u32 VAR_3, VAR_4, VAR_5;
	SVG_Point_Angle *VAR_6;
	SVG_Point *VAR_7;
	Fixed *VAR_8;
	GF_List *VAR_9;
	Bool VAR_10 = VAR_11;

	VAR_5 = VAR_1->type;
	switch(VAR_2) {
	case VAR_12:
		VAR_1->type = VAR_13;
		break;
	case VAR_14:
		if (VAR_5==8) VAR_10 = VAR_15;
		VAR_1->type = VAR_16;
		break;
	case VAR_17:
		if ((VAR_5==8) || (VAR_5==1)) VAR_10 = VAR_15;
		VAR_1->type = VAR_18;
		break;
	case VAR_19:
		if ((VAR_5==1) || (VAR_5==4)) VAR_10 = VAR_15;
		VAR_1->type = VAR_20;
		break;
	case VAR_21:
		if ((VAR_5==1) || (VAR_5==4)) VAR_10 = VAR_15;
		VAR_1->type = VAR_22;
		break;
	case VAR_23:
		VAR_1->type = VAR_24;
		break;
	default:
		GF_LOG(VAR_25, VAR_26, (""[SVG Parsing] unknown datatype for animate transform.\n""));
		break;
	}

	if (!VAR_10) {
		while (gf_list_count(VAR_1->values)) {
			SMIL_AnimateValue VAR_27;
			VAR_27.type = 0;
			VAR_27.value = gf_list_pop_back(VAR_1->values);
			lsr_delete_anim_value(VAR_0, &VAR_27, VAR_5);
		}
		return;
	}

	VAR_3 = gf_list_count(VAR_1->values);
	if (!VAR_3) return;

	if (VAR_2==VAR_12)
		return;

	for (VAR_4=0; VAR_4<VAR_3; VAR_4++) {
		void *VAR_27 = gf_list_get(VAR_1->values, VAR_4);
		switch (VAR_2) {
		case VAR_17:
			GF_SAFEALLOC(VAR_6, SVG_Point_Angle);
			if (!VAR_6) return;

			if (VAR_5==8) {
				VAR_9 = (GF_List*)VAR_27;
				VAR_8 = (Fixed*)gf_list_get(VAR_9, 0);
				if (VAR_8) VAR_6->angle = *VAR_8;
				VAR_8 = (Fixed*)gf_list_get(VAR_9, 1);
				if (VAR_8) VAR_6->x = *VAR_8;
				VAR_8 = (Fixed*)gf_list_get(VAR_9, 2);
				if (VAR_8) VAR_6->y = *VAR_8;
				while (gf_list_count(VAR_9)) {
					VAR_8 = (Fixed*)gf_list_last(VAR_9);
					gf_list_rem_last(VAR_9);
					gf_free(VAR_8);
				}
				gf_list_del(VAR_9);
			} else if (VAR_5==1) {
				VAR_6->angle = ((SVG_Number *)VAR_27)->value;
				gf_free(VAR_27);
			}
			VAR_6->angle = gf_muldiv(VAR_6->angle, VAR_28, INT2FIX(180) );
			gf_list_rem(VAR_1->values, VAR_4);
			gf_list_insert(VAR_1->values, VAR_6, VAR_4);
			break;
		case VAR_19:
		case VAR_21:
			VAR_8 = (Fixed*)gf_malloc(sizeof(Fixed));
			*VAR_8 = ((SVG_Number *)VAR_27)->value;
			gf_free(VAR_27);
			gf_list_rem(VAR_1->values, VAR_4);
			gf_list_insert(VAR_1->values, VAR_8, VAR_4);
			break;
		case VAR_14:
			VAR_7 = (SVG_Point*)gf_malloc(sizeof(SVG_Point));
			VAR_9 = (GF_List*)VAR_27;
			VAR_8 = (Fixed*)gf_list_get(VAR_9, 0);
			if (VAR_8) VAR_7->x = *VAR_8;
			VAR_8 = (Fixed*)gf_list_get(VAR_9, 1);
			if (VAR_8) VAR_7->y = *VAR_8;
			else VAR_7->y = VAR_7->x;
			while (gf_list_count(VAR_9)) {
				VAR_8 = (Fixed*)gf_list_last(VAR_9);
				gf_list_rem_last(VAR_9);
				gf_free(VAR_8);
			}
			gf_list_del(VAR_9);
			gf_list_rem(VAR_1->values, VAR_4);
			gf_list_insert(VAR_1->values, VAR_7, VAR_4);
			break;
		default:
			GF_LOG(VAR_25, VAR_29, (""[LASeR] unknown transform type %d\n"", VAR_2));
			break;
		}
	}
}",gpac/76b9e3f578a056fee07a4b317f5b36a83d01810e/lsr_dec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -62,7 +62,7 @@
 			if (coded_type==8) {
 				l = (GF_List*)a_val;
 				f = (Fixed*)gf_list_get(l, 0);
-				p->angle = *f;
+				if (f) p->angle = *f;
 				f = (Fixed*)gf_list_get(l, 1);
 				if (f) p->x = *f;
 				f = (Fixed*)gf_list_get(l, 2);","{'deleted_lines': ['\t\t\t\tp->angle = *f;'], 'added_lines': ['\t\t\t\tif (f) p->angle = *f;']}",True,"A null pointer dereference vulnerability exists in gpac 1.1.0 via the lsr_read_anim_values_ex function, which causes a segmentation fault and application crash.",7.5,HIGH,2,test,2021-12-14T09:53:30Z,4
CVE-2021-46507,['CWE-674'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,pcmacdon/jsish,"Fixes #54

FossilOrigin-Name: e8cfa1f794ef05c67d00ebb5575c08f3987e71709bca5072cf2a7924870ae0e5",b99d9eac3d01d3f9ea8959aed092168c0aadd448,https://github.com/pcmacdon/jsish/commit/b99d9eac3d01d3f9ea8959aed092168c0aadd448,src/jsiValue.c,Jsi_ValueToString,"const char* Jsi_ValueToString(Jsi_Interp *interp, Jsi_Value *v, int *lenPtr)
{
Jsi_Number d;
const char *ntxt = ""undefined"";
int kflag = 1;
int isKey = 0;
char *key = NULL;
if (!v)
goto done;
if (lenPtr) *lenPtr = 0;
char unibuf[JSI_MAX_NUMBER_STRING*2];
switch(v->vt) {
case JSI_VT_STRING:
ntxt = v->d.s.str;
goto done;
case JSI_VT_UNDEF:
break;
case JSI_VT_BOOL:
ntxt = v->d.val ? ""true"":""false"";
break;
case JSI_VT_NULL:
ntxt = ""null"";
break;
case JSI_VT_NUMBER: {
d = v->d.num;
fmtnum:
if (Jsi_NumberIsInteger(d)) {
Jsi_NumberItoA10((Jsi_Wide)d, unibuf, sizeof(unibuf));
kflag = 0;
ntxt = unibuf;
} else if (Jsi_NumberIsNormal(d)) {
Jsi_NumberDtoA(interp, d, unibuf, sizeof(unibuf), 0);
kflag = 0;
ntxt = unibuf;
} else if (Jsi_NumberIsNaN(v->d.num)) {
ntxt = ""NaN"";
} else {
int s = Jsi_NumberIsInfinity(d);
if (s > 0) ntxt = ""Infinity"";
else if (s < 0) ntxt = ""-Infinity"";
else Jsi_LogBug(""Ieee function got problem"");
}
break;
}
case JSI_VT_OBJECT: {
Jsi_Obj *obj = v->d.obj;
switch(obj->ot) {
case JSI_OT_STRING:
ntxt = obj->d.s.str;
goto done;
case JSI_OT_BOOL:
ntxt = obj->d.val ? ""true"":""false"";
break;
case JSI_OT_NUMBER:
d = obj->d.num;
goto fmtnum;
break;
default:
ntxt = ""[object Object]"";
break;
}
break;
}
default:
Jsi_LogBug(""Convert a unknown type: 0x%x to string"", v->vt);
break;
}
Jsi_ValueReset(interp, &v);
if (!kflag) {
Jsi_ValueMakeStringDup(interp, &v, ntxt);
return Jsi_ValueString(interp, v, lenPtr);
}
key = jsi_KeyFind(interp, ntxt, 0, &isKey);
if (key)
Jsi_ValueMakeStringKey(interp, &v, key);
else
Jsi_ValueMakeString(interp, &v, ntxt);
ntxt = v->d.s.str;
done:
if (lenPtr) *lenPtr = Jsi_Strlen(ntxt);
return ntxt;
}","const char* Jsi_ValueToString(Jsi_Interp *VAR_0, Jsi_Value *VAR_1, int *VAR_2)
{
Jsi_Number VAR_3;
const char *VAR_4 = ""undefined"";
int VAR_5 = 1;
int VAR_6 = 0;
char *VAR_7 = NULL;
if (!VAR_1)
goto done;
if (VAR_2) *VAR_2 = 0;
char VAR_8[VAR_9*2];
switch(VAR_1->vt) {
case VAR_10:
VAR_4 = VAR_1->d.s.str;
goto done;
case VAR_11:
break;
case VAR_12:
VAR_4 = VAR_1->d.val ? ""true"":""false"";
break;
case VAR_13:
VAR_4 = ""null"";
break;
case VAR_14: {
VAR_3 = VAR_1->d.num;
fmtnum:
if (Jsi_NumberIsInteger(VAR_3)) {
Jsi_NumberItoA10((Jsi_Wide)VAR_3, VAR_8, sizeof(VAR_8));
VAR_5 = 0;
VAR_4 = VAR_8;
} else if (Jsi_NumberIsNormal(VAR_3)) {
Jsi_NumberDtoA(VAR_0, VAR_3, VAR_8, sizeof(VAR_8), 0);
VAR_5 = 0;
VAR_4 = VAR_8;
} else if (Jsi_NumberIsNaN(VAR_1->d.num)) {
VAR_4 = ""NaN"";
} else {
int VAR_15 = Jsi_NumberIsInfinity(VAR_3);
if (VAR_15 > 0) VAR_4 = ""Infinity"";
else if (VAR_15 < 0) VAR_4 = ""-Infinity"";
else Jsi_LogBug(""Ieee function got problem"");
}
break;
}
case VAR_16: {
Jsi_Obj *VAR_17 = VAR_1->d.obj;
switch(VAR_17->ot) {
case VAR_18:
VAR_4 = VAR_17->d.s.str;
goto done;
case VAR_19:
VAR_4 = VAR_17->d.val ? ""true"":""false"";
break;
case VAR_20:
VAR_3 = VAR_17->d.num;
goto fmtnum;
break;
default:
VAR_4 = ""[object Object]"";
break;
}
break;
}
default:
Jsi_LogBug(""Convert a unknown type: 0x%x to string"", VAR_1->vt);
break;
}
Jsi_ValueReset(VAR_0, &VAR_1);
if (!VAR_5) {
Jsi_ValueMakeStringDup(VAR_0, &VAR_1, VAR_4);
return Jsi_ValueString(VAR_0, VAR_1, VAR_2);
}
VAR_7 = jsi_KeyFind(VAR_0, VAR_4, 0, &VAR_6);
if (VAR_7)
Jsi_ValueMakeStringKey(VAR_0, &VAR_1, VAR_7);
else
Jsi_ValueMakeString(VAR_0, &VAR_1, VAR_4);
VAR_4 = VAR_1->d.s.str;
done:
if (VAR_2) *VAR_2 = Jsi_Strlen(VAR_4);
return VAR_4;
}",pcmacdon/jsish/b99d9eac3d01d3f9ea8959aed092168c0aadd448/jsiValue.c/vul/before/0.json,"const char* Jsi_ValueToString(Jsi_Interp *interp, Jsi_Value *v, int *lenPtr)
{
    Jsi_Number d;
    const char *ntxt = ""undefined"";
    int kflag = 1;
    int isKey = 0;
    char *key = NULL;
    if (!v)
        goto done;
    if (lenPtr) *lenPtr = 0;
    char unibuf[JSI_MAX_NUMBER_STRING*2];
    switch(v->vt) {
        case JSI_VT_STRING:
            ntxt = v->d.s.str;
            goto done;
        case JSI_VT_UNDEF:
            break;
        case JSI_VT_BOOL:
            ntxt = v->d.val ? ""true"":""false"";
            break;
        case JSI_VT_NULL:
            ntxt = ""null"";
            break;
        case JSI_VT_NUMBER: {
            d = v->d.num;
fmtnum:
            if (Jsi_NumberIsInteger(d)) {
                Jsi_NumberItoA10((Jsi_Wide)d, unibuf, sizeof(unibuf));
                kflag = 0;
                ntxt = unibuf;
            } else if (Jsi_NumberIsNormal(d)) {
                Jsi_NumberDtoA(interp, d, unibuf, sizeof(unibuf), 0);
                kflag = 0;
                ntxt = unibuf;
            } else if (Jsi_NumberIsNaN(v->d.num)) {
                ntxt = ""NaN"";
            } else {
                int s = Jsi_NumberIsInfinity(d);
                if (s > 0) ntxt = ""Infinity"";
                else if (s < 0) ntxt = ""-Infinity"";
                else if (!interp->logMsgDepth) Jsi_LogBug(""Ieee function got problem"");
            }
            break;
        }
        case JSI_VT_OBJECT: {
            Jsi_Obj *obj = v->d.obj;
            switch(obj->ot) {
                case JSI_OT_STRING:
                    ntxt = obj->d.s.str;
                    goto done;
                case JSI_OT_BOOL:
                    ntxt = obj->d.val ? ""true"":""false"";
                    break;
                case JSI_OT_NUMBER:
                    d = obj->d.num;
                    goto fmtnum;
                    break;
                default:
                    ntxt = ""[object Object]"";
                    break;
            }
            break;
        }
        default:
            if (!interp->logMsgDepth) Jsi_LogBug(""Convert a unknown type: 0x%x to string"", v->vt);
            break;
    }
    Jsi_ValueReset(interp, &v);
    if (!kflag) {
        Jsi_ValueMakeStringDup(interp, &v, ntxt);
        return Jsi_ValueString(interp, v, lenPtr);
    }
    
    key = jsi_KeyFind(interp, ntxt, 0, &isKey);
    if (key)
        Jsi_ValueMakeStringKey(interp, &v, key);
    else
        Jsi_ValueMakeString(interp, &v, ntxt);
    ntxt = v->d.s.str;
    
done:
    if (lenPtr) *lenPtr = Jsi_Strlen(ntxt);
    return ntxt;
}","const char* Jsi_ValueToString(Jsi_Interp *VAR_0, Jsi_Value *VAR_1, int *VAR_2)
{
    Jsi_Number VAR_3;
    const char *VAR_4 = ""undefined"";
    int VAR_5 = 1;
    int VAR_6 = 0;
    char *VAR_7 = NULL;
    if (!VAR_1)
        goto done;
    if (VAR_2) *VAR_2 = 0;
    char VAR_8[VAR_9*2];
    switch(VAR_1->vt) {
        case VAR_10:
            VAR_4 = VAR_1->d.s.str;
            goto done;
        case VAR_11:
            break;
        case VAR_12:
            VAR_4 = VAR_1->d.val ? ""true"":""false"";
            break;
        case VAR_13:
            VAR_4 = ""null"";
            break;
        case VAR_14: {
            VAR_3 = VAR_1->d.num;
fmtnum:
            if (Jsi_NumberIsInteger(VAR_3)) {
                Jsi_NumberItoA10((Jsi_Wide)VAR_3, VAR_8, sizeof(VAR_8));
                VAR_5 = 0;
                VAR_4 = VAR_8;
            } else if (Jsi_NumberIsNormal(VAR_3)) {
                Jsi_NumberDtoA(VAR_0, VAR_3, VAR_8, sizeof(VAR_8), 0);
                VAR_5 = 0;
                VAR_4 = VAR_8;
            } else if (Jsi_NumberIsNaN(VAR_1->d.num)) {
                VAR_4 = ""NaN"";
            } else {
                int VAR_15 = Jsi_NumberIsInfinity(VAR_3);
                if (VAR_15 > 0) VAR_4 = ""Infinity"";
                else if (VAR_15 < 0) VAR_4 = ""-Infinity"";
                else if (!VAR_0->logMsgDepth) Jsi_LogBug(""Ieee function got problem"");
            }
            break;
        }
        case VAR_16: {
            Jsi_Obj *VAR_17 = VAR_1->d.obj;
            switch(VAR_17->ot) {
                case VAR_18:
                    VAR_4 = VAR_17->d.s.str;
                    goto done;
                case VAR_19:
                    VAR_4 = VAR_17->d.val ? ""true"":""false"";
                    break;
                case VAR_20:
                    VAR_3 = VAR_17->d.num;
                    goto fmtnum;
                    break;
                default:
                    VAR_4 = ""[object Object]"";
                    break;
            }
            break;
        }
        default:
            if (!VAR_0->logMsgDepth) Jsi_LogBug(""Convert a unknown type: 0x%x to string"", VAR_1->vt);
            break;
    }
    Jsi_ValueReset(VAR_0, &VAR_1);
    if (!VAR_5) {
        Jsi_ValueMakeStringDup(VAR_0, &VAR_1, VAR_4);
        return Jsi_ValueString(VAR_0, VAR_1, VAR_2);
    }
    
    VAR_7 = jsi_KeyFind(VAR_0, VAR_4, 0, &VAR_6);
    if (VAR_7)
        Jsi_ValueMakeStringKey(VAR_0, &VAR_1, VAR_7);
    else
        Jsi_ValueMakeString(VAR_0, &VAR_1, VAR_4);
    VAR_4 = VAR_1->d.s.str;
    
done:
    if (VAR_2) *VAR_2 = Jsi_Strlen(VAR_4);
    return VAR_4;
}",pcmacdon/jsish/b99d9eac3d01d3f9ea8959aed092168c0aadd448/jsiValue.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -38,7 +38,7 @@
                 int s = Jsi_NumberIsInfinity(d);
                 if (s > 0) ntxt = ""Infinity"";
                 else if (s < 0) ntxt = ""-Infinity"";
-                else Jsi_LogBug(""Ieee function got problem"");
+                else if (!interp->logMsgDepth) Jsi_LogBug(""Ieee function got problem"");
             }
             break;
         }
@@ -62,7 +62,7 @@
             break;
         }
         default:
-            Jsi_LogBug(""Convert a unknown type: 0x%x to string"", v->vt);
+            if (!interp->logMsgDepth) Jsi_LogBug(""Convert a unknown type: 0x%x to string"", v->vt);
             break;
     }
     Jsi_ValueReset(interp, &v);","{'deleted_lines': ['                else Jsi_LogBug(""Ieee function got problem"");', '            Jsi_LogBug(""Convert a unknown type: 0x%x to string"", v->vt);'], 'added_lines': ['                else if (!interp->logMsgDepth) Jsi_LogBug(""Ieee function got problem"");', '            if (!interp->logMsgDepth) Jsi_LogBug(""Convert a unknown type: 0x%x to string"", v->vt);']}",True,Jsish v3.5.0 was discovered to contain a stack overflow via Jsi_LogMsg at src/jsiUtils.c.,5.5,MEDIUM,1,test,2021-12-27T21:20:29Z,4
CVE-2021-46499,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,pcmacdon/jsish,"Fixes #76

FossilOrigin-Name: 1a370f5a3fc952b9f433f5607a68f83871294222452b85a5092bde44c309a7ce",9c9dbe59760a660e21d69d5cf6007c9ccbb5c9a3,https://github.com/pcmacdon/jsish/commit/9c9dbe59760a660e21d69d5cf6007c9ccbb5c9a3,src/jsiObj.c,Jsi_ObjArraySet,"Jsi_RC Jsi_ObjArraySet(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *value, int arrayindex)
{
int m, n = arrayindex;
if (Jsi_ObjArraySizer(interp, obj, n) <= 0)
return JSI_ERROR;
if (obj->arr[n] == value)
return JSI_OK;
if (obj->arr[n])
Jsi_DecrRefCount(interp, obj->arr[n]);
Assert(obj->arrCnt<=obj->arrMaxSize);
obj->arr[n] = value;
if (value)
Jsi_IncrRefCount(interp, value);
if (value && value->vt == JSI_VT_OBJECT)
jsi_ObjInsertObjCheck(interp, obj, value, 1);
m = Jsi_ObjGetLength(interp, obj);
if ((n+1) > m)
Jsi_ObjSetLength(interp, obj, n+1);
return JSI_OK;
}","Jsi_RC Jsi_ObjArraySet(Jsi_Interp *VAR_0, Jsi_Obj *VAR_1, Jsi_Value *VAR_2, int VAR_3)
{
int VAR_4, VAR_5 = VAR_3;
if (Jsi_ObjArraySizer(VAR_0, VAR_1, VAR_5) <= 0)
return VAR_6;
if (VAR_1->arr[VAR_5] == VAR_2)
return VAR_7;
if (VAR_1->arr[VAR_5])
Jsi_DecrRefCount(VAR_0, VAR_1->arr[VAR_5]);
Assert(VAR_1->arrCnt<=VAR_1->arrMaxSize);
VAR_1->arr[VAR_5] = VAR_2;
if (VAR_2)
Jsi_IncrRefCount(VAR_0, VAR_2);
if (VAR_2 && VAR_2->vt == VAR_8)
jsi_ObjInsertObjCheck(VAR_0, VAR_1, VAR_2, 1);
VAR_4 = Jsi_ObjGetLength(VAR_0, VAR_1);
if ((VAR_5+1) > VAR_4)
Jsi_ObjSetLength(VAR_0, VAR_1, VAR_5+1);
return VAR_7;
}",pcmacdon/jsish/9c9dbe59760a660e21d69d5cf6007c9ccbb5c9a3/jsiObj.c/vul/before/0.json,"Jsi_RC Jsi_ObjArraySet(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *value, int arrayindex)
{
    int m, n = arrayindex;
    if (Jsi_ObjArraySizer(interp, obj, n+1) <= 0)
        return JSI_ERROR;
    if (obj->arr[n] == value)
        return JSI_OK;
    if (obj->arr[n])
        Jsi_DecrRefCount(interp, obj->arr[n]);
    Assert(obj->arrCnt<=obj->arrMaxSize);
    obj->arr[n] = value;
    if (value)
        Jsi_IncrRefCount(interp, value);
    if (value && value->vt == JSI_VT_OBJECT)
        jsi_ObjInsertObjCheck(interp, obj, value, 1);
    m = Jsi_ObjGetLength(interp, obj);
    if ((n+1) > m)
       Jsi_ObjSetLength(interp, obj, n+1);
    return JSI_OK;
}","Jsi_RC Jsi_ObjArraySet(Jsi_Interp *VAR_0, Jsi_Obj *VAR_1, Jsi_Value *VAR_2, int VAR_3)
{
    int VAR_4, VAR_5 = VAR_3;
    if (Jsi_ObjArraySizer(VAR_0, VAR_1, VAR_5+1) <= 0)
        return VAR_6;
    if (VAR_1->arr[VAR_5] == VAR_2)
        return VAR_7;
    if (VAR_1->arr[VAR_5])
        Jsi_DecrRefCount(VAR_0, VAR_1->arr[VAR_5]);
    Assert(VAR_1->arrCnt<=VAR_1->arrMaxSize);
    VAR_1->arr[VAR_5] = VAR_2;
    if (VAR_2)
        Jsi_IncrRefCount(VAR_0, VAR_2);
    if (VAR_2 && VAR_2->vt == VAR_8)
        jsi_ObjInsertObjCheck(VAR_0, VAR_1, VAR_2, 1);
    VAR_4 = Jsi_ObjGetLength(VAR_0, VAR_1);
    if ((VAR_5+1) > VAR_4)
       Jsi_ObjSetLength(VAR_0, VAR_1, VAR_5+1);
    return VAR_7;
}",pcmacdon/jsish/9c9dbe59760a660e21d69d5cf6007c9ccbb5c9a3/jsiObj.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 Jsi_RC Jsi_ObjArraySet(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *value, int arrayindex)
 {
     int m, n = arrayindex;
-    if (Jsi_ObjArraySizer(interp, obj, n) <= 0)
+    if (Jsi_ObjArraySizer(interp, obj, n+1) <= 0)
         return JSI_ERROR;
     if (obj->arr[n] == value)
         return JSI_OK;","{'deleted_lines': ['    if (Jsi_ObjArraySizer(interp, obj, n) <= 0)'], 'added_lines': ['    if (Jsi_ObjArraySizer(interp, obj, n+1) <= 0)']}",True,Jsish v3.5.0 was discovered to contain a heap-use-after-free via jsi_ValueCopyMove in src/jsiValue.c. This vulnerability can lead to a Denial of Service (DoS).,5.5,MEDIUM,1,test,2021-12-28T03:37:30Z,4
CVE-2021-46499,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,pcmacdon/jsish,"Fixes #76

FossilOrigin-Name: 1a370f5a3fc952b9f433f5607a68f83871294222452b85a5092bde44c309a7ce",9c9dbe59760a660e21d69d5cf6007c9ccbb5c9a3,https://github.com/pcmacdon/jsish/commit/9c9dbe59760a660e21d69d5cf6007c9ccbb5c9a3,src/jsiObj.c,ObjListifyCallback,"static Jsi_RC ObjListifyCallback(Jsi_Tree *tree, Jsi_TreeEntry *hPtr, void *data)
{
Jsi_Interp *interp = tree->opts.interp;
Jsi_Obj *obj = (Jsi_Obj*)data;
int n;
if (!hPtr->f.bits.dontenum) {
char *ep = NULL, *cp = (char*)Jsi_TreeKeyGet(hPtr);
if (!cp || !isdigit(*cp))
return JSI_OK;
n = (int)strtol(cp, &ep, 0);
if (n<0 || (uint)n >= interp->maxArrayList)
return JSI_OK;
hPtr->f.bits.isarrlist = 1;
if (Jsi_ObjArraySizer(interp, obj, n) <= 0) 
return Jsi_LogError(""too long"");
obj->arr[n] = (Jsi_Value*)Jsi_TreeValueGet(hPtr);
}
return JSI_OK;
}","static Jsi_RC ObjListifyCallback(Jsi_Tree *VAR_0, Jsi_TreeEntry *VAR_1, void *VAR_2)
{
Jsi_Interp *VAR_3 = VAR_0->opts.interp;
Jsi_Obj *VAR_4 = (Jsi_Obj*)VAR_2;
int VAR_5;
if (!VAR_1->f.bits.dontenum) {
char *VAR_6 = NULL, *VAR_7 = (char*)Jsi_TreeKeyGet(VAR_1);
if (!VAR_7 || !isdigit(*VAR_7))
return VAR_8;
VAR_5 = (int)strtol(VAR_7, &VAR_6, 0);
if (VAR_5<0 || (uint)VAR_5 >= VAR_3->maxArrayList)
return VAR_8;
VAR_1->f.bits.isarrlist = 1;
if (Jsi_ObjArraySizer(VAR_3, VAR_4, VAR_5) <= 0) 
return Jsi_LogError(""too long"");
VAR_4->arr[VAR_5] = (Jsi_Value*)Jsi_TreeValueGet(VAR_1);
}
return VAR_8;
}",pcmacdon/jsish/9c9dbe59760a660e21d69d5cf6007c9ccbb5c9a3/jsiObj.c/vul/before/1.json,"static Jsi_RC ObjListifyCallback(Jsi_Tree *tree, Jsi_TreeEntry *hPtr, void *data)
{
    Jsi_Interp *interp = tree->opts.interp;
    Jsi_Obj *obj = (Jsi_Obj*)data;
    int n;
    if (!hPtr->f.bits.dontenum) {
        char *ep = NULL, *cp = (char*)Jsi_TreeKeyGet(hPtr);
        if (!cp || !isdigit(*cp))
            return JSI_OK;
        n = (int)strtol(cp, &ep, 0);
        if (n<0 || (uint)n >= interp->maxArrayList)
            return JSI_OK;
        hPtr->f.bits.isarrlist = 1;
        if (Jsi_ObjArraySizer(interp, obj, n+1) <= 0) 
            return Jsi_LogError(""too long"");
        Jsi_Value* v = (Jsi_Value*)Jsi_TreeValueGet(hPtr);
        obj->arr[n] = v;
        if (v)
            Jsi_IncrRefCount(interp, v);
       // obj->arrCnt++;
    }
    return JSI_OK;
}","static Jsi_RC ObjListifyCallback(Jsi_Tree *VAR_0, Jsi_TreeEntry *VAR_1, void *VAR_2)
{
    Jsi_Interp *VAR_3 = VAR_0->opts.interp;
    Jsi_Obj *VAR_4 = (Jsi_Obj*)VAR_2;
    int VAR_5;
    if (!VAR_1->f.bits.dontenum) {
        char *VAR_6 = NULL, *VAR_7 = (char*)Jsi_TreeKeyGet(VAR_1);
        if (!VAR_7 || !isdigit(*VAR_7))
            return VAR_8;
        VAR_5 = (int)strtol(VAR_7, &VAR_6, 0);
        if (VAR_5<0 || (uint)VAR_5 >= VAR_3->maxArrayList)
            return VAR_8;
        VAR_1->f.bits.isarrlist = 1;
        if (Jsi_ObjArraySizer(VAR_3, VAR_4, VAR_5+1) <= 0) 
            return Jsi_LogError(""too long"");
        Jsi_Value* VAR_9 = (Jsi_Value*)Jsi_TreeValueGet(VAR_1);
        VAR_4->arr[VAR_5] = VAR_9;
        if (VAR_9)
            Jsi_IncrRefCount(VAR_3, VAR_9);
       /* COMMENT_0 */
    }
    return VAR_8;
}",pcmacdon/jsish/9c9dbe59760a660e21d69d5cf6007c9ccbb5c9a3/jsiObj.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -11,9 +11,12 @@
         if (n<0 || (uint)n >= interp->maxArrayList)
             return JSI_OK;
         hPtr->f.bits.isarrlist = 1;
-        if (Jsi_ObjArraySizer(interp, obj, n) <= 0) 
+        if (Jsi_ObjArraySizer(interp, obj, n+1) <= 0) 
             return Jsi_LogError(""too long"");
-        obj->arr[n] = (Jsi_Value*)Jsi_TreeValueGet(hPtr);
+        Jsi_Value* v = (Jsi_Value*)Jsi_TreeValueGet(hPtr);
+        obj->arr[n] = v;
+        if (v)
+            Jsi_IncrRefCount(interp, v);
        // obj->arrCnt++;
     }
     return JSI_OK;","{'deleted_lines': ['        if (Jsi_ObjArraySizer(interp, obj, n) <= 0) ', '        obj->arr[n] = (Jsi_Value*)Jsi_TreeValueGet(hPtr);'], 'added_lines': ['        if (Jsi_ObjArraySizer(interp, obj, n+1) <= 0) ', '        Jsi_Value* v = (Jsi_Value*)Jsi_TreeValueGet(hPtr);', '        obj->arr[n] = v;', '        if (v)', '            Jsi_IncrRefCount(interp, v);']}",True,Jsish v3.5.0 was discovered to contain a heap-use-after-free via jsi_ValueCopyMove in src/jsiValue.c. This vulnerability can lead to a Denial of Service (DoS).,5.5,MEDIUM,1,test,2021-12-28T03:37:30Z,4
CVE-2021-46335,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,Moddable-OpenSource/moddable,XS: #748,4a1e972c24c8fbca2b94f568d94c6c68f997ba39,https://github.com/Moddable-OpenSource/moddable/commit/4a1e972c24c8fbca2b94f568d94c6c68f997ba39,xs/sources/xsFunction.c,fx_Function_prototype_hasInstance,"void fx_Function_prototype_hasInstance(txMachine* the)
{
txSlot* instance;
txSlot* prototype;
mxResult->kind = XS_BOOLEAN_KIND;
mxResult->value.boolean = 0;
if (mxArgc == 0)
return;
instance = fxGetInstance(the, mxArgv(0));
if (!instance)
return;
mxPushSlot(mxThis);
mxGetID(mxID(_prototype));
prototype = fxGetInstance(the, the->stack);
mxPop();
if (!prototype) {
txSlot* slot = mxFunctionInstanceHome(mxThis->value.reference)->next;
if (slot && (slot->flag & XS_INTERNAL_FLAG) && (slot->ID == mxID(_boundFunction))) {
mxPushSlot(slot);
mxGetID(mxID(_prototype));
prototype = fxGetInstance(the, the->stack);
mxPop();
}
}
if (!prototype)
mxTypeError(""prototype is no object"");
if (prototype->ID) {
txSlot* alias = the->aliasArray[prototype->ID];
if (alias)
prototype = alias;
}
mxPushNull();
while (mxBehaviorGetPrototype(the, instance, the->stack)) {
instance = the->stack->value.reference;
if (instance == prototype) {
mxResult->value.boolean = 1;
break;
}
}
mxPop();
}","void fx_Function_prototype_hasInstance(txMachine* VAR_0)
{
txSlot* VAR_1;
txSlot* VAR_2;
VAR_3->kind = VAR_4;
VAR_3->value.boolean = 0;
if (VAR_5 == 0)
return;
VAR_1 = fxGetInstance(VAR_0, mxArgv(0));
if (!VAR_1)
return;
mxPushSlot(VAR_6);
mxGetID(mxID(VAR_7));
VAR_2 = fxGetInstance(VAR_0, VAR_0->stack);
mxPop();
if (!VAR_2) {
txSlot* VAR_8 = mxFunctionInstanceHome(VAR_6->value.reference)->next;
if (VAR_8 && (VAR_8->flag & VAR_9) && (VAR_8->ID == mxID(VAR_10))) {
mxPushSlot(VAR_8);
mxGetID(mxID(VAR_7));
VAR_2 = fxGetInstance(VAR_0, VAR_0->stack);
mxPop();
}
}
if (!VAR_2)
mxTypeError(""prototype is no object"");
if (VAR_2->ID) {
txSlot* VAR_11 = VAR_0->aliasArray[VAR_2->ID];
if (VAR_11)
VAR_2 = VAR_11;
}
mxPushNull();
while (mxBehaviorGetPrototype(VAR_0, VAR_1, VAR_0->stack)) {
VAR_1 = VAR_0->stack->value.reference;
if (VAR_1 == VAR_2) {
VAR_3->value.boolean = 1;
break;
}
}
mxPop();
}",Moddable-OpenSource/moddable/4a1e972c24c8fbca2b94f568d94c6c68f997ba39/xsFunction.c/vul/before/0.json,"void fx_Function_prototype_hasInstance(txMachine* the)
{	
	txSlot* function;
	txSlot* slot;
	txSlot* instance;
	txSlot* prototype;
	mxResult->kind = XS_BOOLEAN_KIND;
	mxResult->value.boolean = 0;
	if (!fxIsCallable(the, mxThis))
		return;
	function = fxToInstance(the, mxThis);
	if (!function)
		return;
	slot = mxFunctionInstanceHome(function)->next;
	if (slot && (slot->flag & XS_INTERNAL_FLAG) && (slot->ID == mxID(_boundFunction))) {
		if (!fxIsCallable(the, slot))
			return;
		function = fxToInstance(the, slot);
		if (!function)
			return;
	}
	if (mxArgc == 0)
		return;
	instance = fxGetInstance(the, mxArgv(0));
	if (!instance)
		return;
	mxPushReference(function);
	mxGetID(mxID(_prototype));
	prototype = fxGetInstance(the, the->stack);
	mxPop();
	if (!prototype)
		mxTypeError(""prototype is no object"");
	if (prototype->ID) {
		txSlot* alias = the->aliasArray[prototype->ID];
		if (alias)
			prototype = alias;
	}
	mxPushNull();
	while (mxBehaviorGetPrototype(the, instance, the->stack)) {
		instance = the->stack->value.reference;
		if (instance == prototype) {
			mxResult->value.boolean = 1;
			break;
		}
	}
	mxPop();
}","void fx_Function_prototype_hasInstance(txMachine* VAR_0)
{	
	txSlot* VAR_1;
	txSlot* VAR_2;
	txSlot* VAR_3;
	txSlot* VAR_4;
	VAR_5->kind = VAR_6;
	VAR_5->value.boolean = 0;
	if (!fxIsCallable(VAR_0, VAR_7))
		return;
	VAR_1 = fxToInstance(VAR_0, VAR_7);
	if (!VAR_1)
		return;
	VAR_2 = mxFunctionInstanceHome(VAR_1)->next;
	if (VAR_2 && (VAR_2->flag & VAR_8) && (VAR_2->ID == mxID(VAR_9))) {
		if (!fxIsCallable(VAR_0, VAR_2))
			return;
		VAR_1 = fxToInstance(VAR_0, VAR_2);
		if (!VAR_1)
			return;
	}
	if (VAR_10 == 0)
		return;
	VAR_3 = fxGetInstance(VAR_0, mxArgv(0));
	if (!VAR_3)
		return;
	mxPushReference(VAR_1);
	mxGetID(mxID(VAR_11));
	VAR_4 = fxGetInstance(VAR_0, VAR_0->stack);
	mxPop();
	if (!VAR_4)
		mxTypeError(""prototype is no object"");
	if (VAR_4->ID) {
		txSlot* VAR_12 = VAR_0->aliasArray[VAR_4->ID];
		if (VAR_12)
			VAR_4 = VAR_12;
	}
	mxPushNull();
	while (mxBehaviorGetPrototype(VAR_0, VAR_3, VAR_0->stack)) {
		VAR_3 = VAR_0->stack->value.reference;
		if (VAR_3 == VAR_4) {
			VAR_5->value.boolean = 1;
			break;
		}
	}
	mxPop();
}",Moddable-OpenSource/moddable/4a1e972c24c8fbca2b94f568d94c6c68f997ba39/xsFunction.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,27 +1,33 @@
 void fx_Function_prototype_hasInstance(txMachine* the)
 {	
+	txSlot* function;
+	txSlot* slot;
 	txSlot* instance;
 	txSlot* prototype;
 	mxResult->kind = XS_BOOLEAN_KIND;
 	mxResult->value.boolean = 0;
+	if (!fxIsCallable(the, mxThis))
+		return;
+	function = fxToInstance(the, mxThis);
+	if (!function)
+		return;
+	slot = mxFunctionInstanceHome(function)->next;
+	if (slot && (slot->flag & XS_INTERNAL_FLAG) && (slot->ID == mxID(_boundFunction))) {
+		if (!fxIsCallable(the, slot))
+			return;
+		function = fxToInstance(the, slot);
+		if (!function)
+			return;
+	}
 	if (mxArgc == 0)
 		return;
 	instance = fxGetInstance(the, mxArgv(0));
 	if (!instance)
 		return;
-	mxPushSlot(mxThis);
+	mxPushReference(function);
 	mxGetID(mxID(_prototype));
 	prototype = fxGetInstance(the, the->stack);
 	mxPop();
-	if (!prototype) {
-		txSlot* slot = mxFunctionInstanceHome(mxThis->value.reference)->next;
-		if (slot && (slot->flag & XS_INTERNAL_FLAG) && (slot->ID == mxID(_boundFunction))) {
-			mxPushSlot(slot);
-			mxGetID(mxID(_prototype));
-			prototype = fxGetInstance(the, the->stack);
-			mxPop();
-		}
-	}
 	if (!prototype)
 		mxTypeError(""prototype is no object"");
 	if (prototype->ID) {","{'deleted_lines': ['\tmxPushSlot(mxThis);', '\tif (!prototype) {', '\t\ttxSlot* slot = mxFunctionInstanceHome(mxThis->value.reference)->next;', '\t\tif (slot && (slot->flag & XS_INTERNAL_FLAG) && (slot->ID == mxID(_boundFunction))) {', '\t\t\tmxPushSlot(slot);', '\t\t\tmxGetID(mxID(_prototype));', '\t\t\tprototype = fxGetInstance(the, the->stack);', '\t\t\tmxPop();', '\t\t}', '\t}'], 'added_lines': ['\ttxSlot* function;', '\ttxSlot* slot;', '\tif (!fxIsCallable(the, mxThis))', '\t\treturn;', '\tfunction = fxToInstance(the, mxThis);', '\tif (!function)', '\t\treturn;', '\tslot = mxFunctionInstanceHome(function)->next;', '\tif (slot && (slot->flag & XS_INTERNAL_FLAG) && (slot->ID == mxID(_boundFunction))) {', '\t\tif (!fxIsCallable(the, slot))', '\t\t\treturn;', '\t\tfunction = fxToInstance(the, slot);', '\t\tif (!function)', '\t\t\treturn;', '\t}', '\tmxPushReference(function);']}",True,Moddable SDK v11.5.0 was discovered to contain a NULL pointer dereference in the component fx_Function_prototype_hasInstance.,5.5,MEDIUM,1,test,2021-12-30T11:04:33Z,4
CVE-2021-46326,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,Moddable-OpenSource/moddable,XS: #759,f000fe13e240464f63fefa605241be7fe5fca1cd,https://github.com/Moddable-OpenSource/moddable/commit/f000fe13e240464f63fefa605241be7fe5fca1cd,xs/sources/xsString.c,fxPushSubstitutionString,"void fxPushSubstitutionString(txMachine* the, txSlot* string, txInteger size, txInteger offset, txSlot* match, txInteger length, txInteger count, txSlot* captures, txSlot* groups, txSlot* replace)
{
txString r;
txInteger m;
txInteger l;
txBoolean flag;
txByte c, d;
txInteger i, j;
txSlot* capture;
txString s;
r = replace->value.string;
m = 0;
l = 0;
flag = 0;
while ((c = c_read8(r++))) {
if (m <= l)
m = l;
else
fxAbort(the, XS_NOT_ENOUGH_MEMORY_EXIT);
if (c == '$') {
c = c_read8(r++);
switch (c) {
case '$':
l++;
flag = 1;
break;
case '&':
l += length;
flag = 1;
break;
case '`':
l += offset;
flag = 1;
break;
case '\'':
l += size - (offset + length);
flag = 1;
break;
case '<':
if (groups && mxIsReference(groups)) {
txString t = r;
while ((d = c_read8(r))) {
if (d == '>')
break;
r++;
}
if (d) {
txInteger n = mxPtrDiff(r - t);
txID name;
if (n > 255)
fxJump(the);
c_memcpy(the->nameBuffer, t, n);
the->nameBuffer[n] = 0;
name = fxFindName(the, the->nameBuffer);
if (name) {
mxPushSlot(groups);
mxGetID(name);
if (!mxIsUndefined(the->stack)) {
fxToString(the, the->stack);
l += mxStringLength(the->stack->value.string);
}
mxPop();
}
r++;
flag = 1;
}
else {
r = t;
l += 2;
}
}
else {
l += 2;
}
break;
default:
if (('0' <= c) && (c <= '9')) {
i = c - '0';
d = c_read8(r);
if (('0' <= d) && (d <= '9')) {
j = (i * 10) + d - '0';
if ((0 < j) && (j <= count)) {
i = j;
r++;
}
else
d = 0;
}
else
d = 0;
if ((0 < i) && (i <= count)) {
capture = (captures + count - i);
if (capture->kind != XS_UNDEFINED_KIND)
l += mxStringLength(capture->value.string);
flag = 1;
}
else {
l++;
l++;
if (d)
l++;
}
}
else {
l++;
if (c)
l++;
}
break;
}
if (!c)
break;
}
else
l++;
}
if (flag) {
mxPushUndefined();
the->stack->value.string = (txString)fxNewChunk(the, fxAddChunkSizes(the, l, 1));
the->stack->kind = XS_STRING_KIND;
r = replace->value.string;
s = the->stack->value.string;
while ((c = c_read8(r++))) {
if (c == '$') {
c = c_read8(r++);
switch (c) {
case '$':
*s++ = c;
break;
case '&':
l = length;
c_memcpy(s, match->value.string, l);
s += l;
break;
case '`':
l = offset;
c_memcpy(s, string->value.string, l);
s += l;
break;
case '\'':
l = size - (offset + length);
if (l > 0) {
c_memcpy(s, string->value.string + offset + length, l);
s += l;
}
break;
case '<':
if (groups && mxIsReference(groups)) {
txString t = r;
while ((d = c_read8(r))) {
if (d == '>')
break;
r++;
}
if (d) {
txInteger n = mxPtrDiff(r - t);
txID name;
if (n > 255)
fxJump(the);
c_memcpy(the->nameBuffer, t, n);
the->nameBuffer[n] = 0;
name = fxFindName(the, the->nameBuffer);
if (name) {
mxPushSlot(groups);
mxGetID(name);
if (!mxIsUndefined(the->stack)) {
fxToString(the, the->stack);
l = mxStringLength(the->stack->value.string);
c_memcpy(s, the->stack->value.string, l);
s += l;
}
mxPop();
}
r++;
}
else {
r = t;
*s++ = '$';
*s++ = '<';
}
}
else {
*s++ = '$';
*s++ = '<';
}
break;
default:
if (('0' <= c) && (c <= '9')) {
i = c - '0';
d = c_read8(r);
if (('0' <= d) && (d <= '9')) {
j = (i * 10) + d - '0';
if ((0 < j) && (j <= count)) {
i = j;
r++;
}
else
d = 0;
}
else
d = 0;
if ((0 < i) && (i <= count)) {
capture = (captures + count - i);
if (capture->kind != XS_UNDEFINED_KIND) {
l = mxStringLength(capture->value.string);
c_memcpy(s, capture->value.string, l);
s += l;
}
}
else {
*s++ = '$';
*s++ = c;
if (d)
*s++ = d;
}
}
else {
*s++ = '$';
if (c)
*s++ = c;
}
break;
}
if (!c)
break;
}
else
*s++ = c;
}
*s = 0;
}
else
mxPushSlot(replace);
}","void fxPushSubstitutionString(txMachine* VAR_0, txSlot* VAR_1, txInteger VAR_2, txInteger VAR_3, txSlot* VAR_4, txInteger VAR_5, txInteger VAR_6, txSlot* VAR_7, txSlot* VAR_8, txSlot* VAR_9)
{
txString VAR_10;
txInteger VAR_11;
txInteger VAR_12;
txBoolean VAR_13;
txByte VAR_14, VAR_15;
txInteger VAR_16, VAR_17;
txSlot* VAR_18;
txString VAR_19;
VAR_10 = VAR_9->value.string;
VAR_11 = 0;
VAR_12 = 0;
VAR_13 = 0;
while ((VAR_14 = c_read8(VAR_10++))) {
if (VAR_11 <= VAR_12)
VAR_11 = VAR_12;
else
fxAbort(VAR_0, VAR_20);
if (VAR_14 == '$') {
VAR_14 = c_read8(VAR_10++);
switch (VAR_14) {
case '$':
VAR_12++;
VAR_13 = 1;
break;
case '&':
VAR_12 += VAR_5;
VAR_13 = 1;
break;
case '`':
VAR_12 += VAR_3;
VAR_13 = 1;
break;
case '\'':
VAR_12 += VAR_2 - (VAR_3 + VAR_5);
VAR_13 = 1;
break;
case '<':
if (VAR_8 && mxIsReference(VAR_8)) {
txString VAR_21 = VAR_10;
while ((VAR_15 = c_read8(VAR_10))) {
if (VAR_15 == '>')
break;
VAR_10++;
}
if (VAR_15) {
txInteger VAR_22 = mxPtrDiff(VAR_10 - VAR_21);
txID VAR_23;
if (VAR_22 > 255)
fxJump(VAR_0);
c_memcpy(VAR_0->nameBuffer, VAR_21, VAR_22);
VAR_0->nameBuffer[VAR_22] = 0;
VAR_23 = fxFindName(VAR_0, VAR_0->nameBuffer);
if (VAR_23) {
mxPushSlot(VAR_8);
mxGetID(VAR_23);
if (!mxIsUndefined(VAR_0->stack)) {
fxToString(VAR_0, VAR_0->stack);
VAR_12 += mxStringLength(VAR_0->stack->value.string);
}
mxPop();
}
VAR_10++;
VAR_13 = 1;
}
else {
VAR_10 = VAR_21;
VAR_12 += 2;
}
}
else {
VAR_12 += 2;
}
break;
default:
if (('0' <= VAR_14) && (VAR_14 <= '9')) {
VAR_16 = VAR_14 - '0';
VAR_15 = c_read8(VAR_10);
if (('0' <= VAR_15) && (VAR_15 <= '9')) {
VAR_17 = (VAR_16 * 10) + VAR_15 - '0';
if ((0 < VAR_17) && (VAR_17 <= VAR_6)) {
VAR_16 = VAR_17;
VAR_10++;
}
else
VAR_15 = 0;
}
else
VAR_15 = 0;
if ((0 < VAR_16) && (VAR_16 <= VAR_6)) {
VAR_18 = (VAR_7 + VAR_6 - VAR_16);
if (VAR_18->kind != VAR_24)
VAR_12 += mxStringLength(VAR_18->value.string);
VAR_13 = 1;
}
else {
VAR_12++;
VAR_12++;
if (VAR_15)
VAR_12++;
}
}
else {
VAR_12++;
if (VAR_14)
VAR_12++;
}
break;
}
if (!VAR_14)
break;
}
else
VAR_12++;
}
if (VAR_13) {
mxPushUndefined();
VAR_0->stack->value.string = (txString)fxNewChunk(VAR_0, fxAddChunkSizes(VAR_0, VAR_12, 1));
VAR_0->stack->kind = VAR_25;
VAR_10 = VAR_9->value.string;
VAR_19 = VAR_0->stack->value.string;
while ((VAR_14 = c_read8(VAR_10++))) {
if (VAR_14 == '$') {
VAR_14 = c_read8(VAR_10++);
switch (VAR_14) {
case '$':
*VAR_19++ = VAR_14;
break;
case '&':
VAR_12 = VAR_5;
c_memcpy(VAR_19, VAR_4->value.string, VAR_12);
VAR_19 += VAR_12;
break;
case '`':
VAR_12 = VAR_3;
c_memcpy(VAR_19, VAR_1->value.string, VAR_12);
VAR_19 += VAR_12;
break;
case '\'':
VAR_12 = VAR_2 - (VAR_3 + VAR_5);
if (VAR_12 > 0) {
c_memcpy(VAR_19, VAR_1->value.string + VAR_3 + VAR_5, VAR_12);
VAR_19 += VAR_12;
}
break;
case '<':
if (VAR_8 && mxIsReference(VAR_8)) {
txString VAR_21 = VAR_10;
while ((VAR_15 = c_read8(VAR_10))) {
if (VAR_15 == '>')
break;
VAR_10++;
}
if (VAR_15) {
txInteger VAR_22 = mxPtrDiff(VAR_10 - VAR_21);
txID VAR_23;
if (VAR_22 > 255)
fxJump(VAR_0);
c_memcpy(VAR_0->nameBuffer, VAR_21, VAR_22);
VAR_0->nameBuffer[VAR_22] = 0;
VAR_23 = fxFindName(VAR_0, VAR_0->nameBuffer);
if (VAR_23) {
mxPushSlot(VAR_8);
mxGetID(VAR_23);
if (!mxIsUndefined(VAR_0->stack)) {
fxToString(VAR_0, VAR_0->stack);
VAR_12 = mxStringLength(VAR_0->stack->value.string);
c_memcpy(VAR_19, VAR_0->stack->value.string, VAR_12);
VAR_19 += VAR_12;
}
mxPop();
}
VAR_10++;
}
else {
VAR_10 = VAR_21;
*VAR_19++ = '$';
*VAR_19++ = '<';
}
}
else {
*VAR_19++ = '$';
*VAR_19++ = '<';
}
break;
default:
if (('0' <= VAR_14) && (VAR_14 <= '9')) {
VAR_16 = VAR_14 - '0';
VAR_15 = c_read8(VAR_10);
if (('0' <= VAR_15) && (VAR_15 <= '9')) {
VAR_17 = (VAR_16 * 10) + VAR_15 - '0';
if ((0 < VAR_17) && (VAR_17 <= VAR_6)) {
VAR_16 = VAR_17;
VAR_10++;
}
else
VAR_15 = 0;
}
else
VAR_15 = 0;
if ((0 < VAR_16) && (VAR_16 <= VAR_6)) {
VAR_18 = (VAR_7 + VAR_6 - VAR_16);
if (VAR_18->kind != VAR_24) {
VAR_12 = mxStringLength(VAR_18->value.string);
c_memcpy(VAR_19, VAR_18->value.string, VAR_12);
VAR_19 += VAR_12;
}
}
else {
*VAR_19++ = '$';
*VAR_19++ = VAR_14;
if (VAR_15)
*VAR_19++ = VAR_15;
}
}
else {
*VAR_19++ = '$';
if (VAR_14)
*VAR_19++ = VAR_14;
}
break;
}
if (!VAR_14)
break;
}
else
*VAR_19++ = VAR_14;
}
*VAR_19 = 0;
}
else
mxPushSlot(VAR_9);
}",Moddable-OpenSource/moddable/f000fe13e240464f63fefa605241be7fe5fca1cd/xsString.c/vul/before/0.json,"void fxPushSubstitutionString(txMachine* the, txSlot* string, txInteger size, txInteger offset, txSlot* match, txInteger length, txInteger count, txSlot* captures, txSlot* groups, txSlot* replace)
{
	txString r;
	txInteger m;
	txInteger l;
	txBoolean flag;
	txByte c, d;
	txInteger i, j;
	txSlot* capture;
	txString s;
	r = replace->value.string;
	m = 0;
	l = 0;
	flag = 0;
	while ((c = c_read8(r++))) {
		if (m <= l)
			m = l;
		else
			fxAbort(the, XS_NOT_ENOUGH_MEMORY_EXIT);
		if (c == '$') {
			c = c_read8(r++);
			switch (c) {
			case '$':
				l++;
				flag = 1;
				break;
			case '&':
				l += length;
				flag = 1;
				break;
			case '`':
				l += offset;
				flag = 1;
				break;
			case '\'':
				l += size - (offset + length);
				flag = 1;
				break;
			case '<':
				if (groups && mxIsReference(groups)) {
					txString t = r;
					while ((d = c_read8(r))) {
						if (d == '>')
							break;
						r++;
					}
					if (d) {
						txInteger n = mxPtrDiff(r - t);
						txID name;
						if (n > 255)
							fxJump(the);
						c_memcpy(the->nameBuffer, t, n);
						the->nameBuffer[n] = 0;
						name = fxFindName(the, the->nameBuffer);
						if (name) {
 							mxPushSlot(groups);
							mxGetID(name);
							if (!mxIsUndefined(the->stack)) {
								fxToString(the, the->stack);
								l += mxStringLength(the->stack->value.string);
							}
							mxPop();
						}
						r++;
						flag = 1;
					}
					else {
						r = t;
						l += 2;
					}
				}
				else {
					l += 2;
				}
				break;
			default:
				if (('0' <= c) && (c <= '9')) {
					i = c - '0';
					d = c_read8(r);
					if (('0' <= d) && (d <= '9')) {
						j = (i * 10) + d - '0';
						if ((0 < j) && (j <= count)) {
							i = j;
							r++;
						}
						else
							d = 0;
					}
					else
						d = 0;
					if ((0 < i) && (i <= count)) {
						capture = (captures + count - i);
						if (capture->kind != XS_UNDEFINED_KIND)
							l += mxStringLength(capture->value.string);
						flag = 1;
					}
					else {
						l++;
						l++;
						if (d)
							l++;
					}
				}
				else {
					l++;
					if (c)
						l++;
				}
				break;
			}
			if (!c)
				break;
		}
		else
			l++;
	}
	if (m > l)
		fxAbort(the, XS_NOT_ENOUGH_MEMORY_EXIT);
	if (flag) {
		mxPushUndefined();
		the->stack->value.string = (txString)fxNewChunk(the, fxAddChunkSizes(the, l, 1));
		the->stack->kind = XS_STRING_KIND;
		r = replace->value.string;
		s = the->stack->value.string;
		while ((c = c_read8(r++))) {
			if (c == '$') {
				c = c_read8(r++);
				switch (c) {
				case '$':
					*s++ = c;
					break;
				case '&':
					l = length;
					c_memcpy(s, match->value.string, l);
					s += l;
					break;
				case '`':
					l = offset;
					c_memcpy(s, string->value.string, l);
					s += l;
					break;
				case '\'':
					l = size - (offset + length);
                    if (l > 0) {
                        c_memcpy(s, string->value.string + offset + length, l);
                        s += l;
                    }
					break;
				case '<':
					if (groups && mxIsReference(groups)) {
						txString t = r;
						while ((d = c_read8(r))) {
							if (d == '>')
								break;
							r++;
						}
						if (d) {
							txInteger n = mxPtrDiff(r - t);
							txID name;
							if (n > 255)
								fxJump(the);
							c_memcpy(the->nameBuffer, t, n);
							the->nameBuffer[n] = 0;
							name = fxFindName(the, the->nameBuffer);
							if (name) {
								mxPushSlot(groups);
								mxGetID(name);
								if (!mxIsUndefined(the->stack)) {
									fxToString(the, the->stack);
									l = mxStringLength(the->stack->value.string);
									c_memcpy(s, the->stack->value.string, l);
									s += l;
								}
								mxPop();
							}
							r++;
						}
						else {
							r = t;
							*s++ = '$';
							*s++ = '<';
						}
					}
					else {
						*s++ = '$';
						*s++ = '<';
					}
					break;
				default:
					if (('0' <= c) && (c <= '9')) {
						i = c - '0';
						d = c_read8(r);
						if (('0' <= d) && (d <= '9')) {
							j = (i * 10) + d - '0';
							if ((0 < j) && (j <= count)) {
								i = j;
								r++;
							}
							else
								d = 0;
						}
						else
							d = 0;
						if ((0 < i) && (i <= count)) {
							capture = (captures + count - i);
							if (capture->kind != XS_UNDEFINED_KIND) {
								l = mxStringLength(capture->value.string);
								c_memcpy(s, capture->value.string, l);
								s += l;
							}
						}
						else {
							*s++ = '$';
							*s++ = c;
							if (d)
								*s++ = d;
						}
					}
					else {
						*s++ = '$';
						if (c)
							*s++ = c;
					}
					break;
				}
				if (!c)
					break;
			}
			else
				*s++ = c;
		}
		*s = 0;
	}
	else
		mxPushSlot(replace);
}","void fxPushSubstitutionString(txMachine* VAR_0, txSlot* VAR_1, txInteger VAR_2, txInteger VAR_3, txSlot* VAR_4, txInteger VAR_5, txInteger VAR_6, txSlot* VAR_7, txSlot* VAR_8, txSlot* VAR_9)
{
	txString VAR_10;
	txInteger VAR_11;
	txInteger VAR_12;
	txBoolean VAR_13;
	txByte VAR_14, VAR_15;
	txInteger VAR_16, VAR_17;
	txSlot* VAR_18;
	txString VAR_19;
	VAR_10 = VAR_9->value.string;
	VAR_11 = 0;
	VAR_12 = 0;
	VAR_13 = 0;
	while ((VAR_14 = c_read8(VAR_10++))) {
		if (VAR_11 <= VAR_12)
			VAR_11 = VAR_12;
		else
			fxAbort(VAR_0, VAR_20);
		if (VAR_14 == '$') {
			VAR_14 = c_read8(VAR_10++);
			switch (VAR_14) {
			case '$':
				VAR_12++;
				VAR_13 = 1;
				break;
			case '&':
				VAR_12 += VAR_5;
				VAR_13 = 1;
				break;
			case '`':
				VAR_12 += VAR_3;
				VAR_13 = 1;
				break;
			case '\'':
				VAR_12 += VAR_2 - (VAR_3 + VAR_5);
				VAR_13 = 1;
				break;
			case '<':
				if (VAR_8 && mxIsReference(VAR_8)) {
					txString VAR_21 = VAR_10;
					while ((VAR_15 = c_read8(VAR_10))) {
						if (VAR_15 == '>')
							break;
						VAR_10++;
					}
					if (VAR_15) {
						txInteger VAR_22 = mxPtrDiff(VAR_10 - VAR_21);
						txID VAR_23;
						if (VAR_22 > 255)
							fxJump(VAR_0);
						c_memcpy(VAR_0->nameBuffer, VAR_21, VAR_22);
						VAR_0->nameBuffer[VAR_22] = 0;
						VAR_23 = fxFindName(VAR_0, VAR_0->nameBuffer);
						if (VAR_23) {
 							mxPushSlot(VAR_8);
							mxGetID(VAR_23);
							if (!mxIsUndefined(VAR_0->stack)) {
								fxToString(VAR_0, VAR_0->stack);
								VAR_12 += mxStringLength(VAR_0->stack->value.string);
							}
							mxPop();
						}
						VAR_10++;
						VAR_13 = 1;
					}
					else {
						VAR_10 = VAR_21;
						VAR_12 += 2;
					}
				}
				else {
					VAR_12 += 2;
				}
				break;
			default:
				if (('0' <= VAR_14) && (VAR_14 <= '9')) {
					VAR_16 = VAR_14 - '0';
					VAR_15 = c_read8(VAR_10);
					if (('0' <= VAR_15) && (VAR_15 <= '9')) {
						VAR_17 = (VAR_16 * 10) + VAR_15 - '0';
						if ((0 < VAR_17) && (VAR_17 <= VAR_6)) {
							VAR_16 = VAR_17;
							VAR_10++;
						}
						else
							VAR_15 = 0;
					}
					else
						VAR_15 = 0;
					if ((0 < VAR_16) && (VAR_16 <= VAR_6)) {
						VAR_18 = (VAR_7 + VAR_6 - VAR_16);
						if (VAR_18->kind != VAR_24)
							VAR_12 += mxStringLength(VAR_18->value.string);
						VAR_13 = 1;
					}
					else {
						VAR_12++;
						VAR_12++;
						if (VAR_15)
							VAR_12++;
					}
				}
				else {
					VAR_12++;
					if (VAR_14)
						VAR_12++;
				}
				break;
			}
			if (!VAR_14)
				break;
		}
		else
			VAR_12++;
	}
	if (VAR_11 > VAR_12)
		fxAbort(VAR_0, VAR_20);
	if (VAR_13) {
		mxPushUndefined();
		VAR_0->stack->value.string = (txString)fxNewChunk(VAR_0, fxAddChunkSizes(VAR_0, VAR_12, 1));
		VAR_0->stack->kind = VAR_25;
		VAR_10 = VAR_9->value.string;
		VAR_19 = VAR_0->stack->value.string;
		while ((VAR_14 = c_read8(VAR_10++))) {
			if (VAR_14 == '$') {
				VAR_14 = c_read8(VAR_10++);
				switch (VAR_14) {
				case '$':
					*VAR_19++ = VAR_14;
					break;
				case '&':
					VAR_12 = VAR_5;
					c_memcpy(VAR_19, VAR_4->value.string, VAR_12);
					VAR_19 += VAR_12;
					break;
				case '`':
					VAR_12 = VAR_3;
					c_memcpy(VAR_19, VAR_1->value.string, VAR_12);
					VAR_19 += VAR_12;
					break;
				case '\'':
					VAR_12 = VAR_2 - (VAR_3 + VAR_5);
                    if (VAR_12 > 0) {
                        c_memcpy(VAR_19, VAR_1->value.string + VAR_3 + VAR_5, VAR_12);
                        VAR_19 += VAR_12;
                    }
					break;
				case '<':
					if (VAR_8 && mxIsReference(VAR_8)) {
						txString VAR_21 = VAR_10;
						while ((VAR_15 = c_read8(VAR_10))) {
							if (VAR_15 == '>')
								break;
							VAR_10++;
						}
						if (VAR_15) {
							txInteger VAR_22 = mxPtrDiff(VAR_10 - VAR_21);
							txID VAR_23;
							if (VAR_22 > 255)
								fxJump(VAR_0);
							c_memcpy(VAR_0->nameBuffer, VAR_21, VAR_22);
							VAR_0->nameBuffer[VAR_22] = 0;
							VAR_23 = fxFindName(VAR_0, VAR_0->nameBuffer);
							if (VAR_23) {
								mxPushSlot(VAR_8);
								mxGetID(VAR_23);
								if (!mxIsUndefined(VAR_0->stack)) {
									fxToString(VAR_0, VAR_0->stack);
									VAR_12 = mxStringLength(VAR_0->stack->value.string);
									c_memcpy(VAR_19, VAR_0->stack->value.string, VAR_12);
									VAR_19 += VAR_12;
								}
								mxPop();
							}
							VAR_10++;
						}
						else {
							VAR_10 = VAR_21;
							*VAR_19++ = '$';
							*VAR_19++ = '<';
						}
					}
					else {
						*VAR_19++ = '$';
						*VAR_19++ = '<';
					}
					break;
				default:
					if (('0' <= VAR_14) && (VAR_14 <= '9')) {
						VAR_16 = VAR_14 - '0';
						VAR_15 = c_read8(VAR_10);
						if (('0' <= VAR_15) && (VAR_15 <= '9')) {
							VAR_17 = (VAR_16 * 10) + VAR_15 - '0';
							if ((0 < VAR_17) && (VAR_17 <= VAR_6)) {
								VAR_16 = VAR_17;
								VAR_10++;
							}
							else
								VAR_15 = 0;
						}
						else
							VAR_15 = 0;
						if ((0 < VAR_16) && (VAR_16 <= VAR_6)) {
							VAR_18 = (VAR_7 + VAR_6 - VAR_16);
							if (VAR_18->kind != VAR_24) {
								VAR_12 = mxStringLength(VAR_18->value.string);
								c_memcpy(VAR_19, VAR_18->value.string, VAR_12);
								VAR_19 += VAR_12;
							}
						}
						else {
							*VAR_19++ = '$';
							*VAR_19++ = VAR_14;
							if (VAR_15)
								*VAR_19++ = VAR_15;
						}
					}
					else {
						*VAR_19++ = '$';
						if (VAR_14)
							*VAR_19++ = VAR_14;
					}
					break;
				}
				if (!VAR_14)
					break;
			}
			else
				*VAR_19++ = VAR_14;
		}
		*VAR_19 = 0;
	}
	else
		mxPushSlot(VAR_9);
}",Moddable-OpenSource/moddable/f000fe13e240464f63fefa605241be7fe5fca1cd/xsString.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -114,6 +114,8 @@
 		else
 			l++;
 	}
+	if (m > l)
+		fxAbort(the, XS_NOT_ENOUGH_MEMORY_EXIT);
 	if (flag) {
 		mxPushUndefined();
 		the->stack->value.string = (txString)fxNewChunk(the, fxAddChunkSizes(the, l, 1));","{'deleted_lines': [], 'added_lines': ['\tif (m > l)', '\t\tfxAbort(the, XS_NOT_ENOUGH_MEMORY_EXIT);']}",True,Moddable SDK v11.5.0 was discovered to contain a heap-buffer-overflow via the component __asan_memcpy.,7.8,HIGH,2,test,2021-12-30T11:24:21Z,4
CVE-2021-4192,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,vim,"patch 8.2.3949: using freed memory with /\%V

Problem:    Using freed memory with /\%V.
Solution:   Get the line again after getvvcol().",4c13e5e6763c6eb36a343a2b8235ea227202e952,https://github.com/vim/vim/commit/4c13e5e6763c6eb36a343a2b8235ea227202e952,src/regexp.c,reg_match_visual,"static int
reg_match_visual(void)
{
pos_Ttop, bot;
linenr_T    lnum;
colnr_Tcol;
win_T*wp = rex.reg_win == NULL ? curwin : rex.reg_win;
intmode;
colnr_Tstart, end;
colnr_Tstart2, end2;
colnr_Tcols;
colnr_Tcurswant;
if (rex.reg_buf != curbuf || VIsual.lnum == 0)
return FALSE;
if (VIsual_active)
{
if (LT_POS(VIsual, wp->w_cursor))
{
top = VIsual;
bot = wp->w_cursor;
}
else
{
top = wp->w_cursor;
bot = VIsual;
}
mode = VIsual_mode;
curswant = wp->w_curswant;
}
else
{
if (LT_POS(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end))
{
top = curbuf->b_visual.vi_start;
bot = curbuf->b_visual.vi_end;
}
else
{
top = curbuf->b_visual.vi_end;
bot = curbuf->b_visual.vi_start;
}
mode = curbuf->b_visual.vi_mode;
curswant = curbuf->b_visual.vi_curswant;
}
lnum = rex.lnum + rex.reg_firstlnum;
if (lnum < top.lnum || lnum > bot.lnum)
return FALSE;
if (mode == 'v')
{
col = (colnr_T)(rex.input - rex.line);
if ((lnum == top.lnum && col < top.col)
|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))
return FALSE;
}
else if (mode == Ctrl_V)
{
getvvcol(wp, &top, &start, NULL, &end);
getvvcol(wp, &bot, &start2, NULL, &end2);
if (start2 < start)
start = start2;
if (end2 > end)
end = end2;
if (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)
end = MAXCOL;
cols = win_linetabsize(wp, rex.line, (colnr_T)(rex.input - rex.line));
if (cols < start || cols > end - (*p_sel == 'e'))
return FALSE;
}
return TRUE;
}","static int
reg_match_visual(void)
{
pos_TVAR_0, VAR_1;
linenr_T    VAR_2;
colnr_TVAR_3;
win_T*VAR_4 = VAR_5.reg_win == NULL ? VAR_6 : VAR_5.reg_win;
intVAR_7;
colnr_TVAR_8, VAR_9;
colnr_TVAR_10, VAR_11;
colnr_TVAR_12;
colnr_TVAR_13;
if (VAR_5.reg_buf != VAR_14 || VAR_15.lnum == 0)
return FALSE;
if (VAR_16)
{
if (LT_POS(VAR_15, VAR_4->w_cursor))
{
VAR_0 = VAR_15;
VAR_1 = VAR_4->w_cursor;
}
else
{
VAR_0 = VAR_4->w_cursor;
VAR_1 = VAR_15;
}
VAR_7 = VAR_17;
VAR_13 = VAR_4->w_curswant;
}
else
{
if (LT_POS(VAR_14->b_visual.vi_start, VAR_14->b_visual.vi_end))
{
VAR_0 = VAR_14->b_visual.vi_start;
VAR_1 = VAR_14->b_visual.vi_end;
}
else
{
VAR_0 = VAR_14->b_visual.vi_end;
VAR_1 = VAR_14->b_visual.vi_start;
}
VAR_7 = VAR_14->b_visual.vi_mode;
VAR_13 = VAR_14->b_visual.vi_curswant;
}
VAR_2 = VAR_5.lnum + VAR_5.reg_firstlnum;
if (VAR_2 < VAR_0.lnum || VAR_2 > VAR_1.lnum)
return FALSE;
if (VAR_7 == 'v')
{
VAR_3 = (colnr_T)(VAR_5.input - VAR_5.line);
if ((VAR_2 == VAR_0.lnum && VAR_3 < VAR_0.col)
|| (VAR_2 == VAR_1.lnum && VAR_3 >= VAR_1.col + (*VAR_18 != 'e')))
return FALSE;
}
else if (VAR_7 == VAR_19)
{
getvvcol(VAR_4, &VAR_0, &VAR_8, NULL, &VAR_9);
getvvcol(VAR_4, &VAR_1, &VAR_10, NULL, &VAR_11);
if (VAR_10 < VAR_8)
VAR_8 = VAR_10;
if (VAR_11 > VAR_9)
VAR_9 = VAR_11;
if (VAR_0.col == VAR_20 || VAR_1.col == VAR_20 || VAR_13 == VAR_20)
VAR_9 = VAR_20;
VAR_12 = win_linetabsize(VAR_4, VAR_5.line, (colnr_T)(VAR_5.input - VAR_5.line));
if (VAR_12 < VAR_8 || VAR_12 > VAR_9 - (*VAR_18 == 'e'))
return FALSE;
}
return TRUE;
}",vim/4c13e5e6763c6eb36a343a2b8235ea227202e952/regexp.c/vul/before/0.json,"static int
reg_match_visual(void)
{
    pos_T	top, bot;
    linenr_T    lnum;
    colnr_T	col;
    win_T	*wp = rex.reg_win == NULL ? curwin : rex.reg_win;
    int		mode;
    colnr_T	start, end;
    colnr_T	start2, end2;
    colnr_T	cols;
    colnr_T	curswant;

    // Check if the buffer is the current buffer.
    if (rex.reg_buf != curbuf || VIsual.lnum == 0)
	return FALSE;

    if (VIsual_active)
    {
	if (LT_POS(VIsual, wp->w_cursor))
	{
	    top = VIsual;
	    bot = wp->w_cursor;
	}
	else
	{
	    top = wp->w_cursor;
	    bot = VIsual;
	}
	mode = VIsual_mode;
	curswant = wp->w_curswant;
    }
    else
    {
	if (LT_POS(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end))
	{
	    top = curbuf->b_visual.vi_start;
	    bot = curbuf->b_visual.vi_end;
	}
	else
	{
	    top = curbuf->b_visual.vi_end;
	    bot = curbuf->b_visual.vi_start;
	}
	mode = curbuf->b_visual.vi_mode;
	curswant = curbuf->b_visual.vi_curswant;
    }
    lnum = rex.lnum + rex.reg_firstlnum;
    if (lnum < top.lnum || lnum > bot.lnum)
	return FALSE;

    col = (colnr_T)(rex.input - rex.line);
    if (mode == 'v')
    {
	if ((lnum == top.lnum && col < top.col)
		|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))
	    return FALSE;
    }
    else if (mode == Ctrl_V)
    {
	getvvcol(wp, &top, &start, NULL, &end);
	getvvcol(wp, &bot, &start2, NULL, &end2);
	if (start2 < start)
	    start = start2;
	if (end2 > end)
	    end = end2;
	if (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)
	    end = MAXCOL;

	// getvvcol() flushes rex.line, need to get it again
	rex.line = reg_getline(rex.lnum);
	rex.input = rex.line + col;

	cols = win_linetabsize(wp, rex.line, col);
	if (cols < start || cols > end - (*p_sel == 'e'))
	    return FALSE;
    }
    return TRUE;
}","static int
reg_match_visual(void)
{
    pos_T	VAR_0, VAR_1;
    linenr_T    VAR_2;
    colnr_T	VAR_3;
    win_T	*VAR_4 = VAR_5.reg_win == NULL ? VAR_6 : VAR_5.reg_win;
    int		VAR_7;
    colnr_T	VAR_8, VAR_9;
    colnr_T	VAR_10, VAR_11;
    colnr_T	VAR_12;
    colnr_T	VAR_13;

    /* COMMENT_0 */
    if (VAR_5.reg_buf != VAR_14 || VAR_15.lnum == 0)
	return FALSE;

    if (VAR_16)
    {
	if (LT_POS(VAR_15, VAR_4->w_cursor))
	{
	    VAR_0 = VAR_15;
	    VAR_1 = VAR_4->w_cursor;
	}
	else
	{
	    VAR_0 = VAR_4->w_cursor;
	    VAR_1 = VAR_15;
	}
	VAR_7 = VAR_17;
	VAR_13 = VAR_4->w_curswant;
    }
    else
    {
	if (LT_POS(VAR_14->b_visual.vi_start, VAR_14->b_visual.vi_end))
	{
	    VAR_0 = VAR_14->b_visual.vi_start;
	    VAR_1 = VAR_14->b_visual.vi_end;
	}
	else
	{
	    VAR_0 = VAR_14->b_visual.vi_end;
	    VAR_1 = VAR_14->b_visual.vi_start;
	}
	VAR_7 = VAR_14->b_visual.vi_mode;
	VAR_13 = VAR_14->b_visual.vi_curswant;
    }
    VAR_2 = VAR_5.lnum + VAR_5.reg_firstlnum;
    if (VAR_2 < VAR_0.lnum || VAR_2 > VAR_1.lnum)
	return FALSE;

    VAR_3 = (colnr_T)(VAR_5.input - VAR_5.line);
    if (VAR_7 == 'v')
    {
	if ((VAR_2 == VAR_0.lnum && VAR_3 < VAR_0.col)
		|| (VAR_2 == VAR_1.lnum && VAR_3 >= VAR_1.col + (*VAR_18 != 'e')))
	    return FALSE;
    }
    else if (VAR_7 == VAR_19)
    {
	getvvcol(VAR_4, &VAR_0, &VAR_8, NULL, &VAR_9);
	getvvcol(VAR_4, &VAR_1, &VAR_10, NULL, &VAR_11);
	if (VAR_10 < VAR_8)
	    VAR_8 = VAR_10;
	if (VAR_11 > VAR_9)
	    VAR_9 = VAR_11;
	if (VAR_0.col == VAR_20 || VAR_1.col == VAR_20 || VAR_13 == VAR_20)
	    VAR_9 = VAR_20;

	/* COMMENT_1 */
	VAR_5.line = reg_getline(VAR_5.lnum);
	VAR_5.input = VAR_5.line + VAR_3;

	VAR_12 = win_linetabsize(VAR_4, VAR_5.line, VAR_3);
	if (VAR_12 < VAR_8 || VAR_12 > VAR_9 - (*VAR_18 == 'e'))
	    return FALSE;
    }
    return TRUE;
}",vim/4c13e5e6763c6eb36a343a2b8235ea227202e952/regexp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -49,9 +49,9 @@
     if (lnum < top.lnum || lnum > bot.lnum)
 	return FALSE;
 
+    col = (colnr_T)(rex.input - rex.line);
     if (mode == 'v')
     {
-	col = (colnr_T)(rex.input - rex.line);
 	if ((lnum == top.lnum && col < top.col)
 		|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))
 	    return FALSE;
@@ -66,7 +66,12 @@
 	    end = end2;
 	if (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)
 	    end = MAXCOL;
-	cols = win_linetabsize(wp, rex.line, (colnr_T)(rex.input - rex.line));
+
+	// getvvcol() flushes rex.line, need to get it again
+	rex.line = reg_getline(rex.lnum);
+	rex.input = rex.line + col;
+
+	cols = win_linetabsize(wp, rex.line, col);
 	if (cols < start || cols > end - (*p_sel == 'e'))
 	    return FALSE;
     }","{'deleted_lines': ['\tcol = (colnr_T)(rex.input - rex.line);', '\tcols = win_linetabsize(wp, rex.line, (colnr_T)(rex.input - rex.line));'], 'added_lines': ['    col = (colnr_T)(rex.input - rex.line);', '', '\t// getvvcol() flushes rex.line, need to get it again', '\trex.line = reg_getline(rex.lnum);', '\trex.input = rex.line + col;', '', '\tcols = win_linetabsize(wp, rex.line, col);']}",True,vim is vulnerable to Use After Free,7.8,HIGH,2,test,2021-12-30T14:49:43Z,4
CVE-2023-22995,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"usb: dwc3: dwc3-qcom: Add missing platform_device_put() in dwc3_qcom_acpi_register_core

Add the missing platform_device_put() before return from
dwc3_qcom_acpi_register_core in the error handling case.

Signed-off-by: Miaoqian Lin <linmq006@gmail.com>
Link: https://lore.kernel.org/r/20211231113641.31474-1-linmq006@gmail.com
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",fa0ef93868a6062babe1144df2807a8b1d4924d2,https://github.com/torvalds/linux/commit/fa0ef93868a6062babe1144df2807a8b1d4924d2,drivers/usb/dwc3/dwc3-qcom.c,dwc3_qcom_acpi_register_core,"static int dwc3_qcom_acpi_register_core(struct platform_device *pdev)
{
struct dwc3_qcom*qcom = platform_get_drvdata(pdev);
struct device*dev = &pdev->dev;
struct resource*res, *child_res = NULL;
struct platform_device*pdev_irq = qcom->urs_usb ? qcom->urs_usb :
pdev;
intirq;
intret;
qcom->dwc3 = platform_device_alloc(""dwc3"", PLATFORM_DEVID_AUTO);
if (!qcom->dwc3)
return -ENOMEM;
qcom->dwc3->dev.parent = dev;
qcom->dwc3->dev.type = dev->type;
qcom->dwc3->dev.dma_mask = dev->dma_mask;
qcom->dwc3->dev.dma_parms = dev->dma_parms;
qcom->dwc3->dev.coherent_dma_mask = dev->coherent_dma_mask;
child_res = kcalloc(2, sizeof(*child_res), GFP_KERNEL);
if (!child_res)
return -ENOMEM;
res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
if (!res) {
dev_err(&pdev->dev, ""failed to get memory resource\n"");
ret = -ENODEV;
goto out;
}
child_res[0].flags = res->flags;
child_res[0].start = res->start;
child_res[0].end = child_res[0].start +
qcom->acpi_pdata->dwc3_core_base_size;
irq = platform_get_irq(pdev_irq, 0);
if (irq < 0) {
ret = irq;
goto out;
}
child_res[1].flags = IORESOURCE_IRQ;
child_res[1].start = child_res[1].end = irq;
ret = platform_device_add_resources(qcom->dwc3, child_res, 2);
if (ret) {
dev_err(&pdev->dev, ""failed to add resources\n"");
goto out;
}
ret = device_add_software_node(&qcom->dwc3->dev, &dwc3_qcom_swnode);
if (ret < 0) {
dev_err(&pdev->dev, ""failed to add properties\n"");
goto out;
}
ret = platform_device_add(qcom->dwc3);
if (ret) {
dev_err(&pdev->dev, ""failed to add device\n"");
device_remove_software_node(&qcom->dwc3->dev);
}
out:
kfree(child_res);
return ret;
}","static int dwc3_qcom_acpi_register_core(struct platform_device *VAR_0)
{
struct dwc3_qcom*VAR_1 = platform_get_drvdata(VAR_0);
struct device*VAR_2 = &VAR_0->dev;
struct resource*VAR_3, *VAR_4 = NULL;
struct platform_device*VAR_5 = VAR_1->urs_usb ? VAR_1->urs_usb :
VAR_0;
intVAR_6;
intVAR_7;
VAR_1->dwc3 = platform_device_alloc(""dwc3"", VAR_8);
if (!VAR_1->dwc3)
return -VAR_9;
VAR_1->dwc3->dev.parent = VAR_2;
VAR_1->dwc3->dev.type = VAR_2->type;
VAR_1->dwc3->dev.dma_mask = VAR_2->dma_mask;
VAR_1->dwc3->dev.dma_parms = VAR_2->dma_parms;
VAR_1->dwc3->dev.coherent_dma_mask = VAR_2->coherent_dma_mask;
VAR_4 = kcalloc(2, sizeof(*VAR_4), VAR_10);
if (!VAR_4)
return -VAR_9;
VAR_3 = platform_get_resource(VAR_0, VAR_11, 0);
if (!VAR_3) {
dev_err(&VAR_0->dev, ""failed to get memory resource\n"");
VAR_7 = -VAR_12;
goto out;
}
VAR_4[0].flags = VAR_3->flags;
VAR_4[0].start = VAR_3->start;
VAR_4[0].end = VAR_4[0].start +
VAR_1->acpi_pdata->dwc3_core_base_size;
VAR_6 = platform_get_irq(VAR_5, 0);
if (VAR_6 < 0) {
VAR_7 = VAR_6;
goto out;
}
VAR_4[1].flags = VAR_13;
VAR_4[1].start = VAR_4[1].end = VAR_6;
VAR_7 = platform_device_add_resources(VAR_1->dwc3, VAR_4, 2);
if (VAR_7) {
dev_err(&VAR_0->dev, ""failed to add resources\n"");
goto out;
}
VAR_7 = device_add_software_node(&VAR_1->dwc3->dev, &VAR_14);
if (VAR_7 < 0) {
dev_err(&VAR_0->dev, ""failed to add properties\n"");
goto out;
}
VAR_7 = platform_device_add(VAR_1->dwc3);
if (VAR_7) {
dev_err(&VAR_0->dev, ""failed to add device\n"");
device_remove_software_node(&VAR_1->dwc3->dev);
}
out:
kfree(VAR_4);
return VAR_7;
}",torvalds/linux/fa0ef93868a6062babe1144df2807a8b1d4924d2/dwc3-qcom.c/vul/before/0.json,"static int dwc3_qcom_acpi_register_core(struct platform_device *pdev)
{
	struct dwc3_qcom	*qcom = platform_get_drvdata(pdev);
	struct device		*dev = &pdev->dev;
	struct resource		*res, *child_res = NULL;
	struct platform_device	*pdev_irq = qcom->urs_usb ? qcom->urs_usb :
							    pdev;
	int			irq;
	int			ret;

	qcom->dwc3 = platform_device_alloc(""dwc3"", PLATFORM_DEVID_AUTO);
	if (!qcom->dwc3)
		return -ENOMEM;

	qcom->dwc3->dev.parent = dev;
	qcom->dwc3->dev.type = dev->type;
	qcom->dwc3->dev.dma_mask = dev->dma_mask;
	qcom->dwc3->dev.dma_parms = dev->dma_parms;
	qcom->dwc3->dev.coherent_dma_mask = dev->coherent_dma_mask;

	child_res = kcalloc(2, sizeof(*child_res), GFP_KERNEL);
	if (!child_res) {
		platform_device_put(qcom->dwc3);
		return -ENOMEM;
	}

	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	if (!res) {
		dev_err(&pdev->dev, ""failed to get memory resource\n"");
		ret = -ENODEV;
		goto out;
	}

	child_res[0].flags = res->flags;
	child_res[0].start = res->start;
	child_res[0].end = child_res[0].start +
		qcom->acpi_pdata->dwc3_core_base_size;

	irq = platform_get_irq(pdev_irq, 0);
	if (irq < 0) {
		ret = irq;
		goto out;
	}
	child_res[1].flags = IORESOURCE_IRQ;
	child_res[1].start = child_res[1].end = irq;

	ret = platform_device_add_resources(qcom->dwc3, child_res, 2);
	if (ret) {
		dev_err(&pdev->dev, ""failed to add resources\n"");
		goto out;
	}

	ret = device_add_software_node(&qcom->dwc3->dev, &dwc3_qcom_swnode);
	if (ret < 0) {
		dev_err(&pdev->dev, ""failed to add properties\n"");
		goto out;
	}

	ret = platform_device_add(qcom->dwc3);
	if (ret) {
		dev_err(&pdev->dev, ""failed to add device\n"");
		device_remove_software_node(&qcom->dwc3->dev);
		goto out;
	}
	kfree(child_res);
	return 0;

out:
	platform_device_put(qcom->dwc3);
	kfree(child_res);
	return ret;
}","static int dwc3_qcom_acpi_register_core(struct platform_device *VAR_0)
{
	struct dwc3_qcom	*VAR_1 = platform_get_drvdata(VAR_0);
	struct device		*VAR_2 = &VAR_0->dev;
	struct resource		*VAR_3, *VAR_4 = NULL;
	struct platform_device	*VAR_5 = VAR_1->urs_usb ? VAR_1->urs_usb :
							    VAR_0;
	int			VAR_6;
	int			VAR_7;

	VAR_1->dwc3 = platform_device_alloc(""dwc3"", VAR_8);
	if (!VAR_1->dwc3)
		return -VAR_9;

	VAR_1->dwc3->dev.parent = VAR_2;
	VAR_1->dwc3->dev.type = VAR_2->type;
	VAR_1->dwc3->dev.dma_mask = VAR_2->dma_mask;
	VAR_1->dwc3->dev.dma_parms = VAR_2->dma_parms;
	VAR_1->dwc3->dev.coherent_dma_mask = VAR_2->coherent_dma_mask;

	VAR_4 = kcalloc(2, sizeof(*VAR_4), VAR_10);
	if (!VAR_4) {
		platform_device_put(VAR_1->dwc3);
		return -VAR_9;
	}

	VAR_3 = platform_get_resource(VAR_0, VAR_11, 0);
	if (!VAR_3) {
		dev_err(&VAR_0->dev, ""failed to get memory resource\n"");
		VAR_7 = -VAR_12;
		goto out;
	}

	VAR_4[0].flags = VAR_3->flags;
	VAR_4[0].start = VAR_3->start;
	VAR_4[0].end = VAR_4[0].start +
		VAR_1->acpi_pdata->dwc3_core_base_size;

	VAR_6 = platform_get_irq(VAR_5, 0);
	if (VAR_6 < 0) {
		VAR_7 = VAR_6;
		goto out;
	}
	VAR_4[1].flags = VAR_13;
	VAR_4[1].start = VAR_4[1].end = VAR_6;

	VAR_7 = platform_device_add_resources(VAR_1->dwc3, VAR_4, 2);
	if (VAR_7) {
		dev_err(&VAR_0->dev, ""failed to add resources\n"");
		goto out;
	}

	VAR_7 = device_add_software_node(&VAR_1->dwc3->dev, &VAR_14);
	if (VAR_7 < 0) {
		dev_err(&VAR_0->dev, ""failed to add properties\n"");
		goto out;
	}

	VAR_7 = platform_device_add(VAR_1->dwc3);
	if (VAR_7) {
		dev_err(&VAR_0->dev, ""failed to add device\n"");
		device_remove_software_node(&VAR_1->dwc3->dev);
		goto out;
	}
	kfree(VAR_4);
	return 0;

out:
	platform_device_put(VAR_1->dwc3);
	kfree(VAR_4);
	return VAR_7;
}",torvalds/linux/fa0ef93868a6062babe1144df2807a8b1d4924d2/dwc3-qcom.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -19,8 +19,10 @@
 	qcom->dwc3->dev.coherent_dma_mask = dev->coherent_dma_mask;
 
 	child_res = kcalloc(2, sizeof(*child_res), GFP_KERNEL);
-	if (!child_res)
+	if (!child_res) {
+		platform_device_put(qcom->dwc3);
 		return -ENOMEM;
+	}
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
@@ -58,9 +60,13 @@
 	if (ret) {
 		dev_err(&pdev->dev, ""failed to add device\n"");
 		device_remove_software_node(&qcom->dwc3->dev);
+		goto out;
 	}
+	kfree(child_res);
+	return 0;
 
 out:
+	platform_device_put(qcom->dwc3);
 	kfree(child_res);
 	return ret;
 }","{'deleted_lines': ['\tif (!child_res)'], 'added_lines': ['\tif (!child_res) {', '\t\tplatform_device_put(qcom->dwc3);', '\t}', '\t\tgoto out;', '\tkfree(child_res);', '\treturn 0;', '\tplatform_device_put(qcom->dwc3);']}",True,"In the Linux kernel before 5.17, an error path in dwc3_qcom_acpi_register_core in drivers/usb/dwc3/dwc3-qcom.c lacks certain platform_device_put and kfree calls.",7.8,HIGH,2,test,2021-12-31T11:36:41Z,4
CVE-2022-0080,['CWE-122'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,mruby,"proc.c: should not reference `irep` when copying failed.

It may cause broken reference count numbers.",28ccc664e5dcd3f9d55173e9afde77c4705a9ab6,https://github.com/mruby/mruby/commit/28ccc664e5dcd3f9d55173e9afde77c4705a9ab6,src/proc.c,mrb_proc_copy,"void
mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)
{
if (a->body.irep) {
return;
}
a->flags = b->flags;
a->body = b->body;
a->upper = b->upper;
if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {
mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);
}
a->e.env = b->e.env;
}","void
mrb_proc_copy(mrb_state *VAR_0, struct RProc *VAR_1, struct RProc *VAR_2)
{
if (VAR_1->body.irep) {
return;
}
VAR_1->flags = VAR_2->flags;
VAR_1->body = VAR_2->body;
VAR_1->upper = VAR_2->upper;
if (!MRB_PROC_CFUNC_P(VAR_1) && VAR_1->body.irep) {
mrb_irep_incref(VAR_0, (mrb_irep*)VAR_1->body.irep);
}
VAR_1->e.env = VAR_2->e.env;
}",mruby/28ccc664e5dcd3f9d55173e9afde77c4705a9ab6/proc.c/vul/before/0.json,"void
mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)
{
  if (a->body.irep) {
    /* already initialized proc */
    return;
  }
  if (!MRB_PROC_CFUNC_P(b) && b->body.irep) {
    mrb_irep_incref(mrb, (mrb_irep*)b->body.irep);
  }
  a->flags = b->flags;
  a->body = b->body;
  a->upper = b->upper;
  a->e.env = b->e.env;
  /* a->e.target_class = a->e.target_class; */
}","void
mrb_proc_copy(mrb_state *VAR_0, struct RProc *VAR_1, struct RProc *VAR_2)
{
  if (VAR_1->body.irep) {
    /* COMMENT_0 */
    return;
  }
  if (!MRB_PROC_CFUNC_P(VAR_2) && VAR_2->body.irep) {
    mrb_irep_incref(VAR_0, (mrb_irep*)VAR_2->body.irep);
  }
  VAR_1->flags = VAR_2->flags;
  VAR_1->body = VAR_2->body;
  VAR_1->upper = VAR_2->upper;
  VAR_1->e.env = VAR_2->e.env;
  /* COMMENT_1 */
}",mruby/28ccc664e5dcd3f9d55173e9afde77c4705a9ab6/proc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,12 +5,12 @@
     /* already initialized proc */
     return;
   }
+  if (!MRB_PROC_CFUNC_P(b) && b->body.irep) {
+    mrb_irep_incref(mrb, (mrb_irep*)b->body.irep);
+  }
   a->flags = b->flags;
   a->body = b->body;
   a->upper = b->upper;
-  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {
-    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);
-  }
   a->e.env = b->e.env;
   /* a->e.target_class = a->e.target_class; */
 }","{'deleted_lines': ['  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {', '    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);', '  }'], 'added_lines': ['  if (!MRB_PROC_CFUNC_P(b) && b->body.irep) {', '    mrb_irep_incref(mrb, (mrb_irep*)b->body.irep);', '  }']}",True,mruby is vulnerable to Heap-based Buffer Overflow,9.8,CRITICAL,3,test,2022-01-01T12:02:58Z,4
CVE-2021-46347,['CWE-617'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,jerryscript-project/jerryscript,"Add missing object types for ecma_object_get_class_name

This patch fixes #4937 and fixes #4938.

JerryScript-DCO-1.0-Signed-off-by: Robert Fancsik robert.fancsik@h-lab.eu",b0625e61819e1f5823f16f2463f5def4ab16bdfb,https://github.com/jerryscript-project/jerryscript/commit/b0625e61819e1f5823f16f2463f5def4ab16bdfb,jerry-core/ecma/operations/ecma-objects.c,ecma_object_check_class_name_is_object,"static inline bool
ecma_object_check_class_name_is_object (ecma_object_t *obj_p) 
{
#ifndef JERRY_NDEBUG
return (ecma_builtin_is_global (obj_p)
#if JERRY_BUILTIN_TYPEDARRAY
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ARRAYBUFFER_PROTOTYPE)
#if JERRY_BUILTIN_SHAREDARRAYBUFFER
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SHARED_ARRAYBUFFER_PROTOTYPE)
#endif 
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_TYPEDARRAY_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_INT8ARRAY_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_UINT8ARRAY_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_INT16ARRAY_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_UINT16ARRAY_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_INT32ARRAY_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_UINT32ARRAY_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_FLOAT32ARRAY_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_UINT8CLAMPEDARRAY_PROTOTYPE)
#if JERRY_NUMBER_TYPE_FLOAT64
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_FLOAT64ARRAY_PROTOTYPE)
#endif 
#if JERRY_BUILTIN_BIGINT
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_BIGINT64ARRAY_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_BIGUINT64ARRAY_PROTOTYPE)
#endif 
#endif 
#if JERRY_ESNEXT
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ARRAY_PROTOTYPE_UNSCOPABLES)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ARRAY_ITERATOR_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ITERATOR_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_STRING_ITERATOR_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_REGEXP_STRING_ITERATOR_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_EVAL_ERROR_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_RANGE_ERROR_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_REFERENCE_ERROR_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SYNTAX_ERROR_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_GENERATOR_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_TYPE_ERROR_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_AGGREGATE_ERROR_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_URI_ERROR_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ERROR_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_DATE_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_REGEXP_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SYMBOL_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ASYNC_FUNCTION_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_PROMISE_PROTOTYPE)
#endif 
#if JERRY_BUILTIN_CONTAINER
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_MAP_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SET_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_WEAKMAP_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_WEAKSET_PROTOTYPE)
#if JERRY_ESNEXT
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_MAP_ITERATOR_PROTOTYPE)
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SET_ITERATOR_PROTOTYPE)
#endif 
#endif 
#if JERRY_BUILTIN_WEAKREF
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_WEAKREF_PROTOTYPE)
#endif 
#if JERRY_BUILTIN_DATAVIEW
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_DATAVIEW_PROTOTYPE)
#endif 
|| ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_OBJECT_PROTOTYPE));
#else 
JERRY_UNUSED (obj_p);
return true;
#endif 
}","static inline bool
ecma_object_check_class_name_is_object (ecma_object_t *VAR_0) 
{
#ifndef VAR_1
return (VAR_2 (obj_p)
#if VAR_3
|| ecma_builtin_is (obj_p, VAR_4)
#if VAR_5
|| ecma_builtin_is (obj_p, VAR_6)
#endif 
|| ecma_builtin_is (obj_p, VAR_7)
|| ecma_builtin_is (obj_p, VAR_8)
|| ecma_builtin_is (obj_p, VAR_9)
|| ecma_builtin_is (obj_p, VAR_10)
|| ecma_builtin_is (obj_p, VAR_11)
|| ecma_builtin_is (obj_p, VAR_12)
|| ecma_builtin_is (obj_p, VAR_13)
|| ecma_builtin_is (obj_p, VAR_14)
|| ecma_builtin_is (obj_p, VAR_15)
#if VAR_16
|| ecma_builtin_is (obj_p, VAR_17)
#endif 
#if VAR_18
|| ecma_builtin_is (obj_p, VAR_19)
|| ecma_builtin_is (obj_p, VAR_20)
#endif 
#endif
#if VAR_21
|| ecma_builtin_is (obj_p, VAR_22)
|| ecma_builtin_is (obj_p, VAR_23)
|| ecma_builtin_is (obj_p, VAR_24)
|| ecma_builtin_is (obj_p, VAR_25)
|| ecma_builtin_is (obj_p, VAR_26)
|| ecma_builtin_is (obj_p, VAR_27)
|| ecma_builtin_is (obj_p, VAR_28)
|| ecma_builtin_is (obj_p, VAR_29)
|| ecma_builtin_is (obj_p, VAR_30)
|| ecma_builtin_is (obj_p, VAR_31)
|| ecma_builtin_is (obj_p, VAR_32)
|| ecma_builtin_is (obj_p, VAR_33)
|| ecma_builtin_is (obj_p, VAR_34)
|| ecma_builtin_is (obj_p, VAR_35)
|| ecma_builtin_is (obj_p, VAR_36)
|| ecma_builtin_is (obj_p, VAR_37)
|| ecma_builtin_is (obj_p, VAR_38)
|| ecma_builtin_is (obj_p, VAR_39)
|| ecma_builtin_is (obj_p, VAR_40)
#endif 
#if VAR_41
|| ecma_builtin_is (obj_p, VAR_42)
|| ecma_builtin_is (obj_p, VAR_43)
|| ecma_builtin_is (obj_p, VAR_44)
|| ecma_builtin_is (obj_p, VAR_45)
#if VAR_21
|| ecma_builtin_is (obj_p, VAR_46)
|| ecma_builtin_is (obj_p, VAR_47)
#endif 
#endif
#if VAR_48
|| ecma_builtin_is (obj_p, VAR_49)
#endif 
#if VAR_50
|| ecma_builtin_is (obj_p, VAR_51)
#endif 
|| ecma_builtin_is (obj_p, VAR_52));
#else 
JERRY_UNUSED (obj_p);
return true;
#endif 
}",jerryscript-project/jerryscript/b0625e61819e1f5823f16f2463f5def4ab16bdfb/ecma-objects.c/vul/before/0.json,"static inline bool
ecma_object_check_class_name_is_object (ecma_object_t *obj_p) /**< object */
{
#ifndef JERRY_NDEBUG
  return (ecma_builtin_is_global (obj_p)
#if JERRY_BUILTIN_TYPEDARRAY
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ARRAYBUFFER_PROTOTYPE)
#if JERRY_BUILTIN_SHAREDARRAYBUFFER
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SHARED_ARRAYBUFFER_PROTOTYPE)
#endif /* JERRY_BUILTIN_SHAREDARRAYBUFFER */
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_TYPEDARRAY_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_INT8ARRAY_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_UINT8ARRAY_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_INT16ARRAY_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_UINT16ARRAY_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_INT32ARRAY_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_UINT32ARRAY_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_FLOAT32ARRAY_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_UINT8CLAMPEDARRAY_PROTOTYPE)
#if JERRY_NUMBER_TYPE_FLOAT64
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_FLOAT64ARRAY_PROTOTYPE)
#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
#if JERRY_BUILTIN_BIGINT
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_BIGINT_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_BIGINT64ARRAY_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_BIGUINT64ARRAY_PROTOTYPE)
#endif /* JERRY_BUILTIN_BIGINT */
#endif /* JERRY_BUILTIN_TYPEDARRAY */
#if JERRY_ESNEXT
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ARRAY_PROTOTYPE_UNSCOPABLES)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ARRAY_ITERATOR_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ITERATOR_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_STRING_ITERATOR_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_REGEXP_STRING_ITERATOR_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_EVAL_ERROR_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_RANGE_ERROR_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_REFERENCE_ERROR_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SYNTAX_ERROR_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_GENERATOR_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_TYPE_ERROR_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_AGGREGATE_ERROR_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_URI_ERROR_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ERROR_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_DATE_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_REGEXP_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SYMBOL_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ASYNC_FUNCTION_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_PROMISE_PROTOTYPE)
#endif /* JERRY_ESNEXT */
#if JERRY_BUILTIN_CONTAINER
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_MAP_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SET_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_WEAKMAP_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_WEAKSET_PROTOTYPE)
#if JERRY_ESNEXT
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_MAP_ITERATOR_PROTOTYPE)
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SET_ITERATOR_PROTOTYPE)
#endif /* JERRY_ESNEXT */
#endif /* JERRY_BUILTIN_CONTAINER */
#if JERRY_BUILTIN_WEAKREF
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_WEAKREF_PROTOTYPE)
#endif /* JERRY_BUILTIN_WEAKREF */
#if JERRY_BUILTIN_DATAVIEW
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_DATAVIEW_PROTOTYPE)
#endif /* JERRY_BUILTIN_DATAVIEW */
          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_OBJECT_PROTOTYPE));
#else /* JERRY_NDEBUG */
  JERRY_UNUSED (obj_p);
  return true;
#endif /* !JERRY_NDEBUG */
}","static inline bool
ecma_object_check_class_name_is_object (ecma_object_t *VAR_0) /* COMMENT_0 */
{
#ifndef VAR_1
  return (VAR_2 (obj_p)
#if VAR_3
          || ecma_builtin_is (obj_p, VAR_4)
#if VAR_5
          || ecma_builtin_is (obj_p, VAR_6)
#endif /* COMMENT_1 */
          || ecma_builtin_is (obj_p, VAR_7)
          || ecma_builtin_is (obj_p, VAR_8)
          || ecma_builtin_is (obj_p, VAR_9)
          || ecma_builtin_is (obj_p, VAR_10)
          || ecma_builtin_is (obj_p, VAR_11)
          || ecma_builtin_is (obj_p, VAR_12)
          || ecma_builtin_is (obj_p, VAR_13)
          || ecma_builtin_is (obj_p, VAR_14)
          || ecma_builtin_is (obj_p, VAR_15)
#if VAR_16
          || ecma_builtin_is (obj_p, VAR_17)
#endif /* COMMENT_2 */
#if VAR_18
          || ecma_builtin_is (obj_p, VAR_19)
          || ecma_builtin_is (obj_p, VAR_20)
          || ecma_builtin_is (obj_p, VAR_21)
#endif /* COMMENT_3 */
#endif/* COMMENT_4 */
#if VAR_22
          || ecma_builtin_is (obj_p, VAR_23)
          || ecma_builtin_is (obj_p, VAR_24)
          || ecma_builtin_is (obj_p, VAR_25)
          || ecma_builtin_is (obj_p, VAR_26)
          || ecma_builtin_is (obj_p, VAR_27)
          || ecma_builtin_is (obj_p, VAR_28)
          || ecma_builtin_is (obj_p, VAR_29)
          || ecma_builtin_is (obj_p, VAR_30)
          || ecma_builtin_is (obj_p, VAR_31)
          || ecma_builtin_is (obj_p, VAR_32)
          || ecma_builtin_is (obj_p, VAR_33)
          || ecma_builtin_is (obj_p, VAR_34)
          || ecma_builtin_is (obj_p, VAR_35)
          || ecma_builtin_is (obj_p, VAR_36)
          || ecma_builtin_is (obj_p, VAR_37)
          || ecma_builtin_is (obj_p, VAR_38)
          || ecma_builtin_is (obj_p, VAR_39)
          || ecma_builtin_is (obj_p, VAR_40)
          || ecma_builtin_is (obj_p, VAR_41)
#endif /* COMMENT_5 */
#if VAR_42
          || ecma_builtin_is (obj_p, VAR_43)
          || ecma_builtin_is (obj_p, VAR_44)
          || ecma_builtin_is (obj_p, VAR_45)
          || ecma_builtin_is (obj_p, VAR_46)
#if VAR_22
          || ecma_builtin_is (obj_p, VAR_47)
          || ecma_builtin_is (obj_p, VAR_48)
#endif /* COMMENT_5 */
#endif/* COMMENT_6 */
#if VAR_49
          || ecma_builtin_is (obj_p, VAR_50)
#endif /* COMMENT_7 */
#if VAR_51
          || ecma_builtin_is (obj_p, VAR_52)
#endif /* COMMENT_8 */
          || ecma_builtin_is (obj_p, VAR_53));
#else /* COMMENT_9 */
  JERRY_UNUSED (obj_p);
  return true;
#endif /* COMMENT_10 */
}",jerryscript-project/jerryscript/b0625e61819e1f5823f16f2463f5def4ab16bdfb/ecma-objects.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -21,6 +21,7 @@
           || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_FLOAT64ARRAY_PROTOTYPE)
 #endif /* JERRY_NUMBER_TYPE_FLOAT64 */
 #if JERRY_BUILTIN_BIGINT
+          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_BIGINT_PROTOTYPE)
           || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_BIGINT64ARRAY_PROTOTYPE)
           || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_BIGUINT64ARRAY_PROTOTYPE)
 #endif /* JERRY_BUILTIN_BIGINT */","{'deleted_lines': [], 'added_lines': ['          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_BIGINT_PROTOTYPE)']}",True,There is an Assertion 'ecma_object_check_class_name_is_object (obj_p)' failed at /jerry-core/ecma/operations/ecma-objects.c in JerryScript 3.0.0.,5.5,MEDIUM,1,test,2022-01-04T15:42:46Z,4
CVE-2021-46347,['CWE-617'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,jerryscript-project/jerryscript,"Add missing object types for ecma_object_get_class_name

This patch fixes #4937 and fixes #4938.

JerryScript-DCO-1.0-Signed-off-by: Robert Fancsik robert.fancsik@h-lab.eu",b0625e61819e1f5823f16f2463f5def4ab16bdfb,https://github.com/jerryscript-project/jerryscript/commit/b0625e61819e1f5823f16f2463f5def4ab16bdfb,jerry-core/ecma/operations/ecma-objects.c,ecma_object_get_class_name,"lit_magic_string_id_t
ecma_object_get_class_name (ecma_object_t *obj_p) 
{
ecma_object_type_t type = ecma_get_object_type (obj_p);
switch (type)
{
case ECMA_OBJECT_TYPE_ARRAY:
case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
{
return LIT_MAGIC_STRING_ARRAY_UL;
}
case ECMA_OBJECT_TYPE_CLASS:
case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:
{
ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
switch (ext_object_p->u.cls.type)
{
#if JERRY_BUILTIN_TYPEDARRAY
case ECMA_OBJECT_CLASS_TYPEDARRAY:
{
return ecma_get_typedarray_magic_string_id (ext_object_p->u.cls.u1.typedarray_type);
}
#endif 
#if JERRY_BUILTIN_CONTAINER
case ECMA_OBJECT_CLASS_CONTAINER:
{
return (lit_magic_string_id_t) ext_object_p->u.cls.u2.container_id;
}
#endif 
default:
{
break;
}
}
JERRY_ASSERT (ext_object_p->u.cls.type < ECMA_OBJECT_CLASS__MAX);
JERRY_ASSERT (ecma_class_object_magic_string_id[ext_object_p->u.cls.type] != LIT_MAGIC_STRING__EMPTY);
return (lit_magic_string_id_t) ecma_class_object_magic_string_id[ext_object_p->u.cls.type];
}
case ECMA_OBJECT_TYPE_FUNCTION:
case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
{
return LIT_MAGIC_STRING_FUNCTION_UL;
}
#if JERRY_BUILTIN_PROXY
case ECMA_OBJECT_TYPE_PROXY:
{
ecma_proxy_object_t *proxy_obj_p = (ecma_proxy_object_t *) obj_p;
if (!ecma_is_value_null (proxy_obj_p->target) && ecma_is_value_object (proxy_obj_p->target))
{
ecma_object_t *target_obj_p = ecma_get_object_from_value (proxy_obj_p->target);
return ecma_object_get_class_name (target_obj_p);
}
return LIT_MAGIC_STRING_OBJECT_UL;
}
#endif 
case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:
{
ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
switch (ext_obj_p->u.built_in.id)
{
#if JERRY_BUILTIN_MATH
case ECMA_BUILTIN_ID_MATH:
{
return LIT_MAGIC_STRING_MATH_UL;
}
#endif 
#if JERRY_BUILTIN_REFLECT
case ECMA_BUILTIN_ID_REFLECT:
{
return LIT_MAGIC_STRING_REFLECT_UL;
}
#endif 
#if JERRY_ESNEXT
case ECMA_BUILTIN_ID_GENERATOR:
{
return LIT_MAGIC_STRING_GENERATOR_UL;
}
case ECMA_BUILTIN_ID_ASYNC_GENERATOR:
{
return LIT_MAGIC_STRING_ASYNC_GENERATOR_UL;
}
#endif 
#if JERRY_BUILTIN_JSON
case ECMA_BUILTIN_ID_JSON:
{
return LIT_MAGIC_STRING_JSON_U;
}
#endif 
#if JERRY_BUILTIN_ATOMICS
case ECMA_BUILTIN_ID_ATOMICS:
{
return LIT_MAGIC_STRING_ATOMICS_U;
}
#endif 
#if !JERRY_ESNEXT
#if JERRY_BUILTIN_ERRORS
case ECMA_BUILTIN_ID_EVAL_ERROR_PROTOTYPE:
case ECMA_BUILTIN_ID_RANGE_ERROR_PROTOTYPE:
case ECMA_BUILTIN_ID_REFERENCE_ERROR_PROTOTYPE:
case ECMA_BUILTIN_ID_SYNTAX_ERROR_PROTOTYPE:
case ECMA_BUILTIN_ID_TYPE_ERROR_PROTOTYPE:
case ECMA_BUILTIN_ID_URI_ERROR_PROTOTYPE:
#endif 
case ECMA_BUILTIN_ID_ERROR_PROTOTYPE:
{
return LIT_MAGIC_STRING_ERROR_UL;
}
#endif 
default:
{
break;
}
}
JERRY_ASSERT (ecma_object_check_class_name_is_object (obj_p));
return LIT_MAGIC_STRING_OBJECT_UL;
}
default:
{
JERRY_ASSERT (type == ECMA_OBJECT_TYPE_GENERAL || type == ECMA_OBJECT_TYPE_PROXY);
return LIT_MAGIC_STRING_OBJECT_UL;
}
}
}","lit_magic_string_id_t
ecma_object_get_class_name (ecma_object_t *VAR_0) 
{
ecma_object_type_t VAR_1 = ecma_get_object_type (VAR_0);
switch (VAR_1)
{
case VAR_2:
case VAR_3:
{
return VAR_4;
}
case VAR_5:
case VAR_6:
{
ecma_extended_object_t *VAR_7 = (ecma_extended_object_t *) VAR_0;
switch (VAR_7->u.cls.type)
{
#if VAR_8
case VAR_9:
{
return ecma_get_typedarray_magic_string_id (VAR_7->u.cls.u1.typedarray_type);
}
#endif 
#if VAR_10
case VAR_11:
{
return (lit_magic_string_id_t) VAR_7->u.cls.u2.container_id;
}
#endif 
default:
{
break;
}
}
JERRY_ASSERT (VAR_7->u.cls.type < VAR_12);
JERRY_ASSERT (VAR_13[VAR_7->u.cls.type] != VAR_14);
return (lit_magic_string_id_t) VAR_13[VAR_7->u.cls.type];
}
case VAR_15:
case VAR_16:
case VAR_17:
case VAR_18:
{
return VAR_19;
}
#if VAR_20
case VAR_21:
{
ecma_proxy_object_t *VAR_22 = (ecma_proxy_object_t *) VAR_0;
if (!ecma_is_value_null (VAR_22->target) && ecma_is_value_object (VAR_22->target))
{
ecma_object_t *VAR_23 = ecma_get_object_from_value (VAR_22->target);
return ecma_object_get_class_name (VAR_23);
}
return VAR_24;
}
#endif 
case VAR_25:
{
ecma_extended_object_t *VAR_26 = (ecma_extended_object_t *) VAR_0;
switch (VAR_26->u.built_in.id)
{
#if VAR_27
case VAR_28:
{
return VAR_29;
}
#endif 
#if VAR_30
case VAR_31:
{
return VAR_32;
}
#endif 
#if VAR_33
case VAR_34:
{
return VAR_35;
}
case VAR_36:
{
return VAR_37;
}
#endif 
#if VAR_38
case VAR_39:
{
return VAR_40;
}
#endif 
#if VAR_41
case VAR_42:
{
return VAR_43;
}
#endif 
#if !VAR_33
#if VAR_44
case VAR_45:
case VAR_46:
case VAR_47:
case VAR_48:
case VAR_49:
case VAR_50:
#endif 
case VAR_51:
{
return VAR_52;
}
#endif 
default:
{
break;
}
}
JERRY_ASSERT (ecma_object_check_class_name_is_object (VAR_0));
return VAR_24;
}
default:
{
JERRY_ASSERT (VAR_1 == VAR_53 || VAR_1 == VAR_21);
return VAR_24;
}
}
}",jerryscript-project/jerryscript/b0625e61819e1f5823f16f2463f5def4ab16bdfb/ecma-objects.c/vul/before/1.json,"lit_magic_string_id_t
ecma_object_get_class_name (ecma_object_t *obj_p) /**< object */
{
  ecma_object_type_t type = ecma_get_object_type (obj_p);

  switch (type)
  {
    case ECMA_OBJECT_TYPE_ARRAY:
    case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
    {
      return LIT_MAGIC_STRING_ARRAY_UL;
    }
    case ECMA_OBJECT_TYPE_CLASS:
    case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:
    {
      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;

      switch (ext_object_p->u.cls.type)
      {
#if JERRY_BUILTIN_TYPEDARRAY
        case ECMA_OBJECT_CLASS_TYPEDARRAY:
        {
          return ecma_get_typedarray_magic_string_id (ext_object_p->u.cls.u1.typedarray_type);
        }
#endif /* JERRY_BUILTIN_TYPEDARRAY */
#if JERRY_BUILTIN_CONTAINER
        case ECMA_OBJECT_CLASS_CONTAINER:
        {
          return (lit_magic_string_id_t) ext_object_p->u.cls.u2.container_id;
        }
#endif /* JERRY_BUILTIN_CONTAINER */
        default:
        {
          break;
        }
      }

      JERRY_ASSERT (ext_object_p->u.cls.type < ECMA_OBJECT_CLASS__MAX);
      JERRY_ASSERT (ecma_class_object_magic_string_id[ext_object_p->u.cls.type] != LIT_MAGIC_STRING__EMPTY);

      return (lit_magic_string_id_t) ecma_class_object_magic_string_id[ext_object_p->u.cls.type];
    }
    case ECMA_OBJECT_TYPE_FUNCTION:
    case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
    case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
    case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
    case ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION:
    {
      return LIT_MAGIC_STRING_FUNCTION_UL;
    }
#if JERRY_BUILTIN_PROXY
    case ECMA_OBJECT_TYPE_PROXY:
    {
      ecma_proxy_object_t *proxy_obj_p = (ecma_proxy_object_t *) obj_p;

      if (!ecma_is_value_null (proxy_obj_p->target) && ecma_is_value_object (proxy_obj_p->target))
      {
        ecma_object_t *target_obj_p = ecma_get_object_from_value (proxy_obj_p->target);
        return ecma_object_get_class_name (target_obj_p);
      }
      return LIT_MAGIC_STRING_OBJECT_UL;
    }
#endif /* JERRY_BUILTIN_PROXY */
    case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:
    {
      ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;

      switch (ext_obj_p->u.built_in.id)
      {
#if JERRY_BUILTIN_MATH
        case ECMA_BUILTIN_ID_MATH:
        {
          return LIT_MAGIC_STRING_MATH_UL;
        }
#endif /* JERRY_BUILTIN_MATH */
#if JERRY_BUILTIN_REFLECT
        case ECMA_BUILTIN_ID_REFLECT:
        {
          return LIT_MAGIC_STRING_REFLECT_UL;
        }
#endif /* JERRY_BUILTIN_REFLECT */
#if JERRY_ESNEXT
        case ECMA_BUILTIN_ID_GENERATOR:
        {
          return LIT_MAGIC_STRING_GENERATOR_UL;
        }
        case ECMA_BUILTIN_ID_ASYNC_GENERATOR:
        {
          return LIT_MAGIC_STRING_ASYNC_GENERATOR_UL;
        }
#endif /* JERRY_ESNEXT */
#if JERRY_BUILTIN_JSON
        case ECMA_BUILTIN_ID_JSON:
        {
          return LIT_MAGIC_STRING_JSON_U;
        }
#endif /* JERRY_BUILTIN_JSON */
#if JERRY_BUILTIN_ATOMICS
        case ECMA_BUILTIN_ID_ATOMICS:
        {
          return LIT_MAGIC_STRING_ATOMICS_U;
        }
#endif /* JERRY_BUILTIN_ATOMICS */
#if !JERRY_ESNEXT
#if JERRY_BUILTIN_ERRORS
        case ECMA_BUILTIN_ID_EVAL_ERROR_PROTOTYPE:
        case ECMA_BUILTIN_ID_RANGE_ERROR_PROTOTYPE:
        case ECMA_BUILTIN_ID_REFERENCE_ERROR_PROTOTYPE:
        case ECMA_BUILTIN_ID_SYNTAX_ERROR_PROTOTYPE:
        case ECMA_BUILTIN_ID_TYPE_ERROR_PROTOTYPE:
        case ECMA_BUILTIN_ID_URI_ERROR_PROTOTYPE:
#endif /* JERRY_BUILTIN_ERRORS */
        case ECMA_BUILTIN_ID_ERROR_PROTOTYPE:
        {
          return LIT_MAGIC_STRING_ERROR_UL;
        }
#endif /* !JERRY_ESNEXT */
        default:
        {
          break;
        }
      }

      JERRY_ASSERT (ecma_object_check_class_name_is_object (obj_p));
      return LIT_MAGIC_STRING_OBJECT_UL;
    }
    default:
    {
      JERRY_ASSERT (type == ECMA_OBJECT_TYPE_GENERAL || type == ECMA_OBJECT_TYPE_PROXY);

      return LIT_MAGIC_STRING_OBJECT_UL;
    }
  }
}","lit_magic_string_id_t
ecma_object_get_class_name (ecma_object_t *VAR_0) /* COMMENT_0 */
{
  ecma_object_type_t VAR_1 = ecma_get_object_type (VAR_0);

  switch (VAR_1)
  {
    case VAR_2:
    case VAR_3:
    {
      return VAR_4;
    }
    case VAR_5:
    case VAR_6:
    {
      ecma_extended_object_t *VAR_7 = (ecma_extended_object_t *) VAR_0;

      switch (VAR_7->u.cls.type)
      {
#if VAR_8
        case VAR_9:
        {
          return ecma_get_typedarray_magic_string_id (VAR_7->u.cls.u1.typedarray_type);
        }
#endif /* COMMENT_1 */
#if VAR_10
        case VAR_11:
        {
          return (lit_magic_string_id_t) VAR_7->u.cls.u2.container_id;
        }
#endif /* COMMENT_2 */
        default:
        {
          break;
        }
      }

      JERRY_ASSERT (VAR_7->u.cls.type < VAR_12);
      JERRY_ASSERT (VAR_13[VAR_7->u.cls.type] != VAR_14);

      return (lit_magic_string_id_t) VAR_13[VAR_7->u.cls.type];
    }
    case VAR_15:
    case VAR_16:
    case VAR_17:
    case VAR_18:
    case VAR_19:
    {
      return VAR_20;
    }
#if VAR_21
    case VAR_22:
    {
      ecma_proxy_object_t *VAR_23 = (ecma_proxy_object_t *) VAR_0;

      if (!ecma_is_value_null (VAR_23->target) && ecma_is_value_object (VAR_23->target))
      {
        ecma_object_t *VAR_24 = ecma_get_object_from_value (VAR_23->target);
        return ecma_object_get_class_name (VAR_24);
      }
      return VAR_25;
    }
#endif /* COMMENT_3 */
    case VAR_26:
    {
      ecma_extended_object_t *VAR_27 = (ecma_extended_object_t *) VAR_0;

      switch (VAR_27->u.built_in.id)
      {
#if VAR_28
        case VAR_29:
        {
          return VAR_30;
        }
#endif /* COMMENT_4 */
#if VAR_31
        case VAR_32:
        {
          return VAR_33;
        }
#endif /* COMMENT_5 */
#if VAR_34
        case VAR_35:
        {
          return VAR_36;
        }
        case VAR_37:
        {
          return VAR_38;
        }
#endif /* COMMENT_6 */
#if VAR_39
        case VAR_40:
        {
          return VAR_41;
        }
#endif /* COMMENT_7 */
#if VAR_42
        case VAR_43:
        {
          return VAR_44;
        }
#endif /* COMMENT_8 */
#if !VAR_34
#if VAR_45
        case VAR_46:
        case VAR_47:
        case VAR_48:
        case VAR_49:
        case VAR_50:
        case VAR_51:
#endif /* COMMENT_9 */
        case VAR_52:
        {
          return VAR_53;
        }
#endif /* COMMENT_10 */
        default:
        {
          break;
        }
      }

      JERRY_ASSERT (ecma_object_check_class_name_is_object (VAR_0));
      return VAR_25;
    }
    default:
    {
      JERRY_ASSERT (VAR_1 == VAR_54 || VAR_1 == VAR_22);

      return VAR_25;
    }
  }
}",jerryscript-project/jerryscript/b0625e61819e1f5823f16f2463f5def4ab16bdfb/ecma-objects.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -44,6 +44,7 @@
     case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
     case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
     case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
+    case ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION:
     {
       return LIT_MAGIC_STRING_FUNCTION_UL;
     }","{'deleted_lines': [], 'added_lines': ['    case ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION:']}",True,There is an Assertion 'ecma_object_check_class_name_is_object (obj_p)' failed at /jerry-core/ecma/operations/ecma-objects.c in JerryScript 3.0.0.,5.5,MEDIUM,1,test,2022-01-04T15:42:46Z,4
CVE-2021-23514,"['CWE-79', 'CWE-22']",AV:N/AC:L/Au:N/C:P/I:N/A:N,0,CrowCpp/Crow,Fix vulnrabilities in mustache and static,0a160214424d5ca708b8e2eaea061924d8fb0c38,https://github.com/CrowCpp/Crow/commit/0a160214424d5ca708b8e2eaea061924d8fb0c38,include/crow/http_response.h,set_static_file_info,"void set_static_file_info(std::string path)
{
file_info.path = path;
file_info.statResult = stat(file_info.path.c_str(), &file_info.statbuf);
#ifdef CROW_ENABLE_COMPRESSION
compressed = false;
#endif
if (file_info.statResult == 0)
{
std::size_t last_dot = path.find_last_of(""."");
std::string extension = path.substr(last_dot + 1);
std::string mimeType = """";
code = 200;
this->add_header(""Content-length"", std::to_string(file_info.statbuf.st_size));
if (extension != """")
{
mimeType = mime_types.at(extension);
if (mimeType != """")
this->add_header(""Content-Type"", mimeType);
else
this->add_header(""content-Type"", ""text/plain"");
}
}
else
{
code = 404;
this->end();
}
}","void set_static_file_info(std::string VAR_0)
{
VAR_1.path = VAR_0;
VAR_1.statResult = stat(VAR_1.path.c_str(), &VAR_1.statbuf);
#ifdef VAR_2
VAR_3 = false;
#endif
if (VAR_1.statResult == 0)
{
std::size_t VAR_4 = VAR_0.find_last_of(""."");
std::string VAR_5 = VAR_0.substr(VAR_4 + 1);
std::string VAR_6 = """";
VAR_7 = 200;
this->add_header(""Content-length"", std::to_string(VAR_1.statbuf.st_size));
if (VAR_5 != """")
{
VAR_6 = VAR_8.at(VAR_5);
if (VAR_6 != """")
this->add_header(""Content-Type"", VAR_6);
else
this->add_header(""content-Type"", ""text/plain"");
}
}
else
{
VAR_7 = 404;
this->end();
}
}",CrowCpp/Crow/0a160214424d5ca708b8e2eaea061924d8fb0c38/http_response.h/vul/before/0.json,"void set_static_file_info(std::string path)
        {
            path = utility::sanitize_filename(path); //TODO create a no_copy function instead
            file_info.path = path;
            file_info.statResult = stat(file_info.path.c_str(), &file_info.statbuf);
#ifdef CROW_ENABLE_COMPRESSION
            compressed = false;
#endif
            if (file_info.statResult == 0)
            {
                std::size_t last_dot = path.find_last_of(""."");
                std::string extension = path.substr(last_dot + 1);
                std::string mimeType = """";
                code = 200;
                this->add_header(""Content-length"", std::to_string(file_info.statbuf.st_size));

                if (extension != """")
                {
                    mimeType = mime_types.at(extension);
                    if (mimeType != """")
                        this->add_header(""Content-Type"", mimeType);
                    else
                        this->add_header(""content-Type"", ""text/plain"");
                }
            }
            else
            {
                code = 404;
                this->end();
            }
        }","void set_static_file_info(std::string VAR_0)
        {
            VAR_0 = utility::sanitize_filename(VAR_0); /* COMMENT_0 */
            VAR_1.path = VAR_0;
            VAR_1.statResult = stat(VAR_1.path.c_str(), &VAR_1.statbuf);
#ifdef VAR_2
            VAR_3 = false;
#endif
            if (VAR_1.statResult == 0)
            {
                std::size_t VAR_4 = VAR_0.find_last_of(""."");
                std::string VAR_5 = VAR_0.substr(VAR_4 + 1);
                std::string VAR_6 = """";
                VAR_7 = 200;
                this->add_header(""Content-length"", std::to_string(VAR_1.statbuf.st_size));

                if (VAR_5 != """")
                {
                    VAR_6 = VAR_8.at(VAR_5);
                    if (VAR_6 != """")
                        this->add_header(""Content-Type"", VAR_6);
                    else
                        this->add_header(""content-Type"", ""text/plain"");
                }
            }
            else
            {
                VAR_7 = 404;
                this->end();
            }
        }",CrowCpp/Crow/0a160214424d5ca708b8e2eaea061924d8fb0c38/http_response.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,6 @@
 void set_static_file_info(std::string path)
         {
+            path = utility::sanitize_filename(path); //TODO create a no_copy function instead
             file_info.path = path;
             file_info.statResult = stat(file_info.path.c_str(), &file_info.statbuf);
 #ifdef CROW_ENABLE_COMPRESSION","{'deleted_lines': [], 'added_lines': ['            path = utility::sanitize_filename(path); //TODO create a no_copy function instead']}",True,This affects the package Crow before 0.3+4. It is possible to traverse directories to fetch arbitrary files from the server.,6.5,MEDIUM,1,test,2022-01-11T17:27:41Z,4
CVE-2021-23514,"['CWE-79', 'CWE-22']",AV:N/AC:L/Au:N/C:P/I:N/A:N,0,CrowCpp/Crow,Fix vulnrabilities in mustache and static,0a160214424d5ca708b8e2eaea061924d8fb0c38,https://github.com/CrowCpp/Crow/commit/0a160214424d5ca708b8e2eaea061924d8fb0c38,include/crow/mustache.h,escape,"void escape(const std::string& in, std::string& out)
{
out.reserve(out.size() + in.size());
for (auto it = in.begin(); it != in.end(); ++it)
{
switch (*it)
{
case '&': out += ""&amp;""; break;
case '<': out += ""&lt;""; break;
case '>': out += ""&gt;""; break;
case '""': out += ""&quot;""; break;
case '\'': out += ""&#39;""; break;
case '/': out += ""&#x2F;""; break;
default: out += *it; break;
}
}
}","void escape(const std::string& VAR_0, std::string& VAR_1)
{
VAR_1.reserve(VAR_1.size() + VAR_0.size());
for (auto VAR_2 = VAR_0.begin(); VAR_2 != VAR_0.end(); ++VAR_2)
{
switch (*VAR_2)
{
case '&': VAR_1 += ""&amp;""; break;
case '<': VAR_1 += ""&lt;""; break;
case '>': VAR_1 += ""&gt;""; break;
case '""': VAR_1 += ""&quot;""; break;
case '\'': VAR_1 += ""&#39;""; break;
case '/': VAR_1 += ""&#x2F;""; break;
default: VAR_1 += *VAR_2; break;
}
}
}",CrowCpp/Crow/0a160214424d5ca708b8e2eaea061924d8fb0c38/mustache.h/vul/before/0.json,"void escape(const std::string& in, std::string& out)
            {
                out.reserve(out.size() + in.size());
                for (auto it = in.begin(); it != in.end(); ++it)
                {
                    switch (*it)
                    {
                        case '&': out += ""&amp;""; break;
                        case '<': out += ""&lt;""; break;
                        case '>': out += ""&gt;""; break;
                        case '""': out += ""&quot;""; break;
                        case '\'': out += ""&#39;""; break;
                        case '/': out += ""&#x2F;""; break;
                        case '`': out += ""&#x60""; break;
                        case '=': out += ""&#x3D""; break;
                        default: out += *it; break;
                    }
                }
            }","void escape(const std::string& VAR_0, std::string& VAR_1)
            {
                VAR_1.reserve(VAR_1.size() + VAR_0.size());
                for (auto VAR_2 = VAR_0.begin(); VAR_2 != VAR_0.end(); ++VAR_2)
                {
                    switch (*VAR_2)
                    {
                        case '&': VAR_1 += ""&amp;""; break;
                        case '<': VAR_1 += ""&lt;""; break;
                        case '>': VAR_1 += ""&gt;""; break;
                        case '""': VAR_1 += ""&quot;""; break;
                        case '\'': VAR_1 += ""&#39;""; break;
                        case '/': VAR_1 += ""&#x2F;""; break;
                        case '`': VAR_1 += ""&#x60""; break;
                        case '=': VAR_1 += ""&#x3D""; break;
                        default: VAR_1 += *VAR_2; break;
                    }
                }
            }",CrowCpp/Crow/0a160214424d5ca708b8e2eaea061924d8fb0c38/mustache.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,6 +11,8 @@
                         case '""': out += ""&quot;""; break;
                         case '\'': out += ""&#39;""; break;
                         case '/': out += ""&#x2F;""; break;
+                        case '`': out += ""&#x60""; break;
+                        case '=': out += ""&#x3D""; break;
                         default: out += *it; break;
                     }
                 }","{'deleted_lines': [], 'added_lines': ['                        case \'`\': out += ""&#x60""; break;', '                        case \'=\': out += ""&#x3D""; break;']}",True,This affects the package Crow before 0.3+4. It is possible to traverse directories to fetch arbitrary files from the server.,6.5,MEDIUM,1,test,2022-01-11T17:27:41Z,4
CVE-2021-23514,"['CWE-79', 'CWE-22']",AV:N/AC:L/Au:N/C:P/I:N/A:N,0,CrowCpp/Crow,"Fixed another vulnerability in mustache file loading
and made the file sanitizer a copy-less function",e688cbd18ea85a4a61b32be4e8d6b37c66943c4a,https://github.com/CrowCpp/Crow/commit/e688cbd18ea85a4a61b32be4e8d6b37c66943c4a,include/crow/mustache.h,load,"inline template_t load(const std::string& filename)
{
return compile(detail::get_loader_ref()(filename));
}","inline template_t load(const std::string& VAR_0)
{
return compile(detail::get_loader_ref()(VAR_0));
}",CrowCpp/Crow/e688cbd18ea85a4a61b32be4e8d6b37c66943c4a/mustache.h/vul/before/0.json,"inline template_t load(const std::string& filename)
        {
            std::string filename_sanitized(filename);
            utility::sanitize_filename(filename_sanitized);
            return compile(detail::get_loader_ref()(filename_sanitized));
        }","inline template_t load(const std::string& VAR_0)
        {
            std::string filename_sanitized(filename);
            utility::sanitize_filename(VAR_1);
            return compile(detail::get_loader_ref()(VAR_1));
        }",CrowCpp/Crow/e688cbd18ea85a4a61b32be4e8d6b37c66943c4a/mustache.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,6 @@
 inline template_t load(const std::string& filename)
         {
-            return compile(detail::get_loader_ref()(filename));
+            std::string filename_sanitized(filename);
+            utility::sanitize_filename(filename_sanitized);
+            return compile(detail::get_loader_ref()(filename_sanitized));
         }","{'deleted_lines': ['            return compile(detail::get_loader_ref()(filename));'], 'added_lines': ['            std::string filename_sanitized(filename);', '            utility::sanitize_filename(filename_sanitized);', '            return compile(detail::get_loader_ref()(filename_sanitized));']}",True,This affects the package Crow before 0.3+4. It is possible to traverse directories to fetch arbitrary files from the server.,6.5,MEDIUM,1,test,2022-01-11T18:48:51Z,4
CVE-2021-23514,"['CWE-79', 'CWE-22']",AV:N/AC:L/Au:N/C:P/I:N/A:N,0,CrowCpp/Crow,"Fixed another vulnerability in mustache file loading
and made the file sanitizer a copy-less function",e688cbd18ea85a4a61b32be4e8d6b37c66943c4a,https://github.com/CrowCpp/Crow/commit/e688cbd18ea85a4a61b32be4e8d6b37c66943c4a,include/crow/utility.h,sanitize_filename,"inline std::string sanitize_filename(std::string data, char replacement = '_')
{
unsigned char i = 0, length_limit;
length_limit = data.length() < 255 ? data.length() : 255;
data = data.substr(0, length_limit);
for (; i < length_limit; i++)
{
switch (data[i])
{
case '/':
case '?':
case '<':
case '>':
case '\\':
case ':':
case '*':
case '|':
case '\""':
case 0x00:
case 0x01:
case 0x02:
case 0x03:
case 0x04:
case 0x05:
case 0x06:
case 0x07:
case 0x08:
case 0x09:
case 0x0a:
case 0x0b:
case 0x0c:
case 0x0d:
case 0x0e:
case 0x0f:
case 0x10:
case 0x11:
case 0x12:
case 0x13:
case 0x14:
case 0x15:
case 0x16:
case 0x17:
case 0x18:
case 0x19:
case 0x1a:
case 0x1b:
case 0x1c:
case 0x1d:
case 0x1e:
case 0x1f:
case 0x80:
case 0x81:
case 0x82:
case 0x83:
case 0x84:
case 0x85:
case 0x86:
case 0x87:
case 0x88:
case 0x89:
case 0x8a:
case 0x8b:
case 0x8c:
case 0x8d:
case 0x8e:
case 0x8f:
case 0x90:
case 0x91:
case 0x92:
case 0x93:
case 0x94:
case 0x95:
case 0x96:
case 0x97:
case 0x98:
case 0x99:
case 0x9a:
case 0x9b:
case 0x9c:
case 0x9d:
case 0x9e:
case 0x9f:
data[i] = replacement;
break;
default:
break;
}
}
std::string str_replacement(1, replacement);
boost::ireplace_all(data, "".."", str_replacement);
boost::ireplace_all(data, ""CON"", str_replacement);
boost::ireplace_all(data, ""PRN"", str_replacement);
boost::ireplace_all(data, ""AUX"", str_replacement);
boost::ireplace_all(data, ""NUL"", str_replacement);
boost::ireplace_all(data, ""COM1"", str_replacement);
boost::ireplace_all(data, ""COM2"", str_replacement);
boost::ireplace_all(data, ""COM3"", str_replacement);
boost::ireplace_all(data, ""COM4"", str_replacement);
boost::ireplace_all(data, ""COM5"", str_replacement);
boost::ireplace_all(data, ""COM6"", str_replacement);
boost::ireplace_all(data, ""COM7"", str_replacement);
boost::ireplace_all(data, ""COM8"", str_replacement);
boost::ireplace_all(data, ""COM9"", str_replacement);
boost::ireplace_all(data, ""LPT1"", str_replacement);
boost::ireplace_all(data, ""LPT2"", str_replacement);
boost::ireplace_all(data, ""LPT3"", str_replacement);
boost::ireplace_all(data, ""LPT4"", str_replacement);
boost::ireplace_all(data, ""LPT5"", str_replacement);
boost::ireplace_all(data, ""LPT6"", str_replacement);
boost::ireplace_all(data, ""LPT7"", str_replacement);
boost::ireplace_all(data, ""LPT8"", str_replacement);
boost::ireplace_all(data, ""LPT9"", str_replacement);
return data;
}","inline std::string sanitize_filename(std::string VAR_0, char VAR_1 = '_')
{
unsigned char VAR_2 = 0, VAR_3;
VAR_3 = VAR_0.length() < 255 ? VAR_0.length() : 255;
VAR_0 = VAR_0.substr(0, VAR_3);
for (; VAR_2 < VAR_3; VAR_2++)
{
switch (VAR_0[VAR_2])
{
case '/':
case '?':
case '<':
case '>':
case '\\':
case ':':
case '*':
case '|':
case '\""':
case 0x00:
case 0x01:
case 0x02:
case 0x03:
case 0x04:
case 0x05:
case 0x06:
case 0x07:
case 0x08:
case 0x09:
case 0x0a:
case 0x0b:
case 0x0c:
case 0x0d:
case 0x0e:
case 0x0f:
case 0x10:
case 0x11:
case 0x12:
case 0x13:
case 0x14:
case 0x15:
case 0x16:
case 0x17:
case 0x18:
case 0x19:
case 0x1a:
case 0x1b:
case 0x1c:
case 0x1d:
case 0x1e:
case 0x1f:
case 0x80:
case 0x81:
case 0x82:
case 0x83:
case 0x84:
case 0x85:
case 0x86:
case 0x87:
case 0x88:
case 0x89:
case 0x8a:
case 0x8b:
case 0x8c:
case 0x8d:
case 0x8e:
case 0x8f:
case 0x90:
case 0x91:
case 0x92:
case 0x93:
case 0x94:
case 0x95:
case 0x96:
case 0x97:
case 0x98:
case 0x99:
case 0x9a:
case 0x9b:
case 0x9c:
case 0x9d:
case 0x9e:
case 0x9f:
VAR_0[VAR_2] = VAR_1;
break;
default:
break;
}
}
std::string VAR_4(1, VAR_1);
boost::ireplace_all(VAR_0, "".."", VAR_4);
boost::ireplace_all(VAR_0, ""CON"", VAR_4);
boost::ireplace_all(VAR_0, ""PRN"", VAR_4);
boost::ireplace_all(VAR_0, ""AUX"", VAR_4);
boost::ireplace_all(VAR_0, ""NUL"", VAR_4);
boost::ireplace_all(VAR_0, ""COM1"", VAR_4);
boost::ireplace_all(VAR_0, ""COM2"", VAR_4);
boost::ireplace_all(VAR_0, ""COM3"", VAR_4);
boost::ireplace_all(VAR_0, ""COM4"", VAR_4);
boost::ireplace_all(VAR_0, ""COM5"", VAR_4);
boost::ireplace_all(VAR_0, ""COM6"", VAR_4);
boost::ireplace_all(VAR_0, ""COM7"", VAR_4);
boost::ireplace_all(VAR_0, ""COM8"", VAR_4);
boost::ireplace_all(VAR_0, ""COM9"", VAR_4);
boost::ireplace_all(VAR_0, ""LPT1"", VAR_4);
boost::ireplace_all(VAR_0, ""LPT2"", VAR_4);
boost::ireplace_all(VAR_0, ""LPT3"", VAR_4);
boost::ireplace_all(VAR_0, ""LPT4"", VAR_4);
boost::ireplace_all(VAR_0, ""LPT5"", VAR_4);
boost::ireplace_all(VAR_0, ""LPT6"", VAR_4);
boost::ireplace_all(VAR_0, ""LPT7"", VAR_4);
boost::ireplace_all(VAR_0, ""LPT8"", VAR_4);
boost::ireplace_all(VAR_0, ""LPT9"", VAR_4);
return VAR_0;
}",CrowCpp/Crow/e688cbd18ea85a4a61b32be4e8d6b37c66943c4a/utility.h/vul/before/0.json,"inline static void sanitize_filename(std::string& data, char replacement = '_')
        {
            unsigned char i = 0, length_limit;

            length_limit = data.length() < 255 ? data.length() : 255;
            data = data.substr(0, length_limit);

            for (; i < length_limit; i++)
            {
                switch ((unsigned char)data[i])
                {
                    // WARNING While I can't see how using '\' or '/' would cause a problem, it still warrants an investigation
                    //case '/':
                    case '?':
                    case '<':
                    case '>':
                    //case '\\':
                    case ':':
                    case '*':
                    case '|':
                    case '\""':

                    case 0x00:
                    case 0x01:
                    case 0x02:
                    case 0x03:
                    case 0x04:
                    case 0x05:
                    case 0x06:
                    case 0x07:
                    case 0x08:
                    case 0x09:
                    case 0x0a:
                    case 0x0b:
                    case 0x0c:
                    case 0x0d:
                    case 0x0e:
                    case 0x0f:
                    case 0x10:
                    case 0x11:
                    case 0x12:
                    case 0x13:
                    case 0x14:
                    case 0x15:
                    case 0x16:
                    case 0x17:
                    case 0x18:
                    case 0x19:
                    case 0x1a:
                    case 0x1b:
                    case 0x1c:
                    case 0x1d:
                    case 0x1e:
                    case 0x1f:

                    case 0x80:
                    case 0x81:
                    case 0x82:
                    case 0x83:
                    case 0x84:
                    case 0x85:
                    case 0x86:
                    case 0x87:
                    case 0x88:
                    case 0x89:
                    case 0x8a:
                    case 0x8b:
                    case 0x8c:
                    case 0x8d:
                    case 0x8e:
                    case 0x8f:
                    case 0x90:
                    case 0x91:
                    case 0x92:
                    case 0x93:
                    case 0x94:
                    case 0x95:
                    case 0x96:
                    case 0x97:
                    case 0x98:
                    case 0x99:
                    case 0x9a:
                    case 0x9b:
                    case 0x9c:
                    case 0x9d:
                    case 0x9e:
                    case 0x9f:

                        data[i] = replacement;
                        break;

                    default:
                        break;
                }
            }
            std::string str_replacement(1, replacement);

            boost::ireplace_all(data, "".."", str_replacement);

            boost::ireplace_all(data, ""CON"", str_replacement);
            boost::ireplace_all(data, ""PRN"", str_replacement);
            boost::ireplace_all(data, ""AUX"", str_replacement);
            boost::ireplace_all(data, ""NUL"", str_replacement);
            boost::ireplace_all(data, ""COM1"", str_replacement);
            boost::ireplace_all(data, ""COM2"", str_replacement);
            boost::ireplace_all(data, ""COM3"", str_replacement);
            boost::ireplace_all(data, ""COM4"", str_replacement);
            boost::ireplace_all(data, ""COM5"", str_replacement);
            boost::ireplace_all(data, ""COM6"", str_replacement);
            boost::ireplace_all(data, ""COM7"", str_replacement);
            boost::ireplace_all(data, ""COM8"", str_replacement);
            boost::ireplace_all(data, ""COM9"", str_replacement);
            boost::ireplace_all(data, ""LPT1"", str_replacement);
            boost::ireplace_all(data, ""LPT2"", str_replacement);
            boost::ireplace_all(data, ""LPT3"", str_replacement);
            boost::ireplace_all(data, ""LPT4"", str_replacement);
            boost::ireplace_all(data, ""LPT5"", str_replacement);
            boost::ireplace_all(data, ""LPT6"", str_replacement);
            boost::ireplace_all(data, ""LPT7"", str_replacement);
            boost::ireplace_all(data, ""LPT8"", str_replacement);
            boost::ireplace_all(data, ""LPT9"", str_replacement);
        }","inline static void sanitize_filename(std::string& VAR_0, char VAR_1 = '_')
        {
            unsigned char VAR_2 = 0, VAR_3;

            VAR_3 = VAR_0.length() < 255 ? VAR_0.length() : 255;
            VAR_0 = VAR_0.substr(0, VAR_3);

            for (; VAR_2 < VAR_3; VAR_2++)
            {
                switch ((unsigned char)VAR_0[VAR_2])
                {
                    /* COMMENT_0 */
                    /* COMMENT_1 */
                    case '?':
                    case '<':
                    case '>':
                    /* COMMENT_2 */
                    case ':':
                    case '*':
                    case '|':
                    case '\""':

                    case 0x00:
                    case 0x01:
                    case 0x02:
                    case 0x03:
                    case 0x04:
                    case 0x05:
                    case 0x06:
                    case 0x07:
                    case 0x08:
                    case 0x09:
                    case 0x0a:
                    case 0x0b:
                    case 0x0c:
                    case 0x0d:
                    case 0x0e:
                    case 0x0f:
                    case 0x10:
                    case 0x11:
                    case 0x12:
                    case 0x13:
                    case 0x14:
                    case 0x15:
                    case 0x16:
                    case 0x17:
                    case 0x18:
                    case 0x19:
                    case 0x1a:
                    case 0x1b:
                    case 0x1c:
                    case 0x1d:
                    case 0x1e:
                    case 0x1f:

                    case 0x80:
                    case 0x81:
                    case 0x82:
                    case 0x83:
                    case 0x84:
                    case 0x85:
                    case 0x86:
                    case 0x87:
                    case 0x88:
                    case 0x89:
                    case 0x8a:
                    case 0x8b:
                    case 0x8c:
                    case 0x8d:
                    case 0x8e:
                    case 0x8f:
                    case 0x90:
                    case 0x91:
                    case 0x92:
                    case 0x93:
                    case 0x94:
                    case 0x95:
                    case 0x96:
                    case 0x97:
                    case 0x98:
                    case 0x99:
                    case 0x9a:
                    case 0x9b:
                    case 0x9c:
                    case 0x9d:
                    case 0x9e:
                    case 0x9f:

                        VAR_0[VAR_2] = VAR_1;
                        break;

                    default:
                        break;
                }
            }
            std::string VAR_4(1, VAR_1);

            boost::ireplace_all(VAR_0, "".."", VAR_4);

            boost::ireplace_all(VAR_0, ""CON"", VAR_4);
            boost::ireplace_all(VAR_0, ""PRN"", VAR_4);
            boost::ireplace_all(VAR_0, ""AUX"", VAR_4);
            boost::ireplace_all(VAR_0, ""NUL"", VAR_4);
            boost::ireplace_all(VAR_0, ""COM1"", VAR_4);
            boost::ireplace_all(VAR_0, ""COM2"", VAR_4);
            boost::ireplace_all(VAR_0, ""COM3"", VAR_4);
            boost::ireplace_all(VAR_0, ""COM4"", VAR_4);
            boost::ireplace_all(VAR_0, ""COM5"", VAR_4);
            boost::ireplace_all(VAR_0, ""COM6"", VAR_4);
            boost::ireplace_all(VAR_0, ""COM7"", VAR_4);
            boost::ireplace_all(VAR_0, ""COM8"", VAR_4);
            boost::ireplace_all(VAR_0, ""COM9"", VAR_4);
            boost::ireplace_all(VAR_0, ""LPT1"", VAR_4);
            boost::ireplace_all(VAR_0, ""LPT2"", VAR_4);
            boost::ireplace_all(VAR_0, ""LPT3"", VAR_4);
            boost::ireplace_all(VAR_0, ""LPT4"", VAR_4);
            boost::ireplace_all(VAR_0, ""LPT5"", VAR_4);
            boost::ireplace_all(VAR_0, ""LPT6"", VAR_4);
            boost::ireplace_all(VAR_0, ""LPT7"", VAR_4);
            boost::ireplace_all(VAR_0, ""LPT8"", VAR_4);
            boost::ireplace_all(VAR_0, ""LPT9"", VAR_4);
        }",CrowCpp/Crow/e688cbd18ea85a4a61b32be4e8d6b37c66943c4a/utility.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-inline std::string sanitize_filename(std::string data, char replacement = '_')
+inline static void sanitize_filename(std::string& data, char replacement = '_')
         {
             unsigned char i = 0, length_limit;
 
@@ -7,13 +7,14 @@
 
             for (; i < length_limit; i++)
             {
-                switch (data[i])
+                switch ((unsigned char)data[i])
                 {
-                    case '/':
+                    // WARNING While I can't see how using '\' or '/' would cause a problem, it still warrants an investigation
+                    //case '/':
                     case '?':
                     case '<':
                     case '>':
-                    case '\\':
+                    //case '\\':
                     case ':':
                     case '*':
                     case '|':
@@ -118,6 +119,4 @@
             boost::ireplace_all(data, ""LPT7"", str_replacement);
             boost::ireplace_all(data, ""LPT8"", str_replacement);
             boost::ireplace_all(data, ""LPT9"", str_replacement);
-
-            return data;
         }","{'deleted_lines': [""inline std::string sanitize_filename(std::string data, char replacement = '_')"", '                switch (data[i])', ""                    case '/':"", ""                    case '\\\\':"", '', '            return data;'], 'added_lines': [""inline static void sanitize_filename(std::string& data, char replacement = '_')"", '                switch ((unsigned char)data[i])', ""                    // WARNING While I can't see how using '\\' or '/' would cause a problem, it still warrants an investigation"", ""                    //case '/':"", ""                    //case '\\\\':""]}",True,This affects the package Crow before 0.3+4. It is possible to traverse directories to fetch arbitrary files from the server.,6.5,MEDIUM,1,test,2022-01-11T18:48:51Z,4
CVE-2021-23514,"['CWE-79', 'CWE-22']",AV:N/AC:L/Au:N/C:P/I:N/A:N,0,CrowCpp/Crow,"Fixed another vulnerability in mustache file loading
and made the file sanitizer a copy-less function",e688cbd18ea85a4a61b32be4e8d6b37c66943c4a,https://github.com/CrowCpp/Crow/commit/e688cbd18ea85a4a61b32be4e8d6b37c66943c4a,include/crow/http_response.h,set_static_file_info,"void set_static_file_info(std::string path)
{
path = utility::sanitize_filename(path);             file_info.path = path;
file_info.statResult = stat(file_info.path.c_str(), &file_info.statbuf);
#ifdef CROW_ENABLE_COMPRESSION
compressed = false;
#endif
if (file_info.statResult == 0)
{
std::size_t last_dot = path.find_last_of(""."");
std::string extension = path.substr(last_dot + 1);
std::string mimeType = """";
code = 200;
this->add_header(""Content-length"", std::to_string(file_info.statbuf.st_size));
if (extension != """")
{
mimeType = mime_types.at(extension);
if (mimeType != """")
this->add_header(""Content-Type"", mimeType);
else
this->add_header(""content-Type"", ""text/plain"");
}
}
else
{
code = 404;
this->end();
}
}","void set_static_file_info(std::string VAR_0)
{
VAR_0 = utility::sanitize_filename(VAR_0); 
VAR_1.path = VAR_0;
VAR_1.statResult = stat(VAR_1.path.c_str(), &VAR_1.statbuf);
#ifdef VAR_2
VAR_3 = false;
#endif
if (VAR_1.statResult == 0)
{
std::size_t VAR_4 = VAR_0.find_last_of(""."");
std::string VAR_5 = VAR_0.substr(VAR_4 + 1);
std::string VAR_6 = """";
VAR_7 = 200;
this->add_header(""Content-length"", std::to_string(VAR_1.statbuf.st_size));
if (VAR_5 != """")
{
VAR_6 = VAR_8.at(VAR_5);
if (VAR_6 != """")
this->add_header(""Content-Type"", VAR_6);
else
this->add_header(""content-Type"", ""text/plain"");
}
}
else
{
VAR_7 = 404;
this->end();
}
}",CrowCpp/Crow/e688cbd18ea85a4a61b32be4e8d6b37c66943c4a/http_response.h/vul/before/0.json,"void set_static_file_info(std::string path)
        {
            utility::sanitize_filename(path);
            file_info.path = path;
            file_info.statResult = stat(file_info.path.c_str(), &file_info.statbuf);
#ifdef CROW_ENABLE_COMPRESSION
            compressed = false;
#endif
            if (file_info.statResult == 0)
            {
                std::size_t last_dot = path.find_last_of(""."");
                std::string extension = path.substr(last_dot + 1);
                std::string mimeType = """";
                code = 200;
                this->add_header(""Content-length"", std::to_string(file_info.statbuf.st_size));

                if (extension != """")
                {
                    mimeType = mime_types.at(extension);
                    if (mimeType != """")
                        this->add_header(""Content-Type"", mimeType);
                    else
                        this->add_header(""content-Type"", ""text/plain"");
                }
            }
            else
            {
                code = 404;
                this->end();
            }
        }","void set_static_file_info(std::string VAR_0)
        {
            utility::sanitize_filename(VAR_0);
            VAR_1.path = VAR_0;
            VAR_1.statResult = stat(VAR_1.path.c_str(), &VAR_1.statbuf);
#ifdef VAR_2
            VAR_3 = false;
#endif
            if (VAR_1.statResult == 0)
            {
                std::size_t VAR_4 = VAR_0.find_last_of(""."");
                std::string VAR_5 = VAR_0.substr(VAR_4 + 1);
                std::string VAR_6 = """";
                VAR_7 = 200;
                this->add_header(""Content-length"", std::to_string(VAR_1.statbuf.st_size));

                if (VAR_5 != """")
                {
                    VAR_6 = VAR_8.at(VAR_5);
                    if (VAR_6 != """")
                        this->add_header(""Content-Type"", VAR_6);
                    else
                        this->add_header(""content-Type"", ""text/plain"");
                }
            }
            else
            {
                VAR_7 = 404;
                this->end();
            }
        }",CrowCpp/Crow/e688cbd18ea85a4a61b32be4e8d6b37c66943c4a/http_response.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 void set_static_file_info(std::string path)
         {
-            path = utility::sanitize_filename(path); //TODO create a no_copy function instead
+            utility::sanitize_filename(path);
             file_info.path = path;
             file_info.statResult = stat(file_info.path.c_str(), &file_info.statbuf);
 #ifdef CROW_ENABLE_COMPRESSION","{'deleted_lines': ['            path = utility::sanitize_filename(path); //TODO create a no_copy function instead'], 'added_lines': ['            utility::sanitize_filename(path);']}",True,This affects the package Crow before 0.3+4. It is possible to traverse directories to fetch arbitrary files from the server.,6.5,MEDIUM,1,test,2022-01-11T18:48:51Z,4
CVE-2021-43518,['CWE-120'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,teeworlds,hotfix CVE-2021-43518,91e5492d4c210f82f1ca6b43a73417fef5463368,https://github.com/teeworlds/teeworlds/commit/91e5492d4c210f82f1ca6b43a73417fef5463368,src/game/client/components/maplayers.cpp,CMapLayers::LoadEnvPoints,"void CMapLayers::LoadEnvPoints(const CLayers *pLayers, array<CEnvPoint>& lEnvPoints)
{
lEnvPoints.clear();
CEnvPoint *pPoints = 0x0;
{
int Start, Num;
pLayers->Map()->GetType(MAPITEMTYPE_ENVPOINTS, &Start, &Num);
if(!Num)
return;
pPoints = (CEnvPoint *)pLayers->Map()->GetItem(Start, 0, 0);
}
int Start, Num;
pLayers->Map()->GetType(MAPITEMTYPE_ENVELOPE, &Start, &Num);
if(!Num)
return;
for(int env = 0; env < Num; env++)
{
CMapItemEnvelope *pItem = (CMapItemEnvelope *)pLayers->Map()->GetItem(Start+env, 0, 0);
if(pItem->m_Version >= 3)
{
for(int i = 0; i < pItem->m_NumPoints; i++)
lEnvPoints.add(pPoints[i + pItem->m_StartPoint]);
}
else
{
for(int i = 0; i < pItem->m_NumPoints; i++)
{
CEnvPoint_v1 *pEnvPoint_v1 = &((CEnvPoint_v1 *)pPoints)[i + pItem->m_StartPoint];
CEnvPoint p;
p.m_Time = pEnvPoint_v1->m_Time;
p.m_Curvetype = pEnvPoint_v1->m_Curvetype;
for(int c = 0; c < pItem->m_Channels; c++)
{
p.m_aValues[c] = pEnvPoint_v1->m_aValues[c];
p.m_aInTangentdx[c] = 0;
p.m_aInTangentdy[c] = 0;
p.m_aOutTangentdx[c] = 0;
p.m_aOutTangentdy[c] = 0;
}
lEnvPoints.add(p);
}
}
}
}","void CMapLayers::LoadEnvPoints(const CLayers *VAR_0, array<CEnvPoint>& VAR_1)
{
VAR_1.clear();
CEnvPoint *VAR_2 = 0x0;
{
int VAR_3, VAR_4;
VAR_0->Map()->GetType(VAR_5, &VAR_3, &VAR_4);
if(!VAR_4)
return;
VAR_2 = (CEnvPoint *)VAR_0->Map()->GetItem(VAR_3, 0, 0);
}
int VAR_3, VAR_4;
VAR_0->Map()->GetType(VAR_6, &VAR_3, &VAR_4);
if(!VAR_4)
return;
for(int VAR_7 = 0; VAR_7 < VAR_4; VAR_7++)
{
CMapItemEnvelope *VAR_8 = (CMapItemEnvelope *)VAR_0->Map()->GetItem(VAR_3+VAR_7, 0, 0);
if(VAR_8->m_Version >= 3)
{
for(int VAR_9 = 0; VAR_9 < VAR_8->m_NumPoints; VAR_9++)
VAR_1.add(VAR_2[VAR_9 + VAR_8->m_StartPoint]);
}
else
{
for(int VAR_9 = 0; VAR_9 < VAR_8->m_NumPoints; VAR_9++)
{
CEnvPoint_v1 *VAR_10 = &((CEnvPoint_v1 *)VAR_2)[VAR_9 + VAR_8->m_StartPoint];
CEnvPoint VAR_11;
VAR_11.m_Time = VAR_10->m_Time;
VAR_11.m_Curvetype = VAR_10->m_Curvetype;
for(int VAR_12 = 0; VAR_12 < VAR_8->m_Channels; VAR_12++)
{
VAR_11.m_aValues[VAR_12] = VAR_10->m_aValues[VAR_12];
VAR_11.m_aInTangentdx[VAR_12] = 0;
VAR_11.m_aInTangentdy[VAR_12] = 0;
VAR_11.m_aOutTangentdx[VAR_12] = 0;
VAR_11.m_aOutTangentdy[VAR_12] = 0;
}
VAR_1.add(VAR_11);
}
}
}
}",teeworlds/91e5492d4c210f82f1ca6b43a73417fef5463368/maplayers.cpp/vul/before/0.json,"void CMapLayers::LoadEnvPoints(const CLayers *pLayers, array<CEnvPoint>& lEnvPoints)
{
	lEnvPoints.clear();

	// get envelope points
	CEnvPoint *pPoints = 0x0;
	{
		int Start, Num;
		pLayers->Map()->GetType(MAPITEMTYPE_ENVPOINTS, &Start, &Num);

		if(!Num)
			return;

		pPoints = (CEnvPoint *)pLayers->Map()->GetItem(Start, 0, 0);
	}

	// get envelopes
	int Start, Num;
	pLayers->Map()->GetType(MAPITEMTYPE_ENVELOPE, &Start, &Num);
	if(!Num)
		return;


	for(int env = 0; env < Num; env++)
	{
		CMapItemEnvelope *pItem = (CMapItemEnvelope *)pLayers->Map()->GetItem(Start+env, 0, 0);

		if(pItem->m_Version >= 3)
		{
			for(int i = 0; i < pItem->m_NumPoints; i++)
				lEnvPoints.add(pPoints[i + pItem->m_StartPoint]);
		}
		else
		{
			// backwards compatibility
			for(int i = 0; i < pItem->m_NumPoints; i++)
			{
				// convert CEnvPoint_v1 -> CEnvPoint
				CEnvPoint_v1 *pEnvPoint_v1 = &((CEnvPoint_v1 *)pPoints)[i + pItem->m_StartPoint];
				CEnvPoint p;

				p.m_Time = pEnvPoint_v1->m_Time;
				p.m_Curvetype = pEnvPoint_v1->m_Curvetype;

				for(int c = 0; c < minimum(pItem->m_Channels, 4); c++)
				{
					p.m_aValues[c] = pEnvPoint_v1->m_aValues[c];
					p.m_aInTangentdx[c] = 0;
					p.m_aInTangentdy[c] = 0;
					p.m_aOutTangentdx[c] = 0;
					p.m_aOutTangentdy[c] = 0;
				}

				lEnvPoints.add(p);
			}
		}
	}
}","void CMapLayers::LoadEnvPoints(const CLayers *VAR_0, array<CEnvPoint>& VAR_1)
{
	VAR_1.clear();

	/* COMMENT_0 */
	CEnvPoint *VAR_2 = 0x0;
	{
		int VAR_3, VAR_4;
		VAR_0->Map()->GetType(VAR_5, &VAR_3, &VAR_4);

		if(!VAR_4)
			return;

		VAR_2 = (CEnvPoint *)VAR_0->Map()->GetItem(VAR_3, 0, 0);
	}

	/* COMMENT_1 */
	int VAR_3, VAR_4;
	VAR_0->Map()->GetType(VAR_6, &VAR_3, &VAR_4);
	if(!VAR_4)
		return;


	for(int VAR_7 = 0; VAR_7 < VAR_4; VAR_7++)
	{
		CMapItemEnvelope *VAR_8 = (CMapItemEnvelope *)VAR_0->Map()->GetItem(VAR_3+VAR_7, 0, 0);

		if(VAR_8->m_Version >= 3)
		{
			for(int VAR_9 = 0; VAR_9 < VAR_8->m_NumPoints; VAR_9++)
				VAR_1.add(VAR_2[VAR_9 + VAR_8->m_StartPoint]);
		}
		else
		{
			/* COMMENT_2 */
			for(int VAR_9 = 0; VAR_9 < VAR_8->m_NumPoints; VAR_9++)
			{
				/* COMMENT_3 */
				CEnvPoint_v1 *VAR_10 = &((CEnvPoint_v1 *)VAR_2)[VAR_9 + VAR_8->m_StartPoint];
				CEnvPoint VAR_11;

				VAR_11.m_Time = VAR_10->m_Time;
				VAR_11.m_Curvetype = VAR_10->m_Curvetype;

				for(int VAR_12 = 0; VAR_12 < minimum(VAR_8->m_Channels, 4); VAR_12++)
				{
					VAR_11.m_aValues[VAR_12] = VAR_10->m_aValues[VAR_12];
					VAR_11.m_aInTangentdx[VAR_12] = 0;
					VAR_11.m_aInTangentdy[VAR_12] = 0;
					VAR_11.m_aOutTangentdx[VAR_12] = 0;
					VAR_11.m_aOutTangentdy[VAR_12] = 0;
				}

				VAR_1.add(VAR_11);
			}
		}
	}
}",teeworlds/91e5492d4c210f82f1ca6b43a73417fef5463368/maplayers.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -42,7 +42,7 @@
 				p.m_Time = pEnvPoint_v1->m_Time;
 				p.m_Curvetype = pEnvPoint_v1->m_Curvetype;
 
-				for(int c = 0; c < pItem->m_Channels; c++)
+				for(int c = 0; c < minimum(pItem->m_Channels, 4); c++)
 				{
 					p.m_aValues[c] = pEnvPoint_v1->m_aValues[c];
 					p.m_aInTangentdx[c] = 0;","{'deleted_lines': ['\t\t\t\tfor(int c = 0; c < pItem->m_Channels; c++)'], 'added_lines': ['\t\t\t\tfor(int c = 0; c < minimum(pItem->m_Channels, 4); c++)']}",True,"Teeworlds up to and including 0.7.5 is vulnerable to Buffer Overflow. A map parser does not validate m_Channels value coming from a map file, leading to a buffer overflow. A malicious server may offer a specially crafted map that will overwrite client's stack causing denial of service or code execution.",7.8,HIGH,2,test,2022-01-15T16:36:39Z,4
CVE-2021-43518,['CWE-120'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,teeworlds,hotfix CVE-2021-43518,91e5492d4c210f82f1ca6b43a73417fef5463368,https://github.com/teeworlds/teeworlds/commit/91e5492d4c210f82f1ca6b43a73417fef5463368,src/game/editor/io.cpp,CEditorMap::Load,"int CEditorMap::Load(class IStorage *pStorage, const char *pFileName, int StorageType)
{
CDataFileReader DataFile;
if(!DataFile.Open(pStorage, pFileName, StorageType))
return 0;
Clean();
CMapItemVersion *pItem = (CMapItemVersion *)DataFile.FindItem(MAPITEMTYPE_VERSION, 0);
if(!pItem)
{
return 0;
}
else if(pItem->m_Version == CMapItemVersion::CURRENT_VERSION)
{
{
CMapItemInfo *pItem = (CMapItemInfo *)DataFile.FindItem(MAPITEMTYPE_INFO, 0);
if(pItem && pItem->m_Version == 1)
{
if(pItem->m_Author > -1)
str_copy(m_MapInfo.m_aAuthor, (char *)DataFile.GetData(pItem->m_Author), sizeof(m_MapInfo.m_aAuthor));
if(pItem->m_MapVersion > -1)
str_copy(m_MapInfo.m_aVersion, (char *)DataFile.GetData(pItem->m_MapVersion), sizeof(m_MapInfo.m_aVersion));
if(pItem->m_Credits > -1)
str_copy(m_MapInfo.m_aCredits, (char *)DataFile.GetData(pItem->m_Credits), sizeof(m_MapInfo.m_aCredits));
if(pItem->m_License > -1)
str_copy(m_MapInfo.m_aLicense, (char *)DataFile.GetData(pItem->m_License), sizeof(m_MapInfo.m_aLicense));
}
}
{
int Start, Num;
DataFile.GetType( MAPITEMTYPE_IMAGE, &Start, &Num);
for(int i = 0; i < Num; i++)
{
CMapItemImage *pItem = (CMapItemImage *)DataFile.GetItem(Start+i, 0, 0);
char *pName = (char *)DataFile.GetData(pItem->m_ImageName);
CEditorImage *pImg = new CEditorImage(m_pEditor);
pImg->m_External = pItem->m_External;
if(pItem->m_External || (pItem->m_Version > 1 && pItem->m_Format != CImageInfo::FORMAT_RGB && pItem->m_Format != CImageInfo::FORMAT_RGBA))
{
char aBuf[IO_MAX_PATH_LENGTH];
str_format(aBuf, sizeof(aBuf),""mapres/%s.png"", pName);
CEditorImage ImgInfo(m_pEditor);
if(m_pEditor->Graphics()->LoadPNG(&ImgInfo, aBuf, IStorage::TYPE_ALL))
{
*pImg = ImgInfo;
pImg->m_Texture = m_pEditor->Graphics()->LoadTextureRaw(ImgInfo.m_Width, ImgInfo.m_Height, ImgInfo.m_Format, ImgInfo.m_pData, CImageInfo::FORMAT_AUTO, IGraphics::TEXLOAD_MULTI_DIMENSION);
ImgInfo.m_pData = 0;
pImg->m_External = 1;
}
}
else
{
pImg->m_Width = pItem->m_Width;
pImg->m_Height = pItem->m_Height;
pImg->m_Format = pItem->m_Version == 1 ? CImageInfo::FORMAT_RGBA : pItem->m_Format;
int PixelSize = pImg->m_Format == CImageInfo::FORMAT_RGB ? 3 : 4;
int DataSize = pImg->m_Width * pImg->m_Height * PixelSize;
void *pData = DataFile.GetData(pItem->m_ImageData);
pImg->m_pData = mem_alloc(DataSize);
mem_copy(pImg->m_pData, pData, DataSize);
pImg->m_Texture = m_pEditor->Graphics()->LoadTextureRaw(pImg->m_Width, pImg->m_Height, pImg->m_Format, pImg->m_pData, CImageInfo::FORMAT_AUTO, IGraphics::TEXLOAD_MULTI_DIMENSION);
}
if(pName)
str_copy(pImg->m_aName, pName, 128);
pImg->LoadAutoMapper();
m_lImages.add(pImg);
DataFile.UnloadData(pItem->m_ImageData);
DataFile.UnloadData(pItem->m_ImageName);
}
}
{
int LayersStart, LayersNum;
DataFile.GetType(MAPITEMTYPE_LAYER, &LayersStart, &LayersNum);
int Start, Num;
DataFile.GetType(MAPITEMTYPE_GROUP, &Start, &Num);
for(int g = 0; g < Num; g++)
{
CMapItemGroup *pGItem = (CMapItemGroup *)DataFile.GetItem(Start+g, 0, 0);
if(pGItem->m_Version < 1 || pGItem->m_Version > CMapItemGroup::CURRENT_VERSION)
continue;
CLayerGroup *pGroup = NewGroup();
pGroup->m_ParallaxX = pGItem->m_ParallaxX;
pGroup->m_ParallaxY = pGItem->m_ParallaxY;
pGroup->m_OffsetX = pGItem->m_OffsetX;
pGroup->m_OffsetY = pGItem->m_OffsetY;
if(pGItem->m_Version >= 2)
{
pGroup->m_UseClipping = pGItem->m_UseClipping;
pGroup->m_ClipX = pGItem->m_ClipX;
pGroup->m_ClipY = pGItem->m_ClipY;
pGroup->m_ClipW = pGItem->m_ClipW;
pGroup->m_ClipH = pGItem->m_ClipH;
}
if(pGItem->m_Version >= 3)
IntsToStr(pGItem->m_aName, sizeof(pGroup->m_aName)/sizeof(int), pGroup->m_aName);
for(int l = 0; l < pGItem->m_NumLayers; l++)
{
CLayer *pLayer = 0;
CMapItemLayer *pLayerItem = (CMapItemLayer *)DataFile.GetItem(LayersStart+pGItem->m_StartLayer+l, 0, 0);
if(!pLayerItem)
continue;
if(pLayerItem->m_Type == LAYERTYPE_TILES)
{
CMapItemLayerTilemap *pTilemapItem = (CMapItemLayerTilemap *)pLayerItem;
CLayerTiles *pTiles = 0;
if(pTilemapItem->m_Flags&TILESLAYERFLAG_GAME)
{
pTiles = new CLayerGame(pTilemapItem->m_Width, pTilemapItem->m_Height);
MakeGameLayer(pTiles);
MakeGameGroup(pGroup);
}
else
{
pTiles = new CLayerTiles(pTilemapItem->m_Width, pTilemapItem->m_Height);
pTiles->m_pEditor = m_pEditor;
pTiles->m_Color = pTilemapItem->m_Color;
pTiles->m_ColorEnv = pTilemapItem->m_ColorEnv;
pTiles->m_ColorEnvOffset = pTilemapItem->m_ColorEnvOffset;
}
pLayer = pTiles;
pGroup->AddLayer(pTiles);
void *pData = DataFile.GetData(pTilemapItem->m_Data);
pTiles->m_Image = pTilemapItem->m_Image;
pTiles->m_Game = pTilemapItem->m_Flags&TILESLAYERFLAG_GAME;
if(pTilemapItem->m_Version >= 3)
IntsToStr(pTilemapItem->m_aName, sizeof(pTiles->m_aName)/sizeof(int), pTiles->m_aName);
if(pTilemapItem->m_Version > 3)
pTiles->ExtractTiles((CTile *)pData);
else
mem_copy(pTiles->m_pTiles, pData, pTiles->m_Width*pTiles->m_Height*sizeof(CTile));
if(pTiles->m_Game && pTilemapItem->m_Version == MakeVersion(1, *pTilemapItem))
{
for(int i = 0; i < pTiles->m_Width*pTiles->m_Height; i++)
{
if(pTiles->m_pTiles[i].m_Index)
pTiles->m_pTiles[i].m_Index += ENTITY_OFFSET;
}
}
DataFile.UnloadData(pTilemapItem->m_Data);
}
else if(pLayerItem->m_Type == LAYERTYPE_QUADS)
{
CMapItemLayerQuads *pQuadsItem = (CMapItemLayerQuads *)pLayerItem;
CLayerQuads *pQuads = new CLayerQuads;
pQuads->m_pEditor = m_pEditor;
pLayer = pQuads;
pQuads->m_Image = pQuadsItem->m_Image;
if(pQuads->m_Image < -1 || pQuads->m_Image >= m_lImages.size())
pQuads->m_Image = -1;
if(pQuadsItem->m_Version >= 2)
IntsToStr(pQuadsItem->m_aName, sizeof(pQuads->m_aName)/sizeof(int), pQuads->m_aName);
void *pData = DataFile.GetDataSwapped(pQuadsItem->m_Data);
pGroup->AddLayer(pQuads);
pQuads->m_lQuads.set_size(pQuadsItem->m_NumQuads);
mem_copy(pQuads->m_lQuads.base_ptr(), pData, sizeof(CQuad)*pQuadsItem->m_NumQuads);
DataFile.UnloadData(pQuadsItem->m_Data);
}
if(pLayer)
pLayer->m_Flags = pLayerItem->m_Flags;
}
}
}
{
CEnvPoint *pEnvPoints = 0;
{
int Start, Num;
DataFile.GetType(MAPITEMTYPE_ENVPOINTS, &Start, &Num);
if(Num)
pEnvPoints = (CEnvPoint *)DataFile.GetItem(Start, 0, 0);
}
int Start, Num;
DataFile.GetType(MAPITEMTYPE_ENVELOPE, &Start, &Num);
for(int e = 0; e < Num; e++)
{
CMapItemEnvelope *pItem = (CMapItemEnvelope *)DataFile.GetItem(Start+e, 0, 0);
CEnvelope *pEnv = new CEnvelope(pItem->m_Channels);
pEnv->m_lPoints.set_size(pItem->m_NumPoints);
for(int n = 0; n < pItem->m_NumPoints; n++)
{
if(pItem->m_Version >= 3)
{
pEnv->m_lPoints[n] = pEnvPoints[pItem->m_StartPoint + n];
}
else
{
CEnvPoint_v1 *pEnvPoint_v1 = &((CEnvPoint_v1 *)pEnvPoints)[pItem->m_StartPoint + n];
mem_zero((void*)&pEnv->m_lPoints[n], sizeof(CEnvPoint));
pEnv->m_lPoints[n].m_Time = pEnvPoint_v1->m_Time;
pEnv->m_lPoints[n].m_Curvetype = pEnvPoint_v1->m_Curvetype;
for(int c = 0; c < pItem->m_Channels; c++)
{
pEnv->m_lPoints[n].m_aValues[c] = pEnvPoint_v1->m_aValues[c];
}
}
}
if(pItem->m_aName[0] != -1)IntsToStr(pItem->m_aName, sizeof(pItem->m_aName)/sizeof(int), pEnv->m_aName);
m_lEnvelopes.add(pEnv);
if(pItem->m_Version >= 2)
pEnv->m_Synchronized = pItem->m_Synchronized;
}
}
}
else
return 0;
return 1;
}","int CEditorMap::Load(class IStorage *VAR_0, const char *VAR_1, int VAR_2)
{
CDataFileReader VAR_3;
if(!VAR_3.Open(VAR_0, VAR_1, VAR_2))
return 0;
Clean();
CMapItemVersion *VAR_4 = (CMapItemVersion *)VAR_3.FindItem(VAR_5, 0);
if(!VAR_4)
{
return 0;
}
else if(VAR_4->m_Version == CMapItemVersion::CURRENT_VERSION)
{
{
CMapItemInfo *VAR_4 = (CMapItemInfo *)VAR_3.FindItem(VAR_6, 0);
if(VAR_4 && VAR_4->m_Version == 1)
{
if(VAR_4->m_Author > -1)
str_copy(VAR_7.m_aAuthor, (char *)VAR_3.GetData(VAR_4->m_Author), sizeof(VAR_7.m_aAuthor));
if(VAR_4->m_MapVersion > -1)
str_copy(VAR_7.m_aVersion, (char *)VAR_3.GetData(VAR_4->m_MapVersion), sizeof(VAR_7.m_aVersion));
if(VAR_4->m_Credits > -1)
str_copy(VAR_7.m_aCredits, (char *)VAR_3.GetData(VAR_4->m_Credits), sizeof(VAR_7.m_aCredits));
if(VAR_4->m_License > -1)
str_copy(VAR_7.m_aLicense, (char *)VAR_3.GetData(VAR_4->m_License), sizeof(VAR_7.m_aLicense));
}
}
{
int VAR_8, VAR_9;
VAR_3.GetType( VAR_10, &VAR_8, &VAR_9);
for(int VAR_11 = 0; VAR_11 < VAR_9; VAR_11++)
{
CMapItemImage *VAR_4 = (CMapItemImage *)VAR_3.GetItem(VAR_8+VAR_11, 0, 0);
char *VAR_12 = (char *)VAR_3.GetData(VAR_4->m_ImageName);
CEditorImage *VAR_13 = new CEditorImage(VAR_14);
VAR_13->m_External = VAR_4->m_External;
if(VAR_4->m_External || (VAR_4->m_Version > 1 && VAR_4->m_Format != CImageInfo::FORMAT_RGB && VAR_4->m_Format != CImageInfo::FORMAT_RGBA))
{
char VAR_15[VAR_16];
str_format(VAR_15, sizeof(VAR_15),""mapres/%s.png"", VAR_12);
CEditorImage ImgInfo(m_pEditor);
if(m_pEditor->Graphics()->LoadPNG(&VAR_17, VAR_15, IStorage::TYPE_ALL))
{
*VAR_13 = VAR_17;
VAR_13->m_Texture = m_pEditor->Graphics()->LoadTextureRaw(VAR_17.m_Width, VAR_17.m_Height, VAR_17.m_Format, VAR_17.m_pData, CImageInfo::FORMAT_AUTO, IGraphics::TEXLOAD_MULTI_DIMENSION);
VAR_17.m_pData = 0;
VAR_13->m_External = 1;
}
}
else
{
VAR_13->m_Width = VAR_4->m_Width;
VAR_13->m_Height = VAR_4->m_Height;
VAR_13->m_Format = VAR_4->m_Version == 1 ? CImageInfo::FORMAT_RGBA : VAR_4->m_Format;
int VAR_18 = VAR_13->m_Format == CImageInfo::FORMAT_RGB ? 3 : 4;
int VAR_19 = VAR_13->m_Width * VAR_13->m_Height * VAR_18;
void *VAR_20 = VAR_3.GetData(VAR_4->m_ImageData);
VAR_13->m_pData = mem_alloc(VAR_19);
mem_copy(VAR_13->m_pData, VAR_20, VAR_19);
VAR_13->m_Texture = m_pEditor->Graphics()->LoadTextureRaw(VAR_13->m_Width, VAR_13->m_Height, VAR_13->m_Format, VAR_13->m_pData, CImageInfo::FORMAT_AUTO, IGraphics::TEXLOAD_MULTI_DIMENSION);
}
if(VAR_12)
str_copy(VAR_13->m_aName, VAR_12, 128);
VAR_13->LoadAutoMapper();
VAR_21.add(VAR_13);
VAR_3.UnloadData(VAR_4->m_ImageData);
VAR_3.UnloadData(VAR_4->m_ImageName);
}
}
{
int VAR_22, VAR_23;
VAR_3.GetType(VAR_24, &VAR_22, &VAR_23);
int VAR_8, VAR_9;
VAR_3.GetType(VAR_25, &VAR_8, &VAR_9);
for(int VAR_26 = 0; VAR_26 < VAR_9; VAR_26++)
{
CMapItemGroup *VAR_27 = (CMapItemGroup *)VAR_3.GetItem(VAR_8+VAR_26, 0, 0);
if(VAR_27->m_Version < 1 || VAR_27->m_Version > CMapItemGroup::CURRENT_VERSION)
continue;
CLayerGroup *VAR_28 = NewGroup();
VAR_28->m_ParallaxX = VAR_27->m_ParallaxX;
VAR_28->m_ParallaxY = VAR_27->m_ParallaxY;
VAR_28->m_OffsetX = VAR_27->m_OffsetX;
VAR_28->m_OffsetY = VAR_27->m_OffsetY;
if(VAR_27->m_Version >= 2)
{
VAR_28->m_UseClipping = VAR_27->m_UseClipping;
VAR_28->m_ClipX = VAR_27->m_ClipX;
VAR_28->m_ClipY = VAR_27->m_ClipY;
VAR_28->m_ClipW = VAR_27->m_ClipW;
VAR_28->m_ClipH = VAR_27->m_ClipH;
}
if(VAR_27->m_Version >= 3)
IntsToStr(VAR_27->m_aName, sizeof(VAR_28->m_aName)/sizeof(int), VAR_28->m_aName);
for(int VAR_29 = 0; VAR_29 < VAR_27->m_NumLayers; VAR_29++)
{
CLayer *VAR_30 = 0;
CMapItemLayer *VAR_31 = (CMapItemLayer *)VAR_3.GetItem(VAR_22+VAR_27->m_StartLayer+VAR_29, 0, 0);
if(!VAR_31)
continue;
if(VAR_31->m_Type == VAR_32)
{
CMapItemLayerTilemap *VAR_33 = (CMapItemLayerTilemap *)VAR_31;
CLayerTiles *VAR_34 = 0;
if(VAR_33->m_Flags&VAR_35)
{
VAR_34 = new CLayerGame(VAR_33->m_Width, VAR_33->m_Height);
MakeGameLayer(VAR_34);
MakeGameGroup(VAR_28);
}
else
{
VAR_34 = new CLayerTiles(VAR_33->m_Width, VAR_33->m_Height);
VAR_34->m_pEditor = m_pEditor;
VAR_34->m_Color = VAR_33->m_Color;
VAR_34->m_ColorEnv = VAR_33->m_ColorEnv;
VAR_34->m_ColorEnvOffset = VAR_33->m_ColorEnvOffset;
}
VAR_30 = VAR_34;
VAR_28->AddLayer(VAR_34);
void *VAR_20 = VAR_3.GetData(VAR_33->m_Data);
VAR_34->m_Image = VAR_33->m_Image;
VAR_34->m_Game = VAR_33->m_Flags&VAR_35;
if(VAR_33->m_Version >= 3)
IntsToStr(VAR_33->m_aName, sizeof(VAR_34->m_aName)/sizeof(int), VAR_34->m_aName);
if(VAR_33->m_Version > 3)
VAR_34->ExtractTiles((CTile *)VAR_20);
else
mem_copy(VAR_34->m_pTiles, VAR_20, VAR_34->m_Width*VAR_34->m_Height*sizeof(CTile));
if(VAR_34->m_Game && VAR_33->m_Version == MakeVersion(1, *VAR_33))
{
for(int VAR_11 = 0; VAR_11 < VAR_34->m_Width*VAR_34->m_Height; VAR_11++)
{
if(VAR_34->m_pTiles[VAR_11].m_Index)
VAR_34->m_pTiles[VAR_11].m_Index += VAR_36;
}
}
VAR_3.UnloadData(VAR_33->m_Data);
}
else if(VAR_31->m_Type == VAR_37)
{
CMapItemLayerQuads *VAR_38 = (CMapItemLayerQuads *)VAR_31;
CLayerQuads *VAR_39 = new CLayerQuads;
VAR_39->m_pEditor = m_pEditor;
VAR_30 = VAR_39;
VAR_39->m_Image = VAR_38->m_Image;
if(VAR_39->m_Image < -1 || VAR_39->m_Image >= VAR_21.size())
VAR_39->m_Image = -1;
if(VAR_38->m_Version >= 2)
IntsToStr(VAR_38->m_aName, sizeof(VAR_39->m_aName)/sizeof(int), VAR_39->m_aName);
void *VAR_20 = VAR_3.GetDataSwapped(VAR_38->m_Data);
VAR_28->AddLayer(VAR_39);
VAR_39->m_lQuads.set_size(VAR_38->m_NumQuads);
mem_copy(VAR_39->m_lQuads.base_ptr(), VAR_20, sizeof(VAR_40)*VAR_38->m_NumQuads);
VAR_3.UnloadData(VAR_38->m_Data);
}
if(VAR_30)
VAR_30->m_Flags = VAR_31->m_Flags;
}
}
}
{
CEnvPoint *VAR_41 = 0;
{
int VAR_8, VAR_9;
VAR_3.GetType(VAR_42, &VAR_8, &VAR_9);
if(VAR_9)
VAR_41 = (CEnvPoint *)VAR_3.GetItem(VAR_8, 0, 0);
}
int VAR_8, VAR_9;
VAR_3.GetType(VAR_43, &VAR_8, &VAR_9);
for(int VAR_44 = 0; VAR_44 < VAR_9; VAR_44++)
{
CMapItemEnvelope *VAR_4 = (CMapItemEnvelope *)VAR_3.GetItem(VAR_8+VAR_44, 0, 0);
CEnvelope *VAR_45 = new CEnvelope(VAR_4->m_Channels);
VAR_45->m_lPoints.set_size(VAR_4->m_NumPoints);
for(int VAR_46 = 0; VAR_46 < VAR_4->m_NumPoints; VAR_46++)
{
if(VAR_4->m_Version >= 3)
{
VAR_45->m_lPoints[VAR_46] = VAR_41[VAR_4->m_StartPoint + VAR_46];
}
else
{
CEnvPoint_v1 *VAR_47 = &((CEnvPoint_v1 *)VAR_41)[VAR_4->m_StartPoint + VAR_46];
mem_zero((void*)&VAR_45->m_lPoints[VAR_46], sizeof(CEnvPoint));
VAR_45->m_lPoints[VAR_46].m_Time = VAR_47->m_Time;
VAR_45->m_lPoints[VAR_46].m_Curvetype = VAR_47->m_Curvetype;
for(int VAR_48 = 0; VAR_48 < VAR_4->m_Channels; VAR_48++)
{
VAR_45->m_lPoints[VAR_46].m_aValues[VAR_48] = VAR_47->m_aValues[VAR_48];
}
}
}
if(VAR_4->m_aName[0] != -1)
IntsToStr(VAR_4->m_aName, sizeof(VAR_4->m_aName)/sizeof(int), VAR_45->m_aName);
VAR_49.add(VAR_45);
if(VAR_4->m_Version >= 2)
VAR_45->m_Synchronized = VAR_4->m_Synchronized;
}
}
}
else
return 0;
return 1;
}",teeworlds/91e5492d4c210f82f1ca6b43a73417fef5463368/io.cpp/vul/before/0.json,"int CEditorMap::Load(class IStorage *pStorage, const char *pFileName, int StorageType)
{
	CDataFileReader DataFile;
	if(!DataFile.Open(pStorage, pFileName, StorageType))
		return 0;

	Clean();

	// check version
	CMapItemVersion *pItem = (CMapItemVersion *)DataFile.FindItem(MAPITEMTYPE_VERSION, 0);
	if(!pItem)
	{
		return 0;
	}
	else if(pItem->m_Version == CMapItemVersion::CURRENT_VERSION)
	{
		// load map info
		{
			CMapItemInfo *pItem = (CMapItemInfo *)DataFile.FindItem(MAPITEMTYPE_INFO, 0);
			if(pItem && pItem->m_Version == 1)
			{
				if(pItem->m_Author > -1)
					str_copy(m_MapInfo.m_aAuthor, (char *)DataFile.GetData(pItem->m_Author), sizeof(m_MapInfo.m_aAuthor));
				if(pItem->m_MapVersion > -1)
					str_copy(m_MapInfo.m_aVersion, (char *)DataFile.GetData(pItem->m_MapVersion), sizeof(m_MapInfo.m_aVersion));
				if(pItem->m_Credits > -1)
					str_copy(m_MapInfo.m_aCredits, (char *)DataFile.GetData(pItem->m_Credits), sizeof(m_MapInfo.m_aCredits));
				if(pItem->m_License > -1)
					str_copy(m_MapInfo.m_aLicense, (char *)DataFile.GetData(pItem->m_License), sizeof(m_MapInfo.m_aLicense));
			}
		}

		// load images
		{
			int Start, Num;
			DataFile.GetType( MAPITEMTYPE_IMAGE, &Start, &Num);
			for(int i = 0; i < Num; i++)
			{
				CMapItemImage *pItem = (CMapItemImage *)DataFile.GetItem(Start+i, 0, 0);
				char *pName = (char *)DataFile.GetData(pItem->m_ImageName);

				// copy base info
				CEditorImage *pImg = new CEditorImage(m_pEditor);
				pImg->m_External = pItem->m_External;

				if(pItem->m_External || (pItem->m_Version > 1 && pItem->m_Format != CImageInfo::FORMAT_RGB && pItem->m_Format != CImageInfo::FORMAT_RGBA))
				{
					char aBuf[IO_MAX_PATH_LENGTH];
					str_format(aBuf, sizeof(aBuf),""mapres/%s.png"", pName);

					// load external
					CEditorImage ImgInfo(m_pEditor);
					if(m_pEditor->Graphics()->LoadPNG(&ImgInfo, aBuf, IStorage::TYPE_ALL))
					{
						*pImg = ImgInfo;
						pImg->m_Texture = m_pEditor->Graphics()->LoadTextureRaw(ImgInfo.m_Width, ImgInfo.m_Height, ImgInfo.m_Format, ImgInfo.m_pData, CImageInfo::FORMAT_AUTO, IGraphics::TEXLOAD_MULTI_DIMENSION);
						ImgInfo.m_pData = 0;
						pImg->m_External = 1;
					}
				}
				else
				{
					pImg->m_Width = pItem->m_Width;
					pImg->m_Height = pItem->m_Height;
					pImg->m_Format = pItem->m_Version == 1 ? CImageInfo::FORMAT_RGBA : pItem->m_Format;
					int PixelSize = pImg->m_Format == CImageInfo::FORMAT_RGB ? 3 : 4;

					// copy image data
					int DataSize = pImg->m_Width * pImg->m_Height * PixelSize;
					void *pData = DataFile.GetData(pItem->m_ImageData);
					pImg->m_pData = mem_alloc(DataSize);
					mem_copy(pImg->m_pData, pData, DataSize);
					pImg->m_Texture = m_pEditor->Graphics()->LoadTextureRaw(pImg->m_Width, pImg->m_Height, pImg->m_Format, pImg->m_pData, CImageInfo::FORMAT_AUTO, IGraphics::TEXLOAD_MULTI_DIMENSION);
				}

				// copy image name
				if(pName)
					str_copy(pImg->m_aName, pName, 128);

				// load auto mapper file
				pImg->LoadAutoMapper();

				m_lImages.add(pImg);

				// unload image
				DataFile.UnloadData(pItem->m_ImageData);
				DataFile.UnloadData(pItem->m_ImageName);
			}
		}

		// load groups
		{
			int LayersStart, LayersNum;
			DataFile.GetType(MAPITEMTYPE_LAYER, &LayersStart, &LayersNum);

			int Start, Num;
			DataFile.GetType(MAPITEMTYPE_GROUP, &Start, &Num);
			for(int g = 0; g < Num; g++)
			{
				CMapItemGroup *pGItem = (CMapItemGroup *)DataFile.GetItem(Start+g, 0, 0);

				if(pGItem->m_Version < 1 || pGItem->m_Version > CMapItemGroup::CURRENT_VERSION)
					continue;

				CLayerGroup *pGroup = NewGroup();
				pGroup->m_ParallaxX = pGItem->m_ParallaxX;
				pGroup->m_ParallaxY = pGItem->m_ParallaxY;
				pGroup->m_OffsetX = pGItem->m_OffsetX;
				pGroup->m_OffsetY = pGItem->m_OffsetY;

				if(pGItem->m_Version >= 2)
				{
					pGroup->m_UseClipping = pGItem->m_UseClipping;
					pGroup->m_ClipX = pGItem->m_ClipX;
					pGroup->m_ClipY = pGItem->m_ClipY;
					pGroup->m_ClipW = pGItem->m_ClipW;
					pGroup->m_ClipH = pGItem->m_ClipH;
				}

				// load group name
				if(pGItem->m_Version >= 3)
					IntsToStr(pGItem->m_aName, sizeof(pGroup->m_aName)/sizeof(int), pGroup->m_aName);

				for(int l = 0; l < pGItem->m_NumLayers; l++)
				{
					CLayer *pLayer = 0;
					CMapItemLayer *pLayerItem = (CMapItemLayer *)DataFile.GetItem(LayersStart+pGItem->m_StartLayer+l, 0, 0);
					if(!pLayerItem)
						continue;

					if(pLayerItem->m_Type == LAYERTYPE_TILES)
					{
						CMapItemLayerTilemap *pTilemapItem = (CMapItemLayerTilemap *)pLayerItem;
						CLayerTiles *pTiles = 0;

						if(pTilemapItem->m_Flags&TILESLAYERFLAG_GAME)
						{
							pTiles = new CLayerGame(pTilemapItem->m_Width, pTilemapItem->m_Height);
							MakeGameLayer(pTiles);
							MakeGameGroup(pGroup);
						}
						else
						{
							pTiles = new CLayerTiles(pTilemapItem->m_Width, pTilemapItem->m_Height);
							pTiles->m_pEditor = m_pEditor;
							pTiles->m_Color = pTilemapItem->m_Color;
							pTiles->m_ColorEnv = pTilemapItem->m_ColorEnv;
							pTiles->m_ColorEnvOffset = pTilemapItem->m_ColorEnvOffset;
						}

						pLayer = pTiles;

						pGroup->AddLayer(pTiles);
						void *pData = DataFile.GetData(pTilemapItem->m_Data);
						pTiles->m_Image = pTilemapItem->m_Image;
						pTiles->m_Game = pTilemapItem->m_Flags&TILESLAYERFLAG_GAME;

						// load layer name
						if(pTilemapItem->m_Version >= 3)
							IntsToStr(pTilemapItem->m_aName, sizeof(pTiles->m_aName)/sizeof(int), pTiles->m_aName);

						// get tile data
						if(pTilemapItem->m_Version > 3)
							pTiles->ExtractTiles((CTile *)pData);
						else
							mem_copy(pTiles->m_pTiles, pData, pTiles->m_Width*pTiles->m_Height*sizeof(CTile));


						if(pTiles->m_Game && pTilemapItem->m_Version == MakeVersion(1, *pTilemapItem))
						{
							for(int i = 0; i < pTiles->m_Width*pTiles->m_Height; i++)
							{
								if(pTiles->m_pTiles[i].m_Index)
									pTiles->m_pTiles[i].m_Index += ENTITY_OFFSET;
							}
						}

						DataFile.UnloadData(pTilemapItem->m_Data);
					}
					else if(pLayerItem->m_Type == LAYERTYPE_QUADS)
					{
						CMapItemLayerQuads *pQuadsItem = (CMapItemLayerQuads *)pLayerItem;
						CLayerQuads *pQuads = new CLayerQuads;
						pQuads->m_pEditor = m_pEditor;
						pLayer = pQuads;
						pQuads->m_Image = pQuadsItem->m_Image;
						if(pQuads->m_Image < -1 || pQuads->m_Image >= m_lImages.size())
							pQuads->m_Image = -1;

						// load layer name
						if(pQuadsItem->m_Version >= 2)
							IntsToStr(pQuadsItem->m_aName, sizeof(pQuads->m_aName)/sizeof(int), pQuads->m_aName);

						void *pData = DataFile.GetDataSwapped(pQuadsItem->m_Data);
						pGroup->AddLayer(pQuads);
						pQuads->m_lQuads.set_size(pQuadsItem->m_NumQuads);
						mem_copy(pQuads->m_lQuads.base_ptr(), pData, sizeof(CQuad)*pQuadsItem->m_NumQuads);
						DataFile.UnloadData(pQuadsItem->m_Data);
					}

					if(pLayer)
						pLayer->m_Flags = pLayerItem->m_Flags;
				}
			}
		}

		// load envelopes
		{
			CEnvPoint *pEnvPoints = 0;
			{
				int Start, Num;
				DataFile.GetType(MAPITEMTYPE_ENVPOINTS, &Start, &Num);
				if(Num)
					pEnvPoints = (CEnvPoint *)DataFile.GetItem(Start, 0, 0);
			}

			int Start, Num;
			DataFile.GetType(MAPITEMTYPE_ENVELOPE, &Start, &Num);
			for(int e = 0; e < Num; e++)
			{
				CMapItemEnvelope *pItem = (CMapItemEnvelope *)DataFile.GetItem(Start+e, 0, 0);
				const int Channels = minimum(pItem->m_Channels, 4);
				CEnvelope *pEnv = new CEnvelope(Channels);
				pEnv->m_lPoints.set_size(pItem->m_NumPoints);
				for(int n = 0; n < pItem->m_NumPoints; n++)
				{
					if(pItem->m_Version >= 3)
					{
						pEnv->m_lPoints[n] = pEnvPoints[pItem->m_StartPoint + n];
					}
					else
					{
						// backwards compatibility
						CEnvPoint_v1 *pEnvPoint_v1 = &((CEnvPoint_v1 *)pEnvPoints)[pItem->m_StartPoint + n];
						mem_zero((void*)&pEnv->m_lPoints[n], sizeof(CEnvPoint));

						pEnv->m_lPoints[n].m_Time = pEnvPoint_v1->m_Time;
						pEnv->m_lPoints[n].m_Curvetype = pEnvPoint_v1->m_Curvetype;

						for(int c = 0; c < Channels; c++)
						{
							pEnv->m_lPoints[n].m_aValues[c] = pEnvPoint_v1->m_aValues[c];
						}
					}
				}

				if(pItem->m_aName[0] != -1)	// compatibility with old maps
					IntsToStr(pItem->m_aName, sizeof(pItem->m_aName)/sizeof(int), pEnv->m_aName);
				m_lEnvelopes.add(pEnv);
				if(pItem->m_Version >= 2)
					pEnv->m_Synchronized = pItem->m_Synchronized;
			}
		}
	}
	else
		return 0;

	return 1;
}","int CEditorMap::Load(class IStorage *VAR_0, const char *VAR_1, int VAR_2)
{
	CDataFileReader VAR_3;
	if(!VAR_3.Open(VAR_0, VAR_1, VAR_2))
		return 0;

	Clean();

	/* COMMENT_0 */
	CMapItemVersion *VAR_4 = (CMapItemVersion *)VAR_3.FindItem(VAR_5, 0);
	if(!VAR_4)
	{
		return 0;
	}
	else if(VAR_4->m_Version == CMapItemVersion::CURRENT_VERSION)
	{
		/* COMMENT_1 */
		{
			CMapItemInfo *VAR_4 = (CMapItemInfo *)VAR_3.FindItem(VAR_6, 0);
			if(VAR_4 && VAR_4->m_Version == 1)
			{
				if(VAR_4->m_Author > -1)
					str_copy(VAR_7.m_aAuthor, (char *)VAR_3.GetData(VAR_4->m_Author), sizeof(VAR_7.m_aAuthor));
				if(VAR_4->m_MapVersion > -1)
					str_copy(VAR_7.m_aVersion, (char *)VAR_3.GetData(VAR_4->m_MapVersion), sizeof(VAR_7.m_aVersion));
				if(VAR_4->m_Credits > -1)
					str_copy(VAR_7.m_aCredits, (char *)VAR_3.GetData(VAR_4->m_Credits), sizeof(VAR_7.m_aCredits));
				if(VAR_4->m_License > -1)
					str_copy(VAR_7.m_aLicense, (char *)VAR_3.GetData(VAR_4->m_License), sizeof(VAR_7.m_aLicense));
			}
		}

		/* COMMENT_2 */
		{
			int VAR_8, VAR_9;
			VAR_3.GetType( VAR_10, &VAR_8, &VAR_9);
			for(int VAR_11 = 0; VAR_11 < VAR_9; VAR_11++)
			{
				CMapItemImage *VAR_4 = (CMapItemImage *)VAR_3.GetItem(VAR_8+VAR_11, 0, 0);
				char *VAR_12 = (char *)VAR_3.GetData(VAR_4->m_ImageName);

				/* COMMENT_3 */
				CEditorImage *VAR_13 = new CEditorImage(VAR_14);
				VAR_13->m_External = VAR_4->m_External;

				if(VAR_4->m_External || (VAR_4->m_Version > 1 && VAR_4->m_Format != CImageInfo::FORMAT_RGB && VAR_4->m_Format != CImageInfo::FORMAT_RGBA))
				{
					char VAR_15[VAR_16];
					str_format(VAR_15, sizeof(VAR_15),""mapres/%s.png"", VAR_12);

					/* COMMENT_4 */
					CEditorImage ImgInfo(m_pEditor);
					if(m_pEditor->Graphics()->LoadPNG(&VAR_17, VAR_15, IStorage::TYPE_ALL))
					{
						*VAR_13 = VAR_17;
						VAR_13->m_Texture = m_pEditor->Graphics()->LoadTextureRaw(VAR_17.m_Width, VAR_17.m_Height, VAR_17.m_Format, VAR_17.m_pData, CImageInfo::FORMAT_AUTO, IGraphics::TEXLOAD_MULTI_DIMENSION);
						VAR_17.m_pData = 0;
						VAR_13->m_External = 1;
					}
				}
				else
				{
					VAR_13->m_Width = VAR_4->m_Width;
					VAR_13->m_Height = VAR_4->m_Height;
					VAR_13->m_Format = VAR_4->m_Version == 1 ? CImageInfo::FORMAT_RGBA : VAR_4->m_Format;
					int VAR_18 = VAR_13->m_Format == CImageInfo::FORMAT_RGB ? 3 : 4;

					/* COMMENT_5 */
					int VAR_19 = VAR_13->m_Width * VAR_13->m_Height * VAR_18;
					void *VAR_20 = VAR_3.GetData(VAR_4->m_ImageData);
					VAR_13->m_pData = mem_alloc(VAR_19);
					mem_copy(VAR_13->m_pData, VAR_20, VAR_19);
					VAR_13->m_Texture = m_pEditor->Graphics()->LoadTextureRaw(VAR_13->m_Width, VAR_13->m_Height, VAR_13->m_Format, VAR_13->m_pData, CImageInfo::FORMAT_AUTO, IGraphics::TEXLOAD_MULTI_DIMENSION);
				}

				/* COMMENT_6 */
				if(VAR_12)
					str_copy(VAR_13->m_aName, VAR_12, 128);

				/* COMMENT_7 */
				VAR_13->LoadAutoMapper();

				VAR_21.add(VAR_13);

				/* COMMENT_8 */
				VAR_3.UnloadData(VAR_4->m_ImageData);
				VAR_3.UnloadData(VAR_4->m_ImageName);
			}
		}

		/* COMMENT_9 */
		{
			int VAR_22, VAR_23;
			VAR_3.GetType(VAR_24, &VAR_22, &VAR_23);

			int VAR_8, VAR_9;
			VAR_3.GetType(VAR_25, &VAR_8, &VAR_9);
			for(int VAR_26 = 0; VAR_26 < VAR_9; VAR_26++)
			{
				CMapItemGroup *VAR_27 = (CMapItemGroup *)VAR_3.GetItem(VAR_8+VAR_26, 0, 0);

				if(VAR_27->m_Version < 1 || VAR_27->m_Version > CMapItemGroup::CURRENT_VERSION)
					continue;

				CLayerGroup *VAR_28 = NewGroup();
				VAR_28->m_ParallaxX = VAR_27->m_ParallaxX;
				VAR_28->m_ParallaxY = VAR_27->m_ParallaxY;
				VAR_28->m_OffsetX = VAR_27->m_OffsetX;
				VAR_28->m_OffsetY = VAR_27->m_OffsetY;

				if(VAR_27->m_Version >= 2)
				{
					VAR_28->m_UseClipping = VAR_27->m_UseClipping;
					VAR_28->m_ClipX = VAR_27->m_ClipX;
					VAR_28->m_ClipY = VAR_27->m_ClipY;
					VAR_28->m_ClipW = VAR_27->m_ClipW;
					VAR_28->m_ClipH = VAR_27->m_ClipH;
				}

				/* COMMENT_10 */
				if(VAR_27->m_Version >= 3)
					IntsToStr(VAR_27->m_aName, sizeof(VAR_28->m_aName)/sizeof(int), VAR_28->m_aName);

				for(int VAR_29 = 0; VAR_29 < VAR_27->m_NumLayers; VAR_29++)
				{
					CLayer *VAR_30 = 0;
					CMapItemLayer *VAR_31 = (CMapItemLayer *)VAR_3.GetItem(VAR_22+VAR_27->m_StartLayer+VAR_29, 0, 0);
					if(!VAR_31)
						continue;

					if(VAR_31->m_Type == VAR_32)
					{
						CMapItemLayerTilemap *VAR_33 = (CMapItemLayerTilemap *)VAR_31;
						CLayerTiles *VAR_34 = 0;

						if(VAR_33->m_Flags&VAR_35)
						{
							VAR_34 = new CLayerGame(VAR_33->m_Width, VAR_33->m_Height);
							MakeGameLayer(VAR_34);
							MakeGameGroup(VAR_28);
						}
						else
						{
							VAR_34 = new CLayerTiles(VAR_33->m_Width, VAR_33->m_Height);
							VAR_34->m_pEditor = m_pEditor;
							VAR_34->m_Color = VAR_33->m_Color;
							VAR_34->m_ColorEnv = VAR_33->m_ColorEnv;
							VAR_34->m_ColorEnvOffset = VAR_33->m_ColorEnvOffset;
						}

						VAR_30 = VAR_34;

						VAR_28->AddLayer(VAR_34);
						void *VAR_20 = VAR_3.GetData(VAR_33->m_Data);
						VAR_34->m_Image = VAR_33->m_Image;
						VAR_34->m_Game = VAR_33->m_Flags&VAR_35;

						/* COMMENT_11 */
						if(VAR_33->m_Version >= 3)
							IntsToStr(VAR_33->m_aName, sizeof(VAR_34->m_aName)/sizeof(int), VAR_34->m_aName);

						/* COMMENT_12 */
						if(VAR_33->m_Version > 3)
							VAR_34->ExtractTiles((CTile *)VAR_20);
						else
							mem_copy(VAR_34->m_pTiles, VAR_20, VAR_34->m_Width*VAR_34->m_Height*sizeof(CTile));


						if(VAR_34->m_Game && VAR_33->m_Version == MakeVersion(1, *VAR_33))
						{
							for(int VAR_11 = 0; VAR_11 < VAR_34->m_Width*VAR_34->m_Height; VAR_11++)
							{
								if(VAR_34->m_pTiles[VAR_11].m_Index)
									VAR_34->m_pTiles[VAR_11].m_Index += VAR_36;
							}
						}

						VAR_3.UnloadData(VAR_33->m_Data);
					}
					else if(VAR_31->m_Type == VAR_37)
					{
						CMapItemLayerQuads *VAR_38 = (CMapItemLayerQuads *)VAR_31;
						CLayerQuads *VAR_39 = new CLayerQuads;
						VAR_39->m_pEditor = m_pEditor;
						VAR_30 = VAR_39;
						VAR_39->m_Image = VAR_38->m_Image;
						if(VAR_39->m_Image < -1 || VAR_39->m_Image >= VAR_21.size())
							VAR_39->m_Image = -1;

						/* COMMENT_11 */
						if(VAR_38->m_Version >= 2)
							IntsToStr(VAR_38->m_aName, sizeof(VAR_39->m_aName)/sizeof(int), VAR_39->m_aName);

						void *VAR_20 = VAR_3.GetDataSwapped(VAR_38->m_Data);
						VAR_28->AddLayer(VAR_39);
						VAR_39->m_lQuads.set_size(VAR_38->m_NumQuads);
						mem_copy(VAR_39->m_lQuads.base_ptr(), VAR_20, sizeof(VAR_40)*VAR_38->m_NumQuads);
						VAR_3.UnloadData(VAR_38->m_Data);
					}

					if(VAR_30)
						VAR_30->m_Flags = VAR_31->m_Flags;
				}
			}
		}

		/* COMMENT_13 */
		{
			CEnvPoint *VAR_41 = 0;
			{
				int VAR_8, VAR_9;
				VAR_3.GetType(VAR_42, &VAR_8, &VAR_9);
				if(VAR_9)
					VAR_41 = (CEnvPoint *)VAR_3.GetItem(VAR_8, 0, 0);
			}

			int VAR_8, VAR_9;
			VAR_3.GetType(VAR_43, &VAR_8, &VAR_9);
			for(int VAR_44 = 0; VAR_44 < VAR_9; VAR_44++)
			{
				CMapItemEnvelope *VAR_4 = (CMapItemEnvelope *)VAR_3.GetItem(VAR_8+VAR_44, 0, 0);
				const int VAR_45 = minimum(VAR_4->m_Channels, 4);
				CEnvelope *VAR_46 = new CEnvelope(VAR_45);
				VAR_46->m_lPoints.set_size(VAR_4->m_NumPoints);
				for(int VAR_47 = 0; VAR_47 < VAR_4->m_NumPoints; VAR_47++)
				{
					if(VAR_4->m_Version >= 3)
					{
						VAR_46->m_lPoints[VAR_47] = VAR_41[VAR_4->m_StartPoint + VAR_47];
					}
					else
					{
						/* COMMENT_14 */
						CEnvPoint_v1 *VAR_48 = &((CEnvPoint_v1 *)VAR_41)[VAR_4->m_StartPoint + VAR_47];
						mem_zero((void*)&VAR_46->m_lPoints[VAR_47], sizeof(CEnvPoint));

						VAR_46->m_lPoints[VAR_47].m_Time = VAR_48->m_Time;
						VAR_46->m_lPoints[VAR_47].m_Curvetype = VAR_48->m_Curvetype;

						for(int VAR_49 = 0; VAR_49 < VAR_45; VAR_49++)
						{
							VAR_46->m_lPoints[VAR_47].m_aValues[VAR_49] = VAR_48->m_aValues[VAR_49];
						}
					}
				}

				if(VAR_4->m_aName[0] != -1)	/* COMMENT_15 */
					IntsToStr(VAR_4->m_aName, sizeof(VAR_4->m_aName)/sizeof(int), VAR_46->m_aName);
				VAR_50.add(VAR_46);
				if(VAR_4->m_Version >= 2)
					VAR_46->m_Synchronized = VAR_4->m_Synchronized;
			}
		}
	}
	else
		return 0;

	return 1;
}",teeworlds/91e5492d4c210f82f1ca6b43a73417fef5463368/io.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -219,7 +219,8 @@
 			for(int e = 0; e < Num; e++)
 			{
 				CMapItemEnvelope *pItem = (CMapItemEnvelope *)DataFile.GetItem(Start+e, 0, 0);
-				CEnvelope *pEnv = new CEnvelope(pItem->m_Channels);
+				const int Channels = minimum(pItem->m_Channels, 4);
+				CEnvelope *pEnv = new CEnvelope(Channels);
 				pEnv->m_lPoints.set_size(pItem->m_NumPoints);
 				for(int n = 0; n < pItem->m_NumPoints; n++)
 				{
@@ -236,7 +237,7 @@
 						pEnv->m_lPoints[n].m_Time = pEnvPoint_v1->m_Time;
 						pEnv->m_lPoints[n].m_Curvetype = pEnvPoint_v1->m_Curvetype;
 
-						for(int c = 0; c < pItem->m_Channels; c++)
+						for(int c = 0; c < Channels; c++)
 						{
 							pEnv->m_lPoints[n].m_aValues[c] = pEnvPoint_v1->m_aValues[c];
 						}","{'deleted_lines': ['\t\t\t\tCEnvelope *pEnv = new CEnvelope(pItem->m_Channels);', '\t\t\t\t\t\tfor(int c = 0; c < pItem->m_Channels; c++)'], 'added_lines': ['\t\t\t\tconst int Channels = minimum(pItem->m_Channels, 4);', '\t\t\t\tCEnvelope *pEnv = new CEnvelope(Channels);', '\t\t\t\t\t\tfor(int c = 0; c < Channels; c++)']}",True,"Teeworlds up to and including 0.7.5 is vulnerable to Buffer Overflow. A map parser does not validate m_Channels value coming from a map file, leading to a buffer overflow. A malicious server may offer a specially crafted map that will overwrite client's stack causing denial of service or code execution.",7.8,HIGH,2,test,2022-01-15T16:36:39Z,4
CVE-2022-23852,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,libexpat,lib: Detect and prevent integer overflow in XML_GetBuffer (CVE-2022-23852),847a645152f5ebc10ac63b74b604d0c1a79fae40,https://github.com/libexpat/libexpat/commit/847a645152f5ebc10ac63b74b604d0c1a79fae40,expat/lib/xmlparse.c,XML_GetBuffer,"void *XMLCALL
XML_GetBuffer(XML_Parser parser, int len) {
if (parser == NULL)
return NULL;
if (len < 0) {
parser->m_errorCode = XML_ERROR_NO_MEMORY;
return NULL;
}
switch (parser->m_parsingStatus.parsing) {
case XML_SUSPENDED:
parser->m_errorCode = XML_ERROR_SUSPENDED;
return NULL;
case XML_FINISHED:
parser->m_errorCode = XML_ERROR_FINISHED;
return NULL;
default:;
}
if (len > EXPAT_SAFE_PTR_DIFF(parser->m_bufferLim, parser->m_bufferEnd)) {
#ifdef XML_CONTEXT_BYTES
int keep;
#endif 
int neededSize = (int)((unsigned)len
+ (unsigned)EXPAT_SAFE_PTR_DIFF(
parser->m_bufferEnd, parser->m_bufferPtr));
if (neededSize < 0) {
parser->m_errorCode = XML_ERROR_NO_MEMORY;
return NULL;
}
#ifdef XML_CONTEXT_BYTES
keep = (int)EXPAT_SAFE_PTR_DIFF(parser->m_bufferPtr, parser->m_buffer);
if (keep > XML_CONTEXT_BYTES)
keep = XML_CONTEXT_BYTES;
neededSize += keep;
#endif 
if (neededSize
<= EXPAT_SAFE_PTR_DIFF(parser->m_bufferLim, parser->m_buffer)) {
#ifdef XML_CONTEXT_BYTES
if (keep < EXPAT_SAFE_PTR_DIFF(parser->m_bufferPtr, parser->m_buffer)) {
int offset
= (int)EXPAT_SAFE_PTR_DIFF(parser->m_bufferPtr, parser->m_buffer)
- keep;
memmove(parser->m_buffer, &parser->m_buffer[offset],
parser->m_bufferEnd - parser->m_bufferPtr + keep);
parser->m_bufferEnd -= offset;
parser->m_bufferPtr -= offset;
}
#else
if (parser->m_buffer && parser->m_bufferPtr) {
memmove(parser->m_buffer, parser->m_bufferPtr,
EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr));
parser->m_bufferEnd
= parser->m_buffer
+ EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr);
parser->m_bufferPtr = parser->m_buffer;
}
#endif 
} else {
char *newBuf;
int bufferSize
= (int)EXPAT_SAFE_PTR_DIFF(parser->m_bufferLim, parser->m_bufferPtr);
if (bufferSize == 0)
bufferSize = INIT_BUFFER_SIZE;
do {
bufferSize = (int)(2U * (unsigned)bufferSize);
} while (bufferSize < neededSize && bufferSize > 0);
if (bufferSize <= 0) {
parser->m_errorCode = XML_ERROR_NO_MEMORY;
return NULL;
}
newBuf = (char *)MALLOC(parser, bufferSize);
if (newBuf == 0) {
parser->m_errorCode = XML_ERROR_NO_MEMORY;
return NULL;
}
parser->m_bufferLim = newBuf + bufferSize;
#ifdef XML_CONTEXT_BYTES
if (parser->m_bufferPtr) {
memcpy(newBuf, &parser->m_bufferPtr[-keep],
EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr)
+ keep);
FREE(parser, parser->m_buffer);
parser->m_buffer = newBuf;
parser->m_bufferEnd
= parser->m_buffer
+ EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr)
+ keep;
parser->m_bufferPtr = parser->m_buffer + keep;
} else {
parser->m_bufferEnd = newBuf;
parser->m_bufferPtr = parser->m_buffer = newBuf;
}
#else
if (parser->m_bufferPtr) {
memcpy(newBuf, parser->m_bufferPtr,
EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr));
FREE(parser, parser->m_buffer);
parser->m_bufferEnd
= newBuf
+ EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr);
} else {
parser->m_bufferEnd = newBuf;
}
parser->m_bufferPtr = parser->m_buffer = newBuf;
#endif 
}
parser->m_eventPtr = parser->m_eventEndPtr = NULL;
parser->m_positionPtr = NULL;
}
return parser->m_bufferEnd;
}","void *VAR_0
XML_GetBuffer(XML_Parser VAR_1, int VAR_2) {
if (VAR_1 == NULL)
return NULL;
if (VAR_2 < 0) {
VAR_1->m_errorCode = VAR_3;
return NULL;
}
switch (VAR_1->m_parsingStatus.parsing) {
case VAR_4:
VAR_1->m_errorCode = VAR_5;
return NULL;
case VAR_6:
VAR_1->m_errorCode = VAR_7;
return NULL;
default:;
}
if (VAR_2 > EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferLim, VAR_1->m_bufferEnd)) {
#ifdef VAR_8
int VAR_9;
#endif 
int VAR_10 = (int)((unsigned)VAR_2
+ (unsigned)EXPAT_SAFE_PTR_DIFF(
VAR_1->m_bufferEnd, VAR_1->m_bufferPtr));
if (VAR_10 < 0) {
VAR_1->m_errorCode = VAR_3;
return NULL;
}
#ifdef VAR_8
VAR_9 = (int)EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferPtr, VAR_1->m_buffer);
if (VAR_9 > VAR_8)
VAR_9 = VAR_8;
VAR_10 += VAR_9;
#endif 
if (VAR_10
<= EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferLim, VAR_1->m_buffer)) {
#ifdef VAR_8
if (VAR_9 < EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferPtr, VAR_1->m_buffer)) {
int VAR_11
= (int)EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferPtr, VAR_1->m_buffer)
- VAR_9;
memmove(VAR_1->m_buffer, &VAR_1->m_buffer[VAR_11],
VAR_1->m_bufferEnd - VAR_1->m_bufferPtr + VAR_9);
VAR_1->m_bufferEnd -= VAR_11;
VAR_1->m_bufferPtr -= VAR_11;
}
#else
if (VAR_1->m_buffer && VAR_1->m_bufferPtr) {
memmove(VAR_1->m_buffer, VAR_1->m_bufferPtr,
EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferEnd, VAR_1->m_bufferPtr));
VAR_1->m_bufferEnd
= VAR_1->m_buffer
+ EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferEnd, VAR_1->m_bufferPtr);
VAR_1->m_bufferPtr = VAR_1->m_buffer;
}
#endif 
} else {
char *VAR_12;
int VAR_13
= (int)EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferLim, VAR_1->m_bufferPtr);
if (VAR_13 == 0)
VAR_13 = VAR_14;
do {
VAR_13 = (int)(2U * (unsigned)VAR_13);
} while (VAR_13 < VAR_10 && VAR_13 > 0);
if (VAR_13 <= 0) {
VAR_1->m_errorCode = VAR_3;
return NULL;
}
VAR_12 = (char *)MALLOC(VAR_1, VAR_13);
if (VAR_12 == 0) {
VAR_1->m_errorCode = VAR_3;
return NULL;
}
VAR_1->m_bufferLim = VAR_12 + VAR_13;
#ifdef VAR_8
if (VAR_1->m_bufferPtr) {
memcpy(VAR_12, &VAR_1->m_bufferPtr[-VAR_9],
EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferEnd, VAR_1->m_bufferPtr)
+ VAR_9);
FREE(VAR_1, VAR_1->m_buffer);
VAR_1->m_buffer = VAR_12;
VAR_1->m_bufferEnd
= VAR_1->m_buffer
+ EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferEnd, VAR_1->m_bufferPtr)
+ VAR_9;
VAR_1->m_bufferPtr = VAR_1->m_buffer + VAR_9;
} else {
VAR_1->m_bufferEnd = VAR_12;
VAR_1->m_bufferPtr = VAR_1->m_buffer = VAR_12;
}
#else
if (VAR_1->m_bufferPtr) {
memcpy(VAR_12, VAR_1->m_bufferPtr,
EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferEnd, VAR_1->m_bufferPtr));
FREE(VAR_1, VAR_1->m_buffer);
VAR_1->m_bufferEnd
= VAR_12
+ EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferEnd, VAR_1->m_bufferPtr);
} else {
VAR_1->m_bufferEnd = VAR_12;
}
VAR_1->m_bufferPtr = VAR_1->m_buffer = VAR_12;
#endif 
}
VAR_1->m_eventPtr = VAR_1->m_eventEndPtr = NULL;
VAR_1->m_positionPtr = NULL;
}
return VAR_1->m_bufferEnd;
}",,"void *XMLCALL
XML_GetBuffer(XML_Parser parser, int len) {
  if (parser == NULL)
    return NULL;
  if (len < 0) {
    parser->m_errorCode = XML_ERROR_NO_MEMORY;
    return NULL;
  }
  switch (parser->m_parsingStatus.parsing) {
  case XML_SUSPENDED:
    parser->m_errorCode = XML_ERROR_SUSPENDED;
    return NULL;
  case XML_FINISHED:
    parser->m_errorCode = XML_ERROR_FINISHED;
    return NULL;
  default:;
  }

  if (len > EXPAT_SAFE_PTR_DIFF(parser->m_bufferLim, parser->m_bufferEnd)) {
#ifdef XML_CONTEXT_BYTES
    int keep;
#endif /* defined XML_CONTEXT_BYTES */
    /* Do not invoke signed arithmetic overflow: */
    int neededSize = (int)((unsigned)len
                           + (unsigned)EXPAT_SAFE_PTR_DIFF(
                               parser->m_bufferEnd, parser->m_bufferPtr));
    if (neededSize < 0) {
      parser->m_errorCode = XML_ERROR_NO_MEMORY;
      return NULL;
    }
#ifdef XML_CONTEXT_BYTES
    keep = (int)EXPAT_SAFE_PTR_DIFF(parser->m_bufferPtr, parser->m_buffer);
    if (keep > XML_CONTEXT_BYTES)
      keep = XML_CONTEXT_BYTES;
    /* Detect and prevent integer overflow */
    if (keep > INT_MAX - neededSize) {
      parser->m_errorCode = XML_ERROR_NO_MEMORY;
      return NULL;
    }
    neededSize += keep;
#endif /* defined XML_CONTEXT_BYTES */
    if (neededSize
        <= EXPAT_SAFE_PTR_DIFF(parser->m_bufferLim, parser->m_buffer)) {
#ifdef XML_CONTEXT_BYTES
      if (keep < EXPAT_SAFE_PTR_DIFF(parser->m_bufferPtr, parser->m_buffer)) {
        int offset
            = (int)EXPAT_SAFE_PTR_DIFF(parser->m_bufferPtr, parser->m_buffer)
              - keep;
        /* The buffer pointers cannot be NULL here; we have at least some bytes
         * in the buffer */
        memmove(parser->m_buffer, &parser->m_buffer[offset],
                parser->m_bufferEnd - parser->m_bufferPtr + keep);
        parser->m_bufferEnd -= offset;
        parser->m_bufferPtr -= offset;
      }
#else
      if (parser->m_buffer && parser->m_bufferPtr) {
        memmove(parser->m_buffer, parser->m_bufferPtr,
                EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr));
        parser->m_bufferEnd
            = parser->m_buffer
              + EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr);
        parser->m_bufferPtr = parser->m_buffer;
      }
#endif /* not defined XML_CONTEXT_BYTES */
    } else {
      char *newBuf;
      int bufferSize
          = (int)EXPAT_SAFE_PTR_DIFF(parser->m_bufferLim, parser->m_bufferPtr);
      if (bufferSize == 0)
        bufferSize = INIT_BUFFER_SIZE;
      do {
        /* Do not invoke signed arithmetic overflow: */
        bufferSize = (int)(2U * (unsigned)bufferSize);
      } while (bufferSize < neededSize && bufferSize > 0);
      if (bufferSize <= 0) {
        parser->m_errorCode = XML_ERROR_NO_MEMORY;
        return NULL;
      }
      newBuf = (char *)MALLOC(parser, bufferSize);
      if (newBuf == 0) {
        parser->m_errorCode = XML_ERROR_NO_MEMORY;
        return NULL;
      }
      parser->m_bufferLim = newBuf + bufferSize;
#ifdef XML_CONTEXT_BYTES
      if (parser->m_bufferPtr) {
        memcpy(newBuf, &parser->m_bufferPtr[-keep],
               EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr)
                   + keep);
        FREE(parser, parser->m_buffer);
        parser->m_buffer = newBuf;
        parser->m_bufferEnd
            = parser->m_buffer
              + EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr)
              + keep;
        parser->m_bufferPtr = parser->m_buffer + keep;
      } else {
        /* This must be a brand new buffer with no data in it yet */
        parser->m_bufferEnd = newBuf;
        parser->m_bufferPtr = parser->m_buffer = newBuf;
      }
#else
      if (parser->m_bufferPtr) {
        memcpy(newBuf, parser->m_bufferPtr,
               EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr));
        FREE(parser, parser->m_buffer);
        parser->m_bufferEnd
            = newBuf
              + EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr);
      } else {
        /* This must be a brand new buffer with no data in it yet */
        parser->m_bufferEnd = newBuf;
      }
      parser->m_bufferPtr = parser->m_buffer = newBuf;
#endif /* not defined XML_CONTEXT_BYTES */
    }
    parser->m_eventPtr = parser->m_eventEndPtr = NULL;
    parser->m_positionPtr = NULL;
  }
  return parser->m_bufferEnd;
}","void *VAR_0
XML_GetBuffer(XML_Parser VAR_1, int VAR_2) {
  if (VAR_1 == NULL)
    return NULL;
  if (VAR_2 < 0) {
    VAR_1->m_errorCode = VAR_3;
    return NULL;
  }
  switch (VAR_1->m_parsingStatus.parsing) {
  case VAR_4:
    VAR_1->m_errorCode = VAR_5;
    return NULL;
  case VAR_6:
    VAR_1->m_errorCode = VAR_7;
    return NULL;
  default:;
  }

  if (VAR_2 > EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferLim, VAR_1->m_bufferEnd)) {
#ifdef VAR_8
    int VAR_9;
#endif /* COMMENT_0 */
    /* COMMENT_1 */
    int VAR_10 = (int)((unsigned)VAR_2
                           + (unsigned)EXPAT_SAFE_PTR_DIFF(
                               VAR_1->m_bufferEnd, VAR_1->m_bufferPtr));
    if (VAR_10 < 0) {
      VAR_1->m_errorCode = VAR_3;
      return NULL;
    }
#ifdef VAR_8
    VAR_9 = (int)EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferPtr, VAR_1->m_buffer);
    if (VAR_9 > VAR_8)
      VAR_9 = VAR_8;
    /* COMMENT_2 */
    if (VAR_9 > VAR_11 - VAR_10) {
      VAR_1->m_errorCode = VAR_3;
      return NULL;
    }
    VAR_10 += VAR_9;
#endif /* COMMENT_0 */
    if (VAR_10
        <= EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferLim, VAR_1->m_buffer)) {
#ifdef VAR_8
      if (VAR_9 < EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferPtr, VAR_1->m_buffer)) {
        int VAR_12
            = (int)EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferPtr, VAR_1->m_buffer)
              - VAR_9;
        /* COMMENT_3 */
                           
        memmove(VAR_1->m_buffer, &VAR_1->m_buffer[VAR_12],
                VAR_1->m_bufferEnd - VAR_1->m_bufferPtr + VAR_9);
        VAR_1->m_bufferEnd -= VAR_12;
        VAR_1->m_bufferPtr -= VAR_12;
      }
#else
      if (VAR_1->m_buffer && VAR_1->m_bufferPtr) {
        memmove(VAR_1->m_buffer, VAR_1->m_bufferPtr,
                EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferEnd, VAR_1->m_bufferPtr));
        VAR_1->m_bufferEnd
            = VAR_1->m_buffer
              + EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferEnd, VAR_1->m_bufferPtr);
        VAR_1->m_bufferPtr = VAR_1->m_buffer;
      }
#endif /* COMMENT_5 */
    } else {
      char *VAR_13;
      int VAR_14
          = (int)EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferLim, VAR_1->m_bufferPtr);
      if (VAR_14 == 0)
        VAR_14 = VAR_15;
      do {
        /* COMMENT_1 */
        VAR_14 = (int)(2U * (unsigned)VAR_14);
      } while (VAR_14 < VAR_10 && VAR_14 > 0);
      if (VAR_14 <= 0) {
        VAR_1->m_errorCode = VAR_3;
        return NULL;
      }
      VAR_13 = (char *)MALLOC(VAR_1, VAR_14);
      if (VAR_13 == 0) {
        VAR_1->m_errorCode = VAR_3;
        return NULL;
      }
      VAR_1->m_bufferLim = VAR_13 + VAR_14;
#ifdef VAR_8
      if (VAR_1->m_bufferPtr) {
        memcpy(VAR_13, &VAR_1->m_bufferPtr[-VAR_9],
               EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferEnd, VAR_1->m_bufferPtr)
                   + VAR_9);
        FREE(VAR_1, VAR_1->m_buffer);
        VAR_1->m_buffer = VAR_13;
        VAR_1->m_bufferEnd
            = VAR_1->m_buffer
              + EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferEnd, VAR_1->m_bufferPtr)
              + VAR_9;
        VAR_1->m_bufferPtr = VAR_1->m_buffer + VAR_9;
      } else {
        /* COMMENT_6 */
        VAR_1->m_bufferEnd = VAR_13;
        VAR_1->m_bufferPtr = VAR_1->m_buffer = VAR_13;
      }
#else
      if (VAR_1->m_bufferPtr) {
        memcpy(VAR_13, VAR_1->m_bufferPtr,
               EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferEnd, VAR_1->m_bufferPtr));
        FREE(VAR_1, VAR_1->m_buffer);
        VAR_1->m_bufferEnd
            = VAR_13
              + EXPAT_SAFE_PTR_DIFF(VAR_1->m_bufferEnd, VAR_1->m_bufferPtr);
      } else {
        /* COMMENT_6 */
        VAR_1->m_bufferEnd = VAR_13;
      }
      VAR_1->m_bufferPtr = VAR_1->m_buffer = VAR_13;
#endif /* COMMENT_5 */
    }
    VAR_1->m_eventPtr = VAR_1->m_eventEndPtr = NULL;
    VAR_1->m_positionPtr = NULL;
  }
  return VAR_1->m_bufferEnd;
}",,"--- func_before
+++ func_after
@@ -32,6 +32,11 @@
     keep = (int)EXPAT_SAFE_PTR_DIFF(parser->m_bufferPtr, parser->m_buffer);
     if (keep > XML_CONTEXT_BYTES)
       keep = XML_CONTEXT_BYTES;
+    /* Detect and prevent integer overflow */
+    if (keep > INT_MAX - neededSize) {
+      parser->m_errorCode = XML_ERROR_NO_MEMORY;
+      return NULL;
+    }
     neededSize += keep;
 #endif /* defined XML_CONTEXT_BYTES */
     if (neededSize","{'deleted_lines': [], 'added_lines': ['    /* Detect and prevent integer overflow */', '    if (keep > INT_MAX - neededSize) {', '      parser->m_errorCode = XML_ERROR_NO_MEMORY;', '      return NULL;', '    }']}",True,"Expat (aka libexpat) before 2.4.4 has a signed integer overflow in XML_GetBuffer, for configurations with a nonzero XML_CONTEXT_BYTES.",9.8,CRITICAL,3,test,2022-01-22T16:48:00Z,4
CVE-2022-0361,['CWE-122'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,vim,"patch 8.2.4215: illegal memory access when copying lines in Visual mode

Problem:    Illegal memory access when copying lines in Visual mode.
Solution:   Adjust the Visual position after copying lines.",dc5490e2cbc8c16022a23b449b48c1bd0083f366,https://github.com/vim/vim/commit/dc5490e2cbc8c16022a23b449b48c1bd0083f366,src/ex_cmds.c,ex_copy,"void
ex_copy(linenr_T line1, linenr_T line2, linenr_T n)
{
linenr_Tcount;
char_u*p;
count = line2 - line1 + 1;
if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)
{
curbuf->b_op_start.lnum = n + 1;
curbuf->b_op_end.lnum = n + count;
curbuf->b_op_start.col = curbuf->b_op_end.col = 0;
}
if (u_save(n, n + 1) == FAIL)
return;
curwin->w_cursor.lnum = n;
while (line1 <= line2)
{
p = vim_strsave(ml_get(line1));
if (p != NULL)
{
ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);
vim_free(p);
}
if (line1 == n)
line1 = curwin->w_cursor.lnum;
++line1;
if (curwin->w_cursor.lnum < line1)
++line1;
if (curwin->w_cursor.lnum < line2)
++line2;
++curwin->w_cursor.lnum;
}
appended_lines_mark(n, count);
msgmore((long)count);
}","void
ex_copy(linenr_T VAR_0, linenr_T VAR_1, linenr_T VAR_2)
{
linenr_TVAR_3;
char_u*VAR_4;
VAR_3 = VAR_1 - VAR_0 + 1;
if ((VAR_5.cmod_flags & VAR_6) == 0)
{
VAR_7->b_op_start.lnum = VAR_2 + 1;
VAR_7->b_op_end.lnum = VAR_2 + VAR_3;
VAR_7->b_op_start.col = VAR_7->b_op_end.col = 0;
}
if (u_save(VAR_2, VAR_2 + 1) == VAR_8)
return;
VAR_9->w_cursor.lnum = VAR_2;
while (VAR_0 <= VAR_1)
{
VAR_4 = vim_strsave(ml_get(VAR_0));
if (VAR_4 != NULL)
{
ml_append(VAR_9->w_cursor.lnum, VAR_4, (colnr_T)0, FALSE);
vim_free(VAR_4);
}
if (VAR_0 == VAR_2)
VAR_0 = VAR_9->w_cursor.lnum;
++VAR_0;
if (VAR_9->w_cursor.lnum < VAR_0)
++VAR_0;
if (VAR_9->w_cursor.lnum < VAR_1)
++VAR_1;
++VAR_9->w_cursor.lnum;
}
appended_lines_mark(VAR_2, VAR_3);
msgmore((long)VAR_3);
}",vim/dc5490e2cbc8c16022a23b449b48c1bd0083f366/ex_cmds.c/vul/before/0.json,"void
ex_copy(linenr_T line1, linenr_T line2, linenr_T n)
{
    linenr_T	count;
    char_u	*p;

    count = line2 - line1 + 1;
    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)
    {
	curbuf->b_op_start.lnum = n + 1;
	curbuf->b_op_end.lnum = n + count;
	curbuf->b_op_start.col = curbuf->b_op_end.col = 0;
    }

    /*
     * there are three situations:
     * 1. destination is above line1
     * 2. destination is between line1 and line2
     * 3. destination is below line2
     *
     * n = destination (when starting)
     * curwin->w_cursor.lnum = destination (while copying)
     * line1 = start of source (while copying)
     * line2 = end of source (while copying)
     */
    if (u_save(n, n + 1) == FAIL)
	return;

    curwin->w_cursor.lnum = n;
    while (line1 <= line2)
    {
	// need to use vim_strsave() because the line will be unlocked within
	// ml_append()
	p = vim_strsave(ml_get(line1));
	if (p != NULL)
	{
	    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);
	    vim_free(p);
	}
	// situation 2: skip already copied lines
	if (line1 == n)
	    line1 = curwin->w_cursor.lnum;
	++line1;
	if (curwin->w_cursor.lnum < line1)
	    ++line1;
	if (curwin->w_cursor.lnum < line2)
	    ++line2;
	++curwin->w_cursor.lnum;
    }

    appended_lines_mark(n, count);
    if (VIsual_active)
	check_pos(curbuf, &VIsual);

    msgmore((long)count);
}","void
ex_copy(linenr_T VAR_0, linenr_T VAR_1, linenr_T VAR_2)
{
    linenr_T	VAR_3;
    char_u	*VAR_4;

    VAR_3 = VAR_1 - VAR_0 + 1;
    if ((VAR_5.cmod_flags & VAR_6) == 0)
    {
	VAR_7->b_op_start.lnum = VAR_2 + 1;
	VAR_7->b_op_end.lnum = VAR_2 + VAR_3;
	VAR_7->b_op_start.col = VAR_7->b_op_end.col = 0;
    }

    /* COMMENT_0 */
                                  
                                    
                                                
                                    
      
                                      
                                                          
                                              
                                            
       
    if (u_save(VAR_2, VAR_2 + 1) == VAR_8)
	return;

    VAR_9->w_cursor.lnum = VAR_2;
    while (VAR_0 <= VAR_1)
    {
	/* COMMENT_11 */
	/* COMMENT_12 */
	VAR_4 = vim_strsave(ml_get(VAR_0));
	if (VAR_4 != NULL)
	{
	    ml_append(VAR_9->w_cursor.lnum, VAR_4, (colnr_T)0, FALSE);
	    vim_free(VAR_4);
	}
	/* COMMENT_13 */
	if (VAR_0 == VAR_2)
	    VAR_0 = VAR_9->w_cursor.lnum;
	++VAR_0;
	if (VAR_9->w_cursor.lnum < VAR_0)
	    ++VAR_0;
	if (VAR_9->w_cursor.lnum < VAR_1)
	    ++VAR_1;
	++VAR_9->w_cursor.lnum;
    }

    appended_lines_mark(VAR_2, VAR_3);
    if (VAR_10)
	check_pos(VAR_7, &VAR_11);

    msgmore((long)VAR_3);
}",vim/dc5490e2cbc8c16022a23b449b48c1bd0083f366/ex_cmds.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -49,6 +49,8 @@
     }
 
     appended_lines_mark(n, count);
+    if (VIsual_active)
+	check_pos(curbuf, &VIsual);
 
     msgmore((long)count);
 }","{'deleted_lines': [], 'added_lines': ['    if (VIsual_active)', '\tcheck_pos(curbuf, &VIsual);']}",True,Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.,7.8,HIGH,2,test,2022-01-25T13:52:53Z,4
CVE-2022-1199,['CWE-416'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"ax25: improve the incomplete fix to avoid UAF and NPD bugs

The previous commit 1ade48d0c27d (""ax25: NPD bug when detaching
AX25 device"") introduce lock_sock() into ax25_kill_by_device to
prevent NPD bug. But the concurrency NPD or UAF bug will occur,
when lock_sock() or release_sock() dereferences the ax25_cb->sock.

The NULL pointer dereference bug can be shown as below:

ax25_kill_by_device()        | ax25_release()
                             |   ax25_destroy_socket()
                             |     ax25_cb_del()
  ...                        |     ...
                             |     ax25->sk=NULL;
  lock_sock(s->sk); //(1)    |
  s->ax25_dev = NULL;        |     ...
  release_sock(s->sk); //(2) |
  ...                        |

The root cause is that the sock is set to null before dereference
site (1) or (2). Therefore, this patch extracts the ax25_cb->sock
in advance, and uses ax25_list_lock to protect it, which can synchronize
with ax25_cb_del() and ensure the value of sock is not null before
dereference sites.

The concurrency UAF bug can be shown as below:

ax25_kill_by_device()        | ax25_release()
                             |   ax25_destroy_socket()
  ...                        |   ...
                             |   sock_put(sk); //FREE
  lock_sock(s->sk); //(1)    |
  s->ax25_dev = NULL;        |   ...
  release_sock(s->sk); //(2) |
  ...                        |

The root cause is that the sock is released before dereference
site (1) or (2). Therefore, this patch uses sock_hold() to increase
the refcount of sock and uses ax25_list_lock to protect it, which
can synchronize with ax25_cb_del() in ax25_destroy_socket() and
ensure the sock wil not be released before dereference sites.

Signed-off-by: Duoming Zhou <duoming@zju.edu.cn>
Signed-off-by: David S. Miller <davem@davemloft.net>",4e0f718daf97d47cf7dec122da1be970f145c809,https://github.com/torvalds/linux/commit/4e0f718daf97d47cf7dec122da1be970f145c809,net/ax25/af_ax25.c,ax25_kill_by_device,"static void ax25_kill_by_device(struct net_device *dev)
{
ax25_dev *ax25_dev;
ax25_cb *s;
if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)
return;
spin_lock_bh(&ax25_list_lock);
again:
ax25_for_each(s, &ax25_list) {
if (s->ax25_dev == ax25_dev) {
spin_unlock_bh(&ax25_list_lock);
lock_sock(s->sk);
s->ax25_dev = NULL;
release_sock(s->sk);
ax25_disconnect(s, ENETUNREACH);
spin_lock_bh(&ax25_list_lock);
goto again;
}
}
spin_unlock_bh(&ax25_list_lock);
}","static void ax25_kill_by_device(struct net_device *VAR_0)
{
ax25_dev *ax25_dev;
ax25_cb *VAR_1;
if ((ax25_dev = ax25_dev_ax25dev(VAR_0)) == NULL)
return;
spin_lock_bh(&VAR_2);
again:
ax25_for_each(VAR_1, &VAR_3) {
if (VAR_1->ax25_dev == ax25_dev) {
spin_unlock_bh(&VAR_2);
lock_sock(VAR_1->sk);
VAR_1->ax25_dev = NULL;
release_sock(VAR_1->sk);
ax25_disconnect(VAR_1, VAR_4);
spin_lock_bh(&VAR_2);
goto again;
}
}
spin_unlock_bh(&VAR_2);
}",torvalds/linux/4e0f718daf97d47cf7dec122da1be970f145c809/af_ax25.c/vul/before/0.json,"static void ax25_kill_by_device(struct net_device *dev)
{
	ax25_dev *ax25_dev;
	ax25_cb *s;
	struct sock *sk;

	if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)
		return;

	spin_lock_bh(&ax25_list_lock);
again:
	ax25_for_each(s, &ax25_list) {
		if (s->ax25_dev == ax25_dev) {
			sk = s->sk;
			sock_hold(sk);
			spin_unlock_bh(&ax25_list_lock);
			lock_sock(sk);
			s->ax25_dev = NULL;
			release_sock(sk);
			ax25_disconnect(s, ENETUNREACH);
			spin_lock_bh(&ax25_list_lock);
			sock_put(sk);
			/* The entry could have been deleted from the
			 * list meanwhile and thus the next pointer is
			 * no longer valid.  Play it safe and restart
			 * the scan.  Forward progress is ensured
			 * because we set s->ax25_dev to NULL and we
			 * are never passed a NULL 'dev' argument.
			 */
			goto again;
		}
	}
	spin_unlock_bh(&ax25_list_lock);
}","static void ax25_kill_by_device(struct net_device *VAR_0)
{
	ax25_dev *ax25_dev;
	ax25_cb *VAR_1;
	struct sock *VAR_2;

	if ((ax25_dev = ax25_dev_ax25dev(VAR_0)) == NULL)
		return;

	spin_lock_bh(&VAR_3);
again:
	ax25_for_each(VAR_1, &VAR_4) {
		if (VAR_1->ax25_dev == ax25_dev) {
			VAR_2 = VAR_1->sk;
			sock_hold(VAR_2);
			spin_unlock_bh(&VAR_3);
			lock_sock(VAR_2);
			VAR_1->ax25_dev = NULL;
			release_sock(VAR_2);
			ax25_disconnect(VAR_1, VAR_5);
			spin_lock_bh(&VAR_3);
			sock_put(VAR_2);
			/* COMMENT_0 */
                                                 
                                                
                                            
                                               
                                             
      
			goto again;
		}
	}
	spin_unlock_bh(&VAR_3);
}",torvalds/linux/4e0f718daf97d47cf7dec122da1be970f145c809/af_ax25.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,6 +2,7 @@
 {
 	ax25_dev *ax25_dev;
 	ax25_cb *s;
+	struct sock *sk;
 
 	if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)
 		return;
@@ -10,13 +11,15 @@
 again:
 	ax25_for_each(s, &ax25_list) {
 		if (s->ax25_dev == ax25_dev) {
+			sk = s->sk;
+			sock_hold(sk);
 			spin_unlock_bh(&ax25_list_lock);
-			lock_sock(s->sk);
+			lock_sock(sk);
 			s->ax25_dev = NULL;
-			release_sock(s->sk);
+			release_sock(sk);
 			ax25_disconnect(s, ENETUNREACH);
 			spin_lock_bh(&ax25_list_lock);
-
+			sock_put(sk);
 			/* The entry could have been deleted from the
 			 * list meanwhile and thus the next pointer is
 			 * no longer valid.  Play it safe and restart","{'deleted_lines': ['\t\t\tlock_sock(s->sk);', '\t\t\trelease_sock(s->sk);', ''], 'added_lines': ['\tstruct sock *sk;', '\t\t\tsk = s->sk;', '\t\t\tsock_hold(sk);', '\t\t\tlock_sock(sk);', '\t\t\trelease_sock(sk);', '\t\t\tsock_put(sk);']}",True,"A flaw was found in the Linux kernel. This flaw allows an attacker to crash the Linux kernel by simulating amateur radio from the user space, resulting in a null-ptr-deref vulnerability and a use-after-free vulnerability.",7.5,HIGH,2,test,2022-01-28T04:47:15Z,4
CVE-2022-0481,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,mruby,codegen.c: fixed a bug in hash code generation with `!val`.,ae3c99767a27f5c6c584162e2adc6a5d0eb2c54e,https://github.com/mruby/mruby/commit/ae3c99767a27f5c6c584162e2adc6a5d0eb2c54e,mrbgems/mruby-compiler/core/codegen.c,gen_hash,"static int
gen_hash(codegen_scope *s, node *tree, int val, int limit)
{
int slimit = GEN_VAL_STACK_MAX;
if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;
int len = 0;
mrb_bool update = FALSE;
while (tree) {
if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {
if (len > 0) {
pop_n(len*2);
if (!update) {
genop_2(s, OP_HASH, cursp(), len);
}
else {
pop();
genop_2(s, OP_HASHADD, cursp(), len);
}
push();
}
codegen(s, tree->car->cdr, val);
if (len > 0 || update) {
pop(); pop();
genop_1(s, OP_HASHCAT, cursp());
push();
}
update = TRUE;
len = 0;
}
else {
codegen(s, tree->car->car, val);
codegen(s, tree->car->cdr, val);
len++;
}
tree = tree->cdr;
if (val && cursp() >= slimit) {
pop_n(len*2);
if (!update) {
genop_2(s, OP_HASH, cursp(), len);
}
else {
pop();
genop_2(s, OP_HASHADD, cursp(), len);
}
push();
update = TRUE;
len = 0;
}
}
if (update) {
if (val && len > 0) {
pop_n(len*2+1);
genop_2(s, OP_HASHADD, cursp(), len);
push();
}
return -1;                  
}
return len;
}","static int
gen_hash(codegen_scope *VAR_0, node *VAR_1, int VAR_2, int VAR_3)
{
int VAR_4 = VAR_5;
if (cursp() >= VAR_6) VAR_4 = VAR_7;
int VAR_8 = 0;
mrb_bool VAR_9 = FALSE;
while (VAR_1) {
if (nint(VAR_1->car->car->car) == VAR_10) {
if (VAR_8 > 0) {
pop_n(VAR_8*2);
if (!VAR_9) {
genop_2(VAR_0, VAR_11, cursp(), VAR_8);
}
else {
pop();
genop_2(VAR_0, VAR_12, cursp(), VAR_8);
}
push();
}
codegen(VAR_0, VAR_1->car->cdr, VAR_2);
if (VAR_8 > 0 || VAR_9) {
pop(); pop();
genop_1(VAR_0, VAR_13, cursp());
push();
}
VAR_9 = TRUE;
VAR_8 = 0;
}
else {
codegen(VAR_0, VAR_1->car->car, VAR_2);
codegen(VAR_0, VAR_1->car->cdr, VAR_2);
VAR_8++;
}
VAR_1 = VAR_1->cdr;
if (VAR_2 && cursp() >= VAR_4) {
pop_n(VAR_8*2);
if (!VAR_9) {
genop_2(VAR_0, VAR_11, cursp(), VAR_8);
}
else {
pop();
genop_2(VAR_0, VAR_12, cursp(), VAR_8);
}
push();
VAR_9 = TRUE;
VAR_8 = 0;
}
}
if (VAR_9) {
if (VAR_2 && VAR_8 > 0) {
pop_n(VAR_8*2+1);
genop_2(VAR_0, VAR_12, cursp(), VAR_8);
push();
}
return -1;                  
}
return VAR_8;
}",mruby/ae3c99767a27f5c6c584162e2adc6a5d0eb2c54e/codegen.c/vul/before/0.json,"static int
gen_hash(codegen_scope *s, node *tree, int val, int limit)
{
  int slimit = GEN_VAL_STACK_MAX;
  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;
  int len = 0;
  mrb_bool update = FALSE;

  while (tree) {
    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {
      if (val && len > 0) {
        pop_n(len*2);
        if (!update) {
          genop_2(s, OP_HASH, cursp(), len);
        }
        else {
          pop();
          genop_2(s, OP_HASHADD, cursp(), len);
        }
        push();
      }
      codegen(s, tree->car->cdr, val);
      if (val && (len > 0 || update)) {
        pop(); pop();
        genop_1(s, OP_HASHCAT, cursp());
        push();
      }
      update = TRUE;
      len = 0;
    }
    else {
      codegen(s, tree->car->car, val);
      codegen(s, tree->car->cdr, val);
      len++;
    }
    tree = tree->cdr;
    if (val && cursp() >= slimit) {
      pop_n(len*2);
      if (!update) {
        genop_2(s, OP_HASH, cursp(), len);
      }
      else {
        pop();
        genop_2(s, OP_HASHADD, cursp(), len);
      }
      push();
      update = TRUE;
      len = 0;
    }
  }
  if (update) {
    if (val && len > 0) {
      pop_n(len*2+1);
      genop_2(s, OP_HASHADD, cursp(), len);
      push();
    }
    return -1;                  /* variable length */
  }
  return len;
}","static int
gen_hash(codegen_scope *VAR_0, node *VAR_1, int VAR_2, int VAR_3)
{
  int VAR_4 = VAR_5;
  if (cursp() >= VAR_6) VAR_4 = VAR_7;
  int VAR_8 = 0;
  mrb_bool VAR_9 = FALSE;

  while (VAR_1) {
    if (nint(VAR_1->car->car->car) == VAR_10) {
      if (VAR_2 && VAR_8 > 0) {
        pop_n(VAR_8*2);
        if (!VAR_9) {
          genop_2(VAR_0, VAR_11, cursp(), VAR_8);
        }
        else {
          pop();
          genop_2(VAR_0, VAR_12, cursp(), VAR_8);
        }
        push();
      }
      codegen(VAR_0, VAR_1->car->cdr, VAR_2);
      if (VAR_2 && (VAR_8 > 0 || VAR_9)) {
        pop(); pop();
        genop_1(VAR_0, VAR_13, cursp());
        push();
      }
      VAR_9 = TRUE;
      VAR_8 = 0;
    }
    else {
      codegen(VAR_0, VAR_1->car->car, VAR_2);
      codegen(VAR_0, VAR_1->car->cdr, VAR_2);
      VAR_8++;
    }
    VAR_1 = VAR_1->cdr;
    if (VAR_2 && cursp() >= VAR_4) {
      pop_n(VAR_8*2);
      if (!VAR_9) {
        genop_2(VAR_0, VAR_11, cursp(), VAR_8);
      }
      else {
        pop();
        genop_2(VAR_0, VAR_12, cursp(), VAR_8);
      }
      push();
      VAR_9 = TRUE;
      VAR_8 = 0;
    }
  }
  if (VAR_9) {
    if (VAR_2 && VAR_8 > 0) {
      pop_n(VAR_8*2+1);
      genop_2(VAR_0, VAR_12, cursp(), VAR_8);
      push();
    }
    return -1;                  /* COMMENT_0 */
  }
  return VAR_8;
}",mruby/ae3c99767a27f5c6c584162e2adc6a5d0eb2c54e/codegen.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,7 +8,7 @@
 
   while (tree) {
     if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {
-      if (len > 0) {
+      if (val && len > 0) {
         pop_n(len*2);
         if (!update) {
           genop_2(s, OP_HASH, cursp(), len);
@@ -20,7 +20,7 @@
         push();
       }
       codegen(s, tree->car->cdr, val);
-      if (len > 0 || update) {
+      if (val && (len > 0 || update)) {
         pop(); pop();
         genop_1(s, OP_HASHCAT, cursp());
         push();","{'deleted_lines': ['      if (len > 0) {', '      if (len > 0 || update) {'], 'added_lines': ['      if (val && len > 0) {', '      if (val && (len > 0 || update)) {']}",True,NULL Pointer Dereference in Homebrew mruby prior to 3.2.,7.5,HIGH,2,test,2022-02-03T01:40:05Z,4
CVE-2022-41859,['CWE-522'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N,1,FreeRADIUS/freeradius-server,"port fixes from master

via the simple expedient of copying the entire function, with
some minor changes to work in v3",9e5e8f2f,https://github.com/FreeRADIUS/freeradius-server/commit/9e5e8f2f912ad2da8ac6e176ac3a606333469937,src/modules/rlm_eap/types/rlm_eap_pwd/eap_pwd.c,compute_password_element,"int compute_password_element (REQUEST *request, pwd_session_t *session, uint16_t grp_num,
char const *password, int password_len,
char const *id_server, int id_server_len,
char const *id_peer, int id_peer_len,
uint32_t *token)
{
BIGNUM *x_candidate = NULL, *rnd = NULL, *y_sqrd = NULL, *qr = NULL, *qnr = NULL;
HMAC_CTX *ctx = NULL;
uint8_t pwe_digest[SHA256_DIGEST_LENGTH], *prfbuf = NULL, *xbuf = NULL, *pm1buf = NULL, ctr;
int nid, is_odd, primebitlen, primebytelen, ret = 0, found = 0, mask;
int save, i, rbits, qr_or_qnr, save_is_odd = 0, cmp;
unsigned int skip;
ctx = HMAC_CTX_new();
if (ctx == NULL) {
DEBUG(""failed allocating HMAC context"");
goto fail;
}
switch (grp_num) { 
case 19:
nid = NID_X9_62_prime256v1;
break;
case 20:
nid = NID_secp384r1;
break;
case 21:
nid = NID_secp521r1;
break;
case 25:
nid = NID_X9_62_prime192v1;
break;
case 26:
nid = NID_secp224r1;
break;
default:
DEBUG(""unknown group %d"", grp_num);
goto fail;
}
session->pwe = NULL;
session->order = NULL;
session->prime = NULL;
if ((session->group = EC_GROUP_new_by_curve_name(nid)) == NULL) {
DEBUG(""unable to create EC_GROUP"");
goto fail;
}
if (((rnd = consttime_BN()) == NULL) ||
((session->pwe = EC_POINT_new(session->group)) == NULL) ||
((session->order = consttime_BN()) == NULL) ||
((session->prime = consttime_BN()) == NULL) ||
((qr = consttime_BN()) == NULL) ||
((qnr = consttime_BN()) == NULL) ||
((x_candidate = consttime_BN()) == NULL) ||
((y_sqrd = consttime_BN()) == NULL)) {
DEBUG(""unable to create bignums"");
goto fail;
}
if (!EC_GROUP_get_curve(session->group, session->prime, NULL, NULL, NULL)) {
DEBUG(""unable to get prime for GFp curve"");
goto fail;
}
if (!EC_GROUP_get_order(session->group, session->order, NULL)) {
DEBUG(""unable to get order for curve"");
goto fail;
}
primebitlen = BN_num_bits(session->prime);
primebytelen = BN_num_bytes(session->prime);
if ((prfbuf = talloc_zero_array(session, uint8_t, primebytelen)) == NULL) {
DEBUG(""unable to alloc space for prf buffer"");
goto fail;
}
if ((xbuf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {
DEBUG(""unable to alloc space for x buffer"");
goto fail;
}
if ((pm1buf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {
DEBUG(""unable to alloc space for pm1 buffer"");
goto fail;
}
do {
BN_rand_range(qr, session->prime);
} while (legendre(qr, session->prime, session->bnctx) != 1);
do {
BN_rand_range(qnr, session->prime);
} while (legendre(qnr, session->prime, session->bnctx) != -1);
if (!BN_sub(rnd, session->prime, BN_value_one())) {
goto fail;
}
BN_bn2bin(rnd, pm1buf);
save_is_odd = 0;
found = 0;
memset(xbuf, 0, primebytelen);
ctr = 0;
while (ctr < 40) {
ctr++;
HMAC_Init_ex(ctx, allzero, SHA256_DIGEST_LENGTH, EVP_sha256(),NULL);
HMAC_Update(ctx, (uint8_t *)token, sizeof(*token));
HMAC_Update(ctx, (uint8_t const *)id_peer, id_peer_len);
HMAC_Update(ctx, (uint8_t const *)id_server, id_server_len);
HMAC_Update(ctx, (uint8_t const *)password, password_len);
HMAC_Update(ctx, (uint8_t *)&ctr, sizeof(ctr));
pwd_hmac_final(ctx, pwe_digest);
BN_bin2bn(pwe_digest, SHA256_DIGEST_LENGTH, rnd);
eap_pwd_kdf(pwe_digest, SHA256_DIGEST_LENGTH, ""EAP-pwd Hunting And Pecking"",
strlen(""EAP-pwd Hunting And Pecking""), prfbuf, primebitlen);
if (primebitlen % 8) {
rbits = 8 - (primebitlen % 8);
for (i = primebytelen - 1; i > 0; i--) {
prfbuf[i] = (prfbuf[i - 1] << (8 - rbits)) | (prfbuf[i] >> rbits);
}
prfbuf[0] >>= rbits;
}
BN_bin2bn(prfbuf, primebytelen, x_candidate);
cmp = const_time_memcmp(pm1buf, prfbuf, primebytelen);
skip = const_time_fill_msb((unsigned int)cmp);
is_odd = BN_is_odd(rnd) ? 1 : 0;
do_equation(session->group, y_sqrd, x_candidate, session->bnctx);
qr_or_qnr = is_quadratic_residue(y_sqrd, session->prime, qr, qnr, session->bnctx);
qr_or_qnr = const_time_select(skip, 0, qr_or_qnr);
mask = const_time_select(found, 0, -1);
save = const_time_select(mask, qr_or_qnr, 0);
mask = const_time_eq(save, 1);
const_time_select_bin(mask, prfbuf, xbuf, primebytelen, xbuf);
save_is_odd = const_time_select(mask, is_odd, save_is_odd);
found = const_time_select(mask, -1, found);
}
BN_bin2bn(xbuf, primebytelen, x_candidate);
if (!EC_POINT_set_compressed_coordinates(session->group, session->pwe,
x_candidate, save_is_odd, NULL)) {
goto fail;
}
session->group_num = grp_num;
if (0) {
fail:
ret = -1;
}
BN_clear_free(x_candidate);
BN_clear_free(y_sqrd);
BN_clear_free(qr);
BN_clear_free(qnr);
BN_clear_free(rnd);
if (prfbuf) talloc_free(prfbuf);
if (xbuf) talloc_free(xbuf);
if (pm1buf) talloc_free(pm1buf);
HMAC_CTX_free(ctx);
return ret;
}","int compute_password_element (REQUEST *VAR_0, pwd_session_t *VAR_1, uint16_t VAR_2,
char const *VAR_3, int VAR_4,
char const *VAR_5, int VAR_6,
char const *VAR_7, int VAR_8,
uint32_t *VAR_9)
{
BIGNUM *VAR_10 = NULL, *VAR_11 = NULL, *VAR_12 = NULL, *VAR_13 = NULL, *VAR_14 = NULL;
HMAC_CTX *VAR_15 = NULL;
uint8_t VAR_16[VAR_17], *VAR_18 = NULL, *VAR_19 = NULL, *VAR_20 = NULL, VAR_21;
int VAR_22, VAR_23, VAR_24, VAR_25, VAR_26 = 0, VAR_27 = 0, VAR_28;
int VAR_29, VAR_30, VAR_31, VAR_32, VAR_33 = 0, VAR_34;
unsigned int VAR_35;
VAR_15 = HMAC_CTX_new();
if (VAR_15 == NULL) {
DEBUG(""failed allocating HMAC context"");
goto fail;
}
switch (VAR_2) { 
case 19:
VAR_22 = VAR_36;
break;
case 20:
VAR_22 = VAR_37;
break;
case 21:
VAR_22 = VAR_38;
break;
case 25:
VAR_22 = VAR_39;
break;
case 26:
VAR_22 = VAR_40;
break;
default:
DEBUG(""unknown group %d"", VAR_2);
goto fail;
}
VAR_1->pwe = NULL;
VAR_1->order = NULL;
VAR_1->prime = NULL;
if ((VAR_1->group = EC_GROUP_new_by_curve_name(VAR_22)) == NULL) {
DEBUG(""unable to create EC_GROUP"");
goto fail;
}
if (((VAR_11 = consttime_BN()) == NULL) ||
((VAR_1->pwe = EC_POINT_new(VAR_1->group)) == NULL) ||
((VAR_1->order = consttime_BN()) == NULL) ||
((VAR_1->prime = consttime_BN()) == NULL) ||
((VAR_13 = consttime_BN()) == NULL) ||
((VAR_14 = consttime_BN()) == NULL) ||
((VAR_10 = consttime_BN()) == NULL) ||
((VAR_12 = consttime_BN()) == NULL)) {
DEBUG(""unable to create bignums"");
goto fail;
}
if (!EC_GROUP_get_curve(VAR_1->group, VAR_1->prime, NULL, NULL, NULL)) {
DEBUG(""unable to get prime for GFp curve"");
goto fail;
}
if (!EC_GROUP_get_order(VAR_1->group, VAR_1->order, NULL)) {
DEBUG(""unable to get order for curve"");
goto fail;
}
VAR_24 = BN_num_bits(VAR_1->prime);
VAR_25 = BN_num_bytes(VAR_1->prime);
if ((VAR_18 = talloc_zero_array(VAR_1, uint8_t, VAR_25)) == NULL) {
DEBUG(""unable to alloc space for prf buffer"");
goto fail;
}
if ((VAR_19 = talloc_zero_array(VAR_0, uint8_t, VAR_25)) == NULL) {
DEBUG(""unable to alloc space for x buffer"");
goto fail;
}
if ((VAR_20 = talloc_zero_array(VAR_0, uint8_t, VAR_25)) == NULL) {
DEBUG(""unable to alloc space for pm1 buffer"");
goto fail;
}
do {
BN_rand_range(VAR_13, VAR_1->prime);
} while (legendre(VAR_13, VAR_1->prime, VAR_1->bnctx) != 1);
do {
BN_rand_range(VAR_14, VAR_1->prime);
} while (legendre(VAR_14, VAR_1->prime, VAR_1->bnctx) != -1);
if (!BN_sub(VAR_11, VAR_1->prime, BN_value_one())) {
goto fail;
}
BN_bn2bin(VAR_11, VAR_20);
VAR_33 = 0;
VAR_27 = 0;
memset(VAR_19, 0, VAR_25);
VAR_21 = 0;
while (VAR_21 < 40) {
VAR_21++;
HMAC_Init_ex(VAR_15, VAR_41, VAR_17, EVP_sha256(),NULL);
HMAC_Update(VAR_15, (uint8_t *)VAR_9, sizeof(*VAR_9));
HMAC_Update(VAR_15, (uint8_t const *)VAR_7, VAR_8);
HMAC_Update(VAR_15, (uint8_t const *)VAR_5, VAR_6);
HMAC_Update(VAR_15, (uint8_t const *)VAR_3, VAR_4);
HMAC_Update(VAR_15, (uint8_t *)&VAR_21, sizeof(VAR_21));
pwd_hmac_final(VAR_15, VAR_16);
BN_bin2bn(VAR_16, VAR_17, VAR_11);
eap_pwd_kdf(VAR_16, VAR_17, ""EAP-pwd Hunting And Pecking"",
strlen(""EAP-pwd Hunting And Pecking""), VAR_18, VAR_24);
if (VAR_24 % 8) {
VAR_31 = 8 - (VAR_24 % 8);
for (VAR_30 = VAR_25 - 1; VAR_30 > 0; VAR_30--) {
VAR_18[VAR_30] = (VAR_18[VAR_30 - 1] << (8 - VAR_31)) | (VAR_18[VAR_30] >> VAR_31);
}
VAR_18[0] >>= VAR_31;
}
BN_bin2bn(VAR_18, VAR_25, VAR_10);
VAR_34 = const_time_memcmp(VAR_20, VAR_18, VAR_25);
VAR_35 = const_time_fill_msb((unsigned int)VAR_34);
VAR_23 = BN_is_odd(VAR_11) ? 1 : 0;
do_equation(VAR_1->group, VAR_12, VAR_10, VAR_1->bnctx);
VAR_32 = is_quadratic_residue(VAR_12, VAR_1->prime, VAR_13, VAR_14, VAR_1->bnctx);
VAR_32 = const_time_select(VAR_35, 0, VAR_32);
VAR_28 = const_time_select(VAR_27, 0, -1);
VAR_29 = const_time_select(VAR_28, VAR_32, 0);
VAR_28 = const_time_eq(VAR_29, 1);
const_time_select_bin(VAR_28, VAR_18, VAR_19, VAR_25, VAR_19);
VAR_33 = const_time_select(VAR_28, VAR_23, VAR_33);
VAR_27 = const_time_select(VAR_28, -1, VAR_27);
}
BN_bin2bn(VAR_19, VAR_25, VAR_10);
if (!EC_POINT_set_compressed_coordinates(VAR_1->group, VAR_1->pwe,
VAR_10, VAR_33, NULL)) {
goto fail;
}
VAR_1->group_num = VAR_2;
if (0) {
fail:
VAR_26 = -1;
}
BN_clear_free(VAR_10);
BN_clear_free(VAR_12);
BN_clear_free(VAR_13);
BN_clear_free(VAR_14);
BN_clear_free(VAR_11);
if (VAR_18) talloc_free(VAR_18);
if (VAR_19) talloc_free(VAR_19);
if (VAR_20) talloc_free(VAR_20);
HMAC_CTX_free(VAR_15);
return VAR_26;
}",FreeRADIUS/freeradius-server/9e5e8f2f/eap_pwd.c/vul/before/0.json,"int compute_password_element (REQUEST *request, pwd_session_t *session, uint16_t grp_num,
			      char const *password, int password_len,
			      char const *id_server, int id_server_len,
			      char const *id_peer, int id_peer_len,
			      uint32_t *token)
{
	BIGNUM		*x_candidate = NULL, *rnd = NULL, *y_sqrd = NULL, *qr = NULL, *qnr = NULL, *y1 = NULL, *y2 = NULL, *y = NULL, *exp = NULL;
	EVP_MD_CTX	*hmac_ctx;
	EVP_PKEY	*hmac_pkey;
	uint8_t		pwe_digest[SHA256_DIGEST_LENGTH], *prfbuf = NULL, *xbuf = NULL, *pm1buf = NULL, *y1buf = NULL, *y2buf = NULL, *ybuf = NULL, ctr;
	int		nid, is_odd, primebitlen, primebytelen, ret = 0, found = 0, mask;
	int		save, i, rbits, qr_or_qnr, save_is_odd = 0, cmp;
	unsigned int	skip;

	MEM(hmac_ctx = EVP_MD_CTX_new());
	MEM(hmac_pkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, allzero, sizeof(allzero)));

	switch (grp_num) { /* from IANA registry for IKE D-H groups */
	case 19:
		nid = NID_X9_62_prime256v1;
		break;

	case 20:
		nid = NID_secp384r1;
		break;

	case 21:
		nid = NID_secp521r1;
		break;

	case 25:
		nid = NID_X9_62_prime192v1;
		break;

	case 26:
		nid = NID_secp224r1;
		break;

	default:
		DEBUG(""unknown group %d"", grp_num);
		goto fail;
	}

	session->pwe = NULL;
	session->order = NULL;
	session->prime = NULL;

	if ((session->group = EC_GROUP_new_by_curve_name(nid)) == NULL) {
		DEBUG(""unable to create EC_GROUP"");
		goto fail;
	}

	if (((rnd = consttime_BN()) == NULL) ||
	    ((session->pwe = EC_POINT_new(session->group)) == NULL) ||
	    ((session->order = consttime_BN()) == NULL) ||
	    ((session->prime = consttime_BN()) == NULL) ||
	    ((qr = consttime_BN()) == NULL) ||
	    ((qnr = consttime_BN()) == NULL) ||
	    ((x_candidate = consttime_BN()) == NULL) ||
	    ((y_sqrd = consttime_BN()) == NULL) ||
	    ((y1 = consttime_BN()) == NULL) ||
	    ((y2 = consttime_BN()) == NULL) ||
	    ((y = consttime_BN()) == NULL) ||
        ((exp = consttime_BN()) == NULL)) {
		DEBUG(""unable to create bignums"");
		goto fail;
	}

	if (!EC_GROUP_get_curve(session->group, session->prime, NULL, NULL, NULL)) {
		DEBUG(""unable to get prime for GFp curve"");
		goto fail;
	}

	if (!EC_GROUP_get_order(session->group, session->order, NULL)) {
		DEBUG(""unable to get order for curve"");
		goto fail;
	}

	primebitlen = BN_num_bits(session->prime);
	primebytelen = BN_num_bytes(session->prime);
	if ((prfbuf = talloc_zero_array(session, uint8_t, primebytelen)) == NULL) {
		DEBUG(""unable to alloc space for prf buffer"");
		goto fail;
	}
	if ((xbuf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {
		DEBUG(""unable to alloc space for x buffer"");
		goto fail;
	}
	if ((pm1buf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {
		DEBUG(""unable to alloc space for pm1 buffer"");
		goto fail;
	}
	if ((y1buf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {
		DEBUG(""unable to alloc space for y1 buffer"");
		goto fail;
	}
	if ((y2buf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {
		DEBUG(""unable to alloc space for y2 buffer"");
		goto fail;
	}
	if ((ybuf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {
		DEBUG(""unable to alloc space for y buffer"");
		goto fail;
	}


	/*
	* derive random quadradic residue and quadratic non-residue
	*/
	do {
		BN_rand_range(qr, session->prime);
	} while (legendre(qr, session->prime, session->bnctx) != 1);

	do {
		BN_rand_range(qnr, session->prime);
	} while (legendre(qnr, session->prime, session->bnctx) != -1);

	if (!BN_sub(rnd, session->prime, BN_value_one())) {
		goto fail;
	}
	BN_bn2bin(rnd, pm1buf);

	save_is_odd = 0;
	found = 0;
	memset(xbuf, 0, primebytelen);
	ctr = 0;
	while (ctr < 40) {
		ctr++;

		/*
		 * compute counter-mode password value and stretch to prime
		 *	pwd-seed = H(token | peer-id | server-id | password |
		 *		     counter)
		 */
		EVP_DigestSignInit(hmac_ctx, NULL, EVP_sha256(), NULL, hmac_pkey);
		EVP_DigestSignUpdate(hmac_ctx, (uint8_t *)token, sizeof(*token));
		EVP_DigestSignUpdate(hmac_ctx, (uint8_t const *)id_peer, id_peer_len);
		EVP_DigestSignUpdate(hmac_ctx, (uint8_t const *)id_server, id_server_len);
		EVP_DigestSignUpdate(hmac_ctx, (uint8_t const *)password, password_len);
		EVP_DigestSignUpdate(hmac_ctx, (uint8_t *)&ctr, sizeof(ctr));

		{
			size_t mdlen = SHA256_DIGEST_LENGTH;

			EVP_DigestSignFinal(hmac_ctx, pwe_digest, &mdlen);
			EVP_MD_CTX_reset(hmac_ctx);
		}

		BN_bin2bn(pwe_digest, SHA256_DIGEST_LENGTH, rnd);
		eap_pwd_kdf(pwe_digest, SHA256_DIGEST_LENGTH, ""EAP-pwd Hunting And Pecking"",
			    strlen(""EAP-pwd Hunting And Pecking""), prfbuf, primebitlen);

		/*
		 * eap_pwd_kdf() returns a string of bits 0..primebitlen but
		 * BN_bin2bn will treat that string of bits as a big endian
		 * number. If the primebitlen is not an even multiple of 8
		 * then excessive bits-- those _after_ primebitlen-- so now
		 * we have to shift right the amount we masked off.
		 */
		if (primebitlen % 8) {
			rbits = 8 - (primebitlen % 8);
			for (i = primebytelen - 1; i > 0; i--) {
				prfbuf[i] = (prfbuf[i - 1] << (8 - rbits)) | (prfbuf[i] >> rbits);
			}
			prfbuf[0] >>= rbits;
		}
		BN_bin2bn(prfbuf, primebytelen, x_candidate);

		/*
		* it would've been better if the spec reduced the candidate
		* modulo the prime but it didn't. So if the candidate >= prime
		* we need to skip it but still run through the operations below
		*/
		cmp = const_time_memcmp(pm1buf, prfbuf, primebytelen);
		skip = const_time_fill_msb((unsigned int)cmp);

		/*
		* need to unambiguously identify the solution, if there is
		* one..
		*/
		is_odd = BN_is_odd(rnd);

		/*
		* check whether x^3 + a*x + b is a quadratic residue
		*
		* save the first quadratic residue we find in the loop but do
		* it in constant time.
		*/
		do_equation(session->group, y_sqrd, x_candidate, session->bnctx);
		qr_or_qnr = is_quadratic_residue(y_sqrd, session->prime, qr, qnr, session->bnctx);

		/*
		* if the candidate >= prime then we want to skip it
		*/
		qr_or_qnr = const_time_select(skip, 0, qr_or_qnr);

		/*
		* if we haven't found PWE yet (found = 0) then mask will be true,
		* if we have found PWE then mask will be false
		*/
		mask = const_time_select(found, 0, -1);

		/*
		* save will be 1 if we want to save this value-- i.e. we haven't
		* found PWE yet and this is a quadratic residue-- and 0 otherwise
		*/
		save = const_time_select(mask, qr_or_qnr, 0);

		/*
		* mask will be true (-1) if we want to save this and false (0)
		* otherwise
		*/
		mask = const_time_eq(save, 1);

		const_time_select_bin(mask, prfbuf, xbuf, primebytelen, xbuf);
		save_is_odd = const_time_select(mask, is_odd, save_is_odd);
		found = const_time_select(mask, -1, found);
	}

	/*
	* now we can savely construct PWE
	*/
	BN_bin2bn(xbuf, primebytelen, x_candidate);
	do_equation(session->group, y_sqrd, x_candidate, session->bnctx);
	if ( !BN_add(exp, session->prime, BN_value_one()) ||
		 !BN_rshift(exp, exp, 2) ||
		 !BN_mod_exp_mont_consttime(y1, y_sqrd, exp, session->prime, session->bnctx, NULL) ||
		 !BN_sub(y2, session->prime, y1) ||
		 !BN_bn2bin(y1, y1buf) ||
		 !BN_bn2bin(y2, y2buf)) {
		DEBUG(""unable to compute y"");
		goto fail;
	}
	mask = const_time_eq(save_is_odd, BN_is_odd(y1));
	const_time_select_bin(mask, y1buf, y2buf, primebytelen, ybuf);
	if (BN_bin2bn(ybuf, primebytelen, y) == NULL ||
		!EC_POINT_set_affine_coordinates(session->group, session->pwe, x_candidate, y, session->bnctx)) {
		DEBUG(""unable to set point coordinate"");
		goto fail;
	}

	session->group_num = grp_num;
	if (0) {
		fail:		/* DON'T free session, it's in handler->opaque */
		ret = -1;
	}

	/* cleanliness and order.... */
	BN_clear_free(x_candidate);
	BN_clear_free(y_sqrd);
	BN_clear_free(qr);
	BN_clear_free(qnr);
	BN_clear_free(rnd);
	BN_clear_free(y1);
	BN_clear_free(y2);
	BN_clear_free(y);
	BN_clear_free(exp);

	if (prfbuf) talloc_free(prfbuf);
	if (xbuf) talloc_free(xbuf);
	if (pm1buf) talloc_free(pm1buf);
	if (y1buf) talloc_free(y1buf);
	if (y2buf) talloc_free(y2buf);
	if (ybuf) talloc_free(ybuf);

	EVP_MD_CTX_free(hmac_ctx);
	EVP_PKEY_free(hmac_pkey);

	return ret;
}","int compute_password_element (REQUEST *VAR_0, pwd_session_t *VAR_1, uint16_t VAR_2,
			      char const *VAR_3, int VAR_4,
			      char const *VAR_5, int VAR_6,
			      char const *VAR_7, int VAR_8,
			      uint32_t *VAR_9)
{
	BIGNUM		*VAR_10 = NULL, *VAR_11 = NULL, *VAR_12 = NULL, *VAR_13 = NULL, *VAR_14 = NULL, *VAR_15 = NULL, *VAR_16 = NULL, *VAR_17 = NULL, *VAR_18 = NULL;
	EVP_MD_CTX	*VAR_19;
	EVP_PKEY	*VAR_20;
	uint8_t		VAR_21[VAR_22], *VAR_23 = NULL, *VAR_24 = NULL, *VAR_25 = NULL, *VAR_26 = NULL, *VAR_27 = NULL, *VAR_28 = NULL, VAR_29;
	int		VAR_30, VAR_31, VAR_32, VAR_33, VAR_34 = 0, VAR_35 = 0, VAR_36;
	int		VAR_37, VAR_38, VAR_39, VAR_40, VAR_41 = 0, VAR_42;
	unsigned int	VAR_43;

	MEM(VAR_19 = EVP_MD_CTX_new());
	MEM(VAR_20 = EVP_PKEY_new_mac_key(VAR_44, NULL, VAR_45, sizeof(VAR_45)));

	switch (VAR_2) { /* COMMENT_0 */
	case 19:
		VAR_30 = VAR_46;
		break;

	case 20:
		VAR_30 = VAR_47;
		break;

	case 21:
		VAR_30 = VAR_48;
		break;

	case 25:
		VAR_30 = VAR_49;
		break;

	case 26:
		VAR_30 = VAR_50;
		break;

	default:
		DEBUG(""unknown group %d"", VAR_2);
		goto fail;
	}

	VAR_1->pwe = NULL;
	VAR_1->order = NULL;
	VAR_1->prime = NULL;

	if ((VAR_1->group = EC_GROUP_new_by_curve_name(VAR_30)) == NULL) {
		DEBUG(""unable to create EC_GROUP"");
		goto fail;
	}

	if (((VAR_11 = consttime_BN()) == NULL) ||
	    ((VAR_1->pwe = EC_POINT_new(VAR_1->group)) == NULL) ||
	    ((VAR_1->order = consttime_BN()) == NULL) ||
	    ((VAR_1->prime = consttime_BN()) == NULL) ||
	    ((VAR_13 = consttime_BN()) == NULL) ||
	    ((VAR_14 = consttime_BN()) == NULL) ||
	    ((VAR_10 = consttime_BN()) == NULL) ||
	    ((VAR_12 = consttime_BN()) == NULL) ||
	    ((VAR_15 = consttime_BN()) == NULL) ||
	    ((VAR_16 = consttime_BN()) == NULL) ||
	    ((VAR_17 = consttime_BN()) == NULL) ||
        ((VAR_18 = consttime_BN()) == NULL)) {
		DEBUG(""unable to create bignums"");
		goto fail;
	}

	if (!EC_GROUP_get_curve(VAR_1->group, VAR_1->prime, NULL, NULL, NULL)) {
		DEBUG(""unable to get prime for GFp curve"");
		goto fail;
	}

	if (!EC_GROUP_get_order(VAR_1->group, VAR_1->order, NULL)) {
		DEBUG(""unable to get order for curve"");
		goto fail;
	}

	VAR_32 = BN_num_bits(VAR_1->prime);
	VAR_33 = BN_num_bytes(VAR_1->prime);
	if ((VAR_23 = talloc_zero_array(VAR_1, uint8_t, VAR_33)) == NULL) {
		DEBUG(""unable to alloc space for prf buffer"");
		goto fail;
	}
	if ((VAR_24 = talloc_zero_array(VAR_0, uint8_t, VAR_33)) == NULL) {
		DEBUG(""unable to alloc space for x buffer"");
		goto fail;
	}
	if ((VAR_25 = talloc_zero_array(VAR_0, uint8_t, VAR_33)) == NULL) {
		DEBUG(""unable to alloc space for pm1 buffer"");
		goto fail;
	}
	if ((VAR_26 = talloc_zero_array(VAR_0, uint8_t, VAR_33)) == NULL) {
		DEBUG(""unable to alloc space for y1 buffer"");
		goto fail;
	}
	if ((VAR_27 = talloc_zero_array(VAR_0, uint8_t, VAR_33)) == NULL) {
		DEBUG(""unable to alloc space for y2 buffer"");
		goto fail;
	}
	if ((VAR_28 = talloc_zero_array(VAR_0, uint8_t, VAR_33)) == NULL) {
		DEBUG(""unable to alloc space for y buffer"");
		goto fail;
	}


	/* COMMENT_1 */
                                                            
   
	do {
		BN_rand_range(VAR_13, VAR_1->prime);
	} while (legendre(VAR_13, VAR_1->prime, VAR_1->bnctx) != 1);

	do {
		BN_rand_range(VAR_14, VAR_1->prime);
	} while (legendre(VAR_14, VAR_1->prime, VAR_1->bnctx) != -1);

	if (!BN_sub(VAR_11, VAR_1->prime, BN_value_one())) {
		goto fail;
	}
	BN_bn2bin(VAR_11, VAR_25);

	VAR_41 = 0;
	VAR_35 = 0;
	memset(VAR_24, 0, VAR_33);
	VAR_29 = 0;
	while (VAR_29 < 40) {
		VAR_29++;

		/* COMMENT_4 */
                                                             
                                                          
                   
     
		EVP_DigestSignInit(VAR_19, NULL, EVP_sha256(), NULL, VAR_20);
		EVP_DigestSignUpdate(VAR_19, (uint8_t *)VAR_9, sizeof(*VAR_9));
		EVP_DigestSignUpdate(VAR_19, (uint8_t const *)VAR_7, VAR_8);
		EVP_DigestSignUpdate(VAR_19, (uint8_t const *)VAR_5, VAR_6);
		EVP_DigestSignUpdate(VAR_19, (uint8_t const *)VAR_3, VAR_4);
		EVP_DigestSignUpdate(VAR_19, (uint8_t *)&VAR_29, sizeof(VAR_29));

		{
			size_t VAR_51 = VAR_22;

			EVP_DigestSignFinal(VAR_19, VAR_21, &VAR_51);
			EVP_MD_CTX_reset(VAR_19);
		}

		BN_bin2bn(VAR_21, VAR_22, VAR_11);
		eap_pwd_kdf(VAR_21, VAR_22, ""EAP-pwd Hunting And Pecking"",
			    strlen(""EAP-pwd Hunting And Pecking""), VAR_23, VAR_32);

		/* COMMENT_9 */
                                                              
                                                             
                                                            
                                                             
                                                     
     
		if (VAR_32 % 8) {
			VAR_39 = 8 - (VAR_32 % 8);
			for (VAR_38 = VAR_33 - 1; VAR_38 > 0; VAR_38--) {
				VAR_23[VAR_38] = (VAR_23[VAR_38 - 1] << (8 - VAR_39)) | (VAR_23[VAR_38] >> VAR_39);
			}
			VAR_23[0] >>= VAR_39;
		}
		BN_bin2bn(VAR_23, VAR_33, VAR_10);

		/* COMMENT_16 */
                                                             
                                                                
                                                                 
    
		VAR_42 = const_time_memcmp(VAR_25, VAR_23, VAR_33);
		VAR_43 = const_time_fill_msb((unsigned int)VAR_42);

		/* COMMENT_21 */
                                                            
         
    
		VAR_31 = BN_is_odd(VAR_11);

		/* COMMENT_25 */
                                                      
   
                                                               
                        
    
		do_equation(VAR_1->group, VAR_12, VAR_10, VAR_1->bnctx);
		VAR_40 = is_quadratic_residue(VAR_12, VAR_1->prime, VAR_13, VAR_14, VAR_1->bnctx);

		/* COMMENT_31 */
                                                     
    
		VAR_40 = const_time_select(VAR_43, 0, VAR_40);

		/* COMMENT_34 */
                                                                   
                                                
    
		VAR_36 = const_time_select(VAR_35, 0, -1);

		/* COMMENT_38 */
                                                                  
                                                                   
    
		VAR_37 = const_time_select(VAR_36, VAR_40, 0);

		/* COMMENT_42 */
                                                                
             
    
		VAR_36 = const_time_eq(VAR_37, 1);

		const_time_select_bin(VAR_36, VAR_23, VAR_24, VAR_33, VAR_24);
		VAR_41 = const_time_select(VAR_36, VAR_31, VAR_41);
		VAR_35 = const_time_select(VAR_36, -1, VAR_35);
	}

	/* COMMENT_46 */
                                  
   
	BN_bin2bn(VAR_24, VAR_33, VAR_10);
	do_equation(VAR_1->group, VAR_12, VAR_10, VAR_1->bnctx);
	if ( !BN_add(VAR_18, VAR_1->prime, BN_value_one()) ||
		 !BN_rshift(VAR_18, VAR_18, 2) ||
		 !BN_mod_exp_mont_consttime(VAR_15, VAR_12, VAR_18, VAR_1->prime, VAR_1->bnctx, NULL) ||
		 !BN_sub(VAR_16, VAR_1->prime, VAR_15) ||
		 !BN_bn2bin(VAR_15, VAR_26) ||
		 !BN_bn2bin(VAR_16, VAR_27)) {
		DEBUG(""unable to compute y"");
		goto fail;
	}
	VAR_36 = const_time_eq(VAR_41, BN_is_odd(VAR_15));
	const_time_select_bin(VAR_36, VAR_26, VAR_27, VAR_33, VAR_28);
	if (BN_bin2bn(VAR_28, VAR_33, VAR_17) == NULL ||
		!EC_POINT_set_affine_coordinates(VAR_1->group, VAR_1->pwe, VAR_10, VAR_17, VAR_1->bnctx)) {
		DEBUG(""unable to set point coordinate"");
		goto fail;
	}

	VAR_1->group_num = VAR_2;
	if (0) {
		fail:		/* COMMENT_49 */
		VAR_34 = -1;
	}

	/* COMMENT_50 */
	BN_clear_free(VAR_10);
	BN_clear_free(VAR_12);
	BN_clear_free(VAR_13);
	BN_clear_free(VAR_14);
	BN_clear_free(VAR_11);
	BN_clear_free(VAR_15);
	BN_clear_free(VAR_16);
	BN_clear_free(VAR_17);
	BN_clear_free(VAR_18);

	if (VAR_23) talloc_free(VAR_23);
	if (VAR_24) talloc_free(VAR_24);
	if (VAR_25) talloc_free(VAR_25);
	if (VAR_26) talloc_free(VAR_26);
	if (VAR_27) talloc_free(VAR_27);
	if (VAR_28) talloc_free(VAR_28);

	EVP_MD_CTX_free(VAR_19);
	EVP_PKEY_free(VAR_20);

	return VAR_34;
}",FreeRADIUS/freeradius-server/9e5e8f2f/eap_pwd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,18 +4,16 @@
 			      char const *id_peer, int id_peer_len,
 			      uint32_t *token)
 {
-	BIGNUM *x_candidate = NULL, *rnd = NULL, *y_sqrd = NULL, *qr = NULL, *qnr = NULL;
-	HMAC_CTX *ctx = NULL;
-	uint8_t pwe_digest[SHA256_DIGEST_LENGTH], *prfbuf = NULL, *xbuf = NULL, *pm1buf = NULL, ctr;
-	int nid, is_odd, primebitlen, primebytelen, ret = 0, found = 0, mask;
-	int save, i, rbits, qr_or_qnr, save_is_odd = 0, cmp;
-	unsigned int skip;
-
-	ctx = HMAC_CTX_new();
-	if (ctx == NULL) {
-		DEBUG(""failed allocating HMAC context"");
-		goto fail;
-	}
+	BIGNUM		*x_candidate = NULL, *rnd = NULL, *y_sqrd = NULL, *qr = NULL, *qnr = NULL, *y1 = NULL, *y2 = NULL, *y = NULL, *exp = NULL;
+	EVP_MD_CTX	*hmac_ctx;
+	EVP_PKEY	*hmac_pkey;
+	uint8_t		pwe_digest[SHA256_DIGEST_LENGTH], *prfbuf = NULL, *xbuf = NULL, *pm1buf = NULL, *y1buf = NULL, *y2buf = NULL, *ybuf = NULL, ctr;
+	int		nid, is_odd, primebitlen, primebytelen, ret = 0, found = 0, mask;
+	int		save, i, rbits, qr_or_qnr, save_is_odd = 0, cmp;
+	unsigned int	skip;
+
+	MEM(hmac_ctx = EVP_MD_CTX_new());
+	MEM(hmac_pkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, allzero, sizeof(allzero)));
 
 	switch (grp_num) { /* from IANA registry for IKE D-H groups */
 	case 19:
@@ -59,7 +57,11 @@
 	    ((qr = consttime_BN()) == NULL) ||
 	    ((qnr = consttime_BN()) == NULL) ||
 	    ((x_candidate = consttime_BN()) == NULL) ||
-	    ((y_sqrd = consttime_BN()) == NULL)) {
+	    ((y_sqrd = consttime_BN()) == NULL) ||
+	    ((y1 = consttime_BN()) == NULL) ||
+	    ((y2 = consttime_BN()) == NULL) ||
+	    ((y = consttime_BN()) == NULL) ||
+        ((exp = consttime_BN()) == NULL)) {
 		DEBUG(""unable to create bignums"");
 		goto fail;
 	}
@@ -88,6 +90,19 @@
 		DEBUG(""unable to alloc space for pm1 buffer"");
 		goto fail;
 	}
+	if ((y1buf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {
+		DEBUG(""unable to alloc space for y1 buffer"");
+		goto fail;
+	}
+	if ((y2buf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {
+		DEBUG(""unable to alloc space for y2 buffer"");
+		goto fail;
+	}
+	if ((ybuf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {
+		DEBUG(""unable to alloc space for y buffer"");
+		goto fail;
+	}
+
 
 	/*
 	* derive random quadradic residue and quadratic non-residue
@@ -117,13 +132,19 @@
 		 *	pwd-seed = H(token | peer-id | server-id | password |
 		 *		     counter)
 		 */
-		HMAC_Init_ex(ctx, allzero, SHA256_DIGEST_LENGTH, EVP_sha256(),NULL);
-		HMAC_Update(ctx, (uint8_t *)token, sizeof(*token));
-		HMAC_Update(ctx, (uint8_t const *)id_peer, id_peer_len);
-		HMAC_Update(ctx, (uint8_t const *)id_server, id_server_len);
-		HMAC_Update(ctx, (uint8_t const *)password, password_len);
-		HMAC_Update(ctx, (uint8_t *)&ctr, sizeof(ctr));
-		pwd_hmac_final(ctx, pwe_digest);
+		EVP_DigestSignInit(hmac_ctx, NULL, EVP_sha256(), NULL, hmac_pkey);
+		EVP_DigestSignUpdate(hmac_ctx, (uint8_t *)token, sizeof(*token));
+		EVP_DigestSignUpdate(hmac_ctx, (uint8_t const *)id_peer, id_peer_len);
+		EVP_DigestSignUpdate(hmac_ctx, (uint8_t const *)id_server, id_server_len);
+		EVP_DigestSignUpdate(hmac_ctx, (uint8_t const *)password, password_len);
+		EVP_DigestSignUpdate(hmac_ctx, (uint8_t *)&ctr, sizeof(ctr));
+
+		{
+			size_t mdlen = SHA256_DIGEST_LENGTH;
+
+			EVP_DigestSignFinal(hmac_ctx, pwe_digest, &mdlen);
+			EVP_MD_CTX_reset(hmac_ctx);
+		}
 
 		BN_bin2bn(pwe_digest, SHA256_DIGEST_LENGTH, rnd);
 		eap_pwd_kdf(pwe_digest, SHA256_DIGEST_LENGTH, ""EAP-pwd Hunting And Pecking"",
@@ -157,7 +178,7 @@
 		* need to unambiguously identify the solution, if there is
 		* one..
 		*/
-		is_odd = BN_is_odd(rnd) ? 1 : 0;
+		is_odd = BN_is_odd(rnd);
 
 		/*
 		* check whether x^3 + a*x + b is a quadratic residue
@@ -200,8 +221,21 @@
 	* now we can savely construct PWE
 	*/
 	BN_bin2bn(xbuf, primebytelen, x_candidate);
-	if (!EC_POINT_set_compressed_coordinates(session->group, session->pwe,
-						     x_candidate, save_is_odd, NULL)) {
+	do_equation(session->group, y_sqrd, x_candidate, session->bnctx);
+	if ( !BN_add(exp, session->prime, BN_value_one()) ||
+		 !BN_rshift(exp, exp, 2) ||
+		 !BN_mod_exp_mont_consttime(y1, y_sqrd, exp, session->prime, session->bnctx, NULL) ||
+		 !BN_sub(y2, session->prime, y1) ||
+		 !BN_bn2bin(y1, y1buf) ||
+		 !BN_bn2bin(y2, y2buf)) {
+		DEBUG(""unable to compute y"");
+		goto fail;
+	}
+	mask = const_time_eq(save_is_odd, BN_is_odd(y1));
+	const_time_select_bin(mask, y1buf, y2buf, primebytelen, ybuf);
+	if (BN_bin2bn(ybuf, primebytelen, y) == NULL ||
+		!EC_POINT_set_affine_coordinates(session->group, session->pwe, x_candidate, y, session->bnctx)) {
+		DEBUG(""unable to set point coordinate"");
 		goto fail;
 	}
 
@@ -217,12 +251,20 @@
 	BN_clear_free(qr);
 	BN_clear_free(qnr);
 	BN_clear_free(rnd);
+	BN_clear_free(y1);
+	BN_clear_free(y2);
+	BN_clear_free(y);
+	BN_clear_free(exp);
 
 	if (prfbuf) talloc_free(prfbuf);
 	if (xbuf) talloc_free(xbuf);
 	if (pm1buf) talloc_free(pm1buf);
-
-	HMAC_CTX_free(ctx);
+	if (y1buf) talloc_free(y1buf);
+	if (y2buf) talloc_free(y2buf);
+	if (ybuf) talloc_free(ybuf);
+
+	EVP_MD_CTX_free(hmac_ctx);
+	EVP_PKEY_free(hmac_pkey);
 
 	return ret;
 }","{'deleted_lines': ['\tBIGNUM *x_candidate = NULL, *rnd = NULL, *y_sqrd = NULL, *qr = NULL, *qnr = NULL;', '\tHMAC_CTX *ctx = NULL;', '\tuint8_t pwe_digest[SHA256_DIGEST_LENGTH], *prfbuf = NULL, *xbuf = NULL, *pm1buf = NULL, ctr;', '\tint nid, is_odd, primebitlen, primebytelen, ret = 0, found = 0, mask;', '\tint save, i, rbits, qr_or_qnr, save_is_odd = 0, cmp;', '\tunsigned int skip;', '', '\tctx = HMAC_CTX_new();', '\tif (ctx == NULL) {', '\t\tDEBUG(""failed allocating HMAC context"");', '\t\tgoto fail;', '\t}', '\t    ((y_sqrd = consttime_BN()) == NULL)) {', '\t\tHMAC_Init_ex(ctx, allzero, SHA256_DIGEST_LENGTH, EVP_sha256(),NULL);', '\t\tHMAC_Update(ctx, (uint8_t *)token, sizeof(*token));', '\t\tHMAC_Update(ctx, (uint8_t const *)id_peer, id_peer_len);', '\t\tHMAC_Update(ctx, (uint8_t const *)id_server, id_server_len);', '\t\tHMAC_Update(ctx, (uint8_t const *)password, password_len);', '\t\tHMAC_Update(ctx, (uint8_t *)&ctr, sizeof(ctr));', '\t\tpwd_hmac_final(ctx, pwe_digest);', '\t\tis_odd = BN_is_odd(rnd) ? 1 : 0;', '\tif (!EC_POINT_set_compressed_coordinates(session->group, session->pwe,', '\t\t\t\t\t\t     x_candidate, save_is_odd, NULL)) {', '', '\tHMAC_CTX_free(ctx);'], 'added_lines': ['\tBIGNUM\t\t*x_candidate = NULL, *rnd = NULL, *y_sqrd = NULL, *qr = NULL, *qnr = NULL, *y1 = NULL, *y2 = NULL, *y = NULL, *exp = NULL;', '\tEVP_MD_CTX\t*hmac_ctx;', '\tEVP_PKEY\t*hmac_pkey;', '\tuint8_t\t\tpwe_digest[SHA256_DIGEST_LENGTH], *prfbuf = NULL, *xbuf = NULL, *pm1buf = NULL, *y1buf = NULL, *y2buf = NULL, *ybuf = NULL, ctr;', '\tint\t\tnid, is_odd, primebitlen, primebytelen, ret = 0, found = 0, mask;', '\tint\t\tsave, i, rbits, qr_or_qnr, save_is_odd = 0, cmp;', '\tunsigned int\tskip;', '', '\tMEM(hmac_ctx = EVP_MD_CTX_new());', '\tMEM(hmac_pkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, allzero, sizeof(allzero)));', '\t    ((y_sqrd = consttime_BN()) == NULL) ||', '\t    ((y1 = consttime_BN()) == NULL) ||', '\t    ((y2 = consttime_BN()) == NULL) ||', '\t    ((y = consttime_BN()) == NULL) ||', '        ((exp = consttime_BN()) == NULL)) {', '\tif ((y1buf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {', '\t\tDEBUG(""unable to alloc space for y1 buffer"");', '\t\tgoto fail;', '\t}', '\tif ((y2buf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {', '\t\tDEBUG(""unable to alloc space for y2 buffer"");', '\t\tgoto fail;', '\t}', '\tif ((ybuf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {', '\t\tDEBUG(""unable to alloc space for y buffer"");', '\t\tgoto fail;', '\t}', '', '\t\tEVP_DigestSignInit(hmac_ctx, NULL, EVP_sha256(), NULL, hmac_pkey);', '\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t *)token, sizeof(*token));', '\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t const *)id_peer, id_peer_len);', '\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t const *)id_server, id_server_len);', '\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t const *)password, password_len);', '\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t *)&ctr, sizeof(ctr));', '', '\t\t{', '\t\t\tsize_t mdlen = SHA256_DIGEST_LENGTH;', '', '\t\t\tEVP_DigestSignFinal(hmac_ctx, pwe_digest, &mdlen);', '\t\t\tEVP_MD_CTX_reset(hmac_ctx);', '\t\t}', '\t\tis_odd = BN_is_odd(rnd);', '\tdo_equation(session->group, y_sqrd, x_candidate, session->bnctx);', '\tif ( !BN_add(exp, session->prime, BN_value_one()) ||', '\t\t !BN_rshift(exp, exp, 2) ||', '\t\t !BN_mod_exp_mont_consttime(y1, y_sqrd, exp, session->prime, session->bnctx, NULL) ||', '\t\t !BN_sub(y2, session->prime, y1) ||', '\t\t !BN_bn2bin(y1, y1buf) ||', '\t\t !BN_bn2bin(y2, y2buf)) {', '\t\tDEBUG(""unable to compute y"");', '\t\tgoto fail;', '\t}', '\tmask = const_time_eq(save_is_odd, BN_is_odd(y1));', '\tconst_time_select_bin(mask, y1buf, y2buf, primebytelen, ybuf);', '\tif (BN_bin2bn(ybuf, primebytelen, y) == NULL ||', '\t\t!EC_POINT_set_affine_coordinates(session->group, session->pwe, x_candidate, y, session->bnctx)) {', '\t\tDEBUG(""unable to set point coordinate"");', '\tBN_clear_free(y1);', '\tBN_clear_free(y2);', '\tBN_clear_free(y);', '\tBN_clear_free(exp);', '\tif (y1buf) talloc_free(y1buf);', '\tif (y2buf) talloc_free(y2buf);', '\tif (ybuf) talloc_free(ybuf);', '', '\tEVP_MD_CTX_free(hmac_ctx);', '\tEVP_PKEY_free(hmac_pkey);']}",True,"In freeradius, the EAP-PWD function compute_password_element() leaks information about the password which allows an attacker to substantially reduce the size of an offline dictionary attack.",7.5,HIGH,2,test,2022-02-04T14:36:26Z,4
CVE-2022-41860,['CWE-476'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,FreeRADIUS/freeradius-server,it's probably wrong to be completely retarded.  Let's fix that.,f1cdbb33ec61c4a64a,https://github.com/FreeRADIUS/freeradius-server/commit/f1cdbb33ec61c4a64a32e107d4d02f936051c708,src/modules/rlm_eap/libeap/eapsimlib.c,unmap_eapsim_basictypes,"int unmap_eapsim_basictypes(RADIUS_PACKET *r,
uint8_t *attr, unsigned int attrlen)
{
VALUE_PAIR*newvp;
inteapsim_attribute;
unsigned inteapsim_len;
intes_attribute_count;
es_attribute_count = 0;
if (attrlen < 5) {
fr_strerror_printf(""EAP-Sim attribute too short: %d < 5"", attrlen);
return 0;
}
newvp = fr_pair_afrom_num(r, PW_EAP_SIM_SUBTYPE, 0);
if (!newvp) {
fr_strerror_printf(""Failed creating EAP-SIM-Subtype"");
return 0;
}
newvp->vp_integer = attr[0];
newvp->vp_length = 1;
fr_pair_add(&(r->vps), newvp);
attr     += 3;
attrlen  -= 3;
while(attrlen > 0) {
uint8_t *p;
if(attrlen < 2) {
fr_strerror_printf(""EAP-Sim attribute %d too short: %d < 2"", es_attribute_count, attrlen);
return 0;
}
eapsim_attribute = attr[0];
eapsim_len = attr[1] * 4;
if (eapsim_len > attrlen) {
fr_strerror_printf(""EAP-Sim attribute %d (no.%d) has length longer than data (%d > %d)"",
eapsim_attribute, es_attribute_count, eapsim_len, attrlen);
return 0;
}
if(eapsim_len > MAX_STRING_LEN) {
eapsim_len = MAX_STRING_LEN;
}
if (eapsim_len < 2) {
fr_strerror_printf(""EAP-Sim attribute %d (no.%d) has length too small"", eapsim_attribute,
es_attribute_count);
return 0;
}
newvp = fr_pair_afrom_num(r, eapsim_attribute+PW_EAP_SIM_BASE, 0);
newvp->vp_length = eapsim_len-2;
newvp->vp_octets = p = talloc_array(newvp, uint8_t, newvp->vp_length);
memcpy(p, &attr[2], eapsim_len-2);
fr_pair_add(&(r->vps), newvp);
newvp = NULL;
attr += eapsim_len;
attrlen -= eapsim_len;
es_attribute_count++;
}
return 1;
}","int unmap_eapsim_basictypes(RADIUS_PACKET *VAR_0,
uint8_t *VAR_1, unsigned int VAR_2)
{
VALUE_PAIR*VAR_3;
intVAR_4;
unsigned intVAR_5;
intVAR_6;
VAR_6 = 0;
if (VAR_2 < 5) {
fr_strerror_printf(""EAP-Sim attribute too short: %d < 5"", VAR_2);
return 0;
}
VAR_3 = fr_pair_afrom_num(VAR_0, VAR_7, 0);
if (!VAR_3) {
fr_strerror_printf(""Failed creating EAP-SIM-Subtype"");
return 0;
}
VAR_3->vp_integer = VAR_1[0];
VAR_3->vp_length = 1;
fr_pair_add(&(VAR_0->vps), VAR_3);
VAR_1     += 3;
VAR_2  -= 3;
while(VAR_2 > 0) {
uint8_t *VAR_8;
if(VAR_2 < 2) {
fr_strerror_printf(""EAP-Sim attribute %d too short: %d < 2"", VAR_6, VAR_2);
return 0;
}
VAR_4 = VAR_1[0];
VAR_5 = VAR_1[1] * 4;
if (VAR_5 > VAR_2) {
fr_strerror_printf(""EAP-Sim attribute %d (no.%d) has length longer than data (%d > %d)"",
VAR_4, VAR_6, VAR_5, VAR_2);
return 0;
}
if(VAR_5 > VAR_9) {
VAR_5 = VAR_9;
}
if (VAR_5 < 2) {
fr_strerror_printf(""EAP-Sim attribute %d (no.%d) has length too small"", VAR_4,
VAR_6);
return 0;
}
VAR_3 = fr_pair_afrom_num(VAR_0, VAR_4+VAR_10, 0);
VAR_3->vp_length = VAR_5-2;
VAR_3->vp_octets = VAR_8 = talloc_array(VAR_3, uint8_t, VAR_3->vp_length);
memcpy(VAR_8, &VAR_1[2], VAR_5-2);
fr_pair_add(&(VAR_0->vps), VAR_3);
VAR_3 = NULL;
VAR_1 += VAR_5;
VAR_2 -= VAR_5;
VAR_6++;
}
return 1;
}",FreeRADIUS/freeradius-server/f1cdbb33ec61c4a64a/eapsimlib.c/vul/before/0.json,"int unmap_eapsim_basictypes(RADIUS_PACKET *r,
			    uint8_t *attr, unsigned int attrlen)
{
	VALUE_PAIR	*newvp;
	int		eapsim_attribute;
	unsigned int	eapsim_len;
	int		es_attribute_count;

	es_attribute_count = 0;

	/* big enough to have even a single attribute */
	if (attrlen < 5) {
		fr_strerror_printf(""EAP-Sim attribute too short: %d < 5"", attrlen);
		return 0;
	}

	newvp = fr_pair_afrom_num(r, PW_EAP_SIM_SUBTYPE, 0);
	if (!newvp) {
		fr_strerror_printf(""Failed creating EAP-SIM-Subtype"");
		return 0;
	}

	newvp->vp_integer = attr[0];
	newvp->vp_length = 1;
	fr_pair_add(&(r->vps), newvp);

	/*
	 *	EAP-SIM has a 1 octet of subtype, and 2 octets
	 *	reserved.
	 */
	attr     += 3;
	attrlen  -= 3;

	/*
	 *	Loop over each attribute.  The format is:
	 *
	 *	1 octet of type
	 *	1 octet of length (value 1..255)
	 *	((4 * length) - 2) octets of data.
	 */
	while (attrlen > 0) {
		uint8_t *p;

		if (attrlen < 2) {
			fr_strerror_printf(""EAP-Sim attribute %d too short: %d < 2"", es_attribute_count, attrlen);
			return 0;
		}

		if (!attr[1]) {
			fr_strerror_printf(""EAP-Sim attribute %d (no.%d) has no data"", eapsim_attribute,
					   es_attribute_count);
			return 0;
		}

		eapsim_attribute = attr[0];
		eapsim_len = attr[1] * 4;

		/*
		 *	The length includes the 2-byte header.
		 */
		if (eapsim_len > attrlen) {
			fr_strerror_printf(""EAP-Sim attribute %d (no.%d) has length longer than data (%d > %d)"",
					   eapsim_attribute, es_attribute_count, eapsim_len, attrlen);
			return 0;
		}

		newvp = fr_pair_afrom_num(r, eapsim_attribute + PW_EAP_SIM_BASE, 0);
		if (!newvp) {
			/*
			 *	RFC 4186 Section 8.1 says 0..127 are
			 *	""non-skippable"".  If one such
			 *	attribute is found and we don't
			 *	understand it, the server has to send:
			 *
			 *	EAP-Request/SIM/Notification packet with an
			 *	(AT_NOTIFICATION code, which implies general failure (""General
			 *	failure after authentication"" (0), or ""General failure"" (16384),
			 *	depending on the phase of the exchange), which terminates the
			 *	authentication exchange.
			 */
			if (eapsim_attribute <= 127) {
				fr_strerror_printf(""Unknown mandatory attribute %d, failing"",
						   eapsim_attribute);
				return 0;
			}

		} else {
			/*
			 *	It's known, ccount for header, and
			 *	copy the value over.
			 */
			newvp->vp_length = eapsim_len - 2;

			newvp->vp_octets = p = talloc_array(newvp, uint8_t, newvp->vp_length);
			memcpy(p, &attr[2], newvp->vp_length);
			fr_pair_add(&(r->vps), newvp);
		}

		/* advance pointers, decrement length */
		attr += eapsim_len;
		attrlen -= eapsim_len;
		es_attribute_count++;
	}

	return 1;
}","int unmap_eapsim_basictypes(RADIUS_PACKET *VAR_0,
			    uint8_t *VAR_1, unsigned int VAR_2)
{
	VALUE_PAIR	*VAR_3;
	int		VAR_4;
	unsigned int	VAR_5;
	int		VAR_6;

	VAR_6 = 0;

	/* COMMENT_0 */
	if (VAR_2 < 5) {
		fr_strerror_printf(""EAP-Sim attribute too short: %d < 5"", VAR_2);
		return 0;
	}

	VAR_3 = fr_pair_afrom_num(VAR_0, VAR_7, 0);
	if (!VAR_3) {
		fr_strerror_printf(""Failed creating EAP-SIM-Subtype"");
		return 0;
	}

	VAR_3->vp_integer = VAR_1[0];
	VAR_3->vp_length = 1;
	fr_pair_add(&(VAR_0->vps), VAR_3);

	/* COMMENT_1 */
                                                  
             
    
	VAR_1     += 3;
	VAR_2  -= 3;

	/* COMMENT_5 */
                                             
   
                   
                                    
                                      
    
	while (VAR_2 > 0) {
		uint8_t *VAR_8;

		if (VAR_2 < 2) {
			fr_strerror_printf(""EAP-Sim attribute %d too short: %d < 2"", VAR_6, VAR_2);
			return 0;
		}

		if (!VAR_1[1]) {
			fr_strerror_printf(""EAP-Sim attribute %d (no.%d) has no data"", VAR_4,
					   VAR_6);
			return 0;
		}

		VAR_4 = VAR_1[0];
		VAR_5 = VAR_1[1] * 4;

		/* COMMENT_12 */
                                           
     
		if (VAR_5 > VAR_2) {
			fr_strerror_printf(""EAP-Sim attribute %d (no.%d) has length longer than data (%d > %d)"",
					   VAR_4, VAR_6, VAR_5, VAR_2);
			return 0;
		}

		VAR_3 = fr_pair_afrom_num(VAR_0, VAR_4 + VAR_9, 0);
		if (!VAR_3) {
			/* COMMENT_15 */
                                          
                                   
                                     
                                            
     
                                                 
                                                                    
                                                                      
                                                                   
                              
      
			if (VAR_4 <= 127) {
				fr_strerror_printf(""Unknown mandatory attribute %d, failing"",
						   VAR_4);
				return 0;
			}

		} else {
			/* COMMENT_27 */
                                        
                          
      
			VAR_3->vp_length = VAR_5 - 2;

			VAR_3->vp_octets = VAR_8 = talloc_array(VAR_3, uint8_t, VAR_3->vp_length);
			memcpy(VAR_8, &VAR_1[2], VAR_3->vp_length);
			fr_pair_add(&(VAR_0->vps), VAR_3);
		}

		/* COMMENT_31 */
		VAR_1 += VAR_5;
		VAR_2 -= VAR_5;
		VAR_6++;
	}

	return 1;
}",FreeRADIUS/freeradius-server/f1cdbb33ec61c4a64a/eapsimlib.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -24,42 +24,77 @@
 	newvp->vp_length = 1;
 	fr_pair_add(&(r->vps), newvp);
 
+	/*
+	 *	EAP-SIM has a 1 octet of subtype, and 2 octets
+	 *	reserved.
+	 */
 	attr     += 3;
 	attrlen  -= 3;
 
-	/* now, loop processing each attribute that we find */
-	while(attrlen > 0) {
+	/*
+	 *	Loop over each attribute.  The format is:
+	 *
+	 *	1 octet of type
+	 *	1 octet of length (value 1..255)
+	 *	((4 * length) - 2) octets of data.
+	 */
+	while (attrlen > 0) {
 		uint8_t *p;
 
-		if(attrlen < 2) {
+		if (attrlen < 2) {
 			fr_strerror_printf(""EAP-Sim attribute %d too short: %d < 2"", es_attribute_count, attrlen);
+			return 0;
+		}
+
+		if (!attr[1]) {
+			fr_strerror_printf(""EAP-Sim attribute %d (no.%d) has no data"", eapsim_attribute,
+					   es_attribute_count);
 			return 0;
 		}
 
 		eapsim_attribute = attr[0];
 		eapsim_len = attr[1] * 4;
 
+		/*
+		 *	The length includes the 2-byte header.
+		 */
 		if (eapsim_len > attrlen) {
 			fr_strerror_printf(""EAP-Sim attribute %d (no.%d) has length longer than data (%d > %d)"",
 					   eapsim_attribute, es_attribute_count, eapsim_len, attrlen);
 			return 0;
 		}
 
-		if(eapsim_len > MAX_STRING_LEN) {
-			eapsim_len = MAX_STRING_LEN;
+		newvp = fr_pair_afrom_num(r, eapsim_attribute + PW_EAP_SIM_BASE, 0);
+		if (!newvp) {
+			/*
+			 *	RFC 4186 Section 8.1 says 0..127 are
+			 *	""non-skippable"".  If one such
+			 *	attribute is found and we don't
+			 *	understand it, the server has to send:
+			 *
+			 *	EAP-Request/SIM/Notification packet with an
+			 *	(AT_NOTIFICATION code, which implies general failure (""General
+			 *	failure after authentication"" (0), or ""General failure"" (16384),
+			 *	depending on the phase of the exchange), which terminates the
+			 *	authentication exchange.
+			 */
+			if (eapsim_attribute <= 127) {
+				fr_strerror_printf(""Unknown mandatory attribute %d, failing"",
+						   eapsim_attribute);
+				return 0;
+			}
+
+		} else {
+			/*
+			 *	It's known, ccount for header, and
+			 *	copy the value over.
+			 */
+			newvp->vp_length = eapsim_len - 2;
+
+			newvp->vp_octets = p = talloc_array(newvp, uint8_t, newvp->vp_length);
+			memcpy(p, &attr[2], newvp->vp_length);
+			fr_pair_add(&(r->vps), newvp);
 		}
-		if (eapsim_len < 2) {
-			fr_strerror_printf(""EAP-Sim attribute %d (no.%d) has length too small"", eapsim_attribute,
-					   es_attribute_count);
-			return 0;
-		}
-
-		newvp = fr_pair_afrom_num(r, eapsim_attribute+PW_EAP_SIM_BASE, 0);
-		newvp->vp_length = eapsim_len-2;
-		newvp->vp_octets = p = talloc_array(newvp, uint8_t, newvp->vp_length);
-		memcpy(p, &attr[2], eapsim_len-2);
-		fr_pair_add(&(r->vps), newvp);
-		newvp = NULL;
 
 		/* advance pointers, decrement length */
 		attr += eapsim_len;","{'deleted_lines': ['\t/* now, loop processing each attribute that we find */', '\twhile(attrlen > 0) {', '\t\tif(attrlen < 2) {', '\t\tif(eapsim_len > MAX_STRING_LEN) {', '\t\t\teapsim_len = MAX_STRING_LEN;', '\t\tif (eapsim_len < 2) {', '\t\t\tfr_strerror_printf(""EAP-Sim attribute %d (no.%d) has length too small"", eapsim_attribute,', '\t\t\t\t\t   es_attribute_count);', '\t\t\treturn 0;', '\t\t}', '', '\t\tnewvp = fr_pair_afrom_num(r, eapsim_attribute+PW_EAP_SIM_BASE, 0);', '\t\tnewvp->vp_length = eapsim_len-2;', '\t\tnewvp->vp_octets = p = talloc_array(newvp, uint8_t, newvp->vp_length);', '\t\tmemcpy(p, &attr[2], eapsim_len-2);', '\t\tfr_pair_add(&(r->vps), newvp);', '\t\tnewvp = NULL;'], 'added_lines': ['\t/*', '\t *\tEAP-SIM has a 1 octet of subtype, and 2 octets', '\t *\treserved.', '\t */', '\t/*', '\t *\tLoop over each attribute.  The format is:', '\t *', '\t *\t1 octet of type', '\t *\t1 octet of length (value 1..255)', '\t *\t((4 * length) - 2) octets of data.', '\t */', '\twhile (attrlen > 0) {', '\t\tif (attrlen < 2) {', '\t\t\treturn 0;', '\t\t}', '', '\t\tif (!attr[1]) {', '\t\t\tfr_strerror_printf(""EAP-Sim attribute %d (no.%d) has no data"", eapsim_attribute,', '\t\t\t\t\t   es_attribute_count);', '\t\t/*', '\t\t *\tThe length includes the 2-byte header.', '\t\t */', '\t\tnewvp = fr_pair_afrom_num(r, eapsim_attribute + PW_EAP_SIM_BASE, 0);', '\t\tif (!newvp) {', '\t\t\t/*', '\t\t\t *\tRFC 4186 Section 8.1 says 0..127 are', '\t\t\t *\t""non-skippable"".  If one such', ""\t\t\t *\tattribute is found and we don't"", '\t\t\t *\tunderstand it, the server has to send:', '\t\t\t *', '\t\t\t *\tEAP-Request/SIM/Notification packet with an', '\t\t\t *\t(AT_NOTIFICATION code, which implies general failure (""General', '\t\t\t *\tfailure after authentication"" (0), or ""General failure"" (16384),', '\t\t\t *\tdepending on the phase of the exchange), which terminates the', '\t\t\t *\tauthentication exchange.', '\t\t\t */', '\t\t\tif (eapsim_attribute <= 127) {', '\t\t\t\tfr_strerror_printf(""Unknown mandatory attribute %d, failing"",', '\t\t\t\t\t\t   eapsim_attribute);', '\t\t\t\treturn 0;', '\t\t\t}', '', '\t\t} else {', '\t\t\t/*', ""\t\t\t *\tIt's known, ccount for header, and"", '\t\t\t *\tcopy the value over.', '\t\t\t */', '\t\t\tnewvp->vp_length = eapsim_len - 2;', '', '\t\t\tnewvp->vp_octets = p = talloc_array(newvp, uint8_t, newvp->vp_length);', '\t\t\tmemcpy(p, &attr[2], newvp->vp_length);', '\t\t\tfr_pair_add(&(r->vps), newvp);']}",True,"In freeradius, when an EAP-SIM supplicant sends an unknown SIM option, the server will try to look that option up in the internal dictionaries. This lookup will fail, but the SIM code will not check for that failure. Instead, it will dereference a NULL pointer, and cause the server to crash.",7.5,HIGH,2,test,2022-02-08T03:26:05Z,4
CVE-2022-0525,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0,mruby,"codegen.c: stack position may be wrong on assignments.

When `[]=` access includes keyword arguments.",0849a2885f81cfd82134992c06df3ccd59052ac7,https://github.com/mruby/mruby/commit/0849a2885f81cfd82134992c06df3ccd59052ac7,mrbgems/mruby-compiler/core/codegen.c,gen_assignment,"static void
gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)
{
int idx;
int type = nint(tree->car);
switch (type) {
case NODE_GVAR:
case NODE_ARG:
case NODE_LVAR:
case NODE_IVAR:
case NODE_CVAR:
case NODE_CONST:
case NODE_NIL:
case NODE_MASGN:
if (rhs) {
codegen(s, rhs, VAL);
pop();
sp = cursp();
}
break;
case NODE_COLON2:
case NODE_CALL:
case NODE_SCALL:
break;
case NODE_NVAR:
codegen_error(s, ""Can't assign to numbered parameter"");
break;
default:
codegen_error(s, ""unknown lhs"");
break;
}
tree = tree->cdr;
switch (type) {
case NODE_GVAR:
gen_setxv(s, OP_SETGV, sp, nsym(tree), val);
break;
case NODE_ARG:
case NODE_LVAR:
idx = lv_idx(s, nsym(tree));
if (idx > 0) {
if (idx != sp) {
gen_move(s, idx, sp, val);
}
break;
}
else {                      
gen_setupvar(s, sp, nsym(tree));
}
break;
case NODE_IVAR:
gen_setxv(s, OP_SETIV, sp, nsym(tree), val);
break;
case NODE_CVAR:
gen_setxv(s, OP_SETCV, sp, nsym(tree), val);
break;
case NODE_CONST:
gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);
break;
case NODE_COLON2:
if (sp) {
gen_move(s, cursp(), sp, 0);
}
sp = cursp();
push();
codegen(s, tree->car, VAL);
if (rhs) {
codegen(s, rhs, VAL); pop();
gen_move(s, sp, cursp(), 0);
}
pop_n(2);
idx = new_sym(s, nsym(tree->cdr));
genop_2(s, OP_SETMCNST, sp, idx);
break;
case NODE_CALL:
case NODE_SCALL:
{
int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;
mrb_sym mid = nsym(tree->cdr->car);
top = cursp();
if (val || sp == cursp()) {
push();                   
}
call = cursp();
if (!tree->car) {
noself = 1;
push();
}
else {
codegen(s, tree->car, VAL); 
}
if (safe) {
int recv = cursp()-1;
gen_move(s, cursp(), recv, 1);
skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);
}
tree = tree->cdr->cdr->car;
if (tree) {
if (tree->car) {            
n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);
if (n < 0) {              
n = 15;
push();
}
}
if (tree->cdr->car) {       
gen_hash(s, tree->cdr->car->cdr, VAL, 0);
if (n < 14) {
n++;
push();
}
else {
pop();
genop_2(s, OP_ARYPUSH, cursp(), 1);
}
}
}
if (rhs) {
codegen(s, rhs, VAL);
pop();
}
else {
gen_move(s, cursp(), sp, 0);
}
if (val) {
gen_move(s, top, cursp(), 1);
}
if (n < 14) {
n++;
}
else {
pop();
genop_2(s, OP_ARYPUSH, cursp(), 1);
}
s->sp = call;
if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {
genop_1(s, OP_SETIDX, cursp());
}
else {
genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);
}
if (safe) {
dispatch(s, skip);
}
s->sp = top;
}
break;
case NODE_MASGN:
gen_vmassignment(s, tree->car, sp, val);
break;
case NODE_NIL:
break;
default:
codegen_error(s, ""unknown lhs"");
break;
}
if (val) push();
}","static void
gen_assignment(codegen_scope *VAR_0, node *VAR_1, node *VAR_2, int VAR_3, int VAR_4)
{
int VAR_5;
int VAR_6 = nint(VAR_1->car);
switch (VAR_6) {
case VAR_7:
case VAR_8:
case VAR_9:
case VAR_10:
case VAR_11:
case VAR_12:
case VAR_13:
case VAR_14:
if (VAR_2) {
codegen(VAR_0, VAR_2, VAR_15);
pop();
VAR_3 = cursp();
}
break;
case VAR_16:
case VAR_17:
case VAR_18:
break;
case VAR_19:
codegen_error(VAR_0, ""Can't assign to numbered parameter"");
break;
default:
codegen_error(VAR_0, ""unknown lhs"");
break;
}
VAR_1 = VAR_1->cdr;
switch (VAR_6) {
case VAR_7:
gen_setxv(VAR_0, VAR_20, VAR_3, nsym(VAR_1), VAR_4);
break;
case VAR_8:
case VAR_9:
VAR_5 = lv_idx(VAR_0, nsym(VAR_1));
if (VAR_5 > 0) {
if (VAR_5 != VAR_3) {
gen_move(VAR_0, VAR_5, VAR_3, VAR_4);
}
break;
}
else {                      
gen_setupvar(VAR_0, VAR_3, nsym(VAR_1));
}
break;
case VAR_10:
gen_setxv(VAR_0, VAR_21, VAR_3, nsym(VAR_1), VAR_4);
break;
case VAR_11:
gen_setxv(VAR_0, VAR_22, VAR_3, nsym(VAR_1), VAR_4);
break;
case VAR_12:
gen_setxv(VAR_0, VAR_23, VAR_3, nsym(VAR_1), VAR_4);
break;
case VAR_16:
if (VAR_3) {
gen_move(VAR_0, cursp(), VAR_3, 0);
}
VAR_3 = cursp();
push();
codegen(VAR_0, VAR_1->car, VAR_15);
if (VAR_2) {
codegen(VAR_0, VAR_2, VAR_15); pop();
gen_move(VAR_0, VAR_3, cursp(), 0);
}
pop_n(2);
VAR_5 = new_sym(VAR_0, nsym(VAR_1->cdr));
genop_2(VAR_0, VAR_24, VAR_3, VAR_5);
break;
case VAR_17:
case VAR_18:
{
int VAR_25 = 0, VAR_26 = (VAR_6 == VAR_18), VAR_27 = 0, VAR_28, VAR_29, VAR_30 = 0;
mrb_sym VAR_31 = nsym(VAR_1->cdr->car);
VAR_28 = cursp();
if (VAR_4 || VAR_3 == cursp()) {
push();                   
}
VAR_29 = cursp();
if (!VAR_1->car) {
VAR_25 = 1;
push();
}
else {
codegen(VAR_0, VAR_1->car, VAR_15); 
}
if (VAR_26) {
int VAR_32 = cursp()-1;
gen_move(VAR_0, cursp(), VAR_32, 1);
VAR_27 = genjmp2_0(VAR_0, VAR_33, cursp(), VAR_4);
}
VAR_1 = VAR_1->cdr->cdr->car;
if (VAR_1) {
if (VAR_1->car) {            
VAR_30 = gen_values(VAR_0, VAR_1->car, VAR_15, (VAR_1->cdr->car)?13:14);
if (VAR_30 < 0) {              
VAR_30 = 15;
push();
}
}
if (VAR_1->cdr->car) {       
gen_hash(VAR_0, VAR_1->cdr->car->cdr, VAR_15, 0);
if (VAR_30 < 14) {
VAR_30++;
push();
}
else {
pop();
genop_2(VAR_0, VAR_34, cursp(), 1);
}
}
}
if (VAR_2) {
codegen(VAR_0, VAR_2, VAR_15);
pop();
}
else {
gen_move(VAR_0, cursp(), VAR_3, 0);
}
if (VAR_4) {
gen_move(VAR_0, VAR_28, cursp(), 1);
}
if (VAR_30 < 14) {
VAR_30++;
}
else {
pop();
genop_2(VAR_0, VAR_34, cursp(), 1);
}
VAR_0->sp = VAR_29;
if (VAR_31 == MRB_OPSYM_2(VAR_0->mrb, VAR_35) && VAR_30 == 2) {
genop_1(VAR_0, VAR_36, cursp());
}
else {
genop_3(VAR_0, VAR_25 ? VAR_37 : VAR_38, cursp(), new_sym(VAR_0, attrsym(VAR_0, VAR_31)), VAR_30);
}
if (VAR_26) {
dispatch(VAR_0, VAR_27);
}
VAR_0->sp = VAR_28;
}
break;
case VAR_14:
gen_vmassignment(VAR_0, VAR_1->car, VAR_3, VAR_4);
break;
case VAR_13:
break;
default:
codegen_error(VAR_0, ""unknown lhs"");
break;
}
if (VAR_4) push();
}",mruby/0849a2885f81cfd82134992c06df3ccd59052ac7/codegen.c/vul/before/0.json,"static void
gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)
{
  int idx;
  int type = nint(tree->car);

  switch (type) {
  case NODE_GVAR:
  case NODE_ARG:
  case NODE_LVAR:
  case NODE_IVAR:
  case NODE_CVAR:
  case NODE_CONST:
  case NODE_NIL:
  case NODE_MASGN:
    if (rhs) {
      codegen(s, rhs, VAL);
      pop();
      sp = cursp();
    }
    break;

  case NODE_COLON2:
  case NODE_CALL:
  case NODE_SCALL:
    /* keep evaluation order */
    break;

  case NODE_NVAR:
    codegen_error(s, ""Can't assign to numbered parameter"");
    break;

  default:
    codegen_error(s, ""unknown lhs"");
    break;
  }

  tree = tree->cdr;
  switch (type) {
  case NODE_GVAR:
    gen_setxv(s, OP_SETGV, sp, nsym(tree), val);
    break;
  case NODE_ARG:
  case NODE_LVAR:
    idx = lv_idx(s, nsym(tree));
    if (idx > 0) {
      if (idx != sp) {
        gen_move(s, idx, sp, val);
      }
      break;
    }
    else {                      /* upvar */
      gen_setupvar(s, sp, nsym(tree));
    }
    break;
  case NODE_IVAR:
    gen_setxv(s, OP_SETIV, sp, nsym(tree), val);
    break;
  case NODE_CVAR:
    gen_setxv(s, OP_SETCV, sp, nsym(tree), val);
    break;
  case NODE_CONST:
    gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);
    break;
  case NODE_COLON2:
    if (sp) {
      gen_move(s, cursp(), sp, 0);
    }
    sp = cursp();
    push();
    codegen(s, tree->car, VAL);
    if (rhs) {
      codegen(s, rhs, VAL); pop();
      gen_move(s, sp, cursp(), 0);
    }
    pop_n(2);
    idx = new_sym(s, nsym(tree->cdr));
    genop_2(s, OP_SETMCNST, sp, idx);
    break;

  case NODE_CALL:
  case NODE_SCALL:
    {
      int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;
      mrb_sym mid = nsym(tree->cdr->car);

      top = cursp();
      if (val || sp == cursp()) {
        push();                   /* room for retval */
      }
      call = cursp();
      if (!tree->car) {
        noself = 1;
        push();
      }
      else {
        codegen(s, tree->car, VAL); /* receiver */
      }
      if (safe) {
        int recv = cursp()-1;
        gen_move(s, cursp(), recv, 1);
        skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);
      }
      tree = tree->cdr->cdr->car;
      if (tree) {
        if (tree->car) {            /* positional arguments */
          n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);
          if (n < 0) {              /* variable length */
            n = 15;
            push();
          }
        }
        if (tree->cdr->car) {       /* keyword arguments */
          if (n == 14) {
            pop_n(n);
            genop_2(s, OP_ARRAY, cursp(), n);
            push();
            n = 15;
          }
          gen_hash(s, tree->cdr->car->cdr, VAL, 0);
          if (n < 14) {
            n++;
          }
          else {
            pop_n(2);
            genop_2(s, OP_ARYPUSH, cursp(), 1);
          }
          push();
        }
      }
      if (rhs) {
        codegen(s, rhs, VAL);
        pop();
      }
      else {
        gen_move(s, cursp(), sp, 0);
      }
      if (val) {
        gen_move(s, top, cursp(), 1);
      }
      if (n < 14) {
        n++;
      }
      else {
        pop();
        genop_2(s, OP_ARYPUSH, cursp(), 1);
      }
      s->sp = call;
      if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {
        genop_1(s, OP_SETIDX, cursp());
      }
      else {
        genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);
      }
      if (safe) {
        dispatch(s, skip);
      }
      s->sp = top;
    }
    break;

  case NODE_MASGN:
    gen_vmassignment(s, tree->car, sp, val);
    break;

  /* splat without assignment */
  case NODE_NIL:
    break;

  default:
    codegen_error(s, ""unknown lhs"");
    break;
  }
  if (val) push();
}","static void
gen_assignment(codegen_scope *VAR_0, node *VAR_1, node *VAR_2, int VAR_3, int VAR_4)
{
  int VAR_5;
  int VAR_6 = nint(VAR_1->car);

  switch (VAR_6) {
  case VAR_7:
  case VAR_8:
  case VAR_9:
  case VAR_10:
  case VAR_11:
  case VAR_12:
  case VAR_13:
  case VAR_14:
    if (VAR_2) {
      codegen(VAR_0, VAR_2, VAR_15);
      pop();
      VAR_3 = cursp();
    }
    break;

  case VAR_16:
  case VAR_17:
  case VAR_18:
    /* COMMENT_0 */
    break;

  case VAR_19:
    codegen_error(VAR_0, ""Can't assign to numbered parameter"");
    break;

  default:
    codegen_error(VAR_0, ""unknown lhs"");
    break;
  }

  VAR_1 = VAR_1->cdr;
  switch (VAR_6) {
  case VAR_7:
    gen_setxv(VAR_0, VAR_20, VAR_3, nsym(VAR_1), VAR_4);
    break;
  case VAR_8:
  case VAR_9:
    VAR_5 = lv_idx(VAR_0, nsym(VAR_1));
    if (VAR_5 > 0) {
      if (VAR_5 != VAR_3) {
        gen_move(VAR_0, VAR_5, VAR_3, VAR_4);
      }
      break;
    }
    else {                      /* COMMENT_1 */
      gen_setupvar(VAR_0, VAR_3, nsym(VAR_1));
    }
    break;
  case VAR_10:
    gen_setxv(VAR_0, VAR_21, VAR_3, nsym(VAR_1), VAR_4);
    break;
  case VAR_11:
    gen_setxv(VAR_0, VAR_22, VAR_3, nsym(VAR_1), VAR_4);
    break;
  case VAR_12:
    gen_setxv(VAR_0, VAR_23, VAR_3, nsym(VAR_1), VAR_4);
    break;
  case VAR_16:
    if (VAR_3) {
      gen_move(VAR_0, cursp(), VAR_3, 0);
    }
    VAR_3 = cursp();
    push();
    codegen(VAR_0, VAR_1->car, VAR_15);
    if (VAR_2) {
      codegen(VAR_0, VAR_2, VAR_15); pop();
      gen_move(VAR_0, VAR_3, cursp(), 0);
    }
    pop_n(2);
    VAR_5 = new_sym(VAR_0, nsym(VAR_1->cdr));
    genop_2(VAR_0, VAR_24, VAR_3, VAR_5);
    break;

  case VAR_17:
  case VAR_18:
    {
      int VAR_25 = 0, VAR_26 = (VAR_6 == VAR_18), VAR_27 = 0, VAR_28, VAR_29, VAR_30 = 0;
      mrb_sym VAR_31 = nsym(VAR_1->cdr->car);

      VAR_28 = cursp();
      if (VAR_4 || VAR_3 == cursp()) {
        push();                   /* COMMENT_2 */
      }
      VAR_29 = cursp();
      if (!VAR_1->car) {
        VAR_25 = 1;
        push();
      }
      else {
        codegen(VAR_0, VAR_1->car, VAR_15); /* COMMENT_3 */
      }
      if (VAR_26) {
        int VAR_32 = cursp()-1;
        gen_move(VAR_0, cursp(), VAR_32, 1);
        VAR_27 = genjmp2_0(VAR_0, VAR_33, cursp(), VAR_4);
      }
      VAR_1 = VAR_1->cdr->cdr->car;
      if (VAR_1) {
        if (VAR_1->car) {            /* COMMENT_4 */
          VAR_30 = gen_values(VAR_0, VAR_1->car, VAR_15, (VAR_1->cdr->car)?13:14);
          if (VAR_30 < 0) {              /* COMMENT_5 */
            VAR_30 = 15;
            push();
          }
        }
        if (VAR_1->cdr->car) {       /* COMMENT_6 */
          if (VAR_30 == 14) {
            pop_n(VAR_30);
            genop_2(VAR_0, VAR_34, cursp(), VAR_30);
            push();
            VAR_30 = 15;
          }
          gen_hash(VAR_0, VAR_1->cdr->car->cdr, VAR_15, 0);
          if (VAR_30 < 14) {
            VAR_30++;
          }
          else {
            pop_n(2);
            genop_2(VAR_0, VAR_35, cursp(), 1);
          }
          push();
        }
      }
      if (VAR_2) {
        codegen(VAR_0, VAR_2, VAR_15);
        pop();
      }
      else {
        gen_move(VAR_0, cursp(), VAR_3, 0);
      }
      if (VAR_4) {
        gen_move(VAR_0, VAR_28, cursp(), 1);
      }
      if (VAR_30 < 14) {
        VAR_30++;
      }
      else {
        pop();
        genop_2(VAR_0, VAR_35, cursp(), 1);
      }
      VAR_0->sp = VAR_29;
      if (VAR_31 == MRB_OPSYM_2(VAR_0->mrb, VAR_36) && VAR_30 == 2) {
        genop_1(VAR_0, VAR_37, cursp());
      }
      else {
        genop_3(VAR_0, VAR_25 ? VAR_38 : VAR_39, cursp(), new_sym(VAR_0, attrsym(VAR_0, VAR_31)), VAR_30);
      }
      if (VAR_26) {
        dispatch(VAR_0, VAR_27);
      }
      VAR_0->sp = VAR_28;
    }
    break;

  case VAR_14:
    gen_vmassignment(VAR_0, VAR_1->car, VAR_3, VAR_4);
    break;

  /* COMMENT_7 */
  case VAR_13:
    break;

  default:
    codegen_error(VAR_0, ""unknown lhs"");
    break;
  }
  if (VAR_4) push();
}",mruby/0849a2885f81cfd82134992c06df3ccd59052ac7/codegen.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -111,15 +111,21 @@
           }
         }
         if (tree->cdr->car) {       /* keyword arguments */
+          if (n == 14) {
+            pop_n(n);
+            genop_2(s, OP_ARRAY, cursp(), n);
+            push();
+            n = 15;
+          }
           gen_hash(s, tree->cdr->car->cdr, VAL, 0);
           if (n < 14) {
             n++;
-            push();
           }
           else {
-            pop();
+            pop_n(2);
             genop_2(s, OP_ARYPUSH, cursp(), 1);
           }
+          push();
         }
       }
       if (rhs) {","{'deleted_lines': ['            push();', '            pop();'], 'added_lines': ['          if (n == 14) {', '            pop_n(n);', '            genop_2(s, OP_ARRAY, cursp(), n);', '            push();', '            n = 15;', '          }', '            pop_n(2);', '          push();']}",True,Out-of-bounds Read in Homebrew mruby prior to 3.2.,9.1,CRITICAL,3,test,2022-02-08T03:46:36Z,4
CVE-2022-1199,['CWE-416'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"ax25: fix NPD bug in ax25_disconnect

The ax25_disconnect() in ax25_kill_by_device() is not
protected by any locks, thus there is a race condition
between ax25_disconnect() and ax25_destroy_socket().
when ax25->sk is assigned as NULL by ax25_destroy_socket(),
a NULL pointer dereference bug will occur if site (1) or (2)
dereferences ax25->sk.

ax25_kill_by_device()                | ax25_release()
  ax25_disconnect()                  |   ax25_destroy_socket()
    ...                              |
    if(ax25->sk != NULL)             |     ...
      ...                            |     ax25->sk = NULL;
      bh_lock_sock(ax25->sk); //(1)  |     ...
      ...                            |
      bh_unlock_sock(ax25->sk); //(2)|

This patch moves ax25_disconnect() into lock_sock(), which can
synchronize with ax25_destroy_socket() in ax25_release().

Fail log:
===============================================================
BUG: kernel NULL pointer dereference, address: 0000000000000088
...
RIP: 0010:_raw_spin_lock+0x7e/0xd0
...
Call Trace:
ax25_disconnect+0xf6/0x220
ax25_device_event+0x187/0x250
raw_notifier_call_chain+0x5e/0x70
dev_close_many+0x17d/0x230
rollback_registered_many+0x1f1/0x950
unregister_netdevice_queue+0x133/0x200
unregister_netdev+0x13/0x20
...

Signed-off-by: Duoming Zhou <duoming@zju.edu.cn>
Signed-off-by: David S. Miller <davem@davemloft.net>",7ec02f5ac8a5be5a3f20611731243dc5e1d9ba10,https://github.com/torvalds/linux/commit/7ec02f5ac8a5be5a3f20611731243dc5e1d9ba10,net/ax25/af_ax25.c,ax25_kill_by_device,"static void ax25_kill_by_device(struct net_device *dev)
{
ax25_dev *ax25_dev;
ax25_cb *s;
struct sock *sk;
if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)
return;
spin_lock_bh(&ax25_list_lock);
again:
ax25_for_each(s, &ax25_list) {
if (s->ax25_dev == ax25_dev) {
sk = s->sk;
sock_hold(sk);
spin_unlock_bh(&ax25_list_lock);
lock_sock(sk);
s->ax25_dev = NULL;
ax25_dev_put(ax25_dev);
release_sock(sk);
ax25_disconnect(s, ENETUNREACH);
spin_lock_bh(&ax25_list_lock);
sock_put(sk);
goto again;
}
}
spin_unlock_bh(&ax25_list_lock);
}","static void ax25_kill_by_device(struct net_device *VAR_0)
{
ax25_dev *ax25_dev;
ax25_cb *VAR_1;
struct sock *VAR_2;
if ((ax25_dev = ax25_dev_ax25dev(VAR_0)) == NULL)
return;
spin_lock_bh(&VAR_3);
again:
ax25_for_each(VAR_1, &VAR_4) {
if (VAR_1->ax25_dev == ax25_dev) {
VAR_2 = VAR_1->sk;
sock_hold(VAR_2);
spin_unlock_bh(&VAR_3);
lock_sock(VAR_2);
VAR_1->ax25_dev = NULL;
ax25_dev_put(ax25_dev);
release_sock(VAR_2);
ax25_disconnect(VAR_1, VAR_5);
spin_lock_bh(&VAR_3);
sock_put(VAR_2);
goto again;
}
}
spin_unlock_bh(&VAR_3);
}",torvalds/linux/7ec02f5ac8a5be5a3f20611731243dc5e1d9ba10/af_ax25.c/vul/before/0.json,"static void ax25_kill_by_device(struct net_device *dev)
{
	ax25_dev *ax25_dev;
	ax25_cb *s;
	struct sock *sk;

	if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)
		return;

	spin_lock_bh(&ax25_list_lock);
again:
	ax25_for_each(s, &ax25_list) {
		if (s->ax25_dev == ax25_dev) {
			sk = s->sk;
			sock_hold(sk);
			spin_unlock_bh(&ax25_list_lock);
			lock_sock(sk);
			s->ax25_dev = NULL;
			ax25_dev_put(ax25_dev);
			ax25_disconnect(s, ENETUNREACH);
			release_sock(sk);
			spin_lock_bh(&ax25_list_lock);
			sock_put(sk);
			/* The entry could have been deleted from the
			 * list meanwhile and thus the next pointer is
			 * no longer valid.  Play it safe and restart
			 * the scan.  Forward progress is ensured
			 * because we set s->ax25_dev to NULL and we
			 * are never passed a NULL 'dev' argument.
			 */
			goto again;
		}
	}
	spin_unlock_bh(&ax25_list_lock);
}","static void ax25_kill_by_device(struct net_device *VAR_0)
{
	ax25_dev *ax25_dev;
	ax25_cb *VAR_1;
	struct sock *VAR_2;

	if ((ax25_dev = ax25_dev_ax25dev(VAR_0)) == NULL)
		return;

	spin_lock_bh(&VAR_3);
again:
	ax25_for_each(VAR_1, &VAR_4) {
		if (VAR_1->ax25_dev == ax25_dev) {
			VAR_2 = VAR_1->sk;
			sock_hold(VAR_2);
			spin_unlock_bh(&VAR_3);
			lock_sock(VAR_2);
			VAR_1->ax25_dev = NULL;
			ax25_dev_put(ax25_dev);
			ax25_disconnect(VAR_1, VAR_5);
			release_sock(VAR_2);
			spin_lock_bh(&VAR_3);
			sock_put(VAR_2);
			/* COMMENT_0 */
                                                 
                                                
                                            
                                               
                                             
      
			goto again;
		}
	}
	spin_unlock_bh(&VAR_3);
}",torvalds/linux/7ec02f5ac8a5be5a3f20611731243dc5e1d9ba10/af_ax25.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,8 +17,8 @@
 			lock_sock(sk);
 			s->ax25_dev = NULL;
 			ax25_dev_put(ax25_dev);
+			ax25_disconnect(s, ENETUNREACH);
 			release_sock(sk);
-			ax25_disconnect(s, ENETUNREACH);
 			spin_lock_bh(&ax25_list_lock);
 			sock_put(sk);
 			/* The entry could have been deleted from the","{'deleted_lines': ['\t\t\tax25_disconnect(s, ENETUNREACH);'], 'added_lines': ['\t\t\tax25_disconnect(s, ENETUNREACH);']}",True,"A flaw was found in the Linux kernel. This flaw allows an attacker to crash the Linux kernel by simulating amateur radio from the user space, resulting in a null-ptr-deref vulnerability and a use-after-free vulnerability.",7.5,HIGH,2,test,2022-02-08T15:40:00Z,4
CVE-2022-0559,['CWE-416'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,radareorg/radare2,"Prefer memleak over usaf in io.bank's rbtree bug ##crash

* That's a workaround, proper fix will come later
* Reproducer: bins/fuzzed/iobank-crash
* Reported by Akyne Choi via huntr.dev",b5cb90b28ec71fda3504da04e3cc94a362807f5e,https://github.com/radareorg/radare2/commit/b5cb90b28ec71fda3504da04e3cc94a362807f5e,libr/util/new_rbtree.c,r_crbtree_insert,"R_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {
r_return_val_if_fail (tree && data && cmp, false);
bool inserted = false;
if (tree->root == NULL) {
tree->root = _node_new (data, NULL);
if (tree->root == NULL) {
return false;
}
inserted = true;
goto out_exit;
}
RRBNode head; 
memset (&head, 0, sizeof (RRBNode));
RRBNode *g = NULL, *parent = &head; 
RRBNode *p = NULL, *q = tree->root; 
int dir = 0, last = 0; 
_set_link (parent, q, 1);
for (;;) {
if (!q) {
q = _node_new (data, p);
if (!q) {
return false;
}
p->link[dir] = q;
inserted = true;
} else if (IS_RED (q->link[0]) && IS_RED (q->link[1])) {
q->red = 1;
q->link[0]->red = 0;
q->link[1]->red = 0;
}
if (IS_RED (q) && IS_RED (p)) {
#if 0
if (!parent) {
return false;
}
#endif
int dir2 = parent->link[1] == g;
if (q == p->link[last]) {
_set_link (parent, _rot_once (g, !last), dir2);
} else {
_set_link (parent, _rot_twice (g, !last), dir2);
}
}
if (inserted) {
break;
}
last = dir;
dir = cmp (data, q->data, user) >= 0;
if (g) {
parent = g;
}
g = p;
p = q;
q = q->link[dir];
}
tree->root = head.link[1];
out_exit:
tree->root->red = 0;
tree->root->parent = NULL;
if (inserted) {
tree->size++;
}
return inserted;
}","R_API bool r_crbtree_insert(RRBTree *VAR_0, void *VAR_1, RRBComparator VAR_2, void *VAR_3) {
r_return_val_if_fail (VAR_0 && VAR_1 && VAR_2, false);
bool VAR_4 = false;
if (VAR_0->root == NULL) {
VAR_0->root = _node_new (VAR_1, NULL);
if (VAR_0->root == NULL) {
return false;
}
VAR_4 = true;
goto out_exit;
}
RRBNode VAR_5; 
memset (&VAR_5, 0, sizeof (RRBNode));
RRBNode *VAR_6 = NULL, *VAR_7 = &VAR_5; 
RRBNode *VAR_8 = NULL, *VAR_9 = VAR_0->root; 
int VAR_10 = 0, VAR_11 = 0; 
_set_link (VAR_7, VAR_9, 1);
for (;;) {
if (!VAR_9) {
VAR_9 = _node_new (VAR_1, VAR_8);
if (!VAR_9) {
return false;
}
VAR_8->link[VAR_10] = VAR_9;
VAR_4 = true;
} else if (IS_RED (VAR_9->link[0]) && IS_RED (VAR_9->link[1])) {
VAR_9->red = 1;
VAR_9->link[0]->red = 0;
VAR_9->link[1]->red = 0;
}
if (IS_RED (VAR_9) && IS_RED (VAR_8)) {
#if 0
if (!VAR_7) {
return false;
}
#endif
int VAR_12 = VAR_7->link[1] == VAR_6;
if (VAR_9 == VAR_8->link[VAR_11]) {
_set_link (VAR_7, _rot_once (VAR_6, !VAR_11), VAR_12);
} else {
_set_link (VAR_7, _rot_twice (VAR_6, !VAR_11), VAR_12);
}
}
if (VAR_4) {
break;
}
VAR_11 = VAR_10;
VAR_10 = VAR_2 (VAR_1, VAR_9->data, VAR_3) >= 0;
if (VAR_6) {
VAR_7 = VAR_6;
}
VAR_6 = VAR_8;
VAR_8 = VAR_9;
VAR_9 = VAR_9->link[VAR_10];
}
VAR_0->root = VAR_5.link[1];
out_exit:
VAR_0->root->red = 0;
VAR_0->root->parent = NULL;
if (VAR_4) {
VAR_0->size++;
}
return VAR_4;
}",,"R_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {
	r_return_val_if_fail (tree && data && cmp, false);
	bool inserted = false;

	if (!tree->root) {
		tree->root = _node_new (data, NULL);
		if (!tree->root) {
			return false;
		}
		inserted = true;
		goto out_exit;
	}

	RRBNode head; /* Fake tree root */
	memset (&head, 0, sizeof (RRBNode));
	RRBNode *g = NULL, *parent = &head; /* Grandparent & parent */
	RRBNode *p = NULL, *q = tree->root; /* Iterator & parent */
	int dir = 0, last = 0; /* Directions */

	_set_link (parent, q, 1);

	for (;;) {
		if (!q) {
			/* Insert a node at first null link(also set its parent link) */
			q = _node_new (data, p);
			if (!q) {
				return false;
			}
			p->link[dir] = q;
			inserted = true;
		} else if (IS_RED (q->link[0]) && IS_RED (q->link[1])) {
			/* Simple red violation: color flip */
			q->red = 1;
			q->link[0]->red = 0;
			q->link[1]->red = 0;
		}

		if (IS_RED (q) && IS_RED (p)) {
#if 0
			// coverity error, parent is never null
			/* Hard red violation: rotate */
			if (!parent) {
				return false;
			}
#endif
			int dir2 = parent->link[1] == g;
			if (q == p->link[last]) {
				_set_link (parent, _rot_once (g, !last), dir2);
			} else {
				_set_link (parent, _rot_twice (g, !last), dir2);
			}
		}

		if (inserted) {
			break;
		}

		last = dir;
		dir = cmp (data, q->data, user) >= 0;

		if (g) {
			parent = g;
		}

		g = p;
		p = q;
		q = q->link[dir];
	}

	/* Update root(it may different due to root rotation) */
	tree->root = head.link[1];

out_exit:
	/* Invariant: root is black */
	tree->root->red = 0;
	tree->root->parent = NULL;
	if (inserted) {
		tree->size++;
	}

	return inserted;
}","R_API bool r_crbtree_insert(RRBTree *VAR_0, void *VAR_1, RRBComparator VAR_2, void *VAR_3) {
	r_return_val_if_fail (VAR_0 && VAR_1 && VAR_2, false);
	bool VAR_4 = false;

	if (!VAR_0->root) {
		VAR_0->root = _node_new (VAR_1, NULL);
		if (!VAR_0->root) {
			return false;
		}
		VAR_4 = true;
		goto out_exit;
	}

	RRBNode VAR_5; /* COMMENT_0 */
	memset (&VAR_5, 0, sizeof (RRBNode));
	RRBNode *VAR_6 = NULL, *VAR_7 = &VAR_5; /* COMMENT_1 */
	RRBNode *VAR_8 = NULL, *VAR_9 = VAR_0->root; /* COMMENT_2 */
	int VAR_10 = 0, VAR_11 = 0; /* COMMENT_3 */

	_set_link (VAR_7, VAR_9, 1);

	for (;;) {
		if (!VAR_9) {
			/* COMMENT_4 */
			VAR_9 = _node_new (VAR_1, VAR_8);
			if (!VAR_9) {
				return false;
			}
			VAR_8->link[VAR_10] = VAR_9;
			VAR_4 = true;
		} else if (IS_RED (VAR_9->link[0]) && IS_RED (VAR_9->link[1])) {
			/* COMMENT_5 */
			VAR_9->red = 1;
			VAR_9->link[0]->red = 0;
			VAR_9->link[1]->red = 0;
		}

		if (IS_RED (VAR_9) && IS_RED (VAR_8)) {
#if 0
			/* COMMENT_6 */
			/* COMMENT_7 */
			if (!VAR_7) {
				return false;
			}
#endif
			int VAR_12 = VAR_7->link[1] == VAR_6;
			if (VAR_9 == VAR_8->link[VAR_11]) {
				_set_link (VAR_7, _rot_once (VAR_6, !VAR_11), VAR_12);
			} else {
				_set_link (VAR_7, _rot_twice (VAR_6, !VAR_11), VAR_12);
			}
		}

		if (VAR_4) {
			break;
		}

		VAR_11 = VAR_10;
		VAR_10 = VAR_2 (VAR_1, VAR_9->data, VAR_3) >= 0;

		if (VAR_6) {
			VAR_7 = VAR_6;
		}

		VAR_6 = VAR_8;
		VAR_8 = VAR_9;
		VAR_9 = VAR_9->link[VAR_10];
	}

	/* COMMENT_8 */
	VAR_0->root = VAR_5.link[1];

out_exit:
	/* COMMENT_9 */
	VAR_0->root->red = 0;
	VAR_0->root->parent = NULL;
	if (VAR_4) {
		VAR_0->size++;
	}

	return VAR_4;
}",,"--- func_before
+++ func_after
@@ -2,9 +2,9 @@
 	r_return_val_if_fail (tree && data && cmp, false);
 	bool inserted = false;
 
-	if (tree->root == NULL) {
+	if (!tree->root) {
 		tree->root = _node_new (data, NULL);
-		if (tree->root == NULL) {
+		if (!tree->root) {
 			return false;
 		}
 		inserted = true;","{'deleted_lines': ['\tif (tree->root == NULL) {', '\t\tif (tree->root == NULL) {'], 'added_lines': ['\tif (!tree->root) {', '\t\tif (!tree->root) {']}",True,Use After Free in GitHub repository radareorg/radare2 prior to 5.6.2.,9.8,CRITICAL,3,test,2022-02-13T20:27:58Z,4
CVE-2022-0559,['CWE-416'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,radareorg/radare2,"Prefer memleak over usaf in io.bank's rbtree bug ##crash

* That's a workaround, proper fix will come later
* Reproducer: bins/fuzzed/iobank-crash
* Reported by Akyne Choi via huntr.dev",b5cb90b28ec71fda3504da04e3cc94a362807f5e,https://github.com/radareorg/radare2/commit/b5cb90b28ec71fda3504da04e3cc94a362807f5e,libr/io/io_bank.c,r_io_bank_map_add_top,"R_API bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {
RIOBank *bank = r_io_bank_get (io, bankid);
RIOMap *map = r_io_map_get (io, mapid);
r_return_val_if_fail (io && bank && map, false);
RIOMapRef *mapref = _mapref_from_map (map);
if (!mapref) {
return false;
}
RIOSubMap *sm = r_io_submap_new (io, mapref);
if (!sm) {
free (mapref);
return false;
}
RRBNode *entry = _find_entry_submap_node (bank, sm);
if (!entry) {
if (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {
free (sm);
free (mapref);
return false;
}
r_list_append (bank->maprefs, mapref);
return true;
}
bank->last_used = NULL;
RIOSubMap *bd = (RIOSubMap *)entry->data;
if (r_io_submap_to (bd) == r_io_submap_to (sm) &&
r_io_submap_from (bd) >= r_io_submap_from (sm)) {
memcpy (bd, sm, sizeof (RIOSubMap));
free (sm);
r_list_append (bank->maprefs, mapref);
return true;
}
if (r_io_submap_from (bd) < r_io_submap_from (sm) &&
r_io_submap_to (sm) < r_io_submap_to (bd)) {
RIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);
if (!bdsm) {
free (sm);
free (mapref);
return false;
}
r_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);
r_io_submap_set_to (bd, r_io_submap_from (sm) - 1);
if (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {
free (sm);
free (bdsm);
free (mapref);
return false;
}
if (!r_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL)) {
r_crbtree_delete (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);
free (sm);
free (bdsm);
free (mapref);
return false;
}
r_list_append (bank->maprefs, mapref);
return true;
}
if (r_io_submap_from (bd) < r_io_submap_from (sm)) {
r_io_submap_set_to (bd, r_io_submap_from (sm) - 1);
entry = r_rbnode_next (entry);
}
while (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {
RRBNode *next = r_rbnode_next (entry);
bool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);
if (!a) {
break;
}
entry = next;
}
if (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {
bd = (RIOSubMap *)entry->data;
r_io_submap_set_from (bd, r_io_submap_to (sm) + 1);
}
if (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {
free (sm);
free (mapref);
return false;
}
r_list_append (bank->maprefs, mapref);
return true;
}","R_API bool r_io_bank_map_add_top(RIO *VAR_0, const ut32 VAR_1, const ut32 VAR_2) {
RIOBank *VAR_3 = r_io_bank_get (VAR_0, VAR_1);
RIOMap *VAR_4 = r_io_map_get (VAR_0, VAR_2);
r_return_val_if_fail (VAR_0 && VAR_3 && VAR_4, false);
RIOMapRef *VAR_5 = _mapref_from_map (VAR_4);
if (!VAR_5) {
return false;
}
RIOSubMap *VAR_6 = r_io_submap_new (VAR_0, VAR_5);
if (!VAR_6) {
free (VAR_5);
return false;
}
RRBNode *VAR_7 = _find_entry_submap_node (VAR_3, VAR_6);
if (!VAR_7) {
if (!r_crbtree_insert (VAR_3->submaps, VAR_6, VAR_8, NULL)) {
free (VAR_6);
free (VAR_5);
return false;
}
r_list_append (VAR_3->maprefs, VAR_5);
return true;
}
VAR_3->last_used = NULL;
RIOSubMap *VAR_9 = (RIOSubMap *)VAR_7->data;
if (r_io_submap_to (VAR_9) == r_io_submap_to (VAR_6) &&
r_io_submap_from (VAR_9) >= r_io_submap_from (VAR_6)) {
memcpy (VAR_9, VAR_6, sizeof (RIOSubMap));
free (VAR_6);
r_list_append (VAR_3->maprefs, VAR_5);
return true;
}
if (r_io_submap_from (VAR_9) < r_io_submap_from (VAR_6) &&
r_io_submap_to (VAR_6) < r_io_submap_to (VAR_9)) {
RIOSubMap *VAR_10 = R_NEWCOPY (RIOSubMap, VAR_9);
if (!VAR_10) {
free (VAR_6);
free (VAR_5);
return false;
}
r_io_submap_set_from (VAR_10, r_io_submap_to (VAR_6) + 1);
r_io_submap_set_to (VAR_9, r_io_submap_from (VAR_6) - 1);
if (!r_crbtree_insert (VAR_3->submaps, VAR_6, VAR_8, NULL)) {
free (VAR_6);
free (VAR_10);
free (VAR_5);
return false;
}
if (!r_crbtree_insert (VAR_3->submaps, VAR_10, VAR_8, NULL)) {
r_crbtree_delete (VAR_3->submaps, VAR_6, VAR_8, NULL);
free (VAR_6);
free (VAR_10);
free (VAR_5);
return false;
}
r_list_append (VAR_3->maprefs, VAR_5);
return true;
}
if (r_io_submap_from (VAR_9) < r_io_submap_from (VAR_6)) {
r_io_submap_set_to (VAR_9, r_io_submap_from (VAR_6) - 1);
VAR_7 = r_rbnode_next (VAR_7);
}
while (VAR_7 && r_io_submap_to (((RIOSubMap *)VAR_7->data)) <= r_io_submap_to (VAR_6)) {
RRBNode *VAR_11 = r_rbnode_next (VAR_7);
bool VAR_12 = r_crbtree_delete (VAR_3->submaps, VAR_7->data, VAR_8, NULL);
if (!VAR_12) {
break;
}
VAR_7 = VAR_11;
}
if (VAR_7 && r_io_submap_from (((RIOSubMap *)VAR_7->data)) <= r_io_submap_to (VAR_6)) {
VAR_9 = (RIOSubMap *)VAR_7->data;
r_io_submap_set_from (VAR_9, r_io_submap_to (VAR_6) + 1);
}
if (!r_crbtree_insert (VAR_3->submaps, VAR_6, VAR_8, NULL)) {
free (VAR_6);
free (VAR_5);
return false;
}
r_list_append (VAR_3->maprefs, VAR_5);
return true;
}",,"R_API bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {
	RIOBank *bank = r_io_bank_get (io, bankid);
	RIOMap *map = r_io_map_get (io, mapid);
	r_return_val_if_fail (io && bank && map, false);
	RIOMapRef *mapref = _mapref_from_map (map);
	if (!mapref) {
		return false;
	}
	RIOSubMap *sm = r_io_submap_new (io, mapref);
	if (!sm) {
		free (mapref);
		return false;
	}
	RRBNode *entry = _find_entry_submap_node (bank, sm);
	if (!entry) {
		// no intersection with any submap, so just insert
		if (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {
			free (sm);
			free (mapref);
			return false;
		}
		r_list_append (bank->maprefs, mapref);
		return true;
	}
	bank->last_used = NULL;
	RIOSubMap *bd = (RIOSubMap *)entry->data;
	if (r_io_submap_to (bd) == r_io_submap_to (sm) &&
		r_io_submap_from (bd) >= r_io_submap_from (sm)) {
		// _find_entry_submap_node guarantees, that there is no submap
		// prior to bd in the range of sm, so instead of deleting and inserting
		// we can just memcpy
		memcpy (bd, sm, sizeof (RIOSubMap));
		free (sm);
		r_list_append (bank->maprefs, mapref);
		return true;
	}
	if (r_io_submap_from (bd) < r_io_submap_from (sm) &&
		r_io_submap_to (sm) < r_io_submap_to (bd)) {
		// split bd into 2 maps => bd and bdsm
		RIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);
		if (!bdsm) {
			free (sm);
			free (mapref);
			return false;
		}
		r_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);
		r_io_submap_set_to (bd, r_io_submap_from (sm) - 1);
		// TODO: insert and check return value, before adjusting sm size
		if (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {
			free (sm);
			free (bdsm);
			free (mapref);
			return false;
		}
		if (!r_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL)) {
			r_crbtree_delete (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);
			free (sm);
			free (bdsm);
			free (mapref);
			return false;
		}
		r_list_append (bank->maprefs, mapref);
		return true;
	}

	// guaranteed intersection
	if (r_io_submap_from (bd) < r_io_submap_from (sm)) {
		r_io_submap_set_to (bd, r_io_submap_from (sm) - 1);
		entry = r_rbnode_next (entry);
	}
	ut64 smto = r_io_submap_to (sm);
	while (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= smto) {
		//delete all submaps that are completly included in sm
		RRBNode *next = r_rbnode_next (entry);
		// this can be optimized, there is no need to do search here
		// XXX this is a workaround to avoid an UAF in Reproducer: iobank-crash
		void *smfree = bank->submaps->free;
		bank->submaps->free = NULL;
		bool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);
		bank->submaps->free = smfree;
		if (!a) {
			entry = NULL;
			break;
		}
		entry = next;
	}
	if (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {
		bd = (RIOSubMap *)entry->data;
		r_io_submap_set_from (bd, r_io_submap_to (sm) + 1);
	}
	if (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {
		free (sm);
		free (mapref);
		return false;
	}
	r_list_append (bank->maprefs, mapref);
	return true;
}","R_API bool r_io_bank_map_add_top(RIO *VAR_0, const ut32 VAR_1, const ut32 VAR_2) {
	RIOBank *VAR_3 = r_io_bank_get (VAR_0, VAR_1);
	RIOMap *VAR_4 = r_io_map_get (VAR_0, VAR_2);
	r_return_val_if_fail (VAR_0 && VAR_3 && VAR_4, false);
	RIOMapRef *VAR_5 = _mapref_from_map (VAR_4);
	if (!VAR_5) {
		return false;
	}
	RIOSubMap *VAR_6 = r_io_submap_new (VAR_0, VAR_5);
	if (!VAR_6) {
		free (VAR_5);
		return false;
	}
	RRBNode *VAR_7 = _find_entry_submap_node (VAR_3, VAR_6);
	if (!VAR_7) {
		/* COMMENT_0 */
		if (!r_crbtree_insert (VAR_3->submaps, VAR_6, VAR_8, NULL)) {
			free (VAR_6);
			free (VAR_5);
			return false;
		}
		r_list_append (VAR_3->maprefs, VAR_5);
		return true;
	}
	VAR_3->last_used = NULL;
	RIOSubMap *VAR_9 = (RIOSubMap *)VAR_7->data;
	if (r_io_submap_to (VAR_9) == r_io_submap_to (VAR_6) &&
		r_io_submap_from (VAR_9) >= r_io_submap_from (VAR_6)) {
		/* COMMENT_1 */
		/* COMMENT_2 */
		/* COMMENT_3 */
		memcpy (VAR_9, VAR_6, sizeof (RIOSubMap));
		free (VAR_6);
		r_list_append (VAR_3->maprefs, VAR_5);
		return true;
	}
	if (r_io_submap_from (VAR_9) < r_io_submap_from (VAR_6) &&
		r_io_submap_to (VAR_6) < r_io_submap_to (VAR_9)) {
		/* COMMENT_4 */
		RIOSubMap *VAR_10 = R_NEWCOPY (RIOSubMap, VAR_9);
		if (!VAR_10) {
			free (VAR_6);
			free (VAR_5);
			return false;
		}
		r_io_submap_set_from (VAR_10, r_io_submap_to (VAR_6) + 1);
		r_io_submap_set_to (VAR_9, r_io_submap_from (VAR_6) - 1);
		/* COMMENT_5 */
		if (!r_crbtree_insert (VAR_3->submaps, VAR_6, VAR_8, NULL)) {
			free (VAR_6);
			free (VAR_10);
			free (VAR_5);
			return false;
		}
		if (!r_crbtree_insert (VAR_3->submaps, VAR_10, VAR_8, NULL)) {
			r_crbtree_delete (VAR_3->submaps, VAR_6, VAR_8, NULL);
			free (VAR_6);
			free (VAR_10);
			free (VAR_5);
			return false;
		}
		r_list_append (VAR_3->maprefs, VAR_5);
		return true;
	}

	/* COMMENT_6 */
	if (r_io_submap_from (VAR_9) < r_io_submap_from (VAR_6)) {
		r_io_submap_set_to (VAR_9, r_io_submap_from (VAR_6) - 1);
		VAR_7 = r_rbnode_next (VAR_7);
	}
	ut64 VAR_11 = r_io_submap_to (VAR_6);
	while (VAR_7 && r_io_submap_to (((RIOSubMap *)VAR_7->data)) <= VAR_11) {
		/* COMMENT_7 */
		RRBNode *VAR_12 = r_rbnode_next (VAR_7);
		/* COMMENT_8 */
		/* COMMENT_9 */
		void *VAR_13 = VAR_3->submaps->free;
		VAR_3->submaps->free = NULL;
		bool VAR_14 = r_crbtree_delete (VAR_3->submaps, VAR_7->data, VAR_8, NULL);
		VAR_3->submaps->free = VAR_13;
		if (!VAR_14) {
			VAR_7 = NULL;
			break;
		}
		VAR_7 = VAR_12;
	}
	if (VAR_7 && r_io_submap_from (((RIOSubMap *)VAR_7->data)) <= r_io_submap_to (VAR_6)) {
		VAR_9 = (RIOSubMap *)VAR_7->data;
		r_io_submap_set_from (VAR_9, r_io_submap_to (VAR_6) + 1);
	}
	if (!r_crbtree_insert (VAR_3->submaps, VAR_6, VAR_8, NULL)) {
		free (VAR_6);
		free (VAR_5);
		return false;
	}
	r_list_append (VAR_3->maprefs, VAR_5);
	return true;
}",,"--- func_before
+++ func_after
@@ -68,12 +68,18 @@
 		r_io_submap_set_to (bd, r_io_submap_from (sm) - 1);
 		entry = r_rbnode_next (entry);
 	}
-	while (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {
+	ut64 smto = r_io_submap_to (sm);
+	while (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= smto) {
 		//delete all submaps that are completly included in sm
 		RRBNode *next = r_rbnode_next (entry);
 		// this can be optimized, there is no need to do search here
+		// XXX this is a workaround to avoid an UAF in Reproducer: iobank-crash
+		void *smfree = bank->submaps->free;
+		bank->submaps->free = NULL;
 		bool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);
+		bank->submaps->free = smfree;
 		if (!a) {
+			entry = NULL;
 			break;
 		}
 		entry = next;","{'deleted_lines': ['\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {'], 'added_lines': ['\tut64 smto = r_io_submap_to (sm);', '\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= smto) {', '\t\t// XXX this is a workaround to avoid an UAF in Reproducer: iobank-crash', '\t\tvoid *smfree = bank->submaps->free;', '\t\tbank->submaps->free = NULL;', '\t\tbank->submaps->free = smfree;', '\t\t\tentry = NULL;']}",True,Use After Free in GitHub repository radareorg/radare2 prior to 5.6.2.,9.8,CRITICAL,3,test,2022-02-13T20:27:58Z,4
CVE-2022-0696,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vim,"patch 8.2.4428: crash when switching tabpage while in the cmdline window

Problem:    Crash when switching tabpage while in the cmdline window.
Solution:   Disallow switching tabpage when in the cmdline window.",0f6e28f686dbb59ab3b562408ab9b2234797b9b1,https://github.com/vim/vim/commit/0f6e28f686dbb59ab3b562408ab9b2234797b9b1,src/usercmd.c,get_user_command_name,"char_u *
get_user_command_name(int idx, int cmdidx)
{
if (cmdidx == CMD_USER && idx < ucmds.ga_len)
return USER_CMD(idx)->uc_name;
if (cmdidx == CMD_USER_BUF)
{
buf_T *buf =
#ifdef FEAT_CMDWIN
is_in_cmdwin() ? prevwin->w_buffer :
#endif
curbuf;
if (idx < buf->b_ucmds.ga_len)
return USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;
}
return NULL;
}","char_u *
get_user_command_name(int VAR_0, int VAR_1)
{
if (VAR_1 == VAR_2 && VAR_0 < VAR_3.ga_len)
return USER_CMD(VAR_0)->uc_name;
if (VAR_1 == VAR_4)
{
buf_T *VAR_5 =
#ifdef VAR_6
is_in_cmdwin() ? VAR_7->w_buffer :
#endif
VAR_8;
if (VAR_0 < VAR_5->b_ucmds.ga_len)
return USER_CMD_GA(&VAR_5->b_ucmds, VAR_0)->uc_name;
}
return NULL;
}",vim/0f6e28f686dbb59ab3b562408ab9b2234797b9b1/usercmd.c/vul/before/3.json,"char_u *
get_user_command_name(int idx, int cmdidx)
{
    if (cmdidx == CMD_USER && idx < ucmds.ga_len)
	return USER_CMD(idx)->uc_name;
    if (cmdidx == CMD_USER_BUF)
    {
	// In cmdwin, the alternative buffer should be used.
	buf_T *buf = prevwin_curwin()->w_buffer;

	if (idx < buf->b_ucmds.ga_len)
	    return USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;
    }
    return NULL;
}","char_u *
get_user_command_name(int VAR_0, int VAR_1)
{
    if (VAR_1 == VAR_2 && VAR_0 < VAR_3.ga_len)
	return USER_CMD(VAR_0)->uc_name;
    if (VAR_1 == VAR_4)
    {
	/* COMMENT_0 */
	buf_T *VAR_5 = prevwin_curwin()->w_buffer;

	if (VAR_0 < VAR_5->b_ucmds.ga_len)
	    return USER_CMD_GA(&VAR_5->b_ucmds, VAR_0)->uc_name;
    }
    return NULL;
}",vim/0f6e28f686dbb59ab3b562408ab9b2234797b9b1/usercmd.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -6,11 +6,7 @@
     if (cmdidx == CMD_USER_BUF)
     {
 	// In cmdwin, the alternative buffer should be used.
-	buf_T *buf =
-#ifdef FEAT_CMDWIN
-		    is_in_cmdwin() ? prevwin->w_buffer :
-#endif
-		    curbuf;
+	buf_T *buf = prevwin_curwin()->w_buffer;
 
 	if (idx < buf->b_ucmds.ga_len)
 	    return USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;","{'deleted_lines': ['\tbuf_T *buf =', '#ifdef FEAT_CMDWIN', '\t\t    is_in_cmdwin() ? prevwin->w_buffer :', '#endif', '\t\t    curbuf;'], 'added_lines': ['\tbuf_T *buf = prevwin_curwin()->w_buffer;']}",True,NULL Pointer Dereference in GitHub repository vim/vim prior to 8.2.4428.,5.5,MEDIUM,1,test,2022-02-20T20:49:35Z,4
CVE-2022-0696,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vim,"patch 8.2.4428: crash when switching tabpage while in the cmdline window

Problem:    Crash when switching tabpage while in the cmdline window.
Solution:   Disallow switching tabpage when in the cmdline window.",0f6e28f686dbb59ab3b562408ab9b2234797b9b1,https://github.com/vim/vim/commit/0f6e28f686dbb59ab3b562408ab9b2234797b9b1,src/usercmd.c,uc_list,"static void
uc_list(char_u *name, size_t name_len)
{
inti, j;
intfound = FALSE;
ucmd_T*cmd;
intlen;
intover;
longa;
garray_T*gap;
gap =
#ifdef FEAT_CMDWIN
is_in_cmdwin() ? &prevwin->w_buffer->b_ucmds :
#endif
&curbuf->b_ucmds;
for (;;)
{
for (i = 0; i < gap->ga_len; ++i)
{
cmd = USER_CMD_GA(gap, i);
a = (long)cmd->uc_argt;
if (STRNCMP(name, cmd->uc_name, name_len) != 0
|| message_filtered(cmd->uc_name))
continue;
if (!found)
msg_puts_title(_(""\n    Name              Args Address Complete    Definition""));
found = TRUE;
msg_putchar('\n');
if (got_int)
break;
len = 4;
if (a & EX_BANG)
{
msg_putchar('!');
--len;
}
if (a & EX_REGSTR)
{
msg_putchar('""');
--len;
}
if (gap != &ucmds)
{
msg_putchar('b');
--len;
}
if (a & EX_TRLBAR)
{
msg_putchar('|');
--len;
}
while (len-- > 0)
msg_putchar(' ');
msg_outtrans_attr(cmd->uc_name, HL_ATTR(HLF_D));
len = (int)STRLEN(cmd->uc_name) + 4;
do {
msg_putchar(' ');
++len;
} while (len < 22);
over = len - 22;
len = 0;
switch ((int)(a & (EX_EXTRA|EX_NOSPC|EX_NEEDARG)))
{
case 0:IObuff[len++] = '0'; break;
case (EX_EXTRA):IObuff[len++] = '*'; break;
case (EX_EXTRA|EX_NOSPC):IObuff[len++] = '?'; break;
case (EX_EXTRA|EX_NEEDARG):IObuff[len++] = '+'; break;
case (EX_EXTRA|EX_NOSPC|EX_NEEDARG): IObuff[len++] = '1'; break;
}
do {
IObuff[len++] = ' ';
} while (len < 5 - over);
if (a & (EX_RANGE|EX_COUNT))
{
if (a & EX_COUNT)
{
sprintf((char *)IObuff + len, ""%ldc"", cmd->uc_def);
len += (int)STRLEN(IObuff + len);
}
else if (a & EX_DFLALL)
IObuff[len++] = '%';
else if (cmd->uc_def >= 0)
{
sprintf((char *)IObuff + len, ""%ld"", cmd->uc_def);
len += (int)STRLEN(IObuff + len);
}
else
IObuff[len++] = '.';
}
do {
IObuff[len++] = ' ';
} while (len < 8 - over);
for (j = 0; addr_type_complete[j].expand != ADDR_NONE; ++j)
if (addr_type_complete[j].expand != ADDR_LINES
&& addr_type_complete[j].expand == cmd->uc_addr_type)
{
STRCPY(IObuff + len, addr_type_complete[j].shortname);
len += (int)STRLEN(IObuff + len);
break;
}
do {
IObuff[len++] = ' ';
} while (len < 13 - over);
for (j = 0; command_complete[j].expand != 0; ++j)
if (command_complete[j].expand == cmd->uc_compl)
{
STRCPY(IObuff + len, command_complete[j].name);
len += (int)STRLEN(IObuff + len);
#ifdef FEAT_EVAL
if (p_verbose > 0 && cmd->uc_compl_arg != NULL
&& STRLEN(cmd->uc_compl_arg) < 200)
{
IObuff[len] = ',';
STRCPY(IObuff + len + 1, cmd->uc_compl_arg);
len += (int)STRLEN(IObuff + len);
}
#endif
break;
}
do {
IObuff[len++] = ' ';
} while (len < 25 - over);
IObuff[len] = '\0';
msg_outtrans(IObuff);
msg_outtrans_special(cmd->uc_rep, FALSE,
name_len == 0 ? Columns - 47 : 0);
#ifdef FEAT_EVAL
if (p_verbose > 0)
last_set_msg(cmd->uc_script_ctx);
#endif
out_flush();
ui_breakcheck();
if (got_int)
break;
}
if (gap == &ucmds || i < gap->ga_len)
break;
gap = &ucmds;
}
if (!found)
msg(_(""No user-defined commands found""));
}","static void
uc_list(char_u *VAR_0, size_t VAR_1)
{
intVAR_2, VAR_3;
intVAR_4 = FALSE;
ucmd_T*VAR_5;
intVAR_6;
intVAR_7;
longVAR_8;
garray_T*VAR_9;
VAR_9 =
#ifdef VAR_10
is_in_cmdwin() ? &VAR_11->w_buffer->b_ucmds :
#endif
&VAR_12->b_ucmds;
for (;;)
{
for (VAR_2 = 0; VAR_2 < VAR_9->ga_len; ++VAR_2)
{
VAR_5 = USER_CMD_GA(VAR_9, VAR_2);
VAR_8 = (long)VAR_5->uc_argt;
if (STRNCMP(VAR_0, VAR_5->uc_name, VAR_1) != 0
|| message_filtered(VAR_5->uc_name))
continue;
if (!VAR_4)
msg_puts_title(_(""\n    Name              Args Address Complete    Definition""));
VAR_4 = TRUE;
msg_putchar('\n');
if (VAR_13)
break;
VAR_6 = 4;
if (VAR_8 & VAR_14)
{
msg_putchar('!');
--VAR_6;
}
if (VAR_8 & VAR_15)
{
msg_putchar('""');
--VAR_6;
}
if (VAR_9 != &VAR_16)
{
msg_putchar('b');
--VAR_6;
}
if (VAR_8 & VAR_17)
{
msg_putchar('|');
--VAR_6;
}
while (VAR_6-- > 0)
msg_putchar(' ');
msg_outtrans_attr(VAR_5->uc_name, HL_ATTR(VAR_18));
VAR_6 = (int)STRLEN(VAR_5->uc_name) + 4;
do {
msg_putchar(' ');
++VAR_6;
} while (VAR_6 < 22);
VAR_7 = VAR_6 - 22;
VAR_6 = 0;
switch ((int)(VAR_8 & (VAR_19|VAR_20|VAR_21)))
{
case 0:VAR_22[VAR_6++] = '0'; break;
case (VAR_19):VAR_22[VAR_6++] = '*'; break;
case (VAR_19|VAR_20):VAR_22[VAR_6++] = '?'; break;
case (VAR_19|VAR_21):VAR_22[VAR_6++] = '+'; break;
case (VAR_19|VAR_20|VAR_21): VAR_22[VAR_6++] = '1'; break;
}
do {
VAR_22[VAR_6++] = ' ';
} while (VAR_6 < 5 - VAR_7);
if (VAR_8 & (VAR_23|VAR_24))
{
if (VAR_8 & VAR_24)
{
sprintf((char *)VAR_22 + VAR_6, ""%ldc"", VAR_5->uc_def);
VAR_6 += (int)STRLEN(VAR_22 + VAR_6);
}
else if (VAR_8 & VAR_25)
VAR_22[VAR_6++] = '%';
else if (VAR_5->uc_def >= 0)
{
sprintf((char *)VAR_22 + VAR_6, ""%ld"", VAR_5->uc_def);
VAR_6 += (int)STRLEN(VAR_22 + VAR_6);
}
else
VAR_22[VAR_6++] = '.';
}
do {
VAR_22[VAR_6++] = ' ';
} while (VAR_6 < 8 - VAR_7);
for (VAR_3 = 0; VAR_26[VAR_3].expand != VAR_27; ++VAR_3)
if (VAR_26[VAR_3].expand != VAR_28
&& VAR_26[VAR_3].expand == VAR_5->uc_addr_type)
{
STRCPY(VAR_22 + VAR_6, VAR_26[VAR_3].shortname);
VAR_6 += (int)STRLEN(VAR_22 + VAR_6);
break;
}
do {
VAR_22[VAR_6++] = ' ';
} while (VAR_6 < 13 - VAR_7);
for (VAR_3 = 0; VAR_29[VAR_3].expand != 0; ++VAR_3)
if (VAR_29[VAR_3].expand == VAR_5->uc_compl)
{
STRCPY(VAR_22 + VAR_6, VAR_29[VAR_3].name);
VAR_6 += (int)STRLEN(VAR_22 + VAR_6);
#ifdef VAR_30
if (VAR_31 > 0 && VAR_5->uc_compl_arg != NULL
&& STRLEN(VAR_5->uc_compl_arg) < 200)
{
VAR_22[VAR_6] = ',';
STRCPY(VAR_22 + VAR_6 + 1, VAR_5->uc_compl_arg);
VAR_6 += (int)STRLEN(VAR_22 + VAR_6);
}
#endif
break;
}
do {
VAR_22[VAR_6++] = ' ';
} while (VAR_6 < 25 - VAR_7);
VAR_22[VAR_6] = '\0';
msg_outtrans(VAR_22);
msg_outtrans_special(VAR_5->uc_rep, FALSE,
VAR_1 == 0 ? VAR_32 - 47 : 0);
#ifdef VAR_30
if (VAR_31 > 0)
last_set_msg(VAR_5->uc_script_ctx);
#endif
out_flush();
ui_breakcheck();
if (VAR_13)
break;
}
if (VAR_9 == &VAR_16 || VAR_2 < VAR_9->ga_len)
break;
VAR_9 = &VAR_16;
}
if (!VAR_4)
msg(_(""No user-defined commands found""));
}",vim/0f6e28f686dbb59ab3b562408ab9b2234797b9b1/usercmd.c/vul/before/2.json,"static void
uc_list(char_u *name, size_t name_len)
{
    int		i, j;
    int		found = FALSE;
    ucmd_T	*cmd;
    int		len;
    int		over;
    long	a;
    garray_T	*gap;

    // In cmdwin, the alternative buffer should be used.
    gap = &prevwin_curwin()->w_buffer->b_ucmds;
    for (;;)
    {
	for (i = 0; i < gap->ga_len; ++i)
	{
	    cmd = USER_CMD_GA(gap, i);
	    a = (long)cmd->uc_argt;

	    // Skip commands which don't match the requested prefix and
	    // commands filtered out.
	    if (STRNCMP(name, cmd->uc_name, name_len) != 0
		    || message_filtered(cmd->uc_name))
		continue;

	    // Put out the title first time
	    if (!found)
		msg_puts_title(_(""\n    Name              Args Address Complete    Definition""));
	    found = TRUE;
	    msg_putchar('\n');
	    if (got_int)
		break;

	    // Special cases
	    len = 4;
	    if (a & EX_BANG)
	    {
		msg_putchar('!');
		--len;
	    }
	    if (a & EX_REGSTR)
	    {
		msg_putchar('""');
		--len;
	    }
	    if (gap != &ucmds)
	    {
		msg_putchar('b');
		--len;
	    }
	    if (a & EX_TRLBAR)
	    {
		msg_putchar('|');
		--len;
	    }
	    while (len-- > 0)
		msg_putchar(' ');

	    msg_outtrans_attr(cmd->uc_name, HL_ATTR(HLF_D));
	    len = (int)STRLEN(cmd->uc_name) + 4;

	    do {
		msg_putchar(' ');
		++len;
	    } while (len < 22);

	    // ""over"" is how much longer the name is than the column width for
	    // the name, we'll try to align what comes after.
	    over = len - 22;
	    len = 0;

	    // Arguments
	    switch ((int)(a & (EX_EXTRA|EX_NOSPC|EX_NEEDARG)))
	    {
		case 0:				IObuff[len++] = '0'; break;
		case (EX_EXTRA):		IObuff[len++] = '*'; break;
		case (EX_EXTRA|EX_NOSPC):	IObuff[len++] = '?'; break;
		case (EX_EXTRA|EX_NEEDARG):	IObuff[len++] = '+'; break;
		case (EX_EXTRA|EX_NOSPC|EX_NEEDARG): IObuff[len++] = '1'; break;
	    }

	    do {
		IObuff[len++] = ' ';
	    } while (len < 5 - over);

	    // Address / Range
	    if (a & (EX_RANGE|EX_COUNT))
	    {
		if (a & EX_COUNT)
		{
		    // -count=N
		    sprintf((char *)IObuff + len, ""%ldc"", cmd->uc_def);
		    len += (int)STRLEN(IObuff + len);
		}
		else if (a & EX_DFLALL)
		    IObuff[len++] = '%';
		else if (cmd->uc_def >= 0)
		{
		    // -range=N
		    sprintf((char *)IObuff + len, ""%ld"", cmd->uc_def);
		    len += (int)STRLEN(IObuff + len);
		}
		else
		    IObuff[len++] = '.';
	    }

	    do {
		IObuff[len++] = ' ';
	    } while (len < 8 - over);

	    // Address Type
	    for (j = 0; addr_type_complete[j].expand != ADDR_NONE; ++j)
		if (addr_type_complete[j].expand != ADDR_LINES
			&& addr_type_complete[j].expand == cmd->uc_addr_type)
		{
		    STRCPY(IObuff + len, addr_type_complete[j].shortname);
		    len += (int)STRLEN(IObuff + len);
		    break;
		}

	    do {
		IObuff[len++] = ' ';
	    } while (len < 13 - over);

	    // Completion
	    for (j = 0; command_complete[j].expand != 0; ++j)
		if (command_complete[j].expand == cmd->uc_compl)
		{
		    STRCPY(IObuff + len, command_complete[j].name);
		    len += (int)STRLEN(IObuff + len);
#ifdef FEAT_EVAL
		    if (p_verbose > 0 && cmd->uc_compl_arg != NULL
					    && STRLEN(cmd->uc_compl_arg) < 200)
		    {
			IObuff[len] = ',';
			STRCPY(IObuff + len + 1, cmd->uc_compl_arg);
			len += (int)STRLEN(IObuff + len);
		    }
#endif
		    break;
		}

	    do {
		IObuff[len++] = ' ';
	    } while (len < 25 - over);

	    IObuff[len] = '\0';
	    msg_outtrans(IObuff);

	    msg_outtrans_special(cmd->uc_rep, FALSE,
					     name_len == 0 ? Columns - 47 : 0);
#ifdef FEAT_EVAL
	    if (p_verbose > 0)
		last_set_msg(cmd->uc_script_ctx);
#endif
	    out_flush();
	    ui_breakcheck();
	    if (got_int)
		break;
	}
	if (gap == &ucmds || i < gap->ga_len)
	    break;
	gap = &ucmds;
    }

    if (!found)
	msg(_(""No user-defined commands found""));
}","static void
uc_list(char_u *VAR_0, size_t VAR_1)
{
    int		VAR_2, VAR_3;
    int		VAR_4 = FALSE;
    ucmd_T	*VAR_5;
    int		VAR_6;
    int		VAR_7;
    long	VAR_8;
    garray_T	*VAR_9;

    /* COMMENT_0 */
    VAR_9 = &prevwin_curwin()->w_buffer->b_ucmds;
    for (;;)
    {
	for (VAR_2 = 0; VAR_2 < VAR_9->ga_len; ++VAR_2)
	{
	    VAR_5 = USER_CMD_GA(VAR_9, VAR_2);
	    VAR_8 = (long)VAR_5->uc_argt;

	    /* COMMENT_1 */
	    /* COMMENT_2 */
	    if (STRNCMP(VAR_0, VAR_5->uc_name, VAR_1) != 0
		    || message_filtered(VAR_5->uc_name))
		continue;

	    /* COMMENT_3 */
	    if (!VAR_4)
		msg_puts_title(_(""\n    Name              Args Address Complete    Definition""));
	    VAR_4 = TRUE;
	    msg_putchar('\n');
	    if (VAR_10)
		break;

	    /* COMMENT_4 */
	    VAR_6 = 4;
	    if (VAR_8 & VAR_11)
	    {
		msg_putchar('!');
		--VAR_6;
	    }
	    if (VAR_8 & VAR_12)
	    {
		msg_putchar('""');
		--VAR_6;
	    }
	    if (VAR_9 != &VAR_13)
	    {
		msg_putchar('b');
		--VAR_6;
	    }
	    if (VAR_8 & VAR_14)
	    {
		msg_putchar('|');
		--VAR_6;
	    }
	    while (VAR_6-- > 0)
		msg_putchar(' ');

	    msg_outtrans_attr(VAR_5->uc_name, HL_ATTR(VAR_15));
	    VAR_6 = (int)STRLEN(VAR_5->uc_name) + 4;

	    do {
		msg_putchar(' ');
		++VAR_6;
	    } while (VAR_6 < 22);

	    /* COMMENT_5 */
	    /* COMMENT_6 */
	    VAR_7 = VAR_6 - 22;
	    VAR_6 = 0;

	    /* COMMENT_7 */
	    switch ((int)(VAR_8 & (VAR_16|VAR_17|VAR_18)))
	    {
		case 0:				VAR_19[VAR_6++] = '0'; break;
		case (VAR_16):		VAR_19[VAR_6++] = '*'; break;
		case (VAR_16|VAR_17):	VAR_19[VAR_6++] = '?'; break;
		case (VAR_16|VAR_18):	VAR_19[VAR_6++] = '+'; break;
		case (VAR_16|VAR_17|VAR_18): VAR_19[VAR_6++] = '1'; break;
	    }

	    do {
		VAR_19[VAR_6++] = ' ';
	    } while (VAR_6 < 5 - VAR_7);

	    /* COMMENT_8 */
	    if (VAR_8 & (VAR_20|VAR_21))
	    {
		if (VAR_8 & VAR_21)
		{
		    /* COMMENT_9 */
		    sprintf((char *)VAR_19 + VAR_6, ""%ldc"", VAR_5->uc_def);
		    VAR_6 += (int)STRLEN(VAR_19 + VAR_6);
		}
		else if (VAR_8 & VAR_22)
		    VAR_19[VAR_6++] = '%';
		else if (VAR_5->uc_def >= 0)
		{
		    /* COMMENT_10 */
		    sprintf((char *)VAR_19 + VAR_6, ""%ld"", VAR_5->uc_def);
		    VAR_6 += (int)STRLEN(VAR_19 + VAR_6);
		}
		else
		    VAR_19[VAR_6++] = '.';
	    }

	    do {
		VAR_19[VAR_6++] = ' ';
	    } while (VAR_6 < 8 - VAR_7);

	    /* COMMENT_11 */
	    for (VAR_3 = 0; VAR_23[VAR_3].expand != VAR_24; ++VAR_3)
		if (VAR_23[VAR_3].expand != VAR_25
			&& VAR_23[VAR_3].expand == VAR_5->uc_addr_type)
		{
		    STRCPY(VAR_19 + VAR_6, VAR_23[VAR_3].shortname);
		    VAR_6 += (int)STRLEN(VAR_19 + VAR_6);
		    break;
		}

	    do {
		VAR_19[VAR_6++] = ' ';
	    } while (VAR_6 < 13 - VAR_7);

	    /* COMMENT_12 */
	    for (VAR_3 = 0; VAR_26[VAR_3].expand != 0; ++VAR_3)
		if (VAR_26[VAR_3].expand == VAR_5->uc_compl)
		{
		    STRCPY(VAR_19 + VAR_6, VAR_26[VAR_3].name);
		    VAR_6 += (int)STRLEN(VAR_19 + VAR_6);
#ifdef VAR_27
		    if (VAR_28 > 0 && VAR_5->uc_compl_arg != NULL
					    && STRLEN(VAR_5->uc_compl_arg) < 200)
		    {
			VAR_19[VAR_6] = ',';
			STRCPY(VAR_19 + VAR_6 + 1, VAR_5->uc_compl_arg);
			VAR_6 += (int)STRLEN(VAR_19 + VAR_6);
		    }
#endif
		    break;
		}

	    do {
		VAR_19[VAR_6++] = ' ';
	    } while (VAR_6 < 25 - VAR_7);

	    VAR_19[VAR_6] = '\0';
	    msg_outtrans(VAR_19);

	    msg_outtrans_special(VAR_5->uc_rep, FALSE,
					     VAR_1 == 0 ? VAR_29 - 47 : 0);
#ifdef VAR_27
	    if (VAR_28 > 0)
		last_set_msg(VAR_5->uc_script_ctx);
#endif
	    out_flush();
	    ui_breakcheck();
	    if (VAR_10)
		break;
	}
	if (VAR_9 == &VAR_13 || VAR_2 < VAR_9->ga_len)
	    break;
	VAR_9 = &VAR_13;
    }

    if (!VAR_4)
	msg(_(""No user-defined commands found""));
}",vim/0f6e28f686dbb59ab3b562408ab9b2234797b9b1/usercmd.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -10,11 +10,7 @@
     garray_T	*gap;
 
     // In cmdwin, the alternative buffer should be used.
-    gap =
-#ifdef FEAT_CMDWIN
-	    is_in_cmdwin() ? &prevwin->w_buffer->b_ucmds :
-#endif
-	    &curbuf->b_ucmds;
+    gap = &prevwin_curwin()->w_buffer->b_ucmds;
     for (;;)
     {
 	for (i = 0; i < gap->ga_len; ++i)","{'deleted_lines': ['    gap =', '#ifdef FEAT_CMDWIN', '\t    is_in_cmdwin() ? &prevwin->w_buffer->b_ucmds :', '#endif', '\t    &curbuf->b_ucmds;'], 'added_lines': ['    gap = &prevwin_curwin()->w_buffer->b_ucmds;']}",True,NULL Pointer Dereference in GitHub repository vim/vim prior to 8.2.4428.,5.5,MEDIUM,1,test,2022-02-20T20:49:35Z,4
CVE-2022-0696,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vim,"patch 8.2.4428: crash when switching tabpage while in the cmdline window

Problem:    Crash when switching tabpage while in the cmdline window.
Solution:   Disallow switching tabpage when in the cmdline window.",0f6e28f686dbb59ab3b562408ab9b2234797b9b1,https://github.com/vim/vim/commit/0f6e28f686dbb59ab3b562408ab9b2234797b9b1,src/evalvars.c,get_user_var_name,"char_u *
get_user_var_name(expand_T *xp, int idx)
{
static long_ugdone;
static long_ubdone;
static long_uwdone;
static long_utdone;
static intvidx;
static hashitem_T*hi;
hashtab_T*ht;
if (idx == 0)
{
gdone = bdone = wdone = vidx = 0;
tdone = 0;
}
if (gdone < globvarht.ht_used)
{
if (gdone++ == 0)
hi = globvarht.ht_array;
else
++hi;
while (HASHITEM_EMPTY(hi))
++hi;
if (STRNCMP(""g:"", xp->xp_pattern, 2) == 0)
return cat_prefix_varname('g', hi->hi_key);
return hi->hi_key;
}
ht =
#ifdef FEAT_CMDWIN
is_in_cmdwin() ? &prevwin->w_buffer->b_vars->dv_hashtab :
#endif
&curbuf->b_vars->dv_hashtab;
if (bdone < ht->ht_used)
{
if (bdone++ == 0)
hi = ht->ht_array;
else
++hi;
while (HASHITEM_EMPTY(hi))
++hi;
return cat_prefix_varname('b', hi->hi_key);
}
ht =
#ifdef FEAT_CMDWIN
is_in_cmdwin() ? &prevwin->w_vars->dv_hashtab :
#endif
&curwin->w_vars->dv_hashtab;
if (wdone < ht->ht_used)
{
if (wdone++ == 0)
hi = ht->ht_array;
else
++hi;
while (HASHITEM_EMPTY(hi))
++hi;
return cat_prefix_varname('w', hi->hi_key);
}
ht = &curtab->tp_vars->dv_hashtab;
if (tdone < ht->ht_used)
{
if (tdone++ == 0)
hi = ht->ht_array;
else
++hi;
while (HASHITEM_EMPTY(hi))
++hi;
return cat_prefix_varname('t', hi->hi_key);
}
if (vidx < VV_LEN)
return cat_prefix_varname('v', (char_u *)vimvars[vidx++].vv_name);
VIM_CLEAR(varnamebuf);
varnamebuflen = 0;
return NULL;
}","char_u *
get_user_var_name(expand_T *VAR_0, int VAR_1)
{
static long_uVAR_2;
static long_uVAR_3;
static long_uVAR_4;
static long_uVAR_5;
static intVAR_6;
static hashitem_T*VAR_7;
hashtab_T*VAR_8;
if (VAR_1 == 0)
{
VAR_2 = VAR_3 = VAR_4 = VAR_6 = 0;
VAR_5 = 0;
}
if (VAR_2 < VAR_9.ht_used)
{
if (VAR_2++ == 0)
VAR_7 = VAR_9.ht_array;
else
++VAR_7;
while (HASHITEM_EMPTY(VAR_7))
++VAR_7;
if (STRNCMP(""g:"", VAR_0->xp_pattern, 2) == 0)
return cat_prefix_varname('g', VAR_7->hi_key);
return VAR_7->hi_key;
}
VAR_8 =
#ifdef VAR_10
is_in_cmdwin() ? &VAR_11->w_buffer->b_vars->dv_hashtab :
#endif
&VAR_12->b_vars->dv_hashtab;
if (VAR_3 < VAR_8->ht_used)
{
if (VAR_3++ == 0)
VAR_7 = VAR_8->ht_array;
else
++VAR_7;
while (HASHITEM_EMPTY(VAR_7))
++VAR_7;
return cat_prefix_varname('b', VAR_7->hi_key);
}
VAR_8 =
#ifdef VAR_10
is_in_cmdwin() ? &VAR_11->w_vars->dv_hashtab :
#endif
&VAR_13->w_vars->dv_hashtab;
if (VAR_4 < VAR_8->ht_used)
{
if (VAR_4++ == 0)
VAR_7 = VAR_8->ht_array;
else
++VAR_7;
while (HASHITEM_EMPTY(VAR_7))
++VAR_7;
return cat_prefix_varname('w', VAR_7->hi_key);
}
VAR_8 = &VAR_14->tp_vars->dv_hashtab;
if (VAR_5 < VAR_8->ht_used)
{
if (VAR_5++ == 0)
VAR_7 = VAR_8->ht_array;
else
++VAR_7;
while (HASHITEM_EMPTY(VAR_7))
++VAR_7;
return cat_prefix_varname('t', VAR_7->hi_key);
}
if (VAR_6 < VAR_15)
return cat_prefix_varname('v', (char_u *)VAR_16[VAR_6++].vv_name);
VIM_CLEAR(VAR_17);
VAR_18 = 0;
return NULL;
}",vim/0f6e28f686dbb59ab3b562408ab9b2234797b9b1/evalvars.c/vul/before/0.json,"char_u *
get_user_var_name(expand_T *xp, int idx)
{
    static long_u	gdone;
    static long_u	bdone;
    static long_u	wdone;
    static long_u	tdone;
    static int		vidx;
    static hashitem_T	*hi;
    hashtab_T		*ht;

    if (idx == 0)
    {
	gdone = bdone = wdone = vidx = 0;
	tdone = 0;
    }

    // Global variables
    if (gdone < globvarht.ht_used)
    {
	if (gdone++ == 0)
	    hi = globvarht.ht_array;
	else
	    ++hi;
	while (HASHITEM_EMPTY(hi))
	    ++hi;
	if (STRNCMP(""g:"", xp->xp_pattern, 2) == 0)
	    return cat_prefix_varname('g', hi->hi_key);
	return hi->hi_key;
    }

    // b: variables
    ht = &prevwin_curwin()->w_buffer->b_vars->dv_hashtab;
    if (bdone < ht->ht_used)
    {
	if (bdone++ == 0)
	    hi = ht->ht_array;
	else
	    ++hi;
	while (HASHITEM_EMPTY(hi))
	    ++hi;
	return cat_prefix_varname('b', hi->hi_key);
    }

    // w: variables
    ht = &prevwin_curwin()->w_vars->dv_hashtab;
    if (wdone < ht->ht_used)
    {
	if (wdone++ == 0)
	    hi = ht->ht_array;
	else
	    ++hi;
	while (HASHITEM_EMPTY(hi))
	    ++hi;
	return cat_prefix_varname('w', hi->hi_key);
    }

    // t: variables
    ht = &curtab->tp_vars->dv_hashtab;
    if (tdone < ht->ht_used)
    {
	if (tdone++ == 0)
	    hi = ht->ht_array;
	else
	    ++hi;
	while (HASHITEM_EMPTY(hi))
	    ++hi;
	return cat_prefix_varname('t', hi->hi_key);
    }

    // v: variables
    if (vidx < VV_LEN)
	return cat_prefix_varname('v', (char_u *)vimvars[vidx++].vv_name);

    VIM_CLEAR(varnamebuf);
    varnamebuflen = 0;
    return NULL;
}","char_u *
get_user_var_name(expand_T *VAR_0, int VAR_1)
{
    static long_u	VAR_2;
    static long_u	VAR_3;
    static long_u	VAR_4;
    static long_u	VAR_5;
    static int		VAR_6;
    static hashitem_T	*VAR_7;
    hashtab_T		*VAR_8;

    if (VAR_1 == 0)
    {
	VAR_2 = VAR_3 = VAR_4 = VAR_6 = 0;
	VAR_5 = 0;
    }

    /* COMMENT_0 */
    if (VAR_2 < VAR_9.ht_used)
    {
	if (VAR_2++ == 0)
	    VAR_7 = VAR_9.ht_array;
	else
	    ++VAR_7;
	while (HASHITEM_EMPTY(VAR_7))
	    ++VAR_7;
	if (STRNCMP(""g:"", VAR_0->xp_pattern, 2) == 0)
	    return cat_prefix_varname('g', VAR_7->hi_key);
	return VAR_7->hi_key;
    }

    /* COMMENT_1 */
    VAR_8 = &prevwin_curwin()->w_buffer->b_vars->dv_hashtab;
    if (VAR_3 < VAR_8->ht_used)
    {
	if (VAR_3++ == 0)
	    VAR_7 = VAR_8->ht_array;
	else
	    ++VAR_7;
	while (HASHITEM_EMPTY(VAR_7))
	    ++VAR_7;
	return cat_prefix_varname('b', VAR_7->hi_key);
    }

    /* COMMENT_2 */
    VAR_8 = &prevwin_curwin()->w_vars->dv_hashtab;
    if (VAR_4 < VAR_8->ht_used)
    {
	if (VAR_4++ == 0)
	    VAR_7 = VAR_8->ht_array;
	else
	    ++VAR_7;
	while (HASHITEM_EMPTY(VAR_7))
	    ++VAR_7;
	return cat_prefix_varname('w', VAR_7->hi_key);
    }

    /* COMMENT_3 */
    VAR_8 = &VAR_10->tp_vars->dv_hashtab;
    if (VAR_5 < VAR_8->ht_used)
    {
	if (VAR_5++ == 0)
	    VAR_7 = VAR_8->ht_array;
	else
	    ++VAR_7;
	while (HASHITEM_EMPTY(VAR_7))
	    ++VAR_7;
	return cat_prefix_varname('t', VAR_7->hi_key);
    }

    /* COMMENT_4 */
    if (VAR_6 < VAR_11)
	return cat_prefix_varname('v', (char_u *)VAR_12[VAR_6++].vv_name);

    VIM_CLEAR(VAR_13);
    VAR_14 = 0;
    return NULL;
}",vim/0f6e28f686dbb59ab3b562408ab9b2234797b9b1/evalvars.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -30,12 +30,7 @@
     }
 
     // b: variables
-    ht =
-#ifdef FEAT_CMDWIN
-	// In cmdwin, the alternative buffer should be used.
-	is_in_cmdwin() ? &prevwin->w_buffer->b_vars->dv_hashtab :
-#endif
-	&curbuf->b_vars->dv_hashtab;
+    ht = &prevwin_curwin()->w_buffer->b_vars->dv_hashtab;
     if (bdone < ht->ht_used)
     {
 	if (bdone++ == 0)
@@ -48,12 +43,7 @@
     }
 
     // w: variables
-    ht =
-#ifdef FEAT_CMDWIN
-	// In cmdwin, the alternative window should be used.
-	is_in_cmdwin() ? &prevwin->w_vars->dv_hashtab :
-#endif
-	&curwin->w_vars->dv_hashtab;
+    ht = &prevwin_curwin()->w_vars->dv_hashtab;
     if (wdone < ht->ht_used)
     {
 	if (wdone++ == 0)","{'deleted_lines': ['    ht =', '#ifdef FEAT_CMDWIN', '\t// In cmdwin, the alternative buffer should be used.', '\tis_in_cmdwin() ? &prevwin->w_buffer->b_vars->dv_hashtab :', '#endif', '\t&curbuf->b_vars->dv_hashtab;', '    ht =', '#ifdef FEAT_CMDWIN', '\t// In cmdwin, the alternative window should be used.', '\tis_in_cmdwin() ? &prevwin->w_vars->dv_hashtab :', '#endif', '\t&curwin->w_vars->dv_hashtab;'], 'added_lines': ['    ht = &prevwin_curwin()->w_buffer->b_vars->dv_hashtab;', '    ht = &prevwin_curwin()->w_vars->dv_hashtab;']}",True,NULL Pointer Dereference in GitHub repository vim/vim prior to 8.2.4428.,5.5,MEDIUM,1,test,2022-02-20T20:49:35Z,4
CVE-2022-0696,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vim,"patch 8.2.4428: crash when switching tabpage while in the cmdline window

Problem:    Crash when switching tabpage while in the cmdline window.
Solution:   Disallow switching tabpage when in the cmdline window.",0f6e28f686dbb59ab3b562408ab9b2234797b9b1,https://github.com/vim/vim/commit/0f6e28f686dbb59ab3b562408ab9b2234797b9b1,src/window.c,goto_tabpage,"void
goto_tabpage(int n)
{
tabpage_T*tp = NULL;      tabpage_T*ttp;
inti;
if (text_locked())
{
text_locked_msg();
return;
}
if (first_tabpage->tp_next == NULL)
{
if (n > 1)
beep_flush();
return;
}
if (n == 0)
{
if (curtab->tp_next == NULL)
tp = first_tabpage;
else
tp = curtab->tp_next;
}
else if (n < 0)
{
ttp = curtab;
for (i = n; i < 0; ++i)
{
for (tp = first_tabpage; tp->tp_next != ttp && tp->tp_next != NULL;
tp = tp->tp_next)
;
ttp = tp;
}
}
else if (n == 9999)
{
for (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)
;
}
else
{
tp = find_tabpage(n);
if (tp == NULL)
{
beep_flush();
return;
}
}
goto_tabpage_tp(tp, TRUE, TRUE);
#ifdef FEAT_GUI_TABLINE
if (gui_use_tabline())
gui_mch_set_curtab(tabpage_index(curtab));
#endif
}","void
goto_tabpage(int VAR_0)
{
tabpage_T*VAR_1 = NULL;  
tabpage_T*VAR_2;
intVAR_3;
if (text_locked())
{
text_locked_msg();
return;
}
if (VAR_4->tp_next == NULL)
{
if (VAR_0 > 1)
beep_flush();
return;
}
if (VAR_0 == 0)
{
if (VAR_5->tp_next == NULL)
VAR_1 = VAR_4;
else
VAR_1 = VAR_5->tp_next;
}
else if (VAR_0 < 0)
{
VAR_2 = VAR_5;
for (VAR_3 = VAR_0; VAR_3 < 0; ++VAR_3)
{
for (VAR_1 = VAR_4; VAR_1->tp_next != VAR_2 && VAR_1->tp_next != NULL;
VAR_1 = VAR_1->tp_next)
;
VAR_2 = VAR_1;
}
}
else if (VAR_0 == 9999)
{
for (VAR_1 = VAR_4; VAR_1->tp_next != NULL; VAR_1 = VAR_1->tp_next)
;
}
else
{
VAR_1 = find_tabpage(VAR_0);
if (VAR_1 == NULL)
{
beep_flush();
return;
}
}
goto_tabpage_tp(VAR_1, TRUE, TRUE);
#ifdef VAR_6
if (gui_use_tabline())
gui_mch_set_curtab(tabpage_index(VAR_5));
#endif
}",vim/0f6e28f686dbb59ab3b562408ab9b2234797b9b1/window.c/vul/before/0.json,"void
goto_tabpage(int n)
{
    tabpage_T	*tp = NULL;  // shut up compiler
    tabpage_T	*ttp;
    int		i;

    if (text_locked())
    {
	// Not allowed when editing the command line.
	text_locked_msg();
	return;
    }
    CHECK_CMDWIN;

    // If there is only one it can't work.
    if (first_tabpage->tp_next == NULL)
    {
	if (n > 1)
	    beep_flush();
	return;
    }

    if (n == 0)
    {
	// No count, go to next tab page, wrap around end.
	if (curtab->tp_next == NULL)
	    tp = first_tabpage;
	else
	    tp = curtab->tp_next;
    }
    else if (n < 0)
    {
	// ""gT"": go to previous tab page, wrap around end.  ""N gT"" repeats
	// this N times.
	ttp = curtab;
	for (i = n; i < 0; ++i)
	{
	    for (tp = first_tabpage; tp->tp_next != ttp && tp->tp_next != NULL;
		    tp = tp->tp_next)
		;
	    ttp = tp;
	}
    }
    else if (n == 9999)
    {
	// Go to last tab page.
	for (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)
	    ;
    }
    else
    {
	// Go to tab page ""n"".
	tp = find_tabpage(n);
	if (tp == NULL)
	{
	    beep_flush();
	    return;
	}
    }

    goto_tabpage_tp(tp, TRUE, TRUE);

#ifdef FEAT_GUI_TABLINE
    if (gui_use_tabline())
	gui_mch_set_curtab(tabpage_index(curtab));
#endif
}","void
goto_tabpage(int VAR_0)
{
    tabpage_T	*VAR_1 = NULL;  /* COMMENT_0 */
    tabpage_T	*VAR_2;
    int		VAR_3;

    if (text_locked())
    {
	/* COMMENT_1 */
	text_locked_msg();
	return;
    }
    VAR_4;

    /* COMMENT_2 */
    if (VAR_5->tp_next == NULL)
    {
	if (VAR_0 > 1)
	    beep_flush();
	return;
    }

    if (VAR_0 == 0)
    {
	/* COMMENT_3 */
	if (VAR_6->tp_next == NULL)
	    VAR_1 = VAR_5;
	else
	    VAR_1 = VAR_6->tp_next;
    }
    else if (VAR_0 < 0)
    {
	/* COMMENT_4 */
	/* COMMENT_5 */
	VAR_2 = VAR_6;
	for (VAR_3 = VAR_0; VAR_3 < 0; ++VAR_3)
	{
	    for (VAR_1 = VAR_5; VAR_1->tp_next != VAR_2 && VAR_1->tp_next != NULL;
		    VAR_1 = VAR_1->tp_next)
		;
	    VAR_2 = VAR_1;
	}
    }
    else if (VAR_0 == 9999)
    {
	/* COMMENT_6 */
	for (VAR_1 = VAR_5; VAR_1->tp_next != NULL; VAR_1 = VAR_1->tp_next)
	    ;
    }
    else
    {
	/* COMMENT_7 */
	VAR_1 = find_tabpage(VAR_0);
	if (VAR_1 == NULL)
	{
	    beep_flush();
	    return;
	}
    }

    goto_tabpage_tp(VAR_1, TRUE, TRUE);

#ifdef VAR_7
    if (gui_use_tabline())
	gui_mch_set_curtab(tabpage_index(VAR_6));
#endif
}",vim/0f6e28f686dbb59ab3b562408ab9b2234797b9b1/window.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,6 +11,7 @@
 	text_locked_msg();
 	return;
     }
+    CHECK_CMDWIN;
 
     // If there is only one it can't work.
     if (first_tabpage->tp_next == NULL)","{'deleted_lines': [], 'added_lines': ['    CHECK_CMDWIN;']}",True,NULL Pointer Dereference in GitHub repository vim/vim prior to 8.2.4428.,5.5,MEDIUM,1,test,2022-02-20T20:49:35Z,4
CVE-2022-0696,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vim,"patch 8.2.4428: crash when switching tabpage while in the cmdline window

Problem:    Crash when switching tabpage while in the cmdline window.
Solution:   Disallow switching tabpage when in the cmdline window.",0f6e28f686dbb59ab3b562408ab9b2234797b9b1,https://github.com/vim/vim/commit/0f6e28f686dbb59ab3b562408ab9b2234797b9b1,src/usercmd.c,find_ucmd,"char_u *
find_ucmd(
exarg_T*eap,
char_u*p,     int*full,     expand_T*xp,     int*complp) {
intlen = (int)(p - eap->cmd);
intj, k, matchlen = 0;
ucmd_T*uc;
intfound = FALSE;
intpossible = FALSE;
char_u*cp, *np;        garray_T*gap;
intamb_local = FALSE;      
gap =
#ifdef FEAT_CMDWIN
is_in_cmdwin() ? &prevwin->w_buffer->b_ucmds :
#endif
&curbuf->b_ucmds;
for (;;)
{
for (j = 0; j < gap->ga_len; ++j)
{
uc = USER_CMD_GA(gap, j);
cp = eap->cmd;
np = uc->uc_name;
k = 0;
while (k < len && *np != NUL && *cp++ == *np++)
k++;
if (k == len || (*np == NUL && vim_isdigit(eap->cmd[k])))
{
if (k == len && found && *np != NUL)
{
if (gap == &ucmds)
return NULL;
amb_local = TRUE;
}
if (!found || (k == len && *np == NUL))
{
if (k == len)
found = TRUE;
else
possible = TRUE;
if (gap == &ucmds)
eap->cmdidx = CMD_USER;
else
eap->cmdidx = CMD_USER_BUF;
eap->argt = (long)uc->uc_argt;
eap->useridx = j;
eap->addr_type = uc->uc_addr_type;
if (complp != NULL)
*complp = uc->uc_compl;
# ifdef FEAT_EVAL
if (xp != NULL)
{
xp->xp_arg = uc->uc_compl_arg;
xp->xp_script_ctx = uc->uc_script_ctx;
xp->xp_script_ctx.sc_lnum += SOURCING_LNUM;
}
# endif
matchlen = k;
if (k == len && *np == NUL)
{
if (full != NULL)
*full = TRUE;
amb_local = FALSE;
break;
}
}
}
}
if (j < gap->ga_len || gap == &ucmds)
break;
gap = &ucmds;
}
if (amb_local)
{
if (xp != NULL)
xp->xp_context = EXPAND_UNSUCCESSFUL;
return NULL;
}
if (found || possible)
return p + (matchlen - len);
return p;
}","char_u *
find_ucmd(
exarg_T*VAR_0,
char_u*VAR_1, 
int*VAR_2, 
expand_T*VAR_3, 
int*VAR_4) 
{
intVAR_5 = (int)(VAR_1 - VAR_0->cmd);
intVAR_6, VAR_7, VAR_8 = 0;
ucmd_T*VAR_9;
intVAR_10 = FALSE;
intVAR_11 = FALSE;
char_u*VAR_12, *VAR_13;    
garray_T*VAR_14;
intVAR_15 = FALSE;  
VAR_14 =
#ifdef VAR_16
is_in_cmdwin() ? &VAR_17->w_buffer->b_ucmds :
#endif
&VAR_18->b_ucmds;
for (;;)
{
for (VAR_6 = 0; VAR_6 < VAR_14->ga_len; ++VAR_6)
{
VAR_9 = USER_CMD_GA(VAR_14, VAR_6);
VAR_12 = VAR_0->cmd;
VAR_13 = VAR_9->uc_name;
VAR_7 = 0;
while (VAR_7 < VAR_5 && *VAR_13 != VAR_19 && *VAR_12++ == *VAR_13++)
VAR_7++;
if (VAR_7 == VAR_5 || (*VAR_13 == VAR_19 && vim_isdigit(VAR_0->cmd[VAR_7])))
{
if (VAR_7 == VAR_5 && VAR_10 && *VAR_13 != VAR_19)
{
if (VAR_14 == &VAR_20)
return NULL;
VAR_15 = TRUE;
}
if (!VAR_10 || (VAR_7 == VAR_5 && *VAR_13 == VAR_19))
{
if (VAR_7 == VAR_5)
VAR_10 = TRUE;
else
VAR_11 = TRUE;
if (VAR_14 == &VAR_20)
VAR_0->cmdidx = VAR_21;
else
VAR_0->cmdidx = VAR_22;
VAR_0->argt = (long)VAR_9->uc_argt;
VAR_0->useridx = VAR_6;
VAR_0->addr_type = VAR_9->uc_addr_type;
if (VAR_4 != NULL)
*VAR_4 = VAR_9->uc_compl;
# ifdef VAR_23
if (VAR_3 != NULL)
{
VAR_3->xp_arg = VAR_9->uc_compl_arg;
VAR_3->xp_script_ctx = VAR_9->uc_script_ctx;
VAR_3->xp_script_ctx.sc_lnum += VAR_24;
}
# endif
VAR_8 = VAR_7;
if (VAR_7 == VAR_5 && *VAR_13 == VAR_19)
{
if (VAR_2 != NULL)
*VAR_2 = TRUE;
VAR_15 = FALSE;
break;
}
}
}
}
if (VAR_6 < VAR_14->ga_len || VAR_14 == &VAR_20)
break;
VAR_14 = &VAR_20;
}
if (VAR_15)
{
if (VAR_3 != NULL)
VAR_3->xp_context = VAR_25;
return NULL;
}
if (VAR_10 || VAR_11)
return VAR_1 + (VAR_8 - VAR_5);
return VAR_1;
}",vim/0f6e28f686dbb59ab3b562408ab9b2234797b9b1/usercmd.c/vul/before/0.json,"char_u *
find_ucmd(
    exarg_T	*eap,
    char_u	*p,	 // end of the command (possibly including count)
    int		*full,	 // set to TRUE for a full match
    expand_T	*xp,	 // used for completion, NULL otherwise
    int		*complp) // completion flags or NULL
{
    int		len = (int)(p - eap->cmd);
    int		j, k, matchlen = 0;
    ucmd_T	*uc;
    int		found = FALSE;
    int		possible = FALSE;
    char_u	*cp, *np;	    // Point into typed cmd and test name
    garray_T	*gap;
    int		amb_local = FALSE;  // Found ambiguous buffer-local command,
				    // only full match global is accepted.

    /*
     * Look for buffer-local user commands first, then global ones.
     */
    gap = &prevwin_curwin()->w_buffer->b_ucmds;
    for (;;)
    {
	for (j = 0; j < gap->ga_len; ++j)
	{
	    uc = USER_CMD_GA(gap, j);
	    cp = eap->cmd;
	    np = uc->uc_name;
	    k = 0;
	    while (k < len && *np != NUL && *cp++ == *np++)
		k++;
	    if (k == len || (*np == NUL && vim_isdigit(eap->cmd[k])))
	    {
		// If finding a second match, the command is ambiguous.  But
		// not if a buffer-local command wasn't a full match and a
		// global command is a full match.
		if (k == len && found && *np != NUL)
		{
		    if (gap == &ucmds)
			return NULL;
		    amb_local = TRUE;
		}

		if (!found || (k == len && *np == NUL))
		{
		    // If we matched up to a digit, then there could
		    // be another command including the digit that we
		    // should use instead.
		    if (k == len)
			found = TRUE;
		    else
			possible = TRUE;

		    if (gap == &ucmds)
			eap->cmdidx = CMD_USER;
		    else
			eap->cmdidx = CMD_USER_BUF;
		    eap->argt = (long)uc->uc_argt;
		    eap->useridx = j;
		    eap->addr_type = uc->uc_addr_type;

		    if (complp != NULL)
			*complp = uc->uc_compl;
# ifdef FEAT_EVAL
		    if (xp != NULL)
		    {
			xp->xp_arg = uc->uc_compl_arg;
			xp->xp_script_ctx = uc->uc_script_ctx;
			xp->xp_script_ctx.sc_lnum += SOURCING_LNUM;
		    }
# endif
		    // Do not search for further abbreviations
		    // if this is an exact match.
		    matchlen = k;
		    if (k == len && *np == NUL)
		    {
			if (full != NULL)
			    *full = TRUE;
			amb_local = FALSE;
			break;
		    }
		}
	    }
	}

	// Stop if we found a full match or searched all.
	if (j < gap->ga_len || gap == &ucmds)
	    break;
	gap = &ucmds;
    }

    // Only found ambiguous matches.
    if (amb_local)
    {
	if (xp != NULL)
	    xp->xp_context = EXPAND_UNSUCCESSFUL;
	return NULL;
    }

    // The match we found may be followed immediately by a number.  Move ""p""
    // back to point to it.
    if (found || possible)
	return p + (matchlen - len);
    return p;
}","char_u *
find_ucmd(
    exarg_T	*VAR_0,
    char_u	*VAR_1,	 /* COMMENT_0 */
    int		*VAR_2,	 /* COMMENT_1 */
    expand_T	*VAR_3,	 /* COMMENT_2 */
    int		*VAR_4) /* COMMENT_3 */
{
    int		VAR_5 = (int)(VAR_1 - VAR_0->cmd);
    int		VAR_6, VAR_7, VAR_8 = 0;
    ucmd_T	*VAR_9;
    int		VAR_10 = FALSE;
    int		VAR_11 = FALSE;
    char_u	*VAR_12, *VAR_13;	    /* COMMENT_4 */
    garray_T	*VAR_14;
    int		VAR_15 = FALSE;  /* COMMENT_5 */
				    /* COMMENT_6 */

    /* COMMENT_7 */
                                                                   
       
    VAR_14 = &prevwin_curwin()->w_buffer->b_ucmds;
    for (;;)
    {
	for (VAR_6 = 0; VAR_6 < VAR_14->ga_len; ++VAR_6)
	{
	    VAR_9 = USER_CMD_GA(VAR_14, VAR_6);
	    VAR_12 = VAR_0->cmd;
	    VAR_13 = VAR_9->uc_name;
	    VAR_7 = 0;
	    while (VAR_7 < VAR_5 && *VAR_13 != VAR_16 && *VAR_12++ == *VAR_13++)
		VAR_7++;
	    if (VAR_7 == VAR_5 || (*VAR_13 == VAR_16 && vim_isdigit(VAR_0->cmd[VAR_7])))
	    {
		/* COMMENT_10 */
		/* COMMENT_11 */
		/* COMMENT_12 */
		if (VAR_7 == VAR_5 && VAR_10 && *VAR_13 != VAR_16)
		{
		    if (VAR_14 == &VAR_17)
			return NULL;
		    VAR_15 = TRUE;
		}

		if (!VAR_10 || (VAR_7 == VAR_5 && *VAR_13 == VAR_16))
		{
		    /* COMMENT_13 */
		    /* COMMENT_14 */
		    /* COMMENT_15 */
		    if (VAR_7 == VAR_5)
			VAR_10 = TRUE;
		    else
			VAR_11 = TRUE;

		    if (VAR_14 == &VAR_17)
			VAR_0->cmdidx = VAR_18;
		    else
			VAR_0->cmdidx = VAR_19;
		    VAR_0->argt = (long)VAR_9->uc_argt;
		    VAR_0->useridx = VAR_6;
		    VAR_0->addr_type = VAR_9->uc_addr_type;

		    if (VAR_4 != NULL)
			*VAR_4 = VAR_9->uc_compl;
# ifdef VAR_20
		    if (VAR_3 != NULL)
		    {
			VAR_3->xp_arg = VAR_9->uc_compl_arg;
			VAR_3->xp_script_ctx = VAR_9->uc_script_ctx;
			VAR_3->xp_script_ctx.sc_lnum += VAR_21;
		    }
# endif
		    /* COMMENT_16 */
		    /* COMMENT_17 */
		    VAR_8 = VAR_7;
		    if (VAR_7 == VAR_5 && *VAR_13 == VAR_16)
		    {
			if (VAR_2 != NULL)
			    *VAR_2 = TRUE;
			VAR_15 = FALSE;
			break;
		    }
		}
	    }
	}

	/* COMMENT_18 */
	if (VAR_6 < VAR_14->ga_len || VAR_14 == &VAR_17)
	    break;
	VAR_14 = &VAR_17;
    }

    /* COMMENT_19 */
    if (VAR_15)
    {
	if (VAR_3 != NULL)
	    VAR_3->xp_context = VAR_22;
	return NULL;
    }

    /* COMMENT_20 */
    /* COMMENT_21 */
    if (VAR_10 || VAR_11)
	return VAR_1 + (VAR_8 - VAR_5);
    return VAR_1;
}",vim/0f6e28f686dbb59ab3b562408ab9b2234797b9b1/usercmd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -19,11 +19,7 @@
     /*
      * Look for buffer-local user commands first, then global ones.
      */
-    gap =
-#ifdef FEAT_CMDWIN
-	is_in_cmdwin() ? &prevwin->w_buffer->b_ucmds :
-#endif
-	&curbuf->b_ucmds;
+    gap = &prevwin_curwin()->w_buffer->b_ucmds;
     for (;;)
     {
 	for (j = 0; j < gap->ga_len; ++j)","{'deleted_lines': ['    gap =', '#ifdef FEAT_CMDWIN', '\tis_in_cmdwin() ? &prevwin->w_buffer->b_ucmds :', '#endif', '\t&curbuf->b_ucmds;'], 'added_lines': ['    gap = &prevwin_curwin()->w_buffer->b_ucmds;']}",True,NULL Pointer Dereference in GitHub repository vim/vim prior to 8.2.4428.,5.5,MEDIUM,1,test,2022-02-20T20:49:35Z,4
CVE-2022-0696,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vim,"patch 8.2.4428: crash when switching tabpage while in the cmdline window

Problem:    Crash when switching tabpage while in the cmdline window.
Solution:   Disallow switching tabpage when in the cmdline window.",0f6e28f686dbb59ab3b562408ab9b2234797b9b1,https://github.com/vim/vim/commit/0f6e28f686dbb59ab3b562408ab9b2234797b9b1,src/window.c,goto_tabpage_tp,"void
goto_tabpage_tp(
tabpage_T*tp,
inttrigger_enter_autocmds,
inttrigger_leave_autocmds)
{
set_keep_msg(NULL, 0);
if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,
trigger_leave_autocmds) == OK)
{
if (valid_tabpage(tp))
enter_tabpage(tp, curbuf, trigger_enter_autocmds,
trigger_leave_autocmds);
else
enter_tabpage(curtab, curbuf, trigger_enter_autocmds,
trigger_leave_autocmds);
}
}","void
goto_tabpage_tp(
tabpage_T*VAR_0,
intVAR_1,
intVAR_2)
{
set_keep_msg(NULL, 0);
if (VAR_0 != VAR_3 && leave_tabpage(VAR_0->tp_curwin->w_buffer,
VAR_2) == VAR_4)
{
if (valid_tabpage(VAR_0))
enter_tabpage(VAR_0, VAR_5, VAR_1,
VAR_2);
else
enter_tabpage(VAR_3, VAR_5, VAR_1,
VAR_2);
}
}",vim/0f6e28f686dbb59ab3b562408ab9b2234797b9b1/window.c/vul/before/2.json,"void
goto_tabpage_tp(
    tabpage_T	*tp,
    int		trigger_enter_autocmds,
    int		trigger_leave_autocmds)
{
    CHECK_CMDWIN;

    // Don't repeat a message in another tab page.
    set_keep_msg(NULL, 0);

    if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,
					trigger_leave_autocmds) == OK)
    {
	if (valid_tabpage(tp))
	    enter_tabpage(tp, curbuf, trigger_enter_autocmds,
		    trigger_leave_autocmds);
	else
	    enter_tabpage(curtab, curbuf, trigger_enter_autocmds,
		    trigger_leave_autocmds);
    }
}","void
goto_tabpage_tp(
    tabpage_T	*VAR_0,
    int		VAR_1,
    int		VAR_2)
{
    VAR_3;

    /* COMMENT_0 */
    set_keep_msg(NULL, 0);

    if (VAR_0 != VAR_4 && leave_tabpage(VAR_0->tp_curwin->w_buffer,
					VAR_2) == VAR_5)
    {
	if (valid_tabpage(VAR_0))
	    enter_tabpage(VAR_0, VAR_6, VAR_1,
		    VAR_2);
	else
	    enter_tabpage(VAR_4, VAR_6, VAR_1,
		    VAR_2);
    }
}",vim/0f6e28f686dbb59ab3b562408ab9b2234797b9b1/window.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -4,6 +4,8 @@
     int		trigger_enter_autocmds,
     int		trigger_leave_autocmds)
 {
+    CHECK_CMDWIN;
+
     // Don't repeat a message in another tab page.
     set_keep_msg(NULL, 0);
 ","{'deleted_lines': [], 'added_lines': ['    CHECK_CMDWIN;', '']}",True,NULL Pointer Dereference in GitHub repository vim/vim prior to 8.2.4428.,5.5,MEDIUM,1,test,2022-02-20T20:49:35Z,4
CVE-2022-0696,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vim,"patch 8.2.4428: crash when switching tabpage while in the cmdline window

Problem:    Crash when switching tabpage while in the cmdline window.
Solution:   Disallow switching tabpage when in the cmdline window.",0f6e28f686dbb59ab3b562408ab9b2234797b9b1,https://github.com/vim/vim/commit/0f6e28f686dbb59ab3b562408ab9b2234797b9b1,src/window.c,win_new_tabpage,"int
win_new_tabpage(int after)
{
tabpage_T*tp = curtab;
tabpage_T*prev_tp = curtab;
tabpage_T*newtp;
intn;
newtp = alloc_tabpage();
if (newtp == NULL)
return FAIL;
if (leave_tabpage(curbuf, TRUE) == FAIL)
{
vim_free(newtp);
return FAIL;
}
curtab = newtp;
newtp->tp_localdir = (tp->tp_localdir == NULL)
? NULL : vim_strsave(tp->tp_localdir);
if (win_alloc_firstwin(tp->tp_curwin) == OK)
{
if (after == 1)
{
newtp->tp_next = first_tabpage;
first_tabpage = newtp;
}
else
{
if (after > 0)
{
n = 2;
for (tp = first_tabpage; tp->tp_next != NULL
&& n < after; tp = tp->tp_next)
++n;
}
newtp->tp_next = tp->tp_next;
tp->tp_next = newtp;
}
newtp->tp_firstwin = newtp->tp_lastwin = newtp->tp_curwin = curwin;
win_init_size();
firstwin->w_winrow = tabline_height();
win_comp_scroll(curwin);
newtp->tp_topframe = topframe;
last_status(FALSE);
lastused_tabpage = prev_tp;
#if defined(FEAT_GUI)
gui_may_update_scrollbars();
#endif
#ifdef FEAT_JOB_CHANNEL
entering_window(curwin);
#endif
redraw_all_later(NOT_VALID);
apply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);
apply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);
apply_autocmds(EVENT_TABNEW, NULL, NULL, FALSE, curbuf);
apply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);
return OK;
}
enter_tabpage(curtab, curbuf, TRUE, TRUE);
return FAIL;
}","int
win_new_tabpage(int VAR_0)
{
tabpage_T*VAR_1 = VAR_2;
tabpage_T*VAR_3 = VAR_2;
tabpage_T*VAR_4;
intVAR_5;
VAR_4 = alloc_tabpage();
if (VAR_4 == NULL)
return VAR_6;
if (leave_tabpage(VAR_7, TRUE) == VAR_6)
{
vim_free(VAR_4);
return VAR_6;
}
VAR_2 = VAR_4;
VAR_4->tp_localdir = (VAR_1->tp_localdir == NULL)
? NULL : vim_strsave(VAR_1->tp_localdir);
if (win_alloc_firstwin(VAR_1->tp_curwin) == VAR_8)
{
if (VAR_0 == 1)
{
VAR_4->tp_next = VAR_9;
VAR_9 = VAR_4;
}
else
{
if (VAR_0 > 0)
{
VAR_5 = 2;
for (VAR_1 = VAR_9; VAR_1->tp_next != NULL
&& VAR_5 < VAR_0; VAR_1 = VAR_1->tp_next)
++VAR_5;
}
VAR_4->tp_next = VAR_1->tp_next;
VAR_1->tp_next = VAR_4;
}
VAR_4->tp_firstwin = VAR_4->tp_lastwin = VAR_4->tp_curwin = VAR_10;
win_init_size();
VAR_11->w_winrow = tabline_height();
win_comp_scroll(VAR_10);
VAR_4->tp_topframe = VAR_12;
last_status(FALSE);
VAR_13 = VAR_3;
#if defined(VAR_14)
gui_may_update_scrollbars();
#endif
#ifdef VAR_15
entering_window(VAR_10);
#endif
redraw_all_later(VAR_16);
apply_autocmds(VAR_17, NULL, NULL, FALSE, VAR_7);
apply_autocmds(VAR_18, NULL, NULL, FALSE, VAR_7);
apply_autocmds(VAR_19, NULL, NULL, FALSE, VAR_7);
apply_autocmds(VAR_20, NULL, NULL, FALSE, VAR_7);
return VAR_8;
}
enter_tabpage(VAR_2, VAR_7, TRUE, TRUE);
return VAR_6;
}",vim/0f6e28f686dbb59ab3b562408ab9b2234797b9b1/window.c/vul/before/1.json,"int
win_new_tabpage(int after)
{
    tabpage_T	*tp = curtab;
    tabpage_T	*prev_tp = curtab;
    tabpage_T	*newtp;
    int		n;

#ifdef FEAT_CMDWIN
    if (cmdwin_type != 0)
    {
	emsg(_(e_invalid_in_cmdline_window));
	return FAIL;
    }
#endif

    newtp = alloc_tabpage();
    if (newtp == NULL)
	return FAIL;

    // Remember the current windows in this Tab page.
    if (leave_tabpage(curbuf, TRUE) == FAIL)
    {
	vim_free(newtp);
	return FAIL;
    }
    curtab = newtp;

    newtp->tp_localdir = (tp->tp_localdir == NULL)
				    ? NULL : vim_strsave(tp->tp_localdir);
    // Create a new empty window.
    if (win_alloc_firstwin(tp->tp_curwin) == OK)
    {
	// Make the new Tab page the new topframe.
	if (after == 1)
	{
	    // New tab page becomes the first one.
	    newtp->tp_next = first_tabpage;
	    first_tabpage = newtp;
	}
	else
	{
	    if (after > 0)
	    {
		// Put new tab page before tab page ""after"".
		n = 2;
		for (tp = first_tabpage; tp->tp_next != NULL
					       && n < after; tp = tp->tp_next)
		    ++n;
	    }
	    newtp->tp_next = tp->tp_next;
	    tp->tp_next = newtp;
	}
	newtp->tp_firstwin = newtp->tp_lastwin = newtp->tp_curwin = curwin;

	win_init_size();
	firstwin->w_winrow = tabline_height();
	win_comp_scroll(curwin);

	newtp->tp_topframe = topframe;
	last_status(FALSE);

	lastused_tabpage = prev_tp;

#if defined(FEAT_GUI)
	// When 'guioptions' includes 'L' or 'R' may have to remove or add
	// scrollbars.  Have to update them anyway.
	gui_may_update_scrollbars();
#endif
#ifdef FEAT_JOB_CHANNEL
	entering_window(curwin);
#endif

	redraw_all_later(NOT_VALID);
	apply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);
	apply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);
	apply_autocmds(EVENT_TABNEW, NULL, NULL, FALSE, curbuf);
	apply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);
	return OK;
    }

    // Failed, get back the previous Tab page
    enter_tabpage(curtab, curbuf, TRUE, TRUE);
    return FAIL;
}","int
win_new_tabpage(int VAR_0)
{
    tabpage_T	*VAR_1 = VAR_2;
    tabpage_T	*VAR_3 = VAR_2;
    tabpage_T	*VAR_4;
    int		VAR_5;

#ifdef VAR_6
    if (VAR_7 != 0)
    {
	emsg(_(VAR_8));
	return VAR_9;
    }
#endif

    VAR_4 = alloc_tabpage();
    if (VAR_4 == NULL)
	return VAR_9;

    /* COMMENT_0 */
    if (leave_tabpage(VAR_10, TRUE) == VAR_9)
    {
	vim_free(VAR_4);
	return VAR_9;
    }
    VAR_2 = VAR_4;

    VAR_4->tp_localdir = (VAR_1->tp_localdir == NULL)
				    ? NULL : vim_strsave(VAR_1->tp_localdir);
    /* COMMENT_1 */
    if (win_alloc_firstwin(VAR_1->tp_curwin) == VAR_11)
    {
	/* COMMENT_2 */
	if (VAR_0 == 1)
	{
	    /* COMMENT_3 */
	    VAR_4->tp_next = VAR_12;
	    VAR_12 = VAR_4;
	}
	else
	{
	    if (VAR_0 > 0)
	    {
		/* COMMENT_4 */
		VAR_5 = 2;
		for (VAR_1 = VAR_12; VAR_1->tp_next != NULL
					       && VAR_5 < VAR_0; VAR_1 = VAR_1->tp_next)
		    ++VAR_5;
	    }
	    VAR_4->tp_next = VAR_1->tp_next;
	    VAR_1->tp_next = VAR_4;
	}
	VAR_4->tp_firstwin = VAR_4->tp_lastwin = VAR_4->tp_curwin = VAR_13;

	win_init_size();
	VAR_14->w_winrow = tabline_height();
	win_comp_scroll(VAR_13);

	VAR_4->tp_topframe = VAR_15;
	last_status(FALSE);

	VAR_16 = VAR_3;

#if defined(VAR_17)
	/* COMMENT_5 */
	/* COMMENT_6 */
	gui_may_update_scrollbars();
#endif
#ifdef VAR_18
	entering_window(VAR_13);
#endif

	redraw_all_later(VAR_19);
	apply_autocmds(VAR_20, NULL, NULL, FALSE, VAR_10);
	apply_autocmds(VAR_21, NULL, NULL, FALSE, VAR_10);
	apply_autocmds(VAR_22, NULL, NULL, FALSE, VAR_10);
	apply_autocmds(VAR_23, NULL, NULL, FALSE, VAR_10);
	return VAR_11;
    }

    /* COMMENT_7 */
    enter_tabpage(VAR_2, VAR_10, TRUE, TRUE);
    return VAR_9;
}",vim/0f6e28f686dbb59ab3b562408ab9b2234797b9b1/window.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -5,6 +5,14 @@
     tabpage_T	*prev_tp = curtab;
     tabpage_T	*newtp;
     int		n;
+
+#ifdef FEAT_CMDWIN
+    if (cmdwin_type != 0)
+    {
+	emsg(_(e_invalid_in_cmdline_window));
+	return FAIL;
+    }
+#endif
 
     newtp = alloc_tabpage();
     if (newtp == NULL)","{'deleted_lines': [], 'added_lines': ['', '#ifdef FEAT_CMDWIN', '    if (cmdwin_type != 0)', '    {', '\temsg(_(e_invalid_in_cmdline_window));', '\treturn FAIL;', '    }', '#endif']}",True,NULL Pointer Dereference in GitHub repository vim/vim prior to 8.2.4428.,5.5,MEDIUM,1,test,2022-02-20T20:49:35Z,4
CVE-2022-0696,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vim,"patch 8.2.4428: crash when switching tabpage while in the cmdline window

Problem:    Crash when switching tabpage while in the cmdline window.
Solution:   Disallow switching tabpage when in the cmdline window.",0f6e28f686dbb59ab3b562408ab9b2234797b9b1,https://github.com/vim/vim/commit/0f6e28f686dbb59ab3b562408ab9b2234797b9b1,src/usercmd.c,get_user_commands,"char_u *
get_user_commands(expand_T *xp UNUSED, int idx)
{
buf_T *buf =
#ifdef FEAT_CMDWIN
is_in_cmdwin() ? prevwin->w_buffer :
#endif
curbuf;
if (idx < buf->b_ucmds.ga_len)
return USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;
idx -= buf->b_ucmds.ga_len;
if (idx < ucmds.ga_len)
return USER_CMD(idx)->uc_name;
return NULL;
}","char_u *
get_user_commands(expand_T *VAR_0 UNUSED, int VAR_1)
{
buf_T *VAR_2 =
#ifdef VAR_3
is_in_cmdwin() ? VAR_4->w_buffer :
#endif
VAR_5;
if (VAR_1 < VAR_2->b_ucmds.ga_len)
return USER_CMD_GA(&VAR_2->b_ucmds, VAR_1)->uc_name;
VAR_1 -= VAR_2->b_ucmds.ga_len;
if (VAR_1 < VAR_6.ga_len)
return USER_CMD(VAR_1)->uc_name;
return NULL;
}",,"char_u *
get_user_commands(expand_T *xp UNUSED, int idx)
{
    // In cmdwin, the alternative buffer should be used.
    buf_T *buf = prevwin_curwin()->w_buffer;

    if (idx < buf->b_ucmds.ga_len)
	return USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;
    idx -= buf->b_ucmds.ga_len;
    if (idx < ucmds.ga_len)
	return USER_CMD(idx)->uc_name;
    return NULL;
}","char_u *
get_user_commands(expand_T *VAR_0 UNUSED, int VAR_1)
{
    /* COMMENT_0 */
    buf_T *VAR_2 = prevwin_curwin()->w_buffer;

    if (VAR_1 < VAR_2->b_ucmds.ga_len)
	return USER_CMD_GA(&VAR_2->b_ucmds, VAR_1)->uc_name;
    VAR_1 -= VAR_2->b_ucmds.ga_len;
    if (VAR_1 < VAR_3.ga_len)
	return USER_CMD(VAR_1)->uc_name;
    return NULL;
}",,"--- func_before
+++ func_after
@@ -2,11 +2,7 @@
 get_user_commands(expand_T *xp UNUSED, int idx)
 {
     // In cmdwin, the alternative buffer should be used.
-    buf_T *buf =
-#ifdef FEAT_CMDWIN
-	is_in_cmdwin() ? prevwin->w_buffer :
-#endif
-	curbuf;
+    buf_T *buf = prevwin_curwin()->w_buffer;
 
     if (idx < buf->b_ucmds.ga_len)
 	return USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;","{'deleted_lines': ['    buf_T *buf =', '#ifdef FEAT_CMDWIN', '\tis_in_cmdwin() ? prevwin->w_buffer :', '#endif', '\tcurbuf;'], 'added_lines': ['    buf_T *buf = prevwin_curwin()->w_buffer;']}",True,NULL Pointer Dereference in GitHub repository vim/vim prior to 8.2.4428.,5.5,MEDIUM,1,test,2022-02-20T20:49:35Z,4
CVE-2022-0476,['CWE-400'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,radareorg/radare2,"Fix DoS in the minidump parser ##crash

* Reported by lazymio via huntr.dev
* Reproducer: mdmp-dos",27fe8031782d3a06c3998eaa94354867864f9f1b,https://github.com/radareorg/radare2/commit/27fe8031782d3a06c3998eaa94354867864f9f1b,libr/bin/format/mdmp/mdmp.c,r_bin_mdmp_init_directory_entry,"static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct minidump_directory *entry) {
r_strf_buffer (128);
struct minidump_handle_operation_list handle_operation_list;
struct minidump_memory_list memory_list;
struct minidump_memory64_list memory64_list;
struct minidump_memory_info_list memory_info_list;
struct minidump_module_list module_list;
struct minidump_thread_list thread_list;
struct minidump_thread_ex_list thread_ex_list;
struct minidump_thread_info_list thread_info_list;
struct minidump_token_info_list token_info_list;
struct minidump_unloaded_module_list unloaded_module_list;
ut64 offset;
int i, r;
if ((ut64)entry->location.rva + entry->location.data_size > r_buf_size (obj->b)) {
eprintf (""[ERROR] Size Mismatch - Stream data is larger than file size!\n"");
return false;
}
switch (entry->stream_type) {
case THREAD_LIST_STREAM:
r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&thread_list, sizeof (thread_list));
if (r != sizeof (thread_list)) {
break;
}
sdb_set (obj->kv, ""mdmp_thread.format"", ""ddddq?? ""
""ThreadId SuspendCount PriorityClass Priority ""
""Teb (mdmp_memory_descriptor)Stack ""
""(mdmp_location_descriptor)ThreadContext"", 0);
sdb_num_set (obj->kv, ""mdmp_thread_list.offset"",
entry->location.rva, 0);
sdb_set (obj->kv, ""mdmp_thread_list.format"",
r_strf (""d[%d]? ""
""NumberOfThreads (mdmp_thread)Threads"",
thread_list.number_of_threads),
0);
break;
case MODULE_LIST_STREAM:
module_list.number_of_modules = r_buf_read_le32_at (obj->b, entry->location.rva);
sdb_set (obj->kv, ""mdmp_module.format"", ""qddtd???qq ""
""BaseOfImage SizeOfImage CheckSum ""
""TimeDateStamp ModuleNameRVA ""
""(mdmp_vs_fixedfileinfo)VersionInfo ""
""(mdmp_location_descriptor)CvRecord ""
""(mdmp_location_descriptor)MiscRecord ""
""Reserved0 Reserved1"", 0);
sdb_num_set (obj->kv, ""mdmp_module_list.offset"",
entry->location.rva, 0);
sdb_set (obj->kv, ""mdmp_module_list.format"",
r_strf (""d[%d]? ""
""NumberOfModule (mdmp_module)Modules"",
module_list.number_of_modules),
0);
offset = entry->location.rva + sizeof (module_list);
for (i = 0; i < module_list.number_of_modules; i++) {
struct minidump_module *module = R_NEW (struct minidump_module);
if (!module) {
break;
}
read_module (obj->b, offset, module);
r_list_append (obj->streams.modules, module);
offset += sizeof (*module);
}
break;
case MEMORY_LIST_STREAM:
r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&memory_list, sizeof (memory_list));
if (r != sizeof (memory_list)) {
break;
}
sdb_num_set (obj->kv, ""mdmp_memory_list.offset"",
entry->location.rva, 0);
sdb_set (obj->kv, ""mdmp_memory_list.format"",
r_strf (""d[%d]? ""
""NumberOfMemoryRanges ""
""(mdmp_memory_descriptor)MemoryRanges "",
memory_list.number_of_memory_ranges),
0);
offset = entry->location.rva + sizeof (memory_list);
for (i = 0; i < memory_list.number_of_memory_ranges; i++) {
struct minidump_memory_descriptor *desc = R_NEW (struct minidump_memory_descriptor);
if (!desc) {
break;
}
r = r_buf_read_at (obj->b, offset, (ut8 *)desc, sizeof (*desc));
if (r != sizeof (*desc)) {
break;
}
r_list_append (obj->streams.memories, desc);
offset += sizeof (*desc);
}
break;
case EXCEPTION_STREAM:
obj->streams.exception = R_NEW (struct minidump_exception_stream);
if (!obj->streams.exception) {
break;
}
r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.exception, sizeof (*obj->streams.exception));
if (r != sizeof (*obj->streams.exception)) {
break;
}
sdb_set (obj->kv, ""mdmp_exception.format"", ""[4]E[4]Eqqdd[15]q ""
""(mdmp_exception_code)ExceptionCode ""
""(mdmp_exception_flags)ExceptionFlags ""
""ExceptionRecord ExceptionAddress ""
""NumberParameters __UnusedAlignment ""
""ExceptionInformation"",
0);
sdb_num_set (obj->kv, ""mdmp_exception_stream.offset"",
entry->location.rva, 0);
sdb_set (obj->kv, ""mdmp_exception_stream.format"", ""dd?? ""
""ThreadId __Alignment ""
""(mdmp_exception)ExceptionRecord ""
""(mdmp_location_descriptor)ThreadContext"",
0);
break;
case SYSTEM_INFO_STREAM:
obj->streams.system_info = R_NEW (struct minidump_system_info);
if (!obj->streams.system_info) {
break;
}
r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.system_info, sizeof (*obj->streams.system_info));
if (r != sizeof (*obj->streams.system_info)) {
break;
}
sdb_num_set (obj->kv, ""mdmp_system_info.offset"",
entry->location.rva, 0);
sdb_set (obj->kv, ""mdmp_system_info.format"", ""[2]EwwbBddd[4]Ed[2]Ew[2]q ""
""(mdmp_processor_architecture)ProcessorArchitecture ""
""ProcessorLevel ProcessorRevision NumberOfProcessors ""
""(mdmp_product_type)ProductType ""
""MajorVersion MinorVersion BuildNumber (mdmp_platform_id)PlatformId ""
""CsdVersionRva (mdmp_suite_mask)SuiteMask Reserved2 ProcessorFeatures"", 0);
break;
case THREAD_EX_LIST_STREAM:
r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&thread_ex_list, sizeof (thread_ex_list));
if (r != sizeof (thread_ex_list)) {
break;
}
sdb_set (obj->kv, ""mdmp_thread_ex.format"", ""ddddq??? ""
""ThreadId SuspendCount PriorityClass Priority ""
""Teb (mdmp_memory_descriptor)Stack ""
""(mdmp_location_descriptor)ThreadContext ""
""(mdmp_memory_descriptor)BackingStore"", 0);
sdb_num_set (obj->kv, ""mdmp_thread_ex_list.offset"",
entry->location.rva, 0);
sdb_set (obj->kv, ""mdmp_thread_ex_list.format"",
r_strf (""d[%d]? NumberOfThreads ""
""(mdmp_thread_ex)Threads"",
thread_ex_list.number_of_threads),
0);
offset = entry->location.rva + sizeof (thread_ex_list);
for (i = 0; i < thread_ex_list.number_of_threads; i++) {
struct minidump_thread_ex *thread = R_NEW (struct minidump_thread_ex);
if (!thread) {
break;
}
r = r_buf_read_at (obj->b, offset, (ut8 *)thread, sizeof (*thread));
if (r != sizeof (*thread)) {
break;
}
r_list_append (obj->streams.ex_threads, thread);
offset += sizeof (*thread);
}
break;
case MEMORY_64_LIST_STREAM:
read_memory64_list (obj->b, entry->location.rva, &memory64_list);
sdb_num_set (obj->kv, ""mdmp_memory64_list.offset"",
entry->location.rva, 0);
sdb_set (obj->kv, ""mdmp_memory64_list.format"",
r_strf (""qq[%""PFMT64d""]? NumberOfMemoryRanges ""
""BaseRva ""
""(mdmp_memory_descriptor64)MemoryRanges"",
memory64_list.number_of_memory_ranges),
0);
obj->streams.memories64.base_rva = memory64_list.base_rva;
offset = entry->location.rva + sizeof (memory64_list);
for (i = 0; i < memory64_list.number_of_memory_ranges; i++) {
struct minidump_memory_descriptor64 *desc = R_NEW (struct minidump_memory_descriptor64);
if (!desc) {
break;
}
read_desc (obj->b, offset, desc);
r_list_append (obj->streams.memories64.memories, desc);
offset += sizeof (*desc);
}
break;
case COMMENT_STREAM_A:
obj->streams.comments_a = R_NEWS (ut8, COMMENTS_SIZE);
if (!obj->streams.comments_a) {
break;
}
r = r_buf_read_at (obj->b, entry->location.rva, obj->streams.comments_a, COMMENTS_SIZE);
if (r != COMMENTS_SIZE) {
break;
}
sdb_num_set (obj->kv, ""mdmp_comment_stream_a.offset"",
entry->location.rva, 0);
sdb_set (obj->kv, ""mdmp_comment_stream_a.format"",
""s CommentA"", 0);
break;
case COMMENT_STREAM_W:
obj->streams.comments_w = R_NEWS (ut8, COMMENTS_SIZE);
if (!obj->streams.comments_w) {
break;
}
r = r_buf_read_at (obj->b, entry->location.rva, obj->streams.comments_w, COMMENTS_SIZE);
if (r != COMMENTS_SIZE) {
break;
}
sdb_num_set (obj->kv, ""mdmp_comment_stream_w.offset"",
entry->location.rva, 0);
sdb_set (obj->kv, ""mdmp_comment_stream_w.format"",
""s CommentW"", 0);
break;
case HANDLE_DATA_STREAM:
obj->streams.handle_data = R_NEW (struct minidump_handle_data_stream);
if (!obj->streams.handle_data) {
break;
}
r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.handle_data, sizeof (*obj->streams.handle_data));
if (r != sizeof (*obj->streams.handle_data)) {
break;
}
sdb_num_set (obj->kv, ""mdmp_handle_data_stream.offset"",
entry->location.rva, 0);
sdb_set (obj->kv, ""mdmp_handle_data_stream.format"", ""dddd ""
""SizeOfHeader SizeOfDescriptor ""
""NumberOfDescriptors Reserved"", 0);
break;
case FUNCTION_TABLE_STREAM:
obj->streams.function_table = R_NEW (struct minidump_function_table_stream);
if (!obj->streams.function_table) {
break;
}
r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.function_table, sizeof (*obj->streams.function_table));
if (r != sizeof (*obj->streams.function_table)) {
break;
}
sdb_num_set (obj->kv, ""mdmp_function_table_stream.offset"",
entry->location.rva, 0);
sdb_set (obj->kv, ""mdmp_function_table_stream.format"", ""dddddd ""
""SizeOfHeader SizeOfDescriptor SizeOfNativeDescriptor ""
""SizeOfFunctionEntry NumberOfDescriptors SizeOfAlignPad"",
0);
break;
case UNLOADED_MODULE_LIST_STREAM:
r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&unloaded_module_list, sizeof (unloaded_module_list));
if (r != sizeof (unloaded_module_list)) {
break;
}
sdb_set (obj->kv, ""mdmp_unloaded_module.format"", ""qddtd ""
""BaseOfImage SizeOfImage CheckSum TimeDateStamp ""
""ModuleNameRva"", 0);
sdb_num_set (obj->kv, ""mdmp_unloaded_module_list.offset"",
entry->location.rva, 0);
sdb_set (obj->kv, ""mdmp_unloaded_module_list.format"", ""ddd ""
""SizeOfHeader SizeOfEntry NumberOfEntries"", 0);
offset = entry->location.rva + sizeof (unloaded_module_list);
for (i = 0; i < unloaded_module_list.number_of_entries; i++) {
struct minidump_unloaded_module *module = R_NEW (struct minidump_unloaded_module);
if (!module) {
break;
}
r = r_buf_read_at (obj->b, offset, (ut8 *)module, sizeof (*module));
if (r != sizeof (*module)) {
break;
}
r_list_append (obj->streams.unloaded_modules, module);
offset += sizeof (*module);
}
break;
case MISC_INFO_STREAM:
obj->streams.misc_info.misc_info_1 = R_NEW (struct minidump_misc_info);
if (!obj->streams.misc_info.misc_info_1) {
break;
}
r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.misc_info.misc_info_1, sizeof (*obj->streams.misc_info.misc_info_1));
if (r != sizeof (*obj->streams.misc_info.misc_info_1)) {
break;
}
sdb_num_set (obj->kv, ""mdmp_misc_info.offset"",
entry->location.rva, 0);
sdb_set (obj->kv, ""mdmp_misc_info.format"", ""d[4]Bdtttddddd ""
""SizeOfInfo (mdmp_misc1_flags)Flags1 ProcessId ""
""ProcessCreateTime ProcessUserTime ProcessKernelTime ""
""ProcessorMaxMhz ProcessorCurrentMhz ""
""ProcessorMhzLimit ProcessorMaxIdleState ""
""ProcessorCurrentIdleState"", 0);
break;
case MEMORY_INFO_LIST_STREAM:
r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&memory_info_list, sizeof (memory_info_list));
if (r != sizeof (memory_info_list)) {
break;
}
sdb_set (obj->kv, ""mdmp_memory_info.format"",
""qq[4]Edq[4]E[4]E[4]Ed BaseAddress AllocationBase ""
""(mdmp_page_protect)AllocationProtect __Alignment1 RegionSize ""
""(mdmp_mem_state)State (mdmp_page_protect)Protect ""
""(mdmp_mem_type)Type __Alignment2"", 0);
sdb_num_set (obj->kv, ""mdmp_memory_info_list.offset"",
entry->location.rva, 0);
sdb_set (obj->kv, ""mdmp_memory_info_list.format"",
r_strf (""ddq[%""PFMT64d""]? SizeOfHeader SizeOfEntry ""
""NumberOfEntries (mdmp_memory_info)MemoryInfo"",
memory_info_list.number_of_entries),
0);
offset = entry->location.rva + sizeof (memory_info_list);
for (i = 0; i < memory_info_list.number_of_entries; i++) {
struct minidump_memory_info *info = R_NEW (struct minidump_memory_info);
if (!info) {
break;
}
r = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));
if (r != sizeof (*info)) {
break;
}
r_list_append (obj->streams.memory_infos, info);
offset += sizeof (*info);
}
break;
case THREAD_INFO_LIST_STREAM:
r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&thread_info_list, sizeof (thread_info_list));
if (r != sizeof (thread_info_list)) {
break;
}
sdb_set (obj->kv, ""mdmp_thread_info.format"", ""ddddttttqq ""
""ThreadId DumpFlags DumpError ExitStatus CreateTime ""
""ExitTime KernelTime UserTime StartAddress Affinity"",
0);
sdb_num_set (obj->kv, ""mdmp_thread_info_list.offset"",
entry->location.rva, 0);
sdb_set (obj->kv, ""mdmp_thread_info_list.format"", ""ddd ""
""SizeOfHeader SizeOfEntry NumberOfEntries"", 0);
offset = entry->location.rva + sizeof (thread_info_list);
for (i = 0; i < thread_info_list.number_of_entries; i++) {
struct minidump_thread_info *info = R_NEW (struct minidump_thread_info);
if (!info) {
break;
}
r = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));
if (r != sizeof (*info)) {
break;
}
r_list_append (obj->streams.thread_infos, info);
offset += sizeof (*info);
}
break;
case HANDLE_OPERATION_LIST_STREAM:
r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&handle_operation_list, sizeof (handle_operation_list));
if (r != sizeof (handle_operation_list)) {
break;
}
sdb_num_set (obj->kv, ""mdmp_handle_operation_list.offset"",
entry->location.rva, 0);
sdb_set (obj->kv, ""mdmp_handle_operation_list.format"", ""dddd ""
""SizeOfHeader SizeOfEntry NumberOfEntries Reserved"", 0);
offset = entry->location.rva + sizeof (handle_operation_list);
for (i = 0; i < handle_operation_list.number_of_entries; i++) {
struct avrf_handle_operation *op = R_NEW (struct avrf_handle_operation);
if (!op) {
break;
}
r = r_buf_read_at (obj->b, offset, (ut8 *)op, sizeof (*op));
if (r != sizeof (*op)) {
break;
}
r_list_append (obj->streams.operations, op);
offset += sizeof (*op);
}
break;
case TOKEN_STREAM:
r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&token_info_list, sizeof (token_info_list));
if (r != sizeof (token_info_list)) {
break;
}
sdb_set (obj->kv, ""mdmp_token_info.format"", ""ddq ""
""TokenSize TokenId TokenHandle"", 0);
sdb_num_set (obj->kv, ""mdmp_token_info_list.offset"",
entry->location.rva, 0);
sdb_set (obj->kv, ""mdmp_token_info_list.format"", ""dddd ""
""TokenListSize TokenListEntries ListHeaderSize ElementHeaderSize"", 0);
offset = entry->location.rva + sizeof (token_info_list);
for (i = 0; i < token_info_list.number_of_entries; i++) {
struct minidump_token_info *info = R_NEW (struct minidump_token_info);
if (!info) {
break;
}
r = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));
if (r != sizeof (*info)) {
break;
}
r_list_append (obj->streams.token_infos, info);
offset += sizeof (*info);
}
break;
case LAST_RESERVED_STREAM:
break;
case UNUSED_STREAM:
case RESERVED_STREAM_0:
case RESERVED_STREAM_1:
break;
default:
eprintf (""[WARN] Invalid or unsupported enumeration encountered %d\n"", entry->stream_type);
break;
}
return true;
}","static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *VAR_0, struct minidump_directory *VAR_1) {
r_strf_buffer (128);
struct minidump_handle_operation_list VAR_2;
struct minidump_memory_list VAR_3;
struct minidump_memory64_list VAR_4;
struct minidump_memory_info_list VAR_5;
struct minidump_module_list VAR_6;
struct minidump_thread_list VAR_7;
struct minidump_thread_ex_list VAR_8;
struct minidump_thread_info_list VAR_9;
struct minidump_token_info_list VAR_10;
struct minidump_unloaded_module_list VAR_11;
ut64 VAR_12;
int VAR_13, VAR_14;
if ((ut64)VAR_1->location.rva + VAR_1->location.data_size > r_buf_size (VAR_0->b)) {
eprintf (""[ERROR] Size Mismatch - Stream data is larger than file size!\n"");
return false;
}
switch (VAR_1->stream_type) {
case VAR_15:
VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_7, sizeof (VAR_7));
if (VAR_14 != sizeof (VAR_7)) {
break;
}
sdb_set (VAR_0->kv, ""mdmp_thread.format"", ""ddddq?? ""
""ThreadId SuspendCount PriorityClass Priority ""
""Teb (mdmp_memory_descriptor)Stack ""
""(mdmp_location_descriptor)ThreadContext"", 0);
sdb_num_set (VAR_0->kv, ""mdmp_thread_list.offset"",
VAR_1->location.rva, 0);
sdb_set (VAR_0->kv, ""mdmp_thread_list.format"",
r_strf (""d[%d]? ""
""NumberOfThreads (mdmp_thread)Threads"",
VAR_7.number_of_threads),
0);
break;
case VAR_16:
VAR_6.number_of_modules = r_buf_read_le32_at (VAR_0->b, VAR_1->location.rva);
sdb_set (VAR_0->kv, ""mdmp_module.format"", ""qddtd???qq ""
""BaseOfImage SizeOfImage CheckSum ""
""TimeDateStamp ModuleNameRVA ""
""(mdmp_vs_fixedfileinfo)VersionInfo ""
""(mdmp_location_descriptor)CvRecord ""
""(mdmp_location_descriptor)MiscRecord ""
""Reserved0 Reserved1"", 0);
sdb_num_set (VAR_0->kv, ""mdmp_module_list.offset"",
VAR_1->location.rva, 0);
sdb_set (VAR_0->kv, ""mdmp_module_list.format"",
r_strf (""d[%d]? ""
""NumberOfModule (mdmp_module)Modules"",
VAR_6.number_of_modules),
0);
VAR_12 = VAR_1->location.rva + sizeof (VAR_6);
for (VAR_13 = 0; VAR_13 < VAR_6.number_of_modules; VAR_13++) {
struct minidump_module *VAR_17 = R_NEW (struct minidump_module);
if (!VAR_17) {
break;
}
read_module (VAR_0->b, VAR_12, VAR_17);
r_list_append (VAR_0->streams.modules, VAR_17);
VAR_12 += sizeof (*VAR_17);
}
break;
case VAR_18:
VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_3, sizeof (VAR_3));
if (VAR_14 != sizeof (VAR_3)) {
break;
}
sdb_num_set (VAR_0->kv, ""mdmp_memory_list.offset"",
VAR_1->location.rva, 0);
sdb_set (VAR_0->kv, ""mdmp_memory_list.format"",
r_strf (""d[%d]? ""
""NumberOfMemoryRanges ""
""(mdmp_memory_descriptor)MemoryRanges "",
VAR_3.number_of_memory_ranges),
0);
VAR_12 = VAR_1->location.rva + sizeof (VAR_3);
for (VAR_13 = 0; VAR_13 < VAR_3.number_of_memory_ranges; VAR_13++) {
struct minidump_memory_descriptor *VAR_19 = R_NEW (struct minidump_memory_descriptor);
if (!VAR_19) {
break;
}
VAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_19, sizeof (*VAR_19));
if (VAR_14 != sizeof (*VAR_19)) {
break;
}
r_list_append (VAR_0->streams.memories, VAR_19);
VAR_12 += sizeof (*VAR_19);
}
break;
case VAR_20:
VAR_0->streams.exception = R_NEW (struct VAR_21);
if (!VAR_0->streams.exception) {
break;
}
VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)VAR_0->streams.exception, sizeof (*VAR_0->streams.exception));
if (VAR_14 != sizeof (*VAR_0->streams.exception)) {
break;
}
sdb_set (VAR_0->kv, ""mdmp_exception.format"", ""[4]E[4]Eqqdd[15]q ""
""(mdmp_exception_code)ExceptionCode ""
""(mdmp_exception_flags)ExceptionFlags ""
""ExceptionRecord ExceptionAddress ""
""NumberParameters __UnusedAlignment ""
""ExceptionInformation"",
0);
sdb_num_set (VAR_0->kv, ""mdmp_exception_stream.offset"",
VAR_1->location.rva, 0);
sdb_set (VAR_0->kv, ""mdmp_exception_stream.format"", ""dd?? ""
""ThreadId __Alignment ""
""(mdmp_exception)ExceptionRecord ""
""(mdmp_location_descriptor)ThreadContext"",
0);
break;
case VAR_22:
VAR_0->streams.system_info = R_NEW (struct VAR_23);
if (!VAR_0->streams.system_info) {
break;
}
VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)VAR_0->streams.system_info, sizeof (*VAR_0->streams.system_info));
if (VAR_14 != sizeof (*VAR_0->streams.system_info)) {
break;
}
sdb_num_set (VAR_0->kv, ""mdmp_system_info.offset"",
VAR_1->location.rva, 0);
sdb_set (VAR_0->kv, ""mdmp_system_info.format"", ""[2]EwwbBddd[4]Ed[2]Ew[2]q ""
""(mdmp_processor_architecture)ProcessorArchitecture ""
""ProcessorLevel ProcessorRevision NumberOfProcessors ""
""(mdmp_product_type)ProductType ""
""MajorVersion MinorVersion BuildNumber (mdmp_platform_id)PlatformId ""
""CsdVersionRva (mdmp_suite_mask)SuiteMask Reserved2 ProcessorFeatures"", 0);
break;
case VAR_24:
VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_8, sizeof (VAR_8));
if (VAR_14 != sizeof (VAR_8)) {
break;
}
sdb_set (VAR_0->kv, ""mdmp_thread_ex.format"", ""ddddq??? ""
""ThreadId SuspendCount PriorityClass Priority ""
""Teb (mdmp_memory_descriptor)Stack ""
""(mdmp_location_descriptor)ThreadContext ""
""(mdmp_memory_descriptor)BackingStore"", 0);
sdb_num_set (VAR_0->kv, ""mdmp_thread_ex_list.offset"",
VAR_1->location.rva, 0);
sdb_set (VAR_0->kv, ""mdmp_thread_ex_list.format"",
r_strf (""d[%d]? NumberOfThreads ""
""(mdmp_thread_ex)Threads"",
VAR_8.number_of_threads),
0);
VAR_12 = VAR_1->location.rva + sizeof (VAR_8);
for (VAR_13 = 0; VAR_13 < VAR_8.number_of_threads; VAR_13++) {
struct minidump_thread_ex *VAR_25 = R_NEW (struct minidump_thread_ex);
if (!VAR_25) {
break;
}
VAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_25, sizeof (*VAR_25));
if (VAR_14 != sizeof (*VAR_25)) {
break;
}
r_list_append (VAR_0->streams.ex_threads, VAR_25);
VAR_12 += sizeof (*VAR_25);
}
break;
case VAR_26:
read_memory64_list (VAR_0->b, VAR_1->location.rva, &VAR_4);
sdb_num_set (VAR_0->kv, ""mdmp_memory64_list.offset"",
VAR_1->location.rva, 0);
sdb_set (VAR_0->kv, ""mdmp_memory64_list.format"",
r_strf (""qq[%""VAR_27""]? NumberOfMemoryRanges ""
""BaseRva ""
""(mdmp_memory_descriptor64)MemoryRanges"",
VAR_4.number_of_memory_ranges),
0);
VAR_0->streams.memories64.base_rva = VAR_4.base_rva;
VAR_12 = VAR_1->location.rva + sizeof (VAR_4);
for (VAR_13 = 0; VAR_13 < VAR_4.number_of_memory_ranges; VAR_13++) {
struct minidump_memory_descriptor64 *VAR_19 = R_NEW (struct minidump_memory_descriptor64);
if (!VAR_19) {
break;
}
read_desc (VAR_0->b, VAR_12, VAR_19);
r_list_append (VAR_0->streams.memories64.memories, VAR_19);
VAR_12 += sizeof (*VAR_19);
}
break;
case VAR_28:
VAR_0->streams.comments_a = R_NEWS (ut8, VAR_29);
if (!VAR_0->streams.comments_a) {
break;
}
VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, VAR_0->streams.comments_a, VAR_29);
if (VAR_14 != VAR_29) {
break;
}
sdb_num_set (VAR_0->kv, ""mdmp_comment_stream_a.offset"",
VAR_1->location.rva, 0);
sdb_set (VAR_0->kv, ""mdmp_comment_stream_a.format"",
""s CommentA"", 0);
break;
case VAR_30:
VAR_0->streams.comments_w = R_NEWS (ut8, VAR_29);
if (!VAR_0->streams.comments_w) {
break;
}
VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, VAR_0->streams.comments_w, VAR_29);
if (VAR_14 != VAR_29) {
break;
}
sdb_num_set (VAR_0->kv, ""mdmp_comment_stream_w.offset"",
VAR_1->location.rva, 0);
sdb_set (VAR_0->kv, ""mdmp_comment_stream_w.format"",
""s CommentW"", 0);
break;
case VAR_31:
VAR_0->streams.handle_data = R_NEW (struct VAR_32);
if (!VAR_0->streams.handle_data) {
break;
}
VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)VAR_0->streams.handle_data, sizeof (*VAR_0->streams.handle_data));
if (VAR_14 != sizeof (*VAR_0->streams.handle_data)) {
break;
}
sdb_num_set (VAR_0->kv, ""mdmp_handle_data_stream.offset"",
VAR_1->location.rva, 0);
sdb_set (VAR_0->kv, ""mdmp_handle_data_stream.format"", ""dddd ""
""SizeOfHeader SizeOfDescriptor ""
""NumberOfDescriptors Reserved"", 0);
break;
case VAR_33:
VAR_0->streams.function_table = R_NEW (struct VAR_34);
if (!VAR_0->streams.function_table) {
break;
}
VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)VAR_0->streams.function_table, sizeof (*VAR_0->streams.function_table));
if (VAR_14 != sizeof (*VAR_0->streams.function_table)) {
break;
}
sdb_num_set (VAR_0->kv, ""mdmp_function_table_stream.offset"",
VAR_1->location.rva, 0);
sdb_set (VAR_0->kv, ""mdmp_function_table_stream.format"", ""dddddd ""
""SizeOfHeader SizeOfDescriptor SizeOfNativeDescriptor ""
""SizeOfFunctionEntry NumberOfDescriptors SizeOfAlignPad"",
0);
break;
case VAR_35:
VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_11, sizeof (VAR_11));
if (VAR_14 != sizeof (VAR_11)) {
break;
}
sdb_set (VAR_0->kv, ""mdmp_unloaded_module.format"", ""qddtd ""
""BaseOfImage SizeOfImage CheckSum TimeDateStamp ""
""ModuleNameRva"", 0);
sdb_num_set (VAR_0->kv, ""mdmp_unloaded_module_list.offset"",
VAR_1->location.rva, 0);
sdb_set (VAR_0->kv, ""mdmp_unloaded_module_list.format"", ""ddd ""
""SizeOfHeader SizeOfEntry NumberOfEntries"", 0);
VAR_12 = VAR_1->location.rva + sizeof (VAR_11);
for (VAR_13 = 0; VAR_13 < VAR_11.number_of_entries; VAR_13++) {
struct minidump_unloaded_module *VAR_17 = R_NEW (struct minidump_unloaded_module);
if (!VAR_17) {
break;
}
VAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_17, sizeof (*VAR_17));
if (VAR_14 != sizeof (*VAR_17)) {
break;
}
r_list_append (VAR_0->streams.unloaded_modules, VAR_17);
VAR_12 += sizeof (*VAR_17);
}
break;
case VAR_36:
VAR_0->streams.misc_info.misc_info_1 = R_NEW (struct VAR_37);
if (!VAR_0->streams.misc_info.misc_info_1) {
break;
}
VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)VAR_0->streams.misc_info.misc_info_1, sizeof (*VAR_0->streams.misc_info.misc_info_1));
if (VAR_14 != sizeof (*VAR_0->streams.misc_info.misc_info_1)) {
break;
}
sdb_num_set (VAR_0->kv, ""mdmp_misc_info.offset"",
VAR_1->location.rva, 0);
sdb_set (VAR_0->kv, ""mdmp_misc_info.format"", ""d[4]Bdtttddddd ""
""SizeOfInfo (mdmp_misc1_flags)Flags1 ProcessId ""
""ProcessCreateTime ProcessUserTime ProcessKernelTime ""
""ProcessorMaxMhz ProcessorCurrentMhz ""
""ProcessorMhzLimit ProcessorMaxIdleState ""
""ProcessorCurrentIdleState"", 0);
break;
case VAR_38:
VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_5, sizeof (VAR_5));
if (VAR_14 != sizeof (VAR_5)) {
break;
}
sdb_set (VAR_0->kv, ""mdmp_memory_info.format"",
""qq[4]Edq[4]E[4]E[4]Ed BaseAddress AllocationBase ""
""(mdmp_page_protect)AllocationProtect __Alignment1 RegionSize ""
""(mdmp_mem_state)State (mdmp_page_protect)Protect ""
""(mdmp_mem_type)Type __Alignment2"", 0);
sdb_num_set (VAR_0->kv, ""mdmp_memory_info_list.offset"",
VAR_1->location.rva, 0);
sdb_set (VAR_0->kv, ""mdmp_memory_info_list.format"",
r_strf (""ddq[%""VAR_27""]? SizeOfHeader SizeOfEntry ""
""NumberOfEntries (mdmp_memory_info)MemoryInfo"",
VAR_5.number_of_entries),
0);
VAR_12 = VAR_1->location.rva + sizeof (VAR_5);
for (VAR_13 = 0; VAR_13 < VAR_5.number_of_entries; VAR_13++) {
struct minidump_memory_info *VAR_39 = R_NEW (struct minidump_memory_info);
if (!VAR_39) {
break;
}
VAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_39, sizeof (*VAR_39));
if (VAR_14 != sizeof (*VAR_39)) {
break;
}
r_list_append (VAR_0->streams.memory_infos, VAR_39);
VAR_12 += sizeof (*VAR_39);
}
break;
case VAR_40:
VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_9, sizeof (VAR_9));
if (VAR_14 != sizeof (VAR_9)) {
break;
}
sdb_set (VAR_0->kv, ""mdmp_thread_info.format"", ""ddddttttqq ""
""ThreadId DumpFlags DumpError ExitStatus CreateTime ""
""ExitTime KernelTime UserTime StartAddress Affinity"",
0);
sdb_num_set (VAR_0->kv, ""mdmp_thread_info_list.offset"",
VAR_1->location.rva, 0);
sdb_set (VAR_0->kv, ""mdmp_thread_info_list.format"", ""ddd ""
""SizeOfHeader SizeOfEntry NumberOfEntries"", 0);
VAR_12 = VAR_1->location.rva + sizeof (VAR_9);
for (VAR_13 = 0; VAR_13 < VAR_9.number_of_entries; VAR_13++) {
struct minidump_thread_info *VAR_39 = R_NEW (struct minidump_thread_info);
if (!VAR_39) {
break;
}
VAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_39, sizeof (*VAR_39));
if (VAR_14 != sizeof (*VAR_39)) {
break;
}
r_list_append (VAR_0->streams.thread_infos, VAR_39);
VAR_12 += sizeof (*VAR_39);
}
break;
case VAR_41:
VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_2, sizeof (VAR_2));
if (VAR_14 != sizeof (VAR_2)) {
break;
}
sdb_num_set (VAR_0->kv, ""mdmp_handle_operation_list.offset"",
VAR_1->location.rva, 0);
sdb_set (VAR_0->kv, ""mdmp_handle_operation_list.format"", ""dddd ""
""SizeOfHeader SizeOfEntry NumberOfEntries Reserved"", 0);
VAR_12 = VAR_1->location.rva + sizeof (VAR_2);
for (VAR_13 = 0; VAR_13 < VAR_2.number_of_entries; VAR_13++) {
struct avrf_handle_operation *VAR_42 = R_NEW (struct avrf_handle_operation);
if (!VAR_42) {
break;
}
VAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_42, sizeof (*VAR_42));
if (VAR_14 != sizeof (*VAR_42)) {
break;
}
r_list_append (VAR_0->streams.operations, VAR_42);
VAR_12 += sizeof (*VAR_42);
}
break;
case VAR_43:
VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_10, sizeof (VAR_10));
if (VAR_14 != sizeof (VAR_10)) {
break;
}
sdb_set (VAR_0->kv, ""mdmp_token_info.format"", ""ddq ""
""TokenSize TokenId TokenHandle"", 0);
sdb_num_set (VAR_0->kv, ""mdmp_token_info_list.offset"",
VAR_1->location.rva, 0);
sdb_set (VAR_0->kv, ""mdmp_token_info_list.format"", ""dddd ""
""TokenListSize TokenListEntries ListHeaderSize ElementHeaderSize"", 0);
VAR_12 = VAR_1->location.rva + sizeof (VAR_10);
for (VAR_13 = 0; VAR_13 < VAR_10.number_of_entries; VAR_13++) {
struct minidump_token_info *VAR_39 = R_NEW (struct minidump_token_info);
if (!VAR_39) {
break;
}
VAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_39, sizeof (*VAR_39));
if (VAR_14 != sizeof (*VAR_39)) {
break;
}
r_list_append (VAR_0->streams.token_infos, VAR_39);
VAR_12 += sizeof (*VAR_39);
}
break;
case VAR_44:
break;
case VAR_45:
case VAR_46:
case VAR_47:
break;
default:
eprintf (""[WARN] Invalid or unsupported enumeration encountered %d\n"", VAR_1->stream_type);
break;
}
return true;
}",radareorg/radare2/27fe8031782d3a06c3998eaa94354867864f9f1b/mdmp.c/vul/before/1.json,"static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct minidump_directory *entry) {
	r_strf_buffer (128);
	struct minidump_handle_operation_list handle_operation_list;
	struct minidump_memory_list memory_list;
	struct minidump_memory64_list memory64_list;
	struct minidump_memory_info_list memory_info_list;
	struct minidump_module_list module_list;
	struct minidump_thread_list thread_list;
	struct minidump_thread_ex_list thread_ex_list;
	struct minidump_thread_info_list thread_info_list;
	struct minidump_token_info_list token_info_list;
	struct minidump_unloaded_module_list unloaded_module_list;
	ut64 offset;
	int i, r;

	/* We could confirm data sizes but a malcious MDMP will always get around
	** this! But we can ensure that the data is not outside of the file */
	if ((ut64)entry->location.rva + entry->location.data_size > r_buf_size (obj->b)) {
		eprintf (""[ERROR] Size Mismatch - Stream data is larger than file size!\n"");
		return false;
	}

	switch (entry->stream_type) {
	case THREAD_LIST_STREAM:
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&thread_list, sizeof (thread_list));
		if (r != sizeof (thread_list)) {
			break;
		}

		sdb_set (obj->kv, ""mdmp_thread.format"", ""ddddq?? ""
			""ThreadId SuspendCount PriorityClass Priority ""
			""Teb (mdmp_memory_descriptor)Stack ""
			""(mdmp_location_descriptor)ThreadContext"", 0);
		sdb_num_set (obj->kv, ""mdmp_thread_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_thread_list.format"",
			r_strf (""d[%d]? ""
				""NumberOfThreads (mdmp_thread)Threads"",
				thread_list.number_of_threads),
			0);

		/* TODO: Not yet fully parsed or utilised */
		break;
	case MODULE_LIST_STREAM:
		module_list.number_of_modules = r_buf_read_le32_at (obj->b, entry->location.rva);

		sdb_set (obj->kv, ""mdmp_module.format"", ""qddtd???qq ""
			""BaseOfImage SizeOfImage CheckSum ""
			""TimeDateStamp ModuleNameRVA ""
			""(mdmp_vs_fixedfileinfo)VersionInfo ""
			""(mdmp_location_descriptor)CvRecord ""
			""(mdmp_location_descriptor)MiscRecord ""
			""Reserved0 Reserved1"", 0);
		sdb_num_set (obj->kv, ""mdmp_module_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_module_list.format"",
			r_strf (""d[%d]? ""
				""NumberOfModule (mdmp_module)Modules"",
				module_list.number_of_modules),
			0);

		offset = entry->location.rva + sizeof (module_list);
		for (i = 0; i < module_list.number_of_modules && offset < obj->size; i++) {
			struct minidump_module *module = read_module (obj->b, offset);
			if (!module) {
				break;	
			}
			r_list_append (obj->streams.modules, module);
			offset += sizeof (*module);
		}
		break;
	case MEMORY_LIST_STREAM:
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&memory_list, sizeof (memory_list));
		if (r != sizeof (memory_list)) {
			break;
		}

		sdb_num_set (obj->kv, ""mdmp_memory_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_memory_list.format"",
			r_strf (""d[%d]? ""
				""NumberOfMemoryRanges ""
				""(mdmp_memory_descriptor)MemoryRanges "",
				memory_list.number_of_memory_ranges),
			0);

		offset = entry->location.rva + sizeof (memory_list);
		for (i = 0; i < memory_list.number_of_memory_ranges && offset < obj->size; i++) {
			struct minidump_memory_descriptor *desc = R_NEW (struct minidump_memory_descriptor);
			if (!desc) {
				break;
			}
			r = r_buf_read_at (obj->b, offset, (ut8 *)desc, sizeof (*desc));
			if (r != sizeof (*desc)) {
				break;
			}
			r_list_append (obj->streams.memories, desc);
			offset += sizeof (*desc);
		}
		break;
	case EXCEPTION_STREAM:
		/* TODO: Not yet fully parsed or utilised */
		obj->streams.exception = R_NEW (struct minidump_exception_stream);
		if (!obj->streams.exception) {
			break;
		}

		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.exception, sizeof (*obj->streams.exception));
		if (r != sizeof (*obj->streams.exception)) {
			break;
		}

		sdb_set (obj->kv, ""mdmp_exception.format"", ""[4]E[4]Eqqdd[15]q ""
							   ""(mdmp_exception_code)ExceptionCode ""
							   ""(mdmp_exception_flags)ExceptionFlags ""
							   ""ExceptionRecord ExceptionAddress ""
							   ""NumberParameters __UnusedAlignment ""
							   ""ExceptionInformation"",
			0);
		sdb_num_set (obj->kv, ""mdmp_exception_stream.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_exception_stream.format"", ""dd?? ""
								  ""ThreadId __Alignment ""
								  ""(mdmp_exception)ExceptionRecord ""
								  ""(mdmp_location_descriptor)ThreadContext"",
			0);

		break;
	case SYSTEM_INFO_STREAM:
		obj->streams.system_info = R_NEW (struct minidump_system_info);
		if (!obj->streams.system_info) {
			break;
		}
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.system_info, sizeof (*obj->streams.system_info));
		if (r != sizeof (*obj->streams.system_info)) {
			break;
		}

		sdb_num_set (obj->kv, ""mdmp_system_info.offset"",
			entry->location.rva, 0);
		/* TODO: We need E as a byte! */
		sdb_set (obj->kv, ""mdmp_system_info.format"", ""[2]EwwbBddd[4]Ed[2]Ew[2]q ""
			""(mdmp_processor_architecture)ProcessorArchitecture ""
			""ProcessorLevel ProcessorRevision NumberOfProcessors ""
			""(mdmp_product_type)ProductType ""
			""MajorVersion MinorVersion BuildNumber (mdmp_platform_id)PlatformId ""
			""CsdVersionRva (mdmp_suite_mask)SuiteMask Reserved2 ProcessorFeatures"", 0);

		break;
	case THREAD_EX_LIST_STREAM:
		/* TODO: Not yet fully parsed or utilised */
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&thread_ex_list, sizeof (thread_ex_list));
		if (r != sizeof (thread_ex_list)) {
			break;
		}

		sdb_set (obj->kv, ""mdmp_thread_ex.format"", ""ddddq??? ""
			""ThreadId SuspendCount PriorityClass Priority ""
			""Teb (mdmp_memory_descriptor)Stack ""
			""(mdmp_location_descriptor)ThreadContext ""
			""(mdmp_memory_descriptor)BackingStore"", 0);
		sdb_num_set (obj->kv, ""mdmp_thread_ex_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_thread_ex_list.format"",
			r_strf (""d[%d]? NumberOfThreads ""
				""(mdmp_thread_ex)Threads"",
				thread_ex_list.number_of_threads),
			0);

		offset = entry->location.rva + sizeof (thread_ex_list);
		for (i = 0; i < thread_ex_list.number_of_threads && offset < obj->size; i++) {
			struct minidump_thread_ex *thread = R_NEW (struct minidump_thread_ex);
			if (!thread) {
				break;
			}
			r = r_buf_read_at (obj->b, offset, (ut8 *)thread, sizeof (*thread));
			if (r != sizeof (*thread)) {
				break;
			}
			r_list_append (obj->streams.ex_threads, thread);
			offset += sizeof (*thread);
		}
		break;
	case MEMORY_64_LIST_STREAM:
		read_memory64_list (obj->b, entry->location.rva, &memory64_list);

		sdb_num_set (obj->kv, ""mdmp_memory64_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_memory64_list.format"",
			r_strf (""qq[%""PFMT64d""]? NumberOfMemoryRanges ""
				""BaseRva ""
				""(mdmp_memory_descriptor64)MemoryRanges"",
				memory64_list.number_of_memory_ranges),
			0);

		obj->streams.memories64.base_rva = memory64_list.base_rva;
		offset = entry->location.rva + sizeof (memory64_list);
		for (i = 0; i < memory64_list.number_of_memory_ranges && offset < obj->size; i++) {
			struct minidump_memory_descriptor64 *desc = R_NEW (struct minidump_memory_descriptor64);
			if (!desc) {
				break;
			}
			read_desc (obj->b, offset, desc);
			r_list_append (obj->streams.memories64.memories, desc);
			offset += sizeof (*desc);
		}
		break;
	case COMMENT_STREAM_A:
		/* TODO: Not yet fully parsed or utilised */
		obj->streams.comments_a = R_NEWS (ut8, COMMENTS_SIZE);
		if (!obj->streams.comments_a) {
			break;
		}
		r = r_buf_read_at (obj->b, entry->location.rva, obj->streams.comments_a, COMMENTS_SIZE);
		if (r != COMMENTS_SIZE) {
			break;
		}

		sdb_num_set (obj->kv, ""mdmp_comment_stream_a.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_comment_stream_a.format"",
			""s CommentA"", 0);

		break;
	case COMMENT_STREAM_W:
		/* TODO: Not yet fully parsed or utilised */
		obj->streams.comments_w = R_NEWS (ut8, COMMENTS_SIZE);
		if (!obj->streams.comments_w) {
			break;
		}
		r = r_buf_read_at (obj->b, entry->location.rva, obj->streams.comments_w, COMMENTS_SIZE);
		if (r != COMMENTS_SIZE) {
			break;
		}

		sdb_num_set (obj->kv, ""mdmp_comment_stream_w.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_comment_stream_w.format"",
				""s CommentW"", 0);

		break;
	case HANDLE_DATA_STREAM:
		/* TODO: Not yet fully parsed or utilised */
		obj->streams.handle_data = R_NEW (struct minidump_handle_data_stream);
		if (!obj->streams.handle_data) {
			break;
		}
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.handle_data, sizeof (*obj->streams.handle_data));
		if (r != sizeof (*obj->streams.handle_data)) {
			break;
		}

		sdb_num_set (obj->kv, ""mdmp_handle_data_stream.offset"",
				entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_handle_data_stream.format"", ""dddd ""
				""SizeOfHeader SizeOfDescriptor ""
				""NumberOfDescriptors Reserved"", 0);
		break;
	case FUNCTION_TABLE_STREAM:
		/* TODO: Not yet fully parsed or utilised */
		obj->streams.function_table = R_NEW (struct minidump_function_table_stream);
		if (!obj->streams.function_table) {
			break;
		}
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.function_table, sizeof (*obj->streams.function_table));
		if (r != sizeof (*obj->streams.function_table)) {
			break;
		}

		sdb_num_set (obj->kv, ""mdmp_function_table_stream.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_function_table_stream.format"", ""dddddd ""
			""SizeOfHeader SizeOfDescriptor SizeOfNativeDescriptor ""
			""SizeOfFunctionEntry NumberOfDescriptors SizeOfAlignPad"",
			0);
		break;
	case UNLOADED_MODULE_LIST_STREAM:
		/* TODO: Not yet fully parsed or utilised */
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&unloaded_module_list, sizeof (unloaded_module_list));
		if (r != sizeof (unloaded_module_list)) {
			break;
		}

		sdb_set (obj->kv, ""mdmp_unloaded_module.format"", ""qddtd ""
			""BaseOfImage SizeOfImage CheckSum TimeDateStamp ""
			""ModuleNameRva"", 0);
		sdb_num_set (obj->kv, ""mdmp_unloaded_module_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_unloaded_module_list.format"", ""ddd ""
			""SizeOfHeader SizeOfEntry NumberOfEntries"", 0);

		offset = entry->location.rva + sizeof (unloaded_module_list);
		for (i = 0; i < unloaded_module_list.number_of_entries && offset < obj->size; i++) {
			struct minidump_unloaded_module *module = R_NEW (struct minidump_unloaded_module);
			if (!module) {
				break;
			}
			r = r_buf_read_at (obj->b, offset, (ut8 *)module, sizeof (*module));
			if (r != sizeof (*module)) {
				break;
			}
			r_list_append (obj->streams.unloaded_modules, module);
			offset += sizeof (*module);
		}
		break;
	case MISC_INFO_STREAM:
		/* TODO: Not yet fully parsed or utilised */
		obj->streams.misc_info.misc_info_1 = R_NEW (struct minidump_misc_info);
		if (!obj->streams.misc_info.misc_info_1) {
			break;
		}
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.misc_info.misc_info_1, sizeof (*obj->streams.misc_info.misc_info_1));
		if (r != sizeof (*obj->streams.misc_info.misc_info_1)) {
			break;
		}

		/* TODO: Handle different sizes */
		sdb_num_set (obj->kv, ""mdmp_misc_info.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_misc_info.format"", ""d[4]Bdtttddddd ""
			""SizeOfInfo (mdmp_misc1_flags)Flags1 ProcessId ""
			""ProcessCreateTime ProcessUserTime ProcessKernelTime ""
			""ProcessorMaxMhz ProcessorCurrentMhz ""
			""ProcessorMhzLimit ProcessorMaxIdleState ""
			""ProcessorCurrentIdleState"", 0);

		break;
	case MEMORY_INFO_LIST_STREAM:
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&memory_info_list, sizeof (memory_info_list));
		if (r != sizeof (memory_info_list)) {
			break;
		}

		sdb_set (obj->kv, ""mdmp_memory_info.format"",
			""qq[4]Edq[4]E[4]E[4]Ed BaseAddress AllocationBase ""
			""(mdmp_page_protect)AllocationProtect __Alignment1 RegionSize ""
			""(mdmp_mem_state)State (mdmp_page_protect)Protect ""
			""(mdmp_mem_type)Type __Alignment2"", 0);
		sdb_num_set (obj->kv, ""mdmp_memory_info_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_memory_info_list.format"",
			r_strf (""ddq[%""PFMT64d""]? SizeOfHeader SizeOfEntry ""
				""NumberOfEntries (mdmp_memory_info)MemoryInfo"",
				memory_info_list.number_of_entries),
			0);

		offset = entry->location.rva + sizeof (memory_info_list);
		for (i = 0; i < memory_info_list.number_of_entries && offset < obj->size; i++) {
			struct minidump_memory_info *info = R_NEW (struct minidump_memory_info);
			if (!info) {
				break;
			}
			r = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));
			if (r != sizeof (*info)) {
				break;
			}
			r_list_append (obj->streams.memory_infos, info);
			offset += sizeof (*info);
		}
		break;
	case THREAD_INFO_LIST_STREAM:
		/* TODO: Not yet fully parsed or utilised */
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&thread_info_list, sizeof (thread_info_list));
		if (r != sizeof (thread_info_list)) {
			break;
		}

		sdb_set (obj->kv, ""mdmp_thread_info.format"", ""ddddttttqq ""
			""ThreadId DumpFlags DumpError ExitStatus CreateTime ""
			""ExitTime KernelTime UserTime StartAddress Affinity"",
			0);
		sdb_num_set (obj->kv, ""mdmp_thread_info_list.offset"",
				entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_thread_info_list.format"", ""ddd ""
			""SizeOfHeader SizeOfEntry NumberOfEntries"", 0);

		offset = entry->location.rva + sizeof (thread_info_list);
		for (i = 0; i < thread_info_list.number_of_entries && offset < obj->size; i++) {
			struct minidump_thread_info *info = R_NEW (struct minidump_thread_info);
			if (!info) {
				break;
			}
			r = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));
			if (r != sizeof (*info)) {
				break;
			}
			r_list_append (obj->streams.thread_infos, info);
			offset += sizeof (*info);
		}
		break;
	case HANDLE_OPERATION_LIST_STREAM:
		/* TODO: Not yet fully parsed or utilised */
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&handle_operation_list, sizeof (handle_operation_list));
		if (r != sizeof (handle_operation_list)) {
			break;
		}

		sdb_num_set (obj->kv, ""mdmp_handle_operation_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_handle_operation_list.format"", ""dddd ""
			""SizeOfHeader SizeOfEntry NumberOfEntries Reserved"", 0);

		offset = entry->location.rva + sizeof (handle_operation_list);
		for (i = 0; i < handle_operation_list.number_of_entries && offset < obj->size; i++) {
			struct avrf_handle_operation *op = R_NEW (struct avrf_handle_operation);
			if (!op) {
				break;
			}
			r = r_buf_read_at (obj->b, offset, (ut8 *)op, sizeof (*op));
			if (r != sizeof (*op)) {
				break;
			}
			r_list_append (obj->streams.operations, op);
			offset += sizeof (*op);
		}

		break;
	case TOKEN_STREAM:
		/* TODO: Not fully parsed or utilised */
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&token_info_list, sizeof (token_info_list));
		if (r != sizeof (token_info_list)) {
			break;
		}

		sdb_set (obj->kv, ""mdmp_token_info.format"", ""ddq ""
			""TokenSize TokenId TokenHandle"", 0);

		sdb_num_set (obj->kv, ""mdmp_token_info_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_token_info_list.format"", ""dddd ""
			""TokenListSize TokenListEntries ListHeaderSize ElementHeaderSize"", 0);

		offset = entry->location.rva + sizeof (token_info_list);
		for (i = 0; i < token_info_list.number_of_entries && offset < obj->size; i++) {
			struct minidump_token_info *info = R_NEW (struct minidump_token_info);
			if (!info) {
				break;
			}
			r = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));
			if (r != sizeof (*info)) {
				break;
			}
			r_list_append (obj->streams.token_infos, info);
			offset += sizeof (*info);
		}
		break;

	case LAST_RESERVED_STREAM:
		/* TODO: Not yet fully parsed or utilised */
		break;
	case UNUSED_STREAM:
	case RESERVED_STREAM_0:
	case RESERVED_STREAM_1:
		/* Silently ignore reserved streams */
		break;
	default:
		eprintf (""[WARN] Invalid or unsupported enumeration encountered %d\n"", entry->stream_type);
		break;
	}
	return true;
}","static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *VAR_0, struct minidump_directory *VAR_1) {
	r_strf_buffer (128);
	struct minidump_handle_operation_list VAR_2;
	struct minidump_memory_list VAR_3;
	struct minidump_memory64_list VAR_4;
	struct minidump_memory_info_list VAR_5;
	struct minidump_module_list VAR_6;
	struct minidump_thread_list VAR_7;
	struct minidump_thread_ex_list VAR_8;
	struct minidump_thread_info_list VAR_9;
	struct minidump_token_info_list VAR_10;
	struct minidump_unloaded_module_list VAR_11;
	ut64 VAR_12;
	int VAR_13, VAR_14;

	/* COMMENT_0 */
                                                                       
	if ((ut64)VAR_1->location.rva + VAR_1->location.data_size > r_buf_size (VAR_0->b)) {
		eprintf (""[ERROR] Size Mismatch - Stream data is larger than file size!\n"");
		return false;
	}

	switch (VAR_1->stream_type) {
	case VAR_15:
		VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_7, sizeof (VAR_7));
		if (VAR_14 != sizeof (VAR_7)) {
			break;
		}

		sdb_set (VAR_0->kv, ""mdmp_thread.format"", ""ddddq?? ""
			""ThreadId SuspendCount PriorityClass Priority ""
			""Teb (mdmp_memory_descriptor)Stack ""
			""(mdmp_location_descriptor)ThreadContext"", 0);
		sdb_num_set (VAR_0->kv, ""mdmp_thread_list.offset"",
			VAR_1->location.rva, 0);
		sdb_set (VAR_0->kv, ""mdmp_thread_list.format"",
			r_strf (""d[%d]? ""
				""NumberOfThreads (mdmp_thread)Threads"",
				VAR_7.number_of_threads),
			0);

		/* COMMENT_2 */
		break;
	case VAR_16:
		VAR_6.number_of_modules = r_buf_read_le32_at (VAR_0->b, VAR_1->location.rva);

		sdb_set (VAR_0->kv, ""mdmp_module.format"", ""qddtd???qq ""
			""BaseOfImage SizeOfImage CheckSum ""
			""TimeDateStamp ModuleNameRVA ""
			""(mdmp_vs_fixedfileinfo)VersionInfo ""
			""(mdmp_location_descriptor)CvRecord ""
			""(mdmp_location_descriptor)MiscRecord ""
			""Reserved0 Reserved1"", 0);
		sdb_num_set (VAR_0->kv, ""mdmp_module_list.offset"",
			VAR_1->location.rva, 0);
		sdb_set (VAR_0->kv, ""mdmp_module_list.format"",
			r_strf (""d[%d]? ""
				""NumberOfModule (mdmp_module)Modules"",
				VAR_6.number_of_modules),
			0);

		VAR_12 = VAR_1->location.rva + sizeof (VAR_6);
		for (VAR_13 = 0; VAR_13 < VAR_6.number_of_modules && VAR_12 < VAR_0->size; VAR_13++) {
			struct minidump_module *VAR_17 = read_module (VAR_0->b, VAR_12);
			if (!VAR_17) {
				break;	
			}
			r_list_append (VAR_0->streams.modules, VAR_17);
			VAR_12 += sizeof (*VAR_17);
		}
		break;
	case VAR_18:
		VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_3, sizeof (VAR_3));
		if (VAR_14 != sizeof (VAR_3)) {
			break;
		}

		sdb_num_set (VAR_0->kv, ""mdmp_memory_list.offset"",
			VAR_1->location.rva, 0);
		sdb_set (VAR_0->kv, ""mdmp_memory_list.format"",
			r_strf (""d[%d]? ""
				""NumberOfMemoryRanges ""
				""(mdmp_memory_descriptor)MemoryRanges "",
				VAR_3.number_of_memory_ranges),
			0);

		VAR_12 = VAR_1->location.rva + sizeof (VAR_3);
		for (VAR_13 = 0; VAR_13 < VAR_3.number_of_memory_ranges && VAR_12 < VAR_0->size; VAR_13++) {
			struct minidump_memory_descriptor *VAR_19 = R_NEW (struct minidump_memory_descriptor);
			if (!VAR_19) {
				break;
			}
			VAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_19, sizeof (*VAR_19));
			if (VAR_14 != sizeof (*VAR_19)) {
				break;
			}
			r_list_append (VAR_0->streams.memories, VAR_19);
			VAR_12 += sizeof (*VAR_19);
		}
		break;
	case VAR_20:
		/* COMMENT_2 */
		VAR_0->streams.exception = R_NEW (struct VAR_21);
		if (!VAR_0->streams.exception) {
			break;
		}

		VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)VAR_0->streams.exception, sizeof (*VAR_0->streams.exception));
		if (VAR_14 != sizeof (*VAR_0->streams.exception)) {
			break;
		}

		sdb_set (VAR_0->kv, ""mdmp_exception.format"", ""[4]E[4]Eqqdd[15]q ""
							   ""(mdmp_exception_code)ExceptionCode ""
							   ""(mdmp_exception_flags)ExceptionFlags ""
							   ""ExceptionRecord ExceptionAddress ""
							   ""NumberParameters __UnusedAlignment ""
							   ""ExceptionInformation"",
			0);
		sdb_num_set (VAR_0->kv, ""mdmp_exception_stream.offset"",
			VAR_1->location.rva, 0);
		sdb_set (VAR_0->kv, ""mdmp_exception_stream.format"", ""dd?? ""
								  ""ThreadId __Alignment ""
								  ""(mdmp_exception)ExceptionRecord ""
								  ""(mdmp_location_descriptor)ThreadContext"",
			0);

		break;
	case VAR_22:
		VAR_0->streams.system_info = R_NEW (struct VAR_23);
		if (!VAR_0->streams.system_info) {
			break;
		}
		VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)VAR_0->streams.system_info, sizeof (*VAR_0->streams.system_info));
		if (VAR_14 != sizeof (*VAR_0->streams.system_info)) {
			break;
		}

		sdb_num_set (VAR_0->kv, ""mdmp_system_info.offset"",
			VAR_1->location.rva, 0);
		/* COMMENT_3 */
		sdb_set (VAR_0->kv, ""mdmp_system_info.format"", ""[2]EwwbBddd[4]Ed[2]Ew[2]q ""
			""(mdmp_processor_architecture)ProcessorArchitecture ""
			""ProcessorLevel ProcessorRevision NumberOfProcessors ""
			""(mdmp_product_type)ProductType ""
			""MajorVersion MinorVersion BuildNumber (mdmp_platform_id)PlatformId ""
			""CsdVersionRva (mdmp_suite_mask)SuiteMask Reserved2 ProcessorFeatures"", 0);

		break;
	case VAR_24:
		/* COMMENT_2 */
		VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_8, sizeof (VAR_8));
		if (VAR_14 != sizeof (VAR_8)) {
			break;
		}

		sdb_set (VAR_0->kv, ""mdmp_thread_ex.format"", ""ddddq??? ""
			""ThreadId SuspendCount PriorityClass Priority ""
			""Teb (mdmp_memory_descriptor)Stack ""
			""(mdmp_location_descriptor)ThreadContext ""
			""(mdmp_memory_descriptor)BackingStore"", 0);
		sdb_num_set (VAR_0->kv, ""mdmp_thread_ex_list.offset"",
			VAR_1->location.rva, 0);
		sdb_set (VAR_0->kv, ""mdmp_thread_ex_list.format"",
			r_strf (""d[%d]? NumberOfThreads ""
				""(mdmp_thread_ex)Threads"",
				VAR_8.number_of_threads),
			0);

		VAR_12 = VAR_1->location.rva + sizeof (VAR_8);
		for (VAR_13 = 0; VAR_13 < VAR_8.number_of_threads && VAR_12 < VAR_0->size; VAR_13++) {
			struct minidump_thread_ex *VAR_25 = R_NEW (struct minidump_thread_ex);
			if (!VAR_25) {
				break;
			}
			VAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_25, sizeof (*VAR_25));
			if (VAR_14 != sizeof (*VAR_25)) {
				break;
			}
			r_list_append (VAR_0->streams.ex_threads, VAR_25);
			VAR_12 += sizeof (*VAR_25);
		}
		break;
	case VAR_26:
		read_memory64_list (VAR_0->b, VAR_1->location.rva, &VAR_4);

		sdb_num_set (VAR_0->kv, ""mdmp_memory64_list.offset"",
			VAR_1->location.rva, 0);
		sdb_set (VAR_0->kv, ""mdmp_memory64_list.format"",
			r_strf (""qq[%""VAR_27""]? NumberOfMemoryRanges ""
				""BaseRva ""
				""(mdmp_memory_descriptor64)MemoryRanges"",
				VAR_4.number_of_memory_ranges),
			0);

		VAR_0->streams.memories64.base_rva = VAR_4.base_rva;
		VAR_12 = VAR_1->location.rva + sizeof (VAR_4);
		for (VAR_13 = 0; VAR_13 < VAR_4.number_of_memory_ranges && VAR_12 < VAR_0->size; VAR_13++) {
			struct minidump_memory_descriptor64 *VAR_19 = R_NEW (struct minidump_memory_descriptor64);
			if (!VAR_19) {
				break;
			}
			read_desc (VAR_0->b, VAR_12, VAR_19);
			r_list_append (VAR_0->streams.memories64.memories, VAR_19);
			VAR_12 += sizeof (*VAR_19);
		}
		break;
	case VAR_28:
		/* COMMENT_2 */
		VAR_0->streams.comments_a = R_NEWS (ut8, VAR_29);
		if (!VAR_0->streams.comments_a) {
			break;
		}
		VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, VAR_0->streams.comments_a, VAR_29);
		if (VAR_14 != VAR_29) {
			break;
		}

		sdb_num_set (VAR_0->kv, ""mdmp_comment_stream_a.offset"",
			VAR_1->location.rva, 0);
		sdb_set (VAR_0->kv, ""mdmp_comment_stream_a.format"",
			""s CommentA"", 0);

		break;
	case VAR_30:
		/* COMMENT_2 */
		VAR_0->streams.comments_w = R_NEWS (ut8, VAR_29);
		if (!VAR_0->streams.comments_w) {
			break;
		}
		VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, VAR_0->streams.comments_w, VAR_29);
		if (VAR_14 != VAR_29) {
			break;
		}

		sdb_num_set (VAR_0->kv, ""mdmp_comment_stream_w.offset"",
			VAR_1->location.rva, 0);
		sdb_set (VAR_0->kv, ""mdmp_comment_stream_w.format"",
				""s CommentW"", 0);

		break;
	case VAR_31:
		/* COMMENT_2 */
		VAR_0->streams.handle_data = R_NEW (struct VAR_32);
		if (!VAR_0->streams.handle_data) {
			break;
		}
		VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)VAR_0->streams.handle_data, sizeof (*VAR_0->streams.handle_data));
		if (VAR_14 != sizeof (*VAR_0->streams.handle_data)) {
			break;
		}

		sdb_num_set (VAR_0->kv, ""mdmp_handle_data_stream.offset"",
				VAR_1->location.rva, 0);
		sdb_set (VAR_0->kv, ""mdmp_handle_data_stream.format"", ""dddd ""
				""SizeOfHeader SizeOfDescriptor ""
				""NumberOfDescriptors Reserved"", 0);
		break;
	case VAR_33:
		/* COMMENT_2 */
		VAR_0->streams.function_table = R_NEW (struct VAR_34);
		if (!VAR_0->streams.function_table) {
			break;
		}
		VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)VAR_0->streams.function_table, sizeof (*VAR_0->streams.function_table));
		if (VAR_14 != sizeof (*VAR_0->streams.function_table)) {
			break;
		}

		sdb_num_set (VAR_0->kv, ""mdmp_function_table_stream.offset"",
			VAR_1->location.rva, 0);
		sdb_set (VAR_0->kv, ""mdmp_function_table_stream.format"", ""dddddd ""
			""SizeOfHeader SizeOfDescriptor SizeOfNativeDescriptor ""
			""SizeOfFunctionEntry NumberOfDescriptors SizeOfAlignPad"",
			0);
		break;
	case VAR_35:
		/* COMMENT_2 */
		VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_11, sizeof (VAR_11));
		if (VAR_14 != sizeof (VAR_11)) {
			break;
		}

		sdb_set (VAR_0->kv, ""mdmp_unloaded_module.format"", ""qddtd ""
			""BaseOfImage SizeOfImage CheckSum TimeDateStamp ""
			""ModuleNameRva"", 0);
		sdb_num_set (VAR_0->kv, ""mdmp_unloaded_module_list.offset"",
			VAR_1->location.rva, 0);
		sdb_set (VAR_0->kv, ""mdmp_unloaded_module_list.format"", ""ddd ""
			""SizeOfHeader SizeOfEntry NumberOfEntries"", 0);

		VAR_12 = VAR_1->location.rva + sizeof (VAR_11);
		for (VAR_13 = 0; VAR_13 < VAR_11.number_of_entries && VAR_12 < VAR_0->size; VAR_13++) {
			struct minidump_unloaded_module *VAR_17 = R_NEW (struct minidump_unloaded_module);
			if (!VAR_17) {
				break;
			}
			VAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_17, sizeof (*VAR_17));
			if (VAR_14 != sizeof (*VAR_17)) {
				break;
			}
			r_list_append (VAR_0->streams.unloaded_modules, VAR_17);
			VAR_12 += sizeof (*VAR_17);
		}
		break;
	case VAR_36:
		/* COMMENT_2 */
		VAR_0->streams.misc_info.misc_info_1 = R_NEW (struct VAR_37);
		if (!VAR_0->streams.misc_info.misc_info_1) {
			break;
		}
		VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)VAR_0->streams.misc_info.misc_info_1, sizeof (*VAR_0->streams.misc_info.misc_info_1));
		if (VAR_14 != sizeof (*VAR_0->streams.misc_info.misc_info_1)) {
			break;
		}

		/* COMMENT_4 */
		sdb_num_set (VAR_0->kv, ""mdmp_misc_info.offset"",
			VAR_1->location.rva, 0);
		sdb_set (VAR_0->kv, ""mdmp_misc_info.format"", ""d[4]Bdtttddddd ""
			""SizeOfInfo (mdmp_misc1_flags)Flags1 ProcessId ""
			""ProcessCreateTime ProcessUserTime ProcessKernelTime ""
			""ProcessorMaxMhz ProcessorCurrentMhz ""
			""ProcessorMhzLimit ProcessorMaxIdleState ""
			""ProcessorCurrentIdleState"", 0);

		break;
	case VAR_38:
		VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_5, sizeof (VAR_5));
		if (VAR_14 != sizeof (VAR_5)) {
			break;
		}

		sdb_set (VAR_0->kv, ""mdmp_memory_info.format"",
			""qq[4]Edq[4]E[4]E[4]Ed BaseAddress AllocationBase ""
			""(mdmp_page_protect)AllocationProtect __Alignment1 RegionSize ""
			""(mdmp_mem_state)State (mdmp_page_protect)Protect ""
			""(mdmp_mem_type)Type __Alignment2"", 0);
		sdb_num_set (VAR_0->kv, ""mdmp_memory_info_list.offset"",
			VAR_1->location.rva, 0);
		sdb_set (VAR_0->kv, ""mdmp_memory_info_list.format"",
			r_strf (""ddq[%""VAR_27""]? SizeOfHeader SizeOfEntry ""
				""NumberOfEntries (mdmp_memory_info)MemoryInfo"",
				VAR_5.number_of_entries),
			0);

		VAR_12 = VAR_1->location.rva + sizeof (VAR_5);
		for (VAR_13 = 0; VAR_13 < VAR_5.number_of_entries && VAR_12 < VAR_0->size; VAR_13++) {
			struct minidump_memory_info *VAR_39 = R_NEW (struct minidump_memory_info);
			if (!VAR_39) {
				break;
			}
			VAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_39, sizeof (*VAR_39));
			if (VAR_14 != sizeof (*VAR_39)) {
				break;
			}
			r_list_append (VAR_0->streams.memory_infos, VAR_39);
			VAR_12 += sizeof (*VAR_39);
		}
		break;
	case VAR_40:
		/* COMMENT_2 */
		VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_9, sizeof (VAR_9));
		if (VAR_14 != sizeof (VAR_9)) {
			break;
		}

		sdb_set (VAR_0->kv, ""mdmp_thread_info.format"", ""ddddttttqq ""
			""ThreadId DumpFlags DumpError ExitStatus CreateTime ""
			""ExitTime KernelTime UserTime StartAddress Affinity"",
			0);
		sdb_num_set (VAR_0->kv, ""mdmp_thread_info_list.offset"",
				VAR_1->location.rva, 0);
		sdb_set (VAR_0->kv, ""mdmp_thread_info_list.format"", ""ddd ""
			""SizeOfHeader SizeOfEntry NumberOfEntries"", 0);

		VAR_12 = VAR_1->location.rva + sizeof (VAR_9);
		for (VAR_13 = 0; VAR_13 < VAR_9.number_of_entries && VAR_12 < VAR_0->size; VAR_13++) {
			struct minidump_thread_info *VAR_39 = R_NEW (struct minidump_thread_info);
			if (!VAR_39) {
				break;
			}
			VAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_39, sizeof (*VAR_39));
			if (VAR_14 != sizeof (*VAR_39)) {
				break;
			}
			r_list_append (VAR_0->streams.thread_infos, VAR_39);
			VAR_12 += sizeof (*VAR_39);
		}
		break;
	case VAR_41:
		/* COMMENT_2 */
		VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_2, sizeof (VAR_2));
		if (VAR_14 != sizeof (VAR_2)) {
			break;
		}

		sdb_num_set (VAR_0->kv, ""mdmp_handle_operation_list.offset"",
			VAR_1->location.rva, 0);
		sdb_set (VAR_0->kv, ""mdmp_handle_operation_list.format"", ""dddd ""
			""SizeOfHeader SizeOfEntry NumberOfEntries Reserved"", 0);

		VAR_12 = VAR_1->location.rva + sizeof (VAR_2);
		for (VAR_13 = 0; VAR_13 < VAR_2.number_of_entries && VAR_12 < VAR_0->size; VAR_13++) {
			struct avrf_handle_operation *VAR_42 = R_NEW (struct avrf_handle_operation);
			if (!VAR_42) {
				break;
			}
			VAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_42, sizeof (*VAR_42));
			if (VAR_14 != sizeof (*VAR_42)) {
				break;
			}
			r_list_append (VAR_0->streams.operations, VAR_42);
			VAR_12 += sizeof (*VAR_42);
		}

		break;
	case VAR_43:
		/* COMMENT_5 */
		VAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_10, sizeof (VAR_10));
		if (VAR_14 != sizeof (VAR_10)) {
			break;
		}

		sdb_set (VAR_0->kv, ""mdmp_token_info.format"", ""ddq ""
			""TokenSize TokenId TokenHandle"", 0);

		sdb_num_set (VAR_0->kv, ""mdmp_token_info_list.offset"",
			VAR_1->location.rva, 0);
		sdb_set (VAR_0->kv, ""mdmp_token_info_list.format"", ""dddd ""
			""TokenListSize TokenListEntries ListHeaderSize ElementHeaderSize"", 0);

		VAR_12 = VAR_1->location.rva + sizeof (VAR_10);
		for (VAR_13 = 0; VAR_13 < VAR_10.number_of_entries && VAR_12 < VAR_0->size; VAR_13++) {
			struct minidump_token_info *VAR_39 = R_NEW (struct minidump_token_info);
			if (!VAR_39) {
				break;
			}
			VAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_39, sizeof (*VAR_39));
			if (VAR_14 != sizeof (*VAR_39)) {
				break;
			}
			r_list_append (VAR_0->streams.token_infos, VAR_39);
			VAR_12 += sizeof (*VAR_39);
		}
		break;

	case VAR_44:
		/* COMMENT_2 */
		break;
	case VAR_45:
	case VAR_46:
	case VAR_47:
		/* COMMENT_6 */
		break;
	default:
		eprintf (""[WARN] Invalid or unsupported enumeration encountered %d\n"", VAR_1->stream_type);
		break;
	}
	return true;
}",radareorg/radare2/27fe8031782d3a06c3998eaa94354867864f9f1b/mdmp.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -60,12 +60,11 @@
 			0);
 
 		offset = entry->location.rva + sizeof (module_list);
-		for (i = 0; i < module_list.number_of_modules; i++) {
-			struct minidump_module *module = R_NEW (struct minidump_module);
+		for (i = 0; i < module_list.number_of_modules && offset < obj->size; i++) {
+			struct minidump_module *module = read_module (obj->b, offset);
 			if (!module) {
-				break;
-			}
-			read_module (obj->b, offset, module);
+				break;	
+			}
 			r_list_append (obj->streams.modules, module);
 			offset += sizeof (*module);
 		}
@@ -86,7 +85,7 @@
 			0);
 
 		offset = entry->location.rva + sizeof (memory_list);
-		for (i = 0; i < memory_list.number_of_memory_ranges; i++) {
+		for (i = 0; i < memory_list.number_of_memory_ranges && offset < obj->size; i++) {
 			struct minidump_memory_descriptor *desc = R_NEW (struct minidump_memory_descriptor);
 			if (!desc) {
 				break;
@@ -169,7 +168,7 @@
 			0);
 
 		offset = entry->location.rva + sizeof (thread_ex_list);
-		for (i = 0; i < thread_ex_list.number_of_threads; i++) {
+		for (i = 0; i < thread_ex_list.number_of_threads && offset < obj->size; i++) {
 			struct minidump_thread_ex *thread = R_NEW (struct minidump_thread_ex);
 			if (!thread) {
 				break;
@@ -196,7 +195,7 @@
 
 		obj->streams.memories64.base_rva = memory64_list.base_rva;
 		offset = entry->location.rva + sizeof (memory64_list);
-		for (i = 0; i < memory64_list.number_of_memory_ranges; i++) {
+		for (i = 0; i < memory64_list.number_of_memory_ranges && offset < obj->size; i++) {
 			struct minidump_memory_descriptor64 *desc = R_NEW (struct minidump_memory_descriptor64);
 			if (!desc) {
 				break;
@@ -291,7 +290,7 @@
 			""SizeOfHeader SizeOfEntry NumberOfEntries"", 0);
 
 		offset = entry->location.rva + sizeof (unloaded_module_list);
-		for (i = 0; i < unloaded_module_list.number_of_entries; i++) {
+		for (i = 0; i < unloaded_module_list.number_of_entries && offset < obj->size; i++) {
 			struct minidump_unloaded_module *module = R_NEW (struct minidump_unloaded_module);
 			if (!module) {
 				break;
@@ -346,7 +345,7 @@
 			0);
 
 		offset = entry->location.rva + sizeof (memory_info_list);
-		for (i = 0; i < memory_info_list.number_of_entries; i++) {
+		for (i = 0; i < memory_info_list.number_of_entries && offset < obj->size; i++) {
 			struct minidump_memory_info *info = R_NEW (struct minidump_memory_info);
 			if (!info) {
 				break;
@@ -376,7 +375,7 @@
 			""SizeOfHeader SizeOfEntry NumberOfEntries"", 0);
 
 		offset = entry->location.rva + sizeof (thread_info_list);
-		for (i = 0; i < thread_info_list.number_of_entries; i++) {
+		for (i = 0; i < thread_info_list.number_of_entries && offset < obj->size; i++) {
 			struct minidump_thread_info *info = R_NEW (struct minidump_thread_info);
 			if (!info) {
 				break;
@@ -402,7 +401,7 @@
 			""SizeOfHeader SizeOfEntry NumberOfEntries Reserved"", 0);
 
 		offset = entry->location.rva + sizeof (handle_operation_list);
-		for (i = 0; i < handle_operation_list.number_of_entries; i++) {
+		for (i = 0; i < handle_operation_list.number_of_entries && offset < obj->size; i++) {
 			struct avrf_handle_operation *op = R_NEW (struct avrf_handle_operation);
 			if (!op) {
 				break;
@@ -432,7 +431,7 @@
 			""TokenListSize TokenListEntries ListHeaderSize ElementHeaderSize"", 0);
 
 		offset = entry->location.rva + sizeof (token_info_list);
-		for (i = 0; i < token_info_list.number_of_entries; i++) {
+		for (i = 0; i < token_info_list.number_of_entries && offset < obj->size; i++) {
 			struct minidump_token_info *info = R_NEW (struct minidump_token_info);
 			if (!info) {
 				break;","{'deleted_lines': ['\t\tfor (i = 0; i < module_list.number_of_modules; i++) {', '\t\t\tstruct minidump_module *module = R_NEW (struct minidump_module);', '\t\t\t\tbreak;', '\t\t\t}', '\t\t\tread_module (obj->b, offset, module);', '\t\tfor (i = 0; i < memory_list.number_of_memory_ranges; i++) {', '\t\tfor (i = 0; i < thread_ex_list.number_of_threads; i++) {', '\t\tfor (i = 0; i < memory64_list.number_of_memory_ranges; i++) {', '\t\tfor (i = 0; i < unloaded_module_list.number_of_entries; i++) {', '\t\tfor (i = 0; i < memory_info_list.number_of_entries; i++) {', '\t\tfor (i = 0; i < thread_info_list.number_of_entries; i++) {', '\t\tfor (i = 0; i < handle_operation_list.number_of_entries; i++) {', '\t\tfor (i = 0; i < token_info_list.number_of_entries; i++) {'], 'added_lines': ['\t\tfor (i = 0; i < module_list.number_of_modules && offset < obj->size; i++) {', '\t\t\tstruct minidump_module *module = read_module (obj->b, offset);', '\t\t\t\tbreak;\t', '\t\t\t}', '\t\tfor (i = 0; i < memory_list.number_of_memory_ranges && offset < obj->size; i++) {', '\t\tfor (i = 0; i < thread_ex_list.number_of_threads && offset < obj->size; i++) {', '\t\tfor (i = 0; i < memory64_list.number_of_memory_ranges && offset < obj->size; i++) {', '\t\tfor (i = 0; i < unloaded_module_list.number_of_entries && offset < obj->size; i++) {', '\t\tfor (i = 0; i < memory_info_list.number_of_entries && offset < obj->size; i++) {', '\t\tfor (i = 0; i < thread_info_list.number_of_entries && offset < obj->size; i++) {', '\t\tfor (i = 0; i < handle_operation_list.number_of_entries && offset < obj->size; i++) {', '\t\tfor (i = 0; i < token_info_list.number_of_entries && offset < obj->size; i++) {']}",True,Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4.,5.5,MEDIUM,1,test,2022-02-21T17:01:56Z,4
CVE-2022-0476,['CWE-400'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,radareorg/radare2,"Fix DoS in the minidump parser ##crash

* Reported by lazymio via huntr.dev
* Reproducer: mdmp-dos",27fe8031782d3a06c3998eaa94354867864f9f1b,https://github.com/radareorg/radare2/commit/27fe8031782d3a06c3998eaa94354867864f9f1b,libr/bin/format/mdmp/mdmp.c,read_module,"static void read_module(RBuffer *b, ut64 addr, struct minidump_module *module) {
st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
r_buf_seek (b, addr, R_BUF_SET);
module->base_of_image = r_buf_read_le64 (b);
module->size_of_image = r_buf_read_le32 (b);
module->check_sum = r_buf_read_le32 (b);
module->time_date_stamp = r_buf_read_le32 (b);
module->module_name_rva = r_buf_read_le32 (b);
module->version_info.dw_signature = r_buf_read_le32 (b);
module->version_info.dw_struc_version = r_buf_read_le32 (b);
module->version_info.dw_file_version_ms = r_buf_read_le32 (b);
module->version_info.dw_file_version_ls = r_buf_read_le32 (b);
module->version_info.dw_product_version_ms = r_buf_read_le32 (b);
module->version_info.dw_product_version_ls = r_buf_read_le32 (b);
module->version_info.dw_file_flags_mask = r_buf_read_le32 (b);
module->version_info.dw_file_flags = r_buf_read_le32 (b);
module->version_info.dw_file_os = r_buf_read_le32 (b);
module->version_info.dw_file_type = r_buf_read_le32 (b);
module->version_info.dw_file_subtype = r_buf_read_le32 (b);
module->version_info.dw_file_date_ms = r_buf_read_le32 (b);
module->version_info.dw_file_date_ls = r_buf_read_le32 (b);
module->cv_record.data_size = r_buf_read_le32 (b);
module->cv_record.rva = r_buf_read_le32 (b);
module->misc_record.data_size = r_buf_read_le32 (b);
module->misc_record.rva = r_buf_read_le32 (b);
module->reserved_0 = r_buf_read_le64 (b);
module->reserved_1 = r_buf_read_le64 (b);
r_buf_seek (b, o_addr, R_BUF_SET);
}","static void read_module(RBuffer *VAR_0, ut64 VAR_1, struct minidump_module *VAR_2) {
st64 VAR_3 = r_buf_seek (VAR_0, 0, VAR_4);
r_buf_seek (VAR_0, VAR_1, VAR_5);
VAR_2->base_of_image = r_buf_read_le64 (VAR_0);
VAR_2->size_of_image = r_buf_read_le32 (VAR_0);
VAR_2->check_sum = r_buf_read_le32 (VAR_0);
VAR_2->time_date_stamp = r_buf_read_le32 (VAR_0);
VAR_2->module_name_rva = r_buf_read_le32 (VAR_0);
VAR_2->version_info.dw_signature = r_buf_read_le32 (VAR_0);
VAR_2->version_info.dw_struc_version = r_buf_read_le32 (VAR_0);
VAR_2->version_info.dw_file_version_ms = r_buf_read_le32 (VAR_0);
VAR_2->version_info.dw_file_version_ls = r_buf_read_le32 (VAR_0);
VAR_2->version_info.dw_product_version_ms = r_buf_read_le32 (VAR_0);
VAR_2->version_info.dw_product_version_ls = r_buf_read_le32 (VAR_0);
VAR_2->version_info.dw_file_flags_mask = r_buf_read_le32 (VAR_0);
VAR_2->version_info.dw_file_flags = r_buf_read_le32 (VAR_0);
VAR_2->version_info.dw_file_os = r_buf_read_le32 (VAR_0);
VAR_2->version_info.dw_file_type = r_buf_read_le32 (VAR_0);
VAR_2->version_info.dw_file_subtype = r_buf_read_le32 (VAR_0);
VAR_2->version_info.dw_file_date_ms = r_buf_read_le32 (VAR_0);
VAR_2->version_info.dw_file_date_ls = r_buf_read_le32 (VAR_0);
VAR_2->cv_record.data_size = r_buf_read_le32 (VAR_0);
VAR_2->cv_record.rva = r_buf_read_le32 (VAR_0);
VAR_2->misc_record.data_size = r_buf_read_le32 (VAR_0);
VAR_2->misc_record.rva = r_buf_read_le32 (VAR_0);
VAR_2->reserved_0 = r_buf_read_le64 (VAR_0);
VAR_2->reserved_1 = r_buf_read_le64 (VAR_0);
r_buf_seek (VAR_0, VAR_3, VAR_5);
}",radareorg/radare2/27fe8031782d3a06c3998eaa94354867864f9f1b/mdmp.c/vul/before/0.json,"static struct minidump_module *read_module(RBuffer *b, ut64 addr) {
	st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
	if (r_buf_seek (b, addr, R_BUF_SET) == -1) {
		return NULL;
	}
	struct minidump_module *module = R_NEW0 (struct minidump_module);
	if (!module) {
		return NULL;
	}
	module->base_of_image = r_buf_read_le64 (b);
	module->size_of_image = r_buf_read_le32 (b);
	module->check_sum = r_buf_read_le32 (b);
	module->time_date_stamp = r_buf_read_le32 (b);
	module->module_name_rva = r_buf_read_le32 (b);
	module->version_info.dw_signature = r_buf_read_le32 (b);
	module->version_info.dw_struc_version = r_buf_read_le32 (b);
	module->version_info.dw_file_version_ms = r_buf_read_le32 (b);
	module->version_info.dw_file_version_ls = r_buf_read_le32 (b);
	module->version_info.dw_product_version_ms = r_buf_read_le32 (b);
	module->version_info.dw_product_version_ls = r_buf_read_le32 (b);
	module->version_info.dw_file_flags_mask = r_buf_read_le32 (b);
	module->version_info.dw_file_flags = r_buf_read_le32 (b);
	module->version_info.dw_file_os = r_buf_read_le32 (b);
	module->version_info.dw_file_type = r_buf_read_le32 (b);
	module->version_info.dw_file_subtype = r_buf_read_le32 (b);
	module->version_info.dw_file_date_ms = r_buf_read_le32 (b);
	module->version_info.dw_file_date_ls = r_buf_read_le32 (b);
	module->cv_record.data_size = r_buf_read_le32 (b);
	module->cv_record.rva = r_buf_read_le32 (b);
	module->misc_record.data_size = r_buf_read_le32 (b);
	module->misc_record.rva = r_buf_read_le32 (b);
	module->reserved_0 = r_buf_read_le64 (b);
	module->reserved_1 = r_buf_read_le64 (b);
	r_buf_seek (b, o_addr, R_BUF_SET);
	return module;
}","static struct minidump_module *read_module(RBuffer *VAR_0, ut64 VAR_1) {
	st64 VAR_2 = r_buf_seek (VAR_0, 0, VAR_3);
	if (r_buf_seek (VAR_0, VAR_1, VAR_4) == -1) {
		return NULL;
	}
	struct minidump_module *VAR_5 = R_NEW0 (struct minidump_module);
	if (!VAR_5) {
		return NULL;
	}
	VAR_5->base_of_image = r_buf_read_le64 (VAR_0);
	VAR_5->size_of_image = r_buf_read_le32 (VAR_0);
	VAR_5->check_sum = r_buf_read_le32 (VAR_0);
	VAR_5->time_date_stamp = r_buf_read_le32 (VAR_0);
	VAR_5->module_name_rva = r_buf_read_le32 (VAR_0);
	VAR_5->version_info.dw_signature = r_buf_read_le32 (VAR_0);
	VAR_5->version_info.dw_struc_version = r_buf_read_le32 (VAR_0);
	VAR_5->version_info.dw_file_version_ms = r_buf_read_le32 (VAR_0);
	VAR_5->version_info.dw_file_version_ls = r_buf_read_le32 (VAR_0);
	VAR_5->version_info.dw_product_version_ms = r_buf_read_le32 (VAR_0);
	VAR_5->version_info.dw_product_version_ls = r_buf_read_le32 (VAR_0);
	VAR_5->version_info.dw_file_flags_mask = r_buf_read_le32 (VAR_0);
	VAR_5->version_info.dw_file_flags = r_buf_read_le32 (VAR_0);
	VAR_5->version_info.dw_file_os = r_buf_read_le32 (VAR_0);
	VAR_5->version_info.dw_file_type = r_buf_read_le32 (VAR_0);
	VAR_5->version_info.dw_file_subtype = r_buf_read_le32 (VAR_0);
	VAR_5->version_info.dw_file_date_ms = r_buf_read_le32 (VAR_0);
	VAR_5->version_info.dw_file_date_ls = r_buf_read_le32 (VAR_0);
	VAR_5->cv_record.data_size = r_buf_read_le32 (VAR_0);
	VAR_5->cv_record.rva = r_buf_read_le32 (VAR_0);
	VAR_5->misc_record.data_size = r_buf_read_le32 (VAR_0);
	VAR_5->misc_record.rva = r_buf_read_le32 (VAR_0);
	VAR_5->reserved_0 = r_buf_read_le64 (VAR_0);
	VAR_5->reserved_1 = r_buf_read_le64 (VAR_0);
	r_buf_seek (VAR_0, VAR_2, VAR_4);
	return VAR_5;
}",radareorg/radare2/27fe8031782d3a06c3998eaa94354867864f9f1b/mdmp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,12 @@
-static void read_module(RBuffer *b, ut64 addr, struct minidump_module *module) {
+static struct minidump_module *read_module(RBuffer *b, ut64 addr) {
 	st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
-	r_buf_seek (b, addr, R_BUF_SET);
+	if (r_buf_seek (b, addr, R_BUF_SET) == -1) {
+		return NULL;
+	}
+	struct minidump_module *module = R_NEW0 (struct minidump_module);
+	if (!module) {
+		return NULL;
+	}
 	module->base_of_image = r_buf_read_le64 (b);
 	module->size_of_image = r_buf_read_le32 (b);
 	module->check_sum = r_buf_read_le32 (b);
@@ -26,4 +32,5 @@
 	module->reserved_0 = r_buf_read_le64 (b);
 	module->reserved_1 = r_buf_read_le64 (b);
 	r_buf_seek (b, o_addr, R_BUF_SET);
+	return module;
 }","{'deleted_lines': ['static void read_module(RBuffer *b, ut64 addr, struct minidump_module *module) {', '\tr_buf_seek (b, addr, R_BUF_SET);'], 'added_lines': ['static struct minidump_module *read_module(RBuffer *b, ut64 addr) {', '\tif (r_buf_seek (b, addr, R_BUF_SET) == -1) {', '\t\treturn NULL;', '\t}', '\tstruct minidump_module *module = R_NEW0 (struct minidump_module);', '\tif (!module) {', '\t\treturn NULL;', '\t}', '\treturn module;']}",True,Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4.,5.5,MEDIUM,1,test,2022-02-21T17:01:56Z,4
CVE-2022-0713,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0,radareorg/radare2,"Fix oobread in macho core symbolication ##crash

* Reported by @cnitlrt via huntr.dev",a35f89f86ed12161af09330e92e5a213014e46a1,https://github.com/radareorg/radare2/commit/a35f89f86ed12161af09330e92e5a213014e46a1,libr/bin/format/mach0/coresymbolication.c,r_coresym_cache_element_new,"RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut64 off, int bits, char * file_name) {
RCoreSymCacheElement *result = NULL;
ut8 *b = NULL;
RCoreSymCacheElementHdr *hdr = r_coresym_cache_element_header_new (buf, off, bits);
if (!hdr) {
return NULL;
}
if (hdr->version != 1) {
eprintf (""Unsupported CoreSymbolication cache version (%d)\n"", hdr->version);
goto beach;
}
if (hdr->size == 0 || hdr->size > r_buf_size (buf) - off) {
eprintf (""Corrupted CoreSymbolication header: size out of bounds (0x%x)\n"", hdr->size);
goto beach;
}
result = R_NEW0 (RCoreSymCacheElement);
if (!result) {
goto beach;
}
result->hdr = hdr;
b = malloc (hdr->size);
if (!b) {
goto beach;
}
if (r_buf_read_at (buf, off, b, hdr->size) != hdr->size) {
goto beach;
}
ut8 *end = b + hdr->size;
if (file_name) {
result->file_name = file_name;
} else if (hdr->file_name_off) {
result->file_name = str_dup_safe (b, b + (size_t)hdr->file_name_off, end);
}
if (hdr->version_off) {
result->binary_version = str_dup_safe (b, b + (size_t)hdr->version_off, end);
}
const size_t word_size = bits / 8;
const ut64 start_of_sections = (ut64)hdr->n_segments * R_CS_EL_SIZE_SEG + R_CS_EL_OFF_SEGS;
const ut64 sect_size = (bits == 32) ? R_CS_EL_SIZE_SECT_32 : R_CS_EL_SIZE_SECT_64;
const ut64 start_of_symbols = start_of_sections + (ut64)hdr->n_sections * sect_size;
const ut64 start_of_lined_symbols = start_of_symbols + (ut64)hdr->n_symbols * R_CS_EL_SIZE_SYM;
const ut64 start_of_line_info = start_of_lined_symbols + (ut64)hdr->n_lined_symbols * R_CS_EL_SIZE_LSYM;
const ut64 start_of_unknown_pairs = start_of_line_info + (ut64)hdr->n_line_info * R_CS_EL_SIZE_LINFO;
const ut64 start_of_strings = start_of_unknown_pairs + (ut64)hdr->n_symbols * 8;
ut64 page_zero_size = 0;
size_t page_zero_idx = 0;
if (UT32_MUL_OVFCHK (hdr->n_segments, sizeof (RCoreSymCacheElementSegment))) {
goto beach;
} else if (UT32_MUL_OVFCHK (hdr->n_sections, sizeof (RCoreSymCacheElementSection))) {
goto beach;
} else if (UT32_MUL_OVFCHK (hdr->n_symbols, sizeof (RCoreSymCacheElementSymbol))) {
goto beach;
} else if (UT32_MUL_OVFCHK (hdr->n_lined_symbols, sizeof (RCoreSymCacheElementLinedSymbol))) {
goto beach;
} else if (UT32_MUL_OVFCHK (hdr->n_line_info, sizeof (RCoreSymCacheElementLineInfo))) {
goto beach;
}
if (hdr->n_segments > 0) {
result->segments = R_NEWS0 (RCoreSymCacheElementSegment, hdr->n_segments);
if (!result->segments) {
goto beach;
}
size_t i;
ut8 *cursor = b + R_CS_EL_OFF_SEGS;
for (i = 0; i < hdr->n_segments && cursor < end; i++) {
RCoreSymCacheElementSegment *seg = &result->segments[i];
seg->paddr = seg->vaddr = r_read_le64 (cursor);
cursor += 8;
if (cursor >= end) {
break;
}
seg->size = seg->vsize = r_read_le64 (cursor);
cursor += 8;
if (cursor >= end) {
break;
}
seg->name = str_dup_safe_fixed (b, cursor, 16, end);
cursor += 16;
if (!seg->name) {
continue;
}
if (!strcmp (seg->name, ""__PAGEZERO"")) {
page_zero_size = seg->size;
page_zero_idx = i;
seg->paddr = seg->vaddr = 0;
seg->size = 0;
}
}
for (i = 0; i < hdr->n_segments && page_zero_size > 0; i++) {
if (i == page_zero_idx) {
continue;
}
RCoreSymCacheElementSegment *seg = &result->segments[i];
if (seg->vaddr < page_zero_size) {
seg->vaddr += page_zero_size;
}
}
}
bool relative_to_strings = false;
ut8* string_origin;
if (hdr->n_sections > 0) {
result->sections = R_NEWS0 (RCoreSymCacheElementSection, hdr->n_sections);
if (!result->sections) {
goto beach;
}
size_t i;
ut8 *cursor = b + start_of_sections;
for (i = 0; i < hdr->n_sections && cursor < end; i++) {
ut8 *sect_start = cursor;
RCoreSymCacheElementSection *sect = &result->sections[i];
sect->vaddr = sect->paddr = r_read_ble (cursor, false, bits);
if (sect->vaddr < page_zero_size) {
sect->vaddr += page_zero_size;
}
cursor += word_size;
if (cursor >= end) {
break;
}
sect->size = r_read_ble (cursor, false, bits);
cursor += word_size;
if (cursor >= end) {
break;
}
ut64 sect_name_off = r_read_ble (cursor, false, bits);
if (!i && !sect_name_off) {
relative_to_strings = true;
}
cursor += word_size;
if (bits == 32) {
cursor += word_size;
}
string_origin = relative_to_strings? b + start_of_strings : sect_start;
sect->name = str_dup_safe (b, string_origin + (size_t)sect_name_off, end);
}
}
if (hdr->n_symbols) {
result->symbols = R_NEWS0 (RCoreSymCacheElementSymbol, hdr->n_symbols);
if (!result->symbols) {
goto beach;
}
size_t i;
ut8 *cursor = b + start_of_symbols;
for (i = 0; i < hdr->n_symbols && cursor + R_CS_EL_SIZE_SYM <= end; i++) {
RCoreSymCacheElementSymbol *sym = &result->symbols[i];
sym->paddr = r_read_le32 (cursor);
sym->size = r_read_le32 (cursor + 0x4);
sym->unk1 = r_read_le32 (cursor + 0x8);
size_t name_off = r_read_le32 (cursor + 0xc);
size_t mangled_name_off = r_read_le32 (cursor + 0x10);
sym->unk2 = (st32)r_read_le32 (cursor + 0x14);
string_origin = relative_to_strings? b + start_of_strings : cursor;
sym->name = str_dup_safe (b, string_origin + name_off, end);
if (!sym->name) {
cursor += R_CS_EL_SIZE_SYM;
continue;
}
string_origin = relative_to_strings? b + start_of_strings : cursor;
sym->mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);
if (!sym->mangled_name) {
cursor += R_CS_EL_SIZE_SYM;
continue;
}
cursor += R_CS_EL_SIZE_SYM;
}
}
if (hdr->n_lined_symbols) {
result->lined_symbols = R_NEWS0 (RCoreSymCacheElementLinedSymbol, hdr->n_lined_symbols);
if (!result->lined_symbols) {
goto beach;
}
size_t i;
ut8 *cursor = b + start_of_lined_symbols;
for (i = 0; i < hdr->n_lined_symbols && cursor + R_CS_EL_SIZE_LSYM <= end; i++) {
RCoreSymCacheElementLinedSymbol *lsym = &result->lined_symbols[i];
lsym->sym.paddr = r_read_le32 (cursor);
lsym->sym.size = r_read_le32 (cursor + 0x4);
lsym->sym.unk1 = r_read_le32 (cursor + 0x8);
size_t name_off = r_read_le32 (cursor + 0xc);
size_t mangled_name_off = r_read_le32 (cursor + 0x10);
lsym->sym.unk2 = (st32)r_read_le32 (cursor + 0x14);
size_t file_name_off = r_read_le32 (cursor + 0x18);
lsym->flc.line = r_read_le32 (cursor + 0x1c);
lsym->flc.col = r_read_le32 (cursor + 0x20);
string_origin = relative_to_strings? b + start_of_strings : cursor;
lsym->sym.name = str_dup_safe (b, string_origin + name_off, end);
if (!lsym->sym.name) {
cursor += R_CS_EL_SIZE_LSYM;
continue;
}
string_origin = relative_to_strings? b + start_of_strings : cursor;
lsym->sym.mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);
if (!lsym->sym.mangled_name) {
cursor += R_CS_EL_SIZE_LSYM;
continue;
}
string_origin = relative_to_strings? b + start_of_strings : cursor;
lsym->flc.file = str_dup_safe (b, string_origin + file_name_off, end);
if (!lsym->flc.file) {
cursor += R_CS_EL_SIZE_LSYM;
continue;
}
cursor += R_CS_EL_SIZE_LSYM;
meta_add_fileline (bf, r_coresym_cache_element_pa2va (result, lsym->sym.paddr), lsym->sym.size, &lsym->flc);
}
}
if (hdr->n_line_info) {
result->line_info = R_NEWS0 (RCoreSymCacheElementLineInfo, hdr->n_line_info);
if (!result->line_info) {
goto beach;
}
size_t i;
ut8 *cursor = b + start_of_line_info;
for (i = 0; i < hdr->n_line_info && cursor + R_CS_EL_SIZE_LINFO <= end; i++) {
RCoreSymCacheElementLineInfo *info = &result->line_info[i];
info->paddr = r_read_le32 (cursor);
info->size = r_read_le32 (cursor + 4);
size_t file_name_off = r_read_le32 (cursor + 8);
info->flc.line = r_read_le32 (cursor + 0xc);
info->flc.col = r_read_le32 (cursor + 0x10);
string_origin = relative_to_strings? b + start_of_strings : cursor;
info->flc.file = str_dup_safe (b, string_origin + file_name_off, end);
if (!info->flc.file) {
break;
}
cursor += R_CS_EL_SIZE_LINFO;
meta_add_fileline (bf, r_coresym_cache_element_pa2va (result, info->paddr), info->size, &info->flc);
}
}
beach:
free (b);
return result;
}","RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *VAR_0, RBuffer *VAR_1, ut64 VAR_2, int VAR_3, char * VAR_4) {
RCoreSymCacheElement *VAR_5 = NULL;
ut8 *VAR_6 = NULL;
RCoreSymCacheElementHdr *VAR_7 = r_coresym_cache_element_header_new (VAR_1, VAR_2, VAR_3);
if (!VAR_7) {
return NULL;
}
if (VAR_7->version != 1) {
eprintf (""Unsupported CoreSymbolication cache version (%d)\n"", VAR_7->version);
goto beach;
}
if (VAR_7->size == 0 || VAR_7->size > r_buf_size (VAR_1) - VAR_2) {
eprintf (""Corrupted CoreSymbolication header: size out of bounds (0x%x)\n"", VAR_7->size);
goto beach;
}
VAR_5 = R_NEW0 (RCoreSymCacheElement);
if (!VAR_5) {
goto beach;
}
VAR_5->hdr = VAR_7;
VAR_6 = malloc (VAR_7->size);
if (!VAR_6) {
goto beach;
}
if (r_buf_read_at (VAR_1, VAR_2, VAR_6, VAR_7->size) != VAR_7->size) {
goto beach;
}
ut8 *VAR_8 = VAR_6 + VAR_7->size;
if (VAR_4) {
VAR_5->file_name = VAR_4;
} else if (VAR_7->file_name_off) {
VAR_5->file_name = str_dup_safe (VAR_6, VAR_6 + (size_t)VAR_7->file_name_off, VAR_8);
}
if (VAR_7->version_off) {
VAR_5->binary_version = str_dup_safe (VAR_6, VAR_6 + (size_t)VAR_7->version_off, VAR_8);
}
const size_t VAR_9 = VAR_3 / 8;
const ut64 VAR_10 = (ut64)VAR_7->n_segments * VAR_11 + VAR_12;
const ut64 VAR_13 = (VAR_3 == 32) ? VAR_14 : VAR_15;
const ut64 VAR_16 = VAR_10 + (ut64)VAR_7->n_sections * VAR_13;
const ut64 VAR_17 = VAR_16 + (ut64)VAR_7->n_symbols * VAR_18;
const ut64 VAR_19 = VAR_17 + (ut64)VAR_7->n_lined_symbols * VAR_20;
const ut64 VAR_21 = VAR_19 + (ut64)VAR_7->n_line_info * VAR_22;
const ut64 VAR_23 = VAR_21 + (ut64)VAR_7->n_symbols * 8;
ut64 VAR_24 = 0;
size_t VAR_25 = 0;
if (UT32_MUL_OVFCHK (VAR_7->n_segments, sizeof (VAR_26))) {
goto beach;
} else if (UT32_MUL_OVFCHK (VAR_7->n_sections, sizeof (VAR_27))) {
goto beach;
} else if (UT32_MUL_OVFCHK (VAR_7->n_symbols, sizeof (VAR_28))) {
goto beach;
} else if (UT32_MUL_OVFCHK (VAR_7->n_lined_symbols, sizeof (VAR_29))) {
goto beach;
} else if (UT32_MUL_OVFCHK (VAR_7->n_line_info, sizeof (VAR_30))) {
goto beach;
}
if (VAR_7->n_segments > 0) {
VAR_5->segments = R_NEWS0 (VAR_26, VAR_7->n_segments);
if (!VAR_5->segments) {
goto beach;
}
size_t VAR_31;
ut8 *VAR_32 = VAR_6 + VAR_12;
for (VAR_31 = 0; VAR_31 < VAR_7->n_segments && VAR_32 < VAR_8; VAR_31++) {
RCoreSymCacheElementSegment *VAR_33 = &VAR_5->segments[VAR_31];
VAR_33->paddr = VAR_33->vaddr = r_read_le64 (VAR_32);
VAR_32 += 8;
if (VAR_32 >= VAR_8) {
break;
}
VAR_33->size = VAR_33->vsize = r_read_le64 (VAR_32);
VAR_32 += 8;
if (VAR_32 >= VAR_8) {
break;
}
VAR_33->name = str_dup_safe_fixed (VAR_6, VAR_32, 16, VAR_8);
VAR_32 += 16;
if (!VAR_33->name) {
continue;
}
if (!strcmp (VAR_33->name, ""__PAGEZERO"")) {
VAR_24 = VAR_33->size;
VAR_25 = VAR_31;
VAR_33->paddr = VAR_33->vaddr = 0;
VAR_33->size = 0;
}
}
for (VAR_31 = 0; VAR_31 < VAR_7->n_segments && VAR_24 > 0; VAR_31++) {
if (VAR_31 == VAR_25) {
continue;
}
RCoreSymCacheElementSegment *VAR_33 = &VAR_5->segments[VAR_31];
if (VAR_33->vaddr < VAR_24) {
VAR_33->vaddr += VAR_24;
}
}
}
bool VAR_34 = false;
ut8* VAR_35;
if (VAR_7->n_sections > 0) {
VAR_5->sections = R_NEWS0 (VAR_27, VAR_7->n_sections);
if (!VAR_5->sections) {
goto beach;
}
size_t VAR_31;
ut8 *VAR_32 = VAR_6 + VAR_10;
for (VAR_31 = 0; VAR_31 < VAR_7->n_sections && VAR_32 < VAR_8; VAR_31++) {
ut8 *VAR_36 = VAR_32;
RCoreSymCacheElementSection *VAR_37 = &VAR_5->sections[VAR_31];
VAR_37->vaddr = VAR_37->paddr = r_read_ble (VAR_32, false, VAR_3);
if (VAR_37->vaddr < VAR_24) {
VAR_37->vaddr += VAR_24;
}
VAR_32 += VAR_9;
if (VAR_32 >= VAR_8) {
break;
}
VAR_37->size = r_read_ble (VAR_32, false, VAR_3);
VAR_32 += VAR_9;
if (VAR_32 >= VAR_8) {
break;
}
ut64 VAR_38 = r_read_ble (VAR_32, false, VAR_3);
if (!VAR_31 && !VAR_38) {
VAR_34 = true;
}
VAR_32 += VAR_9;
if (VAR_3 == 32) {
VAR_32 += VAR_9;
}
VAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_36;
VAR_37->name = str_dup_safe (VAR_6, VAR_35 + (size_t)VAR_38, VAR_8);
}
}
if (VAR_7->n_symbols) {
VAR_5->symbols = R_NEWS0 (VAR_28, VAR_7->n_symbols);
if (!VAR_5->symbols) {
goto beach;
}
size_t VAR_31;
ut8 *VAR_32 = VAR_6 + VAR_16;
for (VAR_31 = 0; VAR_31 < VAR_7->n_symbols && VAR_32 + VAR_18 <= VAR_8; VAR_31++) {
RCoreSymCacheElementSymbol *VAR_39 = &VAR_5->symbols[VAR_31];
VAR_39->paddr = r_read_le32 (VAR_32);
VAR_39->size = r_read_le32 (VAR_32 + 0x4);
VAR_39->unk1 = r_read_le32 (VAR_32 + 0x8);
size_t VAR_40 = r_read_le32 (VAR_32 + 0xc);
size_t VAR_41 = r_read_le32 (VAR_32 + 0x10);
VAR_39->unk2 = (st32)r_read_le32 (VAR_32 + 0x14);
VAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;
VAR_39->name = str_dup_safe (VAR_6, VAR_35 + VAR_40, VAR_8);
if (!VAR_39->name) {
VAR_32 += VAR_18;
continue;
}
VAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;
VAR_39->mangled_name = str_dup_safe (VAR_6, VAR_35 + VAR_41, VAR_8);
if (!VAR_39->mangled_name) {
VAR_32 += VAR_18;
continue;
}
VAR_32 += VAR_18;
}
}
if (VAR_7->n_lined_symbols) {
VAR_5->lined_symbols = R_NEWS0 (VAR_29, VAR_7->n_lined_symbols);
if (!VAR_5->lined_symbols) {
goto beach;
}
size_t VAR_31;
ut8 *VAR_32 = VAR_6 + VAR_17;
for (VAR_31 = 0; VAR_31 < VAR_7->n_lined_symbols && VAR_32 + VAR_20 <= VAR_8; VAR_31++) {
RCoreSymCacheElementLinedSymbol *VAR_42 = &VAR_5->lined_symbols[VAR_31];
VAR_42->sym.paddr = r_read_le32 (VAR_32);
VAR_42->sym.size = r_read_le32 (VAR_32 + 0x4);
VAR_42->sym.unk1 = r_read_le32 (VAR_32 + 0x8);
size_t VAR_40 = r_read_le32 (VAR_32 + 0xc);
size_t VAR_41 = r_read_le32 (VAR_32 + 0x10);
VAR_42->sym.unk2 = (st32)r_read_le32 (VAR_32 + 0x14);
size_t VAR_43 = r_read_le32 (VAR_32 + 0x18);
VAR_42->flc.line = r_read_le32 (VAR_32 + 0x1c);
VAR_42->flc.col = r_read_le32 (VAR_32 + 0x20);
VAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;
VAR_42->sym.name = str_dup_safe (VAR_6, VAR_35 + VAR_40, VAR_8);
if (!VAR_42->sym.name) {
VAR_32 += VAR_20;
continue;
}
VAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;
VAR_42->sym.mangled_name = str_dup_safe (VAR_6, VAR_35 + VAR_41, VAR_8);
if (!VAR_42->sym.mangled_name) {
VAR_32 += VAR_20;
continue;
}
VAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;
VAR_42->flc.file = str_dup_safe (VAR_6, VAR_35 + VAR_43, VAR_8);
if (!VAR_42->flc.file) {
VAR_32 += VAR_20;
continue;
}
VAR_32 += VAR_20;
meta_add_fileline (VAR_0, r_coresym_cache_element_pa2va (VAR_5, VAR_42->sym.paddr), VAR_42->sym.size, &VAR_42->flc);
}
}
if (VAR_7->n_line_info) {
VAR_5->line_info = R_NEWS0 (VAR_30, VAR_7->n_line_info);
if (!VAR_5->line_info) {
goto beach;
}
size_t VAR_31;
ut8 *VAR_32 = VAR_6 + VAR_19;
for (VAR_31 = 0; VAR_31 < VAR_7->n_line_info && VAR_32 + VAR_22 <= VAR_8; VAR_31++) {
RCoreSymCacheElementLineInfo *VAR_44 = &VAR_5->line_info[VAR_31];
VAR_44->paddr = r_read_le32 (VAR_32);
VAR_44->size = r_read_le32 (VAR_32 + 4);
size_t VAR_43 = r_read_le32 (VAR_32 + 8);
VAR_44->flc.line = r_read_le32 (VAR_32 + 0xc);
VAR_44->flc.col = r_read_le32 (VAR_32 + 0x10);
VAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;
VAR_44->flc.file = str_dup_safe (VAR_6, VAR_35 + VAR_43, VAR_8);
if (!VAR_44->flc.file) {
break;
}
VAR_32 += VAR_22;
meta_add_fileline (VAR_0, r_coresym_cache_element_pa2va (VAR_5, VAR_44->paddr), VAR_44->size, &VAR_44->flc);
}
}
beach:
free (VAR_6);
return VAR_5;
}",radareorg/radare2/a35f89f86ed12161af09330e92e5a213014e46a1/coresymbolication.c/vul/before/0.json,"RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut64 off, int bits, char * file_name) {
	RCoreSymCacheElement *result = NULL;
	ut8 *b = NULL;
	RCoreSymCacheElementHdr *hdr = r_coresym_cache_element_header_new (buf, off, bits);
	if (!hdr) {
		return NULL;
	}
	if (hdr->version != 1) {
		eprintf (""Unsupported CoreSymbolication cache version (%d)\n"", hdr->version);
		goto beach;
	}
	if (hdr->size == 0 || hdr->size > r_buf_size (buf) - off) {
		eprintf (""Corrupted CoreSymbolication header: size out of bounds (0x%x)\n"", hdr->size);
		goto beach;
	}
	result = R_NEW0 (RCoreSymCacheElement);
	if (!result) {
		goto beach;
	}
	result->hdr = hdr;
	b = malloc (hdr->size);
	if (!b) {
		goto beach;
	}
	if (r_buf_read_at (buf, off, b, hdr->size) != hdr->size) {
		goto beach;
	}
	ut8 *end = b + hdr->size;
	if (file_name) {
		result->file_name = file_name;
	} else if (hdr->file_name_off) {
		result->file_name = str_dup_safe (b, b + (size_t)hdr->file_name_off, end);
	}
	if (hdr->version_off) {
		result->binary_version = str_dup_safe (b, b + (size_t)hdr->version_off, end);
	}
	const size_t word_size = bits / 8;
	const ut64 start_of_sections = (ut64)hdr->n_segments * R_CS_EL_SIZE_SEG + R_CS_EL_OFF_SEGS;
	const ut64 sect_size = (bits == 32) ? R_CS_EL_SIZE_SECT_32 : R_CS_EL_SIZE_SECT_64;
	const ut64 start_of_symbols = start_of_sections + (ut64)hdr->n_sections * sect_size;
	const ut64 start_of_lined_symbols = start_of_symbols + (ut64)hdr->n_symbols * R_CS_EL_SIZE_SYM;
	const ut64 start_of_line_info = start_of_lined_symbols + (ut64)hdr->n_lined_symbols * R_CS_EL_SIZE_LSYM;
	const ut64 start_of_unknown_pairs = start_of_line_info + (ut64)hdr->n_line_info * R_CS_EL_SIZE_LINFO;
	const ut64 start_of_strings = start_of_unknown_pairs + (ut64)hdr->n_symbols * 8;

	ut64 page_zero_size = 0;
	size_t page_zero_idx = 0;
	if (UT32_MUL_OVFCHK (hdr->n_segments, sizeof (RCoreSymCacheElementSegment))) {
		goto beach;
	} else if (UT32_MUL_OVFCHK (hdr->n_sections, sizeof (RCoreSymCacheElementSection))) {
		goto beach;
	} else if (UT32_MUL_OVFCHK (hdr->n_symbols, sizeof (RCoreSymCacheElementSymbol))) {
		goto beach;
	} else if (UT32_MUL_OVFCHK (hdr->n_lined_symbols, sizeof (RCoreSymCacheElementLinedSymbol))) {
		goto beach;
	} else if (UT32_MUL_OVFCHK (hdr->n_line_info, sizeof (RCoreSymCacheElementLineInfo))) {
		goto beach;
	}
	if (hdr->n_segments > 0) {
		result->segments = R_NEWS0 (RCoreSymCacheElementSegment, hdr->n_segments);
		if (!result->segments) {
			goto beach;
		}
		size_t i;
		ut8 *cursor = b + R_CS_EL_OFF_SEGS;
		for (i = 0; i < hdr->n_segments && cursor + sizeof (RCoreSymCacheElementSegment) < end; i++) {
			RCoreSymCacheElementSegment *seg = &result->segments[i];
			seg->paddr = seg->vaddr = r_read_le64 (cursor);
			cursor += 8;
			if (cursor >= end) {
				break;
			}
			seg->size = seg->vsize = r_read_le64 (cursor);
			cursor += 8;
			if (cursor >= end) {
				break;
			}
			seg->name = str_dup_safe_fixed (b, cursor, 16, end);
			cursor += 16;
			if (!seg->name) {
				continue;
			}

			if (!strcmp (seg->name, ""__PAGEZERO"")) {
				page_zero_size = seg->size;
				page_zero_idx = i;
				seg->paddr = seg->vaddr = 0;
				seg->size = 0;
			}
		}
		for (i = 0; i < hdr->n_segments && page_zero_size > 0; i++) {
			if (i == page_zero_idx) {
				continue;
			}
			RCoreSymCacheElementSegment *seg = &result->segments[i];
			if (seg->vaddr < page_zero_size) {
				seg->vaddr += page_zero_size;
			}
		}
	}
	bool relative_to_strings = false;
	ut8* string_origin;
	if (hdr->n_sections > 0) {
		result->sections = R_NEWS0 (RCoreSymCacheElementSection, hdr->n_sections);
		if (!result->sections) {
			goto beach;
		}
		size_t i;
		ut8 *cursor = b + start_of_sections;
		for (i = 0; i < hdr->n_sections && cursor < end; i++) {
			ut8 *sect_start = cursor;
			RCoreSymCacheElementSection *sect = &result->sections[i];
			sect->vaddr = sect->paddr = r_read_ble (cursor, false, bits);
			if (sect->vaddr < page_zero_size) {
				sect->vaddr += page_zero_size;
			}
			cursor += word_size;
			if (cursor >= end) {
				break;
			}
			sect->size = r_read_ble (cursor, false, bits);
			cursor += word_size;
			if (cursor >= end) {
				break;
			}
			ut64 sect_name_off = r_read_ble (cursor, false, bits);
			if (!i && !sect_name_off) {
				relative_to_strings = true;
			}
			cursor += word_size;
			if (bits == 32) {
				cursor += word_size;
			}
			string_origin = relative_to_strings? b + start_of_strings : sect_start;
			sect->name = str_dup_safe (b, string_origin + (size_t)sect_name_off, end);
		}
	}
	if (hdr->n_symbols) {
		result->symbols = R_NEWS0 (RCoreSymCacheElementSymbol, hdr->n_symbols);
		if (!result->symbols) {
			goto beach;
		}
		size_t i;
		ut8 *cursor = b + start_of_symbols;
		for (i = 0; i < hdr->n_symbols && cursor + R_CS_EL_SIZE_SYM <= end; i++) {
			RCoreSymCacheElementSymbol *sym = &result->symbols[i];
			sym->paddr = r_read_le32 (cursor);
			sym->size = r_read_le32 (cursor + 0x4);
			sym->unk1 = r_read_le32 (cursor + 0x8);
			size_t name_off = r_read_le32 (cursor + 0xc);
			size_t mangled_name_off = r_read_le32 (cursor + 0x10);
			sym->unk2 = (st32)r_read_le32 (cursor + 0x14);
			string_origin = relative_to_strings? b + start_of_strings : cursor;
			sym->name = str_dup_safe (b, string_origin + name_off, end);
			if (!sym->name) {
				cursor += R_CS_EL_SIZE_SYM;
				continue;
			}
			string_origin = relative_to_strings? b + start_of_strings : cursor;
			sym->mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);
			if (!sym->mangled_name) {
				cursor += R_CS_EL_SIZE_SYM;
				continue;
			}
			cursor += R_CS_EL_SIZE_SYM;
		}
	}
	if (hdr->n_lined_symbols) {
		result->lined_symbols = R_NEWS0 (RCoreSymCacheElementLinedSymbol, hdr->n_lined_symbols);
		if (!result->lined_symbols) {
			goto beach;
		}
		size_t i;
		ut8 *cursor = b + start_of_lined_symbols;
		for (i = 0; i < hdr->n_lined_symbols && cursor + R_CS_EL_SIZE_LSYM <= end; i++) {
			RCoreSymCacheElementLinedSymbol *lsym = &result->lined_symbols[i];
			lsym->sym.paddr = r_read_le32 (cursor);
			lsym->sym.size = r_read_le32 (cursor + 0x4);
			lsym->sym.unk1 = r_read_le32 (cursor + 0x8);
			size_t name_off = r_read_le32 (cursor + 0xc);
			size_t mangled_name_off = r_read_le32 (cursor + 0x10);
			lsym->sym.unk2 = (st32)r_read_le32 (cursor + 0x14);
			size_t file_name_off = r_read_le32 (cursor + 0x18);
			lsym->flc.line = r_read_le32 (cursor + 0x1c);
			lsym->flc.col = r_read_le32 (cursor + 0x20);
			string_origin = relative_to_strings? b + start_of_strings : cursor;
			lsym->sym.name = str_dup_safe (b, string_origin + name_off, end);
			if (!lsym->sym.name) {
				cursor += R_CS_EL_SIZE_LSYM;
				continue;
			}
			string_origin = relative_to_strings? b + start_of_strings : cursor;
			lsym->sym.mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);
			if (!lsym->sym.mangled_name) {
				cursor += R_CS_EL_SIZE_LSYM;
				continue;
			}
			string_origin = relative_to_strings? b + start_of_strings : cursor;
			lsym->flc.file = str_dup_safe (b, string_origin + file_name_off, end);
			if (!lsym->flc.file) {
				cursor += R_CS_EL_SIZE_LSYM;
				continue;
			}
			cursor += R_CS_EL_SIZE_LSYM;
			meta_add_fileline (bf, r_coresym_cache_element_pa2va (result, lsym->sym.paddr), lsym->sym.size, &lsym->flc);
		}
	}
	if (hdr->n_line_info) {
		result->line_info = R_NEWS0 (RCoreSymCacheElementLineInfo, hdr->n_line_info);
		if (!result->line_info) {
			goto beach;
		}
		size_t i;
		ut8 *cursor = b + start_of_line_info;
		for (i = 0; i < hdr->n_line_info && cursor + R_CS_EL_SIZE_LINFO <= end; i++) {
			RCoreSymCacheElementLineInfo *info = &result->line_info[i];
			info->paddr = r_read_le32 (cursor);
			info->size = r_read_le32 (cursor + 4);
			size_t file_name_off = r_read_le32 (cursor + 8);
			info->flc.line = r_read_le32 (cursor + 0xc);
			info->flc.col = r_read_le32 (cursor + 0x10);
			string_origin = relative_to_strings? b + start_of_strings : cursor;
			info->flc.file = str_dup_safe (b, string_origin + file_name_off, end);
			if (!info->flc.file) {
				break;
			}
			cursor += R_CS_EL_SIZE_LINFO;
			meta_add_fileline (bf, r_coresym_cache_element_pa2va (result, info->paddr), info->size, &info->flc);
		}
	}

	/*
	 * TODO:
	 * Figure out the meaning of the 2 arrays of hdr->n_symbols
	 * 32-bit integers located at the end of line info.
	 * Those are the last info before the strings at the end.
	 */

beach:
	free (b);
	return result;
}","RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *VAR_0, RBuffer *VAR_1, ut64 VAR_2, int VAR_3, char * VAR_4) {
	RCoreSymCacheElement *VAR_5 = NULL;
	ut8 *VAR_6 = NULL;
	RCoreSymCacheElementHdr *VAR_7 = r_coresym_cache_element_header_new (VAR_1, VAR_2, VAR_3);
	if (!VAR_7) {
		return NULL;
	}
	if (VAR_7->version != 1) {
		eprintf (""Unsupported CoreSymbolication cache version (%d)\n"", VAR_7->version);
		goto beach;
	}
	if (VAR_7->size == 0 || VAR_7->size > r_buf_size (VAR_1) - VAR_2) {
		eprintf (""Corrupted CoreSymbolication header: size out of bounds (0x%x)\n"", VAR_7->size);
		goto beach;
	}
	VAR_5 = R_NEW0 (RCoreSymCacheElement);
	if (!VAR_5) {
		goto beach;
	}
	VAR_5->hdr = VAR_7;
	VAR_6 = malloc (VAR_7->size);
	if (!VAR_6) {
		goto beach;
	}
	if (r_buf_read_at (VAR_1, VAR_2, VAR_6, VAR_7->size) != VAR_7->size) {
		goto beach;
	}
	ut8 *VAR_8 = VAR_6 + VAR_7->size;
	if (VAR_4) {
		VAR_5->file_name = VAR_4;
	} else if (VAR_7->file_name_off) {
		VAR_5->file_name = str_dup_safe (VAR_6, VAR_6 + (size_t)VAR_7->file_name_off, VAR_8);
	}
	if (VAR_7->version_off) {
		VAR_5->binary_version = str_dup_safe (VAR_6, VAR_6 + (size_t)VAR_7->version_off, VAR_8);
	}
	const size_t VAR_9 = VAR_3 / 8;
	const ut64 VAR_10 = (ut64)VAR_7->n_segments * VAR_11 + VAR_12;
	const ut64 VAR_13 = (VAR_3 == 32) ? VAR_14 : VAR_15;
	const ut64 VAR_16 = VAR_10 + (ut64)VAR_7->n_sections * VAR_13;
	const ut64 VAR_17 = VAR_16 + (ut64)VAR_7->n_symbols * VAR_18;
	const ut64 VAR_19 = VAR_17 + (ut64)VAR_7->n_lined_symbols * VAR_20;
	const ut64 VAR_21 = VAR_19 + (ut64)VAR_7->n_line_info * VAR_22;
	const ut64 VAR_23 = VAR_21 + (ut64)VAR_7->n_symbols * 8;

	ut64 VAR_24 = 0;
	size_t VAR_25 = 0;
	if (UT32_MUL_OVFCHK (VAR_7->n_segments, sizeof (VAR_26))) {
		goto beach;
	} else if (UT32_MUL_OVFCHK (VAR_7->n_sections, sizeof (VAR_27))) {
		goto beach;
	} else if (UT32_MUL_OVFCHK (VAR_7->n_symbols, sizeof (VAR_28))) {
		goto beach;
	} else if (UT32_MUL_OVFCHK (VAR_7->n_lined_symbols, sizeof (VAR_29))) {
		goto beach;
	} else if (UT32_MUL_OVFCHK (VAR_7->n_line_info, sizeof (VAR_30))) {
		goto beach;
	}
	if (VAR_7->n_segments > 0) {
		VAR_5->segments = R_NEWS0 (VAR_26, VAR_7->n_segments);
		if (!VAR_5->segments) {
			goto beach;
		}
		size_t VAR_31;
		ut8 *VAR_32 = VAR_6 + VAR_12;
		for (VAR_31 = 0; VAR_31 < VAR_7->n_segments && VAR_32 + sizeof (VAR_26) < VAR_8; VAR_31++) {
			RCoreSymCacheElementSegment *VAR_33 = &VAR_5->segments[VAR_31];
			VAR_33->paddr = VAR_33->vaddr = r_read_le64 (VAR_32);
			VAR_32 += 8;
			if (VAR_32 >= VAR_8) {
				break;
			}
			VAR_33->size = VAR_33->vsize = r_read_le64 (VAR_32);
			VAR_32 += 8;
			if (VAR_32 >= VAR_8) {
				break;
			}
			VAR_33->name = str_dup_safe_fixed (VAR_6, VAR_32, 16, VAR_8);
			VAR_32 += 16;
			if (!VAR_33->name) {
				continue;
			}

			if (!strcmp (VAR_33->name, ""__PAGEZERO"")) {
				VAR_24 = VAR_33->size;
				VAR_25 = VAR_31;
				VAR_33->paddr = VAR_33->vaddr = 0;
				VAR_33->size = 0;
			}
		}
		for (VAR_31 = 0; VAR_31 < VAR_7->n_segments && VAR_24 > 0; VAR_31++) {
			if (VAR_31 == VAR_25) {
				continue;
			}
			RCoreSymCacheElementSegment *VAR_33 = &VAR_5->segments[VAR_31];
			if (VAR_33->vaddr < VAR_24) {
				VAR_33->vaddr += VAR_24;
			}
		}
	}
	bool VAR_34 = false;
	ut8* VAR_35;
	if (VAR_7->n_sections > 0) {
		VAR_5->sections = R_NEWS0 (VAR_27, VAR_7->n_sections);
		if (!VAR_5->sections) {
			goto beach;
		}
		size_t VAR_31;
		ut8 *VAR_32 = VAR_6 + VAR_10;
		for (VAR_31 = 0; VAR_31 < VAR_7->n_sections && VAR_32 < VAR_8; VAR_31++) {
			ut8 *VAR_36 = VAR_32;
			RCoreSymCacheElementSection *VAR_37 = &VAR_5->sections[VAR_31];
			VAR_37->vaddr = VAR_37->paddr = r_read_ble (VAR_32, false, VAR_3);
			if (VAR_37->vaddr < VAR_24) {
				VAR_37->vaddr += VAR_24;
			}
			VAR_32 += VAR_9;
			if (VAR_32 >= VAR_8) {
				break;
			}
			VAR_37->size = r_read_ble (VAR_32, false, VAR_3);
			VAR_32 += VAR_9;
			if (VAR_32 >= VAR_8) {
				break;
			}
			ut64 VAR_38 = r_read_ble (VAR_32, false, VAR_3);
			if (!VAR_31 && !VAR_38) {
				VAR_34 = true;
			}
			VAR_32 += VAR_9;
			if (VAR_3 == 32) {
				VAR_32 += VAR_9;
			}
			VAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_36;
			VAR_37->name = str_dup_safe (VAR_6, VAR_35 + (size_t)VAR_38, VAR_8);
		}
	}
	if (VAR_7->n_symbols) {
		VAR_5->symbols = R_NEWS0 (VAR_28, VAR_7->n_symbols);
		if (!VAR_5->symbols) {
			goto beach;
		}
		size_t VAR_31;
		ut8 *VAR_32 = VAR_6 + VAR_16;
		for (VAR_31 = 0; VAR_31 < VAR_7->n_symbols && VAR_32 + VAR_18 <= VAR_8; VAR_31++) {
			RCoreSymCacheElementSymbol *VAR_39 = &VAR_5->symbols[VAR_31];
			VAR_39->paddr = r_read_le32 (VAR_32);
			VAR_39->size = r_read_le32 (VAR_32 + 0x4);
			VAR_39->unk1 = r_read_le32 (VAR_32 + 0x8);
			size_t VAR_40 = r_read_le32 (VAR_32 + 0xc);
			size_t VAR_41 = r_read_le32 (VAR_32 + 0x10);
			VAR_39->unk2 = (st32)r_read_le32 (VAR_32 + 0x14);
			VAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;
			VAR_39->name = str_dup_safe (VAR_6, VAR_35 + VAR_40, VAR_8);
			if (!VAR_39->name) {
				VAR_32 += VAR_18;
				continue;
			}
			VAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;
			VAR_39->mangled_name = str_dup_safe (VAR_6, VAR_35 + VAR_41, VAR_8);
			if (!VAR_39->mangled_name) {
				VAR_32 += VAR_18;
				continue;
			}
			VAR_32 += VAR_18;
		}
	}
	if (VAR_7->n_lined_symbols) {
		VAR_5->lined_symbols = R_NEWS0 (VAR_29, VAR_7->n_lined_symbols);
		if (!VAR_5->lined_symbols) {
			goto beach;
		}
		size_t VAR_31;
		ut8 *VAR_32 = VAR_6 + VAR_17;
		for (VAR_31 = 0; VAR_31 < VAR_7->n_lined_symbols && VAR_32 + VAR_20 <= VAR_8; VAR_31++) {
			RCoreSymCacheElementLinedSymbol *VAR_42 = &VAR_5->lined_symbols[VAR_31];
			VAR_42->sym.paddr = r_read_le32 (VAR_32);
			VAR_42->sym.size = r_read_le32 (VAR_32 + 0x4);
			VAR_42->sym.unk1 = r_read_le32 (VAR_32 + 0x8);
			size_t VAR_40 = r_read_le32 (VAR_32 + 0xc);
			size_t VAR_41 = r_read_le32 (VAR_32 + 0x10);
			VAR_42->sym.unk2 = (st32)r_read_le32 (VAR_32 + 0x14);
			size_t VAR_43 = r_read_le32 (VAR_32 + 0x18);
			VAR_42->flc.line = r_read_le32 (VAR_32 + 0x1c);
			VAR_42->flc.col = r_read_le32 (VAR_32 + 0x20);
			VAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;
			VAR_42->sym.name = str_dup_safe (VAR_6, VAR_35 + VAR_40, VAR_8);
			if (!VAR_42->sym.name) {
				VAR_32 += VAR_20;
				continue;
			}
			VAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;
			VAR_42->sym.mangled_name = str_dup_safe (VAR_6, VAR_35 + VAR_41, VAR_8);
			if (!VAR_42->sym.mangled_name) {
				VAR_32 += VAR_20;
				continue;
			}
			VAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;
			VAR_42->flc.file = str_dup_safe (VAR_6, VAR_35 + VAR_43, VAR_8);
			if (!VAR_42->flc.file) {
				VAR_32 += VAR_20;
				continue;
			}
			VAR_32 += VAR_20;
			meta_add_fileline (VAR_0, r_coresym_cache_element_pa2va (VAR_5, VAR_42->sym.paddr), VAR_42->sym.size, &VAR_42->flc);
		}
	}
	if (VAR_7->n_line_info) {
		VAR_5->line_info = R_NEWS0 (VAR_30, VAR_7->n_line_info);
		if (!VAR_5->line_info) {
			goto beach;
		}
		size_t VAR_31;
		ut8 *VAR_32 = VAR_6 + VAR_19;
		for (VAR_31 = 0; VAR_31 < VAR_7->n_line_info && VAR_32 + VAR_22 <= VAR_8; VAR_31++) {
			RCoreSymCacheElementLineInfo *VAR_44 = &VAR_5->line_info[VAR_31];
			VAR_44->paddr = r_read_le32 (VAR_32);
			VAR_44->size = r_read_le32 (VAR_32 + 4);
			size_t VAR_43 = r_read_le32 (VAR_32 + 8);
			VAR_44->flc.line = r_read_le32 (VAR_32 + 0xc);
			VAR_44->flc.col = r_read_le32 (VAR_32 + 0x10);
			VAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;
			VAR_44->flc.file = str_dup_safe (VAR_6, VAR_35 + VAR_43, VAR_8);
			if (!VAR_44->flc.file) {
				break;
			}
			VAR_32 += VAR_22;
			meta_add_fileline (VAR_0, r_coresym_cache_element_pa2va (VAR_5, VAR_44->paddr), VAR_44->size, &VAR_44->flc);
		}
	}

	/* COMMENT_0 */
         
                                                            
                                                    
                                                          
    

beach:
	free (VAR_6);
	return VAR_5;
}",radareorg/radare2/a35f89f86ed12161af09330e92e5a213014e46a1/coresymbolication.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -63,7 +63,7 @@
 		}
 		size_t i;
 		ut8 *cursor = b + R_CS_EL_OFF_SEGS;
-		for (i = 0; i < hdr->n_segments && cursor < end; i++) {
+		for (i = 0; i < hdr->n_segments && cursor + sizeof (RCoreSymCacheElementSegment) < end; i++) {
 			RCoreSymCacheElementSegment *seg = &result->segments[i];
 			seg->paddr = seg->vaddr = r_read_le64 (cursor);
 			cursor += 8;","{'deleted_lines': ['\t\tfor (i = 0; i < hdr->n_segments && cursor < end; i++) {'], 'added_lines': ['\t\tfor (i = 0; i < hdr->n_segments && cursor + sizeof (RCoreSymCacheElementSegment) < end; i++) {']}",True,Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.6.4.,7.1,HIGH,2,test,2022-02-21T18:25:02Z,4
CVE-2022-26356,['CWE-667'],AV:L/AC:H/Au:N/C:N/I:N/A:C,0,xen-project/xen,"x86/hap: do not switch on log dirty for VRAM tracking

XEN_DMOP_track_dirty_vram possibly calls into paging_log_dirty_enable
when using HAP mode, and it can interact badly with other ongoing
paging domctls, as XEN_DMOP_track_dirty_vram is not holding the domctl
lock.

This was detected as a result of the following assert triggering when
doing repeated migrations of a HAP HVM domain with a stubdom:

Assertion 'd->arch.paging.log_dirty.allocs == 0' failed at paging.c:198
----[ Xen-4.17-unstable  x86_64  debug=y  Not tainted ]----
CPU:    34
RIP:    e008:[<ffff82d040314b3b>] arch/x86/mm/paging.c#paging_free_log_dirty_bitmap+0x606/0x6
RFLAGS: 0000000000010206   CONTEXT: hypervisor (d0v23)
[...]
Xen call trace:
   [<ffff82d040314b3b>] R arch/x86/mm/paging.c#paging_free_log_dirty_bitmap+0x606/0x63a
   [<ffff82d040279f96>] S xsm/flask/hooks.c#domain_has_perm+0x5a/0x67
   [<ffff82d04031577f>] F paging_domctl+0x251/0xd41
   [<ffff82d04031640c>] F paging_domctl_continuation+0x19d/0x202
   [<ffff82d0403202fa>] F pv_hypercall+0x150/0x2a7
   [<ffff82d0403a729d>] F lstar_enter+0x12d/0x140

Such assert triggered because the stubdom used
XEN_DMOP_track_dirty_vram while dom0 was in the middle of executing
XEN_DOMCTL_SHADOW_OP_OFF, and so log dirty become enabled while
retiring the old structures, thus leading to new entries being
populated in already clear slots.

Fix this by not enabling log dirty for VRAM tracking, similar to what
is done when using shadow instead of HAP. Call
p2m_enable_hardware_log_dirty when enabling VRAM tracking in order to
get some hardware assistance if available. As a side effect the memory
pressure on the p2m pool should go down if only VRAM tracking is
enabled, as the dirty bitmap is no longer allocated.

Note that paging_log_dirty_range (used to get the dirty bitmap for
VRAM tracking) doesn't use the log dirty bitmap, and instead relies on
checking whether each gfn on the range has been switched from
p2m_ram_logdirty to p2m_ram_rw in order to account for dirty pages.

This is CVE-2022-26356 / XSA-397.

Signed-off-by: Roger Pau Monn <roger.pau@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",4f4db53784d912c4f409a451c36ebfd4754e0a42,https://github.com/xen-project/xen/commit/4f4db53784d912c4f409a451c36ebfd4754e0a42,xen/arch/x86/mm/paging.c,paging_log_dirty_enable,"int paging_log_dirty_enable(struct domain *d, bool log_global)
{
int ret;
if ( has_arch_pdevs(d) && log_global )
{
return -EINVAL;
}
if ( paging_mode_log_dirty(d) )
return -EINVAL;
domain_pause(d);
ret = d->arch.paging.log_dirty.ops->enable(d, log_global);
domain_unpause(d);
return ret;
}","int paging_log_dirty_enable(struct domain *VAR_0, bool VAR_1)
{
int VAR_2;
if ( has_arch_pdevs(VAR_0) && VAR_1 )
{
return -VAR_3;
}
if ( paging_mode_log_dirty(VAR_0) )
return -VAR_3;
domain_pause(VAR_0);
VAR_2 = VAR_0->arch.paging.log_dirty.ops->enable(VAR_0, VAR_1);
domain_unpause(VAR_0);
return VAR_2;
}",xen-project/xen/4f4db53784d912c4f409a451c36ebfd4754e0a42/paging.c/vul/before/0.json,"static int paging_log_dirty_enable(struct domain *d, bool log_global)
{
    int ret;

    if ( has_arch_pdevs(d) && log_global )
    {
        /*
         * Refuse to turn on global log-dirty mode
         * if the domain is sharing the P2M with the IOMMU.
         */
        return -EINVAL;
    }

    if ( paging_mode_log_dirty(d) )
        return -EINVAL;

    domain_pause(d);
    ret = d->arch.paging.log_dirty.ops->enable(d, log_global);
    domain_unpause(d);

    return ret;
}","static int paging_log_dirty_enable(struct domain *VAR_0, bool VAR_1)
{
    int VAR_2;

    if ( has_arch_pdevs(VAR_0) && VAR_1 )
    {
        /* COMMENT_0 */
                                                  
                                                           
           
        return -VAR_3;
    }

    if ( paging_mode_log_dirty(VAR_0) )
        return -VAR_3;

    domain_pause(VAR_0);
    VAR_2 = VAR_0->arch.paging.log_dirty.ops->enable(VAR_0, VAR_1);
    domain_unpause(VAR_0);

    return VAR_2;
}",xen-project/xen/4f4db53784d912c4f409a451c36ebfd4754e0a42/paging.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-int paging_log_dirty_enable(struct domain *d, bool log_global)
+static int paging_log_dirty_enable(struct domain *d, bool log_global)
 {
     int ret;
 ","{'deleted_lines': ['int paging_log_dirty_enable(struct domain *d, bool log_global)'], 'added_lines': ['static int paging_log_dirty_enable(struct domain *d, bool log_global)']}",True,"Racy interactions between dirty vram tracking and paging log dirty hypercalls Activation of log dirty mode done by XEN_DMOP_track_dirty_vram (was named HVMOP_track_dirty_vram before Xen 4.9) is racy with ongoing log dirty hypercalls. A suitably timed call to XEN_DMOP_track_dirty_vram can enable log dirty while another CPU is still in the process of tearing down the structures related to a previously enabled log dirty mode (XEN_DOMCTL_SHADOW_OP_OFF). This is due to lack of mutually exclusive locking between both operations and can lead to entries being added in already freed slots, resulting in a memory leak.",5.6,MEDIUM,1,test,2022-02-23T08:40:40Z,4
CVE-2022-26356,['CWE-667'],AV:L/AC:H/Au:N/C:N/I:N/A:C,0,xen-project/xen,"x86/hap: do not switch on log dirty for VRAM tracking

XEN_DMOP_track_dirty_vram possibly calls into paging_log_dirty_enable
when using HAP mode, and it can interact badly with other ongoing
paging domctls, as XEN_DMOP_track_dirty_vram is not holding the domctl
lock.

This was detected as a result of the following assert triggering when
doing repeated migrations of a HAP HVM domain with a stubdom:

Assertion 'd->arch.paging.log_dirty.allocs == 0' failed at paging.c:198
----[ Xen-4.17-unstable  x86_64  debug=y  Not tainted ]----
CPU:    34
RIP:    e008:[<ffff82d040314b3b>] arch/x86/mm/paging.c#paging_free_log_dirty_bitmap+0x606/0x6
RFLAGS: 0000000000010206   CONTEXT: hypervisor (d0v23)
[...]
Xen call trace:
   [<ffff82d040314b3b>] R arch/x86/mm/paging.c#paging_free_log_dirty_bitmap+0x606/0x63a
   [<ffff82d040279f96>] S xsm/flask/hooks.c#domain_has_perm+0x5a/0x67
   [<ffff82d04031577f>] F paging_domctl+0x251/0xd41
   [<ffff82d04031640c>] F paging_domctl_continuation+0x19d/0x202
   [<ffff82d0403202fa>] F pv_hypercall+0x150/0x2a7
   [<ffff82d0403a729d>] F lstar_enter+0x12d/0x140

Such assert triggered because the stubdom used
XEN_DMOP_track_dirty_vram while dom0 was in the middle of executing
XEN_DOMCTL_SHADOW_OP_OFF, and so log dirty become enabled while
retiring the old structures, thus leading to new entries being
populated in already clear slots.

Fix this by not enabling log dirty for VRAM tracking, similar to what
is done when using shadow instead of HAP. Call
p2m_enable_hardware_log_dirty when enabling VRAM tracking in order to
get some hardware assistance if available. As a side effect the memory
pressure on the p2m pool should go down if only VRAM tracking is
enabled, as the dirty bitmap is no longer allocated.

Note that paging_log_dirty_range (used to get the dirty bitmap for
VRAM tracking) doesn't use the log dirty bitmap, and instead relies on
checking whether each gfn on the range has been switched from
p2m_ram_logdirty to p2m_ram_rw in order to account for dirty pages.

This is CVE-2022-26356 / XSA-397.

Signed-off-by: Roger Pau Monn <roger.pau@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",4f4db53784d912c4f409a451c36ebfd4754e0a42,https://github.com/xen-project/xen/commit/4f4db53784d912c4f409a451c36ebfd4754e0a42,xen/arch/x86/mm/hap/hap.c,hap_track_dirty_vram,"int hap_track_dirty_vram(struct domain *d,
unsigned long begin_pfn,
unsigned int nr_frames,
XEN_GUEST_HANDLE(void) guest_dirty_bitmap)
{
long rc = 0;
struct sh_dirty_vram *dirty_vram;
uint8_t *dirty_bitmap = NULL;
if ( nr_frames )
{
unsigned int size = DIV_ROUND_UP(nr_frames, BITS_PER_BYTE);
if ( !paging_mode_log_dirty(d) )
{
rc = paging_log_dirty_enable(d, false);
if ( rc )
goto out;
}
rc = -ENOMEM;
dirty_bitmap = vzalloc(size);
if ( !dirty_bitmap )
goto out;
paging_lock(d);
dirty_vram = d->arch.hvm.dirty_vram;
if ( !dirty_vram )
{
rc = -ENOMEM;
if ( (dirty_vram = xzalloc(struct sh_dirty_vram)) == NULL )
{
paging_unlock(d);
goto out;
}
d->arch.hvm.dirty_vram = dirty_vram;
}
if ( begin_pfn != dirty_vram->begin_pfn ||
begin_pfn + nr_frames != dirty_vram->end_pfn )
{
unsigned long ostart = dirty_vram->begin_pfn;
unsigned long oend = dirty_vram->end_pfn;
dirty_vram->begin_pfn = begin_pfn;
dirty_vram->end_pfn = begin_pfn + nr_frames;
paging_unlock(d);
if ( oend > ostart )
p2m_change_type_range(d, ostart, oend,
p2m_ram_logdirty, p2m_ram_rw);
p2m_change_type_range(d, begin_pfn, begin_pfn + nr_frames,
p2m_ram_rw, p2m_ram_logdirty);
guest_flush_tlb_mask(d, d->dirty_cpumask);
memset(dirty_bitmap, 0xff, size); 
}
else
{
paging_unlock(d);
domain_pause(d);
p2m_flush_hardware_cached_dirty(d);
paging_log_dirty_range(d, begin_pfn, nr_frames, dirty_bitmap);
domain_unpause(d);
}
rc = -EFAULT;
if ( copy_to_guest(guest_dirty_bitmap, dirty_bitmap, size) == 0 )
rc = 0;
}
else
{
paging_lock(d);
dirty_vram = d->arch.hvm.dirty_vram;
if ( dirty_vram )
{
begin_pfn = dirty_vram->begin_pfn;
nr_frames = dirty_vram->end_pfn - dirty_vram->begin_pfn;
xfree(dirty_vram);
d->arch.hvm.dirty_vram = NULL;
}
paging_unlock(d);
if ( nr_frames )
p2m_change_type_range(d, begin_pfn, begin_pfn + nr_frames,
p2m_ram_logdirty, p2m_ram_rw);
}
out:
vfree(dirty_bitmap);
return rc;
}","int hap_track_dirty_vram(struct domain *VAR_0,
unsigned long VAR_1,
unsigned int VAR_2,
VAR_3(void) VAR_4)
{
long VAR_5 = 0;
struct sh_dirty_vram *VAR_6;
uint8_t *VAR_7 = NULL;
if ( VAR_2 )
{
unsigned int VAR_8 = DIV_ROUND_UP(VAR_2, VAR_9);
if ( !paging_mode_log_dirty(VAR_0) )
{
VAR_5 = paging_log_dirty_enable(VAR_0, false);
if ( VAR_5 )
goto out;
}
VAR_5 = -VAR_10;
VAR_7 = vzalloc(VAR_8);
if ( !VAR_7 )
goto out;
paging_lock(VAR_0);
VAR_6 = VAR_0->arch.hvm.dirty_vram;
if ( !VAR_6 )
{
VAR_5 = -VAR_10;
if ( (VAR_6 = xzalloc(struct sh_dirty_vram)) == NULL )
{
paging_unlock(VAR_0);
goto out;
}
VAR_0->arch.hvm.dirty_vram = VAR_6;
}
if ( VAR_1 != VAR_6->begin_pfn ||
VAR_1 + VAR_2 != VAR_6->end_pfn )
{
unsigned long VAR_11 = VAR_6->begin_pfn;
unsigned long VAR_12 = VAR_6->end_pfn;
VAR_6->begin_pfn = VAR_1;
VAR_6->end_pfn = VAR_1 + VAR_2;
paging_unlock(VAR_0);
if ( VAR_12 > VAR_11 )
p2m_change_type_range(VAR_0, VAR_11, VAR_12,
VAR_13, VAR_14);
p2m_change_type_range(VAR_0, VAR_1, VAR_1 + VAR_2,
VAR_14, VAR_13);
guest_flush_tlb_mask(VAR_0, VAR_0->dirty_cpumask);
memset(VAR_7, 0xff, VAR_8); 
}
else
{
paging_unlock(VAR_0);
domain_pause(VAR_0);
p2m_flush_hardware_cached_dirty(VAR_0);
paging_log_dirty_range(VAR_0, VAR_1, VAR_2, VAR_7);
domain_unpause(VAR_0);
}
VAR_5 = -VAR_15;
if ( copy_to_guest(VAR_4, VAR_7, VAR_8) == 0 )
VAR_5 = 0;
}
else
{
paging_lock(VAR_0);
VAR_6 = VAR_0->arch.hvm.dirty_vram;
if ( VAR_6 )
{
VAR_1 = VAR_6->begin_pfn;
VAR_2 = VAR_6->end_pfn - VAR_6->begin_pfn;
xfree(VAR_6);
VAR_0->arch.hvm.dirty_vram = NULL;
}
paging_unlock(VAR_0);
if ( VAR_2 )
p2m_change_type_range(VAR_0, VAR_1, VAR_1 + VAR_2,
VAR_13, VAR_14);
}
out:
vfree(VAR_7);
return VAR_5;
}",,"int hap_track_dirty_vram(struct domain *d,
                         unsigned long begin_pfn,
                         unsigned int nr_frames,
                         XEN_GUEST_HANDLE(void) guest_dirty_bitmap)
{
    long rc = 0;
    struct sh_dirty_vram *dirty_vram;
    uint8_t *dirty_bitmap = NULL;

    if ( nr_frames )
    {
        unsigned int size = DIV_ROUND_UP(nr_frames, BITS_PER_BYTE);

        rc = -ENOMEM;
        dirty_bitmap = vzalloc(size);
        if ( !dirty_bitmap )
            goto out;

        paging_lock(d);

        dirty_vram = d->arch.hvm.dirty_vram;
        if ( !dirty_vram )
        {
            rc = -ENOMEM;
            if ( (dirty_vram = xzalloc(struct sh_dirty_vram)) == NULL )
            {
                paging_unlock(d);
                goto out;
            }

            d->arch.hvm.dirty_vram = dirty_vram;
        }

        if ( begin_pfn != dirty_vram->begin_pfn ||
             begin_pfn + nr_frames != dirty_vram->end_pfn )
        {
            unsigned long ostart = dirty_vram->begin_pfn;
            unsigned long oend = dirty_vram->end_pfn;

            dirty_vram->begin_pfn = begin_pfn;
            dirty_vram->end_pfn = begin_pfn + nr_frames;

            paging_unlock(d);

            domain_pause(d);
            p2m_enable_hardware_log_dirty(d);
            domain_unpause(d);

            if ( oend > ostart )
                p2m_change_type_range(d, ostart, oend,
                                      p2m_ram_logdirty, p2m_ram_rw);

            /*
             * Switch vram to log dirty mode, either by setting l1e entries of
             * P2M table to be read-only, or via hardware-assisted log-dirty.
             */
            p2m_change_type_range(d, begin_pfn, begin_pfn + nr_frames,
                                  p2m_ram_rw, p2m_ram_logdirty);

            guest_flush_tlb_mask(d, d->dirty_cpumask);

            memset(dirty_bitmap, 0xff, size); /* consider all pages dirty */
        }
        else
        {
            paging_unlock(d);

            domain_pause(d);

            /* Flush dirty GFNs potentially cached by hardware. */
            p2m_flush_hardware_cached_dirty(d);

            /* get the bitmap */
            paging_log_dirty_range(d, begin_pfn, nr_frames, dirty_bitmap);

            domain_unpause(d);
        }

        rc = -EFAULT;
        if ( copy_to_guest(guest_dirty_bitmap, dirty_bitmap, size) == 0 )
            rc = 0;
    }
    else
    {
        paging_lock(d);

        dirty_vram = d->arch.hvm.dirty_vram;
        if ( dirty_vram )
        {
            /*
             * If zero pages specified while tracking dirty vram
             * then stop tracking
             */
            begin_pfn = dirty_vram->begin_pfn;
            nr_frames = dirty_vram->end_pfn - dirty_vram->begin_pfn;
            xfree(dirty_vram);
            d->arch.hvm.dirty_vram = NULL;
        }

        paging_unlock(d);

        if ( nr_frames )
            p2m_change_type_range(d, begin_pfn, begin_pfn + nr_frames,
                                  p2m_ram_logdirty, p2m_ram_rw);
    }
out:
    vfree(dirty_bitmap);

    return rc;
}","int hap_track_dirty_vram(struct domain *VAR_0,
                         unsigned long VAR_1,
                         unsigned int VAR_2,
                         VAR_3(void) VAR_4)
{
    long VAR_5 = 0;
    struct sh_dirty_vram *VAR_6;
    uint8_t *VAR_7 = NULL;

    if ( VAR_2 )
    {
        unsigned int VAR_8 = DIV_ROUND_UP(VAR_2, VAR_9);

        VAR_5 = -VAR_10;
        VAR_7 = vzalloc(VAR_8);
        if ( !VAR_7 )
            goto out;

        paging_lock(VAR_0);

        VAR_6 = VAR_0->arch.hvm.dirty_vram;
        if ( !VAR_6 )
        {
            VAR_5 = -VAR_10;
            if ( (VAR_6 = xzalloc(struct sh_dirty_vram)) == NULL )
            {
                paging_unlock(VAR_0);
                goto out;
            }

            VAR_0->arch.hvm.dirty_vram = VAR_6;
        }

        if ( VAR_1 != VAR_6->begin_pfn ||
             VAR_1 + VAR_2 != VAR_6->end_pfn )
        {
            unsigned long VAR_11 = VAR_6->begin_pfn;
            unsigned long VAR_12 = VAR_6->end_pfn;

            VAR_6->begin_pfn = VAR_1;
            VAR_6->end_pfn = VAR_1 + VAR_2;

            paging_unlock(VAR_0);

            domain_pause(VAR_0);
            p2m_enable_hardware_log_dirty(VAR_0);
            domain_unpause(VAR_0);

            if ( VAR_12 > VAR_11 )
                p2m_change_type_range(VAR_0, VAR_11, VAR_12,
                                      VAR_13, VAR_14);

            /* COMMENT_0 */
                                                                              
                                                                             
               
            p2m_change_type_range(VAR_0, VAR_1, VAR_1 + VAR_2,
                                  VAR_14, VAR_13);

            guest_flush_tlb_mask(VAR_0, VAR_0->dirty_cpumask);

            memset(VAR_7, 0xff, VAR_8); /* COMMENT_4 */
        }
        else
        {
            paging_unlock(VAR_0);

            domain_pause(VAR_0);

            /* COMMENT_5 */
            p2m_flush_hardware_cached_dirty(VAR_0);

            /* COMMENT_6 */
            paging_log_dirty_range(VAR_0, VAR_1, VAR_2, VAR_7);

            domain_unpause(VAR_0);
        }

        VAR_5 = -VAR_15;
        if ( copy_to_guest(VAR_4, VAR_7, VAR_8) == 0 )
            VAR_5 = 0;
    }
    else
    {
        paging_lock(VAR_0);

        VAR_6 = VAR_0->arch.hvm.dirty_vram;
        if ( VAR_6 )
        {
            /* COMMENT_7 */
                                                                
                                 
               
            VAR_1 = VAR_6->begin_pfn;
            VAR_2 = VAR_6->end_pfn - VAR_6->begin_pfn;
            xfree(VAR_6);
            VAR_0->arch.hvm.dirty_vram = NULL;
        }

        paging_unlock(VAR_0);

        if ( VAR_2 )
            p2m_change_type_range(VAR_0, VAR_1, VAR_1 + VAR_2,
                                  VAR_13, VAR_14);
    }
out:
    vfree(VAR_7);

    return VAR_5;
}",,"--- func_before
+++ func_after
@@ -10,13 +10,6 @@
     if ( nr_frames )
     {
         unsigned int size = DIV_ROUND_UP(nr_frames, BITS_PER_BYTE);
-
-        if ( !paging_mode_log_dirty(d) )
-        {
-            rc = paging_log_dirty_enable(d, false);
-            if ( rc )
-                goto out;
-        }
 
         rc = -ENOMEM;
         dirty_bitmap = vzalloc(size);
@@ -48,6 +41,10 @@
             dirty_vram->end_pfn = begin_pfn + nr_frames;
 
             paging_unlock(d);
+
+            domain_pause(d);
+            p2m_enable_hardware_log_dirty(d);
+            domain_unpause(d);
 
             if ( oend > ostart )
                 p2m_change_type_range(d, ostart, oend,","{'deleted_lines': ['', '        if ( !paging_mode_log_dirty(d) )', '        {', '            rc = paging_log_dirty_enable(d, false);', '            if ( rc )', '                goto out;', '        }'], 'added_lines': ['', '            domain_pause(d);', '            p2m_enable_hardware_log_dirty(d);', '            domain_unpause(d);']}",True,"Racy interactions between dirty vram tracking and paging log dirty hypercalls Activation of log dirty mode done by XEN_DMOP_track_dirty_vram (was named HVMOP_track_dirty_vram before Xen 4.9) is racy with ongoing log dirty hypercalls. A suitably timed call to XEN_DMOP_track_dirty_vram can enable log dirty while another CPU is still in the process of tearing down the structures related to a previously enabled log dirty mode (XEN_DOMCTL_SHADOW_OP_OFF). This is due to lack of mutually exclusive locking between both operations and can lead to entries being added in already freed slots, resulting in a memory leak.",5.6,MEDIUM,1,test,2022-02-23T08:40:40Z,4
CVE-2022-0695,['CWE-400'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,radareorg/radare2,"Fix DoS in PE/QNX/DYLDCACHE/PSX parsers ##crash

* Reported by lazymio
* Reproducer: AAA4AAAAAB4=",634b886e84a5c568d243e744becc6b3223e089cf,https://github.com/radareorg/radare2/commit/634b886e84a5c568d243e744becc6b3223e089cf,libr/bin/p/bin_psxexe.c,entries,"static RList* entries(RBinFile* bf) {
RList* ret = NULL;
RBinAddr* addr = NULL;
psxexe_header psxheader;
if (!(ret = r_list_new ())) {
return NULL;
}
if (!(addr = R_NEW0 (RBinAddr))) {
r_list_free (ret);
return NULL;
}
if (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, ""8c17i"", 1) < sizeof (psxexe_header)) {
eprintf (""PSXEXE Header truncated\n"");
r_list_free (ret);
free (addr);
return NULL;
}
addr->paddr = (psxheader.pc0 - psxheader.t_addr) + PSXEXE_TEXTSECTION_OFFSET;
addr->vaddr = psxheader.pc0;
r_list_append (ret, addr);
return ret;
}","static RList* entries(RBinFile* VAR_0) {
RList* VAR_1 = NULL;
RBinAddr* VAR_2 = NULL;
psxexe_header VAR_3;
if (!(VAR_1 = r_list_new ())) {
return NULL;
}
if (!(VAR_2 = R_NEW0 (RBinAddr))) {
r_list_free (VAR_1);
return NULL;
}
if (r_buf_fread_at (VAR_0->buf, 0, (ut8*)&VAR_3, ""8c17i"", 1) < sizeof (psxexe_header)) {
eprintf (""PSXEXE Header truncated\n"");
r_list_free (VAR_1);
free (VAR_2);
return NULL;
}
VAR_2->paddr = (VAR_3.pc0 - VAR_3.t_addr) + VAR_4;
VAR_2->vaddr = VAR_3.pc0;
r_list_append (VAR_1, VAR_2);
return VAR_1;
}",radareorg/radare2/634b886e84a5c568d243e744becc6b3223e089cf/bin_psxexe.c/vul/before/1.json,"static RList* entries(RBinFile* bf) {
	RList* ret = NULL;
	RBinAddr* addr = NULL;
	psxexe_header psxheader;

	if (!(ret = r_list_new ())) {
		return NULL;
	}

	if (!(addr = R_NEW0 (RBinAddr))) {
		r_list_free (ret);
		return NULL;
	}

	if (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, ""8c17i"", 1) != sizeof (psxexe_header)) {
		eprintf (""PSXEXE Header truncated\n"");
		r_list_free (ret);
		free (addr);
		return NULL;
	}

	addr->paddr = (psxheader.pc0 - psxheader.t_addr) + PSXEXE_TEXTSECTION_OFFSET;
	addr->vaddr = psxheader.pc0;

	r_list_append (ret, addr);
	return ret;
}","static RList* entries(RBinFile* VAR_0) {
	RList* VAR_1 = NULL;
	RBinAddr* VAR_2 = NULL;
	psxexe_header VAR_3;

	if (!(VAR_1 = r_list_new ())) {
		return NULL;
	}

	if (!(VAR_2 = R_NEW0 (RBinAddr))) {
		r_list_free (VAR_1);
		return NULL;
	}

	if (r_buf_fread_at (VAR_0->buf, 0, (ut8*)&VAR_3, ""8c17i"", 1) != sizeof (psxexe_header)) {
		eprintf (""PSXEXE Header truncated\n"");
		r_list_free (VAR_1);
		free (VAR_2);
		return NULL;
	}

	VAR_2->paddr = (VAR_3.pc0 - VAR_3.t_addr) + VAR_4;
	VAR_2->vaddr = VAR_3.pc0;

	r_list_append (VAR_1, VAR_2);
	return VAR_1;
}",radareorg/radare2/634b886e84a5c568d243e744becc6b3223e089cf/bin_psxexe.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -12,7 +12,7 @@
 		return NULL;
 	}
 
-	if (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, ""8c17i"", 1) < sizeof (psxexe_header)) {
+	if (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, ""8c17i"", 1) != sizeof (psxexe_header)) {
 		eprintf (""PSXEXE Header truncated\n"");
 		r_list_free (ret);
 		free (addr);","{'deleted_lines': ['\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, ""8c17i"", 1) < sizeof (psxexe_header)) {'], 'added_lines': ['\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, ""8c17i"", 1) != sizeof (psxexe_header)) {']}",True,Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4.,5.5,MEDIUM,1,test,2022-02-23T21:54:54Z,4
CVE-2022-0695,['CWE-400'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,radareorg/radare2,"Fix DoS in PE/QNX/DYLDCACHE/PSX parsers ##crash

* Reported by lazymio
* Reproducer: AAA4AAAAAB4=",634b886e84a5c568d243e744becc6b3223e089cf,https://github.com/radareorg/radare2/commit/634b886e84a5c568d243e744becc6b3223e089cf,libr/bin/p/bin_psxexe.c,sections,"static RList* sections(RBinFile* bf) {
RList* ret = NULL;
RBinSection* sect = NULL;
psxexe_header psxheader = {0};
ut64 sz = 0;
if (!(ret = r_list_new ())) {
return NULL;
}
if (!(sect = R_NEW0 (RBinSection))) {
r_list_free (ret);
return NULL;
}
if (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, ""8c17i"", 1) < sizeof (psxexe_header)) {
eprintf (""Truncated Header\n"");
free (sect);
r_list_free (ret);
return NULL;
}
sz = r_buf_size (bf->buf);
sect->name = strdup (""TEXT"");
sect->paddr = PSXEXE_TEXTSECTION_OFFSET;
sect->size = sz - PSXEXE_TEXTSECTION_OFFSET;
sect->vaddr = psxheader.t_addr;
sect->vsize = psxheader.t_size;
sect->perm = R_PERM_RX;
sect->add = true;
sect->has_strings = true;
r_list_append (ret, sect);
return ret;
}","static RList* sections(RBinFile* VAR_0) {
RList* VAR_1 = NULL;
RBinSection* VAR_2 = NULL;
psxexe_header VAR_3 = {0};
ut64 VAR_4 = 0;
if (!(VAR_1 = r_list_new ())) {
return NULL;
}
if (!(VAR_2 = R_NEW0 (RBinSection))) {
r_list_free (VAR_1);
return NULL;
}
if (r_buf_fread_at (VAR_0->buf, 0, (ut8*)&VAR_3, ""8c17i"", 1) < sizeof (psxexe_header)) {
eprintf (""Truncated Header\n"");
free (VAR_2);
r_list_free (VAR_1);
return NULL;
}
VAR_4 = r_buf_size (VAR_0->buf);
VAR_2->name = strdup (""TEXT"");
VAR_2->paddr = VAR_5;
VAR_2->size = VAR_4 - VAR_5;
VAR_2->vaddr = VAR_3.t_addr;
VAR_2->vsize = VAR_3.t_size;
VAR_2->perm = VAR_6;
VAR_2->add = true;
VAR_2->has_strings = true;
r_list_append (VAR_1, VAR_2);
return VAR_1;
}",radareorg/radare2/634b886e84a5c568d243e744becc6b3223e089cf/bin_psxexe.c/vul/before/0.json,"static RList* sections(RBinFile* bf) {
	RList* ret = NULL;
	RBinSection* sect = NULL;
	psxexe_header psxheader = {0};
	ut64 sz = 0;

	if (!(ret = r_list_new ())) {
		return NULL;
	}

	if (!(sect = R_NEW0 (RBinSection))) {
		r_list_free (ret);
		return NULL;
	}

	if (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, ""8c17i"", 1) != sizeof (psxexe_header)) {
		eprintf (""Truncated Header\n"");
		free (sect);
		r_list_free (ret);
		return NULL;
	}

	sz = r_buf_size (bf->buf);

	sect->name = strdup (""TEXT"");
	sect->paddr = PSXEXE_TEXTSECTION_OFFSET;
	sect->size = sz - PSXEXE_TEXTSECTION_OFFSET;
	sect->vaddr = psxheader.t_addr;
	sect->vsize = psxheader.t_size;
	sect->perm = R_PERM_RX;
	sect->add = true;
	sect->has_strings = true;

	r_list_append (ret, sect);
	return ret;
}","static RList* sections(RBinFile* VAR_0) {
	RList* VAR_1 = NULL;
	RBinSection* VAR_2 = NULL;
	psxexe_header VAR_3 = {0};
	ut64 VAR_4 = 0;

	if (!(VAR_1 = r_list_new ())) {
		return NULL;
	}

	if (!(VAR_2 = R_NEW0 (RBinSection))) {
		r_list_free (VAR_1);
		return NULL;
	}

	if (r_buf_fread_at (VAR_0->buf, 0, (ut8*)&VAR_3, ""8c17i"", 1) != sizeof (psxexe_header)) {
		eprintf (""Truncated Header\n"");
		free (VAR_2);
		r_list_free (VAR_1);
		return NULL;
	}

	VAR_4 = r_buf_size (VAR_0->buf);

	VAR_2->name = strdup (""TEXT"");
	VAR_2->paddr = VAR_5;
	VAR_2->size = VAR_4 - VAR_5;
	VAR_2->vaddr = VAR_3.t_addr;
	VAR_2->vsize = VAR_3.t_size;
	VAR_2->perm = VAR_6;
	VAR_2->add = true;
	VAR_2->has_strings = true;

	r_list_append (VAR_1, VAR_2);
	return VAR_1;
}",radareorg/radare2/634b886e84a5c568d243e744becc6b3223e089cf/bin_psxexe.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -13,7 +13,7 @@
 		return NULL;
 	}
 
-	if (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, ""8c17i"", 1) < sizeof (psxexe_header)) {
+	if (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, ""8c17i"", 1) != sizeof (psxexe_header)) {
 		eprintf (""Truncated Header\n"");
 		free (sect);
 		r_list_free (ret);","{'deleted_lines': ['\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, ""8c17i"", 1) < sizeof (psxexe_header)) {'], 'added_lines': ['\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, ""8c17i"", 1) != sizeof (psxexe_header)) {']}",True,Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4.,5.5,MEDIUM,1,test,2022-02-23T21:54:54Z,4
CVE-2022-0695,['CWE-400'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,radareorg/radare2,"Fix DoS in PE/QNX/DYLDCACHE/PSX parsers ##crash

* Reported by lazymio
* Reproducer: AAA4AAAAAB4=",634b886e84a5c568d243e744becc6b3223e089cf,https://github.com/radareorg/radare2/commit/634b886e84a5c568d243e744becc6b3223e089cf,libr/util/buf.c,buf_format,"static st64 buf_format(RBuffer *dst, RBuffer *src, const char *fmt, int n) {
st64 res = 0;
int i;
for (i = 0; i < n; i++) {
int j;
int m = 1;
int tsize = 2;
bool bigendian = true;
for (j = 0; fmt[j]; j++) {
switch (fmt[j]) {
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
if (m == 1) {
m = r_num_get (NULL, &fmt[j]);
}
continue;
case 's': tsize = 2; bigendian = false; break;
case 'S': tsize = 2; bigendian = true; break;
case 'i': tsize = 4; bigendian = false; break;
case 'I': tsize = 4; bigendian = true; break;
case 'l': tsize = 8; bigendian = false; break;
case 'L': tsize = 8; bigendian = true; break;
case 'c': tsize = 1; bigendian = false; break;
default: return -1;
}
int k;
for (k = 0; k < m; k++) {
ut8 tmp[sizeof (ut64)];
ut8 d1;
ut16 d2;
ut32 d3;
ut64 d4;
st64 r = r_buf_read (src, tmp, tsize);
if (r < tsize) {
return -1;
}
switch (tsize) {
case 1:
d1 = r_read_ble8 (tmp);
r = r_buf_write (dst, (ut8 *)&d1, 1);
break;
case 2:
d2 = r_read_ble16 (tmp, bigendian);
r = r_buf_write (dst, (ut8 *)&d2, 2);
break;
case 4:
d3 = r_read_ble32 (tmp, bigendian);
r = r_buf_write (dst, (ut8 *)&d3, 4);
break;
case 8:
d4 = r_read_ble64 (tmp, bigendian);
r = r_buf_write (dst, (ut8 *)&d4, 8);
break;
}
if (r < 0) {
return -1;
}
res += r;
}
m = 1;
}
}
return res;
}","static st64 buf_format(RBuffer *VAR_0, RBuffer *VAR_1, const char *VAR_2, int VAR_3) {
st64 VAR_4 = 0;
int VAR_5;
for (VAR_5 = 0; VAR_5 < VAR_3; VAR_5++) {
int VAR_6;
int VAR_7 = 1;
int VAR_8 = 2;
bool VAR_9 = true;
for (VAR_6 = 0; VAR_2[VAR_6]; VAR_6++) {
switch (VAR_2[VAR_6]) {
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
if (VAR_7 == 1) {
VAR_7 = r_num_get (NULL, &VAR_2[VAR_6]);
}
continue;
case 's': VAR_8 = 2; VAR_9 = false; break;
case 'S': VAR_8 = 2; VAR_9 = true; break;
case 'i': VAR_8 = 4; VAR_9 = false; break;
case 'I': VAR_8 = 4; VAR_9 = true; break;
case 'l': VAR_8 = 8; VAR_9 = false; break;
case 'L': VAR_8 = 8; VAR_9 = true; break;
case 'c': VAR_8 = 1; VAR_9 = false; break;
default: return -1;
}
int VAR_10;
for (VAR_10 = 0; VAR_10 < VAR_7; VAR_10++) {
ut8 VAR_11[sizeof (VAR_12)];
ut8 VAR_13;
ut16 VAR_14;
ut32 VAR_15;
ut64 VAR_16;
st64 VAR_17 = r_buf_read (VAR_1, VAR_11, VAR_8);
if (VAR_17 < VAR_8) {
return -1;
}
switch (VAR_8) {
case 1:
VAR_13 = r_read_ble8 (VAR_11);
VAR_17 = r_buf_write (VAR_0, (ut8 *)&VAR_13, 1);
break;
case 2:
VAR_14 = r_read_ble16 (VAR_11, VAR_9);
VAR_17 = r_buf_write (VAR_0, (ut8 *)&VAR_14, 2);
break;
case 4:
VAR_15 = r_read_ble32 (VAR_11, VAR_9);
VAR_17 = r_buf_write (VAR_0, (ut8 *)&VAR_15, 4);
break;
case 8:
VAR_16 = r_read_ble64 (VAR_11, VAR_9);
VAR_17 = r_buf_write (VAR_0, (ut8 *)&VAR_16, 8);
break;
}
if (VAR_17 < 0) {
return -1;
}
VAR_4 += VAR_17;
}
VAR_7 = 1;
}
}
return VAR_4;
}",radareorg/radare2/634b886e84a5c568d243e744becc6b3223e089cf/buf.c/vul/before/2.json,"static st64 buf_format(RBuffer *dst, RBuffer *src, const char *fmt, int n) {
	st64 res = 0;
	int i;
	for (i = 0; i < n; i++) {
		int j;
		int m = 1;
		int tsize = 2;
		bool bigendian = true;

		for (j = 0; fmt[j]; j++) {
			switch (fmt[j]) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				if (m == 1) {
					m = r_num_get (NULL, &fmt[j]);
				}
				continue;
			case 's': tsize = 2; bigendian = false; break;
			case 'S': tsize = 2; bigendian = true; break;
			case 'i': tsize = 4; bigendian = false; break;
			case 'I': tsize = 4; bigendian = true; break;
			case 'l': tsize = 8; bigendian = false; break;
			case 'L': tsize = 8; bigendian = true; break;
			case 'c': tsize = 1; bigendian = false; break;
			default: return -1;
			}

			int k;
			for (k = 0; k < m; k++) {
				ut8 tmp[sizeof (ut64)];
				ut8 d1;
				ut16 d2;
				ut32 d3;
				ut64 d4;
				st64 r = r_buf_read (src, tmp, tsize);
				if (r != tsize) {
					return -1;
				}
				switch (tsize) {
				case 1:
					d1 = r_read_ble8 (tmp);
					r = r_buf_write (dst, (ut8 *)&d1, 1);
					break;
				case 2:
					d2 = r_read_ble16 (tmp, bigendian);
					r = r_buf_write (dst, (ut8 *)&d2, 2);
					break;
				case 4:
					d3 = r_read_ble32 (tmp, bigendian);
					r = r_buf_write (dst, (ut8 *)&d3, 4);
					break;
				case 8:
					d4 = r_read_ble64 (tmp, bigendian);
					r = r_buf_write (dst, (ut8 *)&d4, 8);
					break;
				}
				if (r < 0) {
					return -1;
				}
				res += r;
			}
			m = 1;
		}
	}
	return res;
}","static st64 buf_format(RBuffer *VAR_0, RBuffer *VAR_1, const char *VAR_2, int VAR_3) {
	st64 VAR_4 = 0;
	int VAR_5;
	for (VAR_5 = 0; VAR_5 < VAR_3; VAR_5++) {
		int VAR_6;
		int VAR_7 = 1;
		int VAR_8 = 2;
		bool VAR_9 = true;

		for (VAR_6 = 0; VAR_2[VAR_6]; VAR_6++) {
			switch (VAR_2[VAR_6]) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				if (VAR_7 == 1) {
					VAR_7 = r_num_get (NULL, &VAR_2[VAR_6]);
				}
				continue;
			case 's': VAR_8 = 2; VAR_9 = false; break;
			case 'S': VAR_8 = 2; VAR_9 = true; break;
			case 'i': VAR_8 = 4; VAR_9 = false; break;
			case 'I': VAR_8 = 4; VAR_9 = true; break;
			case 'l': VAR_8 = 8; VAR_9 = false; break;
			case 'L': VAR_8 = 8; VAR_9 = true; break;
			case 'c': VAR_8 = 1; VAR_9 = false; break;
			default: return -1;
			}

			int VAR_10;
			for (VAR_10 = 0; VAR_10 < VAR_7; VAR_10++) {
				ut8 VAR_11[sizeof (VAR_12)];
				ut8 VAR_13;
				ut16 VAR_14;
				ut32 VAR_15;
				ut64 VAR_16;
				st64 VAR_17 = r_buf_read (VAR_1, VAR_11, VAR_8);
				if (VAR_17 != VAR_8) {
					return -1;
				}
				switch (VAR_8) {
				case 1:
					VAR_13 = r_read_ble8 (VAR_11);
					VAR_17 = r_buf_write (VAR_0, (ut8 *)&VAR_13, 1);
					break;
				case 2:
					VAR_14 = r_read_ble16 (VAR_11, VAR_9);
					VAR_17 = r_buf_write (VAR_0, (ut8 *)&VAR_14, 2);
					break;
				case 4:
					VAR_15 = r_read_ble32 (VAR_11, VAR_9);
					VAR_17 = r_buf_write (VAR_0, (ut8 *)&VAR_15, 4);
					break;
				case 8:
					VAR_16 = r_read_ble64 (VAR_11, VAR_9);
					VAR_17 = r_buf_write (VAR_0, (ut8 *)&VAR_16, 8);
					break;
				}
				if (VAR_17 < 0) {
					return -1;
				}
				VAR_4 += VAR_17;
			}
			VAR_7 = 1;
		}
	}
	return VAR_4;
}",radareorg/radare2/634b886e84a5c568d243e744becc6b3223e089cf/buf.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -41,10 +41,9 @@
 				ut32 d3;
 				ut64 d4;
 				st64 r = r_buf_read (src, tmp, tsize);
-				if (r < tsize) {
+				if (r != tsize) {
 					return -1;
 				}
-
 				switch (tsize) {
 				case 1:
 					d1 = r_read_ble8 (tmp);","{'deleted_lines': ['\t\t\t\tif (r < tsize) {', ''], 'added_lines': ['\t\t\t\tif (r != tsize) {']}",True,Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4.,5.5,MEDIUM,1,test,2022-02-23T21:54:54Z,4
CVE-2022-0695,['CWE-400'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,radareorg/radare2,"Fix DoS in PE/QNX/DYLDCACHE/PSX parsers ##crash

* Reported by lazymio
* Reproducer: AAA4AAAAAB4=",634b886e84a5c568d243e744becc6b3223e089cf,https://github.com/radareorg/radare2/commit/634b886e84a5c568d243e744becc6b3223e089cf,libr/util/buf.c,r_buf_read_at,"R_API st64 r_buf_read_at(RBuffer *b, ut64 addr, ut8 *buf, ut64 len) {
r_return_val_if_fail (b && buf, -1);
st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
st64 r = r_buf_seek (b, addr, R_BUF_SET);
if (r < 0) {
return r;
}
r = r_buf_read (b, buf, len);
r_buf_seek (b, o_addr, R_BUF_SET);
return r;
}","R_API st64 r_buf_read_at(RBuffer *VAR_0, ut64 VAR_1, ut8 *VAR_2, ut64 VAR_3) {
r_return_val_if_fail (VAR_0 && VAR_2, -1);
st64 VAR_4 = r_buf_seek (VAR_0, 0, VAR_5);
st64 VAR_6 = r_buf_seek (VAR_0, VAR_1, VAR_7);
if (VAR_6 < 0) {
return VAR_6;
}
VAR_6 = r_buf_read (VAR_0, VAR_2, VAR_3);
r_buf_seek (VAR_0, VAR_4, VAR_7);
return VAR_6;
}",,"R_API st64 r_buf_read_at(RBuffer *b, ut64 addr, ut8 *buf, ut64 len) {
	r_return_val_if_fail (b && buf, -1);
	st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
	st64 r = r_buf_seek (b, addr, R_BUF_SET);
	if (r < 0) {
		return r;
	}
	r = r_buf_read (b, buf, len);
	r_buf_seek (b, o_addr, R_BUF_SET);
	return r;
}","R_API st64 r_buf_read_at(RBuffer *VAR_0, ut64 VAR_1, ut8 *VAR_2, ut64 VAR_3) {
	r_return_val_if_fail (VAR_0 && VAR_2, -1);
	st64 VAR_4 = r_buf_seek (VAR_0, 0, VAR_5);
	st64 VAR_6 = r_buf_seek (VAR_0, VAR_1, VAR_7);
	if (VAR_6 < 0) {
		return VAR_6;
	}
	VAR_6 = r_buf_read (VAR_0, VAR_2, VAR_3);
	r_buf_seek (VAR_0, VAR_4, VAR_7);
	return VAR_6;
}",,"--- func_before
+++ func_after
@@ -5,7 +5,6 @@
 	if (r < 0) {
 		return r;
 	}
-
 	r = r_buf_read (b, buf, len);
 	r_buf_seek (b, o_addr, R_BUF_SET);
 	return r;","{'deleted_lines': [''], 'added_lines': []}",True,Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4.,5.5,MEDIUM,1,test,2022-02-23T21:54:54Z,4
CVE-2022-0695,['CWE-400'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,radareorg/radare2,"Fix DoS in PE/QNX/DYLDCACHE/PSX parsers ##crash

* Reported by lazymio
* Reproducer: AAA4AAAAAB4=",634b886e84a5c568d243e744becc6b3223e089cf,https://github.com/radareorg/radare2/commit/634b886e84a5c568d243e744becc6b3223e089cf,libr/bin/format/pe/pe.c,bin_pe_init_metadata_hdr,"static bool bin_pe_init_metadata_hdr(RBinPEObj* pe) {
PE_(image_metadata_header) * metadata = R_NEW0 (PE_(image_metadata_header));
if (!metadata) {
return false;
}
PE_DWord metadata_directory = pe->clr_hdr? PE_(va2pa) (pe, pe->clr_hdr->MetaDataDirectoryAddress): 0;
if (!metadata_directory) {
free (metadata);
return false;
}
int rr = r_buf_fread_at (pe->b, metadata_directory,
(ut8*) metadata, pe->big_endian? ""1I2S"": ""1i2s"", 1);
if (rr < 1) {
goto fail;
}
rr = r_buf_fread_at (pe->b, metadata_directory + 8,
(ut8*) (&metadata->Reserved), pe->big_endian? ""1I"": ""1i"", 1);
if (rr < 1) {
goto fail;
}
rr = r_buf_fread_at (pe->b, metadata_directory + 12,
(ut8*) (&metadata->VersionStringLength), pe->big_endian? ""1I"": ""1i"", 1);
if (rr < 1) {
goto fail;
}
eprintf (""Metadata Signature: 0x%""PFMT64x"" 0x%""PFMT64x"" %d\n"",
(ut64)metadata_directory, (ut64)metadata->Signature, (int)metadata->VersionStringLength);
int len = metadata->VersionStringLength; if (len > 0) {
metadata->VersionString = calloc (1, len + 1);
if (!metadata->VersionString) {
goto fail;
}
rr = r_buf_read_at (pe->b, metadata_directory + 16, (ut8*)(metadata->VersionString), len);
if (rr != len) {
eprintf (""Warning: read (metadata header) - cannot parse version string\n"");
free (metadata->VersionString);
free (metadata);
return 0;
}
eprintf ("".NET Version: %s\n"", metadata->VersionString);
}
rr = r_buf_fread_at (pe->b, metadata_directory + 16 + metadata->VersionStringLength,
(ut8*) (&metadata->Flags), pe->big_endian? ""2S"": ""2s"", 1);
if (rr < 1) {
goto fail;
}
eprintf (""Number of Metadata Streams: %d\n"", metadata->NumberOfStreams);
pe->metadata_header = metadata;
int stream_addr = metadata_directory + 20 + metadata->VersionStringLength;
PE_(image_metadata_stream) * stream;
PE_(image_metadata_stream) **streams = calloc (sizeof (PE_(image_metadata_stream)*), metadata->NumberOfStreams);
if (!streams) {
goto fail;
}
int count;
for (count = 0; count < metadata->NumberOfStreams; count++) {
stream = R_NEW0 (PE_(image_metadata_stream));
if (!stream) {
free (streams);
goto fail;
}
if (r_buf_size (pe->b) < (stream_addr + 8 + MAX_METADATA_STRING_LENGTH)) {
eprintf (""Truncated\n"");
free (stream);
free (streams);
goto fail;
}
if (r_buf_fread_at (pe->b, stream_addr, (ut8*) stream, pe->big_endian? ""2I"": ""2i"", 1) < 1) {
free (stream);
free (streams);
goto fail;
}
eprintf (""DirectoryAddress: %x Size: %x\n"", stream->Offset, stream->Size);
char* stream_name = calloc (1, MAX_METADATA_STRING_LENGTH + 1);
if (!stream_name) {
free (stream);
free (streams);
goto fail;
}
int c = bin_pe_read_metadata_string (stream_name, pe->b, stream_addr + 8);
if (c == 0) {
free (stream_name);
free (stream);
free (streams);
goto fail;
}
eprintf (""Stream name: %s %d\n"", stream_name, c);
stream->Name = stream_name;
streams[count] = stream;
stream_addr += 8 + c;
}
pe->streams = streams;
return true;
fail:
eprintf (""Warning: read (metadata header)\n"");
free (metadata);
return false;
}","static bool bin_pe_init_metadata_hdr(RBinPEObj* VAR_0) {
VAR_1(image_metadata_header) * VAR_2 = R_NEW0 (VAR_1(image_metadata_header));
if (!VAR_2) {
return false;
}
PE_DWord VAR_3 = VAR_0->clr_hdr? VAR_1(VAR_4) (VAR_0, VAR_0->clr_hdr->MetaDataDirectoryAddress): 0;
if (!VAR_3) {
free (VAR_2);
return false;
}
int VAR_5 = r_buf_fread_at (VAR_0->b, VAR_3,
(ut8*) VAR_2, VAR_0->big_endian? ""1I2S"": ""1i2s"", 1);
if (VAR_5 < 1) {
goto fail;
}
VAR_5 = r_buf_fread_at (VAR_0->b, VAR_3 + 8,
(ut8*) (&VAR_2->Reserved), VAR_0->big_endian? ""1I"": ""1i"", 1);
if (VAR_5 < 1) {
goto fail;
}
VAR_5 = r_buf_fread_at (VAR_0->b, VAR_3 + 12,
(ut8*) (&VAR_2->VersionStringLength), VAR_0->big_endian? ""1I"": ""1i"", 1);
if (VAR_5 < 1) {
goto fail;
}
eprintf (""Metadata Signature: 0x%""VAR_6"" 0x%""VAR_6"" %d\n"",
(ut64)VAR_3, (ut64)VAR_2->Signature, (int)VAR_2->VersionStringLength);
int VAR_7 = VAR_2->VersionStringLength; 
if (VAR_7 > 0) {
VAR_2->VersionString = calloc (1, VAR_7 + 1);
if (!VAR_2->VersionString) {
goto fail;
}
VAR_5 = r_buf_read_at (VAR_0->b, VAR_3 + 16, (ut8*)(VAR_2->VersionString), VAR_7);
if (VAR_5 != VAR_7) {
eprintf (""Warning: read (metadata header) - cannot parse version string\n"");
free (VAR_2->VersionString);
free (VAR_2);
return 0;
}
eprintf ("".NET Version: %s\n"", VAR_2->VersionString);
}
VAR_5 = r_buf_fread_at (VAR_0->b, VAR_3 + 16 + VAR_2->VersionStringLength,
(ut8*) (&VAR_2->Flags), VAR_0->big_endian? ""2S"": ""2s"", 1);
if (VAR_5 < 1) {
goto fail;
}
eprintf (""Number of Metadata Streams: %d\n"", VAR_2->NumberOfStreams);
VAR_0->metadata_header = VAR_2;
int VAR_8 = VAR_3 + 20 + VAR_2->VersionStringLength;
VAR_1(VAR_9) * VAR_10;
VAR_1(image_metadata_stream) **VAR_11 = calloc (sizeof (VAR_1(image_metadata_stream)*), VAR_2->NumberOfStreams);
if (!VAR_11) {
goto fail;
}
int VAR_12;
for (VAR_12 = 0; VAR_12 < VAR_2->NumberOfStreams; VAR_12++) {
VAR_10 = R_NEW0 (VAR_1(image_metadata_stream));
if (!VAR_10) {
free (VAR_11);
goto fail;
}
if (r_buf_size (VAR_0->b) < (VAR_8 + 8 + VAR_13)) {
eprintf (""Truncated\n"");
free (VAR_10);
free (VAR_11);
goto fail;
}
if (r_buf_fread_at (VAR_0->b, VAR_8, (ut8*) VAR_10, VAR_0->big_endian? ""2I"": ""2i"", 1) < 1) {
free (VAR_10);
free (VAR_11);
goto fail;
}
eprintf (""DirectoryAddress: %x Size: %x\n"", VAR_10->Offset, VAR_10->Size);
char* VAR_14 = calloc (1, VAR_13 + 1);
if (!VAR_14) {
free (VAR_10);
free (VAR_11);
goto fail;
}
int VAR_15 = bin_pe_read_metadata_string (VAR_14, VAR_0->b, VAR_8 + 8);
if (VAR_15 == 0) {
free (VAR_14);
free (VAR_10);
free (VAR_11);
goto fail;
}
eprintf (""Stream name: %s %d\n"", VAR_14, VAR_15);
VAR_10->Name = VAR_14;
VAR_11[VAR_12] = VAR_10;
VAR_8 += 8 + VAR_15;
}
VAR_0->streams = VAR_11;
return true;
fail:
eprintf (""Warning: read (metadata header)\n"");
free (VAR_2);
return false;
}",radareorg/radare2/634b886e84a5c568d243e744becc6b3223e089cf/pe.c/vul/before/1.json,"static bool bin_pe_init_metadata_hdr(RBinPEObj* pe) {
	PE_(image_metadata_header) * metadata = R_NEW0 (PE_(image_metadata_header));
	if (!metadata) {
		return false;
	}
	PE_DWord metadata_directory = pe->clr_hdr? PE_(va2pa) (pe, pe->clr_hdr->MetaDataDirectoryAddress): 0;
	if (!metadata_directory) {
		free (metadata);
		return false;
	}
	int rr = r_buf_fread_at (pe->b, metadata_directory,
		(ut8*) metadata, pe->big_endian? ""1I2S"": ""1i2s"", 1);
	if (rr < 1) {
		goto fail;
	}

	rr = r_buf_fread_at (pe->b, metadata_directory + 8,
		(ut8*) (&metadata->Reserved), pe->big_endian? ""1I"": ""1i"", 1);
	if (rr < 1) {
		goto fail;
	}

	rr = r_buf_fread_at (pe->b, metadata_directory + 12,
		(ut8*) (&metadata->VersionStringLength), pe->big_endian? ""1I"": ""1i"", 1);
	if (rr < 1) {
		goto fail;
	}

	eprintf (""Metadata Signature: 0x%""PFMT64x"" 0x%""PFMT64x"" %d\n"",
		(ut64)metadata_directory, (ut64)metadata->Signature, (int)metadata->VersionStringLength);

	// read the version string
	int len = metadata->VersionStringLength; // XXX: dont trust this length
	if (len > 0) {
		metadata->VersionString = calloc (1, len + 1);
		if (!metadata->VersionString) {
			goto fail;
		}

		rr = r_buf_read_at (pe->b, metadata_directory + 16, (ut8*)(metadata->VersionString), len);
		if (rr != len) {
			eprintf (""Warning: read (metadata header) - cannot parse version string\n"");
			free (metadata->VersionString);
			free (metadata);
			return 0;
		}
		eprintf ("".NET Version: %s\n"", metadata->VersionString);
	}

	// read the header after the string
	rr = r_buf_fread_at (pe->b, metadata_directory + 16 + metadata->VersionStringLength,
		(ut8*) (&metadata->Flags), pe->big_endian? ""2S"": ""2s"", 1);
	if (rr < 1) {
		goto fail;
	}

	eprintf (""Number of Metadata Streams: %d\n"", metadata->NumberOfStreams);
	pe->metadata_header = metadata;


	// read metadata streams
	int stream_addr = metadata_directory + 20 + metadata->VersionStringLength;
	PE_(image_metadata_stream) * stream;
	PE_(image_metadata_stream) **streams = calloc (sizeof (PE_(image_metadata_stream)*), metadata->NumberOfStreams);
	if (!streams) {
		goto fail;
	}
	int count;
	for (count = 0; count < metadata->NumberOfStreams; count++) {
		stream = R_NEW0 (PE_(image_metadata_stream));
		if (!stream) {
			free (streams);
			goto fail;
		}
		if (r_buf_size (pe->b) < (stream_addr + 8 + MAX_METADATA_STRING_LENGTH)) {
			eprintf (""Truncated\n"");
			free (stream);
			free (streams);
			goto fail;
		}
		if (r_buf_fread_at (pe->b, stream_addr, (ut8*) stream, pe->big_endian? ""2I"": ""2i"", 1) < 1) {
			free (stream);
			free (streams);
			goto fail;
		}
		eprintf (""DirectoryAddress: %x Size: %x\n"", stream->Offset, stream->Size);
		char* stream_name = calloc (1, MAX_METADATA_STRING_LENGTH + 1);

		if (!stream_name) {
			free (stream);
			free (streams);
			goto fail;
		}

		int c = bin_pe_read_metadata_string (stream_name, pe->b, stream_addr + 8);
		if (c == 0) {
			free (stream_name);
			free (stream);
			free (streams);
			goto fail;
		}
		eprintf (""Stream name: %s %d\n"", stream_name, c);
		stream->Name = stream_name;
		streams[count] = stream;
		stream_addr += 8 + c;
	}
	pe->streams = streams;
	return true;
fail:
	eprintf (""Warning: read (metadata header)\n"");
	free (metadata);
	return false;
}","static bool bin_pe_init_metadata_hdr(RBinPEObj* VAR_0) {
	VAR_1(image_metadata_header) * VAR_2 = R_NEW0 (VAR_1(image_metadata_header));
	if (!VAR_2) {
		return false;
	}
	PE_DWord VAR_3 = VAR_0->clr_hdr? VAR_1(VAR_4) (VAR_0, VAR_0->clr_hdr->MetaDataDirectoryAddress): 0;
	if (!VAR_3) {
		free (VAR_2);
		return false;
	}
	int VAR_5 = r_buf_fread_at (VAR_0->b, VAR_3,
		(ut8*) VAR_2, VAR_0->big_endian? ""1I2S"": ""1i2s"", 1);
	if (VAR_5 < 1) {
		goto fail;
	}

	VAR_5 = r_buf_fread_at (VAR_0->b, VAR_3 + 8,
		(ut8*) (&VAR_2->Reserved), VAR_0->big_endian? ""1I"": ""1i"", 1);
	if (VAR_5 < 1) {
		goto fail;
	}

	VAR_5 = r_buf_fread_at (VAR_0->b, VAR_3 + 12,
		(ut8*) (&VAR_2->VersionStringLength), VAR_0->big_endian? ""1I"": ""1i"", 1);
	if (VAR_5 < 1) {
		goto fail;
	}

	eprintf (""Metadata Signature: 0x%""VAR_6"" 0x%""VAR_6"" %d\n"",
		(ut64)VAR_3, (ut64)VAR_2->Signature, (int)VAR_2->VersionStringLength);

	/* COMMENT_0 */
	int VAR_7 = VAR_2->VersionStringLength; /* COMMENT_1 */
	if (VAR_7 > 0) {
		VAR_2->VersionString = calloc (1, VAR_7 + 1);
		if (!VAR_2->VersionString) {
			goto fail;
		}

		VAR_5 = r_buf_read_at (VAR_0->b, VAR_3 + 16, (ut8*)(VAR_2->VersionString), VAR_7);
		if (VAR_5 != VAR_7) {
			eprintf (""Warning: read (metadata header) - cannot parse version string\n"");
			free (VAR_2->VersionString);
			free (VAR_2);
			return 0;
		}
		eprintf ("".NET Version: %s\n"", VAR_2->VersionString);
	}

	/* COMMENT_2 */
	VAR_5 = r_buf_fread_at (VAR_0->b, VAR_3 + 16 + VAR_2->VersionStringLength,
		(ut8*) (&VAR_2->Flags), VAR_0->big_endian? ""2S"": ""2s"", 1);
	if (VAR_5 < 1) {
		goto fail;
	}

	eprintf (""Number of Metadata Streams: %d\n"", VAR_2->NumberOfStreams);
	VAR_0->metadata_header = VAR_2;


	/* COMMENT_3 */
	int VAR_8 = VAR_3 + 20 + VAR_2->VersionStringLength;
	VAR_1(VAR_9) * VAR_10;
	VAR_1(image_metadata_stream) **VAR_11 = calloc (sizeof (VAR_1(image_metadata_stream)*), VAR_2->NumberOfStreams);
	if (!VAR_11) {
		goto fail;
	}
	int VAR_12;
	for (VAR_12 = 0; VAR_12 < VAR_2->NumberOfStreams; VAR_12++) {
		VAR_10 = R_NEW0 (VAR_1(image_metadata_stream));
		if (!VAR_10) {
			free (VAR_11);
			goto fail;
		}
		if (r_buf_size (VAR_0->b) < (VAR_8 + 8 + VAR_13)) {
			eprintf (""Truncated\n"");
			free (VAR_10);
			free (VAR_11);
			goto fail;
		}
		if (r_buf_fread_at (VAR_0->b, VAR_8, (ut8*) VAR_10, VAR_0->big_endian? ""2I"": ""2i"", 1) < 1) {
			free (VAR_10);
			free (VAR_11);
			goto fail;
		}
		eprintf (""DirectoryAddress: %x Size: %x\n"", VAR_10->Offset, VAR_10->Size);
		char* VAR_14 = calloc (1, VAR_13 + 1);

		if (!VAR_14) {
			free (VAR_10);
			free (VAR_11);
			goto fail;
		}

		int VAR_15 = bin_pe_read_metadata_string (VAR_14, VAR_0->b, VAR_8 + 8);
		if (VAR_15 == 0) {
			free (VAR_14);
			free (VAR_10);
			free (VAR_11);
			goto fail;
		}
		eprintf (""Stream name: %s %d\n"", VAR_14, VAR_15);
		VAR_10->Name = VAR_14;
		VAR_11[VAR_12] = VAR_10;
		VAR_8 += 8 + VAR_15;
	}
	VAR_0->streams = VAR_11;
	return true;
fail:
	eprintf (""Warning: read (metadata header)\n"");
	free (VAR_2);
	return false;
}",radareorg/radare2/634b886e84a5c568d243e744becc6b3223e089cf/pe.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -50,7 +50,6 @@
 	// read the header after the string
 	rr = r_buf_fread_at (pe->b, metadata_directory + 16 + metadata->VersionStringLength,
 		(ut8*) (&metadata->Flags), pe->big_endian? ""2S"": ""2s"", 1);
-
 	if (rr < 1) {
 		goto fail;
 	}","{'deleted_lines': [''], 'added_lines': []}",True,Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4.,5.5,MEDIUM,1,test,2022-02-23T21:54:54Z,4
CVE-2022-0695,['CWE-400'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,radareorg/radare2,"Fix DoS in PE/QNX/DYLDCACHE/PSX parsers ##crash

* Reported by lazymio
* Reproducer: AAA4AAAAAB4=",634b886e84a5c568d243e744becc6b3223e089cf,https://github.com/radareorg/radare2/commit/634b886e84a5c568d243e744becc6b3223e089cf,libr/bin/p/bin_qnx.c,lmf_header_load,"static int lmf_header_load(lmf_header *lmfh, RBuffer *buf, Sdb *db) {
if (r_buf_size (buf) < sizeof (lmf_header)) {
return false;
}
if (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, ""iiiiiiiicccciiiicc"", 1) < QNX_HDR_SIZE) {
return false;
}
r_strf_buffer (32);
sdb_set (db, ""qnx.version"", r_strf (""0x%xH"", lmfh->version), 0);
sdb_set (db, ""qnx.cflags"", r_strf (""0x%xH"", lmfh->cflags), 0);
sdb_set (db, ""qnx.cpu"", r_strf (""0x%xH"", lmfh->cpu), 0);
sdb_set (db, ""qnx.fpu"", r_strf (""0x%xH"", lmfh->fpu), 0);
sdb_set (db, ""qnx.code_index"", r_strf (""0x%x"", lmfh->code_index), 0);
sdb_set (db, ""qnx.stack_index"", r_strf (""0x%x"", lmfh->stack_index), 0);
sdb_set (db, ""qnx.heap_index"", r_strf (""0x%x"", lmfh->heap_index), 0);
sdb_set (db, ""qnx.argv_index"", r_strf (""0x%x"", lmfh->argv_index), 0);
sdb_set (db, ""qnx.code_offset"", r_strf (""0x%x"", lmfh->code_offset), 0);
sdb_set (db, ""qnx.stack_nbytes"", r_strf (""0x%x"", lmfh->stack_nbytes), 0);
sdb_set (db, ""qnx.heap_nbytes"", r_strf (""0x%x"", lmfh->heap_nbytes), 0);
sdb_set (db, ""qnx.image_base"", r_strf (""0x%x"", lmfh->image_base), 0);
return true;
}","static int lmf_header_load(lmf_header *VAR_0, RBuffer *VAR_1, Sdb *VAR_2) {
if (r_buf_size (VAR_1) < sizeof (lmf_header)) {
return false;
}
if (r_buf_fread_at (VAR_1, VAR_3, (ut8 *) VAR_0, ""iiiiiiiicccciiiicc"", 1) < VAR_4) {
return false;
}
r_strf_buffer (32);
sdb_set (VAR_2, ""qnx.version"", r_strf (""0x%xH"", VAR_0->version), 0);
sdb_set (VAR_2, ""qnx.cflags"", r_strf (""0x%xH"", VAR_0->cflags), 0);
sdb_set (VAR_2, ""qnx.cpu"", r_strf (""0x%xH"", VAR_0->cpu), 0);
sdb_set (VAR_2, ""qnx.fpu"", r_strf (""0x%xH"", VAR_0->fpu), 0);
sdb_set (VAR_2, ""qnx.code_index"", r_strf (""0x%x"", VAR_0->code_index), 0);
sdb_set (VAR_2, ""qnx.stack_index"", r_strf (""0x%x"", VAR_0->stack_index), 0);
sdb_set (VAR_2, ""qnx.heap_index"", r_strf (""0x%x"", VAR_0->heap_index), 0);
sdb_set (VAR_2, ""qnx.argv_index"", r_strf (""0x%x"", VAR_0->argv_index), 0);
sdb_set (VAR_2, ""qnx.code_offset"", r_strf (""0x%x"", VAR_0->code_offset), 0);
sdb_set (VAR_2, ""qnx.stack_nbytes"", r_strf (""0x%x"", VAR_0->stack_nbytes), 0);
sdb_set (VAR_2, ""qnx.heap_nbytes"", r_strf (""0x%x"", VAR_0->heap_nbytes), 0);
sdb_set (VAR_2, ""qnx.image_base"", r_strf (""0x%x"", VAR_0->image_base), 0);
return true;
}",radareorg/radare2/634b886e84a5c568d243e744becc6b3223e089cf/bin_qnx.c/vul/before/0.json,"static int lmf_header_load(lmf_header *lmfh, RBuffer *buf, Sdb *db) {
	if (r_buf_size (buf) < sizeof (lmf_header)) {
		return false;
	}
	if (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, ""iiiiiiiicccciiiicc"", 1) != QNX_HDR_SIZE) {
		return false;
	}
	r_strf_buffer (32);
	sdb_set (db, ""qnx.version"", r_strf (""0x%xH"", lmfh->version), 0);
	sdb_set (db, ""qnx.cflags"", r_strf (""0x%xH"", lmfh->cflags), 0);
	sdb_set (db, ""qnx.cpu"", r_strf (""0x%xH"", lmfh->cpu), 0);
	sdb_set (db, ""qnx.fpu"", r_strf (""0x%xH"", lmfh->fpu), 0);
	sdb_set (db, ""qnx.code_index"", r_strf (""0x%x"", lmfh->code_index), 0);
	sdb_set (db, ""qnx.stack_index"", r_strf (""0x%x"", lmfh->stack_index), 0);
	sdb_set (db, ""qnx.heap_index"", r_strf (""0x%x"", lmfh->heap_index), 0);
	sdb_set (db, ""qnx.argv_index"", r_strf (""0x%x"", lmfh->argv_index), 0);
	sdb_set (db, ""qnx.code_offset"", r_strf (""0x%x"", lmfh->code_offset), 0);
	sdb_set (db, ""qnx.stack_nbytes"", r_strf (""0x%x"", lmfh->stack_nbytes), 0);
	sdb_set (db, ""qnx.heap_nbytes"", r_strf (""0x%x"", lmfh->heap_nbytes), 0);
	sdb_set (db, ""qnx.image_base"", r_strf (""0x%x"", lmfh->image_base), 0);
	return true;
}","static int lmf_header_load(lmf_header *VAR_0, RBuffer *VAR_1, Sdb *VAR_2) {
	if (r_buf_size (VAR_1) < sizeof (lmf_header)) {
		return false;
	}
	if (r_buf_fread_at (VAR_1, VAR_3, (ut8 *) VAR_0, ""iiiiiiiicccciiiicc"", 1) != VAR_4) {
		return false;
	}
	r_strf_buffer (32);
	sdb_set (VAR_2, ""qnx.version"", r_strf (""0x%xH"", VAR_0->version), 0);
	sdb_set (VAR_2, ""qnx.cflags"", r_strf (""0x%xH"", VAR_0->cflags), 0);
	sdb_set (VAR_2, ""qnx.cpu"", r_strf (""0x%xH"", VAR_0->cpu), 0);
	sdb_set (VAR_2, ""qnx.fpu"", r_strf (""0x%xH"", VAR_0->fpu), 0);
	sdb_set (VAR_2, ""qnx.code_index"", r_strf (""0x%x"", VAR_0->code_index), 0);
	sdb_set (VAR_2, ""qnx.stack_index"", r_strf (""0x%x"", VAR_0->stack_index), 0);
	sdb_set (VAR_2, ""qnx.heap_index"", r_strf (""0x%x"", VAR_0->heap_index), 0);
	sdb_set (VAR_2, ""qnx.argv_index"", r_strf (""0x%x"", VAR_0->argv_index), 0);
	sdb_set (VAR_2, ""qnx.code_offset"", r_strf (""0x%x"", VAR_0->code_offset), 0);
	sdb_set (VAR_2, ""qnx.stack_nbytes"", r_strf (""0x%x"", VAR_0->stack_nbytes), 0);
	sdb_set (VAR_2, ""qnx.heap_nbytes"", r_strf (""0x%x"", VAR_0->heap_nbytes), 0);
	sdb_set (VAR_2, ""qnx.image_base"", r_strf (""0x%x"", VAR_0->image_base), 0);
	return true;
}",radareorg/radare2/634b886e84a5c568d243e744becc6b3223e089cf/bin_qnx.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 	if (r_buf_size (buf) < sizeof (lmf_header)) {
 		return false;
 	}
-	if (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, ""iiiiiiiicccciiiicc"", 1) < QNX_HDR_SIZE) {
+	if (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, ""iiiiiiiicccciiiicc"", 1) != QNX_HDR_SIZE) {
 		return false;
 	}
 	r_strf_buffer (32);","{'deleted_lines': ['\tif (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, ""iiiiiiiicccciiiicc"", 1) < QNX_HDR_SIZE) {'], 'added_lines': ['\tif (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, ""iiiiiiiicccciiiicc"", 1) != QNX_HDR_SIZE) {']}",True,Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4.,5.5,MEDIUM,1,test,2022-02-23T21:54:54Z,4
CVE-2022-0695,['CWE-400'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,radareorg/radare2,"Fix DoS in PE/QNX/DYLDCACHE/PSX parsers ##crash

* Reported by lazymio
* Reproducer: AAA4AAAAAB4=",634b886e84a5c568d243e744becc6b3223e089cf,https://github.com/radareorg/radare2/commit/634b886e84a5c568d243e744becc6b3223e089cf,libr/bin/p/bin_qnx.c,load_buffer,"static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
QnxObj *qo = R_NEW0 (QnxObj);
if (!qo) {
return false;
}
lmf_record lrec;
lmf_resource lres;
lmf_data ldata;
ut64 offset = QNX_RECORD_SIZE;
RList *sections = NULL;
RList *fixups = NULL;
if (!qo) {
goto beach;
}
if (!(sections = r_list_newf ((RListFree)r_bin_section_free)) || !(fixups = r_list_new ())) {
goto beach;
}
qo->kv = sdb_new0 ();
if (!qo->kv) {
goto beach;
}
if (r_buf_fread_at (bf->buf, 0, (ut8 *)&lrec, ""ccss"", 1) < QNX_RECORD_SIZE) {
goto beach;
}
lmf_header_load (&qo->lmfh, bf->buf, qo->kv);
offset += lrec.data_nbytes;
for (;;) {
if (r_buf_fread_at (bf->buf, offset, (ut8 *)&lrec, ""ccss"", 1) < QNX_RECORD_SIZE) {
goto beach;
}
offset += sizeof (lmf_record);
if (lrec.rec_type == LMF_IMAGE_END_REC) {
break;
} else if (lrec.rec_type == LMF_RESOURCE_REC) {
RBinSection *ptr = R_NEW0 (RBinSection);
if (!ptr) {
goto beach;
}
if (r_buf_fread_at (bf->buf, offset, (ut8 *)&lres, ""ssss"", 1) < sizeof (lmf_resource)) {
goto beach;
}
ptr->name = strdup (""LMF_RESOURCE"");
ptr->paddr = offset;
ptr->vsize = lrec.data_nbytes - sizeof (lmf_resource);
ptr->size = ptr->vsize;
ptr->add = true;
r_list_append (sections, ptr);
} else if (lrec.rec_type == LMF_LOAD_REC) {
RBinSection *ptr = R_NEW0 (RBinSection);
if (r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) < sizeof (lmf_data)) {
goto beach;
}
if (!ptr) {
goto beach;
}
ptr->name = strdup (""LMF_LOAD"");
ptr->paddr = offset;
ptr->vaddr = ldata.offset;
ptr->vsize = lrec.data_nbytes - sizeof (lmf_data);
ptr->size = ptr->vsize;
ptr->add = true;
r_list_append (sections, ptr);
} else if (lrec.rec_type == LMF_FIXUP_REC) {
RBinReloc *ptr = R_NEW0 (RBinReloc);
if (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) < sizeof (lmf_data)) {
goto beach;
}
ptr->vaddr = ptr->paddr = ldata.offset;
ptr->type = 'f'; r_list_append (fixups, ptr);
} else if (lrec.rec_type == LMF_8087_FIXUP_REC) {
RBinReloc *ptr = R_NEW0 (RBinReloc);
if (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) < sizeof (lmf_data)) {
goto beach;
}
ptr->vaddr = ptr->paddr = ldata.offset;
ptr->type = 'F'; r_list_append (fixups, ptr);
} else if (lrec.rec_type == LMF_RW_END_REC) {
r_buf_fread_at (bf->buf, offset, (ut8 *)&qo->rwend, ""si"", 1);
}
offset += lrec.data_nbytes;
}
sdb_ns_set (sdb, ""info"", qo->kv);
qo->sections = sections;
qo->fixups = fixups;
*bin_obj = qo;
return true;
beach:
free (qo);
r_list_free (fixups);
r_list_free (sections);
return false;
}","static bool load_buffer(RBinFile *VAR_0, void **VAR_1, RBuffer *VAR_2, ut64 VAR_3, Sdb *VAR_4) {
QnxObj *VAR_5 = R_NEW0 (QnxObj);
if (!VAR_5) {
return false;
}
lmf_record VAR_6;
lmf_resource VAR_7;
lmf_data VAR_8;
ut64 VAR_9 = VAR_10;
RList *VAR_11 = NULL;
RList *VAR_12 = NULL;
if (!VAR_5) {
goto beach;
}
if (!(VAR_11 = r_list_newf ((RListFree)VAR_13)) || !(VAR_12 = r_list_new ())) {
goto beach;
}
VAR_5->kv = sdb_new0 ();
if (!VAR_5->kv) {
goto beach;
}
if (r_buf_fread_at (VAR_0->buf, 0, (ut8 *)&VAR_6, ""ccss"", 1) < VAR_10) {
goto beach;
}
lmf_header_load (&VAR_5->lmfh, VAR_0->buf, VAR_5->kv);
VAR_9 += VAR_6.data_nbytes;
for (;;) {
if (r_buf_fread_at (VAR_0->buf, VAR_9, (ut8 *)&VAR_6, ""ccss"", 1) < VAR_10) {
goto beach;
}
VAR_9 += sizeof (lmf_record);
if (VAR_6.rec_type == VAR_14) {
break;
} else if (VAR_6.rec_type == VAR_15) {
RBinSection *VAR_16 = R_NEW0 (RBinSection);
if (!VAR_16) {
goto beach;
}
if (r_buf_fread_at (VAR_0->buf, VAR_9, (ut8 *)&VAR_7, ""ssss"", 1) < sizeof (lmf_resource)) {
goto beach;
}
VAR_16->name = strdup (""LMF_RESOURCE"");
VAR_16->paddr = VAR_9;
VAR_16->vsize = VAR_6.data_nbytes - sizeof (lmf_resource);
VAR_16->size = VAR_16->vsize;
VAR_16->add = true;
r_list_append (VAR_11, VAR_16);
} else if (VAR_6.rec_type == VAR_17) {
RBinSection *VAR_16 = R_NEW0 (RBinSection);
if (r_buf_fread_at (VAR_0->buf, VAR_9, (ut8 *)&VAR_8, ""si"", 1) < sizeof (lmf_data)) {
goto beach;
}
if (!VAR_16) {
goto beach;
}
VAR_16->name = strdup (""LMF_LOAD"");
VAR_16->paddr = VAR_9;
VAR_16->vaddr = VAR_8.offset;
VAR_16->vsize = VAR_6.data_nbytes - sizeof (lmf_data);
VAR_16->size = VAR_16->vsize;
VAR_16->add = true;
r_list_append (VAR_11, VAR_16);
} else if (VAR_6.rec_type == VAR_18) {
RBinReloc *VAR_16 = R_NEW0 (RBinReloc);
if (!VAR_16 || r_buf_fread_at (VAR_0->buf, VAR_9, (ut8 *)&VAR_8, ""si"", 1) < sizeof (lmf_data)) {
goto beach;
}
VAR_16->vaddr = VAR_16->paddr = VAR_8.offset;
VAR_16->type = 'f'; 
r_list_append (VAR_12, VAR_16);
} else if (VAR_6.rec_type == VAR_19) {
RBinReloc *VAR_16 = R_NEW0 (RBinReloc);
if (!VAR_16 || r_buf_fread_at (VAR_0->buf, VAR_9, (ut8 *)&VAR_8, ""si"", 1) < sizeof (lmf_data)) {
goto beach;
}
VAR_16->vaddr = VAR_16->paddr = VAR_8.offset;
VAR_16->type = 'F'; 
r_list_append (VAR_12, VAR_16);
} else if (VAR_6.rec_type == VAR_20) {
r_buf_fread_at (VAR_0->buf, VAR_9, (ut8 *)&VAR_5->rwend, ""si"", 1);
}
VAR_9 += VAR_6.data_nbytes;
}
sdb_ns_set (VAR_4, ""info"", VAR_5->kv);
VAR_5->sections = VAR_11;
VAR_5->fixups = VAR_12;
*VAR_1 = VAR_5;
return true;
beach:
free (VAR_5);
r_list_free (VAR_12);
r_list_free (VAR_11);
return false;
}",radareorg/radare2/634b886e84a5c568d243e744becc6b3223e089cf/bin_qnx.c/vul/before/1.json,"static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
	QnxObj *qo = R_NEW0 (QnxObj);
	if (!qo) {
		return false;
	}
	lmf_record lrec;
	lmf_resource lres;
	lmf_data ldata;
	ut64 offset = QNX_RECORD_SIZE;
	RList *sections = NULL;
	RList *fixups = NULL;

	if (!qo) {
		goto beach;
	}
	if (!(sections = r_list_newf ((RListFree)r_bin_section_free)) || !(fixups = r_list_new ())) {
		goto beach;
	}
	qo->kv = sdb_new0 ();
	if (!qo->kv) {
		goto beach;
	}
	// Read the first record
	if (r_buf_fread_at (bf->buf, 0, (ut8 *)&lrec, ""ccss"", 1) != QNX_RECORD_SIZE) {
		goto beach;
	}
	// Load the header
	lmf_header_load (&qo->lmfh, bf->buf, qo->kv);
	offset += lrec.data_nbytes;

	for (;;) {
		if (r_buf_fread_at (bf->buf, offset, (ut8 *)&lrec, ""ccss"", 1) != QNX_RECORD_SIZE) {
			goto beach;
		}
		offset += sizeof (lmf_record);

		if (lrec.rec_type == LMF_IMAGE_END_REC) {
			break;
		} else if (lrec.rec_type == LMF_RESOURCE_REC) {
			RBinSection *ptr = R_NEW0 (RBinSection);
			if (!ptr) {
				goto beach;
			}
			if (r_buf_fread_at (bf->buf, offset, (ut8 *)&lres, ""ssss"", 1) != sizeof (lmf_resource)) {
				goto beach;
			}
			ptr->name = strdup (""LMF_RESOURCE"");
			ptr->paddr = offset;
			ptr->vsize = lrec.data_nbytes - sizeof (lmf_resource);
			ptr->size = ptr->vsize;
			ptr->add = true;
		 	r_list_append (sections, ptr);
		} else if (lrec.rec_type == LMF_LOAD_REC) {
			RBinSection *ptr = R_NEW0 (RBinSection);
			if (r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) != sizeof (lmf_data)) {
				goto beach;
			}
			if (!ptr) {
				goto beach;
			}
			ptr->name = strdup (""LMF_LOAD"");
			ptr->paddr = offset;
			ptr->vaddr = ldata.offset;
			ptr->vsize = lrec.data_nbytes - sizeof (lmf_data);
			ptr->size = ptr->vsize;
			ptr->add = true;
		 	r_list_append (sections, ptr);
		} else if (lrec.rec_type == LMF_FIXUP_REC) {
			RBinReloc *ptr = R_NEW0 (RBinReloc);
			if (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) != sizeof (lmf_data)) {
				goto beach;
			}
			ptr->vaddr = ptr->paddr = ldata.offset;
			ptr->type = 'f'; // ""LMF_FIXUP"";
			r_list_append (fixups, ptr);
		} else if (lrec.rec_type == LMF_8087_FIXUP_REC) {
			RBinReloc *ptr = R_NEW0 (RBinReloc);
			if (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) != sizeof (lmf_data)) {
				goto beach;
			}
			ptr->vaddr = ptr->paddr = ldata.offset;
			ptr->type = 'F'; // ""LMF_8087_FIXUP"";
			r_list_append (fixups, ptr);
		} else if (lrec.rec_type == LMF_RW_END_REC) {
			r_buf_fread_at (bf->buf, offset, (ut8 *)&qo->rwend, ""si"", 1);
		}
		offset += lrec.data_nbytes;
	}
	sdb_ns_set (sdb, ""info"", qo->kv);
	qo->sections = sections;
	qo->fixups = fixups;
	*bin_obj = qo;
	return true;
beach:
	free (qo);
	r_list_free (fixups);
	r_list_free (sections);
	return false;
}","static bool load_buffer(RBinFile *VAR_0, void **VAR_1, RBuffer *VAR_2, ut64 VAR_3, Sdb *VAR_4) {
	QnxObj *VAR_5 = R_NEW0 (QnxObj);
	if (!VAR_5) {
		return false;
	}
	lmf_record VAR_6;
	lmf_resource VAR_7;
	lmf_data VAR_8;
	ut64 VAR_9 = VAR_10;
	RList *VAR_11 = NULL;
	RList *VAR_12 = NULL;

	if (!VAR_5) {
		goto beach;
	}
	if (!(VAR_11 = r_list_newf ((RListFree)VAR_13)) || !(VAR_12 = r_list_new ())) {
		goto beach;
	}
	VAR_5->kv = sdb_new0 ();
	if (!VAR_5->kv) {
		goto beach;
	}
	/* COMMENT_0 */
	if (r_buf_fread_at (VAR_0->buf, 0, (ut8 *)&VAR_6, ""ccss"", 1) != VAR_10) {
		goto beach;
	}
	/* COMMENT_1 */
	lmf_header_load (&VAR_5->lmfh, VAR_0->buf, VAR_5->kv);
	VAR_9 += VAR_6.data_nbytes;

	for (;;) {
		if (r_buf_fread_at (VAR_0->buf, VAR_9, (ut8 *)&VAR_6, ""ccss"", 1) != VAR_10) {
			goto beach;
		}
		VAR_9 += sizeof (lmf_record);

		if (VAR_6.rec_type == VAR_14) {
			break;
		} else if (VAR_6.rec_type == VAR_15) {
			RBinSection *VAR_16 = R_NEW0 (RBinSection);
			if (!VAR_16) {
				goto beach;
			}
			if (r_buf_fread_at (VAR_0->buf, VAR_9, (ut8 *)&VAR_7, ""ssss"", 1) != sizeof (lmf_resource)) {
				goto beach;
			}
			VAR_16->name = strdup (""LMF_RESOURCE"");
			VAR_16->paddr = VAR_9;
			VAR_16->vsize = VAR_6.data_nbytes - sizeof (lmf_resource);
			VAR_16->size = VAR_16->vsize;
			VAR_16->add = true;
		 	r_list_append (VAR_11, VAR_16);
		} else if (VAR_6.rec_type == VAR_17) {
			RBinSection *VAR_16 = R_NEW0 (RBinSection);
			if (r_buf_fread_at (VAR_0->buf, VAR_9, (ut8 *)&VAR_8, ""si"", 1) != sizeof (lmf_data)) {
				goto beach;
			}
			if (!VAR_16) {
				goto beach;
			}
			VAR_16->name = strdup (""LMF_LOAD"");
			VAR_16->paddr = VAR_9;
			VAR_16->vaddr = VAR_8.offset;
			VAR_16->vsize = VAR_6.data_nbytes - sizeof (lmf_data);
			VAR_16->size = VAR_16->vsize;
			VAR_16->add = true;
		 	r_list_append (VAR_11, VAR_16);
		} else if (VAR_6.rec_type == VAR_18) {
			RBinReloc *VAR_16 = R_NEW0 (RBinReloc);
			if (!VAR_16 || r_buf_fread_at (VAR_0->buf, VAR_9, (ut8 *)&VAR_8, ""si"", 1) != sizeof (lmf_data)) {
				goto beach;
			}
			VAR_16->vaddr = VAR_16->paddr = VAR_8.offset;
			VAR_16->type = 'f'; /* COMMENT_2 */
			r_list_append (VAR_12, VAR_16);
		} else if (VAR_6.rec_type == VAR_19) {
			RBinReloc *VAR_16 = R_NEW0 (RBinReloc);
			if (!VAR_16 || r_buf_fread_at (VAR_0->buf, VAR_9, (ut8 *)&VAR_8, ""si"", 1) != sizeof (lmf_data)) {
				goto beach;
			}
			VAR_16->vaddr = VAR_16->paddr = VAR_8.offset;
			VAR_16->type = 'F'; /* COMMENT_3 */
			r_list_append (VAR_12, VAR_16);
		} else if (VAR_6.rec_type == VAR_20) {
			r_buf_fread_at (VAR_0->buf, VAR_9, (ut8 *)&VAR_5->rwend, ""si"", 1);
		}
		VAR_9 += VAR_6.data_nbytes;
	}
	sdb_ns_set (VAR_4, ""info"", VAR_5->kv);
	VAR_5->sections = VAR_11;
	VAR_5->fixups = VAR_12;
	*VAR_1 = VAR_5;
	return true;
beach:
	free (VAR_5);
	r_list_free (VAR_12);
	r_list_free (VAR_11);
	return false;
}",radareorg/radare2/634b886e84a5c568d243e744becc6b3223e089cf/bin_qnx.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -21,7 +21,7 @@
 		goto beach;
 	}
 	// Read the first record
-	if (r_buf_fread_at (bf->buf, 0, (ut8 *)&lrec, ""ccss"", 1) < QNX_RECORD_SIZE) {
+	if (r_buf_fread_at (bf->buf, 0, (ut8 *)&lrec, ""ccss"", 1) != QNX_RECORD_SIZE) {
 		goto beach;
 	}
 	// Load the header
@@ -29,7 +29,7 @@
 	offset += lrec.data_nbytes;
 
 	for (;;) {
-		if (r_buf_fread_at (bf->buf, offset, (ut8 *)&lrec, ""ccss"", 1) < QNX_RECORD_SIZE) {
+		if (r_buf_fread_at (bf->buf, offset, (ut8 *)&lrec, ""ccss"", 1) != QNX_RECORD_SIZE) {
 			goto beach;
 		}
 		offset += sizeof (lmf_record);
@@ -41,7 +41,7 @@
 			if (!ptr) {
 				goto beach;
 			}
-			if (r_buf_fread_at (bf->buf, offset, (ut8 *)&lres, ""ssss"", 1) < sizeof (lmf_resource)) {
+			if (r_buf_fread_at (bf->buf, offset, (ut8 *)&lres, ""ssss"", 1) != sizeof (lmf_resource)) {
 				goto beach;
 			}
 			ptr->name = strdup (""LMF_RESOURCE"");
@@ -52,7 +52,7 @@
 		 	r_list_append (sections, ptr);
 		} else if (lrec.rec_type == LMF_LOAD_REC) {
 			RBinSection *ptr = R_NEW0 (RBinSection);
-			if (r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) < sizeof (lmf_data)) {
+			if (r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) != sizeof (lmf_data)) {
 				goto beach;
 			}
 			if (!ptr) {
@@ -67,7 +67,7 @@
 		 	r_list_append (sections, ptr);
 		} else if (lrec.rec_type == LMF_FIXUP_REC) {
 			RBinReloc *ptr = R_NEW0 (RBinReloc);
-			if (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) < sizeof (lmf_data)) {
+			if (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) != sizeof (lmf_data)) {
 				goto beach;
 			}
 			ptr->vaddr = ptr->paddr = ldata.offset;
@@ -75,7 +75,7 @@
 			r_list_append (fixups, ptr);
 		} else if (lrec.rec_type == LMF_8087_FIXUP_REC) {
 			RBinReloc *ptr = R_NEW0 (RBinReloc);
-			if (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) < sizeof (lmf_data)) {
+			if (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) != sizeof (lmf_data)) {
 				goto beach;
 			}
 			ptr->vaddr = ptr->paddr = ldata.offset;","{'deleted_lines': ['\tif (r_buf_fread_at (bf->buf, 0, (ut8 *)&lrec, ""ccss"", 1) < QNX_RECORD_SIZE) {', '\t\tif (r_buf_fread_at (bf->buf, offset, (ut8 *)&lrec, ""ccss"", 1) < QNX_RECORD_SIZE) {', '\t\t\tif (r_buf_fread_at (bf->buf, offset, (ut8 *)&lres, ""ssss"", 1) < sizeof (lmf_resource)) {', '\t\t\tif (r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) < sizeof (lmf_data)) {', '\t\t\tif (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) < sizeof (lmf_data)) {', '\t\t\tif (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) < sizeof (lmf_data)) {'], 'added_lines': ['\tif (r_buf_fread_at (bf->buf, 0, (ut8 *)&lrec, ""ccss"", 1) != QNX_RECORD_SIZE) {', '\t\tif (r_buf_fread_at (bf->buf, offset, (ut8 *)&lrec, ""ccss"", 1) != QNX_RECORD_SIZE) {', '\t\t\tif (r_buf_fread_at (bf->buf, offset, (ut8 *)&lres, ""ssss"", 1) != sizeof (lmf_resource)) {', '\t\t\tif (r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) != sizeof (lmf_data)) {', '\t\t\tif (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) != sizeof (lmf_data)) {', '\t\t\tif (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) != sizeof (lmf_data)) {']}",True,Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4.,5.5,MEDIUM,1,test,2022-02-23T21:54:54Z,4
CVE-2022-0695,['CWE-400'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,radareorg/radare2,"Fix DoS in PE/QNX/DYLDCACHE/PSX parsers ##crash

* Reported by lazymio
* Reproducer: AAA4AAAAAB4=",634b886e84a5c568d243e744becc6b3223e089cf,https://github.com/radareorg/radare2/commit/634b886e84a5c568d243e744becc6b3223e089cf,libr/bin/format/pe/pe.c,Pe_r_bin_pe_parse_var,"static Var* Pe_r_bin_pe_parse_var(RBinPEObj* pe, PE_DWord* curAddr) {
Var* var = calloc (1, sizeof (*var));
if (!var) {
pe_printf (""Warning: calloc (Var)\n"");
return NULL;
}
if ((var->wLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {
pe_printf (""Warning: read (Var wLength)\n"");
free_Var (var);
return NULL;
}
*curAddr += sizeof (var->wLength);
if ((var->wValueLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {
pe_printf (""Warning: read (Var wValueLength)\n"");
free_Var (var);
return NULL;
}
*curAddr += sizeof (var->wValueLength);
if ((var->wType = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {
pe_printf (""Warning: read (Var wType)\n"");
free_Var (var);
return NULL;
}
*curAddr += sizeof (var->wType);
if (var->wType != 0 && var->wType != 1) {
pe_printf (""Warning: check (Var wType)\n"");
free_Var (var);
return NULL;
}
var->szKey = (ut16*) malloc (UT16_ALIGN (TRANSLATION_UTF_16_LEN));  if (!var->szKey) {
pe_printf (""Warning: malloc (Var szKey)\n"");
free_Var (var);
return NULL;
}
if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {
pe_printf (""Warning: read (Var szKey)\n"");
free_Var (var);
return NULL;
}
*curAddr += TRANSLATION_UTF_16_LEN;
if (memcmp (var->szKey, TRANSLATION_UTF_16, TRANSLATION_UTF_16_LEN)) {
pe_printf (""Warning: check (Var szKey)\n"");
free_Var (var);
return NULL;
}
align32 (*curAddr);
var->numOfValues = var->wValueLength / 4;
if (!var->numOfValues) {
pe_printf (""Warning: check (Var numOfValues)\n"");
free_Var (var);
return NULL;
}
var->Value = (ut32*) malloc (var->wValueLength);
if (!var->Value) {
pe_printf (""Warning: malloc (Var Value)\n"");
free_Var (var);
return NULL;
}
if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->Value, var->wValueLength) != var->wValueLength) {
pe_printf (""Warning: read (Var Value)\n"");
free_Var (var);
return NULL;
}
*curAddr += var->wValueLength;
return var;
}","static Var* Pe_r_bin_pe_parse_var(RBinPEObj* VAR_0, PE_DWord* VAR_1) {
Var* VAR_2 = calloc (1, sizeof (*VAR_2));
if (!VAR_2) {
pe_printf (""Warning: calloc (Var)\n"");
return NULL;
}
if ((VAR_2->wLength = r_buf_read_le16_at (VAR_0->b, *VAR_1)) == VAR_3) {
pe_printf (""Warning: read (Var wLength)\n"");
free_Var (VAR_2);
return NULL;
}
*VAR_1 += sizeof (VAR_2->wLength);
if ((VAR_2->wValueLength = r_buf_read_le16_at (VAR_0->b, *VAR_1)) == VAR_3) {
pe_printf (""Warning: read (Var wValueLength)\n"");
free_Var (VAR_2);
return NULL;
}
*VAR_1 += sizeof (VAR_2->wValueLength);
if ((VAR_2->wType = r_buf_read_le16_at (VAR_0->b, *VAR_1)) == VAR_3) {
pe_printf (""Warning: read (Var wType)\n"");
free_Var (VAR_2);
return NULL;
}
*VAR_1 += sizeof (VAR_2->wType);
if (VAR_2->wType != 0 && VAR_2->wType != 1) {
pe_printf (""Warning: check (Var wType)\n"");
free_Var (VAR_2);
return NULL;
}
VAR_2->szKey = (ut16*) malloc (UT16_ALIGN (VAR_4));  
if (!VAR_2->szKey) {
pe_printf (""Warning: malloc (Var szKey)\n"");
free_Var (VAR_2);
return NULL;
}
if (r_buf_read_at (VAR_0->b, *VAR_1, (ut8*) VAR_2->szKey, VAR_4) < 1) {
pe_printf (""Warning: read (Var szKey)\n"");
free_Var (VAR_2);
return NULL;
}
*VAR_1 += VAR_4;
if (memcmp (VAR_2->szKey, VAR_5, VAR_4)) {
pe_printf (""Warning: check (Var szKey)\n"");
free_Var (VAR_2);
return NULL;
}
align32 (*VAR_1);
VAR_2->numOfValues = VAR_2->wValueLength / 4;
if (!VAR_2->numOfValues) {
pe_printf (""Warning: check (Var numOfValues)\n"");
free_Var (VAR_2);
return NULL;
}
VAR_2->Value = (ut32*) malloc (VAR_2->wValueLength);
if (!VAR_2->Value) {
pe_printf (""Warning: malloc (Var Value)\n"");
free_Var (VAR_2);
return NULL;
}
if (r_buf_read_at (VAR_0->b, *VAR_1, (ut8*) VAR_2->Value, VAR_2->wValueLength) != VAR_2->wValueLength) {
pe_printf (""Warning: read (Var Value)\n"");
free_Var (VAR_2);
return NULL;
}
*VAR_1 += VAR_2->wValueLength;
return VAR_2;
}",radareorg/radare2/634b886e84a5c568d243e744becc6b3223e089cf/pe.c/vul/before/2.json,"static Var* Pe_r_bin_pe_parse_var(RBinPEObj* pe, PE_DWord* curAddr) {
	Var* var = calloc (1, sizeof (*var));
	if (!var) {
		pe_printf (""Warning: calloc (Var)\n"");
		return NULL;
	}
	if ((var->wLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {
		pe_printf (""Warning: read (Var wLength)\n"");
		free_Var (var);
		return NULL;
	}
	*curAddr += sizeof (var->wLength);
	if ((var->wValueLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {
		pe_printf (""Warning: read (Var wValueLength)\n"");
		free_Var (var);
		return NULL;
	}
	*curAddr += sizeof (var->wValueLength);
	if ((var->wType = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {
		pe_printf (""Warning: read (Var wType)\n"");
		free_Var (var);
		return NULL;
	}
	*curAddr += sizeof (var->wType);
	if (var->wType != 0 && var->wType != 1) {
		pe_printf (""Warning: check (Var wType)\n"");
		free_Var (var);
		return NULL;
	}

	var->szKey = (ut16*) malloc (UT16_ALIGN (TRANSLATION_UTF_16_LEN));  //L""Translation""
	if (!var->szKey) {
		pe_printf (""Warning: malloc (Var szKey)\n"");
		free_Var (var);
		return NULL;
	}
	if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) != TRANSLATION_UTF_16_LEN) {
		pe_printf (""Warning: read (Var szKey)\n"");
		free_Var (var);
		return NULL;
	}
	*curAddr += TRANSLATION_UTF_16_LEN;
	if (memcmp (var->szKey, TRANSLATION_UTF_16, TRANSLATION_UTF_16_LEN)) {
		pe_printf (""Warning: check (Var szKey)\n"");
		free_Var (var);
		return NULL;
	}
	align32 (*curAddr);
	var->numOfValues = var->wValueLength / 4;
	if (!var->numOfValues) {
		pe_printf (""Warning: check (Var numOfValues)\n"");
		free_Var (var);
		return NULL;
	}
	var->Value = (ut32*) malloc (var->wValueLength);
	if (!var->Value) {
		pe_printf (""Warning: malloc (Var Value)\n"");
		free_Var (var);
		return NULL;
	}
	if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->Value, var->wValueLength) != var->wValueLength) {
		pe_printf (""Warning: read (Var Value)\n"");
		free_Var (var);
		return NULL;
	}
	*curAddr += var->wValueLength;
	return var;
}","static Var* Pe_r_bin_pe_parse_var(RBinPEObj* VAR_0, PE_DWord* VAR_1) {
	Var* VAR_2 = calloc (1, sizeof (*VAR_2));
	if (!VAR_2) {
		pe_printf (""Warning: calloc (Var)\n"");
		return NULL;
	}
	if ((VAR_2->wLength = r_buf_read_le16_at (VAR_0->b, *VAR_1)) == VAR_3) {
		pe_printf (""Warning: read (Var wLength)\n"");
		free_Var (VAR_2);
		return NULL;
	}
	*VAR_1 += sizeof (VAR_2->wLength);
	if ((VAR_2->wValueLength = r_buf_read_le16_at (VAR_0->b, *VAR_1)) == VAR_3) {
		pe_printf (""Warning: read (Var wValueLength)\n"");
		free_Var (VAR_2);
		return NULL;
	}
	*VAR_1 += sizeof (VAR_2->wValueLength);
	if ((VAR_2->wType = r_buf_read_le16_at (VAR_0->b, *VAR_1)) == VAR_3) {
		pe_printf (""Warning: read (Var wType)\n"");
		free_Var (VAR_2);
		return NULL;
	}
	*VAR_1 += sizeof (VAR_2->wType);
	if (VAR_2->wType != 0 && VAR_2->wType != 1) {
		pe_printf (""Warning: check (Var wType)\n"");
		free_Var (VAR_2);
		return NULL;
	}

	VAR_2->szKey = (ut16*) malloc (UT16_ALIGN (VAR_4));  /* COMMENT_0 */
	if (!VAR_2->szKey) {
		pe_printf (""Warning: malloc (Var szKey)\n"");
		free_Var (VAR_2);
		return NULL;
	}
	if (r_buf_read_at (VAR_0->b, *VAR_1, (ut8*) VAR_2->szKey, VAR_4) != VAR_4) {
		pe_printf (""Warning: read (Var szKey)\n"");
		free_Var (VAR_2);
		return NULL;
	}
	*VAR_1 += VAR_4;
	if (memcmp (VAR_2->szKey, VAR_5, VAR_4)) {
		pe_printf (""Warning: check (Var szKey)\n"");
		free_Var (VAR_2);
		return NULL;
	}
	align32 (*VAR_1);
	VAR_2->numOfValues = VAR_2->wValueLength / 4;
	if (!VAR_2->numOfValues) {
		pe_printf (""Warning: check (Var numOfValues)\n"");
		free_Var (VAR_2);
		return NULL;
	}
	VAR_2->Value = (ut32*) malloc (VAR_2->wValueLength);
	if (!VAR_2->Value) {
		pe_printf (""Warning: malloc (Var Value)\n"");
		free_Var (VAR_2);
		return NULL;
	}
	if (r_buf_read_at (VAR_0->b, *VAR_1, (ut8*) VAR_2->Value, VAR_2->wValueLength) != VAR_2->wValueLength) {
		pe_printf (""Warning: read (Var Value)\n"");
		free_Var (VAR_2);
		return NULL;
	}
	*VAR_1 += VAR_2->wValueLength;
	return VAR_2;
}",radareorg/radare2/634b886e84a5c568d243e744becc6b3223e089cf/pe.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -34,7 +34,7 @@
 		free_Var (var);
 		return NULL;
 	}
-	if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {
+	if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) != TRANSLATION_UTF_16_LEN) {
 		pe_printf (""Warning: read (Var szKey)\n"");
 		free_Var (var);
 		return NULL;","{'deleted_lines': ['\tif (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {'], 'added_lines': ['\tif (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) != TRANSLATION_UTF_16_LEN) {']}",True,Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4.,5.5,MEDIUM,1,test,2022-02-23T21:54:54Z,4
CVE-2022-0695,['CWE-400'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,radareorg/radare2,"Fix DoS in PE/QNX/DYLDCACHE/PSX parsers ##crash

* Reported by lazymio
* Reproducer: AAA4AAAAAB4=",634b886e84a5c568d243e744becc6b3223e089cf,https://github.com/radareorg/radare2/commit/634b886e84a5c568d243e744becc6b3223e089cf,libr/bin/format/pe/pe.c,bin_pe_parse_imports,"static int bin_pe_parse_imports(RBinPEObj* pe,
struct r_bin_pe_import_t** importp, int* nimp,
const char* dll_name,
PE_DWord OriginalFirstThunk,
PE_DWord FirstThunk) {
char import_name[PE_NAME_LENGTH + 1];
char name[PE_NAME_LENGTH + 1];
PE_Word import_hint, import_ordinal = 0;
PE_DWord import_table = 0, off = 0;
int i = 0, len;
Sdb* db = NULL;
char* sdb_module = NULL;
char* symname = NULL;
char* symdllname = NULL;
if (!dll_name || !*dll_name || *dll_name == '0') {
return 0;
}
if (!(off = PE_(va2pa) (pe, OriginalFirstThunk)) &&
!(off = PE_(va2pa) (pe, FirstThunk))) {
return 0;
}
do {
if (import_ordinal >= UT16_MAX) {
break;
}
if (off + i * sizeof (PE_DWord) > pe->size) {
break;
}
import_table = R_BUF_READ_PE_DWORD_AT (pe->b, off + i * sizeof (PE_DWord));
if (import_table == PE_DWORD_MAX) {
pe_printf (""Warning: read (import table)\n"");
goto error;
} else if (import_table) {
if (import_table & ILT_MASK1) {
import_ordinal = import_table & ILT_MASK2;
import_hint = 0;
snprintf (import_name, PE_NAME_LENGTH, ""Ordinal_%i"", import_ordinal);
free (symdllname);
strncpy (name, dll_name, sizeof (name) - 1);
name[sizeof (name) - 1] = 0;
symdllname = strdup (name);
size_t len = strlen (symdllname);
r_str_case (symdllname, 0);
len = len < 4? 0: len - 4;
symdllname[len] = 0;
char* filename = NULL;
if (!sdb_module || strcmp (symdllname, sdb_module)) {
sdb_free (db);
db = NULL;
free (sdb_module);
sdb_module = strdup (symdllname);
filename = r_str_newf (""%s.sdb"", symdllname);
if (filename && r_file_exists (filename)) {
db = sdb_new (NULL, filename, 0);
} else {
const char *dirPrefix = r_sys_prefix (NULL);
char *lower_symdllname = strdup (symdllname);
r_str_case (lower_symdllname, false);
filename = r_str_newf (R_JOIN_4_PATHS (""%s"", R2_SDB_FORMAT, ""dll"", ""%s.sdb""),
dirPrefix, lower_symdllname);
free (lower_symdllname);
if (r_file_exists (filename)) {
db = sdb_new (NULL, filename, 0);
}
}
}
if (db) {
symname = resolveModuleOrdinal (db, symdllname, import_ordinal);
if (symname) {
snprintf (import_name, PE_NAME_LENGTH, ""%s"", symname);
R_FREE (symname);
}
} else {
pe_printf (""Cannot find %s\n"", filename);
}
free (filename);
} else {
import_ordinal++;
const ut64 off = PE_(va2pa) (pe, import_table);
if (off > pe->size || (off + sizeof (PE_Word)) > pe->size) {
pe_printf (""Warning: off > pe->size\n"");
goto error;
}
import_hint = r_buf_read_le16_at (pe->b, off);
if (import_hint == UT16_MAX) {
pe_printf (""Warning: read import hint at 0x%08""PFMT64x ""\n"", off);
goto error;
}
name[0] = '\0';
len = r_buf_read_at (pe->b, off + sizeof (PE_Word), (ut8*) name, PE_NAME_LENGTH);
if (len < 1) {
pe_printf (""Warning: read (import name)\n"");
goto error;
} else if (!*name) {
break;
}
name[PE_NAME_LENGTH] = '\0';
int len = snprintf (import_name, sizeof (import_name), ""%s"" , name);
if (len >= sizeof (import_name)) {
eprintf (""Import name '%s' has been truncated.\n"", import_name);
}
}
struct r_bin_pe_import_t *new_importp = realloc (*importp, (*nimp + 1) * sizeof (struct r_bin_pe_import_t));
if (!new_importp) {
r_sys_perror (""realloc (import)"");
goto error;
}
*importp = new_importp;
memcpy ((*importp)[*nimp].name, import_name, PE_NAME_LENGTH);
(*importp)[*nimp].name[PE_NAME_LENGTH] = '\0';
memcpy ((*importp)[*nimp].libname, dll_name, PE_NAME_LENGTH);
(*importp)[*nimp].libname[PE_NAME_LENGTH] = '\0';
(*importp)[*nimp].vaddr = bin_pe_rva_to_va (pe, FirstThunk + i * sizeof (PE_DWord));
(*importp)[*nimp].paddr = PE_(va2pa) (pe, FirstThunk) + i * sizeof (PE_DWord);
(*importp)[*nimp].hint = import_hint;
(*importp)[*nimp].ordinal = import_ordinal;
(*importp)[*nimp].last = 0;
(*nimp)++;
i++;
}
} while (import_table);
if (db) {
sdb_free (db);
db = NULL;
}
free (symdllname);
free (sdb_module);
return i;
error:
if (db) {
sdb_free (db);
db = NULL;
}
free (symdllname);
free (sdb_module);
return false;
}","static int bin_pe_parse_imports(RBinPEObj* VAR_0,
struct r_bin_pe_import_t** VAR_1, int* VAR_2,
const char* VAR_3,
PE_DWord VAR_4,
PE_DWord VAR_5) {
char VAR_6[VAR_7 + 1];
char VAR_8[VAR_7 + 1];
PE_Word VAR_9, VAR_10 = 0;
PE_DWord VAR_11 = 0, VAR_12 = 0;
int VAR_13 = 0, VAR_14;
Sdb* VAR_15 = NULL;
char* VAR_16 = NULL;
char* VAR_17 = NULL;
char* VAR_18 = NULL;
if (!VAR_3 || !*VAR_3 || *VAR_3 == '0') {
return 0;
}
if (!(VAR_12 = PE_(VAR_19) (VAR_0, VAR_4)) &&
!(VAR_12 = PE_(VAR_19) (VAR_0, VAR_5))) {
return 0;
}
do {
if (VAR_10 >= VAR_20) {
break;
}
if (VAR_12 + VAR_13 * sizeof (PE_DWord) > VAR_0->size) {
break;
}
VAR_11 = R_BUF_READ_PE_DWORD_AT (VAR_0->b, VAR_12 + VAR_13 * sizeof (PE_DWord));
if (VAR_11 == VAR_21) {
pe_printf (""Warning: read (import table)\n"");
goto error;
} else if (VAR_11) {
if (VAR_11 & VAR_22) {
VAR_10 = VAR_11 & VAR_23;
VAR_9 = 0;
snprintf (VAR_6, VAR_7, ""Ordinal_%i"", VAR_10);
free (VAR_18);
strncpy (VAR_8, VAR_3, sizeof (VAR_8) - 1);
VAR_8[sizeof (VAR_8) - 1] = 0;
VAR_18 = strdup (VAR_8);
size_t VAR_14 = strlen (VAR_18);
r_str_case (VAR_18, 0);
VAR_14 = VAR_14 < 4? 0: VAR_14 - 4;
VAR_18[VAR_14] = 0;
char* VAR_24 = NULL;
if (!VAR_16 || strcmp (VAR_18, VAR_16)) {
sdb_free (VAR_15);
VAR_15 = NULL;
free (VAR_16);
VAR_16 = strdup (VAR_18);
VAR_24 = r_str_newf (""%s.sdb"", VAR_18);
if (VAR_24 && r_file_exists (VAR_24)) {
VAR_15 = sdb_new (NULL, VAR_24, 0);
} else {
const char *VAR_25 = r_sys_prefix (NULL);
char *VAR_26 = strdup (VAR_18);
r_str_case (VAR_26, false);
VAR_24 = r_str_newf (R_JOIN_4_PATHS (""%s"", VAR_27, ""dll"", ""%s.sdb""),
VAR_25, VAR_26);
free (VAR_26);
if (r_file_exists (VAR_24)) {
VAR_15 = sdb_new (NULL, VAR_24, 0);
}
}
}
if (VAR_15) {
VAR_17 = resolveModuleOrdinal (VAR_15, VAR_18, VAR_10);
if (VAR_17) {
snprintf (VAR_6, VAR_7, ""%s"", VAR_17);
R_FREE (VAR_17);
}
} else {
pe_printf (""Cannot find %s\n"", VAR_24);
}
free (VAR_24);
} else {
VAR_10++;
const ut64 VAR_12 = PE_(VAR_19) (VAR_0, VAR_11);
if (VAR_12 > VAR_0->size || (VAR_12 + sizeof (PE_Word)) > VAR_0->size) {
pe_printf (""Warning: off > pe->size\n"");
goto error;
}
VAR_9 = r_buf_read_le16_at (VAR_0->b, VAR_12);
if (VAR_9 == VAR_20) {
pe_printf (""Warning: read import hint at 0x%08""VAR_28 ""\n"", VAR_12);
goto error;
}
VAR_8[0] = '\0';
VAR_14 = r_buf_read_at (VAR_0->b, VAR_12 + sizeof (PE_Word), (ut8*) VAR_8, VAR_7);
if (VAR_14 < 1) {
pe_printf (""Warning: read (import name)\n"");
goto error;
} else if (!*VAR_8) {
break;
}
VAR_8[VAR_7] = '\0';
int VAR_14 = snprintf (VAR_6, sizeof (VAR_6), ""%s"" , VAR_8);
if (VAR_14 >= sizeof (VAR_6)) {
eprintf (""Import name '%s' has been truncated.\n"", VAR_6);
}
}
struct r_bin_pe_import_t *VAR_29 = realloc (*VAR_1, (*VAR_2 + 1) * sizeof (struct r_bin_pe_import_t));
if (!VAR_29) {
r_sys_perror (""realloc (import)"");
goto error;
}
*VAR_1 = VAR_29;
memcpy ((*VAR_1)[*VAR_2].name, VAR_6, VAR_7);
(*VAR_1)[*VAR_2].name[VAR_7] = '\0';
memcpy ((*VAR_1)[*VAR_2].libname, VAR_3, VAR_7);
(*VAR_1)[*VAR_2].libname[VAR_7] = '\0';
(*VAR_1)[*VAR_2].vaddr = bin_pe_rva_to_va (VAR_0, VAR_5 + VAR_13 * sizeof (PE_DWord));
(*VAR_1)[*VAR_2].paddr = PE_(VAR_19) (VAR_0, VAR_5) + VAR_13 * sizeof (PE_DWord);
(*VAR_1)[*VAR_2].hint = VAR_9;
(*VAR_1)[*VAR_2].ordinal = VAR_10;
(*VAR_1)[*VAR_2].last = 0;
(*VAR_2)++;
VAR_13++;
}
} while (VAR_11);
if (VAR_15) {
sdb_free (VAR_15);
VAR_15 = NULL;
}
free (VAR_18);
free (VAR_16);
return VAR_13;
error:
if (VAR_15) {
sdb_free (VAR_15);
VAR_15 = NULL;
}
free (VAR_18);
free (VAR_16);
return false;
}",radareorg/radare2/634b886e84a5c568d243e744becc6b3223e089cf/pe.c/vul/before/0.json,"static int bin_pe_parse_imports(RBinPEObj* pe,
                                struct r_bin_pe_import_t** importp, int* nimp,
                                const char* dll_name,
                                PE_DWord OriginalFirstThunk,
                                PE_DWord FirstThunk) {
	char import_name[PE_NAME_LENGTH + 1];
	char name[PE_NAME_LENGTH + 1];
	PE_Word import_hint, import_ordinal = 0;
	PE_DWord import_table = 0, off = 0;
	int i = 0, len;
	Sdb* db = NULL;
	char* sdb_module = NULL;
	char* symname = NULL;
	char* symdllname = NULL;

	if (!dll_name || !*dll_name || *dll_name == '0') {
		return 0;
	}

	if (!(off = PE_(va2pa) (pe, OriginalFirstThunk)) &&
	!(off = PE_(va2pa) (pe, FirstThunk))) {
		return 0;
	}
	do {
		if (import_ordinal >= UT16_MAX) {
			break;
		}
		if (off + i * sizeof (PE_DWord) > pe->size) {
			break;
		}
		import_table = R_BUF_READ_PE_DWORD_AT (pe->b, off + i * sizeof (PE_DWord));
		if (import_table == PE_DWORD_MAX) {
			pe_printf (""Warning: read (import table)\n"");
			goto error;
		} else if (import_table) {
			if (import_table & ILT_MASK1) {
				import_ordinal = import_table & ILT_MASK2;
				import_hint = 0;
				snprintf (import_name, PE_NAME_LENGTH, ""Ordinal_%i"", import_ordinal);
				free (symdllname);
				strncpy (name, dll_name, sizeof (name) - 1);
				name[sizeof (name) - 1] = 0;
				symdllname = strdup (name);

				// remove the trailling "".dll""
				size_t len = strlen (symdllname);
				r_str_case (symdllname, 0);
				len = len < 4? 0: len - 4;
				symdllname[len] = 0;

				char* filename = NULL;
				if (!sdb_module || strcmp (symdllname, sdb_module)) {
					sdb_free (db);
					db = NULL;
					free (sdb_module);
					sdb_module = strdup (symdllname);
					filename = r_str_newf (""%s.sdb"", symdllname);
					if (filename && r_file_exists (filename)) {
						db = sdb_new (NULL, filename, 0);
					} else {
						const char *dirPrefix = r_sys_prefix (NULL);
						char *lower_symdllname = strdup (symdllname);
						r_str_case (lower_symdllname, false);
						filename = r_str_newf (R_JOIN_4_PATHS (""%s"", R2_SDB_FORMAT, ""dll"", ""%s.sdb""),
							dirPrefix, lower_symdllname);
						free (lower_symdllname);
						if (r_file_exists (filename)) {
							db = sdb_new (NULL, filename, 0);
						}
					}
				}
				if (db) {
					symname = resolveModuleOrdinal (db, symdllname, import_ordinal);
					if (symname) {
						snprintf (import_name, PE_NAME_LENGTH, ""%s"", symname);
						R_FREE (symname);
					}
				} else {
					pe_printf (""Cannot find %s\n"", filename);
				}
				free (filename);
			} else {
				import_ordinal++;
				const ut64 off = PE_(va2pa) (pe, import_table);
				if (off > pe->size || (off + sizeof (PE_Word)) > pe->size) {
					pe_printf (""Warning: off > pe->size\n"");
					goto error;
				}
				import_hint = r_buf_read_le16_at (pe->b, off);
				if (import_hint == UT16_MAX) {
					pe_printf (""Warning: read import hint at 0x%08""PFMT64x ""\n"", off);
					goto error;
				}
				name[0] = '\0';
				len = r_buf_read_at (pe->b, off + sizeof (PE_Word), (ut8*) name, PE_NAME_LENGTH);
				if (len < 1) {
					pe_printf (""Warning: read (import name)\n"");
					goto error;
				}
				if (!*name) {
					break;
				}
				name[PE_NAME_LENGTH] = '\0';
				int len = snprintf (import_name, sizeof (import_name), ""%s"" , name);
				if (len >= sizeof (import_name)) {
					eprintf (""Import name '%s' has been truncated.\n"", import_name);
				}
			}
			struct r_bin_pe_import_t *new_importp = realloc (*importp, (*nimp + 1) * sizeof (struct r_bin_pe_import_t));
			if (!new_importp) {
				r_sys_perror (""realloc (import)"");
				goto error;
			}
			*importp = new_importp;
			memcpy ((*importp)[*nimp].name, import_name, PE_NAME_LENGTH);
			(*importp)[*nimp].name[PE_NAME_LENGTH] = '\0';
			memcpy ((*importp)[*nimp].libname, dll_name, PE_NAME_LENGTH);
			(*importp)[*nimp].libname[PE_NAME_LENGTH] = '\0';
			(*importp)[*nimp].vaddr = bin_pe_rva_to_va (pe, FirstThunk + i * sizeof (PE_DWord));
			(*importp)[*nimp].paddr = PE_(va2pa) (pe, FirstThunk) + i * sizeof (PE_DWord);
			(*importp)[*nimp].hint = import_hint;
			(*importp)[*nimp].ordinal = import_ordinal;
			(*importp)[*nimp].last = 0;
			(*nimp)++;
			i++;
		}
	} while (import_table);

	if (db) {
		sdb_free (db);
		db = NULL;
	}
	free (symdllname);
	free (sdb_module);
	return i;

error:
	if (db) {
		sdb_free (db);
		db = NULL;
	}
	free (symdllname);
	free (sdb_module);
	return false;
}","static int bin_pe_parse_imports(RBinPEObj* VAR_0,
                                struct r_bin_pe_import_t** VAR_1, int* VAR_2,
                                const char* VAR_3,
                                PE_DWord VAR_4,
                                PE_DWord VAR_5) {
	char VAR_6[VAR_7 + 1];
	char VAR_8[VAR_7 + 1];
	PE_Word VAR_9, VAR_10 = 0;
	PE_DWord VAR_11 = 0, VAR_12 = 0;
	int VAR_13 = 0, VAR_14;
	Sdb* VAR_15 = NULL;
	char* VAR_16 = NULL;
	char* VAR_17 = NULL;
	char* VAR_18 = NULL;

	if (!VAR_3 || !*VAR_3 || *VAR_3 == '0') {
		return 0;
	}

	if (!(VAR_12 = PE_(VAR_19) (VAR_0, VAR_4)) &&
	!(VAR_12 = PE_(VAR_19) (VAR_0, VAR_5))) {
		return 0;
	}
	do {
		if (VAR_10 >= VAR_20) {
			break;
		}
		if (VAR_12 + VAR_13 * sizeof (PE_DWord) > VAR_0->size) {
			break;
		}
		VAR_11 = R_BUF_READ_PE_DWORD_AT (VAR_0->b, VAR_12 + VAR_13 * sizeof (PE_DWord));
		if (VAR_11 == VAR_21) {
			pe_printf (""Warning: read (import table)\n"");
			goto error;
		} else if (VAR_11) {
			if (VAR_11 & VAR_22) {
				VAR_10 = VAR_11 & VAR_23;
				VAR_9 = 0;
				snprintf (VAR_6, VAR_7, ""Ordinal_%i"", VAR_10);
				free (VAR_18);
				strncpy (VAR_8, VAR_3, sizeof (VAR_8) - 1);
				VAR_8[sizeof (VAR_8) - 1] = 0;
				VAR_18 = strdup (VAR_8);

				/* COMMENT_0 */
				size_t VAR_14 = strlen (VAR_18);
				r_str_case (VAR_18, 0);
				VAR_14 = VAR_14 < 4? 0: VAR_14 - 4;
				VAR_18[VAR_14] = 0;

				char* VAR_24 = NULL;
				if (!VAR_16 || strcmp (VAR_18, VAR_16)) {
					sdb_free (VAR_15);
					VAR_15 = NULL;
					free (VAR_16);
					VAR_16 = strdup (VAR_18);
					VAR_24 = r_str_newf (""%s.sdb"", VAR_18);
					if (VAR_24 && r_file_exists (VAR_24)) {
						VAR_15 = sdb_new (NULL, VAR_24, 0);
					} else {
						const char *VAR_25 = r_sys_prefix (NULL);
						char *VAR_26 = strdup (VAR_18);
						r_str_case (VAR_26, false);
						VAR_24 = r_str_newf (R_JOIN_4_PATHS (""%s"", VAR_27, ""dll"", ""%s.sdb""),
							VAR_25, VAR_26);
						free (VAR_26);
						if (r_file_exists (VAR_24)) {
							VAR_15 = sdb_new (NULL, VAR_24, 0);
						}
					}
				}
				if (VAR_15) {
					VAR_17 = resolveModuleOrdinal (VAR_15, VAR_18, VAR_10);
					if (VAR_17) {
						snprintf (VAR_6, VAR_7, ""%s"", VAR_17);
						R_FREE (VAR_17);
					}
				} else {
					pe_printf (""Cannot find %s\n"", VAR_24);
				}
				free (VAR_24);
			} else {
				VAR_10++;
				const ut64 VAR_12 = PE_(VAR_19) (VAR_0, VAR_11);
				if (VAR_12 > VAR_0->size || (VAR_12 + sizeof (PE_Word)) > VAR_0->size) {
					pe_printf (""Warning: off > pe->size\n"");
					goto error;
				}
				VAR_9 = r_buf_read_le16_at (VAR_0->b, VAR_12);
				if (VAR_9 == VAR_20) {
					pe_printf (""Warning: read import hint at 0x%08""VAR_28 ""\n"", VAR_12);
					goto error;
				}
				VAR_8[0] = '\0';
				VAR_14 = r_buf_read_at (VAR_0->b, VAR_12 + sizeof (PE_Word), (ut8*) VAR_8, VAR_7);
				if (VAR_14 < 1) {
					pe_printf (""Warning: read (import name)\n"");
					goto error;
				}
				if (!*VAR_8) {
					break;
				}
				VAR_8[VAR_7] = '\0';
				int VAR_14 = snprintf (VAR_6, sizeof (VAR_6), ""%s"" , VAR_8);
				if (VAR_14 >= sizeof (VAR_6)) {
					eprintf (""Import name '%s' has been truncated.\n"", VAR_6);
				}
			}
			struct r_bin_pe_import_t *VAR_29 = realloc (*VAR_1, (*VAR_2 + 1) * sizeof (struct r_bin_pe_import_t));
			if (!VAR_29) {
				r_sys_perror (""realloc (import)"");
				goto error;
			}
			*VAR_1 = VAR_29;
			memcpy ((*VAR_1)[*VAR_2].name, VAR_6, VAR_7);
			(*VAR_1)[*VAR_2].name[VAR_7] = '\0';
			memcpy ((*VAR_1)[*VAR_2].libname, VAR_3, VAR_7);
			(*VAR_1)[*VAR_2].libname[VAR_7] = '\0';
			(*VAR_1)[*VAR_2].vaddr = bin_pe_rva_to_va (VAR_0, VAR_5 + VAR_13 * sizeof (PE_DWord));
			(*VAR_1)[*VAR_2].paddr = PE_(VAR_19) (VAR_0, VAR_5) + VAR_13 * sizeof (PE_DWord);
			(*VAR_1)[*VAR_2].hint = VAR_9;
			(*VAR_1)[*VAR_2].ordinal = VAR_10;
			(*VAR_1)[*VAR_2].last = 0;
			(*VAR_2)++;
			VAR_13++;
		}
	} while (VAR_11);

	if (VAR_15) {
		sdb_free (VAR_15);
		VAR_15 = NULL;
	}
	free (VAR_18);
	free (VAR_16);
	return VAR_13;

error:
	if (VAR_15) {
		sdb_free (VAR_15);
		VAR_15 = NULL;
	}
	free (VAR_18);
	free (VAR_16);
	return false;
}",radareorg/radare2/634b886e84a5c568d243e744becc6b3223e089cf/pe.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -96,7 +96,8 @@
 				if (len < 1) {
 					pe_printf (""Warning: read (import name)\n"");
 					goto error;
-				} else if (!*name) {
+				}
+				if (!*name) {
 					break;
 				}
 				name[PE_NAME_LENGTH] = '\0';","{'deleted_lines': ['\t\t\t\t} else if (!*name) {'], 'added_lines': ['\t\t\t\t}', '\t\t\t\tif (!*name) {']}",True,Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4.,5.5,MEDIUM,1,test,2022-02-23T21:54:54Z,4
CVE-2022-0695,['CWE-400'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,radareorg/radare2,"Fix DoS in PE/QNX/DYLDCACHE/PSX parsers ##crash

* Reported by lazymio
* Reproducer: AAA4AAAAAB4=",634b886e84a5c568d243e744becc6b3223e089cf,https://github.com/radareorg/radare2/commit/634b886e84a5c568d243e744becc6b3223e089cf,libr/bin/p/bin_dyldcache.c,estimate_slide,"static ut64 estimate_slide(RBinFile *bf, RDyldCache *cache, ut64 value_mask, ut64 value_add) {
ut64 slide = 0;
if (cache->n_hdr > 1) {
return slide;
}
ut64 *classlist = malloc (64);
if (!classlist) {
goto beach;
}
RListIter *iter;
RDyldBinImage *bin;
r_list_foreach (cache->bins, iter, bin) {
bool found_sample = false;
struct MACH0_(opts_t) opts = {0};
opts.verbose = bf->rbin->verbose;
opts.header_at = bin->header_at;
opts.symbols_off = 0;
struct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (cache->buf, &opts);
if (!mach0) {
goto beach;
}
struct section_t *sections = NULL;
if (!(sections = MACH0_(get_sections) (mach0))) {
MACH0_(mach0_free) (mach0);
goto beach;
}
int i;
int incomplete = 2;
int classlist_idx = 0, data_idx = 0;
for (i = 0; !sections[i].last && incomplete; i++) {
if (sections[i].size == 0) {
continue;
}
if (strstr (sections[i].name, ""__objc_classlist"")) {
incomplete--;
classlist_idx = i;
continue;
}
if (strstr (sections[i].name, ""__objc_data"")) {
incomplete--;
data_idx = i;
continue;
}
}
if (incomplete) {
goto next_bin;
}
int classlist_sample_size = R_MIN (64, sections[classlist_idx].size);
int n_classes = classlist_sample_size / 8;
ut64 sect_offset = sections[classlist_idx].offset + bin->hdr_offset;
if (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, ""l"", n_classes) < classlist_sample_size) {
goto next_bin;
}
ut64 data_addr = sections[data_idx].addr;
ut64 data_tail = data_addr & 0xfff;
ut64 data_tail_end = (data_addr + sections[data_idx].size) & 0xfff;
for (i = 0; i < n_classes; i++) {
ut64 cl_addr = (classlist[i] & value_mask) + value_add;
ut64 cl_tail = cl_addr & 0xfff;
if (cl_tail >= data_tail && cl_tail < data_tail_end) {
ut64 off = cl_tail - data_tail;
slide = ((cl_addr - off) & value_mask) - (data_addr & value_mask);
found_sample = true;
break;
}
}
next_bin:
MACH0_(mach0_free) (mach0);
R_FREE (sections);
if (found_sample) {
break;
}
}
beach:
R_FREE (classlist);
return slide;
}","static ut64 estimate_slide(RBinFile *VAR_0, RDyldCache *VAR_1, ut64 VAR_2, ut64 VAR_3) {
ut64 VAR_4 = 0;
if (VAR_1->n_hdr > 1) {
return VAR_4;
}
ut64 *VAR_5 = malloc (64);
if (!VAR_5) {
goto beach;
}
RListIter *VAR_6;
RDyldBinImage *VAR_7;
r_list_foreach (VAR_1->bins, VAR_6, VAR_7) {
bool VAR_8 = false;
struct MACH0_(VAR_9) VAR_10 = {0};
VAR_10.verbose = VAR_0->rbin->verbose;
VAR_10.header_at = VAR_7->header_at;
VAR_10.symbols_off = 0;
struct MACH0_(VAR_11) *VAR_12 = MACH0_(VAR_13) (VAR_1->buf, &VAR_10);
if (!VAR_12) {
goto beach;
}
struct section_t *VAR_14 = NULL;
if (!(VAR_14 = MACH0_(VAR_15) (VAR_12))) {
MACH0_(VAR_16) (VAR_12);
goto beach;
}
int VAR_17;
int VAR_18 = 2;
int VAR_19 = 0, VAR_20 = 0;
for (VAR_17 = 0; !VAR_14[VAR_17].last && VAR_18; VAR_17++) {
if (VAR_14[VAR_17].size == 0) {
continue;
}
if (strstr (VAR_14[VAR_17].name, ""__objc_classlist"")) {
VAR_18--;
VAR_19 = VAR_17;
continue;
}
if (strstr (VAR_14[VAR_17].name, ""__objc_data"")) {
VAR_18--;
VAR_20 = VAR_17;
continue;
}
}
if (VAR_18) {
goto next_bin;
}
int VAR_21 = R_MIN (64, VAR_14[VAR_19].size);
int VAR_22 = VAR_21 / 8;
ut64 VAR_23 = VAR_14[VAR_19].offset + VAR_7->hdr_offset;
if (r_buf_fread_at (VAR_1->buf, VAR_23, (ut8*) VAR_5, ""l"", VAR_22) < VAR_21) {
goto next_bin;
}
ut64 VAR_24 = VAR_14[VAR_20].addr;
ut64 VAR_25 = VAR_24 & 0xfff;
ut64 VAR_26 = (VAR_24 + VAR_14[VAR_20].size) & 0xfff;
for (VAR_17 = 0; VAR_17 < VAR_22; VAR_17++) {
ut64 VAR_27 = (VAR_5[VAR_17] & VAR_2) + VAR_3;
ut64 VAR_28 = VAR_27 & 0xfff;
if (VAR_28 >= VAR_25 && VAR_28 < VAR_26) {
ut64 VAR_29 = VAR_28 - VAR_25;
VAR_4 = ((VAR_27 - VAR_29) & VAR_2) - (VAR_24 & VAR_2);
VAR_8 = true;
break;
}
}
next_bin:
MACH0_(VAR_16) (VAR_12);
R_FREE (VAR_14);
if (VAR_8) {
break;
}
}
beach:
R_FREE (VAR_5);
return VAR_4;
}",radareorg/radare2/634b886e84a5c568d243e744becc6b3223e089cf/bin_dyldcache.c/vul/before/0.json,"static ut64 estimate_slide(RBinFile *bf, RDyldCache *cache, ut64 value_mask, ut64 value_add) {
	ut64 slide = 0;
	if (cache->n_hdr > 1) {
		return slide;
	}
	ut64 *classlist = malloc (64);
	if (!classlist) {
		goto beach;
	}

	RListIter *iter;
	RDyldBinImage *bin;
	r_list_foreach (cache->bins, iter, bin) {
		bool found_sample = false;

		struct MACH0_(opts_t) opts = {0};
		opts.verbose = bf->rbin->verbose;
		opts.header_at = bin->header_at;
		opts.symbols_off = 0;

		struct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (cache->buf, &opts);
		if (!mach0) {
			goto beach;
		}

		struct section_t *sections = NULL;
		if (!(sections = MACH0_(get_sections) (mach0))) {
			MACH0_(mach0_free) (mach0);
			goto beach;
		}

		int i;
		int incomplete = 2;
		int classlist_idx = 0, data_idx = 0;
		for (i = 0; !sections[i].last && incomplete; i++) {
			if (sections[i].size == 0) {
				continue;
			}
			if (strstr (sections[i].name, ""__objc_classlist"")) {
				incomplete--;
				classlist_idx = i;
				continue;
			}
			if (strstr (sections[i].name, ""__objc_data"")) {
				incomplete--;
				data_idx = i;
				continue;
			}
		}

		if (incomplete) {
			goto next_bin;
		}

		int classlist_sample_size = R_MIN (64, sections[classlist_idx].size);
		int n_classes = classlist_sample_size / 8;
		ut64 sect_offset = sections[classlist_idx].offset + bin->hdr_offset;

		if (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, ""l"", n_classes) != classlist_sample_size) {
			goto next_bin;
		}

		ut64 data_addr = sections[data_idx].addr;
		ut64 data_tail = data_addr & 0xfff;
		ut64 data_tail_end = (data_addr + sections[data_idx].size) & 0xfff;
		for (i = 0; i < n_classes; i++) {
			ut64 cl_addr = (classlist[i] & value_mask) + value_add;
			ut64 cl_tail = cl_addr & 0xfff;
			if (cl_tail >= data_tail && cl_tail < data_tail_end) {
				ut64 off = cl_tail - data_tail;
				slide = ((cl_addr - off) & value_mask) - (data_addr & value_mask);
				found_sample = true;
				break;
			}
		}

next_bin:
		MACH0_(mach0_free) (mach0);
		R_FREE (sections);

		if (found_sample) {
			break;
		}
	}

beach:
	R_FREE (classlist);
	return slide;
}","static ut64 estimate_slide(RBinFile *VAR_0, RDyldCache *VAR_1, ut64 VAR_2, ut64 VAR_3) {
	ut64 VAR_4 = 0;
	if (VAR_1->n_hdr > 1) {
		return VAR_4;
	}
	ut64 *VAR_5 = malloc (64);
	if (!VAR_5) {
		goto beach;
	}

	RListIter *VAR_6;
	RDyldBinImage *VAR_7;
	r_list_foreach (VAR_1->bins, VAR_6, VAR_7) {
		bool VAR_8 = false;

		struct MACH0_(VAR_9) VAR_10 = {0};
		VAR_10.verbose = VAR_0->rbin->verbose;
		VAR_10.header_at = VAR_7->header_at;
		VAR_10.symbols_off = 0;

		struct MACH0_(VAR_11) *VAR_12 = MACH0_(VAR_13) (VAR_1->buf, &VAR_10);
		if (!VAR_12) {
			goto beach;
		}

		struct section_t *VAR_14 = NULL;
		if (!(VAR_14 = MACH0_(VAR_15) (VAR_12))) {
			MACH0_(VAR_16) (VAR_12);
			goto beach;
		}

		int VAR_17;
		int VAR_18 = 2;
		int VAR_19 = 0, VAR_20 = 0;
		for (VAR_17 = 0; !VAR_14[VAR_17].last && VAR_18; VAR_17++) {
			if (VAR_14[VAR_17].size == 0) {
				continue;
			}
			if (strstr (VAR_14[VAR_17].name, ""__objc_classlist"")) {
				VAR_18--;
				VAR_19 = VAR_17;
				continue;
			}
			if (strstr (VAR_14[VAR_17].name, ""__objc_data"")) {
				VAR_18--;
				VAR_20 = VAR_17;
				continue;
			}
		}

		if (VAR_18) {
			goto next_bin;
		}

		int VAR_21 = R_MIN (64, VAR_14[VAR_19].size);
		int VAR_22 = VAR_21 / 8;
		ut64 VAR_23 = VAR_14[VAR_19].offset + VAR_7->hdr_offset;

		if (r_buf_fread_at (VAR_1->buf, VAR_23, (ut8*) VAR_5, ""l"", VAR_22) != VAR_21) {
			goto next_bin;
		}

		ut64 VAR_24 = VAR_14[VAR_20].addr;
		ut64 VAR_25 = VAR_24 & 0xfff;
		ut64 VAR_26 = (VAR_24 + VAR_14[VAR_20].size) & 0xfff;
		for (VAR_17 = 0; VAR_17 < VAR_22; VAR_17++) {
			ut64 VAR_27 = (VAR_5[VAR_17] & VAR_2) + VAR_3;
			ut64 VAR_28 = VAR_27 & 0xfff;
			if (VAR_28 >= VAR_25 && VAR_28 < VAR_26) {
				ut64 VAR_29 = VAR_28 - VAR_25;
				VAR_4 = ((VAR_27 - VAR_29) & VAR_2) - (VAR_24 & VAR_2);
				VAR_8 = true;
				break;
			}
		}

next_bin:
		MACH0_(VAR_16) (VAR_12);
		R_FREE (VAR_14);

		if (VAR_8) {
			break;
		}
	}

beach:
	R_FREE (VAR_5);
	return VAR_4;
}",radareorg/radare2/634b886e84a5c568d243e744becc6b3223e089cf/bin_dyldcache.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -56,7 +56,7 @@
 		int n_classes = classlist_sample_size / 8;
 		ut64 sect_offset = sections[classlist_idx].offset + bin->hdr_offset;
 
-		if (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, ""l"", n_classes) < classlist_sample_size) {
+		if (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, ""l"", n_classes) != classlist_sample_size) {
 			goto next_bin;
 		}
 ","{'deleted_lines': ['\t\tif (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, ""l"", n_classes) < classlist_sample_size) {'], 'added_lines': ['\t\tif (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, ""l"", n_classes) != classlist_sample_size) {']}",True,Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4.,5.5,MEDIUM,1,test,2022-02-23T21:54:54Z,4
CVE-2022-0695,['CWE-400'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,radareorg/radare2,"Fix DoS in PE/QNX/DYLDCACHE/PSX parsers ##crash

* Reported by lazymio
* Reproducer: AAA4AAAAAB4=",634b886e84a5c568d243e744becc6b3223e089cf,https://github.com/radareorg/radare2/commit/634b886e84a5c568d243e744becc6b3223e089cf,libr/util/buf.c,r_buf_fread_at,"R_API st64 r_buf_fread_at(RBuffer *b, ut64 addr, ut8 *buf, const char *fmt, int n) {
r_return_val_if_fail (b && buf && fmt, -1);
st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
st64 r = r_buf_seek (b, addr, R_BUF_SET);
if (r < 0) {
return r;
}
r = r_buf_fread (b, buf, fmt, n);
r_buf_seek (b, o_addr, R_BUF_SET);
return r;
}","R_API st64 r_buf_fread_at(RBuffer *VAR_0, ut64 VAR_1, ut8 *VAR_2, const char *VAR_3, int VAR_4) {
r_return_val_if_fail (VAR_0 && VAR_2 && VAR_3, -1);
st64 VAR_5 = r_buf_seek (VAR_0, 0, VAR_6);
st64 VAR_7 = r_buf_seek (VAR_0, VAR_1, VAR_8);
if (VAR_7 < 0) {
return VAR_7;
}
VAR_7 = r_buf_fread (VAR_0, VAR_2, VAR_3, VAR_4);
r_buf_seek (VAR_0, VAR_5, VAR_8);
return VAR_7;
}",,"R_API st64 r_buf_fread_at(RBuffer *b, ut64 addr, ut8 *buf, const char *fmt, int n) {
	r_return_val_if_fail (b && buf && fmt, -1);
	st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
	st64 r = r_buf_seek (b, addr, R_BUF_SET);
	if (r < 0) {
		return r;
	}
	r = r_buf_fread (b, buf, fmt, n);
	(void)r_buf_seek (b, o_addr, R_BUF_SET);
	return r;
}","R_API st64 r_buf_fread_at(RBuffer *VAR_0, ut64 VAR_1, ut8 *VAR_2, const char *VAR_3, int VAR_4) {
	r_return_val_if_fail (VAR_0 && VAR_2 && VAR_3, -1);
	st64 VAR_5 = r_buf_seek (VAR_0, 0, VAR_6);
	st64 VAR_7 = r_buf_seek (VAR_0, VAR_1, VAR_8);
	if (VAR_7 < 0) {
		return VAR_7;
	}
	VAR_7 = r_buf_fread (VAR_0, VAR_2, VAR_3, VAR_4);
	(void)r_buf_seek (VAR_0, VAR_5, VAR_8);
	return VAR_7;
}",,"--- func_before
+++ func_after
@@ -6,6 +6,6 @@
 		return r;
 	}
 	r = r_buf_fread (b, buf, fmt, n);
-	r_buf_seek (b, o_addr, R_BUF_SET);
+	(void)r_buf_seek (b, o_addr, R_BUF_SET);
 	return r;
 }","{'deleted_lines': ['\tr_buf_seek (b, o_addr, R_BUF_SET);'], 'added_lines': ['\t(void)r_buf_seek (b, o_addr, R_BUF_SET);']}",True,Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4.,5.5,MEDIUM,1,test,2022-02-23T21:54:54Z,4
CVE-2019-17452,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,axiomatic-systems/Bento4,fix #434,ffea12e7055ba95b4b907cc140785cfb1c420c64,https://github.com/axiomatic-systems/Bento4/commit/ffea12e7055ba95b4b907cc140785cfb1c420c64,Source/C++/Core/Ap4DescriptorFactory.cpp,AP4_DescriptorFactory::CreateDescriptorFromStream,"AP4_Result
AP4_DescriptorFactory::CreateDescriptorFromStream(AP4_ByteStream&  stream, 
AP4_Descriptor*& descriptor)
{
AP4_Result result;
descriptor = NULL;
AP4_Position offset;
stream.Tell(offset);
unsigned char tag;
result = stream.ReadUI08(tag);
if (AP4_FAILED(result)) {
stream.Seek(offset);
return result;
}
AP4_UI32      payload_size = 0;
unsigned int  header_size = 1;
unsigned int  max  = 4;
unsigned char ext  = 0;
do {
header_size++;
result = stream.ReadUI08(ext);
if (AP4_FAILED(result)) {
stream.Seek(offset);
return result;
}
payload_size = (payload_size<<7) + (ext&0x7F);
} while (--max && (ext&0x80));
if (payload_size) {
switch (tag) {
case AP4_DESCRIPTOR_TAG_OD:
case AP4_DESCRIPTOR_TAG_MP4_OD:
descriptor = new AP4_ObjectDescriptor(stream, tag, header_size, payload_size);
break;
case AP4_DESCRIPTOR_TAG_IOD:
case AP4_DESCRIPTOR_TAG_MP4_IOD:
descriptor = new AP4_InitialObjectDescriptor(stream, tag, header_size, payload_size);
break;
case AP4_DESCRIPTOR_TAG_ES_ID_INC:
descriptor = new AP4_EsIdIncDescriptor(stream, header_size, payload_size);
break;
case AP4_DESCRIPTOR_TAG_ES_ID_REF:
descriptor = new AP4_EsIdRefDescriptor(stream, header_size, payload_size);
break;
case AP4_DESCRIPTOR_TAG_ES:
descriptor = new AP4_EsDescriptor(stream, header_size, payload_size);
break;
case AP4_DESCRIPTOR_TAG_DECODER_CONFIG:
descriptor = new AP4_DecoderConfigDescriptor(stream, header_size, payload_size);
break;
case AP4_DESCRIPTOR_TAG_DECODER_SPECIFIC_INFO:
descriptor = new AP4_DecoderSpecificInfoDescriptor(stream, header_size, payload_size);
break;
case AP4_DESCRIPTOR_TAG_SL_CONFIG:
if (payload_size != 1) return AP4_ERROR_INVALID_FORMAT;
descriptor = new AP4_SLConfigDescriptor(header_size);
break;
case AP4_DESCRIPTOR_TAG_IPMP_DESCRIPTOR_POINTER:
descriptor = new AP4_IpmpDescriptorPointer(stream, header_size, payload_size);
break;
case AP4_DESCRIPTOR_TAG_IPMP_DESCRIPTOR:
descriptor = new AP4_IpmpDescriptor(stream, header_size, payload_size);
break;
default:
descriptor = new AP4_UnknownDescriptor(stream, tag, header_size, payload_size);
break;
}
}
stream.Seek(offset+header_size+payload_size);
return AP4_SUCCESS;
}","AP4_Result
AP4_DescriptorFactory::CreateDescriptorFromStream(AP4_ByteStream&  VAR_0, 
AP4_Descriptor*& VAR_1)
{
AP4_Result VAR_2;
VAR_1 = NULL;
AP4_Position VAR_3;
VAR_0.Tell(VAR_3);
unsigned char VAR_4;
VAR_2 = VAR_0.ReadUI08(VAR_4);
if (AP4_FAILED(VAR_2)) {
VAR_0.Seek(VAR_3);
return VAR_2;
}
AP4_UI32      VAR_5 = 0;
unsigned int  VAR_6 = 1;
unsigned int  VAR_7  = 4;
unsigned char VAR_8  = 0;
do {
VAR_6++;
VAR_2 = VAR_0.ReadUI08(VAR_8);
if (AP4_FAILED(VAR_2)) {
VAR_0.Seek(VAR_3);
return VAR_2;
}
VAR_5 = (VAR_5<<7) + (VAR_8&0x7F);
} while (--VAR_7 && (VAR_8&0x80));
if (VAR_5) {
switch (VAR_4) {
case VAR_9:
case VAR_10:
VAR_1 = new AP4_ObjectDescriptor(VAR_0, VAR_4, VAR_6, VAR_5);
break;
case VAR_11:
case VAR_12:
VAR_1 = new AP4_InitialObjectDescriptor(VAR_0, VAR_4, VAR_6, VAR_5);
break;
case VAR_13:
VAR_1 = new AP4_EsIdIncDescriptor(VAR_0, VAR_6, VAR_5);
break;
case VAR_14:
VAR_1 = new AP4_EsIdRefDescriptor(VAR_0, VAR_6, VAR_5);
break;
case VAR_15:
VAR_1 = new AP4_EsDescriptor(VAR_0, VAR_6, VAR_5);
break;
case VAR_16:
VAR_1 = new AP4_DecoderConfigDescriptor(VAR_0, VAR_6, VAR_5);
break;
case VAR_17:
VAR_1 = new AP4_DecoderSpecificInfoDescriptor(VAR_0, VAR_6, VAR_5);
break;
case VAR_18:
if (VAR_5 != 1) return VAR_19;
VAR_1 = new AP4_SLConfigDescriptor(VAR_6);
break;
case VAR_20:
VAR_1 = new AP4_IpmpDescriptorPointer(VAR_0, VAR_6, VAR_5);
break;
case VAR_21:
VAR_1 = new AP4_IpmpDescriptor(VAR_0, VAR_6, VAR_5);
break;
default:
VAR_1 = new AP4_UnknownDescriptor(VAR_0, VAR_4, VAR_6, VAR_5);
break;
}
}
VAR_0.Seek(VAR_3+VAR_6+VAR_5);
return VAR_22;
}",axiomatic-systems/Bento4/ffea12e7055ba95b4b907cc140785cfb1c420c64/Ap4DescriptorFactory.cpp/vul/before/0.json,"AP4_Result
AP4_DescriptorFactory::CreateDescriptorFromStream(AP4_ByteStream&  stream, 
                                                  AP4_Descriptor*& descriptor)
{
    AP4_Result result;

    // NULL by default
    descriptor = NULL;

    // remember current stream offset
    AP4_Position offset;
    stream.Tell(offset);

    // read descriptor tag
    unsigned char tag;
    result = stream.ReadUI08(tag);
    if (AP4_FAILED(result)) {
        stream.Seek(offset);
        return result;
    }
    
    // read descriptor size
    AP4_UI32      payload_size = 0;
    unsigned int  header_size = 1;
    unsigned int  max  = 4;
    unsigned char ext  = 0;
    do {
        header_size++;
        result = stream.ReadUI08(ext);
        if (AP4_FAILED(result)) {
            stream.Seek(offset);
            return result;
        }
        payload_size = (payload_size<<7) + (ext&0x7F);
    } while (--max && (ext&0x80));

    // create the descriptor
    if (payload_size) {
        switch (tag) {
          case AP4_DESCRIPTOR_TAG_OD:
          case AP4_DESCRIPTOR_TAG_MP4_OD:
            descriptor = new AP4_ObjectDescriptor(stream, tag, header_size, payload_size);
            break;

          case AP4_DESCRIPTOR_TAG_IOD:
          case AP4_DESCRIPTOR_TAG_MP4_IOD:
            descriptor = new AP4_InitialObjectDescriptor(stream, tag, header_size, payload_size);
            break;

          case AP4_DESCRIPTOR_TAG_ES_ID_INC:
            descriptor = new AP4_EsIdIncDescriptor(stream, header_size, payload_size);
            break;

          case AP4_DESCRIPTOR_TAG_ES_ID_REF:
            descriptor = new AP4_EsIdRefDescriptor(stream, header_size, payload_size);
            break;

          case AP4_DESCRIPTOR_TAG_ES:
            descriptor = new AP4_EsDescriptor(stream, header_size, payload_size);
            break;

          case AP4_DESCRIPTOR_TAG_DECODER_CONFIG:
            descriptor = new AP4_DecoderConfigDescriptor(stream, header_size, payload_size);
            break;

          case AP4_DESCRIPTOR_TAG_DECODER_SPECIFIC_INFO:
            descriptor = new AP4_DecoderSpecificInfoDescriptor(stream, header_size, payload_size);
            break;

          case AP4_DESCRIPTOR_TAG_SL_CONFIG:
            if (payload_size != 1) return AP4_ERROR_INVALID_FORMAT;
            descriptor = new AP4_SLConfigDescriptor(header_size);
            break;

          case AP4_DESCRIPTOR_TAG_IPMP_DESCRIPTOR_POINTER:
            descriptor = new AP4_IpmpDescriptorPointer(stream, header_size, payload_size);
            break;

          case AP4_DESCRIPTOR_TAG_IPMP_DESCRIPTOR:
            descriptor = new AP4_IpmpDescriptor(stream, header_size, payload_size);
            break;

          default:
            descriptor = new AP4_UnknownDescriptor(stream, tag, header_size, payload_size);
            break;
        }
    } else {
        stream.Seek(offset);
        return AP4_ERROR_INVALID_FORMAT;
    }
    
    // skip to the end of the descriptor
    stream.Seek(offset+header_size+payload_size);

    return AP4_SUCCESS;
}","AP4_Result
AP4_DescriptorFactory::CreateDescriptorFromStream(AP4_ByteStream&  VAR_0, 
                                                  AP4_Descriptor*& VAR_1)
{
    AP4_Result VAR_2;

    /* COMMENT_0 */
    VAR_1 = NULL;

    /* COMMENT_1 */
    AP4_Position VAR_3;
    VAR_0.Tell(VAR_3);

    /* COMMENT_2 */
    unsigned char VAR_4;
    VAR_2 = VAR_0.ReadUI08(VAR_4);
    if (AP4_FAILED(VAR_2)) {
        VAR_0.Seek(VAR_3);
        return VAR_2;
    }
    
    /* COMMENT_3 */
    AP4_UI32      VAR_5 = 0;
    unsigned int  VAR_6 = 1;
    unsigned int  VAR_7  = 4;
    unsigned char VAR_8  = 0;
    do {
        VAR_6++;
        VAR_2 = VAR_0.ReadUI08(VAR_8);
        if (AP4_FAILED(VAR_2)) {
            VAR_0.Seek(VAR_3);
            return VAR_2;
        }
        VAR_5 = (VAR_5<<7) + (VAR_8&0x7F);
    } while (--VAR_7 && (VAR_8&0x80));

    /* COMMENT_4 */
    if (VAR_5) {
        switch (VAR_4) {
          case VAR_9:
          case VAR_10:
            VAR_1 = new AP4_ObjectDescriptor(VAR_0, VAR_4, VAR_6, VAR_5);
            break;

          case VAR_11:
          case VAR_12:
            VAR_1 = new AP4_InitialObjectDescriptor(VAR_0, VAR_4, VAR_6, VAR_5);
            break;

          case VAR_13:
            VAR_1 = new AP4_EsIdIncDescriptor(VAR_0, VAR_6, VAR_5);
            break;

          case VAR_14:
            VAR_1 = new AP4_EsIdRefDescriptor(VAR_0, VAR_6, VAR_5);
            break;

          case VAR_15:
            VAR_1 = new AP4_EsDescriptor(VAR_0, VAR_6, VAR_5);
            break;

          case VAR_16:
            VAR_1 = new AP4_DecoderConfigDescriptor(VAR_0, VAR_6, VAR_5);
            break;

          case VAR_17:
            VAR_1 = new AP4_DecoderSpecificInfoDescriptor(VAR_0, VAR_6, VAR_5);
            break;

          case VAR_18:
            if (VAR_5 != 1) return VAR_19;
            VAR_1 = new AP4_SLConfigDescriptor(VAR_6);
            break;

          case VAR_20:
            VAR_1 = new AP4_IpmpDescriptorPointer(VAR_0, VAR_6, VAR_5);
            break;

          case VAR_21:
            VAR_1 = new AP4_IpmpDescriptor(VAR_0, VAR_6, VAR_5);
            break;

          default:
            VAR_1 = new AP4_UnknownDescriptor(VAR_0, VAR_4, VAR_6, VAR_5);
            break;
        }
    } else {
        VAR_0.Seek(VAR_3);
        return VAR_19;
    }
    
    /* COMMENT_5 */
    VAR_0.Seek(VAR_3+VAR_6+VAR_5);

    return VAR_22;
}",axiomatic-systems/Bento4/ffea12e7055ba95b4b907cc140785cfb1c420c64/Ap4DescriptorFactory.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -84,6 +84,9 @@
             descriptor = new AP4_UnknownDescriptor(stream, tag, header_size, payload_size);
             break;
         }
+    } else {
+        stream.Seek(offset);
+        return AP4_ERROR_INVALID_FORMAT;
     }
     
     // skip to the end of the descriptor","{'deleted_lines': [], 'added_lines': ['    } else {', '        stream.Seek(offset);', '        return AP4_ERROR_INVALID_FORMAT;']}",True,"Bento4 1.5.1.0 has a NULL pointer dereference in AP4_DescriptorListInspector::Action in Core/Ap4Descriptor.h, related to AP4_IodsAtom::InspectFields in Core/Ap4IodsAtom.cpp, as demonstrated by mp4dump.",6.5,MEDIUM,1,test,2022-02-28T03:11:11Z,4
CVE-2022-27650,['CWE-276'],AV:N/AC:M/Au:S/C:P/I:P/A:P,0,containers/crun,"exec: --cap do not set inheritable capabilities

Closes: CVE-2022-27650

Signed-off-by: Giuseppe Scrivano <gscrivan@redhat.com>",1aeeed2e4fdeffb4875c0d0b439915894594c8c6,https://github.com/containers/crun/commit/1aeeed2e4fdeffb4875c0d0b439915894594c8c6,src/exec.c,crun_command_exec,"int
crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)
{
int first_arg = 0, ret = 0;
libcrun_context_t crun_context = {
0,
};
cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;
struct libcrun_container_exec_options_s exec_opts;
memset (&exec_opts, 0, sizeof (exec_opts));
exec_opts.struct_size = sizeof (exec_opts);
crun_context.preserve_fds = 0;
crun_context.listen_fds = 0;
argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);
crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);
ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);
if (UNLIKELY (ret < 0))
return ret;
crun_context.detach = exec_options.detach;
crun_context.console_socket = exec_options.console_socket;
crun_context.pid_file = exec_options.pid_file;
crun_context.preserve_fds = exec_options.preserve_fds;
if (getenv (""LISTEN_FDS""))
{
crun_context.listen_fds = strtoll (getenv (""LISTEN_FDS""), NULL, 10);
crun_context.preserve_fds += crun_context.listen_fds;
}
if (exec_options.process)
exec_opts.path = exec_options.process;
else
{
process = xmalloc0 (sizeof (*process));
int i;
process->args_len = argc;
process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));
for (i = 0; i < argc - first_arg; i++)
process->args[i] = xstrdup (argv[first_arg + i + 1]);
process->args[i] = NULL;
if (exec_options.cwd)
process->cwd = exec_options.cwd;
process->terminal = exec_options.tty;
process->env = exec_options.env;
process->env_len = exec_options.env_size;
process->user = make_oci_process_user (exec_options.user);
if (exec_options.process_label != NULL)
process->selinux_label = exec_options.process_label;
if (exec_options.apparmor != NULL)
process->apparmor_profile = exec_options.apparmor;
if (exec_options.cap_size > 0)
{
runtime_spec_schema_config_schema_process_capabilities *capabilities
= xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));
capabilities->effective = exec_options.cap;
capabilities->effective_len = exec_options.cap_size;
capabilities->inheritable = dup_array (exec_options.cap, exec_options.cap_size);
capabilities->inheritable_len = exec_options.cap_size;
capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);
capabilities->bounding_len = exec_options.cap_size;
capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);
capabilities->ambient_len = exec_options.cap_size;
capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);
capabilities->permitted_len = exec_options.cap_size;
process->capabilities = capabilities;
}
if (exec_options.no_new_privs)
process->no_new_privileges = 1;
exec_opts.process = process;
}
exec_opts.cgroup = exec_options.cgroup;
return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);
}","int
crun_command_exec (struct crun_global_arguments *VAR_0, int VAR_1, char **VAR_2, libcrun_error_t *VAR_3)
{
int VAR_4 = 0, VAR_5 = 0;
libcrun_context_t VAR_6 = {
0,
};
cleanup_process_schema VAR_7 *VAR_8 = NULL;
struct libcrun_container_exec_options_s VAR_9;
memset (&VAR_9, 0, sizeof (VAR_9));
VAR_9.struct_size = sizeof (VAR_9);
VAR_6.preserve_fds = 0;
VAR_6.listen_fds = 0;
argp_parse (&VAR_10, VAR_1, VAR_2, VAR_11, &VAR_4, &VAR_12);
crun_assert_n_args (VAR_1 - VAR_4, VAR_12.process ? 1 : 2, -1);
VAR_5 = init_libcrun_context (&VAR_6, VAR_2[VAR_4], VAR_0, VAR_3);
if (UNLIKELY (VAR_5 < 0))
return VAR_5;
VAR_6.detach = VAR_12.detach;
VAR_6.console_socket = VAR_12.console_socket;
VAR_6.pid_file = VAR_12.pid_file;
VAR_6.preserve_fds = VAR_12.preserve_fds;
if (getenv (""LISTEN_FDS""))
{
VAR_6.listen_fds = strtoll (getenv (""LISTEN_FDS""), NULL, 10);
VAR_6.preserve_fds += VAR_6.listen_fds;
}
if (VAR_12.process)
VAR_9.path = VAR_12.process;
else
{
VAR_8 = xmalloc0 (sizeof (*VAR_8));
int VAR_13;
VAR_8->args_len = VAR_1;
VAR_8->args = xmalloc0 ((VAR_1 + 1) * sizeof (*VAR_8->args));
for (VAR_13 = 0; VAR_13 < VAR_1 - VAR_4; VAR_13++)
VAR_8->args[VAR_13] = xstrdup (VAR_2[VAR_4 + VAR_13 + 1]);
VAR_8->args[VAR_13] = NULL;
if (VAR_12.cwd)
VAR_8->cwd = VAR_12.cwd;
VAR_8->terminal = VAR_12.tty;
VAR_8->env = VAR_12.env;
VAR_8->env_len = VAR_12.env_size;
VAR_8->user = make_oci_process_user (VAR_12.user);
if (VAR_12.process_label != NULL)
VAR_8->selinux_label = VAR_12.process_label;
if (VAR_12.apparmor != NULL)
VAR_8->apparmor_profile = VAR_12.apparmor;
if (VAR_12.cap_size > 0)
{
runtime_spec_schema_config_schema_process_capabilities *VAR_14
= xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));
VAR_14->effective = VAR_12.cap;
VAR_14->effective_len = VAR_12.cap_size;
VAR_14->inheritable = dup_array (VAR_12.cap, VAR_12.cap_size);
VAR_14->inheritable_len = VAR_12.cap_size;
VAR_14->bounding = dup_array (VAR_12.cap, VAR_12.cap_size);
VAR_14->bounding_len = VAR_12.cap_size;
VAR_14->ambient = dup_array (VAR_12.cap, VAR_12.cap_size);
VAR_14->ambient_len = VAR_12.cap_size;
VAR_14->permitted = dup_array (VAR_12.cap, VAR_12.cap_size);
VAR_14->permitted_len = VAR_12.cap_size;
VAR_8->capabilities = VAR_14;
}
if (VAR_12.no_new_privs)
VAR_8->no_new_privileges = 1;
VAR_9.process = VAR_8;
}
VAR_9.cgroup = VAR_12.cgroup;
return libcrun_container_exec_with_options (&VAR_6, VAR_2[VAR_4], &VAR_9, VAR_3);
}",containers/crun/1aeeed2e4fdeffb4875c0d0b439915894594c8c6/exec.c/vul/before/0.json,"int
crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)
{
  int first_arg = 0, ret = 0;
  libcrun_context_t crun_context = {
    0,
  };
  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;
  struct libcrun_container_exec_options_s exec_opts;

  memset (&exec_opts, 0, sizeof (exec_opts));
  exec_opts.struct_size = sizeof (exec_opts);

  crun_context.preserve_fds = 0;
  crun_context.listen_fds = 0;

  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);
  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);

  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);
  if (UNLIKELY (ret < 0))
    return ret;

  crun_context.detach = exec_options.detach;
  crun_context.console_socket = exec_options.console_socket;
  crun_context.pid_file = exec_options.pid_file;
  crun_context.preserve_fds = exec_options.preserve_fds;

  if (getenv (""LISTEN_FDS""))
    {
      crun_context.listen_fds = strtoll (getenv (""LISTEN_FDS""), NULL, 10);
      crun_context.preserve_fds += crun_context.listen_fds;
    }

  if (exec_options.process)
    exec_opts.path = exec_options.process;
  else
    {
      process = xmalloc0 (sizeof (*process));
      int i;

      process->args_len = argc;
      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));
      for (i = 0; i < argc - first_arg; i++)
        process->args[i] = xstrdup (argv[first_arg + i + 1]);
      process->args[i] = NULL;
      if (exec_options.cwd)
        process->cwd = exec_options.cwd;
      process->terminal = exec_options.tty;
      process->env = exec_options.env;
      process->env_len = exec_options.env_size;
      process->user = make_oci_process_user (exec_options.user);

      if (exec_options.process_label != NULL)
        process->selinux_label = exec_options.process_label;

      if (exec_options.apparmor != NULL)
        process->apparmor_profile = exec_options.apparmor;

      if (exec_options.cap_size > 0)
        {
          runtime_spec_schema_config_schema_process_capabilities *capabilities
              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));

          capabilities->effective = exec_options.cap;
          capabilities->effective_len = exec_options.cap_size;

          capabilities->inheritable = NULL;
          capabilities->inheritable_len = 0;

          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);
          capabilities->bounding_len = exec_options.cap_size;

          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);
          capabilities->ambient_len = exec_options.cap_size;

          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);
          capabilities->permitted_len = exec_options.cap_size;

          process->capabilities = capabilities;
        }

      // noNewPriviledges will remain `false` if basespec has `false` unless specified
      // Default is always `true` in generated basespec config
      if (exec_options.no_new_privs)
        process->no_new_privileges = 1;

      exec_opts.process = process;
    }

  exec_opts.cgroup = exec_options.cgroup;

  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);
}","int
crun_command_exec (struct crun_global_arguments *VAR_0, int VAR_1, char **VAR_2, libcrun_error_t *VAR_3)
{
  int VAR_4 = 0, VAR_5 = 0;
  libcrun_context_t VAR_6 = {
    0,
  };
  cleanup_process_schema VAR_7 *VAR_8 = NULL;
  struct libcrun_container_exec_options_s VAR_9;

  memset (&VAR_9, 0, sizeof (VAR_9));
  VAR_9.struct_size = sizeof (VAR_9);

  VAR_6.preserve_fds = 0;
  VAR_6.listen_fds = 0;

  argp_parse (&VAR_10, VAR_1, VAR_2, VAR_11, &VAR_4, &VAR_12);
  crun_assert_n_args (VAR_1 - VAR_4, VAR_12.process ? 1 : 2, -1);

  VAR_5 = init_libcrun_context (&VAR_6, VAR_2[VAR_4], VAR_0, VAR_3);
  if (UNLIKELY (VAR_5 < 0))
    return VAR_5;

  VAR_6.detach = VAR_12.detach;
  VAR_6.console_socket = VAR_12.console_socket;
  VAR_6.pid_file = VAR_12.pid_file;
  VAR_6.preserve_fds = VAR_12.preserve_fds;

  if (getenv (""LISTEN_FDS""))
    {
      VAR_6.listen_fds = strtoll (getenv (""LISTEN_FDS""), NULL, 10);
      VAR_6.preserve_fds += VAR_6.listen_fds;
    }

  if (VAR_12.process)
    VAR_9.path = VAR_12.process;
  else
    {
      VAR_8 = xmalloc0 (sizeof (*VAR_8));
      int VAR_13;

      VAR_8->args_len = VAR_1;
      VAR_8->args = xmalloc0 ((VAR_1 + 1) * sizeof (*VAR_8->args));
      for (VAR_13 = 0; VAR_13 < VAR_1 - VAR_4; VAR_13++)
        VAR_8->args[VAR_13] = xstrdup (VAR_2[VAR_4 + VAR_13 + 1]);
      VAR_8->args[VAR_13] = NULL;
      if (VAR_12.cwd)
        VAR_8->cwd = VAR_12.cwd;
      VAR_8->terminal = VAR_12.tty;
      VAR_8->env = VAR_12.env;
      VAR_8->env_len = VAR_12.env_size;
      VAR_8->user = make_oci_process_user (VAR_12.user);

      if (VAR_12.process_label != NULL)
        VAR_8->selinux_label = VAR_12.process_label;

      if (VAR_12.apparmor != NULL)
        VAR_8->apparmor_profile = VAR_12.apparmor;

      if (VAR_12.cap_size > 0)
        {
          runtime_spec_schema_config_schema_process_capabilities *VAR_14
              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));

          VAR_14->effective = VAR_12.cap;
          VAR_14->effective_len = VAR_12.cap_size;

          VAR_14->inheritable = NULL;
          VAR_14->inheritable_len = 0;

          VAR_14->bounding = dup_array (VAR_12.cap, VAR_12.cap_size);
          VAR_14->bounding_len = VAR_12.cap_size;

          VAR_14->ambient = dup_array (VAR_12.cap, VAR_12.cap_size);
          VAR_14->ambient_len = VAR_12.cap_size;

          VAR_14->permitted = dup_array (VAR_12.cap, VAR_12.cap_size);
          VAR_14->permitted_len = VAR_12.cap_size;

          VAR_8->capabilities = VAR_14;
        }

      /* COMMENT_0 */
      /* COMMENT_1 */
      if (VAR_12.no_new_privs)
        VAR_8->no_new_privileges = 1;

      VAR_9.process = VAR_8;
    }

  VAR_9.cgroup = VAR_12.cgroup;

  return libcrun_container_exec_with_options (&VAR_6, VAR_2[VAR_4], &VAR_9, VAR_3);
}",containers/crun/1aeeed2e4fdeffb4875c0d0b439915894594c8c6/exec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -65,8 +65,8 @@
           capabilities->effective = exec_options.cap;
           capabilities->effective_len = exec_options.cap_size;
 
-          capabilities->inheritable = dup_array (exec_options.cap, exec_options.cap_size);
-          capabilities->inheritable_len = exec_options.cap_size;
+          capabilities->inheritable = NULL;
+          capabilities->inheritable_len = 0;
 
           capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);
           capabilities->bounding_len = exec_options.cap_size;","{'deleted_lines': ['          capabilities->inheritable = dup_array (exec_options.cap, exec_options.cap_size);', '          capabilities->inheritable_len = exec_options.cap_size;'], 'added_lines': ['          capabilities->inheritable = NULL;', '          capabilities->inheritable_len = 0;']}",True,A flaw was found in crun where containers were incorrectly started with non-empty default permissions. A vulnerability was found in Moby (Docker Engine) where containers were started incorrectly with non-empty inheritable Linux process capabilities. This flaw allows an attacker with access to programs with inheritable file capabilities to elevate those capabilities to the permitted set when execve(2) runs.,7.5,HIGH,2,test,2022-02-28T10:06:50Z,4
CVE-2022-27920,['CWE-79'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,kiwix/libkiwix,"use encoded URLs for searchSuggestionHtml

Previously, the seachURL was not encoded.
This resulted in an XSS vulnerability, a concept of proof is:

start kiwix-serve
visit - http://192.168.18.1:8081/""><svg onload=""alert(1)"">
This would display an alert message.

This encodes the searchURL before passing it to searchSuggestionHtml",8136138492ab51ae8a311be589b8b131d04125ce,https://github.com/kiwix/libkiwix/commit/8136138492ab51ae8a311be589b8b131d04125ce,src/server/internalServer.cpp,InternalServer::handle_content,"std::unique_ptr<Response> InternalServer::handle_content(const RequestContext& request)
{
const std::string url = request.get_url();
const std::string pattern = url.substr((url.find_last_of('/'))+1);
if (m_verbose.load()) {
printf(""** running handle_content\n"");
}
const std::string bookName = get_book_name(request);
if (bookName.empty())
return build_homepage(request);
std::shared_ptr<zim::Archive> archive;
try {
const std::string bookId = mp_nameMapper->getIdForName(bookName);
archive = mp_library->getArchiveById(bookId);
} catch (const std::out_of_range& e) {}
if (archive == nullptr) {
std::string searchURL = m_root+""/search?pattern=""+pattern;     const std::string details = searchSuggestionHTML(searchURL, kiwix::urlDecode(pattern));
return Response::build_404(*this, request.get_full_url(), bookName, """", details);
}
auto urlStr = request.get_url().substr(bookName.size()+1);
if (urlStr[0] == '/') {
urlStr = urlStr.substr(1);
}
try {
auto entry = getEntryFromPath(*archive, urlStr);
if (entry.isRedirect() || urlStr.empty()) {
return build_redirect(bookName, getFinalItem(*archive, entry));
}
auto response = ItemResponse::build(*this, request, entry.getItem());
try {
dynamic_cast<ContentResponse&>(*response).set_taskbar(bookName, getArchiveTitle(*archive));
} catch (std::bad_cast& e) {}
if (m_verbose.load()) {
printf(""Found %s\n"", entry.getPath().c_str());
printf(""mimeType: %s\n"", entry.getItem(true).getMimetype().c_str());
}
return response;
} catch(zim::EntryNotFound& e) {
if (m_verbose.load())
printf(""Failed to find %s\n"", urlStr.c_str());
std::string searchURL = m_root+""/search?content=""+bookName+""&pattern=""+pattern;     const std::string details = searchSuggestionHTML(searchURL, kiwix::urlDecode(pattern));
return Response::build_404(*this, request.get_full_url(), bookName, getArchiveTitle(*archive), details);
}
}","std::unique_ptr<Response> InternalServer::handle_content(const RequestContext& VAR_0)
{
const std::string VAR_1 = VAR_0.get_url();
const std::string VAR_2 = VAR_1.substr((VAR_1.find_last_of('/'))+1);
if (VAR_3.load()) {
printf(""** running handle_content\n"");
}
const std::string VAR_4 = get_book_name(VAR_0);
if (VAR_4.empty())
return build_homepage(VAR_0);
std::shared_ptr<zim::Archive> VAR_5;
try {
const std::string VAR_6 = VAR_7->getIdForName(VAR_4);
VAR_5 = VAR_8->getArchiveById(VAR_6);
} catch (const std::out_of_range& VAR_9) {}
if (VAR_5 == nullptr) {
std::string VAR_10 = VAR_11+""/search?pattern=""+VAR_2; 
const std::string VAR_12 = searchSuggestionHTML(VAR_10, kiwix::urlDecode(VAR_2));
return Response::build_404(*this, VAR_0.get_full_url(), VAR_4, """", VAR_12);
}
auto VAR_13 = VAR_0.get_url().substr(VAR_4.size()+1);
if (VAR_13[0] == '/') {
VAR_13 = VAR_13.substr(1);
}
try {
auto VAR_14 = getEntryFromPath(*VAR_5, VAR_13);
if (VAR_14.isRedirect() || VAR_13.empty()) {
return build_redirect(VAR_4, getFinalItem(*VAR_5, VAR_14));
}
auto VAR_15 = ItemResponse::build(*this, VAR_0, VAR_14.getItem());
try {
VAR_16<ContentResponse&>(*VAR_15).set_taskbar(VAR_4, getArchiveTitle(*VAR_5));
} catch (std::bad_cast& VAR_9) {}
if (VAR_3.load()) {
printf(""Found %s\n"", VAR_14.getPath().c_str());
printf(""mimeType: %s\n"", VAR_14.getItem(true).getMimetype().c_str());
}
return VAR_15;
} catch(zim::EntryNotFound& VAR_9) {
if (VAR_3.load())
printf(""Failed to find %s\n"", VAR_13.c_str());
std::string VAR_10 = VAR_11+""/search?content=""+VAR_4+""&pattern=""+VAR_2; 
const std::string VAR_12 = searchSuggestionHTML(VAR_10, kiwix::urlDecode(VAR_2));
return Response::build_404(*this, VAR_0.get_full_url(), VAR_4, getArchiveTitle(*VAR_5), VAR_12);
}
}",kiwix/libkiwix/8136138492ab51ae8a311be589b8b131d04125ce/internalServer.cpp/vul/before/0.json,"std::unique_ptr<Response> InternalServer::handle_content(const RequestContext& request)
{
  const std::string url = request.get_url();
  const std::string pattern = url.substr((url.find_last_of('/'))+1);
  if (m_verbose.load()) {
    printf(""** running handle_content\n"");
  }

  const std::string bookName = get_book_name(request);
  if (bookName.empty())
    return build_homepage(request);

  std::shared_ptr<zim::Archive> archive;
  try {
    const std::string bookId = mp_nameMapper->getIdForName(bookName);
    archive = mp_library->getArchiveById(bookId);
  } catch (const std::out_of_range& e) {}

  if (archive == nullptr) {
    std::string searchURL = m_root + ""/search?pattern="" + kiwix::urlEncode(pattern, true); // Make a full search on the entire library.
    const std::string details = searchSuggestionHTML(searchURL, kiwix::urlDecode(pattern));

    return Response::build_404(*this, request.get_full_url(), bookName, """", details);
  }

  auto urlStr = request.get_url().substr(bookName.size()+1);
  if (urlStr[0] == '/') {
    urlStr = urlStr.substr(1);
  }

  try {
    auto entry = getEntryFromPath(*archive, urlStr);
    if (entry.isRedirect() || urlStr.empty()) {
      // If urlStr is empty, we want to mainPage.
      // We must do a redirection to the real page.
      return build_redirect(bookName, getFinalItem(*archive, entry));
    }
    auto response = ItemResponse::build(*this, request, entry.getItem());
    try {
      dynamic_cast<ContentResponse&>(*response).set_taskbar(bookName, getArchiveTitle(*archive));
    } catch (std::bad_cast& e) {}

    if (m_verbose.load()) {
      printf(""Found %s\n"", entry.getPath().c_str());
      printf(""mimeType: %s\n"", entry.getItem(true).getMimetype().c_str());
    }

    return response;
  } catch(zim::EntryNotFound& e) {
    if (m_verbose.load())
      printf(""Failed to find %s\n"", urlStr.c_str());

    std::string searchURL = m_root + ""/search?content="" + bookName + ""&pattern="" + kiwix::urlEncode(pattern, true); // Make a search on this specific book only.
    const std::string details = searchSuggestionHTML(searchURL, kiwix::urlDecode(pattern));

    return Response::build_404(*this, request.get_full_url(), bookName, getArchiveTitle(*archive), details);
  }
}","std::unique_ptr<Response> InternalServer::handle_content(const RequestContext& VAR_0)
{
  const std::string VAR_1 = VAR_0.get_url();
  const std::string VAR_2 = VAR_1.substr((VAR_1.find_last_of('/'))+1);
  if (VAR_3.load()) {
    printf(""** running handle_content\n"");
  }

  const std::string VAR_4 = get_book_name(VAR_0);
  if (VAR_4.empty())
    return build_homepage(VAR_0);

  std::shared_ptr<zim::Archive> VAR_5;
  try {
    const std::string VAR_6 = VAR_7->getIdForName(VAR_4);
    VAR_5 = VAR_8->getArchiveById(VAR_6);
  } catch (const std::out_of_range& VAR_9) {}

  if (VAR_5 == nullptr) {
    std::string VAR_10 = VAR_11 + ""/search?pattern="" + kiwix::urlEncode(VAR_2, true); /* COMMENT_0 */
    const std::string VAR_12 = searchSuggestionHTML(VAR_10, kiwix::urlDecode(VAR_2));

    return Response::build_404(*this, VAR_0.get_full_url(), VAR_4, """", VAR_12);
  }

  auto VAR_13 = VAR_0.get_url().substr(VAR_4.size()+1);
  if (VAR_13[0] == '/') {
    VAR_13 = VAR_13.substr(1);
  }

  try {
    auto VAR_14 = getEntryFromPath(*VAR_5, VAR_13);
    if (VAR_14.isRedirect() || VAR_13.empty()) {
      /* COMMENT_1 */
      /* COMMENT_2 */
      return build_redirect(VAR_4, getFinalItem(*VAR_5, VAR_14));
    }
    auto VAR_15 = ItemResponse::build(*this, VAR_0, VAR_14.getItem());
    try {
      VAR_16<ContentResponse&>(*VAR_15).set_taskbar(VAR_4, getArchiveTitle(*VAR_5));
    } catch (std::bad_cast& VAR_9) {}

    if (VAR_3.load()) {
      printf(""Found %s\n"", VAR_14.getPath().c_str());
      printf(""mimeType: %s\n"", VAR_14.getItem(true).getMimetype().c_str());
    }

    return VAR_15;
  } catch(zim::EntryNotFound& VAR_9) {
    if (VAR_3.load())
      printf(""Failed to find %s\n"", VAR_13.c_str());

    std::string VAR_10 = VAR_11 + ""/search?content="" + VAR_4 + ""&pattern="" + kiwix::urlEncode(VAR_2, true); /* COMMENT_3 */
    const std::string VAR_12 = searchSuggestionHTML(VAR_10, kiwix::urlDecode(VAR_2));

    return Response::build_404(*this, VAR_0.get_full_url(), VAR_4, getArchiveTitle(*VAR_5), VAR_12);
  }
}",kiwix/libkiwix/8136138492ab51ae8a311be589b8b131d04125ce/internalServer.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,7 +17,7 @@
   } catch (const std::out_of_range& e) {}
 
   if (archive == nullptr) {
-    std::string searchURL = m_root+""/search?pattern=""+pattern; // Make a full search on the entire library.
+    std::string searchURL = m_root + ""/search?pattern="" + kiwix::urlEncode(pattern, true); // Make a full search on the entire library.
     const std::string details = searchSuggestionHTML(searchURL, kiwix::urlDecode(pattern));
 
     return Response::build_404(*this, request.get_full_url(), bookName, """", details);
@@ -50,7 +50,7 @@
     if (m_verbose.load())
       printf(""Failed to find %s\n"", urlStr.c_str());
 
-    std::string searchURL = m_root+""/search?content=""+bookName+""&pattern=""+pattern; // Make a search on this specific book only.
+    std::string searchURL = m_root + ""/search?content="" + bookName + ""&pattern="" + kiwix::urlEncode(pattern, true); // Make a search on this specific book only.
     const std::string details = searchSuggestionHTML(searchURL, kiwix::urlDecode(pattern));
 
     return Response::build_404(*this, request.get_full_url(), bookName, getArchiveTitle(*archive), details);","{'deleted_lines': ['    std::string searchURL = m_root+""/search?pattern=""+pattern; // Make a full search on the entire library.', '    std::string searchURL = m_root+""/search?content=""+bookName+""&pattern=""+pattern; // Make a search on this specific book only.'], 'added_lines': ['    std::string searchURL = m_root + ""/search?pattern="" + kiwix::urlEncode(pattern, true); // Make a full search on the entire library.', '    std::string searchURL = m_root + ""/search?content="" + bookName + ""&pattern="" + kiwix::urlEncode(pattern, true); // Make a search on this specific book only.']}",True,libkiwix 10.0.0 and 10.0.1 allows XSS in the built-in webserver functionality via the search suggestions URL parameter. This is fixed in 10.1.0.,6.1,MEDIUM,1,test,2022-03-01T11:38:18Z,4
CVE-2022-1199,['CWE-416'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"ax25: Fix NULL pointer dereference in ax25_kill_by_device

When two ax25 devices attempted to establish connection, the requester use ax25_create(),
ax25_bind() and ax25_connect() to initiate connection. The receiver use ax25_rcv() to
accept connection and use ax25_create_cb() in ax25_rcv() to create ax25_cb, but the
ax25_cb->sk is NULL. When the receiver is detaching, a NULL pointer dereference bug
caused by sock_hold(sk) in ax25_kill_by_device() will happen. The corresponding
fail log is shown below:

===============================================================
BUG: KASAN: null-ptr-deref in ax25_device_event+0xfd/0x290
Call Trace:
...
ax25_device_event+0xfd/0x290
raw_notifier_call_chain+0x5e/0x70
dev_close_many+0x174/0x220
unregister_netdevice_many+0x1f7/0xa60
unregister_netdevice_queue+0x12f/0x170
unregister_netdev+0x13/0x20
mkiss_close+0xcd/0x140
tty_ldisc_release+0xc0/0x220
tty_release_struct+0x17/0xa0
tty_release+0x62d/0x670
...

This patch add condition check in ax25_kill_by_device(). If s->sk is
NULL, it will goto if branch to kill device.

Fixes: 4e0f718daf97 (""ax25: improve the incomplete fix to avoid UAF and NPD bugs"")
Reported-by: Thomas Osterried <thomas@osterried.de>
Signed-off-by: Duoming Zhou <duoming@zju.edu.cn>
Signed-off-by: David S. Miller <davem@davemloft.net>",71171ac8eb34ce7fe6b3267dce27c313ab3cb3ac,https://github.com/torvalds/linux/commit/71171ac8eb34ce7fe6b3267dce27c313ab3cb3ac,net/ax25/af_ax25.c,ax25_kill_by_device,"static void ax25_kill_by_device(struct net_device *dev)
{
ax25_dev *ax25_dev;
ax25_cb *s;
struct sock *sk;
if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)
return;
spin_lock_bh(&ax25_list_lock);
again:
ax25_for_each(s, &ax25_list) {
if (s->ax25_dev == ax25_dev) {
sk = s->sk;
sock_hold(sk);
spin_unlock_bh(&ax25_list_lock);
lock_sock(sk);
s->ax25_dev = NULL;
dev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);
ax25_dev_put(ax25_dev);
ax25_disconnect(s, ENETUNREACH);
release_sock(sk);
spin_lock_bh(&ax25_list_lock);
sock_put(sk);
goto again;
}
}
spin_unlock_bh(&ax25_list_lock);
}","static void ax25_kill_by_device(struct net_device *VAR_0)
{
ax25_dev *ax25_dev;
ax25_cb *VAR_1;
struct sock *VAR_2;
if ((ax25_dev = ax25_dev_ax25dev(VAR_0)) == NULL)
return;
spin_lock_bh(&VAR_3);
again:
ax25_for_each(VAR_1, &VAR_4) {
if (VAR_1->ax25_dev == ax25_dev) {
VAR_2 = VAR_1->sk;
sock_hold(VAR_2);
spin_unlock_bh(&VAR_3);
lock_sock(VAR_2);
VAR_1->ax25_dev = NULL;
dev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);
ax25_dev_put(ax25_dev);
ax25_disconnect(VAR_1, VAR_5);
release_sock(VAR_2);
spin_lock_bh(&VAR_3);
sock_put(VAR_2);
goto again;
}
}
spin_unlock_bh(&VAR_3);
}",torvalds/linux/71171ac8eb34ce7fe6b3267dce27c313ab3cb3ac/af_ax25.c/vul/before/0.json,"static void ax25_kill_by_device(struct net_device *dev)
{
	ax25_dev *ax25_dev;
	ax25_cb *s;
	struct sock *sk;

	if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)
		return;

	spin_lock_bh(&ax25_list_lock);
again:
	ax25_for_each(s, &ax25_list) {
		if (s->ax25_dev == ax25_dev) {
			sk = s->sk;
			if (!sk) {
				spin_unlock_bh(&ax25_list_lock);
				s->ax25_dev = NULL;
				ax25_disconnect(s, ENETUNREACH);
				spin_lock_bh(&ax25_list_lock);
				goto again;
			}
			sock_hold(sk);
			spin_unlock_bh(&ax25_list_lock);
			lock_sock(sk);
			s->ax25_dev = NULL;
			dev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);
			ax25_dev_put(ax25_dev);
			ax25_disconnect(s, ENETUNREACH);
			release_sock(sk);
			spin_lock_bh(&ax25_list_lock);
			sock_put(sk);
			/* The entry could have been deleted from the
			 * list meanwhile and thus the next pointer is
			 * no longer valid.  Play it safe and restart
			 * the scan.  Forward progress is ensured
			 * because we set s->ax25_dev to NULL and we
			 * are never passed a NULL 'dev' argument.
			 */
			goto again;
		}
	}
	spin_unlock_bh(&ax25_list_lock);
}","static void ax25_kill_by_device(struct net_device *VAR_0)
{
	ax25_dev *ax25_dev;
	ax25_cb *VAR_1;
	struct sock *VAR_2;

	if ((ax25_dev = ax25_dev_ax25dev(VAR_0)) == NULL)
		return;

	spin_lock_bh(&VAR_3);
again:
	ax25_for_each(VAR_1, &VAR_4) {
		if (VAR_1->ax25_dev == ax25_dev) {
			VAR_2 = VAR_1->sk;
			if (!VAR_2) {
				spin_unlock_bh(&VAR_3);
				VAR_1->ax25_dev = NULL;
				ax25_disconnect(VAR_1, VAR_5);
				spin_lock_bh(&VAR_3);
				goto again;
			}
			sock_hold(VAR_2);
			spin_unlock_bh(&VAR_3);
			lock_sock(VAR_2);
			VAR_1->ax25_dev = NULL;
			dev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);
			ax25_dev_put(ax25_dev);
			ax25_disconnect(VAR_1, VAR_5);
			release_sock(VAR_2);
			spin_lock_bh(&VAR_3);
			sock_put(VAR_2);
			/* COMMENT_0 */
                                                 
                                                
                                            
                                               
                                             
      
			goto again;
		}
	}
	spin_unlock_bh(&VAR_3);
}",torvalds/linux/71171ac8eb34ce7fe6b3267dce27c313ab3cb3ac/af_ax25.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,6 +12,13 @@
 	ax25_for_each(s, &ax25_list) {
 		if (s->ax25_dev == ax25_dev) {
 			sk = s->sk;
+			if (!sk) {
+				spin_unlock_bh(&ax25_list_lock);
+				s->ax25_dev = NULL;
+				ax25_disconnect(s, ENETUNREACH);
+				spin_lock_bh(&ax25_list_lock);
+				goto again;
+			}
 			sock_hold(sk);
 			spin_unlock_bh(&ax25_list_lock);
 			lock_sock(sk);","{'deleted_lines': [], 'added_lines': ['\t\t\tif (!sk) {', '\t\t\t\tspin_unlock_bh(&ax25_list_lock);', '\t\t\t\ts->ax25_dev = NULL;', '\t\t\t\tax25_disconnect(s, ENETUNREACH);', '\t\t\t\tspin_lock_bh(&ax25_list_lock);', '\t\t\t\tgoto again;', '\t\t\t}']}",True,"A flaw was found in the Linux kernel. This flaw allows an attacker to crash the Linux kernel by simulating amateur radio from the user space, resulting in a null-ptr-deref vulnerability and a use-after-free vulnerability.",7.5,HIGH,2,test,2022-03-08T08:12:23Z,4
CVE-2022-0890,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,mruby,fiber.c: should pack 15+ arguments in an array.,da48e7dbb20024c198493b8724adae1b842083aa,https://github.com/mruby/mruby/commit/da48e7dbb20024c198493b8724adae1b842083aa,mrbgems/mruby-fiber/src/fiber.c,fiber_switch,"static mrb_value
fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)
{
struct mrb_context *c = fiber_check(mrb, self);
struct mrb_context *old_c = mrb->c;
enum mrb_fiber_state status;
mrb_value value;
fiber_check_cfunc(mrb, c);
status = c->status;
switch (status) {
case MRB_FIBER_TRANSFERRED:
if (resume) {
mrb_raise(mrb, E_FIBER_ERROR, ""resuming transferred fiber"");
}
break;
case MRB_FIBER_RUNNING:
case MRB_FIBER_RESUMED:
mrb_raise(mrb, E_FIBER_ERROR, ""double resume"");
break;
case MRB_FIBER_TERMINATED:
mrb_raise(mrb, E_FIBER_ERROR, ""resuming dead fiber"");
break;
default:
break;
}
old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;
c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);
fiber_switch_context(mrb, c);
if (status == MRB_FIBER_CREATED) {
mrb_value *b, *e;
if (!c->ci->proc) {
mrb_raise(mrb, E_FIBER_ERROR, ""double resume (current)"");
}
mrb_stack_extend(mrb, len+2); 
b = c->stbase+1;
e = b + len;
while (b<e) {
*b++ = *a++;
}
if (vmexec) {
c->ci--;                    
}
c->cibase->n = len;
value = c->stbase[0] = MRB_PROC_ENV(c->cibase->proc)->stack[0];
}
else {
value = fiber_result(mrb, a, len);
if (vmexec) {
c->ci[1].stack[0] = value;
}
}
if (vmexec) {
c->vmexec = TRUE;
value = mrb_vm_exec(mrb, c->ci->proc, c->ci->pc);
mrb->c = old_c;
}
else {
MARK_CONTEXT_MODIFY(c);
}
return value;
}","static mrb_value
fiber_switch(mrb_state *VAR_0, mrb_value VAR_1, mrb_int VAR_2, const mrb_value *VAR_3, mrb_bool VAR_4, mrb_bool VAR_5)
{
struct mrb_context *VAR_6 = fiber_check(VAR_0, VAR_1);
struct mrb_context *VAR_7 = VAR_0->c;
enum mrb_fiber_state VAR_8;
mrb_value VAR_9;
fiber_check_cfunc(VAR_0, VAR_6);
VAR_8 = VAR_6->status;
switch (VAR_8) {
case VAR_10:
if (VAR_4) {
mrb_raise(VAR_0, VAR_11, ""resuming transferred fiber"");
}
break;
case VAR_12:
case VAR_13:
mrb_raise(VAR_0, VAR_11, ""double resume"");
break;
case VAR_14:
mrb_raise(VAR_0, VAR_11, ""resuming dead fiber"");
break;
default:
break;
}
VAR_7->status = VAR_4 ? VAR_13 : VAR_10;
VAR_6->prev = VAR_4 ? VAR_0->c : (VAR_6->prev ? VAR_6->prev : VAR_0->root_c);
fiber_switch_context(VAR_0, VAR_6);
if (VAR_8 == VAR_15) {
mrb_value *VAR_16, *VAR_17;
if (!VAR_6->ci->proc) {
mrb_raise(VAR_0, VAR_11, ""double resume (current)"");
}
mrb_stack_extend(VAR_0, VAR_2+2); 
VAR_16 = VAR_6->stbase+1;
VAR_17 = VAR_16 + VAR_2;
while (VAR_16<VAR_17) {
*VAR_16++ = *VAR_3++;
}
if (VAR_5) {
VAR_6->ci--;                    
}
VAR_6->cibase->n = VAR_2;
VAR_9 = VAR_6->stbase[0] = MRB_PROC_ENV(VAR_6->cibase->proc)->stack[0];
}
else {
VAR_9 = fiber_result(VAR_0, VAR_3, VAR_2);
if (VAR_5) {
VAR_6->ci[1].stack[0] = VAR_9;
}
}
if (VAR_5) {
VAR_6->vmexec = TRUE;
VAR_9 = mrb_vm_exec(VAR_0, VAR_6->ci->proc, VAR_6->ci->pc);
VAR_0->c = VAR_7;
}
else {
MARK_CONTEXT_MODIFY(VAR_6);
}
return VAR_9;
}",mruby/da48e7dbb20024c198493b8724adae1b842083aa/fiber.c/vul/before/0.json,"static mrb_value
fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)
{
  struct mrb_context *c = fiber_check(mrb, self);
  struct mrb_context *old_c = mrb->c;
  enum mrb_fiber_state status;
  mrb_value value;

  fiber_check_cfunc(mrb, c);
  status = c->status;
  switch (status) {
  case MRB_FIBER_TRANSFERRED:
    if (resume) {
      mrb_raise(mrb, E_FIBER_ERROR, ""resuming transferred fiber"");
    }
    break;
  case MRB_FIBER_RUNNING:
  case MRB_FIBER_RESUMED:
    mrb_raise(mrb, E_FIBER_ERROR, ""double resume"");
    break;
  case MRB_FIBER_TERMINATED:
    mrb_raise(mrb, E_FIBER_ERROR, ""resuming dead fiber"");
    break;
  default:
    break;
  }
  old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;
  c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);
  fiber_switch_context(mrb, c);
  if (status == MRB_FIBER_CREATED) {
    mrb_value *b, *e;

    if (!c->ci->proc) {
      mrb_raise(mrb, E_FIBER_ERROR, ""double resume (current)"");
    }
    if (vmexec) {
      c->ci--;                    /* pop dummy callinfo */
    }
    if (len >= 15) {
      mrb_stack_extend(mrb, 3);   /* for receiver, args and (optional) block */
      c->stbase[1] = mrb_ary_new_from_values(mrb, len, a);
      len = 15;
    }
    else {
      mrb_stack_extend(mrb, len+2); /* for receiver and (optional) block */
      b = c->stbase+1;
      e = b + len;
      while (b<e) {
        *b++ = *a++;
      }
    }
    c->cibase->n = len;
    value = c->stbase[0] = MRB_PROC_ENV(c->cibase->proc)->stack[0];
  }
  else {
    value = fiber_result(mrb, a, len);
    if (vmexec) {
      c->ci[1].stack[0] = value;
    }
  }

  if (vmexec) {
    c->vmexec = TRUE;
    value = mrb_vm_exec(mrb, c->ci->proc, c->ci->pc);
    mrb->c = old_c;
  }
  else {
    MARK_CONTEXT_MODIFY(c);
  }
  return value;
}","static mrb_value
fiber_switch(mrb_state *VAR_0, mrb_value VAR_1, mrb_int VAR_2, const mrb_value *VAR_3, mrb_bool VAR_4, mrb_bool VAR_5)
{
  struct mrb_context *VAR_6 = fiber_check(VAR_0, VAR_1);
  struct mrb_context *VAR_7 = VAR_0->c;
  enum mrb_fiber_state VAR_8;
  mrb_value VAR_9;

  fiber_check_cfunc(VAR_0, VAR_6);
  VAR_8 = VAR_6->status;
  switch (VAR_8) {
  case VAR_10:
    if (VAR_4) {
      mrb_raise(VAR_0, VAR_11, ""resuming transferred fiber"");
    }
    break;
  case VAR_12:
  case VAR_13:
    mrb_raise(VAR_0, VAR_11, ""double resume"");
    break;
  case VAR_14:
    mrb_raise(VAR_0, VAR_11, ""resuming dead fiber"");
    break;
  default:
    break;
  }
  VAR_7->status = VAR_4 ? VAR_13 : VAR_10;
  VAR_6->prev = VAR_4 ? VAR_0->c : (VAR_6->prev ? VAR_6->prev : VAR_0->root_c);
  fiber_switch_context(VAR_0, VAR_6);
  if (VAR_8 == VAR_15) {
    mrb_value *VAR_16, *VAR_17;

    if (!VAR_6->ci->proc) {
      mrb_raise(VAR_0, VAR_11, ""double resume (current)"");
    }
    if (VAR_5) {
      VAR_6->ci--;                    /* COMMENT_0 */
    }
    if (VAR_2 >= 15) {
      mrb_stack_extend(VAR_0, 3);   /* COMMENT_1 */
      VAR_6->stbase[1] = mrb_ary_new_from_values(VAR_0, VAR_2, VAR_3);
      VAR_2 = 15;
    }
    else {
      mrb_stack_extend(VAR_0, VAR_2+2); /* COMMENT_2 */
      VAR_16 = VAR_6->stbase+1;
      VAR_17 = VAR_16 + VAR_2;
      while (VAR_16<VAR_17) {
        *VAR_16++ = *VAR_3++;
      }
    }
    VAR_6->cibase->n = VAR_2;
    VAR_9 = VAR_6->stbase[0] = MRB_PROC_ENV(VAR_6->cibase->proc)->stack[0];
  }
  else {
    VAR_9 = fiber_result(VAR_0, VAR_3, VAR_2);
    if (VAR_5) {
      VAR_6->ci[1].stack[0] = VAR_9;
    }
  }

  if (VAR_5) {
    VAR_6->vmexec = TRUE;
    VAR_9 = mrb_vm_exec(VAR_0, VAR_6->ci->proc, VAR_6->ci->pc);
    VAR_0->c = VAR_7;
  }
  else {
    MARK_CONTEXT_MODIFY(VAR_6);
  }
  return VAR_9;
}",mruby/da48e7dbb20024c198493b8724adae1b842083aa/fiber.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -33,14 +33,21 @@
     if (!c->ci->proc) {
       mrb_raise(mrb, E_FIBER_ERROR, ""double resume (current)"");
     }
-    mrb_stack_extend(mrb, len+2); /* for receiver and (optional) block */
-    b = c->stbase+1;
-    e = b + len;
-    while (b<e) {
-      *b++ = *a++;
-    }
     if (vmexec) {
       c->ci--;                    /* pop dummy callinfo */
+    }
+    if (len >= 15) {
+      mrb_stack_extend(mrb, 3);   /* for receiver, args and (optional) block */
+      c->stbase[1] = mrb_ary_new_from_values(mrb, len, a);
+      len = 15;
+    }
+    else {
+      mrb_stack_extend(mrb, len+2); /* for receiver and (optional) block */
+      b = c->stbase+1;
+      e = b + len;
+      while (b<e) {
+        *b++ = *a++;
+      }
     }
     c->cibase->n = len;
     value = c->stbase[0] = MRB_PROC_ENV(c->cibase->proc)->stack[0];","{'deleted_lines': ['    mrb_stack_extend(mrb, len+2); /* for receiver and (optional) block */', '    b = c->stbase+1;', '    e = b + len;', '    while (b<e) {', '      *b++ = *a++;', '    }'], 'added_lines': ['    }', '    if (len >= 15) {', '      mrb_stack_extend(mrb, 3);   /* for receiver, args and (optional) block */', '      c->stbase[1] = mrb_ary_new_from_values(mrb, len, a);', '      len = 15;', '    }', '    else {', '      mrb_stack_extend(mrb, len+2); /* for receiver and (optional) block */', '      b = c->stbase+1;', '      e = b + len;', '      while (b<e) {', '        *b++ = *a++;', '      }']}",True,NULL Pointer Dereference in GitHub repository mruby/mruby prior to 3.2.,5.5,MEDIUM,1,test,2022-03-09T06:20:13Z,4
CVE-2022-0943,['CWE-122'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,vim,"patch 8.2.4563: ""z="" in Visual mode may go beyond the end of the line

Problem:    ""z="" in Visual mode may go beyond the end of the line.
Solution:   Adjust ""badlen"".",5c68617d395f9d7b824f68475b24ce3e38d653a3,https://github.com/vim/vim/commit/5c68617d395f9d7b824f68475b24ce3e38d653a3,src/spellsuggest.c,spell_suggest,"void
spell_suggest(int count)
{
char_u*line;
pos_Tprev_cursor = curwin->w_cursor;
char_uwcopy[MAXWLEN + 2];
char_u*p;
inti;
intc;
suginfo_Tsug;
suggest_T*stp;
intmouse_used;
intneed_cap;
intlimit;
intselected = count;
intbadlen = 0;
intmsg_scroll_save = msg_scroll;
intwo_spell_save = curwin->w_p_spell;
if (!curwin->w_p_spell)
{
did_set_spelllang(curwin);
curwin->w_p_spell = TRUE;
}
if (*curwin->w_s->b_p_spl == NUL)
{
emsg(_(e_spell_checking_is_not_possible));
return;
}
if (VIsual_active)
{
if (curwin->w_cursor.lnum != VIsual.lnum)
{
vim_beep(BO_SPELL);
return;
}
badlen = (int)curwin->w_cursor.col - (int)VIsual.col;
if (badlen < 0)
badlen = -badlen;
else
curwin->w_cursor.col = VIsual.col;
++badlen;
end_visual_mode();
}
else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0
|| curwin->w_cursor.col > prev_cursor.col)
{
curwin->w_cursor = prev_cursor;
line = ml_get_curline();
p = line + curwin->w_cursor.col;
while (p > line && spell_iswordp_nmw(p, curwin))
MB_PTR_BACK(line, p);
while (*p != NUL && !spell_iswordp_nmw(p, curwin))
MB_PTR_ADV(p);
if (!spell_iswordp_nmw(p, curwin)){
beep_flush();
return;
}
curwin->w_cursor.col = (colnr_T)(p - line);
}
need_cap = check_need_cap(curwin->w_cursor.lnum, curwin->w_cursor.col);
line = vim_strsave(ml_get_curline());
if (line == NULL)
goto skip;
if (sps_limit > (int)Rows - 2)
limit = (int)Rows - 2;
else
limit = sps_limit;
spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug, limit,
TRUE, need_cap, TRUE);
if (sug.su_ga.ga_len == 0)
msg(_(""Sorry, no suggestions""));
else if (count > 0)
{
if (count > sug.su_ga.ga_len)
smsg(_(""Sorry, only %ld suggestions""), (long)sug.su_ga.ga_len);
}
else
{
#ifdef FEAT_RIGHTLEFT
cmdmsg_rl = curwin->w_p_rl;
if (cmdmsg_rl)
msg_col = Columns - 1;
#endif
msg_start();
msg_row = Rows - 1;lines_left = Rows;vim_snprintf((char *)IObuff, IOSIZE, _(""Change \""%.*s\"" to:""),
sug.su_badlen, sug.su_badptr);
#ifdef FEAT_RIGHTLEFT
if (cmdmsg_rl && STRNCMP(IObuff, ""Change"", 6) == 0)
{
vim_snprintf((char *)IObuff, IOSIZE, "":ot \""%.*s\"" egnahC"",
sug.su_badlen, sug.su_badptr);
}
#endif
msg_puts((char *)IObuff);
msg_clr_eos();
msg_putchar('\n');
msg_scroll = TRUE;
for (i = 0; i < sug.su_ga.ga_len; ++i)
{
stp = &SUG(sug.su_ga, i);
vim_strncpy(wcopy, stp->st_word, MAXWLEN);
if (sug.su_badlen > stp->st_orglen)
vim_strncpy(wcopy + stp->st_wordlen,
sug.su_badptr + stp->st_orglen,
sug.su_badlen - stp->st_orglen);
vim_snprintf((char *)IObuff, IOSIZE, ""%2d"", i + 1);
#ifdef FEAT_RIGHTLEFT
if (cmdmsg_rl)
rl_mirror(IObuff);
#endif
msg_puts((char *)IObuff);
vim_snprintf((char *)IObuff, IOSIZE, "" \""%s\"""", wcopy);
msg_puts((char *)IObuff);
if (sug.su_badlen < stp->st_orglen)
{
vim_snprintf((char *)IObuff, IOSIZE, _("" < \""%.*s\""""),
stp->st_orglen, sug.su_badptr);
msg_puts((char *)IObuff);
}
if (p_verbose > 0)
{
if (sps_flags & (SPS_DOUBLE | SPS_BEST))
vim_snprintf((char *)IObuff, IOSIZE, "" (%s%d - %d)"",
stp->st_salscore ? ""s "" : """",
stp->st_score, stp->st_altscore);
else
vim_snprintf((char *)IObuff, IOSIZE, "" (%d)"",
stp->st_score);
#ifdef FEAT_RIGHTLEFT
if (cmdmsg_rl)
rl_mirror(IObuff + 1);
#endif
msg_advance(30);
msg_puts((char *)IObuff);
}
msg_putchar('\n');
}
#ifdef FEAT_RIGHTLEFT
cmdmsg_rl = FALSE;
msg_col = 0;
#endif
selected = prompt_for_number(&mouse_used);
if (mouse_used)
selected -= lines_left;
lines_left = Rows;msg_scroll = msg_scroll_save;
}
if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor() == OK)
{
VIM_CLEAR(repl_from);
VIM_CLEAR(repl_to);
stp = &SUG(sug.su_ga, selected - 1);
if (sug.su_badlen > stp->st_orglen)
{
repl_from = vim_strnsave(sug.su_badptr, sug.su_badlen);
vim_snprintf((char *)IObuff, IOSIZE, ""%s%.*s"", stp->st_word,
sug.su_badlen - stp->st_orglen,
sug.su_badptr + stp->st_orglen);
repl_to = vim_strsave(IObuff);
}
else
{
repl_from = vim_strnsave(sug.su_badptr, stp->st_orglen);
repl_to = vim_strsave(stp->st_word);
}
p = alloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1);
if (p != NULL)
{
c = (int)(sug.su_badptr - line);
mch_memmove(p, line, c);
STRCPY(p + c, stp->st_word);
STRCAT(p, sug.su_badptr + stp->st_orglen);
ResetRedobuff();
AppendToRedobuff((char_u *)""ciw"");
AppendToRedobuffLit(p + c,
stp->st_wordlen + sug.su_badlen - stp->st_orglen);
AppendCharToRedobuff(ESC);
ml_replace(curwin->w_cursor.lnum, p, FALSE);
curwin->w_cursor.col = c;
changed_bytes(curwin->w_cursor.lnum, c);
}
}
else
curwin->w_cursor = prev_cursor;
spell_find_cleanup(&sug);
skip:
vim_free(line);
curwin->w_p_spell = wo_spell_save;
}","void
spell_suggest(int VAR_0)
{
char_u*VAR_1;
pos_TVAR_2 = VAR_3->w_cursor;
char_uVAR_4[VAR_5 + 2];
char_u*VAR_6;
intVAR_7;
intVAR_8;
suginfo_TVAR_9;
suggest_T*VAR_10;
intVAR_11;
intVAR_12;
intVAR_13;
intVAR_14 = VAR_0;
intVAR_15 = 0;
intVAR_16 = VAR_17;
intVAR_18 = VAR_3->w_p_spell;
if (!VAR_3->w_p_spell)
{
did_set_spelllang(VAR_3);
VAR_3->w_p_spell = TRUE;
}
if (*VAR_3->w_s->b_p_spl == VAR_19)
{
emsg(_(VAR_20));
return;
}
if (VAR_21)
{
if (VAR_3->w_cursor.lnum != VAR_22.lnum)
{
vim_beep(VAR_23);
return;
}
VAR_15 = (int)VAR_3->w_cursor.col - (int)VAR_22.col;
if (VAR_15 < 0)
VAR_15 = -VAR_15;
else
VAR_3->w_cursor.col = VAR_22.col;
++VAR_15;
end_visual_mode();
}
else if (spell_move_to(VAR_3, VAR_24, TRUE, TRUE, NULL) == 0
|| VAR_3->w_cursor.col > VAR_2.col)
{
VAR_3->w_cursor = VAR_2;
VAR_1 = ml_get_curline();
VAR_6 = VAR_1 + VAR_3->w_cursor.col;
while (VAR_6 > VAR_1 && spell_iswordp_nmw(VAR_6, VAR_3))
MB_PTR_BACK(VAR_1, VAR_6);
while (*VAR_6 != VAR_19 && !spell_iswordp_nmw(VAR_6, VAR_3))
MB_PTR_ADV(VAR_6);
if (!spell_iswordp_nmw(VAR_6, VAR_3))
{
beep_flush();
return;
}
VAR_3->w_cursor.col = (VAR_25)(VAR_6 - VAR_1);
}
VAR_12 = check_need_cap(VAR_3->w_cursor.lnum, VAR_3->w_cursor.col);
VAR_1 = vim_strsave(ml_get_curline());
if (VAR_1 == NULL)
goto skip;
if (VAR_26 > (int)VAR_27 - 2)
VAR_13 = (int)VAR_27 - 2;
else
VAR_13 = VAR_26;
spell_find_suggest(VAR_1 + VAR_3->w_cursor.col, VAR_15, &VAR_9, VAR_13,
TRUE, VAR_12, TRUE);
if (VAR_9.su_ga.ga_len == 0)
msg(_(""Sorry, no suggestions""));
else if (VAR_0 > 0)
{
if (VAR_0 > VAR_9.su_ga.ga_len)
smsg(_(""Sorry, only %ld suggestions""), (long)VAR_9.su_ga.ga_len);
}
else
{
#ifdef VAR_28
VAR_29 = VAR_3->w_p_rl;
if (VAR_29)
VAR_30 = VAR_31 - 1;
#endif
msg_start();
VAR_32 = VAR_27 - 1;
VAR_33 = VAR_27;
vim_snprintf((char *)VAR_34, VAR_35, _(""Change \""%.*s\"" to:""),
VAR_9.su_badlen, VAR_9.su_badptr);
#ifdef VAR_28
if (VAR_29 && STRNCMP(VAR_34, ""Change"", 6) == 0)
{
vim_snprintf((char *)VAR_34, VAR_35, "":ot \""%.*s\"" egnahC"",
VAR_9.su_badlen, VAR_9.su_badptr);
}
#endif
msg_puts((char *)VAR_34);
msg_clr_eos();
msg_putchar('\n');
VAR_17 = TRUE;
for (VAR_7 = 0; VAR_7 < VAR_9.su_ga.ga_len; ++VAR_7)
{
VAR_10 = &SUG(VAR_9.su_ga, VAR_7);
vim_strncpy(VAR_4, VAR_10->st_word, VAR_5);
if (VAR_9.su_badlen > VAR_10->st_orglen)
vim_strncpy(VAR_4 + VAR_10->st_wordlen,
VAR_9.su_badptr + VAR_10->st_orglen,
VAR_9.su_badlen - VAR_10->st_orglen);
vim_snprintf((char *)VAR_34, VAR_35, ""%2d"", VAR_7 + 1);
#ifdef VAR_28
if (VAR_29)
rl_mirror(VAR_34);
#endif
msg_puts((char *)VAR_34);
vim_snprintf((char *)VAR_34, VAR_35, "" \""%s\"""", VAR_4);
msg_puts((char *)VAR_34);
if (VAR_9.su_badlen < VAR_10->st_orglen)
{
vim_snprintf((char *)VAR_34, VAR_35, _("" < \""%.*s\""""),
VAR_10->st_orglen, VAR_9.su_badptr);
msg_puts((char *)VAR_34);
}
if (VAR_36 > 0)
{
if (VAR_37 & (VAR_38 | VAR_39))
vim_snprintf((char *)VAR_34, VAR_35, "" (%s%d - %d)"",
VAR_10->st_salscore ? ""s "" : """",
VAR_10->st_score, VAR_10->st_altscore);
else
vim_snprintf((char *)VAR_34, VAR_35, "" (%d)"",
VAR_10->st_score);
#ifdef VAR_28
if (VAR_29)
rl_mirror(VAR_34 + 1);
#endif
msg_advance(30);
msg_puts((char *)VAR_34);
}
msg_putchar('\n');
}
#ifdef VAR_28
VAR_29 = FALSE;
VAR_30 = 0;
#endif
VAR_14 = prompt_for_number(&VAR_11);
if (VAR_11)
VAR_14 -= VAR_33;
VAR_33 = VAR_27;
VAR_17 = VAR_16;
}
if (VAR_14 > 0 && VAR_14 <= VAR_9.su_ga.ga_len && u_save_cursor() == VAR_40)
{
VIM_CLEAR(VAR_41);
VIM_CLEAR(VAR_42);
VAR_10 = &SUG(VAR_9.su_ga, VAR_14 - 1);
if (VAR_9.su_badlen > VAR_10->st_orglen)
{
VAR_41 = vim_strnsave(VAR_9.su_badptr, VAR_9.su_badlen);
vim_snprintf((char *)VAR_34, VAR_35, ""%s%.*s"", VAR_10->st_word,
VAR_9.su_badlen - VAR_10->st_orglen,
VAR_9.su_badptr + VAR_10->st_orglen);
VAR_42 = vim_strsave(VAR_34);
}
else
{
VAR_41 = vim_strnsave(VAR_9.su_badptr, VAR_10->st_orglen);
VAR_42 = vim_strsave(VAR_10->st_word);
}
VAR_6 = alloc(STRLEN(VAR_1) - VAR_10->st_orglen + VAR_10->st_wordlen + 1);
if (VAR_6 != NULL)
{
VAR_8 = (int)(VAR_9.su_badptr - VAR_1);
mch_memmove(VAR_6, VAR_1, VAR_8);
STRCPY(VAR_6 + VAR_8, VAR_10->st_word);
STRCAT(VAR_6, VAR_9.su_badptr + VAR_10->st_orglen);
ResetRedobuff();
AppendToRedobuff((char_u *)""ciw"");
AppendToRedobuffLit(VAR_6 + VAR_8,
VAR_10->st_wordlen + VAR_9.su_badlen - VAR_10->st_orglen);
AppendCharToRedobuff(VAR_43);
ml_replace(VAR_3->w_cursor.lnum, VAR_6, FALSE);
VAR_3->w_cursor.col = VAR_8;
changed_bytes(VAR_3->w_cursor.lnum, VAR_8);
}
}
else
VAR_3->w_cursor = VAR_2;
spell_find_cleanup(&VAR_9);
skip:
vim_free(VAR_1);
VAR_3->w_p_spell = VAR_18;
}",vim/5c68617d395f9d7b824f68475b24ce3e38d653a3/spellsuggest.c/vul/before/0.json,"void
spell_suggest(int count)
{
    char_u	*line;
    pos_T	prev_cursor = curwin->w_cursor;
    char_u	wcopy[MAXWLEN + 2];
    char_u	*p;
    int		i;
    int		c;
    suginfo_T	sug;
    suggest_T	*stp;
    int		mouse_used;
    int		need_cap;
    int		limit;
    int		selected = count;
    int		badlen = 0;
    int		msg_scroll_save = msg_scroll;
    int		wo_spell_save = curwin->w_p_spell;

    if (!curwin->w_p_spell)
    {
	did_set_spelllang(curwin);
	curwin->w_p_spell = TRUE;
    }

    if (*curwin->w_s->b_p_spl == NUL)
    {
	emsg(_(e_spell_checking_is_not_possible));
	return;
    }

    if (VIsual_active)
    {
	// Use the Visually selected text as the bad word.  But reject
	// a multi-line selection.
	if (curwin->w_cursor.lnum != VIsual.lnum)
	{
	    vim_beep(BO_SPELL);
	    return;
	}
	badlen = (int)curwin->w_cursor.col - (int)VIsual.col;
	if (badlen < 0)
	    badlen = -badlen;
	else
	    curwin->w_cursor.col = VIsual.col;
	++badlen;
	end_visual_mode();
	// make sure we don't include the NUL at the end of the line
	line = ml_get_curline();
	if (badlen > STRLEN(line) - curwin->w_cursor.col)
	    badlen = STRLEN(line) - curwin->w_cursor.col;
    }
    // Find the start of the badly spelled word.
    else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0
	    || curwin->w_cursor.col > prev_cursor.col)
    {
	// No bad word or it starts after the cursor: use the word under the
	// cursor.
	curwin->w_cursor = prev_cursor;
	line = ml_get_curline();
	p = line + curwin->w_cursor.col;
	// Backup to before start of word.
	while (p > line && spell_iswordp_nmw(p, curwin))
	    MB_PTR_BACK(line, p);
	// Forward to start of word.
	while (*p != NUL && !spell_iswordp_nmw(p, curwin))
	    MB_PTR_ADV(p);

	if (!spell_iswordp_nmw(p, curwin))		// No word found.
	{
	    beep_flush();
	    return;
	}
	curwin->w_cursor.col = (colnr_T)(p - line);
    }

    // Get the word and its length.

    // Figure out if the word should be capitalised.
    need_cap = check_need_cap(curwin->w_cursor.lnum, curwin->w_cursor.col);

    // Make a copy of current line since autocommands may free the line.
    line = vim_strsave(ml_get_curline());
    if (line == NULL)
	goto skip;

    // Get the list of suggestions.  Limit to 'lines' - 2 or the number in
    // 'spellsuggest', whatever is smaller.
    if (sps_limit > (int)Rows - 2)
	limit = (int)Rows - 2;
    else
	limit = sps_limit;
    spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug, limit,
							TRUE, need_cap, TRUE);

    if (sug.su_ga.ga_len == 0)
	msg(_(""Sorry, no suggestions""));
    else if (count > 0)
    {
	if (count > sug.su_ga.ga_len)
	    smsg(_(""Sorry, only %ld suggestions""), (long)sug.su_ga.ga_len);
    }
    else
    {
#ifdef FEAT_RIGHTLEFT
	// When 'rightleft' is set the list is drawn right-left.
	cmdmsg_rl = curwin->w_p_rl;
	if (cmdmsg_rl)
	    msg_col = Columns - 1;
#endif

	// List the suggestions.
	msg_start();
	msg_row = Rows - 1;	// for when 'cmdheight' > 1
	lines_left = Rows;	// avoid more prompt
	vim_snprintf((char *)IObuff, IOSIZE, _(""Change \""%.*s\"" to:""),
						sug.su_badlen, sug.su_badptr);
#ifdef FEAT_RIGHTLEFT
	if (cmdmsg_rl && STRNCMP(IObuff, ""Change"", 6) == 0)
	{
	    // And now the rabbit from the high hat: Avoid showing the
	    // untranslated message rightleft.
	    vim_snprintf((char *)IObuff, IOSIZE, "":ot \""%.*s\"" egnahC"",
						sug.su_badlen, sug.su_badptr);
	}
#endif
	msg_puts((char *)IObuff);
	msg_clr_eos();
	msg_putchar('\n');

	msg_scroll = TRUE;
	for (i = 0; i < sug.su_ga.ga_len; ++i)
	{
	    stp = &SUG(sug.su_ga, i);

	    // The suggested word may replace only part of the bad word, add
	    // the not replaced part.
	    vim_strncpy(wcopy, stp->st_word, MAXWLEN);
	    if (sug.su_badlen > stp->st_orglen)
		vim_strncpy(wcopy + stp->st_wordlen,
					       sug.su_badptr + stp->st_orglen,
					      sug.su_badlen - stp->st_orglen);
	    vim_snprintf((char *)IObuff, IOSIZE, ""%2d"", i + 1);
#ifdef FEAT_RIGHTLEFT
	    if (cmdmsg_rl)
		rl_mirror(IObuff);
#endif
	    msg_puts((char *)IObuff);

	    vim_snprintf((char *)IObuff, IOSIZE, "" \""%s\"""", wcopy);
	    msg_puts((char *)IObuff);

	    // The word may replace more than ""su_badlen"".
	    if (sug.su_badlen < stp->st_orglen)
	    {
		vim_snprintf((char *)IObuff, IOSIZE, _("" < \""%.*s\""""),
					       stp->st_orglen, sug.su_badptr);
		msg_puts((char *)IObuff);
	    }

	    if (p_verbose > 0)
	    {
		// Add the score.
		if (sps_flags & (SPS_DOUBLE | SPS_BEST))
		    vim_snprintf((char *)IObuff, IOSIZE, "" (%s%d - %d)"",
			stp->st_salscore ? ""s "" : """",
			stp->st_score, stp->st_altscore);
		else
		    vim_snprintf((char *)IObuff, IOSIZE, "" (%d)"",
			    stp->st_score);
#ifdef FEAT_RIGHTLEFT
		if (cmdmsg_rl)
		    // Mirror the numbers, but keep the leading space.
		    rl_mirror(IObuff + 1);
#endif
		msg_advance(30);
		msg_puts((char *)IObuff);
	    }
	    msg_putchar('\n');
	}

#ifdef FEAT_RIGHTLEFT
	cmdmsg_rl = FALSE;
	msg_col = 0;
#endif
	// Ask for choice.
	selected = prompt_for_number(&mouse_used);
	if (mouse_used)
	    selected -= lines_left;
	lines_left = Rows;		// avoid more prompt
	// don't delay for 'smd' in normal_cmd()
	msg_scroll = msg_scroll_save;
    }

    if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor() == OK)
    {
	// Save the from and to text for :spellrepall.
	VIM_CLEAR(repl_from);
	VIM_CLEAR(repl_to);

	stp = &SUG(sug.su_ga, selected - 1);
	if (sug.su_badlen > stp->st_orglen)
	{
	    // Replacing less than ""su_badlen"", append the remainder to
	    // repl_to.
	    repl_from = vim_strnsave(sug.su_badptr, sug.su_badlen);
	    vim_snprintf((char *)IObuff, IOSIZE, ""%s%.*s"", stp->st_word,
		    sug.su_badlen - stp->st_orglen,
					      sug.su_badptr + stp->st_orglen);
	    repl_to = vim_strsave(IObuff);
	}
	else
	{
	    // Replacing su_badlen or more, use the whole word.
	    repl_from = vim_strnsave(sug.su_badptr, stp->st_orglen);
	    repl_to = vim_strsave(stp->st_word);
	}

	// Replace the word.
	p = alloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1);
	if (p != NULL)
	{
	    c = (int)(sug.su_badptr - line);
	    mch_memmove(p, line, c);
	    STRCPY(p + c, stp->st_word);
	    STRCAT(p, sug.su_badptr + stp->st_orglen);

	    // For redo we use a change-word command.
	    ResetRedobuff();
	    AppendToRedobuff((char_u *)""ciw"");
	    AppendToRedobuffLit(p + c,
			    stp->st_wordlen + sug.su_badlen - stp->st_orglen);
	    AppendCharToRedobuff(ESC);

	    // ""p"" may be freed here
	    ml_replace(curwin->w_cursor.lnum, p, FALSE);
	    curwin->w_cursor.col = c;

	    changed_bytes(curwin->w_cursor.lnum, c);
	}
    }
    else
	curwin->w_cursor = prev_cursor;

    spell_find_cleanup(&sug);
skip:
    vim_free(line);
    curwin->w_p_spell = wo_spell_save;
}","void
spell_suggest(int VAR_0)
{
    char_u	*VAR_1;
    pos_T	VAR_2 = VAR_3->w_cursor;
    char_u	VAR_4[VAR_5 + 2];
    char_u	*VAR_6;
    int		VAR_7;
    int		VAR_8;
    suginfo_T	VAR_9;
    suggest_T	*VAR_10;
    int		VAR_11;
    int		VAR_12;
    int		VAR_13;
    int		VAR_14 = VAR_0;
    int		VAR_15 = 0;
    int		VAR_16 = VAR_17;
    int		VAR_18 = VAR_3->w_p_spell;

    if (!VAR_3->w_p_spell)
    {
	did_set_spelllang(VAR_3);
	VAR_3->w_p_spell = TRUE;
    }

    if (*VAR_3->w_s->b_p_spl == VAR_19)
    {
	emsg(_(VAR_20));
	return;
    }

    if (VAR_21)
    {
	/* COMMENT_0 */
	/* COMMENT_1 */
	if (VAR_3->w_cursor.lnum != VAR_22.lnum)
	{
	    vim_beep(VAR_23);
	    return;
	}
	VAR_15 = (int)VAR_3->w_cursor.col - (int)VAR_22.col;
	if (VAR_15 < 0)
	    VAR_15 = -VAR_15;
	else
	    VAR_3->w_cursor.col = VAR_22.col;
	++VAR_15;
	end_visual_mode();
	/* COMMENT_2 */
	VAR_1 = ml_get_curline();
	if (VAR_15 > STRLEN(VAR_1) - VAR_3->w_cursor.col)
	    VAR_15 = STRLEN(VAR_1) - VAR_3->w_cursor.col;
    }
    /* COMMENT_3 */
    else if (spell_move_to(VAR_3, VAR_24, TRUE, TRUE, NULL) == 0
	    || VAR_3->w_cursor.col > VAR_2.col)
    {
	/* COMMENT_4 */
	/* COMMENT_5 */
	VAR_3->w_cursor = VAR_2;
	VAR_1 = ml_get_curline();
	VAR_6 = VAR_1 + VAR_3->w_cursor.col;
	/* COMMENT_6 */
	while (VAR_6 > VAR_1 && spell_iswordp_nmw(VAR_6, VAR_3))
	    MB_PTR_BACK(VAR_1, VAR_6);
	/* COMMENT_7 */
	while (*VAR_6 != VAR_19 && !spell_iswordp_nmw(VAR_6, VAR_3))
	    MB_PTR_ADV(VAR_6);

	if (!spell_iswordp_nmw(VAR_6, VAR_3))		/* COMMENT_8 */
	{
	    beep_flush();
	    return;
	}
	VAR_3->w_cursor.col = (VAR_25)(VAR_6 - VAR_1);
    }

    /* COMMENT_9 */

    /* COMMENT_10 */
    VAR_12 = check_need_cap(VAR_3->w_cursor.lnum, VAR_3->w_cursor.col);

    /* COMMENT_11 */
    VAR_1 = vim_strsave(ml_get_curline());
    if (VAR_1 == NULL)
	goto skip;

    /* COMMENT_12 */
    /* COMMENT_13 */
    if (VAR_26 > (int)VAR_27 - 2)
	VAR_13 = (int)VAR_27 - 2;
    else
	VAR_13 = VAR_26;
    spell_find_suggest(VAR_1 + VAR_3->w_cursor.col, VAR_15, &VAR_9, VAR_13,
							TRUE, VAR_12, TRUE);

    if (VAR_9.su_ga.ga_len == 0)
	msg(_(""Sorry, no suggestions""));
    else if (VAR_0 > 0)
    {
	if (VAR_0 > VAR_9.su_ga.ga_len)
	    smsg(_(""Sorry, only %ld suggestions""), (long)VAR_9.su_ga.ga_len);
    }
    else
    {
#ifdef VAR_28
	/* COMMENT_14 */
	VAR_29 = VAR_3->w_p_rl;
	if (VAR_29)
	    VAR_30 = VAR_31 - 1;
#endif

	/* COMMENT_15 */
	msg_start();
	VAR_32 = VAR_27 - 1;	/* COMMENT_16 */
	VAR_33 = VAR_27;	/* COMMENT_17 */
	vim_snprintf((char *)VAR_34, VAR_35, _(""Change \""%.*s\"" to:""),
						VAR_9.su_badlen, VAR_9.su_badptr);
#ifdef VAR_28
	if (VAR_29 && STRNCMP(VAR_34, ""Change"", 6) == 0)
	{
	    /* COMMENT_18 */
	    /* COMMENT_19 */
	    vim_snprintf((char *)VAR_34, VAR_35, "":ot \""%.*s\"" egnahC"",
						VAR_9.su_badlen, VAR_9.su_badptr);
	}
#endif
	msg_puts((char *)VAR_34);
	msg_clr_eos();
	msg_putchar('\n');

	VAR_17 = TRUE;
	for (VAR_7 = 0; VAR_7 < VAR_9.su_ga.ga_len; ++VAR_7)
	{
	    VAR_10 = &SUG(VAR_9.su_ga, VAR_7);

	    /* COMMENT_20 */
	    /* COMMENT_21 */
	    vim_strncpy(VAR_4, VAR_10->st_word, VAR_5);
	    if (VAR_9.su_badlen > VAR_10->st_orglen)
		vim_strncpy(VAR_4 + VAR_10->st_wordlen,
					       VAR_9.su_badptr + VAR_10->st_orglen,
					      VAR_9.su_badlen - VAR_10->st_orglen);
	    vim_snprintf((char *)VAR_34, VAR_35, ""%2d"", VAR_7 + 1);
#ifdef VAR_28
	    if (VAR_29)
		rl_mirror(VAR_34);
#endif
	    msg_puts((char *)VAR_34);

	    vim_snprintf((char *)VAR_34, VAR_35, "" \""%s\"""", VAR_4);
	    msg_puts((char *)VAR_34);

	    /* COMMENT_22 */
	    if (VAR_9.su_badlen < VAR_10->st_orglen)
	    {
		vim_snprintf((char *)VAR_34, VAR_35, _("" < \""%.*s\""""),
					       VAR_10->st_orglen, VAR_9.su_badptr);
		msg_puts((char *)VAR_34);
	    }

	    if (VAR_36 > 0)
	    {
		/* COMMENT_23 */
		if (VAR_37 & (VAR_38 | VAR_39))
		    vim_snprintf((char *)VAR_34, VAR_35, "" (%s%d - %d)"",
			VAR_10->st_salscore ? ""s "" : """",
			VAR_10->st_score, VAR_10->st_altscore);
		else
		    vim_snprintf((char *)VAR_34, VAR_35, "" (%d)"",
			    VAR_10->st_score);
#ifdef VAR_28
		if (VAR_29)
		    /* COMMENT_24 */
		    rl_mirror(VAR_34 + 1);
#endif
		msg_advance(30);
		msg_puts((char *)VAR_34);
	    }
	    msg_putchar('\n');
	}

#ifdef VAR_28
	VAR_29 = FALSE;
	VAR_30 = 0;
#endif
	/* COMMENT_25 */
	VAR_14 = prompt_for_number(&VAR_11);
	if (VAR_11)
	    VAR_14 -= VAR_33;
	VAR_33 = VAR_27;		/* COMMENT_17 */
	/* COMMENT_26 */
	VAR_17 = VAR_16;
    }

    if (VAR_14 > 0 && VAR_14 <= VAR_9.su_ga.ga_len && u_save_cursor() == VAR_40)
    {
	/* COMMENT_27 */
	VIM_CLEAR(VAR_41);
	VIM_CLEAR(VAR_42);

	VAR_10 = &SUG(VAR_9.su_ga, VAR_14 - 1);
	if (VAR_9.su_badlen > VAR_10->st_orglen)
	{
	    /* COMMENT_28 */
	    /* COMMENT_29 */
	    VAR_41 = vim_strnsave(VAR_9.su_badptr, VAR_9.su_badlen);
	    vim_snprintf((char *)VAR_34, VAR_35, ""%s%.*s"", VAR_10->st_word,
		    VAR_9.su_badlen - VAR_10->st_orglen,
					      VAR_9.su_badptr + VAR_10->st_orglen);
	    VAR_42 = vim_strsave(VAR_34);
	}
	else
	{
	    /* COMMENT_30 */
	    VAR_41 = vim_strnsave(VAR_9.su_badptr, VAR_10->st_orglen);
	    VAR_42 = vim_strsave(VAR_10->st_word);
	}

	/* COMMENT_31 */
	VAR_6 = alloc(STRLEN(VAR_1) - VAR_10->st_orglen + VAR_10->st_wordlen + 1);
	if (VAR_6 != NULL)
	{
	    VAR_8 = (int)(VAR_9.su_badptr - VAR_1);
	    mch_memmove(VAR_6, VAR_1, VAR_8);
	    STRCPY(VAR_6 + VAR_8, VAR_10->st_word);
	    STRCAT(VAR_6, VAR_9.su_badptr + VAR_10->st_orglen);

	    /* COMMENT_32 */
	    ResetRedobuff();
	    AppendToRedobuff((char_u *)""ciw"");
	    AppendToRedobuffLit(VAR_6 + VAR_8,
			    VAR_10->st_wordlen + VAR_9.su_badlen - VAR_10->st_orglen);
	    AppendCharToRedobuff(VAR_43);

	    /* COMMENT_33 */
	    ml_replace(VAR_3->w_cursor.lnum, VAR_6, FALSE);
	    VAR_3->w_cursor.col = VAR_8;

	    changed_bytes(VAR_3->w_cursor.lnum, VAR_8);
	}
    }
    else
	VAR_3->w_cursor = VAR_2;

    spell_find_cleanup(&VAR_9);
skip:
    vim_free(VAR_1);
    VAR_3->w_p_spell = VAR_18;
}",vim/5c68617d395f9d7b824f68475b24ce3e38d653a3/spellsuggest.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -45,6 +45,10 @@
 	    curwin->w_cursor.col = VIsual.col;
 	++badlen;
 	end_visual_mode();
+	// make sure we don't include the NUL at the end of the line
+	line = ml_get_curline();
+	if (badlen > STRLEN(line) - curwin->w_cursor.col)
+	    badlen = STRLEN(line) - curwin->w_cursor.col;
     }
     // Find the start of the badly spelled word.
     else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0","{'deleted_lines': [], 'added_lines': [""\t// make sure we don't include the NUL at the end of the line"", '\tline = ml_get_curline();', '\tif (badlen > STRLEN(line) - curwin->w_cursor.col)', '\t    badlen = STRLEN(line) - curwin->w_cursor.col;']}",True,Heap-based Buffer Overflow occurs in vim in GitHub repository vim/vim prior to 8.2.4563.,7.8,HIGH,2,test,2022-03-13T20:12:25Z,4
CVE-2022-1237,['CWE-129'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,radareorg/radare2,"Fix oobread segfaults in the NE bin parser ##crash

* Reported by @han0nly via huntr.dev
* Reproducers: seed1 seed2
* BountyID: ad3c9c4c-76e7-40c8-bd4a-c095acd8bb40",2d782cdaa2112c10b8dd5e7a93c134b2ada9c1a6,https://github.com/radareorg/radare2/commit/2d782cdaa2112c10b8dd5e7a93c134b2ada9c1a6,libr/bin/format/ne/ne.c,r_bin_ne_get_segments,"RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
int i;
if (!bin) {
return NULL;
}
RList *segments = r_list_newf (free);
for (i = 0; i < bin->ne_header->SegCount; i++) {
RBinSection *bs = R_NEW0 (RBinSection);
NE_image_segment_entry *se = &bin->segment_entries[i];
if (!bs) {
return segments;
}
bs->size = se->length;
bs->vsize = se->minAllocSz ? se->minAllocSz : 64000;
bs->bits = R_SYS_BITS_16;
bs->is_data = se->flags & IS_DATA;
bs->perm = __translate_perms (se->flags);
bs->paddr = (ut64)se->offset * bin->alignment;
bs->name = r_str_newf (""%s.%"" PFMT64d, se->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", bs->paddr);
bs->is_segment = true;
r_list_append (segments, bs);
}
bin->segments = segments;
return segments;
}","RList *r_bin_ne_get_segments(r_bin_ne_obj_t *VAR_0) {
int VAR_1;
if (!VAR_0) {
return NULL;
}
RList *VAR_2 = r_list_newf (VAR_3);
for (VAR_1 = 0; VAR_1 < VAR_0->ne_header->SegCount; VAR_1++) {
RBinSection *VAR_4 = R_NEW0 (RBinSection);
NE_image_segment_entry *VAR_5 = &VAR_0->segment_entries[VAR_1];
if (!VAR_4) {
return VAR_2;
}
VAR_4->size = VAR_5->length;
VAR_4->vsize = VAR_5->minAllocSz ? VAR_5->minAllocSz : 64000;
VAR_4->bits = VAR_6;
VAR_4->is_data = VAR_5->flags & VAR_7;
VAR_4->perm = __translate_perms (VAR_5->flags);
VAR_4->paddr = (ut64)VAR_5->offset * VAR_0->alignment;
VAR_4->name = r_str_newf (""%s.%"" VAR_8, VAR_5->flags & VAR_9 ? ""MOVEABLE"" : ""FIXED"", VAR_4->paddr);
VAR_4->is_segment = true;
r_list_append (VAR_2, VAR_4);
}
VAR_0->segments = VAR_2;
return VAR_2;
}",radareorg/radare2/2d782cdaa2112c10b8dd5e7a93c134b2ada9c1a6/ne.c/vul/before/1.json,"RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
	int i;
	if (!bin) {
		return NULL;
	}
	RList *segments = r_list_newf (free);
	for (i = 0; i < bin->ne_header->SegCount; i++) {
		RBinSection *bs = R_NEW0 (RBinSection);
		if (!bs) {
			return segments;
		}
		NE_image_segment_entry *se = &bin->segment_entries[i];
		bs->size = se->length;
		bs->vsize = se->minAllocSz ? se->minAllocSz : 64000;
		bs->bits = R_SYS_BITS_16;
		bs->is_data = se->flags & IS_DATA;
		bs->perm = __translate_perms (se->flags);
		bs->paddr = (ut64)se->offset * bin->alignment;
		bs->name = r_str_newf (""%s.%"" PFMT64d, se->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", bs->paddr);
		bs->is_segment = true;
		r_list_append (segments, bs);
	}
	bin->segments = segments;
	return segments;
}","RList *r_bin_ne_get_segments(r_bin_ne_obj_t *VAR_0) {
	int VAR_1;
	if (!VAR_0) {
		return NULL;
	}
	RList *VAR_2 = r_list_newf (VAR_3);
	for (VAR_1 = 0; VAR_1 < VAR_0->ne_header->SegCount; VAR_1++) {
		RBinSection *VAR_4 = R_NEW0 (RBinSection);
		if (!VAR_4) {
			return VAR_2;
		}
		NE_image_segment_entry *VAR_5 = &VAR_0->segment_entries[VAR_1];
		VAR_4->size = VAR_5->length;
		VAR_4->vsize = VAR_5->minAllocSz ? VAR_5->minAllocSz : 64000;
		VAR_4->bits = VAR_6;
		VAR_4->is_data = VAR_5->flags & VAR_7;
		VAR_4->perm = __translate_perms (VAR_5->flags);
		VAR_4->paddr = (ut64)VAR_5->offset * VAR_0->alignment;
		VAR_4->name = r_str_newf (""%s.%"" VAR_8, VAR_5->flags & VAR_9 ? ""MOVEABLE"" : ""FIXED"", VAR_4->paddr);
		VAR_4->is_segment = true;
		r_list_append (VAR_2, VAR_4);
	}
	VAR_0->segments = VAR_2;
	return VAR_2;
}",radareorg/radare2/2d782cdaa2112c10b8dd5e7a93c134b2ada9c1a6/ne.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -6,10 +6,10 @@
 	RList *segments = r_list_newf (free);
 	for (i = 0; i < bin->ne_header->SegCount; i++) {
 		RBinSection *bs = R_NEW0 (RBinSection);
-		NE_image_segment_entry *se = &bin->segment_entries[i];
 		if (!bs) {
 			return segments;
 		}
+		NE_image_segment_entry *se = &bin->segment_entries[i];
 		bs->size = se->length;
 		bs->vsize = se->minAllocSz ? se->minAllocSz : 64000;
 		bs->bits = R_SYS_BITS_16;","{'deleted_lines': ['\t\tNE_image_segment_entry *se = &bin->segment_entries[i];'], 'added_lines': ['\t\tNE_image_segment_entry *se = &bin->segment_entries[i];']}",True,"Improper Validation of Array Index in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability is heap overflow and may be exploitable. For more general description of heap buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/122.html).",7.8,HIGH,2,test,2022-04-05T09:31:24Z,4
CVE-2022-1237,['CWE-129'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,radareorg/radare2,"Fix oobread segfaults in the NE bin parser ##crash

* Reported by @han0nly via huntr.dev
* Reproducers: seed1 seed2
* BountyID: ad3c9c4c-76e7-40c8-bd4a-c095acd8bb40",2d782cdaa2112c10b8dd5e7a93c134b2ada9c1a6,https://github.com/radareorg/radare2/commit/2d782cdaa2112c10b8dd5e7a93c134b2ada9c1a6,libr/bin/format/ne/ne.c,r_bin_ne_get_relocs,"RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {
RList *segments = bin->segments;
if (!segments) {
return NULL;
}
RList *entries = bin->entries;
if (!entries) {
return NULL;
}
RList *symbols = bin->symbols;
if (!symbols) {
return NULL;
}
ut16 *modref = malloc (bin->ne_header->ModRefs * sizeof (ut16));
if (!modref) {
return NULL;
}
r_buf_read_at (bin->buf, (ut64)bin->ne_header->ModRefTable + bin->header_offset, (ut8 *)modref, bin->ne_header->ModRefs * sizeof (ut16));
RList *relocs = r_list_newf (free);
if (!relocs) {
free (modref);
return NULL;
}
RListIter *it;
RBinSection *seg;
int index = -1;
r_list_foreach (segments, it, seg) {
index++;
if (!(bin->segment_entries[index].flags & RELOCINFO)) {
continue;
}
ut32 off, start = off = seg->paddr + seg->size;
ut16 length = r_buf_read_le16_at (bin->buf, off);
if (!length) {
continue;
}
off += 2;
while (off < start + length * sizeof (NE_image_reloc_item)) {
RBinReloc *reloc = R_NEW0 (RBinReloc);
if (!reloc) {
return NULL;
}
NE_image_reloc_item rel;
r_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel));
reloc->paddr = seg->paddr + rel.offset;
switch (rel.type) {
case LOBYTE:
reloc->type = R_BIN_RELOC_8;
break;
case SEL_16:
case OFF_16:
reloc->type = R_BIN_RELOC_16;
break;
case POI_32:
case OFF_32:
reloc->type = R_BIN_RELOC_32;
break;
case POI_48:
reloc->type = R_BIN_RELOC_64;
break;
}
ut32 offset;
if (rel.flags & (IMPORTED_ORD | IMPORTED_NAME)) {
RBinImport *imp = R_NEW0 (RBinImport);
if (!imp) {
free (reloc);
break;
}
char *name;
if (rel.index > bin->ne_header->ModRefs) {
name = r_str_newf (""UnknownModule%d_%x"", rel.index, off); } else {
offset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;
name = __read_nonnull_str_at (bin->buf, offset);
}
if (rel.flags & IMPORTED_ORD) {
imp->ordinal = rel.func_ord;
imp->name = r_str_newf (""%s.%s"", name, __func_name_from_ord(name, rel.func_ord));
} else {
offset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off;
char *func = __read_nonnull_str_at (bin->buf, offset);
imp->name = r_str_newf (""%s.%s"", name, func);
free (func);
}
free (name);
reloc->import = imp;
} else if (rel.flags & OSFIXUP) {
} else {
if (strstr (seg->name, ""FIXED"")) {
RBinSection *s = r_list_get_n (segments, rel.segnum - 1);
if (s) {
offset = s->paddr + rel.segoff;
} else {
offset = -1;
}
} else {
RBinAddr *entry = r_list_get_n (entries, rel.entry_ordinal - 1);
if (entry) {
offset = entry->paddr;
} else {
offset = -1;
}
}
reloc->addend = offset;
RBinSymbol *sym = NULL;
RListIter *sit;
r_list_foreach (symbols, sit, sym) {
if (sym->paddr == reloc->addend) {
reloc->symbol = sym;
break;
}
}
}
if (rel.flags & ADDITIVE) {
reloc->additive = 1;
r_list_append (relocs, reloc);
} else {
do {
r_list_append (relocs, reloc);
offset = r_buf_read_le16_at (bin->buf, reloc->paddr);
RBinReloc *tmp = reloc;
reloc = R_NEW0 (RBinReloc);
if (!reloc) {
break;
}
*reloc = *tmp;
reloc->paddr = seg->paddr + offset;
} while (offset != 0xFFFF);
free (reloc);
}
off += sizeof (NE_image_reloc_item);
}
}
free (modref);
return relocs;
}","RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *VAR_0) {
RList *VAR_1 = VAR_0->segments;
if (!VAR_1) {
return NULL;
}
RList *VAR_2 = VAR_0->entries;
if (!VAR_2) {
return NULL;
}
RList *VAR_3 = VAR_0->symbols;
if (!VAR_3) {
return NULL;
}
ut16 *VAR_4 = malloc (VAR_0->ne_header->ModRefs * sizeof (ut16));
if (!VAR_4) {
return NULL;
}
r_buf_read_at (VAR_0->buf, (ut64)VAR_0->ne_header->ModRefTable + VAR_0->header_offset, (ut8 *)VAR_4, VAR_0->ne_header->ModRefs * sizeof (ut16));
RList *VAR_5 = r_list_newf (VAR_6);
if (!VAR_5) {
VAR_6 (VAR_4);
return NULL;
}
RListIter *VAR_7;
RBinSection *VAR_8;
int VAR_9 = -1;
r_list_foreach (VAR_1, VAR_7, VAR_8) {
VAR_9++;
if (!(VAR_0->segment_entries[VAR_9].flags & VAR_10)) {
continue;
}
ut32 VAR_11, VAR_12 = VAR_11 = VAR_8->paddr + VAR_8->size;
ut16 VAR_13 = r_buf_read_le16_at (VAR_0->buf, VAR_11);
if (!VAR_13) {
continue;
}
VAR_11 += 2;
while (VAR_11 < VAR_12 + VAR_13 * sizeof (VAR_14)) {
RBinReloc *VAR_15 = R_NEW0 (RBinReloc);
if (!VAR_15) {
return NULL;
}
NE_image_reloc_item VAR_16;
r_buf_read_at (VAR_0->buf, VAR_11, (ut8 *)&VAR_16, sizeof (VAR_16));
VAR_15->paddr = VAR_8->paddr + VAR_16.offset;
switch (VAR_16.type) {
case VAR_17:
VAR_15->type = VAR_18;
break;
case VAR_19:
case VAR_20:
VAR_15->type = VAR_21;
break;
case VAR_22:
case VAR_23:
VAR_15->type = VAR_24;
break;
case VAR_25:
VAR_15->type = VAR_26;
break;
}
ut32 VAR_27;
if (VAR_16.flags & (VAR_28 | VAR_29)) {
RBinImport *VAR_30 = R_NEW0 (RBinImport);
if (!VAR_30) {
VAR_6 (VAR_15);
break;
}
char *VAR_31;
if (VAR_16.index > VAR_0->ne_header->ModRefs) {
VAR_31 = r_str_newf (""UnknownModule%d_%x"", VAR_16.index, VAR_11); 
} else {
VAR_27 = VAR_4[VAR_16.index - 1] + VAR_0->header_offset + VAR_0->ne_header->ImportNameTable;
VAR_31 = __read_nonnull_str_at (VAR_0->buf, VAR_27);
}
if (VAR_16.flags & VAR_28) {
VAR_30->ordinal = VAR_16.func_ord;
VAR_30->name = r_str_newf (""%s.%s"", VAR_31, __func_name_from_ord(VAR_31, VAR_16.func_ord));
} else {
VAR_27 = VAR_0->header_offset + VAR_0->ne_header->ImportNameTable + VAR_16.name_off;
char *VAR_32 = __read_nonnull_str_at (VAR_0->buf, VAR_27);
VAR_30->name = r_str_newf (""%s.%s"", VAR_31, VAR_32);
VAR_6 (VAR_32);
}
VAR_6 (VAR_31);
VAR_15->import = VAR_30;
} else if (VAR_16.flags & VAR_33) {
} else {
if (strstr (VAR_8->name, ""FIXED"")) {
RBinSection *VAR_34 = r_list_get_n (VAR_1, VAR_16.segnum - 1);
if (VAR_34) {
VAR_27 = VAR_34->paddr + VAR_16.segoff;
} else {
VAR_27 = -1;
}
} else {
RBinAddr *VAR_35 = r_list_get_n (VAR_2, VAR_16.entry_ordinal - 1);
if (VAR_35) {
VAR_27 = VAR_35->paddr;
} else {
VAR_27 = -1;
}
}
VAR_15->addend = VAR_27;
RBinSymbol *VAR_36 = NULL;
RListIter *VAR_37;
r_list_foreach (VAR_3, VAR_37, VAR_36) {
if (VAR_36->paddr == VAR_15->addend) {
VAR_15->symbol = VAR_36;
break;
}
}
}
if (VAR_16.flags & VAR_38) {
VAR_15->additive = 1;
r_list_append (VAR_5, VAR_15);
} else {
do {
r_list_append (VAR_5, VAR_15);
VAR_27 = r_buf_read_le16_at (VAR_0->buf, VAR_15->paddr);
RBinReloc *VAR_39 = VAR_15;
VAR_15 = R_NEW0 (RBinReloc);
if (!VAR_15) {
break;
}
*VAR_15 = *VAR_39;
VAR_15->paddr = VAR_8->paddr + VAR_27;
} while (VAR_27 != 0xFFFF);
VAR_6 (VAR_15);
}
VAR_11 += sizeof (NE_image_reloc_item);
}
}
VAR_6 (VAR_4);
return VAR_5;
}",radareorg/radare2/2d782cdaa2112c10b8dd5e7a93c134b2ada9c1a6/ne.c/vul/before/0.json,"RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {
	RList *segments = bin->segments;
	if (!segments) {
		return NULL;
	}
	RList *entries = bin->entries;
	if (!entries) {
		return NULL;
	}
	RList *symbols = bin->symbols;
	if (!symbols) {
		return NULL;
	}

	ut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16));
	if (!modref) {
		return NULL;
	}
	r_buf_read_at (bin->buf, (ut64)bin->ne_header->ModRefTable + bin->header_offset, (ut8 *)modref, bin->ne_header->ModRefs * sizeof (ut16));

	RList *relocs = r_list_newf (free);
	if (!relocs) {
		free (modref);
		return NULL;
	}

	RListIter *it;
	RBinSection *seg;
	int index = -1;
	r_list_foreach (segments, it, seg) {
		index++;
		if (!(bin->segment_entries[index].flags & RELOCINFO)) {
			continue;
		}
		ut32 off, start = off = seg->paddr + seg->size;
		ut16 length = r_buf_read_le16_at (bin->buf, off);
		if (!length) {
			continue;
		}
		off += 2;
		size_t buf_size = r_buf_size (bin->buf);
		while (off < start + length * sizeof (NE_image_reloc_item) && off < buf_size) {
			RBinReloc *reloc = R_NEW0 (RBinReloc);
			if (!reloc) {
				return NULL;
			}
			NE_image_reloc_item rel;
			r_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel));
			reloc->paddr = seg->paddr + rel.offset;
			switch (rel.type) {
			case LOBYTE:
				reloc->type = R_BIN_RELOC_8;
				break;
			case SEL_16:
			case OFF_16:
				reloc->type = R_BIN_RELOC_16;
				break;
			case POI_32:
			case OFF_32:
				reloc->type = R_BIN_RELOC_32;
				break;
			case POI_48:
				reloc->type = R_BIN_RELOC_64;
				break;
			}
			
			ut32 offset;
			if (rel.flags & (IMPORTED_ORD | IMPORTED_NAME)) {
				RBinImport *imp = R_NEW0 (RBinImport);
				if (!imp) {
					free (reloc);
					break;
				}
				char *name;
				if (rel.index < 1 || rel.index > bin->ne_header->ModRefs) {
					name = r_str_newf (""UnknownModule%d_%x"", rel.index, off); // ????
				} else {
					int index = rel.index;
					offset = modref[index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;
					name = __read_nonnull_str_at (bin->buf, offset);
				}
				if (rel.flags & IMPORTED_ORD) {
					imp->ordinal = rel.func_ord;
					imp->name = r_str_newf (""%s.%s"", name, __func_name_from_ord(name, rel.func_ord));
				} else {
					offset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off;
					char *func = __read_nonnull_str_at (bin->buf, offset);
					imp->name = r_str_newf (""%s.%s"", name, func);
					free (func);
				}
				free (name);
				reloc->import = imp;
			} else if (rel.flags & OSFIXUP) {
				// TODO
			} else {
				if (strstr (seg->name, ""FIXED"")) {
					RBinSection *s = r_list_get_n (segments, rel.segnum - 1);
					if (s) {
						offset = s->paddr + rel.segoff;
					} else {
						offset = -1;
					}
				} else {
					RBinAddr *entry = r_list_get_n (entries, rel.entry_ordinal - 1);
					if (entry) {
						offset = entry->paddr;
					} else {
						offset = -1;
					}
				}
				reloc->addend = offset;
				RBinSymbol *sym = NULL;
				RListIter *sit;
				r_list_foreach (symbols, sit, sym) {
					if (sym->paddr == reloc->addend) {
						reloc->symbol = sym;
						break;
					}
				}
			}

			if (rel.flags & ADDITIVE) {
				reloc->additive = 1;
				r_list_append (relocs, reloc);
			} else {
				do {
					r_list_append (relocs, reloc);
					
					offset = r_buf_read_le16_at (bin->buf, reloc->paddr);
					RBinReloc *tmp = reloc;
					reloc = R_NEW0 (RBinReloc);
					if (!reloc) {
						break;
					}
					*reloc = *tmp;
					reloc->paddr = seg->paddr + offset;
				} while (offset != 0xFFFF);
				free (reloc);
			}

			off += sizeof (NE_image_reloc_item);
		}
	}
	free (modref);
	return relocs;
}","RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *VAR_0) {
	RList *VAR_1 = VAR_0->segments;
	if (!VAR_1) {
		return NULL;
	}
	RList *VAR_2 = VAR_0->entries;
	if (!VAR_2) {
		return NULL;
	}
	RList *VAR_3 = VAR_0->symbols;
	if (!VAR_3) {
		return NULL;
	}

	ut16 *VAR_4 = calloc (VAR_0->ne_header->ModRefs, sizeof (ut16));
	if (!VAR_4) {
		return NULL;
	}
	r_buf_read_at (VAR_0->buf, (ut64)VAR_0->ne_header->ModRefTable + VAR_0->header_offset, (ut8 *)VAR_4, VAR_0->ne_header->ModRefs * sizeof (ut16));

	RList *VAR_5 = r_list_newf (VAR_6);
	if (!VAR_5) {
		VAR_6 (VAR_4);
		return NULL;
	}

	RListIter *VAR_7;
	RBinSection *VAR_8;
	int VAR_9 = -1;
	r_list_foreach (VAR_1, VAR_7, VAR_8) {
		VAR_9++;
		if (!(VAR_0->segment_entries[VAR_9].flags & VAR_10)) {
			continue;
		}
		ut32 VAR_11, VAR_12 = VAR_11 = VAR_8->paddr + VAR_8->size;
		ut16 VAR_13 = r_buf_read_le16_at (VAR_0->buf, VAR_11);
		if (!VAR_13) {
			continue;
		}
		VAR_11 += 2;
		size_t VAR_14 = r_buf_size (VAR_0->buf);
		while (VAR_11 < VAR_12 + VAR_13 * sizeof (VAR_15) && VAR_11 < VAR_14) {
			RBinReloc *VAR_16 = R_NEW0 (RBinReloc);
			if (!VAR_16) {
				return NULL;
			}
			NE_image_reloc_item VAR_17;
			r_buf_read_at (VAR_0->buf, VAR_11, (ut8 *)&VAR_17, sizeof (VAR_17));
			VAR_16->paddr = VAR_8->paddr + VAR_17.offset;
			switch (VAR_17.type) {
			case VAR_18:
				VAR_16->type = VAR_19;
				break;
			case VAR_20:
			case VAR_21:
				VAR_16->type = VAR_22;
				break;
			case VAR_23:
			case VAR_24:
				VAR_16->type = VAR_25;
				break;
			case VAR_26:
				VAR_16->type = VAR_27;
				break;
			}
			
			ut32 VAR_28;
			if (VAR_17.flags & (VAR_29 | VAR_30)) {
				RBinImport *VAR_31 = R_NEW0 (RBinImport);
				if (!VAR_31) {
					VAR_6 (VAR_16);
					break;
				}
				char *VAR_32;
				if (VAR_17.index < 1 || VAR_17.index > VAR_0->ne_header->ModRefs) {
					VAR_32 = r_str_newf (""UnknownModule%d_%x"", VAR_17.index, VAR_11); /* COMMENT_0 */
				} else {
					int VAR_9 = VAR_17.index;
					VAR_28 = VAR_4[VAR_9 - 1] + VAR_0->header_offset + VAR_0->ne_header->ImportNameTable;
					VAR_32 = __read_nonnull_str_at (VAR_0->buf, VAR_28);
				}
				if (VAR_17.flags & VAR_29) {
					VAR_31->ordinal = VAR_17.func_ord;
					VAR_31->name = r_str_newf (""%s.%s"", VAR_32, __func_name_from_ord(VAR_32, VAR_17.func_ord));
				} else {
					VAR_28 = VAR_0->header_offset + VAR_0->ne_header->ImportNameTable + VAR_17.name_off;
					char *VAR_33 = __read_nonnull_str_at (VAR_0->buf, VAR_28);
					VAR_31->name = r_str_newf (""%s.%s"", VAR_32, VAR_33);
					VAR_6 (VAR_33);
				}
				VAR_6 (VAR_32);
				VAR_16->import = VAR_31;
			} else if (VAR_17.flags & VAR_34) {
				/* COMMENT_1 */
			} else {
				if (strstr (VAR_8->name, ""FIXED"")) {
					RBinSection *VAR_35 = r_list_get_n (VAR_1, VAR_17.segnum - 1);
					if (VAR_35) {
						VAR_28 = VAR_35->paddr + VAR_17.segoff;
					} else {
						VAR_28 = -1;
					}
				} else {
					RBinAddr *VAR_36 = r_list_get_n (VAR_2, VAR_17.entry_ordinal - 1);
					if (VAR_36) {
						VAR_28 = VAR_36->paddr;
					} else {
						VAR_28 = -1;
					}
				}
				VAR_16->addend = VAR_28;
				RBinSymbol *VAR_37 = NULL;
				RListIter *VAR_38;
				r_list_foreach (VAR_3, VAR_38, VAR_37) {
					if (VAR_37->paddr == VAR_16->addend) {
						VAR_16->symbol = VAR_37;
						break;
					}
				}
			}

			if (VAR_17.flags & VAR_39) {
				VAR_16->additive = 1;
				r_list_append (VAR_5, VAR_16);
			} else {
				do {
					r_list_append (VAR_5, VAR_16);
					
					VAR_28 = r_buf_read_le16_at (VAR_0->buf, VAR_16->paddr);
					RBinReloc *VAR_40 = VAR_16;
					VAR_16 = R_NEW0 (RBinReloc);
					if (!VAR_16) {
						break;
					}
					*VAR_16 = *VAR_40;
					VAR_16->paddr = VAR_8->paddr + VAR_28;
				} while (VAR_28 != 0xFFFF);
				VAR_6 (VAR_16);
			}

			VAR_11 += sizeof (NE_image_reloc_item);
		}
	}
	VAR_6 (VAR_4);
	return VAR_5;
}",radareorg/radare2/2d782cdaa2112c10b8dd5e7a93c134b2ada9c1a6/ne.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,7 +12,7 @@
 		return NULL;
 	}
 
-	ut16 *modref = malloc (bin->ne_header->ModRefs * sizeof (ut16));
+	ut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16));
 	if (!modref) {
 		return NULL;
 	}
@@ -38,7 +38,8 @@
 			continue;
 		}
 		off += 2;
-		while (off < start + length * sizeof (NE_image_reloc_item)) {
+		size_t buf_size = r_buf_size (bin->buf);
+		while (off < start + length * sizeof (NE_image_reloc_item) && off < buf_size) {
 			RBinReloc *reloc = R_NEW0 (RBinReloc);
 			if (!reloc) {
 				return NULL;
@@ -71,10 +72,11 @@
 					break;
 				}
 				char *name;
-				if (rel.index > bin->ne_header->ModRefs) {
+				if (rel.index < 1 || rel.index > bin->ne_header->ModRefs) {
 					name = r_str_newf (""UnknownModule%d_%x"", rel.index, off); // ????
 				} else {
-					offset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;
+					int index = rel.index;
+					offset = modref[index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;
 					name = __read_nonnull_str_at (bin->buf, offset);
 				}
 				if (rel.flags & IMPORTED_ORD) {","{'deleted_lines': ['\tut16 *modref = malloc (bin->ne_header->ModRefs * sizeof (ut16));', '\t\twhile (off < start + length * sizeof (NE_image_reloc_item)) {', '\t\t\t\tif (rel.index > bin->ne_header->ModRefs) {', '\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;'], 'added_lines': ['\tut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16));', '\t\tsize_t buf_size = r_buf_size (bin->buf);', '\t\twhile (off < start + length * sizeof (NE_image_reloc_item) && off < buf_size) {', '\t\t\t\tif (rel.index < 1 || rel.index > bin->ne_header->ModRefs) {', '\t\t\t\t\tint index = rel.index;', '\t\t\t\t\toffset = modref[index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;']}",True,"Improper Validation of Array Index in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability is heap overflow and may be exploitable. For more general description of heap buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/122.html).",7.8,HIGH,2,test,2022-04-05T09:31:24Z,4
CVE-2022-1244,['CWE-122'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,radareorg/radare2,"Fix oobread in dyldcache ##crash

* Reported by @hdthky via huntr.dev
* Reproducers: poc1
* BountyID: 8ae2c61a-2220-47a5-bfe8-fe6d41ab1f82",2b77b277d67ce061ee6ef839e7139ebc2103c1e3,https://github.com/radareorg/radare2/commit/2b77b277d67ce061ee6ef839e7139ebc2103c1e3,libr/bin/p/bin_dyldcache.c,create_cache_bins,"static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {
RList *bins = r_list_newf ((RListFree)free_bin);
ut16 *depArray = NULL;
cache_imgxtr_t *extras = NULL;
if (!bins) {
return NULL;
}
char *target_libs = NULL;
RList *target_lib_names = NULL;
int *deps = NULL;
target_libs = r_sys_getenv (""R_DYLDCACHE_FILTER"");
if (target_libs) {
target_lib_names = r_str_split_list (target_libs, "":"", 0);
if (!target_lib_names) {
r_list_free (bins);
return NULL;
}
deps = R_NEWS0 (int, cache->hdr->imagesCount);
if (!deps) {
r_list_free (bins);
r_list_free (target_lib_names);
return NULL;
}
}
ut32 i;
for (i = 0; i < cache->n_hdr; i++) {
cache_hdr_t *hdr = &cache->hdr[i];
ut64 hdr_offset = cache->hdr_offset[i];
ut32 maps_index = cache->maps_index[i];
cache_img_t *img = read_cache_images (cache->buf, hdr, hdr_offset);
if (!img) {
goto next;
}
ut32 j;
if (target_libs) {
HtPU *path_to_idx = NULL;
if (cache->accel) {
depArray = R_NEWS0 (ut16, cache->accel->depListCount);
if (!depArray) {
goto next;
}
if (r_buf_fread_at (cache->buf, cache->accel->depListOffset, (ut8*) depArray, ""s"", cache->accel->depListCount) != cache->accel->depListCount * 2) {
goto next;
}
extras = read_cache_imgextra (cache->buf, hdr, cache->accel);
if (!extras) {
goto next;
}
} else {
path_to_idx = create_path_to_index (cache->buf, img, hdr);
}
for (j = 0; j < hdr->imagesCount; j++) {
bool printing = !deps[j];
char *lib_name = get_lib_name (cache->buf, &img[j]);
if (!lib_name) {
break;
}
if (strstr (lib_name, ""libobjc.A.dylib"")) {
deps[j]++;
}
if (!r_list_find (target_lib_names, lib_name, string_contains)) {
R_FREE (lib_name);
continue;
}
if (printing) {
eprintf (""FILTER: %s\n"", lib_name);
}
R_FREE (lib_name);
deps[j]++;
if (extras && depArray) {
ut32 k;
for (k = extras[j].dependentsStartArrayIndex; depArray[k] != 0xffff; k++) {
ut16 dep_index = depArray[k] & 0x7fff;
deps[dep_index]++;
char *dep_name = get_lib_name (cache->buf, &img[dep_index]);
if (!dep_name) {
break;
}
if (printing) {
eprintf (""-> %s\n"", dep_name);
}
free (dep_name);
}
} else if (path_to_idx) {
carve_deps_at_address (cache, img, path_to_idx, img[j].address, deps, printing);
}
}
ht_pu_free (path_to_idx);
R_FREE (depArray);
R_FREE (extras);
}
for (j = 0; j < hdr->imagesCount; j++) {
if (deps && !deps[j]) {
continue;
}
ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);
if (pa == UT64_MAX) {
continue;
}
ut8 magicbytes[4];
r_buf_read_at (cache->buf, pa, magicbytes, 4);
int magic = r_read_le32 (magicbytes);
switch (magic) {
case MH_MAGIC_64:
{
char file[256];
RDyldBinImage *bin = R_NEW0 (RDyldBinImage);
if (!bin) {
goto next;
}
bin->header_at = pa;
bin->hdr_offset = hdr_offset;
bin->symbols_off = resolve_symbols_off (cache, pa);
bin->va = img[j].address;
if (r_buf_read_at (cache->buf, img[j].pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {
file[255] = 0;
char *last_slash = strrchr (file, '/');
if (last_slash && *last_slash) {
if (last_slash > file) {
char *scan = last_slash - 1;
while (scan > file && *scan != '/') {
scan--;
}
if (*scan == '/') {
bin->file = strdup (scan + 1);
} else {
bin->file = strdup (last_slash + 1);
}
} else {
bin->file = strdup (last_slash + 1);
}
} else {
bin->file = strdup (file);
}
}
r_list_append (bins, bin);
break;
}
default:
eprintf (""Unknown sub-bin\n"");
break;
}
}
next:
R_FREE (depArray);
R_FREE (extras);
R_FREE (img);
}
if (r_list_empty (bins)) {
r_list_free (bins);
bins = NULL;
}
R_FREE (deps);
R_FREE (target_libs);
r_list_free (target_lib_names);
return bins;
}","static RList *create_cache_bins(RBinFile *VAR_0, RDyldCache *VAR_1) {
RList *VAR_2 = r_list_newf ((RListFree)VAR_3);
ut16 *VAR_4 = NULL;
cache_imgxtr_t *VAR_5 = NULL;
if (!VAR_2) {
return NULL;
}
char *VAR_6 = NULL;
RList *VAR_7 = NULL;
int *VAR_8 = NULL;
VAR_6 = r_sys_getenv (""R_DYLDCACHE_FILTER"");
if (VAR_6) {
VAR_7 = r_str_split_list (VAR_6, "":"", 0);
if (!VAR_7) {
r_list_free (VAR_2);
return NULL;
}
VAR_8 = R_NEWS0 (int, VAR_1->hdr->imagesCount);
if (!VAR_8) {
r_list_free (VAR_2);
r_list_free (VAR_7);
return NULL;
}
}
ut32 VAR_9;
for (VAR_9 = 0; VAR_9 < VAR_1->n_hdr; VAR_9++) {
cache_hdr_t *VAR_10 = &VAR_1->hdr[VAR_9];
ut64 VAR_11 = VAR_1->hdr_offset[VAR_9];
ut32 VAR_12 = VAR_1->maps_index[VAR_9];
cache_img_t *VAR_13 = read_cache_images (VAR_1->buf, VAR_10, VAR_11);
if (!VAR_13) {
goto next;
}
ut32 VAR_14;
if (VAR_6) {
HtPU *VAR_15 = NULL;
if (VAR_1->accel) {
VAR_4 = R_NEWS0 (ut16, VAR_1->accel->depListCount);
if (!VAR_4) {
goto next;
}
if (r_buf_fread_at (VAR_1->buf, VAR_1->accel->depListOffset, (ut8*) VAR_4, ""s"", VAR_1->accel->depListCount) != VAR_1->accel->depListCount * 2) {
goto next;
}
VAR_5 = read_cache_imgextra (VAR_1->buf, VAR_10, VAR_1->accel);
if (!VAR_5) {
goto next;
}
} else {
VAR_15 = create_path_to_index (VAR_1->buf, VAR_13, VAR_10);
}
for (VAR_14 = 0; VAR_14 < VAR_10->imagesCount; VAR_14++) {
bool VAR_16 = !VAR_8[VAR_14];
char *VAR_17 = get_lib_name (VAR_1->buf, &VAR_13[VAR_14]);
if (!VAR_17) {
break;
}
if (strstr (VAR_17, ""libobjc.A.dylib"")) {
VAR_8[VAR_14]++;
}
if (!r_list_find (VAR_7, VAR_17, VAR_18)) {
R_FREE (VAR_17);
continue;
}
if (VAR_16) {
eprintf (""FILTER: %s\n"", VAR_17);
}
R_FREE (VAR_17);
VAR_8[VAR_14]++;
if (VAR_5 && VAR_4) {
ut32 VAR_19;
for (VAR_19 = VAR_5[VAR_14].dependentsStartArrayIndex; VAR_4[VAR_19] != 0xffff; VAR_19++) {
ut16 VAR_20 = VAR_4[VAR_19] & 0x7fff;
VAR_8[VAR_20]++;
char *VAR_21 = get_lib_name (VAR_1->buf, &VAR_13[VAR_20]);
if (!VAR_21) {
break;
}
if (VAR_16) {
eprintf (""-> %s\n"", VAR_21);
}
free (VAR_21);
}
} else if (VAR_15) {
carve_deps_at_address (VAR_1, VAR_13, VAR_15, VAR_13[VAR_14].address, VAR_8, VAR_16);
}
}
ht_pu_free (VAR_15);
R_FREE (VAR_4);
R_FREE (VAR_5);
}
for (VAR_14 = 0; VAR_14 < VAR_10->imagesCount; VAR_14++) {
if (VAR_8 && !VAR_8[VAR_14]) {
continue;
}
ut64 VAR_22 = va2pa (VAR_13[VAR_14].address, VAR_10->mappingCount, &VAR_1->maps[VAR_12], VAR_1->buf, 0, NULL, NULL);
if (VAR_22 == VAR_23) {
continue;
}
ut8 VAR_24[4];
r_buf_read_at (VAR_1->buf, VAR_22, VAR_24, 4);
int VAR_25 = r_read_le32 (VAR_24);
switch (VAR_25) {
case VAR_26:
{
char VAR_27[256];
RDyldBinImage *VAR_28 = R_NEW0 (RDyldBinImage);
if (!VAR_28) {
goto next;
}
VAR_28->header_at = VAR_22;
VAR_28->hdr_offset = VAR_11;
VAR_28->symbols_off = resolve_symbols_off (VAR_1, VAR_22);
VAR_28->va = VAR_13[VAR_14].address;
if (r_buf_read_at (VAR_1->buf, VAR_13[VAR_14].pathFileOffset, (ut8*) &VAR_27, sizeof (VAR_27)) == sizeof (VAR_27)) {
VAR_27[255] = 0;
char *VAR_29 = strrchr (VAR_27, '/');
if (VAR_29 && *VAR_29) {
if (VAR_29 > VAR_27) {
char *VAR_30 = VAR_29 - 1;
while (VAR_30 > VAR_27 && *VAR_30 != '/') {
VAR_30--;
}
if (*VAR_30 == '/') {
VAR_28->file = strdup (VAR_30 + 1);
} else {
VAR_28->file = strdup (VAR_29 + 1);
}
} else {
VAR_28->file = strdup (VAR_29 + 1);
}
} else {
VAR_28->file = strdup (VAR_27);
}
}
r_list_append (VAR_2, VAR_28);
break;
}
default:
eprintf (""Unknown sub-bin\n"");
break;
}
}
next:
R_FREE (VAR_4);
R_FREE (VAR_5);
R_FREE (VAR_13);
}
if (r_list_empty (VAR_2)) {
r_list_free (VAR_2);
VAR_2 = NULL;
}
R_FREE (VAR_8);
R_FREE (VAR_6);
r_list_free (VAR_7);
return VAR_2;
}",radareorg/radare2/2b77b277d67ce061ee6ef839e7139ebc2103c1e3/bin_dyldcache.c/vul/before/0.json,"static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {
	RList *bins = r_list_newf ((RListFree)free_bin);
	ut16 *depArray = NULL;
	cache_imgxtr_t *extras = NULL;
	if (!bins) {
		return NULL;
	}

	char *target_libs = NULL;
	RList *target_lib_names = NULL;
	int *deps = NULL;
	target_libs = r_sys_getenv (""R_DYLDCACHE_FILTER"");
	if (target_libs) {
		target_lib_names = r_str_split_list (target_libs, "":"", 0);
		if (!target_lib_names) {
			r_list_free (bins);
			return NULL;
		}
		deps = R_NEWS0 (int, cache->hdr->imagesCount);
		if (!deps) {
			r_list_free (bins);
			r_list_free (target_lib_names);
			return NULL;
		}
	}

	ut32 i;
	for (i = 0; i < cache->n_hdr; i++) {
		cache_hdr_t *hdr = &cache->hdr[i];
		ut64 hdr_offset = cache->hdr_offset[i];
		ut32 maps_index = cache->maps_index[i];
		cache_img_t *img = read_cache_images (cache->buf, hdr, hdr_offset);
		if (!img) {
			goto next;
		}

		ut32 j;
		if (target_libs) {
			HtPU *path_to_idx = NULL;
			if (cache->accel) {
				depArray = R_NEWS0 (ut16, cache->accel->depListCount);
				if (!depArray) {
					goto next;
				}

				if (r_buf_fread_at (cache->buf, cache->accel->depListOffset, (ut8*) depArray, ""s"", cache->accel->depListCount) != cache->accel->depListCount * 2) {
					goto next;
				}

				extras = read_cache_imgextra (cache->buf, hdr, cache->accel);
				if (!extras) {
					goto next;
				}
			} else {
				path_to_idx = create_path_to_index (cache->buf, img, hdr);
			}

			for (j = 0; j < hdr->imagesCount; j++) {
				bool printing = !deps[j];
				char *lib_name = get_lib_name (cache->buf, &img[j]);
				if (!lib_name) {
					break;
				}
				if (strstr (lib_name, ""libobjc.A.dylib"")) {
					deps[j]++;
				}
				if (!r_list_find (target_lib_names, lib_name, string_contains)) {
					R_FREE (lib_name);
					continue;
				}
				if (printing) {
					eprintf (""FILTER: %s\n"", lib_name);
				}
				R_FREE (lib_name);
				deps[j]++;

				if (extras && depArray) {
					ut32 k;
					for (k = extras[j].dependentsStartArrayIndex; depArray[k] != 0xffff; k++) {
						ut16 dep_index = depArray[k] & 0x7fff;
						deps[dep_index]++;

						char *dep_name = get_lib_name (cache->buf, &img[dep_index]);
						if (!dep_name) {
							break;
						}
						if (printing) {
							eprintf (""-> %s\n"", dep_name);
						}
						free (dep_name);
					}
				} else if (path_to_idx) {
					carve_deps_at_address (cache, img, path_to_idx, img[j].address, deps, printing);
				}
			}

			ht_pu_free (path_to_idx);
			R_FREE (depArray);
			R_FREE (extras);
		}

		for (j = 0; j < hdr->imagesCount; j++) {
			if (deps && !deps[j]) {
				continue;
			}
			// ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);
			ut64 pa = va2pa (img[j].address, cache->n_maps, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);
			if (pa == UT64_MAX) {
				continue;
			}
			ut8 magicbytes[4];
			r_buf_read_at (cache->buf, pa, magicbytes, 4);
			int magic = r_read_le32 (magicbytes);
			switch (magic) {
			case MH_MAGIC_64:
			{
				char file[256];
				RDyldBinImage *bin = R_NEW0 (RDyldBinImage);
				if (!bin) {
					goto next;
				}
				bin->header_at = pa;
				bin->hdr_offset = hdr_offset;
				bin->symbols_off = resolve_symbols_off (cache, pa);
				bin->va = img[j].address;
				if (r_buf_read_at (cache->buf, img[j].pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {
					file[255] = 0;
					char *last_slash = strrchr (file, '/');
					if (last_slash && *last_slash) {
						if (last_slash > file) {
							char *scan = last_slash - 1;
							while (scan > file && *scan != '/') {
								scan--;
							}
							if (*scan == '/') {
								bin->file = strdup (scan + 1);
							} else {
								bin->file = strdup (last_slash + 1);
							}
						} else {
							bin->file = strdup (last_slash + 1);
						}
					} else {
						bin->file = strdup (file);
					}
				}
				r_list_append (bins, bin);
				break;
			}
			default:
				eprintf (""Unknown sub-bin\n"");
				break;
			}
		}
next:
		R_FREE (depArray);
		R_FREE (extras);
		R_FREE (img);
	}
	if (r_list_empty (bins)) {
		r_list_free (bins);
		bins = NULL;
	}
	R_FREE (deps);
	R_FREE (target_libs);
	r_list_free (target_lib_names);
	return bins;
}","static RList *create_cache_bins(RBinFile *VAR_0, RDyldCache *VAR_1) {
	RList *VAR_2 = r_list_newf ((RListFree)VAR_3);
	ut16 *VAR_4 = NULL;
	cache_imgxtr_t *VAR_5 = NULL;
	if (!VAR_2) {
		return NULL;
	}

	char *VAR_6 = NULL;
	RList *VAR_7 = NULL;
	int *VAR_8 = NULL;
	VAR_6 = r_sys_getenv (""R_DYLDCACHE_FILTER"");
	if (VAR_6) {
		VAR_7 = r_str_split_list (VAR_6, "":"", 0);
		if (!VAR_7) {
			r_list_free (VAR_2);
			return NULL;
		}
		VAR_8 = R_NEWS0 (int, VAR_1->hdr->imagesCount);
		if (!VAR_8) {
			r_list_free (VAR_2);
			r_list_free (VAR_7);
			return NULL;
		}
	}

	ut32 VAR_9;
	for (VAR_9 = 0; VAR_9 < VAR_1->n_hdr; VAR_9++) {
		cache_hdr_t *VAR_10 = &VAR_1->hdr[VAR_9];
		ut64 VAR_11 = VAR_1->hdr_offset[VAR_9];
		ut32 VAR_12 = VAR_1->maps_index[VAR_9];
		cache_img_t *VAR_13 = read_cache_images (VAR_1->buf, VAR_10, VAR_11);
		if (!VAR_13) {
			goto next;
		}

		ut32 VAR_14;
		if (VAR_6) {
			HtPU *VAR_15 = NULL;
			if (VAR_1->accel) {
				VAR_4 = R_NEWS0 (ut16, VAR_1->accel->depListCount);
				if (!VAR_4) {
					goto next;
				}

				if (r_buf_fread_at (VAR_1->buf, VAR_1->accel->depListOffset, (ut8*) VAR_4, ""s"", VAR_1->accel->depListCount) != VAR_1->accel->depListCount * 2) {
					goto next;
				}

				VAR_5 = read_cache_imgextra (VAR_1->buf, VAR_10, VAR_1->accel);
				if (!VAR_5) {
					goto next;
				}
			} else {
				VAR_15 = create_path_to_index (VAR_1->buf, VAR_13, VAR_10);
			}

			for (VAR_14 = 0; VAR_14 < VAR_10->imagesCount; VAR_14++) {
				bool VAR_16 = !VAR_8[VAR_14];
				char *VAR_17 = get_lib_name (VAR_1->buf, &VAR_13[VAR_14]);
				if (!VAR_17) {
					break;
				}
				if (strstr (VAR_17, ""libobjc.A.dylib"")) {
					VAR_8[VAR_14]++;
				}
				if (!r_list_find (VAR_7, VAR_17, VAR_18)) {
					R_FREE (VAR_17);
					continue;
				}
				if (VAR_16) {
					eprintf (""FILTER: %s\n"", VAR_17);
				}
				R_FREE (VAR_17);
				VAR_8[VAR_14]++;

				if (VAR_5 && VAR_4) {
					ut32 VAR_19;
					for (VAR_19 = VAR_5[VAR_14].dependentsStartArrayIndex; VAR_4[VAR_19] != 0xffff; VAR_19++) {
						ut16 VAR_20 = VAR_4[VAR_19] & 0x7fff;
						VAR_8[VAR_20]++;

						char *VAR_21 = get_lib_name (VAR_1->buf, &VAR_13[VAR_20]);
						if (!VAR_21) {
							break;
						}
						if (VAR_16) {
							eprintf (""-> %s\n"", VAR_21);
						}
						free (VAR_21);
					}
				} else if (VAR_15) {
					carve_deps_at_address (VAR_1, VAR_13, VAR_15, VAR_13[VAR_14].address, VAR_8, VAR_16);
				}
			}

			ht_pu_free (VAR_15);
			R_FREE (VAR_4);
			R_FREE (VAR_5);
		}

		for (VAR_14 = 0; VAR_14 < VAR_10->imagesCount; VAR_14++) {
			if (VAR_8 && !VAR_8[VAR_14]) {
				continue;
			}
			/* COMMENT_0 */
			ut64 VAR_22 = va2pa (VAR_13[VAR_14].address, VAR_1->n_maps, &VAR_1->maps[VAR_12], VAR_1->buf, 0, NULL, NULL);
			if (VAR_22 == VAR_23) {
				continue;
			}
			ut8 VAR_24[4];
			r_buf_read_at (VAR_1->buf, VAR_22, VAR_24, 4);
			int VAR_25 = r_read_le32 (VAR_24);
			switch (VAR_25) {
			case VAR_26:
			{
				char VAR_27[256];
				RDyldBinImage *VAR_28 = R_NEW0 (RDyldBinImage);
				if (!VAR_28) {
					goto next;
				}
				VAR_28->header_at = VAR_22;
				VAR_28->hdr_offset = VAR_11;
				VAR_28->symbols_off = resolve_symbols_off (VAR_1, VAR_22);
				VAR_28->va = VAR_13[VAR_14].address;
				if (r_buf_read_at (VAR_1->buf, VAR_13[VAR_14].pathFileOffset, (ut8*) &VAR_27, sizeof (VAR_27)) == sizeof (VAR_27)) {
					VAR_27[255] = 0;
					char *VAR_29 = strrchr (VAR_27, '/');
					if (VAR_29 && *VAR_29) {
						if (VAR_29 > VAR_27) {
							char *VAR_30 = VAR_29 - 1;
							while (VAR_30 > VAR_27 && *VAR_30 != '/') {
								VAR_30--;
							}
							if (*VAR_30 == '/') {
								VAR_28->file = strdup (VAR_30 + 1);
							} else {
								VAR_28->file = strdup (VAR_29 + 1);
							}
						} else {
							VAR_28->file = strdup (VAR_29 + 1);
						}
					} else {
						VAR_28->file = strdup (VAR_27);
					}
				}
				r_list_append (VAR_2, VAR_28);
				break;
			}
			default:
				eprintf (""Unknown sub-bin\n"");
				break;
			}
		}
next:
		R_FREE (VAR_4);
		R_FREE (VAR_5);
		R_FREE (VAR_13);
	}
	if (r_list_empty (VAR_2)) {
		r_list_free (VAR_2);
		VAR_2 = NULL;
	}
	R_FREE (VAR_8);
	R_FREE (VAR_6);
	r_list_free (VAR_7);
	return VAR_2;
}",radareorg/radare2/2b77b277d67ce061ee6ef839e7139ebc2103c1e3/bin_dyldcache.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -103,7 +103,8 @@
 			if (deps && !deps[j]) {
 				continue;
 			}
-			ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);
+			// ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);
+			ut64 pa = va2pa (img[j].address, cache->n_maps, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);
 			if (pa == UT64_MAX) {
 				continue;
 			}","{'deleted_lines': ['\t\t\tut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);'], 'added_lines': ['\t\t\t// ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);', '\t\t\tut64 pa = va2pa (img[j].address, cache->n_maps, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);']}",True,heap-buffer-overflow in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability is capable of inducing denial of service.,5.5,MEDIUM,1,test,2022-04-05T17:39:26Z,4
CVE-2022-24793,['CWE-120'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,pjsip/pjproject,"Merge pull request from GHSA-p6g5-v97c-w5q4

* Prevent heap buffer overflow when parsing DNS packets

* Make sure packet parsing doesn't advance beyond max/end

* Update checks

* Remove  check

Co-authored-by: sauwming <ming@teluu.com>",9fae8f43accef8ea65d4a8ae9cdf297c46cfe29a,https://github.com/pjsip/pjproject/commit/9fae8f43accef8ea65d4a8ae9cdf297c46cfe29a,pjlib-util/src/pjlib-util/dns.c,get_name,"static pj_status_t get_name(int rec_counter, const pj_uint8_t *pkt, 
const pj_uint8_t *start, const pj_uint8_t *max,
pj_str_t *name)
{
const pj_uint8_t *p;
pj_status_t status;
if (rec_counter > 10) {
return PJLIB_UTIL_EDNSINNAMEPTR;
}
p = start;
while (*p) {
if ((*p & 0xc0) == 0xc0) {
pj_uint16_t offset;
pj_memcpy(&offset, p, 2);
offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));
offset = pj_ntohs(offset);
if (offset >= max - pkt)
return PJLIB_UTIL_EDNSINNAMEPTR;
status = get_name(rec_counter+1, pkt, pkt + offset, max, name);
if (status != PJ_SUCCESS)
return status;
return PJ_SUCCESS;
} else {
unsigned label_len = *p;
if (pkt+label_len > max)
return PJLIB_UTIL_EDNSINNAMEPTR;
pj_memcpy(name->ptr + name->slen, p+1, label_len);
name->slen += label_len;
p += label_len + 1;
if (*p != 0) {
*(name->ptr + name->slen) = '.';
++name->slen;
}
if (p >= max)
return PJLIB_UTIL_EDNSINSIZE;
}
}
return PJ_SUCCESS;
}","static pj_status_t get_name(int VAR_0, const pj_uint8_t *VAR_1, 
const pj_uint8_t *VAR_2, const pj_uint8_t *VAR_3,
pj_str_t *VAR_4)
{
const pj_uint8_t *VAR_5;
pj_status_t VAR_6;
if (VAR_0 > 10) {
return VAR_7;
}
VAR_5 = VAR_2;
while (*VAR_5) {
if ((*VAR_5 & 0xc0) == 0xc0) {
pj_uint16_t VAR_8;
pj_memcpy(&VAR_8, VAR_5, 2);
VAR_8 ^= pj_htons((pj_uint16_t)(0xc0 << 8));
VAR_8 = pj_ntohs(VAR_8);
if (VAR_8 >= VAR_3 - VAR_1)
return VAR_7;
VAR_6 = get_name(VAR_0+1, VAR_1, VAR_1 + VAR_8, VAR_3, VAR_4);
if (VAR_6 != VAR_9)
return VAR_6;
return VAR_9;
} else {
unsigned VAR_10 = *VAR_5;
if (VAR_1+VAR_10 > VAR_3)
return VAR_7;
pj_memcpy(VAR_4->ptr + VAR_4->slen, VAR_5+1, VAR_10);
VAR_4->slen += VAR_10;
VAR_5 += VAR_10 + 1;
if (*VAR_5 != 0) {
*(VAR_4->ptr + VAR_4->slen) = '.';
++VAR_4->slen;
}
if (VAR_5 >= VAR_3)
return VAR_11;
}
}
return VAR_9;
}",pjsip/pjproject/9fae8f43accef8ea65d4a8ae9cdf297c46cfe29a/dns.c/vul/before/0.json,"static pj_status_t get_name(int rec_counter, const pj_uint8_t *pkt, 
			    const pj_uint8_t *start, const pj_uint8_t *max,
			    pj_str_t *name)
{
    const pj_uint8_t *p;
    pj_status_t status;

    /* Limit the number of recursion */
    if (rec_counter > 10) {
	/* Too many name recursion */
	return PJLIB_UTIL_EDNSINNAMEPTR;
    }

    p = start;
    while (*p) {
	if ((*p & 0xc0) == 0xc0) {
	    /* Compression is found! */
	    pj_uint16_t offset;

	    /* Get the 14bit offset */
	    pj_memcpy(&offset, p, 2);
	    offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));
	    offset = pj_ntohs(offset);

	    /* Check that offset is valid */
	    if (offset >= max - pkt)
		return PJLIB_UTIL_EDNSINNAMEPTR;

	    /* Retrieve the name from that offset. */
	    status = get_name(rec_counter+1, pkt, pkt + offset, max, name);
	    if (status != PJ_SUCCESS)
		return status;

	    return PJ_SUCCESS;
	} else {
	    unsigned label_len = *p;

	    /* Check that label length is valid.
	     * Each label consists of an octet length (of size 1) followed
	     * by the octet of the specified length (label_len). Then it
	     * must be followed by either another label's octet length or
	     * a zero length octet (that terminates the sequence).
	     */
	    if (p+1+label_len+1 > max)
		return PJLIB_UTIL_EDNSINNAMEPTR;

	    pj_memcpy(name->ptr + name->slen, p+1, label_len);
	    name->slen += label_len;

	    p += label_len + 1;
	    if (*p != 0) {
		*(name->ptr + name->slen) = '.';
		++name->slen;
	    }
	}
    }

    return PJ_SUCCESS;
}","static pj_status_t get_name(int VAR_0, const pj_uint8_t *VAR_1, 
			    const pj_uint8_t *VAR_2, const pj_uint8_t *VAR_3,
			    pj_str_t *VAR_4)
{
    const pj_uint8_t *VAR_5;
    pj_status_t VAR_6;

    /* COMMENT_0 */
    if (VAR_0 > 10) {
	/* COMMENT_1 */
	return VAR_7;
    }

    VAR_5 = VAR_2;
    while (*VAR_5) {
	if ((*VAR_5 & 0xc0) == 0xc0) {
	    /* COMMENT_2 */
	    pj_uint16_t VAR_8;

	    /* COMMENT_3 */
	    pj_memcpy(&VAR_8, VAR_5, 2);
	    VAR_8 ^= pj_htons((pj_uint16_t)(0xc0 << 8));
	    VAR_8 = pj_ntohs(VAR_8);

	    /* COMMENT_4 */
	    if (VAR_8 >= VAR_3 - VAR_1)
		return VAR_7;

	    /* COMMENT_5 */
	    VAR_6 = get_name(VAR_0+1, VAR_1, VAR_1 + VAR_8, VAR_3, VAR_4);
	    if (VAR_6 != VAR_9)
		return VAR_6;

	    return VAR_9;
	} else {
	    unsigned VAR_10 = *VAR_5;

	    /* COMMENT_6 */
                                                                   
                                                                 
                                                                  
                                                           
        
	    if (VAR_5+1+VAR_10+1 > VAR_3)
		return VAR_7;

	    pj_memcpy(VAR_4->ptr + VAR_4->slen, VAR_5+1, VAR_10);
	    VAR_4->slen += VAR_10;

	    VAR_5 += VAR_10 + 1;
	    if (*VAR_5 != 0) {
		*(VAR_4->ptr + VAR_4->slen) = '.';
		++VAR_4->slen;
	    }
	}
    }

    return VAR_9;
}",pjsip/pjproject/9fae8f43accef8ea65d4a8ae9cdf297c46cfe29a/dns.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -35,8 +35,13 @@
 	} else {
 	    unsigned label_len = *p;
 
-	    /* Check that label length is valid */
-	    if (pkt+label_len > max)
+	    /* Check that label length is valid.
+	     * Each label consists of an octet length (of size 1) followed
+	     * by the octet of the specified length (label_len). Then it
+	     * must be followed by either another label's octet length or
+	     * a zero length octet (that terminates the sequence).
+	     */
+	    if (p+1+label_len+1 > max)
 		return PJLIB_UTIL_EDNSINNAMEPTR;
 
 	    pj_memcpy(name->ptr + name->slen, p+1, label_len);
@@ -47,9 +52,6 @@
 		*(name->ptr + name->slen) = '.';
 		++name->slen;
 	    }
-
-	    if (p >= max)
-		return PJLIB_UTIL_EDNSINSIZE;
 	}
     }
 ","{'deleted_lines': ['\t    /* Check that label length is valid */', '\t    if (pkt+label_len > max)', '', '\t    if (p >= max)', '\t\treturn PJLIB_UTIL_EDNSINSIZE;'], 'added_lines': ['\t    /* Check that label length is valid.', '\t     * Each label consists of an octet length (of size 1) followed', '\t     * by the octet of the specified length (label_len). Then it', ""\t     * must be followed by either another label's octet length or"", '\t     * a zero length octet (that terminates the sequence).', '\t     */', '\t    if (p+1+label_len+1 > max)']}",True,"PJSIP is a free and open source multimedia communication library written in C. A buffer overflow vulnerability in versions 2.12 and prior affects applications that use PJSIP DNS resolution. It doesn't affect PJSIP users who utilize an external resolver. This vulnerability is related to CVE-2023-27585. The difference is that this issue is in parsing the query record `parse_rr()`, while the issue in CVE-2023-27585 is in `parse_query()`. A patch is available in the `master` branch of the `pjsip/pjproject` GitHub repository. A workaround is to disable DNS resolution in PJSIP config (by setting `nameserver_count` to zero) or use an external resolver instead.",7.5,HIGH,2,test,2022-04-06T03:49:47Z,4
CVE-2022-24793,['CWE-120'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,pjsip/pjproject,"Merge pull request from GHSA-p6g5-v97c-w5q4

* Prevent heap buffer overflow when parsing DNS packets

* Make sure packet parsing doesn't advance beyond max/end

* Update checks

* Remove  check

Co-authored-by: sauwming <ming@teluu.com>",9fae8f43accef8ea65d4a8ae9cdf297c46cfe29a,https://github.com/pjsip/pjproject/commit/9fae8f43accef8ea65d4a8ae9cdf297c46cfe29a,pjlib-util/src/pjlib-util/dns.c,parse_query,"static pj_status_t parse_query(pj_dns_parsed_query *q, pj_pool_t *pool,
const pj_uint8_t *pkt, const pj_uint8_t *start,
const pj_uint8_t *max, int *parsed_len)
{
const pj_uint8_t *p = start;
int name_len, name_part_len;
pj_status_t status;
status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);
if (status != PJ_SUCCESS)
return status;
q->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);
q->name.slen = 0;
status = get_name(0, pkt, start, max, &q->name);
if (status != PJ_SUCCESS)
return status;
p = (start + name_part_len);
pj_memcpy(&q->type, p, 2);
q->type = pj_ntohs(q->type);
p += 2;
pj_memcpy(&q->dnsclass, p, 2);
q->dnsclass = pj_ntohs(q->dnsclass);
p += 2;
*parsed_len = (int)(p - start);
return PJ_SUCCESS;
}","static pj_status_t parse_query(pj_dns_parsed_query *VAR_0, pj_pool_t *VAR_1,
const pj_uint8_t *VAR_2, const pj_uint8_t *VAR_3,
const pj_uint8_t *VAR_4, int *VAR_5)
{
const pj_uint8_t *VAR_6 = VAR_3;
int VAR_7, VAR_8;
pj_status_t VAR_9;
VAR_9 = get_name_len(0, VAR_2, VAR_3, VAR_4, &VAR_8, &VAR_7);
if (VAR_9 != VAR_10)
return VAR_9;
VAR_0->name.ptr = (char*) pj_pool_alloc(VAR_1, VAR_7+4);
VAR_0->name.slen = 0;
VAR_9 = get_name(0, VAR_2, VAR_3, VAR_4, &VAR_0->name);
if (VAR_9 != VAR_10)
return VAR_9;
VAR_6 = (VAR_3 + VAR_8);
pj_memcpy(&VAR_0->type, VAR_6, 2);
VAR_0->type = pj_ntohs(VAR_0->type);
VAR_6 += 2;
pj_memcpy(&VAR_0->dnsclass, VAR_6, 2);
VAR_0->dnsclass = pj_ntohs(VAR_0->dnsclass);
VAR_6 += 2;
*VAR_5 = (int)(VAR_6 - VAR_3);
return VAR_10;
}",pjsip/pjproject/9fae8f43accef8ea65d4a8ae9cdf297c46cfe29a/dns.c/vul/before/1.json,"static pj_status_t parse_query(pj_dns_parsed_query *q, pj_pool_t *pool,
			       const pj_uint8_t *pkt, const pj_uint8_t *start,
			       const pj_uint8_t *max, int *parsed_len)
{
    const pj_uint8_t *p = start;
    int name_len, name_part_len;
    pj_status_t status;

    /* Get the length of the name */
    status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);
    if (status != PJ_SUCCESS)
	return status;

    /* Allocate memory for the name */
    q->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);
    q->name.slen = 0;

    /* Get the name */
    status = get_name(0, pkt, start, max, &q->name);
    if (status != PJ_SUCCESS)
	return status;

    p = (start + name_part_len);

    /* Check the size can accomodate next few fields. */
    if (p + 4 > max)
    	return PJLIB_UTIL_EDNSINSIZE;

    /* Get the type */
    pj_memcpy(&q->type, p, 2);
    q->type = pj_ntohs(q->type);
    p += 2;

    /* Get the class */
    pj_memcpy(&q->dnsclass, p, 2);
    q->dnsclass = pj_ntohs(q->dnsclass);
    p += 2;

    *parsed_len = (int)(p - start);

    return PJ_SUCCESS;
}","static pj_status_t parse_query(pj_dns_parsed_query *VAR_0, pj_pool_t *VAR_1,
			       const pj_uint8_t *VAR_2, const pj_uint8_t *VAR_3,
			       const pj_uint8_t *VAR_4, int *VAR_5)
{
    const pj_uint8_t *VAR_6 = VAR_3;
    int VAR_7, VAR_8;
    pj_status_t VAR_9;

    /* COMMENT_0 */
    VAR_9 = get_name_len(0, VAR_2, VAR_3, VAR_4, &VAR_8, &VAR_7);
    if (VAR_9 != VAR_10)
	return VAR_9;

    /* COMMENT_1 */
    VAR_0->name.ptr = (char*) pj_pool_alloc(VAR_1, VAR_7+4);
    VAR_0->name.slen = 0;

    /* COMMENT_2 */
    VAR_9 = get_name(0, VAR_2, VAR_3, VAR_4, &VAR_0->name);
    if (VAR_9 != VAR_10)
	return VAR_9;

    VAR_6 = (VAR_3 + VAR_8);

    /* COMMENT_3 */
    if (VAR_6 + 4 > VAR_4)
    	return VAR_11;

    /* COMMENT_4 */
    pj_memcpy(&VAR_0->type, VAR_6, 2);
    VAR_0->type = pj_ntohs(VAR_0->type);
    VAR_6 += 2;

    /* COMMENT_5 */
    pj_memcpy(&VAR_0->dnsclass, VAR_6, 2);
    VAR_0->dnsclass = pj_ntohs(VAR_0->dnsclass);
    VAR_6 += 2;

    *VAR_5 = (int)(VAR_6 - VAR_3);

    return VAR_10;
}",pjsip/pjproject/9fae8f43accef8ea65d4a8ae9cdf297c46cfe29a/dns.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -22,6 +22,10 @@
 
     p = (start + name_part_len);
 
+    /* Check the size can accomodate next few fields. */
+    if (p + 4 > max)
+    	return PJLIB_UTIL_EDNSINSIZE;
+
     /* Get the type */
     pj_memcpy(&q->type, p, 2);
     q->type = pj_ntohs(q->type);","{'deleted_lines': [], 'added_lines': ['    /* Check the size can accomodate next few fields. */', '    if (p + 4 > max)', '    \treturn PJLIB_UTIL_EDNSINSIZE;', '']}",True,"PJSIP is a free and open source multimedia communication library written in C. A buffer overflow vulnerability in versions 2.12 and prior affects applications that use PJSIP DNS resolution. It doesn't affect PJSIP users who utilize an external resolver. This vulnerability is related to CVE-2023-27585. The difference is that this issue is in parsing the query record `parse_rr()`, while the issue in CVE-2023-27585 is in `parse_query()`. A patch is available in the `master` branch of the `pjsip/pjproject` GitHub repository. A workaround is to disable DNS resolution in PJSIP config (by setting `nameserver_count` to zero) or use an external resolver instead.",7.5,HIGH,2,test,2022-04-06T03:49:47Z,4
CVE-2022-24793,['CWE-120'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,pjsip/pjproject,"Merge pull request from GHSA-p6g5-v97c-w5q4

* Prevent heap buffer overflow when parsing DNS packets

* Make sure packet parsing doesn't advance beyond max/end

* Update checks

* Remove  check

Co-authored-by: sauwming <ming@teluu.com>",9fae8f43accef8ea65d4a8ae9cdf297c46cfe29a,https://github.com/pjsip/pjproject/commit/9fae8f43accef8ea65d4a8ae9cdf297c46cfe29a,pjlib-util/src/pjlib-util/dns.c,get_name_len,"static pj_status_t get_name_len(int rec_counter, const pj_uint8_t *pkt, 
const pj_uint8_t *start, const pj_uint8_t *max, 
int *parsed_len, int *name_len)
{
const pj_uint8_t *p;
pj_status_t status;
if (rec_counter > 10) {
return PJLIB_UTIL_EDNSINNAMEPTR;
}
*name_len = *parsed_len = 0;
p = start;
while (*p) {
if ((*p & 0xc0) == 0xc0) {
int ptr_len = 0;
int dummy;
pj_uint16_t offset;
pj_memcpy(&offset, p, 2);
offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));
offset = pj_ntohs(offset);
if (offset >= max - pkt)
return PJLIB_UTIL_EDNSINNAMEPTR;
status = get_name_len(rec_counter+1, pkt, pkt + offset, max, 
&dummy, &ptr_len);
if (status != PJ_SUCCESS)
return status;
*parsed_len += 2;
*name_len += ptr_len;
return PJ_SUCCESS;
} else {
unsigned label_len = *p;
if (pkt+label_len > max)
return PJLIB_UTIL_EDNSINNAMEPTR;
p += (label_len + 1);
*parsed_len += (label_len + 1);
if (*p != 0)
++label_len;
*name_len += label_len;
if (p >= max)
return PJLIB_UTIL_EDNSINSIZE;
}
}
++p;
(*parsed_len)++;
return PJ_SUCCESS;
}","static pj_status_t get_name_len(int VAR_0, const pj_uint8_t *VAR_1, 
const pj_uint8_t *VAR_2, const pj_uint8_t *VAR_3, 
int *VAR_4, int *VAR_5)
{
const pj_uint8_t *VAR_6;
pj_status_t VAR_7;
if (VAR_0 > 10) {
return VAR_8;
}
*VAR_5 = *VAR_4 = 0;
VAR_6 = VAR_2;
while (*VAR_6) {
if ((*VAR_6 & 0xc0) == 0xc0) {
int VAR_9 = 0;
int VAR_10;
pj_uint16_t VAR_11;
pj_memcpy(&VAR_11, VAR_6, 2);
VAR_11 ^= pj_htons((pj_uint16_t)(0xc0 << 8));
VAR_11 = pj_ntohs(VAR_11);
if (VAR_11 >= VAR_3 - VAR_1)
return VAR_8;
VAR_7 = get_name_len(VAR_0+1, VAR_1, VAR_1 + VAR_11, VAR_3, 
&VAR_10, &VAR_9);
if (VAR_7 != VAR_12)
return VAR_7;
*VAR_4 += 2;
*VAR_5 += VAR_9;
return VAR_12;
} else {
unsigned VAR_13 = *VAR_6;
if (VAR_1+VAR_13 > VAR_3)
return VAR_8;
VAR_6 += (VAR_13 + 1);
*VAR_4 += (VAR_13 + 1);
if (*VAR_6 != 0)
++VAR_13;
*VAR_5 += VAR_13;
if (VAR_6 >= VAR_3)
return VAR_14;
}
}
++VAR_6;
(*VAR_4)++;
return VAR_12;
}",pjsip/pjproject/9fae8f43accef8ea65d4a8ae9cdf297c46cfe29a/dns.c/vul/before/2.json,"static pj_status_t get_name_len(int rec_counter, const pj_uint8_t *pkt, 
				const pj_uint8_t *start, const pj_uint8_t *max, 
				int *parsed_len, int *name_len)
{
    const pj_uint8_t *p;
    pj_status_t status;

    /* Limit the number of recursion */
    if (rec_counter > 10) {
	/* Too many name recursion */
	return PJLIB_UTIL_EDNSINNAMEPTR;
    }

    *name_len = *parsed_len = 0;
    p = start;
    while (*p) {
	if ((*p & 0xc0) == 0xc0) {
	    /* Compression is found! */
	    int ptr_len = 0;
	    int dummy;
	    pj_uint16_t offset;

	    /* Get the 14bit offset */
	    pj_memcpy(&offset, p, 2);
	    offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));
	    offset = pj_ntohs(offset);

	    /* Check that offset is valid */
	    if (offset >= max - pkt)
		return PJLIB_UTIL_EDNSINNAMEPTR;

	    /* Get the name length from that offset. */
	    status = get_name_len(rec_counter+1, pkt, pkt + offset, max, 
				  &dummy, &ptr_len);
	    if (status != PJ_SUCCESS)
		return status;

	    *parsed_len += 2;
	    *name_len += ptr_len;

	    return PJ_SUCCESS;
	} else {
	    unsigned label_len = *p;

	    /* Check that label length is valid.
	     * Each label consists of an octet length (of size 1) followed
	     * by the octet of the specified length (label_len). Then it
	     * must be followed by either another label's octet length or
	     * a zero length octet (that terminates the sequence).
	     */
	    if (p+1+label_len+1 > max)
		return PJLIB_UTIL_EDNSINNAMEPTR;

	    p += (label_len + 1);
	    *parsed_len += (label_len + 1);

	    if (*p != 0)
		++label_len;
	    
	    *name_len += label_len;
	}
    }
    ++p;
    (*parsed_len)++;

    return PJ_SUCCESS;
}","static pj_status_t get_name_len(int VAR_0, const pj_uint8_t *VAR_1, 
				const pj_uint8_t *VAR_2, const pj_uint8_t *VAR_3, 
				int *VAR_4, int *VAR_5)
{
    const pj_uint8_t *VAR_6;
    pj_status_t VAR_7;

    /* COMMENT_0 */
    if (VAR_0 > 10) {
	/* COMMENT_1 */
	return VAR_8;
    }

    *VAR_5 = *VAR_4 = 0;
    VAR_6 = VAR_2;
    while (*VAR_6) {
	if ((*VAR_6 & 0xc0) == 0xc0) {
	    /* COMMENT_2 */
	    int VAR_9 = 0;
	    int VAR_10;
	    pj_uint16_t VAR_11;

	    /* COMMENT_3 */
	    pj_memcpy(&VAR_11, VAR_6, 2);
	    VAR_11 ^= pj_htons((pj_uint16_t)(0xc0 << 8));
	    VAR_11 = pj_ntohs(VAR_11);

	    /* COMMENT_4 */
	    if (VAR_11 >= VAR_3 - VAR_1)
		return VAR_8;

	    /* COMMENT_5 */
	    VAR_7 = get_name_len(VAR_0+1, VAR_1, VAR_1 + VAR_11, VAR_3, 
				  &VAR_10, &VAR_9);
	    if (VAR_7 != VAR_12)
		return VAR_7;

	    *VAR_4 += 2;
	    *VAR_5 += VAR_9;

	    return VAR_12;
	} else {
	    unsigned VAR_13 = *VAR_6;

	    /* COMMENT_6 */
                                                                   
                                                                 
                                                                  
                                                           
        
	    if (VAR_6+1+VAR_13+1 > VAR_3)
		return VAR_8;

	    VAR_6 += (VAR_13 + 1);
	    *VAR_4 += (VAR_13 + 1);

	    if (*VAR_6 != 0)
		++VAR_13;
	    
	    *VAR_5 += VAR_13;
	}
    }
    ++VAR_6;
    (*VAR_4)++;

    return VAR_12;
}",pjsip/pjproject/9fae8f43accef8ea65d4a8ae9cdf297c46cfe29a/dns.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -42,8 +42,13 @@
 	} else {
 	    unsigned label_len = *p;
 
-	    /* Check that label length is valid */
-	    if (pkt+label_len > max)
+	    /* Check that label length is valid.
+	     * Each label consists of an octet length (of size 1) followed
+	     * by the octet of the specified length (label_len). Then it
+	     * must be followed by either another label's octet length or
+	     * a zero length octet (that terminates the sequence).
+	     */
+	    if (p+1+label_len+1 > max)
 		return PJLIB_UTIL_EDNSINNAMEPTR;
 
 	    p += (label_len + 1);
@@ -53,9 +58,6 @@
 		++label_len;
 	    
 	    *name_len += label_len;
-
-	    if (p >= max)
-		return PJLIB_UTIL_EDNSINSIZE;
 	}
     }
     ++p;","{'deleted_lines': ['\t    /* Check that label length is valid */', '\t    if (pkt+label_len > max)', '', '\t    if (p >= max)', '\t\treturn PJLIB_UTIL_EDNSINSIZE;'], 'added_lines': ['\t    /* Check that label length is valid.', '\t     * Each label consists of an octet length (of size 1) followed', '\t     * by the octet of the specified length (label_len). Then it', ""\t     * must be followed by either another label's octet length or"", '\t     * a zero length octet (that terminates the sequence).', '\t     */', '\t    if (p+1+label_len+1 > max)']}",True,"PJSIP is a free and open source multimedia communication library written in C. A buffer overflow vulnerability in versions 2.12 and prior affects applications that use PJSIP DNS resolution. It doesn't affect PJSIP users who utilize an external resolver. This vulnerability is related to CVE-2023-27585. The difference is that this issue is in parsing the query record `parse_rr()`, while the issue in CVE-2023-27585 is in `parse_query()`. A patch is available in the `master` branch of the `pjsip/pjproject` GitHub repository. A workaround is to disable DNS resolution in PJSIP config (by setting `nameserver_count` to zero) or use an external resolver instead.",7.5,HIGH,2,test,2022-04-06T03:49:47Z,4
CVE-2022-1297,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0,radareorg/radare2,"Fix oobread and unaligned casts in the NE entrypoint logic ##crash

* Reported by @hmsec via huntr.dev
* Reproducer: nepocaligns
* BountyID: ec538fa4-06c6-4050-a141-f60153ddeaac",0a557045476a2969c7079aec9eeb29d02f2809c6,https://github.com/radareorg/radare2/commit/0a557045476a2969c7079aec9eeb29d02f2809c6,libr/bin/format/ne/ne.c,r_bin_ne_get_entrypoints,"RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {
if (!bin->entry_table) {
return NULL;
}
RList *entries = r_list_newf (free);
if (!entries) {
return NULL;
}
RList *segments = r_bin_ne_get_segments (bin);
if (!segments) {
r_list_free (entries);
return NULL;
}
if (bin->ne_header->csEntryPoint) {
RBinAddr *entry = R_NEW0 (RBinAddr);
if (!entry) {
r_list_free (entries);
return NULL;
}
entry->bits = 16;
ut32 entry_cs = bin->ne_header->csEntryPoint;
RBinSection *s = r_list_get_n (segments, entry_cs - 1);
entry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0);
r_list_append (entries, entry);
}
int off = 0;
size_t tableat = bin->header_offset + bin->ne_header->EntryTableOffset;
while (off < bin->ne_header->EntryTableLength) {
if (tableat + off >= r_buf_size (bin->buf)) {
break;
}
ut8 bundle_length = *(ut8 *)(bin->entry_table + off);
if (!bundle_length) {
break;
}
off++;
ut8 bundle_type = *(ut8 *)(bin->entry_table + off);
off++;
int i;
for (i = 0; i < bundle_length; i++) {
if (tableat + off + 4 >= r_buf_size (bin->buf)) {
break;
}
RBinAddr *entry = R_NEW0 (RBinAddr);
if (!entry) {
r_list_free (entries);
return NULL;
}
off++;
if (!bundle_type) { off--;
free (entry);
break;
} else if (bundle_type == 0xff) { off += 2;
ut8 segnum = *(bin->entry_table + off);
off++;
ut16 segoff = *(ut16 *)(bin->entry_table + off);
if (segnum > 0) {
entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;
}
} else { if (bundle_type < bin->ne_header->SegCount) {
entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset
* bin->alignment + *(ut16 *)(bin->entry_table + off);
}
}
off += 2;
r_list_append (entries, entry);
}
}
r_list_free (segments);
bin->entries = entries;
return entries;
}","RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *VAR_0) {
if (!VAR_0->entry_table) {
return NULL;
}
RList *VAR_1 = r_list_newf (VAR_2);
if (!VAR_1) {
return NULL;
}
RList *VAR_3 = r_bin_ne_get_segments (VAR_0);
if (!VAR_3) {
r_list_free (VAR_1);
return NULL;
}
if (VAR_0->ne_header->csEntryPoint) {
RBinAddr *VAR_4 = R_NEW0 (RBinAddr);
if (!VAR_4) {
r_list_free (VAR_1);
return NULL;
}
VAR_4->bits = 16;
ut32 VAR_5 = VAR_0->ne_header->csEntryPoint;
RBinSection *VAR_6 = r_list_get_n (VAR_3, VAR_5 - 1);
VAR_4->paddr = VAR_0->ne_header->ipEntryPoint + (VAR_6? VAR_6->paddr: 0);
r_list_append (VAR_1, VAR_4);
}
int VAR_7 = 0;
size_t VAR_8 = VAR_0->header_offset + VAR_0->ne_header->EntryTableOffset;
while (VAR_7 < VAR_0->ne_header->EntryTableLength) {
if (VAR_8 + VAR_7 >= r_buf_size (VAR_0->buf)) {
break;
}
ut8 VAR_9 = *(ut8 *)(VAR_0->entry_table + VAR_7);
if (!VAR_9) {
break;
}
VAR_7++;
ut8 VAR_10 = *(ut8 *)(VAR_0->entry_table + VAR_7);
VAR_7++;
int VAR_11;
for (VAR_11 = 0; VAR_11 < VAR_9; VAR_11++) {
if (VAR_8 + VAR_7 + 4 >= r_buf_size (VAR_0->buf)) {
break;
}
RBinAddr *VAR_4 = R_NEW0 (RBinAddr);
if (!VAR_4) {
r_list_free (VAR_1);
return NULL;
}
VAR_7++;
if (!VAR_10) { 
VAR_7--;
VAR_2 (VAR_4);
break;
} else if (VAR_10 == 0xff) { 
VAR_7 += 2;
ut8 VAR_12 = *(VAR_0->entry_table + VAR_7);
VAR_7++;
ut16 VAR_13 = *(ut16 *)(VAR_0->entry_table + VAR_7);
if (VAR_12 > 0) {
VAR_4->paddr = (ut64)VAR_0->segment_entries[VAR_12 - 1].offset * VAR_0->alignment + VAR_13;
}
} else { 
if (VAR_10 < VAR_0->ne_header->SegCount) {
VAR_4->paddr = (ut64)VAR_0->segment_entries[VAR_10 - 1].offset
* VAR_0->alignment + *(ut16 *)(VAR_0->entry_table + VAR_7);
}
}
VAR_7 += 2;
r_list_append (VAR_1, VAR_4);
}
}
r_list_free (VAR_3);
VAR_0->entries = VAR_1;
return VAR_1;
}",radareorg/radare2/0a557045476a2969c7079aec9eeb29d02f2809c6/ne.c/vul/before/0.json,"RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {
	if (!bin->entry_table) {
		return NULL;
	}
	RList *entries = r_list_newf (free);
	if (!entries) {
		return NULL;
	}
	RList *segments = r_bin_ne_get_segments (bin);
	if (!segments) {
		r_list_free (entries);
		return NULL;
	}
	if (bin->ne_header->csEntryPoint) {
		RBinAddr *entry = R_NEW0 (RBinAddr);
		if (!entry) {
			r_list_free (entries);
			return NULL;
		}
		entry->bits = 16;
		ut32 entry_cs = bin->ne_header->csEntryPoint;
		RBinSection *s = r_list_get_n (segments, entry_cs - 1);
		entry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0);

		r_list_append (entries, entry);
	}
	int off = 0;
	size_t tableat = bin->header_offset + bin->ne_header->EntryTableOffset;
	while (off < bin->ne_header->EntryTableLength) {
		if (tableat + off >= r_buf_size (bin->buf)) {
			break;
		}
		ut8 bundle_length = *(ut8 *)(bin->entry_table + off);
		if (!bundle_length) {
			break;
		}
		off++;
		ut8 bundle_type = *(ut8 *)(bin->entry_table + off);
		off++;
		int i;
		for (i = 0; i < bundle_length; i++) {
			if (tableat + off + 4 >= r_buf_size (bin->buf)) {
				break;
			}
			RBinAddr *entry = R_NEW0 (RBinAddr);
			if (!entry) {
				r_list_free (entries);
				return NULL;
			}
			off++;
			if (!bundle_type) { // Skip
				off--;
				free (entry);
				break;
			} else if (bundle_type == 0xff) { // moveable
				off += 2;
				ut8 segnum = *(bin->entry_table + off);
				off++;
				if (off > bin->ne_header->EntryTableLength) {
					break;
				}
				ut16 segoff = r_read_le16 (bin->entry_table + off);
				if (segnum > 0 && segnum < bin->ne_header->SegCount) {
					entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;
				}
			} else { // Fixed
				if (off + 2 >= bin->ne_header->EntryTableLength) {
					break;
				}
				ut16 delta = r_read_le16 (bin->entry_table + off);
				if (bundle_type < bin->ne_header->SegCount) {
					entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset
						* bin->alignment + delta;
				}
			}
			off += 2;
			r_list_append (entries, entry);
		}
	}
	r_list_free (segments);
	bin->entries = entries;
	return entries;
}","RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *VAR_0) {
	if (!VAR_0->entry_table) {
		return NULL;
	}
	RList *VAR_1 = r_list_newf (VAR_2);
	if (!VAR_1) {
		return NULL;
	}
	RList *VAR_3 = r_bin_ne_get_segments (VAR_0);
	if (!VAR_3) {
		r_list_free (VAR_1);
		return NULL;
	}
	if (VAR_0->ne_header->csEntryPoint) {
		RBinAddr *VAR_4 = R_NEW0 (RBinAddr);
		if (!VAR_4) {
			r_list_free (VAR_1);
			return NULL;
		}
		VAR_4->bits = 16;
		ut32 VAR_5 = VAR_0->ne_header->csEntryPoint;
		RBinSection *VAR_6 = r_list_get_n (VAR_3, VAR_5 - 1);
		VAR_4->paddr = VAR_0->ne_header->ipEntryPoint + (VAR_6? VAR_6->paddr: 0);

		r_list_append (VAR_1, VAR_4);
	}
	int VAR_7 = 0;
	size_t VAR_8 = VAR_0->header_offset + VAR_0->ne_header->EntryTableOffset;
	while (VAR_7 < VAR_0->ne_header->EntryTableLength) {
		if (VAR_8 + VAR_7 >= r_buf_size (VAR_0->buf)) {
			break;
		}
		ut8 VAR_9 = *(ut8 *)(VAR_0->entry_table + VAR_7);
		if (!VAR_9) {
			break;
		}
		VAR_7++;
		ut8 VAR_10 = *(ut8 *)(VAR_0->entry_table + VAR_7);
		VAR_7++;
		int VAR_11;
		for (VAR_11 = 0; VAR_11 < VAR_9; VAR_11++) {
			if (VAR_8 + VAR_7 + 4 >= r_buf_size (VAR_0->buf)) {
				break;
			}
			RBinAddr *VAR_4 = R_NEW0 (RBinAddr);
			if (!VAR_4) {
				r_list_free (VAR_1);
				return NULL;
			}
			VAR_7++;
			if (!VAR_10) { /* COMMENT_0 */
				VAR_7--;
				VAR_2 (VAR_4);
				break;
			} else if (VAR_10 == 0xff) { /* COMMENT_1 */
				VAR_7 += 2;
				ut8 VAR_12 = *(VAR_0->entry_table + VAR_7);
				VAR_7++;
				if (VAR_7 > VAR_0->ne_header->EntryTableLength) {
					break;
				}
				ut16 VAR_13 = r_read_le16 (VAR_0->entry_table + VAR_7);
				if (VAR_12 > 0 && VAR_12 < VAR_0->ne_header->SegCount) {
					VAR_4->paddr = (ut64)VAR_0->segment_entries[VAR_12 - 1].offset * VAR_0->alignment + VAR_13;
				}
			} else { /* COMMENT_2 */
				if (VAR_7 + 2 >= VAR_0->ne_header->EntryTableLength) {
					break;
				}
				ut16 VAR_14 = r_read_le16 (VAR_0->entry_table + VAR_7);
				if (VAR_10 < VAR_0->ne_header->SegCount) {
					VAR_4->paddr = (ut64)VAR_0->segment_entries[VAR_10 - 1].offset
						* VAR_0->alignment + VAR_14;
				}
			}
			VAR_7 += 2;
			r_list_append (VAR_1, VAR_4);
		}
	}
	r_list_free (VAR_3);
	VAR_0->entries = VAR_1;
	return VAR_1;
}",radareorg/radare2/0a557045476a2969c7079aec9eeb29d02f2809c6/ne.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -56,14 +56,21 @@
 				off += 2;
 				ut8 segnum = *(bin->entry_table + off);
 				off++;
-				ut16 segoff = *(ut16 *)(bin->entry_table + off);
-				if (segnum > 0) {
+				if (off > bin->ne_header->EntryTableLength) {
+					break;
+				}
+				ut16 segoff = r_read_le16 (bin->entry_table + off);
+				if (segnum > 0 && segnum < bin->ne_header->SegCount) {
 					entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;
 				}
 			} else { // Fixed
+				if (off + 2 >= bin->ne_header->EntryTableLength) {
+					break;
+				}
+				ut16 delta = r_read_le16 (bin->entry_table + off);
 				if (bundle_type < bin->ne_header->SegCount) {
 					entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset
-						* bin->alignment + *(ut16 *)(bin->entry_table + off);
+						* bin->alignment + delta;
 				}
 			}
 			off += 2;","{'deleted_lines': ['\t\t\t\tut16 segoff = *(ut16 *)(bin->entry_table + off);', '\t\t\t\tif (segnum > 0) {', '\t\t\t\t\t\t* bin->alignment + *(ut16 *)(bin->entry_table + off);'], 'added_lines': ['\t\t\t\tif (off > bin->ne_header->EntryTableLength) {', '\t\t\t\t\tbreak;', '\t\t\t\t}', '\t\t\t\tut16 segoff = r_read_le16 (bin->entry_table + off);', '\t\t\t\tif (segnum > 0 && segnum < bin->ne_header->SegCount) {', '\t\t\t\tif (off + 2 >= bin->ne_header->EntryTableLength) {', '\t\t\t\t\tbreak;', '\t\t\t\t}', '\t\t\t\tut16 delta = r_read_le16 (bin->entry_table + off);', '\t\t\t\t\t\t* bin->alignment + delta;']}",True,Out-of-bounds Read in r_bin_ne_get_entrypoints function in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability may allow attackers to read sensitive information or cause a crash.,9.1,CRITICAL,3,test,2022-04-11T11:35:52Z,4
CVE-2021-46019,"['CWE-416', 'CWE-476']",AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gnu-mirror-unofficial/recutils,"parser: avoid character 0xff being interpreted as (int) -1

This fixes the following CVEs:
- CVE-2021-46019
- CVE-2021-46022
- CVE-2021-46022

2022-04-16  Jose E. Marchesi  <jemarch@gnu.org>

	CVE-2021-46019
	CVE-2021-46022
	CVE-2021-46022
	* src/rec-parser.c (rec_parse_comment): Avoid 0xff being
	interpreted as (int) -1.",34b75ed7ad492c8e38b669ebafe0176f1f9992d2,https://github.com/gnu-mirror-unofficial/recutils/commit/34b75ed7ad492c8e38b669ebafe0176f1f9992d2,src/rec-parser.c,rec_parse_comment,"static bool
rec_parse_comment (rec_parser_t parser, rec_comment_t *comment)
{
bool ret;
rec_buf_t buf;
char *str;
size_t str_size;
int ci;
char c;
ret = false;
buf = rec_buf_new (&str, &str_size);
if (rec_expect (parser, ""#""))
{
while ((ci = rec_parser_getc (parser)) != EOF)
{
c = (char) ci;
if (c == '\n')
{
if ((ci = rec_parser_getc (parser)) == EOF)
break;
c = (char) ci;
if (c != '#')
{
rec_parser_ungetc (parser, ci);
break;
}
else
c = '\n';
}
if (rec_buf_putc (c, buf) == EOF)
{
parser->error = REC_PARSER_ENOMEM;
return false;
}
}
ret = true;
}
rec_buf_close (buf);
if (ret)
*comment = rec_comment_new (str);
else
*comment = NULL;
free (str);
return ret;
}","static bool
rec_parse_comment (rec_parser_t VAR_0, rec_comment_t *VAR_1)
{
bool VAR_2;
rec_buf_t VAR_3;
char *VAR_4;
size_t VAR_5;
int VAR_6;
char VAR_7;
VAR_2 = false;
VAR_3 = rec_buf_new (&VAR_4, &VAR_5);
if (rec_expect (VAR_0, ""#""))
{
while ((VAR_6 = rec_parser_getc (VAR_0)) != VAR_8)
{
VAR_7 = (char) VAR_6;
if (VAR_7 == '\n')
{
if ((VAR_6 = rec_parser_getc (VAR_0)) == VAR_8)
break;
VAR_7 = (char) VAR_6;
if (VAR_7 != '#')
{
rec_parser_ungetc (VAR_0, VAR_6);
break;
}
else
VAR_7 = '\n';
}
if (rec_buf_putc (VAR_7, VAR_3) == VAR_8)
{
VAR_0->error = VAR_9;
return false;
}
}
VAR_2 = true;
}
rec_buf_close (VAR_3);
if (VAR_2)
*VAR_1 = rec_comment_new (VAR_4);
else
*VAR_1 = NULL;
free (VAR_4);
return VAR_2;
}",gnu-mirror-unofficial/recutils/34b75ed7ad492c8e38b669ebafe0176f1f9992d2/rec-parser.c/vul/before/0.json,"static bool
rec_parse_comment (rec_parser_t parser, rec_comment_t *comment)
{
  bool ret;
  rec_buf_t buf;
  char *str;
  size_t str_size;
  int ci;
  char c;

  ret = false;
  buf = rec_buf_new (&str, &str_size);

  /* Comments start at the beginning of line and span until the first
   * \n character not followed by a #, or EOF.
   */
  if (rec_expect (parser, ""#""))
    {
      while ((ci = rec_parser_getc (parser)) != EOF)
        {
          c = (char) ci;

          if (c == '\n')
            {
              if ((ci = rec_parser_getc (parser)) == EOF)
                break;
              c = (char) ci;

              if (c != '#')
                {
                  rec_parser_ungetc (parser, ci);
                  break;
                }
              else
                c = '\n';
            }

          if (rec_buf_putc (ci, buf) == EOF)
            {
              /* Out of memory */
              parser->error = REC_PARSER_ENOMEM;
              return false;
            }
        }

      ret = true;
    }

  rec_buf_close (buf);

  if (ret)
    *comment = rec_comment_new (str);
  else
    *comment = NULL;

  free (str);
  return ret;
}","static bool
rec_parse_comment (rec_parser_t VAR_0, rec_comment_t *VAR_1)
{
  bool VAR_2;
  rec_buf_t VAR_3;
  char *VAR_4;
  size_t VAR_5;
  int VAR_6;
  char VAR_7;

  VAR_2 = false;
  VAR_3 = rec_buf_new (&VAR_4, &VAR_5);

  /* COMMENT_0 */
                                              
     
  if (rec_expect (VAR_0, ""#""))
    {
      while ((VAR_6 = rec_parser_getc (VAR_0)) != VAR_8)
        {
          VAR_7 = (char) VAR_6;

          if (VAR_7 == '\n')
            {
              if ((VAR_6 = rec_parser_getc (VAR_0)) == VAR_8)
                break;
              VAR_7 = (char) VAR_6;

              if (VAR_7 != '#')
                {
                  rec_parser_ungetc (VAR_0, VAR_6);
                  break;
                }
              else
                VAR_7 = '\n';
            }

          if (rec_buf_putc (VAR_6, VAR_3) == VAR_8)
            {
              /* COMMENT_3 */
              VAR_0->error = VAR_9;
              return false;
            }
        }

      VAR_2 = true;
    }

  rec_buf_close (VAR_3);

  if (VAR_2)
    *VAR_1 = rec_comment_new (VAR_4);
  else
    *VAR_1 = NULL;

  free (VAR_4);
  return VAR_2;
}",gnu-mirror-unofficial/recutils/34b75ed7ad492c8e38b669ebafe0176f1f9992d2/rec-parser.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -35,7 +35,7 @@
                 c = '\n';
             }
 
-          if (rec_buf_putc (c, buf) == EOF)
+          if (rec_buf_putc (ci, buf) == EOF)
             {
               /* Out of memory */
               parser->error = REC_PARSER_ENOMEM;","{'deleted_lines': ['          if (rec_buf_putc (c, buf) == EOF)'], 'added_lines': ['          if (rec_buf_putc (ci, buf) == EOF)']}",True,An untrusted pointer dereference in rec_db_destroy() at rec-db.c of GNU Recutils v1.8.90 can lead to a segmentation fault or application crash.,5.5,MEDIUM,1,test,2022-04-16T15:11:56Z,4
CVE-2021-46784,['CWE-617'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,squid-cache/squid,Improve handling of Gopher responses (#1022),5e2ea2b13bd98f53e29964ca26bb0d602a8a12b9,https://github.com/squid-cache/squid/commit/5e2ea2b13bd98f53e29964ca26bb0d602a8a12b9,src/gopher.cc,gopherToHTML,"static void
gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
{
char *pos = inbuf;
char *lpos = NULL;
char *tline = NULL;
LOCAL_ARRAY(char, line, TEMP_BUF_SIZE);
LOCAL_ARRAY(char, tmpbuf, TEMP_BUF_SIZE);
char *name = NULL;
char *selector = NULL;
char *host = NULL;
char *port = NULL;
char *escaped_selector = NULL;
const char *icon_url = NULL;
char gtype;
StoreEntry *entry = NULL;
memset(tmpbuf, '\0', TEMP_BUF_SIZE);
memset(line, '\0', TEMP_BUF_SIZE);
entry = gopherState->entry;
if (gopherState->conversion == GopherStateData::HTML_INDEX_PAGE) {
char *html_url = html_quote(entry->url());
gopherHTMLHeader(entry, ""Gopher Index %s"", html_url);
storeAppendPrintf(entry,
""<p>This is a searchable Gopher index. Use the search\n""
""function of your browser to enter search terms.\n""
""<ISINDEX>\n"");
gopherHTMLFooter(entry);
entry->flush();
gopherState->HTML_header_added = 1;
return;
}
if (gopherState->conversion == GopherStateData::HTML_CSO_PAGE) {
char *html_url = html_quote(entry->url());
gopherHTMLHeader(entry, ""CSO Search of %s"", html_url);
storeAppendPrintf(entry,
""<P>A CSO database usually contains a phonebook or\n""
""directory.  Use the search function of your browser to enter\n""
""search terms.</P><ISINDEX>\n"");
gopherHTMLFooter(entry);
entry->flush();
gopherState->HTML_header_added = 1;
return;
}
String outbuf;
if (!gopherState->HTML_header_added) {
if (gopherState->conversion == GopherStateData::HTML_CSO_RESULT)
gopherHTMLHeader(entry, ""CSO Search Result"", NULL);
else
gopherHTMLHeader(entry, ""Gopher Menu"", NULL);
outbuf.append (""<PRE>"");
gopherState->HTML_header_added = 1;
gopherState->HTML_pre = 1;
}
while (pos < inbuf + len) {
int llen;
int left = len - (pos - inbuf);
lpos = (char *)memchr(pos, '\n', left);
if (lpos) {
++lpos;             
llen = lpos - pos;
} else {
llen = left;
}
if (gopherState->len + llen >= TEMP_BUF_SIZE) {
debugs(10, DBG_IMPORTANT, ""GopherHTML: Buffer overflow. Lost some data on URL: "" << entry->url()  );
llen = TEMP_BUF_SIZE - gopherState->len - 1;
gopherState->overflowed = true;         }
if (!lpos) {
memcpy(gopherState->buf + gopherState->len, pos, llen);
gopherState->len += llen;
break;
}
if (gopherState->len != 0) {
memcpy(line, gopherState->buf, gopherState->len);
memcpy(line + gopherState->len, pos, llen);
llen += gopherState->len;
gopherState->len = 0;
} else {
memcpy(line, pos, llen);
}
line[llen + 1] = '\0';
pos = lpos;
if (*line == '.') {
memset(line, '\0', TEMP_BUF_SIZE);
continue;
}
switch (gopherState->conversion) {
case GopherStateData::HTML_INDEX_RESULT:
case GopherStateData::HTML_DIR: {
tline = line;
gtype = *tline;
++tline;
name = tline;
selector = strchr(tline, TAB);
if (selector) {
*selector = '\0';
++selector;
host = strchr(selector, TAB);
if (host) {
*host = '\0';
++host;
port = strchr(host, TAB);
if (port) {
char *junk;
port[0] = ':';
junk = strchr(host, TAB);
if (junk)
*junk++ = 0;    
else {
junk = strchr(host, '\r');
if (junk)
*junk++ = 0;    
else {
junk = strchr(host, '\n');
if (junk)
*junk++ = 0;    
}
}
if ((port[1] == '0') && (!port[2]))
port[0] = 0;    
}
escaped_selector = xstrdup(rfc1738_escape_part(selector));
switch (gtype) {
case GOPHER_DIRECTORY:
icon_url = mimeGetIconURL(""internal-menu"");
break;
case GOPHER_HTML:
case GOPHER_FILE:
icon_url = mimeGetIconURL(""internal-text"");
break;
case GOPHER_INDEX:
case GOPHER_CSO:
icon_url = mimeGetIconURL(""internal-index"");
break;
case GOPHER_IMAGE:
case GOPHER_GIF:
case GOPHER_PLUS_IMAGE:
icon_url = mimeGetIconURL(""internal-image"");
break;
case GOPHER_SOUND:
case GOPHER_PLUS_SOUND:
icon_url = mimeGetIconURL(""internal-sound"");
break;
case GOPHER_PLUS_MOVIE:
icon_url = mimeGetIconURL(""internal-movie"");
break;
case GOPHER_TELNET:
case GOPHER_3270:
icon_url = mimeGetIconURL(""internal-telnet"");
break;
case GOPHER_BIN:
case GOPHER_MACBINHEX:
case GOPHER_DOSBIN:
case GOPHER_UUENCODED:
icon_url = mimeGetIconURL(""internal-binary"");
break;
case GOPHER_INFO:
icon_url = NULL;
break;
case GOPHER_WWW:
icon_url = mimeGetIconURL(""internal-link"");
break;
default:
icon_url = mimeGetIconURL(""internal-unknown"");
break;
}
memset(tmpbuf, '\0', TEMP_BUF_SIZE);
if ((gtype == GOPHER_TELNET) || (gtype == GOPHER_3270)) {
if (strlen(escaped_selector) != 0)
snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""telnet:                                     icon_url, escaped_selector, rfc1738_escape_part(host),
*port ? "":"" : """", port, html_quote(name));
else
snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""telnet:                                     icon_url, rfc1738_escape_part(host), *port ? "":"" : """",
port, html_quote(name));
} else if (gtype == GOPHER_INFO) {
snprintf(tmpbuf, TEMP_BUF_SIZE, ""\t%s\n"", html_quote(name));
} else {
if (strncmp(selector, ""GET /"", 5) == 0) {
snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""http:                                     icon_url, host, rfc1738_escape_unescaped(selector + 5), html_quote(name));
} else if (gtype == GOPHER_WWW) {
snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""%s\"">%s</A>\n"",
icon_url, rfc1738_escape_unescaped(selector), html_quote(name));
} else {
snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""gopher:                                     icon_url, host, gtype, escaped_selector, html_quote(name));
}
}
safe_free(escaped_selector);
outbuf.append(tmpbuf);
} else {
memset(line, '\0', TEMP_BUF_SIZE);
continue;
}
} else {
memset(line, '\0', TEMP_BUF_SIZE);
continue;
}
break;
}           
case GopherStateData::HTML_CSO_RESULT: {
if (line[0] == '-') {
int code, recno;
char *s_code, *s_recno, *result;
s_code = strtok(line + 1, "":\n"");
s_recno = strtok(NULL, "":\n"");
result = strtok(NULL, ""\n"");
if (!result)
break;
code = atoi(s_code);
recno = atoi(s_recno);
if (code != 200)
break;
if (gopherState->cso_recno != recno) {
snprintf(tmpbuf, TEMP_BUF_SIZE, ""</PRE><HR noshade size=\""1px\""><H2>Record# %d<br><i>%s</i></H2>\n<PRE>"", recno, html_quote(result));
gopherState->cso_recno = recno;
} else {
snprintf(tmpbuf, TEMP_BUF_SIZE, ""%s\n"", html_quote(result));
}
outbuf.append(tmpbuf);
break;
} else {
int code;
char *s_code, *result;
s_code = strtok(line, "":"");
result = strtok(NULL, ""\n"");
if (!result)
break;
code = atoi(s_code);
switch (code) {
case 200: {
break;
}
case 102:   
case 501:   
case 502: { 
snprintf(tmpbuf, TEMP_BUF_SIZE, ""</PRE><HR noshade size=\""1px\""><H2>%s</H2>\n<PRE>"", html_quote(result));
outbuf.append(tmpbuf);
break;
}
}
}
break;
}           
default:
break;      
}           
}               
if (outbuf.size() > 0) {
entry->append(outbuf.rawBuf(), outbuf.size());
entry->flush();
}
outbuf.clean();
return;
}","static void
gopherToHTML(GopherStateData * VAR_0, char *VAR_1, int VAR_2)
{
char *VAR_3 = VAR_1;
char *VAR_4 = NULL;
char *VAR_5 = NULL;
LOCAL_ARRAY(char, line, TEMP_BUF_SIZE);
LOCAL_ARRAY(char, tmpbuf, TEMP_BUF_SIZE);
char *VAR_6 = NULL;
char *VAR_7 = NULL;
char *VAR_8 = NULL;
char *VAR_9 = NULL;
char *VAR_10 = NULL;
const char *VAR_11 = NULL;
char VAR_12;
StoreEntry *VAR_13 = NULL;
memset(tmpbuf, '\0', TEMP_BUF_SIZE);
memset(line, '\0', TEMP_BUF_SIZE);
VAR_13 = VAR_0->entry;
if (VAR_0->conversion == GopherStateData::HTML_INDEX_PAGE) {
char *VAR_14 = html_quote(VAR_13->url());
gopherHTMLHeader(VAR_13, ""Gopher Index %s"", VAR_14);
storeAppendPrintf(VAR_13,
""<p>This is a searchable Gopher index. Use the search\n""
""function of your browser to enter search terms.\n""
""<ISINDEX>\n"");
gopherHTMLFooter(VAR_13);
VAR_13->flush();
VAR_0->HTML_header_added = 1;
return;
}
if (VAR_0->conversion == GopherStateData::HTML_CSO_PAGE) {
char *VAR_14 = html_quote(VAR_13->url());
gopherHTMLHeader(VAR_13, ""CSO Search of %s"", VAR_14);
storeAppendPrintf(VAR_13,
""<P>A CSO database usually contains a phonebook or\n""
""directory.  Use the search function of your browser to enter\n""
""search terms.</P><ISINDEX>\n"");
gopherHTMLFooter(VAR_13);
VAR_13->flush();
VAR_0->HTML_header_added = 1;
return;
}
String VAR_15;
if (!VAR_0->HTML_header_added) {
if (VAR_0->conversion == GopherStateData::HTML_CSO_RESULT)
gopherHTMLHeader(VAR_13, ""CSO Search Result"", NULL);
else
gopherHTMLHeader(VAR_13, ""Gopher Menu"", NULL);
VAR_15.append (""<PRE>"");
VAR_0->HTML_header_added = 1;
VAR_0->HTML_pre = 1;
}
while (VAR_3 < VAR_1 + VAR_2) {
int VAR_16;
int VAR_17 = VAR_2 - (VAR_3 - VAR_1);
VAR_4 = (char *)memchr(VAR_3, '\n', VAR_17);
if (VAR_4) {
++VAR_4;             
VAR_16 = VAR_4 - VAR_3;
} else {
VAR_16 = VAR_17;
}
if (VAR_0->len + VAR_16 >= TEMP_BUF_SIZE) {
debugs(10, VAR_18, ""GopherHTML: Buffer overflow. Lost some data on URL: "" << VAR_13->url()  );
VAR_16 = TEMP_BUF_SIZE - VAR_0->len - 1;
VAR_0->overflowed = true; 
}
if (!VAR_4) {
memcpy(VAR_0->buf + VAR_0->len, VAR_3, VAR_16);
VAR_0->len += VAR_16;
break;
}
if (VAR_0->len != 0) {
memcpy(line, VAR_0->buf, VAR_0->len);
memcpy(line + VAR_0->len, VAR_3, VAR_16);
VAR_16 += VAR_0->len;
VAR_0->len = 0;
} else {
memcpy(line, VAR_3, VAR_16);
}
line[VAR_16 + 1] = '\0';
VAR_3 = VAR_4;
if (*line == '.') {
memset(line, '\0', TEMP_BUF_SIZE);
continue;
}
switch (VAR_0->conversion) {
case GopherStateData::HTML_INDEX_RESULT:
case GopherStateData::HTML_DIR: {
VAR_5 = line;
VAR_12 = *VAR_5;
++VAR_5;
VAR_6 = VAR_5;
VAR_7 = strchr(VAR_5, VAR_19);
if (VAR_7) {
*VAR_7 = '\0';
++VAR_7;
VAR_8 = strchr(VAR_7, VAR_19);
if (VAR_8) {
*VAR_8 = '\0';
++VAR_8;
VAR_9 = strchr(VAR_8, VAR_19);
if (VAR_9) {
char *VAR_20;
VAR_9[0] = ':';
VAR_20 = strchr(VAR_8, VAR_19);
if (VAR_20)
*VAR_20++ = 0;    
else {
VAR_20 = strchr(VAR_8, '\r');
if (VAR_20)
*VAR_20++ = 0;    
else {
VAR_20 = strchr(VAR_8, '\n');
if (VAR_20)
*VAR_20++ = 0;    
}
}
if ((VAR_9[1] == '0') && (!VAR_9[2]))
VAR_9[0] = 0;    
}
VAR_10 = xstrdup(rfc1738_escape_part(VAR_7));
switch (VAR_12) {
case VAR_21:
VAR_11 = mimeGetIconURL(""internal-menu"");
break;
case VAR_22:
case VAR_23:
VAR_11 = mimeGetIconURL(""internal-text"");
break;
case VAR_24:
case VAR_25:
VAR_11 = mimeGetIconURL(""internal-index"");
break;
case VAR_26:
case VAR_27:
case VAR_28:
VAR_11 = mimeGetIconURL(""internal-image"");
break;
case VAR_29:
case VAR_30:
VAR_11 = mimeGetIconURL(""internal-sound"");
break;
case VAR_31:
VAR_11 = mimeGetIconURL(""internal-movie"");
break;
case VAR_32:
case VAR_33:
VAR_11 = mimeGetIconURL(""internal-telnet"");
break;
case VAR_34:
case VAR_35:
case VAR_36:
case VAR_37:
VAR_11 = mimeGetIconURL(""internal-binary"");
break;
case VAR_38:
VAR_11 = NULL;
break;
case VAR_39:
VAR_11 = mimeGetIconURL(""internal-link"");
break;
default:
VAR_11 = mimeGetIconURL(""internal-unknown"");
break;
}
memset(tmpbuf, '\0', TEMP_BUF_SIZE);
if ((VAR_12 == VAR_32) || (VAR_12 == VAR_33)) {
if (strlen(VAR_10) != 0)
snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""telnet://%s@%s%s%s/\"">%s</A>\n"",
VAR_11, VAR_10, rfc1738_escape_part(VAR_8),
*VAR_9 ? "":"" : """", VAR_9, html_quote(VAR_6));
else
snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""telnet://%s%s%s/\"">%s</A>\n"",
VAR_11, rfc1738_escape_part(VAR_8), *VAR_9 ? "":"" : """",
VAR_9, html_quote(VAR_6));
} else if (VAR_12 == VAR_38) {
snprintf(tmpbuf, TEMP_BUF_SIZE, ""\t%s\n"", html_quote(VAR_6));
} else {
if (strncmp(VAR_7, ""GET /"", 5) == 0) {
snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""http://%s/%s\"">%s</A>\n"",
VAR_11, VAR_8, rfc1738_escape_unescaped(VAR_7 + 5), html_quote(VAR_6));
} else if (VAR_12 == VAR_39) {
snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""%s\"">%s</A>\n"",
VAR_11, rfc1738_escape_unescaped(VAR_7), html_quote(VAR_6));
} else {
snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""gopher://%s/%c%s\"">%s</A>\n"",
VAR_11, VAR_8, VAR_12, VAR_10, html_quote(VAR_6));
}
}
safe_free(VAR_10);
VAR_15.append(tmpbuf);
} else {
memset(line, '\0', TEMP_BUF_SIZE);
continue;
}
} else {
memset(line, '\0', TEMP_BUF_SIZE);
continue;
}
break;
}           
case GopherStateData::HTML_CSO_RESULT: {
if (line[0] == '-') {
int VAR_40, VAR_41;
char *VAR_42, *VAR_43, *VAR_44;
VAR_42 = strtok(line + 1, "":\n"");
VAR_43 = strtok(NULL, "":\n"");
VAR_44 = strtok(NULL, ""\n"");
if (!VAR_44)
break;
VAR_40 = atoi(VAR_42);
VAR_41 = atoi(VAR_43);
if (VAR_40 != 200)
break;
if (VAR_0->cso_recno != VAR_41) {
snprintf(tmpbuf, TEMP_BUF_SIZE, ""</PRE><HR noshade size=\""1px\""><H2>Record# %d<br><i>%s</i></H2>\n<PRE>"", VAR_41, html_quote(VAR_44));
VAR_0->cso_recno = VAR_41;
} else {
snprintf(tmpbuf, TEMP_BUF_SIZE, ""%s\n"", html_quote(VAR_44));
}
VAR_15.append(tmpbuf);
break;
} else {
int VAR_40;
char *VAR_42, *VAR_44;
VAR_42 = strtok(line, "":"");
VAR_44 = strtok(NULL, ""\n"");
if (!VAR_44)
break;
VAR_40 = atoi(VAR_42);
switch (VAR_40) {
case 200: {
break;
}
case 102:   
case 501:   
case 502: { 
snprintf(tmpbuf, TEMP_BUF_SIZE, ""</PRE><HR noshade size=\""1px\""><H2>%s</H2>\n<PRE>"", html_quote(VAR_44));
VAR_15.append(tmpbuf);
break;
}
}
}
break;
}           
default:
break;      
}           
}               
if (VAR_15.size() > 0) {
VAR_13->append(VAR_15.rawBuf(), VAR_15.size());
VAR_13->flush();
}
VAR_15.clean();
return;
}",squid-cache/squid/5e2ea2b13bd98f53e29964ca26bb0d602a8a12b9/gopher.cc/vul/before/0.json,"static void
gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
{
    char *pos = inbuf;
    char *lpos = NULL;
    char *tline = NULL;
    LOCAL_ARRAY(char, line, TEMP_BUF_SIZE);
    char *name = NULL;
    char *selector = NULL;
    char *host = NULL;
    char *port = NULL;
    char *escaped_selector = NULL;
    const char *icon_url = NULL;
    char gtype;
    StoreEntry *entry = NULL;

    memset(line, '\0', TEMP_BUF_SIZE);

    entry = gopherState->entry;

    if (gopherState->conversion == GopherStateData::HTML_INDEX_PAGE) {
        char *html_url = html_quote(entry->url());
        gopherHTMLHeader(entry, ""Gopher Index %s"", html_url);
        storeAppendPrintf(entry,
                          ""<p>This is a searchable Gopher index. Use the search\n""
                          ""function of your browser to enter search terms.\n""
                          ""<ISINDEX>\n"");
        gopherHTMLFooter(entry);
        /* now let start sending stuff to client */
        entry->flush();
        gopherState->HTML_header_added = 1;

        return;
    }

    if (gopherState->conversion == GopherStateData::HTML_CSO_PAGE) {
        char *html_url = html_quote(entry->url());
        gopherHTMLHeader(entry, ""CSO Search of %s"", html_url);
        storeAppendPrintf(entry,
                          ""<P>A CSO database usually contains a phonebook or\n""
                          ""directory.  Use the search function of your browser to enter\n""
                          ""search terms.</P><ISINDEX>\n"");
        gopherHTMLFooter(entry);
        /* now let start sending stuff to client */
        entry->flush();
        gopherState->HTML_header_added = 1;

        return;
    }

    SBuf outbuf;

    if (!gopherState->HTML_header_added) {
        if (gopherState->conversion == GopherStateData::HTML_CSO_RESULT)
            gopherHTMLHeader(entry, ""CSO Search Result"", NULL);
        else
            gopherHTMLHeader(entry, ""Gopher Menu"", NULL);

        outbuf.append (""<PRE>"");

        gopherState->HTML_header_added = 1;

        gopherState->HTML_pre = 1;
    }

    while (pos < inbuf + len) {
        int llen;
        int left = len - (pos - inbuf);
        lpos = (char *)memchr(pos, '\n', left);
        if (lpos) {
            ++lpos;             /* Next line is after \n */
            llen = lpos - pos;
        } else {
            llen = left;
        }
        if (gopherState->len + llen >= TEMP_BUF_SIZE) {
            debugs(10, DBG_IMPORTANT, ""GopherHTML: Buffer overflow. Lost some data on URL: "" << entry->url()  );
            llen = TEMP_BUF_SIZE - gopherState->len - 1;
            gopherState->overflowed = true; // may already be true
        }
        if (!lpos) {
            /* there is no complete line in inbuf */
            /* copy it to temp buffer */
            /* note: llen is adjusted above */
            memcpy(gopherState->buf + gopherState->len, pos, llen);
            gopherState->len += llen;
            break;
        }
        if (gopherState->len != 0) {
            /* there is something left from last tx. */
            memcpy(line, gopherState->buf, gopherState->len);
            memcpy(line + gopherState->len, pos, llen);
            llen += gopherState->len;
            gopherState->len = 0;
        } else {
            memcpy(line, pos, llen);
        }
        line[llen + 1] = '\0';
        /* move input to next line */
        pos = lpos;

        /* at this point. We should have one line in buffer to process */

        if (*line == '.') {
            /* skip it */
            memset(line, '\0', TEMP_BUF_SIZE);
            continue;
        }

        switch (gopherState->conversion) {

        case GopherStateData::HTML_INDEX_RESULT:

        case GopherStateData::HTML_DIR: {
            tline = line;
            gtype = *tline;
            ++tline;
            name = tline;
            selector = strchr(tline, TAB);

            if (selector) {
                *selector = '\0';
                ++selector;
                host = strchr(selector, TAB);

                if (host) {
                    *host = '\0';
                    ++host;
                    port = strchr(host, TAB);

                    if (port) {
                        char *junk;
                        port[0] = ':';
                        junk = strchr(host, TAB);

                        if (junk)
                            *junk++ = 0;    /* Chop port */
                        else {
                            junk = strchr(host, '\r');

                            if (junk)
                                *junk++ = 0;    /* Chop port */
                            else {
                                junk = strchr(host, '\n');

                                if (junk)
                                    *junk++ = 0;    /* Chop port */
                            }
                        }

                        if ((port[1] == '0') && (!port[2]))
                            port[0] = 0;    /* 0 means none */
                    }

                    /* escape a selector here */
                    escaped_selector = xstrdup(rfc1738_escape_part(selector));

                    switch (gtype) {

                    case GOPHER_DIRECTORY:
                        icon_url = mimeGetIconURL(""internal-menu"");
                        break;

                    case GOPHER_HTML:

                    case GOPHER_FILE:
                        icon_url = mimeGetIconURL(""internal-text"");
                        break;

                    case GOPHER_INDEX:

                    case GOPHER_CSO:
                        icon_url = mimeGetIconURL(""internal-index"");
                        break;

                    case GOPHER_IMAGE:

                    case GOPHER_GIF:

                    case GOPHER_PLUS_IMAGE:
                        icon_url = mimeGetIconURL(""internal-image"");
                        break;

                    case GOPHER_SOUND:

                    case GOPHER_PLUS_SOUND:
                        icon_url = mimeGetIconURL(""internal-sound"");
                        break;

                    case GOPHER_PLUS_MOVIE:
                        icon_url = mimeGetIconURL(""internal-movie"");
                        break;

                    case GOPHER_TELNET:

                    case GOPHER_3270:
                        icon_url = mimeGetIconURL(""internal-telnet"");
                        break;

                    case GOPHER_BIN:

                    case GOPHER_MACBINHEX:

                    case GOPHER_DOSBIN:

                    case GOPHER_UUENCODED:
                        icon_url = mimeGetIconURL(""internal-binary"");
                        break;

                    case GOPHER_INFO:
                        icon_url = NULL;
                        break;

                    case GOPHER_WWW:
                        icon_url = mimeGetIconURL(""internal-link"");
                        break;

                    default:
                        icon_url = mimeGetIconURL(""internal-unknown"");
                        break;
                    }

                    if ((gtype == GOPHER_TELNET) || (gtype == GOPHER_3270)) {
                        if (strlen(escaped_selector) != 0)
                            outbuf.appendf(""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""telnet://%s@%s%s%s/\"">%s</A>\n"",
                                     icon_url, escaped_selector, rfc1738_escape_part(host),
                                     *port ? "":"" : """", port, html_quote(name));
                        else
                            outbuf.appendf(""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""telnet://%s%s%s/\"">%s</A>\n"",
                                     icon_url, rfc1738_escape_part(host), *port ? "":"" : """",
                                     port, html_quote(name));

                    } else if (gtype == GOPHER_INFO) {
                        outbuf.appendf(""\t%s\n"", html_quote(name));
                    } else {
                        if (strncmp(selector, ""GET /"", 5) == 0) {
                            /* WWW link */
                            outbuf.appendf(""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""http://%s/%s\"">%s</A>\n"",
                                     icon_url, host, rfc1738_escape_unescaped(selector + 5), html_quote(name));
                        } else if (gtype == GOPHER_WWW) {
                            outbuf.appendf(""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""gopher://%s/%c%s\"">%s</A>\n"",
                                     icon_url, rfc1738_escape_unescaped(selector), html_quote(name));
                        } else {
                            /* Standard link */
                            outbuf.appendf(""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""gopher://%s/%c%s\"">%s</A>\n"",
                                     icon_url, host, gtype, escaped_selector, html_quote(name));
                        }
                    }

                    safe_free(escaped_selector);
                } else {
                    memset(line, '\0', TEMP_BUF_SIZE);
                    continue;
                }
            } else {
                memset(line, '\0', TEMP_BUF_SIZE);
                continue;
            }

            break;
            }           /* HTML_DIR, HTML_INDEX_RESULT */

        case GopherStateData::HTML_CSO_RESULT: {
            if (line[0] == '-') {
                int code, recno;
                char *s_code, *s_recno, *result;

                s_code = strtok(line + 1, "":\n"");
                s_recno = strtok(NULL, "":\n"");
                result = strtok(NULL, ""\n"");

                if (!result)
                    break;

                code = atoi(s_code);

                recno = atoi(s_recno);

                if (code != 200)
                    break;

                if (gopherState->cso_recno != recno) {
                    outbuf.appendf(""</PRE><HR noshade size=\""1px\""><H2>Record# %d<br><i>%s</i></H2>\n<PRE>"", recno, html_quote(result));
                    gopherState->cso_recno = recno;
                } else {
                    outbuf.appendf(""%s\n"", html_quote(result));
                }

                break;
            } else {
                int code;
                char *s_code, *result;

                s_code = strtok(line, "":"");
                result = strtok(NULL, ""\n"");

                if (!result)
                    break;

                code = atoi(s_code);

                switch (code) {

                case 200: {
                    /* OK */
                    /* Do nothing here */
                    break;
                }

                case 102:   /* Number of matches */

                case 501:   /* No Match */

                case 502: { /* Too Many Matches */
                    /* Print the message the server returns */
                    outbuf.appendf(""</PRE><HR noshade size=\""1px\""><H2>%s</H2>\n<PRE>"", html_quote(result));
                    break;
                }

                }
            }

            break;
            }           /* HTML_CSO_RESULT */
        default:
            break;      /* do nothing */

        }           /* switch */

    }               /* while loop */

    if (outbuf.length() > 0) {
        entry->append(outbuf.rawContent(), outbuf.length());
        /* now let start sending stuff to client */
        entry->flush();
    }

    return;
}","static void
gopherToHTML(GopherStateData * VAR_0, char *VAR_1, int VAR_2)
{
    char *VAR_3 = VAR_1;
    char *VAR_4 = NULL;
    char *VAR_5 = NULL;
    LOCAL_ARRAY(char, line, TEMP_BUF_SIZE);
    char *VAR_6 = NULL;
    char *VAR_7 = NULL;
    char *VAR_8 = NULL;
    char *VAR_9 = NULL;
    char *VAR_10 = NULL;
    const char *VAR_11 = NULL;
    char VAR_12;
    StoreEntry *VAR_13 = NULL;

    memset(line, '\0', TEMP_BUF_SIZE);

    VAR_13 = VAR_0->entry;

    if (VAR_0->conversion == GopherStateData::HTML_INDEX_PAGE) {
        char *VAR_14 = html_quote(VAR_13->url());
        gopherHTMLHeader(VAR_13, ""Gopher Index %s"", VAR_14);
        storeAppendPrintf(VAR_13,
                          ""<p>This is a searchable Gopher index. Use the search\n""
                          ""function of your browser to enter search terms.\n""
                          ""<ISINDEX>\n"");
        gopherHTMLFooter(VAR_13);
        /* COMMENT_0 */
        VAR_13->flush();
        VAR_0->HTML_header_added = 1;

        return;
    }

    if (VAR_0->conversion == GopherStateData::HTML_CSO_PAGE) {
        char *VAR_14 = html_quote(VAR_13->url());
        gopherHTMLHeader(VAR_13, ""CSO Search of %s"", VAR_14);
        storeAppendPrintf(VAR_13,
                          ""<P>A CSO database usually contains a phonebook or\n""
                          ""directory.  Use the search function of your browser to enter\n""
                          ""search terms.</P><ISINDEX>\n"");
        gopherHTMLFooter(VAR_13);
        /* COMMENT_0 */
        VAR_13->flush();
        VAR_0->HTML_header_added = 1;

        return;
    }

    SBuf VAR_15;

    if (!VAR_0->HTML_header_added) {
        if (VAR_0->conversion == GopherStateData::HTML_CSO_RESULT)
            gopherHTMLHeader(VAR_13, ""CSO Search Result"", NULL);
        else
            gopherHTMLHeader(VAR_13, ""Gopher Menu"", NULL);

        VAR_15.append (""<PRE>"");

        VAR_0->HTML_header_added = 1;

        VAR_0->HTML_pre = 1;
    }

    while (VAR_3 < VAR_1 + VAR_2) {
        int VAR_16;
        int VAR_17 = VAR_2 - (VAR_3 - VAR_1);
        VAR_4 = (char *)memchr(VAR_3, '\n', VAR_17);
        if (VAR_4) {
            ++VAR_4;             /* COMMENT_1 */
            VAR_16 = VAR_4 - VAR_3;
        } else {
            VAR_16 = VAR_17;
        }
        if (VAR_0->len + VAR_16 >= TEMP_BUF_SIZE) {
            debugs(10, VAR_18, ""GopherHTML: Buffer overflow. Lost some data on URL: "" << VAR_13->url()  );
            VAR_16 = TEMP_BUF_SIZE - VAR_0->len - 1;
            VAR_0->overflowed = true; /* COMMENT_2 */
        }
        if (!VAR_4) {
            /* COMMENT_3 */
            /* COMMENT_4 */
            /* COMMENT_5 */
            memcpy(VAR_0->buf + VAR_0->len, VAR_3, VAR_16);
            VAR_0->len += VAR_16;
            break;
        }
        if (VAR_0->len != 0) {
            /* COMMENT_6 */
            memcpy(line, VAR_0->buf, VAR_0->len);
            memcpy(line + VAR_0->len, VAR_3, VAR_16);
            VAR_16 += VAR_0->len;
            VAR_0->len = 0;
        } else {
            memcpy(line, VAR_3, VAR_16);
        }
        line[VAR_16 + 1] = '\0';
        /* COMMENT_7 */
        VAR_3 = VAR_4;

        /* COMMENT_8 */

        if (*line == '.') {
            /* COMMENT_9 */
            memset(line, '\0', TEMP_BUF_SIZE);
            continue;
        }

        switch (VAR_0->conversion) {

        case GopherStateData::HTML_INDEX_RESULT:

        case GopherStateData::HTML_DIR: {
            VAR_5 = line;
            VAR_12 = *VAR_5;
            ++VAR_5;
            VAR_6 = VAR_5;
            VAR_7 = strchr(VAR_5, VAR_19);

            if (VAR_7) {
                *VAR_7 = '\0';
                ++VAR_7;
                VAR_8 = strchr(VAR_7, VAR_19);

                if (VAR_8) {
                    *VAR_8 = '\0';
                    ++VAR_8;
                    VAR_9 = strchr(VAR_8, VAR_19);

                    if (VAR_9) {
                        char *VAR_20;
                        VAR_9[0] = ':';
                        VAR_20 = strchr(VAR_8, VAR_19);

                        if (VAR_20)
                            *VAR_20++ = 0;    /* COMMENT_10 */
                        else {
                            VAR_20 = strchr(VAR_8, '\r');

                            if (VAR_20)
                                *VAR_20++ = 0;    /* COMMENT_10 */
                            else {
                                VAR_20 = strchr(VAR_8, '\n');

                                if (VAR_20)
                                    *VAR_20++ = 0;    /* COMMENT_10 */
                            }
                        }

                        if ((VAR_9[1] == '0') && (!VAR_9[2]))
                            VAR_9[0] = 0;    /* COMMENT_11 */
                    }

                    /* COMMENT_12 */
                    VAR_10 = xstrdup(rfc1738_escape_part(VAR_7));

                    switch (VAR_12) {

                    case VAR_21:
                        VAR_11 = mimeGetIconURL(""internal-menu"");
                        break;

                    case VAR_22:

                    case VAR_23:
                        VAR_11 = mimeGetIconURL(""internal-text"");
                        break;

                    case VAR_24:

                    case VAR_25:
                        VAR_11 = mimeGetIconURL(""internal-index"");
                        break;

                    case VAR_26:

                    case VAR_27:

                    case VAR_28:
                        VAR_11 = mimeGetIconURL(""internal-image"");
                        break;

                    case VAR_29:

                    case VAR_30:
                        VAR_11 = mimeGetIconURL(""internal-sound"");
                        break;

                    case VAR_31:
                        VAR_11 = mimeGetIconURL(""internal-movie"");
                        break;

                    case VAR_32:

                    case VAR_33:
                        VAR_11 = mimeGetIconURL(""internal-telnet"");
                        break;

                    case VAR_34:

                    case VAR_35:

                    case VAR_36:

                    case VAR_37:
                        VAR_11 = mimeGetIconURL(""internal-binary"");
                        break;

                    case VAR_38:
                        VAR_11 = NULL;
                        break;

                    case VAR_39:
                        VAR_11 = mimeGetIconURL(""internal-link"");
                        break;

                    default:
                        VAR_11 = mimeGetIconURL(""internal-unknown"");
                        break;
                    }

                    if ((VAR_12 == VAR_32) || (VAR_12 == VAR_33)) {
                        if (strlen(VAR_10) != 0)
                            VAR_15.appendf(""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""telnet://%s@%s%s%s/\"">%s</A>\n"",
                                     VAR_11, VAR_10, rfc1738_escape_part(VAR_8),
                                     *VAR_9 ? "":"" : """", VAR_9, html_quote(VAR_6));
                        else
                            VAR_15.appendf(""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""telnet://%s%s%s/\"">%s</A>\n"",
                                     VAR_11, rfc1738_escape_part(VAR_8), *VAR_9 ? "":"" : """",
                                     VAR_9, html_quote(VAR_6));

                    } else if (VAR_12 == VAR_38) {
                        VAR_15.appendf(""\t%s\n"", html_quote(VAR_6));
                    } else {
                        if (strncmp(VAR_7, ""GET /"", 5) == 0) {
                            /* COMMENT_13 */
                            VAR_15.appendf(""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""http://%s/%s\"">%s</A>\n"",
                                     VAR_11, VAR_8, rfc1738_escape_unescaped(VAR_7 + 5), html_quote(VAR_6));
                        } else if (VAR_12 == VAR_39) {
                            VAR_15.appendf(""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""gopher://%s/%c%s\"">%s</A>\n"",
                                     VAR_11, rfc1738_escape_unescaped(VAR_7), html_quote(VAR_6));
                        } else {
                            /* COMMENT_14 */
                            VAR_15.appendf(""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""gopher://%s/%c%s\"">%s</A>\n"",
                                     VAR_11, VAR_8, VAR_12, VAR_10, html_quote(VAR_6));
                        }
                    }

                    safe_free(VAR_10);
                } else {
                    memset(line, '\0', TEMP_BUF_SIZE);
                    continue;
                }
            } else {
                memset(line, '\0', TEMP_BUF_SIZE);
                continue;
            }

            break;
            }           /* COMMENT_15 */

        case GopherStateData::HTML_CSO_RESULT: {
            if (line[0] == '-') {
                int VAR_40, VAR_41;
                char *VAR_42, *VAR_43, *VAR_44;

                VAR_42 = strtok(line + 1, "":\n"");
                VAR_43 = strtok(NULL, "":\n"");
                VAR_44 = strtok(NULL, ""\n"");

                if (!VAR_44)
                    break;

                VAR_40 = atoi(VAR_42);

                VAR_41 = atoi(VAR_43);

                if (VAR_40 != 200)
                    break;

                if (VAR_0->cso_recno != VAR_41) {
                    VAR_15.appendf(""</PRE><HR noshade size=\""1px\""><H2>Record# %d<br><i>%s</i></H2>\n<PRE>"", VAR_41, html_quote(VAR_44));
                    VAR_0->cso_recno = VAR_41;
                } else {
                    VAR_15.appendf(""%s\n"", html_quote(VAR_44));
                }

                break;
            } else {
                int VAR_40;
                char *VAR_42, *VAR_44;

                VAR_42 = strtok(line, "":"");
                VAR_44 = strtok(NULL, ""\n"");

                if (!VAR_44)
                    break;

                VAR_40 = atoi(VAR_42);

                switch (VAR_40) {

                case 200: {
                    /* COMMENT_16 */
                    /* COMMENT_17 */
                    break;
                }

                case 102:   /* COMMENT_18 */

                case 501:   /* COMMENT_19 */

                case 502: { /* COMMENT_20 */
                    /* COMMENT_21 */
                    VAR_15.appendf(""</PRE><HR noshade size=\""1px\""><H2>%s</H2>\n<PRE>"", html_quote(VAR_44));
                    break;
                }

                }
            }

            break;
            }           /* COMMENT_22 */
        default:
            break;      /* COMMENT_23 */

        }           /* COMMENT_24 */

    }               /* COMMENT_25 */

    if (VAR_15.length() > 0) {
        VAR_13->append(VAR_15.rawContent(), VAR_15.length());
        /* COMMENT_0 */
        VAR_13->flush();
    }

    return;
}",squid-cache/squid/5e2ea2b13bd98f53e29964ca26bb0d602a8a12b9/gopher.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,7 +5,6 @@
     char *lpos = NULL;
     char *tline = NULL;
     LOCAL_ARRAY(char, line, TEMP_BUF_SIZE);
-    LOCAL_ARRAY(char, tmpbuf, TEMP_BUF_SIZE);
     char *name = NULL;
     char *selector = NULL;
     char *host = NULL;
@@ -15,7 +14,6 @@
     char gtype;
     StoreEntry *entry = NULL;
 
-    memset(tmpbuf, '\0', TEMP_BUF_SIZE);
     memset(line, '\0', TEMP_BUF_SIZE);
 
     entry = gopherState->entry;
@@ -50,7 +48,7 @@
         return;
     }
 
-    String outbuf;
+    SBuf outbuf;
 
     if (!gopherState->HTML_header_added) {
         if (gopherState->conversion == GopherStateData::HTML_CSO_RESULT)
@@ -222,37 +220,34 @@
                         break;
                     }
 
-                    memset(tmpbuf, '\0', TEMP_BUF_SIZE);
-
                     if ((gtype == GOPHER_TELNET) || (gtype == GOPHER_3270)) {
                         if (strlen(escaped_selector) != 0)
-                            snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""telnet://%s@%s%s%s/\"">%s</A>\n"",
+                            outbuf.appendf(""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""telnet://%s@%s%s%s/\"">%s</A>\n"",
                                      icon_url, escaped_selector, rfc1738_escape_part(host),
                                      *port ? "":"" : """", port, html_quote(name));
                         else
-                            snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""telnet://%s%s%s/\"">%s</A>\n"",
+                            outbuf.appendf(""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""telnet://%s%s%s/\"">%s</A>\n"",
                                      icon_url, rfc1738_escape_part(host), *port ? "":"" : """",
                                      port, html_quote(name));
 
                     } else if (gtype == GOPHER_INFO) {
-                        snprintf(tmpbuf, TEMP_BUF_SIZE, ""\t%s\n"", html_quote(name));
+                        outbuf.appendf(""\t%s\n"", html_quote(name));
                     } else {
                         if (strncmp(selector, ""GET /"", 5) == 0) {
                             /* WWW link */
-                            snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""http://%s/%s\"">%s</A>\n"",
+                            outbuf.appendf(""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""http://%s/%s\"">%s</A>\n"",
                                      icon_url, host, rfc1738_escape_unescaped(selector + 5), html_quote(name));
                         } else if (gtype == GOPHER_WWW) {
-                            snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""%s\"">%s</A>\n"",
+                            outbuf.appendf(""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""gopher://%s/%c%s\"">%s</A>\n"",
                                      icon_url, rfc1738_escape_unescaped(selector), html_quote(name));
                         } else {
                             /* Standard link */
-                            snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""gopher://%s/%c%s\"">%s</A>\n"",
+                            outbuf.appendf(""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""gopher://%s/%c%s\"">%s</A>\n"",
                                      icon_url, host, gtype, escaped_selector, html_quote(name));
                         }
                     }
 
                     safe_free(escaped_selector);
-                    outbuf.append(tmpbuf);
                 } else {
                     memset(line, '\0', TEMP_BUF_SIZE);
                     continue;
@@ -285,13 +280,12 @@
                     break;
 
                 if (gopherState->cso_recno != recno) {
-                    snprintf(tmpbuf, TEMP_BUF_SIZE, ""</PRE><HR noshade size=\""1px\""><H2>Record# %d<br><i>%s</i></H2>\n<PRE>"", recno, html_quote(result));
+                    outbuf.appendf(""</PRE><HR noshade size=\""1px\""><H2>Record# %d<br><i>%s</i></H2>\n<PRE>"", recno, html_quote(result));
                     gopherState->cso_recno = recno;
                 } else {
-                    snprintf(tmpbuf, TEMP_BUF_SIZE, ""%s\n"", html_quote(result));
-                }
-
-                outbuf.append(tmpbuf);
+                    outbuf.appendf(""%s\n"", html_quote(result));
+                }
+
                 break;
             } else {
                 int code;
@@ -319,8 +313,7 @@
 
                 case 502: { /* Too Many Matches */
                     /* Print the message the server returns */
-                    snprintf(tmpbuf, TEMP_BUF_SIZE, ""</PRE><HR noshade size=\""1px\""><H2>%s</H2>\n<PRE>"", html_quote(result));
-                    outbuf.append(tmpbuf);
+                    outbuf.appendf(""</PRE><HR noshade size=\""1px\""><H2>%s</H2>\n<PRE>"", html_quote(result));
                     break;
                 }
 
@@ -336,12 +329,11 @@
 
     }               /* while loop */
 
-    if (outbuf.size() > 0) {
-        entry->append(outbuf.rawBuf(), outbuf.size());
+    if (outbuf.length() > 0) {
+        entry->append(outbuf.rawContent(), outbuf.length());
         /* now let start sending stuff to client */
         entry->flush();
     }
 
-    outbuf.clean();
     return;
 }","{'deleted_lines': ['    LOCAL_ARRAY(char, tmpbuf, TEMP_BUF_SIZE);', ""    memset(tmpbuf, '\\0', TEMP_BUF_SIZE);"", '    String outbuf;', ""                    memset(tmpbuf, '\\0', TEMP_BUF_SIZE);"", '', '                            snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\\""0\\"" SRC=\\""%s\\""> <A HREF=\\""telnet://%s@%s%s%s/\\"">%s</A>\\n"",', '                            snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\\""0\\"" SRC=\\""%s\\""> <A HREF=\\""telnet://%s%s%s/\\"">%s</A>\\n"",', '                        snprintf(tmpbuf, TEMP_BUF_SIZE, ""\\t%s\\n"", html_quote(name));', '                            snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\\""0\\"" SRC=\\""%s\\""> <A HREF=\\""http://%s/%s\\"">%s</A>\\n"",', '                            snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\\""0\\"" SRC=\\""%s\\""> <A HREF=\\""%s\\"">%s</A>\\n"",', '                            snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\\""0\\"" SRC=\\""%s\\""> <A HREF=\\""gopher://%s/%c%s\\"">%s</A>\\n"",', '                    outbuf.append(tmpbuf);', '                    snprintf(tmpbuf, TEMP_BUF_SIZE, ""</PRE><HR noshade size=\\""1px\\""><H2>Record# %d<br><i>%s</i></H2>\\n<PRE>"", recno, html_quote(result));', '                    snprintf(tmpbuf, TEMP_BUF_SIZE, ""%s\\n"", html_quote(result));', '                }', '', '                outbuf.append(tmpbuf);', '                    snprintf(tmpbuf, TEMP_BUF_SIZE, ""</PRE><HR noshade size=\\""1px\\""><H2>%s</H2>\\n<PRE>"", html_quote(result));', '                    outbuf.append(tmpbuf);', '    if (outbuf.size() > 0) {', '        entry->append(outbuf.rawBuf(), outbuf.size());', '    outbuf.clean();'], 'added_lines': ['    SBuf outbuf;', '                            outbuf.appendf(""<IMG border=\\""0\\"" SRC=\\""%s\\""> <A HREF=\\""telnet://%s@%s%s%s/\\"">%s</A>\\n"",', '                            outbuf.appendf(""<IMG border=\\""0\\"" SRC=\\""%s\\""> <A HREF=\\""telnet://%s%s%s/\\"">%s</A>\\n"",', '                        outbuf.appendf(""\\t%s\\n"", html_quote(name));', '                            outbuf.appendf(""<IMG border=\\""0\\"" SRC=\\""%s\\""> <A HREF=\\""http://%s/%s\\"">%s</A>\\n"",', '                            outbuf.appendf(""<IMG border=\\""0\\"" SRC=\\""%s\\""> <A HREF=\\""gopher://%s/%c%s\\"">%s</A>\\n"",', '                            outbuf.appendf(""<IMG border=\\""0\\"" SRC=\\""%s\\""> <A HREF=\\""gopher://%s/%c%s\\"">%s</A>\\n"",', '                    outbuf.appendf(""</PRE><HR noshade size=\\""1px\\""><H2>Record# %d<br><i>%s</i></H2>\\n<PRE>"", recno, html_quote(result));', '                    outbuf.appendf(""%s\\n"", html_quote(result));', '                }', '', '                    outbuf.appendf(""</PRE><HR noshade size=\\""1px\\""><H2>%s</H2>\\n<PRE>"", html_quote(result));', '    if (outbuf.length() > 0) {', '        entry->append(outbuf.rawContent(), outbuf.length());']}",True,"In Squid 3.x through 3.5.28, 4.x through 4.17, and 5.x before 5.6, due to improper buffer management, a Denial of Service can occur when processing long Gopher server responses.",6.5,MEDIUM,1,test,2022-04-18T13:42:36Z,4
CVE-2023-3439,['CWE-416'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"mctp: defer the kfree of object mdev->addrs

The function mctp_unregister() reclaims the device's relevant resource
when a netcard detaches. However, a running routine may be unaware of
this and cause the use-after-free of the mdev->addrs object.

The race condition can be demonstrated below

 cleanup thread               another thread
                          |
unregister_netdev()       |  mctp_sendmsg()
...                       |    ...
  mctp_unregister()       |    rt = mctp_route_lookup()
    ...                   |    mctl_local_output()
    kfree(mdev->addrs)    |      ...
                          |      saddr = rt->dev->addrs[0];
                          |

An attacker can adopt the (recent provided) mtcpserial driver with pty
to fake the device detaching and use the userfaultfd to increase the
race success chance (in mctp_sendmsg). The KASan report for such a POC
is shown below:

[   86.051955] ==================================================================
[   86.051955] BUG: KASAN: use-after-free in mctp_local_output+0x4e9/0xb7d
[   86.051955] Read of size 1 at addr ffff888005f298c0 by task poc/295
[   86.051955]
[   86.051955] Call Trace:
[   86.051955]  <TASK>
[   86.051955]  dump_stack_lvl+0x33/0x42
[   86.051955]  print_report.cold.13+0xb2/0x6b3
[   86.051955]  ? preempt_schedule_irq+0x57/0x80
[   86.051955]  ? mctp_local_output+0x4e9/0xb7d
[   86.051955]  kasan_report+0xa5/0x120
[   86.051955]  ? mctp_local_output+0x4e9/0xb7d
[   86.051955]  mctp_local_output+0x4e9/0xb7d
[   86.051955]  ? mctp_dev_set_key+0x79/0x79
[   86.051955]  ? copyin+0x38/0x50
[   86.051955]  ? _copy_from_iter+0x1b6/0xf20
[   86.051955]  ? sysvec_apic_timer_interrupt+0x97/0xb0
[   86.051955]  ? asm_sysvec_apic_timer_interrupt+0x12/0x20
[   86.051955]  ? mctp_local_output+0x1/0xb7d
[   86.051955]  mctp_sendmsg+0x64d/0xdb0
[   86.051955]  ? mctp_sk_close+0x20/0x20
[   86.051955]  ? __fget_light+0x2fd/0x4f0
[   86.051955]  ? mctp_sk_close+0x20/0x20
[   86.051955]  sock_sendmsg+0xdd/0x110
[   86.051955]  __sys_sendto+0x1cc/0x2a0
[   86.051955]  ? __ia32_sys_getpeername+0xa0/0xa0
[   86.051955]  ? new_sync_write+0x335/0x550
[   86.051955]  ? alloc_file+0x22f/0x500
[   86.051955]  ? __ip_do_redirect+0x820/0x1820
[   86.051955]  ? vfs_write+0x44d/0x7b0
[   86.051955]  ? vfs_write+0x44d/0x7b0
[   86.051955]  ? fput_many+0x15/0x120
[   86.051955]  ? ksys_write+0x155/0x1b0
[   86.051955]  ? __ia32_sys_read+0xa0/0xa0
[   86.051955]  __x64_sys_sendto+0xd8/0x1b0
[   86.051955]  ? exit_to_user_mode_prepare+0x2f/0x120
[   86.051955]  ? syscall_exit_to_user_mode+0x12/0x20
[   86.051955]  do_syscall_64+0x3a/0x80
[   86.051955]  entry_SYSCALL_64_after_hwframe+0x44/0xae
[   86.051955] RIP: 0033:0x7f82118a56b3
[   86.051955] RSP: 002b:00007ffdb154b110 EFLAGS: 00000293 ORIG_RAX: 000000000000002c
[   86.051955] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f82118a56b3
[   86.051955] RDX: 0000000000000010 RSI: 00007f8211cd4000 RDI: 0000000000000007
[   86.051955] RBP: 00007ffdb154c1d0 R08: 00007ffdb154b164 R09: 000000000000000c
[   86.051955] R10: 0000000000000000 R11: 0000000000000293 R12: 000055d779800db0
[   86.051955] R13: 00007ffdb154c2b0 R14: 0000000000000000 R15: 0000000000000000
[   86.051955]  </TASK>
[   86.051955]
[   86.051955] Allocated by task 295:
[   86.051955]  kasan_save_stack+0x1c/0x40
[   86.051955]  __kasan_kmalloc+0x84/0xa0
[   86.051955]  mctp_rtm_newaddr+0x242/0x610
[   86.051955]  rtnetlink_rcv_msg+0x2fd/0x8b0
[   86.051955]  netlink_rcv_skb+0x11c/0x340
[   86.051955]  netlink_unicast+0x439/0x630
[   86.051955]  netlink_sendmsg+0x752/0xc00
[   86.051955]  sock_sendmsg+0xdd/0x110
[   86.051955]  __sys_sendto+0x1cc/0x2a0
[   86.051955]  __x64_sys_sendto+0xd8/0x1b0
[   86.051955]  do_syscall_64+0x3a/0x80
[   86.051955]  entry_SYSCALL_64_after_hwframe+0x44/0xae
[   86.051955]
[   86.051955] Freed by task 301:
[   86.051955]  kasan_save_stack+0x1c/0x40
[   86.051955]  kasan_set_track+0x21/0x30
[   86.051955]  kasan_set_free_info+0x20/0x30
[   86.051955]  __kasan_slab_free+0x104/0x170
[   86.051955]  kfree+0x8c/0x290
[   86.051955]  mctp_dev_notify+0x161/0x2c0
[   86.051955]  raw_notifier_call_chain+0x8b/0xc0
[   86.051955]  unregister_netdevice_many+0x299/0x1180
[   86.051955]  unregister_netdevice_queue+0x210/0x2f0
[   86.051955]  unregister_netdev+0x13/0x20
[   86.051955]  mctp_serial_close+0x6d/0xa0
[   86.051955]  tty_ldisc_kill+0x31/0xa0
[   86.051955]  tty_ldisc_hangup+0x24f/0x560
[   86.051955]  __tty_hangup.part.28+0x2ce/0x6b0
[   86.051955]  tty_release+0x327/0xc70
[   86.051955]  __fput+0x1df/0x8b0
[   86.051955]  task_work_run+0xca/0x150
[   86.051955]  exit_to_user_mode_prepare+0x114/0x120
[   86.051955]  syscall_exit_to_user_mode+0x12/0x20
[   86.051955]  do_syscall_64+0x46/0x80
[   86.051955]  entry_SYSCALL_64_after_hwframe+0x44/0xae
[   86.051955]
[   86.051955] The buggy address belongs to the object at ffff888005f298c0
[   86.051955]  which belongs to the cache kmalloc-8 of size 8
[   86.051955] The buggy address is located 0 bytes inside of
[   86.051955]  8-byte region [ffff888005f298c0, ffff888005f298c8)
[   86.051955]
[   86.051955] The buggy address belongs to the physical page:
[   86.051955] flags: 0x100000000000200(slab|node=0|zone=1)
[   86.051955] raw: 0100000000000200 dead000000000100 dead000000000122 ffff888005c42280
[   86.051955] raw: 0000000000000000 0000000080660066 00000001ffffffff 0000000000000000
[   86.051955] page dumped because: kasan: bad access detected
[   86.051955]
[   86.051955] Memory state around the buggy address:
[   86.051955]  ffff888005f29780: 00 fc fc fc fc 00 fc fc fc fc 00 fc fc fc fc 00
[   86.051955]  ffff888005f29800: fc fc fc fc 00 fc fc fc fc 00 fc fc fc fc 00 fc
[   86.051955] >ffff888005f29880: fc fc fc fb fc fc fc fc fa fc fc fc fc fa fc fc
[   86.051955]                                            ^
[   86.051955]  ffff888005f29900: fc fc 00 fc fc fc fc 00 fc fc fc fc 00 fc fc fc
[   86.051955]  ffff888005f29980: fc 00 fc fc fc fc 00 fc fc fc fc 00 fc fc fc fc
[   86.051955] ==================================================================

To this end, just like the commit e04480920d1e (""Bluetooth: defer
cleanup of resources in hci_unregister_dev()"")  this patch defers the
destructive kfree(mdev->addrs) in mctp_unregister to the mctp_dev_put,
where the refcount of mdev is zero and the entire device is reclaimed.
This prevents the use-after-free because the sendmsg thread holds the
reference of mdev in the mctp_route object.

Fixes: 583be982d934 (mctp: Add device handling and netlink interface)
Signed-off-by: Lin Ma <linma@zju.edu.cn>
Acked-by: Jeremy Kerr <jk@codeconstruct.com.au>
Link: https://lore.kernel.org/r/20220422114340.32346-1-linma@zju.edu.cn
Signed-off-by: Paolo Abeni <pabeni@redhat.com>",b561275d633bcd8e0e8055ab86f1a13df75a0269,https://github.com/torvalds/linux/commit/b561275d633bcd8e0e8055ab86f1a13df75a0269,net/mctp/device.c,mctp_unregister,"static void mctp_unregister(struct net_device *dev)
{
struct mctp_dev *mdev;
mdev = mctp_dev_get_rtnl(dev);
if (mdev && !mctp_known(dev)) {
netdev_warn(dev, ""%s: BUG mctp_ptr set for unknown type %d"",
__func__, dev->type);
return;
}
if (!mdev)
return;
RCU_INIT_POINTER(mdev->dev->mctp_ptr, NULL);
mctp_route_remove_dev(mdev);
mctp_neigh_remove_dev(mdev);
kfree(mdev->addrs);
mctp_dev_put(mdev);
}","static void mctp_unregister(struct net_device *VAR_0)
{
struct mctp_dev *VAR_1;
VAR_1 = mctp_dev_get_rtnl(VAR_0);
if (VAR_1 && !mctp_known(VAR_0)) {
netdev_warn(VAR_0, ""%s: BUG mctp_ptr set for unknown type %d"",
VAR_2, VAR_0->type);
return;
}
if (!VAR_1)
return;
RCU_INIT_POINTER(VAR_1->dev->mctp_ptr, NULL);
mctp_route_remove_dev(VAR_1);
mctp_neigh_remove_dev(VAR_1);
kfree(VAR_1->addrs);
mctp_dev_put(VAR_1);
}",torvalds/linux/b561275d633bcd8e0e8055ab86f1a13df75a0269/device.c/vul/before/0.json,"static void mctp_unregister(struct net_device *dev)
{
	struct mctp_dev *mdev;

	mdev = mctp_dev_get_rtnl(dev);
	if (mdev && !mctp_known(dev)) {
		// Sanity check, should match what was set in mctp_register
		netdev_warn(dev, ""%s: BUG mctp_ptr set for unknown type %d"",
			    __func__, dev->type);
		return;
	}
	if (!mdev)
		return;

	RCU_INIT_POINTER(mdev->dev->mctp_ptr, NULL);

	mctp_route_remove_dev(mdev);
	mctp_neigh_remove_dev(mdev);

	mctp_dev_put(mdev);
}","static void mctp_unregister(struct net_device *VAR_0)
{
	struct mctp_dev *VAR_1;

	VAR_1 = mctp_dev_get_rtnl(VAR_0);
	if (VAR_1 && !mctp_known(VAR_0)) {
		/* COMMENT_0 */
		netdev_warn(VAR_0, ""%s: BUG mctp_ptr set for unknown type %d"",
			    VAR_2, VAR_0->type);
		return;
	}
	if (!VAR_1)
		return;

	RCU_INIT_POINTER(VAR_1->dev->mctp_ptr, NULL);

	mctp_route_remove_dev(VAR_1);
	mctp_neigh_remove_dev(VAR_1);

	mctp_dev_put(VAR_1);
}",torvalds/linux/b561275d633bcd8e0e8055ab86f1a13df75a0269/device.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -16,7 +16,6 @@
 
 	mctp_route_remove_dev(mdev);
 	mctp_neigh_remove_dev(mdev);
-	kfree(mdev->addrs);
 
 	mctp_dev_put(mdev);
 }","{'deleted_lines': ['\tkfree(mdev->addrs);'], 'added_lines': []}",True,"A flaw was found in the MCTP protocol in the Linux kernel. The function mctp_unregister() reclaims the device's relevant resource when a netcard detaches. However, a running routine may be unaware of this and cause the use-after-free of the mdev->addrs object, potentially leading to a denial of service.",4.7,MEDIUM,1,test,2022-04-22T11:43:40Z,4
CVE-2023-3439,['CWE-416'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"mctp: defer the kfree of object mdev->addrs

The function mctp_unregister() reclaims the device's relevant resource
when a netcard detaches. However, a running routine may be unaware of
this and cause the use-after-free of the mdev->addrs object.

The race condition can be demonstrated below

 cleanup thread               another thread
                          |
unregister_netdev()       |  mctp_sendmsg()
...                       |    ...
  mctp_unregister()       |    rt = mctp_route_lookup()
    ...                   |    mctl_local_output()
    kfree(mdev->addrs)    |      ...
                          |      saddr = rt->dev->addrs[0];
                          |

An attacker can adopt the (recent provided) mtcpserial driver with pty
to fake the device detaching and use the userfaultfd to increase the
race success chance (in mctp_sendmsg). The KASan report for such a POC
is shown below:

[   86.051955] ==================================================================
[   86.051955] BUG: KASAN: use-after-free in mctp_local_output+0x4e9/0xb7d
[   86.051955] Read of size 1 at addr ffff888005f298c0 by task poc/295
[   86.051955]
[   86.051955] Call Trace:
[   86.051955]  <TASK>
[   86.051955]  dump_stack_lvl+0x33/0x42
[   86.051955]  print_report.cold.13+0xb2/0x6b3
[   86.051955]  ? preempt_schedule_irq+0x57/0x80
[   86.051955]  ? mctp_local_output+0x4e9/0xb7d
[   86.051955]  kasan_report+0xa5/0x120
[   86.051955]  ? mctp_local_output+0x4e9/0xb7d
[   86.051955]  mctp_local_output+0x4e9/0xb7d
[   86.051955]  ? mctp_dev_set_key+0x79/0x79
[   86.051955]  ? copyin+0x38/0x50
[   86.051955]  ? _copy_from_iter+0x1b6/0xf20
[   86.051955]  ? sysvec_apic_timer_interrupt+0x97/0xb0
[   86.051955]  ? asm_sysvec_apic_timer_interrupt+0x12/0x20
[   86.051955]  ? mctp_local_output+0x1/0xb7d
[   86.051955]  mctp_sendmsg+0x64d/0xdb0
[   86.051955]  ? mctp_sk_close+0x20/0x20
[   86.051955]  ? __fget_light+0x2fd/0x4f0
[   86.051955]  ? mctp_sk_close+0x20/0x20
[   86.051955]  sock_sendmsg+0xdd/0x110
[   86.051955]  __sys_sendto+0x1cc/0x2a0
[   86.051955]  ? __ia32_sys_getpeername+0xa0/0xa0
[   86.051955]  ? new_sync_write+0x335/0x550
[   86.051955]  ? alloc_file+0x22f/0x500
[   86.051955]  ? __ip_do_redirect+0x820/0x1820
[   86.051955]  ? vfs_write+0x44d/0x7b0
[   86.051955]  ? vfs_write+0x44d/0x7b0
[   86.051955]  ? fput_many+0x15/0x120
[   86.051955]  ? ksys_write+0x155/0x1b0
[   86.051955]  ? __ia32_sys_read+0xa0/0xa0
[   86.051955]  __x64_sys_sendto+0xd8/0x1b0
[   86.051955]  ? exit_to_user_mode_prepare+0x2f/0x120
[   86.051955]  ? syscall_exit_to_user_mode+0x12/0x20
[   86.051955]  do_syscall_64+0x3a/0x80
[   86.051955]  entry_SYSCALL_64_after_hwframe+0x44/0xae
[   86.051955] RIP: 0033:0x7f82118a56b3
[   86.051955] RSP: 002b:00007ffdb154b110 EFLAGS: 00000293 ORIG_RAX: 000000000000002c
[   86.051955] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f82118a56b3
[   86.051955] RDX: 0000000000000010 RSI: 00007f8211cd4000 RDI: 0000000000000007
[   86.051955] RBP: 00007ffdb154c1d0 R08: 00007ffdb154b164 R09: 000000000000000c
[   86.051955] R10: 0000000000000000 R11: 0000000000000293 R12: 000055d779800db0
[   86.051955] R13: 00007ffdb154c2b0 R14: 0000000000000000 R15: 0000000000000000
[   86.051955]  </TASK>
[   86.051955]
[   86.051955] Allocated by task 295:
[   86.051955]  kasan_save_stack+0x1c/0x40
[   86.051955]  __kasan_kmalloc+0x84/0xa0
[   86.051955]  mctp_rtm_newaddr+0x242/0x610
[   86.051955]  rtnetlink_rcv_msg+0x2fd/0x8b0
[   86.051955]  netlink_rcv_skb+0x11c/0x340
[   86.051955]  netlink_unicast+0x439/0x630
[   86.051955]  netlink_sendmsg+0x752/0xc00
[   86.051955]  sock_sendmsg+0xdd/0x110
[   86.051955]  __sys_sendto+0x1cc/0x2a0
[   86.051955]  __x64_sys_sendto+0xd8/0x1b0
[   86.051955]  do_syscall_64+0x3a/0x80
[   86.051955]  entry_SYSCALL_64_after_hwframe+0x44/0xae
[   86.051955]
[   86.051955] Freed by task 301:
[   86.051955]  kasan_save_stack+0x1c/0x40
[   86.051955]  kasan_set_track+0x21/0x30
[   86.051955]  kasan_set_free_info+0x20/0x30
[   86.051955]  __kasan_slab_free+0x104/0x170
[   86.051955]  kfree+0x8c/0x290
[   86.051955]  mctp_dev_notify+0x161/0x2c0
[   86.051955]  raw_notifier_call_chain+0x8b/0xc0
[   86.051955]  unregister_netdevice_many+0x299/0x1180
[   86.051955]  unregister_netdevice_queue+0x210/0x2f0
[   86.051955]  unregister_netdev+0x13/0x20
[   86.051955]  mctp_serial_close+0x6d/0xa0
[   86.051955]  tty_ldisc_kill+0x31/0xa0
[   86.051955]  tty_ldisc_hangup+0x24f/0x560
[   86.051955]  __tty_hangup.part.28+0x2ce/0x6b0
[   86.051955]  tty_release+0x327/0xc70
[   86.051955]  __fput+0x1df/0x8b0
[   86.051955]  task_work_run+0xca/0x150
[   86.051955]  exit_to_user_mode_prepare+0x114/0x120
[   86.051955]  syscall_exit_to_user_mode+0x12/0x20
[   86.051955]  do_syscall_64+0x46/0x80
[   86.051955]  entry_SYSCALL_64_after_hwframe+0x44/0xae
[   86.051955]
[   86.051955] The buggy address belongs to the object at ffff888005f298c0
[   86.051955]  which belongs to the cache kmalloc-8 of size 8
[   86.051955] The buggy address is located 0 bytes inside of
[   86.051955]  8-byte region [ffff888005f298c0, ffff888005f298c8)
[   86.051955]
[   86.051955] The buggy address belongs to the physical page:
[   86.051955] flags: 0x100000000000200(slab|node=0|zone=1)
[   86.051955] raw: 0100000000000200 dead000000000100 dead000000000122 ffff888005c42280
[   86.051955] raw: 0000000000000000 0000000080660066 00000001ffffffff 0000000000000000
[   86.051955] page dumped because: kasan: bad access detected
[   86.051955]
[   86.051955] Memory state around the buggy address:
[   86.051955]  ffff888005f29780: 00 fc fc fc fc 00 fc fc fc fc 00 fc fc fc fc 00
[   86.051955]  ffff888005f29800: fc fc fc fc 00 fc fc fc fc 00 fc fc fc fc 00 fc
[   86.051955] >ffff888005f29880: fc fc fc fb fc fc fc fc fa fc fc fc fc fa fc fc
[   86.051955]                                            ^
[   86.051955]  ffff888005f29900: fc fc 00 fc fc fc fc 00 fc fc fc fc 00 fc fc fc
[   86.051955]  ffff888005f29980: fc 00 fc fc fc fc 00 fc fc fc fc 00 fc fc fc fc
[   86.051955] ==================================================================

To this end, just like the commit e04480920d1e (""Bluetooth: defer
cleanup of resources in hci_unregister_dev()"")  this patch defers the
destructive kfree(mdev->addrs) in mctp_unregister to the mctp_dev_put,
where the refcount of mdev is zero and the entire device is reclaimed.
This prevents the use-after-free because the sendmsg thread holds the
reference of mdev in the mctp_route object.

Fixes: 583be982d934 (mctp: Add device handling and netlink interface)
Signed-off-by: Lin Ma <linma@zju.edu.cn>
Acked-by: Jeremy Kerr <jk@codeconstruct.com.au>
Link: https://lore.kernel.org/r/20220422114340.32346-1-linma@zju.edu.cn
Signed-off-by: Paolo Abeni <pabeni@redhat.com>",b561275d633bcd8e0e8055ab86f1a13df75a0269,https://github.com/torvalds/linux/commit/b561275d633bcd8e0e8055ab86f1a13df75a0269,net/mctp/device.c,mctp_dev_put,"void mctp_dev_put(struct mctp_dev *mdev)
{
if (mdev && refcount_dec_and_test(&mdev->refs)) {
dev_put(mdev->dev);
kfree_rcu(mdev, rcu);
}
}","void mctp_dev_put(struct mctp_dev *VAR_0)
{
if (VAR_0 && refcount_dec_and_test(&VAR_0->refs)) {
dev_put(VAR_0->dev);
kfree_rcu(VAR_0, VAR_1);
}
}",torvalds/linux/b561275d633bcd8e0e8055ab86f1a13df75a0269/device.c/vul/before/1.json,"void mctp_dev_put(struct mctp_dev *mdev)
{
	if (mdev && refcount_dec_and_test(&mdev->refs)) {
		kfree(mdev->addrs);
		dev_put(mdev->dev);
		kfree_rcu(mdev, rcu);
	}
}","void mctp_dev_put(struct mctp_dev *VAR_0)
{
	if (VAR_0 && refcount_dec_and_test(&VAR_0->refs)) {
		kfree(VAR_0->addrs);
		dev_put(VAR_0->dev);
		kfree_rcu(VAR_0, VAR_1);
	}
}",torvalds/linux/b561275d633bcd8e0e8055ab86f1a13df75a0269/device.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,6 +1,7 @@
 void mctp_dev_put(struct mctp_dev *mdev)
 {
 	if (mdev && refcount_dec_and_test(&mdev->refs)) {
+		kfree(mdev->addrs);
 		dev_put(mdev->dev);
 		kfree_rcu(mdev, rcu);
 	}","{'deleted_lines': [], 'added_lines': ['\t\tkfree(mdev->addrs);']}",True,"A flaw was found in the MCTP protocol in the Linux kernel. The function mctp_unregister() reclaims the device's relevant resource when a netcard detaches. However, a running routine may be unaware of this and cause the use-after-free of the mdev->addrs object, potentially leading to a denial of service.",4.7,MEDIUM,1,test,2022-04-22T11:43:40Z,4
CVE-2022-1533,['CWE-125'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,bfabiszewski/libmobi,Fix wrong boundary checks in inflections parser resulting in stack buffer over-read with corrupt input,eafc415bc6067e72577f70d6dd5acbf057ce6e6f,https://github.com/bfabiszewski/libmobi/commit/eafc415bc6067e72577f70d6dd5acbf057ce6e6f,src/index.c,mobi_decode_infl,"MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsigned char *rule) {
int pos = *decoded_size;
char mod = 'i';
char dir = '<';
char olddir;
unsigned char c;
while ((c = *rule++)) {
if (c <= 4) {
mod = (c <= 2) ? 'i' : 'd'; 
olddir = dir;
dir = (c & 2) ? '<' : '>'; 
if (olddir != dir && olddir) {
pos = (c & 2) ? *decoded_size : 0;
}
}
else if (c > 10 && c < 20) {
if (dir == '>') {
pos = *decoded_size;
}
pos -= c - 10;
dir = 0;
if (pos < 0 || pos > *decoded_size) {
debug_print(""Position setting failed (%s)\n"", decoded);
return MOBI_DATA_CORRUPT;
}
}
else {
if (mod == 'i') {
const unsigned char *s = decoded + pos;
unsigned char *d = decoded + pos + 1;
const int l = *decoded_size - pos;
if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {
debug_print(""Out of buffer in %s at pos: %i\n"", decoded, pos);
return MOBI_DATA_CORRUPT;
}
memmove(d, s, (size_t) l);
decoded[pos] = c;
(*decoded_size)++;
if (dir == '>') { pos++; }
} else {
if (dir == '<') { pos--; }
const unsigned char *s = decoded + pos + 1;
unsigned char *d = decoded + pos;
const int l = *decoded_size - pos;
if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {
debug_print(""Out of buffer in %s at pos: %i\n"", decoded, pos);
return MOBI_DATA_CORRUPT;
}
if (decoded[pos] != c) {
debug_print(""Character mismatch in %s at pos: %i (%c != %c)\n"", decoded, pos, decoded[pos], c);
return MOBI_DATA_CORRUPT;
}
memmove(d, s, (size_t) l);
(*decoded_size)--;
}
}
}
return MOBI_SUCCESS;
}","MOBI_RET mobi_decode_infl(unsigned char *VAR_0, int *VAR_1, const unsigned char *VAR_2) {
int VAR_3 = *VAR_1;
char VAR_4 = 'i';
char VAR_5 = '<';
char VAR_6;
unsigned char VAR_7;
while ((VAR_7 = *VAR_2++)) {
if (VAR_7 <= 4) {
VAR_4 = (VAR_7 <= 2) ? 'i' : 'd'; 
VAR_6 = VAR_5;
VAR_5 = (VAR_7 & 2) ? '<' : '>'; 
if (VAR_6 != VAR_5 && VAR_6) {
VAR_3 = (VAR_7 & 2) ? *VAR_1 : 0;
}
}
else if (VAR_7 > 10 && VAR_7 < 20) {
if (VAR_5 == '>') {
VAR_3 = *VAR_1;
}
VAR_3 -= VAR_7 - 10;
VAR_5 = 0;
if (VAR_3 < 0 || VAR_3 > *VAR_1) {
debug_print(""Position setting failed (%s)\n"", VAR_0);
return VAR_8;
}
}
else {
if (VAR_4 == 'i') {
const unsigned char *VAR_9 = VAR_0 + VAR_3;
unsigned char *VAR_10 = VAR_0 + VAR_3 + 1;
const int VAR_11 = *VAR_1 - VAR_3;
if (VAR_11 < 0 || VAR_10 + VAR_11 > VAR_0 + VAR_12) {
debug_print(""Out of buffer in %s at pos: %i\n"", VAR_0, VAR_3);
return VAR_8;
}
memmove(VAR_10, VAR_9, (size_t) VAR_11);
VAR_0[VAR_3] = VAR_7;
(*VAR_1)++;
if (VAR_5 == '>') { VAR_3++; }
} else {
if (VAR_5 == '<') { VAR_3--; }
const unsigned char *VAR_9 = VAR_0 + VAR_3 + 1;
unsigned char *VAR_10 = VAR_0 + VAR_3;
const int VAR_11 = *VAR_1 - VAR_3;
if (VAR_11 < 0 || VAR_10 + VAR_11 > VAR_0 + VAR_12) {
debug_print(""Out of buffer in %s at pos: %i\n"", VAR_0, VAR_3);
return VAR_8;
}
if (VAR_0[VAR_3] != VAR_7) {
debug_print(""Character mismatch in %s at pos: %i (%c != %c)\n"", VAR_0, VAR_3, VAR_0[VAR_3], VAR_7);
return VAR_8;
}
memmove(VAR_10, VAR_9, (size_t) VAR_11);
(*VAR_1)--;
}
}
}
return VAR_13;
}",bfabiszewski/libmobi/eafc415bc6067e72577f70d6dd5acbf057ce6e6f/index.c/vul/before/0.json,"MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsigned char *rule) {
    int pos = *decoded_size;
    char mod = 'i';
    char dir = '<';
    char olddir;
    unsigned char c;
    while ((c = *rule++)) {
        if (c <= 4) {
            mod = (c <= 2) ? 'i' : 'd'; /* insert, delete */
            olddir = dir;
            dir = (c & 2) ? '<' : '>'; /* left, right */
            if (olddir != dir && olddir) {
                pos = (c & 2) ? *decoded_size : 0;
            }
        }
        else if (c > 10 && c < 20) {
            if (dir == '>') {
                pos = *decoded_size;
            }
            pos -= c - 10;
            dir = 0;
        }
        else {
            if (mod == 'i') {
                const unsigned char *s = decoded + pos;
                unsigned char *d = decoded + pos + 1;
                const int l = *decoded_size - pos;
                if (pos < 0 || l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {
                    debug_print(""Out of buffer in %s at pos: %i\n"", decoded, pos);
                    return MOBI_DATA_CORRUPT;
                }
                memmove(d, s, (size_t) l);
                decoded[pos] = c;
                (*decoded_size)++;
                if (dir == '>') { pos++; }
            } else {
                if (dir == '<') { pos--; }
                const unsigned char *s = decoded + pos + 1;
                unsigned char *d = decoded + pos;
                const int l = *decoded_size - pos;
                if (pos < 0 || l < 0 || s + l > decoded + INDX_INFLBUF_SIZEMAX) {
                    debug_print(""Out of buffer in %s at pos: %i\n"", decoded, pos);
                    return MOBI_DATA_CORRUPT;
                }
                if (decoded[pos] != c) {
                    debug_print(""Character mismatch in %s at pos: %i (%c != %c)\n"", decoded, pos, decoded[pos], c);
                    return MOBI_DATA_CORRUPT;
                }
                memmove(d, s, (size_t) l);
                (*decoded_size)--;
            }
        }
    }
    return MOBI_SUCCESS;
}","MOBI_RET mobi_decode_infl(unsigned char *VAR_0, int *VAR_1, const unsigned char *VAR_2) {
    int VAR_3 = *VAR_1;
    char VAR_4 = 'i';
    char VAR_5 = '<';
    char VAR_6;
    unsigned char VAR_7;
    while ((VAR_7 = *VAR_2++)) {
        if (VAR_7 <= 4) {
            VAR_4 = (VAR_7 <= 2) ? 'i' : 'd'; /* COMMENT_0 */
            VAR_6 = VAR_5;
            VAR_5 = (VAR_7 & 2) ? '<' : '>'; /* COMMENT_1 */
            if (VAR_6 != VAR_5 && VAR_6) {
                VAR_3 = (VAR_7 & 2) ? *VAR_1 : 0;
            }
        }
        else if (VAR_7 > 10 && VAR_7 < 20) {
            if (VAR_5 == '>') {
                VAR_3 = *VAR_1;
            }
            VAR_3 -= VAR_7 - 10;
            VAR_5 = 0;
        }
        else {
            if (VAR_4 == 'i') {
                const unsigned char *VAR_8 = VAR_0 + VAR_3;
                unsigned char *VAR_9 = VAR_0 + VAR_3 + 1;
                const int VAR_10 = *VAR_1 - VAR_3;
                if (VAR_3 < 0 || VAR_10 < 0 || VAR_9 + VAR_10 > VAR_0 + VAR_11) {
                    debug_print(""Out of buffer in %s at pos: %i\n"", VAR_0, VAR_3);
                    return VAR_12;
                }
                memmove(VAR_9, VAR_8, (size_t) VAR_10);
                VAR_0[VAR_3] = VAR_7;
                (*VAR_1)++;
                if (VAR_5 == '>') { VAR_3++; }
            } else {
                if (VAR_5 == '<') { VAR_3--; }
                const unsigned char *VAR_8 = VAR_0 + VAR_3 + 1;
                unsigned char *VAR_9 = VAR_0 + VAR_3;
                const int VAR_10 = *VAR_1 - VAR_3;
                if (VAR_3 < 0 || VAR_10 < 0 || VAR_8 + VAR_10 > VAR_0 + VAR_11) {
                    debug_print(""Out of buffer in %s at pos: %i\n"", VAR_0, VAR_3);
                    return VAR_12;
                }
                if (VAR_0[VAR_3] != VAR_7) {
                    debug_print(""Character mismatch in %s at pos: %i (%c != %c)\n"", VAR_0, VAR_3, VAR_0[VAR_3], VAR_7);
                    return VAR_12;
                }
                memmove(VAR_9, VAR_8, (size_t) VAR_10);
                (*VAR_1)--;
            }
        }
    }
    return VAR_13;
}",bfabiszewski/libmobi/eafc415bc6067e72577f70d6dd5acbf057ce6e6f/index.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -19,17 +19,13 @@
             }
             pos -= c - 10;
             dir = 0;
-            if (pos < 0 || pos > *decoded_size) {
-                debug_print(""Position setting failed (%s)\n"", decoded);
-                return MOBI_DATA_CORRUPT;
-            }
         }
         else {
             if (mod == 'i') {
                 const unsigned char *s = decoded + pos;
                 unsigned char *d = decoded + pos + 1;
                 const int l = *decoded_size - pos;
-                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {
+                if (pos < 0 || l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {
                     debug_print(""Out of buffer in %s at pos: %i\n"", decoded, pos);
                     return MOBI_DATA_CORRUPT;
                 }
@@ -42,7 +38,7 @@
                 const unsigned char *s = decoded + pos + 1;
                 unsigned char *d = decoded + pos;
                 const int l = *decoded_size - pos;
-                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {
+                if (pos < 0 || l < 0 || s + l > decoded + INDX_INFLBUF_SIZEMAX) {
                     debug_print(""Out of buffer in %s at pos: %i\n"", decoded, pos);
                     return MOBI_DATA_CORRUPT;
                 }","{'deleted_lines': ['            if (pos < 0 || pos > *decoded_size) {', '                debug_print(""Position setting failed (%s)\\n"", decoded);', '                return MOBI_DATA_CORRUPT;', '            }', '                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {', '                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {'], 'added_lines': ['                if (pos < 0 || l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {', '                if (pos < 0 || l < 0 || s + l > decoded + INDX_INFLBUF_SIZEMAX) {']}",True,Buffer Over-read in GitHub repository bfabiszewski/libmobi prior to 0.11. This vulnerability is capable of arbitrary code execution.,7.8,HIGH,2,test,2022-04-27T10:31:59Z,4
CVE-2022-29197,['CWE-20'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,tensorflow,"Fix tf.raw_ops.UnsortedSegmentJoin vulnerability with invalid num_segments.

Check that input is actually a scalar before treating it as such.

PiperOrigin-RevId: 445206880",13d38a07ce9143e044aa737cfd7bb759d0e9b400,https://github.com/tensorflow/tensorflow/commit/13d38a07ce9143e044aa737cfd7bb759d0e9b400,tensorflow/core/kernels/unsorted_segment_join_op.cc,Compute,"void Compute(OpKernelContext* context) override {
const Tensor& input = context->input(0);
const TensorShape& input_shape = input.shape();
const int32_t input_dims = input_shape.dims();
const Tensor& segment_id = context->input(1);
const TensorShape& segment_id_shape = segment_id.shape();
const int32_t segment_dims = segment_id_shape.dims();
const Tensor& num_segments_tensor = context->input(2);
OP_REQUIRES(context, num_segments_tensor.NumElements() != 0,
errors::InvalidArgument(""Number of segments cannot be empty.""));
auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();
OP_REQUIRES(
context, num_segments >= 0,
errors::InvalidArgument(
""Number of segments must be non-negative but got "", num_segments));
OP_REQUIRES(context, segment_dims != 0,
errors::InvalidArgument(""Segment_id cannot have rank 0""));
OP_REQUIRES(
context, segment_dims <= input_dims,
errors::OutOfRange(""Invalid segment_id rank "", segment_dims,
"" for input with "", input_dims, "" dimension(s)""));
for (auto i = 0; i < segment_dims; i++) {
OP_REQUIRES(
context, segment_id_shape.dim_size(i) == input_shape.dim_size(i),
errors::InvalidArgument(
""Segment dimension is "", segment_id_shape.dim_size(i),
"" while input dimension is "", input_dims, "" in rank "", i));
}
Tensor* output_tensor = nullptr;
TensorShape output_shape =
GetOutputShape(input_shape, segment_id_shape, num_segments);
OP_REQUIRES_OK(context, context->allocate_output(""output"", output_shape,
&output_tensor));
auto output_flat = output_tensor->flat<tstring>();
auto flat_segment_id = segment_id.flat<INDICES_TYPE>();
auto flat_input = input.flat<tstring>();
for (int i = 0; i < flat_segment_id.size(); i++) {
OP_REQUIRES(
context,
((flat_segment_id(i) < num_segments) && (flat_segment_id(i) >= 0)),
errors::InvalidArgument(
""segment_ids are not allowed to exceed num_segments or""
"" to have negative values.""));
}
int64_t big_stride;
int64_t small_stride;
std::tie(big_stride, small_stride) =
GetStrides<INDICES_TYPE>(input_shape, segment_id_shape);
auto relative_offset_set =
GetFlattenedRelativeOffsets<INDICES_TYPE>(small_stride, big_stride);
for (auto start_offset = 0; start_offset < big_stride; start_offset++) {
for (auto i = 0; i < relative_offset_set.size(); i++) {
auto output_index = start_offset + flat_segment_id(i) * big_stride;
auto offset = start_offset + relative_offset_set[i];
if (output_flat(output_index).length() != 0)
output_flat(output_index).append(separator_.c_str());
output_flat(output_index).append(flat_input(offset));
}
}
}","void Compute(OpKernelContext* VAR_0) override {
const Tensor& VAR_1 = VAR_0->input(0);
const TensorShape& VAR_2 = VAR_1.shape();
const int32_t VAR_3 = VAR_2.dims();
const Tensor& VAR_4 = VAR_0->input(1);
const TensorShape& VAR_5 = VAR_4.shape();
const int32_t VAR_6 = VAR_5.dims();
const Tensor& VAR_7 = VAR_0->input(2);
OP_REQUIRES(VAR_0, VAR_7.NumElements() != 0,
errors::InvalidArgument(""Number of segments cannot be empty.""));
auto VAR_8 = VAR_7.scalar<NUM_SEGMENTS_TYPE>()();
OP_REQUIRES(
VAR_0, VAR_8 >= 0,
errors::InvalidArgument(
""Number of segments must be non-negative but got "", VAR_8));
OP_REQUIRES(VAR_0, VAR_6 != 0,
errors::InvalidArgument(""Segment_id cannot have rank 0""));
OP_REQUIRES(
VAR_0, VAR_6 <= VAR_3,
errors::OutOfRange(""Invalid segment_id rank "", VAR_6,
"" for input with "", VAR_3, "" dimension(s)""));
for (auto VAR_9 = 0; VAR_9 < VAR_6; VAR_9++) {
OP_REQUIRES(
VAR_0, VAR_5.dim_size(VAR_9) == VAR_2.dim_size(VAR_9),
errors::InvalidArgument(
""Segment dimension is "", VAR_5.dim_size(VAR_9),
"" while input dimension is "", VAR_3, "" in rank "", VAR_9));
}
Tensor* VAR_10 = nullptr;
TensorShape VAR_11 =
GetOutputShape(VAR_2, VAR_5, VAR_8);
OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(""output"", VAR_11,
&VAR_10));
auto VAR_12 = VAR_10->flat<tstring>();
auto VAR_13 = VAR_4.flat<INDICES_TYPE>();
auto VAR_14 = VAR_1.flat<tstring>();
for (int VAR_9 = 0; VAR_9 < VAR_13.size(); VAR_9++) {
OP_REQUIRES(
VAR_0,
((VAR_13(VAR_9) < VAR_8) && (VAR_13(VAR_9) >= 0)),
errors::InvalidArgument(
""segment_ids are not allowed to exceed num_segments or""
"" to have negative values.""));
}
int64_t VAR_15;
int64_t VAR_16;
std::tie(VAR_15, VAR_16) =
VAR_17<INDICES_TYPE>(VAR_2, VAR_5);
auto VAR_18 =
VAR_19<INDICES_TYPE>(VAR_16, VAR_15);
for (auto VAR_20 = 0; VAR_20 < VAR_15; VAR_20++) {
for (auto VAR_9 = 0; VAR_9 < VAR_18.size(); VAR_9++) {
auto VAR_21 = VAR_20 + VAR_13(VAR_9) * VAR_15;
auto VAR_22 = VAR_20 + VAR_18[VAR_9];
if (VAR_12(VAR_21).length() != 0)
VAR_12(VAR_21).append(VAR_23.c_str());
VAR_12(VAR_21).append(VAR_14(VAR_22));
}
}
}",,"void Compute(OpKernelContext* context) override {
    const Tensor& input = context->input(0);
    const TensorShape& input_shape = input.shape();
    const int32_t input_dims = input_shape.dims();

    const Tensor& segment_id = context->input(1);
    const TensorShape& segment_id_shape = segment_id.shape();
    const int32_t segment_dims = segment_id_shape.dims();

    const Tensor& num_segments_tensor = context->input(2);
    OP_REQUIRES(context, num_segments_tensor.NumElements() != 0,
                errors::InvalidArgument(""Number of segments cannot be empty.""));
    OP_REQUIRES(context,
                TensorShapeUtils::IsScalar(num_segments_tensor.shape()),
                errors::InvalidArgument(""Number of segments must be a scalar""));
    auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();

    OP_REQUIRES(
        context, num_segments >= 0,
        errors::InvalidArgument(
            ""Number of segments must be non-negative but got "", num_segments));
    OP_REQUIRES(context, segment_dims != 0,
                errors::InvalidArgument(""Segment_id cannot have rank 0""));

    OP_REQUIRES(
        context, segment_dims <= input_dims,
        errors::OutOfRange(""Invalid segment_id rank "", segment_dims,
                           "" for input with "", input_dims, "" dimension(s)""));
    for (auto i = 0; i < segment_dims; i++) {
      OP_REQUIRES(
          context, segment_id_shape.dim_size(i) == input_shape.dim_size(i),
          errors::InvalidArgument(
              ""Segment dimension is "", segment_id_shape.dim_size(i),
              "" while input dimension is "", input_dims, "" in rank "", i));
    }

    // Making output tensor.
    Tensor* output_tensor = nullptr;
    TensorShape output_shape =
        GetOutputShape(input_shape, segment_id_shape, num_segments);
    OP_REQUIRES_OK(context, context->allocate_output(""output"", output_shape,
                                                     &output_tensor));

    // Preparating flat tensors.
    auto output_flat = output_tensor->flat<tstring>();
    auto flat_segment_id = segment_id.flat<INDICES_TYPE>();
    auto flat_input = input.flat<tstring>();

    for (int i = 0; i < flat_segment_id.size(); i++) {
      OP_REQUIRES(
          context,
          ((flat_segment_id(i) < num_segments) && (flat_segment_id(i) >= 0)),
          errors::InvalidArgument(
              ""segment_ids are not allowed to exceed num_segments or""
              "" to have negative values.""));
    }

    int64_t big_stride;
    int64_t small_stride;
    std::tie(big_stride, small_stride) =
        GetStrides<INDICES_TYPE>(input_shape, segment_id_shape);
    auto relative_offset_set =
        GetFlattenedRelativeOffsets<INDICES_TYPE>(small_stride, big_stride);
    for (auto start_offset = 0; start_offset < big_stride; start_offset++) {
      for (auto i = 0; i < relative_offset_set.size(); i++) {
        auto output_index = start_offset + flat_segment_id(i) * big_stride;
        auto offset = start_offset + relative_offset_set[i];
        if (output_flat(output_index).length() != 0)
          output_flat(output_index).append(separator_.c_str());
        output_flat(output_index).append(flat_input(offset));
      }
    }
  }","void Compute(OpKernelContext* VAR_0) override {
    const Tensor& VAR_1 = VAR_0->input(0);
    const TensorShape& VAR_2 = VAR_1.shape();
    const int32_t VAR_3 = VAR_2.dims();

    const Tensor& VAR_4 = VAR_0->input(1);
    const TensorShape& VAR_5 = VAR_4.shape();
    const int32_t VAR_6 = VAR_5.dims();

    const Tensor& VAR_7 = VAR_0->input(2);
    OP_REQUIRES(VAR_0, VAR_7.NumElements() != 0,
                errors::InvalidArgument(""Number of segments cannot be empty.""));
    OP_REQUIRES(VAR_0,
                TensorShapeUtils::IsScalar(VAR_7.shape()),
                errors::InvalidArgument(""Number of segments must be a scalar""));
    auto VAR_8 = VAR_7.scalar<NUM_SEGMENTS_TYPE>()();

    OP_REQUIRES(
        VAR_0, VAR_8 >= 0,
        errors::InvalidArgument(
            ""Number of segments must be non-negative but got "", VAR_8));
    OP_REQUIRES(VAR_0, VAR_6 != 0,
                errors::InvalidArgument(""Segment_id cannot have rank 0""));

    OP_REQUIRES(
        VAR_0, VAR_6 <= VAR_3,
        errors::OutOfRange(""Invalid segment_id rank "", VAR_6,
                           "" for input with "", VAR_3, "" dimension(s)""));
    for (auto VAR_9 = 0; VAR_9 < VAR_6; VAR_9++) {
      OP_REQUIRES(
          VAR_0, VAR_5.dim_size(VAR_9) == VAR_2.dim_size(VAR_9),
          errors::InvalidArgument(
              ""Segment dimension is "", VAR_5.dim_size(VAR_9),
              "" while input dimension is "", VAR_3, "" in rank "", VAR_9));
    }

    /* COMMENT_0 */
    Tensor* VAR_10 = nullptr;
    TensorShape VAR_11 =
        GetOutputShape(VAR_2, VAR_5, VAR_8);
    OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(""output"", VAR_11,
                                                     &VAR_10));

    /* COMMENT_1 */
    auto VAR_12 = VAR_10->flat<tstring>();
    auto VAR_13 = VAR_4.flat<INDICES_TYPE>();
    auto VAR_14 = VAR_1.flat<tstring>();

    for (int VAR_9 = 0; VAR_9 < VAR_13.size(); VAR_9++) {
      OP_REQUIRES(
          VAR_0,
          ((VAR_13(VAR_9) < VAR_8) && (VAR_13(VAR_9) >= 0)),
          errors::InvalidArgument(
              ""segment_ids are not allowed to exceed num_segments or""
              "" to have negative values.""));
    }

    int64_t VAR_15;
    int64_t VAR_16;
    std::tie(VAR_15, VAR_16) =
        VAR_17<INDICES_TYPE>(VAR_2, VAR_5);
    auto VAR_18 =
        VAR_19<INDICES_TYPE>(VAR_16, VAR_15);
    for (auto VAR_20 = 0; VAR_20 < VAR_15; VAR_20++) {
      for (auto VAR_9 = 0; VAR_9 < VAR_18.size(); VAR_9++) {
        auto VAR_21 = VAR_20 + VAR_13(VAR_9) * VAR_15;
        auto VAR_22 = VAR_20 + VAR_18[VAR_9];
        if (VAR_12(VAR_21).length() != 0)
          VAR_12(VAR_21).append(VAR_23.c_str());
        VAR_12(VAR_21).append(VAR_14(VAR_22));
      }
    }
  }",,"--- func_before
+++ func_after
@@ -10,6 +10,9 @@
     const Tensor& num_segments_tensor = context->input(2);
     OP_REQUIRES(context, num_segments_tensor.NumElements() != 0,
                 errors::InvalidArgument(""Number of segments cannot be empty.""));
+    OP_REQUIRES(context,
+                TensorShapeUtils::IsScalar(num_segments_tensor.shape()),
+                errors::InvalidArgument(""Number of segments must be a scalar""));
     auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();
 
     OP_REQUIRES(","{'deleted_lines': [], 'added_lines': ['    OP_REQUIRES(context,', '                TensorShapeUtils::IsScalar(num_segments_tensor.shape()),', '                errors::InvalidArgument(""Number of segments must be a scalar""));']}",True,"TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.UnsortedSegmentJoin` does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. The code assumes `num_segments` is a scalar but there is no validation for this before accessing its value. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.",5.5,MEDIUM,1,test,2022-04-28T18:37:31Z,4
CVE-2022-29201,"['CWE-20', 'CWE-476']",AV:L/AC:L/Au:N/C:N/I:N/A:P,0,tensorflow,"Fix undefined behavior in QuantizedConv2D

Added more input validation and tests.  Prior to this, we could get
`nullptr` exceptions when attempting to access 0th elements of 0-sized
inputs, leading to security vulnerability bugs.

Also needed to modify `quantized_conv_ops_test.cc` for consistency.
Previously the CPU kernel did technically support passing tensors
of rank larger than 0 for min/max values.  However, the XLA kernels do not.

PiperOrigin-RevId: 445518507",0f0b080ecde4d3dfec158d6f60da34d5e31693c4,https://github.com/tensorflow/tensorflow/commit/0f0b080ecde4d3dfec158d6f60da34d5e31693c4,tensorflow/core/kernels/quantized_conv_ops.cc,Compute,"void Compute(OpKernelContext* context) override {
const Tensor& input = context->input(0);
const Tensor& filter = context->input(1);
OP_REQUIRES(context, input.dims() == 4,
errors::InvalidArgument(""input must be 4-dimensional"",
input.shape().DebugString()));
OP_REQUIRES(context, filter.dims() == 4,
errors::InvalidArgument(""filter must be 4-dimensional: "",
filter.shape().DebugString()));
const float min_input = context->input(2).flat<float>()(0);
const float max_input = context->input(3).flat<float>()(0);
const float min_filter = context->input(4).flat<float>()(0);
const float max_filter = context->input(5).flat<float>()(0);
const int32_t offset_input =
FloatToQuantizedUnclamped<T1>(0.0f, min_input, max_input);
const int32_t offset_filter =
FloatToQuantizedUnclamped<T2>(0.0f, min_filter, max_filter);
const int32_t offset_output = 0;
const int32_t mult_output = 1;
const int32_t shift_output = 0;
const int64_t in_depth = input.dim_size(3);
OP_REQUIRES(context, in_depth == filter.dim_size(2),
errors::InvalidArgument(
""input and filter must have the same depth: "", in_depth,
"" vs "", filter.dim_size(2)));
const int64_t out_depth = filter.dim_size(3);
const int64_t input_rows = input.dim_size(1);
const int64_t filter_rows = filter.dim_size(0);
const int64_t input_cols = input.dim_size(2);
const int64_t filter_cols = filter.dim_size(1);
const int64_t batch = input.dim_size(0);
const int stride = strides_[1];
int64_t out_rows = 0, out_cols = 0, pad_rows = 0, pad_cols = 0;
OP_REQUIRES_OK(context,
GetWindowedOutputSize(input_rows, filter_rows, stride,
padding_, &out_rows, &pad_rows));
OP_REQUIRES_OK(context,
GetWindowedOutputSize(input_cols, filter_cols, stride,
padding_, &out_cols, &pad_cols));
CHECK_GT(batch, 0);
CHECK_GT(out_rows, 0);
CHECK_GT(out_cols, 0);
CHECK_GT(out_depth, 0);
TensorShape out_shape({batch, out_rows, out_cols, out_depth});
Tensor* output = nullptr;
OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));
ConvFunctor<T1, T2, T3> conv_functor;
conv_functor(context, input.flat<T1>().data(), batch, input_rows,
input_cols, in_depth, offset_input, filter.flat<T2>().data(),
filter_rows, filter_cols, out_depth, offset_filter, stride,
padding_, output->flat<T3>().data(), out_rows, out_cols,
shift_output, offset_output, mult_output);
float min_output_value;
float max_output_value;
QuantizationRangeForMultiplication<T1, T2, T3>(
min_input, max_input, min_filter, max_filter, &min_output_value,
&max_output_value);
Tensor* output_min = nullptr;
OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));
output_min->flat<float>()(0) = min_output_value;
Tensor* output_max = nullptr;
OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));
output_max->flat<float>()(0) = max_output_value;
}","void Compute(OpKernelContext* VAR_0) override {
const Tensor& VAR_1 = VAR_0->input(0);
const Tensor& VAR_2 = VAR_0->input(1);
OP_REQUIRES(VAR_0, VAR_1.dims() == 4,
errors::InvalidArgument(""input must be 4-dimensional"",
VAR_1.shape().DebugString()));
OP_REQUIRES(VAR_0, VAR_2.dims() == 4,
errors::InvalidArgument(""filter must be 4-dimensional: "",
VAR_2.shape().DebugString()));
const float VAR_3 = VAR_0->input(2).flat<float>()(0);
const float VAR_4 = VAR_0->input(3).flat<float>()(0);
const float VAR_5 = VAR_0->input(4).flat<float>()(0);
const float VAR_6 = VAR_0->input(5).flat<float>()(0);
const int32_t VAR_7 =
VAR_8<T1>(0.0f, VAR_3, VAR_4);
const int32_t VAR_9 =
VAR_8<T2>(0.0f, VAR_5, VAR_6);
const int32_t VAR_10 = 0;
const int32_t VAR_11 = 1;
const int32_t VAR_12 = 0;
const int64_t VAR_13 = VAR_1.dim_size(3);
OP_REQUIRES(VAR_0, VAR_13 == VAR_2.dim_size(2),
errors::InvalidArgument(
""input and filter must have the same depth: "", VAR_13,
"" vs "", VAR_2.dim_size(2)));
const int64_t VAR_14 = VAR_2.dim_size(3);
const int64_t VAR_15 = VAR_1.dim_size(1);
const int64_t VAR_16 = VAR_2.dim_size(0);
const int64_t VAR_17 = VAR_1.dim_size(2);
const int64_t VAR_18 = VAR_2.dim_size(1);
const int64_t VAR_19 = VAR_1.dim_size(0);
const int VAR_20 = VAR_21[1];
int64_t VAR_22 = 0, VAR_23 = 0, VAR_24 = 0, VAR_25 = 0;
OP_REQUIRES_OK(VAR_0,
GetWindowedOutputSize(VAR_15, VAR_16, VAR_20,
VAR_26, &VAR_22, &VAR_24));
OP_REQUIRES_OK(VAR_0,
GetWindowedOutputSize(VAR_17, VAR_18, VAR_20,
VAR_26, &VAR_23, &VAR_25));
CHECK_GT(VAR_19, 0);
CHECK_GT(VAR_22, 0);
CHECK_GT(VAR_23, 0);
CHECK_GT(VAR_14, 0);
TensorShape VAR_27({VAR_19, VAR_22, VAR_23, VAR_14});
Tensor* VAR_28 = nullptr;
OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(0, VAR_27, &VAR_28));
ConvFunctor<T1, T2, T3> VAR_29;
VAR_29(VAR_0, VAR_1.flat<T1>().data(), VAR_19, VAR_15,
VAR_17, VAR_13, VAR_7, VAR_2.flat<T2>().data(),
VAR_16, VAR_18, VAR_14, VAR_9, VAR_20,
VAR_26, VAR_28->flat<T3>().data(), VAR_22, VAR_23,
VAR_12, VAR_10, VAR_11);
float VAR_30;
float VAR_31;
VAR_32<T1, T2, T3>(
VAR_3, VAR_4, VAR_5, VAR_6, &VAR_30,
&VAR_31);
Tensor* VAR_33 = nullptr;
OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(1, {}, &VAR_33));
VAR_33->flat<float>()(0) = VAR_30;
Tensor* VAR_34 = nullptr;
OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(2, {}, &VAR_34));
VAR_34->flat<float>()(0) = VAR_31;
}",,"void Compute(OpKernelContext* context) override {
    // Input tensor is of the following dimensions:
    // [ batch, in_rows, in_cols, in_depth ]
    const Tensor& input = context->input(0);

    // Input filter is of the following dimensions:
    // [ filter_rows, filter_cols, in_depth, out_depth]
    const Tensor& filter = context->input(1);

    // For 2D convolution, there should be 4 dimensions.
    OP_REQUIRES(context, input.dims() == 4,
                errors::InvalidArgument(""input must be rank 4 but is rank "",
                                        input.shape().dims()));
    OP_REQUIRES(context, filter.dims() == 4,
                errors::InvalidArgument(""filter must be rank 4 but is rank "",
                                        filter.shape().dims()));

    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(2).shape()),
                errors::InvalidArgument(""min_input must be rank 0 but is rank "",
                                        context->input(2).shape().dims()));
    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(3).shape()),
                errors::InvalidArgument(""max_input must be rank 0 but is rank "",
                                        context->input(3).shape().dims()));
    OP_REQUIRES(
        context, TensorShapeUtils::IsScalar(context->input(4).shape()),
        errors::InvalidArgument(""min_filter must be rank 0 but is rank "",
                                context->input(4).shape().dims()));
    OP_REQUIRES(
        context, TensorShapeUtils::IsScalar(context->input(5).shape()),
        errors::InvalidArgument(""max_filter must be rank 0 but is rank "",
                                context->input(5).shape().dims()));

    const float min_input = context->input(2).flat<float>()(0);
    const float max_input = context->input(3).flat<float>()(0);
    const float min_filter = context->input(4).flat<float>()(0);
    const float max_filter = context->input(5).flat<float>()(0);
    const int32_t offset_input =
        FloatToQuantizedUnclamped<T1>(0.0f, min_input, max_input);
    const int32_t offset_filter =
        FloatToQuantizedUnclamped<T2>(0.0f, min_filter, max_filter);
    const int32_t offset_output = 0;
    const int32_t mult_output = 1;
    const int32_t shift_output = 0;

    // The last dimension for input is in_depth. It must be the same as the
    // filter's in_depth.
    const int64_t in_depth = input.dim_size(3);
    OP_REQUIRES(context, in_depth == filter.dim_size(2),
                errors::InvalidArgument(
                    ""input and filter must have the same depth: "", in_depth,
                    "" vs "", filter.dim_size(2)));

    // The last dimension for filter is out_depth.
    const int64_t out_depth = filter.dim_size(3);

    // The second dimension for input is rows/height.
    // The first dimension for filter is rows/height.
    const int64_t input_rows = input.dim_size(1);
    const int64_t filter_rows = filter.dim_size(0);

    // The third dimension for input is columns/width.
    // The second dimension for filter is columns/width.
    const int64_t input_cols = input.dim_size(2);
    const int64_t filter_cols = filter.dim_size(1);

    // The first dimension for input is batch.
    const int64_t batch = input.dim_size(0);

    // For now we take the stride from the second dimension only (we
    // assume row = col stride, and do not support striding on the
    // batch or depth dimension).
    const int stride = strides_[1];

    int64_t out_rows = 0, out_cols = 0, pad_rows = 0, pad_cols = 0;
    OP_REQUIRES_OK(context,
                   GetWindowedOutputSize(input_rows, filter_rows, stride,
                                         padding_, &out_rows, &pad_rows));
    OP_REQUIRES_OK(context,
                   GetWindowedOutputSize(input_cols, filter_cols, stride,
                                         padding_, &out_cols, &pad_cols));
    CHECK_GT(batch, 0);
    CHECK_GT(out_rows, 0);
    CHECK_GT(out_cols, 0);
    CHECK_GT(out_depth, 0);
    TensorShape out_shape({batch, out_rows, out_cols, out_depth});

    // Output tensor is of the following dimensions:
    // [ in_batch, out_rows, out_cols, out_depth ]
    Tensor* output = nullptr;
    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));

    // This will call different implementations (e.g. reference or optimized)
    // depending on the template parameter.
    ConvFunctor<T1, T2, T3> conv_functor;
    conv_functor(context, input.flat<T1>().data(), batch, input_rows,
                 input_cols, in_depth, offset_input, filter.flat<T2>().data(),
                 filter_rows, filter_cols, out_depth, offset_filter, stride,
                 padding_, output->flat<T3>().data(), out_rows, out_cols,
                 shift_output, offset_output, mult_output);

    float min_output_value;
    float max_output_value;
    QuantizationRangeForMultiplication<T1, T2, T3>(
        min_input, max_input, min_filter, max_filter, &min_output_value,
        &max_output_value);

    Tensor* output_min = nullptr;
    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));
    output_min->flat<float>()(0) = min_output_value;

    Tensor* output_max = nullptr;
    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));
    output_max->flat<float>()(0) = max_output_value;
  }","void Compute(OpKernelContext* VAR_0) override {
    /* COMMENT_0 */
    /* COMMENT_1 */
    const Tensor& VAR_1 = VAR_0->input(0);

    /* COMMENT_2 */
    /* COMMENT_3 */
    const Tensor& VAR_2 = VAR_0->input(1);

    /* COMMENT_4 */
    OP_REQUIRES(VAR_0, VAR_1.dims() == 4,
                errors::InvalidArgument(""input must be rank 4 but is rank "",
                                        VAR_1.shape().dims()));
    OP_REQUIRES(VAR_0, VAR_2.dims() == 4,
                errors::InvalidArgument(""filter must be rank 4 but is rank "",
                                        VAR_2.shape().dims()));

    OP_REQUIRES(VAR_0, TensorShapeUtils::IsScalar(VAR_0->input(2).shape()),
                errors::InvalidArgument(""min_input must be rank 0 but is rank "",
                                        VAR_0->input(2).shape().dims()));
    OP_REQUIRES(VAR_0, TensorShapeUtils::IsScalar(VAR_0->input(3).shape()),
                errors::InvalidArgument(""max_input must be rank 0 but is rank "",
                                        VAR_0->input(3).shape().dims()));
    OP_REQUIRES(
        VAR_0, TensorShapeUtils::IsScalar(VAR_0->input(4).shape()),
        errors::InvalidArgument(""min_filter must be rank 0 but is rank "",
                                VAR_0->input(4).shape().dims()));
    OP_REQUIRES(
        VAR_0, TensorShapeUtils::IsScalar(VAR_0->input(5).shape()),
        errors::InvalidArgument(""max_filter must be rank 0 but is rank "",
                                VAR_0->input(5).shape().dims()));

    const float VAR_3 = VAR_0->input(2).flat<float>()(0);
    const float VAR_4 = VAR_0->input(3).flat<float>()(0);
    const float VAR_5 = VAR_0->input(4).flat<float>()(0);
    const float VAR_6 = VAR_0->input(5).flat<float>()(0);
    const int32_t VAR_7 =
        VAR_8<T1>(0.0f, VAR_3, VAR_4);
    const int32_t VAR_9 =
        VAR_8<T2>(0.0f, VAR_5, VAR_6);
    const int32_t VAR_10 = 0;
    const int32_t VAR_11 = 1;
    const int32_t VAR_12 = 0;

    /* COMMENT_5 */
    /* COMMENT_6 */
    const int64_t VAR_13 = VAR_1.dim_size(3);
    OP_REQUIRES(VAR_0, VAR_13 == VAR_2.dim_size(2),
                errors::InvalidArgument(
                    ""input and filter must have the same depth: "", VAR_13,
                    "" vs "", VAR_2.dim_size(2)));

    /* COMMENT_7 */
    const int64_t VAR_14 = VAR_2.dim_size(3);

    /* COMMENT_8 */
    /* COMMENT_9 */
    const int64_t VAR_15 = VAR_1.dim_size(1);
    const int64_t VAR_16 = VAR_2.dim_size(0);

    /* COMMENT_10 */
    /* COMMENT_11 */
    const int64_t VAR_17 = VAR_1.dim_size(2);
    const int64_t VAR_18 = VAR_2.dim_size(1);

    /* COMMENT_12 */
    const int64_t VAR_19 = VAR_1.dim_size(0);

    /* COMMENT_13 */
    /* COMMENT_14 */
    /* COMMENT_15 */
    const int VAR_20 = VAR_21[1];

    int64_t VAR_22 = 0, VAR_23 = 0, VAR_24 = 0, VAR_25 = 0;
    OP_REQUIRES_OK(VAR_0,
                   GetWindowedOutputSize(VAR_15, VAR_16, VAR_20,
                                         VAR_26, &VAR_22, &VAR_24));
    OP_REQUIRES_OK(VAR_0,
                   GetWindowedOutputSize(VAR_17, VAR_18, VAR_20,
                                         VAR_26, &VAR_23, &VAR_25));
    CHECK_GT(VAR_19, 0);
    CHECK_GT(VAR_22, 0);
    CHECK_GT(VAR_23, 0);
    CHECK_GT(VAR_14, 0);
    TensorShape VAR_27({VAR_19, VAR_22, VAR_23, VAR_14});

    /* COMMENT_16 */
    /* COMMENT_17 */
    Tensor* VAR_28 = nullptr;
    OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(0, VAR_27, &VAR_28));

    /* COMMENT_18 */
    /* COMMENT_19 */
    ConvFunctor<T1, T2, T3> VAR_29;
    VAR_29(VAR_0, VAR_1.flat<T1>().data(), VAR_19, VAR_15,
                 VAR_17, VAR_13, VAR_7, VAR_2.flat<T2>().data(),
                 VAR_16, VAR_18, VAR_14, VAR_9, VAR_20,
                 VAR_26, VAR_28->flat<T3>().data(), VAR_22, VAR_23,
                 VAR_12, VAR_10, VAR_11);

    float VAR_30;
    float VAR_31;
    VAR_32<T1, T2, T3>(
        VAR_3, VAR_4, VAR_5, VAR_6, &VAR_30,
        &VAR_31);

    Tensor* VAR_33 = nullptr;
    OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(1, {}, &VAR_33));
    VAR_33->flat<float>()(0) = VAR_30;

    Tensor* VAR_34 = nullptr;
    OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(2, {}, &VAR_34));
    VAR_34->flat<float>()(0) = VAR_31;
  }",,"--- func_before
+++ func_after
@@ -9,11 +9,26 @@
 
     // For 2D convolution, there should be 4 dimensions.
     OP_REQUIRES(context, input.dims() == 4,
-                errors::InvalidArgument(""input must be 4-dimensional"",
-                                        input.shape().DebugString()));
+                errors::InvalidArgument(""input must be rank 4 but is rank "",
+                                        input.shape().dims()));
     OP_REQUIRES(context, filter.dims() == 4,
-                errors::InvalidArgument(""filter must be 4-dimensional: "",
-                                        filter.shape().DebugString()));
+                errors::InvalidArgument(""filter must be rank 4 but is rank "",
+                                        filter.shape().dims()));
+
+    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(2).shape()),
+                errors::InvalidArgument(""min_input must be rank 0 but is rank "",
+                                        context->input(2).shape().dims()));
+    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(3).shape()),
+                errors::InvalidArgument(""max_input must be rank 0 but is rank "",
+                                        context->input(3).shape().dims()));
+    OP_REQUIRES(
+        context, TensorShapeUtils::IsScalar(context->input(4).shape()),
+        errors::InvalidArgument(""min_filter must be rank 0 but is rank "",
+                                context->input(4).shape().dims()));
+    OP_REQUIRES(
+        context, TensorShapeUtils::IsScalar(context->input(5).shape()),
+        errors::InvalidArgument(""max_filter must be rank 0 but is rank "",
+                                context->input(5).shape().dims()));
 
     const float min_input = context->input(2).flat<float>()(0);
     const float max_input = context->input(3).flat<float>()(0);","{'deleted_lines': ['                errors::InvalidArgument(""input must be 4-dimensional"",', '                                        input.shape().DebugString()));', '                errors::InvalidArgument(""filter must be 4-dimensional: "",', '                                        filter.shape().DebugString()));'], 'added_lines': ['                errors::InvalidArgument(""input must be rank 4 but is rank "",', '                                        input.shape().dims()));', '                errors::InvalidArgument(""filter must be rank 4 but is rank "",', '                                        filter.shape().dims()));', '', '    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(2).shape()),', '                errors::InvalidArgument(""min_input must be rank 0 but is rank "",', '                                        context->input(2).shape().dims()));', '    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(3).shape()),', '                errors::InvalidArgument(""max_input must be rank 0 but is rank "",', '                                        context->input(3).shape().dims()));', '    OP_REQUIRES(', '        context, TensorShapeUtils::IsScalar(context->input(4).shape()),', '        errors::InvalidArgument(""min_filter must be rank 0 but is rank "",', '                                context->input(4).shape().dims()));', '    OP_REQUIRES(', '        context, TensorShapeUtils::IsScalar(context->input(5).shape()),', '        errors::InvalidArgument(""max_filter must be rank 0 but is rank "",', '                                context->input(5).shape().dims()));']}",True,"TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.QuantizedConv2D` does not fully validate the input arguments. In this case, references get bound to `nullptr` for each argument that is empty. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.",5.5,MEDIUM,1,test,2022-04-29T22:22:06Z,4
CVE-2022-29017,['CWE-755'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,axiomatic-systems/Bento4,fix #691,33331ce2d35d45d855af7441db6116b4a9e2b70f,https://github.com/axiomatic-systems/Bento4/commit/33331ce2d35d45d855af7441db6116b4a9e2b70f,Source/C++/Apps/Mp42Hls/Mp42Hls.cpp,main,"int
main(int argc, char** argv)
{
if (argc < 2) {
PrintUsageAndExit();
}
Options.input                          = NULL;
Options.verbose                        = false;
Options.hls_version                    = 0;
Options.pmt_pid                        = 0x100;
Options.audio_pid                      = 0x101;
Options.video_pid                      = 0x102;
Options.audio_track_id                 = -1;
Options.video_track_id                 = -1;
Options.audio_format                   = AUDIO_FORMAT_TS;
Options.output_single_file             = false;
Options.show_info                      = false;
Options.index_filename                 = ""stream.m3u8"";
Options.iframe_index_filename          = NULL;
Options.segment_filename_template      = NULL;
Options.segment_url_template           = NULL;
Options.segment_duration               = 6;
Options.segment_duration_threshold     = DefaultSegmentDurationThreshold;
Options.allow_cache                    = NULL;
Options.encryption_key_hex             = NULL;
Options.encryption_mode                = ENCRYPTION_MODE_NONE;
Options.encryption_iv_mode             = ENCRYPTION_IV_MODE_NONE;
Options.encryption_key_uri             = ""key.bin"";
Options.encryption_key_format          = NULL;
Options.encryption_key_format_versions = NULL;
Options.pcr_offset                     = AP4_MPEG2_TS_DEFAULT_PCR_OFFSET;
AP4_SetMemory(Options.encryption_key, 0, sizeof(Options.encryption_key));
AP4_SetMemory(Options.encryption_iv,  0, sizeof(Options.encryption_iv));
AP4_SetMemory(&Stats, 0, sizeof(Stats));
AP4_Result result;
char** args = argv+1;
while (const char* arg = *args++) {
if (!strcmp(arg, ""--verbose"")) {
Options.verbose = true;
} else if (!strcmp(arg, ""--hls-version"")) {
if (*args == NULL) {
fprintf(stderr, ""ERROR: --hls-version requires a number\n"");
return 1;
}
Options.hls_version = (unsigned int)strtoul(*args++, NULL, 10);
if (Options.hls_version ==0) {
fprintf(stderr, ""ERROR: --hls-version requires number > 0\n"");
return 1;
}
} else if (!strcmp(arg, ""--segment-duration"")) {
if (*args == NULL) {
fprintf(stderr, ""ERROR: --segment-duration requires a number\n"");
return 1;
}
Options.segment_duration = (unsigned int)strtoul(*args++, NULL, 10);
} else if (!strcmp(arg, ""--segment-duration-threshold"")) {
if (*args == NULL) {
fprintf(stderr, ""ERROR: --segment-duration-threshold requires a number\n"");
return 1;
}
Options.segment_duration_threshold = (unsigned int)strtoul(*args++, NULL, 10);
} else if (!strcmp(arg, ""--segment-filename-template"")) {
if (*args == NULL) {
fprintf(stderr, ""ERROR: --segment-filename-template requires an argument\n"");
return 1;
}
Options.segment_filename_template = *args++;
} else if (!strcmp(arg, ""--segment-url-template"")) {
if (*args == NULL) {
fprintf(stderr, ""ERROR: --segment-url-template requires an argument\n"");
return 1;
}
Options.segment_url_template = *args++;
} else if (!strcmp(arg, ""--allow-cache"")) {
if (*args == NULL || (strcmp(*args, ""NO"") && strcmp(*args, ""YES""))) {
fprintf(stderr, ""ERROR: --allow-cache requires a YES or NO argument\n"");
return 1;
}
Options.allow_cache = *args++;
} else if (!strcmp(arg, ""--pmt-pid"")) {
if (*args == NULL) {
fprintf(stderr, ""ERROR: --pmt-pid requires a number\n"");
return 1;
}
Options.pmt_pid = (unsigned int)strtoul(*args++, NULL, 10);
} else if (!strcmp(arg, ""--audio-pid"")) {
if (*args == NULL) {
fprintf(stderr, ""ERROR: --audio-pid requires a number\n"");
return 1;
}
Options.audio_pid = (unsigned int)strtoul(*args++, NULL, 10);
} else if (!strcmp(arg, ""--video-pid"")) {
if (*args == NULL) {
fprintf(stderr, ""ERROR: --video-pid requires a number\n"");
return 1;
}
Options.video_pid = (unsigned int)strtoul(*args++, NULL, 10);
} else if (!strcmp(arg, ""--audio-track-id"")) {
if (*args == NULL) {
fprintf(stderr, ""ERROR: --audio-track-id requires a number\n"");
return 1;
}
Options.audio_track_id = (unsigned int)strtoul(*args++, NULL, 10);
} else if (!strcmp(arg, ""--audio-format"")) {
if (*args == NULL) {
fprintf(stderr, ""ERROR: --audio-format requires an argument\n"");
return 1;
}
const char* format = *args++;
if (!strcmp(format, ""ts"")) {
Options.audio_format = AUDIO_FORMAT_TS;
} else if (!strcmp(format, ""packed"")) {
Options.audio_format = AUDIO_FORMAT_PACKED;
} else {
fprintf(stderr, ""ERROR: unknown audio format\n"");
return 1;
}
} else if (!strcmp(arg, ""--video-track-id"")) {
if (*args == NULL) {
fprintf(stderr, ""ERROR: --video-track-id requires a number\n"");
return 1;
}
Options.video_track_id = (unsigned int)strtoul(*args++, NULL, 10);
} else if (!strcmp(arg, ""--pcr-offset"")) {
if (*args == NULL) {
fprintf(stderr, ""ERROR: --pcr-offset requires a number\n"");
return 1;
}
Options.pcr_offset = (unsigned int)strtoul(*args++, NULL, 10);
} else if (!strcmp(arg, ""--output-single-file"")) {
Options.output_single_file = true;
} else if (!strcmp(arg, ""--index-filename"")) {
if (*args == NULL) {
fprintf(stderr, ""ERROR: --index-filename requires a filename\n"");
return 1;
}
Options.index_filename = *args++;
} else if (!strcmp(arg, ""--iframe-index-filename"")) {
if (*args == NULL) {
fprintf(stderr, ""ERROR: --iframe-index-filename requires a filename\n"");
return 1;
}
Options.iframe_index_filename = *args++;
} else if (!strcmp(arg, ""--show-info"")) {
Options.show_info = true;
} else if (!strcmp(arg, ""--encryption-key"")) {
if (*args == NULL) {
fprintf(stderr, ""ERROR: --encryption-key requires an argument\n"");
return 1;
}
Options.encryption_key_hex = *args++;
result = AP4_ParseHex(Options.encryption_key_hex, Options.encryption_key, 16);
if (AP4_FAILED(result)) {
fprintf(stderr, ""ERROR: invalid hex key\n"");
return 1;
}
if (Options.encryption_mode == ENCRYPTION_MODE_NONE) {
Options.encryption_mode = ENCRYPTION_MODE_AES_128;
}
} else if (!strcmp(arg, ""--encryption-mode"")) {
if (*args == NULL) {
fprintf(stderr, ""ERROR: --encryption-mode requires an argument\n"");
return 1;
}
if (strncmp(*args, ""AES-128"", 7) == 0) {
Options.encryption_mode = ENCRYPTION_MODE_AES_128;
} else if (strncmp(*args, ""SAMPLE-AES"", 10) == 0) {
Options.encryption_mode = ENCRYPTION_MODE_SAMPLE_AES;
} else {
fprintf(stderr, ""ERROR: unknown encryption mode\n"");
return 1;
}
++args;
} else if (!strcmp(arg, ""--encryption-iv-mode"")) {
if (*args == NULL) {
fprintf(stderr, ""ERROR: --encryption-iv-mode requires an argument\n"");
return 1;
}
if (strncmp(*args, ""sequence"", 8) == 0) {
Options.encryption_iv_mode = ENCRYPTION_IV_MODE_SEQUENCE;
} else if (strncmp(*args, ""random"", 6) == 0) {
Options.encryption_iv_mode = ENCRYPTION_IV_MODE_RANDOM;
} else if (strncmp(*args, ""fps"", 3) == 0) {
Options.encryption_iv_mode = ENCRYPTION_IV_MODE_FPS;
} else {
fprintf(stderr, ""ERROR: unknown encryption IV mode\n"");
return 1;
}
++args;
} else if (!strcmp(arg, ""--encryption-key-uri"")) {
if (*args == NULL) {
fprintf(stderr, ""ERROR: --encryption-key-uri requires an argument\n"");
return 1;
}
Options.encryption_key_uri = *args++;
} else if (!strcmp(arg, ""--encryption-key-format"")) {
if (*args == NULL) {
fprintf(stderr, ""ERROR: --encryption-key-format requires an argument\n"");
return 1;
}
Options.encryption_key_format = *args++;
} else if (!strcmp(arg, ""--encryption-key-format-versions"")) {
if (*args == NULL) {
fprintf(stderr, ""ERROR: --encryption-key-format-versions requires an argument\n"");
return 1;
}
Options.encryption_key_format_versions = *args++;
} else if (!strcmp(arg, ""--encryption-key-line"")) {
if (*args == NULL) {
fprintf(stderr, ""ERROR: --encryption-key-line requires an argument\n"");
return 1;
}
Options.encryption_key_lines.Append(*args++);
} else if (Options.input == NULL) {
Options.input = arg;
} else {
fprintf(stderr, ""ERROR: unexpected argument: %s\n"", arg);
return 1;
}
}
if (Options.input == NULL) {
fprintf(stderr, ""ERROR: missing input file name\n"");
return 1;
}
if (Options.encryption_mode == ENCRYPTION_MODE_NONE && Options.encryption_key_lines.ItemCount() != 0) {
fprintf(stderr, ""ERROR: --encryption-key-line requires --encryption-key and --encryption-key-mode\n"");
return 1;
}
if (Options.encryption_mode != ENCRYPTION_MODE_NONE && Options.encryption_key_hex == NULL) {
fprintf(stderr, ""ERROR: no encryption key specified\n"");
return 1;
}
if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES && Options.hls_version > 0 && Options.hls_version < 5) {
Options.hls_version = 5;
fprintf(stderr, ""WARNING: forcing version to 5 in order to support SAMPLE-AES encryption\n"");
}
if (Options.iframe_index_filename && Options.hls_version > 0 && Options.hls_version < 4) {
fprintf(stderr, ""WARNING: forcing version to 4 in order to support I-FRAME-ONLY playlists\n"");
Options.hls_version = 4;
}
if (Options.encryption_iv_mode == ENCRYPTION_IV_MODE_NONE && Options.encryption_mode != ENCRYPTION_MODE_NONE) {
if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {
Options.encryption_iv_mode = ENCRYPTION_IV_MODE_RANDOM;
} else {
Options.encryption_iv_mode = ENCRYPTION_IV_MODE_SEQUENCE;
}
}
if ((Options.encryption_key_format || Options.encryption_key_format_versions) && Options.hls_version > 0 && Options.hls_version < 5) {
Options.hls_version = 5;
fprintf(stderr, ""WARNING: forcing version to 5 in order to support KEYFORMAT and/or KEYFORMATVERSIONS\n"");
}
if (Options.output_single_file && Options.hls_version > 0 && Options.hls_version < 4) {
Options.hls_version = 4;
fprintf(stderr, ""WARNING: forcing version to 4 in order to support single file output\n"");
}
if (Options.hls_version == 0) {
if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {
Options.hls_version = 5;
} else if (Options.output_single_file || Options.iframe_index_filename) {
Options.hls_version = 4;
} else {
Options.hls_version = 3;
}
}
if (Options.verbose && Options.show_info) {
fprintf(stderr, ""WARNING: --verbose will be ignored because --show-info is selected\n"");
Options.verbose = false;
}
if (Options.iframe_index_filename == NULL) {
if (Options.hls_version >= 4) {
Options.iframe_index_filename = ""iframes.m3u8"";
}
}
if (Options.audio_format == AUDIO_FORMAT_TS) {
if (Options.segment_filename_template == NULL) {
if (Options.output_single_file) {
Options.segment_filename_template = ""stream.ts"";
} else {
Options.segment_filename_template = ""segment-%d.ts"";
}
}
if (Options.segment_url_template == NULL) {
if (Options.output_single_file) {
Options.segment_url_template = ""stream.ts"";
} else {
Options.segment_url_template = ""segment-%d.ts"";
}
}
}
if (Options.encryption_iv_mode == ENCRYPTION_IV_MODE_FPS) {
if (AP4_StringLength(Options.encryption_key_hex) != 64) {
fprintf(stderr, ""ERROR: 'fps' IV mode requires a 32 byte key value (64 characters in hex)\n"");
return 1;
}
result = AP4_ParseHex(Options.encryption_key_hex+32, Options.encryption_iv, 16);
if (AP4_FAILED(result)) {
fprintf(stderr, ""ERROR: invalid hex IV\n"");
return 1;
}
} else if (Options.encryption_iv_mode == ENCRYPTION_IV_MODE_RANDOM) {
result = AP4_System_GenerateRandomBytes(Options.encryption_iv, sizeof(Options.encryption_iv));
if (AP4_FAILED(result)) {
fprintf(stderr, ""ERROR: failed to get random IV (%d)\n"", result);
return 1;
}
}
AP4_ByteStream* input = NULL;
result = AP4_FileByteStream::Create(Options.input, AP4_FileByteStream::STREAM_MODE_READ, input);
if (AP4_FAILED(result)) {
fprintf(stderr, ""ERROR: cannot open input (%d)\n"", result);
return 1;
}
AP4_File* input_file = new AP4_File(*input, true);
AP4_SampleDescription* sample_description;
AP4_Movie* movie = input_file->GetMovie();
if (movie == NULL) {
fprintf(stderr, ""ERROR: no movie in file\n"");
return 1;
}
AP4_Track* audio_track = NULL;
if (Options.audio_track_id == -1) {
audio_track = movie->GetTrack(AP4_Track::TYPE_AUDIO);
} else if (Options.audio_track_id > 0) {
audio_track = movie->GetTrack((AP4_UI32)Options.audio_track_id);
if (audio_track == NULL) {
fprintf(stderr, ""ERROR: audio track ID %d not found\n"", Options.audio_track_id);
return 1;
}
if (audio_track->GetType() != AP4_Track::TYPE_AUDIO) {
fprintf(stderr, ""ERROR: track ID %d is not an audio track\n"", Options.audio_track_id);
return 1;
}
}
AP4_Track* video_track = NULL;
if (Options.video_track_id == -1) {
video_track = movie->GetTrack(AP4_Track::TYPE_VIDEO);
} else if (Options.video_track_id > 0) {
video_track = movie->GetTrack((AP4_UI32)Options.video_track_id);
if (video_track == NULL) {
fprintf(stderr, ""ERROR: video track ID %d not found\n"", Options.video_track_id);
return 1;
}
if (video_track->GetType() != AP4_Track::TYPE_VIDEO) {
fprintf(stderr, ""ERROR: track ID %d is not a video track\n"", Options.video_track_id);
return 1;
}
}
if (audio_track == NULL && video_track == NULL) {
fprintf(stderr, ""ERROR: no suitable tracks found\n"");
delete input_file;
input->Release();
return 1;
}
if (Options.audio_format == AUDIO_FORMAT_PACKED && video_track != NULL) {
if (audio_track == NULL) {
fprintf(stderr, ""ERROR: packed audio format requires an audio track\n"");
return 1;
}
fprintf(stderr, ""WARNING: ignoring video track because of the packed audio format\n"");
video_track = NULL;
}
if (video_track == NULL) {
Options.segment_duration_threshold = 0;
}
AP4_LinearReader* linear_reader = NULL;
SampleReader*     audio_reader  = NULL;
SampleReader*     video_reader  = NULL;
if (movie->HasFragments()) {
linear_reader = new AP4_LinearReader(*movie, input);
if (audio_track) {
linear_reader->EnableTrack(audio_track->GetId());
audio_reader = new FragmentedSampleReader(*linear_reader, audio_track->GetId());
}
if (video_track) {
linear_reader->EnableTrack(video_track->GetId());
video_reader = new FragmentedSampleReader(*linear_reader, video_track->GetId());
}
} else {
if (audio_track) {
audio_reader = new TrackSampleReader(*audio_track);
}
if (video_track) {
video_reader = new TrackSampleReader(*video_track);
}
}
AP4_Mpeg2TsWriter*               ts_writer = NULL;
AP4_Mpeg2TsWriter::SampleStream* audio_stream = NULL;
AP4_Mpeg2TsWriter::SampleStream* video_stream = NULL;
AP4_UI08                         nalu_length_size = 0;
PackedAudioWriter*               packed_writer = NULL;
if (Options.audio_format == AUDIO_FORMAT_PACKED) {
packed_writer = new PackedAudioWriter();
sample_description = audio_track->GetSampleDescription(0);
if (sample_description == NULL) {
fprintf(stderr, ""ERROR: unable to parse audio sample description\n"");
goto end;
}
if (Options.segment_filename_template == NULL || Options.segment_url_template == NULL) {
const char* default_stream_name    = ""stream.es"";
const char* default_stream_pattern = ""segment-%d.es"";
if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_MP4A) {
AP4_MpegAudioSampleDescription* mpeg_audio_desc = AP4_DYNAMIC_CAST(AP4_MpegAudioSampleDescription, sample_description);
if (mpeg_audio_desc == NULL ||
!(mpeg_audio_desc->GetObjectTypeId() == AP4_OTI_MPEG4_AUDIO          ||
mpeg_audio_desc->GetObjectTypeId() == AP4_OTI_MPEG2_AAC_AUDIO_LC   ||
mpeg_audio_desc->GetObjectTypeId() == AP4_OTI_MPEG2_AAC_AUDIO_MAIN)) {
fprintf(stderr, ""ERROR: only AAC audio is supported\n"");
return 1;
}
default_stream_name    = ""stream.aac"";
default_stream_pattern = ""segment-%d.aac"";
} else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AC_3) {
default_stream_name    = ""stream.ac3"";
default_stream_pattern = ""segment-%d.ac3"";
} else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_EC_3) {
default_stream_name    = ""stream.ec3"";
default_stream_pattern = ""segment-%d.ec3"";
} else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AC_4) {
default_stream_name    = ""stream.ac4"";
default_stream_pattern = ""segment-%d.ac4"";
}
if (Options.segment_filename_template == NULL) {
if (Options.output_single_file) {
Options.segment_filename_template = default_stream_name;
} else {
Options.segment_filename_template = default_stream_pattern;
}
}
if (Options.segment_url_template == NULL) {
if (Options.output_single_file) {
Options.segment_url_template = default_stream_name;
} else {
Options.segment_url_template = default_stream_pattern;
}
}
}
} else {
ts_writer = new AP4_Mpeg2TsWriter(Options.pmt_pid);
if (audio_track) {
sample_description = audio_track->GetSampleDescription(0);
if (sample_description == NULL) {
fprintf(stderr, ""ERROR: unable to parse audio sample description\n"");
goto end;
}
unsigned int stream_type = 0;
unsigned int stream_id   = 0;
if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_MP4A) {
if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {
stream_type = AP4_MPEG2_STREAM_TYPE_SAMPLE_AES_ISO_IEC_13818_7;
} else {
stream_type = AP4_MPEG2_STREAM_TYPE_ISO_IEC_13818_7;
}
stream_id   = AP4_MPEG2_TS_DEFAULT_STREAM_ID_AUDIO;
} else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AC_3) {
if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {
stream_type = AP4_MPEG2_STREAM_TYPE_SAMPLE_AES_ATSC_AC3;
} else {
stream_type = AP4_MPEG2_STREAM_TYPE_ATSC_AC3;
}
stream_id   = AP4_MPEG2_TS_STREAM_ID_PRIVATE_STREAM_1;
} else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_EC_3) {
if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {
stream_type = AP4_MPEG2_STREAM_TYPE_SAMPLE_AES_ATSC_EAC3;
} else {
stream_type = AP4_MPEG2_STREAM_TYPE_ATSC_EAC3;
}
stream_id   = AP4_MPEG2_TS_STREAM_ID_PRIVATE_STREAM_1;
} else {
fprintf(stderr, ""ERROR: audio codec not supported\n"");
return 1;
}
if (stream_type == AP4_MPEG2_STREAM_TYPE_ATSC_EAC3) {
unsigned int number_of_channels = 0;
AP4_String track_language;
AP4_Dec3Atom* dec3 = AP4_DYNAMIC_CAST(AP4_Dec3Atom, sample_description->GetDetails().GetChild(AP4_ATOM_TYPE_DEC3));
AP4_BitWriter bits(8);
bits.Write(0xCC, 8);
bits.Write(0x06, 8);                    bits.Write(0xC0, 8);                    bits.Write(24, 5);                      if (dec3->GetSubStreams()[0].acmod == 0) {
number_of_channels = 1;
} else if (dec3->GetSubStreams()[0].acmod == 1) {
number_of_channels = 0;
} else if (dec3->GetSubStreams()[0].acmod == 2) {
number_of_channels = 2;
} else {
number_of_channels = 4;
}
if (dec3->GetSubStreams()[0].num_dep_sub > 0) {
number_of_channels = 5;
}
bits.Write(number_of_channels, 3);                              bits.Write(4, 3);                                               bits.Write(dec3->GetSubStreams()[0].bsid, 5);                   track_language = audio_track->GetTrackLanguage();
if (track_language.GetLength() == 3) {
bits.Write(track_language.GetChars()[0], 8);
bits.Write(track_language.GetChars()[1], 8);
bits.Write(track_language.GetChars()[2], 8);
} else {
bits.Write(0x75, 8);
bits.Write(0x6E, 8);
bits.Write(0x64, 8);
}
result = ts_writer->SetAudioStream(audio_track->GetMediaTimeScale(),
stream_type,
stream_id,
audio_stream,
Options.audio_pid,
bits.GetData(), 8,
Options.pcr_offset);
} else {
result = ts_writer->SetAudioStream(audio_track->GetMediaTimeScale(),
stream_type,
stream_id,
audio_stream,
Options.audio_pid,
NULL, 0,
Options.pcr_offset);
}
if (AP4_FAILED(result)) {
fprintf(stderr, ""could not create audio stream (%d)\n"", result);
goto end;
}
}
if (video_track) {
sample_description = video_track->GetSampleDescription(0);
if (sample_description == NULL) {
fprintf(stderr, ""ERROR: unable to parse video sample description\n"");
goto end;
}
unsigned int stream_type = 0;
unsigned int stream_id   = AP4_MPEG2_TS_DEFAULT_STREAM_ID_VIDEO;
if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AVC1 ||
sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AVC2 ||
sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AVC3 ||
sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AVC4 ||
sample_description->GetFormat() == AP4_SAMPLE_FORMAT_DVAV ||
sample_description->GetFormat() == AP4_SAMPLE_FORMAT_DVA1) {
if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {
stream_type = AP4_MPEG2_STREAM_TYPE_SAMPLE_AES_AVC;
AP4_AvcSampleDescription* avc_desc = AP4_DYNAMIC_CAST(AP4_AvcSampleDescription, sample_description);
if (avc_desc == NULL) {
fprintf(stderr, ""ERROR: not a proper AVC track\n"");
return 1;
}
nalu_length_size = avc_desc->GetNaluLengthSize();
} else {
stream_type = AP4_MPEG2_STREAM_TYPE_AVC;
}
} else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_HEV1 ||
sample_description->GetFormat() == AP4_SAMPLE_FORMAT_HVC1 ||
sample_description->GetFormat() == AP4_SAMPLE_FORMAT_DVHE ||
sample_description->GetFormat() == AP4_SAMPLE_FORMAT_DVH1) {
stream_type = AP4_MPEG2_STREAM_TYPE_HEVC;
} else {
fprintf(stderr, ""ERROR: video codec not supported\n"");
return 1;
}
if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {
if (stream_type != AP4_MPEG2_STREAM_TYPE_SAMPLE_AES_AVC) {
fprintf(stderr, ""ERROR: AES-SAMPLE encryption can only be used with H.264 video\n"");
return 1;
}
}
result = ts_writer->SetVideoStream(video_track->GetMediaTimeScale(),
stream_type,
stream_id,
video_stream,
Options.video_pid,
NULL, 0,
Options.pcr_offset);
if (AP4_FAILED(result)) {
fprintf(stderr, ""could not create video stream (%d)\n"", result);
goto end;
}
}
}
result = WriteSamples(ts_writer, packed_writer,
audio_track, audio_reader, audio_stream,
video_track, video_reader, video_stream,
Options.segment_duration_threshold,
nalu_length_size);
if (AP4_FAILED(result)) {
fprintf(stderr, ""ERROR: failed to write samples (%d)\n"", result);
}
if (Options.show_info) {
double average_segment_bitrate = 0.0;
if (Stats.segments_total_duration != 0.0) {
average_segment_bitrate = 8.0*(double)Stats.segments_total_size/Stats.segments_total_duration;
}
double average_iframe_bitrate = 0.0;
if (Stats.segments_total_duration != 0.0) {
average_iframe_bitrate = 8.0*(double)Stats.iframes_total_size/Stats.segments_total_duration;
}
double frame_rate = 0.0;
if (video_track && (Stats.segments_total_duration != 0.0)) {
double sample_count = (double)video_track->GetSampleCount();
double media_duration = (double)video_track->GetMediaDuration();
double timescale = (double)video_track->GetMediaTimeScale();
if (media_duration > 0.0) {
frame_rate = sample_count/(media_duration/timescale);
}
}
printf(
""{\n""
);
printf(
""  \""stats\"": {\n""
""    \""duration\"": %f,\n""
""    \""avg_segment_bitrate\"": %f,\n""
""    \""max_segment_bitrate\"": %f,\n""
""    \""avg_iframe_bitrate\"": %f,\n""
""    \""max_iframe_bitrate\"": %f,\n""
""    \""frame_rate\"": %f\n""
""  }"",
(double)movie->GetDurationMs()/1000.0,
average_segment_bitrate,
Stats.max_segment_bitrate,
average_iframe_bitrate,
Stats.max_iframe_bitrate,
frame_rate
);
if (audio_track) {
AP4_String codec;
AP4_SampleDescription* sdesc = audio_track->GetSampleDescription(0);
if (sdesc) {
sdesc->GetCodecString(codec);
}
printf(
"",\n""
""  \""audio\"": {\n""
""    \""codec\"": \""%s\""\n""
""  }"",
codec.GetChars()
);
}
if (video_track) {
AP4_String codec;
AP4_UI16 width = (AP4_UI16)(video_track->GetWidth()/65536.0);
AP4_UI16 height = (AP4_UI16)(video_track->GetHeight()/65536.0);
AP4_SampleDescription* sdesc = video_track->GetSampleDescription(0);
if (sdesc) {
sdesc->GetCodecString(codec);
AP4_VideoSampleDescription* video_desc = AP4_DYNAMIC_CAST(AP4_VideoSampleDescription, sdesc);
if (video_desc) {
width = video_desc->GetWidth();
height = video_desc->GetHeight();
}
}
printf(
"",\n""
""  \""video\"": {\n""
""    \""codec\"": \""%s\"",\n""
""    \""width\"": %d,\n""
""    \""height\"": %d\n""
""  }"",
codec.GetChars(),
width,
height
);
}
printf(
""\n""
""}\n""
);
}
end:
delete ts_writer;
delete packed_writer;
delete input_file;
input->Release();
delete linear_reader;
delete audio_reader;
delete video_reader;
return result == AP4_SUCCESS?0:1;
}","int
main(int VAR_0, char** VAR_1)
{
if (VAR_0 < 2) {
PrintUsageAndExit();
}
VAR_2.input                          = NULL;
VAR_2.verbose                        = false;
VAR_2.hls_version                    = 0;
VAR_2.pmt_pid                        = 0x100;
VAR_2.audio_pid                      = 0x101;
VAR_2.video_pid                      = 0x102;
VAR_2.audio_track_id                 = -1;
VAR_2.video_track_id                 = -1;
VAR_2.audio_format                   = VAR_3;
VAR_2.output_single_file             = false;
VAR_2.show_info                      = false;
VAR_2.index_filename                 = ""stream.m3u8"";
VAR_2.iframe_index_filename          = NULL;
VAR_2.segment_filename_template      = NULL;
VAR_2.segment_url_template           = NULL;
VAR_2.segment_duration               = 6;
VAR_2.segment_duration_threshold     = VAR_4;
VAR_2.allow_cache                    = NULL;
VAR_2.encryption_key_hex             = NULL;
VAR_2.encryption_mode                = VAR_5;
VAR_2.encryption_iv_mode             = VAR_6;
VAR_2.encryption_key_uri             = ""key.bin"";
VAR_2.encryption_key_format          = NULL;
VAR_2.encryption_key_format_versions = NULL;
VAR_2.pcr_offset                     = VAR_7;
AP4_SetMemory(VAR_2.encryption_key, 0, sizeof(VAR_2.encryption_key));
AP4_SetMemory(VAR_2.encryption_iv,  0, sizeof(VAR_2.encryption_iv));
AP4_SetMemory(&VAR_8, 0, sizeof(VAR_8));
AP4_Result VAR_9;
char** VAR_10 = VAR_1+1;
while (const char* VAR_11 = *VAR_10++) {
if (!strcmp(VAR_11, ""--verbose"")) {
VAR_2.verbose = true;
} else if (!strcmp(VAR_11, ""--hls-version"")) {
if (*VAR_10 == NULL) {
fprintf(VAR_12, ""ERROR: --hls-version requires a number\n"");
return 1;
}
VAR_2.hls_version = (unsigned int)strtoul(*VAR_10++, NULL, 10);
if (VAR_2.hls_version ==0) {
fprintf(VAR_12, ""ERROR: --hls-version requires number > 0\n"");
return 1;
}
} else if (!strcmp(VAR_11, ""--segment-duration"")) {
if (*VAR_10 == NULL) {
fprintf(VAR_12, ""ERROR: --segment-duration requires a number\n"");
return 1;
}
VAR_2.segment_duration = (unsigned int)strtoul(*VAR_10++, NULL, 10);
} else if (!strcmp(VAR_11, ""--segment-duration-threshold"")) {
if (*VAR_10 == NULL) {
fprintf(VAR_12, ""ERROR: --segment-duration-threshold requires a number\n"");
return 1;
}
VAR_2.segment_duration_threshold = (unsigned int)strtoul(*VAR_10++, NULL, 10);
} else if (!strcmp(VAR_11, ""--segment-filename-template"")) {
if (*VAR_10 == NULL) {
fprintf(VAR_12, ""ERROR: --segment-filename-template requires an argument\n"");
return 1;
}
VAR_2.segment_filename_template = *VAR_10++;
} else if (!strcmp(VAR_11, ""--segment-url-template"")) {
if (*VAR_10 == NULL) {
fprintf(VAR_12, ""ERROR: --segment-url-template requires an argument\n"");
return 1;
}
VAR_2.segment_url_template = *VAR_10++;
} else if (!strcmp(VAR_11, ""--allow-cache"")) {
if (*VAR_10 == NULL || (strcmp(*VAR_10, ""NO"") && strcmp(*VAR_10, ""YES""))) {
fprintf(VAR_12, ""ERROR: --allow-cache requires a YES or NO argument\n"");
return 1;
}
VAR_2.allow_cache = *VAR_10++;
} else if (!strcmp(VAR_11, ""--pmt-pid"")) {
if (*VAR_10 == NULL) {
fprintf(VAR_12, ""ERROR: --pmt-pid requires a number\n"");
return 1;
}
VAR_2.pmt_pid = (unsigned int)strtoul(*VAR_10++, NULL, 10);
} else if (!strcmp(VAR_11, ""--audio-pid"")) {
if (*VAR_10 == NULL) {
fprintf(VAR_12, ""ERROR: --audio-pid requires a number\n"");
return 1;
}
VAR_2.audio_pid = (unsigned int)strtoul(*VAR_10++, NULL, 10);
} else if (!strcmp(VAR_11, ""--video-pid"")) {
if (*VAR_10 == NULL) {
fprintf(VAR_12, ""ERROR: --video-pid requires a number\n"");
return 1;
}
VAR_2.video_pid = (unsigned int)strtoul(*VAR_10++, NULL, 10);
} else if (!strcmp(VAR_11, ""--audio-track-id"")) {
if (*VAR_10 == NULL) {
fprintf(VAR_12, ""ERROR: --audio-track-id requires a number\n"");
return 1;
}
VAR_2.audio_track_id = (unsigned int)strtoul(*VAR_10++, NULL, 10);
} else if (!strcmp(VAR_11, ""--audio-format"")) {
if (*VAR_10 == NULL) {
fprintf(VAR_12, ""ERROR: --audio-format requires an argument\n"");
return 1;
}
const char* VAR_13 = *VAR_10++;
if (!strcmp(VAR_13, ""ts"")) {
VAR_2.audio_format = VAR_3;
} else if (!strcmp(VAR_13, ""packed"")) {
VAR_2.audio_format = VAR_14;
} else {
fprintf(VAR_12, ""ERROR: unknown audio format\n"");
return 1;
}
} else if (!strcmp(VAR_11, ""--video-track-id"")) {
if (*VAR_10 == NULL) {
fprintf(VAR_12, ""ERROR: --video-track-id requires a number\n"");
return 1;
}
VAR_2.video_track_id = (unsigned int)strtoul(*VAR_10++, NULL, 10);
} else if (!strcmp(VAR_11, ""--pcr-offset"")) {
if (*VAR_10 == NULL) {
fprintf(VAR_12, ""ERROR: --pcr-offset requires a number\n"");
return 1;
}
VAR_2.pcr_offset = (unsigned int)strtoul(*VAR_10++, NULL, 10);
} else if (!strcmp(VAR_11, ""--output-single-file"")) {
VAR_2.output_single_file = true;
} else if (!strcmp(VAR_11, ""--index-filename"")) {
if (*VAR_10 == NULL) {
fprintf(VAR_12, ""ERROR: --index-filename requires a filename\n"");
return 1;
}
VAR_2.index_filename = *VAR_10++;
} else if (!strcmp(VAR_11, ""--iframe-index-filename"")) {
if (*VAR_10 == NULL) {
fprintf(VAR_12, ""ERROR: --iframe-index-filename requires a filename\n"");
return 1;
}
VAR_2.iframe_index_filename = *VAR_10++;
} else if (!strcmp(VAR_11, ""--show-info"")) {
VAR_2.show_info = true;
} else if (!strcmp(VAR_11, ""--encryption-key"")) {
if (*VAR_10 == NULL) {
fprintf(VAR_12, ""ERROR: --encryption-key requires an argument\n"");
return 1;
}
VAR_2.encryption_key_hex = *VAR_10++;
VAR_9 = AP4_ParseHex(VAR_2.encryption_key_hex, VAR_2.encryption_key, 16);
if (AP4_FAILED(VAR_9)) {
fprintf(VAR_12, ""ERROR: invalid hex key\n"");
return 1;
}
if (VAR_2.encryption_mode == VAR_5) {
VAR_2.encryption_mode = VAR_15;
}
} else if (!strcmp(VAR_11, ""--encryption-mode"")) {
if (*VAR_10 == NULL) {
fprintf(VAR_12, ""ERROR: --encryption-mode requires an argument\n"");
return 1;
}
if (strncmp(*VAR_10, ""AES-128"", 7) == 0) {
VAR_2.encryption_mode = VAR_15;
} else if (strncmp(*VAR_10, ""SAMPLE-AES"", 10) == 0) {
VAR_2.encryption_mode = VAR_16;
} else {
fprintf(VAR_12, ""ERROR: unknown encryption mode\n"");
return 1;
}
++VAR_10;
} else if (!strcmp(VAR_11, ""--encryption-iv-mode"")) {
if (*VAR_10 == NULL) {
fprintf(VAR_12, ""ERROR: --encryption-iv-mode requires an argument\n"");
return 1;
}
if (strncmp(*VAR_10, ""sequence"", 8) == 0) {
VAR_2.encryption_iv_mode = VAR_17;
} else if (strncmp(*VAR_10, ""random"", 6) == 0) {
VAR_2.encryption_iv_mode = VAR_18;
} else if (strncmp(*VAR_10, ""fps"", 3) == 0) {
VAR_2.encryption_iv_mode = VAR_19;
} else {
fprintf(VAR_12, ""ERROR: unknown encryption IV mode\n"");
return 1;
}
++VAR_10;
} else if (!strcmp(VAR_11, ""--encryption-key-uri"")) {
if (*VAR_10 == NULL) {
fprintf(VAR_12, ""ERROR: --encryption-key-uri requires an argument\n"");
return 1;
}
VAR_2.encryption_key_uri = *VAR_10++;
} else if (!strcmp(VAR_11, ""--encryption-key-format"")) {
if (*VAR_10 == NULL) {
fprintf(VAR_12, ""ERROR: --encryption-key-format requires an argument\n"");
return 1;
}
VAR_2.encryption_key_format = *VAR_10++;
} else if (!strcmp(VAR_11, ""--encryption-key-format-versions"")) {
if (*VAR_10 == NULL) {
fprintf(VAR_12, ""ERROR: --encryption-key-format-versions requires an argument\n"");
return 1;
}
VAR_2.encryption_key_format_versions = *VAR_10++;
} else if (!strcmp(VAR_11, ""--encryption-key-line"")) {
if (*VAR_10 == NULL) {
fprintf(VAR_12, ""ERROR: --encryption-key-line requires an argument\n"");
return 1;
}
VAR_2.encryption_key_lines.Append(*VAR_10++);
} else if (VAR_2.input == NULL) {
VAR_2.input = VAR_11;
} else {
fprintf(VAR_12, ""ERROR: unexpected argument: %s\n"", VAR_11);
return 1;
}
}
if (VAR_2.input == NULL) {
fprintf(VAR_12, ""ERROR: missing input file name\n"");
return 1;
}
if (VAR_2.encryption_mode == VAR_5 && VAR_2.encryption_key_lines.ItemCount() != 0) {
fprintf(VAR_12, ""ERROR: --encryption-key-line requires --encryption-key and --encryption-key-mode\n"");
return 1;
}
if (VAR_2.encryption_mode != VAR_5 && VAR_2.encryption_key_hex == NULL) {
fprintf(VAR_12, ""ERROR: no encryption key specified\n"");
return 1;
}
if (VAR_2.encryption_mode == VAR_16 && VAR_2.hls_version > 0 && VAR_2.hls_version < 5) {
VAR_2.hls_version = 5;
fprintf(VAR_12, ""WARNING: forcing version to 5 in order to support SAMPLE-AES encryption\n"");
}
if (VAR_2.iframe_index_filename && VAR_2.hls_version > 0 && VAR_2.hls_version < 4) {
fprintf(VAR_12, ""WARNING: forcing version to 4 in order to support I-FRAME-ONLY playlists\n"");
VAR_2.hls_version = 4;
}
if (VAR_2.encryption_iv_mode == VAR_6 && VAR_2.encryption_mode != VAR_5) {
if (VAR_2.encryption_mode == VAR_16) {
VAR_2.encryption_iv_mode = VAR_18;
} else {
VAR_2.encryption_iv_mode = VAR_17;
}
}
if ((VAR_2.encryption_key_format || VAR_2.encryption_key_format_versions) && VAR_2.hls_version > 0 && VAR_2.hls_version < 5) {
VAR_2.hls_version = 5;
fprintf(VAR_12, ""WARNING: forcing version to 5 in order to support KEYFORMAT and/or KEYFORMATVERSIONS\n"");
}
if (VAR_2.output_single_file && VAR_2.hls_version > 0 && VAR_2.hls_version < 4) {
VAR_2.hls_version = 4;
fprintf(VAR_12, ""WARNING: forcing version to 4 in order to support single file output\n"");
}
if (VAR_2.hls_version == 0) {
if (VAR_2.encryption_mode == VAR_16) {
VAR_2.hls_version = 5;
} else if (VAR_2.output_single_file || VAR_2.iframe_index_filename) {
VAR_2.hls_version = 4;
} else {
VAR_2.hls_version = 3;
}
}
if (VAR_2.verbose && VAR_2.show_info) {
fprintf(VAR_12, ""WARNING: --verbose will be ignored because --show-info is selected\n"");
VAR_2.verbose = false;
}
if (VAR_2.iframe_index_filename == NULL) {
if (VAR_2.hls_version >= 4) {
VAR_2.iframe_index_filename = ""iframes.m3u8"";
}
}
if (VAR_2.audio_format == VAR_3) {
if (VAR_2.segment_filename_template == NULL) {
if (VAR_2.output_single_file) {
VAR_2.segment_filename_template = ""stream.ts"";
} else {
VAR_2.segment_filename_template = ""segment-%d.ts"";
}
}
if (VAR_2.segment_url_template == NULL) {
if (VAR_2.output_single_file) {
VAR_2.segment_url_template = ""stream.ts"";
} else {
VAR_2.segment_url_template = ""segment-%d.ts"";
}
}
}
if (VAR_2.encryption_iv_mode == VAR_19) {
if (AP4_StringLength(VAR_2.encryption_key_hex) != 64) {
fprintf(VAR_12, ""ERROR: 'fps' IV mode requires a 32 byte key value (64 characters in hex)\n"");
return 1;
}
VAR_9 = AP4_ParseHex(VAR_2.encryption_key_hex+32, VAR_2.encryption_iv, 16);
if (AP4_FAILED(VAR_9)) {
fprintf(VAR_12, ""ERROR: invalid hex IV\n"");
return 1;
}
} else if (VAR_2.encryption_iv_mode == VAR_18) {
VAR_9 = AP4_System_GenerateRandomBytes(VAR_2.encryption_iv, sizeof(VAR_2.encryption_iv));
if (AP4_FAILED(VAR_9)) {
fprintf(VAR_12, ""ERROR: failed to get random IV (%d)\n"", VAR_9);
return 1;
}
}
AP4_ByteStream* VAR_20 = NULL;
VAR_9 = AP4_FileByteStream::Create(VAR_2.input, AP4_FileByteStream::STREAM_MODE_READ, VAR_20);
if (AP4_FAILED(VAR_9)) {
fprintf(VAR_12, ""ERROR: cannot open input (%d)\n"", VAR_9);
return 1;
}
AP4_File* VAR_21 = new AP4_File(*VAR_20, true);
AP4_SampleDescription* VAR_22;
AP4_Movie* VAR_23 = VAR_21->GetMovie();
if (VAR_23 == NULL) {
fprintf(VAR_12, ""ERROR: no movie in file\n"");
return 1;
}
AP4_Track* VAR_24 = NULL;
if (VAR_2.audio_track_id == -1) {
VAR_24 = VAR_23->GetTrack(AP4_Track::TYPE_AUDIO);
} else if (VAR_2.audio_track_id > 0) {
VAR_24 = VAR_23->GetTrack((AP4_UI32)VAR_2.audio_track_id);
if (VAR_24 == NULL) {
fprintf(VAR_12, ""ERROR: audio track ID %d not found\n"", VAR_2.audio_track_id);
return 1;
}
if (VAR_24->GetType() != AP4_Track::TYPE_AUDIO) {
fprintf(VAR_12, ""ERROR: track ID %d is not an audio track\n"", VAR_2.audio_track_id);
return 1;
}
}
AP4_Track* VAR_25 = NULL;
if (VAR_2.video_track_id == -1) {
VAR_25 = VAR_23->GetTrack(AP4_Track::TYPE_VIDEO);
} else if (VAR_2.video_track_id > 0) {
VAR_25 = VAR_23->GetTrack((AP4_UI32)VAR_2.video_track_id);
if (VAR_25 == NULL) {
fprintf(VAR_12, ""ERROR: video track ID %d not found\n"", VAR_2.video_track_id);
return 1;
}
if (VAR_25->GetType() != AP4_Track::TYPE_VIDEO) {
fprintf(VAR_12, ""ERROR: track ID %d is not a video track\n"", VAR_2.video_track_id);
return 1;
}
}
if (VAR_24 == NULL && VAR_25 == NULL) {
fprintf(VAR_12, ""ERROR: no suitable tracks found\n"");
delete VAR_21;
VAR_20->Release();
return 1;
}
if (VAR_2.audio_format == VAR_14 && VAR_25 != NULL) {
if (VAR_24 == NULL) {
fprintf(VAR_12, ""ERROR: packed audio format requires an audio track\n"");
return 1;
}
fprintf(VAR_12, ""WARNING: ignoring video track because of the packed audio format\n"");
VAR_25 = NULL;
}
if (VAR_25 == NULL) {
VAR_2.segment_duration_threshold = 0;
}
AP4_LinearReader* VAR_26 = NULL;
SampleReader*     VAR_27  = NULL;
SampleReader*     VAR_28  = NULL;
if (VAR_23->HasFragments()) {
VAR_26 = new AP4_LinearReader(*VAR_23, VAR_20);
if (VAR_24) {
VAR_26->EnableTrack(VAR_24->GetId());
VAR_27 = new FragmentedSampleReader(*VAR_26, VAR_24->GetId());
}
if (VAR_25) {
VAR_26->EnableTrack(VAR_25->GetId());
VAR_28 = new FragmentedSampleReader(*VAR_26, VAR_25->GetId());
}
} else {
if (VAR_24) {
VAR_27 = new TrackSampleReader(*VAR_24);
}
if (VAR_25) {
VAR_28 = new TrackSampleReader(*VAR_25);
}
}
AP4_Mpeg2TsWriter*               VAR_29 = NULL;
AP4_Mpeg2TsWriter::SampleStream* VAR_30 = NULL;
AP4_Mpeg2TsWriter::SampleStream* VAR_31 = NULL;
AP4_UI08                         VAR_32 = 0;
PackedAudioWriter*               VAR_33 = NULL;
if (VAR_2.audio_format == VAR_14) {
VAR_33 = new PackedAudioWriter();
VAR_22 = VAR_24->GetSampleDescription(0);
if (VAR_22 == NULL) {
fprintf(VAR_12, ""ERROR: unable to parse audio sample description\n"");
goto end;
}
if (VAR_2.segment_filename_template == NULL || VAR_2.segment_url_template == NULL) {
const char* VAR_34    = ""stream.es"";
const char* VAR_35 = ""segment-%d.es"";
if (VAR_22->GetFormat() == VAR_36) {
AP4_MpegAudioSampleDescription* VAR_37 = AP4_DYNAMIC_CAST(AP4_MpegAudioSampleDescription, VAR_22);
if (VAR_37 == NULL ||
!(VAR_37->GetObjectTypeId() == VAR_38          ||
VAR_37->GetObjectTypeId() == VAR_39   ||
VAR_37->GetObjectTypeId() == VAR_40)) {
fprintf(VAR_12, ""ERROR: only AAC audio is supported\n"");
return 1;
}
VAR_34    = ""stream.aac"";
VAR_35 = ""segment-%d.aac"";
} else if (VAR_22->GetFormat() == VAR_41) {
VAR_34    = ""stream.ac3"";
VAR_35 = ""segment-%d.ac3"";
} else if (VAR_22->GetFormat() == VAR_42) {
VAR_34    = ""stream.ec3"";
VAR_35 = ""segment-%d.ec3"";
} else if (VAR_22->GetFormat() == VAR_43) {
VAR_34    = ""stream.ac4"";
VAR_35 = ""segment-%d.ac4"";
}
if (VAR_2.segment_filename_template == NULL) {
if (VAR_2.output_single_file) {
VAR_2.segment_filename_template = VAR_34;
} else {
VAR_2.segment_filename_template = VAR_35;
}
}
if (VAR_2.segment_url_template == NULL) {
if (VAR_2.output_single_file) {
VAR_2.segment_url_template = VAR_34;
} else {
VAR_2.segment_url_template = VAR_35;
}
}
}
} else {
VAR_29 = new AP4_Mpeg2TsWriter(VAR_2.pmt_pid);
if (VAR_24) {
VAR_22 = VAR_24->GetSampleDescription(0);
if (VAR_22 == NULL) {
fprintf(VAR_12, ""ERROR: unable to parse audio sample description\n"");
goto end;
}
unsigned int VAR_44 = 0;
unsigned int VAR_45   = 0;
if (VAR_22->GetFormat() == VAR_36) {
if (VAR_2.encryption_mode == VAR_16) {
VAR_44 = VAR_46;
} else {
VAR_44 = VAR_47;
}
VAR_45   = VAR_48;
} else if (VAR_22->GetFormat() == VAR_41) {
if (VAR_2.encryption_mode == VAR_16) {
VAR_44 = VAR_49;
} else {
VAR_44 = VAR_50;
}
VAR_45   = VAR_51;
} else if (VAR_22->GetFormat() == VAR_42) {
if (VAR_2.encryption_mode == VAR_16) {
VAR_44 = VAR_52;
} else {
VAR_44 = VAR_53;
}
VAR_45   = VAR_51;
} else {
fprintf(VAR_12, ""ERROR: audio codec not supported\n"");
return 1;
}
if (VAR_44 == VAR_53) {
unsigned int VAR_54 = 0;
AP4_String VAR_55;
AP4_Dec3Atom* VAR_56 = AP4_DYNAMIC_CAST(AP4_Dec3Atom, VAR_22->GetDetails().GetChild(VAR_57));
AP4_BitWriter VAR_58(8);
VAR_58.Write(0xCC, 8);
VAR_58.Write(0x06, 8);    
VAR_58.Write(0xC0, 8);    
VAR_58.Write(24, 5);      
if (VAR_56->GetSubStreams()[0].acmod == 0) {
VAR_54 = 1;
} else if (VAR_56->GetSubStreams()[0].acmod == 1) {
VAR_54 = 0;
} else if (VAR_56->GetSubStreams()[0].acmod == 2) {
VAR_54 = 2;
} else {
VAR_54 = 4;
}
if (VAR_56->GetSubStreams()[0].num_dep_sub > 0) {
VAR_54 = 5;
}
VAR_58.Write(VAR_54, 3);              
VAR_58.Write(4, 3);                               
VAR_58.Write(VAR_56->GetSubStreams()[0].bsid, 5);   
VAR_55 = VAR_24->GetTrackLanguage();
if (VAR_55.GetLength() == 3) {
VAR_58.Write(VAR_55.GetChars()[0], 8);
VAR_58.Write(VAR_55.GetChars()[1], 8);
VAR_58.Write(VAR_55.GetChars()[2], 8);
} else {
VAR_58.Write(0x75, 8);
VAR_58.Write(0x6E, 8);
VAR_58.Write(0x64, 8);
}
VAR_9 = VAR_29->SetAudioStream(VAR_24->GetMediaTimeScale(),
VAR_44,
VAR_45,
VAR_30,
VAR_2.audio_pid,
VAR_58.GetData(), 8,
VAR_2.pcr_offset);
} else {
VAR_9 = VAR_29->SetAudioStream(VAR_24->GetMediaTimeScale(),
VAR_44,
VAR_45,
VAR_30,
VAR_2.audio_pid,
NULL, 0,
VAR_2.pcr_offset);
}
if (AP4_FAILED(VAR_9)) {
fprintf(VAR_12, ""could not create audio stream (%d)\n"", VAR_9);
goto end;
}
}
if (VAR_25) {
VAR_22 = VAR_25->GetSampleDescription(0);
if (VAR_22 == NULL) {
fprintf(VAR_12, ""ERROR: unable to parse video sample description\n"");
goto end;
}
unsigned int VAR_44 = 0;
unsigned int VAR_45   = VAR_59;
if (VAR_22->GetFormat() == VAR_60 ||
VAR_22->GetFormat() == VAR_61 ||
VAR_22->GetFormat() == VAR_62 ||
VAR_22->GetFormat() == VAR_63 ||
VAR_22->GetFormat() == VAR_64 ||
VAR_22->GetFormat() == VAR_65) {
if (VAR_2.encryption_mode == VAR_16) {
VAR_44 = VAR_66;
AP4_AvcSampleDescription* VAR_67 = AP4_DYNAMIC_CAST(AP4_AvcSampleDescription, VAR_22);
if (VAR_67 == NULL) {
fprintf(VAR_12, ""ERROR: not a proper AVC track\n"");
return 1;
}
VAR_32 = VAR_67->GetNaluLengthSize();
} else {
VAR_44 = VAR_68;
}
} else if (VAR_22->GetFormat() == VAR_69 ||
VAR_22->GetFormat() == VAR_70 ||
VAR_22->GetFormat() == VAR_71 ||
VAR_22->GetFormat() == VAR_72) {
VAR_44 = VAR_73;
} else {
fprintf(VAR_12, ""ERROR: video codec not supported\n"");
return 1;
}
if (VAR_2.encryption_mode == VAR_16) {
if (VAR_44 != VAR_66) {
fprintf(VAR_12, ""ERROR: AES-SAMPLE encryption can only be used with H.264 video\n"");
return 1;
}
}
VAR_9 = VAR_29->SetVideoStream(VAR_25->GetMediaTimeScale(),
VAR_44,
VAR_45,
VAR_31,
VAR_2.video_pid,
NULL, 0,
VAR_2.pcr_offset);
if (AP4_FAILED(VAR_9)) {
fprintf(VAR_12, ""could not create video stream (%d)\n"", VAR_9);
goto end;
}
}
}
VAR_9 = WriteSamples(VAR_29, VAR_33,
VAR_24, VAR_27, VAR_30,
VAR_25, VAR_28, VAR_31,
VAR_2.segment_duration_threshold,
VAR_32);
if (AP4_FAILED(VAR_9)) {
fprintf(VAR_12, ""ERROR: failed to write samples (%d)\n"", VAR_9);
}
if (VAR_2.show_info) {
double VAR_74 = 0.0;
if (VAR_8.segments_total_duration != 0.0) {
VAR_74 = 8.0*(double)VAR_8.segments_total_size/VAR_8.segments_total_duration;
}
double VAR_75 = 0.0;
if (VAR_8.segments_total_duration != 0.0) {
VAR_75 = 8.0*(double)VAR_8.iframes_total_size/VAR_8.segments_total_duration;
}
double VAR_76 = 0.0;
if (VAR_25 && (VAR_8.segments_total_duration != 0.0)) {
double VAR_77 = (double)VAR_25->GetSampleCount();
double VAR_78 = (double)VAR_25->GetMediaDuration();
double VAR_79 = (double)VAR_25->GetMediaTimeScale();
if (VAR_78 > 0.0) {
VAR_76 = VAR_77/(VAR_78/VAR_79);
}
}
printf(
""{\n""
);
printf(
""  \""stats\"": {\n""
""    \""duration\"": %f,\n""
""    \""avg_segment_bitrate\"": %f,\n""
""    \""max_segment_bitrate\"": %f,\n""
""    \""avg_iframe_bitrate\"": %f,\n""
""    \""max_iframe_bitrate\"": %f,\n""
""    \""frame_rate\"": %f\n""
""  }"",
(double)VAR_23->GetDurationMs()/1000.0,
VAR_74,
VAR_8.max_segment_bitrate,
VAR_75,
VAR_8.max_iframe_bitrate,
VAR_76
);
if (VAR_24) {
AP4_String VAR_80;
AP4_SampleDescription* VAR_81 = VAR_24->GetSampleDescription(0);
if (VAR_81) {
VAR_81->GetCodecString(VAR_80);
}
printf(
"",\n""
""  \""audio\"": {\n""
""    \""codec\"": \""%s\""\n""
""  }"",
VAR_80.GetChars()
);
}
if (VAR_25) {
AP4_String VAR_80;
AP4_UI16 VAR_82 = (AP4_UI16)(VAR_25->GetWidth()/65536.0);
AP4_UI16 VAR_83 = (AP4_UI16)(VAR_25->GetHeight()/65536.0);
AP4_SampleDescription* VAR_81 = VAR_25->GetSampleDescription(0);
if (VAR_81) {
VAR_81->GetCodecString(VAR_80);
AP4_VideoSampleDescription* VAR_84 = AP4_DYNAMIC_CAST(AP4_VideoSampleDescription, VAR_81);
if (VAR_84) {
VAR_82 = VAR_84->GetWidth();
VAR_83 = VAR_84->GetHeight();
}
}
printf(
"",\n""
""  \""video\"": {\n""
""    \""codec\"": \""%s\"",\n""
""    \""width\"": %d,\n""
""    \""height\"": %d\n""
""  }"",
VAR_80.GetChars(),
VAR_82,
VAR_83
);
}
printf(
""\n""
""}\n""
);
}
end:
delete VAR_29;
delete VAR_33;
delete VAR_21;
VAR_20->Release();
delete VAR_26;
delete VAR_27;
delete VAR_28;
return VAR_9 == VAR_85?0:1;
}",axiomatic-systems/Bento4/33331ce2d35d45d855af7441db6116b4a9e2b70f/Mp42Hls.cpp/vul/before/0.json,"int
main(int argc, char** argv)
{
    if (argc < 2) {
        PrintUsageAndExit();
    }
    
    // default options
    Options.input                          = NULL;
    Options.verbose                        = false;
    Options.hls_version                    = 0;
    Options.pmt_pid                        = 0x100;
    Options.audio_pid                      = 0x101;
    Options.video_pid                      = 0x102;
    Options.audio_track_id                 = -1;
    Options.video_track_id                 = -1;
    Options.audio_format                   = AUDIO_FORMAT_TS;
    Options.output_single_file             = false;
    Options.show_info                      = false;
    Options.index_filename                 = ""stream.m3u8"";
    Options.iframe_index_filename          = NULL;
    Options.segment_filename_template      = NULL;
    Options.segment_url_template           = NULL;
    Options.segment_duration               = 6;
    Options.segment_duration_threshold     = DefaultSegmentDurationThreshold;
    Options.allow_cache                    = NULL;
    Options.encryption_key_hex             = NULL;
    Options.encryption_mode                = ENCRYPTION_MODE_NONE;
    Options.encryption_iv_mode             = ENCRYPTION_IV_MODE_NONE;
    Options.encryption_key_uri             = ""key.bin"";
    Options.encryption_key_format          = NULL;
    Options.encryption_key_format_versions = NULL;
    Options.pcr_offset                     = AP4_MPEG2_TS_DEFAULT_PCR_OFFSET;
    AP4_SetMemory(Options.encryption_key, 0, sizeof(Options.encryption_key));
    AP4_SetMemory(Options.encryption_iv,  0, sizeof(Options.encryption_iv));
    AP4_SetMemory(&Stats, 0, sizeof(Stats));

    // parse command line
    AP4_Result result;
    char** args = argv+1;
    while (const char* arg = *args++) {
        if (!strcmp(arg, ""--verbose"")) {
            Options.verbose = true;
        } else if (!strcmp(arg, ""--hls-version"")) {
            if (*args == NULL) {
                fprintf(stderr, ""ERROR: --hls-version requires a number\n"");
                return 1;
            }
            Options.hls_version = (unsigned int)strtoul(*args++, NULL, 10);
            if (Options.hls_version ==0) {
                fprintf(stderr, ""ERROR: --hls-version requires number > 0\n"");
                return 1;
            }
        } else if (!strcmp(arg, ""--segment-duration"")) {
            if (*args == NULL) {
                fprintf(stderr, ""ERROR: --segment-duration requires a number\n"");
                return 1;
            }
            Options.segment_duration = (unsigned int)strtoul(*args++, NULL, 10);
        } else if (!strcmp(arg, ""--segment-duration-threshold"")) {
            if (*args == NULL) {
                fprintf(stderr, ""ERROR: --segment-duration-threshold requires a number\n"");
                return 1;
            }
            Options.segment_duration_threshold = (unsigned int)strtoul(*args++, NULL, 10);
        } else if (!strcmp(arg, ""--segment-filename-template"")) {
            if (*args == NULL) {
                fprintf(stderr, ""ERROR: --segment-filename-template requires an argument\n"");
                return 1;
            }
            Options.segment_filename_template = *args++;
        } else if (!strcmp(arg, ""--segment-url-template"")) {
            if (*args == NULL) {
                fprintf(stderr, ""ERROR: --segment-url-template requires an argument\n"");
                return 1;
            }
            Options.segment_url_template = *args++;
        } else if (!strcmp(arg, ""--allow-cache"")) {
            if (*args == NULL || (strcmp(*args, ""NO"") && strcmp(*args, ""YES""))) {
                fprintf(stderr, ""ERROR: --allow-cache requires a YES or NO argument\n"");
                return 1;
            }
            Options.allow_cache = *args++;
        } else if (!strcmp(arg, ""--pmt-pid"")) {
            if (*args == NULL) {
                fprintf(stderr, ""ERROR: --pmt-pid requires a number\n"");
                return 1;
            }
            Options.pmt_pid = (unsigned int)strtoul(*args++, NULL, 10);
        } else if (!strcmp(arg, ""--audio-pid"")) {
            if (*args == NULL) {
                fprintf(stderr, ""ERROR: --audio-pid requires a number\n"");
                return 1;
            }
            Options.audio_pid = (unsigned int)strtoul(*args++, NULL, 10);
        } else if (!strcmp(arg, ""--video-pid"")) {
            if (*args == NULL) {
                fprintf(stderr, ""ERROR: --video-pid requires a number\n"");
                return 1;
            }
            Options.video_pid = (unsigned int)strtoul(*args++, NULL, 10);
        } else if (!strcmp(arg, ""--audio-track-id"")) {
            if (*args == NULL) {
                fprintf(stderr, ""ERROR: --audio-track-id requires a number\n"");
                return 1;
            }
            Options.audio_track_id = (unsigned int)strtoul(*args++, NULL, 10);
        } else if (!strcmp(arg, ""--audio-format"")) {
            if (*args == NULL) {
                fprintf(stderr, ""ERROR: --audio-format requires an argument\n"");
                return 1;
            }
            const char* format = *args++;
            if (!strcmp(format, ""ts"")) {
                Options.audio_format = AUDIO_FORMAT_TS;
            } else if (!strcmp(format, ""packed"")) {
                Options.audio_format = AUDIO_FORMAT_PACKED;
            } else {
                fprintf(stderr, ""ERROR: unknown audio format\n"");
                return 1;
            }
        } else if (!strcmp(arg, ""--video-track-id"")) {
            if (*args == NULL) {
                fprintf(stderr, ""ERROR: --video-track-id requires a number\n"");
                return 1;
            }
            Options.video_track_id = (unsigned int)strtoul(*args++, NULL, 10);
        } else if (!strcmp(arg, ""--pcr-offset"")) {
            if (*args == NULL) {
                fprintf(stderr, ""ERROR: --pcr-offset requires a number\n"");
                return 1;
            }
            Options.pcr_offset = (unsigned int)strtoul(*args++, NULL, 10);
        } else if (!strcmp(arg, ""--output-single-file"")) {
            Options.output_single_file = true;
        } else if (!strcmp(arg, ""--index-filename"")) {
            if (*args == NULL) {
                fprintf(stderr, ""ERROR: --index-filename requires a filename\n"");
                return 1;
            }
            Options.index_filename = *args++;
        } else if (!strcmp(arg, ""--iframe-index-filename"")) {
            if (*args == NULL) {
                fprintf(stderr, ""ERROR: --iframe-index-filename requires a filename\n"");
                return 1;
            }
            Options.iframe_index_filename = *args++;
        } else if (!strcmp(arg, ""--show-info"")) {
            Options.show_info = true;
        } else if (!strcmp(arg, ""--encryption-key"")) {
            if (*args == NULL) {
                fprintf(stderr, ""ERROR: --encryption-key requires an argument\n"");
                return 1;
            }
            Options.encryption_key_hex = *args++;
            result = AP4_ParseHex(Options.encryption_key_hex, Options.encryption_key, 16);
            if (AP4_FAILED(result)) {
                fprintf(stderr, ""ERROR: invalid hex key\n"");
                return 1;
            }
            if (Options.encryption_mode == ENCRYPTION_MODE_NONE) {
                Options.encryption_mode = ENCRYPTION_MODE_AES_128;
            }
        } else if (!strcmp(arg, ""--encryption-mode"")) {
            if (*args == NULL) {
                fprintf(stderr, ""ERROR: --encryption-mode requires an argument\n"");
                return 1;
            }
            if (strncmp(*args, ""AES-128"", 7) == 0) {
                Options.encryption_mode = ENCRYPTION_MODE_AES_128;
            } else if (strncmp(*args, ""SAMPLE-AES"", 10) == 0) {
                Options.encryption_mode = ENCRYPTION_MODE_SAMPLE_AES;
            } else {
                fprintf(stderr, ""ERROR: unknown encryption mode\n"");
                return 1;
            }
            ++args;
        } else if (!strcmp(arg, ""--encryption-iv-mode"")) {
            if (*args == NULL) {
                fprintf(stderr, ""ERROR: --encryption-iv-mode requires an argument\n"");
                return 1;
            }
            if (strncmp(*args, ""sequence"", 8) == 0) {
                Options.encryption_iv_mode = ENCRYPTION_IV_MODE_SEQUENCE;
            } else if (strncmp(*args, ""random"", 6) == 0) {
                Options.encryption_iv_mode = ENCRYPTION_IV_MODE_RANDOM;
            } else if (strncmp(*args, ""fps"", 3) == 0) {
                Options.encryption_iv_mode = ENCRYPTION_IV_MODE_FPS;
            } else {
                fprintf(stderr, ""ERROR: unknown encryption IV mode\n"");
                return 1;
            }
            ++args;
        } else if (!strcmp(arg, ""--encryption-key-uri"")) {
            if (*args == NULL) {
                fprintf(stderr, ""ERROR: --encryption-key-uri requires an argument\n"");
                return 1;
            }
            Options.encryption_key_uri = *args++;
        } else if (!strcmp(arg, ""--encryption-key-format"")) {
            if (*args == NULL) {
                fprintf(stderr, ""ERROR: --encryption-key-format requires an argument\n"");
                return 1;
            }
            Options.encryption_key_format = *args++;
        } else if (!strcmp(arg, ""--encryption-key-format-versions"")) {
            if (*args == NULL) {
                fprintf(stderr, ""ERROR: --encryption-key-format-versions requires an argument\n"");
                return 1;
            }
            Options.encryption_key_format_versions = *args++;
        } else if (!strcmp(arg, ""--encryption-key-line"")) {
            if (*args == NULL) {
                fprintf(stderr, ""ERROR: --encryption-key-line requires an argument\n"");
                return 1;
            }
            Options.encryption_key_lines.Append(*args++);
        } else if (Options.input == NULL) {
            Options.input = arg;
        } else {
            fprintf(stderr, ""ERROR: unexpected argument: %s\n"", arg);
            return 1;
        }
    }

    // check args
    if (Options.input == NULL) {
        fprintf(stderr, ""ERROR: missing input file name\n"");
        return 1;
    }
    if (Options.encryption_mode == ENCRYPTION_MODE_NONE && Options.encryption_key_lines.ItemCount() != 0) {
        fprintf(stderr, ""ERROR: --encryption-key-line requires --encryption-key and --encryption-key-mode\n"");
        return 1;
    }
    if (Options.encryption_mode != ENCRYPTION_MODE_NONE && Options.encryption_key_hex == NULL) {
        fprintf(stderr, ""ERROR: no encryption key specified\n"");
        return 1;
    }
    if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES && Options.hls_version > 0 && Options.hls_version < 5) {
        Options.hls_version = 5;
        fprintf(stderr, ""WARNING: forcing version to 5 in order to support SAMPLE-AES encryption\n"");
    }
    if (Options.iframe_index_filename && Options.hls_version > 0 && Options.hls_version < 4) {
        fprintf(stderr, ""WARNING: forcing version to 4 in order to support I-FRAME-ONLY playlists\n"");
        Options.hls_version = 4;
    }
    if (Options.encryption_iv_mode == ENCRYPTION_IV_MODE_NONE && Options.encryption_mode != ENCRYPTION_MODE_NONE) {
        if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {
            // sequence-mode IVs don't work well with i-frame only playlists, use random instead
            Options.encryption_iv_mode = ENCRYPTION_IV_MODE_RANDOM;
        } else {
            Options.encryption_iv_mode = ENCRYPTION_IV_MODE_SEQUENCE;
        }
    }
    if ((Options.encryption_key_format || Options.encryption_key_format_versions) && Options.hls_version > 0 && Options.hls_version < 5) {
        Options.hls_version = 5;
        fprintf(stderr, ""WARNING: forcing version to 5 in order to support KEYFORMAT and/or KEYFORMATVERSIONS\n"");
    }
    if (Options.output_single_file && Options.hls_version > 0 && Options.hls_version < 4) {
        Options.hls_version = 4;
        fprintf(stderr, ""WARNING: forcing version to 4 in order to support single file output\n"");
    }
    if (Options.hls_version == 0) {
        // default version is 3 for cleartext or AES-128 encryption, and 5 for SAMPLE-AES
        if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {
            Options.hls_version = 5;
        } else if (Options.output_single_file || Options.iframe_index_filename) {
            Options.hls_version = 4;
        } else {
            Options.hls_version = 3;
        }
    }
    
    if (Options.verbose && Options.show_info) {
        fprintf(stderr, ""WARNING: --verbose will be ignored because --show-info is selected\n"");
        Options.verbose = false;
    }

    // compute some derived values
    if (Options.iframe_index_filename == NULL) {
        if (Options.hls_version >= 4) {
            Options.iframe_index_filename = ""iframes.m3u8"";
        }
    }
    if (Options.audio_format == AUDIO_FORMAT_TS) {
        if (Options.segment_filename_template == NULL) {
            if (Options.output_single_file) {
                Options.segment_filename_template = ""stream.ts"";
            } else {
                Options.segment_filename_template = ""segment-%d.ts"";
            }
        }
        if (Options.segment_url_template == NULL) {
            if (Options.output_single_file) {
                Options.segment_url_template = ""stream.ts"";
            } else {
                Options.segment_url_template = ""segment-%d.ts"";
            }
        }
    }
    
    if (Options.encryption_iv_mode == ENCRYPTION_IV_MODE_FPS) {
        if (Options.encryption_key_hex == NULL || AP4_StringLength(Options.encryption_key_hex) != 64) {
            fprintf(stderr, ""ERROR: 'fps' IV mode requires a 32 byte key value (64 characters in hex)\n"");
            return 1;
        }
        result = AP4_ParseHex(Options.encryption_key_hex+32, Options.encryption_iv, 16);
        if (AP4_FAILED(result)) {
            fprintf(stderr, ""ERROR: invalid hex IV\n"");
            return 1;
        }
    } else if (Options.encryption_iv_mode == ENCRYPTION_IV_MODE_RANDOM) {
        result = AP4_System_GenerateRandomBytes(Options.encryption_iv, sizeof(Options.encryption_iv));
        if (AP4_FAILED(result)) {
            fprintf(stderr, ""ERROR: failed to get random IV (%d)\n"", result);
            return 1;
        }
    }
    
	// create the input stream
    AP4_ByteStream* input = NULL;
    result = AP4_FileByteStream::Create(Options.input, AP4_FileByteStream::STREAM_MODE_READ, input);
    if (AP4_FAILED(result)) {
        fprintf(stderr, ""ERROR: cannot open input (%d)\n"", result);
        return 1;
    }
    
	// open the file
    AP4_File* input_file = new AP4_File(*input, true);

    // get the movie
    AP4_SampleDescription* sample_description;
    AP4_Movie* movie = input_file->GetMovie();
    if (movie == NULL) {
        fprintf(stderr, ""ERROR: no movie in file\n"");
        return 1;
    }

    // get the audio and video tracks
    AP4_Track* audio_track = NULL;
    if (Options.audio_track_id == -1) {
        audio_track = movie->GetTrack(AP4_Track::TYPE_AUDIO);
    } else if (Options.audio_track_id > 0) {
        audio_track = movie->GetTrack((AP4_UI32)Options.audio_track_id);
        if (audio_track == NULL) {
            fprintf(stderr, ""ERROR: audio track ID %d not found\n"", Options.audio_track_id);
            return 1;
        }
        if (audio_track->GetType() != AP4_Track::TYPE_AUDIO) {
            fprintf(stderr, ""ERROR: track ID %d is not an audio track\n"", Options.audio_track_id);
            return 1;
        }
    }
    AP4_Track* video_track = NULL;
    if (Options.video_track_id == -1) {
        video_track = movie->GetTrack(AP4_Track::TYPE_VIDEO);
    } else if (Options.video_track_id > 0) {
        video_track = movie->GetTrack((AP4_UI32)Options.video_track_id);
        if (video_track == NULL) {
            fprintf(stderr, ""ERROR: video track ID %d not found\n"", Options.video_track_id);
            return 1;
        }
        if (video_track->GetType() != AP4_Track::TYPE_VIDEO) {
            fprintf(stderr, ""ERROR: track ID %d is not a video track\n"", Options.video_track_id);
            return 1;
        }
    }
    if (audio_track == NULL && video_track == NULL) {
        fprintf(stderr, ""ERROR: no suitable tracks found\n"");
        delete input_file;
        input->Release();
        return 1;
    }
    if (Options.audio_format == AUDIO_FORMAT_PACKED && video_track != NULL) {
        if (audio_track == NULL) {
            fprintf(stderr, ""ERROR: packed audio format requires an audio track\n"");
            return 1;
        }
        fprintf(stderr, ""WARNING: ignoring video track because of the packed audio format\n"");
        video_track = NULL;
    }
    if (video_track == NULL) {
        Options.segment_duration_threshold = 0;
    }
    
    // create the appropriate readers
    AP4_LinearReader* linear_reader = NULL;
    SampleReader*     audio_reader  = NULL;
    SampleReader*     video_reader  = NULL;
    if (movie->HasFragments()) {
        // create a linear reader to get the samples
        linear_reader = new AP4_LinearReader(*movie, input);
    
        if (audio_track) {
            linear_reader->EnableTrack(audio_track->GetId());
            audio_reader = new FragmentedSampleReader(*linear_reader, audio_track->GetId());
        }
        if (video_track) {
            linear_reader->EnableTrack(video_track->GetId());
            video_reader = new FragmentedSampleReader(*linear_reader, video_track->GetId());
        }
    } else {
        if (audio_track) {
            audio_reader = new TrackSampleReader(*audio_track);
        }
        if (video_track) {
            video_reader = new TrackSampleReader(*video_track);
        }
    }
    
    AP4_Mpeg2TsWriter*               ts_writer = NULL;
    AP4_Mpeg2TsWriter::SampleStream* audio_stream = NULL;
    AP4_Mpeg2TsWriter::SampleStream* video_stream = NULL;
    AP4_UI08                         nalu_length_size = 0;
    PackedAudioWriter*               packed_writer = NULL;
    if (Options.audio_format == AUDIO_FORMAT_PACKED) {
        packed_writer = new PackedAudioWriter();
    
        // figure out the file extensions if needed
        sample_description = audio_track->GetSampleDescription(0);
        if (sample_description == NULL) {
            fprintf(stderr, ""ERROR: unable to parse audio sample description\n"");
            goto end;
        }
        if (Options.segment_filename_template == NULL || Options.segment_url_template == NULL) {
            const char* default_stream_name    = ""stream.es"";
            const char* default_stream_pattern = ""segment-%d.es"";
            if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_MP4A) {
                AP4_MpegAudioSampleDescription* mpeg_audio_desc = AP4_DYNAMIC_CAST(AP4_MpegAudioSampleDescription, sample_description);
                if (mpeg_audio_desc == NULL ||
                    !(mpeg_audio_desc->GetObjectTypeId() == AP4_OTI_MPEG4_AUDIO          ||
                      mpeg_audio_desc->GetObjectTypeId() == AP4_OTI_MPEG2_AAC_AUDIO_LC   ||
                      mpeg_audio_desc->GetObjectTypeId() == AP4_OTI_MPEG2_AAC_AUDIO_MAIN)) {
                    fprintf(stderr, ""ERROR: only AAC audio is supported\n"");
                    return 1;
                }
                default_stream_name    = ""stream.aac"";
                default_stream_pattern = ""segment-%d.aac"";
            } else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AC_3) {
                default_stream_name    = ""stream.ac3"";
                default_stream_pattern = ""segment-%d.ac3"";
            } else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_EC_3) {
                default_stream_name    = ""stream.ec3"";
                default_stream_pattern = ""segment-%d.ec3"";
            } else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AC_4) {
                default_stream_name    = ""stream.ac4"";
                default_stream_pattern = ""segment-%d.ac4"";
            }

            // override the segment names
            if (Options.segment_filename_template == NULL) {
                if (Options.output_single_file) {
                    Options.segment_filename_template = default_stream_name;
                } else {
                    Options.segment_filename_template = default_stream_pattern;
                }
            }
            if (Options.segment_url_template == NULL) {
                if (Options.output_single_file) {
                    Options.segment_url_template = default_stream_name;
                } else {
                    Options.segment_url_template = default_stream_pattern;
                }
            }
        }
    } else {
        // create an MPEG2 TS Writer
        ts_writer = new AP4_Mpeg2TsWriter(Options.pmt_pid);

        // add the audio stream
        if (audio_track) {
            sample_description = audio_track->GetSampleDescription(0);
            if (sample_description == NULL) {
                fprintf(stderr, ""ERROR: unable to parse audio sample description\n"");
                goto end;
            }

            unsigned int stream_type = 0;
            unsigned int stream_id   = 0;
            if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_MP4A) {
                if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {
                    stream_type = AP4_MPEG2_STREAM_TYPE_SAMPLE_AES_ISO_IEC_13818_7;
                } else {
                    stream_type = AP4_MPEG2_STREAM_TYPE_ISO_IEC_13818_7;
                }
                stream_id   = AP4_MPEG2_TS_DEFAULT_STREAM_ID_AUDIO;
            } else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AC_3) {
                if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {
                    stream_type = AP4_MPEG2_STREAM_TYPE_SAMPLE_AES_ATSC_AC3;
                } else {
                    stream_type = AP4_MPEG2_STREAM_TYPE_ATSC_AC3;
                }
                stream_id   = AP4_MPEG2_TS_STREAM_ID_PRIVATE_STREAM_1;
            } else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_EC_3) {
                if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {
                    stream_type = AP4_MPEG2_STREAM_TYPE_SAMPLE_AES_ATSC_EAC3;
                } else {
                    stream_type = AP4_MPEG2_STREAM_TYPE_ATSC_EAC3;
                }
                stream_id   = AP4_MPEG2_TS_STREAM_ID_PRIVATE_STREAM_1;
            } else {
                fprintf(stderr, ""ERROR: audio codec not supported\n"");
                return 1;
            }
            if (stream_type == AP4_MPEG2_STREAM_TYPE_ATSC_EAC3) {
                // E-AC-3 descriptor
                unsigned int number_of_channels = 0;
                AP4_String track_language;
                AP4_Dec3Atom* dec3 = AP4_DYNAMIC_CAST(AP4_Dec3Atom, sample_description->GetDetails().GetChild(AP4_ATOM_TYPE_DEC3));
                AP4_BitWriter bits(8);
                bits.Write(0xCC, 8);
                bits.Write(0x06, 8);    // fixed value
                bits.Write(0xC0, 8);    // reserved, bsid_flag, mainid_flag, asvc_flag, mixinfoexists, substream1_flag, substream2_flag and substream3_flag 
                bits.Write(24, 5);      // reserved, full_service_flag and service_type
                if (dec3->GetSubStreams()[0].acmod == 0) {
                    number_of_channels = 1;
                } else if (dec3->GetSubStreams()[0].acmod == 1) {
                    number_of_channels = 0;
                } else if (dec3->GetSubStreams()[0].acmod == 2) {
                    number_of_channels = 2;
                } else {
                    number_of_channels = 4;
                }
                if (dec3->GetSubStreams()[0].num_dep_sub > 0) {
                    number_of_channels = 5;
                }
                bits.Write(number_of_channels, 3);              // number_of_channels
                bits.Write(4, 3);                               // language_flag, language_flag_2, reserved
                bits.Write(dec3->GetSubStreams()[0].bsid, 5);   // bsid
                track_language = audio_track->GetTrackLanguage();
                if (track_language.GetLength() == 3) {
                    bits.Write(track_language.GetChars()[0], 8);
                    bits.Write(track_language.GetChars()[1], 8);
                    bits.Write(track_language.GetChars()[2], 8);
                } else {
                    bits.Write(0x75, 8);
                    bits.Write(0x6E, 8);
                    bits.Write(0x64, 8);
                }
                 // setup the audio stream
                result = ts_writer->SetAudioStream(audio_track->GetMediaTimeScale(),
                                                   stream_type,
                                                   stream_id,
                                                   audio_stream,
                                                   Options.audio_pid,
                                                   bits.GetData(), 8,
                                                   Options.pcr_offset);
            } else {
            // setup the audio stream
            result = ts_writer->SetAudioStream(audio_track->GetMediaTimeScale(),
                                               stream_type,
                                               stream_id,
                                               audio_stream,
                                               Options.audio_pid,
                                               NULL, 0,
                                               Options.pcr_offset);
            }
            if (AP4_FAILED(result)) {
                fprintf(stderr, ""could not create audio stream (%d)\n"", result);
                goto end;
            }
        }
        
        // add the video stream
        if (video_track) {
            sample_description = video_track->GetSampleDescription(0);
            if (sample_description == NULL) {
                fprintf(stderr, ""ERROR: unable to parse video sample description\n"");
                goto end;
            }
            
            // decide on the stream type
            unsigned int stream_type = 0;
            unsigned int stream_id   = AP4_MPEG2_TS_DEFAULT_STREAM_ID_VIDEO;
            if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AVC1 ||
                sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AVC2 ||
                sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AVC3 ||
                sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AVC4 ||
                sample_description->GetFormat() == AP4_SAMPLE_FORMAT_DVAV ||
                sample_description->GetFormat() == AP4_SAMPLE_FORMAT_DVA1) {
                if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {
                    stream_type = AP4_MPEG2_STREAM_TYPE_SAMPLE_AES_AVC;
                    AP4_AvcSampleDescription* avc_desc = AP4_DYNAMIC_CAST(AP4_AvcSampleDescription, sample_description);
                    if (avc_desc == NULL) {
                        fprintf(stderr, ""ERROR: not a proper AVC track\n"");
                        return 1;
                    }
                    nalu_length_size = avc_desc->GetNaluLengthSize();
                } else {
                    stream_type = AP4_MPEG2_STREAM_TYPE_AVC;
                }
            } else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_HEV1 ||
                       sample_description->GetFormat() == AP4_SAMPLE_FORMAT_HVC1 ||
                       sample_description->GetFormat() == AP4_SAMPLE_FORMAT_DVHE ||
                       sample_description->GetFormat() == AP4_SAMPLE_FORMAT_DVH1) {
                stream_type = AP4_MPEG2_STREAM_TYPE_HEVC;
            } else {
                fprintf(stderr, ""ERROR: video codec not supported\n"");
                return 1;
            }
            if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {
                if (stream_type != AP4_MPEG2_STREAM_TYPE_SAMPLE_AES_AVC) {
                    fprintf(stderr, ""ERROR: AES-SAMPLE encryption can only be used with H.264 video\n"");
                    return 1;
                }
            }
            
            // setup the video stream
            result = ts_writer->SetVideoStream(video_track->GetMediaTimeScale(),
                                               stream_type,
                                               stream_id,
                                               video_stream,
                                               Options.video_pid,
                                               NULL, 0,
                                               Options.pcr_offset);
            if (AP4_FAILED(result)) {
                fprintf(stderr, ""could not create video stream (%d)\n"", result);
                goto end;
            }
        }
    }
    
    result = WriteSamples(ts_writer, packed_writer,
                          audio_track, audio_reader, audio_stream,
                          video_track, video_reader, video_stream,
                          Options.segment_duration_threshold,
                          nalu_length_size);
    if (AP4_FAILED(result)) {
        fprintf(stderr, ""ERROR: failed to write samples (%d)\n"", result);
    }

    if (Options.show_info) {
        double average_segment_bitrate = 0.0;
        if (Stats.segments_total_duration != 0.0) {
            average_segment_bitrate = 8.0*(double)Stats.segments_total_size/Stats.segments_total_duration;
        }
        double average_iframe_bitrate = 0.0;
        if (Stats.segments_total_duration != 0.0) {
            average_iframe_bitrate = 8.0*(double)Stats.iframes_total_size/Stats.segments_total_duration;
        }

        double frame_rate = 0.0;
        if (video_track && (Stats.segments_total_duration != 0.0)) {
            double sample_count = (double)video_track->GetSampleCount();
            double media_duration = (double)video_track->GetMediaDuration();
            double timescale = (double)video_track->GetMediaTimeScale();
            if (media_duration > 0.0) {
                frame_rate = sample_count/(media_duration/timescale);
            }
        }

        printf(
            ""{\n""
        );
        printf(
            ""  \""stats\"": {\n""
            ""    \""duration\"": %f,\n""
            ""    \""avg_segment_bitrate\"": %f,\n""
            ""    \""max_segment_bitrate\"": %f,\n""
            ""    \""avg_iframe_bitrate\"": %f,\n""
            ""    \""max_iframe_bitrate\"": %f,\n""
            ""    \""frame_rate\"": %f\n""
            ""  }"",
            (double)movie->GetDurationMs()/1000.0,
            average_segment_bitrate,
            Stats.max_segment_bitrate,
            average_iframe_bitrate,
            Stats.max_iframe_bitrate,
            frame_rate
        );
        if (audio_track) {
            AP4_String codec;
            AP4_SampleDescription* sdesc = audio_track->GetSampleDescription(0);
            if (sdesc) {
                sdesc->GetCodecString(codec);
            }
            printf(
                "",\n""
                ""  \""audio\"": {\n""
                ""    \""codec\"": \""%s\""\n""
                ""  }"",
                codec.GetChars()
            );
        }
        if (video_track) {
            AP4_String codec;
            AP4_UI16 width = (AP4_UI16)(video_track->GetWidth()/65536.0);
            AP4_UI16 height = (AP4_UI16)(video_track->GetHeight()/65536.0);
            AP4_SampleDescription* sdesc = video_track->GetSampleDescription(0);
            if (sdesc) {
                sdesc->GetCodecString(codec);
                AP4_VideoSampleDescription* video_desc = AP4_DYNAMIC_CAST(AP4_VideoSampleDescription, sdesc);
                if (video_desc) {
                    width = video_desc->GetWidth();
                    height = video_desc->GetHeight();
                }
            }
            printf(
                "",\n""
                ""  \""video\"": {\n""
                ""    \""codec\"": \""%s\"",\n""
                ""    \""width\"": %d,\n""
                ""    \""height\"": %d\n""
                ""  }"",
                codec.GetChars(),
                width,
                height
            );
        }
        printf(
            ""\n""
            ""}\n""
        );
    }
    
end:
    delete ts_writer;
    delete packed_writer;
    delete input_file;
    input->Release();
    delete linear_reader;
    delete audio_reader;
    delete video_reader;
    
    return result == AP4_SUCCESS?0:1;
}","int
main(int VAR_0, char** VAR_1)
{
    if (VAR_0 < 2) {
        PrintUsageAndExit();
    }
    
    /* COMMENT_0 */
    VAR_2.input                          = NULL;
    VAR_2.verbose                        = false;
    VAR_2.hls_version                    = 0;
    VAR_2.pmt_pid                        = 0x100;
    VAR_2.audio_pid                      = 0x101;
    VAR_2.video_pid                      = 0x102;
    VAR_2.audio_track_id                 = -1;
    VAR_2.video_track_id                 = -1;
    VAR_2.audio_format                   = VAR_3;
    VAR_2.output_single_file             = false;
    VAR_2.show_info                      = false;
    VAR_2.index_filename                 = ""stream.m3u8"";
    VAR_2.iframe_index_filename          = NULL;
    VAR_2.segment_filename_template      = NULL;
    VAR_2.segment_url_template           = NULL;
    VAR_2.segment_duration               = 6;
    VAR_2.segment_duration_threshold     = VAR_4;
    VAR_2.allow_cache                    = NULL;
    VAR_2.encryption_key_hex             = NULL;
    VAR_2.encryption_mode                = VAR_5;
    VAR_2.encryption_iv_mode             = VAR_6;
    VAR_2.encryption_key_uri             = ""key.bin"";
    VAR_2.encryption_key_format          = NULL;
    VAR_2.encryption_key_format_versions = NULL;
    VAR_2.pcr_offset                     = VAR_7;
    AP4_SetMemory(VAR_2.encryption_key, 0, sizeof(VAR_2.encryption_key));
    AP4_SetMemory(VAR_2.encryption_iv,  0, sizeof(VAR_2.encryption_iv));
    AP4_SetMemory(&VAR_8, 0, sizeof(VAR_8));

    /* COMMENT_1 */
    AP4_Result VAR_9;
    char** VAR_10 = VAR_1+1;
    while (const char* VAR_11 = *VAR_10++) {
        if (!strcmp(VAR_11, ""--verbose"")) {
            VAR_2.verbose = true;
        } else if (!strcmp(VAR_11, ""--hls-version"")) {
            if (*VAR_10 == NULL) {
                fprintf(VAR_12, ""ERROR: --hls-version requires a number\n"");
                return 1;
            }
            VAR_2.hls_version = (unsigned int)strtoul(*VAR_10++, NULL, 10);
            if (VAR_2.hls_version ==0) {
                fprintf(VAR_12, ""ERROR: --hls-version requires number > 0\n"");
                return 1;
            }
        } else if (!strcmp(VAR_11, ""--segment-duration"")) {
            if (*VAR_10 == NULL) {
                fprintf(VAR_12, ""ERROR: --segment-duration requires a number\n"");
                return 1;
            }
            VAR_2.segment_duration = (unsigned int)strtoul(*VAR_10++, NULL, 10);
        } else if (!strcmp(VAR_11, ""--segment-duration-threshold"")) {
            if (*VAR_10 == NULL) {
                fprintf(VAR_12, ""ERROR: --segment-duration-threshold requires a number\n"");
                return 1;
            }
            VAR_2.segment_duration_threshold = (unsigned int)strtoul(*VAR_10++, NULL, 10);
        } else if (!strcmp(VAR_11, ""--segment-filename-template"")) {
            if (*VAR_10 == NULL) {
                fprintf(VAR_12, ""ERROR: --segment-filename-template requires an argument\n"");
                return 1;
            }
            VAR_2.segment_filename_template = *VAR_10++;
        } else if (!strcmp(VAR_11, ""--segment-url-template"")) {
            if (*VAR_10 == NULL) {
                fprintf(VAR_12, ""ERROR: --segment-url-template requires an argument\n"");
                return 1;
            }
            VAR_2.segment_url_template = *VAR_10++;
        } else if (!strcmp(VAR_11, ""--allow-cache"")) {
            if (*VAR_10 == NULL || (strcmp(*VAR_10, ""NO"") && strcmp(*VAR_10, ""YES""))) {
                fprintf(VAR_12, ""ERROR: --allow-cache requires a YES or NO argument\n"");
                return 1;
            }
            VAR_2.allow_cache = *VAR_10++;
        } else if (!strcmp(VAR_11, ""--pmt-pid"")) {
            if (*VAR_10 == NULL) {
                fprintf(VAR_12, ""ERROR: --pmt-pid requires a number\n"");
                return 1;
            }
            VAR_2.pmt_pid = (unsigned int)strtoul(*VAR_10++, NULL, 10);
        } else if (!strcmp(VAR_11, ""--audio-pid"")) {
            if (*VAR_10 == NULL) {
                fprintf(VAR_12, ""ERROR: --audio-pid requires a number\n"");
                return 1;
            }
            VAR_2.audio_pid = (unsigned int)strtoul(*VAR_10++, NULL, 10);
        } else if (!strcmp(VAR_11, ""--video-pid"")) {
            if (*VAR_10 == NULL) {
                fprintf(VAR_12, ""ERROR: --video-pid requires a number\n"");
                return 1;
            }
            VAR_2.video_pid = (unsigned int)strtoul(*VAR_10++, NULL, 10);
        } else if (!strcmp(VAR_11, ""--audio-track-id"")) {
            if (*VAR_10 == NULL) {
                fprintf(VAR_12, ""ERROR: --audio-track-id requires a number\n"");
                return 1;
            }
            VAR_2.audio_track_id = (unsigned int)strtoul(*VAR_10++, NULL, 10);
        } else if (!strcmp(VAR_11, ""--audio-format"")) {
            if (*VAR_10 == NULL) {
                fprintf(VAR_12, ""ERROR: --audio-format requires an argument\n"");
                return 1;
            }
            const char* VAR_13 = *VAR_10++;
            if (!strcmp(VAR_13, ""ts"")) {
                VAR_2.audio_format = VAR_3;
            } else if (!strcmp(VAR_13, ""packed"")) {
                VAR_2.audio_format = VAR_14;
            } else {
                fprintf(VAR_12, ""ERROR: unknown audio format\n"");
                return 1;
            }
        } else if (!strcmp(VAR_11, ""--video-track-id"")) {
            if (*VAR_10 == NULL) {
                fprintf(VAR_12, ""ERROR: --video-track-id requires a number\n"");
                return 1;
            }
            VAR_2.video_track_id = (unsigned int)strtoul(*VAR_10++, NULL, 10);
        } else if (!strcmp(VAR_11, ""--pcr-offset"")) {
            if (*VAR_10 == NULL) {
                fprintf(VAR_12, ""ERROR: --pcr-offset requires a number\n"");
                return 1;
            }
            VAR_2.pcr_offset = (unsigned int)strtoul(*VAR_10++, NULL, 10);
        } else if (!strcmp(VAR_11, ""--output-single-file"")) {
            VAR_2.output_single_file = true;
        } else if (!strcmp(VAR_11, ""--index-filename"")) {
            if (*VAR_10 == NULL) {
                fprintf(VAR_12, ""ERROR: --index-filename requires a filename\n"");
                return 1;
            }
            VAR_2.index_filename = *VAR_10++;
        } else if (!strcmp(VAR_11, ""--iframe-index-filename"")) {
            if (*VAR_10 == NULL) {
                fprintf(VAR_12, ""ERROR: --iframe-index-filename requires a filename\n"");
                return 1;
            }
            VAR_2.iframe_index_filename = *VAR_10++;
        } else if (!strcmp(VAR_11, ""--show-info"")) {
            VAR_2.show_info = true;
        } else if (!strcmp(VAR_11, ""--encryption-key"")) {
            if (*VAR_10 == NULL) {
                fprintf(VAR_12, ""ERROR: --encryption-key requires an argument\n"");
                return 1;
            }
            VAR_2.encryption_key_hex = *VAR_10++;
            VAR_9 = AP4_ParseHex(VAR_2.encryption_key_hex, VAR_2.encryption_key, 16);
            if (AP4_FAILED(VAR_9)) {
                fprintf(VAR_12, ""ERROR: invalid hex key\n"");
                return 1;
            }
            if (VAR_2.encryption_mode == VAR_5) {
                VAR_2.encryption_mode = VAR_15;
            }
        } else if (!strcmp(VAR_11, ""--encryption-mode"")) {
            if (*VAR_10 == NULL) {
                fprintf(VAR_12, ""ERROR: --encryption-mode requires an argument\n"");
                return 1;
            }
            if (strncmp(*VAR_10, ""AES-128"", 7) == 0) {
                VAR_2.encryption_mode = VAR_15;
            } else if (strncmp(*VAR_10, ""SAMPLE-AES"", 10) == 0) {
                VAR_2.encryption_mode = VAR_16;
            } else {
                fprintf(VAR_12, ""ERROR: unknown encryption mode\n"");
                return 1;
            }
            ++VAR_10;
        } else if (!strcmp(VAR_11, ""--encryption-iv-mode"")) {
            if (*VAR_10 == NULL) {
                fprintf(VAR_12, ""ERROR: --encryption-iv-mode requires an argument\n"");
                return 1;
            }
            if (strncmp(*VAR_10, ""sequence"", 8) == 0) {
                VAR_2.encryption_iv_mode = VAR_17;
            } else if (strncmp(*VAR_10, ""random"", 6) == 0) {
                VAR_2.encryption_iv_mode = VAR_18;
            } else if (strncmp(*VAR_10, ""fps"", 3) == 0) {
                VAR_2.encryption_iv_mode = VAR_19;
            } else {
                fprintf(VAR_12, ""ERROR: unknown encryption IV mode\n"");
                return 1;
            }
            ++VAR_10;
        } else if (!strcmp(VAR_11, ""--encryption-key-uri"")) {
            if (*VAR_10 == NULL) {
                fprintf(VAR_12, ""ERROR: --encryption-key-uri requires an argument\n"");
                return 1;
            }
            VAR_2.encryption_key_uri = *VAR_10++;
        } else if (!strcmp(VAR_11, ""--encryption-key-format"")) {
            if (*VAR_10 == NULL) {
                fprintf(VAR_12, ""ERROR: --encryption-key-format requires an argument\n"");
                return 1;
            }
            VAR_2.encryption_key_format = *VAR_10++;
        } else if (!strcmp(VAR_11, ""--encryption-key-format-versions"")) {
            if (*VAR_10 == NULL) {
                fprintf(VAR_12, ""ERROR: --encryption-key-format-versions requires an argument\n"");
                return 1;
            }
            VAR_2.encryption_key_format_versions = *VAR_10++;
        } else if (!strcmp(VAR_11, ""--encryption-key-line"")) {
            if (*VAR_10 == NULL) {
                fprintf(VAR_12, ""ERROR: --encryption-key-line requires an argument\n"");
                return 1;
            }
            VAR_2.encryption_key_lines.Append(*VAR_10++);
        } else if (VAR_2.input == NULL) {
            VAR_2.input = VAR_11;
        } else {
            fprintf(VAR_12, ""ERROR: unexpected argument: %s\n"", VAR_11);
            return 1;
        }
    }

    /* COMMENT_2 */
    if (VAR_2.input == NULL) {
        fprintf(VAR_12, ""ERROR: missing input file name\n"");
        return 1;
    }
    if (VAR_2.encryption_mode == VAR_5 && VAR_2.encryption_key_lines.ItemCount() != 0) {
        fprintf(VAR_12, ""ERROR: --encryption-key-line requires --encryption-key and --encryption-key-mode\n"");
        return 1;
    }
    if (VAR_2.encryption_mode != VAR_5 && VAR_2.encryption_key_hex == NULL) {
        fprintf(VAR_12, ""ERROR: no encryption key specified\n"");
        return 1;
    }
    if (VAR_2.encryption_mode == VAR_16 && VAR_2.hls_version > 0 && VAR_2.hls_version < 5) {
        VAR_2.hls_version = 5;
        fprintf(VAR_12, ""WARNING: forcing version to 5 in order to support SAMPLE-AES encryption\n"");
    }
    if (VAR_2.iframe_index_filename && VAR_2.hls_version > 0 && VAR_2.hls_version < 4) {
        fprintf(VAR_12, ""WARNING: forcing version to 4 in order to support I-FRAME-ONLY playlists\n"");
        VAR_2.hls_version = 4;
    }
    if (VAR_2.encryption_iv_mode == VAR_6 && VAR_2.encryption_mode != VAR_5) {
        if (VAR_2.encryption_mode == VAR_16) {
            /* COMMENT_3 */
            VAR_2.encryption_iv_mode = VAR_18;
        } else {
            VAR_2.encryption_iv_mode = VAR_17;
        }
    }
    if ((VAR_2.encryption_key_format || VAR_2.encryption_key_format_versions) && VAR_2.hls_version > 0 && VAR_2.hls_version < 5) {
        VAR_2.hls_version = 5;
        fprintf(VAR_12, ""WARNING: forcing version to 5 in order to support KEYFORMAT and/or KEYFORMATVERSIONS\n"");
    }
    if (VAR_2.output_single_file && VAR_2.hls_version > 0 && VAR_2.hls_version < 4) {
        VAR_2.hls_version = 4;
        fprintf(VAR_12, ""WARNING: forcing version to 4 in order to support single file output\n"");
    }
    if (VAR_2.hls_version == 0) {
        /* COMMENT_4 */
        if (VAR_2.encryption_mode == VAR_16) {
            VAR_2.hls_version = 5;
        } else if (VAR_2.output_single_file || VAR_2.iframe_index_filename) {
            VAR_2.hls_version = 4;
        } else {
            VAR_2.hls_version = 3;
        }
    }
    
    if (VAR_2.verbose && VAR_2.show_info) {
        fprintf(VAR_12, ""WARNING: --verbose will be ignored because --show-info is selected\n"");
        VAR_2.verbose = false;
    }

    /* COMMENT_5 */
    if (VAR_2.iframe_index_filename == NULL) {
        if (VAR_2.hls_version >= 4) {
            VAR_2.iframe_index_filename = ""iframes.m3u8"";
        }
    }
    if (VAR_2.audio_format == VAR_3) {
        if (VAR_2.segment_filename_template == NULL) {
            if (VAR_2.output_single_file) {
                VAR_2.segment_filename_template = ""stream.ts"";
            } else {
                VAR_2.segment_filename_template = ""segment-%d.ts"";
            }
        }
        if (VAR_2.segment_url_template == NULL) {
            if (VAR_2.output_single_file) {
                VAR_2.segment_url_template = ""stream.ts"";
            } else {
                VAR_2.segment_url_template = ""segment-%d.ts"";
            }
        }
    }
    
    if (VAR_2.encryption_iv_mode == VAR_19) {
        if (VAR_2.encryption_key_hex == NULL || AP4_StringLength(VAR_2.encryption_key_hex) != 64) {
            fprintf(VAR_12, ""ERROR: 'fps' IV mode requires a 32 byte key value (64 characters in hex)\n"");
            return 1;
        }
        VAR_9 = AP4_ParseHex(VAR_2.encryption_key_hex+32, VAR_2.encryption_iv, 16);
        if (AP4_FAILED(VAR_9)) {
            fprintf(VAR_12, ""ERROR: invalid hex IV\n"");
            return 1;
        }
    } else if (VAR_2.encryption_iv_mode == VAR_18) {
        VAR_9 = AP4_System_GenerateRandomBytes(VAR_2.encryption_iv, sizeof(VAR_2.encryption_iv));
        if (AP4_FAILED(VAR_9)) {
            fprintf(VAR_12, ""ERROR: failed to get random IV (%d)\n"", VAR_9);
            return 1;
        }
    }
    
	/* COMMENT_6 */
    AP4_ByteStream* VAR_20 = NULL;
    VAR_9 = AP4_FileByteStream::Create(VAR_2.input, AP4_FileByteStream::STREAM_MODE_READ, VAR_20);
    if (AP4_FAILED(VAR_9)) {
        fprintf(VAR_12, ""ERROR: cannot open input (%d)\n"", VAR_9);
        return 1;
    }
    
	/* COMMENT_7 */
    AP4_File* VAR_21 = new AP4_File(*VAR_20, true);

    /* COMMENT_8 */
    AP4_SampleDescription* VAR_22;
    AP4_Movie* VAR_23 = VAR_21->GetMovie();
    if (VAR_23 == NULL) {
        fprintf(VAR_12, ""ERROR: no movie in file\n"");
        return 1;
    }

    /* COMMENT_9 */
    AP4_Track* VAR_24 = NULL;
    if (VAR_2.audio_track_id == -1) {
        VAR_24 = VAR_23->GetTrack(AP4_Track::TYPE_AUDIO);
    } else if (VAR_2.audio_track_id > 0) {
        VAR_24 = VAR_23->GetTrack((AP4_UI32)VAR_2.audio_track_id);
        if (VAR_24 == NULL) {
            fprintf(VAR_12, ""ERROR: audio track ID %d not found\n"", VAR_2.audio_track_id);
            return 1;
        }
        if (VAR_24->GetType() != AP4_Track::TYPE_AUDIO) {
            fprintf(VAR_12, ""ERROR: track ID %d is not an audio track\n"", VAR_2.audio_track_id);
            return 1;
        }
    }
    AP4_Track* VAR_25 = NULL;
    if (VAR_2.video_track_id == -1) {
        VAR_25 = VAR_23->GetTrack(AP4_Track::TYPE_VIDEO);
    } else if (VAR_2.video_track_id > 0) {
        VAR_25 = VAR_23->GetTrack((AP4_UI32)VAR_2.video_track_id);
        if (VAR_25 == NULL) {
            fprintf(VAR_12, ""ERROR: video track ID %d not found\n"", VAR_2.video_track_id);
            return 1;
        }
        if (VAR_25->GetType() != AP4_Track::TYPE_VIDEO) {
            fprintf(VAR_12, ""ERROR: track ID %d is not a video track\n"", VAR_2.video_track_id);
            return 1;
        }
    }
    if (VAR_24 == NULL && VAR_25 == NULL) {
        fprintf(VAR_12, ""ERROR: no suitable tracks found\n"");
        delete VAR_21;
        VAR_20->Release();
        return 1;
    }
    if (VAR_2.audio_format == VAR_14 && VAR_25 != NULL) {
        if (VAR_24 == NULL) {
            fprintf(VAR_12, ""ERROR: packed audio format requires an audio track\n"");
            return 1;
        }
        fprintf(VAR_12, ""WARNING: ignoring video track because of the packed audio format\n"");
        VAR_25 = NULL;
    }
    if (VAR_25 == NULL) {
        VAR_2.segment_duration_threshold = 0;
    }
    
    /* COMMENT_10 */
    AP4_LinearReader* VAR_26 = NULL;
    SampleReader*     VAR_27  = NULL;
    SampleReader*     VAR_28  = NULL;
    if (VAR_23->HasFragments()) {
        /* COMMENT_11 */
        VAR_26 = new AP4_LinearReader(*VAR_23, VAR_20);
    
        if (VAR_24) {
            VAR_26->EnableTrack(VAR_24->GetId());
            VAR_27 = new FragmentedSampleReader(*VAR_26, VAR_24->GetId());
        }
        if (VAR_25) {
            VAR_26->EnableTrack(VAR_25->GetId());
            VAR_28 = new FragmentedSampleReader(*VAR_26, VAR_25->GetId());
        }
    } else {
        if (VAR_24) {
            VAR_27 = new TrackSampleReader(*VAR_24);
        }
        if (VAR_25) {
            VAR_28 = new TrackSampleReader(*VAR_25);
        }
    }
    
    AP4_Mpeg2TsWriter*               VAR_29 = NULL;
    AP4_Mpeg2TsWriter::SampleStream* VAR_30 = NULL;
    AP4_Mpeg2TsWriter::SampleStream* VAR_31 = NULL;
    AP4_UI08                         VAR_32 = 0;
    PackedAudioWriter*               VAR_33 = NULL;
    if (VAR_2.audio_format == VAR_14) {
        VAR_33 = new PackedAudioWriter();
    
        /* COMMENT_12 */
        VAR_22 = VAR_24->GetSampleDescription(0);
        if (VAR_22 == NULL) {
            fprintf(VAR_12, ""ERROR: unable to parse audio sample description\n"");
            goto end;
        }
        if (VAR_2.segment_filename_template == NULL || VAR_2.segment_url_template == NULL) {
            const char* VAR_34    = ""stream.es"";
            const char* VAR_35 = ""segment-%d.es"";
            if (VAR_22->GetFormat() == VAR_36) {
                AP4_MpegAudioSampleDescription* VAR_37 = AP4_DYNAMIC_CAST(AP4_MpegAudioSampleDescription, VAR_22);
                if (VAR_37 == NULL ||
                    !(VAR_37->GetObjectTypeId() == VAR_38          ||
                      VAR_37->GetObjectTypeId() == VAR_39   ||
                      VAR_37->GetObjectTypeId() == VAR_40)) {
                    fprintf(VAR_12, ""ERROR: only AAC audio is supported\n"");
                    return 1;
                }
                VAR_34    = ""stream.aac"";
                VAR_35 = ""segment-%d.aac"";
            } else if (VAR_22->GetFormat() == VAR_41) {
                VAR_34    = ""stream.ac3"";
                VAR_35 = ""segment-%d.ac3"";
            } else if (VAR_22->GetFormat() == VAR_42) {
                VAR_34    = ""stream.ec3"";
                VAR_35 = ""segment-%d.ec3"";
            } else if (VAR_22->GetFormat() == VAR_43) {
                VAR_34    = ""stream.ac4"";
                VAR_35 = ""segment-%d.ac4"";
            }

            /* COMMENT_13 */
            if (VAR_2.segment_filename_template == NULL) {
                if (VAR_2.output_single_file) {
                    VAR_2.segment_filename_template = VAR_34;
                } else {
                    VAR_2.segment_filename_template = VAR_35;
                }
            }
            if (VAR_2.segment_url_template == NULL) {
                if (VAR_2.output_single_file) {
                    VAR_2.segment_url_template = VAR_34;
                } else {
                    VAR_2.segment_url_template = VAR_35;
                }
            }
        }
    } else {
        /* COMMENT_14 */
        VAR_29 = new AP4_Mpeg2TsWriter(VAR_2.pmt_pid);

        /* COMMENT_15 */
        if (VAR_24) {
            VAR_22 = VAR_24->GetSampleDescription(0);
            if (VAR_22 == NULL) {
                fprintf(VAR_12, ""ERROR: unable to parse audio sample description\n"");
                goto end;
            }

            unsigned int VAR_44 = 0;
            unsigned int VAR_45   = 0;
            if (VAR_22->GetFormat() == VAR_36) {
                if (VAR_2.encryption_mode == VAR_16) {
                    VAR_44 = VAR_46;
                } else {
                    VAR_44 = VAR_47;
                }
                VAR_45   = VAR_48;
            } else if (VAR_22->GetFormat() == VAR_41) {
                if (VAR_2.encryption_mode == VAR_16) {
                    VAR_44 = VAR_49;
                } else {
                    VAR_44 = VAR_50;
                }
                VAR_45   = VAR_51;
            } else if (VAR_22->GetFormat() == VAR_42) {
                if (VAR_2.encryption_mode == VAR_16) {
                    VAR_44 = VAR_52;
                } else {
                    VAR_44 = VAR_53;
                }
                VAR_45   = VAR_51;
            } else {
                fprintf(VAR_12, ""ERROR: audio codec not supported\n"");
                return 1;
            }
            if (VAR_44 == VAR_53) {
                /* COMMENT_16 */
                unsigned int VAR_54 = 0;
                AP4_String VAR_55;
                AP4_Dec3Atom* VAR_56 = AP4_DYNAMIC_CAST(AP4_Dec3Atom, VAR_22->GetDetails().GetChild(VAR_57));
                AP4_BitWriter VAR_58(8);
                VAR_58.Write(0xCC, 8);
                VAR_58.Write(0x06, 8);    /* COMMENT_17 */
                VAR_58.Write(0xC0, 8);    /* COMMENT_18 */
                VAR_58.Write(24, 5);      /* COMMENT_19 */
                if (VAR_56->GetSubStreams()[0].acmod == 0) {
                    VAR_54 = 1;
                } else if (VAR_56->GetSubStreams()[0].acmod == 1) {
                    VAR_54 = 0;
                } else if (VAR_56->GetSubStreams()[0].acmod == 2) {
                    VAR_54 = 2;
                } else {
                    VAR_54 = 4;
                }
                if (VAR_56->GetSubStreams()[0].num_dep_sub > 0) {
                    VAR_54 = 5;
                }
                VAR_58.Write(VAR_54, 3);              /* COMMENT_20 */
                VAR_58.Write(4, 3);                               /* COMMENT_21 */
                VAR_58.Write(VAR_56->GetSubStreams()[0].bsid, 5);   /* COMMENT_22 */
                VAR_55 = VAR_24->GetTrackLanguage();
                if (VAR_55.GetLength() == 3) {
                    VAR_58.Write(VAR_55.GetChars()[0], 8);
                    VAR_58.Write(VAR_55.GetChars()[1], 8);
                    VAR_58.Write(VAR_55.GetChars()[2], 8);
                } else {
                    VAR_58.Write(0x75, 8);
                    VAR_58.Write(0x6E, 8);
                    VAR_58.Write(0x64, 8);
                }
                 /* COMMENT_23 */
                VAR_9 = VAR_29->SetAudioStream(VAR_24->GetMediaTimeScale(),
                                                   VAR_44,
                                                   VAR_45,
                                                   VAR_30,
                                                   VAR_2.audio_pid,
                                                   VAR_58.GetData(), 8,
                                                   VAR_2.pcr_offset);
            } else {
            /* COMMENT_23 */
            VAR_9 = VAR_29->SetAudioStream(VAR_24->GetMediaTimeScale(),
                                               VAR_44,
                                               VAR_45,
                                               VAR_30,
                                               VAR_2.audio_pid,
                                               NULL, 0,
                                               VAR_2.pcr_offset);
            }
            if (AP4_FAILED(VAR_9)) {
                fprintf(VAR_12, ""could not create audio stream (%d)\n"", VAR_9);
                goto end;
            }
        }
        
        /* COMMENT_24 */
        if (VAR_25) {
            VAR_22 = VAR_25->GetSampleDescription(0);
            if (VAR_22 == NULL) {
                fprintf(VAR_12, ""ERROR: unable to parse video sample description\n"");
                goto end;
            }
            
            /* COMMENT_25 */
            unsigned int VAR_44 = 0;
            unsigned int VAR_45   = VAR_59;
            if (VAR_22->GetFormat() == VAR_60 ||
                VAR_22->GetFormat() == VAR_61 ||
                VAR_22->GetFormat() == VAR_62 ||
                VAR_22->GetFormat() == VAR_63 ||
                VAR_22->GetFormat() == VAR_64 ||
                VAR_22->GetFormat() == VAR_65) {
                if (VAR_2.encryption_mode == VAR_16) {
                    VAR_44 = VAR_66;
                    AP4_AvcSampleDescription* VAR_67 = AP4_DYNAMIC_CAST(AP4_AvcSampleDescription, VAR_22);
                    if (VAR_67 == NULL) {
                        fprintf(VAR_12, ""ERROR: not a proper AVC track\n"");
                        return 1;
                    }
                    VAR_32 = VAR_67->GetNaluLengthSize();
                } else {
                    VAR_44 = VAR_68;
                }
            } else if (VAR_22->GetFormat() == VAR_69 ||
                       VAR_22->GetFormat() == VAR_70 ||
                       VAR_22->GetFormat() == VAR_71 ||
                       VAR_22->GetFormat() == VAR_72) {
                VAR_44 = VAR_73;
            } else {
                fprintf(VAR_12, ""ERROR: video codec not supported\n"");
                return 1;
            }
            if (VAR_2.encryption_mode == VAR_16) {
                if (VAR_44 != VAR_66) {
                    fprintf(VAR_12, ""ERROR: AES-SAMPLE encryption can only be used with H.264 video\n"");
                    return 1;
                }
            }
            
            /* COMMENT_26 */
            VAR_9 = VAR_29->SetVideoStream(VAR_25->GetMediaTimeScale(),
                                               VAR_44,
                                               VAR_45,
                                               VAR_31,
                                               VAR_2.video_pid,
                                               NULL, 0,
                                               VAR_2.pcr_offset);
            if (AP4_FAILED(VAR_9)) {
                fprintf(VAR_12, ""could not create video stream (%d)\n"", VAR_9);
                goto end;
            }
        }
    }
    
    VAR_9 = WriteSamples(VAR_29, VAR_33,
                          VAR_24, VAR_27, VAR_30,
                          VAR_25, VAR_28, VAR_31,
                          VAR_2.segment_duration_threshold,
                          VAR_32);
    if (AP4_FAILED(VAR_9)) {
        fprintf(VAR_12, ""ERROR: failed to write samples (%d)\n"", VAR_9);
    }

    if (VAR_2.show_info) {
        double VAR_74 = 0.0;
        if (VAR_8.segments_total_duration != 0.0) {
            VAR_74 = 8.0*(double)VAR_8.segments_total_size/VAR_8.segments_total_duration;
        }
        double VAR_75 = 0.0;
        if (VAR_8.segments_total_duration != 0.0) {
            VAR_75 = 8.0*(double)VAR_8.iframes_total_size/VAR_8.segments_total_duration;
        }

        double VAR_76 = 0.0;
        if (VAR_25 && (VAR_8.segments_total_duration != 0.0)) {
            double VAR_77 = (double)VAR_25->GetSampleCount();
            double VAR_78 = (double)VAR_25->GetMediaDuration();
            double VAR_79 = (double)VAR_25->GetMediaTimeScale();
            if (VAR_78 > 0.0) {
                VAR_76 = VAR_77/(VAR_78/VAR_79);
            }
        }

        printf(
            ""{\n""
        );
        printf(
            ""  \""stats\"": {\n""
            ""    \""duration\"": %f,\n""
            ""    \""avg_segment_bitrate\"": %f,\n""
            ""    \""max_segment_bitrate\"": %f,\n""
            ""    \""avg_iframe_bitrate\"": %f,\n""
            ""    \""max_iframe_bitrate\"": %f,\n""
            ""    \""frame_rate\"": %f\n""
            ""  }"",
            (double)VAR_23->GetDurationMs()/1000.0,
            VAR_74,
            VAR_8.max_segment_bitrate,
            VAR_75,
            VAR_8.max_iframe_bitrate,
            VAR_76
        );
        if (VAR_24) {
            AP4_String VAR_80;
            AP4_SampleDescription* VAR_81 = VAR_24->GetSampleDescription(0);
            if (VAR_81) {
                VAR_81->GetCodecString(VAR_80);
            }
            printf(
                "",\n""
                ""  \""audio\"": {\n""
                ""    \""codec\"": \""%s\""\n""
                ""  }"",
                VAR_80.GetChars()
            );
        }
        if (VAR_25) {
            AP4_String VAR_80;
            AP4_UI16 VAR_82 = (AP4_UI16)(VAR_25->GetWidth()/65536.0);
            AP4_UI16 VAR_83 = (AP4_UI16)(VAR_25->GetHeight()/65536.0);
            AP4_SampleDescription* VAR_81 = VAR_25->GetSampleDescription(0);
            if (VAR_81) {
                VAR_81->GetCodecString(VAR_80);
                AP4_VideoSampleDescription* VAR_84 = AP4_DYNAMIC_CAST(AP4_VideoSampleDescription, VAR_81);
                if (VAR_84) {
                    VAR_82 = VAR_84->GetWidth();
                    VAR_83 = VAR_84->GetHeight();
                }
            }
            printf(
                "",\n""
                ""  \""video\"": {\n""
                ""    \""codec\"": \""%s\"",\n""
                ""    \""width\"": %d,\n""
                ""    \""height\"": %d\n""
                ""  }"",
                VAR_80.GetChars(),
                VAR_82,
                VAR_83
            );
        }
        printf(
            ""\n""
            ""}\n""
        );
    }
    
end:
    delete VAR_29;
    delete VAR_33;
    delete VAR_21;
    VAR_20->Release();
    delete VAR_26;
    delete VAR_27;
    delete VAR_28;
    
    return VAR_9 == VAR_85?0:1;
}",axiomatic-systems/Bento4/33331ce2d35d45d855af7441db6116b4a9e2b70f/Mp42Hls.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -300,7 +300,7 @@
     }
     
     if (Options.encryption_iv_mode == ENCRYPTION_IV_MODE_FPS) {
-        if (AP4_StringLength(Options.encryption_key_hex) != 64) {
+        if (Options.encryption_key_hex == NULL || AP4_StringLength(Options.encryption_key_hex) != 64) {
             fprintf(stderr, ""ERROR: 'fps' IV mode requires a 32 byte key value (64 characters in hex)\n"");
             return 1;
         }","{'deleted_lines': ['        if (AP4_StringLength(Options.encryption_key_hex) != 64) {'], 'added_lines': ['        if (Options.encryption_key_hex == NULL || AP4_StringLength(Options.encryption_key_hex) != 64) {']}",True,Bento4 v1.6.0.0 was discovered to contain a segmentation fault via the component /x86_64/multiarch/strlen-avx2.S.,5.5,MEDIUM,1,test,2022-05-01T20:56:35Z,4
CVE-2022-2301,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,hpjansson/chafa,"XwdLoader: Fix buffer over-read and improve general robustness

This commit fixes a buffer over-read that could occur due to g_ntohl()
evaluating its argument more than once if at least one of the following
is true:

* Build target is not x86.
* __OPTIMIZE__ is not set during compilation (e.g. -O0 was used).

It also improves robustness more generally and fixes an issue where the
wrong field was being used to calculate the color map size, causing some
image files that were otherwise fine to be rejected.

Reported by @JieyongMa via huntr.dev.",56fabfa18a6880b4cb66047fa6557920078048d9,https://github.com/hpjansson/chafa/commit/56fabfa18a6880b4cb66047fa6557920078048d9,tools/chafa/xwd-loader.c,load_header,"static gboolean
load_header (XwdLoader *loader) {
XwdHeader *h = &loader->header;
XwdHeader in;
const guint32 *p = (const guint32 *) &in;
if (!file_mapping_taste (loader->mapping, &in, 0, sizeof (in)))
return FALSE;
h->header_size = g_ntohl (*(p++));
h->file_version = g_ntohl (*(p++));
h->pixmap_format = g_ntohl (*(p++));
h->pixmap_depth = g_ntohl (*(p++));
h->pixmap_width = g_ntohl (*(p++));
h->pixmap_height = g_ntohl (*(p++));
h->x_offset = g_ntohl (*(p++));
h->byte_order = g_ntohl (*(p++));
h->bitmap_unit = g_ntohl (*(p++));
h->bitmap_bit_order = g_ntohl (*(p++));
h->bitmap_pad = g_ntohl (*(p++));
h->bits_per_pixel = g_ntohl (*(p++));
h->bytes_per_line = g_ntohl (*(p++));
h->visual_class = g_ntohl (*(p++));
h->red_mask = g_ntohl (*(p++));
h->green_mask = g_ntohl (*(p++));
h->blue_mask = g_ntohl (*(p++));
h->bits_per_rgb = g_ntohl (*(p++));
h->color_map_entries = g_ntohl (*(p++));
h->n_colors = g_ntohl (*(p++));
h->window_width = g_ntohl (*(p++));
h->window_height = g_ntohl (*(p++));
h->window_x = g_ntohl (*(p++));
h->window_y = g_ntohl (*(p++));
h->window_border_width = g_ntohl (*(p++));
ASSERT_HEADER (h->header_size >= sizeof (XwdHeader));
ASSERT_HEADER (h->file_version == 7);
ASSERT_HEADER (h->pixmap_depth == 24);
ASSERT_HEADER (h->bits_per_rgb == 8 || h->bits_per_rgb == 24);
ASSERT_HEADER (h->bytes_per_line >= h->pixmap_width * (h->bits_per_pixel / 8));
ASSERT_HEADER (compute_pixel_type (loader) < CHAFA_PIXEL_MAX);
loader->file_data = file_mapping_get_data (loader->mapping, &loader->file_data_len);
if (!loader->file_data)
return FALSE;
ASSERT_HEADER (loader->file_data_len >= h->header_size
+ h->n_colors * sizeof (XwdColor)
+ h->pixmap_height * h->bytes_per_line);
loader->image_data = (const guint8 *) loader->file_data
+ h->header_size + h->n_colors * sizeof (XwdColor);
return TRUE;
}","static gboolean
load_header (XwdLoader *VAR_0) 
{
XwdHeader *VAR_1 = &VAR_0->header;
XwdHeader VAR_2;
const guint32 *VAR_3 = (const guint32 *) &VAR_2;
if (!file_mapping_taste (VAR_0->mapping, &VAR_2, 0, sizeof (VAR_2)))
return FALSE;
VAR_1->header_size = g_ntohl (*(VAR_3++));
VAR_1->file_version = g_ntohl (*(VAR_3++));
VAR_1->pixmap_format = g_ntohl (*(VAR_3++));
VAR_1->pixmap_depth = g_ntohl (*(VAR_3++));
VAR_1->pixmap_width = g_ntohl (*(VAR_3++));
VAR_1->pixmap_height = g_ntohl (*(VAR_3++));
VAR_1->x_offset = g_ntohl (*(VAR_3++));
VAR_1->byte_order = g_ntohl (*(VAR_3++));
VAR_1->bitmap_unit = g_ntohl (*(VAR_3++));
VAR_1->bitmap_bit_order = g_ntohl (*(VAR_3++));
VAR_1->bitmap_pad = g_ntohl (*(VAR_3++));
VAR_1->bits_per_pixel = g_ntohl (*(VAR_3++));
VAR_1->bytes_per_line = g_ntohl (*(VAR_3++));
VAR_1->visual_class = g_ntohl (*(VAR_3++));
VAR_1->red_mask = g_ntohl (*(VAR_3++));
VAR_1->green_mask = g_ntohl (*(VAR_3++));
VAR_1->blue_mask = g_ntohl (*(VAR_3++));
VAR_1->bits_per_rgb = g_ntohl (*(VAR_3++));
VAR_1->color_map_entries = g_ntohl (*(VAR_3++));
VAR_1->n_colors = g_ntohl (*(VAR_3++));
VAR_1->window_width = g_ntohl (*(VAR_3++));
VAR_1->window_height = g_ntohl (*(VAR_3++));
VAR_1->window_x = g_ntohl (*(VAR_3++));
VAR_1->window_y = g_ntohl (*(VAR_3++));
VAR_1->window_border_width = g_ntohl (*(VAR_3++));
ASSERT_HEADER (VAR_1->header_size >= sizeof (XwdHeader));
ASSERT_HEADER (VAR_1->file_version == 7);
ASSERT_HEADER (VAR_1->pixmap_depth == 24);
ASSERT_HEADER (VAR_1->bits_per_rgb == 8 || VAR_1->bits_per_rgb == 24);
ASSERT_HEADER (VAR_1->bytes_per_line >= VAR_1->pixmap_width * (VAR_1->bits_per_pixel / 8));
ASSERT_HEADER (compute_pixel_type (VAR_0) < VAR_4);
VAR_0->file_data = file_mapping_get_data (VAR_0->mapping, &VAR_0->file_data_len);
if (!VAR_0->file_data)
return FALSE;
ASSERT_HEADER (VAR_0->file_data_len >= VAR_1->header_size
+ VAR_1->n_colors * sizeof (XwdColor)
+ VAR_1->pixmap_height * VAR_1->bytes_per_line);
VAR_0->image_data = (const guint8 *) VAR_0->file_data
+ VAR_1->header_size + VAR_1->n_colors * sizeof (XwdColor);
return TRUE;
}",hpjansson/chafa/56fabfa18a6880b4cb66047fa6557920078048d9/xwd-loader.c/vul/before/0.json,"static gboolean
load_header (XwdLoader *loader)
{
    XwdHeader *h = &loader->header;
    XwdHeader in;
    const XwdHeader *inp;

    if (!file_mapping_taste (loader->mapping, &in, 0, sizeof (in)))
        return FALSE;

    inp = &in;

    UNPACK_FIELD_U32 (h, inp, header_size);
    UNPACK_FIELD_U32 (h, inp, file_version);
    UNPACK_FIELD_U32 (h, inp, pixmap_format);
    UNPACK_FIELD_U32 (h, inp, pixmap_depth);
    UNPACK_FIELD_U32 (h, inp, pixmap_width);
    UNPACK_FIELD_U32 (h, inp, pixmap_height);
    UNPACK_FIELD_U32 (h, inp, x_offset);
    UNPACK_FIELD_U32 (h, inp, byte_order);
    UNPACK_FIELD_U32 (h, inp, bitmap_unit);
    UNPACK_FIELD_U32 (h, inp, bitmap_bit_order);
    UNPACK_FIELD_U32 (h, inp, bitmap_pad);
    UNPACK_FIELD_U32 (h, inp, bits_per_pixel);
    UNPACK_FIELD_U32 (h, inp, bytes_per_line);
    UNPACK_FIELD_U32 (h, inp, visual_class);
    UNPACK_FIELD_U32 (h, inp, red_mask);
    UNPACK_FIELD_U32 (h, inp, green_mask);
    UNPACK_FIELD_U32 (h, inp, blue_mask);
    UNPACK_FIELD_U32 (h, inp, bits_per_rgb);
    UNPACK_FIELD_U32 (h, inp, color_map_entries);
    UNPACK_FIELD_U32 (h, inp, n_colors);
    UNPACK_FIELD_U32 (h, inp, window_width);
    UNPACK_FIELD_U32 (h, inp, window_height);
    UNPACK_FIELD_S32 (h, inp, window_x);
    UNPACK_FIELD_S32 (h, inp, window_y);
    UNPACK_FIELD_U32 (h, inp, window_border_width);

    /* Only support the most common/useful subset of XWD files out there;
     * namely, that corresponding to screen dumps from modern X.Org servers.
     * We could check visual_class == 5 too, but the other fields convey all
     * the info we need. */

    ASSERT_HEADER (h->header_size >= sizeof (XwdHeader));
    ASSERT_HEADER (h->header_size <= 65535);
    ASSERT_HEADER (h->file_version == 7);
    ASSERT_HEADER (h->pixmap_depth == 24);

    /* Should be zero for truecolor/directcolor. Cap it to prevent overflows. */
    ASSERT_HEADER (h->color_map_entries <= 256);

    /* Xvfb sets bits_per_rgb to 8, but 'convert' uses 24 for the same image data. One
     * of them is likely misunderstanding. Let's be lenient and accept either. */
    ASSERT_HEADER (h->bits_per_rgb == 8 || h->bits_per_rgb == 24);

    /* These are the pixel formats we allow. */
    ASSERT_HEADER (h->bits_per_pixel == 24 || h->bits_per_pixel == 32);

    /* Enforce sane dimensions. */
    ASSERT_HEADER (h->pixmap_width >= 1 && h->pixmap_width <= 65535);
    ASSERT_HEADER (h->pixmap_height >= 1 && h->pixmap_height <= 65535);

    /* Make sure rowstride can actually hold a row's worth of data but is not padded to
     * something ridiculous. */
    ASSERT_HEADER (h->bytes_per_line >= h->pixmap_width * (h->bits_per_pixel / 8));
    ASSERT_HEADER (h->bytes_per_line <= h->pixmap_width * (h->bits_per_pixel / 8) + 1024);

    /* Make sure the total allocation/map is not too big. */
    ASSERT_HEADER (h->bytes_per_line * h->pixmap_height < (1UL << 31) - 65536 - 256 * 32);

    ASSERT_HEADER (compute_pixel_type (loader) < CHAFA_PIXEL_MAX);

    loader->file_data = file_mapping_get_data (loader->mapping, &loader->file_data_len);
    if (!loader->file_data)
        return FALSE;

    ASSERT_HEADER (loader->file_data_len >= h->header_size
                   + h->color_map_entries * sizeof (XwdColor)
                   + h->pixmap_height * (gsize) h->bytes_per_line);

    loader->image_data = (const guint8 *) loader->file_data
        + h->header_size + h->color_map_entries * sizeof (XwdColor);

    return TRUE;
}","static gboolean
load_header (XwdLoader *VAR_0)
{
    XwdHeader *VAR_1 = &VAR_0->header;
    XwdHeader VAR_2;
    const XwdHeader *VAR_3;

    if (!file_mapping_taste (VAR_0->mapping, &VAR_2, 0, sizeof (VAR_2)))
        return FALSE;

    VAR_3 = &VAR_2;

    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_4);
    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_5);
    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_6);
    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_7);
    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_8);
    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_9);
    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_10);
    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_11);
    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_12);
    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_13);
    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_14);
    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_15);
    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_16);
    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_17);
    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_18);
    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_19);
    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_20);
    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_21);
    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_22);
    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_23);
    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_24);
    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_25);
    UNPACK_FIELD_S32 (VAR_1, VAR_3, VAR_26);
    UNPACK_FIELD_S32 (VAR_1, VAR_3, VAR_27);
    UNPACK_FIELD_U32 (VAR_1, VAR_3, VAR_28);

    /* COMMENT_0 */
                                                                            
                                                                            
                           

    ASSERT_HEADER (VAR_1->header_size >= sizeof (XwdHeader));
    ASSERT_HEADER (VAR_1->header_size <= 65535);
    ASSERT_HEADER (VAR_1->file_version == 7);
    ASSERT_HEADER (VAR_1->pixmap_depth == 24);

    /* COMMENT_4 */
    ASSERT_HEADER (VAR_1->color_map_entries <= 256);

    /* COMMENT_5 */
                                                                                 
    ASSERT_HEADER (VAR_1->bits_per_rgb == 8 || VAR_1->bits_per_rgb == 24);

    /* COMMENT_7 */
    ASSERT_HEADER (VAR_1->bits_per_pixel == 24 || VAR_1->bits_per_pixel == 32);

    /* COMMENT_8 */
    ASSERT_HEADER (VAR_1->pixmap_width >= 1 && VAR_1->pixmap_width <= 65535);
    ASSERT_HEADER (VAR_1->pixmap_height >= 1 && VAR_1->pixmap_height <= 65535);

    /* COMMENT_9 */
                               
    ASSERT_HEADER (VAR_1->bytes_per_line >= VAR_1->pixmap_width * (VAR_1->bits_per_pixel / 8));
    ASSERT_HEADER (VAR_1->bytes_per_line <= VAR_1->pixmap_width * (VAR_1->bits_per_pixel / 8) + 1024);

    /* COMMENT_11 */
    ASSERT_HEADER (VAR_1->bytes_per_line * VAR_1->pixmap_height < (1UL << 31) - 65536 - 256 * 32);

    ASSERT_HEADER (compute_pixel_type (VAR_0) < VAR_29);

    VAR_0->file_data = file_mapping_get_data (VAR_0->mapping, &VAR_0->file_data_len);
    if (!VAR_0->file_data)
        return FALSE;

    ASSERT_HEADER (VAR_0->file_data_len >= VAR_1->header_size
                   + VAR_1->color_map_entries * sizeof (XwdColor)
                   + VAR_1->pixmap_height * (gsize) VAR_1->bytes_per_line);

    VAR_0->image_data = (const guint8 *) VAR_0->file_data
        + VAR_1->header_size + VAR_1->color_map_entries * sizeof (XwdColor);

    return TRUE;
}",hpjansson/chafa/56fabfa18a6880b4cb66047fa6557920078048d9/xwd-loader.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,51 +1,73 @@
 static gboolean
-load_header (XwdLoader *loader) // gconstpointer in, gsize in_max_len, XwdHeader *header_out)
+load_header (XwdLoader *loader)
 {
     XwdHeader *h = &loader->header;
     XwdHeader in;
-    const guint32 *p = (const guint32 *) &in;
+    const XwdHeader *inp;
 
     if (!file_mapping_taste (loader->mapping, &in, 0, sizeof (in)))
         return FALSE;
 
-    h->header_size = g_ntohl (*(p++));
-    h->file_version = g_ntohl (*(p++));
-    h->pixmap_format = g_ntohl (*(p++));
-    h->pixmap_depth = g_ntohl (*(p++));
-    h->pixmap_width = g_ntohl (*(p++));
-    h->pixmap_height = g_ntohl (*(p++));
-    h->x_offset = g_ntohl (*(p++));
-    h->byte_order = g_ntohl (*(p++));
-    h->bitmap_unit = g_ntohl (*(p++));
-    h->bitmap_bit_order = g_ntohl (*(p++));
-    h->bitmap_pad = g_ntohl (*(p++));
-    h->bits_per_pixel = g_ntohl (*(p++));
-    h->bytes_per_line = g_ntohl (*(p++));
-    h->visual_class = g_ntohl (*(p++));
-    h->red_mask = g_ntohl (*(p++));
-    h->green_mask = g_ntohl (*(p++));
-    h->blue_mask = g_ntohl (*(p++));
-    h->bits_per_rgb = g_ntohl (*(p++));
-    h->color_map_entries = g_ntohl (*(p++));
-    h->n_colors = g_ntohl (*(p++));
-    h->window_width = g_ntohl (*(p++));
-    h->window_height = g_ntohl (*(p++));
-    h->window_x = g_ntohl (*(p++));
-    h->window_y = g_ntohl (*(p++));
-    h->window_border_width = g_ntohl (*(p++));
+    inp = &in;
+
+    UNPACK_FIELD_U32 (h, inp, header_size);
+    UNPACK_FIELD_U32 (h, inp, file_version);
+    UNPACK_FIELD_U32 (h, inp, pixmap_format);
+    UNPACK_FIELD_U32 (h, inp, pixmap_depth);
+    UNPACK_FIELD_U32 (h, inp, pixmap_width);
+    UNPACK_FIELD_U32 (h, inp, pixmap_height);
+    UNPACK_FIELD_U32 (h, inp, x_offset);
+    UNPACK_FIELD_U32 (h, inp, byte_order);
+    UNPACK_FIELD_U32 (h, inp, bitmap_unit);
+    UNPACK_FIELD_U32 (h, inp, bitmap_bit_order);
+    UNPACK_FIELD_U32 (h, inp, bitmap_pad);
+    UNPACK_FIELD_U32 (h, inp, bits_per_pixel);
+    UNPACK_FIELD_U32 (h, inp, bytes_per_line);
+    UNPACK_FIELD_U32 (h, inp, visual_class);
+    UNPACK_FIELD_U32 (h, inp, red_mask);
+    UNPACK_FIELD_U32 (h, inp, green_mask);
+    UNPACK_FIELD_U32 (h, inp, blue_mask);
+    UNPACK_FIELD_U32 (h, inp, bits_per_rgb);
+    UNPACK_FIELD_U32 (h, inp, color_map_entries);
+    UNPACK_FIELD_U32 (h, inp, n_colors);
+    UNPACK_FIELD_U32 (h, inp, window_width);
+    UNPACK_FIELD_U32 (h, inp, window_height);
+    UNPACK_FIELD_S32 (h, inp, window_x);
+    UNPACK_FIELD_S32 (h, inp, window_y);
+    UNPACK_FIELD_U32 (h, inp, window_border_width);
 
     /* Only support the most common/useful subset of XWD files out there;
-     * namely, that corresponding to screen dumps from modern X.Org servers. */
+     * namely, that corresponding to screen dumps from modern X.Org servers.
+     * We could check visual_class == 5 too, but the other fields convey all
+     * the info we need. */
 
     ASSERT_HEADER (h->header_size >= sizeof (XwdHeader));
+    ASSERT_HEADER (h->header_size <= 65535);
     ASSERT_HEADER (h->file_version == 7);
     ASSERT_HEADER (h->pixmap_depth == 24);
+
+    /* Should be zero for truecolor/directcolor. Cap it to prevent overflows. */
+    ASSERT_HEADER (h->color_map_entries <= 256);
 
     /* Xvfb sets bits_per_rgb to 8, but 'convert' uses 24 for the same image data. One
      * of them is likely misunderstanding. Let's be lenient and accept either. */
     ASSERT_HEADER (h->bits_per_rgb == 8 || h->bits_per_rgb == 24);
 
+    /* These are the pixel formats we allow. */
+    ASSERT_HEADER (h->bits_per_pixel == 24 || h->bits_per_pixel == 32);
+
+    /* Enforce sane dimensions. */
+    ASSERT_HEADER (h->pixmap_width >= 1 && h->pixmap_width <= 65535);
+    ASSERT_HEADER (h->pixmap_height >= 1 && h->pixmap_height <= 65535);
+
+    /* Make sure rowstride can actually hold a row's worth of data but is not padded to
+     * something ridiculous. */
     ASSERT_HEADER (h->bytes_per_line >= h->pixmap_width * (h->bits_per_pixel / 8));
+    ASSERT_HEADER (h->bytes_per_line <= h->pixmap_width * (h->bits_per_pixel / 8) + 1024);
+
+    /* Make sure the total allocation/map is not too big. */
+    ASSERT_HEADER (h->bytes_per_line * h->pixmap_height < (1UL << 31) - 65536 - 256 * 32);
+
     ASSERT_HEADER (compute_pixel_type (loader) < CHAFA_PIXEL_MAX);
 
     loader->file_data = file_mapping_get_data (loader->mapping, &loader->file_data_len);
@@ -53,11 +75,11 @@
         return FALSE;
 
     ASSERT_HEADER (loader->file_data_len >= h->header_size
-                   + h->n_colors * sizeof (XwdColor)
-                   + h->pixmap_height * h->bytes_per_line);
+                   + h->color_map_entries * sizeof (XwdColor)
+                   + h->pixmap_height * (gsize) h->bytes_per_line);
 
     loader->image_data = (const guint8 *) loader->file_data
-        + h->header_size + h->n_colors * sizeof (XwdColor);
+        + h->header_size + h->color_map_entries * sizeof (XwdColor);
 
     return TRUE;
 }","{'deleted_lines': ['load_header (XwdLoader *loader) // gconstpointer in, gsize in_max_len, XwdHeader *header_out)', '    const guint32 *p = (const guint32 *) &in;', '    h->header_size = g_ntohl (*(p++));', '    h->file_version = g_ntohl (*(p++));', '    h->pixmap_format = g_ntohl (*(p++));', '    h->pixmap_depth = g_ntohl (*(p++));', '    h->pixmap_width = g_ntohl (*(p++));', '    h->pixmap_height = g_ntohl (*(p++));', '    h->x_offset = g_ntohl (*(p++));', '    h->byte_order = g_ntohl (*(p++));', '    h->bitmap_unit = g_ntohl (*(p++));', '    h->bitmap_bit_order = g_ntohl (*(p++));', '    h->bitmap_pad = g_ntohl (*(p++));', '    h->bits_per_pixel = g_ntohl (*(p++));', '    h->bytes_per_line = g_ntohl (*(p++));', '    h->visual_class = g_ntohl (*(p++));', '    h->red_mask = g_ntohl (*(p++));', '    h->green_mask = g_ntohl (*(p++));', '    h->blue_mask = g_ntohl (*(p++));', '    h->bits_per_rgb = g_ntohl (*(p++));', '    h->color_map_entries = g_ntohl (*(p++));', '    h->n_colors = g_ntohl (*(p++));', '    h->window_width = g_ntohl (*(p++));', '    h->window_height = g_ntohl (*(p++));', '    h->window_x = g_ntohl (*(p++));', '    h->window_y = g_ntohl (*(p++));', '    h->window_border_width = g_ntohl (*(p++));', '     * namely, that corresponding to screen dumps from modern X.Org servers. */', '                   + h->n_colors * sizeof (XwdColor)', '                   + h->pixmap_height * h->bytes_per_line);', '        + h->header_size + h->n_colors * sizeof (XwdColor);'], 'added_lines': ['load_header (XwdLoader *loader)', '    const XwdHeader *inp;', '    inp = &in;', '', '    UNPACK_FIELD_U32 (h, inp, header_size);', '    UNPACK_FIELD_U32 (h, inp, file_version);', '    UNPACK_FIELD_U32 (h, inp, pixmap_format);', '    UNPACK_FIELD_U32 (h, inp, pixmap_depth);', '    UNPACK_FIELD_U32 (h, inp, pixmap_width);', '    UNPACK_FIELD_U32 (h, inp, pixmap_height);', '    UNPACK_FIELD_U32 (h, inp, x_offset);', '    UNPACK_FIELD_U32 (h, inp, byte_order);', '    UNPACK_FIELD_U32 (h, inp, bitmap_unit);', '    UNPACK_FIELD_U32 (h, inp, bitmap_bit_order);', '    UNPACK_FIELD_U32 (h, inp, bitmap_pad);', '    UNPACK_FIELD_U32 (h, inp, bits_per_pixel);', '    UNPACK_FIELD_U32 (h, inp, bytes_per_line);', '    UNPACK_FIELD_U32 (h, inp, visual_class);', '    UNPACK_FIELD_U32 (h, inp, red_mask);', '    UNPACK_FIELD_U32 (h, inp, green_mask);', '    UNPACK_FIELD_U32 (h, inp, blue_mask);', '    UNPACK_FIELD_U32 (h, inp, bits_per_rgb);', '    UNPACK_FIELD_U32 (h, inp, color_map_entries);', '    UNPACK_FIELD_U32 (h, inp, n_colors);', '    UNPACK_FIELD_U32 (h, inp, window_width);', '    UNPACK_FIELD_U32 (h, inp, window_height);', '    UNPACK_FIELD_S32 (h, inp, window_x);', '    UNPACK_FIELD_S32 (h, inp, window_y);', '    UNPACK_FIELD_U32 (h, inp, window_border_width);', '     * namely, that corresponding to screen dumps from modern X.Org servers.', '     * We could check visual_class == 5 too, but the other fields convey all', '     * the info we need. */', '    ASSERT_HEADER (h->header_size <= 65535);', '', '    /* Should be zero for truecolor/directcolor. Cap it to prevent overflows. */', '    ASSERT_HEADER (h->color_map_entries <= 256);', '    /* These are the pixel formats we allow. */', '    ASSERT_HEADER (h->bits_per_pixel == 24 || h->bits_per_pixel == 32);', '', '    /* Enforce sane dimensions. */', '    ASSERT_HEADER (h->pixmap_width >= 1 && h->pixmap_width <= 65535);', '    ASSERT_HEADER (h->pixmap_height >= 1 && h->pixmap_height <= 65535);', '', ""    /* Make sure rowstride can actually hold a row's worth of data but is not padded to"", '     * something ridiculous. */', '    ASSERT_HEADER (h->bytes_per_line <= h->pixmap_width * (h->bits_per_pixel / 8) + 1024);', '', '    /* Make sure the total allocation/map is not too big. */', '    ASSERT_HEADER (h->bytes_per_line * h->pixmap_height < (1UL << 31) - 65536 - 256 * 32);', '', '                   + h->color_map_entries * sizeof (XwdColor)', '                   + h->pixmap_height * (gsize) h->bytes_per_line);', '        + h->header_size + h->color_map_entries * sizeof (XwdColor);']}",True,Buffer Over-read in GitHub repository hpjansson/chafa prior to 1.10.3.,5.5,MEDIUM,1,test,2022-05-01T22:37:35Z,4
CVE-2022-30292,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,albertodemichelis/squirrel,fix in thread.call,a6413aa690e0bdfef648c68693349a7b878fe60d,https://github.com/albertodemichelis/squirrel/commit/a6413aa690e0bdfef648c68693349a7b878fe60d,squirrel/sqbaselib.cpp,thread_call,"static SQInteger thread_call(HSQUIRRELVM v)
{
SQObjectPtr o = stack_get(v,1);
if(sq_type(o) == OT_THREAD) {
SQInteger nparams = sq_gettop(v);
_thread(o)->Push(_thread(o)->_roottable);
for(SQInteger i = 2; i<(nparams+1); i++)
sq_move(_thread(o),v,i);
if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {
sq_move(v,_thread(o),-1);
sq_pop(_thread(o),1);
return 1;
}
v->_lasterror = _thread(o)->_lasterror;
return SQ_ERROR;
}
return sq_throwerror(v,_SC(""wrong parameter""));
}","static SQInteger thread_call(HSQUIRRELVM VAR_0)
{
SQObjectPtr VAR_1 = stack_get(VAR_0,1);
if(sq_type(VAR_1) == VAR_2) {
SQInteger VAR_3 = sq_gettop(VAR_0);
_thread(VAR_1)->Push(_thread(VAR_1)->_roottable);
for(SQInteger VAR_4 = 2; VAR_4<(VAR_3+1); VAR_4++)
sq_move(_thread(VAR_1),VAR_0,VAR_4);
if(SQ_SUCCEEDED(sq_call(_thread(VAR_1),VAR_3,VAR_5,VAR_5))) {
sq_move(VAR_0,_thread(VAR_1),-1);
sq_pop(_thread(VAR_1),1);
return 1;
}
VAR_0->_lasterror = _thread(VAR_1)->_lasterror;
return VAR_6;
}
return sq_throwerror(VAR_0,_SC(""wrong parameter""));
}",albertodemichelis/squirrel/a6413aa690e0bdfef648c68693349a7b878fe60d/sqbaselib.cpp/vul/before/0.json,"static SQInteger thread_call(HSQUIRRELVM v)
{
    SQObjectPtr o = stack_get(v,1);
    if(sq_type(o) == OT_THREAD) {
        SQInteger nparams = sq_gettop(v);
        sq_reservestack(_thread(o), nparams + 3);
        _thread(o)->Push(_thread(o)->_roottable);
        for(SQInteger i = 2; i<(nparams+1); i++)
            sq_move(_thread(o),v,i);
        if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {
            sq_move(v,_thread(o),-1);
            sq_pop(_thread(o),1);
            return 1;
        }
        v->_lasterror = _thread(o)->_lasterror;
        return SQ_ERROR;
    }
    return sq_throwerror(v,_SC(""wrong parameter""));
}","static SQInteger thread_call(HSQUIRRELVM VAR_0)
{
    SQObjectPtr VAR_1 = stack_get(VAR_0,1);
    if(sq_type(VAR_1) == VAR_2) {
        SQInteger VAR_3 = sq_gettop(VAR_0);
        sq_reservestack(_thread(VAR_1), VAR_3 + 3);
        _thread(VAR_1)->Push(_thread(VAR_1)->_roottable);
        for(SQInteger VAR_4 = 2; VAR_4<(VAR_3+1); VAR_4++)
            sq_move(_thread(VAR_1),VAR_0,VAR_4);
        if(SQ_SUCCEEDED(sq_call(_thread(VAR_1),VAR_3,VAR_5,VAR_5))) {
            sq_move(VAR_0,_thread(VAR_1),-1);
            sq_pop(_thread(VAR_1),1);
            return 1;
        }
        VAR_0->_lasterror = _thread(VAR_1)->_lasterror;
        return VAR_6;
    }
    return sq_throwerror(VAR_0,_SC(""wrong parameter""));
}",albertodemichelis/squirrel/a6413aa690e0bdfef648c68693349a7b878fe60d/sqbaselib.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,6 +3,7 @@
     SQObjectPtr o = stack_get(v,1);
     if(sq_type(o) == OT_THREAD) {
         SQInteger nparams = sq_gettop(v);
+        sq_reservestack(_thread(o), nparams + 3);
         _thread(o)->Push(_thread(o)->_roottable);
         for(SQInteger i = 2; i<(nparams+1); i++)
             sq_move(_thread(o),v,i);","{'deleted_lines': [], 'added_lines': ['        sq_reservestack(_thread(o), nparams + 3);']}",True,Heap-based buffer overflow in sqbaselib.cpp in SQUIRREL 3.2 due to lack of a certain sq_reservestack call.,10.0,CRITICAL,3,test,2022-05-02T10:04:58Z,4
CVE-2022-1907,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0,bfabiszewski/libmobi,"Fix boundary checking error in markup search, that could cause buffer over-read with corrupt input",1e0378e6f9e4ae415cedc9eb10850888897c5dba,https://github.com/bfabiszewski/libmobi/commit/1e0378e6f9e4ae415cedc9eb10850888897c5dba,src/parse_rawml.c,mobi_find_attrvalue,"MOBI_RET mobi_find_attrvalue(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end, const MOBIFiletype type, const char *needle) {
if (!result) {
debug_print(""Result structure is null%s"", ""\n"");
return MOBI_PARAM_ERR;
}
result->start = result->end = NULL;
*(result->value) = '\0';
if (!data_start || !data_end) {
debug_print(""Data is null%s"", ""\n"");
return MOBI_PARAM_ERR;
}
size_t needle_length = strlen(needle);
if (needle_length > MOBI_ATTRNAME_MAXSIZE) {
debug_print(""Attribute too long: %zu\n"", needle_length);
return MOBI_PARAM_ERR;
}
if (data_start + needle_length > data_end) {
return MOBI_SUCCESS;
}
unsigned char *data = (unsigned char *) data_start;
unsigned char tag_open;
unsigned char tag_close;
if (type == T_CSS) {
tag_open = '{';
tag_close = '}';
} else {
tag_open = '<';
tag_close = '>';
}
unsigned char last_border = tag_close;
while (data <= data_end) {
if (*data == tag_open || *data == tag_close) {
last_border = *data;
}
if (data + needle_length <= data_end && memcmp(data, needle, needle_length) == 0) {
if (last_border != tag_open) {
data += needle_length;
continue;
}
while (data >= data_start && !isspace(*data) && *data != tag_open && *data != '=' && *data != '(') {
data--;
}
result->is_url = (*data == '(');
result->start = ++data;
int i = 0;
while (data <= data_end && !isspace(*data) && *data != tag_close && *data != ')' && i < MOBI_ATTRVALUE_MAXSIZE) {
result->value[i++] = (char) *data++;
}
if (*(data - 1) == '/' && *data == '>') {
--data; --i;
}
result->end = data;
result->value[i] = '\0';
return MOBI_SUCCESS;
}
data++;
}
return MOBI_SUCCESS;
}","MOBI_RET mobi_find_attrvalue(MOBIResult *VAR_0, const unsigned char *VAR_1, const unsigned char *VAR_2, const MOBIFiletype VAR_3, const char *VAR_4) {
if (!VAR_0) {
debug_print(""Result structure is null%s"", ""\n"");
return VAR_5;
}
VAR_0->start = VAR_0->end = NULL;
*(VAR_0->value) = '\0';
if (!VAR_1 || !VAR_2) {
debug_print(""Data is null%s"", ""\n"");
return VAR_5;
}
size_t VAR_6 = strlen(VAR_4);
if (VAR_6 > VAR_7) {
debug_print(""Attribute too long: %zu\n"", VAR_6);
return VAR_5;
}
if (VAR_1 + VAR_6 > VAR_2) {
return VAR_8;
}
unsigned char *VAR_9 = (unsigned char *) VAR_1;
unsigned char VAR_10;
unsigned char VAR_11;
if (VAR_3 == VAR_12) {
VAR_10 = '{';
VAR_11 = '}';
} else {
VAR_10 = '<';
VAR_11 = '>';
}
unsigned char VAR_13 = VAR_11;
while (VAR_9 <= VAR_2) {
if (*VAR_9 == VAR_10 || *VAR_9 == VAR_11) {
VAR_13 = *VAR_9;
}
if (VAR_9 + VAR_6 <= VAR_2 && memcmp(VAR_9, VAR_4, VAR_6) == 0) {
if (VAR_13 != VAR_10) {
VAR_9 += VAR_6;
continue;
}
while (VAR_9 >= VAR_1 && !isspace(*VAR_9) && *VAR_9 != VAR_10 && *VAR_9 != '=' && *VAR_9 != '(') {
VAR_9--;
}
VAR_0->is_url = (*VAR_9 == '(');
VAR_0->start = ++VAR_9;
int VAR_14 = 0;
while (VAR_9 <= VAR_2 && !isspace(*VAR_9) && *VAR_9 != VAR_11 && *VAR_9 != ')' && VAR_14 < VAR_15) {
VAR_0->value[VAR_14++] = (char) *VAR_9++;
}
if (*(VAR_9 - 1) == '/' && *VAR_9 == '>') {
--VAR_9; --VAR_14;
}
VAR_0->end = VAR_9;
VAR_0->value[VAR_14] = '\0';
return VAR_8;
}
VAR_9++;
}
return VAR_8;
}",bfabiszewski/libmobi/1e0378e6f9e4ae415cedc9eb10850888897c5dba/parse_rawml.c/vul/before/2.json,"MOBI_RET mobi_find_attrvalue(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end, const MOBIFiletype type, const char *needle) {
    if (!result) {
        debug_print(""Result structure is null%s"", ""\n"");
        return MOBI_PARAM_ERR;
    }
    result->start = result->end = NULL;
    *(result->value) = '\0';
    if (!data_start || !data_end) {
        debug_print(""Data is null%s"", ""\n"");
        return MOBI_PARAM_ERR;
    }
    size_t needle_length = strlen(needle);
    if (needle_length > MOBI_ATTRNAME_MAXSIZE) {
        debug_print(""Attribute too long: %zu\n"", needle_length);
        return MOBI_PARAM_ERR;
    }
    if (data_start + needle_length > data_end) {
        return MOBI_SUCCESS;
    }
    unsigned char *data = (unsigned char *) data_start;
    unsigned char tag_open;
    unsigned char tag_close;
    if (type == T_CSS) {
        tag_open = '{';
        tag_close = '}';
    } else {
        tag_open = '<';
        tag_close = '>';
    }
    unsigned char last_border = tag_close;
    while (data <= data_end) {
        if (*data == tag_open || *data == tag_close) {
            last_border = *data;
        }
        if (data + needle_length <= data_end && memcmp(data, needle, needle_length) == 0) {
            /* found match */
            if (last_border != tag_open) {
                /* opening char not found, not an attribute */
                data += needle_length;
                continue;
            }
            /* go to attribute value beginning */
            while (data >= data_start && !isspace(*data) && *data != tag_open && *data != '=' && *data != '(') {
                data--;
            }
            result->is_url = (*data == '(');
            result->start = ++data;
            /* now go forward */
            int i = 0;
            while (data <= data_end && !isspace(*data) && *data != tag_close && *data != ')' && i < MOBI_ATTRVALUE_MAXSIZE) {
                result->value[i++] = (char) *data++;
            }
            /* self closing tag '/>' */
            if (data <= data_end && *(data - 1) == '/' && *data == '>') {
                --data; --i;
            }
            result->end = data;
            result->value[i] = '\0';
            return MOBI_SUCCESS;
        }
        data++;
    }
    return MOBI_SUCCESS;
}","MOBI_RET mobi_find_attrvalue(MOBIResult *VAR_0, const unsigned char *VAR_1, const unsigned char *VAR_2, const MOBIFiletype VAR_3, const char *VAR_4) {
    if (!VAR_0) {
        debug_print(""Result structure is null%s"", ""\n"");
        return VAR_5;
    }
    VAR_0->start = VAR_0->end = NULL;
    *(VAR_0->value) = '\0';
    if (!VAR_1 || !VAR_2) {
        debug_print(""Data is null%s"", ""\n"");
        return VAR_5;
    }
    size_t VAR_6 = strlen(VAR_4);
    if (VAR_6 > VAR_7) {
        debug_print(""Attribute too long: %zu\n"", VAR_6);
        return VAR_5;
    }
    if (VAR_1 + VAR_6 > VAR_2) {
        return VAR_8;
    }
    unsigned char *VAR_9 = (unsigned char *) VAR_1;
    unsigned char VAR_10;
    unsigned char VAR_11;
    if (VAR_3 == VAR_12) {
        VAR_10 = '{';
        VAR_11 = '}';
    } else {
        VAR_10 = '<';
        VAR_11 = '>';
    }
    unsigned char VAR_13 = VAR_11;
    while (VAR_9 <= VAR_2) {
        if (*VAR_9 == VAR_10 || *VAR_9 == VAR_11) {
            VAR_13 = *VAR_9;
        }
        if (VAR_9 + VAR_6 <= VAR_2 && memcmp(VAR_9, VAR_4, VAR_6) == 0) {
            /* COMMENT_0 */
            if (VAR_13 != VAR_10) {
                /* COMMENT_1 */
                VAR_9 += VAR_6;
                continue;
            }
            /* COMMENT_2 */
            while (VAR_9 >= VAR_1 && !isspace(*VAR_9) && *VAR_9 != VAR_10 && *VAR_9 != '=' && *VAR_9 != '(') {
                VAR_9--;
            }
            VAR_0->is_url = (*VAR_9 == '(');
            VAR_0->start = ++VAR_9;
            /* COMMENT_3 */
            int VAR_14 = 0;
            while (VAR_9 <= VAR_2 && !isspace(*VAR_9) && *VAR_9 != VAR_11 && *VAR_9 != ')' && VAR_14 < VAR_15) {
                VAR_0->value[VAR_14++] = (char) *VAR_9++;
            }
            /* COMMENT_4 */
            if (VAR_9 <= VAR_2 && *(VAR_9 - 1) == '/' && *VAR_9 == '>') {
                --VAR_9; --VAR_14;
            }
            VAR_0->end = VAR_9;
            VAR_0->value[VAR_14] = '\0';
            return VAR_8;
        }
        VAR_9++;
    }
    return VAR_8;
}",bfabiszewski/libmobi/1e0378e6f9e4ae415cedc9eb10850888897c5dba/parse_rawml.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -51,7 +51,7 @@
                 result->value[i++] = (char) *data++;
             }
             /* self closing tag '/>' */
-            if (*(data - 1) == '/' && *data == '>') {
+            if (data <= data_end && *(data - 1) == '/' && *data == '>') {
                 --data; --i;
             }
             result->end = data;","{'deleted_lines': [""            if (*(data - 1) == '/' && *data == '>') {""], 'added_lines': [""            if (data <= data_end && *(data - 1) == '/' && *data == '>') {""]}",True,Buffer Over-read in GitHub repository bfabiszewski/libmobi prior to 0.11.,8.1,HIGH,2,test,2022-05-03T07:10:25Z,4
CVE-2022-1907,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0,bfabiszewski/libmobi,"Fix boundary checking error in markup search, that could cause buffer over-read with corrupt input",1e0378e6f9e4ae415cedc9eb10850888897c5dba,https://github.com/bfabiszewski/libmobi/commit/1e0378e6f9e4ae415cedc9eb10850888897c5dba,src/parse_rawml.c,mobi_get_attribute_value,"size_t mobi_get_attribute_value(char *value, const unsigned char *data, const size_t size, const char *attribute, bool only_quoted) {
if (!data) {
debug_print(""Data is null%s"", ""\n"");
return SIZE_MAX;
}
size_t length = size;
size_t attr_length = strlen(attribute);
if (attr_length > MOBI_ATTRNAME_MAXSIZE) {
debug_print(""Attribute too long: %zu\n"", attr_length);
return SIZE_MAX;
}
char attr[MOBI_ATTRNAME_MAXSIZE + 2];
strcpy(attr, attribute);
strcat(attr, ""="");
attr_length++;
if (size < attr_length) {
return SIZE_MAX;
}
unsigned char last_border = '\0';
do {
if (*data == '<' || *data == '>') {
last_border = *data;
}
if (length > attr_length + 1 && memcmp(data, attr, attr_length) == 0) {
size_t offset = size - length;
if (last_border == '>') {
data += attr_length;
length -= attr_length - 1;
continue;
}
if (offset > 0) {
if (data[-1] != '<' && !isspace(data[-1])) {
data += attr_length;
length -= attr_length - 1;
continue;
}
}
data += attr_length;
length -= attr_length;
unsigned char separator;
if (*data != '\'' && *data != '""') {
if (only_quoted) {
continue;
}
separator = ' ';
} else {
separator = *data;
data++;
length--;
}
size_t j;
for (j = 0; j < MOBI_ATTRVALUE_MAXSIZE && length && *data != separator && *data != '>'; j++) {
*value++ = (char) *data++;
length--;
}
if (*(data - 1) == '/' && *data == '>') {
value--;
}
*value = '\0';
return size - length - j;
}
data++;
} while (--length);
value[0] = '\0';
return SIZE_MAX;
}","size_t mobi_get_attribute_value(char *VAR_0, const unsigned char *VAR_1, const size_t VAR_2, const char *VAR_3, bool VAR_4) {
if (!VAR_1) {
debug_print(""Data is null%s"", ""\n"");
return VAR_5;
}
size_t VAR_6 = VAR_2;
size_t VAR_7 = strlen(VAR_3);
if (VAR_7 > VAR_8) {
debug_print(""Attribute too long: %zu\n"", VAR_7);
return VAR_5;
}
char VAR_9[VAR_8 + 2];
strcpy(VAR_9, VAR_3);
strcat(VAR_9, ""="");
VAR_7++;
if (VAR_2 < VAR_7) {
return VAR_5;
}
unsigned char VAR_10 = '\0';
do {
if (*VAR_1 == '<' || *VAR_1 == '>') {
VAR_10 = *VAR_1;
}
if (VAR_6 > VAR_7 + 1 && memcmp(VAR_1, VAR_9, VAR_7) == 0) {
size_t VAR_11 = VAR_2 - VAR_6;
if (VAR_10 == '>') {
VAR_1 += VAR_7;
VAR_6 -= VAR_7 - 1;
continue;
}
if (VAR_11 > 0) {
if (VAR_1[-1] != '<' && !isspace(VAR_1[-1])) {
VAR_1 += VAR_7;
VAR_6 -= VAR_7 - 1;
continue;
}
}
VAR_1 += VAR_7;
VAR_6 -= VAR_7;
unsigned char VAR_12;
if (*VAR_1 != '\'' && *VAR_1 != '""') {
if (VAR_4) {
continue;
}
VAR_12 = ' ';
} else {
VAR_12 = *VAR_1;
VAR_1++;
VAR_6--;
}
size_t VAR_13;
for (VAR_13 = 0; VAR_13 < VAR_14 && VAR_6 && *VAR_1 != VAR_12 && *VAR_1 != '>'; VAR_13++) {
*VAR_0++ = (char) *VAR_1++;
VAR_6--;
}
if (*(VAR_1 - 1) == '/' && *VAR_1 == '>') {
VAR_0--;
}
*VAR_0 = '\0';
return VAR_2 - VAR_6 - VAR_13;
}
VAR_1++;
} while (--VAR_6);
VAR_0[0] = '\0';
return VAR_5;
}",bfabiszewski/libmobi/1e0378e6f9e4ae415cedc9eb10850888897c5dba/parse_rawml.c/vul/before/1.json,"size_t mobi_get_attribute_value(char *value, const unsigned char *data, const size_t size, const char *attribute, bool only_quoted) {
    /* FIXME: this function could be replaced by mobi_find_attrvalue()? */
    if (!data) {
        debug_print(""Data is null%s"", ""\n"");
        return SIZE_MAX;
    }
    size_t length = size;
    size_t attr_length = strlen(attribute);
    if (attr_length > MOBI_ATTRNAME_MAXSIZE) {
        debug_print(""Attribute too long: %zu\n"", attr_length);
        return SIZE_MAX;
    }
    char attr[MOBI_ATTRNAME_MAXSIZE + 2];
    strcpy(attr, attribute);
    strcat(attr, ""="");
    attr_length++;
    if (size < attr_length) {
        return SIZE_MAX;
    }
    /* FIXME: search may start inside tag, so it is a safer option */
    unsigned char last_border = '\0';
    do {
        if (*data == '<' || *data == '>') {
            last_border = *data;
        }
        if (length > attr_length + 1 && memcmp(data, attr, attr_length) == 0) {
            /* found match */
            size_t offset = size - length;
            if (last_border == '>') {
                /* We are in tag contents */
                data += attr_length;
                length -= attr_length - 1;
                continue;
            }
            /* previous character should be white space or opening tag */
            if (offset > 0) {
                if (data[-1] != '<' && !isspace(data[-1])) {
                    data += attr_length;
                    length -= attr_length - 1;
                    continue;
                }
            }
            /* now go forward */
            data += attr_length;
            length -= attr_length;
            unsigned char separator;
            if (*data != '\'' && *data != '""') {
                if (only_quoted) {
                    continue;
                }
                separator = ' ';
            } else {
                separator = *data;
                data++;
                length--;
            }
            size_t j;
            for (j = 0; j < MOBI_ATTRVALUE_MAXSIZE && length && *data != separator && *data != '>'; j++) {
                *value++ = (char) *data++;
                length--;
            }
            /* self closing tag '/>' */
            if (length && *(data - 1) == '/' && *data == '>') {
                value--;
            }
            *value = '\0';
            /* return offset to the beginning of the attribute value string */
            return size - length - j;
        }
        data++;
    } while (--length);
    value[0] = '\0';
    return SIZE_MAX;
}","size_t mobi_get_attribute_value(char *VAR_0, const unsigned char *VAR_1, const size_t VAR_2, const char *VAR_3, bool VAR_4) {
    /* COMMENT_0 */
    if (!VAR_1) {
        debug_print(""Data is null%s"", ""\n"");
        return VAR_5;
    }
    size_t VAR_6 = VAR_2;
    size_t VAR_7 = strlen(VAR_3);
    if (VAR_7 > VAR_8) {
        debug_print(""Attribute too long: %zu\n"", VAR_7);
        return VAR_5;
    }
    char VAR_9[VAR_8 + 2];
    strcpy(VAR_9, VAR_3);
    strcat(VAR_9, ""="");
    VAR_7++;
    if (VAR_2 < VAR_7) {
        return VAR_5;
    }
    /* COMMENT_1 */
    unsigned char VAR_10 = '\0';
    do {
        if (*VAR_1 == '<' || *VAR_1 == '>') {
            VAR_10 = *VAR_1;
        }
        if (VAR_6 > VAR_7 + 1 && memcmp(VAR_1, VAR_9, VAR_7) == 0) {
            /* COMMENT_2 */
            size_t VAR_11 = VAR_2 - VAR_6;
            if (VAR_10 == '>') {
                /* COMMENT_3 */
                VAR_1 += VAR_7;
                VAR_6 -= VAR_7 - 1;
                continue;
            }
            /* COMMENT_4 */
            if (VAR_11 > 0) {
                if (VAR_1[-1] != '<' && !isspace(VAR_1[-1])) {
                    VAR_1 += VAR_7;
                    VAR_6 -= VAR_7 - 1;
                    continue;
                }
            }
            /* COMMENT_5 */
            VAR_1 += VAR_7;
            VAR_6 -= VAR_7;
            unsigned char VAR_12;
            if (*VAR_1 != '\'' && *VAR_1 != '""') {
                if (VAR_4) {
                    continue;
                }
                VAR_12 = ' ';
            } else {
                VAR_12 = *VAR_1;
                VAR_1++;
                VAR_6--;
            }
            size_t VAR_13;
            for (VAR_13 = 0; VAR_13 < VAR_14 && VAR_6 && *VAR_1 != VAR_12 && *VAR_1 != '>'; VAR_13++) {
                *VAR_0++ = (char) *VAR_1++;
                VAR_6--;
            }
            /* COMMENT_6 */
            if (VAR_6 && *(VAR_1 - 1) == '/' && *VAR_1 == '>') {
                VAR_0--;
            }
            *VAR_0 = '\0';
            /* COMMENT_7 */
            return VAR_2 - VAR_6 - VAR_13;
        }
        VAR_1++;
    } while (--VAR_6);
    VAR_0[0] = '\0';
    return VAR_5;
}",bfabiszewski/libmobi/1e0378e6f9e4ae415cedc9eb10850888897c5dba/parse_rawml.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -60,7 +60,7 @@
                 length--;
             }
             /* self closing tag '/>' */
-            if (*(data - 1) == '/' && *data == '>') {
+            if (length && *(data - 1) == '/' && *data == '>') {
                 value--;
             }
             *value = '\0';","{'deleted_lines': [""            if (*(data - 1) == '/' && *data == '>') {""], 'added_lines': [""            if (length && *(data - 1) == '/' && *data == '>') {""]}",True,Buffer Over-read in GitHub repository bfabiszewski/libmobi prior to 0.11.,8.1,HIGH,2,test,2022-05-03T07:10:25Z,4
CVE-2022-1907,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0,bfabiszewski/libmobi,"Fix boundary checking error in markup search, that could cause buffer over-read with corrupt input",1e0378e6f9e4ae415cedc9eb10850888897c5dba,https://github.com/bfabiszewski/libmobi/commit/1e0378e6f9e4ae415cedc9eb10850888897c5dba,src/parse_rawml.c,mobi_search_links_kf7,"MOBI_RET mobi_search_links_kf7(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end) {
if (!result) {
debug_print(""Result structure is null%s"", ""\n"");
return MOBI_PARAM_ERR;
}
result->start = result->end = NULL;
*(result->value) = '\0';
if (!data_start || !data_end) {
debug_print(""Data is null%s"", ""\n"");
return MOBI_PARAM_ERR;
}
const char *needle1 = ""filepos="";
const char *needle2 = ""recindex="";
const size_t needle1_length = strlen(needle1);
const size_t needle2_length = strlen(needle2);
const size_t needle_length = max(needle1_length,needle2_length);
if (data_start + needle_length > data_end) {
return MOBI_SUCCESS;
}
unsigned char *data = (unsigned char *) data_start;
const unsigned char tag_open = '<';
const unsigned char tag_close = '>';
unsigned char last_border = tag_open;
while (data <= data_end) {
if (*data == tag_open || *data == tag_close) {
last_border = *data;
}
if (data + needle_length <= data_end &&
(memcmp(data, needle1, needle1_length) == 0 ||
memcmp(data, needle2, needle2_length) == 0)) {
if (last_border != tag_open) {
data += needle_length;
continue;
}
while (data >= data_start && !isspace(*data) && *data != tag_open) {
data--;
}
result->start = ++data;
int i = 0;
while (data <= data_end && !isspace(*data) && *data != tag_close && i < MOBI_ATTRVALUE_MAXSIZE) {
result->value[i++] = (char) *data++;
}
if (*(data - 1) == '/' && *data == '>') {
--data; --i;
}
result->end = data;
result->value[i] = '\0';
return MOBI_SUCCESS;
}
data++;
}
return MOBI_SUCCESS;
}","MOBI_RET mobi_search_links_kf7(MOBIResult *VAR_0, const unsigned char *VAR_1, const unsigned char *VAR_2) {
if (!VAR_0) {
debug_print(""Result structure is null%s"", ""\n"");
return VAR_3;
}
VAR_0->start = VAR_0->end = NULL;
*(VAR_0->value) = '\0';
if (!VAR_1 || !VAR_2) {
debug_print(""Data is null%s"", ""\n"");
return VAR_3;
}
const char *VAR_4 = ""filepos="";
const char *VAR_5 = ""recindex="";
const size_t VAR_6 = strlen(VAR_4);
const size_t VAR_7 = strlen(VAR_5);
const size_t VAR_8 = max(VAR_6,VAR_7);
if (VAR_1 + VAR_8 > VAR_2) {
return VAR_9;
}
unsigned char *VAR_10 = (unsigned char *) VAR_1;
const unsigned char VAR_11 = '<';
const unsigned char VAR_12 = '>';
unsigned char VAR_13 = VAR_11;
while (VAR_10 <= VAR_2) {
if (*VAR_10 == VAR_11 || *VAR_10 == VAR_12) {
VAR_13 = *VAR_10;
}
if (VAR_10 + VAR_8 <= VAR_2 &&
(memcmp(VAR_10, VAR_4, VAR_6) == 0 ||
memcmp(VAR_10, VAR_5, VAR_7) == 0)) {
if (VAR_13 != VAR_11) {
VAR_10 += VAR_8;
continue;
}
while (VAR_10 >= VAR_1 && !isspace(*VAR_10) && *VAR_10 != VAR_11) {
VAR_10--;
}
VAR_0->start = ++VAR_10;
int VAR_14 = 0;
while (VAR_10 <= VAR_2 && !isspace(*VAR_10) && *VAR_10 != VAR_12 && VAR_14 < VAR_15) {
VAR_0->value[VAR_14++] = (char) *VAR_10++;
}
if (*(VAR_10 - 1) == '/' && *VAR_10 == '>') {
--VAR_10; --VAR_14;
}
VAR_0->end = VAR_10;
VAR_0->value[VAR_14] = '\0';
return VAR_9;
}
VAR_10++;
}
return VAR_9;
}",bfabiszewski/libmobi/1e0378e6f9e4ae415cedc9eb10850888897c5dba/parse_rawml.c/vul/before/0.json,"MOBI_RET mobi_search_links_kf7(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end) {
    if (!result) {
        debug_print(""Result structure is null%s"", ""\n"");
        return MOBI_PARAM_ERR;
    }
    result->start = result->end = NULL;
    *(result->value) = '\0';
    if (!data_start || !data_end) {
        debug_print(""Data is null%s"", ""\n"");
        return MOBI_PARAM_ERR;
    }
    const char *needle1 = ""filepos="";
    const char *needle2 = ""recindex="";
    const size_t needle1_length = strlen(needle1);
    const size_t needle2_length = strlen(needle2);
    const size_t needle_length = max(needle1_length,needle2_length);
    if (data_start + needle_length > data_end) {
        return MOBI_SUCCESS;
    }
    unsigned char *data = (unsigned char *) data_start;
    const unsigned char tag_open = '<';
    const unsigned char tag_close = '>';
    unsigned char last_border = tag_open;
    while (data <= data_end) {
        if (*data == tag_open || *data == tag_close) {
            last_border = *data;
        }
        if (data + needle_length <= data_end &&
            (memcmp(data, needle1, needle1_length) == 0 ||
             memcmp(data, needle2, needle2_length) == 0)) {
                /* found match */
                if (last_border != tag_open) {
                    /* opening char not found, not an attribute */
                    data += needle_length;
                    continue;
                }
                /* go to attribute  beginning */
                while (data >= data_start && !isspace(*data) && *data != tag_open) {
                    data--;
                }
                result->start = ++data;
                /* now go forward */
                int i = 0;
                while (data <= data_end && !isspace(*data) && *data != tag_close && i < MOBI_ATTRVALUE_MAXSIZE) {
                    result->value[i++] = (char) *data++;
                }
                /* self closing tag '/>' */
                if (data <= data_end && *(data - 1) == '/' && *data == '>') {
                    --data; --i;
                }
                result->end = data;
                result->value[i] = '\0';
                return MOBI_SUCCESS;
            }
        data++;
    }
    return MOBI_SUCCESS;
}","MOBI_RET mobi_search_links_kf7(MOBIResult *VAR_0, const unsigned char *VAR_1, const unsigned char *VAR_2) {
    if (!VAR_0) {
        debug_print(""Result structure is null%s"", ""\n"");
        return VAR_3;
    }
    VAR_0->start = VAR_0->end = NULL;
    *(VAR_0->value) = '\0';
    if (!VAR_1 || !VAR_2) {
        debug_print(""Data is null%s"", ""\n"");
        return VAR_3;
    }
    const char *VAR_4 = ""filepos="";
    const char *VAR_5 = ""recindex="";
    const size_t VAR_6 = strlen(VAR_4);
    const size_t VAR_7 = strlen(VAR_5);
    const size_t VAR_8 = max(VAR_6,VAR_7);
    if (VAR_1 + VAR_8 > VAR_2) {
        return VAR_9;
    }
    unsigned char *VAR_10 = (unsigned char *) VAR_1;
    const unsigned char VAR_11 = '<';
    const unsigned char VAR_12 = '>';
    unsigned char VAR_13 = VAR_11;
    while (VAR_10 <= VAR_2) {
        if (*VAR_10 == VAR_11 || *VAR_10 == VAR_12) {
            VAR_13 = *VAR_10;
        }
        if (VAR_10 + VAR_8 <= VAR_2 &&
            (memcmp(VAR_10, VAR_4, VAR_6) == 0 ||
             memcmp(VAR_10, VAR_5, VAR_7) == 0)) {
                /* COMMENT_0 */
                if (VAR_13 != VAR_11) {
                    /* COMMENT_1 */
                    VAR_10 += VAR_8;
                    continue;
                }
                /* COMMENT_2 */
                while (VAR_10 >= VAR_1 && !isspace(*VAR_10) && *VAR_10 != VAR_11) {
                    VAR_10--;
                }
                VAR_0->start = ++VAR_10;
                /* COMMENT_3 */
                int VAR_14 = 0;
                while (VAR_10 <= VAR_2 && !isspace(*VAR_10) && *VAR_10 != VAR_12 && VAR_14 < VAR_15) {
                    VAR_0->value[VAR_14++] = (char) *VAR_10++;
                }
                /* COMMENT_4 */
                if (VAR_10 <= VAR_2 && *(VAR_10 - 1) == '/' && *VAR_10 == '>') {
                    --VAR_10; --VAR_14;
                }
                VAR_0->end = VAR_10;
                VAR_0->value[VAR_14] = '\0';
                return VAR_9;
            }
        VAR_10++;
    }
    return VAR_9;
}",bfabiszewski/libmobi/1e0378e6f9e4ae415cedc9eb10850888897c5dba/parse_rawml.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -45,7 +45,7 @@
                     result->value[i++] = (char) *data++;
                 }
                 /* self closing tag '/>' */
-                if (*(data - 1) == '/' && *data == '>') {
+                if (data <= data_end && *(data - 1) == '/' && *data == '>') {
                     --data; --i;
                 }
                 result->end = data;","{'deleted_lines': [""                if (*(data - 1) == '/' && *data == '>') {""], 'added_lines': [""                if (data <= data_end && *(data - 1) == '/' && *data == '>') {""]}",True,Buffer Over-read in GitHub repository bfabiszewski/libmobi prior to 0.11.,8.1,HIGH,2,test,2022-05-03T07:10:25Z,4
CVE-2022-1616,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,vim,"patch 8.2.4895: buffer overflow with invalid command with composing chars

Problem:    Buffer overflow with invalid command with composing chars.
Solution:   Check that the whole character fits in the buffer.",d88934406c5375d88f8f1b65331c9f0cab68cc6c,https://github.com/vim/vim/commit/d88934406c5375d88f8f1b65331c9f0cab68cc6c,src/ex_docmd.c,append_command,"static void
append_command(char_u *cmd)
{
char_u *s = cmd;
char_u *d;
STRCAT(IObuff, "": "");
d = IObuff + STRLEN(IObuff);
while (*s != NUL && d - IObuff < IOSIZE - 7)
{
if (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0) : *s == 0xa0)
{
s += enc_utf8 ? 2 : 1;
STRCPY(d, ""<a0>"");
d += 4;
}
else
MB_COPY_CHAR(s, d);
}
*d = NUL;
}","static void
append_command(char_u *VAR_0)
{
char_u *VAR_1 = VAR_0;
char_u *VAR_2;
STRCAT(VAR_3, "": "");
VAR_2 = VAR_3 + STRLEN(VAR_3);
while (*VAR_1 != VAR_4 && VAR_2 - VAR_3 < VAR_5 - 7)
{
if (VAR_6 ? (VAR_1[0] == 0xc2 && VAR_1[1] == 0xa0) : *VAR_1 == 0xa0)
{
VAR_1 += VAR_6 ? 2 : 1;
STRCPY(VAR_2, ""<a0>"");
VAR_2 += 4;
}
else
MB_COPY_CHAR(VAR_1, VAR_2);
}
*VAR_2 = VAR_4;
}",vim/d88934406c5375d88f8f1b65331c9f0cab68cc6c/ex_docmd.c/vul/before/0.json,"static void
append_command(char_u *cmd)
{
    char_u *s = cmd;
    char_u *d;

    STRCAT(IObuff, "": "");
    d = IObuff + STRLEN(IObuff);
    while (*s != NUL && d - IObuff + 5 < IOSIZE)
    {
	if (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0) : *s == 0xa0)
	{
	    s += enc_utf8 ? 2 : 1;
	    STRCPY(d, ""<a0>"");
	    d += 4;
	}
	else if (d - IObuff + (*mb_ptr2len)(s) + 1 >= IOSIZE)
	    break;
	else
	    MB_COPY_CHAR(s, d);
    }
    *d = NUL;
}","static void
append_command(char_u *VAR_0)
{
    char_u *VAR_1 = VAR_0;
    char_u *VAR_2;

    STRCAT(VAR_3, "": "");
    VAR_2 = VAR_3 + STRLEN(VAR_3);
    while (*VAR_1 != VAR_4 && VAR_2 - VAR_3 + 5 < VAR_5)
    {
	if (VAR_6 ? (VAR_1[0] == 0xc2 && VAR_1[1] == 0xa0) : *VAR_1 == 0xa0)
	{
	    VAR_1 += VAR_6 ? 2 : 1;
	    STRCPY(VAR_2, ""<a0>"");
	    VAR_2 += 4;
	}
	else if (VAR_2 - VAR_3 + (*VAR_7)(VAR_1) + 1 >= VAR_5)
	    break;
	else
	    MB_COPY_CHAR(VAR_1, VAR_2);
    }
    *VAR_2 = VAR_4;
}",vim/d88934406c5375d88f8f1b65331c9f0cab68cc6c/ex_docmd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
 
     STRCAT(IObuff, "": "");
     d = IObuff + STRLEN(IObuff);
-    while (*s != NUL && d - IObuff < IOSIZE - 7)
+    while (*s != NUL && d - IObuff + 5 < IOSIZE)
     {
 	if (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0) : *s == 0xa0)
 	{
@@ -14,6 +14,8 @@
 	    STRCPY(d, ""<a0>"");
 	    d += 4;
 	}
+	else if (d - IObuff + (*mb_ptr2len)(s) + 1 >= IOSIZE)
+	    break;
 	else
 	    MB_COPY_CHAR(s, d);
     }","{'deleted_lines': ['    while (*s != NUL && d - IObuff < IOSIZE - 7)'], 'added_lines': ['    while (*s != NUL && d - IObuff + 5 < IOSIZE)', '\telse if (d - IObuff + (*mb_ptr2len)(s) + 1 >= IOSIZE)', '\t    break;']}",True,"Use after free in append_command in GitHub repository vim/vim prior to 8.2.4895. This vulnerability is capable of crashing software, Bypass Protection Mechanism, Modify Memory, and possible remote execution",7.8,HIGH,2,test,2022-05-06T19:38:47Z,4
CVE-2022-31306,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,nginx/njs,"Fixed Object.defineProperty() when a recursive descriptor is provided.

This closes #481 issue on Github.",81af26364c21c196dd21fb5e14c7fa9ce7debd17,https://github.com/nginx/njs/commit/81af26364c21c196dd21fb5e14c7fa9ce7debd17,src/njs_array.c,njs_array_convert_to_slow_array,"njs_int_t
njs_array_convert_to_slow_array(njs_vm_t *vm, njs_array_t *array)
{
uint32_t           i, length;
njs_value_t        index, value;
njs_object_prop_t  *prop;
njs_set_array(&value, array);
array->object.fast_array = 0;
length = array->length;
for (i = 0; i < length; i++) {
if (njs_is_valid(&array->start[i])) {
njs_uint32_to_string(&index, i);
prop = njs_object_property_add(vm, &value, &index, 0);
if (njs_slow_path(prop == NULL)) {
return NJS_ERROR;
}
prop->value = array->start[i];
}
}
njs_mp_free(vm->mem_pool, array->start);
array->start = NULL;
return NJS_OK;
}","njs_int_t
njs_array_convert_to_slow_array(njs_vm_t *VAR_0, njs_array_t *VAR_1)
{
uint32_t           VAR_2, VAR_3;
njs_value_t        VAR_4, VAR_5;
njs_object_prop_t  *VAR_6;
njs_set_array(&VAR_5, VAR_1);
VAR_1->object.fast_array = 0;
VAR_3 = VAR_1->length;
for (VAR_2 = 0; VAR_2 < VAR_3; VAR_2++) {
if (njs_is_valid(&VAR_1->start[VAR_2])) {
njs_uint32_to_string(&VAR_4, VAR_2);
VAR_6 = njs_object_property_add(VAR_0, &VAR_5, &VAR_4, 0);
if (njs_slow_path(VAR_6 == NULL)) {
return VAR_7;
}
VAR_6->value = VAR_1->start[VAR_2];
}
}
njs_mp_free(VAR_0->mem_pool, VAR_1->start);
VAR_1->start = NULL;
return VAR_8;
}",nginx/njs/81af26364c21c196dd21fb5e14c7fa9ce7debd17/njs_array.c/vul/before/0.json,"njs_int_t
njs_array_convert_to_slow_array(njs_vm_t *vm, njs_array_t *array)
{
    uint32_t           i, length;
    njs_value_t        index, value;
    njs_object_prop_t  *prop;

    if (njs_slow_path(!array->object.fast_array)) {
        return NJS_OK;
    }

    njs_set_array(&value, array);
    array->object.fast_array = 0;

    length = array->length;

    for (i = 0; i < length; i++) {
        if (njs_is_valid(&array->start[i])) {
            njs_uint32_to_string(&index, i);
            prop = njs_object_property_add(vm, &value, &index, 0);
            if (njs_slow_path(prop == NULL)) {
                return NJS_ERROR;
            }

            prop->value = array->start[i];
        }
    }

    /* GC: release value. */

    njs_mp_free(vm->mem_pool, array->start);
    array->start = NULL;

    return NJS_OK;
}","njs_int_t
njs_array_convert_to_slow_array(njs_vm_t *VAR_0, njs_array_t *VAR_1)
{
    uint32_t           VAR_2, VAR_3;
    njs_value_t        VAR_4, VAR_5;
    njs_object_prop_t  *VAR_6;

    if (njs_slow_path(!VAR_1->object.fast_array)) {
        return VAR_7;
    }

    njs_set_array(&VAR_5, VAR_1);
    VAR_1->object.fast_array = 0;

    VAR_3 = VAR_1->length;

    for (VAR_2 = 0; VAR_2 < VAR_3; VAR_2++) {
        if (njs_is_valid(&VAR_1->start[VAR_2])) {
            njs_uint32_to_string(&VAR_4, VAR_2);
            VAR_6 = njs_object_property_add(VAR_0, &VAR_5, &VAR_4, 0);
            if (njs_slow_path(VAR_6 == NULL)) {
                return VAR_8;
            }

            VAR_6->value = VAR_1->start[VAR_2];
        }
    }

    /* COMMENT_0 */

    njs_mp_free(VAR_0->mem_pool, VAR_1->start);
    VAR_1->start = NULL;

    return VAR_7;
}",nginx/njs/81af26364c21c196dd21fb5e14c7fa9ce7debd17/njs_array.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,6 +4,10 @@
     uint32_t           i, length;
     njs_value_t        index, value;
     njs_object_prop_t  *prop;
+
+    if (njs_slow_path(!array->object.fast_array)) {
+        return NJS_OK;
+    }
 
     njs_set_array(&value, array);
     array->object.fast_array = 0;","{'deleted_lines': [], 'added_lines': ['', '    if (njs_slow_path(!array->object.fast_array)) {', '        return NJS_OK;', '    }']}",True,Nginx NJS v0.7.2 was discovered to contain a segmentation violation in the function njs_array_convert_to_slow_array at src/njs_array.c.,5.5,MEDIUM,1,test,2022-05-07T01:55:07Z,4
CVE-2022-36012,['CWE-617'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,tensorflow,"[tfg][functiondef_import] Error on empty edge names

Return an error in the generic function importer if an edge name is empty.

PiperOrigin-RevId: 449953062",ad069af92392efee1418c48ff561fd3070a03d7b,https://github.com/tensorflow/tensorflow/commit/ad069af92392efee1418c48ff561fd3070a03d7b,tensorflow/core/ir/importexport/functiondef_import.cc,ImportGenericFunction,"Status ImportGenericFunction(
GraphFuncOp func_op, const FunctionDef& func,
llvm::StringMap<llvm::StringMap<SmallVector<Value, 1>>>& values_map,
OpBuilder& builder) {
const OpDef& signature = func.signature();
Location unknown_loc = builder.getUnknownLoc();
MLIRContext* context = builder.getContext();
TFGraphDialect* tfgDialect = cast<TFGraphDialect>(func_op->getDialect());
NamedAttrList attrs;
DictionaryAttr func_attrs = builder.getDictionaryAttr({});
if (signature.name().empty())
return InvalidArgument(""generic function without a name"");
attrs.append(""sym_name"", builder.getStringAttr(signature.name()));
attrs.append(""generic"", builder.getUnitAttr());
if (!signature.description().empty())
attrs.append(""description"", builder.getStringAttr(signature.description()));
if (signature.is_stateful())
attrs.append(""is_stateful"", builder.getUnitAttr());
if (signature.control_output_size()) {
SmallVector<Attribute> control_outputs;
for (const std::string& output : signature.control_output())
control_outputs.push_back(builder.getStringAttr(output));
attrs.append(""control_output"", builder.getArrayAttr(control_outputs));
}
{
NamedAttrList attr_defs;
for (const OpDef_AttrDef& attr : signature.attr()) {
NamedAttrList attr_def;
if (attr.name().empty())
return InvalidArgument(""Missing name for function attribute"");
if (!attr.type().empty())
attr_def.append(builder.getNamedAttr(
""function_type"", builder.getStringAttr(attr.type())));
if (attr.has_default_value()) {
TF_ASSIGN_OR_RETURN(
Attribute attr,
ConvertAttributeValue(attr.default_value(), builder, tfgDialect));
attr_def.append(builder.getNamedAttr(""default_value"", attr));
}
if (!attr.description().empty())
attr_def.append(builder.getNamedAttr(
""description"", builder.getStringAttr(attr.description())));
if (attr.has_minimum() || attr.minimum())
attr_def.append(builder.getNamedAttr(
""minimum"", builder.getI32IntegerAttr(attr.minimum())));
if (attr.has_allowed_values()) {
TF_ASSIGN_OR_RETURN(
Attribute attr,
ConvertAttributeValue(attr.allowed_values(), builder, tfgDialect));
attr_def.append(builder.getNamedAttr(""allowed_values"", attr));
}
attr_defs.append(builder.getNamedAttr(
attr.name(), attr_def.getDictionary(builder.getContext())));
}
if (!attr_defs.empty()) {
func_attrs = attr_defs.getDictionary(builder.getContext());
attrs.append(""tfg.func_attrs"", func_attrs);
}
}
if (func.resource_arg_unique_id_size()) {
SmallVector<int32_t> resource_arg_unique_ids_keys;
SmallVector<int32_t> resource_arg_unique_ids_values;
for (const auto& unique_id : func.resource_arg_unique_id()) {
resource_arg_unique_ids_keys.push_back(unique_id.first);
resource_arg_unique_ids_values.push_back(unique_id.second);
}
attrs.append(""resource_arg_unique_ids_keys"",
builder.getI32TensorAttr(resource_arg_unique_ids_keys));
attrs.append(""resource_arg_unique_ids_values"",
builder.getI32TensorAttr(resource_arg_unique_ids_values));
}
for (const auto& namedAttr : func.attr()) {
if (namedAttr.first.empty())
return InvalidArgument(""Invalid function attribute name"");
const std::string& name = ""tf."" + namedAttr.first;
const AttrValue& tf_attr = namedAttr.second;
TF_ASSIGN_OR_RETURN(Attribute attr,
ConvertAttributeValue(tf_attr, builder, tfgDialect));
attrs.append(name, attr);
}
SmallString<8> arg_or_res_attr_name;
SmallString<8> sub_arg_attr_name;
int arg_num = 0;
SmallVector<StringRef> arg_names;
SmallVector<Type> arg_types;
SmallVector<Attribute> args_attrs;
SmallVector<Attribute> res_attrs;
for (const auto& enumerated_input : llvm::enumerate(signature.input_arg())) {
const OpDef::ArgDef& input = enumerated_input.value();
TF_ASSIGN_OR_RETURN(NamedAttrList input_attrs,
ConvertArgDefAttributes(input, tfgDialect, builder));
auto it = func.arg_attr().find(enumerated_input.index());
if (it != func.arg_attr().end()) {
NamedAttrList arg_attr;
for (const auto& named_attr : it->second.attr()) {
TF_ASSIGN_OR_RETURN(
Attribute attr,
ConvertAttributeValue(named_attr.second, builder, tfgDialect));
arg_attr.append(named_attr.first, attr);
}
input_attrs.append(""tfg.arg_attrs"",
arg_attr.getDictionary(builder.getContext()));
}
arg_names.push_back(builder.getStringAttr(input.name()).getValue());
arg_types.push_back(OpaqueTensorType::get(context));
args_attrs.push_back(input_attrs.getDictionary(context));
args_attrs.push_back(NamedAttrList{}.getDictionary(context));
arg_num++;
}
attrs.push_back(
builder.getNamedAttr(function_interface_impl::getArgDictAttrName(),
builder.getArrayAttr(args_attrs)));
int res_num = 0;
for (const OpDef::ArgDef& output : signature.output_arg()) {
TF_ASSIGN_OR_RETURN(NamedAttrList output_attrs,
ConvertArgDefAttributes(output, tfgDialect, builder));
res_attrs.push_back(output_attrs.getDictionary(context));
++res_num;
}
for (const std::string& output : signature.control_output()) {
NamedAttrList output_attrs;
output_attrs.append(""tfg.name"", builder.getStringAttr(output));
res_attrs.push_back(output_attrs.getDictionary(context));
++res_num;
}
attrs.push_back(
builder.getNamedAttr(function_interface_impl::getResultDictAttrName(),
builder.getArrayAttr(res_attrs)));
values_map.clear();
Block* body = new Block();
func_op.body().push_back(body);
Type control_ty = ControlType::get(context);
for (auto type_and_name : llvm::zip(arg_types, arg_names)) {
Value arg = body->addArgument(std::get<0>(type_and_name), unknown_loc);
llvm::StringMap<SmallVector<Value, 1>>& values =
values_map[std::get<1>(type_and_name)];
Value ctl = body->addArgument(control_ty, unknown_loc);
values[""""].push_back(arg);
values[""^""].push_back(ctl);
}
OpBuilder body_builder = OpBuilder::atBlockEnd(body);
OperationName mlir_placeholder(""tfg.__mlir_placeholder"", context);
Type placeholder_ty = OpaqueTensorType::get(context);
ValueMapManager value_manager(values_map, body_builder, mlir_placeholder,
placeholder_ty, control_ty, unknown_loc);
TF_RETURN_WITH_CONTEXT_IF_ERROR(
ImportNodes(value_manager, func.node_def(), body_builder),
"" when importing function "", func.signature().name());
res_num = 0;
llvm::StringMap<int> output_name_to_position;
for (const OpDef::ArgDef& output : signature.output_arg()) {
if (output_name_to_position.count(output.name()))
return InvalidArgument(""Duplicated output_arg entry"", output.name());
output_name_to_position[output.name()] = res_num;
++res_num;
}
res_num = 0;
llvm::StringMap<int> control_output_to_position;
for (const std::string& output : signature.control_output()) {
if (control_output_to_position.count(output))
return InvalidArgument(""Duplicated control_output entry"", output);
control_output_to_position[output] = res_num;
++res_num;
}
SmallVector<Value> ret_vals(func.ret_size() + func.control_ret_size(),
Value());
for (const auto& ret_val : func.ret()) {
auto position = output_name_to_position.find(ret_val.first);
if (position == output_name_to_position.end())
return InvalidArgument(
""Can't import function, returned value references unknown output ""
""argument "",
ret_val.first);
ret_vals[position->second] =
value_manager.GetValueOrCreatePlaceholder(ret_val.second);
}
for (const auto& ret_val : func.control_ret()) {
auto position = control_output_to_position.find(ret_val.first);
if (position == control_output_to_position.end())
return InvalidArgument(
""Can't import function, returned value references unknown output ""
""argument "",
ret_val.first);
Value result = value_manager.GetValueOrCreatePlaceholder(
(Twine(""^"") + ret_val.second).str());
if (!result.getType().isa<ControlType>())
return InvalidArgument(""failed to map returned value "", ret_val.second,
"", isn't a control output"");
ret_vals[func.ret_size() + position->second] = result;
}
for (auto& indexed_val : llvm::enumerate(ret_vals)) {
if (indexed_val.value()) continue;
return InvalidArgument(
""Failed to import function, missing output for position "",
indexed_val.index());
}
MutableArrayRef<Value> operands = ret_vals;
ReturnOp ret_op = body_builder.create<ReturnOp>(
unknown_loc, operands.slice(0, func.ret_size()),
operands.slice(func.ret_size()));
{
SmallVector<Type> arg_types_with_ctl;
for (Type type : arg_types) {
arg_types_with_ctl.push_back(type);
arg_types_with_ctl.push_back(control_ty);
}
attrs.append(""function_type"",
TypeAttr::get(builder.getFunctionType(
arg_types_with_ctl, ret_op.getOperandTypes())));
}
func_op->setAttrs(attrs);
return Status::OK();
}","Status ImportGenericFunction(
GraphFuncOp VAR_0, const FunctionDef& VAR_1,
llvm::StringMap<llvm::StringMap<SmallVector<Value, 1>>>& VAR_2,
OpBuilder& VAR_3) {
const OpDef& VAR_4 = VAR_1.signature();
Location VAR_5 = VAR_3.getUnknownLoc();
MLIRContext* VAR_6 = VAR_3.getContext();
TFGraphDialect* VAR_7 = VAR_8<TFGraphDialect>(VAR_0->getDialect());
NamedAttrList VAR_9;
DictionaryAttr VAR_10 = VAR_3.getDictionaryAttr({});
if (VAR_4.name().empty())
return InvalidArgument(""generic function without a name"");
VAR_9.append(""sym_name"", VAR_3.getStringAttr(VAR_4.name()));
VAR_9.append(""generic"", VAR_3.getUnitAttr());
if (!VAR_4.description().empty())
VAR_9.append(""description"", VAR_3.getStringAttr(VAR_4.description()));
if (VAR_4.is_stateful())
VAR_9.append(""is_stateful"", VAR_3.getUnitAttr());
if (VAR_4.control_output_size()) {
SmallVector<Attribute> VAR_11;
for (const std::string& VAR_12 : VAR_4.control_output())
VAR_11.push_back(VAR_3.getStringAttr(VAR_12));
VAR_9.append(""control_output"", VAR_3.getArrayAttr(VAR_11));
}
{
NamedAttrList VAR_13;
for (const OpDef_AttrDef& VAR_14 : VAR_4.attr()) {
NamedAttrList VAR_15;
if (VAR_14.name().empty())
return InvalidArgument(""Missing name for function attribute"");
if (!VAR_14.type().empty())
VAR_15.append(VAR_3.getNamedAttr(
""function_type"", VAR_3.getStringAttr(VAR_14.type())));
if (VAR_14.has_default_value()) {
TF_ASSIGN_OR_RETURN(
Attribute VAR_14,
ConvertAttributeValue(attr.default_value(), builder, tfgDialect));
VAR_15.append(builder.getNamedAttr(""default_value"", attr));
}
if (!attr.description().empty())
VAR_15.append(builder.getNamedAttr(
""description"", builder.getStringAttr(attr.description())));
if (attr.has_minimum() || attr.minimum())
VAR_15.append(builder.getNamedAttr(
""minimum"", builder.getI32IntegerAttr(attr.minimum())));
if (attr.has_allowed_values()) {
TF_ASSIGN_OR_RETURN(
Attribute attr,
ConvertAttributeValue(attr.allowed_values(), builder, tfgDialect));
VAR_15.append(builder.getNamedAttr(""allowed_values"", attr));
}
VAR_13.append(builder.getNamedAttr(
attr.name(), VAR_15.getDictionary(builder.getContext())));
}
if (!VAR_13.empty()) {
VAR_10 = VAR_13.getDictionary(builder.getContext());
VAR_9.append(""tfg.func_attrs"", VAR_10);
}
}
if (VAR_1.resource_arg_unique_id_size()) {
SmallVector<int32_t> VAR_16;
SmallVector<int32_t> VAR_17;
for (const auto& VAR_18 : VAR_1.resource_arg_unique_id()) {
VAR_16.push_back(VAR_18.first);
VAR_17.push_back(VAR_18.second);
}
VAR_9.append(""resource_arg_unique_ids_keys"",
builder.getI32TensorAttr(VAR_16));
VAR_9.append(""resource_arg_unique_ids_values"",
builder.getI32TensorAttr(VAR_17));
}
for (const auto& VAR_19 : VAR_1.attr()) {
if (VAR_19.first.empty())
return InvalidArgument(""Invalid function attribute name"");
const std::string& VAR_20 = ""tf."" + VAR_19.first;
const AttrValue& VAR_21 = VAR_19.second;
TF_ASSIGN_OR_RETURN(Attribute attr,
ConvertAttributeValue(tf_attr, builder, tfgDialect));
VAR_9.append(VAR_20, attr);
}
SmallString<8> VAR_22;
SmallString<8> VAR_23;
int VAR_24 = 0;
SmallVector<StringRef> VAR_25;
SmallVector<Type> VAR_26;
SmallVector<Attribute> VAR_27;
SmallVector<Attribute> VAR_28;
for (const auto& VAR_29 : llvm::enumerate(VAR_4.input_arg())) {
const OpDef::ArgDef& VAR_30 = VAR_29.value();
TF_ASSIGN_OR_RETURN(NamedAttrList VAR_31,
ConvertArgDefAttributes(input, tfgDialect, builder));
auto VAR_32 = VAR_1.arg_attr().find(VAR_29.index());
if (VAR_32 != VAR_1.arg_attr().end()) {
NamedAttrList VAR_33;
for (const auto& VAR_34 : VAR_32->second.attr()) {
TF_ASSIGN_OR_RETURN(
Attribute attr,
ConvertAttributeValue(named_attr.VAR_35, builder, tfgDialect));
VAR_33.append(named_attr.first, attr);
}
VAR_31.append(""tfg.arg_attrs"",
VAR_33.getDictionary(builder.getContext()));
}
VAR_25.push_back(builder.getStringAttr(input.name()).getValue());
VAR_26.push_back(OpaqueTensorType::get(VAR_6));
VAR_27.push_back(VAR_31.getDictionary(VAR_6));
VAR_27.push_back(NamedAttrList{}.getDictionary(VAR_6));
VAR_24++;
}
VAR_9.push_back(
builder.getNamedAttr(function_interface_impl::getArgDictAttrName(),
builder.getArrayAttr(VAR_27)));
int VAR_36 = 0;
for (const OpDef::ArgDef& VAR_12 : VAR_4.output_arg()) {
TF_ASSIGN_OR_RETURN(NamedAttrList VAR_37,
ConvertArgDefAttributes(output, tfgDialect, builder));
VAR_28.push_back(VAR_37.getDictionary(VAR_6));
++VAR_36;
}
for (const std::string& output : VAR_4.control_output()) {
NamedAttrList VAR_37;
VAR_37.append(""tfg.name"", builder.getStringAttr(output));
VAR_28.push_back(VAR_37.getDictionary(VAR_6));
++VAR_36;
}
VAR_9.push_back(
builder.getNamedAttr(function_interface_impl::getResultDictAttrName(),
builder.getArrayAttr(VAR_28)));
VAR_2.clear();
Block* VAR_38 = new Block();
VAR_0.body().push_back(VAR_38);
Type VAR_39 = ControlType::get(VAR_6);
for (auto VAR_40 : llvm::zip(VAR_26, VAR_25)) {
Value VAR_41 = VAR_38->addArgument(std::VAR_42<0>(VAR_40), VAR_5);
llvm::StringMap<SmallVector<Value, 1>>& VAR_43 =
VAR_2[std::VAR_42<1>(VAR_40)];
Value VAR_44 = VAR_38->addArgument(VAR_39, VAR_5);
VAR_43[""""].push_back(VAR_41);
VAR_43[""^""].push_back(VAR_44);
}
OpBuilder VAR_45 = OpBuilder::atBlockEnd(VAR_38);
OperationName VAR_46(""tfg.__mlir_placeholder"", VAR_6);
Type VAR_47 = OpaqueTensorType::get(VAR_6);
ValueMapManager value_manager(values_map, body_builder, mlir_placeholder,
placeholder_ty, control_ty, unknown_loc);
TF_RETURN_WITH_CONTEXT_IF_ERROR(
ImportNodes(VAR_48, VAR_1.node_def(), body_builder),
"" when importing function "", VAR_1.signature().name());
VAR_36 = 0;
llvm::StringMap<int> VAR_49;
for (const OpDef::ArgDef& output : VAR_4.output_arg()) {
if (VAR_49.count(output.name()))
return InvalidArgument(""Duplicated output_arg entry"", output.name());
VAR_49[output.name()] = VAR_36;
++VAR_36;
}
VAR_36 = 0;
llvm::StringMap<int> VAR_50;
for (const std::string& output : VAR_4.control_output()) {
if (VAR_50.count(output))
return InvalidArgument(""Duplicated control_output entry"", output);
VAR_50[output] = VAR_36;
++VAR_36;
}
SmallVector<Value> VAR_51(VAR_1.ret_size() + VAR_1.control_ret_size(),
Value());
for (const auto& VAR_52 : VAR_1.ret()) {
auto VAR_53 = VAR_49.find(VAR_52.first);
if (VAR_53 == VAR_49.end())
return InvalidArgument(
""Can't import function, returned value references unknown output ""
""argument "",
VAR_52.first);
VAR_51[VAR_53->second] =
VAR_48.GetValueOrCreatePlaceholder(VAR_52.second);
}
for (const auto& VAR_52 : VAR_1.control_ret()) {
auto VAR_53 = VAR_50.find(VAR_52.first);
if (VAR_53 == VAR_50.end())
return InvalidArgument(
""Can't import function, returned value references unknown output ""
""argument "",
VAR_52.first);
Value VAR_54 = VAR_48.GetValueOrCreatePlaceholder(
(Twine(""^"") + VAR_52.second).str());
if (!VAR_54.getType().isa<ControlType>())
return InvalidArgument(""failed to map returned value "", VAR_52.second,
"", isn't a control output"");
VAR_51[VAR_1.ret_size() + VAR_53->second] = VAR_54;
}
for (auto& VAR_55 : llvm::enumerate(VAR_51)) {
if (VAR_55.value()) continue;
return InvalidArgument(
""Failed to import function, missing output for position "",
VAR_55.index());
}
MutableArrayRef<Value> VAR_56 = VAR_51;
ReturnOp VAR_57 = body_builder.create<ReturnOp>(
unknown_loc, VAR_56.slice(0, VAR_1.ret_size()),
VAR_56.slice(VAR_1.ret_size()));
{
SmallVector<Type> VAR_58;
for (Type VAR_59 : VAR_26) {
VAR_58.push_back(VAR_59);
VAR_58.push_back(control_ty);
}
VAR_9.append(""function_type"",
TypeAttr::get(builder.getFunctionType(
VAR_58, VAR_57.getOperandTypes())));
}
VAR_0->setAttrs(VAR_9);
return Status::OK();
}",tensorflow/ad069af92392efee1418c48ff561fd3070a03d7b/functiondef_import.cc/vul/before/0.json,"Status ImportGenericFunction(
    GraphFuncOp func_op, const FunctionDef& func,
    llvm::StringMap<llvm::StringMap<SmallVector<Value, 1>>>& values_map,
    OpBuilder& builder) {
  const OpDef& signature = func.signature();
  Location unknown_loc = builder.getUnknownLoc();
  MLIRContext* context = builder.getContext();

  TFGraphDialect* tfgDialect = cast<TFGraphDialect>(func_op->getDialect());
  NamedAttrList attrs;
  DictionaryAttr func_attrs = builder.getDictionaryAttr({});
  if (signature.name().empty())
    return InvalidArgument(""generic function without a name"");
  attrs.append(""sym_name"", builder.getStringAttr(signature.name()));
  attrs.append(""generic"", builder.getUnitAttr());
  if (!signature.description().empty())
    attrs.append(""description"", builder.getStringAttr(signature.description()));
  if (signature.is_stateful())
    attrs.append(""is_stateful"", builder.getUnitAttr());
  if (signature.control_output_size()) {
    SmallVector<Attribute> control_outputs;
    for (const std::string& output : signature.control_output())
      control_outputs.push_back(builder.getStringAttr(output));
    attrs.append(""control_output"", builder.getArrayAttr(control_outputs));
  }
  {
    NamedAttrList attr_defs;
    for (const OpDef_AttrDef& attr : signature.attr()) {
      NamedAttrList attr_def;
      if (attr.name().empty())
        return InvalidArgument(""Missing name for function attribute"");
      if (!attr.type().empty())
        attr_def.append(builder.getNamedAttr(
            ""function_type"", builder.getStringAttr(attr.type())));
      if (attr.has_default_value()) {
        TF_ASSIGN_OR_RETURN(
            Attribute attr,
            ConvertAttributeValue(attr.default_value(), builder, tfgDialect));
        attr_def.append(builder.getNamedAttr(""default_value"", attr));
      }
      if (!attr.description().empty())
        attr_def.append(builder.getNamedAttr(
            ""description"", builder.getStringAttr(attr.description())));
      if (attr.has_minimum() || attr.minimum())
        attr_def.append(builder.getNamedAttr(
            ""minimum"", builder.getI32IntegerAttr(attr.minimum())));
      if (attr.has_allowed_values()) {
        TF_ASSIGN_OR_RETURN(
            Attribute attr,
            ConvertAttributeValue(attr.allowed_values(), builder, tfgDialect));
        attr_def.append(builder.getNamedAttr(""allowed_values"", attr));
      }
      attr_defs.append(builder.getNamedAttr(
          attr.name(), attr_def.getDictionary(builder.getContext())));
    }
    if (!attr_defs.empty()) {
      func_attrs = attr_defs.getDictionary(builder.getContext());
      attrs.append(""tfg.func_attrs"", func_attrs);
    }
  }

  // The resource_arg_unique_id is a list of `pair<int, int>`, we import it
  // as two arrays of integer right now.
  if (func.resource_arg_unique_id_size()) {
    SmallVector<int32_t> resource_arg_unique_ids_keys;
    SmallVector<int32_t> resource_arg_unique_ids_values;
    for (const auto& unique_id : func.resource_arg_unique_id()) {
      resource_arg_unique_ids_keys.push_back(unique_id.first);
      resource_arg_unique_ids_values.push_back(unique_id.second);
    }
    attrs.append(""resource_arg_unique_ids_keys"",
                 builder.getI32TensorAttr(resource_arg_unique_ids_keys));
    attrs.append(""resource_arg_unique_ids_values"",
                 builder.getI32TensorAttr(resource_arg_unique_ids_values));
  }

  // Import the function attributes with a `tf.` prefix to match the current
  // infrastructure expectations.
  for (const auto& namedAttr : func.attr()) {
    if (namedAttr.first.empty())
      return InvalidArgument(""Invalid function attribute name"");
    const std::string& name = ""tf."" + namedAttr.first;
    const AttrValue& tf_attr = namedAttr.second;
    TF_ASSIGN_OR_RETURN(Attribute attr,
                        ConvertAttributeValue(tf_attr, builder, tfgDialect));
    attrs.append(name, attr);
  }
  SmallString<8> arg_or_res_attr_name;
  SmallString<8> sub_arg_attr_name;
  // Iterate of the input in the signature. Each input will correspond to
  // potentially multiple arguments because of how the OpDef allows repeated
  // arguments controlled by `number_attr` for example.
  // We populate the `arg_names` vector with the name of each input at each
  // position, and `arg_types` with the matching type.
  int arg_num = 0;
  SmallVector<StringRef> arg_names;
  SmallVector<Type> arg_types;
  SmallVector<Attribute> args_attrs;
  SmallVector<Attribute> res_attrs;
  for (const auto& enumerated_input : llvm::enumerate(signature.input_arg())) {
    const OpDef::ArgDef& input = enumerated_input.value();
    TF_ASSIGN_OR_RETURN(NamedAttrList input_attrs,
                        ConvertArgDefAttributes(input, tfgDialect, builder));
    auto it = func.arg_attr().find(enumerated_input.index());
    if (it != func.arg_attr().end()) {
      NamedAttrList arg_attr;
      for (const auto& named_attr : it->second.attr()) {
        TF_ASSIGN_OR_RETURN(
            Attribute attr,
            ConvertAttributeValue(named_attr.second, builder, tfgDialect));
        arg_attr.append(named_attr.first, attr);
      }
      input_attrs.append(""tfg.arg_attrs"",
                         arg_attr.getDictionary(builder.getContext()));
    }
    arg_names.push_back(builder.getStringAttr(input.name()).getValue());
    arg_types.push_back(OpaqueTensorType::get(context));
    args_attrs.push_back(input_attrs.getDictionary(context));
    args_attrs.push_back(NamedAttrList{}.getDictionary(context));
    arg_num++;
  }
  attrs.push_back(
      builder.getNamedAttr(function_interface_impl::getArgDictAttrName(),
                           builder.getArrayAttr(args_attrs)));

  // Process the results attributes now.
  int res_num = 0;
  for (const OpDef::ArgDef& output : signature.output_arg()) {
    TF_ASSIGN_OR_RETURN(NamedAttrList output_attrs,
                        ConvertArgDefAttributes(output, tfgDialect, builder));
    res_attrs.push_back(output_attrs.getDictionary(context));
    ++res_num;
  }
  // Process the control output metadata and store them as attributes.
  for (const std::string& output : signature.control_output()) {
    NamedAttrList output_attrs;
    output_attrs.append(""tfg.name"", builder.getStringAttr(output));
    res_attrs.push_back(output_attrs.getDictionary(context));
    ++res_num;
  }
  attrs.push_back(
      builder.getNamedAttr(function_interface_impl::getResultDictAttrName(),
                           builder.getArrayAttr(res_attrs)));

  values_map.clear();
  Block* body = new Block();
  func_op.body().push_back(body);
  Type control_ty = ControlType::get(context);
  // Create the block arguments and populate the `values_map` with the matching
  // input names.
  for (auto type_and_name : llvm::zip(arg_types, arg_names)) {
    Value arg = body->addArgument(std::get<0>(type_and_name), unknown_loc);
    llvm::StringMap<SmallVector<Value, 1>>& values =
        values_map[std::get<1>(type_and_name)];
    Value ctl = body->addArgument(control_ty, unknown_loc);
    values[""""].push_back(arg);
    values[""^""].push_back(ctl);
  }

  // Pre-populate the nodes_map with the needed slots for the return.
  OpBuilder body_builder = OpBuilder::atBlockEnd(body);
  // We use placeholders during the import to create ""fake"" operations to break
  // cycles: we need operands to feed to the users.
  OperationName mlir_placeholder(""tfg.__mlir_placeholder"", context);
  Type placeholder_ty = OpaqueTensorType::get(context);
  ValueMapManager value_manager(values_map, body_builder, mlir_placeholder,
                                placeholder_ty, control_ty, unknown_loc);

  // Import the function body here, after this we have a function with all
  // the nodes, and the nodes_map contains the mapping from node_name to actual
  // MLIR Operations.
  TF_RETURN_WITH_CONTEXT_IF_ERROR(
      ImportNodes(value_manager, func.node_def(), body_builder),
      "" when importing function "", func.signature().name());

  // After the body, the final part is to setup the return. It comes in two
  // parts: the `ret` field from the FunctionDef for the regular output and the
  // `control_ret` field for the control output.
  //
  // Because `ret` and `control_ret` aren't ordered, there is an indirection to
  // the FunctionDef signature to retrieve the position of each `ret` and
  // `control_ret` entry by name. We compute this mapping from the name of an
  // output to the position in the result array first.
  res_num = 0;
  llvm::StringMap<int> output_name_to_position;
  for (const OpDef::ArgDef& output : signature.output_arg()) {
    if (output_name_to_position.count(output.name()))
      return InvalidArgument(""Duplicated output_arg entry"", output.name());
    output_name_to_position[output.name()] = res_num;
    ++res_num;
  }
  res_num = 0;
  llvm::StringMap<int> control_output_to_position;
  for (const std::string& output : signature.control_output()) {
    if (control_output_to_position.count(output))
      return InvalidArgument(""Duplicated control_output entry"", output);
    control_output_to_position[output] = res_num;
    ++res_num;
  }

  // We pre-allocate the array of operands and populate it using the
  // `output_name_to_position` and `control_output_to_position` populated
  // previously.
  SmallVector<Value> ret_vals(func.ret_size() + func.control_ret_size(),
                              Value());
  for (const auto& ret_val : func.ret()) {
    auto position = output_name_to_position.find(ret_val.first);
    if (position == output_name_to_position.end()) {
      return InvalidArgument(
          ""Can't import function, returned value references unknown output ""
          ""argument "",
          ret_val.first);
    }
    if (ret_val.second.empty()) {
      return InvalidArgument(""Function '"", func.signature().name(),
                             ""' has empty result name"");
    }
    ret_vals[position->second] =
        value_manager.GetValueOrCreatePlaceholder(ret_val.second);
  }
  for (const auto& ret_val : func.control_ret()) {
    auto position = control_output_to_position.find(ret_val.first);
    if (position == control_output_to_position.end()) {
      return InvalidArgument(
          ""Can't import function, returned value references unknown output ""
          ""argument "",
          ret_val.first);
    }
    if (ret_val.second.empty()) {
      return InvalidArgument(""Function '"", func.signature().name(),
                             ""' has empty control result name"");
    }
    Value result = value_manager.GetValueOrCreatePlaceholder(
        (Twine(""^"") + ret_val.second).str());
    if (!result.getType().isa<ControlType>())
      return InvalidArgument(""failed to map returned value "", ret_val.second,
                             "", isn't a control output"");
    ret_vals[func.ret_size() + position->second] = result;
  }
  // Check that all the of the return operands have been populated.
  for (auto& indexed_val : llvm::enumerate(ret_vals)) {
    if (indexed_val.value()) continue;
    return InvalidArgument(
        ""Failed to import function, missing output for position "",
        indexed_val.index());
  }
  MutableArrayRef<Value> operands = ret_vals;
  ReturnOp ret_op = body_builder.create<ReturnOp>(
      unknown_loc, operands.slice(0, func.ret_size()),
      operands.slice(func.ret_size()));

  // Now that we have all the types, set the function signature as the
  // ""function_type"" attribute.
  {
    SmallVector<Type> arg_types_with_ctl;
    for (Type type : arg_types) {
      arg_types_with_ctl.push_back(type);
      arg_types_with_ctl.push_back(control_ty);
    }
    attrs.append(""function_type"",
                 TypeAttr::get(builder.getFunctionType(
                     arg_types_with_ctl, ret_op.getOperandTypes())));
  }
  func_op->setAttrs(attrs);
  return Status::OK();
}","Status ImportGenericFunction(
    GraphFuncOp VAR_0, const FunctionDef& VAR_1,
    llvm::StringMap<llvm::StringMap<SmallVector<Value, 1>>>& VAR_2,
    OpBuilder& VAR_3) {
  const OpDef& VAR_4 = VAR_1.signature();
  Location VAR_5 = VAR_3.getUnknownLoc();
  MLIRContext* VAR_6 = VAR_3.getContext();

  TFGraphDialect* VAR_7 = VAR_8<TFGraphDialect>(VAR_0->getDialect());
  NamedAttrList VAR_9;
  DictionaryAttr VAR_10 = VAR_3.getDictionaryAttr({});
  if (VAR_4.name().empty())
    return InvalidArgument(""generic function without a name"");
  VAR_9.append(""sym_name"", VAR_3.getStringAttr(VAR_4.name()));
  VAR_9.append(""generic"", VAR_3.getUnitAttr());
  if (!VAR_4.description().empty())
    VAR_9.append(""description"", VAR_3.getStringAttr(VAR_4.description()));
  if (VAR_4.is_stateful())
    VAR_9.append(""is_stateful"", VAR_3.getUnitAttr());
  if (VAR_4.control_output_size()) {
    SmallVector<Attribute> VAR_11;
    for (const std::string& VAR_12 : VAR_4.control_output())
      VAR_11.push_back(VAR_3.getStringAttr(VAR_12));
    VAR_9.append(""control_output"", VAR_3.getArrayAttr(VAR_11));
  }
  {
    NamedAttrList VAR_13;
    for (const OpDef_AttrDef& VAR_14 : VAR_4.attr()) {
      NamedAttrList VAR_15;
      if (VAR_14.name().empty())
        return InvalidArgument(""Missing name for function attribute"");
      if (!VAR_14.type().empty())
        VAR_15.append(VAR_3.getNamedAttr(
            ""function_type"", VAR_3.getStringAttr(VAR_14.type())));
      if (VAR_14.has_default_value()) {
        TF_ASSIGN_OR_RETURN(
            Attribute VAR_14,
            ConvertAttributeValue(attr.default_value(), builder, tfgDialect));
        VAR_15.append(builder.getNamedAttr(""default_value"", attr));
      }
      if (!attr.description().empty())
        VAR_15.append(builder.getNamedAttr(
            ""description"", builder.getStringAttr(attr.description())));
      if (attr.has_minimum() || attr.minimum())
        VAR_15.append(builder.getNamedAttr(
            ""minimum"", builder.getI32IntegerAttr(attr.minimum())));
      if (attr.has_allowed_values()) {
        TF_ASSIGN_OR_RETURN(
            Attribute attr,
            ConvertAttributeValue(attr.allowed_values(), builder, tfgDialect));
        VAR_15.append(builder.getNamedAttr(""allowed_values"", attr));
      }
      VAR_13.append(builder.getNamedAttr(
          attr.name(), VAR_15.getDictionary(builder.getContext())));
    }
    if (!VAR_13.empty()) {
      VAR_10 = VAR_13.getDictionary(builder.getContext());
      VAR_9.append(""tfg.func_attrs"", VAR_10);
    }
  }

  /* COMMENT_0 */
  /* COMMENT_1 */
  if (VAR_1.resource_arg_unique_id_size()) {
    SmallVector<int32_t> VAR_16;
    SmallVector<int32_t> VAR_17;
    for (const auto& VAR_18 : VAR_1.resource_arg_unique_id()) {
      VAR_16.push_back(VAR_18.first);
      VAR_17.push_back(VAR_18.second);
    }
    VAR_9.append(""resource_arg_unique_ids_keys"",
                 builder.getI32TensorAttr(VAR_16));
    VAR_9.append(""resource_arg_unique_ids_values"",
                 builder.getI32TensorAttr(VAR_17));
  }

  /* COMMENT_2 */
  /* COMMENT_3 */
  for (const auto& VAR_19 : VAR_1.attr()) {
    if (VAR_19.first.empty())
      return InvalidArgument(""Invalid function attribute name"");
    const std::string& VAR_20 = ""tf."" + VAR_19.first;
    const AttrValue& VAR_21 = VAR_19.second;
    TF_ASSIGN_OR_RETURN(Attribute attr,
                        ConvertAttributeValue(tf_attr, builder, tfgDialect));
    VAR_9.append(VAR_20, attr);
  }
  SmallString<8> VAR_22;
  SmallString<8> VAR_23;
  /* COMMENT_4 */
  /* COMMENT_5 */
  /* COMMENT_6 */
  /* COMMENT_7 */
  /* COMMENT_8 */
  int VAR_24 = 0;
  SmallVector<StringRef> VAR_25;
  SmallVector<Type> VAR_26;
  SmallVector<Attribute> VAR_27;
  SmallVector<Attribute> VAR_28;
  for (const auto& VAR_29 : llvm::enumerate(VAR_4.input_arg())) {
    const OpDef::ArgDef& VAR_30 = VAR_29.value();
    TF_ASSIGN_OR_RETURN(NamedAttrList VAR_31,
                        ConvertArgDefAttributes(input, tfgDialect, builder));
    auto VAR_32 = VAR_1.arg_attr().find(VAR_29.index());
    if (VAR_32 != VAR_1.arg_attr().end()) {
      NamedAttrList VAR_33;
      for (const auto& VAR_34 : VAR_32->second.attr()) {
        TF_ASSIGN_OR_RETURN(
            Attribute attr,
            ConvertAttributeValue(named_attr.VAR_35, builder, tfgDialect));
        VAR_33.append(named_attr.first, attr);
      }
      VAR_31.append(""tfg.arg_attrs"",
                         VAR_33.getDictionary(builder.getContext()));
    }
    VAR_25.push_back(builder.getStringAttr(input.name()).getValue());
    VAR_26.push_back(OpaqueTensorType::get(VAR_6));
    VAR_27.push_back(VAR_31.getDictionary(VAR_6));
    VAR_27.push_back(NamedAttrList{}.getDictionary(VAR_6));
    VAR_24++;
  }
  VAR_9.push_back(
      builder.getNamedAttr(function_interface_impl::getArgDictAttrName(),
                           builder.getArrayAttr(VAR_27)));

  /* COMMENT_9 */
  int VAR_36 = 0;
  for (const OpDef::ArgDef& VAR_12 : VAR_4.output_arg()) {
    TF_ASSIGN_OR_RETURN(NamedAttrList VAR_37,
                        ConvertArgDefAttributes(output, tfgDialect, builder));
    VAR_28.push_back(VAR_37.getDictionary(VAR_6));
    ++VAR_36;
  }
  /* COMMENT_10 */
  for (const std::string& output : VAR_4.control_output()) {
    NamedAttrList VAR_37;
    VAR_37.append(""tfg.name"", builder.getStringAttr(output));
    VAR_28.push_back(VAR_37.getDictionary(VAR_6));
    ++VAR_36;
  }
  VAR_9.push_back(
      builder.getNamedAttr(function_interface_impl::getResultDictAttrName(),
                           builder.getArrayAttr(VAR_28)));

  VAR_2.clear();
  Block* VAR_38 = new Block();
  VAR_0.body().push_back(VAR_38);
  Type VAR_39 = ControlType::get(VAR_6);
  /* COMMENT_11 */
  /* COMMENT_12 */
  for (auto VAR_40 : llvm::zip(VAR_26, VAR_25)) {
    Value VAR_41 = VAR_38->addArgument(std::VAR_42<0>(VAR_40), VAR_5);
    llvm::StringMap<SmallVector<Value, 1>>& VAR_43 =
        VAR_2[std::VAR_42<1>(VAR_40)];
    Value VAR_44 = VAR_38->addArgument(VAR_39, VAR_5);
    VAR_43[""""].push_back(VAR_41);
    VAR_43[""^""].push_back(VAR_44);
  }

  /* COMMENT_13 */
  OpBuilder VAR_45 = OpBuilder::atBlockEnd(VAR_38);
  /* COMMENT_14 */
  /* COMMENT_15 */
  OperationName VAR_46(""tfg.__mlir_placeholder"", VAR_6);
  Type VAR_47 = OpaqueTensorType::get(VAR_6);
  ValueMapManager value_manager(values_map, body_builder, mlir_placeholder,
                                placeholder_ty, control_ty, unknown_loc);

  /* COMMENT_16 */
  /* COMMENT_17 */
  /* COMMENT_18 */
  TF_RETURN_WITH_CONTEXT_IF_ERROR(
      ImportNodes(VAR_48, VAR_1.node_def(), body_builder),
      "" when importing function "", VAR_1.signature().name());

  /* COMMENT_19 */
  /* COMMENT_20 */
  /* COMMENT_21 */
  /* COMMENT_22 */
  /* COMMENT_23 */
  /* COMMENT_24 */
  /* COMMENT_25 */
  /* COMMENT_26 */
  VAR_36 = 0;
  llvm::StringMap<int> VAR_49;
  for (const OpDef::ArgDef& output : VAR_4.output_arg()) {
    if (VAR_49.count(output.name()))
      return InvalidArgument(""Duplicated output_arg entry"", output.name());
    VAR_49[output.name()] = VAR_36;
    ++VAR_36;
  }
  VAR_36 = 0;
  llvm::StringMap<int> VAR_50;
  for (const std::string& output : VAR_4.control_output()) {
    if (VAR_50.count(output))
      return InvalidArgument(""Duplicated control_output entry"", output);
    VAR_50[output] = VAR_36;
    ++VAR_36;
  }

  /* COMMENT_27 */
  /* COMMENT_28 */
  /* COMMENT_29 */
  SmallVector<Value> VAR_51(VAR_1.ret_size() + VAR_1.control_ret_size(),
                              Value());
  for (const auto& VAR_52 : VAR_1.ret()) {
    auto VAR_53 = VAR_49.find(VAR_52.first);
    if (VAR_53 == VAR_49.end()) {
      return InvalidArgument(
          ""Can't import function, returned value references unknown output ""
          ""argument "",
          VAR_52.first);
    }
    if (VAR_52.second.empty()) {
      return InvalidArgument(""Function '"", VAR_1.signature().name(),
                             ""' has empty result name"");
    }
    VAR_51[VAR_53->second] =
        VAR_48.GetValueOrCreatePlaceholder(VAR_52.second);
  }
  for (const auto& VAR_52 : VAR_1.control_ret()) {
    auto VAR_53 = VAR_50.find(VAR_52.first);
    if (VAR_53 == VAR_50.end()) {
      return InvalidArgument(
          ""Can't import function, returned value references unknown output ""
          ""argument "",
          VAR_52.first);
    }
    if (VAR_52.second.empty()) {
      return InvalidArgument(""Function '"", VAR_1.signature().name(),
                             ""' has empty control result name"");
    }
    Value VAR_54 = VAR_48.GetValueOrCreatePlaceholder(
        (Twine(""^"") + VAR_52.second).str());
    if (!VAR_54.getType().isa<ControlType>())
      return InvalidArgument(""failed to map returned value "", VAR_52.second,
                             "", isn't a control output"");
    VAR_51[VAR_1.ret_size() + VAR_53->second] = VAR_54;
  }
  /* COMMENT_30 */
  for (auto& VAR_55 : llvm::enumerate(VAR_51)) {
    if (VAR_55.value()) continue;
    return InvalidArgument(
        ""Failed to import function, missing output for position "",
        VAR_55.index());
  }
  MutableArrayRef<Value> VAR_56 = VAR_51;
  ReturnOp VAR_57 = body_builder.create<ReturnOp>(
      unknown_loc, VAR_56.slice(0, VAR_1.ret_size()),
      VAR_56.slice(VAR_1.ret_size()));

  /* COMMENT_31 */
  /* COMMENT_32 */
  {
    SmallVector<Type> VAR_58;
    for (Type VAR_59 : VAR_26) {
      VAR_58.push_back(VAR_59);
      VAR_58.push_back(control_ty);
    }
    VAR_9.append(""function_type"",
                 TypeAttr::get(builder.getFunctionType(
                     VAR_58, VAR_57.getOperandTypes())));
  }
  VAR_0->setAttrs(VAR_9);
  return Status::OK();
}",tensorflow/ad069af92392efee1418c48ff561fd3070a03d7b/functiondef_import.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -205,21 +205,31 @@
                               Value());
   for (const auto& ret_val : func.ret()) {
     auto position = output_name_to_position.find(ret_val.first);
-    if (position == output_name_to_position.end())
+    if (position == output_name_to_position.end()) {
       return InvalidArgument(
           ""Can't import function, returned value references unknown output ""
           ""argument "",
           ret_val.first);
+    }
+    if (ret_val.second.empty()) {
+      return InvalidArgument(""Function '"", func.signature().name(),
+                             ""' has empty result name"");
+    }
     ret_vals[position->second] =
         value_manager.GetValueOrCreatePlaceholder(ret_val.second);
   }
   for (const auto& ret_val : func.control_ret()) {
     auto position = control_output_to_position.find(ret_val.first);
-    if (position == control_output_to_position.end())
+    if (position == control_output_to_position.end()) {
       return InvalidArgument(
           ""Can't import function, returned value references unknown output ""
           ""argument "",
           ret_val.first);
+    }
+    if (ret_val.second.empty()) {
+      return InvalidArgument(""Function '"", func.signature().name(),
+                             ""' has empty control result name"");
+    }
     Value result = value_manager.GetValueOrCreatePlaceholder(
         (Twine(""^"") + ret_val.second).str());
     if (!result.getType().isa<ControlType>())","{'deleted_lines': ['    if (position == output_name_to_position.end())', '    if (position == control_output_to_position.end())'], 'added_lines': ['    if (position == output_name_to_position.end()) {', '    }', '    if (ret_val.second.empty()) {', '      return InvalidArgument(""Function \'"", func.signature().name(),', '                             ""\' has empty result name"");', '    }', '    if (position == control_output_to_position.end()) {', '    }', '    if (ret_val.second.empty()) {', '      return InvalidArgument(""Function \'"", func.signature().name(),', '                             ""\' has empty control result name"");', '    }']}",True,"TensorFlow is an open source platform for machine learning. When `mlir::tfg::ConvertGenericFunctionToFunctionDef` is given empty function attributes, it crashes. We have patched the issue in GitHub commit ad069af92392efee1418c48ff561fd3070a03d7b. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.",5.9,MEDIUM,1,test,2022-05-20T11:04:05Z,4
CVE-2022-36012,['CWE-617'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,tensorflow,"[tfg][functiondef_import] Error on empty edge names

Return an error in the generic function importer if an edge name is empty.

PiperOrigin-RevId: 449953062",ad069af92392efee1418c48ff561fd3070a03d7b,https://github.com/tensorflow/tensorflow/commit/ad069af92392efee1418c48ff561fd3070a03d7b,tensorflow/core/ir/importexport/functiondef_import.cc,ImportNodes,"Status ImportNodes(ValueMapManager value_manager,
const RepeatedPtrField<NodeDef>& nodes, OpBuilder& builder) {
Location unknown_loc = builder.getUnknownLoc();
MLIRContext* context = builder.getContext();
Type placeholder_ty = OpaqueTensorType::get(context);
Type control_ty = ControlType::get(context);
TFGraphDialect* tfgDialect =
cast<TFGraphDialect>(context->getLoadedDialect(""tfg""));
StringAttr device_attr = tfgDialect->getDeviceAttrIdentifier();
StringAttr name_attr = tfgDialect->getNameAttrIdentifier();
StringAttr fulltype_attr = tfgDialect->getFullTypeAttrIdentifier();
for (const NodeDef& node : nodes) {
DVLOG(1) << ""Processing node "" << node.name() << ""\n"";
if (node.op().empty()) return InvalidArgument(""empty op type"");
OperationState state(unknown_loc, absl::StrCat(""tfg."", node.op()));
for (const std::string& input : node.input())
state.operands.push_back(
value_manager.GetValueOrCreatePlaceholder(input));
state.types.push_back(placeholder_ty);
state.types.push_back(control_ty);
for (const auto& namedAttr : node.attr()) {
const std::string& name = namedAttr.first;
const AttrValue& tf_attr = namedAttr.second;
TF_ASSIGN_OR_RETURN(Attribute attr,
ConvertAttributeValue(tf_attr, builder, tfgDialect));
state.addAttribute(name, attr);
}
if (!node.device().empty())
state.addAttribute(device_attr, StringAttr::get(context, node.device()));
if (!node.name().empty())
state.addAttribute(name_attr, StringAttr::get(context, node.name()));
if (node.has_experimental_type()) {
TF_ASSIGN_OR_RETURN(
tf_type::FullTypeAttr type,
ConvertAttribute(node.experimental_type(), builder, tfgDialect));
state.addAttribute(fulltype_attr, type);
}
Operation* op = builder.create(state);
StringRef node_name = node.name();
{
size_t colon_sep = node_name.find_first_of(':');
if (colon_sep != StringRef::npos)
node_name = node_name.take_front(colon_sep);
}
TF_RETURN_IF_ERROR(value_manager.DefineOperation(op, node_name));
}
for (Operation& op : *builder.getInsertionBlock()) {
if (op.getName().getStringRef() == ""tfg.__mlir_placeholder"") {
return InvalidArgument(absl::StrCat(
""Couldn't import graph: placeholder left "",
op.getAttrOfType<StringAttr>(name_attr).getValue().str()));
}
}
return Status::OK();
}","Status ImportNodes(ValueMapManager VAR_0,
const RepeatedPtrField<NodeDef>& VAR_1, OpBuilder& VAR_2) {
Location VAR_3 = VAR_2.getUnknownLoc();
MLIRContext* VAR_4 = VAR_2.getContext();
Type VAR_5 = OpaqueTensorType::get(VAR_4);
Type VAR_6 = ControlType::get(VAR_4);
TFGraphDialect* VAR_7 =
VAR_8<TFGraphDialect>(VAR_4->getLoadedDialect(""tfg""));
StringAttr VAR_9 = VAR_7->getDeviceAttrIdentifier();
StringAttr VAR_10 = VAR_7->getNameAttrIdentifier();
StringAttr VAR_11 = VAR_7->getFullTypeAttrIdentifier();
for (const NodeDef& VAR_12 : VAR_1) {
DVLOG(1) << ""Processing node "" << VAR_12.name() << ""\n"";
if (VAR_12.op().empty()) return InvalidArgument(""empty op type"");
OperationState VAR_13(VAR_3, absl::StrCat(""tfg."", VAR_12.op()));
for (const std::string& VAR_14 : VAR_12.input())
VAR_13.operands.push_back(
VAR_0.GetValueOrCreatePlaceholder(VAR_14));
VAR_13.types.push_back(VAR_5);
VAR_13.types.push_back(VAR_6);
for (const auto& VAR_15 : VAR_12.attr()) {
const std::string& VAR_16 = VAR_15.first;
const AttrValue& VAR_17 = VAR_15.second;
TF_ASSIGN_OR_RETURN(Attribute VAR_18,
ConvertAttributeValue(tf_attr, builder, tfgDialect));
VAR_13.addAttribute(VAR_16, VAR_18);
}
if (!VAR_12.device().empty())
VAR_13.addAttribute(VAR_9, StringAttr::get(VAR_4, VAR_12.device()));
if (!VAR_12.name().empty())
VAR_13.addAttribute(VAR_10, StringAttr::get(VAR_4, VAR_12.name()));
if (VAR_12.has_experimental_type()) {
TF_ASSIGN_OR_RETURN(
tf_type::FullTypeAttr VAR_19,
ConvertAttribute(node.experimental_type(), builder, tfgDialect));
VAR_13.addAttribute(VAR_11, VAR_19);
}
Operation* VAR_20 = builder.create(VAR_13);
StringRef VAR_21 = node.name();
{
size_t VAR_22 = VAR_21.find_first_of(':');
if (VAR_22 != StringRef::npos)
VAR_21 = VAR_21.take_front(VAR_22);
}
TF_RETURN_IF_ERROR(VAR_0.DefineOperation(VAR_20, VAR_21));
}
for (Operation& VAR_20 : *builder.getInsertionBlock()) {
if (VAR_20.getName().getStringRef() == ""tfg.__mlir_placeholder"") {
return InvalidArgument(absl::StrCat(
""Couldn't import graph: placeholder left "",
VAR_20.getAttrOfType<StringAttr>(VAR_10).getValue().str()));
}
}
return Status::OK();
}",tensorflow/ad069af92392efee1418c48ff561fd3070a03d7b/functiondef_import.cc/vul/before/1.json,"Status ImportNodes(ValueMapManager value_manager,
                   const RepeatedPtrField<NodeDef>& nodes, OpBuilder& builder) {
  Location unknown_loc = builder.getUnknownLoc();
  MLIRContext* context = builder.getContext();

  Type placeholder_ty = OpaqueTensorType::get(context);
  Type control_ty = ControlType::get(context);
  TFGraphDialect* tfgDialect =
      cast<TFGraphDialect>(context->getLoadedDialect(""tfg""));
  StringAttr device_attr = tfgDialect->getDeviceAttrIdentifier();
  StringAttr name_attr = tfgDialect->getNameAttrIdentifier();
  StringAttr fulltype_attr = tfgDialect->getFullTypeAttrIdentifier();
  // Process every node and create a matching MLIR operation
  for (const NodeDef& node : nodes) {
    DVLOG(1) << ""Processing node "" << node.name() << ""\n"";
    if (node.op().empty()) return InvalidArgument(""empty op type"");
    OperationState state(unknown_loc, absl::StrCat(""tfg."", node.op()));
    // Fetch the inputs, creating placeholder if an input hasn't been visited.
    for (const std::string& input : node.input()) {
      if (input.empty())
        return InvalidArgument(""Node '"", node.name(), ""' has an empty input"");
      state.operands.push_back(
          value_manager.GetValueOrCreatePlaceholder(input));
    }
    // Retrieve the entry in the nodes_map for this node and infer the result
    // count from what was inferred during the first traversal above.
    state.types.push_back(placeholder_ty);
    state.types.push_back(control_ty);
    // Handle attributes.
    for (const auto& namedAttr : node.attr()) {
      const std::string& name = namedAttr.first;
      const AttrValue& tf_attr = namedAttr.second;
      TF_ASSIGN_OR_RETURN(Attribute attr,
                          ConvertAttributeValue(tf_attr, builder, tfgDialect));
      state.addAttribute(name, attr);
    }
    if (!node.device().empty())
      state.addAttribute(device_attr, StringAttr::get(context, node.device()));
    if (!node.name().empty())
      state.addAttribute(name_attr, StringAttr::get(context, node.name()));
    if (node.has_experimental_type()) {
      TF_ASSIGN_OR_RETURN(
          tf_type::FullTypeAttr type,
          ConvertAttribute(node.experimental_type(), builder, tfgDialect));
      state.addAttribute(fulltype_attr, type);
    }

    Operation* op = builder.create(state);

    StringRef node_name = node.name();
    {
      size_t colon_sep = node_name.find_first_of(':');
      if (colon_sep != StringRef::npos)
        node_name = node_name.take_front(colon_sep);
    }
    TF_RETURN_IF_ERROR(value_manager.DefineOperation(op, node_name));
  }
  // We don't expect any placeholder left at this point, fail if any.
  for (Operation& op : *builder.getInsertionBlock()) {
    if (op.getName().getStringRef() == ""tfg.__mlir_placeholder"") {
      return InvalidArgument(absl::StrCat(
          ""Couldn't import graph: placeholder left "",
          op.getAttrOfType<StringAttr>(name_attr).getValue().str()));
    }
  }
  return Status::OK();
}","Status ImportNodes(ValueMapManager VAR_0,
                   const RepeatedPtrField<NodeDef>& VAR_1, OpBuilder& VAR_2) {
  Location VAR_3 = VAR_2.getUnknownLoc();
  MLIRContext* VAR_4 = VAR_2.getContext();

  Type VAR_5 = OpaqueTensorType::get(VAR_4);
  Type VAR_6 = ControlType::get(VAR_4);
  TFGraphDialect* VAR_7 =
      VAR_8<TFGraphDialect>(VAR_4->getLoadedDialect(""tfg""));
  StringAttr VAR_9 = VAR_7->getDeviceAttrIdentifier();
  StringAttr VAR_10 = VAR_7->getNameAttrIdentifier();
  StringAttr VAR_11 = VAR_7->getFullTypeAttrIdentifier();
  /* COMMENT_0 */
  for (const NodeDef& VAR_12 : VAR_1) {
    DVLOG(1) << ""Processing node "" << VAR_12.name() << ""\n"";
    if (VAR_12.op().empty()) return InvalidArgument(""empty op type"");
    OperationState VAR_13(VAR_3, absl::StrCat(""tfg."", VAR_12.op()));
    /* COMMENT_1 */
    for (const std::string& VAR_14 : VAR_12.input()) {
      if (VAR_14.empty())
        return InvalidArgument(""Node '"", VAR_12.name(), ""' has an empty input"");
      VAR_13.operands.push_back(
          VAR_0.GetValueOrCreatePlaceholder(VAR_14));
    }
    /* COMMENT_2 */
    /* COMMENT_3 */
    VAR_13.types.push_back(VAR_5);
    VAR_13.types.push_back(VAR_6);
    /* COMMENT_4 */
    for (const auto& VAR_15 : VAR_12.attr()) {
      const std::string& VAR_16 = VAR_15.first;
      const AttrValue& VAR_17 = VAR_15.second;
      TF_ASSIGN_OR_RETURN(Attribute VAR_18,
                          ConvertAttributeValue(tf_attr, builder, tfgDialect));
      VAR_13.addAttribute(VAR_16, VAR_18);
    }
    if (!VAR_12.device().empty())
      VAR_13.addAttribute(VAR_9, StringAttr::get(VAR_4, VAR_12.device()));
    if (!VAR_12.name().empty())
      VAR_13.addAttribute(VAR_10, StringAttr::get(VAR_4, VAR_12.name()));
    if (VAR_12.has_experimental_type()) {
      TF_ASSIGN_OR_RETURN(
          tf_type::FullTypeAttr VAR_19,
          ConvertAttribute(node.experimental_type(), builder, tfgDialect));
      VAR_13.addAttribute(VAR_11, VAR_19);
    }

    Operation* VAR_20 = builder.create(VAR_13);

    StringRef VAR_21 = node.name();
    {
      size_t VAR_22 = VAR_21.find_first_of(':');
      if (VAR_22 != StringRef::npos)
        VAR_21 = VAR_21.take_front(VAR_22);
    }
    TF_RETURN_IF_ERROR(VAR_0.DefineOperation(VAR_20, VAR_21));
  }
  /* COMMENT_5 */
  for (Operation& VAR_20 : *builder.getInsertionBlock()) {
    if (VAR_20.getName().getStringRef() == ""tfg.__mlir_placeholder"") {
      return InvalidArgument(absl::StrCat(
          ""Couldn't import graph: placeholder left "",
          VAR_20.getAttrOfType<StringAttr>(VAR_10).getValue().str()));
    }
  }
  return Status::OK();
}",tensorflow/ad069af92392efee1418c48ff561fd3070a03d7b/functiondef_import.cc/vul/after/1.json,"--- func_before
+++ func_after
@@ -16,9 +16,12 @@
     if (node.op().empty()) return InvalidArgument(""empty op type"");
     OperationState state(unknown_loc, absl::StrCat(""tfg."", node.op()));
     // Fetch the inputs, creating placeholder if an input hasn't been visited.
-    for (const std::string& input : node.input())
+    for (const std::string& input : node.input()) {
+      if (input.empty())
+        return InvalidArgument(""Node '"", node.name(), ""' has an empty input"");
       state.operands.push_back(
           value_manager.GetValueOrCreatePlaceholder(input));
+    }
     // Retrieve the entry in the nodes_map for this node and infer the result
     // count from what was inferred during the first traversal above.
     state.types.push_back(placeholder_ty);","{'deleted_lines': ['    for (const std::string& input : node.input())'], 'added_lines': ['    for (const std::string& input : node.input()) {', '      if (input.empty())', '        return InvalidArgument(""Node \'"", node.name(), ""\' has an empty input"");', '    }']}",True,"TensorFlow is an open source platform for machine learning. When `mlir::tfg::ConvertGenericFunctionToFunctionDef` is given empty function attributes, it crashes. We have patched the issue in GitHub commit ad069af92392efee1418c48ff561fd3070a03d7b. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.",5.9,MEDIUM,1,test,2022-05-20T11:04:05Z,4
CVE-2022-33105,['CWE-401'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,redis,"Fix memory leak in streamGetEdgeID (#10753)

si is initialized by streamIteratorStart(), we should call
streamIteratorStop() on it when done.

regression introduced in #9127 (redis 7.0)",4a7a4e42db8ff757cdf3f4a824f66426036034ef,https://github.com/redis/redis/commit/4a7a4e42db8ff757cdf3f4a824f66426036034ef,src/t_stream.c,streamGetEdgeID,"void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id)
{
streamIterator si;
int64_t numfields;
streamIteratorStart(&si,s,NULL,NULL,!first);
si.skip_tombstones = skip_tombstones;
int found = streamIteratorGetID(&si,edge_id,&numfields);
if (!found) {
streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};
*edge_id = first ? max_id : min_id;
}
}","void streamGetEdgeID(stream *VAR_0, int VAR_1, int VAR_2, streamID *VAR_3)
{
streamIterator VAR_4;
int64_t VAR_5;
streamIteratorStart(&VAR_4,VAR_0,NULL,NULL,!VAR_1);
VAR_4.skip_tombstones = VAR_2;
int VAR_6 = streamIteratorGetID(&VAR_4,VAR_3,&VAR_5);
if (!VAR_6) {
streamID VAR_7 = {0, 0}, VAR_8 = {VAR_9, VAR_9};
*VAR_3 = VAR_1 ? VAR_8 : VAR_7;
}
}",redis/4a7a4e42db8ff757cdf3f4a824f66426036034ef/t_stream.c/vul/before/0.json,"void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id)
{
    streamIterator si;
    int64_t numfields;
    streamIteratorStart(&si,s,NULL,NULL,!first);
    si.skip_tombstones = skip_tombstones;
    int found = streamIteratorGetID(&si,edge_id,&numfields);
    if (!found) {
        streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};
        *edge_id = first ? max_id : min_id;
    }
    streamIteratorStop(&si);
}","void streamGetEdgeID(stream *VAR_0, int VAR_1, int VAR_2, streamID *VAR_3)
{
    streamIterator VAR_4;
    int64_t VAR_5;
    streamIteratorStart(&VAR_4,VAR_0,NULL,NULL,!VAR_1);
    VAR_4.skip_tombstones = VAR_2;
    int VAR_6 = streamIteratorGetID(&VAR_4,VAR_3,&VAR_5);
    if (!VAR_6) {
        streamID VAR_7 = {0, 0}, VAR_8 = {VAR_9, VAR_9};
        *VAR_3 = VAR_1 ? VAR_8 : VAR_7;
    }
    streamIteratorStop(&VAR_4);
}",redis/4a7a4e42db8ff757cdf3f4a824f66426036034ef/t_stream.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,5 +9,5 @@
         streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};
         *edge_id = first ? max_id : min_id;
     }
-
+    streamIteratorStop(&si);
 }","{'deleted_lines': [''], 'added_lines': ['    streamIteratorStop(&si);']}",True,Redis v7.0 was discovered to contain a memory leak via the component streamGetEdgeID.,7.5,HIGH,2,test,2022-05-22T09:15:26Z,4
CVE-2022-36013,['CWE-476'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,tensorflow,"[TF] NodeDefs without an op name are invalid, return error on import

PiperOrigin-RevId: 453711926",a0f0b9a21c9270930457095092f558fbad4c03e5,https://github.com/tensorflow/tensorflow/commit/a0f0b9a21c9270930457095092f558fbad4c03e5,tensorflow/core/ir/importexport/graphdef_import.cc,GraphDefImporter::ConvertNodeDef,"Status GraphDefImporter::ConvertNodeDef(OpBuilder &builder, ConversionState &s,
const NodeDef &node) {
VLOG(4) << ""Importing: "" << node.name();
OperationState state(ConvertLocation(node), absl::StrCat(""tfg."", node.op()));
const OpDef *op_def;
const OpRegistrationData *op_reg_data = nullptr;
if ((op_reg_data = registry_.LookUp(node.op()))) {
op_def = &op_reg_data->op_def;
} else {
auto it = function_op_defs_.find(node.op());
if (it == function_op_defs_.end())
return InvalidArgument(""Unable to find OpDef for "", node.op());
op_def = it->second;
}
state.attributes.reserve(node.attr_size() + 3);
if (!node.device().empty()) {
state.addAttribute(dialect_->getDeviceAttrIdentifier(),
b_.getStringAttr(node.device()));
}
if (!node.name().empty()) {
state.addAttribute(dialect_->getNameAttrIdentifier(),
b_.getStringAttr(node.name()));
}
const auto add_full_type = [&](const FullTypeDef &full_type_def) {
TF_ASSIGN_OR_RETURN(tf_type::FullTypeAttr full_type,
ConvertAttribute(full_type_def, b_, dialect_));
state.addAttribute(dialect_->getFullTypeAttrIdentifier(), full_type);
return ::tensorflow::OkStatus();
};
if (node.has_experimental_type()) {
TF_RETURN_IF_ERROR(add_full_type(node.experimental_type()));
} else if (op_reg_data && op_reg_data->type_ctor) {
FullTypeDef full_type_def;
TF_RETURN_IF_ERROR(
tensorflow::full_type::SpecializeType(node, *op_def, full_type_def));
TF_RETURN_IF_ERROR(add_full_type(full_type_def));
}
for (auto &name_attr : node.attr()) {
if (name_attr.first.empty())
return InvalidArgument(""Node "", node.name(), "" has an empty attr name"");
TF_ASSIGN_OR_RETURN(Attribute attr,
ConvertAttributeValue(name_attr.second, b_, dialect_));
state.addAttribute(name_attr.first, attr);
}
for (const auto &attr_def : op_def->attr()) {
if (attr_def.has_default_value() &&
!state.attributes.get(attr_def.name())) {
TF_ASSIGN_OR_RETURN(
Attribute attr,
ConvertAttributeValue(attr_def.default_value(), b_, dialect_));
state.addAttribute(attr_def.name(), attr);
}
}
SmallVector<std::pair<unsigned, unsigned>> result_segments;
result_segments.reserve(op_def->output_arg_size());
state.types.reserve(op_def->output_arg_size() + 1);
for (const OpDef::ArgDef &def : op_def->output_arg()) {
unsigned index = state.types.size();
TF_ASSIGN_OR_RETURN(unsigned size,
ArgNumType(state.attributes, def, state.types));
result_segments.emplace_back(index, size);
}
state.types.push_back(dialect_->getControlType());
state.operands.reserve(node.input_size());
SmallVector<Value> control_operands;
struct BackedgeResolution {
ResultInfo *info;
size_t operand_index;
ResultId id;
};
SmallVector<BackedgeResolution> unresolved_data_operands,
unresolved_control_operands;
for (const std::string &input : node.input()) {
TF_ASSIGN_OR_RETURN(Result result, GetResult(s, input));
if (result.control) {
if (result.info) {
unresolved_control_operands.push_back(BackedgeResolution{
result.info, control_operands.size(), result.id});
}
control_operands.push_back(result.control);
} else {
if (result.info) {
unresolved_data_operands.push_back(
BackedgeResolution{result.info, state.operands.size(), result.id});
}
state.operands.push_back(result.data);
}
}
unsigned num_data_operands = state.operands.size();
state.addOperands(control_operands);
Operation *op = builder.create(state);
for (const BackedgeResolution &r : unresolved_data_operands) {
r.info->backedges.push_back(
Backedge{r.id, &op->getOpOperand(r.operand_index)});
}
for (const BackedgeResolution &r : unresolved_control_operands) {
r.info->backedges.push_back(
Backedge{r.id, &op->getOpOperand(num_data_operands + r.operand_index)});
}
std::unique_ptr<ResultInfo> &info = s[node.name()];
if (!info) {
info = std::make_unique<ResultInfo>();
}
info->resolved = true;
info->control = *std::prev(op->result_end());
info->data = op->getResults().drop_back();
for (auto it : llvm::zip(result_segments, op_def->output_arg())) {
const std::pair<unsigned, unsigned> &segment = std::get<0>(it);
info->outputs.emplace(std::get<1>(it).name(),
info->data.slice(segment.first, segment.second));
}
for (const Backedge &backedge : info->backedges) {
Value value;
if (backedge.id.IsControl()) {
value = info->control;
} else {
TF_ASSIGN_OR_RETURN(value, ResolveDataResult(backedge.id, info.get()));
}
backedge.operand->set(value);
}
info->backedges.clear();
return ::tensorflow::OkStatus();
}","Status GraphDefImporter::ConvertNodeDef(OpBuilder &VAR_0, ConversionState &VAR_1,
const NodeDef &VAR_2) {
VLOG(4) << ""Importing: "" << VAR_2.name();
OperationState VAR_3(ConvertLocation(VAR_2), absl::StrCat(""tfg."", VAR_2.op()));
const OpDef *VAR_4;
const OpRegistrationData *VAR_5 = nullptr;
if ((VAR_5 = VAR_6.LookUp(VAR_2.op()))) {
VAR_4 = &VAR_5->op_def;
} else {
auto VAR_7 = VAR_8.find(VAR_2.op());
if (VAR_7 == VAR_8.end())
return InvalidArgument(""Unable to find OpDef for "", VAR_2.op());
VAR_4 = VAR_7->second;
}
VAR_3.attributes.reserve(VAR_2.attr_size() + 3);
if (!VAR_2.device().empty()) {
VAR_3.addAttribute(VAR_9->getDeviceAttrIdentifier(),
VAR_10.getStringAttr(VAR_2.device()));
}
if (!VAR_2.name().empty()) {
VAR_3.addAttribute(VAR_9->getNameAttrIdentifier(),
VAR_10.getStringAttr(VAR_2.name()));
}
const auto VAR_11 = [&](const FullTypeDef &VAR_12) {
TF_ASSIGN_OR_RETURN(tf_type::FullTypeAttr VAR_13,
ConvertAttribute(full_type_def, b_, dialect_));
VAR_3.addAttribute(dialect_->getFullTypeAttrIdentifier(), VAR_13);
return ::tensorflow::OkStatus();
};
if (VAR_2.has_experimental_type()) {
TF_RETURN_IF_ERROR(VAR_11(VAR_2.experimental_type()));
} else if (VAR_5 && VAR_5->type_ctor) {
FullTypeDef full_type_def;
TF_RETURN_IF_ERROR(
tensorflow::full_type::SpecializeType(VAR_2, *VAR_4, full_type_def));
TF_RETURN_IF_ERROR(VAR_11(full_type_def));
}
for (auto &VAR_14 : VAR_2.attr()) {
if (VAR_14.first.empty())
return InvalidArgument(""Node "", VAR_2.name(), "" has an empty attr name"");
TF_ASSIGN_OR_RETURN(Attribute VAR_15,
ConvertAttributeValue(name_attr.VAR_16, b_, dialect_));
VAR_3.addAttribute(name_attr.first, VAR_15);
}
for (const auto &VAR_17 : VAR_4->attr()) {
if (VAR_17.has_default_value() &&
!VAR_3.attributes.get(VAR_17.name())) {
TF_ASSIGN_OR_RETURN(
Attribute VAR_15,
ConvertAttributeValue(attr_def.default_value(), b_, dialect_));
VAR_3.addAttribute(attr_def.name(), VAR_15);
}
}
SmallVector<std::pair<unsigned, unsigned>> VAR_18;
VAR_18.reserve(VAR_4->output_arg_size());
VAR_3.types.reserve(VAR_4->output_arg_size() + 1);
for (const OpDef::ArgDef &VAR_19 : VAR_4->output_arg()) {
unsigned VAR_20 = VAR_3.types.size();
TF_ASSIGN_OR_RETURN(unsigned VAR_21,
ArgNumType(state.VAR_22, def, state.VAR_23));
VAR_18.emplace_back(VAR_20, VAR_21);
}
state.types.push_back(dialect_->getControlType());
state.operands.reserve(VAR_2.input_size());
SmallVector<Value> VAR_24;
struct BackedgeResolution {
ResultInfo *info;
size_t operand_index;
ResultId id;
};
SmallVector<BackedgeResolution> VAR_25,
VAR_26;
for (const std::string &VAR_27 : VAR_2.input()) {
TF_ASSIGN_OR_RETURN(Result VAR_28, GetResult(s, input));
if (VAR_28.control) {
if (VAR_28.info) {
VAR_26.push_back(BackedgeResolution{
VAR_28.info, VAR_24.size(), VAR_28.id});
}
VAR_24.push_back(VAR_28.control);
} else {
if (VAR_28.info) {
VAR_25.push_back(
BackedgeResolution{VAR_28.info, state.operands.size(), VAR_28.id});
}
state.operands.push_back(VAR_28.data);
}
}
unsigned VAR_29 = state.operands.size();
state.addOperands(VAR_24);
Operation *VAR_30 = VAR_0.create(state);
for (const BackedgeResolution &VAR_31 : VAR_25) {
VAR_31.info->backedges.push_back(
Backedge{VAR_31.id, &VAR_30->getOpOperand(VAR_31.operand_index)});
}
for (const BackedgeResolution &VAR_31 : VAR_26) {
VAR_31.info->backedges.push_back(
Backedge{VAR_31.id, &VAR_30->getOpOperand(VAR_29 + VAR_31.operand_index)});
}
std::unique_ptr<ResultInfo> &VAR_32 = s[VAR_2.name()];
if (!VAR_32) {
VAR_32 = std::VAR_33<ResultInfo>();
}
VAR_32->resolved = true;
VAR_32->control = *std::prev(VAR_30->result_end());
VAR_32->data = VAR_30->getResults().drop_back();
for (auto VAR_7 : llvm::zip(VAR_18, VAR_4->output_arg())) {
const std::pair<unsigned, unsigned> &VAR_34 = std::VAR_35<0>(VAR_7);
VAR_32->outputs.emplace(std::VAR_35<1>(VAR_7).name(),
VAR_32->data.slice(VAR_34.first, VAR_34.second));
}
for (const Backedge &VAR_36 : VAR_32->backedges) {
Value VAR_37;
if (VAR_36.id.IsControl()) {
VAR_37 = VAR_32->control;
} else {
TF_ASSIGN_OR_RETURN(VAR_37, ResolveDataResult(VAR_36.id, VAR_32.get()));
}
VAR_36.operand->set(VAR_37);
}
VAR_32->backedges.clear();
return ::tensorflow::OkStatus();
}",tensorflow/a0f0b9a21c9270930457095092f558fbad4c03e5/graphdef_import.cc/vul/before/0.json,"Status GraphDefImporter::ConvertNodeDef(OpBuilder &builder, ConversionState &s,
                                        const NodeDef &node) {
  VLOG(4) << ""Importing: "" << node.name();
  if (node.op().empty())
    return InvalidArgument(""Node "", node.name(), "" has an empty op name"");

  OperationState state(ConvertLocation(node), absl::StrCat(""tfg."", node.op()));

  // The GraphImporter does light shape inference, but here we will defer all of
  // that to the shape inference pass.
  const OpDef *op_def;
  const OpRegistrationData *op_reg_data = nullptr;
  if ((op_reg_data = registry_.LookUp(node.op()))) {
    op_def = &op_reg_data->op_def;
  } else {
    auto it = function_op_defs_.find(node.op());
    if (it == function_op_defs_.end())
      return InvalidArgument(""Unable to find OpDef for "", node.op());
    op_def = it->second;
  }

  // Import the attributes. Reserve `+3` for `device`,`name`, and `fulltype`.
  state.attributes.reserve(node.attr_size() + 3);
  if (!node.device().empty()) {
    state.addAttribute(dialect_->getDeviceAttrIdentifier(),
                       b_.getStringAttr(node.device()));
  }
  if (!node.name().empty()) {
    state.addAttribute(dialect_->getNameAttrIdentifier(),
                       b_.getStringAttr(node.name()));
  }

  // If the op doesn't have a FullType, try to infer one.
  const auto add_full_type = [&](const FullTypeDef &full_type_def) {
    TF_ASSIGN_OR_RETURN(tf_type::FullTypeAttr full_type,
                        ConvertAttribute(full_type_def, b_, dialect_));
    state.addAttribute(dialect_->getFullTypeAttrIdentifier(), full_type);
    return ::tensorflow::OkStatus();
  };
  if (node.has_experimental_type()) {
    TF_RETURN_IF_ERROR(add_full_type(node.experimental_type()));
  } else if (op_reg_data && op_reg_data->type_ctor) {
    FullTypeDef full_type_def;
    TF_RETURN_IF_ERROR(
        tensorflow::full_type::SpecializeType(node, *op_def, full_type_def));
    TF_RETURN_IF_ERROR(add_full_type(full_type_def));
  }

  for (auto &name_attr : node.attr()) {
    if (name_attr.first.empty())
      return InvalidArgument(""Node "", node.name(), "" has an empty attr name"");
    TF_ASSIGN_OR_RETURN(Attribute attr,
                        ConvertAttributeValue(name_attr.second, b_, dialect_));
    state.addAttribute(name_attr.first, attr);
  }

  // Add missing default attributes.
  for (const auto &attr_def : op_def->attr()) {
    if (attr_def.has_default_value() &&
        !state.attributes.get(attr_def.name())) {
      TF_ASSIGN_OR_RETURN(
          Attribute attr,
          ConvertAttributeValue(attr_def.default_value(), b_, dialect_));
      state.addAttribute(attr_def.name(), attr);
    }
  }

  // Get the result types. Ops can have multiple named results. Track the
  // segment sizes.
  SmallVector<std::pair<unsigned, unsigned>> result_segments;
  result_segments.reserve(op_def->output_arg_size());
  state.types.reserve(op_def->output_arg_size() + 1);
  for (const OpDef::ArgDef &def : op_def->output_arg()) {
    unsigned index = state.types.size();
    TF_ASSIGN_OR_RETURN(unsigned size,
                        ArgNumType(state.attributes, def, state.types));
    result_segments.emplace_back(index, size);
  }
  state.types.push_back(dialect_->getControlType());

  // Collect the operands. Set backedges to a placeholder and resolve them
  // later.
  state.operands.reserve(node.input_size());
  SmallVector<Value> control_operands;
  struct BackedgeResolution {
    ResultInfo *info;
    size_t operand_index;
    ResultId id;
  };
  SmallVector<BackedgeResolution> unresolved_data_operands,
      unresolved_control_operands;
  for (const std::string &input : node.input()) {
    TF_ASSIGN_OR_RETURN(Result result, GetResult(s, input));
    if (result.control) {
      if (result.info) {
        unresolved_control_operands.push_back(BackedgeResolution{
            result.info, control_operands.size(), result.id});
      }
      control_operands.push_back(result.control);
    } else {
      if (result.info) {
        unresolved_data_operands.push_back(
            BackedgeResolution{result.info, state.operands.size(), result.id});
      }
      state.operands.push_back(result.data);
    }
  }
  unsigned num_data_operands = state.operands.size();
  state.addOperands(control_operands);

  // Create the op and record any unresolved operands.
  Operation *op = builder.create(state);
  for (const BackedgeResolution &r : unresolved_data_operands) {
    r.info->backedges.push_back(
        Backedge{r.id, &op->getOpOperand(r.operand_index)});
  }
  for (const BackedgeResolution &r : unresolved_control_operands) {
    r.info->backedges.push_back(
        Backedge{r.id, &op->getOpOperand(num_data_operands + r.operand_index)});
  }

  std::unique_ptr<ResultInfo> &info = s[node.name()];
  if (!info) {
    info = std::make_unique<ResultInfo>();
  }
  info->resolved = true;
  info->control = *std::prev(op->result_end());
  info->data = op->getResults().drop_back();
  for (auto it : llvm::zip(result_segments, op_def->output_arg())) {
    const std::pair<unsigned, unsigned> &segment = std::get<0>(it);
    info->outputs.emplace(std::get<1>(it).name(),
                          info->data.slice(segment.first, segment.second));
  }

  // Resolve any associated backedges.
  for (const Backedge &backedge : info->backedges) {
    Value value;
    if (backedge.id.IsControl()) {
      value = info->control;
    } else {
      TF_ASSIGN_OR_RETURN(value, ResolveDataResult(backedge.id, info.get()));
    }
    backedge.operand->set(value);
  }
  info->backedges.clear();

  return ::tensorflow::OkStatus();
}","Status GraphDefImporter::ConvertNodeDef(OpBuilder &VAR_0, ConversionState &VAR_1,
                                        const NodeDef &VAR_2) {
  VLOG(4) << ""Importing: "" << VAR_2.name();
  if (VAR_2.op().empty())
    return InvalidArgument(""Node "", VAR_2.name(), "" has an empty op name"");

  OperationState VAR_3(ConvertLocation(VAR_2), absl::StrCat(""tfg."", VAR_2.op()));

  /* COMMENT_0 */
  /* COMMENT_1 */
  const OpDef *VAR_4;
  const OpRegistrationData *VAR_5 = nullptr;
  if ((VAR_5 = VAR_6.LookUp(VAR_2.op()))) {
    VAR_4 = &VAR_5->op_def;
  } else {
    auto VAR_7 = VAR_8.find(VAR_2.op());
    if (VAR_7 == VAR_8.end())
      return InvalidArgument(""Unable to find OpDef for "", VAR_2.op());
    VAR_4 = VAR_7->second;
  }

  /* COMMENT_2 */
  VAR_3.attributes.reserve(VAR_2.attr_size() + 3);
  if (!VAR_2.device().empty()) {
    VAR_3.addAttribute(VAR_9->getDeviceAttrIdentifier(),
                       VAR_10.getStringAttr(VAR_2.device()));
  }
  if (!VAR_2.name().empty()) {
    VAR_3.addAttribute(VAR_9->getNameAttrIdentifier(),
                       VAR_10.getStringAttr(VAR_2.name()));
  }

  /* COMMENT_3 */
  const auto VAR_11 = [&](const FullTypeDef &VAR_12) {
    TF_ASSIGN_OR_RETURN(tf_type::FullTypeAttr VAR_13,
                        ConvertAttribute(full_type_def, b_, dialect_));
    VAR_3.addAttribute(dialect_->getFullTypeAttrIdentifier(), VAR_13);
    return ::tensorflow::OkStatus();
  };
  if (VAR_2.has_experimental_type()) {
    TF_RETURN_IF_ERROR(VAR_11(VAR_2.experimental_type()));
  } else if (VAR_5 && VAR_5->type_ctor) {
    FullTypeDef full_type_def;
    TF_RETURN_IF_ERROR(
        tensorflow::full_type::SpecializeType(VAR_2, *VAR_4, full_type_def));
    TF_RETURN_IF_ERROR(VAR_11(full_type_def));
  }

  for (auto &VAR_14 : VAR_2.attr()) {
    if (VAR_14.first.empty())
      return InvalidArgument(""Node "", VAR_2.name(), "" has an empty attr name"");
    TF_ASSIGN_OR_RETURN(Attribute VAR_15,
                        ConvertAttributeValue(name_attr.VAR_16, b_, dialect_));
    VAR_3.addAttribute(name_attr.first, VAR_15);
  }

  /* COMMENT_4 */
  for (const auto &VAR_17 : VAR_4->attr()) {
    if (VAR_17.has_default_value() &&
        !VAR_3.attributes.get(VAR_17.name())) {
      TF_ASSIGN_OR_RETURN(
          Attribute VAR_15,
          ConvertAttributeValue(attr_def.default_value(), b_, dialect_));
      VAR_3.addAttribute(attr_def.name(), VAR_15);
    }
  }

  /* COMMENT_5 */
  /* COMMENT_6 */
  SmallVector<std::pair<unsigned, unsigned>> VAR_18;
  VAR_18.reserve(VAR_4->output_arg_size());
  VAR_3.types.reserve(VAR_4->output_arg_size() + 1);
  for (const OpDef::ArgDef &VAR_19 : VAR_4->output_arg()) {
    unsigned VAR_20 = VAR_3.types.size();
    TF_ASSIGN_OR_RETURN(unsigned VAR_21,
                        ArgNumType(state.VAR_22, def, state.VAR_23));
    VAR_18.emplace_back(VAR_20, VAR_21);
  }
  state.types.push_back(dialect_->getControlType());

  /* COMMENT_7 */
  /* COMMENT_8 */
  state.operands.reserve(VAR_2.input_size());
  SmallVector<Value> VAR_24;
  struct BackedgeResolution {
    ResultInfo *info;
    size_t operand_index;
    ResultId id;
  };
  SmallVector<BackedgeResolution> VAR_25,
      VAR_26;
  for (const std::string &VAR_27 : VAR_2.input()) {
    TF_ASSIGN_OR_RETURN(Result VAR_28, GetResult(s, input));
    if (VAR_28.control) {
      if (VAR_28.info) {
        VAR_26.push_back(BackedgeResolution{
            VAR_28.info, VAR_24.size(), VAR_28.id});
      }
      VAR_24.push_back(VAR_28.control);
    } else {
      if (VAR_28.info) {
        VAR_25.push_back(
            BackedgeResolution{VAR_28.info, state.operands.size(), VAR_28.id});
      }
      state.operands.push_back(VAR_28.data);
    }
  }
  unsigned VAR_29 = state.operands.size();
  state.addOperands(VAR_24);

  /* COMMENT_9 */
  Operation *VAR_30 = VAR_0.create(state);
  for (const BackedgeResolution &VAR_31 : VAR_25) {
    VAR_31.info->backedges.push_back(
        Backedge{VAR_31.id, &VAR_30->getOpOperand(VAR_31.operand_index)});
  }
  for (const BackedgeResolution &VAR_31 : VAR_26) {
    VAR_31.info->backedges.push_back(
        Backedge{VAR_31.id, &VAR_30->getOpOperand(VAR_29 + VAR_31.operand_index)});
  }

  std::unique_ptr<ResultInfo> &VAR_32 = s[VAR_2.name()];
  if (!VAR_32) {
    VAR_32 = std::VAR_33<ResultInfo>();
  }
  VAR_32->resolved = true;
  VAR_32->control = *std::prev(VAR_30->result_end());
  VAR_32->data = VAR_30->getResults().drop_back();
  for (auto VAR_7 : llvm::zip(VAR_18, VAR_4->output_arg())) {
    const std::pair<unsigned, unsigned> &VAR_34 = std::VAR_35<0>(VAR_7);
    VAR_32->outputs.emplace(std::VAR_35<1>(VAR_7).name(),
                          VAR_32->data.slice(VAR_34.first, VAR_34.second));
  }

  /* COMMENT_10 */
  for (const Backedge &VAR_36 : VAR_32->backedges) {
    Value VAR_37;
    if (VAR_36.id.IsControl()) {
      VAR_37 = VAR_32->control;
    } else {
      TF_ASSIGN_OR_RETURN(VAR_37, ResolveDataResult(VAR_36.id, VAR_32.get()));
    }
    VAR_36.operand->set(VAR_37);
  }
  VAR_32->backedges.clear();

  return ::tensorflow::OkStatus();
}",tensorflow/a0f0b9a21c9270930457095092f558fbad4c03e5/graphdef_import.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,9 @@
 Status GraphDefImporter::ConvertNodeDef(OpBuilder &builder, ConversionState &s,
                                         const NodeDef &node) {
   VLOG(4) << ""Importing: "" << node.name();
+  if (node.op().empty())
+    return InvalidArgument(""Node "", node.name(), "" has an empty op name"");
+
   OperationState state(ConvertLocation(node), absl::StrCat(""tfg."", node.op()));
 
   // The GraphImporter does light shape inference, but here we will defer all of","{'deleted_lines': [], 'added_lines': ['  if (node.op().empty())', '    return InvalidArgument(""Node "", node.name(), "" has an empty op name"");', '']}",True,"TensorFlow is an open source platform for machine learning. When `mlir::tfg::GraphDefImporter::ConvertNodeDef` tries to convert NodeDefs without an op name, it crashes. We have patched the issue in GitHub commit a0f0b9a21c9270930457095092f558fbad4c03e5. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.",5.9,MEDIUM,1,test,2022-06-08T17:27:21Z,4
CVE-2022-26363,['CWE-Other'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86: Split cache_flush() out of cache_writeback()

Subsequent changes will want a fully flushing version.

Use the new helper rather than opencoding it in flush_area_local().  This
resolves an outstanding issue where the conditional sfence is on the wrong
side of the clflushopt loop.  clflushopt is ordered with respect to older
stores, not to younger stores.

Rename gnttab_cache_flush()'s helper to avoid colliding in name.
grant_table.c can see the prototype from cache.h so the build fails
otherwise.

This is part of XSA-402.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",9a67ffee3371506e1cbfdfff5b90658d4828f6a2,https://github.com/xen-project/xen/commit/9a67ffee3371506e1cbfdfff5b90658d4828f6a2,xen/arch/x86/flushtlb.c,cache_writeback,"void cache_writeback(const void *addr, unsigned int size)
{
unsigned int clflush_size = current_cpu_data.x86_clflush_size ?: 16;
const void *end = addr + size;
addr -= (unsigned long)addr & (clflush_size - 1);
for ( ; addr < end; addr += clflush_size )
{
#if defined(HAVE_AS_CLWB)
# define CLWB_ENCODING ""clwb %[p]""
#elif defined(HAVE_AS_XSAVEOPT)
# define CLWB_ENCODING ""data16 xsaveopt %[p]"" 
#else
# define CLWB_ENCODING "".byte 0x66, 0x0f, 0xae, 0x30"" 
#endif
#define BASE_INPUT(addr) [p] ""m"" (*(const char *)(addr))
#if defined(HAVE_AS_CLWB) || defined(HAVE_AS_XSAVEOPT)
# define INPUT BASE_INPUT
#else
# define INPUT(addr) ""a"" (addr), BASE_INPUT(addr)
#endif
alternative_io_2(""ds; clflush %[p]"",
""data16 clflush %[p]"", 
X86_FEATURE_CLFLUSHOPT,
CLWB_ENCODING,
X86_FEATURE_CLWB, ,
INPUT(addr));
#undef INPUT
#undef BASE_INPUT
#undef CLWB_ENCODING
}
alternative_2("""", ""sfence"", X86_FEATURE_CLFLUSHOPT,
""sfence"", X86_FEATURE_CLWB);
}","void cache_writeback(const void *VAR_0, unsigned int VAR_1)
{
unsigned int VAR_2 = VAR_3.x86_clflush_size ?VAR_4: 16;
const void *VAR_5 = VAR_0 + VAR_1;
VAR_0 -= (unsigned long)VAR_0 & (VAR_2 - 1);
for ( ; VAR_0 < VAR_5; VAR_0 += VAR_2 )
{
#if defined(VAR_6)
# define VAR_7 ""clwb %[p]""
#elif defined(VAR_8)
# define VAR_7 ""data16 xsaveopt %[p]"" 
#else
# define VAR_7 "".byte 0x66, 0x0f, 0xae, 0x30"" 
#endif
#define BASE_INPUT(VAR_0) [p] ""m"" (*(const char *)(addr))
#if defined(VAR_6) || defined(VAR_8)
# define VAR_9 BASE_INPUT
#else
# define VAR_9(VAR_0) ""a"" (addr), BASE_INPUT(addr)
#endif
alternative_io_2(""ds; clflush %[p]"",
""data16 clflush %[p]"", 
VAR_10,
VAR_7,
VAR_11, ,
VAR_9(VAR_0));
#undef INPUT
#undef BASE_INPUT
#undef CLWB_ENCODING
}
alternative_2("""", ""sfence"", VAR_10,
""sfence"", VAR_11);
}",xen-project/xen/9a67ffee3371506e1cbfdfff5b90658d4828f6a2/flushtlb.c/vul/before/1.json,"void cache_writeback(const void *addr, unsigned int size)
{
    unsigned int clflush_size;
    const void *end = addr + size;

    /* Fall back to CLFLUSH{,OPT} when CLWB isn't available. */
    if ( !boot_cpu_has(X86_FEATURE_CLWB) )
        return cache_flush(addr, size);

    /*
     * This function may be called before current_cpu_data is established.
     * Hence a fallback is needed to prevent the loop below becoming infinite.
     */
    clflush_size = current_cpu_data.x86_clflush_size ?: 16;
    addr -= (unsigned long)addr & (clflush_size - 1);
    for ( ; addr < end; addr += clflush_size )
    {
/*
 * The arguments to a macro must not include preprocessor directives. Doing so
 * results in undefined behavior, so we have to create some defines here in
 * order to avoid it.
 */
#if defined(HAVE_AS_CLWB)
# define CLWB_ENCODING ""clwb %[p]""
#elif defined(HAVE_AS_XSAVEOPT)
# define CLWB_ENCODING ""data16 xsaveopt %[p]"" /* clwb */
#else
# define CLWB_ENCODING "".byte 0x66, 0x0f, 0xae, 0x30"" /* clwb (%%rax) */
#endif

#define BASE_INPUT(addr) [p] ""m"" (*(const char *)(addr))
#if defined(HAVE_AS_CLWB) || defined(HAVE_AS_XSAVEOPT)
# define INPUT BASE_INPUT
#else
# define INPUT(addr) ""a"" (addr), BASE_INPUT(addr)
#endif

        asm volatile (CLWB_ENCODING :: INPUT(addr));

#undef INPUT
#undef BASE_INPUT
#undef CLWB_ENCODING
    }

    asm volatile (""sfence"" ::: ""memory"");
}","void cache_writeback(const void *VAR_0, unsigned int VAR_1)
{
    unsigned int VAR_2;
    const void *VAR_3 = VAR_0 + VAR_1;

    /* COMMENT_0 */
    if ( !boot_cpu_has(VAR_4) )
        return cache_flush(VAR_0, VAR_1);

    /* COMMENT_1 */
                                                                          
                                                                              
       
    VAR_2 = VAR_5.x86_clflush_size ?VAR_6: 16;
    VAR_0 -= (unsigned long)VAR_0 & (VAR_2 - 1);
    for ( ; VAR_0 < VAR_3; VAR_0 += VAR_2 )
    {
/* COMMENT_5 */
                                                                              
                                                                           
                     
   
#if defined(VAR_7)
# define VAR_8 ""clwb %[p]""
#elif defined(VAR_9)
# define VAR_8 ""data16 xsaveopt %[p]"" /* clwb */
#else
# define VAR_8 "".byte 0x66, 0x0f, 0xae, 0x30"" /* clwb (%%rax) */
#endif

#define BASE_INPUT(VAR_0) [p] ""m"" (*(const char *)(addr))
#if defined(VAR_7) || defined(VAR_9)
# define VAR_10 BASE_INPUT
#else
# define VAR_10(VAR_0) ""a"" (addr), BASE_INPUT(addr)
#endif

        asm volatile (VAR_8 :: INPUT(addr));

#undef INPUT
#undef BASE_INPUT
#undef CLWB_ENCODING
    }

    asm volatile (""sfence"" ::: ""memory"");
}",xen-project/xen/9a67ffee3371506e1cbfdfff5b90658d4828f6a2/flushtlb.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,12 +1,17 @@
 void cache_writeback(const void *addr, unsigned int size)
 {
+    unsigned int clflush_size;
+    const void *end = addr + size;
+
+    /* Fall back to CLFLUSH{,OPT} when CLWB isn't available. */
+    if ( !boot_cpu_has(X86_FEATURE_CLWB) )
+        return cache_flush(addr, size);
+
     /*
      * This function may be called before current_cpu_data is established.
      * Hence a fallback is needed to prevent the loop below becoming infinite.
      */
-    unsigned int clflush_size = current_cpu_data.x86_clflush_size ?: 16;
-    const void *end = addr + size;
-
+    clflush_size = current_cpu_data.x86_clflush_size ?: 16;
     addr -= (unsigned long)addr & (clflush_size - 1);
     for ( ; addr < end; addr += clflush_size )
     {
@@ -29,22 +34,13 @@
 #else
 # define INPUT(addr) ""a"" (addr), BASE_INPUT(addr)
 #endif
-        /*
-         * Note regarding the ""ds"" prefix use: it's faster to do a clflush
-         * + prefix than a clflush + nop, and hence the prefix is added instead
-         * of letting the alternative framework fill the gap by appending nops.
-         */
-        alternative_io_2(""ds; clflush %[p]"",
-                         ""data16 clflush %[p]"", /* clflushopt */
-                         X86_FEATURE_CLFLUSHOPT,
-                         CLWB_ENCODING,
-                         X86_FEATURE_CLWB, /* no outputs */,
-                         INPUT(addr));
+
+        asm volatile (CLWB_ENCODING :: INPUT(addr));
+
 #undef INPUT
 #undef BASE_INPUT
 #undef CLWB_ENCODING
     }
 
-    alternative_2("""", ""sfence"", X86_FEATURE_CLFLUSHOPT,
-                      ""sfence"", X86_FEATURE_CLWB);
+    asm volatile (""sfence"" ::: ""memory"");
 }","{'deleted_lines': ['    unsigned int clflush_size = current_cpu_data.x86_clflush_size ?: 16;', '    const void *end = addr + size;', '', '        /*', '         * Note regarding the ""ds"" prefix use: it\'s faster to do a clflush', '         * + prefix than a clflush + nop, and hence the prefix is added instead', '         * of letting the alternative framework fill the gap by appending nops.', '         */', '        alternative_io_2(""ds; clflush %[p]"",', '                         ""data16 clflush %[p]"", /* clflushopt */', '                         X86_FEATURE_CLFLUSHOPT,', '                         CLWB_ENCODING,', '                         X86_FEATURE_CLWB, /* no outputs */,', '                         INPUT(addr));', '    alternative_2("""", ""sfence"", X86_FEATURE_CLFLUSHOPT,', '                      ""sfence"", X86_FEATURE_CLWB);'], 'added_lines': ['    unsigned int clflush_size;', '    const void *end = addr + size;', '', ""    /* Fall back to CLFLUSH{,OPT} when CLWB isn't available. */"", '    if ( !boot_cpu_has(X86_FEATURE_CLWB) )', '        return cache_flush(addr, size);', '', '    clflush_size = current_cpu_data.x86_clflush_size ?: 16;', '', '        asm volatile (CLWB_ENCODING :: INPUT(addr));', '', '    asm volatile (""sfence"" ::: ""memory"");']}",True,"x86 pv: Insufficient care with non-coherent mappings T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Xen maintains a type reference count for pages, in addition to a regular reference count. This scheme is used to maintain invariants required for Xen's safety, e.g. PV guests may not have direct writeable access to pagetables; updates need auditing by Xen. Unfortunately, Xen's safety logic doesn't account for CPU-induced cache non-coherency; cases where the CPU can cause the content of the cache to be different to the content in main memory. In such cases, Xen's safety logic can incorrectly conclude that the contents of a page is safe.",6.7,MEDIUM,1,test,2022-06-09T12:22:38Z,4
CVE-2022-26363,['CWE-Other'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86: Split cache_flush() out of cache_writeback()

Subsequent changes will want a fully flushing version.

Use the new helper rather than opencoding it in flush_area_local().  This
resolves an outstanding issue where the conditional sfence is on the wrong
side of the clflushopt loop.  clflushopt is ordered with respect to older
stores, not to younger stores.

Rename gnttab_cache_flush()'s helper to avoid colliding in name.
grant_table.c can see the prototype from cache.h so the build fails
otherwise.

This is part of XSA-402.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",9a67ffee3371506e1cbfdfff5b90658d4828f6a2,https://github.com/xen-project/xen/commit/9a67ffee3371506e1cbfdfff5b90658d4828f6a2,xen/arch/x86/flushtlb.c,flush_area_local,"unsigned int flush_area_local(const void *va, unsigned int flags)
{
unsigned int order = (flags - 1) & FLUSH_ORDER_MASK;
if ( flags & (FLUSH_TLB|FLUSH_TLB_GLOBAL) )
{
if ( order == 0 )
{
if ( read_cr4() & X86_CR4_PCIDE )
{
unsigned long addr = (unsigned long)va;
invpcid_flush_one(PCID_PV_PRIV, addr);
invpcid_flush_one(PCID_PV_USER, addr);
if ( opt_xpti_hwdom || opt_xpti_domu )
{
invpcid_flush_one(PCID_PV_PRIV | PCID_PV_XPTI, addr);
invpcid_flush_one(PCID_PV_USER | PCID_PV_XPTI, addr);
}
}
else
asm volatile ( ""invlpg %0""
: : ""m"" (*(const char *)(va)) : ""memory"" );
}
else
do_tlb_flush();
}
if ( flags & FLUSH_HVM_ASID_CORE )
hvm_flush_guest_tlbs();
if ( flags & FLUSH_CACHE )
{
const struct cpuinfo_x86 *c = &current_cpu_data;
unsigned long i, sz = 0;
if ( order < (BITS_PER_LONG - PAGE_SHIFT) )
sz = 1UL << (order + PAGE_SHIFT);
if ( (!(flags & (FLUSH_TLB|FLUSH_TLB_GLOBAL)) ||
(flags & FLUSH_VA_VALID)) &&
c->x86_clflush_size && c->x86_cache_size && sz &&
((sz >> 10) < c->x86_cache_size) )
{
alternative("""", ""sfence"", X86_FEATURE_CLFLUSHOPT);
for ( i = 0; i < sz; i += c->x86_clflush_size )
alternative_input(""ds; clflush %0"",
""data16 clflush %0"",      
X86_FEATURE_CLFLUSHOPT,
""m"" (((const char *)va)[i]));
flags &= ~FLUSH_CACHE;
}
else
{
wbinvd();
}
}
if ( flags & FLUSH_ROOT_PGTBL )
get_cpu_info()->root_pgt_changed = true;
return flags;
}","unsigned int flush_area_local(const void *VAR_0, unsigned int VAR_1)
{
unsigned int VAR_2 = (VAR_1 - 1) & VAR_3;
if ( VAR_1 & (VAR_4|VAR_5) )
{
if ( VAR_2 == 0 )
{
if ( read_cr4() & VAR_6 )
{
unsigned long VAR_7 = (unsigned long)VAR_0;
invpcid_flush_one(VAR_8, VAR_7);
invpcid_flush_one(VAR_9, VAR_7);
if ( VAR_10 || VAR_11 )
{
invpcid_flush_one(VAR_8 | VAR_12, VAR_7);
invpcid_flush_one(VAR_9 | VAR_12, VAR_7);
}
}
else
VAR_13 volatile ( ""invlpg %0""
: : ""m"" (*(const char *)(VAR_0)) : ""memory"" );
}
else
do_tlb_flush();
}
if ( VAR_1 & VAR_14 )
hvm_flush_guest_tlbs();
if ( VAR_1 & VAR_15 )
{
const struct cpuinfo_x86 *VAR_16 = &VAR_17;
unsigned long VAR_18, VAR_19 = 0;
if ( VAR_2 < (VAR_20 - VAR_21) )
VAR_19 = 1UL << (VAR_2 + VAR_21);
if ( (!(VAR_1 & (VAR_4|VAR_5)) ||
(VAR_1 & VAR_22)) &&
VAR_16->x86_clflush_size && VAR_16->x86_cache_size && VAR_19 &&
((VAR_19 >> 10) < VAR_16->x86_cache_size) )
{
alternative("""", ""sfence"", VAR_23);
for ( VAR_18 = 0; VAR_18 < VAR_19; VAR_18 += VAR_16->x86_clflush_size )
alternative_input(""ds; clflush %0"",
""data16 clflush %0"",      
VAR_23,
""m"" (((const char *)VAR_0)[VAR_18]));
VAR_1 &= ~VAR_15;
}
else
{
wbinvd();
}
}
if ( VAR_1 & VAR_24 )
get_cpu_info()->root_pgt_changed = true;
return VAR_1;
}",xen-project/xen/9a67ffee3371506e1cbfdfff5b90658d4828f6a2/flushtlb.c/vul/before/0.json,"unsigned int flush_area_local(const void *va, unsigned int flags)
{
    unsigned int order = (flags - 1) & FLUSH_ORDER_MASK;

    if ( flags & (FLUSH_TLB|FLUSH_TLB_GLOBAL) )
    {
        if ( order == 0 )
        {
            /*
             * We don't INVLPG multi-page regions because the 2M/4M/1G
             * region may not have been mapped with a superpage. Also there
             * are various errata surrounding INVLPG usage on superpages, and
             * a full flush is in any case not *that* expensive.
             */
            if ( read_cr4() & X86_CR4_PCIDE )
            {
                unsigned long addr = (unsigned long)va;

                /*
                 * Flush the addresses for all potential address spaces.
                 * We can't check the current domain for being subject to
                 * XPTI as current might be the idle vcpu while we still have
                 * some XPTI domain TLB entries.
                 * Using invpcid is okay here, as with PCID enabled we always
                 * have global pages disabled.
                 */
                invpcid_flush_one(PCID_PV_PRIV, addr);
                invpcid_flush_one(PCID_PV_USER, addr);
                if ( opt_xpti_hwdom || opt_xpti_domu )
                {
                    invpcid_flush_one(PCID_PV_PRIV | PCID_PV_XPTI, addr);
                    invpcid_flush_one(PCID_PV_USER | PCID_PV_XPTI, addr);
                }
            }
            else
                asm volatile ( ""invlpg %0""
                               : : ""m"" (*(const char *)(va)) : ""memory"" );
        }
        else
            do_tlb_flush();
    }

    if ( flags & FLUSH_HVM_ASID_CORE )
        hvm_flush_guest_tlbs();

    if ( flags & FLUSH_CACHE )
    {
        const struct cpuinfo_x86 *c = &current_cpu_data;
        unsigned long sz = 0;

        if ( order < (BITS_PER_LONG - PAGE_SHIFT) )
            sz = 1UL << (order + PAGE_SHIFT);

        if ( (!(flags & (FLUSH_TLB|FLUSH_TLB_GLOBAL)) ||
              (flags & FLUSH_VA_VALID)) &&
             c->x86_clflush_size && c->x86_cache_size && sz &&
             ((sz >> 10) < c->x86_cache_size) )
        {
            cache_flush(va, sz);
            flags &= ~FLUSH_CACHE;
        }
        else
        {
            wbinvd();
        }
    }

    if ( flags & FLUSH_ROOT_PGTBL )
        get_cpu_info()->root_pgt_changed = true;

    return flags;
}","unsigned int flush_area_local(const void *VAR_0, unsigned int VAR_1)
{
    unsigned int VAR_2 = (VAR_1 - 1) & VAR_3;

    if ( VAR_1 & (VAR_4|VAR_5) )
    {
        if ( VAR_2 == 0 )
        {
            /* COMMENT_0 */
                                                                      
                                                                           
                                                                             
                                                                
               
            if ( read_cr4() & VAR_6 )
            {
                unsigned long VAR_7 = (unsigned long)VAR_0;

                /* COMMENT_6 */
                                                                        
                                                                         
                                                                             
                                                
                                                                             
                                              
                   
                invpcid_flush_one(VAR_8, VAR_7);
                invpcid_flush_one(VAR_9, VAR_7);
                if ( VAR_10 || VAR_11 )
                {
                    invpcid_flush_one(VAR_8 | VAR_12, VAR_7);
                    invpcid_flush_one(VAR_9 | VAR_12, VAR_7);
                }
            }
            else
                VAR_13 volatile ( ""invlpg %0""
                               : : ""m"" (*(const char *)(VAR_0)) : ""memory"" );
        }
        else
            do_tlb_flush();
    }

    if ( VAR_1 & VAR_14 )
        hvm_flush_guest_tlbs();

    if ( VAR_1 & VAR_15 )
    {
        const struct cpuinfo_x86 *VAR_16 = &VAR_17;
        unsigned long VAR_18 = 0;

        if ( VAR_2 < (VAR_19 - VAR_20) )
            VAR_18 = 1UL << (VAR_2 + VAR_20);

        if ( (!(VAR_1 & (VAR_4|VAR_5)) ||
              (VAR_1 & VAR_21)) &&
             VAR_16->x86_clflush_size && VAR_16->x86_cache_size && VAR_18 &&
             ((VAR_18 >> 10) < VAR_16->x86_cache_size) )
        {
            cache_flush(VAR_0, VAR_18);
            VAR_1 &= ~VAR_15;
        }
        else
        {
            wbinvd();
        }
    }

    if ( VAR_1 & VAR_22 )
        get_cpu_info()->root_pgt_changed = true;

    return VAR_1;
}",xen-project/xen/9a67ffee3371506e1cbfdfff5b90658d4828f6a2/flushtlb.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -46,7 +46,7 @@
     if ( flags & FLUSH_CACHE )
     {
         const struct cpuinfo_x86 *c = &current_cpu_data;
-        unsigned long i, sz = 0;
+        unsigned long sz = 0;
 
         if ( order < (BITS_PER_LONG - PAGE_SHIFT) )
             sz = 1UL << (order + PAGE_SHIFT);
@@ -56,12 +56,7 @@
              c->x86_clflush_size && c->x86_cache_size && sz &&
              ((sz >> 10) < c->x86_cache_size) )
         {
-            alternative("""", ""sfence"", X86_FEATURE_CLFLUSHOPT);
-            for ( i = 0; i < sz; i += c->x86_clflush_size )
-                alternative_input(""ds; clflush %0"",
-                                  ""data16 clflush %0"",      /* clflushopt */
-                                  X86_FEATURE_CLFLUSHOPT,
-                                  ""m"" (((const char *)va)[i]));
+            cache_flush(va, sz);
             flags &= ~FLUSH_CACHE;
         }
         else","{'deleted_lines': ['        unsigned long i, sz = 0;', '            alternative("""", ""sfence"", X86_FEATURE_CLFLUSHOPT);', '            for ( i = 0; i < sz; i += c->x86_clflush_size )', '                alternative_input(""ds; clflush %0"",', '                                  ""data16 clflush %0"",      /* clflushopt */', '                                  X86_FEATURE_CLFLUSHOPT,', '                                  ""m"" (((const char *)va)[i]));'], 'added_lines': ['        unsigned long sz = 0;', '            cache_flush(va, sz);']}",True,"x86 pv: Insufficient care with non-coherent mappings T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Xen maintains a type reference count for pages, in addition to a regular reference count. This scheme is used to maintain invariants required for Xen's safety, e.g. PV guests may not have direct writeable access to pagetables; updates need auditing by Xen. Unfortunately, Xen's safety logic doesn't account for CPU-induced cache non-coherency; cases where the CPU can cause the content of the cache to be different to the content in main memory. In such cases, Xen's safety logic can incorrectly conclude that the contents of a page is safe.",6.7,MEDIUM,1,test,2022-06-09T12:22:38Z,4
CVE-2022-26363,['CWE-Other'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86: Split cache_flush() out of cache_writeback()

Subsequent changes will want a fully flushing version.

Use the new helper rather than opencoding it in flush_area_local().  This
resolves an outstanding issue where the conditional sfence is on the wrong
side of the clflushopt loop.  clflushopt is ordered with respect to older
stores, not to younger stores.

Rename gnttab_cache_flush()'s helper to avoid colliding in name.
grant_table.c can see the prototype from cache.h so the build fails
otherwise.

This is part of XSA-402.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",9a67ffee3371506e1cbfdfff5b90658d4828f6a2,https://github.com/xen-project/xen/commit/9a67ffee3371506e1cbfdfff5b90658d4828f6a2,xen/common/grant_table.c,gnttab_cache_flush,"static long
gnttab_cache_flush(XEN_GUEST_HANDLE_PARAM(gnttab_cache_flush_t) uop,
grant_ref_t *cur_ref,
unsigned int count)
{
unsigned int i;
gnttab_cache_flush_t op;
for ( i = 0; i < count; i++ )
{
if ( i && hypercall_preempt_check() )
return i;
if ( unlikely(__copy_from_guest(&op, uop, 1)) )
return -EFAULT;
for ( ; ; )
{
int ret = cache_flush(&op, cur_ref);
if ( ret < 0 )
return ret;
if ( ret == 0 )
break;
if ( hypercall_preempt_check() )
return i;
}
*cur_ref = 0;
guest_handle_add_offset(uop, 1);
}
*cur_ref = 0;
return 0;
}","static long
gnttab_cache_flush(VAR_0(gnttab_cache_flush_t) VAR_1,
grant_ref_t *VAR_2,
unsigned int VAR_3)
{
unsigned int VAR_4;
gnttab_cache_flush_t VAR_5;
for ( VAR_4 = 0; VAR_4 < VAR_3; VAR_4++ )
{
if ( VAR_4 && hypercall_preempt_check() )
return VAR_4;
if ( unlikely(__copy_from_guest(&VAR_5, VAR_1, 1)) )
return -VAR_6;
for ( ; ; )
{
int VAR_7 = cache_flush(&VAR_5, VAR_2);
if ( VAR_7 < 0 )
return VAR_7;
if ( VAR_7 == 0 )
break;
if ( hypercall_preempt_check() )
return VAR_4;
}
*VAR_2 = 0;
guest_handle_add_offset(VAR_1, 1);
}
*VAR_2 = 0;
return 0;
}",,"static long
gnttab_cache_flush(XEN_GUEST_HANDLE_PARAM(gnttab_cache_flush_t) uop,
                      grant_ref_t *cur_ref,
                      unsigned int count)
{
    unsigned int i;
    gnttab_cache_flush_t op;

    for ( i = 0; i < count; i++ )
    {
        if ( i && hypercall_preempt_check() )
            return i;
        if ( unlikely(__copy_from_guest(&op, uop, 1)) )
            return -EFAULT;
        for ( ; ; )
        {
            int ret = _cache_flush(&op, cur_ref);

            if ( ret < 0 )
                return ret;
            if ( ret == 0 )
                break;
            if ( hypercall_preempt_check() )
                return i;
        }
        *cur_ref = 0;
        guest_handle_add_offset(uop, 1);
    }

    *cur_ref = 0;

    return 0;
}","static long
gnttab_cache_flush(VAR_0(gnttab_cache_flush_t) VAR_1,
                      grant_ref_t *VAR_2,
                      unsigned int VAR_3)
{
    unsigned int VAR_4;
    gnttab_cache_flush_t VAR_5;

    for ( VAR_4 = 0; VAR_4 < VAR_3; VAR_4++ )
    {
        if ( VAR_4 && hypercall_preempt_check() )
            return VAR_4;
        if ( unlikely(__copy_from_guest(&VAR_5, VAR_1, 1)) )
            return -VAR_6;
        for ( ; ; )
        {
            int VAR_7 = _cache_flush(&VAR_5, VAR_2);

            if ( VAR_7 < 0 )
                return VAR_7;
            if ( VAR_7 == 0 )
                break;
            if ( hypercall_preempt_check() )
                return VAR_4;
        }
        *VAR_2 = 0;
        guest_handle_add_offset(VAR_1, 1);
    }

    *VAR_2 = 0;

    return 0;
}",,"--- func_before
+++ func_after
@@ -14,7 +14,7 @@
             return -EFAULT;
         for ( ; ; )
         {
-            int ret = cache_flush(&op, cur_ref);
+            int ret = _cache_flush(&op, cur_ref);
 
             if ( ret < 0 )
                 return ret;","{'deleted_lines': ['            int ret = cache_flush(&op, cur_ref);'], 'added_lines': ['            int ret = _cache_flush(&op, cur_ref);']}",True,"x86 pv: Insufficient care with non-coherent mappings T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Xen maintains a type reference count for pages, in addition to a regular reference count. This scheme is used to maintain invariants required for Xen's safety, e.g. PV guests may not have direct writeable access to pagetables; updates need auditing by Xen. Unfortunately, Xen's safety logic doesn't account for CPU-induced cache non-coherency; cases where the CPU can cause the content of the cache to be different to the content in main memory. In such cases, Xen's safety logic can incorrectly conclude that the contents of a page is safe.",6.7,MEDIUM,1,test,2022-06-09T12:22:38Z,4
CVE-2022-26363,['CWE-Other'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/amd: Work around CLFLUSH ordering on older parts

On pre-CLFLUSHOPT AMD CPUs, CLFLUSH is weakely ordered with everything,
including reads and writes to the address, and LFENCE/SFENCE instructions.

This creates a multitude of problematic corner cases, laid out in the manual.
Arrange to use MFENCE on both sides of the CLFLUSH to force proper ordering.

This is part of XSA-402.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",062868a5a8b428b85db589fa9a6d6e43969ffeb9,https://github.com/xen-project/xen/commit/062868a5a8b428b85db589fa9a6d6e43969ffeb9,xen/arch/x86/flushtlb.c,cache_flush,"void cache_flush(const void *addr, unsigned int size)
{
unsigned int clflush_size = current_cpu_data.x86_clflush_size ?: 16;
const void *end = addr + size;
addr -= (unsigned long)addr & (clflush_size - 1);
for ( ; addr < end; addr += clflush_size )
{
alternative_io(""ds; clflush %[p]"",
""data16 clflush %[p]"", 
X86_FEATURE_CLFLUSHOPT,
,
[p] ""m"" (*(const char *)(addr)));
}
alternative("""", ""sfence"", X86_FEATURE_CLFLUSHOPT);
}","void cache_flush(const void *VAR_0, unsigned int VAR_1)
{
unsigned int VAR_2 = VAR_3.x86_clflush_size ?VAR_4: 16;
const void *VAR_5 = VAR_0 + VAR_1;
VAR_0 -= (unsigned long)VAR_0 & (VAR_2 - 1);
for ( ; VAR_0 < VAR_5; VAR_0 += VAR_2 )
{
alternative_io(""ds; clflush %[p]"",
""data16 clflush %[p]"", 
VAR_6,
,
[VAR_7] ""m"" (*(const char *)(VAR_0)));
}
alternative("""", ""sfence"", VAR_6);
}",xen-project/xen/062868a5a8b428b85db589fa9a6d6e43969ffeb9/flushtlb.c/vul/before/0.json,"void cache_flush(const void *addr, unsigned int size)
{
    /*
     * This function may be called before current_cpu_data is established.
     * Hence a fallback is needed to prevent the loop below becoming infinite.
     */
    unsigned int clflush_size = current_cpu_data.x86_clflush_size ?: 16;
    const void *end = addr + size;

    alternative("""", ""mfence"", X86_BUG_CLFLUSH_MFENCE);

    addr -= (unsigned long)addr & (clflush_size - 1);
    for ( ; addr < end; addr += clflush_size )
    {
        /*
         * Note regarding the ""ds"" prefix use: it's faster to do a clflush
         * + prefix than a clflush + nop, and hence the prefix is added instead
         * of letting the alternative framework fill the gap by appending nops.
         */
        alternative_io(""ds; clflush %[p]"",
                       ""data16 clflush %[p]"", /* clflushopt */
                       X86_FEATURE_CLFLUSHOPT,
                       /* no outputs */,
                       [p] ""m"" (*(const char *)(addr)));
    }

    alternative_2("""",
                  ""sfence"", X86_FEATURE_CLFLUSHOPT,
                  ""mfence"", X86_BUG_CLFLUSH_MFENCE);
}","void cache_flush(const void *VAR_0, unsigned int VAR_1)
{
    /* COMMENT_0 */
                                                                          
                                                                              
       
    unsigned int VAR_2 = VAR_3.x86_clflush_size ?VAR_4: 16;
    const void *VAR_5 = VAR_0 + VAR_1;

    alternative("""", ""mfence"", VAR_6);

    VAR_0 -= (unsigned long)VAR_0 & (VAR_2 - 1);
    for ( ; VAR_0 < VAR_5; VAR_0 += VAR_2 )
    {
        /* COMMENT_4 */
                                                                          
                                                                               
                                                                               
           
        alternative_io(""ds; clflush %[p]"",
                       ""data16 clflush %[p]"", /* COMMENT_9 */
                       VAR_7,
                       /* COMMENT_10 */,
                       [VAR_8] ""m"" (*(const char *)(VAR_0)));
    }

    alternative_2("""",
                  ""sfence"", VAR_7,
                  ""mfence"", VAR_6);
}",xen-project/xen/062868a5a8b428b85db589fa9a6d6e43969ffeb9/flushtlb.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,6 +6,8 @@
      */
     unsigned int clflush_size = current_cpu_data.x86_clflush_size ?: 16;
     const void *end = addr + size;
+
+    alternative("""", ""mfence"", X86_BUG_CLFLUSH_MFENCE);
 
     addr -= (unsigned long)addr & (clflush_size - 1);
     for ( ; addr < end; addr += clflush_size )
@@ -22,5 +24,7 @@
                        [p] ""m"" (*(const char *)(addr)));
     }
 
-    alternative("""", ""sfence"", X86_FEATURE_CLFLUSHOPT);
+    alternative_2("""",
+                  ""sfence"", X86_FEATURE_CLFLUSHOPT,
+                  ""mfence"", X86_BUG_CLFLUSH_MFENCE);
 }","{'deleted_lines': ['    alternative("""", ""sfence"", X86_FEATURE_CLFLUSHOPT);'], 'added_lines': ['', '    alternative("""", ""mfence"", X86_BUG_CLFLUSH_MFENCE);', '    alternative_2("""",', '                  ""sfence"", X86_FEATURE_CLFLUSHOPT,', '                  ""mfence"", X86_BUG_CLFLUSH_MFENCE);']}",True,"x86 pv: Insufficient care with non-coherent mappings T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Xen maintains a type reference count for pages, in addition to a regular reference count. This scheme is used to maintain invariants required for Xen's safety, e.g. PV guests may not have direct writeable access to pagetables; updates need auditing by Xen. Unfortunately, Xen's safety logic doesn't account for CPU-induced cache non-coherency; cases where the CPU can cause the content of the cache to be different to the content in main memory. In such cases, Xen's safety logic can incorrectly conclude that the contents of a page is safe.",6.7,MEDIUM,1,test,2022-06-09T12:23:07Z,4
CVE-2022-26363,['CWE-Other'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/amd: Work around CLFLUSH ordering on older parts

On pre-CLFLUSHOPT AMD CPUs, CLFLUSH is weakely ordered with everything,
including reads and writes to the address, and LFENCE/SFENCE instructions.

This creates a multitude of problematic corner cases, laid out in the manual.
Arrange to use MFENCE on both sides of the CLFLUSH to force proper ordering.

This is part of XSA-402.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",062868a5a8b428b85db589fa9a6d6e43969ffeb9,https://github.com/xen-project/xen/commit/062868a5a8b428b85db589fa9a6d6e43969ffeb9,xen/arch/x86/cpu/amd.c,init_amd,"static void cf_check init_amd(struct cpuinfo_x86 *c)
{
u32 l, h;
unsigned long long value;
if (c->x86 == 15) {
rdmsrl(MSR_K8_HWCR, value);
value |= 1 << 6;
wrmsrl(MSR_K8_HWCR, value);
}
__clear_bit(X86_FEATURE_PBE, c->x86_capability);
if (c->x86 == 0xf && c->x86_model < 0x14
&& cpu_has(c, X86_FEATURE_LAHF_LM)) {
__clear_bit(X86_FEATURE_LAHF_LM, c->x86_capability);
if (!rdmsr_amd_safe(0xc001100d, &l, &h))
wrmsr_amd_safe(0xc001100d, l, h & ~1);
}
if (c == &boot_cpu_data && !cpu_has(c, X86_FEATURE_RSTR_FP_ERR_PTRS))
setup_force_cpu_cap(X86_BUG_FPU_PTRS);
if (c->x86 == 0x0f || c->x86 == 0x11)
__set_bit(X86_FEATURE_LFENCE_DISPATCH, c->x86_capability);
else 
amd_init_lfence(c);
amd_init_ssbd(c);
if (!cpu_has_hypervisor && !cpu_has_nscb && c == &boot_cpu_data &&
c->x86 == 0x17)
detect_zen2_null_seg_behaviour();
if (c == &boot_cpu_data && !cpu_has_nscb)
setup_force_cpu_cap(X86_BUG_NULL_SEG);
if (!cpu_has_lfence_dispatch)
__set_bit(X86_FEATURE_MFENCE_RDTSC, c->x86_capability);
switch(c->x86)
{
case 0xf ... 0x11:
disable_c1e(NULL);
if (acpi_smi_cmd && (acpi_enable_value | acpi_disable_value))
amd_acpi_c1e_quirk = true;
break;
case 0x15: case 0x16:
if (c == &boot_cpu_data &&
cpu_has(c, X86_FEATURE_RDRAND) &&
!is_forced_cpu_cap(X86_FEATURE_RDRAND)) {
static const char __initconst text[] =
""RDRAND may cease to work on this hardware upon resume from S3.\n""
""Please choose an explicit cpuid={no-}rdrand setting.\n"";
setup_clear_cpu_cap(X86_FEATURE_RDRAND);
warning_add(text);
}
break;
}
display_cacheinfo(c);
if (c->extended_cpuid_level >= 0x80000008) {
c->x86_max_cores = (cpuid_ecx(0x80000008) & 0xff) + 1;
}
if (c->extended_cpuid_level >= 0x80000007) {
if (cpu_has(c, X86_FEATURE_ITSC)) {
__set_bit(X86_FEATURE_CONSTANT_TSC, c->x86_capability);
__set_bit(X86_FEATURE_NONSTOP_TSC, c->x86_capability);
if (c->x86 != 0x11)
__set_bit(X86_FEATURE_TSC_RELIABLE,
c->x86_capability);
}
}
if ((c->x86 == 0x15) &&
(c->x86_model >= 0x10) && (c->x86_model <= 0x1f) &&
!cpu_has(c, X86_FEATURE_TOPOEXT) &&
!rdmsr_safe(MSR_K8_EXT_FEATURE_MASK, value)) {
value |= 1ULL << 54;
wrmsr_safe(MSR_K8_EXT_FEATURE_MASK, value);
rdmsrl(MSR_K8_EXT_FEATURE_MASK, value);
if (value & (1ULL << 54)) {
__set_bit(X86_FEATURE_TOPOEXT, c->x86_capability);
printk(KERN_INFO ""CPU: Re-enabling disabled ""
""Topology Extensions Support\n"");
}
}
if (c->x86 == 0x15 && c->x86_model >= 0x02 && c->x86_model < 0x20 &&
!rdmsr_safe(MSR_AMD64_IC_CFG, value) && (value & 0x1e) != 0x1e)
wrmsr_safe(MSR_AMD64_IC_CFG, value | 0x1e);
amd_get_topology(c);
if (c->x86 == 0x10)
__clear_bit(X86_FEATURE_MONITOR, c->x86_capability);
if (!cpu_has_amd_erratum(c, AMD_ERRATUM_121))
opt_allow_unsafe = 1;
else if (opt_allow_unsafe < 0)
panic(""Xen will not boot on this CPU for security reasons""
""Pass \""allow_unsafe\"" if you're trusting all your""
"" (PV) guest kernels.\n"");
else if (!opt_allow_unsafe && c == &boot_cpu_data)
printk(KERN_WARNING
""*** Xen will not allow creation of DomU-s on""
"" this CPU for security reasons. ***\n""
KERN_WARNING
""*** Pass \""allow_unsafe\"" if you're trusting""
"" all your (PV) guest kernels. ***\n"");
if (c->x86 == 0x16 && c->x86_model <= 0xf) {
if (c == &boot_cpu_data) {
l = pci_conf_read32(PCI_SBDF(0, 0, 0x18, 3), 0x58);
h = pci_conf_read32(PCI_SBDF(0, 0, 0x18, 3), 0x5c);
if ((l & 0x1f) | (h & 0x1))
printk(KERN_WARNING
""Applying workaround for erratum 792: %s%s%s\n"",
(l & 0x1f) ? ""clearing D18F3x58[4:0]"" : """",
((l & 0x1f) && (h & 0x1)) ? "" and "" : """",
(h & 0x1) ? ""clearing D18F3x5C[0]"" : """");
if (l & 0x1f)
pci_conf_write32(PCI_SBDF(0, 0, 0x18, 3), 0x58,
l & ~0x1f);
if (h & 0x1)
pci_conf_write32(PCI_SBDF(0, 0, 0x18, 3), 0x5c,
h & ~0x1);
}
rdmsrl(MSR_AMD64_LS_CFG, value);
if (!(value & (1 << 15))) {
static bool_t warned;
if (c == &boot_cpu_data || opt_cpu_info ||
!test_and_set_bool(warned))
printk(KERN_WARNING
""CPU%u: Applying workaround for erratum 793\n"",
smp_processor_id());
wrmsrl(MSR_AMD64_LS_CFG, value | (1 << 15));
}
} else if (c->x86 == 0x12) {
rdmsrl(MSR_AMD64_DE_CFG, value);
if (!(value & (1U << 31))) {
static bool warned;
if (c == &boot_cpu_data || opt_cpu_info ||
!test_and_set_bool(warned))
printk(KERN_WARNING
""CPU%u: Applying workaround for erratum 665\n"",
smp_processor_id());
wrmsrl(MSR_AMD64_DE_CFG, value | (1U << 31));
}
}
__clear_bit(X86_FEATURE_SEP, c->x86_capability);
if (c->x86 == 0x10) {
if (c == &boot_cpu_data)
check_enable_amd_mmconf_dmi();
fam10h_check_enable_mmcfg();
rdmsrl(MSR_F10_BU_CFG2, value);
value &= ~(1ULL << 24);
wrmsrl(MSR_F10_BU_CFG2, value);
}
if ( opt_arat && c->x86 > 0x11 )
__set_bit(X86_FEATURE_ARAT, c->x86_capability);
if (nmi_watchdog != NMI_LOCAL_APIC && c->x86 < 0x14) {
wrmsrl(MSR_K7_PERFCTR0, 0);
wrmsrl(MSR_K7_PERFCTR1, 0);
wrmsrl(MSR_K7_PERFCTR2, 0);
wrmsrl(MSR_K7_PERFCTR3, 0);
}
if (cpu_has(c, X86_FEATURE_EFRO)) {
rdmsr(MSR_K8_HWCR, l, h);
l |= (1 << 27); 
wrmsr(MSR_K8_HWCR, l, h);
}
if ((smp_processor_id() == 1) && !cpu_has(c, X86_FEATURE_ITSC))
disable_c1_ramping();
check_syscfg_dram_mod_en();
amd_log_freq(c);
}","static void VAR_0 init_amd(struct cpuinfo_x86 *VAR_1)
{
u32 VAR_2, VAR_3;
unsigned long long VAR_4;
if (VAR_1->x86 == 15) {
rdmsrl(VAR_5, VAR_4);
VAR_4 |= 1 << 6;
wrmsrl(VAR_5, VAR_4);
}
__clear_bit(VAR_6, VAR_1->x86_capability);
if (VAR_1->x86 == 0xf && VAR_1->x86_model < 0x14
&& cpu_has(VAR_1, VAR_7)) {
__clear_bit(VAR_7, VAR_1->x86_capability);
if (!rdmsr_amd_safe(0xc001100d, &VAR_2, &VAR_3))
wrmsr_amd_safe(0xc001100d, VAR_2, VAR_3 & ~1);
}
if (VAR_1 == &VAR_8 && !cpu_has(VAR_1, VAR_9))
setup_force_cpu_cap(VAR_10);
if (VAR_1->x86 == 0x0f || VAR_1->x86 == 0x11)
__set_bit(VAR_11, VAR_1->x86_capability);
else 
amd_init_lfence(VAR_1);
amd_init_ssbd(VAR_1);
if (!VAR_12 && !VAR_13 && VAR_1 == &VAR_8 &&
VAR_1->x86 == 0x17)
detect_zen2_null_seg_behaviour();
if (VAR_1 == &VAR_8 && !VAR_13)
setup_force_cpu_cap(VAR_14);
if (!VAR_15)
__set_bit(VAR_16, VAR_1->x86_capability);
switch(VAR_1->x86)
{
case 0xf ... 0x11:
disable_c1e(NULL);
if (VAR_17 && (VAR_18 | VAR_19))
VAR_20 = true;
break;
case 0x15: case 0x16:
if (VAR_1 == &VAR_8 &&
cpu_has(VAR_1, VAR_21) &&
!is_forced_cpu_cap(VAR_21)) {
static const char VAR_22 VAR_23[] =
""RDRAND may cease to work on this hardware upon resume from S3.\n""
""Please choose an explicit cpuid={no-}rdrand setting.\n"";
setup_clear_cpu_cap(VAR_21);
warning_add(VAR_23);
}
break;
}
display_cacheinfo(VAR_1);
if (VAR_1->extended_cpuid_level >= 0x80000008) {
VAR_1->x86_max_cores = (cpuid_ecx(0x80000008) & 0xff) + 1;
}
if (VAR_1->extended_cpuid_level >= 0x80000007) {
if (cpu_has(VAR_1, VAR_24)) {
__set_bit(VAR_25, VAR_1->x86_capability);
__set_bit(VAR_26, VAR_1->x86_capability);
if (VAR_1->x86 != 0x11)
__set_bit(VAR_27,
VAR_1->x86_capability);
}
}
if ((VAR_1->x86 == 0x15) &&
(VAR_1->x86_model >= 0x10) && (VAR_1->x86_model <= 0x1f) &&
!cpu_has(VAR_1, VAR_28) &&
!rdmsr_safe(VAR_29, VAR_4)) {
VAR_4 |= 1ULL << 54;
wrmsr_safe(VAR_29, VAR_4);
rdmsrl(VAR_29, VAR_4);
if (VAR_4 & (1ULL << 54)) {
__set_bit(VAR_28, VAR_1->x86_capability);
printk(KERN_INFO ""CPU: Re-enabling disabled ""
""Topology Extensions Support\n"");
}
}
if (VAR_1->x86 == 0x15 && VAR_1->x86_model >= 0x02 && VAR_1->x86_model < 0x20 &&
!rdmsr_safe(VAR_30, VAR_4) && (VAR_4 & 0x1e) != 0x1e)
wrmsr_safe(VAR_30, VAR_4 | 0x1e);
amd_get_topology(VAR_1);
if (VAR_1->x86 == 0x10)
__clear_bit(VAR_31, VAR_1->x86_capability);
if (!cpu_has_amd_erratum(VAR_1, VAR_32))
VAR_33 = 1;
else if (VAR_33 < 0)
panic(""Xen will not boot on this CPU for security reasons""
""Pass \""allow_unsafe\"" if you're trusting all your""
"" (PV) guest kernels.\n"");
else if (!VAR_33 && VAR_1 == &VAR_8)
printk(KERN_WARNING
""*** Xen will not allow creation of DomU-s on""
"" this CPU for security reasons. ***\n""
KERN_WARNING
""*** Pass \""allow_unsafe\"" if you're trusting""
"" all your (PV) guest kernels. ***\n"");
if (VAR_1->x86 == 0x16 && VAR_1->x86_model <= 0xf) {
if (VAR_1 == &VAR_8) {
VAR_2 = pci_conf_read32(PCI_SBDF(0, 0, 0x18, 3), 0x58);
VAR_3 = pci_conf_read32(PCI_SBDF(0, 0, 0x18, 3), 0x5c);
if ((VAR_2 & 0x1f) | (VAR_3 & 0x1))
printk(KERN_WARNING
""Applying workaround for erratum 792: %s%s%s\n"",
(VAR_2 & 0x1f) ? ""clearing D18F3x58[4:0]"" : """",
((VAR_2 & 0x1f) && (VAR_3 & 0x1)) ? "" and "" : """",
(VAR_3 & 0x1) ? ""clearing D18F3x5C[0]"" : """");
if (VAR_2 & 0x1f)
pci_conf_write32(PCI_SBDF(0, 0, 0x18, 3), 0x58,
VAR_2 & ~0x1f);
if (VAR_3 & 0x1)
pci_conf_write32(PCI_SBDF(0, 0, 0x18, 3), 0x5c,
VAR_3 & ~0x1);
}
rdmsrl(VAR_34, VAR_4);
if (!(VAR_4 & (1 << 15))) {
static bool_t VAR_35;
if (VAR_1 == &VAR_8 || VAR_36 ||
!test_and_set_bool(VAR_35))
printk(KERN_WARNING
""CPU%u: Applying workaround for erratum 793\n"",
smp_processor_id());
wrmsrl(VAR_34, VAR_4 | (1 << 15));
}
} else if (VAR_1->x86 == 0x12) {
rdmsrl(VAR_37, VAR_4);
if (!(VAR_4 & (1U << 31))) {
static bool VAR_35;
if (VAR_1 == &VAR_8 || VAR_36 ||
!test_and_set_bool(VAR_35))
printk(KERN_WARNING
""CPU%u: Applying workaround for erratum 665\n"",
smp_processor_id());
wrmsrl(VAR_37, VAR_4 | (1U << 31));
}
}
__clear_bit(VAR_38, VAR_1->x86_capability);
if (VAR_1->x86 == 0x10) {
if (VAR_1 == &VAR_8)
check_enable_amd_mmconf_dmi();
fam10h_check_enable_mmcfg();
rdmsrl(VAR_39, VAR_4);
VAR_4 &= ~(1ULL << 24);
wrmsrl(VAR_39, VAR_4);
}
if ( VAR_40 && VAR_1->x86 > 0x11 )
__set_bit(VAR_41, VAR_1->x86_capability);
if (VAR_42 != VAR_43 && VAR_1->x86 < 0x14) {
wrmsrl(VAR_44, 0);
wrmsrl(VAR_45, 0);
wrmsrl(VAR_46, 0);
wrmsrl(VAR_47, 0);
}
if (cpu_has(VAR_1, VAR_48)) {
rdmsr(VAR_5, VAR_2, VAR_3);
VAR_2 |= (1 << 27); 
wrmsr(VAR_5, VAR_2, VAR_3);
}
if ((smp_processor_id() == 1) && !cpu_has(VAR_1, VAR_24))
disable_c1_ramping();
check_syscfg_dram_mod_en();
amd_log_freq(VAR_1);
}",,"static void cf_check init_amd(struct cpuinfo_x86 *c)
{
	u32 l, h;

	unsigned long long value;

	/* Disable TLB flush filter by setting HWCR.FFDIS on K8
	 * bit 6 of msr C001_0015
	 *
	 * Errata 63 for SH-B3 steppings
	 * Errata 122 for all steppings (F+ have it disabled by default)
	 */
	if (c->x86 == 15) {
		rdmsrl(MSR_K8_HWCR, value);
		value |= 1 << 6;
		wrmsrl(MSR_K8_HWCR, value);
	}

	/*
	 * Some AMD CPUs duplicate the 3DNow bit in base and extended CPUID
	 * leaves.  Unfortunately, this aliases PBE on Intel CPUs. Clobber the
	 * alias, leaving 3DNow in the extended leaf.
	 */
	__clear_bit(X86_FEATURE_PBE, c->x86_capability);
	
	if (c->x86 == 0xf && c->x86_model < 0x14
	    && cpu_has(c, X86_FEATURE_LAHF_LM)) {
		/*
		 * Some BIOSes incorrectly force this feature, but only K8
		 * revision D (model = 0x14) and later actually support it.
		 * (AMD Erratum #110, docId: 25759).
		 */
		__clear_bit(X86_FEATURE_LAHF_LM, c->x86_capability);
		if (!rdmsr_amd_safe(0xc001100d, &l, &h))
			wrmsr_amd_safe(0xc001100d, l, h & ~1);
	}

	/*
	 * Older AMD CPUs don't save/load FOP/FIP/FDP unless an FPU exception
	 * is pending.  Xen works around this at (F)XRSTOR time.
	 */
	if (c == &boot_cpu_data && !cpu_has(c, X86_FEATURE_RSTR_FP_ERR_PTRS))
		setup_force_cpu_cap(X86_BUG_FPU_PTRS);

	if (c->x86 == 0x0f || c->x86 == 0x11)
		/* Always dispatch serialising on this hardare. */
		__set_bit(X86_FEATURE_LFENCE_DISPATCH, c->x86_capability);
	else /* Implicily ""== 0x10 || >= 0x12"" by being 64bit. */
		amd_init_lfence(c);

	amd_init_ssbd(c);

	/* Probe for NSCB on Zen2 CPUs when not virtualised */
	if (!cpu_has_hypervisor && !cpu_has_nscb && c == &boot_cpu_data &&
	    c->x86 == 0x17)
		detect_zen2_null_seg_behaviour();

	/*
	 * AMD CPUs before Zen2 don't clear segment bases/limits when loading
	 * a NULL selector.
	 */
	if (c == &boot_cpu_data && !cpu_has_nscb)
		setup_force_cpu_cap(X86_BUG_NULL_SEG);

	/* MFENCE stops RDTSC speculation */
	if (!cpu_has_lfence_dispatch)
		__set_bit(X86_FEATURE_MFENCE_RDTSC, c->x86_capability);

	/*
	 * On pre-CLFLUSHOPT AMD CPUs, CLFLUSH is weakly ordered with
	 * everything, including reads and writes to address, and
	 * LFENCE/SFENCE instructions.
	 */
	if (!cpu_has_clflushopt)
		setup_force_cpu_cap(X86_BUG_CLFLUSH_MFENCE);

	switch(c->x86)
	{
	case 0xf ... 0x11:
		disable_c1e(NULL);
		if (acpi_smi_cmd && (acpi_enable_value | acpi_disable_value))
			amd_acpi_c1e_quirk = true;
		break;

	case 0x15: case 0x16:
		/*
		 * There are some Fam15/Fam16 systems where upon resume from S3
		 * firmware fails to re-setup properly functioning RDRAND.
		 * By the time we can spot the problem, it is too late to take
		 * action, and there is nothing Xen can do to repair the problem.
		 * Clear the feature unless force-enabled on the command line.
		 */
		if (c == &boot_cpu_data &&
		    cpu_has(c, X86_FEATURE_RDRAND) &&
		    !is_forced_cpu_cap(X86_FEATURE_RDRAND)) {
			static const char __initconst text[] =
				""RDRAND may cease to work on this hardware upon resume from S3.\n""
				""Please choose an explicit cpuid={no-}rdrand setting.\n"";

			setup_clear_cpu_cap(X86_FEATURE_RDRAND);
			warning_add(text);
		}
		break;
	}

	display_cacheinfo(c);

	if (c->extended_cpuid_level >= 0x80000008) {
		c->x86_max_cores = (cpuid_ecx(0x80000008) & 0xff) + 1;
	}

	if (c->extended_cpuid_level >= 0x80000007) {
		if (cpu_has(c, X86_FEATURE_ITSC)) {
			__set_bit(X86_FEATURE_CONSTANT_TSC, c->x86_capability);
			__set_bit(X86_FEATURE_NONSTOP_TSC, c->x86_capability);
			if (c->x86 != 0x11)
				__set_bit(X86_FEATURE_TSC_RELIABLE,
					  c->x86_capability);
		}
	}

	/* re-enable TopologyExtensions if switched off by BIOS */
	if ((c->x86 == 0x15) &&
	    (c->x86_model >= 0x10) && (c->x86_model <= 0x1f) &&
	    !cpu_has(c, X86_FEATURE_TOPOEXT) &&
	    !rdmsr_safe(MSR_K8_EXT_FEATURE_MASK, value)) {
		value |= 1ULL << 54;
		wrmsr_safe(MSR_K8_EXT_FEATURE_MASK, value);
		rdmsrl(MSR_K8_EXT_FEATURE_MASK, value);
		if (value & (1ULL << 54)) {
			__set_bit(X86_FEATURE_TOPOEXT, c->x86_capability);
			printk(KERN_INFO ""CPU: Re-enabling disabled ""
			       ""Topology Extensions Support\n"");
		}
	}

	/*
	 * The way access filter has a performance penalty on some workloads.
	 * Disable it on the affected CPUs.
	 */
	if (c->x86 == 0x15 && c->x86_model >= 0x02 && c->x86_model < 0x20 &&
	    !rdmsr_safe(MSR_AMD64_IC_CFG, value) && (value & 0x1e) != 0x1e)
		wrmsr_safe(MSR_AMD64_IC_CFG, value | 0x1e);

        amd_get_topology(c);

	/* Pointless to use MWAIT on Family10 as it does not deep sleep. */
	if (c->x86 == 0x10)
		__clear_bit(X86_FEATURE_MONITOR, c->x86_capability);

	if (!cpu_has_amd_erratum(c, AMD_ERRATUM_121))
		opt_allow_unsafe = 1;
	else if (opt_allow_unsafe < 0)
		panic(""Xen will not boot on this CPU for security reasons""
		      ""Pass \""allow_unsafe\"" if you're trusting all your""
		      "" (PV) guest kernels.\n"");
	else if (!opt_allow_unsafe && c == &boot_cpu_data)
		printk(KERN_WARNING
		       ""*** Xen will not allow creation of DomU-s on""
		       "" this CPU for security reasons. ***\n""
		       KERN_WARNING
		       ""*** Pass \""allow_unsafe\"" if you're trusting""
		       "" all your (PV) guest kernels. ***\n"");

	if (c->x86 == 0x16 && c->x86_model <= 0xf) {
		if (c == &boot_cpu_data) {
			l = pci_conf_read32(PCI_SBDF(0, 0, 0x18, 3), 0x58);
			h = pci_conf_read32(PCI_SBDF(0, 0, 0x18, 3), 0x5c);
			if ((l & 0x1f) | (h & 0x1))
				printk(KERN_WARNING
				       ""Applying workaround for erratum 792: %s%s%s\n"",
				       (l & 0x1f) ? ""clearing D18F3x58[4:0]"" : """",
				       ((l & 0x1f) && (h & 0x1)) ? "" and "" : """",
				       (h & 0x1) ? ""clearing D18F3x5C[0]"" : """");

			if (l & 0x1f)
				pci_conf_write32(PCI_SBDF(0, 0, 0x18, 3), 0x58,
						 l & ~0x1f);

			if (h & 0x1)
				pci_conf_write32(PCI_SBDF(0, 0, 0x18, 3), 0x5c,
						 h & ~0x1);
		}

		rdmsrl(MSR_AMD64_LS_CFG, value);
		if (!(value & (1 << 15))) {
			static bool_t warned;

			if (c == &boot_cpu_data || opt_cpu_info ||
			    !test_and_set_bool(warned))
				printk(KERN_WARNING
				       ""CPU%u: Applying workaround for erratum 793\n"",
				       smp_processor_id());
			wrmsrl(MSR_AMD64_LS_CFG, value | (1 << 15));
		}
	} else if (c->x86 == 0x12) {
		rdmsrl(MSR_AMD64_DE_CFG, value);
		if (!(value & (1U << 31))) {
			static bool warned;

			if (c == &boot_cpu_data || opt_cpu_info ||
			    !test_and_set_bool(warned))
				printk(KERN_WARNING
				       ""CPU%u: Applying workaround for erratum 665\n"",
				       smp_processor_id());
			wrmsrl(MSR_AMD64_DE_CFG, value | (1U << 31));
		}
	}

	/* AMD CPUs do not support SYSENTER outside of legacy mode. */
	__clear_bit(X86_FEATURE_SEP, c->x86_capability);

	if (c->x86 == 0x10) {
		/* do this for boot cpu */
		if (c == &boot_cpu_data)
			check_enable_amd_mmconf_dmi();

		fam10h_check_enable_mmcfg();

		/*
		 * On family 10h BIOS may not have properly enabled WC+
		 * support, causing it to be converted to CD memtype. This may
		 * result in performance degradation for certain nested-paging
		 * guests. Prevent this conversion by clearing bit 24 in
		 * MSR_F10_BU_CFG2.
		 */
		rdmsrl(MSR_F10_BU_CFG2, value);
		value &= ~(1ULL << 24);
		wrmsrl(MSR_F10_BU_CFG2, value);
	}

	/*
	 * Family 0x12 and above processors have APIC timer
	 * running in deep C states.
	 */
	if ( opt_arat && c->x86 > 0x11 )
		__set_bit(X86_FEATURE_ARAT, c->x86_capability);

	/*
	 * Prior to Family 0x14, perf counters are not reset during warm reboot.
	 * We have to reset them manually.
	 */
	if (nmi_watchdog != NMI_LOCAL_APIC && c->x86 < 0x14) {
		wrmsrl(MSR_K7_PERFCTR0, 0);
		wrmsrl(MSR_K7_PERFCTR1, 0);
		wrmsrl(MSR_K7_PERFCTR2, 0);
		wrmsrl(MSR_K7_PERFCTR3, 0);
	}

	if (cpu_has(c, X86_FEATURE_EFRO)) {
		rdmsr(MSR_K8_HWCR, l, h);
		l |= (1 << 27); /* Enable read-only APERF/MPERF bit */
		wrmsr(MSR_K8_HWCR, l, h);
	}

	/* Prevent TSC drift in non single-processor, single-core platforms. */
	if ((smp_processor_id() == 1) && !cpu_has(c, X86_FEATURE_ITSC))
		disable_c1_ramping();

	check_syscfg_dram_mod_en();

	amd_log_freq(c);
}","static void VAR_0 init_amd(struct cpuinfo_x86 *VAR_1)
{
	u32 VAR_2, VAR_3;

	unsigned long long VAR_4;

	/* COMMENT_0 */
                          
   
                                 
                                                                 
    
	if (VAR_1->x86 == 15) {
		rdmsrl(VAR_5, VAR_4);
		VAR_4 |= 1 << 6;
		wrmsrl(VAR_5, VAR_4);
	}

	/* COMMENT_6 */
                                                                    
                                                                       
                                              
    
	__clear_bit(VAR_6, VAR_1->x86_capability);
	
	if (VAR_1->x86 == 0xf && VAR_1->x86_model < 0x14
	    && cpu_has(VAR_1, VAR_7)) {
		/* COMMENT_11 */
                                                            
                                                             
                                      
     
		__clear_bit(VAR_7, VAR_1->x86_capability);
		if (!rdmsr_amd_safe(0xc001100d, &VAR_2, &VAR_3))
			wrmsr_amd_safe(0xc001100d, VAR_2, VAR_3 & ~1);
	}

	/* COMMENT_16 */
                                                                      
                                                         
    
	if (VAR_1 == &VAR_8 && !cpu_has(VAR_1, VAR_9))
		setup_force_cpu_cap(VAR_10);

	if (VAR_1->x86 == 0x0f || VAR_1->x86 == 0x11)
		/* COMMENT_20 */
		__set_bit(VAR_11, VAR_1->x86_capability);
	else /* COMMENT_21 */
		amd_init_lfence(VAR_1);

	amd_init_ssbd(VAR_1);

	/* COMMENT_22 */
	if (!VAR_12 && !VAR_13 && VAR_1 == &VAR_8 &&
	    VAR_1->x86 == 0x17)
		detect_zen2_null_seg_behaviour();

	/* COMMENT_23 */
                                                                      
                    
    
	if (VAR_1 == &VAR_8 && !VAR_13)
		setup_force_cpu_cap(VAR_14);

	/* COMMENT_27 */
	if (!VAR_15)
		__set_bit(VAR_16, VAR_1->x86_capability);

	/* COMMENT_28 */
                                                              
                                                          
                               
    
	if (!VAR_17)
		setup_force_cpu_cap(VAR_18);

	switch(VAR_1->x86)
	{
	case 0xf ... 0x11:
		disable_c1e(NULL);
		if (VAR_19 && (VAR_20 | VAR_21))
			VAR_22 = true;
		break;

	case 0x15: case 0x16:
		/* COMMENT_33 */
                                                                 
                                                            
                                                                
                                                                   
                                                                
     
		if (VAR_1 == &VAR_8 &&
		    cpu_has(VAR_1, VAR_23) &&
		    !is_forced_cpu_cap(VAR_23)) {
			static const char VAR_24 VAR_25[] =
				""RDRAND may cease to work on this hardware upon resume from S3.\n""
				""Please choose an explicit cpuid={no-}rdrand setting.\n"";

			setup_clear_cpu_cap(VAR_23);
			warning_add(VAR_25);
		}
		break;
	}

	display_cacheinfo(VAR_1);

	if (VAR_1->extended_cpuid_level >= 0x80000008) {
		VAR_1->x86_max_cores = (cpuid_ecx(0x80000008) & 0xff) + 1;
	}

	if (VAR_1->extended_cpuid_level >= 0x80000007) {
		if (cpu_has(VAR_1, VAR_26)) {
			__set_bit(VAR_27, VAR_1->x86_capability);
			__set_bit(VAR_28, VAR_1->x86_capability);
			if (VAR_1->x86 != 0x11)
				__set_bit(VAR_29,
					  VAR_1->x86_capability);
		}
	}

	/* COMMENT_40 */
	if ((VAR_1->x86 == 0x15) &&
	    (VAR_1->x86_model >= 0x10) && (VAR_1->x86_model <= 0x1f) &&
	    !cpu_has(VAR_1, VAR_30) &&
	    !rdmsr_safe(VAR_31, VAR_4)) {
		VAR_4 |= 1ULL << 54;
		wrmsr_safe(VAR_31, VAR_4);
		rdmsrl(VAR_31, VAR_4);
		if (VAR_4 & (1ULL << 54)) {
			__set_bit(VAR_30, VAR_1->x86_capability);
			printk(KERN_INFO ""CPU: Re-enabling disabled ""
			       ""Topology Extensions Support\n"");
		}
	}

	/* COMMENT_41 */
                                                                      
                                    
    
	if (VAR_1->x86 == 0x15 && VAR_1->x86_model >= 0x02 && VAR_1->x86_model < 0x20 &&
	    !rdmsr_safe(VAR_32, VAR_4) && (VAR_4 & 0x1e) != 0x1e)
		wrmsr_safe(VAR_32, VAR_4 | 0x1e);

        amd_get_topology(VAR_1);

	/* COMMENT_45 */
	if (VAR_1->x86 == 0x10)
		__clear_bit(VAR_33, VAR_1->x86_capability);

	if (!cpu_has_amd_erratum(VAR_1, VAR_34))
		VAR_35 = 1;
	else if (VAR_35 < 0)
		panic(""Xen will not boot on this CPU for security reasons""
		      ""Pass \""allow_unsafe\"" if you're trusting all your""
		      "" (PV) guest kernels.\n"");
	else if (!VAR_35 && VAR_1 == &VAR_8)
		printk(KERN_WARNING
		       ""*** Xen will not allow creation of DomU-s on""
		       "" this CPU for security reasons. ***\n""
		       KERN_WARNING
		       ""*** Pass \""allow_unsafe\"" if you're trusting""
		       "" all your (PV) guest kernels. ***\n"");

	if (VAR_1->x86 == 0x16 && VAR_1->x86_model <= 0xf) {
		if (VAR_1 == &VAR_8) {
			VAR_2 = pci_conf_read32(PCI_SBDF(0, 0, 0x18, 3), 0x58);
			VAR_3 = pci_conf_read32(PCI_SBDF(0, 0, 0x18, 3), 0x5c);
			if ((VAR_2 & 0x1f) | (VAR_3 & 0x1))
				printk(KERN_WARNING
				       ""Applying workaround for erratum 792: %s%s%s\n"",
				       (VAR_2 & 0x1f) ? ""clearing D18F3x58[4:0]"" : """",
				       ((VAR_2 & 0x1f) && (VAR_3 & 0x1)) ? "" and "" : """",
				       (VAR_3 & 0x1) ? ""clearing D18F3x5C[0]"" : """");

			if (VAR_2 & 0x1f)
				pci_conf_write32(PCI_SBDF(0, 0, 0x18, 3), 0x58,
						 VAR_2 & ~0x1f);

			if (VAR_3 & 0x1)
				pci_conf_write32(PCI_SBDF(0, 0, 0x18, 3), 0x5c,
						 VAR_3 & ~0x1);
		}

		rdmsrl(VAR_36, VAR_4);
		if (!(VAR_4 & (1 << 15))) {
			static bool_t VAR_37;

			if (VAR_1 == &VAR_8 || VAR_38 ||
			    !test_and_set_bool(VAR_37))
				printk(KERN_WARNING
				       ""CPU%u: Applying workaround for erratum 793\n"",
				       smp_processor_id());
			wrmsrl(VAR_36, VAR_4 | (1 << 15));
		}
	} else if (VAR_1->x86 == 0x12) {
		rdmsrl(VAR_39, VAR_4);
		if (!(VAR_4 & (1U << 31))) {
			static bool VAR_37;

			if (VAR_1 == &VAR_8 || VAR_38 ||
			    !test_and_set_bool(VAR_37))
				printk(KERN_WARNING
				       ""CPU%u: Applying workaround for erratum 665\n"",
				       smp_processor_id());
			wrmsrl(VAR_39, VAR_4 | (1U << 31));
		}
	}

	/* COMMENT_46 */
	__clear_bit(VAR_40, VAR_1->x86_capability);

	if (VAR_1->x86 == 0x10) {
		/* COMMENT_47 */
		if (VAR_1 == &VAR_8)
			check_enable_amd_mmconf_dmi();

		fam10h_check_enable_mmcfg();

		/* COMMENT_48 */
                                                         
                                                                
                                                                
                                                          
                     
     
		rdmsrl(VAR_41, VAR_4);
		VAR_4 &= ~(1ULL << 24);
		wrmsrl(VAR_41, VAR_4);
	}

	/* COMMENT_55 */
                                                    
                             
    
	if ( VAR_42 && VAR_1->x86 > 0x11 )
		__set_bit(VAR_43, VAR_1->x86_capability);

	/* COMMENT_59 */
                                                                         
                                   
    
	if (VAR_44 != VAR_45 && VAR_1->x86 < 0x14) {
		wrmsrl(VAR_46, 0);
		wrmsrl(VAR_47, 0);
		wrmsrl(VAR_48, 0);
		wrmsrl(VAR_49, 0);
	}

	if (cpu_has(VAR_1, VAR_50)) {
		rdmsr(VAR_5, VAR_2, VAR_3);
		VAR_2 |= (1 << 27); /* COMMENT_63 */
		wrmsr(VAR_5, VAR_2, VAR_3);
	}

	/* COMMENT_64 */
	if ((smp_processor_id() == 1) && !cpu_has(VAR_1, VAR_26))
		disable_c1_ramping();

	check_syscfg_dram_mod_en();

	amd_log_freq(VAR_1);
}",,"--- func_before
+++ func_after
@@ -65,6 +65,14 @@
 	/* MFENCE stops RDTSC speculation */
 	if (!cpu_has_lfence_dispatch)
 		__set_bit(X86_FEATURE_MFENCE_RDTSC, c->x86_capability);
+
+	/*
+	 * On pre-CLFLUSHOPT AMD CPUs, CLFLUSH is weakly ordered with
+	 * everything, including reads and writes to address, and
+	 * LFENCE/SFENCE instructions.
+	 */
+	if (!cpu_has_clflushopt)
+		setup_force_cpu_cap(X86_BUG_CLFLUSH_MFENCE);
 
 	switch(c->x86)
 	{","{'deleted_lines': [], 'added_lines': ['', '\t/*', '\t * On pre-CLFLUSHOPT AMD CPUs, CLFLUSH is weakly ordered with', '\t * everything, including reads and writes to address, and', '\t * LFENCE/SFENCE instructions.', '\t */', '\tif (!cpu_has_clflushopt)', '\t\tsetup_force_cpu_cap(X86_BUG_CLFLUSH_MFENCE);']}",True,"x86 pv: Insufficient care with non-coherent mappings T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Xen maintains a type reference count for pages, in addition to a regular reference count. This scheme is used to maintain invariants required for Xen's safety, e.g. PV guests may not have direct writeable access to pagetables; updates need auditing by Xen. Unfortunately, Xen's safety logic doesn't account for CPU-induced cache non-coherency; cases where the CPU can cause the content of the cache to be different to the content in main memory. In such cases, Xen's safety logic can incorrectly conclude that the contents of a page is safe.",6.7,MEDIUM,1,test,2022-06-09T12:23:07Z,4
CVE-2022-34835,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,u-boot,"i2c: fix stack buffer overflow vulnerability in i2c md command

When running ""i2c md 0 0 80000100"", the function do_i2c_md parses the
length into an unsigned int variable named length. The value is then
moved to a signed variable:

    int nbytes = length;
    #define DISP_LINE_LEN 16
    int linebytes = (nbytes > DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes;
    ret = dm_i2c_read(dev, addr, linebuf, linebytes);

On systems where integers are 32 bits wide, 0x80000100 is a negative
value to ""nbytes > DISP_LINE_LEN"" is false and linebytes gets assigned
0x80000100 instead of 16.

The consequence is that the function which reads from the i2c device
(dm_i2c_read or i2c_read) is called with a 16-byte stack buffer to fill
but with a size parameter which is too large. In some cases, this could
trigger a crash. But with some i2c drivers, such as drivers/i2c/nx_i2c.c
(used with ""nexell,s5pxx18-i2c"" bus), the size is actually truncated to
a 16-bit integer. This is because function i2c_transfer expects an
unsigned short length. In such a case, an attacker who can control the
response of an i2c device can overwrite the return address of a function
and execute arbitrary code through Return-Oriented Programming.

Fix this issue by using unsigned integers types in do_i2c_md. While at
it, make also alen unsigned, as signed sizes can cause vulnerabilities
when people forgot to check that they can be negative.

Signed-off-by: Nicolas Iooss <nicolas.iooss+uboot@ledger.fr>
Reviewed-by: Heiko Schocher <hs@denx.de>",8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409,https://github.com/u-boot/u-boot/commit/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409,cmd/i2c.c,do_i2c_md,"static int do_i2c_md(struct cmd_tbl *cmdtp, int flag, int argc,
char *const argv[])
{
uintchip;
uintaddr, length;
int alen;
intj, nbytes, linebytes;
int ret;
#if CONFIG_IS_ENABLED(DM_I2C)
struct udevice *dev;
#endif
chip   = i2c_dp_last_chip;
addr   = i2c_dp_last_addr;
alen   = i2c_dp_last_alen;
length = i2c_dp_last_length;
if (argc < 3)
return CMD_RET_USAGE;
if ((flag & CMD_FLAG_REPEAT) == 0) {
chip = hextoul(argv[1], NULL);
addr = hextoul(argv[2], NULL);
alen = get_alen(argv[2], DEFAULT_ADDR_LEN);
if (alen > 3)
return CMD_RET_USAGE;
if (argc > 3)
length = hextoul(argv[3], NULL);
}
#if CONFIG_IS_ENABLED(DM_I2C)
ret = i2c_get_cur_bus_chip(chip, &dev);
if (!ret && alen != -1)
ret = i2c_set_chip_offset_len(dev, alen);
if (ret)
return i2c_report_err(ret, I2C_ERR_READ);
#endif
nbytes = length;
do {
unsigned charlinebuf[DISP_LINE_LEN];
unsigned char*cp;
linebytes = (nbytes > DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes;
#if CONFIG_IS_ENABLED(DM_I2C)
ret = dm_i2c_read(dev, addr, linebuf, linebytes);
#else
ret = i2c_read(chip, addr, alen, linebuf, linebytes);
#endif
if (ret)
return i2c_report_err(ret, I2C_ERR_READ);
else {
printf(""%04x:"", addr);
cp = linebuf;
for (j=0; j<linebytes; j++) {
printf("" %02x"", *cp++);
addr++;
}
puts (""    "");
cp = linebuf;
for (j=0; j<linebytes; j++) {
if ((*cp < 0x20) || (*cp > 0x7e))
puts (""."");
else
printf(""%c"", *cp);
cp++;
}
putc ('\n');
}
nbytes -= linebytes;
} while (nbytes > 0);
i2c_dp_last_chip   = chip;
i2c_dp_last_addr   = addr;
i2c_dp_last_alen   = alen;
i2c_dp_last_length = length;
return 0;
}","static int do_i2c_md(struct cmd_tbl *VAR_0, int VAR_1, int VAR_2,
char *const VAR_3[])
{
uintVAR_4;
uintVAR_5, VAR_6;
int VAR_7;
intVAR_8, VAR_9, VAR_10;
int VAR_11;
#if CONFIG_IS_ENABLED(VAR_12)
struct udevice *VAR_13;
#endif
VAR_4   = VAR_14;
VAR_5   = VAR_15;
VAR_7   = VAR_16;
VAR_6 = VAR_17;
if (VAR_2 < 3)
return VAR_18;
if ((VAR_1 & VAR_19) == 0) {
VAR_4 = hextoul(VAR_3[1], NULL);
VAR_5 = hextoul(VAR_3[2], NULL);
VAR_7 = get_alen(VAR_3[2], VAR_20);
if (VAR_7 > 3)
return VAR_18;
if (VAR_2 > 3)
VAR_6 = hextoul(VAR_3[3], NULL);
}
#if CONFIG_IS_ENABLED(VAR_12)
VAR_11 = i2c_get_cur_bus_chip(VAR_4, &VAR_13);
if (!VAR_11 && VAR_7 != -1)
VAR_11 = i2c_set_chip_offset_len(VAR_13, VAR_7);
if (VAR_11)
return i2c_report_err(VAR_11, VAR_21);
#endif
VAR_9 = VAR_6;
do {
unsigned charVAR_22[VAR_23];
unsigned char*VAR_24;
VAR_10 = (VAR_9 > VAR_23) ? VAR_23 : VAR_9;
#if CONFIG_IS_ENABLED(VAR_12)
VAR_11 = dm_i2c_read(VAR_13, VAR_5, VAR_22, VAR_10);
#else
VAR_11 = i2c_read(VAR_4, VAR_5, VAR_7, VAR_22, VAR_10);
#endif
if (VAR_11)
return i2c_report_err(VAR_11, VAR_21);
else {
printf(""%04x:"", VAR_5);
VAR_24 = VAR_22;
for (VAR_8=0; VAR_8<VAR_10; VAR_8++) {
printf("" %02x"", *VAR_24++);
VAR_5++;
}
puts (""    "");
VAR_24 = VAR_22;
for (VAR_8=0; VAR_8<VAR_10; VAR_8++) {
if ((*VAR_24 < 0x20) || (*VAR_24 > 0x7e))
puts (""."");
else
printf(""%c"", *VAR_24);
VAR_24++;
}
putc ('\n');
}
VAR_9 -= VAR_10;
} while (VAR_9 > 0);
VAR_14   = VAR_4;
VAR_15   = VAR_5;
VAR_16   = VAR_7;
VAR_17 = VAR_6;
return 0;
}",u-boot/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409/i2c.c/vul/before/0.json,"static int do_i2c_md(struct cmd_tbl *cmdtp, int flag, int argc,
		     char *const argv[])
{
	uint	chip;
	uint	addr, length;
	uint	alen;
	uint	j, nbytes, linebytes;
	int ret;
#if CONFIG_IS_ENABLED(DM_I2C)
	struct udevice *dev;
#endif

	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	chip   = i2c_dp_last_chip;
	addr   = i2c_dp_last_addr;
	alen   = i2c_dp_last_alen;
	length = i2c_dp_last_length;

	if (argc < 3)
		return CMD_RET_USAGE;

	if ((flag & CMD_FLAG_REPEAT) == 0) {
		/*
		 * New command specified.
		 */

		/*
		 * I2C chip address
		 */
		chip = hextoul(argv[1], NULL);

		/*
		 * I2C data address within the chip.  This can be 1 or
		 * 2 bytes long.  Some day it might be 3 bytes long :-).
		 */
		addr = hextoul(argv[2], NULL);
		alen = get_alen(argv[2], DEFAULT_ADDR_LEN);
		if (alen > 3)
			return CMD_RET_USAGE;

		/*
		 * If another parameter, it is the length to display.
		 * Length is the number of objects, not number of bytes.
		 */
		if (argc > 3)
			length = hextoul(argv[3], NULL);
	}

#if CONFIG_IS_ENABLED(DM_I2C)
	ret = i2c_get_cur_bus_chip(chip, &dev);
	if (!ret && alen != -1)
		ret = i2c_set_chip_offset_len(dev, alen);
	if (ret)
		return i2c_report_err(ret, I2C_ERR_READ);
#endif

	/*
	 * Print the lines.
	 *
	 * We buffer all read data, so we can make sure data is read only
	 * once.
	 */
	nbytes = length;
	do {
		unsigned char	linebuf[DISP_LINE_LEN];
		unsigned char	*cp;

		linebytes = (nbytes > DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes;

#if CONFIG_IS_ENABLED(DM_I2C)
		ret = dm_i2c_read(dev, addr, linebuf, linebytes);
#else
		ret = i2c_read(chip, addr, alen, linebuf, linebytes);
#endif
		if (ret)
			return i2c_report_err(ret, I2C_ERR_READ);
		else {
			printf(""%04x:"", addr);
			cp = linebuf;
			for (j=0; j<linebytes; j++) {
				printf("" %02x"", *cp++);
				addr++;
			}
			puts (""    "");
			cp = linebuf;
			for (j=0; j<linebytes; j++) {
				if ((*cp < 0x20) || (*cp > 0x7e))
					puts (""."");
				else
					printf(""%c"", *cp);
				cp++;
			}
			putc ('\n');
		}
		nbytes -= linebytes;
	} while (nbytes > 0);

	i2c_dp_last_chip   = chip;
	i2c_dp_last_addr   = addr;
	i2c_dp_last_alen   = alen;
	i2c_dp_last_length = length;

	return 0;
}","static int do_i2c_md(struct cmd_tbl *VAR_0, int VAR_1, int VAR_2,
		     char *const VAR_3[])
{
	uint	VAR_4;
	uint	VAR_5, VAR_6;
	uint	VAR_7;
	uint	VAR_8, VAR_9, VAR_10;
	int VAR_11;
#if CONFIG_IS_ENABLED(VAR_12)
	struct udevice *VAR_13;
#endif

	/* COMMENT_0 */
            
    
	VAR_4   = VAR_14;
	VAR_5   = VAR_15;
	VAR_7   = VAR_16;
	VAR_6 = VAR_17;

	if (VAR_2 < 3)
		return VAR_18;

	if ((VAR_1 & VAR_19) == 0) {
		/* COMMENT_3 */
                           
     

		/* COMMENT_6 */
                     
     
		VAR_4 = hextoul(VAR_3[1], NULL);

		/* COMMENT_9 */
                                                        
                                                          
     
		VAR_5 = hextoul(VAR_3[2], NULL);
		VAR_7 = get_alen(VAR_3[2], VAR_20);
		if (VAR_7 > 3)
			return VAR_18;

		/* COMMENT_13 */
                                                       
                                                          
     
		if (VAR_2 > 3)
			VAR_6 = hextoul(VAR_3[3], NULL);
	}

#if CONFIG_IS_ENABLED(VAR_12)
	VAR_11 = i2c_get_cur_bus_chip(VAR_4, &VAR_13);
	if (!VAR_11 && VAR_7 != -1)
		VAR_11 = i2c_set_chip_offset_len(VAR_13, VAR_7);
	if (VAR_11)
		return i2c_report_err(VAR_11, VAR_21);
#endif

	/* COMMENT_17 */
                    
   
                                                                  
         
    
	VAR_9 = VAR_6;
	do {
		unsigned char	VAR_22[VAR_23];
		unsigned char	*VAR_24;

		VAR_10 = (VAR_9 > VAR_23) ? VAR_23 : VAR_9;

#if CONFIG_IS_ENABLED(VAR_12)
		VAR_11 = dm_i2c_read(VAR_13, VAR_5, VAR_22, VAR_10);
#else
		VAR_11 = i2c_read(VAR_4, VAR_5, VAR_7, VAR_22, VAR_10);
#endif
		if (VAR_11)
			return i2c_report_err(VAR_11, VAR_21);
		else {
			printf(""%04x:"", VAR_5);
			VAR_24 = VAR_22;
			for (VAR_8=0; VAR_8<VAR_10; VAR_8++) {
				printf("" %02x"", *VAR_24++);
				VAR_5++;
			}
			puts (""    "");
			VAR_24 = VAR_22;
			for (VAR_8=0; VAR_8<VAR_10; VAR_8++) {
				if ((*VAR_24 < 0x20) || (*VAR_24 > 0x7e))
					puts (""."");
				else
					printf(""%c"", *VAR_24);
				VAR_24++;
			}
			putc ('\n');
		}
		VAR_9 -= VAR_10;
	} while (VAR_9 > 0);

	VAR_14   = VAR_4;
	VAR_15   = VAR_5;
	VAR_16   = VAR_7;
	VAR_17 = VAR_6;

	return 0;
}",u-boot/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409/i2c.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,8 +3,8 @@
 {
 	uint	chip;
 	uint	addr, length;
-	int alen;
-	int	j, nbytes, linebytes;
+	uint	alen;
+	uint	j, nbytes, linebytes;
 	int ret;
 #if CONFIG_IS_ENABLED(DM_I2C)
 	struct udevice *dev;","{'deleted_lines': ['\tint alen;', '\tint\tj, nbytes, linebytes;'], 'added_lines': ['\tuint\talen;', '\tuint\tj, nbytes, linebytes;']}",True,"In Das U-Boot through 2022.07-rc5, an integer signedness error and resultant stack-based buffer overflow in the ""i2c md"" command enables the corruption of the return address pointer of the do_i2c_md function.",9.8,CRITICAL,3,test,2022-06-10T14:50:25Z,4
CVE-2022-34835,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,u-boot,"i2c: fix stack buffer overflow vulnerability in i2c md command

When running ""i2c md 0 0 80000100"", the function do_i2c_md parses the
length into an unsigned int variable named length. The value is then
moved to a signed variable:

    int nbytes = length;
    #define DISP_LINE_LEN 16
    int linebytes = (nbytes > DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes;
    ret = dm_i2c_read(dev, addr, linebuf, linebytes);

On systems where integers are 32 bits wide, 0x80000100 is a negative
value to ""nbytes > DISP_LINE_LEN"" is false and linebytes gets assigned
0x80000100 instead of 16.

The consequence is that the function which reads from the i2c device
(dm_i2c_read or i2c_read) is called with a 16-byte stack buffer to fill
but with a size parameter which is too large. In some cases, this could
trigger a crash. But with some i2c drivers, such as drivers/i2c/nx_i2c.c
(used with ""nexell,s5pxx18-i2c"" bus), the size is actually truncated to
a 16-bit integer. This is because function i2c_transfer expects an
unsigned short length. In such a case, an attacker who can control the
response of an i2c device can overwrite the return address of a function
and execute arbitrary code through Return-Oriented Programming.

Fix this issue by using unsigned integers types in do_i2c_md. While at
it, make also alen unsigned, as signed sizes can cause vulnerabilities
when people forgot to check that they can be negative.

Signed-off-by: Nicolas Iooss <nicolas.iooss+uboot@ledger.fr>
Reviewed-by: Heiko Schocher <hs@denx.de>",8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409,https://github.com/u-boot/u-boot/commit/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409,cmd/i2c.c,get_alen,"static uint get_alen(char *arg, int default_len)
{
intj;
intalen;
alen = default_len;
for (j = 0; j < 8; j++) {
if (arg[j] == '.') {
alen = arg[j+1] - '0';
break;
} else if (arg[j] == '\0')
break;
}
return alen;
}","static uint get_alen(char *VAR_0, int VAR_1)
{
intVAR_2;
intVAR_3;
VAR_3 = VAR_1;
for (VAR_2 = 0; VAR_2 < 8; VAR_2++) {
if (VAR_0[VAR_2] == '.') {
VAR_3 = VAR_0[VAR_2+1] - '0';
break;
} else if (VAR_0[VAR_2] == '\0')
break;
}
return VAR_3;
}",u-boot/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409/i2c.c/vul/before/4.json,"static uint get_alen(char *arg, uint default_len)
{
	uint	j;
	uint	alen;

	alen = default_len;
	for (j = 0; j < 8; j++) {
		if (arg[j] == '.') {
			alen = arg[j+1] - '0';
			break;
		} else if (arg[j] == '\0')
			break;
	}
	return alen;
}","static uint get_alen(char *VAR_0, uint VAR_1)
{
	uint	VAR_2;
	uint	VAR_3;

	VAR_3 = VAR_1;
	for (VAR_2 = 0; VAR_2 < 8; VAR_2++) {
		if (VAR_0[VAR_2] == '.') {
			VAR_3 = VAR_0[VAR_2+1] - '0';
			break;
		} else if (VAR_0[VAR_2] == '\0')
			break;
	}
	return VAR_3;
}",u-boot/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409/i2c.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
-static uint get_alen(char *arg, int default_len)
+static uint get_alen(char *arg, uint default_len)
 {
-	int	j;
-	int	alen;
+	uint	j;
+	uint	alen;
 
 	alen = default_len;
 	for (j = 0; j < 8; j++) {","{'deleted_lines': ['static uint get_alen(char *arg, int default_len)', '\tint\tj;', '\tint\talen;'], 'added_lines': ['static uint get_alen(char *arg, uint default_len)', '\tuint\tj;', '\tuint\talen;']}",True,"In Das U-Boot through 2022.07-rc5, an integer signedness error and resultant stack-based buffer overflow in the ""i2c md"" command enables the corruption of the return address pointer of the do_i2c_md function.",9.8,CRITICAL,3,test,2022-06-10T14:50:25Z,4
CVE-2022-34835,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,u-boot,"i2c: fix stack buffer overflow vulnerability in i2c md command

When running ""i2c md 0 0 80000100"", the function do_i2c_md parses the
length into an unsigned int variable named length. The value is then
moved to a signed variable:

    int nbytes = length;
    #define DISP_LINE_LEN 16
    int linebytes = (nbytes > DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes;
    ret = dm_i2c_read(dev, addr, linebuf, linebytes);

On systems where integers are 32 bits wide, 0x80000100 is a negative
value to ""nbytes > DISP_LINE_LEN"" is false and linebytes gets assigned
0x80000100 instead of 16.

The consequence is that the function which reads from the i2c device
(dm_i2c_read or i2c_read) is called with a 16-byte stack buffer to fill
but with a size parameter which is too large. In some cases, this could
trigger a crash. But with some i2c drivers, such as drivers/i2c/nx_i2c.c
(used with ""nexell,s5pxx18-i2c"" bus), the size is actually truncated to
a 16-bit integer. This is because function i2c_transfer expects an
unsigned short length. In such a case, an attacker who can control the
response of an i2c device can overwrite the return address of a function
and execute arbitrary code through Return-Oriented Programming.

Fix this issue by using unsigned integers types in do_i2c_md. While at
it, make also alen unsigned, as signed sizes can cause vulnerabilities
when people forgot to check that they can be negative.

Signed-off-by: Nicolas Iooss <nicolas.iooss+uboot@ledger.fr>
Reviewed-by: Heiko Schocher <hs@denx.de>",8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409,https://github.com/u-boot/u-boot/commit/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409,cmd/i2c.c,do_i2c_write,"static int do_i2c_write(struct cmd_tbl *cmdtp, int flag, int argc,
char *const argv[])
{
uintchip;
uintdevaddr, length;
int alen;
u_char  *memaddr;
int ret;
#if CONFIG_IS_ENABLED(DM_I2C)
struct udevice *dev;
struct dm_i2c_chip *i2c_chip;
#endif
if ((argc < 5) || (argc > 6))
return cmd_usage(cmdtp);
memaddr = (u_char *)hextoul(argv[1], NULL);
chip = hextoul(argv[2], NULL);
devaddr = hextoul(argv[3], NULL);
alen = get_alen(argv[3], DEFAULT_ADDR_LEN);
if (alen > 3)
return cmd_usage(cmdtp);
length = hextoul(argv[4], NULL);
#if CONFIG_IS_ENABLED(DM_I2C)
ret = i2c_get_cur_bus_chip(chip, &dev);
if (!ret && alen != -1)
ret = i2c_set_chip_offset_len(dev, alen);
if (ret)
return i2c_report_err(ret, I2C_ERR_WRITE);
i2c_chip = dev_get_parent_plat(dev);
if (!i2c_chip)
return i2c_report_err(ret, I2C_ERR_WRITE);
#endif
if (argc == 6 && !strcmp(argv[5], ""-s"")) {
#if CONFIG_IS_ENABLED(DM_I2C)
i2c_chip->flags &= ~DM_I2C_CHIP_WR_ADDRESS;
ret = dm_i2c_write(dev, devaddr, memaddr, length);
#else
ret = i2c_write(chip, devaddr, alen, memaddr, length);
#endif
if (ret)
return i2c_report_err(ret, I2C_ERR_WRITE);
} else {
while (length-- > 0) {
#if CONFIG_IS_ENABLED(DM_I2C)
i2c_chip->flags |= DM_I2C_CHIP_WR_ADDRESS;
ret = dm_i2c_write(dev, devaddr++, memaddr++, 1);
#else
ret = i2c_write(chip, devaddr++, alen, memaddr++, 1);
#endif
if (ret)
return i2c_report_err(ret, I2C_ERR_WRITE);
#if !defined(CONFIG_SYS_I2C_FRAM)
udelay(11000);
#endif
}
}
return 0;
}","static int do_i2c_write(struct cmd_tbl *VAR_0, int VAR_1, int VAR_2,
char *const VAR_3[])
{
uintVAR_4;
uintVAR_5, VAR_6;
int VAR_7;
u_char  *VAR_8;
int VAR_9;
#if CONFIG_IS_ENABLED(VAR_10)
struct udevice *VAR_11;
struct dm_i2c_chip *VAR_12;
#endif
if ((VAR_2 < 5) || (VAR_2 > 6))
return cmd_usage(VAR_0);
VAR_8 = (u_char *)hextoul(VAR_3[1], NULL);
VAR_4 = hextoul(VAR_3[2], NULL);
VAR_5 = hextoul(VAR_3[3], NULL);
VAR_7 = get_alen(VAR_3[3], VAR_13);
if (VAR_7 > 3)
return cmd_usage(VAR_0);
VAR_6 = hextoul(VAR_3[4], NULL);
#if CONFIG_IS_ENABLED(VAR_10)
VAR_9 = i2c_get_cur_bus_chip(VAR_4, &VAR_11);
if (!VAR_9 && VAR_7 != -1)
VAR_9 = i2c_set_chip_offset_len(VAR_11, VAR_7);
if (VAR_9)
return i2c_report_err(VAR_9, VAR_14);
VAR_12 = dev_get_parent_plat(VAR_11);
if (!VAR_12)
return i2c_report_err(VAR_9, VAR_14);
#endif
if (VAR_2 == 6 && !strcmp(VAR_3[5], ""-s"")) {
#if CONFIG_IS_ENABLED(VAR_10)
VAR_12->flags &= ~VAR_15;
VAR_9 = dm_i2c_write(VAR_11, VAR_5, VAR_8, VAR_6);
#else
VAR_9 = i2c_write(VAR_4, VAR_5, VAR_7, VAR_8, VAR_6);
#endif
if (VAR_9)
return i2c_report_err(VAR_9, VAR_14);
} else {
while (VAR_6-- > 0) {
#if CONFIG_IS_ENABLED(VAR_10)
VAR_12->flags |= VAR_15;
VAR_9 = dm_i2c_write(VAR_11, VAR_5++, VAR_8++, 1);
#else
VAR_9 = i2c_write(VAR_4, VAR_5++, VAR_7, VAR_8++, 1);
#endif
if (VAR_9)
return i2c_report_err(VAR_9, VAR_14);
#if !defined(VAR_16)
udelay(11000);
#endif
}
}
return 0;
}",u-boot/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409/i2c.c/vul/before/3.json,"static int do_i2c_write(struct cmd_tbl *cmdtp, int flag, int argc,
			char *const argv[])
{
	uint	chip;
	uint	devaddr, length;
	uint	alen;
	u_char  *memaddr;
	int ret;
#if CONFIG_IS_ENABLED(DM_I2C)
	struct udevice *dev;
	struct dm_i2c_chip *i2c_chip;
#endif

	if ((argc < 5) || (argc > 6))
		return cmd_usage(cmdtp);

	/*
	 * memaddr is the address where to store things in memory
	 */
	memaddr = (u_char *)hextoul(argv[1], NULL);

	/*
	 * I2C chip address
	 */
	chip = hextoul(argv[2], NULL);

	/*
	 * I2C data address within the chip.  This can be 1 or
	 * 2 bytes long.  Some day it might be 3 bytes long :-).
	 */
	devaddr = hextoul(argv[3], NULL);
	alen = get_alen(argv[3], DEFAULT_ADDR_LEN);
	if (alen > 3)
		return cmd_usage(cmdtp);

	/*
	 * Length is the number of bytes.
	 */
	length = hextoul(argv[4], NULL);

#if CONFIG_IS_ENABLED(DM_I2C)
	ret = i2c_get_cur_bus_chip(chip, &dev);
	if (!ret && alen != -1)
		ret = i2c_set_chip_offset_len(dev, alen);
	if (ret)
		return i2c_report_err(ret, I2C_ERR_WRITE);
	i2c_chip = dev_get_parent_plat(dev);
	if (!i2c_chip)
		return i2c_report_err(ret, I2C_ERR_WRITE);
#endif

	if (argc == 6 && !strcmp(argv[5], ""-s"")) {
		/*
		 * Write all bytes in a single I2C transaction. If the target
		 * device is an EEPROM, it is your responsibility to not cross
		 * a page boundary. No write delay upon completion, take this
		 * into account if linking commands.
		 */
#if CONFIG_IS_ENABLED(DM_I2C)
		i2c_chip->flags &= ~DM_I2C_CHIP_WR_ADDRESS;
		ret = dm_i2c_write(dev, devaddr, memaddr, length);
#else
		ret = i2c_write(chip, devaddr, alen, memaddr, length);
#endif
		if (ret)
			return i2c_report_err(ret, I2C_ERR_WRITE);
	} else {
		/*
		 * Repeated addressing - perform <length> separate
		 * write transactions of one byte each
		 */
		while (length-- > 0) {
#if CONFIG_IS_ENABLED(DM_I2C)
			i2c_chip->flags |= DM_I2C_CHIP_WR_ADDRESS;
			ret = dm_i2c_write(dev, devaddr++, memaddr++, 1);
#else
			ret = i2c_write(chip, devaddr++, alen, memaddr++, 1);
#endif
			if (ret)
				return i2c_report_err(ret, I2C_ERR_WRITE);
/*
 * No write delay with FRAM devices.
 */
#if !defined(CONFIG_SYS_I2C_FRAM)
			udelay(11000);
#endif
		}
	}
	return 0;
}","static int do_i2c_write(struct cmd_tbl *VAR_0, int VAR_1, int VAR_2,
			char *const VAR_3[])
{
	uint	VAR_4;
	uint	VAR_5, VAR_6;
	uint	VAR_7;
	u_char  *VAR_8;
	int VAR_9;
#if CONFIG_IS_ENABLED(VAR_10)
	struct udevice *VAR_11;
	struct dm_i2c_chip *VAR_12;
#endif

	if ((VAR_2 < 5) || (VAR_2 > 6))
		return cmd_usage(VAR_0);

	/* COMMENT_0 */
                                                          
    
	VAR_8 = (u_char *)hextoul(VAR_3[1], NULL);

	/* COMMENT_3 */
                    
    
	VAR_4 = hextoul(VAR_3[2], NULL);

	/* COMMENT_6 */
                                                       
                                                         
    
	VAR_5 = hextoul(VAR_3[3], NULL);
	VAR_7 = get_alen(VAR_3[3], VAR_13);
	if (VAR_7 > 3)
		return cmd_usage(VAR_0);

	/* COMMENT_10 */
                                  
    
	VAR_6 = hextoul(VAR_3[4], NULL);

#if CONFIG_IS_ENABLED(VAR_10)
	VAR_9 = i2c_get_cur_bus_chip(VAR_4, &VAR_11);
	if (!VAR_9 && VAR_7 != -1)
		VAR_9 = i2c_set_chip_offset_len(VAR_11, VAR_7);
	if (VAR_9)
		return i2c_report_err(VAR_9, VAR_14);
	VAR_12 = dev_get_parent_plat(VAR_11);
	if (!VAR_12)
		return i2c_report_err(VAR_9, VAR_14);
#endif

	if (VAR_2 == 6 && !strcmp(VAR_3[5], ""-s"")) {
		/* COMMENT_13 */
                                                               
                                                                
                                                               
                                      
     
#if CONFIG_IS_ENABLED(VAR_10)
		VAR_12->flags &= ~VAR_15;
		VAR_9 = dm_i2c_write(VAR_11, VAR_5, VAR_8, VAR_6);
#else
		VAR_9 = i2c_write(VAR_4, VAR_5, VAR_7, VAR_8, VAR_6);
#endif
		if (VAR_9)
			return i2c_report_err(VAR_9, VAR_14);
	} else {
		/* COMMENT_19 */
                                                    
                                        
     
		while (VAR_6-- > 0) {
#if CONFIG_IS_ENABLED(VAR_10)
			VAR_12->flags |= VAR_15;
			VAR_9 = dm_i2c_write(VAR_11, VAR_5++, VAR_8++, 1);
#else
			VAR_9 = i2c_write(VAR_4, VAR_5++, VAR_7, VAR_8++, 1);
#endif
			if (VAR_9)
				return i2c_report_err(VAR_9, VAR_14);
/* COMMENT_23 */
                                    
   
#if !defined(VAR_16)
			udelay(11000);
#endif
		}
	}
	return 0;
}",u-boot/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409/i2c.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 {
 	uint	chip;
 	uint	devaddr, length;
-	int alen;
+	uint	alen;
 	u_char  *memaddr;
 	int ret;
 #if CONFIG_IS_ENABLED(DM_I2C)","{'deleted_lines': ['\tint alen;'], 'added_lines': ['\tuint\talen;']}",True,"In Das U-Boot through 2022.07-rc5, an integer signedness error and resultant stack-based buffer overflow in the ""i2c md"" command enables the corruption of the return address pointer of the do_i2c_md function.",9.8,CRITICAL,3,test,2022-06-10T14:50:25Z,4
CVE-2022-34835,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,u-boot,"i2c: fix stack buffer overflow vulnerability in i2c md command

When running ""i2c md 0 0 80000100"", the function do_i2c_md parses the
length into an unsigned int variable named length. The value is then
moved to a signed variable:

    int nbytes = length;
    #define DISP_LINE_LEN 16
    int linebytes = (nbytes > DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes;
    ret = dm_i2c_read(dev, addr, linebuf, linebytes);

On systems where integers are 32 bits wide, 0x80000100 is a negative
value to ""nbytes > DISP_LINE_LEN"" is false and linebytes gets assigned
0x80000100 instead of 16.

The consequence is that the function which reads from the i2c device
(dm_i2c_read or i2c_read) is called with a 16-byte stack buffer to fill
but with a size parameter which is too large. In some cases, this could
trigger a crash. But with some i2c drivers, such as drivers/i2c/nx_i2c.c
(used with ""nexell,s5pxx18-i2c"" bus), the size is actually truncated to
a 16-bit integer. This is because function i2c_transfer expects an
unsigned short length. In such a case, an attacker who can control the
response of an i2c device can overwrite the return address of a function
and execute arbitrary code through Return-Oriented Programming.

Fix this issue by using unsigned integers types in do_i2c_md. While at
it, make also alen unsigned, as signed sizes can cause vulnerabilities
when people forgot to check that they can be negative.

Signed-off-by: Nicolas Iooss <nicolas.iooss+uboot@ledger.fr>
Reviewed-by: Heiko Schocher <hs@denx.de>",8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409,https://github.com/u-boot/u-boot/commit/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409,cmd/i2c.c,do_i2c_loop,"static int do_i2c_loop(struct cmd_tbl *cmdtp, int flag, int argc,
char *const argv[])
{
uintchip;
int alen;
uintaddr;
uintlength;
u_charbytes[16];
intdelay;
int ret;
#if CONFIG_IS_ENABLED(DM_I2C)
struct udevice *dev;
#endif
if (argc < 3)
return CMD_RET_USAGE;
chip = hextoul(argv[1], NULL);
addr = hextoul(argv[2], NULL);
alen = get_alen(argv[2], DEFAULT_ADDR_LEN);
if (alen > 3)
return CMD_RET_USAGE;
#if CONFIG_IS_ENABLED(DM_I2C)
ret = i2c_get_cur_bus_chip(chip, &dev);
if (!ret && alen != -1)
ret = i2c_set_chip_offset_len(dev, alen);
if (ret)
return i2c_report_err(ret, I2C_ERR_WRITE);
#endif
length = 1;
length = hextoul(argv[3], NULL);
if (length > sizeof(bytes))
length = sizeof(bytes);
delay = 1000;
if (argc > 3)
delay = dectoul(argv[4], NULL);
while (1) {
#if CONFIG_IS_ENABLED(DM_I2C)
ret = dm_i2c_read(dev, addr, bytes, length);
#else
ret = i2c_read(chip, addr, alen, bytes, length);
#endif
if (ret)
i2c_report_err(ret, I2C_ERR_READ);
udelay(delay);
}
return 0;
}","static int do_i2c_loop(struct cmd_tbl *VAR_0, int VAR_1, int VAR_2,
char *const VAR_3[])
{
uintVAR_4;
int VAR_5;
uintVAR_6;
uintVAR_7;
u_charVAR_8[16];
intVAR_9;
int VAR_10;
#if CONFIG_IS_ENABLED(VAR_11)
struct udevice *VAR_12;
#endif
if (VAR_2 < 3)
return VAR_13;
VAR_4 = hextoul(VAR_3[1], NULL);
VAR_6 = hextoul(VAR_3[2], NULL);
VAR_5 = get_alen(VAR_3[2], VAR_14);
if (VAR_5 > 3)
return VAR_13;
#if CONFIG_IS_ENABLED(VAR_11)
VAR_10 = i2c_get_cur_bus_chip(VAR_4, &VAR_12);
if (!VAR_10 && VAR_5 != -1)
VAR_10 = i2c_set_chip_offset_len(VAR_12, VAR_5);
if (VAR_10)
return i2c_report_err(VAR_10, VAR_15);
#endif
VAR_7 = 1;
VAR_7 = hextoul(VAR_3[3], NULL);
if (VAR_7 > sizeof(VAR_8))
VAR_7 = sizeof(VAR_8);
VAR_9 = 1000;
if (VAR_2 > 3)
VAR_9 = dectoul(VAR_3[4], NULL);
while (1) {
#if CONFIG_IS_ENABLED(VAR_11)
VAR_10 = dm_i2c_read(VAR_12, VAR_6, VAR_8, VAR_7);
#else
VAR_10 = i2c_read(VAR_4, VAR_6, VAR_5, VAR_8, VAR_7);
#endif
if (VAR_10)
i2c_report_err(VAR_10, VAR_16);
udelay(VAR_9);
}
return 0;
}",u-boot/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409/i2c.c/vul/before/2.json,"static int do_i2c_loop(struct cmd_tbl *cmdtp, int flag, int argc,
		       char *const argv[])
{
	uint	chip;
	uint	alen;
	uint	addr;
	uint	length;
	u_char	bytes[16];
	int	delay;
	int ret;
#if CONFIG_IS_ENABLED(DM_I2C)
	struct udevice *dev;
#endif

	if (argc < 3)
		return CMD_RET_USAGE;

	/*
	 * Chip is always specified.
	 */
	chip = hextoul(argv[1], NULL);

	/*
	 * Address is always specified.
	 */
	addr = hextoul(argv[2], NULL);
	alen = get_alen(argv[2], DEFAULT_ADDR_LEN);
	if (alen > 3)
		return CMD_RET_USAGE;
#if CONFIG_IS_ENABLED(DM_I2C)
	ret = i2c_get_cur_bus_chip(chip, &dev);
	if (!ret && alen != -1)
		ret = i2c_set_chip_offset_len(dev, alen);
	if (ret)
		return i2c_report_err(ret, I2C_ERR_WRITE);
#endif

	/*
	 * Length is the number of objects, not number of bytes.
	 */
	length = 1;
	length = hextoul(argv[3], NULL);
	if (length > sizeof(bytes))
		length = sizeof(bytes);

	/*
	 * The delay time (uSec) is optional.
	 */
	delay = 1000;
	if (argc > 3)
		delay = dectoul(argv[4], NULL);
	/*
	 * Run the loop...
	 */
	while (1) {
#if CONFIG_IS_ENABLED(DM_I2C)
		ret = dm_i2c_read(dev, addr, bytes, length);
#else
		ret = i2c_read(chip, addr, alen, bytes, length);
#endif
		if (ret)
			i2c_report_err(ret, I2C_ERR_READ);
		udelay(delay);
	}

	/* NOTREACHED */
	return 0;
}","static int do_i2c_loop(struct cmd_tbl *VAR_0, int VAR_1, int VAR_2,
		       char *const VAR_3[])
{
	uint	VAR_4;
	uint	VAR_5;
	uint	VAR_6;
	uint	VAR_7;
	u_char	VAR_8[16];
	int	VAR_9;
	int VAR_10;
#if CONFIG_IS_ENABLED(VAR_11)
	struct udevice *VAR_12;
#endif

	if (VAR_2 < 3)
		return VAR_13;

	/* COMMENT_0 */
                             
    
	VAR_4 = hextoul(VAR_3[1], NULL);

	/* COMMENT_3 */
                                
    
	VAR_6 = hextoul(VAR_3[2], NULL);
	VAR_5 = get_alen(VAR_3[2], VAR_14);
	if (VAR_5 > 3)
		return VAR_13;
#if CONFIG_IS_ENABLED(VAR_11)
	VAR_10 = i2c_get_cur_bus_chip(VAR_4, &VAR_12);
	if (!VAR_10 && VAR_5 != -1)
		VAR_10 = i2c_set_chip_offset_len(VAR_12, VAR_5);
	if (VAR_10)
		return i2c_report_err(VAR_10, VAR_15);
#endif

	/* COMMENT_6 */
                                                         
    
	VAR_7 = 1;
	VAR_7 = hextoul(VAR_3[3], NULL);
	if (VAR_7 > sizeof(VAR_8))
		VAR_7 = sizeof(VAR_8);

	/* COMMENT_9 */
                                      
    
	VAR_9 = 1000;
	if (VAR_2 > 3)
		VAR_9 = dectoul(VAR_3[4], NULL);
	/* COMMENT_12 */
                   
    
	while (1) {
#if CONFIG_IS_ENABLED(VAR_11)
		VAR_10 = dm_i2c_read(VAR_12, VAR_6, VAR_8, VAR_7);
#else
		VAR_10 = i2c_read(VAR_4, VAR_6, VAR_5, VAR_8, VAR_7);
#endif
		if (VAR_10)
			i2c_report_err(VAR_10, VAR_16);
		udelay(VAR_9);
	}

	/* COMMENT_15 */
	return 0;
}",u-boot/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409/i2c.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 		       char *const argv[])
 {
 	uint	chip;
-	int alen;
+	uint	alen;
 	uint	addr;
 	uint	length;
 	u_char	bytes[16];","{'deleted_lines': ['\tint alen;'], 'added_lines': ['\tuint\talen;']}",True,"In Das U-Boot through 2022.07-rc5, an integer signedness error and resultant stack-based buffer overflow in the ""i2c md"" command enables the corruption of the return address pointer of the do_i2c_md function.",9.8,CRITICAL,3,test,2022-06-10T14:50:25Z,4
CVE-2022-34835,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,u-boot,"i2c: fix stack buffer overflow vulnerability in i2c md command

When running ""i2c md 0 0 80000100"", the function do_i2c_md parses the
length into an unsigned int variable named length. The value is then
moved to a signed variable:

    int nbytes = length;
    #define DISP_LINE_LEN 16
    int linebytes = (nbytes > DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes;
    ret = dm_i2c_read(dev, addr, linebuf, linebytes);

On systems where integers are 32 bits wide, 0x80000100 is a negative
value to ""nbytes > DISP_LINE_LEN"" is false and linebytes gets assigned
0x80000100 instead of 16.

The consequence is that the function which reads from the i2c device
(dm_i2c_read or i2c_read) is called with a 16-byte stack buffer to fill
but with a size parameter which is too large. In some cases, this could
trigger a crash. But with some i2c drivers, such as drivers/i2c/nx_i2c.c
(used with ""nexell,s5pxx18-i2c"" bus), the size is actually truncated to
a 16-bit integer. This is because function i2c_transfer expects an
unsigned short length. In such a case, an attacker who can control the
response of an i2c device can overwrite the return address of a function
and execute arbitrary code through Return-Oriented Programming.

Fix this issue by using unsigned integers types in do_i2c_md. While at
it, make also alen unsigned, as signed sizes can cause vulnerabilities
when people forgot to check that they can be negative.

Signed-off-by: Nicolas Iooss <nicolas.iooss+uboot@ledger.fr>
Reviewed-by: Heiko Schocher <hs@denx.de>",8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409,https://github.com/u-boot/u-boot/commit/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409,cmd/i2c.c,do_i2c_mw,"static int do_i2c_mw(struct cmd_tbl *cmdtp, int flag, int argc,
char *const argv[])
{
uintchip;
ulongaddr;
intalen;
ucharbyte;
intcount;
int ret;
#if CONFIG_IS_ENABLED(DM_I2C)
struct udevice *dev;
#endif
if ((argc < 4) || (argc > 5))
return CMD_RET_USAGE;
chip = hextoul(argv[1], NULL);
addr = hextoul(argv[2], NULL);
alen = get_alen(argv[2], DEFAULT_ADDR_LEN);
if (alen > 3)
return CMD_RET_USAGE;
#if CONFIG_IS_ENABLED(DM_I2C)
ret = i2c_get_cur_bus_chip(chip, &dev);
if (!ret && alen != -1)
ret = i2c_set_chip_offset_len(dev, alen);
if (ret)
return i2c_report_err(ret, I2C_ERR_WRITE);
#endif
byte = hextoul(argv[3], NULL);
if (argc == 5)
count = hextoul(argv[4], NULL);
else
count = 1;
while (count-- > 0) {
#if CONFIG_IS_ENABLED(DM_I2C)
ret = dm_i2c_write(dev, addr++, &byte, 1);
#else
ret = i2c_write(chip, addr++, alen, &byte, 1);
#endif
if (ret)
return i2c_report_err(ret, I2C_ERR_WRITE);
#if !defined(CONFIG_SYS_I2C_FRAM)
udelay(11000);
#endif
}
return 0;
}","static int do_i2c_mw(struct cmd_tbl *VAR_0, int VAR_1, int VAR_2,
char *const VAR_3[])
{
uintVAR_4;
ulongVAR_5;
intVAR_6;
ucharVAR_7;
intVAR_8;
int VAR_9;
#if CONFIG_IS_ENABLED(VAR_10)
struct udevice *VAR_11;
#endif
if ((VAR_2 < 4) || (VAR_2 > 5))
return VAR_12;
VAR_4 = hextoul(VAR_3[1], NULL);
VAR_5 = hextoul(VAR_3[2], NULL);
VAR_6 = get_alen(VAR_3[2], VAR_13);
if (VAR_6 > 3)
return VAR_12;
#if CONFIG_IS_ENABLED(VAR_10)
VAR_9 = i2c_get_cur_bus_chip(VAR_4, &VAR_11);
if (!VAR_9 && VAR_6 != -1)
VAR_9 = i2c_set_chip_offset_len(VAR_11, VAR_6);
if (VAR_9)
return i2c_report_err(VAR_9, VAR_14);
#endif
VAR_7 = hextoul(VAR_3[3], NULL);
if (VAR_2 == 5)
VAR_8 = hextoul(VAR_3[4], NULL);
else
VAR_8 = 1;
while (VAR_8-- > 0) {
#if CONFIG_IS_ENABLED(VAR_10)
VAR_9 = dm_i2c_write(VAR_11, VAR_5++, &VAR_7, 1);
#else
VAR_9 = i2c_write(VAR_4, VAR_5++, VAR_6, &VAR_7, 1);
#endif
if (VAR_9)
return i2c_report_err(VAR_9, VAR_14);
#if !defined(VAR_15)
udelay(11000);
#endif
}
return 0;
}",u-boot/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409/i2c.c/vul/before/1.json,"static int do_i2c_mw(struct cmd_tbl *cmdtp, int flag, int argc,
		     char *const argv[])
{
	uint	chip;
	ulong	addr;
	uint	alen;
	uchar	byte;
	uint	count;
	int ret;
#if CONFIG_IS_ENABLED(DM_I2C)
	struct udevice *dev;
#endif

	if ((argc < 4) || (argc > 5))
		return CMD_RET_USAGE;

	/*
	 * Chip is always specified.
	 */
	chip = hextoul(argv[1], NULL);

	/*
	 * Address is always specified.
	 */
	addr = hextoul(argv[2], NULL);
	alen = get_alen(argv[2], DEFAULT_ADDR_LEN);
	if (alen > 3)
		return CMD_RET_USAGE;

#if CONFIG_IS_ENABLED(DM_I2C)
	ret = i2c_get_cur_bus_chip(chip, &dev);
	if (!ret && alen != -1)
		ret = i2c_set_chip_offset_len(dev, alen);
	if (ret)
		return i2c_report_err(ret, I2C_ERR_WRITE);
#endif
	/*
	 * Value to write is always specified.
	 */
	byte = hextoul(argv[3], NULL);

	/*
	 * Optional count
	 */
	if (argc == 5)
		count = hextoul(argv[4], NULL);
	else
		count = 1;

	while (count-- > 0) {
#if CONFIG_IS_ENABLED(DM_I2C)
		ret = dm_i2c_write(dev, addr++, &byte, 1);
#else
		ret = i2c_write(chip, addr++, alen, &byte, 1);
#endif
		if (ret)
			return i2c_report_err(ret, I2C_ERR_WRITE);
		/*
		 * Wait for the write to complete.  The write can take
		 * up to 10mSec (we allow a little more time).
		 */
/*
 * No write delay with FRAM devices.
 */
#if !defined(CONFIG_SYS_I2C_FRAM)
		udelay(11000);
#endif
	}

	return 0;
}","static int do_i2c_mw(struct cmd_tbl *VAR_0, int VAR_1, int VAR_2,
		     char *const VAR_3[])
{
	uint	VAR_4;
	ulong	VAR_5;
	uint	VAR_6;
	uchar	VAR_7;
	uint	VAR_8;
	int VAR_9;
#if CONFIG_IS_ENABLED(VAR_10)
	struct udevice *VAR_11;
#endif

	if ((VAR_2 < 4) || (VAR_2 > 5))
		return VAR_12;

	/* COMMENT_0 */
                             
    
	VAR_4 = hextoul(VAR_3[1], NULL);

	/* COMMENT_3 */
                                
    
	VAR_5 = hextoul(VAR_3[2], NULL);
	VAR_6 = get_alen(VAR_3[2], VAR_13);
	if (VAR_6 > 3)
		return VAR_12;

#if CONFIG_IS_ENABLED(VAR_10)
	VAR_9 = i2c_get_cur_bus_chip(VAR_4, &VAR_11);
	if (!VAR_9 && VAR_6 != -1)
		VAR_9 = i2c_set_chip_offset_len(VAR_11, VAR_6);
	if (VAR_9)
		return i2c_report_err(VAR_9, VAR_14);
#endif
	/* COMMENT_6 */
                                       
    
	VAR_7 = hextoul(VAR_3[3], NULL);

	/* COMMENT_9 */
                  
    
	if (VAR_2 == 5)
		VAR_8 = hextoul(VAR_3[4], NULL);
	else
		VAR_8 = 1;

	while (VAR_8-- > 0) {
#if CONFIG_IS_ENABLED(VAR_10)
		VAR_9 = dm_i2c_write(VAR_11, VAR_5++, &VAR_7, 1);
#else
		VAR_9 = i2c_write(VAR_4, VAR_5++, VAR_6, &VAR_7, 1);
#endif
		if (VAR_9)
			return i2c_report_err(VAR_9, VAR_14);
		/* COMMENT_12 */
                                                        
                                                
     
/* COMMENT_16 */
                                    
   
#if !defined(VAR_15)
		udelay(11000);
#endif
	}

	return 0;
}",u-boot/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409/i2c.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -3,9 +3,9 @@
 {
 	uint	chip;
 	ulong	addr;
-	int	alen;
+	uint	alen;
 	uchar	byte;
-	int	count;
+	uint	count;
 	int ret;
 #if CONFIG_IS_ENABLED(DM_I2C)
 	struct udevice *dev;","{'deleted_lines': ['\tint\talen;', '\tint\tcount;'], 'added_lines': ['\tuint\talen;', '\tuint\tcount;']}",True,"In Das U-Boot through 2022.07-rc5, an integer signedness error and resultant stack-based buffer overflow in the ""i2c md"" command enables the corruption of the return address pointer of the do_i2c_md function.",9.8,CRITICAL,3,test,2022-06-10T14:50:25Z,4
CVE-2022-34835,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,u-boot,"i2c: fix stack buffer overflow vulnerability in i2c md command

When running ""i2c md 0 0 80000100"", the function do_i2c_md parses the
length into an unsigned int variable named length. The value is then
moved to a signed variable:

    int nbytes = length;
    #define DISP_LINE_LEN 16
    int linebytes = (nbytes > DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes;
    ret = dm_i2c_read(dev, addr, linebuf, linebytes);

On systems where integers are 32 bits wide, 0x80000100 is a negative
value to ""nbytes > DISP_LINE_LEN"" is false and linebytes gets assigned
0x80000100 instead of 16.

The consequence is that the function which reads from the i2c device
(dm_i2c_read or i2c_read) is called with a 16-byte stack buffer to fill
but with a size parameter which is too large. In some cases, this could
trigger a crash. But with some i2c drivers, such as drivers/i2c/nx_i2c.c
(used with ""nexell,s5pxx18-i2c"" bus), the size is actually truncated to
a 16-bit integer. This is because function i2c_transfer expects an
unsigned short length. In such a case, an attacker who can control the
response of an i2c device can overwrite the return address of a function
and execute arbitrary code through Return-Oriented Programming.

Fix this issue by using unsigned integers types in do_i2c_md. While at
it, make also alen unsigned, as signed sizes can cause vulnerabilities
when people forgot to check that they can be negative.

Signed-off-by: Nicolas Iooss <nicolas.iooss+uboot@ledger.fr>
Reviewed-by: Heiko Schocher <hs@denx.de>",8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409,https://github.com/u-boot/u-boot/commit/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409,cmd/i2c.c,do_i2c_crc,"static int do_i2c_crc(struct cmd_tbl *cmdtp, int flag, int argc,
char *const argv[])
{
uintchip;
ulongaddr;
intalen;
intcount;
ucharbyte;
ulongcrc;
ulongerr;
int ret = 0;
#if CONFIG_IS_ENABLED(DM_I2C)
struct udevice *dev;
#endif
if (argc < 4)
return CMD_RET_USAGE;
chip = hextoul(argv[1], NULL);
addr = hextoul(argv[2], NULL);
alen = get_alen(argv[2], DEFAULT_ADDR_LEN);
if (alen > 3)
return CMD_RET_USAGE;
#if CONFIG_IS_ENABLED(DM_I2C)
ret = i2c_get_cur_bus_chip(chip, &dev);
if (!ret && alen != -1)
ret = i2c_set_chip_offset_len(dev, alen);
if (ret)
return i2c_report_err(ret, I2C_ERR_READ);
#endif
count = hextoul(argv[3], NULL);
printf (""CRC32 for %08lx ... %08lx ==> "", addr, addr + count - 1);
crc = 0;
err = 0;
while (count-- > 0) {
#if CONFIG_IS_ENABLED(DM_I2C)
ret = dm_i2c_read(dev, addr, &byte, 1);
#else
ret = i2c_read(chip, addr, alen, &byte, 1);
#endif
if (ret)
err++;
crc = crc32(crc, &byte, 1);
addr++;
}
if (err > 0)
i2c_report_err(ret, I2C_ERR_READ);
else
printf (""%08lx\n"", crc);
return 0;
}","static int do_i2c_crc(struct cmd_tbl *VAR_0, int VAR_1, int VAR_2,
char *const VAR_3[])
{
uintVAR_4;
ulongVAR_5;
intVAR_6;
intVAR_7;
ucharVAR_8;
ulongVAR_9;
ulongVAR_10;
int VAR_11 = 0;
#if CONFIG_IS_ENABLED(VAR_12)
struct udevice *VAR_13;
#endif
if (VAR_2 < 4)
return VAR_14;
VAR_4 = hextoul(VAR_3[1], NULL);
VAR_5 = hextoul(VAR_3[2], NULL);
VAR_6 = get_alen(VAR_3[2], VAR_15);
if (VAR_6 > 3)
return VAR_14;
#if CONFIG_IS_ENABLED(VAR_12)
VAR_11 = i2c_get_cur_bus_chip(VAR_4, &VAR_13);
if (!VAR_11 && VAR_6 != -1)
VAR_11 = i2c_set_chip_offset_len(VAR_13, VAR_6);
if (VAR_11)
return i2c_report_err(VAR_11, VAR_16);
#endif
VAR_7 = hextoul(VAR_3[3], NULL);
printf (""CRC32 for %08lx ... %08lx ==> "", VAR_5, VAR_5 + VAR_7 - 1);
VAR_9 = 0;
VAR_10 = 0;
while (VAR_7-- > 0) {
#if CONFIG_IS_ENABLED(VAR_12)
VAR_11 = dm_i2c_read(VAR_13, VAR_5, &VAR_8, 1);
#else
VAR_11 = i2c_read(VAR_4, VAR_5, VAR_6, &VAR_8, 1);
#endif
if (VAR_11)
VAR_10++;
VAR_9 = crc32(VAR_9, &VAR_8, 1);
VAR_5++;
}
if (VAR_10 > 0)
i2c_report_err(VAR_11, VAR_16);
else
printf (""%08lx\n"", VAR_9);
return 0;
}",u-boot/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409/i2c.c/vul/before/6.json,"static int do_i2c_crc(struct cmd_tbl *cmdtp, int flag, int argc,
		      char *const argv[])
{
	uint	chip;
	ulong	addr;
	uint	alen;
	uint	count;
	uchar	byte;
	ulong	crc;
	ulong	err;
	int ret = 0;
#if CONFIG_IS_ENABLED(DM_I2C)
	struct udevice *dev;
#endif

	if (argc < 4)
		return CMD_RET_USAGE;

	/*
	 * Chip is always specified.
	 */
	chip = hextoul(argv[1], NULL);

	/*
	 * Address is always specified.
	 */
	addr = hextoul(argv[2], NULL);
	alen = get_alen(argv[2], DEFAULT_ADDR_LEN);
	if (alen > 3)
		return CMD_RET_USAGE;

#if CONFIG_IS_ENABLED(DM_I2C)
	ret = i2c_get_cur_bus_chip(chip, &dev);
	if (!ret && alen != -1)
		ret = i2c_set_chip_offset_len(dev, alen);
	if (ret)
		return i2c_report_err(ret, I2C_ERR_READ);
#endif
	/*
	 * Count is always specified
	 */
	count = hextoul(argv[3], NULL);

	printf (""CRC32 for %08lx ... %08lx ==> "", addr, addr + count - 1);
	/*
	 * CRC a byte at a time.  This is going to be slooow, but hey, the
	 * memories are small and slow too so hopefully nobody notices.
	 */
	crc = 0;
	err = 0;
	while (count-- > 0) {
#if CONFIG_IS_ENABLED(DM_I2C)
		ret = dm_i2c_read(dev, addr, &byte, 1);
#else
		ret = i2c_read(chip, addr, alen, &byte, 1);
#endif
		if (ret)
			err++;
		crc = crc32(crc, &byte, 1);
		addr++;
	}
	if (err > 0)
		i2c_report_err(ret, I2C_ERR_READ);
	else
		printf (""%08lx\n"", crc);

	return 0;
}","static int do_i2c_crc(struct cmd_tbl *VAR_0, int VAR_1, int VAR_2,
		      char *const VAR_3[])
{
	uint	VAR_4;
	ulong	VAR_5;
	uint	VAR_6;
	uint	VAR_7;
	uchar	VAR_8;
	ulong	VAR_9;
	ulong	VAR_10;
	int VAR_11 = 0;
#if CONFIG_IS_ENABLED(VAR_12)
	struct udevice *VAR_13;
#endif

	if (VAR_2 < 4)
		return VAR_14;

	/* COMMENT_0 */
                             
    
	VAR_4 = hextoul(VAR_3[1], NULL);

	/* COMMENT_3 */
                                
    
	VAR_5 = hextoul(VAR_3[2], NULL);
	VAR_6 = get_alen(VAR_3[2], VAR_15);
	if (VAR_6 > 3)
		return VAR_14;

#if CONFIG_IS_ENABLED(VAR_12)
	VAR_11 = i2c_get_cur_bus_chip(VAR_4, &VAR_13);
	if (!VAR_11 && VAR_6 != -1)
		VAR_11 = i2c_set_chip_offset_len(VAR_13, VAR_6);
	if (VAR_11)
		return i2c_report_err(VAR_11, VAR_16);
#endif
	/* COMMENT_6 */
                             
    
	VAR_7 = hextoul(VAR_3[3], NULL);

	printf (""CRC32 for %08lx ... %08lx ==> "", VAR_5, VAR_5 + VAR_7 - 1);
	/* COMMENT_9 */
                                                                   
                                                                
    
	VAR_9 = 0;
	VAR_10 = 0;
	while (VAR_7-- > 0) {
#if CONFIG_IS_ENABLED(VAR_12)
		VAR_11 = dm_i2c_read(VAR_13, VAR_5, &VAR_8, 1);
#else
		VAR_11 = i2c_read(VAR_4, VAR_5, VAR_6, &VAR_8, 1);
#endif
		if (VAR_11)
			VAR_10++;
		VAR_9 = crc32(VAR_9, &VAR_8, 1);
		VAR_5++;
	}
	if (VAR_10 > 0)
		i2c_report_err(VAR_11, VAR_16);
	else
		printf (""%08lx\n"", VAR_9);

	return 0;
}",u-boot/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409/i2c.c/vul/after/6.json,"--- func_before
+++ func_after
@@ -3,8 +3,8 @@
 {
 	uint	chip;
 	ulong	addr;
-	int	alen;
-	int	count;
+	uint	alen;
+	uint	count;
 	uchar	byte;
 	ulong	crc;
 	ulong	err;","{'deleted_lines': ['\tint\talen;', '\tint\tcount;'], 'added_lines': ['\tuint\talen;', '\tuint\tcount;']}",True,"In Das U-Boot through 2022.07-rc5, an integer signedness error and resultant stack-based buffer overflow in the ""i2c md"" command enables the corruption of the return address pointer of the do_i2c_md function.",9.8,CRITICAL,3,test,2022-06-10T14:50:25Z,4
CVE-2022-34835,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,u-boot,"i2c: fix stack buffer overflow vulnerability in i2c md command

When running ""i2c md 0 0 80000100"", the function do_i2c_md parses the
length into an unsigned int variable named length. The value is then
moved to a signed variable:

    int nbytes = length;
    #define DISP_LINE_LEN 16
    int linebytes = (nbytes > DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes;
    ret = dm_i2c_read(dev, addr, linebuf, linebytes);

On systems where integers are 32 bits wide, 0x80000100 is a negative
value to ""nbytes > DISP_LINE_LEN"" is false and linebytes gets assigned
0x80000100 instead of 16.

The consequence is that the function which reads from the i2c device
(dm_i2c_read or i2c_read) is called with a 16-byte stack buffer to fill
but with a size parameter which is too large. In some cases, this could
trigger a crash. But with some i2c drivers, such as drivers/i2c/nx_i2c.c
(used with ""nexell,s5pxx18-i2c"" bus), the size is actually truncated to
a 16-bit integer. This is because function i2c_transfer expects an
unsigned short length. In such a case, an attacker who can control the
response of an i2c device can overwrite the return address of a function
and execute arbitrary code through Return-Oriented Programming.

Fix this issue by using unsigned integers types in do_i2c_md. While at
it, make also alen unsigned, as signed sizes can cause vulnerabilities
when people forgot to check that they can be negative.

Signed-off-by: Nicolas Iooss <nicolas.iooss+uboot@ledger.fr>
Reviewed-by: Heiko Schocher <hs@denx.de>",8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409,https://github.com/u-boot/u-boot/commit/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409,cmd/i2c.c,do_i2c_read,"static int do_i2c_read(struct cmd_tbl *cmdtp, int flag, int argc,
char *const argv[])
{
uintchip;
uintdevaddr, length;
int alen;
u_char  *memaddr;
int ret;
#if CONFIG_IS_ENABLED(DM_I2C)
struct udevice *dev;
#endif
if (argc != 5)
return CMD_RET_USAGE;
chip = hextoul(argv[1], NULL);
devaddr = hextoul(argv[2], NULL);
alen = get_alen(argv[2], DEFAULT_ADDR_LEN);
if (alen > 3)
return CMD_RET_USAGE;
length = hextoul(argv[3], NULL);
memaddr = (u_char *)hextoul(argv[4], NULL);
#if CONFIG_IS_ENABLED(DM_I2C)
ret = i2c_get_cur_bus_chip(chip, &dev);
if (!ret && alen != -1)
ret = i2c_set_chip_offset_len(dev, alen);
if (!ret)
ret = dm_i2c_read(dev, devaddr, memaddr, length);
#else
ret = i2c_read(chip, devaddr, alen, memaddr, length);
#endif
if (ret)
return i2c_report_err(ret, I2C_ERR_READ);
return 0;
}","static int do_i2c_read(struct cmd_tbl *VAR_0, int VAR_1, int VAR_2,
char *const VAR_3[])
{
uintVAR_4;
uintVAR_5, VAR_6;
int VAR_7;
u_char  *VAR_8;
int VAR_9;
#if CONFIG_IS_ENABLED(VAR_10)
struct udevice *VAR_11;
#endif
if (VAR_2 != 5)
return VAR_12;
VAR_4 = hextoul(VAR_3[1], NULL);
VAR_5 = hextoul(VAR_3[2], NULL);
VAR_7 = get_alen(VAR_3[2], VAR_13);
if (VAR_7 > 3)
return VAR_12;
VAR_6 = hextoul(VAR_3[3], NULL);
VAR_8 = (u_char *)hextoul(VAR_3[4], NULL);
#if CONFIG_IS_ENABLED(VAR_10)
VAR_9 = i2c_get_cur_bus_chip(VAR_4, &VAR_11);
if (!VAR_9 && VAR_7 != -1)
VAR_9 = i2c_set_chip_offset_len(VAR_11, VAR_7);
if (!VAR_9)
VAR_9 = dm_i2c_read(VAR_11, VAR_5, VAR_8, VAR_6);
#else
VAR_9 = i2c_read(VAR_4, VAR_5, VAR_7, VAR_8, VAR_6);
#endif
if (VAR_9)
return i2c_report_err(VAR_9, VAR_14);
return 0;
}",u-boot/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409/i2c.c/vul/before/5.json,"static int do_i2c_read(struct cmd_tbl *cmdtp, int flag, int argc,
		       char *const argv[])
{
	uint	chip;
	uint	devaddr, length;
	uint	alen;
	u_char  *memaddr;
	int ret;
#if CONFIG_IS_ENABLED(DM_I2C)
	struct udevice *dev;
#endif

	if (argc != 5)
		return CMD_RET_USAGE;

	/*
	 * I2C chip address
	 */
	chip = hextoul(argv[1], NULL);

	/*
	 * I2C data address within the chip.  This can be 1 or
	 * 2 bytes long.  Some day it might be 3 bytes long :-).
	 */
	devaddr = hextoul(argv[2], NULL);
	alen = get_alen(argv[2], DEFAULT_ADDR_LEN);
	if (alen > 3)
		return CMD_RET_USAGE;

	/*
	 * Length is the number of objects, not number of bytes.
	 */
	length = hextoul(argv[3], NULL);

	/*
	 * memaddr is the address where to store things in memory
	 */
	memaddr = (u_char *)hextoul(argv[4], NULL);

#if CONFIG_IS_ENABLED(DM_I2C)
	ret = i2c_get_cur_bus_chip(chip, &dev);
	if (!ret && alen != -1)
		ret = i2c_set_chip_offset_len(dev, alen);
	if (!ret)
		ret = dm_i2c_read(dev, devaddr, memaddr, length);
#else
	ret = i2c_read(chip, devaddr, alen, memaddr, length);
#endif
	if (ret)
		return i2c_report_err(ret, I2C_ERR_READ);

	return 0;
}","static int do_i2c_read(struct cmd_tbl *VAR_0, int VAR_1, int VAR_2,
		       char *const VAR_3[])
{
	uint	VAR_4;
	uint	VAR_5, VAR_6;
	uint	VAR_7;
	u_char  *VAR_8;
	int VAR_9;
#if CONFIG_IS_ENABLED(VAR_10)
	struct udevice *VAR_11;
#endif

	if (VAR_2 != 5)
		return VAR_12;

	/* COMMENT_0 */
                    
    
	VAR_4 = hextoul(VAR_3[1], NULL);

	/* COMMENT_3 */
                                                       
                                                         
    
	VAR_5 = hextoul(VAR_3[2], NULL);
	VAR_7 = get_alen(VAR_3[2], VAR_13);
	if (VAR_7 > 3)
		return VAR_12;

	/* COMMENT_7 */
                                                         
    
	VAR_6 = hextoul(VAR_3[3], NULL);

	/* COMMENT_10 */
                                                          
    
	VAR_8 = (u_char *)hextoul(VAR_3[4], NULL);

#if CONFIG_IS_ENABLED(VAR_10)
	VAR_9 = i2c_get_cur_bus_chip(VAR_4, &VAR_11);
	if (!VAR_9 && VAR_7 != -1)
		VAR_9 = i2c_set_chip_offset_len(VAR_11, VAR_7);
	if (!VAR_9)
		VAR_9 = dm_i2c_read(VAR_11, VAR_5, VAR_8, VAR_6);
#else
	VAR_9 = i2c_read(VAR_4, VAR_5, VAR_7, VAR_8, VAR_6);
#endif
	if (VAR_9)
		return i2c_report_err(VAR_9, VAR_14);

	return 0;
}",u-boot/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409/i2c.c/vul/after/5.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 {
 	uint	chip;
 	uint	devaddr, length;
-	int alen;
+	uint	alen;
 	u_char  *memaddr;
 	int ret;
 #if CONFIG_IS_ENABLED(DM_I2C)","{'deleted_lines': ['\tint alen;'], 'added_lines': ['\tuint\talen;']}",True,"In Das U-Boot through 2022.07-rc5, an integer signedness error and resultant stack-based buffer overflow in the ""i2c md"" command enables the corruption of the return address pointer of the do_i2c_md function.",9.8,CRITICAL,3,test,2022-06-10T14:50:25Z,4
CVE-2022-34299,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0,davea42/libdwarf-code,"Fixes old bug(which could result in Denial of Service)
due to a missing check before reading the 8 bytes of a DW_FORM_ref_sig8.
DW202206-001
	modified:   src/lib/libdwarf/dwarf_form.c",7ef09e1fc9ba07653dd078edb2408631c7969162,https://github.com/davea42/libdwarf-code/commit/7ef09e1fc9ba07653dd078edb2408631c7969162,src/lib/libdwarf/dwarf_form.c,dwarf_global_formref_b,"int
dwarf_global_formref_b(Dwarf_Attribute attr,
Dwarf_Off * ret_offset,
Dwarf_Bool * offset_is_info,
Dwarf_Error * error)
{
Dwarf_Debug dbg = 0;
Dwarf_Unsigned offset = 0;
Dwarf_CU_Context cu_context = 0;
Dwarf_Half context_version = 0;
Dwarf_Byte_Ptr section_end = 0;
Dwarf_Bool is_info = TRUE;
int res  = get_attr_dbg(&dbg,&cu_context,attr,error);
if (res != DW_DLV_OK) {
return res;
}
section_end =
_dwarf_calculate_info_section_end_ptr(cu_context);
context_version = cu_context->cc_version_stamp;
is_info = cu_context->cc_is_info;
switch (attr->ar_attribute_form) {
case DW_FORM_ref1:
offset = *(Dwarf_Small *) attr->ar_debug_ptr;
goto fixoffset;
case DW_FORM_ref2:
READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
attr->ar_debug_ptr, DWARF_HALF_SIZE,
error,section_end);
goto fixoffset;
case DW_FORM_ref4:
READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
attr->ar_debug_ptr, DWARF_32BIT_SIZE,
error,section_end);
goto fixoffset;
case DW_FORM_ref8:
READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
attr->ar_debug_ptr, DWARF_64BIT_SIZE,
error,section_end);
goto fixoffset;
case DW_FORM_ref_udata:
{
Dwarf_Byte_Ptr ptr = attr->ar_debug_ptr;
Dwarf_Unsigned localoffset = 0;
DECODE_LEB128_UWORD_CK(ptr,localoffset,
dbg,error,section_end);
offset = localoffset;
fixoffset: 
if (offset >= cu_context->cc_length +
cu_context->cc_length_size +
cu_context->cc_extension_size) {
_dwarf_error(dbg, error, DW_DLE_ATTR_FORM_OFFSET_BAD);
return DW_DLV_ERROR;
}
offset += cu_context->cc_debug_offset;
}
break;
case DW_FORM_data4:
if (context_version >= DW_CU_VERSION4) {
_dwarf_error(dbg, error, DW_DLE_NOT_REF_FORM);
return DW_DLV_ERROR;
}
READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
attr->ar_debug_ptr, DWARF_32BIT_SIZE,
error, section_end);
break;
case DW_FORM_data8:
if (context_version >= DW_CU_VERSION4) {
_dwarf_error(dbg, error, DW_DLE_NOT_REF_FORM);
return DW_DLV_ERROR;
}
READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
attr->ar_debug_ptr, DWARF_64BIT_SIZE,
error,section_end);
break;
case DW_FORM_ref_addr:
{
unsigned length_size = 0;
if (context_version == 2) {
length_size = cu_context->cc_address_size;
} else {
length_size = cu_context->cc_length_size;
}
if (length_size == 4) {
READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
attr->ar_debug_ptr, DWARF_32BIT_SIZE,
error,section_end);
} else if (length_size == 8) {
READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
attr->ar_debug_ptr, DWARF_64BIT_SIZE,
error,section_end);
} else {
_dwarf_error(dbg, error,
DW_DLE_FORM_SEC_OFFSET_LENGTH_BAD);
return DW_DLV_ERROR;
}
}
break;
case DW_FORM_loclistx:
case DW_FORM_rnglistx: {
unsigned length_size = cu_context->cc_length_size;
READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
attr->ar_debug_ptr, length_size,
error,section_end);
}
break;
case DW_FORM_sec_offset:
case DW_FORM_GNU_ref_alt:  
case DW_FORM_GNU_strp_alt: 
case DW_FORM_strp_sup:     
case DW_FORM_line_strp:    
{
unsigned length_size = cu_context->cc_length_size;
if (length_size == 4) {
READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
attr->ar_debug_ptr, DWARF_32BIT_SIZE,
error,section_end);
} else if (length_size == 8) {
READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
attr->ar_debug_ptr, DWARF_64BIT_SIZE,
error,section_end);
} else {
_dwarf_error(dbg, error,
DW_DLE_FORM_SEC_OFFSET_LENGTH_BAD);
return DW_DLV_ERROR;
}
}
break;
case DW_FORM_ref_sig8: {
Dwarf_Sig8 sig8;
Dwarf_Bool t_is_info = TRUE;
Dwarf_Unsigned t_offset = 0;
memcpy(&sig8,attr->ar_debug_ptr,sizeof(Dwarf_Sig8));
res = find_sig8_target_as_global_offset(attr,
&sig8,&t_is_info,&t_offset,error);
if (res == DW_DLV_ERROR) {
_dwarf_error_string(dbg, error,
DW_DLE_REF_SIG8_NOT_HANDLED,
""DW_DLE_REF_SIG8_NOT_HANDLED: ""
"" problem finding target"");
return DW_DLV_ERROR;
}
if (res == DW_DLV_NO_ENTRY) {
return res;
}
is_info = t_is_info;
offset = t_offset;
break;
}
default: {
dwarfstring m;
int formcode = attr->ar_attribute_form;
int fcres = 0;
const char *name = 0;
dwarfstring_constructor(&m);
dwarfstring_append_printf_u(&m,
""DW_DLE_BAD_REF_FORM: The form code is 0x%x "",
formcode);
fcres  = dwarf_get_FORM_name (formcode,&name);
if (fcres != DW_DLV_OK) {
name=""<UnknownFormCode>"";
}
dwarfstring_append_printf_s(&m,
"" %s."",(char *)name);
_dwarf_error_string(dbg, error, DW_DLE_BAD_REF_FORM,
dwarfstring_string(&m));
dwarfstring_destructor(&m);
return DW_DLV_ERROR;
}
}
*offset_is_info = is_info;
*ret_offset = offset;
return DW_DLV_OK;
}","int
dwarf_global_formref_b(Dwarf_Attribute VAR_0,
Dwarf_Off * VAR_1,
Dwarf_Bool * VAR_2,
Dwarf_Error * VAR_3)
{
Dwarf_Debug VAR_4 = 0;
Dwarf_Unsigned VAR_5 = 0;
Dwarf_CU_Context VAR_6 = 0;
Dwarf_Half VAR_7 = 0;
Dwarf_Byte_Ptr VAR_8 = 0;
Dwarf_Bool VAR_9 = TRUE;
int VAR_10  = get_attr_dbg(&VAR_4,&VAR_6,VAR_0,VAR_3);
if (VAR_10 != VAR_11) {
return VAR_10;
}
VAR_8 =
_dwarf_calculate_info_section_end_ptr(VAR_6);
VAR_7 = VAR_6->cc_version_stamp;
VAR_9 = VAR_6->cc_is_info;
switch (VAR_0->ar_attribute_form) {
case VAR_12:
VAR_5 = *(Dwarf_Small *) VAR_0->ar_debug_ptr;
goto fixoffset;
case VAR_13:
READ_UNALIGNED_CK(VAR_4, VAR_5, Dwarf_Unsigned,
VAR_0->ar_debug_ptr, VAR_14,
VAR_3,VAR_8);
goto fixoffset;
case VAR_15:
READ_UNALIGNED_CK(VAR_4, VAR_5, Dwarf_Unsigned,
VAR_0->ar_debug_ptr, VAR_16,
VAR_3,VAR_8);
goto fixoffset;
case VAR_17:
READ_UNALIGNED_CK(VAR_4, VAR_5, Dwarf_Unsigned,
VAR_0->ar_debug_ptr, VAR_18,
VAR_3,VAR_8);
goto fixoffset;
case VAR_19:
{
Dwarf_Byte_Ptr VAR_20 = VAR_0->ar_debug_ptr;
Dwarf_Unsigned VAR_21 = 0;
DECODE_LEB128_UWORD_CK(VAR_20,VAR_21,
VAR_4,VAR_3,VAR_8);
VAR_5 = VAR_21;
fixoffset: 
if (VAR_5 >= VAR_6->cc_length +
VAR_6->cc_length_size +
VAR_6->cc_extension_size) {
_dwarf_error(VAR_4, VAR_3, VAR_22);
return VAR_23;
}
VAR_5 += VAR_6->cc_debug_offset;
}
break;
case VAR_24:
if (VAR_7 >= VAR_25) {
_dwarf_error(VAR_4, VAR_3, VAR_26);
return VAR_23;
}
READ_UNALIGNED_CK(VAR_4, VAR_5, Dwarf_Unsigned,
VAR_0->ar_debug_ptr, VAR_16,
VAR_3, VAR_8);
break;
case VAR_27:
if (VAR_7 >= VAR_25) {
_dwarf_error(VAR_4, VAR_3, VAR_26);
return VAR_23;
}
READ_UNALIGNED_CK(VAR_4, VAR_5, Dwarf_Unsigned,
VAR_0->ar_debug_ptr, VAR_18,
VAR_3,VAR_8);
break;
case VAR_28:
{
unsigned VAR_29 = 0;
if (VAR_7 == 2) {
VAR_29 = VAR_6->cc_address_size;
} else {
VAR_29 = VAR_6->cc_length_size;
}
if (VAR_29 == 4) {
READ_UNALIGNED_CK(VAR_4, VAR_5, Dwarf_Unsigned,
VAR_0->ar_debug_ptr, VAR_16,
VAR_3,VAR_8);
} else if (VAR_29 == 8) {
READ_UNALIGNED_CK(VAR_4, VAR_5, Dwarf_Unsigned,
VAR_0->ar_debug_ptr, VAR_18,
VAR_3,VAR_8);
} else {
_dwarf_error(VAR_4, VAR_3,
VAR_30);
return VAR_23;
}
}
break;
case VAR_31:
case VAR_32: {
unsigned VAR_29 = VAR_6->cc_length_size;
READ_UNALIGNED_CK(VAR_4, VAR_5, Dwarf_Unsigned,
VAR_0->ar_debug_ptr, VAR_29,
VAR_3,VAR_8);
}
break;
case VAR_33:
case VAR_34:  
case VAR_35: 
case VAR_36:     
case VAR_37:    
{
unsigned VAR_29 = VAR_6->cc_length_size;
if (VAR_29 == 4) {
READ_UNALIGNED_CK(VAR_4, VAR_5, Dwarf_Unsigned,
VAR_0->ar_debug_ptr, VAR_16,
VAR_3,VAR_8);
} else if (VAR_29 == 8) {
READ_UNALIGNED_CK(VAR_4, VAR_5, Dwarf_Unsigned,
VAR_0->ar_debug_ptr, VAR_18,
VAR_3,VAR_8);
} else {
_dwarf_error(VAR_4, VAR_3,
VAR_30);
return VAR_23;
}
}
break;
case VAR_38: {
Dwarf_Sig8 VAR_39;
Dwarf_Bool VAR_40 = TRUE;
Dwarf_Unsigned VAR_41 = 0;
memcpy(&VAR_39,VAR_0->ar_debug_ptr,sizeof(Dwarf_Sig8));
VAR_10 = find_sig8_target_as_global_offset(VAR_0,
&VAR_39,&VAR_40,&VAR_41,VAR_3);
if (VAR_10 == VAR_23) {
_dwarf_error_string(VAR_4, VAR_3,
VAR_42,
""DW_DLE_REF_SIG8_NOT_HANDLED: ""
"" problem finding target"");
return VAR_23;
}
if (VAR_10 == VAR_43) {
return VAR_10;
}
VAR_9 = VAR_40;
VAR_5 = VAR_41;
break;
}
default: {
dwarfstring VAR_44;
int VAR_45 = VAR_0->ar_attribute_form;
int VAR_46 = 0;
const char *VAR_47 = 0;
dwarfstring_constructor(&VAR_44);
dwarfstring_append_printf_u(&VAR_44,
""DW_DLE_BAD_REF_FORM: The form code is 0x%x "",
VAR_45);
VAR_46  = dwarf_get_FORM_name (VAR_45,&VAR_47);
if (VAR_46 != VAR_11) {
VAR_47=""<UnknownFormCode>"";
}
dwarfstring_append_printf_s(&VAR_44,
"" %s."",(char *)VAR_47);
_dwarf_error_string(VAR_4, VAR_3, VAR_48,
dwarfstring_string(&VAR_44));
dwarfstring_destructor(&VAR_44);
return VAR_23;
}
}
*VAR_2 = VAR_9;
*VAR_1 = VAR_5;
return VAR_11;
}",davea42/libdwarf-code/7ef09e1fc9ba07653dd078edb2408631c7969162/dwarf_form.c/vul/before/1.json,"int
dwarf_global_formref_b(Dwarf_Attribute attr,
    Dwarf_Off * ret_offset,
    Dwarf_Bool * offset_is_info,
    Dwarf_Error * error)
{
    Dwarf_Debug dbg = 0;
    Dwarf_Unsigned offset = 0;
    Dwarf_CU_Context cu_context = 0;
    Dwarf_Half context_version = 0;
    Dwarf_Byte_Ptr section_end = 0;
    Dwarf_Bool is_info = TRUE;

    int res  = get_attr_dbg(&dbg,&cu_context,attr,error);
    if (res != DW_DLV_OK) {
        return res;
    }
    section_end =
        _dwarf_calculate_info_section_end_ptr(cu_context);
    context_version = cu_context->cc_version_stamp;
    is_info = cu_context->cc_is_info;
    switch (attr->ar_attribute_form) {

    case DW_FORM_ref1:
        offset = *(Dwarf_Small *) attr->ar_debug_ptr;
        goto fixoffset;

    case DW_FORM_ref2:
        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
            attr->ar_debug_ptr, DWARF_HALF_SIZE,
            error,section_end);
        goto fixoffset;

    case DW_FORM_ref4:
        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
            attr->ar_debug_ptr, DWARF_32BIT_SIZE,
            error,section_end);
        goto fixoffset;

    case DW_FORM_ref8:
        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
            attr->ar_debug_ptr, DWARF_64BIT_SIZE,
            error,section_end);
        goto fixoffset;

    case DW_FORM_ref_udata:
        {
        Dwarf_Byte_Ptr ptr = attr->ar_debug_ptr;
        Dwarf_Unsigned localoffset = 0;

        DECODE_LEB128_UWORD_CK(ptr,localoffset,
            dbg,error,section_end);
        offset = localoffset;

        fixoffset: /* we have a local offset, make it global */

        /* check legality of offset */
        if (offset >= cu_context->cc_length +
            cu_context->cc_length_size +
            cu_context->cc_extension_size) {
            _dwarf_error(dbg, error, DW_DLE_ATTR_FORM_OFFSET_BAD);
            return DW_DLV_ERROR;
        }

        /* globalize the offset */
        offset += cu_context->cc_debug_offset;
        }
        break;

    /*  The DWARF2 document did not make clear that
        DW_FORM_data4( and 8) were references with
        global offsets to some section.
        That was first clearly documented in DWARF3.
        In DWARF4 these two forms are no longer references. */
    case DW_FORM_data4:
        if (context_version >= DW_CU_VERSION4) {
            _dwarf_error(dbg, error, DW_DLE_NOT_REF_FORM);
            return DW_DLV_ERROR;
        }
        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
            attr->ar_debug_ptr, DWARF_32BIT_SIZE,
            error, section_end);
        /* The offset is global. */
        break;
    case DW_FORM_data8:
        if (context_version >= DW_CU_VERSION4) {
            _dwarf_error(dbg, error, DW_DLE_NOT_REF_FORM);
            return DW_DLV_ERROR;
        }
        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
            attr->ar_debug_ptr, DWARF_64BIT_SIZE,
            error,section_end);
        /* The offset is global. */
        break;
    case DW_FORM_ref_addr:
        {
            /*  In Dwarf V2 DW_FORM_ref_addr was defined
                as address-size even though it is a .debug_info
                offset.  Fixed in Dwarf V3 to be offset-size.
                */
            unsigned length_size = 0;
            if (context_version == 2) {
                length_size = cu_context->cc_address_size;
            } else {
                length_size = cu_context->cc_length_size;
            }
            if (length_size == 4) {
                READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
                    attr->ar_debug_ptr, DWARF_32BIT_SIZE,
                    error,section_end);
            } else if (length_size == 8) {
                READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
                    attr->ar_debug_ptr, DWARF_64BIT_SIZE,
                    error,section_end);
            } else {
                _dwarf_error(dbg, error,
                    DW_DLE_FORM_SEC_OFFSET_LENGTH_BAD);
                return DW_DLV_ERROR;
            }
        }
        break;
    /*  Index into .debug_rnglists/.debug_loclists section.
        Return the index itself. */
    case DW_FORM_loclistx:
    case DW_FORM_rnglistx: {
        unsigned length_size = cu_context->cc_length_size;
        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
            attr->ar_debug_ptr, length_size,
            error,section_end);
        }
        break;
    case DW_FORM_sec_offset:
    case DW_FORM_GNU_ref_alt:  /* 2013 GNU extension */
    case DW_FORM_GNU_strp_alt: /* 2013 GNU extension */
    case DW_FORM_strp_sup:     /* DWARF5, sup string section */
    case DW_FORM_line_strp:    /* DWARF5, .debug_line_str section */
        {
            /*  DW_FORM_sec_offset first exists in DWARF4.*/
            /*  It is up to the caller to know what the offset
                of DW_FORM_sec_offset, DW_FORM_strp_sup
                or DW_FORM_GNU_strp_alt etc refer to,
                the offset is not going to refer to .debug_info! */
            unsigned length_size = cu_context->cc_length_size;
            if (length_size == 4) {
                READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
                    attr->ar_debug_ptr, DWARF_32BIT_SIZE,
                    error,section_end);
            } else if (length_size == 8) {
                READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,
                    attr->ar_debug_ptr, DWARF_64BIT_SIZE,
                    error,section_end);
            } else {
                _dwarf_error(dbg, error,
                    DW_DLE_FORM_SEC_OFFSET_LENGTH_BAD);
                return DW_DLV_ERROR;
            }
        }
        break;
    case DW_FORM_ref_sig8: {
        /*  This, in DWARF4, is how
            .debug_info refers to .debug_types. */
        Dwarf_Sig8 sig8;
        Dwarf_Bool t_is_info = TRUE;
        Dwarf_Unsigned t_offset = 0;

        if ((attr->ar_debug_ptr + sizeof(Dwarf_Sig8)) > section_end) {
            _dwarf_error_string(dbg, error,
                DW_DLE_REF_SIG8_NOT_HANDLED,
                ""DW_DLE_REF_SIG8_NOT_HANDLED: ""
                "" Dwarf_Sig8 content runs off the end of its section"");
            return DW_DLV_ERROR;
        }
        memcpy(&sig8,attr->ar_debug_ptr,sizeof(Dwarf_Sig8));
        res = find_sig8_target_as_global_offset(attr,
            &sig8,&t_is_info,&t_offset,error);
        if (res == DW_DLV_ERROR) {
            _dwarf_error_string(dbg, error,
                DW_DLE_REF_SIG8_NOT_HANDLED,
                ""DW_DLE_REF_SIG8_NOT_HANDLED: ""
                "" problem finding target"");
            return DW_DLV_ERROR;
        }
        if (res == DW_DLV_NO_ENTRY) {
            return res;
        }
        is_info = t_is_info;
        offset = t_offset;
        break;
    }
    default: {
        dwarfstring m;
        int formcode = attr->ar_attribute_form;
        int fcres = 0;
        const char *name = 0;

        dwarfstring_constructor(&m);
        dwarfstring_append_printf_u(&m,
            ""DW_DLE_BAD_REF_FORM: The form code is 0x%x "",
            formcode);
        fcres  = dwarf_get_FORM_name (formcode,&name);
        if (fcres != DW_DLV_OK) {
            name=""<UnknownFormCode>"";
        }
        dwarfstring_append_printf_s(&m,
            "" %s."",(char *)name);
        _dwarf_error_string(dbg, error, DW_DLE_BAD_REF_FORM,
            dwarfstring_string(&m));
        dwarfstring_destructor(&m);
        return DW_DLV_ERROR;
        }
    }

    *offset_is_info = is_info;
    *ret_offset = offset;
    return DW_DLV_OK;
}","int
dwarf_global_formref_b(Dwarf_Attribute VAR_0,
    Dwarf_Off * VAR_1,
    Dwarf_Bool * VAR_2,
    Dwarf_Error * VAR_3)
{
    Dwarf_Debug VAR_4 = 0;
    Dwarf_Unsigned VAR_5 = 0;
    Dwarf_CU_Context VAR_6 = 0;
    Dwarf_Half VAR_7 = 0;
    Dwarf_Byte_Ptr VAR_8 = 0;
    Dwarf_Bool VAR_9 = TRUE;

    int VAR_10  = get_attr_dbg(&VAR_4,&VAR_6,VAR_0,VAR_3);
    if (VAR_10 != VAR_11) {
        return VAR_10;
    }
    VAR_8 =
        _dwarf_calculate_info_section_end_ptr(VAR_6);
    VAR_7 = VAR_6->cc_version_stamp;
    VAR_9 = VAR_6->cc_is_info;
    switch (VAR_0->ar_attribute_form) {

    case VAR_12:
        VAR_5 = *(Dwarf_Small *) VAR_0->ar_debug_ptr;
        goto fixoffset;

    case VAR_13:
        READ_UNALIGNED_CK(VAR_4, VAR_5, Dwarf_Unsigned,
            VAR_0->ar_debug_ptr, VAR_14,
            VAR_3,VAR_8);
        goto fixoffset;

    case VAR_15:
        READ_UNALIGNED_CK(VAR_4, VAR_5, Dwarf_Unsigned,
            VAR_0->ar_debug_ptr, VAR_16,
            VAR_3,VAR_8);
        goto fixoffset;

    case VAR_17:
        READ_UNALIGNED_CK(VAR_4, VAR_5, Dwarf_Unsigned,
            VAR_0->ar_debug_ptr, VAR_18,
            VAR_3,VAR_8);
        goto fixoffset;

    case VAR_19:
        {
        Dwarf_Byte_Ptr VAR_20 = VAR_0->ar_debug_ptr;
        Dwarf_Unsigned VAR_21 = 0;

        DECODE_LEB128_UWORD_CK(VAR_20,VAR_21,
            VAR_4,VAR_3,VAR_8);
        VAR_5 = VAR_21;

        fixoffset: /* COMMENT_0 */

        /* COMMENT_1 */
        if (VAR_5 >= VAR_6->cc_length +
            VAR_6->cc_length_size +
            VAR_6->cc_extension_size) {
            _dwarf_error(VAR_4, VAR_3, VAR_22);
            return VAR_23;
        }

        /* COMMENT_2 */
        VAR_5 += VAR_6->cc_debug_offset;
        }
        break;

    /* COMMENT_3 */
                                                  
                                       
                                                    
                                                              
    case VAR_24:
        if (VAR_7 >= VAR_25) {
            _dwarf_error(VAR_4, VAR_3, VAR_26);
            return VAR_23;
        }
        READ_UNALIGNED_CK(VAR_4, VAR_5, Dwarf_Unsigned,
            VAR_0->ar_debug_ptr, VAR_16,
            VAR_3, VAR_8);
        /* COMMENT_8 */
        break;
    case VAR_27:
        if (VAR_7 >= VAR_25) {
            _dwarf_error(VAR_4, VAR_3, VAR_26);
            return VAR_23;
        }
        READ_UNALIGNED_CK(VAR_4, VAR_5, Dwarf_Unsigned,
            VAR_0->ar_debug_ptr, VAR_18,
            VAR_3,VAR_8);
        /* COMMENT_8 */
        break;
    case VAR_28:
        {
            /* COMMENT_9 */
                                                               
                                                             
                  
            unsigned VAR_29 = 0;
            if (VAR_7 == 2) {
                VAR_29 = VAR_6->cc_address_size;
            } else {
                VAR_29 = VAR_6->cc_length_size;
            }
            if (VAR_29 == 4) {
                READ_UNALIGNED_CK(VAR_4, VAR_5, Dwarf_Unsigned,
                    VAR_0->ar_debug_ptr, VAR_16,
                    VAR_3,VAR_8);
            } else if (VAR_29 == 8) {
                READ_UNALIGNED_CK(VAR_4, VAR_5, Dwarf_Unsigned,
                    VAR_0->ar_debug_ptr, VAR_18,
                    VAR_3,VAR_8);
            } else {
                _dwarf_error(VAR_4, VAR_3,
                    VAR_30);
                return VAR_23;
            }
        }
        break;
    /* COMMENT_13 */
                                   
    case VAR_31:
    case VAR_32: {
        unsigned VAR_29 = VAR_6->cc_length_size;
        READ_UNALIGNED_CK(VAR_4, VAR_5, Dwarf_Unsigned,
            VAR_0->ar_debug_ptr, VAR_29,
            VAR_3,VAR_8);
        }
        break;
    case VAR_33:
    case VAR_34:  /* COMMENT_15 */
    case VAR_35: /* COMMENT_15 */
    case VAR_36:     /* COMMENT_16 */
    case VAR_37:    /* COMMENT_17 */
        {
            /* COMMENT_18 */
            /* COMMENT_19 */
                                                       
                                                     
                                                                   
            unsigned VAR_29 = VAR_6->cc_length_size;
            if (VAR_29 == 4) {
                READ_UNALIGNED_CK(VAR_4, VAR_5, Dwarf_Unsigned,
                    VAR_0->ar_debug_ptr, VAR_16,
                    VAR_3,VAR_8);
            } else if (VAR_29 == 8) {
                READ_UNALIGNED_CK(VAR_4, VAR_5, Dwarf_Unsigned,
                    VAR_0->ar_debug_ptr, VAR_18,
                    VAR_3,VAR_8);
            } else {
                _dwarf_error(VAR_4, VAR_3,
                    VAR_30);
                return VAR_23;
            }
        }
        break;
    case VAR_38: {
        /* COMMENT_23 */
                                                  
        Dwarf_Sig8 VAR_39;
        Dwarf_Bool VAR_40 = TRUE;
        Dwarf_Unsigned VAR_41 = 0;

        if ((VAR_0->ar_debug_ptr + sizeof(Dwarf_Sig8)) > VAR_8) {
            _dwarf_error_string(VAR_4, VAR_3,
                VAR_42,
                ""DW_DLE_REF_SIG8_NOT_HANDLED: ""
                "" Dwarf_Sig8 content runs off the end of its section"");
            return VAR_23;
        }
        memcpy(&VAR_39,VAR_0->ar_debug_ptr,sizeof(Dwarf_Sig8));
        VAR_10 = find_sig8_target_as_global_offset(VAR_0,
            &VAR_39,&VAR_40,&VAR_41,VAR_3);
        if (VAR_10 == VAR_23) {
            _dwarf_error_string(VAR_4, VAR_3,
                VAR_42,
                ""DW_DLE_REF_SIG8_NOT_HANDLED: ""
                "" problem finding target"");
            return VAR_23;
        }
        if (VAR_10 == VAR_43) {
            return VAR_10;
        }
        VAR_9 = VAR_40;
        VAR_5 = VAR_41;
        break;
    }
    default: {
        dwarfstring VAR_44;
        int VAR_45 = VAR_0->ar_attribute_form;
        int VAR_46 = 0;
        const char *VAR_47 = 0;

        dwarfstring_constructor(&VAR_44);
        dwarfstring_append_printf_u(&VAR_44,
            ""DW_DLE_BAD_REF_FORM: The form code is 0x%x "",
            VAR_45);
        VAR_46  = dwarf_get_FORM_name (VAR_45,&VAR_47);
        if (VAR_46 != VAR_11) {
            VAR_47=""<UnknownFormCode>"";
        }
        dwarfstring_append_printf_s(&VAR_44,
            "" %s."",(char *)VAR_47);
        _dwarf_error_string(VAR_4, VAR_3, VAR_48,
            dwarfstring_string(&VAR_44));
        dwarfstring_destructor(&VAR_44);
        return VAR_23;
        }
    }

    *VAR_2 = VAR_9;
    *VAR_1 = VAR_5;
    return VAR_11;
}",davea42/libdwarf-code/7ef09e1fc9ba07653dd078edb2408631c7969162/dwarf_form.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -163,6 +163,13 @@
         Dwarf_Bool t_is_info = TRUE;
         Dwarf_Unsigned t_offset = 0;
 
+        if ((attr->ar_debug_ptr + sizeof(Dwarf_Sig8)) > section_end) {
+            _dwarf_error_string(dbg, error,
+                DW_DLE_REF_SIG8_NOT_HANDLED,
+                ""DW_DLE_REF_SIG8_NOT_HANDLED: ""
+                "" Dwarf_Sig8 content runs off the end of its section"");
+            return DW_DLV_ERROR;
+        }
         memcpy(&sig8,attr->ar_debug_ptr,sizeof(Dwarf_Sig8));
         res = find_sig8_target_as_global_offset(attr,
             &sig8,&t_is_info,&t_offset,error);","{'deleted_lines': [], 'added_lines': ['        if ((attr->ar_debug_ptr + sizeof(Dwarf_Sig8)) > section_end) {', '            _dwarf_error_string(dbg, error,', '                DW_DLE_REF_SIG8_NOT_HANDLED,', '                ""DW_DLE_REF_SIG8_NOT_HANDLED: ""', '                "" Dwarf_Sig8 content runs off the end of its section"");', '            return DW_DLV_ERROR;', '        }']}",True,There is a heap-based buffer over-read in libdwarf 0.4.0. This issue is related to dwarf_global_formref_b.,8.1,HIGH,2,test,2022-06-15T21:46:01Z,4
CVE-2022-34299,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0,davea42/libdwarf-code,"Fixes old bug(which could result in Denial of Service)
due to a missing check before reading the 8 bytes of a DW_FORM_ref_sig8.
DW202206-001
	modified:   src/lib/libdwarf/dwarf_form.c",7ef09e1fc9ba07653dd078edb2408631c7969162,https://github.com/davea42/libdwarf-code/commit/7ef09e1fc9ba07653dd078edb2408631c7969162,src/lib/libdwarf/dwarf_form.c,find_sig8_target_as_global_offset,"static int
find_sig8_target_as_global_offset(Dwarf_Attribute attr,
Dwarf_Sig8  *sig8,
Dwarf_Bool  *is_info,
Dwarf_Off   *targoffset,
Dwarf_Error *error)
{
Dwarf_Die  targdie = 0;
Dwarf_Bool targ_is_info = 0;
Dwarf_Off  localoff = 0;
int res = 0;
targ_is_info = attr->ar_cu_context->cc_is_info;
memcpy(sig8,attr->ar_debug_ptr,sizeof(*sig8));
res = dwarf_find_die_given_sig8(attr->ar_dbg,
sig8,&targdie,&targ_is_info,error);
if (res != DW_DLV_OK) {
return res;
}
res = dwarf_die_offsets(targdie,targoffset,&localoff,error);
if (res != DW_DLV_OK) {
dwarf_dealloc_die(targdie);
return res;
}
*is_info = targdie->di_cu_context->cc_is_info;
dwarf_dealloc_die(targdie);
return DW_DLV_OK;
}","static int
find_sig8_target_as_global_offset(Dwarf_Attribute VAR_0,
Dwarf_Sig8  *VAR_1,
Dwarf_Bool  *VAR_2,
Dwarf_Off   *VAR_3,
Dwarf_Error *VAR_4)
{
Dwarf_Die  VAR_5 = 0;
Dwarf_Bool VAR_6 = 0;
Dwarf_Off  VAR_7 = 0;
int VAR_8 = 0;
VAR_6 = VAR_0->ar_cu_context->cc_is_info;
memcpy(VAR_1,VAR_0->ar_debug_ptr,sizeof(*VAR_1));
VAR_8 = dwarf_find_die_given_sig8(VAR_0->ar_dbg,
VAR_1,&VAR_5,&VAR_6,VAR_4);
if (VAR_8 != VAR_9) {
return VAR_8;
}
VAR_8 = dwarf_die_offsets(VAR_5,VAR_3,&VAR_7,VAR_4);
if (VAR_8 != VAR_9) {
dwarf_dealloc_die(VAR_5);
return VAR_8;
}
*VAR_2 = VAR_5->di_cu_context->cc_is_info;
dwarf_dealloc_die(VAR_5);
return VAR_9;
}",davea42/libdwarf-code/7ef09e1fc9ba07653dd078edb2408631c7969162/dwarf_form.c/vul/before/0.json,"static int
find_sig8_target_as_global_offset(Dwarf_Attribute attr,
    Dwarf_Sig8  *sig8,
    Dwarf_Bool  *is_info,
    Dwarf_Off   *targoffset,
    Dwarf_Error *error)
{
    Dwarf_Die  targdie = 0;
    Dwarf_Bool targ_is_info = 0;
    Dwarf_Off  localoff = 0;
    int res = 0;
    targ_is_info = attr->ar_cu_context->cc_is_info;
    memcpy(sig8,attr->ar_debug_ptr,sizeof(*sig8));
    res = dwarf_find_die_given_sig8(attr->ar_dbg,
        sig8,&targdie,&targ_is_info,error);
    if (res != DW_DLV_OK) {
        return res;
    }
    res = dwarf_die_offsets(targdie,targoffset,&localoff,error);
    if (res != DW_DLV_OK) {
        dwarf_dealloc_die(targdie);
        return res;
    }
    *is_info = targdie->di_cu_context->cc_is_info;
    dwarf_dealloc_die(targdie);
    return DW_DLV_OK;
}","static int
find_sig8_target_as_global_offset(Dwarf_Attribute VAR_0,
    Dwarf_Sig8  *VAR_1,
    Dwarf_Bool  *VAR_2,
    Dwarf_Off   *VAR_3,
    Dwarf_Error *VAR_4)
{
    Dwarf_Die  VAR_5 = 0;
    Dwarf_Bool VAR_6 = 0;
    Dwarf_Off  VAR_7 = 0;
    int VAR_8 = 0;
    VAR_6 = VAR_0->ar_cu_context->cc_is_info;
    memcpy(VAR_1,VAR_0->ar_debug_ptr,sizeof(*VAR_1));
    VAR_8 = dwarf_find_die_given_sig8(VAR_0->ar_dbg,
        VAR_1,&VAR_5,&VAR_6,VAR_4);
    if (VAR_8 != VAR_9) {
        return VAR_8;
    }
    VAR_8 = dwarf_die_offsets(VAR_5,VAR_3,&VAR_7,VAR_4);
    if (VAR_8 != VAR_9) {
        dwarf_dealloc_die(VAR_5);
        return VAR_8;
    }
    *VAR_2 = VAR_5->di_cu_context->cc_is_info;
    dwarf_dealloc_die(VAR_5);
    return VAR_9;
}",davea42/libdwarf-code/7ef09e1fc9ba07653dd078edb2408631c7969162/dwarf_form.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,7 +9,6 @@
     Dwarf_Bool targ_is_info = 0;
     Dwarf_Off  localoff = 0;
     int res = 0;
-
     targ_is_info = attr->ar_cu_context->cc_is_info;
     memcpy(sig8,attr->ar_debug_ptr,sizeof(*sig8));
     res = dwarf_find_die_given_sig8(attr->ar_dbg,","{'deleted_lines': [''], 'added_lines': []}",True,There is a heap-based buffer over-read in libdwarf 0.4.0. This issue is related to dwarf_global_formref_b.,8.1,HIGH,2,test,2022-06-15T21:46:01Z,4
CVE-2022-2175,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,vim,"patch 8.2.5148: invalid memory access when using expression on command line

Problem:    Invalid memory access when using an expression on the command line.
Solution:   Make sure the position does not go negative.",6046aded8da002b08d380db29de2ba0268b6616e,https://github.com/vim/vim/commit/6046aded8da002b08d380db29de2ba0268b6616e,src/ex_getln.c,cmdline_insert_reg,"static int
cmdline_insert_reg(int *gotesc UNUSED)
{
inti;
intc;
#ifdef USE_ON_FLY_SCROLL
dont_scroll = TRUE;#endif
putcmdline('""', TRUE);
++no_mapping;
++allow_keys;
i = c = plain_vgetc();    if (i == Ctrl_O)
i = Ctrl_R;    if (i == Ctrl_R)
c = plain_vgetc();    extra_char = NUL;
--no_mapping;
--allow_keys;
#ifdef FEAT_EVAL
new_cmdpos = -1;
if (c == '=')
{
if (ccline.cmdfirstc == '='  || cmdline_star > 0) {
beep_flush();
c = ESC;
}
else
c = get_expr_register();
}
#endif
if (c != ESC)        {
cmdline_paste(c, i == Ctrl_R, FALSE);
#ifdef FEAT_EVAL
if (aborting())
{
*gotesc = TRUE;          return GOTO_NORMAL_MODE;
}
#endif
KeyTyped = FALSE;#ifdef FEAT_EVAL
if (new_cmdpos >= 0)
{
if (new_cmdpos > ccline.cmdlen)
ccline.cmdpos = ccline.cmdlen;
else
ccline.cmdpos = new_cmdpos;
}
#endif
}
redrawcmd();
return CMDLINE_NOT_CHANGED;
}","static int
cmdline_insert_reg(int *VAR_0 UNUSED)
{
intVAR_1;
intVAR_2;
#ifdef VAR_3
VAR_4 = TRUE;
#endif
putcmdline('""', TRUE);
++VAR_5;
++VAR_6;
VAR_1 = VAR_2 = plain_vgetc();
if (VAR_1 == VAR_7)
VAR_1 = VAR_8;
if (VAR_1 == VAR_8)
VAR_2 = plain_vgetc();
VAR_9 = VAR_10;
--VAR_5;
--VAR_6;
#ifdef VAR_11
VAR_12 = -1;
if (VAR_2 == '=')
{
if (VAR_13.cmdfirstc == '='  
|| VAR_14 > 0) 
{
beep_flush();
VAR_2 = VAR_15;
}
else
VAR_2 = get_expr_register();
}
#endif
if (VAR_2 != VAR_15)    
{
cmdline_paste(VAR_2, VAR_1 == VAR_8, FALSE);
#ifdef VAR_11
if (aborting())
{
*VAR_0 = TRUE;  
return VAR_16;
}
#endif
VAR_17 = FALSE;
#ifdef VAR_11
if (VAR_12 >= 0)
{
if (VAR_12 > VAR_13.cmdlen)
VAR_13.cmdpos = VAR_13.cmdlen;
else
VAR_13.cmdpos = VAR_12;
}
#endif
}
redrawcmd();
return VAR_18;
}",,"static int
cmdline_insert_reg(int *gotesc UNUSED)
{
    int		i;
    int		c;
    int		save_new_cmdpos = new_cmdpos;

#ifdef USE_ON_FLY_SCROLL
    dont_scroll = TRUE;	// disallow scrolling here
#endif
    putcmdline('""', TRUE);
    ++no_mapping;
    ++allow_keys;
    i = c = plain_vgetc();	// CTRL-R <char>
    if (i == Ctrl_O)
	i = Ctrl_R;		// CTRL-R CTRL-O == CTRL-R CTRL-R
    if (i == Ctrl_R)
	c = plain_vgetc();	// CTRL-R CTRL-R <char>
    extra_char = NUL;
    --no_mapping;
    --allow_keys;
#ifdef FEAT_EVAL
    /*
     * Insert the result of an expression.
     */
    new_cmdpos = -1;
    if (c == '=')
    {
	if (ccline.cmdfirstc == '='  // can't do this recursively
		|| cmdline_star > 0) // or when typing a password
	{
	    beep_flush();
	    c = ESC;
	}
	else
	    c = get_expr_register();
    }
#endif
    if (c != ESC)	    // use ESC to cancel inserting register
    {
	cmdline_paste(c, i == Ctrl_R, FALSE);

#ifdef FEAT_EVAL
	// When there was a serious error abort getting the
	// command line.
	if (aborting())
	{
	    *gotesc = TRUE;  // will free ccline.cmdbuff after
	    // putting it in history
	    return GOTO_NORMAL_MODE;
	}
#endif
	KeyTyped = FALSE;	// Don't do p_wc completion.
#ifdef FEAT_EVAL
	if (new_cmdpos >= 0)
	{
	    // set_cmdline_pos() was used
	    if (new_cmdpos > ccline.cmdlen)
		ccline.cmdpos = ccline.cmdlen;
	    else
		ccline.cmdpos = new_cmdpos;
	}
#endif
    }
    new_cmdpos = save_new_cmdpos;

    // remove the double quote
    redrawcmd();

    // The text has been stuffed, the command line didn't change yet.
    return CMDLINE_NOT_CHANGED;
}","static int
cmdline_insert_reg(int *VAR_0 UNUSED)
{
    int		VAR_1;
    int		VAR_2;
    int		VAR_3 = VAR_4;

#ifdef VAR_5
    VAR_6 = TRUE;	/* COMMENT_0 */
#endif
    putcmdline('""', TRUE);
    ++VAR_7;
    ++VAR_8;
    VAR_1 = VAR_2 = plain_vgetc();	/* COMMENT_1 */
    if (VAR_1 == VAR_9)
	VAR_1 = VAR_10;		/* COMMENT_2 */
    if (VAR_1 == VAR_10)
	VAR_2 = plain_vgetc();	/* COMMENT_3 */
    VAR_11 = VAR_12;
    --VAR_7;
    --VAR_8;
#ifdef VAR_13
    /* COMMENT_4 */
                                          
       
    VAR_4 = -1;
    if (VAR_2 == '=')
    {
	if (VAR_14.cmdfirstc == '='  /* COMMENT_7 */
		|| VAR_15 > 0) /* COMMENT_8 */
	{
	    beep_flush();
	    VAR_2 = VAR_16;
	}
	else
	    VAR_2 = get_expr_register();
    }
#endif
    if (VAR_2 != VAR_16)	    /* COMMENT_9 */
    {
	cmdline_paste(VAR_2, VAR_1 == VAR_10, FALSE);

#ifdef VAR_13
	/* COMMENT_10 */
	/* COMMENT_11 */
	if (aborting())
	{
	    *VAR_0 = TRUE;  /* COMMENT_12 */
	    /* COMMENT_13 */
	    return VAR_17;
	}
#endif
	VAR_18 = FALSE;	/* COMMENT_14 */
#ifdef VAR_13
	if (VAR_4 >= 0)
	{
	    /* COMMENT_15 */
	    if (VAR_4 > VAR_14.cmdlen)
		VAR_14.cmdpos = VAR_14.cmdlen;
	    else
		VAR_14.cmdpos = VAR_4;
	}
#endif
    }
    VAR_4 = VAR_3;

    /* COMMENT_16 */
    redrawcmd();

    /* COMMENT_17 */
    return VAR_19;
}",,"--- func_before
+++ func_after
@@ -3,6 +3,7 @@
 {
     int		i;
     int		c;
+    int		save_new_cmdpos = new_cmdpos;
 
 #ifdef USE_ON_FLY_SCROLL
     dont_scroll = TRUE;	// disallow scrolling here
@@ -21,8 +22,6 @@
 #ifdef FEAT_EVAL
     /*
      * Insert the result of an expression.
-     * Need to save the current command line, to be able to enter
-     * a new one...
      */
     new_cmdpos = -1;
     if (c == '=')
@@ -63,6 +62,8 @@
 	}
 #endif
     }
+    new_cmdpos = save_new_cmdpos;
+
     // remove the double quote
     redrawcmd();
 ","{'deleted_lines': ['     * Need to save the current command line, to be able to enter', '     * a new one...'], 'added_lines': ['    int\t\tsave_new_cmdpos = new_cmdpos;', '    new_cmdpos = save_new_cmdpos;', '']}",True,Buffer Over-read in GitHub repository vim/vim prior to 8.2.,7.8,HIGH,2,test,2022-06-22T12:51:54Z,4
CVE-2022-2207,['CWE-122'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,vim,"patch 8.2.5162: reading before the start of the line with BS in Replace mode

Problem:    Reading before the start of the line with BS in Replace mode.
Solution:   Check the cursor column is more than zero.",0971c7a4e537ea120a6bb2195960be8d0815e97b,https://github.com/vim/vim/commit/0971c7a4e537ea120a6bb2195960be8d0815e97b,src/edit.c,ins_bs,"static int
ins_bs(
intc,
intmode,
int*inserted_space_p)
{
linenr_Tlnum;
intcc;
inttemp = 0;        colnr_Tsave_col;
colnr_Tmincol;
intdid_backspace = FALSE;
intin_indent;
intoldState;
intcpc[MAX_MCO];        intcall_fix_indent = FALSE;
if (       BUFEMPTY()
|| (
#ifdef FEAT_RIGHTLEFT
!revins_on &&
#endif
((curwin->w_cursor.lnum == 1 && curwin->w_cursor.col == 0)
|| (!can_bs(BS_START)
&& ((arrow_used
#ifdef FEAT_JOB_CHANNEL
&& !bt_prompt(curbuf)
#endif
) || (curwin->w_cursor.lnum == Insstart_orig.lnum
&& curwin->w_cursor.col <= Insstart_orig.col)))
|| (!can_bs(BS_INDENT) && !arrow_used && ai_col > 0
&& curwin->w_cursor.col <= ai_col)
|| (!can_bs(BS_EOL) && curwin->w_cursor.col == 0))))
{
vim_beep(BO_BS);
return FALSE;
}
if (stop_arrow() == FAIL)
return FALSE;
in_indent = inindent(0);
if (in_indent)
can_cindent = FALSE;
end_comment_pending = NUL;#ifdef FEAT_RIGHTLEFT
if (revins_on)    inc_cursor();
#endif
if (curwin->w_cursor.coladd > 0)
{
if (mode == BACKSPACE_CHAR)
{
--curwin->w_cursor.coladd;
return TRUE;
}
if (mode == BACKSPACE_WORD)
{
curwin->w_cursor.coladd = 0;
return TRUE;
}
curwin->w_cursor.coladd = 0;
}
if (curwin->w_cursor.col == 0)
{
lnum = Insstart.lnum;
if (curwin->w_cursor.lnum == lnum
#ifdef FEAT_RIGHTLEFT
|| revins_on
#endif
)
{
if (u_save((linenr_T)(curwin->w_cursor.lnum - 2),
(linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL)
return FALSE;
--Insstart.lnum;
Insstart.col = (colnr_T)STRLEN(ml_get(Insstart.lnum));
}
cc = -1;
if (State & REPLACE_FLAG)
cc = replace_pop();    
if ((State & REPLACE_FLAG) && curwin->w_cursor.lnum <= lnum)
{
dec_cursor();
}
else
{
if (!(State & VREPLACE_FLAG)
|| curwin->w_cursor.lnum > orig_line_count)
{
temp = gchar_cursor();--curwin->w_cursor.lnum;
if (has_format_option(FO_AUTO)
&& has_format_option(FO_WHITE_PAR))
{
char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum,
TRUE);
int    len;
len = (int)STRLEN(ptr);
if (len > 0 && ptr[len - 1] == ' ')
ptr[len - 1] = NUL;
}
(void)do_join(2, FALSE, FALSE, FALSE, FALSE);
if (temp == NUL && gchar_cursor() != NUL)
inc_cursor();
}
else
dec_cursor();
if (State & REPLACE_FLAG)
{
oldState = State;
State = MODE_NORMAL;
while (cc > 0)
{
save_col = curwin->w_cursor.col;
mb_replace_pop_ins(cc);
curwin->w_cursor.col = save_col;
cc = replace_pop();
}
replace_pop_ins();
State = oldState;
}
}
did_ai = FALSE;
}
else
{
#ifdef FEAT_RIGHTLEFT
if (revins_on)    dec_cursor();
#endif
mincol = 0;
if (mode == BACKSPACE_LINE
&& (curbuf->b_p_ai || cindent_on())
#ifdef FEAT_RIGHTLEFT
&& !revins_on
#endif
)
{
save_col = curwin->w_cursor.col;
beginline(BL_WHITE);
if (curwin->w_cursor.col < save_col)
{
mincol = curwin->w_cursor.col;
call_fix_indent = TRUE;
}
curwin->w_cursor.col = save_col;
}
if (   mode == BACKSPACE_CHAR
&& ((p_sta && in_indent)
|| ((get_sts_value() != 0
#ifdef FEAT_VARTABS
|| tabstop_count(curbuf->b_p_vsts_array)
#endif
)
&& curwin->w_cursor.col > 0
&& (*(ml_get_cursor() - 1) == TAB
|| (*(ml_get_cursor() - 1) == ' '
&& (!*inserted_space_p
|| arrow_used))))))
{
intts;
colnr_Tvcol;
colnr_Twant_vcol;
colnr_Tstart_vcol;
*inserted_space_p = FALSE;
getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);
start_vcol = vcol;
dec_cursor();
getvcol(curwin, &curwin->w_cursor, NULL, NULL, &want_vcol);
inc_cursor();
#ifdef FEAT_VARTABS
if (p_sta && in_indent)
{
ts = (int)get_sw_value(curbuf);
want_vcol = (want_vcol / ts) * ts;
}
else
want_vcol = tabstop_start(want_vcol, get_sts_value(),
curbuf->b_p_vsts_array);
#else
if (p_sta && in_indent)
ts = (int)get_sw_value(curbuf);
else
ts = (int)get_sts_value();
want_vcol = (want_vcol / ts) * ts;
#endif
while (vcol > want_vcol
&& (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))
ins_bs_one(&vcol);
while (vcol < want_vcol)
{
if (curwin->w_cursor.lnum == Insstart_orig.lnum
&& curwin->w_cursor.col < Insstart_orig.col)
Insstart_orig.col = curwin->w_cursor.col;
if (State & VREPLACE_FLAG)
ins_char(' ');
else
{
ins_str((char_u *)"" "");
if ((State & REPLACE_FLAG))
replace_push(NUL);
}
getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);
}
if (vcol >= start_vcol)
ins_bs_one(&vcol);
}
else
{
int cclass = 0, prev_cclass = 0;
if (has_mbyte)
cclass = mb_get_class(ml_get_cursor());
do
{
#ifdef FEAT_RIGHTLEFT
if (!revins_on) #endif
dec_cursor();
cc = gchar_cursor();
if (has_mbyte)
{
prev_cclass = cclass;
cclass = mb_get_class(ml_get_cursor());
}
if (mode == BACKSPACE_WORD && !vim_isspace(cc))
{
mode = BACKSPACE_WORD_NOT_SPACE;
temp = vim_iswordc(cc);
}
else if (mode == BACKSPACE_WORD_NOT_SPACE
&& ((vim_isspace(cc) || vim_iswordc(cc) != temp)
|| prev_cclass != cclass))
{
#ifdef FEAT_RIGHTLEFT
if (!revins_on)
#endif
inc_cursor();
#ifdef FEAT_RIGHTLEFT
else if (State & REPLACE_FLAG)
dec_cursor();
#endif
break;
}
if (State & REPLACE_FLAG)
replace_do_bs(-1);
else
{
if (enc_utf8 && p_deco)
(void)utfc_ptr2char(ml_get_cursor(), cpc);
(void)del_char(FALSE);
if (enc_utf8 && p_deco && cpc[0] != NUL)
inc_cursor();
#ifdef FEAT_RIGHTLEFT
if (revins_chars)
{
revins_chars--;
revins_legal++;
}
if (revins_on && gchar_cursor() == NUL)
break;
#endif
}
if (mode == BACKSPACE_CHAR)
break;
} while (
#ifdef FEAT_RIGHTLEFT
revins_on ||
#endif
(curwin->w_cursor.col > mincol
&&  (can_bs(BS_NOSTOP)
|| (curwin->w_cursor.lnum != Insstart_orig.lnum
|| curwin->w_cursor.col != Insstart_orig.col)
)));
}
did_backspace = TRUE;
}
did_si = FALSE;
can_si = FALSE;
can_si_back = FALSE;
if (curwin->w_cursor.col <= 1)
did_ai = FALSE;
if (call_fix_indent)
fix_indent();
AppendCharToRedobuff(c);
if (curwin->w_cursor.lnum == Insstart_orig.lnum
&& curwin->w_cursor.col < Insstart_orig.col)
Insstart_orig.col = curwin->w_cursor.col;
if (vim_strchr(p_cpo, CPO_BACKSPACE) != NULL && dollar_vcol == -1)
dollar_vcol = curwin->w_virtcol;
#ifdef FEAT_FOLDING
if (did_backspace)
foldOpenCursor();
#endif
return did_backspace;
}","static int
ins_bs(
intVAR_0,
intVAR_1,
int*VAR_2)
{
linenr_TVAR_3;
intVAR_4;
intVAR_5 = 0;    
colnr_TVAR_6;
colnr_TVAR_7;
intVAR_8 = FALSE;
intVAR_9;
intVAR_10;
intVAR_11[VAR_12];    
intVAR_13 = FALSE;
if (       BUFEMPTY()
|| (
#ifdef VAR_14
!VAR_15 &&
#endif
((VAR_16->w_cursor.lnum == 1 && VAR_16->w_cursor.col == 0)
|| (!can_bs(VAR_17)
&& ((VAR_18
#ifdef VAR_19
&& !bt_prompt(VAR_20)
#endif
) || (VAR_16->w_cursor.lnum == VAR_21.lnum
&& VAR_16->w_cursor.col <= VAR_21.col)))
|| (!can_bs(VAR_22) && !VAR_18 && VAR_23 > 0
&& VAR_16->w_cursor.col <= VAR_23)
|| (!can_bs(VAR_24) && VAR_16->w_cursor.col == 0))))
{
vim_beep(VAR_25);
return FALSE;
}
if (stop_arrow() == VAR_26)
return FALSE;
VAR_9 = inindent(0);
if (VAR_9)
VAR_27 = FALSE;
VAR_28 = VAR_29;
#ifdef VAR_14
if (VAR_15)    
inc_cursor();
#endif
if (VAR_16->w_cursor.coladd > 0)
{
if (VAR_1 == VAR_30)
{
--VAR_16->w_cursor.coladd;
return TRUE;
}
if (VAR_1 == VAR_31)
{
VAR_16->w_cursor.coladd = 0;
return TRUE;
}
VAR_16->w_cursor.coladd = 0;
}
if (VAR_16->w_cursor.col == 0)
{
VAR_3 = VAR_32.lnum;
if (VAR_16->w_cursor.lnum == VAR_3
#ifdef VAR_14
|| VAR_15
#endif
)
{
if (u_save((linenr_T)(VAR_16->w_cursor.lnum - 2),
(linenr_T)(VAR_16->w_cursor.lnum + 1)) == VAR_26)
return FALSE;
--VAR_32.lnum;
VAR_32.col = (colnr_T)STRLEN(ml_get(VAR_32.lnum));
}
VAR_4 = -1;
if (VAR_33 & VAR_34)
VAR_4 = replace_pop();    
if ((VAR_33 & VAR_34) && VAR_16->w_cursor.lnum <= VAR_3)
{
dec_cursor();
}
else
{
if (!(VAR_33 & VAR_35)
|| VAR_16->w_cursor.lnum > VAR_36)
{
VAR_5 = gchar_cursor();
--VAR_16->w_cursor.lnum;
if (has_format_option(VAR_37)
&& has_format_option(VAR_38))
{
char_u  *VAR_39 = ml_get_buf(VAR_20, VAR_16->w_cursor.lnum,
TRUE);
int    VAR_40;
VAR_40 = (int)STRLEN(VAR_39);
if (VAR_40 > 0 && VAR_39[VAR_40 - 1] == ' ')
VAR_39[VAR_40 - 1] = VAR_29;
}
(void)do_join(2, FALSE, FALSE, FALSE, FALSE);
if (VAR_5 == VAR_29 && gchar_cursor() != VAR_29)
inc_cursor();
}
else
dec_cursor();
if (VAR_33 & VAR_34)
{
VAR_10 = VAR_33;
VAR_33 = VAR_41;
while (VAR_4 > 0)
{
VAR_6 = VAR_16->w_cursor.col;
mb_replace_pop_ins(VAR_4);
VAR_16->w_cursor.col = VAR_6;
VAR_4 = replace_pop();
}
replace_pop_ins();
VAR_33 = VAR_10;
}
}
VAR_42 = FALSE;
}
else
{
#ifdef VAR_14
if (VAR_15)
dec_cursor();
#endif
VAR_7 = 0;
if (VAR_1 == VAR_43
&& (VAR_20->b_p_ai || cindent_on())
#ifdef VAR_14
&& !VAR_15
#endif
)
{
VAR_6 = VAR_16->w_cursor.col;
beginline(VAR_44);
if (VAR_16->w_cursor.col < VAR_6)
{
VAR_7 = VAR_16->w_cursor.col;
VAR_13 = TRUE;
}
VAR_16->w_cursor.col = VAR_6;
}
if (   VAR_1 == VAR_30
&& ((VAR_45 && VAR_9)
|| ((get_sts_value() != 0
#ifdef VAR_46
|| tabstop_count(VAR_20->b_p_vsts_array)
#endif
)
&& VAR_16->w_cursor.col > 0
&& (*(ml_get_cursor() - 1) == VAR_47
|| (*(ml_get_cursor() - 1) == ' '
&& (!*VAR_2
|| VAR_18))))))
{
intVAR_48;
colnr_TVAR_49;
colnr_TVAR_50;
colnr_TVAR_51;
*VAR_2 = FALSE;
getvcol(VAR_16, &VAR_16->w_cursor, &VAR_49, NULL, NULL);
VAR_51 = VAR_49;
dec_cursor();
getvcol(VAR_16, &VAR_16->w_cursor, NULL, NULL, &VAR_50);
inc_cursor();
#ifdef VAR_46
if (VAR_45 && VAR_9)
{
VAR_48 = (int)get_sw_value(VAR_20);
VAR_50 = (VAR_50 / VAR_48) * VAR_48;
}
else
VAR_50 = tabstop_start(VAR_50, get_sts_value(),
VAR_20->b_p_vsts_array);
#else
if (VAR_45 && VAR_9)
VAR_48 = (int)get_sw_value(VAR_20);
else
VAR_48 = (int)get_sts_value();
VAR_50 = (VAR_50 / VAR_48) * VAR_48;
#endif
while (VAR_49 > VAR_50
&& (VAR_4 = *(ml_get_cursor() - 1), VIM_ISWHITE(VAR_4)))
ins_bs_one(&VAR_49);
while (VAR_49 < VAR_50)
{
if (VAR_16->w_cursor.lnum == VAR_21.lnum
&& VAR_16->w_cursor.col < VAR_21.col)
VAR_21.col = VAR_16->w_cursor.col;
if (VAR_33 & VAR_35)
ins_char(' ');
else
{
ins_str((char_u *)"" "");
if ((VAR_33 & VAR_34))
replace_push(VAR_29);
}
getvcol(VAR_16, &VAR_16->w_cursor, &VAR_49, NULL, NULL);
}
if (VAR_49 >= VAR_51)
ins_bs_one(&VAR_49);
}
else
{
int VAR_52 = 0, VAR_53 = 0;
if (VAR_54)
VAR_52 = mb_get_class(ml_get_cursor());
do
{
#ifdef VAR_14
if (!VAR_15) 
#endif
dec_cursor();
VAR_4 = gchar_cursor();
if (VAR_54)
{
VAR_53 = VAR_52;
VAR_52 = mb_get_class(ml_get_cursor());
}
if (VAR_1 == VAR_31 && !vim_isspace(VAR_4))
{
VAR_1 = VAR_55;
VAR_5 = vim_iswordc(VAR_4);
}
else if (VAR_1 == VAR_55
&& ((vim_isspace(VAR_4) || vim_iswordc(VAR_4) != VAR_5)
|| VAR_53 != VAR_52))
{
#ifdef VAR_14
if (!VAR_15)
#endif
inc_cursor();
#ifdef VAR_14
else if (State & VAR_34)
dec_cursor();
#endif
break;
}
if (State & VAR_34)
replace_do_bs(-1);
else
{
if (VAR_56 && VAR_57)
(void)utfc_ptr2char(ml_get_cursor(), VAR_11);
(void)del_char(FALSE);
if (VAR_56 && VAR_57 && VAR_11[0] != VAR_29)
inc_cursor();
#ifdef VAR_14
if (VAR_58)
{
VAR_58--;
VAR_59++;
}
if (VAR_15 && gchar_cursor() == VAR_29)
break;
#endif
}
if (VAR_1 == VAR_30)
break;
} while (
#ifdef VAR_14
VAR_15 ||
#endif
(VAR_16->w_cursor.col > VAR_7
&&  (can_bs(VAR_60)
|| (VAR_16->w_cursor.lnum != VAR_21.lnum
|| VAR_16->w_cursor.col != VAR_21.col)
)));
}
VAR_8 = TRUE;
}
VAR_61 = FALSE;
VAR_62 = FALSE;
VAR_63 = FALSE;
if (VAR_16->w_cursor.col <= 1)
VAR_42 = FALSE;
if (VAR_13)
fix_indent();
AppendCharToRedobuff(VAR_0);
if (VAR_16->w_cursor.lnum == VAR_21.lnum
&& VAR_16->w_cursor.col < VAR_21.col)
VAR_21.col = VAR_16->w_cursor.col;
if (vim_strchr(VAR_64, VAR_65) != NULL && VAR_66 == -1)
VAR_66 = VAR_16->w_virtcol;
#ifdef VAR_67
if (VAR_8)
foldOpenCursor();
#endif
return VAR_8;
}",vim/0971c7a4e537ea120a6bb2195960be8d0815e97b/edit.c/vul/before/0.json,"static int
ins_bs(
    int		c,
    int		mode,
    int		*inserted_space_p)
{
    linenr_T	lnum;
    int		cc;
    int		temp = 0;	    // init for GCC
    colnr_T	save_col;
    colnr_T	mincol;
    int		did_backspace = FALSE;
    int		in_indent;
    int		oldState;
    int		cpc[MAX_MCO];	    // composing characters
    int		call_fix_indent = FALSE;

    /*
     * can't delete anything in an empty file
     * can't backup past first character in buffer
     * can't backup past starting point unless 'backspace' > 1
     * can backup to a previous line if 'backspace' == 0
     */
    if (       BUFEMPTY()
	    || (
#ifdef FEAT_RIGHTLEFT
		!revins_on &&
#endif
		((curwin->w_cursor.lnum == 1 && curwin->w_cursor.col == 0)
		    || (!can_bs(BS_START)
			&& ((arrow_used
#ifdef FEAT_JOB_CHANNEL
				&& !bt_prompt(curbuf)
#endif
			) || (curwin->w_cursor.lnum == Insstart_orig.lnum
				&& curwin->w_cursor.col <= Insstart_orig.col)))
		    || (!can_bs(BS_INDENT) && !arrow_used && ai_col > 0
					 && curwin->w_cursor.col <= ai_col)
		    || (!can_bs(BS_EOL) && curwin->w_cursor.col == 0))))
    {
	vim_beep(BO_BS);
	return FALSE;
    }

    if (stop_arrow() == FAIL)
	return FALSE;
    in_indent = inindent(0);
    if (in_indent)
	can_cindent = FALSE;
    end_comment_pending = NUL;	// After BS, don't auto-end comment
#ifdef FEAT_RIGHTLEFT
    if (revins_on)	    // put cursor after last inserted char
	inc_cursor();
#endif

    // Virtualedit:
    //	BACKSPACE_CHAR eats a virtual space
    //	BACKSPACE_WORD eats all coladd
    //	BACKSPACE_LINE eats all coladd and keeps going
    if (curwin->w_cursor.coladd > 0)
    {
	if (mode == BACKSPACE_CHAR)
	{
	    --curwin->w_cursor.coladd;
	    return TRUE;
	}
	if (mode == BACKSPACE_WORD)
	{
	    curwin->w_cursor.coladd = 0;
	    return TRUE;
	}
	curwin->w_cursor.coladd = 0;
    }

    /*
     * Delete newline!
     */
    if (curwin->w_cursor.col == 0)
    {
	lnum = Insstart.lnum;
	if (curwin->w_cursor.lnum == lnum
#ifdef FEAT_RIGHTLEFT
			|| revins_on
#endif
				    )
	{
	    if (u_save((linenr_T)(curwin->w_cursor.lnum - 2),
			       (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL)
		return FALSE;
	    --Insstart.lnum;
	    Insstart.col = (colnr_T)STRLEN(ml_get(Insstart.lnum));
	}
	/*
	 * In replace mode:
	 * cc < 0: NL was inserted, delete it
	 * cc >= 0: NL was replaced, put original characters back
	 */
	cc = -1;
	if (State & REPLACE_FLAG)
	    cc = replace_pop();	    // returns -1 if NL was inserted
	/*
	 * In replace mode, in the line we started replacing, we only move the
	 * cursor.
	 */
	if ((State & REPLACE_FLAG) && curwin->w_cursor.lnum <= lnum)
	{
	    dec_cursor();
	}
	else
	{
	    if (!(State & VREPLACE_FLAG)
				   || curwin->w_cursor.lnum > orig_line_count)
	    {
		temp = gchar_cursor();	// remember current char
		--curwin->w_cursor.lnum;

		// When ""aw"" is in 'formatoptions' we must delete the space at
		// the end of the line, otherwise the line will be broken
		// again when auto-formatting.
		if (has_format_option(FO_AUTO)
					   && has_format_option(FO_WHITE_PAR))
		{
		    char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum,
									TRUE);
		    int	    len;

		    len = (int)STRLEN(ptr);
		    if (len > 0 && ptr[len - 1] == ' ')
			ptr[len - 1] = NUL;
		}

		(void)do_join(2, FALSE, FALSE, FALSE, FALSE);
		if (temp == NUL && gchar_cursor() != NUL)
		    inc_cursor();
	    }
	    else
		dec_cursor();

	    /*
	     * In MODE_REPLACE mode we have to put back the text that was
	     * replaced by the NL. On the replace stack is first a
	     * NUL-terminated sequence of characters that were deleted and then
	     * the characters that NL replaced.
	     */
	    if (State & REPLACE_FLAG)
	    {
		/*
		 * Do the next ins_char() in MODE_NORMAL state, to
		 * prevent ins_char() from replacing characters and
		 * avoiding showmatch().
		 */
		oldState = State;
		State = MODE_NORMAL;
		/*
		 * restore characters (blanks) deleted after cursor
		 */
		while (cc > 0)
		{
		    save_col = curwin->w_cursor.col;
		    mb_replace_pop_ins(cc);
		    curwin->w_cursor.col = save_col;
		    cc = replace_pop();
		}
		// restore the characters that NL replaced
		replace_pop_ins();
		State = oldState;
	    }
	}
	did_ai = FALSE;
    }
    else
    {
	/*
	 * Delete character(s) before the cursor.
	 */
#ifdef FEAT_RIGHTLEFT
	if (revins_on)		// put cursor on last inserted char
	    dec_cursor();
#endif
	mincol = 0;
						// keep indent
	if (mode == BACKSPACE_LINE
		&& (curbuf->b_p_ai || cindent_on())
#ifdef FEAT_RIGHTLEFT
		&& !revins_on
#endif
			    )
	{
	    save_col = curwin->w_cursor.col;
	    beginline(BL_WHITE);
	    if (curwin->w_cursor.col < save_col)
	    {
		mincol = curwin->w_cursor.col;
		// should now fix the indent to match with the previous line
		call_fix_indent = TRUE;
	    }
	    curwin->w_cursor.col = save_col;
	}

	/*
	 * Handle deleting one 'shiftwidth' or 'softtabstop'.
	 */
	if (	   mode == BACKSPACE_CHAR
		&& ((p_sta && in_indent)
		    || ((get_sts_value() != 0
#ifdef FEAT_VARTABS
			|| tabstop_count(curbuf->b_p_vsts_array)
#endif
			)
			&& curwin->w_cursor.col > 0
			&& (*(ml_get_cursor() - 1) == TAB
			    || (*(ml_get_cursor() - 1) == ' '
				&& (!*inserted_space_p
				    || arrow_used))))))
	{
	    int		ts;
	    colnr_T	vcol;
	    colnr_T	want_vcol;
	    colnr_T	start_vcol;

	    *inserted_space_p = FALSE;
	    // Compute the virtual column where we want to be.  Since
	    // 'showbreak' may get in the way, need to get the last column of
	    // the previous character.
	    getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);
	    start_vcol = vcol;
	    dec_cursor();
	    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &want_vcol);
	    inc_cursor();
#ifdef FEAT_VARTABS
	    if (p_sta && in_indent)
	    {
		ts = (int)get_sw_value(curbuf);
		want_vcol = (want_vcol / ts) * ts;
	    }
	    else
		want_vcol = tabstop_start(want_vcol, get_sts_value(),
						       curbuf->b_p_vsts_array);
#else
	    if (p_sta && in_indent)
		ts = (int)get_sw_value(curbuf);
	    else
		ts = (int)get_sts_value();
	    want_vcol = (want_vcol / ts) * ts;
#endif

	    // delete characters until we are at or before want_vcol
	    while (vcol > want_vcol && curwin->w_cursor.col > 0
		    && (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))
		ins_bs_one(&vcol);

	    // insert extra spaces until we are at want_vcol
	    while (vcol < want_vcol)
	    {
		// Remember the first char we inserted
		if (curwin->w_cursor.lnum == Insstart_orig.lnum
				   && curwin->w_cursor.col < Insstart_orig.col)
		    Insstart_orig.col = curwin->w_cursor.col;

		if (State & VREPLACE_FLAG)
		    ins_char(' ');
		else
		{
		    ins_str((char_u *)"" "");
		    if ((State & REPLACE_FLAG))
			replace_push(NUL);
		}
		getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);
	    }

	    // If we are now back where we started delete one character.  Can
	    // happen when using 'sts' and 'linebreak'.
	    if (vcol >= start_vcol)
		ins_bs_one(&vcol);
	}

	/*
	 * Delete up to starting point, start of line or previous word.
	 */
	else
	{
	    int cclass = 0, prev_cclass = 0;

	    if (has_mbyte)
		cclass = mb_get_class(ml_get_cursor());
	    do
	    {
#ifdef FEAT_RIGHTLEFT
		if (!revins_on) // put cursor on char to be deleted
#endif
		    dec_cursor();

		cc = gchar_cursor();
		// look multi-byte character class
		if (has_mbyte)
		{
		    prev_cclass = cclass;
		    cclass = mb_get_class(ml_get_cursor());
		}

		// start of word?
		if (mode == BACKSPACE_WORD && !vim_isspace(cc))
		{
		    mode = BACKSPACE_WORD_NOT_SPACE;
		    temp = vim_iswordc(cc);
		}
		// end of word?
		else if (mode == BACKSPACE_WORD_NOT_SPACE
			&& ((vim_isspace(cc) || vim_iswordc(cc) != temp)
			|| prev_cclass != cclass))
		{
#ifdef FEAT_RIGHTLEFT
		    if (!revins_on)
#endif
			inc_cursor();
#ifdef FEAT_RIGHTLEFT
		    else if (State & REPLACE_FLAG)
			dec_cursor();
#endif
		    break;
		}
		if (State & REPLACE_FLAG)
		    replace_do_bs(-1);
		else
		{
		    if (enc_utf8 && p_deco)
			(void)utfc_ptr2char(ml_get_cursor(), cpc);
		    (void)del_char(FALSE);
		    /*
		     * If there are combining characters and 'delcombine' is set
		     * move the cursor back.  Don't back up before the base
		     * character.
		     */
		    if (enc_utf8 && p_deco && cpc[0] != NUL)
			inc_cursor();
#ifdef FEAT_RIGHTLEFT
		    if (revins_chars)
		    {
			revins_chars--;
			revins_legal++;
		    }
		    if (revins_on && gchar_cursor() == NUL)
			break;
#endif
		}
		// Just a single backspace?:
		if (mode == BACKSPACE_CHAR)
		    break;
	    } while (
#ifdef FEAT_RIGHTLEFT
		    revins_on ||
#endif
		    (curwin->w_cursor.col > mincol
		    &&  (can_bs(BS_NOSTOP)
			|| (curwin->w_cursor.lnum != Insstart_orig.lnum
			|| curwin->w_cursor.col != Insstart_orig.col)
		    )));
	}
	did_backspace = TRUE;
    }
    did_si = FALSE;
    can_si = FALSE;
    can_si_back = FALSE;
    if (curwin->w_cursor.col <= 1)
	did_ai = FALSE;

    if (call_fix_indent)
	fix_indent();

    /*
     * It's a little strange to put backspaces into the redo
     * buffer, but it makes auto-indent a lot easier to deal
     * with.
     */
    AppendCharToRedobuff(c);

    // If deleted before the insertion point, adjust it
    if (curwin->w_cursor.lnum == Insstart_orig.lnum
				  && curwin->w_cursor.col < Insstart_orig.col)
	Insstart_orig.col = curwin->w_cursor.col;

    // vi behaviour: the cursor moves backward but the character that
    //		     was there remains visible
    // Vim behaviour: the cursor moves backward and the character that
    //		      was there is erased from the screen.
    // We can emulate the vi behaviour by pretending there is a dollar
    // displayed even when there isn't.
    //  --pkv Sun Jan 19 01:56:40 EST 2003
    if (vim_strchr(p_cpo, CPO_BACKSPACE) != NULL && dollar_vcol == -1)
	dollar_vcol = curwin->w_virtcol;

#ifdef FEAT_FOLDING
    // When deleting a char the cursor line must never be in a closed fold.
    // E.g., when 'foldmethod' is indent and deleting the first non-white
    // char before a Tab.
    if (did_backspace)
	foldOpenCursor();
#endif

    return did_backspace;
}","static int
ins_bs(
    int		VAR_0,
    int		VAR_1,
    int		*VAR_2)
{
    linenr_T	VAR_3;
    int		VAR_4;
    int		VAR_5 = 0;	    /* COMMENT_0 */
    colnr_T	VAR_6;
    colnr_T	VAR_7;
    int		VAR_8 = FALSE;
    int		VAR_9;
    int		VAR_10;
    int		VAR_11[VAR_12];	    /* COMMENT_1 */
    int		VAR_13 = FALSE;

    /* COMMENT_2 */
                                             
                                                  
                                                              
                                                        
       
    if (       BUFEMPTY()
	    || (
#ifdef VAR_14
		!VAR_15 &&
#endif
		((VAR_16->w_cursor.lnum == 1 && VAR_16->w_cursor.col == 0)
		    || (!can_bs(VAR_17)
			&& ((VAR_18
#ifdef VAR_19
				&& !bt_prompt(VAR_20)
#endif
			) || (VAR_16->w_cursor.lnum == VAR_21.lnum
				&& VAR_16->w_cursor.col <= VAR_21.col)))
		    || (!can_bs(VAR_22) && !VAR_18 && VAR_23 > 0
					 && VAR_16->w_cursor.col <= VAR_23)
		    || (!can_bs(VAR_24) && VAR_16->w_cursor.col == 0))))
    {
	vim_beep(VAR_25);
	return FALSE;
    }

    if (stop_arrow() == VAR_26)
	return FALSE;
    VAR_9 = inindent(0);
    if (VAR_9)
	VAR_27 = FALSE;
    VAR_28 = VAR_29;	/* COMMENT_8 */
#ifdef VAR_14
    if (VAR_15)	    /* COMMENT_9 */
	inc_cursor();
#endif

    /* COMMENT_10 */
    /* COMMENT_11 */
    /* COMMENT_12 */
    /* COMMENT_13 */
    if (VAR_16->w_cursor.coladd > 0)
    {
	if (VAR_1 == VAR_30)
	{
	    --VAR_16->w_cursor.coladd;
	    return TRUE;
	}
	if (VAR_1 == VAR_31)
	{
	    VAR_16->w_cursor.coladd = 0;
	    return TRUE;
	}
	VAR_16->w_cursor.coladd = 0;
    }

    /* COMMENT_14 */
                      
       
    if (VAR_16->w_cursor.col == 0)
    {
	VAR_3 = VAR_32.lnum;
	if (VAR_16->w_cursor.lnum == VAR_3
#ifdef VAR_14
			|| VAR_15
#endif
				    )
	{
	    if (u_save((linenr_T)(VAR_16->w_cursor.lnum - 2),
			       (linenr_T)(VAR_16->w_cursor.lnum + 1)) == VAR_26)
		return FALSE;
	    --VAR_32.lnum;
	    VAR_32.col = (colnr_T)STRLEN(ml_get(VAR_32.lnum));
	}
	/* COMMENT_17 */
                    
                                      
                                                          
    
	VAR_4 = -1;
	if (VAR_33 & VAR_34)
	    VAR_4 = replace_pop();	    /* COMMENT_22 */
	/* COMMENT_23 */
                                                                       
           
    
	if ((VAR_33 & VAR_34) && VAR_16->w_cursor.lnum <= VAR_3)
	{
	    dec_cursor();
	}
	else
	{
	    if (!(VAR_33 & VAR_35)
				   || VAR_16->w_cursor.lnum > VAR_36)
	    {
		VAR_5 = gchar_cursor();	/* COMMENT_27 */
		--VAR_16->w_cursor.lnum;

		/* COMMENT_28 */
		/* COMMENT_29 */
		/* COMMENT_30 */
		if (has_format_option(VAR_37)
					   && has_format_option(VAR_38))
		{
		    char_u  *VAR_39 = ml_get_buf(VAR_20, VAR_16->w_cursor.lnum,
									TRUE);
		    int	    VAR_40;

		    VAR_40 = (int)STRLEN(VAR_39);
		    if (VAR_40 > 0 && VAR_39[VAR_40 - 1] == ' ')
			VAR_39[VAR_40 - 1] = VAR_29;
		}

		(void)do_join(2, FALSE, FALSE, FALSE, FALSE);
		if (VAR_5 == VAR_29 && gchar_cursor() != VAR_29)
		    inc_cursor();
	    }
	    else
		dec_cursor();

	    /* COMMENT_31 */
                                                                  
                                                           
                                                                        
                                        
        
	    if (VAR_33 & VAR_34)
	    {
		/* COMMENT_37 */
                                                    
                                                     
                          
     
		VAR_10 = VAR_33;
		VAR_33 = VAR_41;
		/* COMMENT_42 */
                                                     
     
		while (VAR_4 > 0)
		{
		    VAR_6 = VAR_16->w_cursor.col;
		    mb_replace_pop_ins(VAR_4);
		    VAR_16->w_cursor.col = VAR_6;
		    VAR_4 = replace_pop();
		}
		/* COMMENT_45 */
		replace_pop_ins();
		VAR_33 = VAR_10;
	    }
	}
	VAR_42 = FALSE;
    }
    else
    {
	/* COMMENT_46 */
                                          
    
#ifdef VAR_14
	if (VAR_15)		/* COMMENT_49 */
	    dec_cursor();
#endif
	VAR_7 = 0;
						/* COMMENT_50 */
	if (VAR_1 == VAR_43
		&& (VAR_20->b_p_ai || cindent_on())
#ifdef VAR_14
		&& !VAR_15
#endif
			    )
	{
	    VAR_6 = VAR_16->w_cursor.col;
	    beginline(VAR_44);
	    if (VAR_16->w_cursor.col < VAR_6)
	    {
		VAR_7 = VAR_16->w_cursor.col;
		/* COMMENT_51 */
		VAR_13 = TRUE;
	    }
	    VAR_16->w_cursor.col = VAR_6;
	}

	/* COMMENT_52 */
                                                      
    
	if (	   VAR_1 == VAR_30
		&& ((VAR_45 && VAR_9)
		    || ((get_sts_value() != 0
#ifdef VAR_46
			|| tabstop_count(VAR_20->b_p_vsts_array)
#endif
			)
			&& VAR_16->w_cursor.col > 0
			&& (*(ml_get_cursor() - 1) == VAR_47
			    || (*(ml_get_cursor() - 1) == ' '
				&& (!*VAR_2
				    || VAR_18))))))
	{
	    int		VAR_48;
	    colnr_T	VAR_49;
	    colnr_T	VAR_50;
	    colnr_T	VAR_51;

	    *VAR_2 = FALSE;
	    /* COMMENT_55 */
	    /* COMMENT_56 */
	    /* COMMENT_57 */
	    getvcol(VAR_16, &VAR_16->w_cursor, &VAR_49, NULL, NULL);
	    VAR_51 = VAR_49;
	    dec_cursor();
	    getvcol(VAR_16, &VAR_16->w_cursor, NULL, NULL, &VAR_50);
	    inc_cursor();
#ifdef VAR_46
	    if (VAR_45 && VAR_9)
	    {
		VAR_48 = (int)get_sw_value(VAR_20);
		VAR_50 = (VAR_50 / VAR_48) * VAR_48;
	    }
	    else
		VAR_50 = tabstop_start(VAR_50, get_sts_value(),
						       VAR_20->b_p_vsts_array);
#else
	    if (VAR_45 && VAR_9)
		VAR_48 = (int)get_sw_value(VAR_20);
	    else
		VAR_48 = (int)get_sts_value();
	    VAR_50 = (VAR_50 / VAR_48) * VAR_48;
#endif

	    /* COMMENT_58 */
	    while (VAR_49 > VAR_50 && VAR_16->w_cursor.col > 0
		    && (VAR_4 = *(ml_get_cursor() - 1), VIM_ISWHITE(VAR_4)))
		ins_bs_one(&VAR_49);

	    /* COMMENT_59 */
	    while (VAR_49 < VAR_50)
	    {
		/* COMMENT_60 */
		if (VAR_16->w_cursor.lnum == VAR_21.lnum
				   && VAR_16->w_cursor.col < VAR_21.col)
		    VAR_21.col = VAR_16->w_cursor.col;

		if (VAR_33 & VAR_35)
		    ins_char(' ');
		else
		{
		    ins_str((char_u *)"" "");
		    if ((VAR_33 & VAR_34))
			replace_push(VAR_29);
		}
		getvcol(VAR_16, &VAR_16->w_cursor, &VAR_49, NULL, NULL);
	    }

	    /* COMMENT_61 */
	    /* COMMENT_62 */
	    if (VAR_49 >= VAR_51)
		ins_bs_one(&VAR_49);
	}

	/* COMMENT_63 */
                                                                
    
	else
	{
	    int VAR_52 = 0, VAR_53 = 0;

	    if (VAR_54)
		VAR_52 = mb_get_class(ml_get_cursor());
	    do
	    {
#ifdef VAR_14
		if (!VAR_15) /* COMMENT_66 */
#endif
		    dec_cursor();

		VAR_4 = gchar_cursor();
		/* COMMENT_67 */
		if (VAR_54)
		{
		    VAR_53 = VAR_52;
		    VAR_52 = mb_get_class(ml_get_cursor());
		}

		/* COMMENT_68 */
		if (VAR_1 == VAR_31 && !vim_isspace(VAR_4))
		{
		    VAR_1 = VAR_55;
		    VAR_5 = vim_iswordc(VAR_4);
		}
		/* COMMENT_69 */
		else if (VAR_1 == VAR_55
			&& ((vim_isspace(VAR_4) || vim_iswordc(VAR_4) != VAR_5)
			|| VAR_53 != VAR_52))
		{
#ifdef VAR_14
		    if (!VAR_15)
#endif
			inc_cursor();
#ifdef VAR_14
		    else if (State & VAR_34)
			dec_cursor();
#endif
		    break;
		}
		if (State & VAR_34)
		    replace_do_bs(-1);
		else
		{
		    if (VAR_56 && VAR_57)
			(void)utfc_ptr2char(ml_get_cursor(), VAR_11);
		    (void)del_char(FALSE);
		    /* COMMENT_70 */
                                                                  
                                                             
                   
         
		    if (VAR_56 && VAR_57 && VAR_11[0] != VAR_29)
			inc_cursor();
#ifdef VAR_14
		    if (VAR_58)
		    {
			VAR_58--;
			VAR_59++;
		    }
		    if (VAR_15 && gchar_cursor() == VAR_29)
			break;
#endif
		}
		/* COMMENT_75 */
		if (VAR_1 == VAR_30)
		    break;
	    } while (
#ifdef VAR_14
		    VAR_15 ||
#endif
		    (VAR_16->w_cursor.col > VAR_7
		    &&  (can_bs(VAR_60)
			|| (VAR_16->w_cursor.lnum != VAR_21.lnum
			|| VAR_16->w_cursor.col != VAR_21.col)
		    )));
	}
	VAR_8 = TRUE;
    }
    VAR_61 = FALSE;
    VAR_62 = FALSE;
    VAR_63 = FALSE;
    if (VAR_16->w_cursor.col <= 1)
	VAR_42 = FALSE;

    if (VAR_13)
	fix_indent();

    /* COMMENT_76 */
                                                            
                                                            
            
       
    AppendCharToRedobuff(VAR_0);

    /* COMMENT_81 */
    if (VAR_16->w_cursor.lnum == VAR_21.lnum
				  && VAR_16->w_cursor.col < VAR_21.col)
	VAR_21.col = VAR_16->w_cursor.col;

    /* COMMENT_82 */
    /* COMMENT_83 */
    /* COMMENT_84 */
    /* COMMENT_85 */
    /* COMMENT_86 */
    /* COMMENT_87 */
    /* COMMENT_88 */
    if (vim_strchr(VAR_64, VAR_65) != NULL && VAR_66 == -1)
	VAR_66 = VAR_16->w_virtcol;

#ifdef VAR_67
    /* COMMENT_89 */
    /* COMMENT_90 */
    /* COMMENT_91 */
    if (VAR_8)
	foldOpenCursor();
#endif

    return VAR_8;
}",vim/0971c7a4e537ea120a6bb2195960be8d0815e97b/edit.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -245,7 +245,7 @@
 #endif
 
 	    // delete characters until we are at or before want_vcol
-	    while (vcol > want_vcol
+	    while (vcol > want_vcol && curwin->w_cursor.col > 0
 		    && (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))
 		ins_bs_one(&vcol);
 ","{'deleted_lines': ['\t    while (vcol > want_vcol'], 'added_lines': ['\t    while (vcol > want_vcol && curwin->w_cursor.col > 0']}",True,Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.,7.8,HIGH,2,test,2022-06-26T11:59:02Z,4
CVE-2022-2231,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vim,"patch 8.2.5169: nested :source may use NULL pointer

Problem:    Nested :source may use NULL pointer.
Solution:   Do not use the NULL pointer.",79481367a457951aabd9501b510fd7e3eb29c3d8,https://github.com/vim/vim/commit/79481367a457951aabd9501b510fd7e3eb29c3d8,src/eval.c,eval0_retarg,"int
eval0_retarg(
char_u*arg,
typval_T*rettv,
exarg_T*eap,
evalarg_T*evalarg,
char_u**retarg)
{
intret;
char_u*p;
char_u*expr_end;
intdid_emsg_before = did_emsg;
intcalled_emsg_before = called_emsg;
intflags = evalarg == NULL ? 0 : evalarg->eval_flags;
intcheck_for_end = retarg == NULL;
intend_error = FALSE;
p = skipwhite(arg);
ret = eval1(&p, rettv, evalarg);
expr_end = p;
p = skipwhite(p);
if (in_vim9script() && p > expr_end && retarg == NULL)
while (*p == '#')
{
char_u *nl = vim_strchr(p, NL);
if (nl == NULL)
break;
p = skipwhite(nl + 1);
if (eap != NULL && *p != NUL)
eap->nextcmd = p;
check_for_end = FALSE;
}
if (ret != FAIL && check_for_end)
end_error = !ends_excmd2(arg, p);
if (ret == FAIL || end_error)
{
if (ret != FAIL)
clear_tv(rettv);
if (!aborting()
&& did_emsg == did_emsg_before
&& called_emsg == called_emsg_before
&& (flags & EVAL_CONSTANT) == 0
&& (!in_vim9script() || !vim9_bad_comment(p)))
{
if (end_error)
semsg(_(e_trailing_characters_str), p);
else
semsg(_(e_invalid_expression_str), arg);
}
if (eap != NULL && skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|')
eap->nextcmd = check_nextcmd(p);
return FAIL;
}
if (retarg != NULL)
*retarg = p;
else if (check_for_end && eap != NULL)
set_nextcmd(eap, p);
return ret;
}","int
eval0_retarg(
char_u*VAR_0,
typval_T*VAR_1,
exarg_T*VAR_2,
evalarg_T*VAR_3,
char_u**VAR_4)
{
intVAR_5;
char_u*VAR_6;
char_u*VAR_7;
intVAR_8 = VAR_9;
intVAR_10 = VAR_11;
intVAR_12 = VAR_3 == NULL ? 0 : VAR_3->eval_flags;
intVAR_13 = VAR_4 == NULL;
intVAR_14 = FALSE;
VAR_6 = skipwhite(VAR_0);
VAR_5 = eval1(&VAR_6, VAR_1, VAR_3);
VAR_7 = VAR_6;
VAR_6 = skipwhite(VAR_6);
if (in_vim9script() && VAR_6 > VAR_7 && VAR_4 == NULL)
while (*VAR_6 == '#')
{
char_u *VAR_15 = vim_strchr(VAR_6, VAR_16);
if (VAR_15 == NULL)
break;
VAR_6 = skipwhite(VAR_15 + 1);
if (VAR_2 != NULL && *VAR_6 != VAR_17)
VAR_2->nextcmd = VAR_6;
VAR_13 = FALSE;
}
if (VAR_5 != VAR_18 && VAR_13)
VAR_14 = !ends_excmd2(VAR_0, VAR_6);
if (VAR_5 == VAR_18 || VAR_14)
{
if (VAR_5 != VAR_18)
clear_tv(VAR_1);
if (!aborting()
&& VAR_9 == VAR_8
&& VAR_11 == VAR_10
&& (VAR_12 & VAR_19) == 0
&& (!in_vim9script() || !vim9_bad_comment(VAR_6)))
{
if (VAR_14)
semsg(_(VAR_20), VAR_6);
else
semsg(_(VAR_21), VAR_0);
}
if (VAR_2 != NULL && skipwhite(VAR_6)[0] == '|' && skipwhite(VAR_6)[1] != '|')
VAR_2->nextcmd = check_nextcmd(VAR_6);
return VAR_18;
}
if (VAR_4 != NULL)
*VAR_4 = VAR_6;
else if (VAR_13 && VAR_2 != NULL)
set_nextcmd(VAR_2, VAR_6);
return VAR_5;
}",vim/79481367a457951aabd9501b510fd7e3eb29c3d8/eval.c/vul/before/0.json,"int
eval0_retarg(
    char_u	*arg,
    typval_T	*rettv,
    exarg_T	*eap,
    evalarg_T	*evalarg,
    char_u	**retarg)
{
    int		ret;
    char_u	*p;
    char_u	*expr_end;
    int		did_emsg_before = did_emsg;
    int		called_emsg_before = called_emsg;
    int		flags = evalarg == NULL ? 0 : evalarg->eval_flags;
    int		check_for_end = retarg == NULL;
    int		end_error = FALSE;

    p = skipwhite(arg);
    ret = eval1(&p, rettv, evalarg);

    if (ret != FAIL)
    {
	expr_end = p;
	p = skipwhite(p);

	// In Vim9 script a command block is not split at NL characters for
	// commands using an expression argument.  Skip over a '#' comment to
	// check for a following NL.  Require white space before the '#'.
	if (in_vim9script() && p > expr_end && retarg == NULL)
	    while (*p == '#')
	    {
		char_u *nl = vim_strchr(p, NL);

		if (nl == NULL)
		    break;
		p = skipwhite(nl + 1);
		if (eap != NULL && *p != NUL)
		    eap->nextcmd = p;
		check_for_end = FALSE;
	    }

	if (check_for_end)
	    end_error = !ends_excmd2(arg, p);
    }

    if (ret == FAIL || end_error)
    {
	if (ret != FAIL)
	    clear_tv(rettv);
	/*
	 * Report the invalid expression unless the expression evaluation has
	 * been cancelled due to an aborting error, an interrupt, or an
	 * exception, or we already gave a more specific error.
	 * Also check called_emsg for when using assert_fails().
	 */
	if (!aborting()
		&& did_emsg == did_emsg_before
		&& called_emsg == called_emsg_before
		&& (flags & EVAL_CONSTANT) == 0
		&& (!in_vim9script() || !vim9_bad_comment(p)))
	{
	    if (end_error)
		semsg(_(e_trailing_characters_str), p);
	    else
		semsg(_(e_invalid_expression_str), arg);
	}

	// Some of the expression may not have been consumed.  Do not check for
	// a next command to avoid more errors, unless ""|"" is following, which
	// could only be a command separator.
	if (eap != NULL && p != NULL
			  &&  skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|')
	    eap->nextcmd = check_nextcmd(p);
	return FAIL;
    }

    if (retarg != NULL)
	*retarg = p;
    else if (check_for_end && eap != NULL)
	set_nextcmd(eap, p);

    return ret;
}","int
eval0_retarg(
    char_u	*VAR_0,
    typval_T	*VAR_1,
    exarg_T	*VAR_2,
    evalarg_T	*VAR_3,
    char_u	**VAR_4)
{
    int		VAR_5;
    char_u	*VAR_6;
    char_u	*VAR_7;
    int		VAR_8 = VAR_9;
    int		VAR_10 = VAR_11;
    int		VAR_12 = VAR_3 == NULL ? 0 : VAR_3->eval_flags;
    int		VAR_13 = VAR_4 == NULL;
    int		VAR_14 = FALSE;

    VAR_6 = skipwhite(VAR_0);
    VAR_5 = eval1(&VAR_6, VAR_1, VAR_3);

    if (VAR_5 != VAR_15)
    {
	VAR_7 = VAR_6;
	VAR_6 = skipwhite(VAR_6);

	/* COMMENT_0 */
	/* COMMENT_1 */
	/* COMMENT_2 */
	if (in_vim9script() && VAR_6 > VAR_7 && VAR_4 == NULL)
	    while (*VAR_6 == '#')
	    {
		char_u *VAR_16 = vim_strchr(VAR_6, VAR_17);

		if (VAR_16 == NULL)
		    break;
		VAR_6 = skipwhite(VAR_16 + 1);
		if (VAR_2 != NULL && *VAR_6 != VAR_18)
		    VAR_2->nextcmd = VAR_6;
		VAR_13 = FALSE;
	    }

	if (VAR_13)
	    VAR_14 = !ends_excmd2(VAR_0, VAR_6);
    }

    if (VAR_5 == VAR_15 || VAR_14)
    {
	if (VAR_5 != VAR_15)
	    clear_tv(VAR_1);
	/* COMMENT_3 */
                                                                      
                                                                
                                                        
                                                         
    
	if (!aborting()
		&& VAR_9 == VAR_8
		&& VAR_11 == VAR_10
		&& (VAR_12 & VAR_19) == 0
		&& (!in_vim9script() || !vim9_bad_comment(VAR_6)))
	{
	    if (VAR_14)
		semsg(_(VAR_20), VAR_6);
	    else
		semsg(_(VAR_21), VAR_0);
	}

	/* COMMENT_9 */
	/* COMMENT_10 */
	/* COMMENT_11 */
	if (VAR_2 != NULL && VAR_6 != NULL
			  &&  skipwhite(VAR_6)[0] == '|' && skipwhite(VAR_6)[1] != '|')
	    VAR_2->nextcmd = check_nextcmd(VAR_6);
	return VAR_15;
    }

    if (VAR_4 != NULL)
	*VAR_4 = VAR_6;
    else if (VAR_13 && VAR_2 != NULL)
	set_nextcmd(VAR_2, VAR_6);

    return VAR_5;
}",vim/79481367a457951aabd9501b510fd7e3eb29c3d8/eval.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,27 +17,32 @@
 
     p = skipwhite(arg);
     ret = eval1(&p, rettv, evalarg);
-    expr_end = p;
-    p = skipwhite(p);
 
-    // In Vim9 script a command block is not split at NL characters for
-    // commands using an expression argument.  Skip over a '#' comment to check
-    // for a following NL.  Require white space before the '#'.
-    if (in_vim9script() && p > expr_end && retarg == NULL)
-	while (*p == '#')
-	{
-	    char_u *nl = vim_strchr(p, NL);
+    if (ret != FAIL)
+    {
+	expr_end = p;
+	p = skipwhite(p);
 
-	    if (nl == NULL)
-		break;
-	    p = skipwhite(nl + 1);
-	    if (eap != NULL && *p != NUL)
-		eap->nextcmd = p;
-	    check_for_end = FALSE;
-	}
+	// In Vim9 script a command block is not split at NL characters for
+	// commands using an expression argument.  Skip over a '#' comment to
+	// check for a following NL.  Require white space before the '#'.
+	if (in_vim9script() && p > expr_end && retarg == NULL)
+	    while (*p == '#')
+	    {
+		char_u *nl = vim_strchr(p, NL);
 
-    if (ret != FAIL && check_for_end)
-	end_error = !ends_excmd2(arg, p);
+		if (nl == NULL)
+		    break;
+		p = skipwhite(nl + 1);
+		if (eap != NULL && *p != NUL)
+		    eap->nextcmd = p;
+		check_for_end = FALSE;
+	    }
+
+	if (check_for_end)
+	    end_error = !ends_excmd2(arg, p);
+    }
+
     if (ret == FAIL || end_error)
     {
 	if (ret != FAIL)
@@ -63,7 +68,8 @@
 	// Some of the expression may not have been consumed.  Do not check for
 	// a next command to avoid more errors, unless ""|"" is following, which
 	// could only be a command separator.
-	if (eap != NULL && skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|')
+	if (eap != NULL && p != NULL
+			  &&  skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|')
 	    eap->nextcmd = check_nextcmd(p);
 	return FAIL;
     }","{'deleted_lines': ['    expr_end = p;', '    p = skipwhite(p);', '    // In Vim9 script a command block is not split at NL characters for', ""    // commands using an expression argument.  Skip over a '#' comment to check"", ""    // for a following NL.  Require white space before the '#'."", '    if (in_vim9script() && p > expr_end && retarg == NULL)', ""\twhile (*p == '#')"", '\t{', '\t    char_u *nl = vim_strchr(p, NL);', '\t    if (nl == NULL)', '\t\tbreak;', '\t    p = skipwhite(nl + 1);', '\t    if (eap != NULL && *p != NUL)', '\t\teap->nextcmd = p;', '\t    check_for_end = FALSE;', '\t}', '    if (ret != FAIL && check_for_end)', '\tend_error = !ends_excmd2(arg, p);', ""\tif (eap != NULL && skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|')""], 'added_lines': ['    if (ret != FAIL)', '    {', '\texpr_end = p;', '\tp = skipwhite(p);', '\t// In Vim9 script a command block is not split at NL characters for', ""\t// commands using an expression argument.  Skip over a '#' comment to"", ""\t// check for a following NL.  Require white space before the '#'."", '\tif (in_vim9script() && p > expr_end && retarg == NULL)', ""\t    while (*p == '#')"", '\t    {', '\t\tchar_u *nl = vim_strchr(p, NL);', '\t\tif (nl == NULL)', '\t\t    break;', '\t\tp = skipwhite(nl + 1);', '\t\tif (eap != NULL && *p != NUL)', '\t\t    eap->nextcmd = p;', '\t\tcheck_for_end = FALSE;', '\t    }', '', '\tif (check_for_end)', '\t    end_error = !ends_excmd2(arg, p);', '    }', '', '\tif (eap != NULL && p != NULL', ""\t\t\t  &&  skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|')""]}",True,NULL Pointer Dereference in GitHub repository vim/vim prior to 8.2.,5.5,MEDIUM,1,test,2022-06-27T19:15:10Z,4
CVE-2023-44488,['CWE-755'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,webmproject/libvpx,"Fix bug with smaller width bigger size

Fixed previous patch that clusterfuzz failed on.

Local fuzzing passing overnight.

Bug: webm:1642
Change-Id: If0e08e72abd2e042efe4dcfac21e4cc51afdfdb9
(cherry picked from commit 263682c9a29395055f3b3afe2d97be1828a6223f)",df9fd9d5b7325060b2b921558a1eb20ca7880937,https://github.com/webmproject/libvpx/commit/df9fd9d5b7325060b2b921558a1eb20ca7880937,vp9/common/vp9_alloccommon.c,vp9_alloc_context_buffers,"int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {
int new_mi_size;
vp9_set_mb_mi(cm, width, height);
new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);
if (cm->mi_alloc_size < new_mi_size) {
cm->free_mi(cm);
if (cm->alloc_mi(cm, new_mi_size)) goto fail;
}
if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {
free_seg_map(cm);
if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;
}
if (cm->above_context_alloc_cols < cm->mi_cols) {
vpx_free(cm->above_context);
cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(
2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,
sizeof(*cm->above_context));
if (!cm->above_context) goto fail;
vpx_free(cm->above_seg_context);
cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(
mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));
if (!cm->above_seg_context) goto fail;
cm->above_context_alloc_cols = cm->mi_cols;
}
if (vp9_alloc_loop_filter(cm)) goto fail;
return 0;
fail:
vp9_set_mb_mi(cm, 0, 0);
vp9_free_context_buffers(cm);
return 1;
}","int vp9_alloc_context_buffers(VP9_COMMON *VAR_0, int VAR_1, int VAR_2) {
int VAR_3;
vp9_set_mb_mi(VAR_0, VAR_1, VAR_2);
VAR_3 = VAR_0->mi_stride * calc_mi_size(VAR_0->mi_rows);
if (VAR_0->mi_alloc_size < VAR_3) {
VAR_0->free_mi(VAR_0);
if (VAR_0->alloc_mi(VAR_0, VAR_3)) goto fail;
}
if (VAR_0->seg_map_alloc_size < VAR_0->mi_rows * VAR_0->mi_cols) {
free_seg_map(VAR_0);
if (alloc_seg_map(VAR_0, VAR_0->mi_rows * VAR_0->mi_cols)) goto fail;
}
if (VAR_0->above_context_alloc_cols < VAR_0->mi_cols) {
vpx_free(VAR_0->above_context);
VAR_0->above_context = (ENTROPY_CONTEXT *)vpx_calloc(
2 * mi_cols_aligned_to_sb(VAR_0->mi_cols) * VAR_4,
sizeof(*VAR_0->above_context));
if (!VAR_0->above_context) goto fail;
vpx_free(VAR_0->above_seg_context);
VAR_0->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(
mi_cols_aligned_to_sb(VAR_0->mi_cols), sizeof(*VAR_0->above_seg_context));
if (!VAR_0->above_seg_context) goto fail;
VAR_0->above_context_alloc_cols = VAR_0->mi_cols;
}
if (vp9_alloc_loop_filter(VAR_0)) goto fail;
return 0;
fail:
vp9_set_mb_mi(VAR_0, 0, 0);
vp9_free_context_buffers(VAR_0);
return 1;
}",webmproject/libvpx/df9fd9d5b7325060b2b921558a1eb20ca7880937/vp9_alloccommon.c/vul/before/0.json,"int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {
  int new_mi_size;

  vp9_set_mb_mi(cm, width, height);
  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);
  if (cm->mi_alloc_size < new_mi_size) {
    cm->free_mi(cm);
    if (cm->alloc_mi(cm, new_mi_size)) goto fail;
  }
  if (cm->above_context_alloc_cols < cm->mi_cols) {
    vpx_free(cm->above_context);
    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(
        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,
        sizeof(*cm->above_context));
    if (!cm->above_context) goto fail;

    vpx_free(cm->above_seg_context);
    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(
        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));
    if (!cm->above_seg_context) goto fail;
    cm->above_context_alloc_cols = cm->mi_cols;
  }

  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {
    // Create the segmentation map structure and set to 0.
    free_seg_map(cm);
    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;
  }

  if (vp9_alloc_loop_filter(cm)) goto fail;

  return 0;

fail:
  // clear the mi_* values to force a realloc on resync
  vp9_set_mb_mi(cm, 0, 0);
  vp9_free_context_buffers(cm);
  return 1;
}","int vp9_alloc_context_buffers(VP9_COMMON *VAR_0, int VAR_1, int VAR_2) {
  int VAR_3;

  vp9_set_mb_mi(VAR_0, VAR_1, VAR_2);
  VAR_3 = VAR_0->mi_stride * calc_mi_size(VAR_0->mi_rows);
  if (VAR_0->mi_alloc_size < VAR_3) {
    VAR_0->free_mi(VAR_0);
    if (VAR_0->alloc_mi(VAR_0, VAR_3)) goto fail;
  }
  if (VAR_0->above_context_alloc_cols < VAR_0->mi_cols) {
    vpx_free(VAR_0->above_context);
    VAR_0->above_context = (ENTROPY_CONTEXT *)vpx_calloc(
        2 * mi_cols_aligned_to_sb(VAR_0->mi_cols) * VAR_4,
        sizeof(*VAR_0->above_context));
    if (!VAR_0->above_context) goto fail;

    vpx_free(VAR_0->above_seg_context);
    VAR_0->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(
        mi_cols_aligned_to_sb(VAR_0->mi_cols), sizeof(*VAR_0->above_seg_context));
    if (!VAR_0->above_seg_context) goto fail;
    VAR_0->above_context_alloc_cols = VAR_0->mi_cols;
  }

  if (VAR_0->seg_map_alloc_size < VAR_0->mi_rows * VAR_0->mi_cols) {
    /* COMMENT_0 */
    free_seg_map(VAR_0);
    if (alloc_seg_map(VAR_0, VAR_0->mi_rows * VAR_0->mi_cols)) goto fail;
  }

  if (vp9_alloc_loop_filter(VAR_0)) goto fail;

  return 0;

fail:
  /* COMMENT_1 */
  vp9_set_mb_mi(VAR_0, 0, 0);
  vp9_free_context_buffers(VAR_0);
  return 1;
}",webmproject/libvpx/df9fd9d5b7325060b2b921558a1eb20ca7880937/vp9_alloccommon.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,13 +7,6 @@
     cm->free_mi(cm);
     if (cm->alloc_mi(cm, new_mi_size)) goto fail;
   }
-
-  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {
-    // Create the segmentation map structure and set to 0.
-    free_seg_map(cm);
-    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;
-  }
-
   if (cm->above_context_alloc_cols < cm->mi_cols) {
     vpx_free(cm->above_context);
     cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(
@@ -28,6 +21,12 @@
     cm->above_context_alloc_cols = cm->mi_cols;
   }
 
+  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {
+    // Create the segmentation map structure and set to 0.
+    free_seg_map(cm);
+    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;
+  }
+
   if (vp9_alloc_loop_filter(cm)) goto fail;
 
   return 0;","{'deleted_lines': ['', '  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {', '    // Create the segmentation map structure and set to 0.', '    free_seg_map(cm);', '    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;', '  }', ''], 'added_lines': ['  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {', '    // Create the segmentation map structure and set to 0.', '    free_seg_map(cm);', '    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;', '  }', '']}",True,"VP9 in libvpx before 1.13.1 mishandles widths, leading to a crash related to encoding.",7.5,HIGH,2,test,2022-06-30T17:48:56Z,4
CVE-2023-44488,['CWE-755'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,webmproject/libvpx,"Fix bug with smaller width bigger size

Fixed previous patch that clusterfuzz failed on.

Bug: webm:1642
Change-Id: If0e08e72abd2e042efe4dcfac21e4cc51afdfdb9",263682c9a29395055f3b3afe2d97be1828a6223f,https://github.com/webmproject/libvpx/commit/263682c9a29395055f3b3afe2d97be1828a6223f,vp9/encoder/vp9_encoder.c,vp9_change_config,"void vp9_change_config(struct VP9_COMP *cpi, const VP9EncoderConfig *oxcf) {
VP9_COMMON *const cm = &cpi->common;
RATE_CONTROL *const rc = &cpi->rc;
int last_w = cpi->oxcf.width;
int last_h = cpi->oxcf.height;
vp9_init_quantizer(cpi);
if (cm->profile != oxcf->profile) cm->profile = oxcf->profile;
cm->bit_depth = oxcf->bit_depth;
cm->color_space = oxcf->color_space;
cm->color_range = oxcf->color_range;
cpi->target_level = oxcf->target_level;
cpi->keep_level_stats = oxcf->target_level != LEVEL_MAX;
set_level_constraint(&cpi->level_constraint,
get_level_index(cpi->target_level));
if (cm->profile <= PROFILE_1)
assert(cm->bit_depth == VPX_BITS_8);
else
assert(cm->bit_depth > VPX_BITS_8);
cpi->oxcf = *oxcf;
#if CONFIG_VP9_HIGHBITDEPTH
cpi->td.mb.e_mbd.bd = (int)cm->bit_depth;
#endif  
if ((oxcf->pass == 0) && (oxcf->rc_mode == VPX_Q)) {
rc->baseline_gf_interval = FIXED_GF_INTERVAL;
} else {
rc->baseline_gf_interval = (MIN_GF_INTERVAL + MAX_GF_INTERVAL) / 2;
}
cpi->refresh_golden_frame = 0;
cpi->refresh_last_frame = 1;
cm->refresh_frame_context = 1;
cm->reset_frame_context = 0;
vp9_reset_segment_features(&cm->seg);
vp9_set_high_precision_mv(cpi, 0);
{
int i;
for (i = 0; i < MAX_SEGMENTS; i++)
cpi->segment_encode_breakout[i] = cpi->oxcf.encode_breakout;
}
cpi->encode_breakout = cpi->oxcf.encode_breakout;
vp9_set_rc_buffer_sizes(cpi);
vp9_new_framerate(cpi, cpi->framerate);
rc->worst_quality = cpi->oxcf.worst_allowed_q;
rc->best_quality = cpi->oxcf.best_allowed_q;
cm->interp_filter = cpi->sf.default_interp_filter;
if (cpi->oxcf.render_width > 0 && cpi->oxcf.render_height > 0) {
cm->render_width = cpi->oxcf.render_width;
cm->render_height = cpi->oxcf.render_height;
} else {
cm->render_width = cpi->oxcf.width;
cm->render_height = cpi->oxcf.height;
}
if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {
cm->width = cpi->oxcf.width;
cm->height = cpi->oxcf.height;
cpi->external_resize = 1;
}
if (cpi->initial_width) {
int new_mi_size = 0;
vp9_set_mb_mi(cm, cm->width, cm->height);
new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);
if (cm->mi_alloc_size < new_mi_size) {
vp9_free_context_buffers(cm);
alloc_compressor_data(cpi);
realloc_segmentation_maps(cpi);
cpi->initial_width = cpi->initial_height = 0;
cpi->external_resize = 0;
} else if (cm->mi_alloc_size == new_mi_size &&
(cpi->oxcf.width > last_w || cpi->oxcf.height > last_h)) {
if (vp9_alloc_loop_filter(cm)) {
vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,
""Failed to allocate loop filter data"");
}
}
}
if (cm->current_video_frame == 0 || last_w != cpi->oxcf.width ||
last_h != cpi->oxcf.height)
update_frame_size(cpi);
if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {
memset(cpi->consec_zero_mv, 0,
cm->mi_rows * cm->mi_cols * sizeof(*cpi->consec_zero_mv));
if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)
vp9_cyclic_refresh_reset_resize(cpi);
rc->rc_1_frame = 0;
rc->rc_2_frame = 0;
}
if ((cpi->svc.number_temporal_layers > 1) ||
((cpi->svc.number_temporal_layers > 1 ||
cpi->svc.number_spatial_layers > 1) &&
cpi->oxcf.pass != 1)) {
vp9_update_layer_context_change_config(cpi,
(int)cpi->oxcf.target_bandwidth);
}
vp9_check_reset_rc_flag(cpi);
cpi->alt_ref_source = NULL;
rc->is_src_frame_alt_ref = 0;
#if 0
cpi->frame_distortion = 0;
cpi->last_frame_distortion = 0;
#endif
set_tile_limits(cpi);
cpi->ext_refresh_frame_flags_pending = 0;
cpi->ext_refresh_frame_context_pending = 0;
#if CONFIG_VP9_HIGHBITDEPTH
highbd_set_var_fns(cpi);
#endif
vp9_set_row_mt(cpi);
}","void vp9_change_config(struct VP9_COMP *VAR_0, const VP9EncoderConfig *VAR_1) {
VP9_COMMON *const VAR_2 = &VAR_0->common;
RATE_CONTROL *const VAR_3 = &VAR_0->rc;
int VAR_4 = VAR_0->oxcf.width;
int VAR_5 = VAR_0->oxcf.height;
vp9_init_quantizer(VAR_0);
if (VAR_2->profile != VAR_1->profile) VAR_2->profile = VAR_1->profile;
VAR_2->bit_depth = VAR_1->bit_depth;
VAR_2->color_space = VAR_1->color_space;
VAR_2->color_range = VAR_1->color_range;
VAR_0->target_level = VAR_1->target_level;
VAR_0->keep_level_stats = VAR_1->target_level != VAR_6;
set_level_constraint(&VAR_0->level_constraint,
get_level_index(VAR_0->target_level));
if (VAR_2->profile <= VAR_7)
assert(VAR_2->bit_depth == VAR_8);
else
assert(VAR_2->bit_depth > VAR_8);
VAR_0->oxcf = *VAR_1;
#if VAR_9
VAR_0->td.mb.e_mbd.bd = (int)VAR_2->bit_depth;
#endif  
if ((VAR_1->pass == 0) && (VAR_1->rc_mode == VAR_10)) {
VAR_3->baseline_gf_interval = VAR_11;
} else {
VAR_3->baseline_gf_interval = (VAR_12 + VAR_13) / 2;
}
VAR_0->refresh_golden_frame = 0;
VAR_0->refresh_last_frame = 1;
VAR_2->refresh_frame_context = 1;
VAR_2->reset_frame_context = 0;
vp9_reset_segment_features(&VAR_2->seg);
vp9_set_high_precision_mv(VAR_0, 0);
{
int VAR_14;
for (VAR_14 = 0; VAR_14 < VAR_15; VAR_14++)
VAR_0->segment_encode_breakout[VAR_14] = VAR_0->oxcf.encode_breakout;
}
VAR_0->encode_breakout = VAR_0->oxcf.encode_breakout;
vp9_set_rc_buffer_sizes(VAR_0);
vp9_new_framerate(VAR_0, VAR_0->framerate);
VAR_3->worst_quality = VAR_0->oxcf.worst_allowed_q;
VAR_3->best_quality = VAR_0->oxcf.best_allowed_q;
VAR_2->interp_filter = VAR_0->sf.default_interp_filter;
if (VAR_0->oxcf.render_width > 0 && VAR_0->oxcf.render_height > 0) {
VAR_2->render_width = VAR_0->oxcf.render_width;
VAR_2->render_height = VAR_0->oxcf.render_height;
} else {
VAR_2->render_width = VAR_0->oxcf.width;
VAR_2->render_height = VAR_0->oxcf.height;
}
if (VAR_4 != VAR_0->oxcf.width || VAR_5 != VAR_0->oxcf.height) {
VAR_2->width = VAR_0->oxcf.width;
VAR_2->height = VAR_0->oxcf.height;
VAR_0->external_resize = 1;
}
if (VAR_0->initial_width) {
int VAR_16 = 0;
vp9_set_mb_mi(VAR_2, VAR_2->width, VAR_2->height);
VAR_16 = VAR_2->mi_stride * calc_mi_size(VAR_2->mi_rows);
if (VAR_2->mi_alloc_size < VAR_16) {
vp9_free_context_buffers(VAR_2);
alloc_compressor_data(VAR_0);
realloc_segmentation_maps(VAR_0);
VAR_0->initial_width = VAR_0->initial_height = 0;
VAR_0->external_resize = 0;
} else if (VAR_2->mi_alloc_size == VAR_16 &&
(VAR_0->oxcf.width > VAR_4 || VAR_0->oxcf.height > VAR_5)) {
if (vp9_alloc_loop_filter(VAR_2)) {
vpx_internal_error(&VAR_2->error, VAR_17,
""Failed to allocate loop filter data"");
}
}
}
if (VAR_2->current_video_frame == 0 || VAR_4 != VAR_0->oxcf.width ||
VAR_5 != VAR_0->oxcf.height)
update_frame_size(VAR_0);
if (VAR_4 != VAR_0->oxcf.width || VAR_5 != VAR_0->oxcf.height) {
memset(VAR_0->consec_zero_mv, 0,
VAR_2->mi_rows * VAR_2->mi_cols * sizeof(*VAR_0->consec_zero_mv));
if (VAR_0->oxcf.aq_mode == VAR_18)
vp9_cyclic_refresh_reset_resize(VAR_0);
VAR_3->rc_1_frame = 0;
VAR_3->rc_2_frame = 0;
}
if ((VAR_0->svc.number_temporal_layers > 1) ||
((VAR_0->svc.number_temporal_layers > 1 ||
VAR_0->svc.number_spatial_layers > 1) &&
VAR_0->oxcf.pass != 1)) {
vp9_update_layer_context_change_config(VAR_0,
(int)VAR_0->oxcf.target_bandwidth);
}
vp9_check_reset_rc_flag(VAR_0);
VAR_0->alt_ref_source = NULL;
VAR_3->is_src_frame_alt_ref = 0;
#if 0
VAR_0->frame_distortion = 0;
VAR_0->last_frame_distortion = 0;
#endif
set_tile_limits(VAR_0);
VAR_0->ext_refresh_frame_flags_pending = 0;
VAR_0->ext_refresh_frame_context_pending = 0;
#if VAR_9
highbd_set_var_fns(VAR_0);
#endif
vp9_set_row_mt(VAR_0);
}",webmproject/libvpx/263682c9a29395055f3b3afe2d97be1828a6223f/vp9_encoder.c/vul/before/0.json,"void vp9_change_config(struct VP9_COMP *cpi, const VP9EncoderConfig *oxcf) {
  VP9_COMMON *const cm = &cpi->common;
  RATE_CONTROL *const rc = &cpi->rc;
  int last_w = cpi->oxcf.width;
  int last_h = cpi->oxcf.height;

  vp9_init_quantizer(cpi);
  if (cm->profile != oxcf->profile) cm->profile = oxcf->profile;
  cm->bit_depth = oxcf->bit_depth;
  cm->color_space = oxcf->color_space;
  cm->color_range = oxcf->color_range;

  cpi->target_level = oxcf->target_level;
  cpi->keep_level_stats = oxcf->target_level != LEVEL_MAX;
  set_level_constraint(&cpi->level_constraint,
                       get_level_index(cpi->target_level));

  if (cm->profile <= PROFILE_1)
    assert(cm->bit_depth == VPX_BITS_8);
  else
    assert(cm->bit_depth > VPX_BITS_8);

  cpi->oxcf = *oxcf;
#if CONFIG_VP9_HIGHBITDEPTH
  cpi->td.mb.e_mbd.bd = (int)cm->bit_depth;
#endif  // CONFIG_VP9_HIGHBITDEPTH

  if ((oxcf->pass == 0) && (oxcf->rc_mode == VPX_Q)) {
    rc->baseline_gf_interval = FIXED_GF_INTERVAL;
  } else {
    rc->baseline_gf_interval = (MIN_GF_INTERVAL + MAX_GF_INTERVAL) / 2;
  }

  cpi->refresh_golden_frame = 0;
  cpi->refresh_last_frame = 1;
  cm->refresh_frame_context = 1;
  cm->reset_frame_context = 0;

  vp9_reset_segment_features(&cm->seg);
  vp9_set_high_precision_mv(cpi, 0);

  {
    int i;

    for (i = 0; i < MAX_SEGMENTS; i++)
      cpi->segment_encode_breakout[i] = cpi->oxcf.encode_breakout;
  }
  cpi->encode_breakout = cpi->oxcf.encode_breakout;

  vp9_set_rc_buffer_sizes(cpi);

  // Set up frame rate and related parameters rate control values.
  vp9_new_framerate(cpi, cpi->framerate);

  // Set absolute upper and lower quality limits
  rc->worst_quality = cpi->oxcf.worst_allowed_q;
  rc->best_quality = cpi->oxcf.best_allowed_q;

  cm->interp_filter = cpi->sf.default_interp_filter;

  if (cpi->oxcf.render_width > 0 && cpi->oxcf.render_height > 0) {
    cm->render_width = cpi->oxcf.render_width;
    cm->render_height = cpi->oxcf.render_height;
  } else {
    cm->render_width = cpi->oxcf.width;
    cm->render_height = cpi->oxcf.height;
  }
  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {
    cm->width = cpi->oxcf.width;
    cm->height = cpi->oxcf.height;
    cpi->external_resize = 1;
  }

  if (cpi->initial_width) {
    int new_mi_size = 0;
    vp9_set_mb_mi(cm, cm->width, cm->height);
    new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);
    if (cm->mi_alloc_size < new_mi_size) {
      vp9_free_context_buffers(cm);
      vp9_free_pc_tree(&cpi->td);
      vpx_free(cpi->mbmi_ext_base);
      alloc_compressor_data(cpi);
      realloc_segmentation_maps(cpi);
      cpi->initial_width = cpi->initial_height = 0;
      cpi->external_resize = 0;
    } else if (cm->mi_alloc_size == new_mi_size &&
               (cpi->oxcf.width > last_w || cpi->oxcf.height > last_h)) {
      if (vp9_alloc_loop_filter(cm)) {
        vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,
                           ""Failed to allocate loop filter data"");
      }
    }
  }

  if (cm->current_video_frame == 0 || last_w != cpi->oxcf.width ||
      last_h != cpi->oxcf.height)
    update_frame_size(cpi);

  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {
    vpx_free(cpi->consec_zero_mv);
    CHECK_MEM_ERROR(
        &cm->error, cpi->consec_zero_mv,
        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(*cpi->consec_zero_mv)));

    vpx_free(cpi->skin_map);
    CHECK_MEM_ERROR(
        &cm->error, cpi->skin_map,
        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(cpi->skin_map[0])));

    free_copy_partition_data(cpi);
    alloc_copy_partition_data(cpi);
    if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)
      vp9_cyclic_refresh_reset_resize(cpi);
    rc->rc_1_frame = 0;
    rc->rc_2_frame = 0;
  }

  if ((cpi->svc.number_temporal_layers > 1) ||
      ((cpi->svc.number_temporal_layers > 1 ||
        cpi->svc.number_spatial_layers > 1) &&
       cpi->oxcf.pass != 1)) {
    vp9_update_layer_context_change_config(cpi,
                                           (int)cpi->oxcf.target_bandwidth);
  }

  vp9_check_reset_rc_flag(cpi);

  cpi->alt_ref_source = NULL;
  rc->is_src_frame_alt_ref = 0;

#if 0
  // Experimental RD Code
  cpi->frame_distortion = 0;
  cpi->last_frame_distortion = 0;
#endif

  set_tile_limits(cpi);

  cpi->ext_refresh_frame_flags_pending = 0;
  cpi->ext_refresh_frame_context_pending = 0;

#if CONFIG_VP9_HIGHBITDEPTH
  highbd_set_var_fns(cpi);
#endif

  vp9_set_row_mt(cpi);
}","void vp9_change_config(struct VP9_COMP *VAR_0, const VP9EncoderConfig *VAR_1) {
  VP9_COMMON *const VAR_2 = &VAR_0->common;
  RATE_CONTROL *const VAR_3 = &VAR_0->rc;
  int VAR_4 = VAR_0->oxcf.width;
  int VAR_5 = VAR_0->oxcf.height;

  vp9_init_quantizer(VAR_0);
  if (VAR_2->profile != VAR_1->profile) VAR_2->profile = VAR_1->profile;
  VAR_2->bit_depth = VAR_1->bit_depth;
  VAR_2->color_space = VAR_1->color_space;
  VAR_2->color_range = VAR_1->color_range;

  VAR_0->target_level = VAR_1->target_level;
  VAR_0->keep_level_stats = VAR_1->target_level != VAR_6;
  set_level_constraint(&VAR_0->level_constraint,
                       get_level_index(VAR_0->target_level));

  if (VAR_2->profile <= VAR_7)
    assert(VAR_2->bit_depth == VAR_8);
  else
    assert(VAR_2->bit_depth > VAR_8);

  VAR_0->oxcf = *VAR_1;
#if VAR_9
  VAR_0->td.mb.e_mbd.bd = (int)VAR_2->bit_depth;
#endif  /* COMMENT_0 */

  if ((VAR_1->pass == 0) && (VAR_1->rc_mode == VAR_10)) {
    VAR_3->baseline_gf_interval = VAR_11;
  } else {
    VAR_3->baseline_gf_interval = (VAR_12 + VAR_13) / 2;
  }

  VAR_0->refresh_golden_frame = 0;
  VAR_0->refresh_last_frame = 1;
  VAR_2->refresh_frame_context = 1;
  VAR_2->reset_frame_context = 0;

  vp9_reset_segment_features(&VAR_2->seg);
  vp9_set_high_precision_mv(VAR_0, 0);

  {
    int VAR_14;

    for (VAR_14 = 0; VAR_14 < VAR_15; VAR_14++)
      VAR_0->segment_encode_breakout[VAR_14] = VAR_0->oxcf.encode_breakout;
  }
  VAR_0->encode_breakout = VAR_0->oxcf.encode_breakout;

  vp9_set_rc_buffer_sizes(VAR_0);

  /* COMMENT_1 */
  vp9_new_framerate(VAR_0, VAR_0->framerate);

  /* COMMENT_2 */
  VAR_3->worst_quality = VAR_0->oxcf.worst_allowed_q;
  VAR_3->best_quality = VAR_0->oxcf.best_allowed_q;

  VAR_2->interp_filter = VAR_0->sf.default_interp_filter;

  if (VAR_0->oxcf.render_width > 0 && VAR_0->oxcf.render_height > 0) {
    VAR_2->render_width = VAR_0->oxcf.render_width;
    VAR_2->render_height = VAR_0->oxcf.render_height;
  } else {
    VAR_2->render_width = VAR_0->oxcf.width;
    VAR_2->render_height = VAR_0->oxcf.height;
  }
  if (VAR_4 != VAR_0->oxcf.width || VAR_5 != VAR_0->oxcf.height) {
    VAR_2->width = VAR_0->oxcf.width;
    VAR_2->height = VAR_0->oxcf.height;
    VAR_0->external_resize = 1;
  }

  if (VAR_0->initial_width) {
    int VAR_16 = 0;
    vp9_set_mb_mi(VAR_2, VAR_2->width, VAR_2->height);
    VAR_16 = VAR_2->mi_stride * calc_mi_size(VAR_2->mi_rows);
    if (VAR_2->mi_alloc_size < VAR_16) {
      vp9_free_context_buffers(VAR_2);
      vp9_free_pc_tree(&VAR_0->td);
      vpx_free(VAR_0->mbmi_ext_base);
      alloc_compressor_data(VAR_0);
      realloc_segmentation_maps(VAR_0);
      VAR_0->initial_width = VAR_0->initial_height = 0;
      VAR_0->external_resize = 0;
    } else if (VAR_2->mi_alloc_size == VAR_16 &&
               (VAR_0->oxcf.width > VAR_4 || VAR_0->oxcf.height > VAR_5)) {
      if (vp9_alloc_loop_filter(VAR_2)) {
        vpx_internal_error(&VAR_2->error, VAR_17,
                           ""Failed to allocate loop filter data"");
      }
    }
  }

  if (VAR_2->current_video_frame == 0 || VAR_4 != VAR_0->oxcf.width ||
      VAR_5 != VAR_0->oxcf.height)
    update_frame_size(VAR_0);

  if (VAR_4 != VAR_0->oxcf.width || VAR_5 != VAR_0->oxcf.height) {
    vpx_free(VAR_0->consec_zero_mv);
    CHECK_MEM_ERROR(
        &VAR_2->error, VAR_0->consec_zero_mv,
        vpx_calloc(VAR_2->mi_rows * VAR_2->mi_cols, sizeof(*VAR_0->consec_zero_mv)));

    vpx_free(VAR_0->skin_map);
    CHECK_MEM_ERROR(
        &VAR_2->error, VAR_0->skin_map,
        vpx_calloc(VAR_2->mi_rows * VAR_2->mi_cols, sizeof(VAR_0->skin_map[0])));

    free_copy_partition_data(VAR_0);
    alloc_copy_partition_data(VAR_0);
    if (VAR_0->oxcf.aq_mode == VAR_18)
      vp9_cyclic_refresh_reset_resize(VAR_0);
    VAR_3->rc_1_frame = 0;
    VAR_3->rc_2_frame = 0;
  }

  if ((VAR_0->svc.number_temporal_layers > 1) ||
      ((VAR_0->svc.number_temporal_layers > 1 ||
        VAR_0->svc.number_spatial_layers > 1) &&
       VAR_0->oxcf.pass != 1)) {
    vp9_update_layer_context_change_config(VAR_0,
                                           (int)VAR_0->oxcf.target_bandwidth);
  }

  vp9_check_reset_rc_flag(VAR_0);

  VAR_0->alt_ref_source = NULL;
  VAR_3->is_src_frame_alt_ref = 0;

#if 0
  /* COMMENT_3 */
  VAR_0->frame_distortion = 0;
  VAR_0->last_frame_distortion = 0;
#endif

  set_tile_limits(VAR_0);

  VAR_0->ext_refresh_frame_flags_pending = 0;
  VAR_0->ext_refresh_frame_context_pending = 0;

#if VAR_9
  highbd_set_var_fns(VAR_0);
#endif

  vp9_set_row_mt(VAR_0);
}",webmproject/libvpx/263682c9a29395055f3b3afe2d97be1828a6223f/vp9_encoder.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -77,6 +77,8 @@
     new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);
     if (cm->mi_alloc_size < new_mi_size) {
       vp9_free_context_buffers(cm);
+      vp9_free_pc_tree(&cpi->td);
+      vpx_free(cpi->mbmi_ext_base);
       alloc_compressor_data(cpi);
       realloc_segmentation_maps(cpi);
       cpi->initial_width = cpi->initial_height = 0;
@@ -95,8 +97,18 @@
     update_frame_size(cpi);
 
   if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {
-    memset(cpi->consec_zero_mv, 0,
-           cm->mi_rows * cm->mi_cols * sizeof(*cpi->consec_zero_mv));
+    vpx_free(cpi->consec_zero_mv);
+    CHECK_MEM_ERROR(
+        &cm->error, cpi->consec_zero_mv,
+        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(*cpi->consec_zero_mv)));
+
+    vpx_free(cpi->skin_map);
+    CHECK_MEM_ERROR(
+        &cm->error, cpi->skin_map,
+        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(cpi->skin_map[0])));
+
+    free_copy_partition_data(cpi);
+    alloc_copy_partition_data(cpi);
     if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)
       vp9_cyclic_refresh_reset_resize(cpi);
     rc->rc_1_frame = 0;","{'deleted_lines': ['    memset(cpi->consec_zero_mv, 0,', '           cm->mi_rows * cm->mi_cols * sizeof(*cpi->consec_zero_mv));'], 'added_lines': ['      vp9_free_pc_tree(&cpi->td);', '      vpx_free(cpi->mbmi_ext_base);', '    vpx_free(cpi->consec_zero_mv);', '    CHECK_MEM_ERROR(', '        &cm->error, cpi->consec_zero_mv,', '        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(*cpi->consec_zero_mv)));', '', '    vpx_free(cpi->skin_map);', '    CHECK_MEM_ERROR(', '        &cm->error, cpi->skin_map,', '        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(cpi->skin_map[0])));', '', '    free_copy_partition_data(cpi);', '    alloc_copy_partition_data(cpi);']}",True,"VP9 in libvpx before 1.13.1 mishandles widths, leading to a crash related to encoding.",7.5,HIGH,2,test,2022-06-30T17:48:56Z,4
CVE-2023-44488,['CWE-755'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,webmproject/libvpx,"Fix bug with smaller width bigger size

Fixed previous patch that clusterfuzz failed on.

Local fuzzing passing overnight.

Bug: webm:1642
Change-Id: If0e08e72abd2e042efe4dcfac21e4cc51afdfdb9
(cherry picked from commit 263682c9a29395055f3b3afe2d97be1828a6223f)",df9fd9d5b7325060b2b921558a1eb20ca7880937,https://github.com/webmproject/libvpx/commit/df9fd9d5b7325060b2b921558a1eb20ca7880937,vp9/encoder/vp9_encoder.c,vp9_change_config,"void vp9_change_config(struct VP9_COMP *cpi, const VP9EncoderConfig *oxcf) {
VP9_COMMON *const cm = &cpi->common;
RATE_CONTROL *const rc = &cpi->rc;
int last_w = cpi->oxcf.width;
int last_h = cpi->oxcf.height;
vp9_init_quantizer(cpi);
if (cm->profile != oxcf->profile) cm->profile = oxcf->profile;
cm->bit_depth = oxcf->bit_depth;
cm->color_space = oxcf->color_space;
cm->color_range = oxcf->color_range;
cpi->target_level = oxcf->target_level;
cpi->keep_level_stats = oxcf->target_level != LEVEL_MAX;
set_level_constraint(&cpi->level_constraint,
get_level_index(cpi->target_level));
if (cm->profile <= PROFILE_1)
assert(cm->bit_depth == VPX_BITS_8);
else
assert(cm->bit_depth > VPX_BITS_8);
cpi->oxcf = *oxcf;
#if CONFIG_VP9_HIGHBITDEPTH
cpi->td.mb.e_mbd.bd = (int)cm->bit_depth;
#endif  
if ((oxcf->pass == 0) && (oxcf->rc_mode == VPX_Q)) {
rc->baseline_gf_interval = FIXED_GF_INTERVAL;
} else {
rc->baseline_gf_interval = (MIN_GF_INTERVAL + MAX_GF_INTERVAL) / 2;
}
cpi->refresh_golden_frame = 0;
cpi->refresh_last_frame = 1;
cm->refresh_frame_context = 1;
cm->reset_frame_context = 0;
vp9_reset_segment_features(&cm->seg);
vp9_set_high_precision_mv(cpi, 0);
{
int i;
for (i = 0; i < MAX_SEGMENTS; i++)
cpi->segment_encode_breakout[i] = cpi->oxcf.encode_breakout;
}
cpi->encode_breakout = cpi->oxcf.encode_breakout;
vp9_set_rc_buffer_sizes(cpi);
vp9_new_framerate(cpi, cpi->framerate);
rc->worst_quality = cpi->oxcf.worst_allowed_q;
rc->best_quality = cpi->oxcf.best_allowed_q;
cm->interp_filter = cpi->sf.default_interp_filter;
if (cpi->oxcf.render_width > 0 && cpi->oxcf.render_height > 0) {
cm->render_width = cpi->oxcf.render_width;
cm->render_height = cpi->oxcf.render_height;
} else {
cm->render_width = cpi->oxcf.width;
cm->render_height = cpi->oxcf.height;
}
if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {
cm->width = cpi->oxcf.width;
cm->height = cpi->oxcf.height;
cpi->external_resize = 1;
}
if (cpi->initial_width) {
int new_mi_size = 0;
vp9_set_mb_mi(cm, cm->width, cm->height);
new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);
if (cm->mi_alloc_size < new_mi_size) {
vp9_free_context_buffers(cm);
alloc_compressor_data(cpi);
realloc_segmentation_maps(cpi);
cpi->initial_width = cpi->initial_height = 0;
cpi->external_resize = 0;
} else if (cm->mi_alloc_size == new_mi_size &&
(cpi->oxcf.width > last_w || cpi->oxcf.height > last_h)) {
if (vp9_alloc_loop_filter(cm)) {
vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,
""Failed to allocate loop filter data"");
}
}
}
if (cm->current_video_frame == 0 || last_w != cpi->oxcf.width ||
last_h != cpi->oxcf.height)
update_frame_size(cpi);
if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {
memset(cpi->consec_zero_mv, 0,
cm->mi_rows * cm->mi_cols * sizeof(*cpi->consec_zero_mv));
if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)
vp9_cyclic_refresh_reset_resize(cpi);
rc->rc_1_frame = 0;
rc->rc_2_frame = 0;
}
if ((cpi->svc.number_temporal_layers > 1) ||
((cpi->svc.number_temporal_layers > 1 ||
cpi->svc.number_spatial_layers > 1) &&
cpi->oxcf.pass != 1)) {
vp9_update_layer_context_change_config(cpi,
(int)cpi->oxcf.target_bandwidth);
}
vp9_check_reset_rc_flag(cpi);
cpi->alt_ref_source = NULL;
rc->is_src_frame_alt_ref = 0;
#if 0
cpi->frame_distortion = 0;
cpi->last_frame_distortion = 0;
#endif
set_tile_limits(cpi);
cpi->ext_refresh_frame_flags_pending = 0;
cpi->ext_refresh_frame_context_pending = 0;
#if CONFIG_VP9_HIGHBITDEPTH
highbd_set_var_fns(cpi);
#endif
vp9_set_row_mt(cpi);
}","void vp9_change_config(struct VP9_COMP *VAR_0, const VP9EncoderConfig *VAR_1) {
VP9_COMMON *const VAR_2 = &VAR_0->common;
RATE_CONTROL *const VAR_3 = &VAR_0->rc;
int VAR_4 = VAR_0->oxcf.width;
int VAR_5 = VAR_0->oxcf.height;
vp9_init_quantizer(VAR_0);
if (VAR_2->profile != VAR_1->profile) VAR_2->profile = VAR_1->profile;
VAR_2->bit_depth = VAR_1->bit_depth;
VAR_2->color_space = VAR_1->color_space;
VAR_2->color_range = VAR_1->color_range;
VAR_0->target_level = VAR_1->target_level;
VAR_0->keep_level_stats = VAR_1->target_level != VAR_6;
set_level_constraint(&VAR_0->level_constraint,
get_level_index(VAR_0->target_level));
if (VAR_2->profile <= VAR_7)
assert(VAR_2->bit_depth == VAR_8);
else
assert(VAR_2->bit_depth > VAR_8);
VAR_0->oxcf = *VAR_1;
#if VAR_9
VAR_0->td.mb.e_mbd.bd = (int)VAR_2->bit_depth;
#endif  
if ((VAR_1->pass == 0) && (VAR_1->rc_mode == VAR_10)) {
VAR_3->baseline_gf_interval = VAR_11;
} else {
VAR_3->baseline_gf_interval = (VAR_12 + VAR_13) / 2;
}
VAR_0->refresh_golden_frame = 0;
VAR_0->refresh_last_frame = 1;
VAR_2->refresh_frame_context = 1;
VAR_2->reset_frame_context = 0;
vp9_reset_segment_features(&VAR_2->seg);
vp9_set_high_precision_mv(VAR_0, 0);
{
int VAR_14;
for (VAR_14 = 0; VAR_14 < VAR_15; VAR_14++)
VAR_0->segment_encode_breakout[VAR_14] = VAR_0->oxcf.encode_breakout;
}
VAR_0->encode_breakout = VAR_0->oxcf.encode_breakout;
vp9_set_rc_buffer_sizes(VAR_0);
vp9_new_framerate(VAR_0, VAR_0->framerate);
VAR_3->worst_quality = VAR_0->oxcf.worst_allowed_q;
VAR_3->best_quality = VAR_0->oxcf.best_allowed_q;
VAR_2->interp_filter = VAR_0->sf.default_interp_filter;
if (VAR_0->oxcf.render_width > 0 && VAR_0->oxcf.render_height > 0) {
VAR_2->render_width = VAR_0->oxcf.render_width;
VAR_2->render_height = VAR_0->oxcf.render_height;
} else {
VAR_2->render_width = VAR_0->oxcf.width;
VAR_2->render_height = VAR_0->oxcf.height;
}
if (VAR_4 != VAR_0->oxcf.width || VAR_5 != VAR_0->oxcf.height) {
VAR_2->width = VAR_0->oxcf.width;
VAR_2->height = VAR_0->oxcf.height;
VAR_0->external_resize = 1;
}
if (VAR_0->initial_width) {
int VAR_16 = 0;
vp9_set_mb_mi(VAR_2, VAR_2->width, VAR_2->height);
VAR_16 = VAR_2->mi_stride * calc_mi_size(VAR_2->mi_rows);
if (VAR_2->mi_alloc_size < VAR_16) {
vp9_free_context_buffers(VAR_2);
alloc_compressor_data(VAR_0);
realloc_segmentation_maps(VAR_0);
VAR_0->initial_width = VAR_0->initial_height = 0;
VAR_0->external_resize = 0;
} else if (VAR_2->mi_alloc_size == VAR_16 &&
(VAR_0->oxcf.width > VAR_4 || VAR_0->oxcf.height > VAR_5)) {
if (vp9_alloc_loop_filter(VAR_2)) {
vpx_internal_error(&VAR_2->error, VAR_17,
""Failed to allocate loop filter data"");
}
}
}
if (VAR_2->current_video_frame == 0 || VAR_4 != VAR_0->oxcf.width ||
VAR_5 != VAR_0->oxcf.height)
update_frame_size(VAR_0);
if (VAR_4 != VAR_0->oxcf.width || VAR_5 != VAR_0->oxcf.height) {
memset(VAR_0->consec_zero_mv, 0,
VAR_2->mi_rows * VAR_2->mi_cols * sizeof(*VAR_0->consec_zero_mv));
if (VAR_0->oxcf.aq_mode == VAR_18)
vp9_cyclic_refresh_reset_resize(VAR_0);
VAR_3->rc_1_frame = 0;
VAR_3->rc_2_frame = 0;
}
if ((VAR_0->svc.number_temporal_layers > 1) ||
((VAR_0->svc.number_temporal_layers > 1 ||
VAR_0->svc.number_spatial_layers > 1) &&
VAR_0->oxcf.pass != 1)) {
vp9_update_layer_context_change_config(VAR_0,
(int)VAR_0->oxcf.target_bandwidth);
}
vp9_check_reset_rc_flag(VAR_0);
VAR_0->alt_ref_source = NULL;
VAR_3->is_src_frame_alt_ref = 0;
#if 0
VAR_0->frame_distortion = 0;
VAR_0->last_frame_distortion = 0;
#endif
set_tile_limits(VAR_0);
VAR_0->ext_refresh_frame_flags_pending = 0;
VAR_0->ext_refresh_frame_context_pending = 0;
#if VAR_9
highbd_set_var_fns(VAR_0);
#endif
vp9_set_row_mt(VAR_0);
}",webmproject/libvpx/df9fd9d5b7325060b2b921558a1eb20ca7880937/vp9_encoder.c/vul/before/0.json,"void vp9_change_config(struct VP9_COMP *cpi, const VP9EncoderConfig *oxcf) {
  VP9_COMMON *const cm = &cpi->common;
  RATE_CONTROL *const rc = &cpi->rc;
  int last_w = cpi->oxcf.width;
  int last_h = cpi->oxcf.height;

  vp9_init_quantizer(cpi);
  if (cm->profile != oxcf->profile) cm->profile = oxcf->profile;
  cm->bit_depth = oxcf->bit_depth;
  cm->color_space = oxcf->color_space;
  cm->color_range = oxcf->color_range;

  cpi->target_level = oxcf->target_level;
  cpi->keep_level_stats = oxcf->target_level != LEVEL_MAX;
  set_level_constraint(&cpi->level_constraint,
                       get_level_index(cpi->target_level));

  if (cm->profile <= PROFILE_1)
    assert(cm->bit_depth == VPX_BITS_8);
  else
    assert(cm->bit_depth > VPX_BITS_8);

  cpi->oxcf = *oxcf;
#if CONFIG_VP9_HIGHBITDEPTH
  cpi->td.mb.e_mbd.bd = (int)cm->bit_depth;
#endif  // CONFIG_VP9_HIGHBITDEPTH

  if ((oxcf->pass == 0) && (oxcf->rc_mode == VPX_Q)) {
    rc->baseline_gf_interval = FIXED_GF_INTERVAL;
  } else {
    rc->baseline_gf_interval = (MIN_GF_INTERVAL + MAX_GF_INTERVAL) / 2;
  }

  cpi->refresh_golden_frame = 0;
  cpi->refresh_last_frame = 1;
  cm->refresh_frame_context = 1;
  cm->reset_frame_context = 0;

  vp9_reset_segment_features(&cm->seg);
  vp9_set_high_precision_mv(cpi, 0);

  {
    int i;

    for (i = 0; i < MAX_SEGMENTS; i++)
      cpi->segment_encode_breakout[i] = cpi->oxcf.encode_breakout;
  }
  cpi->encode_breakout = cpi->oxcf.encode_breakout;

  vp9_set_rc_buffer_sizes(cpi);

  // Set up frame rate and related parameters rate control values.
  vp9_new_framerate(cpi, cpi->framerate);

  // Set absolute upper and lower quality limits
  rc->worst_quality = cpi->oxcf.worst_allowed_q;
  rc->best_quality = cpi->oxcf.best_allowed_q;

  cm->interp_filter = cpi->sf.default_interp_filter;

  if (cpi->oxcf.render_width > 0 && cpi->oxcf.render_height > 0) {
    cm->render_width = cpi->oxcf.render_width;
    cm->render_height = cpi->oxcf.render_height;
  } else {
    cm->render_width = cpi->oxcf.width;
    cm->render_height = cpi->oxcf.height;
  }
  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {
    cm->width = cpi->oxcf.width;
    cm->height = cpi->oxcf.height;
    cpi->external_resize = 1;
  }

  if (cpi->initial_width) {
    int new_mi_size = 0;
    vp9_set_mb_mi(cm, cm->width, cm->height);
    new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);
    if (cm->mi_alloc_size < new_mi_size) {
      vp9_free_context_buffers(cm);
      vp9_free_pc_tree(&cpi->td);
      vpx_free(cpi->mbmi_ext_base);
      alloc_compressor_data(cpi);
      realloc_segmentation_maps(cpi);
      cpi->initial_width = cpi->initial_height = 0;
      cpi->external_resize = 0;
    } else if (cm->mi_alloc_size == new_mi_size &&
               (cpi->oxcf.width > last_w || cpi->oxcf.height > last_h)) {
      if (vp9_alloc_loop_filter(cm)) {
        vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,
                           ""Failed to allocate loop filter data"");
      }
    }
  }

  if (cm->current_video_frame == 0 || last_w != cpi->oxcf.width ||
      last_h != cpi->oxcf.height)
    update_frame_size(cpi);

  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {
    vpx_free(cpi->consec_zero_mv);
    CHECK_MEM_ERROR(
        cm, cpi->consec_zero_mv,
        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(*cpi->consec_zero_mv)));

    vpx_free(cpi->skin_map);
    CHECK_MEM_ERROR(
        cm, cpi->skin_map,
        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(cpi->skin_map[0])));

    free_copy_partition_data(cpi);
    alloc_copy_partition_data(cpi);
    if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)
      vp9_cyclic_refresh_reset_resize(cpi);
    rc->rc_1_frame = 0;
    rc->rc_2_frame = 0;
  }

  if ((cpi->svc.number_temporal_layers > 1) ||
      ((cpi->svc.number_temporal_layers > 1 ||
        cpi->svc.number_spatial_layers > 1) &&
       cpi->oxcf.pass != 1)) {
    vp9_update_layer_context_change_config(cpi,
                                           (int)cpi->oxcf.target_bandwidth);
  }

  vp9_check_reset_rc_flag(cpi);

  cpi->alt_ref_source = NULL;
  rc->is_src_frame_alt_ref = 0;

#if 0
  // Experimental RD Code
  cpi->frame_distortion = 0;
  cpi->last_frame_distortion = 0;
#endif

  set_tile_limits(cpi);

  cpi->ext_refresh_frame_flags_pending = 0;
  cpi->ext_refresh_frame_context_pending = 0;

#if CONFIG_VP9_HIGHBITDEPTH
  highbd_set_var_fns(cpi);
#endif

  vp9_set_row_mt(cpi);
}","void vp9_change_config(struct VP9_COMP *VAR_0, const VP9EncoderConfig *VAR_1) {
  VP9_COMMON *const VAR_2 = &VAR_0->common;
  RATE_CONTROL *const VAR_3 = &VAR_0->rc;
  int VAR_4 = VAR_0->oxcf.width;
  int VAR_5 = VAR_0->oxcf.height;

  vp9_init_quantizer(VAR_0);
  if (VAR_2->profile != VAR_1->profile) VAR_2->profile = VAR_1->profile;
  VAR_2->bit_depth = VAR_1->bit_depth;
  VAR_2->color_space = VAR_1->color_space;
  VAR_2->color_range = VAR_1->color_range;

  VAR_0->target_level = VAR_1->target_level;
  VAR_0->keep_level_stats = VAR_1->target_level != VAR_6;
  set_level_constraint(&VAR_0->level_constraint,
                       get_level_index(VAR_0->target_level));

  if (VAR_2->profile <= VAR_7)
    assert(VAR_2->bit_depth == VAR_8);
  else
    assert(VAR_2->bit_depth > VAR_8);

  VAR_0->oxcf = *VAR_1;
#if VAR_9
  VAR_0->td.mb.e_mbd.bd = (int)VAR_2->bit_depth;
#endif  /* COMMENT_0 */

  if ((VAR_1->pass == 0) && (VAR_1->rc_mode == VAR_10)) {
    VAR_3->baseline_gf_interval = VAR_11;
  } else {
    VAR_3->baseline_gf_interval = (VAR_12 + VAR_13) / 2;
  }

  VAR_0->refresh_golden_frame = 0;
  VAR_0->refresh_last_frame = 1;
  VAR_2->refresh_frame_context = 1;
  VAR_2->reset_frame_context = 0;

  vp9_reset_segment_features(&VAR_2->seg);
  vp9_set_high_precision_mv(VAR_0, 0);

  {
    int VAR_14;

    for (VAR_14 = 0; VAR_14 < VAR_15; VAR_14++)
      VAR_0->segment_encode_breakout[VAR_14] = VAR_0->oxcf.encode_breakout;
  }
  VAR_0->encode_breakout = VAR_0->oxcf.encode_breakout;

  vp9_set_rc_buffer_sizes(VAR_0);

  /* COMMENT_1 */
  vp9_new_framerate(VAR_0, VAR_0->framerate);

  /* COMMENT_2 */
  VAR_3->worst_quality = VAR_0->oxcf.worst_allowed_q;
  VAR_3->best_quality = VAR_0->oxcf.best_allowed_q;

  VAR_2->interp_filter = VAR_0->sf.default_interp_filter;

  if (VAR_0->oxcf.render_width > 0 && VAR_0->oxcf.render_height > 0) {
    VAR_2->render_width = VAR_0->oxcf.render_width;
    VAR_2->render_height = VAR_0->oxcf.render_height;
  } else {
    VAR_2->render_width = VAR_0->oxcf.width;
    VAR_2->render_height = VAR_0->oxcf.height;
  }
  if (VAR_4 != VAR_0->oxcf.width || VAR_5 != VAR_0->oxcf.height) {
    VAR_2->width = VAR_0->oxcf.width;
    VAR_2->height = VAR_0->oxcf.height;
    VAR_0->external_resize = 1;
  }

  if (VAR_0->initial_width) {
    int VAR_16 = 0;
    vp9_set_mb_mi(VAR_2, VAR_2->width, VAR_2->height);
    VAR_16 = VAR_2->mi_stride * calc_mi_size(VAR_2->mi_rows);
    if (VAR_2->mi_alloc_size < VAR_16) {
      vp9_free_context_buffers(VAR_2);
      vp9_free_pc_tree(&VAR_0->td);
      vpx_free(VAR_0->mbmi_ext_base);
      alloc_compressor_data(VAR_0);
      realloc_segmentation_maps(VAR_0);
      VAR_0->initial_width = VAR_0->initial_height = 0;
      VAR_0->external_resize = 0;
    } else if (VAR_2->mi_alloc_size == VAR_16 &&
               (VAR_0->oxcf.width > VAR_4 || VAR_0->oxcf.height > VAR_5)) {
      if (vp9_alloc_loop_filter(VAR_2)) {
        vpx_internal_error(&VAR_2->error, VAR_17,
                           ""Failed to allocate loop filter data"");
      }
    }
  }

  if (VAR_2->current_video_frame == 0 || VAR_4 != VAR_0->oxcf.width ||
      VAR_5 != VAR_0->oxcf.height)
    update_frame_size(VAR_0);

  if (VAR_4 != VAR_0->oxcf.width || VAR_5 != VAR_0->oxcf.height) {
    vpx_free(VAR_0->consec_zero_mv);
    CHECK_MEM_ERROR(
        VAR_2, VAR_0->consec_zero_mv,
        vpx_calloc(VAR_2->mi_rows * VAR_2->mi_cols, sizeof(*VAR_0->consec_zero_mv)));

    vpx_free(VAR_0->skin_map);
    CHECK_MEM_ERROR(
        VAR_2, VAR_0->skin_map,
        vpx_calloc(VAR_2->mi_rows * VAR_2->mi_cols, sizeof(VAR_0->skin_map[0])));

    free_copy_partition_data(VAR_0);
    alloc_copy_partition_data(VAR_0);
    if (VAR_0->oxcf.aq_mode == VAR_18)
      vp9_cyclic_refresh_reset_resize(VAR_0);
    VAR_3->rc_1_frame = 0;
    VAR_3->rc_2_frame = 0;
  }

  if ((VAR_0->svc.number_temporal_layers > 1) ||
      ((VAR_0->svc.number_temporal_layers > 1 ||
        VAR_0->svc.number_spatial_layers > 1) &&
       VAR_0->oxcf.pass != 1)) {
    vp9_update_layer_context_change_config(VAR_0,
                                           (int)VAR_0->oxcf.target_bandwidth);
  }

  vp9_check_reset_rc_flag(VAR_0);

  VAR_0->alt_ref_source = NULL;
  VAR_3->is_src_frame_alt_ref = 0;

#if 0
  /* COMMENT_3 */
  VAR_0->frame_distortion = 0;
  VAR_0->last_frame_distortion = 0;
#endif

  set_tile_limits(VAR_0);

  VAR_0->ext_refresh_frame_flags_pending = 0;
  VAR_0->ext_refresh_frame_context_pending = 0;

#if VAR_9
  highbd_set_var_fns(VAR_0);
#endif

  vp9_set_row_mt(VAR_0);
}",webmproject/libvpx/df9fd9d5b7325060b2b921558a1eb20ca7880937/vp9_encoder.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -77,6 +77,8 @@
     new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);
     if (cm->mi_alloc_size < new_mi_size) {
       vp9_free_context_buffers(cm);
+      vp9_free_pc_tree(&cpi->td);
+      vpx_free(cpi->mbmi_ext_base);
       alloc_compressor_data(cpi);
       realloc_segmentation_maps(cpi);
       cpi->initial_width = cpi->initial_height = 0;
@@ -95,8 +97,18 @@
     update_frame_size(cpi);
 
   if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {
-    memset(cpi->consec_zero_mv, 0,
-           cm->mi_rows * cm->mi_cols * sizeof(*cpi->consec_zero_mv));
+    vpx_free(cpi->consec_zero_mv);
+    CHECK_MEM_ERROR(
+        cm, cpi->consec_zero_mv,
+        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(*cpi->consec_zero_mv)));
+
+    vpx_free(cpi->skin_map);
+    CHECK_MEM_ERROR(
+        cm, cpi->skin_map,
+        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(cpi->skin_map[0])));
+
+    free_copy_partition_data(cpi);
+    alloc_copy_partition_data(cpi);
     if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)
       vp9_cyclic_refresh_reset_resize(cpi);
     rc->rc_1_frame = 0;","{'deleted_lines': ['    memset(cpi->consec_zero_mv, 0,', '           cm->mi_rows * cm->mi_cols * sizeof(*cpi->consec_zero_mv));'], 'added_lines': ['      vp9_free_pc_tree(&cpi->td);', '      vpx_free(cpi->mbmi_ext_base);', '    vpx_free(cpi->consec_zero_mv);', '    CHECK_MEM_ERROR(', '        cm, cpi->consec_zero_mv,', '        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(*cpi->consec_zero_mv)));', '', '    vpx_free(cpi->skin_map);', '    CHECK_MEM_ERROR(', '        cm, cpi->skin_map,', '        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(cpi->skin_map[0])));', '', '    free_copy_partition_data(cpi);', '    alloc_copy_partition_data(cpi);']}",True,"VP9 in libvpx before 1.13.1 mishandles widths, leading to a crash related to encoding.",7.5,HIGH,2,test,2022-06-30T17:48:56Z,4
CVE-2023-44488,['CWE-755'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,webmproject/libvpx,"Fix bug with smaller width bigger size

Fixed previous patch that clusterfuzz failed on.

Bug: webm:1642
Change-Id: If0e08e72abd2e042efe4dcfac21e4cc51afdfdb9",263682c9a29395055f3b3afe2d97be1828a6223f,https://github.com/webmproject/libvpx/commit/263682c9a29395055f3b3afe2d97be1828a6223f,vp9/common/vp9_alloccommon.c,vp9_alloc_context_buffers,"int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {
int new_mi_size;
vp9_set_mb_mi(cm, width, height);
new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);
if (cm->mi_alloc_size < new_mi_size) {
cm->free_mi(cm);
if (cm->alloc_mi(cm, new_mi_size)) goto fail;
}
if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {
free_seg_map(cm);
if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;
}
if (cm->above_context_alloc_cols < cm->mi_cols) {
vpx_free(cm->above_context);
cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(
2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,
sizeof(*cm->above_context));
if (!cm->above_context) goto fail;
vpx_free(cm->above_seg_context);
cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(
mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));
if (!cm->above_seg_context) goto fail;
cm->above_context_alloc_cols = cm->mi_cols;
}
if (vp9_alloc_loop_filter(cm)) goto fail;
return 0;
fail:
vp9_set_mb_mi(cm, 0, 0);
vp9_free_context_buffers(cm);
return 1;
}","int vp9_alloc_context_buffers(VP9_COMMON *VAR_0, int VAR_1, int VAR_2) {
int VAR_3;
vp9_set_mb_mi(VAR_0, VAR_1, VAR_2);
VAR_3 = VAR_0->mi_stride * calc_mi_size(VAR_0->mi_rows);
if (VAR_0->mi_alloc_size < VAR_3) {
VAR_0->free_mi(VAR_0);
if (VAR_0->alloc_mi(VAR_0, VAR_3)) goto fail;
}
if (VAR_0->seg_map_alloc_size < VAR_0->mi_rows * VAR_0->mi_cols) {
free_seg_map(VAR_0);
if (alloc_seg_map(VAR_0, VAR_0->mi_rows * VAR_0->mi_cols)) goto fail;
}
if (VAR_0->above_context_alloc_cols < VAR_0->mi_cols) {
vpx_free(VAR_0->above_context);
VAR_0->above_context = (ENTROPY_CONTEXT *)vpx_calloc(
2 * mi_cols_aligned_to_sb(VAR_0->mi_cols) * VAR_4,
sizeof(*VAR_0->above_context));
if (!VAR_0->above_context) goto fail;
vpx_free(VAR_0->above_seg_context);
VAR_0->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(
mi_cols_aligned_to_sb(VAR_0->mi_cols), sizeof(*VAR_0->above_seg_context));
if (!VAR_0->above_seg_context) goto fail;
VAR_0->above_context_alloc_cols = VAR_0->mi_cols;
}
if (vp9_alloc_loop_filter(VAR_0)) goto fail;
return 0;
fail:
vp9_set_mb_mi(VAR_0, 0, 0);
vp9_free_context_buffers(VAR_0);
return 1;
}",webmproject/libvpx/263682c9a29395055f3b3afe2d97be1828a6223f/vp9_alloccommon.c/vul/before/0.json,"int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {
  int new_mi_size;

  vp9_set_mb_mi(cm, width, height);
  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);
  if (cm->mi_alloc_size < new_mi_size) {
    cm->free_mi(cm);
    if (cm->alloc_mi(cm, new_mi_size)) goto fail;
  }
  if (cm->above_context_alloc_cols < cm->mi_cols) {
    vpx_free(cm->above_context);
    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(
        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,
        sizeof(*cm->above_context));
    if (!cm->above_context) goto fail;

    vpx_free(cm->above_seg_context);
    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(
        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));
    if (!cm->above_seg_context) goto fail;
    cm->above_context_alloc_cols = cm->mi_cols;
  }

  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {
    // Create the segmentation map structure and set to 0.
    free_seg_map(cm);
    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;
  }

  if (vp9_alloc_loop_filter(cm)) goto fail;

  return 0;

fail:
  // clear the mi_* values to force a realloc on resync
  vp9_set_mb_mi(cm, 0, 0);
  vp9_free_context_buffers(cm);
  return 1;
}","int vp9_alloc_context_buffers(VP9_COMMON *VAR_0, int VAR_1, int VAR_2) {
  int VAR_3;

  vp9_set_mb_mi(VAR_0, VAR_1, VAR_2);
  VAR_3 = VAR_0->mi_stride * calc_mi_size(VAR_0->mi_rows);
  if (VAR_0->mi_alloc_size < VAR_3) {
    VAR_0->free_mi(VAR_0);
    if (VAR_0->alloc_mi(VAR_0, VAR_3)) goto fail;
  }
  if (VAR_0->above_context_alloc_cols < VAR_0->mi_cols) {
    vpx_free(VAR_0->above_context);
    VAR_0->above_context = (ENTROPY_CONTEXT *)vpx_calloc(
        2 * mi_cols_aligned_to_sb(VAR_0->mi_cols) * VAR_4,
        sizeof(*VAR_0->above_context));
    if (!VAR_0->above_context) goto fail;

    vpx_free(VAR_0->above_seg_context);
    VAR_0->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(
        mi_cols_aligned_to_sb(VAR_0->mi_cols), sizeof(*VAR_0->above_seg_context));
    if (!VAR_0->above_seg_context) goto fail;
    VAR_0->above_context_alloc_cols = VAR_0->mi_cols;
  }

  if (VAR_0->seg_map_alloc_size < VAR_0->mi_rows * VAR_0->mi_cols) {
    /* COMMENT_0 */
    free_seg_map(VAR_0);
    if (alloc_seg_map(VAR_0, VAR_0->mi_rows * VAR_0->mi_cols)) goto fail;
  }

  if (vp9_alloc_loop_filter(VAR_0)) goto fail;

  return 0;

fail:
  /* COMMENT_1 */
  vp9_set_mb_mi(VAR_0, 0, 0);
  vp9_free_context_buffers(VAR_0);
  return 1;
}",webmproject/libvpx/263682c9a29395055f3b3afe2d97be1828a6223f/vp9_alloccommon.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,13 +7,6 @@
     cm->free_mi(cm);
     if (cm->alloc_mi(cm, new_mi_size)) goto fail;
   }
-
-  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {
-    // Create the segmentation map structure and set to 0.
-    free_seg_map(cm);
-    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;
-  }
-
   if (cm->above_context_alloc_cols < cm->mi_cols) {
     vpx_free(cm->above_context);
     cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(
@@ -28,6 +21,12 @@
     cm->above_context_alloc_cols = cm->mi_cols;
   }
 
+  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {
+    // Create the segmentation map structure and set to 0.
+    free_seg_map(cm);
+    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;
+  }
+
   if (vp9_alloc_loop_filter(cm)) goto fail;
 
   return 0;","{'deleted_lines': ['', '  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {', '    // Create the segmentation map structure and set to 0.', '    free_seg_map(cm);', '    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;', '  }', ''], 'added_lines': ['  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {', '    // Create the segmentation map structure and set to 0.', '    free_seg_map(cm);', '    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;', '  }', '']}",True,"VP9 in libvpx before 1.13.1 mishandles widths, leading to a crash related to encoding.",7.5,HIGH,2,test,2022-06-30T17:48:56Z,4
CVE-2022-2288,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,vim,"patch 9.0.0025: accessing beyond allocated memory with the cmdline window

Problem:    Accessing beyond allocated memory when using the cmdline window in
            Ex mode.
Solution:   Use ""*"" instead of ""'<,'>"" for Visual mode.",c6fdb15d423df22e1776844811d082322475e48a,https://github.com/vim/vim/commit/c6fdb15d423df22e1776844811d082322475e48a,src/ex_docmd.c,parse_command_modifiers,"int
parse_command_modifiers(
exarg_T    *eap,
char    **errormsg,
cmdmod_T    *cmod,
int    skip_only)
{
char_u  *orig_cmd = eap->cmd;
char_u  *cmd_start = NULL;
int    use_plus_cmd = FALSE;
int    starts_with_colon = FALSE;
int    vim9script = in_vim9script();
int    has_visual_range = FALSE;
CLEAR_POINTER(cmod);
cmod->cmod_flags = sticky_cmdmod_flags;
if (STRNCMP(eap->cmd, ""'<,'>"", 5) == 0)
{
eap->cmd += 5;
cmd_start = eap->cmd;
has_visual_range = TRUE;
}
for (;;)
{
char_u  *p;
while (*eap->cmd == ' ' || *eap->cmd == '\t' || *eap->cmd == ':')
{
if (*eap->cmd == ':')
starts_with_colon = TRUE;
++eap->cmd;
}
if (*eap->cmd == NUL && exmode_active
&& (getline_equal(eap->getline, eap->cookie, getexmodeline)
|| getline_equal(eap->getline, eap->cookie, getexline))
&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)
{
use_plus_cmd = TRUE;
if (!skip_only)
ex_pressedreturn = TRUE;
break;  }
if (comment_start(eap->cmd, starts_with_colon))
{
if (eap->nextcmd == NULL)
{
eap->nextcmd = vim_strchr(eap->cmd, '\n');
if (eap->nextcmd != NULL)
++eap->nextcmd;
}
if (vim9script && has_cmdmod(cmod, FALSE))
*errormsg = _(e_command_modifier_without_command);
return FAIL;
}
if (*eap->cmd == NUL)
{
if (!skip_only)
{
ex_pressedreturn = TRUE;
if (vim9script && has_cmdmod(cmod, FALSE))
*errormsg = _(e_command_modifier_without_command);
}
return FAIL;
}
p = skip_range(eap->cmd, TRUE, NULL);
if (vim9script)
{
char_u *s, *n;
for (s = eap->cmd; ASCII_ISALPHA(*s); ++s)
;
n = skipwhite(s);
if (*n == '.' || *n == '=' || (*n != NUL && n[1] == '=')
|| *s == '[')
break;
}
switch (*p)
{
case 'a':if (!checkforcmd_noparen(&eap->cmd, ""aboveleft"", 3))
break;
cmod->cmod_split |= WSP_ABOVE;
continue;
case 'b':if (checkforcmd_noparen(&eap->cmd, ""belowright"", 3))
{
cmod->cmod_split |= WSP_BELOW;
continue;
}
if (checkforcmd_opt(&eap->cmd, ""browse"", 3, TRUE))
{
#ifdef FEAT_BROWSE_CMD
cmod->cmod_flags |= CMOD_BROWSE;
#endif
continue;
}
if (!checkforcmd_noparen(&eap->cmd, ""botright"", 2))
break;
cmod->cmod_split |= WSP_BOT;
continue;
case 'c':if (!checkforcmd_opt(&eap->cmd, ""confirm"", 4, TRUE))
break;
#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
cmod->cmod_flags |= CMOD_CONFIRM;
#endif
continue;
case 'k':if (checkforcmd_noparen(&eap->cmd, ""keepmarks"", 3))
{
cmod->cmod_flags |= CMOD_KEEPMARKS;
continue;
}
if (checkforcmd_noparen(&eap->cmd, ""keepalt"", 5))
{
cmod->cmod_flags |= CMOD_KEEPALT;
continue;
}
if (checkforcmd_noparen(&eap->cmd, ""keeppatterns"", 5))
{
cmod->cmod_flags |= CMOD_KEEPPATTERNS;
continue;
}
if (!checkforcmd_noparen(&eap->cmd, ""keepjumps"", 5))
break;
cmod->cmod_flags |= CMOD_KEEPJUMPS;
continue;
case 'f':{
char_u  *reg_pat;
char_u  *nulp = NULL;
int    c = 0;
if (!checkforcmd_noparen(&p, ""filter"", 4)
|| *p == NUL
|| (ends_excmd(*p)
#ifdef FEAT_EVAL
&& (!vim9script || VIM_ISWHITE(p[1]))
#endif
))
break;
if (*p == '!')
{
cmod->cmod_filter_force = TRUE;
p = skipwhite(p + 1);
if (*p == NUL || ends_excmd(*p))
break;
}
#ifdef FEAT_EVAL
if (vim9script && !VIM_ISWHITE(p[-1]))
break;
#endif
if (skip_only)
p = skip_vimgrep_pat(p, NULL, NULL);
else
p = skip_vimgrep_pat_ext(p, &reg_pat, NULL,
&nulp, &c);
if (p == NULL || *p == NUL)
break;
if (!skip_only)
{
cmod->cmod_filter_regmatch.regprog =
vim_regcomp(reg_pat, RE_MAGIC);
if (cmod->cmod_filter_regmatch.regprog == NULL)
break;
if (nulp != NULL)
*nulp = c;
}
eap->cmd = p;
continue;
}
case 'h':if (p != eap->cmd || !checkforcmd_noparen(&p, ""hide"", 3)
|| *p == NUL || ends_excmd(*p))
break;
eap->cmd = p;
cmod->cmod_flags |= CMOD_HIDE;
continue;
case 'l':if (checkforcmd_noparen(&eap->cmd, ""lockmarks"", 3))
{
cmod->cmod_flags |= CMOD_LOCKMARKS;
continue;
}
if (checkforcmd_noparen(&eap->cmd, ""legacy"", 3))
{
if (ends_excmd2(p, eap->cmd))
{
*errormsg =
_(e_legacy_must_be_followed_by_command);
return FAIL;
}
cmod->cmod_flags |= CMOD_LEGACY;
continue;
}
if (!checkforcmd_noparen(&eap->cmd, ""leftabove"", 5))
break;
cmod->cmod_split |= WSP_ABOVE;
continue;
case 'n':if (checkforcmd_noparen(&eap->cmd, ""noautocmd"", 3))
{
cmod->cmod_flags |= CMOD_NOAUTOCMD;
continue;
}
if (!checkforcmd_noparen(&eap->cmd, ""noswapfile"", 3))
break;
cmod->cmod_flags |= CMOD_NOSWAPFILE;
continue;
case 'r':if (!checkforcmd_noparen(&eap->cmd, ""rightbelow"", 6))
break;
cmod->cmod_split |= WSP_BELOW;
continue;
case 's':if (checkforcmd_noparen(&eap->cmd, ""sandbox"", 3))
{
cmod->cmod_flags |= CMOD_SANDBOX;
continue;
}
if (!checkforcmd_noparen(&eap->cmd, ""silent"", 3))
break;
cmod->cmod_flags |= CMOD_SILENT;
if (*eap->cmd == '!' && !VIM_ISWHITE(eap->cmd[-1]))
{
eap->cmd = skipwhite(eap->cmd + 1);
cmod->cmod_flags |= CMOD_ERRSILENT;
}
continue;
case 't':if (checkforcmd_noparen(&p, ""tab"", 3))
{
if (!skip_only)
{
long tabnr = get_address(eap, &eap->cmd,
ADDR_TABS, eap->skip,
skip_only, FALSE, 1);
if (tabnr == MAXLNUM)
cmod->cmod_tab = tabpage_index(curtab) + 1;
else
{
if (tabnr < 0 || tabnr > LAST_TAB_NR)
{
*errormsg = _(e_invalid_range);
return FAIL;
}
cmod->cmod_tab = tabnr + 1;
}
}
eap->cmd = p;
continue;
}
if (!checkforcmd_noparen(&eap->cmd, ""topleft"", 2))
break;
cmod->cmod_split |= WSP_TOP;
continue;
case 'u':if (!checkforcmd_noparen(&eap->cmd, ""unsilent"", 3))
break;
cmod->cmod_flags |= CMOD_UNSILENT;
continue;
case 'v':if (checkforcmd_noparen(&eap->cmd, ""vertical"", 4))
{
cmod->cmod_split |= WSP_VERT;
continue;
}
if (checkforcmd_noparen(&eap->cmd, ""vim9cmd"", 4))
{
if (ends_excmd2(p, eap->cmd))
{
*errormsg =
_(e_vim9cmd_must_be_followed_by_command);
return FAIL;
}
cmod->cmod_flags |= CMOD_VIM9CMD;
continue;
}
if (!checkforcmd_noparen(&p, ""verbose"", 4))
break;
if (vim_isdigit(*eap->cmd))
{
cmod->cmod_verbose = atoi((char *)eap->cmd) + 1;
}
else
cmod->cmod_verbose = 2;  eap->cmd = p;
continue;
}
break;
}
if (has_visual_range)
{
if (eap->cmd > cmd_start)
{
if (use_plus_cmd)
{
size_t len = STRLEN(cmd_start);
mch_memmove(orig_cmd, cmd_start, len);
STRCPY(orig_cmd + len, ""'<,'>+"");
}
else
{
mch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);
eap->cmd -= 5;
mch_memmove(eap->cmd - 1, "":'<,'>"", 6);
}
}
else
if (use_plus_cmd)
eap->cmd = (char_u *)""'<,'>+"";
else
eap->cmd = orig_cmd;
}
else if (use_plus_cmd)
eap->cmd = (char_u *)""+"";
return OK;
}","int
parse_command_modifiers(
exarg_T    *VAR_0,
char    **VAR_1,
cmdmod_T    *VAR_2,
int    VAR_3)
{
char_u  *VAR_4 = VAR_0->cmd;
char_u  *VAR_5 = NULL;
int    VAR_6 = FALSE;
int    VAR_7 = FALSE;
int    VAR_8 = in_vim9script();
int    VAR_9 = FALSE;
CLEAR_POINTER(VAR_2);
VAR_2->cmod_flags = VAR_10;
if (STRNCMP(VAR_0->cmd, ""'<,'>"", 5) == 0)
{
VAR_0->cmd += 5;
VAR_5 = VAR_0->cmd;
VAR_9 = TRUE;
}
for (;;)
{
char_u  *VAR_11;
while (*VAR_0->cmd == ' ' || *VAR_0->cmd == '\t' || *VAR_0->cmd == ':')
{
if (*VAR_0->cmd == ':')
VAR_7 = TRUE;
++VAR_0->cmd;
}
if (*VAR_0->cmd == VAR_12 && VAR_13
&& (getline_equal(VAR_0->getline, VAR_0->cookie, VAR_14)
|| getline_equal(VAR_0->getline, VAR_0->cookie, VAR_15))
&& VAR_16->w_cursor.lnum < VAR_17->b_ml.ml_line_count)
{
VAR_6 = TRUE;
if (!VAR_3)
VAR_18 = TRUE;
break;  
}
if (comment_start(VAR_0->cmd, VAR_7))
{
if (VAR_0->nextcmd == NULL)
{
VAR_0->nextcmd = vim_strchr(VAR_0->cmd, '\n');
if (VAR_0->nextcmd != NULL)
++VAR_0->nextcmd;
}
if (VAR_8 && has_cmdmod(VAR_2, FALSE))
*VAR_1 = _(VAR_19);
return VAR_20;
}
if (*VAR_0->cmd == VAR_12)
{
if (!VAR_3)
{
VAR_18 = TRUE;
if (VAR_8 && has_cmdmod(VAR_2, FALSE))
*VAR_1 = _(VAR_19);
}
return VAR_20;
}
VAR_11 = skip_range(VAR_0->cmd, TRUE, NULL);
if (VAR_8)
{
char_u *VAR_21, *VAR_22;
for (VAR_21 = VAR_0->cmd; ASCII_ISALPHA(*VAR_21); ++VAR_21)
;
VAR_22 = skipwhite(VAR_21);
if (*VAR_22 == '.' || *VAR_22 == '=' || (*VAR_22 != VAR_12 && VAR_22[1] == '=')
|| *VAR_21 == '[')
break;
}
switch (*VAR_11)
{
case 'a':if (!checkforcmd_noparen(&VAR_0->cmd, ""aboveleft"", 3))
break;
VAR_2->cmod_split |= VAR_23;
continue;
case 'b':if (checkforcmd_noparen(&VAR_0->cmd, ""belowright"", 3))
{
VAR_2->cmod_split |= VAR_24;
continue;
}
if (checkforcmd_opt(&VAR_0->cmd, ""browse"", 3, TRUE))
{
#ifdef VAR_25
VAR_2->cmod_flags |= VAR_26;
#endif
continue;
}
if (!checkforcmd_noparen(&VAR_0->cmd, ""botright"", 2))
break;
VAR_2->cmod_split |= VAR_27;
continue;
case 'c':if (!checkforcmd_opt(&VAR_0->cmd, ""confirm"", 4, TRUE))
break;
#if defined(VAR_28) || defined(VAR_29)
VAR_2->cmod_flags |= VAR_30;
#endif
continue;
case 'k':if (checkforcmd_noparen(&VAR_0->cmd, ""keepmarks"", 3))
{
VAR_2->cmod_flags |= VAR_31;
continue;
}
if (checkforcmd_noparen(&VAR_0->cmd, ""keepalt"", 5))
{
VAR_2->cmod_flags |= VAR_32;
continue;
}
if (checkforcmd_noparen(&VAR_0->cmd, ""keeppatterns"", 5))
{
VAR_2->cmod_flags |= VAR_33;
continue;
}
if (!checkforcmd_noparen(&VAR_0->cmd, ""keepjumps"", 5))
break;
VAR_2->cmod_flags |= VAR_34;
continue;
case 'f':
{
char_u  *VAR_35;
char_u  *VAR_36 = NULL;
int    VAR_37 = 0;
if (!checkforcmd_noparen(&VAR_11, ""filter"", 4)
|| *VAR_11 == VAR_12
|| (ends_excmd(*VAR_11)
#ifdef VAR_38
&& (!VAR_8 || VIM_ISWHITE(VAR_11[1]))
#endif
))
break;
if (*VAR_11 == '!')
{
VAR_2->cmod_filter_force = TRUE;
VAR_11 = skipwhite(VAR_11 + 1);
if (*VAR_11 == VAR_12 || ends_excmd(*VAR_11))
break;
}
#ifdef VAR_38
if (VAR_8 && !VIM_ISWHITE(VAR_11[-1]))
break;
#endif
if (VAR_3)
VAR_11 = skip_vimgrep_pat(VAR_11, NULL, NULL);
else
VAR_11 = skip_vimgrep_pat_ext(VAR_11, &VAR_35, NULL,
&VAR_36, &VAR_37);
if (VAR_11 == NULL || *VAR_11 == VAR_12)
break;
if (!VAR_3)
{
VAR_2->cmod_filter_regmatch.regprog =
vim_regcomp(VAR_35, VAR_39);
if (VAR_2->cmod_filter_regmatch.regprog == NULL)
break;
if (VAR_36 != NULL)
*VAR_36 = VAR_37;
}
VAR_0->cmd = VAR_11;
continue;
}
case 'h':if (VAR_11 != VAR_0->cmd || !checkforcmd_noparen(&VAR_11, ""hide"", 3)
|| *VAR_11 == VAR_12 || ends_excmd(*VAR_11))
break;
VAR_0->cmd = VAR_11;
VAR_2->cmod_flags |= VAR_40;
continue;
case 'l':if (checkforcmd_noparen(&VAR_0->cmd, ""lockmarks"", 3))
{
VAR_2->cmod_flags |= VAR_41;
continue;
}
if (checkforcmd_noparen(&VAR_0->cmd, ""legacy"", 3))
{
if (ends_excmd2(VAR_11, VAR_0->cmd))
{
*VAR_1 =
_(VAR_42);
return VAR_20;
}
VAR_2->cmod_flags |= VAR_43;
continue;
}
if (!checkforcmd_noparen(&VAR_0->cmd, ""leftabove"", 5))
break;
VAR_2->cmod_split |= VAR_23;
continue;
case 'n':if (checkforcmd_noparen(&VAR_0->cmd, ""noautocmd"", 3))
{
VAR_2->cmod_flags |= VAR_44;
continue;
}
if (!checkforcmd_noparen(&VAR_0->cmd, ""noswapfile"", 3))
break;
VAR_2->cmod_flags |= VAR_45;
continue;
case 'r':if (!checkforcmd_noparen(&VAR_0->cmd, ""rightbelow"", 6))
break;
VAR_2->cmod_split |= VAR_24;
continue;
case 's':if (checkforcmd_noparen(&VAR_0->cmd, ""sandbox"", 3))
{
VAR_2->cmod_flags |= VAR_46;
continue;
}
if (!checkforcmd_noparen(&VAR_0->cmd, ""silent"", 3))
break;
VAR_2->cmod_flags |= VAR_47;
if (*VAR_0->cmd == '!' && !VIM_ISWHITE(VAR_0->cmd[-1]))
{
VAR_0->cmd = skipwhite(VAR_0->cmd + 1);
VAR_2->cmod_flags |= VAR_48;
}
continue;
case 't':if (checkforcmd_noparen(&VAR_11, ""tab"", 3))
{
if (!VAR_3)
{
long VAR_49 = get_address(VAR_0, &VAR_0->cmd,
VAR_50, VAR_0->skip,
VAR_3, FALSE, 1);
if (VAR_49 == VAR_51)
VAR_2->cmod_tab = tabpage_index(VAR_52) + 1;
else
{
if (VAR_49 < 0 || VAR_49 > VAR_53)
{
*VAR_1 = _(VAR_54);
return VAR_20;
}
VAR_2->cmod_tab = VAR_49 + 1;
}
}
VAR_0->cmd = VAR_11;
continue;
}
if (!checkforcmd_noparen(&VAR_0->cmd, ""topleft"", 2))
break;
VAR_2->cmod_split |= VAR_55;
continue;
case 'u':if (!checkforcmd_noparen(&VAR_0->cmd, ""unsilent"", 3))
break;
VAR_2->cmod_flags |= VAR_56;
continue;
case 'v':if (checkforcmd_noparen(&VAR_0->cmd, ""vertical"", 4))
{
VAR_2->cmod_split |= VAR_57;
continue;
}
if (checkforcmd_noparen(&VAR_0->cmd, ""vim9cmd"", 4))
{
if (ends_excmd2(VAR_11, VAR_0->cmd))
{
*VAR_1 =
_(VAR_58);
return VAR_20;
}
VAR_2->cmod_flags |= VAR_59;
continue;
}
if (!checkforcmd_noparen(&VAR_11, ""verbose"", 4))
break;
if (vim_isdigit(*VAR_0->cmd))
{
VAR_2->cmod_verbose = atoi((char *)VAR_0->cmd) + 1;
}
else
VAR_2->cmod_verbose = 2;  
VAR_0->cmd = VAR_11;
continue;
}
break;
}
if (VAR_9)
{
if (VAR_0->cmd > VAR_5)
{
if (VAR_6)
{
size_t VAR_60 = STRLEN(VAR_5);
mch_memmove(VAR_4, VAR_5, VAR_60);
STRCPY(VAR_4 + VAR_60, ""'<,'>+"");
}
else
{
mch_memmove(VAR_5 - 5, VAR_5, VAR_0->cmd - VAR_5);
VAR_0->cmd -= 5;
mch_memmove(VAR_0->cmd - 1, "":'<,'>"", 6);
}
}
else
if (VAR_6)
VAR_0->cmd = (char_u *)""'<,'>+"";
else
VAR_0->cmd = VAR_4;
}
else if (VAR_6)
VAR_0->cmd = (char_u *)""+"";
return VAR_61;
}",vim/c6fdb15d423df22e1776844811d082322475e48a/ex_docmd.c/vul/before/0.json,"int
parse_command_modifiers(
	exarg_T	    *eap,
	char	    **errormsg,
	cmdmod_T    *cmod,
	int	    skip_only)
{
    char_u  *orig_cmd = eap->cmd;
    char_u  *cmd_start = NULL;
    int	    use_plus_cmd = FALSE;
    int	    starts_with_colon = FALSE;
    int	    vim9script = in_vim9script();
    int	    has_visual_range = FALSE;

    CLEAR_POINTER(cmod);
    cmod->cmod_flags = sticky_cmdmod_flags;

    if (STRNCMP(eap->cmd, ""'<,'>"", 5) == 0)
    {
	// The automatically inserted Visual area range is skipped, so that
	// typing "":cmdmod cmd"" in Visual mode works without having to move the
	// range to after the modififiers. The command will be
	// ""'<,'>cmdmod cmd"", parse ""cmdmod cmd"" and then put back ""'<,'>""
	// before ""cmd"" below.
	eap->cmd += 5;
	cmd_start = eap->cmd;
	has_visual_range = TRUE;
    }

    // Repeat until no more command modifiers are found.
    for (;;)
    {
	char_u  *p;

	while (*eap->cmd == ' ' || *eap->cmd == '\t' || *eap->cmd == ':')
	{
	    if (*eap->cmd == ':')
		starts_with_colon = TRUE;
	    ++eap->cmd;
	}

	// in ex mode, an empty command (after modifiers) works like :+
	if (*eap->cmd == NUL && exmode_active
		   && (getline_equal(eap->getline, eap->cookie, getexmodeline)
		       || getline_equal(eap->getline, eap->cookie, getexline))
			&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)
	{
	    use_plus_cmd = TRUE;
	    if (!skip_only)
		ex_pressedreturn = TRUE;
	    break;  // no modifiers following
	}

	// ignore comment and empty lines
	if (comment_start(eap->cmd, starts_with_colon))
	{
	    // a comment ends at a NL
	    if (eap->nextcmd == NULL)
	    {
		eap->nextcmd = vim_strchr(eap->cmd, '\n');
		if (eap->nextcmd != NULL)
		    ++eap->nextcmd;
	    }
	    if (vim9script && has_cmdmod(cmod, FALSE))
		*errormsg = _(e_command_modifier_without_command);
	    return FAIL;
	}
	if (*eap->cmd == NUL)
	{
	    if (!skip_only)
	    {
		ex_pressedreturn = TRUE;
		if (vim9script && has_cmdmod(cmod, FALSE))
		    *errormsg = _(e_command_modifier_without_command);
	    }
	    return FAIL;
	}

	p = skip_range(eap->cmd, TRUE, NULL);

	// In Vim9 script a variable can shadow a command modifier:
	//   verbose = 123
	//   verbose += 123
	//   silent! verbose = func()
	//   verbose.member = 2
	//   verbose[expr] = 2
	// But not:
	//   verbose [a, b] = list
	if (vim9script)
	{
	    char_u *s, *n;

	    for (s = eap->cmd; ASCII_ISALPHA(*s); ++s)
		;
	    n = skipwhite(s);
	    if (*n == '.' || *n == '=' || (*n != NUL && n[1] == '=')
		    || *s == '[')
		break;
	}

	switch (*p)
	{
	    // When adding an entry, also modify cmd_exists().
	    case 'a':	if (!checkforcmd_noparen(&eap->cmd, ""aboveleft"", 3))
			    break;
			cmod->cmod_split |= WSP_ABOVE;
			continue;

	    case 'b':	if (checkforcmd_noparen(&eap->cmd, ""belowright"", 3))
			{
			    cmod->cmod_split |= WSP_BELOW;
			    continue;
			}
			if (checkforcmd_opt(&eap->cmd, ""browse"", 3, TRUE))
			{
#ifdef FEAT_BROWSE_CMD
			    cmod->cmod_flags |= CMOD_BROWSE;
#endif
			    continue;
			}
			if (!checkforcmd_noparen(&eap->cmd, ""botright"", 2))
			    break;
			cmod->cmod_split |= WSP_BOT;
			continue;

	    case 'c':	if (!checkforcmd_opt(&eap->cmd, ""confirm"", 4, TRUE))
			    break;
#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
			cmod->cmod_flags |= CMOD_CONFIRM;
#endif
			continue;

	    case 'k':	if (checkforcmd_noparen(&eap->cmd, ""keepmarks"", 3))
			{
			    cmod->cmod_flags |= CMOD_KEEPMARKS;
			    continue;
			}
			if (checkforcmd_noparen(&eap->cmd, ""keepalt"", 5))
			{
			    cmod->cmod_flags |= CMOD_KEEPALT;
			    continue;
			}
			if (checkforcmd_noparen(&eap->cmd, ""keeppatterns"", 5))
			{
			    cmod->cmod_flags |= CMOD_KEEPPATTERNS;
			    continue;
			}
			if (!checkforcmd_noparen(&eap->cmd, ""keepjumps"", 5))
			    break;
			cmod->cmod_flags |= CMOD_KEEPJUMPS;
			continue;

	    case 'f':	// only accept "":filter {pat} cmd""
			{
			    char_u  *reg_pat;
			    char_u  *nulp = NULL;
			    int	    c = 0;

			    if (!checkforcmd_noparen(&p, ""filter"", 4)
				    || *p == NUL
				    || (ends_excmd(*p)
#ifdef FEAT_EVAL
					// in "":filter #pat# cmd"" # does not
					// start a comment
				     && (!vim9script || VIM_ISWHITE(p[1]))
#endif
				     ))
				break;
			    if (*p == '!')
			    {
				cmod->cmod_filter_force = TRUE;
				p = skipwhite(p + 1);
				if (*p == NUL || ends_excmd(*p))
				    break;
			    }
#ifdef FEAT_EVAL
			    // Avoid that ""filter(arg)"" is recognized.
			    if (vim9script && !VIM_ISWHITE(p[-1]))
				break;
#endif
			    if (skip_only)
				p = skip_vimgrep_pat(p, NULL, NULL);
			    else
				// NOTE: This puts a NUL after the pattern.
				p = skip_vimgrep_pat_ext(p, &reg_pat, NULL,
								    &nulp, &c);
			    if (p == NULL || *p == NUL)
				break;
			    if (!skip_only)
			    {
				cmod->cmod_filter_regmatch.regprog =
						vim_regcomp(reg_pat, RE_MAGIC);
				if (cmod->cmod_filter_regmatch.regprog == NULL)
				    break;
				// restore the character overwritten by NUL
				if (nulp != NULL)
				    *nulp = c;
			    }
			    eap->cmd = p;
			    continue;
			}

			// "":hide"" and "":hide | cmd"" are not modifiers
	    case 'h':	if (p != eap->cmd || !checkforcmd_noparen(&p, ""hide"", 3)
					       || *p == NUL || ends_excmd(*p))
			    break;
			eap->cmd = p;
			cmod->cmod_flags |= CMOD_HIDE;
			continue;

	    case 'l':	if (checkforcmd_noparen(&eap->cmd, ""lockmarks"", 3))
			{
			    cmod->cmod_flags |= CMOD_LOCKMARKS;
			    continue;
			}
			if (checkforcmd_noparen(&eap->cmd, ""legacy"", 3))
			{
			    if (ends_excmd2(p, eap->cmd))
			    {
				*errormsg =
				      _(e_legacy_must_be_followed_by_command);
				return FAIL;
			    }
			    cmod->cmod_flags |= CMOD_LEGACY;
			    continue;
			}

			if (!checkforcmd_noparen(&eap->cmd, ""leftabove"", 5))
			    break;
			cmod->cmod_split |= WSP_ABOVE;
			continue;

	    case 'n':	if (checkforcmd_noparen(&eap->cmd, ""noautocmd"", 3))
			{
			    cmod->cmod_flags |= CMOD_NOAUTOCMD;
			    continue;
			}
			if (!checkforcmd_noparen(&eap->cmd, ""noswapfile"", 3))
			    break;
			cmod->cmod_flags |= CMOD_NOSWAPFILE;
			continue;

	    case 'r':	if (!checkforcmd_noparen(&eap->cmd, ""rightbelow"", 6))
			    break;
			cmod->cmod_split |= WSP_BELOW;
			continue;

	    case 's':	if (checkforcmd_noparen(&eap->cmd, ""sandbox"", 3))
			{
			    cmod->cmod_flags |= CMOD_SANDBOX;
			    continue;
			}
			if (!checkforcmd_noparen(&eap->cmd, ""silent"", 3))
			    break;
			cmod->cmod_flags |= CMOD_SILENT;
			if (*eap->cmd == '!' && !VIM_ISWHITE(eap->cmd[-1]))
			{
			    // "":silent!"", but not ""silent !cmd""
			    eap->cmd = skipwhite(eap->cmd + 1);
			    cmod->cmod_flags |= CMOD_ERRSILENT;
			}
			continue;

	    case 't':	if (checkforcmd_noparen(&p, ""tab"", 3))
			{
			    if (!skip_only)
			    {
				long tabnr = get_address(eap, &eap->cmd,
						    ADDR_TABS, eap->skip,
						    skip_only, FALSE, 1);
				if (tabnr == MAXLNUM)
				    cmod->cmod_tab = tabpage_index(curtab) + 1;
				else
				{
				    if (tabnr < 0 || tabnr > LAST_TAB_NR)
				    {
					*errormsg = _(e_invalid_range);
					return FAIL;
				    }
				    cmod->cmod_tab = tabnr + 1;
				}
			    }
			    eap->cmd = p;
			    continue;
			}
			if (!checkforcmd_noparen(&eap->cmd, ""topleft"", 2))
			    break;
			cmod->cmod_split |= WSP_TOP;
			continue;

	    case 'u':	if (!checkforcmd_noparen(&eap->cmd, ""unsilent"", 3))
			    break;
			cmod->cmod_flags |= CMOD_UNSILENT;
			continue;

	    case 'v':	if (checkforcmd_noparen(&eap->cmd, ""vertical"", 4))
			{
			    cmod->cmod_split |= WSP_VERT;
			    continue;
			}
			if (checkforcmd_noparen(&eap->cmd, ""vim9cmd"", 4))
			{
			    if (ends_excmd2(p, eap->cmd))
			    {
				*errormsg =
				      _(e_vim9cmd_must_be_followed_by_command);
				return FAIL;
			    }
			    cmod->cmod_flags |= CMOD_VIM9CMD;
			    continue;
			}
			if (!checkforcmd_noparen(&p, ""verbose"", 4))
			    break;
			if (vim_isdigit(*eap->cmd))
			{
			    // zero means not set, one is verbose == 0, etc.
			    cmod->cmod_verbose = atoi((char *)eap->cmd) + 1;
			}
			else
			    cmod->cmod_verbose = 2;  // default: verbose == 1
			eap->cmd = p;
			continue;
	}
	break;
    }

    if (has_visual_range)
    {
	if (eap->cmd > cmd_start)
	{
	    // Move the '<,'> range to after the modifiers and insert a colon.
	    // Since the modifiers have been parsed put the colon on top of the
	    // space: ""'<,'>mod cmd"" -> ""mod:'<,'>cmd
	    // Put eap->cmd after the colon.
	    if (use_plus_cmd)
	    {
		size_t len = STRLEN(cmd_start);

		// Special case: empty command uses ""+"":
		//  ""'<,'>mods"" -> ""mods *+
		//  Use ""*"" instead of ""'<,'>"" to avoid the command getting
		//  longer, in case is was allocated.
		mch_memmove(orig_cmd, cmd_start, len);
		STRCPY(orig_cmd + len, "" *+"");
	    }
	    else
	    {
		mch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);
		eap->cmd -= 5;
		mch_memmove(eap->cmd - 1, "":'<,'>"", 6);
	    }
	}
	else
	    // No modifiers, move the pointer back.
	    // Special case: change empty command to ""+"".
	    if (use_plus_cmd)
		eap->cmd = (char_u *)""'<,'>+"";
	    else
		eap->cmd = orig_cmd;
    }
    else if (use_plus_cmd)
	eap->cmd = (char_u *)""+"";

    return OK;
}","int
parse_command_modifiers(
	exarg_T	    *VAR_0,
	char	    **VAR_1,
	cmdmod_T    *VAR_2,
	int	    VAR_3)
{
    char_u  *VAR_4 = VAR_0->cmd;
    char_u  *VAR_5 = NULL;
    int	    VAR_6 = FALSE;
    int	    VAR_7 = FALSE;
    int	    VAR_8 = in_vim9script();
    int	    VAR_9 = FALSE;

    CLEAR_POINTER(VAR_2);
    VAR_2->cmod_flags = VAR_10;

    if (STRNCMP(VAR_0->cmd, ""'<,'>"", 5) == 0)
    {
	/* COMMENT_0 */
	/* COMMENT_1 */
	/* COMMENT_2 */
	/* COMMENT_3 */
	/* COMMENT_4 */
	VAR_0->cmd += 5;
	VAR_5 = VAR_0->cmd;
	VAR_9 = TRUE;
    }

    /* COMMENT_5 */
    for (;;)
    {
	char_u  *VAR_11;

	while (*VAR_0->cmd == ' ' || *VAR_0->cmd == '\t' || *VAR_0->cmd == ':')
	{
	    if (*VAR_0->cmd == ':')
		VAR_7 = TRUE;
	    ++VAR_0->cmd;
	}

	/* COMMENT_6 */
	if (*VAR_0->cmd == VAR_12 && VAR_13
		   && (getline_equal(VAR_0->getline, VAR_0->cookie, VAR_14)
		       || getline_equal(VAR_0->getline, VAR_0->cookie, VAR_15))
			&& VAR_16->w_cursor.lnum < VAR_17->b_ml.ml_line_count)
	{
	    VAR_6 = TRUE;
	    if (!VAR_3)
		VAR_18 = TRUE;
	    break;  /* COMMENT_7 */
	}

	/* COMMENT_8 */
	if (comment_start(VAR_0->cmd, VAR_7))
	{
	    /* COMMENT_9 */
	    if (VAR_0->nextcmd == NULL)
	    {
		VAR_0->nextcmd = vim_strchr(VAR_0->cmd, '\n');
		if (VAR_0->nextcmd != NULL)
		    ++VAR_0->nextcmd;
	    }
	    if (VAR_8 && has_cmdmod(VAR_2, FALSE))
		*VAR_1 = _(VAR_19);
	    return VAR_20;
	}
	if (*VAR_0->cmd == VAR_12)
	{
	    if (!VAR_3)
	    {
		VAR_18 = TRUE;
		if (VAR_8 && has_cmdmod(VAR_2, FALSE))
		    *VAR_1 = _(VAR_19);
	    }
	    return VAR_20;
	}

	VAR_11 = skip_range(VAR_0->cmd, TRUE, NULL);

	/* COMMENT_10 */
	/* COMMENT_11 */
	/* COMMENT_12 */
	/* COMMENT_13 */
	/* COMMENT_14 */
	/* COMMENT_15 */
	/* COMMENT_16 */
	/* COMMENT_17 */
	if (VAR_8)
	{
	    char_u *VAR_21, *VAR_22;

	    for (VAR_21 = VAR_0->cmd; ASCII_ISALPHA(*VAR_21); ++VAR_21)
		;
	    VAR_22 = skipwhite(VAR_21);
	    if (*VAR_22 == '.' || *VAR_22 == '=' || (*VAR_22 != VAR_12 && VAR_22[1] == '=')
		    || *VAR_21 == '[')
		break;
	}

	switch (*VAR_11)
	{
	    /* COMMENT_18 */
	    case 'a':	if (!checkforcmd_noparen(&VAR_0->cmd, ""aboveleft"", 3))
			    break;
			VAR_2->cmod_split |= VAR_23;
			continue;

	    case 'b':	if (checkforcmd_noparen(&VAR_0->cmd, ""belowright"", 3))
			{
			    VAR_2->cmod_split |= VAR_24;
			    continue;
			}
			if (checkforcmd_opt(&VAR_0->cmd, ""browse"", 3, TRUE))
			{
#ifdef VAR_25
			    VAR_2->cmod_flags |= VAR_26;
#endif
			    continue;
			}
			if (!checkforcmd_noparen(&VAR_0->cmd, ""botright"", 2))
			    break;
			VAR_2->cmod_split |= VAR_27;
			continue;

	    case 'c':	if (!checkforcmd_opt(&VAR_0->cmd, ""confirm"", 4, TRUE))
			    break;
#if defined(VAR_28) || defined(VAR_29)
			VAR_2->cmod_flags |= VAR_30;
#endif
			continue;

	    case 'k':	if (checkforcmd_noparen(&VAR_0->cmd, ""keepmarks"", 3))
			{
			    VAR_2->cmod_flags |= VAR_31;
			    continue;
			}
			if (checkforcmd_noparen(&VAR_0->cmd, ""keepalt"", 5))
			{
			    VAR_2->cmod_flags |= VAR_32;
			    continue;
			}
			if (checkforcmd_noparen(&VAR_0->cmd, ""keeppatterns"", 5))
			{
			    VAR_2->cmod_flags |= VAR_33;
			    continue;
			}
			if (!checkforcmd_noparen(&VAR_0->cmd, ""keepjumps"", 5))
			    break;
			VAR_2->cmod_flags |= VAR_34;
			continue;

	    case 'f':	/* COMMENT_19 */
			{
			    char_u  *VAR_35;
			    char_u  *VAR_36 = NULL;
			    int	    VAR_37 = 0;

			    if (!checkforcmd_noparen(&VAR_11, ""filter"", 4)
				    || *VAR_11 == VAR_12
				    || (ends_excmd(*VAR_11)
#ifdef VAR_38
					/* COMMENT_20 */
					/* COMMENT_21 */
				     && (!VAR_8 || VIM_ISWHITE(VAR_11[1]))
#endif
				     ))
				break;
			    if (*VAR_11 == '!')
			    {
				VAR_2->cmod_filter_force = TRUE;
				VAR_11 = skipwhite(VAR_11 + 1);
				if (*VAR_11 == VAR_12 || ends_excmd(*VAR_11))
				    break;
			    }
#ifdef VAR_38
			    /* COMMENT_22 */
			    if (VAR_8 && !VIM_ISWHITE(VAR_11[-1]))
				break;
#endif
			    if (VAR_3)
				VAR_11 = skip_vimgrep_pat(VAR_11, NULL, NULL);
			    else
				/* COMMENT_23 */
				VAR_11 = skip_vimgrep_pat_ext(VAR_11, &VAR_35, NULL,
								    &VAR_36, &VAR_37);
			    if (VAR_11 == NULL || *VAR_11 == VAR_12)
				break;
			    if (!VAR_3)
			    {
				VAR_2->cmod_filter_regmatch.regprog =
						vim_regcomp(VAR_35, VAR_39);
				if (VAR_2->cmod_filter_regmatch.regprog == NULL)
				    break;
				/* COMMENT_24 */
				if (VAR_36 != NULL)
				    *VAR_36 = VAR_37;
			    }
			    VAR_0->cmd = VAR_11;
			    continue;
			}

			/* COMMENT_25 */
	    case 'h':	if (VAR_11 != VAR_0->cmd || !checkforcmd_noparen(&VAR_11, ""hide"", 3)
					       || *VAR_11 == VAR_12 || ends_excmd(*VAR_11))
			    break;
			VAR_0->cmd = VAR_11;
			VAR_2->cmod_flags |= VAR_40;
			continue;

	    case 'l':	if (checkforcmd_noparen(&VAR_0->cmd, ""lockmarks"", 3))
			{
			    VAR_2->cmod_flags |= VAR_41;
			    continue;
			}
			if (checkforcmd_noparen(&VAR_0->cmd, ""legacy"", 3))
			{
			    if (ends_excmd2(VAR_11, VAR_0->cmd))
			    {
				*VAR_1 =
				      _(VAR_42);
				return VAR_20;
			    }
			    VAR_2->cmod_flags |= VAR_43;
			    continue;
			}

			if (!checkforcmd_noparen(&VAR_0->cmd, ""leftabove"", 5))
			    break;
			VAR_2->cmod_split |= VAR_23;
			continue;

	    case 'n':	if (checkforcmd_noparen(&VAR_0->cmd, ""noautocmd"", 3))
			{
			    VAR_2->cmod_flags |= VAR_44;
			    continue;
			}
			if (!checkforcmd_noparen(&VAR_0->cmd, ""noswapfile"", 3))
			    break;
			VAR_2->cmod_flags |= VAR_45;
			continue;

	    case 'r':	if (!checkforcmd_noparen(&VAR_0->cmd, ""rightbelow"", 6))
			    break;
			VAR_2->cmod_split |= VAR_24;
			continue;

	    case 's':	if (checkforcmd_noparen(&VAR_0->cmd, ""sandbox"", 3))
			{
			    VAR_2->cmod_flags |= VAR_46;
			    continue;
			}
			if (!checkforcmd_noparen(&VAR_0->cmd, ""silent"", 3))
			    break;
			VAR_2->cmod_flags |= VAR_47;
			if (*VAR_0->cmd == '!' && !VIM_ISWHITE(VAR_0->cmd[-1]))
			{
			    /* COMMENT_26 */
			    VAR_0->cmd = skipwhite(VAR_0->cmd + 1);
			    VAR_2->cmod_flags |= VAR_48;
			}
			continue;

	    case 't':	if (checkforcmd_noparen(&VAR_11, ""tab"", 3))
			{
			    if (!VAR_3)
			    {
				long VAR_49 = get_address(VAR_0, &VAR_0->cmd,
						    VAR_50, VAR_0->skip,
						    VAR_3, FALSE, 1);
				if (VAR_49 == VAR_51)
				    VAR_2->cmod_tab = tabpage_index(VAR_52) + 1;
				else
				{
				    if (VAR_49 < 0 || VAR_49 > VAR_53)
				    {
					*VAR_1 = _(VAR_54);
					return VAR_20;
				    }
				    VAR_2->cmod_tab = VAR_49 + 1;
				}
			    }
			    VAR_0->cmd = VAR_11;
			    continue;
			}
			if (!checkforcmd_noparen(&VAR_0->cmd, ""topleft"", 2))
			    break;
			VAR_2->cmod_split |= VAR_55;
			continue;

	    case 'u':	if (!checkforcmd_noparen(&VAR_0->cmd, ""unsilent"", 3))
			    break;
			VAR_2->cmod_flags |= VAR_56;
			continue;

	    case 'v':	if (checkforcmd_noparen(&VAR_0->cmd, ""vertical"", 4))
			{
			    VAR_2->cmod_split |= VAR_57;
			    continue;
			}
			if (checkforcmd_noparen(&VAR_0->cmd, ""vim9cmd"", 4))
			{
			    if (ends_excmd2(VAR_11, VAR_0->cmd))
			    {
				*VAR_1 =
				      _(VAR_58);
				return VAR_20;
			    }
			    VAR_2->cmod_flags |= VAR_59;
			    continue;
			}
			if (!checkforcmd_noparen(&VAR_11, ""verbose"", 4))
			    break;
			if (vim_isdigit(*VAR_0->cmd))
			{
			    /* COMMENT_27 */
			    VAR_2->cmod_verbose = atoi((char *)VAR_0->cmd) + 1;
			}
			else
			    VAR_2->cmod_verbose = 2;  /* COMMENT_28 */
			VAR_0->cmd = VAR_11;
			continue;
	}
	break;
    }

    if (VAR_9)
    {
	if (VAR_0->cmd > VAR_5)
	{
	    /* COMMENT_29 */
	    /* COMMENT_30 */
	    /* COMMENT_31 */
	    /* COMMENT_32 */
	    if (VAR_6)
	    {
		size_t VAR_60 = STRLEN(VAR_5);

		/* COMMENT_33 */
		/* COMMENT_34 */
		/* COMMENT_35 */
		/* COMMENT_36 */
		mch_memmove(VAR_4, VAR_5, VAR_60);
		STRCPY(VAR_4 + VAR_60, "" *+"");
	    }
	    else
	    {
		mch_memmove(VAR_5 - 5, VAR_5, VAR_0->cmd - VAR_5);
		VAR_0->cmd -= 5;
		mch_memmove(VAR_0->cmd - 1, "":'<,'>"", 6);
	    }
	}
	else
	    /* COMMENT_37 */
	    /* COMMENT_38 */
	    if (VAR_6)
		VAR_0->cmd = (char_u *)""'<,'>+"";
	    else
		VAR_0->cmd = VAR_4;
    }
    else if (VAR_6)
	VAR_0->cmd = (char_u *)""+"";

    return VAR_61;
}",vim/c6fdb15d423df22e1776844811d082322475e48a/ex_docmd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -337,9 +337,11 @@
 		size_t len = STRLEN(cmd_start);
 
 		// Special case: empty command uses ""+"":
-		//  ""'<,'>mods"" -> ""mods'<,'>+
+		//  ""'<,'>mods"" -> ""mods *+
+		//  Use ""*"" instead of ""'<,'>"" to avoid the command getting
+		//  longer, in case is was allocated.
 		mch_memmove(orig_cmd, cmd_start, len);
-		STRCPY(orig_cmd + len, ""'<,'>+"");
+		STRCPY(orig_cmd + len, "" *+"");
 	    }
 	    else
 	    {","{'deleted_lines': ['\t\t//  ""\'<,\'>mods"" -> ""mods\'<,\'>+', '\t\tSTRCPY(orig_cmd + len, ""\'<,\'>+"");'], 'added_lines': ['\t\t//  ""\'<,\'>mods"" -> ""mods *+', '\t\t//  Use ""*"" instead of ""\'<,\'>"" to avoid the command getting', '\t\t//  longer, in case is was allocated.', '\t\tSTRCPY(orig_cmd + len, "" *+"");']}",True,Out-of-bounds Write in GitHub repository vim/vim prior to 9.0.,7.8,HIGH,2,test,2022-07-02T12:43:21Z,4
CVE-2022-2553,['CWE-287'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N,1,ClusterLabs/booth,"Revert ""Refactor: main: substitute is_auth_req macro""

This reverts commit da79b8ba28ad4837a0fee13e5f8fb6f89fe0e24c.

authfile != authkey

Signed-off-by: Jan Friesse <jfriesse@redhat.com>",35bf0b7b048d715f671eb68974fb6b4af6528c67,https://github.com/ClusterLabs/booth/commit/35bf0b7b048d715f671eb68974fb6b4af6528c67,src/main.c,setup_config,"static int setup_config(int type)
{
int rv;
rv = read_config(cl.configfile, type);
if (rv < 0)
goto out;
if (is_auth_req()) {
rv = read_authkey();
if (rv < 0)
goto out;
#if HAVE_LIBGCRYPT
if (!gcry_check_version(NULL)) {
log_error(""gcry_check_version"");
rv = -ENOENT;
goto out;
}
gcry_control(GCRYCTL_DISABLE_SECMEM, 0);
gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);
#endif
}
if (cl.type == DAEMON && cl.site[0]) {
if (!find_site_by_name(cl.site, &local, 1)) {
log_error(""Cannot find \""%s\"" in the configuration."",
cl.site);
return -EINVAL;
}
local->local = 1;
} else
find_myself(NULL, type == CLIENT || type == GEOSTORE);
rv = check_config(type);
if (rv < 0)
goto out;
if (!cl.lockfile[0]) {
snprintf(cl.lockfile, sizeof(cl.lockfile)-1,
""%s/%s.pid"", BOOTH_RUN_DIR, booth_conf->name);
}
out:
return rv;
}","static int setup_config(int VAR_0)
{
int VAR_1;
VAR_1 = read_config(VAR_2.configfile, VAR_0);
if (VAR_1 < 0)
goto out;
if (is_auth_req()) {
VAR_1 = read_authkey();
if (VAR_1 < 0)
goto out;
#if VAR_3
if (!gcry_check_version(NULL)) {
log_error(""gcry_check_version"");
VAR_1 = -VAR_4;
goto out;
}
gcry_control(VAR_5, 0);
gcry_control(VAR_6, 0);
#endif
}
if (VAR_2.type == VAR_7 && VAR_2.site[0]) {
if (!find_site_by_name(VAR_2.site, &VAR_8, 1)) {
log_error(""Cannot find \""%s\"" in the configuration."",
VAR_2.site);
return -VAR_9;
}
VAR_8->local = 1;
} else
find_myself(NULL, VAR_0 == VAR_10 || VAR_0 == VAR_11);
VAR_1 = check_config(VAR_0);
if (VAR_1 < 0)
goto out;
if (!VAR_2.lockfile[0]) {
snprintf(VAR_2.lockfile, sizeof(VAR_2.lockfile)-1,
""%s/%s.pid"", VAR_12, VAR_13->name);
}
out:
return VAR_1;
}",ClusterLabs/booth/35bf0b7b048d715f671eb68974fb6b4af6528c67/main.c/vul/before/0.json,"static int setup_config(int type)
{
	int rv;

	rv = read_config(cl.configfile, type);
	if (rv < 0)
		goto out;

	if (booth_conf->authfile[0] != '\0') {
		rv = read_authkey();
		if (rv < 0)
			goto out;
#if HAVE_LIBGCRYPT
		if (!gcry_check_version(NULL)) {
			log_error(""gcry_check_version"");
			rv = -ENOENT;
			goto out;
		}
		gcry_control(GCRYCTL_DISABLE_SECMEM, 0);
		gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);
#endif
	}

	/* Set ""local"" pointer, ignoring errors. */
	if (cl.type == DAEMON && cl.site[0]) {
		if (!find_site_by_name(cl.site, &local, 1)) {
			log_error(""Cannot find \""%s\"" in the configuration."",
					cl.site);
			return -EINVAL;
		}
		local->local = 1;
	} else
		find_myself(NULL, type == CLIENT || type == GEOSTORE);


	rv = check_config(type);
	if (rv < 0)
		goto out;


	/* Per default the PID file name is derived from the
	 * configuration name. */
	if (!cl.lockfile[0]) {
		snprintf(cl.lockfile, sizeof(cl.lockfile)-1,
				""%s/%s.pid"", BOOTH_RUN_DIR, booth_conf->name);
	}

out:
	return rv;
}","static int setup_config(int VAR_0)
{
	int VAR_1;

	VAR_1 = read_config(VAR_2.configfile, VAR_0);
	if (VAR_1 < 0)
		goto out;

	if (VAR_3->authfile[0] != '\0') {
		VAR_1 = read_authkey();
		if (VAR_1 < 0)
			goto out;
#if VAR_4
		if (!gcry_check_version(NULL)) {
			log_error(""gcry_check_version"");
			VAR_1 = -VAR_5;
			goto out;
		}
		gcry_control(VAR_6, 0);
		gcry_control(VAR_7, 0);
#endif
	}

	/* COMMENT_0 */
	if (VAR_2.type == VAR_8 && VAR_2.site[0]) {
		if (!find_site_by_name(VAR_2.site, &VAR_9, 1)) {
			log_error(""Cannot find \""%s\"" in the configuration."",
					VAR_2.site);
			return -VAR_10;
		}
		VAR_9->local = 1;
	} else
		find_myself(NULL, VAR_0 == VAR_11 || VAR_0 == VAR_12);


	VAR_1 = check_config(VAR_0);
	if (VAR_1 < 0)
		goto out;


	/* COMMENT_1 */
                          
	if (!VAR_2.lockfile[0]) {
		snprintf(VAR_2.lockfile, sizeof(VAR_2.lockfile)-1,
				""%s/%s.pid"", VAR_13, VAR_3->name);
	}

out:
	return VAR_1;
}",ClusterLabs/booth/35bf0b7b048d715f671eb68974fb6b4af6528c67/main.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
 	if (rv < 0)
 		goto out;
 
-	if (is_auth_req()) {
+	if (booth_conf->authfile[0] != '\0') {
 		rv = read_authkey();
 		if (rv < 0)
 			goto out;","{'deleted_lines': ['\tif (is_auth_req()) {'], 'added_lines': [""\tif (booth_conf->authfile[0] != '\\0') {""]}",True,"The authfile directive in the booth config file is ignored, preventing use of authentication in communications from node to node. As a result, nodes that do not have the correct authentication key are not prevented from communicating with other nodes in the cluster.",6.5,MEDIUM,1,test,2022-07-04T07:39:47Z,4
CVE-2022-2476,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,dbry/WavPack,"issue #121: NULL pointer dereference in wvunpack.c

* check for NULL pointer before dereferencing in wvunpack.c
* sanitize custom extensions to be alphanumeric only",25b4a2725d8568212e7cf89ca05ca29d128af7ac,https://github.com/dbry/WavPack/commit/25b4a2725d8568212e7cf89ca05ca29d128af7ac,cli/wvunpack.c,wvunpack_main,"static int wvunpack_main(int argc, char **argv)
#else
int main(int argc, char **argv)
#endif
{
#ifdef __EMX__ 
_wildcard (&argc, &argv);
#endif
int verify_only = 0, error_count = 0, add_extension = 0, output_spec = 0, c_count = 0, x_count = 0;
char outpath, **matches = NULL, *outfilename = NULL, **argv_fn = NULL, selfname [PATH_MAX];
int use_stdin = 0, use_stdout = 0, argc_fn = 0, argi, result;
#if defined(_WIN32)
if (!GetModuleFileName (NULL, selfname, sizeof (selfname)))
#endif
strncpy (selfname, *argv, sizeof (selfname));
if (filespec_name (selfname)) {
char *filename = filespec_name (selfname);
if (strstr (filename, ""ebug"") || strstr (filename, ""DEBUG""))
debug_logging_mode = TRUE;
while (strchr (filename, '{')) {
char *open_brace = strchr (filename, '{');
char *close_brace = strchr (open_brace, '}');
if (!close_brace)
break;
if (close_brace - open_brace > 1) {
int option_len = (int)(close_brace - open_brace) - 1;
char *option = malloc (option_len + 1);
argv_fn = realloc (argv_fn, sizeof (char *) * ++argc_fn);
memcpy (option, open_brace + 1, option_len);
argv_fn [argc_fn - 1] = option;
option [option_len] = 0;
if (debug_logging_mode)
error_line (""file arg %d: %s"", argc_fn, option);
}
filename = close_brace;
}
}
if (debug_logging_mode) {
char **argv_t = argv;
int argc_t = argc;
while (--argc_t)
error_line (""cli arg %d: %s"", argc - argc_t, *++argv_t);
}
#if defined (_WIN32)
set_console_title = 1;      #endif                          
for (argi = 0; argi < argc + argc_fn - 1; ++argi) {
char *argcp;
if (argi < argc_fn)
argcp = argv_fn [argi];
else
argcp = argv [argi - argc_fn + 1];
if (argcp [0] == '-' && argcp [1] == '-' && argcp [2]) {
char *long_option = argcp + 2, *long_param = long_option;
while (*long_param)
if (*long_param++ == '=')
break;
if (!strcmp (long_option, ""help"")) {                                        printf (""%s"", help);
return 0;
}
else if (!strcmp (long_option, ""version"")) {                                printf (""wvunpack %s\n"", PACKAGE_VERSION);
printf (""libwavpack %s\n"", WavpackGetLibraryVersionString ());
return 0;
}
#ifdef _WIN32
else if (!strcmp (long_option, ""pause""))                                    pause_mode = 1;
else if (!strcmp (long_option, ""drop""))                                     drop_mode = 1;
#endif
else if (!strcmp (long_option, ""normalize-floats""))                         normalize_floats = 1;
else if (!strcmp (long_option, ""no-utf8-convert""))                          no_utf8_convert = 1;
else if (!strncmp (long_option, ""skip"", 4)) {                               parse_sample_time_index (&skip, long_param);
if (!skip.value_is_valid) {
error_line (""invalid --skip parameter!"");
++error_count;
}
}
else if (!strncmp (long_option, ""until"", 5)) {                              parse_sample_time_index (&until, long_param);
if (!until.value_is_valid) {
error_line (""invalid --until parameter!"");
++error_count;
}
}
else if (!strcmp (long_option, ""caf-be"")) {                                 decode_format = WP_FORMAT_CAF;
caf_be = format_specified = 1;
}
else if (!strcmp (long_option, ""caf-le"")) {                                 decode_format = WP_FORMAT_CAF;
format_specified = 1;
}
else if (!strcmp (long_option, ""dsf"")) {                                    decode_format = WP_FORMAT_DSF;
format_specified = 1;
}
else if (!strcmp (long_option, ""dsdiff"") || !strcmp (long_option, ""dff"")) {
decode_format = WP_FORMAT_DFF;                                          format_specified = 1;
}
else if (!strcmp (long_option, ""w64"")) {                                    decode_format = WP_FORMAT_W64;
format_specified = 1;
}
else if (!strcmp (long_option, ""wav"")) {                                    decode_format = WP_FORMAT_WAV;
format_specified = 1;
}
else if (!strcmp (long_option, ""raw-pcm""))                                  raw_pcm = raw_decode = 1;
else if (!strcmp (long_option, ""raw""))                                      raw_decode = 1;
else {
error_line (""unknown option: %s !"", long_option);
++error_count;
}
}
#if defined (_WIN32)
else if ((argcp [0] == '-' || argcp [0] == '/') && argcp [1])
#else
else if (argcp [0] == '-' && argcp [1])
#endif
while (*++argcp)
switch (*argcp) {
case 'Y': case 'y':
overwrite_all = 1;
break;
case 'C': case 'c':
if (++c_count == 2) {
add_tag_extraction_to_list (""cuesheet=%a.cue"");
c_count = 0;
}
break;
case 'D': case 'd':
delete_source = 1;
break;
#if defined (_WIN32)
case 'L': case 'l':
SetPriorityClass (GetCurrentProcess(), IDLE_PRIORITY_CLASS);
break;
#elif defined (__OS2__)
case 'L': case 'l':
DosSetPriority (0, PRTYC_IDLETIME, 0, 0);
break;
#endif
#if defined (_WIN32)
case 'O': case 'o':                          break;
#else
case 'O': case 'o':
output_spec = 1;
break;
#endif
case 'T': case 't':
copy_time = 1;
break;
case 'V': case 'v':
++verify_only;
break;
case 'F': case 'f':
file_info = (char) strtol (++argcp, &argcp, 10);
if (file_info < 0 || file_info > 10) {
error_line (""-f option must be 1-10, or omit (or 0) for all!"");
++error_count;
}
else {
quiet_mode = no_audio_decode = 1;
file_info++;
}
--argcp;
break;
case 'S': case 's':
no_audio_decode = 1;
++summary;
break;
case 'K': case 'k':
outbuf_k = strtol (++argcp, &argcp, 10);
if (outbuf_k < 1 || outbuf_k > 16384)                                   outbuf_k = 0;
--argcp;
break;
case 'M': case 'm':
calc_md5 = 1;
break;
case 'B': case 'b':
blind_decode = 1;
break;
case 'N': case 'n':
no_audio_decode = 1;
break;
case 'R': case 'r':
raw_decode = 1;
break;
case 'W': case 'w':
decode_format = WP_FORMAT_WAV;
format_specified = 1;
break;
case 'Q': case 'q':
quiet_mode = 1;
break;
case 'Z': case 'z':
set_console_title = (char) strtol (++argcp, &argcp, 10);
--argcp;
break;
case 'X': case 'x':
if (++x_count == 3) {
error_line (""illegal option: %s !"", argcp);
++error_count;
x_count = 0;
}
break;
case 'I': case 'i':
ignore_wvc = 1;
break;
default:
error_line (""illegal option: %c !"", *argcp);
++error_count;
}
else if (argi < argc_fn) {
error_line (""invalid use of filename-embedded args: %s !"", argcp);
++error_count;
}
else {
if (x_count) {
if (x_count == 1) {
if (tag_extract_stdout) {
error_line (""can't extract more than 1 tag item to stdout at a time!"");
++error_count;
}
else {
tag_extract_stdout = argcp;
no_audio_decode = 1;
}
}
else if (x_count == 2)
add_tag_extraction_to_list (argcp);
x_count = 0;
}
#if defined (_WIN32)
else if (drop_mode || !num_files) {
matches = realloc (matches, (num_files + 1) * sizeof (*matches));
matches [num_files] = malloc (strlen (argcp) + 10);
strcpy (matches [num_files], argcp);
use_stdin |= (*argcp == '-');
if (*(matches [num_files]) != '-' && *(matches [num_files]) != '@' &&
!filespec_ext (matches [num_files]))
strcat (matches [num_files], "".wv"");
num_files++;
}
else if (!outfilename) {
outfilename = malloc (strlen (argcp) + PATH_MAX);
strcpy (outfilename, argcp);
use_stdout = (*argcp == '-');
}
else {
error_line (""extra unknown argument: %s !"", argcp);
++error_count;
}
#else
else if (output_spec) {
outfilename = malloc (strlen (argcp) + PATH_MAX);
strcpy (outfilename, argcp);
use_stdout = (*argcp == '-');
output_spec = 0;
}
else {
matches = realloc (matches, (num_files + 1) * sizeof (*matches));
matches [num_files] = malloc (strlen (argcp) + 10);
strcpy (matches [num_files], argcp);
use_stdin |= (*argcp == '-');
if (*(matches [num_files]) != '-' && *(matches [num_files]) != '@' &&
!filespec_ext (matches [num_files]))
strcat (matches [num_files], "".wv"");
num_files++;
}
#endif
}
if (argi < argc_fn)
free (argv_fn [argi]);
}
free (argv_fn);
if (output_spec) {
error_line (""no output filename or path specified with -o option!"");
++error_count;
}
if (use_stdin && num_files > 1) {
error_line (""when stdin is used for input, it must be the only file!"");
++error_count;
}
if (use_stdin && !outfilename)          use_stdout = 1;
if (delete_source && (verify_only || skip.value_is_valid || until.value_is_valid)) {
error_line (""can't delete in verify mode or when --skip or --until are used!"");
delete_source = 0;
}
if (raw_decode && format_specified) {
error_line (""-r (raw decode) and specifying a format (like -w) are incompatible!"");
++error_count;
}
if (verify_only && (format_specified || outfilename)) {
error_line (""specifying output file or format and verify mode are incompatible!"");
++error_count;
}
if (verify_only > 1 && calc_md5) {
error_line (""can't calculate MD5s in quick verify mode!"");
++error_count;
}
if (c_count == 1) {
if (tag_extract_stdout) {
error_line (""can't extract more than 1 tag item to stdout at a time!"");
error_count++;
}
else {
tag_extract_stdout = ""cuesheet"";
no_audio_decode = 1;
}
}
if ((summary || file_info) && (num_tag_extractions || outfilename || verify_only || delete_source || format_specified)) {
error_line (""can't display file information and do anything else!"");
++error_count;
}
if (tag_extract_stdout && (num_tag_extractions || outfilename || verify_only || delete_source || format_specified || raw_decode)) {
error_line (""can't extract a tag to stdout and do anything else!"");
++error_count;
}
if ((tag_extract_stdout || num_tag_extractions) && use_stdout) {
error_line (""can't extract tags when unpacking audio to stdout!"");
++error_count;
}
if (strcmp (WavpackGetLibraryVersionString (), PACKAGE_VERSION)) {
fprintf (stderr, version_warning, WavpackGetLibraryVersionString (), PACKAGE_VERSION);
fflush (stderr);
}
else if (!quiet_mode && !error_count) {
fprintf (stderr, sign_on, VERSION_OS, WavpackGetLibraryVersionString ());
fflush (stderr);
}
if (error_count) {
fprintf (stderr, ""\ntype 'wvunpack' for short help or 'wvunpack --help' for full help\n"");
fflush (stderr);
return 1;
}
if (!num_files) {
printf (""%s"", usage);
return 1;
}
setup_break ();
for (file_index = 0; file_index < num_files; ++file_index) {
char *infilename = matches [file_index];
if (*infilename == '@') {
FILE *list = fopen (infilename+1, ""rb"");
char *listbuff = NULL, *cp;
int listbytes = 0, di, c;
for (di = file_index; di < num_files - 1; di++)
matches [di] = matches [di + 1];
file_index--;
num_files--;
if (list == NULL) {
error_line (""file %s not found!"", infilename+1);
free (infilename);
return 1;
}
while (1) {
int bytes_read;
listbuff = realloc (listbuff, listbytes + 1024);
memset (listbuff + listbytes, 0, 1024);
listbytes += bytes_read = (int) fread (listbuff + listbytes, 1, 1024, list);
if (bytes_read < 1024)
break;
}
#if defined (_WIN32)
listbuff = realloc (listbuff, listbytes *= 2);
TextToUTF8 (listbuff, listbytes);
#endif
cp = listbuff;
while ((c = *cp++)) {
while (c == '\n' || c == '\r')
c = *cp++;
if (c) {
char *fname = malloc (PATH_MAX);
int ci = 0;
do
fname [ci++] = c;
while ((c = *cp++) != '\n' && c != '\r' && c && ci < PATH_MAX);
fname [ci++] = '\0';
matches = realloc (matches, ++num_files * sizeof (*matches));
for (di = num_files - 1; di > file_index + 1; di--)
matches [di] = matches [di - 1];
matches [++file_index] = fname;
}
if (!c)
break;
}
fclose (list);
free (listbuff);
free (infilename);
}
#if defined (_WIN32)
else if (filespec_wild (infilename)) {
wchar_t *winfilename = utf8_to_utf16(infilename);
struct _wfinddata_t _wfinddata_t;
intptr_t file;
int di;
for (di = file_index; di < num_files - 1; di++)
matches [di] = matches [di + 1];
file_index--;
num_files--;
if ((file = _wfindfirst (winfilename, &_wfinddata_t)) != (intptr_t) -1) {
do {
char *name_utf8;
if (!(_wfinddata_t.attrib & _A_SUBDIR) && (name_utf8 = utf16_to_utf8(_wfinddata_t.name))) {
matches = realloc (matches, ++num_files * sizeof (*matches));
for (di = num_files - 1; di > file_index + 1; di--)
matches [di] = matches [di - 1];
matches [++file_index] = malloc (strlen (infilename) + strlen (name_utf8) + 10);
strcpy (matches [file_index], infilename);
*filespec_name (matches [file_index]) = '\0';
strcat (matches [file_index], name_utf8);
free (name_utf8);
}
} while (_wfindnext (file, &_wfinddata_t) == 0);
_findclose (file);
}
free (winfilename);
free (infilename);
}
#endif
}
if (outfilename && outfilename [0] == '@') {
char listbuff [PATH_MAX * 2], *lp = listbuff;
FILE *list = fopen (outfilename+1, ""rb"");
int c;
if (list == NULL) {
error_line (""file %s not found!"", outfilename+1);
free(outfilename);
return 1;
}
memset (listbuff, 0, sizeof (listbuff));
c = (int) fread (listbuff, 1, sizeof (listbuff) - 1, list);   
#if defined (_WIN32)
TextToUTF8 (listbuff, PATH_MAX * 2);
#endif
while ((c = *lp++) == '\n' || c == '\r');
if (c) {
int ci = 0;
do
outfilename [ci++] = c;
while ((c = *lp++) != '\n' && c != '\r' && c && ci < PATH_MAX);
outfilename [ci] = '\0';
}
else {
error_line (""output spec file is empty!"");
free(outfilename);
fclose (list);
return 1;
}
fclose (list);
}
if (num_files) {
if (outfilename && *outfilename != '-') {
outpath = (filespec_path (outfilename) != NULL);
if (num_files > 1 && !outpath) {
error_line (""%s is not a valid output path"", outfilename);
free (outfilename);
return 1;
}
}
else
outpath = 0;
add_extension = !outfilename || outpath || !filespec_ext (outfilename);
for (file_index = 0; file_index < num_files; ++file_index) {
if (check_break ())
break;
if (outpath) {
strcat (outfilename, filespec_name (matches [file_index]));
if (filespec_ext (outfilename))
*filespec_ext (outfilename) = '\0';
}
else if (!outfilename) {
outfilename = malloc (strlen (matches [file_index]) + 10);
strcpy (outfilename, matches [file_index]);
if (filespec_ext (outfilename))
*filespec_ext (outfilename) = '\0';
}
if (num_files > 1 && !quiet_mode) {
fprintf (stderr, ""\n%s:\n"", matches [file_index]);
fflush (stderr);
}
if (verify_only > 1) {
result = quick_verify_file (matches [file_index], verify_only > 2);
if (result == WAVPACK_HARD_ERROR)
result = unpack_file (matches [file_index], NULL, 0);
}
else
result = unpack_file (matches [file_index], verify_only ? NULL : outfilename, add_extension);
if (result != WAVPACK_NO_ERROR)
++error_count;
if (result == WAVPACK_HARD_ERROR)
break;
if (outpath)
*filespec_name (outfilename) = '\0';
else if (*outfilename != '-') {
free (outfilename);
outfilename = NULL;
}
free (matches [file_index]);
}
if (num_files > 1) {
if (error_count) {
fprintf (stderr, ""\n **** warning: errors occurred in %d of %d files! ****\n"", error_count, num_files);
fflush (stderr);
}
else if (!quiet_mode) {
fprintf (stderr, ""\n **** %d files successfully processed ****\n"", num_files);
fflush (stderr);
}
}
free (matches);
}
else {
error_line (""nothing to do!"");
++error_count;
}
if (outfilename)
free (outfilename);
if (set_console_title)
DoSetConsoleTitle (""WvUnpack Completed"");
return error_count ? 1 : 0;
}","static int wvunpack_main(int VAR_0, char **VAR_1)
#else
int main(int VAR_0, char **VAR_1)
#endif
{
#ifdef VAR_2 
_wildcard (&VAR_0, &VAR_1);
#endif
int VAR_3 = 0, VAR_4 = 0, VAR_5 = 0, VAR_6 = 0, VAR_7 = 0, VAR_8 = 0;
char VAR_9, **VAR_10 = NULL, *VAR_11 = NULL, **VAR_12 = NULL, VAR_13 [VAR_14];
int VAR_15 = 0, VAR_16 = 0, VAR_17 = 0, VAR_18, VAR_19;
#if defined(VAR_20)
if (!GetModuleFileName (NULL, VAR_13, sizeof (VAR_13)))
#endif
strncpy (VAR_13, *VAR_1, sizeof (VAR_13));
if (filespec_name (VAR_13)) {
char *VAR_21 = filespec_name (VAR_13);
if (strstr (VAR_21, ""ebug"") || strstr (VAR_21, ""DEBUG""))
VAR_22 = TRUE;
while (strchr (VAR_21, '{')) {
char *VAR_23 = strchr (VAR_21, '{');
char *VAR_24 = strchr (VAR_23, '}');
if (!VAR_24)
break;
if (VAR_24 - VAR_23 > 1) {
int VAR_25 = (int)(VAR_24 - VAR_23) - 1;
char *VAR_26 = malloc (VAR_25 + 1);
VAR_12 = realloc (VAR_12, sizeof (char *) * ++VAR_17);
memcpy (VAR_26, VAR_23 + 1, VAR_25);
VAR_12 [VAR_17 - 1] = VAR_26;
VAR_26 [VAR_25] = 0;
if (VAR_22)
error_line (""file arg %d: %s"", VAR_17, VAR_26);
}
VAR_21 = VAR_24;
}
}
if (VAR_22) {
char **VAR_27 = VAR_1;
int VAR_28 = VAR_0;
while (--VAR_28)
error_line (""cli arg %d: %s"", VAR_0 - VAR_28, *++VAR_27);
}
#if defined (VAR_20)
VAR_29 = 1;      
#endif                          
for (VAR_18 = 0; VAR_18 < VAR_0 + VAR_17 - 1; ++VAR_18) {
char *VAR_30;
if (VAR_18 < VAR_17)
VAR_30 = VAR_12 [VAR_18];
else
VAR_30 = VAR_1 [VAR_18 - VAR_17 + 1];
if (VAR_30 [0] == '-' && VAR_30 [1] == '-' && VAR_30 [2]) {
char *VAR_31 = VAR_30 + 2, *VAR_32 = VAR_31;
while (*VAR_32)
if (*VAR_32++ == '=')
break;
if (!strcmp (VAR_31, ""help"")) {                        
printf (""%s"", VAR_33);
return 0;
}
else if (!strcmp (VAR_31, ""version"")) {                
printf (""wvunpack %s\n"", VAR_34);
printf (""libwavpack %s\n"", WavpackGetLibraryVersionString ());
return 0;
}
#ifdef VAR_20
else if (!strcmp (long_option, ""pause""))                    
VAR_35 = 1;
else if (!strcmp (long_option, ""drop""))                     
VAR_36 = 1;
#endif
else if (!strcmp (long_option, ""VAR_37-VAR_38""))         
VAR_39 = 1;
else if (!strcmp (long_option, ""VAR_40-VAR_41-VAR_42""))          
VAR_43 = 1;
else if (!strncmp (long_option, ""skip"", 4)) {               
parse_sample_time_index (&skip, VAR_32);
if (!skip.value_is_valid) {
error_line (""invalid --skip parameter!"");
++VAR_4;
}
}
else if (!strncmp (long_option, ""until"", 5)) {              
parse_sample_time_index (&until, VAR_32);
if (!until.value_is_valid) {
error_line (""invalid --until parameter!"");
++VAR_4;
}
}
else if (!strcmp (long_option, ""VAR_44-VAR_45"")) {                 
VAR_46 = VAR_47;
VAR_48 = VAR_49 = 1;
}
else if (!strcmp (long_option, ""VAR_44-VAR_50"")) {                 
VAR_46 = VAR_47;
VAR_49 = 1;
}
else if (!strcmp (long_option, ""dsf"")) {                    
VAR_46 = VAR_51;
VAR_49 = 1;
}
else if (!strcmp (long_option, ""dsdiff"") || !strcmp (long_option, ""dff"")) {
VAR_46 = VAR_52;                          
VAR_49 = 1;
}
else if (!strcmp (long_option, ""w64"")) {                    
VAR_46 = VAR_53;
VAR_49 = 1;
}
else if (!strcmp (long_option, ""wav"")) {                    
VAR_46 = VAR_54;
VAR_49 = 1;
}
else if (!strcmp (long_option, ""VAR_55-VAR_56""))                  
VAR_57 = VAR_58 = 1;
else if (!strcmp (long_option, ""raw""))                      
VAR_58 = 1;
else {
error_line (""unknown option: %s !"", long_option);
++VAR_4;
}
}
#if defined (VAR_20)
else if ((argcp [0] == '-' || argcp [0] == '/') && argcp [1])
#else
else if (argcp [0] == '-' && argcp [1])
#endif
while (*++argcp)
switch (*argcp) {
case 'Y': case 'y':
VAR_59 = 1;
break;
case 'C': case 'c':
if (++VAR_7 == 2) {
add_tag_extraction_to_list (""cuesheet=%a.cue"");
VAR_7 = 0;
}
break;
case 'D': case 'd':
VAR_60 = 1;
break;
#if defined (VAR_20)
case 'L': case 'l':
SetPriorityClass (GetCurrentProcess(), VAR_61);
break;
#elif defined (VAR_62)
case 'L': case 'l':
DosSetPriority (0, VAR_63, 0, 0);
break;
#endif
#if defined (VAR_20)
case 'O': case 'o':  
break;
#else
case 'O': case 'o':
VAR_6 = 1;
break;
#endif
case 'T': case 't':
VAR_64 = 1;
break;
case 'V': case 'v':
++VAR_3;
break;
case 'F': case 'f':
VAR_65 = (char) strtol (++argcp, &argcp, 10);
if (VAR_65 < 0 || VAR_65 > 10) {
error_line (""-f option must be 1-10, or omit (or 0) for all!"");
++VAR_4;
}
else {
VAR_66 = VAR_67 = 1;
VAR_65++;
}
--argcp;
break;
case 'S': case 's':
VAR_67 = 1;
++VAR_68;
break;
case 'K': case 'k':
VAR_69 = strtol (++argcp, &argcp, 10);
if (VAR_69 < 1 || VAR_69 > 16384)       
VAR_69 = 0;
--argcp;
break;
case 'M': case 'm':
VAR_70 = 1;
break;
case 'B': case 'b':
VAR_71 = 1;
break;
case 'N': case 'n':
VAR_67 = 1;
break;
case 'R': case 'r':
VAR_58 = 1;
break;
case 'W': case 'w':
VAR_46 = VAR_54;
VAR_49 = 1;
break;
case 'Q': case 'q':
VAR_66 = 1;
break;
case 'Z': case 'z':
VAR_29 = (char) strtol (++argcp, &argcp, 10);
--argcp;
break;
case 'X': case 'x':
if (++VAR_8 == 3) {
error_line (""illegal option: %s !"", argcp);
++VAR_4;
VAR_8 = 0;
}
break;
case 'I': case 'i':
VAR_72 = 1;
break;
default:
error_line (""illegal option: %c !"", *argcp);
++VAR_4;
}
else if (argi < VAR_17) {
error_line (""invalid use of filename-embedded args: %s !"", argcp);
++VAR_4;
}
else {
if (VAR_8) {
if (VAR_8 == 1) {
if (VAR_73) {
error_line (""can't extract more than 1 tag item to stdout at a time!"");
++VAR_4;
}
else {
VAR_73 = argcp;
VAR_67 = 1;
}
}
else if (VAR_8 == 2)
add_tag_extraction_to_list (argcp);
VAR_8 = 0;
}
#if defined (VAR_20)
else if (drop_mode || !VAR_74) {
VAR_10 = realloc (VAR_10, (VAR_74 + 1) * sizeof (*VAR_10));
VAR_10 [VAR_74] = malloc (strlen (argcp) + 10);
strcpy (VAR_10 [VAR_74], argcp);
VAR_15 |= (*argcp == '-');
if (*(VAR_10 [VAR_74]) != '-' && *(VAR_10 [VAR_74]) != '@' &&
!filespec_ext (VAR_10 [VAR_74]))
strcat (VAR_10 [VAR_74], "".wv"");
VAR_74++;
}
else if (!outfilename) {
outfilename = malloc (strlen (argcp) + VAR_14);
strcpy (outfilename, argcp);
VAR_16 = (*argcp == '-');
}
else {
error_line (""extra unknown argument: %s !"", argcp);
++VAR_4;
}
#else
else if (output_spec) {
outfilename = malloc (strlen (argcp) + VAR_14);
strcpy (outfilename, argcp);
VAR_16 = (*argcp == '-');
output_spec = 0;
}
else {
VAR_10 = realloc (VAR_10, (VAR_74 + 1) * sizeof (*VAR_10));
VAR_10 [VAR_74] = malloc (strlen (argcp) + 10);
strcpy (VAR_10 [VAR_74], argcp);
VAR_15 |= (*argcp == '-');
if (*(VAR_10 [VAR_74]) != '-' && *(VAR_10 [VAR_74]) != '@' &&
!filespec_ext (VAR_10 [VAR_74]))
strcat (VAR_10 [VAR_74], "".wv"");
VAR_74++;
}
#endif
}
if (argi < VAR_17)
free (VAR_12 [argi]);
}
free (VAR_12);
if (output_spec) {
error_line (""no output filename or path specified with -o option!"");
++VAR_4;
}
if (VAR_15 && VAR_74 > 1) {
error_line (""when stdin is used for input, it must be the only file!"");
++VAR_4;
}
if (VAR_15 && !outfilename)  
VAR_16 = 1;
if (VAR_60 && (VAR_3 || skip.value_is_valid || until.value_is_valid)) {
error_line (""can't delete in verify mode or when --skip or --until are used!"");
VAR_60 = 0;
}
if (VAR_58 && VAR_49) {
error_line (""-r (raw decode) and specifying a format (like -w) are incompatible!"");
++VAR_4;
}
if (VAR_3 && (VAR_49 || outfilename)) {
error_line (""specifying output file or format and verify mode are incompatible!"");
++VAR_4;
}
if (VAR_3 > 1 && VAR_70) {
error_line (""can't calculate MD5s in quick verify mode!"");
++VAR_4;
}
if (VAR_7 == 1) {
if (VAR_73) {
error_line (""can't extract more than 1 tag item to stdout at a time!"");
VAR_4++;
}
else {
VAR_73 = ""cuesheet"";
VAR_67 = 1;
}
}
if ((VAR_68 || VAR_65) && (VAR_75 || outfilename || VAR_3 || VAR_60 || VAR_49)) {
error_line (""can't display file information and do anything else!"");
++VAR_4;
}
if (VAR_73 && (VAR_75 || outfilename || VAR_3 || VAR_60 || VAR_49 || VAR_58)) {
error_line (""can't extract a tag to stdout and do anything else!"");
++VAR_4;
}
if ((VAR_73 || VAR_75) && VAR_16) {
error_line (""can't extract tags when unpacking audio to stdout!"");
++VAR_4;
}
if (strcmp (WavpackGetLibraryVersionString (), VAR_34)) {
fprintf (VAR_76, VAR_77, WavpackGetLibraryVersionString (), VAR_34);
fflush (VAR_76);
}
else if (!VAR_66 && !VAR_4) {
fprintf (VAR_76, VAR_78, VAR_79, WavpackGetLibraryVersionString ());
fflush (VAR_76);
}
if (VAR_4) {
fprintf (VAR_76, ""\ntype 'wvunpack' for short help or 'wvunpack --help' for full help\n"");
fflush (VAR_76);
return 1;
}
if (!VAR_74) {
printf (""%s"", VAR_80);
return 1;
}
setup_break ();
for (VAR_81 = 0; VAR_81 < VAR_74; ++VAR_81) {
char *VAR_82 = VAR_10 [VAR_81];
if (*VAR_82 == '@') {
FILE *VAR_83 = fopen (VAR_82+1, ""rb"");
char *VAR_84 = NULL, *VAR_85;
int VAR_86 = 0, VAR_87, VAR_88;
for (VAR_87 = VAR_81; VAR_87 < VAR_74 - 1; VAR_87++)
VAR_10 [VAR_87] = VAR_10 [VAR_87 + 1];
VAR_81--;
VAR_74--;
if (VAR_83 == NULL) {
error_line (""file %s not found!"", VAR_82+1);
free (VAR_82);
return 1;
}
while (1) {
int VAR_89;
VAR_84 = realloc (VAR_84, VAR_86 + 1024);
memset (VAR_84 + VAR_86, 0, 1024);
VAR_86 += VAR_89 = (int) fread (VAR_84 + VAR_86, 1, 1024, VAR_83);
if (VAR_89 < 1024)
break;
}
#if defined (VAR_20)
VAR_84 = realloc (VAR_84, VAR_86 *= 2);
TextToUTF8 (VAR_84, VAR_86);
#endif
VAR_85 = VAR_84;
while ((VAR_88 = *VAR_85++)) {
while (VAR_88 == '\n' || VAR_88 == '\r')
VAR_88 = *VAR_85++;
if (VAR_88) {
char *VAR_90 = malloc (VAR_14);
int VAR_91 = 0;
do
VAR_90 [VAR_91++] = VAR_88;
while ((VAR_88 = *VAR_85++) != '\n' && VAR_88 != '\r' && VAR_88 && VAR_91 < VAR_14);
VAR_90 [VAR_91++] = '\0';
VAR_10 = realloc (VAR_10, ++VAR_74 * sizeof (*VAR_10));
for (VAR_87 = VAR_74 - 1; VAR_87 > VAR_81 + 1; VAR_87--)
VAR_10 [VAR_87] = VAR_10 [VAR_87 - 1];
VAR_10 [++VAR_81] = VAR_90;
}
if (!VAR_88)
break;
}
fclose (VAR_83);
free (VAR_84);
free (VAR_82);
}
#if defined (VAR_20)
else if (filespec_wild (infilename)) {
wchar_t *VAR_92 = utf8_to_utf16(infilename);
struct _wfinddata_t _wfinddata_t;
intptr_t VAR_93;
int VAR_87;
for (VAR_87 = VAR_81; VAR_87 < VAR_74 - 1; VAR_87++)
VAR_10 [VAR_87] = VAR_10 [VAR_87 + 1];
VAR_81--;
VAR_74--;
if ((VAR_93 = _wfindfirst (VAR_92, &_wfinddata_t)) != (intptr_t) -1) {
do {
char *VAR_94;
if (!(_wfinddata_t.attrib & VAR_95) && (VAR_94 = utf16_to_utf8(_wfinddata_t.name))) {
VAR_10 = realloc (VAR_10, ++VAR_74 * sizeof (*VAR_10));
for (VAR_87 = VAR_74 - 1; VAR_87 > VAR_81 + 1; VAR_87--)
VAR_10 [VAR_87] = VAR_10 [VAR_87 - 1];
VAR_10 [++VAR_81] = malloc (strlen (infilename) + strlen (VAR_94) + 10);
strcpy (VAR_10 [VAR_81], infilename);
*filespec_name (VAR_10 [VAR_81]) = '\0';
strcat (VAR_10 [VAR_81], VAR_94);
free (VAR_94);
}
} while (_wfindnext (VAR_93, &_wfinddata_t) == 0);
_findclose (VAR_93);
}
free (VAR_92);
free (infilename);
}
#endif
}
if (outfilename && outfilename [0] == '@') {
char VAR_84 [VAR_14 * 2], *VAR_96 = VAR_84;
FILE *VAR_83 = fopen (outfilename+1, ""rb"");
int VAR_88;
if (VAR_83 == NULL) {
error_line (""file %s not found!"", outfilename+1);
free(outfilename);
return 1;
}
memset (VAR_84, 0, sizeof (VAR_84));
VAR_88 = (int) fread (VAR_84, 1, sizeof (VAR_84) - 1, VAR_83);   
#if defined (VAR_20)
TextToUTF8 (VAR_84, VAR_14 * 2);
#endif
while ((VAR_88 = *VAR_96++) == '\n' || VAR_88 == '\r');
if (VAR_88) {
int VAR_91 = 0;
do
outfilename [VAR_91++] = VAR_88;
while ((VAR_88 = *VAR_96++) != '\n' && VAR_88 != '\r' && VAR_88 && VAR_91 < VAR_14);
outfilename [VAR_91] = '\0';
}
else {
error_line (""output spec file is empty!"");
free(outfilename);
fclose (VAR_83);
return 1;
}
fclose (VAR_83);
}
if (VAR_74) {
if (outfilename && *outfilename != '-') {
VAR_9 = (filespec_path (outfilename) != NULL);
if (VAR_74 > 1 && !VAR_9) {
error_line (""%s is not a valid output path"", outfilename);
free (outfilename);
return 1;
}
}
else
VAR_9 = 0;
VAR_5 = !outfilename || VAR_9 || !filespec_ext (outfilename);
for (VAR_81 = 0; VAR_81 < VAR_74; ++VAR_81) {
if (check_break ())
break;
if (VAR_9) {
strcat (outfilename, filespec_name (VAR_10 [VAR_81]));
if (filespec_ext (outfilename))
*filespec_ext (outfilename) = '\0';
}
else if (!outfilename) {
outfilename = malloc (strlen (VAR_10 [VAR_81]) + 10);
strcpy (outfilename, VAR_10 [VAR_81]);
if (filespec_ext (outfilename))
*filespec_ext (outfilename) = '\0';
}
if (VAR_74 > 1 && !VAR_66) {
fprintf (VAR_76, ""\n%s:\n"", VAR_10 [VAR_81]);
fflush (VAR_76);
}
if (VAR_3 > 1) {
VAR_19 = quick_verify_file (VAR_10 [VAR_81], VAR_3 > 2);
if (VAR_19 == VAR_97)
VAR_19 = unpack_file (VAR_10 [VAR_81], NULL, 0);
}
else
VAR_19 = unpack_file (VAR_10 [VAR_81], VAR_3 ? NULL : outfilename, VAR_5);
if (VAR_19 != VAR_98)
++VAR_4;
if (VAR_19 == VAR_97)
break;
if (VAR_9)
*filespec_name (outfilename) = '\0';
else if (*outfilename != '-') {
free (outfilename);
outfilename = NULL;
}
free (VAR_10 [VAR_81]);
}
if (VAR_74 > 1) {
if (VAR_4) {
fprintf (VAR_76, ""\n **** warning: errors occurred in %d of %d files! ****\n"", VAR_4, VAR_74);
fflush (VAR_76);
}
else if (!VAR_66) {
fprintf (VAR_76, ""\n **** %d files successfully processed ****\n"", VAR_74);
fflush (VAR_76);
}
}
free (VAR_10);
}
else {
error_line (""nothing to do!"");
++VAR_4;
}
if (outfilename)
free (outfilename);
if (VAR_29)
DoSetConsoleTitle (""WvUnpack Completed"");
return VAR_4 ? 1 : 0;
}",,"static int wvunpack_main(int argc, char **argv)
#else
int main(int argc, char **argv)
#endif
{
#ifdef __EMX__ /* OS/2 */
    _wildcard (&argc, &argv);
#endif
    int verify_only = 0, error_count = 0, add_extension = 0, output_spec = 0, c_count = 0, x_count = 0;
    char outpath, **matches = NULL, *outfilename = NULL, **argv_fn = NULL, selfname [PATH_MAX];
    int use_stdin = 0, use_stdout = 0, argc_fn = 0, argi, result;

#if defined(_WIN32)
    if (!GetModuleFileName (NULL, selfname, sizeof (selfname)))
#endif
    strncpy (selfname, *argv, sizeof (selfname));

    if (filespec_name (selfname)) {
        char *filename = filespec_name (selfname);

        if (strstr (filename, ""ebug"") || strstr (filename, ""DEBUG""))
            debug_logging_mode = TRUE;

        while (strchr (filename, '{')) {
            char *open_brace = strchr (filename, '{');
            char *close_brace = strchr (open_brace, '}');

            if (!close_brace)
                break;

            if (close_brace - open_brace > 1) {
                int option_len = (int)(close_brace - open_brace) - 1;
                char *option = malloc (option_len + 1);

                argv_fn = realloc (argv_fn, sizeof (char *) * ++argc_fn);
                memcpy (option, open_brace + 1, option_len);
                argv_fn [argc_fn - 1] = option;
                option [option_len] = 0;

                if (debug_logging_mode)
                    error_line (""file arg %d: %s"", argc_fn, option);
            }

            filename = close_brace;
        }
    }

    if (debug_logging_mode) {
        char **argv_t = argv;
        int argc_t = argc;

        while (--argc_t)
            error_line (""cli arg %d: %s"", argc - argc_t, *++argv_t);
    }

#if defined (_WIN32)
    set_console_title = 1;      // on Windows, we default to messing with the console title
#endif                          // on Linux, this is considered uncool to do by default

    // loop through command-line arguments

    for (argi = 0; argi < argc + argc_fn - 1; ++argi) {
        char *argcp;

        if (argi < argc_fn)
            argcp = argv_fn [argi];
        else
            argcp = argv [argi - argc_fn + 1];

        if (argcp [0] == '-' && argcp [1] == '-' && argcp [2]) {
            char *long_option = argcp + 2, *long_param = long_option;

            while (*long_param)
                if (*long_param++ == '=')
                    break;

            if (!strcmp (long_option, ""help"")) {                        // --help
                printf (""%s"", help);
                return 0;
            }
            else if (!strcmp (long_option, ""version"")) {                // --version
                printf (""wvunpack %s\n"", PACKAGE_VERSION);
                printf (""libwavpack %s\n"", WavpackGetLibraryVersionString ());
                return 0;
            }
#ifdef _WIN32
            else if (!strcmp (long_option, ""pause""))                    // --pause
                pause_mode = 1;
            else if (!strcmp (long_option, ""drop""))                     // --drop
                drop_mode = 1;
#endif
            else if (!strcmp (long_option, ""normalize-floats""))         // --normalize-floats
                normalize_floats = 1;
            else if (!strcmp (long_option, ""no-utf8-convert""))          // --no-utf8-convert
                no_utf8_convert = 1;
            else if (!strncmp (long_option, ""skip"", 4)) {               // --skip
                parse_sample_time_index (&skip, long_param);

                if (!skip.value_is_valid) {
                    error_line (""invalid --skip parameter!"");
                    ++error_count;
                }
            }
            else if (!strncmp (long_option, ""until"", 5)) {              // --until
                parse_sample_time_index (&until, long_param);

                if (!until.value_is_valid) {
                    error_line (""invalid --until parameter!"");
                    ++error_count;
                }
            }
            else if (!strcmp (long_option, ""caf-be"")) {                 // --caf-be
                decode_format = WP_FORMAT_CAF;
                caf_be = format_specified = 1;
            }
            else if (!strcmp (long_option, ""caf-le"")) {                 // --caf-le
                decode_format = WP_FORMAT_CAF;
                format_specified = 1;
            }
            else if (!strcmp (long_option, ""dsf"")) {                    // --dsf
                decode_format = WP_FORMAT_DSF;
                format_specified = 1;
            }
            else if (!strcmp (long_option, ""dsdiff"") || !strcmp (long_option, ""dff"")) {
                decode_format = WP_FORMAT_DFF;                          // --dsdiff or --dff
                format_specified = 1;
            }
            else if (!strcmp (long_option, ""w64"")) {                    // --w64
                decode_format = WP_FORMAT_W64;
                format_specified = 1;
            }
            else if (!strcmp (long_option, ""wav"")) {                    // --wav
                decode_format = WP_FORMAT_WAV;
                format_specified = 1;
            }
            else if (!strcmp (long_option, ""raw-pcm""))                  // --raw-pcm
                raw_pcm = raw_decode = 1;
            else if (!strcmp (long_option, ""raw""))                      // --raw
                raw_decode = 1;
            else {
                error_line (""unknown option: %s !"", long_option);
                ++error_count;
            }
        }
#if defined (_WIN32)
        else if ((argcp [0] == '-' || argcp [0] == '/') && argcp [1])
#else
        else if (argcp [0] == '-' && argcp [1])
#endif
            while (*++argcp)
                switch (*argcp) {
                    case 'Y': case 'y':
                        overwrite_all = 1;
                        break;

                    case 'C': case 'c':
                        if (++c_count == 2) {
                            add_tag_extraction_to_list (""cuesheet=%a.cue"");
                            c_count = 0;
                        }

                        break;

                    case 'D': case 'd':
                        delete_source = 1;
                        break;

#if defined (_WIN32)
                    case 'L': case 'l':
                        SetPriorityClass (GetCurrentProcess(), IDLE_PRIORITY_CLASS);
                        break;
#elif defined (__OS2__)
                    case 'L': case 'l':
                        DosSetPriority (0, PRTYC_IDLETIME, 0, 0);
                        break;
#endif
#if defined (_WIN32)
                    case 'O': case 'o':  // ignore -o in Windows to be Linux compatible
                        break;
#else
                    case 'O': case 'o':
                        output_spec = 1;
                        break;
#endif
                    case 'T': case 't':
                        copy_time = 1;
                        break;

                    case 'V': case 'v':
                        ++verify_only;
                        break;

                    case 'F': case 'f':
                        file_info = (char) strtol (++argcp, &argcp, 10);

                        if (file_info < 0 || file_info > 10) {
                            error_line (""-f option must be 1-10, or omit (or 0) for all!"");
                            ++error_count;
                        }
                        else {
                            quiet_mode = no_audio_decode = 1;
                            file_info++;
                        }

                        --argcp;
                        break;

                    case 'S': case 's':
                        no_audio_decode = 1;
                        ++summary;
                        break;

                    case 'K': case 'k':
                        outbuf_k = strtol (++argcp, &argcp, 10);

                        if (outbuf_k < 1 || outbuf_k > 16384)       // range-check for reasonable values
                            outbuf_k = 0;

                        --argcp;
                        break;

                    case 'M': case 'm':
                        calc_md5 = 1;
                        break;

                    case 'B': case 'b':
                        blind_decode = 1;
                        break;

                    case 'N': case 'n':
                        no_audio_decode = 1;
                        break;

                    case 'R': case 'r':
                        raw_decode = 1;
                        break;

                    case 'W': case 'w':
                        decode_format = WP_FORMAT_WAV;
                        format_specified = 1;
                        break;

                    case 'Q': case 'q':
                        quiet_mode = 1;
                        break;

                    case 'Z': case 'z':
                        set_console_title = (char) strtol (++argcp, &argcp, 10);
                        --argcp;
                        break;

                    case 'X': case 'x':
                        if (++x_count == 3) {
                            error_line (""illegal option: %s !"", argcp);
                            ++error_count;
                            x_count = 0;
                        }

                        break;

                    case 'I': case 'i':
                        ignore_wvc = 1;
                        break;

                    default:
                        error_line (""illegal option: %c !"", *argcp);
                        ++error_count;
                }
        else if (argi < argc_fn) {
            error_line (""invalid use of filename-embedded args: %s !"", argcp);
            ++error_count;
        }
        else {
            if (x_count) {
                if (x_count == 1) {
                    if (tag_extract_stdout) {
                        error_line (""can't extract more than 1 tag item to stdout at a time!"");
                        ++error_count;
                    }
                    else {
                        tag_extract_stdout = argcp;
                        no_audio_decode = 1;
                    }
                }
                else if (x_count == 2)
                    add_tag_extraction_to_list (argcp);

                x_count = 0;
            }
#if defined (_WIN32)
            else if (drop_mode || !num_files) {
                matches = realloc (matches, (num_files + 1) * sizeof (*matches));
                matches [num_files] = malloc (strlen (argcp) + 10);
                strcpy (matches [num_files], argcp);
                use_stdin |= (*argcp == '-');

                if (*(matches [num_files]) != '-' && *(matches [num_files]) != '@' &&
                    !filespec_ext (matches [num_files]))
                        strcat (matches [num_files], "".wv"");

                num_files++;
            }
            else if (!outfilename) {
                outfilename = malloc (strlen (argcp) + PATH_MAX);
                strcpy (outfilename, argcp);
                use_stdout = (*argcp == '-');
            }
            else {
                error_line (""extra unknown argument: %s !"", argcp);
                ++error_count;
            }
#else
            else if (output_spec) {
                outfilename = malloc (strlen (argcp) + PATH_MAX);
                strcpy (outfilename, argcp);
                use_stdout = (*argcp == '-');
                output_spec = 0;
            }
            else {
                matches = realloc (matches, (num_files + 1) * sizeof (*matches));
                matches [num_files] = malloc (strlen (argcp) + 10);
                strcpy (matches [num_files], argcp);
                use_stdin |= (*argcp == '-');

                if (*(matches [num_files]) != '-' && *(matches [num_files]) != '@' &&
                    !filespec_ext (matches [num_files]))
                        strcat (matches [num_files], "".wv"");

                num_files++;
            }
#endif
        }

        if (argi < argc_fn)
            free (argv_fn [argi]);
    }

    free (argv_fn);

   // check for various command-line argument problems

    if (output_spec) {
        error_line (""no output filename or path specified with -o option!"");
        ++error_count;
    }

    if (use_stdin && num_files > 1) {
        error_line (""when stdin is used for input, it must be the only file!"");
        ++error_count;
    }

    if (use_stdin && !outfilename)  // for stdin source, no output specification implies stdout
        use_stdout = 1;

    if (delete_source && (verify_only || skip.value_is_valid || until.value_is_valid)) {
        error_line (""can't delete in verify mode or when --skip or --until are used!"");
        delete_source = 0;
    }

    if (raw_decode && format_specified) {
        error_line (""-r (raw decode) and specifying a format (like -w) are incompatible!"");
        ++error_count;
    }

    if (verify_only && (format_specified || outfilename)) {
        error_line (""specifying output file or format and verify mode are incompatible!"");
        ++error_count;
    }

    if (verify_only > 1 && calc_md5) {
        error_line (""can't calculate MD5s in quick verify mode!"");
        ++error_count;
    }

    if (c_count == 1) {
        if (tag_extract_stdout) {
            error_line (""can't extract more than 1 tag item to stdout at a time!"");
            error_count++;
        }
        else {
            tag_extract_stdout = ""cuesheet"";
            no_audio_decode = 1;
        }
    }

    if ((summary || file_info) && (num_tag_extractions || outfilename || verify_only || delete_source || format_specified)) {
        error_line (""can't display file information and do anything else!"");
        ++error_count;
    }

    if (tag_extract_stdout && (num_tag_extractions || outfilename || verify_only || delete_source || format_specified || raw_decode)) {
        error_line (""can't extract a tag to stdout and do anything else!"");
        ++error_count;
    }

    if ((tag_extract_stdout || num_tag_extractions) && use_stdout) {
        error_line (""can't extract tags when unpacking audio to stdout!"");
        ++error_count;
    }

    if (strcmp (WavpackGetLibraryVersionString (), PACKAGE_VERSION)) {
        fprintf (stderr, version_warning, WavpackGetLibraryVersionString (), PACKAGE_VERSION);
        fflush (stderr);
    }
    else if (!quiet_mode && !error_count) {
        fprintf (stderr, sign_on, VERSION_OS, WavpackGetLibraryVersionString ());
        fflush (stderr);
    }

    if (error_count) {
        fprintf (stderr, ""\ntype 'wvunpack' for short help or 'wvunpack --help' for full help\n"");
        fflush (stderr);
        return 1;
    }

    if (!num_files) {
        printf (""%s"", usage);
        return 1;
    }

    setup_break ();

    for (file_index = 0; file_index < num_files; ++file_index) {
        char *infilename = matches [file_index];

        // If the single infile specification begins with a '@', then it
        // actually points to a file that contains the names of the files
        // to be converted. This was included for use by Wim Speekenbrink's
        // frontends, but could be used for other purposes.

        if (*infilename == '@') {
            FILE *list = fopen (infilename+1, ""rb"");
            char *listbuff = NULL, *cp;
            int listbytes = 0, di, c;

            for (di = file_index; di < num_files - 1; di++)
                matches [di] = matches [di + 1];

            file_index--;
            num_files--;

            if (list == NULL) {
                error_line (""file %s not found!"", infilename+1);
                free (infilename);
                return 1;
            }

            while (1) {
                int bytes_read;

                listbuff = realloc (listbuff, listbytes + 1024);
                memset (listbuff + listbytes, 0, 1024);
                listbytes += bytes_read = (int) fread (listbuff + listbytes, 1, 1024, list);

                if (bytes_read < 1024)
                    break;
            }

#if defined (_WIN32)
            listbuff = realloc (listbuff, listbytes *= 2);
            TextToUTF8 (listbuff, listbytes);
#endif
            cp = listbuff;

            while ((c = *cp++)) {

                while (c == '\n' || c == '\r')
                    c = *cp++;

                if (c) {
                    char *fname = malloc (PATH_MAX);
                    int ci = 0;

                    do
                        fname [ci++] = c;
                    while ((c = *cp++) != '\n' && c != '\r' && c && ci < PATH_MAX);

                    fname [ci++] = '\0';
                    matches = realloc (matches, ++num_files * sizeof (*matches));

                    for (di = num_files - 1; di > file_index + 1; di--)
                        matches [di] = matches [di - 1];

                    matches [++file_index] = fname;
                }

                if (!c)
                    break;
            }

            fclose (list);
            free (listbuff);
            free (infilename);
        }
#if defined (_WIN32)
        else if (filespec_wild (infilename)) {
            wchar_t *winfilename = utf8_to_utf16(infilename);
            struct _wfinddata_t _wfinddata_t;
            intptr_t file;
            int di;

            for (di = file_index; di < num_files - 1; di++)
                matches [di] = matches [di + 1];

            file_index--;
            num_files--;

            if ((file = _wfindfirst (winfilename, &_wfinddata_t)) != (intptr_t) -1) {
                do {
                    char *name_utf8;

                    if (!(_wfinddata_t.attrib & _A_SUBDIR) && (name_utf8 = utf16_to_utf8(_wfinddata_t.name))) {
                        matches = realloc (matches, ++num_files * sizeof (*matches));

                        for (di = num_files - 1; di > file_index + 1; di--)
                            matches [di] = matches [di - 1];

                        matches [++file_index] = malloc (strlen (infilename) + strlen (name_utf8) + 10);
                        strcpy (matches [file_index], infilename);
                        *filespec_name (matches [file_index]) = '\0';
                        strcat (matches [file_index], name_utf8);
                        free (name_utf8);
                    }
                } while (_wfindnext (file, &_wfinddata_t) == 0);

                _findclose (file);
            }

            free (winfilename);
            free (infilename);
        }
#endif
    }

    // If the outfile specification begins with a '@', then it actually points
    // to a file that contains the output specification. This was included for
    // use by Wim Speekenbrink's frontends because certain filenames could not
    // be passed on the command-line, but could be used for other purposes.

    if (outfilename && outfilename [0] == '@') {
        char listbuff [PATH_MAX * 2], *lp = listbuff;
        FILE *list = fopen (outfilename+1, ""rb"");
        int c;

        if (list == NULL) {
            error_line (""file %s not found!"", outfilename+1);
            free(outfilename);
            return 1;
        }

        memset (listbuff, 0, sizeof (listbuff));
        c = (int) fread (listbuff, 1, sizeof (listbuff) - 1, list);   // assign c only to suppress warning

#if defined (_WIN32)
        TextToUTF8 (listbuff, PATH_MAX * 2);
#endif

        while ((c = *lp++) == '\n' || c == '\r');

        if (c) {
            int ci = 0;

            do
                outfilename [ci++] = c;
            while ((c = *lp++) != '\n' && c != '\r' && c && ci < PATH_MAX);

            outfilename [ci] = '\0';
        }
        else {
            error_line (""output spec file is empty!"");
            free(outfilename);
            fclose (list);
            return 1;
        }

        fclose (list);
    }

    // if we found any files to process, this is where we start

    if (num_files) {
        if (outfilename && *outfilename != '-') {
            outpath = (filespec_path (outfilename) != NULL);

            if (num_files > 1 && !outpath) {
                error_line (""%s is not a valid output path"", outfilename);
                free (outfilename);
                return 1;
            }
        }
        else
            outpath = 0;

        add_extension = !outfilename || outpath || !filespec_ext (outfilename);

        // loop through and process files in list

        for (file_index = 0; file_index < num_files; ++file_index) {
            if (check_break ())
                break;

            // generate output filename

            if (outpath) {
                strcat (outfilename, filespec_name (matches [file_index]));

                if (filespec_ext (outfilename))
                    *filespec_ext (outfilename) = '\0';
            }
            else if (!outfilename) {
                outfilename = malloc (strlen (matches [file_index]) + 10);
                strcpy (outfilename, matches [file_index]);

                if (filespec_ext (outfilename))
                    *filespec_ext (outfilename) = '\0';
            }

            if (num_files > 1 && !quiet_mode) {
                fprintf (stderr, ""\n%s:\n"", matches [file_index]);
                fflush (stderr);
            }

            if (verify_only > 1) {
                result = quick_verify_file (matches [file_index], verify_only > 2);

                // quick_verify_file() returns hard error to mean file cannot be quickly verified
                // because it has no block checksums, so fall back to standard slow verify

                if (result == WAVPACK_HARD_ERROR)
                    result = unpack_file (matches [file_index], NULL, 0);
            }
            else
                result = unpack_file (matches [file_index], verify_only ? NULL : outfilename, add_extension);

            if (result != WAVPACK_NO_ERROR)
                ++error_count;

            if (result == WAVPACK_HARD_ERROR)
                break;

            // clean up in preparation for potentially another file

            if (outpath) {
                if (filespec_name (outfilename))
                    *filespec_name (outfilename) = '\0';
            }
            else if (*outfilename != '-') {
                free (outfilename);
                outfilename = NULL;
            }

            free (matches [file_index]);
        }

        if (num_files > 1) {
            if (error_count) {
                fprintf (stderr, ""\n **** warning: errors occurred in %d of %d files! ****\n"", error_count, num_files);
                fflush (stderr);
            }
            else if (!quiet_mode) {
                fprintf (stderr, ""\n **** %d files successfully processed ****\n"", num_files);
                fflush (stderr);
            }
        }

        free (matches);
    }
    else {
        error_line (""nothing to do!"");
        ++error_count;
    }

    if (outfilename)
        free (outfilename);

    if (set_console_title)
        DoSetConsoleTitle (""WvUnpack Completed"");

    return error_count ? 1 : 0;
}","static int wvunpack_main(int VAR_0, char **VAR_1)
#else
int main(int VAR_0, char **VAR_1)
#endif
{
#ifdef VAR_2 /* COMMENT_0 */
    _wildcard (&VAR_0, &VAR_1);
#endif
    int VAR_3 = 0, VAR_4 = 0, VAR_5 = 0, VAR_6 = 0, VAR_7 = 0, VAR_8 = 0;
    char VAR_9, **VAR_10 = NULL, *VAR_11 = NULL, **VAR_12 = NULL, VAR_13 [VAR_14];
    int VAR_15 = 0, VAR_16 = 0, VAR_17 = 0, VAR_18, VAR_19;

#if defined(VAR_20)
    if (!GetModuleFileName (NULL, VAR_13, sizeof (VAR_13)))
#endif
    strncpy (VAR_13, *VAR_1, sizeof (VAR_13));

    if (filespec_name (VAR_13)) {
        char *VAR_21 = filespec_name (VAR_13);

        if (strstr (VAR_21, ""ebug"") || strstr (VAR_21, ""DEBUG""))
            VAR_22 = TRUE;

        while (strchr (VAR_21, '{')) {
            char *VAR_23 = strchr (VAR_21, '{');
            char *VAR_24 = strchr (VAR_23, '}');

            if (!VAR_24)
                break;

            if (VAR_24 - VAR_23 > 1) {
                int VAR_25 = (int)(VAR_24 - VAR_23) - 1;
                char *VAR_26 = malloc (VAR_25 + 1);

                VAR_12 = realloc (VAR_12, sizeof (char *) * ++VAR_17);
                memcpy (VAR_26, VAR_23 + 1, VAR_25);
                VAR_12 [VAR_17 - 1] = VAR_26;
                VAR_26 [VAR_25] = 0;

                if (VAR_22)
                    error_line (""file arg %d: %s"", VAR_17, VAR_26);
            }

            VAR_21 = VAR_24;
        }
    }

    if (VAR_22) {
        char **VAR_27 = VAR_1;
        int VAR_28 = VAR_0;

        while (--VAR_28)
            error_line (""cli arg %d: %s"", VAR_0 - VAR_28, *++VAR_27);
    }

#if defined (VAR_20)
    VAR_29 = 1;      /* COMMENT_1 */
#endif                          /* COMMENT_2 */

    /* COMMENT_3 */

    for (VAR_18 = 0; VAR_18 < VAR_0 + VAR_17 - 1; ++VAR_18) {
        char *VAR_30;

        if (VAR_18 < VAR_17)
            VAR_30 = VAR_12 [VAR_18];
        else
            VAR_30 = VAR_1 [VAR_18 - VAR_17 + 1];

        if (VAR_30 [0] == '-' && VAR_30 [1] == '-' && VAR_30 [2]) {
            char *VAR_31 = VAR_30 + 2, *VAR_32 = VAR_31;

            while (*VAR_32)
                if (*VAR_32++ == '=')
                    break;

            if (!strcmp (VAR_31, ""help"")) {                        /* COMMENT_4 */
                printf (""%s"", VAR_33);
                return 0;
            }
            else if (!strcmp (VAR_31, ""version"")) {                /* COMMENT_5 */
                printf (""wvunpack %s\n"", VAR_34);
                printf (""libwavpack %s\n"", WavpackGetLibraryVersionString ());
                return 0;
            }
#ifdef VAR_20
            else if (!strcmp (long_option, ""pause""))                    /* COMMENT_6 */
                VAR_35 = 1;
            else if (!strcmp (long_option, ""drop""))                     /* COMMENT_7 */
                VAR_36 = 1;
#endif
            else if (!strcmp (long_option, ""VAR_37-VAR_38""))         /* COMMENT_8 */
                VAR_39 = 1;
            else if (!strcmp (long_option, ""VAR_40-VAR_41-VAR_42""))          /* COMMENT_9 */
                VAR_43 = 1;
            else if (!strncmp (long_option, ""skip"", 4)) {               /* COMMENT_10 */
                parse_sample_time_index (&skip, VAR_32);

                if (!skip.value_is_valid) {
                    error_line (""invalid --skip parameter!"");
                    ++VAR_4;
                }
            }
            else if (!strncmp (long_option, ""until"", 5)) {              /* COMMENT_11 */
                parse_sample_time_index (&until, VAR_32);

                if (!until.value_is_valid) {
                    error_line (""invalid --until parameter!"");
                    ++VAR_4;
                }
            }
            else if (!strcmp (long_option, ""VAR_44-VAR_45"")) {                 /* COMMENT_12 */
                VAR_46 = VAR_47;
                VAR_48 = VAR_49 = 1;
            }
            else if (!strcmp (long_option, ""VAR_44-VAR_50"")) {                 /* COMMENT_13 */
                VAR_46 = VAR_47;
                VAR_49 = 1;
            }
            else if (!strcmp (long_option, ""dsf"")) {                    /* COMMENT_14 */
                VAR_46 = VAR_51;
                VAR_49 = 1;
            }
            else if (!strcmp (long_option, ""dsdiff"") || !strcmp (long_option, ""dff"")) {
                VAR_46 = VAR_52;                          /* COMMENT_15 */
                VAR_49 = 1;
            }
            else if (!strcmp (long_option, ""w64"")) {                    /* COMMENT_16 */
                VAR_46 = VAR_53;
                VAR_49 = 1;
            }
            else if (!strcmp (long_option, ""wav"")) {                    /* COMMENT_17 */
                VAR_46 = VAR_54;
                VAR_49 = 1;
            }
            else if (!strcmp (long_option, ""VAR_55-VAR_56""))                  /* COMMENT_18 */
                VAR_57 = VAR_58 = 1;
            else if (!strcmp (long_option, ""raw""))                      /* COMMENT_19 */
                VAR_58 = 1;
            else {
                error_line (""unknown option: %s !"", long_option);
                ++VAR_4;
            }
        }
#if defined (VAR_20)
        else if ((argcp [0] == '-' || argcp [0] == '/') && argcp [1])
#else
        else if (argcp [0] == '-' && argcp [1])
#endif
            while (*++argcp)
                switch (*argcp) {
                    case 'Y': case 'y':
                        VAR_59 = 1;
                        break;

                    case 'C': case 'c':
                        if (++VAR_7 == 2) {
                            add_tag_extraction_to_list (""cuesheet=%a.cue"");
                            VAR_7 = 0;
                        }

                        break;

                    case 'D': case 'd':
                        VAR_60 = 1;
                        break;

#if defined (VAR_20)
                    case 'L': case 'l':
                        SetPriorityClass (GetCurrentProcess(), VAR_61);
                        break;
#elif defined (VAR_62)
                    case 'L': case 'l':
                        DosSetPriority (0, VAR_63, 0, 0);
                        break;
#endif
#if defined (VAR_20)
                    case 'O': case 'o':  /* COMMENT_20 */
                        break;
#else
                    case 'O': case 'o':
                        VAR_6 = 1;
                        break;
#endif
                    case 'T': case 't':
                        VAR_64 = 1;
                        break;

                    case 'V': case 'v':
                        ++VAR_3;
                        break;

                    case 'F': case 'f':
                        VAR_65 = (char) strtol (++argcp, &argcp, 10);

                        if (VAR_65 < 0 || VAR_65 > 10) {
                            error_line (""-f option must be 1-10, or omit (or 0) for all!"");
                            ++VAR_4;
                        }
                        else {
                            VAR_66 = VAR_67 = 1;
                            VAR_65++;
                        }

                        --argcp;
                        break;

                    case 'S': case 's':
                        VAR_67 = 1;
                        ++VAR_68;
                        break;

                    case 'K': case 'k':
                        VAR_69 = strtol (++argcp, &argcp, 10);

                        if (VAR_69 < 1 || VAR_69 > 16384)       /* COMMENT_21 */
                            VAR_69 = 0;

                        --argcp;
                        break;

                    case 'M': case 'm':
                        VAR_70 = 1;
                        break;

                    case 'B': case 'b':
                        VAR_71 = 1;
                        break;

                    case 'N': case 'n':
                        VAR_67 = 1;
                        break;

                    case 'R': case 'r':
                        VAR_58 = 1;
                        break;

                    case 'W': case 'w':
                        VAR_46 = VAR_54;
                        VAR_49 = 1;
                        break;

                    case 'Q': case 'q':
                        VAR_66 = 1;
                        break;

                    case 'Z': case 'z':
                        VAR_29 = (char) strtol (++argcp, &argcp, 10);
                        --argcp;
                        break;

                    case 'X': case 'x':
                        if (++VAR_8 == 3) {
                            error_line (""illegal option: %s !"", argcp);
                            ++VAR_4;
                            VAR_8 = 0;
                        }

                        break;

                    case 'I': case 'i':
                        VAR_72 = 1;
                        break;

                    default:
                        error_line (""illegal option: %c !"", *argcp);
                        ++VAR_4;
                }
        else if (argi < VAR_17) {
            error_line (""invalid use of filename-embedded args: %s !"", argcp);
            ++VAR_4;
        }
        else {
            if (VAR_8) {
                if (VAR_8 == 1) {
                    if (VAR_73) {
                        error_line (""can't extract more than 1 tag item to stdout at a time!"");
                        ++VAR_4;
                    }
                    else {
                        VAR_73 = argcp;
                        VAR_67 = 1;
                    }
                }
                else if (VAR_8 == 2)
                    add_tag_extraction_to_list (argcp);

                VAR_8 = 0;
            }
#if defined (VAR_20)
            else if (drop_mode || !VAR_74) {
                VAR_10 = realloc (VAR_10, (VAR_74 + 1) * sizeof (*VAR_10));
                VAR_10 [VAR_74] = malloc (strlen (argcp) + 10);
                strcpy (VAR_10 [VAR_74], argcp);
                VAR_15 |= (*argcp == '-');

                if (*(VAR_10 [VAR_74]) != '-' && *(VAR_10 [VAR_74]) != '@' &&
                    !filespec_ext (VAR_10 [VAR_74]))
                        strcat (VAR_10 [VAR_74], "".wv"");

                VAR_74++;
            }
            else if (!outfilename) {
                outfilename = malloc (strlen (argcp) + VAR_14);
                strcpy (outfilename, argcp);
                VAR_16 = (*argcp == '-');
            }
            else {
                error_line (""extra unknown argument: %s !"", argcp);
                ++VAR_4;
            }
#else
            else if (output_spec) {
                outfilename = malloc (strlen (argcp) + VAR_14);
                strcpy (outfilename, argcp);
                VAR_16 = (*argcp == '-');
                output_spec = 0;
            }
            else {
                VAR_10 = realloc (VAR_10, (VAR_74 + 1) * sizeof (*VAR_10));
                VAR_10 [VAR_74] = malloc (strlen (argcp) + 10);
                strcpy (VAR_10 [VAR_74], argcp);
                VAR_15 |= (*argcp == '-');

                if (*(VAR_10 [VAR_74]) != '-' && *(VAR_10 [VAR_74]) != '@' &&
                    !filespec_ext (VAR_10 [VAR_74]))
                        strcat (VAR_10 [VAR_74], "".wv"");

                VAR_74++;
            }
#endif
        }

        if (argi < VAR_17)
            free (VAR_12 [argi]);
    }

    free (VAR_12);

   /* COMMENT_22 */

    if (output_spec) {
        error_line (""no output filename or path specified with -o option!"");
        ++VAR_4;
    }

    if (VAR_15 && VAR_74 > 1) {
        error_line (""when stdin is used for input, it must be the only file!"");
        ++VAR_4;
    }

    if (VAR_15 && !outfilename)  /* COMMENT_23 */
        VAR_16 = 1;

    if (VAR_60 && (VAR_3 || skip.value_is_valid || until.value_is_valid)) {
        error_line (""can't delete in verify mode or when --skip or --until are used!"");
        VAR_60 = 0;
    }

    if (VAR_58 && VAR_49) {
        error_line (""-r (raw decode) and specifying a format (like -w) are incompatible!"");
        ++VAR_4;
    }

    if (VAR_3 && (VAR_49 || outfilename)) {
        error_line (""specifying output file or format and verify mode are incompatible!"");
        ++VAR_4;
    }

    if (VAR_3 > 1 && VAR_70) {
        error_line (""can't calculate MD5s in quick verify mode!"");
        ++VAR_4;
    }

    if (VAR_7 == 1) {
        if (VAR_73) {
            error_line (""can't extract more than 1 tag item to stdout at a time!"");
            VAR_4++;
        }
        else {
            VAR_73 = ""cuesheet"";
            VAR_67 = 1;
        }
    }

    if ((VAR_68 || VAR_65) && (VAR_75 || outfilename || VAR_3 || VAR_60 || VAR_49)) {
        error_line (""can't display file information and do anything else!"");
        ++VAR_4;
    }

    if (VAR_73 && (VAR_75 || outfilename || VAR_3 || VAR_60 || VAR_49 || VAR_58)) {
        error_line (""can't extract a tag to stdout and do anything else!"");
        ++VAR_4;
    }

    if ((VAR_73 || VAR_75) && VAR_16) {
        error_line (""can't extract tags when unpacking audio to stdout!"");
        ++VAR_4;
    }

    if (strcmp (WavpackGetLibraryVersionString (), VAR_34)) {
        fprintf (VAR_76, VAR_77, WavpackGetLibraryVersionString (), VAR_34);
        fflush (VAR_76);
    }
    else if (!VAR_66 && !VAR_4) {
        fprintf (VAR_76, VAR_78, VAR_79, WavpackGetLibraryVersionString ());
        fflush (VAR_76);
    }

    if (VAR_4) {
        fprintf (VAR_76, ""\ntype 'wvunpack' for short help or 'wvunpack --help' for full help\n"");
        fflush (VAR_76);
        return 1;
    }

    if (!VAR_74) {
        printf (""%s"", VAR_80);
        return 1;
    }

    setup_break ();

    for (VAR_81 = 0; VAR_81 < VAR_74; ++VAR_81) {
        char *VAR_82 = VAR_10 [VAR_81];

        /* COMMENT_24 */
        /* COMMENT_25 */
        /* COMMENT_26 */
        /* COMMENT_27 */

        if (*VAR_82 == '@') {
            FILE *VAR_83 = fopen (VAR_82+1, ""rb"");
            char *VAR_84 = NULL, *VAR_85;
            int VAR_86 = 0, VAR_87, VAR_88;

            for (VAR_87 = VAR_81; VAR_87 < VAR_74 - 1; VAR_87++)
                VAR_10 [VAR_87] = VAR_10 [VAR_87 + 1];

            VAR_81--;
            VAR_74--;

            if (VAR_83 == NULL) {
                error_line (""file %s not found!"", VAR_82+1);
                free (VAR_82);
                return 1;
            }

            while (1) {
                int VAR_89;

                VAR_84 = realloc (VAR_84, VAR_86 + 1024);
                memset (VAR_84 + VAR_86, 0, 1024);
                VAR_86 += VAR_89 = (int) fread (VAR_84 + VAR_86, 1, 1024, VAR_83);

                if (VAR_89 < 1024)
                    break;
            }

#if defined (VAR_20)
            VAR_84 = realloc (VAR_84, VAR_86 *= 2);
            TextToUTF8 (VAR_84, VAR_86);
#endif
            VAR_85 = VAR_84;

            while ((VAR_88 = *VAR_85++)) {

                while (VAR_88 == '\n' || VAR_88 == '\r')
                    VAR_88 = *VAR_85++;

                if (VAR_88) {
                    char *VAR_90 = malloc (VAR_14);
                    int VAR_91 = 0;

                    do
                        VAR_90 [VAR_91++] = VAR_88;
                    while ((VAR_88 = *VAR_85++) != '\n' && VAR_88 != '\r' && VAR_88 && VAR_91 < VAR_14);

                    VAR_90 [VAR_91++] = '\0';
                    VAR_10 = realloc (VAR_10, ++VAR_74 * sizeof (*VAR_10));

                    for (VAR_87 = VAR_74 - 1; VAR_87 > VAR_81 + 1; VAR_87--)
                        VAR_10 [VAR_87] = VAR_10 [VAR_87 - 1];

                    VAR_10 [++VAR_81] = VAR_90;
                }

                if (!VAR_88)
                    break;
            }

            fclose (VAR_83);
            free (VAR_84);
            free (VAR_82);
        }
#if defined (VAR_20)
        else if (filespec_wild (infilename)) {
            wchar_t *VAR_92 = utf8_to_utf16(infilename);
            struct _wfinddata_t _wfinddata_t;
            intptr_t VAR_93;
            int VAR_87;

            for (VAR_87 = VAR_81; VAR_87 < VAR_74 - 1; VAR_87++)
                VAR_10 [VAR_87] = VAR_10 [VAR_87 + 1];

            VAR_81--;
            VAR_74--;

            if ((VAR_93 = _wfindfirst (VAR_92, &_wfinddata_t)) != (intptr_t) -1) {
                do {
                    char *VAR_94;

                    if (!(_wfinddata_t.attrib & VAR_95) && (VAR_94 = utf16_to_utf8(_wfinddata_t.name))) {
                        VAR_10 = realloc (VAR_10, ++VAR_74 * sizeof (*VAR_10));

                        for (VAR_87 = VAR_74 - 1; VAR_87 > VAR_81 + 1; VAR_87--)
                            VAR_10 [VAR_87] = VAR_10 [VAR_87 - 1];

                        VAR_10 [++VAR_81] = malloc (strlen (infilename) + strlen (VAR_94) + 10);
                        strcpy (VAR_10 [VAR_81], infilename);
                        *filespec_name (VAR_10 [VAR_81]) = '\0';
                        strcat (VAR_10 [VAR_81], VAR_94);
                        free (VAR_94);
                    }
                } while (_wfindnext (VAR_93, &_wfinddata_t) == 0);

                _findclose (VAR_93);
            }

            free (VAR_92);
            free (infilename);
        }
#endif
    }

    /* COMMENT_28 */
    /* COMMENT_29 */
    /* COMMENT_30 */
    /* COMMENT_31 */

    if (outfilename && outfilename [0] == '@') {
        char VAR_84 [VAR_14 * 2], *VAR_96 = VAR_84;
        FILE *VAR_83 = fopen (outfilename+1, ""rb"");
        int VAR_88;

        if (VAR_83 == NULL) {
            error_line (""file %s not found!"", outfilename+1);
            free(outfilename);
            return 1;
        }

        memset (VAR_84, 0, sizeof (VAR_84));
        VAR_88 = (int) fread (VAR_84, 1, sizeof (VAR_84) - 1, VAR_83);   /* COMMENT_32 */

#if defined (VAR_20)
        TextToUTF8 (VAR_84, VAR_14 * 2);
#endif

        while ((VAR_88 = *VAR_96++) == '\n' || VAR_88 == '\r');

        if (VAR_88) {
            int VAR_91 = 0;

            do
                outfilename [VAR_91++] = VAR_88;
            while ((VAR_88 = *VAR_96++) != '\n' && VAR_88 != '\r' && VAR_88 && VAR_91 < VAR_14);

            outfilename [VAR_91] = '\0';
        }
        else {
            error_line (""output spec file is empty!"");
            free(outfilename);
            fclose (VAR_83);
            return 1;
        }

        fclose (VAR_83);
    }

    /* COMMENT_33 */

    if (VAR_74) {
        if (outfilename && *outfilename != '-') {
            VAR_9 = (filespec_path (outfilename) != NULL);

            if (VAR_74 > 1 && !VAR_9) {
                error_line (""%s is not a valid output path"", outfilename);
                free (outfilename);
                return 1;
            }
        }
        else
            VAR_9 = 0;

        VAR_5 = !outfilename || VAR_9 || !filespec_ext (outfilename);

        /* COMMENT_34 */

        for (VAR_81 = 0; VAR_81 < VAR_74; ++VAR_81) {
            if (check_break ())
                break;

            /* COMMENT_35 */

            if (VAR_9) {
                strcat (outfilename, filespec_name (VAR_10 [VAR_81]));

                if (filespec_ext (outfilename))
                    *filespec_ext (outfilename) = '\0';
            }
            else if (!outfilename) {
                outfilename = malloc (strlen (VAR_10 [VAR_81]) + 10);
                strcpy (outfilename, VAR_10 [VAR_81]);

                if (filespec_ext (outfilename))
                    *filespec_ext (outfilename) = '\0';
            }

            if (VAR_74 > 1 && !VAR_66) {
                fprintf (VAR_76, ""\n%s:\n"", VAR_10 [VAR_81]);
                fflush (VAR_76);
            }

            if (VAR_3 > 1) {
                VAR_19 = quick_verify_file (VAR_10 [VAR_81], VAR_3 > 2);

                /* COMMENT_36 */
                /* COMMENT_37 */

                if (VAR_19 == VAR_97)
                    VAR_19 = unpack_file (VAR_10 [VAR_81], NULL, 0);
            }
            else
                VAR_19 = unpack_file (VAR_10 [VAR_81], VAR_3 ? NULL : outfilename, VAR_5);

            if (VAR_19 != VAR_98)
                ++VAR_4;

            if (VAR_19 == VAR_97)
                break;

            /* COMMENT_38 */

            if (VAR_9) {
                if (filespec_name (outfilename))
                    *filespec_name (outfilename) = '\0';
            }
            else if (*outfilename != '-') {
                free (outfilename);
                outfilename = NULL;
            }

            free (VAR_10 [VAR_81]);
        }

        if (VAR_74 > 1) {
            if (VAR_4) {
                fprintf (VAR_76, ""\n **** warning: errors occurred in %d of %d files! ****\n"", VAR_4, VAR_74);
                fflush (VAR_76);
            }
            else if (!VAR_66) {
                fprintf (VAR_76, ""\n **** %d files successfully processed ****\n"", VAR_74);
                fflush (VAR_76);
            }
        }

        free (VAR_10);
    }
    else {
        error_line (""nothing to do!"");
        ++VAR_4;
    }

    if (outfilename)
        free (outfilename);

    if (VAR_29)
        DoSetConsoleTitle (""WvUnpack Completed"");

    return VAR_4 ? 1 : 0;
}",,"--- func_before
+++ func_after
@@ -640,8 +640,10 @@
 
             // clean up in preparation for potentially another file
 
-            if (outpath)
-                *filespec_name (outfilename) = '\0';
+            if (outpath) {
+                if (filespec_name (outfilename))
+                    *filespec_name (outfilename) = '\0';
+            }
             else if (*outfilename != '-') {
                 free (outfilename);
                 outfilename = NULL;","{'deleted_lines': ['            if (outpath)', ""                *filespec_name (outfilename) = '\\0';""], 'added_lines': ['            if (outpath) {', '                if (filespec_name (outfilename))', ""                    *filespec_name (outfilename) = '\\0';"", '            }']}",True,A null pointer dereference bug was found in wavpack-5.4.0 The results from the ASAN log: AddressSanitizer:DEADLYSIGNAL ===================================================================84257==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x561b47a970c6 bp 0x7fff13952fb0 sp 0x7fff1394fca0 T0) ==84257==The signal is caused by a WRITE memory access. ==84257==Hint: address points to the zero page. #0 0x561b47a970c5 in main cli/wvunpack.c:834 #1 0x7efc4f5c0082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) #2 0x561b47a945ed in _start (/usr/local/bin/wvunpack+0xa5ed) AddressSanitizer can not provide additional info. SUMMARY: AddressSanitizer: SEGV cli/wvunpack.c:834 in main ==84257==ABORTING,5.5,MEDIUM,1,test,2022-07-06T01:58:19Z,4
CVE-2022-2476,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,dbry/WavPack,"issue #121: NULL pointer dereference in wvunpack.c

* check for NULL pointer before dereferencing in wvunpack.c
* sanitize custom extensions to be alphanumeric only",25b4a2725d8568212e7cf89ca05ca29d128af7ac,https://github.com/dbry/WavPack/commit/25b4a2725d8568212e7cf89ca05ca29d128af7ac,src/open_utils.c,process_metadata,"static int process_metadata (WavpackContext *wpc, WavpackMetadata *wpmd)
{
WavpackStream *wps = wpc->streams [wpc->current_stream];
switch (wpmd->id) {
case ID_DUMMY:
return TRUE;
case ID_DECORR_TERMS:
return read_decorr_terms (wps, wpmd);
case ID_DECORR_WEIGHTS:
return read_decorr_weights (wps, wpmd);
case ID_DECORR_SAMPLES:
return read_decorr_samples (wps, wpmd);
case ID_ENTROPY_VARS:
return read_entropy_vars (wps, wpmd);
case ID_HYBRID_PROFILE:
return read_hybrid_profile (wps, wpmd);
case ID_SHAPING_WEIGHTS:
return read_shaping_info (wps, wpmd);
case ID_FLOAT_INFO:
return read_float_info (wps, wpmd);
case ID_INT32_INFO:
return read_int32_info (wps, wpmd);
case ID_CHANNEL_INFO:
return read_channel_info (wpc, wpmd);
case ID_CHANNEL_IDENTITIES:
return read_channel_identities (wpc, wpmd);
case ID_CONFIG_BLOCK:
return read_config_info (wpc, wpmd);
case ID_NEW_CONFIG_BLOCK:
return read_new_config_info (wpc, wpmd);
case ID_SAMPLE_RATE:
return read_sample_rate (wpc, wpmd);
case ID_WV_BITSTREAM:
return init_wv_bitstream (wps, wpmd);
case ID_WVC_BITSTREAM:
return init_wvc_bitstream (wps, wpmd);
case ID_WVX_BITSTREAM:
return init_wvx_bitstream (wps, wpmd);
case ID_DSD_BLOCK:
#ifdef ENABLE_DSD
return init_dsd_block (wpc, wpmd);
#else
strcpy (wpc->error_message, ""not configured to handle DSD WavPack files!"");
return FALSE;
#endif
case ID_ALT_HEADER: case ID_ALT_TRAILER:
if (!(wpc->open_flags & OPEN_ALT_TYPES))
return TRUE;
case ID_RIFF_HEADER: case ID_RIFF_TRAILER:
return read_wrapper_data (wpc, wpmd);
case ID_ALT_MD5_CHECKSUM:
if (!(wpc->open_flags & OPEN_ALT_TYPES))
return TRUE;
case ID_MD5_CHECKSUM:
if (wpmd->byte_length == 16) {
memcpy (wpc->config.md5_checksum, wpmd->data, 16);
wpc->config.flags |= CONFIG_MD5_CHECKSUM;
wpc->config.md5_read = 1;
}
return TRUE;
case ID_ALT_EXTENSION:
if (wpmd->byte_length && wpmd->byte_length < sizeof (wpc->file_extension)) {
memcpy (wpc->file_extension, wpmd->data, wpmd->byte_length);
wpc->file_extension [wpmd->byte_length] = 0;
}
return TRUE;
case ID_BLOCK_CHECKSUM:
wpc->version_five = 1;
return TRUE;
default:
return (wpmd->id & ID_OPTIONAL_DATA) ? TRUE : FALSE;
}
}","static int process_metadata (WavpackContext *VAR_0, WavpackMetadata *VAR_1)
{
WavpackStream *VAR_2 = VAR_0->streams [VAR_0->current_stream];
switch (VAR_1->id) {
case VAR_3:
return TRUE;
case VAR_4:
return read_decorr_terms (VAR_2, VAR_1);
case VAR_5:
return read_decorr_weights (VAR_2, VAR_1);
case VAR_6:
return read_decorr_samples (VAR_2, VAR_1);
case VAR_7:
return read_entropy_vars (VAR_2, VAR_1);
case VAR_8:
return read_hybrid_profile (VAR_2, VAR_1);
case VAR_9:
return read_shaping_info (VAR_2, VAR_1);
case VAR_10:
return read_float_info (VAR_2, VAR_1);
case VAR_11:
return read_int32_info (VAR_2, VAR_1);
case VAR_12:
return read_channel_info (VAR_0, VAR_1);
case VAR_13:
return read_channel_identities (VAR_0, VAR_1);
case VAR_14:
return read_config_info (VAR_0, VAR_1);
case VAR_15:
return read_new_config_info (VAR_0, VAR_1);
case VAR_16:
return read_sample_rate (VAR_0, VAR_1);
case VAR_17:
return init_wv_bitstream (VAR_2, VAR_1);
case VAR_18:
return init_wvc_bitstream (VAR_2, VAR_1);
case VAR_19:
return init_wvx_bitstream (VAR_2, VAR_1);
case VAR_20:
#ifdef VAR_21
return init_dsd_block (VAR_0, VAR_1);
#else
strcpy (VAR_0->error_message, ""not configured to handle DSD WavPack files!"");
return FALSE;
#endif
case VAR_22: case VAR_23:
if (!(VAR_0->open_flags & VAR_24))
return TRUE;
case VAR_25: case VAR_26:
return read_wrapper_data (VAR_0, VAR_1);
case VAR_27:
if (!(VAR_0->open_flags & VAR_24))
return TRUE;
case VAR_28:
if (VAR_1->byte_length == 16) {
memcpy (VAR_0->config.md5_checksum, VAR_1->data, 16);
VAR_0->config.flags |= VAR_29;
VAR_0->config.md5_read = 1;
}
return TRUE;
case VAR_30:
if (VAR_1->byte_length && VAR_1->byte_length < sizeof (VAR_0->file_extension)) {
memcpy (VAR_0->file_extension, VAR_1->data, VAR_1->byte_length);
VAR_0->file_extension [VAR_1->byte_length] = 0;
}
return TRUE;
case VAR_31:
VAR_0->version_five = 1;
return TRUE;
default:
return (VAR_1->id & VAR_32) ? TRUE : FALSE;
}
}",dbry/WavPack/25b4a2725d8568212e7cf89ca05ca29d128af7ac/open_utils.c/vul/before/0.json,"static int process_metadata (WavpackContext *wpc, WavpackMetadata *wpmd)
{
    WavpackStream *wps = wpc->streams [wpc->current_stream];

    switch (wpmd->id) {
        case ID_DUMMY:
            return TRUE;

        case ID_DECORR_TERMS:
            return read_decorr_terms (wps, wpmd);

        case ID_DECORR_WEIGHTS:
            return read_decorr_weights (wps, wpmd);

        case ID_DECORR_SAMPLES:
            return read_decorr_samples (wps, wpmd);

        case ID_ENTROPY_VARS:
            return read_entropy_vars (wps, wpmd);

        case ID_HYBRID_PROFILE:
            return read_hybrid_profile (wps, wpmd);

        case ID_SHAPING_WEIGHTS:
            return read_shaping_info (wps, wpmd);

        case ID_FLOAT_INFO:
            return read_float_info (wps, wpmd);

        case ID_INT32_INFO:
            return read_int32_info (wps, wpmd);

        case ID_CHANNEL_INFO:
            return read_channel_info (wpc, wpmd);

        case ID_CHANNEL_IDENTITIES:
            return read_channel_identities (wpc, wpmd);

        case ID_CONFIG_BLOCK:
            return read_config_info (wpc, wpmd);

        case ID_NEW_CONFIG_BLOCK:
            return read_new_config_info (wpc, wpmd);

        case ID_SAMPLE_RATE:
            return read_sample_rate (wpc, wpmd);

        case ID_WV_BITSTREAM:
            return init_wv_bitstream (wps, wpmd);

        case ID_WVC_BITSTREAM:
            return init_wvc_bitstream (wps, wpmd);

        case ID_WVX_BITSTREAM:
            return init_wvx_bitstream (wps, wpmd);

        case ID_DSD_BLOCK:
#ifdef ENABLE_DSD
            return init_dsd_block (wpc, wpmd);
#else
            strcpy (wpc->error_message, ""not configured to handle DSD WavPack files!"");
            return FALSE;
#endif

        case ID_ALT_HEADER: case ID_ALT_TRAILER:
            if (!(wpc->open_flags & OPEN_ALT_TYPES))
                return TRUE;

        case ID_RIFF_HEADER: case ID_RIFF_TRAILER:
            return read_wrapper_data (wpc, wpmd);

        case ID_ALT_MD5_CHECKSUM:
            if (!(wpc->open_flags & OPEN_ALT_TYPES))
                return TRUE;

        case ID_MD5_CHECKSUM:
            if (wpmd->byte_length == 16) {
                memcpy (wpc->config.md5_checksum, wpmd->data, 16);
                wpc->config.flags |= CONFIG_MD5_CHECKSUM;
                wpc->config.md5_read = 1;
            }

            return TRUE;

        case ID_ALT_EXTENSION:
            if (wpmd->byte_length && wpmd->byte_length < sizeof (wpc->file_extension)) {
                int i, j;

                for (i = j = 0; i < wpmd->byte_length; ++i)
                    if (isalnum (((char *) wpmd->data) [i]))
                        wpc->file_extension [j++] = ((char *) wpmd->data) [i];

                wpc->file_extension [j] = 0;
            }

            return TRUE;

        // we don't actually verify the checksum here (it's done right after the
        // block is read), but it's a good indicator of version 5 files

        case ID_BLOCK_CHECKSUM:
            wpc->version_five = 1;
            return TRUE;

        default:
            return (wpmd->id & ID_OPTIONAL_DATA) ? TRUE : FALSE;
    }
}","static int process_metadata (WavpackContext *VAR_0, WavpackMetadata *VAR_1)
{
    WavpackStream *VAR_2 = VAR_0->streams [VAR_0->current_stream];

    switch (VAR_1->id) {
        case VAR_3:
            return TRUE;

        case VAR_4:
            return read_decorr_terms (VAR_2, VAR_1);

        case VAR_5:
            return read_decorr_weights (VAR_2, VAR_1);

        case VAR_6:
            return read_decorr_samples (VAR_2, VAR_1);

        case VAR_7:
            return read_entropy_vars (VAR_2, VAR_1);

        case VAR_8:
            return read_hybrid_profile (VAR_2, VAR_1);

        case VAR_9:
            return read_shaping_info (VAR_2, VAR_1);

        case VAR_10:
            return read_float_info (VAR_2, VAR_1);

        case VAR_11:
            return read_int32_info (VAR_2, VAR_1);

        case VAR_12:
            return read_channel_info (VAR_0, VAR_1);

        case VAR_13:
            return read_channel_identities (VAR_0, VAR_1);

        case VAR_14:
            return read_config_info (VAR_0, VAR_1);

        case VAR_15:
            return read_new_config_info (VAR_0, VAR_1);

        case VAR_16:
            return read_sample_rate (VAR_0, VAR_1);

        case VAR_17:
            return init_wv_bitstream (VAR_2, VAR_1);

        case VAR_18:
            return init_wvc_bitstream (VAR_2, VAR_1);

        case VAR_19:
            return init_wvx_bitstream (VAR_2, VAR_1);

        case VAR_20:
#ifdef VAR_21
            return init_dsd_block (VAR_0, VAR_1);
#else
            strcpy (VAR_0->error_message, ""not configured to handle DSD WavPack files!"");
            return FALSE;
#endif

        case VAR_22: case VAR_23:
            if (!(VAR_0->open_flags & VAR_24))
                return TRUE;

        case VAR_25: case VAR_26:
            return read_wrapper_data (VAR_0, VAR_1);

        case VAR_27:
            if (!(VAR_0->open_flags & VAR_24))
                return TRUE;

        case VAR_28:
            if (VAR_1->byte_length == 16) {
                memcpy (VAR_0->config.md5_checksum, VAR_1->data, 16);
                VAR_0->config.flags |= VAR_29;
                VAR_0->config.md5_read = 1;
            }

            return TRUE;

        case VAR_30:
            if (VAR_1->byte_length && VAR_1->byte_length < sizeof (VAR_0->file_extension)) {
                int VAR_31, VAR_32;

                for (VAR_31 = VAR_32 = 0; VAR_31 < VAR_1->byte_length; ++VAR_31)
                    if (isalnum (((char *) VAR_1->data) [VAR_31]))
                        VAR_0->file_extension [VAR_32++] = ((char *) VAR_1->data) [VAR_31];

                VAR_0->file_extension [VAR_32] = 0;
            }

            return TRUE;

        /* COMMENT_0 */
        /* COMMENT_1 */

        case VAR_33:
            VAR_0->version_five = 1;
            return TRUE;

        default:
            return (VAR_1->id & VAR_34) ? TRUE : FALSE;
    }
}",dbry/WavPack/25b4a2725d8568212e7cf89ca05ca29d128af7ac/open_utils.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -84,8 +84,13 @@
 
         case ID_ALT_EXTENSION:
             if (wpmd->byte_length && wpmd->byte_length < sizeof (wpc->file_extension)) {
-                memcpy (wpc->file_extension, wpmd->data, wpmd->byte_length);
-                wpc->file_extension [wpmd->byte_length] = 0;
+                int i, j;
+
+                for (i = j = 0; i < wpmd->byte_length; ++i)
+                    if (isalnum (((char *) wpmd->data) [i]))
+                        wpc->file_extension [j++] = ((char *) wpmd->data) [i];
+
+                wpc->file_extension [j] = 0;
             }
 
             return TRUE;","{'deleted_lines': ['                memcpy (wpc->file_extension, wpmd->data, wpmd->byte_length);', '                wpc->file_extension [wpmd->byte_length] = 0;'], 'added_lines': ['                int i, j;', '', '                for (i = j = 0; i < wpmd->byte_length; ++i)', '                    if (isalnum (((char *) wpmd->data) [i]))', '                        wpc->file_extension [j++] = ((char *) wpmd->data) [i];', '', '                wpc->file_extension [j] = 0;']}",True,A null pointer dereference bug was found in wavpack-5.4.0 The results from the ASAN log: AddressSanitizer:DEADLYSIGNAL ===================================================================84257==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x561b47a970c6 bp 0x7fff13952fb0 sp 0x7fff1394fca0 T0) ==84257==The signal is caused by a WRITE memory access. ==84257==Hint: address points to the zero page. #0 0x561b47a970c5 in main cli/wvunpack.c:834 #1 0x7efc4f5c0082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) #2 0x561b47a945ed in _start (/usr/local/bin/wvunpack+0xa5ed) AddressSanitizer can not provide additional info. SUMMARY: AddressSanitizer: SEGV cli/wvunpack.c:834 in main ==84257==ABORTING,5.5,MEDIUM,1,test,2022-07-06T01:58:19Z,4
CVE-2022-2345,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,vim,"patch 9.0.0047: using freed memory with recursive substitute

Problem:    Using freed memory with recursive substitute.
Solution:   Always make a copy for reg_prev_sub.",32acf1f1a72ebb9d8942b9c9d80023bf1bb668ea,https://github.com/vim/vim/commit/32acf1f1a72ebb9d8942b9c9d80023bf1bb668ea,src/regexp.c,regtilde,"char_u *
regtilde(char_u *source, int magic)
{
char_u*newsub = source;
char_u*tmpsub;
char_u*p;
intlen;
intprevlen;
for (p = newsub; *p; ++p)
{
if ((*p == '~' && magic) || (*p == '\\' && *(p + 1) == '~' && !magic))
{
if (reg_prev_sub != NULL)
{
prevlen = (int)STRLEN(reg_prev_sub);
tmpsub = alloc(STRLEN(newsub) + prevlen);
if (tmpsub != NULL)
{
len = (int)(p - newsub);    mch_memmove(tmpsub, newsub, (size_t)len);
mch_memmove(tmpsub + len, reg_prev_sub, (size_t)prevlen);
if (!magic)
++p;    STRCPY(tmpsub + len + prevlen, p + 1);
if (newsub != source)vim_free(newsub);
newsub = tmpsub;
p = newsub + len + prevlen;
}
}
else if (magic)
STRMOVE(p, p + 1);    else
STRMOVE(p, p + 2);    --p;
}
else
{
if (*p == '\\' && p[1])++p;
if (has_mbyte)
p += (*mb_ptr2len)(p) - 1;
}
}
vim_free(reg_prev_sub);
if (newsub != source)reg_prev_sub = newsub;
elsereg_prev_sub = vim_strsave(newsub);
return newsub;
}","char_u *
regtilde(char_u *VAR_0, int VAR_1)
{
char_u*VAR_2 = VAR_0;
char_u*VAR_3;
char_u*VAR_4;
intVAR_5;
intVAR_6;
for (VAR_4 = VAR_2; *VAR_4; ++VAR_4)
{
if ((*VAR_4 == '~' && VAR_1) || (*VAR_4 == '\\' && *(VAR_4 + 1) == '~' && !VAR_1))
{
if (VAR_7 != NULL)
{
VAR_6 = (int)STRLEN(VAR_7);
VAR_3 = alloc(STRLEN(VAR_2) + VAR_6);
if (VAR_3 != NULL)
{
VAR_5 = (int)(VAR_4 - VAR_2);
mch_memmove(VAR_3, VAR_2, (size_t)VAR_5);
mch_memmove(VAR_3 + VAR_5, VAR_7, (size_t)VAR_6);
if (!VAR_1)
++VAR_4;
STRCPY(VAR_3 + VAR_5 + VAR_6, VAR_4 + 1);
if (VAR_2 != VAR_0)
vim_free(VAR_2);
VAR_2 = VAR_3;
VAR_4 = VAR_2 + VAR_5 + VAR_6;
}
}
else if (VAR_1)
STRMOVE(VAR_4, VAR_4 + 1);
else
STRMOVE(VAR_4, VAR_4 + 2);
--VAR_4;
}
else
{
if (*VAR_4 == '\\' && VAR_4[1])
++VAR_4;
if (VAR_8)
VAR_4 += (*VAR_9)(VAR_4) - 1;
}
}
vim_free(VAR_7);
if (VAR_2 != VAR_0)
VAR_7 = VAR_2;
else
VAR_7 = vim_strsave(VAR_2);
return VAR_2;
}",vim/32acf1f1a72ebb9d8942b9c9d80023bf1bb668ea/regexp.c/vul/before/0.json,"char_u *
regtilde(char_u *source, int magic)
{
    char_u	*newsub = source;
    char_u	*tmpsub;
    char_u	*p;
    int		len;
    int		prevlen;

    for (p = newsub; *p; ++p)
    {
	if ((*p == '~' && magic) || (*p == '\\' && *(p + 1) == '~' && !magic))
	{
	    if (reg_prev_sub != NULL)
	    {
		// length = len(newsub) - 1 + len(prev_sub) + 1
		prevlen = (int)STRLEN(reg_prev_sub);
		tmpsub = alloc(STRLEN(newsub) + prevlen);
		if (tmpsub != NULL)
		{
		    // copy prefix
		    len = (int)(p - newsub);	// not including ~
		    mch_memmove(tmpsub, newsub, (size_t)len);
		    // interpret tilde
		    mch_memmove(tmpsub + len, reg_prev_sub, (size_t)prevlen);
		    // copy postfix
		    if (!magic)
			++p;			// back off backslash
		    STRCPY(tmpsub + len + prevlen, p + 1);

		    if (newsub != source)	// already allocated newsub
			vim_free(newsub);
		    newsub = tmpsub;
		    p = newsub + len + prevlen;
		}
	    }
	    else if (magic)
		STRMOVE(p, p + 1);	// remove '~'
	    else
		STRMOVE(p, p + 2);	// remove '\~'
	    --p;
	}
	else
	{
	    if (*p == '\\' && p[1])		// skip escaped characters
		++p;
	    if (has_mbyte)
		p += (*mb_ptr2len)(p) - 1;
	}
    }

    // Store a copy of newsub  in reg_prev_sub.  It is always allocated,
    // because recursive calls may make the returned string invalid.
    vim_free(reg_prev_sub);
    reg_prev_sub = vim_strsave(newsub);

    return newsub;
}","char_u *
regtilde(char_u *VAR_0, int VAR_1)
{
    char_u	*VAR_2 = VAR_0;
    char_u	*VAR_3;
    char_u	*VAR_4;
    int		VAR_5;
    int		VAR_6;

    for (VAR_4 = VAR_2; *VAR_4; ++VAR_4)
    {
	if ((*VAR_4 == '~' && VAR_1) || (*VAR_4 == '\\' && *(VAR_4 + 1) == '~' && !VAR_1))
	{
	    if (VAR_7 != NULL)
	    {
		/* COMMENT_0 */
		VAR_6 = (int)STRLEN(VAR_7);
		VAR_3 = alloc(STRLEN(VAR_2) + VAR_6);
		if (VAR_3 != NULL)
		{
		    /* COMMENT_1 */
		    VAR_5 = (int)(VAR_4 - VAR_2);	/* COMMENT_2 */
		    mch_memmove(VAR_3, VAR_2, (size_t)VAR_5);
		    /* COMMENT_3 */
		    mch_memmove(VAR_3 + VAR_5, VAR_7, (size_t)VAR_6);
		    /* COMMENT_4 */
		    if (!VAR_1)
			++VAR_4;			/* COMMENT_5 */
		    STRCPY(VAR_3 + VAR_5 + VAR_6, VAR_4 + 1);

		    if (VAR_2 != VAR_0)	/* COMMENT_6 */
			vim_free(VAR_2);
		    VAR_2 = VAR_3;
		    VAR_4 = VAR_2 + VAR_5 + VAR_6;
		}
	    }
	    else if (VAR_1)
		STRMOVE(VAR_4, VAR_4 + 1);	/* COMMENT_7 */
	    else
		STRMOVE(VAR_4, VAR_4 + 2);	/* COMMENT_8 */
	    --VAR_4;
	}
	else
	{
	    if (*VAR_4 == '\\' && VAR_4[1])		/* COMMENT_9 */
		++VAR_4;
	    if (VAR_8)
		VAR_4 += (*VAR_9)(VAR_4) - 1;
	}
    }

    /* COMMENT_10 */
    /* COMMENT_11 */
    vim_free(VAR_7);
    VAR_7 = vim_strsave(VAR_2);

    return VAR_2;
}",vim/32acf1f1a72ebb9d8942b9c9d80023bf1bb668ea/regexp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -49,10 +49,10 @@
 	}
     }
 
+    // Store a copy of newsub  in reg_prev_sub.  It is always allocated,
+    // because recursive calls may make the returned string invalid.
     vim_free(reg_prev_sub);
-    if (newsub != source)	// newsub was allocated, just keep it
-	reg_prev_sub = newsub;
-    else			// no ~ found, need to save newsub
-	reg_prev_sub = vim_strsave(newsub);
+    reg_prev_sub = vim_strsave(newsub);
+
     return newsub;
 }","{'deleted_lines': ['    if (newsub != source)\t// newsub was allocated, just keep it', '\treg_prev_sub = newsub;', '    else\t\t\t// no ~ found, need to save newsub', '\treg_prev_sub = vim_strsave(newsub);'], 'added_lines': ['    // Store a copy of newsub  in reg_prev_sub.  It is always allocated,', '    // because recursive calls may make the returned string invalid.', '    reg_prev_sub = vim_strsave(newsub);', '']}",True,Use After Free in GitHub repository vim/vim prior to 9.0.0046.,7.8,HIGH,2,test,2022-07-07T21:20:31Z,4
CVE-2022-39188,['CWE-362'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"mmu_gather: Force tlb-flush VM_PFNMAP vmas

Jann reported a race between munmap() and unmap_mapping_range(), where
unmap_mapping_range() will no-op once unmap_vmas() has unlinked the
VMA; however munmap() will not yet have invalidated the TLBs.

Therefore unmap_mapping_range() will complete while there are still
(stale) TLB entries for the specified range.

Mitigate this by force flushing TLBs for VM_PFNMAP ranges.

Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Acked-by: Will Deacon <will@kernel.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",b67fbebd4cf980aecbcc750e1462128bffe8ae15,https://github.com/torvalds/linux/commit/b67fbebd4cf980aecbcc750e1462128bffe8ae15,include/asm-generic/tlb.h,tlb_end_vma,"static inline void tlb_end_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)
{
if (tlb->fullmm || IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS))
return;
tlb_flush_mmu_tlbonly(tlb);
}","static inline void tlb_end_vma(struct mmu_gather *VAR_0, struct vm_area_struct *VAR_1)
{
if (VAR_0->fullmm || IS_ENABLED(VAR_2))
return;
tlb_flush_mmu_tlbonly(VAR_0);
}",torvalds/linux/b67fbebd4cf980aecbcc750e1462128bffe8ae15/tlb.h/vul/before/0.json,"static inline void tlb_end_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)
{
	if (tlb->fullmm)
		return;

	/*
	 * VM_PFNMAP is more fragile because the core mm will not track the
	 * page mapcount -- there might not be page-frames for these PFNs after
	 * all. Force flush TLBs for such ranges to avoid munmap() vs
	 * unmap_mapping_range() races.
	 */
	if (tlb->vma_pfn || !IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS)) {
		/*
		 * Do a TLB flush and reset the range at VMA boundaries; this avoids
		 * the ranges growing with the unused space between consecutive VMAs.
		 */
		tlb_flush_mmu_tlbonly(tlb);
	}
}","static inline void tlb_end_vma(struct mmu_gather *VAR_0, struct vm_area_struct *VAR_1)
{
	if (VAR_0->fullmm)
		return;

	/* COMMENT_0 */
                                                                    
                                                                        
                                                              
                                
    
	if (VAR_0->vma_pfn || !IS_ENABLED(VAR_2)) {
		/* COMMENT_6 */
                                                                      
                                                                       
     
		tlb_flush_mmu_tlbonly(VAR_0);
	}
}",torvalds/linux/b67fbebd4cf980aecbcc750e1462128bffe8ae15/tlb.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,13 +1,19 @@
 static inline void tlb_end_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)
 {
-	if (tlb->fullmm || IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS))
+	if (tlb->fullmm)
 		return;
 
 	/*
-	 * Do a TLB flush and reset the range at VMA boundaries; this avoids
-	 * the ranges growing with the unused space between consecutive VMAs,
-	 * but also the mmu_gather::vma_* flags from tlb_start_vma() rely on
-	 * this.
+	 * VM_PFNMAP is more fragile because the core mm will not track the
+	 * page mapcount -- there might not be page-frames for these PFNs after
+	 * all. Force flush TLBs for such ranges to avoid munmap() vs
+	 * unmap_mapping_range() races.
 	 */
-	tlb_flush_mmu_tlbonly(tlb);
+	if (tlb->vma_pfn || !IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS)) {
+		/*
+		 * Do a TLB flush and reset the range at VMA boundaries; this avoids
+		 * the ranges growing with the unused space between consecutive VMAs.
+		 */
+		tlb_flush_mmu_tlbonly(tlb);
+	}
 }","{'deleted_lines': ['\tif (tlb->fullmm || IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS))', '\t * Do a TLB flush and reset the range at VMA boundaries; this avoids', '\t * the ranges growing with the unused space between consecutive VMAs,', '\t * but also the mmu_gather::vma_* flags from tlb_start_vma() rely on', '\t * this.', '\ttlb_flush_mmu_tlbonly(tlb);'], 'added_lines': ['\tif (tlb->fullmm)', '\t * VM_PFNMAP is more fragile because the core mm will not track the', '\t * page mapcount -- there might not be page-frames for these PFNs after', '\t * all. Force flush TLBs for such ranges to avoid munmap() vs', '\t * unmap_mapping_range() races.', '\tif (tlb->vma_pfn || !IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS)) {', '\t\t/*', '\t\t * Do a TLB flush and reset the range at VMA boundaries; this avoids', '\t\t * the ranges growing with the unused space between consecutive VMAs.', '\t\t */', '\t\ttlb_flush_mmu_tlbonly(tlb);', '\t}']}",True,"An issue was discovered in include/asm-generic/tlb.h in the Linux kernel before 5.19. Because of a race condition (unmap_mapping_range versus munmap), a device driver can free a page while it still has stale TLB entries. This only occurs in situations with VM_PFNMAP VMAs.",4.7,MEDIUM,1,test,2022-07-08T07:18:06Z,4
CVE-2022-39188,['CWE-362'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"mmu_gather: Force tlb-flush VM_PFNMAP vmas

Jann reported a race between munmap() and unmap_mapping_range(), where
unmap_mapping_range() will no-op once unmap_vmas() has unlinked the
VMA; however munmap() will not yet have invalidated the TLBs.

Therefore unmap_mapping_range() will complete while there are still
(stale) TLB entries for the specified range.

Mitigate this by force flushing TLBs for VM_PFNMAP ranges.

Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Acked-by: Will Deacon <will@kernel.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",b67fbebd4cf980aecbcc750e1462128bffe8ae15,https://github.com/torvalds/linux/commit/b67fbebd4cf980aecbcc750e1462128bffe8ae15,include/asm-generic/tlb.h,tlb_update_vma_flags,"static inline void
tlb_update_vma_flags(struct mmu_gather *tlb, struct vm_area_struct *vma)
{
tlb->vma_huge = is_vm_hugetlb_page(vma);
tlb->vma_exec = !!(vma->vm_flags & VM_EXEC);
}","static inline void
tlb_update_vma_flags(struct mmu_gather *VAR_0, struct vm_area_struct *VAR_1)
{
VAR_0->vma_huge = is_vm_hugetlb_page(VAR_1);
VAR_0->vma_exec = !!(VAR_1->vm_flags & VAR_2);
}",torvalds/linux/b67fbebd4cf980aecbcc750e1462128bffe8ae15/tlb.h/vul/before/1.json,"static inline void
tlb_update_vma_flags(struct mmu_gather *tlb, struct vm_area_struct *vma)
{
	/*
	 * flush_tlb_range() implementations that look at VM_HUGETLB (tile,
	 * mips-4k) flush only large pages.
	 *
	 * flush_tlb_range() implementations that flush I-TLB also flush D-TLB
	 * (tile, xtensa, arm), so it's ok to just add VM_EXEC to an existing
	 * range.
	 *
	 * We rely on tlb_end_vma() to issue a flush, such that when we reset
	 * these values the batch is empty.
	 */
	tlb->vma_huge = is_vm_hugetlb_page(vma);
	tlb->vma_exec = !!(vma->vm_flags & VM_EXEC);
	tlb->vma_pfn  = !!(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP));
}","static inline void
tlb_update_vma_flags(struct mmu_gather *VAR_0, struct vm_area_struct *VAR_1)
{
	/* COMMENT_0 */
                                                                    
                                    
   
                                                                       
                                                                      
          
   
                                                                      
                                    
    
	VAR_0->vma_huge = is_vm_hugetlb_page(VAR_1);
	VAR_0->vma_exec = !!(VAR_1->vm_flags & VAR_2);
	VAR_0->vma_pfn  = !!(VAR_1->vm_flags & (VAR_3|VAR_4));
}",torvalds/linux/b67fbebd4cf980aecbcc750e1462128bffe8ae15/tlb.h/vul/after/1.json,"--- func_before
+++ func_after
@@ -14,4 +14,5 @@
 	 */
 	tlb->vma_huge = is_vm_hugetlb_page(vma);
 	tlb->vma_exec = !!(vma->vm_flags & VM_EXEC);
+	tlb->vma_pfn  = !!(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP));
 }","{'deleted_lines': [], 'added_lines': ['\ttlb->vma_pfn  = !!(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP));']}",True,"An issue was discovered in include/asm-generic/tlb.h in the Linux kernel before 5.19. Because of a race condition (unmap_mapping_range versus munmap), a device driver can free a page while it still has stale TLB entries. This only occurs in situations with VM_PFNMAP VMAs.",4.7,MEDIUM,1,test,2022-07-08T07:18:06Z,4
CVE-2022-4128,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"mptcp: fix subflow traversal at disconnect time

At disconnect time the MPTCP protocol traverse the subflows
list closing each of them. In some circumstances - MPJ subflow,
passive MPTCP socket, the latter operation can remove the
subflow from the list, invalidating the current iterator.

Address the issue using the safe list traversing helper
variant.

Reported-by: van fantasy <g1042620637@gmail.com>
Fixes: b29fcfb54cd7 (""mptcp: full disconnect implementation"")
Tested-by: Matthieu Baerts <matthieu.baerts@tessares.net>
Reviewed-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
Signed-off-by: Paolo Abeni <pabeni@redhat.com>
Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",5c835bb142d4,https://github.com/torvalds/linux/commit/5c835bb142d4013c2ab24bff5ae9f6709a39cbcf,net/mptcp/protocol.c,mptcp_disconnect,"static int mptcp_disconnect(struct sock *sk, int flags)
{
struct mptcp_subflow_context *subflow;
struct mptcp_sock *msk = mptcp_sk(sk);
inet_sk_state_store(sk, TCP_CLOSE);
mptcp_for_each_subflow(msk, subflow) {
struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
__mptcp_close_ssk(sk, ssk, subflow, MPTCP_CF_FASTCLOSE);
}
mptcp_stop_timer(sk);
sk_stop_timer(sk, &sk->sk_timer);
if (mptcp_sk(sk)->token)
mptcp_event(MPTCP_EVENT_CLOSED, mptcp_sk(sk), NULL, GFP_KERNEL);
mptcp_destroy_common(msk);
msk->last_snd = NULL;
WRITE_ONCE(msk->flags, 0);
msk->cb_flags = 0;
msk->push_pending = 0;
msk->recovery = false;
msk->can_ack = false;
msk->fully_established = false;
msk->rcv_data_fin = false;
msk->snd_data_fin_enable = false;
msk->rcv_fastclose = false;
msk->use_64bit_ack = false;
WRITE_ONCE(msk->csum_enabled, mptcp_is_checksum_enabled(sock_net(sk)));
mptcp_pm_data_reset(msk);
mptcp_ca_reset(sk);
sk->sk_shutdown = 0;
sk_error_report(sk);
return 0;
}","static int mptcp_disconnect(struct sock *VAR_0, int VAR_1)
{
struct mptcp_subflow_context *VAR_2;
struct mptcp_sock *VAR_3 = mptcp_sk(VAR_0);
inet_sk_state_store(VAR_0, VAR_4);
mptcp_for_each_subflow(VAR_3, VAR_2) {
struct sock *VAR_5 = mptcp_subflow_tcp_sock(VAR_2);
__mptcp_close_ssk(VAR_0, VAR_5, VAR_2, VAR_6);
}
mptcp_stop_timer(VAR_0);
sk_stop_timer(VAR_0, &VAR_0->sk_timer);
if (mptcp_sk(VAR_0)->token)
mptcp_event(VAR_7, mptcp_sk(VAR_0), NULL, VAR_8);
mptcp_destroy_common(VAR_3);
VAR_3->last_snd = NULL;
WRITE_ONCE(VAR_3->flags, 0);
VAR_3->cb_flags = 0;
VAR_3->push_pending = 0;
VAR_3->recovery = false;
VAR_3->can_ack = false;
VAR_3->fully_established = false;
VAR_3->rcv_data_fin = false;
VAR_3->snd_data_fin_enable = false;
VAR_3->rcv_fastclose = false;
VAR_3->use_64bit_ack = false;
WRITE_ONCE(VAR_3->csum_enabled, mptcp_is_checksum_enabled(sock_net(VAR_0)));
mptcp_pm_data_reset(VAR_3);
mptcp_ca_reset(VAR_0);
VAR_0->sk_shutdown = 0;
sk_error_report(VAR_0);
return 0;
}",torvalds/linux/5c835bb142d4/protocol.c/vul/before/0.json,"static int mptcp_disconnect(struct sock *sk, int flags)
{
	struct mptcp_subflow_context *subflow, *tmp;
	struct mptcp_sock *msk = mptcp_sk(sk);

	inet_sk_state_store(sk, TCP_CLOSE);

	list_for_each_entry_safe(subflow, tmp, &msk->conn_list, node) {
		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);

		__mptcp_close_ssk(sk, ssk, subflow, MPTCP_CF_FASTCLOSE);
	}

	mptcp_stop_timer(sk);
	sk_stop_timer(sk, &sk->sk_timer);

	if (mptcp_sk(sk)->token)
		mptcp_event(MPTCP_EVENT_CLOSED, mptcp_sk(sk), NULL, GFP_KERNEL);

	mptcp_destroy_common(msk);
	msk->last_snd = NULL;
	WRITE_ONCE(msk->flags, 0);
	msk->cb_flags = 0;
	msk->push_pending = 0;
	msk->recovery = false;
	msk->can_ack = false;
	msk->fully_established = false;
	msk->rcv_data_fin = false;
	msk->snd_data_fin_enable = false;
	msk->rcv_fastclose = false;
	msk->use_64bit_ack = false;
	WRITE_ONCE(msk->csum_enabled, mptcp_is_checksum_enabled(sock_net(sk)));
	mptcp_pm_data_reset(msk);
	mptcp_ca_reset(sk);

	sk->sk_shutdown = 0;
	sk_error_report(sk);
	return 0;
}","static int mptcp_disconnect(struct sock *VAR_0, int VAR_1)
{
	struct mptcp_subflow_context *VAR_2, *VAR_3;
	struct mptcp_sock *VAR_4 = mptcp_sk(VAR_0);

	inet_sk_state_store(VAR_0, VAR_5);

	list_for_each_entry_safe(VAR_2, VAR_3, &VAR_4->conn_list, VAR_6) {
		struct sock *VAR_7 = mptcp_subflow_tcp_sock(VAR_2);

		__mptcp_close_ssk(VAR_0, VAR_7, VAR_2, VAR_8);
	}

	mptcp_stop_timer(VAR_0);
	sk_stop_timer(VAR_0, &VAR_0->sk_timer);

	if (mptcp_sk(VAR_0)->token)
		mptcp_event(VAR_9, mptcp_sk(VAR_0), NULL, VAR_10);

	mptcp_destroy_common(VAR_4);
	VAR_4->last_snd = NULL;
	WRITE_ONCE(VAR_4->flags, 0);
	VAR_4->cb_flags = 0;
	VAR_4->push_pending = 0;
	VAR_4->recovery = false;
	VAR_4->can_ack = false;
	VAR_4->fully_established = false;
	VAR_4->rcv_data_fin = false;
	VAR_4->snd_data_fin_enable = false;
	VAR_4->rcv_fastclose = false;
	VAR_4->use_64bit_ack = false;
	WRITE_ONCE(VAR_4->csum_enabled, mptcp_is_checksum_enabled(sock_net(VAR_0)));
	mptcp_pm_data_reset(VAR_4);
	mptcp_ca_reset(VAR_0);

	VAR_0->sk_shutdown = 0;
	sk_error_report(VAR_0);
	return 0;
}",torvalds/linux/5c835bb142d4/protocol.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,11 +1,11 @@
 static int mptcp_disconnect(struct sock *sk, int flags)
 {
-	struct mptcp_subflow_context *subflow;
+	struct mptcp_subflow_context *subflow, *tmp;
 	struct mptcp_sock *msk = mptcp_sk(sk);
 
 	inet_sk_state_store(sk, TCP_CLOSE);
 
-	mptcp_for_each_subflow(msk, subflow) {
+	list_for_each_entry_safe(subflow, tmp, &msk->conn_list, node) {
 		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
 
 		__mptcp_close_ssk(sk, ssk, subflow, MPTCP_CF_FASTCLOSE);","{'deleted_lines': ['\tstruct mptcp_subflow_context *subflow;', '\tmptcp_for_each_subflow(msk, subflow) {'], 'added_lines': ['\tstruct mptcp_subflow_context *subflow, *tmp;', '\tlist_for_each_entry_safe(subflow, tmp, &msk->conn_list, node) {']}",True,A NULL pointer dereference issue was discovered in the Linux kernel in the MPTCP protocol when traversing the subflow list at disconnect time. A local user could use this flaw to potentially crash the system causing a denial of service.,5.5,MEDIUM,1,test,2022-07-08T23:36:09Z,4
CVE-2022-35987,['CWE-617'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,tensorflow,"Fix security vulnerability with DenseBincountOp

PiperOrigin-RevId: 460826735",bf4c14353c2328636a18bfad1e151052c81d5f43,https://github.com/tensorflow/tensorflow/commit/bf4c14353c2328636a18bfad1e151052c81d5f43,tensorflow/core/kernels/bincount_op.cc,Compile,"void Compile(XlaOpKernelContext* ctx) override {
int64_t output_size;
xla::XlaOp output_size_param = ctx->Input(""size"");
StatusOr<xla::Shape> output_shape_or =
ctx->builder()->GetShape(output_size_param);
OP_REQUIRES_OK(ctx, output_shape_or.status());
auto output_shape_param = output_shape_or.ValueOrDie();
auto output_rank = output_shape_param.rank();
OP_REQUIRES(ctx, output_rank == 0,
errors::InvalidArgument(""Shape must be rank 0 but is rank "",
output_rank));
OP_REQUIRES_OK(ctx, ctx->ConstantInputAsIntScalar(""size"", &output_size));
OP_REQUIRES(ctx, output_size >= 0,
errors::InvalidArgument(""size ("", output_size,
"") must be non-negative""));
xla::XlaOp idx, updates, output;
xla::XlaOp input = ctx->Input(0);
auto input_xla_type = ctx->input_xla_type(0);
xla::PrimitiveType dtype = ctx->InputXlaType(""weights"");
auto zero = xla::Zero(ctx->builder(), dtype);
auto one = xla::One(ctx->builder(), dtype);
StatusOr<xla::Shape> input_shape_or = ctx->builder()->GetShape(input);
OP_REQUIRES_OK(ctx, input_shape_or.status());
auto input_shape = input_shape_or.ValueOrDie();
auto size = input_shape.dimensions(0);
if (!size) {
output = xla::Broadcast(zero, {output_size});
ctx->SetOutput(0, output);
return;
}
auto rank = input_shape.rank();
OP_REQUIRES(ctx, rank <= 2,
errors::InvalidArgument(
""Shape must be at most rank 2 but is rank "", rank));
xla::XlaOp weights = ctx->Input(2);
StatusOr<xla::Shape> weights_shape_or = ctx->builder()->GetShape(weights);
OP_REQUIRES_OK(ctx, weights_shape_or.status());
auto weights_shape = weights_shape_or.ValueOrDie();
auto weights_size = weights_shape.dimensions(0);
bool has_weights = false;
if (weights_size) {
has_weights = true;
}
xla::Shape output_shape = xla::ShapeUtil::MakeShape(dtype, {output_size});
xla::ScatterDimensionNumbers scatter_dnums;
scatter_dnums.set_index_vector_dim(1);
scatter_dnums.add_inserted_window_dims(0);
scatter_dnums.add_scatter_dims_to_operand_dims(0);
if (rank == 2) {
output_shape = xla::ShapeUtil::MakeShape(dtype, {size, output_size});
scatter_dnums.add_inserted_window_dims(1);
scatter_dnums.add_scatter_dims_to_operand_dims(1);
auto i_shape =
xla::ShapeUtil::MakeShape(input_xla_type, {input_shape.dimensions()});
auto i = xla::Iota(ctx->builder(), i_shape, 0);
i = xla::Reshape(
i, {input_shape.dimensions(0) * input_shape.dimensions(1), 1});
auto j = xla::Reshape(
input, {input_shape.dimensions(0) * input_shape.dimensions(1), 1});
std::vector<xla::XlaOp> iotas_to_concat;
iotas_to_concat.push_back(i);
iotas_to_concat.push_back(j);
idx = xla::ConcatInDim(ctx->builder(), iotas_to_concat, 1);
updates = xla::Broadcast(
one, {input_shape.dimensions(0) * input_shape.dimensions(1)});
output = xla::Broadcast(
zero, {output_shape.dimensions(0), output_shape.dimensions(1)});
if (has_weights && !binary_output_) {
weights = xla::Reshape(
weights, {input_shape.dimensions(0) * input_shape.dimensions(1)});
updates = weights;
}
} else {
input = xla::Reshape(input, {size, 1});
idx = xla::Reshape(input, {size, 1});
updates = xla::Broadcast(one, {size});
output = xla::Broadcast(zero, {output_size});
if (has_weights && !binary_output_) {
updates = weights;
}
}
xla::XlaComputation assn_computation = [&] {
std::unique_ptr<xla::XlaBuilder> subb =
ctx->builder()->CreateSubBuilder(""scatter_bincount"");
xla::Shape param_shape = xla::ShapeUtil::MakeShape(dtype, {});
auto p0 = xla::Parameter(subb.get(), 0, param_shape, ""p0"");
auto p1 = xla::Parameter(subb.get(), 1, param_shape, ""p1"");
if (!binary_output_) {
xla::Add(p0, p1);
}
return subb->BuildAndNoteError();
}();
output = xla::Scatter(output, idx, updates, assn_computation, scatter_dnums,
false, false);
ctx->SetOutput(0, output);
}","void Compile(XlaOpKernelContext* VAR_0) override {
int64_t VAR_1;
xla::XlaOp VAR_2 = VAR_0->Input(""size"");
StatusOr<xla::Shape> VAR_3 =
VAR_0->builder()->GetShape(VAR_2);
OP_REQUIRES_OK(VAR_0, VAR_3.status());
auto VAR_4 = VAR_3.ValueOrDie();
auto VAR_5 = VAR_4.rank();
OP_REQUIRES(VAR_0, VAR_5 == 0,
errors::InvalidArgument(""Shape must be rank 0 but is rank "",
VAR_5));
OP_REQUIRES_OK(VAR_0, VAR_0->ConstantInputAsIntScalar(""size"", &VAR_1));
OP_REQUIRES(VAR_0, VAR_1 >= 0,
errors::InvalidArgument(""size ("", VAR_1,
"") must be non-negative""));
xla::XlaOp VAR_6, VAR_7, VAR_8;
xla::XlaOp VAR_9 = VAR_0->Input(0);
auto VAR_10 = VAR_0->input_xla_type(0);
xla::PrimitiveType VAR_11 = VAR_0->InputXlaType(""weights"");
auto VAR_12 = xla::Zero(VAR_0->builder(), VAR_11);
auto VAR_13 = xla::One(VAR_0->builder(), VAR_11);
StatusOr<xla::Shape> VAR_14 = VAR_0->builder()->GetShape(VAR_9);
OP_REQUIRES_OK(VAR_0, VAR_14.status());
auto VAR_15 = VAR_14.ValueOrDie();
auto VAR_16 = VAR_15.dimensions(0);
if (!VAR_16) {
VAR_8 = xla::Broadcast(VAR_12, {VAR_1});
VAR_0->SetOutput(0, VAR_8);
return;
}
auto VAR_17 = VAR_15.rank();
OP_REQUIRES(VAR_0, VAR_17 <= 2,
errors::InvalidArgument(
""Shape must be at most rank 2 but is rank "", VAR_17));
xla::XlaOp VAR_18 = VAR_0->Input(2);
StatusOr<xla::Shape> VAR_19 = VAR_0->builder()->GetShape(VAR_18);
OP_REQUIRES_OK(VAR_0, VAR_19.status());
auto VAR_20 = VAR_19.ValueOrDie();
auto VAR_21 = VAR_20.dimensions(0);
bool VAR_22 = false;
if (VAR_21) {
VAR_22 = true;
}
xla::Shape VAR_23 = xla::ShapeUtil::MakeShape(VAR_11, {VAR_1});
xla::ScatterDimensionNumbers VAR_24;
VAR_24.set_index_vector_dim(1);
VAR_24.add_inserted_window_dims(0);
VAR_24.add_scatter_dims_to_operand_dims(0);
if (VAR_17 == 2) {
VAR_23 = xla::ShapeUtil::MakeShape(VAR_11, {VAR_16, VAR_1});
VAR_24.add_inserted_window_dims(1);
VAR_24.add_scatter_dims_to_operand_dims(1);
auto VAR_25 =
xla::ShapeUtil::MakeShape(VAR_10, {VAR_15.dimensions()});
auto VAR_26 = xla::Iota(VAR_0->builder(), VAR_25, 0);
VAR_26 = xla::Reshape(
VAR_26, {VAR_15.dimensions(0) * VAR_15.dimensions(1), 1});
auto VAR_27 = xla::Reshape(
VAR_9, {VAR_15.dimensions(0) * VAR_15.dimensions(1), 1});
std::vector<xla::XlaOp> VAR_28;
VAR_28.push_back(VAR_26);
VAR_28.push_back(VAR_27);
VAR_6 = xla::ConcatInDim(VAR_0->builder(), VAR_28, 1);
VAR_7 = xla::Broadcast(
VAR_13, {VAR_15.dimensions(0) * VAR_15.dimensions(1)});
VAR_8 = xla::Broadcast(
VAR_12, {VAR_23.dimensions(0), VAR_23.dimensions(1)});
if (VAR_22 && !VAR_29) {
VAR_18 = xla::Reshape(
VAR_18, {VAR_15.dimensions(0) * VAR_15.dimensions(1)});
VAR_7 = VAR_18;
}
} else {
VAR_9 = xla::Reshape(VAR_9, {VAR_16, 1});
VAR_6 = xla::Reshape(VAR_9, {VAR_16, 1});
VAR_7 = xla::Broadcast(VAR_13, {VAR_16});
VAR_8 = xla::Broadcast(VAR_12, {VAR_1});
if (VAR_22 && !VAR_29) {
VAR_7 = VAR_18;
}
}
xla::XlaComputation VAR_30 = [&] {
std::unique_ptr<xla::XlaBuilder> VAR_31 =
VAR_0->builder()->CreateSubBuilder(""scatter_bincount"");
xla::Shape VAR_32 = xla::ShapeUtil::MakeShape(VAR_11, {});
auto VAR_33 = xla::Parameter(VAR_31.get(), 0, VAR_32, ""p0"");
auto VAR_34 = xla::Parameter(VAR_31.get(), 1, VAR_32, ""p1"");
if (!VAR_29) {
xla::Add(VAR_33, VAR_34);
}
return VAR_31->BuildAndNoteError();
}();
VAR_8 = xla::Scatter(VAR_8, VAR_6, VAR_7, VAR_30, VAR_24,
false, false);
VAR_0->SetOutput(0, VAR_8);
}",,"void Compile(XlaOpKernelContext* ctx) override {
    int64_t output_size;
    xla::XlaOp output_size_param = ctx->Input(""size"");
    StatusOr<xla::Shape> output_shape_or =
        ctx->builder()->GetShape(output_size_param);
    OP_REQUIRES_OK(ctx, output_shape_or.status());
    auto output_shape_param = output_shape_or.ValueOrDie();
    auto output_rank = output_shape_param.rank();
    OP_REQUIRES(ctx, output_rank == 0,
                errors::InvalidArgument(""Shape must be rank 0 but is rank "",
                                        output_rank));
    OP_REQUIRES_OK(ctx, ctx->ConstantInputAsIntScalar(""size"", &output_size));
    OP_REQUIRES(ctx, output_size >= 0,
                errors::InvalidArgument(""size ("", output_size,
                                        "") must be non-negative""));
    xla::XlaOp idx, updates, output;
    xla::XlaOp input = ctx->Input(0);
    auto input_xla_type = ctx->input_xla_type(0);
    xla::PrimitiveType dtype = ctx->InputXlaType(""weights"");
    auto zero = xla::Zero(ctx->builder(), dtype);
    auto one = xla::One(ctx->builder(), dtype);
    StatusOr<xla::Shape> input_shape_or = ctx->builder()->GetShape(input);
    OP_REQUIRES_OK(ctx, input_shape_or.status());
    auto input_shape = input_shape_or.ValueOrDie();
    auto size = input_shape.dimensions(0);

    if (!size) {
      output = xla::Broadcast(zero, {output_size});
      ctx->SetOutput(0, output);
      return;
    }
    auto rank = input_shape.rank();

    OP_REQUIRES(ctx, rank <= 2,
                errors::InvalidArgument(
                    ""Shape must be at most rank 2 but is rank "", rank));

    xla::XlaOp weights = ctx->Input(2);
    StatusOr<xla::Shape> weights_shape_or = ctx->builder()->GetShape(weights);
    OP_REQUIRES_OK(ctx, weights_shape_or.status());

    auto weights_shape = weights_shape_or.ValueOrDie();
    OP_REQUIRES(ctx,
                xla::ShapeUtil::CompatibleIgnoringElementType(weights_shape,
                                                              input_shape) ||
                    (weights_shape.dimensions_size() > 0 &&
                     weights_shape.dimensions(0) == 0),
                errors::InvalidArgument(
                    ""`weights` must be the same shape as `arr` or a length-0 ""
                    ""`Tensor`, in which case it acts as all weights equal to ""
                    ""1. Received "",
                    weights_shape.DebugString()));

    auto weights_size = weights_shape.dimensions(0);
    bool has_weights = false;
    if (weights_size) {
      has_weights = true;
    }
    xla::Shape output_shape = xla::ShapeUtil::MakeShape(dtype, {output_size});
    xla::ScatterDimensionNumbers scatter_dnums;
    scatter_dnums.set_index_vector_dim(1);
    scatter_dnums.add_inserted_window_dims(0);
    scatter_dnums.add_scatter_dims_to_operand_dims(0);

    if (rank == 2) {
      output_shape = xla::ShapeUtil::MakeShape(dtype, {size, output_size});
      scatter_dnums.add_inserted_window_dims(1);
      scatter_dnums.add_scatter_dims_to_operand_dims(1);
      auto i_shape =
          xla::ShapeUtil::MakeShape(input_xla_type, {input_shape.dimensions()});
      auto i = xla::Iota(ctx->builder(), i_shape, 0);
      i = xla::Reshape(
          i, {input_shape.dimensions(0) * input_shape.dimensions(1), 1});
      auto j = xla::Reshape(
          input, {input_shape.dimensions(0) * input_shape.dimensions(1), 1});
      std::vector<xla::XlaOp> iotas_to_concat;
      iotas_to_concat.push_back(i);
      iotas_to_concat.push_back(j);
      idx = xla::ConcatInDim(ctx->builder(), iotas_to_concat, 1);
      updates = xla::Broadcast(
          one, {input_shape.dimensions(0) * input_shape.dimensions(1)});
      output = xla::Broadcast(
          zero, {output_shape.dimensions(0), output_shape.dimensions(1)});
      if (has_weights && !binary_output_) {
        weights = xla::Reshape(
            weights, {input_shape.dimensions(0) * input_shape.dimensions(1)});
        updates = weights;
      }
    } else {
      input = xla::Reshape(input, {size, 1});
      idx = xla::Reshape(input, {size, 1});
      updates = xla::Broadcast(one, {size});
      output = xla::Broadcast(zero, {output_size});
      if (has_weights && !binary_output_) {
        updates = weights;
      }
    }

    xla::XlaComputation assn_computation = [&] {
      std::unique_ptr<xla::XlaBuilder> subb =
          ctx->builder()->CreateSubBuilder(""scatter_bincount"");
      xla::Shape param_shape = xla::ShapeUtil::MakeShape(dtype, {});
      auto p0 = xla::Parameter(subb.get(), 0, param_shape, ""p0"");
      auto p1 = xla::Parameter(subb.get(), 1, param_shape, ""p1"");
      if (!binary_output_) {
        xla::Add(p0, p1);
      }
      return subb->BuildAndNoteError();
    }();
    output = xla::Scatter(output, idx, updates, assn_computation, scatter_dnums,
                          false, false);
    ctx->SetOutput(0, output);
  }","void Compile(XlaOpKernelContext* VAR_0) override {
    int64_t VAR_1;
    xla::XlaOp VAR_2 = VAR_0->Input(""size"");
    StatusOr<xla::Shape> VAR_3 =
        VAR_0->builder()->GetShape(VAR_2);
    OP_REQUIRES_OK(VAR_0, VAR_3.status());
    auto VAR_4 = VAR_3.ValueOrDie();
    auto VAR_5 = VAR_4.rank();
    OP_REQUIRES(VAR_0, VAR_5 == 0,
                errors::InvalidArgument(""Shape must be rank 0 but is rank "",
                                        VAR_5));
    OP_REQUIRES_OK(VAR_0, VAR_0->ConstantInputAsIntScalar(""size"", &VAR_1));
    OP_REQUIRES(VAR_0, VAR_1 >= 0,
                errors::InvalidArgument(""size ("", VAR_1,
                                        "") must be non-negative""));
    xla::XlaOp VAR_6, VAR_7, VAR_8;
    xla::XlaOp VAR_9 = VAR_0->Input(0);
    auto VAR_10 = VAR_0->input_xla_type(0);
    xla::PrimitiveType VAR_11 = VAR_0->InputXlaType(""weights"");
    auto VAR_12 = xla::Zero(VAR_0->builder(), VAR_11);
    auto VAR_13 = xla::One(VAR_0->builder(), VAR_11);
    StatusOr<xla::Shape> VAR_14 = VAR_0->builder()->GetShape(VAR_9);
    OP_REQUIRES_OK(VAR_0, VAR_14.status());
    auto VAR_15 = VAR_14.ValueOrDie();
    auto VAR_16 = VAR_15.dimensions(0);

    if (!VAR_16) {
      VAR_8 = xla::Broadcast(VAR_12, {VAR_1});
      VAR_0->SetOutput(0, VAR_8);
      return;
    }
    auto VAR_17 = VAR_15.rank();

    OP_REQUIRES(VAR_0, VAR_17 <= 2,
                errors::InvalidArgument(
                    ""Shape must be at most rank 2 but is rank "", VAR_17));

    xla::XlaOp VAR_18 = VAR_0->Input(2);
    StatusOr<xla::Shape> VAR_19 = VAR_0->builder()->GetShape(VAR_18);
    OP_REQUIRES_OK(VAR_0, VAR_19.status());

    auto VAR_20 = VAR_19.ValueOrDie();
    OP_REQUIRES(VAR_0,
                xla::ShapeUtil::CompatibleIgnoringElementType(VAR_20,
                                                              VAR_15) ||
                    (VAR_20.dimensions_size() > 0 &&
                     VAR_20.dimensions(0) == 0),
                errors::InvalidArgument(
                    ""`weights` must be the same shape as `arr` or a length-0 ""
                    ""`Tensor`, in which case it acts as all weights equal to ""
                    ""1. Received "",
                    VAR_20.DebugString()));

    auto VAR_21 = VAR_20.dimensions(0);
    bool VAR_22 = false;
    if (VAR_21) {
      VAR_22 = true;
    }
    xla::Shape VAR_23 = xla::ShapeUtil::MakeShape(VAR_11, {VAR_1});
    xla::ScatterDimensionNumbers VAR_24;
    VAR_24.set_index_vector_dim(1);
    VAR_24.add_inserted_window_dims(0);
    VAR_24.add_scatter_dims_to_operand_dims(0);

    if (VAR_17 == 2) {
      VAR_23 = xla::ShapeUtil::MakeShape(VAR_11, {VAR_16, VAR_1});
      VAR_24.add_inserted_window_dims(1);
      VAR_24.add_scatter_dims_to_operand_dims(1);
      auto VAR_25 =
          xla::ShapeUtil::MakeShape(VAR_10, {VAR_15.dimensions()});
      auto VAR_26 = xla::Iota(VAR_0->builder(), VAR_25, 0);
      VAR_26 = xla::Reshape(
          VAR_26, {VAR_15.dimensions(0) * VAR_15.dimensions(1), 1});
      auto VAR_27 = xla::Reshape(
          VAR_9, {VAR_15.dimensions(0) * VAR_15.dimensions(1), 1});
      std::vector<xla::XlaOp> VAR_28;
      VAR_28.push_back(VAR_26);
      VAR_28.push_back(VAR_27);
      VAR_6 = xla::ConcatInDim(VAR_0->builder(), VAR_28, 1);
      VAR_7 = xla::Broadcast(
          VAR_13, {VAR_15.dimensions(0) * VAR_15.dimensions(1)});
      VAR_8 = xla::Broadcast(
          VAR_12, {VAR_23.dimensions(0), VAR_23.dimensions(1)});
      if (VAR_22 && !VAR_29) {
        VAR_18 = xla::Reshape(
            VAR_18, {VAR_15.dimensions(0) * VAR_15.dimensions(1)});
        VAR_7 = VAR_18;
      }
    } else {
      VAR_9 = xla::Reshape(VAR_9, {VAR_16, 1});
      VAR_6 = xla::Reshape(VAR_9, {VAR_16, 1});
      VAR_7 = xla::Broadcast(VAR_13, {VAR_16});
      VAR_8 = xla::Broadcast(VAR_12, {VAR_1});
      if (VAR_22 && !VAR_29) {
        VAR_7 = VAR_18;
      }
    }

    xla::XlaComputation VAR_30 = [&] {
      std::unique_ptr<xla::XlaBuilder> VAR_31 =
          VAR_0->builder()->CreateSubBuilder(""scatter_bincount"");
      xla::Shape VAR_32 = xla::ShapeUtil::MakeShape(VAR_11, {});
      auto VAR_33 = xla::Parameter(VAR_31.get(), 0, VAR_32, ""p0"");
      auto VAR_34 = xla::Parameter(VAR_31.get(), 1, VAR_32, ""p1"");
      if (!VAR_29) {
        xla::Add(VAR_33, VAR_34);
      }
      return VAR_31->BuildAndNoteError();
    }();
    VAR_8 = xla::Scatter(VAR_8, VAR_6, VAR_7, VAR_30, VAR_24,
                          false, false);
    VAR_0->SetOutput(0, VAR_8);
  }",,"--- func_before
+++ func_after
@@ -40,6 +40,17 @@
     OP_REQUIRES_OK(ctx, weights_shape_or.status());
 
     auto weights_shape = weights_shape_or.ValueOrDie();
+    OP_REQUIRES(ctx,
+                xla::ShapeUtil::CompatibleIgnoringElementType(weights_shape,
+                                                              input_shape) ||
+                    (weights_shape.dimensions_size() > 0 &&
+                     weights_shape.dimensions(0) == 0),
+                errors::InvalidArgument(
+                    ""`weights` must be the same shape as `arr` or a length-0 ""
+                    ""`Tensor`, in which case it acts as all weights equal to ""
+                    ""1. Received "",
+                    weights_shape.DebugString()));
+
     auto weights_size = weights_shape.dimensions(0);
     bool has_weights = false;
     if (weights_size) {","{'deleted_lines': [], 'added_lines': ['    OP_REQUIRES(ctx,', '                xla::ShapeUtil::CompatibleIgnoringElementType(weights_shape,', '                                                              input_shape) ||', '                    (weights_shape.dimensions_size() > 0 &&', '                     weights_shape.dimensions(0) == 0),', '                errors::InvalidArgument(', '                    ""`weights` must be the same shape as `arr` or a length-0 ""', '                    ""`Tensor`, in which case it acts as all weights equal to ""', '                    ""1. Received "",', '                    weights_shape.DebugString()));', '']}",True,"TensorFlow is an open source platform for machine learning. `DenseBincount` assumes its input tensor `weights` to either have the same shape as its input tensor `input` or to be length-0. A different `weights` shape will trigger a `CHECK` fail that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit bf4c14353c2328636a18bfad1e151052c81d5f43. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.",5.9,MEDIUM,1,test,2022-07-13T23:13:13Z,4
CVE-2022-35987,['CWE-617'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,tensorflow,"Fix security vulnerability with DenseBincountOp

PiperOrigin-RevId: 460826735",bf4c14353c2328636a18bfad1e151052c81d5f43,https://github.com/tensorflow/tensorflow/commit/bf4c14353c2328636a18bfad1e151052c81d5f43,tensorflow/compiler/tf2xla/kernels/bincount_op.cc,Compile,"void Compile(XlaOpKernelContext* ctx) override {
int64_t output_size;
xla::XlaOp output_size_param = ctx->Input(""size"");
StatusOr<xla::Shape> output_shape_or =
ctx->builder()->GetShape(output_size_param);
OP_REQUIRES_OK(ctx, output_shape_or.status());
auto output_shape_param = output_shape_or.ValueOrDie();
auto output_rank = output_shape_param.rank();
OP_REQUIRES(ctx, output_rank == 0,
errors::InvalidArgument(""Shape must be rank 0 but is rank "",
output_rank));
OP_REQUIRES_OK(ctx, ctx->ConstantInputAsIntScalar(""size"", &output_size));
OP_REQUIRES(ctx, output_size >= 0,
errors::InvalidArgument(""size ("", output_size,
"") must be non-negative""));
xla::XlaOp idx, updates, output;
xla::XlaOp input = ctx->Input(0);
auto input_xla_type = ctx->input_xla_type(0);
xla::PrimitiveType dtype = ctx->InputXlaType(""weights"");
auto zero = xla::Zero(ctx->builder(), dtype);
auto one = xla::One(ctx->builder(), dtype);
StatusOr<xla::Shape> input_shape_or = ctx->builder()->GetShape(input);
OP_REQUIRES_OK(ctx, input_shape_or.status());
auto input_shape = input_shape_or.ValueOrDie();
auto size = input_shape.dimensions(0);
if (!size) {
output = xla::Broadcast(zero, {output_size});
ctx->SetOutput(0, output);
return;
}
auto rank = input_shape.rank();
OP_REQUIRES(ctx, rank <= 2,
errors::InvalidArgument(
""Shape must be at most rank 2 but is rank "", rank));
xla::XlaOp weights = ctx->Input(2);
StatusOr<xla::Shape> weights_shape_or = ctx->builder()->GetShape(weights);
OP_REQUIRES_OK(ctx, weights_shape_or.status());
auto weights_shape = weights_shape_or.ValueOrDie();
auto weights_size = weights_shape.dimensions(0);
bool has_weights = false;
if (weights_size) {
has_weights = true;
}
xla::Shape output_shape = xla::ShapeUtil::MakeShape(dtype, {output_size});
xla::ScatterDimensionNumbers scatter_dnums;
scatter_dnums.set_index_vector_dim(1);
scatter_dnums.add_inserted_window_dims(0);
scatter_dnums.add_scatter_dims_to_operand_dims(0);
if (rank == 2) {
output_shape = xla::ShapeUtil::MakeShape(dtype, {size, output_size});
scatter_dnums.add_inserted_window_dims(1);
scatter_dnums.add_scatter_dims_to_operand_dims(1);
auto i_shape =
xla::ShapeUtil::MakeShape(input_xla_type, {input_shape.dimensions()});
auto i = xla::Iota(ctx->builder(), i_shape, 0);
i = xla::Reshape(
i, {input_shape.dimensions(0) * input_shape.dimensions(1), 1});
auto j = xla::Reshape(
input, {input_shape.dimensions(0) * input_shape.dimensions(1), 1});
std::vector<xla::XlaOp> iotas_to_concat;
iotas_to_concat.push_back(i);
iotas_to_concat.push_back(j);
idx = xla::ConcatInDim(ctx->builder(), iotas_to_concat, 1);
updates = xla::Broadcast(
one, {input_shape.dimensions(0) * input_shape.dimensions(1)});
output = xla::Broadcast(
zero, {output_shape.dimensions(0), output_shape.dimensions(1)});
if (has_weights && !binary_output_) {
weights = xla::Reshape(
weights, {input_shape.dimensions(0) * input_shape.dimensions(1)});
updates = weights;
}
} else {
input = xla::Reshape(input, {size, 1});
idx = xla::Reshape(input, {size, 1});
updates = xla::Broadcast(one, {size});
output = xla::Broadcast(zero, {output_size});
if (has_weights && !binary_output_) {
updates = weights;
}
}
xla::XlaComputation assn_computation = [&] {
std::unique_ptr<xla::XlaBuilder> subb =
ctx->builder()->CreateSubBuilder(""scatter_bincount"");
xla::Shape param_shape = xla::ShapeUtil::MakeShape(dtype, {});
auto p0 = xla::Parameter(subb.get(), 0, param_shape, ""p0"");
auto p1 = xla::Parameter(subb.get(), 1, param_shape, ""p1"");
if (!binary_output_) {
xla::Add(p0, p1);
}
return subb->BuildAndNoteError();
}();
output = xla::Scatter(output, idx, updates, assn_computation, scatter_dnums,
false, false);
ctx->SetOutput(0, output);
}","void Compile(XlaOpKernelContext* VAR_0) override {
int64_t VAR_1;
xla::XlaOp VAR_2 = VAR_0->Input(""size"");
StatusOr<xla::Shape> VAR_3 =
VAR_0->builder()->GetShape(VAR_2);
OP_REQUIRES_OK(VAR_0, VAR_3.status());
auto VAR_4 = VAR_3.ValueOrDie();
auto VAR_5 = VAR_4.rank();
OP_REQUIRES(VAR_0, VAR_5 == 0,
errors::InvalidArgument(""Shape must be rank 0 but is rank "",
VAR_5));
OP_REQUIRES_OK(VAR_0, VAR_0->ConstantInputAsIntScalar(""size"", &VAR_1));
OP_REQUIRES(VAR_0, VAR_1 >= 0,
errors::InvalidArgument(""size ("", VAR_1,
"") must be non-negative""));
xla::XlaOp VAR_6, VAR_7, VAR_8;
xla::XlaOp VAR_9 = VAR_0->Input(0);
auto VAR_10 = VAR_0->input_xla_type(0);
xla::PrimitiveType VAR_11 = VAR_0->InputXlaType(""weights"");
auto VAR_12 = xla::Zero(VAR_0->builder(), VAR_11);
auto VAR_13 = xla::One(VAR_0->builder(), VAR_11);
StatusOr<xla::Shape> VAR_14 = VAR_0->builder()->GetShape(VAR_9);
OP_REQUIRES_OK(VAR_0, VAR_14.status());
auto VAR_15 = VAR_14.ValueOrDie();
auto VAR_16 = VAR_15.dimensions(0);
if (!VAR_16) {
VAR_8 = xla::Broadcast(VAR_12, {VAR_1});
VAR_0->SetOutput(0, VAR_8);
return;
}
auto VAR_17 = VAR_15.rank();
OP_REQUIRES(VAR_0, VAR_17 <= 2,
errors::InvalidArgument(
""Shape must be at most rank 2 but is rank "", VAR_17));
xla::XlaOp VAR_18 = VAR_0->Input(2);
StatusOr<xla::Shape> VAR_19 = VAR_0->builder()->GetShape(VAR_18);
OP_REQUIRES_OK(VAR_0, VAR_19.status());
auto VAR_20 = VAR_19.ValueOrDie();
auto VAR_21 = VAR_20.dimensions(0);
bool VAR_22 = false;
if (VAR_21) {
VAR_22 = true;
}
xla::Shape VAR_23 = xla::ShapeUtil::MakeShape(VAR_11, {VAR_1});
xla::ScatterDimensionNumbers VAR_24;
VAR_24.set_index_vector_dim(1);
VAR_24.add_inserted_window_dims(0);
VAR_24.add_scatter_dims_to_operand_dims(0);
if (VAR_17 == 2) {
VAR_23 = xla::ShapeUtil::MakeShape(VAR_11, {VAR_16, VAR_1});
VAR_24.add_inserted_window_dims(1);
VAR_24.add_scatter_dims_to_operand_dims(1);
auto VAR_25 =
xla::ShapeUtil::MakeShape(VAR_10, {VAR_15.dimensions()});
auto VAR_26 = xla::Iota(VAR_0->builder(), VAR_25, 0);
VAR_26 = xla::Reshape(
VAR_26, {VAR_15.dimensions(0) * VAR_15.dimensions(1), 1});
auto VAR_27 = xla::Reshape(
VAR_9, {VAR_15.dimensions(0) * VAR_15.dimensions(1), 1});
std::vector<xla::XlaOp> VAR_28;
VAR_28.push_back(VAR_26);
VAR_28.push_back(VAR_27);
VAR_6 = xla::ConcatInDim(VAR_0->builder(), VAR_28, 1);
VAR_7 = xla::Broadcast(
VAR_13, {VAR_15.dimensions(0) * VAR_15.dimensions(1)});
VAR_8 = xla::Broadcast(
VAR_12, {VAR_23.dimensions(0), VAR_23.dimensions(1)});
if (VAR_22 && !VAR_29) {
VAR_18 = xla::Reshape(
VAR_18, {VAR_15.dimensions(0) * VAR_15.dimensions(1)});
VAR_7 = VAR_18;
}
} else {
VAR_9 = xla::Reshape(VAR_9, {VAR_16, 1});
VAR_6 = xla::Reshape(VAR_9, {VAR_16, 1});
VAR_7 = xla::Broadcast(VAR_13, {VAR_16});
VAR_8 = xla::Broadcast(VAR_12, {VAR_1});
if (VAR_22 && !VAR_29) {
VAR_7 = VAR_18;
}
}
xla::XlaComputation VAR_30 = [&] {
std::unique_ptr<xla::XlaBuilder> VAR_31 =
VAR_0->builder()->CreateSubBuilder(""scatter_bincount"");
xla::Shape VAR_32 = xla::ShapeUtil::MakeShape(VAR_11, {});
auto VAR_33 = xla::Parameter(VAR_31.get(), 0, VAR_32, ""p0"");
auto VAR_34 = xla::Parameter(VAR_31.get(), 1, VAR_32, ""p1"");
if (!VAR_29) {
xla::Add(VAR_33, VAR_34);
}
return VAR_31->BuildAndNoteError();
}();
VAR_8 = xla::Scatter(VAR_8, VAR_6, VAR_7, VAR_30, VAR_24,
false, false);
VAR_0->SetOutput(0, VAR_8);
}",,"void Compile(XlaOpKernelContext* ctx) override {
    int64_t output_size;
    xla::XlaOp output_size_param = ctx->Input(""size"");
    StatusOr<xla::Shape> output_shape_or =
        ctx->builder()->GetShape(output_size_param);
    OP_REQUIRES_OK(ctx, output_shape_or.status());
    auto output_shape_param = output_shape_or.ValueOrDie();
    auto output_rank = output_shape_param.rank();
    OP_REQUIRES(ctx, output_rank == 0,
                errors::InvalidArgument(""Shape must be rank 0 but is rank "",
                                        output_rank));
    OP_REQUIRES_OK(ctx, ctx->ConstantInputAsIntScalar(""size"", &output_size));
    OP_REQUIRES(ctx, output_size >= 0,
                errors::InvalidArgument(""size ("", output_size,
                                        "") must be non-negative""));
    xla::XlaOp idx, updates, output;
    xla::XlaOp input = ctx->Input(0);
    auto input_xla_type = ctx->input_xla_type(0);
    xla::PrimitiveType dtype = ctx->InputXlaType(""weights"");
    auto zero = xla::Zero(ctx->builder(), dtype);
    auto one = xla::One(ctx->builder(), dtype);
    StatusOr<xla::Shape> input_shape_or = ctx->builder()->GetShape(input);
    OP_REQUIRES_OK(ctx, input_shape_or.status());
    auto input_shape = input_shape_or.ValueOrDie();
    auto size = input_shape.dimensions(0);

    if (!size) {
      output = xla::Broadcast(zero, {output_size});
      ctx->SetOutput(0, output);
      return;
    }
    auto rank = input_shape.rank();

    OP_REQUIRES(ctx, rank <= 2,
                errors::InvalidArgument(
                    ""Shape must be at most rank 2 but is rank "", rank));

    xla::XlaOp weights = ctx->Input(2);
    StatusOr<xla::Shape> weights_shape_or = ctx->builder()->GetShape(weights);
    OP_REQUIRES_OK(ctx, weights_shape_or.status());

    auto weights_shape = weights_shape_or.ValueOrDie();
    OP_REQUIRES(ctx,
                xla::ShapeUtil::CompatibleIgnoringElementType(weights_shape,
                                                              input_shape) ||
                    (weights_shape.dimensions_size() > 0 &&
                     weights_shape.dimensions(0) == 0),
                errors::InvalidArgument(
                    ""`weights` must be the same shape as `arr` or a length-0 ""
                    ""`Tensor`, in which case it acts as all weights equal to ""
                    ""1. Received "",
                    weights_shape.DebugString()));

    auto weights_size = weights_shape.dimensions(0);
    bool has_weights = false;
    if (weights_size) {
      has_weights = true;
    }
    xla::Shape output_shape = xla::ShapeUtil::MakeShape(dtype, {output_size});
    xla::ScatterDimensionNumbers scatter_dnums;
    scatter_dnums.set_index_vector_dim(1);
    scatter_dnums.add_inserted_window_dims(0);
    scatter_dnums.add_scatter_dims_to_operand_dims(0);

    if (rank == 2) {
      output_shape = xla::ShapeUtil::MakeShape(dtype, {size, output_size});
      scatter_dnums.add_inserted_window_dims(1);
      scatter_dnums.add_scatter_dims_to_operand_dims(1);
      auto i_shape =
          xla::ShapeUtil::MakeShape(input_xla_type, {input_shape.dimensions()});
      auto i = xla::Iota(ctx->builder(), i_shape, 0);
      i = xla::Reshape(
          i, {input_shape.dimensions(0) * input_shape.dimensions(1), 1});
      auto j = xla::Reshape(
          input, {input_shape.dimensions(0) * input_shape.dimensions(1), 1});
      std::vector<xla::XlaOp> iotas_to_concat;
      iotas_to_concat.push_back(i);
      iotas_to_concat.push_back(j);
      idx = xla::ConcatInDim(ctx->builder(), iotas_to_concat, 1);
      updates = xla::Broadcast(
          one, {input_shape.dimensions(0) * input_shape.dimensions(1)});
      output = xla::Broadcast(
          zero, {output_shape.dimensions(0), output_shape.dimensions(1)});
      if (has_weights && !binary_output_) {
        weights = xla::Reshape(
            weights, {input_shape.dimensions(0) * input_shape.dimensions(1)});
        updates = weights;
      }
    } else {
      input = xla::Reshape(input, {size, 1});
      idx = xla::Reshape(input, {size, 1});
      updates = xla::Broadcast(one, {size});
      output = xla::Broadcast(zero, {output_size});
      if (has_weights && !binary_output_) {
        updates = weights;
      }
    }

    xla::XlaComputation assn_computation = [&] {
      std::unique_ptr<xla::XlaBuilder> subb =
          ctx->builder()->CreateSubBuilder(""scatter_bincount"");
      xla::Shape param_shape = xla::ShapeUtil::MakeShape(dtype, {});
      auto p0 = xla::Parameter(subb.get(), 0, param_shape, ""p0"");
      auto p1 = xla::Parameter(subb.get(), 1, param_shape, ""p1"");
      if (!binary_output_) {
        xla::Add(p0, p1);
      }
      return subb->BuildAndNoteError();
    }();
    output = xla::Scatter(output, idx, updates, assn_computation, scatter_dnums,
                          false, false);
    ctx->SetOutput(0, output);
  }","void Compile(XlaOpKernelContext* VAR_0) override {
    int64_t VAR_1;
    xla::XlaOp VAR_2 = VAR_0->Input(""size"");
    StatusOr<xla::Shape> VAR_3 =
        VAR_0->builder()->GetShape(VAR_2);
    OP_REQUIRES_OK(VAR_0, VAR_3.status());
    auto VAR_4 = VAR_3.ValueOrDie();
    auto VAR_5 = VAR_4.rank();
    OP_REQUIRES(VAR_0, VAR_5 == 0,
                errors::InvalidArgument(""Shape must be rank 0 but is rank "",
                                        VAR_5));
    OP_REQUIRES_OK(VAR_0, VAR_0->ConstantInputAsIntScalar(""size"", &VAR_1));
    OP_REQUIRES(VAR_0, VAR_1 >= 0,
                errors::InvalidArgument(""size ("", VAR_1,
                                        "") must be non-negative""));
    xla::XlaOp VAR_6, VAR_7, VAR_8;
    xla::XlaOp VAR_9 = VAR_0->Input(0);
    auto VAR_10 = VAR_0->input_xla_type(0);
    xla::PrimitiveType VAR_11 = VAR_0->InputXlaType(""weights"");
    auto VAR_12 = xla::Zero(VAR_0->builder(), VAR_11);
    auto VAR_13 = xla::One(VAR_0->builder(), VAR_11);
    StatusOr<xla::Shape> VAR_14 = VAR_0->builder()->GetShape(VAR_9);
    OP_REQUIRES_OK(VAR_0, VAR_14.status());
    auto VAR_15 = VAR_14.ValueOrDie();
    auto VAR_16 = VAR_15.dimensions(0);

    if (!VAR_16) {
      VAR_8 = xla::Broadcast(VAR_12, {VAR_1});
      VAR_0->SetOutput(0, VAR_8);
      return;
    }
    auto VAR_17 = VAR_15.rank();

    OP_REQUIRES(VAR_0, VAR_17 <= 2,
                errors::InvalidArgument(
                    ""Shape must be at most rank 2 but is rank "", VAR_17));

    xla::XlaOp VAR_18 = VAR_0->Input(2);
    StatusOr<xla::Shape> VAR_19 = VAR_0->builder()->GetShape(VAR_18);
    OP_REQUIRES_OK(VAR_0, VAR_19.status());

    auto VAR_20 = VAR_19.ValueOrDie();
    OP_REQUIRES(VAR_0,
                xla::ShapeUtil::CompatibleIgnoringElementType(VAR_20,
                                                              VAR_15) ||
                    (VAR_20.dimensions_size() > 0 &&
                     VAR_20.dimensions(0) == 0),
                errors::InvalidArgument(
                    ""`weights` must be the same shape as `arr` or a length-0 ""
                    ""`Tensor`, in which case it acts as all weights equal to ""
                    ""1. Received "",
                    VAR_20.DebugString()));

    auto VAR_21 = VAR_20.dimensions(0);
    bool VAR_22 = false;
    if (VAR_21) {
      VAR_22 = true;
    }
    xla::Shape VAR_23 = xla::ShapeUtil::MakeShape(VAR_11, {VAR_1});
    xla::ScatterDimensionNumbers VAR_24;
    VAR_24.set_index_vector_dim(1);
    VAR_24.add_inserted_window_dims(0);
    VAR_24.add_scatter_dims_to_operand_dims(0);

    if (VAR_17 == 2) {
      VAR_23 = xla::ShapeUtil::MakeShape(VAR_11, {VAR_16, VAR_1});
      VAR_24.add_inserted_window_dims(1);
      VAR_24.add_scatter_dims_to_operand_dims(1);
      auto VAR_25 =
          xla::ShapeUtil::MakeShape(VAR_10, {VAR_15.dimensions()});
      auto VAR_26 = xla::Iota(VAR_0->builder(), VAR_25, 0);
      VAR_26 = xla::Reshape(
          VAR_26, {VAR_15.dimensions(0) * VAR_15.dimensions(1), 1});
      auto VAR_27 = xla::Reshape(
          VAR_9, {VAR_15.dimensions(0) * VAR_15.dimensions(1), 1});
      std::vector<xla::XlaOp> VAR_28;
      VAR_28.push_back(VAR_26);
      VAR_28.push_back(VAR_27);
      VAR_6 = xla::ConcatInDim(VAR_0->builder(), VAR_28, 1);
      VAR_7 = xla::Broadcast(
          VAR_13, {VAR_15.dimensions(0) * VAR_15.dimensions(1)});
      VAR_8 = xla::Broadcast(
          VAR_12, {VAR_23.dimensions(0), VAR_23.dimensions(1)});
      if (VAR_22 && !VAR_29) {
        VAR_18 = xla::Reshape(
            VAR_18, {VAR_15.dimensions(0) * VAR_15.dimensions(1)});
        VAR_7 = VAR_18;
      }
    } else {
      VAR_9 = xla::Reshape(VAR_9, {VAR_16, 1});
      VAR_6 = xla::Reshape(VAR_9, {VAR_16, 1});
      VAR_7 = xla::Broadcast(VAR_13, {VAR_16});
      VAR_8 = xla::Broadcast(VAR_12, {VAR_1});
      if (VAR_22 && !VAR_29) {
        VAR_7 = VAR_18;
      }
    }

    xla::XlaComputation VAR_30 = [&] {
      std::unique_ptr<xla::XlaBuilder> VAR_31 =
          VAR_0->builder()->CreateSubBuilder(""scatter_bincount"");
      xla::Shape VAR_32 = xla::ShapeUtil::MakeShape(VAR_11, {});
      auto VAR_33 = xla::Parameter(VAR_31.get(), 0, VAR_32, ""p0"");
      auto VAR_34 = xla::Parameter(VAR_31.get(), 1, VAR_32, ""p1"");
      if (!VAR_29) {
        xla::Add(VAR_33, VAR_34);
      }
      return VAR_31->BuildAndNoteError();
    }();
    VAR_8 = xla::Scatter(VAR_8, VAR_6, VAR_7, VAR_30, VAR_24,
                          false, false);
    VAR_0->SetOutput(0, VAR_8);
  }",,"--- func_before
+++ func_after
@@ -40,6 +40,17 @@
     OP_REQUIRES_OK(ctx, weights_shape_or.status());
 
     auto weights_shape = weights_shape_or.ValueOrDie();
+    OP_REQUIRES(ctx,
+                xla::ShapeUtil::CompatibleIgnoringElementType(weights_shape,
+                                                              input_shape) ||
+                    (weights_shape.dimensions_size() > 0 &&
+                     weights_shape.dimensions(0) == 0),
+                errors::InvalidArgument(
+                    ""`weights` must be the same shape as `arr` or a length-0 ""
+                    ""`Tensor`, in which case it acts as all weights equal to ""
+                    ""1. Received "",
+                    weights_shape.DebugString()));
+
     auto weights_size = weights_shape.dimensions(0);
     bool has_weights = false;
     if (weights_size) {","{'deleted_lines': [], 'added_lines': ['    OP_REQUIRES(ctx,', '                xla::ShapeUtil::CompatibleIgnoringElementType(weights_shape,', '                                                              input_shape) ||', '                    (weights_shape.dimensions_size() > 0 &&', '                     weights_shape.dimensions(0) == 0),', '                errors::InvalidArgument(', '                    ""`weights` must be the same shape as `arr` or a length-0 ""', '                    ""`Tensor`, in which case it acts as all weights equal to ""', '                    ""1. Received "",', '                    weights_shape.DebugString()));', '']}",True,"TensorFlow is an open source platform for machine learning. `DenseBincount` assumes its input tensor `weights` to either have the same shape as its input tensor `input` or to be length-0. A different `weights` shape will trigger a `CHECK` fail that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit bf4c14353c2328636a18bfad1e151052c81d5f43. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.",5.9,MEDIUM,1,test,2022-07-13T23:13:13Z,4
CVE-2022-35965,['CWE-476'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,tensorflow,"Fix empty inputs for Upper/LowerBound.

For upper/lower-bound searches via `tf.searchsorted`, if the sorted input is empty,
the previous code resulted in a `nullptr` dereference.  For emtpy inputs, any
sorted search should return a value of 0, meaning that a value would be inserted
into the first slot of the array.

PiperOrigin-RevId: 460971165",bce3717eaef4f769019fd18e990464ca4a2efeea,https://github.com/tensorflow/tensorflow/commit/bce3717eaef4f769019fd18e990464ca4a2efeea,tensorflow/core/kernels/searchsorted_op.cc,Compute,"void Compute(OpKernelContext* ctx) override {
const Tensor& sorted_inputs_t = ctx->input(0);
const Tensor& values_t = ctx->input(1);
OP_REQUIRES(
ctx, sorted_inputs_t.shape().dims() >= 2,
errors::InvalidArgument(""sorted input argument must be a matrix""));
OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),
Status(error::INVALID_ARGUMENT,
""Leading dim_size of both tensors must match.""));
OP_REQUIRES(ctx, values_t.NumElements() < std::numeric_limits<int>::max(),
Status(error::INVALID_ARGUMENT,
""values tensor size must less than INT_MAX""));
Tensor* output_t;
OP_REQUIRES_OK(ctx, ctx->allocate_output(0, values_t.shape(), &output_t));
if (output_t->dtype() == DT_INT32) {
OP_REQUIRES(ctx,
FastBoundsCheck(sorted_inputs_t.dim_size(1),
std::numeric_limits<int>::max()),
errors::InvalidArgument(""trailing dim_size must less than ""
""INT_MAX for int32 output type, was "",
sorted_inputs_t.dim_size(1)));
}
auto output = output_t->template flat<OutType>();
const auto sorted_inputs = sorted_inputs_t.template flat<T>();
const auto values = values_t.template flat<T>();
OP_REQUIRES_OK(
ctx, functor::LowerBoundFunctor<Device, T, OutType>::Compute(
ctx, sorted_inputs, values, sorted_inputs_t.dim_size(0),
sorted_inputs_t.dim_size(1), values_t.dim_size(1), &output));
}","void Compute(OpKernelContext* VAR_0) override {
const Tensor& VAR_1 = VAR_0->input(0);
const Tensor& VAR_2 = VAR_0->input(1);
OP_REQUIRES(
VAR_0, VAR_1.shape().dims() >= 2,
errors::InvalidArgument(""sorted input argument must be a matrix""));
OP_REQUIRES(VAR_0, VAR_1.dim_size(0) == VAR_2.dim_size(0),
Status(error::INVALID_ARGUMENT,
""Leading dim_size of both tensors must match.""));
OP_REQUIRES(VAR_0, VAR_2.NumElements() < std::numeric_limits<int>::max(),
Status(error::INVALID_ARGUMENT,
""values tensor size must less than INT_MAX""));
Tensor* VAR_3;
OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(0, VAR_2.shape(), &VAR_3));
if (VAR_3->dtype() == VAR_4) {
OP_REQUIRES(VAR_0,
FastBoundsCheck(VAR_1.dim_size(1),
std::numeric_limits<int>::max()),
errors::InvalidArgument(""trailing dim_size must less than ""
""INT_MAX for int32 output type, was "",
VAR_1.dim_size(1)));
}
auto VAR_5 = VAR_3->template flat<OutType>();
const auto VAR_6 = VAR_1.template flat<T>();
const auto VAR_7 = VAR_2.template flat<T>();
OP_REQUIRES_OK(
VAR_0, functor::LowerBoundFunctor<Device, T, OutType>::Compute(
VAR_0, VAR_6, VAR_7, VAR_1.dim_size(0),
VAR_1.dim_size(1), VAR_2.dim_size(1), &VAR_5));
}",,"void Compute(OpKernelContext* ctx) override {
    const Tensor& sorted_inputs_t = ctx->input(0);
    const Tensor& values_t = ctx->input(1);

    // inputs must be at least a matrix
    OP_REQUIRES(
        ctx, sorted_inputs_t.shape().dims() >= 2,
        errors::InvalidArgument(""sorted input argument must be a matrix""));
    // must have same batch dim_size for both
    OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),
                Status(error::INVALID_ARGUMENT,
                       ""Leading dim_size of both tensors must match.""));

    // this is required because we do indexing in int32 on the GPU
    OP_REQUIRES(ctx, values_t.NumElements() < std::numeric_limits<int>::max(),
                Status(error::INVALID_ARGUMENT,
                       ""values tensor size must less than INT_MAX""));

    Tensor* output_t;
    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, values_t.shape(), &output_t));

    if (output_t->dtype() == DT_INT32) {
      OP_REQUIRES(ctx,
                  FastBoundsCheck(sorted_inputs_t.dim_size(1),
                                  std::numeric_limits<int>::max()),
                  errors::InvalidArgument(""trailing dim_size must less than ""
                                          ""INT_MAX for int32 output type, was "",
                                          sorted_inputs_t.dim_size(1)));
    }

    auto output = output_t->template flat<OutType>();
    const auto sorted_inputs = sorted_inputs_t.template flat<T>();
    const auto values = values_t.template flat<T>();

    // For empty inputs, all values will be placed at the zeroth position.
    if (sorted_inputs.size() == 0) {
      functor::SetZeroFunctor<Device, OutType> set_zero;
      set_zero(ctx->eigen_device<Device>(), output);
      return;
    }

    OP_REQUIRES_OK(
        ctx, functor::LowerBoundFunctor<Device, T, OutType>::Compute(
                 ctx, sorted_inputs, values, sorted_inputs_t.dim_size(0),
                 sorted_inputs_t.dim_size(1), values_t.dim_size(1), &output));
  }","void Compute(OpKernelContext* VAR_0) override {
    const Tensor& VAR_1 = VAR_0->input(0);
    const Tensor& VAR_2 = VAR_0->input(1);

    /* COMMENT_0 */
    OP_REQUIRES(
        VAR_0, VAR_1.shape().dims() >= 2,
        errors::InvalidArgument(""sorted input argument must be a matrix""));
    /* COMMENT_1 */
    OP_REQUIRES(VAR_0, VAR_1.dim_size(0) == VAR_2.dim_size(0),
                Status(error::INVALID_ARGUMENT,
                       ""Leading dim_size of both tensors must match.""));

    /* COMMENT_2 */
    OP_REQUIRES(VAR_0, VAR_2.NumElements() < std::numeric_limits<int>::max(),
                Status(error::INVALID_ARGUMENT,
                       ""values tensor size must less than INT_MAX""));

    Tensor* VAR_3;
    OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(0, VAR_2.shape(), &VAR_3));

    if (VAR_3->dtype() == VAR_4) {
      OP_REQUIRES(VAR_0,
                  FastBoundsCheck(VAR_1.dim_size(1),
                                  std::numeric_limits<int>::max()),
                  errors::InvalidArgument(""trailing dim_size must less than ""
                                          ""INT_MAX for int32 output type, was "",
                                          VAR_1.dim_size(1)));
    }

    auto VAR_5 = VAR_3->template flat<OutType>();
    const auto VAR_6 = VAR_1.template flat<T>();
    const auto VAR_7 = VAR_2.template flat<T>();

    /* COMMENT_3 */
    if (VAR_6.size() == 0) {
      functor::SetZeroFunctor<Device, OutType> VAR_8;
      VAR_8(VAR_0->eigen_device<Device>(), VAR_5);
      return;
    }

    OP_REQUIRES_OK(
        VAR_0, functor::LowerBoundFunctor<Device, T, OutType>::Compute(
                 VAR_0, VAR_6, VAR_7, VAR_1.dim_size(0),
                 VAR_1.dim_size(1), VAR_2.dim_size(1), &VAR_5));
  }",,"--- func_before
+++ func_after
@@ -31,6 +31,14 @@
     auto output = output_t->template flat<OutType>();
     const auto sorted_inputs = sorted_inputs_t.template flat<T>();
     const auto values = values_t.template flat<T>();
+
+    // For empty inputs, all values will be placed at the zeroth position.
+    if (sorted_inputs.size() == 0) {
+      functor::SetZeroFunctor<Device, OutType> set_zero;
+      set_zero(ctx->eigen_device<Device>(), output);
+      return;
+    }
+
     OP_REQUIRES_OK(
         ctx, functor::LowerBoundFunctor<Device, T, OutType>::Compute(
                  ctx, sorted_inputs, values, sorted_inputs_t.dim_size(0),","{'deleted_lines': [], 'added_lines': ['', '    // For empty inputs, all values will be placed at the zeroth position.', '    if (sorted_inputs.size() == 0) {', '      functor::SetZeroFunctor<Device, OutType> set_zero;', '      set_zero(ctx->eigen_device<Device>(), output);', '      return;', '    }', '']}",True,"TensorFlow is an open source platform for machine learning. If `LowerBound` or `UpperBound` is given an empty`sorted_inputs` input, it results in a `nullptr` dereference, leading to a segfault that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit bce3717eaef4f769019fd18e990464ca4a2efeea. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.",5.9,MEDIUM,1,test,2022-07-14T15:49:19Z,4
CVE-2022-35970,"['CWE-617', 'CWE-20']",CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,tensorflow,"Fix quantize ops input validation issues.

The majority of these are just missing checks on min/max.

PiperOrigin-RevId: 461800665",785d67a78a1d533759fcd2f5e8d6ef778de849e0,https://github.com/tensorflow/tensorflow/commit/785d67a78a1d533759fcd2f5e8d6ef778de849e0,tensorflow/core/kernels/quantized_bias_add_op.cc,Compute,"void Compute(OpKernelContext* context) override {
const Tensor& input = context->input(0);
const Tensor& bias = context->input(1);
const float input_min = context->input(2).flat<float>()(0);
const float input_max = context->input(3).flat<float>()(0);
const float bias_min = context->input(4).flat<float>()(0);
const float bias_max = context->input(5).flat<float>()(0);
OP_REQUIRES(context, TensorShapeUtils::IsMatrixOrHigher(input.shape()),
errors::InvalidArgument(""Input tensor must be at least 2D: "",
input.shape().DebugString()));
OP_REQUIRES(context, TensorShapeUtils::IsVector(bias.shape()),
errors::InvalidArgument(""Biases must be 1D: "",
bias.shape().DebugString()));
const auto last_dim = input.shape().dims() - 1;
OP_REQUIRES(
context, bias.shape().dim_size(0) == input.shape().dim_size(last_dim),
errors::InvalidArgument(
""Must provide as many biases as the last dimension ""
""of the input tensor: "",
bias.shape().DebugString(), "" vs. "", input.shape().DebugString()));
OP_REQUIRES(context, bias.NumElements() > 0,
errors::InvalidArgument(""Must provide at least 1 bias""));
Tensor* output = nullptr;
OP_REQUIRES_OK(context,
context->allocate_output(0, input.shape(), &output));
float total_min;
float total_max;
if (meta::IsSupportedAndEnabled() && std::is_same<T1, quint8>() &&
std::is_same<T2, quint8>() && std::is_same<T3, qint32>()) {
auto input_ui8_array = input.flat<quint8>();
auto bias_ui8_array = bias.flat<quint8>();
GetOutputMinAndMaxForQuantizedAdd(input_min, input_max, bias_min,
bias_max, &total_min, &total_max);
meta::QuantizedBiasAdd(context, input_ui8_array.data(),
input_ui8_array.size(), bias_ui8_array.data(),
bias_ui8_array.size(), input_min, input_max,
bias_min, bias_max, total_min, total_max,
output->flat<qint32>().data());
} else {
QuantizedAddUsingEigen<T1, T2, T3>(
context->template eigen_device<CPUDevice>(), input, input_min,
input_max, bias, bias_min, bias_max, output, &total_min, &total_max);
}
Tensor* output_min = nullptr;
OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));
output_min->flat<float>()(0) = total_min;
Tensor* output_max = nullptr;
OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));
output_max->flat<float>()(0) = total_max;
}","void Compute(OpKernelContext* VAR_0) override {
const Tensor& VAR_1 = VAR_0->input(0);
const Tensor& VAR_2 = VAR_0->input(1);
const float VAR_3 = VAR_0->input(2).flat<float>()(0);
const float VAR_4 = VAR_0->input(3).flat<float>()(0);
const float VAR_5 = VAR_0->input(4).flat<float>()(0);
const float VAR_6 = VAR_0->input(5).flat<float>()(0);
OP_REQUIRES(VAR_0, TensorShapeUtils::IsMatrixOrHigher(VAR_1.shape()),
errors::InvalidArgument(""Input tensor must be at least 2D: "",
VAR_1.shape().DebugString()));
OP_REQUIRES(VAR_0, TensorShapeUtils::IsVector(VAR_2.shape()),
errors::InvalidArgument(""Biases must be 1D: "",
VAR_2.shape().DebugString()));
const auto VAR_7 = VAR_1.shape().dims() - 1;
OP_REQUIRES(
VAR_0, VAR_2.shape().dim_size(0) == VAR_1.shape().dim_size(VAR_7),
errors::InvalidArgument(
""Must provide as many biases as the last dimension ""
""of the input tensor: "",
VAR_2.shape().DebugString(), "" vs. "", VAR_1.shape().DebugString()));
OP_REQUIRES(VAR_0, VAR_2.NumElements() > 0,
errors::InvalidArgument(""Must provide at least 1 bias""));
Tensor* VAR_8 = nullptr;
OP_REQUIRES_OK(VAR_0,
VAR_0->allocate_output(0, VAR_1.shape(), &VAR_8));
float VAR_9;
float VAR_10;
if (meta::IsSupportedAndEnabled() && std::VAR_11<T1, quint8>() &&
std::VAR_11<T2, quint8>() && std::VAR_11<T3, qint32>()) {
auto VAR_12 = VAR_1.flat<quint8>();
auto VAR_13 = VAR_2.flat<quint8>();
GetOutputMinAndMaxForQuantizedAdd(VAR_3, VAR_4, VAR_5,
VAR_6, &VAR_9, &VAR_10);
meta::QuantizedBiasAdd(VAR_0, VAR_12.data(),
VAR_12.size(), VAR_13.data(),
VAR_13.size(), VAR_3, VAR_4,
VAR_5, VAR_6, VAR_9, VAR_10,
VAR_8->flat<qint32>().data());
} else {
VAR_14<T1, T2, T3>(
VAR_0->template eigen_device<CPUDevice>(), VAR_1, VAR_3,
VAR_4, VAR_2, VAR_5, VAR_6, VAR_8, &VAR_9, &VAR_10);
}
Tensor* VAR_15 = nullptr;
OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(1, {}, &VAR_15));
VAR_15->flat<float>()(0) = VAR_9;
Tensor* VAR_16 = nullptr;
OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(2, {}, &VAR_16));
VAR_16->flat<float>()(0) = VAR_10;
}",,"void Compute(OpKernelContext* context) override {
    const Tensor& input = context->input(0);
    const Tensor& bias = context->input(1);

    const Tensor& min_input = context->input(2);
    const Tensor& max_input = context->input(3);
    const Tensor& min_bias = context->input(4);
    const Tensor& max_bias = context->input(5);
    OP_REQUIRES(
        context, TensorShapeUtils::IsScalar(min_input.shape()),
        errors::InvalidArgument(""`min_input` must be rank 0 but is rank "",
                                min_input.dims()));
    OP_REQUIRES(
        context, TensorShapeUtils::IsScalar(max_input.shape()),
        errors::InvalidArgument(""`max_input` must be rank 0 but is rank "",
                                max_input.dims()));
    OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_bias.shape()),
                errors::InvalidArgument(
                    ""`min_bias` must be rank 0 but is rank "", min_bias.dims()));
    OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_bias.shape()),
                errors::InvalidArgument(
                    ""`max_bias` must be rank 0 but is rank "", max_bias.dims()));

    const float input_min = min_input.flat<float>()(0);
    const float input_max = max_input.flat<float>()(0);
    const float bias_min = min_bias.flat<float>()(0);
    const float bias_max = max_bias.flat<float>()(0);

    OP_REQUIRES(context, TensorShapeUtils::IsMatrixOrHigher(input.shape()),
                errors::InvalidArgument(""Input tensor must be at least 2D: "",
                                        input.shape().DebugString()));
    OP_REQUIRES(context, TensorShapeUtils::IsVector(bias.shape()),
                errors::InvalidArgument(""Biases must be 1D: "",
                                        bias.shape().DebugString()));
    const auto last_dim = input.shape().dims() - 1;
    OP_REQUIRES(
        context, bias.shape().dim_size(0) == input.shape().dim_size(last_dim),
        errors::InvalidArgument(
            ""Must provide as many biases as the last dimension ""
            ""of the input tensor: "",
            bias.shape().DebugString(), "" vs. "", input.shape().DebugString()));
    OP_REQUIRES(context, bias.NumElements() > 0,
                errors::InvalidArgument(""Must provide at least 1 bias""));

    Tensor* output = nullptr;
    OP_REQUIRES_OK(context,
                   context->allocate_output(0, input.shape(), &output));

    float total_min;
    float total_max;

    if (meta::IsSupportedAndEnabled() && std::is_same<T1, quint8>() &&
        std::is_same<T2, quint8>() && std::is_same<T3, qint32>()) {
      auto input_ui8_array = input.flat<quint8>();
      auto bias_ui8_array = bias.flat<quint8>();
      GetOutputMinAndMaxForQuantizedAdd(input_min, input_max, bias_min,
                                        bias_max, &total_min, &total_max);
      meta::QuantizedBiasAdd(context, input_ui8_array.data(),
                             input_ui8_array.size(), bias_ui8_array.data(),
                             bias_ui8_array.size(), input_min, input_max,
                             bias_min, bias_max, total_min, total_max,
                             output->flat<qint32>().data());
    } else {
      QuantizedAddUsingEigen<T1, T2, T3>(
          context->template eigen_device<CPUDevice>(), input, input_min,
          input_max, bias, bias_min, bias_max, output, &total_min, &total_max);
    }

    Tensor* output_min = nullptr;
    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));
    output_min->flat<float>()(0) = total_min;

    Tensor* output_max = nullptr;
    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));
    output_max->flat<float>()(0) = total_max;
  }","void Compute(OpKernelContext* VAR_0) override {
    const Tensor& VAR_1 = VAR_0->input(0);
    const Tensor& VAR_2 = VAR_0->input(1);

    const Tensor& VAR_3 = VAR_0->input(2);
    const Tensor& VAR_4 = VAR_0->input(3);
    const Tensor& VAR_5 = VAR_0->input(4);
    const Tensor& VAR_6 = VAR_0->input(5);
    OP_REQUIRES(
        VAR_0, TensorShapeUtils::IsScalar(VAR_3.shape()),
        errors::InvalidArgument(""`min_input` must be rank 0 but is rank "",
                                VAR_3.dims()));
    OP_REQUIRES(
        VAR_0, TensorShapeUtils::IsScalar(VAR_4.shape()),
        errors::InvalidArgument(""`max_input` must be rank 0 but is rank "",
                                VAR_4.dims()));
    OP_REQUIRES(VAR_0, TensorShapeUtils::IsScalar(VAR_5.shape()),
                errors::InvalidArgument(
                    ""`min_bias` must be rank 0 but is rank "", VAR_5.dims()));
    OP_REQUIRES(VAR_0, TensorShapeUtils::IsScalar(VAR_6.shape()),
                errors::InvalidArgument(
                    ""`max_bias` must be rank 0 but is rank "", VAR_6.dims()));

    const float VAR_7 = VAR_3.flat<float>()(0);
    const float VAR_8 = VAR_4.flat<float>()(0);
    const float VAR_9 = VAR_5.flat<float>()(0);
    const float VAR_10 = VAR_6.flat<float>()(0);

    OP_REQUIRES(VAR_0, TensorShapeUtils::IsMatrixOrHigher(VAR_1.shape()),
                errors::InvalidArgument(""Input tensor must be at least 2D: "",
                                        VAR_1.shape().DebugString()));
    OP_REQUIRES(VAR_0, TensorShapeUtils::IsVector(VAR_2.shape()),
                errors::InvalidArgument(""Biases must be 1D: "",
                                        VAR_2.shape().DebugString()));
    const auto VAR_11 = VAR_1.shape().dims() - 1;
    OP_REQUIRES(
        VAR_0, VAR_2.shape().dim_size(0) == VAR_1.shape().dim_size(VAR_11),
        errors::InvalidArgument(
            ""Must provide as many biases as the last dimension ""
            ""of the input tensor: "",
            VAR_2.shape().DebugString(), "" vs. "", VAR_1.shape().DebugString()));
    OP_REQUIRES(VAR_0, VAR_2.NumElements() > 0,
                errors::InvalidArgument(""Must provide at least 1 bias""));

    Tensor* VAR_12 = nullptr;
    OP_REQUIRES_OK(VAR_0,
                   VAR_0->allocate_output(0, VAR_1.shape(), &VAR_12));

    float VAR_13;
    float VAR_14;

    if (meta::IsSupportedAndEnabled() && std::VAR_15<T1, quint8>() &&
        std::VAR_15<T2, quint8>() && std::VAR_15<T3, qint32>()) {
      auto VAR_16 = VAR_1.flat<quint8>();
      auto VAR_17 = VAR_2.flat<quint8>();
      GetOutputMinAndMaxForQuantizedAdd(VAR_7, VAR_8, VAR_9,
                                        VAR_10, &VAR_13, &VAR_14);
      meta::QuantizedBiasAdd(VAR_0, VAR_16.data(),
                             VAR_16.size(), VAR_17.data(),
                             VAR_17.size(), VAR_7, VAR_8,
                             VAR_9, VAR_10, VAR_13, VAR_14,
                             VAR_12->flat<qint32>().data());
    } else {
      VAR_18<T1, T2, T3>(
          VAR_0->template eigen_device<CPUDevice>(), VAR_1, VAR_7,
          VAR_8, VAR_2, VAR_9, VAR_10, VAR_12, &VAR_13, &VAR_14);
    }

    Tensor* VAR_19 = nullptr;
    OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(1, {}, &VAR_19));
    VAR_19->flat<float>()(0) = VAR_13;

    Tensor* VAR_20 = nullptr;
    OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(2, {}, &VAR_20));
    VAR_20->flat<float>()(0) = VAR_14;
  }",,"--- func_before
+++ func_after
@@ -1,10 +1,30 @@
 void Compute(OpKernelContext* context) override {
     const Tensor& input = context->input(0);
     const Tensor& bias = context->input(1);
-    const float input_min = context->input(2).flat<float>()(0);
-    const float input_max = context->input(3).flat<float>()(0);
-    const float bias_min = context->input(4).flat<float>()(0);
-    const float bias_max = context->input(5).flat<float>()(0);
+
+    const Tensor& min_input = context->input(2);
+    const Tensor& max_input = context->input(3);
+    const Tensor& min_bias = context->input(4);
+    const Tensor& max_bias = context->input(5);
+    OP_REQUIRES(
+        context, TensorShapeUtils::IsScalar(min_input.shape()),
+        errors::InvalidArgument(""`min_input` must be rank 0 but is rank "",
+                                min_input.dims()));
+    OP_REQUIRES(
+        context, TensorShapeUtils::IsScalar(max_input.shape()),
+        errors::InvalidArgument(""`max_input` must be rank 0 but is rank "",
+                                max_input.dims()));
+    OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_bias.shape()),
+                errors::InvalidArgument(
+                    ""`min_bias` must be rank 0 but is rank "", min_bias.dims()));
+    OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_bias.shape()),
+                errors::InvalidArgument(
+                    ""`max_bias` must be rank 0 but is rank "", max_bias.dims()));
+
+    const float input_min = min_input.flat<float>()(0);
+    const float input_max = max_input.flat<float>()(0);
+    const float bias_min = min_bias.flat<float>()(0);
+    const float bias_max = max_bias.flat<float>()(0);
 
     OP_REQUIRES(context, TensorShapeUtils::IsMatrixOrHigher(input.shape()),
                 errors::InvalidArgument(""Input tensor must be at least 2D: "",","{'deleted_lines': ['    const float input_min = context->input(2).flat<float>()(0);', '    const float input_max = context->input(3).flat<float>()(0);', '    const float bias_min = context->input(4).flat<float>()(0);', '    const float bias_max = context->input(5).flat<float>()(0);'], 'added_lines': ['', '    const Tensor& min_input = context->input(2);', '    const Tensor& max_input = context->input(3);', '    const Tensor& min_bias = context->input(4);', '    const Tensor& max_bias = context->input(5);', '    OP_REQUIRES(', '        context, TensorShapeUtils::IsScalar(min_input.shape()),', '        errors::InvalidArgument(""`min_input` must be rank 0 but is rank "",', '                                min_input.dims()));', '    OP_REQUIRES(', '        context, TensorShapeUtils::IsScalar(max_input.shape()),', '        errors::InvalidArgument(""`max_input` must be rank 0 but is rank "",', '                                max_input.dims()));', '    OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_bias.shape()),', '                errors::InvalidArgument(', '                    ""`min_bias` must be rank 0 but is rank "", min_bias.dims()));', '    OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_bias.shape()),', '                errors::InvalidArgument(', '                    ""`max_bias` must be rank 0 but is rank "", max_bias.dims()));', '', '    const float input_min = min_input.flat<float>()(0);', '    const float input_max = max_input.flat<float>()(0);', '    const float bias_min = min_bias.flat<float>()(0);', '    const float bias_max = max_bias.flat<float>()(0);']}",True,"TensorFlow is an open source platform for machine learning. If `QuantizedInstanceNorm` is given `x_min` or `x_max` tensors of a nonzero rank, it results in a segfault that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit 785d67a78a1d533759fcd2f5e8d6ef778de849e0. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.",5.9,MEDIUM,1,test,2022-07-19T05:40:58Z,4
CVE-2022-35970,"['CWE-617', 'CWE-20']",CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,tensorflow,"Fix quantize ops input validation issues.

The majority of these are just missing checks on min/max.

PiperOrigin-RevId: 461800665",785d67a78a1d533759fcd2f5e8d6ef778de849e0,https://github.com/tensorflow/tensorflow/commit/785d67a78a1d533759fcd2f5e8d6ef778de849e0,tensorflow/core/kernels/requantize.cc,Compute,"void Compute(OpKernelContext* ctx) override {
const Tensor& input = ctx->input(0);
const float input_min_float = ctx->input(1).flat<float>()(0);
const float input_max_float = ctx->input(2).flat<float>()(0);
const float requested_output_min_float = ctx->input(3).flat<float>()(0);
const float requested_output_max_float = ctx->input(4).flat<float>()(0);
Tensor* output = nullptr;
OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));
Tensor* output_min = nullptr;
OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));
Tensor* output_max = nullptr;
OP_REQUIRES_OK(ctx, ctx->allocate_output(2, TensorShape({}), &output_max));
OP_REQUIRES(
ctx, requested_output_min_float <= 0.0f,
errors::InvalidArgument(""requested_output_min must be <= 0, but got "",
requested_output_min_float));
OP_REQUIRES(
ctx, requested_output_max_float >= requested_output_min_float,
errors::InvalidArgument(
""requested_output_max must be >= requested_output_min, but got "",
requested_output_max_float, "" and "", requested_output_min_float));
auto input_array = input.flat<T1>();
#if 0
auto output_array = output->flat<T2>();
RequantizeManyInNewRange<T1, T2>(
input_array.data(), input_array.size(),
input_min_float, input_max_float,
requested_output_min_float, requested_output_max_float,
output_array.data());
#endif
if (input_array.size() > 0) {
if (meta::IsSupportedAndEnabled() && std::is_same<T1, qint32>() &&
std::is_same<T2, quint8>()) {
auto input_i32_array = input.flat<qint32>();
meta::Requantize(ctx, input_i32_array.data(), input_i32_array.size(),
input_min_float, input_max_float,
requested_output_min_float, requested_output_max_float,
output->flat<quint8>().data());
} else {
RequantizeManyInNewRangeUsingEigen<T1, T2>(
ctx->eigen_device<CPUDevice>(), input, input_min_float,
input_max_float, requested_output_min_float,
requested_output_max_float, output);
}
}
output_min->flat<float>().setConstant(requested_output_min_float);
output_max->flat<float>().setConstant(requested_output_max_float);
}","void Compute(OpKernelContext* VAR_0) override {
const Tensor& VAR_1 = VAR_0->input(0);
const float VAR_2 = VAR_0->input(1).flat<float>()(0);
const float VAR_3 = VAR_0->input(2).flat<float>()(0);
const float VAR_4 = VAR_0->input(3).flat<float>()(0);
const float VAR_5 = VAR_0->input(4).flat<float>()(0);
Tensor* VAR_6 = nullptr;
OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(0, VAR_1.shape(), &VAR_6));
Tensor* VAR_7 = nullptr;
OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(1, TensorShape({}), &VAR_7));
Tensor* VAR_8 = nullptr;
OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(2, TensorShape({}), &VAR_8));
OP_REQUIRES(
VAR_0, VAR_4 <= 0.0f,
errors::InvalidArgument(""requested_output_min must be <= 0, but got "",
VAR_4));
OP_REQUIRES(
VAR_0, VAR_5 >= VAR_4,
errors::InvalidArgument(
""requested_output_max must be >= requested_output_min, but got "",
VAR_5, "" and "", VAR_4));
auto VAR_9 = VAR_1.flat<T1>();
#if 0
auto VAR_10 = VAR_6->flat<T2>();
VAR_11<T1, T2>(
VAR_9.data(), VAR_9.size(),
VAR_2, VAR_3,
VAR_4, VAR_5,
VAR_10.data());
#endif
if (VAR_9.size() > 0) {
if (meta::IsSupportedAndEnabled() && std::VAR_12<T1, qint32>() &&
std::VAR_12<T2, quint8>()) {
auto VAR_13 = VAR_1.flat<qint32>();
meta::Requantize(VAR_0, VAR_13.data(), VAR_13.size(),
VAR_2, VAR_3,
VAR_4, VAR_5,
VAR_6->flat<quint8>().data());
} else {
VAR_14<T1, T2>(
VAR_0->eigen_device<CPUDevice>(), VAR_1, VAR_2,
VAR_3, VAR_4,
VAR_5, VAR_6);
}
}
VAR_7->flat<float>().setConstant(VAR_4);
VAR_8->flat<float>().setConstant(VAR_5);
}",,"void Compute(OpKernelContext* ctx) override {
    const Tensor& input = ctx->input(0);

    const Tensor& input_min = ctx->input(1);
    const Tensor& input_max = ctx->input(2);
    const Tensor& requested_output_min = ctx->input(3);
    const Tensor& requested_output_max = ctx->input(4);
    OP_REQUIRES(
        ctx, TensorShapeUtils::IsScalar(input_min.shape()),
        errors::InvalidArgument(""`input_min` must be rank 0 but is rank "",
                                input_min.dims()));
    OP_REQUIRES(
        ctx, TensorShapeUtils::IsScalar(input_max.shape()),
        errors::InvalidArgument(""`input_max` must be rank 0 but is rank "",
                                input_max.dims()));
    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(requested_output_min.shape()),
                errors::InvalidArgument(
                    ""`requested_output_min` must be rank 0 but is rank "",
                    requested_output_min.dims()));
    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(requested_output_max.shape()),
                errors::InvalidArgument(
                    ""`requested_output_max` must be rank 0 but is rank "",
                    requested_output_max.dims()));

    const float input_min_float = input_min.flat<float>()(0);
    const float input_max_float = input_max.flat<float>()(0);
    const float requested_output_min_float =
        requested_output_min.flat<float>()(0);
    const float requested_output_max_float =
        requested_output_max.flat<float>()(0);

    Tensor* output = nullptr;
    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));
    Tensor* output_min = nullptr;
    OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));
    Tensor* output_max = nullptr;
    OP_REQUIRES_OK(ctx, ctx->allocate_output(2, TensorShape({}), &output_max));

    OP_REQUIRES(
        ctx, requested_output_min_float <= 0.0f,
        errors::InvalidArgument(""requested_output_min must be <= 0, but got "",
                                requested_output_min_float));
    OP_REQUIRES(
        ctx, requested_output_max_float >= requested_output_min_float,
        errors::InvalidArgument(
            ""requested_output_max must be >= requested_output_min, but got "",
            requested_output_max_float, "" and "", requested_output_min_float));

    auto input_array = input.flat<T1>();

#if 0
    // This is the reference, non-eigen implementation:
    auto output_array = output->flat<T2>();
    RequantizeManyInNewRange<T1, T2>(
        input_array.data(), input_array.size(),
        input_min_float, input_max_float,
        requested_output_min_float, requested_output_max_float,
        output_array.data());
#endif

    if (input_array.size() > 0) {
      if (meta::IsSupportedAndEnabled() && std::is_same<T1, qint32>() &&
          std::is_same<T2, quint8>()) {
        auto input_i32_array = input.flat<qint32>();
        meta::Requantize(ctx, input_i32_array.data(), input_i32_array.size(),
                         input_min_float, input_max_float,
                         requested_output_min_float, requested_output_max_float,
                         output->flat<quint8>().data());
      } else {
        RequantizeManyInNewRangeUsingEigen<T1, T2>(
            ctx->eigen_device<CPUDevice>(), input, input_min_float,
            input_max_float, requested_output_min_float,
            requested_output_max_float, output);
      }
    }

    output_min->flat<float>().setConstant(requested_output_min_float);
    output_max->flat<float>().setConstant(requested_output_max_float);
  }","void Compute(OpKernelContext* VAR_0) override {
    const Tensor& VAR_1 = VAR_0->input(0);

    const Tensor& VAR_2 = VAR_0->input(1);
    const Tensor& VAR_3 = VAR_0->input(2);
    const Tensor& VAR_4 = VAR_0->input(3);
    const Tensor& VAR_5 = VAR_0->input(4);
    OP_REQUIRES(
        VAR_0, TensorShapeUtils::IsScalar(VAR_2.shape()),
        errors::InvalidArgument(""`input_min` must be rank 0 but is rank "",
                                VAR_2.dims()));
    OP_REQUIRES(
        VAR_0, TensorShapeUtils::IsScalar(VAR_3.shape()),
        errors::InvalidArgument(""`input_max` must be rank 0 but is rank "",
                                VAR_3.dims()));
    OP_REQUIRES(VAR_0, TensorShapeUtils::IsScalar(VAR_4.shape()),
                errors::InvalidArgument(
                    ""`requested_output_min` must be rank 0 but is rank "",
                    VAR_4.dims()));
    OP_REQUIRES(VAR_0, TensorShapeUtils::IsScalar(VAR_5.shape()),
                errors::InvalidArgument(
                    ""`requested_output_max` must be rank 0 but is rank "",
                    VAR_5.dims()));

    const float VAR_6 = VAR_2.flat<float>()(0);
    const float VAR_7 = VAR_3.flat<float>()(0);
    const float VAR_8 =
        VAR_4.flat<float>()(0);
    const float VAR_9 =
        VAR_5.flat<float>()(0);

    Tensor* VAR_10 = nullptr;
    OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(0, VAR_1.shape(), &VAR_10));
    Tensor* VAR_11 = nullptr;
    OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(1, TensorShape({}), &VAR_11));
    Tensor* VAR_12 = nullptr;
    OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(2, TensorShape({}), &VAR_12));

    OP_REQUIRES(
        VAR_0, VAR_8 <= 0.0f,
        errors::InvalidArgument(""requested_output_min must be <= 0, but got "",
                                VAR_8));
    OP_REQUIRES(
        VAR_0, VAR_9 >= VAR_8,
        errors::InvalidArgument(
            ""requested_output_max must be >= requested_output_min, but got "",
            VAR_9, "" and "", VAR_8));

    auto VAR_13 = VAR_1.flat<T1>();

#if 0
    /* COMMENT_0 */
    auto VAR_14 = VAR_10->flat<T2>();
    VAR_15<T1, T2>(
        VAR_13.data(), VAR_13.size(),
        VAR_6, VAR_7,
        VAR_8, VAR_9,
        VAR_14.data());
#endif

    if (VAR_13.size() > 0) {
      if (meta::IsSupportedAndEnabled() && std::VAR_16<T1, qint32>() &&
          std::VAR_16<T2, quint8>()) {
        auto VAR_17 = VAR_1.flat<qint32>();
        meta::Requantize(VAR_0, VAR_17.data(), VAR_17.size(),
                         VAR_6, VAR_7,
                         VAR_8, VAR_9,
                         VAR_10->flat<quint8>().data());
      } else {
        VAR_18<T1, T2>(
            VAR_0->eigen_device<CPUDevice>(), VAR_1, VAR_6,
            VAR_7, VAR_8,
            VAR_9, VAR_10);
      }
    }

    VAR_11->flat<float>().setConstant(VAR_8);
    VAR_12->flat<float>().setConstant(VAR_9);
  }",,"--- func_before
+++ func_after
@@ -1,9 +1,33 @@
 void Compute(OpKernelContext* ctx) override {
     const Tensor& input = ctx->input(0);
-    const float input_min_float = ctx->input(1).flat<float>()(0);
-    const float input_max_float = ctx->input(2).flat<float>()(0);
-    const float requested_output_min_float = ctx->input(3).flat<float>()(0);
-    const float requested_output_max_float = ctx->input(4).flat<float>()(0);
+
+    const Tensor& input_min = ctx->input(1);
+    const Tensor& input_max = ctx->input(2);
+    const Tensor& requested_output_min = ctx->input(3);
+    const Tensor& requested_output_max = ctx->input(4);
+    OP_REQUIRES(
+        ctx, TensorShapeUtils::IsScalar(input_min.shape()),
+        errors::InvalidArgument(""`input_min` must be rank 0 but is rank "",
+                                input_min.dims()));
+    OP_REQUIRES(
+        ctx, TensorShapeUtils::IsScalar(input_max.shape()),
+        errors::InvalidArgument(""`input_max` must be rank 0 but is rank "",
+                                input_max.dims()));
+    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(requested_output_min.shape()),
+                errors::InvalidArgument(
+                    ""`requested_output_min` must be rank 0 but is rank "",
+                    requested_output_min.dims()));
+    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(requested_output_max.shape()),
+                errors::InvalidArgument(
+                    ""`requested_output_max` must be rank 0 but is rank "",
+                    requested_output_max.dims()));
+
+    const float input_min_float = input_min.flat<float>()(0);
+    const float input_max_float = input_max.flat<float>()(0);
+    const float requested_output_min_float =
+        requested_output_min.flat<float>()(0);
+    const float requested_output_max_float =
+        requested_output_max.flat<float>()(0);
 
     Tensor* output = nullptr;
     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));","{'deleted_lines': ['    const float input_min_float = ctx->input(1).flat<float>()(0);', '    const float input_max_float = ctx->input(2).flat<float>()(0);', '    const float requested_output_min_float = ctx->input(3).flat<float>()(0);', '    const float requested_output_max_float = ctx->input(4).flat<float>()(0);'], 'added_lines': ['', '    const Tensor& input_min = ctx->input(1);', '    const Tensor& input_max = ctx->input(2);', '    const Tensor& requested_output_min = ctx->input(3);', '    const Tensor& requested_output_max = ctx->input(4);', '    OP_REQUIRES(', '        ctx, TensorShapeUtils::IsScalar(input_min.shape()),', '        errors::InvalidArgument(""`input_min` must be rank 0 but is rank "",', '                                input_min.dims()));', '    OP_REQUIRES(', '        ctx, TensorShapeUtils::IsScalar(input_max.shape()),', '        errors::InvalidArgument(""`input_max` must be rank 0 but is rank "",', '                                input_max.dims()));', '    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(requested_output_min.shape()),', '                errors::InvalidArgument(', '                    ""`requested_output_min` must be rank 0 but is rank "",', '                    requested_output_min.dims()));', '    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(requested_output_max.shape()),', '                errors::InvalidArgument(', '                    ""`requested_output_max` must be rank 0 but is rank "",', '                    requested_output_max.dims()));', '', '    const float input_min_float = input_min.flat<float>()(0);', '    const float input_max_float = input_max.flat<float>()(0);', '    const float requested_output_min_float =', '        requested_output_min.flat<float>()(0);', '    const float requested_output_max_float =', '        requested_output_max.flat<float>()(0);']}",True,"TensorFlow is an open source platform for machine learning. If `QuantizedInstanceNorm` is given `x_min` or `x_max` tensors of a nonzero rank, it results in a segfault that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit 785d67a78a1d533759fcd2f5e8d6ef778de849e0. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.",5.9,MEDIUM,1,test,2022-07-19T05:40:58Z,4
CVE-2022-35970,"['CWE-617', 'CWE-20']",CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,tensorflow,"Fix quantize ops input validation issues.

The majority of these are just missing checks on min/max.

PiperOrigin-RevId: 461800665",785d67a78a1d533759fcd2f5e8d6ef778de849e0,https://github.com/tensorflow/tensorflow/commit/785d67a78a1d533759fcd2f5e8d6ef778de849e0,tensorflow/core/kernels/quantized_instance_norm.cc,Compute,"void Compute(OpKernelContext* context) override {
const Tensor& input = context->input(0);
float input_min = context->input(1).flat<float>()(0);
float input_max = context->input(2).flat<float>()(0);
float input_scale = (input_max - input_min) / 255.0f;
OP_REQUIRES(context, input_min < input_max,
errors::InvalidArgument(
""input_min must be less than input_max : "", input_min,
"" >= "", input_max));
auto input_tensor = input.tensor<quint8, 4>();
auto N = input_tensor.dimension(0);
auto H = input_tensor.dimension(1);
auto W = input_tensor.dimension(2);
auto C = input_tensor.dimension(3);
Tensor* output = nullptr;
OP_REQUIRES_OK(context,
context->allocate_output(0, input.shape(), &output));
Tensor* output_min = nullptr;
OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));
Tensor* output_max = nullptr;
OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));
typedef TTypes<float>::Tensor::Index Index;
const Eigen::IndexList<Eigen::type2index<1>, Eigen::type2index<2>>
reduction_indices;
Eigen::IndexList<Eigen::type2index<1>, Index, Index, Eigen::type2index<1>>
broadcast_spec;
broadcast_spec.set(1, H);
broadcast_spec.set(2, W);
Eigen::IndexList<Index, Eigen::type2index<1>, Eigen::type2index<1>, Index>
expand_spec;
expand_spec.set(0, N);
expand_spec.set(3, C);
Eigen::Tensor<float, 2, Eigen::RowMajor> float_mean(N, C);
Eigen::Tensor<float, 2, Eigen::RowMajor> float_variance(N, C);
#ifdef USE_NEON
if (N == 1 && (C % 16 == 0)) {
VLOG(2) << ""Calling optimized"";
ColMeanAndVariance(reinterpret_cast<const uint8_t*>(input_tensor.data()),
H * W, C, float_mean.data(), float_variance.data());
float minimum = given_y_min_, maximum = given_y_max_;
if (!output_range_given_) {
MinAndMax(reinterpret_cast<const uint8_t*>(input_tensor.data()), H * W,
C, float_mean.data(), float_variance.data(),
variance_epsilon_, &minimum, &maximum);
}
if (maximum - minimum < min_separation_) {
maximum = minimum + min_separation_;
}
InstanceNorm(reinterpret_cast<const uint8_t*>(input_tensor.data()), H * W,
C, float_mean.data(), float_variance.data(),
variance_epsilon_, minimum, maximum,
reinterpret_cast<uint8_t*>(output->flat<quint8>().data()));
output_min->scalar<float>()() = minimum;
output_max->scalar<float>()() = maximum;
} else  #endif
{
VLOG(2) << ""Calling unoptimized"";
float_mean = input_tensor.cast<float>().reduce(
reduction_indices, Eigen::internal::MeanReducer<float>());
float_variance =
(input_scale *
((input_tensor.cast<float>() -
float_mean.reshape(expand_spec).broadcast(broadcast_spec))))
.square()
.reduce(reduction_indices, Eigen::internal::MeanReducer<float>());
Eigen::Tensor<float, 4, Eigen::RowMajor> instance_normed =
input_scale *
(input_tensor.cast<float>() -
float_mean.reshape(expand_spec).broadcast(broadcast_spec)) *
(float_variance + variance_epsilon_)
.rsqrt()
.reshape(expand_spec)
.broadcast(broadcast_spec);
Eigen::Tensor<float, 0, Eigen::RowMajor> normed_min;
Eigen::Tensor<float, 0, Eigen::RowMajor> normed_max;
if (!output_range_given_) {
normed_min = instance_normed.minimum();
normed_max = instance_normed.maximum();
} else {
normed_min() = given_y_min_;
normed_max() = given_y_max_;
}
if (normed_max() - normed_min() < min_separation_) {
normed_max() = normed_min() + min_separation_;
}
FloatToQuantizedStruct<quint8> output_f2q(normed_min(), normed_max());
auto instance_normed_quantized =
QUANTIZE_WITH_EIGEN(instance_normed, output_f2q, quint8);
output->tensor<quint8, 4>().device(
context->template eigen_device<CPUDevice>()) =
instance_normed_quantized;
output_min->flat<float>()(0) = normed_min();
output_max->flat<float>()(0) = normed_max();
}
}","void Compute(OpKernelContext* VAR_0) override {
const Tensor& VAR_1 = VAR_0->input(0);
float VAR_2 = VAR_0->input(1).flat<float>()(0);
float VAR_3 = VAR_0->input(2).flat<float>()(0);
float VAR_4 = (VAR_3 - VAR_2) / 255.0f;
OP_REQUIRES(VAR_0, VAR_2 < VAR_3,
errors::InvalidArgument(
""input_min must be less than input_max : "", VAR_2,
"" >= "", VAR_3));
auto VAR_5 = VAR_1.tensor<quint8, 4>();
auto VAR_6 = VAR_5.dimension(0);
auto VAR_7 = VAR_5.dimension(1);
auto VAR_8 = VAR_5.dimension(2);
auto VAR_9 = VAR_5.dimension(3);
Tensor* VAR_10 = nullptr;
OP_REQUIRES_OK(VAR_0,
VAR_0->allocate_output(0, VAR_1.shape(), &VAR_10));
Tensor* VAR_11 = nullptr;
OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(1, {}, &VAR_11));
Tensor* VAR_12 = nullptr;
OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(2, {}, &VAR_12));
typedef TTypes<float>::Tensor::Index Index;
const Eigen::IndexList<Eigen::type2index<1>, Eigen::type2index<2>>
VAR_13;
Eigen::IndexList<Eigen::type2index<1>, Index, Index, Eigen::type2index<1>>
VAR_14;
VAR_14.set(1, VAR_7);
VAR_14.set(2, VAR_8);
Eigen::IndexList<Index, Eigen::type2index<1>, Eigen::type2index<1>, Index>
VAR_15;
VAR_15.set(0, VAR_6);
VAR_15.set(3, VAR_9);
Eigen::Tensor<float, 2, Eigen::RowMajor> float_mean(N, C);
Eigen::Tensor<float, 2, Eigen::RowMajor> float_variance(N, C);
#ifdef VAR_16
if (N == 1 && (C % 16 == 0)) {
VLOG(2) << ""Calling optimized"";
ColMeanAndVariance(VAR_17<const uint8_t*>(VAR_5.data()),
VAR_7 * VAR_8, C, VAR_18.data(), VAR_19.data());
float VAR_20 = VAR_21, VAR_22 = VAR_23;
if (!VAR_24) {
MinAndMax(VAR_17<const uint8_t*>(VAR_5.data()), VAR_7 * VAR_8,
C, VAR_18.data(), VAR_19.data(),
VAR_25, &VAR_20, &VAR_22);
}
if (VAR_22 - VAR_20 < VAR_26) {
VAR_22 = VAR_20 + VAR_26;
}
InstanceNorm(VAR_17<const uint8_t*>(VAR_5.data()), VAR_7 * VAR_8,
C, VAR_18.data(), VAR_19.data(),
VAR_25, VAR_20, VAR_22,
VAR_17<uint8_t*>(VAR_10->flat<quint8>().data()));
VAR_11->scalar<float>()() = VAR_20;
VAR_12->scalar<float>()() = VAR_22;
} else  
#endif
{
VLOG(2) << ""Calling unoptimized"";
VAR_18 = VAR_5.cast<float>().reduce(
VAR_13, Eigen::internal::VAR_27<float>());
VAR_19 =
(VAR_4 *
((VAR_5.cast<float>() -
VAR_18.reshape(VAR_15).broadcast(VAR_14))))
.square()
.reduce(VAR_13, Eigen::internal::VAR_27<float>());
Eigen::Tensor<float, 4, Eigen::RowMajor> VAR_28 =
VAR_4 *
(VAR_5.cast<float>() -
VAR_18.reshape(VAR_15).broadcast(VAR_14)) *
(VAR_19 + VAR_25)
.rsqrt()
.reshape(VAR_15)
.broadcast(VAR_14);
Eigen::Tensor<float, 0, Eigen::RowMajor> VAR_29;
Eigen::Tensor<float, 0, Eigen::RowMajor> VAR_30;
if (!VAR_24) {
VAR_29 = VAR_28.minimum();
VAR_30 = VAR_28.maximum();
} else {
VAR_29() = VAR_21;
VAR_30() = VAR_23;
}
if (VAR_30() - VAR_29() < VAR_26) {
VAR_30() = VAR_29() + VAR_26;
}
FloatToQuantizedStruct<quint8> output_f2q(normed_min(), normed_max());
auto VAR_31 =
QUANTIZE_WITH_EIGEN(VAR_28, VAR_32, quint8);
VAR_10->tensor<quint8, 4>().device(
VAR_0->template eigen_device<CPUDevice>()) =
VAR_31;
VAR_11->flat<float>()(0) = normed_min();
VAR_12->flat<float>()(0) = normed_max();
}
}",,"void Compute(OpKernelContext* context) override {
    const Tensor& input = context->input(0);

    const Tensor& x_min = context->input(1);
    const Tensor& x_max = context->input(2);
    OP_REQUIRES(context, TensorShapeUtils::IsScalar(x_min.shape()),
                errors::InvalidArgument(""`x_min` must be rank 0 but is rank "",
                                        x_min.dims()));
    OP_REQUIRES(context, TensorShapeUtils::IsScalar(x_max.shape()),
                errors::InvalidArgument(""`x_max` must be rank 0 but is rank "",
                                        x_max.dims()));
    float input_min = x_min.scalar<float>()();
    float input_max = x_max.scalar<float>()();
    float input_scale = (input_max - input_min) / 255.0f;

    OP_REQUIRES(context, input_min < input_max,
                errors::InvalidArgument(
                    ""input_min must be less than input_max : "", input_min,
                    "" >= "", input_max));

    auto input_tensor = input.tensor<quint8, 4>();
    auto N = input_tensor.dimension(0);
    auto H = input_tensor.dimension(1);
    auto W = input_tensor.dimension(2);
    auto C = input_tensor.dimension(3);

    Tensor* output = nullptr;
    OP_REQUIRES_OK(context,
                   context->allocate_output(0, input.shape(), &output));

    Tensor* output_min = nullptr;
    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));
    Tensor* output_max = nullptr;
    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));

    typedef TTypes<float>::Tensor::Index Index;

    const Eigen::IndexList<Eigen::type2index<1>, Eigen::type2index<2>>
        reduction_indices;
    Eigen::IndexList<Eigen::type2index<1>, Index, Index, Eigen::type2index<1>>
        broadcast_spec;
    broadcast_spec.set(1, H);
    broadcast_spec.set(2, W);
    Eigen::IndexList<Index, Eigen::type2index<1>, Eigen::type2index<1>, Index>
        expand_spec;
    expand_spec.set(0, N);
    expand_spec.set(3, C);

    Eigen::Tensor<float, 2, Eigen::RowMajor> float_mean(N, C);
    Eigen::Tensor<float, 2, Eigen::RowMajor> float_variance(N, C);

#ifdef USE_NEON
    if (N == 1 && (C % 16 == 0)) {
      VLOG(2) << ""Calling optimized"";
      ColMeanAndVariance(reinterpret_cast<const uint8_t*>(input_tensor.data()),
                         H * W, C, float_mean.data(), float_variance.data());

      float minimum = given_y_min_, maximum = given_y_max_;
      if (!output_range_given_) {
        MinAndMax(reinterpret_cast<const uint8_t*>(input_tensor.data()), H * W,
                  C, float_mean.data(), float_variance.data(),
                  variance_epsilon_, &minimum, &maximum);
      }

      if (maximum - minimum < min_separation_) {
        maximum = minimum + min_separation_;
      }

      InstanceNorm(reinterpret_cast<const uint8_t*>(input_tensor.data()), H * W,
                   C, float_mean.data(), float_variance.data(),
                   variance_epsilon_, minimum, maximum,
                   reinterpret_cast<uint8_t*>(output->flat<quint8>().data()));
      output_min->scalar<float>()() = minimum;
      output_max->scalar<float>()() = maximum;
    } else  // NOLINT(readability/braces)
#endif
    {
      VLOG(2) << ""Calling unoptimized"";
      float_mean = input_tensor.cast<float>().reduce(
          reduction_indices, Eigen::internal::MeanReducer<float>());

      float_variance =
          (input_scale *
           ((input_tensor.cast<float>() -
             float_mean.reshape(expand_spec).broadcast(broadcast_spec))))
              .square()
              .reduce(reduction_indices, Eigen::internal::MeanReducer<float>());

      Eigen::Tensor<float, 4, Eigen::RowMajor> instance_normed =
          input_scale *
          (input_tensor.cast<float>() -
           float_mean.reshape(expand_spec).broadcast(broadcast_spec)) *
          (float_variance + variance_epsilon_)
              .rsqrt()
              .reshape(expand_spec)
              .broadcast(broadcast_spec);

      Eigen::Tensor<float, 0, Eigen::RowMajor> normed_min;
      Eigen::Tensor<float, 0, Eigen::RowMajor> normed_max;

      if (!output_range_given_) {
        normed_min = instance_normed.minimum();
        normed_max = instance_normed.maximum();
      } else {
        normed_min() = given_y_min_;
        normed_max() = given_y_max_;
      }

      if (normed_max() - normed_min() < min_separation_) {
        normed_max() = normed_min() + min_separation_;
      }

      FloatToQuantizedStruct<quint8> output_f2q(normed_min(), normed_max());
      auto instance_normed_quantized =
          QUANTIZE_WITH_EIGEN(instance_normed, output_f2q, quint8);

      output->tensor<quint8, 4>().device(
          context->template eigen_device<CPUDevice>()) =
          instance_normed_quantized;
      output_min->flat<float>()(0) = normed_min();
      output_max->flat<float>()(0) = normed_max();
    }
  }","void Compute(OpKernelContext* VAR_0) override {
    const Tensor& VAR_1 = VAR_0->input(0);

    const Tensor& VAR_2 = VAR_0->input(1);
    const Tensor& VAR_3 = VAR_0->input(2);
    OP_REQUIRES(VAR_0, TensorShapeUtils::IsScalar(VAR_2.shape()),
                errors::InvalidArgument(""`x_min` must be rank 0 but is rank "",
                                        VAR_2.dims()));
    OP_REQUIRES(VAR_0, TensorShapeUtils::IsScalar(VAR_3.shape()),
                errors::InvalidArgument(""`x_max` must be rank 0 but is rank "",
                                        VAR_3.dims()));
    float VAR_4 = VAR_2.scalar<float>()();
    float VAR_5 = VAR_3.scalar<float>()();
    float VAR_6 = (VAR_5 - VAR_4) / 255.0f;

    OP_REQUIRES(VAR_0, VAR_4 < VAR_5,
                errors::InvalidArgument(
                    ""input_min must be less than input_max : "", VAR_4,
                    "" >= "", VAR_5));

    auto VAR_7 = VAR_1.tensor<quint8, 4>();
    auto VAR_8 = VAR_7.dimension(0);
    auto VAR_9 = VAR_7.dimension(1);
    auto VAR_10 = VAR_7.dimension(2);
    auto VAR_11 = VAR_7.dimension(3);

    Tensor* VAR_12 = nullptr;
    OP_REQUIRES_OK(VAR_0,
                   VAR_0->allocate_output(0, VAR_1.shape(), &VAR_12));

    Tensor* VAR_13 = nullptr;
    OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(1, {}, &VAR_13));
    Tensor* VAR_14 = nullptr;
    OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(2, {}, &VAR_14));

    typedef TTypes<float>::Tensor::Index Index;

    const Eigen::IndexList<Eigen::type2index<1>, Eigen::type2index<2>>
        VAR_15;
    Eigen::IndexList<Eigen::type2index<1>, Index, Index, Eigen::type2index<1>>
        VAR_16;
    VAR_16.set(1, VAR_9);
    VAR_16.set(2, VAR_10);
    Eigen::IndexList<Index, Eigen::type2index<1>, Eigen::type2index<1>, Index>
        VAR_17;
    VAR_17.set(0, VAR_8);
    VAR_17.set(3, VAR_11);

    Eigen::Tensor<float, 2, Eigen::RowMajor> float_mean(N, C);
    Eigen::Tensor<float, 2, Eigen::RowMajor> float_variance(N, C);

#ifdef VAR_18
    if (N == 1 && (C % 16 == 0)) {
      VLOG(2) << ""Calling optimized"";
      ColMeanAndVariance(VAR_19<const uint8_t*>(VAR_7.data()),
                         VAR_9 * VAR_10, C, VAR_20.data(), VAR_21.data());

      float VAR_22 = VAR_23, VAR_24 = VAR_25;
      if (!VAR_26) {
        MinAndMax(VAR_19<const uint8_t*>(VAR_7.data()), VAR_9 * VAR_10,
                  C, VAR_20.data(), VAR_21.data(),
                  VAR_27, &VAR_22, &VAR_24);
      }

      if (VAR_24 - VAR_22 < VAR_28) {
        VAR_24 = VAR_22 + VAR_28;
      }

      InstanceNorm(VAR_19<const uint8_t*>(VAR_7.data()), VAR_9 * VAR_10,
                   C, VAR_20.data(), VAR_21.data(),
                   VAR_27, VAR_22, VAR_24,
                   VAR_19<uint8_t*>(VAR_12->flat<quint8>().data()));
      VAR_13->scalar<float>()() = VAR_22;
      VAR_14->scalar<float>()() = VAR_24;
    } else  /* COMMENT_0 */
#endif
    {
      VLOG(2) << ""Calling unoptimized"";
      VAR_20 = VAR_7.cast<float>().reduce(
          VAR_15, Eigen::internal::VAR_29<float>());

      VAR_21 =
          (VAR_6 *
           ((VAR_7.cast<float>() -
             VAR_20.reshape(VAR_17).broadcast(VAR_16))))
              .square()
              .reduce(VAR_15, Eigen::internal::VAR_29<float>());

      Eigen::Tensor<float, 4, Eigen::RowMajor> VAR_30 =
          VAR_6 *
          (VAR_7.cast<float>() -
           VAR_20.reshape(VAR_17).broadcast(VAR_16)) *
          (VAR_21 + VAR_27)
              .rsqrt()
              .reshape(VAR_17)
              .broadcast(VAR_16);

      Eigen::Tensor<float, 0, Eigen::RowMajor> VAR_31;
      Eigen::Tensor<float, 0, Eigen::RowMajor> VAR_32;

      if (!VAR_26) {
        VAR_31 = VAR_30.minimum();
        VAR_32 = VAR_30.maximum();
      } else {
        VAR_31() = VAR_23;
        VAR_32() = VAR_25;
      }

      if (VAR_32() - VAR_31() < VAR_28) {
        VAR_32() = VAR_31() + VAR_28;
      }

      FloatToQuantizedStruct<quint8> output_f2q(normed_min(), normed_max());
      auto VAR_33 =
          QUANTIZE_WITH_EIGEN(VAR_30, VAR_34, quint8);

      VAR_12->tensor<quint8, 4>().device(
          VAR_0->template eigen_device<CPUDevice>()) =
          VAR_33;
      VAR_13->flat<float>()(0) = normed_min();
      VAR_14->flat<float>()(0) = normed_max();
    }
  }",,"--- func_before
+++ func_after
@@ -1,8 +1,16 @@
 void Compute(OpKernelContext* context) override {
     const Tensor& input = context->input(0);
 
-    float input_min = context->input(1).flat<float>()(0);
-    float input_max = context->input(2).flat<float>()(0);
+    const Tensor& x_min = context->input(1);
+    const Tensor& x_max = context->input(2);
+    OP_REQUIRES(context, TensorShapeUtils::IsScalar(x_min.shape()),
+                errors::InvalidArgument(""`x_min` must be rank 0 but is rank "",
+                                        x_min.dims()));
+    OP_REQUIRES(context, TensorShapeUtils::IsScalar(x_max.shape()),
+                errors::InvalidArgument(""`x_max` must be rank 0 but is rank "",
+                                        x_max.dims()));
+    float input_min = x_min.scalar<float>()();
+    float input_max = x_max.scalar<float>()();
     float input_scale = (input_max - input_min) / 255.0f;
 
     OP_REQUIRES(context, input_min < input_max,","{'deleted_lines': ['    float input_min = context->input(1).flat<float>()(0);', '    float input_max = context->input(2).flat<float>()(0);'], 'added_lines': ['    const Tensor& x_min = context->input(1);', '    const Tensor& x_max = context->input(2);', '    OP_REQUIRES(context, TensorShapeUtils::IsScalar(x_min.shape()),', '                errors::InvalidArgument(""`x_min` must be rank 0 but is rank "",', '                                        x_min.dims()));', '    OP_REQUIRES(context, TensorShapeUtils::IsScalar(x_max.shape()),', '                errors::InvalidArgument(""`x_max` must be rank 0 but is rank "",', '                                        x_max.dims()));', '    float input_min = x_min.scalar<float>()();', '    float input_max = x_max.scalar<float>()();']}",True,"TensorFlow is an open source platform for machine learning. If `QuantizedInstanceNorm` is given `x_min` or `x_max` tensors of a nonzero rank, it results in a segfault that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit 785d67a78a1d533759fcd2f5e8d6ef778de849e0. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.",5.9,MEDIUM,1,test,2022-07-19T05:40:58Z,4
CVE-2022-33745,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H,1,xen-project/xen,"x86/mm: correct TLB flush condition in _get_page_type()

When this logic was moved, it was moved across the point where nx is
updated to hold the new type for the page. IOW originally it was
equivalent to using x (and perhaps x would better have been used), but
now it isn't anymore. Switch to using x, which then brings things in
line again with the slightly earlier comment there (now) talking about
transitions _from_ writable.

I have to confess though that I cannot make a direct connection between
the reported observed behavior of guests leaving several pages around
with pending general references and the change here. Repeated testing,
nevertheless, confirms the reported issue is no longer there.

This is CVE-2022-33745 / XSA-408.

Reported-by: Charles Arnold <carnold@suse.com>
Fixes: 8cc5036bc385 (""x86/pv: Fix ABAC cmpxchg() race in _get_page_type()"")
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>",a9949efb288fd6e21bbaf9d5826207c7c41cda27,https://github.com/xen-project/xen/commit/a9949efb288fd6e21bbaf9d5826207c7c41cda27,xen/arch/x86/mm.c,_get_page_type,"static int _get_page_type(struct page_info *page, unsigned long type,
bool preemptible)
{
unsigned long nx, x;
int rc = 0;
ASSERT(!(type & ~(PGT_type_mask | PGT_pae_xen_l2)));
ASSERT(!in_irq());
for ( unsigned long y = ACCESS_ONCE(page->u.inuse.type_info); ; )
{
x  = y;
nx = x + 1;
if ( unlikely((nx & PGT_count_mask) == 0) )
{
gdprintk(XENLOG_WARNING,
""Type count overflow on mfn %""PRI_mfn""\n"",
mfn_x(page_to_mfn(page)));
return -EINVAL;
}
if ( unlikely((x & PGT_count_mask) == 0) )
{
ASSERT(!(x & PGT_pae_xen_l2));
if ( (x & PGT_type_mask) != type )
{
nx &= ~(PGT_type_mask | PGT_validated);
nx |= type;
}
}
else if ( unlikely((x & (PGT_type_mask|PGT_pae_xen_l2)) != type) )
{
if ( ((x & PGT_type_mask) == PGT_l2_page_table) &&
(type == PGT_l1_page_table) )
return -EINVAL;
if ( ((x & PGT_type_mask) == PGT_l3_page_table) &&
(type == PGT_l2_page_table) )
return -EINVAL;
if ( ((x & PGT_type_mask) == PGT_l4_page_table) &&
(type == PGT_l3_page_table) )
return -EINVAL;
gdprintk(XENLOG_WARNING,
""Bad type (saw %"" PRtype_info "" != exp %"" PRtype_info "") ""
""for mfn %"" PRI_mfn "" (pfn %"" PRI_pfn "")\n"",
x, type, mfn_x(page_to_mfn(page)),
get_gpfn_from_mfn(mfn_x(page_to_mfn(page))));
return -EINVAL;
}
else if ( unlikely(!(x & PGT_validated)) )
{
ASSERT((x & (PGT_type_mask | PGT_pae_xen_l2 | PGT_count_mask)) ==
(type | 1));
if ( !(x & PGT_partial) )
{
do {
if ( preemptible && hypercall_preempt_check() )
return -EINTR;
cpu_relax();
} while ( (y = ACCESS_ONCE(page->u.inuse.type_info)) == x );
continue;
}
nx = x & ~PGT_partial;
}
if ( likely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) == x) )
break;
if ( preemptible && hypercall_preempt_check() )
return -EINTR;
}
if ( likely(nx & PGT_validated) )
return 0;
if ( unlikely((x & PGT_count_mask) == 0) )
{
struct domain *d = page_get_owner(page);
if ( d && shadow_mode_enabled(d) )
shadow_prepare_page_type_change(d, page, type);
if ( (x & PGT_type_mask) != type )
{
cpumask_t *mask = this_cpu(scratch_cpumask);
BUG_ON(in_irq());
cpumask_copy(mask, d->dirty_cpumask);
tlbflush_filter(mask, page->tlbflush_timestamp);
if ( unlikely(!cpumask_empty(mask)) &&
(!shadow_mode_enabled(d) ||
((nx & PGT_type_mask) == PGT_writable_page)) )
{
perfc_incr(need_flush_tlb_flush);
flush_mask(mask,
(x & PGT_type_mask) &&
(x & PGT_type_mask) <= PGT_root_page_table
? FLUSH_TLB | FLUSH_NO_ASSIST
: FLUSH_TLB);
}
}
}
if ( unlikely(((x & PGT_type_mask) == PGT_writable_page) !=
(type == PGT_writable_page)) )
{
struct domain *d = page_get_owner(page);
if ( d && unlikely(need_iommu_pt_sync(d)) && is_pv_domain(d) )
{
mfn_t mfn = page_to_mfn(page);
if ( (x & PGT_type_mask) == PGT_writable_page )
rc = iommu_legacy_unmap(d, _dfn(mfn_x(mfn)),
1ul << PAGE_ORDER_4K);
else
rc = iommu_legacy_map(d, _dfn(mfn_x(mfn)), mfn,
1ul << PAGE_ORDER_4K,
IOMMUF_readable | IOMMUF_writable);
if ( unlikely(rc) )
{
_put_page_type(page, 0, NULL);
goto out;
}
}
}
if ( (nx & PGT_non_coherent) && type != PGT_writable_page )
{
void *addr = __map_domain_page(page);
cache_flush(addr, PAGE_SIZE);
unmap_domain_page(addr);
page->u.inuse.type_info &= ~PGT_non_coherent;
}
if ( type == PGT_writable_page || type == PGT_shared_page )
page->u.inuse.type_info |= PGT_validated;
else
{
if ( !(x & PGT_partial) )
{
page->nr_validated_ptes = 0;
page->partial_flags = 0;
page->linear_pt_count = 0;
}
rc = validate_page(page, type, preemptible);
}
out:
if ( (x & PGT_partial) && !(nx & PGT_partial) )
put_page(page);
return rc;
}","static int _get_page_type(struct page_info *VAR_0, unsigned long VAR_1,
bool VAR_2)
{
unsigned long VAR_3, VAR_4;
int VAR_5 = 0;
ASSERT(!(VAR_1 & ~(VAR_6 | VAR_7)));
ASSERT(!in_irq());
for ( unsigned long VAR_8 = ACCESS_ONCE(VAR_0->u.inuse.type_info); ; )
{
VAR_4  = VAR_8;
VAR_3 = VAR_4 + 1;
if ( unlikely((VAR_3 & VAR_9) == 0) )
{
gdprintk(VAR_10,
""Type count overflow on mfn %""VAR_11""\n"",
mfn_x(page_to_mfn(VAR_0)));
return -VAR_12;
}
if ( unlikely((VAR_4 & VAR_9) == 0) )
{
ASSERT(!(VAR_4 & VAR_7));
if ( (VAR_4 & VAR_6) != VAR_1 )
{
VAR_3 &= ~(VAR_6 | VAR_13);
VAR_3 |= VAR_1;
}
}
else if ( unlikely((VAR_4 & (VAR_6|VAR_7)) != VAR_1) )
{
if ( ((VAR_4 & VAR_6) == VAR_14) &&
(VAR_1 == VAR_15) )
return -VAR_12;
if ( ((VAR_4 & VAR_6) == VAR_16) &&
(VAR_1 == VAR_14) )
return -VAR_12;
if ( ((VAR_4 & VAR_6) == VAR_17) &&
(VAR_1 == VAR_16) )
return -VAR_12;
gdprintk(VAR_10,
""Bad type (saw %"" VAR_18 "" != exp %"" VAR_18 "") ""
""for mfn %"" VAR_11 "" (pfn %"" VAR_19 "")\n"",
VAR_4, VAR_1, mfn_x(page_to_mfn(VAR_0)),
get_gpfn_from_mfn(mfn_x(page_to_mfn(VAR_0))));
return -VAR_12;
}
else if ( unlikely(!(VAR_4 & VAR_13)) )
{
ASSERT((VAR_4 & (VAR_6 | VAR_7 | VAR_9)) ==
(VAR_1 | 1));
if ( !(VAR_4 & VAR_20) )
{
do {
if ( VAR_2 && hypercall_preempt_check() )
return -VAR_21;
cpu_relax();
} while ( (VAR_8 = ACCESS_ONCE(VAR_0->u.inuse.type_info)) == VAR_4 );
continue;
}
VAR_3 = VAR_4 & ~VAR_20;
}
if ( likely((VAR_8 = cmpxchg(&VAR_0->u.inuse.type_info, VAR_4, VAR_3)) == VAR_4) )
break;
if ( VAR_2 && hypercall_preempt_check() )
return -VAR_21;
}
if ( likely(VAR_3 & VAR_13) )
return 0;
if ( unlikely((VAR_4 & VAR_9) == 0) )
{
struct domain *VAR_22 = page_get_owner(VAR_0);
if ( VAR_22 && shadow_mode_enabled(VAR_22) )
shadow_prepare_page_type_change(VAR_22, VAR_0, VAR_1);
if ( (VAR_4 & VAR_6) != VAR_1 )
{
cpumask_t *VAR_23 = this_cpu(VAR_24);
BUG_ON(in_irq());
cpumask_copy(VAR_23, VAR_22->dirty_cpumask);
tlbflush_filter(VAR_23, VAR_0->tlbflush_timestamp);
if ( unlikely(!cpumask_empty(VAR_23)) &&
(!shadow_mode_enabled(VAR_22) ||
((VAR_3 & VAR_6) == VAR_25)) )
{
perfc_incr(VAR_26);
flush_mask(VAR_23,
(VAR_4 & VAR_6) &&
(VAR_4 & VAR_6) <= VAR_27
? VAR_28 | VAR_29
: VAR_28);
}
}
}
if ( unlikely(((VAR_4 & VAR_6) == VAR_25) !=
(VAR_1 == VAR_25)) )
{
struct domain *VAR_22 = page_get_owner(VAR_0);
if ( VAR_22 && unlikely(need_iommu_pt_sync(VAR_22)) && is_pv_domain(VAR_22) )
{
mfn_t VAR_30 = page_to_mfn(VAR_0);
if ( (VAR_4 & VAR_6) == VAR_25 )
VAR_5 = iommu_legacy_unmap(VAR_22, _dfn(mfn_x(VAR_30)),
1ul << VAR_31);
else
VAR_5 = iommu_legacy_map(VAR_22, _dfn(mfn_x(VAR_30)), VAR_30,
1ul << VAR_31,
VAR_32 | VAR_33);
if ( unlikely(VAR_5) )
{
_put_page_type(VAR_0, 0, NULL);
goto out;
}
}
}
if ( (VAR_3 & VAR_34) && VAR_1 != VAR_25 )
{
void *VAR_35 = __map_domain_page(VAR_0);
cache_flush(VAR_35, VAR_36);
unmap_domain_page(VAR_35);
VAR_0->u.inuse.type_info &= ~VAR_34;
}
if ( VAR_1 == VAR_25 || VAR_1 == VAR_37 )
VAR_0->u.inuse.type_info |= VAR_13;
else
{
if ( !(VAR_4 & VAR_20) )
{
VAR_0->nr_validated_ptes = 0;
VAR_0->partial_flags = 0;
VAR_0->linear_pt_count = 0;
}
VAR_5 = validate_page(VAR_0, VAR_1, VAR_2);
}
out:
if ( (VAR_4 & VAR_20) && !(VAR_3 & VAR_20) )
put_page(VAR_0);
return VAR_5;
}",xen-project/xen/a9949efb288fd6e21bbaf9d5826207c7c41cda27/mm.c/vul/before/0.json,"static int _get_page_type(struct page_info *page, unsigned long type,
                          bool preemptible)
{
    unsigned long nx, x;
    int rc = 0;

    ASSERT(!(type & ~(PGT_type_mask | PGT_pae_xen_l2)));
    ASSERT(!in_irq());

    for ( unsigned long y = ACCESS_ONCE(page->u.inuse.type_info); ; )
    {
        x  = y;
        nx = x + 1;

        if ( unlikely((nx & PGT_count_mask) == 0) )
        {
            gdprintk(XENLOG_WARNING,
                     ""Type count overflow on mfn %""PRI_mfn""\n"",
                     mfn_x(page_to_mfn(page)));
            return -EINVAL;
        }

        if ( unlikely((x & PGT_count_mask) == 0) )
        {
            /*
             * Typeref 0 -> 1.
             *
             * Type changes are permitted when the typeref is 0.  If the type
             * actually changes, the page needs re-validating.
             */

            ASSERT(!(x & PGT_pae_xen_l2));
            if ( (x & PGT_type_mask) != type )
            {
                nx &= ~(PGT_type_mask | PGT_validated);
                nx |= type;
            }
        }
        else if ( unlikely((x & (PGT_type_mask|PGT_pae_xen_l2)) != type) )
        {
            /*
             * else, we're trying to take a new reference, of the wrong type.
             *
             * This (being able to prohibit use of the wrong type) is what the
             * typeref system exists for, but skip printing the failure if it
             * looks like a recursive mapping, as subsequent logic might
             * ultimately permit the attempt.
             */
            if ( ((x & PGT_type_mask) == PGT_l2_page_table) &&
                 (type == PGT_l1_page_table) )
                return -EINVAL;
            if ( ((x & PGT_type_mask) == PGT_l3_page_table) &&
                 (type == PGT_l2_page_table) )
                return -EINVAL;
            if ( ((x & PGT_type_mask) == PGT_l4_page_table) &&
                 (type == PGT_l3_page_table) )
                return -EINVAL;
            gdprintk(XENLOG_WARNING,
                     ""Bad type (saw %"" PRtype_info "" != exp %"" PRtype_info "") ""
                     ""for mfn %"" PRI_mfn "" (pfn %"" PRI_pfn "")\n"",
                     x, type, mfn_x(page_to_mfn(page)),
                     get_gpfn_from_mfn(mfn_x(page_to_mfn(page))));
            return -EINVAL;
        }
        else if ( unlikely(!(x & PGT_validated)) )
        {
            /*
             * else, the count is non-zero, and we're grabbing the right type;
             * but the page hasn't been validated yet.
             *
             * The page is in one of two states (depending on PGT_partial),
             * and should have exactly one reference.
             */
            ASSERT((x & (PGT_type_mask | PGT_pae_xen_l2 | PGT_count_mask)) ==
                   (type | 1));

            if ( !(x & PGT_partial) )
            {
                /*
                 * The page has been left in the ""validate locked"" state
                 * (i.e. PGT_[type] | 1) which means that a concurrent caller
                 * of _get_page_type() is in the middle of validation.
                 *
                 * Spin waiting for the concurrent user to complete (partial
                 * or fully validated), then restart our attempt to acquire a
                 * type reference.
                 */
                do {
                    if ( preemptible && hypercall_preempt_check() )
                        return -EINTR;
                    cpu_relax();
                } while ( (y = ACCESS_ONCE(page->u.inuse.type_info)) == x );
                continue;
            }

            /*
             * The page has been left in the ""partial"" state
             * (i.e., PGT_[type] | PGT_partial | 1).
             *
             * Rather than bumping the type count, we need to try to grab the
             * validation lock; if we succeed, we need to validate the page,
             * then drop the general ref associated with the PGT_partial bit.
             *
             * We grab the validation lock by setting nx to (PGT_[type] | 1)
             * (i.e., non-zero type count, neither PGT_validated nor
             * PGT_partial set).
             */
            nx = x & ~PGT_partial;
        }

        if ( likely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) == x) )
            break;

        if ( preemptible && hypercall_preempt_check() )
            return -EINTR;
    }

    /*
     * One typeref has been taken and is now globally visible.
     *
     * The page is either in the ""validate locked"" state (PGT_[type] | 1) or
     * fully validated (PGT_[type] | PGT_validated | >0).
     */

    /* If the page is fully validated, we're done. */
    if ( likely(nx & PGT_validated) )
        return 0;

    /*
     * The page is in the ""validate locked"" state.  We have exclusive access,
     * and any concurrent callers are waiting in the cmpxchg() loop above.
     *
     * Exclusive access ends when PGT_validated or PGT_partial get set.
     */

    if ( unlikely((x & PGT_count_mask) == 0) )
    {
        struct domain *d = page_get_owner(page);

        if ( d && shadow_mode_enabled(d) )
            shadow_prepare_page_type_change(d, page, type);

        if ( (x & PGT_type_mask) != type )
        {
            /*
             * On type change we check to flush stale TLB entries. It is
             * vital that no other CPUs are left with writeable mappings
             * to a frame which is intending to become pgtable/segdesc.
             */
            cpumask_t *mask = this_cpu(scratch_cpumask);

            BUG_ON(in_irq());
            cpumask_copy(mask, d->dirty_cpumask);

            /* Don't flush if the timestamp is old enough */
            tlbflush_filter(mask, page->tlbflush_timestamp);

            if ( unlikely(!cpumask_empty(mask)) &&
                 /* Shadow mode: track only writable pages. */
                 (!shadow_mode_enabled(d) ||
                  ((x & PGT_type_mask) == PGT_writable_page)) )
            {
                perfc_incr(need_flush_tlb_flush);
                /*
                 * If page was a page table make sure the flush is
                 * performed using an IPI in order to avoid changing the
                 * type of a page table page under the feet of
                 * spurious_page_fault().
                 */
                flush_mask(mask,
                           (x & PGT_type_mask) &&
                           (x & PGT_type_mask) <= PGT_root_page_table
                           ? FLUSH_TLB | FLUSH_NO_ASSIST
                           : FLUSH_TLB);
            }
        }
    }

    if ( unlikely(((x & PGT_type_mask) == PGT_writable_page) !=
                  (type == PGT_writable_page)) )
    {
        /* Special pages should not be accessible from devices. */
        struct domain *d = page_get_owner(page);

        if ( d && unlikely(need_iommu_pt_sync(d)) && is_pv_domain(d) )
        {
            mfn_t mfn = page_to_mfn(page);

            if ( (x & PGT_type_mask) == PGT_writable_page )
                rc = iommu_legacy_unmap(d, _dfn(mfn_x(mfn)),
                                        1ul << PAGE_ORDER_4K);
            else
                rc = iommu_legacy_map(d, _dfn(mfn_x(mfn)), mfn,
                                      1ul << PAGE_ORDER_4K,
                                      IOMMUF_readable | IOMMUF_writable);

            if ( unlikely(rc) )
            {
                _put_page_type(page, 0, NULL);
                goto out;
            }
        }
    }

    /*
     * Flush the cache if there were previously non-coherent mappings of
     * this page, and we're trying to use it as anything other than a
     * writeable page.  This forces the page to be coherent before we
     * validate its contents for safety.
     */
    if ( (nx & PGT_non_coherent) && type != PGT_writable_page )
    {
        void *addr = __map_domain_page(page);

        cache_flush(addr, PAGE_SIZE);
        unmap_domain_page(addr);

        page->u.inuse.type_info &= ~PGT_non_coherent;
    }

    /*
     * No special validation needed for writable or shared pages.  Page
     * tables and GDT/LDT need to have their contents audited.
     *
     * per validate_page(), non-atomic updates are fine here.
     */
    if ( type == PGT_writable_page || type == PGT_shared_page )
        page->u.inuse.type_info |= PGT_validated;
    else
    {
        if ( !(x & PGT_partial) )
        {
            page->nr_validated_ptes = 0;
            page->partial_flags = 0;
            page->linear_pt_count = 0;
        }

        rc = validate_page(page, type, preemptible);
    }

 out:
    /*
     * Did we drop the PGT_partial bit when acquiring the typeref?  If so,
     * drop the general reference that went along with it.
     *
     * N.B. validate_page() may have have re-set PGT_partial, not reflected in
     * nx, but will have taken an extra ref when doing so.
     */
    if ( (x & PGT_partial) && !(nx & PGT_partial) )
        put_page(page);

    return rc;
}","static int _get_page_type(struct page_info *VAR_0, unsigned long VAR_1,
                          bool VAR_2)
{
    unsigned long VAR_3, VAR_4;
    int VAR_5 = 0;

    ASSERT(!(VAR_1 & ~(VAR_6 | VAR_7)));
    ASSERT(!in_irq());

    for ( unsigned long VAR_8 = ACCESS_ONCE(VAR_0->u.inuse.type_info); ; )
    {
        VAR_4  = VAR_8;
        VAR_3 = VAR_4 + 1;

        if ( unlikely((VAR_3 & VAR_9) == 0) )
        {
            gdprintk(VAR_10,
                     ""Type count overflow on mfn %""VAR_11""\n"",
                     mfn_x(page_to_mfn(VAR_0)));
            return -VAR_12;
        }

        if ( unlikely((VAR_4 & VAR_9) == 0) )
        {
            /* COMMENT_0 */
                              
              
                                                                             
                                                              
               

            ASSERT(!(VAR_4 & VAR_7));
            if ( (VAR_4 & VAR_6) != VAR_1 )
            {
                VAR_3 &= ~(VAR_6 | VAR_13);
                VAR_3 |= VAR_1;
            }
        }
        else if ( unlikely((VAR_4 & (VAR_6|VAR_7)) != VAR_1) )
        {
            /* COMMENT_6 */
                                                                             
              
                                                                              
                                                                             
                                                                        
                                             
               
            if ( ((VAR_4 & VAR_6) == VAR_14) &&
                 (VAR_1 == VAR_15) )
                return -VAR_12;
            if ( ((VAR_4 & VAR_6) == VAR_16) &&
                 (VAR_1 == VAR_14) )
                return -VAR_12;
            if ( ((VAR_4 & VAR_6) == VAR_17) &&
                 (VAR_1 == VAR_16) )
                return -VAR_12;
            gdprintk(VAR_10,
                     ""Bad type (saw %"" VAR_18 "" != exp %"" VAR_18 "") ""
                     ""for mfn %"" VAR_11 "" (pfn %"" VAR_19 "")\n"",
                     VAR_4, VAR_1, mfn_x(page_to_mfn(VAR_0)),
                     get_gpfn_from_mfn(mfn_x(page_to_mfn(VAR_0))));
            return -VAR_12;
        }
        else if ( unlikely(!(VAR_4 & VAR_13)) )
        {
            /* COMMENT_14 */
                                                                              
                                                      
              
                                                                           
                                                     
               
            ASSERT((VAR_4 & (VAR_6 | VAR_7 | VAR_9)) ==
                   (VAR_1 | 1));

            if ( !(VAR_4 & VAR_20) )
            {
                /* COMMENT_21 */
                                                                        
                                                                             
                                                                      
                  
                                                                            
                                                                             
                                  
                   
                do {
                    if ( VAR_2 && hypercall_preempt_check() )
                        return -VAR_21;
                    cpu_relax();
                } while ( (VAR_8 = ACCESS_ONCE(VAR_0->u.inuse.type_info)) == VAR_4 );
                continue;
            }

            /* COMMENT_30 */
                                                            
                                                    
              
                                                                             
                                                                            
                                                                             
              
                                                                            
                                                                    
                                
               
            VAR_3 = VAR_4 & ~VAR_20;
        }

        if ( likely((VAR_8 = cmpxchg(&VAR_0->u.inuse.type_info, VAR_4, VAR_3)) == VAR_4) )
            break;

        if ( VAR_2 && hypercall_preempt_check() )
            return -VAR_21;
    }

    /* COMMENT_41 */
                                                              
      
                                                                            
                                                         
       

    /* COMMENT_47 */
    if ( likely(VAR_3 & VAR_13) )
        return 0;

    /* COMMENT_48 */
                                                                             
                                                                          
      
                                                                       
       

    if ( unlikely((VAR_4 & VAR_9) == 0) )
    {
        struct domain *VAR_22 = page_get_owner(VAR_0);

        if ( VAR_22 && shadow_mode_enabled(VAR_22) )
            shadow_prepare_page_type_change(VAR_22, VAR_0, VAR_1);

        if ( (VAR_4 & VAR_6) != VAR_1 )
        {
            /* COMMENT_54 */
                                                                        
                                                                        
                                                                       
               
            cpumask_t *VAR_23 = this_cpu(VAR_24);

            BUG_ON(in_irq());
            cpumask_copy(VAR_23, VAR_22->dirty_cpumask);

            /* COMMENT_59 */
            tlbflush_filter(VAR_23, VAR_0->tlbflush_timestamp);

            if ( unlikely(!cpumask_empty(VAR_23)) &&
                 /* COMMENT_60 */
                 (!shadow_mode_enabled(VAR_22) ||
                  ((VAR_4 & VAR_6) == VAR_25)) )
            {
                perfc_incr(VAR_26);
                /* COMMENT_61 */
                                                                  
                                                                        
                                                              
                                         
                   
                flush_mask(VAR_23,
                           (VAR_4 & VAR_6) &&
                           (VAR_4 & VAR_6) <= VAR_27
                           ? VAR_28 | VAR_29
                           : VAR_28);
            }
        }
    }

    if ( unlikely(((VAR_4 & VAR_6) == VAR_25) !=
                  (VAR_1 == VAR_25)) )
    {
        /* COMMENT_67 */
        struct domain *VAR_22 = page_get_owner(VAR_0);

        if ( VAR_22 && unlikely(need_iommu_pt_sync(VAR_22)) && is_pv_domain(VAR_22) )
        {
            mfn_t VAR_30 = page_to_mfn(VAR_0);

            if ( (VAR_4 & VAR_6) == VAR_25 )
                VAR_5 = iommu_legacy_unmap(VAR_22, _dfn(mfn_x(VAR_30)),
                                        1ul << VAR_31);
            else
                VAR_5 = iommu_legacy_map(VAR_22, _dfn(mfn_x(VAR_30)), VAR_30,
                                      1ul << VAR_31,
                                      VAR_32 | VAR_33);

            if ( unlikely(VAR_5) )
            {
                _put_page_type(VAR_0, 0, NULL);
                goto out;
            }
        }
    }

    /* COMMENT_68 */
                                                                        
                                                                     
                                                                     
                                        
       
    if ( (VAR_3 & VAR_34) && VAR_1 != VAR_25 )
    {
        void *VAR_35 = __map_domain_page(VAR_0);

        cache_flush(VAR_35, VAR_36);
        unmap_domain_page(VAR_35);

        VAR_0->u.inuse.type_info &= ~VAR_34;
    }

    /* COMMENT_74 */
                                                                       
                                                              
      
                                                             
       
    if ( VAR_1 == VAR_25 || VAR_1 == VAR_37 )
        VAR_0->u.inuse.type_info |= VAR_13;
    else
    {
        if ( !(VAR_4 & VAR_20) )
        {
            VAR_0->nr_validated_ptes = 0;
            VAR_0->partial_flags = 0;
            VAR_0->linear_pt_count = 0;
        }

        VAR_5 = validate_page(VAR_0, VAR_1, VAR_2);
    }

 out:
    /* COMMENT_80 */
                                                                          
                                                          
      
                                                                              
                                                          
       
    if ( (VAR_4 & VAR_20) && !(VAR_3 & VAR_20) )
        put_page(VAR_0);

    return VAR_5;
}",xen-project/xen/a9949efb288fd6e21bbaf9d5826207c7c41cda27/mm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -158,7 +158,7 @@
             if ( unlikely(!cpumask_empty(mask)) &&
                  /* Shadow mode: track only writable pages. */
                  (!shadow_mode_enabled(d) ||
-                  ((nx & PGT_type_mask) == PGT_writable_page)) )
+                  ((x & PGT_type_mask) == PGT_writable_page)) )
             {
                 perfc_incr(need_flush_tlb_flush);
                 /*","{'deleted_lines': ['                  ((nx & PGT_type_mask) == PGT_writable_page)) )'], 'added_lines': ['                  ((x & PGT_type_mask) == PGT_writable_page)) )']}",True,"insufficient TLB flush for x86 PV guests in shadow mode For migration as well as to work around kernels unaware of L1TF (see XSA-273), PV guests may be run in shadow paging mode. To address XSA-401, code was moved inside a function in Xen. This code movement missed a variable changing meaning / value between old and new code positions. The now wrong use of the variable did lead to a wrong TLB flush condition, omitting flushes where such are necessary.",8.8,HIGH,2,test,2022-07-26T12:54:34Z,4
CVE-2022-27941,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,appneta/tcpreplay,But #716 heap-buffer-overflow in get_l2len_protocol(),a135cea13507b5d2f810d762390ba37d6b93aa3e,https://github.com/appneta/tcpreplay/commit/a135cea13507b5d2f810d762390ba37d6b93aa3e,src/common/get.c,get_l2len_protocol,"int get_l2len_protocol(const u_char *pktdata,
const uint32_t datalen,
const int datalink,
uint16_t *protocol,
uint32_t *l2len,
uint32_t *l2offset,
uint32_t *vlan_offset)
{
assert(protocol);
assert(l2len);
assert(l2offset);
assert(vlan_offset);
if (!pktdata || !datalen) {
errx(-1, ""get_l2len_protocol: invalid L2 parameters: pktdata=0x%p len=%d"",
pktdata,
datalen);
return -1;
}
*protocol = 0;
*l2len = 0;
*l2offset = 0;
*vlan_offset = 0;
switch (datalink) {
case DLT_RAW:
if (datalen == 0)
return -1;
if ((pktdata[0] >> 4) == 4)
*protocol = ETHERTYPE_IP;
else if ((pktdata[0] >> 4) == 6)
*protocol = ETHERTYPE_IP6;
break;
case DLT_JUNIPER_ETHER:
if (datalen < 4)
return -1;
if (memcmp(pktdata, JUNIPER_PCAP_MAGIC, 3)) {
warnx(""No Magic Number found during protocol lookup: %s (0x%x)"",
pcap_datalink_val_to_description(datalink),
datalink);
return -1;
}
if ((pktdata[3] & JUNIPER_FLAG_EXT) == JUNIPER_FLAG_EXT) {
if (datalen < 6)
return -1;
*l2offset = ntohs(*((uint16_t*)&pktdata[4]));
*l2offset += 6; 
} else {
*l2offset = 4; 
}
if ((pktdata[3] & JUNIPER_FLAG_NO_L2) == JUNIPER_FLAG_NO_L2) {
uint32_t ip_hdr_offset = *l2offset;
if (datalen < ip_hdr_offset + 1)
return -1;
if ((pktdata[ip_hdr_offset] >> 4) == 4)
*protocol = ETHERTYPE_IP;
else if ((pktdata[ip_hdr_offset] >> 4) == 6)
*protocol = ETHERTYPE_IP6;
return 0;
}
case DLT_EN10MB:
{
eth_hdr_t *eth_hdr = (eth_hdr_t*)(pktdata + *l2offset);
uint32_t l2_net_off = sizeof(*eth_hdr) + *l2offset;
uint16_t ether_type = ntohs(eth_hdr->ether_type);
if (datalen <= l2_net_off)
return -1;
if (parse_metadata(pktdata,
datalen,
&ether_type,
&l2_net_off,
l2offset,
vlan_offset))
return -1;
if (datalen < l2_net_off)
return -1;
*l2len = l2_net_off;
if (ether_type > 1500) {
*protocol = ether_type;
} else {
if ((pktdata[l2_net_off] >> 4) == 4)
*protocol = ETHERTYPE_IP;
else if ((pktdata[l2_net_off] >> 4) == 6)
*protocol = ETHERTYPE_IP6;
else
return -1;
}
break;
}
case DLT_PPP_SERIAL:
if ((size_t)datalen < sizeof(struct tcpr_pppserial_hdr))
return -1;
struct tcpr_pppserial_hdr *ppp = (struct tcpr_pppserial_hdr*)pktdata;
*l2len = sizeof(*ppp);
if (ntohs(ppp->protocol) == 0x0021)
*protocol = ETHERTYPE_IP;
else
*protocol = ntohs(ppp->protocol);
break;
case DLT_C_HDLC:
if (datalen < CISCO_HDLC_LEN)
return -1;
hdlc_hdr_t *hdlc_hdr = (hdlc_hdr_t*)pktdata;
*l2len = sizeof(*hdlc_hdr);
*protocol = ntohs(hdlc_hdr->protocol);
break;
case DLT_LINUX_SLL:
if (datalen < SLL_HDR_LEN)
return -1;
sll_hdr_t *sll_hdr = (sll_hdr_t*)pktdata;
*l2len = sizeof(*sll_hdr);
*protocol = ntohs(sll_hdr->sll_protocol);
break;
default:
errx(-1, ""Unable to process unsupported DLT type: %s (0x%x)"",
pcap_datalink_val_to_description(datalink),
datalink);
}
return 0;
}","int get_l2len_protocol(const u_char *VAR_0,
const uint32_t VAR_1,
const int VAR_2,
uint16_t *VAR_3,
uint32_t *VAR_4,
uint32_t *VAR_5,
uint32_t *VAR_6)
{
assert(VAR_3);
assert(VAR_4);
assert(VAR_5);
assert(VAR_6);
if (!VAR_0 || !VAR_1) {
errx(-1, ""get_l2len_protocol: invalid L2 parameters: pktdata=0x%p len=%d"",
VAR_0,
VAR_1);
return -1;
}
*VAR_3 = 0;
*VAR_4 = 0;
*VAR_5 = 0;
*VAR_6 = 0;
switch (VAR_2) {
case VAR_7:
if (VAR_1 == 0)
return -1;
if ((VAR_0[0] >> 4) == 4)
*VAR_3 = VAR_8;
else if ((VAR_0[0] >> 4) == 6)
*VAR_3 = VAR_9;
break;
case VAR_10:
if (VAR_1 < 4)
return -1;
if (memcmp(VAR_0, VAR_11, 3)) {
warnx(""No Magic Number found during protocol lookup: %s (0x%x)"",
pcap_datalink_val_to_description(VAR_2),
VAR_2);
return -1;
}
if ((VAR_0[3] & VAR_12) == VAR_12) {
if (VAR_1 < 6)
return -1;
*VAR_5 = ntohs(*((uint16_t*)&VAR_0[4]));
*VAR_5 += 6; 
} else {
*VAR_5 = 4; 
}
if ((VAR_0[3] & VAR_13) == VAR_13) {
uint32_t VAR_14 = *VAR_5;
if (VAR_1 < VAR_14 + 1)
return -1;
if ((VAR_0[VAR_14] >> 4) == 4)
*VAR_3 = VAR_8;
else if ((VAR_0[VAR_14] >> 4) == 6)
*VAR_3 = VAR_9;
return 0;
}
case VAR_15:
{
eth_hdr_t *VAR_16 = (eth_hdr_t*)(VAR_0 + *VAR_5);
uint32_t VAR_17 = sizeof(*VAR_16) + *VAR_5;
uint16_t VAR_18 = ntohs(VAR_16->ether_type);
if (VAR_1 <= VAR_17)
return -1;
if (parse_metadata(VAR_0,
VAR_1,
&VAR_18,
&VAR_17,
VAR_5,
VAR_6))
return -1;
if (VAR_1 < VAR_17)
return -1;
*VAR_4 = VAR_17;
if (VAR_18 > 1500) {
*VAR_3 = VAR_18;
} else {
if ((VAR_0[VAR_17] >> 4) == 4)
*VAR_3 = VAR_8;
else if ((VAR_0[VAR_17] >> 4) == 6)
*VAR_3 = VAR_9;
else
return -1;
}
break;
}
case VAR_19:
if ((size_t)VAR_1 < sizeof(struct tcpr_pppserial_hdr))
return -1;
struct tcpr_pppserial_hdr *VAR_20 = (struct tcpr_pppserial_hdr*)VAR_0;
*VAR_4 = sizeof(*VAR_20);
if (ntohs(VAR_20->protocol) == 0x0021)
*VAR_3 = VAR_8;
else
*VAR_3 = ntohs(VAR_20->protocol);
break;
case VAR_21:
if (VAR_1 < VAR_22)
return -1;
hdlc_hdr_t *VAR_23 = (hdlc_hdr_t*)VAR_0;
*VAR_4 = sizeof(*VAR_23);
*VAR_3 = ntohs(VAR_23->protocol);
break;
case VAR_24:
if (VAR_1 < VAR_25)
return -1;
sll_hdr_t *VAR_26 = (sll_hdr_t*)VAR_0;
*VAR_4 = sizeof(*VAR_26);
*VAR_3 = ntohs(VAR_26->sll_protocol);
break;
default:
errx(-1, ""Unable to process unsupported DLT type: %s (0x%x)"",
pcap_datalink_val_to_description(VAR_2),
VAR_2);
}
return 0;
}",appneta/tcpreplay/a135cea13507b5d2f810d762390ba37d6b93aa3e/get.c/vul/before/0.json,"int get_l2len_protocol(const u_char *pktdata,
                       const uint32_t datalen,
                       const int datalink,
                       uint16_t *protocol,
                       uint32_t *l2len,
                       uint32_t *l2offset,
                       uint32_t *vlan_offset)
{
    assert(protocol);
    assert(l2len);
    assert(l2offset);
    assert(vlan_offset);

    if (!pktdata || !datalen) {
        errx(-1, ""get_l2len_protocol: invalid L2 parameters: pktdata=0x%p len=%d"",
             pktdata,
             datalen);
        return -1;
    }

    *protocol = 0;
    *l2len = 0;
    *l2offset = 0;
    *vlan_offset = 0;

    switch (datalink) {
    case DLT_RAW:
        if (datalen == 0)
            return -1;

        if ((pktdata[0] >> 4) == 4)
            *protocol = ETHERTYPE_IP;
        else if ((pktdata[0] >> 4) == 6)
            *protocol = ETHERTYPE_IP6;
        break;
    case DLT_JUNIPER_ETHER:
        if (datalen < 4)
            return -1;

        if (memcmp(pktdata, JUNIPER_PCAP_MAGIC, 3)) {
            warnx(""No Magic Number found during protocol lookup: %s (0x%x)"",
                  pcap_datalink_val_to_description(datalink),
                  datalink);
            return -1;
        }

        if ((pktdata[3] & JUNIPER_FLAG_EXT) == JUNIPER_FLAG_EXT) {
            if (datalen < 6)
                return -1;

            *l2offset = ntohs(*((uint16_t*)&pktdata[4]));
            *l2offset += 6; /* MGC + flags + ext_total_len */
        } else {
            *l2offset = 4; /* MGC + flags (no header extensions) */
        }

        if ((pktdata[3] & JUNIPER_FLAG_NO_L2) == JUNIPER_FLAG_NO_L2) {
            /* no L2 header present - *l2offset is actually IP offset */
            uint32_t ip_hdr_offset = *l2offset;
            if (datalen < ip_hdr_offset + 1)
                return -1;

            if ((pktdata[ip_hdr_offset] >> 4) == 4)
                *protocol = ETHERTYPE_IP;
            else if ((pktdata[ip_hdr_offset] >> 4) == 6)
                *protocol = ETHERTYPE_IP6;

            return 0;
        }

        /* fall through */
    case DLT_EN10MB:
    {
        eth_hdr_t *eth_hdr;
        uint16_t ether_type;
        uint32_t l2_net_off = sizeof(*eth_hdr) + *l2offset;

        if (datalen <= l2_net_off)
            return -1;

        eth_hdr = (eth_hdr_t*)(pktdata + *l2offset);
        ether_type = ntohs(eth_hdr->ether_type);
        if (parse_metadata(pktdata,
                           datalen,
                           &ether_type,
                           &l2_net_off,
                           l2offset,
                           vlan_offset))
            return -1;

        if (datalen < l2_net_off)
            return -1;

        *l2len = l2_net_off;
        if (ether_type > 1500) {
            /* Ethernet II frame - return in host order */
            *protocol = ether_type;
        } else {
            /* 803.3 frame */
            if ((pktdata[l2_net_off] >> 4) == 4)
                *protocol = ETHERTYPE_IP;
            else if ((pktdata[l2_net_off] >> 4) == 6)
                *protocol = ETHERTYPE_IP6;
            else
                /* unsupported 802.3 protocol */
                return -1;
        }
        break;
    }
    case DLT_PPP_SERIAL:
        if ((size_t)datalen < sizeof(struct tcpr_pppserial_hdr))
            return -1;

        struct tcpr_pppserial_hdr *ppp = (struct tcpr_pppserial_hdr*)pktdata;
        *l2len = sizeof(*ppp);
        if (ntohs(ppp->protocol) == 0x0021)
            *protocol = ETHERTYPE_IP;
        else
            *protocol = ntohs(ppp->protocol);

        break;
    case DLT_C_HDLC:
        if (datalen < CISCO_HDLC_LEN)
            return -1;

        hdlc_hdr_t *hdlc_hdr = (hdlc_hdr_t*)pktdata;
        *l2len = sizeof(*hdlc_hdr);
        *protocol = ntohs(hdlc_hdr->protocol);
        break;
    case DLT_LINUX_SLL:
        if (datalen < SLL_HDR_LEN)
            return -1;

        sll_hdr_t *sll_hdr = (sll_hdr_t*)pktdata;
        *l2len = sizeof(*sll_hdr);
        *protocol = ntohs(sll_hdr->sll_protocol);
        break;
    default:
        errx(-1, ""Unable to process unsupported DLT type: %s (0x%x)"",
             pcap_datalink_val_to_description(datalink),
             datalink);
    }

    return 0;
}","int get_l2len_protocol(const u_char *VAR_0,
                       const uint32_t VAR_1,
                       const int VAR_2,
                       uint16_t *VAR_3,
                       uint32_t *VAR_4,
                       uint32_t *VAR_5,
                       uint32_t *VAR_6)
{
    assert(VAR_3);
    assert(VAR_4);
    assert(VAR_5);
    assert(VAR_6);

    if (!VAR_0 || !VAR_1) {
        errx(-1, ""get_l2len_protocol: invalid L2 parameters: pktdata=0x%p len=%d"",
             VAR_0,
             VAR_1);
        return -1;
    }

    *VAR_3 = 0;
    *VAR_4 = 0;
    *VAR_5 = 0;
    *VAR_6 = 0;

    switch (VAR_2) {
    case VAR_7:
        if (VAR_1 == 0)
            return -1;

        if ((VAR_0[0] >> 4) == 4)
            *VAR_3 = VAR_8;
        else if ((VAR_0[0] >> 4) == 6)
            *VAR_3 = VAR_9;
        break;
    case VAR_10:
        if (VAR_1 < 4)
            return -1;

        if (memcmp(VAR_0, VAR_11, 3)) {
            warnx(""No Magic Number found during protocol lookup: %s (0x%x)"",
                  pcap_datalink_val_to_description(VAR_2),
                  VAR_2);
            return -1;
        }

        if ((VAR_0[3] & VAR_12) == VAR_12) {
            if (VAR_1 < 6)
                return -1;

            *VAR_5 = ntohs(*((uint16_t*)&VAR_0[4]));
            *VAR_5 += 6; /* COMMENT_0 */
        } else {
            *VAR_5 = 4; /* COMMENT_1 */
        }

        if ((VAR_0[3] & VAR_13) == VAR_13) {
            /* COMMENT_2 */
            uint32_t VAR_14 = *VAR_5;
            if (VAR_1 < VAR_14 + 1)
                return -1;

            if ((VAR_0[VAR_14] >> 4) == 4)
                *VAR_3 = VAR_8;
            else if ((VAR_0[VAR_14] >> 4) == 6)
                *VAR_3 = VAR_9;

            return 0;
        }

        /* COMMENT_3 */
    case VAR_15:
    {
        eth_hdr_t *VAR_16;
        uint16_t VAR_17;
        uint32_t VAR_18 = sizeof(*VAR_16) + *VAR_5;

        if (VAR_1 <= VAR_18)
            return -1;

        VAR_16 = (eth_hdr_t*)(VAR_0 + *VAR_5);
        VAR_17 = ntohs(VAR_16->ether_type);
        if (parse_metadata(VAR_0,
                           VAR_1,
                           &VAR_17,
                           &VAR_18,
                           VAR_5,
                           VAR_6))
            return -1;

        if (VAR_1 < VAR_18)
            return -1;

        *VAR_4 = VAR_18;
        if (VAR_17 > 1500) {
            /* COMMENT_4 */
            *VAR_3 = VAR_17;
        } else {
            /* COMMENT_5 */
            if ((VAR_0[VAR_18] >> 4) == 4)
                *VAR_3 = VAR_8;
            else if ((VAR_0[VAR_18] >> 4) == 6)
                *VAR_3 = VAR_9;
            else
                /* COMMENT_6 */
                return -1;
        }
        break;
    }
    case VAR_19:
        if ((size_t)VAR_1 < sizeof(struct tcpr_pppserial_hdr))
            return -1;

        struct tcpr_pppserial_hdr *VAR_20 = (struct tcpr_pppserial_hdr*)VAR_0;
        *VAR_4 = sizeof(*VAR_20);
        if (ntohs(VAR_20->protocol) == 0x0021)
            *VAR_3 = VAR_8;
        else
            *VAR_3 = ntohs(VAR_20->protocol);

        break;
    case VAR_21:
        if (VAR_1 < VAR_22)
            return -1;

        hdlc_hdr_t *VAR_23 = (hdlc_hdr_t*)VAR_0;
        *VAR_4 = sizeof(*VAR_23);
        *VAR_3 = ntohs(VAR_23->protocol);
        break;
    case VAR_24:
        if (VAR_1 < VAR_25)
            return -1;

        sll_hdr_t *VAR_26 = (sll_hdr_t*)VAR_0;
        *VAR_4 = sizeof(*VAR_26);
        *VAR_3 = ntohs(VAR_26->sll_protocol);
        break;
    default:
        errx(-1, ""Unable to process unsupported DLT type: %s (0x%x)"",
             pcap_datalink_val_to_description(VAR_2),
             VAR_2);
    }

    return 0;
}",appneta/tcpreplay/a135cea13507b5d2f810d762390ba37d6b93aa3e/get.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -71,13 +71,15 @@
         /* fall through */
     case DLT_EN10MB:
     {
-        eth_hdr_t *eth_hdr = (eth_hdr_t*)(pktdata + *l2offset);
+        eth_hdr_t *eth_hdr;
+        uint16_t ether_type;
         uint32_t l2_net_off = sizeof(*eth_hdr) + *l2offset;
-        uint16_t ether_type = ntohs(eth_hdr->ether_type);
 
         if (datalen <= l2_net_off)
             return -1;
 
+        eth_hdr = (eth_hdr_t*)(pktdata + *l2offset);
+        ether_type = ntohs(eth_hdr->ether_type);
         if (parse_metadata(pktdata,
                            datalen,
                            &ether_type,","{'deleted_lines': ['        eth_hdr_t *eth_hdr = (eth_hdr_t*)(pktdata + *l2offset);', '        uint16_t ether_type = ntohs(eth_hdr->ether_type);'], 'added_lines': ['        eth_hdr_t *eth_hdr;', '        uint16_t ether_type;', '        eth_hdr = (eth_hdr_t*)(pktdata + *l2offset);', '        ether_type = ntohs(eth_hdr->ether_type);']}",True,tcprewrite in Tcpreplay 4.4.1 has a heap-based buffer over-read in get_l2len_protocol in common/get.c.,7.8,HIGH,2,test,2022-08-01T19:20:41Z,4
CVE-2023-1095,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"netfilter: nf_tables: fix null deref due to zeroed list head

In nf_tables_updtable, if nf_tables_table_enable returns an error,
nft_trans_destroy is called to free the transaction object.

nft_trans_destroy() calls list_del(), but the transaction was never
placed on a list -- the list head is all zeroes, this results in
a null dereference:

BUG: KASAN: null-ptr-deref in nft_trans_destroy+0x26/0x59
Call Trace:
 nft_trans_destroy+0x26/0x59
 nf_tables_newtable+0x4bc/0x9bc
 [..]

Its sane to assume that nft_trans_destroy() can be called
on the transaction object returned by nft_trans_alloc(), so
make sure the list head is initialised.

Fixes: 55dd6f93076b (""netfilter: nf_tables: use new transaction infrastructure to handle table"")
Reported-by: mingi cho <mgcho.minic@gmail.com>
Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",580077855a40741cf511766129702d97ff02f4d9,https://github.com/torvalds/linux/commit/580077855a40741cf511766129702d97ff02f4d9,net/netfilter/nf_tables_api.c,nft_trans_alloc_gfp,"static struct nft_trans *nft_trans_alloc_gfp(const struct nft_ctx *ctx,
int msg_type, u32 size, gfp_t gfp)
{
struct nft_trans *trans;
trans = kzalloc(sizeof(struct nft_trans) + size, gfp);
if (trans == NULL)
return NULL;
trans->msg_type = msg_type;
trans->ctx= *ctx;
return trans;
}","static struct nft_trans *nft_trans_alloc_gfp(const struct nft_ctx *VAR_0,
int VAR_1, u32 VAR_2, gfp_t VAR_3)
{
struct nft_trans *VAR_4;
VAR_4 = kzalloc(sizeof(struct nft_trans) + VAR_2, VAR_3);
if (VAR_4 == NULL)
return NULL;
VAR_4->msg_type = VAR_1;
VAR_4->ctx= *VAR_0;
return VAR_4;
}",torvalds/linux/580077855a40741cf511766129702d97ff02f4d9/nf_tables_api.c/vul/before/0.json,"static struct nft_trans *nft_trans_alloc_gfp(const struct nft_ctx *ctx,
					     int msg_type, u32 size, gfp_t gfp)
{
	struct nft_trans *trans;

	trans = kzalloc(sizeof(struct nft_trans) + size, gfp);
	if (trans == NULL)
		return NULL;

	INIT_LIST_HEAD(&trans->list);
	trans->msg_type = msg_type;
	trans->ctx	= *ctx;

	return trans;
}","static struct nft_trans *nft_trans_alloc_gfp(const struct nft_ctx *VAR_0,
					     int VAR_1, u32 VAR_2, gfp_t VAR_3)
{
	struct nft_trans *VAR_4;

	VAR_4 = kzalloc(sizeof(struct nft_trans) + VAR_2, VAR_3);
	if (VAR_4 == NULL)
		return NULL;

	INIT_LIST_HEAD(&VAR_4->list);
	VAR_4->msg_type = VAR_1;
	VAR_4->ctx	= *VAR_0;

	return VAR_4;
}",torvalds/linux/580077855a40741cf511766129702d97ff02f4d9/nf_tables_api.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,6 +7,7 @@
 	if (trans == NULL)
 		return NULL;
 
+	INIT_LIST_HEAD(&trans->list);
 	trans->msg_type = msg_type;
 	trans->ctx	= *ctx;
 ","{'deleted_lines': [], 'added_lines': ['\tINIT_LIST_HEAD(&trans->list);']}",True,"In nf_tables_updtable, if nf_tables_table_enable returns an error, nft_trans_destroy is called to free the transaction object. nft_trans_destroy() calls list_del(), but the transaction was never placed on a list -- the list head is all zeroes, this results in a NULL pointer dereference.",5.5,MEDIUM,1,test,2022-08-09T16:34:02Z,4
CVE-2022-36044,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,rizinorg/rizin,Fix oob read on _luac_build_info and luac memleaks,05bbd147caccc60162d6fba9baaaf24befa281cd,https://github.com/rizinorg/rizin/commit/05bbd147caccc60162d6fba9baaaf24befa281cd,librz/bin/p/bin_luac.c,strings,"static RzList *strings(RzBinFile *bf) {
if (!bf) {
return NULL;
}
LuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf);
if (!bin_info_obj) {
return NULL;
}
return bin_info_obj->string_list;
}","static RzList *strings(RzBinFile *VAR_0) {
if (!VAR_0) {
return NULL;
}
LuacBinInfo *VAR_1 = GET_INTERNAL_BIN_INFO_OBJ(VAR_0);
if (!VAR_1) {
return NULL;
}
return VAR_1->string_list;
}",rizinorg/rizin/05bbd147caccc60162d6fba9baaaf24befa281cd/bin_luac.c/vul/before/1.json,"static RzList *strings(RzBinFile *bf) {
	if (!bf) {
		return NULL;
	}
	LuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf);
	if (!bin_info_obj) {
		return NULL;
	}

	return rz_list_clone(bin_info_obj->string_list);
}","static RzList *strings(RzBinFile *VAR_0) {
	if (!VAR_0) {
		return NULL;
	}
	LuacBinInfo *VAR_1 = GET_INTERNAL_BIN_INFO_OBJ(VAR_0);
	if (!VAR_1) {
		return NULL;
	}

	return rz_list_clone(VAR_1->string_list);
}",rizinorg/rizin/05bbd147caccc60162d6fba9baaaf24befa281cd/bin_luac.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -7,5 +7,5 @@
 		return NULL;
 	}
 
-	return bin_info_obj->string_list;
+	return rz_list_clone(bin_info_obj->string_list);
 }","{'deleted_lines': ['\treturn bin_info_obj->string_list;'], 'added_lines': ['\treturn rz_list_clone(bin_info_obj->string_list);']}",True,"Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from Luac files. A user opening a malicious Luac file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commits 07b43bc8aa1ffebd9b68d60624c9610cf7e460c7 and 05bbd147caccc60162d6fba9baaaf24befa281cd contain fixes for the issue.",7.8,HIGH,2,test,2022-08-17T12:29:37Z,4
CVE-2022-36044,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,rizinorg/rizin,Fix oob read on _luac_build_info and luac memleaks,05bbd147caccc60162d6fba9baaaf24befa281cd,https://github.com/rizinorg/rizin/commit/05bbd147caccc60162d6fba9baaaf24befa281cd,librz/bin/format/luac/luac_bin.c,_luac_build_info,"void _luac_build_info(LuaProto *proto, LuacBinInfo *info) {
char *section_name;
char *symbol_name;
char *proto_name;
RzListIter *iter;
ut64 current_offset;
ut64 current_size;
int i = 0; 
if (proto->name_size == 0 || proto->proto_name == NULL) {
proto_name = rz_str_newf(""fcn.%08llx"", proto->offset);
} else {
proto_name = rz_str_new((char *)proto->proto_name);
}
current_offset = proto->offset;
current_size = proto->size;
section_name = rz_str_newf(""%s.header"", proto_name);
luac_add_section(info->section_list, section_name, current_offset, current_size, false);
RZ_FREE(section_name);
current_offset = proto->code_offset;
current_size = proto->code_size;
section_name = rz_str_newf(""%s.code"", proto_name);
luac_add_section(info->section_list, section_name, current_offset, current_size, true);
RZ_FREE(section_name);
current_offset = proto->const_offset;
current_size = proto->const_size;
section_name = rz_str_newf(""%s.const"", proto_name);
luac_add_section(info->section_list, section_name, current_offset, current_size, false);
RZ_FREE(section_name);
current_offset = proto->upvalue_offset;
current_size = proto->upvalue_size;
section_name = rz_str_newf(""%s.upvalues"", proto_name);
luac_add_section(info->section_list, section_name, current_offset, current_size, false);
RZ_FREE(section_name);
current_offset = proto->inner_proto_offset;
current_size = proto->inner_proto_size;
section_name = rz_str_newf(""%s.protos"", proto_name);
luac_add_section(info->section_list, section_name, current_offset, current_size, false);
RZ_FREE(section_name);
current_offset = proto->debug_offset;
current_size = proto->debug_size;
section_name = rz_str_newf(""%s.debug"", proto_name);
luac_add_section(info->section_list, section_name, current_offset, current_size, false);
RZ_FREE(section_name);
LuaLocalVarEntry *local_var_entry;
rz_list_foreach (proto->local_var_info_entries, iter, local_var_entry) {
luac_add_string(
info->string_list,
(char *)local_var_entry->varname,
local_var_entry->offset,
local_var_entry->varname_len);
}
char **upvalue_names;
int real_upvalue_cnt;
LuaDbgUpvalueEntry *debug_upv_entry;
real_upvalue_cnt = rz_list_length(proto->upvalue_entries);
upvalue_names = RZ_NEWS0(char *, real_upvalue_cnt);
if (!upvalue_names) {
return;
}
rz_list_foreach (proto->dbg_upvalue_entries, iter, debug_upv_entry) {
upvalue_names[i] = (char *)debug_upv_entry->upvalue_name;
luac_add_string(
info->string_list,
upvalue_names[i],
debug_upv_entry->offset,
debug_upv_entry->name_len);
}
LuaConstEntry *const_entry;
rz_list_foreach (proto->const_entries, iter, const_entry) {
symbol_name = get_constant_symbol_name(proto_name, const_entry);
luac_add_symbol(
info->symbol_list,
symbol_name,
const_entry->offset,
const_entry->data_len,
get_tag_string(const_entry->tag));
if (const_entry->tag == LUA_VLNGSTR || const_entry->tag == LUA_VSHRSTR) {
luac_add_string(
info->string_list,
(char *)const_entry->data,
const_entry->offset,
const_entry->data_len);
}
RZ_FREE(symbol_name);
}
LuaUpvalueEntry *upvalue_entry;
i = 0;
rz_list_foreach (proto->upvalue_entries, iter, upvalue_entry) {
symbol_name = get_upvalue_symbol_name(proto_name, upvalue_entry, upvalue_names[i++]);
luac_add_symbol(
info->symbol_list,
symbol_name,
upvalue_entry->offset,
3,
""UPVALUE"");
RZ_FREE(symbol_name);
}
LuaProto *sub_proto;
rz_list_foreach (proto->proto_entries, iter, sub_proto) {
_luac_build_info(sub_proto, info);
}
RZ_FREE(proto_name);
}","void _luac_build_info(LuaProto *VAR_0, LuacBinInfo *VAR_1) {
char *VAR_2;
char *VAR_3;
char *VAR_4;
RzListIter *VAR_5;
ut64 VAR_6;
ut64 VAR_7;
int VAR_8 = 0; 
if (VAR_0->name_size == 0 || VAR_0->proto_name == NULL) {
VAR_4 = rz_str_newf(""fcn.%08llx"", VAR_0->offset);
} else {
VAR_4 = rz_str_new((char *)VAR_0->proto_name);
}
VAR_6 = VAR_0->offset;
VAR_7 = VAR_0->size;
VAR_2 = rz_str_newf(""%s.header"", VAR_4);
luac_add_section(VAR_1->section_list, VAR_2, VAR_6, VAR_7, false);
RZ_FREE(VAR_2);
VAR_6 = VAR_0->code_offset;
VAR_7 = VAR_0->code_size;
VAR_2 = rz_str_newf(""%s.code"", VAR_4);
luac_add_section(VAR_1->section_list, VAR_2, VAR_6, VAR_7, true);
RZ_FREE(VAR_2);
VAR_6 = VAR_0->const_offset;
VAR_7 = VAR_0->const_size;
VAR_2 = rz_str_newf(""%s.const"", VAR_4);
luac_add_section(VAR_1->section_list, VAR_2, VAR_6, VAR_7, false);
RZ_FREE(VAR_2);
VAR_6 = VAR_0->upvalue_offset;
VAR_7 = VAR_0->upvalue_size;
VAR_2 = rz_str_newf(""%s.upvalues"", VAR_4);
luac_add_section(VAR_1->section_list, VAR_2, VAR_6, VAR_7, false);
RZ_FREE(VAR_2);
VAR_6 = VAR_0->inner_proto_offset;
VAR_7 = VAR_0->inner_proto_size;
VAR_2 = rz_str_newf(""%s.protos"", VAR_4);
luac_add_section(VAR_1->section_list, VAR_2, VAR_6, VAR_7, false);
RZ_FREE(VAR_2);
VAR_6 = VAR_0->debug_offset;
VAR_7 = VAR_0->debug_size;
VAR_2 = rz_str_newf(""%s.debug"", VAR_4);
luac_add_section(VAR_1->section_list, VAR_2, VAR_6, VAR_7, false);
RZ_FREE(VAR_2);
LuaLocalVarEntry *VAR_9;
rz_list_foreach (VAR_0->local_var_info_entries, VAR_5, VAR_9) {
luac_add_string(
VAR_1->string_list,
(char *)VAR_9->varname,
VAR_9->offset,
VAR_9->varname_len);
}
char **VAR_10;
int VAR_11;
LuaDbgUpvalueEntry *VAR_12;
VAR_11 = rz_list_length(VAR_0->upvalue_entries);
VAR_10 = RZ_NEWS0(char *, VAR_11);
if (!VAR_10) {
return;
}
rz_list_foreach (VAR_0->dbg_upvalue_entries, VAR_5, VAR_12) {
VAR_10[VAR_8] = (char *)VAR_12->upvalue_name;
luac_add_string(
VAR_1->string_list,
VAR_10[VAR_8],
VAR_12->offset,
VAR_12->name_len);
}
LuaConstEntry *VAR_13;
rz_list_foreach (VAR_0->const_entries, VAR_5, VAR_13) {
VAR_3 = get_constant_symbol_name(VAR_4, VAR_13);
luac_add_symbol(
VAR_1->symbol_list,
VAR_3,
VAR_13->offset,
VAR_13->data_len,
get_tag_string(VAR_13->tag));
if (VAR_13->tag == VAR_14 || VAR_13->tag == VAR_15) {
luac_add_string(
VAR_1->string_list,
(char *)VAR_13->data,
VAR_13->offset,
VAR_13->data_len);
}
RZ_FREE(VAR_3);
}
LuaUpvalueEntry *VAR_16;
VAR_8 = 0;
rz_list_foreach (VAR_0->upvalue_entries, VAR_5, VAR_16) {
VAR_3 = get_upvalue_symbol_name(VAR_4, VAR_16, VAR_10[VAR_8++]);
luac_add_symbol(
VAR_1->symbol_list,
VAR_3,
VAR_16->offset,
3,
""UPVALUE"");
RZ_FREE(VAR_3);
}
LuaProto *VAR_17;
rz_list_foreach (VAR_0->proto_entries, VAR_5, VAR_17) {
_luac_build_info(VAR_17, VAR_1);
}
RZ_FREE(VAR_4);
}",rizinorg/rizin/05bbd147caccc60162d6fba9baaaf24befa281cd/luac_bin.c/vul/before/1.json,"void _luac_build_info(LuaProto *proto, LuacBinInfo *info) {
	/* process proto header info */
	char *section_name;
	char *symbol_name;
	char *proto_name;
	char **upvalue_names = NULL;
	RzListIter *iter;
	int i = 0; // iter

	ut64 current_offset;
	ut64 current_size;

	// 0. check if stripped (proto name is lost)
	if (proto->name_size == 0 || proto->proto_name == NULL) {
		// replace name with current offset
		proto_name = rz_str_newf(""fcn.%08llx"", proto->offset);
	} else {
		proto_name = rz_str_new((char *)proto->proto_name);
	}

	// 1.1 set section name as function_name.header
	current_offset = proto->offset;
	current_size = proto->size;
	section_name = rz_str_newf(""%s.header"", proto_name);
	luac_add_section(info->section_list, section_name, current_offset, current_size, false);
	RZ_FREE(section_name);

	// 1.2 set section name as function_name.code
	current_offset = proto->code_offset;
	current_size = proto->code_size;
	section_name = rz_str_newf(""%s.code"", proto_name);
	luac_add_section(info->section_list, section_name, current_offset, current_size, true);
	RZ_FREE(section_name);

	// 1.3 set const section
	current_offset = proto->const_offset;
	current_size = proto->const_size;
	section_name = rz_str_newf(""%s.const"", proto_name);
	luac_add_section(info->section_list, section_name, current_offset, current_size, false);
	RZ_FREE(section_name);

	// 1.4 upvalue section
	current_offset = proto->upvalue_offset;
	current_size = proto->upvalue_size;
	section_name = rz_str_newf(""%s.upvalues"", proto_name);
	luac_add_section(info->section_list, section_name, current_offset, current_size, false);
	RZ_FREE(section_name);

	// 1.5 inner protos section
	current_offset = proto->inner_proto_offset;
	current_size = proto->inner_proto_size;
	section_name = rz_str_newf(""%s.protos"", proto_name);
	luac_add_section(info->section_list, section_name, current_offset, current_size, false);
	RZ_FREE(section_name);

	// 1.6 debug section
	current_offset = proto->debug_offset;
	current_size = proto->debug_size;
	section_name = rz_str_newf(""%s.debug"", proto_name);
	luac_add_section(info->section_list, section_name, current_offset, current_size, false);
	RZ_FREE(section_name);

	// 2.1 parse local var info
	LuaLocalVarEntry *local_var_entry;
	rz_list_foreach (proto->local_var_info_entries, iter, local_var_entry) {
		luac_add_string(
			info->string_list,
			(char *)local_var_entry->varname,
			local_var_entry->offset,
			local_var_entry->varname_len);
	}

	// 2.2 parse debug_upvalues
	size_t real_upvalue_cnt = rz_list_length(proto->upvalue_entries);
	if (real_upvalue_cnt > 0) {
		LuaDbgUpvalueEntry *debug_upv_entry;
		upvalue_names = RZ_NEWS0(char *, real_upvalue_cnt);
		if (!upvalue_names) {
			free(proto_name);
			return;
		}

		i = 0;
		rz_list_foreach (proto->dbg_upvalue_entries, iter, debug_upv_entry) {
			upvalue_names[i] = (char *)debug_upv_entry->upvalue_name;
			luac_add_string(
				info->string_list,
				upvalue_names[i],
				debug_upv_entry->offset,
				debug_upv_entry->name_len);
			i++;
		}
	}

	// 3.1 construct constant symbols
	LuaConstEntry *const_entry;
	rz_list_foreach (proto->const_entries, iter, const_entry) {
		symbol_name = get_constant_symbol_name(proto_name, const_entry);
		luac_add_symbol(
			info->symbol_list,
			symbol_name,
			const_entry->offset,
			const_entry->data_len,
			get_tag_string(const_entry->tag));
		if (const_entry->tag == LUA_VLNGSTR || const_entry->tag == LUA_VSHRSTR) {
			luac_add_string(
				info->string_list,
				(char *)const_entry->data,
				const_entry->offset,
				const_entry->data_len);
		}
		RZ_FREE(symbol_name);
	}

	// 3.2 construct upvalue symbols
	LuaUpvalueEntry *upvalue_entry;
	i = 0;
	rz_list_foreach (proto->upvalue_entries, iter, upvalue_entry) {
		symbol_name = get_upvalue_symbol_name(proto_name, upvalue_entry, upvalue_names[i++]);
		luac_add_symbol(
			info->symbol_list,
			symbol_name,
			upvalue_entry->offset,
			3,
			""UPVALUE"");
		RZ_FREE(symbol_name);
	}

	// 4. parse sub proto
	LuaProto *sub_proto;
	rz_list_foreach (proto->proto_entries, iter, sub_proto) {
		_luac_build_info(sub_proto, info);
	}

	free(upvalue_names);
	free(proto_name);
}","void _luac_build_info(LuaProto *VAR_0, LuacBinInfo *VAR_1) {
	/* COMMENT_0 */
	char *VAR_2;
	char *VAR_3;
	char *VAR_4;
	char **VAR_5 = NULL;
	RzListIter *VAR_6;
	int VAR_7 = 0; /* COMMENT_1 */

	ut64 VAR_8;
	ut64 VAR_9;

	/* COMMENT_2 */
	if (VAR_0->name_size == 0 || VAR_0->proto_name == NULL) {
		/* COMMENT_3 */
		VAR_4 = rz_str_newf(""fcn.%08llx"", VAR_0->offset);
	} else {
		VAR_4 = rz_str_new((char *)VAR_0->proto_name);
	}

	/* COMMENT_4 */
	VAR_8 = VAR_0->offset;
	VAR_9 = VAR_0->size;
	VAR_2 = rz_str_newf(""%s.header"", VAR_4);
	luac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);
	RZ_FREE(VAR_2);

	/* COMMENT_5 */
	VAR_8 = VAR_0->code_offset;
	VAR_9 = VAR_0->code_size;
	VAR_2 = rz_str_newf(""%s.code"", VAR_4);
	luac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, true);
	RZ_FREE(VAR_2);

	/* COMMENT_6 */
	VAR_8 = VAR_0->const_offset;
	VAR_9 = VAR_0->const_size;
	VAR_2 = rz_str_newf(""%s.const"", VAR_4);
	luac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);
	RZ_FREE(VAR_2);

	/* COMMENT_7 */
	VAR_8 = VAR_0->upvalue_offset;
	VAR_9 = VAR_0->upvalue_size;
	VAR_2 = rz_str_newf(""%s.upvalues"", VAR_4);
	luac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);
	RZ_FREE(VAR_2);

	/* COMMENT_8 */
	VAR_8 = VAR_0->inner_proto_offset;
	VAR_9 = VAR_0->inner_proto_size;
	VAR_2 = rz_str_newf(""%s.protos"", VAR_4);
	luac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);
	RZ_FREE(VAR_2);

	/* COMMENT_9 */
	VAR_8 = VAR_0->debug_offset;
	VAR_9 = VAR_0->debug_size;
	VAR_2 = rz_str_newf(""%s.debug"", VAR_4);
	luac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);
	RZ_FREE(VAR_2);

	/* COMMENT_10 */
	LuaLocalVarEntry *VAR_10;
	rz_list_foreach (VAR_0->local_var_info_entries, VAR_6, VAR_10) {
		luac_add_string(
			VAR_1->string_list,
			(char *)VAR_10->varname,
			VAR_10->offset,
			VAR_10->varname_len);
	}

	/* COMMENT_11 */
	size_t VAR_11 = rz_list_length(VAR_0->upvalue_entries);
	if (VAR_11 > 0) {
		LuaDbgUpvalueEntry *VAR_12;
		VAR_5 = RZ_NEWS0(char *, VAR_11);
		if (!VAR_5) {
			free(VAR_4);
			return;
		}

		VAR_7 = 0;
		rz_list_foreach (VAR_0->dbg_upvalue_entries, VAR_6, VAR_12) {
			VAR_5[VAR_7] = (char *)VAR_12->upvalue_name;
			luac_add_string(
				VAR_1->string_list,
				VAR_5[VAR_7],
				VAR_12->offset,
				VAR_12->name_len);
			VAR_7++;
		}
	}

	/* COMMENT_12 */
	LuaConstEntry *VAR_13;
	rz_list_foreach (VAR_0->const_entries, VAR_6, VAR_13) {
		VAR_3 = get_constant_symbol_name(VAR_4, VAR_13);
		luac_add_symbol(
			VAR_1->symbol_list,
			VAR_3,
			VAR_13->offset,
			VAR_13->data_len,
			get_tag_string(VAR_13->tag));
		if (VAR_13->tag == VAR_14 || VAR_13->tag == VAR_15) {
			luac_add_string(
				VAR_1->string_list,
				(char *)VAR_13->data,
				VAR_13->offset,
				VAR_13->data_len);
		}
		RZ_FREE(VAR_3);
	}

	/* COMMENT_13 */
	LuaUpvalueEntry *VAR_16;
	VAR_7 = 0;
	rz_list_foreach (VAR_0->upvalue_entries, VAR_6, VAR_16) {
		VAR_3 = get_upvalue_symbol_name(VAR_4, VAR_16, VAR_5[VAR_7++]);
		luac_add_symbol(
			VAR_1->symbol_list,
			VAR_3,
			VAR_16->offset,
			3,
			""UPVALUE"");
		RZ_FREE(VAR_3);
	}

	/* COMMENT_14 */
	LuaProto *VAR_17;
	rz_list_foreach (VAR_0->proto_entries, VAR_6, VAR_17) {
		_luac_build_info(VAR_17, VAR_1);
	}

	free(VAR_5);
	free(VAR_4);
}",rizinorg/rizin/05bbd147caccc60162d6fba9baaaf24befa281cd/luac_bin.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -3,12 +3,12 @@
 	char *section_name;
 	char *symbol_name;
 	char *proto_name;
+	char **upvalue_names = NULL;
 	RzListIter *iter;
+	int i = 0; // iter
 
 	ut64 current_offset;
 	ut64 current_size;
-
-	int i = 0; // iter
 
 	// 0. check if stripped (proto name is lost)
 	if (proto->name_size == 0 || proto->proto_name == NULL) {
@@ -71,21 +71,25 @@
 	}
 
 	// 2.2 parse debug_upvalues
-	char **upvalue_names;
-	int real_upvalue_cnt;
-	LuaDbgUpvalueEntry *debug_upv_entry;
-	real_upvalue_cnt = rz_list_length(proto->upvalue_entries);
-	upvalue_names = RZ_NEWS0(char *, real_upvalue_cnt);
-	if (!upvalue_names) {
-		return;
-	}
-	rz_list_foreach (proto->dbg_upvalue_entries, iter, debug_upv_entry) {
-		upvalue_names[i] = (char *)debug_upv_entry->upvalue_name;
-		luac_add_string(
-			info->string_list,
-			upvalue_names[i],
-			debug_upv_entry->offset,
-			debug_upv_entry->name_len);
+	size_t real_upvalue_cnt = rz_list_length(proto->upvalue_entries);
+	if (real_upvalue_cnt > 0) {
+		LuaDbgUpvalueEntry *debug_upv_entry;
+		upvalue_names = RZ_NEWS0(char *, real_upvalue_cnt);
+		if (!upvalue_names) {
+			free(proto_name);
+			return;
+		}
+
+		i = 0;
+		rz_list_foreach (proto->dbg_upvalue_entries, iter, debug_upv_entry) {
+			upvalue_names[i] = (char *)debug_upv_entry->upvalue_name;
+			luac_add_string(
+				info->string_list,
+				upvalue_names[i],
+				debug_upv_entry->offset,
+				debug_upv_entry->name_len);
+			i++;
+		}
 	}
 
 	// 3.1 construct constant symbols
@@ -128,5 +132,6 @@
 		_luac_build_info(sub_proto, info);
 	}
 
-	RZ_FREE(proto_name);
+	free(upvalue_names);
+	free(proto_name);
 }","{'deleted_lines': ['', '\tint i = 0; // iter', '\tchar **upvalue_names;', '\tint real_upvalue_cnt;', '\tLuaDbgUpvalueEntry *debug_upv_entry;', '\treal_upvalue_cnt = rz_list_length(proto->upvalue_entries);', '\tupvalue_names = RZ_NEWS0(char *, real_upvalue_cnt);', '\tif (!upvalue_names) {', '\t\treturn;', '\t}', '\trz_list_foreach (proto->dbg_upvalue_entries, iter, debug_upv_entry) {', '\t\tupvalue_names[i] = (char *)debug_upv_entry->upvalue_name;', '\t\tluac_add_string(', '\t\t\tinfo->string_list,', '\t\t\tupvalue_names[i],', '\t\t\tdebug_upv_entry->offset,', '\t\t\tdebug_upv_entry->name_len);', '\tRZ_FREE(proto_name);'], 'added_lines': ['\tchar **upvalue_names = NULL;', '\tint i = 0; // iter', '\tsize_t real_upvalue_cnt = rz_list_length(proto->upvalue_entries);', '\tif (real_upvalue_cnt > 0) {', '\t\tLuaDbgUpvalueEntry *debug_upv_entry;', '\t\tupvalue_names = RZ_NEWS0(char *, real_upvalue_cnt);', '\t\tif (!upvalue_names) {', '\t\t\tfree(proto_name);', '\t\t\treturn;', '\t\t}', '', '\t\ti = 0;', '\t\trz_list_foreach (proto->dbg_upvalue_entries, iter, debug_upv_entry) {', '\t\t\tupvalue_names[i] = (char *)debug_upv_entry->upvalue_name;', '\t\t\tluac_add_string(', '\t\t\t\tinfo->string_list,', '\t\t\t\tupvalue_names[i],', '\t\t\t\tdebug_upv_entry->offset,', '\t\t\t\tdebug_upv_entry->name_len);', '\t\t\ti++;', '\t\t}', '\tfree(upvalue_names);', '\tfree(proto_name);']}",True,"Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from Luac files. A user opening a malicious Luac file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commits 07b43bc8aa1ffebd9b68d60624c9610cf7e460c7 and 05bbd147caccc60162d6fba9baaaf24befa281cd contain fixes for the issue.",7.8,HIGH,2,test,2022-08-17T12:29:37Z,4
CVE-2022-36044,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,rizinorg/rizin,Fix oob read on _luac_build_info and luac memleaks,05bbd147caccc60162d6fba9baaaf24befa281cd,https://github.com/rizinorg/rizin/commit/05bbd147caccc60162d6fba9baaaf24befa281cd,librz/bin/p/bin_luac.c,entries,"static RzList *entries(RzBinFile *bf) {
if (!bf) {
return NULL;
}
LuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf);
if (!bin_info_obj) {
return NULL;
}
return bin_info_obj->entry_list;
}","static RzList *entries(RzBinFile *VAR_0) {
if (!VAR_0) {
return NULL;
}
LuacBinInfo *VAR_1 = GET_INTERNAL_BIN_INFO_OBJ(VAR_0);
if (!VAR_1) {
return NULL;
}
return VAR_1->entry_list;
}",rizinorg/rizin/05bbd147caccc60162d6fba9baaaf24befa281cd/bin_luac.c/vul/before/2.json,"static RzList *entries(RzBinFile *bf) {
	if (!bf) {
		return NULL;
	}
	LuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf);
	if (!bin_info_obj) {
		return NULL;
	}

	return rz_list_clone(bin_info_obj->entry_list);
}","static RzList *entries(RzBinFile *VAR_0) {
	if (!VAR_0) {
		return NULL;
	}
	LuacBinInfo *VAR_1 = GET_INTERNAL_BIN_INFO_OBJ(VAR_0);
	if (!VAR_1) {
		return NULL;
	}

	return rz_list_clone(VAR_1->entry_list);
}",rizinorg/rizin/05bbd147caccc60162d6fba9baaaf24befa281cd/bin_luac.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -7,5 +7,5 @@
 		return NULL;
 	}
 
-	return bin_info_obj->entry_list;
+	return rz_list_clone(bin_info_obj->entry_list);
 }","{'deleted_lines': ['\treturn bin_info_obj->entry_list;'], 'added_lines': ['\treturn rz_list_clone(bin_info_obj->entry_list);']}",True,"Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from Luac files. A user opening a malicious Luac file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commits 07b43bc8aa1ffebd9b68d60624c9610cf7e460c7 and 05bbd147caccc60162d6fba9baaaf24befa281cd contain fixes for the issue.",7.8,HIGH,2,test,2022-08-17T12:29:37Z,4
CVE-2022-36044,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,rizinorg/rizin,Fix oob read on _luac_build_info and luac memleaks,05bbd147caccc60162d6fba9baaaf24befa281cd,https://github.com/rizinorg/rizin/commit/05bbd147caccc60162d6fba9baaaf24befa281cd,librz/bin/format/luac/luac_bin.c,luac_build_info,"LuacBinInfo *luac_build_info(LuaProto *proto) {
if (!proto) {
RZ_LOG_ERROR(""Invalid luac file\n"");
return NULL;
}
LuacBinInfo *ret = RZ_NEW0(LuacBinInfo);
if (!ret) {
return NULL;
}
ret->entry_list = rz_list_newf((RzListFree)free_rz_addr);
ret->symbol_list = rz_list_newf((RzListFree)rz_bin_symbol_free);
ret->section_list = rz_list_newf((RzListFree)free_rz_section);
ret->string_list = rz_list_newf((RzListFree)free_rz_string);
if (!(ret->entry_list && ret->symbol_list && ret->section_list && ret->string_list)) {
try_free_empty_list(ret->entry_list);
try_free_empty_list(ret->symbol_list);
try_free_empty_list(ret->section_list);
try_free_empty_list(ret->string_list);
}
_luac_build_info(proto, ret);
ut64 main_entry_offset;
main_entry_offset = proto->code_offset + proto->code_skipped;
luac_add_entry(ret->entry_list, main_entry_offset, RZ_BIN_ENTRY_TYPE_PROGRAM);
return ret;
}","LuacBinInfo *luac_build_info(LuaProto *VAR_0) {
if (!VAR_0) {
RZ_LOG_ERROR(""Invalid luac file\n"");
return NULL;
}
LuacBinInfo *VAR_1 = RZ_NEW0(LuacBinInfo);
if (!VAR_1) {
return NULL;
}
VAR_1->entry_list = rz_list_newf((RzListFree)VAR_2);
VAR_1->symbol_list = rz_list_newf((RzListFree)VAR_3);
VAR_1->section_list = rz_list_newf((RzListFree)VAR_4);
VAR_1->string_list = rz_list_newf((RzListFree)VAR_5);
if (!(VAR_1->entry_list && VAR_1->symbol_list && VAR_1->section_list && VAR_1->string_list)) {
try_free_empty_list(VAR_1->entry_list);
try_free_empty_list(VAR_1->symbol_list);
try_free_empty_list(VAR_1->section_list);
try_free_empty_list(VAR_1->string_list);
}
_luac_build_info(VAR_0, VAR_1);
ut64 VAR_6;
VAR_6 = VAR_0->code_offset + VAR_0->code_skipped;
luac_add_entry(VAR_1->entry_list, VAR_6, VAR_7);
return VAR_1;
}",rizinorg/rizin/05bbd147caccc60162d6fba9baaaf24befa281cd/luac_bin.c/vul/before/0.json,"LuacBinInfo *luac_build_info(LuaProto *proto) {
	if (!proto) {
		RZ_LOG_ERROR(""Invalid luac file\n"");
		return NULL;
	}

	LuacBinInfo *ret = RZ_NEW0(LuacBinInfo);
	if (!ret) {
		return NULL;
	}

	ret->entry_list = rz_list_newf((RzListFree)free_rz_addr);
	ret->symbol_list = rz_list_newf((RzListFree)rz_bin_symbol_free);
	ret->section_list = rz_list_newf((RzListFree)free_rz_section);
	ret->string_list = rz_list_newf((RzListFree)free_rz_string);

	if (!(ret->entry_list && ret->symbol_list && ret->section_list && ret->string_list)) {
		rz_list_free(ret->entry_list);
		rz_list_free(ret->symbol_list);
		rz_list_free(ret->section_list);
		rz_list_free(ret->string_list);
	}

	_luac_build_info(proto, ret);

	// add entry of main
	ut64 main_entry_offset;
	main_entry_offset = proto->code_offset + proto->code_skipped;
	luac_add_entry(ret->entry_list, main_entry_offset, RZ_BIN_ENTRY_TYPE_PROGRAM);

	return ret;
}","LuacBinInfo *luac_build_info(LuaProto *VAR_0) {
	if (!VAR_0) {
		RZ_LOG_ERROR(""Invalid luac file\n"");
		return NULL;
	}

	LuacBinInfo *VAR_1 = RZ_NEW0(LuacBinInfo);
	if (!VAR_1) {
		return NULL;
	}

	VAR_1->entry_list = rz_list_newf((RzListFree)VAR_2);
	VAR_1->symbol_list = rz_list_newf((RzListFree)VAR_3);
	VAR_1->section_list = rz_list_newf((RzListFree)VAR_4);
	VAR_1->string_list = rz_list_newf((RzListFree)VAR_5);

	if (!(VAR_1->entry_list && VAR_1->symbol_list && VAR_1->section_list && VAR_1->string_list)) {
		rz_list_free(VAR_1->entry_list);
		rz_list_free(VAR_1->symbol_list);
		rz_list_free(VAR_1->section_list);
		rz_list_free(VAR_1->string_list);
	}

	_luac_build_info(VAR_0, VAR_1);

	/* COMMENT_0 */
	ut64 VAR_6;
	VAR_6 = VAR_0->code_offset + VAR_0->code_skipped;
	luac_add_entry(VAR_1->entry_list, VAR_6, VAR_7);

	return VAR_1;
}",rizinorg/rizin/05bbd147caccc60162d6fba9baaaf24befa281cd/luac_bin.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -15,10 +15,10 @@
 	ret->string_list = rz_list_newf((RzListFree)free_rz_string);
 
 	if (!(ret->entry_list && ret->symbol_list && ret->section_list && ret->string_list)) {
-		try_free_empty_list(ret->entry_list);
-		try_free_empty_list(ret->symbol_list);
-		try_free_empty_list(ret->section_list);
-		try_free_empty_list(ret->string_list);
+		rz_list_free(ret->entry_list);
+		rz_list_free(ret->symbol_list);
+		rz_list_free(ret->section_list);
+		rz_list_free(ret->string_list);
 	}
 
 	_luac_build_info(proto, ret);","{'deleted_lines': ['\t\ttry_free_empty_list(ret->entry_list);', '\t\ttry_free_empty_list(ret->symbol_list);', '\t\ttry_free_empty_list(ret->section_list);', '\t\ttry_free_empty_list(ret->string_list);'], 'added_lines': ['\t\trz_list_free(ret->entry_list);', '\t\trz_list_free(ret->symbol_list);', '\t\trz_list_free(ret->section_list);', '\t\trz_list_free(ret->string_list);']}",True,"Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from Luac files. A user opening a malicious Luac file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commits 07b43bc8aa1ffebd9b68d60624c9610cf7e460c7 and 05bbd147caccc60162d6fba9baaaf24befa281cd contain fixes for the issue.",7.8,HIGH,2,test,2022-08-17T12:29:37Z,4
CVE-2022-36044,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,rizinorg/rizin,Fix oob read on _luac_build_info and luac memleaks,05bbd147caccc60162d6fba9baaaf24befa281cd,https://github.com/rizinorg/rizin/commit/05bbd147caccc60162d6fba9baaaf24befa281cd,librz/bin/p/bin_luac.c,symbols,"static RzList *symbols(RzBinFile *bf) {
if (!bf) {
return NULL;
}
LuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf);
if (!bin_info_obj) {
return NULL;
}
return bin_info_obj->symbol_list;
}","static RzList *symbols(RzBinFile *VAR_0) {
if (!VAR_0) {
return NULL;
}
LuacBinInfo *VAR_1 = GET_INTERNAL_BIN_INFO_OBJ(VAR_0);
if (!VAR_1) {
return NULL;
}
return VAR_1->symbol_list;
}",rizinorg/rizin/05bbd147caccc60162d6fba9baaaf24befa281cd/bin_luac.c/vul/before/0.json,"static RzList *symbols(RzBinFile *bf) {
	if (!bf) {
		return NULL;
	}
	LuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf);
	if (!bin_info_obj) {
		return NULL;
	}

	return rz_list_clone(bin_info_obj->symbol_list);
}","static RzList *symbols(RzBinFile *VAR_0) {
	if (!VAR_0) {
		return NULL;
	}
	LuacBinInfo *VAR_1 = GET_INTERNAL_BIN_INFO_OBJ(VAR_0);
	if (!VAR_1) {
		return NULL;
	}

	return rz_list_clone(VAR_1->symbol_list);
}",rizinorg/rizin/05bbd147caccc60162d6fba9baaaf24befa281cd/bin_luac.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,5 +7,5 @@
 		return NULL;
 	}
 
-	return bin_info_obj->symbol_list;
+	return rz_list_clone(bin_info_obj->symbol_list);
 }","{'deleted_lines': ['\treturn bin_info_obj->symbol_list;'], 'added_lines': ['\treturn rz_list_clone(bin_info_obj->symbol_list);']}",True,"Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from Luac files. A user opening a malicious Luac file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commits 07b43bc8aa1ffebd9b68d60624c9610cf7e460c7 and 05bbd147caccc60162d6fba9baaaf24befa281cd contain fixes for the issue.",7.8,HIGH,2,test,2022-08-17T12:29:37Z,4
CVE-2022-36042,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,rizinorg/rizin,"Fix oob write in dyldcache

When the individual n_slide_infos were too high, the sum would overflow
and too few entries would be allocated.",556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810,https://github.com/rizinorg/rizin/commit/556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810,librz/bin/format/mach0/dyldcache.c,get_rebase_infos,"static RzDyldRebaseInfos *get_rebase_infos(RzDyldCache *cache) {
RzDyldRebaseInfos *result = RZ_NEW0(RzDyldRebaseInfos);
if (!result) {
return NULL;
}
if (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize) {
ut32 total_slide_infos = 0;
ut32 n_slide_infos[MAX_N_HDR];
ut32 i;
for (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {
ut64 hdr_offset = cache->hdr_offset[i];
if (!rz_buf_read_le32_at(cache->buf, 0x13c + hdr_offset, &n_slide_infos[i])) {
goto beach;
}
total_slide_infos += n_slide_infos[i];
}
if (!total_slide_infos) {
goto beach;
}
RzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, total_slide_infos);
if (!infos) {
goto beach;
}
ut32 k = 0;
for (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {
ut64 hdr_offset = cache->hdr_offset[i];
if (!n_slide_infos[i]) {
continue;
}
ut32 sio;
if (!rz_buf_read_le32_at(cache->buf, 0x138 + hdr_offset, &sio)) {
continue;
}
ut64 slide_infos_offset = sio;
if (!slide_infos_offset) {
continue;
}
slide_infos_offset += hdr_offset;
ut32 j;
RzDyldRebaseInfo *prev_info = NULL;
for (j = 0; j < n_slide_infos[i]; j++) {
ut64 offset = slide_infos_offset + j * sizeof(cache_mapping_slide);
cache_mapping_slide entry;
if (rz_buf_fread_at(cache->buf, offset, (ut8 *)&entry, ""6lii"", 1) != sizeof(cache_mapping_slide)) {
break;
}
if (entry.slideInfoOffset && entry.slideInfoSize) {
infos[k].start = entry.fileOffset + hdr_offset;
infos[k].end = infos[k].start + entry.size;
ut64 slide = prev_info ? prev_info->slide : UT64_MAX;
infos[k].info = get_rebase_info(cache, entry.slideInfoOffset + hdr_offset, entry.slideInfoSize, entry.fileOffset + hdr_offset, slide);
prev_info = infos[k].info;
k++;
}
}
}
if (!k) {
free(infos);
goto beach;
}
if (k < total_slide_infos) {
RzDyldRebaseInfosEntry *pruned_infos = RZ_NEWS0(RzDyldRebaseInfosEntry, k);
if (!pruned_infos) {
free(infos);
goto beach;
}
memcpy(pruned_infos, infos, sizeof(RzDyldRebaseInfosEntry) * k);
free(infos);
infos = pruned_infos;
}
result->entries = infos;
result->length = k;
return result;
}
if (cache->hdr->mappingCount > 1) {
RzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, 1);
if (!infos) {
goto beach;
}
infos[0].start = cache->maps[1].fileOffset;
infos[0].end = infos[0].start + cache->maps[1].size;
infos[0].info = get_rebase_info(cache, cache->hdr->slideInfoOffset, cache->hdr->slideInfoSize, infos[0].start, UT64_MAX);
result->entries = infos;
result->length = 1;
return result;
}
beach:
free(result);
return NULL;
}","static RzDyldRebaseInfos *get_rebase_infos(RzDyldCache *VAR_0) {
RzDyldRebaseInfos *VAR_1 = RZ_NEW0(RzDyldRebaseInfos);
if (!VAR_1) {
return NULL;
}
if (!VAR_0->hdr->slideInfoOffset || !VAR_0->hdr->slideInfoSize) {
ut32 VAR_2 = 0;
ut32 VAR_3[VAR_4];
ut32 VAR_5;
for (VAR_5 = 0; VAR_5 < VAR_0->n_hdr && VAR_5 < VAR_4; VAR_5++) {
ut64 VAR_6 = VAR_0->hdr_offset[VAR_5];
if (!rz_buf_read_le32_at(VAR_0->buf, 0x13c + VAR_6, &VAR_3[VAR_5])) {
goto beach;
}
VAR_2 += VAR_3[VAR_5];
}
if (!VAR_2) {
goto beach;
}
RzDyldRebaseInfosEntry *VAR_7 = RZ_NEWS0(RzDyldRebaseInfosEntry, VAR_2);
if (!VAR_7) {
goto beach;
}
ut32 VAR_8 = 0;
for (VAR_5 = 0; VAR_5 < VAR_0->n_hdr && VAR_5 < VAR_4; VAR_5++) {
ut64 VAR_6 = VAR_0->hdr_offset[VAR_5];
if (!VAR_3[VAR_5]) {
continue;
}
ut32 VAR_9;
if (!rz_buf_read_le32_at(VAR_0->buf, 0x138 + VAR_6, &VAR_9)) {
continue;
}
ut64 VAR_10 = VAR_9;
if (!VAR_10) {
continue;
}
VAR_10 += VAR_6;
ut32 VAR_11;
RzDyldRebaseInfo *VAR_12 = NULL;
for (VAR_11 = 0; VAR_11 < VAR_3[VAR_5]; VAR_11++) {
ut64 VAR_13 = VAR_10 + VAR_11 * sizeof(VAR_14);
cache_mapping_slide VAR_15;
if (rz_buf_fread_at(VAR_0->buf, VAR_13, (ut8 *)&VAR_15, ""6lii"", 1) != sizeof(cache_mapping_slide)) {
break;
}
if (VAR_15.slideInfoOffset && VAR_15.slideInfoSize) {
VAR_7[VAR_8].start = VAR_15.fileOffset + VAR_6;
VAR_7[VAR_8].end = VAR_7[VAR_8].start + VAR_15.size;
ut64 VAR_16 = VAR_12 ? VAR_12->slide : VAR_17;
VAR_7[VAR_8].info = get_rebase_info(VAR_0, VAR_15.slideInfoOffset + VAR_6, VAR_15.slideInfoSize, VAR_15.fileOffset + VAR_6, VAR_16);
VAR_12 = VAR_7[VAR_8].info;
VAR_8++;
}
}
}
if (!VAR_8) {
free(VAR_7);
goto beach;
}
if (VAR_8 < VAR_2) {
RzDyldRebaseInfosEntry *VAR_18 = RZ_NEWS0(RzDyldRebaseInfosEntry, VAR_8);
if (!VAR_18) {
free(VAR_7);
goto beach;
}
memcpy(VAR_18, VAR_7, sizeof(RzDyldRebaseInfosEntry) * VAR_8);
free(VAR_7);
VAR_7 = VAR_18;
}
VAR_1->entries = VAR_7;
VAR_1->length = VAR_8;
return VAR_1;
}
if (VAR_0->hdr->mappingCount > 1) {
RzDyldRebaseInfosEntry *VAR_7 = RZ_NEWS0(RzDyldRebaseInfosEntry, 1);
if (!VAR_7) {
goto beach;
}
VAR_7[0].start = VAR_0->maps[1].fileOffset;
VAR_7[0].end = VAR_7[0].start + VAR_0->maps[1].size;
VAR_7[0].info = get_rebase_info(VAR_0, VAR_0->hdr->slideInfoOffset, VAR_0->hdr->slideInfoSize, VAR_7[0].start, VAR_17);
VAR_1->entries = VAR_7;
VAR_1->length = 1;
return VAR_1;
}
beach:
free(VAR_1);
return NULL;
}",rizinorg/rizin/556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810/dyldcache.c/vul/before/0.json,"static RzDyldRebaseInfos *get_rebase_infos(RzDyldCache *cache) {
	RzDyldRebaseInfos *result = RZ_NEW0(RzDyldRebaseInfos);
	if (!result) {
		return NULL;
	}

	if (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize) {
		size_t total_slide_infos = 0;
		ut32 n_slide_infos[MAX_N_HDR];

		ut32 i;
		for (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {
			ut64 hdr_offset = cache->hdr_offset[i];
			if (!rz_buf_read_le32_at(cache->buf, 0x13c + hdr_offset, &n_slide_infos[i])) {
				goto beach;
			}
			ut32 total = total_slide_infos + n_slide_infos[i];
			if (total < total_slide_infos) {
				// overflow
				goto beach;
			}
			total_slide_infos = total;
		}

		if (!total_slide_infos) {
			goto beach;
		}

		RzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, total_slide_infos);
		if (!infos) {
			goto beach;
		}

		ut32 k = 0;
		for (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {
			ut64 hdr_offset = cache->hdr_offset[i];
			if (!n_slide_infos[i]) {
				continue;
			}
			ut32 sio;
			if (!rz_buf_read_le32_at(cache->buf, 0x138 + hdr_offset, &sio)) {
				continue;
			}
			ut64 slide_infos_offset = sio;
			if (!slide_infos_offset) {
				continue;
			}
			slide_infos_offset += hdr_offset;

			ut32 j;
			RzDyldRebaseInfo *prev_info = NULL;
			for (j = 0; j < n_slide_infos[i]; j++) {
				ut64 offset = slide_infos_offset + j * sizeof(cache_mapping_slide);
				cache_mapping_slide entry;
				if (rz_buf_fread_at(cache->buf, offset, (ut8 *)&entry, ""6lii"", 1) != sizeof(cache_mapping_slide)) {
					break;
				}

				if (entry.slideInfoOffset && entry.slideInfoSize) {
					infos[k].start = entry.fileOffset + hdr_offset;
					infos[k].end = infos[k].start + entry.size;
					ut64 slide = prev_info ? prev_info->slide : UT64_MAX;
					infos[k].info = get_rebase_info(cache, entry.slideInfoOffset + hdr_offset, entry.slideInfoSize, entry.fileOffset + hdr_offset, slide);
					prev_info = infos[k].info;
					k++;
				}
			}
		}

		if (!k) {
			free(infos);
			goto beach;
		}

		if (k < total_slide_infos) {
			RzDyldRebaseInfosEntry *pruned_infos = RZ_NEWS0(RzDyldRebaseInfosEntry, k);
			if (!pruned_infos) {
				free(infos);
				goto beach;
			}

			memcpy(pruned_infos, infos, sizeof(RzDyldRebaseInfosEntry) * k);
			free(infos);
			infos = pruned_infos;
		}

		result->entries = infos;
		result->length = k;
		return result;
	}

	if (cache->hdr->mappingCount > 1) {
		RzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, 1);
		if (!infos) {
			goto beach;
		}

		infos[0].start = cache->maps[1].fileOffset;
		infos[0].end = infos[0].start + cache->maps[1].size;
		infos[0].info = get_rebase_info(cache, cache->hdr->slideInfoOffset, cache->hdr->slideInfoSize, infos[0].start, UT64_MAX);

		result->entries = infos;
		result->length = 1;
		return result;
	}

beach:
	free(result);
	return NULL;
}","static RzDyldRebaseInfos *get_rebase_infos(RzDyldCache *VAR_0) {
	RzDyldRebaseInfos *VAR_1 = RZ_NEW0(RzDyldRebaseInfos);
	if (!VAR_1) {
		return NULL;
	}

	if (!VAR_0->hdr->slideInfoOffset || !VAR_0->hdr->slideInfoSize) {
		size_t VAR_2 = 0;
		ut32 VAR_3[VAR_4];

		ut32 VAR_5;
		for (VAR_5 = 0; VAR_5 < VAR_0->n_hdr && VAR_5 < VAR_4; VAR_5++) {
			ut64 VAR_6 = VAR_0->hdr_offset[VAR_5];
			if (!rz_buf_read_le32_at(VAR_0->buf, 0x13c + VAR_6, &VAR_3[VAR_5])) {
				goto beach;
			}
			ut32 VAR_7 = VAR_2 + VAR_3[VAR_5];
			if (VAR_7 < VAR_2) {
				/* COMMENT_0 */
				goto beach;
			}
			VAR_2 = VAR_7;
		}

		if (!VAR_2) {
			goto beach;
		}

		RzDyldRebaseInfosEntry *VAR_8 = RZ_NEWS0(RzDyldRebaseInfosEntry, VAR_2);
		if (!VAR_8) {
			goto beach;
		}

		ut32 VAR_9 = 0;
		for (VAR_5 = 0; VAR_5 < VAR_0->n_hdr && VAR_5 < VAR_4; VAR_5++) {
			ut64 VAR_6 = VAR_0->hdr_offset[VAR_5];
			if (!VAR_3[VAR_5]) {
				continue;
			}
			ut32 VAR_10;
			if (!rz_buf_read_le32_at(VAR_0->buf, 0x138 + VAR_6, &VAR_10)) {
				continue;
			}
			ut64 VAR_11 = VAR_10;
			if (!VAR_11) {
				continue;
			}
			VAR_11 += VAR_6;

			ut32 VAR_12;
			RzDyldRebaseInfo *VAR_13 = NULL;
			for (VAR_12 = 0; VAR_12 < VAR_3[VAR_5]; VAR_12++) {
				ut64 VAR_14 = VAR_11 + VAR_12 * sizeof(VAR_15);
				cache_mapping_slide VAR_16;
				if (rz_buf_fread_at(VAR_0->buf, VAR_14, (ut8 *)&VAR_16, ""6lii"", 1) != sizeof(cache_mapping_slide)) {
					break;
				}

				if (VAR_16.slideInfoOffset && VAR_16.slideInfoSize) {
					VAR_8[VAR_9].start = VAR_16.fileOffset + VAR_6;
					VAR_8[VAR_9].end = VAR_8[VAR_9].start + VAR_16.size;
					ut64 VAR_17 = VAR_13 ? VAR_13->slide : VAR_18;
					VAR_8[VAR_9].info = get_rebase_info(VAR_0, VAR_16.slideInfoOffset + VAR_6, VAR_16.slideInfoSize, VAR_16.fileOffset + VAR_6, VAR_17);
					VAR_13 = VAR_8[VAR_9].info;
					VAR_9++;
				}
			}
		}

		if (!VAR_9) {
			free(VAR_8);
			goto beach;
		}

		if (VAR_9 < VAR_2) {
			RzDyldRebaseInfosEntry *VAR_19 = RZ_NEWS0(RzDyldRebaseInfosEntry, VAR_9);
			if (!VAR_19) {
				free(VAR_8);
				goto beach;
			}

			memcpy(VAR_19, VAR_8, sizeof(RzDyldRebaseInfosEntry) * VAR_9);
			free(VAR_8);
			VAR_8 = VAR_19;
		}

		VAR_1->entries = VAR_8;
		VAR_1->length = VAR_9;
		return VAR_1;
	}

	if (VAR_0->hdr->mappingCount > 1) {
		RzDyldRebaseInfosEntry *VAR_8 = RZ_NEWS0(RzDyldRebaseInfosEntry, 1);
		if (!VAR_8) {
			goto beach;
		}

		VAR_8[0].start = VAR_0->maps[1].fileOffset;
		VAR_8[0].end = VAR_8[0].start + VAR_0->maps[1].size;
		VAR_8[0].info = get_rebase_info(VAR_0, VAR_0->hdr->slideInfoOffset, VAR_0->hdr->slideInfoSize, VAR_8[0].start, VAR_18);

		VAR_1->entries = VAR_8;
		VAR_1->length = 1;
		return VAR_1;
	}

beach:
	free(VAR_1);
	return NULL;
}",rizinorg/rizin/556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810/dyldcache.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
 	}
 
 	if (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize) {
-		ut32 total_slide_infos = 0;
+		size_t total_slide_infos = 0;
 		ut32 n_slide_infos[MAX_N_HDR];
 
 		ut32 i;
@@ -14,7 +14,12 @@
 			if (!rz_buf_read_le32_at(cache->buf, 0x13c + hdr_offset, &n_slide_infos[i])) {
 				goto beach;
 			}
-			total_slide_infos += n_slide_infos[i];
+			ut32 total = total_slide_infos + n_slide_infos[i];
+			if (total < total_slide_infos) {
+				// overflow
+				goto beach;
+			}
+			total_slide_infos = total;
 		}
 
 		if (!total_slide_infos) {","{'deleted_lines': ['\t\tut32 total_slide_infos = 0;', '\t\t\ttotal_slide_infos += n_slide_infos[i];'], 'added_lines': ['\t\tsize_t total_slide_infos = 0;', '\t\t\tut32 total = total_slide_infos + n_slide_infos[i];', '\t\t\tif (total < total_slide_infos) {', '\t\t\t\t// overflow', '\t\t\t\tgoto beach;', '\t\t\t}', '\t\t\ttotal_slide_infos = total;']}",True,"Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from dyld cache files. A user opening a malicious dyld cache file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commit number 556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810 contains a patch.",7.8,HIGH,2,test,2022-08-17T14:53:02Z,4
CVE-2022-36044,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,rizinorg/rizin,fix oob read on luac,07b43bc8aa1ffebd9b68d60624c9610cf7e460c7,https://github.com/rizinorg/rizin/commit/07b43bc8aa1ffebd9b68d60624c9610cf7e460c7,librz/bin/format/luac/luac_bin.c,_luac_build_info,"void _luac_build_info(LuaProto *proto, LuacBinInfo *info) {
char *section_name;
char *symbol_name;
char *proto_name;
char **upvalue_names = NULL;
RzListIter *iter;
int i = 0; 
ut64 current_offset;
ut64 current_size;
if (proto->name_size == 0 || proto->proto_name == NULL) {
proto_name = rz_str_newf(""fcn.%08llx"", proto->offset);
} else {
proto_name = rz_str_new((char *)proto->proto_name);
}
current_offset = proto->offset;
current_size = proto->size;
section_name = rz_str_newf(""%s.header"", proto_name);
luac_add_section(info->section_list, section_name, current_offset, current_size, false);
RZ_FREE(section_name);
current_offset = proto->code_offset;
current_size = proto->code_size;
section_name = rz_str_newf(""%s.code"", proto_name);
luac_add_section(info->section_list, section_name, current_offset, current_size, true);
RZ_FREE(section_name);
current_offset = proto->const_offset;
current_size = proto->const_size;
section_name = rz_str_newf(""%s.const"", proto_name);
luac_add_section(info->section_list, section_name, current_offset, current_size, false);
RZ_FREE(section_name);
current_offset = proto->upvalue_offset;
current_size = proto->upvalue_size;
section_name = rz_str_newf(""%s.upvalues"", proto_name);
luac_add_section(info->section_list, section_name, current_offset, current_size, false);
RZ_FREE(section_name);
current_offset = proto->inner_proto_offset;
current_size = proto->inner_proto_size;
section_name = rz_str_newf(""%s.protos"", proto_name);
luac_add_section(info->section_list, section_name, current_offset, current_size, false);
RZ_FREE(section_name);
current_offset = proto->debug_offset;
current_size = proto->debug_size;
section_name = rz_str_newf(""%s.debug"", proto_name);
luac_add_section(info->section_list, section_name, current_offset, current_size, false);
RZ_FREE(section_name);
LuaLocalVarEntry *local_var_entry;
rz_list_foreach (proto->local_var_info_entries, iter, local_var_entry) {
luac_add_string(
info->string_list,
(char *)local_var_entry->varname,
local_var_entry->offset,
local_var_entry->varname_len);
}
size_t real_upvalue_cnt = rz_list_length(proto->upvalue_entries);
if (real_upvalue_cnt > 0) {
LuaDbgUpvalueEntry *debug_upv_entry;
upvalue_names = RZ_NEWS0(char *, real_upvalue_cnt);
if (!upvalue_names) {
free(proto_name);
return;
}
i = 0;
rz_list_foreach (proto->dbg_upvalue_entries, iter, debug_upv_entry) {
upvalue_names[i] = (char *)debug_upv_entry->upvalue_name;
luac_add_string(
info->string_list,
upvalue_names[i],
debug_upv_entry->offset,
debug_upv_entry->name_len);
i++;
}
}
LuaConstEntry *const_entry;
rz_list_foreach (proto->const_entries, iter, const_entry) {
symbol_name = get_constant_symbol_name(proto_name, const_entry);
luac_add_symbol(
info->symbol_list,
symbol_name,
const_entry->offset,
const_entry->data_len,
get_tag_string(const_entry->tag));
if (const_entry->tag == LUA_VLNGSTR || const_entry->tag == LUA_VSHRSTR) {
luac_add_string(
info->string_list,
(char *)const_entry->data,
const_entry->offset,
const_entry->data_len);
}
RZ_FREE(symbol_name);
}
LuaUpvalueEntry *upvalue_entry;
i = 0;
rz_list_foreach (proto->upvalue_entries, iter, upvalue_entry) {
symbol_name = get_upvalue_symbol_name(proto_name, upvalue_entry, upvalue_names[i++]);
luac_add_symbol(
info->symbol_list,
symbol_name,
upvalue_entry->offset,
3,
""UPVALUE"");
RZ_FREE(symbol_name);
}
LuaProto *sub_proto;
rz_list_foreach (proto->proto_entries, iter, sub_proto) {
_luac_build_info(sub_proto, info);
}
free(upvalue_names);
free(proto_name);
}","void _luac_build_info(LuaProto *VAR_0, LuacBinInfo *VAR_1) {
char *VAR_2;
char *VAR_3;
char *VAR_4;
char **VAR_5 = NULL;
RzListIter *VAR_6;
int VAR_7 = 0; 
ut64 VAR_8;
ut64 VAR_9;
if (VAR_0->name_size == 0 || VAR_0->proto_name == NULL) {
VAR_4 = rz_str_newf(""fcn.%08llx"", VAR_0->offset);
} else {
VAR_4 = rz_str_new((char *)VAR_0->proto_name);
}
VAR_8 = VAR_0->offset;
VAR_9 = VAR_0->size;
VAR_2 = rz_str_newf(""%s.header"", VAR_4);
luac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);
RZ_FREE(VAR_2);
VAR_8 = VAR_0->code_offset;
VAR_9 = VAR_0->code_size;
VAR_2 = rz_str_newf(""%s.code"", VAR_4);
luac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, true);
RZ_FREE(VAR_2);
VAR_8 = VAR_0->const_offset;
VAR_9 = VAR_0->const_size;
VAR_2 = rz_str_newf(""%s.const"", VAR_4);
luac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);
RZ_FREE(VAR_2);
VAR_8 = VAR_0->upvalue_offset;
VAR_9 = VAR_0->upvalue_size;
VAR_2 = rz_str_newf(""%s.upvalues"", VAR_4);
luac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);
RZ_FREE(VAR_2);
VAR_8 = VAR_0->inner_proto_offset;
VAR_9 = VAR_0->inner_proto_size;
VAR_2 = rz_str_newf(""%s.protos"", VAR_4);
luac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);
RZ_FREE(VAR_2);
VAR_8 = VAR_0->debug_offset;
VAR_9 = VAR_0->debug_size;
VAR_2 = rz_str_newf(""%s.debug"", VAR_4);
luac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);
RZ_FREE(VAR_2);
LuaLocalVarEntry *VAR_10;
rz_list_foreach (VAR_0->local_var_info_entries, VAR_6, VAR_10) {
luac_add_string(
VAR_1->string_list,
(char *)VAR_10->varname,
VAR_10->offset,
VAR_10->varname_len);
}
size_t VAR_11 = rz_list_length(VAR_0->upvalue_entries);
if (VAR_11 > 0) {
LuaDbgUpvalueEntry *VAR_12;
VAR_5 = RZ_NEWS0(char *, VAR_11);
if (!VAR_5) {
free(VAR_4);
return;
}
VAR_7 = 0;
rz_list_foreach (VAR_0->dbg_upvalue_entries, VAR_6, VAR_12) {
VAR_5[VAR_7] = (char *)VAR_12->upvalue_name;
luac_add_string(
VAR_1->string_list,
VAR_5[VAR_7],
VAR_12->offset,
VAR_12->name_len);
VAR_7++;
}
}
LuaConstEntry *VAR_13;
rz_list_foreach (VAR_0->const_entries, VAR_6, VAR_13) {
VAR_3 = get_constant_symbol_name(VAR_4, VAR_13);
luac_add_symbol(
VAR_1->symbol_list,
VAR_3,
VAR_13->offset,
VAR_13->data_len,
get_tag_string(VAR_13->tag));
if (VAR_13->tag == VAR_14 || VAR_13->tag == VAR_15) {
luac_add_string(
VAR_1->string_list,
(char *)VAR_13->data,
VAR_13->offset,
VAR_13->data_len);
}
RZ_FREE(VAR_3);
}
LuaUpvalueEntry *VAR_16;
VAR_7 = 0;
rz_list_foreach (VAR_0->upvalue_entries, VAR_6, VAR_16) {
VAR_3 = get_upvalue_symbol_name(VAR_4, VAR_16, VAR_5[VAR_7++]);
luac_add_symbol(
VAR_1->symbol_list,
VAR_3,
VAR_16->offset,
3,
""UPVALUE"");
RZ_FREE(VAR_3);
}
LuaProto *VAR_17;
rz_list_foreach (VAR_0->proto_entries, VAR_6, VAR_17) {
_luac_build_info(VAR_17, VAR_1);
}
free(VAR_5);
free(VAR_4);
}",rizinorg/rizin/07b43bc8aa1ffebd9b68d60624c9610cf7e460c7/luac_bin.c/vul/before/0.json,"void _luac_build_info(LuaProto *proto, LuacBinInfo *info) {
	/* process proto header info */
	char *section_name;
	char *symbol_name;
	char *proto_name;
	char **upvalue_names = NULL;
	RzListIter *iter;
	int i = 0; // iter

	ut64 current_offset;
	ut64 current_size;

	// 0. check if stripped (proto name is lost)
	if (proto->name_size == 0 || proto->proto_name == NULL) {
		// replace name with current offset
		proto_name = rz_str_newf(""fcn.%08llx"", proto->offset);
	} else {
		proto_name = rz_str_new((char *)proto->proto_name);
	}

	// 1.1 set section name as function_name.header
	current_offset = proto->offset;
	current_size = proto->size;
	section_name = rz_str_newf(""%s.header"", proto_name);
	luac_add_section(info->section_list, section_name, current_offset, current_size, false);
	RZ_FREE(section_name);

	// 1.2 set section name as function_name.code
	current_offset = proto->code_offset;
	current_size = proto->code_size;
	section_name = rz_str_newf(""%s.code"", proto_name);
	luac_add_section(info->section_list, section_name, current_offset, current_size, true);
	RZ_FREE(section_name);

	// 1.3 set const section
	current_offset = proto->const_offset;
	current_size = proto->const_size;
	section_name = rz_str_newf(""%s.const"", proto_name);
	luac_add_section(info->section_list, section_name, current_offset, current_size, false);
	RZ_FREE(section_name);

	// 1.4 upvalue section
	current_offset = proto->upvalue_offset;
	current_size = proto->upvalue_size;
	section_name = rz_str_newf(""%s.upvalues"", proto_name);
	luac_add_section(info->section_list, section_name, current_offset, current_size, false);
	RZ_FREE(section_name);

	// 1.5 inner protos section
	current_offset = proto->inner_proto_offset;
	current_size = proto->inner_proto_size;
	section_name = rz_str_newf(""%s.protos"", proto_name);
	luac_add_section(info->section_list, section_name, current_offset, current_size, false);
	RZ_FREE(section_name);

	// 1.6 debug section
	current_offset = proto->debug_offset;
	current_size = proto->debug_size;
	section_name = rz_str_newf(""%s.debug"", proto_name);
	luac_add_section(info->section_list, section_name, current_offset, current_size, false);
	RZ_FREE(section_name);

	// 2.1 parse local var info
	LuaLocalVarEntry *local_var_entry;
	rz_list_foreach (proto->local_var_info_entries, iter, local_var_entry) {
		luac_add_string(
			info->string_list,
			(char *)local_var_entry->varname,
			local_var_entry->offset,
			local_var_entry->varname_len);
	}

	// 2.2 parse debug_upvalues
	size_t real_upvalue_cnt = RZ_MAX(rz_list_length(proto->upvalue_entries), rz_list_length(proto->dbg_upvalue_entries));
	if (real_upvalue_cnt > 0) {
		LuaDbgUpvalueEntry *debug_upv_entry;
		upvalue_names = RZ_NEWS0(char *, real_upvalue_cnt);
		if (!upvalue_names) {
			free(proto_name);
			return;
		}

		i = 0;
		rz_list_foreach (proto->dbg_upvalue_entries, iter, debug_upv_entry) {
			upvalue_names[i] = (char *)debug_upv_entry->upvalue_name;
			luac_add_string(
				info->string_list,
				upvalue_names[i],
				debug_upv_entry->offset,
				debug_upv_entry->name_len);
			i++;
		}
	}

	// 3.1 construct constant symbols
	LuaConstEntry *const_entry;
	rz_list_foreach (proto->const_entries, iter, const_entry) {
		symbol_name = get_constant_symbol_name(proto_name, const_entry);
		if (!symbol_name) {
			continue;
		}
		luac_add_symbol(
			info->symbol_list,
			symbol_name,
			const_entry->offset,
			const_entry->data_len,
			get_tag_string(const_entry->tag));
		if (const_entry->tag == LUA_VLNGSTR || const_entry->tag == LUA_VSHRSTR) {
			luac_add_string(
				info->string_list,
				(char *)const_entry->data,
				const_entry->offset,
				const_entry->data_len);
		}
		RZ_FREE(symbol_name);
	}

	// 3.2 construct upvalue symbols
	LuaUpvalueEntry *upvalue_entry;
	i = 0;
	rz_list_foreach (proto->upvalue_entries, iter, upvalue_entry) {
		symbol_name = get_upvalue_symbol_name(proto_name, upvalue_entry, upvalue_names[i++]);
		luac_add_symbol(
			info->symbol_list,
			symbol_name,
			upvalue_entry->offset,
			3,
			""UPVALUE"");
		RZ_FREE(symbol_name);
	}

	// 4. parse sub proto
	LuaProto *sub_proto;
	rz_list_foreach (proto->proto_entries, iter, sub_proto) {
		_luac_build_info(sub_proto, info);
	}

	free(upvalue_names);
	free(proto_name);
}","void _luac_build_info(LuaProto *VAR_0, LuacBinInfo *VAR_1) {
	/* COMMENT_0 */
	char *VAR_2;
	char *VAR_3;
	char *VAR_4;
	char **VAR_5 = NULL;
	RzListIter *VAR_6;
	int VAR_7 = 0; /* COMMENT_1 */

	ut64 VAR_8;
	ut64 VAR_9;

	/* COMMENT_2 */
	if (VAR_0->name_size == 0 || VAR_0->proto_name == NULL) {
		/* COMMENT_3 */
		VAR_4 = rz_str_newf(""fcn.%08llx"", VAR_0->offset);
	} else {
		VAR_4 = rz_str_new((char *)VAR_0->proto_name);
	}

	/* COMMENT_4 */
	VAR_8 = VAR_0->offset;
	VAR_9 = VAR_0->size;
	VAR_2 = rz_str_newf(""%s.header"", VAR_4);
	luac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);
	RZ_FREE(VAR_2);

	/* COMMENT_5 */
	VAR_8 = VAR_0->code_offset;
	VAR_9 = VAR_0->code_size;
	VAR_2 = rz_str_newf(""%s.code"", VAR_4);
	luac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, true);
	RZ_FREE(VAR_2);

	/* COMMENT_6 */
	VAR_8 = VAR_0->const_offset;
	VAR_9 = VAR_0->const_size;
	VAR_2 = rz_str_newf(""%s.const"", VAR_4);
	luac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);
	RZ_FREE(VAR_2);

	/* COMMENT_7 */
	VAR_8 = VAR_0->upvalue_offset;
	VAR_9 = VAR_0->upvalue_size;
	VAR_2 = rz_str_newf(""%s.upvalues"", VAR_4);
	luac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);
	RZ_FREE(VAR_2);

	/* COMMENT_8 */
	VAR_8 = VAR_0->inner_proto_offset;
	VAR_9 = VAR_0->inner_proto_size;
	VAR_2 = rz_str_newf(""%s.protos"", VAR_4);
	luac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);
	RZ_FREE(VAR_2);

	/* COMMENT_9 */
	VAR_8 = VAR_0->debug_offset;
	VAR_9 = VAR_0->debug_size;
	VAR_2 = rz_str_newf(""%s.debug"", VAR_4);
	luac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);
	RZ_FREE(VAR_2);

	/* COMMENT_10 */
	LuaLocalVarEntry *VAR_10;
	rz_list_foreach (VAR_0->local_var_info_entries, VAR_6, VAR_10) {
		luac_add_string(
			VAR_1->string_list,
			(char *)VAR_10->varname,
			VAR_10->offset,
			VAR_10->varname_len);
	}

	/* COMMENT_11 */
	size_t VAR_11 = RZ_MAX(rz_list_length(VAR_0->upvalue_entries), rz_list_length(VAR_0->dbg_upvalue_entries));
	if (VAR_11 > 0) {
		LuaDbgUpvalueEntry *VAR_12;
		VAR_5 = RZ_NEWS0(char *, VAR_11);
		if (!VAR_5) {
			free(VAR_4);
			return;
		}

		VAR_7 = 0;
		rz_list_foreach (VAR_0->dbg_upvalue_entries, VAR_6, VAR_12) {
			VAR_5[VAR_7] = (char *)VAR_12->upvalue_name;
			luac_add_string(
				VAR_1->string_list,
				VAR_5[VAR_7],
				VAR_12->offset,
				VAR_12->name_len);
			VAR_7++;
		}
	}

	/* COMMENT_12 */
	LuaConstEntry *VAR_13;
	rz_list_foreach (VAR_0->const_entries, VAR_6, VAR_13) {
		VAR_3 = get_constant_symbol_name(VAR_4, VAR_13);
		if (!VAR_3) {
			continue;
		}
		luac_add_symbol(
			VAR_1->symbol_list,
			VAR_3,
			VAR_13->offset,
			VAR_13->data_len,
			get_tag_string(VAR_13->tag));
		if (VAR_13->tag == VAR_14 || VAR_13->tag == VAR_15) {
			luac_add_string(
				VAR_1->string_list,
				(char *)VAR_13->data,
				VAR_13->offset,
				VAR_13->data_len);
		}
		RZ_FREE(VAR_3);
	}

	/* COMMENT_13 */
	LuaUpvalueEntry *VAR_16;
	VAR_7 = 0;
	rz_list_foreach (VAR_0->upvalue_entries, VAR_6, VAR_16) {
		VAR_3 = get_upvalue_symbol_name(VAR_4, VAR_16, VAR_5[VAR_7++]);
		luac_add_symbol(
			VAR_1->symbol_list,
			VAR_3,
			VAR_16->offset,
			3,
			""UPVALUE"");
		RZ_FREE(VAR_3);
	}

	/* COMMENT_14 */
	LuaProto *VAR_17;
	rz_list_foreach (VAR_0->proto_entries, VAR_6, VAR_17) {
		_luac_build_info(VAR_17, VAR_1);
	}

	free(VAR_5);
	free(VAR_4);
}",rizinorg/rizin/07b43bc8aa1ffebd9b68d60624c9610cf7e460c7/luac_bin.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -71,7 +71,7 @@
 	}
 
 	// 2.2 parse debug_upvalues
-	size_t real_upvalue_cnt = rz_list_length(proto->upvalue_entries);
+	size_t real_upvalue_cnt = RZ_MAX(rz_list_length(proto->upvalue_entries), rz_list_length(proto->dbg_upvalue_entries));
 	if (real_upvalue_cnt > 0) {
 		LuaDbgUpvalueEntry *debug_upv_entry;
 		upvalue_names = RZ_NEWS0(char *, real_upvalue_cnt);
@@ -96,6 +96,9 @@
 	LuaConstEntry *const_entry;
 	rz_list_foreach (proto->const_entries, iter, const_entry) {
 		symbol_name = get_constant_symbol_name(proto_name, const_entry);
+		if (!symbol_name) {
+			continue;
+		}
 		luac_add_symbol(
 			info->symbol_list,
 			symbol_name,","{'deleted_lines': ['\tsize_t real_upvalue_cnt = rz_list_length(proto->upvalue_entries);'], 'added_lines': ['\tsize_t real_upvalue_cnt = RZ_MAX(rz_list_length(proto->upvalue_entries), rz_list_length(proto->dbg_upvalue_entries));', '\t\tif (!symbol_name) {', '\t\t\tcontinue;', '\t\t}']}",True,"Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from Luac files. A user opening a malicious Luac file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commits 07b43bc8aa1ffebd9b68d60624c9610cf7e460c7 and 05bbd147caccc60162d6fba9baaaf24befa281cd contain fixes for the issue.",7.8,HIGH,2,test,2022-08-19T21:01:10Z,4
CVE-2022-36044,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,rizinorg/rizin,fix oob read on luac,07b43bc8aa1ffebd9b68d60624c9610cf7e460c7,https://github.com/rizinorg/rizin/commit/07b43bc8aa1ffebd9b68d60624c9610cf7e460c7,librz/bin/bobj.c,classes_from_symbols,"static RzList *classes_from_symbols(RzBinFile *bf) {
RzBinSymbol *sym;
RzListIter *iter;
rz_list_foreach (bf->o->symbols, iter, sym) {
if (sym->name[0] != '_') {
continue;
}
const char *cn = sym->classname;
if (cn) {
RzBinClass *c = rz_bin_file_add_class(bf, sym->classname, NULL, 0);
if (!c) {
continue;
}
char *dn = sym->dname;
char *fn = swiftField(dn, cn);
if (fn) {
RzBinField *f = rz_bin_field_new(sym->paddr, sym->vaddr, sym->size, fn, NULL, NULL, false);
rz_list_append(c->fields, f);
free(fn);
} else {
char *mn = strstr(dn, "".."");
if (!mn) {
mn = strstr(dn, cn);
if (mn && mn[strlen(cn)] == '.') {
rz_list_append(c->methods, sym);
}
}
}
}
}
return bf->o->classes;
}","static RzList *classes_from_symbols(RzBinFile *VAR_0) {
RzBinSymbol *VAR_1;
RzListIter *VAR_2;
rz_list_foreach (VAR_0->o->symbols, VAR_2, VAR_1) {
if (VAR_1->name[0] != '_') {
continue;
}
const char *VAR_3 = VAR_1->classname;
if (VAR_3) {
RzBinClass *VAR_4 = rz_bin_file_add_class(VAR_0, VAR_1->classname, NULL, 0);
if (!VAR_4) {
continue;
}
char *VAR_5 = VAR_1->dname;
char *VAR_6 = swiftField(VAR_5, VAR_3);
if (VAR_6) {
RzBinField *VAR_7 = rz_bin_field_new(VAR_1->paddr, VAR_1->vaddr, VAR_1->size, VAR_6, NULL, NULL, false);
rz_list_append(VAR_4->fields, VAR_7);
free(VAR_6);
} else {
char *VAR_8 = strstr(VAR_5, "".."");
if (!VAR_8) {
VAR_8 = strstr(VAR_5, VAR_3);
if (VAR_8 && VAR_8[strlen(VAR_3)] == '.') {
rz_list_append(VAR_4->methods, VAR_1);
}
}
}
}
}
return VAR_0->o->classes;
}",rizinorg/rizin/07b43bc8aa1ffebd9b68d60624c9610cf7e460c7/bobj.c/vul/before/0.json,"static RzList *classes_from_symbols(RzBinFile *bf) {
	RzBinSymbol *sym;
	RzListIter *iter;
	rz_list_foreach (bf->o->symbols, iter, sym) {
		if (!sym->name || sym->name[0] != '_') {
			continue;
		}
		const char *cn = sym->classname;
		if (cn) {
			RzBinClass *c = rz_bin_file_add_class(bf, sym->classname, NULL, 0);
			if (!c) {
				continue;
			}
			// swift specific
			char *dn = sym->dname;
			char *fn = swiftField(dn, cn);
			if (fn) {
				RzBinField *f = rz_bin_field_new(sym->paddr, sym->vaddr, sym->size, fn, NULL, NULL, false);
				rz_list_append(c->fields, f);
				free(fn);
			} else {
				char *mn = strstr(dn, "".."");
				if (!mn) {
					mn = strstr(dn, cn);
					if (mn && mn[strlen(cn)] == '.') {
						rz_list_append(c->methods, sym);
					}
				}
			}
		}
	}
	return bf->o->classes;
}","static RzList *classes_from_symbols(RzBinFile *VAR_0) {
	RzBinSymbol *VAR_1;
	RzListIter *VAR_2;
	rz_list_foreach (VAR_0->o->symbols, VAR_2, VAR_1) {
		if (!VAR_1->name || VAR_1->name[0] != '_') {
			continue;
		}
		const char *VAR_3 = VAR_1->classname;
		if (VAR_3) {
			RzBinClass *VAR_4 = rz_bin_file_add_class(VAR_0, VAR_1->classname, NULL, 0);
			if (!VAR_4) {
				continue;
			}
			/* COMMENT_0 */
			char *VAR_5 = VAR_1->dname;
			char *VAR_6 = swiftField(VAR_5, VAR_3);
			if (VAR_6) {
				RzBinField *VAR_7 = rz_bin_field_new(VAR_1->paddr, VAR_1->vaddr, VAR_1->size, VAR_6, NULL, NULL, false);
				rz_list_append(VAR_4->fields, VAR_7);
				free(VAR_6);
			} else {
				char *VAR_8 = strstr(VAR_5, "".."");
				if (!VAR_8) {
					VAR_8 = strstr(VAR_5, VAR_3);
					if (VAR_8 && VAR_8[strlen(VAR_3)] == '.') {
						rz_list_append(VAR_4->methods, VAR_1);
					}
				}
			}
		}
	}
	return VAR_0->o->classes;
}",rizinorg/rizin/07b43bc8aa1ffebd9b68d60624c9610cf7e460c7/bobj.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 	RzBinSymbol *sym;
 	RzListIter *iter;
 	rz_list_foreach (bf->o->symbols, iter, sym) {
-		if (sym->name[0] != '_') {
+		if (!sym->name || sym->name[0] != '_') {
 			continue;
 		}
 		const char *cn = sym->classname;","{'deleted_lines': [""\t\tif (sym->name[0] != '_') {""], 'added_lines': [""\t\tif (!sym->name || sym->name[0] != '_') {""]}",True,"Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from Luac files. A user opening a malicious Luac file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commits 07b43bc8aa1ffebd9b68d60624c9610cf7e460c7 and 05bbd147caccc60162d6fba9baaaf24befa281cd contain fixes for the issue.",7.8,HIGH,2,test,2022-08-19T21:01:10Z,4
CVE-2022-36040,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,rizinorg/rizin,fix #2963 - oob write (1 byte) in pyc/marshal.c,68948017423a12786704e54227b8b2f918c2fd27,https://github.com/rizinorg/rizin/commit/68948017423a12786704e54227b8b2f918c2fd27,librz/bin/format/pyc/marshal.c,get_complex_object,"static pyc_object *get_complex_object(RzBinPycObj *pyc, RzBuffer *buffer) {
pyc_object *ret = NULL;
bool error = false;
ut32 size = 0;
ut32 n1 = 0;
ut32 n2 = 0;
ret = RZ_NEW0(pyc_object);
if (!ret) {
return NULL;
}
if ((pyc->magic_int & 0xffff) <= 62061) {
n1 = get_ut8(buffer, &error);
} else {
n1 = get_st32(buffer, &error);
}
if (error) {
free(ret);
return NULL;
}
ut8 *s1 = malloc(n1 + 1);
if (!s1) {
return NULL;
}
size = rz_buf_read(buffer, s1, n1);
if (size != n1) {
RZ_FREE(s1);
RZ_FREE(ret);
return NULL;
}
s1[n1] = '\0';
if ((pyc->magic_int & 0xffff) <= 62061) {
n2 = get_ut8(buffer, &error);
} else
n2 = get_st32(buffer, &error);
if (error) {
return NULL;
}
ut8 *s2 = malloc(n2 + 1);
if (!s2) {
return NULL;
}
size = rz_buf_read(buffer, s2, n2);
if (size != n2) {
RZ_FREE(s1);
RZ_FREE(s2);
RZ_FREE(ret);
return NULL;
}
s2[n2] = '\0';
ret->type = TYPE_COMPLEX;
ret->data = rz_str_newf(""%s+%sj"", s1, s2);
RZ_FREE(s1);
RZ_FREE(s2);
if (!ret->data) {
RZ_FREE(ret);
return NULL;
}
return ret;
}","static pyc_object *get_complex_object(RzBinPycObj *VAR_0, RzBuffer *VAR_1) {
pyc_object *VAR_2 = NULL;
bool VAR_3 = false;
ut32 VAR_4 = 0;
ut32 VAR_5 = 0;
ut32 VAR_6 = 0;
VAR_2 = RZ_NEW0(pyc_object);
if (!VAR_2) {
return NULL;
}
if ((VAR_0->magic_int & 0xffff) <= 62061) {
VAR_5 = get_ut8(VAR_1, &VAR_3);
} else {
VAR_5 = get_st32(VAR_1, &VAR_3);
}
if (VAR_3) {
free(VAR_2);
return NULL;
}
ut8 *VAR_7 = malloc(VAR_5 + 1);
if (!VAR_7) {
return NULL;
}
VAR_4 = rz_buf_read(VAR_1, VAR_7, VAR_5);
if (VAR_4 != VAR_5) {
RZ_FREE(VAR_7);
RZ_FREE(VAR_2);
return NULL;
}
VAR_7[VAR_5] = '\0';
if ((VAR_0->magic_int & 0xffff) <= 62061) {
VAR_6 = get_ut8(VAR_1, &VAR_3);
} else
VAR_6 = get_st32(VAR_1, &VAR_3);
if (VAR_3) {
return NULL;
}
ut8 *VAR_8 = malloc(VAR_6 + 1);
if (!VAR_8) {
return NULL;
}
VAR_4 = rz_buf_read(VAR_1, VAR_8, VAR_6);
if (VAR_4 != VAR_6) {
RZ_FREE(VAR_7);
RZ_FREE(VAR_8);
RZ_FREE(VAR_2);
return NULL;
}
VAR_8[VAR_6] = '\0';
VAR_2->type = VAR_9;
VAR_2->data = rz_str_newf(""%s+%sj"", VAR_7, VAR_8);
RZ_FREE(VAR_7);
RZ_FREE(VAR_8);
if (!VAR_2->data) {
RZ_FREE(VAR_2);
return NULL;
}
return VAR_2;
}",rizinorg/rizin/68948017423a12786704e54227b8b2f918c2fd27/marshal.c/vul/before/0.json,"static pyc_object *get_complex_object(RzBinPycObj *pyc, RzBuffer *buffer) {
	pyc_object *ret = NULL;
	bool error = false;
	ut32 n1 = 0;
	ut32 n2 = 0;

	ret = RZ_NEW0(pyc_object);
	if (!ret) {
		return NULL;
	}

	if ((pyc->magic_int & 0xffff) <= 62061) {
		n1 = get_ut8(buffer, &error);
	} else {
		n1 = get_st32(buffer, &error);
	}
	if (error || UT32_ADD_OVFCHK(n1, 1)) {
		free(ret);
		return NULL;
	}
	ut8 *s1 = malloc(n1 + 1);
	if (!s1) {
		return NULL;
	}
	/* object contain string representation of the number */
	if (rz_buf_read(buffer, s1, n1) != n1) {
		RZ_FREE(s1);
		RZ_FREE(ret);
		return NULL;
	}
	s1[n1] = '\0';

	if ((pyc->magic_int & 0xffff) <= 62061) {
		n2 = get_ut8(buffer, &error);
	} else {
		n2 = get_st32(buffer, &error);
	}
	if (error || UT32_ADD_OVFCHK(n2, 1)) {
		return NULL;
	}
	ut8 *s2 = malloc(n2 + 1);
	if (!s2) {
		return NULL;
	}
	/* object contain string representation of the number */
	if (rz_buf_read(buffer, s2, n2) != n2) {
		RZ_FREE(s1);
		RZ_FREE(s2);
		RZ_FREE(ret);
		return NULL;
	}
	s2[n2] = '\0';

	ret->type = TYPE_COMPLEX;
	ret->data = rz_str_newf(""%s+%sj"", s1, s2);
	RZ_FREE(s1);
	RZ_FREE(s2);
	if (!ret->data) {
		RZ_FREE(ret);
		return NULL;
	}
	return ret;
}","static pyc_object *get_complex_object(RzBinPycObj *VAR_0, RzBuffer *VAR_1) {
	pyc_object *VAR_2 = NULL;
	bool VAR_3 = false;
	ut32 VAR_4 = 0;
	ut32 VAR_5 = 0;

	VAR_2 = RZ_NEW0(pyc_object);
	if (!VAR_2) {
		return NULL;
	}

	if ((VAR_0->magic_int & 0xffff) <= 62061) {
		VAR_4 = get_ut8(VAR_1, &VAR_3);
	} else {
		VAR_4 = get_st32(VAR_1, &VAR_3);
	}
	if (VAR_3 || UT32_ADD_OVFCHK(VAR_4, 1)) {
		free(VAR_2);
		return NULL;
	}
	ut8 *VAR_6 = malloc(VAR_4 + 1);
	if (!VAR_6) {
		return NULL;
	}
	/* COMMENT_0 */
	if (rz_buf_read(VAR_1, VAR_6, VAR_4) != VAR_4) {
		RZ_FREE(VAR_6);
		RZ_FREE(VAR_2);
		return NULL;
	}
	VAR_6[VAR_4] = '\0';

	if ((VAR_0->magic_int & 0xffff) <= 62061) {
		VAR_5 = get_ut8(VAR_1, &VAR_3);
	} else {
		VAR_5 = get_st32(VAR_1, &VAR_3);
	}
	if (VAR_3 || UT32_ADD_OVFCHK(VAR_5, 1)) {
		return NULL;
	}
	ut8 *VAR_7 = malloc(VAR_5 + 1);
	if (!VAR_7) {
		return NULL;
	}
	/* COMMENT_0 */
	if (rz_buf_read(VAR_1, VAR_7, VAR_5) != VAR_5) {
		RZ_FREE(VAR_6);
		RZ_FREE(VAR_7);
		RZ_FREE(VAR_2);
		return NULL;
	}
	VAR_7[VAR_5] = '\0';

	VAR_2->type = VAR_8;
	VAR_2->data = rz_str_newf(""%s+%sj"", VAR_6, VAR_7);
	RZ_FREE(VAR_6);
	RZ_FREE(VAR_7);
	if (!VAR_2->data) {
		RZ_FREE(VAR_2);
		return NULL;
	}
	return VAR_2;
}",rizinorg/rizin/68948017423a12786704e54227b8b2f918c2fd27/marshal.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,6 @@
 static pyc_object *get_complex_object(RzBinPycObj *pyc, RzBuffer *buffer) {
 	pyc_object *ret = NULL;
 	bool error = false;
-	ut32 size = 0;
 	ut32 n1 = 0;
 	ut32 n2 = 0;
 
@@ -15,7 +14,7 @@
 	} else {
 		n1 = get_st32(buffer, &error);
 	}
-	if (error) {
+	if (error || UT32_ADD_OVFCHK(n1, 1)) {
 		free(ret);
 		return NULL;
 	}
@@ -24,8 +23,7 @@
 		return NULL;
 	}
 	/* object contain string representation of the number */
-	size = rz_buf_read(buffer, s1, n1);
-	if (size != n1) {
+	if (rz_buf_read(buffer, s1, n1) != n1) {
 		RZ_FREE(s1);
 		RZ_FREE(ret);
 		return NULL;
@@ -34,9 +32,10 @@
 
 	if ((pyc->magic_int & 0xffff) <= 62061) {
 		n2 = get_ut8(buffer, &error);
-	} else
+	} else {
 		n2 = get_st32(buffer, &error);
-	if (error) {
+	}
+	if (error || UT32_ADD_OVFCHK(n2, 1)) {
 		return NULL;
 	}
 	ut8 *s2 = malloc(n2 + 1);
@@ -44,8 +43,7 @@
 		return NULL;
 	}
 	/* object contain string representation of the number */
-	size = rz_buf_read(buffer, s2, n2);
-	if (size != n2) {
+	if (rz_buf_read(buffer, s2, n2) != n2) {
 		RZ_FREE(s1);
 		RZ_FREE(s2);
 		RZ_FREE(ret);","{'deleted_lines': ['\tut32 size = 0;', '\tif (error) {', '\tsize = rz_buf_read(buffer, s1, n1);', '\tif (size != n1) {', '\t} else', '\tif (error) {', '\tsize = rz_buf_read(buffer, s2, n2);', '\tif (size != n2) {'], 'added_lines': ['\tif (error || UT32_ADD_OVFCHK(n1, 1)) {', '\tif (rz_buf_read(buffer, s1, n1) != n1) {', '\t} else {', '\t}', '\tif (error || UT32_ADD_OVFCHK(n2, 1)) {', '\tif (rz_buf_read(buffer, s2, n2) != n2) {']}",True,"Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from PYC(python) files. A user opening a malicious PYC file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commit number 68948017423a12786704e54227b8b2f918c2fd27 contains a patch.",7.8,HIGH,2,test,2022-08-22T17:50:19Z,4
CVE-2022-3016,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,vim,"patch 9.0.0286: using freed memory when location list changed in autocmd

Problem:    Using freed memory when location list changed in autocmd.
Solution:   Return QF_ABORT and handle it. (Yegappan Lakshmanan,
            closes #10993)",6d24a51b94beb1991cddce221f90b455e2d50db7,https://github.com/vim/vim/commit/6d24a51b94beb1991cddce221f90b455e2d50db7,src/quickfix.c,qf_jump_edit_buffer,"static int
qf_jump_edit_buffer(
qf_info_T*qi,
qfline_T*qf_ptr,
intforceit,
intprev_winid,
int*opened_window)
{
qf_list_T*qfl = qf_get_curlist(qi);
intold_changedtick = qfl->qf_changedtick;
qfltype_Tqfl_type = qfl->qfl_type;
intretval = OK;
intold_qf_curlist = qi->qf_curlist;
intsave_qfid = qfl->qf_id;
if (qf_ptr->qf_type == 1)
{
if (!can_abandon(curbuf, forceit))
{
no_write_message();
return FAIL;
}
retval = do_ecmd(qf_ptr->qf_fnum, NULL, NULL, NULL, (linenr_T)1,
ECMD_HIDE + ECMD_SET_HELP,
prev_winid == curwin->w_id ? curwin : NULL);
}
else
retval = buflist_getfile(qf_ptr->qf_fnum,
(linenr_T)1, GETF_SETMARK | GETF_SWITCH, forceit);
if (qfl_type == QFLT_LOCATION)
{
win_T*wp = win_id2wp(prev_winid);
if (wp == NULL && curwin->w_llist != qi)
{
emsg(_(e_current_window_was_closed));
*opened_window = FALSE;
return NOTDONE;
}
}
if (qfl_type == QFLT_QUICKFIX && !qflist_valid(NULL, save_qfid))
{
emsg(_(e_current_quickfix_list_was_changed));
return NOTDONE;
}
if (old_qf_curlist != qi->qf_curlist
|| old_changedtick != qfl->qf_changedtick
|| !is_qf_entry_present(qfl, qf_ptr))
{
if (qfl_type == QFLT_QUICKFIX)
emsg(_(e_current_quickfix_list_was_changed));
else
emsg(_(e_current_location_list_was_changed));
return NOTDONE;
}
return retval;
}","static int
qf_jump_edit_buffer(
qf_info_T*VAR_0,
qfline_T*VAR_1,
intVAR_2,
intVAR_3,
int*VAR_4)
{
qf_list_T*VAR_5 = qf_get_curlist(VAR_0);
intVAR_6 = VAR_5->qf_changedtick;
qfltype_TVAR_7 = VAR_5->qfl_type;
intVAR_8 = VAR_9;
intVAR_10 = VAR_0->qf_curlist;
intVAR_11 = VAR_5->qf_id;
if (VAR_1->qf_type == 1)
{
if (!can_abandon(VAR_12, VAR_2))
{
no_write_message();
return VAR_13;
}
VAR_8 = do_ecmd(VAR_1->qf_fnum, NULL, NULL, NULL, (linenr_T)1,
VAR_14 + VAR_15,
VAR_3 == VAR_16->w_id ? VAR_16 : NULL);
}
else
VAR_8 = buflist_getfile(VAR_1->qf_fnum,
(linenr_T)1, VAR_17 | VAR_18, VAR_2);
if (VAR_7 == VAR_19)
{
win_T*VAR_20 = win_id2wp(VAR_3);
if (VAR_20 == NULL && VAR_16->w_llist != VAR_0)
{
emsg(_(VAR_21));
*VAR_4 = FALSE;
return VAR_22;
}
}
if (VAR_7 == VAR_23 && !qflist_valid(NULL, VAR_11))
{
emsg(_(VAR_24));
return VAR_22;
}
if (VAR_10 != VAR_0->qf_curlist
|| VAR_6 != VAR_5->qf_changedtick
|| !is_qf_entry_present(VAR_5, VAR_1))
{
if (VAR_7 == VAR_23)
emsg(_(VAR_24));
else
emsg(_(VAR_25));
return VAR_22;
}
return VAR_8;
}",vim/6d24a51b94beb1991cddce221f90b455e2d50db7/quickfix.c/vul/before/1.json,"static int
qf_jump_edit_buffer(
	qf_info_T	*qi,
	qfline_T	*qf_ptr,
	int		forceit,
	int		prev_winid,
	int		*opened_window)
{
    qf_list_T	*qfl = qf_get_curlist(qi);
    int		old_changedtick = qfl->qf_changedtick;
    qfltype_T	qfl_type = qfl->qfl_type;
    int		retval = OK;
    int		old_qf_curlist = qi->qf_curlist;
    int		save_qfid = qfl->qf_id;

    if (qf_ptr->qf_type == 1)
    {
	// Open help file (do_ecmd() will set b_help flag, readfile() will
	// set b_p_ro flag).
	if (!can_abandon(curbuf, forceit))
	{
	    no_write_message();
	    return FAIL;
	}

	retval = do_ecmd(qf_ptr->qf_fnum, NULL, NULL, NULL, (linenr_T)1,
		ECMD_HIDE + ECMD_SET_HELP,
		prev_winid == curwin->w_id ? curwin : NULL);
    }
    else
	retval = buflist_getfile(qf_ptr->qf_fnum,
		(linenr_T)1, GETF_SETMARK | GETF_SWITCH, forceit);

    // If a location list, check whether the associated window is still
    // present.
    if (qfl_type == QFLT_LOCATION)
    {
	win_T	*wp = win_id2wp(prev_winid);

	if (wp == NULL && curwin->w_llist != qi)
	{
	    emsg(_(e_current_window_was_closed));
	    *opened_window = FALSE;
	    return QF_ABORT;
	}
    }

    if (qfl_type == QFLT_QUICKFIX && !qflist_valid(NULL, save_qfid))
    {
	emsg(_(e_current_quickfix_list_was_changed));
	return QF_ABORT;
    }

    // Check if the list was changed.  The pointers may happen to be identical,
    // thus also check qf_changedtick.
    if (old_qf_curlist != qi->qf_curlist
	    || old_changedtick != qfl->qf_changedtick
	    || !is_qf_entry_present(qfl, qf_ptr))
    {
	if (qfl_type == QFLT_QUICKFIX)
	    emsg(_(e_current_quickfix_list_was_changed));
	else
	    emsg(_(e_current_location_list_was_changed));
	return QF_ABORT;
    }

    return retval;
}","static int
qf_jump_edit_buffer(
	qf_info_T	*VAR_0,
	qfline_T	*VAR_1,
	int		VAR_2,
	int		VAR_3,
	int		*VAR_4)
{
    qf_list_T	*VAR_5 = qf_get_curlist(VAR_0);
    int		VAR_6 = VAR_5->qf_changedtick;
    qfltype_T	VAR_7 = VAR_5->qfl_type;
    int		VAR_8 = VAR_9;
    int		VAR_10 = VAR_0->qf_curlist;
    int		VAR_11 = VAR_5->qf_id;

    if (VAR_1->qf_type == 1)
    {
	/* COMMENT_0 */
	/* COMMENT_1 */
	if (!can_abandon(VAR_12, VAR_2))
	{
	    no_write_message();
	    return VAR_13;
	}

	VAR_8 = do_ecmd(VAR_1->qf_fnum, NULL, NULL, NULL, (linenr_T)1,
		VAR_14 + VAR_15,
		VAR_3 == VAR_16->w_id ? VAR_16 : NULL);
    }
    else
	VAR_8 = buflist_getfile(VAR_1->qf_fnum,
		(linenr_T)1, VAR_17 | VAR_18, VAR_2);

    /* COMMENT_2 */
    /* COMMENT_3 */
    if (VAR_7 == VAR_19)
    {
	win_T	*VAR_20 = win_id2wp(VAR_3);

	if (VAR_20 == NULL && VAR_16->w_llist != VAR_0)
	{
	    emsg(_(VAR_21));
	    *VAR_4 = FALSE;
	    return VAR_22;
	}
    }

    if (VAR_7 == VAR_23 && !qflist_valid(NULL, VAR_11))
    {
	emsg(_(VAR_24));
	return VAR_22;
    }

    /* COMMENT_4 */
    /* COMMENT_5 */
    if (VAR_10 != VAR_0->qf_curlist
	    || VAR_6 != VAR_5->qf_changedtick
	    || !is_qf_entry_present(VAR_5, VAR_1))
    {
	if (VAR_7 == VAR_23)
	    emsg(_(VAR_24));
	else
	    emsg(_(VAR_25));
	return VAR_22;
    }

    return VAR_8;
}",vim/6d24a51b94beb1991cddce221f90b455e2d50db7/quickfix.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -41,14 +41,14 @@
 	{
 	    emsg(_(e_current_window_was_closed));
 	    *opened_window = FALSE;
-	    return NOTDONE;
+	    return QF_ABORT;
 	}
     }
 
     if (qfl_type == QFLT_QUICKFIX && !qflist_valid(NULL, save_qfid))
     {
 	emsg(_(e_current_quickfix_list_was_changed));
-	return NOTDONE;
+	return QF_ABORT;
     }
 
     // Check if the list was changed.  The pointers may happen to be identical,
@@ -61,7 +61,7 @@
 	    emsg(_(e_current_quickfix_list_was_changed));
 	else
 	    emsg(_(e_current_location_list_was_changed));
-	return NOTDONE;
+	return QF_ABORT;
     }
 
     return retval;","{'deleted_lines': ['\t    return NOTDONE;', '\treturn NOTDONE;', '\treturn NOTDONE;'], 'added_lines': ['\t    return QF_ABORT;', '\treturn QF_ABORT;', '\treturn QF_ABORT;']}",True,Use After Free in GitHub repository vim/vim prior to 9.0.0286.,7.8,HIGH,2,test,2022-08-27T19:59:57Z,4
CVE-2022-3016,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,vim,"patch 9.0.0286: using freed memory when location list changed in autocmd

Problem:    Using freed memory when location list changed in autocmd.
Solution:   Return QF_ABORT and handle it. (Yegappan Lakshmanan,
            closes #10993)",6d24a51b94beb1991cddce221f90b455e2d50db7,https://github.com/vim/vim/commit/6d24a51b94beb1991cddce221f90b455e2d50db7,src/quickfix.c,qf_jump_newwin,"static void
qf_jump_newwin(qf_info_T*qi,
intdir,
interrornr,
intforceit,
intnewwin)
{
qf_list_T*qfl;
qfline_T*qf_ptr;
qfline_T*old_qf_ptr;
intqf_index;
intold_qf_index;
char_u*old_swb = p_swb;
unsignedold_swb_flags = swb_flags;
intprev_winid;
intopened_window = FALSE;
intprint_message = TRUE;
intold_KeyTyped = KeyTyped;     intretval = OK;
if (qi == NULL)
qi = &ql_info;
if (qf_stack_empty(qi) || qf_list_empty(qf_get_curlist(qi)))
{
emsg(_(e_no_errors));
return;
}
incr_quickfix_busy();
qfl = qf_get_curlist(qi);
qf_ptr = qfl->qf_ptr;
old_qf_ptr = qf_ptr;
qf_index = qfl->qf_index;
old_qf_index = qf_index;
qf_ptr = qf_get_entry(qfl, errornr, dir, &qf_index);
if (qf_ptr == NULL)
{
qf_ptr = old_qf_ptr;
qf_index = old_qf_index;
goto theend;
}
qfl->qf_index = qf_index;
qfl->qf_ptr = qf_ptr;
if (qf_win_pos_update(qi, old_qf_index))
print_message = FALSE;
prev_winid = curwin->w_id;
retval = qf_jump_open_window(qi, qf_ptr, newwin, &opened_window);
if (retval == FAIL)
goto failed;
if (retval == NOTDONE)
goto theend;
retval = qf_jump_to_buffer(qi, qf_index, qf_ptr, forceit, prev_winid,
&opened_window, old_KeyTyped, print_message);
if (retval == NOTDONE)
{
qi = NULL;
qf_ptr = NULL;
}
if (retval != OK)
{
if (opened_window)
win_close(curwin, TRUE);    if (qf_ptr != NULL && qf_ptr->qf_fnum != 0)
{
failed:
qf_ptr = old_qf_ptr;
qf_index = old_qf_index;
}
}
theend:
if (qi != NULL)
{
qfl->qf_ptr = qf_ptr;
qfl->qf_index = qf_index;
}
if (p_swb != old_swb && p_swb == empty_option)
{
p_swb = old_swb;
swb_flags = old_swb_flags;
}
decr_quickfix_busy();
}","static void
qf_jump_newwin(qf_info_T*VAR_0,
intVAR_1,
intVAR_2,
intVAR_3,
intVAR_4)
{
qf_list_T*VAR_5;
qfline_T*VAR_6;
qfline_T*VAR_7;
intVAR_8;
intVAR_9;
char_u*VAR_10 = VAR_11;
unsignedVAR_12 = VAR_13;
intVAR_14;
intVAR_15 = FALSE;
intVAR_16 = TRUE;
intVAR_17 = VAR_18; 
intVAR_19 = VAR_20;
if (VAR_0 == NULL)
VAR_0 = &VAR_21;
if (qf_stack_empty(VAR_0) || qf_list_empty(qf_get_curlist(VAR_0)))
{
emsg(_(VAR_22));
return;
}
incr_quickfix_busy();
VAR_5 = qf_get_curlist(VAR_0);
VAR_6 = VAR_5->qf_ptr;
VAR_7 = VAR_6;
VAR_8 = VAR_5->qf_index;
VAR_9 = VAR_8;
VAR_6 = qf_get_entry(VAR_5, VAR_2, VAR_1, &VAR_8);
if (VAR_6 == NULL)
{
VAR_6 = VAR_7;
VAR_8 = VAR_9;
goto theend;
}
VAR_5->qf_index = VAR_8;
VAR_5->qf_ptr = VAR_6;
if (qf_win_pos_update(VAR_0, VAR_9))
VAR_16 = FALSE;
VAR_14 = VAR_23->w_id;
VAR_19 = qf_jump_open_window(VAR_0, VAR_6, VAR_4, &VAR_15);
if (VAR_19 == VAR_24)
goto failed;
if (VAR_19 == VAR_25)
goto theend;
VAR_19 = qf_jump_to_buffer(VAR_0, VAR_8, VAR_6, VAR_3, VAR_14,
&VAR_15, VAR_17, VAR_16);
if (VAR_19 == VAR_25)
{
VAR_0 = NULL;
VAR_6 = NULL;
}
if (VAR_19 != VAR_20)
{
if (VAR_15)
win_close(VAR_23, TRUE);    
if (VAR_6 != NULL && VAR_6->qf_fnum != 0)
{
failed:
VAR_6 = VAR_7;
VAR_8 = VAR_9;
}
}
theend:
if (VAR_0 != NULL)
{
VAR_5->qf_ptr = VAR_6;
VAR_5->qf_index = VAR_8;
}
if (VAR_11 != VAR_10 && VAR_11 == VAR_26)
{
VAR_11 = VAR_10;
VAR_13 = VAR_12;
}
decr_quickfix_busy();
}",vim/6d24a51b94beb1991cddce221f90b455e2d50db7/quickfix.c/vul/before/2.json,"static void
qf_jump_newwin(qf_info_T	*qi,
	int		dir,
	int		errornr,
	int		forceit,
	int		newwin)
{
    qf_list_T		*qfl;
    qfline_T		*qf_ptr;
    qfline_T		*old_qf_ptr;
    int			qf_index;
    int			old_qf_index;
    char_u		*old_swb = p_swb;
    unsigned		old_swb_flags = swb_flags;
    int			prev_winid;
    int			opened_window = FALSE;
    int			print_message = TRUE;
    int			old_KeyTyped = KeyTyped; // getting file may reset it
    int			retval = OK;

    if (qi == NULL)
	qi = &ql_info;

    if (qf_stack_empty(qi) || qf_list_empty(qf_get_curlist(qi)))
    {
	emsg(_(e_no_errors));
	return;
    }

    incr_quickfix_busy();

    qfl = qf_get_curlist(qi);

    qf_ptr = qfl->qf_ptr;
    old_qf_ptr = qf_ptr;
    qf_index = qfl->qf_index;
    old_qf_index = qf_index;

    qf_ptr = qf_get_entry(qfl, errornr, dir, &qf_index);
    if (qf_ptr == NULL)
    {
	qf_ptr = old_qf_ptr;
	qf_index = old_qf_index;
	goto theend;
    }

    qfl->qf_index = qf_index;
    qfl->qf_ptr = qf_ptr;
    if (qf_win_pos_update(qi, old_qf_index))
	// No need to print the error message if it's visible in the error
	// window
	print_message = FALSE;

    prev_winid = curwin->w_id;

    retval = qf_jump_open_window(qi, qf_ptr, newwin, &opened_window);
    if (retval == FAIL)
	goto failed;
    if (retval == QF_ABORT)
    {
	qi = NULL;
	qf_ptr = NULL;
	goto theend;
    }
    if (retval == NOTDONE)
	goto theend;

    retval = qf_jump_to_buffer(qi, qf_index, qf_ptr, forceit, prev_winid,
				  &opened_window, old_KeyTyped, print_message);
    if (retval == QF_ABORT)
    {
	// Quickfix/location list was modified by an autocmd
	qi = NULL;
	qf_ptr = NULL;
    }

    if (retval != OK)
    {
	if (opened_window)
	    win_close(curwin, TRUE);    // Close opened window
	if (qf_ptr != NULL && qf_ptr->qf_fnum != 0)
	{
	    // Couldn't open file, so put index back where it was.  This could
	    // happen if the file was readonly and we changed something.
failed:
	    qf_ptr = old_qf_ptr;
	    qf_index = old_qf_index;
	}
    }
theend:
    if (qi != NULL)
    {
	qfl->qf_ptr = qf_ptr;
	qfl->qf_index = qf_index;
    }
    if (p_swb != old_swb && p_swb == empty_option)
    {
	// Restore old 'switchbuf' value, but not when an autocommand or
	// modeline has changed the value.
	p_swb = old_swb;
	swb_flags = old_swb_flags;
    }
    decr_quickfix_busy();
}","static void
qf_jump_newwin(qf_info_T	*VAR_0,
	int		VAR_1,
	int		VAR_2,
	int		VAR_3,
	int		VAR_4)
{
    qf_list_T		*VAR_5;
    qfline_T		*VAR_6;
    qfline_T		*VAR_7;
    int			VAR_8;
    int			VAR_9;
    char_u		*VAR_10 = VAR_11;
    unsigned		VAR_12 = VAR_13;
    int			VAR_14;
    int			VAR_15 = FALSE;
    int			VAR_16 = TRUE;
    int			VAR_17 = VAR_18; /* COMMENT_0 */
    int			VAR_19 = VAR_20;

    if (VAR_0 == NULL)
	VAR_0 = &VAR_21;

    if (qf_stack_empty(VAR_0) || qf_list_empty(qf_get_curlist(VAR_0)))
    {
	emsg(_(VAR_22));
	return;
    }

    incr_quickfix_busy();

    VAR_5 = qf_get_curlist(VAR_0);

    VAR_6 = VAR_5->qf_ptr;
    VAR_7 = VAR_6;
    VAR_8 = VAR_5->qf_index;
    VAR_9 = VAR_8;

    VAR_6 = qf_get_entry(VAR_5, VAR_2, VAR_1, &VAR_8);
    if (VAR_6 == NULL)
    {
	VAR_6 = VAR_7;
	VAR_8 = VAR_9;
	goto theend;
    }

    VAR_5->qf_index = VAR_8;
    VAR_5->qf_ptr = VAR_6;
    if (qf_win_pos_update(VAR_0, VAR_9))
	/* COMMENT_1 */
	/* COMMENT_2 */
	VAR_16 = FALSE;

    VAR_14 = VAR_23->w_id;

    VAR_19 = qf_jump_open_window(VAR_0, VAR_6, VAR_4, &VAR_15);
    if (VAR_19 == VAR_24)
	goto failed;
    if (VAR_19 == VAR_25)
    {
	VAR_0 = NULL;
	VAR_6 = NULL;
	goto theend;
    }
    if (VAR_19 == VAR_26)
	goto theend;

    VAR_19 = qf_jump_to_buffer(VAR_0, VAR_8, VAR_6, VAR_3, VAR_14,
				  &VAR_15, VAR_17, VAR_16);
    if (VAR_19 == VAR_25)
    {
	/* COMMENT_3 */
	VAR_0 = NULL;
	VAR_6 = NULL;
    }

    if (VAR_19 != VAR_20)
    {
	if (VAR_15)
	    win_close(VAR_23, TRUE);    /* COMMENT_4 */
	if (VAR_6 != NULL && VAR_6->qf_fnum != 0)
	{
	    /* COMMENT_5 */
	    /* COMMENT_6 */
failed:
	    VAR_6 = VAR_7;
	    VAR_8 = VAR_9;
	}
    }
theend:
    if (VAR_0 != NULL)
    {
	VAR_5->qf_ptr = VAR_6;
	VAR_5->qf_index = VAR_8;
    }
    if (VAR_11 != VAR_10 && VAR_11 == VAR_27)
    {
	/* COMMENT_7 */
	/* COMMENT_8 */
	VAR_11 = VAR_10;
	VAR_13 = VAR_12;
    }
    decr_quickfix_busy();
}",vim/6d24a51b94beb1991cddce221f90b455e2d50db7/quickfix.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -56,14 +56,20 @@
     retval = qf_jump_open_window(qi, qf_ptr, newwin, &opened_window);
     if (retval == FAIL)
 	goto failed;
+    if (retval == QF_ABORT)
+    {
+	qi = NULL;
+	qf_ptr = NULL;
+	goto theend;
+    }
     if (retval == NOTDONE)
 	goto theend;
 
     retval = qf_jump_to_buffer(qi, qf_index, qf_ptr, forceit, prev_winid,
 				  &opened_window, old_KeyTyped, print_message);
-    if (retval == NOTDONE)
+    if (retval == QF_ABORT)
     {
-	// Quickfix/location list is freed by an autocmd
+	// Quickfix/location list was modified by an autocmd
 	qi = NULL;
 	qf_ptr = NULL;
     }","{'deleted_lines': ['    if (retval == NOTDONE)', '\t// Quickfix/location list is freed by an autocmd'], 'added_lines': ['    if (retval == QF_ABORT)', '    {', '\tqi = NULL;', '\tqf_ptr = NULL;', '\tgoto theend;', '    }', '    if (retval == QF_ABORT)', '\t// Quickfix/location list was modified by an autocmd']}",True,Use After Free in GitHub repository vim/vim prior to 9.0.0286.,7.8,HIGH,2,test,2022-08-27T19:59:57Z,4
CVE-2022-3016,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,vim,"patch 9.0.0286: using freed memory when location list changed in autocmd

Problem:    Using freed memory when location list changed in autocmd.
Solution:   Return QF_ABORT and handle it. (Yegappan Lakshmanan,
            closes #10993)",6d24a51b94beb1991cddce221f90b455e2d50db7,https://github.com/vim/vim/commit/6d24a51b94beb1991cddce221f90b455e2d50db7,src/quickfix.c,qf_jump_open_window,"static int
qf_jump_open_window(
qf_info_T*qi,
qfline_T*qf_ptr,
intnewwin,
int*opened_window)
{
qf_list_T*qfl = qf_get_curlist(qi);
intold_changedtick = qfl->qf_changedtick;
intold_qf_curlist = qi->qf_curlist;
qfltype_Tqfl_type = qfl->qfl_type;
if (qf_ptr->qf_type == 1 && (!bt_help(curwin->w_buffer)
|| cmdmod.cmod_tab != 0))
if (jump_to_help_window(qi, newwin, opened_window) == FAIL)
return FAIL;
if (old_qf_curlist != qi->qf_curlist
|| old_changedtick != qfl->qf_changedtick
|| !is_qf_entry_present(qfl, qf_ptr))
{
if (qfl_type == QFLT_QUICKFIX)
emsg(_(e_current_quickfix_list_was_changed));
else
emsg(_(e_current_location_list_was_changed));
return FAIL;
}
if (bt_quickfix(curbuf) && !*opened_window)
{
if (qf_ptr->qf_fnum == 0)
return NOTDONE;
if (qf_jump_to_usable_window(qf_ptr->qf_fnum, newwin,
opened_window) == FAIL)
return FAIL;
}
if (old_qf_curlist != qi->qf_curlist
|| old_changedtick != qfl->qf_changedtick
|| !is_qf_entry_present(qfl, qf_ptr))
{
if (qfl_type == QFLT_QUICKFIX)
emsg(_(e_current_quickfix_list_was_changed));
else
emsg(_(e_current_location_list_was_changed));
return FAIL;
}
return OK;
}","static int
qf_jump_open_window(
qf_info_T*VAR_0,
qfline_T*VAR_1,
intVAR_2,
int*VAR_3)
{
qf_list_T*VAR_4 = qf_get_curlist(VAR_0);
intVAR_5 = VAR_4->qf_changedtick;
intVAR_6 = VAR_0->qf_curlist;
qfltype_TVAR_7 = VAR_4->qfl_type;
if (VAR_1->qf_type == 1 && (!bt_help(VAR_8->w_buffer)
|| VAR_9.cmod_tab != 0))
if (jump_to_help_window(VAR_0, VAR_2, VAR_3) == VAR_10)
return VAR_10;
if (VAR_6 != VAR_0->qf_curlist
|| VAR_5 != VAR_4->qf_changedtick
|| !is_qf_entry_present(VAR_4, VAR_1))
{
if (VAR_7 == VAR_11)
emsg(_(VAR_12));
else
emsg(_(VAR_13));
return VAR_10;
}
if (bt_quickfix(VAR_14) && !*VAR_3)
{
if (VAR_1->qf_fnum == 0)
return VAR_15;
if (qf_jump_to_usable_window(VAR_1->qf_fnum, VAR_2,
VAR_3) == VAR_10)
return VAR_10;
}
if (VAR_6 != VAR_0->qf_curlist
|| VAR_5 != VAR_4->qf_changedtick
|| !is_qf_entry_present(VAR_4, VAR_1))
{
if (VAR_7 == VAR_11)
emsg(_(VAR_12));
else
emsg(_(VAR_13));
return VAR_10;
}
return VAR_16;
}",vim/6d24a51b94beb1991cddce221f90b455e2d50db7/quickfix.c/vul/before/0.json,"static int
qf_jump_open_window(
	qf_info_T	*qi,
	qfline_T	*qf_ptr,
	int		newwin,
	int		*opened_window)
{
    qf_list_T	*qfl = qf_get_curlist(qi);
    int		old_changedtick = qfl->qf_changedtick;
    int		old_qf_curlist = qi->qf_curlist;
    qfltype_T	qfl_type = qfl->qfl_type;

    // For "":helpgrep"" find a help window or open one.
    if (qf_ptr->qf_type == 1 && (!bt_help(curwin->w_buffer)
						      || cmdmod.cmod_tab != 0))
	if (jump_to_help_window(qi, newwin, opened_window) == FAIL)
	    return FAIL;
    if (old_qf_curlist != qi->qf_curlist
	    || old_changedtick != qfl->qf_changedtick
	    || !is_qf_entry_present(qfl, qf_ptr))
    {
	if (qfl_type == QFLT_QUICKFIX)
	    emsg(_(e_current_quickfix_list_was_changed));
	else
	    emsg(_(e_current_location_list_was_changed));
	return QF_ABORT;
    }

    // If currently in the quickfix window, find another window to show the
    // file in.
    if (bt_quickfix(curbuf) && !*opened_window)
    {
	// If there is no file specified, we don't know where to go.
	// But do advance, otherwise "":cn"" gets stuck.
	if (qf_ptr->qf_fnum == 0)
	    return NOTDONE;

	if (qf_jump_to_usable_window(qf_ptr->qf_fnum, newwin,
						opened_window) == FAIL)
	    return FAIL;
    }
    if (old_qf_curlist != qi->qf_curlist
	    || old_changedtick != qfl->qf_changedtick
	    || !is_qf_entry_present(qfl, qf_ptr))
    {
	if (qfl_type == QFLT_QUICKFIX)
	    emsg(_(e_current_quickfix_list_was_changed));
	else
	    emsg(_(e_current_location_list_was_changed));
	return QF_ABORT;
    }

    return OK;
}","static int
qf_jump_open_window(
	qf_info_T	*VAR_0,
	qfline_T	*VAR_1,
	int		VAR_2,
	int		*VAR_3)
{
    qf_list_T	*VAR_4 = qf_get_curlist(VAR_0);
    int		VAR_5 = VAR_4->qf_changedtick;
    int		VAR_6 = VAR_0->qf_curlist;
    qfltype_T	VAR_7 = VAR_4->qfl_type;

    /* COMMENT_0 */
    if (VAR_1->qf_type == 1 && (!bt_help(VAR_8->w_buffer)
						      || VAR_9.cmod_tab != 0))
	if (jump_to_help_window(VAR_0, VAR_2, VAR_3) == VAR_10)
	    return VAR_10;
    if (VAR_6 != VAR_0->qf_curlist
	    || VAR_5 != VAR_4->qf_changedtick
	    || !is_qf_entry_present(VAR_4, VAR_1))
    {
	if (VAR_7 == VAR_11)
	    emsg(_(VAR_12));
	else
	    emsg(_(VAR_13));
	return VAR_14;
    }

    /* COMMENT_1 */
    /* COMMENT_2 */
    if (bt_quickfix(VAR_15) && !*VAR_3)
    {
	/* COMMENT_3 */
	/* COMMENT_4 */
	if (VAR_1->qf_fnum == 0)
	    return VAR_16;

	if (qf_jump_to_usable_window(VAR_1->qf_fnum, VAR_2,
						VAR_3) == VAR_10)
	    return VAR_10;
    }
    if (VAR_6 != VAR_0->qf_curlist
	    || VAR_5 != VAR_4->qf_changedtick
	    || !is_qf_entry_present(VAR_4, VAR_1))
    {
	if (VAR_7 == VAR_11)
	    emsg(_(VAR_12));
	else
	    emsg(_(VAR_13));
	return VAR_14;
    }

    return VAR_17;
}",vim/6d24a51b94beb1991cddce221f90b455e2d50db7/quickfix.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -23,7 +23,7 @@
 	    emsg(_(e_current_quickfix_list_was_changed));
 	else
 	    emsg(_(e_current_location_list_was_changed));
-	return FAIL;
+	return QF_ABORT;
     }
 
     // If currently in the quickfix window, find another window to show the
@@ -47,7 +47,7 @@
 	    emsg(_(e_current_quickfix_list_was_changed));
 	else
 	    emsg(_(e_current_location_list_was_changed));
-	return FAIL;
+	return QF_ABORT;
     }
 
     return OK;","{'deleted_lines': ['\treturn FAIL;', '\treturn FAIL;'], 'added_lines': ['\treturn QF_ABORT;', '\treturn QF_ABORT;']}",True,Use After Free in GitHub repository vim/vim prior to 9.0.0286.,7.8,HIGH,2,test,2022-08-27T19:59:57Z,4
CVE-2022-3134,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,vim,"patch 9.0.0389: crash when 'tagfunc' closes the window

Problem:    Crash when 'tagfunc' closes the window.
Solution:   Bail out when the window was closed.",ccfde4d028e891a41e3548323c3d47b06fb0b83e,https://github.com/vim/vim/commit/ccfde4d028e891a41e3548323c3d47b06fb0b83e,src/tag.c,do_tag,"int
do_tag(
char_u*tag,    inttype,
intcount,
intforceit,    intverbose){
taggy_T*tagstack = curwin->w_tagstack;
inttagstackidx = curwin->w_tagstackidx;
inttagstacklen = curwin->w_tagstacklen;
intcur_match = 0;
intcur_fnum = curbuf->b_fnum;
intoldtagstackidx = tagstackidx;
intprevtagstackidx = tagstackidx;
intprev_num_matches;
intnew_tag = FALSE;
inti;
intic;
intno_regexp = FALSE;
interror_cur_match = 0;
intsave_pos = FALSE;
fmark_Tsaved_fmark;
#ifdef FEAT_CSCOPE
intjumped_to_tag = FALSE;
#endif
intnew_num_matches;
char_u**new_matches;
intuse_tagstack;
intskip_msg = FALSE;
char_u*buf_ffname = curbuf->b_ffname;            intuse_tfu = 1;
char_u*tofree = NULL;
static intnum_matches = 0;
static intmax_num_matches = 0;      static char_u**matches = NULL;
static intflags;
#ifdef FEAT_EVAL
if (tfu_in_use)
{
emsg(_(e_cannot_modify_tag_stack_within_tagfunc));
return FALSE;
}
#endif
#ifdef EXITFREE
if (type == DT_FREE)
{
FreeWild(num_matches, matches);
# ifdef FEAT_CSCOPE
cs_free_tags();
# endif
num_matches = 0;
return FALSE;
}
#endif
if (type == DT_HELP)
{
type = DT_TAG;
no_regexp = TRUE;
use_tfu = 0;
}
prev_num_matches = num_matches;
free_string_option(nofile_fname);
nofile_fname = NULL;
CLEAR_POS(&saved_fmark.mark);    saved_fmark.fnum = 0;
if ((!p_tgst && *tag != NUL))
{
use_tagstack = FALSE;
new_tag = TRUE;
#if defined(FEAT_QUICKFIX)
if (g_do_tagpreview != 0)
{
tagstack_clear_entry(&ptag_entry);
if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)
goto end_do_tag;
}
#endif
}
else
{
#if defined(FEAT_QUICKFIX)
if (g_do_tagpreview != 0)
use_tagstack = FALSE;
else
#endif
use_tagstack = TRUE;
if (*tag != NUL
&& (type == DT_TAG || type == DT_SELECT || type == DT_JUMP
#ifdef FEAT_QUICKFIX
|| type == DT_LTAG
#endif
#ifdef FEAT_CSCOPE
|| type == DT_CSCOPE
#endif
))
{
#if defined(FEAT_QUICKFIX)
if (g_do_tagpreview != 0)
{
if (ptag_entry.tagname != NULL
&& STRCMP(ptag_entry.tagname, tag) == 0)
{
cur_match = ptag_entry.cur_match;
cur_fnum = ptag_entry.cur_fnum;
}
else
{
tagstack_clear_entry(&ptag_entry);
if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)
goto end_do_tag;
}
}
else
#endif
{
while (tagstackidx < tagstacklen)
tagstack_clear_entry(&tagstack[--tagstacklen]);
if (++tagstacklen > TAGSTACKSIZE)
{
tagstacklen = TAGSTACKSIZE;
tagstack_clear_entry(&tagstack[0]);
for (i = 1; i < tagstacklen; ++i)
tagstack[i - 1] = tagstack[i];
--tagstackidx;
}
if ((tagstack[tagstackidx].tagname = vim_strsave(tag)) == NULL)
{
curwin->w_tagstacklen = tagstacklen - 1;
goto end_do_tag;
}
curwin->w_tagstacklen = tagstacklen;
save_pos = TRUE;    }
new_tag = TRUE;
}
else
{
if (
#if defined(FEAT_QUICKFIX)
g_do_tagpreview != 0 ? ptag_entry.tagname == NULL :
#endif
tagstacklen == 0)
{
emsg(_(e_tag_stack_empty));
goto end_do_tag;
}
if (type == DT_POP)    {
#ifdef FEAT_FOLDING
intold_KeyTyped = KeyTyped;
#endif
if ((tagstackidx -= count) < 0)
{
emsg(_(e_at_bottom_of_tag_stack));
if (tagstackidx + count == 0)
{
tagstackidx = 0;
goto end_do_tag;
}
tagstackidx = 0;
}
else if (tagstackidx >= tagstacklen)    {
emsg(_(e_at_top_of_tag_stack));
goto end_do_tag;
}
saved_fmark = tagstack[tagstackidx].fmark;
if (saved_fmark.fnum != curbuf->b_fnum)
{
if (buflist_getfile(saved_fmark.fnum, saved_fmark.mark.lnum,
GETF_SETMARK, forceit) == FAIL)
{
tagstackidx = oldtagstackidx;  goto end_do_tag;
}
curwin->w_cursor.lnum = saved_fmark.mark.lnum;
}
else
{
setpcmark();
curwin->w_cursor.lnum = saved_fmark.mark.lnum;
}
curwin->w_cursor.col = saved_fmark.mark.col;
curwin->w_set_curswant = TRUE;
check_cursor();
#ifdef FEAT_FOLDING
if ((fdo_flags & FDO_TAG) && old_KeyTyped)
foldOpenCursor();
#endif
FreeWild(num_matches, matches);
#ifdef FEAT_CSCOPE
cs_free_tags();
#endif
num_matches = 0;
tag_freematch();
goto end_do_tag;
}
if (type == DT_TAG
#if defined(FEAT_QUICKFIX)
|| type == DT_LTAG
#endif
)
{
#if defined(FEAT_QUICKFIX)
if (g_do_tagpreview != 0)
{
cur_match = ptag_entry.cur_match;
cur_fnum = ptag_entry.cur_fnum;
}
else
#endif
{
save_pos = TRUE;    if ((tagstackidx += count - 1) >= tagstacklen)
{
tagstackidx = tagstacklen - 1;
emsg(_(e_at_top_of_tag_stack));
save_pos = FALSE;
}
else if (tagstackidx < 0)    {
emsg(_(e_at_bottom_of_tag_stack));
tagstackidx = 0;
goto end_do_tag;
}
cur_match = tagstack[tagstackidx].cur_match;
cur_fnum = tagstack[tagstackidx].cur_fnum;
}
new_tag = TRUE;
}
else    {
prevtagstackidx = tagstackidx;
#if defined(FEAT_QUICKFIX)
if (g_do_tagpreview != 0)
{
cur_match = ptag_entry.cur_match;
cur_fnum = ptag_entry.cur_fnum;
}
else
#endif
{
if (--tagstackidx < 0)
tagstackidx = 0;
cur_match = tagstack[tagstackidx].cur_match;
cur_fnum = tagstack[tagstackidx].cur_fnum;
}
switch (type)
{
case DT_FIRST: cur_match = count - 1; break;
case DT_SELECT:
case DT_JUMP:
#ifdef FEAT_CSCOPE
case DT_CSCOPE:
#endif
case DT_LAST:  cur_match = MAXCOL - 1; break;
case DT_NEXT:  cur_match += count; break;
case DT_PREV:  cur_match -= count; break;
}
if (cur_match >= MAXCOL)
cur_match = MAXCOL - 1;
else if (cur_match < 0)
{
emsg(_(e_cannot_go_before_first_matching_tag));
skip_msg = TRUE;
cur_match = 0;
cur_fnum = curbuf->b_fnum;
}
}
}
#if defined(FEAT_QUICKFIX)
if (g_do_tagpreview != 0)
{
if (type != DT_SELECT && type != DT_JUMP)
{
ptag_entry.cur_match = cur_match;
ptag_entry.cur_fnum = cur_fnum;
}
}
else
#endif
{
saved_fmark = tagstack[tagstackidx].fmark;
if (save_pos)
{
tagstack[tagstackidx].fmark.mark = curwin->w_cursor;
tagstack[tagstackidx].fmark.fnum = curbuf->b_fnum;
}
curwin->w_tagstackidx = tagstackidx;
if (type != DT_SELECT && type != DT_JUMP)
{
curwin->w_tagstack[tagstackidx].cur_match = cur_match;
curwin->w_tagstack[tagstackidx].cur_fnum = cur_fnum;
}
}
}
if (cur_fnum != curbuf->b_fnum)
{
buf_T *buf = buflist_findnr(cur_fnum);
if (buf != NULL)
buf_ffname = buf->b_ffname;
}
for (;;)
{
intother_name;
char_u*name;
if (use_tagstack)
{
name = vim_strsave(tagstack[tagstackidx].tagname);
vim_free(tofree);
tofree = name;
}
#if defined(FEAT_QUICKFIX)
else if (g_do_tagpreview != 0)
name = ptag_entry.tagname;
#endif
else
name = tag;
other_name = (tagmatchname == NULL || STRCMP(tagmatchname, name) != 0);
if (new_tag
|| (cur_match >= num_matches && max_num_matches != MAXCOL)
|| other_name)
{
if (other_name)
{
vim_free(tagmatchname);
tagmatchname = vim_strsave(name);
}
if (type == DT_SELECT || type == DT_JUMP
#if defined(FEAT_QUICKFIX)
|| type == DT_LTAG
#endif
)
cur_match = MAXCOL - 1;
if (type == DT_TAG)
max_num_matches = MAXCOL;
else
max_num_matches = cur_match + 1;
if (!no_regexp && *name == '/')
{
flags = TAG_REGEXP;
++name;
}
else
flags = TAG_NOIC;
#ifdef FEAT_CSCOPE
if (type == DT_CSCOPE)
flags = TAG_CSCOPE;
#endif
if (verbose)
flags |= TAG_VERBOSE;
if (!use_tfu)
flags |= TAG_NO_TAGFUNC;
if (find_tags(name, &new_num_matches, &new_matches, flags,
max_num_matches, buf_ffname) == OK
&& new_num_matches < max_num_matches)
max_num_matches = MAXCOL;   
if (!new_tag && !other_name)
{
int    j, k;
int    idx = 0;
tagptrs_T   tagp, tagp2;
for (j = 0; j < num_matches; ++j)
{
parse_match(matches[j], &tagp);
for (i = idx; i < new_num_matches; ++i)
{
parse_match(new_matches[i], &tagp2);
if (STRCMP(tagp.tagname, tagp2.tagname) == 0)
{
char_u *p = new_matches[i];
for (k = i; k > idx; --k)
new_matches[k] = new_matches[k - 1];
new_matches[idx++] = p;
break;
}
}
}
}
FreeWild(num_matches, matches);
num_matches = new_num_matches;
matches = new_matches;
}
if (num_matches <= 0)
{
if (verbose)
semsg(_(e_tag_not_found_str), name);
#if defined(FEAT_QUICKFIX)
g_do_tagpreview = 0;
#endif
}
else
{
int ask_for_selection = FALSE;
#ifdef FEAT_CSCOPE
if (type == DT_CSCOPE && num_matches > 1)
{
cs_print_tags();
ask_for_selection = TRUE;
}
else
#endif
if (type == DT_TAG && *tag != NUL)
cur_match = count > 0 ? count - 1 : 0;
else if (type == DT_SELECT || (type == DT_JUMP && num_matches > 1))
{
print_tag_list(new_tag, use_tagstack, num_matches, matches);
ask_for_selection = TRUE;
}
#if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)
else if (type == DT_LTAG)
{
if (add_llist_tags(tag, num_matches, matches) == FAIL)
goto end_do_tag;
cur_match = 0;    }
#endif
if (ask_for_selection == TRUE)
{
i = prompt_for_number(NULL);
if (i <= 0 || i > num_matches || got_int)
{
if (use_tagstack)
{
tagstack[tagstackidx].fmark = saved_fmark;
tagstackidx = prevtagstackidx;
}
#ifdef FEAT_CSCOPE
cs_free_tags();
jumped_to_tag = TRUE;
#endif
break;
}
cur_match = i - 1;
}
if (cur_match >= num_matches)
{
if ((type == DT_NEXT || type == DT_FIRST)
&& nofile_fname == NULL)
{
if (num_matches == 1)
emsg(_(e_there_is_only_one_matching_tag));
else
emsg(_(e_cannot_go_beyond_last_matching_tag));
skip_msg = TRUE;
}
cur_match = num_matches - 1;
}
if (use_tagstack)
{
tagptrs_T   tagp;
tagstack[tagstackidx].cur_match = cur_match;
tagstack[tagstackidx].cur_fnum = cur_fnum;
if (use_tfu && parse_match(matches[cur_match], &tagp) == OK
&& tagp.user_data)
{
VIM_CLEAR(tagstack[tagstackidx].user_data);
tagstack[tagstackidx].user_data = vim_strnsave(
tagp.user_data, tagp.user_data_end - tagp.user_data);
}
++tagstackidx;
}
#if defined(FEAT_QUICKFIX)
else if (g_do_tagpreview != 0)
{
ptag_entry.cur_match = cur_match;
ptag_entry.cur_fnum = cur_fnum;
}
#endif
if (nofile_fname != NULL && error_cur_match != cur_match)
smsg(_(""File \""%s\"" does not exist""), nofile_fname);
ic = (matches[cur_match][0] & MT_IC_OFF);
if (type != DT_TAG && type != DT_SELECT && type != DT_JUMP
#ifdef FEAT_CSCOPE
&& type != DT_CSCOPE
#endif
&& (num_matches > 1 || ic)
&& !skip_msg)
{
sprintf((char *)IObuff, _(""tag %d of %d%s""),
cur_match + 1,
num_matches,
max_num_matches != MAXCOL ? _("" or more"") : """");
if (ic)
STRCAT(IObuff, _(""  Using tag with different case!""));
if ((num_matches > prev_num_matches || new_tag)
&& num_matches > 1)
{
if (ic)
msg_attr((char *)IObuff, HL_ATTR(HLF_W));
else
msg((char *)IObuff);
msg_scroll = TRUE;}
else
give_warning(IObuff, ic);
if (ic && !msg_scrolled && msg_silent == 0)
{
out_flush();
ui_delay(1007L, TRUE);
}
}
#if defined(FEAT_EVAL)
vim_snprintf((char *)IObuff, IOSIZE, "":ta %s\r"", name);
set_vim_var_string(VV_SWAPCOMMAND, IObuff, -1);
#endif
i = jumpto_tag(matches[cur_match], forceit, type != DT_CSCOPE);
#if defined(FEAT_EVAL)
set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);
#endif
if (i == NOTAGFILE)
{
if ((type == DT_PREV && cur_match > 0)
|| ((type == DT_TAG || type == DT_NEXT
|| type == DT_FIRST)
&& (max_num_matches != MAXCOL
|| cur_match < num_matches - 1)))
{
error_cur_match = cur_match;
if (use_tagstack)
--tagstackidx;
if (type == DT_PREV)
--cur_match;
else
{
type = DT_NEXT;
++cur_match;
}
continue;
}
semsg(_(e_file_str_does_not_exist), nofile_fname);
}
else
{
if (use_tagstack && tagstackidx > curwin->w_tagstacklen)
tagstackidx = curwin->w_tagstackidx;
#ifdef FEAT_CSCOPE
jumped_to_tag = TRUE;
#endif
}
}
break;
}
end_do_tag:
if (use_tagstack && tagstackidx <= curwin->w_tagstacklen)
curwin->w_tagstackidx = tagstackidx;
postponed_split = 0;# ifdef FEAT_QUICKFIX
g_do_tagpreview = 0;# endif
vim_free(tofree);
#ifdef FEAT_CSCOPE
return jumped_to_tag;
#else
return FALSE;
#endif
}","int
do_tag(
char_u*VAR_0,
intVAR_1,
intVAR_2,
intVAR_3,
intVAR_4)
{
taggy_T*VAR_5 = VAR_6->w_tagstack;
intVAR_7 = VAR_6->w_tagstackidx;
intVAR_8 = VAR_6->w_tagstacklen;
intVAR_9 = 0;
intVAR_10 = VAR_11->b_fnum;
intVAR_12 = VAR_7;
intVAR_13 = VAR_7;
intVAR_14;
intVAR_15 = FALSE;
intVAR_16;
intVAR_17;
intVAR_18 = FALSE;
intVAR_19 = 0;
intVAR_20 = FALSE;
fmark_TVAR_21;
#ifdef VAR_22
intVAR_23 = FALSE;
#endif
intVAR_24;
char_u**VAR_25;
intVAR_26;
intVAR_27 = FALSE;
char_u*VAR_28 = VAR_11->b_ffname;    
intVAR_29 = 1;
char_u*VAR_30 = NULL;
static intVAR_31 = 0;
static intVAR_32 = 0;  
static char_u**VAR_33 = NULL;
static intVAR_34;
#ifdef VAR_35
if (VAR_36)
{
emsg(_(VAR_37));
return FALSE;
}
#endif
#ifdef VAR_38
if (VAR_1 == VAR_39)
{
FreeWild(VAR_31, VAR_33);
# ifdef VAR_22
cs_free_tags();
# endif
VAR_31 = 0;
return FALSE;
}
#endif
if (VAR_1 == VAR_40)
{
VAR_1 = VAR_41;
VAR_18 = TRUE;
VAR_29 = 0;
}
VAR_14 = VAR_31;
free_string_option(VAR_42);
VAR_42 = NULL;
CLEAR_POS(&VAR_21.mark);
VAR_21.fnum = 0;
if ((!VAR_43 && *VAR_0 != VAR_44))
{
VAR_26 = FALSE;
VAR_15 = TRUE;
#if defined(VAR_45)
if (VAR_46 != 0)
{
tagstack_clear_entry(&VAR_47);
if ((VAR_47.tagname = vim_strsave(VAR_0)) == NULL)
goto end_do_tag;
}
#endif
}
else
{
#if defined(VAR_45)
if (VAR_46 != 0)
VAR_26 = FALSE;
else
#endif
VAR_26 = TRUE;
if (*VAR_0 != VAR_44
&& (VAR_1 == VAR_41 || VAR_1 == VAR_48 || VAR_1 == VAR_49
#ifdef VAR_45
|| VAR_1 == VAR_50
#endif
#ifdef VAR_22
|| VAR_1 == VAR_51
#endif
))
{
#if defined(VAR_45)
if (VAR_46 != 0)
{
if (VAR_47.tagname != NULL
&& STRCMP(VAR_47.tagname, VAR_0) == 0)
{
VAR_9 = VAR_47.cur_match;
VAR_10 = VAR_47.cur_fnum;
}
else
{
tagstack_clear_entry(&VAR_47);
if ((VAR_47.tagname = vim_strsave(VAR_0)) == NULL)
goto end_do_tag;
}
}
else
#endif
{
while (VAR_7 < VAR_8)
tagstack_clear_entry(&VAR_5[--VAR_8]);
if (++VAR_8 > VAR_52)
{
VAR_8 = VAR_52;
tagstack_clear_entry(&VAR_5[0]);
for (VAR_16 = 1; VAR_16 < VAR_8; ++VAR_16)
VAR_5[VAR_16 - 1] = VAR_5[VAR_16];
--VAR_7;
}
if ((VAR_5[VAR_7].tagname = vim_strsave(VAR_0)) == NULL)
{
VAR_6->w_tagstacklen = VAR_8 - 1;
goto end_do_tag;
}
VAR_6->w_tagstacklen = VAR_8;
VAR_20 = TRUE;
}
VAR_15 = TRUE;
}
else
{
if (
#if defined(VAR_45)
VAR_46 != 0 ? VAR_47.tagname == NULL :
#endif
VAR_8 == 0)
{
emsg(_(VAR_53));
goto end_do_tag;
}
if (VAR_1 == VAR_54)
{
#ifdef VAR_55
intVAR_56 = VAR_57;
#endif
if ((VAR_7 -= VAR_2) < 0)
{
emsg(_(VAR_58));
if (VAR_7 + VAR_2 == 0)
{
VAR_7 = 0;
goto end_do_tag;
}
VAR_7 = 0;
}
else if (VAR_7 >= VAR_8)    
{
emsg(_(VAR_59));
goto end_do_tag;
}
VAR_21 = VAR_5[VAR_7].fmark;
if (VAR_21.fnum != VAR_11->b_fnum)
{
if (buflist_getfile(VAR_21.fnum, VAR_21.mark.lnum,
VAR_60, VAR_3) == VAR_61)
{
VAR_7 = VAR_12;  
goto end_do_tag;
}
VAR_6->w_cursor.lnum = VAR_21.mark.lnum;
}
else
{
setpcmark();
VAR_6->w_cursor.lnum = VAR_21.mark.lnum;
}
VAR_6->w_cursor.col = VAR_21.mark.col;
VAR_6->w_set_curswant = TRUE;
check_cursor();
#ifdef VAR_55
if ((VAR_62 & VAR_63) && VAR_56)
foldOpenCursor();
#endif
FreeWild(VAR_31, VAR_33);
#ifdef VAR_22
cs_free_tags();
#endif
VAR_31 = 0;
tag_freematch();
goto end_do_tag;
}
if (VAR_1 == VAR_41
#if defined(VAR_45)
|| VAR_1 == VAR_50
#endif
)
{
#if defined(VAR_45)
if (VAR_46 != 0)
{
VAR_9 = VAR_47.cur_match;
VAR_10 = VAR_47.cur_fnum;
}
else
#endif
{
VAR_20 = TRUE;
if ((VAR_7 += VAR_2 - 1) >= VAR_8)
{
VAR_7 = VAR_8 - 1;
emsg(_(VAR_59));
VAR_20 = FALSE;
}
else if (VAR_7 < 0)
{
emsg(_(VAR_58));
VAR_7 = 0;
goto end_do_tag;
}
VAR_9 = VAR_5[VAR_7].cur_match;
VAR_10 = VAR_5[VAR_7].cur_fnum;
}
VAR_15 = TRUE;
}
else
{
VAR_13 = VAR_7;
#if defined(VAR_45)
if (VAR_46 != 0)
{
VAR_9 = VAR_47.cur_match;
VAR_10 = VAR_47.cur_fnum;
}
else
#endif
{
if (--VAR_7 < 0)
VAR_7 = 0;
VAR_9 = VAR_5[VAR_7].cur_match;
VAR_10 = VAR_5[VAR_7].cur_fnum;
}
switch (VAR_1)
{
case VAR_64: VAR_9 = VAR_2 - 1; break;
case VAR_48:
case VAR_49:
#ifdef VAR_22
case VAR_51:
#endif
case VAR_65:  VAR_9 = VAR_66 - 1; break;
case VAR_67:  VAR_9 += VAR_2; break;
case VAR_68:  VAR_9 -= VAR_2; break;
}
if (VAR_9 >= VAR_66)
VAR_9 = VAR_66 - 1;
else if (VAR_9 < 0)
{
emsg(_(VAR_69));
VAR_27 = TRUE;
VAR_9 = 0;
VAR_10 = VAR_11->b_fnum;
}
}
}
#if defined(VAR_45)
if (VAR_46 != 0)
{
if (VAR_1 != VAR_48 && VAR_1 != VAR_49)
{
VAR_47.cur_match = VAR_9;
VAR_47.cur_fnum = VAR_10;
}
}
else
#endif
{
VAR_21 = VAR_5[VAR_7].fmark;
if (VAR_20)
{
VAR_5[VAR_7].fmark.mark = VAR_6->w_cursor;
VAR_5[VAR_7].fmark.fnum = VAR_11->b_fnum;
}
VAR_6->w_tagstackidx = VAR_7;
if (VAR_1 != VAR_48 && VAR_1 != VAR_49)
{
VAR_6->w_tagstack[VAR_7].cur_match = VAR_9;
VAR_6->w_tagstack[VAR_7].cur_fnum = VAR_10;
}
}
}
if (VAR_10 != VAR_11->b_fnum)
{
buf_T *VAR_70 = buflist_findnr(VAR_10);
if (VAR_70 != NULL)
VAR_28 = VAR_70->b_ffname;
}
for (;;)
{
intVAR_71;
char_u*VAR_72;
if (VAR_26)
{
VAR_72 = vim_strsave(VAR_5[VAR_7].tagname);
vim_free(VAR_30);
VAR_30 = VAR_72;
}
#if defined(VAR_45)
else if (g_do_tagpreview != 0)
VAR_72 = VAR_47.tagname;
#endif
else
VAR_72 = VAR_0;
VAR_71 = (VAR_73 == NULL || STRCMP(VAR_73, VAR_72) != 0);
if (VAR_15
|| (VAR_9 >= VAR_31 && VAR_32 != VAR_66)
|| VAR_71)
{
if (VAR_71)
{
vim_free(VAR_73);
VAR_73 = vim_strsave(VAR_72);
}
if (VAR_1 == VAR_48 || VAR_1 == VAR_49
#if defined(VAR_45)
|| VAR_1 == VAR_50
#endif
)
VAR_9 = VAR_66 - 1;
if (VAR_1 == VAR_41)
VAR_32 = VAR_66;
else
VAR_32 = VAR_9 + 1;
if (!VAR_18 && *VAR_72 == '/')
{
VAR_34 = VAR_74;
++VAR_72;
}
else
VAR_34 = VAR_75;
#ifdef VAR_22
if (VAR_1 == VAR_51)
VAR_34 = VAR_76;
#endif
if (VAR_4)
VAR_34 |= VAR_77;
if (!VAR_29)
VAR_34 |= VAR_78;
if (find_tags(VAR_72, &VAR_24, &VAR_25, VAR_34,
VAR_32, VAR_28) == VAR_79
&& VAR_24 < VAR_32)
VAR_32 = VAR_66; 
if (!VAR_15 && !VAR_71)
{
int    VAR_80, VAR_81;
int    VAR_82 = 0;
tagptrs_T   VAR_83, VAR_84;
for (VAR_80 = 0; VAR_80 < VAR_31; ++VAR_80)
{
parse_match(VAR_33[VAR_80], &VAR_83);
for (VAR_16 = VAR_82; VAR_16 < VAR_24; ++VAR_16)
{
parse_match(VAR_25[VAR_16], &VAR_84);
if (STRCMP(VAR_83.tagname, VAR_84.tagname) == 0)
{
char_u *VAR_85 = VAR_25[VAR_16];
for (VAR_81 = VAR_16; VAR_81 > VAR_82; --VAR_81)
VAR_25[VAR_81] = VAR_25[VAR_81 - 1];
VAR_25[VAR_82++] = VAR_85;
break;
}
}
}
}
FreeWild(VAR_31, VAR_33);
VAR_31 = VAR_24;
VAR_33 = VAR_25;
}
if (VAR_31 <= 0)
{
if (VAR_4)
semsg(_(VAR_86), VAR_72);
#if defined(VAR_45)
g_do_tagpreview = 0;
#endif
}
else
{
int VAR_87 = FALSE;
#ifdef VAR_22
if (VAR_1 == VAR_51 && VAR_31 > 1)
{
cs_print_tags();
VAR_87 = TRUE;
}
else
#endif
if (VAR_1 == VAR_41 && *VAR_0 != VAR_44)
VAR_9 = VAR_2 > 0 ? VAR_2 - 1 : 0;
else if (VAR_1 == VAR_48 || (VAR_1 == VAR_49 && VAR_31 > 1))
{
print_tag_list(VAR_15, VAR_26, VAR_31, VAR_33);
VAR_87 = TRUE;
}
#if defined(VAR_45) && defined(VAR_35)
else if (type == VAR_50)
{
if (add_llist_tags(VAR_0, VAR_31, VAR_33) == VAR_61)
goto end_do_tag;
VAR_9 = 0;
}
#endif
if (VAR_87 == TRUE)
{
VAR_16 = prompt_for_number(NULL);
if (VAR_16 <= 0 || VAR_16 > VAR_31 || VAR_88)
{
if (VAR_26)
{
VAR_5[VAR_7].fmark = VAR_21;
VAR_7 = VAR_13;
}
#ifdef VAR_22
cs_free_tags();
VAR_23 = TRUE;
#endif
break;
}
VAR_9 = VAR_16 - 1;
}
if (VAR_9 >= VAR_31)
{
if ((type == VAR_67 || type == VAR_64)
&& VAR_42 == NULL)
{
if (VAR_31 == 1)
emsg(_(VAR_89));
else
emsg(_(VAR_90));
VAR_27 = TRUE;
}
VAR_9 = VAR_31 - 1;
}
if (VAR_26)
{
tagptrs_T   VAR_83;
VAR_5[VAR_7].cur_match = VAR_9;
VAR_5[VAR_7].cur_fnum = VAR_10;
if (VAR_29 && parse_match(VAR_33[VAR_9], &VAR_83) == VAR_79
&& VAR_83.user_data)
{
VIM_CLEAR(VAR_5[VAR_7].user_data);
VAR_5[VAR_7].user_data = vim_strnsave(
VAR_83.user_data, VAR_83.user_data_end - VAR_83.user_data);
}
++VAR_7;
}
#if defined(VAR_45)
else if (g_do_tagpreview != 0)
{
VAR_47.cur_match = VAR_9;
VAR_47.cur_fnum = VAR_10;
}
#endif
if (VAR_42 != NULL && VAR_19 != VAR_9)
smsg(_(""File \""%s\"" does not exist""), VAR_42);
VAR_17 = (VAR_33[VAR_9][0] & VAR_91);
if (type != VAR_41 && type != VAR_48 && type != VAR_49
#ifdef VAR_22
&& type != VAR_51
#endif
&& (VAR_31 > 1 || VAR_17)
&& !VAR_27)
{
sprintf((char *)VAR_92, _(""tag %d of %d%s""),
VAR_9 + 1,
VAR_31,
VAR_32 != VAR_66 ? _("" or more"") : """");
if (VAR_17)
STRCAT(VAR_92, _(""  Using tag with different case!""));
if ((VAR_31 > VAR_14 || VAR_15)
&& VAR_31 > 1)
{
if (VAR_17)
msg_attr((char *)VAR_92, HL_ATTR(VAR_93));
else
msg((char *)VAR_92);
VAR_94 = TRUE;
}
else
give_warning(VAR_92, VAR_17);
if (VAR_17 && !VAR_95 && VAR_96 == 0)
{
out_flush();
ui_delay(1007L, TRUE);
}
}
#if defined(VAR_35)
vim_snprintf((char *)VAR_92, VAR_97, "":ta %s\r"", VAR_72);
set_vim_var_string(VAR_98, VAR_92, -1);
#endif
VAR_16 = jumpto_tag(VAR_33[VAR_9], VAR_3, type != VAR_51);
#if defined(VAR_35)
set_vim_var_string(VAR_98, NULL, -1);
#endif
if (VAR_16 == VAR_99)
{
if ((type == VAR_68 && VAR_9 > 0)
|| ((type == VAR_41 || type == VAR_67
|| type == VAR_64)
&& (VAR_32 != VAR_66
|| VAR_9 < VAR_31 - 1)))
{
VAR_19 = VAR_9;
if (VAR_26)
--VAR_7;
if (type == VAR_68)
--VAR_9;
else
{
type = VAR_67;
++VAR_9;
}
continue;
}
semsg(_(VAR_100), VAR_42);
}
else
{
if (VAR_26 && VAR_7 > VAR_6->w_tagstacklen)
VAR_7 = VAR_6->w_tagstackidx;
#ifdef VAR_22
VAR_23 = TRUE;
#endif
}
}
break;
}
end_do_tag:
if (VAR_26 && VAR_7 <= VAR_6->w_tagstacklen)
VAR_6->w_tagstackidx = VAR_7;
VAR_101 = 0;
# ifdef VAR_45
g_do_tagpreview = 0;
# endif
vim_free(VAR_30);
#ifdef VAR_22
return VAR_23;
#else
return FALSE;
#endif
}",vim/ccfde4d028e891a41e3548323c3d47b06fb0b83e/tag.c/vul/before/0.json,"int
do_tag(
    char_u	*tag,		// tag (pattern) to jump to
    int		type,
    int		count,
    int		forceit,	// :ta with !
    int		verbose)	// print ""tag not found"" message
{
    taggy_T	*tagstack = curwin->w_tagstack;
    int		tagstackidx = curwin->w_tagstackidx;
    int		tagstacklen = curwin->w_tagstacklen;
    int		cur_match = 0;
    int		cur_fnum = curbuf->b_fnum;
    int		oldtagstackidx = tagstackidx;
    int		prevtagstackidx = tagstackidx;
    int		prev_num_matches;
    int		new_tag = FALSE;
    int		i;
    int		ic;
    int		no_regexp = FALSE;
    int		error_cur_match = 0;
    int		save_pos = FALSE;
    fmark_T	saved_fmark;
#ifdef FEAT_CSCOPE
    int		jumped_to_tag = FALSE;
#endif
    int		new_num_matches;
    char_u	**new_matches;
    int		use_tagstack;
    int		skip_msg = FALSE;
    char_u	*buf_ffname = curbuf->b_ffname;	    // name to use for
						    // priority computation
    int		use_tfu = 1;
    char_u	*tofree = NULL;

    // remember the matches for the last used tag
    static int		num_matches = 0;
    static int		max_num_matches = 0;  // limit used for match search
    static char_u	**matches = NULL;
    static int		flags;

#ifdef FEAT_EVAL
    if (tfu_in_use)
    {
	emsg(_(e_cannot_modify_tag_stack_within_tagfunc));
	return FALSE;
    }
#endif

#ifdef EXITFREE
    if (type == DT_FREE)
    {
	// remove the list of matches
	FreeWild(num_matches, matches);
# ifdef FEAT_CSCOPE
	cs_free_tags();
# endif
	num_matches = 0;
	return FALSE;
    }
#endif

    if (type == DT_HELP)
    {
	type = DT_TAG;
	no_regexp = TRUE;
	use_tfu = 0;
    }

    prev_num_matches = num_matches;
    free_string_option(nofile_fname);
    nofile_fname = NULL;

    CLEAR_POS(&saved_fmark.mark);	// shutup gcc 4.0
    saved_fmark.fnum = 0;

    /*
     * Don't add a tag to the tagstack if 'tagstack' has been reset.
     */
    if ((!p_tgst && *tag != NUL))
    {
	use_tagstack = FALSE;
	new_tag = TRUE;
#if defined(FEAT_QUICKFIX)
	if (g_do_tagpreview != 0)
	{
	    tagstack_clear_entry(&ptag_entry);
	    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)
		goto end_do_tag;
	}
#endif
    }
    else
    {
#if defined(FEAT_QUICKFIX)
	if (g_do_tagpreview != 0)
	    use_tagstack = FALSE;
	else
#endif
	    use_tagstack = TRUE;

	// new pattern, add to the tag stack
	if (*tag != NUL
		&& (type == DT_TAG || type == DT_SELECT || type == DT_JUMP
#ifdef FEAT_QUICKFIX
		    || type == DT_LTAG
#endif
#ifdef FEAT_CSCOPE
		    || type == DT_CSCOPE
#endif
		    ))
	{
#if defined(FEAT_QUICKFIX)
	    if (g_do_tagpreview != 0)
	    {
		if (ptag_entry.tagname != NULL
			&& STRCMP(ptag_entry.tagname, tag) == 0)
		{
		    // Jumping to same tag: keep the current match, so that
		    // the CursorHold autocommand example works.
		    cur_match = ptag_entry.cur_match;
		    cur_fnum = ptag_entry.cur_fnum;
		}
		else
		{
		    tagstack_clear_entry(&ptag_entry);
		    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)
			goto end_do_tag;
		}
	    }
	    else
#endif
	    {
		/*
		 * If the last used entry is not at the top, delete all tag
		 * stack entries above it.
		 */
		while (tagstackidx < tagstacklen)
		    tagstack_clear_entry(&tagstack[--tagstacklen]);

		// if the tagstack is full: remove oldest entry
		if (++tagstacklen > TAGSTACKSIZE)
		{
		    tagstacklen = TAGSTACKSIZE;
		    tagstack_clear_entry(&tagstack[0]);
		    for (i = 1; i < tagstacklen; ++i)
			tagstack[i - 1] = tagstack[i];
		    --tagstackidx;
		}

		/*
		 * put the tag name in the tag stack
		 */
		if ((tagstack[tagstackidx].tagname = vim_strsave(tag)) == NULL)
		{
		    curwin->w_tagstacklen = tagstacklen - 1;
		    goto end_do_tag;
		}
		curwin->w_tagstacklen = tagstacklen;

		save_pos = TRUE;	// save the cursor position below
	    }

	    new_tag = TRUE;
	}
	else
	{
	    if (
#if defined(FEAT_QUICKFIX)
		    g_do_tagpreview != 0 ? ptag_entry.tagname == NULL :
#endif
		    tagstacklen == 0)
	    {
		// empty stack
		emsg(_(e_tag_stack_empty));
		goto end_do_tag;
	    }

	    if (type == DT_POP)		// go to older position
	    {
#ifdef FEAT_FOLDING
		int	old_KeyTyped = KeyTyped;
#endif
		if ((tagstackidx -= count) < 0)
		{
		    emsg(_(e_at_bottom_of_tag_stack));
		    if (tagstackidx + count == 0)
		    {
			// We did [num]^T from the bottom of the stack
			tagstackidx = 0;
			goto end_do_tag;
		    }
		    // We weren't at the bottom of the stack, so jump all the
		    // way to the bottom now.
		    tagstackidx = 0;
		}
		else if (tagstackidx >= tagstacklen)    // count == 0?
		{
		    emsg(_(e_at_top_of_tag_stack));
		    goto end_do_tag;
		}

		// Make a copy of the fmark, autocommands may invalidate the
		// tagstack before it's used.
		saved_fmark = tagstack[tagstackidx].fmark;
		if (saved_fmark.fnum != curbuf->b_fnum)
		{
		    /*
		     * Jump to other file. If this fails (e.g. because the
		     * file was changed) keep original position in tag stack.
		     */
		    if (buflist_getfile(saved_fmark.fnum, saved_fmark.mark.lnum,
					       GETF_SETMARK, forceit) == FAIL)
		    {
			tagstackidx = oldtagstackidx;  // back to old posn
			goto end_do_tag;
		    }
		    // An BufReadPost autocommand may jump to the '"" mark, but
		    // we don't what that here.
		    curwin->w_cursor.lnum = saved_fmark.mark.lnum;
		}
		else
		{
		    setpcmark();
		    curwin->w_cursor.lnum = saved_fmark.mark.lnum;
		}
		curwin->w_cursor.col = saved_fmark.mark.col;
		curwin->w_set_curswant = TRUE;
		check_cursor();
#ifdef FEAT_FOLDING
		if ((fdo_flags & FDO_TAG) && old_KeyTyped)
		    foldOpenCursor();
#endif

		// remove the old list of matches
		FreeWild(num_matches, matches);
#ifdef FEAT_CSCOPE
		cs_free_tags();
#endif
		num_matches = 0;
		tag_freematch();
		goto end_do_tag;
	    }

	    if (type == DT_TAG
#if defined(FEAT_QUICKFIX)
		    || type == DT_LTAG
#endif
	       )
	    {
#if defined(FEAT_QUICKFIX)
		if (g_do_tagpreview != 0)
		{
		    cur_match = ptag_entry.cur_match;
		    cur_fnum = ptag_entry.cur_fnum;
		}
		else
#endif
		{
		    // "":tag"" (no argument): go to newer pattern
		    save_pos = TRUE;	// save the cursor position below
		    if ((tagstackidx += count - 1) >= tagstacklen)
		    {
			/*
			 * Beyond the last one, just give an error message and
			 * go to the last one.  Don't store the cursor
			 * position.
			 */
			tagstackidx = tagstacklen - 1;
			emsg(_(e_at_top_of_tag_stack));
			save_pos = FALSE;
		    }
		    else if (tagstackidx < 0)	// must have been count == 0
		    {
			emsg(_(e_at_bottom_of_tag_stack));
			tagstackidx = 0;
			goto end_do_tag;
		    }
		    cur_match = tagstack[tagstackidx].cur_match;
		    cur_fnum = tagstack[tagstackidx].cur_fnum;
		}
		new_tag = TRUE;
	    }
	    else				// go to other matching tag
	    {
		// Save index for when selection is cancelled.
		prevtagstackidx = tagstackidx;

#if defined(FEAT_QUICKFIX)
		if (g_do_tagpreview != 0)
		{
		    cur_match = ptag_entry.cur_match;
		    cur_fnum = ptag_entry.cur_fnum;
		}
		else
#endif
		{
		    if (--tagstackidx < 0)
			tagstackidx = 0;
		    cur_match = tagstack[tagstackidx].cur_match;
		    cur_fnum = tagstack[tagstackidx].cur_fnum;
		}
		switch (type)
		{
		    case DT_FIRST: cur_match = count - 1; break;
		    case DT_SELECT:
		    case DT_JUMP:
#ifdef FEAT_CSCOPE
		    case DT_CSCOPE:
#endif
		    case DT_LAST:  cur_match = MAXCOL - 1; break;
		    case DT_NEXT:  cur_match += count; break;
		    case DT_PREV:  cur_match -= count; break;
		}
		if (cur_match >= MAXCOL)
		    cur_match = MAXCOL - 1;
		else if (cur_match < 0)
		{
		    emsg(_(e_cannot_go_before_first_matching_tag));
		    skip_msg = TRUE;
		    cur_match = 0;
		    cur_fnum = curbuf->b_fnum;
		}
	    }
	}

#if defined(FEAT_QUICKFIX)
	if (g_do_tagpreview != 0)
	{
	    if (type != DT_SELECT && type != DT_JUMP)
	    {
		ptag_entry.cur_match = cur_match;
		ptag_entry.cur_fnum = cur_fnum;
	    }
	}
	else
#endif
	{
	    /*
	     * For "":tag [arg]"" or "":tselect"" remember position before the jump.
	     */
	    saved_fmark = tagstack[tagstackidx].fmark;
	    if (save_pos)
	    {
		tagstack[tagstackidx].fmark.mark = curwin->w_cursor;
		tagstack[tagstackidx].fmark.fnum = curbuf->b_fnum;
	    }

	    // Curwin will change in the call to jumpto_tag() if "":stag"" was
	    // used or an autocommand jumps to another window; store value of
	    // tagstackidx now.
	    curwin->w_tagstackidx = tagstackidx;
	    if (type != DT_SELECT && type != DT_JUMP)
	    {
		curwin->w_tagstack[tagstackidx].cur_match = cur_match;
		curwin->w_tagstack[tagstackidx].cur_fnum = cur_fnum;
	    }
	}
    }

    // When not using the current buffer get the name of buffer ""cur_fnum"".
    // Makes sure that the tag order doesn't change when using a remembered
    // position for ""cur_match"".
    if (cur_fnum != curbuf->b_fnum)
    {
	buf_T *buf = buflist_findnr(cur_fnum);

	if (buf != NULL)
	    buf_ffname = buf->b_ffname;
    }

    /*
     * Repeat searching for tags, when a file has not been found.
     */
    for (;;)
    {
	int	other_name;
	char_u	*name;

	/*
	 * When desired match not found yet, try to find it (and others).
	 */
	if (use_tagstack)
	{
	    // make a copy, the tagstack may change in 'tagfunc'
	    name = vim_strsave(tagstack[tagstackidx].tagname);
	    vim_free(tofree);
	    tofree = name;
	}
#if defined(FEAT_QUICKFIX)
	else if (g_do_tagpreview != 0)
	    name = ptag_entry.tagname;
#endif
	else
	    name = tag;
	other_name = (tagmatchname == NULL || STRCMP(tagmatchname, name) != 0);
	if (new_tag
		|| (cur_match >= num_matches && max_num_matches != MAXCOL)
		|| other_name)
	{
	    if (other_name)
	    {
		vim_free(tagmatchname);
		tagmatchname = vim_strsave(name);
	    }

	    if (type == DT_SELECT || type == DT_JUMP
#if defined(FEAT_QUICKFIX)
		|| type == DT_LTAG
#endif
		)
		cur_match = MAXCOL - 1;
	    if (type == DT_TAG)
		max_num_matches = MAXCOL;
	    else
		max_num_matches = cur_match + 1;

	    // when the argument starts with '/', use it as a regexp
	    if (!no_regexp && *name == '/')
	    {
		flags = TAG_REGEXP;
		++name;
	    }
	    else
		flags = TAG_NOIC;

#ifdef FEAT_CSCOPE
	    if (type == DT_CSCOPE)
		flags = TAG_CSCOPE;
#endif
	    if (verbose)
		flags |= TAG_VERBOSE;

	    if (!use_tfu)
		flags |= TAG_NO_TAGFUNC;

	    if (find_tags(name, &new_num_matches, &new_matches, flags,
					    max_num_matches, buf_ffname) == OK
		    && new_num_matches < max_num_matches)
		max_num_matches = MAXCOL; // If less than max_num_matches
					  // found: all matches found.

	    // A tag function may do anything, which may cause various
	    // information to become invalid.  At least check for the tagstack
	    // to still be the same.
	    if (tagstack != curwin->w_tagstack)
	    {
		emsg(_(e_window_unexpectedly_close_while_searching_for_tags));
		FreeWild(new_num_matches, new_matches);
		break;
	    }

	    // If there already were some matches for the same name, move them
	    // to the start.  Avoids that the order changes when using
	    // "":tnext"" and jumping to another file.
	    if (!new_tag && !other_name)
	    {
		int	    j, k;
		int	    idx = 0;
		tagptrs_T   tagp, tagp2;

		// Find the position of each old match in the new list.  Need
		// to use parse_match() to find the tag line.
		for (j = 0; j < num_matches; ++j)
		{
		    parse_match(matches[j], &tagp);
		    for (i = idx; i < new_num_matches; ++i)
		    {
			parse_match(new_matches[i], &tagp2);
			if (STRCMP(tagp.tagname, tagp2.tagname) == 0)
			{
			    char_u *p = new_matches[i];
			    for (k = i; k > idx; --k)
				new_matches[k] = new_matches[k - 1];
			    new_matches[idx++] = p;
			    break;
			}
		    }
		}
	    }
	    FreeWild(num_matches, matches);
	    num_matches = new_num_matches;
	    matches = new_matches;
	}

	if (num_matches <= 0)
	{
	    if (verbose)
		semsg(_(e_tag_not_found_str), name);
#if defined(FEAT_QUICKFIX)
	    g_do_tagpreview = 0;
#endif
	}
	else
	{
	    int ask_for_selection = FALSE;

#ifdef FEAT_CSCOPE
	    if (type == DT_CSCOPE && num_matches > 1)
	    {
		cs_print_tags();
		ask_for_selection = TRUE;
	    }
	    else
#endif
	    if (type == DT_TAG && *tag != NUL)
		// If a count is supplied to the "":tag <name>"" command, then
		// jump to count'th matching tag.
		cur_match = count > 0 ? count - 1 : 0;
	    else if (type == DT_SELECT || (type == DT_JUMP && num_matches > 1))
	    {
		print_tag_list(new_tag, use_tagstack, num_matches, matches);
		ask_for_selection = TRUE;
	    }
#if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)
	    else if (type == DT_LTAG)
	    {
		if (add_llist_tags(tag, num_matches, matches) == FAIL)
		    goto end_do_tag;
		cur_match = 0;		// Jump to the first tag
	    }
#endif

	    if (ask_for_selection == TRUE)
	    {
		/*
		 * Ask to select a tag from the list.
		 */
		i = prompt_for_number(NULL);
		if (i <= 0 || i > num_matches || got_int)
		{
		    // no valid choice: don't change anything
		    if (use_tagstack)
		    {
			tagstack[tagstackidx].fmark = saved_fmark;
			tagstackidx = prevtagstackidx;
		    }
#ifdef FEAT_CSCOPE
		    cs_free_tags();
		    jumped_to_tag = TRUE;
#endif
		    break;
		}
		cur_match = i - 1;
	    }

	    if (cur_match >= num_matches)
	    {
		// Avoid giving this error when a file wasn't found and we're
		// looking for a match in another file, which wasn't found.
		// There will be an emsg(""file doesn't exist"") below then.
		if ((type == DT_NEXT || type == DT_FIRST)
						      && nofile_fname == NULL)
		{
		    if (num_matches == 1)
			emsg(_(e_there_is_only_one_matching_tag));
		    else
			emsg(_(e_cannot_go_beyond_last_matching_tag));
		    skip_msg = TRUE;
		}
		cur_match = num_matches - 1;
	    }
	    if (use_tagstack)
	    {
		tagptrs_T   tagp;

		tagstack[tagstackidx].cur_match = cur_match;
		tagstack[tagstackidx].cur_fnum = cur_fnum;

		// store user-provided data originating from tagfunc
		if (use_tfu && parse_match(matches[cur_match], &tagp) == OK
			&& tagp.user_data)
		{
		    VIM_CLEAR(tagstack[tagstackidx].user_data);
		    tagstack[tagstackidx].user_data = vim_strnsave(
			  tagp.user_data, tagp.user_data_end - tagp.user_data);
		}

		++tagstackidx;
	    }
#if defined(FEAT_QUICKFIX)
	    else if (g_do_tagpreview != 0)
	    {
		ptag_entry.cur_match = cur_match;
		ptag_entry.cur_fnum = cur_fnum;
	    }
#endif

	    /*
	     * Only when going to try the next match, report that the previous
	     * file didn't exist.  Otherwise an emsg() is given below.
	     */
	    if (nofile_fname != NULL && error_cur_match != cur_match)
		smsg(_(""File \""%s\"" does not exist""), nofile_fname);


	    ic = (matches[cur_match][0] & MT_IC_OFF);
	    if (type != DT_TAG && type != DT_SELECT && type != DT_JUMP
#ifdef FEAT_CSCOPE
		&& type != DT_CSCOPE
#endif
		&& (num_matches > 1 || ic)
		&& !skip_msg)
	    {
		// Give an indication of the number of matching tags
		sprintf((char *)IObuff, _(""tag %d of %d%s""),
				cur_match + 1,
				num_matches,
				max_num_matches != MAXCOL ? _("" or more"") : """");
		if (ic)
		    STRCAT(IObuff, _(""  Using tag with different case!""));
		if ((num_matches > prev_num_matches || new_tag)
							   && num_matches > 1)
		{
		    if (ic)
			msg_attr((char *)IObuff, HL_ATTR(HLF_W));
		    else
			msg((char *)IObuff);
		    msg_scroll = TRUE;	// don't overwrite this message
		}
		else
		    give_warning(IObuff, ic);
		if (ic && !msg_scrolled && msg_silent == 0)
		{
		    out_flush();
		    ui_delay(1007L, TRUE);
		}
	    }

#if defined(FEAT_EVAL)
	    // Let the SwapExists event know what tag we are jumping to.
	    vim_snprintf((char *)IObuff, IOSIZE, "":ta %s\r"", name);
	    set_vim_var_string(VV_SWAPCOMMAND, IObuff, -1);
#endif

	    /*
	     * Jump to the desired match.
	     */
	    i = jumpto_tag(matches[cur_match], forceit, type != DT_CSCOPE);

#if defined(FEAT_EVAL)
	    set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);
#endif

	    if (i == NOTAGFILE)
	    {
		// File not found: try again with another matching tag
		if ((type == DT_PREV && cur_match > 0)
			|| ((type == DT_TAG || type == DT_NEXT
							  || type == DT_FIRST)
			    && (max_num_matches != MAXCOL
					     || cur_match < num_matches - 1)))
		{
		    error_cur_match = cur_match;
		    if (use_tagstack)
			--tagstackidx;
		    if (type == DT_PREV)
			--cur_match;
		    else
		    {
			type = DT_NEXT;
			++cur_match;
		    }
		    continue;
		}
		semsg(_(e_file_str_does_not_exist), nofile_fname);
	    }
	    else
	    {
		// We may have jumped to another window, check that
		// tagstackidx is still valid.
		if (use_tagstack && tagstackidx > curwin->w_tagstacklen)
		    tagstackidx = curwin->w_tagstackidx;
#ifdef FEAT_CSCOPE
		jumped_to_tag = TRUE;
#endif
	    }
	}
	break;
    }

end_do_tag:
    // Only store the new index when using the tagstack and it's valid.
    if (use_tagstack && tagstackidx <= curwin->w_tagstacklen)
	curwin->w_tagstackidx = tagstackidx;
    postponed_split = 0;	// don't split next time
# ifdef FEAT_QUICKFIX
    g_do_tagpreview = 0;	// don't do tag preview next time
# endif

    vim_free(tofree);
#ifdef FEAT_CSCOPE
    return jumped_to_tag;
#else
    return FALSE;
#endif
}","int
do_tag(
    char_u	*VAR_0,		/* COMMENT_0 */
    int		VAR_1,
    int		VAR_2,
    int		VAR_3,	/* COMMENT_1 */
    int		VAR_4)	/* COMMENT_2 */
{
    taggy_T	*VAR_5 = VAR_6->w_tagstack;
    int		VAR_7 = VAR_6->w_tagstackidx;
    int		VAR_8 = VAR_6->w_tagstacklen;
    int		VAR_9 = 0;
    int		VAR_10 = VAR_11->b_fnum;
    int		VAR_12 = VAR_7;
    int		VAR_13 = VAR_7;
    int		VAR_14;
    int		VAR_15 = FALSE;
    int		VAR_16;
    int		VAR_17;
    int		VAR_18 = FALSE;
    int		VAR_19 = 0;
    int		VAR_20 = FALSE;
    fmark_T	VAR_21;
#ifdef VAR_22
    int		VAR_23 = FALSE;
#endif
    int		VAR_24;
    char_u	**VAR_25;
    int		VAR_26;
    int		VAR_27 = FALSE;
    char_u	*VAR_28 = VAR_11->b_ffname;	    /* COMMENT_3 */
						    /* COMMENT_4 */
    int		VAR_29 = 1;
    char_u	*VAR_30 = NULL;

    /* COMMENT_5 */
    static int		VAR_31 = 0;
    static int		VAR_32 = 0;  /* COMMENT_6 */
    static char_u	**VAR_33 = NULL;
    static int		VAR_34;

#ifdef VAR_35
    if (VAR_36)
    {
	emsg(_(VAR_37));
	return FALSE;
    }
#endif

#ifdef VAR_38
    if (VAR_1 == VAR_39)
    {
	/* COMMENT_7 */
	FreeWild(VAR_31, VAR_33);
# ifdef VAR_22
	cs_free_tags();
# endif
	VAR_31 = 0;
	return FALSE;
    }
#endif

    if (VAR_1 == VAR_40)
    {
	VAR_1 = VAR_41;
	VAR_18 = TRUE;
	VAR_29 = 0;
    }

    VAR_14 = VAR_31;
    free_string_option(VAR_42);
    VAR_42 = NULL;

    CLEAR_POS(&VAR_21.mark);	/* COMMENT_8 */
    VAR_21.fnum = 0;

    /* COMMENT_9 */
                                                                    
       
    if ((!VAR_43 && *VAR_0 != VAR_44))
    {
	VAR_26 = FALSE;
	VAR_15 = TRUE;
#if defined(VAR_45)
	if (VAR_46 != 0)
	{
	    tagstack_clear_entry(&VAR_47);
	    if ((VAR_47.tagname = vim_strsave(VAR_0)) == NULL)
		goto end_do_tag;
	}
#endif
    }
    else
    {
#if defined(VAR_45)
	if (VAR_46 != 0)
	    VAR_26 = FALSE;
	else
#endif
	    VAR_26 = TRUE;

	/* COMMENT_12 */
	if (*VAR_0 != VAR_44
		&& (VAR_1 == VAR_41 || VAR_1 == VAR_48 || VAR_1 == VAR_49
#ifdef VAR_45
		    || VAR_1 == VAR_50
#endif
#ifdef VAR_22
		    || VAR_1 == VAR_51
#endif
		    ))
	{
#if defined(VAR_45)
	    if (VAR_46 != 0)
	    {
		if (VAR_47.tagname != NULL
			&& STRCMP(VAR_47.tagname, VAR_0) == 0)
		{
		    /* COMMENT_13 */
		    /* COMMENT_14 */
		    VAR_9 = VAR_47.cur_match;
		    VAR_10 = VAR_47.cur_fnum;
		}
		else
		{
		    tagstack_clear_entry(&VAR_47);
		    if ((VAR_47.tagname = vim_strsave(VAR_0)) == NULL)
			goto end_do_tag;
		}
	    }
	    else
#endif
	    {
		/* COMMENT_15 */
                                                             
                            
     
		while (VAR_7 < VAR_8)
		    tagstack_clear_entry(&VAR_5[--VAR_8]);

		/* COMMENT_19 */
		if (++VAR_8 > VAR_52)
		{
		    VAR_8 = VAR_52;
		    tagstack_clear_entry(&VAR_5[0]);
		    for (VAR_16 = 1; VAR_16 < VAR_8; ++VAR_16)
			VAR_5[VAR_16 - 1] = VAR_5[VAR_16];
		    --VAR_7;
		}

		/* COMMENT_20 */
                                      
     
		if ((VAR_5[VAR_7].tagname = vim_strsave(VAR_0)) == NULL)
		{
		    VAR_6->w_tagstacklen = VAR_8 - 1;
		    goto end_do_tag;
		}
		VAR_6->w_tagstacklen = VAR_8;

		VAR_20 = TRUE;	/* COMMENT_23 */
	    }

	    VAR_15 = TRUE;
	}
	else
	{
	    if (
#if defined(VAR_45)
		    VAR_46 != 0 ? VAR_47.tagname == NULL :
#endif
		    VAR_8 == 0)
	    {
		/* COMMENT_24 */
		emsg(_(VAR_53));
		goto end_do_tag;
	    }

	    if (VAR_1 == VAR_54)		/* COMMENT_25 */
	    {
#ifdef VAR_55
		int	VAR_56 = VAR_57;
#endif
		if ((VAR_7 -= VAR_2) < 0)
		{
		    emsg(_(VAR_58));
		    if (VAR_7 + VAR_2 == 0)
		    {
			/* COMMENT_26 */
			VAR_7 = 0;
			goto end_do_tag;
		    }
		    /* COMMENT_27 */
		    /* COMMENT_28 */
		    VAR_7 = 0;
		}
		else if (VAR_7 >= VAR_8)    /* COMMENT_29 */
		{
		    emsg(_(VAR_59));
		    goto end_do_tag;
		}

		/* COMMENT_30 */
		/* COMMENT_31 */
		VAR_21 = VAR_5[VAR_7].fmark;
		if (VAR_21.fnum != VAR_11->b_fnum)
		{
		    /* COMMENT_32 */
                                                            
                                                               
         
		    if (buflist_getfile(VAR_21.fnum, VAR_21.mark.lnum,
					       VAR_60, VAR_3) == VAR_61)
		    {
			VAR_7 = VAR_12;  /* COMMENT_36 */
			goto end_do_tag;
		    }
		    /* COMMENT_37 */
		    /* COMMENT_38 */
		    VAR_6->w_cursor.lnum = VAR_21.mark.lnum;
		}
		else
		{
		    setpcmark();
		    VAR_6->w_cursor.lnum = VAR_21.mark.lnum;
		}
		VAR_6->w_cursor.col = VAR_21.mark.col;
		VAR_6->w_set_curswant = TRUE;
		check_cursor();
#ifdef VAR_55
		if ((VAR_62 & VAR_63) && VAR_56)
		    foldOpenCursor();
#endif

		/* COMMENT_39 */
		FreeWild(VAR_31, VAR_33);
#ifdef VAR_22
		cs_free_tags();
#endif
		VAR_31 = 0;
		tag_freematch();
		goto end_do_tag;
	    }

	    if (VAR_1 == VAR_41
#if defined(VAR_45)
		    || VAR_1 == VAR_50
#endif
	       )
	    {
#if defined(VAR_45)
		if (VAR_46 != 0)
		{
		    VAR_9 = VAR_47.cur_match;
		    VAR_10 = VAR_47.cur_fnum;
		}
		else
#endif
		{
		    /* COMMENT_40 */
		    VAR_20 = TRUE;	/* COMMENT_23 */
		    if ((VAR_7 += VAR_2 - 1) >= VAR_8)
		    {
			/* COMMENT_41 */
                                                         
                                                 
               
      
			VAR_7 = VAR_8 - 1;
			emsg(_(VAR_59));
			VAR_20 = FALSE;
		    }
		    else if (VAR_7 < 0)	/* COMMENT_46 */
		    {
			emsg(_(VAR_58));
			VAR_7 = 0;
			goto end_do_tag;
		    }
		    VAR_9 = VAR_5[VAR_7].cur_match;
		    VAR_10 = VAR_5[VAR_7].cur_fnum;
		}
		VAR_15 = TRUE;
	    }
	    else				/* COMMENT_47 */
	    {
		/* COMMENT_48 */
		VAR_13 = VAR_7;

#if defined(VAR_45)
		if (VAR_46 != 0)
		{
		    VAR_9 = VAR_47.cur_match;
		    VAR_10 = VAR_47.cur_fnum;
		}
		else
#endif
		{
		    if (--VAR_7 < 0)
			VAR_7 = 0;
		    VAR_9 = VAR_5[VAR_7].cur_match;
		    VAR_10 = VAR_5[VAR_7].cur_fnum;
		}
		switch (VAR_1)
		{
		    case VAR_64: VAR_9 = VAR_2 - 1; break;
		    case VAR_48:
		    case VAR_49:
#ifdef VAR_22
		    case VAR_51:
#endif
		    case VAR_65:  VAR_9 = VAR_66 - 1; break;
		    case VAR_67:  VAR_9 += VAR_2; break;
		    case VAR_68:  VAR_9 -= VAR_2; break;
		}
		if (VAR_9 >= VAR_66)
		    VAR_9 = VAR_66 - 1;
		else if (VAR_9 < 0)
		{
		    emsg(_(VAR_69));
		    VAR_27 = TRUE;
		    VAR_9 = 0;
		    VAR_10 = VAR_11->b_fnum;
		}
	    }
	}

#if defined(VAR_45)
	if (VAR_46 != 0)
	{
	    if (VAR_1 != VAR_48 && VAR_1 != VAR_49)
	    {
		VAR_47.cur_match = VAR_9;
		VAR_47.cur_fnum = VAR_10;
	    }
	}
	else
#endif
	{
	    /* COMMENT_49 */
                                                                         
        
	    VAR_21 = VAR_5[VAR_7].fmark;
	    if (VAR_20)
	    {
		VAR_5[VAR_7].fmark.mark = VAR_6->w_cursor;
		VAR_5[VAR_7].fmark.fnum = VAR_11->b_fnum;
	    }

	    /* COMMENT_52 */
	    /* COMMENT_53 */
	    /* COMMENT_54 */
	    VAR_6->w_tagstackidx = VAR_7;
	    if (VAR_1 != VAR_48 && VAR_1 != VAR_49)
	    {
		VAR_6->w_tagstack[VAR_7].cur_match = VAR_9;
		VAR_6->w_tagstack[VAR_7].cur_fnum = VAR_10;
	    }
	}
    }

    /* COMMENT_55 */
    /* COMMENT_56 */
    /* COMMENT_57 */
    if (VAR_10 != VAR_11->b_fnum)
    {
	buf_T *VAR_70 = buflist_findnr(VAR_10);

	if (VAR_70 != NULL)
	    VAR_28 = VAR_70->b_ffname;
    }

    /* COMMENT_58 */
                                                                 
       
    for (;;)
    {
	int	VAR_71;
	char_u	*VAR_72;

	/* COMMENT_61 */
                                                                  
    
	if (VAR_26)
	{
	    /* COMMENT_64 */
	    VAR_72 = vim_strsave(VAR_5[VAR_7].tagname);
	    vim_free(VAR_30);
	    VAR_30 = VAR_72;
	}
#if defined(VAR_45)
	else if (g_do_tagpreview != 0)
	    VAR_72 = VAR_47.tagname;
#endif
	else
	    VAR_72 = VAR_0;
	VAR_71 = (VAR_73 == NULL || STRCMP(VAR_73, VAR_72) != 0);
	if (VAR_15
		|| (VAR_9 >= VAR_31 && VAR_32 != VAR_66)
		|| VAR_71)
	{
	    if (VAR_71)
	    {
		vim_free(VAR_73);
		VAR_73 = vim_strsave(VAR_72);
	    }

	    if (VAR_1 == VAR_48 || VAR_1 == VAR_49
#if defined(VAR_45)
		|| VAR_1 == VAR_50
#endif
		)
		VAR_9 = VAR_66 - 1;
	    if (VAR_1 == VAR_41)
		VAR_32 = VAR_66;
	    else
		VAR_32 = VAR_9 + 1;

	    /* COMMENT_65 */
	    if (!VAR_18 && *VAR_72 == '/')
	    {
		VAR_34 = VAR_74;
		++VAR_72;
	    }
	    else
		VAR_34 = VAR_75;

#ifdef VAR_22
	    if (VAR_1 == VAR_51)
		VAR_34 = VAR_76;
#endif
	    if (VAR_4)
		VAR_34 |= VAR_77;

	    if (!VAR_29)
		VAR_34 |= VAR_78;

	    if (find_tags(VAR_72, &VAR_24, &VAR_25, VAR_34,
					    VAR_32, VAR_28) == VAR_79
		    && VAR_24 < VAR_32)
		VAR_32 = VAR_66; /* COMMENT_66 */
					  /* COMMENT_67 */

	    /* COMMENT_68 */
	    /* COMMENT_69 */
	    /* COMMENT_70 */
	    if (VAR_5 != VAR_6->w_tagstack)
	    {
		emsg(_(VAR_80));
		FreeWild(VAR_24, VAR_25);
		break;
	    }

	    /* COMMENT_71 */
	    /* COMMENT_72 */
	    /* COMMENT_73 */
	    if (!VAR_15 && !VAR_71)
	    {
		int	    VAR_81, VAR_82;
		int	    VAR_83 = 0;
		tagptrs_T   VAR_84, VAR_85;

		/* COMMENT_74 */
		/* COMMENT_75 */
		for (VAR_81 = 0; VAR_81 < VAR_31; ++VAR_81)
		{
		    parse_match(VAR_33[VAR_81], &VAR_84);
		    for (VAR_16 = VAR_83; VAR_16 < VAR_24; ++VAR_16)
		    {
			parse_match(VAR_25[VAR_16], &VAR_85);
			if (STRCMP(VAR_84.tagname, VAR_85.tagname) == 0)
			{
			    char_u *VAR_86 = VAR_25[VAR_16];
			    for (VAR_82 = VAR_16; VAR_82 > VAR_83; --VAR_82)
				VAR_25[VAR_82] = VAR_25[VAR_82 - 1];
			    VAR_25[VAR_83++] = VAR_86;
			    break;
			}
		    }
		}
	    }
	    FreeWild(VAR_31, VAR_33);
	    VAR_31 = VAR_24;
	    VAR_33 = VAR_25;
	}

	if (VAR_31 <= 0)
	{
	    if (VAR_4)
		semsg(_(VAR_87), VAR_72);
#if defined(VAR_45)
	    g_do_tagpreview = 0;
#endif
	}
	else
	{
	    int VAR_88 = FALSE;

#ifdef VAR_22
	    if (VAR_1 == VAR_51 && VAR_31 > 1)
	    {
		cs_print_tags();
		VAR_88 = TRUE;
	    }
	    else
#endif
	    if (VAR_1 == VAR_41 && *VAR_0 != VAR_44)
		/* COMMENT_76 */
		/* COMMENT_77 */
		VAR_9 = VAR_2 > 0 ? VAR_2 - 1 : 0;
	    else if (VAR_1 == VAR_48 || (VAR_1 == VAR_49 && VAR_31 > 1))
	    {
		print_tag_list(VAR_15, VAR_26, VAR_31, VAR_33);
		VAR_88 = TRUE;
	    }
#if defined(VAR_45) && defined(VAR_35)
	    else if (type == VAR_50)
	    {
		if (add_llist_tags(VAR_0, VAR_31, VAR_33) == VAR_61)
		    goto end_do_tag;
		VAR_9 = 0;		/* COMMENT_78 */
	    }
#endif

	    if (VAR_88 == TRUE)
	    {
		/* COMMENT_79 */
                                       
     
		VAR_16 = prompt_for_number(NULL);
		if (VAR_16 <= 0 || VAR_16 > VAR_31 || VAR_89)
		{
		    /* COMMENT_82 */
		    if (VAR_26)
		    {
			VAR_5[VAR_7].fmark = VAR_21;
			VAR_7 = VAR_13;
		    }
#ifdef VAR_22
		    cs_free_tags();
		    VAR_23 = TRUE;
#endif
		    break;
		}
		VAR_9 = VAR_16 - 1;
	    }

	    if (VAR_9 >= VAR_31)
	    {
		/* COMMENT_83 */
		/* COMMENT_84 */
		/* COMMENT_85 */
		if ((type == VAR_67 || type == VAR_64)
						      && VAR_42 == NULL)
		{
		    if (VAR_31 == 1)
			emsg(_(VAR_90));
		    else
			emsg(_(VAR_91));
		    VAR_27 = TRUE;
		}
		VAR_9 = VAR_31 - 1;
	    }
	    if (VAR_26)
	    {
		tagptrs_T   VAR_84;

		VAR_5[VAR_7].cur_match = VAR_9;
		VAR_5[VAR_7].cur_fnum = VAR_10;

		/* COMMENT_86 */
		if (VAR_29 && parse_match(VAR_33[VAR_9], &VAR_84) == VAR_79
			&& VAR_84.user_data)
		{
		    VIM_CLEAR(VAR_5[VAR_7].user_data);
		    VAR_5[VAR_7].user_data = vim_strnsave(
			  VAR_84.user_data, VAR_84.user_data_end - VAR_84.user_data);
		}

		++VAR_7;
	    }
#if defined(VAR_45)
	    else if (g_do_tagpreview != 0)
	    {
		VAR_47.cur_match = VAR_9;
		VAR_47.cur_fnum = VAR_10;
	    }
#endif

	    /* COMMENT_87 */
                                                                       
                                                               
        
	    if (VAR_42 != NULL && VAR_19 != VAR_9)
		smsg(_(""File \""%s\"" does not exist""), VAR_42);


	    VAR_17 = (VAR_33[VAR_9][0] & VAR_92);
	    if (type != VAR_41 && type != VAR_48 && type != VAR_49
#ifdef VAR_22
		&& type != VAR_51
#endif
		&& (VAR_31 > 1 || VAR_17)
		&& !VAR_27)
	    {
		/* COMMENT_91 */
		sprintf((char *)VAR_93, _(""tag %d of %d%s""),
				VAR_9 + 1,
				VAR_31,
				VAR_32 != VAR_66 ? _("" or more"") : """");
		if (VAR_17)
		    STRCAT(VAR_93, _(""  Using tag with different case!""));
		if ((VAR_31 > VAR_14 || VAR_15)
							   && VAR_31 > 1)
		{
		    if (VAR_17)
			msg_attr((char *)VAR_93, HL_ATTR(VAR_94));
		    else
			msg((char *)VAR_93);
		    VAR_95 = TRUE;	/* COMMENT_92 */
		}
		else
		    give_warning(VAR_93, VAR_17);
		if (VAR_17 && !VAR_96 && VAR_97 == 0)
		{
		    out_flush();
		    ui_delay(1007L, TRUE);
		}
	    }

#if defined(VAR_35)
	    /* COMMENT_93 */
	    vim_snprintf((char *)VAR_93, VAR_98, "":ta %s\r"", VAR_72);
	    set_vim_var_string(VAR_99, VAR_93, -1);
#endif

	    /* COMMENT_94 */
                                  
        
	    VAR_16 = jumpto_tag(VAR_33[VAR_9], VAR_3, type != VAR_51);

#if defined(VAR_35)
	    set_vim_var_string(VAR_99, NULL, -1);
#endif

	    if (VAR_16 == VAR_100)
	    {
		/* COMMENT_97 */
		if ((type == VAR_68 && VAR_9 > 0)
			|| ((type == VAR_41 || type == VAR_67
							  || type == VAR_64)
			    && (VAR_32 != VAR_66
					     || VAR_9 < VAR_31 - 1)))
		{
		    VAR_19 = VAR_9;
		    if (VAR_26)
			--VAR_7;
		    if (type == VAR_68)
			--VAR_9;
		    else
		    {
			type = VAR_67;
			++VAR_9;
		    }
		    continue;
		}
		semsg(_(VAR_101), VAR_42);
	    }
	    else
	    {
		/* COMMENT_98 */
		/* COMMENT_99 */
		if (VAR_26 && VAR_7 > VAR_6->w_tagstacklen)
		    VAR_7 = VAR_6->w_tagstackidx;
#ifdef VAR_22
		VAR_23 = TRUE;
#endif
	    }
	}
	break;
    }

end_do_tag:
    /* COMMENT_100 */
    if (VAR_26 && VAR_7 <= VAR_6->w_tagstacklen)
	VAR_6->w_tagstackidx = VAR_7;
    VAR_102 = 0;	/* COMMENT_101 */
# ifdef VAR_45
    g_do_tagpreview = 0;	/* COMMENT_102 */
# endif

    vim_free(VAR_30);
#ifdef VAR_22
    return VAR_23;
#else
    return FALSE;
#endif
}",vim/ccfde4d028e891a41e3548323c3d47b06fb0b83e/tag.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -440,6 +440,16 @@
 		max_num_matches = MAXCOL; // If less than max_num_matches
 					  // found: all matches found.
 
+	    // A tag function may do anything, which may cause various
+	    // information to become invalid.  At least check for the tagstack
+	    // to still be the same.
+	    if (tagstack != curwin->w_tagstack)
+	    {
+		emsg(_(e_window_unexpectedly_close_while_searching_for_tags));
+		FreeWild(new_num_matches, new_matches);
+		break;
+	    }
+
 	    // If there already were some matches for the same name, move them
 	    // to the start.  Avoids that the order changes when using
 	    // "":tnext"" and jumping to another file.","{'deleted_lines': [], 'added_lines': ['\t    // A tag function may do anything, which may cause various', '\t    // information to become invalid.  At least check for the tagstack', '\t    // to still be the same.', '\t    if (tagstack != curwin->w_tagstack)', '\t    {', '\t\temsg(_(e_window_unexpectedly_close_while_searching_for_tags));', '\t\tFreeWild(new_num_matches, new_matches);', '\t\tbreak;', '\t    }', '']}",True,Use After Free in GitHub repository vim/vim prior to 9.0.0389.,7.8,HIGH,2,test,2022-09-05T18:51:13Z,4
CVE-2022-41889,['CWE-476'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,tensorflow,"Fix pywrap attribute read security vulnerability.

If a list of quantized tensors is assigned to an attribute, the pywrap code was failing to
parse the tensor and returning a `nullptr`, which wasn't caught.  Here we check the return
value and set an appropriate error status.

PiperOrigin-RevId: 476981029",e9e95553e5411834d215e6770c81a83a3d0866ce,https://github.com/tensorflow/tensorflow/commit/e9e95553e5411834d215e6770c81a83a3d0866ce,tensorflow/python/eager/pywrap_tfe_src.cc,SetOpAttrList,"bool SetOpAttrList(TFE_Context* ctx, TFE_Op* op, const char* key,
PyObject* py_list, TF_AttrType type,
tensorflow::gtl::FlatMap<string, int64_t>* attr_list_sizes,
TF_Status* status) {
if (!PySequence_Check(py_list)) {
TF_SetStatus(
status, TF_INVALID_ARGUMENT,
tensorflow::strings::StrCat(""Expecting sequence value for attr "", key,
"", got "", py_list->ob_type->tp_name)
.c_str());
return false;
}
const int num_values = PySequence_Size(py_list);
if (attr_list_sizes != nullptr) (*attr_list_sizes)[key] = num_values;
#define PARSE_LIST(c_type, parse_fn)                                      \
std::unique_ptr<c_type[]> values(new c_type[num_values]);               \
for (int i = 0; i < num_values; ++i) {                                  \
tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));   \
if (!parse_fn(key, py_value.get(), status, &values[i])) return false; \
}
if (type == TF_ATTR_STRING) {
std::unique_ptr<const void*[]> values(new const void*[num_values]);
std::unique_ptr<size_t[]> lengths(new size_t[num_values]);
for (int i = 0; i < num_values; ++i) {
tensorflow::StringPiece value;
tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));
if (!ParseStringValue(key, py_value.get(), status, &value)) return false;
values[i] = value.data();
lengths[i] = value.size();
}
TFE_OpSetAttrStringList(op, key, values.get(), lengths.get(), num_values);
} else if (type == TF_ATTR_INT) {
PARSE_LIST(int64_t, ParseInt64Value);
TFE_OpSetAttrIntList(op, key, values.get(), num_values);
} else if (type == TF_ATTR_FLOAT) {
PARSE_LIST(float, ParseFloatValue);
TFE_OpSetAttrFloatList(op, key, values.get(), num_values);
} else if (type == TF_ATTR_BOOL) {
PARSE_LIST(unsigned char, ParseBoolValue);
TFE_OpSetAttrBoolList(op, key, values.get(), num_values);
} else if (type == TF_ATTR_TYPE) {
PARSE_LIST(int, ParseTypeValue);
TFE_OpSetAttrTypeList(op, key,
reinterpret_cast<const TF_DataType*>(values.get()),
num_values);
} else if (type == TF_ATTR_SHAPE) {
int total_dims = 0;
for (int i = 0; i < num_values; ++i) {
tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));
if (py_value.get() != Py_None) {
if (!PySequence_Check(py_value.get())) {
TF_SetStatus(
status, TF_INVALID_ARGUMENT,
tensorflow::strings::StrCat(
""Expecting None or sequence value for element"", i,
"" of attr "", key, "", got "", py_value->ob_type->tp_name)
.c_str());
return false;
}
const auto size = TensorShapeNumDims(py_value.get());
if (size >= 0) {
total_dims += size;
}
}
}
std::unique_ptr<int64_t[]> buffer(new int64_t[total_dims]);
std::unique_ptr<const int64_t*[]> dims(new const int64_t*[num_values]);
std::unique_ptr<int[]> num_dims(new int[num_values]);
int64_t* offset = buffer.get();
for (int i = 0; i < num_values; ++i) {
tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));
if (py_value.get() == Py_None) {
dims[i] = nullptr;
num_dims[i] = -1;
} else {
const auto size = TensorShapeNumDims(py_value.get());
if (size == -1) {
dims[i] = nullptr;
num_dims[i] = -1;
continue;
}
dims[i] = offset;
num_dims[i] = size;
for (int j = 0; j < size; ++j) {
tensorflow::Safe_PyObjectPtr inner_py_value(
PySequence_ITEM(py_value.get(), j));
if (inner_py_value.get() == Py_None) {
*offset = -1;
} else if (!ParseDimensionValue(key, inner_py_value.get(), status,
offset)) {
return false;
}
++offset;
}
}
}
TFE_OpSetAttrShapeList(op, key, dims.get(), num_dims.get(), num_values,
status);
if (!status->status.ok()) return false;
} else if (type == TF_ATTR_FUNC) {
std::unique_ptr<const TFE_Op*[]> funcs(new const TFE_Op*[num_values]);
for (int i = 0; i < num_values; ++i) {
tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));
tensorflow::StringPiece func_name;
if (!ParseStringValue(key, py_value.get(), status, &func_name)) {
PyObject* name_attr = PyObject_GetAttrString(py_value.get(), ""name"");
if (name_attr == nullptr ||
!ParseStringValue(key, name_attr, status, &func_name)) {
TF_SetStatus(
status, TF_INVALID_ARGUMENT,
tensorflow::strings::StrCat(
""unable to set function value attribute from a "",
py_value.get()->ob_type->tp_name,
"" object. If you think this is an error, please file an ""
""issue at ""
""https:                  .c_str());
return false;
}
}
funcs[i] = TFE_NewOp(ctx, func_name.data(), status);
if (!status->status.ok()) return false;
}
TFE_OpSetAttrFunctionList(op, key, funcs.get(), num_values);
if (!status->status.ok()) return false;
} else {
TF_SetStatus(status, TF_UNIMPLEMENTED,
tensorflow::strings::StrCat(""Attr "", key,
"" has unhandled list type "", type)
.c_str());
return false;
}
#undef PARSE_LIST
return true;
}","bool SetOpAttrList(TFE_Context* VAR_0, TFE_Op* VAR_1, const char* VAR_2,
PyObject* VAR_3, TF_AttrType VAR_4,
tensorflow::gtl::FlatMap<string, int64_t>* VAR_5,
TF_Status* VAR_6) {
if (!PySequence_Check(VAR_3)) {
TF_SetStatus(
VAR_6, VAR_7,
tensorflow::strings::StrCat(""Expecting sequence value for attr "", VAR_2,
"", got "", VAR_3->ob_type->tp_name)
.c_str());
return false;
}
const int VAR_8 = PySequence_Size(VAR_3);
if (VAR_5 != nullptr) (*VAR_5)[VAR_2] = VAR_8;
#define PARSE_LIST(VAR_9, VAR_10)                                      \
std::unique_ptr<c_type[]> values(new c_type[num_values]);               \
for (int i = 0; i < num_values; ++i) {                                  \
tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));   \
if (!parse_fn(key, py_value.get(), status, &values[i])) return false; \
}
if (VAR_4 == VAR_11) {
std::unique_ptr<const void*[]> VAR_12(new const void*[VAR_8]);
std::unique_ptr<size_t[]> VAR_13(new size_t[VAR_8]);
for (int VAR_14 = 0; VAR_14 < VAR_8; ++VAR_14) {
tensorflow::StringPiece VAR_15;
tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));
if (!ParseStringValue(VAR_2, VAR_16.get(), VAR_6, &VAR_15)) return false;
VAR_12[i] = VAR_15.data();
VAR_13[i] = VAR_15.size();
}
TFE_OpSetAttrStringList(VAR_1, VAR_2, VAR_12.get(), VAR_13.get(), VAR_8);
} else if (VAR_4 == VAR_17) {
PARSE_LIST(int64_t, ParseInt64Value);
TFE_OpSetAttrIntList(VAR_1, VAR_2, VAR_12.get(), VAR_8);
} else if (VAR_4 == VAR_18) {
PARSE_LIST(float, ParseFloatValue);
TFE_OpSetAttrFloatList(VAR_1, VAR_2, VAR_12.get(), VAR_8);
} else if (VAR_4 == VAR_19) {
PARSE_LIST(unsigned char, ParseBoolValue);
TFE_OpSetAttrBoolList(VAR_1, VAR_2, VAR_12.get(), VAR_8);
} else if (VAR_4 == VAR_20) {
PARSE_LIST(int, ParseTypeValue);
TFE_OpSetAttrTypeList(VAR_1, VAR_2,
VAR_21<const TF_DataType*>(VAR_12.get()),
VAR_8);
} else if (VAR_4 == VAR_22) {
int VAR_23 = 0;
for (int i = 0; i < VAR_8; ++i) {
tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));
if (VAR_16.get() != VAR_24) {
if (!PySequence_Check(VAR_16.get())) {
TF_SetStatus(
VAR_6, VAR_7,
tensorflow::strings::StrCat(
""Expecting None or sequence value for element"", i,
"" of attr "", VAR_2, "", got "", VAR_16->ob_type->tp_name)
.c_str());
return false;
}
const auto VAR_25 = TensorShapeNumDims(VAR_16.get());
if (VAR_25 >= 0) {
VAR_23 += VAR_25;
}
}
}
std::unique_ptr<int64_t[]> VAR_26(new int64_t[VAR_23]);
std::unique_ptr<const int64_t*[]> VAR_27(new const int64_t*[VAR_8]);
std::unique_ptr<int[]> VAR_28(new int[VAR_8]);
int64_t* VAR_29 = VAR_26.get();
for (int i = 0; i < VAR_8; ++i) {
tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));
if (VAR_16.get() == VAR_24) {
VAR_27[i] = nullptr;
VAR_28[i] = -1;
} else {
const auto VAR_25 = TensorShapeNumDims(VAR_16.get());
if (VAR_25 == -1) {
VAR_27[i] = nullptr;
VAR_28[i] = -1;
continue;
}
VAR_27[i] = VAR_29;
VAR_28[i] = VAR_25;
for (int VAR_30 = 0; VAR_30 < VAR_25; ++VAR_30) {
tensorflow::Safe_PyObjectPtr VAR_31(
PySequence_ITEM(VAR_16.get(), VAR_30));
if (VAR_31.get() == VAR_24) {
*VAR_29 = -1;
} else if (!ParseDimensionValue(VAR_2, VAR_31.get(), VAR_6,
VAR_29)) {
return false;
}
++VAR_29;
}
}
}
TFE_OpSetAttrShapeList(VAR_1, VAR_2, VAR_27.get(), VAR_28.get(), VAR_8,
VAR_6);
if (!VAR_6->status.ok()) return false;
} else if (VAR_4 == VAR_32) {
std::unique_ptr<const TFE_Op*[]> VAR_33(new const TFE_Op*[VAR_8]);
for (int i = 0; i < VAR_8; ++i) {
tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));
tensorflow::StringPiece VAR_34;
if (!ParseStringValue(VAR_2, VAR_16.get(), VAR_6, &VAR_34)) {
PyObject* VAR_35 = PyObject_GetAttrString(VAR_16.get(), ""name"");
if (VAR_35 == nullptr ||
!ParseStringValue(VAR_2, VAR_35, VAR_6, &VAR_34)) {
TF_SetStatus(
VAR_6, VAR_7,
tensorflow::strings::StrCat(
""unable to set function value attribute from a "",
VAR_16.get()->ob_type->tp_name,
"" object. If you think this is an error, please file an ""
""issue at ""
""https://github.com/tensorflow/tensorflow/issues/new"")
.c_str());
return false;
}
}
VAR_33[i] = TFE_NewOp(VAR_0, VAR_34.data(), VAR_6);
if (!VAR_6->status.ok()) return false;
}
TFE_OpSetAttrFunctionList(VAR_1, VAR_2, VAR_33.get(), VAR_8);
if (!VAR_6->status.ok()) return false;
} else {
TF_SetStatus(VAR_6, VAR_36,
tensorflow::strings::StrCat(""Attr "", VAR_2,
"" has unhandled list type "", VAR_4)
.c_str());
return false;
}
#undef PARSE_LIST
return true;
}",tensorflow/e9e95553e5411834d215e6770c81a83a3d0866ce/pywrap_tfe_src.cc/vul/before/0.json,"bool SetOpAttrList(TFE_Context* ctx, TFE_Op* op, const char* key,
                   PyObject* py_list, TF_AttrType type,
                   tensorflow::gtl::FlatMap<string, int64_t>* attr_list_sizes,
                   TF_Status* status) {
  if (!PySequence_Check(py_list)) {
    TF_SetStatus(
        status, TF_INVALID_ARGUMENT,
        tensorflow::strings::StrCat(""Expecting sequence value for attr "", key,
                                    "", got "", py_list->ob_type->tp_name)
            .c_str());
    return false;
  }
  const int num_values = PySequence_Size(py_list);
  if (attr_list_sizes != nullptr) (*attr_list_sizes)[key] = num_values;

#define PARSE_LIST(c_type, parse_fn)                                       \
  std::unique_ptr<c_type[]> values(new c_type[num_values]);                \
  for (int i = 0; i < num_values; ++i) {                                   \
    tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));    \
    if (py_value == nullptr) {                                             \
      TF_SetStatus(status, TF_INVALID_ARGUMENT,                            \
                   tensorflow::strings::StrCat(                            \
                       ""Expecting sequence of "" #c_type "" for attr "", key, \
                       "", got "", py_list->ob_type->tp_name)                \
                       .c_str());                                          \
      return false;                                                        \
    } else if (!parse_fn(key, py_value.get(), status, &values[i])) {       \
      return false;                                                        \
    }                                                                      \
  }

  if (type == TF_ATTR_STRING) {
    std::unique_ptr<const void*[]> values(new const void*[num_values]);
    std::unique_ptr<size_t[]> lengths(new size_t[num_values]);
    for (int i = 0; i < num_values; ++i) {
      tensorflow::StringPiece value;
      tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));
      if (!ParseStringValue(key, py_value.get(), status, &value)) return false;
      values[i] = value.data();
      lengths[i] = value.size();
    }
    TFE_OpSetAttrStringList(op, key, values.get(), lengths.get(), num_values);
  } else if (type == TF_ATTR_INT) {
    PARSE_LIST(int64_t, ParseInt64Value);
    TFE_OpSetAttrIntList(op, key, values.get(), num_values);
  } else if (type == TF_ATTR_FLOAT) {
    PARSE_LIST(float, ParseFloatValue);
    TFE_OpSetAttrFloatList(op, key, values.get(), num_values);
  } else if (type == TF_ATTR_BOOL) {
    PARSE_LIST(unsigned char, ParseBoolValue);
    TFE_OpSetAttrBoolList(op, key, values.get(), num_values);
  } else if (type == TF_ATTR_TYPE) {
    PARSE_LIST(int, ParseTypeValue);
    TFE_OpSetAttrTypeList(op, key,
                          reinterpret_cast<const TF_DataType*>(values.get()),
                          num_values);
  } else if (type == TF_ATTR_SHAPE) {
    // Make one pass through the input counting the total number of
    // dims across all the input lists.
    int total_dims = 0;
    for (int i = 0; i < num_values; ++i) {
      tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));
      if (py_value.get() != Py_None) {
        if (!PySequence_Check(py_value.get())) {
          TF_SetStatus(
              status, TF_INVALID_ARGUMENT,
              tensorflow::strings::StrCat(
                  ""Expecting None or sequence value for element"", i,
                  "" of attr "", key, "", got "", py_value->ob_type->tp_name)
                  .c_str());
          return false;
        }
        const auto size = TensorShapeNumDims(py_value.get());
        if (size >= 0) {
          total_dims += size;
        }
      }
    }
    // Allocate a buffer that can fit all of the dims together.
    std::unique_ptr<int64_t[]> buffer(new int64_t[total_dims]);
    // Copy the input dims into the buffer and set dims to point to
    // the start of each list's dims.
    std::unique_ptr<const int64_t*[]> dims(new const int64_t*[num_values]);
    std::unique_ptr<int[]> num_dims(new int[num_values]);
    int64_t* offset = buffer.get();
    for (int i = 0; i < num_values; ++i) {
      tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));
      if (py_value.get() == Py_None) {
        dims[i] = nullptr;
        num_dims[i] = -1;
      } else {
        const auto size = TensorShapeNumDims(py_value.get());
        if (size == -1) {
          dims[i] = nullptr;
          num_dims[i] = -1;
          continue;
        }
        dims[i] = offset;
        num_dims[i] = size;
        for (int j = 0; j < size; ++j) {
          tensorflow::Safe_PyObjectPtr inner_py_value(
              PySequence_ITEM(py_value.get(), j));
          if (inner_py_value.get() == Py_None) {
            *offset = -1;
          } else if (!ParseDimensionValue(key, inner_py_value.get(), status,
                                          offset)) {
            return false;
          }
          ++offset;
        }
      }
    }
    TFE_OpSetAttrShapeList(op, key, dims.get(), num_dims.get(), num_values,
                           status);
    if (!status->status.ok()) return false;
  } else if (type == TF_ATTR_FUNC) {
    std::unique_ptr<const TFE_Op*[]> funcs(new const TFE_Op*[num_values]);
    for (int i = 0; i < num_values; ++i) {
      tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));
      // Allow:
      // (1) String function name, OR
      // (2) A Python object with a .name attribute
      //     (A crude test for being a
      //     tensorflow.python.framework.function._DefinedFunction)
      //     (which is what the various ""defun"" or ""Defun"" decorators do).
      // And in the future also allow an object that can encapsulate
      // the function name and its attribute values.
      tensorflow::StringPiece func_name;
      if (!ParseStringValue(key, py_value.get(), status, &func_name)) {
        PyObject* name_attr = PyObject_GetAttrString(py_value.get(), ""name"");
        if (name_attr == nullptr ||
            !ParseStringValue(key, name_attr, status, &func_name)) {
          TF_SetStatus(
              status, TF_INVALID_ARGUMENT,
              tensorflow::strings::StrCat(
                  ""unable to set function value attribute from a "",
                  py_value.get()->ob_type->tp_name,
                  "" object. If you think this is an error, please file an ""
                  ""issue at ""
                  ""https://github.com/tensorflow/tensorflow/issues/new"")
                  .c_str());
          return false;
        }
      }
      funcs[i] = TFE_NewOp(ctx, func_name.data(), status);
      if (!status->status.ok()) return false;
    }
    TFE_OpSetAttrFunctionList(op, key, funcs.get(), num_values);
    if (!status->status.ok()) return false;
  } else {
    TF_SetStatus(status, TF_UNIMPLEMENTED,
                 tensorflow::strings::StrCat(""Attr "", key,
                                             "" has unhandled list type "", type)
                     .c_str());
    return false;
  }
#undef PARSE_LIST
  return true;
}","bool SetOpAttrList(TFE_Context* VAR_0, TFE_Op* VAR_1, const char* VAR_2,
                   PyObject* VAR_3, TF_AttrType VAR_4,
                   tensorflow::gtl::FlatMap<string, int64_t>* VAR_5,
                   TF_Status* VAR_6) {
  if (!PySequence_Check(VAR_3)) {
    TF_SetStatus(
        VAR_6, VAR_7,
        tensorflow::strings::StrCat(""Expecting sequence value for attr "", VAR_2,
                                    "", got "", VAR_3->ob_type->tp_name)
            .c_str());
    return false;
  }
  const int VAR_8 = PySequence_Size(VAR_3);
  if (VAR_5 != nullptr) (*VAR_5)[VAR_2] = VAR_8;

#define PARSE_LIST(VAR_9, VAR_10)                                       \
  std::unique_ptr<c_type[]> values(new c_type[num_values]);                \
  for (int i = 0; i < num_values; ++i) {                                   \
    tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));    \
    if (py_value == nullptr) {                                             \
      TF_SetStatus(status, TF_INVALID_ARGUMENT,                            \
                   tensorflow::strings::StrCat(                            \
                       ""Expecting sequence of "" #c_type "" for attr "", key, \
                       "", got "", py_list->ob_type->tp_name)                \
                       .c_str());                                          \
      return false;                                                        \
    } else if (!parse_fn(key, py_value.get(), status, &values[i])) {       \
      return false;                                                        \
    }                                                                      \
  }

  if (VAR_4 == VAR_11) {
    std::unique_ptr<const void*[]> VAR_12(new const void*[VAR_8]);
    std::unique_ptr<size_t[]> VAR_13(new size_t[VAR_8]);
    for (int VAR_14 = 0; VAR_14 < VAR_8; ++VAR_14) {
      tensorflow::StringPiece VAR_15;
      tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));
      if (!ParseStringValue(VAR_2, VAR_16.get(), VAR_6, &VAR_15)) return false;
      VAR_12[i] = VAR_15.data();
      VAR_13[i] = VAR_15.size();
    }
    TFE_OpSetAttrStringList(VAR_1, VAR_2, VAR_12.get(), VAR_13.get(), VAR_8);
  } else if (VAR_4 == VAR_17) {
    PARSE_LIST(int64_t, ParseInt64Value);
    TFE_OpSetAttrIntList(VAR_1, VAR_2, VAR_12.get(), VAR_8);
  } else if (VAR_4 == VAR_18) {
    PARSE_LIST(float, ParseFloatValue);
    TFE_OpSetAttrFloatList(VAR_1, VAR_2, VAR_12.get(), VAR_8);
  } else if (VAR_4 == VAR_19) {
    PARSE_LIST(unsigned char, ParseBoolValue);
    TFE_OpSetAttrBoolList(VAR_1, VAR_2, VAR_12.get(), VAR_8);
  } else if (VAR_4 == VAR_20) {
    PARSE_LIST(int, ParseTypeValue);
    TFE_OpSetAttrTypeList(VAR_1, VAR_2,
                          VAR_21<const TF_DataType*>(VAR_12.get()),
                          VAR_8);
  } else if (VAR_4 == VAR_22) {
    /* COMMENT_0 */
    /* COMMENT_1 */
    int VAR_23 = 0;
    for (int i = 0; i < VAR_8; ++i) {
      tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));
      if (VAR_16.get() != VAR_24) {
        if (!PySequence_Check(VAR_16.get())) {
          TF_SetStatus(
              VAR_6, VAR_7,
              tensorflow::strings::StrCat(
                  ""Expecting None or sequence value for element"", i,
                  "" of attr "", VAR_2, "", got "", VAR_16->ob_type->tp_name)
                  .c_str());
          return false;
        }
        const auto VAR_25 = TensorShapeNumDims(VAR_16.get());
        if (VAR_25 >= 0) {
          VAR_23 += VAR_25;
        }
      }
    }
    /* COMMENT_2 */
    std::unique_ptr<int64_t[]> VAR_26(new int64_t[VAR_23]);
    /* COMMENT_3 */
    /* COMMENT_4 */
    std::unique_ptr<const int64_t*[]> VAR_27(new const int64_t*[VAR_8]);
    std::unique_ptr<int[]> VAR_28(new int[VAR_8]);
    int64_t* VAR_29 = VAR_26.get();
    for (int i = 0; i < VAR_8; ++i) {
      tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));
      if (VAR_16.get() == VAR_24) {
        VAR_27[i] = nullptr;
        VAR_28[i] = -1;
      } else {
        const auto VAR_25 = TensorShapeNumDims(VAR_16.get());
        if (VAR_25 == -1) {
          VAR_27[i] = nullptr;
          VAR_28[i] = -1;
          continue;
        }
        VAR_27[i] = VAR_29;
        VAR_28[i] = VAR_25;
        for (int VAR_30 = 0; VAR_30 < VAR_25; ++VAR_30) {
          tensorflow::Safe_PyObjectPtr VAR_31(
              PySequence_ITEM(VAR_16.get(), VAR_30));
          if (VAR_31.get() == VAR_24) {
            *VAR_29 = -1;
          } else if (!ParseDimensionValue(VAR_2, VAR_31.get(), VAR_6,
                                          VAR_29)) {
            return false;
          }
          ++VAR_29;
        }
      }
    }
    TFE_OpSetAttrShapeList(VAR_1, VAR_2, VAR_27.get(), VAR_28.get(), VAR_8,
                           VAR_6);
    if (!VAR_6->status.ok()) return false;
  } else if (VAR_4 == VAR_32) {
    std::unique_ptr<const TFE_Op*[]> VAR_33(new const TFE_Op*[VAR_8]);
    for (int i = 0; i < VAR_8; ++i) {
      tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));
      /* COMMENT_5 */
      /* COMMENT_6 */
      /* COMMENT_7 */
      /* COMMENT_8 */
      /* COMMENT_9 */
      /* COMMENT_10 */
      /* COMMENT_11 */
      /* COMMENT_12 */
      tensorflow::StringPiece VAR_34;
      if (!ParseStringValue(VAR_2, VAR_16.get(), VAR_6, &VAR_34)) {
        PyObject* VAR_35 = PyObject_GetAttrString(VAR_16.get(), ""name"");
        if (VAR_35 == nullptr ||
            !ParseStringValue(VAR_2, VAR_35, VAR_6, &VAR_34)) {
          TF_SetStatus(
              VAR_6, VAR_7,
              tensorflow::strings::StrCat(
                  ""unable to set function value attribute from a "",
                  VAR_16.get()->ob_type->tp_name,
                  "" object. If you think this is an error, please file an ""
                  ""issue at ""
                  ""https://github.com/tensorflow/tensorflow/issues/new"")
                  .c_str());
          return false;
        }
      }
      VAR_33[i] = TFE_NewOp(VAR_0, VAR_34.data(), VAR_6);
      if (!VAR_6->status.ok()) return false;
    }
    TFE_OpSetAttrFunctionList(VAR_1, VAR_2, VAR_33.get(), VAR_8);
    if (!VAR_6->status.ok()) return false;
  } else {
    TF_SetStatus(VAR_6, VAR_36,
                 tensorflow::strings::StrCat(""Attr "", VAR_2,
                                             "" has unhandled list type "", VAR_4)
                     .c_str());
    return false;
  }
#undef PARSE_LIST
  return true;
}",tensorflow/e9e95553e5411834d215e6770c81a83a3d0866ce/pywrap_tfe_src.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -13,11 +13,20 @@
   const int num_values = PySequence_Size(py_list);
   if (attr_list_sizes != nullptr) (*attr_list_sizes)[key] = num_values;
 
-#define PARSE_LIST(c_type, parse_fn)                                      \
-  std::unique_ptr<c_type[]> values(new c_type[num_values]);               \
-  for (int i = 0; i < num_values; ++i) {                                  \
-    tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));   \
-    if (!parse_fn(key, py_value.get(), status, &values[i])) return false; \
+#define PARSE_LIST(c_type, parse_fn)                                       \
+  std::unique_ptr<c_type[]> values(new c_type[num_values]);                \
+  for (int i = 0; i < num_values; ++i) {                                   \
+    tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));    \
+    if (py_value == nullptr) {                                             \
+      TF_SetStatus(status, TF_INVALID_ARGUMENT,                            \
+                   tensorflow::strings::StrCat(                            \
+                       ""Expecting sequence of "" #c_type "" for attr "", key, \
+                       "", got "", py_list->ob_type->tp_name)                \
+                       .c_str());                                          \
+      return false;                                                        \
+    } else if (!parse_fn(key, py_value.get(), status, &values[i])) {       \
+      return false;                                                        \
+    }                                                                      \
   }
 
   if (type == TF_ATTR_STRING) {","{'deleted_lines': ['#define PARSE_LIST(c_type, parse_fn)                                      \\', '  std::unique_ptr<c_type[]> values(new c_type[num_values]);               \\', '  for (int i = 0; i < num_values; ++i) {                                  \\', '    tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));   \\', '    if (!parse_fn(key, py_value.get(), status, &values[i])) return false; \\'], 'added_lines': ['#define PARSE_LIST(c_type, parse_fn)                                       \\', '  std::unique_ptr<c_type[]> values(new c_type[num_values]);                \\', '  for (int i = 0; i < num_values; ++i) {                                   \\', '    tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));    \\', '    if (py_value == nullptr) {                                             \\', '      TF_SetStatus(status, TF_INVALID_ARGUMENT,                            \\', '                   tensorflow::strings::StrCat(                            \\', '                       ""Expecting sequence of "" #c_type "" for attr "", key, \\', '                       "", got "", py_list->ob_type->tp_name)                \\', '                       .c_str());                                          \\', '      return false;                                                        \\', '    } else if (!parse_fn(key, py_value.get(), status, &values[i])) {       \\', '      return false;                                                        \\', '    }                                                                      \\']}",True,"TensorFlow is an open source platform for machine learning. If a list of quantized tensors is assigned to an attribute, the pywrap code fails to parse the tensor and returns a `nullptr`, which is not caught. An example can be seen in `tf.compat.v1.extract_volume_patches` by passing in quantized tensors as input `ksizes`. We have patched the issue in GitHub commit e9e95553e5411834d215e6770c81a83a3d0866ce. The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range.",4.8,MEDIUM,1,test,2022-09-26T20:45:03Z,4
CVE-2022-41894,['CWE-120'],CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H,1,tensorflow,"Fix a potential buffer overflow issue in reference kernel of the CONV_3D_TRANSPOSE

PiperOrigin-RevId: 479074072",72c0bdcb25305b0b36842d746cc61d72658d2941,https://github.com/tensorflow/tensorflow/commit/72c0bdcb25305b0b36842d746cc61d72658d2941,tensorflow/lite/kernels/internal/reference/conv3d_transpose.h,Conv3DTranspose,"inline void Conv3DTranspose(
const Conv3DTransposeParams& params, const RuntimeShape& input_shape,
const float* input_data, const RuntimeShape& filter_shape,
const float* filter_data, const RuntimeShape& bias_shape,
const float* bias_data, const RuntimeShape& output_shape,
float* output_data) {
const int stride_width = params.stride_width;
const int stride_height = params.stride_height;
const int stride_depth = params.stride_depth;
const int pad_width = params.padding_values.width;
const int pad_height = params.padding_values.height;
const int pad_depth = params.padding_values.depth;
TFLITE_DCHECK_EQ(input_shape.DimensionsCount(), 5);
TFLITE_DCHECK_EQ(filter_shape.DimensionsCount(), 5);
TFLITE_DCHECK_EQ(output_shape.DimensionsCount(), 5);
const int batches = MatchingDim(input_shape, 0, output_shape, 0);
const int input_num_channels = MatchingDim(input_shape, 4, filter_shape, 4);
const int output_num_channels = output_shape.Dims(4);
const int input_depth = input_shape.Dims(1);
const int input_height = input_shape.Dims(2);
const int input_width = input_shape.Dims(3);
const int filter_depth = filter_shape.Dims(0);
const int filter_height = filter_shape.Dims(1);
const int filter_width = filter_shape.Dims(2);
const int output_depth = output_shape.Dims(1);
const int output_height = output_shape.Dims(2);
const int output_width = output_shape.Dims(3);
if (bias_data) {
TFLITE_DCHECK_EQ(bias_shape.FlatSize(), output_num_channels);
}
const int num_elements = output_shape.FlatSize();
for (int i = 0; i < num_elements; i++) {
output_data[i] = 0.0f;
}
for (int batch = 0; batch < batches; ++batch) {
for (int in_d = 0; in_d < input_depth; ++in_d) {
for (int in_y = 0; in_y < input_height; ++in_y) {
for (int in_x = 0; in_x < input_width; ++in_x) {
for (int in_channel = 0; in_channel < input_num_channels;
++in_channel) {
const int out_x_origin = (in_x * stride_width) - pad_width;
const int out_y_origin = (in_y * stride_height) - pad_height;
const int out_d_origin = (in_d * stride_depth) - pad_depth;
for (int filter_d = 0; filter_d < filter_depth; ++filter_d) {
for (int filter_y = 0; filter_y < filter_height; ++filter_y) {
for (int filter_x = 0; filter_x < filter_width; ++filter_x) {
for (int out_channel = 0; out_channel < output_num_channels;
++out_channel) {
const int out_x =
out_x_origin + params.dilation_width * filter_x;
const int out_y =
out_y_origin + params.dilation_height * filter_y;
const int out_d =
out_d_origin + params.dilation_depth * filter_d;
if ((out_x >= 0) && (out_x < output_width) &&
(out_y >= 0) && (out_y < output_height) &&
(out_d >= 0) && (out_d < output_depth)) {
float input_value = input_data[Offset(
input_shape, batch, in_d, in_y, in_x, in_channel)];
float filter_value = filter_data[Offset(
filter_shape, filter_d, filter_y, filter_x,
out_channel, in_channel)];
output_data[Offset(output_shape, batch, out_d, out_y,
out_x, out_channel)] +=
input_value * filter_value;
}
}
}
}
}
}
}
}
}
}
const float float_activation_min = params.float_activation_min;
const float float_activation_max = params.float_activation_max;
float* data_ptr = output_data;
if (bias_data) {
const int outer_size =
batches * output_depth * output_height * output_width;
const int num_channels = input_shape.Dims(4);
for (int n = 0; n < outer_size; ++n) {
for (int c = 0; c < output_num_channels; ++c) {
data_ptr[c] = ActivationFunctionWithMinMax(data_ptr[c] + bias_data[c],
float_activation_min,
float_activation_max);
}
data_ptr += num_channels;
}
} else {
const int flat_size = output_shape.FlatSize();
for (int i = 0; i < flat_size; ++i) {
data_ptr[i] = ActivationFunctionWithMinMax(
data_ptr[i], float_activation_min, float_activation_max);
}
}
}","inline void Conv3DTranspose(
const Conv3DTransposeParams& VAR_0, const RuntimeShape& VAR_1,
const float* VAR_2, const RuntimeShape& VAR_3,
const float* VAR_4, const RuntimeShape& VAR_5,
const float* VAR_6, const RuntimeShape& VAR_7,
float* VAR_8) {
const int VAR_9 = VAR_0.stride_width;
const int VAR_10 = VAR_0.stride_height;
const int VAR_11 = VAR_0.stride_depth;
const int VAR_12 = VAR_0.padding_values.width;
const int VAR_13 = VAR_0.padding_values.height;
const int VAR_14 = VAR_0.padding_values.depth;
TFLITE_DCHECK_EQ(VAR_1.DimensionsCount(), 5);
TFLITE_DCHECK_EQ(VAR_3.DimensionsCount(), 5);
TFLITE_DCHECK_EQ(VAR_7.DimensionsCount(), 5);
const int VAR_15 = MatchingDim(VAR_1, 0, VAR_7, 0);
const int VAR_16 = MatchingDim(VAR_1, 4, VAR_3, 4);
const int VAR_17 = VAR_7.Dims(4);
const int VAR_18 = VAR_1.Dims(1);
const int VAR_19 = VAR_1.Dims(2);
const int VAR_20 = VAR_1.Dims(3);
const int VAR_21 = VAR_3.Dims(0);
const int VAR_22 = VAR_3.Dims(1);
const int VAR_23 = VAR_3.Dims(2);
const int VAR_24 = VAR_7.Dims(1);
const int VAR_25 = VAR_7.Dims(2);
const int VAR_26 = VAR_7.Dims(3);
if (VAR_6) {
TFLITE_DCHECK_EQ(VAR_5.FlatSize(), VAR_17);
}
const int VAR_27 = VAR_7.FlatSize();
for (int VAR_28 = 0; VAR_28 < VAR_27; VAR_28++) {
VAR_8[VAR_28] = 0.0f;
}
for (int VAR_29 = 0; VAR_29 < VAR_15; ++VAR_29) {
for (int VAR_30 = 0; VAR_30 < VAR_18; ++VAR_30) {
for (int VAR_31 = 0; VAR_31 < VAR_19; ++VAR_31) {
for (int VAR_32 = 0; VAR_32 < VAR_20; ++VAR_32) {
for (int VAR_33 = 0; VAR_33 < VAR_16;
++VAR_33) {
const int VAR_34 = (VAR_32 * VAR_9) - VAR_12;
const int VAR_35 = (VAR_31 * VAR_10) - VAR_13;
const int VAR_36 = (VAR_30 * VAR_11) - VAR_14;
for (int VAR_37 = 0; VAR_37 < VAR_21; ++VAR_37) {
for (int VAR_38 = 0; VAR_38 < VAR_22; ++VAR_38) {
for (int VAR_39 = 0; VAR_39 < VAR_23; ++VAR_39) {
for (int VAR_40 = 0; VAR_40 < VAR_17;
++VAR_40) {
const int VAR_41 =
VAR_34 + VAR_0.dilation_width * VAR_39;
const int VAR_42 =
VAR_35 + VAR_0.dilation_height * VAR_38;
const int VAR_43 =
VAR_36 + VAR_0.dilation_depth * VAR_37;
if ((VAR_41 >= 0) && (VAR_41 < VAR_26) &&
(VAR_42 >= 0) && (VAR_42 < VAR_25) &&
(VAR_43 >= 0) && (VAR_43 < VAR_24)) {
float VAR_44 = VAR_2[Offset(
VAR_1, VAR_29, VAR_30, VAR_31, VAR_32, VAR_33)];
float VAR_45 = VAR_4[Offset(
VAR_3, VAR_37, VAR_38, VAR_39,
VAR_40, VAR_33)];
VAR_8[Offset(VAR_7, VAR_29, VAR_43, VAR_42,
VAR_41, VAR_40)] +=
VAR_44 * VAR_45;
}
}
}
}
}
}
}
}
}
}
const float VAR_46 = VAR_0.float_activation_min;
const float VAR_47 = VAR_0.float_activation_max;
float* VAR_48 = VAR_8;
if (VAR_6) {
const int VAR_49 =
VAR_15 * VAR_24 * VAR_25 * VAR_26;
const int VAR_50 = VAR_1.Dims(4);
for (int VAR_51 = 0; VAR_51 < VAR_49; ++VAR_51) {
for (int VAR_52 = 0; VAR_52 < VAR_17; ++VAR_52) {
VAR_48[VAR_52] = ActivationFunctionWithMinMax(VAR_48[VAR_52] + VAR_6[VAR_52],
VAR_46,
VAR_47);
}
VAR_48 += VAR_50;
}
} else {
const int VAR_53 = VAR_7.FlatSize();
for (int VAR_28 = 0; VAR_28 < VAR_53; ++VAR_28) {
VAR_48[VAR_28] = ActivationFunctionWithMinMax(
VAR_48[VAR_28], VAR_46, VAR_47);
}
}
}",,"inline void Conv3DTranspose(
    const Conv3DTransposeParams& params, const RuntimeShape& input_shape,
    const float* input_data, const RuntimeShape& filter_shape,
    const float* filter_data, const RuntimeShape& bias_shape,
    const float* bias_data, const RuntimeShape& output_shape,
    float* output_data) {
  const int stride_width = params.stride_width;
  const int stride_height = params.stride_height;
  const int stride_depth = params.stride_depth;
  const int pad_width = params.padding_values.width;
  const int pad_height = params.padding_values.height;
  const int pad_depth = params.padding_values.depth;
  TFLITE_DCHECK_EQ(input_shape.DimensionsCount(), 5);
  TFLITE_DCHECK_EQ(filter_shape.DimensionsCount(), 5);
  TFLITE_DCHECK_EQ(output_shape.DimensionsCount(), 5);

  const int batches = MatchingDim(input_shape, 0, output_shape, 0);
  const int input_num_channels = MatchingDim(input_shape, 4, filter_shape, 4);
  const int output_num_channels = output_shape.Dims(4);
  const int input_depth = input_shape.Dims(1);
  const int input_height = input_shape.Dims(2);
  const int input_width = input_shape.Dims(3);
  const int filter_depth = filter_shape.Dims(0);
  const int filter_height = filter_shape.Dims(1);
  const int filter_width = filter_shape.Dims(2);
  const int output_depth = output_shape.Dims(1);
  const int output_height = output_shape.Dims(2);
  const int output_width = output_shape.Dims(3);
  if (bias_data) {
    TFLITE_DCHECK_EQ(bias_shape.FlatSize(), output_num_channels);
  }

  // Initializes the output array to zero.
  const int num_elements = output_shape.FlatSize();
  for (int i = 0; i < num_elements; i++) {
    output_data[i] = 0.0f;
  }

  // Loop through input elements one at a time.
  for (int batch = 0; batch < batches; ++batch) {
    for (int in_d = 0; in_d < input_depth; ++in_d) {
      for (int in_y = 0; in_y < input_height; ++in_y) {
        for (int in_x = 0; in_x < input_width; ++in_x) {
          for (int in_channel = 0; in_channel < input_num_channels;
               ++in_channel) {
            // Loop through the output elements it will influence.
            const int out_x_origin = (in_x * stride_width) - pad_width;
            const int out_y_origin = (in_y * stride_height) - pad_height;
            const int out_d_origin = (in_d * stride_depth) - pad_depth;
            for (int filter_d = 0; filter_d < filter_depth; ++filter_d) {
              for (int filter_y = 0; filter_y < filter_height; ++filter_y) {
                for (int filter_x = 0; filter_x < filter_width; ++filter_x) {
                  for (int out_channel = 0; out_channel < output_num_channels;
                       ++out_channel) {
                    // Compute output element location.
                    const int out_x =
                        out_x_origin + params.dilation_width * filter_x;
                    const int out_y =
                        out_y_origin + params.dilation_height * filter_y;
                    const int out_d =
                        out_d_origin + params.dilation_depth * filter_d;
                    // We cannot accumulate out of bounds.
                    if ((out_x >= 0) && (out_x < output_width) &&
                        (out_y >= 0) && (out_y < output_height) &&
                        (out_d >= 0) && (out_d < output_depth)) {
                      float input_value = input_data[Offset(
                          input_shape, batch, in_d, in_y, in_x, in_channel)];
                      float filter_value = filter_data[Offset(
                          filter_shape, filter_d, filter_y, filter_x,
                          out_channel, in_channel)];
                      output_data[Offset(output_shape, batch, out_d, out_y,
                                         out_x, out_channel)] +=
                          input_value * filter_value;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  const float float_activation_min = params.float_activation_min;
  const float float_activation_max = params.float_activation_max;
  float* data_ptr = output_data;
  if (bias_data) {
    const int outer_size =
        batches * output_depth * output_height * output_width;
    for (int n = 0; n < outer_size; ++n) {
      for (int c = 0; c < output_num_channels; ++c) {
        data_ptr[c] = ActivationFunctionWithMinMax(data_ptr[c] + bias_data[c],
                                                   float_activation_min,
                                                   float_activation_max);
      }
      data_ptr += output_num_channels;
    }
  } else {
    const int flat_size = output_shape.FlatSize();
    for (int i = 0; i < flat_size; ++i) {
      data_ptr[i] = ActivationFunctionWithMinMax(
          data_ptr[i], float_activation_min, float_activation_max);
    }
  }
}","inline void Conv3DTranspose(
    const Conv3DTransposeParams& VAR_0, const RuntimeShape& VAR_1,
    const float* VAR_2, const RuntimeShape& VAR_3,
    const float* VAR_4, const RuntimeShape& VAR_5,
    const float* VAR_6, const RuntimeShape& VAR_7,
    float* VAR_8) {
  const int VAR_9 = VAR_0.stride_width;
  const int VAR_10 = VAR_0.stride_height;
  const int VAR_11 = VAR_0.stride_depth;
  const int VAR_12 = VAR_0.padding_values.width;
  const int VAR_13 = VAR_0.padding_values.height;
  const int VAR_14 = VAR_0.padding_values.depth;
  TFLITE_DCHECK_EQ(VAR_1.DimensionsCount(), 5);
  TFLITE_DCHECK_EQ(VAR_3.DimensionsCount(), 5);
  TFLITE_DCHECK_EQ(VAR_7.DimensionsCount(), 5);

  const int VAR_15 = MatchingDim(VAR_1, 0, VAR_7, 0);
  const int VAR_16 = MatchingDim(VAR_1, 4, VAR_3, 4);
  const int VAR_17 = VAR_7.Dims(4);
  const int VAR_18 = VAR_1.Dims(1);
  const int VAR_19 = VAR_1.Dims(2);
  const int VAR_20 = VAR_1.Dims(3);
  const int VAR_21 = VAR_3.Dims(0);
  const int VAR_22 = VAR_3.Dims(1);
  const int VAR_23 = VAR_3.Dims(2);
  const int VAR_24 = VAR_7.Dims(1);
  const int VAR_25 = VAR_7.Dims(2);
  const int VAR_26 = VAR_7.Dims(3);
  if (VAR_6) {
    TFLITE_DCHECK_EQ(VAR_5.FlatSize(), VAR_17);
  }

  /* COMMENT_0 */
  const int VAR_27 = VAR_7.FlatSize();
  for (int VAR_28 = 0; VAR_28 < VAR_27; VAR_28++) {
    VAR_8[VAR_28] = 0.0f;
  }

  /* COMMENT_1 */
  for (int VAR_29 = 0; VAR_29 < VAR_15; ++VAR_29) {
    for (int VAR_30 = 0; VAR_30 < VAR_18; ++VAR_30) {
      for (int VAR_31 = 0; VAR_31 < VAR_19; ++VAR_31) {
        for (int VAR_32 = 0; VAR_32 < VAR_20; ++VAR_32) {
          for (int VAR_33 = 0; VAR_33 < VAR_16;
               ++VAR_33) {
            /* COMMENT_2 */
            const int VAR_34 = (VAR_32 * VAR_9) - VAR_12;
            const int VAR_35 = (VAR_31 * VAR_10) - VAR_13;
            const int VAR_36 = (VAR_30 * VAR_11) - VAR_14;
            for (int VAR_37 = 0; VAR_37 < VAR_21; ++VAR_37) {
              for (int VAR_38 = 0; VAR_38 < VAR_22; ++VAR_38) {
                for (int VAR_39 = 0; VAR_39 < VAR_23; ++VAR_39) {
                  for (int VAR_40 = 0; VAR_40 < VAR_17;
                       ++VAR_40) {
                    /* COMMENT_3 */
                    const int VAR_41 =
                        VAR_34 + VAR_0.dilation_width * VAR_39;
                    const int VAR_42 =
                        VAR_35 + VAR_0.dilation_height * VAR_38;
                    const int VAR_43 =
                        VAR_36 + VAR_0.dilation_depth * VAR_37;
                    /* COMMENT_4 */
                    if ((VAR_41 >= 0) && (VAR_41 < VAR_26) &&
                        (VAR_42 >= 0) && (VAR_42 < VAR_25) &&
                        (VAR_43 >= 0) && (VAR_43 < VAR_24)) {
                      float VAR_44 = VAR_2[Offset(
                          VAR_1, VAR_29, VAR_30, VAR_31, VAR_32, VAR_33)];
                      float VAR_45 = VAR_4[Offset(
                          VAR_3, VAR_37, VAR_38, VAR_39,
                          VAR_40, VAR_33)];
                      VAR_8[Offset(VAR_7, VAR_29, VAR_43, VAR_42,
                                         VAR_41, VAR_40)] +=
                          VAR_44 * VAR_45;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  const float VAR_46 = VAR_0.float_activation_min;
  const float VAR_47 = VAR_0.float_activation_max;
  float* VAR_48 = VAR_8;
  if (VAR_6) {
    const int VAR_49 =
        VAR_15 * VAR_24 * VAR_25 * VAR_26;
    for (int VAR_50 = 0; VAR_50 < VAR_49; ++VAR_50) {
      for (int VAR_51 = 0; VAR_51 < VAR_17; ++VAR_51) {
        VAR_48[VAR_51] = ActivationFunctionWithMinMax(VAR_48[VAR_51] + VAR_6[VAR_51],
                                                   VAR_46,
                                                   VAR_47);
      }
      VAR_48 += VAR_17;
    }
  } else {
    const int VAR_52 = VAR_7.FlatSize();
    for (int VAR_28 = 0; VAR_28 < VAR_52; ++VAR_28) {
      VAR_48[VAR_28] = ActivationFunctionWithMinMax(
          VAR_48[VAR_28], VAR_46, VAR_47);
    }
  }
}",,"--- func_before
+++ func_after
@@ -88,14 +88,13 @@
   if (bias_data) {
     const int outer_size =
         batches * output_depth * output_height * output_width;
-    const int num_channels = input_shape.Dims(4);
     for (int n = 0; n < outer_size; ++n) {
       for (int c = 0; c < output_num_channels; ++c) {
         data_ptr[c] = ActivationFunctionWithMinMax(data_ptr[c] + bias_data[c],
                                                    float_activation_min,
                                                    float_activation_max);
       }
-      data_ptr += num_channels;
+      data_ptr += output_num_channels;
     }
   } else {
     const int flat_size = output_shape.FlatSize();","{'deleted_lines': ['    const int num_channels = input_shape.Dims(4);', '      data_ptr += num_channels;'], 'added_lines': ['      data_ptr += output_num_channels;']}",True,"TensorFlow is an open source platform for machine learning. The reference kernel of the `CONV_3D_TRANSPOSE` TensorFlow Lite operator wrongly increments the data_ptr when adding the bias to the result. Instead of `data_ptr += num_channels;` it should be `data_ptr += output_num_channels;` as if the number of input channels is different than the number of output channels, the wrong result will be returned and a buffer overflow will occur if num_channels > output_num_channels. An attacker can craft a model with a specific number of input channels. It is then possible to write specific values through the bias of the layer outside the bounds of the buffer. This attack only works if the reference kernel resolver is used in the interpreter. We have patched the issue in GitHub commit 72c0bdcb25305b0b36842d746cc61d72658d2941. The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range.",7.1,HIGH,2,test,2022-10-05T17:03:52Z,4
CVE-2022-43294,['CWE-787'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,arendst/Tasmota, fix stack overflow vulnerability,066878da4d4762a9b6cb169fdf353e804d735cfd,https://github.com/arendst/Tasmota/commit/066878da4d4762a9b6cb169fdf353e804d735cfd,lib/libesp32/rtsp/CRtspSession.cpp,CRtspSession::ParseRtspRequest,"bool CRtspSession::ParseRtspRequest(char const * aRequest, unsigned aRequestSize)
{
unsigned CurRequestSize;
Init();
CurRequestSize = aRequestSize;
memcpy(CurRequest,aRequest,aRequestSize);
char * ClientPortPtr;
char * TmpPtr;
char CP[128];     char * pCP;
ClientPortPtr = strstr(CurRequest,""client_port"");
if (ClientPortPtr != nullptr)
{
TmpPtr = strstr(ClientPortPtr,""\r\n"");
if (TmpPtr != nullptr)
{
TmpPtr[0] = 0x00;
strcpy(CP,ClientPortPtr);
pCP = strstr(CP,""="");
if (pCP != nullptr)
{
pCP++;
strcpy(CP,pCP);
pCP = strstr(CP,""-"");
if (pCP != nullptr)
{
pCP[0] = 0x00;
m_ClientRTPPort  = atoi(CP);
m_ClientRTCPPort = m_ClientRTPPort + 1;
};
};
};
};
bool parseSucceeded = false;
unsigned i;
for (i = 0; i < sizeof(CmdName)-1 && i < CurRequestSize; ++i)
{
char c = CurRequest[i];
if (c == ' ' || c == '\t')
{
parseSucceeded = true;
break;
}
CmdName[i] = c;
}
CmdName[i] = '\0';
if (!parseSucceeded) {
printf(""failed to parse RTSP\n"");
return false;
}
printf(""RTSP received %s\n"", CmdName);
if (strstr(CmdName,""OPTIONS"")   != nullptr) m_RtspCmdType = RTSP_OPTIONS; else
if (strstr(CmdName,""DESCRIBE"")  != nullptr) m_RtspCmdType = RTSP_DESCRIBE; else
if (strstr(CmdName,""SETUP"")     != nullptr) m_RtspCmdType = RTSP_SETUP; else
if (strstr(CmdName,""PLAY"")      != nullptr) m_RtspCmdType = RTSP_PLAY; else
if (strstr(CmdName,""TEARDOWN"")  != nullptr) m_RtspCmdType = RTSP_TEARDOWN;
if (m_RtspCmdType == RTSP_SETUP)
{
TmpPtr = strstr(CurRequest,""RTP/AVP/TCP"");
if (TmpPtr != nullptr) m_TcpTransport = true; else m_TcpTransport = false;
};
unsigned j = i+1;
while (j < CurRequestSize && (CurRequest[j] == ' ' || CurRequest[j] == '\t')) ++j;     for (; (int)j < (int)(CurRequestSize-8); ++j)
{
if ((CurRequest[j]   == 'r' || CurRequest[j]   == 'R')   &&
(CurRequest[j+1] == 't' || CurRequest[j+1] == 'T') &&
(CurRequest[j+2] == 's' || CurRequest[j+2] == 'S') &&
(CurRequest[j+3] == 'p' || CurRequest[j+3] == 'P') &&
CurRequest[j+4] == ':' && CurRequest[j+5] == '/')
{
j += 6;
if (CurRequest[j] == '/')
{                   ++j;
unsigned uidx = 0;
while (j < CurRequestSize && CurRequest[j] != '/' && CurRequest[j] != ' ' && uidx < sizeof(m_URLHostPort) - 1)
{                       m_URLHostPort[uidx] = CurRequest[j];
uidx++;
++j;
};
}
else --j;
i = j;
break;
}
}
parseSucceeded = false;
for (unsigned k = i+1; (int)k < (int)(CurRequestSize-5); ++k)
{
if (CurRequest[k]   == 'R'   && CurRequest[k+1] == 'T'   &&
CurRequest[k+2] == 'S'   && CurRequest[k+3] == 'P'   &&
CurRequest[k+4] == '/')
{
while (--k >= i && CurRequest[k] == ' ') {}
unsigned k1 = k;
while (k1 > i && CurRequest[k1] != '/') --k1;
if (k - k1 + 1 > sizeof(m_URLSuffix)) return false;
unsigned n = 0, k2 = k1+1;
while (k2 <= k) m_URLSuffix[n++] = CurRequest[k2++];
m_URLSuffix[n] = '\0';
if (k1 - i > sizeof(m_URLPreSuffix)) return false;
n = 0; k2 = i + 1;
while (k2 <= k1 - 1) m_URLPreSuffix[n++] = CurRequest[k2++];
m_URLPreSuffix[n] = '\0';
i = k + 7;
parseSucceeded = true;
break;
}
}
if (!parseSucceeded) return false;
parseSucceeded = false;
for (j = i; (int)j < (int)(CurRequestSize-5); ++j)
{
if (CurRequest[j]   == 'C' && CurRequest[j+1] == 'S' &&
CurRequest[j+2] == 'e' && CurRequest[j+3] == 'q' &&
CurRequest[j+4] == ':')
{
j += 5;
while (j < CurRequestSize && (CurRequest[j] ==  ' ' || CurRequest[j] == '\t')) ++j;
unsigned n;
for (n = 0; n < sizeof(m_CSeq)-1 && j < CurRequestSize; ++n,++j)
{
char c = CurRequest[j];
if (c == '\r' || c == '\n')
{
parseSucceeded = true;
break;
}
m_CSeq[n] = c;
}
m_CSeq[n] = '\0';
break;
}
}
if (!parseSucceeded) return false;
for (j = i; (int)j < (int)(CurRequestSize-15); ++j)
{
if (CurRequest[j]    == 'C'  && CurRequest[j+1]  == 'o'  &&
CurRequest[j+2]  == 'n'  && CurRequest[j+3]  == 't'  &&
CurRequest[j+4]  == 'e'  && CurRequest[j+5]  == 'n'  &&
CurRequest[j+6]  == 't'  && CurRequest[j+7]  == '-'  &&
(CurRequest[j+8] == 'L' || CurRequest[j+8]   == 'l') &&
CurRequest[j+9]  == 'e'  && CurRequest[j+10] == 'n' &&
CurRequest[j+11] == 'g' && CurRequest[j+12]  == 't' &&
CurRequest[j+13] == 'h' && CurRequest[j+14] == ':')
{
j += 15;
while (j < CurRequestSize && (CurRequest[j] ==  ' ' || CurRequest[j] == '\t')) ++j;
unsigned num;
if (sscanf(&CurRequest[j], ""%u"", &num) == 1) m_ContentLength = num;
}
}
return true;
}","bool CRtspSession::ParseRtspRequest(char const * VAR_0, unsigned VAR_1)
{
unsigned VAR_2;
Init();
VAR_2 = VAR_1;
memcpy(VAR_3,VAR_0,VAR_1);
char * VAR_4;
char * VAR_5;
char VAR_6[128]; 
char * VAR_7;
VAR_4 = strstr(VAR_3,""client_port"");
if (VAR_4 != nullptr)
{
VAR_5 = strstr(VAR_4,""\r\n"");
if (VAR_5 != nullptr)
{
VAR_5[0] = 0x00;
strcpy(VAR_6,VAR_4);
VAR_7 = strstr(VAR_6,""="");
if (VAR_7 != nullptr)
{
VAR_7++;
strcpy(VAR_6,VAR_7);
VAR_7 = strstr(VAR_6,""-"");
if (VAR_7 != nullptr)
{
VAR_7[0] = 0x00;
VAR_8  = atoi(VAR_6);
VAR_9 = VAR_8 + 1;
};
};
};
};
bool VAR_10 = false;
unsigned VAR_11;
for (VAR_11 = 0; VAR_11 < sizeof(VAR_12)-1 && VAR_11 < VAR_2; ++VAR_11)
{
char VAR_13 = VAR_3[VAR_11];
if (VAR_13 == ' ' || VAR_13 == '\t')
{
VAR_10 = true;
break;
}
VAR_12[VAR_11] = VAR_13;
}
VAR_12[VAR_11] = '\0';
if (!VAR_10) {
printf(""failed to parse RTSP\n"");
return false;
}
printf(""RTSP received %s\n"", VAR_12);
if (strstr(VAR_12,""OPTIONS"")   != nullptr) VAR_14 = VAR_15; else
if (strstr(VAR_12,""DESCRIBE"")  != nullptr) VAR_14 = VAR_16; else
if (strstr(VAR_12,""SETUP"")     != nullptr) VAR_14 = VAR_17; else
if (strstr(VAR_12,""PLAY"")      != nullptr) VAR_14 = VAR_18; else
if (strstr(VAR_12,""TEARDOWN"")  != nullptr) VAR_14 = VAR_19;
if (VAR_14 == VAR_17)
{
VAR_5 = strstr(VAR_3,""RTP/AVP/TCP"");
if (VAR_5 != nullptr) VAR_20 = true; else VAR_20 = false;
};
unsigned VAR_21 = VAR_11+1;
while (VAR_21 < VAR_2 && (VAR_3[VAR_21] == ' ' || VAR_3[VAR_21] == '\t')) ++VAR_21; 
for (; (int)VAR_21 < (int)(VAR_2-8); ++VAR_21)
{
if ((VAR_3[VAR_21]   == 'r' || VAR_3[VAR_21]   == 'R')   &&
(VAR_3[VAR_21+1] == 't' || VAR_3[VAR_21+1] == 'T') &&
(VAR_3[VAR_21+2] == 's' || VAR_3[VAR_21+2] == 'S') &&
(VAR_3[VAR_21+3] == 'p' || VAR_3[VAR_21+3] == 'P') &&
VAR_3[VAR_21+4] == ':' && VAR_3[VAR_21+5] == '/')
{
VAR_21 += 6;
if (VAR_3[VAR_21] == '/')
{   
++VAR_21;
unsigned VAR_22 = 0;
while (VAR_21 < VAR_2 && VAR_3[VAR_21] != '/' && VAR_3[VAR_21] != ' ' && VAR_22 < sizeof(VAR_23) - 1)
{   
VAR_23[VAR_22] = VAR_3[VAR_21];
VAR_22++;
++VAR_21;
};
}
else --VAR_21;
VAR_11 = VAR_21;
break;
}
}
VAR_10 = false;
for (unsigned VAR_24 = VAR_11+1; (int)VAR_24 < (int)(VAR_2-5); ++VAR_24)
{
if (VAR_3[VAR_24]   == 'R'   && VAR_3[VAR_24+1] == 'T'   &&
VAR_3[VAR_24+2] == 'S'   && VAR_3[VAR_24+3] == 'P'   &&
VAR_3[VAR_24+4] == '/')
{
while (--VAR_24 >= VAR_11 && VAR_3[VAR_24] == ' ') {}
unsigned VAR_25 = VAR_24;
while (VAR_25 > VAR_11 && VAR_3[VAR_25] != '/') --VAR_25;
if (VAR_24 - VAR_25 + 1 > sizeof(VAR_26)) return false;
unsigned VAR_27 = 0, VAR_28 = VAR_25+1;
while (VAR_28 <= VAR_24) VAR_26[VAR_27++] = VAR_3[VAR_28++];
VAR_26[VAR_27] = '\0';
if (VAR_25 - VAR_11 > sizeof(VAR_29)) return false;
VAR_27 = 0; VAR_28 = VAR_11 + 1;
while (VAR_28 <= VAR_25 - 1) VAR_29[VAR_27++] = VAR_3[VAR_28++];
VAR_29[VAR_27] = '\0';
VAR_11 = VAR_24 + 7;
VAR_10 = true;
break;
}
}
if (!VAR_10) return false;
VAR_10 = false;
for (VAR_21 = VAR_11; (int)VAR_21 < (int)(VAR_2-5); ++VAR_21)
{
if (VAR_3[VAR_21]   == 'C' && VAR_3[VAR_21+1] == 'S' &&
VAR_3[VAR_21+2] == 'e' && VAR_3[VAR_21+3] == 'q' &&
VAR_3[VAR_21+4] == ':')
{
VAR_21 += 5;
while (VAR_21 < VAR_2 && (VAR_3[VAR_21] ==  ' ' || VAR_3[VAR_21] == '\t')) ++VAR_21;
unsigned VAR_27;
for (VAR_27 = 0; VAR_27 < sizeof(VAR_30)-1 && VAR_21 < VAR_2; ++VAR_27,++VAR_21)
{
char VAR_13 = VAR_3[VAR_21];
if (VAR_13 == '\r' || VAR_13 == '\n')
{
VAR_10 = true;
break;
}
VAR_30[VAR_27] = VAR_13;
}
VAR_30[VAR_27] = '\0';
break;
}
}
if (!VAR_10) return false;
for (VAR_21 = VAR_11; (int)VAR_21 < (int)(VAR_2-15); ++VAR_21)
{
if (VAR_3[VAR_21]    == 'C'  && VAR_3[VAR_21+1]  == 'o'  &&
VAR_3[VAR_21+2]  == 'n'  && VAR_3[VAR_21+3]  == 't'  &&
VAR_3[VAR_21+4]  == 'e'  && VAR_3[VAR_21+5]  == 'n'  &&
VAR_3[VAR_21+6]  == 't'  && VAR_3[VAR_21+7]  == '-'  &&
(VAR_3[VAR_21+8] == 'L' || VAR_3[VAR_21+8]   == 'l') &&
VAR_3[VAR_21+9]  == 'e'  && VAR_3[VAR_21+10] == 'n' &&
VAR_3[VAR_21+11] == 'g' && VAR_3[VAR_21+12]  == 't' &&
VAR_3[VAR_21+13] == 'h' && VAR_3[VAR_21+14] == ':')
{
VAR_21 += 15;
while (VAR_21 < VAR_2 && (VAR_3[VAR_21] ==  ' ' || VAR_3[VAR_21] == '\t')) ++VAR_21;
unsigned VAR_31;
if (sscanf(&VAR_3[VAR_21], ""%u"", &VAR_31) == 1) VAR_32 = VAR_31;
}
}
return true;
}",arendst/Tasmota/066878da4d4762a9b6cb169fdf353e804d735cfd/CRtspSession.cpp/vul/before/0.json,"bool CRtspSession::ParseRtspRequest(char const * aRequest, unsigned aRequestSize)
{
    // char CmdName[RTSP_PARAM_STRING_MAX];
    //char CurRequest[RTSP_BUFFER_SIZE]; // Note: we assume single threaded, this large buf we keep off of the tiny stack
    unsigned CurRequestSize;

    Init();
    CurRequestSize = aRequestSize;
    memcpy(CurRequest,aRequest,aRequestSize);

    // check whether the request contains information about the RTP/RTCP UDP client ports (SETUP command)
    char * ClientPortPtr;
    char * TmpPtr;
    char CP[128]; //static char CP[1024];
    char * pCP;
    int Length;


    ClientPortPtr = strstr(CurRequest,""client_port"");
    if (ClientPortPtr != nullptr)
    {
        TmpPtr = strstr(ClientPortPtr,""\r\n"");
        if (TmpPtr != nullptr)
        {
            TmpPtr[0] = 0x00;
            Length = strlen(ClientPortPtr);
            if (Length > 128)
            {
                Length = 128;
            }
            strncpy(CP,ClientPortPtr, Length);
            pCP = strstr(CP,""="");
            if (pCP != nullptr)
            {
                pCP++;
                strcpy(CP,pCP);
                pCP = strstr(CP,""-"");
                if (pCP != nullptr)
                {
                    pCP[0] = 0x00;
                    m_ClientRTPPort  = atoi(CP);
                    m_ClientRTCPPort = m_ClientRTPPort + 1;
                };
            };
        };
    };

    // Read everything up to the first space as the command name
    bool parseSucceeded = false;
    unsigned i;
    for (i = 0; i < sizeof(CmdName)-1 && i < CurRequestSize; ++i)
    {
        char c = CurRequest[i];
        if (c == ' ' || c == '\t')
        {
            parseSucceeded = true;
            break;
        }
        CmdName[i] = c;
    }
    CmdName[i] = '\0';
    if (!parseSucceeded) {
        printf(""failed to parse RTSP\n"");
        return false;
    }

    printf(""RTSP received %s\n"", CmdName);

    // find out the command type
    if (strstr(CmdName,""OPTIONS"")   != nullptr) m_RtspCmdType = RTSP_OPTIONS; else
    if (strstr(CmdName,""DESCRIBE"")  != nullptr) m_RtspCmdType = RTSP_DESCRIBE; else
    if (strstr(CmdName,""SETUP"")     != nullptr) m_RtspCmdType = RTSP_SETUP; else
    if (strstr(CmdName,""PLAY"")      != nullptr) m_RtspCmdType = RTSP_PLAY; else
    if (strstr(CmdName,""TEARDOWN"")  != nullptr) m_RtspCmdType = RTSP_TEARDOWN;

    // check whether the request contains transport information (UDP or TCP)
    if (m_RtspCmdType == RTSP_SETUP)
    {
        TmpPtr = strstr(CurRequest,""RTP/AVP/TCP"");
        if (TmpPtr != nullptr) m_TcpTransport = true; else m_TcpTransport = false;
    };

    // Skip over the prefix of any ""rtsp://"" or ""rtsp:/"" URL that follows:
    unsigned j = i+1;
    while (j < CurRequestSize && (CurRequest[j] == ' ' || CurRequest[j] == '\t')) ++j; // skip over any additional white space
    for (; (int)j < (int)(CurRequestSize-8); ++j)
    {
        if ((CurRequest[j]   == 'r' || CurRequest[j]   == 'R')   &&
            (CurRequest[j+1] == 't' || CurRequest[j+1] == 'T') &&
            (CurRequest[j+2] == 's' || CurRequest[j+2] == 'S') &&
            (CurRequest[j+3] == 'p' || CurRequest[j+3] == 'P') &&
            CurRequest[j+4] == ':' && CurRequest[j+5] == '/')
        {
            j += 6;
            if (CurRequest[j] == '/')
            {   // This is a ""rtsp://"" URL; skip over the host:port part that follows:
                ++j;
                unsigned uidx = 0;
                while (j < CurRequestSize && CurRequest[j] != '/' && CurRequest[j] != ' ' && uidx < sizeof(m_URLHostPort) - 1)
                {   // extract the host:port part of the URL here
                    m_URLHostPort[uidx] = CurRequest[j];
                    uidx++;
                    ++j;
                };
            }
            else --j;
            i = j;
            break;
        }
    }

    // Look for the URL suffix (before the following ""RTSP/""):
    parseSucceeded = false;
    for (unsigned k = i+1; (int)k < (int)(CurRequestSize-5); ++k)
    {
        if (CurRequest[k]   == 'R'   && CurRequest[k+1] == 'T'   &&
            CurRequest[k+2] == 'S'   && CurRequest[k+3] == 'P'   &&
            CurRequest[k+4] == '/')
        {
            while (--k >= i && CurRequest[k] == ' ') {}
            unsigned k1 = k;
            while (k1 > i && CurRequest[k1] != '/') --k1;
            if (k - k1 + 1 > sizeof(m_URLSuffix)) return false;
            unsigned n = 0, k2 = k1+1;

            while (k2 <= k) m_URLSuffix[n++] = CurRequest[k2++];
            m_URLSuffix[n] = '\0';

            if (k1 - i > sizeof(m_URLPreSuffix)) return false;
            n = 0; k2 = i + 1;
            while (k2 <= k1 - 1) m_URLPreSuffix[n++] = CurRequest[k2++];
            m_URLPreSuffix[n] = '\0';
            i = k + 7;
            parseSucceeded = true;
            break;
        }
    }
    if (!parseSucceeded) return false;

    // Look for ""CSeq:"", skip whitespace, then read everything up to the next \r or \n as 'CSeq':
    parseSucceeded = false;
    for (j = i; (int)j < (int)(CurRequestSize-5); ++j)
    {
        if (CurRequest[j]   == 'C' && CurRequest[j+1] == 'S' &&
            CurRequest[j+2] == 'e' && CurRequest[j+3] == 'q' &&
            CurRequest[j+4] == ':')
        {
            j += 5;
            while (j < CurRequestSize && (CurRequest[j] ==  ' ' || CurRequest[j] == '\t')) ++j;
            unsigned n;
            for (n = 0; n < sizeof(m_CSeq)-1 && j < CurRequestSize; ++n,++j)
            {
                char c = CurRequest[j];
                if (c == '\r' || c == '\n')
                {
                    parseSucceeded = true;
                    break;
                }
                m_CSeq[n] = c;
            }
            m_CSeq[n] = '\0';
            break;
        }
    }
    if (!parseSucceeded) return false;

    // Also: Look for ""Content-Length:"" (optional)
    for (j = i; (int)j < (int)(CurRequestSize-15); ++j)
    {
        if (CurRequest[j]    == 'C'  && CurRequest[j+1]  == 'o'  &&
            CurRequest[j+2]  == 'n'  && CurRequest[j+3]  == 't'  &&
            CurRequest[j+4]  == 'e'  && CurRequest[j+5]  == 'n'  &&
            CurRequest[j+6]  == 't'  && CurRequest[j+7]  == '-'  &&
            (CurRequest[j+8] == 'L' || CurRequest[j+8]   == 'l') &&
            CurRequest[j+9]  == 'e'  && CurRequest[j+10] == 'n' &&
            CurRequest[j+11] == 'g' && CurRequest[j+12]  == 't' &&
            CurRequest[j+13] == 'h' && CurRequest[j+14] == ':')
        {
            j += 15;
            while (j < CurRequestSize && (CurRequest[j] ==  ' ' || CurRequest[j] == '\t')) ++j;
            unsigned num;
            if (sscanf(&CurRequest[j], ""%u"", &num) == 1) m_ContentLength = num;
        }
    }
    return true;
}","bool CRtspSession::ParseRtspRequest(char const * VAR_0, unsigned VAR_1)
{
    /* COMMENT_0 */
    /* COMMENT_1 */
    unsigned VAR_2;

    Init();
    VAR_2 = VAR_1;
    memcpy(VAR_3,VAR_0,VAR_1);

    /* COMMENT_2 */
    char * VAR_4;
    char * VAR_5;
    char VAR_6[128]; /* COMMENT_3 */
    char * VAR_7;
    int VAR_8;


    VAR_4 = strstr(VAR_3,""client_port"");
    if (VAR_4 != nullptr)
    {
        VAR_5 = strstr(VAR_4,""\r\n"");
        if (VAR_5 != nullptr)
        {
            VAR_5[0] = 0x00;
            VAR_8 = strlen(VAR_4);
            if (VAR_8 > 128)
            {
                VAR_8 = 128;
            }
            strncpy(VAR_6,VAR_4, VAR_8);
            VAR_7 = strstr(VAR_6,""="");
            if (VAR_7 != nullptr)
            {
                VAR_7++;
                strcpy(VAR_6,VAR_7);
                VAR_7 = strstr(VAR_6,""-"");
                if (VAR_7 != nullptr)
                {
                    VAR_7[0] = 0x00;
                    VAR_9  = atoi(VAR_6);
                    VAR_10 = VAR_9 + 1;
                };
            };
        };
    };

    /* COMMENT_4 */
    bool VAR_11 = false;
    unsigned VAR_12;
    for (VAR_12 = 0; VAR_12 < sizeof(VAR_13)-1 && VAR_12 < VAR_2; ++VAR_12)
    {
        char VAR_14 = VAR_3[VAR_12];
        if (VAR_14 == ' ' || VAR_14 == '\t')
        {
            VAR_11 = true;
            break;
        }
        VAR_13[VAR_12] = VAR_14;
    }
    VAR_13[VAR_12] = '\0';
    if (!VAR_11) {
        printf(""failed to parse RTSP\n"");
        return false;
    }

    printf(""RTSP received %s\n"", VAR_13);

    /* COMMENT_5 */
    if (strstr(VAR_13,""OPTIONS"")   != nullptr) VAR_15 = VAR_16; else
    if (strstr(VAR_13,""DESCRIBE"")  != nullptr) VAR_15 = VAR_17; else
    if (strstr(VAR_13,""SETUP"")     != nullptr) VAR_15 = VAR_18; else
    if (strstr(VAR_13,""PLAY"")      != nullptr) VAR_15 = VAR_19; else
    if (strstr(VAR_13,""TEARDOWN"")  != nullptr) VAR_15 = VAR_20;

    /* COMMENT_6 */
    if (VAR_15 == VAR_18)
    {
        VAR_5 = strstr(VAR_3,""RTP/AVP/TCP"");
        if (VAR_5 != nullptr) VAR_21 = true; else VAR_21 = false;
    };

    /* COMMENT_7 */
    unsigned VAR_22 = VAR_12+1;
    while (VAR_22 < VAR_2 && (VAR_3[VAR_22] == ' ' || VAR_3[VAR_22] == '\t')) ++VAR_22; /* COMMENT_8 */
    for (; (int)VAR_22 < (int)(VAR_2-8); ++VAR_22)
    {
        if ((VAR_3[VAR_22]   == 'r' || VAR_3[VAR_22]   == 'R')   &&
            (VAR_3[VAR_22+1] == 't' || VAR_3[VAR_22+1] == 'T') &&
            (VAR_3[VAR_22+2] == 's' || VAR_3[VAR_22+2] == 'S') &&
            (VAR_3[VAR_22+3] == 'p' || VAR_3[VAR_22+3] == 'P') &&
            VAR_3[VAR_22+4] == ':' && VAR_3[VAR_22+5] == '/')
        {
            VAR_22 += 6;
            if (VAR_3[VAR_22] == '/')
            {   /* COMMENT_9 */
                ++VAR_22;
                unsigned VAR_23 = 0;
                while (VAR_22 < VAR_2 && VAR_3[VAR_22] != '/' && VAR_3[VAR_22] != ' ' && VAR_23 < sizeof(VAR_24) - 1)
                {   /* COMMENT_10 */
                    VAR_24[VAR_23] = VAR_3[VAR_22];
                    VAR_23++;
                    ++VAR_22;
                };
            }
            else --VAR_22;
            VAR_12 = VAR_22;
            break;
        }
    }

    /* COMMENT_11 */
    VAR_11 = false;
    for (unsigned VAR_25 = VAR_12+1; (int)VAR_25 < (int)(VAR_2-5); ++VAR_25)
    {
        if (VAR_3[VAR_25]   == 'R'   && VAR_3[VAR_25+1] == 'T'   &&
            VAR_3[VAR_25+2] == 'S'   && VAR_3[VAR_25+3] == 'P'   &&
            VAR_3[VAR_25+4] == '/')
        {
            while (--VAR_25 >= VAR_12 && VAR_3[VAR_25] == ' ') {}
            unsigned VAR_26 = VAR_25;
            while (VAR_26 > VAR_12 && VAR_3[VAR_26] != '/') --VAR_26;
            if (VAR_25 - VAR_26 + 1 > sizeof(VAR_27)) return false;
            unsigned VAR_28 = 0, VAR_29 = VAR_26+1;

            while (VAR_29 <= VAR_25) VAR_27[VAR_28++] = VAR_3[VAR_29++];
            VAR_27[VAR_28] = '\0';

            if (VAR_26 - VAR_12 > sizeof(VAR_30)) return false;
            VAR_28 = 0; VAR_29 = VAR_12 + 1;
            while (VAR_29 <= VAR_26 - 1) VAR_30[VAR_28++] = VAR_3[VAR_29++];
            VAR_30[VAR_28] = '\0';
            VAR_12 = VAR_25 + 7;
            VAR_11 = true;
            break;
        }
    }
    if (!VAR_11) return false;

    /* COMMENT_12 */
    VAR_11 = false;
    for (VAR_22 = VAR_12; (int)VAR_22 < (int)(VAR_2-5); ++VAR_22)
    {
        if (VAR_3[VAR_22]   == 'C' && VAR_3[VAR_22+1] == 'S' &&
            VAR_3[VAR_22+2] == 'e' && VAR_3[VAR_22+3] == 'q' &&
            VAR_3[VAR_22+4] == ':')
        {
            VAR_22 += 5;
            while (VAR_22 < VAR_2 && (VAR_3[VAR_22] ==  ' ' || VAR_3[VAR_22] == '\t')) ++VAR_22;
            unsigned VAR_28;
            for (VAR_28 = 0; VAR_28 < sizeof(VAR_31)-1 && VAR_22 < VAR_2; ++VAR_28,++VAR_22)
            {
                char VAR_14 = VAR_3[VAR_22];
                if (VAR_14 == '\r' || VAR_14 == '\n')
                {
                    VAR_11 = true;
                    break;
                }
                VAR_31[VAR_28] = VAR_14;
            }
            VAR_31[VAR_28] = '\0';
            break;
        }
    }
    if (!VAR_11) return false;

    /* COMMENT_13 */
    for (VAR_22 = VAR_12; (int)VAR_22 < (int)(VAR_2-15); ++VAR_22)
    {
        if (VAR_3[VAR_22]    == 'C'  && VAR_3[VAR_22+1]  == 'o'  &&
            VAR_3[VAR_22+2]  == 'n'  && VAR_3[VAR_22+3]  == 't'  &&
            VAR_3[VAR_22+4]  == 'e'  && VAR_3[VAR_22+5]  == 'n'  &&
            VAR_3[VAR_22+6]  == 't'  && VAR_3[VAR_22+7]  == '-'  &&
            (VAR_3[VAR_22+8] == 'L' || VAR_3[VAR_22+8]   == 'l') &&
            VAR_3[VAR_22+9]  == 'e'  && VAR_3[VAR_22+10] == 'n' &&
            VAR_3[VAR_22+11] == 'g' && VAR_3[VAR_22+12]  == 't' &&
            VAR_3[VAR_22+13] == 'h' && VAR_3[VAR_22+14] == ':')
        {
            VAR_22 += 15;
            while (VAR_22 < VAR_2 && (VAR_3[VAR_22] ==  ' ' || VAR_3[VAR_22] == '\t')) ++VAR_22;
            unsigned VAR_32;
            if (sscanf(&VAR_3[VAR_22], ""%u"", &VAR_32) == 1) VAR_33 = VAR_32;
        }
    }
    return true;
}",arendst/Tasmota/066878da4d4762a9b6cb169fdf353e804d735cfd/CRtspSession.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -13,6 +13,8 @@
     char * TmpPtr;
     char CP[128]; //static char CP[1024];
     char * pCP;
+    int Length;
+
 
     ClientPortPtr = strstr(CurRequest,""client_port"");
     if (ClientPortPtr != nullptr)
@@ -21,7 +23,12 @@
         if (TmpPtr != nullptr)
         {
             TmpPtr[0] = 0x00;
-            strcpy(CP,ClientPortPtr);
+            Length = strlen(ClientPortPtr);
+            if (Length > 128)
+            {
+                Length = 128;
+            }
+            strncpy(CP,ClientPortPtr, Length);
             pCP = strstr(CP,""="");
             if (pCP != nullptr)
             {","{'deleted_lines': ['            strcpy(CP,ClientPortPtr);'], 'added_lines': ['    int Length;', '', '            Length = strlen(ClientPortPtr);', '            if (Length > 128)', '            {', '                Length = 128;', '            }', '            strncpy(CP,ClientPortPtr, Length);']}",True,Tasmota before commit 066878da4d4762a9b6cb169fdf353e804d735cfd was discovered to contain a stack overflow via the ClientPortPtr parameter at lib/libesp32/rtsp/CRtspSession.cpp.,9.8,CRITICAL,3,test,2022-10-12T16:40:17Z,4
CVE-2022-39318,"['CWE-20', 'CWE-369']",CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:N/A:H,1,FreeRDP,"Fixed division by zero in urbdrc

(cherry picked from commit 731f8419d04b481d7160de1f34062d630ed48765)",80adde17ddc4b596ed1dae0922a0c54ab3d4b8ea,https://github.com/FreeRDP/FreeRDP/commit/80adde17ddc4b596ed1dae0922a0c54ab3d4b8ea,channels/urbdrc/client/libusb/libusb_udevice.c,libusb_udev_isoch_transfer,"static int libusb_udev_isoch_transfer(IUDEVICE* idev, URBDRC_CHANNEL_CALLBACK* callback,
UINT32 MessageId, UINT32 RequestId, UINT32 EndpointAddress,
UINT32 TransferFlags, UINT32 StartFrame, UINT32 ErrorCount,
BOOL NoAck, const BYTE* packetDescriptorData,
UINT32 NumberOfPackets, UINT32 BufferSize, const BYTE* Buffer,
t_isoch_transfer_cb cb, UINT32 Timeout)
{
UINT32 iso_packet_size;
UDEVICE* pdev = (UDEVICE*)idev;
ASYNC_TRANSFER_USER_DATA* user_data;
struct libusb_transfer* iso_transfer = NULL;
URBDRC_PLUGIN* urbdrc;
size_t outSize = (NumberOfPackets * 12);
uint32_t streamID = 0x40000000 | RequestId;
if (!pdev || !pdev->urbdrc)
return -1;
urbdrc = pdev->urbdrc;
user_data = async_transfer_user_data_new(idev, MessageId, 48, BufferSize, Buffer,
outSize + 1024, NoAck, cb, callback);
if (!user_data)
return -1;
user_data->ErrorCount = ErrorCount;
user_data->StartFrame = StartFrame;
if (!Buffer)
Stream_Seek(user_data->data, (NumberOfPackets * 12));
iso_packet_size = BufferSize / NumberOfPackets;
iso_transfer = libusb_alloc_transfer(NumberOfPackets);
if (iso_transfer == NULL)
{
WLog_Print(urbdrc->log, WLOG_ERROR, ""Error: libusb_alloc_transfer."");
async_transfer_user_data_free(user_data);
return -1;
}
libusb_fill_iso_transfer(iso_transfer, pdev->libusb_handle, EndpointAddress,
Stream_Pointer(user_data->data), BufferSize, NumberOfPackets,
func_iso_callback, user_data, Timeout);
set_stream_id_for_buffer(iso_transfer, streamID);
libusb_set_iso_packet_lengths(iso_transfer, iso_packet_size);
if (ArrayList_Add(pdev->request_queue, iso_transfer) < 0)
{
WLog_Print(urbdrc->log, WLOG_WARN,
""Failed to queue iso transfer, streamID %08"" PRIx32 "" already in use!"",
streamID);
request_free(iso_transfer);
return -1;
}
return libusb_submit_transfer(iso_transfer);
}","static int libusb_udev_isoch_transfer(IUDEVICE* VAR_0, URBDRC_CHANNEL_CALLBACK* VAR_1,
UINT32 VAR_2, UINT32 VAR_3, UINT32 VAR_4,
UINT32 VAR_5, UINT32 VAR_6, UINT32 VAR_7,
BOOL VAR_8, const BYTE* VAR_9,
UINT32 VAR_10, UINT32 VAR_11, const BYTE* VAR_12,
t_isoch_transfer_cb VAR_13, UINT32 VAR_14)
{
UINT32 VAR_15;
UDEVICE* VAR_16 = (UDEVICE*)VAR_0;
ASYNC_TRANSFER_USER_DATA* VAR_17;
struct libusb_transfer* VAR_18 = NULL;
URBDRC_PLUGIN* VAR_19;
size_t VAR_20 = (VAR_10 * 12);
uint32_t VAR_21 = 0x40000000 | VAR_3;
if (!VAR_16 || !VAR_16->urbdrc)
return -1;
VAR_19 = VAR_16->urbdrc;
VAR_17 = async_transfer_user_data_new(VAR_0, VAR_2, 48, VAR_11, VAR_12,
VAR_20 + 1024, VAR_8, VAR_13, VAR_1);
if (!VAR_17)
return -1;
VAR_17->ErrorCount = VAR_7;
VAR_17->StartFrame = VAR_6;
if (!VAR_12)
Stream_Seek(VAR_17->data, (VAR_10 * 12));
VAR_15 = VAR_11 / VAR_10;
VAR_18 = libusb_alloc_transfer(VAR_10);
if (VAR_18 == NULL)
{
WLog_Print(VAR_19->log, VAR_22, ""Error: libusb_alloc_transfer."");
async_transfer_user_data_free(VAR_17);
return -1;
}
libusb_fill_iso_transfer(VAR_18, VAR_16->libusb_handle, VAR_4,
Stream_Pointer(VAR_17->data), VAR_11, VAR_10,
VAR_23, VAR_17, VAR_14);
set_stream_id_for_buffer(VAR_18, VAR_21);
libusb_set_iso_packet_lengths(VAR_18, VAR_15);
if (ArrayList_Add(VAR_16->request_queue, VAR_18) < 0)
{
WLog_Print(VAR_19->log, VAR_24,
""Failed to queue iso transfer, streamID %08"" VAR_25 "" already in use!"",
VAR_21);
request_free(VAR_18);
return -1;
}
return libusb_submit_transfer(VAR_18);
}",FreeRDP/80adde17ddc4b596ed1dae0922a0c54ab3d4b8ea/libusb_udevice.c/vul/before/0.json,"static int libusb_udev_isoch_transfer(IUDEVICE* idev, URBDRC_CHANNEL_CALLBACK* callback,
                                      UINT32 MessageId, UINT32 RequestId, UINT32 EndpointAddress,
                                      UINT32 TransferFlags, UINT32 StartFrame, UINT32 ErrorCount,
                                      BOOL NoAck, const BYTE* packetDescriptorData,
                                      UINT32 NumberOfPackets, UINT32 BufferSize, const BYTE* Buffer,
                                      t_isoch_transfer_cb cb, UINT32 Timeout)
{
	UINT32 iso_packet_size;
	UDEVICE* pdev = (UDEVICE*)idev;
	ASYNC_TRANSFER_USER_DATA* user_data;
	struct libusb_transfer* iso_transfer = NULL;
	URBDRC_PLUGIN* urbdrc;
	size_t outSize = (NumberOfPackets * 12);
	uint32_t streamID = 0x40000000 | RequestId;

	if (!pdev || !pdev->urbdrc)
		return -1;

	urbdrc = pdev->urbdrc;
	user_data = async_transfer_user_data_new(idev, MessageId, 48, BufferSize, Buffer,
	                                         outSize + 1024, NoAck, cb, callback);

	if (!user_data)
		return -1;

	user_data->ErrorCount = ErrorCount;
	user_data->StartFrame = StartFrame;

	if (!Buffer)
		Stream_Seek(user_data->data, (NumberOfPackets * 12));

	if (NumberOfPackets > 0)
	{
		iso_packet_size = BufferSize / NumberOfPackets;
		iso_transfer = libusb_alloc_transfer((int)NumberOfPackets);
	}

	if (iso_transfer == NULL)
	{
		WLog_Print(urbdrc->log, WLOG_ERROR,
		           ""Error: libusb_alloc_transfer [NumberOfPackets=%"" PRIu32 "", BufferSize=%"" PRIu32
		           "" ]"",
		           NumberOfPackets, BufferSize);
		async_transfer_user_data_free(user_data);
		return -1;
	}

	/**  process URB_FUNCTION_IOSCH_TRANSFER */
	libusb_fill_iso_transfer(iso_transfer, pdev->libusb_handle, EndpointAddress,
	                         Stream_Pointer(user_data->data), BufferSize, NumberOfPackets,
	                         func_iso_callback, user_data, Timeout);
	set_stream_id_for_buffer(iso_transfer, streamID);
	libusb_set_iso_packet_lengths(iso_transfer, iso_packet_size);

	if (ArrayList_Add(pdev->request_queue, iso_transfer) < 0)
	{
		WLog_Print(urbdrc->log, WLOG_WARN,
		           ""Failed to queue iso transfer, streamID %08"" PRIx32 "" already in use!"",
		           streamID);
		request_free(iso_transfer);
		return -1;
	}
	return libusb_submit_transfer(iso_transfer);
}","static int libusb_udev_isoch_transfer(IUDEVICE* VAR_0, URBDRC_CHANNEL_CALLBACK* VAR_1,
                                      UINT32 VAR_2, UINT32 VAR_3, UINT32 VAR_4,
                                      UINT32 VAR_5, UINT32 VAR_6, UINT32 VAR_7,
                                      BOOL VAR_8, const BYTE* VAR_9,
                                      UINT32 VAR_10, UINT32 VAR_11, const BYTE* VAR_12,
                                      t_isoch_transfer_cb VAR_13, UINT32 VAR_14)
{
	UINT32 VAR_15;
	UDEVICE* VAR_16 = (UDEVICE*)VAR_0;
	ASYNC_TRANSFER_USER_DATA* VAR_17;
	struct libusb_transfer* VAR_18 = NULL;
	URBDRC_PLUGIN* VAR_19;
	size_t VAR_20 = (VAR_10 * 12);
	uint32_t VAR_21 = 0x40000000 | VAR_3;

	if (!VAR_16 || !VAR_16->urbdrc)
		return -1;

	VAR_19 = VAR_16->urbdrc;
	VAR_17 = async_transfer_user_data_new(VAR_0, VAR_2, 48, VAR_11, VAR_12,
	                                         VAR_20 + 1024, VAR_8, VAR_13, VAR_1);

	if (!VAR_17)
		return -1;

	VAR_17->ErrorCount = VAR_7;
	VAR_17->StartFrame = VAR_6;

	if (!VAR_12)
		Stream_Seek(VAR_17->data, (VAR_10 * 12));

	if (VAR_10 > 0)
	{
		VAR_15 = VAR_11 / VAR_10;
		VAR_18 = libusb_alloc_transfer((int)VAR_10);
	}

	if (VAR_18 == NULL)
	{
		WLog_Print(VAR_19->log, VAR_22,
		           ""Error: libusb_alloc_transfer [NumberOfPackets=%"" VAR_23 "", BufferSize=%"" VAR_23
		           "" ]"",
		           VAR_10, VAR_11);
		async_transfer_user_data_free(VAR_17);
		return -1;
	}

	/* COMMENT_0 */
	libusb_fill_iso_transfer(VAR_18, VAR_16->libusb_handle, VAR_4,
	                         Stream_Pointer(VAR_17->data), VAR_11, VAR_10,
	                         VAR_24, VAR_17, VAR_14);
	set_stream_id_for_buffer(VAR_18, VAR_21);
	libusb_set_iso_packet_lengths(VAR_18, VAR_15);

	if (ArrayList_Add(VAR_16->request_queue, VAR_18) < 0)
	{
		WLog_Print(VAR_19->log, VAR_25,
		           ""Failed to queue iso transfer, streamID %08"" VAR_26 "" already in use!"",
		           VAR_21);
		request_free(VAR_18);
		return -1;
	}
	return libusb_submit_transfer(VAR_18);
}",FreeRDP/80adde17ddc4b596ed1dae0922a0c54ab3d4b8ea/libusb_udevice.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -29,12 +29,18 @@
 	if (!Buffer)
 		Stream_Seek(user_data->data, (NumberOfPackets * 12));
 
-	iso_packet_size = BufferSize / NumberOfPackets;
-	iso_transfer = libusb_alloc_transfer(NumberOfPackets);
+	if (NumberOfPackets > 0)
+	{
+		iso_packet_size = BufferSize / NumberOfPackets;
+		iso_transfer = libusb_alloc_transfer((int)NumberOfPackets);
+	}
 
 	if (iso_transfer == NULL)
 	{
-		WLog_Print(urbdrc->log, WLOG_ERROR, ""Error: libusb_alloc_transfer."");
+		WLog_Print(urbdrc->log, WLOG_ERROR,
+		           ""Error: libusb_alloc_transfer [NumberOfPackets=%"" PRIu32 "", BufferSize=%"" PRIu32
+		           "" ]"",
+		           NumberOfPackets, BufferSize);
 		async_transfer_user_data_free(user_data);
 		return -1;
 	}","{'deleted_lines': ['\tiso_packet_size = BufferSize / NumberOfPackets;', '\tiso_transfer = libusb_alloc_transfer(NumberOfPackets);', '\t\tWLog_Print(urbdrc->log, WLOG_ERROR, ""Error: libusb_alloc_transfer."");'], 'added_lines': ['\tif (NumberOfPackets > 0)', '\t{', '\t\tiso_packet_size = BufferSize / NumberOfPackets;', '\t\tiso_transfer = libusb_alloc_transfer((int)NumberOfPackets);', '\t}', '\t\tWLog_Print(urbdrc->log, WLOG_ERROR,', '\t\t           ""Error: libusb_alloc_transfer [NumberOfPackets=%"" PRIu32 "", BufferSize=%"" PRIu32', '\t\t           "" ]"",', '\t\t           NumberOfPackets, BufferSize);']}",True,FreeRDP is a free remote desktop protocol library and clients. Affected versions of FreeRDP are missing input validation in `urbdrc` channel. A malicious server can trick a FreeRDP based client to crash with division by zero. This issue has been addressed in version 2.9.0. All users are advised to upgrade. Users unable to upgrade should not use the `/usb` redirection switch.,4.8,MEDIUM,1,test,2022-10-13T06:27:41Z,4
CVE-2022-3957,['CWE-404'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,gpac,fixed mem leak in sgv parse error,2191e66aa7df750e8ef01781b1930bea87b713bb,https://github.com/gpac/gpac/commit/2191e66aa7df750e8ef01781b1930bea87b713bb,src/scenegraph/svg_attributes.c,svg_parse_preserveaspectratio,"static void svg_parse_preserveaspectratio(SVG_PreserveAspectRatio *par, char *attribute_content, GF_Err *out_e)
{
char *content = attribute_content;
while (*content == ' ') content++;
if (strstr(content, ""defer"")) {
par->defer = 1;
content += 4;
} else {
content = attribute_content;
}
while (*content == ' ') content++;
if (strstr(content, ""none"")) {
par->align = SVG_PRESERVEASPECTRATIO_NONE;
content+=4;
} else if (strstr(content, ""xMinYMin"")) {
par->align = SVG_PRESERVEASPECTRATIO_XMINYMIN;
content+=8;
} else if (strstr(content, ""xMidYMin"")) {
par->align = SVG_PRESERVEASPECTRATIO_XMIDYMIN;
content+=8;
} else if (strstr(content, ""xMaxYMin"")) {
par->align = SVG_PRESERVEASPECTRATIO_XMAXYMIN;
content+=8;
} else if (strstr(content, ""xMinYMid"")) {
par->align = SVG_PRESERVEASPECTRATIO_XMINYMID;
content+=8;
} else if (strstr(content, ""xMidYMid"")) {
par->align = SVG_PRESERVEASPECTRATIO_XMIDYMID;
content+=8;
} else if (strstr(content, ""xMaxYMid"")) {
par->align = SVG_PRESERVEASPECTRATIO_XMAXYMID;
content+=8;
} else if (strstr(content, ""xMinYMax"")) {
par->align = SVG_PRESERVEASPECTRATIO_XMINYMAX;
content+=8;
} else if (strstr(content, ""xMidYMax"")) {
par->align = SVG_PRESERVEASPECTRATIO_XMIDYMAX;
content+=8;
} else if (strstr(content, ""xMaxYMax"")) {
par->align = SVG_PRESERVEASPECTRATIO_XMAXYMAX;
content+=8;
} else {
*out_e = GF_NON_COMPLIANT_BITSTREAM;
}
while (*content == ' ') content++;
if (*content == 0) return;
if (strstr(content, ""meet"")) {
par->meetOrSlice = SVG_MEETORSLICE_MEET;
} else if (strstr(content, ""slice"")) {
par->meetOrSlice = SVG_MEETORSLICE_SLICE;
} else {
*out_e = GF_NON_COMPLIANT_BITSTREAM;
}
}","static void svg_parse_preserveaspectratio(SVG_PreserveAspectRatio *VAR_0, char *VAR_1, GF_Err *VAR_2)
{
char *VAR_3 = VAR_1;
while (*VAR_3 == ' ') VAR_3++;
if (strstr(VAR_3, ""defer"")) {
VAR_0->defer = 1;
VAR_3 += 4;
} else {
VAR_3 = VAR_1;
}
while (*VAR_3 == ' ') VAR_3++;
if (strstr(VAR_3, ""none"")) {
VAR_0->align = VAR_4;
VAR_3+=4;
} else if (strstr(VAR_3, ""xMinYMin"")) {
VAR_0->align = VAR_5;
VAR_3+=8;
} else if (strstr(VAR_3, ""xMidYMin"")) {
VAR_0->align = VAR_6;
VAR_3+=8;
} else if (strstr(VAR_3, ""xMaxYMin"")) {
VAR_0->align = VAR_7;
VAR_3+=8;
} else if (strstr(VAR_3, ""xMinYMid"")) {
VAR_0->align = VAR_8;
VAR_3+=8;
} else if (strstr(VAR_3, ""xMidYMid"")) {
VAR_0->align = VAR_9;
VAR_3+=8;
} else if (strstr(VAR_3, ""xMaxYMid"")) {
VAR_0->align = VAR_10;
VAR_3+=8;
} else if (strstr(VAR_3, ""xMinYMax"")) {
VAR_0->align = VAR_11;
VAR_3+=8;
} else if (strstr(VAR_3, ""xMidYMax"")) {
VAR_0->align = VAR_12;
VAR_3+=8;
} else if (strstr(VAR_3, ""xMaxYMax"")) {
VAR_0->align = VAR_13;
VAR_3+=8;
} else {
*VAR_2 = VAR_14;
}
while (*VAR_3 == ' ') VAR_3++;
if (*VAR_3 == 0) return;
if (strstr(VAR_3, ""meet"")) {
VAR_0->meetOrSlice = VAR_15;
} else if (strstr(VAR_3, ""slice"")) {
VAR_0->meetOrSlice = VAR_16;
} else {
*VAR_2 = VAR_14;
}
}",gpac/2191e66aa7df750e8ef01781b1930bea87b713bb/svg_attributes.c/vul/before/1.json,"static void svg_parse_preserveaspectratio(SVG_PreserveAspectRatio *par, char *attribute_content, GF_Err *out_e)
{
	char *content = attribute_content;
	while (*content == ' ') content++;
	if (strstr(content, ""defer"")) {
		par->defer = 1;
		content += 5;
	} else {
		content = attribute_content;
	}
	while (*content == ' ') content++;
	if (strstr(content, ""none"")) {
		par->align = SVG_PRESERVEASPECTRATIO_NONE;
		content+=4;
	} else if (strstr(content, ""xMinYMin"")) {
		par->align = SVG_PRESERVEASPECTRATIO_XMINYMIN;
		content+=8;
	} else if (strstr(content, ""xMidYMin"")) {
		par->align = SVG_PRESERVEASPECTRATIO_XMIDYMIN;
		content+=8;
	} else if (strstr(content, ""xMaxYMin"")) {
		par->align = SVG_PRESERVEASPECTRATIO_XMAXYMIN;
		content+=8;
	} else if (strstr(content, ""xMinYMid"")) {
		par->align = SVG_PRESERVEASPECTRATIO_XMINYMID;
		content+=8;
	} else if (strstr(content, ""xMidYMid"")) {
		par->align = SVG_PRESERVEASPECTRATIO_XMIDYMID;
		content+=8;
	} else if (strstr(content, ""xMaxYMid"")) {
		par->align = SVG_PRESERVEASPECTRATIO_XMAXYMID;
		content+=8;
	} else if (strstr(content, ""xMinYMax"")) {
		par->align = SVG_PRESERVEASPECTRATIO_XMINYMAX;
		content+=8;
	} else if (strstr(content, ""xMidYMax"")) {
		par->align = SVG_PRESERVEASPECTRATIO_XMIDYMAX;
		content+=8;
	} else if (strstr(content, ""xMaxYMax"")) {
		par->align = SVG_PRESERVEASPECTRATIO_XMAXYMAX;
		content+=8;
	} else {
		*out_e = GF_NON_COMPLIANT_BITSTREAM;
	}
	while (*content == ' ') content++;
	if (*content == 0) return;

	if (strstr(content, ""meet"")) {
		par->meetOrSlice = SVG_MEETORSLICE_MEET;
	} else if (strstr(content, ""slice"")) {
		par->meetOrSlice = SVG_MEETORSLICE_SLICE;
	} else {
		*out_e = GF_NON_COMPLIANT_BITSTREAM;
	}
}","static void svg_parse_preserveaspectratio(SVG_PreserveAspectRatio *VAR_0, char *VAR_1, GF_Err *VAR_2)
{
	char *VAR_3 = VAR_1;
	while (*VAR_3 == ' ') VAR_3++;
	if (strstr(VAR_3, ""defer"")) {
		VAR_0->defer = 1;
		VAR_3 += 5;
	} else {
		VAR_3 = VAR_1;
	}
	while (*VAR_3 == ' ') VAR_3++;
	if (strstr(VAR_3, ""none"")) {
		VAR_0->align = VAR_4;
		VAR_3+=4;
	} else if (strstr(VAR_3, ""xMinYMin"")) {
		VAR_0->align = VAR_5;
		VAR_3+=8;
	} else if (strstr(VAR_3, ""xMidYMin"")) {
		VAR_0->align = VAR_6;
		VAR_3+=8;
	} else if (strstr(VAR_3, ""xMaxYMin"")) {
		VAR_0->align = VAR_7;
		VAR_3+=8;
	} else if (strstr(VAR_3, ""xMinYMid"")) {
		VAR_0->align = VAR_8;
		VAR_3+=8;
	} else if (strstr(VAR_3, ""xMidYMid"")) {
		VAR_0->align = VAR_9;
		VAR_3+=8;
	} else if (strstr(VAR_3, ""xMaxYMid"")) {
		VAR_0->align = VAR_10;
		VAR_3+=8;
	} else if (strstr(VAR_3, ""xMinYMax"")) {
		VAR_0->align = VAR_11;
		VAR_3+=8;
	} else if (strstr(VAR_3, ""xMidYMax"")) {
		VAR_0->align = VAR_12;
		VAR_3+=8;
	} else if (strstr(VAR_3, ""xMaxYMax"")) {
		VAR_0->align = VAR_13;
		VAR_3+=8;
	} else {
		*VAR_2 = VAR_14;
	}
	while (*VAR_3 == ' ') VAR_3++;
	if (*VAR_3 == 0) return;

	if (strstr(VAR_3, ""meet"")) {
		VAR_0->meetOrSlice = VAR_15;
	} else if (strstr(VAR_3, ""slice"")) {
		VAR_0->meetOrSlice = VAR_16;
	} else {
		*VAR_2 = VAR_14;
	}
}",gpac/2191e66aa7df750e8ef01781b1930bea87b713bb/svg_attributes.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
 	while (*content == ' ') content++;
 	if (strstr(content, ""defer"")) {
 		par->defer = 1;
-		content += 4;
+		content += 5;
 	} else {
 		content = attribute_content;
 	}","{'deleted_lines': ['\t\tcontent += 4;'], 'added_lines': ['\t\tcontent += 5;']}",True,A vulnerability classified as problematic was found in GPAC. Affected by this vulnerability is the function svg_parse_preserveaspectratio of the file scenegraph/svg_attributes.c of the component SVG Parser. The manipulation leads to memory leak. The attack can be launched remotely. The name of the patch is 2191e66aa7df750e8ef01781b1930bea87b713bb. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-213463.,6.5,MEDIUM,1,test,2022-11-07T07:59:52Z,4
CVE-2022-3957,['CWE-404'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,gpac,fixed mem leak in sgv parse error,2191e66aa7df750e8ef01781b1930bea87b713bb,https://github.com/gpac/gpac/commit/2191e66aa7df750e8ef01781b1930bea87b713bb,src/scenegraph/svg_attributes.c,gf_svg_parse_attribute,"GF_EXPORT
GF_Err gf_svg_parse_attribute(GF_Node *n, GF_FieldInfo *info, char *attribute_content, u8 anim_value_type)
{
GF_Err e = GF_OK;
if (info->fieldType != DOM_String_datatype && strlen(attribute_content)) {
u32 i, len;
while (attribute_content[0] && (strchr(""\r\n\t "", attribute_content[0])))
attribute_content++;
i=0;
len = (u32) strlen(attribute_content);
while (i<len) {
if (strchr(""\r\n\t"", attribute_content[i]))
attribute_content[i] = ' ';
i++;
}
while (len && attribute_content[len-1]==' ') {
attribute_content[len-1] = 0;
len--;
}
}
switch (info->fieldType) {
case SVG_Boolean_datatype:
svg_parse_boolean((SVG_Boolean *)info->far_ptr, attribute_content, &e);
break;
case SVG_Color_datatype:
svg_parse_color((SVG_Color *)info->far_ptr, attribute_content, &e);
break;
case SVG_Paint_datatype:
svg_parse_paint(n, (SVG_Paint *)info->far_ptr, attribute_content, &e);
break;
case SVG_FillRule_datatype:
svg_parse_clipfillrule((SVG_FillRule *)info->far_ptr, attribute_content, &e);
break;
case SVG_StrokeLineJoin_datatype:
svg_parse_strokelinejoin((SVG_StrokeLineJoin *)info->far_ptr, attribute_content, &e);
break;
case SVG_StrokeLineCap_datatype:
svg_parse_strokelinecap((SVG_StrokeLineCap *)info->far_ptr, attribute_content, &e);
break;
case SVG_FontStyle_datatype:
svg_parse_fontstyle((SVG_FontStyle *)info->far_ptr, attribute_content, &e);
break;
case SVG_FontWeight_datatype:
svg_parse_fontweight((SVG_FontWeight *)info->far_ptr, attribute_content, &e);
break;
case SVG_FontVariant_datatype:
svg_parse_fontvariant((SVG_FontVariant *)info->far_ptr, attribute_content, &e);
break;
case SVG_TextAnchor_datatype:
svg_parse_textanchor((SVG_TextAnchor *)info->far_ptr, attribute_content, &e);
break;
case SVG_Display_datatype:
svg_parse_display((SVG_Display *)info->far_ptr, attribute_content, &e);
break;
case SVG_Visibility_datatype:
svg_parse_visibility((SVG_Visibility *)info->far_ptr, attribute_content, &e);
break;
case SVG_Overflow_datatype:
svg_parse_overflow((SVG_Overflow *)info->far_ptr, attribute_content, &e);
break;
case SVG_ZoomAndPan_datatype:
svg_parse_zoomandpan((SVG_ZoomAndPan *)info->far_ptr, attribute_content, &e);
break;
case SVG_DisplayAlign_datatype:
svg_parse_displayalign((SVG_DisplayAlign *)info->far_ptr, attribute_content, &e);
break;
case SVG_TextAlign_datatype:
svg_parse_textalign((SVG_TextAlign *)info->far_ptr, attribute_content, &e);
break;
case SVG_PointerEvents_datatype:
svg_parse_pointerevents((SVG_PointerEvents *)info->far_ptr, attribute_content, &e);
break;
case SVG_RenderingHint_datatype:
svg_parse_renderinghint((SVG_RenderingHint *)info->far_ptr, attribute_content, &e);
break;
case SVG_VectorEffect_datatype:
svg_parse_vectoreffect((SVG_VectorEffect *)info->far_ptr, attribute_content, &e);
break;
case SVG_PlaybackOrder_datatype:
svg_parse_playbackorder((SVG_PlaybackOrder *)info->far_ptr, attribute_content, &e);
break;
case SVG_TimelineBegin_datatype:
svg_parse_timelinebegin((SVG_TimelineBegin *)info->far_ptr, attribute_content, &e);
break;
case XML_Space_datatype:
svg_parse_xmlspace((XML_Space *)info->far_ptr, attribute_content, &e);
break;
case XMLEV_Propagate_datatype:
svg_parse_xmlev_propagate((XMLEV_Propagate *)info->far_ptr, attribute_content, &e);
break;
case XMLEV_DefaultAction_datatype:
svg_parse_xmlev_defaultAction((XMLEV_DefaultAction *)info->far_ptr, attribute_content, &e);
break;
case XMLEV_Phase_datatype:
svg_parse_xmlev_phase((XMLEV_Phase *)info->far_ptr, attribute_content, &e);
break;
case SMIL_SyncBehavior_datatype:
smil_parse_syncBehaviorOrDefault((SMIL_SyncBehavior *)info->far_ptr, attribute_content, &e);
break;
case SMIL_SyncTolerance_datatype:
smil_parse_syncToleranceOrDefault((SMIL_SyncTolerance *)info->far_ptr, attribute_content, &e);
break;
case SMIL_AttributeType_datatype:
smil_parse_attributeType((SMIL_AttributeType *)info->far_ptr, attribute_content, &e);
break;
case SMIL_CalcMode_datatype:
smil_parse_calcmode((SMIL_CalcMode *)info->far_ptr, attribute_content, &e);
break;
case SMIL_Additive_datatype:
smil_parse_additive((SMIL_CalcMode *)info->far_ptr, attribute_content, &e);
break;
case SMIL_Accumulate_datatype:
smil_parse_accumulate((SMIL_Accumulate *)info->far_ptr, attribute_content, &e);
break;
case SMIL_Restart_datatype:
smil_parse_restart((SMIL_Restart *)info->far_ptr, attribute_content, &e);
break;
case SMIL_Fill_datatype:
smil_parse_fill((SMIL_Fill *)info->far_ptr, attribute_content, &e);
break;
case SVG_GradientUnit_datatype:
if (!strcmp(attribute_content, ""userSpaceOnUse""))
*((SVG_GradientUnit *)info->far_ptr) = SVG_GRADIENTUNITS_USER;
else if (!strcmp(attribute_content, ""objectBoundingBox""))
*((SVG_GradientUnit *)info->far_ptr) = SVG_GRADIENTUNITS_OBJECT;
else
e = GF_NON_COMPLIANT_BITSTREAM;
break;
case SVG_FocusHighlight_datatype:
svg_parse_focushighlight((SVG_FocusHighlight*)info->far_ptr, attribute_content, &e);
break;
case SVG_Focusable_datatype:
svg_parse_focusable((SVG_Focusable*)info->far_ptr, attribute_content, &e);
break;
case SVG_InitialVisibility_datatype:
svg_parse_initialvisibility((SVG_InitialVisibility*)info->far_ptr, attribute_content, &e);
break;
case SVG_Overlay_datatype:
svg_parse_overlay((SVG_Overlay*)info->far_ptr, attribute_content, &e);
break;
case SVG_TransformBehavior_datatype:
svg_parse_transformbehavior((SVG_TransformBehavior*)info->far_ptr, attribute_content, &e);
break;
case SVG_SpreadMethod_datatype:
if (!strcmp(attribute_content, ""reflect"")) *(u8*)info->far_ptr = SVG_SPREAD_REFLECT;
else if (!strcmp(attribute_content, ""repeat"")) *(u8*)info->far_ptr = SVG_SPREAD_REPEAT;
else if (!strcmp(attribute_content, ""pad"")) *(u8*)info->far_ptr = SVG_SPREAD_PAD;
else e = GF_NON_COMPLIANT_BITSTREAM;
break;
case SVG_Filter_TransferType_datatype:
if (!strcmp(attribute_content, ""table"")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_TABLE;
else if (!strcmp(attribute_content, ""discrete"")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_DISCRETE;
else if (!strcmp(attribute_content, ""linear"")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_LINEAR;
else if (!strcmp(attribute_content, ""gamma"")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_GAMMA;
else if (!strcmp(attribute_content, ""identity"")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_IDENTITY;
else if (!strcmp(attribute_content, ""fractalNoise"")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_FRACTAL_NOISE;
else if (!strcmp(attribute_content, ""turbulence"")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_TURBULENCE;
else if (!strcmp(attribute_content, ""matrix"")) *(u8*)info->far_ptr = SVG_FILTER_MX_MATRIX;
else if (!strcmp(attribute_content, ""saturate"")) *(u8*)info->far_ptr = SVG_FILTER_MX_SATURATE;
else if (!strcmp(attribute_content, ""hueRotate"")) *(u8*)info->far_ptr = SVG_FILTER_HUE_ROTATE;
else if (!strcmp(attribute_content, ""luminanceToAlpha"")) *(u8*)info->far_ptr = SVG_FILTER_LUM_TO_ALPHA;
else e = GF_NON_COMPLIANT_BITSTREAM;
break;
case SVG_Length_datatype:
case SVG_Coordinate_datatype:
case SVG_FontSize_datatype:
case SVG_Rotate_datatype:
case SVG_Number_datatype:
svg_parse_length((SVG_Number*)info->far_ptr, attribute_content, 0, &e);
break;
case SMIL_AnimateValue_datatype:
svg_parse_one_anim_value(n, (SMIL_AnimateValue*)info->far_ptr, attribute_content, anim_value_type, &e);
break;
case SMIL_AnimateValues_datatype:
svg_parse_anim_values(n, (SMIL_AnimateValues*)info->far_ptr, attribute_content, anim_value_type, &e);
break;
case XMLRI_datatype:
svg_parse_iri(n, (XMLRI*)info->far_ptr, attribute_content);
break;
case XML_IDREF_datatype:
svg_parse_idref(n, (XMLRI*)info->far_ptr, attribute_content);
break;
case SMIL_AttributeName_datatype:
((SMIL_AttributeName *)info->far_ptr)->name = gf_strdup(attribute_content);
break;
case SMIL_Times_datatype:
smil_parse_time_list(n, *(GF_List **)info->far_ptr, attribute_content);
break;
case SMIL_Duration_datatype:
smil_parse_min_max_dur_repeatdur((SMIL_Duration*)info->far_ptr, attribute_content, &e);
break;
case SMIL_RepeatCount_datatype:
smil_parse_repeatcount((SMIL_RepeatCount*)info->far_ptr, attribute_content, &e);
break;
case SVG_PathData_datatype:
svg_parse_path((SVG_PathData*)info->far_ptr, attribute_content, &e);
break;
case SVG_Points_datatype:
svg_parse_points(*(GF_List **)(info->far_ptr), attribute_content, &e);
break;
case SMIL_KeyTimes_datatype:
case SMIL_KeyPoints_datatype:
case SMIL_KeySplines_datatype:
case SVG_Numbers_datatype:
svg_parse_numbers(*(GF_List **)(info->far_ptr), attribute_content, 0, &e);
break;
case SVG_Coordinates_datatype:
svg_parse_coordinates(*(GF_List **)(info->far_ptr), attribute_content, &e);
break;
case SVG_ViewBox_datatype:
svg_parse_viewbox((SVG_ViewBox*)info->far_ptr, attribute_content, &e);
break;
case SVG_StrokeDashArray_datatype:
svg_parse_strokedasharray((SVG_StrokeDashArray*)info->far_ptr, attribute_content, &e);
break;
case SVG_FontFamily_datatype:
svg_parse_fontfamily((SVG_FontFamily*)info->far_ptr, attribute_content, &e);
break;
case SVG_Motion_datatype:
svg_parse_point_into_matrix((GF_Matrix2D*)info->far_ptr, attribute_content, &e);
break;
case SVG_Transform_datatype:
e = svg_parse_transform((SVG_Transform*)info->far_ptr, attribute_content);
break;
case SVG_Transform_Translate_datatype:
{
u32 i = 0;
SVG_Point *p = (SVG_Point *)info->far_ptr;
i+=svg_parse_number(&(attribute_content[i]), &(p->x), 0, &e);
if (attribute_content[i] == 0) {
p->y = 0;
} else {
svg_parse_number(&(attribute_content[i]), &(p->y), 0, &e);
}
}
break;
case SVG_Transform_Scale_datatype:
{
u32 i = 0;
SVG_Point *p = (SVG_Point *)info->far_ptr;
i+=svg_parse_number(&(attribute_content[i]), &(p->x), 0, &e);
if (attribute_content[i] == 0) {
p->y = p->x;
} else {
svg_parse_number(&(attribute_content[i]), &(p->y), 0, &e);
}
}
break;
case SVG_Transform_SkewX_datatype:
case SVG_Transform_SkewY_datatype:
{
Fixed *p = (Fixed *)info->far_ptr;
svg_parse_number(attribute_content, p, 1, &e);
}
break;
case SVG_Transform_Rotate_datatype:
{
u32 i = 0;
SVG_Point_Angle *p = (SVG_Point_Angle *)info->far_ptr;
i+=svg_parse_number(&(attribute_content[i]), &(p->angle), 1, &e);
if (attribute_content[i] == 0) {
p->y = p->x = 0;
} else {
i+=svg_parse_number(&(attribute_content[i]), &(p->x), 0, &e);
svg_parse_number(&(attribute_content[i]), &(p->y), 0, &e);
}
}
break;
case SVG_PreserveAspectRatio_datatype:
svg_parse_preserveaspectratio((SVG_PreserveAspectRatio*)info->far_ptr, attribute_content, &e);
break;
case SVG_TransformType_datatype:
svg_parse_animatetransform_type((SVG_TransformType*)info->far_ptr, attribute_content, &e);
break;
case SVG_ID_datatype:
case DOM_String_datatype:
case SVG_ContentType_datatype:
case SVG_LanguageID_datatype:
if (*(SVG_String *)info->far_ptr) gf_free(*(SVG_String *)info->far_ptr);
*(SVG_String *)info->far_ptr = gf_strdup(attribute_content);
break;
case DOM_StringList_datatype:
svg_parse_strings(*(GF_List **)info->far_ptr, attribute_content, 0);
break;
case XMLRI_List_datatype:
svg_parse_strings(*(GF_List **)info->far_ptr, attribute_content, 1);
break;
case XMLEV_Event_datatype:
{
XMLEV_Event *xml_ev = (XMLEV_Event *)info->far_ptr;
char *sep = strchr(attribute_content, '(');
if (sep) {
sep[0] = 0;
xml_ev->type = gf_dom_event_type_by_name(attribute_content);
sep[0] = '(';
if ((xml_ev->type == GF_EVENT_REPEAT) || (xml_ev->type == GF_EVENT_REPEAT_EVENT)) {
char _v;
sscanf(sep, ""(%c)"", &_v);
xml_ev->parameter = _v;
} else { 
char *sep2 = strchr(attribute_content, ')');
sep2[0] = 0;
xml_ev->parameter = gf_dom_get_key_type(sep+1);
sep2[0] = ')';
}
} else {
xml_ev->parameter = 0;
xml_ev->type = gf_dom_event_type_by_name(attribute_content);
}
}
break;
case SVG_Focus_datatype:
svg_parse_focus(n, (SVG_Focus*)info->far_ptr, attribute_content, &e);
break;
case SVG_ClipPath_datatype:
svg_parse_clippath(n, (SVG_ClipPath*)info->far_ptr, attribute_content, &e);
break;
case LASeR_Choice_datatype:
e = laser_parse_choice((LASeR_Choice*)info->far_ptr, attribute_content);
break;
case LASeR_Size_datatype:
e = laser_parse_size((LASeR_Size*)info->far_ptr, attribute_content, &e);
break;
case SVG_Clock_datatype:
svg_parse_clock_value(attribute_content, (SVG_Clock*)info->far_ptr);
break;
case SVG_Unknown_datatype:
if (*(SVG_String *)info->far_ptr) gf_free(*(SVG_String *)info->far_ptr);
*(SVG_String *)info->far_ptr = gf_strdup(attribute_content);
break;
default:
GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (""[SVG Parsing] Cannot parse attribute %s\n"", info->name ? info->name : """"));
break;
}
if (e) {
GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (""[SVG Parsing] Cannot parse attribute %s value %s: %s\n"", info->name ? info->name : """", attribute_content, gf_error_to_string(e)));
}
return e;
}","GF_EXPORT
VAR_0 gf_svg_parse_attribute(GF_Node *VAR_1, GF_FieldInfo *VAR_2, char *VAR_3, u8 VAR_4)
{
GF_Err VAR_5 = VAR_6;
if (VAR_2->fieldType != VAR_7 && strlen(VAR_3)) {
u32 VAR_8, VAR_9;
while (VAR_3[0] && (strchr(""\r\n\t "", VAR_3[0])))
VAR_3++;
VAR_8=0;
VAR_9 = (u32) strlen(VAR_3);
while (VAR_8<VAR_9) {
if (strchr(""\r\n\t"", VAR_3[VAR_8]))
VAR_3[VAR_8] = ' ';
VAR_8++;
}
while (VAR_9 && VAR_3[VAR_9-1]==' ') {
VAR_3[VAR_9-1] = 0;
VAR_9--;
}
}
switch (VAR_2->fieldType) {
case VAR_10:
svg_parse_boolean((SVG_Boolean *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_11:
svg_parse_color((SVG_Color *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_12:
svg_parse_paint(VAR_1, (SVG_Paint *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_13:
svg_parse_clipfillrule((SVG_FillRule *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_14:
svg_parse_strokelinejoin((SVG_StrokeLineJoin *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_15:
svg_parse_strokelinecap((SVG_StrokeLineCap *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_16:
svg_parse_fontstyle((SVG_FontStyle *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_17:
svg_parse_fontweight((SVG_FontWeight *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_18:
svg_parse_fontvariant((SVG_FontVariant *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_19:
svg_parse_textanchor((SVG_TextAnchor *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_20:
svg_parse_display((SVG_Display *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_21:
svg_parse_visibility((SVG_Visibility *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_22:
svg_parse_overflow((SVG_Overflow *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_23:
svg_parse_zoomandpan((SVG_ZoomAndPan *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_24:
svg_parse_displayalign((SVG_DisplayAlign *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_25:
svg_parse_textalign((SVG_TextAlign *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_26:
svg_parse_pointerevents((SVG_PointerEvents *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_27:
svg_parse_renderinghint((SVG_RenderingHint *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_28:
svg_parse_vectoreffect((SVG_VectorEffect *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_29:
svg_parse_playbackorder((SVG_PlaybackOrder *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_30:
svg_parse_timelinebegin((SVG_TimelineBegin *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_31:
svg_parse_xmlspace((XML_Space *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_32:
svg_parse_xmlev_propagate((XMLEV_Propagate *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_33:
svg_parse_xmlev_defaultAction((XMLEV_DefaultAction *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_34:
svg_parse_xmlev_phase((XMLEV_Phase *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_35:
smil_parse_syncBehaviorOrDefault((SMIL_SyncBehavior *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_36:
smil_parse_syncToleranceOrDefault((SMIL_SyncTolerance *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_37:
smil_parse_attributeType((SMIL_AttributeType *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_38:
smil_parse_calcmode((SMIL_CalcMode *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_39:
smil_parse_additive((SMIL_CalcMode *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_40:
smil_parse_accumulate((SMIL_Accumulate *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_41:
smil_parse_restart((SMIL_Restart *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_42:
smil_parse_fill((SMIL_Fill *)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_43:
if (!strcmp(VAR_3, ""userSpaceOnUse""))
*((SVG_GradientUnit *)VAR_2->far_ptr) = VAR_44;
else if (!strcmp(VAR_3, ""objectBoundingBox""))
*((SVG_GradientUnit *)VAR_2->far_ptr) = VAR_45;
else
VAR_5 = VAR_46;
break;
case VAR_47:
svg_parse_focushighlight((SVG_FocusHighlight*)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_48:
svg_parse_focusable((SVG_Focusable*)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_49:
svg_parse_initialvisibility((SVG_InitialVisibility*)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_50:
svg_parse_overlay((SVG_Overlay*)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_51:
svg_parse_transformbehavior((SVG_TransformBehavior*)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_52:
if (!strcmp(VAR_3, ""reflect"")) *(u8*)VAR_2->far_ptr = VAR_53;
else if (!strcmp(VAR_3, ""repeat"")) *(u8*)VAR_2->far_ptr = VAR_54;
else if (!strcmp(VAR_3, ""pad"")) *(u8*)VAR_2->far_ptr = VAR_55;
else VAR_5 = VAR_46;
break;
case VAR_56:
if (!strcmp(VAR_3, ""table"")) *(u8*)VAR_2->far_ptr = VAR_57;
else if (!strcmp(VAR_3, ""discrete"")) *(u8*)VAR_2->far_ptr = VAR_58;
else if (!strcmp(VAR_3, ""linear"")) *(u8*)VAR_2->far_ptr = VAR_59;
else if (!strcmp(VAR_3, ""gamma"")) *(u8*)VAR_2->far_ptr = VAR_60;
else if (!strcmp(VAR_3, ""identity"")) *(u8*)VAR_2->far_ptr = VAR_61;
else if (!strcmp(VAR_3, ""fractalNoise"")) *(u8*)VAR_2->far_ptr = VAR_62;
else if (!strcmp(VAR_3, ""turbulence"")) *(u8*)VAR_2->far_ptr = VAR_63;
else if (!strcmp(VAR_3, ""matrix"")) *(u8*)VAR_2->far_ptr = VAR_64;
else if (!strcmp(VAR_3, ""saturate"")) *(u8*)VAR_2->far_ptr = VAR_65;
else if (!strcmp(VAR_3, ""hueRotate"")) *(u8*)VAR_2->far_ptr = VAR_66;
else if (!strcmp(VAR_3, ""luminanceToAlpha"")) *(u8*)VAR_2->far_ptr = VAR_67;
else VAR_5 = VAR_46;
break;
case VAR_68:
case VAR_69:
case VAR_70:
case VAR_71:
case VAR_72:
svg_parse_length((SVG_Number*)VAR_2->far_ptr, VAR_3, 0, &VAR_5);
break;
case VAR_73:
svg_parse_one_anim_value(VAR_1, (SMIL_AnimateValue*)VAR_2->far_ptr, VAR_3, VAR_4, &VAR_5);
break;
case VAR_74:
svg_parse_anim_values(VAR_1, (SMIL_AnimateValues*)VAR_2->far_ptr, VAR_3, VAR_4, &VAR_5);
break;
case VAR_75:
svg_parse_iri(VAR_1, (XMLRI*)VAR_2->far_ptr, VAR_3);
break;
case VAR_76:
svg_parse_idref(VAR_1, (XMLRI*)VAR_2->far_ptr, VAR_3);
break;
case VAR_77:
((SMIL_AttributeName *)VAR_2->far_ptr)->name = gf_strdup(VAR_3);
break;
case VAR_78:
smil_parse_time_list(VAR_1, *(GF_List **)VAR_2->far_ptr, VAR_3);
break;
case VAR_79:
smil_parse_min_max_dur_repeatdur((SMIL_Duration*)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_80:
smil_parse_repeatcount((SMIL_RepeatCount*)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_81:
svg_parse_path((SVG_PathData*)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_82:
svg_parse_points(*(GF_List **)(VAR_2->far_ptr), VAR_3, &VAR_5);
break;
case VAR_83:
case VAR_84:
case VAR_85:
case VAR_86:
svg_parse_numbers(*(GF_List **)(VAR_2->far_ptr), VAR_3, 0, &VAR_5);
break;
case VAR_87:
svg_parse_coordinates(*(GF_List **)(VAR_2->far_ptr), VAR_3, &VAR_5);
break;
case VAR_88:
svg_parse_viewbox((SVG_ViewBox*)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_89:
svg_parse_strokedasharray((SVG_StrokeDashArray*)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_90:
svg_parse_fontfamily((SVG_FontFamily*)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_91:
svg_parse_point_into_matrix((GF_Matrix2D*)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_92:
VAR_5 = svg_parse_transform((SVG_Transform*)VAR_2->far_ptr, VAR_3);
break;
case VAR_93:
{
u32 VAR_8 = 0;
SVG_Point *VAR_94 = (SVG_Point *)VAR_2->far_ptr;
VAR_8+=svg_parse_number(&(VAR_3[VAR_8]), &(VAR_94->x), 0, &VAR_5);
if (VAR_3[VAR_8] == 0) {
VAR_94->y = 0;
} else {
svg_parse_number(&(VAR_3[VAR_8]), &(VAR_94->y), 0, &VAR_5);
}
}
break;
case VAR_95:
{
u32 VAR_8 = 0;
SVG_Point *VAR_94 = (SVG_Point *)VAR_2->far_ptr;
VAR_8+=svg_parse_number(&(VAR_3[VAR_8]), &(VAR_94->x), 0, &VAR_5);
if (VAR_3[VAR_8] == 0) {
VAR_94->y = VAR_94->x;
} else {
svg_parse_number(&(VAR_3[VAR_8]), &(VAR_94->y), 0, &VAR_5);
}
}
break;
case VAR_96:
case VAR_97:
{
Fixed *VAR_94 = (Fixed *)VAR_2->far_ptr;
svg_parse_number(VAR_3, VAR_94, 1, &VAR_5);
}
break;
case VAR_98:
{
u32 VAR_8 = 0;
SVG_Point_Angle *VAR_94 = (SVG_Point_Angle *)VAR_2->far_ptr;
VAR_8+=svg_parse_number(&(VAR_3[VAR_8]), &(VAR_94->angle), 1, &VAR_5);
if (VAR_3[VAR_8] == 0) {
VAR_94->y = VAR_94->x = 0;
} else {
VAR_8+=svg_parse_number(&(VAR_3[VAR_8]), &(VAR_94->x), 0, &VAR_5);
svg_parse_number(&(VAR_3[VAR_8]), &(VAR_94->y), 0, &VAR_5);
}
}
break;
case VAR_99:
svg_parse_preserveaspectratio((SVG_PreserveAspectRatio*)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_100:
svg_parse_animatetransform_type((SVG_TransformType*)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_101:
case VAR_7:
case VAR_102:
case VAR_103:
if (*(SVG_String *)VAR_2->far_ptr) gf_free(*(SVG_String *)VAR_2->far_ptr);
*(SVG_String *)VAR_2->far_ptr = gf_strdup(VAR_3);
break;
case VAR_104:
svg_parse_strings(*(GF_List **)VAR_2->far_ptr, VAR_3, 0);
break;
case VAR_105:
svg_parse_strings(*(GF_List **)VAR_2->far_ptr, VAR_3, 1);
break;
case VAR_106:
{
XMLEV_Event *VAR_107 = (XMLEV_Event *)VAR_2->far_ptr;
char *VAR_108 = strchr(VAR_3, '(');
if (VAR_108) {
VAR_108[0] = 0;
VAR_107->type = gf_dom_event_type_by_name(VAR_3);
VAR_108[0] = '(';
if ((VAR_107->type == VAR_109) || (VAR_107->type == VAR_110)) {
char VAR_111;
sscanf(VAR_108, ""(%c)"", &VAR_111);
VAR_107->parameter = VAR_111;
} else { 
char *VAR_112 = strchr(VAR_3, ')');
VAR_112[0] = 0;
VAR_107->parameter = gf_dom_get_key_type(VAR_108+1);
VAR_112[0] = ')';
}
} else {
VAR_107->parameter = 0;
VAR_107->type = gf_dom_event_type_by_name(VAR_3);
}
}
break;
case VAR_113:
svg_parse_focus(VAR_1, (SVG_Focus*)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_114:
svg_parse_clippath(VAR_1, (SVG_ClipPath*)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_115:
VAR_5 = laser_parse_choice((LASeR_Choice*)VAR_2->far_ptr, VAR_3);
break;
case VAR_116:
VAR_5 = laser_parse_size((LASeR_Size*)VAR_2->far_ptr, VAR_3, &VAR_5);
break;
case VAR_117:
svg_parse_clock_value(VAR_3, (SVG_Clock*)VAR_2->far_ptr);
break;
case VAR_118:
if (*(SVG_String *)VAR_2->far_ptr) gf_free(*(SVG_String *)VAR_2->far_ptr);
*(SVG_String *)VAR_2->far_ptr = gf_strdup(VAR_3);
break;
default:
GF_LOG(VAR_119, VAR_120, (""[SVG Parsing] Cannot parse attribute %s\n"", VAR_2->name ? VAR_2->name : """"));
break;
}
if (VAR_5) {
GF_LOG(VAR_121, VAR_120, (""[SVG Parsing] Cannot parse attribute %s value %s: %s\n"", VAR_2->name ? VAR_2->name : """", VAR_3, gf_error_to_string(VAR_5)));
}
return VAR_5;
}",,"GF_EXPORT
GF_Err gf_svg_parse_attribute(GF_Node *n, GF_FieldInfo *info, char *attribute_content, u8 anim_value_type)
{
	GF_Err e = GF_OK;
	/* for all attributes, except strings, apply some sort of white space normalization*/
	if (info->fieldType != DOM_String_datatype && strlen(attribute_content)) {
		u32 i, len;
		/*remove spaces at the beginning*/
		while (attribute_content[0] && (strchr(""\r\n\t "", attribute_content[0])))
			attribute_content++;

		/*change all special chars in spaces*/
		i=0;
		len = (u32) strlen(attribute_content);
		while (i<len) {
			if (strchr(""\r\n\t"", attribute_content[i]))
				attribute_content[i] = ' ';
			i++;
		}
		/*remove spaces in the end*/
		while (len && attribute_content[len-1]==' ') {
			attribute_content[len-1] = 0;
			len--;
		}
	}

	switch (info->fieldType) {
	case SVG_Boolean_datatype:
		svg_parse_boolean((SVG_Boolean *)info->far_ptr, attribute_content, &e);
		break;
	case SVG_Color_datatype:
		svg_parse_color((SVG_Color *)info->far_ptr, attribute_content, &e);
		break;
	case SVG_Paint_datatype:
		svg_parse_paint(n, (SVG_Paint *)info->far_ptr, attribute_content, &e);
		break;

	/* beginning of keyword type parsing */
	case SVG_FillRule_datatype:
		svg_parse_clipfillrule((SVG_FillRule *)info->far_ptr, attribute_content, &e);
		break;
	case SVG_StrokeLineJoin_datatype:
		svg_parse_strokelinejoin((SVG_StrokeLineJoin *)info->far_ptr, attribute_content, &e);
		break;
	case SVG_StrokeLineCap_datatype:
		svg_parse_strokelinecap((SVG_StrokeLineCap *)info->far_ptr, attribute_content, &e);
		break;
	case SVG_FontStyle_datatype:
		svg_parse_fontstyle((SVG_FontStyle *)info->far_ptr, attribute_content, &e);
		break;
	case SVG_FontWeight_datatype:
		svg_parse_fontweight((SVG_FontWeight *)info->far_ptr, attribute_content, &e);
		break;
	case SVG_FontVariant_datatype:
		svg_parse_fontvariant((SVG_FontVariant *)info->far_ptr, attribute_content, &e);
		break;
	case SVG_TextAnchor_datatype:
		svg_parse_textanchor((SVG_TextAnchor *)info->far_ptr, attribute_content, &e);
		break;
	case SVG_Display_datatype:
		svg_parse_display((SVG_Display *)info->far_ptr, attribute_content, &e);
		break;
	case SVG_Visibility_datatype:
		svg_parse_visibility((SVG_Visibility *)info->far_ptr, attribute_content, &e);
		break;
	case SVG_Overflow_datatype:
		svg_parse_overflow((SVG_Overflow *)info->far_ptr, attribute_content, &e);
		break;
	case SVG_ZoomAndPan_datatype:
		svg_parse_zoomandpan((SVG_ZoomAndPan *)info->far_ptr, attribute_content, &e);
		break;
	case SVG_DisplayAlign_datatype:
		svg_parse_displayalign((SVG_DisplayAlign *)info->far_ptr, attribute_content, &e);
		break;
	case SVG_TextAlign_datatype:
		svg_parse_textalign((SVG_TextAlign *)info->far_ptr, attribute_content, &e);
		break;
	case SVG_PointerEvents_datatype:
		svg_parse_pointerevents((SVG_PointerEvents *)info->far_ptr, attribute_content, &e);
		break;
	case SVG_RenderingHint_datatype:
		svg_parse_renderinghint((SVG_RenderingHint *)info->far_ptr, attribute_content, &e);
		break;
	case SVG_VectorEffect_datatype:
		svg_parse_vectoreffect((SVG_VectorEffect *)info->far_ptr, attribute_content, &e);
		break;
	case SVG_PlaybackOrder_datatype:
		svg_parse_playbackorder((SVG_PlaybackOrder *)info->far_ptr, attribute_content, &e);
		break;
	case SVG_TimelineBegin_datatype:
		svg_parse_timelinebegin((SVG_TimelineBegin *)info->far_ptr, attribute_content, &e);
		break;
	case XML_Space_datatype:
		svg_parse_xmlspace((XML_Space *)info->far_ptr, attribute_content, &e);
		break;
	case XMLEV_Propagate_datatype:
		svg_parse_xmlev_propagate((XMLEV_Propagate *)info->far_ptr, attribute_content, &e);
		break;
	case XMLEV_DefaultAction_datatype:
		svg_parse_xmlev_defaultAction((XMLEV_DefaultAction *)info->far_ptr, attribute_content, &e);
		break;
	case XMLEV_Phase_datatype:
		svg_parse_xmlev_phase((XMLEV_Phase *)info->far_ptr, attribute_content, &e);
		break;
	case SMIL_SyncBehavior_datatype:
		smil_parse_syncBehaviorOrDefault((SMIL_SyncBehavior *)info->far_ptr, attribute_content, &e);
		break;
	case SMIL_SyncTolerance_datatype:
		smil_parse_syncToleranceOrDefault((SMIL_SyncTolerance *)info->far_ptr, attribute_content, &e);
		break;
	case SMIL_AttributeType_datatype:
		smil_parse_attributeType((SMIL_AttributeType *)info->far_ptr, attribute_content, &e);
		break;
	case SMIL_CalcMode_datatype:
		smil_parse_calcmode((SMIL_CalcMode *)info->far_ptr, attribute_content, &e);
		break;
	case SMIL_Additive_datatype:
		smil_parse_additive((SMIL_CalcMode *)info->far_ptr, attribute_content, &e);
		break;
	case SMIL_Accumulate_datatype:
		smil_parse_accumulate((SMIL_Accumulate *)info->far_ptr, attribute_content, &e);
		break;
	case SMIL_Restart_datatype:
		smil_parse_restart((SMIL_Restart *)info->far_ptr, attribute_content, &e);
		break;
	case SMIL_Fill_datatype:
		smil_parse_fill((SMIL_Fill *)info->far_ptr, attribute_content, &e);
		break;
	case SVG_GradientUnit_datatype:
		if (!strcmp(attribute_content, ""userSpaceOnUse""))
			*((SVG_GradientUnit *)info->far_ptr) = SVG_GRADIENTUNITS_USER;
		else if (!strcmp(attribute_content, ""objectBoundingBox""))
			*((SVG_GradientUnit *)info->far_ptr) = SVG_GRADIENTUNITS_OBJECT;
		else
			e = GF_NON_COMPLIANT_BITSTREAM;
		break;
	case SVG_FocusHighlight_datatype:
		svg_parse_focushighlight((SVG_FocusHighlight*)info->far_ptr, attribute_content, &e);
		break;
	case SVG_Focusable_datatype:
		svg_parse_focusable((SVG_Focusable*)info->far_ptr, attribute_content, &e);
		break;
	case SVG_InitialVisibility_datatype:
		svg_parse_initialvisibility((SVG_InitialVisibility*)info->far_ptr, attribute_content, &e);
		break;
	case SVG_Overlay_datatype:
		svg_parse_overlay((SVG_Overlay*)info->far_ptr, attribute_content, &e);
		break;
	case SVG_TransformBehavior_datatype:
		svg_parse_transformbehavior((SVG_TransformBehavior*)info->far_ptr, attribute_content, &e);
		break;
	case SVG_SpreadMethod_datatype:
		if (!strcmp(attribute_content, ""reflect"")) *(u8*)info->far_ptr = SVG_SPREAD_REFLECT;
		else if (!strcmp(attribute_content, ""repeat"")) *(u8*)info->far_ptr = SVG_SPREAD_REPEAT;
		else if (!strcmp(attribute_content, ""pad"")) *(u8*)info->far_ptr = SVG_SPREAD_PAD;
		else e = GF_NON_COMPLIANT_BITSTREAM;
		break;
	case SVG_Filter_TransferType_datatype:
		if (!strcmp(attribute_content, ""table"")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_TABLE;
		else if (!strcmp(attribute_content, ""discrete"")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_DISCRETE;
		else if (!strcmp(attribute_content, ""linear"")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_LINEAR;
		else if (!strcmp(attribute_content, ""gamma"")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_GAMMA;
		else if (!strcmp(attribute_content, ""identity"")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_IDENTITY;
		else if (!strcmp(attribute_content, ""fractalNoise"")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_FRACTAL_NOISE;
		else if (!strcmp(attribute_content, ""turbulence"")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_TURBULENCE;
		else if (!strcmp(attribute_content, ""matrix"")) *(u8*)info->far_ptr = SVG_FILTER_MX_MATRIX;
		else if (!strcmp(attribute_content, ""saturate"")) *(u8*)info->far_ptr = SVG_FILTER_MX_SATURATE;
		else if (!strcmp(attribute_content, ""hueRotate"")) *(u8*)info->far_ptr = SVG_FILTER_HUE_ROTATE;
		else if (!strcmp(attribute_content, ""luminanceToAlpha"")) *(u8*)info->far_ptr = SVG_FILTER_LUM_TO_ALPHA;
		else e = GF_NON_COMPLIANT_BITSTREAM;
		break;

	/* end of keyword type parsing */

	/* keyword | numbers (with possibly units) */
	case SVG_Length_datatype:
	case SVG_Coordinate_datatype:
	case SVG_FontSize_datatype:
	case SVG_Rotate_datatype:
	case SVG_Number_datatype:
		svg_parse_length((SVG_Number*)info->far_ptr, attribute_content, 0, &e);
		break;

	case SMIL_AnimateValue_datatype:
		svg_parse_one_anim_value(n, (SMIL_AnimateValue*)info->far_ptr, attribute_content, anim_value_type, &e);
		break;
	case SMIL_AnimateValues_datatype:
		svg_parse_anim_values(n, (SMIL_AnimateValues*)info->far_ptr, attribute_content, anim_value_type, &e);
		break;

	case XMLRI_datatype:
		svg_parse_iri(n, (XMLRI*)info->far_ptr, attribute_content);
		break;
	case XML_IDREF_datatype:
		svg_parse_idref(n, (XMLRI*)info->far_ptr, attribute_content);
		break;
	case SMIL_AttributeName_datatype:
		((SMIL_AttributeName *)info->far_ptr)->name = gf_strdup(attribute_content);
		break;
	case SMIL_Times_datatype:
		smil_parse_time_list(n, *(GF_List **)info->far_ptr, attribute_content);
		break;
	case SMIL_Duration_datatype:
		smil_parse_min_max_dur_repeatdur((SMIL_Duration*)info->far_ptr, attribute_content, &e);
		break;
	case SMIL_RepeatCount_datatype:
		smil_parse_repeatcount((SMIL_RepeatCount*)info->far_ptr, attribute_content, &e);
		break;
	case SVG_PathData_datatype:
		svg_parse_path((SVG_PathData*)info->far_ptr, attribute_content, &e);
		break;
	case SVG_Points_datatype:
		svg_parse_points(*(GF_List **)(info->far_ptr), attribute_content, &e);
		break;
	case SMIL_KeyTimes_datatype:
	case SMIL_KeyPoints_datatype:
	case SMIL_KeySplines_datatype:
	case SVG_Numbers_datatype:
		svg_parse_numbers(*(GF_List **)(info->far_ptr), attribute_content, 0, &e);
		break;
	case SVG_Coordinates_datatype:
		svg_parse_coordinates(*(GF_List **)(info->far_ptr), attribute_content, &e);
		break;
	case SVG_ViewBox_datatype:
		svg_parse_viewbox((SVG_ViewBox*)info->far_ptr, attribute_content, &e);
		break;
	case SVG_StrokeDashArray_datatype:
		svg_parse_strokedasharray((SVG_StrokeDashArray*)info->far_ptr, attribute_content, &e);
		break;
	case SVG_FontFamily_datatype:
		svg_parse_fontfamily((SVG_FontFamily*)info->far_ptr, attribute_content, &e);
		break;
	case SVG_Motion_datatype:
		svg_parse_point_into_matrix((GF_Matrix2D*)info->far_ptr, attribute_content, &e);
		break;
	case SVG_Transform_datatype:
		e = svg_parse_transform((SVG_Transform*)info->far_ptr, attribute_content);
		break;
	case SVG_Transform_Translate_datatype:
	{
		u32 i = 0;
		SVG_Point *p = (SVG_Point *)info->far_ptr;
		i+=svg_parse_number(&(attribute_content[i]), &(p->x), 0, &e);
		if (attribute_content[i] == 0) {
			p->y = 0;
		} else {
			/*i+=*/svg_parse_number(&(attribute_content[i]), &(p->y), 0, &e);
		}
	}
	break;
	case SVG_Transform_Scale_datatype:
	{
		u32 i = 0;
		SVG_Point *p = (SVG_Point *)info->far_ptr;
		i+=svg_parse_number(&(attribute_content[i]), &(p->x), 0, &e);
		if (attribute_content[i] == 0) {
			p->y = p->x;
		} else {
			/*i+=*/svg_parse_number(&(attribute_content[i]), &(p->y), 0, &e);
		}
	}
	break;
	case SVG_Transform_SkewX_datatype:
	case SVG_Transform_SkewY_datatype:
	{
		Fixed *p = (Fixed *)info->far_ptr;
		svg_parse_number(attribute_content, p, 1, &e);
	}
	break;
	case SVG_Transform_Rotate_datatype:
	{
		u32 i = 0;
		SVG_Point_Angle *p = (SVG_Point_Angle *)info->far_ptr;
		i+=svg_parse_number(&(attribute_content[i]), &(p->angle), 1, &e);
		if (attribute_content[i] == 0) {
			p->y = p->x = 0;
		} else {
			i+=svg_parse_number(&(attribute_content[i]), &(p->x), 0, &e);
			/*i+=*/svg_parse_number(&(attribute_content[i]), &(p->y), 0, &e);
		}
	}
	break;
	case SVG_PreserveAspectRatio_datatype:
		svg_parse_preserveaspectratio((SVG_PreserveAspectRatio*)info->far_ptr, attribute_content, &e);
		break;
	case SVG_TransformType_datatype:
		svg_parse_animatetransform_type((SVG_TransformType*)info->far_ptr, attribute_content, &e);
		break;

	case SVG_ID_datatype:
	case DOM_String_datatype:
	case SVG_ContentType_datatype:
	case SVG_LanguageID_datatype:
		if (*(SVG_String *)info->far_ptr) gf_free(*(SVG_String *)info->far_ptr);

		*(SVG_String *)info->far_ptr = gf_strdup(attribute_content);
		break;

	case DOM_StringList_datatype:
		svg_parse_strings(*(GF_List **)info->far_ptr, attribute_content, 0);
		break;
	case XMLRI_List_datatype:
		svg_parse_strings(*(GF_List **)info->far_ptr, attribute_content, 1);
		break;

	case XMLEV_Event_datatype:
	{
		XMLEV_Event *xml_ev = (XMLEV_Event *)info->far_ptr;
		char *sep = strchr(attribute_content, '(');
		if (sep) {
			sep[0] = 0;
			xml_ev->type = gf_dom_event_type_by_name(attribute_content);
			sep[0] = '(';
			if ((xml_ev->type == GF_EVENT_REPEAT) || (xml_ev->type == GF_EVENT_REPEAT_EVENT)) {
				char _v;
				sscanf(sep, ""(%c)"", &_v);
				xml_ev->parameter = _v;
			} else { /* key events ... */
				char *sep2 = strchr(attribute_content, ')');
				sep2[0] = 0;
				xml_ev->parameter = gf_dom_get_key_type(sep+1);
				sep2[0] = ')';
			}
		} else {
			xml_ev->parameter = 0;
			xml_ev->type = gf_dom_event_type_by_name(attribute_content);
		}
	}
	break;

	case SVG_Focus_datatype:
		svg_parse_focus(n, (SVG_Focus*)info->far_ptr, attribute_content, &e);
		break;
	case SVG_ClipPath_datatype:
		svg_parse_clippath(n, (SVG_ClipPath*)info->far_ptr, attribute_content, &e);
		break;

	case LASeR_Choice_datatype:
		e = laser_parse_choice((LASeR_Choice*)info->far_ptr, attribute_content);
		break;
	case LASeR_Size_datatype:
		e = laser_parse_size((LASeR_Size*)info->far_ptr, attribute_content, &e);
		break;
	case SVG_Clock_datatype:
		svg_parse_clock_value(attribute_content, (SVG_Clock*)info->far_ptr);
		break;
	case SVG_Unknown_datatype:
		if (*(SVG_String *)info->far_ptr) gf_free(*(SVG_String *)info->far_ptr);
		*(SVG_String *)info->far_ptr = gf_strdup(attribute_content);
		break;
	default:
		GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (""[SVG Parsing] Cannot parse attribute \""%s\""\n"", info->name ? info->name : """"));
		return GF_OK;
	}
	if (e) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (""[SVG Parsing] Cannot parse attribute \""%s\"" value %s: %s\n"", info->name ? info->name : """", attribute_content, gf_error_to_string(e)));
		//continue parsing if not test mode
		if (!gf_sys_is_test_mode())
			e = GF_OK;
	}
	return e;
}","GF_EXPORT
VAR_0 gf_svg_parse_attribute(GF_Node *VAR_1, GF_FieldInfo *VAR_2, char *VAR_3, u8 VAR_4)
{
	GF_Err VAR_5 = VAR_6;
	/* COMMENT_0 */
	if (VAR_2->fieldType != VAR_7 && strlen(VAR_3)) {
		u32 VAR_8, VAR_9;
		/* COMMENT_1 */
		while (VAR_3[0] && (strchr(""\r\n\t "", VAR_3[0])))
			VAR_3++;

		/* COMMENT_2 */
		VAR_8=0;
		VAR_9 = (u32) strlen(VAR_3);
		while (VAR_8<VAR_9) {
			if (strchr(""\r\n\t"", VAR_3[VAR_8]))
				VAR_3[VAR_8] = ' ';
			VAR_8++;
		}
		/* COMMENT_3 */
		while (VAR_9 && VAR_3[VAR_9-1]==' ') {
			VAR_3[VAR_9-1] = 0;
			VAR_9--;
		}
	}

	switch (VAR_2->fieldType) {
	case VAR_10:
		svg_parse_boolean((SVG_Boolean *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_11:
		svg_parse_color((SVG_Color *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_12:
		svg_parse_paint(VAR_1, (SVG_Paint *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;

	/* COMMENT_4 */
	case VAR_13:
		svg_parse_clipfillrule((SVG_FillRule *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_14:
		svg_parse_strokelinejoin((SVG_StrokeLineJoin *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_15:
		svg_parse_strokelinecap((SVG_StrokeLineCap *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_16:
		svg_parse_fontstyle((SVG_FontStyle *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_17:
		svg_parse_fontweight((SVG_FontWeight *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_18:
		svg_parse_fontvariant((SVG_FontVariant *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_19:
		svg_parse_textanchor((SVG_TextAnchor *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_20:
		svg_parse_display((SVG_Display *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_21:
		svg_parse_visibility((SVG_Visibility *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_22:
		svg_parse_overflow((SVG_Overflow *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_23:
		svg_parse_zoomandpan((SVG_ZoomAndPan *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_24:
		svg_parse_displayalign((SVG_DisplayAlign *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_25:
		svg_parse_textalign((SVG_TextAlign *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_26:
		svg_parse_pointerevents((SVG_PointerEvents *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_27:
		svg_parse_renderinghint((SVG_RenderingHint *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_28:
		svg_parse_vectoreffect((SVG_VectorEffect *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_29:
		svg_parse_playbackorder((SVG_PlaybackOrder *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_30:
		svg_parse_timelinebegin((SVG_TimelineBegin *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_31:
		svg_parse_xmlspace((XML_Space *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_32:
		svg_parse_xmlev_propagate((XMLEV_Propagate *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_33:
		svg_parse_xmlev_defaultAction((XMLEV_DefaultAction *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_34:
		svg_parse_xmlev_phase((XMLEV_Phase *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_35:
		smil_parse_syncBehaviorOrDefault((SMIL_SyncBehavior *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_36:
		smil_parse_syncToleranceOrDefault((SMIL_SyncTolerance *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_37:
		smil_parse_attributeType((SMIL_AttributeType *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_38:
		smil_parse_calcmode((SMIL_CalcMode *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_39:
		smil_parse_additive((SMIL_CalcMode *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_40:
		smil_parse_accumulate((SMIL_Accumulate *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_41:
		smil_parse_restart((SMIL_Restart *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_42:
		smil_parse_fill((SMIL_Fill *)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_43:
		if (!strcmp(VAR_3, ""userSpaceOnUse""))
			*((SVG_GradientUnit *)VAR_2->far_ptr) = VAR_44;
		else if (!strcmp(VAR_3, ""objectBoundingBox""))
			*((SVG_GradientUnit *)VAR_2->far_ptr) = VAR_45;
		else
			VAR_5 = VAR_46;
		break;
	case VAR_47:
		svg_parse_focushighlight((SVG_FocusHighlight*)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_48:
		svg_parse_focusable((SVG_Focusable*)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_49:
		svg_parse_initialvisibility((SVG_InitialVisibility*)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_50:
		svg_parse_overlay((SVG_Overlay*)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_51:
		svg_parse_transformbehavior((SVG_TransformBehavior*)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_52:
		if (!strcmp(VAR_3, ""reflect"")) *(u8*)VAR_2->far_ptr = VAR_53;
		else if (!strcmp(VAR_3, ""repeat"")) *(u8*)VAR_2->far_ptr = VAR_54;
		else if (!strcmp(VAR_3, ""pad"")) *(u8*)VAR_2->far_ptr = VAR_55;
		else VAR_5 = VAR_46;
		break;
	case VAR_56:
		if (!strcmp(VAR_3, ""table"")) *(u8*)VAR_2->far_ptr = VAR_57;
		else if (!strcmp(VAR_3, ""discrete"")) *(u8*)VAR_2->far_ptr = VAR_58;
		else if (!strcmp(VAR_3, ""linear"")) *(u8*)VAR_2->far_ptr = VAR_59;
		else if (!strcmp(VAR_3, ""gamma"")) *(u8*)VAR_2->far_ptr = VAR_60;
		else if (!strcmp(VAR_3, ""identity"")) *(u8*)VAR_2->far_ptr = VAR_61;
		else if (!strcmp(VAR_3, ""fractalNoise"")) *(u8*)VAR_2->far_ptr = VAR_62;
		else if (!strcmp(VAR_3, ""turbulence"")) *(u8*)VAR_2->far_ptr = VAR_63;
		else if (!strcmp(VAR_3, ""matrix"")) *(u8*)VAR_2->far_ptr = VAR_64;
		else if (!strcmp(VAR_3, ""saturate"")) *(u8*)VAR_2->far_ptr = VAR_65;
		else if (!strcmp(VAR_3, ""hueRotate"")) *(u8*)VAR_2->far_ptr = VAR_66;
		else if (!strcmp(VAR_3, ""luminanceToAlpha"")) *(u8*)VAR_2->far_ptr = VAR_67;
		else VAR_5 = VAR_46;
		break;

	/* COMMENT_5 */

	/* COMMENT_6 */
	case VAR_68:
	case VAR_69:
	case VAR_70:
	case VAR_71:
	case VAR_72:
		svg_parse_length((SVG_Number*)VAR_2->far_ptr, VAR_3, 0, &VAR_5);
		break;

	case VAR_73:
		svg_parse_one_anim_value(VAR_1, (SMIL_AnimateValue*)VAR_2->far_ptr, VAR_3, VAR_4, &VAR_5);
		break;
	case VAR_74:
		svg_parse_anim_values(VAR_1, (SMIL_AnimateValues*)VAR_2->far_ptr, VAR_3, VAR_4, &VAR_5);
		break;

	case VAR_75:
		svg_parse_iri(VAR_1, (XMLRI*)VAR_2->far_ptr, VAR_3);
		break;
	case VAR_76:
		svg_parse_idref(VAR_1, (XMLRI*)VAR_2->far_ptr, VAR_3);
		break;
	case VAR_77:
		((SMIL_AttributeName *)VAR_2->far_ptr)->name = gf_strdup(VAR_3);
		break;
	case VAR_78:
		smil_parse_time_list(VAR_1, *(GF_List **)VAR_2->far_ptr, VAR_3);
		break;
	case VAR_79:
		smil_parse_min_max_dur_repeatdur((SMIL_Duration*)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_80:
		smil_parse_repeatcount((SMIL_RepeatCount*)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_81:
		svg_parse_path((SVG_PathData*)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_82:
		svg_parse_points(*(GF_List **)(VAR_2->far_ptr), VAR_3, &VAR_5);
		break;
	case VAR_83:
	case VAR_84:
	case VAR_85:
	case VAR_86:
		svg_parse_numbers(*(GF_List **)(VAR_2->far_ptr), VAR_3, 0, &VAR_5);
		break;
	case VAR_87:
		svg_parse_coordinates(*(GF_List **)(VAR_2->far_ptr), VAR_3, &VAR_5);
		break;
	case VAR_88:
		svg_parse_viewbox((SVG_ViewBox*)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_89:
		svg_parse_strokedasharray((SVG_StrokeDashArray*)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_90:
		svg_parse_fontfamily((SVG_FontFamily*)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_91:
		svg_parse_point_into_matrix((GF_Matrix2D*)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_92:
		VAR_5 = svg_parse_transform((SVG_Transform*)VAR_2->far_ptr, VAR_3);
		break;
	case VAR_93:
	{
		u32 VAR_8 = 0;
		SVG_Point *VAR_94 = (SVG_Point *)VAR_2->far_ptr;
		VAR_8+=svg_parse_number(&(VAR_3[VAR_8]), &(VAR_94->x), 0, &VAR_5);
		if (VAR_3[VAR_8] == 0) {
			VAR_94->y = 0;
		} else {
			/* COMMENT_7 */svg_parse_number(&(VAR_3[VAR_8]), &(VAR_94->y), 0, &VAR_5);
		}
	}
	break;
	case VAR_95:
	{
		u32 VAR_8 = 0;
		SVG_Point *VAR_94 = (SVG_Point *)VAR_2->far_ptr;
		VAR_8+=svg_parse_number(&(VAR_3[VAR_8]), &(VAR_94->x), 0, &VAR_5);
		if (VAR_3[VAR_8] == 0) {
			VAR_94->y = VAR_94->x;
		} else {
			/* COMMENT_7 */svg_parse_number(&(VAR_3[VAR_8]), &(VAR_94->y), 0, &VAR_5);
		}
	}
	break;
	case VAR_96:
	case VAR_97:
	{
		Fixed *VAR_94 = (Fixed *)VAR_2->far_ptr;
		svg_parse_number(VAR_3, VAR_94, 1, &VAR_5);
	}
	break;
	case VAR_98:
	{
		u32 VAR_8 = 0;
		SVG_Point_Angle *VAR_94 = (SVG_Point_Angle *)VAR_2->far_ptr;
		VAR_8+=svg_parse_number(&(VAR_3[VAR_8]), &(VAR_94->angle), 1, &VAR_5);
		if (VAR_3[VAR_8] == 0) {
			VAR_94->y = VAR_94->x = 0;
		} else {
			VAR_8+=svg_parse_number(&(VAR_3[VAR_8]), &(VAR_94->x), 0, &VAR_5);
			/* COMMENT_7 */svg_parse_number(&(VAR_3[VAR_8]), &(VAR_94->y), 0, &VAR_5);
		}
	}
	break;
	case VAR_99:
		svg_parse_preserveaspectratio((SVG_PreserveAspectRatio*)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_100:
		svg_parse_animatetransform_type((SVG_TransformType*)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;

	case VAR_101:
	case VAR_7:
	case VAR_102:
	case VAR_103:
		if (*(SVG_String *)VAR_2->far_ptr) gf_free(*(SVG_String *)VAR_2->far_ptr);

		*(SVG_String *)VAR_2->far_ptr = gf_strdup(VAR_3);
		break;

	case VAR_104:
		svg_parse_strings(*(GF_List **)VAR_2->far_ptr, VAR_3, 0);
		break;
	case VAR_105:
		svg_parse_strings(*(GF_List **)VAR_2->far_ptr, VAR_3, 1);
		break;

	case VAR_106:
	{
		XMLEV_Event *VAR_107 = (XMLEV_Event *)VAR_2->far_ptr;
		char *VAR_108 = strchr(VAR_3, '(');
		if (VAR_108) {
			VAR_108[0] = 0;
			VAR_107->type = gf_dom_event_type_by_name(VAR_3);
			VAR_108[0] = '(';
			if ((VAR_107->type == VAR_109) || (VAR_107->type == VAR_110)) {
				char VAR_111;
				sscanf(VAR_108, ""(%c)"", &VAR_111);
				VAR_107->parameter = VAR_111;
			} else { /* COMMENT_8 */
				char *VAR_112 = strchr(VAR_3, ')');
				VAR_112[0] = 0;
				VAR_107->parameter = gf_dom_get_key_type(VAR_108+1);
				VAR_112[0] = ')';
			}
		} else {
			VAR_107->parameter = 0;
			VAR_107->type = gf_dom_event_type_by_name(VAR_3);
		}
	}
	break;

	case VAR_113:
		svg_parse_focus(VAR_1, (SVG_Focus*)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_114:
		svg_parse_clippath(VAR_1, (SVG_ClipPath*)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;

	case VAR_115:
		VAR_5 = laser_parse_choice((LASeR_Choice*)VAR_2->far_ptr, VAR_3);
		break;
	case VAR_116:
		VAR_5 = laser_parse_size((LASeR_Size*)VAR_2->far_ptr, VAR_3, &VAR_5);
		break;
	case VAR_117:
		svg_parse_clock_value(VAR_3, (SVG_Clock*)VAR_2->far_ptr);
		break;
	case VAR_118:
		if (*(SVG_String *)VAR_2->far_ptr) gf_free(*(SVG_String *)VAR_2->far_ptr);
		*(SVG_String *)VAR_2->far_ptr = gf_strdup(VAR_3);
		break;
	default:
		GF_LOG(VAR_119, VAR_120, (""[SVG Parsing] Cannot parse attribute \""%s\""\n"", VAR_2->name ? VAR_2->name : """"));
		return VAR_6;
	}
	if (VAR_5) {
		GF_LOG(VAR_121, VAR_120, (""[SVG Parsing] Cannot parse attribute \""%s\"" value %s: %s\n"", VAR_2->name ? VAR_2->name : """", VAR_3, gf_error_to_string(VAR_5)));
		/* COMMENT_9 */
		if (!gf_sys_is_test_mode())
			VAR_5 = VAR_6;
	}
	return VAR_5;
}",,"--- func_before
+++ func_after
@@ -349,11 +349,14 @@
 		*(SVG_String *)info->far_ptr = gf_strdup(attribute_content);
 		break;
 	default:
-		GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (""[SVG Parsing] Cannot parse attribute %s\n"", info->name ? info->name : """"));
-		break;
+		GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (""[SVG Parsing] Cannot parse attribute \""%s\""\n"", info->name ? info->name : """"));
+		return GF_OK;
 	}
 	if (e) {
-		GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (""[SVG Parsing] Cannot parse attribute %s value %s: %s\n"", info->name ? info->name : """", attribute_content, gf_error_to_string(e)));
+		GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (""[SVG Parsing] Cannot parse attribute \""%s\"" value %s: %s\n"", info->name ? info->name : """", attribute_content, gf_error_to_string(e)));
+		//continue parsing if not test mode
+		if (!gf_sys_is_test_mode())
+			e = GF_OK;
 	}
 	return e;
 }","{'deleted_lines': ['\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (""[SVG Parsing] Cannot parse attribute %s\\n"", info->name ? info->name : """"));', '\t\tbreak;', '\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (""[SVG Parsing] Cannot parse attribute %s value %s: %s\\n"", info->name ? info->name : """", attribute_content, gf_error_to_string(e)));'], 'added_lines': ['\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (""[SVG Parsing] Cannot parse attribute \\""%s\\""\\n"", info->name ? info->name : """"));', '\t\treturn GF_OK;', '\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (""[SVG Parsing] Cannot parse attribute \\""%s\\"" value %s: %s\\n"", info->name ? info->name : """", attribute_content, gf_error_to_string(e)));', '\t\t//continue parsing if not test mode', '\t\tif (!gf_sys_is_test_mode())', '\t\t\te = GF_OK;']}",True,A vulnerability classified as problematic was found in GPAC. Affected by this vulnerability is the function svg_parse_preserveaspectratio of the file scenegraph/svg_attributes.c of the component SVG Parser. The manipulation leads to memory leak. The attack can be launched remotely. The name of the patch is 2191e66aa7df750e8ef01781b1930bea87b713bb. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-213463.,6.5,MEDIUM,1,test,2022-11-07T07:59:52Z,4
CVE-2022-3957,['CWE-404'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,gpac,fixed mem leak in sgv parse error,2191e66aa7df750e8ef01781b1930bea87b713bb,https://github.com/gpac/gpac/commit/2191e66aa7df750e8ef01781b1930bea87b713bb,src/scene_manager/loader_svg.c,load_svg_run,"GF_Err load_svg_run(GF_SceneLoader *load)
{
u32 in_time;
GF_Err e;
GF_SVG_Parser *parser = (GF_SVG_Parser *)load->loader_priv;
if (!parser) {
e = gf_sm_load_initialize_svg(load, NULL, GF_FALSE);
if (e) return e;
parser = (GF_SVG_Parser *)load->loader_priv;
}
in_time = gf_sys_clock();
e = gf_xml_sax_parse_file(parser->sax_parser, (const char *)load->fileName, svg_progress);
if (parser->last_error<0) e = parser->last_error;
if (e<0) return svg_report(parser, e, ""Unable to parse file %s: %s"", load->fileName, gf_xml_sax_get_error(parser->sax_parser) );
GF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (""[Parser] Scene parsed and Scene Graph built in %d ms\n"", gf_sys_clock() - in_time));
svg_flush_animations(parser);
gf_sm_svg_flush_state(parser);
return e;
}","GF_Err load_svg_run(GF_SceneLoader *VAR_0)
{
u32 VAR_1;
GF_Err VAR_2;
GF_SVG_Parser *VAR_3 = (GF_SVG_Parser *)VAR_0->loader_priv;
if (!VAR_3) {
VAR_2 = gf_sm_load_initialize_svg(VAR_0, NULL, VAR_4);
if (VAR_2) return VAR_2;
VAR_3 = (GF_SVG_Parser *)VAR_0->loader_priv;
}
VAR_1 = gf_sys_clock();
VAR_2 = gf_xml_sax_parse_file(VAR_3->sax_parser, (const char *)VAR_0->fileName, VAR_5);
if (VAR_3->last_error<0) VAR_2 = VAR_3->last_error;
if (VAR_2<0) return svg_report(VAR_3, VAR_2, ""Unable to parse file %s: %s"", VAR_0->fileName, gf_xml_sax_get_error(VAR_3->sax_parser) );
GF_LOG(VAR_6, VAR_7, (""[Parser] Scene parsed and Scene Graph built in %d ms\n"", gf_sys_clock() - VAR_1));
svg_flush_animations(VAR_3);
gf_sm_svg_flush_state(VAR_3);
return VAR_2;
}",gpac/2191e66aa7df750e8ef01781b1930bea87b713bb/loader_svg.c/vul/before/0.json,"GF_Err load_svg_run(GF_SceneLoader *load)
{
	u32 in_time;
	GF_Err e;
	GF_SVG_Parser *parser = (GF_SVG_Parser *)load->loader_priv;

	if (!parser) {
		e = gf_sm_load_initialize_svg(load, NULL, GF_FALSE);
		if (e) return e;
		parser = (GF_SVG_Parser *)load->loader_priv;
	}

	in_time = gf_sys_clock();
	e = gf_xml_sax_parse_file(parser->sax_parser, (const char *)load->fileName, svg_progress);
	svg_flush_animations(parser);
	gf_sm_svg_flush_state(parser);
	if (parser->last_error<0) e = parser->last_error;

	if (e<0) return svg_report(parser, e, ""Unable to parse file %s: %s"", load->fileName, gf_xml_sax_get_error(parser->sax_parser) );
	GF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (""[Parser] Scene parsed and Scene Graph built in %d ms\n"", gf_sys_clock() - in_time));

	return e;

}","GF_Err load_svg_run(GF_SceneLoader *VAR_0)
{
	u32 VAR_1;
	GF_Err VAR_2;
	GF_SVG_Parser *VAR_3 = (GF_SVG_Parser *)VAR_0->loader_priv;

	if (!VAR_3) {
		VAR_2 = gf_sm_load_initialize_svg(VAR_0, NULL, VAR_4);
		if (VAR_2) return VAR_2;
		VAR_3 = (GF_SVG_Parser *)VAR_0->loader_priv;
	}

	VAR_1 = gf_sys_clock();
	VAR_2 = gf_xml_sax_parse_file(VAR_3->sax_parser, (const char *)VAR_0->fileName, VAR_5);
	svg_flush_animations(VAR_3);
	gf_sm_svg_flush_state(VAR_3);
	if (VAR_3->last_error<0) VAR_2 = VAR_3->last_error;

	if (VAR_2<0) return svg_report(VAR_3, VAR_2, ""Unable to parse file %s: %s"", VAR_0->fileName, gf_xml_sax_get_error(VAR_3->sax_parser) );
	GF_LOG(VAR_6, VAR_7, (""[Parser] Scene parsed and Scene Graph built in %d ms\n"", gf_sys_clock() - VAR_1));

	return VAR_2;

}",gpac/2191e66aa7df750e8ef01781b1930bea87b713bb/loader_svg.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,13 +12,13 @@
 
 	in_time = gf_sys_clock();
 	e = gf_xml_sax_parse_file(parser->sax_parser, (const char *)load->fileName, svg_progress);
+	svg_flush_animations(parser);
+	gf_sm_svg_flush_state(parser);
 	if (parser->last_error<0) e = parser->last_error;
-	
+
 	if (e<0) return svg_report(parser, e, ""Unable to parse file %s: %s"", load->fileName, gf_xml_sax_get_error(parser->sax_parser) );
 	GF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (""[Parser] Scene parsed and Scene Graph built in %d ms\n"", gf_sys_clock() - in_time));
 
-	svg_flush_animations(parser);
-	gf_sm_svg_flush_state(parser);
 	return e;
 
 }","{'deleted_lines': ['\t', '\tsvg_flush_animations(parser);', '\tgf_sm_svg_flush_state(parser);'], 'added_lines': ['\tsvg_flush_animations(parser);', '\tgf_sm_svg_flush_state(parser);', '']}",True,A vulnerability classified as problematic was found in GPAC. Affected by this vulnerability is the function svg_parse_preserveaspectratio of the file scenegraph/svg_attributes.c of the component SVG Parser. The manipulation leads to memory leak. The attack can be launched remotely. The name of the patch is 2191e66aa7df750e8ef01781b1930bea87b713bb. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-213463.,6.5,MEDIUM,1,test,2022-11-07T07:59:52Z,4
CVE-2022-3957,['CWE-404'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,gpac,fixed mem leak in sgv parse error,2191e66aa7df750e8ef01781b1930bea87b713bb,https://github.com/gpac/gpac/commit/2191e66aa7df750e8ef01781b1930bea87b713bb,src/scene_manager/loader_svg.c,svg_parse_animation,"static Bool svg_parse_animation(GF_SVG_Parser *parser, GF_SceneGraph *sg, SVG_DeferredAnimation *anim, const char *nodeID, u32 force_type)
{
GF_FieldInfo info;
u32 tag;
u8 anim_value_type = 0;
if (!anim->animation_elt)
return GF_FALSE;
if (anim->resolve_stage==0) {
if (!anim->target && anim->target_id)
anim->target = (SVG_Element *) gf_sg_find_node_by_name(sg, anim->target_id + 1);
if (anim->target) {
XMLRI *iri;
gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_XLINK_ATT_href, GF_TRUE, GF_FALSE, &info);
iri = (XMLRI *)info.far_ptr;
iri->type = XMLRI_ELEMENTID;
iri->target = anim->target;
gf_node_register_iri(sg, iri);
}
tag = gf_node_get_tag((GF_Node *)anim->animation_elt);
if (anim->type && (tag== TAG_SVG_animateTransform) ) {
gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_transform_type, GF_TRUE, GF_FALSE, &info);
gf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->type, 0);
switch(*(SVG_TransformType *) info.far_ptr) {
case SVG_TRANSFORM_TRANSLATE:
anim_value_type = SVG_Transform_Translate_datatype;
break;
case SVG_TRANSFORM_SCALE:
anim_value_type = SVG_Transform_Scale_datatype;
break;
case SVG_TRANSFORM_ROTATE:
anim_value_type = SVG_Transform_Rotate_datatype;
break;
case SVG_TRANSFORM_SKEWX:
anim_value_type = SVG_Transform_SkewX_datatype;
break;
case SVG_TRANSFORM_SKEWY:
anim_value_type = SVG_Transform_SkewY_datatype;
break;
case SVG_TRANSFORM_MATRIX:
anim_value_type = SVG_Transform_datatype;
break;
default:
svg_report(parser, GF_OK, ""unknown datatype for animate transform"");
return GF_FALSE;
}
}
else if (gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_attributeName, GF_FALSE, GF_FALSE, &info) == GF_OK) {
SMIL_AttributeName *attname = (SMIL_AttributeName *)info.far_ptr;
if (!attname->type) {
char *sep;
char *name = attname->name;
sep = strchr(name, ':');
if (sep) {
sep[0] = 0;
attname->type = gf_sg_get_namespace_code(anim->animation_elt->sgprivate->scenegraph, name);
sep[0] = ':';
name = gf_strdup(sep+1);
gf_free(attname->name);
attname->name = name;
} else {
attname->type = parser->current_ns;
}
}
if (!anim->target) return GF_FALSE;
gf_node_get_attribute_by_name((GF_Node *)anim->target, attname->name, attname->type, GF_TRUE, GF_TRUE, &info);
attname->tag = info.fieldIndex;
attname->type = 0;
anim_value_type = info.fieldType;
} else {
if (tag == TAG_SVG_animateMotion) {
anim_value_type = SVG_Motion_datatype;
} else if (tag == TAG_SVG_discard) {
anim->resolve_stage = 1;
return svg_parse_animation(parser, sg, anim, nodeID, 0);
} else {
svg_report(parser, GF_OK, ""Missing attributeName attribute on %s"", gf_node_get_name((GF_Node *)anim->animation_elt));
return GF_FALSE;
}
}
if (!anim->target) return GF_FALSE;
if (anim->to) {
gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_to, GF_TRUE, GF_FALSE, &info);
gf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->to, anim_value_type);
if (anim_value_type==XMLRI_datatype) {
svg_post_process_href(parser, (GF_Node *) anim->target, (XMLRI*)((SMIL_AnimateValue *)info.far_ptr)->value);
}
}
if (anim->from) {
gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_from, GF_TRUE, GF_FALSE, &info);
gf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->from, anim_value_type);
if (anim_value_type==XMLRI_datatype)
svg_post_process_href(parser,  (GF_Node *) anim->target, (XMLRI*)((SMIL_AnimateValue *)info.far_ptr)->value);
}
if (anim->by) {
gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_by, GF_TRUE, GF_FALSE, &info);
gf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->by, anim_value_type);
if (anim_value_type==XMLRI_datatype)
svg_post_process_href(parser,  (GF_Node *) anim->target, (XMLRI*)((SMIL_AnimateValue *)info.far_ptr)->value);
}
if (anim->values) {
gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_values, GF_TRUE, GF_FALSE, &info);
gf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->values, anim_value_type);
if (anim_value_type==XMLRI_datatype) {
u32 i, count;
SMIL_AnimateValues *anim_values;
anim_values = (SMIL_AnimateValues *)info.far_ptr;
count = gf_list_count(anim_values->values);
for (i=0; i<count; i++) {
XMLRI *iri = (XMLRI *)gf_list_get(anim_values->values, i);
svg_post_process_href(parser,  (GF_Node *) anim->target, iri);
}
}
}
anim->resolve_stage = 1;
}
if (anim->resolve_stage == 1) {
gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_begin, GF_TRUE, GF_FALSE, &info);
if (gf_svg_resolve_smil_times((GF_Node *)anim->animation_elt, anim->target, *(GF_List **)info.far_ptr, GF_FALSE, nodeID)) {
anim->resolve_stage = 2;
} else if (force_type!=2) {
return GF_FALSE;
}
}
gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_end, GF_TRUE, GF_FALSE, &info);
if (!gf_svg_resolve_smil_times((GF_Node *)anim->animation_elt, anim->target, *(GF_List **)info.far_ptr, GF_TRUE, nodeID)) {
if (force_type!=2) return GF_FALSE;
}
if (force_type || gf_node_get_tag((GF_Node *)anim->animation_elt) != TAG_SVG_animateMotion) {
gf_node_init((GF_Node *)anim->animation_elt);
return GF_TRUE;
} else {
return GF_FALSE;
}
}","static Bool svg_parse_animation(GF_SVG_Parser *VAR_0, GF_SceneGraph *VAR_1, SVG_DeferredAnimation *VAR_2, const char *VAR_3, u32 VAR_4)
{
GF_FieldInfo VAR_5;
u32 VAR_6;
u8 VAR_7 = 0;
if (!VAR_2->animation_elt)
return VAR_8;
if (VAR_2->resolve_stage==0) {
if (!VAR_2->target && VAR_2->target_id)
VAR_2->target = (SVG_Element *) gf_sg_find_node_by_name(VAR_1, VAR_2->target_id + 1);
if (VAR_2->target) {
XMLRI *VAR_9;
gf_node_get_attribute_by_tag((GF_Node *)VAR_2->animation_elt, VAR_10, VAR_11, VAR_8, &VAR_5);
VAR_9 = (XMLRI *)VAR_5.far_ptr;
VAR_9->type = VAR_12;
VAR_9->target = VAR_2->target;
gf_node_register_iri(VAR_1, VAR_9);
}
VAR_6 = gf_node_get_tag((GF_Node *)VAR_2->animation_elt);
if (VAR_2->type && (VAR_6== VAR_13) ) {
gf_node_get_attribute_by_tag((GF_Node *)VAR_2->animation_elt, VAR_14, VAR_11, VAR_8, &VAR_5);
gf_svg_parse_attribute((GF_Node *)VAR_2->animation_elt, &VAR_5, VAR_2->type, 0);
switch(*(SVG_TransformType *) VAR_5.far_ptr) {
case VAR_15:
VAR_7 = VAR_16;
break;
case VAR_17:
VAR_7 = VAR_18;
break;
case VAR_19:
VAR_7 = VAR_20;
break;
case VAR_21:
VAR_7 = VAR_22;
break;
case VAR_23:
VAR_7 = VAR_24;
break;
case VAR_25:
VAR_7 = VAR_26;
break;
default:
svg_report(VAR_0, VAR_27, ""unknown datatype for animate transform"");
return VAR_8;
}
}
else if (gf_node_get_attribute_by_tag((GF_Node *)VAR_2->animation_elt, VAR_28, VAR_8, VAR_8, &VAR_5) == VAR_27) {
SMIL_AttributeName *VAR_29 = (SMIL_AttributeName *)VAR_5.far_ptr;
if (!VAR_29->type) {
char *VAR_30;
char *VAR_31 = VAR_29->name;
VAR_30 = strchr(VAR_31, ':');
if (VAR_30) {
VAR_30[0] = 0;
VAR_29->type = gf_sg_get_namespace_code(VAR_2->animation_elt->sgprivate->scenegraph, VAR_31);
VAR_30[0] = ':';
VAR_31 = gf_strdup(VAR_30+1);
gf_free(VAR_29->name);
VAR_29->name = VAR_31;
} else {
VAR_29->type = VAR_0->current_ns;
}
}
if (!VAR_2->target) return VAR_8;
gf_node_get_attribute_by_name((GF_Node *)VAR_2->target, VAR_29->name, VAR_29->type, VAR_11, VAR_11, &VAR_5);
VAR_29->tag = VAR_5.fieldIndex;
VAR_29->type = 0;
VAR_7 = VAR_5.fieldType;
} else {
if (VAR_6 == VAR_32) {
VAR_7 = VAR_33;
} else if (VAR_6 == VAR_34) {
VAR_2->resolve_stage = 1;
return svg_parse_animation(VAR_0, VAR_1, VAR_2, VAR_3, 0);
} else {
svg_report(VAR_0, VAR_27, ""Missing attributeName attribute on %s"", gf_node_get_name((GF_Node *)VAR_2->animation_elt));
return VAR_8;
}
}
if (!VAR_2->target) return VAR_8;
if (VAR_2->to) {
gf_node_get_attribute_by_tag((GF_Node *)VAR_2->animation_elt, VAR_35, VAR_11, VAR_8, &VAR_5);
gf_svg_parse_attribute((GF_Node *)VAR_2->animation_elt, &VAR_5, VAR_2->to, VAR_7);
if (VAR_7==VAR_36) {
svg_post_process_href(VAR_0, (GF_Node *) VAR_2->target, (XMLRI*)((SMIL_AnimateValue *)VAR_5.far_ptr)->value);
}
}
if (VAR_2->from) {
gf_node_get_attribute_by_tag((GF_Node *)VAR_2->animation_elt, VAR_37, VAR_11, VAR_8, &VAR_5);
gf_svg_parse_attribute((GF_Node *)VAR_2->animation_elt, &VAR_5, VAR_2->from, VAR_7);
if (VAR_7==VAR_36)
svg_post_process_href(VAR_0,  (GF_Node *) VAR_2->target, (XMLRI*)((SMIL_AnimateValue *)VAR_5.far_ptr)->value);
}
if (VAR_2->by) {
gf_node_get_attribute_by_tag((GF_Node *)VAR_2->animation_elt, VAR_38, VAR_11, VAR_8, &VAR_5);
gf_svg_parse_attribute((GF_Node *)VAR_2->animation_elt, &VAR_5, VAR_2->by, VAR_7);
if (VAR_7==VAR_36)
svg_post_process_href(VAR_0,  (GF_Node *) VAR_2->target, (XMLRI*)((SMIL_AnimateValue *)VAR_5.far_ptr)->value);
}
if (VAR_2->values) {
gf_node_get_attribute_by_tag((GF_Node *)VAR_2->animation_elt, VAR_39, VAR_11, VAR_8, &VAR_5);
gf_svg_parse_attribute((GF_Node *)VAR_2->animation_elt, &VAR_5, VAR_2->values, VAR_7);
if (VAR_7==VAR_36) {
u32 VAR_40, VAR_41;
SMIL_AnimateValues *VAR_42;
VAR_42 = (SMIL_AnimateValues *)VAR_5.far_ptr;
VAR_41 = gf_list_count(VAR_42->values);
for (VAR_40=0; VAR_40<VAR_41; VAR_40++) {
XMLRI *VAR_9 = (XMLRI *)gf_list_get(VAR_42->values, VAR_40);
svg_post_process_href(VAR_0,  (GF_Node *) VAR_2->target, VAR_9);
}
}
}
VAR_2->resolve_stage = 1;
}
if (VAR_2->resolve_stage == 1) {
gf_node_get_attribute_by_tag((GF_Node *)VAR_2->animation_elt, VAR_43, VAR_11, VAR_8, &VAR_5);
if (gf_svg_resolve_smil_times((GF_Node *)VAR_2->animation_elt, VAR_2->target, *(GF_List **)VAR_5.far_ptr, VAR_8, VAR_3)) {
VAR_2->resolve_stage = 2;
} else if (VAR_4!=2) {
return VAR_8;
}
}
gf_node_get_attribute_by_tag((GF_Node *)VAR_2->animation_elt, VAR_44, VAR_11, VAR_8, &VAR_5);
if (!gf_svg_resolve_smil_times((GF_Node *)VAR_2->animation_elt, VAR_2->target, *(GF_List **)VAR_5.far_ptr, VAR_11, VAR_3)) {
if (VAR_4!=2) return VAR_8;
}
if (VAR_4 || gf_node_get_tag((GF_Node *)VAR_2->animation_elt) != VAR_32) {
gf_node_init((GF_Node *)VAR_2->animation_elt);
return VAR_11;
} else {
return VAR_8;
}
}",gpac/2191e66aa7df750e8ef01781b1930bea87b713bb/loader_svg.c/vul/before/1.json,"static Bool svg_parse_animation(GF_SVG_Parser *parser, GF_SceneGraph *sg, SVG_DeferredAnimation *anim, const char *nodeID, u32 force_type)
{
	GF_FieldInfo info;
	u32 tag;
	u8 anim_value_type = 0;

	if (!anim->animation_elt)
		return GF_FALSE;
	if (anim->resolve_stage==0) {
		/* Stage 0: parsing the animation attribute values
					for that we need to resolve the target first */

		/* if we don't have a target, try to get it */
		if (!anim->target && anim->target_id)
			anim->target = (SVG_Element *) gf_sg_find_node_by_name(sg, anim->target_id + 1);

		/* if now we have a target, create the xlink:href attribute on the animation element and set it to the found target */
		if (anim->target) {
			XMLRI *iri;
			gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_XLINK_ATT_href, GF_TRUE, GF_FALSE, &info);
			iri = (XMLRI *)info.far_ptr;
			iri->type = XMLRI_ELEMENTID;
			iri->target = anim->target;
			gf_node_register_iri(sg, iri);
		}

		tag = gf_node_get_tag((GF_Node *)anim->animation_elt);
		/* get the attribute name attribute if specified */
		if (anim->type && (tag== TAG_SVG_animateTransform) ) {
			gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_transform_type, GF_TRUE, GF_FALSE, &info);
			gf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->type, 0);
			switch(*(SVG_TransformType *) info.far_ptr) {
			case SVG_TRANSFORM_TRANSLATE:
				anim_value_type = SVG_Transform_Translate_datatype;
				break;
			case SVG_TRANSFORM_SCALE:
				anim_value_type = SVG_Transform_Scale_datatype;
				break;
			case SVG_TRANSFORM_ROTATE:
				anim_value_type = SVG_Transform_Rotate_datatype;
				break;
			case SVG_TRANSFORM_SKEWX:
				anim_value_type = SVG_Transform_SkewX_datatype;
				break;
			case SVG_TRANSFORM_SKEWY:
				anim_value_type = SVG_Transform_SkewY_datatype;
				break;
			case SVG_TRANSFORM_MATRIX:
				anim_value_type = SVG_Transform_datatype;
				break;
			default:
				svg_report(parser, GF_OK, ""unknown datatype for animate transform"");
				return GF_FALSE;
			}
		}
		else if (gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_attributeName, GF_FALSE, GF_FALSE, &info) == GF_OK) {
			SMIL_AttributeName *attname = (SMIL_AttributeName *)info.far_ptr;

			/*parse the attribute name even if the target is not found, because a namespace could be specified and
			only valid for the current node*/
			if (!attname->type) {
				char *sep;
				char *name = attname->name;
				sep = strchr(name, ':');
				if (sep) {
					sep[0] = 0;
					attname->type = gf_sg_get_namespace_code(anim->animation_elt->sgprivate->scenegraph, name);
					sep[0] = ':';
					name = gf_strdup(sep+1);
					gf_free(attname->name);
					attname->name = name;
				} else {
					attname->type = parser->current_ns;
				}
			}

			/* the target is still not known stay in stage 0 */
			if (!anim->target) return GF_FALSE;

			gf_node_get_attribute_by_name((GF_Node *)anim->target, attname->name, attname->type, GF_TRUE, GF_TRUE, &info);
			/*set the tag value to avoid parsing the name in the anim node_init phase*/
			attname->tag = info.fieldIndex;
			attname->type = 0;
			anim_value_type = info.fieldType;
		} else {
			if (tag == TAG_SVG_animateMotion) {
				anim_value_type = SVG_Motion_datatype;
			} else if (tag == TAG_SVG_discard) {
				/* there is no value to parse in discard, we can jump to the next stage */
				anim->resolve_stage = 1;
				return svg_parse_animation(parser, sg, anim, nodeID, 0);
			} else {
				svg_report(parser, GF_OK, ""Missing attributeName attribute on %s"", gf_node_get_name((GF_Node *)anim->animation_elt));
				return GF_FALSE;
			}
		}

		/* the target is still not known stay in stage 0 */
		if (!anim->target) return GF_FALSE;

		if (anim->to) {
			/* now that we have a target, if there is a to value to parse, create the attribute and parse it */
			gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_to, GF_TRUE, GF_FALSE, &info);
			if (!info.name) info.name = ""to"";
			gf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->to, anim_value_type);
			if (anim_value_type==XMLRI_datatype) {
				svg_post_process_href(parser, (GF_Node *) anim->target, (XMLRI*)((SMIL_AnimateValue *)info.far_ptr)->value);
			}
		}
		if (anim->from) {
			/* now that we have a target, if there is a from value to parse, create the attribute and parse it */
			gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_from, GF_TRUE, GF_FALSE, &info);
			if (!info.name) info.name = ""from"";
			gf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->from, anim_value_type);
			if (anim_value_type==XMLRI_datatype)
				svg_post_process_href(parser,  (GF_Node *) anim->target, (XMLRI*)((SMIL_AnimateValue *)info.far_ptr)->value);
		}
		if (anim->by) {
			/* now that we have a target, if there is a by value to parse, create the attribute and parse it */
			gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_by, GF_TRUE, GF_FALSE, &info);
			if (!info.name) info.name = ""by"";
			gf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->by, anim_value_type);
			if (anim_value_type==XMLRI_datatype)
				svg_post_process_href(parser,  (GF_Node *) anim->target, (XMLRI*)((SMIL_AnimateValue *)info.far_ptr)->value);
		}
		if (anim->values) {
			/* now that we have a target, if there is a 'values' value to parse, create the attribute and parse it */
			gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_values, GF_TRUE, GF_FALSE, &info);
			if (!info.name) info.name = ""values"";
			gf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->values, anim_value_type);
			if (anim_value_type==XMLRI_datatype) {
				u32 i, count;
				SMIL_AnimateValues *anim_values;
				anim_values = (SMIL_AnimateValues *)info.far_ptr;
				count = gf_list_count(anim_values->values);
				for (i=0; i<count; i++) {
					XMLRI *iri = (XMLRI *)gf_list_get(anim_values->values, i);
					svg_post_process_href(parser,  (GF_Node *) anim->target, iri);
				}
			}
		}
		anim->resolve_stage = 1;
	}

	if (anim->resolve_stage == 1) {
		/* Stage 1: parsing the begin values
					we go into the next stage only if at least one begin value is resolved */
		gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_begin, GF_TRUE, GF_FALSE, &info);
		if (gf_svg_resolve_smil_times((GF_Node *)anim->animation_elt, anim->target, *(GF_List **)info.far_ptr, GF_FALSE, nodeID)) {
			anim->resolve_stage = 2;
		} else if (force_type!=2) {
			return GF_FALSE;
		}
	}

	gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_end, GF_TRUE, GF_FALSE, &info);
	if (!gf_svg_resolve_smil_times((GF_Node *)anim->animation_elt, anim->target, *(GF_List **)info.far_ptr, GF_TRUE, nodeID)) {
		if (force_type!=2) return GF_FALSE;
	}

	/*animateMotion needs its children to be parsed before it can be initialized !! */
	if (force_type || gf_node_get_tag((GF_Node *)anim->animation_elt) != TAG_SVG_animateMotion) {
		gf_node_init((GF_Node *)anim->animation_elt);
		return GF_TRUE;
	} else {
		return GF_FALSE;
	}

}","static Bool svg_parse_animation(GF_SVG_Parser *VAR_0, GF_SceneGraph *VAR_1, SVG_DeferredAnimation *VAR_2, const char *VAR_3, u32 VAR_4)
{
	GF_FieldInfo VAR_5;
	u32 VAR_6;
	u8 VAR_7 = 0;

	if (!VAR_2->animation_elt)
		return VAR_8;
	if (VAR_2->resolve_stage==0) {
		/* COMMENT_0 */
                                                    

		/* COMMENT_2 */
		if (!VAR_2->target && VAR_2->target_id)
			VAR_2->target = (SVG_Element *) gf_sg_find_node_by_name(VAR_1, VAR_2->target_id + 1);

		/* COMMENT_3 */
		if (VAR_2->target) {
			XMLRI *VAR_9;
			gf_node_get_attribute_by_tag((GF_Node *)VAR_2->animation_elt, VAR_10, VAR_11, VAR_8, &VAR_5);
			VAR_9 = (XMLRI *)VAR_5.far_ptr;
			VAR_9->type = VAR_12;
			VAR_9->target = VAR_2->target;
			gf_node_register_iri(VAR_1, VAR_9);
		}

		VAR_6 = gf_node_get_tag((GF_Node *)VAR_2->animation_elt);
		/* COMMENT_4 */
		if (VAR_2->type && (VAR_6== VAR_13) ) {
			gf_node_get_attribute_by_tag((GF_Node *)VAR_2->animation_elt, VAR_14, VAR_11, VAR_8, &VAR_5);
			gf_svg_parse_attribute((GF_Node *)VAR_2->animation_elt, &VAR_5, VAR_2->type, 0);
			switch(*(SVG_TransformType *) VAR_5.far_ptr) {
			case VAR_15:
				VAR_7 = VAR_16;
				break;
			case VAR_17:
				VAR_7 = VAR_18;
				break;
			case VAR_19:
				VAR_7 = VAR_20;
				break;
			case VAR_21:
				VAR_7 = VAR_22;
				break;
			case VAR_23:
				VAR_7 = VAR_24;
				break;
			case VAR_25:
				VAR_7 = VAR_26;
				break;
			default:
				svg_report(VAR_0, VAR_27, ""unknown datatype for animate transform"");
				return VAR_8;
			}
		}
		else if (gf_node_get_attribute_by_tag((GF_Node *)VAR_2->animation_elt, VAR_28, VAR_8, VAR_8, &VAR_5) == VAR_27) {
			SMIL_AttributeName *VAR_29 = (SMIL_AttributeName *)VAR_5.far_ptr;

			/* COMMENT_5 */
                                    
			if (!VAR_29->type) {
				char *VAR_30;
				char *VAR_31 = VAR_29->name;
				VAR_30 = strchr(VAR_31, ':');
				if (VAR_30) {
					VAR_30[0] = 0;
					VAR_29->type = gf_sg_get_namespace_code(VAR_2->animation_elt->sgprivate->scenegraph, VAR_31);
					VAR_30[0] = ':';
					VAR_31 = gf_strdup(VAR_30+1);
					gf_free(VAR_29->name);
					VAR_29->name = VAR_31;
				} else {
					VAR_29->type = VAR_0->current_ns;
				}
			}

			/* COMMENT_7 */
			if (!VAR_2->target) return VAR_8;

			gf_node_get_attribute_by_name((GF_Node *)VAR_2->target, VAR_29->name, VAR_29->type, VAR_11, VAR_11, &VAR_5);
			/* COMMENT_8 */
			VAR_29->tag = VAR_5.fieldIndex;
			VAR_29->type = 0;
			VAR_7 = VAR_5.fieldType;
		} else {
			if (VAR_6 == VAR_32) {
				VAR_7 = VAR_33;
			} else if (VAR_6 == VAR_34) {
				/* COMMENT_9 */
				VAR_2->resolve_stage = 1;
				return svg_parse_animation(VAR_0, VAR_1, VAR_2, VAR_3, 0);
			} else {
				svg_report(VAR_0, VAR_27, ""Missing attributeName attribute on %s"", gf_node_get_name((GF_Node *)VAR_2->animation_elt));
				return VAR_8;
			}
		}

		/* COMMENT_7 */
		if (!VAR_2->target) return VAR_8;

		if (VAR_2->to) {
			/* COMMENT_10 */
			gf_node_get_attribute_by_tag((GF_Node *)VAR_2->animation_elt, VAR_35, VAR_11, VAR_8, &VAR_5);
			if (!VAR_5.name) VAR_5.name = ""to"";
			gf_svg_parse_attribute((GF_Node *)VAR_2->animation_elt, &VAR_5, VAR_2->to, VAR_7);
			if (VAR_7==VAR_36) {
				svg_post_process_href(VAR_0, (GF_Node *) VAR_2->target, (XMLRI*)((SMIL_AnimateValue *)VAR_5.far_ptr)->value);
			}
		}
		if (VAR_2->from) {
			/* COMMENT_11 */
			gf_node_get_attribute_by_tag((GF_Node *)VAR_2->animation_elt, VAR_37, VAR_11, VAR_8, &VAR_5);
			if (!VAR_5.name) VAR_5.name = ""from"";
			gf_svg_parse_attribute((GF_Node *)VAR_2->animation_elt, &VAR_5, VAR_2->from, VAR_7);
			if (VAR_7==VAR_36)
				svg_post_process_href(VAR_0,  (GF_Node *) VAR_2->target, (XMLRI*)((SMIL_AnimateValue *)VAR_5.far_ptr)->value);
		}
		if (VAR_2->by) {
			/* COMMENT_12 */
			gf_node_get_attribute_by_tag((GF_Node *)VAR_2->animation_elt, VAR_38, VAR_11, VAR_8, &VAR_5);
			if (!VAR_5.name) VAR_5.name = ""by"";
			gf_svg_parse_attribute((GF_Node *)VAR_2->animation_elt, &VAR_5, VAR_2->by, VAR_7);
			if (VAR_7==VAR_36)
				svg_post_process_href(VAR_0,  (GF_Node *) VAR_2->target, (XMLRI*)((SMIL_AnimateValue *)VAR_5.far_ptr)->value);
		}
		if (VAR_2->values) {
			/* COMMENT_13 */
			gf_node_get_attribute_by_tag((GF_Node *)VAR_2->animation_elt, VAR_39, VAR_11, VAR_8, &VAR_5);
			if (!VAR_5.name) VAR_5.name = ""values"";
			gf_svg_parse_attribute((GF_Node *)VAR_2->animation_elt, &VAR_5, VAR_2->values, VAR_7);
			if (VAR_7==VAR_36) {
				u32 VAR_40, VAR_41;
				SMIL_AnimateValues *VAR_42;
				VAR_42 = (SMIL_AnimateValues *)VAR_5.far_ptr;
				VAR_41 = gf_list_count(VAR_42->values);
				for (VAR_40=0; VAR_40<VAR_41; VAR_40++) {
					XMLRI *VAR_9 = (XMLRI *)gf_list_get(VAR_42->values, VAR_40);
					svg_post_process_href(VAR_0,  (GF_Node *) VAR_2->target, VAR_9);
				}
			}
		}
		VAR_2->resolve_stage = 1;
	}

	if (VAR_2->resolve_stage == 1) {
		/* COMMENT_14 */
                                                                              
		gf_node_get_attribute_by_tag((GF_Node *)VAR_2->animation_elt, VAR_43, VAR_11, VAR_8, &VAR_5);
		if (gf_svg_resolve_smil_times((GF_Node *)VAR_2->animation_elt, VAR_2->target, *(GF_List **)VAR_5.far_ptr, VAR_8, VAR_3)) {
			VAR_2->resolve_stage = 2;
		} else if (VAR_4!=2) {
			return VAR_8;
		}
	}

	gf_node_get_attribute_by_tag((GF_Node *)VAR_2->animation_elt, VAR_44, VAR_11, VAR_8, &VAR_5);
	if (!gf_svg_resolve_smil_times((GF_Node *)VAR_2->animation_elt, VAR_2->target, *(GF_List **)VAR_5.far_ptr, VAR_11, VAR_3)) {
		if (VAR_4!=2) return VAR_8;
	}

	/* COMMENT_16 */
	if (VAR_4 || gf_node_get_tag((GF_Node *)VAR_2->animation_elt) != VAR_32) {
		gf_node_init((GF_Node *)VAR_2->animation_elt);
		return VAR_11;
	} else {
		return VAR_8;
	}

}",gpac/2191e66aa7df750e8ef01781b1930bea87b713bb/loader_svg.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -101,6 +101,7 @@
 		if (anim->to) {
 			/* now that we have a target, if there is a to value to parse, create the attribute and parse it */
 			gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_to, GF_TRUE, GF_FALSE, &info);
+			if (!info.name) info.name = ""to"";
 			gf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->to, anim_value_type);
 			if (anim_value_type==XMLRI_datatype) {
 				svg_post_process_href(parser, (GF_Node *) anim->target, (XMLRI*)((SMIL_AnimateValue *)info.far_ptr)->value);
@@ -109,6 +110,7 @@
 		if (anim->from) {
 			/* now that we have a target, if there is a from value to parse, create the attribute and parse it */
 			gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_from, GF_TRUE, GF_FALSE, &info);
+			if (!info.name) info.name = ""from"";
 			gf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->from, anim_value_type);
 			if (anim_value_type==XMLRI_datatype)
 				svg_post_process_href(parser,  (GF_Node *) anim->target, (XMLRI*)((SMIL_AnimateValue *)info.far_ptr)->value);
@@ -116,6 +118,7 @@
 		if (anim->by) {
 			/* now that we have a target, if there is a by value to parse, create the attribute and parse it */
 			gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_by, GF_TRUE, GF_FALSE, &info);
+			if (!info.name) info.name = ""by"";
 			gf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->by, anim_value_type);
 			if (anim_value_type==XMLRI_datatype)
 				svg_post_process_href(parser,  (GF_Node *) anim->target, (XMLRI*)((SMIL_AnimateValue *)info.far_ptr)->value);
@@ -123,6 +126,7 @@
 		if (anim->values) {
 			/* now that we have a target, if there is a 'values' value to parse, create the attribute and parse it */
 			gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_values, GF_TRUE, GF_FALSE, &info);
+			if (!info.name) info.name = ""values"";
 			gf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->values, anim_value_type);
 			if (anim_value_type==XMLRI_datatype) {
 				u32 i, count;","{'deleted_lines': [], 'added_lines': ['\t\t\tif (!info.name) info.name = ""to"";', '\t\t\tif (!info.name) info.name = ""from"";', '\t\t\tif (!info.name) info.name = ""by"";', '\t\t\tif (!info.name) info.name = ""values"";']}",True,A vulnerability classified as problematic was found in GPAC. Affected by this vulnerability is the function svg_parse_preserveaspectratio of the file scenegraph/svg_attributes.c of the component SVG Parser. The manipulation leads to memory leak. The attack can be launched remotely. The name of the patch is 2191e66aa7df750e8ef01781b1930bea87b713bb. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-213463.,6.5,MEDIUM,1,test,2022-11-07T07:59:52Z,4
CVE-2022-3424,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"misc: sgi-gru: fix use-after-free error in gru_set_context_option, gru_fault and gru_handle_user_call_os

In some bad situation, the gts may be freed gru_check_chiplet_assignment.
The call chain can be gru_unload_context->gru_free_gru_context->gts_drop
and kfree finally. However, the caller didn't know if the gts is freed
or not and use it afterwards. This will trigger a Use after Free bug.

Fix it by introducing a return value to see if it's in error path or not.
Free the gts in caller if gru_check_chiplet_assignment check failed.

Fixes: 55484c45dbec (""gru: allow users to specify gru chiplet 2"")
Signed-off-by: Zheng Wang <zyytlz.wz@163.com>
Acked-by: Dimitri Sivanich <sivanich@hpe.com>
Link: https://lore.kernel.org/r/20221110035033.19498-1-zyytlz.wz@163.com
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",643a16a0eb1d6ac23744bb6e90a00fc21148a9dc,https://github.com/torvalds/linux/commit/643a16a0eb1d6ac23744bb6e90a00fc21148a9dc,drivers/misc/sgi-gru/grufault.c,gru_set_context_option,"int gru_set_context_option(unsigned long arg)
{
struct gru_thread_state *gts;
struct gru_set_context_option_req req;
int ret = 0;
STAT(set_context_option);
if (copy_from_user(&req, (void __user *)arg, sizeof(req)))
return -EFAULT;
gru_dbg(grudev, ""op %d, gseg 0x%lx, value1 0x%lx\n"", req.op, req.gseg, req.val1);
gts = gru_find_lock_gts(req.gseg);
if (!gts) {
gts = gru_alloc_locked_gts(req.gseg);
if (IS_ERR(gts))
return PTR_ERR(gts);
}
switch (req.op) {
case sco_blade_chiplet:
if (req.val0 < -1 || req.val0 >= GRU_CHIPLETS_PER_HUB ||
req.val1 < -1 || req.val1 >= GRU_MAX_BLADES ||
(req.val1 >= 0 && !gru_base[req.val1])) {
ret = -EINVAL;
} else {
gts->ts_user_blade_id = req.val1;
gts->ts_user_chiplet_id = req.val0;
gru_check_context_placement(gts);
}
break;
case sco_gseg_owner:
gts->ts_tgid_owner = current->tgid;
break;
case sco_cch_req_slice:
gts->ts_cch_req_slice = req.val1 & 3;
break;
default:
ret = -EINVAL;
}
gru_unlock_gts(gts);
return ret;
}","int gru_set_context_option(unsigned long VAR_0)
{
struct gru_thread_state *VAR_1;
struct gru_set_context_option_req VAR_2;
int VAR_3 = 0;
STAT(VAR_4);
if (copy_from_user(&VAR_2, (void __user *)VAR_0, sizeof(VAR_2)))
return -VAR_5;
gru_dbg(VAR_6, ""op %d, gseg 0x%lx, value1 0x%lx\n"", VAR_2.op, VAR_2.gseg, VAR_2.val1);
VAR_1 = gru_find_lock_gts(VAR_2.gseg);
if (!VAR_1) {
VAR_1 = gru_alloc_locked_gts(VAR_2.gseg);
if (IS_ERR(VAR_1))
return PTR_ERR(VAR_1);
}
switch (VAR_2.op) {
case VAR_7:
if (VAR_2.val0 < -1 || VAR_2.val0 >= VAR_8 ||
VAR_2.val1 < -1 || VAR_2.val1 >= VAR_9 ||
(VAR_2.val1 >= 0 && !VAR_10[VAR_2.val1])) {
VAR_3 = -VAR_11;
} else {
VAR_1->ts_user_blade_id = VAR_2.val1;
VAR_1->ts_user_chiplet_id = VAR_2.val0;
gru_check_context_placement(VAR_1);
}
break;
case VAR_12:
VAR_1->ts_tgid_owner = VAR_13->tgid;
break;
case VAR_14:
VAR_1->ts_cch_req_slice = VAR_2.val1 & 3;
break;
default:
VAR_3 = -VAR_11;
}
gru_unlock_gts(VAR_1);
return VAR_3;
}",torvalds/linux/643a16a0eb1d6ac23744bb6e90a00fc21148a9dc/grufault.c/vul/before/1.json,"int gru_set_context_option(unsigned long arg)
{
	struct gru_thread_state *gts;
	struct gru_set_context_option_req req;
	int ret = 0;

	STAT(set_context_option);
	if (copy_from_user(&req, (void __user *)arg, sizeof(req)))
		return -EFAULT;
	gru_dbg(grudev, ""op %d, gseg 0x%lx, value1 0x%lx\n"", req.op, req.gseg, req.val1);

	gts = gru_find_lock_gts(req.gseg);
	if (!gts) {
		gts = gru_alloc_locked_gts(req.gseg);
		if (IS_ERR(gts))
			return PTR_ERR(gts);
	}

	switch (req.op) {
	case sco_blade_chiplet:
		/* Select blade/chiplet for GRU context */
		if (req.val0 < -1 || req.val0 >= GRU_CHIPLETS_PER_HUB ||
		    req.val1 < -1 || req.val1 >= GRU_MAX_BLADES ||
		    (req.val1 >= 0 && !gru_base[req.val1])) {
			ret = -EINVAL;
		} else {
			gts->ts_user_blade_id = req.val1;
			gts->ts_user_chiplet_id = req.val0;
			if (gru_check_context_placement(gts)) {
				gru_unlock_gts(gts);
				gru_unload_context(gts, 1);
				return ret;
			}
		}
		break;
	case sco_gseg_owner:
 		/* Register the current task as the GSEG owner */
		gts->ts_tgid_owner = current->tgid;
		break;
	case sco_cch_req_slice:
 		/* Set the CCH slice option */
		gts->ts_cch_req_slice = req.val1 & 3;
		break;
	default:
		ret = -EINVAL;
	}
	gru_unlock_gts(gts);

	return ret;
}","int gru_set_context_option(unsigned long VAR_0)
{
	struct gru_thread_state *VAR_1;
	struct gru_set_context_option_req VAR_2;
	int VAR_3 = 0;

	STAT(VAR_4);
	if (copy_from_user(&VAR_2, (void __user *)VAR_0, sizeof(VAR_2)))
		return -VAR_5;
	gru_dbg(VAR_6, ""op %d, gseg 0x%lx, value1 0x%lx\n"", VAR_2.op, VAR_2.gseg, VAR_2.val1);

	VAR_1 = gru_find_lock_gts(VAR_2.gseg);
	if (!VAR_1) {
		VAR_1 = gru_alloc_locked_gts(VAR_2.gseg);
		if (IS_ERR(VAR_1))
			return PTR_ERR(VAR_1);
	}

	switch (VAR_2.op) {
	case VAR_7:
		/* COMMENT_0 */
		if (VAR_2.val0 < -1 || VAR_2.val0 >= VAR_8 ||
		    VAR_2.val1 < -1 || VAR_2.val1 >= VAR_9 ||
		    (VAR_2.val1 >= 0 && !VAR_10[VAR_2.val1])) {
			VAR_3 = -VAR_11;
		} else {
			VAR_1->ts_user_blade_id = VAR_2.val1;
			VAR_1->ts_user_chiplet_id = VAR_2.val0;
			if (gru_check_context_placement(VAR_1)) {
				gru_unlock_gts(VAR_1);
				gru_unload_context(VAR_1, 1);
				return VAR_3;
			}
		}
		break;
	case VAR_12:
 		/* COMMENT_1 */
		VAR_1->ts_tgid_owner = VAR_13->tgid;
		break;
	case VAR_14:
 		/* COMMENT_2 */
		VAR_1->ts_cch_req_slice = VAR_2.val1 & 3;
		break;
	default:
		VAR_3 = -VAR_11;
	}
	gru_unlock_gts(VAR_1);

	return VAR_3;
}",torvalds/linux/643a16a0eb1d6ac23744bb6e90a00fc21148a9dc/grufault.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -26,7 +26,11 @@
 		} else {
 			gts->ts_user_blade_id = req.val1;
 			gts->ts_user_chiplet_id = req.val0;
-			gru_check_context_placement(gts);
+			if (gru_check_context_placement(gts)) {
+				gru_unlock_gts(gts);
+				gru_unload_context(gts, 1);
+				return ret;
+			}
 		}
 		break;
 	case sco_gseg_owner:","{'deleted_lines': ['\t\t\tgru_check_context_placement(gts);'], 'added_lines': ['\t\t\tif (gru_check_context_placement(gts)) {', '\t\t\t\tgru_unlock_gts(gts);', '\t\t\t\tgru_unload_context(gts, 1);', '\t\t\t\treturn ret;', '\t\t\t}']}",True,"A use-after-free flaw was found in the Linux kernels SGI GRU driver in the way the first gru_file_unlocked_ioctl function is called by the user, where a fail pass occurs in the gru_check_chiplet_assignment function. This flaw allows a local user to crash or potentially escalate their privileges on the system.",7.8,HIGH,2,test,2022-11-10T03:50:33Z,4
CVE-2022-3424,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"misc: sgi-gru: fix use-after-free error in gru_set_context_option, gru_fault and gru_handle_user_call_os

In some bad situation, the gts may be freed gru_check_chiplet_assignment.
The call chain can be gru_unload_context->gru_free_gru_context->gts_drop
and kfree finally. However, the caller didn't know if the gts is freed
or not and use it afterwards. This will trigger a Use after Free bug.

Fix it by introducing a return value to see if it's in error path or not.
Free the gts in caller if gru_check_chiplet_assignment check failed.

Fixes: 55484c45dbec (""gru: allow users to specify gru chiplet 2"")
Signed-off-by: Zheng Wang <zyytlz.wz@163.com>
Acked-by: Dimitri Sivanich <sivanich@hpe.com>
Link: https://lore.kernel.org/r/20221110035033.19498-1-zyytlz.wz@163.com
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",643a16a0eb1d6ac23744bb6e90a00fc21148a9dc,https://github.com/torvalds/linux/commit/643a16a0eb1d6ac23744bb6e90a00fc21148a9dc,drivers/misc/sgi-gru/grufault.c,gru_handle_user_call_os,"int gru_handle_user_call_os(unsigned long cb)
{
struct gru_tlb_fault_handle *tfh;
struct gru_thread_state *gts;
void *cbk;
int ucbnum, cbrnum, ret = -EINVAL;
STAT(call_os);
ucbnum = get_cb_number((void *)cb);
if ((cb & (GRU_HANDLE_STRIDE - 1)) || ucbnum >= GRU_NUM_CB)
return -EINVAL;
gts = gru_find_lock_gts(cb);
if (!gts)
return -EINVAL;
gru_dbg(grudev, ""address 0x%lx, gid %d, gts 0x%p\n"", cb, gts->ts_gru ? gts->ts_gru->gs_gid : -1, gts);
if (ucbnum >= gts->ts_cbr_au_count * GRU_CBR_AU_SIZE)
goto exit;
gru_check_context_placement(gts);
if (gts->ts_gru && gts->ts_force_cch_reload) {
gts->ts_force_cch_reload = 0;
gru_update_cch(gts);
}
ret = -EAGAIN;
cbrnum = thread_cbr_number(gts, ucbnum);
if (gts->ts_gru) {
tfh = get_tfh_by_index(gts->ts_gru, cbrnum);
cbk = get_gseg_base_address_cb(gts->ts_gru->gs_gru_base_vaddr,
gts->ts_ctxnum, ucbnum);
ret = gru_user_dropin(gts, tfh, cbk);
}
exit:
gru_unlock_gts(gts);
return ret;
}","int gru_handle_user_call_os(unsigned long VAR_0)
{
struct gru_tlb_fault_handle *VAR_1;
struct gru_thread_state *VAR_2;
void *VAR_3;
int VAR_4, VAR_5, VAR_6 = -VAR_7;
STAT(VAR_8);
VAR_4 = get_cb_number((void *)VAR_0);
if ((VAR_0 & (VAR_9 - 1)) || VAR_4 >= VAR_10)
return -VAR_7;
VAR_2 = gru_find_lock_gts(VAR_0);
if (!VAR_2)
return -VAR_7;
gru_dbg(VAR_11, ""address 0x%lx, gid %d, gts 0x%p\n"", VAR_0, VAR_2->ts_gru ? VAR_2->ts_gru->gs_gid : -1, VAR_2);
if (VAR_4 >= VAR_2->ts_cbr_au_count * VAR_12)
goto exit;
gru_check_context_placement(VAR_2);
if (VAR_2->ts_gru && VAR_2->ts_force_cch_reload) {
VAR_2->ts_force_cch_reload = 0;
gru_update_cch(VAR_2);
}
VAR_6 = -VAR_13;
VAR_5 = thread_cbr_number(VAR_2, VAR_4);
if (VAR_2->ts_gru) {
VAR_1 = get_tfh_by_index(VAR_2->ts_gru, VAR_5);
VAR_3 = get_gseg_base_address_cb(VAR_2->ts_gru->gs_gru_base_vaddr,
VAR_2->ts_ctxnum, VAR_4);
VAR_6 = gru_user_dropin(VAR_2, VAR_1, VAR_3);
}
exit:
gru_unlock_gts(VAR_2);
return VAR_6;
}",torvalds/linux/643a16a0eb1d6ac23744bb6e90a00fc21148a9dc/grufault.c/vul/before/0.json,"int gru_handle_user_call_os(unsigned long cb)
{
	struct gru_tlb_fault_handle *tfh;
	struct gru_thread_state *gts;
	void *cbk;
	int ucbnum, cbrnum, ret = -EINVAL;

	STAT(call_os);

	/* sanity check the cb pointer */
	ucbnum = get_cb_number((void *)cb);
	if ((cb & (GRU_HANDLE_STRIDE - 1)) || ucbnum >= GRU_NUM_CB)
		return -EINVAL;

again:
	gts = gru_find_lock_gts(cb);
	if (!gts)
		return -EINVAL;
	gru_dbg(grudev, ""address 0x%lx, gid %d, gts 0x%p\n"", cb, gts->ts_gru ? gts->ts_gru->gs_gid : -1, gts);

	if (ucbnum >= gts->ts_cbr_au_count * GRU_CBR_AU_SIZE)
		goto exit;

	if (gru_check_context_placement(gts)) {
		gru_unlock_gts(gts);
		gru_unload_context(gts, 1);
		goto again;
	}

	/*
	 * CCH may contain stale data if ts_force_cch_reload is set.
	 */
	if (gts->ts_gru && gts->ts_force_cch_reload) {
		gts->ts_force_cch_reload = 0;
		gru_update_cch(gts);
	}

	ret = -EAGAIN;
	cbrnum = thread_cbr_number(gts, ucbnum);
	if (gts->ts_gru) {
		tfh = get_tfh_by_index(gts->ts_gru, cbrnum);
		cbk = get_gseg_base_address_cb(gts->ts_gru->gs_gru_base_vaddr,
				gts->ts_ctxnum, ucbnum);
		ret = gru_user_dropin(gts, tfh, cbk);
	}
exit:
	gru_unlock_gts(gts);
	return ret;
}","int gru_handle_user_call_os(unsigned long VAR_0)
{
	struct gru_tlb_fault_handle *VAR_1;
	struct gru_thread_state *VAR_2;
	void *VAR_3;
	int VAR_4, VAR_5, VAR_6 = -VAR_7;

	STAT(VAR_8);

	/* COMMENT_0 */
	VAR_4 = get_cb_number((void *)VAR_0);
	if ((VAR_0 & (VAR_9 - 1)) || VAR_4 >= VAR_10)
		return -VAR_7;

again:
	VAR_2 = gru_find_lock_gts(VAR_0);
	if (!VAR_2)
		return -VAR_7;
	gru_dbg(VAR_11, ""address 0x%lx, gid %d, gts 0x%p\n"", VAR_0, VAR_2->ts_gru ? VAR_2->ts_gru->gs_gid : -1, VAR_2);

	if (VAR_4 >= VAR_2->ts_cbr_au_count * VAR_12)
		goto exit;

	if (gru_check_context_placement(VAR_2)) {
		gru_unlock_gts(VAR_2);
		gru_unload_context(VAR_2, 1);
		goto again;
	}

	/* COMMENT_1 */
                                                             
    
	if (VAR_2->ts_gru && VAR_2->ts_force_cch_reload) {
		VAR_2->ts_force_cch_reload = 0;
		gru_update_cch(VAR_2);
	}

	VAR_6 = -VAR_13;
	VAR_5 = thread_cbr_number(VAR_2, VAR_4);
	if (VAR_2->ts_gru) {
		VAR_1 = get_tfh_by_index(VAR_2->ts_gru, VAR_5);
		VAR_3 = get_gseg_base_address_cb(VAR_2->ts_gru->gs_gru_base_vaddr,
				VAR_2->ts_ctxnum, VAR_4);
		VAR_6 = gru_user_dropin(VAR_2, VAR_1, VAR_3);
	}
exit:
	gru_unlock_gts(VAR_2);
	return VAR_6;
}",torvalds/linux/643a16a0eb1d6ac23744bb6e90a00fc21148a9dc/grufault.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,6 +12,7 @@
 	if ((cb & (GRU_HANDLE_STRIDE - 1)) || ucbnum >= GRU_NUM_CB)
 		return -EINVAL;
 
+again:
 	gts = gru_find_lock_gts(cb);
 	if (!gts)
 		return -EINVAL;
@@ -20,7 +21,11 @@
 	if (ucbnum >= gts->ts_cbr_au_count * GRU_CBR_AU_SIZE)
 		goto exit;
 
-	gru_check_context_placement(gts);
+	if (gru_check_context_placement(gts)) {
+		gru_unlock_gts(gts);
+		gru_unload_context(gts, 1);
+		goto again;
+	}
 
 	/*
 	 * CCH may contain stale data if ts_force_cch_reload is set.","{'deleted_lines': ['\tgru_check_context_placement(gts);'], 'added_lines': ['again:', '\tif (gru_check_context_placement(gts)) {', '\t\tgru_unlock_gts(gts);', '\t\tgru_unload_context(gts, 1);', '\t\tgoto again;', '\t}']}",True,"A use-after-free flaw was found in the Linux kernels SGI GRU driver in the way the first gru_file_unlocked_ioctl function is called by the user, where a fail pass occurs in the gru_check_chiplet_assignment function. This flaw allows a local user to crash or potentially escalate their privileges on the system.",7.8,HIGH,2,test,2022-11-10T03:50:33Z,4
CVE-2022-3424,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"misc: sgi-gru: fix use-after-free error in gru_set_context_option, gru_fault and gru_handle_user_call_os

In some bad situation, the gts may be freed gru_check_chiplet_assignment.
The call chain can be gru_unload_context->gru_free_gru_context->gts_drop
and kfree finally. However, the caller didn't know if the gts is freed
or not and use it afterwards. This will trigger a Use after Free bug.

Fix it by introducing a return value to see if it's in error path or not.
Free the gts in caller if gru_check_chiplet_assignment check failed.

Fixes: 55484c45dbec (""gru: allow users to specify gru chiplet 2"")
Signed-off-by: Zheng Wang <zyytlz.wz@163.com>
Acked-by: Dimitri Sivanich <sivanich@hpe.com>
Link: https://lore.kernel.org/r/20221110035033.19498-1-zyytlz.wz@163.com
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",643a16a0eb1d6ac23744bb6e90a00fc21148a9dc,https://github.com/torvalds/linux/commit/643a16a0eb1d6ac23744bb6e90a00fc21148a9dc,drivers/misc/sgi-gru/grumain.c,gru_check_context_placement,"void gru_check_context_placement(struct gru_thread_state *gts)
{
struct gru_state *gru;
gru = gts->ts_gru;
if (!gru || gts->ts_tgid_owner != current->tgid)
return;
if (!gru_check_chiplet_assignment(gru, gts)) {
STAT(check_context_unload);
gru_unload_context(gts, 1);
} else if (gru_retarget_intr(gts)) {
STAT(check_context_retarget_intr);
}
}","void gru_check_context_placement(struct gru_thread_state *VAR_0)
{
struct gru_state *VAR_1;
VAR_1 = VAR_0->ts_gru;
if (!VAR_1 || VAR_0->ts_tgid_owner != VAR_2->tgid)
return;
if (!gru_check_chiplet_assignment(VAR_1, VAR_0)) {
STAT(VAR_3);
gru_unload_context(VAR_0, 1);
} else if (gru_retarget_intr(VAR_0)) {
STAT(VAR_4);
}
}",torvalds/linux/643a16a0eb1d6ac23744bb6e90a00fc21148a9dc/grumain.c/vul/before/0.json,"int gru_check_context_placement(struct gru_thread_state *gts)
{
	struct gru_state *gru;
	int ret = 0;

	/*
	 * If the current task is the context owner, verify that the
	 * context is correctly placed. This test is skipped for non-owner
	 * references. Pthread apps use non-owner references to the CBRs.
	 */
	gru = gts->ts_gru;
	/*
	 * If gru or gts->ts_tgid_owner isn't initialized properly, return
	 * success to indicate that the caller does not need to unload the
	 * gru context.The caller is responsible for their inspection and
	 * reinitialization if needed.
	 */
	if (!gru || gts->ts_tgid_owner != current->tgid)
		return ret;

	if (!gru_check_chiplet_assignment(gru, gts)) {
		STAT(check_context_unload);
		ret = -EINVAL;
	} else if (gru_retarget_intr(gts)) {
		STAT(check_context_retarget_intr);
	}

	return ret;
}","int gru_check_context_placement(struct gru_thread_state *VAR_0)
{
	struct gru_state *VAR_1;
	int VAR_2 = 0;

	/* COMMENT_0 */
                                                             
                                                                   
                                                                  
    
	VAR_1 = VAR_0->ts_gru;
	/* COMMENT_5 */
                                                                   
                                                                   
                                                                  
                               
    
	if (!VAR_1 || VAR_0->ts_tgid_owner != VAR_3->tgid)
		return VAR_2;

	if (!gru_check_chiplet_assignment(VAR_1, VAR_0)) {
		STAT(VAR_4);
		VAR_2 = -VAR_5;
	} else if (gru_retarget_intr(VAR_0)) {
		STAT(VAR_6);
	}

	return VAR_2;
}",torvalds/linux/643a16a0eb1d6ac23744bb6e90a00fc21148a9dc/grumain.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,7 @@
-void gru_check_context_placement(struct gru_thread_state *gts)
+int gru_check_context_placement(struct gru_thread_state *gts)
 {
 	struct gru_state *gru;
+	int ret = 0;
 
 	/*
 	 * If the current task is the context owner, verify that the
@@ -8,13 +9,21 @@
 	 * references. Pthread apps use non-owner references to the CBRs.
 	 */
 	gru = gts->ts_gru;
+	/*
+	 * If gru or gts->ts_tgid_owner isn't initialized properly, return
+	 * success to indicate that the caller does not need to unload the
+	 * gru context.The caller is responsible for their inspection and
+	 * reinitialization if needed.
+	 */
 	if (!gru || gts->ts_tgid_owner != current->tgid)
-		return;
+		return ret;
 
 	if (!gru_check_chiplet_assignment(gru, gts)) {
 		STAT(check_context_unload);
-		gru_unload_context(gts, 1);
+		ret = -EINVAL;
 	} else if (gru_retarget_intr(gts)) {
 		STAT(check_context_retarget_intr);
 	}
+
+	return ret;
 }","{'deleted_lines': ['void gru_check_context_placement(struct gru_thread_state *gts)', '\t\treturn;', '\t\tgru_unload_context(gts, 1);'], 'added_lines': ['int gru_check_context_placement(struct gru_thread_state *gts)', '\tint ret = 0;', '\t/*', ""\t * If gru or gts->ts_tgid_owner isn't initialized properly, return"", '\t * success to indicate that the caller does not need to unload the', '\t * gru context.The caller is responsible for their inspection and', '\t * reinitialization if needed.', '\t */', '\t\treturn ret;', '\t\tret = -EINVAL;', '', '\treturn ret;']}",True,"A use-after-free flaw was found in the Linux kernels SGI GRU driver in the way the first gru_file_unlocked_ioctl function is called by the user, where a fail pass occurs in the gru_check_chiplet_assignment function. This flaw allows a local user to crash or potentially escalate their privileges on the system.",7.8,HIGH,2,test,2022-11-10T03:50:33Z,4
CVE-2022-3424,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"misc: sgi-gru: fix use-after-free error in gru_set_context_option, gru_fault and gru_handle_user_call_os

In some bad situation, the gts may be freed gru_check_chiplet_assignment.
The call chain can be gru_unload_context->gru_free_gru_context->gts_drop
and kfree finally. However, the caller didn't know if the gts is freed
or not and use it afterwards. This will trigger a Use after Free bug.

Fix it by introducing a return value to see if it's in error path or not.
Free the gts in caller if gru_check_chiplet_assignment check failed.

Fixes: 55484c45dbec (""gru: allow users to specify gru chiplet 2"")
Signed-off-by: Zheng Wang <zyytlz.wz@163.com>
Acked-by: Dimitri Sivanich <sivanich@hpe.com>
Link: https://lore.kernel.org/r/20221110035033.19498-1-zyytlz.wz@163.com
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",643a16a0eb1d6ac23744bb6e90a00fc21148a9dc,https://github.com/torvalds/linux/commit/643a16a0eb1d6ac23744bb6e90a00fc21148a9dc,drivers/misc/sgi-gru/grumain.c,gru_fault,"vm_fault_t gru_fault(struct vm_fault *vmf)
{
struct vm_area_struct *vma = vmf->vma;
struct gru_thread_state *gts;
unsigned long paddr, vaddr;
unsigned long expires;
vaddr = vmf->address;
gru_dbg(grudev, ""vma %p, vaddr 0x%lx (0x%lx)\n"",
vma, vaddr, GSEG_BASE(vaddr));
STAT(nopfn);
gts = gru_find_thread_state(vma, TSID(vaddr, vma));
if (!gts)
return VM_FAULT_SIGBUS;
again:
mutex_lock(&gts->ts_ctxlock);
preempt_disable();
gru_check_context_placement(gts);
if (!gts->ts_gru) {
STAT(load_user_context);
if (!gru_assign_gru_context(gts)) {
preempt_enable();
mutex_unlock(&gts->ts_ctxlock);
set_current_state(TASK_INTERRUPTIBLE);
schedule_timeout(GRU_ASSIGN_DELAY);  
expires = gts->ts_steal_jiffies + GRU_STEAL_DELAY;
if (time_before(expires, jiffies))
gru_steal_context(gts);
goto again;
}
gru_load_context(gts);
paddr = gseg_physical_address(gts->ts_gru, gts->ts_ctxnum);
remap_pfn_range(vma, vaddr & ~(GRU_GSEG_PAGESIZE - 1),
paddr >> PAGE_SHIFT, GRU_GSEG_PAGESIZE,
vma->vm_page_prot);
}
preempt_enable();
mutex_unlock(&gts->ts_ctxlock);
return VM_FAULT_NOPAGE;
}","vm_fault_t gru_fault(struct vm_fault *VAR_0)
{
struct vm_area_struct *VAR_1 = VAR_0->vma;
struct gru_thread_state *VAR_2;
unsigned long VAR_3, VAR_4;
unsigned long VAR_5;
VAR_4 = VAR_0->address;
gru_dbg(VAR_6, ""vma %p, vaddr 0x%lx (0x%lx)\n"",
VAR_1, VAR_4, GSEG_BASE(VAR_4));
STAT(VAR_7);
VAR_2 = gru_find_thread_state(VAR_1, TSID(VAR_4, VAR_1));
if (!VAR_2)
return VAR_8;
again:
mutex_lock(&VAR_2->ts_ctxlock);
preempt_disable();
gru_check_context_placement(VAR_2);
if (!VAR_2->ts_gru) {
STAT(VAR_9);
if (!gru_assign_gru_context(VAR_2)) {
preempt_enable();
mutex_unlock(&VAR_2->ts_ctxlock);
set_current_state(VAR_10);
schedule_timeout(VAR_11);  
VAR_5 = VAR_2->ts_steal_jiffies + VAR_12;
if (time_before(VAR_5, VAR_13))
gru_steal_context(VAR_2);
goto again;
}
gru_load_context(VAR_2);
VAR_3 = gseg_physical_address(VAR_2->ts_gru, VAR_2->ts_ctxnum);
remap_pfn_range(VAR_1, VAR_4 & ~(VAR_14 - 1),
VAR_3 >> VAR_15, VAR_14,
VAR_1->vm_page_prot);
}
preempt_enable();
mutex_unlock(&VAR_2->ts_ctxlock);
return VAR_16;
}",torvalds/linux/643a16a0eb1d6ac23744bb6e90a00fc21148a9dc/grumain.c/vul/before/1.json,"vm_fault_t gru_fault(struct vm_fault *vmf)
{
	struct vm_area_struct *vma = vmf->vma;
	struct gru_thread_state *gts;
	unsigned long paddr, vaddr;
	unsigned long expires;

	vaddr = vmf->address;
	gru_dbg(grudev, ""vma %p, vaddr 0x%lx (0x%lx)\n"",
		vma, vaddr, GSEG_BASE(vaddr));
	STAT(nopfn);

	/* The following check ensures vaddr is a valid address in the VMA */
	gts = gru_find_thread_state(vma, TSID(vaddr, vma));
	if (!gts)
		return VM_FAULT_SIGBUS;

again:
	mutex_lock(&gts->ts_ctxlock);
	preempt_disable();

	if (gru_check_context_placement(gts)) {
		preempt_enable();
		mutex_unlock(&gts->ts_ctxlock);
		gru_unload_context(gts, 1);
		return VM_FAULT_NOPAGE;
	}

	if (!gts->ts_gru) {
		STAT(load_user_context);
		if (!gru_assign_gru_context(gts)) {
			preempt_enable();
			mutex_unlock(&gts->ts_ctxlock);
			set_current_state(TASK_INTERRUPTIBLE);
			schedule_timeout(GRU_ASSIGN_DELAY);  /* true hack ZZZ */
			expires = gts->ts_steal_jiffies + GRU_STEAL_DELAY;
			if (time_before(expires, jiffies))
				gru_steal_context(gts);
			goto again;
		}
		gru_load_context(gts);
		paddr = gseg_physical_address(gts->ts_gru, gts->ts_ctxnum);
		remap_pfn_range(vma, vaddr & ~(GRU_GSEG_PAGESIZE - 1),
				paddr >> PAGE_SHIFT, GRU_GSEG_PAGESIZE,
				vma->vm_page_prot);
	}

	preempt_enable();
	mutex_unlock(&gts->ts_ctxlock);

	return VM_FAULT_NOPAGE;
}","vm_fault_t gru_fault(struct vm_fault *VAR_0)
{
	struct vm_area_struct *VAR_1 = VAR_0->vma;
	struct gru_thread_state *VAR_2;
	unsigned long VAR_3, VAR_4;
	unsigned long VAR_5;

	VAR_4 = VAR_0->address;
	gru_dbg(VAR_6, ""vma %p, vaddr 0x%lx (0x%lx)\n"",
		VAR_1, VAR_4, GSEG_BASE(VAR_4));
	STAT(VAR_7);

	/* COMMENT_0 */
	VAR_2 = gru_find_thread_state(VAR_1, TSID(VAR_4, VAR_1));
	if (!VAR_2)
		return VAR_8;

again:
	mutex_lock(&VAR_2->ts_ctxlock);
	preempt_disable();

	if (gru_check_context_placement(VAR_2)) {
		preempt_enable();
		mutex_unlock(&VAR_2->ts_ctxlock);
		gru_unload_context(VAR_2, 1);
		return VAR_9;
	}

	if (!VAR_2->ts_gru) {
		STAT(VAR_10);
		if (!gru_assign_gru_context(VAR_2)) {
			preempt_enable();
			mutex_unlock(&VAR_2->ts_ctxlock);
			set_current_state(VAR_11);
			schedule_timeout(VAR_12);  /* COMMENT_1 */
			VAR_5 = VAR_2->ts_steal_jiffies + VAR_13;
			if (time_before(VAR_5, VAR_14))
				gru_steal_context(VAR_2);
			goto again;
		}
		gru_load_context(VAR_2);
		VAR_3 = gseg_physical_address(VAR_2->ts_gru, VAR_2->ts_ctxnum);
		remap_pfn_range(VAR_1, VAR_4 & ~(VAR_15 - 1),
				VAR_3 >> VAR_16, VAR_15,
				VAR_1->vm_page_prot);
	}

	preempt_enable();
	mutex_unlock(&VAR_2->ts_ctxlock);

	return VAR_9;
}",torvalds/linux/643a16a0eb1d6ac23744bb6e90a00fc21148a9dc/grumain.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -19,7 +19,12 @@
 	mutex_lock(&gts->ts_ctxlock);
 	preempt_disable();
 
-	gru_check_context_placement(gts);
+	if (gru_check_context_placement(gts)) {
+		preempt_enable();
+		mutex_unlock(&gts->ts_ctxlock);
+		gru_unload_context(gts, 1);
+		return VM_FAULT_NOPAGE;
+	}
 
 	if (!gts->ts_gru) {
 		STAT(load_user_context);","{'deleted_lines': ['\tgru_check_context_placement(gts);'], 'added_lines': ['\tif (gru_check_context_placement(gts)) {', '\t\tpreempt_enable();', '\t\tmutex_unlock(&gts->ts_ctxlock);', '\t\tgru_unload_context(gts, 1);', '\t\treturn VM_FAULT_NOPAGE;', '\t}']}",True,"A use-after-free flaw was found in the Linux kernels SGI GRU driver in the way the first gru_file_unlocked_ioctl function is called by the user, where a fail pass occurs in the gru_check_chiplet_assignment function. This flaw allows a local user to crash or potentially escalate their privileges on the system.",7.8,HIGH,2,test,2022-11-10T03:50:33Z,4
CVE-2022-45343,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,gpac,fixed #2315,1016912db5408b6f38e8eb715279493ae380d1c4,https://github.com/gpac/gpac/commit/1016912db5408b6f38e8eb715279493ae380d1c4,src/bifs/field_decode.c,BD_DecMFFieldList,"GF_Err BD_DecMFFieldList(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)
{
GF_Node *new_node;
GF_Err e;
u8 endFlag, qp_local, qp_on, initial_qp;
GF_ChildNodeItem *last = NULL;
u32 nbF;
GF_FieldInfo sffield;
memset(&sffield, 0, sizeof(GF_FieldInfo));
sffield.fieldIndex = field->fieldIndex;
sffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType);
sffield.NDTtype = field->NDTtype;
sffield.name = field->name;
nbF = 0;
qp_on = qp_local = 0;
initial_qp = codec->ActiveQP ? 1 : 0;
endFlag = gf_bs_read_int(bs, 1);
while (!endFlag  && (codec->LastError>=0)) {
if (field->fieldType != GF_SG_VRML_MFNODE) {
e = gf_sg_vrml_mf_append(field->far_ptr, field->fieldType, & sffield.far_ptr);
if (e) return e;
e = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);
if (e) return e;
} else {
new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);
if (new_node) {
e = gf_node_register(new_node, is_mem_com ? NULL : node);
if (e) return e;
if (node) {
if (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {
qp_local = ((M_QuantizationParameter *)new_node)->isLocal;
if (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);
e = gf_bifs_dec_qp_set(codec, new_node);
if (e) return e;
qp_on = 1;
if (qp_local) qp_local = 2;
if (codec->force_keep_qp) {
e = gf_node_list_add_child_last(field->far_ptr, new_node, &last);
} else {
gf_node_register(new_node, NULL);
gf_node_unregister(new_node, node);
}
} else
e = gf_node_list_add_child_last(field->far_ptr, new_node, &last);
}
else if (codec->pCurrentProto) {
e = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);
}
} else {
return codec->LastError;
}
}
if (e) return e;
endFlag = gf_bs_read_int(bs, 1);
if (qp_on && qp_local) {
if (qp_local == 2) {
qp_local = 1;
} else {
gf_bifs_dec_qp_remove(codec, initial_qp);
qp_local = 0;
qp_on = 0;
}
}
nbF += 1;
}
if (qp_on) gf_bifs_dec_qp_remove(codec, initial_qp);
gf_bifs_dec_qp14_set_length(codec, nbF);
return GF_OK;
}","GF_Err BD_DecMFFieldList(GF_BifsDecoder * VAR_0, GF_BitStream *VAR_1, GF_Node *VAR_2, GF_FieldInfo *VAR_3, Bool VAR_4)
{
GF_Node *VAR_5;
GF_Err VAR_6;
u8 VAR_7, VAR_8, VAR_9, VAR_10;
GF_ChildNodeItem *VAR_11 = NULL;
u32 VAR_12;
GF_FieldInfo VAR_13;
memset(&VAR_13, 0, sizeof(GF_FieldInfo));
VAR_13.fieldIndex = VAR_3->fieldIndex;
VAR_13.fieldType = gf_sg_vrml_get_sf_type(VAR_3->fieldType);
VAR_13.NDTtype = VAR_3->NDTtype;
VAR_13.name = VAR_3->name;
VAR_12 = 0;
VAR_9 = VAR_8 = 0;
VAR_10 = VAR_0->ActiveQP ? 1 : 0;
VAR_7 = gf_bs_read_int(VAR_1, 1);
while (!VAR_7  && (VAR_0->LastError>=0)) {
if (VAR_3->fieldType != VAR_14) {
VAR_6 = gf_sg_vrml_mf_append(VAR_3->far_ptr, VAR_3->fieldType, & VAR_13.far_ptr);
if (VAR_6) return VAR_6;
VAR_6 = gf_bifs_dec_sf_field(VAR_0, VAR_1, VAR_2, &VAR_13, VAR_15);
if (VAR_6) return VAR_6;
} else {
VAR_5 = gf_bifs_dec_node(VAR_0, VAR_1, VAR_3->NDTtype);
if (VAR_5) {
VAR_6 = gf_node_register(VAR_5, VAR_4 ? NULL : VAR_2);
if (VAR_6) return VAR_6;
if (VAR_2) {
if (gf_node_get_tag(VAR_5) == VAR_16) {
VAR_8 = ((M_QuantizationParameter *)VAR_5)->isLocal;
if (VAR_9) gf_bifs_dec_qp_remove(VAR_0, VAR_15);
VAR_6 = gf_bifs_dec_qp_set(VAR_0, VAR_5);
if (VAR_6) return VAR_6;
VAR_9 = 1;
if (VAR_8) VAR_8 = 2;
if (VAR_0->force_keep_qp) {
VAR_6 = gf_node_list_add_child_last(VAR_3->far_ptr, VAR_5, &VAR_11);
} else {
gf_node_register(VAR_5, NULL);
gf_node_unregister(VAR_5, VAR_2);
}
} else
VAR_6 = gf_node_list_add_child_last(VAR_3->far_ptr, VAR_5, &VAR_11);
}
else if (VAR_0->pCurrentProto) {
VAR_6 = gf_node_list_add_child_last( (GF_ChildNodeItem **)VAR_3->far_ptr, VAR_5, &VAR_11);
}
} else {
return VAR_0->LastError;
}
}
if (VAR_6) return VAR_6;
VAR_7 = gf_bs_read_int(VAR_1, 1);
if (VAR_9 && VAR_8) {
if (VAR_8 == 2) {
VAR_8 = 1;
} else {
gf_bifs_dec_qp_remove(VAR_0, VAR_10);
VAR_8 = 0;
VAR_9 = 0;
}
}
VAR_12 += 1;
}
if (VAR_9) gf_bifs_dec_qp_remove(VAR_0, VAR_10);
gf_bifs_dec_qp14_set_length(VAR_0, VAR_12);
return VAR_17;
}",gpac/1016912db5408b6f38e8eb715279493ae380d1c4/field_decode.c/vul/before/0.json,"GF_Err BD_DecMFFieldList(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)
{
	GF_Node *new_node;
	GF_Err e=GF_OK;
	u8 endFlag, qp_local, qp_on, initial_qp;
	GF_ChildNodeItem *last = NULL;
	u32 nbF;

	GF_FieldInfo sffield;

	memset(&sffield, 0, sizeof(GF_FieldInfo));
	sffield.fieldIndex = field->fieldIndex;
	sffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType);
	sffield.NDTtype = field->NDTtype;
	sffield.name = field->name;

	nbF = 0;
	qp_on = qp_local = 0;
	initial_qp = codec->ActiveQP ? 1 : 0;

	endFlag = gf_bs_read_int(bs, 1);
	while (!endFlag  && (codec->LastError>=0)) {
		if (field->fieldType != GF_SG_VRML_MFNODE) {
			e = gf_sg_vrml_mf_append(field->far_ptr, field->fieldType, & sffield.far_ptr);
			if (e) goto exit;
			e = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);
			if (e) goto exit;
		} else {
			new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);
			//append
			if (new_node) {
				e = gf_node_register(new_node, is_mem_com ? NULL : node);
				if (e) goto exit;

				//regular coding
				if (node) {
					//special case for QP, register as the current QP
					if (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {
						qp_local = ((M_QuantizationParameter *)new_node)->isLocal;
						//we have a QP in the same scope, remove previous
						if (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);
						e = gf_bifs_dec_qp_set(codec, new_node);
						if (e) goto exit;
						qp_on = 1;
						if (qp_local) qp_local = 2;
						if (codec->force_keep_qp) {
							e = gf_node_list_add_child_last(field->far_ptr, new_node, &last);
						} else {
							gf_node_register(new_node, NULL);
							gf_node_unregister(new_node, node);
						}
					} else
						//this is generic MFNode container
						e = gf_node_list_add_child_last(field->far_ptr, new_node, &last);

				}
				//proto coding: directly add the child
				else if (codec->pCurrentProto) {
					//TO DO: what happens if this is a QP node on the interface ?
					e = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);
				}
			} else {
				e = codec->LastError;
				goto exit;
			}
		}
		if (e) goto exit;

		endFlag = gf_bs_read_int(bs, 1);

		//according to the spec, the QP applies to the current node itself,
		//not just children. If IsLocal is TRUE remove the node
		if (qp_on && qp_local) {
			if (qp_local == 2) {
				qp_local = 1;
			} else {
				//ask to get rid of QP and reactivate if we had a QP when entering
				gf_bifs_dec_qp_remove(codec, initial_qp);
				qp_local = 0;
				qp_on = 0;
			}
		}
		nbF += 1;
	}

exit:
	/*finally delete the QP if any (local or not) as we get out of this node
	and reactivate previous one*/
	if (qp_on) gf_bifs_dec_qp_remove(codec, initial_qp);
	if (e) return e;

	/*this is for QP 14*/
	gf_bifs_dec_qp14_set_length(codec, nbF);
	return GF_OK;
}","GF_Err BD_DecMFFieldList(GF_BifsDecoder * VAR_0, GF_BitStream *VAR_1, GF_Node *VAR_2, GF_FieldInfo *VAR_3, Bool VAR_4)
{
	GF_Node *VAR_5;
	GF_Err VAR_6=VAR_7;
	u8 VAR_8, VAR_9, VAR_10, VAR_11;
	GF_ChildNodeItem *VAR_12 = NULL;
	u32 VAR_13;

	GF_FieldInfo VAR_14;

	memset(&VAR_14, 0, sizeof(GF_FieldInfo));
	VAR_14.fieldIndex = VAR_3->fieldIndex;
	VAR_14.fieldType = gf_sg_vrml_get_sf_type(VAR_3->fieldType);
	VAR_14.NDTtype = VAR_3->NDTtype;
	VAR_14.name = VAR_3->name;

	VAR_13 = 0;
	VAR_10 = VAR_9 = 0;
	VAR_11 = VAR_0->ActiveQP ? 1 : 0;

	VAR_8 = gf_bs_read_int(VAR_1, 1);
	while (!VAR_8  && (VAR_0->LastError>=0)) {
		if (VAR_3->fieldType != VAR_15) {
			VAR_6 = gf_sg_vrml_mf_append(VAR_3->far_ptr, VAR_3->fieldType, & VAR_14.far_ptr);
			if (VAR_6) goto exit;
			VAR_6 = gf_bifs_dec_sf_field(VAR_0, VAR_1, VAR_2, &VAR_14, VAR_16);
			if (VAR_6) goto exit;
		} else {
			VAR_5 = gf_bifs_dec_node(VAR_0, VAR_1, VAR_3->NDTtype);
			/* COMMENT_0 */
			if (VAR_5) {
				VAR_6 = gf_node_register(VAR_5, VAR_4 ? NULL : VAR_2);
				if (VAR_6) goto exit;

				/* COMMENT_1 */
				if (VAR_2) {
					/* COMMENT_2 */
					if (gf_node_get_tag(VAR_5) == VAR_17) {
						VAR_9 = ((M_QuantizationParameter *)VAR_5)->isLocal;
						/* COMMENT_3 */
						if (VAR_10) gf_bifs_dec_qp_remove(VAR_0, VAR_16);
						VAR_6 = gf_bifs_dec_qp_set(VAR_0, VAR_5);
						if (VAR_6) goto exit;
						VAR_10 = 1;
						if (VAR_9) VAR_9 = 2;
						if (VAR_0->force_keep_qp) {
							VAR_6 = gf_node_list_add_child_last(VAR_3->far_ptr, VAR_5, &VAR_12);
						} else {
							gf_node_register(VAR_5, NULL);
							gf_node_unregister(VAR_5, VAR_2);
						}
					} else
						/* COMMENT_4 */
						VAR_6 = gf_node_list_add_child_last(VAR_3->far_ptr, VAR_5, &VAR_12);

				}
				/* COMMENT_5 */
				else if (VAR_0->pCurrentProto) {
					/* COMMENT_6 */
					VAR_6 = gf_node_list_add_child_last( (GF_ChildNodeItem **)VAR_3->far_ptr, VAR_5, &VAR_12);
				}
			} else {
				VAR_6 = VAR_0->LastError;
				goto exit;
			}
		}
		if (VAR_6) goto exit;

		VAR_8 = gf_bs_read_int(VAR_1, 1);

		/* COMMENT_7 */
		/* COMMENT_8 */
		if (VAR_10 && VAR_9) {
			if (VAR_9 == 2) {
				VAR_9 = 1;
			} else {
				/* COMMENT_9 */
				gf_bifs_dec_qp_remove(VAR_0, VAR_11);
				VAR_9 = 0;
				VAR_10 = 0;
			}
		}
		VAR_13 += 1;
	}

exit:
	/* COMMENT_10 */
                              
	if (VAR_10) gf_bifs_dec_qp_remove(VAR_0, VAR_11);
	if (VAR_6) return VAR_6;

	/* COMMENT_12 */
	gf_bifs_dec_qp14_set_length(VAR_0, VAR_13);
	return VAR_7;
}",gpac/1016912db5408b6f38e8eb715279493ae380d1c4/field_decode.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 GF_Err BD_DecMFFieldList(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)
 {
 	GF_Node *new_node;
-	GF_Err e;
+	GF_Err e=GF_OK;
 	u8 endFlag, qp_local, qp_on, initial_qp;
 	GF_ChildNodeItem *last = NULL;
 	u32 nbF;
@@ -22,15 +22,15 @@
 	while (!endFlag  && (codec->LastError>=0)) {
 		if (field->fieldType != GF_SG_VRML_MFNODE) {
 			e = gf_sg_vrml_mf_append(field->far_ptr, field->fieldType, & sffield.far_ptr);
-			if (e) return e;
+			if (e) goto exit;
 			e = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);
-			if (e) return e;
+			if (e) goto exit;
 		} else {
 			new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);
 			//append
 			if (new_node) {
 				e = gf_node_register(new_node, is_mem_com ? NULL : node);
-				if (e) return e;
+				if (e) goto exit;
 
 				//regular coding
 				if (node) {
@@ -40,7 +40,7 @@
 						//we have a QP in the same scope, remove previous
 						if (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);
 						e = gf_bifs_dec_qp_set(codec, new_node);
-						if (e) return e;
+						if (e) goto exit;
 						qp_on = 1;
 						if (qp_local) qp_local = 2;
 						if (codec->force_keep_qp) {
@@ -60,10 +60,11 @@
 					e = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);
 				}
 			} else {
-				return codec->LastError;
+				e = codec->LastError;
+				goto exit;
 			}
 		}
-		if (e) return e;
+		if (e) goto exit;
 
 		endFlag = gf_bs_read_int(bs, 1);
 
@@ -81,9 +82,13 @@
 		}
 		nbF += 1;
 	}
+
+exit:
 	/*finally delete the QP if any (local or not) as we get out of this node
 	and reactivate previous one*/
 	if (qp_on) gf_bifs_dec_qp_remove(codec, initial_qp);
+	if (e) return e;
+
 	/*this is for QP 14*/
 	gf_bifs_dec_qp14_set_length(codec, nbF);
 	return GF_OK;","{'deleted_lines': ['\tGF_Err e;', '\t\t\tif (e) return e;', '\t\t\tif (e) return e;', '\t\t\t\tif (e) return e;', '\t\t\t\t\t\tif (e) return e;', '\t\t\t\treturn codec->LastError;', '\t\tif (e) return e;'], 'added_lines': ['\tGF_Err e=GF_OK;', '\t\t\tif (e) goto exit;', '\t\t\tif (e) goto exit;', '\t\t\t\tif (e) goto exit;', '\t\t\t\t\t\tif (e) goto exit;', '\t\t\t\te = codec->LastError;', '\t\t\t\tgoto exit;', '\t\tif (e) goto exit;', '', 'exit:', '\tif (e) return e;', '']}",True,GPAC v2.1-DEV-rev478-g696e6f868-master was discovered to contain a heap use-after-free via the Q_IsTypeOn function at /gpac/src/bifs/unquantize.c.,7.8,HIGH,2,test,2022-11-14T13:45:13Z,4
CVE-2023-0770,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,gpac,fixed #2316,c31941822ee275a35bc148382bafef1c53ec1c26,https://github.com/gpac/gpac/commit/c31941822ee275a35bc148382bafef1c53ec1c26,src/scenegraph/vrml_proto.c,gf_sg_proto_field_is_sftime_offset,"GF_EXPORT
Bool gf_sg_proto_field_is_sftime_offset(GF_Node *node, GF_FieldInfo *field)
{
u32 i;
GF_Route *r;
GF_ProtoInstance *inst;
GF_FieldInfo inf;
if (node->sgprivate->tag != TAG_ProtoNode) return 0;
if (field->fieldType != GF_SG_VRML_SFTIME) return 0;
inst = (GF_ProtoInstance *) node;
i=0;
while ((r = (GF_Route*)gf_list_enum(inst->proto_interface->sub_graph->Routes, &i))) {
if (!r->IS_route) continue;
if (r->FromNode || (r->FromField.fieldIndex != field->fieldIndex)) continue;
gf_node_get_field(r->ToNode, r->ToField.fieldIndex, &inf);
if (r->ToNode->sgprivate->tag == TAG_ProtoNode) return gf_sg_proto_field_is_sftime_offset(r->ToNode, &inf);
if (!stricmp(inf.name, ""startTime"") || !stricmp(inf.name, ""stopTime"")) return 1;
}
return 0;
}","GF_EXPORT
VAR_0 gf_sg_proto_field_is_sftime_offset(GF_Node *VAR_1, GF_FieldInfo *VAR_2)
{
u32 VAR_3;
GF_Route *VAR_4;
GF_ProtoInstance *VAR_5;
GF_FieldInfo VAR_6;
if (VAR_1->sgprivate->tag != VAR_7) return 0;
if (VAR_2->fieldType != VAR_8) return 0;
VAR_5 = (GF_ProtoInstance *) VAR_1;
VAR_3=0;
while ((VAR_4 = (GF_Route*)gf_list_enum(VAR_5->proto_interface->sub_graph->Routes, &VAR_3))) {
if (!VAR_4->IS_route) continue;
if (VAR_4->FromNode || (VAR_4->FromField.fieldIndex != VAR_2->fieldIndex)) continue;
gf_node_get_field(VAR_4->ToNode, VAR_4->ToField.fieldIndex, &VAR_6);
if (VAR_4->ToNode->sgprivate->tag == VAR_7) return gf_sg_proto_field_is_sftime_offset(VAR_4->ToNode, &VAR_6);
if (!stricmp(VAR_6.name, ""startTime"") || !stricmp(VAR_6.name, ""stopTime"")) return 1;
}
return 0;
}",,"GF_EXPORT
Bool gf_sg_proto_field_is_sftime_offset(GF_Node *node, GF_FieldInfo *field)
{
	u32 i;
	GF_Route *r;
	GF_ProtoInstance *inst;
	GF_FieldInfo inf;
	if (node->sgprivate->tag != TAG_ProtoNode) return 0;
	if (field->fieldType != GF_SG_VRML_SFTIME) return 0;

	inst = (GF_ProtoInstance *) node;
	/*check in interface if this is ISed */
	i=0;
	while ((r = (GF_Route*)gf_list_enum(inst->proto_interface->sub_graph->Routes, &i))) {
		if (!r->IS_route) continue;
		/*only check eventIn/field/exposedField*/
		if (r->FromNode || (r->FromField.fieldIndex != field->fieldIndex)) continue;

		gf_node_get_field(r->ToNode, r->ToField.fieldIndex, &inf);
		/*IS to another proto*/
		if (r->ToNode->sgprivate->tag == TAG_ProtoNode) {
			if (r->ToNode==node) continue;
			return gf_sg_proto_field_is_sftime_offset(r->ToNode, &inf);
		}
		/*IS to a startTime/stopTime field*/
		if (!stricmp(inf.name, ""startTime"") || !stricmp(inf.name, ""stopTime"")) return 1;
	}
	return 0;
}","GF_EXPORT
VAR_0 gf_sg_proto_field_is_sftime_offset(GF_Node *VAR_1, GF_FieldInfo *VAR_2)
{
	u32 VAR_3;
	GF_Route *VAR_4;
	GF_ProtoInstance *VAR_5;
	GF_FieldInfo VAR_6;
	if (VAR_1->sgprivate->tag != VAR_7) return 0;
	if (VAR_2->fieldType != VAR_8) return 0;

	VAR_5 = (GF_ProtoInstance *) VAR_1;
	/* COMMENT_0 */
	VAR_3=0;
	while ((VAR_4 = (GF_Route*)gf_list_enum(VAR_5->proto_interface->sub_graph->Routes, &VAR_3))) {
		if (!VAR_4->IS_route) continue;
		/* COMMENT_1 */
		if (VAR_4->FromNode || (VAR_4->FromField.fieldIndex != VAR_2->fieldIndex)) continue;

		gf_node_get_field(VAR_4->ToNode, VAR_4->ToField.fieldIndex, &VAR_6);
		/* COMMENT_2 */
		if (VAR_4->ToNode->sgprivate->tag == VAR_7) {
			if (VAR_4->ToNode==VAR_1) continue;
			return gf_sg_proto_field_is_sftime_offset(VAR_4->ToNode, &VAR_6);
		}
		/* COMMENT_3 */
		if (!stricmp(VAR_6.name, ""startTime"") || !stricmp(VAR_6.name, ""stopTime"")) return 1;
	}
	return 0;
}",,"--- func_before
+++ func_after
@@ -18,7 +18,10 @@
 
 		gf_node_get_field(r->ToNode, r->ToField.fieldIndex, &inf);
 		/*IS to another proto*/
-		if (r->ToNode->sgprivate->tag == TAG_ProtoNode) return gf_sg_proto_field_is_sftime_offset(r->ToNode, &inf);
+		if (r->ToNode->sgprivate->tag == TAG_ProtoNode) {
+			if (r->ToNode==node) continue;
+			return gf_sg_proto_field_is_sftime_offset(r->ToNode, &inf);
+		}
 		/*IS to a startTime/stopTime field*/
 		if (!stricmp(inf.name, ""startTime"") || !stricmp(inf.name, ""stopTime"")) return 1;
 	}","{'deleted_lines': ['\t\tif (r->ToNode->sgprivate->tag == TAG_ProtoNode) return gf_sg_proto_field_is_sftime_offset(r->ToNode, &inf);'], 'added_lines': ['\t\tif (r->ToNode->sgprivate->tag == TAG_ProtoNode) {', '\t\t\tif (r->ToNode==node) continue;', '\t\t\treturn gf_sg_proto_field_is_sftime_offset(r->ToNode, &inf);', '\t\t}']}",True,Stack-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.2.,7.8,HIGH,2,test,2022-11-23T14:59:43Z,4
CVE-2022-40761,['CWE-1284'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Samsung/mTower,"Fixed CVE-2022-40761

Signed-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,https://github.com/Samsung/mTower/commit/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,tee/tee/tee_pobj.c,tee_pobj_get,"TEE_Result tee_pobj_get(TEE_UUID *uuid, void *obj_id, uint32_t obj_id_len,
uint32_t flags, bool temporary,
const struct tee_file_operations *fops,
struct tee_pobj **obj)
{
struct tee_pobj *o;
TEE_Result res;
*obj = NULL;
TAILQ_FOREACH(o, &tee_pobjs, link) {
if ((obj_id_len == o->obj_id_len) &&
(memcmp(obj_id, o->obj_id, obj_id_len) == 0) &&
(memcmp(uuid, &o->uuid, sizeof(TEE_UUID)) == 0) &&
(fops == o->fops)) {
*obj = o;
}
}
if (*obj) {
if (temporary != (*obj)->temporary) {
res = TEE_ERROR_ACCESS_CONFLICT;
goto out;
}
res = tee_pobj_check_access((*obj)->flags, flags);
if (res == TEE_SUCCESS)
(*obj)->refcnt++;
goto out;
}
o = calloc(1, sizeof(struct tee_pobj));
if (!o) {
res = TEE_ERROR_OUT_OF_MEMORY;
goto out;
}
o->refcnt = 1;
memcpy(&o->uuid, uuid, sizeof(TEE_UUID));
o->flags = flags;
o->fops = fops;
o->temporary = temporary;
o->obj_id = malloc(obj_id_len);
if (o->obj_id == NULL) {
free(o);
res = TEE_ERROR_OUT_OF_MEMORY;
goto out;
}
memcpy(o->obj_id, obj_id, obj_id_len);
o->obj_id_len = obj_id_len;
TAILQ_INSERT_TAIL(&tee_pobjs, o, link);
*obj = o;
res = TEE_SUCCESS;
out:
if (res != TEE_SUCCESS)
*obj = NULL;
return res;
}","TEE_Result tee_pobj_get(TEE_UUID *VAR_0, void *VAR_1, uint32_t VAR_2,
uint32_t VAR_3, bool VAR_4,
const struct tee_file_operations *VAR_5,
struct tee_pobj **VAR_6)
{
struct tee_pobj *VAR_7;
TEE_Result VAR_8;
*VAR_6 = NULL;
TAILQ_FOREACH(VAR_7, &VAR_9, VAR_10) {
if ((VAR_2 == VAR_7->obj_id_len) &&
(memcmp(VAR_1, VAR_7->obj_id, VAR_2) == 0) &&
(memcmp(VAR_0, &VAR_7->uuid, sizeof(TEE_UUID)) == 0) &&
(VAR_5 == VAR_7->fops)) {
*VAR_6 = VAR_7;
}
}
if (*VAR_6) {
if (VAR_4 != (*VAR_6)->temporary) {
VAR_8 = VAR_11;
goto out;
}
VAR_8 = tee_pobj_check_access((*VAR_6)->flags, VAR_3);
if (VAR_8 == VAR_12)
(*VAR_6)->refcnt++;
goto out;
}
VAR_7 = calloc(1, sizeof(struct tee_pobj));
if (!VAR_7) {
VAR_8 = VAR_13;
goto out;
}
VAR_7->refcnt = 1;
memcpy(&VAR_7->uuid, VAR_0, sizeof(TEE_UUID));
VAR_7->flags = VAR_3;
VAR_7->fops = VAR_5;
VAR_7->temporary = VAR_4;
VAR_7->obj_id = malloc(VAR_2);
if (VAR_7->obj_id == NULL) {
free(VAR_7);
VAR_8 = VAR_13;
goto out;
}
memcpy(VAR_7->obj_id, VAR_1, VAR_2);
VAR_7->obj_id_len = VAR_2;
TAILQ_INSERT_TAIL(&VAR_9, VAR_7, VAR_10);
*VAR_6 = VAR_7;
VAR_8 = VAR_12;
out:
if (VAR_8 != VAR_12)
*VAR_6 = NULL;
return VAR_8;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_pobj.c/vul/before/0.json,"TEE_Result tee_pobj_get(TEE_UUID *uuid, void *obj_id, uint32_t obj_id_len,
			uint32_t flags, bool temporary,
			const struct tee_file_operations *fops,
			struct tee_pobj **obj)
{
	struct tee_pobj *o;
	TEE_Result res;

	*obj = NULL;

//	mutex_lock(&pobjs_mutex);
	/* Check if file is open */
	TAILQ_FOREACH(o, &tee_pobjs, link) {
		if ((obj_id_len == o->obj_id_len) &&
		    (memcmp(obj_id, o->obj_id, obj_id_len) == 0) &&
		    (memcmp(uuid, &o->uuid, sizeof(TEE_UUID)) == 0) &&
		    (fops == o->fops)) {
			*obj = o;
		}
	}

	if (*obj) {
		if (temporary != (*obj)->temporary) {
			res = TEE_ERROR_ACCESS_CONFLICT;
			goto out;
		}
		res = tee_pobj_check_access((*obj)->flags, flags);
		if (res == TEE_SUCCESS)
			(*obj)->refcnt++;
		goto out;
	}

	/* new file */
	o = TEE_Malloc(sizeof(struct tee_pobj), TEE_MALLOC_FILL_ZERO);
	// o = calloc(1, sizeof(struct tee_pobj));
	if (!o) {
		res = TEE_ERROR_OUT_OF_MEMORY;
		goto out;
	}

	o->refcnt = 1;
	memcpy(&o->uuid, uuid, sizeof(TEE_UUID));
	o->flags = flags;
	o->fops = fops;
	o->temporary = temporary;

	o->obj_id = malloc(obj_id_len);
	if (o->obj_id == NULL) {
		free(o);
		res = TEE_ERROR_OUT_OF_MEMORY;
		goto out;
	}
	memcpy(o->obj_id, obj_id, obj_id_len);
	o->obj_id_len = obj_id_len;

	TAILQ_INSERT_TAIL(&tee_pobjs, o, link);
	*obj = o;

	res = TEE_SUCCESS;
out:
	if (res != TEE_SUCCESS)
		*obj = NULL;
//	mutex_unlock(&pobjs_mutex);
	return res;
}","TEE_Result tee_pobj_get(TEE_UUID *VAR_0, void *VAR_1, uint32_t VAR_2,
			uint32_t VAR_3, bool VAR_4,
			const struct tee_file_operations *VAR_5,
			struct tee_pobj **VAR_6)
{
	struct tee_pobj *VAR_7;
	TEE_Result VAR_8;

	*VAR_6 = NULL;

/* COMMENT_0 */
	/* COMMENT_1 */
	TAILQ_FOREACH(VAR_7, &VAR_9, VAR_10) {
		if ((VAR_2 == VAR_7->obj_id_len) &&
		    (memcmp(VAR_1, VAR_7->obj_id, VAR_2) == 0) &&
		    (memcmp(VAR_0, &VAR_7->uuid, sizeof(TEE_UUID)) == 0) &&
		    (VAR_5 == VAR_7->fops)) {
			*VAR_6 = VAR_7;
		}
	}

	if (*VAR_6) {
		if (VAR_4 != (*VAR_6)->temporary) {
			VAR_8 = VAR_11;
			goto out;
		}
		VAR_8 = tee_pobj_check_access((*VAR_6)->flags, VAR_3);
		if (VAR_8 == VAR_12)
			(*VAR_6)->refcnt++;
		goto out;
	}

	/* COMMENT_2 */
	VAR_7 = TEE_Malloc(sizeof(struct tee_pobj), VAR_13);
	/* COMMENT_3 */
	if (!VAR_7) {
		VAR_8 = VAR_14;
		goto out;
	}

	VAR_7->refcnt = 1;
	memcpy(&VAR_7->uuid, VAR_0, sizeof(TEE_UUID));
	VAR_7->flags = VAR_3;
	VAR_7->fops = VAR_5;
	VAR_7->temporary = VAR_4;

	VAR_7->obj_id = malloc(VAR_2);
	if (VAR_7->obj_id == NULL) {
		free(VAR_7);
		VAR_8 = VAR_14;
		goto out;
	}
	memcpy(VAR_7->obj_id, VAR_1, VAR_2);
	VAR_7->obj_id_len = VAR_2;

	TAILQ_INSERT_TAIL(&VAR_9, VAR_7, VAR_10);
	*VAR_6 = VAR_7;

	VAR_8 = VAR_12;
out:
	if (VAR_8 != VAR_12)
		*VAR_6 = NULL;
/* COMMENT_4 */
	return VAR_8;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_pobj.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -31,7 +31,8 @@
 	}
 
 	/* new file */
-	o = calloc(1, sizeof(struct tee_pobj));
+	o = TEE_Malloc(sizeof(struct tee_pobj), TEE_MALLOC_FILL_ZERO);
+	// o = calloc(1, sizeof(struct tee_pobj));
 	if (!o) {
 		res = TEE_ERROR_OUT_OF_MEMORY;
 		goto out;","{'deleted_lines': ['\to = calloc(1, sizeof(struct tee_pobj));'], 'added_lines': ['\to = TEE_Malloc(sizeof(struct tee_pobj), TEE_MALLOC_FILL_ZERO);', '\t// o = calloc(1, sizeof(struct tee_pobj));']}",True,"The function tee_obj_free in Samsung mTower through 0.3.0 allows a trusted application to trigger a Denial of Service (DoS) by invoking the function TEE_AllocateOperation with a disturbed heap layout, related to utee_cryp_obj_alloc.",7.5,HIGH,2,test,2022-11-24T19:37:56Z,4
CVE-2022-40761,['CWE-1284'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Samsung/mTower,"Fixed CVE-2022-40761

Signed-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,https://github.com/Samsung/mTower/commit/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,crypto/libtomcrypt/src/tee_ltc_provider.c,crypto_mac_alloc_ctx,"TEE_Result crypto_mac_alloc_ctx(void **ctx_ret, uint32_t algo)
{
TEE_Result res;
size_t ctx_size;
void *ctx;
res = mac_get_ctx_size(algo, &ctx_size);
if (res)
return res;
ctx = calloc(1, ctx_size);
if (!ctx)
return TEE_ERROR_OUT_OF_MEMORY;
*ctx_ret = ctx;
return TEE_SUCCESS;
}","TEE_Result crypto_mac_alloc_ctx(void **VAR_0, uint32_t VAR_1)
{
TEE_Result VAR_2;
size_t VAR_3;
void *VAR_4;
VAR_2 = mac_get_ctx_size(VAR_1, &VAR_3);
if (VAR_2)
return VAR_2;
VAR_4 = calloc(1, VAR_3);
if (!VAR_4)
return VAR_5;
*VAR_0 = VAR_4;
return VAR_6;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_ltc_provider.c/vul/before/5.json,"TEE_Result crypto_mac_alloc_ctx(void **ctx_ret, uint32_t algo)
{
	TEE_Result res;
	size_t ctx_size;
	void *ctx;

	res = mac_get_ctx_size(algo, &ctx_size);
	if (res)
		return res;
	ctx = TEE_Malloc(ctx_size, TEE_MALLOC_FILL_ZERO);
	// ctx = calloc(1, ctx_size);
	if (!ctx)
		return TEE_ERROR_OUT_OF_MEMORY;

	*ctx_ret = ctx;
	return TEE_SUCCESS;
}","TEE_Result crypto_mac_alloc_ctx(void **VAR_0, uint32_t VAR_1)
{
	TEE_Result VAR_2;
	size_t VAR_3;
	void *VAR_4;

	VAR_2 = mac_get_ctx_size(VAR_1, &VAR_3);
	if (VAR_2)
		return VAR_2;
	VAR_4 = TEE_Malloc(VAR_3, VAR_5);
	/* COMMENT_0 */
	if (!VAR_4)
		return VAR_6;

	*VAR_0 = VAR_4;
	return VAR_7;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_ltc_provider.c/vul/after/5.json,"--- func_before
+++ func_after
@@ -7,8 +7,8 @@
 	res = mac_get_ctx_size(algo, &ctx_size);
 	if (res)
 		return res;
-
-	ctx = calloc(1, ctx_size);
+	ctx = TEE_Malloc(ctx_size, TEE_MALLOC_FILL_ZERO);
+	// ctx = calloc(1, ctx_size);
 	if (!ctx)
 		return TEE_ERROR_OUT_OF_MEMORY;
 ","{'deleted_lines': ['', '\tctx = calloc(1, ctx_size);'], 'added_lines': ['\tctx = TEE_Malloc(ctx_size, TEE_MALLOC_FILL_ZERO);', '\t// ctx = calloc(1, ctx_size);']}",True,"The function tee_obj_free in Samsung mTower through 0.3.0 allows a trusted application to trigger a Denial of Service (DoS) by invoking the function TEE_AllocateOperation with a disturbed heap layout, related to utee_cryp_obj_alloc.",7.5,HIGH,2,test,2022-11-24T19:37:56Z,4
CVE-2022-40761,['CWE-1284'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Samsung/mTower,"Fixed CVE-2022-40761

Signed-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,https://github.com/Samsung/mTower/commit/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,tee/kernel/tee_ta_manager.c,tee_ta_init_session,"static TEE_Result tee_ta_init_session(TEE_ErrorOrigin *err,
struct tee_ta_session_head *open_sessions,
const TEE_UUID *uuid,
struct tee_ta_session **sess)
{
TEE_Result res;
struct tee_ta_session *s = malloc(sizeof(struct tee_ta_session));
*err = TEE_ORIGIN_TEE;
if (!s)
return TEE_ERROR_OUT_OF_MEMORY;
memset(s,0,sizeof(struct tee_ta_session));
TAILQ_INSERT_TAIL(open_sessions, s, link);
res = tee_ta_init_pseudo_ta_session(uuid, s);
if (res == TEE_SUCCESS || res != TEE_ERROR_ITEM_NOT_FOUND)
goto out;
res = tee_ta_init_user_ta_session(uuid, s);
out:
if (res == TEE_SUCCESS) {
*sess = s;
} else {
TAILQ_REMOVE(open_sessions, s, link);
free(s);
}
return res;
}","static TEE_Result tee_ta_init_session(TEE_ErrorOrigin *VAR_0,
struct tee_ta_session_head *VAR_1,
const TEE_UUID *VAR_2,
struct tee_ta_session **VAR_3)
{
TEE_Result VAR_4;
struct tee_ta_session *VAR_5 = malloc(sizeof(struct tee_ta_session));
*VAR_0 = VAR_6;
if (!VAR_5)
return VAR_7;
memset(VAR_5,0,sizeof(struct tee_ta_session));
TAILQ_INSERT_TAIL(VAR_1, VAR_5, VAR_8);
VAR_4 = tee_ta_init_pseudo_ta_session(VAR_2, VAR_5);
if (VAR_4 == VAR_9 || VAR_4 != VAR_10)
goto out;
VAR_4 = tee_ta_init_user_ta_session(VAR_2, VAR_5);
out:
if (VAR_4 == VAR_9) {
*VAR_3 = VAR_5;
} else {
TAILQ_REMOVE(VAR_1, VAR_5, VAR_8);
free(VAR_5);
}
return VAR_4;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_ta_manager.c/vul/before/0.json,"static TEE_Result tee_ta_init_session(TEE_ErrorOrigin *err,
				struct tee_ta_session_head *open_sessions,
				const TEE_UUID *uuid,
				struct tee_ta_session **sess)
{
	TEE_Result res;
//	struct tee_ta_ctx *ctx;
//  struct tee_ta_session *s = calloc(1, sizeof(struct tee_ta_session));

// TEE_Malloc(sizeof(struct pseudo_ta_ctx), TEE_MALLOC_FILL_ZERO);
//   struct tee_ta_session *s = malloc(sizeof(struct tee_ta_session));
  struct tee_ta_session *s = TEE_Malloc(sizeof(struct tee_ta_session), TEE_MALLOC_FILL_ZERO);
  *err = TEE_ORIGIN_TEE;
  if (!s)
    return TEE_ERROR_OUT_OF_MEMORY;

  memset(s,0,sizeof(struct tee_ta_session));

//
//	s->cancel_mask = true;
//	condvar_init(&s->refc_cv);
//	condvar_init(&s->lock_cv);
//	s->lock_thread = THREAD_ID_INVALID;
//	s->ref_count = 1;
//
//
//	/*
//	 * We take the global TA mutex here and hold it while doing
//	 * RPC to load the TA. This big critical section should be broken
//	 * down into smaller pieces.
//	 */
//
//
//	mutex_lock(&tee_ta_mutex);
	TAILQ_INSERT_TAIL(open_sessions, s, link);

	/* Look for already loaded TA */
//	ctx = tee_ta_context_find(uuid);
//	if (ctx) {
//		res = tee_ta_init_session_with_context(ctx, s);
//		if (res == TEE_SUCCESS || res != TEE_ERROR_ITEM_NOT_FOUND)
//			goto out;
//	}

	/* Look for static TA */
	res = tee_ta_init_pseudo_ta_session(uuid, s);
	if (res == TEE_SUCCESS || res != TEE_ERROR_ITEM_NOT_FOUND)
		goto out;

	/* Look for user TA */
	res = tee_ta_init_user_ta_session(uuid, s);

out:
	if (res == TEE_SUCCESS) {
		*sess = s;
	} else {
		TAILQ_REMOVE(open_sessions, s, link);
		free(s);
	}
//	mutex_unlock(&tee_ta_mutex);
	return res;
}","static TEE_Result tee_ta_init_session(TEE_ErrorOrigin *VAR_0,
				struct tee_ta_session_head *VAR_1,
				const TEE_UUID *VAR_2,
				struct tee_ta_session **VAR_3)
{
	TEE_Result VAR_4;
/* COMMENT_0 */
/* COMMENT_1 */

/* COMMENT_2 */
/* COMMENT_3 */
  struct tee_ta_session *VAR_5 = TEE_Malloc(sizeof(struct tee_ta_session), VAR_6);
  *VAR_0 = VAR_7;
  if (!VAR_5)
    return VAR_8;

  memset(VAR_5,0,sizeof(struct tee_ta_session));

/* COMMENT_4 */
/* COMMENT_5 */
/* COMMENT_6 */
/* COMMENT_7 */
/* COMMENT_8 */
/* COMMENT_9 */
/* COMMENT_4 */
/* COMMENT_4 */
/* COMMENT_10 */
/* COMMENT_11 */
/* COMMENT_12 */
/* COMMENT_13 */
/* COMMENT_14 */
/* COMMENT_4 */
/* COMMENT_4 */
/* COMMENT_15 */
	TAILQ_INSERT_TAIL(VAR_1, VAR_5, VAR_9);

	/* COMMENT_16 */
/* COMMENT_17 */
/* COMMENT_18 */
/* COMMENT_19 */
/* COMMENT_20 */
/* COMMENT_21 */
/* COMMENT_22 */

	/* COMMENT_23 */
	VAR_4 = tee_ta_init_pseudo_ta_session(VAR_2, VAR_5);
	if (VAR_4 == VAR_10 || VAR_4 != VAR_11)
		goto out;

	/* COMMENT_24 */
	VAR_4 = tee_ta_init_user_ta_session(VAR_2, VAR_5);

out:
	if (VAR_4 == VAR_10) {
		*VAR_3 = VAR_5;
	} else {
		TAILQ_REMOVE(VAR_1, VAR_5, VAR_9);
		free(VAR_5);
	}
/* COMMENT_25 */
	return VAR_4;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_ta_manager.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,7 +6,10 @@
 	TEE_Result res;
 //	struct tee_ta_ctx *ctx;
 //  struct tee_ta_session *s = calloc(1, sizeof(struct tee_ta_session));
-  struct tee_ta_session *s = malloc(sizeof(struct tee_ta_session));
+
+// TEE_Malloc(sizeof(struct pseudo_ta_ctx), TEE_MALLOC_FILL_ZERO);
+//   struct tee_ta_session *s = malloc(sizeof(struct tee_ta_session));
+  struct tee_ta_session *s = TEE_Malloc(sizeof(struct tee_ta_session), TEE_MALLOC_FILL_ZERO);
   *err = TEE_ORIGIN_TEE;
   if (!s)
     return TEE_ERROR_OUT_OF_MEMORY;","{'deleted_lines': ['  struct tee_ta_session *s = malloc(sizeof(struct tee_ta_session));'], 'added_lines': ['', '// TEE_Malloc(sizeof(struct pseudo_ta_ctx), TEE_MALLOC_FILL_ZERO);', '//   struct tee_ta_session *s = malloc(sizeof(struct tee_ta_session));', '  struct tee_ta_session *s = TEE_Malloc(sizeof(struct tee_ta_session), TEE_MALLOC_FILL_ZERO);']}",True,"The function tee_obj_free in Samsung mTower through 0.3.0 allows a trusted application to trigger a Denial of Service (DoS) by invoking the function TEE_AllocateOperation with a disturbed heap layout, related to utee_cryp_obj_alloc.",7.5,HIGH,2,test,2022-11-24T19:37:56Z,4
CVE-2022-40761,['CWE-1284'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Samsung/mTower,"Fixed CVE-2022-40761

Signed-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,https://github.com/Samsung/mTower/commit/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,tee/tee/tee_obj.c,tee_obj_alloc,"struct tee_obj *tee_obj_alloc(void)
{
return calloc(1, sizeof(struct tee_obj));
}","struct tee_obj *tee_obj_alloc(void)
{
return calloc(1, sizeof(struct tee_obj));
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_obj.c/vul/before/0.json,"struct tee_obj *tee_obj_alloc(void)
{
	// return calloc(1, sizeof(struct tee_obj));
	return TEE_Malloc(sizeof(struct tee_obj), TEE_MALLOC_FILL_ZERO);
}","struct tee_obj *tee_obj_alloc(void)
{
	/* COMMENT_0 */
	return TEE_Malloc(sizeof(struct tee_obj), VAR_0);
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_obj.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,5 @@
 struct tee_obj *tee_obj_alloc(void)
 {
-	return calloc(1, sizeof(struct tee_obj));
+	// return calloc(1, sizeof(struct tee_obj));
+	return TEE_Malloc(sizeof(struct tee_obj), TEE_MALLOC_FILL_ZERO);
 }","{'deleted_lines': ['\treturn calloc(1, sizeof(struct tee_obj));'], 'added_lines': ['\t// return calloc(1, sizeof(struct tee_obj));', '\treturn TEE_Malloc(sizeof(struct tee_obj), TEE_MALLOC_FILL_ZERO);']}",True,"The function tee_obj_free in Samsung mTower through 0.3.0 allows a trusted application to trigger a Denial of Service (DoS) by invoking the function TEE_AllocateOperation with a disturbed heap layout, related to utee_cryp_obj_alloc.",7.5,HIGH,2,test,2022-11-24T19:37:56Z,4
CVE-2022-40761,['CWE-1284'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Samsung/mTower,"Fixed CVE-2022-40761

Signed-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,https://github.com/Samsung/mTower/commit/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,tee/tee/tee_svc_cryp.c,tee_obj_set_type,"TEE_Result tee_obj_set_type(struct tee_obj *o, uint32_t obj_type,
size_t max_key_size)
{
TEE_Result res = TEE_SUCCESS;
const struct tee_cryp_obj_type_props *type_props;
if (o->attr)
return TEE_ERROR_BAD_STATE;
if (obj_type == TEE_TYPE_DATA) {
if (max_key_size)
return TEE_ERROR_NOT_SUPPORTED;
} else {
type_props = tee_svc_find_type_props(obj_type);
if (!type_props)
return TEE_ERROR_NOT_SUPPORTED;
if (max_key_size % type_props->quanta != 0)
return TEE_ERROR_NOT_SUPPORTED;
if (max_key_size < type_props->min_size)
return TEE_ERROR_NOT_SUPPORTED;
if (max_key_size > type_props->max_size)
return TEE_ERROR_NOT_SUPPORTED;
o->attr = calloc(1, type_props->alloc_size);
if (!o->attr)
return TEE_ERROR_OUT_OF_MEMORY;
}
switch (obj_type) {
default:
if (obj_type != TEE_TYPE_DATA) {
struct tee_cryp_obj_secret *key = o->attr;
key->alloc_size = type_props->alloc_size -
sizeof(*key);
}
break;
}
if (res != TEE_SUCCESS)
return res;
o->info.objectType = obj_type;
o->info.maxKeySize = max_key_size;
o->info.objectUsage = TEE_USAGE_DEFAULT;
return TEE_SUCCESS;
}","TEE_Result tee_obj_set_type(struct tee_obj *VAR_0, uint32_t VAR_1,
size_t VAR_2)
{
TEE_Result VAR_3 = VAR_4;
const struct tee_cryp_obj_type_props *VAR_5;
if (VAR_0->attr)
return VAR_6;
if (VAR_1 == VAR_7) {
if (VAR_2)
return VAR_8;
} else {
VAR_5 = tee_svc_find_type_props(VAR_1);
if (!VAR_5)
return VAR_8;
if (VAR_2 % VAR_5->quanta != 0)
return VAR_8;
if (VAR_2 < VAR_5->min_size)
return VAR_8;
if (VAR_2 > VAR_5->max_size)
return VAR_8;
VAR_0->attr = calloc(1, VAR_5->alloc_size);
if (!VAR_0->attr)
return VAR_9;
}
switch (VAR_1) {
default:
if (VAR_1 != VAR_7) {
struct tee_cryp_obj_secret *VAR_10 = VAR_0->attr;
VAR_10->alloc_size = VAR_5->alloc_size -
sizeof(*VAR_10);
}
break;
}
if (VAR_3 != VAR_4)
return VAR_3;
VAR_0->info.objectType = VAR_1;
VAR_0->info.maxKeySize = VAR_2;
VAR_0->info.objectUsage = VAR_11;
return VAR_4;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_svc_cryp.c/vul/before/0.json,"TEE_Result tee_obj_set_type(struct tee_obj *o, uint32_t obj_type,
			    size_t max_key_size)
{
	TEE_Result res = TEE_SUCCESS;
	const struct tee_cryp_obj_type_props *type_props;

	/* Can only set type for newly allocated objs */
	if (o->attr)
		return TEE_ERROR_BAD_STATE;

	/*
	 * Verify that maxKeySize is supported and find out how
	 * much should be allocated.
	 */

	if (obj_type == TEE_TYPE_DATA) {
		if (max_key_size)
			return TEE_ERROR_NOT_SUPPORTED;
	} else {
		/* Find description of object */
		type_props = tee_svc_find_type_props(obj_type);
		if (!type_props)
			return TEE_ERROR_NOT_SUPPORTED;

		/* Check that maxKeySize follows restrictions */
		if (max_key_size % type_props->quanta != 0)
			return TEE_ERROR_NOT_SUPPORTED;
		if (max_key_size < type_props->min_size)
			return TEE_ERROR_NOT_SUPPORTED;
		if (max_key_size > type_props->max_size)
			return TEE_ERROR_NOT_SUPPORTED;

		o->attr = TEE_Malloc(type_props->alloc_size, TEE_MALLOC_FILL_ZERO);
		// o->attr = calloc(1, type_props->alloc_size);
		if (!o->attr)
			return TEE_ERROR_OUT_OF_MEMORY;
	}

	/* If we have a key structure, pre-allocate the bignums inside */
	switch (obj_type) {
//	case TEE_TYPE_RSA_PUBLIC_KEY:
//		res = crypto_acipher_alloc_rsa_public_key(o->attr,
//							  max_key_size);
//		break;
//	case TEE_TYPE_RSA_KEYPAIR:
//		res = crypto_acipher_alloc_rsa_keypair(o->attr, max_key_size);
//		break;
//	case TEE_TYPE_DSA_PUBLIC_KEY:
//		res = crypto_acipher_alloc_dsa_public_key(o->attr,
//							  max_key_size);
//		break;
//	case TEE_TYPE_DSA_KEYPAIR:
//		res = crypto_acipher_alloc_dsa_keypair(o->attr, max_key_size);
//		break;
//	case TEE_TYPE_DH_KEYPAIR:
//		res = crypto_acipher_alloc_dh_keypair(o->attr, max_key_size);
//		break;
//	case TEE_TYPE_ECDSA_PUBLIC_KEY:
//	case TEE_TYPE_ECDH_PUBLIC_KEY:
//		res = crypto_acipher_alloc_ecc_public_key(o->attr,
//							  max_key_size);
//		break;
//	case TEE_TYPE_ECDSA_KEYPAIR:
//	case TEE_TYPE_ECDH_KEYPAIR:
//		res = crypto_acipher_alloc_ecc_keypair(o->attr, max_key_size);
//		break;
	default:
		if (obj_type != TEE_TYPE_DATA) {
			struct tee_cryp_obj_secret *key = o->attr;

			key->alloc_size = type_props->alloc_size -
					  sizeof(*key);
		}
		break;
	}

	if (res != TEE_SUCCESS)
		return res;

	o->info.objectType = obj_type;
	o->info.maxKeySize = max_key_size;
	o->info.objectUsage = TEE_USAGE_DEFAULT;

	return TEE_SUCCESS;
}","TEE_Result tee_obj_set_type(struct tee_obj *VAR_0, uint32_t VAR_1,
			    size_t VAR_2)
{
	TEE_Result VAR_3 = VAR_4;
	const struct tee_cryp_obj_type_props *VAR_5;

	/* COMMENT_0 */
	if (VAR_0->attr)
		return VAR_6;

	/* COMMENT_1 */
                                                        
                             
    

	if (VAR_1 == VAR_7) {
		if (VAR_2)
			return VAR_8;
	} else {
		/* COMMENT_5 */
		VAR_5 = tee_svc_find_type_props(VAR_1);
		if (!VAR_5)
			return VAR_8;

		/* COMMENT_6 */
		if (VAR_2 % VAR_5->quanta != 0)
			return VAR_8;
		if (VAR_2 < VAR_5->min_size)
			return VAR_8;
		if (VAR_2 > VAR_5->max_size)
			return VAR_8;

		VAR_0->attr = TEE_Malloc(VAR_5->alloc_size, VAR_9);
		/* COMMENT_7 */
		if (!VAR_0->attr)
			return VAR_10;
	}

	/* COMMENT_8 */
	switch (VAR_1) {
/* COMMENT_9 */
/* COMMENT_10 */
/* COMMENT_11 */
/* COMMENT_12 */
/* COMMENT_13 */
/* COMMENT_14 */
/* COMMENT_12 */
/* COMMENT_15 */
/* COMMENT_16 */
/* COMMENT_11 */
/* COMMENT_12 */
/* COMMENT_17 */
/* COMMENT_18 */
/* COMMENT_12 */
/* COMMENT_19 */
/* COMMENT_20 */
/* COMMENT_12 */
/* COMMENT_21 */
/* COMMENT_22 */
/* COMMENT_23 */
/* COMMENT_11 */
/* COMMENT_12 */
/* COMMENT_24 */
/* COMMENT_25 */
/* COMMENT_26 */
/* COMMENT_12 */
	default:
		if (VAR_1 != VAR_7) {
			struct tee_cryp_obj_secret *VAR_11 = VAR_0->attr;

			VAR_11->alloc_size = VAR_5->alloc_size -
					  sizeof(*VAR_11);
		}
		break;
	}

	if (VAR_3 != VAR_4)
		return VAR_3;

	VAR_0->info.objectType = VAR_1;
	VAR_0->info.maxKeySize = VAR_2;
	VAR_0->info.objectUsage = VAR_12;

	return VAR_4;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_svc_cryp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -30,7 +30,8 @@
 		if (max_key_size > type_props->max_size)
 			return TEE_ERROR_NOT_SUPPORTED;
 
-		o->attr = calloc(1, type_props->alloc_size);
+		o->attr = TEE_Malloc(type_props->alloc_size, TEE_MALLOC_FILL_ZERO);
+		// o->attr = calloc(1, type_props->alloc_size);
 		if (!o->attr)
 			return TEE_ERROR_OUT_OF_MEMORY;
 	}","{'deleted_lines': ['\t\to->attr = calloc(1, type_props->alloc_size);'], 'added_lines': ['\t\to->attr = TEE_Malloc(type_props->alloc_size, TEE_MALLOC_FILL_ZERO);', '\t\t// o->attr = calloc(1, type_props->alloc_size);']}",True,"The function tee_obj_free in Samsung mTower through 0.3.0 allows a trusted application to trigger a Denial of Service (DoS) by invoking the function TEE_AllocateOperation with a disturbed heap layout, related to utee_cryp_obj_alloc.",7.5,HIGH,2,test,2022-11-24T19:37:56Z,4
CVE-2022-40761,['CWE-1284'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Samsung/mTower,"Fixed CVE-2022-40761

Signed-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,https://github.com/Samsung/mTower/commit/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,tee/tee/tee_svc_cryp.c,utee_cryp_state_alloc,"TEE_Result utee_cryp_state_alloc(unsigned long algo, unsigned long mode,
unsigned long key1, unsigned long key2,
uint32_t *state)
{
TEE_Result res;
struct tee_cryp_state *cs;
struct tee_ta_session *sess;
struct tee_obj *o1 = NULL;
struct tee_obj *o2 = NULL;
struct user_ta_ctx *utc;
res = tee_ta_get_current_session(&sess);
if (res != TEE_SUCCESS)
return res;
utc = to_user_ta_ctx(sess->ctx);
if (key1 != 0) {
res = tee_obj_get(utc, tee_svc_uref_to_vaddr(key1), &o1);
if (res != TEE_SUCCESS)
return res;
if (o1->busy)
return TEE_ERROR_BAD_PARAMETERS;
res = tee_svc_cryp_check_key_type(o1, algo, mode);
if (res != TEE_SUCCESS)
return res;
}
if (key2 != 0) {
res = tee_obj_get(utc, tee_svc_uref_to_vaddr(key2), &o2);
if (res != TEE_SUCCESS)
return res;
if (o2->busy)
return TEE_ERROR_BAD_PARAMETERS;
res = tee_svc_cryp_check_key_type(o2, algo, mode);
if (res != TEE_SUCCESS)
return res;
}
cs = calloc(1, sizeof(struct tee_cryp_state));
if (!cs)
return TEE_ERROR_OUT_OF_MEMORY;
TAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);
cs->algo = algo;
cs->mode = mode;
switch (TEE_ALG_GET_CLASS(algo)) {
case TEE_OPERATION_CIPHER:
if ((algo == TEE_ALG_AES_XTS && (key1 == 0 || key2 == 0)) ||
(algo != TEE_ALG_AES_XTS && (key1 == 0 || key2 != 0))) {
res = TEE_ERROR_BAD_PARAMETERS;
} else {
res = crypto_cipher_alloc_ctx(&cs->ctx, algo);
if (res != TEE_SUCCESS)
break;
}
break;
case TEE_OPERATION_AE:
if (key1 == 0 || key2 != 0) {
res = TEE_ERROR_BAD_PARAMETERS;
} else {
}
break;
case TEE_OPERATION_MAC:
if (key1 == 0 || key2 != 0) {
res = TEE_ERROR_BAD_PARAMETERS;
} else {
res = crypto_mac_alloc_ctx(&cs->ctx, algo);
if (res != TEE_SUCCESS)
break;
}
break;
case TEE_OPERATION_DIGEST:
if (key1 != 0 || key2 != 0) {
res = TEE_ERROR_BAD_PARAMETERS;
} else {
res = crypto_hash_alloc_ctx(&cs->ctx, algo);
if (res != TEE_SUCCESS)
break;
}
break;
case TEE_OPERATION_ASYMMETRIC_CIPHER:
case TEE_OPERATION_ASYMMETRIC_SIGNATURE:
if (key1 == 0 || key2 != 0)
res = TEE_ERROR_BAD_PARAMETERS;
break;
case TEE_OPERATION_KEY_DERIVATION:
if (key1 == 0 || key2 != 0)
res = TEE_ERROR_BAD_PARAMETERS;
break;
default:
res = TEE_ERROR_NOT_SUPPORTED;
break;
}
if (res != TEE_SUCCESS)
goto out;
res = tee_svc_copy_kaddr_to_uref(state, cs);
if (res != TEE_SUCCESS)
goto out;
if (o1 != NULL) {
o1->busy = true;
cs->key1 = (vaddr_t)o1;
}
if (o2 != NULL) {
o2->busy = true;
cs->key2 = (vaddr_t)o2;
}
out:
if (res != TEE_SUCCESS)
cryp_state_free(utc, cs);
return res;
}","TEE_Result utee_cryp_state_alloc(unsigned long VAR_0, unsigned long VAR_1,
unsigned long VAR_2, unsigned long VAR_3,
uint32_t *VAR_4)
{
TEE_Result VAR_5;
struct tee_cryp_state *VAR_6;
struct tee_ta_session *VAR_7;
struct tee_obj *VAR_8 = NULL;
struct tee_obj *VAR_9 = NULL;
struct user_ta_ctx *VAR_10;
VAR_5 = tee_ta_get_current_session(&VAR_7);
if (VAR_5 != VAR_11)
return VAR_5;
VAR_10 = to_user_ta_ctx(VAR_7->ctx);
if (VAR_2 != 0) {
VAR_5 = tee_obj_get(VAR_10, tee_svc_uref_to_vaddr(VAR_2), &VAR_8);
if (VAR_5 != VAR_11)
return VAR_5;
if (VAR_8->busy)
return VAR_12;
VAR_5 = tee_svc_cryp_check_key_type(VAR_8, VAR_0, VAR_1);
if (VAR_5 != VAR_11)
return VAR_5;
}
if (VAR_3 != 0) {
VAR_5 = tee_obj_get(VAR_10, tee_svc_uref_to_vaddr(VAR_3), &VAR_9);
if (VAR_5 != VAR_11)
return VAR_5;
if (VAR_9->busy)
return VAR_12;
VAR_5 = tee_svc_cryp_check_key_type(VAR_9, VAR_0, VAR_1);
if (VAR_5 != VAR_11)
return VAR_5;
}
VAR_6 = calloc(1, sizeof(struct tee_cryp_state));
if (!VAR_6)
return VAR_13;
TAILQ_INSERT_TAIL(&VAR_10->cryp_states, VAR_6, VAR_14);
VAR_6->algo = VAR_0;
VAR_6->mode = VAR_1;
switch (TEE_ALG_GET_CLASS(VAR_0)) {
case VAR_15:
if ((VAR_0 == VAR_16 && (VAR_2 == 0 || VAR_3 == 0)) ||
(VAR_0 != VAR_16 && (VAR_2 == 0 || VAR_3 != 0))) {
VAR_5 = VAR_12;
} else {
VAR_5 = crypto_cipher_alloc_ctx(&VAR_6->ctx, VAR_0);
if (VAR_5 != VAR_11)
break;
}
break;
case VAR_17:
if (VAR_2 == 0 || VAR_3 != 0) {
VAR_5 = VAR_12;
} else {
}
break;
case VAR_18:
if (VAR_2 == 0 || VAR_3 != 0) {
VAR_5 = VAR_12;
} else {
VAR_5 = crypto_mac_alloc_ctx(&VAR_6->ctx, VAR_0);
if (VAR_5 != VAR_11)
break;
}
break;
case VAR_19:
if (VAR_2 != 0 || VAR_3 != 0) {
VAR_5 = VAR_12;
} else {
VAR_5 = crypto_hash_alloc_ctx(&VAR_6->ctx, VAR_0);
if (VAR_5 != VAR_11)
break;
}
break;
case VAR_20:
case VAR_21:
if (VAR_2 == 0 || VAR_3 != 0)
VAR_5 = VAR_12;
break;
case VAR_22:
if (VAR_2 == 0 || VAR_3 != 0)
VAR_5 = VAR_12;
break;
default:
VAR_5 = VAR_23;
break;
}
if (VAR_5 != VAR_11)
goto out;
VAR_5 = tee_svc_copy_kaddr_to_uref(VAR_4, VAR_6);
if (VAR_5 != VAR_11)
goto out;
if (VAR_8 != NULL) {
VAR_8->busy = true;
VAR_6->key1 = (vaddr_t)VAR_8;
}
if (VAR_9 != NULL) {
VAR_9->busy = true;
VAR_6->key2 = (vaddr_t)VAR_9;
}
out:
if (VAR_5 != VAR_11)
cryp_state_free(VAR_10, VAR_6);
return VAR_5;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_svc_cryp.c/vul/before/1.json,"TEE_Result utee_cryp_state_alloc(unsigned long algo, unsigned long mode,
			unsigned long key1, unsigned long key2,
			uint32_t *state)
{
	TEE_Result res;
	struct tee_cryp_state *cs;
	struct tee_ta_session *sess;
	struct tee_obj *o1 = NULL;
	struct tee_obj *o2 = NULL;
	struct user_ta_ctx *utc;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;
	utc = to_user_ta_ctx(sess->ctx);

	if (key1 != 0) {
		res = tee_obj_get(utc, tee_svc_uref_to_vaddr(key1), &o1);
		if (res != TEE_SUCCESS)
			return res;
		if (o1->busy)
			return TEE_ERROR_BAD_PARAMETERS;
		res = tee_svc_cryp_check_key_type(o1, algo, mode);
		if (res != TEE_SUCCESS)
			return res;
	}
	if (key2 != 0) {
		res = tee_obj_get(utc, tee_svc_uref_to_vaddr(key2), &o2);
		if (res != TEE_SUCCESS)
			return res;
		if (o2->busy)
			return TEE_ERROR_BAD_PARAMETERS;
		res = tee_svc_cryp_check_key_type(o2, algo, mode);
		if (res != TEE_SUCCESS)
			return res;
	}

	cs = TEE_Malloc(sizeof(struct tee_cryp_state), TEE_MALLOC_FILL_ZERO);
	// cs = calloc(1, sizeof(struct tee_cryp_state));
	if (!cs)
		return TEE_ERROR_OUT_OF_MEMORY;
	TAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);
	cs->algo = algo;
	cs->mode = mode;

	switch (TEE_ALG_GET_CLASS(algo)) {
	case TEE_OPERATION_CIPHER:
		if ((algo == TEE_ALG_AES_XTS && (key1 == 0 || key2 == 0)) ||
		    (algo != TEE_ALG_AES_XTS && (key1 == 0 || key2 != 0))) {
			res = TEE_ERROR_BAD_PARAMETERS;
		} else {
			res = crypto_cipher_alloc_ctx(&cs->ctx, algo);
			if (res != TEE_SUCCESS)
				break;
		}
		break;
	case TEE_OPERATION_AE:
		if (key1 == 0 || key2 != 0) {
			res = TEE_ERROR_BAD_PARAMETERS;
		} else {
//			res = crypto_authenc_alloc_ctx(&cs->ctx, algo);
//			if (res != TEE_SUCCESS)
//				break;
		}
		break;
	case TEE_OPERATION_MAC:
		if (key1 == 0 || key2 != 0) {
			res = TEE_ERROR_BAD_PARAMETERS;
		} else {
			res = crypto_mac_alloc_ctx(&cs->ctx, algo);
			if (res != TEE_SUCCESS)
				break;
		}
		break;
	case TEE_OPERATION_DIGEST:
		if (key1 != 0 || key2 != 0) {
			res = TEE_ERROR_BAD_PARAMETERS;
		} else {
			res = crypto_hash_alloc_ctx(&cs->ctx, algo);
			if (res != TEE_SUCCESS)
				break;
		}
		break;
	case TEE_OPERATION_ASYMMETRIC_CIPHER:
	case TEE_OPERATION_ASYMMETRIC_SIGNATURE:
		if (key1 == 0 || key2 != 0)
			res = TEE_ERROR_BAD_PARAMETERS;
		break;
	case TEE_OPERATION_KEY_DERIVATION:
		if (key1 == 0 || key2 != 0)
			res = TEE_ERROR_BAD_PARAMETERS;
		break;
	default:
		res = TEE_ERROR_NOT_SUPPORTED;
		break;
	}
	if (res != TEE_SUCCESS)
		goto out;

	res = tee_svc_copy_kaddr_to_uref(state, cs);
	if (res != TEE_SUCCESS)
		goto out;

	/* Register keys */
	if (o1 != NULL) {
		o1->busy = true;
		cs->key1 = (vaddr_t)o1;
	}
	if (o2 != NULL) {
		o2->busy = true;
		cs->key2 = (vaddr_t)o2;
	}

out:
	if (res != TEE_SUCCESS)
		cryp_state_free(utc, cs);
	return res;
}","TEE_Result utee_cryp_state_alloc(unsigned long VAR_0, unsigned long VAR_1,
			unsigned long VAR_2, unsigned long VAR_3,
			uint32_t *VAR_4)
{
	TEE_Result VAR_5;
	struct tee_cryp_state *VAR_6;
	struct tee_ta_session *VAR_7;
	struct tee_obj *VAR_8 = NULL;
	struct tee_obj *VAR_9 = NULL;
	struct user_ta_ctx *VAR_10;

	VAR_5 = tee_ta_get_current_session(&VAR_7);
	if (VAR_5 != VAR_11)
		return VAR_5;
	VAR_10 = to_user_ta_ctx(VAR_7->ctx);

	if (VAR_2 != 0) {
		VAR_5 = tee_obj_get(VAR_10, tee_svc_uref_to_vaddr(VAR_2), &VAR_8);
		if (VAR_5 != VAR_11)
			return VAR_5;
		if (VAR_8->busy)
			return VAR_12;
		VAR_5 = tee_svc_cryp_check_key_type(VAR_8, VAR_0, VAR_1);
		if (VAR_5 != VAR_11)
			return VAR_5;
	}
	if (VAR_3 != 0) {
		VAR_5 = tee_obj_get(VAR_10, tee_svc_uref_to_vaddr(VAR_3), &VAR_9);
		if (VAR_5 != VAR_11)
			return VAR_5;
		if (VAR_9->busy)
			return VAR_12;
		VAR_5 = tee_svc_cryp_check_key_type(VAR_9, VAR_0, VAR_1);
		if (VAR_5 != VAR_11)
			return VAR_5;
	}

	VAR_6 = TEE_Malloc(sizeof(struct tee_cryp_state), VAR_13);
	/* COMMENT_0 */
	if (!VAR_6)
		return VAR_14;
	TAILQ_INSERT_TAIL(&VAR_10->cryp_states, VAR_6, VAR_15);
	VAR_6->algo = VAR_0;
	VAR_6->mode = VAR_1;

	switch (TEE_ALG_GET_CLASS(VAR_0)) {
	case VAR_16:
		if ((VAR_0 == VAR_17 && (VAR_2 == 0 || VAR_3 == 0)) ||
		    (VAR_0 != VAR_17 && (VAR_2 == 0 || VAR_3 != 0))) {
			VAR_5 = VAR_12;
		} else {
			VAR_5 = crypto_cipher_alloc_ctx(&VAR_6->ctx, VAR_0);
			if (VAR_5 != VAR_11)
				break;
		}
		break;
	case VAR_18:
		if (VAR_2 == 0 || VAR_3 != 0) {
			VAR_5 = VAR_12;
		} else {
/* COMMENT_1 */
/* COMMENT_2 */
/* COMMENT_3 */
		}
		break;
	case VAR_19:
		if (VAR_2 == 0 || VAR_3 != 0) {
			VAR_5 = VAR_12;
		} else {
			VAR_5 = crypto_mac_alloc_ctx(&VAR_6->ctx, VAR_0);
			if (VAR_5 != VAR_11)
				break;
		}
		break;
	case VAR_20:
		if (VAR_2 != 0 || VAR_3 != 0) {
			VAR_5 = VAR_12;
		} else {
			VAR_5 = crypto_hash_alloc_ctx(&VAR_6->ctx, VAR_0);
			if (VAR_5 != VAR_11)
				break;
		}
		break;
	case VAR_21:
	case VAR_22:
		if (VAR_2 == 0 || VAR_3 != 0)
			VAR_5 = VAR_12;
		break;
	case VAR_23:
		if (VAR_2 == 0 || VAR_3 != 0)
			VAR_5 = VAR_12;
		break;
	default:
		VAR_5 = VAR_24;
		break;
	}
	if (VAR_5 != VAR_11)
		goto out;

	VAR_5 = tee_svc_copy_kaddr_to_uref(VAR_4, VAR_6);
	if (VAR_5 != VAR_11)
		goto out;

	/* COMMENT_4 */
	if (VAR_8 != NULL) {
		VAR_8->busy = true;
		VAR_6->key1 = (vaddr_t)VAR_8;
	}
	if (VAR_9 != NULL) {
		VAR_9->busy = true;
		VAR_6->key2 = (vaddr_t)VAR_9;
	}

out:
	if (VAR_5 != VAR_11)
		cryp_state_free(VAR_10, VAR_6);
	return VAR_5;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_svc_cryp.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -35,7 +35,8 @@
 			return res;
 	}
 
-	cs = calloc(1, sizeof(struct tee_cryp_state));
+	cs = TEE_Malloc(sizeof(struct tee_cryp_state), TEE_MALLOC_FILL_ZERO);
+	// cs = calloc(1, sizeof(struct tee_cryp_state));
 	if (!cs)
 		return TEE_ERROR_OUT_OF_MEMORY;
 	TAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);","{'deleted_lines': ['\tcs = calloc(1, sizeof(struct tee_cryp_state));'], 'added_lines': ['\tcs = TEE_Malloc(sizeof(struct tee_cryp_state), TEE_MALLOC_FILL_ZERO);', '\t// cs = calloc(1, sizeof(struct tee_cryp_state));']}",True,"The function tee_obj_free in Samsung mTower through 0.3.0 allows a trusted application to trigger a Denial of Service (DoS) by invoking the function TEE_AllocateOperation with a disturbed heap layout, related to utee_cryp_obj_alloc.",7.5,HIGH,2,test,2022-11-24T19:37:56Z,4
CVE-2022-40761,['CWE-1284'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Samsung/mTower,"Fixed CVE-2022-40761

Signed-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,https://github.com/Samsung/mTower/commit/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,tee/kernel/user_ta.c,tee_ta_init_user_ta_session,"TEE_Result tee_ta_init_user_ta_session(const TEE_UUID *uuid,
struct tee_ta_session *s)
{
TEE_Result res;
struct user_ta_ctx *utc = NULL;
struct user_ta_head *ta_head;
DMSG(""Lookup user TA %pUl"", (void *)uuid);
ta_head = (struct user_ta_head *)&__start_user_ta_head_section;
while (true) {
if (ta_head >= &__stop_user_ta_head_section)
return TEE_ERROR_ITEM_NOT_FOUND;
if (memcmp(&ta_head->uuid, uuid, sizeof(TEE_UUID)) == 0)
break;
ta_head++;
}
DMSG(""Open %s"", ta_head->name);
utc = calloc(1, sizeof(struct user_ta_ctx));
if (!utc) {
res = TEE_ERROR_OUT_OF_MEMORY;
goto error_return;
}
TAILQ_INIT(&utc->open_sessions);
TAILQ_INIT(&utc->cryp_states);
TAILQ_INIT(&utc->objects);
s->ctx = &utc->ctx;
utc->ctx.flags = ta_head->flags;
utc->ctx.uuid = ta_head->uuid;
utc->user_ta = ta_head;
utc->ctx.ops = &user_ta_ops;
TAILQ_INSERT_TAIL(&tee_ctxes, &utc->ctx, link);
DMSG(""Context was successfully inserted!"");
return TEE_SUCCESS;
error_return:
return res;
}","TEE_Result tee_ta_init_user_ta_session(const TEE_UUID *VAR_0,
struct tee_ta_session *VAR_1)
{
TEE_Result VAR_2;
struct user_ta_ctx *VAR_3 = NULL;
struct user_ta_head *VAR_4;
DMSG(""Lookup user TA %pUl"", (void *)VAR_0);
VAR_4 = (struct user_ta_head *)&VAR_5;
while (true) {
if (VAR_4 >= &VAR_6)
return VAR_7;
if (memcmp(&VAR_4->uuid, VAR_0, sizeof(TEE_UUID)) == 0)
break;
VAR_4++;
}
DMSG(""Open %s"", VAR_4->name);
VAR_3 = calloc(1, sizeof(struct user_ta_ctx));
if (!VAR_3) {
VAR_2 = VAR_8;
goto error_return;
}
TAILQ_INIT(&VAR_3->open_sessions);
TAILQ_INIT(&VAR_3->cryp_states);
TAILQ_INIT(&VAR_3->objects);
VAR_1->ctx = &VAR_3->ctx;
VAR_3->ctx.flags = VAR_4->flags;
VAR_3->ctx.uuid = VAR_4->uuid;
VAR_3->user_ta = VAR_4;
VAR_3->ctx.ops = &VAR_9;
TAILQ_INSERT_TAIL(&VAR_10, &VAR_3->ctx, VAR_11);
DMSG(""Context was successfully inserted!"");
return VAR_12;
error_return:
return VAR_2;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/user_ta.c/vul/before/0.json,"TEE_Result tee_ta_init_user_ta_session(const TEE_UUID *uuid,
			struct tee_ta_session *s)
{
//	const struct user_ta_store_ops *store;
	TEE_Result res;

  struct user_ta_ctx *utc = NULL;
  struct user_ta_head *ta_head;
//  struct user_ta_store_handle *ta_handle = NULL;

//  res = ta_store->open(uuid, &ta_handle);
//  if (res != TEE_SUCCESS)
//    return res;

  DMSG(""Lookup user TA %pUl"", (void *)uuid);

  ta_head = (struct user_ta_head *)&__start_user_ta_head_section;
  while (true) {
    if (ta_head >= &__stop_user_ta_head_section)
      return TEE_ERROR_ITEM_NOT_FOUND;

//    uuid_print(&ta_head->uuid);
//    uuid_print(uuid);

    if (memcmp(&ta_head->uuid, uuid, sizeof(TEE_UUID)) == 0)
      break;
    ta_head++;
  }

  /* Load a new TA and create a session */
  DMSG(""Open %s"", ta_head->name);

  /* Register context */
  // utc = calloc(1, sizeof(struct user_ta_ctx));
  utc = TEE_Malloc(sizeof(struct user_ta_ctx), TEE_MALLOC_FILL_ZERO);
  if (!utc) {
    res = TEE_ERROR_OUT_OF_MEMORY;
    goto error_return;
  }

  TAILQ_INIT(&utc->open_sessions);
  TAILQ_INIT(&utc->cryp_states);
  TAILQ_INIT(&utc->objects);
  //TAILQ_INIT(&utc->storage_enums);
  s->ctx = &utc->ctx;

  utc->ctx.flags = ta_head->flags;
  utc->ctx.uuid = ta_head->uuid;
  utc->user_ta = ta_head;
//  utc->entry_func = ta_head->entry.ptr64;
  utc->ctx.ops = &user_ta_ops;

  TAILQ_INSERT_TAIL(&tee_ctxes, &utc->ctx, link);

  DMSG(""Context was successfully inserted!"");

  return TEE_SUCCESS;

//  DMSG(""%s : %pUl"", stc->pseudo_ta->name, (void *)&ctx->uuid);

//	SLIST_FOREACH(store, &uta_store_list, link) {
//		DMSG(""Lookup user TA %pUl (%s)"", (void *)uuid,
//		     store->description);
//		res = ta_load(uuid, store, &s->ctx);
//		if (res == TEE_ERROR_ITEM_NOT_FOUND)
//			continue;
//		if (res == TEE_SUCCESS)
//			s->ctx->ops = &user_ta_ops;
//		else
//			DMSG(""res=0x%x"", res);
//		return res;
//	}
error_return:
	return res;
}","TEE_Result tee_ta_init_user_ta_session(const TEE_UUID *VAR_0,
			struct tee_ta_session *VAR_1)
{
/* COMMENT_0 */
	TEE_Result VAR_2;

  struct user_ta_ctx *VAR_3 = NULL;
  struct user_ta_head *VAR_4;
/* COMMENT_1 */

/* COMMENT_2 */
/* COMMENT_3 */
/* COMMENT_4 */

  DMSG(""Lookup user TA %pUl"", (void *)VAR_0);

  VAR_4 = (struct user_ta_head *)&VAR_5;
  while (true) {
    if (VAR_4 >= &VAR_6)
      return VAR_7;

/* COMMENT_5 */
/* COMMENT_6 */

    if (memcmp(&VAR_4->uuid, VAR_0, sizeof(TEE_UUID)) == 0)
      break;
    VAR_4++;
  }

  /* COMMENT_7 */
  DMSG(""Open %s"", VAR_4->name);

  /* COMMENT_8 */
  /* COMMENT_9 */
  VAR_3 = TEE_Malloc(sizeof(struct user_ta_ctx), VAR_8);
  if (!VAR_3) {
    VAR_2 = VAR_9;
    goto error_return;
  }

  TAILQ_INIT(&VAR_3->open_sessions);
  TAILQ_INIT(&VAR_3->cryp_states);
  TAILQ_INIT(&VAR_3->objects);
  /* COMMENT_10 */
  VAR_1->ctx = &VAR_3->ctx;

  VAR_3->ctx.flags = VAR_4->flags;
  VAR_3->ctx.uuid = VAR_4->uuid;
  VAR_3->user_ta = VAR_4;
/* COMMENT_11 */
  VAR_3->ctx.ops = &VAR_10;

  TAILQ_INSERT_TAIL(&VAR_11, &VAR_3->ctx, VAR_12);

  DMSG(""Context was successfully inserted!"");

  return VAR_13;

/* COMMENT_12 */

/* COMMENT_13 */
/* COMMENT_14 */
/* COMMENT_15 */
/* COMMENT_16 */
/* COMMENT_17 */
/* COMMENT_18 */
/* COMMENT_19 */
/* COMMENT_20 */
/* COMMENT_21 */
/* COMMENT_22 */
/* COMMENT_23 */
/* COMMENT_24 */
error_return:
	return VAR_2;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/user_ta.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -31,7 +31,8 @@
   DMSG(""Open %s"", ta_head->name);
 
   /* Register context */
-  utc = calloc(1, sizeof(struct user_ta_ctx));
+  // utc = calloc(1, sizeof(struct user_ta_ctx));
+  utc = TEE_Malloc(sizeof(struct user_ta_ctx), TEE_MALLOC_FILL_ZERO);
   if (!utc) {
     res = TEE_ERROR_OUT_OF_MEMORY;
     goto error_return;","{'deleted_lines': ['  utc = calloc(1, sizeof(struct user_ta_ctx));'], 'added_lines': ['  // utc = calloc(1, sizeof(struct user_ta_ctx));', '  utc = TEE_Malloc(sizeof(struct user_ta_ctx), TEE_MALLOC_FILL_ZERO);']}",True,"The function tee_obj_free in Samsung mTower through 0.3.0 allows a trusted application to trigger a Denial of Service (DoS) by invoking the function TEE_AllocateOperation with a disturbed heap layout, related to utee_cryp_obj_alloc.",7.5,HIGH,2,test,2022-11-24T19:37:56Z,4
CVE-2022-40761,['CWE-1284'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Samsung/mTower,"Fixed CVE-2022-40761

Signed-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,https://github.com/Samsung/mTower/commit/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,crypto/libtomcrypt/src/tee_ltc_provider.c,crypto_aes_ccm_alloc_ctx,"TEE_Result crypto_aes_ccm_alloc_ctx(void **ctx_ret)
{
struct tee_ccm_state *ctx = calloc(1, sizeof(*ctx));
if (!ctx)
return TEE_ERROR_OUT_OF_MEMORY;
*ctx_ret = ctx;
return TEE_SUCCESS;
}","TEE_Result crypto_aes_ccm_alloc_ctx(void **VAR_0)
{
struct tee_ccm_state *VAR_1 = calloc(1, sizeof(*VAR_1));
if (!VAR_1)
return VAR_2;
*VAR_0 = VAR_1;
return VAR_3;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_ltc_provider.c/vul/before/0.json,"TEE_Result crypto_aes_ccm_alloc_ctx(void **ctx_ret)
{
	struct tee_ccm_state *ctx = TEE_Malloc(sizeof(*ctx), TEE_MALLOC_FILL_ZERO);
	// struct tee_ccm_state *ctx = calloc(1, sizeof(*ctx));

	if (!ctx)
		return TEE_ERROR_OUT_OF_MEMORY;

	*ctx_ret = ctx;
	return TEE_SUCCESS;
}","TEE_Result crypto_aes_ccm_alloc_ctx(void **VAR_0)
{
	struct tee_ccm_state *VAR_1 = TEE_Malloc(sizeof(*VAR_1), VAR_2);
	/* COMMENT_0 */

	if (!VAR_1)
		return VAR_3;

	*VAR_0 = VAR_1;
	return VAR_4;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_ltc_provider.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,7 @@
 TEE_Result crypto_aes_ccm_alloc_ctx(void **ctx_ret)
 {
-	struct tee_ccm_state *ctx = calloc(1, sizeof(*ctx));
+	struct tee_ccm_state *ctx = TEE_Malloc(sizeof(*ctx), TEE_MALLOC_FILL_ZERO);
+	// struct tee_ccm_state *ctx = calloc(1, sizeof(*ctx));
 
 	if (!ctx)
 		return TEE_ERROR_OUT_OF_MEMORY;","{'deleted_lines': ['\tstruct tee_ccm_state *ctx = calloc(1, sizeof(*ctx));'], 'added_lines': ['\tstruct tee_ccm_state *ctx = TEE_Malloc(sizeof(*ctx), TEE_MALLOC_FILL_ZERO);', '\t// struct tee_ccm_state *ctx = calloc(1, sizeof(*ctx));']}",True,"The function tee_obj_free in Samsung mTower through 0.3.0 allows a trusted application to trigger a Denial of Service (DoS) by invoking the function TEE_AllocateOperation with a disturbed heap layout, related to utee_cryp_obj_alloc.",7.5,HIGH,2,test,2022-11-24T19:37:56Z,4
CVE-2022-40761,['CWE-1284'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Samsung/mTower,"Fixed CVE-2022-40761

Signed-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,https://github.com/Samsung/mTower/commit/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,crypto/libtomcrypt/src/tee_ltc_provider.c,crypto_hash_alloc_ctx,"TEE_Result crypto_hash_alloc_ctx(void **ctx_ret, uint32_t algo)
{
TEE_Result res;
size_t ctx_size;
void *ctx;
res = hash_get_ctx_size(algo, &ctx_size);
if (res)
return res;
ctx = calloc(1, ctx_size);
if (!ctx)
return TEE_ERROR_OUT_OF_MEMORY;
*ctx_ret = ctx;
return TEE_SUCCESS;
}","TEE_Result crypto_hash_alloc_ctx(void **VAR_0, uint32_t VAR_1)
{
TEE_Result VAR_2;
size_t VAR_3;
void *VAR_4;
VAR_2 = hash_get_ctx_size(VAR_1, &VAR_3);
if (VAR_2)
return VAR_2;
VAR_4 = calloc(1, VAR_3);
if (!VAR_4)
return VAR_5;
*VAR_0 = VAR_4;
return VAR_6;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_ltc_provider.c/vul/before/1.json,"TEE_Result crypto_hash_alloc_ctx(void **ctx_ret, uint32_t algo)
{
	TEE_Result res;
	size_t ctx_size;
	void *ctx;

	res = hash_get_ctx_size(algo, &ctx_size);
	if (res)
		return res;

	ctx = TEE_Malloc(ctx_size, TEE_MALLOC_FILL_ZERO);
	// ctx = calloc(1, ctx_size);
	if (!ctx)
		return TEE_ERROR_OUT_OF_MEMORY;

	*ctx_ret = ctx;
	return TEE_SUCCESS;
}","TEE_Result crypto_hash_alloc_ctx(void **VAR_0, uint32_t VAR_1)
{
	TEE_Result VAR_2;
	size_t VAR_3;
	void *VAR_4;

	VAR_2 = hash_get_ctx_size(VAR_1, &VAR_3);
	if (VAR_2)
		return VAR_2;

	VAR_4 = TEE_Malloc(VAR_3, VAR_5);
	/* COMMENT_0 */
	if (!VAR_4)
		return VAR_6;

	*VAR_0 = VAR_4;
	return VAR_7;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_ltc_provider.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -8,7 +8,8 @@
 	if (res)
 		return res;
 
-	ctx = calloc(1, ctx_size);
+	ctx = TEE_Malloc(ctx_size, TEE_MALLOC_FILL_ZERO);
+	// ctx = calloc(1, ctx_size);
 	if (!ctx)
 		return TEE_ERROR_OUT_OF_MEMORY;
 ","{'deleted_lines': ['\tctx = calloc(1, ctx_size);'], 'added_lines': ['\tctx = TEE_Malloc(ctx_size, TEE_MALLOC_FILL_ZERO);', '\t// ctx = calloc(1, ctx_size);']}",True,"The function tee_obj_free in Samsung mTower through 0.3.0 allows a trusted application to trigger a Denial of Service (DoS) by invoking the function TEE_AllocateOperation with a disturbed heap layout, related to utee_cryp_obj_alloc.",7.5,HIGH,2,test,2022-11-24T19:37:56Z,4
CVE-2022-40761,['CWE-1284'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Samsung/mTower,"Fixed CVE-2022-40761

Signed-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,https://github.com/Samsung/mTower/commit/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,crypto/libtomcrypt/src/tee_ltc_provider.c,crypto_aes_gcm_alloc_ctx,"TEE_Result crypto_aes_gcm_alloc_ctx(void **ctx_ret)
{
struct tee_gcm_state *ctx = calloc(1, sizeof(*ctx));
if (!ctx)
return TEE_ERROR_OUT_OF_MEMORY;
*ctx_ret = ctx;
return TEE_SUCCESS;
}","TEE_Result crypto_aes_gcm_alloc_ctx(void **VAR_0)
{
struct tee_gcm_state *VAR_1 = calloc(1, sizeof(*VAR_1));
if (!VAR_1)
return VAR_2;
*VAR_0 = VAR_1;
return VAR_3;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_ltc_provider.c/vul/before/2.json,"TEE_Result crypto_aes_gcm_alloc_ctx(void **ctx_ret)
{
	struct tee_gcm_state *ctx =  TEE_Malloc(sizeof(*ctx), TEE_MALLOC_FILL_ZERO);
	// struct tee_gcm_state *ctx = calloc(1, sizeof(*ctx));

	if (!ctx)
		return TEE_ERROR_OUT_OF_MEMORY;

	*ctx_ret = ctx;
	return TEE_SUCCESS;
}","TEE_Result crypto_aes_gcm_alloc_ctx(void **VAR_0)
{
	struct tee_gcm_state *VAR_1 =  TEE_Malloc(sizeof(*VAR_1), VAR_2);
	/* COMMENT_0 */

	if (!VAR_1)
		return VAR_3;

	*VAR_0 = VAR_1;
	return VAR_4;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_ltc_provider.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,6 +1,7 @@
 TEE_Result crypto_aes_gcm_alloc_ctx(void **ctx_ret)
 {
-	struct tee_gcm_state *ctx = calloc(1, sizeof(*ctx));
+	struct tee_gcm_state *ctx =  TEE_Malloc(sizeof(*ctx), TEE_MALLOC_FILL_ZERO);
+	// struct tee_gcm_state *ctx = calloc(1, sizeof(*ctx));
 
 	if (!ctx)
 		return TEE_ERROR_OUT_OF_MEMORY;","{'deleted_lines': ['\tstruct tee_gcm_state *ctx = calloc(1, sizeof(*ctx));'], 'added_lines': ['\tstruct tee_gcm_state *ctx =  TEE_Malloc(sizeof(*ctx), TEE_MALLOC_FILL_ZERO);', '\t// struct tee_gcm_state *ctx = calloc(1, sizeof(*ctx));']}",True,"The function tee_obj_free in Samsung mTower through 0.3.0 allows a trusted application to trigger a Denial of Service (DoS) by invoking the function TEE_AllocateOperation with a disturbed heap layout, related to utee_cryp_obj_alloc.",7.5,HIGH,2,test,2022-11-24T19:37:56Z,4
CVE-2022-40761,['CWE-1284'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Samsung/mTower,"Fixed CVE-2022-40761

Signed-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,https://github.com/Samsung/mTower/commit/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,crypto/libtomcrypt/src/tee_ltc_provider.c,crypto_bignum_allocate,"struct bignum *crypto_bignum_allocate(size_t size_bits)
{
size_t sz = mpa_StaticVarSizeInU32(size_bits) *sizeof(uint32_t);
struct mpa_numbase_struct *bn = calloc(1, sz);
if (!bn)
return NULL;
bn->alloc = sz - MPA_NUMBASE_METADATA_SIZE_IN_U32 * sizeof(uint32_t);
return (struct bignum *)bn;
}","struct bignum *crypto_bignum_allocate(size_t VAR_0)
{
size_t VAR_1 = mpa_StaticVarSizeInU32(VAR_0) *sizeof(uint32_t);
struct mpa_numbase_struct *VAR_2 = calloc(1, VAR_1);
if (!VAR_2)
return NULL;
VAR_2->alloc = VAR_1 - VAR_3 * sizeof(uint32_t);
return (struct bignum *)VAR_2;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_ltc_provider.c/vul/before/3.json,"struct bignum *crypto_bignum_allocate(size_t size_bits)
{
	size_t sz = mpa_StaticVarSizeInU32(size_bits) *	sizeof(uint32_t);
	// struct mpa_numbase_struct *bn = calloc(1, sz);
	struct mpa_numbase_struct *bn= TEE_Malloc(sz, TEE_MALLOC_FILL_ZERO);
	if (!bn)
		return NULL;
	bn->alloc = sz - MPA_NUMBASE_METADATA_SIZE_IN_U32 * sizeof(uint32_t);
	return (struct bignum *)bn;
}","struct bignum *crypto_bignum_allocate(size_t VAR_0)
{
	size_t VAR_1 = mpa_StaticVarSizeInU32(VAR_0) *	sizeof(uint32_t);
	/* COMMENT_0 */
	struct mpa_numbase_struct *VAR_2= TEE_Malloc(VAR_1, VAR_3);
	if (!VAR_2)
		return NULL;
	VAR_2->alloc = VAR_1 - VAR_4 * sizeof(uint32_t);
	return (struct bignum *)VAR_2;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_ltc_provider.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -1,8 +1,8 @@
 struct bignum *crypto_bignum_allocate(size_t size_bits)
 {
 	size_t sz = mpa_StaticVarSizeInU32(size_bits) *	sizeof(uint32_t);
-	struct mpa_numbase_struct *bn = calloc(1, sz);
-
+	// struct mpa_numbase_struct *bn = calloc(1, sz);
+	struct mpa_numbase_struct *bn= TEE_Malloc(sz, TEE_MALLOC_FILL_ZERO);
 	if (!bn)
 		return NULL;
 	bn->alloc = sz - MPA_NUMBASE_METADATA_SIZE_IN_U32 * sizeof(uint32_t);","{'deleted_lines': ['\tstruct mpa_numbase_struct *bn = calloc(1, sz);', ''], 'added_lines': ['\t// struct mpa_numbase_struct *bn = calloc(1, sz);', '\tstruct mpa_numbase_struct *bn= TEE_Malloc(sz, TEE_MALLOC_FILL_ZERO);']}",True,"The function tee_obj_free in Samsung mTower through 0.3.0 allows a trusted application to trigger a Denial of Service (DoS) by invoking the function TEE_AllocateOperation with a disturbed heap layout, related to utee_cryp_obj_alloc.",7.5,HIGH,2,test,2022-11-24T19:37:56Z,4
CVE-2022-40761,['CWE-1284'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Samsung/mTower,"Fixed CVE-2022-40761

Signed-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,https://github.com/Samsung/mTower/commit/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,crypto/libtomcrypt/src/tee_ltc_provider.c,crypto_cipher_alloc_ctx,"TEE_Result crypto_cipher_alloc_ctx(void **ctx_ret, uint32_t algo)
{
TEE_Result res;
size_t ctx_size;
void *ctx;
res = cipher_get_ctx_size(algo, &ctx_size);
if (res)
return res;
ctx = calloc(1, ctx_size);
if (!ctx)
return TEE_ERROR_OUT_OF_MEMORY;
*ctx_ret = ctx;
return TEE_SUCCESS;
}","TEE_Result crypto_cipher_alloc_ctx(void **VAR_0, uint32_t VAR_1)
{
TEE_Result VAR_2;
size_t VAR_3;
void *VAR_4;
VAR_2 = cipher_get_ctx_size(VAR_1, &VAR_3);
if (VAR_2)
return VAR_2;
VAR_4 = calloc(1, VAR_3);
if (!VAR_4)
return VAR_5;
*VAR_0 = VAR_4;
return VAR_6;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_ltc_provider.c/vul/before/4.json,"TEE_Result crypto_cipher_alloc_ctx(void **ctx_ret, uint32_t algo)
{
	TEE_Result res;
	size_t ctx_size;
	void *ctx;

	res = cipher_get_ctx_size(algo, &ctx_size);

	if (res)
		return res;

	// ctx = calloc(1, ctx_size);
	ctx = TEE_Malloc(ctx_size, TEE_MALLOC_FILL_ZERO);
	if (!ctx)
		return TEE_ERROR_OUT_OF_MEMORY;

	*ctx_ret = ctx;
	return TEE_SUCCESS;
}","TEE_Result crypto_cipher_alloc_ctx(void **VAR_0, uint32_t VAR_1)
{
	TEE_Result VAR_2;
	size_t VAR_3;
	void *VAR_4;

	VAR_2 = cipher_get_ctx_size(VAR_1, &VAR_3);

	if (VAR_2)
		return VAR_2;

	/* COMMENT_0 */
	VAR_4 = TEE_Malloc(VAR_3, VAR_5);
	if (!VAR_4)
		return VAR_6;

	*VAR_0 = VAR_4;
	return VAR_7;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_ltc_provider.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -9,7 +9,8 @@
 	if (res)
 		return res;
 
-	ctx = calloc(1, ctx_size);
+	// ctx = calloc(1, ctx_size);
+	ctx = TEE_Malloc(ctx_size, TEE_MALLOC_FILL_ZERO);
 	if (!ctx)
 		return TEE_ERROR_OUT_OF_MEMORY;
 ","{'deleted_lines': ['\tctx = calloc(1, ctx_size);'], 'added_lines': ['\t// ctx = calloc(1, ctx_size);', '\tctx = TEE_Malloc(ctx_size, TEE_MALLOC_FILL_ZERO);']}",True,"The function tee_obj_free in Samsung mTower through 0.3.0 allows a trusted application to trigger a Denial of Service (DoS) by invoking the function TEE_AllocateOperation with a disturbed heap layout, related to utee_cryp_obj_alloc.",7.5,HIGH,2,test,2022-11-24T19:37:56Z,4
CVE-2022-40761,['CWE-1284'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Samsung/mTower,"Fixed CVE-2022-40761

Signed-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,https://github.com/Samsung/mTower/commit/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae,tee/kernel/pseudo_ta.c,tee_ta_init_pseudo_ta_session,"TEE_Result tee_ta_init_pseudo_ta_session(const TEE_UUID *uuid,
struct tee_ta_session *s)
{
struct pseudo_ta_ctx *stc = NULL;
struct tee_ta_ctx *ctx;
const struct pseudo_ta_head *ta;
DMSG(""Lookup pseudo TA %pUl"", (void *)uuid);
ta = &__start_ta_head_section;
while (true) {
if (ta >= &__stop_ta_head_section)
return TEE_ERROR_ITEM_NOT_FOUND;
if (memcmp(&ta->uuid, uuid, sizeof(TEE_UUID)) == 0)
break;
ta++;
}
DMSG(""Open %s"", ta->name);
stc = calloc(1, sizeof(struct pseudo_ta_ctx));
if (!stc)
return TEE_ERROR_OUT_OF_MEMORY;
ctx = &stc->ctx;
s->ctx = ctx;
ctx->flags = ta->flags;
stc->pseudo_ta = ta;
ctx->uuid = ta->uuid;
ctx->ops = &pseudo_ta_ops;
TAILQ_INSERT_TAIL(&tee_ctxes, ctx, link);
DMSG(""%s : %pUl"", stc->pseudo_ta->name, (void *)&ctx->uuid);
return TEE_SUCCESS;
}","TEE_Result tee_ta_init_pseudo_ta_session(const TEE_UUID *VAR_0,
struct tee_ta_session *VAR_1)
{
struct pseudo_ta_ctx *VAR_2 = NULL;
struct tee_ta_ctx *VAR_3;
const struct pseudo_ta_head *VAR_4;
DMSG(""Lookup pseudo TA %pUl"", (void *)VAR_0);
VAR_4 = &VAR_5;
while (true) {
if (VAR_4 >= &VAR_6)
return VAR_7;
if (memcmp(&VAR_4->uuid, VAR_0, sizeof(TEE_UUID)) == 0)
break;
VAR_4++;
}
DMSG(""Open %s"", VAR_4->name);
VAR_2 = calloc(1, sizeof(struct pseudo_ta_ctx));
if (!VAR_2)
return VAR_8;
VAR_3 = &VAR_2->ctx;
VAR_1->ctx = VAR_3;
VAR_3->flags = VAR_4->flags;
VAR_2->pseudo_ta = VAR_4;
VAR_3->uuid = VAR_4->uuid;
VAR_3->ops = &VAR_9;
TAILQ_INSERT_TAIL(&VAR_10, VAR_3, VAR_11);
DMSG(""%s : %pUl"", VAR_2->pseudo_ta->name, (void *)&VAR_3->uuid);
return VAR_12;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/pseudo_ta.c/vul/before/0.json,"TEE_Result tee_ta_init_pseudo_ta_session(const TEE_UUID *uuid,
			struct tee_ta_session *s)
{
	struct pseudo_ta_ctx *stc = NULL;
	struct tee_ta_ctx *ctx;
	const struct pseudo_ta_head *ta;

  DMSG(""Lookup pseudo TA %pUl"", (void *)uuid);

	ta = &__start_ta_head_section;
	while (true) {
		if (ta >= &__stop_ta_head_section)
			return TEE_ERROR_ITEM_NOT_FOUND;
//    uuid_print(&ta->uuid);
//    uuid_print(uuid);
		if (memcmp(&ta->uuid, uuid, sizeof(TEE_UUID)) == 0)
			break;
		ta++;
	}

	/* Load a new TA and create a session */
	DMSG(""Open %s"", ta->name);
	// stc = calloc(1, sizeof(struct pseudo_ta_ctx));
	stc = TEE_Malloc(sizeof(struct pseudo_ta_ctx), TEE_MALLOC_FILL_ZERO);
	if (!stc)
		return TEE_ERROR_OUT_OF_MEMORY;
	ctx = &stc->ctx;

//	ctx->ref_count = 1;
	s->ctx = ctx;
	ctx->flags = ta->flags;
	stc->pseudo_ta = ta;
	ctx->uuid = ta->uuid;
	ctx->ops = &pseudo_ta_ops;
	TAILQ_INSERT_TAIL(&tee_ctxes, ctx, link);

	DMSG(""%s : %pUl"", stc->pseudo_ta->name, (void *)&ctx->uuid);

	return TEE_SUCCESS;
}","TEE_Result tee_ta_init_pseudo_ta_session(const TEE_UUID *VAR_0,
			struct tee_ta_session *VAR_1)
{
	struct pseudo_ta_ctx *VAR_2 = NULL;
	struct tee_ta_ctx *VAR_3;
	const struct pseudo_ta_head *VAR_4;

  DMSG(""Lookup pseudo TA %pUl"", (void *)VAR_0);

	VAR_4 = &VAR_5;
	while (true) {
		if (VAR_4 >= &VAR_6)
			return VAR_7;
/* COMMENT_0 */
/* COMMENT_1 */
		if (memcmp(&VAR_4->uuid, VAR_0, sizeof(TEE_UUID)) == 0)
			break;
		VAR_4++;
	}

	/* COMMENT_2 */
	DMSG(""Open %s"", VAR_4->name);
	/* COMMENT_3 */
	VAR_2 = TEE_Malloc(sizeof(struct pseudo_ta_ctx), VAR_8);
	if (!VAR_2)
		return VAR_9;
	VAR_3 = &VAR_2->ctx;

/* COMMENT_4 */
	VAR_1->ctx = VAR_3;
	VAR_3->flags = VAR_4->flags;
	VAR_2->pseudo_ta = VAR_4;
	VAR_3->uuid = VAR_4->uuid;
	VAR_3->ops = &VAR_10;
	TAILQ_INSERT_TAIL(&VAR_11, VAR_3, VAR_12);

	DMSG(""%s : %pUl"", VAR_2->pseudo_ta->name, (void *)&VAR_3->uuid);

	return VAR_13;
}",Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/pseudo_ta.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -20,7 +20,8 @@
 
 	/* Load a new TA and create a session */
 	DMSG(""Open %s"", ta->name);
-	stc = calloc(1, sizeof(struct pseudo_ta_ctx));
+	// stc = calloc(1, sizeof(struct pseudo_ta_ctx));
+	stc = TEE_Malloc(sizeof(struct pseudo_ta_ctx), TEE_MALLOC_FILL_ZERO);
 	if (!stc)
 		return TEE_ERROR_OUT_OF_MEMORY;
 	ctx = &stc->ctx;","{'deleted_lines': ['\tstc = calloc(1, sizeof(struct pseudo_ta_ctx));'], 'added_lines': ['\t// stc = calloc(1, sizeof(struct pseudo_ta_ctx));', '\tstc = TEE_Malloc(sizeof(struct pseudo_ta_ctx), TEE_MALLOC_FILL_ZERO);']}",True,"The function tee_obj_free in Samsung mTower through 0.3.0 allows a trusted application to trigger a Denial of Service (DoS) by invoking the function TEE_AllocateOperation with a disturbed heap layout, related to utee_cryp_obj_alloc.",7.5,HIGH,2,test,2022-11-24T19:37:56Z,4
CVE-2022-4141,['CWE-122'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,vim,"patch 9.0.0947: invalid memory access in substitute with function

Problem:    Invalid memory access in substitute with function that goes to
            another file.
Solution:   Check for text locked in CTRL-W gf.",cc762a48d42b579fb7bdec2c614636b830342dd5,https://github.com/vim/vim/commit/cc762a48d42b579fb7bdec2c614636b830342dd5,src/normal.c,nv_gotofile,"static void
nv_gotofile(cmdarg_T *cap)
{
char_u*ptr;
linenr_Tlnum = -1;
if (check_text_locked(cap->oap))
return;
if (curbuf_locked())
{
clearop(cap->oap);
return;
}
#ifdef FEAT_PROP_POPUP
if (ERROR_IF_TERM_POPUP_WINDOW)
return;
#endif
ptr = grab_file_name(cap->count1, &lnum);
if (ptr != NULL)
{
if (curbufIsChanged() && curbuf->b_nwindows <= 1 && !buf_hide(curbuf))
(void)autowrite(curbuf, FALSE);
setpcmark();
if (do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,
buf_hide(curbuf) ? ECMD_HIDE : 0, curwin) == OK
&& cap->nchar == 'F' && lnum >= 0)
{
curwin->w_cursor.lnum = lnum;
check_cursor_lnum();
beginline(BL_SOL | BL_FIX);
}
vim_free(ptr);
}
else
clearop(cap->oap);
}","static void
nv_gotofile(cmdarg_T *VAR_0)
{
char_u*VAR_1;
linenr_TVAR_2 = -1;
if (check_text_locked(VAR_0->oap))
return;
if (curbuf_locked())
{
clearop(VAR_0->oap);
return;
}
#ifdef VAR_3
if (VAR_4)
return;
#endif
VAR_1 = grab_file_name(VAR_0->count1, &VAR_2);
if (VAR_1 != NULL)
{
if (curbufIsChanged() && VAR_5->b_nwindows <= 1 && !buf_hide(VAR_5))
(void)autowrite(VAR_5, FALSE);
setpcmark();
if (do_ecmd(0, VAR_1, NULL, NULL, VAR_6,
buf_hide(VAR_5) ? VAR_7 : 0, VAR_8) == VAR_9
&& VAR_0->nchar == 'F' && VAR_2 >= 0)
{
VAR_8->w_cursor.lnum = VAR_2;
check_cursor_lnum();
beginline(VAR_10 | VAR_11);
}
vim_free(VAR_1);
}
else
clearop(VAR_0->oap);
}",vim/cc762a48d42b579fb7bdec2c614636b830342dd5/normal.c/vul/before/2.json,"static void
nv_gotofile(cmdarg_T *cap)
{
    char_u	*ptr;
    linenr_T	lnum = -1;

    if (check_text_or_curbuf_locked(cap->oap))
	return;

#ifdef FEAT_PROP_POPUP
    if (ERROR_IF_TERM_POPUP_WINDOW)
	return;
#endif

    ptr = grab_file_name(cap->count1, &lnum);

    if (ptr != NULL)
    {
	// do autowrite if necessary
	if (curbufIsChanged() && curbuf->b_nwindows <= 1 && !buf_hide(curbuf))
	    (void)autowrite(curbuf, FALSE);
	setpcmark();
	if (do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,
				buf_hide(curbuf) ? ECMD_HIDE : 0, curwin) == OK
		&& cap->nchar == 'F' && lnum >= 0)
	{
	    curwin->w_cursor.lnum = lnum;
	    check_cursor_lnum();
	    beginline(BL_SOL | BL_FIX);
	}
	vim_free(ptr);
    }
    else
	clearop(cap->oap);
}","static void
nv_gotofile(cmdarg_T *VAR_0)
{
    char_u	*VAR_1;
    linenr_T	VAR_2 = -1;

    if (check_text_or_curbuf_locked(VAR_0->oap))
	return;

#ifdef VAR_3
    if (VAR_4)
	return;
#endif

    VAR_1 = grab_file_name(VAR_0->count1, &VAR_2);

    if (VAR_1 != NULL)
    {
	/* COMMENT_0 */
	if (curbufIsChanged() && VAR_5->b_nwindows <= 1 && !buf_hide(VAR_5))
	    (void)autowrite(VAR_5, FALSE);
	setpcmark();
	if (do_ecmd(0, VAR_1, NULL, NULL, VAR_6,
				buf_hide(VAR_5) ? VAR_7 : 0, VAR_8) == VAR_9
		&& VAR_0->nchar == 'F' && VAR_2 >= 0)
	{
	    VAR_8->w_cursor.lnum = VAR_2;
	    check_cursor_lnum();
	    beginline(VAR_10 | VAR_11);
	}
	vim_free(VAR_1);
    }
    else
	clearop(VAR_0->oap);
}",vim/cc762a48d42b579fb7bdec2c614636b830342dd5/normal.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -4,13 +4,9 @@
     char_u	*ptr;
     linenr_T	lnum = -1;
 
-    if (check_text_locked(cap->oap))
+    if (check_text_or_curbuf_locked(cap->oap))
 	return;
-    if (curbuf_locked())
-    {
-	clearop(cap->oap);
-	return;
-    }
+
 #ifdef FEAT_PROP_POPUP
     if (ERROR_IF_TERM_POPUP_WINDOW)
 	return;","{'deleted_lines': ['    if (check_text_locked(cap->oap))', '    if (curbuf_locked())', '    {', '\tclearop(cap->oap);', '\treturn;', '    }'], 'added_lines': ['    if (check_text_or_curbuf_locked(cap->oap))', '']}",True,Heap based buffer overflow in vim/vim 9.0.0946 and below by allowing an attacker to CTRL-W gf in the expression used in the RHS of the substitute command.,7.8,HIGH,2,test,2022-11-25T13:03:31Z,4
CVE-2022-4141,['CWE-122'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,vim,"patch 9.0.0947: invalid memory access in substitute with function

Problem:    Invalid memory access in substitute with function that goes to
            another file.
Solution:   Check for text locked in CTRL-W gf.",cc762a48d42b579fb7bdec2c614636b830342dd5,https://github.com/vim/vim/commit/cc762a48d42b579fb7bdec2c614636b830342dd5,src/normal.c,normal_cmd,"void
normal_cmd(
oparg_T*oap,
inttoplevel UNUSED){
cmdarg_Tca;    intc;
intctrl_w = FALSE;    intold_col = curwin->w_curswant;
intneed_flushbuf = FALSE;    pos_Told_pos;    intmapped_len;
static intold_mapped_len = 0;
intidx;
intset_prevcount = FALSE;
intsave_did_cursorhold = did_cursorhold;
CLEAR_FIELD(ca);    ca.oap = oap;
ca.opcount = opcount;
#ifdef CURSOR_SHAPE
c = finish_op;
#endif
finish_op = (oap->op_type != OP_NOP);
#ifdef CURSOR_SHAPE
if (finish_op != c)
{
ui_cursor_shape();# ifdef FEAT_MOUSESHAPE
update_mouseshape(-1);
# endif
}
#endif
may_trigger_modechanged();
if (!finish_op && !oap->regname)
{
ca.opcount = 0;
#ifdef FEAT_EVAL
set_prevcount = TRUE;
#endif
}
if (oap->prev_opcount > 0 || oap->prev_count0 > 0)
{
ca.opcount = oap->prev_opcount;
ca.count0 = oap->prev_count0;
oap->prev_opcount = 0;
oap->prev_count0 = 0;
}
mapped_len = typebuf_maplen();
State = MODE_NORMAL_BUSY;
#ifdef USE_ON_FLY_SCROLL
dont_scroll = FALSE;#endif
#ifdef FEAT_EVAL
if (toplevel && readbuf1_empty())
set_vcount_ca(&ca, &set_prevcount);
#endif
c = safe_vgetc();
LANGMAP_ADJUST(c, get_real_state() != MODE_SELECT);
if (restart_edit == 0)
old_mapped_len = 0;
else if (old_mapped_len
|| (VIsual_active && mapped_len == 0 && typebuf_maplen() > 0))
old_mapped_len = typebuf_maplen();
if (c == NUL)
c = K_ZERO;
if (VIsual_active
&& VIsual_select
&& (vim_isprintc(c) || c == NL || c == CAR || c == K_KENTER))
{
int len;
len = ins_char_typebuf(vgetc_char, vgetc_mod_mask);
if (KeyTyped)
ungetchars(len);
if (restart_edit != 0)
c = 'd';
else
c = 'c';
msg_nowait = TRUE;old_mapped_len = 0;    }
if (KeyTyped && !KeyStuffed)
win_ensure_size();
need_flushbuf = add_to_showcmd(c);
c = normal_cmd_get_count(&ca, c, toplevel, set_prevcount, &ctrl_w,
&need_flushbuf);
if (ctrl_w)
{
ca.nchar = c;
ca.cmdchar = Ctrl_W;
}
else
ca.cmdchar = c;
idx = find_command(ca.cmdchar);
if (idx < 0)
{
clearopbeep(oap);
goto normal_end;
}
if ((nv_cmds[idx].cmd_flags & NV_NCW)
&& (check_text_locked(oap) || curbuf_locked()))
goto normal_end;
if (VIsual_active)
{
if (km_stopsel
&& (nv_cmds[idx].cmd_flags & NV_STS)
&& !(mod_mask & MOD_MASK_SHIFT))
{
end_visual_mode();
redraw_curbuf_later(UPD_INVERTED);
}
if (km_startsel)
{
if (nv_cmds[idx].cmd_flags & NV_SS)
{
unshift_special(&ca);
idx = find_command(ca.cmdchar);
if (idx < 0)
{
clearopbeep(oap);
goto normal_end;
}
}
else if ((nv_cmds[idx].cmd_flags & NV_SSS)
&& (mod_mask & MOD_MASK_SHIFT))
mod_mask &= ~MOD_MASK_SHIFT;
}
}
#ifdef FEAT_RIGHTLEFT
if (curwin->w_p_rl && KeyTyped && !KeyStuffed
&& (nv_cmds[idx].cmd_flags & NV_RL))
{
switch (ca.cmdchar)
{
case 'l':    ca.cmdchar = 'h'; break;
case K_RIGHT:   ca.cmdchar = K_LEFT; break;
case K_S_RIGHT: ca.cmdchar = K_S_LEFT; break;
case K_C_RIGHT: ca.cmdchar = K_C_LEFT; break;
case 'h':    ca.cmdchar = 'l'; break;
case K_LEFT:    ca.cmdchar = K_RIGHT; break;
case K_S_LEFT:  ca.cmdchar = K_S_RIGHT; break;
case K_C_LEFT:  ca.cmdchar = K_C_RIGHT; break;
case '>':    ca.cmdchar = '<'; break;
case '<':    ca.cmdchar = '>'; break;
}
idx = find_command(ca.cmdchar);
}
#endif
if (normal_cmd_needs_more_chars(&ca, nv_cmds[idx].cmd_flags))
idx = normal_cmd_get_more_chars(idx, &ca, &need_flushbuf);
if (need_flushbuf)
out_flush();
if (ca.cmdchar != K_IGNORE)
{
if (ex_normal_busy)
did_cursorhold = save_did_cursorhold;
else
did_cursorhold = FALSE;
}
State = MODE_NORMAL;
if (ca.nchar == ESC)
{
clearop(oap);
if (restart_edit == 0 && goto_im())
restart_edit = 'a';
goto normal_end;
}
if (ca.cmdchar != K_IGNORE)
{
msg_didout = FALSE;    msg_col = 0;
}
old_pos = curwin->w_cursor;
if (!VIsual_active && km_startsel)
{
if (nv_cmds[idx].cmd_flags & NV_SS)
{
start_selection();
unshift_special(&ca);
idx = find_command(ca.cmdchar);
}
else if ((nv_cmds[idx].cmd_flags & NV_SSS)
&& (mod_mask & MOD_MASK_SHIFT))
{
start_selection();
mod_mask &= ~MOD_MASK_SHIFT;
}
}
ca.arg = nv_cmds[idx].cmd_arg;
(nv_cmds[idx].cmd_func)(&ca);
if (!finish_op
&& !oap->op_type
&& (idx < 0 || !(nv_cmds[idx].cmd_flags & NV_KEEPREG)))
{
clearop(oap);
#ifdef FEAT_EVAL
reset_reg_var();
#endif
}
if (old_mapped_len > 0)
old_mapped_len = typebuf_maplen();
if (ca.cmdchar != K_IGNORE && ca.cmdchar != K_MOUSEMOVE)
do_pending_operator(&ca, old_col, FALSE);
if (normal_cmd_need_to_wait_for_msg(&ca, &old_pos))
normal_cmd_wait_for_msg();
normal_end:
msg_nowait = FALSE;
#ifdef FEAT_EVAL
if (finish_op)
reset_reg_var();
#endif
#ifdef CURSOR_SHAPE
c = finish_op;
#endif
finish_op = FALSE;
may_trigger_modechanged();
#ifdef CURSOR_SHAPE
if (c || ca.cmdchar == 'r')
{
ui_cursor_shape();# ifdef FEAT_MOUSESHAPE
update_mouseshape(-1);
# endif
}
#endif
if (oap->op_type == OP_NOP && oap->regname == 0
&& ca.cmdchar != K_CURSORHOLD)
clear_showcmd();
checkpcmark();    vim_free(ca.searchbuf);
if (has_mbyte)
mb_adjust_cursor();
if (curwin->w_p_scb && toplevel)
{
validate_cursor();do_check_scrollbind(TRUE);
}
if (curwin->w_p_crb && toplevel)
{
validate_cursor();do_check_cursorbind();
}
#ifdef FEAT_TERMINAL
if (term_job_running(curbuf->b_term))
restart_edit = 0;
#endif
if (       oap->op_type == OP_NOP
&& ((restart_edit != 0 && !VIsual_active && old_mapped_len == 0)
|| restart_VIsual_select == 1)
&& !(ca.retval & CA_COMMAND_BUSY)
&& stuff_empty()
&& oap->regname == 0)
{
if (restart_VIsual_select == 1)
{
VIsual_select = TRUE;
may_trigger_modechanged();
showmode();
restart_VIsual_select = 0;
VIsual_select_reg = 0;
}
if (restart_edit != 0 && !VIsual_active && old_mapped_len == 0)
(void)edit(restart_edit, FALSE, 1L);
}
if (restart_VIsual_select == 2)
restart_VIsual_select = 1;
opcount = ca.opcount;
}","void
normal_cmd(
oparg_T*VAR_0,
intVAR_1 UNUSED)
{
cmdarg_TVAR_2;
intVAR_3;
intVAR_4 = FALSE;
intVAR_5 = VAR_6->w_curswant;
intVAR_7 = FALSE;
pos_TVAR_8;
intVAR_9;
static intVAR_10 = 0;
intVAR_11;
intVAR_12 = FALSE;
intVAR_13 = VAR_14;
CLEAR_FIELD(VAR_2);
VAR_2.oap = VAR_0;
VAR_2.opcount = VAR_15;
#ifdef VAR_16
VAR_3 = VAR_17;
#endif
VAR_17 = (VAR_0->op_type != VAR_18);
#ifdef VAR_16
if (VAR_17 != VAR_3)
{
ui_cursor_shape();
# ifdef VAR_19
update_mouseshape(-1);
# endif
}
#endif
may_trigger_modechanged();
if (!VAR_17 && !VAR_0->regname)
{
VAR_2.opcount = 0;
#ifdef VAR_20
VAR_12 = TRUE;
#endif
}
if (VAR_0->prev_opcount > 0 || VAR_0->prev_count0 > 0)
{
VAR_2.opcount = VAR_0->prev_opcount;
VAR_2.count0 = VAR_0->prev_count0;
VAR_0->prev_opcount = 0;
VAR_0->prev_count0 = 0;
}
VAR_9 = typebuf_maplen();
VAR_21 = VAR_22;
#ifdef VAR_23
VAR_24 = FALSE;
#endif
#ifdef VAR_20
if (VAR_1 && readbuf1_empty())
set_vcount_ca(&VAR_2, &VAR_12);
#endif
VAR_3 = safe_vgetc();
LANGMAP_ADJUST(VAR_3, get_real_state() != VAR_25);
if (VAR_26 == 0)
VAR_10 = 0;
else if (VAR_10
|| (VAR_27 && VAR_9 == 0 && typebuf_maplen() > 0))
VAR_10 = typebuf_maplen();
if (VAR_3 == VAR_28)
VAR_3 = VAR_29;
if (VAR_27
&& VAR_30
&& (vim_isprintc(VAR_3) || VAR_3 == VAR_31 || VAR_3 == VAR_32 || VAR_3 == VAR_33))
{
int VAR_34;
VAR_34 = ins_char_typebuf(VAR_35, VAR_36);
if (VAR_37)
ungetchars(VAR_34);
if (VAR_26 != 0)
VAR_3 = 'd';
else
VAR_3 = 'c';
VAR_38 = TRUE;
VAR_10 = 0;
}
if (VAR_37 && !VAR_39)
win_ensure_size();
VAR_7 = add_to_showcmd(VAR_3);
VAR_3 = normal_cmd_get_count(&VAR_2, VAR_3, VAR_1, VAR_12, &VAR_4,
&VAR_7);
if (VAR_4)
{
VAR_2.nchar = VAR_3;
VAR_2.cmdchar = VAR_40;
}
else
VAR_2.cmdchar = VAR_3;
VAR_11 = find_command(VAR_2.cmdchar);
if (VAR_11 < 0)
{
clearopbeep(VAR_0);
goto normal_end;
}
if ((VAR_41[VAR_11].cmd_flags & VAR_42)
&& (check_text_locked(VAR_0) || curbuf_locked()))
goto normal_end;
if (VAR_27)
{
if (VAR_43
&& (VAR_41[VAR_11].cmd_flags & VAR_44)
&& !(VAR_45 & VAR_46))
{
end_visual_mode();
redraw_curbuf_later(VAR_47);
}
if (VAR_48)
{
if (VAR_41[VAR_11].cmd_flags & VAR_49)
{
unshift_special(&VAR_2);
VAR_11 = find_command(VAR_2.cmdchar);
if (VAR_11 < 0)
{
clearopbeep(VAR_0);
goto normal_end;
}
}
else if ((VAR_41[VAR_11].cmd_flags & VAR_50)
&& (VAR_45 & VAR_46))
VAR_45 &= ~VAR_46;
}
}
#ifdef VAR_51
if (VAR_6->w_p_rl && VAR_37 && !VAR_39
&& (VAR_41[VAR_11].cmd_flags & VAR_52))
{
switch (VAR_2.cmdchar)
{
case 'l':    VAR_2.cmdchar = 'h'; break;
case VAR_53:   VAR_2.cmdchar = VAR_54; break;
case VAR_55: VAR_2.cmdchar = VAR_56; break;
case VAR_57: VAR_2.cmdchar = VAR_58; break;
case 'h':    VAR_2.cmdchar = 'l'; break;
case VAR_54:    VAR_2.cmdchar = VAR_53; break;
case VAR_56:  VAR_2.cmdchar = VAR_55; break;
case VAR_58:  VAR_2.cmdchar = VAR_57; break;
case '>':    VAR_2.cmdchar = '<'; break;
case '<':    VAR_2.cmdchar = '>'; break;
}
VAR_11 = find_command(VAR_2.cmdchar);
}
#endif
if (normal_cmd_needs_more_chars(&VAR_2, VAR_41[VAR_11].cmd_flags))
VAR_11 = normal_cmd_get_more_chars(VAR_11, &VAR_2, &VAR_7);
if (VAR_7)
out_flush();
if (VAR_2.cmdchar != VAR_59)
{
if (VAR_60)
VAR_14 = VAR_13;
else
VAR_14 = FALSE;
}
VAR_21 = VAR_61;
if (VAR_2.nchar == VAR_62)
{
clearop(VAR_0);
if (VAR_26 == 0 && goto_im())
VAR_26 = 'a';
goto normal_end;
}
if (VAR_2.cmdchar != VAR_59)
{
VAR_63 = FALSE;    
VAR_64 = 0;
}
VAR_8 = VAR_6->w_cursor;
if (!VAR_27 && VAR_48)
{
if (VAR_41[VAR_11].cmd_flags & VAR_49)
{
start_selection();
unshift_special(&VAR_2);
VAR_11 = find_command(VAR_2.cmdchar);
}
else if ((VAR_41[VAR_11].cmd_flags & VAR_50)
&& (VAR_45 & VAR_46))
{
start_selection();
VAR_45 &= ~VAR_46;
}
}
VAR_2.arg = VAR_41[VAR_11].cmd_arg;
(VAR_41[VAR_11].cmd_func)(&VAR_2);
if (!VAR_17
&& !VAR_0->op_type
&& (VAR_11 < 0 || !(VAR_41[VAR_11].cmd_flags & VAR_65)))
{
clearop(VAR_0);
#ifdef VAR_20
reset_reg_var();
#endif
}
if (VAR_10 > 0)
VAR_10 = typebuf_maplen();
if (VAR_2.cmdchar != VAR_59 && VAR_2.cmdchar != VAR_66)
do_pending_operator(&VAR_2, VAR_5, FALSE);
if (normal_cmd_need_to_wait_for_msg(&VAR_2, &VAR_8))
normal_cmd_wait_for_msg();
normal_end:
VAR_38 = FALSE;
#ifdef VAR_20
if (VAR_17)
reset_reg_var();
#endif
#ifdef VAR_16
VAR_3 = VAR_17;
#endif
VAR_17 = FALSE;
may_trigger_modechanged();
#ifdef VAR_16
if (VAR_3 || VAR_2.cmdchar == 'r')
{
ui_cursor_shape();
# ifdef VAR_19
update_mouseshape(-1);
# endif
}
#endif
if (VAR_0->op_type == VAR_18 && VAR_0->regname == 0
&& VAR_2.cmdchar != VAR_67)
clear_showcmd();
checkpcmark();
vim_free(VAR_2.searchbuf);
if (VAR_68)
mb_adjust_cursor();
if (VAR_6->w_p_scb && VAR_1)
{
validate_cursor();
do_check_scrollbind(TRUE);
}
if (VAR_6->w_p_crb && VAR_1)
{
validate_cursor();
do_check_cursorbind();
}
#ifdef VAR_69
if (term_job_running(VAR_70->b_term))
VAR_26 = 0;
#endif
if (       VAR_0->op_type == VAR_18
&& ((VAR_26 != 0 && !VAR_27 && VAR_10 == 0)
|| VAR_71 == 1)
&& !(VAR_2.retval & VAR_72)
&& stuff_empty()
&& VAR_0->regname == 0)
{
if (VAR_71 == 1)
{
VAR_30 = TRUE;
may_trigger_modechanged();
showmode();
VAR_71 = 0;
VAR_73 = 0;
}
if (VAR_26 != 0 && !VAR_27 && VAR_10 == 0)
(void)edit(VAR_26, FALSE, 1L);
}
if (VAR_71 == 2)
VAR_71 = 1;
VAR_15 = VAR_2.opcount;
}",,"void
normal_cmd(
    oparg_T	*oap,
    int		toplevel UNUSED)	// TRUE when called from main()
{
    cmdarg_T	ca;			// command arguments
    int		c;
    int		ctrl_w = FALSE;		// got CTRL-W command
    int		old_col = curwin->w_curswant;
    int		need_flushbuf = FALSE;	// need to call out_flush()
    pos_T	old_pos;		// cursor position before command
    int		mapped_len;
    static int	old_mapped_len = 0;
    int		idx;
    int		set_prevcount = FALSE;
    int		save_did_cursorhold = did_cursorhold;

    CLEAR_FIELD(ca);	// also resets ca.retval
    ca.oap = oap;

    // Use a count remembered from before entering an operator.  After typing
    // ""3d"" we return from normal_cmd() and come back here, the ""3"" is
    // remembered in ""opcount"".
    ca.opcount = opcount;

    // If there is an operator pending, then the command we take this time
    // will terminate it. Finish_op tells us to finish the operation before
    // returning this time (unless the operation was cancelled).
#ifdef CURSOR_SHAPE
    c = finish_op;
#endif
    finish_op = (oap->op_type != OP_NOP);
#ifdef CURSOR_SHAPE
    if (finish_op != c)
    {
	ui_cursor_shape();		// may show different cursor shape
# ifdef FEAT_MOUSESHAPE
	update_mouseshape(-1);
# endif
    }
#endif
    may_trigger_modechanged();

    // When not finishing an operator and no register name typed, reset the
    // count.
    if (!finish_op && !oap->regname)
    {
	ca.opcount = 0;
#ifdef FEAT_EVAL
	set_prevcount = TRUE;
#endif
    }

    // Restore counts from before receiving K_CURSORHOLD.  This means after
    // typing ""3"", handling K_CURSORHOLD and then typing ""2"" we get ""32"", not
    // ""3 * 2"".
    if (oap->prev_opcount > 0 || oap->prev_count0 > 0)
    {
	ca.opcount = oap->prev_opcount;
	ca.count0 = oap->prev_count0;
	oap->prev_opcount = 0;
	oap->prev_count0 = 0;
    }

    mapped_len = typebuf_maplen();

    State = MODE_NORMAL_BUSY;
#ifdef USE_ON_FLY_SCROLL
    dont_scroll = FALSE;	// allow scrolling here
#endif

#ifdef FEAT_EVAL
    // Set v:count here, when called from main() and not a stuffed
    // command, so that v:count can be used in an expression mapping
    // when there is no count. Do set it for redo.
    if (toplevel && readbuf1_empty())
	set_vcount_ca(&ca, &set_prevcount);
#endif

    /*
     * Get the command character from the user.
     */
    c = safe_vgetc();
    LANGMAP_ADJUST(c, get_real_state() != MODE_SELECT);

    // If a mapping was started in Visual or Select mode, remember the length
    // of the mapping.  This is used below to not return to Insert mode for as
    // long as the mapping is being executed.
    if (restart_edit == 0)
	old_mapped_len = 0;
    else if (old_mapped_len
		|| (VIsual_active && mapped_len == 0 && typebuf_maplen() > 0))
	old_mapped_len = typebuf_maplen();

    if (c == NUL)
	c = K_ZERO;

    // In Select mode, typed text replaces the selection.
    if (VIsual_active
	    && VIsual_select
	    && (vim_isprintc(c) || c == NL || c == CAR || c == K_KENTER))
    {
	int len;

	// Fake a ""c""hange command.  When ""restart_edit"" is set (e.g., because
	// 'insertmode' is set) fake a ""d""elete command, Insert mode will
	// restart automatically.
	// Insert the typed character in the typeahead buffer, so that it can
	// be mapped in Insert mode.  Required for "":lmap"" to work.
	len = ins_char_typebuf(vgetc_char, vgetc_mod_mask);

	// When recording and gotchars() was called the character will be
	// recorded again, remove the previous recording.
	if (KeyTyped)
	    ungetchars(len);

	if (restart_edit != 0)
	    c = 'd';
	else
	    c = 'c';
	msg_nowait = TRUE;	// don't delay going to insert mode
	old_mapped_len = 0;	// do go to Insert mode
    }

    // If the window was made so small that nothing shows, make it at least one
    // line and one column when typing a command.
    if (KeyTyped && !KeyStuffed)
	win_ensure_size();

    need_flushbuf = add_to_showcmd(c);

    // Get the command count
    c = normal_cmd_get_count(&ca, c, toplevel, set_prevcount, &ctrl_w,
							&need_flushbuf);

    // Find the command character in the table of commands.
    // For CTRL-W we already got nchar when looking for a count.
    if (ctrl_w)
    {
	ca.nchar = c;
	ca.cmdchar = Ctrl_W;
    }
    else
	ca.cmdchar = c;
    idx = find_command(ca.cmdchar);
    if (idx < 0)
    {
	// Not a known command: beep.
	clearopbeep(oap);
	goto normal_end;
    }

    if ((nv_cmds[idx].cmd_flags & NV_NCW) && check_text_or_curbuf_locked(oap))
	// this command is not allowed now
	goto normal_end;

    // In Visual/Select mode, a few keys are handled in a special way.
    if (VIsual_active)
    {
	// when 'keymodel' contains ""stopsel"" may stop Select/Visual mode
	if (km_stopsel
		&& (nv_cmds[idx].cmd_flags & NV_STS)
		&& !(mod_mask & MOD_MASK_SHIFT))
	{
	    end_visual_mode();
	    redraw_curbuf_later(UPD_INVERTED);
	}

	// Keys that work different when 'keymodel' contains ""startsel""
	if (km_startsel)
	{
	    if (nv_cmds[idx].cmd_flags & NV_SS)
	    {
		unshift_special(&ca);
		idx = find_command(ca.cmdchar);
		if (idx < 0)
		{
		    // Just in case
		    clearopbeep(oap);
		    goto normal_end;
		}
	    }
	    else if ((nv_cmds[idx].cmd_flags & NV_SSS)
					       && (mod_mask & MOD_MASK_SHIFT))
		mod_mask &= ~MOD_MASK_SHIFT;
	}
    }

#ifdef FEAT_RIGHTLEFT
    if (curwin->w_p_rl && KeyTyped && !KeyStuffed
					  && (nv_cmds[idx].cmd_flags & NV_RL))
    {
	// Invert horizontal movements and operations.  Only when typed by the
	// user directly, not when the result of a mapping or ""x"" translated
	// to ""dl"".
	switch (ca.cmdchar)
	{
	    case 'l':	    ca.cmdchar = 'h'; break;
	    case K_RIGHT:   ca.cmdchar = K_LEFT; break;
	    case K_S_RIGHT: ca.cmdchar = K_S_LEFT; break;
	    case K_C_RIGHT: ca.cmdchar = K_C_LEFT; break;
	    case 'h':	    ca.cmdchar = 'l'; break;
	    case K_LEFT:    ca.cmdchar = K_RIGHT; break;
	    case K_S_LEFT:  ca.cmdchar = K_S_RIGHT; break;
	    case K_C_LEFT:  ca.cmdchar = K_C_RIGHT; break;
	    case '>':	    ca.cmdchar = '<'; break;
	    case '<':	    ca.cmdchar = '>'; break;
	}
	idx = find_command(ca.cmdchar);
    }
#endif

    // Get additional characters if we need them.
    if (normal_cmd_needs_more_chars(&ca, nv_cmds[idx].cmd_flags))
	idx = normal_cmd_get_more_chars(idx, &ca, &need_flushbuf);

    // Flush the showcmd characters onto the screen so we can see them while
    // the command is being executed.  Only do this when the shown command was
    // actually displayed, otherwise this will slow down a lot when executing
    // mappings.
    if (need_flushbuf)
	out_flush();

    if (ca.cmdchar != K_IGNORE)
    {
	if (ex_normal_busy)
	    did_cursorhold = save_did_cursorhold;
	else
	    did_cursorhold = FALSE;
    }

    State = MODE_NORMAL;

    if (ca.nchar == ESC)
    {
	clearop(oap);
	if (restart_edit == 0 && goto_im())
	    restart_edit = 'a';
	goto normal_end;
    }

    if (ca.cmdchar != K_IGNORE)
    {
	msg_didout = FALSE;    // don't scroll screen up for normal command
	msg_col = 0;
    }

    old_pos = curwin->w_cursor;		// remember where cursor was

    // When 'keymodel' contains ""startsel"" some keys start Select/Visual
    // mode.
    if (!VIsual_active && km_startsel)
    {
	if (nv_cmds[idx].cmd_flags & NV_SS)
	{
	    start_selection();
	    unshift_special(&ca);
	    idx = find_command(ca.cmdchar);
	}
	else if ((nv_cmds[idx].cmd_flags & NV_SSS)
					   && (mod_mask & MOD_MASK_SHIFT))
	{
	    start_selection();
	    mod_mask &= ~MOD_MASK_SHIFT;
	}
    }

    // Execute the command!
    // Call the command function found in the commands table.
    ca.arg = nv_cmds[idx].cmd_arg;
    (nv_cmds[idx].cmd_func)(&ca);

    // If we didn't start or finish an operator, reset oap->regname, unless we
    // need it later.
    if (!finish_op
	    && !oap->op_type
	    && (idx < 0 || !(nv_cmds[idx].cmd_flags & NV_KEEPREG)))
    {
	clearop(oap);
#ifdef FEAT_EVAL
	reset_reg_var();
#endif
    }

    // Get the length of mapped chars again after typing a count, second
    // character or ""z333<cr>"".
    if (old_mapped_len > 0)
	old_mapped_len = typebuf_maplen();

    // If an operation is pending, handle it.  But not for K_IGNORE or
    // K_MOUSEMOVE.
    if (ca.cmdchar != K_IGNORE && ca.cmdchar != K_MOUSEMOVE)
	do_pending_operator(&ca, old_col, FALSE);

    // Wait for a moment when a message is displayed that will be overwritten
    // by the mode message.
    if (normal_cmd_need_to_wait_for_msg(&ca, &old_pos))
	normal_cmd_wait_for_msg();

    // Finish up after executing a Normal mode command.
normal_end:

    msg_nowait = FALSE;

#ifdef FEAT_EVAL
    if (finish_op)
	reset_reg_var();
#endif

    // Reset finish_op, in case it was set
#ifdef CURSOR_SHAPE
    c = finish_op;
#endif
    finish_op = FALSE;
    may_trigger_modechanged();
#ifdef CURSOR_SHAPE
    // Redraw the cursor with another shape, if we were in Operator-pending
    // mode or did a replace command.
    if (c || ca.cmdchar == 'r')
    {
	ui_cursor_shape();		// may show different cursor shape
# ifdef FEAT_MOUSESHAPE
	update_mouseshape(-1);
# endif
    }
#endif

    if (oap->op_type == OP_NOP && oap->regname == 0
	    && ca.cmdchar != K_CURSORHOLD)
	clear_showcmd();

    checkpcmark();		// check if we moved since setting pcmark
    vim_free(ca.searchbuf);

    if (has_mbyte)
	mb_adjust_cursor();

    if (curwin->w_p_scb && toplevel)
    {
	validate_cursor();	// may need to update w_leftcol
	do_check_scrollbind(TRUE);
    }

    if (curwin->w_p_crb && toplevel)
    {
	validate_cursor();	// may need to update w_leftcol
	do_check_cursorbind();
    }

#ifdef FEAT_TERMINAL
    // don't go to Insert mode if a terminal has a running job
    if (term_job_running(curbuf->b_term))
	restart_edit = 0;
#endif

    // May restart edit(), if we got here with CTRL-O in Insert mode (but not
    // if still inside a mapping that started in Visual mode).
    // May switch from Visual to Select mode after CTRL-O command.
    if (       oap->op_type == OP_NOP
	    && ((restart_edit != 0 && !VIsual_active && old_mapped_len == 0)
		|| restart_VIsual_select == 1)
	    && !(ca.retval & CA_COMMAND_BUSY)
	    && stuff_empty()
	    && oap->regname == 0)
    {
	if (restart_VIsual_select == 1)
	{
	    VIsual_select = TRUE;
	    may_trigger_modechanged();
	    showmode();
	    restart_VIsual_select = 0;
	    VIsual_select_reg = 0;
	}
	if (restart_edit != 0 && !VIsual_active && old_mapped_len == 0)
	    (void)edit(restart_edit, FALSE, 1L);
    }

    if (restart_VIsual_select == 2)
	restart_VIsual_select = 1;

    // Save count before an operator for next time.
    opcount = ca.opcount;
}","void
normal_cmd(
    oparg_T	*VAR_0,
    int		VAR_1 UNUSED)	/* COMMENT_0 */
{
    cmdarg_T	VAR_2;			/* COMMENT_1 */
    int		VAR_3;
    int		VAR_4 = FALSE;		/* COMMENT_2 */
    int		VAR_5 = VAR_6->w_curswant;
    int		VAR_7 = FALSE;	/* COMMENT_3 */
    pos_T	VAR_8;		/* COMMENT_4 */
    int		VAR_9;
    static int	VAR_10 = 0;
    int		VAR_11;
    int		VAR_12 = FALSE;
    int		VAR_13 = VAR_14;

    CLEAR_FIELD(VAR_2);	/* COMMENT_5 */
    VAR_2.oap = VAR_0;

    /* COMMENT_6 */
    /* COMMENT_7 */
    /* COMMENT_8 */
    VAR_2.opcount = VAR_15;

    /* COMMENT_9 */
    /* COMMENT_10 */
    /* COMMENT_11 */
#ifdef VAR_16
    VAR_3 = VAR_17;
#endif
    VAR_17 = (VAR_0->op_type != VAR_18);
#ifdef VAR_16
    if (VAR_17 != VAR_3)
    {
	ui_cursor_shape();		/* COMMENT_12 */
# ifdef VAR_19
	update_mouseshape(-1);
# endif
    }
#endif
    may_trigger_modechanged();

    /* COMMENT_13 */
    /* COMMENT_14 */
    if (!VAR_17 && !VAR_0->regname)
    {
	VAR_2.opcount = 0;
#ifdef VAR_20
	VAR_12 = TRUE;
#endif
    }

    /* COMMENT_15 */
    /* COMMENT_16 */
    /* COMMENT_17 */
    if (VAR_0->prev_opcount > 0 || VAR_0->prev_count0 > 0)
    {
	VAR_2.opcount = VAR_0->prev_opcount;
	VAR_2.count0 = VAR_0->prev_count0;
	VAR_0->prev_opcount = 0;
	VAR_0->prev_count0 = 0;
    }

    VAR_9 = typebuf_maplen();

    VAR_21 = VAR_22;
#ifdef VAR_23
    VAR_24 = FALSE;	/* COMMENT_18 */
#endif

#ifdef VAR_20
    /* COMMENT_19 */
    /* COMMENT_20 */
    /* COMMENT_21 */
    if (VAR_1 && readbuf1_empty())
	set_vcount_ca(&VAR_2, &VAR_12);
#endif

    /* COMMENT_22 */
                                               
       
    VAR_3 = safe_vgetc();
    LANGMAP_ADJUST(VAR_3, get_real_state() != VAR_25);

    /* COMMENT_25 */
    /* COMMENT_26 */
    /* COMMENT_27 */
    if (VAR_26 == 0)
	VAR_10 = 0;
    else if (VAR_10
		|| (VAR_27 && VAR_9 == 0 && typebuf_maplen() > 0))
	VAR_10 = typebuf_maplen();

    if (VAR_3 == VAR_28)
	VAR_3 = VAR_29;

    /* COMMENT_28 */
    if (VAR_27
	    && VAR_30
	    && (vim_isprintc(VAR_3) || VAR_3 == VAR_31 || VAR_3 == VAR_32 || VAR_3 == VAR_33))
    {
	int VAR_34;

	/* COMMENT_29 */
	/* COMMENT_30 */
	/* COMMENT_31 */
	/* COMMENT_32 */
	/* COMMENT_33 */
	VAR_34 = ins_char_typebuf(VAR_35, VAR_36);

	/* COMMENT_34 */
	/* COMMENT_35 */
	if (VAR_37)
	    ungetchars(VAR_34);

	if (VAR_26 != 0)
	    VAR_3 = 'd';
	else
	    VAR_3 = 'c';
	VAR_38 = TRUE;	/* COMMENT_36 */
	VAR_10 = 0;	/* COMMENT_37 */
    }

    /* COMMENT_38 */
    /* COMMENT_39 */
    if (VAR_37 && !VAR_39)
	win_ensure_size();

    VAR_7 = add_to_showcmd(VAR_3);

    /* COMMENT_40 */
    VAR_3 = normal_cmd_get_count(&VAR_2, VAR_3, VAR_1, VAR_12, &VAR_4,
							&VAR_7);

    /* COMMENT_41 */
    /* COMMENT_42 */
    if (VAR_4)
    {
	VAR_2.nchar = VAR_3;
	VAR_2.cmdchar = VAR_40;
    }
    else
	VAR_2.cmdchar = VAR_3;
    VAR_11 = find_command(VAR_2.cmdchar);
    if (VAR_11 < 0)
    {
	/* COMMENT_43 */
	clearopbeep(VAR_0);
	goto normal_end;
    }

    if ((VAR_41[VAR_11].cmd_flags & VAR_42) && check_text_or_curbuf_locked(VAR_0))
	/* COMMENT_44 */
	goto normal_end;

    /* COMMENT_45 */
    if (VAR_27)
    {
	/* COMMENT_46 */
	if (VAR_43
		&& (VAR_41[VAR_11].cmd_flags & VAR_44)
		&& !(VAR_45 & VAR_46))
	{
	    end_visual_mode();
	    redraw_curbuf_later(VAR_47);
	}

	/* COMMENT_47 */
	if (VAR_48)
	{
	    if (VAR_41[VAR_11].cmd_flags & VAR_49)
	    {
		unshift_special(&VAR_2);
		VAR_11 = find_command(VAR_2.cmdchar);
		if (VAR_11 < 0)
		{
		    /* COMMENT_48 */
		    clearopbeep(VAR_0);
		    goto normal_end;
		}
	    }
	    else if ((VAR_41[VAR_11].cmd_flags & VAR_50)
					       && (VAR_45 & VAR_46))
		VAR_45 &= ~VAR_46;
	}
    }

#ifdef VAR_51
    if (VAR_6->w_p_rl && VAR_37 && !VAR_39
					  && (VAR_41[VAR_11].cmd_flags & VAR_52))
    {
	/* COMMENT_49 */
	/* COMMENT_50 */
	/* COMMENT_51 */
	switch (VAR_2.cmdchar)
	{
	    case 'l':	    VAR_2.cmdchar = 'h'; break;
	    case VAR_53:   VAR_2.cmdchar = VAR_54; break;
	    case VAR_55: VAR_2.cmdchar = VAR_56; break;
	    case VAR_57: VAR_2.cmdchar = VAR_58; break;
	    case 'h':	    VAR_2.cmdchar = 'l'; break;
	    case VAR_54:    VAR_2.cmdchar = VAR_53; break;
	    case VAR_56:  VAR_2.cmdchar = VAR_55; break;
	    case VAR_58:  VAR_2.cmdchar = VAR_57; break;
	    case '>':	    VAR_2.cmdchar = '<'; break;
	    case '<':	    VAR_2.cmdchar = '>'; break;
	}
	VAR_11 = find_command(VAR_2.cmdchar);
    }
#endif

    /* COMMENT_52 */
    if (normal_cmd_needs_more_chars(&VAR_2, VAR_41[VAR_11].cmd_flags))
	VAR_11 = normal_cmd_get_more_chars(VAR_11, &VAR_2, &VAR_7);

    /* COMMENT_53 */
    /* COMMENT_54 */
    /* COMMENT_55 */
    /* COMMENT_56 */
    if (VAR_7)
	out_flush();

    if (VAR_2.cmdchar != VAR_59)
    {
	if (VAR_60)
	    VAR_14 = VAR_13;
	else
	    VAR_14 = FALSE;
    }

    VAR_21 = VAR_61;

    if (VAR_2.nchar == VAR_62)
    {
	clearop(VAR_0);
	if (VAR_26 == 0 && goto_im())
	    VAR_26 = 'a';
	goto normal_end;
    }

    if (VAR_2.cmdchar != VAR_59)
    {
	VAR_63 = FALSE;    /* COMMENT_57 */
	VAR_64 = 0;
    }

    VAR_8 = VAR_6->w_cursor;		/* COMMENT_58 */

    /* COMMENT_59 */
    /* COMMENT_60 */
    if (!VAR_27 && VAR_48)
    {
	if (VAR_41[VAR_11].cmd_flags & VAR_49)
	{
	    start_selection();
	    unshift_special(&VAR_2);
	    VAR_11 = find_command(VAR_2.cmdchar);
	}
	else if ((VAR_41[VAR_11].cmd_flags & VAR_50)
					   && (VAR_45 & VAR_46))
	{
	    start_selection();
	    VAR_45 &= ~VAR_46;
	}
    }

    /* COMMENT_61 */
    /* COMMENT_62 */
    VAR_2.arg = VAR_41[VAR_11].cmd_arg;
    (VAR_41[VAR_11].cmd_func)(&VAR_2);

    /* COMMENT_63 */
    /* COMMENT_64 */
    if (!VAR_17
	    && !VAR_0->op_type
	    && (VAR_11 < 0 || !(VAR_41[VAR_11].cmd_flags & VAR_65)))
    {
	clearop(VAR_0);
#ifdef VAR_20
	reset_reg_var();
#endif
    }

    /* COMMENT_65 */
    /* COMMENT_66 */
    if (VAR_10 > 0)
	VAR_10 = typebuf_maplen();

    /* COMMENT_67 */
    /* COMMENT_68 */
    if (VAR_2.cmdchar != VAR_59 && VAR_2.cmdchar != VAR_66)
	do_pending_operator(&VAR_2, VAR_5, FALSE);

    /* COMMENT_69 */
    /* COMMENT_70 */
    if (normal_cmd_need_to_wait_for_msg(&VAR_2, &VAR_8))
	normal_cmd_wait_for_msg();

    /* COMMENT_71 */
normal_end:

    VAR_38 = FALSE;

#ifdef VAR_20
    if (VAR_17)
	reset_reg_var();
#endif

    /* COMMENT_72 */
#ifdef VAR_16
    VAR_3 = VAR_17;
#endif
    VAR_17 = FALSE;
    may_trigger_modechanged();
#ifdef VAR_16
    /* COMMENT_73 */
    /* COMMENT_74 */
    if (VAR_3 || VAR_2.cmdchar == 'r')
    {
	ui_cursor_shape();		/* COMMENT_12 */
# ifdef VAR_19
	update_mouseshape(-1);
# endif
    }
#endif

    if (VAR_0->op_type == VAR_18 && VAR_0->regname == 0
	    && VAR_2.cmdchar != VAR_67)
	clear_showcmd();

    checkpcmark();		/* COMMENT_75 */
    vim_free(VAR_2.searchbuf);

    if (VAR_68)
	mb_adjust_cursor();

    if (VAR_6->w_p_scb && VAR_1)
    {
	validate_cursor();	/* COMMENT_76 */
	do_check_scrollbind(TRUE);
    }

    if (VAR_6->w_p_crb && VAR_1)
    {
	validate_cursor();	/* COMMENT_76 */
	do_check_cursorbind();
    }

#ifdef VAR_69
    /* COMMENT_77 */
    if (term_job_running(VAR_70->b_term))
	VAR_26 = 0;
#endif

    /* COMMENT_78 */
    /* COMMENT_79 */
    /* COMMENT_80 */
    if (       VAR_0->op_type == VAR_18
	    && ((VAR_26 != 0 && !VAR_27 && VAR_10 == 0)
		|| VAR_71 == 1)
	    && !(VAR_2.retval & VAR_72)
	    && stuff_empty()
	    && VAR_0->regname == 0)
    {
	if (VAR_71 == 1)
	{
	    VAR_30 = TRUE;
	    may_trigger_modechanged();
	    showmode();
	    VAR_71 = 0;
	    VAR_73 = 0;
	}
	if (VAR_26 != 0 && !VAR_27 && VAR_10 == 0)
	    (void)edit(VAR_26, FALSE, 1L);
    }

    if (VAR_71 == 2)
	VAR_71 = 1;

    /* COMMENT_81 */
    VAR_15 = VAR_2.opcount;
}",,"--- func_before
+++ func_after
@@ -150,8 +150,7 @@
 	goto normal_end;
     }
 
-    if ((nv_cmds[idx].cmd_flags & NV_NCW)
-				&& (check_text_locked(oap) || curbuf_locked()))
+    if ((nv_cmds[idx].cmd_flags & NV_NCW) && check_text_or_curbuf_locked(oap))
 	// this command is not allowed now
 	goto normal_end;
 ","{'deleted_lines': ['    if ((nv_cmds[idx].cmd_flags & NV_NCW)', '\t\t\t\t&& (check_text_locked(oap) || curbuf_locked()))'], 'added_lines': ['    if ((nv_cmds[idx].cmd_flags & NV_NCW) && check_text_or_curbuf_locked(oap))']}",True,Heap based buffer overflow in vim/vim 9.0.0946 and below by allowing an attacker to CTRL-W gf in the expression used in the RHS of the substitute command.,7.8,HIGH,2,test,2022-11-25T13:03:31Z,4
CVE-2022-4141,['CWE-122'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,vim,"patch 9.0.0947: invalid memory access in substitute with function

Problem:    Invalid memory access in substitute with function that goes to
            another file.
Solution:   Check for text locked in CTRL-W gf.",cc762a48d42b579fb7bdec2c614636b830342dd5,https://github.com/vim/vim/commit/cc762a48d42b579fb7bdec2c614636b830342dd5,src/normal.c,check_text_locked,"static int
check_text_locked(oparg_T *oap)
{
if (text_locked())
{
clearopbeep(oap);
text_locked_msg();
return TRUE;
}
return FALSE;
}","static int
check_text_locked(oparg_T *VAR_0)
{
if (text_locked())
{
clearopbeep(VAR_0);
text_locked_msg();
return TRUE;
}
return FALSE;
}",vim/cc762a48d42b579fb7bdec2c614636b830342dd5/normal.c/vul/before/0.json,"static int
check_text_locked(oparg_T *oap)
{
    if (text_locked())
    {
	if (oap != NULL)
	    clearopbeep(oap);
	text_locked_msg();
	return TRUE;
    }
    return FALSE;
}","static int
check_text_locked(oparg_T *VAR_0)
{
    if (text_locked())
    {
	if (VAR_0 != NULL)
	    clearopbeep(VAR_0);
	text_locked_msg();
	return TRUE;
    }
    return FALSE;
}",vim/cc762a48d42b579fb7bdec2c614636b830342dd5/normal.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,7 +3,8 @@
 {
     if (text_locked())
     {
-	clearopbeep(oap);
+	if (oap != NULL)
+	    clearopbeep(oap);
 	text_locked_msg();
 	return TRUE;
     }","{'deleted_lines': ['\tclearopbeep(oap);'], 'added_lines': ['\tif (oap != NULL)', '\t    clearopbeep(oap);']}",True,Heap based buffer overflow in vim/vim 9.0.0946 and below by allowing an attacker to CTRL-W gf in the expression used in the RHS of the substitute command.,7.8,HIGH,2,test,2022-11-25T13:03:31Z,4
CVE-2022-4141,['CWE-122'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,vim,"patch 9.0.0947: invalid memory access in substitute with function

Problem:    Invalid memory access in substitute with function that goes to
            another file.
Solution:   Check for text locked in CTRL-W gf.",cc762a48d42b579fb7bdec2c614636b830342dd5,https://github.com/vim/vim/commit/cc762a48d42b579fb7bdec2c614636b830342dd5,src/window.c,do_window,"void
do_window(
intnchar,
longPrenum,
intxchar)    {
longPrenum1;
win_T*wp;
char_u*ptr;
linenr_T    lnum = -1;
#ifdef FEAT_FIND_ID
inttype = FIND_DEFINE;
intlen;
#endif
char_ucbuf[40];
if (ERROR_IF_ANY_POPUP_WINDOW)
return;
#define CHECK_CMDWIN \
do { \
if (cmdwin_type != 0) \
{ \
emsg(_(e_invalid_in_cmdline_window)); \
return; \
} \
} while (0)
Prenum1 = Prenum == 0 ? 1 : Prenum;
switch (nchar)
{
case 'S':
case Ctrl_S:
case 's':
CHECK_CMDWIN;
reset_VIsual_and_resel();if (bt_quickfix(curbuf))
goto newwindow;
#ifdef FEAT_GUI
need_mouse_correct = TRUE;
#endif
(void)win_split((int)Prenum, 0);
break;
case Ctrl_V:
case 'v':
CHECK_CMDWIN;
reset_VIsual_and_resel();if (bt_quickfix(curbuf))
goto newwindow;
#ifdef FEAT_GUI
need_mouse_correct = TRUE;
#endif
(void)win_split((int)Prenum, WSP_VERT);
break;
case Ctrl_HAT:
case '^':
CHECK_CMDWIN;
reset_VIsual_and_resel();
if (buflist_findnr(Prenum == 0
? curwin->w_alt_fnum : Prenum) == NULL)
{
if (Prenum == 0)
emsg(_(e_no_alternate_file));
else
semsg(_(e_buffer_nr_not_found), Prenum);
break;
}
if (!curbuf_locked() && win_split(0, 0) == OK)
(void)buflist_getfile(
Prenum == 0 ? curwin->w_alt_fnum : Prenum,
(linenr_T)0, GETF_ALT, FALSE);
break;
case Ctrl_N:
case 'n':
CHECK_CMDWIN;
reset_VIsual_and_resel();newwindow:
if (Prenum)
vim_snprintf((char *)cbuf, sizeof(cbuf) - 5, ""%ld"", Prenum);
else
cbuf[0] = NUL;
#if defined(FEAT_QUICKFIX)
if (nchar == 'v' || nchar == Ctrl_V)
STRCAT(cbuf, ""v"");
#endif
STRCAT(cbuf, ""new"");
do_cmdline_cmd(cbuf);
break;
case Ctrl_Q:
case 'q':
reset_VIsual_and_resel();cmd_with_count(""quit"", cbuf, sizeof(cbuf), Prenum);
do_cmdline_cmd(cbuf);
break;
case Ctrl_C:
case 'c':
reset_VIsual_and_resel();cmd_with_count(""close"", cbuf, sizeof(cbuf), Prenum);
do_cmdline_cmd(cbuf);
break;
#if defined(FEAT_QUICKFIX)
case Ctrl_Z:
case 'z':
CHECK_CMDWIN;
reset_VIsual_and_resel();do_cmdline_cmd((char_u *)""pclose"");
break;
case 'P':
FOR_ALL_WINDOWS(wp)
if (wp->w_p_pvw)
break;
if (wp == NULL)
emsg(_(e_there_is_no_preview_window));
else
win_goto(wp);
break;
#endif
case Ctrl_O:
case 'o':
CHECK_CMDWIN;
reset_VIsual_and_resel();cmd_with_count(""only"", cbuf, sizeof(cbuf), Prenum);
do_cmdline_cmd(cbuf);
break;
case Ctrl_W:
case 'w':
case 'W':
CHECK_CMDWIN;
if (ONE_WINDOW && Prenum != 1)    beep_flush();
else
{
if (Prenum)    {
for (wp = firstwin; --Prenum > 0; )
{
if (wp->w_next == NULL)
break;
else
wp = wp->w_next;
}
}
else
{
if (nchar == 'W')    {
wp = curwin->w_prev;
if (wp == NULL)
wp = lastwin;    }
else    {
wp = curwin->w_next;
if (wp == NULL)
wp = firstwin;    }
}
win_goto(wp);
}
break;
case 'j':
case K_DOWN:
case Ctrl_J:
CHECK_CMDWIN;
win_goto_ver(FALSE, Prenum1);
break;
case 'k':
case K_UP:
case Ctrl_K:
CHECK_CMDWIN;
win_goto_ver(TRUE, Prenum1);
break;
case 'h':
case K_LEFT:
case Ctrl_H:
case K_BS:
CHECK_CMDWIN;
win_goto_hor(TRUE, Prenum1);
break;
case 'l':
case K_RIGHT:
case Ctrl_L:
CHECK_CMDWIN;
win_goto_hor(FALSE, Prenum1);
break;
case 'T':
CHECK_CMDWIN;
if (one_window())
msg(_(m_onlyone));
else
{
tabpage_T*oldtab = curtab;
tabpage_T*newtab;
wp = curwin;
if (win_new_tabpage((int)Prenum) == OK
&& valid_tabpage(oldtab))
{
newtab = curtab;
goto_tabpage_tp(oldtab, TRUE, TRUE);
if (curwin == wp)
win_close(curwin, FALSE);
if (valid_tabpage(newtab))
goto_tabpage_tp(newtab, TRUE, TRUE);
}
}
break;
case 't':
case Ctrl_T:
win_goto(firstwin);
break;
case 'b':
case Ctrl_B:
win_goto(lastwin);
break;
case 'p':
case Ctrl_P:
if (!win_valid(prevwin))
beep_flush();
else
win_goto(prevwin);
break;
case 'x':
case Ctrl_X:
CHECK_CMDWIN;
win_exchange(Prenum);
break;
case Ctrl_R:
case 'r':
CHECK_CMDWIN;
reset_VIsual_and_resel();win_rotate(FALSE, (int)Prenum1);    break;
case 'R':
CHECK_CMDWIN;
reset_VIsual_and_resel();win_rotate(TRUE, (int)Prenum1);    break;
case 'K':
case 'J':
case 'H':
case 'L':
CHECK_CMDWIN;
win_totop((int)Prenum,
((nchar == 'H' || nchar == 'L') ? WSP_VERT : 0)
| ((nchar == 'H' || nchar == 'K') ? WSP_TOP : WSP_BOT));
break;
case '=':
{
int mod = cmdmod.cmod_split & (WSP_VERT | WSP_HOR);
#ifdef FEAT_GUI
need_mouse_correct = TRUE;
#endif
win_equal(NULL, FALSE,
mod == WSP_VERT ? 'v' : mod == WSP_HOR ? 'h' : 'b');
}
break;
case '+':
#ifdef FEAT_GUI
need_mouse_correct = TRUE;
#endif
win_setheight(curwin->w_height + (int)Prenum1);
break;
case '-':
#ifdef FEAT_GUI
need_mouse_correct = TRUE;
#endif
win_setheight(curwin->w_height - (int)Prenum1);
break;
case Ctrl__:
case '_':
#ifdef FEAT_GUI
need_mouse_correct = TRUE;
#endif
win_setheight(Prenum ? (int)Prenum : 9999);
break;
case '>':
#ifdef FEAT_GUI
need_mouse_correct = TRUE;
#endif
win_setwidth(curwin->w_width + (int)Prenum1);
break;
case '<':
#ifdef FEAT_GUI
need_mouse_correct = TRUE;
#endif
win_setwidth(curwin->w_width - (int)Prenum1);
break;
case '|':
#ifdef FEAT_GUI
need_mouse_correct = TRUE;
#endif
win_setwidth(Prenum != 0 ? (int)Prenum : 9999);
break;
#if defined(FEAT_QUICKFIX)
case '}':
CHECK_CMDWIN;
if (Prenum)
g_do_tagpreview = Prenum;
else
g_do_tagpreview = p_pvh;
#endif
case ']':
case Ctrl_RSB:
CHECK_CMDWIN;
if (Prenum)
postponed_split = Prenum;
else
postponed_split = -1;
#ifdef FEAT_QUICKFIX
if (nchar != '}')
g_do_tagpreview = 0;
#endif
do_nv_ident(Ctrl_RSB, NUL);
break;
case 'f':
case 'F':
case Ctrl_F:
wingotofile:
CHECK_CMDWIN;
ptr = grab_file_name(Prenum1, &lnum);
if (ptr != NULL)
{
tabpage_T*oldtab = curtab;
win_T*oldwin = curwin;
#ifdef FEAT_GUI
need_mouse_correct = TRUE;
#endif
setpcmark();
if (win_split(0, 0) == OK)
{
RESET_BINDING(curwin);
if (do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL,
ECMD_HIDE, NULL) == FAIL)
{
win_close(curwin, FALSE);
goto_tabpage_win(oldtab, oldwin);
}
else if (nchar == 'F' && lnum >= 0)
{
curwin->w_cursor.lnum = lnum;
check_cursor_lnum();
beginline(BL_SOL | BL_FIX);
}
}
vim_free(ptr);
}
break;
#ifdef FEAT_FIND_ID
case 'i':        case Ctrl_I:
type = FIND_ANY;
case 'd':        case Ctrl_D:
CHECK_CMDWIN;
if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)
break;
ptr = vim_strnsave(ptr, len);
if (ptr == NULL)
break;
find_pattern_in_path(ptr, 0, len, TRUE,
Prenum == 0 ? TRUE : FALSE, type,
Prenum1, ACTION_SPLIT, (linenr_T)1, (linenr_T)MAXLNUM);
vim_free(ptr);
curwin->w_set_curswant = TRUE;
break;
#endif
#if defined(FEAT_QUICKFIX)
case K_KENTER:
case CAR:
if (bt_quickfix(curbuf))
qf_view_result(TRUE);
break;
#endif
case 'g':
case Ctrl_G:
CHECK_CMDWIN;
#ifdef USE_ON_FLY_SCROLL
dont_scroll = TRUE;#endif
++no_mapping;
++allow_keys;   if (xchar == NUL)
xchar = plain_vgetc();
LANGMAP_ADJUST(xchar, TRUE);
--no_mapping;
--allow_keys;
(void)add_to_showcmd(xchar);
switch (xchar)
{
#if defined(FEAT_QUICKFIX)
case '}':
xchar = Ctrl_RSB;
if (Prenum)
g_do_tagpreview = Prenum;
else
g_do_tagpreview = p_pvh;
#endif
case ']':
case Ctrl_RSB:
if (Prenum)
postponed_split = Prenum;
else
postponed_split = -1;
do_nv_ident('g', xchar);
break;
case 'f':        case 'F':    cmdmod.cmod_tab = tabpage_index(curtab) + 1;
nchar = xchar;
goto wingotofile;
case 't':    goto_tabpage((int)Prenum);
break;
case 'T':    goto_tabpage(-(int)Prenum1);
break;
case TAB:    if (goto_tabpage_lastused() == FAIL)
beep_flush();
break;
default:
beep_flush();
break;
}
break;
default:beep_flush();
break;
}
}","void
do_window(
intVAR_0,
longVAR_1,
intVAR_2)    
{
longVAR_3;
win_T*VAR_4;
char_u*VAR_5;
linenr_T    VAR_6 = -1;
#ifdef VAR_7
intVAR_8 = VAR_9;
intVAR_10;
#endif
char_uVAR_11[40];
if (VAR_12)
return;
#define VAR_13 \
do { \
if (cmdwin_type != 0) \
{ \
emsg(_(e_invalid_in_cmdline_window)); \
return; \
} \
} while (0)
VAR_3 = VAR_1 == 0 ? 1 : VAR_1;
switch (VAR_0)
{
case 'S':
case VAR_14:
case 's':
VAR_13;
reset_VIsual_and_resel();
if (bt_quickfix(VAR_15))
goto newwindow;
#ifdef VAR_16
VAR_17 = TRUE;
#endif
(void)win_split((int)VAR_1, 0);
break;
case VAR_18:
case 'v':
VAR_13;
reset_VIsual_and_resel();
if (bt_quickfix(VAR_15))
goto newwindow;
#ifdef VAR_16
VAR_17 = TRUE;
#endif
(void)win_split((int)VAR_1, VAR_19);
break;
case VAR_20:
case '^':
VAR_13;
reset_VIsual_and_resel();
if (buflist_findnr(VAR_1 == 0
? VAR_21->w_alt_fnum : VAR_1) == NULL)
{
if (VAR_1 == 0)
emsg(_(VAR_22));
else
semsg(_(VAR_23), VAR_1);
break;
}
if (!curbuf_locked() && win_split(0, 0) == VAR_24)
(void)buflist_getfile(
VAR_1 == 0 ? VAR_21->w_alt_fnum : VAR_1,
(linenr_T)0, VAR_25, FALSE);
break;
case VAR_26:
case 'n':
VAR_13;
reset_VIsual_and_resel();
newwindow:
if (VAR_1)
vim_snprintf((char *)VAR_11, sizeof(VAR_11) - 5, ""%ld"", VAR_1);
else
VAR_11[0] = VAR_27;
#if defined(VAR_28)
if (VAR_0 == 'v' || VAR_0 == VAR_18)
STRCAT(VAR_11, ""v"");
#endif
STRCAT(VAR_11, ""new"");
do_cmdline_cmd(VAR_11);
break;
case VAR_29:
case 'q':
reset_VIsual_and_resel();
cmd_with_count(""quit"", VAR_11, sizeof(VAR_11), VAR_1);
do_cmdline_cmd(VAR_11);
break;
case VAR_30:
case 'c':
reset_VIsual_and_resel();
cmd_with_count(""close"", VAR_11, sizeof(VAR_11), VAR_1);
do_cmdline_cmd(VAR_11);
break;
#if defined(VAR_28)
case VAR_31:
case 'z':
VAR_13;
reset_VIsual_and_resel();
do_cmdline_cmd((char_u *)""pclose"");
break;
case 'P':
VAR_32(wp)
if (wp->VAR_33)
break;
if (wp == NULL)
emsg(_(VAR_34));
else
win_goto(wp);
break;
#endif
case VAR_35:
case 'o':
VAR_13;
reset_VIsual_and_resel();
cmd_with_count(""only"", VAR_11, sizeof(VAR_11), VAR_1);
do_cmdline_cmd(VAR_11);
break;
case VAR_36:
case 'w':
case 'W':
VAR_13;
if (VAR_37 && VAR_1 != 1)
beep_flush();
else
{
if (VAR_1)
{
for (wp = VAR_38; --VAR_1 > 0; )
{
if (wp->w_next == NULL)
break;
else
wp = wp->w_next;
}
}
else
{
if (VAR_0 == 'W')    
{
wp = VAR_21->w_prev;
if (wp == NULL)
wp = VAR_39;    
}
else    
{
wp = VAR_21->w_next;
if (wp == NULL)
wp = VAR_38;    
}
}
win_goto(wp);
}
break;
case 'j':
case VAR_40:
case VAR_41:
VAR_13;
win_goto_ver(FALSE, VAR_3);
break;
case 'k':
case VAR_42:
case VAR_43:
VAR_13;
win_goto_ver(TRUE, VAR_3);
break;
case 'h':
case VAR_44:
case VAR_45:
case VAR_46:
VAR_13;
win_goto_hor(TRUE, VAR_3);
break;
case 'l':
case VAR_47:
case VAR_48:
VAR_13;
win_goto_hor(FALSE, VAR_3);
break;
case 'T':
VAR_13;
if (one_window())
msg(_(VAR_49));
else
{
tabpage_T*VAR_50 = VAR_51;
tabpage_T*VAR_52;
wp = VAR_21;
if (win_new_tabpage((int)VAR_1) == VAR_24
&& valid_tabpage(VAR_50))
{
VAR_52 = VAR_51;
goto_tabpage_tp(VAR_50, TRUE, TRUE);
if (VAR_21 == wp)
win_close(VAR_21, FALSE);
if (valid_tabpage(VAR_52))
goto_tabpage_tp(VAR_52, TRUE, TRUE);
}
}
break;
case 't':
case VAR_53:
win_goto(VAR_38);
break;
case 'b':
case VAR_54:
win_goto(VAR_39);
break;
case 'p':
case VAR_55:
if (!win_valid(VAR_56))
beep_flush();
else
win_goto(VAR_56);
break;
case 'x':
case VAR_57:
VAR_13;
win_exchange(VAR_1);
break;
case VAR_58:
case 'r':
VAR_13;
reset_VIsual_and_resel();
win_rotate(FALSE, (int)VAR_3);    
break;
case 'R':
VAR_13;
reset_VIsual_and_resel();
win_rotate(TRUE, (int)VAR_3);    
break;
case 'K':
case 'J':
case 'H':
case 'L':
VAR_13;
win_totop((int)VAR_1,
((VAR_0 == 'H' || VAR_0 == 'L') ? VAR_19 : 0)
| ((VAR_0 == 'H' || VAR_0 == 'K') ? VAR_59 : VAR_60));
break;
case '=':
{
int VAR_61 = VAR_62.cmod_split & (VAR_19 | VAR_63);
#ifdef VAR_16
VAR_17 = TRUE;
#endif
win_equal(NULL, FALSE,
VAR_61 == VAR_19 ? 'v' : VAR_61 == VAR_63 ? 'h' : 'b');
}
break;
case '+':
#ifdef VAR_16
VAR_17 = TRUE;
#endif
win_setheight(VAR_21->w_height + (int)VAR_3);
break;
case '-':
#ifdef VAR_16
VAR_17 = TRUE;
#endif
win_setheight(VAR_21->w_height - (int)VAR_3);
break;
case VAR_64:
case '_':
#ifdef VAR_16
VAR_17 = TRUE;
#endif
win_setheight(VAR_1 ? (int)VAR_1 : 9999);
break;
case '>':
#ifdef VAR_16
VAR_17 = TRUE;
#endif
win_setwidth(VAR_21->w_width + (int)VAR_3);
break;
case '<':
#ifdef VAR_16
VAR_17 = TRUE;
#endif
win_setwidth(VAR_21->w_width - (int)VAR_3);
break;
case '|':
#ifdef VAR_16
VAR_17 = TRUE;
#endif
win_setwidth(VAR_1 != 0 ? (int)VAR_1 : 9999);
break;
#if defined(VAR_28)
case '}':
VAR_13;
if (VAR_1)
VAR_65 = VAR_1;
else
VAR_65 = VAR_66;
#endif
case ']':
case VAR_67:
VAR_13;
if (VAR_1)
VAR_68 = VAR_1;
else
VAR_68 = -1;
#ifdef VAR_28
if (VAR_0 != '}')
VAR_65 = 0;
#endif
do_nv_ident(VAR_67, VAR_27);
break;
case 'f':
case 'F':
case VAR_69:
wingotofile:
VAR_13;
VAR_5 = grab_file_name(VAR_3, &VAR_6);
if (VAR_5 != NULL)
{
tabpage_T*VAR_50 = VAR_51;
win_T*VAR_70 = VAR_21;
#ifdef VAR_16
VAR_17 = TRUE;
#endif
setpcmark();
if (win_split(0, 0) == VAR_24)
{
RESET_BINDING(VAR_21);
if (do_ecmd(0, VAR_5, NULL, NULL, VAR_71,
VAR_72, NULL) == VAR_73)
{
win_close(VAR_21, FALSE);
goto_tabpage_win(VAR_50, VAR_70);
}
else if (VAR_0 == 'F' && VAR_6 >= 0)
{
VAR_21->w_cursor.lnum = VAR_6;
check_cursor_lnum();
beginline(VAR_74 | VAR_75);
}
}
vim_free(VAR_5);
}
break;
#ifdef VAR_7
case 'i':    
case VAR_76:
VAR_8 = VAR_77;
case 'd':    
case VAR_78:
VAR_13;
if ((VAR_10 = find_ident_under_cursor(&VAR_5, VAR_79)) == 0)
break;
VAR_5 = vim_strnsave(VAR_5, VAR_10);
if (VAR_5 == NULL)
break;
find_pattern_in_path(VAR_5, 0, VAR_10, TRUE,
VAR_1 == 0 ? TRUE : FALSE, VAR_8,
VAR_3, VAR_80, (linenr_T)1, (linenr_T)VAR_81);
vim_free(VAR_5);
VAR_21->w_set_curswant = TRUE;
break;
#endif
#if defined(VAR_28)
case VAR_82:
case VAR_83:
if (bt_quickfix(VAR_15))
qf_view_result(TRUE);
break;
#endif
case 'g':
case VAR_84:
VAR_13;
#ifdef VAR_85
VAR_86 = TRUE;
#endif
++VAR_87;
++VAR_88;   
if (VAR_2 == VAR_27)
VAR_2 = plain_vgetc();
LANGMAP_ADJUST(VAR_2, TRUE);
--VAR_87;
--VAR_88;
(void)add_to_showcmd(VAR_2);
switch (VAR_2)
{
#if defined(VAR_28)
case '}':
VAR_2 = VAR_67;
if (VAR_1)
VAR_65 = VAR_1;
else
VAR_65 = VAR_66;
#endif
case ']':
case VAR_67:
if (VAR_1)
VAR_68 = VAR_1;
else
VAR_68 = -1;
do_nv_ident('g', VAR_2);
break;
case 'f':    
case 'F':    
VAR_62.cmod_tab = tabpage_index(VAR_51) + 1;
VAR_0 = VAR_2;
goto wingotofile;
case 't':    
goto_tabpage((int)VAR_1);
break;
case 'T':    
goto_tabpage(-(int)VAR_3);
break;
case VAR_89:    
if (goto_tabpage_lastused() == VAR_73)
beep_flush();
break;
default:
beep_flush();
break;
}
break;
default:beep_flush();
break;
}
}",vim/cc762a48d42b579fb7bdec2c614636b830342dd5/window.c/vul/before/0.json,"void
do_window(
    int		nchar,
    long	Prenum,
    int		xchar)	    // extra char from "":wincmd gx"" or NUL
{
    long	Prenum1;
    win_T	*wp;
    char_u	*ptr;
    linenr_T    lnum = -1;
#ifdef FEAT_FIND_ID
    int		type = FIND_DEFINE;
    int		len;
#endif
    char_u	cbuf[40];

    if (ERROR_IF_ANY_POPUP_WINDOW)
	return;

#define CHECK_CMDWIN \
    do { \
	if (cmdwin_type != 0) \
	{ \
	    emsg(_(e_invalid_in_cmdline_window)); \
	    return; \
	} \
    } while (0)

    Prenum1 = Prenum == 0 ? 1 : Prenum;

    switch (nchar)
    {
// split current window in two parts, horizontally
    case 'S':
    case Ctrl_S:
    case 's':
		CHECK_CMDWIN;
		reset_VIsual_and_resel();	// stop Visual mode
		// When splitting the quickfix window open a new buffer in it,
		// don't replicate the quickfix buffer.
		if (bt_quickfix(curbuf))
		    goto newwindow;
#ifdef FEAT_GUI
		need_mouse_correct = TRUE;
#endif
		(void)win_split((int)Prenum, 0);
		break;

// split current window in two parts, vertically
    case Ctrl_V:
    case 'v':
		CHECK_CMDWIN;
		reset_VIsual_and_resel();	// stop Visual mode
		// When splitting the quickfix window open a new buffer in it,
		// don't replicate the quickfix buffer.
		if (bt_quickfix(curbuf))
		    goto newwindow;
#ifdef FEAT_GUI
		need_mouse_correct = TRUE;
#endif
		(void)win_split((int)Prenum, WSP_VERT);
		break;

// split current window and edit alternate file
    case Ctrl_HAT:
    case '^':
		CHECK_CMDWIN;
		reset_VIsual_and_resel();	// stop Visual mode

		if (buflist_findnr(Prenum == 0
					? curwin->w_alt_fnum : Prenum) == NULL)
		{
		    if (Prenum == 0)
			emsg(_(e_no_alternate_file));
		    else
			semsg(_(e_buffer_nr_not_found), Prenum);
		    break;
		}

		if (!curbuf_locked() && win_split(0, 0) == OK)
		    (void)buflist_getfile(
			    Prenum == 0 ? curwin->w_alt_fnum : Prenum,
			    (linenr_T)0, GETF_ALT, FALSE);
		break;

// open new window
    case Ctrl_N:
    case 'n':
		CHECK_CMDWIN;
		reset_VIsual_and_resel();	// stop Visual mode
newwindow:
		if (Prenum)
		    // window height
		    vim_snprintf((char *)cbuf, sizeof(cbuf) - 5, ""%ld"", Prenum);
		else
		    cbuf[0] = NUL;
#if defined(FEAT_QUICKFIX)
		if (nchar == 'v' || nchar == Ctrl_V)
		    STRCAT(cbuf, ""v"");
#endif
		STRCAT(cbuf, ""new"");
		do_cmdline_cmd(cbuf);
		break;

// quit current window
    case Ctrl_Q:
    case 'q':
		reset_VIsual_and_resel();	// stop Visual mode
		cmd_with_count(""quit"", cbuf, sizeof(cbuf), Prenum);
		do_cmdline_cmd(cbuf);
		break;

// close current window
    case Ctrl_C:
    case 'c':
		reset_VIsual_and_resel();	// stop Visual mode
		cmd_with_count(""close"", cbuf, sizeof(cbuf), Prenum);
		do_cmdline_cmd(cbuf);
		break;

#if defined(FEAT_QUICKFIX)
// close preview window
    case Ctrl_Z:
    case 'z':
		CHECK_CMDWIN;
		reset_VIsual_and_resel();	// stop Visual mode
		do_cmdline_cmd((char_u *)""pclose"");
		break;

// cursor to preview window
    case 'P':
		FOR_ALL_WINDOWS(wp)
		    if (wp->w_p_pvw)
			break;
		if (wp == NULL)
		    emsg(_(e_there_is_no_preview_window));
		else
		    win_goto(wp);
		break;
#endif

// close all but current window
    case Ctrl_O:
    case 'o':
		CHECK_CMDWIN;
		reset_VIsual_and_resel();	// stop Visual mode
		cmd_with_count(""only"", cbuf, sizeof(cbuf), Prenum);
		do_cmdline_cmd(cbuf);
		break;

// cursor to next window with wrap around
    case Ctrl_W:
    case 'w':
// cursor to previous window with wrap around
    case 'W':
		CHECK_CMDWIN;
		if (ONE_WINDOW && Prenum != 1)	// just one window
		    beep_flush();
		else
		{
		    if (Prenum)			// go to specified window
		    {
			for (wp = firstwin; --Prenum > 0; )
			{
			    if (wp->w_next == NULL)
				break;
			    else
				wp = wp->w_next;
			}
		    }
		    else
		    {
			if (nchar == 'W')	    // go to previous window
			{
			    wp = curwin->w_prev;
			    if (wp == NULL)
				wp = lastwin;	    // wrap around
			}
			else			    // go to next window
			{
			    wp = curwin->w_next;
			    if (wp == NULL)
				wp = firstwin;	    // wrap around
			}
		    }
		    win_goto(wp);
		}
		break;

// cursor to window below
    case 'j':
    case K_DOWN:
    case Ctrl_J:
		CHECK_CMDWIN;
		win_goto_ver(FALSE, Prenum1);
		break;

// cursor to window above
    case 'k':
    case K_UP:
    case Ctrl_K:
		CHECK_CMDWIN;
		win_goto_ver(TRUE, Prenum1);
		break;

// cursor to left window
    case 'h':
    case K_LEFT:
    case Ctrl_H:
    case K_BS:
		CHECK_CMDWIN;
		win_goto_hor(TRUE, Prenum1);
		break;

// cursor to right window
    case 'l':
    case K_RIGHT:
    case Ctrl_L:
		CHECK_CMDWIN;
		win_goto_hor(FALSE, Prenum1);
		break;

// move window to new tab page
    case 'T':
		CHECK_CMDWIN;
		if (one_window())
		    msg(_(m_onlyone));
		else
		{
		    tabpage_T	*oldtab = curtab;
		    tabpage_T	*newtab;

		    // First create a new tab with the window, then go back to
		    // the old tab and close the window there.
		    wp = curwin;
		    if (win_new_tabpage((int)Prenum) == OK
						     && valid_tabpage(oldtab))
		    {
			newtab = curtab;
			goto_tabpage_tp(oldtab, TRUE, TRUE);
			if (curwin == wp)
			    win_close(curwin, FALSE);
			if (valid_tabpage(newtab))
			    goto_tabpage_tp(newtab, TRUE, TRUE);
		    }
		}
		break;

// cursor to top-left window
    case 't':
    case Ctrl_T:
		win_goto(firstwin);
		break;

// cursor to bottom-right window
    case 'b':
    case Ctrl_B:
		win_goto(lastwin);
		break;

// cursor to last accessed (previous) window
    case 'p':
    case Ctrl_P:
		if (!win_valid(prevwin))
		    beep_flush();
		else
		    win_goto(prevwin);
		break;

// exchange current and next window
    case 'x':
    case Ctrl_X:
		CHECK_CMDWIN;
		win_exchange(Prenum);
		break;

// rotate windows downwards
    case Ctrl_R:
    case 'r':
		CHECK_CMDWIN;
		reset_VIsual_and_resel();	// stop Visual mode
		win_rotate(FALSE, (int)Prenum1);    // downwards
		break;

// rotate windows upwards
    case 'R':
		CHECK_CMDWIN;
		reset_VIsual_and_resel();	// stop Visual mode
		win_rotate(TRUE, (int)Prenum1);	    // upwards
		break;

// move window to the very top/bottom/left/right
    case 'K':
    case 'J':
    case 'H':
    case 'L':
		CHECK_CMDWIN;
		win_totop((int)Prenum,
			((nchar == 'H' || nchar == 'L') ? WSP_VERT : 0)
			| ((nchar == 'H' || nchar == 'K') ? WSP_TOP : WSP_BOT));
		break;

// make all windows the same width and/or height
    case '=':
		{
		    int mod = cmdmod.cmod_split & (WSP_VERT | WSP_HOR);
#ifdef FEAT_GUI
		    need_mouse_correct = TRUE;
#endif
		    win_equal(NULL, FALSE,
			   mod == WSP_VERT ? 'v' : mod == WSP_HOR ? 'h' : 'b');
		}
		break;

// increase current window height
    case '+':
#ifdef FEAT_GUI
		need_mouse_correct = TRUE;
#endif
		win_setheight(curwin->w_height + (int)Prenum1);
		break;

// decrease current window height
    case '-':
#ifdef FEAT_GUI
		need_mouse_correct = TRUE;
#endif
		win_setheight(curwin->w_height - (int)Prenum1);
		break;

// set current window height
    case Ctrl__:
    case '_':
#ifdef FEAT_GUI
		need_mouse_correct = TRUE;
#endif
		win_setheight(Prenum ? (int)Prenum : 9999);
		break;

// increase current window width
    case '>':
#ifdef FEAT_GUI
		need_mouse_correct = TRUE;
#endif
		win_setwidth(curwin->w_width + (int)Prenum1);
		break;

// decrease current window width
    case '<':
#ifdef FEAT_GUI
		need_mouse_correct = TRUE;
#endif
		win_setwidth(curwin->w_width - (int)Prenum1);
		break;

// set current window width
    case '|':
#ifdef FEAT_GUI
		need_mouse_correct = TRUE;
#endif
		win_setwidth(Prenum != 0 ? (int)Prenum : 9999);
		break;

// jump to tag and split window if tag exists (in preview window)
#if defined(FEAT_QUICKFIX)
    case '}':
		CHECK_CMDWIN;
		if (Prenum)
		    g_do_tagpreview = Prenum;
		else
		    g_do_tagpreview = p_pvh;
#endif
		// FALLTHROUGH
    case ']':
    case Ctrl_RSB:
		CHECK_CMDWIN;
		// keep Visual mode, can select words to use as a tag
		if (Prenum)
		    postponed_split = Prenum;
		else
		    postponed_split = -1;
#ifdef FEAT_QUICKFIX
		if (nchar != '}')
		    g_do_tagpreview = 0;
#endif

		// Execute the command right here, required when ""wincmd ]""
		// was used in a function.
		do_nv_ident(Ctrl_RSB, NUL);
		break;

// edit file name under cursor in a new window
    case 'f':
    case 'F':
    case Ctrl_F:
wingotofile:
		CHECK_CMDWIN;
		if (check_text_or_curbuf_locked(NULL))
		    break;

		ptr = grab_file_name(Prenum1, &lnum);
		if (ptr != NULL)
		{
		    tabpage_T	*oldtab = curtab;
		    win_T	*oldwin = curwin;
#ifdef FEAT_GUI
		    need_mouse_correct = TRUE;
#endif
		    setpcmark();
		    if (win_split(0, 0) == OK)
		    {
			RESET_BINDING(curwin);
			if (do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL,
						   ECMD_HIDE, NULL) == FAIL)
			{
			    // Failed to open the file, close the window
			    // opened for it.
			    win_close(curwin, FALSE);
			    goto_tabpage_win(oldtab, oldwin);
			}
			else if (nchar == 'F' && lnum >= 0)
			{
			    curwin->w_cursor.lnum = lnum;
			    check_cursor_lnum();
			    beginline(BL_SOL | BL_FIX);
			}
		    }
		    vim_free(ptr);
		}
		break;

#ifdef FEAT_FIND_ID
// Go to the first occurrence of the identifier under cursor along path in a
// new window -- webb
    case 'i':			    // Go to any match
    case Ctrl_I:
		type = FIND_ANY;
		// FALLTHROUGH
    case 'd':			    // Go to definition, using 'define'
    case Ctrl_D:
		CHECK_CMDWIN;
		if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)
		    break;

		// Make a copy, if the line was changed it will be freed.
		ptr = vim_strnsave(ptr, len);
		if (ptr == NULL)
		    break;

		find_pattern_in_path(ptr, 0, len, TRUE,
			Prenum == 0 ? TRUE : FALSE, type,
			Prenum1, ACTION_SPLIT, (linenr_T)1, (linenr_T)MAXLNUM);
		vim_free(ptr);
		curwin->w_set_curswant = TRUE;
		break;
#endif

// Quickfix window only: view the result under the cursor in a new split.
#if defined(FEAT_QUICKFIX)
    case K_KENTER:
    case CAR:
		if (bt_quickfix(curbuf))
		    qf_view_result(TRUE);
		break;
#endif

// CTRL-W g  extended commands
    case 'g':
    case Ctrl_G:
		CHECK_CMDWIN;
#ifdef USE_ON_FLY_SCROLL
		dont_scroll = TRUE;		// disallow scrolling here
#endif
		++no_mapping;
		++allow_keys;   // no mapping for xchar, but allow key codes
		if (xchar == NUL)
		    xchar = plain_vgetc();
		LANGMAP_ADJUST(xchar, TRUE);
		--no_mapping;
		--allow_keys;
		(void)add_to_showcmd(xchar);

		switch (xchar)
		{
#if defined(FEAT_QUICKFIX)
		    case '}':
			xchar = Ctrl_RSB;
			if (Prenum)
			    g_do_tagpreview = Prenum;
			else
			    g_do_tagpreview = p_pvh;
#endif
			// FALLTHROUGH
		    case ']':
		    case Ctrl_RSB:
			// keep Visual mode, can select words to use as a tag
			if (Prenum)
			    postponed_split = Prenum;
			else
			    postponed_split = -1;

			// Execute the command right here, required when
			// ""wincmd g}"" was used in a function.
			do_nv_ident('g', xchar);
			break;

		    case 'f':	    // CTRL-W gf: ""gf"" in a new tab page
		    case 'F':	    // CTRL-W gF: ""gF"" in a new tab page
			cmdmod.cmod_tab = tabpage_index(curtab) + 1;
			nchar = xchar;
			goto wingotofile;

		    case 't':	    // CTRL-W gt: go to next tab page
			goto_tabpage((int)Prenum);
			break;

		    case 'T':	    // CTRL-W gT: go to previous tab page
			goto_tabpage(-(int)Prenum1);
			break;

		    case TAB:	    // CTRL-W g<Tab>: go to last used tab page
			if (goto_tabpage_lastused() == FAIL)
			    beep_flush();
			break;

		    default:
			beep_flush();
			break;
		}
		break;

    default:	beep_flush();
		break;
    }
}","void
do_window(
    int		VAR_0,
    long	VAR_1,
    int		VAR_2)	    /* COMMENT_0 */
{
    long	VAR_3;
    win_T	*VAR_4;
    char_u	*VAR_5;
    linenr_T    VAR_6 = -1;
#ifdef VAR_7
    int		VAR_8 = VAR_9;
    int		VAR_10;
#endif
    char_u	VAR_11[40];

    if (VAR_12)
	return;

#define VAR_13 \
    do { \
	if (cmdwin_type != 0) \
	{ \
	    emsg(_(e_invalid_in_cmdline_window)); \
	    return; \
	} \
    } while (0)

    VAR_3 = VAR_1 == 0 ? 1 : VAR_1;

    switch (VAR_0)
    {
/* COMMENT_1 */
    case 'S':
    case VAR_14:
    case 's':
		VAR_13;
		reset_VIsual_and_resel();	/* COMMENT_2 */
		/* COMMENT_3 */
		/* COMMENT_4 */
		if (bt_quickfix(VAR_15))
		    goto newwindow;
#ifdef VAR_16
		VAR_17 = TRUE;
#endif
		(void)win_split((int)VAR_1, 0);
		break;

/* COMMENT_5 */
    case VAR_18:
    case 'v':
		VAR_13;
		reset_VIsual_and_resel();	/* COMMENT_2 */
		/* COMMENT_3 */
		/* COMMENT_4 */
		if (bt_quickfix(VAR_15))
		    goto newwindow;
#ifdef VAR_16
		VAR_17 = TRUE;
#endif
		(void)win_split((int)VAR_1, VAR_19);
		break;

/* COMMENT_6 */
    case VAR_20:
    case '^':
		VAR_13;
		reset_VIsual_and_resel();	/* COMMENT_2 */

		if (buflist_findnr(VAR_1 == 0
					? VAR_21->w_alt_fnum : VAR_1) == NULL)
		{
		    if (VAR_1 == 0)
			emsg(_(VAR_22));
		    else
			semsg(_(VAR_23), VAR_1);
		    break;
		}

		if (!curbuf_locked() && win_split(0, 0) == VAR_24)
		    (void)buflist_getfile(
			    VAR_1 == 0 ? VAR_21->w_alt_fnum : VAR_1,
			    (linenr_T)0, VAR_25, FALSE);
		break;

/* COMMENT_7 */
    case VAR_26:
    case 'n':
		VAR_13;
		reset_VIsual_and_resel();	/* COMMENT_2 */
newwindow:
		if (VAR_1)
		    /* COMMENT_8 */
		    vim_snprintf((char *)VAR_11, sizeof(VAR_11) - 5, ""%ld"", VAR_1);
		else
		    VAR_11[0] = VAR_27;
#if defined(VAR_28)
		if (VAR_0 == 'v' || VAR_0 == VAR_18)
		    STRCAT(VAR_11, ""v"");
#endif
		STRCAT(VAR_11, ""new"");
		do_cmdline_cmd(VAR_11);
		break;

/* COMMENT_9 */
    case VAR_29:
    case 'q':
		reset_VIsual_and_resel();	/* COMMENT_2 */
		cmd_with_count(""quit"", VAR_11, sizeof(VAR_11), VAR_1);
		do_cmdline_cmd(VAR_11);
		break;

/* COMMENT_10 */
    case VAR_30:
    case 'c':
		reset_VIsual_and_resel();	/* COMMENT_2 */
		cmd_with_count(""close"", VAR_11, sizeof(VAR_11), VAR_1);
		do_cmdline_cmd(VAR_11);
		break;

#if defined(VAR_28)
/* COMMENT_11 */
    case VAR_31:
    case 'z':
		VAR_13;
		reset_VIsual_and_resel();	/* COMMENT_2 */
		do_cmdline_cmd((char_u *)""pclose"");
		break;

/* COMMENT_12 */
    case 'P':
		VAR_32(wp)
		    if (wp->VAR_33)
			break;
		if (wp == NULL)
		    emsg(_(VAR_34));
		else
		    win_goto(wp);
		break;
#endif

/* COMMENT_13 */
    case VAR_35:
    case 'o':
		VAR_13;
		reset_VIsual_and_resel();	/* COMMENT_2 */
		cmd_with_count(""only"", VAR_11, sizeof(VAR_11), VAR_1);
		do_cmdline_cmd(VAR_11);
		break;

/* COMMENT_14 */
    case VAR_36:
    case 'w':
/* COMMENT_15 */
    case 'W':
		VAR_13;
		if (VAR_37 && VAR_1 != 1)	/* COMMENT_16 */
		    beep_flush();
		else
		{
		    if (VAR_1)			/* COMMENT_17 */
		    {
			for (wp = VAR_38; --VAR_1 > 0; )
			{
			    if (wp->w_next == NULL)
				break;
			    else
				wp = wp->w_next;
			}
		    }
		    else
		    {
			if (VAR_0 == 'W')	    /* COMMENT_18 */
			{
			    wp = VAR_21->w_prev;
			    if (wp == NULL)
				wp = VAR_39;	    /* COMMENT_19 */
			}
			else			    /* COMMENT_20 */
			{
			    wp = VAR_21->w_next;
			    if (wp == NULL)
				wp = VAR_38;	    /* COMMENT_19 */
			}
		    }
		    win_goto(wp);
		}
		break;

/* COMMENT_21 */
    case 'j':
    case VAR_40:
    case VAR_41:
		VAR_13;
		win_goto_ver(FALSE, VAR_3);
		break;

/* COMMENT_22 */
    case 'k':
    case VAR_42:
    case VAR_43:
		VAR_13;
		win_goto_ver(TRUE, VAR_3);
		break;

/* COMMENT_23 */
    case 'h':
    case VAR_44:
    case VAR_45:
    case VAR_46:
		VAR_13;
		win_goto_hor(TRUE, VAR_3);
		break;

/* COMMENT_24 */
    case 'l':
    case VAR_47:
    case VAR_48:
		VAR_13;
		win_goto_hor(FALSE, VAR_3);
		break;

/* COMMENT_25 */
    case 'T':
		VAR_13;
		if (one_window())
		    msg(_(VAR_49));
		else
		{
		    tabpage_T	*VAR_50 = VAR_51;
		    tabpage_T	*VAR_52;

		    /* COMMENT_26 */
		    /* COMMENT_27 */
		    wp = VAR_21;
		    if (win_new_tabpage((int)VAR_1) == VAR_24
						     && valid_tabpage(VAR_50))
		    {
			VAR_52 = VAR_51;
			goto_tabpage_tp(VAR_50, TRUE, TRUE);
			if (VAR_21 == wp)
			    win_close(VAR_21, FALSE);
			if (valid_tabpage(VAR_52))
			    goto_tabpage_tp(VAR_52, TRUE, TRUE);
		    }
		}
		break;

/* COMMENT_28 */
    case 't':
    case VAR_53:
		win_goto(VAR_38);
		break;

/* COMMENT_29 */
    case 'b':
    case VAR_54:
		win_goto(VAR_39);
		break;

/* COMMENT_30 */
    case 'p':
    case VAR_55:
		if (!win_valid(VAR_56))
		    beep_flush();
		else
		    win_goto(VAR_56);
		break;

/* COMMENT_31 */
    case 'x':
    case VAR_57:
		VAR_13;
		win_exchange(VAR_1);
		break;

/* COMMENT_32 */
    case VAR_58:
    case 'r':
		VAR_13;
		reset_VIsual_and_resel();	/* COMMENT_2 */
		win_rotate(FALSE, (int)VAR_3);    /* COMMENT_33 */
		break;

/* COMMENT_34 */
    case 'R':
		VAR_13;
		reset_VIsual_and_resel();	/* COMMENT_2 */
		win_rotate(TRUE, (int)VAR_3);	    /* COMMENT_35 */
		break;

/* COMMENT_36 */
    case 'K':
    case 'J':
    case 'H':
    case 'L':
		VAR_13;
		win_totop((int)VAR_1,
			((VAR_0 == 'H' || VAR_0 == 'L') ? VAR_19 : 0)
			| ((VAR_0 == 'H' || VAR_0 == 'K') ? VAR_59 : VAR_60));
		break;

/* COMMENT_37 */
    case '=':
		{
		    int VAR_61 = VAR_62.cmod_split & (VAR_19 | VAR_63);
#ifdef VAR_16
		    VAR_17 = TRUE;
#endif
		    win_equal(NULL, FALSE,
			   VAR_61 == VAR_19 ? 'v' : VAR_61 == VAR_63 ? 'h' : 'b');
		}
		break;

/* COMMENT_38 */
    case '+':
#ifdef VAR_16
		VAR_17 = TRUE;
#endif
		win_setheight(VAR_21->w_height + (int)VAR_3);
		break;

/* COMMENT_39 */
    case '-':
#ifdef VAR_16
		VAR_17 = TRUE;
#endif
		win_setheight(VAR_21->w_height - (int)VAR_3);
		break;

/* COMMENT_40 */
    case VAR_64:
    case '_':
#ifdef VAR_16
		VAR_17 = TRUE;
#endif
		win_setheight(VAR_1 ? (int)VAR_1 : 9999);
		break;

/* COMMENT_41 */
    case '>':
#ifdef VAR_16
		VAR_17 = TRUE;
#endif
		win_setwidth(VAR_21->w_width + (int)VAR_3);
		break;

/* COMMENT_42 */
    case '<':
#ifdef VAR_16
		VAR_17 = TRUE;
#endif
		win_setwidth(VAR_21->w_width - (int)VAR_3);
		break;

/* COMMENT_43 */
    case '|':
#ifdef VAR_16
		VAR_17 = TRUE;
#endif
		win_setwidth(VAR_1 != 0 ? (int)VAR_1 : 9999);
		break;

/* COMMENT_44 */
#if defined(VAR_28)
    case '}':
		VAR_13;
		if (VAR_1)
		    VAR_65 = VAR_1;
		else
		    VAR_65 = VAR_66;
#endif
		/* COMMENT_45 */
    case ']':
    case VAR_67:
		VAR_13;
		/* COMMENT_46 */
		if (VAR_1)
		    VAR_68 = VAR_1;
		else
		    VAR_68 = -1;
#ifdef VAR_28
		if (VAR_0 != '}')
		    VAR_65 = 0;
#endif

		/* COMMENT_47 */
		/* COMMENT_48 */
		do_nv_ident(VAR_67, VAR_27);
		break;

/* COMMENT_49 */
    case 'f':
    case 'F':
    case VAR_69:
wingotofile:
		VAR_13;
		if (check_text_or_curbuf_locked(NULL))
		    break;

		VAR_5 = grab_file_name(VAR_3, &VAR_6);
		if (VAR_5 != NULL)
		{
		    tabpage_T	*VAR_50 = VAR_51;
		    win_T	*VAR_70 = VAR_21;
#ifdef VAR_16
		    VAR_17 = TRUE;
#endif
		    setpcmark();
		    if (win_split(0, 0) == VAR_24)
		    {
			RESET_BINDING(VAR_21);
			if (do_ecmd(0, VAR_5, NULL, NULL, VAR_71,
						   VAR_72, NULL) == VAR_73)
			{
			    /* COMMENT_50 */
			    /* COMMENT_51 */
			    win_close(VAR_21, FALSE);
			    goto_tabpage_win(VAR_50, VAR_70);
			}
			else if (VAR_0 == 'F' && VAR_6 >= 0)
			{
			    VAR_21->w_cursor.lnum = VAR_6;
			    check_cursor_lnum();
			    beginline(VAR_74 | VAR_75);
			}
		    }
		    vim_free(VAR_5);
		}
		break;

#ifdef VAR_7
/* COMMENT_52 */
/* COMMENT_53 */
    case 'i':			    /* COMMENT_54 */
    case VAR_76:
		VAR_8 = VAR_77;
		/* COMMENT_45 */
    case 'd':			    /* COMMENT_55 */
    case VAR_78:
		VAR_13;
		if ((VAR_10 = find_ident_under_cursor(&VAR_5, VAR_79)) == 0)
		    break;

		/* COMMENT_56 */
		VAR_5 = vim_strnsave(VAR_5, VAR_10);
		if (VAR_5 == NULL)
		    break;

		find_pattern_in_path(VAR_5, 0, VAR_10, TRUE,
			VAR_1 == 0 ? TRUE : FALSE, VAR_8,
			VAR_3, VAR_80, (linenr_T)1, (linenr_T)VAR_81);
		vim_free(VAR_5);
		VAR_21->w_set_curswant = TRUE;
		break;
#endif

/* COMMENT_57 */
#if defined(VAR_28)
    case VAR_82:
    case VAR_83:
		if (bt_quickfix(VAR_15))
		    qf_view_result(TRUE);
		break;
#endif

/* COMMENT_58 */
    case 'g':
    case VAR_84:
		VAR_13;
#ifdef VAR_85
		VAR_86 = TRUE;		/* COMMENT_59 */
#endif
		++VAR_87;
		++VAR_88;   /* COMMENT_60 */
		if (VAR_2 == VAR_27)
		    VAR_2 = plain_vgetc();
		LANGMAP_ADJUST(VAR_2, TRUE);
		--VAR_87;
		--VAR_88;
		(void)add_to_showcmd(VAR_2);

		switch (VAR_2)
		{
#if defined(VAR_28)
		    case '}':
			VAR_2 = VAR_67;
			if (VAR_1)
			    VAR_65 = VAR_1;
			else
			    VAR_65 = VAR_66;
#endif
			/* COMMENT_45 */
		    case ']':
		    case VAR_67:
			/* COMMENT_46 */
			if (VAR_1)
			    VAR_68 = VAR_1;
			else
			    VAR_68 = -1;

			/* COMMENT_61 */
			/* COMMENT_62 */
			do_nv_ident('g', VAR_2);
			break;

		    case 'f':	    /* COMMENT_63 */
		    case 'F':	    /* COMMENT_64 */
			VAR_62.cmod_tab = tabpage_index(VAR_51) + 1;
			VAR_0 = VAR_2;
			goto wingotofile;

		    case 't':	    /* COMMENT_65 */
			goto_tabpage((int)VAR_1);
			break;

		    case 'T':	    /* COMMENT_66 */
			goto_tabpage(-(int)VAR_3);
			break;

		    case VAR_89:	    /* COMMENT_67 */
			if (goto_tabpage_lastused() == VAR_73)
			    beep_flush();
			break;

		    default:
			beep_flush();
			break;
		}
		break;

    default:	beep_flush();
		break;
    }
}",vim/cc762a48d42b579fb7bdec2c614636b830342dd5/window.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -395,6 +395,8 @@
     case Ctrl_F:
 wingotofile:
 		CHECK_CMDWIN;
+		if (check_text_or_curbuf_locked(NULL))
+		    break;
 
 		ptr = grab_file_name(Prenum1, &lnum);
 		if (ptr != NULL)","{'deleted_lines': [], 'added_lines': ['\t\tif (check_text_or_curbuf_locked(NULL))', '\t\t    break;']}",True,Heap based buffer overflow in vim/vim 9.0.0946 and below by allowing an attacker to CTRL-W gf in the expression used in the RHS of the substitute command.,7.8,HIGH,2,test,2022-11-25T13:03:31Z,4
CVE-2022-40757,['CWE-119'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Samsung/mTower,"Fixed CVE-2022-40760

Signed-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",ab9d06d51ff8c3eab9ba9ea85e422179dbd12b15,https://github.com/Samsung/mTower/commit/ab9d06d51ff8c3eab9ba9ea85e422179dbd12b15,tee/lib/libutee/tee_api_operations.c,TEE_MACComputeFinal,"TEE_Result TEE_MACComputeFinal(TEE_OperationHandle operation,
const void *message, uint32_t messageLen,
void *mac, uint32_t *macLen)
{
TEE_Result res;
uint64_t ml;
if (operation == TEE_HANDLE_NULL ||
(message == NULL && messageLen != 0) ||
mac == NULL ||
macLen == NULL) {
res = TEE_ERROR_BAD_PARAMETERS;
goto out;
}
if (operation->info.operationClass != TEE_OPERATION_MAC) {
res = TEE_ERROR_BAD_PARAMETERS;
goto out;
}
if ((operation->info.handleState & TEE_HANDLE_FLAG_INITIALIZED) == 0) {
res = TEE_ERROR_BAD_PARAMETERS;
goto out;
}
if (operation->operationState != TEE_OPERATION_STATE_ACTIVE) {
res = TEE_ERROR_BAD_PARAMETERS;
goto out;
}
ml = *macLen;
res = utee_hash_final(operation->state, message, messageLen, mac, &ml);
*macLen = ml;
if (res != TEE_SUCCESS)
goto out;
operation->info.handleState &= ~TEE_HANDLE_FLAG_INITIALIZED;
operation->operationState = TEE_OPERATION_STATE_INITIAL;
out:
if (res != TEE_SUCCESS &&
res != TEE_ERROR_SHORT_BUFFER)
TEE_Panic(res);
return res;
}","TEE_Result TEE_MACComputeFinal(TEE_OperationHandle VAR_0,
const void *VAR_1, uint32_t VAR_2,
void *VAR_3, uint32_t *VAR_4)
{
TEE_Result VAR_5;
uint64_t VAR_6;
if (VAR_0 == VAR_7 ||
(VAR_1 == NULL && VAR_2 != 0) ||
VAR_3 == NULL ||
VAR_4 == NULL) {
VAR_5 = VAR_8;
goto out;
}
if (VAR_0->info.operationClass != VAR_9) {
VAR_5 = VAR_8;
goto out;
}
if ((VAR_0->info.handleState & VAR_10) == 0) {
VAR_5 = VAR_8;
goto out;
}
if (VAR_0->operationState != VAR_11) {
VAR_5 = VAR_8;
goto out;
}
VAR_6 = *VAR_4;
VAR_5 = utee_hash_final(VAR_0->state, VAR_1, VAR_2, VAR_3, &VAR_6);
*VAR_4 = VAR_6;
if (VAR_5 != VAR_12)
goto out;
VAR_0->info.handleState &= ~VAR_10;
VAR_0->operationState = VAR_13;
out:
if (VAR_5 != VAR_12 &&
VAR_5 != VAR_14)
TEE_Panic(VAR_5);
return VAR_5;
}",Samsung/mTower/ab9d06d51ff8c3eab9ba9ea85e422179dbd12b15/tee_api_operations.c/vul/before/1.json,"TEE_Result TEE_MACComputeFinal(TEE_OperationHandle operation,
			       const void *message, uint32_t messageLen,
			       void *mac, uint32_t *macLen)
{
	TEE_Result res;
	uint64_t ml;

	if (operation == TEE_HANDLE_NULL ||
	    (message == NULL && messageLen != 0) ||
	    mac == NULL ||
	    macLen == NULL) {
		res = TEE_ERROR_BAD_PARAMETERS;
		goto out;
	}

	if (operation->info.operationClass != TEE_OPERATION_MAC) {
		res = TEE_ERROR_BAD_PARAMETERS;
		goto out;
	}

	if ((operation->info.handleState & TEE_HANDLE_FLAG_INITIALIZED) == 0) {
		res = TEE_ERROR_BAD_PARAMETERS;
		goto out;
	}

	if (operation->operationState != TEE_OPERATION_STATE_ACTIVE) {
		res = TEE_ERROR_BAD_PARAMETERS;
		goto out;
	}

	if (CONFIG_MAX_CRYPTO_CHUNK_SIZE < *macLen) {
		res = TEE_ERROR_BAD_PARAMETERS;
		goto out;
	}

	ml = *macLen;
	res = utee_hash_final(operation->state, message, messageLen, mac, &ml);
	*macLen = ml;
	if (res != TEE_SUCCESS)
		goto out;

	operation->info.handleState &= ~TEE_HANDLE_FLAG_INITIALIZED;

	operation->operationState = TEE_OPERATION_STATE_INITIAL;

out:
	if (res != TEE_SUCCESS &&
	    res != TEE_ERROR_SHORT_BUFFER)
		TEE_Panic(res);

	return res;
}","TEE_Result TEE_MACComputeFinal(TEE_OperationHandle VAR_0,
			       const void *VAR_1, uint32_t VAR_2,
			       void *VAR_3, uint32_t *VAR_4)
{
	TEE_Result VAR_5;
	uint64_t VAR_6;

	if (VAR_0 == VAR_7 ||
	    (VAR_1 == NULL && VAR_2 != 0) ||
	    VAR_3 == NULL ||
	    VAR_4 == NULL) {
		VAR_5 = VAR_8;
		goto out;
	}

	if (VAR_0->info.operationClass != VAR_9) {
		VAR_5 = VAR_8;
		goto out;
	}

	if ((VAR_0->info.handleState & VAR_10) == 0) {
		VAR_5 = VAR_8;
		goto out;
	}

	if (VAR_0->operationState != VAR_11) {
		VAR_5 = VAR_8;
		goto out;
	}

	if (VAR_12 < *VAR_4) {
		VAR_5 = VAR_8;
		goto out;
	}

	VAR_6 = *VAR_4;
	VAR_5 = utee_hash_final(VAR_0->state, VAR_1, VAR_2, VAR_3, &VAR_6);
	*VAR_4 = VAR_6;
	if (VAR_5 != VAR_13)
		goto out;

	VAR_0->info.handleState &= ~VAR_10;

	VAR_0->operationState = VAR_14;

out:
	if (VAR_5 != VAR_13 &&
	    VAR_5 != VAR_15)
		TEE_Panic(VAR_5);

	return VAR_5;
}",Samsung/mTower/ab9d06d51ff8c3eab9ba9ea85e422179dbd12b15/tee_api_operations.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -28,6 +28,11 @@
 		goto out;
 	}
 
+	if (CONFIG_MAX_CRYPTO_CHUNK_SIZE < *macLen) {
+		res = TEE_ERROR_BAD_PARAMETERS;
+		goto out;
+	}
+
 	ml = *macLen;
 	res = utee_hash_final(operation->state, message, messageLen, mac, &ml);
 	*macLen = ml;","{'deleted_lines': [], 'added_lines': ['\tif (CONFIG_MAX_CRYPTO_CHUNK_SIZE < *macLen) {', '\t\tres = TEE_ERROR_BAD_PARAMETERS;', '\t\tgoto out;', '\t}', '']}",True,A Buffer Access with Incorrect Length Value vulnerablity in the TEE_MACComputeFinal function in Samsung mTower through 0.3.0 allows a trusted application to trigger a Denial of Service (DoS) by invoking the function TEE_MACComputeFinal with an excessive size value of messageLen.,7.5,HIGH,2,test,2022-11-28T10:19:34Z,4
CVE-2022-40757,['CWE-119'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Samsung/mTower,"Fixed CVE-2022-40760

Signed-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",ab9d06d51ff8c3eab9ba9ea85e422179dbd12b15,https://github.com/Samsung/mTower/commit/ab9d06d51ff8c3eab9ba9ea85e422179dbd12b15,tee/lib/libutee/tee_api_operations.c,TEE_MACUpdate,"void TEE_MACUpdate(TEE_OperationHandle operation, const void *chunk,
uint32_t chunkSize)
{
TEE_Result res;
if (operation == TEE_HANDLE_NULL || (chunk == NULL && chunkSize != 0))
TEE_Panic(0);
if (operation->info.operationClass != TEE_OPERATION_MAC)
TEE_Panic(0);
if ((operation->info.handleState & TEE_HANDLE_FLAG_INITIALIZED) == 0)
TEE_Panic(0);
if (operation->operationState != TEE_OPERATION_STATE_ACTIVE)
TEE_Panic(0);
res = utee_hash_update(operation->state, chunk, chunkSize);
if (res != TEE_SUCCESS)
TEE_Panic(res);
}","void TEE_MACUpdate(TEE_OperationHandle VAR_0, const void *VAR_1,
uint32_t VAR_2)
{
TEE_Result VAR_3;
if (VAR_0 == VAR_4 || (VAR_1 == NULL && VAR_2 != 0))
TEE_Panic(0);
if (VAR_0->info.operationClass != VAR_5)
TEE_Panic(0);
if ((VAR_0->info.handleState & VAR_6) == 0)
TEE_Panic(0);
if (VAR_0->operationState != VAR_7)
TEE_Panic(0);
VAR_3 = utee_hash_update(VAR_0->state, VAR_1, VAR_2);
if (VAR_3 != VAR_8)
TEE_Panic(VAR_3);
}",Samsung/mTower/ab9d06d51ff8c3eab9ba9ea85e422179dbd12b15/tee_api_operations.c/vul/before/2.json,"void TEE_MACUpdate(TEE_OperationHandle operation, const void *chunk,
		   uint32_t chunkSize)
{
	TEE_Result res;

	if (operation == TEE_HANDLE_NULL || (chunk == NULL && chunkSize != 0))
		TEE_Panic(0);

	if (operation->info.operationClass != TEE_OPERATION_MAC)
		TEE_Panic(0);

	if ((operation->info.handleState & TEE_HANDLE_FLAG_INITIALIZED) == 0)
		TEE_Panic(0);

	if (operation->operationState != TEE_OPERATION_STATE_ACTIVE)
		TEE_Panic(0);

	if (CONFIG_MAX_CRYPTO_CHUNK_SIZE < chunkSize)
		TEE_Panic(TEE_ERROR_BAD_PARAMETERS);

	res = utee_hash_update(operation->state, chunk, chunkSize);
	if (res != TEE_SUCCESS)
		TEE_Panic(res);
}","void TEE_MACUpdate(TEE_OperationHandle VAR_0, const void *VAR_1,
		   uint32_t VAR_2)
{
	TEE_Result VAR_3;

	if (VAR_0 == VAR_4 || (VAR_1 == NULL && VAR_2 != 0))
		TEE_Panic(0);

	if (VAR_0->info.operationClass != VAR_5)
		TEE_Panic(0);

	if ((VAR_0->info.handleState & VAR_6) == 0)
		TEE_Panic(0);

	if (VAR_0->operationState != VAR_7)
		TEE_Panic(0);

	if (VAR_8 < VAR_2)
		TEE_Panic(VAR_9);

	VAR_3 = utee_hash_update(VAR_0->state, VAR_1, VAR_2);
	if (VAR_3 != VAR_10)
		TEE_Panic(VAR_3);
}",Samsung/mTower/ab9d06d51ff8c3eab9ba9ea85e422179dbd12b15/tee_api_operations.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -15,6 +15,9 @@
 	if (operation->operationState != TEE_OPERATION_STATE_ACTIVE)
 		TEE_Panic(0);
 
+	if (CONFIG_MAX_CRYPTO_CHUNK_SIZE < chunkSize)
+		TEE_Panic(TEE_ERROR_BAD_PARAMETERS);
+
 	res = utee_hash_update(operation->state, chunk, chunkSize);
 	if (res != TEE_SUCCESS)
 		TEE_Panic(res);","{'deleted_lines': [], 'added_lines': ['\tif (CONFIG_MAX_CRYPTO_CHUNK_SIZE < chunkSize)', '\t\tTEE_Panic(TEE_ERROR_BAD_PARAMETERS);', '']}",True,A Buffer Access with Incorrect Length Value vulnerablity in the TEE_MACComputeFinal function in Samsung mTower through 0.3.0 allows a trusted application to trigger a Denial of Service (DoS) by invoking the function TEE_MACComputeFinal with an excessive size value of messageLen.,7.5,HIGH,2,test,2022-11-28T10:19:34Z,4
CVE-2022-40757,['CWE-119'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Samsung/mTower,"Fixed CVE-2022-40760

Signed-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",ab9d06d51ff8c3eab9ba9ea85e422179dbd12b15,https://github.com/Samsung/mTower/commit/ab9d06d51ff8c3eab9ba9ea85e422179dbd12b15,tee/lib/libutee/tee_api_operations.c,TEE_CipherUpdate,"TEE_Result TEE_CipherUpdate(TEE_OperationHandle operation, const void *srcData,
uint32_t srcLen, void *destData, uint32_t *destLen)
{
TEE_Result res;
size_t req_dlen;
uint64_t dl;
if (operation == TEE_HANDLE_NULL ||
(srcData == NULL && srcLen != 0) ||
destLen == NULL ||
(destData == NULL && *destLen != 0)) {
res = TEE_ERROR_BAD_PARAMETERS;
goto out;
}
if (operation->info.operationClass != TEE_OPERATION_CIPHER) {
res = TEE_ERROR_BAD_PARAMETERS;
goto out;
}
if ((operation->info.handleState & TEE_HANDLE_FLAG_INITIALIZED) == 0) {
res = TEE_ERROR_BAD_PARAMETERS;
goto out;
}
if (operation->operationState != TEE_OPERATION_STATE_ACTIVE) {
res = TEE_ERROR_BAD_PARAMETERS;
goto out;
}
if (!srcData && !srcLen) {
*destLen = 0;
res = TEE_SUCCESS;
goto out;
}
if (operation->block_size > 1) {
req_dlen = ((operation->buffer_offs + srcLen) /
operation->block_size) * operation->block_size;
} else {
req_dlen = srcLen;
}
if (operation->buffer_two_blocks) {
if (req_dlen > operation->block_size * 2)
req_dlen -= operation->block_size * 2;
else
req_dlen = 0;
}
if (*destLen < req_dlen) {
*destLen = req_dlen;
res = TEE_ERROR_SHORT_BUFFER;
goto out;
}
dl = *destLen;
if (operation->block_size > 1) {
res = tee_buffer_update(operation, utee_cipher_update, srcData,
srcLen, destData, &dl);
} else {
if (srcLen > 0) {
res = utee_cipher_update(operation->state, srcData,
srcLen, destData, &dl);
} else {
res = TEE_SUCCESS;
dl = 0;
}
}
*destLen = dl;
out:
if (res != TEE_SUCCESS &&
res != TEE_ERROR_SHORT_BUFFER)
TEE_Panic(res);
return res;
}","TEE_Result TEE_CipherUpdate(TEE_OperationHandle VAR_0, const void *VAR_1,
uint32_t VAR_2, void *VAR_3, uint32_t *VAR_4)
{
TEE_Result VAR_5;
size_t VAR_6;
uint64_t VAR_7;
if (VAR_0 == VAR_8 ||
(VAR_1 == NULL && VAR_2 != 0) ||
VAR_4 == NULL ||
(VAR_3 == NULL && *VAR_4 != 0)) {
VAR_5 = VAR_9;
goto out;
}
if (VAR_0->info.operationClass != VAR_10) {
VAR_5 = VAR_9;
goto out;
}
if ((VAR_0->info.handleState & VAR_11) == 0) {
VAR_5 = VAR_9;
goto out;
}
if (VAR_0->operationState != VAR_12) {
VAR_5 = VAR_9;
goto out;
}
if (!VAR_1 && !VAR_2) {
*VAR_4 = 0;
VAR_5 = VAR_13;
goto out;
}
if (VAR_0->block_size > 1) {
VAR_6 = ((VAR_0->buffer_offs + VAR_2) /
VAR_0->block_size) * VAR_0->block_size;
} else {
VAR_6 = VAR_2;
}
if (VAR_0->buffer_two_blocks) {
if (VAR_6 > VAR_0->block_size * 2)
VAR_6 -= VAR_0->block_size * 2;
else
VAR_6 = 0;
}
if (*VAR_4 < VAR_6) {
*VAR_4 = VAR_6;
VAR_5 = VAR_14;
goto out;
}
VAR_7 = *VAR_4;
if (VAR_0->block_size > 1) {
VAR_5 = tee_buffer_update(VAR_0, VAR_15, VAR_1,
VAR_2, VAR_3, &VAR_7);
} else {
if (VAR_2 > 0) {
VAR_5 = VAR_15(VAR_0->state, VAR_1,
VAR_2, VAR_3, &VAR_7);
} else {
VAR_5 = VAR_13;
VAR_7 = 0;
}
}
*VAR_4 = VAR_7;
out:
if (VAR_5 != VAR_13 &&
VAR_5 != VAR_14)
TEE_Panic(VAR_5);
return VAR_5;
}",Samsung/mTower/ab9d06d51ff8c3eab9ba9ea85e422179dbd12b15/tee_api_operations.c/vul/before/0.json,"TEE_Result TEE_CipherUpdate(TEE_OperationHandle operation, const void *srcData,
			    uint32_t srcLen, void *destData, uint32_t *destLen)
{
	TEE_Result res;
	size_t req_dlen;
	uint64_t dl;

	if (operation == TEE_HANDLE_NULL ||
	    (srcData == NULL && srcLen != 0) ||
	    destLen == NULL ||
	    (destData == NULL && *destLen != 0) ||
	    (srcLen > CONFIG_MAX_CRYPTO_CHUNK_SIZE || *destLen > CONFIG_MAX_CRYPTO_CHUNK_SIZE)) {
		res = TEE_ERROR_BAD_PARAMETERS;
		goto out;
	}

	if (operation->info.operationClass != TEE_OPERATION_CIPHER) {
		res = TEE_ERROR_BAD_PARAMETERS;
		goto out;
	}

	if ((operation->info.handleState & TEE_HANDLE_FLAG_INITIALIZED) == 0) {
		res = TEE_ERROR_BAD_PARAMETERS;
		goto out;
	}

	if (operation->operationState != TEE_OPERATION_STATE_ACTIVE) {
		res = TEE_ERROR_BAD_PARAMETERS;
		goto out;
	}

	if (!srcData && !srcLen) {
		*destLen = 0;
		res = TEE_SUCCESS;
		goto out;
	}

	/* Calculate required dlen */
	if (operation->block_size > 1) {
		req_dlen = ((operation->buffer_offs + srcLen) /
			    operation->block_size) * operation->block_size;
	} else {
		req_dlen = srcLen;
	}
	if (operation->buffer_two_blocks) {
		if (req_dlen > operation->block_size * 2)
			req_dlen -= operation->block_size * 2;
		else
			req_dlen = 0;
	}
	/*
	 * Check that required destLen is big enough before starting to feed
	 * data to the algorithm. Errors during feeding of data are fatal as we
	 * can't restore sync with this API.
	 */
	if (*destLen < req_dlen) {
		*destLen = req_dlen;
		res = TEE_ERROR_SHORT_BUFFER;
		goto out;
	}

	dl = *destLen;
	if (operation->block_size > 1) {
		res = tee_buffer_update(operation, utee_cipher_update, srcData,
					srcLen, destData, &dl);
	} else {
		if (srcLen > 0) {
			res = utee_cipher_update(operation->state, srcData,
						 srcLen, destData, &dl);
		} else {
			res = TEE_SUCCESS;
			dl = 0;
		}
	}
	*destLen = dl;

out:
	if (res != TEE_SUCCESS &&
	    res != TEE_ERROR_SHORT_BUFFER)
		TEE_Panic(res);

	return res;
}","TEE_Result TEE_CipherUpdate(TEE_OperationHandle VAR_0, const void *VAR_1,
			    uint32_t VAR_2, void *VAR_3, uint32_t *VAR_4)
{
	TEE_Result VAR_5;
	size_t VAR_6;
	uint64_t VAR_7;

	if (VAR_0 == VAR_8 ||
	    (VAR_1 == NULL && VAR_2 != 0) ||
	    VAR_4 == NULL ||
	    (VAR_3 == NULL && *VAR_4 != 0) ||
	    (VAR_2 > VAR_9 || *VAR_4 > VAR_9)) {
		VAR_5 = VAR_10;
		goto out;
	}

	if (VAR_0->info.operationClass != VAR_11) {
		VAR_5 = VAR_10;
		goto out;
	}

	if ((VAR_0->info.handleState & VAR_12) == 0) {
		VAR_5 = VAR_10;
		goto out;
	}

	if (VAR_0->operationState != VAR_13) {
		VAR_5 = VAR_10;
		goto out;
	}

	if (!VAR_1 && !VAR_2) {
		*VAR_4 = 0;
		VAR_5 = VAR_14;
		goto out;
	}

	/* COMMENT_0 */
	if (VAR_0->block_size > 1) {
		VAR_6 = ((VAR_0->buffer_offs + VAR_2) /
			    VAR_0->block_size) * VAR_0->block_size;
	} else {
		VAR_6 = VAR_2;
	}
	if (VAR_0->buffer_two_blocks) {
		if (VAR_6 > VAR_0->block_size * 2)
			VAR_6 -= VAR_0->block_size * 2;
		else
			VAR_6 = 0;
	}
	/* COMMENT_1 */
                                                                     
                                                                        
                                     
    
	if (*VAR_4 < VAR_6) {
		*VAR_4 = VAR_6;
		VAR_5 = VAR_15;
		goto out;
	}

	VAR_7 = *VAR_4;
	if (VAR_0->block_size > 1) {
		VAR_5 = tee_buffer_update(VAR_0, VAR_16, VAR_1,
					VAR_2, VAR_3, &VAR_7);
	} else {
		if (VAR_2 > 0) {
			VAR_5 = VAR_16(VAR_0->state, VAR_1,
						 VAR_2, VAR_3, &VAR_7);
		} else {
			VAR_5 = VAR_14;
			VAR_7 = 0;
		}
	}
	*VAR_4 = VAR_7;

out:
	if (VAR_5 != VAR_14 &&
	    VAR_5 != VAR_15)
		TEE_Panic(VAR_5);

	return VAR_5;
}",Samsung/mTower/ab9d06d51ff8c3eab9ba9ea85e422179dbd12b15/tee_api_operations.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,7 +8,8 @@
 	if (operation == TEE_HANDLE_NULL ||
 	    (srcData == NULL && srcLen != 0) ||
 	    destLen == NULL ||
-	    (destData == NULL && *destLen != 0)) {
+	    (destData == NULL && *destLen != 0) ||
+	    (srcLen > CONFIG_MAX_CRYPTO_CHUNK_SIZE || *destLen > CONFIG_MAX_CRYPTO_CHUNK_SIZE)) {
 		res = TEE_ERROR_BAD_PARAMETERS;
 		goto out;
 	}","{'deleted_lines': ['\t    (destData == NULL && *destLen != 0)) {'], 'added_lines': ['\t    (destData == NULL && *destLen != 0) ||', '\t    (srcLen > CONFIG_MAX_CRYPTO_CHUNK_SIZE || *destLen > CONFIG_MAX_CRYPTO_CHUNK_SIZE)) {']}",True,A Buffer Access with Incorrect Length Value vulnerablity in the TEE_MACComputeFinal function in Samsung mTower through 0.3.0 allows a trusted application to trigger a Denial of Service (DoS) by invoking the function TEE_MACComputeFinal with an excessive size value of messageLen.,7.5,HIGH,2,test,2022-11-28T10:19:34Z,4
CVE-2022-47515,['CWE-Other'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,drachtio/drachtio-server,bugfix (#245) - long incoming message crashes server,4cf9fe2c420b86c16442215d449d40be777c1911,https://github.com/drachtio/drachtio-server/commit/4cf9fe2c420b86c16442215d449d40be777c1911,src/controller.cpp,StackMsg::appendLine,"void StackMsg::appendLine( char *szLine, bool complete ) {
if( complete ) {
m_os.flush() ;
m_sipMessage = m_os.str() ;
m_sipMessage.resize( m_sipMessage.length() - 1) ;
boost::replace_all(m_sipMessage, ""\n"", DR_CRLF);
}
else if( 0 == strcmp(szLine, ""\n"") ) {
m_os << endl ;
}
else {
int i = 0 ;
while( ' ' == szLine[i] && '\0' != szLine[i]) i++ ;
m_os << ( szLine + i ) ;
}
}","void StackMsg::appendLine( char *VAR_0, bool VAR_1 ) {
if( VAR_1 ) {
VAR_2.flush() ;
VAR_3 = VAR_2.str() ;
VAR_3.resize( VAR_3.length() - 1) ;
boost::replace_all(VAR_3, ""\n"", VAR_4);
}
else if( 0 == strcmp(VAR_0, ""\n"") ) {
VAR_2 << VAR_5 ;
}
else {
int VAR_6 = 0 ;
while( ' ' == VAR_0[VAR_6] && '\0' != VAR_0[VAR_6]) VAR_6++ ;
VAR_2 << ( VAR_0 + VAR_6 ) ;
}
}",drachtio/drachtio-server/4cf9fe2c420b86c16442215d449d40be777c1911/controller.cpp/vul/before/0.json,"void StackMsg::appendLine( char *szLine, bool complete ) {
        if( complete ) {
            m_os.flush() ;
            m_sipMessage = m_os.str() ;
            if (m_sipMessage.length() > 1) m_sipMessage.resize( m_sipMessage.length() - 1) ;
            boost::replace_all(m_sipMessage, ""\n"", DR_CRLF);
        }
        else if( 0 == strcmp(szLine, ""\n"") ) {
            m_os << endl ;
        }
        else {
            int i = 0 ;
            while( ' ' == szLine[i] && '\0' != szLine[i]) i++ ;
            m_os << ( szLine + i ) ;
        }
    }","void StackMsg::appendLine( char *VAR_0, bool VAR_1 ) {
        if( VAR_1 ) {
            VAR_2.flush() ;
            VAR_3 = VAR_2.str() ;
            if (VAR_3.length() > 1) VAR_3.resize( VAR_3.length() - 1) ;
            boost::replace_all(VAR_3, ""\n"", VAR_4);
        }
        else if( 0 == strcmp(VAR_0, ""\n"") ) {
            VAR_2 << VAR_5 ;
        }
        else {
            int VAR_6 = 0 ;
            while( ' ' == VAR_0[VAR_6] && '\0' != VAR_0[VAR_6]) VAR_6++ ;
            VAR_2 << ( VAR_0 + VAR_6 ) ;
        }
    }",drachtio/drachtio-server/4cf9fe2c420b86c16442215d449d40be777c1911/controller.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
         if( complete ) {
             m_os.flush() ;
             m_sipMessage = m_os.str() ;
-            m_sipMessage.resize( m_sipMessage.length() - 1) ;
+            if (m_sipMessage.length() > 1) m_sipMessage.resize( m_sipMessage.length() - 1) ;
             boost::replace_all(m_sipMessage, ""\n"", DR_CRLF);
         }
         else if( 0 == strcmp(szLine, ""\n"") ) {","{'deleted_lines': ['            m_sipMessage.resize( m_sipMessage.length() - 1) ;'], 'added_lines': ['            if (m_sipMessage.length() > 1) m_sipMessage.resize( m_sipMessage.length() - 1) ;']}",True,An issue was discovered in drachtio-server before 0.8.20. It allows remote attackers to cause a denial of service (daemon crash) via a long message in a TCP request that leads to std::length_error.,7.5,HIGH,2,test,2022-11-29T18:36:50Z,4
CVE-2022-23476,"['CWE-252', 'CWE-476']",CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,sparklemotion/nokogiri,"fix(cruby): XML::Reader#attribute_hash returns nil on error

Note that on JRuby, the namespaces are still returned because the
parse error would raised on the subsequent node expansion.

This restores the behavior from v1.13.7",9fe0761c47c0d4270d1a5220cfd25de080350d50,https://github.com/sparklemotion/nokogiri/commit/9fe0761c47c0d4270d1a5220cfd25de080350d50,ext/nokogiri/xml_reader.c,rb_xml_reader_attribute_hash,"static VALUE
rb_xml_reader_attribute_hash(VALUE rb_reader)
{
VALUE rb_attributes = rb_hash_new();
xmlTextReaderPtr c_reader;
xmlNodePtr c_node;
xmlAttrPtr c_property;
Data_Get_Struct(rb_reader, xmlTextReader, c_reader);
if (!has_attributes(c_reader)) {
return rb_attributes;
}
c_node = xmlTextReaderExpand(c_reader);
c_property = c_node->properties;
while (c_property != NULL) {
VALUE rb_name = NOKOGIRI_STR_NEW2(c_property->name);
VALUE rb_value = Qnil;
xmlChar *c_value = xmlNodeGetContent((xmlNode *)c_property);
if (c_value) {
rb_value = NOKOGIRI_STR_NEW2(c_value);
xmlFree(c_value);
}
rb_hash_aset(rb_attributes, rb_name, rb_value);
c_property = c_property->next;
}
return rb_attributes;
}","static VALUE
rb_xml_reader_attribute_hash(VALUE VAR_0)
{
VALUE VAR_1 = rb_hash_new();
xmlTextReaderPtr VAR_2;
xmlNodePtr VAR_3;
xmlAttrPtr VAR_4;
Data_Get_Struct(VAR_0, VAR_5, VAR_2);
if (!has_attributes(VAR_2)) {
return VAR_1;
}
VAR_3 = xmlTextReaderExpand(VAR_2);
VAR_4 = VAR_3->properties;
while (VAR_4 != NULL) {
VALUE VAR_6 = NOKOGIRI_STR_NEW2(VAR_4->name);
VALUE VAR_7 = VAR_8;
xmlChar *VAR_9 = xmlNodeGetContent((xmlNode *)VAR_4);
if (VAR_9) {
VAR_7 = NOKOGIRI_STR_NEW2(VAR_9);
xmlFree(VAR_9);
}
rb_hash_aset(VAR_1, VAR_6, VAR_7);
VAR_4 = VAR_4->next;
}
return VAR_1;
}",sparklemotion/nokogiri/9fe0761c47c0d4270d1a5220cfd25de080350d50/xml_reader.c/vul/before/0.json,"static VALUE
rb_xml_reader_attribute_hash(VALUE rb_reader)
{
  VALUE rb_attributes = rb_hash_new();
  xmlTextReaderPtr c_reader;
  xmlNodePtr c_node;
  xmlAttrPtr c_property;

  Data_Get_Struct(rb_reader, xmlTextReader, c_reader);

  if (!has_attributes(c_reader)) {
    return rb_attributes;
  }

  c_node = xmlTextReaderExpand(c_reader);
  if (c_node == NULL) {
    return Qnil;
  }

  c_property = c_node->properties;
  while (c_property != NULL) {
    VALUE rb_name = NOKOGIRI_STR_NEW2(c_property->name);
    VALUE rb_value = Qnil;
    xmlChar *c_value = xmlNodeGetContent((xmlNode *)c_property);

    if (c_value) {
      rb_value = NOKOGIRI_STR_NEW2(c_value);
      xmlFree(c_value);
    }

    rb_hash_aset(rb_attributes, rb_name, rb_value);

    c_property = c_property->next;
  }

  return rb_attributes;
}","static VALUE
rb_xml_reader_attribute_hash(VALUE VAR_0)
{
  VALUE VAR_1 = rb_hash_new();
  xmlTextReaderPtr VAR_2;
  xmlNodePtr VAR_3;
  xmlAttrPtr VAR_4;

  Data_Get_Struct(VAR_0, VAR_5, VAR_2);

  if (!has_attributes(VAR_2)) {
    return VAR_1;
  }

  VAR_3 = xmlTextReaderExpand(VAR_2);
  if (VAR_3 == NULL) {
    return VAR_6;
  }

  VAR_4 = VAR_3->properties;
  while (VAR_4 != NULL) {
    VALUE VAR_7 = NOKOGIRI_STR_NEW2(VAR_4->name);
    VALUE VAR_8 = VAR_6;
    xmlChar *VAR_9 = xmlNodeGetContent((xmlNode *)VAR_4);

    if (VAR_9) {
      VAR_8 = NOKOGIRI_STR_NEW2(VAR_9);
      xmlFree(VAR_9);
    }

    rb_hash_aset(VAR_1, VAR_7, VAR_8);

    VAR_4 = VAR_4->next;
  }

  return VAR_1;
}",sparklemotion/nokogiri/9fe0761c47c0d4270d1a5220cfd25de080350d50/xml_reader.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -13,6 +13,10 @@
   }
 
   c_node = xmlTextReaderExpand(c_reader);
+  if (c_node == NULL) {
+    return Qnil;
+  }
+
   c_property = c_node->properties;
   while (c_property != NULL) {
     VALUE rb_name = NOKOGIRI_STR_NEW2(c_property->name);","{'deleted_lines': [], 'added_lines': ['  if (c_node == NULL) {', '    return Qnil;', '  }', '']}",True,"Nokogiri is an open source XML and HTML library for the Ruby programming language. Nokogiri `1.13.8` and `1.13.9` fail to check the return value from `xmlTextReaderExpand` in the method `Nokogiri::XML::Reader#attribute_hash`. This can lead to a null pointer exception when invalid markup is being parsed. For applications using `XML::Reader` to parse untrusted inputs, this may potentially be a vector for a denial of service attack. Users are advised to upgrade to Nokogiri `>= 1.13.10`. Users may be able to search their code for calls to either `XML::Reader#attributes` or `XML::Reader#attribute_hash` to determine if they are affected.",7.5,HIGH,2,test,2022-12-06T06:51:37Z,4
CVE-2022-47663,['CWE-120'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,gpac,fixed #2360,e7e8745f677010a5cb3366d5cbf39df7cffaaa2d,https://github.com/gpac/gpac/commit/e7e8745f677010a5cb3366d5cbf39df7cffaaa2d,src/filters/reframe_h263.c,h263dmx_process,"GF_Err h263dmx_process(GF_Filter *filter)
{
GF_H263DmxCtx *ctx = gf_filter_get_udta(filter);
GF_FilterPacket *pck, *dst_pck;
u64 byte_offset;
char *data;
u8 *start;
Bool first_frame_found = GF_FALSE;
u32 pck_size;
s32 remain;
if (!ctx->duration.num)
h263dmx_check_dur(filter, ctx);
pck = gf_filter_pid_get_packet(ctx->ipid);
if (!pck) {
if (gf_filter_pid_is_eos(ctx->ipid)) {
if (ctx->opid)
gf_filter_pid_set_eos(ctx->opid);
if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
ctx->src_pck = NULL;
return GF_EOS;
}
return GF_OK;
}
data = (char *) gf_filter_pck_get_data(pck, &pck_size);
byte_offset = gf_filter_pck_get_byte_offset(pck);
start = data;
remain = pck_size;
if (ctx->bytes_in_header) {
#if 0
if (ctx->bytes_in_header + remain < 7) {
memcpy(ctx->header + ctx->bytes_in_header, start, remain);
ctx->bytes_in_header += remain;
gf_filter_pid_drop_packet(ctx->ipid);
return GF_OK;
}
alread_sync = 7 - ctx->bytes_in_header;
memcpy(ctx->header + ctx->bytes_in_header, start, alread_sync);
start += alread_sync;
remain -= alread_sync;
ctx->bytes_in_header = 0;
alread_sync = GF_TRUE;
#endif
}
else if (ctx->timescale) {
if (!ctx->notime) {
u64 cts = gf_filter_pck_get_cts(pck);
if (cts != GF_FILTER_NO_TS)
ctx->cts = cts;
}
if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
ctx->src_pck = pck;
gf_filter_pck_ref_props(&ctx->src_pck);
}
if (ctx->resume_from) {
if (gf_filter_pid_would_block(ctx->opid))
return GF_OK;
start += ctx->resume_from;
remain -= ctx->resume_from;
ctx->resume_from = 0;
}
while (remain) {
u32 size=0;
Bool full_frame;
u8 *pck_data;
s32 current, next;
u32 fmt, w, h;
if (remain<5) {
memcpy(ctx->hdr_store, start, remain);
ctx->bytes_in_header = remain;
break;
}
if (ctx->bytes_in_header) {
if (first_frame_found) {
GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (""[H263Dmx] corrupted frame!\n""));
}
memcpy(ctx->hdr_store + ctx->bytes_in_header, start, 8 - ctx->bytes_in_header);
current = h263dmx_next_start_code(ctx->hdr_store, 8);
if (current<0) {
dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);
if (!dst_pck) return GF_OUT_OF_MEM;
if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
memcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);
gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
gf_filter_pck_set_cts(dst_pck, ctx->cts);
gf_filter_pck_set_duration(dst_pck, ctx->fps.den);
if (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);
}
gf_filter_pck_send(dst_pck);
ctx->bytes_in_header = 0;
current = h263dmx_next_start_code(start, remain);
}
} else {
current = h263dmx_next_start_code(start, remain);
}
if (current<0) {
break;
}
if (current>0) {
if (!ctx->opid) {
if (ctx->bytes_in_header) {
ctx->bytes_in_header -= current;
} else {
start += current;
remain -= current;
}
GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (""[H263Dmx] garbage before first frame!\n""));
continue;
}
if (first_frame_found) {
GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (""[H263Dmx] corrupted frame!\n""));
}
dst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data);
if (!dst_pck) return GF_OUT_OF_MEM;
if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
if (ctx->bytes_in_header) {
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);
}
ctx->bytes_in_header -= current;
memcpy(pck_data, ctx->hdr_store, current);
} else {
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
}
memcpy(pck_data, start, current);
start += current;
remain -= current;
}
gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_TRUE);
gf_filter_pck_set_cts(dst_pck, ctx->cts);
gf_filter_pck_set_duration(dst_pck, ctx->fps.den);
if (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);
gf_filter_pck_send(dst_pck);
h263dmx_update_cts(ctx);
}
if (ctx->bytes_in_header) {
gf_bs_reassign_buffer(ctx->bs, ctx->hdr_store+current, 8-current);
} else if (!ctx->bs) {
ctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);
} else {
gf_bs_reassign_buffer(ctx->bs, start, remain);
}
gf_bs_read_int(ctx->bs, 22);
gf_bs_read_int(ctx->bs, 8);
gf_bs_read_int(ctx->bs, 5);
fmt = gf_bs_read_int(ctx->bs, 3);
h263_get_pic_size(ctx->bs, fmt, &w, &h);
h263dmx_check_pid(filter, ctx, w, h);
if (!ctx->is_playing) {
ctx->resume_from = (u32) ( (char *)start -  (char *)data );
return GF_OK;
}
if (ctx->in_seek) {
u64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->fps.num);
if (ctx->cts + ctx->fps.den >= nb_frames_at_seek) {
ctx->in_seek = GF_FALSE;
}
}
next = h263dmx_next_start_code(start+1, remain-1);
if (next>0) {
size = next+1 + ctx->bytes_in_header;
full_frame = GF_TRUE;
} else {
u8 b3 = start[remain-3];
u8 b2 = start[remain-2];
u8 b1 = start[remain-1];
if (!b1 || !b2 || !b3) {
memcpy(ctx->hdr_store, start+remain-3, 3);
remain -= 3;
ctx->bytes_in_header = 3;
}
size = remain;
full_frame = GF_FALSE;
}
dst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &pck_data);
if (!dst_pck) return GF_OUT_OF_MEM;
if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
if (ctx->bytes_in_header && current) {
memcpy(pck_data, ctx->hdr_store+current, ctx->bytes_in_header);
size -= ctx->bytes_in_header;
ctx->bytes_in_header = 0;
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset + ctx->bytes_in_header);
}
memcpy(pck_data, start, size);
} else {
memcpy(pck_data, start, size);
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data);
}
}
gf_filter_pck_set_framing(dst_pck, GF_TRUE, full_frame);
gf_filter_pck_set_cts(dst_pck, ctx->cts);
gf_filter_pck_set_sap(dst_pck, (start[4]&0x02) ? GF_FILTER_SAP_NONE : GF_FILTER_SAP_1);
gf_filter_pck_set_duration(dst_pck, ctx->fps.den);
if (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);
gf_filter_pck_send(dst_pck);
first_frame_found = GF_TRUE;
start += size;
remain -= size;
if (!full_frame) break;
h263dmx_update_cts(ctx);
if (gf_filter_pid_would_block(ctx->opid)) {
ctx->resume_from = (u32) ( (char *)start -  (char *)data);
return GF_OK;
}
}
gf_filter_pid_drop_packet(ctx->ipid);
return GF_OK;
}","GF_Err h263dmx_process(GF_Filter *VAR_0)
{
GF_H263DmxCtx *VAR_1 = gf_filter_get_udta(VAR_0);
GF_FilterPacket *VAR_2, *VAR_3;
u64 VAR_4;
char *VAR_5;
u8 *VAR_6;
Bool VAR_7 = VAR_8;
u32 VAR_9;
s32 VAR_10;
if (!VAR_1->duration.num)
h263dmx_check_dur(VAR_0, VAR_1);
VAR_2 = gf_filter_pid_get_packet(VAR_1->ipid);
if (!VAR_2) {
if (gf_filter_pid_is_eos(VAR_1->ipid)) {
if (VAR_1->opid)
gf_filter_pid_set_eos(VAR_1->opid);
if (VAR_1->src_pck) gf_filter_pck_unref(VAR_1->src_pck);
VAR_1->src_pck = NULL;
return VAR_11;
}
return VAR_12;
}
VAR_5 = (char *) gf_filter_pck_get_data(VAR_2, &VAR_9);
VAR_4 = gf_filter_pck_get_byte_offset(VAR_2);
VAR_6 = VAR_5;
VAR_10 = VAR_9;
if (VAR_1->bytes_in_header) {
#if 0
if (VAR_1->bytes_in_header + VAR_10 < 7) {
memcpy(VAR_1->header + VAR_1->bytes_in_header, VAR_6, VAR_10);
VAR_1->bytes_in_header += VAR_10;
gf_filter_pid_drop_packet(VAR_1->ipid);
return VAR_12;
}
VAR_13 = 7 - VAR_1->bytes_in_header;
memcpy(VAR_1->header + VAR_1->bytes_in_header, VAR_6, VAR_13);
VAR_6 += VAR_13;
VAR_10 -= VAR_13;
VAR_1->bytes_in_header = 0;
VAR_13 = VAR_14;
#endif
}
else if (VAR_1->timescale) {
if (!VAR_1->notime) {
u64 VAR_15 = gf_filter_pck_get_cts(VAR_2);
if (VAR_15 != VAR_16)
VAR_1->cts = VAR_15;
}
if (VAR_1->src_pck) gf_filter_pck_unref(VAR_1->src_pck);
VAR_1->src_pck = VAR_2;
gf_filter_pck_ref_props(&VAR_1->src_pck);
}
if (VAR_1->resume_from) {
if (gf_filter_pid_would_block(VAR_1->opid))
return VAR_12;
VAR_6 += VAR_1->resume_from;
VAR_10 -= VAR_1->resume_from;
VAR_1->resume_from = 0;
}
while (VAR_10) {
u32 VAR_17=0;
Bool VAR_18;
u8 *VAR_19;
s32 VAR_20, VAR_21;
u32 VAR_22, VAR_23, VAR_24;
if (VAR_10<5) {
memcpy(VAR_1->hdr_store, VAR_6, VAR_10);
VAR_1->bytes_in_header = VAR_10;
break;
}
if (VAR_1->bytes_in_header) {
if (VAR_7) {
GF_LOG(VAR_25, VAR_26, (""[H263Dmx] corrupted frame!\n""));
}
memcpy(VAR_1->hdr_store + VAR_1->bytes_in_header, VAR_6, 8 - VAR_1->bytes_in_header);
VAR_20 = h263dmx_next_start_code(VAR_1->hdr_store, 8);
if (VAR_20<0) {
VAR_3 = gf_filter_pck_new_alloc(VAR_1->opid, VAR_1->bytes_in_header, &VAR_19);
if (!VAR_3) return VAR_27;
if (VAR_1->src_pck) gf_filter_pck_merge_properties(VAR_1->src_pck, VAR_3);
memcpy(VAR_19, VAR_1->hdr_store, VAR_1->bytes_in_header);
gf_filter_pck_set_framing(VAR_3, VAR_8, VAR_8);
gf_filter_pck_set_cts(VAR_3, VAR_1->cts);
gf_filter_pck_set_duration(VAR_3, VAR_1->fps.den);
if (VAR_1->in_seek) gf_filter_pck_set_seek_flag(VAR_3, VAR_14);
if (VAR_4 != VAR_28) {
gf_filter_pck_set_byte_offset(VAR_3, VAR_4 - VAR_1->bytes_in_header);
}
gf_filter_pck_send(VAR_3);
VAR_1->bytes_in_header = 0;
VAR_20 = h263dmx_next_start_code(VAR_6, VAR_10);
}
} else {
VAR_20 = h263dmx_next_start_code(VAR_6, VAR_10);
}
if (VAR_20<0) {
break;
}
if (VAR_20>0) {
if (!VAR_1->opid) {
if (VAR_1->bytes_in_header) {
VAR_1->bytes_in_header -= VAR_20;
} else {
VAR_6 += VAR_20;
VAR_10 -= VAR_20;
}
GF_LOG(VAR_25, VAR_26, (""[H263Dmx] garbage before first frame!\n""));
continue;
}
if (VAR_7) {
GF_LOG(VAR_25, VAR_26, (""[H263Dmx] corrupted frame!\n""));
}
VAR_3 = gf_filter_pck_new_alloc(VAR_1->opid, VAR_20, &VAR_19);
if (!VAR_3) return VAR_27;
if (VAR_1->src_pck) gf_filter_pck_merge_properties(VAR_1->src_pck, VAR_3);
if (VAR_1->bytes_in_header) {
if (VAR_4 != VAR_28) {
gf_filter_pck_set_byte_offset(VAR_3, VAR_4 - VAR_1->bytes_in_header);
}
VAR_1->bytes_in_header -= VAR_20;
memcpy(VAR_19, VAR_1->hdr_store, VAR_20);
} else {
if (VAR_4 != VAR_28) {
gf_filter_pck_set_byte_offset(VAR_3, VAR_4);
}
memcpy(VAR_19, VAR_6, VAR_20);
VAR_6 += VAR_20;
VAR_10 -= VAR_20;
}
gf_filter_pck_set_framing(VAR_3, VAR_8, VAR_14);
gf_filter_pck_set_cts(VAR_3, VAR_1->cts);
gf_filter_pck_set_duration(VAR_3, VAR_1->fps.den);
if (VAR_1->in_seek) gf_filter_pck_set_seek_flag(VAR_3, VAR_14);
gf_filter_pck_send(VAR_3);
h263dmx_update_cts(VAR_1);
}
if (VAR_1->bytes_in_header) {
gf_bs_reassign_buffer(VAR_1->bs, VAR_1->hdr_store+VAR_20, 8-VAR_20);
} else if (!VAR_1->bs) {
VAR_1->bs = gf_bs_new(VAR_6, VAR_10, VAR_29);
} else {
gf_bs_reassign_buffer(VAR_1->bs, VAR_6, VAR_10);
}
gf_bs_read_int(VAR_1->bs, 22);
gf_bs_read_int(VAR_1->bs, 8);
gf_bs_read_int(VAR_1->bs, 5);
VAR_22 = gf_bs_read_int(VAR_1->bs, 3);
h263_get_pic_size(VAR_1->bs, VAR_22, &VAR_23, &VAR_24);
h263dmx_check_pid(VAR_0, VAR_1, VAR_23, VAR_24);
if (!VAR_1->is_playing) {
VAR_1->resume_from = (u32) ( (char *)VAR_6 -  (char *)VAR_5 );
return VAR_12;
}
if (VAR_1->in_seek) {
u64 VAR_30 = (u64) (VAR_1->start_range * VAR_1->fps.num);
if (VAR_1->cts + VAR_1->fps.den >= VAR_30) {
VAR_1->in_seek = VAR_8;
}
}
VAR_21 = h263dmx_next_start_code(VAR_6+1, VAR_10-1);
if (VAR_21>0) {
VAR_17 = VAR_21+1 + VAR_1->bytes_in_header;
VAR_18 = VAR_14;
} else {
u8 VAR_31 = VAR_6[VAR_10-3];
u8 VAR_32 = VAR_6[VAR_10-2];
u8 VAR_33 = VAR_6[VAR_10-1];
if (!VAR_33 || !VAR_32 || !VAR_31) {
memcpy(VAR_1->hdr_store, VAR_6+VAR_10-3, 3);
VAR_10 -= 3;
VAR_1->bytes_in_header = 3;
}
VAR_17 = VAR_10;
VAR_18 = VAR_8;
}
VAR_3 = gf_filter_pck_new_alloc(VAR_1->opid, VAR_17, &VAR_19);
if (!VAR_3) return VAR_27;
if (VAR_1->src_pck) gf_filter_pck_merge_properties(VAR_1->src_pck, VAR_3);
if (VAR_1->bytes_in_header && VAR_20) {
memcpy(VAR_19, VAR_1->hdr_store+VAR_20, VAR_1->bytes_in_header);
VAR_17 -= VAR_1->bytes_in_header;
VAR_1->bytes_in_header = 0;
if (VAR_4 != VAR_28) {
gf_filter_pck_set_byte_offset(VAR_3, VAR_4 + VAR_1->bytes_in_header);
}
memcpy(VAR_19, VAR_6, VAR_17);
} else {
memcpy(VAR_19, VAR_6, VAR_17);
if (VAR_4 != VAR_28) {
gf_filter_pck_set_byte_offset(VAR_3, VAR_4 + VAR_6 - (u8 *) VAR_5);
}
}
gf_filter_pck_set_framing(VAR_3, VAR_14, VAR_18);
gf_filter_pck_set_cts(VAR_3, VAR_1->cts);
gf_filter_pck_set_sap(VAR_3, (VAR_6[4]&0x02) ? VAR_34 : VAR_35);
gf_filter_pck_set_duration(VAR_3, VAR_1->fps.den);
if (VAR_1->in_seek) gf_filter_pck_set_seek_flag(VAR_3, VAR_14);
gf_filter_pck_send(VAR_3);
VAR_7 = VAR_14;
VAR_6 += VAR_17;
VAR_10 -= VAR_17;
if (!VAR_18) break;
h263dmx_update_cts(VAR_1);
if (gf_filter_pid_would_block(VAR_1->opid)) {
VAR_1->resume_from = (u32) ( (char *)VAR_6 -  (char *)VAR_5);
return VAR_12;
}
}
gf_filter_pid_drop_packet(VAR_1->ipid);
return VAR_12;
}",gpac/e7e8745f677010a5cb3366d5cbf39df7cffaaa2d/reframe_h263.c/vul/before/0.json,"GF_Err h263dmx_process(GF_Filter *filter)
{
	GF_H263DmxCtx *ctx = gf_filter_get_udta(filter);
	GF_FilterPacket *pck, *dst_pck;
	u64 byte_offset;
	char *data;
	u8 *start;
	Bool first_frame_found = GF_FALSE;
	u32 pck_size;
	s32 remain;

	//always reparse duration
	if (!ctx->duration.num)
		h263dmx_check_dur(filter, ctx);

	pck = gf_filter_pid_get_packet(ctx->ipid);
	if (!pck) {
		if (gf_filter_pid_is_eos(ctx->ipid)) {
			if (ctx->opid)
				gf_filter_pid_set_eos(ctx->opid);
			if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
			ctx->src_pck = NULL;
			return GF_EOS;
		}
		return GF_OK;
	}

	data = (char *) gf_filter_pck_get_data(pck, &pck_size);
	byte_offset = gf_filter_pck_get_byte_offset(pck);

	start = data;
	remain = pck_size;


	if (ctx->bytes_in_header) {
#if 0
		if (ctx->bytes_in_header + remain < 7) {
			memcpy(ctx->header + ctx->bytes_in_header, start, remain);
			ctx->bytes_in_header += remain;
			gf_filter_pid_drop_packet(ctx->ipid);
			return GF_OK;
		}
		alread_sync = 7 - ctx->bytes_in_header;
		memcpy(ctx->header + ctx->bytes_in_header, start, alread_sync);
		start += alread_sync;
		remain -= alread_sync;
		ctx->bytes_in_header = 0;
		alread_sync = GF_TRUE;
#endif

	}
	//input pid is muxed - we flushed pending data , update cts unless recomputing timing
	else if (ctx->timescale) {
		if (!ctx->notime) {
			u64 cts = gf_filter_pck_get_cts(pck);
			if (cts != GF_FILTER_NO_TS)
				ctx->cts = cts;
		}
		if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
		ctx->src_pck = pck;
		gf_filter_pck_ref_props(&ctx->src_pck);
	}

	if (ctx->resume_from) {
		if (gf_filter_pid_would_block(ctx->opid))
			return GF_OK;
		start += ctx->resume_from;
		remain -= ctx->resume_from;
		ctx->resume_from = 0;
	}

	while (remain) {
		u32 size=0;
		Bool full_frame;
		u8 *pck_data;
		s32 current, next;
		u32 fmt, w, h;

		//not enough bytes
		if (remain<5) {
			memcpy(ctx->hdr_store, start, remain);
			ctx->bytes_in_header = remain;
			break;
		}

		if (ctx->bytes_in_header) {
			if (first_frame_found) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (""[H263Dmx] corrupted frame!\n""));
			}

			memcpy(ctx->hdr_store + ctx->bytes_in_header, start, 8 - ctx->bytes_in_header);
			current = h263dmx_next_start_code(ctx->hdr_store, 8);

			//no start code in stored buffer
			if (current<0) {
				dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);
				if (!dst_pck) return GF_OUT_OF_MEM;

				if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);

				memcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);
				gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
				gf_filter_pck_set_cts(dst_pck, ctx->cts);
				gf_filter_pck_set_duration(dst_pck, ctx->fps.den);
				if (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);

				if (byte_offset != GF_FILTER_NO_BO) {
					gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);
				}
				gf_filter_pck_send(dst_pck);
				ctx->bytes_in_header = 0;

				current = h263dmx_next_start_code(start, remain);
			}
		} else {
			//locate next start code
			current = h263dmx_next_start_code(start, remain);
		}


		if (current<0) {
			//not enough bytes to process start code !!
			break;
		}

		if (current>0) {
			if (!ctx->opid) {
				if (ctx->bytes_in_header) {
					if (ctx->bytes_in_header<current) {
						current-=ctx->bytes_in_header;
						ctx->bytes_in_header = 0;
						start += current;
						remain -= current;
					} else {
						ctx->bytes_in_header -= current;
					}
				} else {
					start += current;
					remain -= current;
				}
				GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (""[H263Dmx] garbage before first frame!\n""));
				continue;
			}
			if (first_frame_found) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (""[H263Dmx] corrupted frame!\n""));
			}
			//flush remaining
			dst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data);
			if (!dst_pck) return GF_OUT_OF_MEM;

			if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);

			if (ctx->bytes_in_header) {
				if (byte_offset != GF_FILTER_NO_BO) {
					gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);
				}
				memcpy(pck_data, ctx->hdr_store, current);
				//we may have a partial startcode
				if (current>ctx->bytes_in_header) {
					current -= ctx->bytes_in_header;
					start += current;
					remain -= current;
					ctx->bytes_in_header = 0;
				} else {
					ctx->bytes_in_header -= current;
				}
			} else {
				if (byte_offset != GF_FILTER_NO_BO) {
					gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
				}
				memcpy(pck_data, start, current);
				start += current;
				remain -= current;
			}
			gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_TRUE);
			gf_filter_pck_set_cts(dst_pck, ctx->cts);
			gf_filter_pck_set_duration(dst_pck, ctx->fps.den);
			if (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);
			gf_filter_pck_send(dst_pck);

			h263dmx_update_cts(ctx);
		}

		if (ctx->bytes_in_header) {
			gf_bs_reassign_buffer(ctx->bs, ctx->hdr_store+current, 8-current);
		} else if (!ctx->bs) {
			ctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);
		} else {
			gf_bs_reassign_buffer(ctx->bs, start, remain);
		}
		/*parse header*/
		gf_bs_read_int(ctx->bs, 22);
		gf_bs_read_int(ctx->bs, 8);
		/*spare+0+split_screen_indicator+document_camera_indicator+freeze_picture_release*/
		gf_bs_read_int(ctx->bs, 5);

		fmt = gf_bs_read_int(ctx->bs, 3);
		h263_get_pic_size(ctx->bs, fmt, &w, &h);

		h263dmx_check_pid(filter, ctx, w, h);

		if (!ctx->is_playing) {
			ctx->resume_from = (u32) ( (char *)start -  (char *)data );
			return GF_OK;
		}

		if (ctx->in_seek) {
			u64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->fps.num);
			if (ctx->cts + ctx->fps.den >= nb_frames_at_seek) {
				//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;
				ctx->in_seek = GF_FALSE;
			}
		}

		//good to go
		next = h263dmx_next_start_code(start+1, remain-1);

		if (next>0) {
			size = next+1 + ctx->bytes_in_header;
			full_frame = GF_TRUE;
		} else {
			u8 b3 = start[remain-3];
			u8 b2 = start[remain-2];
			u8 b1 = start[remain-1];
			//we may have a startcode here !
			if (!b1 || !b2 || !b3) {
				memcpy(ctx->hdr_store, start+remain-3, 3);
				remain -= 3;
				ctx->bytes_in_header = 3;
			}
			size = remain;
			full_frame = GF_FALSE;
		}

		dst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &pck_data);
		if (!dst_pck) return GF_OUT_OF_MEM;

		if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
		if (ctx->bytes_in_header && current) {
			memcpy(pck_data, ctx->hdr_store+current, ctx->bytes_in_header);
			size -= ctx->bytes_in_header;
			ctx->bytes_in_header = 0;
			if (byte_offset != GF_FILTER_NO_BO) {
				gf_filter_pck_set_byte_offset(dst_pck, byte_offset + ctx->bytes_in_header);
			}
			memcpy(pck_data, start, size);
		} else {
			memcpy(pck_data, start, size);
			if (byte_offset != GF_FILTER_NO_BO) {
				gf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data);
			}
		}

		gf_filter_pck_set_framing(dst_pck, GF_TRUE, full_frame);
		gf_filter_pck_set_cts(dst_pck, ctx->cts);
		gf_filter_pck_set_sap(dst_pck, (start[4]&0x02) ? GF_FILTER_SAP_NONE : GF_FILTER_SAP_1);
		gf_filter_pck_set_duration(dst_pck, ctx->fps.den);
		if (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);
		gf_filter_pck_send(dst_pck);

		first_frame_found = GF_TRUE;
		start += size;
		remain -= size;
		if (!full_frame) break;
		h263dmx_update_cts(ctx);


		//don't demux too much of input, abort when we would block. This avoid dispatching
		//a huge number of frames in a single call
		if (gf_filter_pid_would_block(ctx->opid)) {
			ctx->resume_from = (u32) ( (char *)start -  (char *)data);
			return GF_OK;
		}
	}
	gf_filter_pid_drop_packet(ctx->ipid);

	return GF_OK;
}","GF_Err h263dmx_process(GF_Filter *VAR_0)
{
	GF_H263DmxCtx *VAR_1 = gf_filter_get_udta(VAR_0);
	GF_FilterPacket *VAR_2, *VAR_3;
	u64 VAR_4;
	char *VAR_5;
	u8 *VAR_6;
	Bool VAR_7 = VAR_8;
	u32 VAR_9;
	s32 VAR_10;

	/* COMMENT_0 */
	if (!VAR_1->duration.num)
		h263dmx_check_dur(VAR_0, VAR_1);

	VAR_2 = gf_filter_pid_get_packet(VAR_1->ipid);
	if (!VAR_2) {
		if (gf_filter_pid_is_eos(VAR_1->ipid)) {
			if (VAR_1->opid)
				gf_filter_pid_set_eos(VAR_1->opid);
			if (VAR_1->src_pck) gf_filter_pck_unref(VAR_1->src_pck);
			VAR_1->src_pck = NULL;
			return VAR_11;
		}
		return VAR_12;
	}

	VAR_5 = (char *) gf_filter_pck_get_data(VAR_2, &VAR_9);
	VAR_4 = gf_filter_pck_get_byte_offset(VAR_2);

	VAR_6 = VAR_5;
	VAR_10 = VAR_9;


	if (VAR_1->bytes_in_header) {
#if 0
		if (VAR_1->bytes_in_header + VAR_10 < 7) {
			memcpy(VAR_1->header + VAR_1->bytes_in_header, VAR_6, VAR_10);
			VAR_1->bytes_in_header += VAR_10;
			gf_filter_pid_drop_packet(VAR_1->ipid);
			return VAR_12;
		}
		VAR_13 = 7 - VAR_1->bytes_in_header;
		memcpy(VAR_1->header + VAR_1->bytes_in_header, VAR_6, VAR_13);
		VAR_6 += VAR_13;
		VAR_10 -= VAR_13;
		VAR_1->bytes_in_header = 0;
		VAR_13 = VAR_14;
#endif

	}
	/* COMMENT_1 */
	else if (VAR_1->timescale) {
		if (!VAR_1->notime) {
			u64 VAR_15 = gf_filter_pck_get_cts(VAR_2);
			if (VAR_15 != VAR_16)
				VAR_1->cts = VAR_15;
		}
		if (VAR_1->src_pck) gf_filter_pck_unref(VAR_1->src_pck);
		VAR_1->src_pck = VAR_2;
		gf_filter_pck_ref_props(&VAR_1->src_pck);
	}

	if (VAR_1->resume_from) {
		if (gf_filter_pid_would_block(VAR_1->opid))
			return VAR_12;
		VAR_6 += VAR_1->resume_from;
		VAR_10 -= VAR_1->resume_from;
		VAR_1->resume_from = 0;
	}

	while (VAR_10) {
		u32 VAR_17=0;
		Bool VAR_18;
		u8 *VAR_19;
		s32 VAR_20, VAR_21;
		u32 VAR_22, VAR_23, VAR_24;

		/* COMMENT_2 */
		if (VAR_10<5) {
			memcpy(VAR_1->hdr_store, VAR_6, VAR_10);
			VAR_1->bytes_in_header = VAR_10;
			break;
		}

		if (VAR_1->bytes_in_header) {
			if (VAR_7) {
				GF_LOG(VAR_25, VAR_26, (""[H263Dmx] corrupted frame!\n""));
			}

			memcpy(VAR_1->hdr_store + VAR_1->bytes_in_header, VAR_6, 8 - VAR_1->bytes_in_header);
			VAR_20 = h263dmx_next_start_code(VAR_1->hdr_store, 8);

			/* COMMENT_3 */
			if (VAR_20<0) {
				VAR_3 = gf_filter_pck_new_alloc(VAR_1->opid, VAR_1->bytes_in_header, &VAR_19);
				if (!VAR_3) return VAR_27;

				if (VAR_1->src_pck) gf_filter_pck_merge_properties(VAR_1->src_pck, VAR_3);

				memcpy(VAR_19, VAR_1->hdr_store, VAR_1->bytes_in_header);
				gf_filter_pck_set_framing(VAR_3, VAR_8, VAR_8);
				gf_filter_pck_set_cts(VAR_3, VAR_1->cts);
				gf_filter_pck_set_duration(VAR_3, VAR_1->fps.den);
				if (VAR_1->in_seek) gf_filter_pck_set_seek_flag(VAR_3, VAR_14);

				if (VAR_4 != VAR_28) {
					gf_filter_pck_set_byte_offset(VAR_3, VAR_4 - VAR_1->bytes_in_header);
				}
				gf_filter_pck_send(VAR_3);
				VAR_1->bytes_in_header = 0;

				VAR_20 = h263dmx_next_start_code(VAR_6, VAR_10);
			}
		} else {
			/* COMMENT_4 */
			VAR_20 = h263dmx_next_start_code(VAR_6, VAR_10);
		}


		if (VAR_20<0) {
			/* COMMENT_5 */
			break;
		}

		if (VAR_20>0) {
			if (!VAR_1->opid) {
				if (VAR_1->bytes_in_header) {
					if (VAR_1->bytes_in_header<VAR_20) {
						VAR_20-=VAR_1->bytes_in_header;
						VAR_1->bytes_in_header = 0;
						VAR_6 += VAR_20;
						VAR_10 -= VAR_20;
					} else {
						VAR_1->bytes_in_header -= VAR_20;
					}
				} else {
					VAR_6 += VAR_20;
					VAR_10 -= VAR_20;
				}
				GF_LOG(VAR_25, VAR_26, (""[H263Dmx] garbage before first frame!\n""));
				continue;
			}
			if (VAR_7) {
				GF_LOG(VAR_25, VAR_26, (""[H263Dmx] corrupted frame!\n""));
			}
			/* COMMENT_6 */
			VAR_3 = gf_filter_pck_new_alloc(VAR_1->opid, VAR_20, &VAR_19);
			if (!VAR_3) return VAR_27;

			if (VAR_1->src_pck) gf_filter_pck_merge_properties(VAR_1->src_pck, VAR_3);

			if (VAR_1->bytes_in_header) {
				if (VAR_4 != VAR_28) {
					gf_filter_pck_set_byte_offset(VAR_3, VAR_4 - VAR_1->bytes_in_header);
				}
				memcpy(VAR_19, VAR_1->hdr_store, VAR_20);
				/* COMMENT_7 */
				if (VAR_20>VAR_1->bytes_in_header) {
					VAR_20 -= VAR_1->bytes_in_header;
					VAR_6 += VAR_20;
					VAR_10 -= VAR_20;
					VAR_1->bytes_in_header = 0;
				} else {
					VAR_1->bytes_in_header -= VAR_20;
				}
			} else {
				if (VAR_4 != VAR_28) {
					gf_filter_pck_set_byte_offset(VAR_3, VAR_4);
				}
				memcpy(VAR_19, VAR_6, VAR_20);
				VAR_6 += VAR_20;
				VAR_10 -= VAR_20;
			}
			gf_filter_pck_set_framing(VAR_3, VAR_8, VAR_14);
			gf_filter_pck_set_cts(VAR_3, VAR_1->cts);
			gf_filter_pck_set_duration(VAR_3, VAR_1->fps.den);
			if (VAR_1->in_seek) gf_filter_pck_set_seek_flag(VAR_3, VAR_14);
			gf_filter_pck_send(VAR_3);

			h263dmx_update_cts(VAR_1);
		}

		if (VAR_1->bytes_in_header) {
			gf_bs_reassign_buffer(VAR_1->bs, VAR_1->hdr_store+VAR_20, 8-VAR_20);
		} else if (!VAR_1->bs) {
			VAR_1->bs = gf_bs_new(VAR_6, VAR_10, VAR_29);
		} else {
			gf_bs_reassign_buffer(VAR_1->bs, VAR_6, VAR_10);
		}
		/* COMMENT_8 */
		gf_bs_read_int(VAR_1->bs, 22);
		gf_bs_read_int(VAR_1->bs, 8);
		/* COMMENT_9 */
		gf_bs_read_int(VAR_1->bs, 5);

		VAR_22 = gf_bs_read_int(VAR_1->bs, 3);
		h263_get_pic_size(VAR_1->bs, VAR_22, &VAR_23, &VAR_24);

		h263dmx_check_pid(VAR_0, VAR_1, VAR_23, VAR_24);

		if (!VAR_1->is_playing) {
			VAR_1->resume_from = (u32) ( (char *)VAR_6 -  (char *)VAR_5 );
			return VAR_12;
		}

		if (VAR_1->in_seek) {
			u64 VAR_30 = (u64) (VAR_1->start_range * VAR_1->fps.num);
			if (VAR_1->cts + VAR_1->fps.den >= VAR_30) {
				/* COMMENT_10 */
				VAR_1->in_seek = VAR_8;
			}
		}

		/* COMMENT_11 */
		VAR_21 = h263dmx_next_start_code(VAR_6+1, VAR_10-1);

		if (VAR_21>0) {
			VAR_17 = VAR_21+1 + VAR_1->bytes_in_header;
			VAR_18 = VAR_14;
		} else {
			u8 VAR_31 = VAR_6[VAR_10-3];
			u8 VAR_32 = VAR_6[VAR_10-2];
			u8 VAR_33 = VAR_6[VAR_10-1];
			/* COMMENT_12 */
			if (!VAR_33 || !VAR_32 || !VAR_31) {
				memcpy(VAR_1->hdr_store, VAR_6+VAR_10-3, 3);
				VAR_10 -= 3;
				VAR_1->bytes_in_header = 3;
			}
			VAR_17 = VAR_10;
			VAR_18 = VAR_8;
		}

		VAR_3 = gf_filter_pck_new_alloc(VAR_1->opid, VAR_17, &VAR_19);
		if (!VAR_3) return VAR_27;

		if (VAR_1->src_pck) gf_filter_pck_merge_properties(VAR_1->src_pck, VAR_3);
		if (VAR_1->bytes_in_header && VAR_20) {
			memcpy(VAR_19, VAR_1->hdr_store+VAR_20, VAR_1->bytes_in_header);
			VAR_17 -= VAR_1->bytes_in_header;
			VAR_1->bytes_in_header = 0;
			if (VAR_4 != VAR_28) {
				gf_filter_pck_set_byte_offset(VAR_3, VAR_4 + VAR_1->bytes_in_header);
			}
			memcpy(VAR_19, VAR_6, VAR_17);
		} else {
			memcpy(VAR_19, VAR_6, VAR_17);
			if (VAR_4 != VAR_28) {
				gf_filter_pck_set_byte_offset(VAR_3, VAR_4 + VAR_6 - (u8 *) VAR_5);
			}
		}

		gf_filter_pck_set_framing(VAR_3, VAR_14, VAR_18);
		gf_filter_pck_set_cts(VAR_3, VAR_1->cts);
		gf_filter_pck_set_sap(VAR_3, (VAR_6[4]&0x02) ? VAR_34 : VAR_35);
		gf_filter_pck_set_duration(VAR_3, VAR_1->fps.den);
		if (VAR_1->in_seek) gf_filter_pck_set_seek_flag(VAR_3, VAR_14);
		gf_filter_pck_send(VAR_3);

		VAR_7 = VAR_14;
		VAR_6 += VAR_17;
		VAR_10 -= VAR_17;
		if (!VAR_18) break;
		h263dmx_update_cts(VAR_1);


		/* COMMENT_13 */
		/* COMMENT_14 */
		if (gf_filter_pid_would_block(VAR_1->opid)) {
			VAR_1->resume_from = (u32) ( (char *)VAR_6 -  (char *)VAR_5);
			return VAR_12;
		}
	}
	gf_filter_pid_drop_packet(VAR_1->ipid);

	return VAR_12;
}",gpac/e7e8745f677010a5cb3366d5cbf39df7cffaaa2d/reframe_h263.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -126,7 +126,14 @@
 		if (current>0) {
 			if (!ctx->opid) {
 				if (ctx->bytes_in_header) {
-					ctx->bytes_in_header -= current;
+					if (ctx->bytes_in_header<current) {
+						current-=ctx->bytes_in_header;
+						ctx->bytes_in_header = 0;
+						start += current;
+						remain -= current;
+					} else {
+						ctx->bytes_in_header -= current;
+					}
 				} else {
 					start += current;
 					remain -= current;
@@ -147,8 +154,16 @@
 				if (byte_offset != GF_FILTER_NO_BO) {
 					gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);
 				}
-				ctx->bytes_in_header -= current;
 				memcpy(pck_data, ctx->hdr_store, current);
+				//we may have a partial startcode
+				if (current>ctx->bytes_in_header) {
+					current -= ctx->bytes_in_header;
+					start += current;
+					remain -= current;
+					ctx->bytes_in_header = 0;
+				} else {
+					ctx->bytes_in_header -= current;
+				}
 			} else {
 				if (byte_offset != GF_FILTER_NO_BO) {
 					gf_filter_pck_set_byte_offset(dst_pck, byte_offset);","{'deleted_lines': ['\t\t\t\t\tctx->bytes_in_header -= current;', '\t\t\t\tctx->bytes_in_header -= current;'], 'added_lines': ['\t\t\t\t\tif (ctx->bytes_in_header<current) {', '\t\t\t\t\t\tcurrent-=ctx->bytes_in_header;', '\t\t\t\t\t\tctx->bytes_in_header = 0;', '\t\t\t\t\t\tstart += current;', '\t\t\t\t\t\tremain -= current;', '\t\t\t\t\t} else {', '\t\t\t\t\t\tctx->bytes_in_header -= current;', '\t\t\t\t\t}', '\t\t\t\t//we may have a partial startcode', '\t\t\t\tif (current>ctx->bytes_in_header) {', '\t\t\t\t\tcurrent -= ctx->bytes_in_header;', '\t\t\t\t\tstart += current;', '\t\t\t\t\tremain -= current;', '\t\t\t\t\tctx->bytes_in_header = 0;', '\t\t\t\t} else {', '\t\t\t\t\tctx->bytes_in_header -= current;', '\t\t\t\t}']}",True,GPAC MP4box 2.1-DEV-rev649-ga8f438d20 is vulnerable to buffer overflow in h263dmx_process filters/reframe_h263.c:609,7.8,HIGH,2,test,2022-12-19T11:26:02Z,4
CVE-2022-23537,['CWE-122'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,pjsip/pjproject,"Merge pull request from GHSA-9pfh-r8x4-w26w

* Fix buffer overread in STUN message decoder

* Updates based on comments",d8440f4d711a654b511f50f79c0445b26f9dd1e1,https://github.com/pjsip/pjproject/commit/d8440f4d711a654b511f50f79c0445b26f9dd1e1,pjnath/src/pjnath/stun_msg.c,pj_stun_msg_decode,"PJ_DEF(pj_status_t) pj_stun_msg_decode(pj_pool_t *pool,
const pj_uint8_t *pdu,
pj_size_t pdu_len,
unsigned options,
pj_stun_msg **p_msg,
pj_size_t *p_parsed_len,
pj_stun_msg **p_response)
{
pj_stun_msg *msg;
const pj_uint8_t *start_pdu = pdu;
pj_bool_t has_msg_int = PJ_FALSE;
pj_bool_t has_fingerprint = PJ_FALSE;
pj_status_t status;
PJ_UNUSED_ARG(options);
PJ_ASSERT_RETURN(pool && pdu && pdu_len && p_msg, PJ_EINVAL);
PJ_ASSERT_RETURN(sizeof(pj_stun_msg_hdr) == 20, PJ_EBUG);
if (p_parsed_len)
*p_parsed_len = 0;
if (p_response)
*p_response = NULL;
if (options & PJ_STUN_CHECK_PACKET) {
status = pj_stun_msg_check(pdu, pdu_len, options);
if (status != PJ_SUCCESS)
return status;
}
msg = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);
pj_memcpy(&msg->hdr, pdu, sizeof(pj_stun_msg_hdr));
msg->hdr.type = pj_ntohs(msg->hdr.type);
msg->hdr.length = pj_ntohs(msg->hdr.length);
msg->hdr.magic = pj_ntohl(msg->hdr.magic);
pdu += sizeof(pj_stun_msg_hdr);
pdu_len = msg->hdr.length;
if (!PJ_STUN_IS_REQUEST(msg->hdr.type))
p_response = NULL;
while (pdu_len >= 4) {
unsigned attr_type, attr_val_len;
const struct attr_desc *adesc;
attr_type = GETVAL16H(pdu, 0);
attr_val_len = GETVAL16H(pdu, 2);
attr_val_len = (attr_val_len + 3) & (~3);
if (pdu_len < attr_val_len) {
pj_str_t err_msg;
char err_msg_buf[80];
err_msg.ptr = err_msg_buf;
err_msg.slen = pj_ansi_snprintf(err_msg_buf, sizeof(err_msg_buf),
""Attribute %s has invalid length"",
pj_stun_get_attr_name(attr_type));
PJ_LOG(4,(THIS_FILE, ""Error decoding message: %.*s"",
(int)err_msg.slen, err_msg.ptr));
if (p_response) {
pj_stun_msg_create_response(pool, msg, 
PJ_STUN_SC_BAD_REQUEST, 
&err_msg, p_response);
}
return PJNATH_ESTUNINATTRLEN;
}
adesc = find_attr_desc(attr_type);
if (adesc == NULL) {
pj_stun_binary_attr *attr = NULL;
PJ_LOG(5,(THIS_FILE, ""Unrecognized attribute type 0x%x"", 
attr_type));
if (attr_type <= 0x7FFF) {
if (p_response) {
unsigned err_code = PJ_STUN_SC_UNKNOWN_ATTRIBUTE;
status = pj_stun_msg_create_response(pool, msg,
err_code, NULL, 
p_response);
if (status==PJ_SUCCESS) {
pj_uint16_t d = (pj_uint16_t)attr_type;
pj_stun_msg_add_unknown_attr(pool, *p_response, 1, &d);
}
}
return PJ_STATUS_FROM_STUN_CODE(PJ_STUN_SC_UNKNOWN_ATTRIBUTE);
}
if (msg->attr_count >= PJ_STUN_MAX_ATTR) {
if (p_response) {
pj_stun_msg_create_response(pool, msg,
PJ_STUN_SC_SERVER_ERROR,
NULL, p_response);
}
return PJNATH_ESTUNTOOMANYATTR;
}
status = pj_stun_binary_attr_create(pool, attr_type, pdu+4, 
GETVAL16H(pdu, 2), &attr);
if (status != PJ_SUCCESS) {
if (p_response) {
pj_stun_msg_create_response(pool, msg,
PJ_STUN_SC_SERVER_ERROR,
NULL, p_response);
}
PJ_LOG(4,(THIS_FILE, 
""Error parsing unknown STUN attribute type %d"",
attr_type));
return status;
}
msg->attr[msg->attr_count++] = &attr->hdr;
} else {
void *attr;
char err_msg1[PJ_ERR_MSG_SIZE],
err_msg2[PJ_ERR_MSG_SIZE];
status = (adesc->decode_attr)(pool, pdu, &msg->hdr, &attr);
if (status != PJ_SUCCESS) {
pj_strerror(status, err_msg1, sizeof(err_msg1));
if (p_response) {
pj_str_t e;
e.ptr = err_msg2;
e.slen= pj_ansi_snprintf(err_msg2, sizeof(err_msg2),
""%s in %s"",
err_msg1,
pj_stun_get_attr_name(attr_type));
if (e.slen < 1 || e.slen >= (int)sizeof(err_msg2))
e.slen = sizeof(err_msg2) - 1;
pj_stun_msg_create_response(pool, msg,
PJ_STUN_SC_BAD_REQUEST,
&e, p_response);
}
PJ_LOG(4,(THIS_FILE, 
""Error parsing STUN attribute %s: %s"",
pj_stun_get_attr_name(attr_type), 
err_msg1));
return status;
}
if (attr_type == PJ_STUN_ATTR_MESSAGE_INTEGRITY && 
!has_fingerprint) 
{
if (has_msg_int) {
if (p_response) {
pj_stun_msg_create_response(pool, msg,
PJ_STUN_SC_BAD_REQUEST,
NULL, p_response);
}
return PJNATH_ESTUNDUPATTR;
}
has_msg_int = PJ_TRUE;
} else if (attr_type == PJ_STUN_ATTR_FINGERPRINT) {
if (has_fingerprint) {
if (p_response) {
pj_stun_msg_create_response(pool, msg,
PJ_STUN_SC_BAD_REQUEST,
NULL, p_response);
}
return PJNATH_ESTUNDUPATTR;
}
has_fingerprint = PJ_TRUE;
} else {
if (has_fingerprint) {
if (p_response) {
pj_stun_msg_create_response(pool, msg,
PJ_STUN_SC_BAD_REQUEST,
NULL, p_response);
}
return PJNATH_ESTUNFINGERPOS;
}
}
if (msg->attr_count >= PJ_STUN_MAX_ATTR) {
if (p_response) {
pj_stun_msg_create_response(pool, msg,
PJ_STUN_SC_SERVER_ERROR,
NULL, p_response);
}
return PJNATH_ESTUNTOOMANYATTR;
}
msg->attr[msg->attr_count++] = (pj_stun_attr_hdr*)attr;
}
if (attr_val_len + 4 >= pdu_len) {
pdu += pdu_len;
pdu_len = 0;
} else {
pdu += (attr_val_len + 4);
pdu_len -= (attr_val_len + 4);
}
}
if (pdu_len > 0) {
PJ_LOG(4,(THIS_FILE, 
""Error decoding STUN message: unparsed trailing %d bytes"",
pdu_len));
return PJNATH_EINSTUNMSGLEN;
}
*p_msg = msg;
if (p_parsed_len)
*p_parsed_len = (pdu - start_pdu);
return PJ_SUCCESS;
}","VAR_0(pj_status_t) pj_stun_msg_decode(pj_pool_t *VAR_1,
const pj_uint8_t *VAR_2,
pj_size_t VAR_3,
unsigned VAR_4,
pj_stun_msg **VAR_5,
pj_size_t *VAR_6,
pj_stun_msg **VAR_7)
{
pj_stun_msg *VAR_8;
const pj_uint8_t *VAR_9 = VAR_2;
pj_bool_t VAR_10 = VAR_11;
pj_bool_t VAR_12 = VAR_11;
pj_status_t VAR_13;
PJ_UNUSED_ARG(VAR_4);
PJ_ASSERT_RETURN(VAR_1 && VAR_2 && VAR_3 && VAR_5, VAR_14);
PJ_ASSERT_RETURN(sizeof(VAR_15) == 20, VAR_16);
if (VAR_6)
*VAR_6 = 0;
if (VAR_7)
*VAR_7 = NULL;
if (VAR_4 & VAR_17) {
VAR_13 = pj_stun_msg_check(VAR_2, VAR_3, VAR_4);
if (VAR_13 != VAR_18)
return VAR_13;
}
VAR_8 = PJ_POOL_ZALLOC_T(VAR_1, pj_stun_msg);
pj_memcpy(&VAR_8->hdr, VAR_2, sizeof(VAR_15));
VAR_8->hdr.type = pj_ntohs(VAR_8->hdr.type);
VAR_8->hdr.length = pj_ntohs(VAR_8->hdr.length);
VAR_8->hdr.magic = pj_ntohl(VAR_8->hdr.magic);
VAR_2 += sizeof(VAR_15);
VAR_3 = VAR_8->hdr.length;
if (!PJ_STUN_IS_REQUEST(VAR_8->hdr.type))
VAR_7 = NULL;
while (VAR_3 >= 4) {
unsigned VAR_19, VAR_20;
const struct attr_desc *VAR_21;
VAR_19 = GETVAL16H(VAR_2, 0);
VAR_20 = GETVAL16H(VAR_2, 2);
VAR_20 = (VAR_20 + 3) & (~3);
if (VAR_3 < VAR_20) {
pj_str_t VAR_22;
char VAR_23[80];
VAR_22.ptr = VAR_23;
VAR_22.slen = pj_ansi_snprintf(VAR_23, sizeof(VAR_23),
""Attribute %s has invalid length"",
pj_stun_get_attr_name(VAR_19));
PJ_LOG(4,(VAR_24, ""Error decoding message: %.*s"",
(int)VAR_22.slen, VAR_22.ptr));
if (VAR_7) {
pj_stun_msg_create_response(VAR_1, VAR_8, 
VAR_25, 
&VAR_22, VAR_7);
}
return VAR_26;
}
VAR_21 = find_attr_desc(VAR_19);
if (VAR_21 == NULL) {
pj_stun_binary_attr *VAR_27 = NULL;
PJ_LOG(5,(VAR_24, ""Unrecognized attribute type 0x%x"", 
VAR_19));
if (VAR_19 <= 0x7FFF) {
if (VAR_7) {
unsigned VAR_28 = VAR_29;
VAR_13 = pj_stun_msg_create_response(VAR_1, VAR_8,
VAR_28, NULL, 
VAR_7);
if (VAR_13==VAR_18) {
pj_uint16_t VAR_30 = (pj_uint16_t)VAR_19;
pj_stun_msg_add_unknown_attr(VAR_1, *VAR_7, 1, &VAR_30);
}
}
return PJ_STATUS_FROM_STUN_CODE(VAR_29);
}
if (VAR_8->attr_count >= VAR_31) {
if (VAR_7) {
pj_stun_msg_create_response(VAR_1, VAR_8,
VAR_32,
NULL, VAR_7);
}
return VAR_33;
}
VAR_13 = pj_stun_binary_attr_create(VAR_1, VAR_19, VAR_2+4, 
GETVAL16H(VAR_2, 2), &VAR_27);
if (VAR_13 != VAR_18) {
if (VAR_7) {
pj_stun_msg_create_response(VAR_1, VAR_8,
VAR_32,
NULL, VAR_7);
}
PJ_LOG(4,(VAR_24, 
""Error parsing unknown STUN attribute type %d"",
VAR_19));
return VAR_13;
}
VAR_8->attr[VAR_8->attr_count++] = &VAR_27->hdr;
} else {
void *VAR_27;
char VAR_34[VAR_35],
VAR_36[VAR_35];
VAR_13 = (VAR_21->decode_attr)(VAR_1, VAR_2, &VAR_8->hdr, &VAR_27);
if (VAR_13 != VAR_18) {
pj_strerror(VAR_13, VAR_34, sizeof(VAR_34));
if (VAR_7) {
pj_str_t VAR_37;
VAR_37.ptr = VAR_36;
VAR_37.slen= pj_ansi_snprintf(VAR_36, sizeof(VAR_36),
""%s in %s"",
VAR_34,
pj_stun_get_attr_name(VAR_19));
if (VAR_37.slen < 1 || VAR_37.slen >= (int)sizeof(VAR_36))
VAR_37.slen = sizeof(VAR_36) - 1;
pj_stun_msg_create_response(VAR_1, VAR_8,
VAR_25,
&VAR_37, VAR_7);
}
PJ_LOG(4,(VAR_24, 
""Error parsing STUN attribute %s: %s"",
pj_stun_get_attr_name(VAR_19), 
VAR_34));
return VAR_13;
}
if (VAR_19 == VAR_38 && 
!VAR_12) 
{
if (VAR_10) {
if (VAR_7) {
pj_stun_msg_create_response(VAR_1, VAR_8,
VAR_25,
NULL, VAR_7);
}
return VAR_39;
}
VAR_10 = VAR_40;
} else if (VAR_19 == VAR_41) {
if (VAR_12) {
if (VAR_7) {
pj_stun_msg_create_response(VAR_1, VAR_8,
VAR_25,
NULL, VAR_7);
}
return VAR_39;
}
VAR_12 = VAR_40;
} else {
if (VAR_12) {
if (VAR_7) {
pj_stun_msg_create_response(VAR_1, VAR_8,
VAR_25,
NULL, VAR_7);
}
return VAR_42;
}
}
if (VAR_8->attr_count >= VAR_31) {
if (VAR_7) {
pj_stun_msg_create_response(VAR_1, VAR_8,
VAR_32,
NULL, VAR_7);
}
return VAR_33;
}
VAR_8->attr[VAR_8->attr_count++] = (pj_stun_attr_hdr*)VAR_27;
}
if (VAR_20 + 4 >= VAR_3) {
VAR_2 += VAR_3;
VAR_3 = 0;
} else {
VAR_2 += (VAR_20 + 4);
VAR_3 -= (VAR_20 + 4);
}
}
if (VAR_3 > 0) {
PJ_LOG(4,(VAR_24, 
""Error decoding STUN message: unparsed trailing %d bytes"",
VAR_3));
return VAR_43;
}
*VAR_5 = VAR_8;
if (VAR_6)
*VAR_6 = (VAR_2 - VAR_9);
return VAR_18;
}",,"PJ_DEF(pj_status_t) pj_stun_msg_decode(pj_pool_t *pool,
                                       const pj_uint8_t *pdu,
                                       pj_size_t pdu_len,
                                       unsigned options,
                                       pj_stun_msg **p_msg,
                                       pj_size_t *p_parsed_len,
                                       pj_stun_msg **p_response)
{
    
    pj_stun_msg *msg;
    const pj_uint8_t *start_pdu = pdu;
    pj_bool_t has_msg_int = PJ_FALSE;
    pj_bool_t has_fingerprint = PJ_FALSE;
    pj_status_t status;

    PJ_UNUSED_ARG(options);

    PJ_ASSERT_RETURN(pool && pdu && pdu_len && p_msg, PJ_EINVAL);
    PJ_ASSERT_RETURN(sizeof(pj_stun_msg_hdr) == 20, PJ_EBUG);

    if (p_parsed_len)
        *p_parsed_len = 0;
    if (p_response)
        *p_response = NULL;

    /* Check if this is a STUN message, if necessary */
    if (options & PJ_STUN_CHECK_PACKET) {
        status = pj_stun_msg_check(pdu, pdu_len, options);
        if (status != PJ_SUCCESS)
            return status;
    } else {
        /* For safety, verify packet length at least */
        pj_uint32_t msg_len = GETVAL16H(pdu, 2) + 20;
        if (msg_len > pdu_len ||
            ((options & PJ_STUN_IS_DATAGRAM) && msg_len != pdu_len))
        {
            return PJNATH_EINSTUNMSGLEN;
        }
    }

    /* Create the message, copy the header, and convert to host byte order */
    msg = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);
    pj_memcpy(&msg->hdr, pdu, sizeof(pj_stun_msg_hdr));
    msg->hdr.type = pj_ntohs(msg->hdr.type);
    msg->hdr.length = pj_ntohs(msg->hdr.length);
    msg->hdr.magic = pj_ntohl(msg->hdr.magic);

    pdu += sizeof(pj_stun_msg_hdr);
    /* pdu_len -= sizeof(pj_stun_msg_hdr); */
    pdu_len = msg->hdr.length;

    /* No need to create response if this is not a request */
    if (!PJ_STUN_IS_REQUEST(msg->hdr.type))
        p_response = NULL;

    /* Parse attributes */
    while (pdu_len >= ATTR_HDR_LEN) {
        unsigned attr_type, attr_val_len;
        const struct attr_desc *adesc;

        /* Get attribute type and length. If length is not aligned
         * to 4 bytes boundary, add padding.
         */
        attr_type = GETVAL16H(pdu, 0);
        attr_val_len = GETVAL16H(pdu, 2);
        attr_val_len = (attr_val_len + 3) & (~3);

        /* Check length */
        if (pdu_len < attr_val_len + ATTR_HDR_LEN) {
            pj_str_t err_msg;
            char err_msg_buf[80];

            err_msg.ptr = err_msg_buf;
            err_msg.slen = pj_ansi_snprintf(err_msg_buf, sizeof(err_msg_buf),
                                            ""Attribute %s has invalid length"",
                                            pj_stun_get_attr_name(attr_type));

            PJ_LOG(4,(THIS_FILE, ""Error decoding message: %.*s"",
                      (int)err_msg.slen, err_msg.ptr));

            if (p_response) {
                pj_stun_msg_create_response(pool, msg, 
                                            PJ_STUN_SC_BAD_REQUEST, 
                                            &err_msg, p_response);
            }
            return PJNATH_ESTUNINATTRLEN;
        }

        /* Get the attribute descriptor */
        adesc = find_attr_desc(attr_type);

        if (adesc == NULL) {
            /* Unrecognized attribute */
            pj_stun_binary_attr *attr = NULL;

            PJ_LOG(5,(THIS_FILE, ""Unrecognized attribute type 0x%x"", 
                      attr_type));

            /* Is this a fatal condition? */
            if (attr_type <= 0x7FFF) {
                /* This is a mandatory attribute, we must return error
                 * if we don't understand the attribute.
                 */
                if (p_response) {
                    unsigned err_code = PJ_STUN_SC_UNKNOWN_ATTRIBUTE;

                    status = pj_stun_msg_create_response(pool, msg,
                                                         err_code, NULL, 
                                                         p_response);
                    if (status==PJ_SUCCESS) {
                        pj_uint16_t d = (pj_uint16_t)attr_type;
                        pj_stun_msg_add_unknown_attr(pool, *p_response, 1, &d);
                    }
                }

                return PJ_STATUS_FROM_STUN_CODE(PJ_STUN_SC_UNKNOWN_ATTRIBUTE);
            }

            /* Make sure we have rooms for the new attribute */
            if (msg->attr_count >= PJ_STUN_MAX_ATTR) {
                if (p_response) {
                    pj_stun_msg_create_response(pool, msg,
                                                PJ_STUN_SC_SERVER_ERROR,
                                                NULL, p_response);
                }
                return PJNATH_ESTUNTOOMANYATTR;
            }

            /* Create binary attribute to represent this */
            status = pj_stun_binary_attr_create(pool, attr_type, pdu+4, 
                                                GETVAL16H(pdu, 2), &attr);
            if (status != PJ_SUCCESS) {
                if (p_response) {
                    pj_stun_msg_create_response(pool, msg,
                                                PJ_STUN_SC_SERVER_ERROR,
                                                NULL, p_response);
                }

                PJ_LOG(4,(THIS_FILE, 
                          ""Error parsing unknown STUN attribute type %d"",
                          attr_type));

                return status;
            }

            /* Add the attribute */
            msg->attr[msg->attr_count++] = &attr->hdr;

        } else {
            void *attr;
            char err_msg1[PJ_ERR_MSG_SIZE],
                 err_msg2[PJ_ERR_MSG_SIZE];

            /* Parse the attribute */
            status = (adesc->decode_attr)(pool, pdu, &msg->hdr, &attr);

            if (status != PJ_SUCCESS) {
                pj_strerror(status, err_msg1, sizeof(err_msg1));

                if (p_response) {
                    pj_str_t e;

                    e.ptr = err_msg2;
                    e.slen= pj_ansi_snprintf(err_msg2, sizeof(err_msg2),
                                             ""%s in %s"",
                                             err_msg1,
                                             pj_stun_get_attr_name(attr_type));
                    if (e.slen < 1 || e.slen >= (int)sizeof(err_msg2))
                        e.slen = sizeof(err_msg2) - 1;
                    pj_stun_msg_create_response(pool, msg,
                                                PJ_STUN_SC_BAD_REQUEST,
                                                &e, p_response);
                }

                PJ_LOG(4,(THIS_FILE, 
                          ""Error parsing STUN attribute %s: %s"",
                          pj_stun_get_attr_name(attr_type), 
                          err_msg1));

                return status;
            }

            if (attr_type == PJ_STUN_ATTR_MESSAGE_INTEGRITY && 
                !has_fingerprint) 
            {
                if (has_msg_int) {
                    /* Already has MESSAGE-INTEGRITY */
                    if (p_response) {
                        pj_stun_msg_create_response(pool, msg,
                                                    PJ_STUN_SC_BAD_REQUEST,
                                                    NULL, p_response);
                    }
                    return PJNATH_ESTUNDUPATTR;
                }
                has_msg_int = PJ_TRUE;

            } else if (attr_type == PJ_STUN_ATTR_FINGERPRINT) {
                if (has_fingerprint) {
                    /* Already has FINGERPRINT */
                    if (p_response) {
                        pj_stun_msg_create_response(pool, msg,
                                                    PJ_STUN_SC_BAD_REQUEST,
                                                    NULL, p_response);
                    }
                    return PJNATH_ESTUNDUPATTR;
                }
                has_fingerprint = PJ_TRUE;
            } else {
                if (has_fingerprint) {
                    /* Another attribute is found which is not FINGERPRINT
                     * after FINGERPRINT. Note that non-FINGERPRINT is
                     * allowed to appear after M-I
                     */
                    if (p_response) {
                        pj_stun_msg_create_response(pool, msg,
                                                    PJ_STUN_SC_BAD_REQUEST,
                                                    NULL, p_response);
                    }
                    return PJNATH_ESTUNFINGERPOS;
                }
            }

            /* Make sure we have rooms for the new attribute */
            if (msg->attr_count >= PJ_STUN_MAX_ATTR) {
                if (p_response) {
                    pj_stun_msg_create_response(pool, msg,
                                                PJ_STUN_SC_SERVER_ERROR,
                                                NULL, p_response);
                }
                return PJNATH_ESTUNTOOMANYATTR;
            }

            /* Add the attribute */
            msg->attr[msg->attr_count++] = (pj_stun_attr_hdr*)attr;
        }

        /* Next attribute */
        if (attr_val_len + 4 >= pdu_len) {
            pdu += pdu_len;
            pdu_len = 0;
        } else {
            pdu += (attr_val_len + 4);
            pdu_len -= (attr_val_len + 4);
        }
    }

    if (pdu_len > 0) {
        /* Stray trailing bytes */
        PJ_LOG(4,(THIS_FILE, 
                  ""Error decoding STUN message: unparsed trailing %d bytes"",
                  pdu_len));
        return PJNATH_EINSTUNMSGLEN;
    }

    *p_msg = msg;

    if (p_parsed_len)
        *p_parsed_len = (pdu - start_pdu);

    return PJ_SUCCESS;
}","VAR_0(pj_status_t) pj_stun_msg_decode(pj_pool_t *VAR_1,
                                       const pj_uint8_t *VAR_2,
                                       pj_size_t VAR_3,
                                       unsigned VAR_4,
                                       pj_stun_msg **VAR_5,
                                       pj_size_t *VAR_6,
                                       pj_stun_msg **VAR_7)
{
    
    pj_stun_msg *VAR_8;
    const pj_uint8_t *VAR_9 = VAR_2;
    pj_bool_t VAR_10 = VAR_11;
    pj_bool_t VAR_12 = VAR_11;
    pj_status_t VAR_13;

    PJ_UNUSED_ARG(VAR_4);

    PJ_ASSERT_RETURN(VAR_1 && VAR_2 && VAR_3 && VAR_5, VAR_14);
    PJ_ASSERT_RETURN(sizeof(VAR_15) == 20, VAR_16);

    if (VAR_6)
        *VAR_6 = 0;
    if (VAR_7)
        *VAR_7 = NULL;

    /* COMMENT_0 */
    if (VAR_4 & VAR_17) {
        VAR_13 = pj_stun_msg_check(VAR_2, VAR_3, VAR_4);
        if (VAR_13 != VAR_18)
            return VAR_13;
    } else {
        /* COMMENT_1 */
        pj_uint32_t VAR_19 = GETVAL16H(VAR_2, 2) + 20;
        if (VAR_19 > VAR_3 ||
            ((VAR_4 & VAR_20) && VAR_19 != VAR_3))
        {
            return VAR_21;
        }
    }

    /* COMMENT_2 */
    VAR_8 = PJ_POOL_ZALLOC_T(VAR_1, pj_stun_msg);
    pj_memcpy(&VAR_8->hdr, VAR_2, sizeof(VAR_15));
    VAR_8->hdr.type = pj_ntohs(VAR_8->hdr.type);
    VAR_8->hdr.length = pj_ntohs(VAR_8->hdr.length);
    VAR_8->hdr.magic = pj_ntohl(VAR_8->hdr.magic);

    VAR_2 += sizeof(VAR_15);
    /* COMMENT_3 */
    VAR_3 = VAR_8->hdr.length;

    /* COMMENT_4 */
    if (!PJ_STUN_IS_REQUEST(VAR_8->hdr.type))
        VAR_7 = NULL;

    /* COMMENT_5 */
    while (VAR_3 >= VAR_22) {
        unsigned VAR_23, VAR_24;
        const struct attr_desc *VAR_25;

        /* COMMENT_6 */
                                            
           
        VAR_23 = GETVAL16H(VAR_2, 0);
        VAR_24 = GETVAL16H(VAR_2, 2);
        VAR_24 = (VAR_24 + 3) & (~3);

        /* COMMENT_9 */
        if (VAR_3 < VAR_24 + VAR_22) {
            pj_str_t VAR_26;
            char VAR_27[80];

            VAR_26.ptr = VAR_27;
            VAR_26.slen = pj_ansi_snprintf(VAR_27, sizeof(VAR_27),
                                            ""Attribute %s has invalid length"",
                                            pj_stun_get_attr_name(VAR_23));

            PJ_LOG(4,(VAR_28, ""Error decoding message: %.*s"",
                      (int)VAR_26.slen, VAR_26.ptr));

            if (VAR_7) {
                pj_stun_msg_create_response(VAR_1, VAR_8, 
                                            VAR_29, 
                                            &VAR_26, VAR_7);
            }
            return VAR_30;
        }

        /* COMMENT_10 */
        VAR_25 = find_attr_desc(VAR_23);

        if (VAR_25 == NULL) {
            /* COMMENT_11 */
            pj_stun_binary_attr *VAR_31 = NULL;

            PJ_LOG(5,(VAR_28, ""Unrecognized attribute type 0x%x"", 
                      VAR_23));

            /* COMMENT_12 */
            if (VAR_23 <= 0x7FFF) {
                /* COMMENT_13 */
                                                        
                   
                if (VAR_7) {
                    unsigned VAR_32 = VAR_33;

                    VAR_13 = pj_stun_msg_create_response(VAR_1, VAR_8,
                                                         VAR_32, NULL, 
                                                         VAR_7);
                    if (VAR_13==VAR_18) {
                        pj_uint16_t VAR_34 = (pj_uint16_t)VAR_23;
                        pj_stun_msg_add_unknown_attr(VAR_1, *VAR_7, 1, &VAR_34);
                    }
                }

                return PJ_STATUS_FROM_STUN_CODE(VAR_33);
            }

            /* COMMENT_16 */
            if (VAR_8->attr_count >= VAR_35) {
                if (VAR_7) {
                    pj_stun_msg_create_response(VAR_1, VAR_8,
                                                VAR_36,
                                                NULL, VAR_7);
                }
                return VAR_37;
            }

            /* COMMENT_17 */
            VAR_13 = pj_stun_binary_attr_create(VAR_1, VAR_23, VAR_2+4, 
                                                GETVAL16H(VAR_2, 2), &VAR_31);
            if (VAR_13 != VAR_18) {
                if (VAR_7) {
                    pj_stun_msg_create_response(VAR_1, VAR_8,
                                                VAR_36,
                                                NULL, VAR_7);
                }

                PJ_LOG(4,(VAR_28, 
                          ""Error parsing unknown STUN attribute type %d"",
                          VAR_23));

                return VAR_13;
            }

            /* COMMENT_18 */
            VAR_8->attr[VAR_8->attr_count++] = &VAR_31->hdr;

        } else {
            void *VAR_31;
            char VAR_38[VAR_39],
                 VAR_40[VAR_39];

            /* COMMENT_19 */
            VAR_13 = (VAR_25->decode_attr)(VAR_1, VAR_2, &VAR_8->hdr, &VAR_31);

            if (VAR_13 != VAR_18) {
                pj_strerror(VAR_13, VAR_38, sizeof(VAR_38));

                if (VAR_7) {
                    pj_str_t VAR_41;

                    VAR_41.ptr = VAR_40;
                    VAR_41.slen= pj_ansi_snprintf(VAR_40, sizeof(VAR_40),
                                             ""%s in %s"",
                                             VAR_38,
                                             pj_stun_get_attr_name(VAR_23));
                    if (VAR_41.slen < 1 || VAR_41.slen >= (int)sizeof(VAR_40))
                        VAR_41.slen = sizeof(VAR_40) - 1;
                    pj_stun_msg_create_response(VAR_1, VAR_8,
                                                VAR_29,
                                                &VAR_41, VAR_7);
                }

                PJ_LOG(4,(VAR_28, 
                          ""Error parsing STUN attribute %s: %s"",
                          pj_stun_get_attr_name(VAR_23), 
                          VAR_38));

                return VAR_13;
            }

            if (VAR_23 == VAR_42 && 
                !VAR_12) 
            {
                if (VAR_10) {
                    /* COMMENT_20 */
                    if (VAR_7) {
                        pj_stun_msg_create_response(VAR_1, VAR_8,
                                                    VAR_29,
                                                    NULL, VAR_7);
                    }
                    return VAR_43;
                }
                VAR_10 = VAR_44;

            } else if (VAR_23 == VAR_45) {
                if (VAR_12) {
                    /* COMMENT_21 */
                    if (VAR_7) {
                        pj_stun_msg_create_response(VAR_1, VAR_8,
                                                    VAR_29,
                                                    NULL, VAR_7);
                    }
                    return VAR_43;
                }
                VAR_12 = VAR_44;
            } else {
                if (VAR_12) {
                    /* COMMENT_22 */
                                                                      
                                                  
                       
                    if (VAR_7) {
                        pj_stun_msg_create_response(VAR_1, VAR_8,
                                                    VAR_29,
                                                    NULL, VAR_7);
                    }
                    return VAR_46;
                }
            }

            /* COMMENT_16 */
            if (VAR_8->attr_count >= VAR_35) {
                if (VAR_7) {
                    pj_stun_msg_create_response(VAR_1, VAR_8,
                                                VAR_36,
                                                NULL, VAR_7);
                }
                return VAR_37;
            }

            /* COMMENT_18 */
            VAR_8->attr[VAR_8->attr_count++] = (pj_stun_attr_hdr*)VAR_31;
        }

        /* COMMENT_26 */
        if (VAR_24 + 4 >= VAR_3) {
            VAR_2 += VAR_3;
            VAR_3 = 0;
        } else {
            VAR_2 += (VAR_24 + 4);
            VAR_3 -= (VAR_24 + 4);
        }
    }

    if (VAR_3 > 0) {
        /* COMMENT_27 */
        PJ_LOG(4,(VAR_28, 
                  ""Error decoding STUN message: unparsed trailing %d bytes"",
                  VAR_3));
        return VAR_21;
    }

    *VAR_5 = VAR_8;

    if (VAR_6)
        *VAR_6 = (VAR_2 - VAR_9);

    return VAR_18;
}",,"--- func_before
+++ func_after
@@ -28,6 +28,14 @@
         status = pj_stun_msg_check(pdu, pdu_len, options);
         if (status != PJ_SUCCESS)
             return status;
+    } else {
+        /* For safety, verify packet length at least */
+        pj_uint32_t msg_len = GETVAL16H(pdu, 2) + 20;
+        if (msg_len > pdu_len ||
+            ((options & PJ_STUN_IS_DATAGRAM) && msg_len != pdu_len))
+        {
+            return PJNATH_EINSTUNMSGLEN;
+        }
     }
 
     /* Create the message, copy the header, and convert to host byte order */
@@ -46,7 +54,7 @@
         p_response = NULL;
 
     /* Parse attributes */
-    while (pdu_len >= 4) {
+    while (pdu_len >= ATTR_HDR_LEN) {
         unsigned attr_type, attr_val_len;
         const struct attr_desc *adesc;
 
@@ -58,7 +66,7 @@
         attr_val_len = (attr_val_len + 3) & (~3);
 
         /* Check length */
-        if (pdu_len < attr_val_len) {
+        if (pdu_len < attr_val_len + ATTR_HDR_LEN) {
             pj_str_t err_msg;
             char err_msg_buf[80];
 ","{'deleted_lines': ['    while (pdu_len >= 4) {', '        if (pdu_len < attr_val_len) {'], 'added_lines': ['    } else {', '        /* For safety, verify packet length at least */', '        pj_uint32_t msg_len = GETVAL16H(pdu, 2) + 20;', '        if (msg_len > pdu_len ||', '            ((options & PJ_STUN_IS_DATAGRAM) && msg_len != pdu_len))', '        {', '            return PJNATH_EINSTUNMSGLEN;', '        }', '    while (pdu_len >= ATTR_HDR_LEN) {', '        if (pdu_len < attr_val_len + ATTR_HDR_LEN) {']}",True,"PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. Buffer overread is possible when parsing a specially crafted STUN message with unknown attribute. The vulnerability affects applications that uses STUN including PJNATH and PJSUA-LIB. The patch is available as a commit in the master branch (2.13.1).",6.5,MEDIUM,1,test,2022-12-20T04:39:12Z,4
CVE-2023-23144,['CWE-190'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,gpac,fixed #2364,3a2458a49b3e6399709d456d7b35e7a6f50cfb86,https://github.com/gpac/gpac/commit/3a2458a49b3e6399709d456d7b35e7a6f50cfb86,src/bifs/unquantize.c,Q_DecCoordOnUnitSphere,"GF_Err Q_DecCoordOnUnitSphere(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, u32 NbComp, Fixed *m_ft)
{
u32 i, orient, sign;
s32 value;
Fixed tang[4], delta;
s32 dir;
if (NbComp != 2 && NbComp != 3) return GF_BAD_PARAM;
dir = 1;
if(NbComp == 2) dir -= 2 * gf_bs_read_int(bs, 1);
orient = gf_bs_read_int(bs, 2);
if ((orient==3) && (NbComp==2)) return GF_NON_COMPLIANT_BITSTREAM;
for(i=0; i<NbComp; i++) {
value = gf_bs_read_int(bs, NbBits) - (1 << (NbBits-1) );
sign = (value >= 0) ? 1 : -1;
m_ft[i] = sign * Q_InverseQuantize(0, 1, NbBits-1, sign*value);
}
delta = 1;
for (i=0; i<NbComp; i++) {
tang[i] = gf_tan(gf_mulfix(GF_PI/4, m_ft[i]) );
delta += gf_mulfix(tang[i], tang[i]);
}
delta = gf_divfix(INT2FIX(dir), gf_sqrt(delta) );
m_ft[orient] = delta;
for (i=0; i<NbComp; i++) {
m_ft[ (orient + i+1) % (NbComp+1) ] = gf_mulfix(tang[i], delta);
}
return GF_OK;
}","GF_Err Q_DecCoordOnUnitSphere(GF_BifsDecoder *VAR_0, GF_BitStream *VAR_1, u32 VAR_2, u32 VAR_3, Fixed *VAR_4)
{
u32 VAR_5, VAR_6, VAR_7;
s32 VAR_8;
Fixed VAR_9[4], VAR_10;
s32 VAR_11;
if (VAR_3 != 2 && VAR_3 != 3) return VAR_12;
VAR_11 = 1;
if(VAR_3 == 2) VAR_11 -= 2 * gf_bs_read_int(VAR_1, 1);
VAR_6 = gf_bs_read_int(VAR_1, 2);
if ((VAR_6==3) && (VAR_3==2)) return VAR_13;
for(VAR_5=0; VAR_5<VAR_3; VAR_5++) {
VAR_8 = gf_bs_read_int(VAR_1, VAR_2) - (1 << (VAR_2-1) );
VAR_7 = (VAR_8 >= 0) ? 1 : -1;
VAR_4[VAR_5] = VAR_7 * Q_InverseQuantize(0, 1, VAR_2-1, VAR_7*VAR_8);
}
VAR_10 = 1;
for (VAR_5=0; VAR_5<VAR_3; VAR_5++) {
VAR_9[VAR_5] = gf_tan(gf_mulfix(VAR_14/4, VAR_4[VAR_5]) );
VAR_10 += gf_mulfix(VAR_9[VAR_5], VAR_9[VAR_5]);
}
VAR_10 = gf_divfix(INT2FIX(VAR_11), gf_sqrt(VAR_10) );
VAR_4[VAR_6] = VAR_10;
for (VAR_5=0; VAR_5<VAR_3; VAR_5++) {
VAR_4[ (VAR_6 + VAR_5+1) % (VAR_3+1) ] = gf_mulfix(VAR_9[VAR_5], VAR_10);
}
return VAR_15;
}",gpac/3a2458a49b3e6399709d456d7b35e7a6f50cfb86/unquantize.c/vul/before/0.json,"GF_Err Q_DecCoordOnUnitSphere(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, u32 NbComp, Fixed *m_ft)
{
	u32 i, orient, sign;
	s32 value;
	Fixed tang[4], delta;
	s32 dir;
	if (NbBits>32) return GF_NON_COMPLIANT_BITSTREAM;
	if (NbComp != 2 && NbComp != 3) return GF_BAD_PARAM;

	//only 2 or 3 comp in the quantized version
	dir = 1;
	if(NbComp == 2) dir -= 2 * gf_bs_read_int(bs, 1);

	orient = gf_bs_read_int(bs, 2);
	if ((orient==3) && (NbComp==2)) return GF_NON_COMPLIANT_BITSTREAM;

	for(i=0; i<NbComp; i++) {
		value = gf_bs_read_int(bs, NbBits) - (1 << (NbBits-1) );
		sign = (value >= 0) ? 1 : -1;
		m_ft[i] = sign * Q_InverseQuantize(0, 1, NbBits-1, sign*value);
	}
	delta = 1;
	for (i=0; i<NbComp; i++) {
		tang[i] = gf_tan(gf_mulfix(GF_PI/4, m_ft[i]) );
		delta += gf_mulfix(tang[i], tang[i]);
	}
	delta = gf_divfix(INT2FIX(dir), gf_sqrt(delta) );
	m_ft[orient] = delta;

	for (i=0; i<NbComp; i++) {
		m_ft[ (orient + i+1) % (NbComp+1) ] = gf_mulfix(tang[i], delta);
	}
	return GF_OK;
}","GF_Err Q_DecCoordOnUnitSphere(GF_BifsDecoder *VAR_0, GF_BitStream *VAR_1, u32 VAR_2, u32 VAR_3, Fixed *VAR_4)
{
	u32 VAR_5, VAR_6, VAR_7;
	s32 VAR_8;
	Fixed VAR_9[4], VAR_10;
	s32 VAR_11;
	if (VAR_2>32) return VAR_12;
	if (VAR_3 != 2 && VAR_3 != 3) return VAR_13;

	/* COMMENT_0 */
	VAR_11 = 1;
	if(VAR_3 == 2) VAR_11 -= 2 * gf_bs_read_int(VAR_1, 1);

	VAR_6 = gf_bs_read_int(VAR_1, 2);
	if ((VAR_6==3) && (VAR_3==2)) return VAR_12;

	for(VAR_5=0; VAR_5<VAR_3; VAR_5++) {
		VAR_8 = gf_bs_read_int(VAR_1, VAR_2) - (1 << (VAR_2-1) );
		VAR_7 = (VAR_8 >= 0) ? 1 : -1;
		VAR_4[VAR_5] = VAR_7 * Q_InverseQuantize(0, 1, VAR_2-1, VAR_7*VAR_8);
	}
	VAR_10 = 1;
	for (VAR_5=0; VAR_5<VAR_3; VAR_5++) {
		VAR_9[VAR_5] = gf_tan(gf_mulfix(VAR_14/4, VAR_4[VAR_5]) );
		VAR_10 += gf_mulfix(VAR_9[VAR_5], VAR_9[VAR_5]);
	}
	VAR_10 = gf_divfix(INT2FIX(VAR_11), gf_sqrt(VAR_10) );
	VAR_4[VAR_6] = VAR_10;

	for (VAR_5=0; VAR_5<VAR_3; VAR_5++) {
		VAR_4[ (VAR_6 + VAR_5+1) % (VAR_3+1) ] = gf_mulfix(VAR_9[VAR_5], VAR_10);
	}
	return VAR_15;
}",gpac/3a2458a49b3e6399709d456d7b35e7a6f50cfb86/unquantize.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
 	s32 value;
 	Fixed tang[4], delta;
 	s32 dir;
-
+	if (NbBits>32) return GF_NON_COMPLIANT_BITSTREAM;
 	if (NbComp != 2 && NbComp != 3) return GF_BAD_PARAM;
 
 	//only 2 or 3 comp in the quantized version","{'deleted_lines': [''], 'added_lines': ['\tif (NbBits>32) return GF_NON_COMPLIANT_BITSTREAM;']}",True,Integer overflow vulnerability in function Q_DecCoordOnUnitSphere file bifs/unquantize.c in GPAC version 2.2-rev0-gab012bbfb-master.,5.5,MEDIUM,1,test,2023-01-04T10:25:11Z,4
CVE-2023-0051,['CWE-122'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,vim,"patch 9.0.1144: reading beyond text

Problem:    Reading beyond text.
Solution:   Add strlen_maxlen() and use it.",c32949b0779106ed5710ae3bffc5053e49083ab4,https://github.com/vim/vim/commit/c32949b0779106ed5710ae3bffc5053e49083ab4,src/strings.c,vim_strchr,"char_u  *
vim_strchr(char_u *string, int c)
{
char_u*p;
intb;
p = string;
if (enc_utf8 && c >= 0x80)
{
while (*p != NUL)
{
int l = utfc_ptr2len(p);
if (utf_ptr2char(p) == c && l > 1)
return p;
p += l;
}
return NULL;
}
if (enc_dbcs != 0 && c > 255)
{
intn2 = c & 0xff;
c = ((unsigned)c >> 8) & 0xff;
while ((b = *p) != NUL)
{
if (b == c && p[1] == n2)
return p;
p += (*mb_ptr2len)(p);
}
return NULL;
}
if (has_mbyte)
{
while ((b = *p) != NUL)
{
if (b == c)
return p;
p += (*mb_ptr2len)(p);
}
return NULL;
}
while ((b = *p) != NUL)
{
if (b == c)
return p;
++p;
}
return NULL;
}","char_u  *
vim_strchr(char_u *VAR_0, int VAR_1)
{
char_u*VAR_2;
intVAR_3;
VAR_2 = VAR_0;
if (VAR_4 && VAR_1 >= 0x80)
{
while (*VAR_2 != VAR_5)
{
int VAR_6 = utfc_ptr2len(VAR_2);
if (utf_ptr2char(VAR_2) == VAR_1 && VAR_6 > 1)
return VAR_2;
VAR_2 += VAR_6;
}
return NULL;
}
if (VAR_7 != 0 && VAR_1 > 255)
{
intVAR_8 = VAR_1 & 0xff;
VAR_1 = ((unsigned)VAR_1 >> 8) & 0xff;
while ((VAR_3 = *VAR_2) != VAR_5)
{
if (VAR_3 == VAR_1 && VAR_2[1] == VAR_8)
return VAR_2;
VAR_2 += (*VAR_9)(VAR_2);
}
return NULL;
}
if (VAR_10)
{
while ((VAR_3 = *VAR_2) != VAR_5)
{
if (VAR_3 == VAR_1)
return VAR_2;
VAR_2 += (*VAR_9)(VAR_2);
}
return NULL;
}
while ((VAR_3 = *VAR_2) != VAR_5)
{
if (VAR_3 == VAR_1)
return VAR_2;
++VAR_2;
}
return NULL;
}",vim/c32949b0779106ed5710ae3bffc5053e49083ab4/strings.c/vul/before/0.json,"char_u *
vim_strchr(char_u *string, int c)
{
    char_u	*p;
    int		b;

    p = string;
    if (enc_utf8 && c >= 0x80)
    {
	while (*p != NUL)
	{
	    int l = utfc_ptr2len(p);

	    // Avoid matching an illegal byte here.
	    if (utf_ptr2char(p) == c && l > 1)
		return p;
	    p += l;
	}
	return NULL;
    }
    if (enc_dbcs != 0 && c > 255)
    {
	int	n2 = c & 0xff;

	c = ((unsigned)c >> 8) & 0xff;
	while ((b = *p) != NUL)
	{
	    if (b == c && p[1] == n2)
		return p;
	    p += (*mb_ptr2len)(p);
	}
	return NULL;
    }
    if (has_mbyte)
    {
	while ((b = *p) != NUL)
	{
	    if (b == c)
		return p;
	    p += (*mb_ptr2len)(p);
	}
	return NULL;
    }
    while ((b = *p) != NUL)
    {
	if (b == c)
	    return p;
	++p;
    }
    return NULL;
}","char_u *
vim_strchr(char_u *VAR_0, int VAR_1)
{
    char_u	*VAR_2;
    int		VAR_3;

    VAR_2 = VAR_0;
    if (VAR_4 && VAR_1 >= 0x80)
    {
	while (*VAR_2 != VAR_5)
	{
	    int VAR_6 = utfc_ptr2len(VAR_2);

	    /* COMMENT_0 */
	    if (utf_ptr2char(VAR_2) == VAR_1 && VAR_6 > 1)
		return VAR_2;
	    VAR_2 += VAR_6;
	}
	return NULL;
    }
    if (VAR_7 != 0 && VAR_1 > 255)
    {
	int	VAR_8 = VAR_1 & 0xff;

	VAR_1 = ((unsigned)VAR_1 >> 8) & 0xff;
	while ((VAR_3 = *VAR_2) != VAR_5)
	{
	    if (VAR_3 == VAR_1 && VAR_2[1] == VAR_8)
		return VAR_2;
	    VAR_2 += (*VAR_9)(VAR_2);
	}
	return NULL;
    }
    if (VAR_10)
    {
	while ((VAR_3 = *VAR_2) != VAR_5)
	{
	    if (VAR_3 == VAR_1)
		return VAR_2;
	    VAR_2 += (*VAR_9)(VAR_2);
	}
	return NULL;
    }
    while ((VAR_3 = *VAR_2) != VAR_5)
    {
	if (VAR_3 == VAR_1)
	    return VAR_2;
	++VAR_2;
    }
    return NULL;
}",vim/c32949b0779106ed5710ae3bffc5053e49083ab4/strings.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-char_u  *
+char_u *
 vim_strchr(char_u *string, int c)
 {
     char_u	*p;","{'deleted_lines': ['char_u  *'], 'added_lines': ['char_u *']}",True,Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1144.,7.8,HIGH,2,test,2023-01-04T15:56:51Z,4
CVE-2023-0051,['CWE-122'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,vim,"patch 9.0.1144: reading beyond text

Problem:    Reading beyond text.
Solution:   Add strlen_maxlen() and use it.",c32949b0779106ed5710ae3bffc5053e49083ab4,https://github.com/vim/vim/commit/c32949b0779106ed5710ae3bffc5053e49083ab4,src/message.c,msg_puts_printf,"static void
msg_puts_printf(char_u *str, int maxlen)
{
char_u*s = str;
char_u*buf = NULL;
char_u*p = s;
#ifdef MSWIN
if (!(silent_mode && p_verbose == 0))
mch_settmode(TMODE_COOK);#endif
while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL)
{
if (!(silent_mode && p_verbose == 0))
{
if (*s == NL)
{
int n = (int)(s - p);
buf = alloc(n + 3);
if (buf != NULL)
{
memcpy(buf, p, n);
if (!info_message)
buf[n++] = CAR;
buf[n++] = NL;
buf[n++] = NUL;
if (info_message)   mch_msg((char *)buf);
else
mch_errmsg((char *)buf);
vim_free(buf);
}
p = s + 1;
}
}
#ifdef FEAT_RIGHTLEFT
if (cmdmsg_rl)
{
if (*s == CAR || *s == NL)
msg_col = Columns - 1;
else
--msg_col;
}
else
#endif
{
if (*s == CAR || *s == NL)
msg_col = 0;
else
++msg_col;
}
++s;
}
if (*p != NUL && !(silent_mode && p_verbose == 0))
{
char_u *tofree = NULL;
if (maxlen > 0 && STRLEN(p) > (size_t)maxlen)
{
tofree = vim_strnsave(p, (size_t)maxlen);
p = tofree;
}
if (p != NULL)
{
if (info_message)
mch_msg((char *)p);
else
mch_errmsg((char *)p);
vim_free(tofree);
}
}
msg_didout = TRUE;    
#ifdef MSWIN
if (!(silent_mode && p_verbose == 0))
mch_settmode(TMODE_RAW);
#endif
}","static void
msg_puts_printf(char_u *VAR_0, int VAR_1)
{
char_u*VAR_2 = VAR_0;
char_u*VAR_3 = NULL;
char_u*VAR_4 = VAR_2;
#ifdef VAR_5
if (!(VAR_6 && VAR_7 == 0))
mch_settmode(VAR_8);
#endif
while ((VAR_1 < 0 || (int)(VAR_2 - VAR_0) < VAR_1) && *VAR_2 != VAR_9)
{
if (!(VAR_6 && VAR_7 == 0))
{
if (*VAR_2 == VAR_10)
{
int VAR_11 = (int)(VAR_2 - VAR_4);
VAR_3 = alloc(VAR_11 + 3);
if (VAR_3 != NULL)
{
memcpy(VAR_3, VAR_4, VAR_11);
if (!VAR_12)
VAR_3[VAR_11++] = VAR_13;
VAR_3[VAR_11++] = VAR_10;
VAR_3[VAR_11++] = VAR_9;
if (VAR_12)   
mch_msg((char *)VAR_3);
else
mch_errmsg((char *)VAR_3);
vim_free(VAR_3);
}
VAR_4 = VAR_2 + 1;
}
}
#ifdef VAR_14
if (VAR_15)
{
if (*VAR_2 == VAR_13 || *VAR_2 == VAR_10)
VAR_16 = VAR_17 - 1;
else
--VAR_16;
}
else
#endif
{
if (*VAR_2 == VAR_13 || *VAR_2 == VAR_10)
VAR_16 = 0;
else
++VAR_16;
}
++VAR_2;
}
if (*VAR_4 != VAR_9 && !(VAR_6 && VAR_7 == 0))
{
char_u *VAR_18 = NULL;
if (VAR_1 > 0 && STRLEN(VAR_4) > (size_t)VAR_1)
{
VAR_18 = vim_strnsave(VAR_4, (size_t)VAR_1);
VAR_4 = VAR_18;
}
if (VAR_4 != NULL)
{
if (VAR_12)
mch_msg((char *)VAR_4);
else
mch_errmsg((char *)VAR_4);
vim_free(VAR_18);
}
}
VAR_19 = TRUE;    
#ifdef VAR_5
if (!(VAR_6 && VAR_7 == 0))
mch_settmode(VAR_20);
#endif
}",vim/c32949b0779106ed5710ae3bffc5053e49083ab4/message.c/vul/before/0.json,"static void
msg_puts_printf(char_u *str, int maxlen)
{
    char_u	*s = str;
    char_u	*buf = NULL;
    char_u	*p = s;

#ifdef MSWIN
    if (!(silent_mode && p_verbose == 0))
	mch_settmode(TMODE_COOK);	// handle CR and NL correctly
#endif
    while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL)
    {
	if (!(silent_mode && p_verbose == 0))
	{
	    // NL --> CR NL translation (for Unix, not for ""--version"")
	    if (*s == NL)
	    {
		int n = (int)(s - p);

		buf = alloc(n + 3);
		if (buf != NULL)
		{
		    memcpy(buf, p, n);
		    if (!info_message)
			buf[n++] = CAR;
		    buf[n++] = NL;
		    buf[n++] = NUL;
		    if (info_message)   // informative message, not an error
			mch_msg((char *)buf);
		    else
			mch_errmsg((char *)buf);
		    vim_free(buf);
		}
		p = s + 1;
	    }
	}

	// primitive way to compute the current column
#ifdef FEAT_RIGHTLEFT
	if (cmdmsg_rl)
	{
	    if (*s == CAR || *s == NL)
		msg_col = Columns - 1;
	    else
		--msg_col;
	}
	else
#endif
	{
	    if (*s == CAR || *s == NL)
		msg_col = 0;
	    else
		++msg_col;
	}
	++s;
    }

    if (*p != NUL && !(silent_mode && p_verbose == 0))
    {
	char_u *tofree = NULL;

	if (maxlen > 0 && vim_strlen_maxlen((char *)p, (size_t)maxlen)
							     >= (size_t)maxlen)
	{
	    tofree = vim_strnsave(p, (size_t)maxlen);
	    p = tofree;
	}
	if (p != NULL)
	{
	    if (info_message)
		mch_msg((char *)p);
	    else
		mch_errmsg((char *)p);
	    vim_free(tofree);
	}
    }

    msg_didout = TRUE;	    // assume that line is not empty

#ifdef MSWIN
    if (!(silent_mode && p_verbose == 0))
	mch_settmode(TMODE_RAW);
#endif
}","static void
msg_puts_printf(char_u *VAR_0, int VAR_1)
{
    char_u	*VAR_2 = VAR_0;
    char_u	*VAR_3 = NULL;
    char_u	*VAR_4 = VAR_2;

#ifdef VAR_5
    if (!(VAR_6 && VAR_7 == 0))
	mch_settmode(VAR_8);	/* COMMENT_0 */
#endif
    while ((VAR_1 < 0 || (int)(VAR_2 - VAR_0) < VAR_1) && *VAR_2 != VAR_9)
    {
	if (!(VAR_6 && VAR_7 == 0))
	{
	    /* COMMENT_1 */
	    if (*VAR_2 == VAR_10)
	    {
		int VAR_11 = (int)(VAR_2 - VAR_4);

		VAR_3 = alloc(VAR_11 + 3);
		if (VAR_3 != NULL)
		{
		    memcpy(VAR_3, VAR_4, VAR_11);
		    if (!VAR_12)
			VAR_3[VAR_11++] = VAR_13;
		    VAR_3[VAR_11++] = VAR_10;
		    VAR_3[VAR_11++] = VAR_9;
		    if (VAR_12)   /* COMMENT_2 */
			mch_msg((char *)VAR_3);
		    else
			mch_errmsg((char *)VAR_3);
		    vim_free(VAR_3);
		}
		VAR_4 = VAR_2 + 1;
	    }
	}

	/* COMMENT_3 */
#ifdef VAR_14
	if (VAR_15)
	{
	    if (*VAR_2 == VAR_13 || *VAR_2 == VAR_10)
		VAR_16 = VAR_17 - 1;
	    else
		--VAR_16;
	}
	else
#endif
	{
	    if (*VAR_2 == VAR_13 || *VAR_2 == VAR_10)
		VAR_16 = 0;
	    else
		++VAR_16;
	}
	++VAR_2;
    }

    if (*VAR_4 != VAR_9 && !(VAR_6 && VAR_7 == 0))
    {
	char_u *VAR_18 = NULL;

	if (VAR_1 > 0 && vim_strlen_maxlen((char *)VAR_4, (size_t)VAR_1)
							     >= (size_t)VAR_1)
	{
	    VAR_18 = vim_strnsave(VAR_4, (size_t)VAR_1);
	    VAR_4 = VAR_18;
	}
	if (VAR_4 != NULL)
	{
	    if (VAR_12)
		mch_msg((char *)VAR_4);
	    else
		mch_errmsg((char *)VAR_4);
	    vim_free(VAR_18);
	}
    }

    VAR_19 = TRUE;	    /* COMMENT_4 */

#ifdef VAR_5
    if (!(VAR_6 && VAR_7 == 0))
	mch_settmode(VAR_20);
#endif
}",vim/c32949b0779106ed5710ae3bffc5053e49083ab4/message.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -60,7 +60,8 @@
     {
 	char_u *tofree = NULL;
 
-	if (maxlen > 0 && STRLEN(p) > (size_t)maxlen)
+	if (maxlen > 0 && vim_strlen_maxlen((char *)p, (size_t)maxlen)
+							     >= (size_t)maxlen)
 	{
 	    tofree = vim_strnsave(p, (size_t)maxlen);
 	    p = tofree;","{'deleted_lines': ['\tif (maxlen > 0 && STRLEN(p) > (size_t)maxlen)'], 'added_lines': ['\tif (maxlen > 0 && vim_strlen_maxlen((char *)p, (size_t)maxlen)', '\t\t\t\t\t\t\t     >= (size_t)maxlen)']}",True,Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1144.,7.8,HIGH,2,test,2023-01-04T15:56:51Z,4
CVE-2023-23557,['CWE-843'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,facebook/hermes,"Use copyDataProperties slow path for objects with accessors

Summary:
Fix a bug present in `hermesBuiltinCopyDataProperties`.
`hermesBuiltinCopyDataProperties` is meant to copy an object. It does
this by iterating over all the properties in the source object, and
then writing the key-value pair into a new object which is returned.The
iteration is done using `JSObject::forEachOwnPropertyWhile`, providing
a callback to process each property. It will take the property id, look
it up in the source object using `getNamedPropertyValue_RJS`, then take
that resulting value and write it into the target. However, that API
explicitly states the following:

> Obviously the callbacks shouldn't be  doing naughty things like modifying
the property map or creating new hidden classes (even implicitly)

But, `getNamedPropertyValue_RJS` can
perform arbitrary JS execution if it is a getter, including
adding/deleting new properties, which would modify the object's
HiddenClass, thus violating `JSObject::forEachOwnPropertyWhile`'s
precondition.Therefore, the fix is to use the correct, but slower path,
whenever there is an accessor on the object. This code path is more 1:1
to the spec. At the beginning, it will simply find all the properties
of the source object using `JSObject::getOwnPropertyKeys` and then
iterate on those, rather than use `JSObject::forEachOwnPropertyWhile`.
This way, we are allowed to manipulate the source object however we
wish, which is necessary in order to call `getNamedPropertyValue_RJS`.

Reviewed By: neildhar

Differential Revision: D41701871

fbshipit-source-id: c4be179f57d52827f12ca26b1ab8d17cdccd7447",a00d237346894c6067a594983be6634f4168c9ad,https://github.com/facebook/hermes/commit/a00d237346894c6067a594983be6634f4168c9ad,lib/VM/JSLib/HermesBuiltin.cpp,copyDataPropertiesSlowPath_RJS,"CallResult<HermesValue> copyDataPropertiesSlowPath_RJS(
Runtime &runtime,
Handle<JSObject> target,
Handle<JSObject> from,
Handle<JSObject> excludedItems) {
assert(
from->isProxyObject() &&
""copyDataPropertiesSlowPath_RJS is only for Proxy"");
auto cr = JSProxy::getOwnPropertyKeys(
from,
runtime,
OwnKeysFlags()
.plusIncludeSymbols()
.plusIncludeNonSymbols()
.plusIncludeNonEnumerable());
if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION)) {
return ExecutionStatus::EXCEPTION;
}
auto keys = *cr;
MutableHandle<> nextKeyHandle{runtime};
MutableHandle<> propValueHandle{runtime};
MutableHandle<SymbolID> tmpSymbolStorage{runtime};
GCScopeMarkerRAII marker{runtime};
for (uint32_t nextKeyIdx = 0, endIdx = keys->getEndIndex();
nextKeyIdx < endIdx;
++nextKeyIdx) {
marker.flush();
nextKeyHandle = keys->at(runtime, nextKeyIdx).unboxToHV(runtime);
if (nextKeyHandle->isNumber()) {
CallResult<PseudoHandle<StringPrimitive>> strRes =
toString_RJS(runtime, nextKeyHandle);
if (LLVM_UNLIKELY(strRes == ExecutionStatus::EXCEPTION)) {
return ExecutionStatus::EXCEPTION;
}
nextKeyHandle = strRes->getHermesValue();
}
if (excludedItems) {
assert(
!excludedItems->isProxyObject() &&
""internal excludedItems object is a proxy"");
ComputedPropertyDescriptor desc;
CallResult<bool> cr = JSObject::getOwnComputedPrimitiveDescriptor(
excludedItems,
runtime,
nextKeyHandle,
JSObject::IgnoreProxy::Yes,
tmpSymbolStorage,
desc);
if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))
return ExecutionStatus::EXCEPTION;
if (*cr)
continue;
}
ComputedPropertyDescriptor desc;
CallResult<bool> crb =
JSProxy::getOwnProperty(from, runtime, nextKeyHandle, desc, nullptr);
if (LLVM_UNLIKELY(crb == ExecutionStatus::EXCEPTION))
return ExecutionStatus::EXCEPTION;
if (*crb && desc.flags.enumerable) {
CallResult<PseudoHandle<>> crv =
JSProxy::getComputed(from, runtime, nextKeyHandle, from);
if (LLVM_UNLIKELY(crv == ExecutionStatus::EXCEPTION))
return ExecutionStatus::EXCEPTION;
propValueHandle = std::move(*crv);
crb = JSObject::defineOwnComputed(
target,
runtime,
nextKeyHandle,
DefinePropertyFlags::getDefaultNewPropertyFlags(),
propValueHandle);
if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))
return ExecutionStatus::EXCEPTION;
assert(
crb != ExecutionStatus::EXCEPTION && *crb &&
""CreateDataProperty failed"");
}
}
return target.getHermesValue();
}","CallResult<HermesValue> copyDataPropertiesSlowPath_RJS(
Runtime &VAR_0,
Handle<JSObject> VAR_1,
Handle<JSObject> VAR_2,
Handle<JSObject> VAR_3) {
assert(
VAR_2->isProxyObject() &&
""copyDataPropertiesSlowPath_RJS is only for Proxy"");
auto VAR_4 = JSProxy::getOwnPropertyKeys(
VAR_2,
VAR_0,
OwnKeysFlags()
.plusIncludeSymbols()
.plusIncludeNonSymbols()
.plusIncludeNonEnumerable());
if (LLVM_UNLIKELY(VAR_4 == ExecutionStatus::EXCEPTION)) {
return ExecutionStatus::EXCEPTION;
}
auto VAR_5 = *VAR_4;
MutableHandle<> VAR_6{VAR_0};
MutableHandle<> VAR_7{VAR_0};
MutableHandle<SymbolID> VAR_8{VAR_0};
GCScopeMarkerRAII VAR_9{VAR_0};
for (uint32_t VAR_10 = 0, VAR_11 = VAR_5->getEndIndex();
VAR_10 < VAR_11;
++VAR_10) {
VAR_9.flush();
VAR_6 = VAR_5->at(VAR_0, VAR_10).unboxToHV(VAR_0);
if (VAR_6->isNumber()) {
CallResult<PseudoHandle<StringPrimitive>> VAR_12 =
toString_RJS(VAR_0, VAR_6);
if (LLVM_UNLIKELY(VAR_12 == ExecutionStatus::EXCEPTION)) {
return ExecutionStatus::EXCEPTION;
}
VAR_6 = VAR_12->getHermesValue();
}
if (VAR_3) {
assert(
!VAR_3->isProxyObject() &&
""internal excludedItems object is a proxy"");
ComputedPropertyDescriptor VAR_13;
CallResult<bool> VAR_4 = JSObject::getOwnComputedPrimitiveDescriptor(
VAR_3,
VAR_0,
VAR_6,
JSObject::IgnoreProxy::Yes,
VAR_8,
VAR_13);
if (LLVM_UNLIKELY(VAR_4 == ExecutionStatus::EXCEPTION))
return ExecutionStatus::EXCEPTION;
if (*VAR_4)
continue;
}
ComputedPropertyDescriptor VAR_13;
CallResult<bool> VAR_14 =
JSProxy::getOwnProperty(VAR_2, VAR_0, VAR_6, VAR_13, nullptr);
if (LLVM_UNLIKELY(VAR_14 == ExecutionStatus::EXCEPTION))
return ExecutionStatus::EXCEPTION;
if (*VAR_14 && VAR_13.flags.enumerable) {
CallResult<PseudoHandle<>> VAR_15 =
JSProxy::getComputed(VAR_2, VAR_0, VAR_6, VAR_2);
if (LLVM_UNLIKELY(VAR_15 == ExecutionStatus::EXCEPTION))
return ExecutionStatus::EXCEPTION;
VAR_7 = std::move(*VAR_15);
VAR_14 = JSObject::defineOwnComputed(
VAR_1,
VAR_0,
VAR_6,
DefinePropertyFlags::getDefaultNewPropertyFlags(),
VAR_7);
if (LLVM_UNLIKELY(VAR_4 == ExecutionStatus::EXCEPTION))
return ExecutionStatus::EXCEPTION;
assert(
VAR_14 != ExecutionStatus::EXCEPTION && *VAR_14 &&
""CreateDataProperty failed"");
}
}
return VAR_1.getHermesValue();
}",facebook/hermes/a00d237346894c6067a594983be6634f4168c9ad/HermesBuiltin.cpp/vul/before/0.json,"CallResult<HermesValue> copyDataPropertiesSlowPath_RJS(
    Runtime &runtime,
    Handle<JSObject> target,
    Handle<JSObject> from,
    Handle<JSObject> excludedItems) {
  // 5. Let keys be ? from.[[OwnPropertyKeys]]().
  auto cr = JSObject::getOwnPropertyKeys(
      from,
      runtime,
      OwnKeysFlags()
          .plusIncludeSymbols()
          .plusIncludeNonSymbols()
          .plusIncludeNonEnumerable());
  if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  auto keys = *cr;

  MutableHandle<> nextKeyHandle{runtime};
  MutableHandle<> propValueHandle{runtime};
  MutableHandle<SymbolID> tmpSymbolStorage{runtime};
  GCScopeMarkerRAII marker{runtime};
  // 6. For each element nextKey of keys in List order, do
  for (uint32_t nextKeyIdx = 0, endIdx = keys->getEndIndex();
       nextKeyIdx < endIdx;
       ++nextKeyIdx) {
    marker.flush();
    nextKeyHandle = keys->at(runtime, nextKeyIdx).unboxToHV(runtime);
    if (nextKeyHandle->isNumber()) {
      CallResult<PseudoHandle<StringPrimitive>> strRes =
          toString_RJS(runtime, nextKeyHandle);
      if (LLVM_UNLIKELY(strRes == ExecutionStatus::EXCEPTION)) {
        return ExecutionStatus::EXCEPTION;
      }
      nextKeyHandle = strRes->getHermesValue();
    }

    // b. For each element e of excludedItems in List order, do
    //   i. If SameValue(e, nextKey) is true, then
    //     1. Set excluded to true.
    if (excludedItems) {
      assert(
          !excludedItems->isProxyObject() &&
          ""internal excludedItems object is a proxy"");
      ComputedPropertyDescriptor desc;
      CallResult<bool> cr = JSObject::getOwnComputedPrimitiveDescriptor(
          excludedItems,
          runtime,
          nextKeyHandle,
          JSObject::IgnoreProxy::Yes,
          tmpSymbolStorage,
          desc);
      if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))
        return ExecutionStatus::EXCEPTION;
      if (*cr)
        continue;
    }

    //   i. Let desc be ? from.[[GetOwnProperty]](nextKey).
    ComputedPropertyDescriptor desc;
    CallResult<bool> crb = JSObject::getOwnComputedDescriptor(
        from, runtime, nextKeyHandle, tmpSymbolStorage, desc);
    if (LLVM_UNLIKELY(crb == ExecutionStatus::EXCEPTION))
      return ExecutionStatus::EXCEPTION;
    //   ii. If desc is not undefined and desc.[[Enumerable]] is true, then
    // TODO(T141997867), move this special case behavior for host objects to
    // getOwnComputedDescriptor.
    if ((*crb && desc.flags.enumerable) || from->isHostObject()) {
      //     1. Let propValue be ? Get(from, nextKey).
      CallResult<PseudoHandle<>> crv =
          JSObject::getComputed_RJS(from, runtime, nextKeyHandle);
      if (LLVM_UNLIKELY(crv == ExecutionStatus::EXCEPTION))
        return ExecutionStatus::EXCEPTION;
      propValueHandle = std::move(*crv);
      //     2. Perform ! CreateDataProperty(target, nextKey, propValue).
      crb = JSObject::defineOwnComputed(
          target,
          runtime,
          nextKeyHandle,
          DefinePropertyFlags::getDefaultNewPropertyFlags(),
          propValueHandle);
      if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))
        return ExecutionStatus::EXCEPTION;
      assert(
          crb != ExecutionStatus::EXCEPTION && *crb &&
          ""CreateDataProperty failed"");
    }
  }
  return target.getHermesValue();
}","CallResult<HermesValue> copyDataPropertiesSlowPath_RJS(
    Runtime &VAR_0,
    Handle<JSObject> VAR_1,
    Handle<JSObject> VAR_2,
    Handle<JSObject> VAR_3) {
  /* COMMENT_0 */
  auto VAR_4 = JSObject::getOwnPropertyKeys(
      VAR_2,
      VAR_0,
      OwnKeysFlags()
          .plusIncludeSymbols()
          .plusIncludeNonSymbols()
          .plusIncludeNonEnumerable());
  if (LLVM_UNLIKELY(VAR_4 == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  auto VAR_5 = *VAR_4;

  MutableHandle<> VAR_6{VAR_0};
  MutableHandle<> VAR_7{VAR_0};
  MutableHandle<SymbolID> VAR_8{VAR_0};
  GCScopeMarkerRAII VAR_9{VAR_0};
  /* COMMENT_1 */
  for (uint32_t VAR_10 = 0, VAR_11 = VAR_5->getEndIndex();
       VAR_10 < VAR_11;
       ++VAR_10) {
    VAR_9.flush();
    VAR_6 = VAR_5->at(VAR_0, VAR_10).unboxToHV(VAR_0);
    if (VAR_6->isNumber()) {
      CallResult<PseudoHandle<StringPrimitive>> VAR_12 =
          toString_RJS(VAR_0, VAR_6);
      if (LLVM_UNLIKELY(VAR_12 == ExecutionStatus::EXCEPTION)) {
        return ExecutionStatus::EXCEPTION;
      }
      VAR_6 = VAR_12->getHermesValue();
    }

    /* COMMENT_2 */
    /* COMMENT_3 */
    /* COMMENT_4 */
    if (VAR_3) {
      assert(
          !VAR_3->isProxyObject() &&
          ""internal excludedItems object is a proxy"");
      ComputedPropertyDescriptor VAR_13;
      CallResult<bool> VAR_4 = JSObject::getOwnComputedPrimitiveDescriptor(
          VAR_3,
          VAR_0,
          VAR_6,
          JSObject::IgnoreProxy::Yes,
          VAR_8,
          VAR_13);
      if (LLVM_UNLIKELY(VAR_4 == ExecutionStatus::EXCEPTION))
        return ExecutionStatus::EXCEPTION;
      if (*VAR_4)
        continue;
    }

    /* COMMENT_5 */
    ComputedPropertyDescriptor VAR_13;
    CallResult<bool> VAR_14 = JSObject::getOwnComputedDescriptor(
        VAR_2, VAR_0, VAR_6, VAR_8, VAR_13);
    if (LLVM_UNLIKELY(VAR_14 == ExecutionStatus::EXCEPTION))
      return ExecutionStatus::EXCEPTION;
    /* COMMENT_6 */
    /* COMMENT_7 */
    /* COMMENT_8 */
    if ((*VAR_14 && VAR_13.flags.enumerable) || VAR_2->isHostObject()) {
      /* COMMENT_9 */
      CallResult<PseudoHandle<>> VAR_15 =
          JSObject::getComputed_RJS(VAR_2, VAR_0, VAR_6);
      if (LLVM_UNLIKELY(VAR_15 == ExecutionStatus::EXCEPTION))
        return ExecutionStatus::EXCEPTION;
      VAR_7 = std::move(*VAR_15);
      /* COMMENT_10 */
      VAR_14 = JSObject::defineOwnComputed(
          VAR_1,
          VAR_0,
          VAR_6,
          DefinePropertyFlags::getDefaultNewPropertyFlags(),
          VAR_7);
      if (LLVM_UNLIKELY(VAR_4 == ExecutionStatus::EXCEPTION))
        return ExecutionStatus::EXCEPTION;
      assert(
          VAR_14 != ExecutionStatus::EXCEPTION && *VAR_14 &&
          ""CreateDataProperty failed"");
    }
  }
  return VAR_1.getHermesValue();
}",facebook/hermes/a00d237346894c6067a594983be6634f4168c9ad/HermesBuiltin.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,12 +3,8 @@
     Handle<JSObject> target,
     Handle<JSObject> from,
     Handle<JSObject> excludedItems) {
-  assert(
-      from->isProxyObject() &&
-      ""copyDataPropertiesSlowPath_RJS is only for Proxy"");
-
   // 5. Let keys be ? from.[[OwnPropertyKeys]]().
-  auto cr = JSProxy::getOwnPropertyKeys(
+  auto cr = JSObject::getOwnPropertyKeys(
       from,
       runtime,
       OwnKeysFlags()
@@ -62,15 +58,17 @@
 
     //   i. Let desc be ? from.[[GetOwnProperty]](nextKey).
     ComputedPropertyDescriptor desc;
-    CallResult<bool> crb =
-        JSProxy::getOwnProperty(from, runtime, nextKeyHandle, desc, nullptr);
+    CallResult<bool> crb = JSObject::getOwnComputedDescriptor(
+        from, runtime, nextKeyHandle, tmpSymbolStorage, desc);
     if (LLVM_UNLIKELY(crb == ExecutionStatus::EXCEPTION))
       return ExecutionStatus::EXCEPTION;
     //   ii. If desc is not undefined and desc.[[Enumerable]] is true, then
-    if (*crb && desc.flags.enumerable) {
+    // TODO(T141997867), move this special case behavior for host objects to
+    // getOwnComputedDescriptor.
+    if ((*crb && desc.flags.enumerable) || from->isHostObject()) {
       //     1. Let propValue be ? Get(from, nextKey).
       CallResult<PseudoHandle<>> crv =
-          JSProxy::getComputed(from, runtime, nextKeyHandle, from);
+          JSObject::getComputed_RJS(from, runtime, nextKeyHandle);
       if (LLVM_UNLIKELY(crv == ExecutionStatus::EXCEPTION))
         return ExecutionStatus::EXCEPTION;
       propValueHandle = std::move(*crv);","{'deleted_lines': ['  assert(', '      from->isProxyObject() &&', '      ""copyDataPropertiesSlowPath_RJS is only for Proxy"");', '', '  auto cr = JSProxy::getOwnPropertyKeys(', '    CallResult<bool> crb =', '        JSProxy::getOwnProperty(from, runtime, nextKeyHandle, desc, nullptr);', '    if (*crb && desc.flags.enumerable) {', '          JSProxy::getComputed(from, runtime, nextKeyHandle, from);'], 'added_lines': ['  auto cr = JSObject::getOwnPropertyKeys(', '    CallResult<bool> crb = JSObject::getOwnComputedDescriptor(', '        from, runtime, nextKeyHandle, tmpSymbolStorage, desc);', '    // TODO(T141997867), move this special case behavior for host objects to', '    // getOwnComputedDescriptor.', '    if ((*crb && desc.flags.enumerable) || from->isHostObject()) {', '          JSObject::getComputed_RJS(from, runtime, nextKeyHandle);']}",True,"An error in Hermes' algorithm for copying objects properties prior to commit a00d237346894c6067a594983be6634f4168c9ad could be used by a malicious attacker to execute arbitrary code via type confusion. Note that this is only exploitable in cases where Hermes is used to execute untrusted JavaScript. Hence, most React Native applications are not affected.",9.8,CRITICAL,3,test,2023-01-10T19:43:42Z,4
CVE-2023-23557,['CWE-843'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,facebook/hermes,"Use copyDataProperties slow path for objects with accessors

Summary:
Fix a bug present in `hermesBuiltinCopyDataProperties`.
`hermesBuiltinCopyDataProperties` is meant to copy an object. It does
this by iterating over all the properties in the source object, and
then writing the key-value pair into a new object which is returned.The
iteration is done using `JSObject::forEachOwnPropertyWhile`, providing
a callback to process each property. It will take the property id, look
it up in the source object using `getNamedPropertyValue_RJS`, then take
that resulting value and write it into the target. However, that API
explicitly states the following:

> Obviously the callbacks shouldn't be  doing naughty things like modifying
the property map or creating new hidden classes (even implicitly)

But, `getNamedPropertyValue_RJS` can
perform arbitrary JS execution if it is a getter, including
adding/deleting new properties, which would modify the object's
HiddenClass, thus violating `JSObject::forEachOwnPropertyWhile`'s
precondition.Therefore, the fix is to use the correct, but slower path,
whenever there is an accessor on the object. This code path is more 1:1
to the spec. At the beginning, it will simply find all the properties
of the source object using `JSObject::getOwnPropertyKeys` and then
iterate on those, rather than use `JSObject::forEachOwnPropertyWhile`.
This way, we are allowed to manipulate the source object however we
wish, which is necessary in order to call `getNamedPropertyValue_RJS`.

Reviewed By: neildhar

Differential Revision: D41701871

fbshipit-source-id: c4be179f57d52827f12ca26b1ab8d17cdccd7447",a00d237346894c6067a594983be6634f4168c9ad,https://github.com/facebook/hermes/commit/a00d237346894c6067a594983be6634f4168c9ad,lib/VM/JSLib/HermesBuiltin.cpp,hermesBuiltinCopyDataProperties,"CallResult<HermesValue>
hermesBuiltinCopyDataProperties(void *, Runtime &runtime, NativeArgs args) {
GCScope gcScope{runtime};
Handle<JSObject> target = args.dyncastArg<JSObject>(0);
if (!target)
return HermesValue::encodeUndefinedValue();
Handle<> untypedSource = args.getArgHandle(1);
if (untypedSource->isNull() || untypedSource->isUndefined())
return target.getHermesValue();
Handle<JSObject> source = untypedSource->isObject()
? Handle<JSObject>::vmcast(untypedSource)
: Handle<JSObject>::vmcast(
runtime.makeHandle(*toObject(runtime, untypedSource)));
Handle<JSObject> excludedItems = args.dyncastArg<JSObject>(2);
assert(
(!excludedItems || !excludedItems->isProxyObject()) &&
""excludedItems internal List is a Proxy"");
if (source->isProxyObject()) {
return copyDataPropertiesSlowPath_RJS(
runtime, target, source, excludedItems);
}
MutableHandle<> nameHandle{runtime};
MutableHandle<> valueHandle{runtime};
MutableHandle<SymbolID> tmpSymbolStorage{runtime};
bool success = JSObject::forEachOwnPropertyWhile(
source,
runtime,
[&source,
&target,
&excludedItems,
&nameHandle,
&valueHandle,
&tmpSymbolStorage](
Runtime &runtime, uint32_t index, ComputedPropertyDescriptor desc) {
if (!desc.flags.enumerable)
return true;
nameHandle = HermesValue::encodeNumberValue(index);
if (excludedItems) {
assert(
!excludedItems->isProxyObject() &&
""internal excludedItems object is a proxy"");
ComputedPropertyDescriptor xdesc;
auto cr = JSObject::getOwnComputedPrimitiveDescriptor(
excludedItems,
runtime,
nameHandle,
JSObject::IgnoreProxy::Yes,
tmpSymbolStorage,
xdesc);
if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))
return false;
if (*cr)
return true;
}
valueHandle = JSObject::getOwnIndexed(
createPseudoHandle(source.get()), runtime, index);
if (LLVM_UNLIKELY(
JSObject::defineOwnComputedPrimitive(
target,
runtime,
nameHandle,
DefinePropertyFlags::getDefaultNewPropertyFlags(),
valueHandle) == ExecutionStatus::EXCEPTION)) {
return false;
}
return true;
},
[&source, &target, &excludedItems, &valueHandle](
Runtime &runtime, SymbolID sym, NamedPropertyDescriptor desc) {
if (!desc.flags.enumerable)
return true;
if (InternalProperty::isInternal(sym))
return true;
if (excludedItems) {
auto cr = JSObject::hasNamedOrIndexed(excludedItems, runtime, sym);
assert(
cr != ExecutionStatus::EXCEPTION &&
""hasNamedOrIndex failed, which can only happen with a proxy, ""
""but excludedItems should never be a proxy"");
if (*cr)
return true;
}
auto cr =
JSObject::getNamedPropertyValue_RJS(source, runtime, source, desc);
if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))
return false;
valueHandle = std::move(*cr);
if (LLVM_UNLIKELY(
JSObject::defineOwnPropertyInternal(
target,
runtime,
sym,
DefinePropertyFlags::getDefaultNewPropertyFlags(),
valueHandle) == ExecutionStatus::EXCEPTION)) {
return false;
}
return true;
});
if (LLVM_UNLIKELY(!success))
return ExecutionStatus::EXCEPTION;
return target.getHermesValue();
}","CallResult<HermesValue>
hermesBuiltinCopyDataProperties(void *, Runtime &VAR_0, NativeArgs VAR_1) {
GCScope VAR_2{VAR_0};
Handle<JSObject> VAR_3 = VAR_1.dyncastArg<JSObject>(0);
if (!VAR_3)
return HermesValue::encodeUndefinedValue();
Handle<> VAR_4 = VAR_1.getArgHandle(1);
if (VAR_4->isNull() || VAR_4->isUndefined())
return VAR_3.getHermesValue();
Handle<JSObject> VAR_5 = VAR_4->isObject()
? Handle<JSObject>::vmcast(VAR_4)
: Handle<JSObject>::vmcast(
VAR_0.makeHandle(*toObject(VAR_0, VAR_4)));
Handle<JSObject> VAR_6 = VAR_1.dyncastArg<JSObject>(2);
assert(
(!VAR_6 || !VAR_6->isProxyObject()) &&
""excludedItems internal List is a Proxy"");
if (VAR_5->isProxyObject()) {
return copyDataPropertiesSlowPath_RJS(
VAR_0, VAR_3, VAR_5, VAR_6);
}
MutableHandle<> VAR_7{VAR_0};
MutableHandle<> VAR_8{VAR_0};
MutableHandle<SymbolID> VAR_9{VAR_0};
bool VAR_10 = JSObject::forEachOwnPropertyWhile(
VAR_5,
VAR_0,
[&VAR_5,
&VAR_3,
&VAR_6,
&VAR_7,
&VAR_8,
&VAR_9](
Runtime &VAR_0, uint32_t VAR_11, ComputedPropertyDescriptor VAR_12) {
if (!VAR_12.flags.enumerable)
return true;
VAR_7 = HermesValue::encodeNumberValue(VAR_11);
if (VAR_6) {
assert(
!VAR_6->isProxyObject() &&
""internal excludedItems object is a proxy"");
ComputedPropertyDescriptor VAR_13;
auto VAR_14 = JSObject::getOwnComputedPrimitiveDescriptor(
VAR_6,
VAR_0,
VAR_7,
JSObject::IgnoreProxy::Yes,
VAR_9,
VAR_13);
if (LLVM_UNLIKELY(VAR_14 == ExecutionStatus::EXCEPTION))
return false;
if (*VAR_14)
return true;
}
VAR_8 = JSObject::getOwnIndexed(
createPseudoHandle(VAR_5.get()), VAR_0, VAR_11);
if (LLVM_UNLIKELY(
JSObject::defineOwnComputedPrimitive(
VAR_3,
VAR_0,
VAR_7,
DefinePropertyFlags::getDefaultNewPropertyFlags(),
VAR_8) == ExecutionStatus::EXCEPTION)) {
return false;
}
return true;
},
[&VAR_5, &VAR_3, &VAR_6, &VAR_8](
Runtime &VAR_0, SymbolID VAR_15, NamedPropertyDescriptor VAR_12) {
if (!VAR_12.flags.enumerable)
return true;
if (InternalProperty::isInternal(VAR_15))
return true;
if (VAR_6) {
auto VAR_14 = JSObject::hasNamedOrIndexed(VAR_6, VAR_0, VAR_15);
assert(
VAR_14 != ExecutionStatus::EXCEPTION &&
""hasNamedOrIndex failed, which can only happen with a proxy, ""
""but excludedItems should never be a proxy"");
if (*VAR_14)
return true;
}
auto VAR_14 =
JSObject::getNamedPropertyValue_RJS(VAR_5, VAR_0, VAR_5, VAR_12);
if (LLVM_UNLIKELY(VAR_14 == ExecutionStatus::EXCEPTION))
return false;
VAR_8 = std::move(*VAR_14);
if (LLVM_UNLIKELY(
JSObject::defineOwnPropertyInternal(
VAR_3,
VAR_0,
VAR_15,
DefinePropertyFlags::getDefaultNewPropertyFlags(),
VAR_8) == ExecutionStatus::EXCEPTION)) {
return false;
}
return true;
});
if (LLVM_UNLIKELY(!VAR_10))
return ExecutionStatus::EXCEPTION;
return VAR_3.getHermesValue();
}",facebook/hermes/a00d237346894c6067a594983be6634f4168c9ad/HermesBuiltin.cpp/vul/before/1.json,"CallResult<HermesValue>
hermesBuiltinCopyDataProperties(void *, Runtime &runtime, NativeArgs args) {
  GCScope gcScope{runtime};

  // 1. Assert: Type(target) is Object.
  Handle<JSObject> target = args.dyncastArg<JSObject>(0);
  // To be safe, ignore non-objects.
  if (!target)
    return HermesValue::encodeUndefinedValue();

  // 3. If source is undefined or null, return target.
  Handle<> untypedSource = args.getArgHandle(1);
  if (untypedSource->isNull() || untypedSource->isUndefined())
    return target.getHermesValue();

  // 4. Let from be ! ToObject(source).
  Handle<JSObject> source = untypedSource->isObject()
      ? Handle<JSObject>::vmcast(untypedSource)
      : Handle<JSObject>::vmcast(
            runtime.makeHandle(*toObject(runtime, untypedSource)));

  // 2. Assert: excludedItems is a List of property keys.
  // In Hermes, excludedItems is represented as a JSObject, created by
  // bytecode emitted by the compiler, whose keys are the excluded
  // propertyKeys
  Handle<JSObject> excludedItems = args.dyncastArg<JSObject>(2);
  assert(
      (!excludedItems || !excludedItems->isProxyObject()) &&
      ""excludedItems internal List is a Proxy"");

  // We cannot use the fast path if the object is a proxy, host object, or when
  // there could potentially be an accessor defined on the object. This is
  // because in order to use JSObject::forEachOwnPropertyWhile, we must not
  // modify the underlying property map or hidden class. However, if we have an
  // accessor, we cannot guarantee that condition, so we use the slow path.
  if (source->isProxyObject() || source->isHostObject() ||
      source->getClass(runtime)->getMayHaveAccessor()) {
    return copyDataPropertiesSlowPath_RJS(
        runtime, target, source, excludedItems);
  }

  MutableHandle<> nameHandle{runtime};
  MutableHandle<> valueHandle{runtime};
  MutableHandle<SymbolID> tmpSymbolStorage{runtime};

  // Process all named properties/symbols.
  bool success = JSObject::forEachOwnPropertyWhile(
      source,
      runtime,
      // indexedCB.
      [&source,
       &target,
       &excludedItems,
       &nameHandle,
       &valueHandle,
       &tmpSymbolStorage](
          Runtime &runtime, uint32_t index, ComputedPropertyDescriptor desc) {
        if (!desc.flags.enumerable)
          return true;

        nameHandle = HermesValue::encodeNumberValue(index);

        if (excludedItems) {
          assert(
              !excludedItems->isProxyObject() &&
              ""internal excludedItems object is a proxy"");
          ComputedPropertyDescriptor xdesc;
          auto cr = JSObject::getOwnComputedPrimitiveDescriptor(
              excludedItems,
              runtime,
              nameHandle,
              JSObject::IgnoreProxy::Yes,
              tmpSymbolStorage,
              xdesc);
          if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))
            return false;
          if (*cr)
            return true;
        }

        valueHandle = JSObject::getOwnIndexed(
            createPseudoHandle(source.get()), runtime, index);

        if (LLVM_UNLIKELY(
                JSObject::defineOwnComputedPrimitive(
                    target,
                    runtime,
                    nameHandle,
                    DefinePropertyFlags::getDefaultNewPropertyFlags(),
                    valueHandle) == ExecutionStatus::EXCEPTION)) {
          return false;
        }

        return true;
      },
      // namedCB.
      [&source, &target, &excludedItems, &valueHandle](
          Runtime &runtime, SymbolID sym, NamedPropertyDescriptor desc) {
        if (!desc.flags.enumerable)
          return true;
        if (InternalProperty::isInternal(sym))
          return true;

        // Skip excluded items.
        if (excludedItems) {
          auto cr = JSObject::hasNamedOrIndexed(excludedItems, runtime, sym);
          assert(
              cr != ExecutionStatus::EXCEPTION &&
              ""hasNamedOrIndex failed, which can only happen with a proxy, ""
              ""but excludedItems should never be a proxy"");
          if (*cr)
            return true;
        }

        SmallHermesValue shv =
            JSObject::getNamedSlotValueUnsafe(*source, runtime, desc);
        valueHandle = runtime.makeHandle(shv.unboxToHV(runtime));

        // sym can be an index-like property, so we have to bypass the assert in
        // defineOwnPropertyInternal.
        if (LLVM_UNLIKELY(
                JSObject::defineOwnPropertyInternal(
                    target,
                    runtime,
                    sym,
                    DefinePropertyFlags::getDefaultNewPropertyFlags(),
                    valueHandle) == ExecutionStatus::EXCEPTION)) {
          return false;
        }

        return true;
      });

  if (LLVM_UNLIKELY(!success))
    return ExecutionStatus::EXCEPTION;

  return target.getHermesValue();
}","CallResult<HermesValue>
hermesBuiltinCopyDataProperties(void *, Runtime &VAR_0, NativeArgs VAR_1) {
  GCScope VAR_2{VAR_0};

  /* COMMENT_0 */
  Handle<JSObject> VAR_3 = VAR_1.dyncastArg<JSObject>(0);
  /* COMMENT_1 */
  if (!VAR_3)
    return HermesValue::encodeUndefinedValue();

  /* COMMENT_2 */
  Handle<> VAR_4 = VAR_1.getArgHandle(1);
  if (VAR_4->isNull() || VAR_4->isUndefined())
    return VAR_3.getHermesValue();

  /* COMMENT_3 */
  Handle<JSObject> VAR_5 = VAR_4->isObject()
      ? Handle<JSObject>::vmcast(VAR_4)
      : Handle<JSObject>::vmcast(
            VAR_0.makeHandle(*toObject(VAR_0, VAR_4)));

  /* COMMENT_4 */
  /* COMMENT_5 */
  /* COMMENT_6 */
  /* COMMENT_7 */
  Handle<JSObject> VAR_6 = VAR_1.dyncastArg<JSObject>(2);
  assert(
      (!VAR_6 || !VAR_6->isProxyObject()) &&
      ""excludedItems internal List is a Proxy"");

  /* COMMENT_8 */
  /* COMMENT_9 */
  /* COMMENT_10 */
  /* COMMENT_11 */
  /* COMMENT_12 */
  if (VAR_5->isProxyObject() || VAR_5->isHostObject() ||
      VAR_5->getClass(VAR_0)->getMayHaveAccessor()) {
    return copyDataPropertiesSlowPath_RJS(
        VAR_0, VAR_3, VAR_5, VAR_6);
  }

  MutableHandle<> VAR_7{VAR_0};
  MutableHandle<> VAR_8{VAR_0};
  MutableHandle<SymbolID> VAR_9{VAR_0};

  /* COMMENT_13 */
  bool VAR_10 = JSObject::forEachOwnPropertyWhile(
      VAR_5,
      VAR_0,
      /* COMMENT_14 */
      [&VAR_5,
       &VAR_3,
       &VAR_6,
       &VAR_7,
       &VAR_8,
       &VAR_9](
          Runtime &VAR_0, uint32_t VAR_11, ComputedPropertyDescriptor VAR_12) {
        if (!VAR_12.flags.enumerable)
          return true;

        VAR_7 = HermesValue::encodeNumberValue(VAR_11);

        if (VAR_6) {
          assert(
              !VAR_6->isProxyObject() &&
              ""internal excludedItems object is a proxy"");
          ComputedPropertyDescriptor VAR_13;
          auto VAR_14 = JSObject::getOwnComputedPrimitiveDescriptor(
              VAR_6,
              VAR_0,
              VAR_7,
              JSObject::IgnoreProxy::Yes,
              VAR_9,
              VAR_13);
          if (LLVM_UNLIKELY(VAR_14 == ExecutionStatus::EXCEPTION))
            return false;
          if (*VAR_14)
            return true;
        }

        VAR_8 = JSObject::getOwnIndexed(
            createPseudoHandle(VAR_5.get()), VAR_0, VAR_11);

        if (LLVM_UNLIKELY(
                JSObject::defineOwnComputedPrimitive(
                    VAR_3,
                    VAR_0,
                    VAR_7,
                    DefinePropertyFlags::getDefaultNewPropertyFlags(),
                    VAR_8) == ExecutionStatus::EXCEPTION)) {
          return false;
        }

        return true;
      },
      /* COMMENT_15 */
      [&VAR_5, &VAR_3, &VAR_6, &VAR_8](
          Runtime &VAR_0, SymbolID VAR_15, NamedPropertyDescriptor VAR_12) {
        if (!VAR_12.flags.enumerable)
          return true;
        if (InternalProperty::isInternal(VAR_15))
          return true;

        /* COMMENT_16 */
        if (VAR_6) {
          auto VAR_14 = JSObject::hasNamedOrIndexed(VAR_6, VAR_0, VAR_15);
          assert(
              VAR_14 != ExecutionStatus::EXCEPTION &&
              ""hasNamedOrIndex failed, which can only happen with a proxy, ""
              ""but excludedItems should never be a proxy"");
          if (*VAR_14)
            return true;
        }

        SmallHermesValue VAR_16 =
            JSObject::getNamedSlotValueUnsafe(*VAR_5, VAR_0, VAR_12);
        VAR_8 = VAR_0.makeHandle(VAR_16.unboxToHV(VAR_0));

        /* COMMENT_17 */
        /* COMMENT_18 */
        if (LLVM_UNLIKELY(
                JSObject::defineOwnPropertyInternal(
                    VAR_3,
                    VAR_0,
                    VAR_15,
                    DefinePropertyFlags::getDefaultNewPropertyFlags(),
                    VAR_8) == ExecutionStatus::EXCEPTION)) {
          return false;
        }

        return true;
      });

  if (LLVM_UNLIKELY(!VAR_10))
    return ExecutionStatus::EXCEPTION;

  return VAR_3.getHermesValue();
}",facebook/hermes/a00d237346894c6067a594983be6634f4168c9ad/HermesBuiltin.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -28,7 +28,13 @@
       (!excludedItems || !excludedItems->isProxyObject()) &&
       ""excludedItems internal List is a Proxy"");
 
-  if (source->isProxyObject()) {
+  // We cannot use the fast path if the object is a proxy, host object, or when
+  // there could potentially be an accessor defined on the object. This is
+  // because in order to use JSObject::forEachOwnPropertyWhile, we must not
+  // modify the underlying property map or hidden class. However, if we have an
+  // accessor, we cannot guarantee that condition, so we use the slow path.
+  if (source->isProxyObject() || source->isHostObject() ||
+      source->getClass(runtime)->getMayHaveAccessor()) {
     return copyDataPropertiesSlowPath_RJS(
         runtime, target, source, excludedItems);
   }
@@ -106,12 +112,9 @@
             return true;
         }
 
-        auto cr =
-            JSObject::getNamedPropertyValue_RJS(source, runtime, source, desc);
-        if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))
-          return false;
-
-        valueHandle = std::move(*cr);
+        SmallHermesValue shv =
+            JSObject::getNamedSlotValueUnsafe(*source, runtime, desc);
+        valueHandle = runtime.makeHandle(shv.unboxToHV(runtime));
 
         // sym can be an index-like property, so we have to bypass the assert in
         // defineOwnPropertyInternal.","{'deleted_lines': ['  if (source->isProxyObject()) {', '        auto cr =', '            JSObject::getNamedPropertyValue_RJS(source, runtime, source, desc);', '        if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))', '          return false;', '', '        valueHandle = std::move(*cr);'], 'added_lines': ['  // We cannot use the fast path if the object is a proxy, host object, or when', '  // there could potentially be an accessor defined on the object. This is', '  // because in order to use JSObject::forEachOwnPropertyWhile, we must not', '  // modify the underlying property map or hidden class. However, if we have an', '  // accessor, we cannot guarantee that condition, so we use the slow path.', '  if (source->isProxyObject() || source->isHostObject() ||', '      source->getClass(runtime)->getMayHaveAccessor()) {', '        SmallHermesValue shv =', '            JSObject::getNamedSlotValueUnsafe(*source, runtime, desc);', '        valueHandle = runtime.makeHandle(shv.unboxToHV(runtime));']}",True,"An error in Hermes' algorithm for copying objects properties prior to commit a00d237346894c6067a594983be6634f4168c9ad could be used by a malicious attacker to execute arbitrary code via type confusion. Note that this is only exploitable in cases where Hermes is used to execute untrusted JavaScript. Hence, most React Native applications are not affected.",9.8,CRITICAL,3,test,2023-01-10T19:43:42Z,4
CVE-2022-38223,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,tats/w3m,"Fix m17n backspace handling causes out-of-bounds write in checkType

[CVE-2022-38223]
Bug-Debian: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=1019599
Bug-Debian: https://github.com/tats/w3m/issues/242",a40aa8e6387c9a7ee8013dd968298c26728c4966,https://github.com/tats/w3m/commit/a40aa8e6387c9a7ee8013dd968298c26728c4966,etc.c,checkType,"Str
checkType(Str s, Lineprop **oprop, Linecolor **ocolor)
{
Lineprop mode;
Lineprop effect = PE_NORMAL;
Lineprop *prop;
static Lineprop *prop_buffer = NULL;
static int prop_size = 0;
char *str = s->ptr, *endp = &s->ptr[s->length], *bs = NULL;
#ifdef USE_ANSI_COLOR
Lineprop ceffect = PE_NORMAL;
Linecolor cmode = 0;
int check_color = FALSE;
Linecolor *color = NULL;
static Linecolor *color_buffer = NULL;
static int color_size = 0;
char *es = NULL;
#endif
int do_copy = FALSE;
int i;
int plen = 0, clen;
if (prop_size < s->length) {
prop_size = (s->length > LINELEN) ? s->length : LINELEN;
prop_buffer = New_Reuse(Lineprop, prop_buffer, prop_size);
}
prop = prop_buffer;
if (ShowEffect) {
bs = memchr(str, '\b', s->length);
#ifdef USE_ANSI_COLOR
if (ocolor) {
es = memchr(str, ESC_CODE, s->length);
if (es) {
if (color_size < s->length) {
color_size = (s->length > LINELEN) ? s->length : LINELEN;
color_buffer = New_Reuse(Linecolor, color_buffer,
color_size);
}
color = color_buffer;
}
}
#endif
if ((bs != NULL)
#ifdef USE_ANSI_COLOR
|| (es != NULL)
#endif
) {
char *sp = str, *ep;
s = Strnew_size(s->length);
do_copy = TRUE;
ep = bs ? (bs - 2) : endp;
#ifdef USE_ANSI_COLOR
if (es && ep > es - 2)
ep = es - 2;
#endif
for (; str < ep && IS_ASCII(*str); str++) {
*(prop++) = PE_NORMAL | (IS_CNTRL(*str) ? PC_CTRL : PC_ASCII);
#ifdef USE_ANSI_COLOR
if (color)
*(color++) = 0;
#endif
}
Strcat_charp_n(s, sp, (int)(str - sp));
}
}
if (!do_copy) {
for (; str < endp && IS_ASCII(*str); str++)
*(prop++) = PE_NORMAL | (IS_CNTRL(*str) ? PC_CTRL : PC_ASCII);
}
while (str < endp) {
if (prop - prop_buffer >= prop_size)
break;
if (bs != NULL) {
#ifdef USE_M17N
if (str == bs - 2 && !strncmp(str, ""__\b\b"", 4)) {
str += 4;
effect = PE_UNDER;
if (str < endp)
bs = memchr(str, '\b', endp - str);
continue;
}
else
#endif
if (str == bs - 1 && *str == '_') {
str += 2;
effect = PE_UNDER;
if (str < endp)
bs = memchr(str, '\b', endp - str);
continue;
}
else if (str == bs) {
if (*(str + 1) == '_') {
if (s->length) {
str += 2;
#ifdef USE_M17N
for (i = 1; i <= plen; i++)
*(prop - i) |= PE_UNDER;
#else
*(prop - 1) |= PE_UNDER;
#endif
}
else {
str++;
}
}
#ifdef USE_M17N
else if (!strncmp(str + 1, ""\b__"", 3)) {
if (s->length) {
str += (plen == 1) ? 3 : 4;
for (i = 1; i <= plen; i++)
*(prop - i) |= PE_UNDER;
}
else {
str += 2;
}
}
else if (*(str + 1) == '\b') {
if (s->length) {
clen = get_mclen(str + 2);
if (plen == clen &&
!strncmp(str - plen, str + 2, plen)) {
for (i = 1; i <= plen; i++)
*(prop - i) |= PE_BOLD;
str += 2 + clen;
}
else {
Strshrink(s, plen);
prop -= plen;
str += 2;
}
}
else {
str += 2;
}
}
#endif
else {
if (s->length) {
#ifdef USE_M17N
clen = get_mclen(str + 1);
if (plen == clen &&
!strncmp(str - plen, str + 1, plen)) {
for (i = 1; i <= plen; i++)
*(prop - i) |= PE_BOLD;
str += 1 + clen;
}
else {
Strshrink(s, plen);
prop -= plen;
str++;
}
#else
if (*(str - 1) == *(str + 1)) {
*(prop - 1) |= PE_BOLD;
str += 2;
}
else {
Strshrink(s, 1);
prop--;
str++;
}
#endif
}
else {
str++;
}
}
if (str < endp)
bs = memchr(str, '\b', endp - str);
continue;
}
#ifdef USE_ANSI_COLOR
else if (str > bs)
bs = memchr(str, '\b', endp - str);
#endif
}
#ifdef USE_ANSI_COLOR
if (es != NULL) {
if (str == es) {
int ok = parse_ansi_color(&str, &ceffect, &cmode);
if (str < endp)
es = memchr(str, ESC_CODE, endp - str);
if (ok) {
if (cmode)
check_color = TRUE;
continue;
}
}
else if (str > es)
es = memchr(str, ESC_CODE, endp - str);
}
#endif
plen = get_mclen(str);
mode = get_mctype(str) | effect;
#ifdef USE_ANSI_COLOR
if (color) {
*(color++) = cmode;
mode |= ceffect;
}
#endif
*(prop++) = mode;
#ifdef USE_M17N
if (plen > 1) {
mode = (mode & ~PC_WCHAR1) | PC_WCHAR2;
for (i = 1; i < plen; i++) {
*(prop++) = mode;
#ifdef USE_ANSI_COLOR
if (color)
*(color++) = cmode;
#endif
}
if (do_copy)
Strcat_charp_n(s, (char *)str, plen);
str += plen;
}
else
#endif
{
if (do_copy)
Strcat_char(s, (char)*str);
str++;
}
effect = PE_NORMAL;
}
*oprop = prop_buffer;
#ifdef USE_ANSI_COLOR
if (ocolor)
*ocolor = check_color ? color_buffer : NULL;
#endif
return s;
}","Str
checkType(Str VAR_0, Lineprop **VAR_1, Linecolor **VAR_2)
{
Lineprop VAR_3;
Lineprop VAR_4 = VAR_5;
Lineprop *VAR_6;
static Lineprop *VAR_7 = NULL;
static int VAR_8 = 0;
char *VAR_9 = VAR_0->ptr, *VAR_10 = &VAR_0->ptr[VAR_0->length], *VAR_11 = NULL;
#ifdef VAR_12
Lineprop VAR_13 = VAR_5;
Linecolor VAR_14 = 0;
int VAR_15 = FALSE;
Linecolor *VAR_16 = NULL;
static Linecolor *VAR_17 = NULL;
static int VAR_18 = 0;
char *VAR_19 = NULL;
#endif
int VAR_20 = FALSE;
int VAR_21;
int VAR_22 = 0, VAR_23;
if (VAR_8 < VAR_0->length) {
VAR_8 = (VAR_0->length > VAR_24) ? VAR_0->length : VAR_24;
VAR_7 = New_Reuse(Lineprop, VAR_7, VAR_8);
}
VAR_6 = VAR_7;
if (VAR_25) {
VAR_11 = memchr(VAR_9, '\b', VAR_0->length);
#ifdef VAR_12
if (VAR_2) {
VAR_19 = memchr(VAR_9, VAR_26, VAR_0->length);
if (VAR_19) {
if (VAR_18 < VAR_0->length) {
VAR_18 = (VAR_0->length > VAR_24) ? VAR_0->length : VAR_24;
VAR_17 = New_Reuse(Linecolor, VAR_17,
VAR_18);
}
VAR_16 = VAR_17;
}
}
#endif
if ((VAR_11 != NULL)
#ifdef VAR_12
|| (VAR_19 != NULL)
#endif
) {
char *VAR_27 = VAR_9, *VAR_28;
VAR_0 = Strnew_size(VAR_0->length);
VAR_20 = TRUE;
VAR_28 = VAR_11 ? (VAR_11 - 2) : VAR_10;
#ifdef VAR_12
if (VAR_19 && VAR_28 > VAR_19 - 2)
VAR_28 = VAR_19 - 2;
#endif
for (; VAR_9 < VAR_28 && IS_ASCII(*VAR_9); VAR_9++) {
*(VAR_6++) = VAR_5 | (IS_CNTRL(*VAR_9) ? VAR_29 : VAR_30);
#ifdef VAR_12
if (VAR_16)
*(VAR_16++) = 0;
#endif
}
Strcat_charp_n(VAR_0, VAR_27, (int)(VAR_9 - VAR_27));
}
}
if (!VAR_20) {
for (; VAR_9 < VAR_10 && IS_ASCII(*VAR_9); VAR_9++)
*(VAR_6++) = VAR_5 | (IS_CNTRL(*VAR_9) ? VAR_29 : VAR_30);
}
while (VAR_9 < VAR_10) {
if (VAR_6 - VAR_7 >= VAR_8)
break;
if (VAR_11 != NULL) {
#ifdef VAR_31
if (VAR_9 == VAR_11 - 2 && !strncmp(VAR_9, ""__\b\b"", 4)) {
VAR_9 += 4;
VAR_4 = VAR_32;
if (VAR_9 < VAR_10)
VAR_11 = memchr(VAR_9, '\b', VAR_10 - VAR_9);
continue;
}
else
#endif
if (VAR_9 == VAR_11 - 1 && *VAR_9 == '_') {
VAR_9 += 2;
VAR_4 = VAR_32;
if (VAR_9 < VAR_10)
VAR_11 = memchr(VAR_9, '\b', VAR_10 - VAR_9);
continue;
}
else if (VAR_9 == VAR_11) {
if (*(VAR_9 + 1) == '_') {
if (VAR_0->length) {
VAR_9 += 2;
#ifdef VAR_31
for (VAR_21 = 1; VAR_21 <= VAR_22; VAR_21++)
*(VAR_6 - VAR_21) |= VAR_32;
#else
*(VAR_6 - 1) |= VAR_32;
#endif
}
else {
VAR_9++;
}
}
#ifdef VAR_31
else if (!strncmp(VAR_9 + 1, ""\b__"", 3)) {
if (VAR_0->length) {
VAR_9 += (VAR_22 == 1) ? 3 : 4;
for (VAR_21 = 1; VAR_21 <= VAR_22; VAR_21++)
*(VAR_6 - VAR_21) |= VAR_32;
}
else {
VAR_9 += 2;
}
}
else if (*(str + 1) == '\b') {
if (VAR_0->length) {
VAR_23 = get_mclen(str + 2);
if (VAR_22 == VAR_23 &&
!strncmp(str - VAR_22, str + 2, VAR_22)) {
for (VAR_21 = 1; VAR_21 <= VAR_22; VAR_21++)
*(VAR_6 - VAR_21) |= VAR_33;
str += 2 + VAR_23;
}
else {
Strshrink(VAR_0, VAR_22);
VAR_6 -= VAR_22;
str += 2;
}
}
else {
str += 2;
}
}
#endif
else {
if (VAR_0->length) {
#ifdef VAR_31
VAR_23 = get_mclen(str + 1);
if (VAR_22 == VAR_23 &&
!strncmp(str - VAR_22, str + 1, VAR_22)) {
for (VAR_21 = 1; VAR_21 <= VAR_22; VAR_21++)
*(VAR_6 - VAR_21) |= VAR_33;
str += 1 + VAR_23;
}
else {
Strshrink(VAR_0, VAR_22);
VAR_6 -= VAR_22;
str++;
}
#else
if (*(str - 1) == *(str + 1)) {
*(VAR_6 - 1) |= VAR_33;
str += 2;
}
else {
Strshrink(VAR_0, 1);
VAR_6--;
str++;
}
#endif
}
else {
str++;
}
}
if (str < VAR_10)
VAR_11 = memchr(str, '\b', VAR_10 - str);
continue;
}
#ifdef VAR_12
else if (str > VAR_11)
VAR_11 = memchr(str, '\b', VAR_10 - str);
#endif
}
#ifdef VAR_12
if (VAR_19 != NULL) {
if (str == VAR_19) {
int VAR_34 = parse_ansi_color(&str, &VAR_13, &VAR_14);
if (str < VAR_10)
VAR_19 = memchr(str, VAR_26, VAR_10 - str);
if (VAR_34) {
if (VAR_14)
VAR_15 = TRUE;
continue;
}
}
else if (str > VAR_19)
VAR_19 = memchr(str, VAR_26, VAR_10 - str);
}
#endif
VAR_22 = get_mclen(str);
VAR_3 = get_mctype(str) | VAR_4;
#ifdef VAR_12
if (VAR_16) {
*(VAR_16++) = VAR_14;
VAR_3 |= VAR_13;
}
#endif
*(VAR_6++) = VAR_3;
#ifdef VAR_31
if (VAR_22 > 1) {
VAR_3 = (VAR_3 & ~VAR_35) | VAR_36;
for (VAR_21 = 1; VAR_21 < VAR_22; VAR_21++) {
*(VAR_6++) = VAR_3;
#ifdef VAR_12
if (VAR_16)
*(VAR_16++) = VAR_14;
#endif
}
if (VAR_20)
Strcat_charp_n(VAR_0, (char *)str, VAR_22);
str += VAR_22;
}
else
#endif
{
if (VAR_20)
Strcat_char(VAR_0, (char)*str);
str++;
}
VAR_4 = VAR_5;
}
*VAR_1 = VAR_7;
#ifdef VAR_12
if (VAR_2)
*VAR_2 = VAR_15 ? VAR_17 : NULL;
#endif
return VAR_0;
}",tats/w3m/a40aa8e6387c9a7ee8013dd968298c26728c4966/etc.c/vul/before/0.json,"Str
checkType(Str s, Lineprop **oprop, Linecolor **ocolor)
{
    Lineprop mode;
    Lineprop effect = PE_NORMAL;
    Lineprop *prop;
    static Lineprop *prop_buffer = NULL;
    static int prop_size = 0;
    char *str = s->ptr, *endp = &s->ptr[s->length], *bs = NULL;
#ifdef USE_ANSI_COLOR
    Lineprop ceffect = PE_NORMAL;
    Linecolor cmode = 0;
    int check_color = FALSE;
    Linecolor *color = NULL;
    static Linecolor *color_buffer = NULL;
    static int color_size = 0;
    char *es = NULL;
#endif
    int do_copy = FALSE;
#ifdef USE_M17N
    int i;
    int plen = 0, clen;
    int *plens = NULL;
    static int *plens_buffer = NULL;
    static int plens_size = 0;
#endif

    if (prop_size < s->length) {
	prop_size = (s->length > LINELEN) ? s->length : LINELEN;
	prop_buffer = New_Reuse(Lineprop, prop_buffer, prop_size);
    }
    prop = prop_buffer;
#ifdef USE_M17N
    if (plens_size < s->length) {
	plens_size = (s->length > LINELEN) ? s->length : LINELEN;
	plens_buffer = New_Reuse(int, plens_buffer, plens_size);
    }
    plens = plens_buffer;
#endif

    if (ShowEffect) {
	bs = memchr(str, '\b', s->length);
#ifdef USE_ANSI_COLOR
	if (ocolor) {
	    es = memchr(str, ESC_CODE, s->length);
	    if (es) {
		if (color_size < s->length) {
		    color_size = (s->length > LINELEN) ? s->length : LINELEN;
		    color_buffer = New_Reuse(Linecolor, color_buffer,
					     color_size);
		}
		color = color_buffer;
	    }
	}
#endif
	if ((bs != NULL)
#ifdef USE_ANSI_COLOR
	    || (es != NULL)
#endif
	    ) {
	    char *sp = str, *ep;
	    s = Strnew_size(s->length);
	    do_copy = TRUE;
	    ep = bs ? (bs - 2) : endp;
#ifdef USE_ANSI_COLOR
	    if (es && ep > es - 2)
		ep = es - 2;
#endif
	    for (; str < ep && IS_ASCII(*str); str++) {
		*(prop++) = PE_NORMAL | (IS_CNTRL(*str) ? PC_CTRL : PC_ASCII);
#ifdef USE_ANSI_COLOR
		if (color)
		    *(color++) = 0;
#endif
#ifdef USE_M17N
		*(plens++) = plen = 1;
#endif
	    }
	    Strcat_charp_n(s, sp, (int)(str - sp));
	}
    }
    if (!do_copy) {
	for (; str < endp && IS_ASCII(*str); str++) {
	    *(prop++) = PE_NORMAL | (IS_CNTRL(*str) ? PC_CTRL : PC_ASCII);
#ifdef USE_M17N
	    *(plens++) = plen = 1;
#endif
	}
    }

    while (str < endp) {
	if (prop - prop_buffer >= prop_size)
	    break;
	if (bs != NULL) {
#ifdef USE_M17N
	    if (str == bs - 2 && !strncmp(str, ""__\b\b"", 4)) {
		str += 4;
		effect = PE_UNDER;
		if (str < endp)
		    bs = memchr(str, '\b', endp - str);
		continue;
	    }
	    else
#endif
	    if (str == bs - 1 && *str == '_') {
		str += 2;
		effect = PE_UNDER;
		if (str < endp)
		    bs = memchr(str, '\b', endp - str);
		continue;
	    }
	    else if (str == bs) {
		if (*(str + 1) == '_') {
		    if (s->length) {
			str += 2;
#ifdef USE_M17N
			for (i = 1; i <= plen; i++)
			    *(prop - i) |= PE_UNDER;
#else
			*(prop - 1) |= PE_UNDER;
#endif
		    }
		    else {
			str++;
		    }
		}
#ifdef USE_M17N
		else if (!strncmp(str + 1, ""\b__"", 3)) {
		    if (s->length) {
			str += (plen == 1) ? 3 : 4;
			for (i = 1; i <= plen; i++)
			    *(prop - i) |= PE_UNDER;
		    }
		    else {
			str += 2;
		    }
		}
		else if (*(str + 1) == '\b') {
		    if (s->length) {
			clen = get_mclen(str + 2);
			if (plen == clen &&
			    !strncmp(str - plen, str + 2, plen)) {
			    for (i = 1; i <= plen; i++)
				*(prop - i) |= PE_BOLD;
			    str += 2 + clen;
			}
			else {
			    Strshrink(s, plen);
			    prop -= plen;
			    plen = *(--plens);
			    str += 2;
			}
		    }
		    else {
			str += 2;
		    }
		}
#endif
		else {
		    if (s->length) {
#ifdef USE_M17N
			clen = get_mclen(str + 1);
			if (plen == clen &&
			    !strncmp(str - plen, str + 1, plen)) {
			    for (i = 1; i <= plen; i++)
				*(prop - i) |= PE_BOLD;
			    str += 1 + clen;
			}
			else {
			    Strshrink(s, plen);
			    prop -= plen;
			    plen = *(--plens);
			    str++;
			}
#else
			if (*(str - 1) == *(str + 1)) {
			    *(prop - 1) |= PE_BOLD;
			    str += 2;
			}
			else {
			    Strshrink(s, 1);
			    prop--;
			    str++;
			}
#endif
		    }
		    else {
			str++;
		    }
		}
		if (str < endp)
		    bs = memchr(str, '\b', endp - str);
		continue;
	    }
#ifdef USE_ANSI_COLOR
	    else if (str > bs)
		bs = memchr(str, '\b', endp - str);
#endif
	}
#ifdef USE_ANSI_COLOR
	if (es != NULL) {
	    if (str == es) {
		int ok = parse_ansi_color(&str, &ceffect, &cmode);
		if (str < endp)
		    es = memchr(str, ESC_CODE, endp - str);
		if (ok) {
		    if (cmode)
			check_color = TRUE;
		    continue;
		}
	    }
	    else if (str > es)
		es = memchr(str, ESC_CODE, endp - str);
	}
#endif

	mode = get_mctype(str) | effect;
#ifdef USE_ANSI_COLOR
	if (color) {
	    *(color++) = cmode;
	    mode |= ceffect;
	}
#endif
	*(prop++) = mode;
#ifdef USE_M17N
	plen = get_mclen(str);
	*(plens++) = plen;
	if (plen > 1) {
	    mode = (mode & ~PC_WCHAR1) | PC_WCHAR2;
	    for (i = 1; i < plen; i++) {
		*(prop++) = mode;
#ifdef USE_ANSI_COLOR
		if (color)
		    *(color++) = cmode;
#endif
	    }
	    if (do_copy)
		Strcat_charp_n(s, (char *)str, plen);
	    str += plen;
	}
	else
#endif
	{
	    if (do_copy)
		Strcat_char(s, (char)*str);
	    str++;
	}
	effect = PE_NORMAL;
    }
    *oprop = prop_buffer;
#ifdef USE_ANSI_COLOR
    if (ocolor)
	*ocolor = check_color ? color_buffer : NULL;
#endif
    return s;
}","Str
checkType(Str VAR_0, Lineprop **VAR_1, Linecolor **VAR_2)
{
    Lineprop VAR_3;
    Lineprop VAR_4 = VAR_5;
    Lineprop *VAR_6;
    static Lineprop *VAR_7 = NULL;
    static int VAR_8 = 0;
    char *VAR_9 = VAR_0->ptr, *VAR_10 = &VAR_0->ptr[VAR_0->length], *VAR_11 = NULL;
#ifdef VAR_12
    Lineprop VAR_13 = VAR_5;
    Linecolor VAR_14 = 0;
    int VAR_15 = FALSE;
    Linecolor *VAR_16 = NULL;
    static Linecolor *VAR_17 = NULL;
    static int VAR_18 = 0;
    char *VAR_19 = NULL;
#endif
    int VAR_20 = FALSE;
#ifdef VAR_21
    int VAR_22;
    int VAR_23 = 0, VAR_24;
    int *VAR_25 = NULL;
    static int *VAR_26 = NULL;
    static int VAR_27 = 0;
#endif

    if (VAR_8 < VAR_0->length) {
	VAR_8 = (VAR_0->length > VAR_28) ? VAR_0->length : VAR_28;
	VAR_7 = New_Reuse(Lineprop, VAR_7, VAR_8);
    }
    VAR_6 = VAR_7;
#ifdef VAR_21
    if (VAR_27 < VAR_0->length) {
	VAR_27 = (VAR_0->length > VAR_28) ? VAR_0->length : VAR_28;
	VAR_26 = New_Reuse(int, VAR_26, VAR_27);
    }
    VAR_25 = VAR_26;
#endif

    if (VAR_29) {
	VAR_11 = memchr(VAR_9, '\b', VAR_0->length);
#ifdef VAR_12
	if (VAR_2) {
	    VAR_19 = memchr(VAR_9, VAR_30, VAR_0->length);
	    if (VAR_19) {
		if (VAR_18 < VAR_0->length) {
		    VAR_18 = (VAR_0->length > VAR_28) ? VAR_0->length : VAR_28;
		    VAR_17 = New_Reuse(Linecolor, VAR_17,
					     VAR_18);
		}
		VAR_16 = VAR_17;
	    }
	}
#endif
	if ((VAR_11 != NULL)
#ifdef VAR_12
	    || (VAR_19 != NULL)
#endif
	    ) {
	    char *VAR_31 = VAR_9, *VAR_32;
	    VAR_0 = Strnew_size(VAR_0->length);
	    VAR_20 = TRUE;
	    VAR_32 = VAR_11 ? (VAR_11 - 2) : VAR_10;
#ifdef VAR_12
	    if (VAR_19 && VAR_32 > VAR_19 - 2)
		VAR_32 = VAR_19 - 2;
#endif
	    for (; VAR_9 < VAR_32 && IS_ASCII(*VAR_9); VAR_9++) {
		*(VAR_6++) = VAR_5 | (IS_CNTRL(*VAR_9) ? VAR_33 : VAR_34);
#ifdef VAR_12
		if (VAR_16)
		    *(VAR_16++) = 0;
#endif
#ifdef VAR_21
		*(VAR_25++) = VAR_23 = 1;
#endif
	    }
	    Strcat_charp_n(VAR_0, VAR_31, (int)(VAR_9 - VAR_31));
	}
    }
    if (!VAR_20) {
	for (; VAR_9 < VAR_10 && IS_ASCII(*VAR_9); VAR_9++) {
	    *(VAR_6++) = VAR_5 | (IS_CNTRL(*VAR_9) ? VAR_33 : VAR_34);
#ifdef VAR_21
	    *(VAR_25++) = VAR_23 = 1;
#endif
	}
    }

    while (VAR_9 < VAR_10) {
	if (VAR_6 - VAR_7 >= VAR_8)
	    break;
	if (VAR_11 != NULL) {
#ifdef VAR_21
	    if (VAR_9 == VAR_11 - 2 && !strncmp(VAR_9, ""__\b\b"", 4)) {
		VAR_9 += 4;
		VAR_4 = VAR_35;
		if (VAR_9 < VAR_10)
		    VAR_11 = memchr(VAR_9, '\b', VAR_10 - VAR_9);
		continue;
	    }
	    else
#endif
	    if (VAR_9 == VAR_11 - 1 && *VAR_9 == '_') {
		VAR_9 += 2;
		VAR_4 = VAR_35;
		if (VAR_9 < VAR_10)
		    VAR_11 = memchr(VAR_9, '\b', VAR_10 - VAR_9);
		continue;
	    }
	    else if (VAR_9 == VAR_11) {
		if (*(VAR_9 + 1) == '_') {
		    if (VAR_0->length) {
			VAR_9 += 2;
#ifdef VAR_21
			for (VAR_22 = 1; VAR_22 <= VAR_23; VAR_22++)
			    *(VAR_6 - VAR_22) |= VAR_35;
#else
			*(VAR_6 - 1) |= VAR_35;
#endif
		    }
		    else {
			VAR_9++;
		    }
		}
#ifdef VAR_21
		else if (!strncmp(VAR_9 + 1, ""\b__"", 3)) {
		    if (VAR_0->length) {
			VAR_9 += (VAR_23 == 1) ? 3 : 4;
			for (VAR_22 = 1; VAR_22 <= VAR_23; VAR_22++)
			    *(VAR_6 - VAR_22) |= VAR_35;
		    }
		    else {
			VAR_9 += 2;
		    }
		}
		else if (*(str + 1) == '\b') {
		    if (VAR_0->length) {
			VAR_24 = get_mclen(str + 2);
			if (VAR_23 == VAR_24 &&
			    !strncmp(str - VAR_23, str + 2, VAR_23)) {
			    for (VAR_22 = 1; VAR_22 <= VAR_23; VAR_22++)
				*(VAR_6 - VAR_22) |= VAR_36;
			    str += 2 + VAR_24;
			}
			else {
			    Strshrink(VAR_0, VAR_23);
			    VAR_6 -= VAR_23;
			    VAR_23 = *(--VAR_25);
			    str += 2;
			}
		    }
		    else {
			str += 2;
		    }
		}
#endif
		else {
		    if (VAR_0->length) {
#ifdef VAR_21
			VAR_24 = get_mclen(str + 1);
			if (VAR_23 == VAR_24 &&
			    !strncmp(str - VAR_23, str + 1, VAR_23)) {
			    for (VAR_22 = 1; VAR_22 <= VAR_23; VAR_22++)
				*(VAR_6 - VAR_22) |= VAR_36;
			    str += 1 + VAR_24;
			}
			else {
			    Strshrink(VAR_0, VAR_23);
			    VAR_6 -= VAR_23;
			    VAR_23 = *(--VAR_25);
			    str++;
			}
#else
			if (*(str - 1) == *(str + 1)) {
			    *(VAR_6 - 1) |= VAR_36;
			    str += 2;
			}
			else {
			    Strshrink(VAR_0, 1);
			    VAR_6--;
			    str++;
			}
#endif
		    }
		    else {
			str++;
		    }
		}
		if (str < VAR_10)
		    VAR_11 = memchr(str, '\b', VAR_10 - str);
		continue;
	    }
#ifdef VAR_12
	    else if (str > VAR_11)
		VAR_11 = memchr(str, '\b', VAR_10 - str);
#endif
	}
#ifdef VAR_12
	if (VAR_19 != NULL) {
	    if (str == VAR_19) {
		int VAR_37 = parse_ansi_color(&str, &VAR_13, &VAR_14);
		if (str < VAR_10)
		    VAR_19 = memchr(str, VAR_30, VAR_10 - str);
		if (VAR_37) {
		    if (VAR_14)
			VAR_15 = TRUE;
		    continue;
		}
	    }
	    else if (str > VAR_19)
		VAR_19 = memchr(str, VAR_30, VAR_10 - str);
	}
#endif

	VAR_3 = get_mctype(str) | VAR_4;
#ifdef VAR_12
	if (VAR_16) {
	    *(VAR_16++) = VAR_14;
	    VAR_3 |= VAR_13;
	}
#endif
	*(VAR_6++) = VAR_3;
#ifdef VAR_21
	VAR_23 = get_mclen(str);
	*(VAR_25++) = VAR_23;
	if (VAR_23 > 1) {
	    VAR_3 = (VAR_3 & ~VAR_38) | VAR_39;
	    for (VAR_22 = 1; VAR_22 < VAR_23; VAR_22++) {
		*(VAR_6++) = VAR_3;
#ifdef VAR_12
		if (VAR_16)
		    *(VAR_16++) = VAR_14;
#endif
	    }
	    if (VAR_20)
		Strcat_charp_n(VAR_0, (char *)str, VAR_23);
	    str += VAR_23;
	}
	else
#endif
	{
	    if (VAR_20)
		Strcat_char(VAR_0, (char)*str);
	    str++;
	}
	VAR_4 = VAR_5;
    }
    *VAR_1 = VAR_7;
#ifdef VAR_12
    if (VAR_2)
	*VAR_2 = VAR_15 ? VAR_17 : NULL;
#endif
    return VAR_0;
}",tats/w3m/a40aa8e6387c9a7ee8013dd968298c26728c4966/etc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,14 +17,26 @@
     char *es = NULL;
 #endif
     int do_copy = FALSE;
+#ifdef USE_M17N
     int i;
     int plen = 0, clen;
+    int *plens = NULL;
+    static int *plens_buffer = NULL;
+    static int plens_size = 0;
+#endif
 
     if (prop_size < s->length) {
 	prop_size = (s->length > LINELEN) ? s->length : LINELEN;
 	prop_buffer = New_Reuse(Lineprop, prop_buffer, prop_size);
     }
     prop = prop_buffer;
+#ifdef USE_M17N
+    if (plens_size < s->length) {
+	plens_size = (s->length > LINELEN) ? s->length : LINELEN;
+	plens_buffer = New_Reuse(int, plens_buffer, plens_size);
+    }
+    plens = plens_buffer;
+#endif
 
     if (ShowEffect) {
 	bs = memchr(str, '\b', s->length);
@@ -60,13 +72,20 @@
 		if (color)
 		    *(color++) = 0;
 #endif
+#ifdef USE_M17N
+		*(plens++) = plen = 1;
+#endif
 	    }
 	    Strcat_charp_n(s, sp, (int)(str - sp));
 	}
     }
     if (!do_copy) {
-	for (; str < endp && IS_ASCII(*str); str++)
+	for (; str < endp && IS_ASCII(*str); str++) {
 	    *(prop++) = PE_NORMAL | (IS_CNTRL(*str) ? PC_CTRL : PC_ASCII);
+#ifdef USE_M17N
+	    *(plens++) = plen = 1;
+#endif
+	}
     }
 
     while (str < endp) {
@@ -128,6 +147,7 @@
 			else {
 			    Strshrink(s, plen);
 			    prop -= plen;
+			    plen = *(--plens);
 			    str += 2;
 			}
 		    }
@@ -149,6 +169,7 @@
 			else {
 			    Strshrink(s, plen);
 			    prop -= plen;
+			    plen = *(--plens);
 			    str++;
 			}
 #else
@@ -193,7 +214,6 @@
 	}
 #endif
 
-	plen = get_mclen(str);
 	mode = get_mctype(str) | effect;
 #ifdef USE_ANSI_COLOR
 	if (color) {
@@ -203,6 +223,8 @@
 #endif
 	*(prop++) = mode;
 #ifdef USE_M17N
+	plen = get_mclen(str);
+	*(plens++) = plen;
 	if (plen > 1) {
 	    mode = (mode & ~PC_WCHAR1) | PC_WCHAR2;
 	    for (i = 1; i < plen; i++) {","{'deleted_lines': ['\tfor (; str < endp && IS_ASCII(*str); str++)', '\tplen = get_mclen(str);'], 'added_lines': ['#ifdef USE_M17N', '    int *plens = NULL;', '    static int *plens_buffer = NULL;', '    static int plens_size = 0;', '#endif', '#ifdef USE_M17N', '    if (plens_size < s->length) {', '\tplens_size = (s->length > LINELEN) ? s->length : LINELEN;', '\tplens_buffer = New_Reuse(int, plens_buffer, plens_size);', '    }', '    plens = plens_buffer;', '#endif', '#ifdef USE_M17N', '\t\t*(plens++) = plen = 1;', '#endif', '\tfor (; str < endp && IS_ASCII(*str); str++) {', '#ifdef USE_M17N', '\t    *(plens++) = plen = 1;', '#endif', '\t}', '\t\t\t    plen = *(--plens);', '\t\t\t    plen = *(--plens);', '\tplen = get_mclen(str);', '\t*(plens++) = plen;']}",True,There is an out-of-bounds write in checkType located in etc.c in w3m 0.5.3. It can be triggered by sending a crafted HTML file to the w3m binary. It allows an attacker to cause Denial of Service or possibly have unspecified other impact.,7.8,HIGH,2,test,2023-01-12T14:24:09Z,4
CVE-2023-25801,['CWE-415'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,tensorflow,"Fix security vulnerability with FractionalMax(AVG)Pool with illegal pooling_ratio

PiperOrigin-RevId: 501651261",ee50d1e00f81f62a4517453f721c634bbb478307,https://github.com/tensorflow/tensorflow/commit/ee50d1e00f81f62a4517453f721c634bbb478307,tensorflow/core/kernels/fractional_avg_pool_op.cc,FractionalAvgPoolOp,"explicit FractionalAvgPoolOp(OpKernelConstruction* context)
: OpKernel(context) {
OP_REQUIRES_OK(context, context->GetAttr(""pooling_ratio"", &pooling_ratio_));
OP_REQUIRES_OK(context, context->GetAttr(""pseudo_random"", &pseudo_random_));
OP_REQUIRES_OK(context, context->GetAttr(""overlapping"", &overlapping_));
OP_REQUIRES(context, pooling_ratio_.size() == 4,
errors::InvalidArgument(
""pooling_ratio field must specify 4 dimensions""));
for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {
OP_REQUIRES(context, pooling_ratio_[i] >= 1,
errors::InvalidArgument(
""pooling_ratio cannot be smaller than 1, got: "",
pooling_ratio_[i]));
}
OP_REQUIRES(
context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,
errors::Unimplemented(""Fractional average pooling is not yet ""
""supported on the batch nor channel dimension.""));
OP_REQUIRES_OK(context, context->GetAttr(""deterministic"", &deterministic_));
OP_REQUIRES_OK(context, context->GetAttr(""seed"", &seed_));
OP_REQUIRES_OK(context, context->GetAttr(""seed2"", &seed2_));
if (deterministic_) {
if ((seed_ == 0) && (seed2_ == 0)) {
seed_ = random::New64();
seed2_ = random::New64();
}
} else {
OP_REQUIRES(
context, (seed_ == 0) && (seed2_ == 0),
errors::InvalidArgument(
""Both seed and seed2 should be 0 if deterministic is false.""));
}
}","explicit FractionalAvgPoolOp(OpKernelConstruction* VAR_0)
: OpKernel(VAR_0) {
OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""pooling_ratio"", &VAR_1));
OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""pseudo_random"", &VAR_2));
OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""overlapping"", &VAR_3));
OP_REQUIRES(VAR_0, VAR_1.size() == 4,
errors::InvalidArgument(
""pooling_ratio field must specify 4 dimensions""));
for (std::size_t VAR_4 = 0; VAR_4 < VAR_1.size(); ++VAR_4) {
OP_REQUIRES(VAR_0, VAR_1[VAR_4] >= 1,
errors::InvalidArgument(
""pooling_ratio cannot be smaller than 1, got: "",
VAR_1[VAR_4]));
}
OP_REQUIRES(
VAR_0, VAR_1[0] == 1 || VAR_1[3] == 1,
errors::Unimplemented(""Fractional average pooling is not yet ""
""supported on the batch nor channel dimension.""));
OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""deterministic"", &VAR_5));
OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""seed"", &VAR_6));
OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""seed2"", &VAR_7));
if (VAR_5) {
if ((VAR_6 == 0) && (VAR_7 == 0)) {
VAR_6 = random::New64();
VAR_7 = random::New64();
}
} else {
OP_REQUIRES(
VAR_0, (VAR_6 == 0) && (VAR_7 == 0),
errors::InvalidArgument(
""Both seed and seed2 should be 0 if deterministic is false.""));
}
}",,"explicit FractionalAvgPoolOp(OpKernelConstruction* context)
      : OpKernel(context) {
    OP_REQUIRES_OK(context, context->GetAttr(""pooling_ratio"", &pooling_ratio_));
    OP_REQUIRES_OK(context, context->GetAttr(""pseudo_random"", &pseudo_random_));
    OP_REQUIRES_OK(context, context->GetAttr(""overlapping"", &overlapping_));
    OP_REQUIRES(context, pooling_ratio_.size() == 4,
                errors::InvalidArgument(
                    ""pooling_ratio field must specify 4 dimensions""));
    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {
      OP_REQUIRES(context, pooling_ratio_[i] >= 1,
                  errors::InvalidArgument(
                      ""pooling_ratio cannot be smaller than 1, got: "",
                      pooling_ratio_[i]));
    }
    OP_REQUIRES(
        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,
        errors::Unimplemented(""Fractional average pooling is not yet ""
                              ""supported on the batch nor channel dimension.""));
    OP_REQUIRES_OK(context, context->GetAttr(""deterministic"", &deterministic_));
    OP_REQUIRES_OK(context, context->GetAttr(""seed"", &seed_));
    OP_REQUIRES_OK(context, context->GetAttr(""seed2"", &seed2_));
    if (deterministic_) {
      // If both seeds are not set when deterministic_ is true, force set seeds.
      if ((seed_ == 0) && (seed2_ == 0)) {
        seed_ = random::New64();
        seed2_ = random::New64();
      }
    } else {
      OP_REQUIRES(
          context, (seed_ == 0) && (seed2_ == 0),
          errors::InvalidArgument(
              ""Both seed and seed2 should be 0 if deterministic is false.""));
    }
  }","explicit FractionalAvgPoolOp(OpKernelConstruction* VAR_0)
      : OpKernel(VAR_0) {
    OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""pooling_ratio"", &VAR_1));
    OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""pseudo_random"", &VAR_2));
    OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""overlapping"", &VAR_3));
    OP_REQUIRES(VAR_0, VAR_1.size() == 4,
                errors::InvalidArgument(
                    ""pooling_ratio field must specify 4 dimensions""));
    for (std::size_t VAR_4 = 0; VAR_4 < VAR_1.size(); ++VAR_4) {
      OP_REQUIRES(VAR_0, VAR_1[VAR_4] >= 1,
                  errors::InvalidArgument(
                      ""pooling_ratio cannot be smaller than 1, got: "",
                      VAR_1[VAR_4]));
    }
    OP_REQUIRES(
        VAR_0, VAR_1[0] == 1 && VAR_1[3] == 1,
        errors::Unimplemented(""Fractional average pooling is not yet ""
                              ""supported on the batch nor channel dimension.""));
    OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""deterministic"", &VAR_5));
    OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""seed"", &VAR_6));
    OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""seed2"", &VAR_7));
    if (VAR_5) {
      /* COMMENT_0 */
      if ((VAR_6 == 0) && (VAR_7 == 0)) {
        VAR_6 = random::New64();
        VAR_7 = random::New64();
      }
    } else {
      OP_REQUIRES(
          VAR_0, (VAR_6 == 0) && (VAR_7 == 0),
          errors::InvalidArgument(
              ""Both seed and seed2 should be 0 if deterministic is false.""));
    }
  }",,"--- func_before
+++ func_after
@@ -13,7 +13,7 @@
                       pooling_ratio_[i]));
     }
     OP_REQUIRES(
-        context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,
+        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,
         errors::Unimplemented(""Fractional average pooling is not yet ""
                               ""supported on the batch nor channel dimension.""));
     OP_REQUIRES_OK(context, context->GetAttr(""deterministic"", &deterministic_));","{'deleted_lines': ['        context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,'], 'added_lines': ['        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,']}",True,"TensorFlow is an open source machine learning platform. Prior to versions 2.12.0 and 2.11.1, `nn_ops.fractional_avg_pool_v2` and `nn_ops.fractional_max_pool_v2` require the first and fourth elements of their parameter `pooling_ratio` to be equal to 1.0, as pooling on batch and channel dimensions is not supported. A fix is included in TensorFlow 2.12.0 and 2.11.1.",8.0,HIGH,2,test,2023-01-12T21:26:50Z,4
CVE-2023-25801,['CWE-415'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,tensorflow,"Fix security vulnerability with FractionalMax(AVG)Pool with illegal pooling_ratio

PiperOrigin-RevId: 501651261",ee50d1e00f81f62a4517453f721c634bbb478307,https://github.com/tensorflow/tensorflow/commit/ee50d1e00f81f62a4517453f721c634bbb478307,tensorflow/core/kernels/fractional_max_pool_op.cc,FractionalMaxPoolOp,"explicit FractionalMaxPoolOp(OpKernelConstruction* context)
: OpKernel(context) {
OP_REQUIRES_OK(context, context->GetAttr(""pooling_ratio"", &pooling_ratio_));
OP_REQUIRES_OK(context, context->GetAttr(""pseudo_random"", &pseudo_random_));
OP_REQUIRES_OK(context, context->GetAttr(""overlapping"", &overlapping_));
OP_REQUIRES(context, pooling_ratio_.size() == 4,
errors::InvalidArgument(""pooling_ratio field must ""
""specify 4 dimensions""));
for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {
OP_REQUIRES(context, pooling_ratio_[i] >= 1,
errors::InvalidArgument(
""pooling_ratio cannot be smaller than 1, got: "",
pooling_ratio_[i]));
}
OP_REQUIRES(
context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,
errors::Unimplemented(""Fractional max pooling is not yet ""
""supported on the batch nor channel dimension.""));
OP_REQUIRES_OK(context, context->GetAttr(""deterministic"", &deterministic_));
OP_REQUIRES_OK(context, context->GetAttr(""seed"", &seed_));
OP_REQUIRES_OK(context, context->GetAttr(""seed2"", &seed2_));
if (deterministic_) {
if ((seed_ == 0) && (seed2_ == 0)) {
seed_ = random::New64();
seed2_ = random::New64();
}
} else {
OP_REQUIRES(
context, (seed_ == 0) && (seed2_ == 0),
errors::InvalidArgument(
""Both seed and seed2 should be 0 if deterministic is false.""));
}
}","explicit FractionalMaxPoolOp(OpKernelConstruction* VAR_0)
: OpKernel(VAR_0) {
OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""pooling_ratio"", &VAR_1));
OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""pseudo_random"", &VAR_2));
OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""overlapping"", &VAR_3));
OP_REQUIRES(VAR_0, VAR_1.size() == 4,
errors::InvalidArgument(""pooling_ratio field must ""
""specify 4 dimensions""));
for (std::size_t VAR_4 = 0; VAR_4 < VAR_1.size(); ++VAR_4) {
OP_REQUIRES(VAR_0, VAR_1[VAR_4] >= 1,
errors::InvalidArgument(
""pooling_ratio cannot be smaller than 1, got: "",
VAR_1[VAR_4]));
}
OP_REQUIRES(
VAR_0, VAR_1[0] == 1 || VAR_1[3] == 1,
errors::Unimplemented(""Fractional max pooling is not yet ""
""supported on the batch nor channel dimension.""));
OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""deterministic"", &VAR_5));
OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""seed"", &VAR_6));
OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""seed2"", &VAR_7));
if (VAR_5) {
if ((VAR_6 == 0) && (VAR_7 == 0)) {
VAR_6 = random::New64();
VAR_7 = random::New64();
}
} else {
OP_REQUIRES(
VAR_0, (VAR_6 == 0) && (VAR_7 == 0),
errors::InvalidArgument(
""Both seed and seed2 should be 0 if deterministic is false.""));
}
}",,"explicit FractionalMaxPoolOp(OpKernelConstruction* context)
      : OpKernel(context) {
    OP_REQUIRES_OK(context, context->GetAttr(""pooling_ratio"", &pooling_ratio_));
    OP_REQUIRES_OK(context, context->GetAttr(""pseudo_random"", &pseudo_random_));
    OP_REQUIRES_OK(context, context->GetAttr(""overlapping"", &overlapping_));

    OP_REQUIRES(context, pooling_ratio_.size() == 4,
                errors::InvalidArgument(""pooling_ratio field must ""
                                        ""specify 4 dimensions""));
    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {
      OP_REQUIRES(context, pooling_ratio_[i] >= 1,
                  errors::InvalidArgument(
                      ""pooling_ratio cannot be smaller than 1, got: "",
                      pooling_ratio_[i]));
    }

    OP_REQUIRES(
        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,
        errors::Unimplemented(""Fractional max pooling is not yet ""
                              ""supported on the batch nor channel dimension.""));

    OP_REQUIRES_OK(context, context->GetAttr(""deterministic"", &deterministic_));
    OP_REQUIRES_OK(context, context->GetAttr(""seed"", &seed_));
    OP_REQUIRES_OK(context, context->GetAttr(""seed2"", &seed2_));
    if (deterministic_) {
      // If both seeds are not set when deterministic_ is true, force set seeds.
      if ((seed_ == 0) && (seed2_ == 0)) {
        seed_ = random::New64();
        seed2_ = random::New64();
      }
    } else {
      OP_REQUIRES(
          context, (seed_ == 0) && (seed2_ == 0),
          errors::InvalidArgument(
              ""Both seed and seed2 should be 0 if deterministic is false.""));
    }
  }","explicit FractionalMaxPoolOp(OpKernelConstruction* VAR_0)
      : OpKernel(VAR_0) {
    OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""pooling_ratio"", &VAR_1));
    OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""pseudo_random"", &VAR_2));
    OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""overlapping"", &VAR_3));

    OP_REQUIRES(VAR_0, VAR_1.size() == 4,
                errors::InvalidArgument(""pooling_ratio field must ""
                                        ""specify 4 dimensions""));
    for (std::size_t VAR_4 = 0; VAR_4 < VAR_1.size(); ++VAR_4) {
      OP_REQUIRES(VAR_0, VAR_1[VAR_4] >= 1,
                  errors::InvalidArgument(
                      ""pooling_ratio cannot be smaller than 1, got: "",
                      VAR_1[VAR_4]));
    }

    OP_REQUIRES(
        VAR_0, VAR_1[0] == 1 && VAR_1[3] == 1,
        errors::Unimplemented(""Fractional max pooling is not yet ""
                              ""supported on the batch nor channel dimension.""));

    OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""deterministic"", &VAR_5));
    OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""seed"", &VAR_6));
    OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(""seed2"", &VAR_7));
    if (VAR_5) {
      /* COMMENT_0 */
      if ((VAR_6 == 0) && (VAR_7 == 0)) {
        VAR_6 = random::New64();
        VAR_7 = random::New64();
      }
    } else {
      OP_REQUIRES(
          VAR_0, (VAR_6 == 0) && (VAR_7 == 0),
          errors::InvalidArgument(
              ""Both seed and seed2 should be 0 if deterministic is false.""));
    }
  }",,"--- func_before
+++ func_after
@@ -15,7 +15,7 @@
     }
 
     OP_REQUIRES(
-        context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,
+        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,
         errors::Unimplemented(""Fractional max pooling is not yet ""
                               ""supported on the batch nor channel dimension.""));
 ","{'deleted_lines': ['        context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,'], 'added_lines': ['        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,']}",True,"TensorFlow is an open source machine learning platform. Prior to versions 2.12.0 and 2.11.1, `nn_ops.fractional_avg_pool_v2` and `nn_ops.fractional_max_pool_v2` require the first and fourth elements of their parameter `pooling_ratio` to be equal to 1.0, as pooling on batch and channel dimensions is not supported. A fix is included in TensorFlow 2.12.0 and 2.11.1.",8.0,HIGH,2,test,2023-01-12T21:26:50Z,4
CVE-2023-25660,['CWE-476'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,tensorflow,"Quick fix for a vuln in printing empty tensors.

PiperOrigin-RevId: 503308327",6d423b8bcc9aa9f5554dc988c1c16d038b508df1,https://github.com/tensorflow/tensorflow/commit/6d423b8bcc9aa9f5554dc988c1c16d038b508df1,tensorflow/core/framework/tensor.cc,SummarizeArray,"string SummarizeArray<bool>(int64_t limit, int64_t num_elts,
const TensorShape& tensor_shape, const char* data,
const bool print_v2) {
auto mutable_data = std::unique_ptr<char[]>(new char[num_elts]);
for (int64_t i = 0; i < num_elts; ++i)
mutable_data.get()[i] = data[i] ? 1 : 0;
bool* array = reinterpret_cast<bool*>(mutable_data.get());
return SummarizeArrayInternal<bool>(limit, num_elts, tensor_shape, array,
print_v2);
}","string VAR_0<bool>(int64_t VAR_1, int64_t VAR_2,
const TensorShape& VAR_3, const char* VAR_4,
const bool VAR_5) {
auto VAR_6 = std::VAR_7<char[]>(new char[VAR_2]);
for (int64_t VAR_8 = 0; VAR_8 < VAR_2; ++VAR_8)
VAR_6.get()[VAR_8] = VAR_4[VAR_8] ? 1 : 0;
bool* VAR_9 = VAR_10<bool*>(VAR_6.get());
return VAR_11<bool>(VAR_1, VAR_2, VAR_3, VAR_9,
VAR_5);
}",tensorflow/6d423b8bcc9aa9f5554dc988c1c16d038b508df1/tensor.cc/vul/before/0.json,"string SummarizeArray<bool>(int64_t limit, int64_t num_elts,
                            const TensorShape& tensor_shape, const char* data,
                            const bool print_v2) {
  if (data == nullptr) {
    return strings::StrCat("""");  // we already print type and shape
  }
  // We first convert all chars to be 0/1 to not get InvalidEnumValue sanitizer
  // error
  auto mutable_data = std::unique_ptr<char[]>(new char[num_elts]);
  for (int64_t i = 0; i < num_elts; ++i)
    mutable_data.get()[i] = data[i] ? 1 : 0;
  bool* array = reinterpret_cast<bool*>(mutable_data.get());
  return SummarizeArrayInternal<bool>(limit, num_elts, tensor_shape, array,
                                      print_v2);
}","string VAR_0<bool>(int64_t VAR_1, int64_t VAR_2,
                            const TensorShape& VAR_3, const char* VAR_4,
                            const bool VAR_5) {
  if (VAR_4 == nullptr) {
    return strings::StrCat("""");  /* COMMENT_0 */
  }
  /* COMMENT_1 */
  /* COMMENT_2 */
  auto VAR_6 = std::VAR_7<char[]>(new char[VAR_2]);
  for (int64_t VAR_8 = 0; VAR_8 < VAR_2; ++VAR_8)
    VAR_6.get()[VAR_8] = VAR_4[VAR_8] ? 1 : 0;
  bool* VAR_9 = VAR_10<bool*>(VAR_6.get());
  return VAR_11<bool>(VAR_1, VAR_2, VAR_3, VAR_9,
                                      VAR_5);
}",tensorflow/6d423b8bcc9aa9f5554dc988c1c16d038b508df1/tensor.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,9 @@
 string SummarizeArray<bool>(int64_t limit, int64_t num_elts,
                             const TensorShape& tensor_shape, const char* data,
                             const bool print_v2) {
+  if (data == nullptr) {
+    return strings::StrCat("""");  // we already print type and shape
+  }
   // We first convert all chars to be 0/1 to not get InvalidEnumValue sanitizer
   // error
   auto mutable_data = std::unique_ptr<char[]>(new char[num_elts]);","{'deleted_lines': [], 'added_lines': ['  if (data == nullptr) {', '    return strings::StrCat("""");  // we already print type and shape', '  }']}",True,"TensorFlow is an open source platform for machine learning. Prior to versions 2.12.0 and 2.11.1, when the parameter `summarize` of `tf.raw_ops.Print` is zero, the new method `SummarizeArray<bool>` will reference to a nullptr, leading to a seg fault. A fix is included in TensorFlow version 2.12 and version 2.11.1.
",7.5,HIGH,2,test,2023-01-20T01:31:46Z,4
CVE-2023-0458,['CWE-476'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N,1,torvalds/linux,"prlimit: do_prlimit needs to have a speculation check

do_prlimit() adds the user-controlled resource value to a pointer that
will subsequently be dereferenced.  In order to help prevent this
codepath from being used as a spectre ""gadget"" a barrier needs to be
added after checking the range.

Reported-by: Jordy Zomer <jordyzomer@google.com>
Tested-by: Jordy Zomer <jordyzomer@google.com>
Suggested-by: Linus Torvalds <torvalds@linuxfoundation.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",739790605705ddcf18f21782b9c99ad7d53a8c11,https://github.com/torvalds/linux/commit/739790605705ddcf18f21782b9c99ad7d53a8c11,kernel/sys.c,do_prlimit,"static int do_prlimit(struct task_struct *tsk, unsigned int resource,
struct rlimit *new_rlim, struct rlimit *old_rlim)
{
struct rlimit *rlim;
int retval = 0;
if (resource >= RLIM_NLIMITS)
return -EINVAL;
if (new_rlim) {
if (new_rlim->rlim_cur > new_rlim->rlim_max)
return -EINVAL;
if (resource == RLIMIT_NOFILE &&
new_rlim->rlim_max > sysctl_nr_open)
return -EPERM;
}
rlim = tsk->signal->rlim + resource;
task_lock(tsk->group_leader);
if (new_rlim) {
if (new_rlim->rlim_max > rlim->rlim_max &&
!capable(CAP_SYS_RESOURCE))
retval = -EPERM;
if (!retval)
retval = security_task_setrlimit(tsk, resource, new_rlim);
}
if (!retval) {
if (old_rlim)
*old_rlim = *rlim;
if (new_rlim)
*rlim = *new_rlim;
}
task_unlock(tsk->group_leader);
if (!retval && new_rlim && resource == RLIMIT_CPU &&
new_rlim->rlim_cur != RLIM_INFINITY &&
IS_ENABLED(CONFIG_POSIX_TIMERS)) {
update_rlimit_cpu(tsk->group_leader, new_rlim->rlim_cur);
}
return retval;
}","static int do_prlimit(struct task_struct *VAR_0, unsigned int VAR_1,
struct rlimit *VAR_2, struct rlimit *VAR_3)
{
struct rlimit *VAR_4;
int VAR_5 = 0;
if (VAR_1 >= VAR_6)
return -VAR_7;
if (VAR_2) {
if (VAR_2->rlim_cur > VAR_2->rlim_max)
return -VAR_7;
if (VAR_1 == VAR_8 &&
VAR_2->rlim_max > VAR_9)
return -VAR_10;
}
VAR_4 = VAR_0->signal->rlim + VAR_1;
task_lock(VAR_0->group_leader);
if (VAR_2) {
if (VAR_2->rlim_max > VAR_4->rlim_max &&
!capable(VAR_11))
VAR_5 = -VAR_10;
if (!VAR_5)
VAR_5 = security_task_setrlimit(VAR_0, VAR_1, VAR_2);
}
if (!VAR_5) {
if (VAR_3)
*VAR_3 = *VAR_4;
if (VAR_2)
*VAR_4 = *VAR_2;
}
task_unlock(VAR_0->group_leader);
if (!VAR_5 && VAR_2 && VAR_1 == VAR_12 &&
VAR_2->rlim_cur != VAR_13 &&
IS_ENABLED(VAR_14)) {
update_rlimit_cpu(VAR_0->group_leader, VAR_2->rlim_cur);
}
return VAR_5;
}",torvalds/linux/739790605705ddcf18f21782b9c99ad7d53a8c11/sys.c/vul/before/0.json,"static int do_prlimit(struct task_struct *tsk, unsigned int resource,
		      struct rlimit *new_rlim, struct rlimit *old_rlim)
{
	struct rlimit *rlim;
	int retval = 0;

	if (resource >= RLIM_NLIMITS)
		return -EINVAL;
	resource = array_index_nospec(resource, RLIM_NLIMITS);

	if (new_rlim) {
		if (new_rlim->rlim_cur > new_rlim->rlim_max)
			return -EINVAL;
		if (resource == RLIMIT_NOFILE &&
				new_rlim->rlim_max > sysctl_nr_open)
			return -EPERM;
	}

	/* Holding a refcount on tsk protects tsk->signal from disappearing. */
	rlim = tsk->signal->rlim + resource;
	task_lock(tsk->group_leader);
	if (new_rlim) {
		/*
		 * Keep the capable check against init_user_ns until cgroups can
		 * contain all limits.
		 */
		if (new_rlim->rlim_max > rlim->rlim_max &&
				!capable(CAP_SYS_RESOURCE))
			retval = -EPERM;
		if (!retval)
			retval = security_task_setrlimit(tsk, resource, new_rlim);
	}
	if (!retval) {
		if (old_rlim)
			*old_rlim = *rlim;
		if (new_rlim)
			*rlim = *new_rlim;
	}
	task_unlock(tsk->group_leader);

	/*
	 * RLIMIT_CPU handling. Arm the posix CPU timer if the limit is not
	 * infinite. In case of RLIM_INFINITY the posix CPU timer code
	 * ignores the rlimit.
	 */
	if (!retval && new_rlim && resource == RLIMIT_CPU &&
	    new_rlim->rlim_cur != RLIM_INFINITY &&
	    IS_ENABLED(CONFIG_POSIX_TIMERS)) {
		/*
		 * update_rlimit_cpu can fail if the task is exiting, but there
		 * may be other tasks in the thread group that are not exiting,
		 * and they need their cpu timers adjusted.
		 *
		 * The group_leader is the last task to be released, so if we
		 * cannot update_rlimit_cpu on it, then the entire process is
		 * exiting and we do not need to update at all.
		 */
		update_rlimit_cpu(tsk->group_leader, new_rlim->rlim_cur);
	}

	return retval;
}","static int do_prlimit(struct task_struct *VAR_0, unsigned int VAR_1,
		      struct rlimit *VAR_2, struct rlimit *VAR_3)
{
	struct rlimit *VAR_4;
	int VAR_5 = 0;

	if (VAR_1 >= VAR_6)
		return -VAR_7;
	VAR_1 = array_index_nospec(VAR_1, VAR_6);

	if (VAR_2) {
		if (VAR_2->rlim_cur > VAR_2->rlim_max)
			return -VAR_7;
		if (VAR_1 == VAR_8 &&
				VAR_2->rlim_max > VAR_9)
			return -VAR_10;
	}

	/* COMMENT_0 */
	VAR_4 = VAR_0->signal->rlim + VAR_1;
	task_lock(VAR_0->group_leader);
	if (VAR_2) {
		/* COMMENT_1 */
                                                                  
                        
     
		if (VAR_2->rlim_max > VAR_4->rlim_max &&
				!capable(VAR_11))
			VAR_5 = -VAR_10;
		if (!VAR_5)
			VAR_5 = security_task_setrlimit(VAR_0, VAR_1, VAR_2);
	}
	if (!VAR_5) {
		if (VAR_3)
			*VAR_3 = *VAR_4;
		if (VAR_2)
			*VAR_4 = *VAR_2;
	}
	task_unlock(VAR_0->group_leader);

	/* COMMENT_5 */
                                                                    
                                                               
                       
    
	if (!VAR_5 && VAR_2 && VAR_1 == VAR_12 &&
	    VAR_2->rlim_cur != VAR_13 &&
	    IS_ENABLED(VAR_14)) {
		/* COMMENT_10 */
                                                                 
                                                                 
                                             
    
                                                               
                                                               
                                                 
     
		update_rlimit_cpu(VAR_0->group_leader, VAR_2->rlim_cur);
	}

	return VAR_5;
}",torvalds/linux/739790605705ddcf18f21782b9c99ad7d53a8c11/sys.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,6 +6,8 @@
 
 	if (resource >= RLIM_NLIMITS)
 		return -EINVAL;
+	resource = array_index_nospec(resource, RLIM_NLIMITS);
+
 	if (new_rlim) {
 		if (new_rlim->rlim_cur > new_rlim->rlim_max)
 			return -EINVAL;","{'deleted_lines': [], 'added_lines': ['\tresource = array_index_nospec(resource, RLIM_NLIMITS);', '']}",True,A speculative pointer dereference problem exists in the Linux Kernel on the do_prlimit() function. The resource argument value is controlled and is used in pointer arithmetic for the 'rlim' variable and can be used to leak the contents. We recommend upgrading past version 6.1.8 or commit739790605705ddcf18f21782b9c99ad7d53a8c11,4.7,MEDIUM,1,test,2023-01-20T10:03:20Z,4
CVE-2023-32269,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"netrom: Fix use-after-free caused by accept on already connected socket

If you call listen() and accept() on an already connect()ed
AF_NETROM socket, accept() can successfully connect.
This is because when the peer socket sends data to sendmsg,
the skb with its own sk stored in the connected socket's
sk->sk_receive_queue is connected, and nr_accept() dequeues
the skb waiting in the sk->sk_receive_queue.

As a result, nr_accept() allocates and returns a sock with
the sk of the parent AF_NETROM socket.

And here use-after-free can happen through complex race conditions:
```
                  cpu0                                                     cpu1
                                                               1. socket_2 = socket(AF_NETROM)
                                                                        .
                                                                        .
                                                                  listen(socket_2)
                                                                  accepted_socket = accept(socket_2)
       2. socket_1 = socket(AF_NETROM)
            nr_create()    // sk refcount : 1
          connect(socket_1)
                                                               3. write(accepted_socket)
                                                                    nr_sendmsg()
                                                                    nr_output()
                                                                    nr_kick()
                                                                    nr_send_iframe()
                                                                    nr_transmit_buffer()
                                                                    nr_route_frame()
                                                                    nr_loopback_queue()
                                                                    nr_loopback_timer()
                                                                    nr_rx_frame()
                                                                    nr_process_rx_frame(sk, skb);    // sk : socket_1's sk
                                                                    nr_state3_machine()
                                                                    nr_queue_rx_frame()
                                                                    sock_queue_rcv_skb()
                                                                    sock_queue_rcv_skb_reason()
                                                                    __sock_queue_rcv_skb()
                                                                    __skb_queue_tail(list, skb);    // list : socket_1's sk->sk_receive_queue
       4. listen(socket_1)
            nr_listen()
          uaf_socket = accept(socket_1)
            nr_accept()
            skb_dequeue(&sk->sk_receive_queue);
                                                               5. close(accepted_socket)
                                                                    nr_release()
                                                                    nr_write_internal(sk, NR_DISCREQ)
                                                                    nr_transmit_buffer()    // NR_DISCREQ
                                                                    nr_route_frame()
                                                                    nr_loopback_queue()
                                                                    nr_loopback_timer()
                                                                    nr_rx_frame()    // sk : socket_1's sk
                                                                    nr_process_rx_frame()  // NR_STATE_3
                                                                    nr_state3_machine()    // NR_DISCREQ
                                                                    nr_disconnect()
                                                                    nr_sk(sk)->state = NR_STATE_0;
       6. close(socket_1)    // sk refcount : 3
            nr_release()    // NR_STATE_0
            sock_put(sk);    // sk refcount : 0
            sk_free(sk);
          close(uaf_socket)
            nr_release()
            sock_hold(sk);    // UAF
```

KASAN report by syzbot:
```
BUG: KASAN: use-after-free in nr_release+0x66/0x460 net/netrom/af_netrom.c:520
Write of size 4 at addr ffff8880235d8080 by task syz-executor564/5128

Call Trace:
 <TASK>
 __dump_stack lib/dump_stack.c:88 [inline]
 dump_stack_lvl+0xd1/0x138 lib/dump_stack.c:106
 print_address_description mm/kasan/report.c:306 [inline]
 print_report+0x15e/0x461 mm/kasan/report.c:417
 kasan_report+0xbf/0x1f0 mm/kasan/report.c:517
 check_region_inline mm/kasan/generic.c:183 [inline]
 kasan_check_range+0x141/0x190 mm/kasan/generic.c:189
 instrument_atomic_read_write include/linux/instrumented.h:102 [inline]
 atomic_fetch_add_relaxed include/linux/atomic/atomic-instrumented.h:116 [inline]
 __refcount_add include/linux/refcount.h:193 [inline]
 __refcount_inc include/linux/refcount.h:250 [inline]
 refcount_inc include/linux/refcount.h:267 [inline]
 sock_hold include/net/sock.h:775 [inline]
 nr_release+0x66/0x460 net/netrom/af_netrom.c:520
 __sock_release+0xcd/0x280 net/socket.c:650
 sock_close+0x1c/0x20 net/socket.c:1365
 __fput+0x27c/0xa90 fs/file_table.c:320
 task_work_run+0x16f/0x270 kernel/task_work.c:179
 exit_task_work include/linux/task_work.h:38 [inline]
 do_exit+0xaa8/0x2950 kernel/exit.c:867
 do_group_exit+0xd4/0x2a0 kernel/exit.c:1012
 get_signal+0x21c3/0x2450 kernel/signal.c:2859
 arch_do_signal_or_restart+0x79/0x5c0 arch/x86/kernel/signal.c:306
 exit_to_user_mode_loop kernel/entry/common.c:168 [inline]
 exit_to_user_mode_prepare+0x15f/0x250 kernel/entry/common.c:203
 __syscall_exit_to_user_mode_work kernel/entry/common.c:285 [inline]
 syscall_exit_to_user_mode+0x1d/0x50 kernel/entry/common.c:296
 do_syscall_64+0x46/0xb0 arch/x86/entry/common.c:86
 entry_SYSCALL_64_after_hwframe+0x63/0xcd
RIP: 0033:0x7f6c19e3c9b9
Code: Unable to access opcode bytes at 0x7f6c19e3c98f.
RSP: 002b:00007fffd4ba2ce8 EFLAGS: 00000246 ORIG_RAX: 0000000000000133
RAX: 0000000000000116 RBX: 0000000000000003 RCX: 00007f6c19e3c9b9
RDX: 0000000000000318 RSI: 00000000200bd000 RDI: 0000000000000006
RBP: 0000000000000003 R08: 000000000000000d R09: 000000000000000d
R10: 0000000000000000 R11: 0000000000000246 R12: 000055555566a2c0
R13: 0000000000000011 R14: 0000000000000000 R15: 0000000000000000
 </TASK>

Allocated by task 5128:
 kasan_save_stack+0x22/0x40 mm/kasan/common.c:45
 kasan_set_track+0x25/0x30 mm/kasan/common.c:52
 ____kasan_kmalloc mm/kasan/common.c:371 [inline]
 ____kasan_kmalloc mm/kasan/common.c:330 [inline]
 __kasan_kmalloc+0xa3/0xb0 mm/kasan/common.c:380
 kasan_kmalloc include/linux/kasan.h:211 [inline]
 __do_kmalloc_node mm/slab_common.c:968 [inline]
 __kmalloc+0x5a/0xd0 mm/slab_common.c:981
 kmalloc include/linux/slab.h:584 [inline]
 sk_prot_alloc+0x140/0x290 net/core/sock.c:2038
 sk_alloc+0x3a/0x7a0 net/core/sock.c:2091
 nr_create+0xb6/0x5f0 net/netrom/af_netrom.c:433
 __sock_create+0x359/0x790 net/socket.c:1515
 sock_create net/socket.c:1566 [inline]
 __sys_socket_create net/socket.c:1603 [inline]
 __sys_socket_create net/socket.c:1588 [inline]
 __sys_socket+0x133/0x250 net/socket.c:1636
 __do_sys_socket net/socket.c:1649 [inline]
 __se_sys_socket net/socket.c:1647 [inline]
 __x64_sys_socket+0x73/0xb0 net/socket.c:1647
 do_syscall_x64 arch/x86/entry/common.c:50 [inline]
 do_syscall_64+0x39/0xb0 arch/x86/entry/common.c:80
 entry_SYSCALL_64_after_hwframe+0x63/0xcd

Freed by task 5128:
 kasan_save_stack+0x22/0x40 mm/kasan/common.c:45
 kasan_set_track+0x25/0x30 mm/kasan/common.c:52
 kasan_save_free_info+0x2b/0x40 mm/kasan/generic.c:518
 ____kasan_slab_free mm/kasan/common.c:236 [inline]
 ____kasan_slab_free+0x13b/0x1a0 mm/kasan/common.c:200
 kasan_slab_free include/linux/kasan.h:177 [inline]
 __cache_free mm/slab.c:3394 [inline]
 __do_kmem_cache_free mm/slab.c:3580 [inline]
 __kmem_cache_free+0xcd/0x3b0 mm/slab.c:3587
 sk_prot_free net/core/sock.c:2074 [inline]
 __sk_destruct+0x5df/0x750 net/core/sock.c:2166
 sk_destruct net/core/sock.c:2181 [inline]
 __sk_free+0x175/0x460 net/core/sock.c:2192
 sk_free+0x7c/0xa0 net/core/sock.c:2203
 sock_put include/net/sock.h:1991 [inline]
 nr_release+0x39e/0x460 net/netrom/af_netrom.c:554
 __sock_release+0xcd/0x280 net/socket.c:650
 sock_close+0x1c/0x20 net/socket.c:1365
 __fput+0x27c/0xa90 fs/file_table.c:320
 task_work_run+0x16f/0x270 kernel/task_work.c:179
 exit_task_work include/linux/task_work.h:38 [inline]
 do_exit+0xaa8/0x2950 kernel/exit.c:867
 do_group_exit+0xd4/0x2a0 kernel/exit.c:1012
 get_signal+0x21c3/0x2450 kernel/signal.c:2859
 arch_do_signal_or_restart+0x79/0x5c0 arch/x86/kernel/signal.c:306
 exit_to_user_mode_loop kernel/entry/common.c:168 [inline]
 exit_to_user_mode_prepare+0x15f/0x250 kernel/entry/common.c:203
 __syscall_exit_to_user_mode_work kernel/entry/common.c:285 [inline]
 syscall_exit_to_user_mode+0x1d/0x50 kernel/entry/common.c:296
 do_syscall_64+0x46/0xb0 arch/x86/entry/common.c:86
 entry_SYSCALL_64_after_hwframe+0x63/0xcd
```

To fix this issue, nr_listen() returns -EINVAL for sockets that
successfully nr_connect().

Reported-by: syzbot+caa188bdfc1eeafeb418@syzkaller.appspotmail.com
Fixes: 1da177e4c3f4 (""Linux-2.6.12-rc2"")
Signed-off-by: Hyunwoo Kim <v4bel@theori.io>
Reviewed-by: Kuniyuki Iwashima <kuniyu@amazon.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",611792920925fb088ddccbe2783c7f92fdfb6b64,https://github.com/torvalds/linux/commit/611792920925fb088ddccbe2783c7f92fdfb6b64,net/netrom/af_netrom.c,nr_listen,"static int nr_listen(struct socket *sock, int backlog)
{
struct sock *sk = sock->sk;
lock_sock(sk);
if (sk->sk_state != TCP_LISTEN) {
memset(&nr_sk(sk)->user_addr, 0, AX25_ADDR_LEN);
sk->sk_max_ack_backlog = backlog;
sk->sk_state           = TCP_LISTEN;
release_sock(sk);
return 0;
}
release_sock(sk);
return -EOPNOTSUPP;
}","static int nr_listen(struct socket *VAR_0, int VAR_1)
{
struct sock *VAR_2 = sock->sk;
lock_sock(VAR_2);
if (VAR_2->sk_state != VAR_3) {
memset(&nr_sk(VAR_2)->user_addr, 0, VAR_4);
VAR_2->sk_max_ack_backlog = VAR_1;
VAR_2->sk_state           = VAR_3;
release_sock(VAR_2);
return 0;
}
release_sock(VAR_2);
return -VAR_5;
}",torvalds/linux/611792920925fb088ddccbe2783c7f92fdfb6b64/af_netrom.c/vul/before/0.json,"static int nr_listen(struct socket *sock, int backlog)
{
	struct sock *sk = sock->sk;

	lock_sock(sk);
	if (sock->state != SS_UNCONNECTED) {
		release_sock(sk);
		return -EINVAL;
	}

	if (sk->sk_state != TCP_LISTEN) {
		memset(&nr_sk(sk)->user_addr, 0, AX25_ADDR_LEN);
		sk->sk_max_ack_backlog = backlog;
		sk->sk_state           = TCP_LISTEN;
		release_sock(sk);
		return 0;
	}
	release_sock(sk);

	return -EOPNOTSUPP;
}","static int nr_listen(struct socket *VAR_0, int VAR_1)
{
	struct sock *VAR_2 = sock->sk;

	lock_sock(VAR_2);
	if (sock->state != VAR_3) {
		release_sock(VAR_2);
		return -VAR_4;
	}

	if (VAR_2->sk_state != VAR_5) {
		memset(&nr_sk(VAR_2)->user_addr, 0, VAR_6);
		VAR_2->sk_max_ack_backlog = VAR_1;
		VAR_2->sk_state           = VAR_5;
		release_sock(VAR_2);
		return 0;
	}
	release_sock(VAR_2);

	return -VAR_7;
}",torvalds/linux/611792920925fb088ddccbe2783c7f92fdfb6b64/af_netrom.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,6 +3,11 @@
 	struct sock *sk = sock->sk;
 
 	lock_sock(sk);
+	if (sock->state != SS_UNCONNECTED) {
+		release_sock(sk);
+		return -EINVAL;
+	}
+
 	if (sk->sk_state != TCP_LISTEN) {
 		memset(&nr_sk(sk)->user_addr, 0, AX25_ADDR_LEN);
 		sk->sk_max_ack_backlog = backlog;","{'deleted_lines': [], 'added_lines': ['\tif (sock->state != SS_UNCONNECTED) {', '\t\trelease_sock(sk);', '\t\treturn -EINVAL;', '\t}', '']}",True,"An issue was discovered in the Linux kernel before 6.1.11. In net/netrom/af_netrom.c, there is a use-after-free because accept is also allowed for a successfully connected AF_NETROM socket. However, in order for an attacker to exploit this, the system must have netrom routing configured or the attacker must have the CAP_NET_ADMIN capability.",6.7,MEDIUM,1,test,2023-01-27T02:32:50Z,4
CVE-2023-3161,['CWE-682'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"fbcon: Check font dimension limits

blit_x and blit_y are u32, so fbcon currently cannot support fonts
larger than 32x32.

The 32x32 case also needs shifting an unsigned int, to properly set bit
31, otherwise we get ""UBSAN: shift-out-of-bounds in fbcon_set_font"",
as reported on:

http://lore.kernel.org/all/IA1PR07MB98308653E259A6F2CE94A4AFABCE9@IA1PR07MB9830.namprd07.prod.outlook.com
Kernel Branch: 6.2.0-rc5-next-20230124
Kernel config: https://drive.google.com/file/d/1F-LszDAizEEH0ZX0HcSR06v5q8FPl2Uv/view?usp=sharing
Reproducer: https://drive.google.com/file/d/1mP1jcLBY7vWCNM60OMf-ogw-urQRjNrm/view?usp=sharing

Reported-by: Sanan Hasanov <sanan.hasanov@Knights.ucf.edu>
Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
Fixes: 2d2699d98492 (""fbcon: font setting should check limitation of driver"")
Cc: stable@vger.kernel.org
Tested-by: Miko Larsson <mikoxyzzz@gmail.com>
Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Helge Deller <deller@gmx.de>",2b09d5d364986f724f17001ccfe4126b9b43a0be,https://github.com/torvalds/linux/commit/2b09d5d364986f724f17001ccfe4126b9b43a0be,drivers/video/fbdev/core/fbcon.c,fbcon_set_font,"static int fbcon_set_font(struct vc_data *vc, struct console_font *font,
unsigned int flags)
{
struct fb_info *info = fbcon_info_from_console(vc->vc_num);
unsigned charcount = font->charcount;
int w = font->width;
int h = font->height;
int size;
int i, csum;
u8 *new_data, *data = font->data;
int pitch = PITCH(font->width);
if (charcount != 256 && charcount != 512)
return -EINVAL;
if (w > FBCON_SWAP(info->var.rotate, info->var.xres, info->var.yres) ||
h > FBCON_SWAP(info->var.rotate, info->var.yres, info->var.xres))
return -EINVAL;
if (!(info->pixmap.blit_x & (1 << (font->width - 1))) ||
!(info->pixmap.blit_y & (1 << (font->height - 1))))
return -EINVAL;
if (fbcon_invalid_charcount(info, charcount))
return -EINVAL;
size = CALC_FONTSZ(h, pitch, charcount);
new_data = kmalloc(FONT_EXTRA_WORDS * sizeof(int) + size, GFP_USER);
if (!new_data)
return -ENOMEM;
memset(new_data, 0, FONT_EXTRA_WORDS * sizeof(int));
new_data += FONT_EXTRA_WORDS * sizeof(int);
FNTSIZE(new_data) = size;
REFCOUNT(new_data) = 0;
for (i=0; i< charcount; i++) {
memcpy(new_data + i*h*pitch, data +  i*32*pitch, h*pitch);
}
csum = crc32(0, new_data, size);
FNTSUM(new_data) = csum;
for (i = first_fb_vc; i <= last_fb_vc; i++) {
struct vc_data *tmp = vc_cons[i].d;
if (fb_display[i].userfont &&
fb_display[i].fontdata &&
FNTSUM(fb_display[i].fontdata) == csum &&
FNTSIZE(fb_display[i].fontdata) == size &&
tmp->vc_font.width == w &&
!memcmp(fb_display[i].fontdata, new_data, size)) {
kfree(new_data - FONT_EXTRA_WORDS * sizeof(int));
new_data = (u8 *)fb_display[i].fontdata;
break;
}
}
return fbcon_do_set_font(vc, font->width, font->height, charcount, new_data, 1);
}","static int fbcon_set_font(struct vc_data *VAR_0, struct console_font *VAR_1,
unsigned int VAR_2)
{
struct fb_info *VAR_3 = fbcon_info_from_console(VAR_0->vc_num);
unsigned VAR_4 = VAR_1->charcount;
int VAR_5 = VAR_1->width;
int VAR_6 = VAR_1->height;
int VAR_7;
int VAR_8, VAR_9;
u8 *VAR_10, *VAR_11 = VAR_1->data;
int VAR_12 = PITCH(VAR_1->width);
if (VAR_4 != 256 && VAR_4 != 512)
return -VAR_13;
if (VAR_5 > FBCON_SWAP(VAR_3->var.rotate, VAR_3->var.xres, VAR_3->var.yres) ||
VAR_6 > FBCON_SWAP(VAR_3->var.rotate, VAR_3->var.yres, VAR_3->var.xres))
return -VAR_13;
if (!(VAR_3->pixmap.blit_x & (1 << (VAR_1->width - 1))) ||
!(VAR_3->pixmap.blit_y & (1 << (VAR_1->height - 1))))
return -VAR_13;
if (fbcon_invalid_charcount(VAR_3, VAR_4))
return -VAR_13;
VAR_7 = CALC_FONTSZ(VAR_6, VAR_12, VAR_4);
VAR_10 = kmalloc(VAR_14 * sizeof(int) + VAR_7, VAR_15);
if (!VAR_10)
return -VAR_16;
memset(VAR_10, 0, VAR_14 * sizeof(int));
VAR_10 += VAR_14 * sizeof(int);
FNTSIZE(VAR_10) = VAR_7;
REFCOUNT(VAR_10) = 0;
for (VAR_8=0; VAR_8< VAR_4; VAR_8++) {
memcpy(VAR_10 + VAR_8*VAR_6*VAR_12, VAR_11 +  VAR_8*32*VAR_12, VAR_6*VAR_12);
}
VAR_9 = crc32(0, VAR_10, VAR_7);
FNTSUM(VAR_10) = VAR_9;
for (VAR_8 = VAR_17; VAR_8 <= VAR_18; VAR_8++) {
struct vc_data *VAR_19 = VAR_20[VAR_8].d;
if (VAR_21[VAR_8].userfont &&
VAR_21[VAR_8].fontdata &&
FNTSUM(VAR_21[VAR_8].fontdata) == VAR_9 &&
FNTSIZE(VAR_21[VAR_8].fontdata) == VAR_7 &&
VAR_19->vc_font.width == VAR_5 &&
!memcmp(VAR_21[VAR_8].fontdata, VAR_10, VAR_7)) {
kfree(VAR_10 - VAR_14 * sizeof(int));
VAR_10 = (u8 *)VAR_21[VAR_8].fontdata;
break;
}
}
return fbcon_do_set_font(VAR_0, VAR_1->width, VAR_1->height, VAR_4, VAR_10, 1);
}",torvalds/linux/2b09d5d364986f724f17001ccfe4126b9b43a0be/fbcon.c/vul/before/0.json,"static int fbcon_set_font(struct vc_data *vc, struct console_font *font,
			  unsigned int flags)
{
	struct fb_info *info = fbcon_info_from_console(vc->vc_num);
	unsigned charcount = font->charcount;
	int w = font->width;
	int h = font->height;
	int size;
	int i, csum;
	u8 *new_data, *data = font->data;
	int pitch = PITCH(font->width);

	/* Is there a reason why fbconsole couldn't handle any charcount >256?
	 * If not this check should be changed to charcount < 256 */
	if (charcount != 256 && charcount != 512)
		return -EINVAL;

	/* font bigger than screen resolution ? */
	if (w > FBCON_SWAP(info->var.rotate, info->var.xres, info->var.yres) ||
	    h > FBCON_SWAP(info->var.rotate, info->var.yres, info->var.xres))
		return -EINVAL;

	if (font->width > 32 || font->height > 32)
		return -EINVAL;

	/* Make sure drawing engine can handle the font */
	if (!(info->pixmap.blit_x & BIT(font->width - 1)) ||
	    !(info->pixmap.blit_y & BIT(font->height - 1)))
		return -EINVAL;

	/* Make sure driver can handle the font length */
	if (fbcon_invalid_charcount(info, charcount))
		return -EINVAL;

	size = CALC_FONTSZ(h, pitch, charcount);

	new_data = kmalloc(FONT_EXTRA_WORDS * sizeof(int) + size, GFP_USER);

	if (!new_data)
		return -ENOMEM;

	memset(new_data, 0, FONT_EXTRA_WORDS * sizeof(int));

	new_data += FONT_EXTRA_WORDS * sizeof(int);
	FNTSIZE(new_data) = size;
	REFCOUNT(new_data) = 0;	/* usage counter */
	for (i=0; i< charcount; i++) {
		memcpy(new_data + i*h*pitch, data +  i*32*pitch, h*pitch);
	}

	/* Since linux has a nice crc32 function use it for counting font
	 * checksums. */
	csum = crc32(0, new_data, size);

	FNTSUM(new_data) = csum;
	/* Check if the same font is on some other console already */
	for (i = first_fb_vc; i <= last_fb_vc; i++) {
		struct vc_data *tmp = vc_cons[i].d;
		
		if (fb_display[i].userfont &&
		    fb_display[i].fontdata &&
		    FNTSUM(fb_display[i].fontdata) == csum &&
		    FNTSIZE(fb_display[i].fontdata) == size &&
		    tmp->vc_font.width == w &&
		    !memcmp(fb_display[i].fontdata, new_data, size)) {
			kfree(new_data - FONT_EXTRA_WORDS * sizeof(int));
			new_data = (u8 *)fb_display[i].fontdata;
			break;
		}
	}
	return fbcon_do_set_font(vc, font->width, font->height, charcount, new_data, 1);
}","static int fbcon_set_font(struct vc_data *VAR_0, struct console_font *VAR_1,
			  unsigned int VAR_2)
{
	struct fb_info *VAR_3 = fbcon_info_from_console(VAR_0->vc_num);
	unsigned VAR_4 = VAR_1->charcount;
	int VAR_5 = VAR_1->width;
	int VAR_6 = VAR_1->height;
	int VAR_7;
	int VAR_8, VAR_9;
	u8 *VAR_10, *VAR_11 = VAR_1->data;
	int VAR_12 = PITCH(VAR_1->width);

	/* COMMENT_0 */
                                                             
	if (VAR_4 != 256 && VAR_4 != 512)
		return -VAR_13;

	/* COMMENT_2 */
	if (VAR_5 > FBCON_SWAP(VAR_3->var.rotate, VAR_3->var.xres, VAR_3->var.yres) ||
	    VAR_6 > FBCON_SWAP(VAR_3->var.rotate, VAR_3->var.yres, VAR_3->var.xres))
		return -VAR_13;

	if (VAR_1->width > 32 || VAR_1->height > 32)
		return -VAR_13;

	/* COMMENT_3 */
	if (!(VAR_3->pixmap.blit_x & BIT(VAR_1->width - 1)) ||
	    !(VAR_3->pixmap.blit_y & BIT(VAR_1->height - 1)))
		return -VAR_13;

	/* COMMENT_4 */
	if (fbcon_invalid_charcount(VAR_3, VAR_4))
		return -VAR_13;

	VAR_7 = CALC_FONTSZ(VAR_6, VAR_12, VAR_4);

	VAR_10 = kmalloc(VAR_14 * sizeof(int) + VAR_7, VAR_15);

	if (!VAR_10)
		return -VAR_16;

	memset(VAR_10, 0, VAR_14 * sizeof(int));

	VAR_10 += VAR_14 * sizeof(int);
	FNTSIZE(VAR_10) = VAR_7;
	REFCOUNT(VAR_10) = 0;	/* COMMENT_5 */
	for (VAR_8=0; VAR_8< VAR_4; VAR_8++) {
		memcpy(VAR_10 + VAR_8*VAR_6*VAR_12, VAR_11 +  VAR_8*32*VAR_12, VAR_6*VAR_12);
	}

	/* COMMENT_6 */
                 
	VAR_9 = crc32(0, VAR_10, VAR_7);

	FNTSUM(VAR_10) = VAR_9;
	/* COMMENT_8 */
	for (VAR_8 = VAR_17; VAR_8 <= VAR_18; VAR_8++) {
		struct vc_data *VAR_19 = VAR_20[VAR_8].d;
		
		if (VAR_21[VAR_8].userfont &&
		    VAR_21[VAR_8].fontdata &&
		    FNTSUM(VAR_21[VAR_8].fontdata) == VAR_9 &&
		    FNTSIZE(VAR_21[VAR_8].fontdata) == VAR_7 &&
		    VAR_19->vc_font.width == VAR_5 &&
		    !memcmp(VAR_21[VAR_8].fontdata, VAR_10, VAR_7)) {
			kfree(VAR_10 - VAR_14 * sizeof(int));
			VAR_10 = (u8 *)VAR_21[VAR_8].fontdata;
			break;
		}
	}
	return fbcon_do_set_font(VAR_0, VAR_1->width, VAR_1->height, VAR_4, VAR_10, 1);
}",torvalds/linux/2b09d5d364986f724f17001ccfe4126b9b43a0be/fbcon.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -20,9 +20,12 @@
 	    h > FBCON_SWAP(info->var.rotate, info->var.yres, info->var.xres))
 		return -EINVAL;
 
+	if (font->width > 32 || font->height > 32)
+		return -EINVAL;
+
 	/* Make sure drawing engine can handle the font */
-	if (!(info->pixmap.blit_x & (1 << (font->width - 1))) ||
-	    !(info->pixmap.blit_y & (1 << (font->height - 1))))
+	if (!(info->pixmap.blit_x & BIT(font->width - 1)) ||
+	    !(info->pixmap.blit_y & BIT(font->height - 1)))
 		return -EINVAL;
 
 	/* Make sure driver can handle the font length */","{'deleted_lines': ['\tif (!(info->pixmap.blit_x & (1 << (font->width - 1))) ||', '\t    !(info->pixmap.blit_y & (1 << (font->height - 1))))'], 'added_lines': ['\tif (font->width > 32 || font->height > 32)', '\t\treturn -EINVAL;', '', '\tif (!(info->pixmap.blit_x & BIT(font->width - 1)) ||', '\t    !(info->pixmap.blit_y & BIT(font->height - 1)))']}",True,"A flaw was found in the Framebuffer Console (fbcon) in the Linux Kernel. When providing font->width and font->height greater than 32 to fbcon_set_font, since there are no checks in place, a shift-out-of-bounds occurs leading to undefined behavior and possible denial of service.",5.5,MEDIUM,1,test,2023-01-29T15:17:40Z,4
CVE-2023-25149,['CWE-269'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,timescale/timescaledb,Lock down search_path in SPI calls,014b40fb7e8d59087cf1c1988a68dd1979f86cb3,https://github.com/timescale/timescaledb/commit/014b40fb7e8d59087cf1c1988a68dd1979f86cb3,tsl/src/reorder.c,tsl_subscription_exec,"Datum
tsl_subscription_exec(PG_FUNCTION_ARGS)
{
Oid save_userid;
int save_sec_context;
const char *subscription_cmd = PG_ARGISNULL(0) ? NULL : text_to_cstring(PG_GETARG_TEXT_P(0));
int res;
List *parsetree_list;
ListCell *parsetree_item;
if (!subscription_cmd)
PG_RETURN_VOID();
if (!superuser() && !has_rolreplication(GetUserId()))
ereport(ERROR,
(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),
(errmsg(""must be superuser or replication role to use this function""))));
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(BOOTSTRAP_SUPERUSERID, save_sec_context | SECURITY_LOCAL_USERID_CHANGE);
parsetree_list = pg_parse_query(subscription_cmd);
foreach (parsetree_item, parsetree_list)
{
RawStmt *parsetree = lfirst_node(RawStmt, parsetree_item);
switch (nodeTag(parsetree->stmt))
{
case T_CreateSubscriptionStmt:
break;
case T_AlterSubscriptionStmt:
break;
case T_DropSubscriptionStmt:
break;
default:
ereport(ERROR,
(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
errmsg(""this function only accepts SUBSCRIPTION commands"")));
}
}
if (SPI_connect() != SPI_OK_CONNECT)
elog(ERROR, ""could not connect to SPI"");
res = SPI_execute(subscription_cmd, false , 0 );
if (res < 0)
ereport(ERROR,
(errcode(ERRCODE_INTERNAL_ERROR),
(errmsg(""error in subscription cmd \""%s\"""", subscription_cmd))));
if ((res = SPI_finish()) != SPI_OK_FINISH)
elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(res));
SetUserIdAndSecContext(save_userid, save_sec_context);
PG_RETURN_VOID();
}","Datum
tsl_subscription_exec(PG_FUNCTION_ARGS)
{
Oid VAR_0;
int VAR_1;
const char *VAR_2 = PG_ARGISNULL(0) ? NULL : text_to_cstring(PG_GETARG_TEXT_P(0));
int VAR_3;
List *VAR_4;
ListCell *VAR_5;
if (!VAR_2)
PG_RETURN_VOID();
if (!superuser() && !has_rolreplication(GetUserId()))
ereport(VAR_6,
(errcode(VAR_7),
(errmsg(""must be superuser or replication role to use this function""))));
GetUserIdAndSecContext(&VAR_0, &VAR_1);
SetUserIdAndSecContext(VAR_8, VAR_1 | VAR_9);
VAR_4 = pg_parse_query(VAR_2);
foreach (VAR_5, VAR_4)
{
RawStmt *VAR_10 = lfirst_node(RawStmt, VAR_5);
switch (nodeTag(VAR_10->stmt))
{
case VAR_11:
break;
case VAR_12:
break;
case VAR_13:
break;
default:
ereport(VAR_6,
(errcode(VAR_14),
errmsg(""this function only accepts SUBSCRIPTION commands"")));
}
}
if (SPI_connect() != VAR_15)
elog(VAR_6, ""could not connect to SPI"");
VAR_3 = SPI_execute(VAR_2, false , 0 );
if (VAR_3 < 0)
ereport(VAR_6,
(errcode(VAR_16),
(errmsg(""error in subscription cmd \""%s\"""", VAR_2))));
if ((VAR_3 = SPI_finish()) != VAR_17)
elog(VAR_6, ""SPI_finish failed: %s"", SPI_result_code_string(VAR_3));
SetUserIdAndSecContext(VAR_0, VAR_1);
PG_RETURN_VOID();
}",timescale/timescaledb/014b40fb7e8d59087cf1c1988a68dd1979f86cb3/reorder.c/vul/before/0.json,"Datum
tsl_subscription_exec(PG_FUNCTION_ARGS)
{
	Oid save_userid;
	int save_sec_context;
	const char *subscription_cmd = PG_ARGISNULL(0) ? NULL : text_to_cstring(PG_GETARG_TEXT_P(0));
	int res;
	List *parsetree_list;
	ListCell *parsetree_item;

	if (!subscription_cmd)
		PG_RETURN_VOID();

	/*
	 * Subscription command needs a superuser
	 * so switch to that context. But first check that the passed in user has atleast
	 * REPLICATION privileges to justify the use of this function
	 */
	if (!superuser() && !has_rolreplication(GetUserId()))
		ereport(ERROR,
				(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),
				 (errmsg(""must be superuser or replication role to use this function""))));

	GetUserIdAndSecContext(&save_userid, &save_sec_context);
	SetUserIdAndSecContext(BOOTSTRAP_SUPERUSERID, save_sec_context | SECURITY_LOCAL_USERID_CHANGE);

	/*
	 * Parse the SQL string into a list of raw parse trees.
	 */
	parsetree_list = pg_parse_query(subscription_cmd);

	/*
	 * Check that we have received a ""SUBSCRIPTION"" related command only. Anything else
	 * needs to error out
	 */
	foreach (parsetree_item, parsetree_list)
	{
		RawStmt *parsetree = lfirst_node(RawStmt, parsetree_item);

		/* We are only interested in ""CREATE/DROP SUBSCRIPTION"" and ""ALTER SUBSCRIPTION"" stmts */
		switch (nodeTag(parsetree->stmt))
		{
			case T_CreateSubscriptionStmt:
				break;

			case T_AlterSubscriptionStmt:
				break;

			case T_DropSubscriptionStmt:
				break;

			default:
				ereport(ERROR,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						 errmsg(""this function only accepts SUBSCRIPTION commands"")));
		}
	}

	if (SPI_connect() != SPI_OK_CONNECT)
		elog(ERROR, ""could not connect to SPI"");

	/* Lock down search_path */
	res = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
	if (res < 0)
		ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));

	res = SPI_execute(subscription_cmd, false /* read_only */, 0 /*count*/);

	if (res < 0)
		ereport(ERROR,
				(errcode(ERRCODE_INTERNAL_ERROR),
				 (errmsg(""error in subscription cmd \""%s\"""", subscription_cmd))));

	if ((res = SPI_finish()) != SPI_OK_FINISH)
		elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(res));

	/* Restore the earlier user */
	SetUserIdAndSecContext(save_userid, save_sec_context);

	PG_RETURN_VOID();
}","Datum
tsl_subscription_exec(PG_FUNCTION_ARGS)
{
	Oid VAR_0;
	int VAR_1;
	const char *VAR_2 = PG_ARGISNULL(0) ? NULL : text_to_cstring(PG_GETARG_TEXT_P(0));
	int VAR_3;
	List *VAR_4;
	ListCell *VAR_5;

	if (!VAR_2)
		PG_RETURN_VOID();

	/* COMMENT_0 */
                                          
                                                                                  
                                                              
    
	if (!superuser() && !has_rolreplication(GetUserId()))
		ereport(VAR_6,
				(errcode(VAR_7),
				 (errmsg(""must be superuser or replication role to use this function""))));

	GetUserIdAndSecContext(&VAR_0, &VAR_1);
	SetUserIdAndSecContext(VAR_8, VAR_1 | VAR_9);

	/* COMMENT_5 */
                                                        
    
	VAR_4 = pg_parse_query(VAR_2);

	/* COMMENT_8 */
                                                                                    
                      
    
	foreach (VAR_5, VAR_4)
	{
		RawStmt *VAR_10 = lfirst_node(RawStmt, VAR_5);

		/* COMMENT_12 */
		switch (nodeTag(VAR_10->stmt))
		{
			case VAR_11:
				break;

			case VAR_12:
				break;

			case VAR_13:
				break;

			default:
				ereport(VAR_6,
						(errcode(VAR_14),
						 errmsg(""this function only accepts SUBSCRIPTION commands"")));
		}
	}

	if (SPI_connect() != VAR_15)
		elog(VAR_6, ""could not connect to SPI"");

	/* COMMENT_13 */
	VAR_3 = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
	if (VAR_3 < 0)
		ereport(VAR_6, (errcode(VAR_16), (errmsg(""could not set search_path""))));

	VAR_3 = SPI_execute(VAR_2, false /* COMMENT_14 */, 0 /* COMMENT_15 */);

	if (VAR_3 < 0)
		ereport(VAR_6,
				(errcode(VAR_16),
				 (errmsg(""error in subscription cmd \""%s\"""", VAR_2))));

	if ((VAR_3 = SPI_finish()) != VAR_17)
		elog(VAR_6, ""SPI_finish failed: %s"", SPI_result_code_string(VAR_3));

	/* COMMENT_16 */
	SetUserIdAndSecContext(VAR_0, VAR_1);

	PG_RETURN_VOID();
}",timescale/timescaledb/014b40fb7e8d59087cf1c1988a68dd1979f86cb3/reorder.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -59,6 +59,11 @@
 	if (SPI_connect() != SPI_OK_CONNECT)
 		elog(ERROR, ""could not connect to SPI"");
 
+	/* Lock down search_path */
+	res = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
+	if (res < 0)
+		ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));
+
 	res = SPI_execute(subscription_cmd, false /* read_only */, 0 /*count*/);
 
 	if (res < 0)","{'deleted_lines': [], 'added_lines': ['\t/* Lock down search_path */', '\tres = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);', '\tif (res < 0)', '\t\tereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));', '']}",True,"TimescaleDB, an open-source time-series SQL database, has a privilege escalation vulnerability in versions 2.8.0 through 2.9.2. During installation, TimescaleDB creates a telemetry job that is runs as the installation user. The queries run as part of the telemetry data collection were not run with a locked down `search_path`, allowing malicious users to create functions that would be executed by the telemetry job, leading to privilege escalation. In order to be able to take advantage of this vulnerability, a user would need to be able to create objects in a database and then get a superuser to install TimescaleDB into their database. When TimescaleDB is installed as trusted extension, non-superusers can install the extension without help from a superuser.

Version 2.9.3 fixes this issue. As a mitigation, the `search_path` of the user running the telemetry job can be locked down to not include schemas writable by other users. The vulnerability is not exploitable on instances in Timescale Cloud and Managed Service for TimescaleDB due to additional security provisions in place on those platforms.",8.8,HIGH,2,test,2023-01-31T12:59:48Z,4
CVE-2023-25149,['CWE-269'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,timescale/timescaledb,Lock down search_path in SPI calls,014b40fb7e8d59087cf1c1988a68dd1979f86cb3,https://github.com/timescale/timescaledb/commit/014b40fb7e8d59087cf1c1988a68dd1979f86cb3,tsl/src/reorder.c,tsl_copy_chunk_cleanup_proc,"Datum
tsl_copy_chunk_cleanup_proc(PG_FUNCTION_ARGS)
{
const char *operation_id = PG_ARGISNULL(0) ? NULL : NameStr(*PG_GETARG_NAME(0));
int rc;
bool nonatomic = fcinfo->context && IsA(fcinfo->context, CallContext) &&
!castNode(CallContext, fcinfo->context)->atomic;
TS_PREVENT_FUNC_IF_READ_ONLY();
PreventInTransactionBlock(true, get_func_name(FC_FN_OID(fcinfo)));
if (operation_id == NULL)
ereport(ERROR,
(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
errmsg(""invalid chunk copy operation id"")));
if ((rc = SPI_connect_ext(nonatomic ? SPI_OPT_NONATOMIC : 0)) != SPI_OK_CONNECT)
elog(ERROR, ""SPI_connect failed: %s"", SPI_result_code_string(rc));
chunk_copy_cleanup(operation_id);
if ((rc = SPI_finish()) != SPI_OK_FINISH)
elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(rc));
PG_RETURN_VOID();
}","Datum
tsl_copy_chunk_cleanup_proc(PG_FUNCTION_ARGS)
{
const char *VAR_0 = PG_ARGISNULL(0) ? NULL : NameStr(*PG_GETARG_NAME(0));
int VAR_1;
bool VAR_2 = VAR_3->context && IsA(VAR_3->context, VAR_4) &&
!castNode(VAR_4, VAR_3->context)->atomic;
TS_PREVENT_FUNC_IF_READ_ONLY();
PreventInTransactionBlock(true, get_func_name(FC_FN_OID(VAR_3)));
if (VAR_0 == NULL)
ereport(VAR_5,
(errcode(VAR_6),
errmsg(""invalid chunk copy operation id"")));
if ((VAR_1 = SPI_connect_ext(VAR_2 ? VAR_7 : 0)) != VAR_8)
elog(VAR_5, ""SPI_connect failed: %s"", SPI_result_code_string(VAR_1));
chunk_copy_cleanup(VAR_0);
if ((VAR_1 = SPI_finish()) != VAR_9)
elog(VAR_5, ""SPI_finish failed: %s"", SPI_result_code_string(VAR_1));
PG_RETURN_VOID();
}",timescale/timescaledb/014b40fb7e8d59087cf1c1988a68dd1979f86cb3/reorder.c/vul/before/1.json,"Datum
tsl_copy_chunk_cleanup_proc(PG_FUNCTION_ARGS)
{
	const char *operation_id = PG_ARGISNULL(0) ? NULL : NameStr(*PG_GETARG_NAME(0));
	int rc;
	bool nonatomic = fcinfo->context && IsA(fcinfo->context, CallContext) &&
					 !castNode(CallContext, fcinfo->context)->atomic;

	TS_PREVENT_FUNC_IF_READ_ONLY();

	PreventInTransactionBlock(true, get_func_name(FC_FN_OID(fcinfo)));

	/* valid input has to be provided */
	if (operation_id == NULL)
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				 errmsg(""invalid chunk copy operation id"")));

	if ((rc = SPI_connect_ext(nonatomic ? SPI_OPT_NONATOMIC : 0)) != SPI_OK_CONNECT)
		elog(ERROR, ""SPI_connect failed: %s"", SPI_result_code_string(rc));

	/* Lock down search_path */
	rc = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
	if (rc < 0)
		ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));

	/* perform the cleanup/repair depending on the stage */
	chunk_copy_cleanup(operation_id);

	if ((rc = SPI_finish()) != SPI_OK_FINISH)
		elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(rc));

	PG_RETURN_VOID();
}","Datum
tsl_copy_chunk_cleanup_proc(PG_FUNCTION_ARGS)
{
	const char *VAR_0 = PG_ARGISNULL(0) ? NULL : NameStr(*PG_GETARG_NAME(0));
	int VAR_1;
	bool VAR_2 = VAR_3->context && IsA(VAR_3->context, VAR_4) &&
					 !castNode(VAR_4, VAR_3->context)->atomic;

	TS_PREVENT_FUNC_IF_READ_ONLY();

	PreventInTransactionBlock(true, get_func_name(FC_FN_OID(VAR_3)));

	/* COMMENT_0 */
	if (VAR_0 == NULL)
		ereport(VAR_5,
				(errcode(VAR_6),
				 errmsg(""invalid chunk copy operation id"")));

	if ((VAR_1 = SPI_connect_ext(VAR_2 ? VAR_7 : 0)) != VAR_8)
		elog(VAR_5, ""SPI_connect failed: %s"", SPI_result_code_string(VAR_1));

	/* COMMENT_1 */
	VAR_1 = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
	if (VAR_1 < 0)
		ereport(VAR_5, (errcode(VAR_9), (errmsg(""could not set search_path""))));

	/* COMMENT_2 */
	chunk_copy_cleanup(VAR_0);

	if ((VAR_1 = SPI_finish()) != VAR_10)
		elog(VAR_5, ""SPI_finish failed: %s"", SPI_result_code_string(VAR_1));

	PG_RETURN_VOID();
}",timescale/timescaledb/014b40fb7e8d59087cf1c1988a68dd1979f86cb3/reorder.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -19,6 +19,11 @@
 	if ((rc = SPI_connect_ext(nonatomic ? SPI_OPT_NONATOMIC : 0)) != SPI_OK_CONNECT)
 		elog(ERROR, ""SPI_connect failed: %s"", SPI_result_code_string(rc));
 
+	/* Lock down search_path */
+	rc = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
+	if (rc < 0)
+		ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));
+
 	/* perform the cleanup/repair depending on the stage */
 	chunk_copy_cleanup(operation_id);
 ","{'deleted_lines': [], 'added_lines': ['\t/* Lock down search_path */', '\trc = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);', '\tif (rc < 0)', '\t\tereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));', '']}",True,"TimescaleDB, an open-source time-series SQL database, has a privilege escalation vulnerability in versions 2.8.0 through 2.9.2. During installation, TimescaleDB creates a telemetry job that is runs as the installation user. The queries run as part of the telemetry data collection were not run with a locked down `search_path`, allowing malicious users to create functions that would be executed by the telemetry job, leading to privilege escalation. In order to be able to take advantage of this vulnerability, a user would need to be able to create objects in a database and then get a superuser to install TimescaleDB into their database. When TimescaleDB is installed as trusted extension, non-superusers can install the extension without help from a superuser.

Version 2.9.3 fixes this issue. As a mitigation, the `search_path` of the user running the telemetry job can be locked down to not include schemas writable by other users. The vulnerability is not exploitable on instances in Timescale Cloud and Managed Service for TimescaleDB due to additional security provisions in place on those platforms.",8.8,HIGH,2,test,2023-01-31T12:59:48Z,4
CVE-2023-25149,['CWE-269'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,timescale/timescaledb,Lock down search_path in SPI calls,014b40fb7e8d59087cf1c1988a68dd1979f86cb3,https://github.com/timescale/timescaledb/commit/014b40fb7e8d59087cf1c1988a68dd1979f86cb3,tsl/src/reorder.c,tsl_copy_or_move_chunk_proc,"static void
tsl_copy_or_move_chunk_proc(FunctionCallInfo fcinfo, bool delete_on_src_node)
{
Oid chunk_id = PG_ARGISNULL(0) ? InvalidOid : PG_GETARG_OID(0);
const char *src_node_name = PG_ARGISNULL(1) ? NULL : NameStr(*PG_GETARG_NAME(1));
const char *dst_node_name = PG_ARGISNULL(2) ? NULL : NameStr(*PG_GETARG_NAME(2));
const char *op_id = PG_ARGISNULL(3) ? NULL : NameStr(*PG_GETARG_NAME(3));
int rc;
bool nonatomic = fcinfo->context && IsA(fcinfo->context, CallContext) &&
!castNode(CallContext, fcinfo->context)->atomic;
TS_PREVENT_FUNC_IF_READ_ONLY();
PreventInTransactionBlock(true, get_func_name(FC_FN_OID(fcinfo)));
if (src_node_name == NULL || dst_node_name == NULL)
ereport(ERROR,
(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
errmsg(""invalid source or destination node"")));
if (!OidIsValid(chunk_id))
ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg(""invalid chunk"")));
if ((rc = SPI_connect_ext(nonatomic ? SPI_OPT_NONATOMIC : 0)) != SPI_OK_CONNECT)
elog(ERROR, ""SPI_connect failed: %s"", SPI_result_code_string(rc));
chunk_copy(chunk_id, src_node_name, dst_node_name, op_id, delete_on_src_node);
if ((rc = SPI_finish()) != SPI_OK_FINISH)
elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(rc));
}","static void
tsl_copy_or_move_chunk_proc(FunctionCallInfo VAR_0, bool VAR_1)
{
Oid VAR_2 = PG_ARGISNULL(0) ? VAR_3 : PG_GETARG_OID(0);
const char *VAR_4 = PG_ARGISNULL(1) ? NULL : NameStr(*PG_GETARG_NAME(1));
const char *VAR_5 = PG_ARGISNULL(2) ? NULL : NameStr(*PG_GETARG_NAME(2));
const char *VAR_6 = PG_ARGISNULL(3) ? NULL : NameStr(*PG_GETARG_NAME(3));
int VAR_7;
bool VAR_8 = VAR_0->context && IsA(VAR_0->context, VAR_9) &&
!castNode(VAR_9, VAR_0->context)->atomic;
TS_PREVENT_FUNC_IF_READ_ONLY();
PreventInTransactionBlock(true, get_func_name(FC_FN_OID(VAR_0)));
if (VAR_4 == NULL || VAR_5 == NULL)
ereport(VAR_10,
(errcode(VAR_11),
errmsg(""invalid source or destination node"")));
if (!OidIsValid(VAR_2))
ereport(VAR_10, (errcode(VAR_11), errmsg(""invalid chunk"")));
if ((VAR_7 = SPI_connect_ext(VAR_8 ? VAR_12 : 0)) != VAR_13)
elog(VAR_10, ""SPI_connect failed: %s"", SPI_result_code_string(VAR_7));
chunk_copy(VAR_2, VAR_4, VAR_5, VAR_6, VAR_1);
if ((VAR_7 = SPI_finish()) != VAR_14)
elog(VAR_10, ""SPI_finish failed: %s"", SPI_result_code_string(VAR_7));
}",timescale/timescaledb/014b40fb7e8d59087cf1c1988a68dd1979f86cb3/reorder.c/vul/before/2.json,"static void
tsl_copy_or_move_chunk_proc(FunctionCallInfo fcinfo, bool delete_on_src_node)
{
	Oid chunk_id = PG_ARGISNULL(0) ? InvalidOid : PG_GETARG_OID(0);
	const char *src_node_name = PG_ARGISNULL(1) ? NULL : NameStr(*PG_GETARG_NAME(1));
	const char *dst_node_name = PG_ARGISNULL(2) ? NULL : NameStr(*PG_GETARG_NAME(2));
	const char *op_id = PG_ARGISNULL(3) ? NULL : NameStr(*PG_GETARG_NAME(3));
	int rc;
	bool nonatomic = fcinfo->context && IsA(fcinfo->context, CallContext) &&
					 !castNode(CallContext, fcinfo->context)->atomic;

	TS_PREVENT_FUNC_IF_READ_ONLY();

	PreventInTransactionBlock(true, get_func_name(FC_FN_OID(fcinfo)));

	/* src_node and dst_node both have to be non-NULL */
	if (src_node_name == NULL || dst_node_name == NULL)
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				 errmsg(""invalid source or destination node"")));

	if (!OidIsValid(chunk_id))
		ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg(""invalid chunk"")));

	if ((rc = SPI_connect_ext(nonatomic ? SPI_OPT_NONATOMIC : 0)) != SPI_OK_CONNECT)
		elog(ERROR, ""SPI_connect failed: %s"", SPI_result_code_string(rc));

	/* Lock down search_path */
	rc = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
	if (rc < 0)
		ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));

	/* perform the actual distributed chunk move after a few sanity checks */
	chunk_copy(chunk_id, src_node_name, dst_node_name, op_id, delete_on_src_node);

	if ((rc = SPI_finish()) != SPI_OK_FINISH)
		elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(rc));
}","static void
tsl_copy_or_move_chunk_proc(FunctionCallInfo VAR_0, bool VAR_1)
{
	Oid VAR_2 = PG_ARGISNULL(0) ? VAR_3 : PG_GETARG_OID(0);
	const char *VAR_4 = PG_ARGISNULL(1) ? NULL : NameStr(*PG_GETARG_NAME(1));
	const char *VAR_5 = PG_ARGISNULL(2) ? NULL : NameStr(*PG_GETARG_NAME(2));
	const char *VAR_6 = PG_ARGISNULL(3) ? NULL : NameStr(*PG_GETARG_NAME(3));
	int VAR_7;
	bool VAR_8 = VAR_0->context && IsA(VAR_0->context, VAR_9) &&
					 !castNode(VAR_9, VAR_0->context)->atomic;

	TS_PREVENT_FUNC_IF_READ_ONLY();

	PreventInTransactionBlock(true, get_func_name(FC_FN_OID(VAR_0)));

	/* COMMENT_0 */
	if (VAR_4 == NULL || VAR_5 == NULL)
		ereport(VAR_10,
				(errcode(VAR_11),
				 errmsg(""invalid source or destination node"")));

	if (!OidIsValid(VAR_2))
		ereport(VAR_10, (errcode(VAR_11), errmsg(""invalid chunk"")));

	if ((VAR_7 = SPI_connect_ext(VAR_8 ? VAR_12 : 0)) != VAR_13)
		elog(VAR_10, ""SPI_connect failed: %s"", SPI_result_code_string(VAR_7));

	/* COMMENT_1 */
	VAR_7 = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
	if (VAR_7 < 0)
		ereport(VAR_10, (errcode(VAR_14), (errmsg(""could not set search_path""))));

	/* COMMENT_2 */
	chunk_copy(VAR_2, VAR_4, VAR_5, VAR_6, VAR_1);

	if ((VAR_7 = SPI_finish()) != VAR_15)
		elog(VAR_10, ""SPI_finish failed: %s"", SPI_result_code_string(VAR_7));
}",timescale/timescaledb/014b40fb7e8d59087cf1c1988a68dd1979f86cb3/reorder.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -25,6 +25,11 @@
 	if ((rc = SPI_connect_ext(nonatomic ? SPI_OPT_NONATOMIC : 0)) != SPI_OK_CONNECT)
 		elog(ERROR, ""SPI_connect failed: %s"", SPI_result_code_string(rc));
 
+	/* Lock down search_path */
+	rc = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
+	if (rc < 0)
+		ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));
+
 	/* perform the actual distributed chunk move after a few sanity checks */
 	chunk_copy(chunk_id, src_node_name, dst_node_name, op_id, delete_on_src_node);
 ","{'deleted_lines': [], 'added_lines': ['\t/* Lock down search_path */', '\trc = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);', '\tif (rc < 0)', '\t\tereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));', '']}",True,"TimescaleDB, an open-source time-series SQL database, has a privilege escalation vulnerability in versions 2.8.0 through 2.9.2. During installation, TimescaleDB creates a telemetry job that is runs as the installation user. The queries run as part of the telemetry data collection were not run with a locked down `search_path`, allowing malicious users to create functions that would be executed by the telemetry job, leading to privilege escalation. In order to be able to take advantage of this vulnerability, a user would need to be able to create objects in a database and then get a superuser to install TimescaleDB into their database. When TimescaleDB is installed as trusted extension, non-superusers can install the extension without help from a superuser.

Version 2.9.3 fixes this issue. As a mitigation, the `search_path` of the user running the telemetry job can be locked down to not include schemas writable by other users. The vulnerability is not exploitable on instances in Timescale Cloud and Managed Service for TimescaleDB due to additional security provisions in place on those platforms.",8.8,HIGH,2,test,2023-01-31T12:59:48Z,4
CVE-2023-25149,['CWE-269'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,timescale/timescaledb,Lock down search_path in SPI calls,014b40fb7e8d59087cf1c1988a68dd1979f86cb3,https://github.com/timescale/timescaledb/commit/014b40fb7e8d59087cf1c1988a68dd1979f86cb3,tsl/src/continuous_aggs/refresh.c,continuous_agg_refresh_internal,"void
continuous_agg_refresh_internal(const ContinuousAgg *cagg,
const InternalTimeRange *refresh_window_arg,
const CaggRefreshCallContext callctx, const bool start_isnull,
const bool end_isnull)
{
Catalog *catalog = ts_catalog_get();
int32 mat_id = cagg->data.mat_hypertable_id;
InternalTimeRange refresh_window = *refresh_window_arg;
int64 computed_invalidation_threshold;
int64 invalidation_threshold;
bool is_raw_ht_distributed;
int rc;
if ((rc = SPI_connect_ext(SPI_OPT_NONATOMIC) != SPI_OK_CONNECT))
elog(ERROR, ""SPI_connect failed: %s"", SPI_result_code_string(rc));
if (!pg_class_ownercheck(cagg->relid, GetUserId()))
aclcheck_error(ACLCHECK_NOT_OWNER,
get_relkind_objtype(get_rel_relkind(cagg->relid)),
get_rel_name(cagg->relid));
PreventCommandIfReadOnly(REFRESH_FUNCTION_NAME);
PreventInTransactionBlock(true, REFRESH_FUNCTION_NAME);
Hypertable *ht = cagg_get_hypertable_or_fail(cagg->data.raw_hypertable_id);
is_raw_ht_distributed = hypertable_is_distributed(ht);
if (!(start_isnull && end_isnull))
{
if (ts_continuous_agg_bucket_width_variable(cagg))
{
refresh_window = *refresh_window_arg;
ts_compute_inscribed_bucketed_refresh_window_variable(&refresh_window.start,
&refresh_window.end,
cagg->bucket_function);
}
else
{
refresh_window =
compute_inscribed_bucketed_refresh_window(refresh_window_arg,
ts_continuous_agg_bucket_width(cagg));
}
}
if (refresh_window.start >= refresh_window.end)
ereport(ERROR,
(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
errmsg(""refresh window too small""),
errdetail(""The refresh window must cover at least one bucket of data.""),
errhint(""Align the refresh window with the bucket""
"" time zone or use at least two buckets."")));
log_refresh_window(callctx == CAGG_REFRESH_POLICY ? LOG : DEBUG1,
cagg,
&refresh_window,
""refreshing continuous aggregate"");
LockRelationOid(catalog_get_table_id(catalog, CONTINUOUS_AGGS_INVALIDATION_THRESHOLD),
AccessExclusiveLock);
computed_invalidation_threshold = invalidation_threshold_compute(cagg, &refresh_window);
invalidation_threshold = invalidation_threshold_set_or_get(cagg->data.raw_hypertable_id,
computed_invalidation_threshold);
if (refresh_window.end > invalidation_threshold)
refresh_window.end = invalidation_threshold;
if (refresh_window.start >= refresh_window.end)
{
emit_up_to_date_notice(cagg, callctx);
if ((rc = SPI_finish()) != SPI_OK_FINISH)
elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(rc));
return;
}
const CaggsInfo all_caggs_info =
ts_continuous_agg_get_all_caggs_info(cagg->data.raw_hypertable_id);
if (is_raw_ht_distributed)
{
remote_invalidation_process_hypertable_log(cagg->data.mat_hypertable_id,
cagg->data.raw_hypertable_id,
refresh_window.type,
&all_caggs_info);
}
else
{
invalidation_process_hypertable_log(cagg->data.mat_hypertable_id,
cagg->data.raw_hypertable_id,
refresh_window.type,
&all_caggs_info);
}
SPI_commit_and_chain();
cagg = ts_continuous_agg_find_by_mat_hypertable_id(mat_id);
if (!process_cagg_invalidations_and_refresh(cagg, &refresh_window, callctx, INVALID_CHUNK_ID))
emit_up_to_date_notice(cagg, callctx);
if ((rc = SPI_finish()) != SPI_OK_FINISH)
elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(rc));
}","void
continuous_agg_refresh_internal(const ContinuousAgg *VAR_0,
const InternalTimeRange *VAR_1,
const CaggRefreshCallContext VAR_2, const bool VAR_3,
const bool VAR_4)
{
Catalog *VAR_5 = ts_catalog_get();
int32 VAR_6 = VAR_0->data.mat_hypertable_id;
InternalTimeRange VAR_7 = *VAR_1;
int64 VAR_8;
int64 VAR_9;
bool VAR_10;
int VAR_11;
if ((VAR_11 = SPI_connect_ext(VAR_12) != VAR_13))
elog(VAR_14, ""SPI_connect failed: %s"", SPI_result_code_string(VAR_11));
if (!pg_class_ownercheck(VAR_0->relid, GetUserId()))
aclcheck_error(VAR_15,
get_relkind_objtype(get_rel_relkind(VAR_0->relid)),
get_rel_name(VAR_0->relid));
PreventCommandIfReadOnly(VAR_16);
PreventInTransactionBlock(true, VAR_16);
Hypertable *VAR_17 = cagg_get_hypertable_or_fail(VAR_0->data.raw_hypertable_id);
VAR_10 = hypertable_is_distributed(VAR_17);
if (!(VAR_3 && VAR_4))
{
if (ts_continuous_agg_bucket_width_variable(VAR_0))
{
VAR_7 = *VAR_1;
ts_compute_inscribed_bucketed_refresh_window_variable(&VAR_7.start,
&VAR_7.end,
VAR_0->bucket_function);
}
else
{
VAR_7 =
compute_inscribed_bucketed_refresh_window(VAR_1,
ts_continuous_agg_bucket_width(VAR_0));
}
}
if (VAR_7.start >= VAR_7.end)
ereport(VAR_14,
(errcode(VAR_18),
errmsg(""refresh window too small""),
errdetail(""The refresh window must cover at least one bucket of data.""),
errhint(""Align the refresh window with the bucket""
"" time zone or use at least two buckets."")));
log_refresh_window(VAR_2 == VAR_19 ? VAR_20 : VAR_21,
VAR_0,
&VAR_7,
""refreshing continuous aggregate"");
LockRelationOid(catalog_get_table_id(VAR_5, VAR_22),
VAR_23);
VAR_8 = invalidation_threshold_compute(VAR_0, &VAR_7);
VAR_9 = invalidation_threshold_set_or_get(VAR_0->data.raw_hypertable_id,
VAR_8);
if (VAR_7.end > VAR_9)
VAR_7.end = VAR_9;
if (VAR_7.start >= VAR_7.end)
{
emit_up_to_date_notice(VAR_0, VAR_2);
if ((VAR_11 = SPI_finish()) != VAR_24)
elog(VAR_14, ""SPI_finish failed: %s"", SPI_result_code_string(VAR_11));
return;
}
const CaggsInfo VAR_25 =
ts_continuous_agg_get_all_caggs_info(VAR_0->data.raw_hypertable_id);
if (VAR_10)
{
remote_invalidation_process_hypertable_log(VAR_0->data.mat_hypertable_id,
VAR_0->data.raw_hypertable_id,
VAR_7.type,
&VAR_25);
}
else
{
invalidation_process_hypertable_log(VAR_0->data.mat_hypertable_id,
VAR_0->data.raw_hypertable_id,
VAR_7.type,
&VAR_25);
}
SPI_commit_and_chain();
VAR_0 = ts_continuous_agg_find_by_mat_hypertable_id(VAR_6);
if (!process_cagg_invalidations_and_refresh(VAR_0, &VAR_7, VAR_2, VAR_26))
emit_up_to_date_notice(VAR_0, VAR_2);
if ((VAR_11 = SPI_finish()) != VAR_24)
elog(VAR_14, ""SPI_finish failed: %s"", SPI_result_code_string(VAR_11));
}",timescale/timescaledb/014b40fb7e8d59087cf1c1988a68dd1979f86cb3/refresh.c/vul/before/0.json,"void
continuous_agg_refresh_internal(const ContinuousAgg *cagg,
								const InternalTimeRange *refresh_window_arg,
								const CaggRefreshCallContext callctx, const bool start_isnull,
								const bool end_isnull)
{
	Catalog *catalog = ts_catalog_get();
	int32 mat_id = cagg->data.mat_hypertable_id;
	InternalTimeRange refresh_window = *refresh_window_arg;
	int64 computed_invalidation_threshold;
	int64 invalidation_threshold;
	bool is_raw_ht_distributed;
	int rc;

	/* Connect to SPI manager due to the underlying SPI calls */
	if ((rc = SPI_connect_ext(SPI_OPT_NONATOMIC) != SPI_OK_CONNECT))
		elog(ERROR, ""SPI_connect failed: %s"", SPI_result_code_string(rc));

	/* Lock down search_path */
	rc = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
	if (rc < 0)
		ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));

	/* Like regular materialized views, require owner to refresh. */
	if (!pg_class_ownercheck(cagg->relid, GetUserId()))
		aclcheck_error(ACLCHECK_NOT_OWNER,
					   get_relkind_objtype(get_rel_relkind(cagg->relid)),
					   get_rel_name(cagg->relid));

	PreventCommandIfReadOnly(REFRESH_FUNCTION_NAME);

	/* Prevent running refresh if we're in a transaction block since a refresh
	 * can run two transactions and might take a long time to release locks if
	 * there's a lot to materialize. Strictly, it is optional to prohibit
	 * transaction blocks since there will be only one transaction if the
	 * invalidation threshold needs no update. However, materialization might
	 * still take a long time and it is probably best for consistency to always
	 * prevent transaction blocks.  */
	PreventInTransactionBlock(true, REFRESH_FUNCTION_NAME);

	Hypertable *ht = cagg_get_hypertable_or_fail(cagg->data.raw_hypertable_id);
	is_raw_ht_distributed = hypertable_is_distributed(ht);

	/* No bucketing when open ended */
	if (!(start_isnull && end_isnull))
	{
		if (ts_continuous_agg_bucket_width_variable(cagg))
		{
			refresh_window = *refresh_window_arg;
			ts_compute_inscribed_bucketed_refresh_window_variable(&refresh_window.start,
																  &refresh_window.end,
																  cagg->bucket_function);
		}
		else
		{
			refresh_window =
				compute_inscribed_bucketed_refresh_window(refresh_window_arg,
														  ts_continuous_agg_bucket_width(cagg));
		}
	}

	if (refresh_window.start >= refresh_window.end)
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				 errmsg(""refresh window too small""),
				 errdetail(""The refresh window must cover at least one bucket of data.""),
				 errhint(""Align the refresh window with the bucket""
						 "" time zone or use at least two buckets."")));

	log_refresh_window(callctx == CAGG_REFRESH_POLICY ? LOG : DEBUG1,
					   cagg,
					   &refresh_window,
					   ""refreshing continuous aggregate"");

	/* Perform the refresh across two transactions.
	 *
	 * The first transaction moves the invalidation threshold (if needed) and
	 * copies over invalidations from the hypertable log to the cagg
	 * invalidation log. Doing the threshold and copying as part of the first
	 * transaction ensures that the threshold and new invalidations will be
	 * visible as soon as possible to concurrent refreshes and that we keep
	 * locks for only a short period. Note that the first transaction
	 * serializes around the threshold table lock, which protects both the
	 * threshold and the invalidation processing against concurrent refreshes.
	 *
	 * The second transaction processes the cagg invalidation log and then
	 * performs the actual refresh (materialization of data). This transaction
	 * serializes around a lock on the materialized hypertable for the
	 * continuous aggregate that gets refreshed.
	 */
	LockRelationOid(catalog_get_table_id(catalog, CONTINUOUS_AGGS_INVALIDATION_THRESHOLD),
					AccessExclusiveLock);

	/* Compute new invalidation threshold. Note that this computation caps the
	 * threshold at the end of the last bucket that holds data in the
	 * underlying hypertable. */
	computed_invalidation_threshold = invalidation_threshold_compute(cagg, &refresh_window);

	/* Set the new invalidation threshold. Note that this only updates the
	 * threshold if the new value is greater than the old one. Otherwise, the
	 * existing threshold is returned. */
	invalidation_threshold = invalidation_threshold_set_or_get(cagg->data.raw_hypertable_id,
															   computed_invalidation_threshold);

	/* We must also cap the refresh window at the invalidation threshold. If
	 * we process invalidations after the threshold, the continuous aggregates
	 * won't be refreshed when the threshold is moved forward in the
	 * future. The invalidation threshold should already be aligned on bucket
	 * boundary. */
	if (refresh_window.end > invalidation_threshold)
		refresh_window.end = invalidation_threshold;

	/* Capping the end might have made the window 0, or negative, so
	 * nothing to refresh in that case */
	if (refresh_window.start >= refresh_window.end)
	{
		emit_up_to_date_notice(cagg, callctx);

		if ((rc = SPI_finish()) != SPI_OK_FINISH)
			elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(rc));

		return;
	}

	/* Process invalidations in the hypertable invalidation log */
	const CaggsInfo all_caggs_info =
		ts_continuous_agg_get_all_caggs_info(cagg->data.raw_hypertable_id);
	if (is_raw_ht_distributed)
	{
		remote_invalidation_process_hypertable_log(cagg->data.mat_hypertable_id,
												   cagg->data.raw_hypertable_id,
												   refresh_window.type,
												   &all_caggs_info);
	}
	else
	{
		invalidation_process_hypertable_log(cagg->data.mat_hypertable_id,
											cagg->data.raw_hypertable_id,
											refresh_window.type,
											&all_caggs_info);
	}

	/* Commit and Start a new transaction */
	SPI_commit_and_chain();

	cagg = ts_continuous_agg_find_by_mat_hypertable_id(mat_id);

	if (!process_cagg_invalidations_and_refresh(cagg, &refresh_window, callctx, INVALID_CHUNK_ID))
		emit_up_to_date_notice(cagg, callctx);

	if ((rc = SPI_finish()) != SPI_OK_FINISH)
		elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(rc));
}","void
continuous_agg_refresh_internal(const ContinuousAgg *VAR_0,
								const InternalTimeRange *VAR_1,
								const CaggRefreshCallContext VAR_2, const bool VAR_3,
								const bool VAR_4)
{
	Catalog *VAR_5 = ts_catalog_get();
	int32 VAR_6 = VAR_0->data.mat_hypertable_id;
	InternalTimeRange VAR_7 = *VAR_1;
	int64 VAR_8;
	int64 VAR_9;
	bool VAR_10;
	int VAR_11;

	/* COMMENT_0 */
	if ((VAR_11 = SPI_connect_ext(VAR_12) != VAR_13))
		elog(VAR_14, ""SPI_connect failed: %s"", SPI_result_code_string(VAR_11));

	/* COMMENT_1 */
	VAR_11 = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
	if (VAR_11 < 0)
		ereport(VAR_14, (errcode(VAR_15), (errmsg(""could not set search_path""))));

	/* COMMENT_2 */
	if (!pg_class_ownercheck(VAR_0->relid, GetUserId()))
		aclcheck_error(VAR_16,
					   get_relkind_objtype(get_rel_relkind(VAR_0->relid)),
					   get_rel_name(VAR_0->relid));

	PreventCommandIfReadOnly(VAR_17);

	/* COMMENT_3 */
                                                                           
                                                                      
                                                                      
                                                                          
                                                                            
                                   
	PreventInTransactionBlock(true, VAR_17);

	Hypertable *VAR_18 = cagg_get_hypertable_or_fail(VAR_0->data.raw_hypertable_id);
	VAR_10 = hypertable_is_distributed(VAR_18);

	/* COMMENT_10 */
	if (!(VAR_3 && VAR_4))
	{
		if (ts_continuous_agg_bucket_width_variable(VAR_0))
		{
			VAR_7 = *VAR_1;
			ts_compute_inscribed_bucketed_refresh_window_variable(&VAR_7.start,
																  &VAR_7.end,
																  VAR_0->bucket_function);
		}
		else
		{
			VAR_7 =
				compute_inscribed_bucketed_refresh_window(VAR_1,
														  ts_continuous_agg_bucket_width(VAR_0));
		}
	}

	if (VAR_7.start >= VAR_7.end)
		ereport(VAR_14,
				(errcode(VAR_19),
				 errmsg(""refresh window too small""),
				 errdetail(""The refresh window must cover at least one bucket of data.""),
				 errhint(""Align the refresh window with the bucket""
						 "" time zone or use at least two buckets."")));

	log_refresh_window(VAR_2 == VAR_20 ? VAR_21 : VAR_22,
					   VAR_0,
					   &VAR_7,
					   ""refreshing continuous aggregate"");

	/* COMMENT_11 */
   
                                                                          
                                                                 
                                                                          
                                                                        
                                                                        
                                                                  
                                                                       
                                                                           
   
                                                                       
                                                                           
                                                                   
                                             
    
	LockRelationOid(catalog_get_table_id(VAR_5, VAR_23),
					VAR_24);

	/* COMMENT_26 */
                                                                  
                             
	VAR_8 = invalidation_threshold_compute(VAR_0, &VAR_7);

	/* COMMENT_29 */
                                                                          
                                      
	VAR_9 = invalidation_threshold_set_or_get(VAR_0->data.raw_hypertable_id,
															   VAR_8);

	/* COMMENT_32 */
                                                                           
                                                                 
                                                                          
                
	if (VAR_7.end > VAR_9)
		VAR_7.end = VAR_9;

	/* COMMENT_37 */
                                      
	if (VAR_7.start >= VAR_7.end)
	{
		emit_up_to_date_notice(VAR_0, VAR_2);

		if ((VAR_11 = SPI_finish()) != VAR_25)
			elog(VAR_14, ""SPI_finish failed: %s"", SPI_result_code_string(VAR_11));

		return;
	}

	/* COMMENT_39 */
	const CaggsInfo VAR_26 =
		ts_continuous_agg_get_all_caggs_info(VAR_0->data.raw_hypertable_id);
	if (VAR_10)
	{
		remote_invalidation_process_hypertable_log(VAR_0->data.mat_hypertable_id,
												   VAR_0->data.raw_hypertable_id,
												   VAR_7.type,
												   &VAR_26);
	}
	else
	{
		invalidation_process_hypertable_log(VAR_0->data.mat_hypertable_id,
											VAR_0->data.raw_hypertable_id,
											VAR_7.type,
											&VAR_26);
	}

	/* COMMENT_40 */
	SPI_commit_and_chain();

	VAR_0 = ts_continuous_agg_find_by_mat_hypertable_id(VAR_6);

	if (!process_cagg_invalidations_and_refresh(VAR_0, &VAR_7, VAR_2, VAR_27))
		emit_up_to_date_notice(VAR_0, VAR_2);

	if ((VAR_11 = SPI_finish()) != VAR_25)
		elog(VAR_14, ""SPI_finish failed: %s"", SPI_result_code_string(VAR_11));
}",timescale/timescaledb/014b40fb7e8d59087cf1c1988a68dd1979f86cb3/refresh.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -15,6 +15,11 @@
 	/* Connect to SPI manager due to the underlying SPI calls */
 	if ((rc = SPI_connect_ext(SPI_OPT_NONATOMIC) != SPI_OK_CONNECT))
 		elog(ERROR, ""SPI_connect failed: %s"", SPI_result_code_string(rc));
+
+	/* Lock down search_path */
+	rc = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
+	if (rc < 0)
+		ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));
 
 	/* Like regular materialized views, require owner to refresh. */
 	if (!pg_class_ownercheck(cagg->relid, GetUserId()))","{'deleted_lines': [], 'added_lines': ['', '\t/* Lock down search_path */', '\trc = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);', '\tif (rc < 0)', '\t\tereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));']}",True,"TimescaleDB, an open-source time-series SQL database, has a privilege escalation vulnerability in versions 2.8.0 through 2.9.2. During installation, TimescaleDB creates a telemetry job that is runs as the installation user. The queries run as part of the telemetry data collection were not run with a locked down `search_path`, allowing malicious users to create functions that would be executed by the telemetry job, leading to privilege escalation. In order to be able to take advantage of this vulnerability, a user would need to be able to create objects in a database and then get a superuser to install TimescaleDB into their database. When TimescaleDB is installed as trusted extension, non-superusers can install the extension without help from a superuser.

Version 2.9.3 fixes this issue. As a mitigation, the `search_path` of the user running the telemetry job can be locked down to not include schemas writable by other users. The vulnerability is not exploitable on instances in Timescale Cloud and Managed Service for TimescaleDB due to additional security provisions in place on those platforms.",8.8,HIGH,2,test,2023-01-31T12:59:48Z,4
CVE-2023-25149,['CWE-269'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,timescale/timescaledb,Lock down search_path in SPI calls,014b40fb7e8d59087cf1c1988a68dd1979f86cb3,https://github.com/timescale/timescaledb/commit/014b40fb7e8d59087cf1c1988a68dd1979f86cb3,src/hypertable.c,ts_hypertable_get_open_dim_max_value,"Datum
ts_hypertable_get_open_dim_max_value(const Hypertable *ht, int dimension_index, bool *isnull)
{
StringInfo command;
const Dimension *dim;
int res;
bool max_isnull;
Datum maxdat;
dim = hyperspace_get_open_dimension(ht->space, dimension_index);
if (NULL == dim)
elog(ERROR, ""invalid open dimension index %d"", dimension_index);
command = makeStringInfo();
appendStringInfo(command,
""SELECT max(%s) FROM %s.%s"",
quote_identifier(NameStr(dim->fd.column_name)),
quote_identifier(NameStr(ht->fd.schema_name)),
quote_identifier(NameStr(ht->fd.table_name)));
if (SPI_connect() != SPI_OK_CONNECT)
elog(ERROR, ""could not connect to SPI"");
res = SPI_execute(command->data, true , 0 );
if (res < 0)
ereport(ERROR,
(errcode(ERRCODE_INTERNAL_ERROR),
(errmsg(""could not find the maximum time value for hypertable \""%s\"""",
get_rel_name(ht->main_table_relid)))));
Ensure(SPI_gettypeid(SPI_tuptable->tupdesc, 1) == ts_dimension_get_partition_type(dim),
""partition types for result (%d) and dimension (%d) do not match"",
SPI_gettypeid(SPI_tuptable->tupdesc, 1),
ts_dimension_get_partition_type(dim));
maxdat = SPI_getbinval(SPI_tuptable->vals[0], SPI_tuptable->tupdesc, 1, &max_isnull);
if (isnull)
*isnull = max_isnull;
if ((res = SPI_finish()) != SPI_OK_FINISH)
elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(res));
return maxdat;
}","Datum
ts_hypertable_get_open_dim_max_value(const Hypertable *VAR_0, int VAR_1, bool *VAR_2)
{
StringInfo VAR_3;
const Dimension *VAR_4;
int VAR_5;
bool VAR_6;
Datum VAR_7;
VAR_4 = hyperspace_get_open_dimension(VAR_0->space, VAR_1);
if (NULL == VAR_4)
elog(VAR_8, ""invalid open dimension index %d"", VAR_1);
VAR_3 = makeStringInfo();
appendStringInfo(VAR_3,
""SELECT max(%s) FROM %s.%s"",
quote_identifier(NameStr(VAR_4->fd.column_name)),
quote_identifier(NameStr(VAR_0->fd.schema_name)),
quote_identifier(NameStr(VAR_0->fd.table_name)));
if (SPI_connect() != VAR_9)
elog(VAR_8, ""could not connect to SPI"");
VAR_5 = SPI_execute(VAR_3->data, true , 0 );
if (VAR_5 < 0)
ereport(VAR_8,
(errcode(VAR_10),
(errmsg(""could not find the maximum time value for hypertable \""%s\"""",
get_rel_name(VAR_0->main_table_relid)))));
Ensure(SPI_gettypeid(VAR_11->tupdesc, 1) == ts_dimension_get_partition_type(VAR_4),
""partition types for result (%d) and dimension (%d) do not match"",
SPI_gettypeid(VAR_11->tupdesc, 1),
ts_dimension_get_partition_type(VAR_4));
VAR_7 = SPI_getbinval(VAR_11->vals[0], VAR_11->tupdesc, 1, &VAR_6);
if (VAR_2)
*VAR_2 = VAR_6;
if ((VAR_5 = SPI_finish()) != VAR_12)
elog(VAR_8, ""SPI_finish failed: %s"", SPI_result_code_string(VAR_5));
return VAR_7;
}",timescale/timescaledb/014b40fb7e8d59087cf1c1988a68dd1979f86cb3/hypertable.c/vul/before/0.json,"Datum
ts_hypertable_get_open_dim_max_value(const Hypertable *ht, int dimension_index, bool *isnull)
{
	StringInfo command;
	const Dimension *dim;
	int res;
	bool max_isnull;
	Datum maxdat;

	dim = hyperspace_get_open_dimension(ht->space, dimension_index);

	if (NULL == dim)
		elog(ERROR, ""invalid open dimension index %d"", dimension_index);

	/*
	 * Query for the last bucket in the materialized hypertable.
	 * Since this might be run as part of a parallel operation
	 * we cannot use SET search_path here to lock down the
	 * search_path and instead have to fully schema-qualify
	 * everything.
	 */
	command = makeStringInfo();
	appendStringInfo(command,
					 ""SELECT pg_catalog.max(%s) FROM %s.%s"",
					 quote_identifier(NameStr(dim->fd.column_name)),
					 quote_identifier(NameStr(ht->fd.schema_name)),
					 quote_identifier(NameStr(ht->fd.table_name)));

	if (SPI_connect() != SPI_OK_CONNECT)
		elog(ERROR, ""could not connect to SPI"");

	res = SPI_execute(command->data, true /* read_only */, 0 /*count*/);

	if (res < 0)
		ereport(ERROR,
				(errcode(ERRCODE_INTERNAL_ERROR),
				 (errmsg(""could not find the maximum time value for hypertable \""%s\"""",
						 get_rel_name(ht->main_table_relid)))));

	Ensure(SPI_gettypeid(SPI_tuptable->tupdesc, 1) == ts_dimension_get_partition_type(dim),
		   ""partition types for result (%d) and dimension (%d) do not match"",
		   SPI_gettypeid(SPI_tuptable->tupdesc, 1),
		   ts_dimension_get_partition_type(dim));
	maxdat = SPI_getbinval(SPI_tuptable->vals[0], SPI_tuptable->tupdesc, 1, &max_isnull);

	if (isnull)
		*isnull = max_isnull;

	if ((res = SPI_finish()) != SPI_OK_FINISH)
		elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(res));

	return maxdat;
}","Datum
ts_hypertable_get_open_dim_max_value(const Hypertable *VAR_0, int VAR_1, bool *VAR_2)
{
	StringInfo VAR_3;
	const Dimension *VAR_4;
	int VAR_5;
	bool VAR_6;
	Datum VAR_7;

	VAR_4 = hyperspace_get_open_dimension(VAR_0->space, VAR_1);

	if (NULL == VAR_4)
		elog(VAR_8, ""invalid open dimension index %d"", VAR_1);

	/* COMMENT_0 */
                                                             
                                                           
                                                       
                                                        
               
    
	VAR_3 = makeStringInfo();
	appendStringInfo(VAR_3,
					 ""SELECT pg_catalog.max(%s) FROM %s.%s"",
					 quote_identifier(NameStr(VAR_4->fd.column_name)),
					 quote_identifier(NameStr(VAR_0->fd.schema_name)),
					 quote_identifier(NameStr(VAR_0->fd.table_name)));

	if (SPI_connect() != VAR_9)
		elog(VAR_8, ""could not connect to SPI"");

	VAR_5 = SPI_execute(VAR_3->data, true /* COMMENT_7 */, 0 /* COMMENT_8 */);

	if (VAR_5 < 0)
		ereport(VAR_8,
				(errcode(VAR_10),
				 (errmsg(""could not find the maximum time value for hypertable \""%s\"""",
						 get_rel_name(VAR_0->main_table_relid)))));

	Ensure(SPI_gettypeid(VAR_11->tupdesc, 1) == ts_dimension_get_partition_type(VAR_4),
		   ""partition types for result (%d) and dimension (%d) do not match"",
		   SPI_gettypeid(VAR_11->tupdesc, 1),
		   ts_dimension_get_partition_type(VAR_4));
	VAR_7 = SPI_getbinval(VAR_11->vals[0], VAR_11->tupdesc, 1, &VAR_6);

	if (VAR_2)
		*VAR_2 = VAR_6;

	if ((VAR_5 = SPI_finish()) != VAR_12)
		elog(VAR_8, ""SPI_finish failed: %s"", SPI_result_code_string(VAR_5));

	return VAR_7;
}",timescale/timescaledb/014b40fb7e8d59087cf1c1988a68dd1979f86cb3/hypertable.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,10 +12,16 @@
 	if (NULL == dim)
 		elog(ERROR, ""invalid open dimension index %d"", dimension_index);
 
-	/* Query for the last bucket in the materialized hypertable */
+	/*
+	 * Query for the last bucket in the materialized hypertable.
+	 * Since this might be run as part of a parallel operation
+	 * we cannot use SET search_path here to lock down the
+	 * search_path and instead have to fully schema-qualify
+	 * everything.
+	 */
 	command = makeStringInfo();
 	appendStringInfo(command,
-					 ""SELECT max(%s) FROM %s.%s"",
+					 ""SELECT pg_catalog.max(%s) FROM %s.%s"",
 					 quote_identifier(NameStr(dim->fd.column_name)),
 					 quote_identifier(NameStr(ht->fd.schema_name)),
 					 quote_identifier(NameStr(ht->fd.table_name)));","{'deleted_lines': ['\t/* Query for the last bucket in the materialized hypertable */', '\t\t\t\t\t ""SELECT max(%s) FROM %s.%s"",'], 'added_lines': ['\t/*', '\t * Query for the last bucket in the materialized hypertable.', '\t * Since this might be run as part of a parallel operation', '\t * we cannot use SET search_path here to lock down the', '\t * search_path and instead have to fully schema-qualify', '\t * everything.', '\t */', '\t\t\t\t\t ""SELECT pg_catalog.max(%s) FROM %s.%s"",']}",True,"TimescaleDB, an open-source time-series SQL database, has a privilege escalation vulnerability in versions 2.8.0 through 2.9.2. During installation, TimescaleDB creates a telemetry job that is runs as the installation user. The queries run as part of the telemetry data collection were not run with a locked down `search_path`, allowing malicious users to create functions that would be executed by the telemetry job, leading to privilege escalation. In order to be able to take advantage of this vulnerability, a user would need to be able to create objects in a database and then get a superuser to install TimescaleDB into their database. When TimescaleDB is installed as trusted extension, non-superusers can install the extension without help from a superuser.

Version 2.9.3 fixes this issue. As a mitigation, the `search_path` of the user running the telemetry job can be locked down to not include schemas writable by other users. The vulnerability is not exploitable on instances in Timescale Cloud and Managed Service for TimescaleDB due to additional security provisions in place on those platforms.",8.8,HIGH,2,test,2023-01-31T12:59:48Z,4
CVE-2023-25149,['CWE-269'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,timescale/timescaledb,Lock down search_path in SPI calls,014b40fb7e8d59087cf1c1988a68dd1979f86cb3,https://github.com/timescale/timescaledb/commit/014b40fb7e8d59087cf1c1988a68dd1979f86cb3,tsl/src/continuous_aggs/materialize.c,continuous_agg_update_materialization,"void
continuous_agg_update_materialization(SchemaAndName partial_view,
SchemaAndName materialization_table,
const NameData *time_column_name,
InternalTimeRange new_materialization_range,
InternalTimeRange invalidation_range, int32 chunk_id)
{
InternalTimeRange combined_materialization_range = new_materialization_range;
bool materialize_invalidations_separately = range_length(invalidation_range) > 0;
int res = SPI_connect();
if (res != SPI_OK_CONNECT)
elog(ERROR, ""could not connect to SPI in materializer"");
if (new_materialization_range.start > new_materialization_range.end)
new_materialization_range.start = new_materialization_range.end;
if (range_length(invalidation_range) > 0)
{
Assert(invalidation_range.start <= invalidation_range.end);
if (invalidation_range.start >= new_materialization_range.end ||
invalidation_range.end > new_materialization_range.end)
elog(ERROR, ""internal error: invalidation range ahead of new materialization range"");
materialize_invalidations_separately =
!ranges_overlap(invalidation_range, new_materialization_range);
combined_materialization_range.start =
int64_min(invalidation_range.start, new_materialization_range.start);
}
if (range_length(invalidation_range) == 0 || !materialize_invalidations_separately)
{
spi_update_materializations(partial_view,
materialization_table,
time_column_name,
internal_time_range_to_time_range(
combined_materialization_range),
chunk_id);
}
else
{
spi_update_materializations(partial_view,
materialization_table,
time_column_name,
internal_time_range_to_time_range(invalidation_range),
chunk_id);
spi_update_materializations(partial_view,
materialization_table,
time_column_name,
internal_time_range_to_time_range(new_materialization_range),
chunk_id);
}
if ((res = SPI_finish()) != SPI_OK_FINISH)
elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(res));
}","void
continuous_agg_update_materialization(SchemaAndName VAR_0,
SchemaAndName VAR_1,
const NameData *VAR_2,
InternalTimeRange VAR_3,
InternalTimeRange VAR_4, int32 VAR_5)
{
InternalTimeRange VAR_6 = VAR_3;
bool VAR_7 = range_length(VAR_4) > 0;
int VAR_8 = SPI_connect();
if (VAR_8 != VAR_9)
elog(VAR_10, ""could not connect to SPI in materializer"");
if (VAR_3.start > VAR_3.end)
VAR_3.start = VAR_3.end;
if (range_length(VAR_4) > 0)
{
Assert(VAR_4.start <= VAR_4.end);
if (VAR_4.start >= VAR_3.end ||
VAR_4.end > VAR_3.end)
elog(VAR_10, ""internal error: invalidation range ahead of new materialization range"");
VAR_7 =
!ranges_overlap(VAR_4, VAR_3);
VAR_6.start =
int64_min(VAR_4.start, VAR_3.start);
}
if (range_length(VAR_4) == 0 || !VAR_7)
{
spi_update_materializations(VAR_0,
VAR_1,
VAR_2,
internal_time_range_to_time_range(
VAR_6),
VAR_5);
}
else
{
spi_update_materializations(VAR_0,
VAR_1,
VAR_2,
internal_time_range_to_time_range(VAR_4),
VAR_5);
spi_update_materializations(VAR_0,
VAR_1,
VAR_2,
internal_time_range_to_time_range(VAR_3),
VAR_5);
}
if ((VAR_8 = SPI_finish()) != VAR_11)
elog(VAR_10, ""SPI_finish failed: %s"", SPI_result_code_string(VAR_8));
}",timescale/timescaledb/014b40fb7e8d59087cf1c1988a68dd1979f86cb3/materialize.c/vul/before/0.json,"void
continuous_agg_update_materialization(SchemaAndName partial_view,
									  SchemaAndName materialization_table,
									  const NameData *time_column_name,
									  InternalTimeRange new_materialization_range,
									  InternalTimeRange invalidation_range, int32 chunk_id)
{
	InternalTimeRange combined_materialization_range = new_materialization_range;
	bool materialize_invalidations_separately = range_length(invalidation_range) > 0;
	int res = SPI_connect();
	if (res != SPI_OK_CONNECT)
		elog(ERROR, ""could not connect to SPI in materializer"");

	/* Lock down search_path */
	res = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
	if (res < 0)
		ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));

	/* pin the start of new_materialization to the end of new_materialization,
	 * we are not allowed to materialize beyond that point
	 */
	if (new_materialization_range.start > new_materialization_range.end)
		new_materialization_range.start = new_materialization_range.end;

	if (range_length(invalidation_range) > 0)
	{
		Assert(invalidation_range.start <= invalidation_range.end);

		/* we never materialize beyond the new materialization range */
		if (invalidation_range.start >= new_materialization_range.end ||
			invalidation_range.end > new_materialization_range.end)
			elog(ERROR, ""internal error: invalidation range ahead of new materialization range"");

		/* If the invalidation and new materialization ranges overlap, materialize in one go */
		materialize_invalidations_separately =
			!ranges_overlap(invalidation_range, new_materialization_range);

		combined_materialization_range.start =
			int64_min(invalidation_range.start, new_materialization_range.start);
	}

	/* Then insert the materializations.
	 * We insert them in two groups:
	 * [lowest_invalidated, greatest_invalidated] and
	 * [start_of_new_materialization, end_of_new_materialization]
	 * eventually, we may want more precise deletions and insertions for the invalidated ranges.
	 * if greatest_invalidated == end_of_new_materialization then we only perform 1 insertion.
	 * to prevent values from being inserted multiple times.
	 */
	if (range_length(invalidation_range) == 0 || !materialize_invalidations_separately)
	{
		spi_update_materializations(partial_view,
									materialization_table,
									time_column_name,
									internal_time_range_to_time_range(
										combined_materialization_range),
									chunk_id);
	}
	else
	{
		spi_update_materializations(partial_view,
									materialization_table,
									time_column_name,
									internal_time_range_to_time_range(invalidation_range),
									chunk_id);

		spi_update_materializations(partial_view,
									materialization_table,
									time_column_name,
									internal_time_range_to_time_range(new_materialization_range),
									chunk_id);
	}

	if ((res = SPI_finish()) != SPI_OK_FINISH)
		elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(res));
}","void
continuous_agg_update_materialization(SchemaAndName VAR_0,
									  SchemaAndName VAR_1,
									  const NameData *VAR_2,
									  InternalTimeRange VAR_3,
									  InternalTimeRange VAR_4, int32 VAR_5)
{
	InternalTimeRange VAR_6 = VAR_3;
	bool VAR_7 = range_length(VAR_4) > 0;
	int VAR_8 = SPI_connect();
	if (VAR_8 != VAR_9)
		elog(VAR_10, ""could not connect to SPI in materializer"");

	/* COMMENT_0 */
	VAR_8 = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
	if (VAR_8 < 0)
		ereport(VAR_10, (errcode(VAR_11), (errmsg(""could not set search_path""))));

	/* COMMENT_1 */
                                                       
    
	if (VAR_3.start > VAR_3.end)
		VAR_3.start = VAR_3.end;

	if (range_length(VAR_4) > 0)
	{
		Assert(VAR_4.start <= VAR_4.end);

		/* COMMENT_4 */
		if (VAR_4.start >= VAR_3.end ||
			VAR_4.end > VAR_3.end)
			elog(VAR_10, ""internal error: invalidation range ahead of new materialization range"");

		/* COMMENT_5 */
		VAR_7 =
			!ranges_overlap(VAR_4, VAR_3);

		VAR_6.start =
			int64_min(VAR_4.start, VAR_3.start);
	}

	/* COMMENT_6 */
                                 
                                                  
                                                              
                                                                                             
                                                                                           
                                                         
    
	if (range_length(VAR_4) == 0 || !VAR_7)
	{
		spi_update_materializations(VAR_0,
									VAR_1,
									VAR_2,
									internal_time_range_to_time_range(
										VAR_6),
									VAR_5);
	}
	else
	{
		spi_update_materializations(VAR_0,
									VAR_1,
									VAR_2,
									internal_time_range_to_time_range(VAR_4),
									VAR_5);

		spi_update_materializations(VAR_0,
									VAR_1,
									VAR_2,
									internal_time_range_to_time_range(VAR_3),
									VAR_5);
	}

	if ((VAR_8 = SPI_finish()) != VAR_12)
		elog(VAR_10, ""SPI_finish failed: %s"", SPI_result_code_string(VAR_8));
}",timescale/timescaledb/014b40fb7e8d59087cf1c1988a68dd1979f86cb3/materialize.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,6 +10,11 @@
 	int res = SPI_connect();
 	if (res != SPI_OK_CONNECT)
 		elog(ERROR, ""could not connect to SPI in materializer"");
+
+	/* Lock down search_path */
+	res = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
+	if (res < 0)
+		ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));
 
 	/* pin the start of new_materialization to the end of new_materialization,
 	 * we are not allowed to materialize beyond that point","{'deleted_lines': [], 'added_lines': ['', '\t/* Lock down search_path */', '\tres = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);', '\tif (res < 0)', '\t\tereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));']}",True,"TimescaleDB, an open-source time-series SQL database, has a privilege escalation vulnerability in versions 2.8.0 through 2.9.2. During installation, TimescaleDB creates a telemetry job that is runs as the installation user. The queries run as part of the telemetry data collection were not run with a locked down `search_path`, allowing malicious users to create functions that would be executed by the telemetry job, leading to privilege escalation. In order to be able to take advantage of this vulnerability, a user would need to be able to create objects in a database and then get a superuser to install TimescaleDB into their database. When TimescaleDB is installed as trusted extension, non-superusers can install the extension without help from a superuser.

Version 2.9.3 fixes this issue. As a mitigation, the `search_path` of the user running the telemetry job can be locked down to not include schemas writable by other users. The vulnerability is not exploitable on instances in Timescale Cloud and Managed Service for TimescaleDB due to additional security provisions in place on those platforms.",8.8,HIGH,2,test,2023-01-31T12:59:48Z,4
CVE-2023-25149,['CWE-269'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,timescale/timescaledb,Lock down search_path in SPI calls,014b40fb7e8d59087cf1c1988a68dd1979f86cb3,https://github.com/timescale/timescaledb/commit/014b40fb7e8d59087cf1c1988a68dd1979f86cb3,src/telemetry/replication.c,ts_telemetry_replication_info_gather,"ReplicationInfo
ts_telemetry_replication_info_gather(void)
{
int res;
bool isnull;
Datum data;
ReplicationInfo info = {
.got_num_wal_senders = false,
.got_is_wal_receiver = false,
};
if (SPI_connect() != SPI_OK_CONNECT)
return info;
res = SPI_execute(""SELECT cast(count(pid) as int) from pg_catalog.pg_stat_get_wal_senders() ""
""WHERE pid is not null"",
true, 
0
);
if (res >= 0)
{
data = SPI_getbinval(SPI_tuptable->vals[0], SPI_tuptable->tupdesc, 1, &isnull);
info.num_wal_senders = DatumGetInt32(data);
info.got_num_wal_senders = true;
}
res = SPI_execute(""SELECT count(pid) > 0 from pg_catalog.pg_stat_get_wal_receiver() WHERE pid ""
""is not null"",
true, 
0
);
if (res >= 0)
{
data = SPI_getbinval(SPI_tuptable->vals[0], SPI_tuptable->tupdesc, 1, &isnull);
info.is_wal_receiver = DatumGetBool(data);
info.got_is_wal_receiver = true;
}
if ((res = SPI_finish()) != SPI_OK_FINISH)
elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(res));
return info;
}","ReplicationInfo
ts_telemetry_replication_info_gather(void)
{
int VAR_0;
bool VAR_1;
Datum VAR_2;
ReplicationInfo VAR_3 = {
.got_num_wal_senders = false,
.got_is_wal_receiver = false,
};
if (SPI_connect() != VAR_4)
return VAR_3;
VAR_0 = SPI_execute(""SELECT cast(count(pid) as int) from pg_catalog.pg_stat_get_wal_senders() ""
""WHERE pid is not null"",
true, 
0
);
if (VAR_0 >= 0)
{
VAR_2 = SPI_getbinval(VAR_5->vals[0], VAR_5->tupdesc, 1, &VAR_1);
VAR_3.num_wal_senders = DatumGetInt32(VAR_2);
VAR_3.got_num_wal_senders = true;
}
VAR_0 = SPI_execute(""SELECT count(pid) > 0 from pg_catalog.pg_stat_get_wal_receiver() WHERE pid ""
""is not null"",
true, 
0
);
if (VAR_0 >= 0)
{
VAR_2 = SPI_getbinval(VAR_5->vals[0], VAR_5->tupdesc, 1, &VAR_1);
VAR_3.is_wal_receiver = DatumGetBool(VAR_2);
VAR_3.got_is_wal_receiver = true;
}
if ((VAR_0 = SPI_finish()) != VAR_6)
elog(VAR_7, ""SPI_finish failed: %s"", SPI_result_code_string(VAR_0));
return VAR_3;
}",timescale/timescaledb/014b40fb7e8d59087cf1c1988a68dd1979f86cb3/replication.c/vul/before/0.json,"ReplicationInfo
ts_telemetry_replication_info_gather(void)
{
	int res;
	bool isnull;
	Datum data;
	ReplicationInfo info = {
		.got_num_wal_senders = false,
		.got_is_wal_receiver = false,
	};

	if (SPI_connect() != SPI_OK_CONNECT)
		return info;

	/* Lock down search_path */
	res = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
	if (res < 0)
		ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));

	res = SPI_execute(""SELECT cast(count(pid) as int) from pg_catalog.pg_stat_get_wal_senders() ""
					  ""WHERE pid is not null"",
					  true, /* read_only */
					  0		/*count*/
	);

	if (res >= 0)
	{
		data = SPI_getbinval(SPI_tuptable->vals[0], SPI_tuptable->tupdesc, 1, &isnull);
		info.num_wal_senders = DatumGetInt32(data);
		info.got_num_wal_senders = true;
	}

	/* use count() > 0 in case they start having pg_stat_get_wal_receiver()
	 * return no rows when the DB isn't a replica */
	res = SPI_execute(""SELECT count(pid) > 0 from pg_catalog.pg_stat_get_wal_receiver() WHERE pid ""
					  ""is not null"",
					  true, /* read_only */
					  0		/*count*/
	);
	if (res >= 0)
	{
		data = SPI_getbinval(SPI_tuptable->vals[0], SPI_tuptable->tupdesc, 1, &isnull);
		info.is_wal_receiver = DatumGetBool(data);
		info.got_is_wal_receiver = true;
	}

	if ((res = SPI_finish()) != SPI_OK_FINISH)
		elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(res));

	return info;
}","ReplicationInfo
ts_telemetry_replication_info_gather(void)
{
	int VAR_0;
	bool VAR_1;
	Datum VAR_2;
	ReplicationInfo VAR_3 = {
		.got_num_wal_senders = false,
		.got_is_wal_receiver = false,
	};

	if (SPI_connect() != VAR_4)
		return VAR_3;

	/* COMMENT_0 */
	VAR_0 = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
	if (VAR_0 < 0)
		ereport(VAR_5, (errcode(VAR_6), (errmsg(""could not set search_path""))));

	VAR_0 = SPI_execute(""SELECT cast(count(pid) as int) from pg_catalog.pg_stat_get_wal_senders() ""
					  ""WHERE pid is not null"",
					  true, /* COMMENT_1 */
					  0		/* COMMENT_2 */
	);

	if (VAR_0 >= 0)
	{
		VAR_2 = SPI_getbinval(VAR_7->vals[0], VAR_7->tupdesc, 1, &VAR_1);
		VAR_3.num_wal_senders = DatumGetInt32(VAR_2);
		VAR_3.got_num_wal_senders = true;
	}

	/* COMMENT_3 */
                                                 
	VAR_0 = SPI_execute(""SELECT count(pid) > 0 from pg_catalog.pg_stat_get_wal_receiver() WHERE pid ""
					  ""is not null"",
					  true, /* COMMENT_1 */
					  0		/* COMMENT_2 */
	);
	if (VAR_0 >= 0)
	{
		VAR_2 = SPI_getbinval(VAR_7->vals[0], VAR_7->tupdesc, 1, &VAR_1);
		VAR_3.is_wal_receiver = DatumGetBool(VAR_2);
		VAR_3.got_is_wal_receiver = true;
	}

	if ((VAR_0 = SPI_finish()) != VAR_8)
		elog(VAR_5, ""SPI_finish failed: %s"", SPI_result_code_string(VAR_0));

	return VAR_3;
}",timescale/timescaledb/014b40fb7e8d59087cf1c1988a68dd1979f86cb3/replication.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,6 +11,11 @@
 
 	if (SPI_connect() != SPI_OK_CONNECT)
 		return info;
+
+	/* Lock down search_path */
+	res = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
+	if (res < 0)
+		ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));
 
 	res = SPI_execute(""SELECT cast(count(pid) as int) from pg_catalog.pg_stat_get_wal_senders() ""
 					  ""WHERE pid is not null"",","{'deleted_lines': [], 'added_lines': ['', '\t/* Lock down search_path */', '\tres = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);', '\tif (res < 0)', '\t\tereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));']}",True,"TimescaleDB, an open-source time-series SQL database, has a privilege escalation vulnerability in versions 2.8.0 through 2.9.2. During installation, TimescaleDB creates a telemetry job that is runs as the installation user. The queries run as part of the telemetry data collection were not run with a locked down `search_path`, allowing malicious users to create functions that would be executed by the telemetry job, leading to privilege escalation. In order to be able to take advantage of this vulnerability, a user would need to be able to create objects in a database and then get a superuser to install TimescaleDB into their database. When TimescaleDB is installed as trusted extension, non-superusers can install the extension without help from a superuser.

Version 2.9.3 fixes this issue. As a mitigation, the `search_path` of the user running the telemetry job can be locked down to not include schemas writable by other users. The vulnerability is not exploitable on instances in Timescale Cloud and Managed Service for TimescaleDB due to additional security provisions in place on those platforms.",8.8,HIGH,2,test,2023-01-31T12:59:48Z,4
CVE-2023-25149,['CWE-269'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,timescale/timescaledb,Lock down search_path in SPI calls,014b40fb7e8d59087cf1c1988a68dd1979f86cb3,https://github.com/timescale/timescaledb/commit/014b40fb7e8d59087cf1c1988a68dd1979f86cb3,src/telemetry/telemetry.c,add_errors_by_sqlerrcode,"static void
add_errors_by_sqlerrcode(JsonbParseState *parse_state)
{
int res;
StringInfo command;
MemoryContext old_context = CurrentMemoryContext, spi_context;
const char *command_string =
""SELECT ""
""job_type, jsonb_object_agg(sqlerrcode, count) ""
""FROM""
""(""
""SELECT (""
""CASE ""
""WHEN error_data ->> \'proc_schema\' = \'_timescaledb_internal\'""
"" AND error_data ->> \'proc_name\' ~ ""
""\'^policy_(retention|compression|reorder|refresh_continuous_""
""aggregate|telemetry|job_error_retention)$\' ""
""THEN error_data ->> \'proc_name\' ""
""ELSE \'user_defined_action\'""
""END""
"") as job_type, ""
""error_data ->> \'sqlerrcode\' as sqlerrcode, ""
""pg_catalog.COUNT(*) ""
""FROM ""
""_timescaledb_internal.job_errors ""
""WHERE error_data ->> \'sqlerrcode\' IS NOT NULL ""
""GROUP BY job_type, error_data->> \'sqlerrcode\' ""
""ORDER BY job_type""
"") q ""
""GROUP BY q.job_type"";
if (SPI_connect() != SPI_OK_CONNECT)
elog(ERROR, ""could not connect to SPI"");
res = SPI_exec(""SET search_path TO pg_catalog, pg_temp"", 0);
if (res < 0)
ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));
command = makeStringInfo();
appendStringInfoString(command, command_string);
res = SPI_execute(command->data, true , 0 );
if (res < 0)
ereport(ERROR,
(errcode(ERRCODE_INTERNAL_ERROR),
(errmsg(""could not get errors by sqlerrcode and job type""))));
for (uint64 i = 0; i < SPI_processed; i++)
{
Datum record_jobtype, record_jsonb;
bool isnull_jobtype, isnull_jsonb;
record_jobtype =
SPI_getbinval(SPI_tuptable->vals[i], SPI_tuptable->tupdesc, 1, &isnull_jobtype);
if (isnull_jobtype)
elog(ERROR, ""null job type returned"");
record_jsonb =
SPI_getbinval(SPI_tuptable->vals[i], SPI_tuptable->tupdesc, 2, &isnull_jsonb);
Jsonb *sqlerrs_jsonb = isnull_jsonb ? NULL : DatumGetJsonbP(record_jsonb);
if (sqlerrs_jsonb == NULL)
continue;
spi_context = MemoryContextSwitchTo(old_context);
add_errors_by_sqlerrcode_internal(parse_state,
TextDatumGetCString(record_jobtype),
sqlerrs_jsonb);
old_context = MemoryContextSwitchTo(spi_context);
}
res = SPI_exec(""RESET search_path"", 0);
res = SPI_finish();
Assert(res == SPI_OK_FINISH);
}","static void
add_errors_by_sqlerrcode(JsonbParseState *VAR_0)
{
int VAR_1;
StringInfo VAR_2;
MemoryContext VAR_3 = VAR_4, VAR_5;
const char *VAR_6 =
""SELECT ""
""job_type, jsonb_object_agg(sqlerrcode, count) ""
""FROM""
""(""
""SELECT (""
""CASE ""
""WHEN error_data ->> \'proc_schema\' = \'_timescaledb_internal\'""
"" AND error_data ->> \'proc_name\' ~ ""
""\'^policy_(retention|compression|reorder|refresh_continuous_""
""aggregate|telemetry|job_error_retention)$\' ""
""THEN error_data ->> \'proc_name\' ""
""ELSE \'user_defined_action\'""
""END""
"") as job_type, ""
""error_data ->> \'sqlerrcode\' as sqlerrcode, ""
""pg_catalog.COUNT(*) ""
""FROM ""
""_timescaledb_internal.job_errors ""
""WHERE error_data ->> \'sqlerrcode\' IS NOT NULL ""
""GROUP BY job_type, error_data->> \'sqlerrcode\' ""
""ORDER BY job_type""
"") q ""
""GROUP BY q.job_type"";
if (SPI_connect() != VAR_7)
elog(VAR_8, ""could not connect to SPI"");
VAR_1 = SPI_exec(""SET search_path TO pg_catalog, pg_temp"", 0);
if (VAR_1 < 0)
ereport(VAR_8, (errcode(VAR_9), (errmsg(""could not set search_path""))));
VAR_2 = makeStringInfo();
appendStringInfoString(VAR_2, VAR_6);
VAR_1 = SPI_execute(VAR_2->data, true , 0 );
if (VAR_1 < 0)
ereport(VAR_8,
(errcode(VAR_9),
(errmsg(""could not get errors by sqlerrcode and job type""))));
for (uint64 VAR_10 = 0; VAR_10 < VAR_11; VAR_10++)
{
Datum VAR_12, VAR_13;
bool VAR_14, VAR_15;
VAR_12 =
SPI_getbinval(VAR_16->vals[VAR_10], VAR_16->tupdesc, 1, &VAR_14);
if (VAR_14)
elog(VAR_8, ""null job type returned"");
VAR_13 =
SPI_getbinval(VAR_16->vals[VAR_10], VAR_16->tupdesc, 2, &VAR_15);
Jsonb *VAR_17 = VAR_15 ? NULL : DatumGetJsonbP(VAR_13);
if (VAR_17 == NULL)
continue;
VAR_5 = MemoryContextSwitchTo(VAR_3);
add_errors_by_sqlerrcode_internal(VAR_0,
TextDatumGetCString(VAR_12),
VAR_17);
VAR_3 = MemoryContextSwitchTo(VAR_5);
}
VAR_1 = SPI_exec(""RESET search_path"", 0);
VAR_1 = SPI_finish();
Assert(VAR_1 == VAR_18);
}",timescale/timescaledb/014b40fb7e8d59087cf1c1988a68dd1979f86cb3/telemetry.c/vul/before/0.json,"static void
add_errors_by_sqlerrcode(JsonbParseState *parse_state)
{
	int res;
	StringInfo command;
	MemoryContext old_context = CurrentMemoryContext, spi_context;

	const char *command_string =
		""SELECT ""
		""job_type, jsonb_object_agg(sqlerrcode, count) ""
		""FROM""
		""(""
		""	SELECT (""
		""		CASE ""
		""			WHEN error_data ->> \'proc_schema\' = \'_timescaledb_internal\'""
		"" 			AND error_data ->> \'proc_name\' ~ ""
		""\'^policy_(retention|compression|reorder|refresh_continuous_""
		""aggregate|telemetry|job_error_retention)$\' ""
		""			THEN error_data ->> \'proc_name\' ""
		""			ELSE \'user_defined_action\'""
		""		END""
		""	) as job_type, ""
		""	error_data ->> \'sqlerrcode\' as sqlerrcode, ""
		""	pg_catalog.COUNT(*) ""
		""	FROM ""
		""	_timescaledb_internal.job_errors ""
		""	WHERE error_data ->> \'sqlerrcode\' IS NOT NULL ""
		""	GROUP BY job_type, error_data->> \'sqlerrcode\' ""
		""	ORDER BY job_type""
		"") q ""
		""GROUP BY q.job_type"";

	if (SPI_connect() != SPI_OK_CONNECT)
		elog(ERROR, ""could not connect to SPI"");

	/* Lock down search_path */
	res = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
	if (res < 0)
		ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));

	command = makeStringInfo();

	appendStringInfoString(command, command_string);
	res = SPI_execute(command->data, true /*read only*/, 0 /* count */);
	if (res < 0)
		ereport(ERROR,
				(errcode(ERRCODE_INTERNAL_ERROR),
				 (errmsg(""could not get errors by sqlerrcode and job type""))));

	/* we expect about 6 rows returned, each row is a record (TEXT, JSONB) */
	for (uint64 i = 0; i < SPI_processed; i++)
	{
		Datum record_jobtype, record_jsonb;
		bool isnull_jobtype, isnull_jsonb;

		record_jobtype =
			SPI_getbinval(SPI_tuptable->vals[i], SPI_tuptable->tupdesc, 1, &isnull_jobtype);
		if (isnull_jobtype)
			elog(ERROR, ""null job type returned"");
		record_jsonb =
			SPI_getbinval(SPI_tuptable->vals[i], SPI_tuptable->tupdesc, 2, &isnull_jsonb);
		/* this jsonb looks like {""P0001"": 32, ""42883"": 6} */
		Jsonb *sqlerrs_jsonb = isnull_jsonb ? NULL : DatumGetJsonbP(record_jsonb);

		if (sqlerrs_jsonb == NULL)
			continue;
		/* the jsonb object cannot be created in the SPI context or it will be lost */
		spi_context = MemoryContextSwitchTo(old_context);
		add_errors_by_sqlerrcode_internal(parse_state,
										  TextDatumGetCString(record_jobtype),
										  sqlerrs_jsonb);
		old_context = MemoryContextSwitchTo(spi_context);
	}

	res = SPI_finish();

	Assert(res == SPI_OK_FINISH);
}","static void
add_errors_by_sqlerrcode(JsonbParseState *VAR_0)
{
	int VAR_1;
	StringInfo VAR_2;
	MemoryContext VAR_3 = VAR_4, VAR_5;

	const char *VAR_6 =
		""SELECT ""
		""job_type, jsonb_object_agg(sqlerrcode, count) ""
		""FROM""
		""(""
		""	SELECT (""
		""		CASE ""
		""			WHEN error_data ->> \'proc_schema\' = \'_timescaledb_internal\'""
		"" 			AND error_data ->> \'proc_name\' ~ ""
		""\'^policy_(retention|compression|reorder|refresh_continuous_""
		""aggregate|telemetry|job_error_retention)$\' ""
		""			THEN error_data ->> \'proc_name\' ""
		""			ELSE \'user_defined_action\'""
		""		END""
		""	) as job_type, ""
		""	error_data ->> \'sqlerrcode\' as sqlerrcode, ""
		""	pg_catalog.COUNT(*) ""
		""	FROM ""
		""	_timescaledb_internal.job_errors ""
		""	WHERE error_data ->> \'sqlerrcode\' IS NOT NULL ""
		""	GROUP BY job_type, error_data->> \'sqlerrcode\' ""
		""	ORDER BY job_type""
		"") q ""
		""GROUP BY q.job_type"";

	if (SPI_connect() != VAR_7)
		elog(VAR_8, ""could not connect to SPI"");

	/* COMMENT_0 */
	VAR_1 = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
	if (VAR_1 < 0)
		ereport(VAR_8, (errcode(VAR_9), (errmsg(""could not set search_path""))));

	VAR_2 = makeStringInfo();

	appendStringInfoString(VAR_2, VAR_6);
	VAR_1 = SPI_execute(VAR_2->data, true /* COMMENT_1 */, 0 /* COMMENT_2 */);
	if (VAR_1 < 0)
		ereport(VAR_8,
				(errcode(VAR_9),
				 (errmsg(""could not get errors by sqlerrcode and job type""))));

	/* COMMENT_3 */
	for (uint64 VAR_10 = 0; VAR_10 < VAR_11; VAR_10++)
	{
		Datum VAR_12, VAR_13;
		bool VAR_14, VAR_15;

		VAR_12 =
			SPI_getbinval(VAR_16->vals[VAR_10], VAR_16->tupdesc, 1, &VAR_14);
		if (VAR_14)
			elog(VAR_8, ""null job type returned"");
		VAR_13 =
			SPI_getbinval(VAR_16->vals[VAR_10], VAR_16->tupdesc, 2, &VAR_15);
		/* COMMENT_4 */
		Jsonb *VAR_17 = VAR_15 ? NULL : DatumGetJsonbP(VAR_13);

		if (VAR_17 == NULL)
			continue;
		/* COMMENT_5 */
		VAR_5 = MemoryContextSwitchTo(VAR_3);
		add_errors_by_sqlerrcode_internal(VAR_0,
										  TextDatumGetCString(VAR_12),
										  VAR_17);
		VAR_3 = MemoryContextSwitchTo(VAR_5);
	}

	VAR_1 = SPI_finish();

	Assert(VAR_1 == VAR_18);
}",timescale/timescaledb/014b40fb7e8d59087cf1c1988a68dd1979f86cb3/telemetry.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -33,8 +33,8 @@
 	if (SPI_connect() != SPI_OK_CONNECT)
 		elog(ERROR, ""could not connect to SPI"");
 
-	/* SPI calls must be qualified otherwise they are unsafe */
-	res = SPI_exec(""SET search_path TO pg_catalog, pg_temp"", 0);
+	/* Lock down search_path */
+	res = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
 	if (res < 0)
 		ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));
 
@@ -72,7 +72,6 @@
 		old_context = MemoryContextSwitchTo(spi_context);
 	}
 
-	res = SPI_exec(""RESET search_path"", 0);
 	res = SPI_finish();
 
 	Assert(res == SPI_OK_FINISH);","{'deleted_lines': ['\t/* SPI calls must be qualified otherwise they are unsafe */', '\tres = SPI_exec(""SET search_path TO pg_catalog, pg_temp"", 0);', '\tres = SPI_exec(""RESET search_path"", 0);'], 'added_lines': ['\t/* Lock down search_path */', '\tres = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);']}",True,"TimescaleDB, an open-source time-series SQL database, has a privilege escalation vulnerability in versions 2.8.0 through 2.9.2. During installation, TimescaleDB creates a telemetry job that is runs as the installation user. The queries run as part of the telemetry data collection were not run with a locked down `search_path`, allowing malicious users to create functions that would be executed by the telemetry job, leading to privilege escalation. In order to be able to take advantage of this vulnerability, a user would need to be able to create objects in a database and then get a superuser to install TimescaleDB into their database. When TimescaleDB is installed as trusted extension, non-superusers can install the extension without help from a superuser.

Version 2.9.3 fixes this issue. As a mitigation, the `search_path` of the user running the telemetry job can be locked down to not include schemas writable by other users. The vulnerability is not exploitable on instances in Timescale Cloud and Managed Service for TimescaleDB due to additional security provisions in place on those platforms.",8.8,HIGH,2,test,2023-01-31T12:59:48Z,4
CVE-2023-25149,['CWE-269'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,timescale/timescaledb,Lock down search_path in SPI calls,014b40fb7e8d59087cf1c1988a68dd1979f86cb3,https://github.com/timescale/timescaledb/commit/014b40fb7e8d59087cf1c1988a68dd1979f86cb3,src/telemetry/telemetry.c,add_job_stats_by_job_type,"static void
add_job_stats_by_job_type(JsonbParseState *parse_state)
{
StringInfo command;
int res;
MemoryContext old_context = CurrentMemoryContext, spi_context;
SPITupleTable *tuptable = NULL;
const char *command_string =
""SELECT (""
""CASE ""
""WHEN j.proc_schema = \'_timescaledb_internal\' AND j.proc_name ~ ""
""\'^policy_(retention|compression|reorder|refresh_continuous_aggregate|telemetry|job_error_""
""retention)$\' ""
""THEN j.proc_name::TEXT ""
""ELSE \'user_defined_action\' ""
""END""
"")  AS job_type, ""
""SUM(total_runs)::BIGINT AS total_runs, ""
""SUM(total_successes)::BIGINT AS total_successes, ""
""SUM(total_failures)::BIGINT AS total_failures, ""
""SUM(total_crashes)::BIGINT AS total_crashes, ""
""SUM(total_duration) AS total_duration, ""
""SUM(total_duration_failures) AS total_duration_failures, ""
""MAX(consecutive_failures) AS max_consecutive_failures, ""
""MAX(consecutive_crashes) AS max_consecutive_crashes ""
""FROM ""
""_timescaledb_internal.bgw_job_stat s ""
""JOIN _timescaledb_config.bgw_job j on j.id = s.job_id ""
""GROUP BY ""
""job_type"";
if (SPI_connect() != SPI_OK_CONNECT)
elog(ERROR, ""could not connect to SPI"");
res = SPI_exec(""SET search_path TO pg_catalog, pg_temp"", 0);
if (res < 0)
ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));
command = makeStringInfo();
appendStringInfoString(command, command_string);
res = SPI_execute(command->data, true , 0 );
if (res < 0)
ereport(ERROR,
(errcode(ERRCODE_INTERNAL_ERROR),
(errmsg(""could not get job statistics by job type""))));
for (uint64 i = 0; i < SPI_processed; i++)
{
tuptable = SPI_tuptable;
TupleDesc tupdesc = tuptable->tupdesc;
Datum jobtype_datum;
Datum total_runs, total_successes, total_failures, total_crashes;
Datum total_duration, total_duration_failures, max_consec_crashes, max_consec_fails;
bool isnull_jobtype, isnull_runs, isnull_successes, isnull_failures, isnull_crashes;
bool isnull_duration, isnull_duration_failures, isnull_consec_crashes, isnull_consec_fails;
jobtype_datum =
SPI_getbinval(SPI_tuptable->vals[i], SPI_tuptable->tupdesc, 1, &isnull_jobtype);
if (isnull_jobtype)
elog(ERROR, ""null job type returned"");
total_runs = SPI_getbinval(tuptable->vals[i], tupdesc, 2, &isnull_runs);
total_successes = SPI_getbinval(tuptable->vals[i], tupdesc, 3, &isnull_successes);
total_failures = SPI_getbinval(tuptable->vals[i], tupdesc, 4, &isnull_failures);
total_crashes = SPI_getbinval(tuptable->vals[i], tupdesc, 5, &isnull_crashes);
total_duration = SPI_getbinval(tuptable->vals[i], tupdesc, 6, &isnull_duration);
total_duration_failures =
SPI_getbinval(tuptable->vals[i], tupdesc, 7, &isnull_duration_failures);
max_consec_fails = SPI_getbinval(tuptable->vals[i], tupdesc, 8, &isnull_consec_fails);
max_consec_crashes = SPI_getbinval(tuptable->vals[i], tupdesc, 9, &isnull_consec_crashes);
if (isnull_jobtype || isnull_runs || isnull_successes || isnull_failures ||
isnull_crashes || isnull_duration || isnull_consec_crashes || isnull_consec_fails)
{
elog(ERROR, ""null record field returned"");
}
spi_context = MemoryContextSwitchTo(old_context);
TelemetryJobStats stats = { .total_runs = DatumGetInt64(total_runs),
.total_successes = DatumGetInt64(total_successes),
.total_failures = DatumGetInt64(total_failures),
.total_crashes = DatumGetInt64(total_crashes),
.max_consecutive_failures = DatumGetInt32(max_consec_fails),
.max_consecutive_crashes = DatumGetInt32(max_consec_crashes),
.total_duration = DatumGetIntervalP(total_duration),
.total_duration_failures =
DatumGetIntervalP(total_duration_failures) };
add_job_stats_internal(parse_state, TextDatumGetCString(jobtype_datum), &stats);
old_context = MemoryContextSwitchTo(spi_context);
}
res = SPI_exec(""RESET search_path"", 0);
res = SPI_finish();
Assert(res == SPI_OK_FINISH);
}","static void
add_job_stats_by_job_type(JsonbParseState *VAR_0)
{
StringInfo VAR_1;
int VAR_2;
MemoryContext VAR_3 = VAR_4, VAR_5;
SPITupleTable *VAR_6 = NULL;
const char *VAR_7 =
""SELECT (""
""CASE ""
""WHEN j.proc_schema = \'_timescaledb_internal\' AND j.proc_name ~ ""
""\'^policy_(retention|compression|reorder|refresh_continuous_aggregate|telemetry|job_error_""
""retention)$\' ""
""THEN j.proc_name::TEXT ""
""ELSE \'user_defined_action\' ""
""END""
"")  AS job_type, ""
""SUM(total_runs)::BIGINT AS total_runs, ""
""SUM(total_successes)::BIGINT AS total_successes, ""
""SUM(total_failures)::BIGINT AS total_failures, ""
""SUM(total_crashes)::BIGINT AS total_crashes, ""
""SUM(total_duration) AS total_duration, ""
""SUM(total_duration_failures) AS total_duration_failures, ""
""MAX(consecutive_failures) AS max_consecutive_failures, ""
""MAX(consecutive_crashes) AS max_consecutive_crashes ""
""FROM ""
""_timescaledb_internal.bgw_job_stat s ""
""JOIN _timescaledb_config.bgw_job j on j.id = s.job_id ""
""GROUP BY ""
""job_type"";
if (SPI_connect() != VAR_8)
elog(VAR_9, ""could not connect to SPI"");
VAR_2 = SPI_exec(""SET search_path TO pg_catalog, pg_temp"", 0);
if (VAR_2 < 0)
ereport(VAR_9, (errcode(VAR_10), (errmsg(""could not set search_path""))));
VAR_1 = makeStringInfo();
appendStringInfoString(VAR_1, VAR_7);
VAR_2 = SPI_execute(VAR_1->data, true , 0 );
if (VAR_2 < 0)
ereport(VAR_9,
(errcode(VAR_10),
(errmsg(""could not get job statistics by job type""))));
for (uint64 VAR_11 = 0; VAR_11 < VAR_12; VAR_11++)
{
VAR_6 = VAR_13;
TupleDesc VAR_14 = VAR_6->tupdesc;
Datum VAR_15;
Datum VAR_16, VAR_17, VAR_18, VAR_19;
Datum VAR_20, VAR_21, VAR_22, VAR_23;
bool VAR_24, VAR_25, VAR_26, VAR_27, VAR_28;
bool VAR_29, VAR_30, VAR_31, VAR_32;
VAR_15 =
SPI_getbinval(VAR_13->vals[VAR_11], VAR_13->tupdesc, 1, &VAR_24);
if (VAR_24)
elog(VAR_9, ""null job type returned"");
VAR_16 = SPI_getbinval(VAR_6->vals[VAR_11], VAR_14, 2, &VAR_25);
VAR_17 = SPI_getbinval(VAR_6->vals[VAR_11], VAR_14, 3, &VAR_26);
VAR_18 = SPI_getbinval(VAR_6->vals[VAR_11], VAR_14, 4, &VAR_27);
VAR_19 = SPI_getbinval(VAR_6->vals[VAR_11], VAR_14, 5, &VAR_28);
VAR_20 = SPI_getbinval(VAR_6->vals[VAR_11], VAR_14, 6, &VAR_29);
VAR_21 =
SPI_getbinval(VAR_6->vals[VAR_11], VAR_14, 7, &VAR_30);
VAR_23 = SPI_getbinval(VAR_6->vals[VAR_11], VAR_14, 8, &VAR_32);
VAR_22 = SPI_getbinval(VAR_6->vals[VAR_11], VAR_14, 9, &VAR_31);
if (VAR_24 || VAR_25 || VAR_26 || VAR_27 ||
VAR_28 || VAR_29 || VAR_31 || VAR_32)
{
elog(VAR_9, ""null record field returned"");
}
VAR_5 = MemoryContextSwitchTo(VAR_3);
TelemetryJobStats VAR_33 = { .total_runs = DatumGetInt64(VAR_16),
.total_successes = DatumGetInt64(VAR_17),
.total_failures = DatumGetInt64(VAR_18),
.total_crashes = DatumGetInt64(VAR_19),
.max_consecutive_failures = DatumGetInt32(VAR_23),
.max_consecutive_crashes = DatumGetInt32(VAR_22),
.total_duration = DatumGetIntervalP(VAR_20),
.total_duration_failures =
DatumGetIntervalP(VAR_21) };
add_job_stats_internal(VAR_0, TextDatumGetCString(VAR_15), &VAR_33);
VAR_3 = MemoryContextSwitchTo(VAR_5);
}
VAR_2 = SPI_exec(""RESET search_path"", 0);
VAR_2 = SPI_finish();
Assert(VAR_2 == VAR_34);
}",timescale/timescaledb/014b40fb7e8d59087cf1c1988a68dd1979f86cb3/telemetry.c/vul/before/1.json,"static void
add_job_stats_by_job_type(JsonbParseState *parse_state)
{
	StringInfo command;
	int res;
	MemoryContext old_context = CurrentMemoryContext, spi_context;
	SPITupleTable *tuptable = NULL;

	const char *command_string =
		""SELECT (""
		""	CASE ""
		""		WHEN j.proc_schema = \'_timescaledb_internal\' AND j.proc_name ~ ""
		""\'^policy_(retention|compression|reorder|refresh_continuous_aggregate|telemetry|job_error_""
		""retention)$\' ""
		""		THEN j.proc_name::TEXT ""
		""		ELSE \'user_defined_action\' ""
		""	END""
		"")  AS job_type, ""
		""	SUM(total_runs)::BIGINT AS total_runs, ""
		""	SUM(total_successes)::BIGINT AS total_successes, ""
		""	SUM(total_failures)::BIGINT AS total_failures, ""
		""	SUM(total_crashes)::BIGINT AS total_crashes, ""
		""	SUM(total_duration) AS total_duration, ""
		""	SUM(total_duration_failures) AS total_duration_failures, ""
		""	MAX(consecutive_failures) AS max_consecutive_failures, ""
		""	MAX(consecutive_crashes) AS max_consecutive_crashes ""
		""FROM ""
		""	_timescaledb_internal.bgw_job_stat s ""
		""	JOIN _timescaledb_config.bgw_job j on j.id = s.job_id ""
		""GROUP BY ""
		""job_type"";

	if (SPI_connect() != SPI_OK_CONNECT)
		elog(ERROR, ""could not connect to SPI"");

	/* Lock down search_path */
	res = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
	if (res < 0)
		ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));

	command = makeStringInfo();

	appendStringInfoString(command, command_string);
	res = SPI_execute(command->data, true /* read_only */, 0 /*count*/);
	if (res < 0)
		ereport(ERROR,
				(errcode(ERRCODE_INTERNAL_ERROR),
				 (errmsg(""could not get job statistics by job type""))));
	/*
	 * a row returned looks like this:
	 * (job_type, total_runs, total_successes, total_failures, total_crashes, total_duration,
	 * total_duration_failures, max_consec_fails, max_consec_crashes)
	 * (""policy_telemetry"", 12, 10, 1, 1, 00:00:11, 00:00:01, 1, 1)
	 */
	for (uint64 i = 0; i < SPI_processed; i++)
	{
		tuptable = SPI_tuptable;
		TupleDesc tupdesc = tuptable->tupdesc;
		Datum jobtype_datum;
		Datum total_runs, total_successes, total_failures, total_crashes;
		Datum total_duration, total_duration_failures, max_consec_crashes, max_consec_fails;

		bool isnull_jobtype, isnull_runs, isnull_successes, isnull_failures, isnull_crashes;
		bool isnull_duration, isnull_duration_failures, isnull_consec_crashes, isnull_consec_fails;

		jobtype_datum =
			SPI_getbinval(SPI_tuptable->vals[i], SPI_tuptable->tupdesc, 1, &isnull_jobtype);
		if (isnull_jobtype)
			elog(ERROR, ""null job type returned"");
		total_runs = SPI_getbinval(tuptable->vals[i], tupdesc, 2, &isnull_runs);
		total_successes = SPI_getbinval(tuptable->vals[i], tupdesc, 3, &isnull_successes);
		total_failures = SPI_getbinval(tuptable->vals[i], tupdesc, 4, &isnull_failures);
		total_crashes = SPI_getbinval(tuptable->vals[i], tupdesc, 5, &isnull_crashes);
		total_duration = SPI_getbinval(tuptable->vals[i], tupdesc, 6, &isnull_duration);
		total_duration_failures =
			SPI_getbinval(tuptable->vals[i], tupdesc, 7, &isnull_duration_failures);
		max_consec_fails = SPI_getbinval(tuptable->vals[i], tupdesc, 8, &isnull_consec_fails);
		max_consec_crashes = SPI_getbinval(tuptable->vals[i], tupdesc, 9, &isnull_consec_crashes);

		if (isnull_jobtype || isnull_runs || isnull_successes || isnull_failures ||
			isnull_crashes || isnull_duration || isnull_consec_crashes || isnull_consec_fails)
		{
			elog(ERROR, ""null record field returned"");
		}

		spi_context = MemoryContextSwitchTo(old_context);
		TelemetryJobStats stats = { .total_runs = DatumGetInt64(total_runs),
									.total_successes = DatumGetInt64(total_successes),
									.total_failures = DatumGetInt64(total_failures),
									.total_crashes = DatumGetInt64(total_crashes),
									.max_consecutive_failures = DatumGetInt32(max_consec_fails),
									.max_consecutive_crashes = DatumGetInt32(max_consec_crashes),
									.total_duration = DatumGetIntervalP(total_duration),
									.total_duration_failures =
										DatumGetIntervalP(total_duration_failures) };
		add_job_stats_internal(parse_state, TextDatumGetCString(jobtype_datum), &stats);
		old_context = MemoryContextSwitchTo(spi_context);
	}
	res = SPI_finish();
	Assert(res == SPI_OK_FINISH);
}","static void
add_job_stats_by_job_type(JsonbParseState *VAR_0)
{
	StringInfo VAR_1;
	int VAR_2;
	MemoryContext VAR_3 = VAR_4, VAR_5;
	SPITupleTable *VAR_6 = NULL;

	const char *VAR_7 =
		""SELECT (""
		""	CASE ""
		""		WHEN j.proc_schema = \'_timescaledb_internal\' AND j.proc_name ~ ""
		""\'^policy_(retention|compression|reorder|refresh_continuous_aggregate|telemetry|job_error_""
		""retention)$\' ""
		""		THEN j.proc_name::TEXT ""
		""		ELSE \'user_defined_action\' ""
		""	END""
		"")  AS job_type, ""
		""	SUM(total_runs)::BIGINT AS total_runs, ""
		""	SUM(total_successes)::BIGINT AS total_successes, ""
		""	SUM(total_failures)::BIGINT AS total_failures, ""
		""	SUM(total_crashes)::BIGINT AS total_crashes, ""
		""	SUM(total_duration) AS total_duration, ""
		""	SUM(total_duration_failures) AS total_duration_failures, ""
		""	MAX(consecutive_failures) AS max_consecutive_failures, ""
		""	MAX(consecutive_crashes) AS max_consecutive_crashes ""
		""FROM ""
		""	_timescaledb_internal.bgw_job_stat s ""
		""	JOIN _timescaledb_config.bgw_job j on j.id = s.job_id ""
		""GROUP BY ""
		""job_type"";

	if (SPI_connect() != VAR_8)
		elog(VAR_9, ""could not connect to SPI"");

	/* COMMENT_0 */
	VAR_2 = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
	if (VAR_2 < 0)
		ereport(VAR_9, (errcode(VAR_10), (errmsg(""could not set search_path""))));

	VAR_1 = makeStringInfo();

	appendStringInfoString(VAR_1, VAR_7);
	VAR_2 = SPI_execute(VAR_1->data, true /* COMMENT_1 */, 0 /* COMMENT_2 */);
	if (VAR_2 < 0)
		ereport(VAR_9,
				(errcode(VAR_10),
				 (errmsg(""could not get job statistics by job type""))));
	/* COMMENT_3 */
                                   
                                                                                          
                                                                  
                                                                
    
	for (uint64 VAR_11 = 0; VAR_11 < VAR_12; VAR_11++)
	{
		VAR_6 = VAR_13;
		TupleDesc VAR_14 = VAR_6->tupdesc;
		Datum VAR_15;
		Datum VAR_16, VAR_17, VAR_18, VAR_19;
		Datum VAR_20, VAR_21, VAR_22, VAR_23;

		bool VAR_24, VAR_25, VAR_26, VAR_27, VAR_28;
		bool VAR_29, VAR_30, VAR_31, VAR_32;

		VAR_15 =
			SPI_getbinval(VAR_13->vals[VAR_11], VAR_13->tupdesc, 1, &VAR_24);
		if (VAR_24)
			elog(VAR_9, ""null job type returned"");
		VAR_16 = SPI_getbinval(VAR_6->vals[VAR_11], VAR_14, 2, &VAR_25);
		VAR_17 = SPI_getbinval(VAR_6->vals[VAR_11], VAR_14, 3, &VAR_26);
		VAR_18 = SPI_getbinval(VAR_6->vals[VAR_11], VAR_14, 4, &VAR_27);
		VAR_19 = SPI_getbinval(VAR_6->vals[VAR_11], VAR_14, 5, &VAR_28);
		VAR_20 = SPI_getbinval(VAR_6->vals[VAR_11], VAR_14, 6, &VAR_29);
		VAR_21 =
			SPI_getbinval(VAR_6->vals[VAR_11], VAR_14, 7, &VAR_30);
		VAR_23 = SPI_getbinval(VAR_6->vals[VAR_11], VAR_14, 8, &VAR_32);
		VAR_22 = SPI_getbinval(VAR_6->vals[VAR_11], VAR_14, 9, &VAR_31);

		if (VAR_24 || VAR_25 || VAR_26 || VAR_27 ||
			VAR_28 || VAR_29 || VAR_31 || VAR_32)
		{
			elog(VAR_9, ""null record field returned"");
		}

		VAR_5 = MemoryContextSwitchTo(VAR_3);
		TelemetryJobStats VAR_33 = { .total_runs = DatumGetInt64(VAR_16),
									.total_successes = DatumGetInt64(VAR_17),
									.total_failures = DatumGetInt64(VAR_18),
									.total_crashes = DatumGetInt64(VAR_19),
									.max_consecutive_failures = DatumGetInt32(VAR_23),
									.max_consecutive_crashes = DatumGetInt32(VAR_22),
									.total_duration = DatumGetIntervalP(VAR_20),
									.total_duration_failures =
										DatumGetIntervalP(VAR_21) };
		add_job_stats_internal(VAR_0, TextDatumGetCString(VAR_15), &VAR_33);
		VAR_3 = MemoryContextSwitchTo(VAR_5);
	}
	VAR_2 = SPI_finish();
	Assert(VAR_2 == VAR_34);
}",timescale/timescaledb/014b40fb7e8d59087cf1c1988a68dd1979f86cb3/telemetry.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -33,8 +33,8 @@
 	if (SPI_connect() != SPI_OK_CONNECT)
 		elog(ERROR, ""could not connect to SPI"");
 
-	/* SPI calls must be qualified otherwise they are unsafe */
-	res = SPI_exec(""SET search_path TO pg_catalog, pg_temp"", 0);
+	/* Lock down search_path */
+	res = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);
 	if (res < 0)
 		ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""could not set search_path""))));
 
@@ -96,7 +96,6 @@
 		add_job_stats_internal(parse_state, TextDatumGetCString(jobtype_datum), &stats);
 		old_context = MemoryContextSwitchTo(spi_context);
 	}
-	res = SPI_exec(""RESET search_path"", 0);
 	res = SPI_finish();
 	Assert(res == SPI_OK_FINISH);
 }","{'deleted_lines': ['\t/* SPI calls must be qualified otherwise they are unsafe */', '\tres = SPI_exec(""SET search_path TO pg_catalog, pg_temp"", 0);', '\tres = SPI_exec(""RESET search_path"", 0);'], 'added_lines': ['\t/* Lock down search_path */', '\tres = SPI_exec(""SET LOCAL search_path TO pg_catalog, pg_temp"", 0);']}",True,"TimescaleDB, an open-source time-series SQL database, has a privilege escalation vulnerability in versions 2.8.0 through 2.9.2. During installation, TimescaleDB creates a telemetry job that is runs as the installation user. The queries run as part of the telemetry data collection were not run with a locked down `search_path`, allowing malicious users to create functions that would be executed by the telemetry job, leading to privilege escalation. In order to be able to take advantage of this vulnerability, a user would need to be able to create objects in a database and then get a superuser to install TimescaleDB into their database. When TimescaleDB is installed as trusted extension, non-superusers can install the extension without help from a superuser.

Version 2.9.3 fixes this issue. As a mitigation, the `search_path` of the user running the telemetry job can be locked down to not include schemas writable by other users. The vulnerability is not exploitable on instances in Timescale Cloud and Managed Service for TimescaleDB due to additional security provisions in place on those platforms.",8.8,HIGH,2,test,2023-01-31T12:59:48Z,4
CVE-2023-25193,['CWE-770'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,harfbuzz,"[layout] Limit how far we skip when looking back

See comments.",85be877925ddbf34f74a1229f3ca1716bb6170dc,https://github.com/harfbuzz/harfbuzz/commit/85be877925ddbf34f74a1229f3ca1716bb6170dc,src/hb-ot-layout-gsubgpos.hh,prev,"bool prev (unsigned *unsafe_from = nullptr)
{
assert (num_items > 0);
unsigned stop = num_items - 1;
if (c->buffer->flags & HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT)
stop = 1 - 1;
while (idx > stop)
{
idx--;
hb_glyph_info_t &info = c->buffer->out_info[idx];
matcher_t::may_skip_t skip = matcher.may_skip (c, info);
if (unlikely (skip == matcher_t::SKIP_YES))
continue;
matcher_t::may_match_t match = matcher.may_match (info, get_glyph_data ());
if (match == matcher_t::MATCH_YES ||
(match == matcher_t::MATCH_MAYBE &&
skip == matcher_t::SKIP_NO))
{
num_items--;
advance_glyph_data ();
return true;
}
if (skip == matcher_t::SKIP_NO)
{
if (unsafe_from)
*unsafe_from = hb_max (1u, idx) - 1u;
return false;
}
}
if (unsafe_from)
*unsafe_from = 0;
return false;
}","bool prev (unsigned *VAR_0 = nullptr)
{
assert (VAR_1 > 0);
unsigned VAR_2 = VAR_1 - 1;
if (VAR_3->buffer->flags & VAR_4)
VAR_2 = 1 - 1;
while (VAR_5 > VAR_2)
{
VAR_5--;
hb_glyph_info_t &VAR_6 = VAR_3->buffer->out_info[VAR_5];
matcher_t::may_skip_t VAR_7 = VAR_8.may_skip (VAR_3, VAR_6);
if (unlikely (VAR_7 == matcher_t::SKIP_YES))
continue;
matcher_t::may_match_t VAR_9 = VAR_8.may_match (VAR_6, get_glyph_data ());
if (VAR_9 == matcher_t::MATCH_YES ||
(VAR_9 == matcher_t::MATCH_MAYBE &&
VAR_7 == matcher_t::SKIP_NO))
{
VAR_1--;
advance_glyph_data ();
return true;
}
if (VAR_7 == matcher_t::SKIP_NO)
{
if (VAR_0)
*VAR_0 = hb_max (1u, VAR_5) - 1u;
return false;
}
}
if (VAR_0)
*VAR_0 = 0;
return false;
}",harfbuzz/85be877925ddbf34f74a1229f3ca1716bb6170dc/hb-ot-layout-gsubgpos.hh/vul/before/0.json,"bool prev (unsigned *unsafe_from = nullptr)
    {
      assert (num_items > 0);
      /* The alternate condition below is faster at string boundaries,
       * but produces subpar ""unsafe-to-concat"" values. */
      unsigned stop = num_items - 1;
      if (c->buffer->flags & HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT)
        stop = 1 - 1;

      /* When looking back, limit how far we search; this function is mostly
       * used for looking back for base glyphs when attaching marks. If we
       * don't limit, we can get O(n^2) behavior where n is the number of
       * consecutive marks. */
      stop = (unsigned) hb_max ((int) stop, (int) idx - HB_MAX_CONTEXT_LENGTH);

      while (idx > stop)
      {
	idx--;
	hb_glyph_info_t &info = c->buffer->out_info[idx];

	matcher_t::may_skip_t skip = matcher.may_skip (c, info);
	if (unlikely (skip == matcher_t::SKIP_YES))
	  continue;

	matcher_t::may_match_t match = matcher.may_match (info, get_glyph_data ());
	if (match == matcher_t::MATCH_YES ||
	    (match == matcher_t::MATCH_MAYBE &&
	     skip == matcher_t::SKIP_NO))
	{
	  num_items--;
	  advance_glyph_data ();
	  return true;
	}

	if (skip == matcher_t::SKIP_NO)
	{
	  if (unsafe_from)
	    *unsafe_from = hb_max (1u, idx) - 1u;
	  return false;
	}
      }
      if (unsafe_from)
        *unsafe_from = 0;
      return false;
    }","bool prev (unsigned *VAR_0 = nullptr)
    {
      assert (VAR_1 > 0);
      /* COMMENT_0 */
                                                          
      unsigned VAR_2 = VAR_1 - 1;
      if (VAR_3->buffer->flags & VAR_4)
        VAR_2 = 1 - 1;

      /* COMMENT_2 */
                                                                          
                                                                         
                              
      VAR_2 = (unsigned) hb_max ((int) VAR_2, (int) VAR_5 - VAR_6);

      while (VAR_5 > VAR_2)
      {
	VAR_5--;
	hb_glyph_info_t &VAR_7 = VAR_3->buffer->out_info[VAR_5];

	matcher_t::may_skip_t VAR_8 = VAR_9.may_skip (VAR_3, VAR_7);
	if (unlikely (VAR_8 == matcher_t::SKIP_YES))
	  continue;

	matcher_t::may_match_t VAR_10 = VAR_9.may_match (VAR_7, get_glyph_data ());
	if (VAR_10 == matcher_t::MATCH_YES ||
	    (VAR_10 == matcher_t::MATCH_MAYBE &&
	     VAR_8 == matcher_t::SKIP_NO))
	{
	  VAR_1--;
	  advance_glyph_data ();
	  return true;
	}

	if (VAR_8 == matcher_t::SKIP_NO)
	{
	  if (VAR_0)
	    *VAR_0 = hb_max (1u, VAR_5) - 1u;
	  return false;
	}
      }
      if (VAR_0)
        *VAR_0 = 0;
      return false;
    }",harfbuzz/85be877925ddbf34f74a1229f3ca1716bb6170dc/hb-ot-layout-gsubgpos.hh/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,6 +6,13 @@
       unsigned stop = num_items - 1;
       if (c->buffer->flags & HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT)
         stop = 1 - 1;
+
+      /* When looking back, limit how far we search; this function is mostly
+       * used for looking back for base glyphs when attaching marks. If we
+       * don't limit, we can get O(n^2) behavior where n is the number of
+       * consecutive marks. */
+      stop = (unsigned) hb_max ((int) stop, (int) idx - HB_MAX_CONTEXT_LENGTH);
+
       while (idx > stop)
       {
 	idx--;","{'deleted_lines': [], 'added_lines': ['', '      /* When looking back, limit how far we search; this function is mostly', '       * used for looking back for base glyphs when attaching marks. If we', ""       * don't limit, we can get O(n^2) behavior where n is the number of"", '       * consecutive marks. */', '      stop = (unsigned) hb_max ((int) stop, (int) idx - HB_MAX_CONTEXT_LENGTH);', '']}",True,hb-ot-layout-gsubgpos.hh in HarfBuzz through 6.0.0 allows attackers to trigger O(n^2) growth via consecutive marks during the process of looking back for base glyphs when attaching marks.,7.5,HIGH,2,test,2023-02-02T03:00:43Z,4
CVE-2023-24808,['CWE-835'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,michaelrsweet/pdfio,Fix denial-of-service attack when reading corrupt PDF files.,4f10021e7ee527c1aa24853e2947e38e154d9ccb,https://github.com/michaelrsweet/pdfio/commit/4f10021e7ee527c1aa24853e2947e38e154d9ccb,pdfio-common.c,_pdfioFileConsume,"bool_pdfioFileConsume(pdfio_file_t *pdf,                  size_t       bytes){
PDFIO_DEBUG(""_pdfioFileConsume(pdf=%p, bytes=%u)\n"", pdf, (unsigned)bytes);
if ((size_t)(pdf->bufend - pdf->bufptr) > bytes)
pdf->bufptr += bytes;
else if (_pdfioFileSeek(pdf, (off_t)bytes, SEEK_CUR) < 0)
return (false);
return (true);
}","bool
_pdfioFileConsume(pdfio_file_t *VAR_0,
size_t       VAR_1)
{
PDFIO_DEBUG(""_pdfioFileConsume(pdf=%p, bytes=%u)\n"", VAR_0, (unsigned)VAR_1);
if ((size_t)(VAR_0->bufend - VAR_0->bufptr) > VAR_1)
VAR_0->bufptr += VAR_1;
else if (_pdfioFileSeek(VAR_0, (off_t)VAR_1, VAR_2) < 0)
return (false);
return (true);
}",michaelrsweet/pdfio/4f10021e7ee527c1aa24853e2947e38e154d9ccb/pdfio-common.c/vul/before/0.json,"bool					// O - `true` on sucess, `false` on EOF
_pdfioFileConsume(pdfio_file_t *pdf,	// I - PDF file
                  size_t       bytes)	// I - Bytes to consume
{
  PDFIO_DEBUG(""_pdfioFileConsume(pdf=%p, bytes=%u)\n"", pdf, (unsigned)bytes);

  if ((size_t)(pdf->bufend - pdf->bufptr) > bytes)
    pdf->bufptr += bytes;
  else if (_pdfioFileSeek(pdf, (off_t)bytes, SEEK_CUR) < 0)
    return (false);

  PDFIO_DEBUG(""_pdfioFileConsume: pos=%ld\n"", (long)(pdf->bufpos + pdf->bufptr - pdf->buffer));

  return (true);
}","bool					/* COMMENT_0 */
_pdfioFileConsume(pdfio_file_t *VAR_0,	/* COMMENT_1 */
                  size_t       VAR_1)	/* COMMENT_2 */
{
  PDFIO_DEBUG(""_pdfioFileConsume(pdf=%p, bytes=%u)\n"", VAR_0, (unsigned)VAR_1);

  if ((size_t)(VAR_0->bufend - VAR_0->bufptr) > VAR_1)
    VAR_0->bufptr += VAR_1;
  else if (_pdfioFileSeek(VAR_0, (off_t)VAR_1, VAR_2) < 0)
    return (false);

  PDFIO_DEBUG(""_pdfioFileConsume: pos=%ld\n"", (long)(VAR_0->bufpos + VAR_0->bufptr - VAR_0->buffer));

  return (true);
}",michaelrsweet/pdfio/4f10021e7ee527c1aa24853e2947e38e154d9ccb/pdfio-common.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,5 +9,7 @@
   else if (_pdfioFileSeek(pdf, (off_t)bytes, SEEK_CUR) < 0)
     return (false);
 
+  PDFIO_DEBUG(""_pdfioFileConsume: pos=%ld\n"", (long)(pdf->bufpos + pdf->bufptr - pdf->buffer));
+
   return (true);
 }","{'deleted_lines': [], 'added_lines': ['  PDFIO_DEBUG(""_pdfioFileConsume: pos=%ld\\n"", (long)(pdf->bufpos + pdf->bufptr - pdf->buffer));', '']}",True, PDFio is a C library for reading and writing PDF files. In versions prior to 1.1.0 a denial of service (DOS) vulnerability exists in the pdfio parser. Crafted pdf files can cause the program to run at 100% utilization and never terminate. The pdf which causes this crash found in testing is about 28kb in size and was discovered via fuzzing. Anyone who uses this library either as a standalone binary or as a library can be DOSed when attempting to parse this type of file. Web servers or other automated processes which rely on this code to turn pdf submissions into plaintext can be DOSed when an attacker uploads the pdf. Please see the linked GHSA for an example pdf. Users are advised to upgrade. There are no known workarounds for this vulnerability.,5.3,MEDIUM,1,test,2023-02-04T01:39:04Z,4
CVE-2023-24808,['CWE-835'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,michaelrsweet/pdfio,Fix denial-of-service attack when reading corrupt PDF files.,4f10021e7ee527c1aa24853e2947e38e154d9ccb,https://github.com/michaelrsweet/pdfio/commit/4f10021e7ee527c1aa24853e2947e38e154d9ccb,pdfio-token.c,_pdfioTokenGet,"bool_pdfioTokenGet(_pdfio_token_t *tb,       char           *buffer,       size_t         bufsize){
if (tb->num_tokens > 0)
{
tb->num_tokens --;
strncpy(buffer, tb->tokens[tb->num_tokens], bufsize - 1);
buffer[bufsize - 1] = '\0';
PDFIO_DEBUG(""_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Popping '%s' from stack.\n"", tb, buffer, (unsigned)bufsize, buffer);
free(tb->tokens[tb->num_tokens]);
tb->tokens[tb->num_tokens] = NULL;
return (true);
}
return (_pdfioTokenRead(tb, buffer, bufsize));
}","bool
_pdfioTokenGet(_pdfio_token_t *VAR_0,
char           *VAR_1,
size_t         VAR_2)
{
if (VAR_0->num_tokens > 0)
{
VAR_0->num_tokens --;
strncpy(VAR_1, VAR_0->tokens[VAR_0->num_tokens], VAR_2 - 1);
VAR_1[VAR_2 - 1] = '\0';
PDFIO_DEBUG(""_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Popping '%s' from stack.\n"", VAR_0, VAR_1, (unsigned)VAR_2, VAR_1);
free(VAR_0->tokens[VAR_0->num_tokens]);
VAR_0->tokens[VAR_0->num_tokens] = NULL;
return (true);
}
return (_pdfioTokenRead(VAR_0, VAR_1, VAR_2));
}",michaelrsweet/pdfio/4f10021e7ee527c1aa24853e2947e38e154d9ccb/pdfio-token.c/vul/before/2.json,"bool					// O - `true` on success, `false` on failure
_pdfioTokenGet(_pdfio_token_t *tb,	// I - Token buffer/stack
	       char           *buffer,	// I - String buffer
	       size_t         bufsize)	// I - Size of string buffer
{
  // See if we have a token waiting on the stack...
  if (tb->num_tokens > 0)
  {
    // Yes, return it...
    size_t len;				// Length of token

    tb->num_tokens --;

    if ((len = strlen(tb->tokens[tb->num_tokens])) > (bufsize - 1))
    {
      // Value too large...
      PDFIO_DEBUG(""_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Token '%s' from stack too large.\n"", tb, buffer, (unsigned)bufsize, tb->tokens[tb->num_tokens]);
      *buffer = '\0';
      return (false);
    }

    memcpy(buffer, tb->tokens[tb->num_tokens], len);
    buffer[len] = '\0';

    PDFIO_DEBUG(""_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Popping '%s' from stack.\n"", tb, buffer, (unsigned)bufsize, buffer);

    free(tb->tokens[tb->num_tokens]);
    tb->tokens[tb->num_tokens] = NULL;

    return (true);
  }

  // No, read a new one...
  return (_pdfioTokenRead(tb, buffer, bufsize));
}","bool					/* COMMENT_0 */
_pdfioTokenGet(_pdfio_token_t *VAR_0,	/* COMMENT_1 */
	       char           *VAR_1,	/* COMMENT_2 */
	       size_t         VAR_2)	/* COMMENT_3 */
{
  /* COMMENT_4 */
  if (VAR_0->num_tokens > 0)
  {
    /* COMMENT_5 */
    size_t VAR_3;				/* COMMENT_6 */

    VAR_0->num_tokens --;

    if ((VAR_3 = strlen(VAR_0->tokens[VAR_0->num_tokens])) > (VAR_2 - 1))
    {
      /* COMMENT_7 */
      PDFIO_DEBUG(""_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Token '%s' from stack too large.\n"", VAR_0, VAR_1, (unsigned)VAR_2, VAR_0->tokens[VAR_0->num_tokens]);
      *VAR_1 = '\0';
      return (false);
    }

    memcpy(VAR_1, VAR_0->tokens[VAR_0->num_tokens], VAR_3);
    VAR_1[VAR_3] = '\0';

    PDFIO_DEBUG(""_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Popping '%s' from stack.\n"", VAR_0, VAR_1, (unsigned)VAR_2, VAR_1);

    free(VAR_0->tokens[VAR_0->num_tokens]);
    VAR_0->tokens[VAR_0->num_tokens] = NULL;

    return (true);
  }

  /* COMMENT_8 */
  return (_pdfioTokenRead(VAR_0, VAR_1, VAR_2));
}",michaelrsweet/pdfio/4f10021e7ee527c1aa24853e2947e38e154d9ccb/pdfio-token.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -7,9 +7,20 @@
   if (tb->num_tokens > 0)
   {
     // Yes, return it...
+    size_t len;				// Length of token
+
     tb->num_tokens --;
-    strncpy(buffer, tb->tokens[tb->num_tokens], bufsize - 1);
-    buffer[bufsize - 1] = '\0';
+
+    if ((len = strlen(tb->tokens[tb->num_tokens])) > (bufsize - 1))
+    {
+      // Value too large...
+      PDFIO_DEBUG(""_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Token '%s' from stack too large.\n"", tb, buffer, (unsigned)bufsize, tb->tokens[tb->num_tokens]);
+      *buffer = '\0';
+      return (false);
+    }
+
+    memcpy(buffer, tb->tokens[tb->num_tokens], len);
+    buffer[len] = '\0';
 
     PDFIO_DEBUG(""_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Popping '%s' from stack.\n"", tb, buffer, (unsigned)bufsize, buffer);
 ","{'deleted_lines': ['    strncpy(buffer, tb->tokens[tb->num_tokens], bufsize - 1);', ""    buffer[bufsize - 1] = '\\0';""], 'added_lines': ['    size_t len;\t\t\t\t// Length of token', '', '', '    if ((len = strlen(tb->tokens[tb->num_tokens])) > (bufsize - 1))', '    {', '      // Value too large...', '      PDFIO_DEBUG(""_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Token \'%s\' from stack too large.\\n"", tb, buffer, (unsigned)bufsize, tb->tokens[tb->num_tokens]);', ""      *buffer = '\\0';"", '      return (false);', '    }', '', '    memcpy(buffer, tb->tokens[tb->num_tokens], len);', ""    buffer[len] = '\\0';""]}",True, PDFio is a C library for reading and writing PDF files. In versions prior to 1.1.0 a denial of service (DOS) vulnerability exists in the pdfio parser. Crafted pdf files can cause the program to run at 100% utilization and never terminate. The pdf which causes this crash found in testing is about 28kb in size and was discovered via fuzzing. Anyone who uses this library either as a standalone binary or as a library can be DOSed when attempting to parse this type of file. Web servers or other automated processes which rely on this code to turn pdf submissions into plaintext can be DOSed when an attacker uploads the pdf. Please see the linked GHSA for an example pdf. Users are advised to upgrade. There are no known workarounds for this vulnerability.,5.3,MEDIUM,1,test,2023-02-04T01:39:04Z,4
CVE-2023-24808,['CWE-835'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,michaelrsweet/pdfio,Fix denial-of-service attack when reading corrupt PDF files.,4f10021e7ee527c1aa24853e2947e38e154d9ccb,https://github.com/michaelrsweet/pdfio/commit/4f10021e7ee527c1aa24853e2947e38e154d9ccb,pdfio-token.c,_pdfioTokenRead,"bool_pdfioTokenRead(_pdfio_token_t *tb,char           *buffer,size_t         bufsize){
intch,parens = 0;  char*bufptr,*bufend,state = '\0';  boolsaw_nul = false;
bufptr = buffer;
bufend = buffer + bufsize - 1;
while ((ch = get_char(tb)) != EOF)
{
if (ch == '%')
{
while ((ch = get_char(tb)) != EOF)
{
if (ch == '\n' || ch == '\r')
break;
}
}
else if (!isspace(ch))
break;
}
if (ch == EOF)
return (false);
if (strchr(PDFIO_DELIM_CHARS, ch) != NULL)
{
*bufptr++ = state = (char)ch;
}
else if (strchr(PDFIO_NUMBER_CHARS, ch) != NULL)
{
state     = 'N';
*bufptr++ = (char)ch;
}
else
{
state     = 'K';
*bufptr++ = (char)ch;
}
switch (state)
{
case '(' : while ((ch = get_char(tb)) != EOF)
{
if (ch == 0)
saw_nul = true;
if (ch == '\\')
{
inti;
switch (ch = get_char(tb))
{
case '0' :       case '1' :
case '2' :
case '3' :
case '4' :
case '5' :
case '6' :
case '7' :
for (ch -= '0', i = 0; i < 2; i ++)
{
int tch = get_char(tb);
if (tch >= '0' && tch <= '7')
{
ch = (char)((ch << 3) | (tch - '0'));
}
else
{
tb->bufptr --;
break;
}
}
break;
case '\\' :
case '(' :
case ')' :
break;
case 'n' :
ch = '\n';
break;
case 'r' :
ch = '\r';
break;
case 't' :
ch = '\t';
break;
case 'b' :
ch = '\b';
break;
case 'f' :
ch = '\f';
break;
default :
break;
}
}
else if (ch == '(')
{
parens ++;
}
else if (ch == ')')
{
if (parens == 0)
break;
parens --;
}
if (bufptr < bufend)
{
*bufptr++ = (char)ch;
}
else
{
_pdfioFileError(tb->pdf, ""Token too large."");
return (false);
}
}
if (ch != ')')
{
_pdfioFileError(tb->pdf, ""Unterminated string literal."");
return (false);
}
if (saw_nul)
{
char*litptr,*hexptr;  size_t bytes = (size_t)(bufptr - buffer - 1);
static const char *hexchars = ""0123456789ABCDEF"";
PDFIO_DEBUG(""_pdfioTokenRead: Converting nul-containing string to binary.\n"");
if ((2 * (bytes + 1)) > bufsize)
{
_pdfioFileError(tb->pdf, ""Token too large."");
return (false);
}
*buffer = '<';
for (litptr = bufptr - 1, hexptr = buffer + 2 * bytes - 1; litptr > buffer; litptr --, hexptr -= 2)
{
int litch = *litptr;
hexptr[0] = hexchars[(litch >> 4) & 15];
hexptr[1] = hexchars[litch & 15];
}
bufptr = buffer + 2 * bytes + 1;
}
break;
case 'K' : while ((ch = get_char(tb)) != EOF && !isspace(ch))
{
if (strchr(PDFIO_DELIM_CHARS, ch) != NULL)
{
tb->bufptr --;
break;
}
else if (bufptr < bufend)
{
*bufptr++ = (char)ch;
}
else
{
_pdfioFileError(tb->pdf, ""Token too large."");
return (false);
}
}
break;
case 'N' : while ((ch = get_char(tb)) != EOF && !isspace(ch))
{
if (!isdigit(ch) && ch != '.')
{
tb->bufptr --;
break;
}
else if (bufptr < bufend)
{
*bufptr++ = (char)ch;
}
else
{
_pdfioFileError(tb->pdf, ""Token too large."");
return (false);
}
}
break;
case '/' : while ((ch = get_char(tb)) != EOF && !isspace(ch))
{
if (strchr(PDFIO_DELIM_CHARS, ch) != NULL)
{
tb->bufptr --;
break;
}
else if (ch == '#')
{
inti;
for (i = 0, ch = 0; i < 2; i ++)
{
int tch = get_char(tb);
if (!isxdigit(tch & 255))
{
_pdfioFileError(tb->pdf, ""Bad # escape in name."");
return (false);
}
else if (isdigit(tch))
ch = ((ch & 255) << 4) | (tch - '0');
else
ch = ((ch & 255) << 4) | (tolower(tch) - 'a' + 10);
}
}
if (bufptr < bufend)
{
*bufptr++ = (char)ch;
}
else
{
_pdfioFileError(tb->pdf, ""Token too large."");
return (false);
}
}
break;
case '<' : if ((ch = get_char(tb)) == '<')
{
*bufptr++ = (char)ch;
break;
}
else if (!isspace(ch & 255) && !isxdigit(ch & 255))
{
_pdfioFileError(tb->pdf, ""Syntax error: '<%c'"", ch);
return (false);
}
do
{
if (isxdigit(ch))
{
if (bufptr < bufend)
{
*bufptr++ = (char)ch;
}
else
{
_pdfioFileError(tb->pdf, ""Token too large."");
return (false);
}
}
else if (!isspace(ch))
{
_pdfioFileError(tb->pdf, ""Invalid hex string character '%c'."", ch);
return (false);
}
}
while ((ch = get_char(tb)) != EOF && ch != '>');
if (ch == EOF)
{
_pdfioFileError(tb->pdf, ""Unterminated hex string."");
return (false);
}
break;
case '>' : if ((ch = get_char(tb)) == '>')
{
*bufptr++ = '>';
}
else
{
_pdfioFileError(tb->pdf, ""Syntax error: '>%c'."", ch);
return (false);
}
break;
}
*bufptr = '\0';
PDFIO_DEBUG(""_pdfioTokenRead: Read '%s'.\n"", buffer);
return (bufptr > buffer);
}","bool
_pdfioTokenRead(_pdfio_token_t *VAR_0,
char           *VAR_1,
size_t         VAR_2)
{
intVAR_3,
VAR_4 = 0;
char*VAR_5,
*VAR_6,
VAR_7 = '\0';
boolVAR_8 = false;
VAR_5 = VAR_1;
VAR_6 = VAR_1 + VAR_2 - 1;
while ((VAR_3 = get_char(VAR_0)) != VAR_9)
{
if (VAR_3 == '%')
{
while ((VAR_3 = get_char(VAR_0)) != VAR_9)
{
if (VAR_3 == '\n' || VAR_3 == '\r')
break;
}
}
else if (!isspace(VAR_3))
break;
}
if (VAR_3 == VAR_9)
return (false);
if (strchr(VAR_10, VAR_3) != NULL)
{
*VAR_5++ = VAR_7 = (char)VAR_3;
}
else if (strchr(VAR_11, VAR_3) != NULL)
{
VAR_7     = 'N';
*VAR_5++ = (char)VAR_3;
}
else
{
VAR_7     = 'K';
*VAR_5++ = (char)VAR_3;
}
switch (VAR_7)
{
case '(' : 
while ((VAR_3 = get_char(VAR_0)) != VAR_9)
{
if (VAR_3 == 0)
VAR_8 = true;
if (VAR_3 == '\\')
{
intVAR_12;
switch (VAR_3 = get_char(VAR_0))
{
case '0' : 
case '1' :
case '2' :
case '3' :
case '4' :
case '5' :
case '6' :
case '7' :
for (VAR_3 -= '0', VAR_12 = 0; VAR_12 < 2; VAR_12 ++)
{
int VAR_13 = get_char(VAR_0);
if (VAR_13 >= '0' && VAR_13 <= '7')
{
VAR_3 = (char)((VAR_3 << 3) | (VAR_13 - '0'));
}
else
{
VAR_0->bufptr --;
break;
}
}
break;
case '\\' :
case '(' :
case ')' :
break;
case 'n' :
VAR_3 = '\n';
break;
case 'r' :
VAR_3 = '\r';
break;
case 't' :
VAR_3 = '\t';
break;
case 'b' :
VAR_3 = '\b';
break;
case 'f' :
VAR_3 = '\f';
break;
default :
break;
}
}
else if (VAR_3 == '(')
{
VAR_4 ++;
}
else if (VAR_3 == ')')
{
if (VAR_4 == 0)
break;
VAR_4 --;
}
if (VAR_5 < VAR_6)
{
*VAR_5++ = (char)VAR_3;
}
else
{
_pdfioFileError(VAR_0->pdf, ""Token too large."");
return (false);
}
}
if (VAR_3 != ')')
{
_pdfioFileError(VAR_0->pdf, ""Unterminated string literal."");
return (false);
}
if (VAR_8)
{
char*VAR_14,
*VAR_15;
size_t VAR_16 = (size_t)(VAR_5 - VAR_1 - 1);
static const char *VAR_17 = ""0123456789ABCDEF"";
PDFIO_DEBUG(""_pdfioTokenRead: Converting nul-containing string to binary.\n"");
if ((2 * (VAR_16 + 1)) > VAR_2)
{
_pdfioFileError(VAR_0->pdf, ""Token too large."");
return (false);
}
*VAR_1 = '<';
for (VAR_14 = VAR_5 - 1, VAR_15 = VAR_1 + 2 * VAR_16 - 1; VAR_14 > VAR_1; VAR_14 --, VAR_15 -= 2)
{
int VAR_18 = *VAR_14;
VAR_15[0] = VAR_17[(VAR_18 >> 4) & 15];
VAR_15[1] = VAR_17[VAR_18 & 15];
}
VAR_5 = VAR_1 + 2 * VAR_16 + 1;
}
break;
case 'K' : 
while ((VAR_3 = get_char(VAR_0)) != VAR_9 && !isspace(VAR_3))
{
if (strchr(VAR_10, VAR_3) != NULL)
{
VAR_0->bufptr --;
break;
}
else if (VAR_5 < VAR_6)
{
*VAR_5++ = (char)VAR_3;
}
else
{
_pdfioFileError(VAR_0->pdf, ""Token too large."");
return (false);
}
}
break;
case 'N' : 
while ((VAR_3 = get_char(VAR_0)) != VAR_9 && !isspace(VAR_3))
{
if (!isdigit(VAR_3) && VAR_3 != '.')
{
VAR_0->bufptr --;
break;
}
else if (VAR_5 < VAR_6)
{
*VAR_5++ = (char)VAR_3;
}
else
{
_pdfioFileError(VAR_0->pdf, ""Token too large."");
return (false);
}
}
break;
case '/' : 
while ((VAR_3 = get_char(VAR_0)) != VAR_9 && !isspace(VAR_3))
{
if (strchr(VAR_10, VAR_3) != NULL)
{
VAR_0->bufptr --;
break;
}
else if (VAR_3 == '#')
{
intVAR_12;
for (VAR_12 = 0, VAR_3 = 0; VAR_12 < 2; VAR_12 ++)
{
int VAR_13 = get_char(VAR_0);
if (!isxdigit(VAR_13 & 255))
{
_pdfioFileError(VAR_0->pdf, ""Bad # escape in name."");
return (false);
}
else if (isdigit(VAR_13))
VAR_3 = ((VAR_3 & 255) << 4) | (VAR_13 - '0');
else
VAR_3 = ((VAR_3 & 255) << 4) | (tolower(VAR_13) - 'a' + 10);
}
}
if (VAR_5 < VAR_6)
{
*VAR_5++ = (char)VAR_3;
}
else
{
_pdfioFileError(VAR_0->pdf, ""Token too large."");
return (false);
}
}
break;
case '<' : 
if ((VAR_3 = get_char(VAR_0)) == '<')
{
*VAR_5++ = (char)VAR_3;
break;
}
else if (!isspace(VAR_3 & 255) && !isxdigit(VAR_3 & 255))
{
_pdfioFileError(VAR_0->pdf, ""Syntax error: '<%c'"", VAR_3);
return (false);
}
do
{
if (isxdigit(VAR_3))
{
if (VAR_5 < VAR_6)
{
*VAR_5++ = (char)VAR_3;
}
else
{
_pdfioFileError(VAR_0->pdf, ""Token too large."");
return (false);
}
}
else if (!isspace(VAR_3))
{
_pdfioFileError(VAR_0->pdf, ""Invalid hex string character '%c'."", VAR_3);
return (false);
}
}
while ((VAR_3 = get_char(VAR_0)) != VAR_9 && VAR_3 != '>');
if (VAR_3 == VAR_9)
{
_pdfioFileError(VAR_0->pdf, ""Unterminated hex string."");
return (false);
}
break;
case '>' : 
if ((VAR_3 = get_char(VAR_0)) == '>')
{
*VAR_5++ = '>';
}
else
{
_pdfioFileError(VAR_0->pdf, ""Syntax error: '>%c'."", VAR_3);
return (false);
}
break;
}
*VAR_5 = '\0';
PDFIO_DEBUG(""_pdfioTokenRead: Read '%s'.\n"", VAR_1);
return (VAR_5 > VAR_1);
}",michaelrsweet/pdfio/4f10021e7ee527c1aa24853e2947e38e154d9ccb/pdfio-token.c/vul/before/1.json,"bool					// O - `true` on success, `false` on failure
_pdfioTokenRead(_pdfio_token_t *tb,	// I - Token buffer/stack
		char           *buffer,	// I - String buffer
		size_t         bufsize)	// I - Size of string buffer
{
  int	ch,				// Character
	parens = 0;			// Parenthesis level
  char	*bufptr,			// Pointer into buffer
	*bufend,			// End of buffer
	state = '\0';			// Current state
  bool	saw_nul = false;		// Did we see a nul character?


  //
  // ""state"" is:
  //
  // - '\0' for idle
  // - '(' for literal string
  // - '/' for name
  // - '<' for possible hex string or dict
  // - '>' for possible dict
  // - '%' for comment
  // - 'K' for keyword
  // - 'N' for number

  // Read the next token, skipping any leading whitespace...
  bufptr = buffer;
  bufend = buffer + bufsize - 1;

  // Skip leading whitespace...
  while ((ch = get_char(tb)) != EOF)
  {
    if (ch == '%')
    {
      // Skip comment
      while ((ch = get_char(tb)) != EOF)
      {
	if (ch == '\n' || ch == '\r')
	  break;
      }
    }
    else if (!isspace(ch))
      break;
  }

  if (ch == EOF)
    return (false);

  // Check for delimiters...
  if (strchr(PDFIO_DELIM_CHARS, ch) != NULL)
  {
    *bufptr++ = state = (char)ch;
  }
  else if (strchr(PDFIO_NUMBER_CHARS, ch) != NULL)
  {
    // Number
    state     = 'N';
    *bufptr++ = (char)ch;
  }
  else
  {
    // Keyword
    state     = 'K';
    *bufptr++ = (char)ch;
  }

  switch (state)
  {
    case '(' : // Literal string
	while ((ch = get_char(tb)) != EOF)
	{
	  if (ch == 0)
	    saw_nul = true;

	  if (ch == '\\')
	  {
	    // Quoted character...
	    int	i;			// Looping var

	    switch (ch = get_char(tb))
	    {
	      case '0' : // Octal character escape
	      case '1' :
	      case '2' :
	      case '3' :
	      case '4' :
	      case '5' :
	      case '6' :
	      case '7' :
		  for (ch -= '0', i = 0; i < 2; i ++)
		  {
		    int tch = get_char(tb);	// Next char

		    if (tch >= '0' && tch <= '7')
		    {
		      ch = (char)((ch << 3) | (tch - '0'));
		    }
		    else
		    {
		      tb->bufptr --;
		      break;
		    }
		  }
		  break;

	      case '\\' :
	      case '(' :
	      case ')' :
		  break;

	      case 'n' :
		  ch = '\n';
		  break;

	      case 'r' :
		  ch = '\r';
		  break;

	      case 't' :
		  ch = '\t';
		  break;

	      case 'b' :
		  ch = '\b';
		  break;

	      case 'f' :
		  ch = '\f';
		  break;

	      default :
	          // Ignore blackslash per PDF spec...
	          break;
	    }
	  }
	  else if (ch == '(')
	  {
	    // Keep track of parenthesis
	    parens ++;
	  }
	  else if (ch == ')')
	  {
	    if (parens == 0)
	      break;

	    parens --;
	  }

	  if (bufptr < bufend)
	  {
	    // Normal character...
	    *bufptr++ = (char)ch;
	  }
	  else
	  {
	    // Out of space
	    _pdfioFileError(tb->pdf, ""Token too large."");
	    return (false);
	  }
	}

	if (ch != ')')
	{
	  _pdfioFileError(tb->pdf, ""Unterminated string literal."");
	  return (false);
	}

	if (saw_nul)
	{
	  // Convert to a hex (binary) string...
	  char	*litptr,		// Pointer to literal character
		*hexptr;		// Pointer to hex character
	  size_t bytes = (size_t)(bufptr - buffer - 1);
					// Bytes of data...
          static const char *hexchars = ""0123456789ABCDEF"";
					// Hex digits

          PDFIO_DEBUG(""_pdfioTokenRead: Converting nul-containing string to binary.\n"");

          if ((2 * (bytes + 1)) > bufsize)
          {
	    // Out of space...
	    _pdfioFileError(tb->pdf, ""Token too large."");
	    return (false);
          }

	  *buffer = '<';
	  for (litptr = bufptr - 1, hexptr = buffer + 2 * bytes - 1; litptr > buffer; litptr --, hexptr -= 2)
	  {
	    int litch = *litptr;	// Grab the character

	    hexptr[0] = hexchars[(litch >> 4) & 15];
	    hexptr[1] = hexchars[litch & 15];
	  }
	  bufptr = buffer + 2 * bytes + 1;
	}
	break;

    case 'K' : // keyword
	while ((ch = get_char(tb)) != EOF && !isspace(ch))
	{
	  if (strchr(PDFIO_DELIM_CHARS, ch) != NULL)
	  {
	    // End of keyword...
	    tb->bufptr --;
	    break;
	  }
	  else if (bufptr < bufend)
	  {
	    // Normal character...
	    *bufptr++ = (char)ch;
	  }
	  else
	  {
	    // Out of space...
	    _pdfioFileError(tb->pdf, ""Token too large."");
	    return (false);
	  }
	}
	break;

    case 'N' : // number
	while ((ch = get_char(tb)) != EOF && !isspace(ch))
	{
	  if (!isdigit(ch) && ch != '.')
	  {
	    // End of number...
	    tb->bufptr --;
	    break;
	  }
	  else if (bufptr < bufend)
	  {
	    // Normal character...
	    *bufptr++ = (char)ch;
	  }
	  else
	  {
	    // Out of space...
	    _pdfioFileError(tb->pdf, ""Token too large."");
	    return (false);
	  }
	}
	break;

    case '/' : // ""/name""
	while ((ch = get_char(tb)) != EOF && !isspace(ch))
	{
	  if (strchr(PDFIO_DELIM_CHARS, ch) != NULL)
	  {
	    // End of keyword...
	    tb->bufptr --;
	    break;
	  }
	  else if (ch == '#')
	  {
	    // Quoted character (#xx) in name...
	    int	i;			// Looping var

	    for (i = 0, ch = 0; i < 2; i ++)
	    {
	      int tch = get_char(tb);

	      if (!isxdigit(tch & 255))
	      {
		_pdfioFileError(tb->pdf, ""Bad # escape in name."");
		return (false);
	      }
	      else if (isdigit(tch))
		ch = ((ch & 255) << 4) | (tch - '0');
	      else
		ch = ((ch & 255) << 4) | (tolower(tch) - 'a' + 10);
	    }
	  }

	  if (bufptr < bufend)
	  {
	    *bufptr++ = (char)ch;
	  }
	  else
	  {
	    // Out of space
	    _pdfioFileError(tb->pdf, ""Token too large."");
	    return (false);
	  }
	}
	break;

    case '<' : // Potential hex string
	if ((ch = get_char(tb)) == '<')
	{
	  // Dictionary delimiter
	  *bufptr++ = (char)ch;
	  break;
	}
	else if (!isspace(ch & 255) && !isxdigit(ch & 255))
	{
	  _pdfioFileError(tb->pdf, ""Syntax error: '<%c'"", ch);
	  return (false);
	}

        do
	{
	  if (isxdigit(ch))
	  {
	    if (bufptr < bufend)
	    {
	      // Hex digit
	      *bufptr++ = (char)ch;
	    }
	    else
	    {
	      // Too large
	      _pdfioFileError(tb->pdf, ""Token too large."");
	      return (false);
	    }
	  }
	  else if (!isspace(ch))
	  {
	    _pdfioFileError(tb->pdf, ""Invalid hex string character '%c'."", ch);
	    return (false);
	  }
	}
	while ((ch = get_char(tb)) != EOF && ch != '>');

	if (ch == EOF)
	{
	  _pdfioFileError(tb->pdf, ""Unterminated hex string."");
	  return (false);
	}
	break;

    case '>' : // Dictionary
	if ((ch = get_char(tb)) == '>')
	{
	  *bufptr++ = '>';
	}
	else
	{
	  _pdfioFileError(tb->pdf, ""Syntax error: '>%c'."", ch);
	  return (false);
	}
	break;
  }

  *bufptr = '\0';

//  PDFIO_DEBUG(""_pdfioTokenRead: Read '%s'.\n"", buffer);

  return (bufptr > buffer);
}","bool					/* COMMENT_0 */
_pdfioTokenRead(_pdfio_token_t *VAR_0,	/* COMMENT_1 */
		char           *VAR_1,	/* COMMENT_2 */
		size_t         VAR_2)	/* COMMENT_3 */
{
  int	VAR_3,				/* COMMENT_4 */
	VAR_4 = 0;			/* COMMENT_5 */
  char	*VAR_5,			/* COMMENT_6 */
	*VAR_6,			/* COMMENT_7 */
	VAR_7 = '\0';			/* COMMENT_8 */
  bool	VAR_8 = false;		/* COMMENT_9 */


  /* COMMENT_10 */
  /* COMMENT_11 */
  /* COMMENT_10 */
  /* COMMENT_12 */
  /* COMMENT_13 */
  /* COMMENT_14 */
  /* COMMENT_15 */
  /* COMMENT_16 */
  /* COMMENT_17 */
  /* COMMENT_18 */
  /* COMMENT_19 */

  /* COMMENT_20 */
  VAR_5 = VAR_1;
  VAR_6 = VAR_1 + VAR_2 - 1;

  /* COMMENT_21 */
  while ((VAR_3 = get_char(VAR_0)) != VAR_9)
  {
    if (VAR_3 == '%')
    {
      /* COMMENT_22 */
      while ((VAR_3 = get_char(VAR_0)) != VAR_9)
      {
	if (VAR_3 == '\n' || VAR_3 == '\r')
	  break;
      }
    }
    else if (!isspace(VAR_3))
      break;
  }

  if (VAR_3 == VAR_9)
    return (false);

  /* COMMENT_23 */
  if (strchr(VAR_10, VAR_3) != NULL)
  {
    *VAR_5++ = VAR_7 = (char)VAR_3;
  }
  else if (strchr(VAR_11, VAR_3) != NULL)
  {
    /* COMMENT_24 */
    VAR_7     = 'N';
    *VAR_5++ = (char)VAR_3;
  }
  else
  {
    /* COMMENT_25 */
    VAR_7     = 'K';
    *VAR_5++ = (char)VAR_3;
  }

  switch (VAR_7)
  {
    case '(' : /* COMMENT_26 */
	while ((VAR_3 = get_char(VAR_0)) != VAR_9)
	{
	  if (VAR_3 == 0)
	    VAR_8 = true;

	  if (VAR_3 == '\\')
	  {
	    /* COMMENT_27 */
	    int	VAR_12;			/* COMMENT_28 */

	    switch (VAR_3 = get_char(VAR_0))
	    {
	      case '0' : /* COMMENT_29 */
	      case '1' :
	      case '2' :
	      case '3' :
	      case '4' :
	      case '5' :
	      case '6' :
	      case '7' :
		  for (VAR_3 -= '0', VAR_12 = 0; VAR_12 < 2; VAR_12 ++)
		  {
		    int VAR_13 = get_char(VAR_0);	/* COMMENT_30 */

		    if (VAR_13 >= '0' && VAR_13 <= '7')
		    {
		      VAR_3 = (char)((VAR_3 << 3) | (VAR_13 - '0'));
		    }
		    else
		    {
		      VAR_0->bufptr --;
		      break;
		    }
		  }
		  break;

	      case '\\' :
	      case '(' :
	      case ')' :
		  break;

	      case 'n' :
		  VAR_3 = '\n';
		  break;

	      case 'r' :
		  VAR_3 = '\r';
		  break;

	      case 't' :
		  VAR_3 = '\t';
		  break;

	      case 'b' :
		  VAR_3 = '\b';
		  break;

	      case 'f' :
		  VAR_3 = '\f';
		  break;

	      default :
	          /* COMMENT_31 */
	          break;
	    }
	  }
	  else if (VAR_3 == '(')
	  {
	    /* COMMENT_32 */
	    VAR_4 ++;
	  }
	  else if (VAR_3 == ')')
	  {
	    if (VAR_4 == 0)
	      break;

	    VAR_4 --;
	  }

	  if (VAR_5 < VAR_6)
	  {
	    /* COMMENT_33 */
	    *VAR_5++ = (char)VAR_3;
	  }
	  else
	  {
	    /* COMMENT_34 */
	    _pdfioFileError(VAR_0->pdf, ""Token too large."");
	    return (false);
	  }
	}

	if (VAR_3 != ')')
	{
	  _pdfioFileError(VAR_0->pdf, ""Unterminated string literal."");
	  return (false);
	}

	if (VAR_8)
	{
	  /* COMMENT_35 */
	  char	*VAR_14,		/* COMMENT_36 */
		*VAR_15;		/* COMMENT_37 */
	  size_t VAR_16 = (size_t)(VAR_5 - VAR_1 - 1);
					/* COMMENT_38 */
          static const char *VAR_17 = ""0123456789ABCDEF"";
					/* COMMENT_39 */

          PDFIO_DEBUG(""_pdfioTokenRead: Converting nul-containing string to binary.\n"");

          if ((2 * (VAR_16 + 1)) > VAR_2)
          {
	    /* COMMENT_40 */
	    _pdfioFileError(VAR_0->pdf, ""Token too large."");
	    return (false);
          }

	  *VAR_1 = '<';
	  for (VAR_14 = VAR_5 - 1, VAR_15 = VAR_1 + 2 * VAR_16 - 1; VAR_14 > VAR_1; VAR_14 --, VAR_15 -= 2)
	  {
	    int VAR_18 = *VAR_14;	/* COMMENT_41 */

	    VAR_15[0] = VAR_17[(VAR_18 >> 4) & 15];
	    VAR_15[1] = VAR_17[VAR_18 & 15];
	  }
	  VAR_5 = VAR_1 + 2 * VAR_16 + 1;
	}
	break;

    case 'K' : /* COMMENT_42 */
	while ((VAR_3 = get_char(VAR_0)) != VAR_9 && !isspace(VAR_3))
	{
	  if (strchr(VAR_10, VAR_3) != NULL)
	  {
	    /* COMMENT_43 */
	    VAR_0->bufptr --;
	    break;
	  }
	  else if (VAR_5 < VAR_6)
	  {
	    /* COMMENT_33 */
	    *VAR_5++ = (char)VAR_3;
	  }
	  else
	  {
	    /* COMMENT_40 */
	    _pdfioFileError(VAR_0->pdf, ""Token too large."");
	    return (false);
	  }
	}
	break;

    case 'N' : /* COMMENT_44 */
	while ((VAR_3 = get_char(VAR_0)) != VAR_9 && !isspace(VAR_3))
	{
	  if (!isdigit(VAR_3) && VAR_3 != '.')
	  {
	    /* COMMENT_45 */
	    VAR_0->bufptr --;
	    break;
	  }
	  else if (VAR_5 < VAR_6)
	  {
	    /* COMMENT_33 */
	    *VAR_5++ = (char)VAR_3;
	  }
	  else
	  {
	    /* COMMENT_40 */
	    _pdfioFileError(VAR_0->pdf, ""Token too large."");
	    return (false);
	  }
	}
	break;

    case '/' : /* COMMENT_46 */
	while ((VAR_3 = get_char(VAR_0)) != VAR_9 && !isspace(VAR_3))
	{
	  if (strchr(VAR_10, VAR_3) != NULL)
	  {
	    /* COMMENT_43 */
	    VAR_0->bufptr --;
	    break;
	  }
	  else if (VAR_3 == '#')
	  {
	    /* COMMENT_47 */
	    int	VAR_12;			/* COMMENT_28 */

	    for (VAR_12 = 0, VAR_3 = 0; VAR_12 < 2; VAR_12 ++)
	    {
	      int VAR_13 = get_char(VAR_0);

	      if (!isxdigit(VAR_13 & 255))
	      {
		_pdfioFileError(VAR_0->pdf, ""Bad # escape in name."");
		return (false);
	      }
	      else if (isdigit(VAR_13))
		VAR_3 = ((VAR_3 & 255) << 4) | (VAR_13 - '0');
	      else
		VAR_3 = ((VAR_3 & 255) << 4) | (tolower(VAR_13) - 'a' + 10);
	    }
	  }

	  if (VAR_5 < VAR_6)
	  {
	    *VAR_5++ = (char)VAR_3;
	  }
	  else
	  {
	    /* COMMENT_34 */
	    _pdfioFileError(VAR_0->pdf, ""Token too large."");
	    return (false);
	  }
	}
	break;

    case '<' : /* COMMENT_48 */
	if ((VAR_3 = get_char(VAR_0)) == '<')
	{
	  /* COMMENT_49 */
	  *VAR_5++ = (char)VAR_3;
	  break;
	}
	else if (!isspace(VAR_3 & 255) && !isxdigit(VAR_3 & 255))
	{
	  _pdfioFileError(VAR_0->pdf, ""Syntax error: '<%c'"", VAR_3);
	  return (false);
	}

        do
	{
	  if (isxdigit(VAR_3))
	  {
	    if (VAR_5 < VAR_6)
	    {
	      /* COMMENT_50 */
	      *VAR_5++ = (char)VAR_3;
	    }
	    else
	    {
	      /* COMMENT_51 */
	      _pdfioFileError(VAR_0->pdf, ""Token too large."");
	      return (false);
	    }
	  }
	  else if (!isspace(VAR_3))
	  {
	    _pdfioFileError(VAR_0->pdf, ""Invalid hex string character '%c'."", VAR_3);
	    return (false);
	  }
	}
	while ((VAR_3 = get_char(VAR_0)) != VAR_9 && VAR_3 != '>');

	if (VAR_3 == VAR_9)
	{
	  _pdfioFileError(VAR_0->pdf, ""Unterminated hex string."");
	  return (false);
	}
	break;

    case '>' : /* COMMENT_52 */
	if ((VAR_3 = get_char(VAR_0)) == '>')
	{
	  *VAR_5++ = '>';
	}
	else
	{
	  _pdfioFileError(VAR_0->pdf, ""Syntax error: '>%c'."", VAR_3);
	  return (false);
	}
	break;
  }

  *VAR_5 = '\0';

/* COMMENT_53 */

  return (VAR_5 > VAR_1);
}",michaelrsweet/pdfio/4f10021e7ee527c1aa24853e2947e38e154d9ccb/pdfio-token.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -344,7 +344,7 @@
 
   *bufptr = '\0';
 
-  PDFIO_DEBUG(""_pdfioTokenRead: Read '%s'.\n"", buffer);
+//  PDFIO_DEBUG(""_pdfioTokenRead: Read '%s'.\n"", buffer);
 
   return (bufptr > buffer);
 }","{'deleted_lines': ['  PDFIO_DEBUG(""_pdfioTokenRead: Read \'%s\'.\\n"", buffer);'], 'added_lines': ['//  PDFIO_DEBUG(""_pdfioTokenRead: Read \'%s\'.\\n"", buffer);']}",True, PDFio is a C library for reading and writing PDF files. In versions prior to 1.1.0 a denial of service (DOS) vulnerability exists in the pdfio parser. Crafted pdf files can cause the program to run at 100% utilization and never terminate. The pdf which causes this crash found in testing is about 28kb in size and was discovered via fuzzing. Anyone who uses this library either as a standalone binary or as a library can be DOSed when attempting to parse this type of file. Web servers or other automated processes which rely on this code to turn pdf submissions into plaintext can be DOSed when an attacker uploads the pdf. Please see the linked GHSA for an example pdf. Users are advised to upgrade. There are no known workarounds for this vulnerability.,5.3,MEDIUM,1,test,2023-02-04T01:39:04Z,4
CVE-2023-24808,['CWE-835'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,michaelrsweet/pdfio,Fix denial-of-service attack when reading corrupt PDF files.,4f10021e7ee527c1aa24853e2947e38e154d9ccb,https://github.com/michaelrsweet/pdfio/commit/4f10021e7ee527c1aa24853e2947e38e154d9ccb,pdfio-token.c,get_char,"static intget_char(_pdfio_token_t *tb){
ssize_tbytes;
if (tb->bufptr >= tb->bufend)
{
if (tb->bufend > tb->buffer)
{
PDFIO_DEBUG(""get_char: Consuming %d bytes.\n"", (int)(tb->bufend - tb->buffer));
(tb->consume_cb)(tb->cb_data, (size_t)(tb->bufend - tb->buffer));
}
if ((bytes = (tb->peek_cb)(tb->cb_data, tb->buffer, sizeof(tb->buffer))) <= 0)
{
tb->bufptr = tb->bufend = tb->buffer;
return (EOF);
}
tb->bufptr = tb->buffer;
tb->bufend = tb->buffer + bytes;
#ifdef DEBUG
unsigned char *ptr;
PDFIO_DEBUG(""get_char: Read '"");
for (ptr = tb->buffer; ptr < tb->bufend; ptr ++)
{
if (*ptr < ' ' || *ptr == 0x7f)
PDFIO_DEBUG(""\\%03o"", *ptr);
else
PDFIO_DEBUG(""%c"", *ptr);
}
PDFIO_DEBUG(""'\n"");
#endif   }
return (*(tb->bufptr)++);
}","static int
get_char(_pdfio_token_t *VAR_0)
{
ssize_tVAR_1;
if (VAR_0->bufptr >= VAR_0->bufend)
{
if (VAR_0->bufend > VAR_0->buffer)
{
PDFIO_DEBUG(""get_char: Consuming %d bytes.\n"", (int)(VAR_0->bufend - VAR_0->buffer));
(VAR_0->consume_cb)(VAR_0->cb_data, (size_t)(VAR_0->bufend - VAR_0->buffer));
}
if ((VAR_1 = (VAR_0->peek_cb)(VAR_0->cb_data, VAR_0->buffer, sizeof(VAR_0->buffer))) <= 0)
{
VAR_0->bufptr = VAR_0->bufend = VAR_0->buffer;
return (VAR_2);
}
VAR_0->bufptr = VAR_0->buffer;
VAR_0->bufend = VAR_0->buffer + VAR_1;
#ifdef VAR_3
unsigned char *VAR_4;
PDFIO_DEBUG(""get_char: Read '"");
for (VAR_4 = VAR_0->buffer; VAR_4 < VAR_0->bufend; VAR_4 ++)
{
if (*VAR_4 < ' ' || *VAR_4 == 0x7f)
PDFIO_DEBUG(""\\%03o"", *VAR_4);
else
PDFIO_DEBUG(""%c"", *VAR_4);
}
PDFIO_DEBUG(""'\n"");
#endif 
}
return (*(VAR_0->bufptr)++);
}",michaelrsweet/pdfio/4f10021e7ee527c1aa24853e2947e38e154d9ccb/pdfio-token.c/vul/before/0.json,"static int				// O - Character or `EOF` on end-of-file
get_char(_pdfio_token_t *tb)		// I - Token buffer
{
  ssize_t	bytes;			// Bytes peeked


  // Refill the buffer as needed...
  if (tb->bufptr >= tb->bufend)
  {
    // Consume previous bytes...
    if (tb->bufend > tb->buffer)
    {
      PDFIO_DEBUG(""get_char: Consuming %d bytes.\n"", (int)(tb->bufend - tb->buffer));
      (tb->consume_cb)(tb->cb_data, (size_t)(tb->bufend - tb->buffer));
    }

    // Peek new bytes...
    if ((bytes = (tb->peek_cb)(tb->cb_data, tb->buffer, sizeof(tb->buffer))) <= 0)
    {
      tb->bufptr = tb->bufend = tb->buffer;
      return (EOF);
    }

    // Update pointers...
    tb->bufptr = tb->buffer;
    tb->bufend = tb->buffer + bytes;

#if 0
#ifdef DEBUG
    unsigned char *ptr;			// Pointer into buffer

    PDFIO_DEBUG(""get_char: Read '"");
    for (ptr = tb->buffer; ptr < tb->bufend; ptr ++)
    {
      if (*ptr < ' ' || *ptr == 0x7f)
        PDFIO_DEBUG(""\\%03o"", *ptr);
      else
        PDFIO_DEBUG(""%c"", *ptr);
    }
    PDFIO_DEBUG(""'\n"");
#endif // DEBUG
#endif // 0
  }

  // Return the next character...
  return (*(tb->bufptr)++);
}","static int				/* COMMENT_0 */
get_char(_pdfio_token_t *VAR_0)		/* COMMENT_1 */
{
  ssize_t	VAR_1;			/* COMMENT_2 */


  /* COMMENT_3 */
  if (VAR_0->bufptr >= VAR_0->bufend)
  {
    /* COMMENT_4 */
    if (VAR_0->bufend > VAR_0->buffer)
    {
      PDFIO_DEBUG(""get_char: Consuming %d bytes.\n"", (int)(VAR_0->bufend - VAR_0->buffer));
      (VAR_0->consume_cb)(VAR_0->cb_data, (size_t)(VAR_0->bufend - VAR_0->buffer));
    }

    /* COMMENT_5 */
    if ((VAR_1 = (VAR_0->peek_cb)(VAR_0->cb_data, VAR_0->buffer, sizeof(VAR_0->buffer))) <= 0)
    {
      VAR_0->bufptr = VAR_0->bufend = VAR_0->buffer;
      return (VAR_2);
    }

    /* COMMENT_6 */
    VAR_0->bufptr = VAR_0->buffer;
    VAR_0->bufend = VAR_0->buffer + VAR_1;

#if 0
#ifdef VAR_3
    unsigned char *VAR_4;			/* COMMENT_7 */

    PDFIO_DEBUG(""get_char: Read '"");
    for (VAR_4 = VAR_0->buffer; VAR_4 < VAR_0->bufend; VAR_4 ++)
    {
      if (*VAR_4 < ' ' || *VAR_4 == 0x7f)
        PDFIO_DEBUG(""\\%03o"", *VAR_4);
      else
        PDFIO_DEBUG(""%c"", *VAR_4);
    }
    PDFIO_DEBUG(""'\n"");
#endif /* COMMENT_8 */
#endif /* COMMENT_9 */
  }

  /* COMMENT_10 */
  return (*(VAR_0->bufptr)++);
}",michaelrsweet/pdfio/4f10021e7ee527c1aa24853e2947e38e154d9ccb/pdfio-token.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -25,6 +25,7 @@
     tb->bufptr = tb->buffer;
     tb->bufend = tb->buffer + bytes;
 
+#if 0
 #ifdef DEBUG
     unsigned char *ptr;			// Pointer into buffer
 
@@ -38,6 +39,7 @@
     }
     PDFIO_DEBUG(""'\n"");
 #endif // DEBUG
+#endif // 0
   }
 
   // Return the next character...","{'deleted_lines': [], 'added_lines': ['#if 0', '#endif // 0']}",True, PDFio is a C library for reading and writing PDF files. In versions prior to 1.1.0 a denial of service (DOS) vulnerability exists in the pdfio parser. Crafted pdf files can cause the program to run at 100% utilization and never terminate. The pdf which causes this crash found in testing is about 28kb in size and was discovered via fuzzing. Anyone who uses this library either as a standalone binary or as a library can be DOSed when attempting to parse this type of file. Web servers or other automated processes which rely on this code to turn pdf submissions into plaintext can be DOSed when an attacker uploads the pdf. Please see the linked GHSA for an example pdf. Users are advised to upgrade. There are no known workarounds for this vulnerability.,5.3,MEDIUM,1,test,2023-02-04T01:39:04Z,4
CVE-2023-24808,['CWE-835'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,michaelrsweet/pdfio,Fix denial-of-service attack when reading corrupt PDF files.,4f10021e7ee527c1aa24853e2947e38e154d9ccb,https://github.com/michaelrsweet/pdfio/commit/4f10021e7ee527c1aa24853e2947e38e154d9ccb,pdfio-file.c,load_xref,"static boolload_xref(
pdfio_file_t        *pdf,    off_t               xref_offset,    pdfio_password_cb_t password_cb,    void                *password_data){
booldone = false;  charline[1024],*ptr;  _pdfio_value_t trailer;  intmax_tnumber,num_objects,offset;  intgeneration;  _pdfio_token_t tb;  off_tline_offset;
while (!done)
{
if (_pdfioFileSeek(pdf, xref_offset, SEEK_SET) != xref_offset)
{
_pdfioFileError(pdf, ""Unable to seek to start of xref table."");
return (false);
}
do
{
line_offset = _pdfioFileTell(pdf);
if (!_pdfioFileGets(pdf, line, sizeof(line)))
{
_pdfioFileError(pdf, ""Unable to read start of xref table."");
return (false);
}
}
while (!line[0]);
PDFIO_DEBUG(""load_xref: line_offset=%lu, line='%s'\n"", (unsigned long)line_offset, line);
if (isdigit(line[0] & 255) && strlen(line) > 4 && (!strcmp(line + strlen(line) - 4, "" obj"") || ((ptr = strstr(line, "" obj"")) != NULL && ptr[4] == '<')))
{
pdfio_obj_t*obj;      size_ti;      pdfio_array_t*index_array;      size_tindex_n,index_count,count;      pdfio_array_t*w_array;      size_tw[3];      size_tw_2,w_3;      size_tw_total;      pdfio_stream_t*st;      unsigned charbuffer[32];      size_tnum_sobjs = 0,sobjs[4096];      pdfio_obj_t*current;
if ((number = strtoimax(line, &ptr, 10)) < 1)
{
_pdfioFileError(pdf, ""Bad xref table header '%s'."", line);
return (false);
}
if ((generation = (int)strtol(ptr, &ptr, 10)) < 0 || generation > 65535)
{
_pdfioFileError(pdf, ""Bad xref table header '%s'."", line);
return (false);
}
while (isspace(*ptr & 255))
ptr ++;
if (strncmp(ptr, ""obj"", 3))
{
_pdfioFileError(pdf, ""Bad xref table header '%s'."", line);
return (false);
}
if (_pdfioFileSeek(pdf, line_offset + ptr + 3 - line, SEEK_SET) < 0)
{
_pdfioFileError(pdf, ""Unable to seek to xref object %lu %u."", (unsigned long)number, (unsigned)generation);
return (false);
}
PDFIO_DEBUG(""load_xref: Loading object %lu %u.\n"", (unsigned long)number, (unsigned)generation);
if ((obj = add_obj(pdf, (size_t)number, (unsigned short)generation, xref_offset)) == NULL)
{
_pdfioFileError(pdf, ""Unable to allocate memory for object."");
return (false);
}
_pdfioTokenInit(&tb, pdf, (_pdfio_tconsume_cb_t)_pdfioFileConsume, (_pdfio_tpeek_cb_t)_pdfioFilePeek, pdf);
if (!_pdfioValueRead(pdf, obj, &tb, &trailer, 0))
{
_pdfioFileError(pdf, ""Unable to read cross-reference stream dictionary."");
return (false);
}
else if (trailer.type != PDFIO_VALTYPE_DICT)
{
_pdfioFileError(pdf, ""Cross-reference stream does not have a dictionary."");
return (false);
}
obj->value = trailer;
if (!_pdfioTokenGet(&tb, line, sizeof(line)) || strcmp(line, ""stream""))
{
_pdfioFileError(pdf, ""Unable to get stream after xref dictionary."");
return (false);
}
_pdfioTokenFlush(&tb);
obj->stream_offset = _pdfioFileTell(pdf);
if ((index_array = pdfioDictGetArray(trailer.value.dict, ""Index"")) != NULL)
index_count = index_array->num_values;
else
index_count = 1;
if ((w_array = pdfioDictGetArray(trailer.value.dict, ""W"")) == NULL)
{
_pdfioFileError(pdf, ""Cross-reference stream does not have required W key."");
return (false);
}
w[0]    = (size_t)pdfioArrayGetNumber(w_array, 0);
w[1]    = (size_t)pdfioArrayGetNumber(w_array, 1);
w[2]    = (size_t)pdfioArrayGetNumber(w_array, 2);
w_total = w[0] + w[1] + w[2];
w_2     = w[0];
w_3     = w[0] + w[1];
if (w[1] == 0 || w[2] > 2 || w[0] > sizeof(buffer) || w[1] > sizeof(buffer) || w[2] > sizeof(buffer) || w_total > sizeof(buffer))
{
_pdfioFileError(pdf, ""Cross-reference stream has invalid W key."");
return (false);
}
if ((st = pdfioObjOpenStream(obj, true)) == NULL)
{
_pdfioFileError(pdf, ""Unable to open cross-reference stream."");
return (false);
}
for (index_n = 0; index_n < index_count; index_n += 2)
{
if (index_count == 1)
{
number = 0;
count  = 999999999;
}
else
{
number = (intmax_t)pdfioArrayGetNumber(index_array, index_n);
count  = (size_t)pdfioArrayGetNumber(index_array, index_n + 1);
}
while (count > 0 && pdfioStreamRead(st, buffer, w_total) > 0)
{
count --;
PDFIO_DEBUG(""load_xref: number=%u %02X%02X%02X%02X%02X\n"", (unsigned)number, buffer[0], buffer[1], buffer[2], buffer[3], buffer[4]);
if (w[0] > 0)
{
if (buffer[0] == 0)
{
number ++;
continue;
}
}
for (i = 1, offset = buffer[w_2]; i < w[1]; i ++)
offset = (offset << 8) | buffer[w_2 + i];
switch (w[2])
{
default :
generation = 0;
break;
case 1 :
generation = buffer[w_3];
break;
case 2 :
generation = (buffer[w_3] << 8) | buffer[w_3 + 1];
break;
}
if ((current = pdfioFileFindObj(pdf, (size_t)number)) != NULL)
{
PDFIO_DEBUG(""load_xref: existing object, prev offset=%u\n"", (unsigned)current->offset);
if (w[0] == 0 || buffer[0] == 1)
{
current->offset = offset;
}
else if (number != offset)
{
current->offset = 0;
}
PDFIO_DEBUG(""load_xref: new offset=%u\n"", (unsigned)current->offset);
}
if (w[0] > 0 && buffer[0] == 2)
{
for (i = 0; i < num_sobjs; i ++)
{
if (sobjs[i] == (size_t)offset)
break;
}
if (i >= num_sobjs && num_sobjs < (sizeof(sobjs) / sizeof(sobjs[0])))
sobjs[num_sobjs ++] = (size_t)offset;
}
else if (!current)
{
if (!add_obj(pdf, (size_t)number, (unsigned short)generation, offset))
return (false);
}
number ++;
}
}
pdfioStreamClose(st);
if (!pdf->trailer_dict)
{
pdf->trailer_dict = trailer.value.dict;
pdf->info_obj     = pdfioDictGetObj(pdf->trailer_dict, ""Info"");
pdf->encrypt_obj  = pdfioDictGetObj(pdf->trailer_dict, ""Encrypt"");
pdf->id_array     = pdfioDictGetArray(pdf->trailer_dict, ""ID"");
if (pdf->encrypt_obj && !_pdfioCryptoUnlock(pdf, password_cb, password_data))
return (false);
}
PDFIO_DEBUG(""load_xref: %lu compressed object streams to load.\n"", (unsigned long)num_sobjs);
for (i = 0; i < num_sobjs; i ++)
{
if ((obj = pdfioFileFindObj(pdf, sobjs[i])) != NULL)
{
PDFIO_DEBUG(""load_xref: Loading compressed object stream %lu (pdf=%p, obj->pdf=%p).\n"", (unsigned long)sobjs[i], pdf, obj->pdf);
if (!load_obj_stream(obj))
return (false);
}
else
{
_pdfioFileError(pdf, ""Unable to find compressed object stream %lu."", (unsigned long)sobjs[i]);
return (false);
}
}
}
else if (!strcmp(line, ""xref""))
{
while (_pdfioFileGets(pdf, line, sizeof(line)))
{
if (!strcmp(line, ""trailer""))
break;
else if (!line[0])
continue;
if (sscanf(line, ""%jd%jd"", &number, &num_objects) != 2)
{
_pdfioFileError(pdf, ""Malformed xref table section '%s'."", line);
return (false);
}
for (; num_objects > 0; num_objects --, number ++)
{
if (_pdfioFileRead(pdf, line, 20) != 20)
return (false);
line[20] = '\0';
if (strcmp(line + 18, ""\r\n"") && strcmp(line + 18, "" \n"") && strcmp(line + 18, "" \r""))
{
_pdfioFileError(pdf, ""Malformed xref table entry '%s'."", line);
return (false);
}
line[18] = '\0';
if ((offset = strtoimax(line, &ptr, 10)) < 0)
{
_pdfioFileError(pdf, ""Malformed xref table entry '%s'."", line);
return (false);
}
if ((generation = (int)strtol(ptr, &ptr, 10)) < 0 || generation > 65535)
{
_pdfioFileError(pdf, ""Malformed xref table entry '%s'."", line);
return (false);
}
if (*ptr != ' ')
{
_pdfioFileError(pdf, ""Malformed xref table entry '%s'."", line);
return (false);
}
ptr ++;
if (*ptr != 'f' && *ptr != 'n')
{
_pdfioFileError(pdf, ""Malformed xref table entry '%s'."", line);
return (false);
}
if (*ptr == 'f')
continue;
if (pdfioFileFindObj(pdf, (size_t)number))
continue;
if (!add_obj(pdf, (size_t)number, (unsigned short)generation, offset))
return (false);
}
}
if (strcmp(line, ""trailer""))
{
_pdfioFileError(pdf, ""Missing trailer."");
return (false);
}
_pdfioTokenInit(&tb, pdf, (_pdfio_tconsume_cb_t)_pdfioFileConsume, (_pdfio_tpeek_cb_t)_pdfioFilePeek, pdf);
if (!_pdfioValueRead(pdf, NULL, &tb, &trailer, 0))
{
_pdfioFileError(pdf, ""Unable to read trailer dictionary."");
return (false);
}
else if (trailer.type != PDFIO_VALTYPE_DICT)
{
_pdfioFileError(pdf, ""Trailer is not a dictionary."");
return (false);
}
_pdfioTokenFlush(&tb);
if (!pdf->trailer_dict)
{
pdf->trailer_dict = trailer.value.dict;
pdf->info_obj     = pdfioDictGetObj(pdf->trailer_dict, ""Info"");
pdf->encrypt_obj  = pdfioDictGetObj(pdf->trailer_dict, ""Encrypt"");
pdf->id_array     = pdfioDictGetArray(pdf->trailer_dict, ""ID"");
if (pdf->encrypt_obj && !_pdfioCryptoUnlock(pdf, password_cb, password_data))
return (false);
}
}
else
{
_pdfioFileError(pdf, ""Bad xref table header '%s'."", line);
return (false);
}
PDFIO_DEBUG(""load_xref: Contents of trailer dictionary:\n"");
PDFIO_DEBUG(""load_xref: "");
PDFIO_DEBUG_VALUE(&trailer);
PDFIO_DEBUG(""\n"");
if ((xref_offset = (off_t)pdfioDictGetNumber(trailer.value.dict, ""Prev"")) <= 0)
done = true;
}
if ((pdf->root_obj = pdfioDictGetObj(pdf->trailer_dict, ""Root"")) == NULL)
{
_pdfioFileError(pdf, ""Missing Root object."");
return (false);
}
PDFIO_DEBUG(""load_xref: Root=%p(%lu)\n"", pdf->root_obj, (unsigned long)pdf->root_obj->number);
return (load_pages(pdf, pdfioDictGetObj(pdfioObjGetDict(pdf->root_obj), ""Pages""), 0));
}","static bool
load_xref(
pdfio_file_t        *VAR_0,
off_t               VAR_1,
pdfio_password_cb_t VAR_2,
void                *VAR_3)
{
boolVAR_4 = false;
charVAR_5[1024],
*VAR_6;
_pdfio_value_t VAR_7;
intmax_tVAR_8,
VAR_9,
VAR_10;
intVAR_11;
_pdfio_token_t VAR_12;
off_tVAR_13;
while (!VAR_4)
{
if (_pdfioFileSeek(VAR_0, VAR_1, VAR_14) != VAR_1)
{
_pdfioFileError(VAR_0, ""Unable to seek to start of xref table."");
return (false);
}
do
{
VAR_13 = _pdfioFileTell(VAR_0);
if (!_pdfioFileGets(VAR_0, VAR_5, sizeof(VAR_5)))
{
_pdfioFileError(VAR_0, ""Unable to read start of xref table."");
return (false);
}
}
while (!VAR_5[0]);
PDFIO_DEBUG(""load_xref: line_offset=%lu, line='%s'\n"", (unsigned long)VAR_13, VAR_5);
if (isdigit(VAR_5[0] & 255) && strlen(VAR_5) > 4 && (!strcmp(VAR_5 + strlen(VAR_5) - 4, "" obj"") || ((VAR_6 = strstr(VAR_5, "" obj"")) != NULL && VAR_6[4] == '<')))
{
pdfio_obj_t*VAR_15;
size_tVAR_16;
pdfio_array_t*VAR_17;
size_tVAR_18,
VAR_19,
VAR_20;
pdfio_array_t*VAR_21;
size_tVAR_22[3];
size_tVAR_23,
VAR_24;
size_tVAR_25;
pdfio_stream_t*VAR_26;
unsigned charVAR_27[32];
size_tVAR_28 = 0,
VAR_29[4096];
pdfio_obj_t*VAR_30;
if ((VAR_8 = strtoimax(VAR_5, &VAR_6, 10)) < 1)
{
_pdfioFileError(VAR_0, ""Bad xref table header '%s'."", VAR_5);
return (false);
}
if ((VAR_11 = (int)strtol(VAR_6, &VAR_6, 10)) < 0 || VAR_11 > 65535)
{
_pdfioFileError(VAR_0, ""Bad xref table header '%s'."", VAR_5);
return (false);
}
while (isspace(*VAR_6 & 255))
VAR_6 ++;
if (strncmp(VAR_6, ""obj"", 3))
{
_pdfioFileError(VAR_0, ""Bad xref table header '%s'."", VAR_5);
return (false);
}
if (_pdfioFileSeek(VAR_0, VAR_13 + VAR_6 + 3 - VAR_5, VAR_14) < 0)
{
_pdfioFileError(VAR_0, ""Unable to seek to xref object %lu %u."", (unsigned long)VAR_8, (unsigned)VAR_11);
return (false);
}
PDFIO_DEBUG(""load_xref: Loading object %lu %u.\n"", (unsigned long)VAR_8, (unsigned)VAR_11);
if ((VAR_15 = add_obj(VAR_0, (size_t)VAR_8, (unsigned short)VAR_11, VAR_1)) == NULL)
{
_pdfioFileError(VAR_0, ""Unable to allocate memory for object."");
return (false);
}
_pdfioTokenInit(&VAR_12, VAR_0, (_pdfio_tconsume_cb_t)VAR_31, (_pdfio_tpeek_cb_t)VAR_32, VAR_0);
if (!_pdfioValueRead(VAR_0, VAR_15, &VAR_12, &VAR_7, 0))
{
_pdfioFileError(VAR_0, ""Unable to read cross-reference stream dictionary."");
return (false);
}
else if (VAR_7.type != VAR_33)
{
_pdfioFileError(VAR_0, ""Cross-reference stream does not have a dictionary."");
return (false);
}
VAR_15->value = VAR_7;
if (!_pdfioTokenGet(&VAR_12, VAR_5, sizeof(VAR_5)) || strcmp(VAR_5, ""stream""))
{
_pdfioFileError(VAR_0, ""Unable to get stream after xref dictionary."");
return (false);
}
_pdfioTokenFlush(&VAR_12);
VAR_15->stream_offset = _pdfioFileTell(VAR_0);
if ((VAR_17 = pdfioDictGetArray(VAR_7.value.dict, ""Index"")) != NULL)
VAR_19 = VAR_17->num_values;
else
VAR_19 = 1;
if ((VAR_21 = pdfioDictGetArray(VAR_7.value.dict, ""W"")) == NULL)
{
_pdfioFileError(VAR_0, ""Cross-reference stream does not have required W key."");
return (false);
}
VAR_22[0]    = (size_t)pdfioArrayGetNumber(VAR_21, 0);
VAR_22[1]    = (size_t)pdfioArrayGetNumber(VAR_21, 1);
VAR_22[2]    = (size_t)pdfioArrayGetNumber(VAR_21, 2);
VAR_25 = VAR_22[0] + VAR_22[1] + VAR_22[2];
VAR_23     = VAR_22[0];
VAR_24     = VAR_22[0] + VAR_22[1];
if (VAR_22[1] == 0 || VAR_22[2] > 2 || VAR_22[0] > sizeof(VAR_27) || VAR_22[1] > sizeof(VAR_27) || VAR_22[2] > sizeof(VAR_27) || VAR_25 > sizeof(VAR_27))
{
_pdfioFileError(VAR_0, ""Cross-reference stream has invalid W key."");
return (false);
}
if ((VAR_26 = pdfioObjOpenStream(VAR_15, true)) == NULL)
{
_pdfioFileError(VAR_0, ""Unable to open cross-reference stream."");
return (false);
}
for (VAR_18 = 0; VAR_18 < VAR_19; VAR_18 += 2)
{
if (VAR_19 == 1)
{
VAR_8 = 0;
VAR_20  = 999999999;
}
else
{
VAR_8 = (intmax_t)pdfioArrayGetNumber(VAR_17, VAR_18);
VAR_20  = (size_t)pdfioArrayGetNumber(VAR_17, VAR_18 + 1);
}
while (VAR_20 > 0 && pdfioStreamRead(VAR_26, VAR_27, VAR_25) > 0)
{
VAR_20 --;
PDFIO_DEBUG(""load_xref: number=%u %02X%02X%02X%02X%02X\n"", (unsigned)VAR_8, VAR_27[0], VAR_27[1], VAR_27[2], VAR_27[3], VAR_27[4]);
if (VAR_22[0] > 0)
{
if (VAR_27[0] == 0)
{
VAR_8 ++;
continue;
}
}
for (VAR_16 = 1, VAR_10 = VAR_27[VAR_23]; VAR_16 < VAR_22[1]; VAR_16 ++)
VAR_10 = (VAR_10 << 8) | VAR_27[VAR_23 + VAR_16];
switch (VAR_22[2])
{
default :
VAR_11 = 0;
break;
case 1 :
VAR_11 = VAR_27[VAR_24];
break;
case 2 :
VAR_11 = (VAR_27[VAR_24] << 8) | VAR_27[VAR_24 + 1];
break;
}
if ((VAR_30 = pdfioFileFindObj(VAR_0, (size_t)VAR_8)) != NULL)
{
PDFIO_DEBUG(""load_xref: existing object, prev offset=%u\n"", (unsigned)VAR_30->offset);
if (VAR_22[0] == 0 || VAR_27[0] == 1)
{
VAR_30->offset = VAR_10;
}
else if (VAR_8 != VAR_10)
{
VAR_30->offset = 0;
}
PDFIO_DEBUG(""load_xref: new offset=%u\n"", (unsigned)VAR_30->offset);
}
if (VAR_22[0] > 0 && VAR_27[0] == 2)
{
for (VAR_16 = 0; VAR_16 < VAR_28; VAR_16 ++)
{
if (VAR_29[VAR_16] == (size_t)VAR_10)
break;
}
if (VAR_16 >= VAR_28 && VAR_28 < (sizeof(sobjs) / sizeof(sobjs[0])))
sobjs[VAR_28 ++] = (size_t)VAR_10;
}
else if (!VAR_30)
{
if (!add_obj(VAR_0, (size_t)VAR_8, (unsigned short)VAR_11, VAR_10))
return (false);
}
VAR_8 ++;
}
}
pdfioStreamClose(VAR_26);
if (!VAR_0->trailer_dict)
{
VAR_0->trailer_dict = VAR_7.value.dict;
VAR_0->info_obj     = pdfioDictGetObj(VAR_0->trailer_dict, ""Info"");
VAR_0->encrypt_obj  = pdfioDictGetObj(VAR_0->trailer_dict, ""Encrypt"");
VAR_0->id_array     = pdfioDictGetArray(VAR_0->trailer_dict, ""ID"");
if (VAR_0->encrypt_obj && !_pdfioCryptoUnlock(VAR_0, VAR_2, VAR_3))
return (false);
}
PDFIO_DEBUG(""load_xref: %lu compressed object streams to load.\n"", (unsigned long)VAR_28);
for (VAR_16 = 0; VAR_16 < VAR_28; VAR_16 ++)
{
if ((VAR_15 = pdfioFileFindObj(VAR_0, sobjs[VAR_16])) != NULL)
{
PDFIO_DEBUG(""load_xref: Loading compressed object stream %lu (pdf=%p, obj->pdf=%p).\n"", (unsigned long)sobjs[VAR_16], VAR_0, VAR_15->pdf);
if (!load_obj_stream(VAR_15))
return (false);
}
else
{
_pdfioFileError(VAR_0, ""Unable to find compressed object stream %lu."", (unsigned long)sobjs[VAR_16]);
return (false);
}
}
}
else if (!strcmp(VAR_5, ""xref""))
{
while (_pdfioFileGets(VAR_0, VAR_5, sizeof(VAR_5)))
{
if (!strcmp(VAR_5, ""trailer""))
break;
else if (!VAR_5[0])
continue;
if (sscanf(VAR_5, ""%jd%jd"", &VAR_8, &VAR_9) != 2)
{
_pdfioFileError(VAR_0, ""Malformed xref table section '%s'."", VAR_5);
return (false);
}
for (; VAR_9 > 0; VAR_9 --, VAR_8 ++)
{
if (_pdfioFileRead(VAR_0, VAR_5, 20) != 20)
return (false);
VAR_5[20] = '\0';
if (strcmp(VAR_5 + 18, ""\r\n"") && strcmp(VAR_5 + 18, "" \n"") && strcmp(VAR_5 + 18, "" \r""))
{
_pdfioFileError(VAR_0, ""Malformed xref table entry '%s'."", VAR_5);
return (false);
}
VAR_5[18] = '\0';
if ((VAR_10 = strtoimax(VAR_5, &VAR_6, 10)) < 0)
{
_pdfioFileError(VAR_0, ""Malformed xref table entry '%s'."", VAR_5);
return (false);
}
if ((VAR_11 = (int)strtol(VAR_6, &VAR_6, 10)) < 0 || VAR_11 > 65535)
{
_pdfioFileError(VAR_0, ""Malformed xref table entry '%s'."", VAR_5);
return (false);
}
if (*VAR_6 != ' ')
{
_pdfioFileError(VAR_0, ""Malformed xref table entry '%s'."", VAR_5);
return (false);
}
VAR_6 ++;
if (*VAR_6 != 'f' && *VAR_6 != 'n')
{
_pdfioFileError(VAR_0, ""Malformed xref table entry '%s'."", VAR_5);
return (false);
}
if (*VAR_6 == 'f')
continue;
if (pdfioFileFindObj(VAR_0, (size_t)VAR_8))
continue;
if (!add_obj(VAR_0, (size_t)VAR_8, (unsigned short)VAR_11, VAR_10))
return (false);
}
}
if (strcmp(VAR_5, ""trailer""))
{
_pdfioFileError(VAR_0, ""Missing trailer."");
return (false);
}
_pdfioTokenInit(&VAR_12, VAR_0, (_pdfio_tconsume_cb_t)VAR_31, (_pdfio_tpeek_cb_t)VAR_32, VAR_0);
if (!_pdfioValueRead(VAR_0, NULL, &VAR_12, &VAR_7, 0))
{
_pdfioFileError(VAR_0, ""Unable to read trailer dictionary."");
return (false);
}
else if (VAR_7.type != VAR_33)
{
_pdfioFileError(VAR_0, ""Trailer is not a dictionary."");
return (false);
}
_pdfioTokenFlush(&VAR_12);
if (!VAR_0->trailer_dict)
{
VAR_0->trailer_dict = VAR_7.value.dict;
VAR_0->info_obj     = pdfioDictGetObj(VAR_0->trailer_dict, ""Info"");
VAR_0->encrypt_obj  = pdfioDictGetObj(VAR_0->trailer_dict, ""Encrypt"");
VAR_0->id_array     = pdfioDictGetArray(VAR_0->trailer_dict, ""ID"");
if (VAR_0->encrypt_obj && !_pdfioCryptoUnlock(VAR_0, VAR_2, VAR_3))
return (false);
}
}
else
{
_pdfioFileError(VAR_0, ""Bad xref table header '%s'."", VAR_5);
return (false);
}
PDFIO_DEBUG(""load_xref: Contents of trailer dictionary:\n"");
PDFIO_DEBUG(""load_xref: "");
PDFIO_DEBUG_VALUE(&VAR_7);
PDFIO_DEBUG(""\n"");
if ((VAR_1 = (off_t)pdfioDictGetNumber(VAR_7.value.dict, ""Prev"")) <= 0)
VAR_4 = true;
}
if ((VAR_0->root_obj = pdfioDictGetObj(VAR_0->trailer_dict, ""Root"")) == NULL)
{
_pdfioFileError(VAR_0, ""Missing Root object."");
return (false);
}
PDFIO_DEBUG(""load_xref: Root=%p(%lu)\n"", VAR_0->root_obj, (unsigned long)VAR_0->root_obj->number);
return (load_pages(VAR_0, pdfioDictGetObj(pdfioObjGetDict(VAR_0->root_obj), ""Pages""), 0));
}",michaelrsweet/pdfio/4f10021e7ee527c1aa24853e2947e38e154d9ccb/pdfio-file.c/vul/before/0.json,"static bool				// O - `true` on success, `false` on failure
load_xref(
    pdfio_file_t        *pdf,		// I - PDF file
    off_t               xref_offset,	// I - Offset to xref
    pdfio_password_cb_t password_cb,	// I - Password callback or `NULL` for none
    void                *password_data)	// I - Password callback data, if any
{
  bool		done = false;		// Are we done?
  char		line[1024],		// Line from file
		*ptr;			// Pointer into line
  _pdfio_value_t trailer;		// Trailer dictionary
  intmax_t	number,			// Object number
		num_objects,		// Number of objects
		offset;			// Offset in file
  int		generation;		// Generation number
  _pdfio_token_t tb;			// Token buffer/stack
  off_t		line_offset;		// Offset to start of line


  while (!done)
  {
    if (_pdfioFileSeek(pdf, xref_offset, SEEK_SET) != xref_offset)
    {
      _pdfioFileError(pdf, ""Unable to seek to start of xref table."");
      return (false);
    }

    do
    {
      line_offset = _pdfioFileTell(pdf);

      if (!_pdfioFileGets(pdf, line, sizeof(line)))
      {
	_pdfioFileError(pdf, ""Unable to read start of xref table."");
	return (false);
      }
    }
    while (!line[0]);

    PDFIO_DEBUG(""load_xref: line_offset=%lu, line='%s'\n"", (unsigned long)line_offset, line);

    if (isdigit(line[0] & 255) && strlen(line) > 4 && (!strcmp(line + strlen(line) - 4, "" obj"") || ((ptr = strstr(line, "" obj"")) != NULL && ptr[4] == '<')))
    {
      // Cross-reference stream
      pdfio_obj_t	*obj;		// Object
      size_t		i;		// Looping var
      pdfio_array_t	*index_array;	// Index array
      size_t		index_n,	// Current element in array
			index_count,	// Number of values in index array
			count;		// Number of objects in current pairing
      pdfio_array_t	*w_array;	// W array
      size_t		w[3];		// Size of each cross-reference field
      size_t		w_2,		// Offset to second field
			w_3;		// Offset to third field
      size_t		w_total;	// Total length
      pdfio_stream_t	*st;		// Stream
      unsigned char	buffer[32];	// Read buffer
      size_t		num_sobjs = 0,	// Number of object streams
			sobjs[4096];	// Object streams to load
      pdfio_obj_t	*current;	// Current object

      if ((number = strtoimax(line, &ptr, 10)) < 1)
      {
	_pdfioFileError(pdf, ""Bad xref table header '%s'."", line);
	return (false);
      }

      if ((generation = (int)strtol(ptr, &ptr, 10)) < 0 || generation > 65535)
      {
	_pdfioFileError(pdf, ""Bad xref table header '%s'."", line);
	return (false);
      }

      while (isspace(*ptr & 255))
	ptr ++;

      if (strncmp(ptr, ""obj"", 3))
      {
	_pdfioFileError(pdf, ""Bad xref table header '%s'."", line);
	return (false);
      }

      if (_pdfioFileSeek(pdf, line_offset + ptr + 3 - line, SEEK_SET) < 0)
      {
        _pdfioFileError(pdf, ""Unable to seek to xref object %lu %u."", (unsigned long)number, (unsigned)generation);
        return (false);
      }

      PDFIO_DEBUG(""load_xref: Loading object %lu %u.\n"", (unsigned long)number, (unsigned)generation);

      if ((obj = add_obj(pdf, (size_t)number, (unsigned short)generation, xref_offset)) == NULL)
      {
        _pdfioFileError(pdf, ""Unable to allocate memory for object."");
        return (false);
      }

      _pdfioTokenInit(&tb, pdf, (_pdfio_tconsume_cb_t)_pdfioFileConsume, (_pdfio_tpeek_cb_t)_pdfioFilePeek, pdf);

      if (!_pdfioValueRead(pdf, obj, &tb, &trailer, 0))
      {
        _pdfioFileError(pdf, ""Unable to read cross-reference stream dictionary."");
        return (false);
      }
      else if (trailer.type != PDFIO_VALTYPE_DICT)
      {
	_pdfioFileError(pdf, ""Cross-reference stream does not have a dictionary."");
	return (false);
      }

      obj->value = trailer;

      if (!_pdfioTokenGet(&tb, line, sizeof(line)) || strcmp(line, ""stream""))
      {
        _pdfioFileError(pdf, ""Unable to get stream after xref dictionary."");
        return (false);
      }

      _pdfioTokenFlush(&tb);

      obj->stream_offset = _pdfioFileTell(pdf);

      if ((index_array = pdfioDictGetArray(trailer.value.dict, ""Index"")) != NULL)
        index_count = index_array->num_values;
      else
        index_count = 1;

      if ((w_array = pdfioDictGetArray(trailer.value.dict, ""W"")) == NULL)
      {
	_pdfioFileError(pdf, ""Cross-reference stream does not have required W key."");
	return (false);
      }

      w[0]    = (size_t)pdfioArrayGetNumber(w_array, 0);
      w[1]    = (size_t)pdfioArrayGetNumber(w_array, 1);
      w[2]    = (size_t)pdfioArrayGetNumber(w_array, 2);
      w_total = w[0] + w[1] + w[2];
      w_2     = w[0];
      w_3     = w[0] + w[1];

      if (w[1] == 0 || w[2] > 2 || w[0] > sizeof(buffer) || w[1] > sizeof(buffer) || w[2] > sizeof(buffer) || w_total > sizeof(buffer))
      {
	_pdfioFileError(pdf, ""Cross-reference stream has invalid W key."");
	return (false);
      }

      if ((st = pdfioObjOpenStream(obj, true)) == NULL)
      {
	_pdfioFileError(pdf, ""Unable to open cross-reference stream."");
	return (false);
      }

      for (index_n = 0; index_n < index_count; index_n += 2)
      {
        if (index_count == 1)
        {
          number = 0;
          count  = 999999999;
	}
	else
	{
          number = (intmax_t)pdfioArrayGetNumber(index_array, index_n);
          count  = (size_t)pdfioArrayGetNumber(index_array, index_n + 1);
	}

	while (count > 0 && pdfioStreamRead(st, buffer, w_total) > 0)
	{
	  count --;

	  PDFIO_DEBUG(""load_xref: number=%u %02X%02X%02X%02X%02X\n"", (unsigned)number, buffer[0], buffer[1], buffer[2], buffer[3], buffer[4]);

	  // Check whether this is an object definition...
	  if (w[0] > 0)
	  {
	    if (buffer[0] == 0)
	    {
	      // Ignore free objects...
	      number ++;
	      continue;
	    }
	  }

	  for (i = 1, offset = buffer[w_2]; i < w[1]; i ++)
	    offset = (offset << 8) | buffer[w_2 + i];

	  switch (w[2])
	  {
	    default :
		generation = 0;
		break;
	    case 1 :
		generation = buffer[w_3];
		break;
	    case 2 :
		generation = (buffer[w_3] << 8) | buffer[w_3 + 1];
		break;
	  }

	  // Create a placeholder for the object in memory...
	  if ((current = pdfioFileFindObj(pdf, (size_t)number)) != NULL)
	  {
	    PDFIO_DEBUG(""load_xref: existing object, prev offset=%u\n"", (unsigned)current->offset);

            if (w[0] == 0 || buffer[0] == 1)
            {
              // Location of object...
	      current->offset = offset;
	    }
	    else if (number != offset)
	    {
	      // Object is part of a stream, offset is the object number...
	      current->offset = 0;
	    }

	    PDFIO_DEBUG(""load_xref: new offset=%u\n"", (unsigned)current->offset);
	  }

	  if (w[0] > 0 && buffer[0] == 2)
	  {
	    // Object streams need to be loaded into memory, so add them
	    // to the list of objects to load later as needed...
	    for (i = 0; i < num_sobjs; i ++)
	    {
	      if (sobjs[i] == (size_t)offset)
		break;
	    }

	    if (i >= num_sobjs && num_sobjs < (sizeof(sobjs) / sizeof(sobjs[0])))
	      sobjs[num_sobjs ++] = (size_t)offset;
	  }
	  else if (!current)
	  {
	    // Add this object...
	    if (!add_obj(pdf, (size_t)number, (unsigned short)generation, offset))
	      return (false);
	  }

	  number ++;
	}
      }

      pdfioStreamClose(st);

      if (!pdf->trailer_dict)
      {
	// Save the trailer dictionary and grab the root (catalog) and info
	// objects...
	pdf->trailer_dict = trailer.value.dict;
	pdf->info_obj     = pdfioDictGetObj(pdf->trailer_dict, ""Info"");
	pdf->encrypt_obj  = pdfioDictGetObj(pdf->trailer_dict, ""Encrypt"");
	pdf->id_array     = pdfioDictGetArray(pdf->trailer_dict, ""ID"");

	// If the trailer contains an Encrypt key, try unlocking the file...
	if (pdf->encrypt_obj && !_pdfioCryptoUnlock(pdf, password_cb, password_data))
	  return (false);
      }

      // Load any object streams that are left...
      PDFIO_DEBUG(""load_xref: %lu compressed object streams to load.\n"", (unsigned long)num_sobjs);

      for (i = 0; i < num_sobjs; i ++)
      {
        if ((obj = pdfioFileFindObj(pdf, sobjs[i])) != NULL)
        {
	  PDFIO_DEBUG(""load_xref: Loading compressed object stream %lu (pdf=%p, obj->pdf=%p).\n"", (unsigned long)sobjs[i], pdf, obj->pdf);

          if (!load_obj_stream(obj))
            return (false);
	}
	else
	{
	  _pdfioFileError(pdf, ""Unable to find compressed object stream %lu."", (unsigned long)sobjs[i]);
	  return (false);
	}
      }
    }
    else if (!strcmp(line, ""xref""))
    {
      // Read the xref tables
      while (_pdfioFileGets(pdf, line, sizeof(line)))
      {
	if (!strcmp(line, ""trailer""))
	  break;
	else if (!line[0])
	  continue;

	if (sscanf(line, ""%jd%jd"", &number, &num_objects) != 2)
	{
	  _pdfioFileError(pdf, ""Malformed xref table section '%s'."", line);
	  return (false);
	}

	// Read this group of objects...
	for (; num_objects > 0; num_objects --, number ++)
	{
	  // Read a line from the file and validate it...
	  if (_pdfioFileRead(pdf, line, 20) != 20)
	    return (false);

	  line[20] = '\0';

	  if (strcmp(line + 18, ""\r\n"") && strcmp(line + 18, "" \n"") && strcmp(line + 18, "" \r""))
	  {
	    _pdfioFileError(pdf, ""Malformed xref table entry '%s'."", line);
	    return (false);
	  }
	  line[18] = '\0';

	  // Parse the line
	  if ((offset = strtoimax(line, &ptr, 10)) < 0)
	  {
	    _pdfioFileError(pdf, ""Malformed xref table entry '%s'."", line);
	    return (false);
	  }

	  if ((generation = (int)strtol(ptr, &ptr, 10)) < 0 || generation > 65535)
	  {
	    _pdfioFileError(pdf, ""Malformed xref table entry '%s'."", line);
	    return (false);
	  }

	  if (*ptr != ' ')
	  {
	    _pdfioFileError(pdf, ""Malformed xref table entry '%s'."", line);
	    return (false);
	  }

	  ptr ++;
	  if (*ptr != 'f' && *ptr != 'n')
	  {
	    _pdfioFileError(pdf, ""Malformed xref table entry '%s'."", line);
	    return (false);
	  }

	  if (*ptr == 'f')
	    continue;			// Don't care about free objects...

	  // Create a placeholder for the object in memory...
	  if (pdfioFileFindObj(pdf, (size_t)number))
	    continue;			// Don't replace newer object...

	  if (!add_obj(pdf, (size_t)number, (unsigned short)generation, offset))
	    return (false);
	}
      }

      if (strcmp(line, ""trailer""))
      {
	_pdfioFileError(pdf, ""Missing trailer."");
	return (false);
      }

      _pdfioTokenInit(&tb, pdf, (_pdfio_tconsume_cb_t)_pdfioFileConsume, (_pdfio_tpeek_cb_t)_pdfioFilePeek, pdf);

      if (!_pdfioValueRead(pdf, NULL, &tb, &trailer, 0))
      {
	_pdfioFileError(pdf, ""Unable to read trailer dictionary."");
	return (false);
      }
      else if (trailer.type != PDFIO_VALTYPE_DICT)
      {
	_pdfioFileError(pdf, ""Trailer is not a dictionary."");
	return (false);
      }

      PDFIO_DEBUG(""load_xref: Got trailer dict.\n"");

      _pdfioTokenFlush(&tb);

      if (!pdf->trailer_dict)
      {
	// Save the trailer dictionary and grab the root (catalog) and info
	// objects...
	pdf->trailer_dict = trailer.value.dict;
	pdf->info_obj     = pdfioDictGetObj(pdf->trailer_dict, ""Info"");
	pdf->encrypt_obj  = pdfioDictGetObj(pdf->trailer_dict, ""Encrypt"");
	pdf->id_array     = pdfioDictGetArray(pdf->trailer_dict, ""ID"");

	// If the trailer contains an Encrypt key, try unlocking the file...
	if (pdf->encrypt_obj && !_pdfioCryptoUnlock(pdf, password_cb, password_data))
	  return (false);
      }
    }
    else
    {
      _pdfioFileError(pdf, ""Bad xref table header '%s'."", line);
      return (false);
    }

    PDFIO_DEBUG(""load_xref: Contents of trailer dictionary:\n"");
    PDFIO_DEBUG(""load_xref: "");
    PDFIO_DEBUG_VALUE(&trailer);
    PDFIO_DEBUG(""\n"");

    if ((xref_offset = (off_t)pdfioDictGetNumber(trailer.value.dict, ""Prev"")) <= 0)
      done = true;
  }

  // Once we have all of the xref tables loaded, get the important objects and
  // build the pages array...
  if ((pdf->root_obj = pdfioDictGetObj(pdf->trailer_dict, ""Root"")) == NULL)
  {
    _pdfioFileError(pdf, ""Missing Root object."");
    return (false);
  }

  PDFIO_DEBUG(""load_xref: Root=%p(%lu)\n"", pdf->root_obj, (unsigned long)pdf->root_obj->number);

  return (load_pages(pdf, pdfioDictGetObj(pdfioObjGetDict(pdf->root_obj), ""Pages""), 0));
}","static bool				/* COMMENT_0 */
load_xref(
    pdfio_file_t        *VAR_0,		/* COMMENT_1 */
    off_t               VAR_1,	/* COMMENT_2 */
    pdfio_password_cb_t VAR_2,	/* COMMENT_3 */
    void                *VAR_3)	/* COMMENT_4 */
{
  bool		VAR_4 = false;		/* COMMENT_5 */
  char		VAR_5[1024],		/* COMMENT_6 */
		*VAR_6;			/* COMMENT_7 */
  _pdfio_value_t VAR_7;		/* COMMENT_8 */
  intmax_t	VAR_8,			/* COMMENT_9 */
		VAR_9,		/* COMMENT_10 */
		VAR_10;			/* COMMENT_11 */
  int		VAR_11;		/* COMMENT_12 */
  _pdfio_token_t VAR_12;			/* COMMENT_13 */
  off_t		VAR_13;		/* COMMENT_14 */


  while (!VAR_4)
  {
    if (_pdfioFileSeek(VAR_0, VAR_1, VAR_14) != VAR_1)
    {
      _pdfioFileError(VAR_0, ""Unable to seek to start of xref table."");
      return (false);
    }

    do
    {
      VAR_13 = _pdfioFileTell(VAR_0);

      if (!_pdfioFileGets(VAR_0, VAR_5, sizeof(VAR_5)))
      {
	_pdfioFileError(VAR_0, ""Unable to read start of xref table."");
	return (false);
      }
    }
    while (!VAR_5[0]);

    PDFIO_DEBUG(""load_xref: line_offset=%lu, line='%s'\n"", (unsigned long)VAR_13, VAR_5);

    if (isdigit(VAR_5[0] & 255) && strlen(VAR_5) > 4 && (!strcmp(VAR_5 + strlen(VAR_5) - 4, "" obj"") || ((VAR_6 = strstr(VAR_5, "" obj"")) != NULL && VAR_6[4] == '<')))
    {
      /* COMMENT_15 */
      pdfio_obj_t	*VAR_15;		/* COMMENT_16 */
      size_t		VAR_16;		/* COMMENT_17 */
      pdfio_array_t	*VAR_17;	/* COMMENT_18 */
      size_t		VAR_18,	/* COMMENT_19 */
			VAR_19,	/* COMMENT_20 */
			VAR_20;		/* COMMENT_21 */
      pdfio_array_t	*VAR_21;	/* COMMENT_22 */
      size_t		VAR_22[3];		/* COMMENT_23 */
      size_t		VAR_23,		/* COMMENT_24 */
			VAR_24;		/* COMMENT_25 */
      size_t		VAR_25;	/* COMMENT_26 */
      pdfio_stream_t	*VAR_26;		/* COMMENT_27 */
      unsigned char	VAR_27[32];	/* COMMENT_28 */
      size_t		VAR_28 = 0,	/* COMMENT_29 */
			VAR_29[4096];	/* COMMENT_30 */
      pdfio_obj_t	*VAR_30;	/* COMMENT_31 */

      if ((VAR_8 = strtoimax(VAR_5, &VAR_6, 10)) < 1)
      {
	_pdfioFileError(VAR_0, ""Bad xref table header '%s'."", VAR_5);
	return (false);
      }

      if ((VAR_11 = (int)strtol(VAR_6, &VAR_6, 10)) < 0 || VAR_11 > 65535)
      {
	_pdfioFileError(VAR_0, ""Bad xref table header '%s'."", VAR_5);
	return (false);
      }

      while (isspace(*VAR_6 & 255))
	VAR_6 ++;

      if (strncmp(VAR_6, ""obj"", 3))
      {
	_pdfioFileError(VAR_0, ""Bad xref table header '%s'."", VAR_5);
	return (false);
      }

      if (_pdfioFileSeek(VAR_0, VAR_13 + VAR_6 + 3 - VAR_5, VAR_14) < 0)
      {
        _pdfioFileError(VAR_0, ""Unable to seek to xref object %lu %u."", (unsigned long)VAR_8, (unsigned)VAR_11);
        return (false);
      }

      PDFIO_DEBUG(""load_xref: Loading object %lu %u.\n"", (unsigned long)VAR_8, (unsigned)VAR_11);

      if ((VAR_15 = add_obj(VAR_0, (size_t)VAR_8, (unsigned short)VAR_11, VAR_1)) == NULL)
      {
        _pdfioFileError(VAR_0, ""Unable to allocate memory for object."");
        return (false);
      }

      _pdfioTokenInit(&VAR_12, VAR_0, (_pdfio_tconsume_cb_t)VAR_31, (_pdfio_tpeek_cb_t)VAR_32, VAR_0);

      if (!_pdfioValueRead(VAR_0, VAR_15, &VAR_12, &VAR_7, 0))
      {
        _pdfioFileError(VAR_0, ""Unable to read cross-reference stream dictionary."");
        return (false);
      }
      else if (VAR_7.type != VAR_33)
      {
	_pdfioFileError(VAR_0, ""Cross-reference stream does not have a dictionary."");
	return (false);
      }

      VAR_15->value = VAR_7;

      if (!_pdfioTokenGet(&VAR_12, VAR_5, sizeof(VAR_5)) || strcmp(VAR_5, ""stream""))
      {
        _pdfioFileError(VAR_0, ""Unable to get stream after xref dictionary."");
        return (false);
      }

      _pdfioTokenFlush(&VAR_12);

      VAR_15->stream_offset = _pdfioFileTell(VAR_0);

      if ((VAR_17 = pdfioDictGetArray(VAR_7.value.dict, ""Index"")) != NULL)
        VAR_19 = VAR_17->num_values;
      else
        VAR_19 = 1;

      if ((VAR_21 = pdfioDictGetArray(VAR_7.value.dict, ""W"")) == NULL)
      {
	_pdfioFileError(VAR_0, ""Cross-reference stream does not have required W key."");
	return (false);
      }

      VAR_22[0]    = (size_t)pdfioArrayGetNumber(VAR_21, 0);
      VAR_22[1]    = (size_t)pdfioArrayGetNumber(VAR_21, 1);
      VAR_22[2]    = (size_t)pdfioArrayGetNumber(VAR_21, 2);
      VAR_25 = VAR_22[0] + VAR_22[1] + VAR_22[2];
      VAR_23     = VAR_22[0];
      VAR_24     = VAR_22[0] + VAR_22[1];

      if (VAR_22[1] == 0 || VAR_22[2] > 2 || VAR_22[0] > sizeof(VAR_27) || VAR_22[1] > sizeof(VAR_27) || VAR_22[2] > sizeof(VAR_27) || VAR_25 > sizeof(VAR_27))
      {
	_pdfioFileError(VAR_0, ""Cross-reference stream has invalid W key."");
	return (false);
      }

      if ((VAR_26 = pdfioObjOpenStream(VAR_15, true)) == NULL)
      {
	_pdfioFileError(VAR_0, ""Unable to open cross-reference stream."");
	return (false);
      }

      for (VAR_18 = 0; VAR_18 < VAR_19; VAR_18 += 2)
      {
        if (VAR_19 == 1)
        {
          VAR_8 = 0;
          VAR_20  = 999999999;
	}
	else
	{
          VAR_8 = (intmax_t)pdfioArrayGetNumber(VAR_17, VAR_18);
          VAR_20  = (size_t)pdfioArrayGetNumber(VAR_17, VAR_18 + 1);
	}

	while (VAR_20 > 0 && pdfioStreamRead(VAR_26, VAR_27, VAR_25) > 0)
	{
	  VAR_20 --;

	  PDFIO_DEBUG(""load_xref: number=%u %02X%02X%02X%02X%02X\n"", (unsigned)VAR_8, VAR_27[0], VAR_27[1], VAR_27[2], VAR_27[3], VAR_27[4]);

	  /* COMMENT_32 */
	  if (VAR_22[0] > 0)
	  {
	    if (VAR_27[0] == 0)
	    {
	      /* COMMENT_33 */
	      VAR_8 ++;
	      continue;
	    }
	  }

	  for (VAR_16 = 1, VAR_10 = VAR_27[VAR_23]; VAR_16 < VAR_22[1]; VAR_16 ++)
	    VAR_10 = (VAR_10 << 8) | VAR_27[VAR_23 + VAR_16];

	  switch (VAR_22[2])
	  {
	    default :
		VAR_11 = 0;
		break;
	    case 1 :
		VAR_11 = VAR_27[VAR_24];
		break;
	    case 2 :
		VAR_11 = (VAR_27[VAR_24] << 8) | VAR_27[VAR_24 + 1];
		break;
	  }

	  /* COMMENT_34 */
	  if ((VAR_30 = pdfioFileFindObj(VAR_0, (size_t)VAR_8)) != NULL)
	  {
	    PDFIO_DEBUG(""load_xref: existing object, prev offset=%u\n"", (unsigned)VAR_30->offset);

            if (VAR_22[0] == 0 || VAR_27[0] == 1)
            {
              /* COMMENT_35 */
	      VAR_30->offset = VAR_10;
	    }
	    else if (VAR_8 != VAR_10)
	    {
	      /* COMMENT_36 */
	      VAR_30->offset = 0;
	    }

	    PDFIO_DEBUG(""load_xref: new offset=%u\n"", (unsigned)VAR_30->offset);
	  }

	  if (VAR_22[0] > 0 && VAR_27[0] == 2)
	  {
	    /* COMMENT_37 */
	    /* COMMENT_38 */
	    for (VAR_16 = 0; VAR_16 < VAR_28; VAR_16 ++)
	    {
	      if (VAR_29[VAR_16] == (size_t)VAR_10)
		break;
	    }

	    if (VAR_16 >= VAR_28 && VAR_28 < (sizeof(sobjs) / sizeof(sobjs[0])))
	      sobjs[VAR_28 ++] = (size_t)VAR_10;
	  }
	  else if (!VAR_30)
	  {
	    /* COMMENT_39 */
	    if (!add_obj(VAR_0, (size_t)VAR_8, (unsigned short)VAR_11, VAR_10))
	      return (false);
	  }

	  VAR_8 ++;
	}
      }

      pdfioStreamClose(VAR_26);

      if (!VAR_0->trailer_dict)
      {
	/* COMMENT_40 */
	/* COMMENT_41 */
	VAR_0->trailer_dict = VAR_7.value.dict;
	VAR_0->info_obj     = pdfioDictGetObj(VAR_0->trailer_dict, ""Info"");
	VAR_0->encrypt_obj  = pdfioDictGetObj(VAR_0->trailer_dict, ""Encrypt"");
	VAR_0->id_array     = pdfioDictGetArray(VAR_0->trailer_dict, ""ID"");

	/* COMMENT_42 */
	if (VAR_0->encrypt_obj && !_pdfioCryptoUnlock(VAR_0, VAR_2, VAR_3))
	  return (false);
      }

      /* COMMENT_43 */
      PDFIO_DEBUG(""load_xref: %lu compressed object streams to load.\n"", (unsigned long)VAR_28);

      for (VAR_16 = 0; VAR_16 < VAR_28; VAR_16 ++)
      {
        if ((VAR_15 = pdfioFileFindObj(VAR_0, sobjs[VAR_16])) != NULL)
        {
	  PDFIO_DEBUG(""load_xref: Loading compressed object stream %lu (pdf=%p, obj->pdf=%p).\n"", (unsigned long)sobjs[VAR_16], VAR_0, VAR_15->pdf);

          if (!load_obj_stream(VAR_15))
            return (false);
	}
	else
	{
	  _pdfioFileError(VAR_0, ""Unable to find compressed object stream %lu."", (unsigned long)sobjs[VAR_16]);
	  return (false);
	}
      }
    }
    else if (!strcmp(VAR_5, ""xref""))
    {
      /* COMMENT_44 */
      while (_pdfioFileGets(VAR_0, VAR_5, sizeof(VAR_5)))
      {
	if (!strcmp(VAR_5, ""trailer""))
	  break;
	else if (!VAR_5[0])
	  continue;

	if (sscanf(VAR_5, ""%jd%jd"", &VAR_8, &VAR_9) != 2)
	{
	  _pdfioFileError(VAR_0, ""Malformed xref table section '%s'."", VAR_5);
	  return (false);
	}

	/* COMMENT_45 */
	for (; VAR_9 > 0; VAR_9 --, VAR_8 ++)
	{
	  /* COMMENT_46 */
	  if (_pdfioFileRead(VAR_0, VAR_5, 20) != 20)
	    return (false);

	  VAR_5[20] = '\0';

	  if (strcmp(VAR_5 + 18, ""\r\n"") && strcmp(VAR_5 + 18, "" \n"") && strcmp(VAR_5 + 18, "" \r""))
	  {
	    _pdfioFileError(VAR_0, ""Malformed xref table entry '%s'."", VAR_5);
	    return (false);
	  }
	  VAR_5[18] = '\0';

	  /* COMMENT_47 */
	  if ((VAR_10 = strtoimax(VAR_5, &VAR_6, 10)) < 0)
	  {
	    _pdfioFileError(VAR_0, ""Malformed xref table entry '%s'."", VAR_5);
	    return (false);
	  }

	  if ((VAR_11 = (int)strtol(VAR_6, &VAR_6, 10)) < 0 || VAR_11 > 65535)
	  {
	    _pdfioFileError(VAR_0, ""Malformed xref table entry '%s'."", VAR_5);
	    return (false);
	  }

	  if (*VAR_6 != ' ')
	  {
	    _pdfioFileError(VAR_0, ""Malformed xref table entry '%s'."", VAR_5);
	    return (false);
	  }

	  VAR_6 ++;
	  if (*VAR_6 != 'f' && *VAR_6 != 'n')
	  {
	    _pdfioFileError(VAR_0, ""Malformed xref table entry '%s'."", VAR_5);
	    return (false);
	  }

	  if (*VAR_6 == 'f')
	    continue;			/* COMMENT_48 */

	  /* COMMENT_34 */
	  if (pdfioFileFindObj(VAR_0, (size_t)VAR_8))
	    continue;			/* COMMENT_49 */

	  if (!add_obj(VAR_0, (size_t)VAR_8, (unsigned short)VAR_11, VAR_10))
	    return (false);
	}
      }

      if (strcmp(VAR_5, ""trailer""))
      {
	_pdfioFileError(VAR_0, ""Missing trailer."");
	return (false);
      }

      _pdfioTokenInit(&VAR_12, VAR_0, (_pdfio_tconsume_cb_t)VAR_31, (_pdfio_tpeek_cb_t)VAR_32, VAR_0);

      if (!_pdfioValueRead(VAR_0, NULL, &VAR_12, &VAR_7, 0))
      {
	_pdfioFileError(VAR_0, ""Unable to read trailer dictionary."");
	return (false);
      }
      else if (VAR_7.type != VAR_33)
      {
	_pdfioFileError(VAR_0, ""Trailer is not a dictionary."");
	return (false);
      }

      PDFIO_DEBUG(""load_xref: Got trailer dict.\n"");

      _pdfioTokenFlush(&VAR_12);

      if (!VAR_0->trailer_dict)
      {
	/* COMMENT_40 */
	/* COMMENT_41 */
	VAR_0->trailer_dict = VAR_7.value.dict;
	VAR_0->info_obj     = pdfioDictGetObj(VAR_0->trailer_dict, ""Info"");
	VAR_0->encrypt_obj  = pdfioDictGetObj(VAR_0->trailer_dict, ""Encrypt"");
	VAR_0->id_array     = pdfioDictGetArray(VAR_0->trailer_dict, ""ID"");

	/* COMMENT_42 */
	if (VAR_0->encrypt_obj && !_pdfioCryptoUnlock(VAR_0, VAR_2, VAR_3))
	  return (false);
      }
    }
    else
    {
      _pdfioFileError(VAR_0, ""Bad xref table header '%s'."", VAR_5);
      return (false);
    }

    PDFIO_DEBUG(""load_xref: Contents of trailer dictionary:\n"");
    PDFIO_DEBUG(""load_xref: "");
    PDFIO_DEBUG_VALUE(&VAR_7);
    PDFIO_DEBUG(""\n"");

    if ((VAR_1 = (off_t)pdfioDictGetNumber(VAR_7.value.dict, ""Prev"")) <= 0)
      VAR_4 = true;
  }

  /* COMMENT_50 */
  /* COMMENT_51 */
  if ((VAR_0->root_obj = pdfioDictGetObj(VAR_0->trailer_dict, ""Root"")) == NULL)
  {
    _pdfioFileError(VAR_0, ""Missing Root object."");
    return (false);
  }

  PDFIO_DEBUG(""load_xref: Root=%p(%lu)\n"", VAR_0->root_obj, (unsigned long)VAR_0->root_obj->number);

  return (load_pages(VAR_0, pdfioDictGetObj(pdfioObjGetDict(VAR_0->root_obj), ""Pages""), 0));
}",michaelrsweet/pdfio/4f10021e7ee527c1aa24853e2947e38e154d9ccb/pdfio-file.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -362,6 +362,8 @@
 	return (false);
       }
 
+      PDFIO_DEBUG(""load_xref: Got trailer dict.\n"");
+
       _pdfioTokenFlush(&tb);
 
       if (!pdf->trailer_dict)","{'deleted_lines': [], 'added_lines': ['      PDFIO_DEBUG(""load_xref: Got trailer dict.\\n"");', '']}",True, PDFio is a C library for reading and writing PDF files. In versions prior to 1.1.0 a denial of service (DOS) vulnerability exists in the pdfio parser. Crafted pdf files can cause the program to run at 100% utilization and never terminate. The pdf which causes this crash found in testing is about 28kb in size and was discovered via fuzzing. Anyone who uses this library either as a standalone binary or as a library can be DOSed when attempting to parse this type of file. Web servers or other automated processes which rely on this code to turn pdf submissions into plaintext can be DOSed when an attacker uploads the pdf. Please see the linked GHSA for an example pdf. Users are advised to upgrade. There are no known workarounds for this vulnerability.,5.3,MEDIUM,1,test,2023-02-04T01:39:04Z,4
CVE-2023-24808,['CWE-835'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,michaelrsweet/pdfio,Fix denial-of-service attack when reading corrupt PDF files.,4f10021e7ee527c1aa24853e2947e38e154d9ccb,https://github.com/michaelrsweet/pdfio/commit/4f10021e7ee527c1aa24853e2947e38e154d9ccb,pdfio-dict.c,_pdfioDictRead,"pdfio_dict_t *_pdfioDictRead(pdfio_file_t   *pdf,               pdfio_obj_t    *obj,               _pdfio_token_t *tb,               size_t         depth){
pdfio_dict_t*dict;  charkey[256];  _pdfio_value_tvalue;
PDFIO_DEBUG(""_pdfioDictRead(pdf=%p)\n"", pdf);
if ((dict = pdfioDictCreate(pdf)) == NULL)
return (NULL);
while (_pdfioTokenGet(tb, key, sizeof(key)))
{
if (!strcmp(key, "">>""))
{
return (dict);
}
else if (key[0] != '/')
{
_pdfioFileError(pdf, ""Invalid dictionary contents."");
break;
}
if (!_pdfioValueRead(pdf, obj, tb, &value, depth))
{
_pdfioFileError(pdf, ""Missing value for dictionary key."");
break;
}
if (!_pdfioDictSetValue(dict, pdfioStringCreate(pdf, key + 1), &value))
break;
}
return (NULL);
}","pdfio_dict_t *
_pdfioDictRead(pdfio_file_t   *VAR_0,
pdfio_obj_t    *VAR_1,
_pdfio_token_t *VAR_2,
size_t         VAR_3)
{
pdfio_dict_t*VAR_4;
charVAR_5[256];
_pdfio_value_tVAR_6;
PDFIO_DEBUG(""_pdfioDictRead(pdf=%p)\n"", VAR_0);
if ((VAR_4 = pdfioDictCreate(VAR_0)) == NULL)
return (NULL);
while (_pdfioTokenGet(VAR_2, VAR_5, sizeof(VAR_5)))
{
if (!strcmp(VAR_5, "">>""))
{
return (VAR_4);
}
else if (VAR_5[0] != '/')
{
_pdfioFileError(VAR_0, ""Invalid dictionary contents."");
break;
}
if (!_pdfioValueRead(VAR_0, VAR_1, VAR_2, &VAR_6, VAR_3))
{
_pdfioFileError(VAR_0, ""Missing value for dictionary key."");
break;
}
if (!_pdfioDictSetValue(VAR_4, pdfioStringCreate(VAR_0, VAR_5 + 1), &VAR_6))
break;
}
return (NULL);
}",michaelrsweet/pdfio/4f10021e7ee527c1aa24853e2947e38e154d9ccb/pdfio-dict.c/vul/before/1.json,"pdfio_dict_t *				// O - New dictionary
_pdfioDictRead(pdfio_file_t   *pdf,	// I - PDF file
               pdfio_obj_t    *obj,	// I - Object, if any
               _pdfio_token_t *tb,	// I - Token buffer/stack
               size_t         depth)	// I - Depth of dictionary
{
  pdfio_dict_t		*dict;		// New dictionary
  char			key[256];	// Dictionary key
  _pdfio_value_t	value;		// Dictionary value


  PDFIO_DEBUG(""_pdfioDictRead(pdf=%p)\n"", pdf);

  // Create a dictionary and start reading...
  if ((dict = pdfioDictCreate(pdf)) == NULL)
    return (NULL);

  while (_pdfioTokenGet(tb, key, sizeof(key)))
  {
    // Get the next key or end-of-dictionary...
    if (!strcmp(key, "">>""))
    {
      // End of dictionary...
      return (dict);
    }
    else if (key[0] != '/')
    {
      _pdfioFileError(pdf, ""Invalid dictionary contents."");
      break;
    }
    else if (_pdfioDictGetValue(dict, key + 1))
    {
      _pdfioFileError(pdf, ""Duplicate dictionary key '%s'."", key + 1);
      return (NULL);
    }

    // Then get the next value...
    PDFIO_DEBUG(""_pdfioDictRead: Reading value for '%s'.\n"", key + 1);

    if (!_pdfioValueRead(pdf, obj, tb, &value, depth))
    {
      _pdfioFileError(pdf, ""Missing value for dictionary key."");
      break;
    }

    if (!_pdfioDictSetValue(dict, pdfioStringCreate(pdf, key + 1), &value))
      break;

//    PDFIO_DEBUG(""_pdfioDictRead: Set %s.\n"", key);
  }

  // Dictionary is invalid - pdfioFileClose will free the memory, return NULL
  // to indicate an error...
  return (NULL);
}","pdfio_dict_t *				/* COMMENT_0 */
_pdfioDictRead(pdfio_file_t   *VAR_0,	/* COMMENT_1 */
               pdfio_obj_t    *VAR_1,	/* COMMENT_2 */
               _pdfio_token_t *VAR_2,	/* COMMENT_3 */
               size_t         VAR_3)	/* COMMENT_4 */
{
  pdfio_dict_t		*VAR_4;		/* COMMENT_5 */
  char			VAR_5[256];	/* COMMENT_6 */
  _pdfio_value_t	VAR_6;		/* COMMENT_7 */


  PDFIO_DEBUG(""_pdfioDictRead(pdf=%p)\n"", VAR_0);

  /* COMMENT_8 */
  if ((VAR_4 = pdfioDictCreate(VAR_0)) == NULL)
    return (NULL);

  while (_pdfioTokenGet(VAR_2, VAR_5, sizeof(VAR_5)))
  {
    /* COMMENT_9 */
    if (!strcmp(VAR_5, "">>""))
    {
      /* COMMENT_10 */
      return (VAR_4);
    }
    else if (VAR_5[0] != '/')
    {
      _pdfioFileError(VAR_0, ""Invalid dictionary contents."");
      break;
    }
    else if (_pdfioDictGetValue(VAR_4, VAR_5 + 1))
    {
      _pdfioFileError(VAR_0, ""Duplicate dictionary key '%s'."", VAR_5 + 1);
      return (NULL);
    }

    /* COMMENT_11 */
    PDFIO_DEBUG(""_pdfioDictRead: Reading value for '%s'.\n"", VAR_5 + 1);

    if (!_pdfioValueRead(VAR_0, VAR_1, VAR_2, &VAR_6, VAR_3))
    {
      _pdfioFileError(VAR_0, ""Missing value for dictionary key."");
      break;
    }

    if (!_pdfioDictSetValue(VAR_4, pdfioStringCreate(VAR_0, VAR_5 + 1), &VAR_6))
      break;

/* COMMENT_12 */
  }

  /* COMMENT_13 */
  /* COMMENT_14 */
  return (NULL);
}",michaelrsweet/pdfio/4f10021e7ee527c1aa24853e2947e38e154d9ccb/pdfio-dict.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -28,8 +28,15 @@
       _pdfioFileError(pdf, ""Invalid dictionary contents."");
       break;
     }
+    else if (_pdfioDictGetValue(dict, key + 1))
+    {
+      _pdfioFileError(pdf, ""Duplicate dictionary key '%s'."", key + 1);
+      return (NULL);
+    }
 
     // Then get the next value...
+    PDFIO_DEBUG(""_pdfioDictRead: Reading value for '%s'.\n"", key + 1);
+
     if (!_pdfioValueRead(pdf, obj, tb, &value, depth))
     {
       _pdfioFileError(pdf, ""Missing value for dictionary key."");","{'deleted_lines': [], 'added_lines': ['    else if (_pdfioDictGetValue(dict, key + 1))', '    {', '      _pdfioFileError(pdf, ""Duplicate dictionary key \'%s\'."", key + 1);', '      return (NULL);', '    }', '    PDFIO_DEBUG(""_pdfioDictRead: Reading value for \'%s\'.\\n"", key + 1);', '']}",True, PDFio is a C library for reading and writing PDF files. In versions prior to 1.1.0 a denial of service (DOS) vulnerability exists in the pdfio parser. Crafted pdf files can cause the program to run at 100% utilization and never terminate. The pdf which causes this crash found in testing is about 28kb in size and was discovered via fuzzing. Anyone who uses this library either as a standalone binary or as a library can be DOSed when attempting to parse this type of file. Web servers or other automated processes which rely on this code to turn pdf submissions into plaintext can be DOSed when an attacker uploads the pdf. Please see the linked GHSA for an example pdf. Users are advised to upgrade. There are no known workarounds for this vulnerability.,5.3,MEDIUM,1,test,2023-02-04T01:39:04Z,4
CVE-2023-24808,['CWE-835'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,michaelrsweet/pdfio,Fix denial-of-service attack when reading corrupt PDF files.,4f10021e7ee527c1aa24853e2947e38e154d9ccb,https://github.com/michaelrsweet/pdfio/commit/4f10021e7ee527c1aa24853e2947e38e154d9ccb,pdfio-dict.c,_pdfioDictSetValue,"bool_pdfioDictSetValue(
pdfio_dict_t   *dict,    const char     *key,    _pdfio_value_t *value){
_pdfio_pair_t*pair;
PDFIO_DEBUG(""_pdfioDictSetValue(dict=%p, key=\""%s\"", value=%p)\n"", dict, key, (void *)value);
if (dict->num_pairs > 0)
{
_pdfio_pair_tpkey;
pkey.key = key;
if ((pair = (_pdfio_pair_t *)bsearch(&pkey, dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs)) != NULL)
{
PDFIO_DEBUG(""_pdfioDictSetValue: Replacing existing value.\n"");
if (pair->value.type == PDFIO_VALTYPE_BINARY)
free(pair->value.value.binary.data);
pair->value = *value;
return (true);
}
}
if (dict->num_pairs >= dict->alloc_pairs)
{
_pdfio_pair_t *temp = (_pdfio_pair_t *)realloc(dict->pairs, (dict->alloc_pairs + 8) * sizeof(_pdfio_pair_t));
if (!temp)
{
PDFIO_DEBUG(""_pdfioDictSetValue: Out of memory.\n"");
return (false);
}
dict->pairs       = temp;
dict->alloc_pairs += 8;
}
pair = dict->pairs + dict->num_pairs;
dict->num_pairs ++;
pair->key   = key;
pair->value = *value;
if (dict->num_pairs > 1 && compare_pairs(pair - 1, pair) > 0)
qsort(dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs);
#ifdef DEBUG
PDFIO_DEBUG(""_pdfioDictSetValue(%p): %lu pairs\n"", (void *)dict, (unsigned long)dict->num_pairs);
PDFIO_DEBUG(""_pdfioDictSetValue(%p): "", (void *)dict);
PDFIO_DEBUG_DICT(dict);
PDFIO_DEBUG(""\n"");
#endif 
return (true);
}","bool
_pdfioDictSetValue(
pdfio_dict_t   *VAR_0,
const char     *VAR_1,
_pdfio_value_t *VAR_2)
{
_pdfio_pair_t*VAR_3;
PDFIO_DEBUG(""_pdfioDictSetValue(dict=%p, key=\""%s\"", value=%p)\n"", VAR_0, VAR_1, (void *)VAR_2);
if (VAR_0->num_pairs > 0)
{
_pdfio_pair_tVAR_4;
VAR_4.key = VAR_1;
if ((VAR_3 = (_pdfio_pair_t *)bsearch(&VAR_4, VAR_0->pairs, VAR_0->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))VAR_5)) != NULL)
{
PDFIO_DEBUG(""_pdfioDictSetValue: Replacing existing value.\n"");
if (VAR_3->value.type == VAR_6)
free(VAR_3->value.value.binary.data);
VAR_3->value = *VAR_2;
return (true);
}
}
if (VAR_0->num_pairs >= VAR_0->alloc_pairs)
{
_pdfio_pair_t *VAR_7 = (_pdfio_pair_t *)realloc(VAR_0->pairs, (VAR_0->alloc_pairs + 8) * sizeof(_pdfio_pair_t));
if (!VAR_7)
{
PDFIO_DEBUG(""_pdfioDictSetValue: Out of memory.\n"");
return (false);
}
VAR_0->pairs       = VAR_7;
VAR_0->alloc_pairs += 8;
}
VAR_3 = VAR_0->pairs + VAR_0->num_pairs;
VAR_0->num_pairs ++;
VAR_3->key   = VAR_1;
VAR_3->value = *VAR_2;
if (VAR_0->num_pairs > 1 && VAR_5(VAR_3 - 1, VAR_3) > 0)
qsort(VAR_0->pairs, VAR_0->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))VAR_5);
#ifdef VAR_8
PDFIO_DEBUG(""_pdfioDictSetValue(%p): %lu pairs\n"", (void *)VAR_0, (unsigned long)VAR_0->num_pairs);
PDFIO_DEBUG(""_pdfioDictSetValue(%p): "", (void *)VAR_0);
PDFIO_DEBUG_DICT(VAR_0);
PDFIO_DEBUG(""\n"");
#endif 
return (true);
}",michaelrsweet/pdfio/4f10021e7ee527c1aa24853e2947e38e154d9ccb/pdfio-dict.c/vul/before/0.json,"bool					// O - `true` on success, `false` on failure
_pdfioDictSetValue(
    pdfio_dict_t   *dict,		// I - Dictionary
    const char     *key,		// I - Key
    _pdfio_value_t *value)		// I - Value
{
  _pdfio_pair_t	*pair;			// Current pair


  PDFIO_DEBUG(""_pdfioDictSetValue(dict=%p, key=\""%s\"", value=%p)\n"", dict, key, (void *)value);

  // See if the key is already set...
  if (dict->num_pairs > 0)
  {
    _pdfio_pair_t	pkey;		// Search key

    pkey.key = key;

    if ((pair = (_pdfio_pair_t *)bsearch(&pkey, dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs)) != NULL)
    {
      // Yes, replace the value...
      PDFIO_DEBUG(""_pdfioDictSetValue: Replacing existing value.\n"");
      if (pair->value.type == PDFIO_VALTYPE_BINARY)
        free(pair->value.value.binary.data);
      pair->value = *value;
      return (true);
    }
  }

  // Nope, add a pair...
  if (dict->num_pairs >= dict->alloc_pairs)
  {
    // Expand the dictionary...
    _pdfio_pair_t *temp = (_pdfio_pair_t *)realloc(dict->pairs, (dict->alloc_pairs + 8) * sizeof(_pdfio_pair_t));

    if (!temp)
    {
      PDFIO_DEBUG(""_pdfioDictSetValue: Out of memory.\n"");
      return (false);
    }

    dict->pairs       = temp;
    dict->alloc_pairs += 8;
  }

  pair = dict->pairs + dict->num_pairs;
  dict->num_pairs ++;

  pair->key   = key;
  pair->value = *value;

  // Re-sort the dictionary and return...
  if (dict->num_pairs > 1 && compare_pairs(pair - 1, pair) > 0)
    qsort(dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs);

#ifdef DEBUG
  PDFIO_DEBUG(""_pdfioDictSetValue(%p): %lu pairs\n"", (void *)dict, (unsigned long)dict->num_pairs);
//  PDFIO_DEBUG(""_pdfioDictSetValue(%p): "", (void *)dict);
//  PDFIO_DEBUG_DICT(dict);
//  PDFIO_DEBUG(""\n"");
#endif // DEBUG

  return (true);
}","bool					/* COMMENT_0 */
_pdfioDictSetValue(
    pdfio_dict_t   *VAR_0,		/* COMMENT_1 */
    const char     *VAR_1,		/* COMMENT_2 */
    _pdfio_value_t *VAR_2)		/* COMMENT_3 */
{
  _pdfio_pair_t	*VAR_3;			/* COMMENT_4 */


  PDFIO_DEBUG(""_pdfioDictSetValue(dict=%p, key=\""%s\"", value=%p)\n"", VAR_0, VAR_1, (void *)VAR_2);

  /* COMMENT_5 */
  if (VAR_0->num_pairs > 0)
  {
    _pdfio_pair_t	VAR_4;		/* COMMENT_6 */

    VAR_4.key = VAR_1;

    if ((VAR_3 = (_pdfio_pair_t *)bsearch(&VAR_4, VAR_0->pairs, VAR_0->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))VAR_5)) != NULL)
    {
      /* COMMENT_7 */
      PDFIO_DEBUG(""_pdfioDictSetValue: Replacing existing value.\n"");
      if (VAR_3->value.type == VAR_6)
        free(VAR_3->value.value.binary.data);
      VAR_3->value = *VAR_2;
      return (true);
    }
  }

  /* COMMENT_8 */
  if (VAR_0->num_pairs >= VAR_0->alloc_pairs)
  {
    /* COMMENT_9 */
    _pdfio_pair_t *VAR_7 = (_pdfio_pair_t *)realloc(VAR_0->pairs, (VAR_0->alloc_pairs + 8) * sizeof(_pdfio_pair_t));

    if (!VAR_7)
    {
      PDFIO_DEBUG(""_pdfioDictSetValue: Out of memory.\n"");
      return (false);
    }

    VAR_0->pairs       = VAR_7;
    VAR_0->alloc_pairs += 8;
  }

  VAR_3 = VAR_0->pairs + VAR_0->num_pairs;
  VAR_0->num_pairs ++;

  VAR_3->key   = VAR_1;
  VAR_3->value = *VAR_2;

  /* COMMENT_10 */
  if (VAR_0->num_pairs > 1 && VAR_5(VAR_3 - 1, VAR_3) > 0)
    qsort(VAR_0->pairs, VAR_0->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))VAR_5);

#ifdef VAR_8
  PDFIO_DEBUG(""_pdfioDictSetValue(%p): %lu pairs\n"", (void *)VAR_0, (unsigned long)VAR_0->num_pairs);
/* COMMENT_11 */
/* COMMENT_12 */
/* COMMENT_13 */
#endif /* COMMENT_14 */

  return (true);
}",michaelrsweet/pdfio/4f10021e7ee527c1aa24853e2947e38e154d9ccb/pdfio-dict.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -55,9 +55,9 @@
 
 #ifdef DEBUG
   PDFIO_DEBUG(""_pdfioDictSetValue(%p): %lu pairs\n"", (void *)dict, (unsigned long)dict->num_pairs);
-  PDFIO_DEBUG(""_pdfioDictSetValue(%p): "", (void *)dict);
-  PDFIO_DEBUG_DICT(dict);
-  PDFIO_DEBUG(""\n"");
+//  PDFIO_DEBUG(""_pdfioDictSetValue(%p): "", (void *)dict);
+//  PDFIO_DEBUG_DICT(dict);
+//  PDFIO_DEBUG(""\n"");
 #endif // DEBUG
 
   return (true);","{'deleted_lines': ['  PDFIO_DEBUG(""_pdfioDictSetValue(%p): "", (void *)dict);', '  PDFIO_DEBUG_DICT(dict);', '  PDFIO_DEBUG(""\\n"");'], 'added_lines': ['//  PDFIO_DEBUG(""_pdfioDictSetValue(%p): "", (void *)dict);', '//  PDFIO_DEBUG_DICT(dict);', '//  PDFIO_DEBUG(""\\n"");']}",True, PDFio is a C library for reading and writing PDF files. In versions prior to 1.1.0 a denial of service (DOS) vulnerability exists in the pdfio parser. Crafted pdf files can cause the program to run at 100% utilization and never terminate. The pdf which causes this crash found in testing is about 28kb in size and was discovered via fuzzing. Anyone who uses this library either as a standalone binary or as a library can be DOSed when attempting to parse this type of file. Web servers or other automated processes which rely on this code to turn pdf submissions into plaintext can be DOSed when an attacker uploads the pdf. Please see the linked GHSA for an example pdf. Users are advised to upgrade. There are no known workarounds for this vulnerability.,5.3,MEDIUM,1,test,2023-02-04T01:39:04Z,4
CVE-2023-1449,['CWE-415'],AV:L/AC:L/Au:S/C:P/I:P/A:P,0,gpac,av1: flush samples on parse error (#2387),8ebbfd61c73d61a2913721a492e5a81fb8d9f9a9,https://github.com/gpac/gpac/commit/8ebbfd61c73d61a2913721a492e5a81fb8d9f9a9,src/filters/reframe_av1.c,av1dmx_parse_av1,"GF_Err av1dmx_parse_av1(GF_Filter *filter, GF_AV1DmxCtx *ctx)
{
GF_Err e = GF_OK;
u64 start;
if (!ctx->is_playing) {
ctx->state.frame_state.is_first_frame = GF_TRUE;
}
start = gf_bs_get_position(ctx->bs);
switch (ctx->bsmode) {
case OBUs:
if (ctx->state.bs && gf_bs_get_position(ctx->state.bs) && (ctx->state.obu_type == OBU_TEMPORAL_DELIMITER)) {
e = GF_OK;
} else {
e = aom_av1_parse_temporal_unit_from_section5(ctx->bs, &ctx->state);
}
break;
case AnnexB:
if (ctx->state.bs && gf_bs_get_position(ctx->state.bs)) {
e = GF_OK;
} else {
e = aom_av1_parse_temporal_unit_from_annexb(ctx->bs, &ctx->state);
if (e==GF_BUFFER_TOO_SMALL) {
gf_av1_reset_state(&ctx->state, GF_FALSE);
gf_bs_seek(ctx->bs, start);
}
}
break;
case IVF:
if (ctx->state.bs && gf_bs_get_position(ctx->state.bs)) {
e = GF_OK;
} else {
e = aom_av1_parse_temporal_unit_from_ivf(ctx->bs, &ctx->state);
}
break;
default:
e = GF_NOT_SUPPORTED;
}
av1dmx_check_pid(filter, ctx);
if (ctx->timescale && (e==GF_BUFFER_TOO_SMALL))
e = GF_OK;
if (e) return e;
if (!ctx->opid) {
if (ctx->state.obu_type != OBU_TEMPORAL_DELIMITER) {
GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (""[AV1Dmx] output pid not configured (no sequence header yet ?), skipping OBU\n""));
}
gf_av1_reset_state(&ctx->state, GF_FALSE);
return GF_OK;
}
if (!ctx->is_playing) {
return GF_OK;
}
return av1dmx_parse_flush_sample(filter, ctx);
}","GF_Err av1dmx_parse_av1(GF_Filter *VAR_0, GF_AV1DmxCtx *VAR_1)
{
GF_Err VAR_2 = VAR_3;
u64 VAR_4;
if (!VAR_1->is_playing) {
VAR_1->state.frame_state.is_first_frame = VAR_5;
}
VAR_4 = gf_bs_get_position(VAR_1->bs);
switch (VAR_1->bsmode) {
case VAR_6:
if (VAR_1->state.bs && gf_bs_get_position(VAR_1->state.bs) && (VAR_1->state.obu_type == VAR_7)) {
VAR_2 = VAR_3;
} else {
VAR_2 = aom_av1_parse_temporal_unit_from_section5(VAR_1->bs, &VAR_1->state);
}
break;
case VAR_8:
if (VAR_1->state.bs && gf_bs_get_position(VAR_1->state.bs)) {
VAR_2 = VAR_3;
} else {
VAR_2 = aom_av1_parse_temporal_unit_from_annexb(VAR_1->bs, &VAR_1->state);
if (VAR_2==VAR_9) {
gf_av1_reset_state(&VAR_1->state, VAR_10);
gf_bs_seek(VAR_1->bs, VAR_4);
}
}
break;
case VAR_11:
if (VAR_1->state.bs && gf_bs_get_position(VAR_1->state.bs)) {
VAR_2 = VAR_3;
} else {
VAR_2 = aom_av1_parse_temporal_unit_from_ivf(VAR_1->bs, &VAR_1->state);
}
break;
default:
VAR_2 = VAR_12;
}
av1dmx_check_pid(VAR_0, VAR_1);
if (VAR_1->timescale && (VAR_2==VAR_9))
VAR_2 = VAR_3;
if (VAR_2) return VAR_2;
if (!VAR_1->opid) {
if (VAR_1->state.obu_type != VAR_7) {
GF_LOG(VAR_13, VAR_14, (""[AV1Dmx] output pid not configured (no sequence header yet ?), skipping OBU\n""));
}
gf_av1_reset_state(&VAR_1->state, VAR_10);
return VAR_3;
}
if (!VAR_1->is_playing) {
return VAR_3;
}
return av1dmx_parse_flush_sample(VAR_0, VAR_1);
}",gpac/8ebbfd61c73d61a2913721a492e5a81fb8d9f9a9/reframe_av1.c/vul/before/1.json,"GF_Err av1dmx_parse_av1(GF_Filter *filter, GF_AV1DmxCtx *ctx)
{
	GF_Err e = GF_OK;
	u64 start;

	if (!ctx->is_playing) {
		ctx->state.frame_state.is_first_frame = GF_TRUE;
	}

	/*we process each TU and extract only the necessary OBUs*/
	start = gf_bs_get_position(ctx->bs);
	switch (ctx->bsmode) {
	case OBUs:
		//first frame loaded !
		if (ctx->state.bs && gf_bs_get_position(ctx->state.bs) && (ctx->state.obu_type == OBU_TEMPORAL_DELIMITER)) {
			e = GF_OK;
		} else {
			e = aom_av1_parse_temporal_unit_from_section5(ctx->bs, &ctx->state);
		}
		break;
	case AnnexB:
		//first TU loaded !
		if (ctx->state.bs && gf_bs_get_position(ctx->state.bs)) {
			e = GF_OK;
		} else {
			e = aom_av1_parse_temporal_unit_from_annexb(ctx->bs, &ctx->state);
			if (e==GF_BUFFER_TOO_SMALL) {
				gf_av1_reset_state(&ctx->state, GF_FALSE);
				gf_bs_seek(ctx->bs, start);
			}
		}
		break;
	case IVF:
		//first frame loaded !
		if (ctx->state.bs && gf_bs_get_position(ctx->state.bs)) {
			e = GF_OK;
		} else {
			e = aom_av1_parse_temporal_unit_from_ivf(ctx->bs, &ctx->state);
		}
		break;
	default:
		e = GF_NOT_SUPPORTED;
	}

	//check pid state
	av1dmx_check_pid(filter, ctx);

	//fixme, we need to flush at each DFG start - for now we assume one PES = one DFG as we do in the muxer
	if (ctx->timescale && (e==GF_BUFFER_TOO_SMALL))
		e = GF_OK;

	if (e) {
		if (e!=GF_EOS && e!=GF_BUFFER_TOO_SMALL) {
			av1dmx_parse_flush_sample(filter, ctx);
		}
		return e;
	}


	if (!ctx->opid) {
		if (ctx->state.obu_type != OBU_TEMPORAL_DELIMITER) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (""[AV1Dmx] output pid not configured (no sequence header yet ?), skipping OBU\n""));
		}
		gf_av1_reset_state(&ctx->state, GF_FALSE);
		return GF_OK;
	}

	if (!ctx->is_playing) {
		//don't reset state we would skip seq header obu in first frame
		//gf_av1_reset_state(&ctx->state, GF_FALSE);
		return GF_OK;
	}

	return av1dmx_parse_flush_sample(filter, ctx);

}","GF_Err av1dmx_parse_av1(GF_Filter *VAR_0, GF_AV1DmxCtx *VAR_1)
{
	GF_Err VAR_2 = VAR_3;
	u64 VAR_4;

	if (!VAR_1->is_playing) {
		VAR_1->state.frame_state.is_first_frame = VAR_5;
	}

	/* COMMENT_0 */
	VAR_4 = gf_bs_get_position(VAR_1->bs);
	switch (VAR_1->bsmode) {
	case VAR_6:
		/* COMMENT_1 */
		if (VAR_1->state.bs && gf_bs_get_position(VAR_1->state.bs) && (VAR_1->state.obu_type == VAR_7)) {
			VAR_2 = VAR_3;
		} else {
			VAR_2 = aom_av1_parse_temporal_unit_from_section5(VAR_1->bs, &VAR_1->state);
		}
		break;
	case VAR_8:
		/* COMMENT_2 */
		if (VAR_1->state.bs && gf_bs_get_position(VAR_1->state.bs)) {
			VAR_2 = VAR_3;
		} else {
			VAR_2 = aom_av1_parse_temporal_unit_from_annexb(VAR_1->bs, &VAR_1->state);
			if (VAR_2==VAR_9) {
				gf_av1_reset_state(&VAR_1->state, VAR_10);
				gf_bs_seek(VAR_1->bs, VAR_4);
			}
		}
		break;
	case VAR_11:
		/* COMMENT_1 */
		if (VAR_1->state.bs && gf_bs_get_position(VAR_1->state.bs)) {
			VAR_2 = VAR_3;
		} else {
			VAR_2 = aom_av1_parse_temporal_unit_from_ivf(VAR_1->bs, &VAR_1->state);
		}
		break;
	default:
		VAR_2 = VAR_12;
	}

	/* COMMENT_3 */
	av1dmx_check_pid(VAR_0, VAR_1);

	/* COMMENT_4 */
	if (VAR_1->timescale && (VAR_2==VAR_9))
		VAR_2 = VAR_3;

	if (VAR_2) {
		if (VAR_2!=VAR_13 && VAR_2!=VAR_9) {
			av1dmx_parse_flush_sample(VAR_0, VAR_1);
		}
		return VAR_2;
	}


	if (!VAR_1->opid) {
		if (VAR_1->state.obu_type != VAR_7) {
			GF_LOG(VAR_14, VAR_15, (""[AV1Dmx] output pid not configured (no sequence header yet ?), skipping OBU\n""));
		}
		gf_av1_reset_state(&VAR_1->state, VAR_10);
		return VAR_3;
	}

	if (!VAR_1->is_playing) {
		/* COMMENT_5 */
		/* COMMENT_6 */
		return VAR_3;
	}

	return av1dmx_parse_flush_sample(VAR_0, VAR_1);

}",gpac/8ebbfd61c73d61a2913721a492e5a81fb8d9f9a9/reframe_av1.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -49,7 +49,12 @@
 	if (ctx->timescale && (e==GF_BUFFER_TOO_SMALL))
 		e = GF_OK;
 
-	if (e) return e;
+	if (e) {
+		if (e!=GF_EOS && e!=GF_BUFFER_TOO_SMALL) {
+			av1dmx_parse_flush_sample(filter, ctx);
+		}
+		return e;
+	}
 
 
 	if (!ctx->opid) {","{'deleted_lines': ['\tif (e) return e;'], 'added_lines': ['\tif (e) {', '\t\tif (e!=GF_EOS && e!=GF_BUFFER_TOO_SMALL) {', '\t\t\tav1dmx_parse_flush_sample(filter, ctx);', '\t\t}', '\t\treturn e;', '\t}']}",True,A vulnerability has been found in GPAC 2.3-DEV-rev35-gbbca86917-master and classified as problematic. This vulnerability affects the function gf_av1_reset_state of the file media_tools/av_parsers.c. The manipulation leads to double free. It is possible to launch the attack on the local host. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. VDB-223294 is the identifier assigned to this vulnerability.,7.8,HIGH,2,test,2023-02-10T14:36:49Z,4
CVE-2023-1449,['CWE-415'],AV:L/AC:L/Au:S/C:P/I:P/A:P,0,gpac,av1: flush samples on parse error (#2387),8ebbfd61c73d61a2913721a492e5a81fb8d9f9a9,https://github.com/gpac/gpac/commit/8ebbfd61c73d61a2913721a492e5a81fb8d9f9a9,src/filters/reframe_av1.c,av1dmx_parse_flush_sample,"static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx)
{
u32 pck_size = 0;
GF_FilterPacket *pck = NULL;
u8 *output = NULL;
if (!ctx->opid)
return GF_NON_COMPLIANT_BITSTREAM;
gf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);
if (!pck_size) {
GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (""[AV1Dmx] no frame OBU, skipping OBU\n""));
return GF_OK;
}
pck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);
if (!pck) return GF_OUT_OF_MEM;
if (ctx->src_pck)
gf_filter_pck_merge_properties(ctx->src_pck, pck);
gf_filter_pck_set_cts(pck, ctx->cts);
gf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0);
memcpy(output, ctx->state.frame_obus, pck_size);
if (ctx->deps) {
u8 flags = 0;
flags = ( ctx->state.frame_state.key_frame) ? 2 : 1;
flags <<= 2;
flags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2;
flags <<= 2;
gf_filter_pck_set_dependency_flags(pck, flags);
}
if (ctx->state.clli_valid) {
u32 crc = gf_crc_32(ctx->state.clli_data, 4);
if (crc != ctx->clli_crc) {
gf_filter_pck_set_property(pck, GF_PROP_PID_CONTENT_LIGHT_LEVEL, &PROP_DATA(ctx->state.clli_data, 4));
}
}
if (ctx->state.mdcv_valid) {
u32 crc = gf_crc_32(ctx->state.mdcv_data, 24);
if (crc != ctx->mdcv_crc) {
av1dmx_set_mdcv(ctx, NULL, pck);
}
}
gf_filter_pck_send(pck);
av1dmx_update_cts(ctx);
gf_av1_reset_state(&ctx->state, GF_FALSE);
return GF_OK;
}","static GF_Err av1dmx_parse_flush_sample(GF_Filter *VAR_0, GF_AV1DmxCtx *VAR_1)
{
u32 VAR_2 = 0;
GF_FilterPacket *VAR_3 = NULL;
u8 *VAR_4 = NULL;
if (!VAR_1->opid)
return VAR_5;
gf_bs_get_content_no_truncate(VAR_1->state.bs, &VAR_1->state.frame_obus, &VAR_2, &VAR_1->state.frame_obus_alloc);
if (!VAR_2) {
GF_LOG(VAR_6, VAR_7, (""[AV1Dmx] no frame OBU, skipping OBU\n""));
return VAR_8;
}
VAR_3 = gf_filter_pck_new_alloc(VAR_1->opid, VAR_2, &VAR_4);
if (!VAR_3) return VAR_9;
if (VAR_1->src_pck)
gf_filter_pck_merge_properties(VAR_1->src_pck, VAR_3);
gf_filter_pck_set_cts(VAR_3, VAR_1->cts);
gf_filter_pck_set_sap(VAR_3, VAR_1->state.frame_state.key_frame ? VAR_10 : 0);
memcpy(VAR_4, VAR_1->state.frame_obus, VAR_2);
if (VAR_1->deps) {
u8 VAR_11 = 0;
VAR_11 = ( VAR_1->state.frame_state.key_frame) ? 2 : 1;
VAR_11 <<= 2;
VAR_11 |= VAR_1->state.frame_state.refresh_frame_flags ? 1 : 2;
VAR_11 <<= 2;
gf_filter_pck_set_dependency_flags(VAR_3, VAR_11);
}
if (VAR_1->state.clli_valid) {
u32 VAR_12 = gf_crc_32(VAR_1->state.clli_data, 4);
if (VAR_12 != VAR_1->clli_crc) {
gf_filter_pck_set_property(VAR_3, VAR_13, &PROP_DATA(VAR_1->state.clli_data, 4));
}
}
if (VAR_1->state.mdcv_valid) {
u32 VAR_12 = gf_crc_32(VAR_1->state.mdcv_data, 24);
if (VAR_12 != VAR_1->mdcv_crc) {
av1dmx_set_mdcv(VAR_1, NULL, VAR_3);
}
}
gf_filter_pck_send(VAR_3);
av1dmx_update_cts(VAR_1);
gf_av1_reset_state(&VAR_1->state, VAR_14);
return VAR_8;
}",gpac/8ebbfd61c73d61a2913721a492e5a81fb8d9f9a9/reframe_av1.c/vul/before/0.json,"static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx)
{
	u32 pck_size = 0;
	GF_FilterPacket *pck = NULL;
	u8 *output = NULL;

	if (!ctx->opid)
		return GF_NON_COMPLIANT_BITSTREAM;

	gf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);

	if (!pck_size) {
		GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (""[AV1Dmx] no frame OBU, skipping OBU\n""));
		return GF_OK;
	}

	pck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);
	if (!pck) return GF_OUT_OF_MEM;

	if (ctx->src_pck)
		gf_filter_pck_merge_properties(ctx->src_pck, pck);

	gf_filter_pck_set_cts(pck, ctx->cts);
	gf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0);

	memcpy(output, ctx->state.frame_obus, pck_size);

	if (ctx->deps) {
		u8 flags = 0;
		//dependsOn
		flags = ( ctx->state.frame_state.key_frame) ? 2 : 1;
		flags <<= 2;
		//dependedOn
	 	flags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2;
		flags <<= 2;
		//hasRedundant
	 	//flags |= ctx->has_redundant ? 1 : 2;
	 	gf_filter_pck_set_dependency_flags(pck, flags);
	}

	if (ctx->state.clli_valid) {
		u32 crc = gf_crc_32(ctx->state.clli_data, 4);
		if (crc != ctx->clli_crc) {
			gf_filter_pck_set_property(pck, GF_PROP_PID_CONTENT_LIGHT_LEVEL, &PROP_DATA(ctx->state.clli_data, 4));
		}
	}
	if (ctx->state.mdcv_valid) {
		u32 crc = gf_crc_32(ctx->state.mdcv_data, 24);
		if (crc != ctx->mdcv_crc) {
			av1dmx_set_mdcv(ctx, NULL, pck);
		}
	}

	gf_filter_pck_send(pck);

	av1dmx_update_cts(ctx);
	gf_av1_reset_state(&ctx->state, GF_FALSE);

	return GF_OK;

}","static GF_Err av1dmx_parse_flush_sample(GF_Filter *VAR_0, GF_AV1DmxCtx *VAR_1)
{
	u32 VAR_2 = 0;
	GF_FilterPacket *VAR_3 = NULL;
	u8 *VAR_4 = NULL;

	if (!VAR_1->opid)
		return VAR_5;

	gf_bs_get_content_no_truncate(VAR_1->state.bs, &VAR_1->state.frame_obus, &VAR_2, &VAR_1->state.frame_obus_alloc);

	if (!VAR_2) {
		GF_LOG(VAR_6, VAR_7, (""[AV1Dmx] no frame OBU, skipping OBU\n""));
		return VAR_8;
	}

	VAR_3 = gf_filter_pck_new_alloc(VAR_1->opid, VAR_2, &VAR_4);
	if (!VAR_3) return VAR_9;

	if (VAR_1->src_pck)
		gf_filter_pck_merge_properties(VAR_1->src_pck, VAR_3);

	gf_filter_pck_set_cts(VAR_3, VAR_1->cts);
	gf_filter_pck_set_sap(VAR_3, VAR_1->state.frame_state.key_frame ? VAR_10 : 0);

	memcpy(VAR_4, VAR_1->state.frame_obus, VAR_2);

	if (VAR_1->deps) {
		u8 VAR_11 = 0;
		/* COMMENT_0 */
		VAR_11 = ( VAR_1->state.frame_state.key_frame) ? 2 : 1;
		VAR_11 <<= 2;
		/* COMMENT_1 */
	 	VAR_11 |= VAR_1->state.frame_state.refresh_frame_flags ? 1 : 2;
		VAR_11 <<= 2;
		/* COMMENT_2 */
	 	/* COMMENT_3 */
	 	gf_filter_pck_set_dependency_flags(VAR_3, VAR_11);
	}

	if (VAR_1->state.clli_valid) {
		u32 VAR_12 = gf_crc_32(VAR_1->state.clli_data, 4);
		if (VAR_12 != VAR_1->clli_crc) {
			gf_filter_pck_set_property(VAR_3, VAR_13, &PROP_DATA(VAR_1->state.clli_data, 4));
		}
	}
	if (VAR_1->state.mdcv_valid) {
		u32 VAR_12 = gf_crc_32(VAR_1->state.mdcv_data, 24);
		if (VAR_12 != VAR_1->mdcv_crc) {
			av1dmx_set_mdcv(VAR_1, NULL, VAR_3);
		}
	}

	gf_filter_pck_send(VAR_3);

	av1dmx_update_cts(VAR_1);
	gf_av1_reset_state(&VAR_1->state, VAR_14);

	return VAR_8;

}",gpac/8ebbfd61c73d61a2913721a492e5a81fb8d9f9a9/reframe_av1.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
 
 	if (!ctx->opid)
 		return GF_NON_COMPLIANT_BITSTREAM;
-		
+
 	gf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);
 
 	if (!pck_size) {","{'deleted_lines': ['\t\t'], 'added_lines': ['']}",True,A vulnerability has been found in GPAC 2.3-DEV-rev35-gbbca86917-master and classified as problematic. This vulnerability affects the function gf_av1_reset_state of the file media_tools/av_parsers.c. The manipulation leads to double free. It is possible to launch the attack on the local host. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. VDB-223294 is the identifier assigned to this vulnerability.,7.8,HIGH,2,test,2023-02-10T14:36:49Z,4
CVE-2022-46377,['CWE-125'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,weston-embedded/uC-FTPs,Patched DoS vulnerabilities CVE-2022-46377 and CVE-2022-46378 / TALOS-2022-1681.,2bbf7c6111766f626923ca5acd29ea827ea5128f,https://github.com/weston-embedded/uC-FTPs/commit/2bbf7c6111766f626923ca5acd29ea827ea5128f,Source/ftp-s.c,FTPs_ProcessCtrlCmd,"static  void  FTPs_ProcessCtrlCmd (FTPs_SESSION_STRUCT  *ftp_session)
{
CPU_CHAR       *p_cmd_arg;
CPU_CHAR       *p_file_time;
void           *p_file;
void           *p_dir;
NET_FS_ENTRY    dirent;
CPU_INT32U      path_name_len;
CPU_INT08U     *p_addr;
CPU_INT08U     *p_port;
NET_IPv4_ADDR   addr;
NET_PORT_NBR    port;
CPU_INT16S      cmp_val;
CPU_BOOLEAN     dig;
CPU_BOOLEAN     rtn_val;
CPU_INT32U      i;
NET_ERR         net_err;
CPU_SR_ALLOC();
p_dir = (void *)0;
switch (ftp_session->CtrlCmd) {
case FTP_CMD_NOOP:
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_OKAY, (CPU_CHAR *)0);
break;
case FTP_CMD_QUIT:
FTPs_StopPasvMode(ftp_session);
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_SERVERCLOSING, (CPU_CHAR *)0);
break;
case FTP_CMD_REIN:
FTPs_StopPasvMode(ftp_session);
ftp_session->CtrlState = FTPs_STATE_LOGOUT;
ftp_session->DtpMode   = FTP_MODE_STREAM;
ftp_session->DtpType   = FTP_TYPE_ASCII;
ftp_session->DtpForm   = FTP_FORM_NONPRINT;
ftp_session->DtpStru   = FTP_STRU_FILE;
ftp_session->DtpCmd    = FTP_CMD_NOOP;
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_OKAY, (CPU_CHAR *)0);
break;
case FTP_CMD_SYST:
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_SYSTEMTYPE, (CPU_CHAR *)0);
break;
case FTP_CMD_FEAT:
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_SYSTEMSTATUS, (CPU_CHAR *)0);
break;
case FTP_CMD_HELP:
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_HELPMESSAGE, (CPU_CHAR *)0);
break;
case FTP_CMD_USER:
p_cmd_arg = FTPs_FindArg(&ftp_session->CtrlCmdArgs);
if (*p_cmd_arg != (CPU_CHAR)0) {
Str_Copy_N(ftp_session->User, p_cmd_arg, sizeof(ftp_session->User));
ftp_session->CtrlState = FTPs_STATE_GOTUSER;
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_NEEDPASSWORD, (CPU_CHAR *)0);
} else {
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PARMSYNTAXERR, (CPU_CHAR *)0);
}
break;
case FTP_CMD_PASS:
p_cmd_arg = FTPs_FindArg(&ftp_session->CtrlCmdArgs);
if (*p_cmd_arg != (CPU_CHAR)0) {
Str_Copy_N(ftp_session->Pass, p_cmd_arg, sizeof(ftp_session->Pass));
rtn_val = FTPs_AuthUser(ftp_session);
if (rtn_val == DEF_OK) {
ftp_session->CtrlState = FTPs_STATE_LOGIN;
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_LOGGEDIN, (CPU_CHAR *)0);
} else {
ftp_session->CtrlState = FTPs_STATE_LOGOUT;
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_NOTLOGGEDIN, (CPU_CHAR *)0);
}
} else {
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PARMSYNTAXERR, (CPU_CHAR *)0);
}
break;
case FTP_CMD_MODE:
p_cmd_arg = FTPs_FindArg(&ftp_session->CtrlCmdArgs);
switch (*p_cmd_arg) {
case FTP_MODE_STREAM:
ftp_session->DtpMode = FTP_MODE_STREAM;
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_OKAY, (CPU_CHAR *)0);
break;
case FTP_MODE_BLOCK:
case FTP_MODE_COMPRESSED:
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PARMNOSUPPORT, (CPU_CHAR *)0);
break;
default:
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PARMSYNTAXERR, (CPU_CHAR *)0);
break;
}
break;
case FTP_CMD_TYPE:
p_cmd_arg = FTPs_FindArg(&ftp_session->CtrlCmdArgs);
switch (*p_cmd_arg) {
case FTP_TYPE_ASCII:
p_cmd_arg = FTPs_FindArg(&ftp_session->CtrlCmdArgs);
switch (*p_cmd_arg) {
case (CPU_CHAR)0:
case FTP_FORM_NONPRINT:
ftp_session->DtpType = FTP_TYPE_ASCII;
ftp_session->DtpForm = FTP_FORM_NONPRINT;
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_OKAY, (CPU_CHAR *)0);
break;
case FTP_FORM_TELNET:
case FTP_FORM_CARGCTRL:
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PARMNOSUPPORT, (CPU_CHAR *)0);
break;
default:
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PARMSYNTAXERR, (CPU_CHAR *)0);
break;
}
break;
case FTP_TYPE_IMAGE:
ftp_session->DtpType = FTP_TYPE_IMAGE;
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_OKAY, (CPU_CHAR *)0);
break;
case FTP_TYPE_LOCAL:
case FTP_TYPE_EBCDIC:
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PARMNOSUPPORT, (CPU_CHAR *)0);
break;
default:
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PARMSYNTAXERR, (CPU_CHAR *)0);
break;
}
break;
case FTP_CMD_STRU:
p_cmd_arg = FTPs_FindArg(&ftp_session->CtrlCmdArgs);
switch (*p_cmd_arg) {
case FTP_STRU_FILE:
ftp_session->DtpStru = FTP_STRU_FILE;
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_OKAY, (CPU_CHAR *)0);
break;
case FTP_STRU_RECORD:
case FTP_STRU_PAGE:
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PARMNOSUPPORT, (CPU_CHAR *)0);
break;
default:
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PARMSYNTAXERR, (CPU_CHAR *)0);
break;
}
break;
case FTP_CMD_PASV:
CPU_CRITICAL_ENTER();
addr = FTPs_PublicAddr;
port = FTPs_PublicPort;
CPU_CRITICAL_EXIT();
ftp_session->DtpSockAddr.Addr = NET_UTIL_HOST_TO_NET_32(NET_IPv4_ADDR_ANY);
ftp_session->DtpSockAddr.Port = NET_UTIL_HOST_TO_NET_16(port);
FTPs_StartPasvMode(ftp_session, &net_err);
if (ftp_session->DtpPasv == DEF_YES) {
addr = NET_UTIL_HOST_TO_NET_32(addr);
port = NET_UTIL_HOST_TO_NET_16(port);
p_addr = (CPU_INT08U *)&addr;
p_port = (CPU_INT08U *)&port;
Str_FmtPrint((char       *)FTPs_NetBufCtrlCmdPtr,
FTPs_NET_BUF_LEN,
(char       *)FTPs_Reply[FTP_REPLY_ENTERPASVMODE].ReplyStr,
(unsigned int)p_addr[0],
(unsigned int)p_addr[1],
(unsigned int)p_addr[2],
(unsigned int)p_addr[3],
(unsigned int)p_port[0],
(unsigned int)p_port[1]);
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_ENTERPASVMODE, FTPs_NetBufCtrlCmdPtr);
} else {
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_CANTOPENDATA, (CPU_CHAR *)0);
}
break;
case FTP_CMD_PORT:
FTPs_StopPasvMode(ftp_session);
if (ftp_session->DtpPasv == DEF_NO) {
p_addr = (CPU_INT08U *)&ftp_session->DtpSockAddr.Addr;
p_port = (CPU_INT08U *)&ftp_session->DtpSockAddr.Port;
for (i = 0; i <= 3; i++) {
dig = ASCII_IsDig(*ftp_session->CtrlCmdArgs);
while ((dig == DEF_NO) && (ftp_session->CtrlCmdArgs != (CPU_CHAR *)0)) {
ftp_session->CtrlCmdArgs++;
dig = ASCII_IsDig(*ftp_session->CtrlCmdArgs);
}
p_addr[i] = Str_ParseNbr_Int32U(ftp_session->CtrlCmdArgs, &ftp_session->CtrlCmdArgs, 10);
}
for (i = 0; i <= 1; i++) {
dig = ASCII_IsDig(*ftp_session->CtrlCmdArgs);
while ((dig == DEF_NO) && (ftp_session->CtrlCmdArgs != 0)) {
ftp_session->CtrlCmdArgs++;
dig = ASCII_IsDig(*ftp_session->CtrlCmdArgs);
}
p_port[i] = Str_ParseNbr_Int32U(ftp_session->CtrlCmdArgs, &ftp_session->CtrlCmdArgs, 10);
}
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_OKAY, (CPU_CHAR *)0);
} else {
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_CANTOPENDATA, (CPU_CHAR *)0);
}
break;
case FTP_CMD_REST:
p_cmd_arg = FTPs_FindArg(&ftp_session->CtrlCmdArgs);
if (*p_cmd_arg != (CPU_CHAR)0) {
ftp_session->DtpOffset = Str_ParseNbr_Int32U(p_cmd_arg, 0, 10);
ftp_session->CtrlState = FTPs_STATE_GOTREST;
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_NEEDMOREINFO, (CPU_CHAR *)0);
}
break;
case FTP_CMD_PWD:
case FTP_CMD_CWD:
case FTP_CMD_CDUP:
case FTP_CMD_MKD:
case FTP_CMD_RMD:
case FTP_CMD_NLST:
case FTP_CMD_LIST:
case FTP_CMD_RETR:
case FTP_CMD_STOR:
case FTP_CMD_APPE:
case FTP_CMD_DELE:
case FTP_CMD_RNFR:
case FTP_CMD_RNTO:
case FTP_CMD_SIZE:
case FTP_CMD_MDTM:
if (ftp_session->CtrlCmd == FTP_CMD_PWD) {
p_cmd_arg = (CPU_CHAR *)""."";
} else if (ftp_session->CtrlCmd == FTP_CMD_CDUP) {
p_cmd_arg = (CPU_CHAR *)"".."";
} else if (ftp_session->CtrlCmd == FTP_CMD_MDTM) {
p_cmd_arg   = FTPs_FindFileName(&ftp_session->CtrlCmdArgs);
p_file_time = FTPs_FindArg(&ftp_session->CtrlCmdArgs);
cmp_val = Str_Len(p_file_time);
if (cmp_val == 14) {
for (i = 0; i < 14; i++) {
dig = ASCII_IsDig(p_file_time[i]);
if (dig == DEF_NO) {
break;
}
}
if (i == 14) {
p_cmd_arg = FTPs_FindFileName(&ftp_session->CtrlCmdArgs);
} else {
p_file_time = """";
}
} else {
p_file_time = """";
}
} else {
p_cmd_arg = FTPs_FindFileName(&ftp_session->CtrlCmdArgs);
}
if (*p_cmd_arg != (CPU_CHAR)0) {
FTPs_ToFTPStylePath(p_cmd_arg);
}
if (*p_cmd_arg == '-') {
p_cmd_arg = (CPU_CHAR *)""."";
}
path_name_len = NetFS_CfgPathGetLenMax();
rtn_val = FTPs_BuildPath(FTPs_FullAbsPathPtr,   path_name_len,
FTPs_FullRelPathPtr,   path_name_len,
FTPs_ParentAbsPathPtr, path_name_len,
FTPs_CurEntryPtr,      path_name_len,
ftp_session->BasePath,
ftp_session->RelPath,
p_cmd_arg);
FTPs_ToFSStylePath(FTPs_FullAbsPathPtr);
FTPs_ToFSStylePath(FTPs_ParentAbsPathPtr);
if (rtn_val == DEF_OK) {
switch (ftp_session->CtrlCmd) {
case FTP_CMD_PWD:
case FTP_CMD_CWD:
case FTP_CMD_CDUP:
case FTP_CMD_RMD:
case FTP_CMD_NLST:
case FTP_CMD_LIST:
p_dir = NetFS_DirOpen(FTPs_FullAbsPathPtr);
if (p_dir == (void *)0) {
rtn_val = DEF_FAIL;
} else {
rtn_val = DEF_OK;
}
NetFS_DirClose(p_dir);
break;
case FTP_CMD_DELE:
p_dir = NetFS_DirOpen(FTPs_ParentAbsPathPtr);
if (p_dir == (void *)0) {
rtn_val = DEF_FAIL;
}
NetFS_DirClose(p_dir);
break;
case FTP_CMD_MKD:
case FTP_CMD_RETR:
case FTP_CMD_STOR:
case FTP_CMD_APPE:
case FTP_CMD_RNFR:
case FTP_CMD_RNTO:
case FTP_CMD_SIZE:
case FTP_CMD_MDTM:
p_file = NetFS_FileOpen(FTPs_FullAbsPathPtr,
NET_FS_FILE_MODE_OPEN,
NET_FS_FILE_ACCESS_RD);
if (p_file != (void *)0) {
switch (ftp_session->CtrlCmd) {
case FTP_CMD_MKD:
case FTP_CMD_APPE:
case FTP_CMD_RNTO:
rtn_val = DEF_FAIL;
break;
case FTP_CMD_SIZE:
NetFS_FileSizeGet(p_file, &dirent.Size);
break;
case FTP_CMD_MDTM:
NetFS_FileDateTimeCreateGet(p_file, &dirent.DateTimeCreate);
break;
default:
rtn_val = DEF_OK;
break;
}
NetFS_FileClose(p_file);
} else {
switch (ftp_session->CtrlCmd) {
case FTP_CMD_MKD:
case FTP_CMD_STOR:
case FTP_CMD_APPE:
case FTP_CMD_RNTO:
rtn_val = DEF_OK;
break;
default:
rtn_val = DEF_FAIL;
break;
}
}
break;
default:
break;
}
if (rtn_val == DEF_OK) {
switch (ftp_session->CtrlCmd) {
case FTP_CMD_PWD:
Str_FmtPrint((char *)FTPs_NetBufCtrlCmdPtr,
FTPs_NET_BUF_LEN,
(char *)""257 \""%s\"" is current directory."",
FTPs_FullRelPathPtr);
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PATHNAME, FTPs_NetBufCtrlCmdPtr);
break;
case FTP_CMD_CWD:
case FTP_CMD_CDUP:
Str_Copy_N(ftp_session->RelPath,  FTPs_FullRelPathPtr, FTPs_CFG_FS_PATH_LEN_MAX);
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_ACTIONCOMPLETE, (CPU_CHAR *)0);
break;
case FTP_CMD_NLST:
case FTP_CMD_LIST:
case FTP_CMD_RETR:
case FTP_CMD_STOR:
case FTP_CMD_APPE:
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_OKAYOPENING, (CPU_CHAR *)0);
ftp_session->DtpCmd = ftp_session->CtrlCmd;
Str_Copy_N(ftp_session->CurEntry, FTPs_FullAbsPathPtr, FTPs_CFG_FS_PATH_LEN_MAX);
FTPs_DtpTask((void *)ftp_session);
ftp_session->DtpOffset = 0;
ftp_session->CtrlState = FTPs_STATE_LOGIN;
break;
case FTP_CMD_MKD:
rtn_val = NetFS_EntryCreate(FTPs_FullAbsPathPtr, DEF_YES);
if (rtn_val == DEF_OK) {
Str_FmtPrint((char *)FTPs_NetBufCtrlCmdPtr,
FTPs_NET_BUF_LEN,
(char *)FTPs_Reply[FTP_REPLY_PATHNAME].ReplyStr,
FTPs_FullRelPathPtr);
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PATHNAME, FTPs_NetBufCtrlCmdPtr);
} else {
Str_FmtPrint((char *)FTPs_NetBufCtrlCmdPtr,
FTPs_NET_BUF_LEN,
(char *)FTPs_Reply[FTP_REPLY_NOTFOUND].ReplyStr,
FTPs_FullRelPathPtr);
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_NOTFOUND, FTPs_NetBufCtrlCmdPtr);
}
break;
case FTP_CMD_RMD:
rtn_val = NetFS_EntryDel(FTPs_FullAbsPathPtr, DEF_NO);
if (rtn_val == DEF_OK) {
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_ACTIONCOMPLETE, (CPU_CHAR *)0);
} else {
Str_FmtPrint((char *)FTPs_NetBufCtrlCmdPtr,
FTPs_NET_BUF_LEN,
(char *)FTPs_Reply[FTP_REPLY_NOTFOUND].ReplyStr,
FTPs_FullRelPathPtr);
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_NOTFOUND, FTPs_NetBufCtrlCmdPtr);
}
break;
case FTP_CMD_DELE:
rtn_val = NetFS_EntryDel(FTPs_FullAbsPathPtr, DEF_YES);
if (rtn_val == DEF_OK) {
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_ACTIONCOMPLETE, (CPU_CHAR *)0);
} else {
Str_FmtPrint((char *)FTPs_NetBufCtrlCmdPtr,
FTPs_NET_BUF_LEN,
(char *)FTPs_Reply[FTP_REPLY_NOTFOUND].ReplyStr,
FTPs_FullRelPathPtr);
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_NOTFOUND, FTPs_NetBufCtrlCmdPtr);
}
break;
case FTP_CMD_RNFR:
Str_Copy_N(FTPs_RenAbsPathPtr, FTPs_FullAbsPathPtr, FTPs_CFG_FS_PATH_LEN_MAX);
Str_Copy_N(FTPs_RenRelPathPtr, FTPs_FullRelPathPtr, FTPs_CFG_FS_PATH_LEN_MAX);
ftp_session->CtrlState = FTPs_STATE_GOTRNFR;
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_NEEDMOREINFO, (CPU_CHAR *)0);
break;
case FTP_CMD_RNTO:
rtn_val = NetFS_EntryRename(FTPs_RenAbsPathPtr, FTPs_FullAbsPathPtr);
ftp_session->CtrlState = FTPs_STATE_LOGIN;
if (rtn_val == DEF_OK) {
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_ACTIONCOMPLETE, (CPU_CHAR *)0);
} else {
Str_FmtPrint((char *)FTPs_NetBufCtrlCmdPtr,
FTPs_NET_BUF_LEN,
(char *)FTPs_Reply[FTP_REPLY_NOTFOUND].ReplyStr,
FTPs_RenRelPathPtr);
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_NOTFOUND, FTPs_NetBufCtrlCmdPtr);
}
break;
case FTP_CMD_SIZE:
Str_FmtPrint((char       *)FTPs_NetBufCtrlCmdPtr,
FTPs_NET_BUF_LEN,
(char       *)""213 %u"",
(unsigned int)dirent.Size);
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_FILESTATUS, FTPs_NetBufCtrlCmdPtr);
break;
case FTP_CMD_MDTM:
cmp_val = Str_Cmp(p_file_time, """");
if (cmp_val == 0) {
Str_FmtPrint((char *)FTPs_NetBufCtrlCmdPtr,
FTPs_NET_BUF_LEN,
(char *)""213 %04hu%02hu%02hu%02hu%02hu%02hu"",
dirent.DateTimeCreate.Yr,
dirent.DateTimeCreate.Month,
dirent.DateTimeCreate.Day,
dirent.DateTimeCreate.Hr,
dirent.DateTimeCreate.Min,
dirent.DateTimeCreate.Sec);
FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_FILESTATUS, FTPs_NetBufCtrlCmdPtr);
} else {
/* Mo","static  void  FTPs_ProcessCtrlCmd (FTPs_SESSION_STRUCT  *VAR_0)
{
CPU_CHAR       *VAR_1;
CPU_CHAR       *VAR_2;
void           *VAR_3;
void           *VAR_4;
NET_FS_ENTRY    VAR_5;
CPU_INT32U      VAR_6;
CPU_INT08U     *VAR_7;
CPU_INT08U     *VAR_8;
NET_IPv4_ADDR   VAR_9;
NET_PORT_NBR    VAR_10;
CPU_INT16S      VAR_11;
CPU_BOOLEAN     VAR_12;
CPU_BOOLEAN     VAR_13;
CPU_INT32U      VAR_14;
NET_ERR         VAR_15;
CPU_SR_ALLOC();
VAR_4 = (void *)0;
switch (VAR_0->CtrlCmd) {
case VAR_16:
FTPs_SendReply(VAR_0->CtrlSockID, VAR_17, (CPU_CHAR *)0);
break;
case VAR_18:
FTPs_StopPasvMode(VAR_0);
FTPs_SendReply(VAR_0->CtrlSockID, VAR_19, (CPU_CHAR *)0);
break;
case VAR_20:
FTPs_StopPasvMode(VAR_0);
VAR_0->CtrlState = VAR_21;
VAR_0->DtpMode   = VAR_22;
VAR_0->DtpType   = VAR_23;
VAR_0->DtpForm   = VAR_24;
VAR_0->DtpStru   = VAR_25;
VAR_0->DtpCmd    = VAR_16;
FTPs_SendReply(VAR_0->CtrlSockID, VAR_17, (CPU_CHAR *)0);
break;
case VAR_26:
FTPs_SendReply(VAR_0->CtrlSockID, VAR_27, (CPU_CHAR *)0);
break;
case VAR_28:
FTPs_SendReply(VAR_0->CtrlSockID, VAR_29, (CPU_CHAR *)0);
break;
case VAR_30:
FTPs_SendReply(VAR_0->CtrlSockID, VAR_31, (CPU_CHAR *)0);
break;
case VAR_32:
VAR_1 = FTPs_FindArg(&VAR_0->CtrlCmdArgs);
if (*VAR_1 != (CPU_CHAR)0) {
Str_Copy_N(VAR_0->User, VAR_1, sizeof(VAR_0->User));
VAR_0->CtrlState = VAR_33;
FTPs_SendReply(VAR_0->CtrlSockID, VAR_34, (CPU_CHAR *)0);
} else {
FTPs_SendReply(VAR_0->CtrlSockID, VAR_35, (CPU_CHAR *)0);
}
break;
case VAR_36:
VAR_1 = FTPs_FindArg(&VAR_0->CtrlCmdArgs);
if (*VAR_1 != (CPU_CHAR)0) {
Str_Copy_N(VAR_0->Pass, VAR_1, sizeof(VAR_0->Pass));
VAR_13 = FTPs_AuthUser(VAR_0);
if (VAR_13 == VAR_37) {
VAR_0->CtrlState = VAR_38;
FTPs_SendReply(VAR_0->CtrlSockID, VAR_39, (CPU_CHAR *)0);
} else {
VAR_0->CtrlState = VAR_21;
FTPs_SendReply(VAR_0->CtrlSockID, VAR_40, (CPU_CHAR *)0);
}
} else {
FTPs_SendReply(VAR_0->CtrlSockID, VAR_35, (CPU_CHAR *)0);
}
break;
case VAR_41:
VAR_1 = FTPs_FindArg(&VAR_0->CtrlCmdArgs);
switch (*VAR_1) {
case VAR_22:
VAR_0->DtpMode = VAR_22;
FTPs_SendReply(VAR_0->CtrlSockID, VAR_17, (CPU_CHAR *)0);
break;
case VAR_42:
case VAR_43:
FTPs_SendReply(VAR_0->CtrlSockID, VAR_44, (CPU_CHAR *)0);
break;
default:
FTPs_SendReply(VAR_0->CtrlSockID, VAR_35, (CPU_CHAR *)0);
break;
}
break;
case VAR_45:
VAR_1 = FTPs_FindArg(&VAR_0->CtrlCmdArgs);
switch (*VAR_1) {
case VAR_23:
VAR_1 = FTPs_FindArg(&VAR_0->CtrlCmdArgs);
switch (*VAR_1) {
case (CPU_CHAR)0:
case VAR_24:
VAR_0->DtpType = VAR_23;
VAR_0->DtpForm = VAR_24;
FTPs_SendReply(VAR_0->CtrlSockID, VAR_17, (CPU_CHAR *)0);
break;
case VAR_46:
case VAR_47:
FTPs_SendReply(VAR_0->CtrlSockID, VAR_44, (CPU_CHAR *)0);
break;
default:
FTPs_SendReply(VAR_0->CtrlSockID, VAR_35, (CPU_CHAR *)0);
break;
}
break;
case VAR_48:
VAR_0->DtpType = VAR_48;
FTPs_SendReply(VAR_0->CtrlSockID, VAR_17, (CPU_CHAR *)0);
break;
case VAR_49:
case VAR_50:
FTPs_SendReply(VAR_0->CtrlSockID, VAR_44, (CPU_CHAR *)0);
break;
default:
FTPs_SendReply(VAR_0->CtrlSockID, VAR_35, (CPU_CHAR *)0);
break;
}
break;
case VAR_51:
VAR_1 = FTPs_FindArg(&VAR_0->CtrlCmdArgs);
switch (*VAR_1) {
case VAR_25:
VAR_0->DtpStru = VAR_25;
FTPs_SendReply(VAR_0->CtrlSockID, VAR_17, (CPU_CHAR *)0);
break;
case VAR_52:
case VAR_53:
FTPs_SendReply(VAR_0->CtrlSockID, VAR_44, (CPU_CHAR *)0);
break;
default:
FTPs_SendReply(VAR_0->CtrlSockID, VAR_35, (CPU_CHAR *)0);
break;
}
break;
case VAR_54:
CPU_CRITICAL_ENTER();
VAR_9 = VAR_55;
VAR_10 = VAR_56;
CPU_CRITICAL_EXIT();
VAR_0->DtpSockAddr.Addr = NET_UTIL_HOST_TO_NET_32(VAR_57);
VAR_0->DtpSockAddr.Port = NET_UTIL_HOST_TO_NET_16(VAR_10);
FTPs_StartPasvMode(VAR_0, &VAR_15);
if (VAR_0->DtpPasv == VAR_58) {
VAR_9 = NET_UTIL_HOST_TO_NET_32(VAR_9);
VAR_10 = NET_UTIL_HOST_TO_NET_16(VAR_10);
VAR_7 = (CPU_INT08U *)&VAR_9;
VAR_8 = (CPU_INT08U *)&VAR_10;
Str_FmtPrint((char       *)VAR_59,
VAR_60,
(char       *)VAR_61[VAR_62].ReplyStr,
(unsigned int)VAR_7[0],
(unsigned int)VAR_7[1],
(unsigned int)VAR_7[2],
(unsigned int)VAR_7[3],
(unsigned int)VAR_8[0],
(unsigned int)VAR_8[1]);
FTPs_SendReply(VAR_0->CtrlSockID, VAR_62, VAR_59);
} else {
FTPs_SendReply(VAR_0->CtrlSockID, VAR_63, (CPU_CHAR *)0);
}
break;
case VAR_64:
FTPs_StopPasvMode(VAR_0);
if (VAR_0->DtpPasv == VAR_65) {
VAR_7 = (CPU_INT08U *)&VAR_0->DtpSockAddr.Addr;
VAR_8 = (CPU_INT08U *)&VAR_0->DtpSockAddr.Port;
for (VAR_14 = 0; VAR_14 <= 3; VAR_14++) {
VAR_12 = ASCII_IsDig(*VAR_0->CtrlCmdArgs);
while ((VAR_12 == VAR_65) && (VAR_0->CtrlCmdArgs != (CPU_CHAR *)0)) {
VAR_0->CtrlCmdArgs++;
VAR_12 = ASCII_IsDig(*VAR_0->CtrlCmdArgs);
}
VAR_7[VAR_14] = Str_ParseNbr_Int32U(VAR_0->CtrlCmdArgs, &VAR_0->CtrlCmdArgs, 10);
}
for (VAR_14 = 0; VAR_14 <= 1; VAR_14++) {
VAR_12 = ASCII_IsDig(*VAR_0->CtrlCmdArgs);
while ((VAR_12 == VAR_65) && (VAR_0->CtrlCmdArgs != 0)) {
VAR_0->CtrlCmdArgs++;
VAR_12 = ASCII_IsDig(*VAR_0->CtrlCmdArgs);
}
VAR_8[VAR_14] = Str_ParseNbr_Int32U(VAR_0->CtrlCmdArgs, &VAR_0->CtrlCmdArgs, 10);
}
FTPs_SendReply(VAR_0->CtrlSockID, VAR_17, (CPU_CHAR *)0);
} else {
FTPs_SendReply(VAR_0->CtrlSockID, VAR_63, (CPU_CHAR *)0);
}
break;
case VAR_66:
VAR_1 = FTPs_FindArg(&VAR_0->CtrlCmdArgs);
if (*VAR_1 != (CPU_CHAR)0) {
VAR_0->DtpOffset = Str_ParseNbr_Int32U(VAR_1, 0, 10);
VAR_0->CtrlState = VAR_67;
FTPs_SendReply(VAR_0->CtrlSockID, VAR_68, (CPU_CHAR *)0);
}
break;
case VAR_69:
case VAR_70:
case VAR_71:
case VAR_72:
case VAR_73:
case VAR_74:
case VAR_75:
case VAR_76:
case VAR_77:
case VAR_78:
case VAR_79:
case VAR_80:
case VAR_81:
case VAR_82:
case VAR_83:
if (VAR_0->CtrlCmd == VAR_69) {
VAR_1 = (CPU_CHAR *)""."";
} else if (VAR_0->CtrlCmd == VAR_71) {
VAR_1 = (CPU_CHAR *)"".."";
} else if (VAR_0->CtrlCmd == VAR_83) {
VAR_1   = FTPs_FindFileName(&VAR_0->CtrlCmdArgs);
VAR_2 = FTPs_FindArg(&VAR_0->CtrlCmdArgs);
VAR_11 = Str_Len(VAR_2);
if (VAR_11 == 14) {
for (VAR_14 = 0; VAR_14 < 14; VAR_14++) {
VAR_12 = ASCII_IsDig(VAR_2[VAR_14]);
if (VAR_12 == VAR_65) {
break;
}
}
if (VAR_14 == 14) {
VAR_1 = FTPs_FindFileName(&VAR_0->CtrlCmdArgs);
} else {
VAR_2 = """";
}
} else {
VAR_2 = """";
}
} else {
VAR_1 = FTPs_FindFileName(&VAR_0->CtrlCmdArgs);
}
if (*VAR_1 != (CPU_CHAR)0) {
FTPs_ToFTPStylePath(VAR_1);
}
if (*VAR_1 == '-') {
VAR_1 = (CPU_CHAR *)""."";
}
VAR_6 = NetFS_CfgPathGetLenMax();
VAR_13 = FTPs_BuildPath(VAR_84,   VAR_6,
VAR_85,   VAR_6,
VAR_86, VAR_6,
VAR_87,      VAR_6,
VAR_0->BasePath,
VAR_0->RelPath,
VAR_1);
FTPs_ToFSStylePath(VAR_84);
FTPs_ToFSStylePath(VAR_86);
if (VAR_13 == VAR_37) {
switch (VAR_0->CtrlCmd) {
case VAR_69:
case VAR_70:
case VAR_71:
case VAR_73:
case VAR_74:
case VAR_75:
VAR_4 = NetFS_DirOpen(VAR_84);
if (VAR_4 == (void *)0) {
VAR_13 = VAR_88;
} else {
VAR_13 = VAR_37;
}
NetFS_DirClose(VAR_4);
break;
case VAR_79:
VAR_4 = NetFS_DirOpen(VAR_86);
if (VAR_4 == (void *)0) {
VAR_13 = VAR_88;
}
NetFS_DirClose(VAR_4);
break;
case VAR_72:
case VAR_76:
case VAR_77:
case VAR_78:
case VAR_80:
case VAR_81:
case VAR_82:
case VAR_83:
VAR_3 = NetFS_FileOpen(VAR_84,
VAR_89,
VAR_90);
if (VAR_3 != (void *)0) {
switch (VAR_0->CtrlCmd) {
case VAR_72:
case VAR_78:
case VAR_81:
VAR_13 = VAR_88;
break;
case VAR_82:
NetFS_FileSizeGet(VAR_3, &VAR_5.Size);
break;
case VAR_83:
NetFS_FileDateTimeCreateGet(VAR_3, &VAR_5.DateTimeCreate);
break;
default:
VAR_13 = VAR_37;
break;
}
NetFS_FileClose(VAR_3);
} else {
switch (VAR_0->CtrlCmd) {
case VAR_72:
case VAR_77:
case VAR_78:
case VAR_81:
VAR_13 = VAR_37;
break;
default:
VAR_13 = VAR_88;
break;
}
}
break;
default:
break;
}
if (VAR_13 == VAR_37) {
switch (VAR_0->CtrlCmd) {
case VAR_69:
Str_FmtPrint((char *)VAR_59,
VAR_60,
(char *)""257 \""%s\"" is current directory."",
VAR_85);
FTPs_SendReply(VAR_0->CtrlSockID, VAR_91, VAR_59);
break;
case VAR_70:
case VAR_71:
Str_Copy_N(VAR_0->RelPath,  VAR_85, VAR_92);
FTPs_SendReply(VAR_0->CtrlSockID, VAR_93, (CPU_CHAR *)0);
break;
case VAR_74:
case VAR_75:
case VAR_76:
case VAR_77:
case VAR_78:
FTPs_SendReply(VAR_0->CtrlSockID, VAR_94, (CPU_CHAR *)0);
VAR_0->DtpCmd = VAR_0->CtrlCmd;
Str_Copy_N(VAR_0->CurEntry, VAR_84, VAR_92);
FTPs_DtpTask((void *)VAR_0);
VAR_0->DtpOffset = 0;
VAR_0->CtrlState = VAR_38;
break;
case VAR_72:
VAR_13 = NetFS_EntryCreate(VAR_84, VAR_58);
if (VAR_13 == VAR_37) {
Str_FmtPrint((char *)VAR_59,
VAR_60,
(char *)VAR_61[VAR_91].ReplyStr,
VAR_85);
FTPs_SendReply(VAR_0->CtrlSockID, VAR_91, VAR_59);
} else {
Str_FmtPrint((char *)VAR_59,
VAR_60,
(char *)VAR_61[VAR_95].ReplyStr,
VAR_85);
FTPs_SendReply(VAR_0->CtrlSockID, VAR_95, VAR_59);
}
break;
case VAR_73:
VAR_13 = NetFS_EntryDel(VAR_84, VAR_65);
if (VAR_13 == VAR_37) {
FTPs_SendReply(VAR_0->CtrlSockID, VAR_93, (CPU_CHAR *)0);
} else {
Str_FmtPrint((char *)VAR_59,
VAR_60,
(char *)VAR_61[VAR_95].ReplyStr,
VAR_85);
FTPs_SendReply(VAR_0->CtrlSockID, VAR_95, VAR_59);
}
break;
case VAR_79:
VAR_13 = NetFS_EntryDel(VAR_84, VAR_58);
if (VAR_13 == VAR_37) {
FTPs_SendReply(VAR_0->CtrlSockID, VAR_93, (CPU_CHAR *)0);
} else {
Str_FmtPrint((char *)VAR_59,
VAR_60,
(char *)VAR_61[VAR_95].ReplyStr,
VAR_85);
FTPs_SendReply(VAR_0->CtrlSockID, VAR_95, VAR_59);
}
break;
case VAR_80:
Str_Copy_N(VAR_96, VAR_84, VAR_92);
Str_Copy_N(VAR_97, VAR_85, VAR_92);
VAR_0->CtrlState = VAR_98;
FTPs_SendReply(VAR_0->CtrlSockID, VAR_68, (CPU_CHAR *)0);
break;
case VAR_81:
VAR_13 = NetFS_EntryRename(VAR_96, VAR_84);
VAR_0->CtrlState = VAR_38;
if (VAR_13 == VAR_37) {
FTPs_SendReply(VAR_0->CtrlSockID, VAR_93, (CPU_CHAR *)0);
} else {
Str_FmtPrint((char *)VAR_59,
VAR_60,
(char *)VAR_61[VAR_95].ReplyStr,
VAR_97);
FTPs_SendReply(VAR_0->CtrlSockID, VAR_95, VAR_59);
}
break;
case VAR_82:
Str_FmtPrint((char       *)VAR_59,
VAR_60,
(char       *)""213 %u"",
(unsigned int)VAR_5.Size);
FTPs_SendReply(VAR_0->CtrlSockID, VAR_99, VAR_59);
break;
case VAR_83:
VAR_11 = Str_Cmp(VAR_2, """");
if (VAR_11 == 0) {
Str_FmtPrint((char *)VAR_59,
VAR_60,
(char *)""213 %04hu%02hu%02hu%02hu%02hu%02hu"",
VAR_5.DateTimeCreate.Yr,
VAR_5.DateTimeCreate.Month,
VAR_5.DateTimeCreate.Day,
VAR_5.DateTimeCreate.Hr,
VAR_5.DateTimeCreate.Min,
VAR_5.DateTimeCreate.Sec);
FTPs_SendReply(VAR_0->CtrlSockID, VAR_99, VAR_59);
} else {
Str_FmtScan((char *)VAR_2,
""%04hu%02hu%02hu%02hu%02hu%02hu"",
(CPU_INT16U *)&VAR_5.DateTimeCreate.Yr,
(CPU_INT16U *)&VAR_5.DateTimeCreate.Month,
(CPU_INT16U *)&VAR_5.DateTimeCreate.Day,
(CPU_INT16U *)&VAR_5.DateTimeCreate.Hr,
(CPU_INT16U *)&VAR_5.DateTimeCreate.Min,
(CPU_INT16U *)&VAR_5.DateTimeCreate.Sec);
(void)NetFS_EntryTimeSet(VAR_84, &VAR_5.DateTimeCreate);
FTPs_SendReply(VAR_0->CtrlSockID, VAR_93, (CPU_CHAR *)0);
}
break;
default:
break;
}
} else {
Str_FmtPrint((char *)VAR_59,
VAR_60,
(char *)VAR_61[VAR_95].ReplyStr,
VAR_85);
FTPs_SendReply(VAR_0->CtrlSockID, VAR_95, VAR_59);
}
} else {
FTPs_SendReply(VAR_0->CtrlSockID, VAR_100, (CPU_CHAR *)0);
}
break;
case VAR_101:
Str_FmtPrint((char *)VAR_59,
VAR_60,
(char *)VAR_61[VAR_102].ReplyStr,
VAR_0->CtrlCmdArgs);
FTPs_SendReply(VAR_0->CtrlSockID, VAR_102, VAR_59);
break;
case VAR_103:
Str_FmtPrint((char *)VAR_59,
VAR_60,
(char *)VAR_61[VAR_104].ReplyStr,
VAR_0->CtrlCmdArgs);
FTPs_SendReply(VAR_0->CtrlSockID, VAR_104, VAR_59);
break;
default:
FTPs_SendReply(VAR_0->CtrlSockID, VAR_105, (CPU_CHAR *)0);
break;
}
}",weston-embedded/uC-FTPs/2bbf7c6111766f626923ca5acd29ea827ea5128f/ftp-s.c/vul/before/0.json,"static  void  FTPs_ProcessCtrlCmd (FTPs_SESSION_STRUCT  *ftp_session)
{
    CPU_CHAR       *p_cmd_arg;
    CPU_CHAR       *p_file_time;

    void           *p_file;
    void           *p_dir;
    NET_FS_ENTRY    dirent;
    CPU_INT32U      path_name_len;

    CPU_INT08U     *p_addr;
    CPU_INT08U     *p_port;

    NET_IPv4_ADDR   addr;
    NET_PORT_NBR    port;

    CPU_INT16S      cmp_val;
    CPU_BOOLEAN     dig;
    CPU_BOOLEAN     rtn_val;
    CPU_INT32U      i;

    NET_ERR         net_err;

    CPU_SR_ALLOC();


    p_dir = (void *)0;

                                                                /* Execute the command.                                 */
    switch (ftp_session->CtrlCmd) {
                                                                /* NOOP:   No operation (keep-alive).                   */
                                                                /* Syntax: NOOP                                         */
        case FTP_CMD_NOOP:
             FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_OKAY, (CPU_CHAR *)0);
             break;

                                                                /* QUIT:   Terminate the FTP session.                   */
                                                                /* Syntax: QUIT                                         */
        case FTP_CMD_QUIT:
             FTPs_StopPasvMode(ftp_session);
             FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_SERVERCLOSING, (CPU_CHAR *)0);
             break;

                                                                /* REIN:   Reinitialize the FTP session.                */
                                                                /* Syntax: REIN                                         */
        case FTP_CMD_REIN:
             FTPs_StopPasvMode(ftp_session);
             ftp_session->CtrlState = FTPs_STATE_LOGOUT;
             ftp_session->DtpMode   = FTP_MODE_STREAM;
             ftp_session->DtpType   = FTP_TYPE_ASCII;
             ftp_session->DtpForm   = FTP_FORM_NONPRINT;
             ftp_session->DtpStru   = FTP_STRU_FILE;
             ftp_session->DtpCmd    = FTP_CMD_NOOP;
             FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_OKAY, (CPU_CHAR *)0);
             break;

                                                                /* SYST:   Get system name.                             */
                                                                /* Syntax: SYST                                         */
        case FTP_CMD_SYST:
             FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_SYSTEMTYPE, (CPU_CHAR *)0);
             break;

                                                                /* FEAT:   Advertise server features.                   */
                                                                /* Syntax: FEAT                                         */
        case FTP_CMD_FEAT:
             FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_SYSTEMSTATUS, (CPU_CHAR *)0);
             break;

                                                                /* HELP:   Advertise server help.                       */
                                                                /* Syntax: HELP                                         */
        case FTP_CMD_HELP:
             FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_HELPMESSAGE, (CPU_CHAR *)0);
             break;

                                                                /* USER:   Set username.                                */
                                                                /* Syntax: USER <username>                              */
        case FTP_CMD_USER:
             p_cmd_arg = FTPs_FindArg(&ftp_session->CtrlCmdArgs);
             if (*p_cmd_arg != (CPU_CHAR)0) {
                 Str_Copy_N(ftp_session->User, p_cmd_arg, sizeof(ftp_session->User));
                 ftp_session->CtrlState = FTPs_STATE_GOTUSER;
                 FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_NEEDPASSWORD, (CPU_CHAR *)0);
             } else {
                 FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PARMSYNTAXERR, (CPU_CHAR *)0);
             }
             break;

                                                                /* PASS:   Enter password.                              */
                                                                /* Syntax: PASS <password>                              */
        case FTP_CMD_PASS:
             p_cmd_arg = FTPs_FindArg(&ftp_session->CtrlCmdArgs);
             if (*p_cmd_arg != (CPU_CHAR)0) {
                 Str_Copy_N(ftp_session->Pass, p_cmd_arg, sizeof(ftp_session->Pass));
                 rtn_val = FTPs_AuthUser(ftp_session);
                 if (rtn_val == DEF_OK) {
                     ftp_session->CtrlState = FTPs_STATE_LOGIN;
                     FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_LOGGEDIN, (CPU_CHAR *)0);
                 } else {
                     ftp_session->CtrlState = FTPs_STATE_LOGOUT;
                     FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_NOTLOGGEDIN, (CPU_CHAR *)0);
                 }
             } else {
                 FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PARMSYNTAXERR, (CPU_CHAR *)0);
             }
             break;

                                                                /* MODE:   Set transfer mode (stream, block, compress). */
                                                                /* Syntax: MODE <S|B|C>                                 */
                                                                /* NOTE:   Server supports STREAM mode only.            */
        case FTP_CMD_MODE:
             p_cmd_arg = FTPs_FindArg(&ftp_session->CtrlCmdArgs);
             switch (*p_cmd_arg) {
                 case FTP_MODE_STREAM:
                      ftp_session->DtpMode = FTP_MODE_STREAM;
                      FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_OKAY, (CPU_CHAR *)0);
                      break;

                 case FTP_MODE_BLOCK:
                 case FTP_MODE_COMPRESSED:
                      FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PARMNOSUPPORT, (CPU_CHAR *)0);
                      break;

                 default:
                      FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PARMSYNTAXERR, (CPU_CHAR *)0);
                      break;
             }
             break;

                                                                /* TYPE:   Set data representation type.                */
                                                                /* Syntax: TYPE <A|E|I|L> [<N|T|C|bytesize>]            */
                                                                /* NOTE:   Server supports ASCII NON_PRINT or IMAGE.    */
        case FTP_CMD_TYPE:
             p_cmd_arg = FTPs_FindArg(&ftp_session->CtrlCmdArgs);
             switch (*p_cmd_arg) {
                 case FTP_TYPE_ASCII:
                      p_cmd_arg = FTPs_FindArg(&ftp_session->CtrlCmdArgs);
                      switch (*p_cmd_arg) {
                          case (CPU_CHAR)0:
                          case FTP_FORM_NONPRINT:
                               ftp_session->DtpType = FTP_TYPE_ASCII;
                               ftp_session->DtpForm = FTP_FORM_NONPRINT;
                               FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_OKAY, (CPU_CHAR *)0);
                               break;

                          case FTP_FORM_TELNET:
                          case FTP_FORM_CARGCTRL:
                               FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PARMNOSUPPORT, (CPU_CHAR *)0);
                               break;

                          default:
                               FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PARMSYNTAXERR, (CPU_CHAR *)0);
                               break;
                      }
                      break;

                 case FTP_TYPE_IMAGE:
                      ftp_session->DtpType = FTP_TYPE_IMAGE;
                      FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_OKAY, (CPU_CHAR *)0);
                      break;

                 case FTP_TYPE_LOCAL:
                 case FTP_TYPE_EBCDIC:
                      FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PARMNOSUPPORT, (CPU_CHAR *)0);
                      break;

                 default:
                      FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PARMSYNTAXERR, (CPU_CHAR *)0);
                      break;
             }
             break;

                                                                /* STRU:   Set file structure (file, record, page).     */
                                                                /* Syntax: STRU <F|R|P>                                 */
                                                                /* NOTE:   Server supports FILE structure only.         */
        case FTP_CMD_STRU:
             p_cmd_arg = FTPs_FindArg(&ftp_session->CtrlCmdArgs);
             switch (*p_cmd_arg) {
                 case FTP_STRU_FILE:
                      ftp_session->DtpStru = FTP_STRU_FILE;
                      FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_OKAY, (CPU_CHAR *)0);
                      break;

                 case FTP_STRU_RECORD:
                 case FTP_STRU_PAGE:
                      FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PARMNOSUPPORT, (CPU_CHAR *)0);
                      break;

                 default:
                      FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PARMSYNTAXERR, (CPU_CHAR *)0);
                      break;
             }
             break;

                                                                /* PASV:   Enter passive mode.                          */
                                                                /* Syntax: PASV                                         */
        case FTP_CMD_PASV:
             CPU_CRITICAL_ENTER();
             addr = FTPs_PublicAddr;
             port = FTPs_PublicPort;
             CPU_CRITICAL_EXIT();

             ftp_session->DtpSockAddr.Addr = NET_UTIL_HOST_TO_NET_32(NET_IPv4_ADDR_ANY);
             ftp_session->DtpSockAddr.Port = NET_UTIL_HOST_TO_NET_16(port);
             FTPs_StartPasvMode(ftp_session, &net_err);
             if (ftp_session->DtpPasv == DEF_YES) {
                 addr = NET_UTIL_HOST_TO_NET_32(addr);
                 port = NET_UTIL_HOST_TO_NET_16(port);

                 p_addr = (CPU_INT08U *)&addr;
                 p_port = (CPU_INT08U *)&port;
                 Str_FmtPrint((char       *)FTPs_NetBufCtrlCmdPtr,
                                            FTPs_NET_BUF_LEN,
                              (char       *)FTPs_Reply[FTP_REPLY_ENTERPASVMODE].ReplyStr,
                              (unsigned int)p_addr[0],
                              (unsigned int)p_addr[1],
                              (unsigned int)p_addr[2],
                              (unsigned int)p_addr[3],
                              (unsigned int)p_port[0],
                              (unsigned int)p_port[1]);

                 FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_ENTERPASVMODE, FTPs_NetBufCtrlCmdPtr);
             } else {
                 FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_CANTOPENDATA, (CPU_CHAR *)0);
             }
             break;

                                                                /* PORT:   Set data port configuration.                 */
                                                                /* Syntax: PORT <ip0, ip1, ip2, ip3, port0, port1>      */
        case FTP_CMD_PORT:
             FTPs_StopPasvMode(ftp_session);
             if (ftp_session->DtpPasv == DEF_NO) {
                 p_addr = (CPU_INT08U *)&ftp_session->DtpSockAddr.Addr;
                 p_port = (CPU_INT08U *)&ftp_session->DtpSockAddr.Port;

                 for (i = 0; i <= 3; i++) {
                     dig = ASCII_IsDig(*ftp_session->CtrlCmdArgs);
                     while ((dig == DEF_NO) && (ftp_session->CtrlCmdArgs != (CPU_CHAR *)0) && (*ftp_session->CtrlCmdArgs != 0)) {
                         ftp_session->CtrlCmdArgs++;
                         dig = ASCII_IsDig(*ftp_session->CtrlCmdArgs);
                     }
                     p_addr[i] = Str_ParseNbr_Int32U(ftp_session->CtrlCmdArgs, &ftp_session->CtrlCmdArgs, 10);
                 }
                 for (i = 0; i <= 1; i++) {
                     dig = ASCII_IsDig(*ftp_session->CtrlCmdArgs);
                     while ((dig == DEF_NO) && (ftp_session->CtrlCmdArgs != 0) && (*ftp_session->CtrlCmdArgs != 0)) {
                         ftp_session->CtrlCmdArgs++;
                         dig = ASCII_IsDig(*ftp_session->CtrlCmdArgs);
                     }
                     p_port[i] = Str_ParseNbr_Int32U(ftp_session->CtrlCmdArgs, &ftp_session->CtrlCmdArgs, 10);
                 }

                 FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_OKAY, (CPU_CHAR *)0);
             } else {
                 FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_CANTOPENDATA, (CPU_CHAR *)0);
             }
             break;

                                                                /* REST:   Next transfer will start at offset <offset>. */
                                                                /* Syntax: REST <offset>                                */
        case FTP_CMD_REST:
             p_cmd_arg = FTPs_FindArg(&ftp_session->CtrlCmdArgs);
             if (*p_cmd_arg != (CPU_CHAR)0) {
                 ftp_session->DtpOffset = Str_ParseNbr_Int32U(p_cmd_arg, 0, 10);
                 ftp_session->CtrlState = FTPs_STATE_GOTREST;
                 FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_NEEDMOREINFO, (CPU_CHAR *)0);
             }
             break;

                                                                /* PWD:    Get present working directory.               */
                                                                /* Syntax: PWD                                          */

                                                                /* CWD:    Change working directory.                    */
                                                                /* Syntax: CWD <dirname>                                */

                                                                /* CDUP:   Change to parent directory.                  */
                                                                /* Syntax: CDUP <filename>                              */

                                                                /* MKD:    Create directory.                            */
                                                                /* Syntax: MKD <dirname>                                */

                                                                /* RMD:    Delete directory.                            */
                                                                /* Syntax: RMD <dirname>                                */

                                                                /* NLST:   Get brief directory entries list.            */
                                                                /* Syntax: NLST [<pathname>]                            */

                                                                /* LIST:   Get detailed directory entries list.         */
                                                                /* Syntax: LIST [<pathname>]                            */

                                                                /* RETR:   Retrieve file.                               */
                                                                /* Syntax: RETR <filename>                              */

                                                                /* STOR:   Store file.                                  */
                                                                /* Syntax: STOR <filename>                              */

                                                                /* APPE:   Append file.                                 */
                                                                /* Syntax: APPE <filename>                              */

                                                                /* DELE:   Delete file.                                 */
                                                                /* Syntax: DELE <filename>                              */

                                                                /* RNFR:   Rename file from name.                       */
                                                                /* Syntax: RNFR <filename>                              */

                                                                /* RNTO:   Rename file to name.                         */
                                                                /* Syntax: RNTO <filename>                              */

                                                                /* SIZE:   Get file size.                               */
                                                                /* Syntax: SIZE <filename>                              */

                                                                /* MDTM:   Get file modification date/time.             */
                                                                /* Syntax: MDTM <filename>                              */
        case FTP_CMD_PWD:
        case FTP_CMD_CWD:
        case FTP_CMD_CDUP:
        case FTP_CMD_MKD:
        case FTP_CMD_RMD:
        case FTP_CMD_NLST:
        case FTP_CMD_LIST:
        case FTP_CMD_RETR:
        case FTP_CMD_STOR:
        case FTP_CMD_APPE:
        case FTP_CMD_DELE:
        case FTP_CMD_RNFR:
        case FTP_CMD_RNTO:
        case FTP_CMD_SIZE:
        case FTP_CMD_MDTM:
                                                                /* Parameter handling.                                  */
             if (ftp_session->CtrlCmd == FTP_CMD_PWD) {
                 p_cmd_arg = (CPU_CHAR *)""."";
             } else if (ftp_session->CtrlCmd == FTP_CMD_CDUP) {
                 p_cmd_arg = (CPU_CHAR *)"".."";
             } else if (ftp_session->CtrlCmd == FTP_CMD_MDTM) {
                                                                /* MDTM command may have one or two arguments           */
                                                                /* 1. If the first argument are a file name, return     */
                                                                /*    file date and time.                               */
                                                                /* 2. If the first argument are a date and time and the */
                                                                /*    second argument are a file name, modify the file  */
                                                                /*    date and time.                                    */
                 p_cmd_arg   = FTPs_FindFileName(&ftp_session->CtrlCmdArgs);
                 p_file_time = FTPs_FindArg(&ftp_session->CtrlCmdArgs);

                                                                /* Check if first argument is a string of 14 digits.    */
                                                                /* The date and time string has exactly 14 digits.      */
                 cmp_val = Str_Len(p_file_time);
                 if (cmp_val == 14) {
                    for (i = 0; i < 14; i++) {
                        dig = ASCII_IsDig(p_file_time[i]);
                        if (dig == DEF_NO) {
                            break;
                        }
                    }
                    if (i == 14) {
                                                                /* Yes: The file name starts after.                     */
                                                                /* No:  The file name IS the first argument.            */
                        p_cmd_arg = FTPs_FindFileName(&ftp_session->CtrlCmdArgs);
                    } else {
                        p_file_time = """";
                    }
                 } else {
                    p_file_time = """";
                 }
             } else {
                 p_cmd_arg = FTPs_FindFileName(&ftp_session->CtrlCmdArgs);
             }

             if (*p_cmd_arg != (CPU_CHAR)0) {
                 FTPs_ToFTPStylePath(p_cmd_arg);
             }

                                                                /* Skip ""-xxxx"" argument.                               */
             if (*p_cmd_arg == '-') {
                 p_cmd_arg = (CPU_CHAR *)""."";
             }

             path_name_len = NetFS_CfgPathGetLenMax();

             rtn_val = FTPs_BuildPath(FTPs_FullAbsPathPtr,   path_name_len,
                                      FTPs_FullRelPathPtr,   path_name_len,
                                      FTPs_ParentAbsPathPtr, path_name_len,
                                      FTPs_CurEntryPtr,      path_name_len,
                                      ftp_session->BasePath,
                                      ftp_session->RelPath,
                                      p_cmd_arg);

             FTPs_ToFSStylePath(FTPs_FullAbsPathPtr);
             FTPs_ToFSStylePath(FTPs_ParentAbsPathPtr);

                                                                /* Verify presence of CurEntry/directory/parent         */
                                                                /* directory.                                           */
             if (rtn_val == DEF_OK) {
                 switch (ftp_session->CtrlCmd) {
                     case FTP_CMD_PWD:
                     case FTP_CMD_CWD:
                     case FTP_CMD_CDUP:
                     case FTP_CMD_RMD:
                     case FTP_CMD_NLST:
                     case FTP_CMD_LIST:
                          p_dir = NetFS_DirOpen(FTPs_FullAbsPathPtr);
                          if (p_dir == (void *)0) {
                              rtn_val = DEF_FAIL;
                          } else {
                              rtn_val = DEF_OK;
                          }
                          NetFS_DirClose(p_dir);
                          break;


                     case FTP_CMD_DELE:
                          p_dir = NetFS_DirOpen(FTPs_ParentAbsPathPtr);
                          if (p_dir == (void *)0) {
                              rtn_val = DEF_FAIL;
                          }
                          NetFS_DirClose(p_dir);
                          break;


                     case FTP_CMD_MKD:
                     case FTP_CMD_RETR:
                     case FTP_CMD_STOR:
                     case FTP_CMD_APPE:
                     case FTP_CMD_RNFR:
                     case FTP_CMD_RNTO:
                     case FTP_CMD_SIZE:
                     case FTP_CMD_MDTM:
                          p_file = NetFS_FileOpen(FTPs_FullAbsPathPtr,
                                                  NET_FS_FILE_MODE_OPEN,
                                                  NET_FS_FILE_ACCESS_RD);
                          if (p_file != (void *)0) {
                              switch (ftp_session->CtrlCmd) {
                                  case FTP_CMD_MKD:
                                  case FTP_CMD_APPE:
                                  case FTP_CMD_RNTO:
                                       rtn_val = DEF_FAIL;
                                       break;

                                  case FTP_CMD_SIZE:
                                       NetFS_FileSizeGet(p_file, &dirent.Size);
                                       break;

                                  case FTP_CMD_MDTM:
                                       NetFS_FileDateTimeCreateGet(p_file, &dirent.DateTimeCreate);
                                       break;

                                  default:
                                       rtn_val = DEF_OK;
                                       break;
                              }
                              NetFS_FileClose(p_file);

                          } else {
                              switch (ftp_session->CtrlCmd) {
                                  case FTP_CMD_MKD:
                                  case FTP_CMD_STOR:
                                  case FTP_CMD_APPE:
                                  case FTP_CMD_RNTO:
                                       rtn_val = DEF_OK;
                                       break;

                                  default:
                                       rtn_val = DEF_FAIL;
                                       break;
                              }
                          }
                          break;


                     default:
                          break;
                 }

                                                                /* Do action.                                           */
                 if (rtn_val == DEF_OK) {
                     switch (ftp_session->CtrlCmd) {
                         case FTP_CMD_PWD:
                              Str_FmtPrint((char *)FTPs_NetBufCtrlCmdPtr,
                                                   FTPs_NET_BUF_LEN,
                                           (char *)""257 \""%s\"" is current directory."",
                                                   FTPs_FullRelPathPtr);
                              FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PATHNAME, FTPs_NetBufCtrlCmdPtr);
                              break;

                         case FTP_CMD_CWD:
                         case FTP_CMD_CDUP:
                              Str_Copy_N(ftp_session->RelPath,  FTPs_FullRelPathPtr, FTPs_CFG_FS_PATH_LEN_MAX);
                              FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_ACTIONCOMPLETE, (CPU_CHAR *)0);
                              break;

                         case FTP_CMD_NLST:
                         case FTP_CMD_LIST:
                         case FTP_CMD_RETR:
                         case FTP_CMD_STOR:
                         case FTP_CMD_APPE:
                              FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_OKAYOPENING, (CPU_CHAR *)0);
                              ftp_session->DtpCmd = ftp_session->CtrlCmd;
                              Str_Copy_N(ftp_session->CurEntry, FTPs_FullAbsPathPtr, FTPs_CFG_FS_PATH_LEN_MAX);
                              FTPs_DtpTask((void *)ftp_session);
                              ftp_session->DtpOffset = 0;
                              ftp_session->CtrlState = FTPs_STATE_LOGIN;
                              break;

                         case FTP_CMD_MKD:
                              rtn_val = NetFS_EntryCreate(FTPs_FullAbsPathPtr, DEF_YES);
                              if (rtn_val == DEF_OK) {
                                  Str_FmtPrint((char *)FTPs_NetBufCtrlCmdPtr,
                                                       FTPs_NET_BUF_LEN,
                                               (char *)FTPs_Reply[FTP_REPLY_PATHNAME].ReplyStr,
                                                       FTPs_FullRelPathPtr);
                                  FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_PATHNAME, FTPs_NetBufCtrlCmdPtr);
                              } else {
                                  Str_FmtPrint((char *)FTPs_NetBufCtrlCmdPtr,
                                                       FTPs_NET_BUF_LEN,
                                               (char *)FTPs_Reply[FTP_REPLY_NOTFOUND].ReplyStr,
                                                       FTPs_FullRelPathPtr);
                                  FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_NOTFOUND, FTPs_NetBufCtrlCmdPtr);
                              }
                              break;

                         case FTP_CMD_RMD:
                              rtn_val = NetFS_EntryDel(FTPs_FullAbsPathPtr, DEF_NO);
                              if (rtn_val == DEF_OK) {
                                  FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_ACTIONCOMPLETE, (CPU_CHAR *)0);
                              } else {
                                  Str_FmtPrint((char *)FTPs_NetBufCtrlCmdPtr,
                                                       FTPs_NET_BUF_LEN,
                                               (char *)FTPs_Reply[FTP_REPLY_NOTFOUND].ReplyStr,
                                                       FTPs_FullRelPathPtr);
                                  FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_NOTFOUND, FTPs_NetBufCtrlCmdPtr);
                              }
                              break;

                         case FTP_CMD_DELE:
                              rtn_val = NetFS_EntryDel(FTPs_FullAbsPathPtr, DEF_YES);
                              if (rtn_val == DEF_OK) {
                                  FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_ACTIONCOMPLETE, (CPU_CHAR *)0);
                              } else {
                                  Str_FmtPrint((char *)FTPs_NetBufCtrlCmdPtr,
                                                       FTPs_NET_BUF_LEN,
                                               (char *)FTPs_Reply[FTP_REPLY_NOTFOUND].ReplyStr,
                                                       FTPs_FullRelPathPtr);
                                  FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_NOTFOUND, FTPs_NetBufCtrlCmdPtr);
                              }
                              break;

                         case FTP_CMD_RNFR:
                              Str_Copy_N(FTPs_RenAbsPathPtr, FTPs_FullAbsPathPtr, FTPs_CFG_FS_PATH_LEN_MAX);
                              Str_Copy_N(FTPs_RenRelPathPtr, FTPs_FullRelPathPtr, FTPs_CFG_FS_PATH_LEN_MAX);
                              ftp_session->CtrlState = FTPs_STATE_GOTRNFR;
                              FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_NEEDMOREINFO, (CPU_CHAR *)0);
                              break;

                         case FTP_CMD_RNTO:
                              rtn_val = NetFS_EntryRename(FTPs_RenAbsPathPtr, FTPs_FullAbsPathPtr);
                              ftp_session->CtrlState = FTPs_STATE_LOGIN;
                              if (rtn_val == DEF_OK) {
                                  FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_ACTIONCOMPLETE, (CPU_CHAR *)0);
                              } else {
                                  Str_FmtPrint((char *)FTPs_NetBufCtrlCmdPtr,
                                                       FTPs_NET_BUF_LEN,
                                               (char *)FTPs_Reply[FTP_REPLY_NOTFOUND].ReplyStr,
                                                       FTPs_RenRelPathPtr);
                                  FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_NOTFOUND, FTPs_NetBufCtrlCmdPtr);
                              }
                              break;

                         case FTP_CMD_SIZE:
                              Str_FmtPrint((char       *)FTPs_NetBufCtrlCmdPtr,
                                                         FTPs_NET_BUF_LEN,
                                           (char       *)""213 %u"",
                                           (unsigned int)dirent.Size);
                              FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_FILESTATUS, FTPs_NetBufCtrlCmdPtr);
                              break;

                         case FTP_CMD_MDTM:
                              cmp_val = Str_Cmp(p_file_time, """");
                              if (cmp_val == 0) {
                                                                /* Return file date and time.                           */
                                  Str_FmtPrint((char *)FTPs_NetBufCtrlCmdPtr,
                                                       FTPs_NET_BUF_LEN,
                                               (char *)""213 %04hu%02hu%02hu%02hu%02hu%02hu"",
                                                       dirent.DateTimeCreate.Yr,
                                                       dirent.DateTimeCreate.Month,
                                                       dirent.DateTimeCreate.Day,
                                                       dirent.DateTimeCreate.Hr,
                                                       dirent.DateTimeCreate.Min,
                                                       dirent.DateTimeCreate.Sec);
                                  FTPs_SendReply(ftp_session->CtrlSockID, FTP_REPLY_FILESTATUS, FTPs_NetBufCtrlCmdPtr);
                              } else","static  void  FTPs_ProcessCtrlCmd (FTPs_SESSION_STRUCT  *VAR_0)
{
    CPU_CHAR       *VAR_1;
    CPU_CHAR       *VAR_2;

    void           *VAR_3;
    void           *VAR_4;
    NET_FS_ENTRY    VAR_5;
    CPU_INT32U      VAR_6;

    CPU_INT08U     *VAR_7;
    CPU_INT08U     *VAR_8;

    NET_IPv4_ADDR   VAR_9;
    NET_PORT_NBR    VAR_10;

    CPU_INT16S      VAR_11;
    CPU_BOOLEAN     VAR_12;
    CPU_BOOLEAN     VAR_13;
    CPU_INT32U      VAR_14;

    NET_ERR         VAR_15;

    CPU_SR_ALLOC();


    VAR_4 = (void *)0;

                                                                /* COMMENT_0 */
    switch (VAR_0->CtrlCmd) {
                                                                /* COMMENT_1 */
                                                                /* COMMENT_2 */
        case VAR_16:
             FTPs_SendReply(VAR_0->CtrlSockID, VAR_17, (CPU_CHAR *)0);
             break;

                                                                /* COMMENT_3 */
                                                                /* COMMENT_4 */
        case VAR_18:
             FTPs_StopPasvMode(VAR_0);
             FTPs_SendReply(VAR_0->CtrlSockID, VAR_19, (CPU_CHAR *)0);
             break;

                                                                /* COMMENT_5 */
                                                                /* COMMENT_6 */
        case VAR_20:
             FTPs_StopPasvMode(VAR_0);
             VAR_0->CtrlState = VAR_21;
             VAR_0->DtpMode   = VAR_22;
             VAR_0->DtpType   = VAR_23;
             VAR_0->DtpForm   = VAR_24;
             VAR_0->DtpStru   = VAR_25;
             VAR_0->DtpCmd    = VAR_16;
             FTPs_SendReply(VAR_0->CtrlSockID, VAR_17, (CPU_CHAR *)0);
             break;

                                                                /* COMMENT_7 */
                                                                /* COMMENT_8 */
        case VAR_26:
             FTPs_SendReply(VAR_0->CtrlSockID, VAR_27, (CPU_CHAR *)0);
             break;

                                                                /* COMMENT_9 */
                                                                /* COMMENT_10 */
        case VAR_28:
             FTPs_SendReply(VAR_0->CtrlSockID, VAR_29, (CPU_CHAR *)0);
             break;

                                                                /* COMMENT_11 */
                                                                /* COMMENT_12 */
        case VAR_30:
             FTPs_SendReply(VAR_0->CtrlSockID, VAR_31, (CPU_CHAR *)0);
             break;

                                                                /* COMMENT_13 */
                                                                /* COMMENT_14 */
        case VAR_32:
             VAR_1 = FTPs_FindArg(&VAR_0->CtrlCmdArgs);
             if (*VAR_1 != (CPU_CHAR)0) {
                 Str_Copy_N(VAR_0->User, VAR_1, sizeof(VAR_0->User));
                 VAR_0->CtrlState = VAR_33;
                 FTPs_SendReply(VAR_0->CtrlSockID, VAR_34, (CPU_CHAR *)0);
             } else {
                 FTPs_SendReply(VAR_0->CtrlSockID, VAR_35, (CPU_CHAR *)0);
             }
             break;

                                                                /* COMMENT_15 */
                                                                /* COMMENT_16 */
        case VAR_36:
             VAR_1 = FTPs_FindArg(&VAR_0->CtrlCmdArgs);
             if (*VAR_1 != (CPU_CHAR)0) {
                 Str_Copy_N(VAR_0->Pass, VAR_1, sizeof(VAR_0->Pass));
                 VAR_13 = FTPs_AuthUser(VAR_0);
                 if (VAR_13 == VAR_37) {
                     VAR_0->CtrlState = VAR_38;
                     FTPs_SendReply(VAR_0->CtrlSockID, VAR_39, (CPU_CHAR *)0);
                 } else {
                     VAR_0->CtrlState = VAR_21;
                     FTPs_SendReply(VAR_0->CtrlSockID, VAR_40, (CPU_CHAR *)0);
                 }
             } else {
                 FTPs_SendReply(VAR_0->CtrlSockID, VAR_35, (CPU_CHAR *)0);
             }
             break;

                                                                /* COMMENT_17 */
                                                                /* COMMENT_18 */
                                                                /* COMMENT_19 */
        case VAR_41:
             VAR_1 = FTPs_FindArg(&VAR_0->CtrlCmdArgs);
             switch (*VAR_1) {
                 case VAR_22:
                      VAR_0->DtpMode = VAR_22;
                      FTPs_SendReply(VAR_0->CtrlSockID, VAR_17, (CPU_CHAR *)0);
                      break;

                 case VAR_42:
                 case VAR_43:
                      FTPs_SendReply(VAR_0->CtrlSockID, VAR_44, (CPU_CHAR *)0);
                      break;

                 default:
                      FTPs_SendReply(VAR_0->CtrlSockID, VAR_35, (CPU_CHAR *)0);
                      break;
             }
             break;

                                                                /* COMMENT_20 */
                                                                /* COMMENT_21 */
                                                                /* COMMENT_22 */
        case VAR_45:
             VAR_1 = FTPs_FindArg(&VAR_0->CtrlCmdArgs);
             switch (*VAR_1) {
                 case VAR_23:
                      VAR_1 = FTPs_FindArg(&VAR_0->CtrlCmdArgs);
                      switch (*VAR_1) {
                          case (CPU_CHAR)0:
                          case VAR_24:
                               VAR_0->DtpType = VAR_23;
                               VAR_0->DtpForm = VAR_24;
                               FTPs_SendReply(VAR_0->CtrlSockID, VAR_17, (CPU_CHAR *)0);
                               break;

                          case VAR_46:
                          case VAR_47:
                               FTPs_SendReply(VAR_0->CtrlSockID, VAR_44, (CPU_CHAR *)0);
                               break;

                          default:
                               FTPs_SendReply(VAR_0->CtrlSockID, VAR_35, (CPU_CHAR *)0);
                               break;
                      }
                      break;

                 case VAR_48:
                      VAR_0->DtpType = VAR_48;
                      FTPs_SendReply(VAR_0->CtrlSockID, VAR_17, (CPU_CHAR *)0);
                      break;

                 case VAR_49:
                 case VAR_50:
                      FTPs_SendReply(VAR_0->CtrlSockID, VAR_44, (CPU_CHAR *)0);
                      break;

                 default:
                      FTPs_SendReply(VAR_0->CtrlSockID, VAR_35, (CPU_CHAR *)0);
                      break;
             }
             break;

                                                                /* COMMENT_23 */
                                                                /* COMMENT_24 */
                                                                /* COMMENT_25 */
        case VAR_51:
             VAR_1 = FTPs_FindArg(&VAR_0->CtrlCmdArgs);
             switch (*VAR_1) {
                 case VAR_25:
                      VAR_0->DtpStru = VAR_25;
                      FTPs_SendReply(VAR_0->CtrlSockID, VAR_17, (CPU_CHAR *)0);
                      break;

                 case VAR_52:
                 case VAR_53:
                      FTPs_SendReply(VAR_0->CtrlSockID, VAR_44, (CPU_CHAR *)0);
                      break;

                 default:
                      FTPs_SendReply(VAR_0->CtrlSockID, VAR_35, (CPU_CHAR *)0);
                      break;
             }
             break;

                                                                /* COMMENT_26 */
                                                                /* COMMENT_27 */
        case VAR_54:
             CPU_CRITICAL_ENTER();
             VAR_9 = VAR_55;
             VAR_10 = VAR_56;
             CPU_CRITICAL_EXIT();

             VAR_0->DtpSockAddr.Addr = NET_UTIL_HOST_TO_NET_32(VAR_57);
             VAR_0->DtpSockAddr.Port = NET_UTIL_HOST_TO_NET_16(VAR_10);
             FTPs_StartPasvMode(VAR_0, &VAR_15);
             if (VAR_0->DtpPasv == VAR_58) {
                 VAR_9 = NET_UTIL_HOST_TO_NET_32(VAR_9);
                 VAR_10 = NET_UTIL_HOST_TO_NET_16(VAR_10);

                 VAR_7 = (CPU_INT08U *)&VAR_9;
                 VAR_8 = (CPU_INT08U *)&VAR_10;
                 Str_FmtPrint((char       *)VAR_59,
                                            VAR_60,
                              (char       *)VAR_61[VAR_62].ReplyStr,
                              (unsigned int)VAR_7[0],
                              (unsigned int)VAR_7[1],
                              (unsigned int)VAR_7[2],
                              (unsigned int)VAR_7[3],
                              (unsigned int)VAR_8[0],
                              (unsigned int)VAR_8[1]);

                 FTPs_SendReply(VAR_0->CtrlSockID, VAR_62, VAR_59);
             } else {
                 FTPs_SendReply(VAR_0->CtrlSockID, VAR_63, (CPU_CHAR *)0);
             }
             break;

                                                                /* COMMENT_28 */
                                                                /* COMMENT_29 */
        case VAR_64:
             FTPs_StopPasvMode(VAR_0);
             if (VAR_0->DtpPasv == VAR_65) {
                 VAR_7 = (CPU_INT08U *)&VAR_0->DtpSockAddr.Addr;
                 VAR_8 = (CPU_INT08U *)&VAR_0->DtpSockAddr.Port;

                 for (VAR_14 = 0; VAR_14 <= 3; VAR_14++) {
                     VAR_12 = ASCII_IsDig(*VAR_0->CtrlCmdArgs);
                     while ((VAR_12 == VAR_65) && (VAR_0->CtrlCmdArgs != (CPU_CHAR *)0) && (*VAR_0->CtrlCmdArgs != 0)) {
                         VAR_0->CtrlCmdArgs++;
                         VAR_12 = ASCII_IsDig(*VAR_0->CtrlCmdArgs);
                     }
                     VAR_7[VAR_14] = Str_ParseNbr_Int32U(VAR_0->CtrlCmdArgs, &VAR_0->CtrlCmdArgs, 10);
                 }
                 for (VAR_14 = 0; VAR_14 <= 1; VAR_14++) {
                     VAR_12 = ASCII_IsDig(*VAR_0->CtrlCmdArgs);
                     while ((VAR_12 == VAR_65) && (VAR_0->CtrlCmdArgs != 0) && (*VAR_0->CtrlCmdArgs != 0)) {
                         VAR_0->CtrlCmdArgs++;
                         VAR_12 = ASCII_IsDig(*VAR_0->CtrlCmdArgs);
                     }
                     VAR_8[VAR_14] = Str_ParseNbr_Int32U(VAR_0->CtrlCmdArgs, &VAR_0->CtrlCmdArgs, 10);
                 }

                 FTPs_SendReply(VAR_0->CtrlSockID, VAR_17, (CPU_CHAR *)0);
             } else {
                 FTPs_SendReply(VAR_0->CtrlSockID, VAR_63, (CPU_CHAR *)0);
             }
             break;

                                                                /* COMMENT_30 */
                                                                /* COMMENT_31 */
        case VAR_66:
             VAR_1 = FTPs_FindArg(&VAR_0->CtrlCmdArgs);
             if (*VAR_1 != (CPU_CHAR)0) {
                 VAR_0->DtpOffset = Str_ParseNbr_Int32U(VAR_1, 0, 10);
                 VAR_0->CtrlState = VAR_67;
                 FTPs_SendReply(VAR_0->CtrlSockID, VAR_68, (CPU_CHAR *)0);
             }
             break;

                                                                /* COMMENT_32 */
                                                                /* COMMENT_33 */

                                                                /* COMMENT_34 */
                                                                /* COMMENT_35 */

                                                                /* COMMENT_36 */
                                                                /* COMMENT_37 */

                                                                /* COMMENT_38 */
                                                                /* COMMENT_39 */

                                                                /* COMMENT_40 */
                                                                /* COMMENT_41 */

                                                                /* COMMENT_42 */
                                                                /* COMMENT_43 */

                                                                /* COMMENT_44 */
                                                                /* COMMENT_45 */

                                                                /* COMMENT_46 */
                                                                /* COMMENT_47 */

                                                                /* COMMENT_48 */
                                                                /* COMMENT_49 */

                                                                /* COMMENT_50 */
                                                                /* COMMENT_51 */

                                                                /* COMMENT_52 */
                                                                /* COMMENT_53 */

                                                                /* COMMENT_54 */
                                                                /* COMMENT_55 */

                                                                /* COMMENT_56 */
                                                                /* COMMENT_57 */

                                                                /* COMMENT_58 */
                                                                /* COMMENT_59 */

                                                                /* COMMENT_60 */
                                                                /* COMMENT_61 */
        case VAR_69:
        case VAR_70:
        case VAR_71:
        case VAR_72:
        case VAR_73:
        case VAR_74:
        case VAR_75:
        case VAR_76:
        case VAR_77:
        case VAR_78:
        case VAR_79:
        case VAR_80:
        case VAR_81:
        case VAR_82:
        case VAR_83:
                                                                /* COMMENT_62 */
             if (VAR_0->CtrlCmd == VAR_69) {
                 VAR_1 = (CPU_CHAR *)""."";
             } else if (VAR_0->CtrlCmd == VAR_71) {
                 VAR_1 = (CPU_CHAR *)"".."";
             } else if (VAR_0->CtrlCmd == VAR_83) {
                                                                /* COMMENT_63 */
                                                                /* COMMENT_64 */
                                                                /* COMMENT_65 */
                                                                /* COMMENT_66 */
                                                                /* COMMENT_67 */
                                                                /* COMMENT_68 */
                 VAR_1   = FTPs_FindFileName(&VAR_0->CtrlCmdArgs);
                 VAR_2 = FTPs_FindArg(&VAR_0->CtrlCmdArgs);

                                                                /* COMMENT_69 */
                                                                /* COMMENT_70 */
                 VAR_11 = Str_Len(VAR_2);
                 if (VAR_11 == 14) {
                    for (VAR_14 = 0; VAR_14 < 14; VAR_14++) {
                        VAR_12 = ASCII_IsDig(VAR_2[VAR_14]);
                        if (VAR_12 == VAR_65) {
                            break;
                        }
                    }
                    if (VAR_14 == 14) {
                                                                /* COMMENT_71 */
                                                                /* COMMENT_72 */
                        VAR_1 = FTPs_FindFileName(&VAR_0->CtrlCmdArgs);
                    } else {
                        VAR_2 = """";
                    }
                 } else {
                    VAR_2 = """";
                 }
             } else {
                 VAR_1 = FTPs_FindFileName(&VAR_0->CtrlCmdArgs);
             }

             if (*VAR_1 != (CPU_CHAR)0) {
                 FTPs_ToFTPStylePath(VAR_1);
             }

                                                                /* COMMENT_73 */
             if (*VAR_1 == '-') {
                 VAR_1 = (CPU_CHAR *)""."";
             }

             VAR_6 = NetFS_CfgPathGetLenMax();

             VAR_13 = FTPs_BuildPath(VAR_84,   VAR_6,
                                      VAR_85,   VAR_6,
                                      VAR_86, VAR_6,
                                      VAR_87,      VAR_6,
                                      VAR_0->BasePath,
                                      VAR_0->RelPath,
                                      VAR_1);

             FTPs_ToFSStylePath(VAR_84);
             FTPs_ToFSStylePath(VAR_86);

                                                                /* COMMENT_74 */
                                                                /* COMMENT_75 */
             if (VAR_13 == VAR_37) {
                 switch (VAR_0->CtrlCmd) {
                     case VAR_69:
                     case VAR_70:
                     case VAR_71:
                     case VAR_73:
                     case VAR_74:
                     case VAR_75:
                          VAR_4 = NetFS_DirOpen(VAR_84);
                          if (VAR_4 == (void *)0) {
                              VAR_13 = VAR_88;
                          } else {
                              VAR_13 = VAR_37;
                          }
                          NetFS_DirClose(VAR_4);
                          break;


                     case VAR_79:
                          VAR_4 = NetFS_DirOpen(VAR_86);
                          if (VAR_4 == (void *)0) {
                              VAR_13 = VAR_88;
                          }
                          NetFS_DirClose(VAR_4);
                          break;


                     case VAR_72:
                     case VAR_76:
                     case VAR_77:
                     case VAR_78:
                     case VAR_80:
                     case VAR_81:
                     case VAR_82:
                     case VAR_83:
                          VAR_3 = NetFS_FileOpen(VAR_84,
                                                  VAR_89,
                                                  VAR_90);
                          if (VAR_3 != (void *)0) {
                              switch (VAR_0->CtrlCmd) {
                                  case VAR_72:
                                  case VAR_78:
                                  case VAR_81:
                                       VAR_13 = VAR_88;
                                       break;

                                  case VAR_82:
                                       NetFS_FileSizeGet(VAR_3, &VAR_5.Size);
                                       break;

                                  case VAR_83:
                                       NetFS_FileDateTimeCreateGet(VAR_3, &VAR_5.DateTimeCreate);
                                       break;

                                  default:
                                       VAR_13 = VAR_37;
                                       break;
                              }
                              NetFS_FileClose(VAR_3);

                          } else {
                              switch (VAR_0->CtrlCmd) {
                                  case VAR_72:
                                  case VAR_77:
                                  case VAR_78:
                                  case VAR_81:
                                       VAR_13 = VAR_37;
                                       break;

                                  default:
                                       VAR_13 = VAR_88;
                                       break;
                              }
                          }
                          break;


                     default:
                          break;
                 }

                                                                /* COMMENT_76 */
                 if (VAR_13 == VAR_37) {
                     switch (VAR_0->CtrlCmd) {
                         case VAR_69:
                              Str_FmtPrint((char *)VAR_59,
                                                   VAR_60,
                                           (char *)""257 \""%s\"" is current directory."",
                                                   VAR_85);
                              FTPs_SendReply(VAR_0->CtrlSockID, VAR_91, VAR_59);
                              break;

                         case VAR_70:
                         case VAR_71:
                              Str_Copy_N(VAR_0->RelPath,  VAR_85, VAR_92);
                              FTPs_SendReply(VAR_0->CtrlSockID, VAR_93, (CPU_CHAR *)0);
                              break;

                         case VAR_74:
                         case VAR_75:
                         case VAR_76:
                         case VAR_77:
                         case VAR_78:
                              FTPs_SendReply(VAR_0->CtrlSockID, VAR_94, (CPU_CHAR *)0);
                              VAR_0->DtpCmd = VAR_0->CtrlCmd;
                              Str_Copy_N(VAR_0->CurEntry, VAR_84, VAR_92);
                              FTPs_DtpTask((void *)VAR_0);
                              VAR_0->DtpOffset = 0;
                              VAR_0->CtrlState = VAR_38;
                              break;

                         case VAR_72:
                              VAR_13 = NetFS_EntryCreate(VAR_84, VAR_58);
                              if (VAR_13 == VAR_37) {
                                  Str_FmtPrint((char *)VAR_59,
                                                       VAR_60,
                                               (char *)VAR_61[VAR_91].ReplyStr,
                                                       VAR_85);
                                  FTPs_SendReply(VAR_0->CtrlSockID, VAR_91, VAR_59);
                              } else {
                                  Str_FmtPrint((char *)VAR_59,
                                                       VAR_60,
                                               (char *)VAR_61[VAR_95].ReplyStr,
                                                       VAR_85);
                                  FTPs_SendReply(VAR_0->CtrlSockID, VAR_95, VAR_59);
                              }
                              break;

                         case VAR_73:
                              VAR_13 = NetFS_EntryDel(VAR_84, VAR_65);
                              if (VAR_13 == VAR_37) {
                                  FTPs_SendReply(VAR_0->CtrlSockID, VAR_93, (CPU_CHAR *)0);
                              } else {
                                  Str_FmtPrint((char *)VAR_59,
                                                       VAR_60,
                                               (char *)VAR_61[VAR_95].ReplyStr,
                                                       VAR_85);
                                  FTPs_SendReply(VAR_0->CtrlSockID, VAR_95, VAR_59);
                              }
                              break;

                         case VAR_79:
                              VAR_13 = NetFS_EntryDel(VAR_84, VAR_58);
                              if (VAR_13 == VAR_37) {
                                  FTPs_SendReply(VAR_0->CtrlSockID, VAR_93, (CPU_CHAR *)0);
                              } else {
                                  Str_FmtPrint((char *)VAR_59,
                                                       VAR_60,
                                               (char *)VAR_61[VAR_95].ReplyStr,
                                                       VAR_85);
                                  FTPs_SendReply(VAR_0->CtrlSockID, VAR_95, VAR_59);
                              }
                              break;

                         case VAR_80:
                              Str_Copy_N(VAR_96, VAR_84, VAR_92);
                              Str_Copy_N(VAR_97, VAR_85, VAR_92);
                              VAR_0->CtrlState = VAR_98;
                              FTPs_SendReply(VAR_0->CtrlSockID, VAR_68, (CPU_CHAR *)0);
                              break;

                         case VAR_81:
                              VAR_13 = NetFS_EntryRename(VAR_96, VAR_84);
                              VAR_0->CtrlState = VAR_38;
                              if (VAR_13 == VAR_37) {
                                  FTPs_SendReply(VAR_0->CtrlSockID, VAR_93, (CPU_CHAR *)0);
                              } else {
                                  Str_FmtPrint((char *)VAR_59,
                                                       VAR_60,
                                               (char *)VAR_61[VAR_95].ReplyStr,
                                                       VAR_97);
                                  FTPs_SendReply(VAR_0->CtrlSockID, VAR_95, VAR_59);
                              }
                              break;

                         case VAR_82:
                              Str_FmtPrint((char       *)VAR_59,
                                                         VAR_60,
                                           (char       *)""213 %u"",
                                           (unsigned int)VAR_5.Size);
                              FTPs_SendReply(VAR_0->CtrlSockID, VAR_99, VAR_59);
                              break;

                         case VAR_83:
                              VAR_11 = Str_Cmp(VAR_2, """");
                              if (VAR_11 == 0) {
                                                                /* COMMENT_77 */
                                  Str_FmtPrint((char *)VAR_59,
                                                       VAR_60,
                                               (char *)""213 %04hu%02hu%02hu%02hu%02hu%02hu"",
                                                       VAR_5.DateTimeCreate.Yr,
                                                       VAR_5.DateTimeCreate.Month,
                                                       VAR_5.DateTimeCreate.Day,
                                                       VAR_5.DateTimeCreate.Hr,
                                                       VAR_5.DateTimeCreate.Min,
                                                       VAR_5.DateTimeCreate.Sec);
                                  FTPs_SendReply(VAR_0->CtrlSockID, VAR_99, VAR_59);
                              } else {
                                                                /* COMMENT_78 */
                                  Str_FmtScan((char *)VAR_2,
                                                     ""%04hu%02hu%02hu%02hu%02hu%02hu"",
                                                     (CPU_INT16U *)&VAR_5.DateTimeCreate.Yr,
                                                     (CPU_INT16U *)&VAR_5.DateTimeCreate.Month,
                                                     (CPU_INT16U *)&VAR_5.DateTimeCreate.Day,
                                                     (CPU_INT16U *)&VAR_5.DateTimeCreate.Hr,
                                                     (CPU_INT16U *)&VAR_5.DateTimeCreate.Min,
                                                     (CPU_INT16U *)&VAR_5.DateTimeCreate.Sec);
                                 (void)NetFS_EntryTimeSet(VAR_84, &VAR_5.DateTimeCreate);
                                  FTPs_SendReply(VAR_0->CtrlSockID, VAR_93, (CPU_CHAR *)0);
                              }
                              break;

                         default:
                            break;
                     }
                 } else {
                     Str_FmtPrint((char *)VAR_59,
                                          VAR_60,
                                  (char *)VAR_61[VAR_95].ReplyStr,
                                          VAR_85);
                     FTPs_SendReply(VAR_0->CtrlSockID, VAR_95, VAR_59);
                 }
             } else {
                 FTPs_SendReply(VAR_0->CtrlSockID, VAR_100, (CPU_CHAR *)0);
             }
             break;

       case VAR_101:
            Str_FmtPrint((char *)VAR_59,
                                 VAR_60,
                         (char *)VAR_61[VAR_102].ReplyStr,
                                 VAR_0->CtrlCmdArgs);
             FTPs_SendReply(VAR_0->CtrlSockID, VAR_102, VAR_59);
             break;


       case VAR_103:
             Str_FmtPrint((char *)VAR_59,
                                  VAR_60,
                          (char *)VAR_61[VAR_104].ReplyStr,
                                  VAR_0->CtrlCmdArgs);
             FTPs_SendReply(VAR_0->CtrlSockID, VAR_104, VAR_59);
             break;


        default:
             FTPs_SendReply(VAR_0->CtrlSockID, VAR_105, (CPU_CHAR *)0);
             break;
    }
}",weston-embedded/uC-FTPs/2bbf7c6111766f626923ca5acd29ea827ea5128f/ftp-s.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -234,7 +234,7 @@
 
                  for (i = 0; i <= 3; i++) {
                      dig = ASCII_IsDig(*ftp_session->CtrlCmdArgs);
-                     while ((dig == DEF_NO) && (ftp_session->CtrlCmdArgs != (CPU_CHAR *)0)) {
+                     while ((dig == DEF_NO) && (ftp_session->CtrlCmdArgs != (CPU_CHAR *)0) && (*ftp_session->CtrlCmdArgs != 0)) {
                          ftp_session->CtrlCmdArgs++;
                          dig = ASCII_IsDig(*ftp_session->CtrlCmdArgs);
                      }
@@ -242,7 +242,7 @@
                  }
                  for (i = 0; i <= 1; i++) {
                      dig = ASCII_IsDig(*ftp_session->CtrlCmdArgs);
-                     while ((dig == DEF_NO) && (ftp_session->CtrlCmdArgs != 0)) {
+                     while ((dig == DEF_NO) && (ftp_session->CtrlCmdArgs != 0) && (*ftp_session->CtrlCmdArgs != 0)) {
                          ftp_session->CtrlCmdArgs++;
                          dig = ASCII_IsDig(*ftp_session->CtrlCmdArgs);
                      }","{'deleted_lines': ['                     while ((dig == DEF_NO) && (ftp_session->CtrlCmdArgs != (CPU_CHAR *)0)) {', '                     while ((dig == DEF_NO) && (ftp_session->CtrlCmdArgs != 0)) {'], 'added_lines': ['                     while ((dig == DEF_NO) && (ftp_session->CtrlCmdArgs != (CPU_CHAR *)0) && (*ftp_session->CtrlCmdArgs != 0)) {', '                     while ((dig == DEF_NO) && (ftp_session->CtrlCmdArgs != 0) && (*ftp_session->CtrlCmdArgs != 0)) {']}",True,An out-of-bounds read vulnerability exists in the PORT command parameter extraction functionality of Weston Embedded uC-FTPs v 1.98.00. A specially-crafted set of network packets can lead to denial of service. An attacker can send packets to trigger this vulnerability.This vulnerability occurs when no IP address argument is provided to the `PORT` command.,6.5,MEDIUM,1,test,2023-02-24T19:25:05Z,4
CVE-2023-28371,['CWE-22'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,Stellarium/stellarium,"Fix a possible security issue
- script output might have been stored to paths elsewhere
- Thanks to G.C. for reporting",1261f74dc4aa6bbd01ab514343424097f8cf46b7,https://github.com/Stellarium/stellarium/commit/1261f74dc4aa6bbd01ab514343424097f8cf46b7,src/scripting/StelScriptOutput.cpp,StelScriptOutput::saveOutputAs,"void StelScriptOutput::saveOutputAs(const QString &name)
{
QFile asFile;
QFileInfo outputInfo(outputFile);
QDir dir=outputInfo.dir(); QFileInfo newFileNameInfo(name);
bool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(""scripts/flag_script_allow_write_absolute_path"", false).toBool();
if (!okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))
{
qWarning() << ""SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname."";
qWarning() << ""  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true"";
asFile.setFileName(dir.absolutePath() + ""/"" + newFileNameInfo.fileName());
qWarning() << ""  Storing to "" << asFile.fileName() << "" instead"";
}
else if (okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))
{
asFile.setFileName(name);
}
else
{
asFile.setFileName(dir.absolutePath() + ""/"" + name);
}
if (!asFile.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text | QIODevice::Unbuffered))
{
qDebug() << ""ERROR: Cannot open file"" << asFile.fileName();
return;
}
qDebug() << ""saving copy of output.txt to "" << asFile.fileName();
asFile.write(qPrintable(outputText), outputText.size());
asFile.close();
}","void StelScriptOutput::saveOutputAs(const QString &VAR_0)
{
QFile VAR_1;
QFileInfo outputInfo(outputFile);
QDir VAR_2=VAR_3.dir(); 
QFileInfo newFileNameInfo(name);
bool VAR_4=StelApp::getInstance().getSettings()->value(""scripts/flag_script_allow_write_absolute_path"", false).toBool();
if (!VAR_4 && (VAR_5.isAbsolute()))
{
qWarning() << ""SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname."";
qWarning() << ""  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true"";
VAR_1.setFileName(VAR_2.absolutePath() + ""/"" + VAR_5.fileName());
qWarning() << ""  Storing to "" << VAR_1.fileName() << "" instead"";
}
else if (VAR_4 && (VAR_5.isAbsolute()))
{
VAR_1.setFileName(name);
}
else
{
VAR_1.setFileName(VAR_2.absolutePath() + ""/"" + name);
}
if (!VAR_1.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text | QIODevice::Unbuffered))
{
qDebug() << ""ERROR: Cannot open file"" << VAR_1.fileName();
return;
}
qDebug() << ""saving copy of output.txt to "" << VAR_1.fileName();
VAR_1.write(qPrintable(VAR_6), VAR_6.size());
VAR_1.close();
}",Stellarium/stellarium/1261f74dc4aa6bbd01ab514343424097f8cf46b7/StelScriptOutput.cpp/vul/before/0.json,"void StelScriptOutput::saveOutputAs(const QString &name)
{
	QFile asFile;
	const QFileInfo outputInfo(outputFile);
	const QDir dir=outputInfo.dir(); // will hold complete dirname
	const QFileInfo newFileNameInfo(name);

	const bool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(""scripts/flag_script_allow_write_absolute_path"", false).toBool();

	if (!okToSaveToAbsolutePath && ((newFileNameInfo.isAbsolute() || (name.contains(""..""))))) // The last condition may include dangerous/malicious paths
	{
		qWarning() << ""SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname or move up in directories."";
		qWarning() << ""  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true"";
		asFile.setFileName(dir.absolutePath() + ""/"" + newFileNameInfo.fileName());
		qWarning() << ""  Storing to "" << asFile.fileName() << "" instead"";
	}
	else if (okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))
	{
		asFile.setFileName(name);
	}
	else
	{
		asFile.setFileName(dir.absolutePath() + ""/"" + name);
	}

	if (!asFile.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text | QIODevice::Unbuffered))
	{
		qDebug() << ""ERROR: Cannot open file"" << asFile.fileName();
		return;
	}
	qDebug() << ""saving copy of output.txt to "" << asFile.fileName();
	asFile.write(qPrintable(outputText), outputText.size());
	asFile.close();
}","void StelScriptOutput::saveOutputAs(const QString &VAR_0)
{
	QFile VAR_1;
	const QFileInfo outputInfo(outputFile);
	const QDir VAR_2=VAR_3.dir(); /* COMMENT_0 */
	const QFileInfo newFileNameInfo(name);

	const bool VAR_4=StelApp::getInstance().getSettings()->value(""scripts/flag_script_allow_write_absolute_path"", false).toBool();

	if (!VAR_4 && ((VAR_5.isAbsolute() || (name.contains(""..""))))) /* COMMENT_1 */
	{
		qWarning() << ""SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname or move up in directories."";
		qWarning() << ""  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true"";
		VAR_1.setFileName(VAR_2.absolutePath() + ""/"" + VAR_5.fileName());
		qWarning() << ""  Storing to "" << VAR_1.fileName() << "" instead"";
	}
	else if (VAR_4 && (VAR_5.isAbsolute()))
	{
		VAR_1.setFileName(name);
	}
	else
	{
		VAR_1.setFileName(VAR_2.absolutePath() + ""/"" + name);
	}

	if (!VAR_1.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text | QIODevice::Unbuffered))
	{
		qDebug() << ""ERROR: Cannot open file"" << VAR_1.fileName();
		return;
	}
	qDebug() << ""saving copy of output.txt to "" << VAR_1.fileName();
	VAR_1.write(qPrintable(VAR_6), VAR_6.size());
	VAR_1.close();
}",Stellarium/stellarium/1261f74dc4aa6bbd01ab514343424097f8cf46b7/StelScriptOutput.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,15 +1,15 @@
 void StelScriptOutput::saveOutputAs(const QString &name)
 {
 	QFile asFile;
-	QFileInfo outputInfo(outputFile);
-	QDir dir=outputInfo.dir(); // will hold complete dirname
-	QFileInfo newFileNameInfo(name);
+	const QFileInfo outputInfo(outputFile);
+	const QDir dir=outputInfo.dir(); // will hold complete dirname
+	const QFileInfo newFileNameInfo(name);
 
-	bool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(""scripts/flag_script_allow_write_absolute_path"", false).toBool();
+	const bool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(""scripts/flag_script_allow_write_absolute_path"", false).toBool();
 
-	if (!okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))
+	if (!okToSaveToAbsolutePath && ((newFileNameInfo.isAbsolute() || (name.contains(""..""))))) // The last condition may include dangerous/malicious paths
 	{
-		qWarning() << ""SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname."";
+		qWarning() << ""SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname or move up in directories."";
 		qWarning() << ""  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true"";
 		asFile.setFileName(dir.absolutePath() + ""/"" + newFileNameInfo.fileName());
 		qWarning() << ""  Storing to "" << asFile.fileName() << "" instead"";","{'deleted_lines': ['\tQFileInfo outputInfo(outputFile);', '\tQDir dir=outputInfo.dir(); // will hold complete dirname', '\tQFileInfo newFileNameInfo(name);', '\tbool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(""scripts/flag_script_allow_write_absolute_path"", false).toBool();', '\tif (!okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))', '\t\tqWarning() << ""SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname."";'], 'added_lines': ['\tconst QFileInfo outputInfo(outputFile);', '\tconst QDir dir=outputInfo.dir(); // will hold complete dirname', '\tconst QFileInfo newFileNameInfo(name);', '\tconst bool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(""scripts/flag_script_allow_write_absolute_path"", false).toBool();', '\tif (!okToSaveToAbsolutePath && ((newFileNameInfo.isAbsolute() || (name.contains(""..""))))) // The last condition may include dangerous/malicious paths', '\t\tqWarning() << ""SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname or move up in directories."";']}",True,"In Stellarium through 1.2, attackers can write to files that are typically unintended, such as ones with absolute pathnames or .. directory traversal.",9.8,CRITICAL,3,test,2023-03-04T15:15:54Z,4
CVE-2023-28371,['CWE-22'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,Stellarium/stellarium,"Fix a possible security issue
- disallow overwriting config.ini",eba61df3b38605befcb43687a4c0a159dbc0c5cb,https://github.com/Stellarium/stellarium/commit/eba61df3b38605befcb43687a4c0a159dbc0c5cb,src/scripting/StelScriptOutput.cpp,StelScriptOutput::saveOutputAs,"void StelScriptOutput::saveOutputAs(const QString &name)
{
QFile asFile;
const QFileInfo outputInfo(outputFile);
const QDir dir=outputInfo.dir(); const QFileInfo newFileNameInfo(name);
const bool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(""scripts/flag_script_allow_write_absolute_path"", false).toBool();
if (!okToSaveToAbsolutePath && ((newFileNameInfo.isAbsolute() || (name.contains(""..""))))) {
qWarning() << ""SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname or move up in directories."";
qWarning() << ""  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true"";
asFile.setFileName(dir.absolutePath() + ""/"" + newFileNameInfo.fileName());
qWarning() << ""  Storing to "" << asFile.fileName() << "" instead"";
}
else if (okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))
{
asFile.setFileName(name);
}
else
{
asFile.setFileName(dir.absolutePath() + ""/"" + name);
}
if (!asFile.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text | QIODevice::Unbuffered))
{
qDebug() << ""ERROR: Cannot open file"" << asFile.fileName();
return;
}
qDebug() << ""saving copy of output.txt to "" << asFile.fileName();
asFile.write(qPrintable(outputText), outputText.size());
asFile.close();
}","void StelScriptOutput::saveOutputAs(const QString &VAR_0)
{
QFile VAR_1;
const QFileInfo outputInfo(outputFile);
const QDir VAR_2=VAR_3.dir(); 
const QFileInfo newFileNameInfo(name);
const bool VAR_4=StelApp::getInstance().getSettings()->value(""scripts/flag_script_allow_write_absolute_path"", false).toBool();
if (!VAR_4 && ((VAR_5.isAbsolute() || (name.contains(""..""))))) 
{
qWarning() << ""SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname or move up in directories."";
qWarning() << ""  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true"";
VAR_1.setFileName(VAR_2.absolutePath() + ""/"" + VAR_5.fileName());
qWarning() << ""  Storing to "" << VAR_1.fileName() << "" instead"";
}
else if (VAR_4 && (VAR_5.isAbsolute()))
{
VAR_1.setFileName(name);
}
else
{
VAR_1.setFileName(VAR_2.absolutePath() + ""/"" + name);
}
if (!VAR_1.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text | QIODevice::Unbuffered))
{
qDebug() << ""ERROR: Cannot open file"" << VAR_1.fileName();
return;
}
qDebug() << ""saving copy of output.txt to "" << VAR_1.fileName();
VAR_1.write(qPrintable(VAR_6), VAR_6.size());
VAR_1.close();
}",Stellarium/stellarium/eba61df3b38605befcb43687a4c0a159dbc0c5cb/StelScriptOutput.cpp/vul/before/0.json,"void StelScriptOutput::saveOutputAs(const QString &name)
{
	QFile asFile;
	const QFileInfo outputInfo(outputFile);
	const QDir dir=outputInfo.dir(); // will hold complete dirname
	const QFileInfo newFileNameInfo(name);

	const bool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(""scripts/flag_script_allow_write_absolute_path"", false).toBool();

	if (name.contains(""config.ini""))
	{
		qWarning() << ""SCRIPTING ERROR: You are trying to overwrite config.ini. Ignoring."";
		return;
	}

	if (!okToSaveToAbsolutePath && ((newFileNameInfo.isAbsolute() || (name.contains(""..""))))) // The last condition may include dangerous/malicious paths
	{
		qWarning() << ""SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname or move up in directories."";
		qWarning() << ""  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true"";
		asFile.setFileName(dir.absolutePath() + ""/"" + newFileNameInfo.fileName());
		qWarning() << ""  Storing to "" << asFile.fileName() << "" instead"";
	}
	else if (okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))
	{
		asFile.setFileName(name);
	}
	else
	{
		asFile.setFileName(dir.absolutePath() + ""/"" + name);
	}

	if (!asFile.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text | QIODevice::Unbuffered))
	{
		qDebug() << ""ERROR: Cannot open file"" << asFile.fileName();
		return;
	}
	qDebug() << ""saving copy of output.txt to "" << asFile.fileName();
	asFile.write(qPrintable(outputText), outputText.size());
	asFile.close();
}","void StelScriptOutput::saveOutputAs(const QString &VAR_0)
{
	QFile VAR_1;
	const QFileInfo outputInfo(outputFile);
	const QDir VAR_2=VAR_3.dir(); /* COMMENT_0 */
	const QFileInfo newFileNameInfo(name);

	const bool VAR_4=StelApp::getInstance().getSettings()->value(""scripts/flag_script_allow_write_absolute_path"", false).toBool();

	if (name.contains(""config.ini""))
	{
		qWarning() << ""SCRIPTING ERROR: You are trying to overwrite config.ini. Ignoring."";
		return;
	}

	if (!VAR_4 && ((VAR_5.isAbsolute() || (name.contains(""..""))))) /* COMMENT_1 */
	{
		qWarning() << ""SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname or move up in directories."";
		qWarning() << ""  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true"";
		VAR_1.setFileName(VAR_2.absolutePath() + ""/"" + VAR_5.fileName());
		qWarning() << ""  Storing to "" << VAR_1.fileName() << "" instead"";
	}
	else if (VAR_4 && (VAR_5.isAbsolute()))
	{
		VAR_1.setFileName(name);
	}
	else
	{
		VAR_1.setFileName(VAR_2.absolutePath() + ""/"" + name);
	}

	if (!VAR_1.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text | QIODevice::Unbuffered))
	{
		qDebug() << ""ERROR: Cannot open file"" << VAR_1.fileName();
		return;
	}
	qDebug() << ""saving copy of output.txt to "" << VAR_1.fileName();
	VAR_1.write(qPrintable(VAR_6), VAR_6.size());
	VAR_1.close();
}",Stellarium/stellarium/eba61df3b38605befcb43687a4c0a159dbc0c5cb/StelScriptOutput.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,6 +6,12 @@
 	const QFileInfo newFileNameInfo(name);
 
 	const bool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(""scripts/flag_script_allow_write_absolute_path"", false).toBool();
+
+	if (name.contains(""config.ini""))
+	{
+		qWarning() << ""SCRIPTING ERROR: You are trying to overwrite config.ini. Ignoring."";
+		return;
+	}
 
 	if (!okToSaveToAbsolutePath && ((newFileNameInfo.isAbsolute() || (name.contains(""..""))))) // The last condition may include dangerous/malicious paths
 	{","{'deleted_lines': [], 'added_lines': ['', '\tif (name.contains(""config.ini""))', '\t{', '\t\tqWarning() << ""SCRIPTING ERROR: You are trying to overwrite config.ini. Ignoring."";', '\t\treturn;', '\t}']}",True,"In Stellarium through 1.2, attackers can write to files that are typically unintended, such as ones with absolute pathnames or .. directory traversal.",9.8,CRITICAL,3,test,2023-03-04T17:02:01Z,4
CVE-2023-28371,['CWE-22'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,Stellarium/stellarium,"Fix a possible security issue
- Require manually set flag to run scripts from absolute pathname
- Mostly applies to scripts given on the command line",787a894897b7872ae96e6f5804a182210edd5c78,https://github.com/Stellarium/stellarium/commit/787a894897b7872ae96e6f5804a182210edd5c78,src/scripting/StelScriptMgr.cpp,StelScriptMgr::runScript,"bool StelScriptMgr::runScript(const QString& fileName, const QString& includePath)
{
QString preprocessedScript;
prepareScript(preprocessedScript,fileName,includePath);
return runPreprocessedScript(preprocessedScript,fileName);
}","bool StelScriptMgr::runScript(const QString& VAR_0, const QString& VAR_1)
{
QString VAR_2;
prepareScript(VAR_2,VAR_0,VAR_1);
return runPreprocessedScript(VAR_2,VAR_0);
}",Stellarium/stellarium/787a894897b7872ae96e6f5804a182210edd5c78/StelScriptMgr.cpp/vul/before/0.json,"bool StelScriptMgr::runScript(const QString& fileName, const QString& includePath)
{
	QString preprocessedScript;
	if (prepareScript(preprocessedScript,fileName,includePath))
		return runPreprocessedScript(preprocessedScript,fileName);
	else
		return false;
}","bool StelScriptMgr::runScript(const QString& VAR_0, const QString& VAR_1)
{
	QString VAR_2;
	if (prepareScript(VAR_2,VAR_0,VAR_1))
		return runPreprocessedScript(VAR_2,VAR_0);
	else
		return false;
}",Stellarium/stellarium/787a894897b7872ae96e6f5804a182210edd5c78/StelScriptMgr.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,8 @@
 bool StelScriptMgr::runScript(const QString& fileName, const QString& includePath)
 {
 	QString preprocessedScript;
-	prepareScript(preprocessedScript,fileName,includePath);
-	return runPreprocessedScript(preprocessedScript,fileName);
+	if (prepareScript(preprocessedScript,fileName,includePath))
+		return runPreprocessedScript(preprocessedScript,fileName);
+	else
+		return false;
 }","{'deleted_lines': ['\tprepareScript(preprocessedScript,fileName,includePath);', '\treturn runPreprocessedScript(preprocessedScript,fileName);'], 'added_lines': ['\tif (prepareScript(preprocessedScript,fileName,includePath))', '\t\treturn runPreprocessedScript(preprocessedScript,fileName);', '\telse', '\t\treturn false;']}",True,"In Stellarium through 1.2, attackers can write to files that are typically unintended, such as ones with absolute pathnames or .. directory traversal.",9.8,CRITICAL,3,test,2023-03-04T17:03:44Z,4
CVE-2023-28371,['CWE-22'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,Stellarium/stellarium,"Fix a possible security issue
- Require manually set flag to run scripts from absolute pathname
- Mostly applies to scripts given on the command line",787a894897b7872ae96e6f5804a182210edd5c78,https://github.com/Stellarium/stellarium/commit/787a894897b7872ae96e6f5804a182210edd5c78,src/scripting/StelScriptMgr.cpp,StelScriptMgr::prepareScript,"bool StelScriptMgr::prepareScript( QString &script, const QString &fileName, const QString &includePath)
{
QString absPath;
if (QFileInfo(fileName).isAbsolute())
absPath = fileName;
else
absPath = StelFileMgr::findFile(""scripts/"" + fileName);
if (absPath.isEmpty())
{
QString msg = QString(""WARNING: could not find script file %1"").arg(QDir::toNativeSeparators(fileName));
emit scriptDebug(msg);
qWarning() << msg;
return false;
}
QString scriptDir = QFileInfo(absPath).dir().path();
QFile fic(absPath);
if (!fic.open(QIODevice::ReadOnly))
{
QString msg = QString(""WARNING: cannot open script: %1"").arg(QDir::toNativeSeparators(fileName));
emit scriptDebug(msg);
qWarning() << msg;
return false;
}
if (!includePath.isEmpty())
scriptDir = includePath;
bool ok = false;
if (fileName.endsWith("".ssc""))
ok = preprocessFile(absPath, fic, script, scriptDir);
if (!ok)
{
return false;
}
return true;
}","bool StelScriptMgr::prepareScript( QString &VAR_0, const QString &VAR_1, const QString &VAR_2)
{
QString VAR_3;
if (QFileInfo(VAR_1).isAbsolute())
VAR_3 = VAR_1;
else
VAR_3 = StelFileMgr::findFile(""scripts/"" + VAR_1);
if (VAR_3.isEmpty())
{
QString VAR_4 = QString(""WARNING: could not find script file %1"").arg(QDir::toNativeSeparators(VAR_1));
emit scriptDebug(msg);
qWarning() << msg;
return false;
}
QString VAR_5 = QFileInfo(VAR_3).dir().path();
QFile fic(absPath);
if (!VAR_6.open(QIODevice::ReadOnly))
{
QString msg = QString(""WARNING: cannot open script: %1"").arg(QDir::toNativeSeparators(VAR_1));
emit scriptDebug(msg);
qWarning() << msg;
return false;
}
if (!VAR_2.isEmpty())
VAR_5 = VAR_2;
bool VAR_7 = false;
if (VAR_1.endsWith("".ssc""))
VAR_7 = preprocessFile(absPath, VAR_6, VAR_0, VAR_5);
if (!VAR_7)
{
return false;
}
return true;
}",Stellarium/stellarium/787a894897b7872ae96e6f5804a182210edd5c78/StelScriptMgr.cpp/vul/before/1.json,"bool StelScriptMgr::prepareScript( QString &script, const QString &fileName, const QString &includePath)
{
	QString absPath;
	const bool okToRunScriptFromAbsolutePath=StelApp::getInstance().getSettings()->value(""scripts/flag_script_allow_absolute_path"", false).toBool();

	if (QFileInfo(fileName).isAbsolute())
	{
		// Absolute paths may bear a security risk. We need a flag to allow them!
		if (okToRunScriptFromAbsolutePath)
			absPath = fileName;
		else
		{
			qWarning() << ""SCRIPTING CONFIGURATION ISSUE: You are trying to run a script from absolute pathname."";
			qWarning() << ""  To enable this, edit config.ini and set [scripts]/flag_script_allow_absolute_path=true"";
			return false;
		}
	}
	else
		absPath = StelFileMgr::findFile(""scripts/"" + fileName);

	if (absPath.isEmpty())
	{
		QString msg = QString(""WARNING: could not find script file %1"").arg(QDir::toNativeSeparators(fileName));
		emit scriptDebug(msg);
		qWarning() << msg;
		return false;
	}

	QString scriptDir = QFileInfo(absPath).dir().path();

	QFile fic(absPath);
	if (!fic.open(QIODevice::ReadOnly))
	{
		QString msg = QString(""WARNING: cannot open script: %1"").arg(QDir::toNativeSeparators(fileName));
		emit scriptDebug(msg);
		qWarning() << msg;
		return false;
	}

	if (!includePath.isEmpty())
		scriptDir = includePath;

	bool ok = false;
	if (fileName.endsWith("".ssc""))
		ok = preprocessFile(absPath, fic, script, scriptDir);
	if (!ok)
	{
		return false;
	}

	return true;
}","bool StelScriptMgr::prepareScript( QString &VAR_0, const QString &VAR_1, const QString &VAR_2)
{
	QString VAR_3;
	const bool VAR_4=StelApp::getInstance().getSettings()->value(""scripts/flag_script_allow_absolute_path"", false).toBool();

	if (QFileInfo(VAR_1).isAbsolute())
	{
		/* COMMENT_0 */
		if (VAR_4)
			VAR_3 = VAR_1;
		else
		{
			qWarning() << ""SCRIPTING CONFIGURATION ISSUE: You are trying to run a script from absolute pathname."";
			qWarning() << ""  To enable this, edit config.ini and set [scripts]/flag_script_allow_absolute_path=true"";
			return false;
		}
	}
	else
		VAR_3 = StelFileMgr::findFile(""scripts/"" + VAR_1);

	if (VAR_3.isEmpty())
	{
		QString VAR_5 = QString(""WARNING: could not find script file %1"").arg(QDir::toNativeSeparators(VAR_1));
		emit scriptDebug(msg);
		qWarning() << msg;
		return false;
	}

	QString VAR_6 = QFileInfo(VAR_3).dir().path();

	QFile fic(absPath);
	if (!VAR_7.open(QIODevice::ReadOnly))
	{
		QString msg = QString(""WARNING: cannot open script: %1"").arg(QDir::toNativeSeparators(VAR_1));
		emit scriptDebug(msg);
		qWarning() << msg;
		return false;
	}

	if (!VAR_2.isEmpty())
		VAR_6 = VAR_2;

	bool VAR_8 = false;
	if (VAR_1.endsWith("".ssc""))
		VAR_8 = preprocessFile(absPath, VAR_7, VAR_0, VAR_6);
	if (!VAR_8)
	{
		return false;
	}

	return true;
}",Stellarium/stellarium/787a894897b7872ae96e6f5804a182210edd5c78/StelScriptMgr.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,9 +1,20 @@
 bool StelScriptMgr::prepareScript( QString &script, const QString &fileName, const QString &includePath)
 {
 	QString absPath;
+	const bool okToRunScriptFromAbsolutePath=StelApp::getInstance().getSettings()->value(""scripts/flag_script_allow_absolute_path"", false).toBool();
 
 	if (QFileInfo(fileName).isAbsolute())
-		absPath = fileName;
+	{
+		// Absolute paths may bear a security risk. We need a flag to allow them!
+		if (okToRunScriptFromAbsolutePath)
+			absPath = fileName;
+		else
+		{
+			qWarning() << ""SCRIPTING CONFIGURATION ISSUE: You are trying to run a script from absolute pathname."";
+			qWarning() << ""  To enable this, edit config.ini and set [scripts]/flag_script_allow_absolute_path=true"";
+			return false;
+		}
+	}
 	else
 		absPath = StelFileMgr::findFile(""scripts/"" + fileName);
 ","{'deleted_lines': ['\t\tabsPath = fileName;'], 'added_lines': ['\tconst bool okToRunScriptFromAbsolutePath=StelApp::getInstance().getSettings()->value(""scripts/flag_script_allow_absolute_path"", false).toBool();', '\t{', '\t\t// Absolute paths may bear a security risk. We need a flag to allow them!', '\t\tif (okToRunScriptFromAbsolutePath)', '\t\t\tabsPath = fileName;', '\t\telse', '\t\t{', '\t\t\tqWarning() << ""SCRIPTING CONFIGURATION ISSUE: You are trying to run a script from absolute pathname."";', '\t\t\tqWarning() << ""  To enable this, edit config.ini and set [scripts]/flag_script_allow_absolute_path=true"";', '\t\t\treturn false;', '\t\t}', '\t}']}",True,"In Stellarium through 1.2, attackers can write to files that are typically unintended, such as ones with absolute pathnames or .. directory traversal.",9.8,CRITICAL,3,test,2023-03-04T17:03:44Z,4
CVE-2023-1289,['CWE-20'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,ImageMagick,erecursion detection,c5b23cbf2119540725e6dc81f4deb25798ead6a4,https://github.com/ImageMagick/ImageMagick/commit/c5b23cbf2119540725e6dc81f4deb25798ead6a4,MagickCore/draw.c,DrawPrimitive,"MagickExport MagickBooleanType DrawPrimitive(Image *image,
const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,
ExceptionInfo *exception)
{
CacheView
*image_view;
MagickStatusType
status;
ssize_t
i,
x;
ssize_t
y;
if (draw_info->debug != MagickFalse)
{
(void) LogMagickEvent(DrawEvent,GetMagickModule(),
""  begin draw-primitive"");
(void) LogMagickEvent(DrawEvent,GetMagickModule(),
""    affine: %g,%g,%g,%g,%g,%g"",draw_info->affine.sx,
draw_info->affine.rx,draw_info->affine.ry,draw_info->affine.sy,
draw_info->affine.tx,draw_info->affine.ty);
}
status=MagickTrue;
if ((IsGrayColorspace(image->colorspace) != MagickFalse) &&
((IsPixelInfoGray(&draw_info->fill) == MagickFalse) ||
(IsPixelInfoGray(&draw_info->stroke) == MagickFalse)))
status&=SetImageColorspace(image,sRGBColorspace,exception);
if (draw_info->compliance == SVGCompliance)
{
status&=SetImageMask(image,WritePixelMask,draw_info->clipping_mask,
exception);
status&=SetImageMask(image,CompositePixelMask,draw_info->composite_mask,
exception);
}
x=CastDoubleToLong(ceil(primitive_info->point.x-0.5));
y=CastDoubleToLong(ceil(primitive_info->point.y-0.5));
image_view=AcquireAuthenticCacheView(image,exception);
switch (primitive_info->primitive)
{
case AlphaPrimitive:
{
if (image->alpha_trait == UndefinedPixelTrait)
status&=SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
switch (primitive_info->method)
{
case PointMethod:
default:
{
PixelInfo
pixel;
Quantum
*q;
q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);
if (q == (Quantum *) NULL)
break;
GetFillColor(draw_info,x,y,&pixel,exception);
SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);
status&=SyncCacheViewAuthenticPixels(image_view,exception);
break;
}
case ReplaceMethod:
{
PixelInfo
pixel,
target;
status&=GetOneCacheViewVirtualPixelInfo(image_view,x,y,&target,
exception);
GetPixelInfo(image,&pixel);
for (y=0; y < (ssize_t) image->rows; y++)
{
Quantum
*magick_restrict q;
q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,
exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
GetPixelInfoPixel(image,q,&pixel);
if (IsFuzzyEquivalencePixelInfo(&pixel,&target) == MagickFalse)
{
q+=GetPixelChannels(image);
continue;
}
GetFillColor(draw_info,x,y,&pixel,exception);
SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);
q+=GetPixelChannels(image);
}
status&=SyncCacheViewAuthenticPixels(image_view,exception);
if (status == MagickFalse)
break;
}
break;
}
case FloodfillMethod:
case FillToBorderMethod:
{
ChannelType
channel_mask;
PixelInfo
target;
status&=GetOneVirtualPixelInfo(image,TileVirtualPixelMethod,x,y,
&target,exception);
if (primitive_info->method == FillToBorderMethod)
{
target.red=(double) draw_info->border_color.red;
target.green=(double) draw_info->border_color.green;
target.blue=(double) draw_info->border_color.blue;
}
channel_mask=SetImageChannelMask(image,AlphaChannel);
status&=FloodfillPaintImage(image,draw_info,&target,x,y,
primitive_info->method == FloodfillMethod ? MagickFalse :
MagickTrue,exception);
(void) SetImageChannelMask(image,channel_mask);
break;
}
case ResetMethod:
{
PixelInfo
pixel;
for (y=0; y < (ssize_t) image->rows; y++)
{
Quantum
*magick_restrict q;
q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,
exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
GetFillColor(draw_info,x,y,&pixel,exception);
SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);
q+=GetPixelChannels(image);
}
status&=SyncCacheViewAuthenticPixels(image_view,exception);
if (status == MagickFalse)
break;
}
break;
}
}
break;
}
case ColorPrimitive:
{
switch (primitive_info->method)
{
case PointMethod:
default:
{
PixelInfo
pixel;
Quantum
*q;
q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);
if (q == (Quantum *) NULL)
break;
GetPixelInfo(image,&pixel);
GetFillColor(draw_info,x,y,&pixel,exception);
SetPixelViaPixelInfo(image,&pixel,q);
status&=SyncCacheViewAuthenticPixels(image_view,exception);
break;
}
case ReplaceMethod:
{
PixelInfo
pixel,
target;
status&=GetOneCacheViewVirtualPixelInfo(image_view,x,y,&target,
exception);
for (y=0; y < (ssize_t) image->rows; y++)
{
Quantum
*magick_restrict q;
q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,
exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
GetPixelInfoPixel(image,q,&pixel);
if (IsFuzzyEquivalencePixelInfo(&pixel,&target) == MagickFalse)
{
q+=GetPixelChannels(image);
continue;
}
GetFillColor(draw_info,x,y,&pixel,exception);
SetPixelViaPixelInfo(image,&pixel,q);
q+=GetPixelChannels(image);
}
status&=SyncCacheViewAuthenticPixels(image_view,exception);
if (status == MagickFalse)
break;
}
break;
}
case FloodfillMethod:
case FillToBorderMethod:
{
PixelInfo
target;
status&=GetOneVirtualPixelInfo(image,TileVirtualPixelMethod,x,y,
&target,exception);
if (primitive_info->method == FillToBorderMethod)
{
target.red=(double) draw_info->border_color.red;
target.green=(double) draw_info->border_color.green;
target.blue=(double) draw_info->border_color.blue;
}
status&=FloodfillPaintImage(image,draw_info,&target,x,y,
primitive_info->method == FloodfillMethod ? MagickFalse :
MagickTrue,exception);
break;
}
case ResetMethod:
{
PixelInfo
pixel;
GetPixelInfo(image,&pixel);
for (y=0; y < (ssize_t) image->rows; y++)
{
Quantum
*magick_restrict q;
q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,
exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
GetFillColor(draw_info,x,y,&pixel,exception);
SetPixelViaPixelInfo(image,&pixel,q);
q+=GetPixelChannels(image);
}
status&=SyncCacheViewAuthenticPixels(image_view,exception);
if (status == MagickFalse)
break;
}
break;
}
}
break;
}
case ImagePrimitive:
{
AffineMatrix
affine;
char
composite_geometry[MagickPathExtent];
Image
*composite_image,
*composite_images;
ImageInfo
*clone_info;
RectangleInfo
geometry;
ssize_t
x1,
y1;
if (primitive_info->text == (char *) NULL)
break;
clone_info=CloneImageInfo(draw_info->image_info);
composite_images=(Image *) NULL;
if (LocaleNCompare(primitive_info->text,""data:"",5) == 0)
composite_images=ReadInlineImage(clone_info,primitive_info->text,
exception);
else
if (*primitive_info->text != '\0')
{
MagickBooleanType
path_status;
struct stat
attributes;
(void) CopyMagickString(clone_info->filename,primitive_info->text,
MagickPathExtent);
(void) SetImageInfo(clone_info,1,exception);
(void) CopyMagickString(clone_info->filename,primitive_info->text,
MagickPathExtent);
if (clone_info->size != (char *) NULL)
clone_info->size=DestroyString(clone_info->size);
if (clone_info->extract != (char *) NULL)
clone_info->extract=DestroyString(clone_info->extract);
path_status=GetPathAttributes(clone_info->filename,&attributes);
if (path_status != MagickFalse)
{
if (S_ISCHR(attributes.st_mode) == 0)
composite_images=ReadImage(clone_info,exception);
else
(void) ThrowMagickException(exception,GetMagickModule(),
FileOpenError,""UnableToOpenFile"",""`%s'"",
clone_info->filename);
}
else
if ((LocaleCompare(clone_info->magick,""ftp"") != 0) &&
(LocaleCompare(clone_info->magick,""http"") != 0) &&
(LocaleCompare(clone_info->magick,""https"") != 0))
composite_images=ReadImage(clone_info,exception);
else
(void) ThrowMagickException(exception,GetMagickModule(),
FileOpenError,""UnableToOpenFile"",""`%s'"",clone_info->filename);
}
clone_info=DestroyImageInfo(clone_info);
if (composite_images == (Image *) NULL)
{
status=MagickFalse;
break;
}
composite_image=RemoveFirstImageFromList(&composite_images);
composite_images=DestroyImageList(composite_images);
(void) SetImageProgressMonitor(composite_image,(MagickProgressMonitor)
NULL,(void *) NULL);
x1=CastDoubleToLong(ceil(primitive_info[1].point.x-0.5));
y1=CastDoubleToLong(ceil(primitive_info[1].point.y-0.5));
if (((x1 != 0L) && (x1 != (ssize_t) composite_image->columns)) ||
((y1 != 0L) && (y1 != (ssize_t) composite_image->rows)))
{
(void) FormatLocaleString(composite_geometry,MagickPathExtent,
""%gx%g!"",primitive_info[1].point.x,primitive_info[1].point.y);
composite_image->filter=image->filter;
status&=TransformImage(&composite_image,(char *) NULL,
composite_geometry,exception);
}
if (composite_image->alpha_trait == UndefinedPixelTrait)
status&=SetImageAlphaChannel(composite_image,OpaqueAlphaChannel,
exception);
if (draw_info->alpha != OpaqueAlpha)
status&=SetImageAlpha(composite_image,draw_info->alpha,exception);
SetGeometry(image,&geometry);
image->gravity=draw_info->gravity;
geometry.x=x;
geometry.y=y;
(void) FormatLocaleString(composite_geometry,MagickPathExtent,
""%.20gx%.20g%+.20g%+.20g"",(double) composite_image->columns,(double)
composite_image->rows,(double) geometry.x,(double) geometry.y);
(void) ParseGravityGeometry(image,composite_geometry,&geometry,exception);
affine=draw_info->affine;
affine.tx=(double) geometry.x;
affine.ty=(double) geometry.y;
composite_image->interpolate=image->interpolate;
if ((draw_info->compose == OverCompositeOp) ||
(draw_info->compose == SrcOverCompositeOp))
status&=DrawAffineImage(image,composite_image,&affine,exception);
else
status&=CompositeImage(image,composite_image,draw_info->compose,
MagickTrue,geometry.x,geometry.y,exception);
composite_image=DestroyImage(composite_image);
break;
}
case PointPrimitive:
{
PixelInfo
fill_color;
Quantum
*q;
if ((y < 0) || (y >= (ssize_t) image->rows))
break;
if ((x < 0) || (x >= (ssize_t) image->columns))
break;
q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);
if (q == (Quantum *) NULL)
break;
GetFillColor(draw_info,x,y,&fill_color,exception);
CompositePixelOver(image,&fill_color,(double) fill_color.alpha,q,(double)
GetPixelAlpha(image,q),q);
status&=SyncCacheViewAuthenticPixels(image_view,exception);
break;
}
case TextPrimitive:
{
char
geometry[MagickPathExtent];
DrawInfo
*clone_info;
if (primitive_info->text == (char *) NULL)
break;
clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
(void) CloneString(&clone_info->text,primitive_info->text);
(void) FormatLocaleString(geometry,MagickPathExtent,""%+f%+f"",
primitive_info->point.x,primitive_info->point.y);
(void) CloneString(&clone_info->geometry,geometry);
status&=AnnotateImage(image,clone_info,exception);
clone_info=DestroyDrawInfo(clone_info);
break;
}
default:
{
double
mid,
scale;
DrawInfo
*clone_info;
if (IsEventLogging() != MagickFalse)
LogPrimitiveInfo(primitive_info);
scale=ExpandAffine(&draw_info->affine);
if ((draw_info->dash_pattern != (double *) NULL) &&
(fabs(draw_info->dash_pattern[0]) >= MagickEpsilon) &&
(fabs(scale*draw_info->stroke_width) >= MagickEpsilon) &&
(draw_info->stroke.alpha != (Quantum) TransparentAlpha))
{
clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
clone_info->stroke_width=0.0;
clone_info->stroke.alpha=(MagickRealType) TransparentAlpha;
status&=DrawPolygonPrimitive(image,clone_info,primitive_info,
exception);
clone_info=DestroyDrawInfo(clone_info);
if (status != MagickFalse)
status&=DrawDashPolygon(draw_info,primitive_info,image,exception);
break;
}
mid=ExpandAffine(&draw_info->affine)*draw_info->stroke_width/2.0;
if ((mid > 1.0) &&
((draw_info->stroke.alpha != (Quantum) TransparentAlpha) ||
(draw_info->stroke_pattern != (Image *) NULL)))
{
double
point_x,
point_y;
MagickBooleanType
closed_path;
closed_path=primitive_info[0].closed_subpath;
i=(ssize_t) primitive_info[0].coordinates;
point_x=fabs(primitive_info[i-1].point.x-primitive_info[0].point.x);
point_y=fabs(primitive_info[i-1].point.y-primitive_info[0].point.y);
if ((point_x < MagickEpsilon) && (point_y < MagickEpsilon))
closed_path=MagickTrue;
if ((((draw_info->linecap == RoundCap) ||
(closed_path != MagickFalse)) &&
(draw_info->linejoin == RoundJoin)) ||
(primitive_info[i].primitive != UndefinedPrimitive))
{
status&=DrawPolygonPrimitive(image,draw_info,primitive_info,
exception);
break;
}
clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
clone_info->stroke_width=0.0;
clone_info->stroke.alpha=(MagickRealType) TransparentAlpha;
status&=DrawPolygonPrimitive(image,clone_info,primitive_info,
exception);
clone_info=DestroyDrawInfo(clone_info);
if (status != MagickFalse)
status&=DrawStrokePolygon(image,draw_info,primitive_info,exception);
break;
}
status&=DrawPolygonPrimitive(image,draw_info,primitive_info,exception);
break;
}
}
image_view=DestroyCacheView(image_view);
if (draw_info->compliance == SVGCompliance)
{
status&=SetImageMask(image,WritePixelMask,(Image *) NULL,exception);
status&=SetImageMask(image,CompositePixelMask,(Image *) NULL,exception);
}
if (draw_info->debug != MagickFalse)
(void) LogMagickEvent(DrawEvent,GetMagickModule(),""  end draw-primitive"");
return(status != 0 ? MagickTrue : MagickFalse);
}","MagickExport VAR_0 DrawPrimitive(Image *VAR_1,
const DrawInfo *VAR_2,const PrimitiveInfo *VAR_3,
ExceptionInfo *VAR_4)
{
CacheView
*VAR_5;
MagickStatusType
VAR_6;
ssize_t
VAR_7,
VAR_8;
ssize_t
VAR_9;
if (VAR_2->debug != VAR_10)
{
(void) LogMagickEvent(VAR_11,GetMagickModule(),
""  begin draw-primitive"");
(void) LogMagickEvent(VAR_11,GetMagickModule(),
""    affine: %g,%g,%g,%g,%g,%g"",VAR_2->affine.sx,
VAR_2->affine.rx,VAR_2->affine.ry,VAR_2->affine.sy,
VAR_2->affine.tx,VAR_2->affine.ty);
}
VAR_6=VAR_12;
if ((IsGrayColorspace(VAR_1->colorspace) != VAR_10) &&
((IsPixelInfoGray(&VAR_2->fill) == VAR_10) ||
(IsPixelInfoGray(&VAR_2->stroke) == VAR_10)))
VAR_6&=SetImageColorspace(VAR_1,VAR_13,VAR_4);
if (VAR_2->compliance == VAR_14)
{
VAR_6&=SetImageMask(VAR_1,VAR_15,VAR_2->clipping_mask,
VAR_4);
VAR_6&=SetImageMask(VAR_1,VAR_16,VAR_2->composite_mask,
VAR_4);
}
VAR_8=CastDoubleToLong(ceil(VAR_3->point.x-0.5));
VAR_9=CastDoubleToLong(ceil(VAR_3->point.y-0.5));
VAR_5=AcquireAuthenticCacheView(VAR_1,VAR_4);
switch (VAR_3->primitive)
{
case VAR_17:
{
if (VAR_1->alpha_trait == VAR_18)
VAR_6&=SetImageAlphaChannel(VAR_1,VAR_19,VAR_4);
switch (VAR_3->method)
{
case VAR_20:
default:
{
PixelInfo
VAR_21;
Quantum
*VAR_22;
VAR_22=GetCacheViewAuthenticPixels(VAR_5,VAR_8,VAR_9,1,1,VAR_4);
if (VAR_22 == (Quantum *) NULL)
break;
GetFillColor(VAR_2,VAR_8,VAR_9,&VAR_21,VAR_4);
SetPixelAlpha(VAR_1,ClampToQuantum(VAR_21.alpha),VAR_22);
VAR_6&=SyncCacheViewAuthenticPixels(VAR_5,VAR_4);
break;
}
case VAR_23:
{
PixelInfo
VAR_21,
VAR_24;
VAR_6&=GetOneCacheViewVirtualPixelInfo(VAR_5,VAR_8,VAR_9,&VAR_24,
VAR_4);
GetPixelInfo(VAR_1,&VAR_21);
for (VAR_9=0; VAR_9 < (ssize_t) VAR_1->rows; VAR_9++)
{
Quantum
*magick_restrict VAR_22;
VAR_22=GetCacheViewAuthenticPixels(VAR_5,0,VAR_9,VAR_1->columns,1,
VAR_4);
if (VAR_22 == (Quantum *) NULL)
break;
for (VAR_8=0; VAR_8 < (ssize_t) VAR_1->columns; VAR_8++)
{
GetPixelInfoPixel(VAR_1,VAR_22,&VAR_21);
if (IsFuzzyEquivalencePixelInfo(&VAR_21,&VAR_24) == VAR_10)
{
VAR_22+=GetPixelChannels(VAR_1);
continue;
}
GetFillColor(VAR_2,VAR_8,VAR_9,&VAR_21,VAR_4);
SetPixelAlpha(VAR_1,ClampToQuantum(VAR_21.alpha),VAR_22);
VAR_22+=GetPixelChannels(VAR_1);
}
VAR_6&=SyncCacheViewAuthenticPixels(VAR_5,VAR_4);
if (VAR_6 == VAR_10)
break;
}
break;
}
case VAR_25:
case VAR_26:
{
ChannelType
VAR_27;
PixelInfo
VAR_24;
VAR_6&=GetOneVirtualPixelInfo(VAR_1,VAR_28,VAR_8,VAR_9,
&VAR_24,VAR_4);
if (VAR_3->method == VAR_26)
{
VAR_24.red=(double) VAR_2->border_color.red;
VAR_24.green=(double) VAR_2->border_color.green;
VAR_24.blue=(double) VAR_2->border_color.blue;
}
VAR_27=SetImageChannelMask(VAR_1,VAR_29);
VAR_6&=FloodfillPaintImage(VAR_1,VAR_2,&VAR_24,VAR_8,VAR_9,
VAR_3->method == VAR_25 ? VAR_10 :
VAR_12,VAR_4);
(void) SetImageChannelMask(VAR_1,VAR_27);
break;
}
case VAR_30:
{
PixelInfo
VAR_21;
for (VAR_9=0; VAR_9 < (ssize_t) VAR_1->rows; VAR_9++)
{
Quantum
*magick_restrict VAR_22;
VAR_22=GetCacheViewAuthenticPixels(VAR_5,0,VAR_9,VAR_1->columns,1,
VAR_4);
if (VAR_22 == (Quantum *) NULL)
break;
for (VAR_8=0; VAR_8 < (ssize_t) VAR_1->columns; VAR_8++)
{
GetFillColor(VAR_2,VAR_8,VAR_9,&VAR_21,VAR_4);
SetPixelAlpha(VAR_1,ClampToQuantum(VAR_21.alpha),VAR_22);
VAR_22+=GetPixelChannels(VAR_1);
}
VAR_6&=SyncCacheViewAuthenticPixels(VAR_5,VAR_4);
if (VAR_6 == VAR_10)
break;
}
break;
}
}
break;
}
case VAR_31:
{
switch (VAR_3->method)
{
case VAR_20:
default:
{
PixelInfo
VAR_21;
Quantum
*VAR_22;
VAR_22=GetCacheViewAuthenticPixels(VAR_5,VAR_8,VAR_9,1,1,VAR_4);
if (VAR_22 == (Quantum *) NULL)
break;
GetPixelInfo(VAR_1,&VAR_21);
GetFillColor(VAR_2,VAR_8,VAR_9,&VAR_21,VAR_4);
SetPixelViaPixelInfo(VAR_1,&VAR_21,VAR_22);
VAR_6&=SyncCacheViewAuthenticPixels(VAR_5,VAR_4);
break;
}
case VAR_23:
{
PixelInfo
VAR_21,
VAR_24;
VAR_6&=GetOneCacheViewVirtualPixelInfo(VAR_5,VAR_8,VAR_9,&VAR_24,
VAR_4);
for (VAR_9=0; VAR_9 < (ssize_t) VAR_1->rows; VAR_9++)
{
Quantum
*magick_restrict VAR_22;
VAR_22=GetCacheViewAuthenticPixels(VAR_5,0,VAR_9,VAR_1->columns,1,
VAR_4);
if (VAR_22 == (Quantum *) NULL)
break;
for (VAR_8=0; VAR_8 < (ssize_t) VAR_1->columns; VAR_8++)
{
GetPixelInfoPixel(VAR_1,VAR_22,&VAR_21);
if (IsFuzzyEquivalencePixelInfo(&VAR_21,&VAR_24) == VAR_10)
{
VAR_22+=GetPixelChannels(VAR_1);
continue;
}
GetFillColor(VAR_2,VAR_8,VAR_9,&VAR_21,VAR_4);
SetPixelViaPixelInfo(VAR_1,&VAR_21,VAR_22);
VAR_22+=GetPixelChannels(VAR_1);
}
VAR_6&=SyncCacheViewAuthenticPixels(VAR_5,VAR_4);
if (VAR_6 == VAR_10)
break;
}
break;
}
case VAR_25:
case VAR_26:
{
PixelInfo
VAR_24;
VAR_6&=GetOneVirtualPixelInfo(VAR_1,VAR_28,VAR_8,VAR_9,
&VAR_24,VAR_4);
if (VAR_3->method == VAR_26)
{
VAR_24.red=(double) VAR_2->border_color.red;
VAR_24.green=(double) VAR_2->border_color.green;
VAR_24.blue=(double) VAR_2->border_color.blue;
}
VAR_6&=FloodfillPaintImage(VAR_1,VAR_2,&VAR_24,VAR_8,VAR_9,
VAR_3->method == VAR_25 ? VAR_10 :
VAR_12,VAR_4);
break;
}
case VAR_30:
{
PixelInfo
VAR_21;
GetPixelInfo(VAR_1,&VAR_21);
for (VAR_9=0; VAR_9 < (ssize_t) VAR_1->rows; VAR_9++)
{
Quantum
*magick_restrict VAR_22;
VAR_22=GetCacheViewAuthenticPixels(VAR_5,0,VAR_9,VAR_1->columns,1,
VAR_4);
if (VAR_22 == (Quantum *) NULL)
break;
for (VAR_8=0; VAR_8 < (ssize_t) VAR_1->columns; VAR_8++)
{
GetFillColor(VAR_2,VAR_8,VAR_9,&VAR_21,VAR_4);
SetPixelViaPixelInfo(VAR_1,&VAR_21,VAR_22);
VAR_22+=GetPixelChannels(VAR_1);
}
VAR_6&=SyncCacheViewAuthenticPixels(VAR_5,VAR_4);
if (VAR_6 == VAR_10)
break;
}
break;
}
}
break;
}
case VAR_32:
{
AffineMatrix
VAR_33;
char
VAR_34[VAR_35];
Image
*VAR_36,
*VAR_37;
ImageInfo
*VAR_38;
RectangleInfo
VAR_39;
ssize_t
VAR_40,
VAR_41;
if (VAR_3->text == (char *) NULL)
break;
VAR_38=CloneImageInfo(VAR_2->image_info);
VAR_37=(Image *) NULL;
if (LocaleNCompare(VAR_3->text,""data:"",5) == 0)
VAR_37=ReadInlineImage(VAR_38,VAR_3->text,
VAR_4);
else
if (*VAR_3->text != '\0')
{
MagickBooleanType
VAR_42;
struct stat
VAR_43;
(void) CopyMagickString(VAR_38->filename,VAR_3->text,
VAR_35);
(void) SetImageInfo(VAR_38,1,VAR_4);
(void) CopyMagickString(VAR_38->filename,VAR_3->text,
VAR_35);
if (VAR_38->size != (char *) NULL)
VAR_38->size=DestroyString(VAR_38->size);
if (VAR_38->extract != (char *) NULL)
VAR_38->extract=DestroyString(VAR_38->extract);
VAR_42=GetPathAttributes(VAR_38->filename,&VAR_43);
if (VAR_42 != VAR_10)
{
if (S_ISCHR(VAR_43.st_mode) == 0)
VAR_37=ReadImage(VAR_38,VAR_4);
else
(void) ThrowMagickException(VAR_4,GetMagickModule(),
VAR_44,""UnableToOpenFile"",""`%s'"",
VAR_38->filename);
}
else
if ((LocaleCompare(VAR_38->magick,""ftp"") != 0) &&
(LocaleCompare(VAR_38->magick,""http"") != 0) &&
(LocaleCompare(VAR_38->magick,""https"") != 0))
VAR_37=ReadImage(VAR_38,VAR_4);
else
(void) ThrowMagickException(VAR_4,GetMagickModule(),
VAR_44,""UnableToOpenFile"",""`%s'"",VAR_38->filename);
}
VAR_38=DestroyImageInfo(VAR_38);
if (VAR_37 == (Image *) NULL)
{
VAR_6=VAR_10;
break;
}
VAR_36=RemoveFirstImageFromList(&VAR_37);
VAR_37=DestroyImageList(VAR_37);
(void) SetImageProgressMonitor(VAR_36,(MagickProgressMonitor)
NULL,(void *) NULL);
VAR_40=CastDoubleToLong(ceil(VAR_3[1].point.x-0.5));
VAR_41=CastDoubleToLong(ceil(VAR_3[1].point.y-0.5));
if (((VAR_40 != 0L) && (VAR_40 != (ssize_t) VAR_36->columns)) ||
((VAR_41 != 0L) && (VAR_41 != (ssize_t) VAR_36->rows)))
{
(void) FormatLocaleString(VAR_34,VAR_35,
""%gx%g!"",VAR_3[1].point.x,VAR_3[1].point.y);
VAR_36->filter=VAR_1->filter;
VAR_6&=TransformImage(&VAR_36,(char *) NULL,
VAR_34,VAR_4);
}
if (VAR_36->alpha_trait == VAR_18)
VAR_6&=SetImageAlphaChannel(VAR_36,VAR_19,
VAR_4);
if (VAR_2->alpha != VAR_45)
VAR_6&=SetImageAlpha(VAR_36,VAR_2->alpha,VAR_4);
SetGeometry(VAR_1,&VAR_39);
VAR_1->gravity=VAR_2->gravity;
VAR_39.x=VAR_8;
VAR_39.y=VAR_9;
(void) FormatLocaleString(VAR_34,VAR_35,
""%.20gx%.20g%+.20g%+.20g"",(double) VAR_36->columns,(double)
VAR_36->rows,(double) VAR_39.x,(double) VAR_39.y);
(void) ParseGravityGeometry(VAR_1,VAR_34,&VAR_39,VAR_4);
VAR_33=VAR_2->affine;
VAR_33.tx=(double) VAR_39.x;
VAR_33.ty=(double) VAR_39.y;
VAR_36->interpolate=VAR_1->interpolate;
if ((VAR_2->compose == VAR_46) ||
(VAR_2->compose == VAR_47))
VAR_6&=DrawAffineImage(VAR_1,VAR_36,&VAR_33,VAR_4);
else
VAR_6&=CompositeImage(VAR_1,VAR_36,VAR_2->compose,
VAR_12,VAR_39.x,VAR_39.y,VAR_4);
VAR_36=DestroyImage(VAR_36);
break;
}
case VAR_48:
{
PixelInfo
VAR_49;
Quantum
*VAR_22;
if ((VAR_9 < 0) || (VAR_9 >= (ssize_t) VAR_1->rows))
break;
if ((VAR_8 < 0) || (VAR_8 >= (ssize_t) VAR_1->columns))
break;
VAR_22=GetCacheViewAuthenticPixels(VAR_5,VAR_8,VAR_9,1,1,VAR_4);
if (VAR_22 == (Quantum *) NULL)
break;
GetFillColor(VAR_2,VAR_8,VAR_9,&VAR_49,VAR_4);
CompositePixelOver(VAR_1,&VAR_49,(double) VAR_49.alpha,VAR_22,(double)
GetPixelAlpha(VAR_1,VAR_22),VAR_22);
VAR_6&=SyncCacheViewAuthenticPixels(VAR_5,VAR_4);
break;
}
case VAR_50:
{
char
VAR_39[VAR_35];
DrawInfo
*VAR_38;
if (VAR_3->text == (char *) NULL)
break;
VAR_38=CloneDrawInfo((ImageInfo *) NULL,VAR_2);
(void) CloneString(&VAR_38->text,VAR_3->text);
(void) FormatLocaleString(VAR_39,VAR_35,""%+f%+f"",
VAR_3->point.x,VAR_3->point.y);
(void) CloneString(&VAR_38->geometry,VAR_39);
VAR_6&=AnnotateImage(VAR_1,VAR_38,VAR_4);
VAR_38=DestroyDrawInfo(VAR_38);
break;
}
default:
{
double
VAR_51,
VAR_52;
DrawInfo
*VAR_38;
if (IsEventLogging() != VAR_10)
LogPrimitiveInfo(VAR_3);
VAR_52=ExpandAffine(&VAR_2->affine);
if ((VAR_2->dash_pattern != (double *) NULL) &&
(fabs(VAR_2->dash_pattern[0]) >= VAR_53) &&
(fabs(VAR_52*VAR_2->stroke_width) >= VAR_53) &&
(VAR_2->stroke.alpha != (Quantum) VAR_54))
{
VAR_38=CloneDrawInfo((ImageInfo *) NULL,VAR_2);
VAR_38->stroke_width=0.0;
VAR_38->stroke.alpha=(MagickRealType) VAR_54;
VAR_6&=DrawPolygonPrimitive(VAR_1,VAR_38,VAR_3,
VAR_4);
VAR_38=DestroyDrawInfo(VAR_38);
if (VAR_6 != VAR_10)
VAR_6&=DrawDashPolygon(VAR_2,VAR_3,VAR_1,VAR_4);
break;
}
VAR_51=ExpandAffine(&VAR_2->affine)*VAR_2->stroke_width/2.0;
if ((VAR_51 > 1.0) &&
((VAR_2->stroke.alpha != (Quantum) VAR_54) ||
(VAR_2->stroke_pattern != (Image *) NULL)))
{
double
VAR_55,
VAR_56;
MagickBooleanType
VAR_57;
VAR_57=VAR_3[0].closed_subpath;
VAR_7=(ssize_t) VAR_3[0].coordinates;
VAR_55=fabs(VAR_3[VAR_7-1].point.x-VAR_3[0].point.x);
VAR_56=fabs(VAR_3[VAR_7-1].point.y-VAR_3[0].point.y);
if ((VAR_55 < VAR_53) && (VAR_56 < VAR_53))
VAR_57=VAR_12;
if ((((VAR_2->linecap == VAR_58) ||
(VAR_57 != VAR_10)) &&
(VAR_2->linejoin == VAR_59)) ||
(VAR_3[VAR_7].primitive != VAR_60))
{
VAR_6&=DrawPolygonPrimitive(VAR_1,VAR_2,VAR_3,
VAR_4);
break;
}
VAR_38=CloneDrawInfo((ImageInfo *) NULL,VAR_2);
VAR_38->stroke_width=0.0;
VAR_38->stroke.alpha=(MagickRealType) VAR_54;
VAR_6&=DrawPolygonPrimitive(VAR_1,VAR_38,VAR_3,
VAR_4);
VAR_38=DestroyDrawInfo(VAR_38);
if (VAR_6 != VAR_10)
VAR_6&=DrawStrokePolygon(VAR_1,VAR_2,VAR_3,VAR_4);
break;
}
VAR_6&=DrawPolygonPrimitive(VAR_1,VAR_2,VAR_3,VAR_4);
break;
}
}
VAR_5=DestroyCacheView(VAR_5);
if (VAR_2->compliance == VAR_14)
{
VAR_6&=SetImageMask(VAR_1,VAR_15,(Image *) NULL,VAR_4);
VAR_6&=SetImageMask(VAR_1,VAR_16,(Image *) NULL,VAR_4);
}
if (VAR_2->debug != VAR_10)
(void) LogMagickEvent(VAR_11,GetMagickModule(),""  end draw-primitive"");
return(VAR_6 != 0 ? VAR_12 : VAR_10);
}",,"MagickExport MagickBooleanType DrawPrimitive(Image *image,
  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,
  ExceptionInfo *exception)
{
  CacheView
    *image_view;

  MagickStatusType
    status;

  ssize_t
    i,
    x;

  ssize_t
    y;

  if (draw_info->debug != MagickFalse)
    {
      (void) LogMagickEvent(DrawEvent,GetMagickModule(),
        ""  begin draw-primitive"");
      (void) LogMagickEvent(DrawEvent,GetMagickModule(),
        ""    affine: %g,%g,%g,%g,%g,%g"",draw_info->affine.sx,
        draw_info->affine.rx,draw_info->affine.ry,draw_info->affine.sy,
        draw_info->affine.tx,draw_info->affine.ty);
    }
  status=MagickTrue;
  if ((IsGrayColorspace(image->colorspace) != MagickFalse) &&
      ((IsPixelInfoGray(&draw_info->fill) == MagickFalse) ||
       (IsPixelInfoGray(&draw_info->stroke) == MagickFalse)))
    status&=SetImageColorspace(image,sRGBColorspace,exception);
  if (draw_info->compliance == SVGCompliance)
    {
      status&=SetImageMask(image,WritePixelMask,draw_info->clipping_mask,
        exception);
      status&=SetImageMask(image,CompositePixelMask,draw_info->composite_mask,
        exception);
    }
  x=CastDoubleToLong(ceil(primitive_info->point.x-0.5));
  y=CastDoubleToLong(ceil(primitive_info->point.y-0.5));
  image_view=AcquireAuthenticCacheView(image,exception);
  switch (primitive_info->primitive)
  {
    case AlphaPrimitive:
    {
      if (image->alpha_trait == UndefinedPixelTrait)
        status&=SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
      switch (primitive_info->method)
      {
        case PointMethod:
        default:
        {
          PixelInfo
            pixel;

          Quantum
            *q;

          q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);
          if (q == (Quantum *) NULL)
            break;
          GetFillColor(draw_info,x,y,&pixel,exception);
          SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);
          status&=SyncCacheViewAuthenticPixels(image_view,exception);
          break;
        }
        case ReplaceMethod:
        {
          PixelInfo
            pixel,
            target;

          status&=GetOneCacheViewVirtualPixelInfo(image_view,x,y,&target,
            exception);
          GetPixelInfo(image,&pixel);
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            Quantum
              *magick_restrict q;

            q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,
              exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              GetPixelInfoPixel(image,q,&pixel);
              if (IsFuzzyEquivalencePixelInfo(&pixel,&target) == MagickFalse)
                {
                  q+=GetPixelChannels(image);
                  continue;
                }
              GetFillColor(draw_info,x,y,&pixel,exception);
              SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);
              q+=GetPixelChannels(image);
            }
            status&=SyncCacheViewAuthenticPixels(image_view,exception);
            if (status == MagickFalse)
              break;
          }
          break;
        }
        case FloodfillMethod:
        case FillToBorderMethod:
        {
          ChannelType
            channel_mask;

          PixelInfo
            target;

          status&=GetOneVirtualPixelInfo(image,TileVirtualPixelMethod,x,y,
            &target,exception);
          if (primitive_info->method == FillToBorderMethod)
            {
              target.red=(double) draw_info->border_color.red;
              target.green=(double) draw_info->border_color.green;
              target.blue=(double) draw_info->border_color.blue;
            }
          channel_mask=SetImageChannelMask(image,AlphaChannel);
          status&=FloodfillPaintImage(image,draw_info,&target,x,y,
            primitive_info->method == FloodfillMethod ? MagickFalse :
            MagickTrue,exception);
          (void) SetImageChannelMask(image,channel_mask);
          break;
        }
        case ResetMethod:
        {
          PixelInfo
            pixel;

          for (y=0; y < (ssize_t) image->rows; y++)
          {
            Quantum
              *magick_restrict q;

            q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,
              exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              GetFillColor(draw_info,x,y,&pixel,exception);
              SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);
              q+=GetPixelChannels(image);
            }
            status&=SyncCacheViewAuthenticPixels(image_view,exception);
            if (status == MagickFalse)
              break;
          }
          break;
        }
      }
      break;
    }
    case ColorPrimitive:
    {
      switch (primitive_info->method)
      {
        case PointMethod:
        default:
        {
          PixelInfo
            pixel;

          Quantum
            *q;

          q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);
          if (q == (Quantum *) NULL)
            break;
          GetPixelInfo(image,&pixel);
          GetFillColor(draw_info,x,y,&pixel,exception);
          SetPixelViaPixelInfo(image,&pixel,q);
          status&=SyncCacheViewAuthenticPixels(image_view,exception);
          break;
        }
        case ReplaceMethod:
        {
          PixelInfo
            pixel,
            target;

          status&=GetOneCacheViewVirtualPixelInfo(image_view,x,y,&target,
            exception);
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            Quantum
              *magick_restrict q;

            q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,
              exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              GetPixelInfoPixel(image,q,&pixel);
              if (IsFuzzyEquivalencePixelInfo(&pixel,&target) == MagickFalse)
                {
                  q+=GetPixelChannels(image);
                  continue;
                }
              GetFillColor(draw_info,x,y,&pixel,exception);
              SetPixelViaPixelInfo(image,&pixel,q);
              q+=GetPixelChannels(image);
            }
            status&=SyncCacheViewAuthenticPixels(image_view,exception);
            if (status == MagickFalse)
              break;
          }
          break;
        }
        case FloodfillMethod:
        case FillToBorderMethod:
        {
          PixelInfo
            target;

          status&=GetOneVirtualPixelInfo(image,TileVirtualPixelMethod,x,y,
            &target,exception);
          if (primitive_info->method == FillToBorderMethod)
            {
              target.red=(double) draw_info->border_color.red;
              target.green=(double) draw_info->border_color.green;
              target.blue=(double) draw_info->border_color.blue;
            }
          status&=FloodfillPaintImage(image,draw_info,&target,x,y,
            primitive_info->method == FloodfillMethod ? MagickFalse :
            MagickTrue,exception);
          break;
        }
        case ResetMethod:
        {
          PixelInfo
            pixel;

          GetPixelInfo(image,&pixel);
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            Quantum
              *magick_restrict q;

            q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,
              exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              GetFillColor(draw_info,x,y,&pixel,exception);
              SetPixelViaPixelInfo(image,&pixel,q);
              q+=GetPixelChannels(image);
            }
            status&=SyncCacheViewAuthenticPixels(image_view,exception);
            if (status == MagickFalse)
              break;
          }
          break;
        }
      }
      break;
    }
    case ImagePrimitive:
    {
      AffineMatrix
        affine;

      char
        composite_geometry[MagickPathExtent];

      Image
        *composite_image,
        *composite_images;

      ImageInfo
        *clone_info;

      RectangleInfo
        geometry;

      ssize_t
        x1,
        y1;

      if (primitive_info->text == (char *) NULL)
        break;
      clone_info=AcquireImageInfo();
      clone_info->recursion_depth=draw_info->image_info->recursion_depth;
      composite_images=(Image *) NULL;
      if (LocaleNCompare(primitive_info->text,""data:"",5) == 0)
        composite_images=ReadInlineImage(clone_info,primitive_info->text,
          exception);
      else
        if (*primitive_info->text != '\0')
          {
            MagickBooleanType
              path_status;

            struct stat
              attributes;

            /*
              Read composite image.
            */
            (void) CopyMagickString(clone_info->filename,primitive_info->text,
              MagickPathExtent);
            (void) SetImageInfo(clone_info,1,exception);
            (void) CopyMagickString(clone_info->filename,primitive_info->text,
              MagickPathExtent);
            if (clone_info->size != (char *) NULL)
              clone_info->size=DestroyString(clone_info->size);
            if (clone_info->extract != (char *) NULL)
              clone_info->extract=DestroyString(clone_info->extract);
            path_status=GetPathAttributes(clone_info->filename,&attributes);
            if (path_status != MagickFalse)
              {
                if (S_ISCHR(attributes.st_mode) == 0)
                  composite_images=ReadImage(clone_info,exception);
                else
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    FileOpenError,""UnableToOpenFile"",""`%s'"",
                      clone_info->filename);
              }
            else
              if ((LocaleCompare(clone_info->magick,""ftp"") != 0) &&
                  (LocaleCompare(clone_info->magick,""http"") != 0) &&
                  (LocaleCompare(clone_info->magick,""https"") != 0))
                composite_images=ReadImage(clone_info,exception);
              else
                (void) ThrowMagickException(exception,GetMagickModule(),
                  FileOpenError,""UnableToOpenFile"",""`%s'"",clone_info->filename);
          }
      clone_info=DestroyImageInfo(clone_info);
      if (composite_images == (Image *) NULL)
        {
          status=MagickFalse;
          break;
        }
      composite_image=RemoveFirstImageFromList(&composite_images);
      composite_images=DestroyImageList(composite_images);
      (void) SetImageProgressMonitor(composite_image,(MagickProgressMonitor)
        NULL,(void *) NULL);
      x1=CastDoubleToLong(ceil(primitive_info[1].point.x-0.5));
      y1=CastDoubleToLong(ceil(primitive_info[1].point.y-0.5));
      if (((x1 != 0L) && (x1 != (ssize_t) composite_image->columns)) ||
          ((y1 != 0L) && (y1 != (ssize_t) composite_image->rows)))
        {
          /*
            Resize image.
          */
          (void) FormatLocaleString(composite_geometry,MagickPathExtent,
            ""%gx%g!"",primitive_info[1].point.x,primitive_info[1].point.y);
          composite_image->filter=image->filter;
          status&=TransformImage(&composite_image,(char *) NULL,
            composite_geometry,exception);
        }
      if (composite_image->alpha_trait == UndefinedPixelTrait)
        status&=SetImageAlphaChannel(composite_image,OpaqueAlphaChannel,
          exception);
      if (draw_info->alpha != OpaqueAlpha)
        status&=SetImageAlpha(composite_image,draw_info->alpha,exception);
      SetGeometry(image,&geometry);
      image->gravity=draw_info->gravity;
      geometry.x=x;
      geometry.y=y;
      (void) FormatLocaleString(composite_geometry,MagickPathExtent,
        ""%.20gx%.20g%+.20g%+.20g"",(double) composite_image->columns,(double)
        composite_image->rows,(double) geometry.x,(double) geometry.y);
      (void) ParseGravityGeometry(image,composite_geometry,&geometry,exception);
      affine=draw_info->affine;
      affine.tx=(double) geometry.x;
      affine.ty=(double) geometry.y;
      composite_image->interpolate=image->interpolate;
      if ((draw_info->compose == OverCompositeOp) ||
          (draw_info->compose == SrcOverCompositeOp))
        status&=DrawAffineImage(image,composite_image,&affine,exception);
      else
        status&=CompositeImage(image,composite_image,draw_info->compose,
          MagickTrue,geometry.x,geometry.y,exception);
      composite_image=DestroyImage(composite_image);
      break;
    }
    case PointPrimitive:
    {
      PixelInfo
        fill_color;

      Quantum
        *q;

      if ((y < 0) || (y >= (ssize_t) image->rows))
        break;
      if ((x < 0) || (x >= (ssize_t) image->columns))
        break;
      q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);
      if (q == (Quantum *) NULL)
        break;
      GetFillColor(draw_info,x,y,&fill_color,exception);
      CompositePixelOver(image,&fill_color,(double) fill_color.alpha,q,(double)
        GetPixelAlpha(image,q),q);
      status&=SyncCacheViewAuthenticPixels(image_view,exception);
      break;
    }
    case TextPrimitive:
    {
      char
        geometry[MagickPathExtent];

      DrawInfo
        *clone_info;

      if (primitive_info->text == (char *) NULL)
        break;
      clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
      (void) CloneString(&clone_info->text,primitive_info->text);
      (void) FormatLocaleString(geometry,MagickPathExtent,""%+f%+f"",
        primitive_info->point.x,primitive_info->point.y);
      (void) CloneString(&clone_info->geometry,geometry);
      status&=AnnotateImage(image,clone_info,exception);
      clone_info=DestroyDrawInfo(clone_info);
      break;
    }
    default:
    {
      double
        mid,
        scale;

      DrawInfo
        *clone_info;

      if (IsEventLogging() != MagickFalse)
        LogPrimitiveInfo(primitive_info);
      scale=ExpandAffine(&draw_info->affine);
      if ((draw_info->dash_pattern != (double *) NULL) &&
          (fabs(draw_info->dash_pattern[0]) >= MagickEpsilon) &&
          (fabs(scale*draw_info->stroke_width) >= MagickEpsilon) &&
          (draw_info->stroke.alpha != (Quantum) TransparentAlpha))
        {
          /*
            Draw dash polygon.
          */
          clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
          clone_info->stroke_width=0.0;
          clone_info->stroke.alpha=(MagickRealType) TransparentAlpha;
          status&=DrawPolygonPrimitive(image,clone_info,primitive_info,
            exception);
          clone_info=DestroyDrawInfo(clone_info);
          if (status != MagickFalse)
            status&=DrawDashPolygon(draw_info,primitive_info,image,exception);
          break;
        }
      mid=ExpandAffine(&draw_info->affine)*draw_info->stroke_width/2.0;
      if ((mid > 1.0) &&
          ((draw_info->stroke.alpha != (Quantum) TransparentAlpha) ||
           (draw_info->stroke_pattern != (Image *) NULL)))
        {
          double
            point_x,
            point_y;

          MagickBooleanType
            closed_path;

          /*
            Draw strokes while respecting line cap/join attributes.
          */
          closed_path=primitive_info[0].closed_subpath;
          i=(ssize_t) primitive_info[0].coordinates;
          point_x=fabs(primitive_info[i-1].point.x-primitive_info[0].point.x);
          point_y=fabs(primitive_info[i-1].point.y-primitive_info[0].point.y);
          if ((point_x < MagickEpsilon) && (point_y < MagickEpsilon))
            closed_path=MagickTrue;
          if ((((draw_info->linecap == RoundCap) ||
                (closed_path != MagickFalse)) &&
               (draw_info->linejoin == RoundJoin)) ||
               (primitive_info[i].primitive != UndefinedPrimitive))
            {
              status&=DrawPolygonPrimitive(image,draw_info,primitive_info,
                exception);
              break;
            }
          clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
          clone_info->stroke_width=0.0;
          clone_info->stroke.alpha=(MagickRealType) TransparentAlpha;
          status&=DrawPolygonPrimitive(image,clone_info,primitive_info,
            exception);
          clone_info=DestroyDrawInfo(clone_info);
          if (status != MagickFalse)
            status&=DrawStrokePolygon(image,draw_info,primitive_info,exception);
          break;
        }
      status&=DrawPolygonPrimitive(image,draw_info,primitive_info,exception);
      break;
    }
  }
  image_view=DestroyCacheView(image_view);
  if (draw_info->compliance == SVGCompliance)
    {
      status&=SetImageMask(image,WritePixelMask,(Image *) NULL,exception);
      status&=SetImageMask(image,CompositePixelMask,(Image *) NULL,exception);
    }
  if (draw_info->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent,GetMagickModule(),""  end draw-primitive"");
  return(status != 0 ? MagickTrue : MagickFalse);
}","MagickExport VAR_0 DrawPrimitive(Image *VAR_1,
  const DrawInfo *VAR_2,const PrimitiveInfo *VAR_3,
  ExceptionInfo *VAR_4)
{
  CacheView
    *VAR_5;

  MagickStatusType
    VAR_6;

  ssize_t
    VAR_7,
    VAR_8;

  ssize_t
    VAR_9;

  if (VAR_2->debug != VAR_10)
    {
      (void) LogMagickEvent(VAR_11,GetMagickModule(),
        ""  begin draw-primitive"");
      (void) LogMagickEvent(VAR_11,GetMagickModule(),
        ""    affine: %g,%g,%g,%g,%g,%g"",VAR_2->affine.sx,
        VAR_2->affine.rx,VAR_2->affine.ry,VAR_2->affine.sy,
        VAR_2->affine.tx,VAR_2->affine.ty);
    }
  VAR_6=VAR_12;
  if ((IsGrayColorspace(VAR_1->colorspace) != VAR_10) &&
      ((IsPixelInfoGray(&VAR_2->fill) == VAR_10) ||
       (IsPixelInfoGray(&VAR_2->stroke) == VAR_10)))
    VAR_6&=SetImageColorspace(VAR_1,VAR_13,VAR_4);
  if (VAR_2->compliance == VAR_14)
    {
      VAR_6&=SetImageMask(VAR_1,VAR_15,VAR_2->clipping_mask,
        VAR_4);
      VAR_6&=SetImageMask(VAR_1,VAR_16,VAR_2->composite_mask,
        VAR_4);
    }
  VAR_8=CastDoubleToLong(ceil(VAR_3->point.x-0.5));
  VAR_9=CastDoubleToLong(ceil(VAR_3->point.y-0.5));
  VAR_5=AcquireAuthenticCacheView(VAR_1,VAR_4);
  switch (VAR_3->primitive)
  {
    case VAR_17:
    {
      if (VAR_1->alpha_trait == VAR_18)
        VAR_6&=SetImageAlphaChannel(VAR_1,VAR_19,VAR_4);
      switch (VAR_3->method)
      {
        case VAR_20:
        default:
        {
          PixelInfo
            VAR_21;

          Quantum
            *VAR_22;

          VAR_22=GetCacheViewAuthenticPixels(VAR_5,VAR_8,VAR_9,1,1,VAR_4);
          if (VAR_22 == (Quantum *) NULL)
            break;
          GetFillColor(VAR_2,VAR_8,VAR_9,&VAR_21,VAR_4);
          SetPixelAlpha(VAR_1,ClampToQuantum(VAR_21.alpha),VAR_22);
          VAR_6&=SyncCacheViewAuthenticPixels(VAR_5,VAR_4);
          break;
        }
        case VAR_23:
        {
          PixelInfo
            VAR_21,
            VAR_24;

          VAR_6&=GetOneCacheViewVirtualPixelInfo(VAR_5,VAR_8,VAR_9,&VAR_24,
            VAR_4);
          GetPixelInfo(VAR_1,&VAR_21);
          for (VAR_9=0; VAR_9 < (ssize_t) VAR_1->rows; VAR_9++)
          {
            Quantum
              *magick_restrict VAR_22;

            VAR_22=GetCacheViewAuthenticPixels(VAR_5,0,VAR_9,VAR_1->columns,1,
              VAR_4);
            if (VAR_22 == (Quantum *) NULL)
              break;
            for (VAR_8=0; VAR_8 < (ssize_t) VAR_1->columns; VAR_8++)
            {
              GetPixelInfoPixel(VAR_1,VAR_22,&VAR_21);
              if (IsFuzzyEquivalencePixelInfo(&VAR_21,&VAR_24) == VAR_10)
                {
                  VAR_22+=GetPixelChannels(VAR_1);
                  continue;
                }
              GetFillColor(VAR_2,VAR_8,VAR_9,&VAR_21,VAR_4);
              SetPixelAlpha(VAR_1,ClampToQuantum(VAR_21.alpha),VAR_22);
              VAR_22+=GetPixelChannels(VAR_1);
            }
            VAR_6&=SyncCacheViewAuthenticPixels(VAR_5,VAR_4);
            if (VAR_6 == VAR_10)
              break;
          }
          break;
        }
        case VAR_25:
        case VAR_26:
        {
          ChannelType
            VAR_27;

          PixelInfo
            VAR_24;

          VAR_6&=GetOneVirtualPixelInfo(VAR_1,VAR_28,VAR_8,VAR_9,
            &VAR_24,VAR_4);
          if (VAR_3->method == VAR_26)
            {
              VAR_24.red=(double) VAR_2->border_color.red;
              VAR_24.green=(double) VAR_2->border_color.green;
              VAR_24.blue=(double) VAR_2->border_color.blue;
            }
          VAR_27=SetImageChannelMask(VAR_1,VAR_29);
          VAR_6&=FloodfillPaintImage(VAR_1,VAR_2,&VAR_24,VAR_8,VAR_9,
            VAR_3->method == VAR_25 ? VAR_10 :
            VAR_12,VAR_4);
          (void) SetImageChannelMask(VAR_1,VAR_27);
          break;
        }
        case VAR_30:
        {
          PixelInfo
            VAR_21;

          for (VAR_9=0; VAR_9 < (ssize_t) VAR_1->rows; VAR_9++)
          {
            Quantum
              *magick_restrict VAR_22;

            VAR_22=GetCacheViewAuthenticPixels(VAR_5,0,VAR_9,VAR_1->columns,1,
              VAR_4);
            if (VAR_22 == (Quantum *) NULL)
              break;
            for (VAR_8=0; VAR_8 < (ssize_t) VAR_1->columns; VAR_8++)
            {
              GetFillColor(VAR_2,VAR_8,VAR_9,&VAR_21,VAR_4);
              SetPixelAlpha(VAR_1,ClampToQuantum(VAR_21.alpha),VAR_22);
              VAR_22+=GetPixelChannels(VAR_1);
            }
            VAR_6&=SyncCacheViewAuthenticPixels(VAR_5,VAR_4);
            if (VAR_6 == VAR_10)
              break;
          }
          break;
        }
      }
      break;
    }
    case VAR_31:
    {
      switch (VAR_3->method)
      {
        case VAR_20:
        default:
        {
          PixelInfo
            VAR_21;

          Quantum
            *VAR_22;

          VAR_22=GetCacheViewAuthenticPixels(VAR_5,VAR_8,VAR_9,1,1,VAR_4);
          if (VAR_22 == (Quantum *) NULL)
            break;
          GetPixelInfo(VAR_1,&VAR_21);
          GetFillColor(VAR_2,VAR_8,VAR_9,&VAR_21,VAR_4);
          SetPixelViaPixelInfo(VAR_1,&VAR_21,VAR_22);
          VAR_6&=SyncCacheViewAuthenticPixels(VAR_5,VAR_4);
          break;
        }
        case VAR_23:
        {
          PixelInfo
            VAR_21,
            VAR_24;

          VAR_6&=GetOneCacheViewVirtualPixelInfo(VAR_5,VAR_8,VAR_9,&VAR_24,
            VAR_4);
          for (VAR_9=0; VAR_9 < (ssize_t) VAR_1->rows; VAR_9++)
          {
            Quantum
              *magick_restrict VAR_22;

            VAR_22=GetCacheViewAuthenticPixels(VAR_5,0,VAR_9,VAR_1->columns,1,
              VAR_4);
            if (VAR_22 == (Quantum *) NULL)
              break;
            for (VAR_8=0; VAR_8 < (ssize_t) VAR_1->columns; VAR_8++)
            {
              GetPixelInfoPixel(VAR_1,VAR_22,&VAR_21);
              if (IsFuzzyEquivalencePixelInfo(&VAR_21,&VAR_24) == VAR_10)
                {
                  VAR_22+=GetPixelChannels(VAR_1);
                  continue;
                }
              GetFillColor(VAR_2,VAR_8,VAR_9,&VAR_21,VAR_4);
              SetPixelViaPixelInfo(VAR_1,&VAR_21,VAR_22);
              VAR_22+=GetPixelChannels(VAR_1);
            }
            VAR_6&=SyncCacheViewAuthenticPixels(VAR_5,VAR_4);
            if (VAR_6 == VAR_10)
              break;
          }
          break;
        }
        case VAR_25:
        case VAR_26:
        {
          PixelInfo
            VAR_24;

          VAR_6&=GetOneVirtualPixelInfo(VAR_1,VAR_28,VAR_8,VAR_9,
            &VAR_24,VAR_4);
          if (VAR_3->method == VAR_26)
            {
              VAR_24.red=(double) VAR_2->border_color.red;
              VAR_24.green=(double) VAR_2->border_color.green;
              VAR_24.blue=(double) VAR_2->border_color.blue;
            }
          VAR_6&=FloodfillPaintImage(VAR_1,VAR_2,&VAR_24,VAR_8,VAR_9,
            VAR_3->method == VAR_25 ? VAR_10 :
            VAR_12,VAR_4);
          break;
        }
        case VAR_30:
        {
          PixelInfo
            VAR_21;

          GetPixelInfo(VAR_1,&VAR_21);
          for (VAR_9=0; VAR_9 < (ssize_t) VAR_1->rows; VAR_9++)
          {
            Quantum
              *magick_restrict VAR_22;

            VAR_22=GetCacheViewAuthenticPixels(VAR_5,0,VAR_9,VAR_1->columns,1,
              VAR_4);
            if (VAR_22 == (Quantum *) NULL)
              break;
            for (VAR_8=0; VAR_8 < (ssize_t) VAR_1->columns; VAR_8++)
            {
              GetFillColor(VAR_2,VAR_8,VAR_9,&VAR_21,VAR_4);
              SetPixelViaPixelInfo(VAR_1,&VAR_21,VAR_22);
              VAR_22+=GetPixelChannels(VAR_1);
            }
            VAR_6&=SyncCacheViewAuthenticPixels(VAR_5,VAR_4);
            if (VAR_6 == VAR_10)
              break;
          }
          break;
        }
      }
      break;
    }
    case VAR_32:
    {
      AffineMatrix
        VAR_33;

      char
        VAR_34[VAR_35];

      Image
        *VAR_36,
        *VAR_37;

      ImageInfo
        *VAR_38;

      RectangleInfo
        VAR_39;

      ssize_t
        VAR_40,
        VAR_41;

      if (VAR_3->text == (char *) NULL)
        break;
      VAR_38=AcquireImageInfo();
      VAR_38->recursion_depth=VAR_2->image_info->recursion_depth;
      VAR_37=(Image *) NULL;
      if (LocaleNCompare(VAR_3->text,""data:"",5) == 0)
        VAR_37=ReadInlineImage(VAR_38,VAR_3->text,
          VAR_4);
      else
        if (*VAR_3->text != '\0')
          {
            MagickBooleanType
              VAR_42;

            struct stat
              VAR_43;

            /* COMMENT_0 */
                                   
              
            (void) CopyMagickString(VAR_38->filename,VAR_3->text,
              VAR_35);
            (void) SetImageInfo(VAR_38,1,VAR_4);
            (void) CopyMagickString(VAR_38->filename,VAR_3->text,
              VAR_35);
            if (VAR_38->size != (char *) NULL)
              VAR_38->size=DestroyString(VAR_38->size);
            if (VAR_38->extract != (char *) NULL)
              VAR_38->extract=DestroyString(VAR_38->extract);
            VAR_42=GetPathAttributes(VAR_38->filename,&VAR_43);
            if (VAR_42 != VAR_10)
              {
                if (S_ISCHR(VAR_43.st_mode) == 0)
                  VAR_37=ReadImage(VAR_38,VAR_4);
                else
                  (void) ThrowMagickException(VAR_4,GetMagickModule(),
                    VAR_44,""UnableToOpenFile"",""`%s'"",
                      VAR_38->filename);
              }
            else
              if ((LocaleCompare(VAR_38->magick,""ftp"") != 0) &&
                  (LocaleCompare(VAR_38->magick,""http"") != 0) &&
                  (LocaleCompare(VAR_38->magick,""https"") != 0))
                VAR_37=ReadImage(VAR_38,VAR_4);
              else
                (void) ThrowMagickException(VAR_4,GetMagickModule(),
                  VAR_44,""UnableToOpenFile"",""`%s'"",VAR_38->filename);
          }
      VAR_38=DestroyImageInfo(VAR_38);
      if (VAR_37 == (Image *) NULL)
        {
          VAR_6=VAR_10;
          break;
        }
      VAR_36=RemoveFirstImageFromList(&VAR_37);
      VAR_37=DestroyImageList(VAR_37);
      (void) SetImageProgressMonitor(VAR_36,(MagickProgressMonitor)
        NULL,(void *) NULL);
      VAR_40=CastDoubleToLong(ceil(VAR_3[1].point.x-0.5));
      VAR_41=CastDoubleToLong(ceil(VAR_3[1].point.y-0.5));
      if (((VAR_40 != 0L) && (VAR_40 != (ssize_t) VAR_36->columns)) ||
          ((VAR_41 != 0L) && (VAR_41 != (ssize_t) VAR_36->rows)))
        {
          /* COMMENT_3 */
                         
            
          (void) FormatLocaleString(VAR_34,VAR_35,
            ""%gx%g!"",VAR_3[1].point.x,VAR_3[1].point.y);
          VAR_36->filter=VAR_1->filter;
          VAR_6&=TransformImage(&VAR_36,(char *) NULL,
            VAR_34,VAR_4);
        }
      if (VAR_36->alpha_trait == VAR_18)
        VAR_6&=SetImageAlphaChannel(VAR_36,VAR_19,
          VAR_4);
      if (VAR_2->alpha != VAR_45)
        VAR_6&=SetImageAlpha(VAR_36,VAR_2->alpha,VAR_4);
      SetGeometry(VAR_1,&VAR_39);
      VAR_1->gravity=VAR_2->gravity;
      VAR_39.x=VAR_8;
      VAR_39.y=VAR_9;
      (void) FormatLocaleString(VAR_34,VAR_35,
        ""%.20gx%.20g%+.20g%+.20g"",(double) VAR_36->columns,(double)
        VAR_36->rows,(double) VAR_39.x,(double) VAR_39.y);
      (void) ParseGravityGeometry(VAR_1,VAR_34,&VAR_39,VAR_4);
      VAR_33=VAR_2->affine;
      VAR_33.tx=(double) VAR_39.x;
      VAR_33.ty=(double) VAR_39.y;
      VAR_36->interpolate=VAR_1->interpolate;
      if ((VAR_2->compose == VAR_46) ||
          (VAR_2->compose == VAR_47))
        VAR_6&=DrawAffineImage(VAR_1,VAR_36,&VAR_33,VAR_4);
      else
        VAR_6&=CompositeImage(VAR_1,VAR_36,VAR_2->compose,
          VAR_12,VAR_39.x,VAR_39.y,VAR_4);
      VAR_36=DestroyImage(VAR_36);
      break;
    }
    case VAR_48:
    {
      PixelInfo
        VAR_49;

      Quantum
        *VAR_22;

      if ((VAR_9 < 0) || (VAR_9 >= (ssize_t) VAR_1->rows))
        break;
      if ((VAR_8 < 0) || (VAR_8 >= (ssize_t) VAR_1->columns))
        break;
      VAR_22=GetCacheViewAuthenticPixels(VAR_5,VAR_8,VAR_9,1,1,VAR_4);
      if (VAR_22 == (Quantum *) NULL)
        break;
      GetFillColor(VAR_2,VAR_8,VAR_9,&VAR_49,VAR_4);
      CompositePixelOver(VAR_1,&VAR_49,(double) VAR_49.alpha,VAR_22,(double)
        GetPixelAlpha(VAR_1,VAR_22),VAR_22);
      VAR_6&=SyncCacheViewAuthenticPixels(VAR_5,VAR_4);
      break;
    }
    case VAR_50:
    {
      char
        VAR_39[VAR_35];

      DrawInfo
        *VAR_38;

      if (VAR_3->text == (char *) NULL)
        break;
      VAR_38=CloneDrawInfo((ImageInfo *) NULL,VAR_2);
      (void) CloneString(&VAR_38->text,VAR_3->text);
      (void) FormatLocaleString(VAR_39,VAR_35,""%+f%+f"",
        VAR_3->point.x,VAR_3->point.y);
      (void) CloneString(&VAR_38->geometry,VAR_39);
      VAR_6&=AnnotateImage(VAR_1,VAR_38,VAR_4);
      VAR_38=DestroyDrawInfo(VAR_38);
      break;
    }
    default:
    {
      double
        VAR_51,
        VAR_52;

      DrawInfo
        *VAR_38;

      if (IsEventLogging() != VAR_10)
        LogPrimitiveInfo(VAR_3);
      VAR_52=ExpandAffine(&VAR_2->affine);
      if ((VAR_2->dash_pattern != (double *) NULL) &&
          (fabs(VAR_2->dash_pattern[0]) >= VAR_53) &&
          (fabs(VAR_52*VAR_2->stroke_width) >= VAR_53) &&
          (VAR_2->stroke.alpha != (Quantum) VAR_54))
        {
          /* COMMENT_6 */
                              
            
          VAR_38=CloneDrawInfo((ImageInfo *) NULL,VAR_2);
          VAR_38->stroke_width=0.0;
          VAR_38->stroke.alpha=(MagickRealType) VAR_54;
          VAR_6&=DrawPolygonPrimitive(VAR_1,VAR_38,VAR_3,
            VAR_4);
          VAR_38=DestroyDrawInfo(VAR_38);
          if (VAR_6 != VAR_10)
            VAR_6&=DrawDashPolygon(VAR_2,VAR_3,VAR_1,VAR_4);
          break;
        }
      VAR_51=ExpandAffine(&VAR_2->affine)*VAR_2->stroke_width/2.0;
      if ((VAR_51 > 1.0) &&
          ((VAR_2->stroke.alpha != (Quantum) VAR_54) ||
           (VAR_2->stroke_pattern != (Image *) NULL)))
        {
          double
            VAR_55,
            VAR_56;

          MagickBooleanType
            VAR_57;

          /* COMMENT_9 */
                                                                   
            
          VAR_57=VAR_3[0].closed_subpath;
          VAR_7=(ssize_t) VAR_3[0].coordinates;
          VAR_55=fabs(VAR_3[VAR_7-1].point.x-VAR_3[0].point.x);
          VAR_56=fabs(VAR_3[VAR_7-1].point.y-VAR_3[0].point.y);
          if ((VAR_55 < VAR_53) && (VAR_56 < VAR_53))
            VAR_57=VAR_12;
          if ((((VAR_2->linecap == VAR_58) ||
                (VAR_57 != VAR_10)) &&
               (VAR_2->linejoin == VAR_59)) ||
               (VAR_3[VAR_7].primitive != VAR_60))
            {
              VAR_6&=DrawPolygonPrimitive(VAR_1,VAR_2,VAR_3,
                VAR_4);
              break;
            }
          VAR_38=CloneDrawInfo((ImageInfo *) NULL,VAR_2);
          VAR_38->stroke_width=0.0;
          VAR_38->stroke.alpha=(MagickRealType) VAR_54;
          VAR_6&=DrawPolygonPrimitive(VAR_1,VAR_38,VAR_3,
            VAR_4);
          VAR_38=DestroyDrawInfo(VAR_38);
          if (VAR_6 != VAR_10)
            VAR_6&=DrawStrokePolygon(VAR_1,VAR_2,VAR_3,VAR_4);
          break;
        }
      VAR_6&=DrawPolygonPrimitive(VAR_1,VAR_2,VAR_3,VAR_4);
      break;
    }
  }
  VAR_5=DestroyCacheView(VAR_5);
  if (VAR_2->compliance == VAR_14)
    {
      VAR_6&=SetImageMask(VAR_1,VAR_15,(Image *) NULL,VAR_4);
      VAR_6&=SetImageMask(VAR_1,VAR_16,(Image *) NULL,VAR_4);
    }
  if (VAR_2->debug != VAR_10)
    (void) LogMagickEvent(VAR_11,GetMagickModule(),""  end draw-primitive"");
  return(VAR_6 != 0 ? VAR_12 : VAR_10);
}",,"--- func_before
+++ func_after
@@ -283,7 +283,8 @@
 
       if (primitive_info->text == (char *) NULL)
         break;
-      clone_info=CloneImageInfo(draw_info->image_info);
+      clone_info=AcquireImageInfo();
+      clone_info->recursion_depth=draw_info->image_info->recursion_depth;
       composite_images=(Image *) NULL;
       if (LocaleNCompare(primitive_info->text,""data:"",5) == 0)
         composite_images=ReadInlineImage(clone_info,primitive_info->text,","{'deleted_lines': ['      clone_info=CloneImageInfo(draw_info->image_info);'], 'added_lines': ['      clone_info=AcquireImageInfo();', '      clone_info->recursion_depth=draw_info->image_info->recursion_depth;']}",True,"A vulnerability was discovered in ImageMagick where a specially created SVG file loads itself and causes a segmentation fault. This flaw allows a remote attacker to pass a specially crafted SVG file that leads to a segmentation fault, generating many trash files in ""/tmp,"" resulting in a denial of service. When ImageMagick crashes, it generates a lot of trash files. These trash files can be large if the SVG file contains many render actions. In a denial of service attack, if a remote attacker uploads an SVG file of size t, ImageMagick generates files of size 103*t. If an attacker uploads a 100M SVG, the server will generate about 10G.",5.5,MEDIUM,1,test,2023-03-06T20:26:32Z,4
CVE-2023-31669,['CWE-116'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,WebAssembly/wabt,"Improve lexing and parsing of invalid annotations (again)

This adds a bounds-check to WastLexer::GetText to handle the case when
the offset is earlier than token_start (e.g. because GetStringToken
found a newline in the string and reset token_start to point at it).

Also revises GetIdToken -> GetIdChars to stop skipping the initial char
in an annotation delimiter, which is an idchar+ but not an id token.

Also fixes the WastParser to handle EOF when reading for the end of an
annotation, both for code metadata annotations and other kinds.
Previously this produced an infinite loop (but only with
--enable-annotations).

Fixes #2165",44491a4b0fdb2d2bd87a151fd169da3343954edd,https://github.com/WebAssembly/wabt/commit/44491a4b0fdb2d2bd87a151fd169da3343954edd,src/wast-parser.cc,WastParser::ParseCodeMetadataAnnotation,"Result WastParser::ParseCodeMetadataAnnotation(ExprList* exprs) {
WABT_TRACE(ParseCodeMetadataAnnotation);
Token tk = Consume();
std::string_view name = tk.text();
name.remove_prefix(sizeof(""metadata.code."") - 1);
std::string data_text;
CHECK_RESULT(ParseQuotedText(&data_text, false));
std::vector<uint8_t> data(data_text.begin(), data_text.end());
exprs->push_back(std::make_unique<CodeMetadataExpr>(name, std::move(data)));
TokenType rpar = Peek();
WABT_USE(rpar);
assert(rpar == TokenType::Rpar);
Consume();
return Result::Ok;
}","Result WastParser::ParseCodeMetadataAnnotation(ExprList* VAR_0) {
WABT_TRACE(VAR_1);
Token VAR_2 = Consume();
std::string_view VAR_3 = VAR_2.text();
VAR_3.remove_prefix(sizeof(""metadata.code."") - 1);
std::string VAR_4;
CHECK_RESULT(ParseQuotedText(&VAR_4, false));
std::vector<uint8_t> VAR_5(VAR_4.begin(), VAR_4.end());
VAR_0->push_back(std::VAR_6<CodeMetadataExpr>(VAR_3, std::move(VAR_5)));
TokenType VAR_7 = Peek();
WABT_USE(VAR_7);
assert(VAR_7 == TokenType::Rpar);
Consume();
return Result::Ok;
}",WebAssembly/wabt/44491a4b0fdb2d2bd87a151fd169da3343954edd/wast-parser.cc/vul/before/0.json,"Result WastParser::ParseCodeMetadataAnnotation(ExprList* exprs) {
  WABT_TRACE(ParseCodeMetadataAnnotation);
  Token tk = Consume();
  std::string_view name = tk.text();
  name.remove_prefix(sizeof(""metadata.code."") - 1);
  std::string data_text;
  CHECK_RESULT(ParseQuotedText(&data_text, false));
  std::vector<uint8_t> data(data_text.begin(), data_text.end());
  exprs->push_back(std::make_unique<CodeMetadataExpr>(name, std::move(data)));
  EXPECT(Rpar);
  return Result::Ok;
}","Result WastParser::ParseCodeMetadataAnnotation(ExprList* VAR_0) {
  WABT_TRACE(VAR_1);
  Token VAR_2 = Consume();
  std::string_view VAR_3 = VAR_2.text();
  VAR_3.remove_prefix(sizeof(""metadata.code."") - 1);
  std::string VAR_4;
  CHECK_RESULT(ParseQuotedText(&VAR_4, false));
  std::vector<uint8_t> VAR_5(VAR_4.begin(), VAR_4.end());
  VAR_0->push_back(std::VAR_6<CodeMetadataExpr>(VAR_3, std::move(VAR_5)));
  EXPECT(VAR_7);
  return Result::Ok;
}",WebAssembly/wabt/44491a4b0fdb2d2bd87a151fd169da3343954edd/wast-parser.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,9 +7,6 @@
   CHECK_RESULT(ParseQuotedText(&data_text, false));
   std::vector<uint8_t> data(data_text.begin(), data_text.end());
   exprs->push_back(std::make_unique<CodeMetadataExpr>(name, std::move(data)));
-  TokenType rpar = Peek();
-  WABT_USE(rpar);
-  assert(rpar == TokenType::Rpar);
-  Consume();
+  EXPECT(Rpar);
   return Result::Ok;
 }","{'deleted_lines': ['  TokenType rpar = Peek();', '  WABT_USE(rpar);', '  assert(rpar == TokenType::Rpar);', '  Consume();'], 'added_lines': ['  EXPECT(Rpar);']}",True,"WebAssembly wat2wasm v1.0.32 allows attackers to cause a libc++abi.dylib crash by putting '@' before a quote ("").",5.5,MEDIUM,1,test,2023-03-10T07:44:58Z,4
CVE-2023-31669,['CWE-116'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,WebAssembly/wabt,"Improve lexing and parsing of invalid annotations (again)

This adds a bounds-check to WastLexer::GetText to handle the case when
the offset is earlier than token_start (e.g. because GetStringToken
found a newline in the string and reset token_start to point at it).

Also revises GetIdToken -> GetIdChars to stop skipping the initial char
in an annotation delimiter, which is an idchar+ but not an id token.

Also fixes the WastParser to handle EOF when reading for the end of an
annotation, both for code metadata annotations and other kinds.
Previously this produced an infinite loop (but only with
--enable-annotations).

Fixes #2165",44491a4b0fdb2d2bd87a151fd169da3343954edd,https://github.com/WebAssembly/wabt/commit/44491a4b0fdb2d2bd87a151fd169da3343954edd,src/wast-lexer.cc,WastLexer::GetText,"std::string_view WastLexer::GetText(size_t offset) {
return std::string_view(token_start_ + offset,
(cursor_ - token_start_) - offset);
}","std::string_view WastLexer::GetText(size_t VAR_0) {
return std::string_view(VAR_1 + VAR_0,
(VAR_2 - VAR_1) - VAR_0);
}",WebAssembly/wabt/44491a4b0fdb2d2bd87a151fd169da3343954edd/wast-lexer.cc/vul/before/1.json,"std::string_view WastLexer::GetText(size_t offset) {
  // Bounds checks are necessary because token_start may have been moved
  // (e.g. if GetStringToken found a newline and reset token_start to
  // point at it).

  if (token_start_ + offset >= buffer_end_)
    return {};

  if (cursor_ <= token_start_ + offset)
    return {};

  return std::string_view(token_start_ + offset,
                          (cursor_ - token_start_) - offset);
}","std::string_view WastLexer::GetText(size_t VAR_0) {
  /* COMMENT_0 */
  /* COMMENT_1 */
  /* COMMENT_2 */

  if (VAR_1 + VAR_0 >= VAR_2)
    return {};

  if (VAR_3 <= VAR_1 + VAR_0)
    return {};

  return std::string_view(VAR_1 + VAR_0,
                          (VAR_3 - VAR_1) - VAR_0);
}",WebAssembly/wabt/44491a4b0fdb2d2bd87a151fd169da3343954edd/wast-lexer.cc/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,4 +1,14 @@
 std::string_view WastLexer::GetText(size_t offset) {
+  // Bounds checks are necessary because token_start may have been moved
+  // (e.g. if GetStringToken found a newline and reset token_start to
+  // point at it).
+
+  if (token_start_ + offset >= buffer_end_)
+    return {};
+
+  if (cursor_ <= token_start_ + offset)
+    return {};
+
   return std::string_view(token_start_ + offset,
                           (cursor_ - token_start_) - offset);
 }","{'deleted_lines': [], 'added_lines': ['  // Bounds checks are necessary because token_start may have been moved', '  // (e.g. if GetStringToken found a newline and reset token_start to', '  // point at it).', '', '  if (token_start_ + offset >= buffer_end_)', '    return {};', '', '  if (cursor_ <= token_start_ + offset)', '    return {};', '']}",True,"WebAssembly wat2wasm v1.0.32 allows attackers to cause a libc++abi.dylib crash by putting '@' before a quote ("").",5.5,MEDIUM,1,test,2023-03-10T07:44:58Z,4
CVE-2023-31669,['CWE-116'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,WebAssembly/wabt,"Improve lexing and parsing of invalid annotations (again)

This adds a bounds-check to WastLexer::GetText to handle the case when
the offset is earlier than token_start (e.g. because GetStringToken
found a newline in the string and reset token_start to point at it).

Also revises GetIdToken -> GetIdChars to stop skipping the initial char
in an annotation delimiter, which is an idchar+ but not an id token.

Also fixes the WastParser to handle EOF when reading for the end of an
annotation, both for code metadata annotations and other kinds.
Previously this produced an infinite loop (but only with
--enable-annotations).

Fixes #2165",44491a4b0fdb2d2bd87a151fd169da3343954edd,https://github.com/WebAssembly/wabt/commit/44491a4b0fdb2d2bd87a151fd169da3343954edd,src/wast-parser.cc,WastParser::Peek,"TokenType WastParser::Peek(size_t n) {
while (tokens_.size() <= n) {
Token cur = lexer_->GetToken();
if (cur.token_type() != TokenType::LparAnn) {
tokens_.push_back(cur);
} else {
if (!options_->features.annotations_enabled()) {
Error(cur.loc, ""annotations not enabled: %s"", cur.to_string().c_str());
tokens_.push_back(Token(cur.loc, TokenType::Invalid));
continue;
}
if (options_->features.code_metadata_enabled() &&
cur.text().find(""metadata.code."") == 0) {
tokens_.push_back(cur);
continue;
}
int indent = 1;
while (indent > 0) {
cur = lexer_->GetToken();
switch (cur.token_type()) {
case TokenType::Lpar:
case TokenType::LparAnn:
indent++;
break;
case TokenType::Rpar:
indent--;
break;
default:
break;
}
}
}
}
return tokens_.at(n).token_type();
}","TokenType WastParser::Peek(size_t VAR_0) {
while (VAR_1.size() <= VAR_0) {
Token VAR_2 = VAR_3->GetToken();
if (VAR_2.token_type() != TokenType::LparAnn) {
VAR_1.push_back(VAR_2);
} else {
if (!VAR_4->features.annotations_enabled()) {
Error(VAR_2.loc, ""annotations not enabled: %s"", VAR_2.to_string().c_str());
VAR_1.push_back(Token(VAR_2.loc, TokenType::Invalid));
continue;
}
if (VAR_4->features.code_metadata_enabled() &&
VAR_2.text().find(""metadata.code."") == 0) {
VAR_1.push_back(VAR_2);
continue;
}
int VAR_5 = 1;
while (VAR_5 > 0) {
VAR_2 = VAR_3->GetToken();
switch (VAR_2.token_type()) {
case TokenType::Lpar:
case TokenType::LparAnn:
VAR_5++;
break;
case TokenType::Rpar:
VAR_5--;
break;
default:
break;
}
}
}
}
return VAR_1.at(VAR_0).token_type();
}",WebAssembly/wabt/44491a4b0fdb2d2bd87a151fd169da3343954edd/wast-parser.cc/vul/before/1.json,"TokenType WastParser::Peek(size_t n) {
  while (tokens_.size() <= n) {
    Token cur = lexer_->GetToken();
    if (cur.token_type() != TokenType::LparAnn) {
      tokens_.push_back(cur);
    } else {
      // Custom annotation. For now, discard until matching Rpar, unless it is
      // a code metadata annotation. In that case, we know how to parse it.
      if (!options_->features.annotations_enabled()) {
        Error(cur.loc, ""annotations not enabled: %s"", cur.to_string().c_str());
        tokens_.push_back(Token(cur.loc, TokenType::Invalid));
        continue;
      }
      if (options_->features.code_metadata_enabled() &&
          cur.text().find(""metadata.code."") == 0) {
        tokens_.push_back(cur);
        continue;
      }
      int indent = 1;
      while (indent > 0) {
        cur = lexer_->GetToken();
        switch (cur.token_type()) {
          case TokenType::Lpar:
          case TokenType::LparAnn:
            indent++;
            break;

          case TokenType::Rpar:
            indent--;
            break;

          case TokenType::Eof:
            indent = 0;
            Error(cur.loc, ""unterminated annotation"");
            break;

          default:
            break;
        }
      }
    }
  }
  return tokens_.at(n).token_type();
}","TokenType WastParser::Peek(size_t VAR_0) {
  while (VAR_1.size() <= VAR_0) {
    Token VAR_2 = VAR_3->GetToken();
    if (VAR_2.token_type() != TokenType::LparAnn) {
      VAR_1.push_back(VAR_2);
    } else {
      /* COMMENT_0 */
      /* COMMENT_1 */
      if (!VAR_4->features.annotations_enabled()) {
        Error(VAR_2.loc, ""annotations not enabled: %s"", VAR_2.to_string().c_str());
        VAR_1.push_back(Token(VAR_2.loc, TokenType::Invalid));
        continue;
      }
      if (VAR_4->features.code_metadata_enabled() &&
          VAR_2.text().find(""metadata.code."") == 0) {
        VAR_1.push_back(VAR_2);
        continue;
      }
      int VAR_5 = 1;
      while (VAR_5 > 0) {
        VAR_2 = VAR_3->GetToken();
        switch (VAR_2.token_type()) {
          case TokenType::Lpar:
          case TokenType::LparAnn:
            VAR_5++;
            break;

          case TokenType::Rpar:
            VAR_5--;
            break;

          case TokenType::Eof:
            VAR_5 = 0;
            Error(VAR_2.loc, ""unterminated annotation"");
            break;

          default:
            break;
        }
      }
    }
  }
  return VAR_1.at(VAR_0).token_type();
}",WebAssembly/wabt/44491a4b0fdb2d2bd87a151fd169da3343954edd/wast-parser.cc/vul/after/1.json,"--- func_before
+++ func_after
@@ -29,6 +29,11 @@
             indent--;
             break;
 
+          case TokenType::Eof:
+            indent = 0;
+            Error(cur.loc, ""unterminated annotation"");
+            break;
+
           default:
             break;
         }","{'deleted_lines': [], 'added_lines': ['          case TokenType::Eof:', '            indent = 0;', '            Error(cur.loc, ""unterminated annotation"");', '            break;', '']}",True,"WebAssembly wat2wasm v1.0.32 allows attackers to cause a libc++abi.dylib crash by putting '@' before a quote ("").",5.5,MEDIUM,1,test,2023-03-10T07:44:58Z,4
CVE-2023-31669,['CWE-116'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,WebAssembly/wabt,"Improve lexing and parsing of invalid annotations (again)

This adds a bounds-check to WastLexer::GetText to handle the case when
the offset is earlier than token_start (e.g. because GetStringToken
found a newline in the string and reset token_start to point at it).

Also revises GetIdToken -> GetIdChars to stop skipping the initial char
in an annotation delimiter, which is an idchar+ but not an id token.

Also fixes the WastParser to handle EOF when reading for the end of an
annotation, both for code metadata annotations and other kinds.
Previously this produced an infinite loop (but only with
--enable-annotations).

Fixes #2165",44491a4b0fdb2d2bd87a151fd169da3343954edd,https://github.com/WebAssembly/wabt/commit/44491a4b0fdb2d2bd87a151fd169da3343954edd,src/wast-lexer.cc,WastLexer::GetToken,"Token WastLexer::GetToken() {
while (true) {
token_start_ = cursor_;
switch (PeekChar()) {
case kEof:
return BareToken(TokenType::Eof);
case '(':
if (MatchString(""(;"")) {
if (ReadBlockComment()) {
continue;
}
return BareToken(TokenType::Eof);
} else if (MatchString(""(@"")) {
GetIdToken();
return TextToken(TokenType::LparAnn, 2);
} else {
ReadChar();
return BareToken(TokenType::Lpar);
}
break;
case ')':
ReadChar();
return BareToken(TokenType::Rpar);
case ';':
if (MatchString("";;"")) {
if (ReadLineComment()) {
continue;
}
return BareToken(TokenType::Eof);
} else {
ReadChar();
ERROR(""unexpected char"");
continue;
}
break;
case ' ':
case '\t':
case '\r':
case '\n':
ReadWhitespace();
continue;
case '""':
return GetStringToken();
case '+':
case '-':
ReadChar();
switch (PeekChar()) {
case 'i':
return GetInfToken();
case 'n':
return GetNanToken();
case '0':
return MatchString(""0x"") ? GetHexNumberToken(TokenType::Int)
: GetNumberToken(TokenType::Int);
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
return GetNumberToken(TokenType::Int);
default:
return GetReservedToken();
}
break;
case '0':
return MatchString(""0x"") ? GetHexNumberToken(TokenType::Nat)
: GetNumberToken(TokenType::Nat);
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
return GetNumberToken(TokenType::Nat);
case '$':
return GetIdToken();
case 'a':
return GetNameEqNumToken(""align="", TokenType::AlignEqNat);
case 'i':
return GetInfToken();
case 'n':
return GetNanToken();
case 'o':
return GetNameEqNumToken(""offset="", TokenType::OffsetEqNat);
default:
if (IsKeyword(PeekChar())) {
return GetKeywordToken();
} else if (IsIdChar(PeekChar())) {
return GetReservedToken();
} else {
ReadChar();
ERROR(""unexpected char"");
continue;
}
}
}
}","Token WastLexer::GetToken() {
while (true) {
VAR_0 = VAR_1;
switch (PeekChar()) {
case VAR_2:
return BareToken(TokenType::Eof);
case '(':
if (MatchString(""(;"")) {
if (ReadBlockComment()) {
continue;
}
return BareToken(TokenType::Eof);
} else if (MatchString(""(@"")) {
GetIdToken();
return TextToken(TokenType::LparAnn, 2);
} else {
ReadChar();
return BareToken(TokenType::Lpar);
}
break;
case ')':
ReadChar();
return BareToken(TokenType::Rpar);
case ';':
if (MatchString("";;"")) {
if (ReadLineComment()) {
continue;
}
return BareToken(TokenType::Eof);
} else {
ReadChar();
ERROR(""unexpected char"");
continue;
}
break;
case ' ':
case '\t':
case '\r':
case '\n':
ReadWhitespace();
continue;
case '""':
return GetStringToken();
case '+':
case '-':
ReadChar();
switch (PeekChar()) {
case 'i':
return GetInfToken();
case 'n':
return GetNanToken();
case '0':
return MatchString(""0x"") ? GetHexNumberToken(TokenType::Int)
: GetNumberToken(TokenType::Int);
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
return GetNumberToken(TokenType::Int);
default:
return GetReservedToken();
}
break;
case '0':
return MatchString(""0x"") ? GetHexNumberToken(TokenType::Nat)
: GetNumberToken(TokenType::Nat);
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
return GetNumberToken(TokenType::Nat);
case '$':
return GetIdToken();
case 'a':
return GetNameEqNumToken(""align="", TokenType::AlignEqNat);
case 'i':
return GetInfToken();
case 'n':
return GetNanToken();
case 'o':
return GetNameEqNumToken(""offset="", TokenType::OffsetEqNat);
default:
if (IsKeyword(PeekChar())) {
return GetKeywordToken();
} else if (IsIdChar(PeekChar())) {
return GetReservedToken();
} else {
ReadChar();
ERROR(""unexpected char"");
continue;
}
}
}
}",WebAssembly/wabt/44491a4b0fdb2d2bd87a151fd169da3343954edd/wast-lexer.cc/vul/before/0.json,"Token WastLexer::GetToken() {
  while (true) {
    token_start_ = cursor_;
    switch (PeekChar()) {
      case kEof:
        return BareToken(TokenType::Eof);

      case '(':
        if (MatchString(""(;"")) {
          if (ReadBlockComment()) {
            continue;
          }
          return BareToken(TokenType::Eof);
        } else if (MatchString(""(@"")) {
          GetIdChars();
          // offset=2 to skip the ""(@"" prefix
          return TextToken(TokenType::LparAnn, 2);
        } else {
          ReadChar();
          return BareToken(TokenType::Lpar);
        }
        break;

      case ')':
        ReadChar();
        return BareToken(TokenType::Rpar);

      case ';':
        if (MatchString("";;"")) {
          if (ReadLineComment()) {
            continue;
          }
          return BareToken(TokenType::Eof);
        } else {
          ReadChar();
          ERROR(""unexpected char"");
          continue;
        }
        break;

      case ' ':
      case '\t':
      case '\r':
      case '\n':
        ReadWhitespace();
        continue;

      case '""':
        return GetStringToken();

      case '+':
      case '-':
        ReadChar();
        switch (PeekChar()) {
          case 'i':
            return GetInfToken();

          case 'n':
            return GetNanToken();

          case '0':
            return MatchString(""0x"") ? GetHexNumberToken(TokenType::Int)
                                     : GetNumberToken(TokenType::Int);
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            return GetNumberToken(TokenType::Int);

          default:
            return GetReservedToken();
        }
        break;

      case '0':
        return MatchString(""0x"") ? GetHexNumberToken(TokenType::Nat)
                                 : GetNumberToken(TokenType::Nat);

      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        return GetNumberToken(TokenType::Nat);

      case '$':
        return GetIdChars();  // Initial $ is idchar, so this produces id token

      case 'a':
        return GetNameEqNumToken(""align="", TokenType::AlignEqNat);

      case 'i':
        return GetInfToken();

      case 'n':
        return GetNanToken();

      case 'o':
        return GetNameEqNumToken(""offset="", TokenType::OffsetEqNat);

      default:
        if (IsKeyword(PeekChar())) {
          return GetKeywordToken();
        } else if (IsIdChar(PeekChar())) {
          return GetReservedToken();
        } else {
          ReadChar();
          ERROR(""unexpected char"");
          continue;
        }
    }
  }
}","Token WastLexer::GetToken() {
  while (true) {
    VAR_0 = VAR_1;
    switch (PeekChar()) {
      case VAR_2:
        return BareToken(TokenType::Eof);

      case '(':
        if (MatchString(""(;"")) {
          if (ReadBlockComment()) {
            continue;
          }
          return BareToken(TokenType::Eof);
        } else if (MatchString(""(@"")) {
          GetIdChars();
          /* COMMENT_0 */
          return TextToken(TokenType::LparAnn, 2);
        } else {
          ReadChar();
          return BareToken(TokenType::Lpar);
        }
        break;

      case ')':
        ReadChar();
        return BareToken(TokenType::Rpar);

      case ';':
        if (MatchString("";;"")) {
          if (ReadLineComment()) {
            continue;
          }
          return BareToken(TokenType::Eof);
        } else {
          ReadChar();
          ERROR(""unexpected char"");
          continue;
        }
        break;

      case ' ':
      case '\t':
      case '\r':
      case '\n':
        ReadWhitespace();
        continue;

      case '""':
        return GetStringToken();

      case '+':
      case '-':
        ReadChar();
        switch (PeekChar()) {
          case 'i':
            return GetInfToken();

          case 'n':
            return GetNanToken();

          case '0':
            return MatchString(""0x"") ? GetHexNumberToken(TokenType::Int)
                                     : GetNumberToken(TokenType::Int);
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            return GetNumberToken(TokenType::Int);

          default:
            return GetReservedToken();
        }
        break;

      case '0':
        return MatchString(""0x"") ? GetHexNumberToken(TokenType::Nat)
                                 : GetNumberToken(TokenType::Nat);

      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        return GetNumberToken(TokenType::Nat);

      case '$':
        return GetIdChars();  /* COMMENT_1 */

      case 'a':
        return GetNameEqNumToken(""align="", TokenType::AlignEqNat);

      case 'i':
        return GetInfToken();

      case 'n':
        return GetNanToken();

      case 'o':
        return GetNameEqNumToken(""offset="", TokenType::OffsetEqNat);

      default:
        if (IsKeyword(PeekChar())) {
          return GetKeywordToken();
        } else if (IsIdChar(PeekChar())) {
          return GetReservedToken();
        } else {
          ReadChar();
          ERROR(""unexpected char"");
          continue;
        }
    }
  }
}",WebAssembly/wabt/44491a4b0fdb2d2bd87a151fd169da3343954edd/wast-lexer.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,7 +12,7 @@
           }
           return BareToken(TokenType::Eof);
         } else if (MatchString(""(@"")) {
-          GetIdToken();
+          GetIdChars();
           // offset=2 to skip the ""(@"" prefix
           return TextToken(TokenType::LparAnn, 2);
         } else {
@@ -93,7 +93,7 @@
         return GetNumberToken(TokenType::Nat);
 
       case '$':
-        return GetIdToken();
+        return GetIdChars();  // Initial $ is idchar, so this produces id token
 
       case 'a':
         return GetNameEqNumToken(""align="", TokenType::AlignEqNat);","{'deleted_lines': ['          GetIdToken();', '        return GetIdToken();'], 'added_lines': ['          GetIdChars();', '        return GetIdChars();  // Initial $ is idchar, so this produces id token']}",True,"WebAssembly wat2wasm v1.0.32 allows attackers to cause a libc++abi.dylib crash by putting '@' before a quote ("").",5.5,MEDIUM,1,test,2023-03-10T07:44:58Z,4
CVE-2023-30456,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H,1,torvalds/linux,"KVM: nVMX: add missing consistency checks for CR0 and CR4

The effective values of the guest CR0 and CR4 registers may differ from
those included in the VMCS12.  In particular, disabling EPT forces
CR4.PAE=1 and disabling unrestricted guest mode forces CR0.PG=CR0.PE=1.

Therefore, checks on these bits cannot be delegated to the processor
and must be performed by KVM.

Reported-by: Reima ISHII <ishiir@g.ecc.u-tokyo.ac.jp>
Cc: stable@vger.kernel.org
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>",112e66017bff7f2837030f34c2bc19501e9212d5,https://github.com/torvalds/linux/commit/112e66017bff7f2837030f34c2bc19501e9212d5,arch/x86/kvm/vmx/nested.c,nested_vmx_check_guest_state,"static int nested_vmx_check_guest_state(struct kvm_vcpu *vcpu,
struct vmcs12 *vmcs12,
enum vm_entry_failure_code *entry_failure_code)
{
bool ia32e;
*entry_failure_code = ENTRY_FAIL_DEFAULT;
if (CC(!nested_guest_cr0_valid(vcpu, vmcs12->guest_cr0)) ||
CC(!nested_guest_cr4_valid(vcpu, vmcs12->guest_cr4)))
return -EINVAL;
if ((vmcs12->vm_entry_controls & VM_ENTRY_LOAD_DEBUG_CONTROLS) &&
CC(!kvm_dr7_valid(vmcs12->guest_dr7)))
return -EINVAL;
if ((vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_PAT) &&
CC(!kvm_pat_valid(vmcs12->guest_ia32_pat)))
return -EINVAL;
if (nested_vmx_check_vmcs_link_ptr(vcpu, vmcs12)) {
*entry_failure_code = ENTRY_FAIL_VMCS_LINK_PTR;
return -EINVAL;
}
if ((vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL) &&
CC(!kvm_valid_perf_global_ctrl(vcpu_to_pmu(vcpu),
vmcs12->guest_ia32_perf_global_ctrl)))
return -EINVAL;
if (to_vmx(vcpu)->nested.nested_run_pending &&
(vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER)) {
ia32e = (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE) != 0;
if (CC(!kvm_valid_efer(vcpu, vmcs12->guest_ia32_efer)) ||
CC(ia32e != !!(vmcs12->guest_ia32_efer & EFER_LMA)) ||
CC(((vmcs12->guest_cr0 & X86_CR0_PG) &&
ia32e != !!(vmcs12->guest_ia32_efer & EFER_LME))))
return -EINVAL;
}
if ((vmcs12->vm_entry_controls & VM_ENTRY_LOAD_BNDCFGS) &&
(CC(is_noncanonical_address(vmcs12->guest_bndcfgs & PAGE_MASK, vcpu)) ||
CC((vmcs12->guest_bndcfgs & MSR_IA32_BNDCFGS_RSVD))))
return -EINVAL;
if (nested_check_guest_non_reg_state(vmcs12))
return -EINVAL;
return 0;
}","static int nested_vmx_check_guest_state(struct kvm_vcpu *VAR_0,
struct vmcs12 *vmcs12,
enum vm_entry_failure_code *VAR_1)
{
bool VAR_2;
*VAR_1 = VAR_3;
if (CC(!nested_guest_cr0_valid(VAR_0, vmcs12->guest_cr0)) ||
CC(!nested_guest_cr4_valid(VAR_0, vmcs12->guest_cr4)))
return -VAR_4;
if ((vmcs12->vm_entry_controls & VAR_5) &&
CC(!kvm_dr7_valid(vmcs12->guest_dr7)))
return -VAR_4;
if ((vmcs12->vm_entry_controls & VAR_6) &&
CC(!kvm_pat_valid(vmcs12->guest_ia32_pat)))
return -VAR_4;
if (nested_vmx_check_vmcs_link_ptr(VAR_0, vmcs12)) {
*VAR_1 = VAR_7;
return -VAR_4;
}
if ((vmcs12->vm_entry_controls & VAR_8) &&
CC(!kvm_valid_perf_global_ctrl(vcpu_to_pmu(VAR_0),
vmcs12->guest_ia32_perf_global_ctrl)))
return -VAR_4;
if (to_vmx(VAR_0)->nested.nested_run_pending &&
(vmcs12->vm_entry_controls & VAR_9)) {
VAR_2 = (vmcs12->vm_entry_controls & VAR_10) != 0;
if (CC(!kvm_valid_efer(VAR_0, vmcs12->guest_ia32_efer)) ||
CC(VAR_2 != !!(vmcs12->guest_ia32_efer & VAR_11)) ||
CC(((vmcs12->guest_cr0 & VAR_12) &&
VAR_2 != !!(vmcs12->guest_ia32_efer & VAR_13))))
return -VAR_4;
}
if ((vmcs12->vm_entry_controls & VAR_14) &&
(CC(is_noncanonical_address(vmcs12->guest_bndcfgs & VAR_15, VAR_0)) ||
CC((vmcs12->guest_bndcfgs & VAR_16))))
return -VAR_4;
if (nested_check_guest_non_reg_state(vmcs12))
return -VAR_4;
return 0;
}",torvalds/linux/112e66017bff7f2837030f34c2bc19501e9212d5/nested.c/vul/before/0.json,"static int nested_vmx_check_guest_state(struct kvm_vcpu *vcpu,
					struct vmcs12 *vmcs12,
					enum vm_entry_failure_code *entry_failure_code)
{
	bool ia32e = !!(vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE);

	*entry_failure_code = ENTRY_FAIL_DEFAULT;

	if (CC(!nested_guest_cr0_valid(vcpu, vmcs12->guest_cr0)) ||
	    CC(!nested_guest_cr4_valid(vcpu, vmcs12->guest_cr4)))
		return -EINVAL;

	if ((vmcs12->vm_entry_controls & VM_ENTRY_LOAD_DEBUG_CONTROLS) &&
	    CC(!kvm_dr7_valid(vmcs12->guest_dr7)))
		return -EINVAL;

	if ((vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_PAT) &&
	    CC(!kvm_pat_valid(vmcs12->guest_ia32_pat)))
		return -EINVAL;

	if (nested_vmx_check_vmcs_link_ptr(vcpu, vmcs12)) {
		*entry_failure_code = ENTRY_FAIL_VMCS_LINK_PTR;
		return -EINVAL;
	}

	if ((vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL) &&
	    CC(!kvm_valid_perf_global_ctrl(vcpu_to_pmu(vcpu),
					   vmcs12->guest_ia32_perf_global_ctrl)))
		return -EINVAL;

	if (CC((vmcs12->guest_cr0 & (X86_CR0_PG | X86_CR0_PE)) == X86_CR0_PG))
		return -EINVAL;

	if (CC(ia32e && !(vmcs12->guest_cr4 & X86_CR4_PAE)) ||
	    CC(ia32e && !(vmcs12->guest_cr0 & X86_CR0_PG)))
		return -EINVAL;

	/*
	 * If the load IA32_EFER VM-entry control is 1, the following checks
	 * are performed on the field for the IA32_EFER MSR:
	 * - Bits reserved in the IA32_EFER MSR must be 0.
	 * - Bit 10 (corresponding to IA32_EFER.LMA) must equal the value of
	 *   the IA-32e mode guest VM-exit control. It must also be identical
	 *   to bit 8 (LME) if bit 31 in the CR0 field (corresponding to
	 *   CR0.PG) is 1.
	 */
	if (to_vmx(vcpu)->nested.nested_run_pending &&
	    (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER)) {
		if (CC(!kvm_valid_efer(vcpu, vmcs12->guest_ia32_efer)) ||
		    CC(ia32e != !!(vmcs12->guest_ia32_efer & EFER_LMA)) ||
		    CC(((vmcs12->guest_cr0 & X86_CR0_PG) &&
		     ia32e != !!(vmcs12->guest_ia32_efer & EFER_LME))))
			return -EINVAL;
	}

	if ((vmcs12->vm_entry_controls & VM_ENTRY_LOAD_BNDCFGS) &&
	    (CC(is_noncanonical_address(vmcs12->guest_bndcfgs & PAGE_MASK, vcpu)) ||
	     CC((vmcs12->guest_bndcfgs & MSR_IA32_BNDCFGS_RSVD))))
		return -EINVAL;

	if (nested_check_guest_non_reg_state(vmcs12))
		return -EINVAL;

	return 0;
}","static int nested_vmx_check_guest_state(struct kvm_vcpu *VAR_0,
					struct vmcs12 *vmcs12,
					enum vm_entry_failure_code *VAR_1)
{
	bool VAR_2 = !!(vmcs12->vm_entry_controls & VAR_3);

	*VAR_1 = VAR_4;

	if (CC(!nested_guest_cr0_valid(VAR_0, vmcs12->guest_cr0)) ||
	    CC(!nested_guest_cr4_valid(VAR_0, vmcs12->guest_cr4)))
		return -VAR_5;

	if ((vmcs12->vm_entry_controls & VAR_6) &&
	    CC(!kvm_dr7_valid(vmcs12->guest_dr7)))
		return -VAR_5;

	if ((vmcs12->vm_entry_controls & VAR_7) &&
	    CC(!kvm_pat_valid(vmcs12->guest_ia32_pat)))
		return -VAR_5;

	if (nested_vmx_check_vmcs_link_ptr(VAR_0, vmcs12)) {
		*VAR_1 = VAR_8;
		return -VAR_5;
	}

	if ((vmcs12->vm_entry_controls & VAR_9) &&
	    CC(!kvm_valid_perf_global_ctrl(vcpu_to_pmu(VAR_0),
					   vmcs12->guest_ia32_perf_global_ctrl)))
		return -VAR_5;

	if (CC((vmcs12->guest_cr0 & (VAR_10 | VAR_11)) == VAR_10))
		return -VAR_5;

	if (CC(VAR_2 && !(vmcs12->guest_cr4 & VAR_12)) ||
	    CC(VAR_2 && !(vmcs12->guest_cr0 & VAR_10)))
		return -VAR_5;

	/* COMMENT_0 */
                                                                     
                                                     
                                                   
                                                                     
                                                                      
                                                                 
                   
    
	if (to_vmx(VAR_0)->nested.nested_run_pending &&
	    (vmcs12->vm_entry_controls & VAR_13)) {
		if (CC(!kvm_valid_efer(VAR_0, vmcs12->guest_ia32_efer)) ||
		    CC(VAR_2 != !!(vmcs12->guest_ia32_efer & VAR_14)) ||
		    CC(((vmcs12->guest_cr0 & VAR_10) &&
		     VAR_2 != !!(vmcs12->guest_ia32_efer & VAR_15))))
			return -VAR_5;
	}

	if ((vmcs12->vm_entry_controls & VAR_16) &&
	    (CC(is_noncanonical_address(vmcs12->guest_bndcfgs & VAR_17, VAR_0)) ||
	     CC((vmcs12->guest_bndcfgs & VAR_18))))
		return -VAR_5;

	if (nested_check_guest_non_reg_state(vmcs12))
		return -VAR_5;

	return 0;
}",torvalds/linux/112e66017bff7f2837030f34c2bc19501e9212d5/nested.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 					struct vmcs12 *vmcs12,
 					enum vm_entry_failure_code *entry_failure_code)
 {
-	bool ia32e;
+	bool ia32e = !!(vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE);
 
 	*entry_failure_code = ENTRY_FAIL_DEFAULT;
 
@@ -28,6 +28,13 @@
 					   vmcs12->guest_ia32_perf_global_ctrl)))
 		return -EINVAL;
 
+	if (CC((vmcs12->guest_cr0 & (X86_CR0_PG | X86_CR0_PE)) == X86_CR0_PG))
+		return -EINVAL;
+
+	if (CC(ia32e && !(vmcs12->guest_cr4 & X86_CR4_PAE)) ||
+	    CC(ia32e && !(vmcs12->guest_cr0 & X86_CR0_PG)))
+		return -EINVAL;
+
 	/*
 	 * If the load IA32_EFER VM-entry control is 1, the following checks
 	 * are performed on the field for the IA32_EFER MSR:
@@ -39,7 +46,6 @@
 	 */
 	if (to_vmx(vcpu)->nested.nested_run_pending &&
 	    (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER)) {
-		ia32e = (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE) != 0;
 		if (CC(!kvm_valid_efer(vcpu, vmcs12->guest_ia32_efer)) ||
 		    CC(ia32e != !!(vmcs12->guest_ia32_efer & EFER_LMA)) ||
 		    CC(((vmcs12->guest_cr0 & X86_CR0_PG) &&","{'deleted_lines': ['\tbool ia32e;', '\t\tia32e = (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE) != 0;'], 'added_lines': ['\tbool ia32e = !!(vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE);', '\tif (CC((vmcs12->guest_cr0 & (X86_CR0_PG | X86_CR0_PE)) == X86_CR0_PG))', '\t\treturn -EINVAL;', '', '\tif (CC(ia32e && !(vmcs12->guest_cr4 & X86_CR4_PAE)) ||', '\t    CC(ia32e && !(vmcs12->guest_cr0 & X86_CR0_PG)))', '\t\treturn -EINVAL;', '']}",True,An issue was discovered in arch/x86/kvm/vmx/nested.c in the Linux kernel before 6.2.8. nVMX on x86_64 lacks consistency checks for CR0 and CR4.,6.5,MEDIUM,1,test,2023-03-10T16:10:56Z,4
CVE-2023-1611,['CWE-416'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:H,1,torvalds/linux,"btrfs: fix race between quota disable and quota assign ioctls

The quota assign ioctl can currently run in parallel with a quota disable
ioctl call. The assign ioctl uses the quota root, while the disable ioctl
frees that root, and therefore we can have a use-after-free triggered in
the assign ioctl, leading to a trace like the following when KASAN is
enabled:

  [672.723][T736] BUG: KASAN: slab-use-after-free in btrfs_search_slot+0x2962/0x2db0
  [672.723][T736] Read of size 8 at addr ffff888022ec0208 by task btrfs_search_sl/27736
  [672.724][T736]
  [672.725][T736] CPU: 1 PID: 27736 Comm: btrfs_search_sl Not tainted 6.3.0-rc3 #37
  [672.723][T736] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014
  [672.727][T736] Call Trace:
  [672.728][T736]  <TASK>
  [672.728][T736]  dump_stack_lvl+0xd9/0x150
  [672.725][T736]  print_report+0xc1/0x5e0
  [672.720][T736]  ? __virt_addr_valid+0x61/0x2e0
  [672.727][T736]  ? __phys_addr+0xc9/0x150
  [672.725][T736]  ? btrfs_search_slot+0x2962/0x2db0
  [672.722][T736]  kasan_report+0xc0/0xf0
  [672.729][T736]  ? btrfs_search_slot+0x2962/0x2db0
  [672.724][T736]  btrfs_search_slot+0x2962/0x2db0
  [672.723][T736]  ? fs_reclaim_acquire+0xba/0x160
  [672.722][T736]  ? split_leaf+0x13d0/0x13d0
  [672.726][T736]  ? rcu_is_watching+0x12/0xb0
  [672.723][T736]  ? kmem_cache_alloc+0x338/0x3c0
  [672.722][T736]  update_qgroup_status_item+0xf7/0x320
  [672.724][T736]  ? add_qgroup_rb+0x3d0/0x3d0
  [672.739][T736]  ? do_raw_spin_lock+0x12d/0x2b0
  [672.730][T736]  ? spin_bug+0x1d0/0x1d0
  [672.737][T736]  btrfs_run_qgroups+0x5de/0x840
  [672.730][T736]  ? btrfs_qgroup_rescan_worker+0xa70/0xa70
  [672.738][T736]  ? __del_qgroup_relation+0x4ba/0xe00
  [672.738][T736]  btrfs_ioctl+0x3d58/0x5d80
  [672.735][T736]  ? tomoyo_path_number_perm+0x16a/0x550
  [672.737][T736]  ? tomoyo_execute_permission+0x4a0/0x4a0
  [672.731][T736]  ? btrfs_ioctl_get_supported_features+0x50/0x50
  [672.737][T736]  ? __sanitizer_cov_trace_switch+0x54/0x90
  [672.734][T736]  ? do_vfs_ioctl+0x132/0x1660
  [672.730][T736]  ? vfs_fileattr_set+0xc40/0xc40
  [672.730][T736]  ? _raw_spin_unlock_irq+0x2e/0x50
  [672.732][T736]  ? sigprocmask+0xf2/0x340
  [672.737][T736]  ? __fget_files+0x26a/0x480
  [672.732][T736]  ? bpf_lsm_file_ioctl+0x9/0x10
  [672.738][T736]  ? btrfs_ioctl_get_supported_features+0x50/0x50
  [672.736][T736]  __x64_sys_ioctl+0x198/0x210
  [672.736][T736]  do_syscall_64+0x39/0xb0
  [672.731][T736]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
  [672.739][T736] RIP: 0033:0x4556ad
  [672.742][T736]  </TASK>
  [672.743][T736]
  [672.748][T736] Allocated by task 27677:
  [672.743][T736]  kasan_save_stack+0x22/0x40
  [672.741][T736]  kasan_set_track+0x25/0x30
  [672.741][T736]  __kasan_kmalloc+0xa4/0xb0
  [672.749][T736]  btrfs_alloc_root+0x48/0x90
  [672.746][T736]  btrfs_create_tree+0x146/0xa20
  [672.744][T736]  btrfs_quota_enable+0x461/0x1d20
  [672.743][T736]  btrfs_ioctl+0x4a1c/0x5d80
  [672.747][T736]  __x64_sys_ioctl+0x198/0x210
  [672.749][T736]  do_syscall_64+0x39/0xb0
  [672.744][T736]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
  [672.756][T736]
  [672.757][T736] Freed by task 27677:
  [672.759][T736]  kasan_save_stack+0x22/0x40
  [672.759][T736]  kasan_set_track+0x25/0x30
  [672.756][T736]  kasan_save_free_info+0x2e/0x50
  [672.751][T736]  ____kasan_slab_free+0x162/0x1c0
  [672.758][T736]  slab_free_freelist_hook+0x89/0x1c0
  [672.752][T736]  __kmem_cache_free+0xaf/0x2e0
  [672.752][T736]  btrfs_put_root+0x1ff/0x2b0
  [672.759][T736]  btrfs_quota_disable+0x80a/0xbc0
  [672.752][T736]  btrfs_ioctl+0x3e5f/0x5d80
  [672.756][T736]  __x64_sys_ioctl+0x198/0x210
  [672.753][T736]  do_syscall_64+0x39/0xb0
  [672.765][T736]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
  [672.769][T736]
  [672.768][T736] The buggy address belongs to the object at ffff888022ec0000
  [672.768][T736]  which belongs to the cache kmalloc-4k of size 4096
  [672.769][T736] The buggy address is located 520 bytes inside of
  [672.769][T736]  freed 4096-byte region [ffff888022ec0000, ffff888022ec1000)
  [672.760][T736]
  [672.764][T736] The buggy address belongs to the physical page:
  [672.761][T736] page:ffffea00008bb000 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x22ec0
  [672.766][T736] head:ffffea00008bb000 order:3 entire_mapcount:0 nr_pages_mapped:0 pincount:0
  [672.779][T736] flags: 0xfff00000010200(slab|head|node=0|zone=1|lastcpupid=0x7ff)
  [672.770][T736] raw: 00fff00000010200 ffff888012842140 ffffea000054ba00 dead000000000002
  [672.770][T736] raw: 0000000000000000 0000000000040004 00000001ffffffff 0000000000000000
  [672.771][T736] page dumped because: kasan: bad access detected
  [672.778][T736] page_owner tracks the page as allocated
  [672.777][T736] page last allocated via order 3, migratetype Unmovable, gfp_mask 0xd2040(__GFP_IO|__GFP_NOWARN|__GFP_NORETRY|__GFP_COMP|__GFP_NOMEMALLOC), pid 88
  [672.779][T736]  get_page_from_freelist+0x119c/0x2d50
  [672.779][T736]  __alloc_pages+0x1cb/0x4a0
  [672.776][T736]  alloc_pages+0x1aa/0x270
  [672.773][T736]  allocate_slab+0x260/0x390
  [672.771][T736]  ___slab_alloc+0xa9a/0x13e0
  [672.778][T736]  __slab_alloc.constprop.0+0x56/0xb0
  [672.771][T736]  __kmem_cache_alloc_node+0x136/0x320
  [672.789][T736]  __kmalloc+0x4e/0x1a0
  [672.783][T736]  tomoyo_realpath_from_path+0xc3/0x600
  [672.781][T736]  tomoyo_path_perm+0x22f/0x420
  [672.782][T736]  tomoyo_path_unlink+0x92/0xd0
  [672.780][T736]  security_path_unlink+0xdb/0x150
  [672.788][T736]  do_unlinkat+0x377/0x680
  [672.788][T736]  __x64_sys_unlink+0xca/0x110
  [672.789][T736]  do_syscall_64+0x39/0xb0
  [672.783][T736]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
  [672.784][T736] page last free stack trace:
  [672.787][T736]  free_pcp_prepare+0x4e5/0x920
  [672.787][T736]  free_unref_page+0x1d/0x4e0
  [672.784][T736]  __unfreeze_partials+0x17c/0x1a0
  [672.797][T736]  qlist_free_all+0x6a/0x180
  [672.796][T736]  kasan_quarantine_reduce+0x189/0x1d0
  [672.797][T736]  __kasan_slab_alloc+0x64/0x90
  [672.793][T736]  kmem_cache_alloc+0x17c/0x3c0
  [672.799][T736]  getname_flags.part.0+0x50/0x4e0
  [672.799][T736]  getname_flags+0x9e/0xe0
  [672.792][T736]  vfs_fstatat+0x77/0xb0
  [672.791][T736]  __do_sys_newlstat+0x84/0x100
  [672.798][T736]  do_syscall_64+0x39/0xb0
  [672.796][T736]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
  [672.790][T736]
  [672.791][T736] Memory state around the buggy address:
  [672.799][T736]  ffff888022ec0100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
  [672.805][T736]  ffff888022ec0180: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
  [672.802][T736] >ffff888022ec0200: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
  [672.809][T736]                       ^
  [672.809][T736]  ffff888022ec0280: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
  [672.809][T736]  ffff888022ec0300: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb

Fix this by having the qgroup assign ioctl take the qgroup ioctl mutex
before calling btrfs_run_qgroups(), which is what all qgroup ioctls should
call.

Reported-by: butt3rflyh4ck <butterflyhuangxx@gmail.com>
Link: https://lore.kernel.org/linux-btrfs/CAFcO6XN3VD8ogmHwqRk4kbiwtpUSNySu2VAxN8waEPciCHJvMA@mail.gmail.com/
CC: stable@vger.kernel.org # 5.10+
Reviewed-by: Qu Wenruo <wqu@suse.com>
Signed-off-by: Filipe Manana <fdmanana@suse.com>
Reviewed-by: David Sterba <dsterba@suse.com>
Signed-off-by: David Sterba <dsterba@suse.com>",2f1a6be12ab6c8470d5776e68644726c94257c54,https://github.com/torvalds/linux/commit/2f1a6be12ab6c8470d5776e68644726c94257c54,fs/btrfs/qgroup.c,btrfs_run_qgroups,"int btrfs_run_qgroups(struct btrfs_trans_handle *trans)
{
struct btrfs_fs_info *fs_info = trans->fs_info;
int ret = 0;
if (!fs_info->quota_root)
return ret;
spin_lock(&fs_info->qgroup_lock);
while (!list_empty(&fs_info->dirty_qgroups)) {
struct btrfs_qgroup *qgroup;
qgroup = list_first_entry(&fs_info->dirty_qgroups,
struct btrfs_qgroup, dirty);
list_del_init(&qgroup->dirty);
spin_unlock(&fs_info->qgroup_lock);
ret = update_qgroup_info_item(trans, qgroup);
if (ret)
qgroup_mark_inconsistent(fs_info);
ret = update_qgroup_limit_item(trans, qgroup);
if (ret)
qgroup_mark_inconsistent(fs_info);
spin_lock(&fs_info->qgroup_lock);
}
if (test_bit(BTRFS_FS_QUOTA_ENABLED, &fs_info->flags))
fs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_ON;
else
fs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_ON;
spin_unlock(&fs_info->qgroup_lock);
ret = update_qgroup_status_item(trans);
if (ret)
qgroup_mark_inconsistent(fs_info);
return ret;
}","int btrfs_run_qgroups(struct btrfs_trans_handle *VAR_0)
{
struct btrfs_fs_info *VAR_1 = VAR_0->fs_info;
int VAR_2 = 0;
if (!VAR_1->quota_root)
return VAR_2;
spin_lock(&VAR_1->qgroup_lock);
while (!list_empty(&VAR_1->dirty_qgroups)) {
struct btrfs_qgroup *VAR_3;
VAR_3 = list_first_entry(&VAR_1->dirty_qgroups,
struct btrfs_qgroup, VAR_4);
list_del_init(&VAR_3->dirty);
spin_unlock(&VAR_1->qgroup_lock);
VAR_2 = update_qgroup_info_item(VAR_0, VAR_3);
if (VAR_2)
qgroup_mark_inconsistent(VAR_1);
VAR_2 = update_qgroup_limit_item(VAR_0, VAR_3);
if (VAR_2)
qgroup_mark_inconsistent(VAR_1);
spin_lock(&VAR_1->qgroup_lock);
}
if (test_bit(VAR_5, &VAR_1->flags))
VAR_1->qgroup_flags |= VAR_6;
else
VAR_1->qgroup_flags &= ~VAR_6;
spin_unlock(&VAR_1->qgroup_lock);
VAR_2 = update_qgroup_status_item(VAR_0);
if (VAR_2)
qgroup_mark_inconsistent(VAR_1);
return VAR_2;
}",torvalds/linux/2f1a6be12ab6c8470d5776e68644726c94257c54/qgroup.c/vul/before/0.json,"int btrfs_run_qgroups(struct btrfs_trans_handle *trans)
{
	struct btrfs_fs_info *fs_info = trans->fs_info;
	int ret = 0;

	/*
	 * In case we are called from the qgroup assign ioctl, assert that we
	 * are holding the qgroup_ioctl_lock, otherwise we can race with a quota
	 * disable operation (ioctl) and access a freed quota root.
	 */
	if (trans->transaction->state != TRANS_STATE_COMMIT_DOING)
		lockdep_assert_held(&fs_info->qgroup_ioctl_lock);

	if (!fs_info->quota_root)
		return ret;

	spin_lock(&fs_info->qgroup_lock);
	while (!list_empty(&fs_info->dirty_qgroups)) {
		struct btrfs_qgroup *qgroup;
		qgroup = list_first_entry(&fs_info->dirty_qgroups,
					  struct btrfs_qgroup, dirty);
		list_del_init(&qgroup->dirty);
		spin_unlock(&fs_info->qgroup_lock);
		ret = update_qgroup_info_item(trans, qgroup);
		if (ret)
			qgroup_mark_inconsistent(fs_info);
		ret = update_qgroup_limit_item(trans, qgroup);
		if (ret)
			qgroup_mark_inconsistent(fs_info);
		spin_lock(&fs_info->qgroup_lock);
	}
	if (test_bit(BTRFS_FS_QUOTA_ENABLED, &fs_info->flags))
		fs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_ON;
	else
		fs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_ON;
	spin_unlock(&fs_info->qgroup_lock);

	ret = update_qgroup_status_item(trans);
	if (ret)
		qgroup_mark_inconsistent(fs_info);

	return ret;
}","int btrfs_run_qgroups(struct btrfs_trans_handle *VAR_0)
{
	struct btrfs_fs_info *VAR_1 = VAR_0->fs_info;
	int VAR_2 = 0;

	/* COMMENT_0 */
                                                                      
                                                                         
                                                            
    
	if (VAR_0->transaction->state != VAR_3)
		lockdep_assert_held(&VAR_1->qgroup_ioctl_lock);

	if (!VAR_1->quota_root)
		return VAR_2;

	spin_lock(&VAR_1->qgroup_lock);
	while (!list_empty(&VAR_1->dirty_qgroups)) {
		struct btrfs_qgroup *VAR_4;
		VAR_4 = list_first_entry(&VAR_1->dirty_qgroups,
					  struct btrfs_qgroup, VAR_5);
		list_del_init(&VAR_4->dirty);
		spin_unlock(&VAR_1->qgroup_lock);
		VAR_2 = update_qgroup_info_item(VAR_0, VAR_4);
		if (VAR_2)
			qgroup_mark_inconsistent(VAR_1);
		VAR_2 = update_qgroup_limit_item(VAR_0, VAR_4);
		if (VAR_2)
			qgroup_mark_inconsistent(VAR_1);
		spin_lock(&VAR_1->qgroup_lock);
	}
	if (test_bit(VAR_6, &VAR_1->flags))
		VAR_1->qgroup_flags |= VAR_7;
	else
		VAR_1->qgroup_flags &= ~VAR_7;
	spin_unlock(&VAR_1->qgroup_lock);

	VAR_2 = update_qgroup_status_item(VAR_0);
	if (VAR_2)
		qgroup_mark_inconsistent(VAR_1);

	return VAR_2;
}",torvalds/linux/2f1a6be12ab6c8470d5776e68644726c94257c54/qgroup.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,6 +2,14 @@
 {
 	struct btrfs_fs_info *fs_info = trans->fs_info;
 	int ret = 0;
+
+	/*
+	 * In case we are called from the qgroup assign ioctl, assert that we
+	 * are holding the qgroup_ioctl_lock, otherwise we can race with a quota
+	 * disable operation (ioctl) and access a freed quota root.
+	 */
+	if (trans->transaction->state != TRANS_STATE_COMMIT_DOING)
+		lockdep_assert_held(&fs_info->qgroup_ioctl_lock);
 
 	if (!fs_info->quota_root)
 		return ret;","{'deleted_lines': [], 'added_lines': ['', '\t/*', '\t * In case we are called from the qgroup assign ioctl, assert that we', '\t * are holding the qgroup_ioctl_lock, otherwise we can race with a quota', '\t * disable operation (ioctl) and access a freed quota root.', '\t */', '\tif (trans->transaction->state != TRANS_STATE_COMMIT_DOING)', '\t\tlockdep_assert_held(&fs_info->qgroup_ioctl_lock);']}",True,A use-after-free flaw was found in btrfs_search_slot in fs/btrfs/ctree.c in btrfs in the Linux Kernel.This flaw allows an attacker to crash the system and possibly cause a kernel information lea,6.3,MEDIUM,1,test,2023-03-22T10:33:28Z,4
CVE-2023-1611,['CWE-416'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:H,1,torvalds/linux,"btrfs: fix race between quota disable and quota assign ioctls

The quota assign ioctl can currently run in parallel with a quota disable
ioctl call. The assign ioctl uses the quota root, while the disable ioctl
frees that root, and therefore we can have a use-after-free triggered in
the assign ioctl, leading to a trace like the following when KASAN is
enabled:

  [672.723][T736] BUG: KASAN: slab-use-after-free in btrfs_search_slot+0x2962/0x2db0
  [672.723][T736] Read of size 8 at addr ffff888022ec0208 by task btrfs_search_sl/27736
  [672.724][T736]
  [672.725][T736] CPU: 1 PID: 27736 Comm: btrfs_search_sl Not tainted 6.3.0-rc3 #37
  [672.723][T736] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014
  [672.727][T736] Call Trace:
  [672.728][T736]  <TASK>
  [672.728][T736]  dump_stack_lvl+0xd9/0x150
  [672.725][T736]  print_report+0xc1/0x5e0
  [672.720][T736]  ? __virt_addr_valid+0x61/0x2e0
  [672.727][T736]  ? __phys_addr+0xc9/0x150
  [672.725][T736]  ? btrfs_search_slot+0x2962/0x2db0
  [672.722][T736]  kasan_report+0xc0/0xf0
  [672.729][T736]  ? btrfs_search_slot+0x2962/0x2db0
  [672.724][T736]  btrfs_search_slot+0x2962/0x2db0
  [672.723][T736]  ? fs_reclaim_acquire+0xba/0x160
  [672.722][T736]  ? split_leaf+0x13d0/0x13d0
  [672.726][T736]  ? rcu_is_watching+0x12/0xb0
  [672.723][T736]  ? kmem_cache_alloc+0x338/0x3c0
  [672.722][T736]  update_qgroup_status_item+0xf7/0x320
  [672.724][T736]  ? add_qgroup_rb+0x3d0/0x3d0
  [672.739][T736]  ? do_raw_spin_lock+0x12d/0x2b0
  [672.730][T736]  ? spin_bug+0x1d0/0x1d0
  [672.737][T736]  btrfs_run_qgroups+0x5de/0x840
  [672.730][T736]  ? btrfs_qgroup_rescan_worker+0xa70/0xa70
  [672.738][T736]  ? __del_qgroup_relation+0x4ba/0xe00
  [672.738][T736]  btrfs_ioctl+0x3d58/0x5d80
  [672.735][T736]  ? tomoyo_path_number_perm+0x16a/0x550
  [672.737][T736]  ? tomoyo_execute_permission+0x4a0/0x4a0
  [672.731][T736]  ? btrfs_ioctl_get_supported_features+0x50/0x50
  [672.737][T736]  ? __sanitizer_cov_trace_switch+0x54/0x90
  [672.734][T736]  ? do_vfs_ioctl+0x132/0x1660
  [672.730][T736]  ? vfs_fileattr_set+0xc40/0xc40
  [672.730][T736]  ? _raw_spin_unlock_irq+0x2e/0x50
  [672.732][T736]  ? sigprocmask+0xf2/0x340
  [672.737][T736]  ? __fget_files+0x26a/0x480
  [672.732][T736]  ? bpf_lsm_file_ioctl+0x9/0x10
  [672.738][T736]  ? btrfs_ioctl_get_supported_features+0x50/0x50
  [672.736][T736]  __x64_sys_ioctl+0x198/0x210
  [672.736][T736]  do_syscall_64+0x39/0xb0
  [672.731][T736]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
  [672.739][T736] RIP: 0033:0x4556ad
  [672.742][T736]  </TASK>
  [672.743][T736]
  [672.748][T736] Allocated by task 27677:
  [672.743][T736]  kasan_save_stack+0x22/0x40
  [672.741][T736]  kasan_set_track+0x25/0x30
  [672.741][T736]  __kasan_kmalloc+0xa4/0xb0
  [672.749][T736]  btrfs_alloc_root+0x48/0x90
  [672.746][T736]  btrfs_create_tree+0x146/0xa20
  [672.744][T736]  btrfs_quota_enable+0x461/0x1d20
  [672.743][T736]  btrfs_ioctl+0x4a1c/0x5d80
  [672.747][T736]  __x64_sys_ioctl+0x198/0x210
  [672.749][T736]  do_syscall_64+0x39/0xb0
  [672.744][T736]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
  [672.756][T736]
  [672.757][T736] Freed by task 27677:
  [672.759][T736]  kasan_save_stack+0x22/0x40
  [672.759][T736]  kasan_set_track+0x25/0x30
  [672.756][T736]  kasan_save_free_info+0x2e/0x50
  [672.751][T736]  ____kasan_slab_free+0x162/0x1c0
  [672.758][T736]  slab_free_freelist_hook+0x89/0x1c0
  [672.752][T736]  __kmem_cache_free+0xaf/0x2e0
  [672.752][T736]  btrfs_put_root+0x1ff/0x2b0
  [672.759][T736]  btrfs_quota_disable+0x80a/0xbc0
  [672.752][T736]  btrfs_ioctl+0x3e5f/0x5d80
  [672.756][T736]  __x64_sys_ioctl+0x198/0x210
  [672.753][T736]  do_syscall_64+0x39/0xb0
  [672.765][T736]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
  [672.769][T736]
  [672.768][T736] The buggy address belongs to the object at ffff888022ec0000
  [672.768][T736]  which belongs to the cache kmalloc-4k of size 4096
  [672.769][T736] The buggy address is located 520 bytes inside of
  [672.769][T736]  freed 4096-byte region [ffff888022ec0000, ffff888022ec1000)
  [672.760][T736]
  [672.764][T736] The buggy address belongs to the physical page:
  [672.761][T736] page:ffffea00008bb000 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x22ec0
  [672.766][T736] head:ffffea00008bb000 order:3 entire_mapcount:0 nr_pages_mapped:0 pincount:0
  [672.779][T736] flags: 0xfff00000010200(slab|head|node=0|zone=1|lastcpupid=0x7ff)
  [672.770][T736] raw: 00fff00000010200 ffff888012842140 ffffea000054ba00 dead000000000002
  [672.770][T736] raw: 0000000000000000 0000000000040004 00000001ffffffff 0000000000000000
  [672.771][T736] page dumped because: kasan: bad access detected
  [672.778][T736] page_owner tracks the page as allocated
  [672.777][T736] page last allocated via order 3, migratetype Unmovable, gfp_mask 0xd2040(__GFP_IO|__GFP_NOWARN|__GFP_NORETRY|__GFP_COMP|__GFP_NOMEMALLOC), pid 88
  [672.779][T736]  get_page_from_freelist+0x119c/0x2d50
  [672.779][T736]  __alloc_pages+0x1cb/0x4a0
  [672.776][T736]  alloc_pages+0x1aa/0x270
  [672.773][T736]  allocate_slab+0x260/0x390
  [672.771][T736]  ___slab_alloc+0xa9a/0x13e0
  [672.778][T736]  __slab_alloc.constprop.0+0x56/0xb0
  [672.771][T736]  __kmem_cache_alloc_node+0x136/0x320
  [672.789][T736]  __kmalloc+0x4e/0x1a0
  [672.783][T736]  tomoyo_realpath_from_path+0xc3/0x600
  [672.781][T736]  tomoyo_path_perm+0x22f/0x420
  [672.782][T736]  tomoyo_path_unlink+0x92/0xd0
  [672.780][T736]  security_path_unlink+0xdb/0x150
  [672.788][T736]  do_unlinkat+0x377/0x680
  [672.788][T736]  __x64_sys_unlink+0xca/0x110
  [672.789][T736]  do_syscall_64+0x39/0xb0
  [672.783][T736]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
  [672.784][T736] page last free stack trace:
  [672.787][T736]  free_pcp_prepare+0x4e5/0x920
  [672.787][T736]  free_unref_page+0x1d/0x4e0
  [672.784][T736]  __unfreeze_partials+0x17c/0x1a0
  [672.797][T736]  qlist_free_all+0x6a/0x180
  [672.796][T736]  kasan_quarantine_reduce+0x189/0x1d0
  [672.797][T736]  __kasan_slab_alloc+0x64/0x90
  [672.793][T736]  kmem_cache_alloc+0x17c/0x3c0
  [672.799][T736]  getname_flags.part.0+0x50/0x4e0
  [672.799][T736]  getname_flags+0x9e/0xe0
  [672.792][T736]  vfs_fstatat+0x77/0xb0
  [672.791][T736]  __do_sys_newlstat+0x84/0x100
  [672.798][T736]  do_syscall_64+0x39/0xb0
  [672.796][T736]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
  [672.790][T736]
  [672.791][T736] Memory state around the buggy address:
  [672.799][T736]  ffff888022ec0100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
  [672.805][T736]  ffff888022ec0180: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
  [672.802][T736] >ffff888022ec0200: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
  [672.809][T736]                       ^
  [672.809][T736]  ffff888022ec0280: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
  [672.809][T736]  ffff888022ec0300: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb

Fix this by having the qgroup assign ioctl take the qgroup ioctl mutex
before calling btrfs_run_qgroups(), which is what all qgroup ioctls should
call.

Reported-by: butt3rflyh4ck <butterflyhuangxx@gmail.com>
Link: https://lore.kernel.org/linux-btrfs/CAFcO6XN3VD8ogmHwqRk4kbiwtpUSNySu2VAxN8waEPciCHJvMA@mail.gmail.com/
CC: stable@vger.kernel.org # 5.10+
Reviewed-by: Qu Wenruo <wqu@suse.com>
Signed-off-by: Filipe Manana <fdmanana@suse.com>
Reviewed-by: David Sterba <dsterba@suse.com>
Signed-off-by: David Sterba <dsterba@suse.com>",2f1a6be12ab6c8470d5776e68644726c94257c54,https://github.com/torvalds/linux/commit/2f1a6be12ab6c8470d5776e68644726c94257c54,fs/btrfs/ioctl.c,btrfs_ioctl_qgroup_assign,"static long btrfs_ioctl_qgroup_assign(struct file *file, void __user *arg)
{
struct inode *inode = file_inode(file);
struct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);
struct btrfs_root *root = BTRFS_I(inode)->root;
struct btrfs_ioctl_qgroup_assign_args *sa;
struct btrfs_trans_handle *trans;
int ret;
int err;
if (!capable(CAP_SYS_ADMIN))
return -EPERM;
ret = mnt_want_write_file(file);
if (ret)
return ret;
sa = memdup_user(arg, sizeof(*sa));
if (IS_ERR(sa)) {
ret = PTR_ERR(sa);
goto drop_write;
}
trans = btrfs_join_transaction(root);
if (IS_ERR(trans)) {
ret = PTR_ERR(trans);
goto out;
}
if (sa->assign) {
ret = btrfs_add_qgroup_relation(trans, sa->src, sa->dst);
} else {
ret = btrfs_del_qgroup_relation(trans, sa->src, sa->dst);
}
err = btrfs_run_qgroups(trans);
if (err < 0)
btrfs_handle_fs_error(fs_info, err,
""failed to update qgroup status and info"");
err = btrfs_end_transaction(trans);
if (err && !ret)
ret = err;
out:
kfree(sa);
drop_write:
mnt_drop_write_file(file);
return ret;
}","static long btrfs_ioctl_qgroup_assign(struct file *file, void __user *VAR_0)
{
struct inode *inode = file_inode(file);
struct btrfs_fs_info *VAR_1 = btrfs_sb(inode->i_sb);
struct btrfs_root *VAR_2 = BTRFS_I(inode)->root;
struct btrfs_ioctl_qgroup_assign_args *VAR_3;
struct btrfs_trans_handle *VAR_4;
int VAR_5;
int VAR_6;
if (!capable(VAR_7))
return -VAR_8;
VAR_5 = mnt_want_write_file(file);
if (VAR_5)
return VAR_5;
VAR_3 = memdup_user(VAR_0, sizeof(*VAR_3));
if (IS_ERR(VAR_3)) {
VAR_5 = PTR_ERR(VAR_3);
goto drop_write;
}
VAR_4 = btrfs_join_transaction(VAR_2);
if (IS_ERR(VAR_4)) {
VAR_5 = PTR_ERR(VAR_4);
goto out;
}
if (VAR_3->assign) {
VAR_5 = btrfs_add_qgroup_relation(VAR_4, VAR_3->src, VAR_3->dst);
} else {
VAR_5 = btrfs_del_qgroup_relation(VAR_4, VAR_3->src, VAR_3->dst);
}
VAR_6 = btrfs_run_qgroups(VAR_4);
if (VAR_6 < 0)
btrfs_handle_fs_error(VAR_1, VAR_6,
""failed to update qgroup status and info"");
VAR_6 = btrfs_end_transaction(VAR_4);
if (VAR_6 && !VAR_5)
VAR_5 = VAR_6;
out:
kfree(VAR_3);
drop_write:
mnt_drop_write_file(file);
return VAR_5;
}",,"static long btrfs_ioctl_qgroup_assign(struct file *file, void __user *arg)
{
	struct inode *inode = file_inode(file);
	struct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);
	struct btrfs_root *root = BTRFS_I(inode)->root;
	struct btrfs_ioctl_qgroup_assign_args *sa;
	struct btrfs_trans_handle *trans;
	int ret;
	int err;

	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;

	ret = mnt_want_write_file(file);
	if (ret)
		return ret;

	sa = memdup_user(arg, sizeof(*sa));
	if (IS_ERR(sa)) {
		ret = PTR_ERR(sa);
		goto drop_write;
	}

	trans = btrfs_join_transaction(root);
	if (IS_ERR(trans)) {
		ret = PTR_ERR(trans);
		goto out;
	}

	if (sa->assign) {
		ret = btrfs_add_qgroup_relation(trans, sa->src, sa->dst);
	} else {
		ret = btrfs_del_qgroup_relation(trans, sa->src, sa->dst);
	}

	/* update qgroup status and info */
	mutex_lock(&fs_info->qgroup_ioctl_lock);
	err = btrfs_run_qgroups(trans);
	mutex_unlock(&fs_info->qgroup_ioctl_lock);
	if (err < 0)
		btrfs_handle_fs_error(fs_info, err,
				      ""failed to update qgroup status and info"");
	err = btrfs_end_transaction(trans);
	if (err && !ret)
		ret = err;

out:
	kfree(sa);
drop_write:
	mnt_drop_write_file(file);
	return ret;
}","static long btrfs_ioctl_qgroup_assign(struct file *file, void __user *VAR_0)
{
	struct inode *inode = file_inode(file);
	struct btrfs_fs_info *VAR_1 = btrfs_sb(inode->i_sb);
	struct btrfs_root *VAR_2 = BTRFS_I(inode)->root;
	struct btrfs_ioctl_qgroup_assign_args *VAR_3;
	struct btrfs_trans_handle *VAR_4;
	int VAR_5;
	int VAR_6;

	if (!capable(VAR_7))
		return -VAR_8;

	VAR_5 = mnt_want_write_file(file);
	if (VAR_5)
		return VAR_5;

	VAR_3 = memdup_user(VAR_0, sizeof(*VAR_3));
	if (IS_ERR(VAR_3)) {
		VAR_5 = PTR_ERR(VAR_3);
		goto drop_write;
	}

	VAR_4 = btrfs_join_transaction(VAR_2);
	if (IS_ERR(VAR_4)) {
		VAR_5 = PTR_ERR(VAR_4);
		goto out;
	}

	if (VAR_3->assign) {
		VAR_5 = btrfs_add_qgroup_relation(VAR_4, VAR_3->src, VAR_3->dst);
	} else {
		VAR_5 = btrfs_del_qgroup_relation(VAR_4, VAR_3->src, VAR_3->dst);
	}

	/* COMMENT_0 */
	mutex_lock(&VAR_1->qgroup_ioctl_lock);
	VAR_6 = btrfs_run_qgroups(VAR_4);
	mutex_unlock(&VAR_1->qgroup_ioctl_lock);
	if (VAR_6 < 0)
		btrfs_handle_fs_error(VAR_1, VAR_6,
				      ""failed to update qgroup status and info"");
	VAR_6 = btrfs_end_transaction(VAR_4);
	if (VAR_6 && !VAR_5)
		VAR_5 = VAR_6;

out:
	kfree(VAR_3);
drop_write:
	mnt_drop_write_file(file);
	return VAR_5;
}",,"--- func_before
+++ func_after
@@ -34,7 +34,9 @@
 	}
 
 	/* update qgroup status and info */
+	mutex_lock(&fs_info->qgroup_ioctl_lock);
 	err = btrfs_run_qgroups(trans);
+	mutex_unlock(&fs_info->qgroup_ioctl_lock);
 	if (err < 0)
 		btrfs_handle_fs_error(fs_info, err,
 				      ""failed to update qgroup status and info"");","{'deleted_lines': [], 'added_lines': ['\tmutex_lock(&fs_info->qgroup_ioctl_lock);', '\tmutex_unlock(&fs_info->qgroup_ioctl_lock);']}",True,A use-after-free flaw was found in btrfs_search_slot in fs/btrfs/ctree.c in btrfs in the Linux Kernel.This flaw allows an attacker to crash the system and possibly cause a kernel information lea,6.3,MEDIUM,1,test,2023-03-22T10:33:28Z,4
CVE-2023-30300,['CWE-835'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,WebAssembly/wabt,"wasm2c: use CHECK_RESULT throughout workhorse function

Make sure to validate module before generating names.",d6dada6ee5071dd7ab3c66ca0bed8eaa9cbc1fe9,https://github.com/WebAssembly/wabt/commit/d6dada6ee5071dd7ab3c66ca0bed8eaa9cbc1fe9,src/tools/wasm2c.cc,ProgramMain,"int ProgramMain(int argc, char** argv) {
Result result;
InitStdio();
ParseOptions(argc, argv);
std::vector<uint8_t> file_data;
result = ReadFile(s_infile.c_str(), &file_data);
if (Succeeded(result)) {
Errors errors;
Module module;
const bool kStopOnFirstError = true;
const bool kFailOnCustomSectionError = true;
ReadBinaryOptions options(s_features, s_log_stream.get(),
s_read_debug_names, kStopOnFirstError,
kFailOnCustomSectionError);
result = ReadBinaryIr(s_infile.c_str(), file_data.data(), file_data.size(),
options, &errors, &module);
if (Succeeded(result)) {
if (Succeeded(result)) {
ValidateOptions options(s_features);
result = ValidateModule(&module, &errors, options);
result |= GenerateNames(&module);
}
if (Succeeded(result)) {
Result dummy_result = ApplyNames(&module);
WABT_USE(dummy_result);
}
if (Succeeded(result)) {
if (!s_outfile.empty()) {
std::string header_name_full =
std::string(strip_extension(s_outfile)) + "".h"";
FileStream c_stream(s_outfile.c_str());
FileStream h_stream(header_name_full);
std::string_view header_name = GetBasename(header_name_full);
if (s_write_c_options.module_name.empty()) {
s_write_c_options.module_name = module.name;
if (s_write_c_options.module_name.empty()) {
s_write_c_options.module_name =
StripExtension(GetBasename(s_infile));
}
}
result =
WriteC(&c_stream, &h_stream, std::string(header_name).c_str(),
&module, s_write_c_options);
} else {
FileStream stream(stdout);
result =
WriteC(&stream, &stream, ""wasm.h"", &module, s_write_c_options);
}
}
}
FormatErrorsToFile(errors, Location::Type::Binary);
}
return result != Result::Ok;
}","int ProgramMain(int VAR_0, char** VAR_1) {
Result VAR_2;
InitStdio();
ParseOptions(VAR_0, VAR_1);
std::vector<uint8_t> VAR_3;
VAR_2 = ReadFile(VAR_4.c_str(), &VAR_3);
if (Succeeded(VAR_2)) {
Errors VAR_5;
Module VAR_6;
const bool VAR_7 = true;
const bool VAR_8 = true;
ReadBinaryOptions VAR_9(VAR_10, VAR_11.get(),
VAR_12, VAR_7,
VAR_8);
VAR_2 = ReadBinaryIr(VAR_4.c_str(), VAR_3.data(), VAR_3.size(),
VAR_9, &VAR_5, &VAR_6);
if (Succeeded(VAR_2)) {
if (Succeeded(VAR_2)) {
ValidateOptions options(s_features);
VAR_2 = ValidateModule(&VAR_6, &VAR_5, VAR_9);
VAR_2 |= GenerateNames(&VAR_6);
}
if (Succeeded(VAR_2)) {
Result VAR_13 = ApplyNames(&VAR_6);
WABT_USE(VAR_13);
}
if (Succeeded(VAR_2)) {
if (!VAR_14.empty()) {
std::string VAR_15 =
std::string(strip_extension(VAR_14)) + "".h"";
FileStream VAR_16(VAR_14.c_str());
FileStream h_stream(header_name_full);
std::string_view VAR_17 = GetBasename(header_name_full);
if (VAR_18.module_name.empty()) {
VAR_18.module_name = VAR_6.name;
if (VAR_18.module_name.empty()) {
VAR_18.module_name =
StripExtension(GetBasename(VAR_4));
}
}
VAR_2 =
WriteC(&VAR_16, &VAR_19, std::string(VAR_17).c_str(),
&VAR_6, VAR_18);
} else {
FileStream stream(stdout);
VAR_2 =
WriteC(&VAR_20, &VAR_20, ""wasm.h"", &VAR_6, VAR_18);
}
}
}
FormatErrorsToFile(VAR_5, Location::Type::Binary);
}
return VAR_2 != Result::Ok;
}",WebAssembly/wabt/d6dada6ee5071dd7ab3c66ca0bed8eaa9cbc1fe9/wasm2c.cc/vul/before/0.json,"int ProgramMain(int argc, char** argv) {
  Result result;

  InitStdio();
  ParseOptions(argc, argv);

  Errors errors;
  result = wasm2c(errors);
  FormatErrorsToFile(errors, Location::Type::Binary);

  return result != Result::Ok;
}","int ProgramMain(int VAR_0, char** VAR_1) {
  Result VAR_2;

  InitStdio();
  ParseOptions(VAR_0, VAR_1);

  Errors VAR_3;
  VAR_2 = wasm2c(VAR_3);
  FormatErrorsToFile(VAR_3, Location::Type::Binary);

  return VAR_2 != Result::Ok;
}",WebAssembly/wabt/d6dada6ee5071dd7ab3c66ca0bed8eaa9cbc1fe9/wasm2c.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,59 +4,9 @@
   InitStdio();
   ParseOptions(argc, argv);
 
-  std::vector<uint8_t> file_data;
-  result = ReadFile(s_infile.c_str(), &file_data);
-  if (Succeeded(result)) {
-    Errors errors;
-    Module module;
-    const bool kStopOnFirstError = true;
-    const bool kFailOnCustomSectionError = true;
-    ReadBinaryOptions options(s_features, s_log_stream.get(),
-                              s_read_debug_names, kStopOnFirstError,
-                              kFailOnCustomSectionError);
-    result = ReadBinaryIr(s_infile.c_str(), file_data.data(), file_data.size(),
-                          options, &errors, &module);
-    if (Succeeded(result)) {
-      if (Succeeded(result)) {
-        ValidateOptions options(s_features);
-        result = ValidateModule(&module, &errors, options);
-        result |= GenerateNames(&module);
-      }
+  Errors errors;
+  result = wasm2c(errors);
+  FormatErrorsToFile(errors, Location::Type::Binary);
 
-      if (Succeeded(result)) {
-        /* TODO(binji): This shouldn't fail; if a name can't be applied
-         * (because the index is invalid, say) it should just be skipped. */
-        Result dummy_result = ApplyNames(&module);
-        WABT_USE(dummy_result);
-      }
-
-      if (Succeeded(result)) {
-        if (!s_outfile.empty()) {
-          std::string header_name_full =
-              std::string(strip_extension(s_outfile)) + "".h"";
-          FileStream c_stream(s_outfile.c_str());
-          FileStream h_stream(header_name_full);
-          std::string_view header_name = GetBasename(header_name_full);
-          if (s_write_c_options.module_name.empty()) {
-            s_write_c_options.module_name = module.name;
-            if (s_write_c_options.module_name.empty()) {
-              // In the absence of module name in the names section use the
-              // filename.
-              s_write_c_options.module_name =
-                  StripExtension(GetBasename(s_infile));
-            }
-          }
-          result =
-              WriteC(&c_stream, &h_stream, std::string(header_name).c_str(),
-                     &module, s_write_c_options);
-        } else {
-          FileStream stream(stdout);
-          result =
-              WriteC(&stream, &stream, ""wasm.h"", &module, s_write_c_options);
-        }
-      }
-    }
-    FormatErrorsToFile(errors, Location::Type::Binary);
-  }
   return result != Result::Ok;
 }","{'deleted_lines': ['  std::vector<uint8_t> file_data;', '  result = ReadFile(s_infile.c_str(), &file_data);', '  if (Succeeded(result)) {', '    Errors errors;', '    Module module;', '    const bool kStopOnFirstError = true;', '    const bool kFailOnCustomSectionError = true;', '    ReadBinaryOptions options(s_features, s_log_stream.get(),', '                              s_read_debug_names, kStopOnFirstError,', '                              kFailOnCustomSectionError);', '    result = ReadBinaryIr(s_infile.c_str(), file_data.data(), file_data.size(),', '                          options, &errors, &module);', '    if (Succeeded(result)) {', '      if (Succeeded(result)) {', '        ValidateOptions options(s_features);', '        result = ValidateModule(&module, &errors, options);', '        result |= GenerateNames(&module);', '      }', '      if (Succeeded(result)) {', ""        /* TODO(binji): This shouldn't fail; if a name can't be applied"", '         * (because the index is invalid, say) it should just be skipped. */', '        Result dummy_result = ApplyNames(&module);', '        WABT_USE(dummy_result);', '      }', '', '      if (Succeeded(result)) {', '        if (!s_outfile.empty()) {', '          std::string header_name_full =', '              std::string(strip_extension(s_outfile)) + "".h"";', '          FileStream c_stream(s_outfile.c_str());', '          FileStream h_stream(header_name_full);', '          std::string_view header_name = GetBasename(header_name_full);', '          if (s_write_c_options.module_name.empty()) {', '            s_write_c_options.module_name = module.name;', '            if (s_write_c_options.module_name.empty()) {', '              // In the absence of module name in the names section use the', '              // filename.', '              s_write_c_options.module_name =', '                  StripExtension(GetBasename(s_infile));', '            }', '          }', '          result =', '              WriteC(&c_stream, &h_stream, std::string(header_name).c_str(),', '                     &module, s_write_c_options);', '        } else {', '          FileStream stream(stdout);', '          result =', '              WriteC(&stream, &stream, ""wasm.h"", &module, s_write_c_options);', '        }', '      }', '    }', '    FormatErrorsToFile(errors, Location::Type::Binary);', '  }'], 'added_lines': ['  Errors errors;', '  result = wasm2c(errors);', '  FormatErrorsToFile(errors, Location::Type::Binary);']}",True,An issue in the component hang.wasm of WebAssembly 1.0 causes an infinite loop.,5.5,MEDIUM,1,test,2023-03-28T10:04:50Z,4
CVE-2023-30300,['CWE-835'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,WebAssembly/wabt,Respond to review,07a33969cbc4d3b346891d062b76b29be6705c01,https://github.com/WebAssembly/wabt/commit/07a33969cbc4d3b346891d062b76b29be6705c01,src/tools/wasm2c.cc,ProgramMain,"int ProgramMain(int argc, char** argv) {
Result result;
InitStdio();
ParseOptions(argc, argv);
Errors errors;
result = wasm2c(errors);
FormatErrorsToFile(errors, Location::Type::Binary);
return result != Result::Ok;
}","int ProgramMain(int VAR_0, char** VAR_1) {
Result VAR_2;
InitStdio();
ParseOptions(VAR_0, VAR_1);
Errors VAR_3;
VAR_2 = wasm2c(VAR_3);
FormatErrorsToFile(VAR_3, Location::Type::Binary);
return VAR_2 != Result::Ok;
}",WebAssembly/wabt/07a33969cbc4d3b346891d062b76b29be6705c01/wasm2c.cc/vul/before/0.json,"int ProgramMain(int argc, char** argv) {
  Result result;

  InitStdio();
  ParseOptions(argc, argv);

  Errors errors;
  result = Wasm2cMain(errors);
  FormatErrorsToFile(errors, Location::Type::Binary);

  return result != Result::Ok;
}","int ProgramMain(int VAR_0, char** VAR_1) {
  Result VAR_2;

  InitStdio();
  ParseOptions(VAR_0, VAR_1);

  Errors VAR_3;
  VAR_2 = Wasm2cMain(VAR_3);
  FormatErrorsToFile(VAR_3, Location::Type::Binary);

  return VAR_2 != Result::Ok;
}",WebAssembly/wabt/07a33969cbc4d3b346891d062b76b29be6705c01/wasm2c.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
   ParseOptions(argc, argv);
 
   Errors errors;
-  result = wasm2c(errors);
+  result = Wasm2cMain(errors);
   FormatErrorsToFile(errors, Location::Type::Binary);
 
   return result != Result::Ok;","{'deleted_lines': ['  result = wasm2c(errors);'], 'added_lines': ['  result = Wasm2cMain(errors);']}",True,An issue in the component hang.wasm of WebAssembly 1.0 causes an infinite loop.,5.5,MEDIUM,1,test,2023-03-30T01:41:12Z,4
CVE-2023-41910,['CWE-125'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,lldpd,daemon: fix read overflow when parsing CDP addresses,a9aeabdf879c25c584852a0bb5523837632f099b,https://github.com/lldpd/lldpd/commit/a9aeabdf879c25c584852a0bb5523837632f099b,src/daemon/protocols/cdp.c,cdp_decode,"int
cdp_decode(struct lldpd *cfg, char *frame, int s, struct lldpd_hardware *hardware,
struct lldpd_chassis **newchassis, struct lldpd_port **newport)
{
struct lldpd_chassis *chassis;
struct lldpd_port *port;
struct lldpd_mgmt *mgmt;
struct in_addr addr;
#  if 0
u_int16_t cksum;
#  endif
u_int8_t *software = NULL, *platform = NULL;
int software_len = 0, platform_len = 0, proto, version, nb, caps;
const unsigned char cdpaddr[] = CDP_MULTICAST_ADDR;
#  ifdef ENABLE_FDP
const unsigned char fdpaddr[] = CDP_MULTICAST_ADDR;
int fdp = 0;
#  endif
u_int8_t *pos, *tlv, *pos_address, *pos_next_address;
int length, len_eth, tlv_type, tlv_len, addresses_len, address_len;
#  ifdef ENABLE_DOT1
struct lldpd_vlan *vlan;
#  endif
log_debug(""cdp"", ""decode CDP frame received on %s"", hardware->h_ifname);
if ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {
log_warn(""cdp"", ""failed to allocate remote chassis"");
return -1;
}
TAILQ_INIT(&chassis->c_mgmt);
if ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {
log_warn(""cdp"", ""failed to allocate remote port"");
free(chassis);
return -1;
}
#  ifdef ENABLE_DOT1
TAILQ_INIT(&port->p_vlans);
#  endif
length = s;
pos = (u_int8_t *)frame;
if (length < 2 * ETHER_ADDR_LEN + sizeof(u_int16_t)  +
8  + 4 ) {
log_warn(""cdp"", ""too short CDP/FDP frame received on %s"",
hardware->h_ifname);
goto malformed;
}
if (PEEK_CMP(cdpaddr, sizeof(cdpaddr)) != 0) {
#  ifdef ENABLE_FDP
PEEK_RESTORE((u_int8_t *)frame);
if (PEEK_CMP(fdpaddr, sizeof(fdpaddr)) != 0)
fdp = 1;
else {
#  endif
log_info(""cdp"",
""frame not targeted at CDP/FDP multicast address received on %s"",
hardware->h_ifname);
goto malformed;
#  ifdef ENABLE_FDP
}
#  endif
}
PEEK_DISCARD(ETHER_ADDR_LEN); 
len_eth = PEEK_UINT16;
if (len_eth > length) {
log_warnx(""cdp"", ""incorrect 802.3 frame size reported on %s"",
hardware->h_ifname);
goto malformed;
}
length = len_eth;
PEEK_DISCARD(6); 
proto = PEEK_UINT16;
if (proto != LLC_PID_CDP) {
if ((proto != LLC_PID_DRIP) && (proto != LLC_PID_PAGP) &&
(proto != LLC_PID_PVSTP) && (proto != LLC_PID_UDLD) &&
(proto != LLC_PID_VTP) && (proto != LLC_PID_DTP) &&
(proto != LLC_PID_STP))
log_debug(""cdp"", ""incorrect LLC protocol ID received on %s"",
hardware->h_ifname);
goto malformed;
}
#  if 0
cksum = frame_checksum(pos, len_eth - 8,
#    ifdef ENABLE_FDP
!fdp
#    else
1
#    endif
);
if (cksum != 0) {
log_info(""cdp"", ""incorrect CDP/FDP checksum for frame received on %s (%d)"",
hardware->h_ifname, cksum);
goto malformed;
}
#  endif
version = PEEK_UINT8;
if ((version != 1) && (version != 2)) {
log_warnx(""cdp"",
""incorrect CDP/FDP version (%d) for frame received on %s"", version,
hardware->h_ifname);
goto malformed;
}
port->p_ttl = PEEK_UINT8; 
PEEK_DISCARD_UINT16;  
while (length) {
if (length < 4) {
log_warnx(""cdp"",
""CDP/FDP TLV header is too large for ""
""frame received on %s"",
hardware->h_ifname);
goto malformed;
}
tlv_type = PEEK_UINT16;
tlv_len = PEEK_UINT16 - 4;
(void)PEEK_SAVE(tlv);
if ((tlv_len < 0) || (length < tlv_len)) {
log_warnx(""cdp"",
""incorrect size in CDP/FDP TLV header for frame ""
""received on %s"",
hardware->h_ifname);
goto malformed;
}
switch (tlv_type) {
case CDP_TLV_CHASSIS:
free(chassis->c_name);
if ((chassis->c_name = (char *)calloc(1, tlv_len + 1)) ==
NULL) {
log_warn(""cdp"",
""unable to allocate memory for chassis name"");
goto malformed;
}
PEEK_BYTES(chassis->c_name, tlv_len);
chassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_LOCAL;
free(chassis->c_id);
if ((chassis->c_id = (char *)malloc(tlv_len)) == NULL) {
log_warn(""cdp"",
""unable to allocate memory for chassis ID"");
goto malformed;
}
memcpy(chassis->c_id, chassis->c_name, tlv_len);
chassis->c_id_len = tlv_len;
break;
case CDP_TLV_ADDRESSES:
CHECK_TLV_SIZE(4, ""Address"");
addresses_len = tlv_len - 4;
for (nb = PEEK_UINT32; nb > 0; nb--) {
(void)PEEK_SAVE(pos_address);
if (addresses_len < 2) {
log_warn(""cdp"",
""too short address subframe ""
""received on %s"",
hardware->h_ifname);
goto malformed;
}
PEEK_DISCARD_UINT8;
addresses_len--;
address_len = PEEK_UINT8;
addresses_len--;
if (addresses_len < address_len + 2) {
log_warn(""cdp"",
""too short address subframe ""
""received on %s"",
hardware->h_ifname);
goto malformed;
}
PEEK_DISCARD(address_len);
addresses_len -= address_len;
address_len = PEEK_UINT16;
addresses_len -= 2;
if (addresses_len < address_len) {
log_warn(""cdp"",
""too short address subframe ""
""received on %s"",
hardware->h_ifname);
goto malformed;
}
PEEK_DISCARD(address_len);
(void)PEEK_SAVE(pos_next_address);
PEEK_RESTORE(pos_address);
if ((PEEK_UINT8 == 1) && (PEEK_UINT8 == 1) &&
(PEEK_UINT8 == CDP_ADDRESS_PROTO_IP) &&
(PEEK_UINT16 == sizeof(struct in_addr))) {
PEEK_BYTES(&addr, sizeof(struct in_addr));
mgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &addr,
sizeof(struct in_addr), 0);
if (mgmt == NULL) {
if (errno == ENOMEM)
log_warn(""cdp"",
""unable to allocate memory for management address"");
else
log_warn(""cdp"",
""too large management address received on %s"",
hardware->h_ifname);
goto malformed;
}
TAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt,
m_entries);
}
PEEK_RESTORE(pos_next_address);
}
break;
case CDP_TLV_PORT:
if (tlv_len == 0) {
log_warn(""cdp"", ""too short port description received"");
goto malformed;
}
free(port->p_descr);
if ((port->p_descr = (char *)calloc(1, tlv_len + 1)) == NULL) {
log_warn(""cdp"",
""unable to allocate memory for port description"");
goto malformed;
}
PEEK_BYTES(port->p_descr, tlv_len);
port->p_id_subtype = LLDP_PORTID_SUBTYPE_IFNAME;
free(port->p_id);
if ((port->p_id = (char *)calloc(1, tlv_len)) == NULL) {
log_warn(""cdp"",
""unable to allocate memory for port ID"");
goto malformed;
}
memcpy(port->p_id, port->p_descr, tlv_len);
port->p_id_len = tlv_len;
break;
case CDP_TLV_CAPABILITIES:
#  ifdef ENABLE_FDP
if (fdp) {
if (!strncmp(""Router"", (char *)pos, tlv_len))
chassis->c_cap_enabled = LLDP_CAP_ROUTER;
else if (!strncmp(""Switch"", (char *)pos, tlv_len))
chassis->c_cap_enabled = LLDP_CAP_BRIDGE;
else if (!strncmp(""Bridge"", (char *)pos, tlv_len))
chassis->c_cap_enabled = LLDP_CAP_REPEATER;
else
chassis->c_cap_enabled = LLDP_CAP_STATION;
chassis->c_cap_available = chassis->c_cap_enabled;
break;
}
#  endif
CHECK_TLV_SIZE(4, ""Capabilities"");
caps = PEEK_UINT32;
if (caps & CDP_CAP_ROUTER)
chassis->c_cap_enabled |= LLDP_CAP_ROUTER;
if (caps & 0x0e) chassis->c_cap_enabled |= LLDP_CAP_BRIDGE;
if (chassis->c_cap_enabled == 0)
chassis->c_cap_enabled = LLDP_CAP_STATION;
chassis->c_cap_available = chassis->c_cap_enabled;
break;
case CDP_TLV_SOFTWARE:
software_len = tlv_len;
(void)PEEK_SAVE(software);
break;
case CDP_TLV_PLATFORM:
platform_len = tlv_len;
(void)PEEK_SAVE(platform);
break;
#  ifdef ENABLE_DOT1
case CDP_TLV_NATIVEVLAN:
CHECK_TLV_SIZE(2, ""Native VLAN"");
if ((vlan = (struct lldpd_vlan *)calloc(1,
sizeof(struct lldpd_vlan))) == NULL) {
log_warn(""cdp"",
""unable to alloc vlan ""
""structure for ""
""tlv received on %s"",
hardware->h_ifname);
goto malformed;
}
vlan->v_vid = port->p_pvid = PEEK_UINT16;
if (asprintf(&vlan->v_name, ""VLAN #%d"", vlan->v_vid) == -1) {
log_warn(""cdp"",
""unable to alloc VLAN name for ""
""TLV received on %s"",
hardware->h_ifname);
free(vlan);
goto malformed;
}
TAILQ_INSERT_TAIL(&port->p_vlans, vlan, v_entries);
break;
#  endif
#  ifdef ENABLE_DOT3
case CDP_TLV_POWER_AVAILABLE:
CHECK_TLV_SIZE(12, ""Power Available"");
if (PEEK_UINT16 > 0) {
port->p_cdp_power.management_id = PEEK_UINT16;
port->p_power.allocated = PEEK_UINT32;
port->p_power.allocated /= 100;
port->p_power.supported = 1;
port->p_power.enabled = 1;
port->p_power.devicetype = LLDP_DOT3_POWER_PSE;
port->p_power.powertype = LLDP_DOT3_POWER_8023AT_TYPE2;
log_debug(""cdp"", ""Allocated power %d00"",
port->p_power.allocated);
if (port->p_power.allocated > CDP_CLASS_3_MAX_PSE_POE) {
port->p_power.allocated -=
CDP_SWITCH_POE_CLASS_4_OFFSET;
} else if (port->p_power.allocated >
CDP_SWITCH_POE_CLASS_3_OFFSET) {
port->p_power.allocated -=
CDP_SWITCH_POE_CLASS_3_OFFSET;
} else {
port->p_power.allocated = 0;
}
port->p_power.requested =
hardware->h_lport.p_power.requested;
}
break;
#  endif
default:
log_debug(""cdp"", ""unknown CDP/FDP TLV type (%d) received on %s"",
ntohs(tlv_type), hardware->h_ifname);
hardware->h_rx_unrecognized_cnt++;
}
PEEK_DISCARD(tlv + tlv_len - pos);
}
if (!software && platform) {
if ((chassis->c_descr = (char *)calloc(1, platform_len + 1)) == NULL) {
log_warn(""cdp"",
""unable to allocate memory for chassis description"");
goto malformed;
}
memcpy(chassis->c_descr, platform, platform_len);
} else if (software && !platform) {
if ((chassis->c_descr = (char *)calloc(1, software_len + 1)) == NULL) {
log_warn(""cdp"",
""unable to allocate memory for chassis description"");
goto malformed;
}
memcpy(chassis->c_descr, software, software_len);
} else if (software && platform) {
#  define CONCAT_PLATFORM "" running on\n""
if ((chassis->c_descr = (char *)calloc(1,
software_len + platform_len + strlen(CONCAT_PLATFORM) + 1)) ==
NULL) {
log_warn(""cdp"",
""unable to allocate memory for chassis description"");
goto malformed;
}
memcpy(chassis->c_descr, platform, platform_len);
memcpy(chassis->c_descr + platform_len, CONCAT_PLATFORM,
strlen(CONCAT_PLATFORM));
memcpy(chassis->c_descr + platform_len + strlen(CONCAT_PLATFORM),
software, software_len);
}
if ((chassis->c_id == NULL) || (port->p_id == NULL) ||
(chassis->c_name == NULL) || (chassis->c_descr == NULL) ||
(port->p_descr == NULL) || (port->p_ttl == 0) ||
(chassis->c_cap_enabled == 0)) {
log_warnx(""cdp"",
""some mandatory CDP/FDP tlv are missing for frame received on %s"",
hardware->h_ifname);
goto malformed;
}
*newchassis = chassis;
*newport = port;
return 1;
malformed:
lldpd_chassis_cleanup(chassis, 1);
lldpd_port_cleanup(port, 1);
free(port);
return -1;
}","int
cdp_decode(struct lldpd *VAR_0, char *VAR_1, int VAR_2, struct lldpd_hardware *VAR_3,
struct lldpd_chassis **VAR_4, struct lldpd_port **VAR_5)
{
struct lldpd_chassis *VAR_6;
struct lldpd_port *VAR_7;
struct lldpd_mgmt *VAR_8;
struct in_addr VAR_9;
#  if 0
u_int16_t VAR_10;
#  endif
u_int8_t *VAR_11 = NULL, *VAR_12 = NULL;
int VAR_13 = 0, VAR_14 = 0, VAR_15, VAR_16, VAR_17, VAR_18;
const unsigned char VAR_19[] = VAR_20;
#  ifdef VAR_21
const unsigned char VAR_22[] = VAR_20;
int VAR_23 = 0;
#  endif
u_int8_t *VAR_24, *VAR_25, *VAR_26, *VAR_27;
int VAR_28, VAR_29, VAR_30, VAR_31, VAR_32, VAR_33;
#  ifdef VAR_34
struct lldpd_vlan *VAR_35;
#  endif
log_debug(""cdp"", ""decode CDP frame received on %s"", VAR_3->h_ifname);
if ((VAR_6 = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {
log_warn(""cdp"", ""failed to allocate remote chassis"");
return -1;
}
TAILQ_INIT(&VAR_6->c_mgmt);
if ((VAR_7 = calloc(1, sizeof(struct lldpd_port))) == NULL) {
log_warn(""cdp"", ""failed to allocate remote port"");
free(VAR_6);
return -1;
}
#  ifdef VAR_34
TAILQ_INIT(&VAR_7->p_vlans);
#  endif
VAR_28 = VAR_2;
VAR_24 = (u_int8_t *)VAR_1;
if (VAR_28 < 2 * VAR_36 + sizeof(u_int16_t)  +
8  + 4 ) {
log_warn(""cdp"", ""too short CDP/FDP frame received on %s"",
VAR_3->h_ifname);
goto malformed;
}
if (PEEK_CMP(VAR_19, sizeof(VAR_19)) != 0) {
#  ifdef VAR_21
PEEK_RESTORE((u_int8_t *)VAR_1);
if (PEEK_CMP(VAR_22, sizeof(VAR_22)) != 0)
VAR_23 = 1;
else {
#  endif
log_info(""cdp"",
""frame not targeted at CDP/FDP multicast address received on %s"",
VAR_3->h_ifname);
goto malformed;
#  ifdef VAR_21
}
#  endif
}
PEEK_DISCARD(VAR_36); 
VAR_29 = VAR_37;
if (VAR_29 > VAR_28) {
log_warnx(""cdp"", ""incorrect 802.3 frame size reported on %s"",
VAR_3->h_ifname);
goto malformed;
}
VAR_28 = VAR_29;
PEEK_DISCARD(6); 
VAR_15 = VAR_37;
if (VAR_15 != VAR_38) {
if ((VAR_15 != VAR_39) && (VAR_15 != VAR_40) &&
(VAR_15 != VAR_41) && (VAR_15 != VAR_42) &&
(VAR_15 != VAR_43) && (VAR_15 != VAR_44) &&
(VAR_15 != VAR_45))
log_debug(""cdp"", ""incorrect LLC protocol ID received on %s"",
VAR_3->h_ifname);
goto malformed;
}
#  if 0
VAR_10 = frame_checksum(VAR_24, VAR_29 - 8,
#    ifdef VAR_21
!VAR_23
#    else
1
#    endif
);
if (VAR_10 != 0) {
log_info(""cdp"", ""incorrect CDP/FDP checksum for frame received on %s (%d)"",
VAR_3->h_ifname, VAR_10);
goto malformed;
}
#  endif
VAR_16 = VAR_46;
if ((VAR_16 != 1) && (VAR_16 != 2)) {
log_warnx(""cdp"",
""incorrect CDP/FDP version (%d) for frame received on %s"", VAR_16,
VAR_3->h_ifname);
goto malformed;
}
VAR_7->p_ttl = VAR_46; 
VAR_47;  
while (VAR_28) {
if (VAR_28 < 4) {
log_warnx(""cdp"",
""CDP/FDP TLV header is too large for ""
""frame received on %s"",
VAR_3->h_ifname);
goto malformed;
}
VAR_30 = VAR_37;
VAR_31 = VAR_37 - 4;
(void)PEEK_SAVE(VAR_25);
if ((VAR_31 < 0) || (VAR_28 < VAR_31)) {
log_warnx(""cdp"",
""incorrect size in CDP/FDP TLV header for frame ""
""received on %s"",
VAR_3->h_ifname);
goto malformed;
}
switch (VAR_30) {
case VAR_48:
free(VAR_6->c_name);
if ((VAR_6->c_name = (char *)calloc(1, VAR_31 + 1)) ==
NULL) {
log_warn(""cdp"",
""unable to allocate memory for chassis name"");
goto malformed;
}
PEEK_BYTES(VAR_6->c_name, VAR_31);
VAR_6->c_id_subtype = VAR_49;
free(VAR_6->c_id);
if ((VAR_6->c_id = (char *)malloc(VAR_31)) == NULL) {
log_warn(""cdp"",
""unable to allocate memory for chassis ID"");
goto malformed;
}
memcpy(VAR_6->c_id, VAR_6->c_name, VAR_31);
VAR_6->c_id_len = VAR_31;
break;
case VAR_50:
CHECK_TLV_SIZE(4, ""Address"");
VAR_32 = VAR_31 - 4;
for (VAR_17 = VAR_51; VAR_17 > 0; VAR_17--) {
(void)PEEK_SAVE(VAR_26);
if (VAR_32 < 2) {
log_warn(""cdp"",
""too short address subframe ""
""received on %s"",
VAR_3->h_ifname);
goto malformed;
}
VAR_52;
VAR_32--;
VAR_33 = VAR_46;
VAR_32--;
if (VAR_32 < VAR_33 + 2) {
log_warn(""cdp"",
""too short address subframe ""
""received on %s"",
VAR_3->h_ifname);
goto malformed;
}
PEEK_DISCARD(VAR_33);
VAR_32 -= VAR_33;
VAR_33 = VAR_37;
VAR_32 -= 2;
if (VAR_32 < VAR_33) {
log_warn(""cdp"",
""too short address subframe ""
""received on %s"",
VAR_3->h_ifname);
goto malformed;
}
PEEK_DISCARD(VAR_33);
(void)PEEK_SAVE(VAR_27);
PEEK_RESTORE(VAR_26);
if ((VAR_46 == 1) && (VAR_46 == 1) &&
(VAR_46 == VAR_53) &&
(VAR_37 == sizeof(struct in_addr))) {
PEEK_BYTES(&VAR_9, sizeof(struct in_addr));
VAR_8 = lldpd_alloc_mgmt(VAR_54, &VAR_9,
sizeof(struct in_addr), 0);
if (VAR_8 == NULL) {
if (VAR_55 == VAR_56)
log_warn(""cdp"",
""unable to allocate memory for management address"");
else
log_warn(""cdp"",
""too large management address received on %s"",
VAR_3->h_ifname);
goto malformed;
}
TAILQ_INSERT_TAIL(&VAR_6->c_mgmt, VAR_8,
VAR_57);
}
PEEK_RESTORE(VAR_27);
}
break;
case VAR_58:
if (VAR_31 == 0) {
log_warn(""cdp"", ""too short port description received"");
goto malformed;
}
free(VAR_7->p_descr);
if ((VAR_7->p_descr = (char *)calloc(1, VAR_31 + 1)) == NULL) {
log_warn(""cdp"",
""unable to allocate memory for port description"");
goto malformed;
}
PEEK_BYTES(VAR_7->p_descr, VAR_31);
VAR_7->p_id_subtype = VAR_59;
free(VAR_7->p_id);
if ((VAR_7->p_id = (char *)calloc(1, VAR_31)) == NULL) {
log_warn(""cdp"",
""unable to allocate memory for port ID"");
goto malformed;
}
memcpy(VAR_7->p_id, VAR_7->p_descr, VAR_31);
VAR_7->p_id_len = VAR_31;
break;
case VAR_60:
#  ifdef VAR_21
if (VAR_23) {
if (!strncmp(""Router"", (char *)VAR_24, VAR_31))
VAR_6->c_cap_enabled = VAR_61;
else if (!strncmp(""Switch"", (char *)VAR_24, VAR_31))
VAR_6->c_cap_enabled = VAR_62;
else if (!strncmp(""Bridge"", (char *)VAR_24, VAR_31))
VAR_6->c_cap_enabled = VAR_63;
else
VAR_6->c_cap_enabled = VAR_64;
VAR_6->c_cap_available = VAR_6->c_cap_enabled;
break;
}
#  endif
CHECK_TLV_SIZE(4, ""Capabilities"");
VAR_18 = VAR_51;
if (VAR_18 & VAR_65)
VAR_6->c_cap_enabled |= VAR_61;
if (VAR_18 & 0x0e) VAR_6->c_cap_enabled |= VAR_62;
if (VAR_6->c_cap_enabled == 0)
VAR_6->c_cap_enabled = VAR_64;
VAR_6->c_cap_available = VAR_6->c_cap_enabled;
break;
case VAR_66:
VAR_13 = VAR_31;
(void)PEEK_SAVE(VAR_11);
break;
case VAR_67:
VAR_14 = VAR_31;
(void)PEEK_SAVE(VAR_12);
break;
#  ifdef VAR_34
case VAR_68:
CHECK_TLV_SIZE(2, ""Native VLAN"");
if ((VAR_35 = (struct lldpd_vlan *)calloc(1,
sizeof(struct lldpd_vlan))) == NULL) {
log_warn(""cdp"",
""unable to alloc vlan ""
""structure for ""
""tlv received on %s"",
VAR_3->h_ifname);
goto malformed;
}
VAR_35->v_vid = VAR_7->p_pvid = VAR_37;
if (asprintf(&VAR_35->v_name, ""VLAN #%d"", VAR_35->v_vid) == -1) {
log_warn(""cdp"",
""unable to alloc VLAN name for ""
""TLV received on %s"",
VAR_3->h_ifname);
free(VAR_35);
goto malformed;
}
TAILQ_INSERT_TAIL(&VAR_7->p_vlans, VAR_35, VAR_69);
break;
#  endif
#  ifdef VAR_70
case VAR_71:
CHECK_TLV_SIZE(12, ""Power Available"");
if (VAR_37 > 0) {
VAR_7->p_cdp_power.management_id = VAR_37;
VAR_7->p_power.allocated = VAR_51;
VAR_7->p_power.allocated /= 100;
VAR_7->p_power.supported = 1;
VAR_7->p_power.enabled = 1;
VAR_7->p_power.devicetype = VAR_72;
VAR_7->p_power.powertype = VAR_73;
log_debug(""cdp"", ""Allocated power %d00"",
VAR_7->p_power.allocated);
if (VAR_7->p_power.allocated > VAR_74) {
VAR_7->p_power.allocated -=
VAR_75;
} else if (VAR_7->p_power.allocated >
VAR_76) {
VAR_7->p_power.allocated -=
VAR_76;
} else {
VAR_7->p_power.allocated = 0;
}
VAR_7->p_power.requested =
VAR_3->h_lport.p_power.requested;
}
break;
#  endif
default:
log_debug(""cdp"", ""unknown CDP/FDP TLV type (%d) received on %s"",
ntohs(VAR_30), VAR_3->h_ifname);
VAR_3->h_rx_unrecognized_cnt++;
}
PEEK_DISCARD(VAR_25 + VAR_31 - VAR_24);
}
if (!VAR_11 && VAR_12) {
if ((VAR_6->c_descr = (char *)calloc(1, VAR_14 + 1)) == NULL) {
log_warn(""cdp"",
""unable to allocate memory for chassis description"");
goto malformed;
}
memcpy(VAR_6->c_descr, VAR_12, VAR_14);
} else if (VAR_11 && !VAR_12) {
if ((VAR_6->c_descr = (char *)calloc(1, VAR_13 + 1)) == NULL) {
log_warn(""cdp"",
""unable to allocate memory for chassis description"");
goto malformed;
}
memcpy(VAR_6->c_descr, VAR_11, VAR_13);
} else if (VAR_11 && VAR_12) {
#  define VAR_77 "" running on\n""
if ((VAR_6->c_descr = (char *)calloc(1,
VAR_13 + VAR_14 + strlen(VAR_77) + 1)) ==
NULL) {
log_warn(""cdp"",
""unable to allocate memory for chassis description"");
goto malformed;
}
memcpy(VAR_6->c_descr, VAR_12, VAR_14);
memcpy(VAR_6->c_descr + VAR_14, VAR_77,
strlen(VAR_77));
memcpy(VAR_6->c_descr + VAR_14 + strlen(VAR_77),
VAR_11, VAR_13);
}
if ((VAR_6->c_id == NULL) || (VAR_7->p_id == NULL) ||
(VAR_6->c_name == NULL) || (VAR_6->c_descr == NULL) ||
(VAR_7->p_descr == NULL) || (VAR_7->p_ttl == 0) ||
(VAR_6->c_cap_enabled == 0)) {
log_warnx(""cdp"",
""some mandatory CDP/FDP tlv are missing for frame received on %s"",
VAR_3->h_ifname);
goto malformed;
}
*VAR_4 = VAR_6;
*VAR_5 = VAR_7;
return 1;
malformed:
lldpd_chassis_cleanup(VAR_6, 1);
lldpd_port_cleanup(VAR_7, 1);
free(VAR_7);
return -1;
}",lldpd/a9aeabdf879c25c584852a0bb5523837632f099b/cdp.c/vul/before/0.json,"int
cdp_decode(struct lldpd *cfg, char *frame, int s, struct lldpd_hardware *hardware,
    struct lldpd_chassis **newchassis, struct lldpd_port **newport)
{
	struct lldpd_chassis *chassis;
	struct lldpd_port *port;
	struct lldpd_mgmt *mgmt;
	struct in_addr addr;
#  if 0
	u_int16_t cksum;
#  endif
	u_int8_t *software = NULL, *platform = NULL;
	int software_len = 0, platform_len = 0, proto, version, nb, caps;
	const unsigned char cdpaddr[] = CDP_MULTICAST_ADDR;
#  ifdef ENABLE_FDP
	const unsigned char fdpaddr[] = CDP_MULTICAST_ADDR;
	int fdp = 0;
#  endif
	u_int8_t *pos, *tlv, *pos_address, *pos_next_address;
	int length, len_eth, tlv_type, tlv_len, addresses_len, address_len;
#  ifdef ENABLE_DOT1
	struct lldpd_vlan *vlan;
#  endif

	log_debug(""cdp"", ""decode CDP frame received on %s"", hardware->h_ifname);

	if ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {
		log_warn(""cdp"", ""failed to allocate remote chassis"");
		return -1;
	}
	TAILQ_INIT(&chassis->c_mgmt);
	if ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {
		log_warn(""cdp"", ""failed to allocate remote port"");
		free(chassis);
		return -1;
	}
#  ifdef ENABLE_DOT1
	TAILQ_INIT(&port->p_vlans);
#  endif

	length = s;
	pos = (u_int8_t *)frame;

	if (length < 2 * ETHER_ADDR_LEN + sizeof(u_int16_t) /* Ethernet */ +
		8 /* LLC */ + 4 /* CDP header */) {
		log_warn(""cdp"", ""too short CDP/FDP frame received on %s"",
		    hardware->h_ifname);
		goto malformed;
	}

	if (PEEK_CMP(cdpaddr, sizeof(cdpaddr)) != 0) {
#  ifdef ENABLE_FDP
		PEEK_RESTORE((u_int8_t *)frame);
		if (PEEK_CMP(fdpaddr, sizeof(fdpaddr)) != 0)
			fdp = 1;
		else {
#  endif
			log_info(""cdp"",
			    ""frame not targeted at CDP/FDP multicast address received on %s"",
			    hardware->h_ifname);
			goto malformed;
#  ifdef ENABLE_FDP
		}
#  endif
	}
	PEEK_DISCARD(ETHER_ADDR_LEN); /* Don't care of source address */
	len_eth = PEEK_UINT16;
	if (len_eth > length) {
		log_warnx(""cdp"", ""incorrect 802.3 frame size reported on %s"",
		    hardware->h_ifname);
		goto malformed;
	}

	/* This is the correct length of the CDP + LLC packets */
	length = len_eth;

	PEEK_DISCARD(6); /* Skip beginning of LLC */
	proto = PEEK_UINT16;
	if (proto != LLC_PID_CDP) {
		if ((proto != LLC_PID_DRIP) && (proto != LLC_PID_PAGP) &&
		    (proto != LLC_PID_PVSTP) && (proto != LLC_PID_UDLD) &&
		    (proto != LLC_PID_VTP) && (proto != LLC_PID_DTP) &&
		    (proto != LLC_PID_STP))
			log_debug(""cdp"", ""incorrect LLC protocol ID received on %s"",
			    hardware->h_ifname);
		goto malformed;
	}

#  if 0
	/* Check checksum */
	cksum = frame_checksum(pos, len_eth - 8,
#    ifdef ENABLE_FDP
	    !fdp		/* fdp = 0 -> cisco checksum */
#    else
	    1			/* cisco checksum */
#    endif
		);
	if (cksum != 0) {
		log_info(""cdp"", ""incorrect CDP/FDP checksum for frame received on %s (%d)"",
			  hardware->h_ifname, cksum);
		goto malformed;
	}
#  endif

	/* Check version */
	version = PEEK_UINT8;
	if ((version != 1) && (version != 2)) {
		log_warnx(""cdp"",
		    ""incorrect CDP/FDP version (%d) for frame received on %s"", version,
		    hardware->h_ifname);
		goto malformed;
	}
	port->p_ttl = PEEK_UINT8; /* TTL */
	PEEK_DISCARD_UINT16;	  /* Checksum, already checked */

	while (length) {
		if (length < 4) {
			log_warnx(""cdp"",
			    ""CDP/FDP TLV header is too large for ""
			    ""frame received on %s"",
			    hardware->h_ifname);
			goto malformed;
		}
		tlv_type = PEEK_UINT16;
		tlv_len = PEEK_UINT16 - 4;

		(void)PEEK_SAVE(tlv);
		if ((tlv_len < 0) || (length < tlv_len)) {
			log_warnx(""cdp"",
			    ""incorrect size in CDP/FDP TLV header for frame ""
			    ""received on %s"",
			    hardware->h_ifname);
			goto malformed;
		}
		switch (tlv_type) {
		case CDP_TLV_CHASSIS:
			free(chassis->c_name);
			if ((chassis->c_name = (char *)calloc(1, tlv_len + 1)) ==
			    NULL) {
				log_warn(""cdp"",
				    ""unable to allocate memory for chassis name"");
				goto malformed;
			}
			PEEK_BYTES(chassis->c_name, tlv_len);
			chassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_LOCAL;
			free(chassis->c_id);
			if ((chassis->c_id = (char *)malloc(tlv_len)) == NULL) {
				log_warn(""cdp"",
				    ""unable to allocate memory for chassis ID"");
				goto malformed;
			}
			memcpy(chassis->c_id, chassis->c_name, tlv_len);
			chassis->c_id_len = tlv_len;
			break;
		case CDP_TLV_ADDRESSES:
			CHECK_TLV_SIZE(4, ""Address"");
			addresses_len = tlv_len - 4;
			for (nb = PEEK_UINT32; nb > 0; nb--) {
				(void)PEEK_SAVE(pos_address);
				/* We first try to get the real length of the packet */
				if (addresses_len < 2) {
					log_warn(""cdp"",
					    ""too short address subframe ""
					    ""received on %s"",
					    hardware->h_ifname);
					goto malformed;
				}
				PEEK_DISCARD_UINT8;
				addresses_len--;
				address_len = PEEK_UINT8;
				addresses_len--;
				if (addresses_len < address_len + 2) {
					log_warn(""cdp"",
					    ""too short address subframe ""
					    ""received on %s"",
					    hardware->h_ifname);
					goto malformed;
				}
				PEEK_DISCARD(address_len);
				addresses_len -= address_len;
				address_len = PEEK_UINT16;
				addresses_len -= 2;
				if (addresses_len < address_len) {
					log_warn(""cdp"",
					    ""too short address subframe ""
					    ""received on %s"",
					    hardware->h_ifname);
					goto malformed;
				}
				PEEK_DISCARD(address_len);
				addresses_len -= address_len;
				(void)PEEK_SAVE(pos_next_address);
				/* Next, we go back and try to extract
				   IPv4 address */
				PEEK_RESTORE(pos_address);
				if ((PEEK_UINT8 == 1) && (PEEK_UINT8 == 1) &&
				    (PEEK_UINT8 == CDP_ADDRESS_PROTO_IP) &&
				    (PEEK_UINT16 == sizeof(struct in_addr))) {
					PEEK_BYTES(&addr, sizeof(struct in_addr));
					mgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &addr,
					    sizeof(struct in_addr), 0);
					if (mgmt == NULL) {
						if (errno == ENOMEM)
							log_warn(""cdp"",
							    ""unable to allocate memory for management address"");
						else
							log_warn(""cdp"",
							    ""too large management address received on %s"",
							    hardware->h_ifname);
						goto malformed;
					}
					TAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt,
					    m_entries);
				}
				/* Go to the end of the address */
				PEEK_RESTORE(pos_next_address);
			}
			break;
		case CDP_TLV_PORT:
			if (tlv_len == 0) {
				log_warn(""cdp"", ""too short port description received"");
				goto malformed;
			}
			free(port->p_descr);
			if ((port->p_descr = (char *)calloc(1, tlv_len + 1)) == NULL) {
				log_warn(""cdp"",
				    ""unable to allocate memory for port description"");
				goto malformed;
			}
			PEEK_BYTES(port->p_descr, tlv_len);
			port->p_id_subtype = LLDP_PORTID_SUBTYPE_IFNAME;
			free(port->p_id);
			if ((port->p_id = (char *)calloc(1, tlv_len)) == NULL) {
				log_warn(""cdp"",
				    ""unable to allocate memory for port ID"");
				goto malformed;
			}
			memcpy(port->p_id, port->p_descr, tlv_len);
			port->p_id_len = tlv_len;
			break;
		case CDP_TLV_CAPABILITIES:
#  ifdef ENABLE_FDP
			if (fdp) {
				/* Capabilities are string with FDP */
				if (!strncmp(""Router"", (char *)pos, tlv_len))
					chassis->c_cap_enabled = LLDP_CAP_ROUTER;
				else if (!strncmp(""Switch"", (char *)pos, tlv_len))
					chassis->c_cap_enabled = LLDP_CAP_BRIDGE;
				else if (!strncmp(""Bridge"", (char *)pos, tlv_len))
					chassis->c_cap_enabled = LLDP_CAP_REPEATER;
				else
					chassis->c_cap_enabled = LLDP_CAP_STATION;
				chassis->c_cap_available = chassis->c_cap_enabled;
				break;
			}
#  endif
			CHECK_TLV_SIZE(4, ""Capabilities"");
			caps = PEEK_UINT32;
			if (caps & CDP_CAP_ROUTER)
				chassis->c_cap_enabled |= LLDP_CAP_ROUTER;
			if (caps & 0x0e) chassis->c_cap_enabled |= LLDP_CAP_BRIDGE;
			if (chassis->c_cap_enabled == 0)
				chassis->c_cap_enabled = LLDP_CAP_STATION;
			chassis->c_cap_available = chassis->c_cap_enabled;
			break;
		case CDP_TLV_SOFTWARE:
			software_len = tlv_len;
			(void)PEEK_SAVE(software);
			break;
		case CDP_TLV_PLATFORM:
			platform_len = tlv_len;
			(void)PEEK_SAVE(platform);
			break;
#  ifdef ENABLE_DOT1
		case CDP_TLV_NATIVEVLAN:
			CHECK_TLV_SIZE(2, ""Native VLAN"");
			if ((vlan = (struct lldpd_vlan *)calloc(1,
				 sizeof(struct lldpd_vlan))) == NULL) {
				log_warn(""cdp"",
				    ""unable to alloc vlan ""
				    ""structure for ""
				    ""tlv received on %s"",
				    hardware->h_ifname);
				goto malformed;
			}
			vlan->v_vid = port->p_pvid = PEEK_UINT16;
			if (asprintf(&vlan->v_name, ""VLAN #%d"", vlan->v_vid) == -1) {
				log_warn(""cdp"",
				    ""unable to alloc VLAN name for ""
				    ""TLV received on %s"",
				    hardware->h_ifname);
				free(vlan);
				goto malformed;
			}
			TAILQ_INSERT_TAIL(&port->p_vlans, vlan, v_entries);
			break;
#  endif
#  ifdef ENABLE_DOT3
		case CDP_TLV_POWER_AVAILABLE:
			CHECK_TLV_SIZE(12, ""Power Available"");
			/* check if it is a respone to a request id */
			if (PEEK_UINT16 > 0) {
				port->p_cdp_power.management_id = PEEK_UINT16;
				port->p_power.allocated = PEEK_UINT32;
				port->p_power.allocated /= 100;
				port->p_power.supported = 1;
				port->p_power.enabled = 1;
				port->p_power.devicetype = LLDP_DOT3_POWER_PSE;
				port->p_power.powertype = LLDP_DOT3_POWER_8023AT_TYPE2;
				log_debug(""cdp"", ""Allocated power %d00"",
				    port->p_power.allocated);
				if (port->p_power.allocated > CDP_CLASS_3_MAX_PSE_POE) {
					port->p_power.allocated -=
					    CDP_SWITCH_POE_CLASS_4_OFFSET;
				} else if (port->p_power.allocated >
				    CDP_SWITCH_POE_CLASS_3_OFFSET) {
					port->p_power.allocated -=
					    CDP_SWITCH_POE_CLASS_3_OFFSET;
				} else {
					port->p_power.allocated = 0;
				}
				port->p_power.requested =
				    hardware->h_lport.p_power.requested;
			}
			break;
#  endif
		default:
			log_debug(""cdp"", ""unknown CDP/FDP TLV type (%d) received on %s"",
			    ntohs(tlv_type), hardware->h_ifname);
			hardware->h_rx_unrecognized_cnt++;
		}
		PEEK_DISCARD(tlv + tlv_len - pos);
	}
	if (!software && platform) {
		if ((chassis->c_descr = (char *)calloc(1, platform_len + 1)) == NULL) {
			log_warn(""cdp"",
			    ""unable to allocate memory for chassis description"");
			goto malformed;
		}
		memcpy(chassis->c_descr, platform, platform_len);
	} else if (software && !platform) {
		if ((chassis->c_descr = (char *)calloc(1, software_len + 1)) == NULL) {
			log_warn(""cdp"",
			    ""unable to allocate memory for chassis description"");
			goto malformed;
		}
		memcpy(chassis->c_descr, software, software_len);
	} else if (software && platform) {
#  define CONCAT_PLATFORM "" running on\n""
		if ((chassis->c_descr = (char *)calloc(1,
			 software_len + platform_len + strlen(CONCAT_PLATFORM) + 1)) ==
		    NULL) {
			log_warn(""cdp"",
			    ""unable to allocate memory for chassis description"");
			goto malformed;
		}
		memcpy(chassis->c_descr, platform, platform_len);
		memcpy(chassis->c_descr + platform_len, CONCAT_PLATFORM,
		    strlen(CONCAT_PLATFORM));
		memcpy(chassis->c_descr + platform_len + strlen(CONCAT_PLATFORM),
		    software, software_len);
	}
	if ((chassis->c_id == NULL) || (port->p_id == NULL) ||
	    (chassis->c_name == NULL) || (chassis->c_descr == NULL) ||
	    (port->p_descr == NULL) || (port->p_ttl == 0) ||
	    (chassis->c_cap_enabled == 0)) {
		log_warnx(""cdp"",
		    ""some mandatory CDP/FDP tlv are missing for frame received on %s"",
		    hardware->h_ifname);
		goto malformed;
	}
	*newchassis = chassis;
	*newport = port;
	return 1;

malformed:
	lldpd_chassis_cleanup(chassis, 1);
	lldpd_port_cleanup(port, 1);
	free(port);
	return -1;
}","int
cdp_decode(struct lldpd *VAR_0, char *VAR_1, int VAR_2, struct lldpd_hardware *VAR_3,
    struct lldpd_chassis **VAR_4, struct lldpd_port **VAR_5)
{
	struct lldpd_chassis *VAR_6;
	struct lldpd_port *VAR_7;
	struct lldpd_mgmt *VAR_8;
	struct in_addr VAR_9;
#  if 0
	u_int16_t VAR_10;
#  endif
	u_int8_t *VAR_11 = NULL, *VAR_12 = NULL;
	int VAR_13 = 0, VAR_14 = 0, VAR_15, VAR_16, VAR_17, VAR_18;
	const unsigned char VAR_19[] = VAR_20;
#  ifdef VAR_21
	const unsigned char VAR_22[] = VAR_20;
	int VAR_23 = 0;
#  endif
	u_int8_t *VAR_24, *VAR_25, *VAR_26, *VAR_27;
	int VAR_28, VAR_29, VAR_30, VAR_31, VAR_32, VAR_33;
#  ifdef VAR_34
	struct lldpd_vlan *VAR_35;
#  endif

	log_debug(""cdp"", ""decode CDP frame received on %s"", VAR_3->h_ifname);

	if ((VAR_6 = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {
		log_warn(""cdp"", ""failed to allocate remote chassis"");
		return -1;
	}
	TAILQ_INIT(&VAR_6->c_mgmt);
	if ((VAR_7 = calloc(1, sizeof(struct lldpd_port))) == NULL) {
		log_warn(""cdp"", ""failed to allocate remote port"");
		free(VAR_6);
		return -1;
	}
#  ifdef VAR_34
	TAILQ_INIT(&VAR_7->p_vlans);
#  endif

	VAR_28 = VAR_2;
	VAR_24 = (u_int8_t *)VAR_1;

	if (VAR_28 < 2 * VAR_36 + sizeof(u_int16_t) /* COMMENT_0 */ +
		8 /* COMMENT_1 */ + 4 /* COMMENT_2 */) {
		log_warn(""cdp"", ""too short CDP/FDP frame received on %s"",
		    VAR_3->h_ifname);
		goto malformed;
	}

	if (PEEK_CMP(VAR_19, sizeof(VAR_19)) != 0) {
#  ifdef VAR_21
		PEEK_RESTORE((u_int8_t *)VAR_1);
		if (PEEK_CMP(VAR_22, sizeof(VAR_22)) != 0)
			VAR_23 = 1;
		else {
#  endif
			log_info(""cdp"",
			    ""frame not targeted at CDP/FDP multicast address received on %s"",
			    VAR_3->h_ifname);
			goto malformed;
#  ifdef VAR_21
		}
#  endif
	}
	PEEK_DISCARD(VAR_36); /* COMMENT_3 */
	VAR_29 = VAR_37;
	if (VAR_29 > VAR_28) {
		log_warnx(""cdp"", ""incorrect 802.3 frame size reported on %s"",
		    VAR_3->h_ifname);
		goto malformed;
	}

	/* COMMENT_4 */
	VAR_28 = VAR_29;

	PEEK_DISCARD(6); /* COMMENT_5 */
	VAR_15 = VAR_37;
	if (VAR_15 != VAR_38) {
		if ((VAR_15 != VAR_39) && (VAR_15 != VAR_40) &&
		    (VAR_15 != VAR_41) && (VAR_15 != VAR_42) &&
		    (VAR_15 != VAR_43) && (VAR_15 != VAR_44) &&
		    (VAR_15 != VAR_45))
			log_debug(""cdp"", ""incorrect LLC protocol ID received on %s"",
			    VAR_3->h_ifname);
		goto malformed;
	}

#  if 0
	/* COMMENT_6 */
	VAR_10 = frame_checksum(VAR_24, VAR_29 - 8,
#    ifdef VAR_21
	    !VAR_23		/* COMMENT_7 */
#    else
	    1			/* COMMENT_8 */
#    endif
		);
	if (VAR_10 != 0) {
		log_info(""cdp"", ""incorrect CDP/FDP checksum for frame received on %s (%d)"",
			  VAR_3->h_ifname, VAR_10);
		goto malformed;
	}
#  endif

	/* COMMENT_9 */
	VAR_16 = VAR_46;
	if ((VAR_16 != 1) && (VAR_16 != 2)) {
		log_warnx(""cdp"",
		    ""incorrect CDP/FDP version (%d) for frame received on %s"", VAR_16,
		    VAR_3->h_ifname);
		goto malformed;
	}
	VAR_7->p_ttl = VAR_46; /* COMMENT_10 */
	VAR_47;	  /* COMMENT_11 */

	while (VAR_28) {
		if (VAR_28 < 4) {
			log_warnx(""cdp"",
			    ""CDP/FDP TLV header is too large for ""
			    ""frame received on %s"",
			    VAR_3->h_ifname);
			goto malformed;
		}
		VAR_30 = VAR_37;
		VAR_31 = VAR_37 - 4;

		(void)PEEK_SAVE(VAR_25);
		if ((VAR_31 < 0) || (VAR_28 < VAR_31)) {
			log_warnx(""cdp"",
			    ""incorrect size in CDP/FDP TLV header for frame ""
			    ""received on %s"",
			    VAR_3->h_ifname);
			goto malformed;
		}
		switch (VAR_30) {
		case VAR_48:
			free(VAR_6->c_name);
			if ((VAR_6->c_name = (char *)calloc(1, VAR_31 + 1)) ==
			    NULL) {
				log_warn(""cdp"",
				    ""unable to allocate memory for chassis name"");
				goto malformed;
			}
			PEEK_BYTES(VAR_6->c_name, VAR_31);
			VAR_6->c_id_subtype = VAR_49;
			free(VAR_6->c_id);
			if ((VAR_6->c_id = (char *)malloc(VAR_31)) == NULL) {
				log_warn(""cdp"",
				    ""unable to allocate memory for chassis ID"");
				goto malformed;
			}
			memcpy(VAR_6->c_id, VAR_6->c_name, VAR_31);
			VAR_6->c_id_len = VAR_31;
			break;
		case VAR_50:
			CHECK_TLV_SIZE(4, ""Address"");
			VAR_32 = VAR_31 - 4;
			for (VAR_17 = VAR_51; VAR_17 > 0; VAR_17--) {
				(void)PEEK_SAVE(VAR_26);
				/* COMMENT_12 */
				if (VAR_32 < 2) {
					log_warn(""cdp"",
					    ""too short address subframe ""
					    ""received on %s"",
					    VAR_3->h_ifname);
					goto malformed;
				}
				VAR_52;
				VAR_32--;
				VAR_33 = VAR_46;
				VAR_32--;
				if (VAR_32 < VAR_33 + 2) {
					log_warn(""cdp"",
					    ""too short address subframe ""
					    ""received on %s"",
					    VAR_3->h_ifname);
					goto malformed;
				}
				PEEK_DISCARD(VAR_33);
				VAR_32 -= VAR_33;
				VAR_33 = VAR_37;
				VAR_32 -= 2;
				if (VAR_32 < VAR_33) {
					log_warn(""cdp"",
					    ""too short address subframe ""
					    ""received on %s"",
					    VAR_3->h_ifname);
					goto malformed;
				}
				PEEK_DISCARD(VAR_33);
				VAR_32 -= VAR_33;
				(void)PEEK_SAVE(VAR_27);
				/* COMMENT_13 */
                      
				PEEK_RESTORE(VAR_26);
				if ((VAR_46 == 1) && (VAR_46 == 1) &&
				    (VAR_46 == VAR_53) &&
				    (VAR_37 == sizeof(struct in_addr))) {
					PEEK_BYTES(&VAR_9, sizeof(struct in_addr));
					VAR_8 = lldpd_alloc_mgmt(VAR_54, &VAR_9,
					    sizeof(struct in_addr), 0);
					if (VAR_8 == NULL) {
						if (VAR_55 == VAR_56)
							log_warn(""cdp"",
							    ""unable to allocate memory for management address"");
						else
							log_warn(""cdp"",
							    ""too large management address received on %s"",
							    VAR_3->h_ifname);
						goto malformed;
					}
					TAILQ_INSERT_TAIL(&VAR_6->c_mgmt, VAR_8,
					    VAR_57);
				}
				/* COMMENT_15 */
				PEEK_RESTORE(VAR_27);
			}
			break;
		case VAR_58:
			if (VAR_31 == 0) {
				log_warn(""cdp"", ""too short port description received"");
				goto malformed;
			}
			free(VAR_7->p_descr);
			if ((VAR_7->p_descr = (char *)calloc(1, VAR_31 + 1)) == NULL) {
				log_warn(""cdp"",
				    ""unable to allocate memory for port description"");
				goto malformed;
			}
			PEEK_BYTES(VAR_7->p_descr, VAR_31);
			VAR_7->p_id_subtype = VAR_59;
			free(VAR_7->p_id);
			if ((VAR_7->p_id = (char *)calloc(1, VAR_31)) == NULL) {
				log_warn(""cdp"",
				    ""unable to allocate memory for port ID"");
				goto malformed;
			}
			memcpy(VAR_7->p_id, VAR_7->p_descr, VAR_31);
			VAR_7->p_id_len = VAR_31;
			break;
		case VAR_60:
#  ifdef VAR_21
			if (VAR_23) {
				/* COMMENT_16 */
				if (!strncmp(""Router"", (char *)VAR_24, VAR_31))
					VAR_6->c_cap_enabled = VAR_61;
				else if (!strncmp(""Switch"", (char *)VAR_24, VAR_31))
					VAR_6->c_cap_enabled = VAR_62;
				else if (!strncmp(""Bridge"", (char *)VAR_24, VAR_31))
					VAR_6->c_cap_enabled = VAR_63;
				else
					VAR_6->c_cap_enabled = VAR_64;
				VAR_6->c_cap_available = VAR_6->c_cap_enabled;
				break;
			}
#  endif
			CHECK_TLV_SIZE(4, ""Capabilities"");
			VAR_18 = VAR_51;
			if (VAR_18 & VAR_65)
				VAR_6->c_cap_enabled |= VAR_61;
			if (VAR_18 & 0x0e) VAR_6->c_cap_enabled |= VAR_62;
			if (VAR_6->c_cap_enabled == 0)
				VAR_6->c_cap_enabled = VAR_64;
			VAR_6->c_cap_available = VAR_6->c_cap_enabled;
			break;
		case VAR_66:
			VAR_13 = VAR_31;
			(void)PEEK_SAVE(VAR_11);
			break;
		case VAR_67:
			VAR_14 = VAR_31;
			(void)PEEK_SAVE(VAR_12);
			break;
#  ifdef VAR_34
		case VAR_68:
			CHECK_TLV_SIZE(2, ""Native VLAN"");
			if ((VAR_35 = (struct lldpd_vlan *)calloc(1,
				 sizeof(struct lldpd_vlan))) == NULL) {
				log_warn(""cdp"",
				    ""unable to alloc vlan ""
				    ""structure for ""
				    ""tlv received on %s"",
				    VAR_3->h_ifname);
				goto malformed;
			}
			VAR_35->v_vid = VAR_7->p_pvid = VAR_37;
			if (asprintf(&VAR_35->v_name, ""VLAN #%d"", VAR_35->v_vid) == -1) {
				log_warn(""cdp"",
				    ""unable to alloc VLAN name for ""
				    ""TLV received on %s"",
				    VAR_3->h_ifname);
				free(VAR_35);
				goto malformed;
			}
			TAILQ_INSERT_TAIL(&VAR_7->p_vlans, VAR_35, VAR_69);
			break;
#  endif
#  ifdef VAR_70
		case VAR_71:
			CHECK_TLV_SIZE(12, ""Power Available"");
			/* COMMENT_17 */
			if (VAR_37 > 0) {
				VAR_7->p_cdp_power.management_id = VAR_37;
				VAR_7->p_power.allocated = VAR_51;
				VAR_7->p_power.allocated /= 100;
				VAR_7->p_power.supported = 1;
				VAR_7->p_power.enabled = 1;
				VAR_7->p_power.devicetype = VAR_72;
				VAR_7->p_power.powertype = VAR_73;
				log_debug(""cdp"", ""Allocated power %d00"",
				    VAR_7->p_power.allocated);
				if (VAR_7->p_power.allocated > VAR_74) {
					VAR_7->p_power.allocated -=
					    VAR_75;
				} else if (VAR_7->p_power.allocated >
				    VAR_76) {
					VAR_7->p_power.allocated -=
					    VAR_76;
				} else {
					VAR_7->p_power.allocated = 0;
				}
				VAR_7->p_power.requested =
				    VAR_3->h_lport.p_power.requested;
			}
			break;
#  endif
		default:
			log_debug(""cdp"", ""unknown CDP/FDP TLV type (%d) received on %s"",
			    ntohs(VAR_30), VAR_3->h_ifname);
			VAR_3->h_rx_unrecognized_cnt++;
		}
		PEEK_DISCARD(VAR_25 + VAR_31 - VAR_24);
	}
	if (!VAR_11 && VAR_12) {
		if ((VAR_6->c_descr = (char *)calloc(1, VAR_14 + 1)) == NULL) {
			log_warn(""cdp"",
			    ""unable to allocate memory for chassis description"");
			goto malformed;
		}
		memcpy(VAR_6->c_descr, VAR_12, VAR_14);
	} else if (VAR_11 && !VAR_12) {
		if ((VAR_6->c_descr = (char *)calloc(1, VAR_13 + 1)) == NULL) {
			log_warn(""cdp"",
			    ""unable to allocate memory for chassis description"");
			goto malformed;
		}
		memcpy(VAR_6->c_descr, VAR_11, VAR_13);
	} else if (VAR_11 && VAR_12) {
#  define VAR_77 "" running on\n""
		if ((VAR_6->c_descr = (char *)calloc(1,
			 VAR_13 + VAR_14 + strlen(VAR_77) + 1)) ==
		    NULL) {
			log_warn(""cdp"",
			    ""unable to allocate memory for chassis description"");
			goto malformed;
		}
		memcpy(VAR_6->c_descr, VAR_12, VAR_14);
		memcpy(VAR_6->c_descr + VAR_14, VAR_77,
		    strlen(VAR_77));
		memcpy(VAR_6->c_descr + VAR_14 + strlen(VAR_77),
		    VAR_11, VAR_13);
	}
	if ((VAR_6->c_id == NULL) || (VAR_7->p_id == NULL) ||
	    (VAR_6->c_name == NULL) || (VAR_6->c_descr == NULL) ||
	    (VAR_7->p_descr == NULL) || (VAR_7->p_ttl == 0) ||
	    (VAR_6->c_cap_enabled == 0)) {
		log_warnx(""cdp"",
		    ""some mandatory CDP/FDP tlv are missing for frame received on %s"",
		    VAR_3->h_ifname);
		goto malformed;
	}
	*VAR_4 = VAR_6;
	*VAR_5 = VAR_7;
	return 1;

malformed:
	lldpd_chassis_cleanup(VAR_6, 1);
	lldpd_port_cleanup(VAR_7, 1);
	free(VAR_7);
	return -1;
}",lldpd/a9aeabdf879c25c584852a0bb5523837632f099b/cdp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -188,6 +188,7 @@
 					goto malformed;
 				}
 				PEEK_DISCARD(address_len);
+				addresses_len -= address_len;
 				(void)PEEK_SAVE(pos_next_address);
 				/* Next, we go back and try to extract
 				   IPv4 address */","{'deleted_lines': [], 'added_lines': ['\t\t\t\taddresses_len -= address_len;']}",True,"An issue was discovered in lldpd before 1.0.17. By crafting a CDP PDU packet with specific CDP_TLV_ADDRESSES TLVs, a malicious actor can remotely force the lldpd daemon to perform an out-of-bounds read on heap memory. This occurs in cdp_decode in daemon/protocols/cdp.c.",9.8,CRITICAL,3,test,2023-04-12T05:38:31Z,4
CVE-2023-31610,['CWE-89'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,openlink/virtuoso-opensource,Fixed missing arguments in table def (fixes #1118),2ed10333e6e973c2b3e1e60ba854ef0dd12afe07,https://github.com/openlink/virtuoso-opensource/commit/2ed10333e6e973c2b3e1e60ba854ef0dd12afe07,libsrc/Wi/sqlstmts.c,sqlc_table_from_select_view,"ST *
sqlc_table_from_select_view (query_t * view_qr, ST * view_def)
{
int inx;
state_slot_t **sel_out = view_qr->qr_select_node->sel_out_slots;
int n_out = BOX_ELEMENTS (sqlp_union_tree_select (view_def->_.view_def.exp)->_.select_stmt.selection);
dk_set_t cols = NULL;
dk_set_t key_parts = NULL;
DO_BOX (state_slot_t *, ssl, inx, sel_out)
{
dtp_t sl_dtp;
uint32 sl_prec;
char sl_scale;
int col_is_indexable;
if (inx >= n_out)
break;
if (SSL_REF == ssl->ssl_type)
ssl = ((state_slot_ref_t*)ssl)->sslr_ssl;
sl_dtp = ssl->ssl_dtp;
sl_prec = ssl->ssl_prec;
sl_scale = ssl->ssl_scale;
if (!sl_dtp || !dtp_is_column_compatible (sl_dtp))
{
sl_dtp = DV_LONG_STRING;
sl_prec = 0;
sl_scale = 0;
}
col_is_indexable = !(
(DV_BLOB == sl_dtp) || (DV_BLOB_WIDE == sl_dtp) ||
(DV_BLOB_BIN == sl_dtp) || (DV_BLOB_XPER == sl_dtp) );
t_dk_set_append_1 (&cols, (void *) t_box_string (ssl->ssl_name));
t_dk_set_append_1 (&cols,
t_list (2, t_list (3, t_box_num (sl_dtp),
t_box_num (sl_prec),
t_box_num (sl_scale)),
NULL));
if (col_is_indexable)
t_dk_set_append_1 (&key_parts, (void *) t_box_string (ssl->ssl_name));
}
END_DO_BOX;
t_dk_set_append_1 (&cols, NULL);
t_dk_set_append_1 (&cols,
t_list (5, INDEX_DEF, NULL, NULL, t_list_to_array (key_parts), NULL));
return ((ST *) t_list (3,
TABLE_DEF,
t_box_string (view_def->_.view_def.name),
t_list_to_array (cols)));
}","ST *
sqlc_table_from_select_view (query_t * VAR_0, ST * VAR_1)
{
int VAR_2;
state_slot_t **VAR_3 = VAR_0->qr_select_node->sel_out_slots;
int VAR_4 = BOX_ELEMENTS (sqlp_union_tree_select (VAR_1->_.view_def.exp)->_.select_stmt.selection);
dk_set_t VAR_5 = NULL;
dk_set_t VAR_6 = NULL;
VAR_7 (state_slot_t *, VAR_8, VAR_2, VAR_3)
{
dtp_t VAR_9;
uint32 VAR_10;
char VAR_11;
int VAR_12;
if (VAR_2 >= VAR_4)
break;
if (VAR_13 == VAR_8->ssl_type)
VAR_8 = ((state_slot_ref_t*)VAR_8)->sslr_ssl;
VAR_9 = VAR_8->ssl_dtp;
VAR_10 = VAR_8->ssl_prec;
VAR_11 = VAR_8->ssl_scale;
if (!VAR_9 || !dtp_is_column_compatible (VAR_9))
{
VAR_9 = VAR_14;
VAR_10 = 0;
VAR_11 = 0;
}
VAR_12 = !(
(VAR_15 == VAR_9) || (VAR_16 == VAR_9) ||
(VAR_17 == VAR_9) || (VAR_18 == VAR_9) );
t_dk_set_append_1 (&VAR_5, (void *) t_box_string (VAR_8->ssl_name));
t_dk_set_append_1 (&VAR_5,
t_list (2, t_list (3, t_box_num (VAR_9),
t_box_num (VAR_10),
t_box_num (VAR_11)),
NULL));
if (VAR_12)
t_dk_set_append_1 (&VAR_6, (void *) t_box_string (VAR_8->ssl_name));
}
VAR_19;
t_dk_set_append_1 (&VAR_5, NULL);
t_dk_set_append_1 (&VAR_5,
t_list (5, VAR_20, NULL, NULL, t_list_to_array (VAR_6), NULL));
return ((ST *) t_list (3,
VAR_21,
t_box_string (VAR_1->_.view_def.name),
t_list_to_array (VAR_5)));
}",openlink/virtuoso-opensource/2ed10333e6e973c2b3e1e60ba854ef0dd12afe07/sqlstmts.c/vul/before/1.json,"ST *
sqlc_table_from_select_view (query_t * view_qr, ST * view_def)
{
  int inx;
  /* make a create table with the view's out cols and data types */
  state_slot_t **sel_out = view_qr->qr_select_node->sel_out_slots;
  int n_out = BOX_ELEMENTS (sqlp_union_tree_select (view_def->_.view_def.exp)->_.select_stmt.selection);
  /* length of select list, not out box cause out bpx may have co and extras */
  dk_set_t cols = NULL;
  dk_set_t key_parts = NULL;

  DO_BOX (state_slot_t *, ssl, inx, sel_out)
  {
    dtp_t sl_dtp;
    uint32 sl_prec;
    char sl_scale;
    int col_is_indexable;
    if (inx >= n_out)
      break;			/* only as many as in selection */
    if (SSL_REF == ssl->ssl_type)
      ssl = ((state_slot_ref_t*)ssl)->sslr_ssl;
    sl_dtp = ssl->ssl_dtp;
    sl_prec = ssl->ssl_prec;
    sl_scale = ssl->ssl_scale;

    if (!sl_dtp || !dtp_is_column_compatible (sl_dtp))
      {
	sl_dtp = DV_LONG_STRING;
	sl_prec = 0;
	sl_scale = 0;
      }
    col_is_indexable = !(
      (DV_BLOB == sl_dtp) || (DV_BLOB_WIDE == sl_dtp) ||
      (DV_BLOB_BIN == sl_dtp) || (DV_BLOB_XPER == sl_dtp) );
    t_dk_set_append_1 (&cols, (void *) t_box_string (ssl->ssl_name));
    t_dk_set_append_1 (&cols,
	t_list (2, t_list (3, t_box_num (sl_dtp),
	    t_box_num (sl_prec),
	    t_box_num (sl_scale)),
	    NULL));
    if (col_is_indexable)
      t_dk_set_append_1 (&key_parts, (void *) t_box_string (ssl->ssl_name));
  }
  END_DO_BOX;
  t_dk_set_append_1 (&cols, NULL);
  t_dk_set_append_1 (&cols,
      t_list (5, INDEX_DEF, NULL, NULL, t_list_to_array (key_parts), NULL));

  return ((ST *) t_list (5,
      TABLE_DEF,
      t_box_string (view_def->_.view_def.name),
      t_list_to_array (cols), 0, 0));
}","ST *
sqlc_table_from_select_view (query_t * VAR_0, ST * VAR_1)
{
  int VAR_2;
  /* COMMENT_0 */
  state_slot_t **VAR_3 = VAR_0->qr_select_node->sel_out_slots;
  int VAR_4 = BOX_ELEMENTS (sqlp_union_tree_select (VAR_1->_.view_def.exp)->_.select_stmt.selection);
  /* COMMENT_1 */
  dk_set_t VAR_5 = NULL;
  dk_set_t VAR_6 = NULL;

  VAR_7 (state_slot_t *, VAR_8, VAR_2, VAR_3)
  {
    dtp_t VAR_9;
    uint32 VAR_10;
    char VAR_11;
    int VAR_12;
    if (VAR_2 >= VAR_4)
      break;			/* COMMENT_2 */
    if (VAR_13 == VAR_8->ssl_type)
      VAR_8 = ((state_slot_ref_t*)VAR_8)->sslr_ssl;
    VAR_9 = VAR_8->ssl_dtp;
    VAR_10 = VAR_8->ssl_prec;
    VAR_11 = VAR_8->ssl_scale;

    if (!VAR_9 || !dtp_is_column_compatible (VAR_9))
      {
	VAR_9 = VAR_14;
	VAR_10 = 0;
	VAR_11 = 0;
      }
    VAR_12 = !(
      (VAR_15 == VAR_9) || (VAR_16 == VAR_9) ||
      (VAR_17 == VAR_9) || (VAR_18 == VAR_9) );
    t_dk_set_append_1 (&VAR_5, (void *) t_box_string (VAR_8->ssl_name));
    t_dk_set_append_1 (&VAR_5,
	t_list (2, t_list (3, t_box_num (VAR_9),
	    t_box_num (VAR_10),
	    t_box_num (VAR_11)),
	    NULL));
    if (VAR_12)
      t_dk_set_append_1 (&VAR_6, (void *) t_box_string (VAR_8->ssl_name));
  }
  VAR_19;
  t_dk_set_append_1 (&VAR_5, NULL);
  t_dk_set_append_1 (&VAR_5,
      t_list (5, VAR_20, NULL, NULL, t_list_to_array (VAR_6), NULL));

  return ((ST *) t_list (5,
      VAR_21,
      t_box_string (VAR_1->_.view_def.name),
      t_list_to_array (VAR_5), 0, 0));
}",openlink/virtuoso-opensource/2ed10333e6e973c2b3e1e60ba854ef0dd12afe07/sqlstmts.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -46,8 +46,8 @@
   t_dk_set_append_1 (&cols,
       t_list (5, INDEX_DEF, NULL, NULL, t_list_to_array (key_parts), NULL));
 
-  return ((ST *) t_list (3,
+  return ((ST *) t_list (5,
       TABLE_DEF,
       t_box_string (view_def->_.view_def.name),
-      t_list_to_array (cols)));
+      t_list_to_array (cols), 0, 0));
 }","{'deleted_lines': ['  return ((ST *) t_list (3,', '      t_list_to_array (cols)));'], 'added_lines': ['  return ((ST *) t_list (5,', '      t_list_to_array (cols), 0, 0));']}",True,An issue in the _IO_default_xsputn component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.,7.5,HIGH,2,test,2023-04-13T11:51:37Z,4
CVE-2023-31610,['CWE-89'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,openlink/virtuoso-opensource,Fixed missing arguments in table def (fixes #1118),2ed10333e6e973c2b3e1e60ba854ef0dd12afe07,https://github.com/openlink/virtuoso-opensource/commit/2ed10333e6e973c2b3e1e60ba854ef0dd12afe07,libsrc/Wi/sqlstmts.c,sqlc_table_from_view,"ST *
sqlc_table_from_view (query_t * view_qr, ST * view_def)
{
if (view_qr)
return (sqlc_table_from_select_view  (view_qr, view_def));
else
{
#if 0
caddr_t *col_defs;
int inx;
int n_cols = BOX_ELEMENTS (view_def->_.view_def.exp->_.proc_table.cols);
col_defs = (caddr_t *) t_alloc_box (
n_cols * sizeof (caddr_t) +
+ 2 * box_length (view_def->_.view_def.exp->_.proc_table.params),
DV_ARRAY_OF_POINTER);
for (inx = 0; inx < n_cols; inx++)
col_defs[inx] = t_box_copy_tree ((caddr_t) view_def->_.view_def.exp->_.proc_table.cols[inx]);
DO_BOX (caddr_t, param, inx, view_def->_.view_def.exp->_.proc_table.params)
{
col_defs [n_cols + inx * 2] = t_box_copy_tree (param);
col_defs [n_cols + inx * 2 + 1] =
(caddr_t) t_list (2,
t_list (2, (long) DV_ANY, (long) 0),
NULL);
}
END_DO_BOX;
return ((ST*) t_list (3, TABLE_DEF, t_box_copy_tree (view_def->_.view_def.name),
(caddr_t) col_defs));
#else
return ((ST*) t_list (3, TABLE_DEF, t_box_copy_tree (view_def->_.view_def.name),
t_box_copy_tree ((caddr_t) view_def->_.view_def.exp->_.proc_table.cols)));
#endif
}
}","ST *
sqlc_table_from_view (query_t * VAR_0, ST * VAR_1)
{
if (VAR_0)
return (sqlc_table_from_select_view  (VAR_0, VAR_1));
else
{
#if 0
caddr_t *VAR_2;
int VAR_3;
int VAR_4 = BOX_ELEMENTS (VAR_1->_.view_def.exp->_.proc_table.cols);
VAR_2 = (caddr_t *) t_alloc_box (
VAR_4 * sizeof (caddr_t) +
+ 2 * box_length (VAR_1->_.view_def.exp->_.proc_table.params),
VAR_5);
for (VAR_3 = 0; VAR_3 < VAR_4; VAR_3++)
VAR_2[VAR_3] = t_box_copy_tree ((caddr_t) VAR_1->_.view_def.exp->_.proc_table.cols[VAR_3]);
DO_BOX (caddr_t, VAR_6, VAR_3, VAR_1->_.view_def.exp->_.proc_table.params)
{
VAR_2 [VAR_4 + VAR_3 * 2] = t_box_copy_tree (VAR_6);
VAR_2 [VAR_4 + VAR_3 * 2 + 1] =
(caddr_t) t_list (2,
t_list (2, (long) VAR_7, (long) 0),
NULL);
}
VAR_8;
return ((ST*) t_list (3, VAR_9, t_box_copy_tree (VAR_1->_.view_def.name),
(caddr_t) VAR_2));
#else
return ((ST*) t_list (3, VAR_9, t_box_copy_tree (VAR_1->_.view_def.name),
t_box_copy_tree ((caddr_t) VAR_1->_.view_def.exp->_.proc_table.cols)));
#endif
}
}",openlink/virtuoso-opensource/2ed10333e6e973c2b3e1e60ba854ef0dd12afe07/sqlstmts.c/vul/before/0.json,"ST *
sqlc_table_from_view (query_t * view_qr, ST * view_def)
{
  if (view_qr)
    return (sqlc_table_from_select_view  (view_qr, view_def));
  else
    {
/*GK: enable that if proc view params to participate in 'select *' */
#if 0
      caddr_t *col_defs;
      int inx;
      int n_cols = BOX_ELEMENTS (view_def->_.view_def.exp->_.proc_table.cols);

      col_defs = (caddr_t *) t_alloc_box (
	  n_cols * sizeof (caddr_t) +
	  + 2 * box_length (view_def->_.view_def.exp->_.proc_table.params),
	  DV_ARRAY_OF_POINTER);

      for (inx = 0; inx < n_cols; inx++)
	col_defs[inx] = t_box_copy_tree ((caddr_t) view_def->_.view_def.exp->_.proc_table.cols[inx]);

      DO_BOX (caddr_t, param, inx, view_def->_.view_def.exp->_.proc_table.params)
	{
	  col_defs [n_cols + inx * 2] = t_box_copy_tree (param);
	  /* GK : = ANY */
	  col_defs [n_cols + inx * 2 + 1] =
	      (caddr_t) t_list (2,
		  t_list (2, (long) DV_ANY, (long) 0),
		  NULL);
	}
      END_DO_BOX;
      return ((ST*) t_list (3, TABLE_DEF, t_box_copy_tree (view_def->_.view_def.name),
		    (caddr_t) col_defs));
#else
      return ((ST*) t_list (5, TABLE_DEF, t_box_copy_tree (view_def->_.view_def.name),
		    t_box_copy_tree ((caddr_t) view_def->_.view_def.exp->_.proc_table.cols), 0, 0));
#endif
    }
}","ST *
sqlc_table_from_view (query_t * VAR_0, ST * VAR_1)
{
  if (VAR_0)
    return (sqlc_table_from_select_view  (VAR_0, VAR_1));
  else
    {
/* COMMENT_0 */
#if 0
      caddr_t *VAR_2;
      int VAR_3;
      int VAR_4 = BOX_ELEMENTS (VAR_1->_.view_def.exp->_.proc_table.cols);

      VAR_2 = (caddr_t *) t_alloc_box (
	  VAR_4 * sizeof (caddr_t) +
	  + 2 * box_length (VAR_1->_.view_def.exp->_.proc_table.params),
	  VAR_5);

      for (VAR_3 = 0; VAR_3 < VAR_4; VAR_3++)
	VAR_2[VAR_3] = t_box_copy_tree ((caddr_t) VAR_1->_.view_def.exp->_.proc_table.cols[VAR_3]);

      DO_BOX (caddr_t, VAR_6, VAR_3, VAR_1->_.view_def.exp->_.proc_table.params)
	{
	  VAR_2 [VAR_4 + VAR_3 * 2] = t_box_copy_tree (VAR_6);
	  /* COMMENT_1 */
	  VAR_2 [VAR_4 + VAR_3 * 2 + 1] =
	      (caddr_t) t_list (2,
		  t_list (2, (long) VAR_7, (long) 0),
		  NULL);
	}
      VAR_8;
      return ((ST*) t_list (3, VAR_9, t_box_copy_tree (VAR_1->_.view_def.name),
		    (caddr_t) VAR_2));
#else
      return ((ST*) t_list (5, VAR_9, t_box_copy_tree (VAR_1->_.view_def.name),
		    t_box_copy_tree ((caddr_t) VAR_1->_.view_def.exp->_.proc_table.cols), 0, 0));
#endif
    }
}",openlink/virtuoso-opensource/2ed10333e6e973c2b3e1e60ba854ef0dd12afe07/sqlstmts.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -32,8 +32,8 @@
       return ((ST*) t_list (3, TABLE_DEF, t_box_copy_tree (view_def->_.view_def.name),
 		    (caddr_t) col_defs));
 #else
-      return ((ST*) t_list (3, TABLE_DEF, t_box_copy_tree (view_def->_.view_def.name),
-		    t_box_copy_tree ((caddr_t) view_def->_.view_def.exp->_.proc_table.cols)));
+      return ((ST*) t_list (5, TABLE_DEF, t_box_copy_tree (view_def->_.view_def.name),
+		    t_box_copy_tree ((caddr_t) view_def->_.view_def.exp->_.proc_table.cols), 0, 0));
 #endif
     }
 }","{'deleted_lines': ['      return ((ST*) t_list (3, TABLE_DEF, t_box_copy_tree (view_def->_.view_def.name),', '\t\t    t_box_copy_tree ((caddr_t) view_def->_.view_def.exp->_.proc_table.cols)));'], 'added_lines': ['      return ((ST*) t_list (5, TABLE_DEF, t_box_copy_tree (view_def->_.view_def.name),', '\t\t    t_box_copy_tree ((caddr_t) view_def->_.view_def.exp->_.proc_table.cols), 0, 0));']}",True,An issue in the _IO_default_xsputn component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.,7.5,HIGH,2,test,2023-04-13T11:51:37Z,4
CVE-2023-33658,['CWE-787'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,nanomq/NanoNNG,* FIX [transport] fix #1153 https://github.com/emqx/nanomq/issues/1153 for other transport,657e6c81c474bdee0e6413483b990e90610030c1,https://github.com/nanomq/NanoNNG/commit/657e6c81c474bdee0e6413483b990e90610030c1,src/sp/transport/mqttws/nmq_websocket.c,wstran_pipe_recv_cb,"static void
wstran_pipe_recv_cb(void *arg)
{
ws_pipe *p = arg;
nni_iov  iov[2];
uint8_t  rv;
uint32_t pos = 1;
uint64_t len = 0;
uint8_t *ptr;
nni_msg *smsg = NULL, *msg = NULL;
nni_aio *raio = p->rxaio;
nni_aio *uaio = NULL;
bool     ack  = false;
nni_mtx_lock(&p->mtx);
if (p->user_rxaio != NULL) {
uaio = p->user_rxaio;
}
if ((rv = nni_aio_result(raio)) != 0) {
log_warn("" recv aio error %s"", nng_strerror(rv));
goto reset;
}
msg = nni_aio_get_msg(raio);
if (nni_msg_header_len(msg) == 0 && nni_msg_len(msg) == 0) {
log_trace(""empty msg received! continue next receive"");
goto recv;
}
ptr = nni_msg_body(msg);
p->gotrxhead += nni_msg_len(msg);
log_trace(""#### wstran_pipe_recv_cb got %ld msg: %p %x %ld"",
p->gotrxhead, ptr, *ptr, nni_msg_len(msg));
if (p->tmp_msg == NULL && p->gotrxhead > 0) {
if ((rv = nni_msg_alloc(&p->tmp_msg, 0)) != 0) {
log_error(""mem error %ld\n"", (size_t) len);
goto reset;
}
}
nni_msg_append(p->tmp_msg, ptr, nni_msg_len(msg));
ptr = nni_msg_body(p->tmp_msg); 
if (p->wantrxhead == 0) {
if (p->gotrxhead == 1) {
goto recv;
}
len = get_var_integer(ptr, &pos);
if (*(ptr + pos - 1) > 0x7f) {
if (p->gotrxhead >= NNI_NANO_MAX_HEADER_SIZE) {
rv = NNG_EMSGSIZE;
goto reset;
}
} else {
p->wantrxhead = len + pos;
nni_msg_set_cmd_type(p->tmp_msg, *ptr & 0xf0);
}
}
if (p->gotrxhead >= p->wantrxhead) {
goto done;
}
recv:
nni_msg_free(msg);
nng_stream_recv(p->ws, raio);
nni_mtx_unlock(&p->mtx);
return;
done:
if (uaio == NULL) {
uaio = p->ep_aio;
}
if (uaio != NULL) {
if (p->gotrxhead+p->wantrxhead > p->conf->max_packet_size) {
log_trace(""size error 0x95\n"");
rv = NMQ_PACKET_TOO_LARGE;
goto recv_error;
}
p->gotrxhead  = 0;
p->wantrxhead = 0;
nni_msg_free(msg);
if (nni_msg_cmd_type(p->tmp_msg) == CMD_CONNECT) {
if (p->ws_param == NULL) {
conn_param_alloc(&p->ws_param);
}
if (conn_handler(nni_msg_body(p->tmp_msg), p->ws_param,
nni_msg_len(p->tmp_msg)) != 0) {
conn_param_free(p->ws_param);
rv = NNG_ECONNRESET;
goto reset;
}
if (p->ws_param->pro_ver == 5) {
p->qsend_quota = p->ws_param->rx_max;
}
if (p->ws_param->max_packet_size == 0) {
p->ws_param->max_packet_size =
p->conf->client_max_packet_size;
}
nni_msg_free(p->tmp_msg);
p->tmp_msg = NULL;
nni_aio_set_output(uaio, 0, p);
nni_aio_finish(uaio, 0, 0);
nni_mtx_unlock(&p->mtx);
return;
} else {
if (nni_msg_alloc(&smsg, 0) != 0) {
goto reset;
}
ws_msg_adaptor(ptr, smsg);
nni_msg_free(p->tmp_msg);
p->tmp_msg = NULL;
nni_msg_set_conn_param(smsg, p->ws_param);
}
uint8_t   qos_pac;
property *prop        = NULL;
uint8_t   reason_code = 0;
uint8_t   ack_cmd     = 0;
uint16_t packet_id = 0;
nni_msg *qmsg;
uint8_t  cmd = nni_msg_cmd_type(smsg);
if (cmd == CMD_PUBLISH) {
qos_pac = nni_msg_get_pub_qos(smsg);
if (qos_pac > 0) {
if (p->ws_param->pro_ver == 5) {
if (p->qrecv_quota > 0) {
p->qrecv_quota--;
} else {
rv = NMQ_RECEIVE_MAXIMUM_EXCEEDED;
goto recv_error;
}
}
if (qos_pac == 1) {
ack_cmd = CMD_PUBACK;
} else if (qos_pac == 2) {
ack_cmd = CMD_PUBREC;
}
packet_id = nni_msg_get_pub_pid(smsg);
ack       = true;
}
} else if (cmd == CMD_PUBREC) {
if (nni_mqtt_pubres_decode(smsg, &packet_id, &reason_code, &prop,
p->ws_param->pro_ver) != 0) {
log_trace(""decode PUBREC variable header failed!"");
}
ack_cmd = CMD_PUBREL;
ack     = true;
} else if (cmd == CMD_PUBREL) {
if (nni_mqtt_pubres_decode(smsg, &packet_id, &reason_code, &prop,
p->ws_param->pro_ver) != 0) {
log_trace(""decode PUBREL variable header failed!"");
}
ack_cmd = CMD_PUBCOMP;
ack     = true;
} else if (cmd == CMD_PUBACK || cmd == CMD_PUBCOMP) {
if (nni_mqtt_pubres_decode(smsg, &packet_id, &reason_code, &prop,
p->ws_param->pro_ver) != 0) {
log_trace(""decode PUBACK or PUBCOMP variable header ""
""failed!"");
}
if (p->ws_param->pro_ver == 5) {
property_free(prop);
p->qsend_quota++;
}
} else if (cmd == CMD_PINGREQ) {
ack = true;
}
if (ack == true) {
if ((rv = nni_msg_alloc(&qmsg, 0)) != 0) {
ack = false;
rv  = NMQ_SERVER_BUSY;
log_error(""ERROR: OOM in WebSocket"");
goto recv_error;
}
if (cmd == CMD_PINGREQ) {
uint8_t buf[2] = { CMD_PINGRESP, 0x00 };
nni_msg_set_cmd_type(qmsg, CMD_PINGRESP);
nni_msg_header_append(qmsg, buf, 2);
nng_aio_wait(p->qsaio);
iov[0].iov_len = nni_msg_header_len(qmsg);
iov[0].iov_buf = nni_msg_header(qmsg);
nni_aio_set_msg(p->qsaio, qmsg);
nni_aio_set_iov(p->qsaio, 1, iov);
nng_stream_send(p->ws, p->qsaio);
} else {
nni_msg_set_cmd_type(qmsg, ack_cmd);
nni_mqtt_msgack_encode(qmsg, packet_id, reason_code,
prop, p->ws_param->pro_ver);
nni_mqtt_pubres_header_encode(qmsg, ack_cmd);
nng_aio_wait(p->qsaio);
iov[0].iov_len = nni_msg_header_len(qmsg);
iov[0].iov_buf = nni_msg_header(qmsg);
iov[1].iov_len = nni_msg_len(qmsg);
iov[1].iov_buf = nni_msg_body(qmsg);
nni_aio_set_msg(p->qsaio, qmsg);
nni_aio_set_iov(p->qsaio, 2, iov);
nng_stream_send(p->ws, p->qsaio);
}
}
nni_aio_set_msg(uaio, smsg);
nni_aio_set_output(uaio, 0, p);
} else {
goto reset;
}
nni_mtx_unlock(&p->mtx);
nni_aio_finish(uaio, 0, nni_msg_len(smsg));
return;
reset:
p->gotrxhead  = 0;
p->wantrxhead = 0;
nng_stream_close(p->ws);
if (uaio != NULL) {
nni_aio_finish_error(uaio, rv);
} else if (p->ep_aio != NULL) {
nni_aio_finish_error(p->ep_aio, rv);
}
if (p->tmp_msg != NULL) {
smsg = p->tmp_msg;
nni_msg_free(smsg);
p->tmp_msg = NULL;
}
nni_mtx_unlock(&p->mtx);
return;
recv_error:
nni_pipe_bump_error(p->npipe, rv);
nni_mtx_unlock(&p->mtx);
nni_msg_free(msg);
log_error(""tcptran_pipe_recv_cb: recv error rv: %d\n"", rv);
return;
}","static void
wstran_pipe_recv_cb(void *VAR_0)
{
ws_pipe *VAR_1 = VAR_0;
nni_iov  VAR_2[2];
uint8_t  VAR_3;
uint32_t VAR_4 = 1;
uint64_t VAR_5 = 0;
uint8_t *VAR_6;
nni_msg *VAR_7 = NULL, *VAR_8 = NULL;
nni_aio *VAR_9 = VAR_1->rxaio;
nni_aio *VAR_10 = NULL;
bool     VAR_11  = false;
nni_mtx_lock(&VAR_1->mtx);
if (VAR_1->user_rxaio != NULL) {
VAR_10 = VAR_1->user_rxaio;
}
if ((VAR_3 = nni_aio_result(VAR_9)) != 0) {
log_warn("" recv aio error %s"", nng_strerror(VAR_3));
goto reset;
}
VAR_8 = nni_aio_get_msg(VAR_9);
if (nni_msg_header_len(VAR_8) == 0 && nni_msg_len(VAR_8) == 0) {
log_trace(""empty msg received! continue next receive"");
goto recv;
}
VAR_6 = nni_msg_body(VAR_8);
VAR_1->gotrxhead += nni_msg_len(VAR_8);
log_trace(""#### wstran_pipe_recv_cb got %ld msg: %p %x %ld"",
VAR_1->gotrxhead, VAR_6, *VAR_6, nni_msg_len(VAR_8));
if (VAR_1->tmp_msg == NULL && VAR_1->gotrxhead > 0) {
if ((VAR_3 = nni_msg_alloc(&VAR_1->tmp_msg, 0)) != 0) {
log_error(""mem error %ld\n"", (size_t) VAR_5);
goto reset;
}
}
nni_msg_append(VAR_1->tmp_msg, VAR_6, nni_msg_len(VAR_8));
VAR_6 = nni_msg_body(VAR_1->tmp_msg); 
if (VAR_1->wantrxhead == 0) {
if (VAR_1->gotrxhead == 1) {
goto recv;
}
VAR_5 = get_var_integer(VAR_6, &VAR_4);
if (*(VAR_6 + VAR_4 - 1) > 0x7f) {
if (VAR_1->gotrxhead >= VAR_12) {
VAR_3 = VAR_13;
goto reset;
}
} else {
VAR_1->wantrxhead = VAR_5 + VAR_4;
nni_msg_set_cmd_type(VAR_1->tmp_msg, *VAR_6 & 0xf0);
}
}
if (VAR_1->gotrxhead >= VAR_1->wantrxhead) {
goto done;
}
recv:
nni_msg_free(VAR_8);
nng_stream_recv(VAR_1->ws, VAR_9);
nni_mtx_unlock(&VAR_1->mtx);
return;
done:
if (VAR_10 == NULL) {
VAR_10 = VAR_1->ep_aio;
}
if (VAR_10 != NULL) {
if (VAR_1->gotrxhead+VAR_1->wantrxhead > VAR_1->conf->max_packet_size) {
log_trace(""size error 0x95\n"");
VAR_3 = VAR_14;
goto recv_error;
}
VAR_1->gotrxhead  = 0;
VAR_1->wantrxhead = 0;
nni_msg_free(VAR_8);
if (nni_msg_cmd_type(VAR_1->tmp_msg) == VAR_15) {
if (VAR_1->ws_param == NULL) {
conn_param_alloc(&VAR_1->ws_param);
}
if (conn_handler(nni_msg_body(VAR_1->tmp_msg), VAR_1->ws_param,
nni_msg_len(VAR_1->tmp_msg)) != 0) {
conn_param_free(VAR_1->ws_param);
VAR_3 = VAR_16;
goto reset;
}
if (VAR_1->ws_param->pro_ver == 5) {
VAR_1->qsend_quota = VAR_1->ws_param->rx_max;
}
if (VAR_1->ws_param->max_packet_size == 0) {
VAR_1->ws_param->max_packet_size =
VAR_1->conf->client_max_packet_size;
}
nni_msg_free(VAR_1->tmp_msg);
VAR_1->tmp_msg = NULL;
nni_aio_set_output(VAR_10, 0, VAR_1);
nni_aio_finish(VAR_10, 0, 0);
nni_mtx_unlock(&VAR_1->mtx);
return;
} else {
if (nni_msg_alloc(&VAR_7, 0) != 0) {
goto reset;
}
ws_msg_adaptor(VAR_6, VAR_7);
nni_msg_free(VAR_1->tmp_msg);
VAR_1->tmp_msg = NULL;
nni_msg_set_conn_param(VAR_7, VAR_1->ws_param);
}
uint8_t   VAR_17;
property *VAR_18        = NULL;
uint8_t   VAR_19 = 0;
uint8_t   VAR_20     = 0;
uint16_t VAR_21 = 0;
nni_msg *VAR_22;
uint8_t  VAR_23 = nni_msg_cmd_type(VAR_7);
if (VAR_23 == VAR_24) {
VAR_17 = nni_msg_get_pub_qos(VAR_7);
if (VAR_17 > 0) {
if (VAR_1->ws_param->pro_ver == 5) {
if (VAR_1->qrecv_quota > 0) {
VAR_1->qrecv_quota--;
} else {
VAR_3 = VAR_25;
goto recv_error;
}
}
if (VAR_17 == 1) {
VAR_20 = VAR_26;
} else if (VAR_17 == 2) {
VAR_20 = VAR_27;
}
VAR_21 = nni_msg_get_pub_pid(VAR_7);
VAR_11       = true;
}
} else if (VAR_23 == VAR_27) {
if (nni_mqtt_pubres_decode(VAR_7, &VAR_21, &VAR_19, &VAR_18,
VAR_1->ws_param->pro_ver) != 0) {
log_trace(""decode PUBREC variable header failed!"");
}
VAR_20 = VAR_28;
VAR_11     = true;
} else if (VAR_23 == VAR_28) {
if (nni_mqtt_pubres_decode(VAR_7, &VAR_21, &VAR_19, &VAR_18,
VAR_1->ws_param->pro_ver) != 0) {
log_trace(""decode PUBREL variable header failed!"");
}
VAR_20 = VAR_29;
VAR_11     = true;
} else if (VAR_23 == VAR_26 || VAR_23 == VAR_29) {
if (nni_mqtt_pubres_decode(VAR_7, &VAR_21, &VAR_19, &VAR_18,
VAR_1->ws_param->pro_ver) != 0) {
log_trace(""decode PUBACK or PUBCOMP variable header ""
""failed!"");
}
if (VAR_1->ws_param->pro_ver == 5) {
property_free(VAR_18);
VAR_1->qsend_quota++;
}
} else if (VAR_23 == VAR_30) {
VAR_11 = true;
}
if (VAR_11 == true) {
if ((VAR_3 = nni_msg_alloc(&VAR_22, 0)) != 0) {
VAR_11 = false;
VAR_3  = VAR_31;
log_error(""ERROR: OOM in WebSocket"");
goto recv_error;
}
if (VAR_23 == VAR_30) {
uint8_t VAR_32[2] = { VAR_33, 0x00 };
nni_msg_set_cmd_type(VAR_22, VAR_33);
nni_msg_header_append(VAR_22, VAR_32, 2);
nng_aio_wait(VAR_1->qsaio);
VAR_2[0].iov_len = nni_msg_header_len(VAR_22);
VAR_2[0].iov_buf = nni_msg_header(VAR_22);
nni_aio_set_msg(VAR_1->qsaio, VAR_22);
nni_aio_set_iov(VAR_1->qsaio, 1, VAR_2);
nng_stream_send(VAR_1->ws, VAR_1->qsaio);
} else {
nni_msg_set_cmd_type(VAR_22, VAR_20);
nni_mqtt_msgack_encode(VAR_22, VAR_21, VAR_19,
VAR_18, VAR_1->ws_param->pro_ver);
nni_mqtt_pubres_header_encode(VAR_22, VAR_20);
nng_aio_wait(VAR_1->qsaio);
VAR_2[0].iov_len = nni_msg_header_len(VAR_22);
VAR_2[0].iov_buf = nni_msg_header(VAR_22);
VAR_2[1].iov_len = nni_msg_len(VAR_22);
VAR_2[1].iov_buf = nni_msg_body(VAR_22);
nni_aio_set_msg(VAR_1->qsaio, VAR_22);
nni_aio_set_iov(VAR_1->qsaio, 2, VAR_2);
nng_stream_send(VAR_1->ws, VAR_1->qsaio);
}
}
nni_aio_set_msg(VAR_10, VAR_7);
nni_aio_set_output(VAR_10, 0, VAR_1);
} else {
goto reset;
}
nni_mtx_unlock(&VAR_1->mtx);
nni_aio_finish(VAR_10, 0, nni_msg_len(VAR_7));
return;
reset:
VAR_1->gotrxhead  = 0;
VAR_1->wantrxhead = 0;
nng_stream_close(VAR_1->ws);
if (VAR_10 != NULL) {
nni_aio_finish_error(VAR_10, VAR_3);
} else if (VAR_1->ep_aio != NULL) {
nni_aio_finish_error(VAR_1->ep_aio, VAR_3);
}
if (VAR_1->tmp_msg != NULL) {
VAR_7 = VAR_1->tmp_msg;
nni_msg_free(VAR_7);
VAR_1->tmp_msg = NULL;
}
nni_mtx_unlock(&VAR_1->mtx);
return;
recv_error:
nni_pipe_bump_error(VAR_1->npipe, VAR_3);
nni_mtx_unlock(&VAR_1->mtx);
nni_msg_free(VAR_8);
log_error(""tcptran_pipe_recv_cb: recv error rv: %d\n"", VAR_3);
return;
}",nanomq/NanoNNG/657e6c81c474bdee0e6413483b990e90610030c1/nmq_websocket.c/vul/before/0.json,"static void
wstran_pipe_recv_cb(void *arg)
{
	ws_pipe *p = arg;
	nni_iov  iov[2];
	uint8_t  rv;
	uint32_t pos = 1;
	uint64_t len = 0;
	uint8_t *ptr;
	nni_msg *smsg = NULL, *msg = NULL;
	nni_aio *raio = p->rxaio;
	nni_aio *uaio = NULL;
	bool     ack  = false;

	nni_mtx_lock(&p->mtx);
	// only sets uaio at first time
	if (p->user_rxaio != NULL) {
		uaio = p->user_rxaio;
	}
	// process scatterd msgs
	if ((rv = nni_aio_result(raio)) != 0) {
		log_warn("" recv aio error %s"", nng_strerror(rv));
		goto reset;
	}
	msg = nni_aio_get_msg(raio);
	if (nni_msg_header_len(msg) == 0 && nni_msg_len(msg) == 0) {
		log_trace(""empty msg received! continue next receive"");
		goto recv;
	}
	ptr = nni_msg_body(msg);
	p->gotrxhead += nni_msg_len(msg);
	log_trace(""#### wstran_pipe_recv_cb got %ld msg: %p %x %ld"",
	    p->gotrxhead, ptr, *ptr, nni_msg_len(msg));
	// first we collect complete Fixheader
	if (p->tmp_msg == NULL && p->gotrxhead > 0) {
		if ((rv = nni_msg_alloc(&p->tmp_msg, 0)) != 0) {
			log_error(""mem error %ld\n"", (size_t) len);
			goto reset;
		}
	}
	// TODO use IOV instead of appending msg
	nni_msg_append(p->tmp_msg, ptr, nni_msg_len(msg));
	ptr = nni_msg_body(p->tmp_msg); // packet might be sticky?

	if (p->wantrxhead == 0) {
		if (p->gotrxhead == 1) {
			goto recv;
		}
		len = get_var_integer(ptr, &pos);
		if (*(ptr + pos - 1) > 0x7f) {
			// continue to next byte of remaining length
			if (p->gotrxhead >= NNI_NANO_MAX_HEADER_SIZE) {
				// length error
				rv = NNG_EMSGSIZE;
				goto reset;
			}
		} else {
			// Fixed header finished
			p->wantrxhead = len + pos;
			nni_msg_set_cmd_type(p->tmp_msg, *ptr & 0xf0);
		}
	}
	if (p->gotrxhead >= p->wantrxhead) {
		goto done;
	}

recv:
	nni_msg_free(msg);
	nng_stream_recv(p->ws, raio);
	nni_mtx_unlock(&p->mtx);
	return;
done:
	if (uaio == NULL) {
		uaio = p->ep_aio;
	}
	if (uaio != NULL) {
		if (p->gotrxhead+p->wantrxhead > p->conf->max_packet_size) {
			log_trace(""size error 0x95\n"");
			rv = NMQ_PACKET_TOO_LARGE;
			goto recv_error;
		}
		p->gotrxhead  = 0;
		p->wantrxhead = 0;
		nni_msg_free(msg);
		if (nni_msg_cmd_type(p->tmp_msg) == CMD_CONNECT) {
			// end of nego
			if (p->ws_param == NULL) {
				conn_param_alloc(&p->ws_param);
			}
			if (conn_handler(nni_msg_body(p->tmp_msg), p->ws_param,
			        nni_msg_len(p->tmp_msg)) != 0) {
				conn_param_free(p->ws_param);
				rv = NNG_ECONNRESET;
				goto reset;
			}
			if (p->ws_param->pro_ver == 5) {
				p->qsend_quota = p->ws_param->rx_max;
			}
			if (p->ws_param->max_packet_size == 0) {
				// set default max packet size for client
				p->ws_param->max_packet_size =
				    p->conf->client_max_packet_size;
			}
			nni_msg_free(p->tmp_msg);
			p->tmp_msg = NULL;
			nni_aio_set_output(uaio, 0, p);
			// pipe_start_cb send CONNACK
			nni_aio_finish(uaio, 0, 0);
			nni_mtx_unlock(&p->mtx);
			return;
		} else {
			if (nni_msg_alloc(&smsg, 0) != 0) {
				goto reset;
			}
			// parse fixed header
			ws_msg_adaptor(ptr, smsg);
			// msg = p->tmp_msg;
			nni_msg_free(p->tmp_msg);
			p->tmp_msg = NULL;
			nni_msg_set_conn_param(smsg, p->ws_param);
		}

		uint8_t   qos_pac;
		property *prop        = NULL;
		uint8_t   reason_code = 0;
		uint8_t   ack_cmd     = 0;

		uint16_t packet_id = 0;
		nni_msg *qmsg;
		uint8_t  cmd = nni_msg_cmd_type(smsg);
		if (cmd == CMD_PUBLISH) {
			qos_pac = nni_msg_get_pub_qos(smsg);
			if (qos_pac > 0) {
				// flow control, check rx_max
				// recv_quota as length of lmq
				if (p->ws_param->pro_ver == 5) {
					if (p->qrecv_quota > 0) {
						p->qrecv_quota--;
					} else {
						rv = NMQ_RECEIVE_MAXIMUM_EXCEEDED;
						goto recv_error;
					}
				}

				if (qos_pac == 1) {
					ack_cmd = CMD_PUBACK;
				} else if (qos_pac == 2) {
					ack_cmd = CMD_PUBREC;
				} else {
					log_warn(""Wrong QoS level!"");
					rv = PROTOCOL_ERROR;
					goto recv_error;
				}
				if ((packet_id = nni_msg_get_pub_pid(msg)) ==
				    0) {
					rv = PROTOCOL_ERROR;
					goto recv_error;
				}
				ack = true;
			}
		} else if (cmd == CMD_PUBREC) {
			if (nni_mqtt_pubres_decode(smsg, &packet_id, &reason_code, &prop,
			        p->ws_param->pro_ver) != 0) {
				log_trace(""decode PUBREC variable header failed!"");
			}
			ack_cmd = CMD_PUBREL;
			ack     = true;
		} else if (cmd == CMD_PUBREL) {
			if (nni_mqtt_pubres_decode(smsg, &packet_id, &reason_code, &prop,
			        p->ws_param->pro_ver) != 0) {
				log_trace(""decode PUBREL variable header failed!"");
			}
			ack_cmd = CMD_PUBCOMP;
			ack     = true;
		} else if (cmd == CMD_PUBACK || cmd == CMD_PUBCOMP) {
			if (nni_mqtt_pubres_decode(smsg, &packet_id, &reason_code, &prop,
			        p->ws_param->pro_ver) != 0) {
				log_trace(""decode PUBACK or PUBCOMP variable header ""
				          ""failed!"");
			}
			// MQTT V5 flow control
			if (p->ws_param->pro_ver == 5) {
				property_free(prop);
				p->qsend_quota++;
			}
		} else if (cmd == CMD_PINGREQ) {
			// reply PINGRESP
			ack = true;
		}

		if (ack == true) {
			// alloc a msg here costs memory. However we must do it for the
			// sake of compatibility with nng.
			if ((rv = nni_msg_alloc(&qmsg, 0)) != 0) {
				ack = false;
				rv  = NMQ_SERVER_BUSY;
				log_error(""ERROR: OOM in WebSocket"");
				goto recv_error;
			}
			if (cmd == CMD_PINGREQ) {
				uint8_t buf[2] = { CMD_PINGRESP, 0x00 };
				nni_msg_set_cmd_type(qmsg, CMD_PINGRESP);
				nni_msg_header_append(qmsg, buf, 2);
				nng_aio_wait(p->qsaio);
				iov[0].iov_len = nni_msg_header_len(qmsg);
				iov[0].iov_buf = nni_msg_header(qmsg);
				nni_aio_set_msg(p->qsaio, qmsg);
				// send ACK down...
				nni_aio_set_iov(p->qsaio, 1, iov);
				nng_stream_send(p->ws, p->qsaio);
				//ignore PING msg, only notify
			} else {
				// TODO set reason code or property here if
				// necessary
				nni_msg_set_cmd_type(qmsg, ack_cmd);
				nni_mqtt_msgack_encode(qmsg, packet_id, reason_code,
				    prop, p->ws_param->pro_ver);
				nni_mqtt_pubres_header_encode(qmsg, ack_cmd);
				nng_aio_wait(p->qsaio);
				iov[0].iov_len = nni_msg_header_len(qmsg);
				iov[0].iov_buf = nni_msg_header(qmsg);
				iov[1].iov_len = nni_msg_len(qmsg);
				iov[1].iov_buf = nni_msg_body(qmsg);
				nni_aio_set_msg(p->qsaio, qmsg);
				// send ACK down...
				nni_aio_set_iov(p->qsaio, 2, iov);
				nng_stream_send(p->ws, p->qsaio);
			}
		}
		nni_aio_set_msg(uaio, smsg);
		nni_aio_set_output(uaio, 0, p);
	} else {
		goto reset;
	}
	nni_mtx_unlock(&p->mtx);
	nni_aio_finish(uaio, 0, nni_msg_len(smsg));
	return;
reset:
	p->gotrxhead  = 0;
	p->wantrxhead = 0;
	nng_stream_close(p->ws);
	if (uaio != NULL) {
		nni_aio_finish_error(uaio, rv);
	} else if (p->ep_aio != NULL) {
		nni_aio_finish_error(p->ep_aio, rv);
	}
	if (p->tmp_msg != NULL) {
		smsg = p->tmp_msg;
		nni_msg_free(smsg);
		p->tmp_msg = NULL;
	}
	nni_mtx_unlock(&p->mtx);
	return;

recv_error:
	//TODO fixme
	// nni_aio_list_remove(aio);
	// msg      = p->rxmsg;
	// p->rxmsg = NULL;
	nni_pipe_bump_error(p->npipe, rv);
	nni_mtx_unlock(&p->mtx);
	nni_msg_free(msg);
	// nni_aio_finish_error(aio, rv);
	log_error(""tcptran_pipe_recv_cb: recv error rv: %d\n"", rv);
	return;
}","static void
wstran_pipe_recv_cb(void *VAR_0)
{
	ws_pipe *VAR_1 = VAR_0;
	nni_iov  VAR_2[2];
	uint8_t  VAR_3;
	uint32_t VAR_4 = 1;
	uint64_t VAR_5 = 0;
	uint8_t *VAR_6;
	nni_msg *VAR_7 = NULL, *VAR_8 = NULL;
	nni_aio *VAR_9 = VAR_1->rxaio;
	nni_aio *VAR_10 = NULL;
	bool     VAR_11  = false;

	nni_mtx_lock(&VAR_1->mtx);
	/* COMMENT_0 */
	if (VAR_1->user_rxaio != NULL) {
		VAR_10 = VAR_1->user_rxaio;
	}
	/* COMMENT_1 */
	if ((VAR_3 = nni_aio_result(VAR_9)) != 0) {
		log_warn("" recv aio error %s"", nng_strerror(VAR_3));
		goto reset;
	}
	VAR_8 = nni_aio_get_msg(VAR_9);
	if (nni_msg_header_len(VAR_8) == 0 && nni_msg_len(VAR_8) == 0) {
		log_trace(""empty msg received! continue next receive"");
		goto recv;
	}
	VAR_6 = nni_msg_body(VAR_8);
	VAR_1->gotrxhead += nni_msg_len(VAR_8);
	log_trace(""#### wstran_pipe_recv_cb got %ld msg: %p %x %ld"",
	    VAR_1->gotrxhead, VAR_6, *VAR_6, nni_msg_len(VAR_8));
	/* COMMENT_2 */
	if (VAR_1->tmp_msg == NULL && VAR_1->gotrxhead > 0) {
		if ((VAR_3 = nni_msg_alloc(&VAR_1->tmp_msg, 0)) != 0) {
			log_error(""mem error %ld\n"", (size_t) VAR_5);
			goto reset;
		}
	}
	/* COMMENT_3 */
	nni_msg_append(VAR_1->tmp_msg, VAR_6, nni_msg_len(VAR_8));
	VAR_6 = nni_msg_body(VAR_1->tmp_msg); /* COMMENT_4 */

	if (VAR_1->wantrxhead == 0) {
		if (VAR_1->gotrxhead == 1) {
			goto recv;
		}
		VAR_5 = get_var_integer(VAR_6, &VAR_4);
		if (*(VAR_6 + VAR_4 - 1) > 0x7f) {
			/* COMMENT_5 */
			if (VAR_1->gotrxhead >= VAR_12) {
				/* COMMENT_6 */
				VAR_3 = VAR_13;
				goto reset;
			}
		} else {
			/* COMMENT_7 */
			VAR_1->wantrxhead = VAR_5 + VAR_4;
			nni_msg_set_cmd_type(VAR_1->tmp_msg, *VAR_6 & 0xf0);
		}
	}
	if (VAR_1->gotrxhead >= VAR_1->wantrxhead) {
		goto done;
	}

recv:
	nni_msg_free(VAR_8);
	nng_stream_recv(VAR_1->ws, VAR_9);
	nni_mtx_unlock(&VAR_1->mtx);
	return;
done:
	if (VAR_10 == NULL) {
		VAR_10 = VAR_1->ep_aio;
	}
	if (VAR_10 != NULL) {
		if (VAR_1->gotrxhead+VAR_1->wantrxhead > VAR_1->conf->max_packet_size) {
			log_trace(""size error 0x95\n"");
			VAR_3 = VAR_14;
			goto recv_error;
		}
		VAR_1->gotrxhead  = 0;
		VAR_1->wantrxhead = 0;
		nni_msg_free(VAR_8);
		if (nni_msg_cmd_type(VAR_1->tmp_msg) == VAR_15) {
			/* COMMENT_8 */
			if (VAR_1->ws_param == NULL) {
				conn_param_alloc(&VAR_1->ws_param);
			}
			if (conn_handler(nni_msg_body(VAR_1->tmp_msg), VAR_1->ws_param,
			        nni_msg_len(VAR_1->tmp_msg)) != 0) {
				conn_param_free(VAR_1->ws_param);
				VAR_3 = VAR_16;
				goto reset;
			}
			if (VAR_1->ws_param->pro_ver == 5) {
				VAR_1->qsend_quota = VAR_1->ws_param->rx_max;
			}
			if (VAR_1->ws_param->max_packet_size == 0) {
				/* COMMENT_9 */
				VAR_1->ws_param->max_packet_size =
				    VAR_1->conf->client_max_packet_size;
			}
			nni_msg_free(VAR_1->tmp_msg);
			VAR_1->tmp_msg = NULL;
			nni_aio_set_output(VAR_10, 0, VAR_1);
			/* COMMENT_10 */
			nni_aio_finish(VAR_10, 0, 0);
			nni_mtx_unlock(&VAR_1->mtx);
			return;
		} else {
			if (nni_msg_alloc(&VAR_7, 0) != 0) {
				goto reset;
			}
			/* COMMENT_11 */
			ws_msg_adaptor(VAR_6, VAR_7);
			/* COMMENT_12 */
			nni_msg_free(VAR_1->tmp_msg);
			VAR_1->tmp_msg = NULL;
			nni_msg_set_conn_param(VAR_7, VAR_1->ws_param);
		}

		uint8_t   VAR_17;
		property *VAR_18        = NULL;
		uint8_t   VAR_19 = 0;
		uint8_t   VAR_20     = 0;

		uint16_t VAR_21 = 0;
		nni_msg *VAR_22;
		uint8_t  VAR_23 = nni_msg_cmd_type(VAR_7);
		if (VAR_23 == VAR_24) {
			VAR_17 = nni_msg_get_pub_qos(VAR_7);
			if (VAR_17 > 0) {
				/* COMMENT_13 */
				/* COMMENT_14 */
				if (VAR_1->ws_param->pro_ver == 5) {
					if (VAR_1->qrecv_quota > 0) {
						VAR_1->qrecv_quota--;
					} else {
						VAR_3 = VAR_25;
						goto recv_error;
					}
				}

				if (VAR_17 == 1) {
					VAR_20 = VAR_26;
				} else if (VAR_17 == 2) {
					VAR_20 = VAR_27;
				} else {
					log_warn(""Wrong QoS level!"");
					VAR_3 = VAR_28;
					goto recv_error;
				}
				if ((VAR_21 = nni_msg_get_pub_pid(VAR_8)) ==
				    0) {
					VAR_3 = VAR_28;
					goto recv_error;
				}
				VAR_11 = true;
			}
		} else if (VAR_23 == VAR_27) {
			if (nni_mqtt_pubres_decode(VAR_7, &VAR_21, &VAR_19, &VAR_18,
			        VAR_1->ws_param->pro_ver) != 0) {
				log_trace(""decode PUBREC variable header failed!"");
			}
			VAR_20 = VAR_29;
			VAR_11     = true;
		} else if (VAR_23 == VAR_29) {
			if (nni_mqtt_pubres_decode(VAR_7, &VAR_21, &VAR_19, &VAR_18,
			        VAR_1->ws_param->pro_ver) != 0) {
				log_trace(""decode PUBREL variable header failed!"");
			}
			VAR_20 = VAR_30;
			VAR_11     = true;
		} else if (VAR_23 == VAR_26 || VAR_23 == VAR_30) {
			if (nni_mqtt_pubres_decode(VAR_7, &VAR_21, &VAR_19, &VAR_18,
			        VAR_1->ws_param->pro_ver) != 0) {
				log_trace(""decode PUBACK or PUBCOMP variable header ""
				          ""failed!"");
			}
			/* COMMENT_15 */
			if (VAR_1->ws_param->pro_ver == 5) {
				property_free(VAR_18);
				VAR_1->qsend_quota++;
			}
		} else if (VAR_23 == VAR_31) {
			/* COMMENT_16 */
			VAR_11 = true;
		}

		if (VAR_11 == true) {
			/* COMMENT_17 */
			/* COMMENT_18 */
			if ((VAR_3 = nni_msg_alloc(&VAR_22, 0)) != 0) {
				VAR_11 = false;
				VAR_3  = VAR_32;
				log_error(""ERROR: OOM in WebSocket"");
				goto recv_error;
			}
			if (VAR_23 == VAR_31) {
				uint8_t VAR_33[2] = { VAR_34, 0x00 };
				nni_msg_set_cmd_type(VAR_22, VAR_34);
				nni_msg_header_append(VAR_22, VAR_33, 2);
				nng_aio_wait(VAR_1->qsaio);
				VAR_2[0].iov_len = nni_msg_header_len(VAR_22);
				VAR_2[0].iov_buf = nni_msg_header(VAR_22);
				nni_aio_set_msg(VAR_1->qsaio, VAR_22);
				/* COMMENT_19 */
				nni_aio_set_iov(VAR_1->qsaio, 1, VAR_2);
				nng_stream_send(VAR_1->ws, VAR_1->qsaio);
				/* COMMENT_20 */
			} else {
				/* COMMENT_21 */
				/* COMMENT_22 */
				nni_msg_set_cmd_type(VAR_22, VAR_20);
				nni_mqtt_msgack_encode(VAR_22, VAR_21, VAR_19,
				    VAR_18, VAR_1->ws_param->pro_ver);
				nni_mqtt_pubres_header_encode(VAR_22, VAR_20);
				nng_aio_wait(VAR_1->qsaio);
				VAR_2[0].iov_len = nni_msg_header_len(VAR_22);
				VAR_2[0].iov_buf = nni_msg_header(VAR_22);
				VAR_2[1].iov_len = nni_msg_len(VAR_22);
				VAR_2[1].iov_buf = nni_msg_body(VAR_22);
				nni_aio_set_msg(VAR_1->qsaio, VAR_22);
				/* COMMENT_19 */
				nni_aio_set_iov(VAR_1->qsaio, 2, VAR_2);
				nng_stream_send(VAR_1->ws, VAR_1->qsaio);
			}
		}
		nni_aio_set_msg(VAR_10, VAR_7);
		nni_aio_set_output(VAR_10, 0, VAR_1);
	} else {
		goto reset;
	}
	nni_mtx_unlock(&VAR_1->mtx);
	nni_aio_finish(VAR_10, 0, nni_msg_len(VAR_7));
	return;
reset:
	VAR_1->gotrxhead  = 0;
	VAR_1->wantrxhead = 0;
	nng_stream_close(VAR_1->ws);
	if (VAR_10 != NULL) {
		nni_aio_finish_error(VAR_10, VAR_3);
	} else if (VAR_1->ep_aio != NULL) {
		nni_aio_finish_error(VAR_1->ep_aio, VAR_3);
	}
	if (VAR_1->tmp_msg != NULL) {
		VAR_7 = VAR_1->tmp_msg;
		nni_msg_free(VAR_7);
		VAR_1->tmp_msg = NULL;
	}
	nni_mtx_unlock(&VAR_1->mtx);
	return;

recv_error:
	/* COMMENT_23 */
	/* COMMENT_24 */
	/* COMMENT_25 */
	/* COMMENT_26 */
	nni_pipe_bump_error(VAR_1->npipe, VAR_3);
	nni_mtx_unlock(&VAR_1->mtx);
	nni_msg_free(VAR_8);
	/* COMMENT_27 */
	log_error(""tcptran_pipe_recv_cb: recv error rv: %d\n"", VAR_3);
	return;
}",nanomq/NanoNNG/657e6c81c474bdee0e6413483b990e90610030c1/nmq_websocket.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -146,9 +146,17 @@
 					ack_cmd = CMD_PUBACK;
 				} else if (qos_pac == 2) {
 					ack_cmd = CMD_PUBREC;
+				} else {
+					log_warn(""Wrong QoS level!"");
+					rv = PROTOCOL_ERROR;
+					goto recv_error;
 				}
-				packet_id = nni_msg_get_pub_pid(smsg);
-				ack       = true;
+				if ((packet_id = nni_msg_get_pub_pid(msg)) ==
+				    0) {
+					rv = PROTOCOL_ERROR;
+					goto recv_error;
+				}
+				ack = true;
 			}
 		} else if (cmd == CMD_PUBREC) {
 			if (nni_mqtt_pubres_decode(smsg, &packet_id, &reason_code, &prop,","{'deleted_lines': ['\t\t\t\tpacket_id = nni_msg_get_pub_pid(smsg);', '\t\t\t\tack       = true;'], 'added_lines': ['\t\t\t\t} else {', '\t\t\t\t\tlog_warn(""Wrong QoS level!"");', '\t\t\t\t\trv = PROTOCOL_ERROR;', '\t\t\t\t\tgoto recv_error;', '\t\t\t\tif ((packet_id = nni_msg_get_pub_pid(msg)) ==', '\t\t\t\t    0) {', '\t\t\t\t\trv = PROTOCOL_ERROR;', '\t\t\t\t\tgoto recv_error;', '\t\t\t\t}', '\t\t\t\tack = true;']}",True,A heap buffer overflow vulnerability exists in NanoMQ 0.17.2. The vulnerability can be triggered by calling the function nni_msg_get_pub_pid() in the file message.c. An attacker could exploit this vulnerability to cause a denial of service attack.,7.5,HIGH,2,test,2023-04-15T07:35:17Z,4
CVE-2023-33658,['CWE-787'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,nanomq/NanoNNG,* FIX [transport] fix #1153 https://github.com/emqx/nanomq/issues/1153 for other transport,657e6c81c474bdee0e6413483b990e90610030c1,https://github.com/nanomq/NanoNNG/commit/657e6c81c474bdee0e6413483b990e90610030c1,src/mqtt/transport/tls/mqtt_tls.c,mqtts_tcptran_pipe_recv_cb,"static void
mqtts_tcptran_pipe_recv_cb(void *arg)
{
nni_aio *           aio;
nni_iov             iov;
uint8_t             type, pos, flags;
uint32_t            len = 0, rv;
size_t              n;
nni_msg *           msg, *qmsg;
mqtts_tcptran_pipe *p     = arg;
nni_aio *           rxaio = p->rxaio;
bool                ack   = false;
nni_mtx_lock(&p->mtx);
aio = nni_list_first(&p->recvq);
if ((rv = nni_aio_result(rxaio)) != 0) {
rv = SERVER_UNAVAILABLE;
goto recv_error;
}
n = nni_aio_count(rxaio);
p->gotrxhead += n;
nni_aio_iov_advance(rxaio, n);
if (nni_aio_iov_count(rxaio) > 0) {
nng_stream_recv(p->conn, rxaio);
nni_mtx_unlock(&p->mtx);
return;
}
rv = mqtt_get_remaining_length(p->rxlen, p->gotrxhead, &len, &pos);
p->wantrxhead = len + 1 + pos;
if (p->gotrxhead <= 5 && p->rxlen[p->gotrxhead - 1] > 0x7f) {
if (p->gotrxhead == NNI_NANO_MAX_HEADER_SIZE) {
rv = PACKET_TOO_LARGE;
goto recv_error;
}
iov.iov_buf = &p->rxlen[p->gotrxhead];
iov.iov_len = 1;
nni_aio_set_iov(rxaio, 1, &iov);
nng_stream_recv(p->conn, rxaio);
nni_mtx_unlock(&p->mtx);
return;
}
if (NULL == p->rxmsg) {
if ((len > p->rcvmax) && (p->rcvmax > 0)) {
rv = PACKET_TOO_LARGE;
goto recv_error;
}
if ((rv = nni_msg_alloc(&p->rxmsg, (size_t) len)) != 0) {
rv = UNSPECIFIED_ERROR;
goto recv_error;
}
nni_msg_set_remaining_len(p->rxmsg, len);
if (len != 0) {
iov.iov_buf = nni_msg_body(p->rxmsg);
iov.iov_len = (size_t) len;
nni_aio_set_iov(rxaio, 1, &iov);
nng_stream_recv(p->conn, rxaio);
nni_mtx_unlock(&p->mtx);
return;
}
}
nni_aio_list_remove(aio);
nni_msg_header_append(p->rxmsg, p->rxlen, pos + 1);
msg      = p->rxmsg;
p->rxmsg = NULL;
n        = nni_msg_len(msg);
type     = p->rxlen[0] & 0xf0;
flags    = p->rxlen[0] & 0x0f;
uint8_t   qos_pac;
uint16_t  packet_id   = 0;
uint8_t   reason_code = 0;
property *prop        = NULL;
uint8_t   ack_cmd     = 0;
switch (type) {
case CMD_PUBLISH:
qos_pac = nni_msg_get_pub_qos(msg);
if (qos_pac > 0) {
if (qos_pac == 1) {
ack_cmd = CMD_PUBACK;
} else if (qos_pac == 2) {
ack_cmd = CMD_PUBREC;
}
packet_id = nni_msg_get_pub_pid(msg);
ack = true;
}
break;
case CMD_PUBREC:
if (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code, &prop,
p->proto) != 0) {
rv = PROTOCOL_ERROR;
goto recv_error;
}
ack_cmd = CMD_PUBREL;
ack     = true;
break;
case CMD_PUBREL:
if (flags == 0x02) {
if (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code,
&prop, p->proto) != 0) {
rv = PROTOCOL_ERROR;
goto recv_error;
}
ack_cmd = CMD_PUBCOMP;
ack     = true;
break;
} else {
rv = PROTOCOL_ERROR;
goto recv_error;
}
case CMD_PUBACK:
case CMD_PUBCOMP:
if (nni_mqtt_pubres_decode(
msg, &packet_id, &reason_code, &prop, p->proto) != 0) {
rv = PROTOCOL_ERROR;
goto recv_error;
}
if (p->proto == MQTT_PROTOCOL_VERSION_v5) {
p->sndmax++;
}
break;
default:
break;
}
if (ack == true) {
if ((rv = nni_msg_alloc(&qmsg, 0)) != 0) {
ack = false;
rv  = UNSPECIFIED_ERROR;
goto recv_error;
}
nni_mqtt_msgack_encode(
qmsg, packet_id, reason_code, prop, p->proto);
nni_mqtt_pubres_header_encode(qmsg, ack_cmd);
if (p->proto == MQTT_PROTOCOL_VERSION_v5) {
property_free(prop);
}
if (p->busy == false) {
nni_msg_insert(qmsg, nni_msg_header(qmsg),
nni_msg_header_len(qmsg));
iov.iov_len    = nni_msg_len(qmsg);
iov.iov_buf    = nni_msg_body(qmsg);
p->busy        = true;
nni_aio_set_msg(p->qsaio, qmsg);
nni_aio_set_iov(p->qsaio, 1, &iov);
nng_stream_send(p->conn, p->qsaio);
} else {
if (nni_lmq_full(&p->rslmq)) {
if (nni_lmq_cap(&p->rslmq) <=
NNG_TRAN_MAX_LMQ_SIZE) {
if ((rv = nni_lmq_resize(&p->rslmq,
nni_lmq_cap(&p->rslmq) *
2)) == 0) {
nni_lmq_put(&p->rslmq, qmsg);
} else {
nni_msg_free(qmsg);
}
} else {
nni_msg *old;
(void) nni_lmq_get(&p->rslmq, &old);
nni_msg_free(old);
nni_lmq_put(&p->rslmq, qmsg);
}
} else {
nni_lmq_put(&p->rslmq, qmsg);
}
}
ack = false;
}
nni_pipe_bump_rx(p->npipe, n);
if (!nni_list_empty(&p->recvq)) {
mqtts_tcptran_pipe_recv_start(p);
}
#ifdef NNG_HAVE_MQTT_BROKER
nni_msg_set_conn_param(msg, p->cparam);
#endif
nni_aio_set_msg(aio, msg);
p->pingcnt = 0;
nni_mtx_unlock(&p->mtx);
nni_aio_finish_sync(aio, 0, n);
return;
recv_error:
nni_aio_list_remove(aio);
msg      = p->rxmsg;
p->rxmsg = NULL;
nni_pipe_bump_error(p->npipe, rv);
nni_mtx_unlock(&p->mtx);
nni_msg_free(msg);
nni_aio_finish_error(aio, rv);
}","static void
mqtts_tcptran_pipe_recv_cb(void *VAR_0)
{
nni_aio *           VAR_1;
nni_iov             VAR_2;
uint8_t             VAR_3, VAR_4, VAR_5;
uint32_t            VAR_6 = 0, VAR_7;
size_t              VAR_8;
nni_msg *           VAR_9, *VAR_10;
mqtts_tcptran_pipe *VAR_11     = VAR_0;
nni_aio *           VAR_12 = VAR_11->rxaio;
bool                VAR_13   = false;
nni_mtx_lock(&VAR_11->mtx);
VAR_1 = nni_list_first(&VAR_11->recvq);
if ((VAR_7 = nni_aio_result(VAR_12)) != 0) {
VAR_7 = VAR_14;
goto recv_error;
}
VAR_8 = nni_aio_count(VAR_12);
VAR_11->gotrxhead += VAR_8;
nni_aio_iov_advance(VAR_12, VAR_8);
if (nni_aio_iov_count(VAR_12) > 0) {
nng_stream_recv(VAR_11->conn, VAR_12);
nni_mtx_unlock(&VAR_11->mtx);
return;
}
VAR_7 = mqtt_get_remaining_length(VAR_11->rxlen, VAR_11->gotrxhead, &VAR_6, &VAR_4);
VAR_11->wantrxhead = VAR_6 + 1 + VAR_4;
if (VAR_11->gotrxhead <= 5 && VAR_11->rxlen[VAR_11->gotrxhead - 1] > 0x7f) {
if (VAR_11->gotrxhead == VAR_15) {
VAR_7 = VAR_16;
goto recv_error;
}
VAR_2.iov_buf = &VAR_11->rxlen[VAR_11->gotrxhead];
VAR_2.iov_len = 1;
nni_aio_set_iov(VAR_12, 1, &VAR_2);
nng_stream_recv(VAR_11->conn, VAR_12);
nni_mtx_unlock(&VAR_11->mtx);
return;
}
if (NULL == VAR_11->rxmsg) {
if ((VAR_6 > VAR_11->rcvmax) && (VAR_11->rcvmax > 0)) {
VAR_7 = VAR_16;
goto recv_error;
}
if ((VAR_7 = nni_msg_alloc(&VAR_11->rxmsg, (size_t) VAR_6)) != 0) {
VAR_7 = VAR_17;
goto recv_error;
}
nni_msg_set_remaining_len(VAR_11->rxmsg, VAR_6);
if (VAR_6 != 0) {
VAR_2.iov_buf = nni_msg_body(VAR_11->rxmsg);
VAR_2.iov_len = (size_t) VAR_6;
nni_aio_set_iov(VAR_12, 1, &VAR_2);
nng_stream_recv(VAR_11->conn, VAR_12);
nni_mtx_unlock(&VAR_11->mtx);
return;
}
}
nni_aio_list_remove(VAR_1);
nni_msg_header_append(VAR_11->rxmsg, VAR_11->rxlen, VAR_4 + 1);
VAR_9      = VAR_11->rxmsg;
VAR_11->rxmsg = NULL;
VAR_8        = nni_msg_len(VAR_9);
VAR_3     = VAR_11->rxlen[0] & 0xf0;
VAR_5    = VAR_11->rxlen[0] & 0x0f;
uint8_t   VAR_18;
uint16_t  VAR_19   = 0;
uint8_t   VAR_20 = 0;
property *VAR_21        = NULL;
uint8_t   VAR_22     = 0;
switch (VAR_3) {
case VAR_23:
VAR_18 = nni_msg_get_pub_qos(VAR_9);
if (VAR_18 > 0) {
if (VAR_18 == 1) {
VAR_22 = VAR_24;
} else if (VAR_18 == 2) {
VAR_22 = VAR_25;
}
VAR_19 = nni_msg_get_pub_pid(VAR_9);
VAR_13 = true;
}
break;
case VAR_25:
if (nni_mqtt_pubres_decode(VAR_9, &VAR_19, &VAR_20, &VAR_21,
VAR_11->proto) != 0) {
VAR_7 = VAR_26;
goto recv_error;
}
VAR_22 = VAR_27;
VAR_13     = true;
break;
case VAR_27:
if (VAR_5 == 0x02) {
if (nni_mqtt_pubres_decode(VAR_9, &VAR_19, &VAR_20,
&VAR_21, VAR_11->proto) != 0) {
VAR_7 = VAR_26;
goto recv_error;
}
VAR_22 = VAR_28;
VAR_13     = true;
break;
} else {
VAR_7 = VAR_26;
goto recv_error;
}
case VAR_24:
case VAR_28:
if (nni_mqtt_pubres_decode(
VAR_9, &VAR_19, &VAR_20, &VAR_21, VAR_11->proto) != 0) {
VAR_7 = VAR_26;
goto recv_error;
}
if (VAR_11->proto == VAR_29) {
VAR_11->sndmax++;
}
break;
default:
break;
}
if (VAR_13 == true) {
if ((VAR_7 = nni_msg_alloc(&VAR_10, 0)) != 0) {
VAR_13 = false;
VAR_7  = VAR_17;
goto recv_error;
}
nni_mqtt_msgack_encode(
VAR_10, VAR_19, VAR_20, VAR_21, VAR_11->proto);
nni_mqtt_pubres_header_encode(VAR_10, VAR_22);
if (VAR_11->proto == VAR_29) {
property_free(VAR_21);
}
if (VAR_11->busy == false) {
nni_msg_insert(VAR_10, nni_msg_header(VAR_10),
nni_msg_header_len(VAR_10));
VAR_2.iov_len    = nni_msg_len(VAR_10);
VAR_2.iov_buf    = nni_msg_body(VAR_10);
VAR_11->busy        = true;
nni_aio_set_msg(VAR_11->qsaio, VAR_10);
nni_aio_set_iov(VAR_11->qsaio, 1, &VAR_2);
nng_stream_send(VAR_11->conn, VAR_11->qsaio);
} else {
if (nni_lmq_full(&VAR_11->rslmq)) {
if (nni_lmq_cap(&VAR_11->rslmq) <=
VAR_30) {
if ((VAR_7 = nni_lmq_resize(&VAR_11->rslmq,
nni_lmq_cap(&VAR_11->rslmq) *
2)) == 0) {
nni_lmq_put(&VAR_11->rslmq, VAR_10);
} else {
nni_msg_free(VAR_10);
}
} else {
nni_msg *VAR_31;
(void) nni_lmq_get(&VAR_11->rslmq, &VAR_31);
nni_msg_free(VAR_31);
nni_lmq_put(&VAR_11->rslmq, VAR_10);
}
} else {
nni_lmq_put(&VAR_11->rslmq, VAR_10);
}
}
VAR_13 = false;
}
nni_pipe_bump_rx(VAR_11->npipe, VAR_8);
if (!nni_list_empty(&VAR_11->recvq)) {
mqtts_tcptran_pipe_recv_start(VAR_11);
}
#ifdef VAR_32
nni_msg_set_conn_param(VAR_9, VAR_11->cparam);
#endif
nni_aio_set_msg(VAR_1, VAR_9);
VAR_11->pingcnt = 0;
nni_mtx_unlock(&VAR_11->mtx);
nni_aio_finish_sync(VAR_1, 0, VAR_8);
return;
recv_error:
nni_aio_list_remove(VAR_1);
VAR_9      = VAR_11->rxmsg;
VAR_11->rxmsg = NULL;
nni_pipe_bump_error(VAR_11->npipe, VAR_7);
nni_mtx_unlock(&VAR_11->mtx);
nni_msg_free(VAR_9);
nni_aio_finish_error(VAR_1, VAR_7);
}",nanomq/NanoNNG/657e6c81c474bdee0e6413483b990e90610030c1/mqtt_tls.c/vul/before/0.json,"static void
mqtts_tcptran_pipe_recv_cb(void *arg)
{
	nni_aio *           aio;
	nni_iov             iov;
	uint8_t             type, pos, flags;
	uint32_t            len = 0, rv;
	size_t              n;
	nni_msg *           msg, *qmsg;
	mqtts_tcptran_pipe *p     = arg;
	nni_aio *           rxaio = p->rxaio;
	bool                ack   = false;
	nni_mtx_lock(&p->mtx);

	aio = nni_list_first(&p->recvq);

	if ((rv = nni_aio_result(rxaio)) != 0) {
		rv = SERVER_UNAVAILABLE;
		goto recv_error;
	}

	n = nni_aio_count(rxaio);
	p->gotrxhead += n;

	// in case one aio is not enough for handling whole buffer
	nni_aio_iov_advance(rxaio, n);
	if (nni_aio_iov_count(rxaio) > 0) {
		nng_stream_recv(p->conn, rxaio);
		nni_mtx_unlock(&p->mtx);
		return;
	}

	rv = mqtt_get_remaining_length(p->rxlen, p->gotrxhead, &len, &pos);
	p->wantrxhead = len + 1 + pos;
	if (p->gotrxhead <= 5 && p->rxlen[p->gotrxhead - 1] > 0x7f) {
		if (p->gotrxhead == NNI_NANO_MAX_HEADER_SIZE) {
			rv = PACKET_TOO_LARGE;
			goto recv_error;
		}
		// same packet, continue receving next byte of remaining length
		iov.iov_buf = &p->rxlen[p->gotrxhead];
		iov.iov_len = 1;
		nni_aio_set_iov(rxaio, 1, &iov);
		nng_stream_recv(p->conn, rxaio);
		nni_mtx_unlock(&p->mtx);
		return;
	}

	// fixed header finished
	if (NULL == p->rxmsg) {
		// Make sure the message payload is not too big.  If it is
		// the caller will shut down the pipe.
		if ((len > p->rcvmax) && (p->rcvmax > 0)) {
			rv = PACKET_TOO_LARGE;
			goto recv_error;
		}
		if ((rv = nni_msg_alloc(&p->rxmsg, (size_t) len)) != 0) {
			rv = UNSPECIFIED_ERROR;
			goto recv_error;
		}
		nni_msg_set_remaining_len(p->rxmsg, len);

		// Submit the rest of the data for a read -- seperate Fixed
		// header with variable header and so on
		//  we want to read the entire message now.
		if (len != 0) {
			iov.iov_buf = nni_msg_body(p->rxmsg);
			iov.iov_len = (size_t) len;

			nni_aio_set_iov(rxaio, 1, &iov);
			// second recv action
			nng_stream_recv(p->conn, rxaio);
			nni_mtx_unlock(&p->mtx);
			return;
		}
	}

	// We read a message completely.  Let the user know the good news. use
	// as application message callback of users
	nni_aio_list_remove(aio);
	nni_msg_header_append(p->rxmsg, p->rxlen, pos + 1);
	msg      = p->rxmsg;
	p->rxmsg = NULL;
	n        = nni_msg_len(msg);
	type     = p->rxlen[0] & 0xf0;
	flags    = p->rxlen[0] & 0x0f;
	// set the payload pointer of msg according to packet_type
	uint8_t   qos_pac;
	uint16_t  packet_id   = 0;
	uint8_t   reason_code = 0;
	property *prop        = NULL;
	uint8_t   ack_cmd     = 0;
	switch (type) {
	case CMD_PUBLISH:
		// should we seperate the 2 phase work of QoS into 2 aios?
		// TODO MQTT v5 qos
		qos_pac = nni_msg_get_pub_qos(msg);
		if (qos_pac > 0) {
			if (qos_pac == 1) {
				ack_cmd = CMD_PUBACK;
			} else if (qos_pac == 2) {
				ack_cmd = CMD_PUBREC;
			} else {
				log_warn(""Wrong QoS level!"");
				rv = PROTOCOL_ERROR;
				goto recv_error;
			}
			if ((packet_id = nni_msg_get_pub_pid(msg)) == 0) {
				rv = PROTOCOL_ERROR;
				goto recv_error;
			}
			ack = true;
		}
		break;
	case CMD_PUBREC:
		if (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code, &prop,
		        p->proto) != 0) {
			rv = PROTOCOL_ERROR;
			goto recv_error;
		}
		ack_cmd = CMD_PUBREL;
		ack     = true;
		break;
	case CMD_PUBREL:
		if (flags == 0x02) {
			if (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code,
			        &prop, p->proto) != 0) {
				rv = PROTOCOL_ERROR;
				goto recv_error;
			}
			ack_cmd = CMD_PUBCOMP;
			ack     = true;
			break;
		} else {
			rv = PROTOCOL_ERROR;
			goto recv_error;
		}
	case CMD_PUBACK:
		// TODO set property for user callback
	case CMD_PUBCOMP:
		if (nni_mqtt_pubres_decode(
		        msg, &packet_id, &reason_code, &prop, p->proto) != 0) {
			rv = PROTOCOL_ERROR;
			goto recv_error;
		}
		if (p->proto == MQTT_PROTOCOL_VERSION_v5) {
			p->sndmax++;
		}
		break;
	default:
		break;
	}

	if (ack == true) {
		// alloc a msg here costs memory. However we must do it for the
		// sake of compatibility with nng.
		if ((rv = nni_msg_alloc(&qmsg, 0)) != 0) {
			ack = false;
			rv  = UNSPECIFIED_ERROR;
			goto recv_error;
		}
		// TODO set reason code or property here if necessary
		nni_mqtt_msgack_encode(
		    qmsg, packet_id, reason_code, prop, p->proto);
		nni_mqtt_pubres_header_encode(qmsg, ack_cmd);
		if (p->proto == MQTT_PROTOCOL_VERSION_v5) {
			property_free(prop);
		}
		// aio_begin?
		if (p->busy == false) {
			nni_msg_insert(qmsg, nni_msg_header(qmsg),
			    nni_msg_header_len(qmsg));
			iov.iov_len    = nni_msg_len(qmsg);
			iov.iov_buf    = nni_msg_body(qmsg);
			p->busy        = true;
			nni_aio_set_msg(p->qsaio, qmsg);
			// send ACK down...
			nni_aio_set_iov(p->qsaio, 1, &iov);
			nng_stream_send(p->conn, p->qsaio);
		} else {
			if (nni_lmq_full(&p->rslmq)) {
				// Make space for the new message. TODO add max
				// limit of msgq len in conf
				if (nni_lmq_cap(&p->rslmq) <=
				    NNG_TRAN_MAX_LMQ_SIZE) {
					if ((rv = nni_lmq_resize(&p->rslmq,
					         nni_lmq_cap(&p->rslmq) *
					             2)) == 0) {
						nni_lmq_put(&p->rslmq, qmsg);
					} else {
						// memory error.
						nni_msg_free(qmsg);
					}
				} else {
					nni_msg *old;
					(void) nni_lmq_get(&p->rslmq, &old);
					nni_msg_free(old);
					nni_lmq_put(&p->rslmq, qmsg);
				}
			} else {
				nni_lmq_put(&p->rslmq, qmsg);
			}
		}
		ack = false;
	}

	// keep connection & Schedule next receive
	nni_pipe_bump_rx(p->npipe, n);
	if (!nni_list_empty(&p->recvq)) {
		mqtts_tcptran_pipe_recv_start(p);
	}
#ifdef NNG_HAVE_MQTT_BROKER
	nni_msg_set_conn_param(msg, p->cparam);
#endif
	nni_aio_set_msg(aio, msg);
	p->pingcnt = 0;
	nni_mtx_unlock(&p->mtx);
	nni_aio_finish_sync(aio, 0, n);
	return;

recv_error:
	nni_aio_list_remove(aio);
	msg      = p->rxmsg;
	p->rxmsg = NULL;
	nni_pipe_bump_error(p->npipe, rv);
	nni_mtx_unlock(&p->mtx);

	nni_msg_free(msg);
	nni_aio_finish_error(aio, rv);
}","static void
mqtts_tcptran_pipe_recv_cb(void *VAR_0)
{
	nni_aio *           VAR_1;
	nni_iov             VAR_2;
	uint8_t             VAR_3, VAR_4, VAR_5;
	uint32_t            VAR_6 = 0, VAR_7;
	size_t              VAR_8;
	nni_msg *           VAR_9, *VAR_10;
	mqtts_tcptran_pipe *VAR_11     = VAR_0;
	nni_aio *           VAR_12 = VAR_11->rxaio;
	bool                VAR_13   = false;
	nni_mtx_lock(&VAR_11->mtx);

	VAR_1 = nni_list_first(&VAR_11->recvq);

	if ((VAR_7 = nni_aio_result(VAR_12)) != 0) {
		VAR_7 = VAR_14;
		goto recv_error;
	}

	VAR_8 = nni_aio_count(VAR_12);
	VAR_11->gotrxhead += VAR_8;

	/* COMMENT_0 */
	nni_aio_iov_advance(VAR_12, VAR_8);
	if (nni_aio_iov_count(VAR_12) > 0) {
		nng_stream_recv(VAR_11->conn, VAR_12);
		nni_mtx_unlock(&VAR_11->mtx);
		return;
	}

	VAR_7 = mqtt_get_remaining_length(VAR_11->rxlen, VAR_11->gotrxhead, &VAR_6, &VAR_4);
	VAR_11->wantrxhead = VAR_6 + 1 + VAR_4;
	if (VAR_11->gotrxhead <= 5 && VAR_11->rxlen[VAR_11->gotrxhead - 1] > 0x7f) {
		if (VAR_11->gotrxhead == VAR_15) {
			VAR_7 = VAR_16;
			goto recv_error;
		}
		/* COMMENT_1 */
		VAR_2.iov_buf = &VAR_11->rxlen[VAR_11->gotrxhead];
		VAR_2.iov_len = 1;
		nni_aio_set_iov(VAR_12, 1, &VAR_2);
		nng_stream_recv(VAR_11->conn, VAR_12);
		nni_mtx_unlock(&VAR_11->mtx);
		return;
	}

	/* COMMENT_2 */
	if (NULL == VAR_11->rxmsg) {
		/* COMMENT_3 */
		/* COMMENT_4 */
		if ((VAR_6 > VAR_11->rcvmax) && (VAR_11->rcvmax > 0)) {
			VAR_7 = VAR_16;
			goto recv_error;
		}
		if ((VAR_7 = nni_msg_alloc(&VAR_11->rxmsg, (size_t) VAR_6)) != 0) {
			VAR_7 = VAR_17;
			goto recv_error;
		}
		nni_msg_set_remaining_len(VAR_11->rxmsg, VAR_6);

		/* COMMENT_5 */
		/* COMMENT_6 */
		/* COMMENT_7 */
		if (VAR_6 != 0) {
			VAR_2.iov_buf = nni_msg_body(VAR_11->rxmsg);
			VAR_2.iov_len = (size_t) VAR_6;

			nni_aio_set_iov(VAR_12, 1, &VAR_2);
			/* COMMENT_8 */
			nng_stream_recv(VAR_11->conn, VAR_12);
			nni_mtx_unlock(&VAR_11->mtx);
			return;
		}
	}

	/* COMMENT_9 */
	/* COMMENT_10 */
	nni_aio_list_remove(VAR_1);
	nni_msg_header_append(VAR_11->rxmsg, VAR_11->rxlen, VAR_4 + 1);
	VAR_9      = VAR_11->rxmsg;
	VAR_11->rxmsg = NULL;
	VAR_8        = nni_msg_len(VAR_9);
	VAR_3     = VAR_11->rxlen[0] & 0xf0;
	VAR_5    = VAR_11->rxlen[0] & 0x0f;
	/* COMMENT_11 */
	uint8_t   VAR_18;
	uint16_t  VAR_19   = 0;
	uint8_t   VAR_20 = 0;
	property *VAR_21        = NULL;
	uint8_t   VAR_22     = 0;
	switch (VAR_3) {
	case VAR_23:
		/* COMMENT_12 */
		/* COMMENT_13 */
		VAR_18 = nni_msg_get_pub_qos(VAR_9);
		if (VAR_18 > 0) {
			if (VAR_18 == 1) {
				VAR_22 = VAR_24;
			} else if (VAR_18 == 2) {
				VAR_22 = VAR_25;
			} else {
				log_warn(""Wrong QoS level!"");
				VAR_7 = VAR_26;
				goto recv_error;
			}
			if ((VAR_19 = nni_msg_get_pub_pid(VAR_9)) == 0) {
				VAR_7 = VAR_26;
				goto recv_error;
			}
			VAR_13 = true;
		}
		break;
	case VAR_25:
		if (nni_mqtt_pubres_decode(VAR_9, &VAR_19, &VAR_20, &VAR_21,
		        VAR_11->proto) != 0) {
			VAR_7 = VAR_26;
			goto recv_error;
		}
		VAR_22 = VAR_27;
		VAR_13     = true;
		break;
	case VAR_27:
		if (VAR_5 == 0x02) {
			if (nni_mqtt_pubres_decode(VAR_9, &VAR_19, &VAR_20,
			        &VAR_21, VAR_11->proto) != 0) {
				VAR_7 = VAR_26;
				goto recv_error;
			}
			VAR_22 = VAR_28;
			VAR_13     = true;
			break;
		} else {
			VAR_7 = VAR_26;
			goto recv_error;
		}
	case VAR_24:
		/* COMMENT_14 */
	case VAR_28:
		if (nni_mqtt_pubres_decode(
		        VAR_9, &VAR_19, &VAR_20, &VAR_21, VAR_11->proto) != 0) {
			VAR_7 = VAR_26;
			goto recv_error;
		}
		if (VAR_11->proto == VAR_29) {
			VAR_11->sndmax++;
		}
		break;
	default:
		break;
	}

	if (VAR_13 == true) {
		/* COMMENT_15 */
		/* COMMENT_16 */
		if ((VAR_7 = nni_msg_alloc(&VAR_10, 0)) != 0) {
			VAR_13 = false;
			VAR_7  = VAR_17;
			goto recv_error;
		}
		/* COMMENT_17 */
		nni_mqtt_msgack_encode(
		    VAR_10, VAR_19, VAR_20, VAR_21, VAR_11->proto);
		nni_mqtt_pubres_header_encode(VAR_10, VAR_22);
		if (VAR_11->proto == VAR_29) {
			property_free(VAR_21);
		}
		/* COMMENT_18 */
		if (VAR_11->busy == false) {
			nni_msg_insert(VAR_10, nni_msg_header(VAR_10),
			    nni_msg_header_len(VAR_10));
			VAR_2.iov_len    = nni_msg_len(VAR_10);
			VAR_2.iov_buf    = nni_msg_body(VAR_10);
			VAR_11->busy        = true;
			nni_aio_set_msg(VAR_11->qsaio, VAR_10);
			/* COMMENT_19 */
			nni_aio_set_iov(VAR_11->qsaio, 1, &VAR_2);
			nng_stream_send(VAR_11->conn, VAR_11->qsaio);
		} else {
			if (nni_lmq_full(&VAR_11->rslmq)) {
				/* COMMENT_20 */
				/* COMMENT_21 */
				if (nni_lmq_cap(&VAR_11->rslmq) <=
				    VAR_30) {
					if ((VAR_7 = nni_lmq_resize(&VAR_11->rslmq,
					         nni_lmq_cap(&VAR_11->rslmq) *
					             2)) == 0) {
						nni_lmq_put(&VAR_11->rslmq, VAR_10);
					} else {
						/* COMMENT_22 */
						nni_msg_free(VAR_10);
					}
				} else {
					nni_msg *VAR_31;
					(void) nni_lmq_get(&VAR_11->rslmq, &VAR_31);
					nni_msg_free(VAR_31);
					nni_lmq_put(&VAR_11->rslmq, VAR_10);
				}
			} else {
				nni_lmq_put(&VAR_11->rslmq, VAR_10);
			}
		}
		VAR_13 = false;
	}

	/* COMMENT_23 */
	nni_pipe_bump_rx(VAR_11->npipe, VAR_8);
	if (!nni_list_empty(&VAR_11->recvq)) {
		mqtts_tcptran_pipe_recv_start(VAR_11);
	}
#ifdef VAR_32
	nni_msg_set_conn_param(VAR_9, VAR_11->cparam);
#endif
	nni_aio_set_msg(VAR_1, VAR_9);
	VAR_11->pingcnt = 0;
	nni_mtx_unlock(&VAR_11->mtx);
	nni_aio_finish_sync(VAR_1, 0, VAR_8);
	return;

recv_error:
	nni_aio_list_remove(VAR_1);
	VAR_9      = VAR_11->rxmsg;
	VAR_11->rxmsg = NULL;
	nni_pipe_bump_error(VAR_11->npipe, VAR_7);
	nni_mtx_unlock(&VAR_11->mtx);

	nni_msg_free(VAR_9);
	nni_aio_finish_error(VAR_1, VAR_7);
}",nanomq/NanoNNG/657e6c81c474bdee0e6413483b990e90610030c1/mqtt_tls.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -100,8 +100,15 @@
 				ack_cmd = CMD_PUBACK;
 			} else if (qos_pac == 2) {
 				ack_cmd = CMD_PUBREC;
-			}
-			packet_id = nni_msg_get_pub_pid(msg);
+			} else {
+				log_warn(""Wrong QoS level!"");
+				rv = PROTOCOL_ERROR;
+				goto recv_error;
+			}
+			if ((packet_id = nni_msg_get_pub_pid(msg)) == 0) {
+				rv = PROTOCOL_ERROR;
+				goto recv_error;
+			}
 			ack = true;
 		}
 		break;","{'deleted_lines': ['\t\t\t}', '\t\t\tpacket_id = nni_msg_get_pub_pid(msg);'], 'added_lines': ['\t\t\t} else {', '\t\t\t\tlog_warn(""Wrong QoS level!"");', '\t\t\t\trv = PROTOCOL_ERROR;', '\t\t\t\tgoto recv_error;', '\t\t\t}', '\t\t\tif ((packet_id = nni_msg_get_pub_pid(msg)) == 0) {', '\t\t\t\trv = PROTOCOL_ERROR;', '\t\t\t\tgoto recv_error;', '\t\t\t}']}",True,A heap buffer overflow vulnerability exists in NanoMQ 0.17.2. The vulnerability can be triggered by calling the function nni_msg_get_pub_pid() in the file message.c. An attacker could exploit this vulnerability to cause a denial of service attack.,7.5,HIGH,2,test,2023-04-15T07:35:17Z,4
CVE-2023-33658,['CWE-787'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,nanomq/NanoNNG,* FIX [transport] fix #1153 https://github.com/emqx/nanomq/issues/1153 for other transport,657e6c81c474bdee0e6413483b990e90610030c1,https://github.com/nanomq/NanoNNG/commit/657e6c81c474bdee0e6413483b990e90610030c1,src/sp/transport/mqtts/broker_tls.c,tlstran_pipe_recv_cb,"static void
tlstran_pipe_recv_cb(void *arg)
{
nni_aio *     aio;
nni_iov       iov[2];
uint8_t       type;
uint8_t       rv;
uint32_t      pos = 1;
uint64_t      len = 0;
size_t        n;
nni_msg      *msg, *qmsg;
tlstran_pipe *p     = arg;
nni_aio *     rxaio = p->rxaio;
conn_param *  cparam;
bool          ack   = false;
log_trace(""tlstran_pipe_recv_cb %p\n"", p);
nni_mtx_lock(&p->mtx);
aio = nni_list_first(&p->recvq);
if ((rv = nni_aio_result(rxaio)) != 0) {
log_warn("" recv aio error %s"", nng_strerror(rv));
rv = NMQ_SERVER_BUSY;
goto recv_error;
}
n = nni_aio_count(rxaio);
p->gotrxhead += n;
nni_aio_iov_advance(rxaio, n);
len = get_var_integer(p->rxlen, &pos);
log_trace(""new %ld recevied %ld header %x %d pos: %d len : %d"", n,
p->gotrxhead, p->rxlen[0], p->rxlen[1], pos, len);
log_trace(""still need byte count:%ld > 0\n"", nni_aio_iov_count(rxaio));
if (nni_aio_iov_count(rxaio) > 0) {
log_trace(""got: %x %x, %ld!!\n"", p->rxlen[0], p->rxlen[1],
strlen((char *) p->rxlen));
nng_stream_recv(p->conn, rxaio);
nni_mtx_unlock(&p->mtx);
return;
} else if (p->gotrxhead <= NNI_NANO_MAX_HEADER_SIZE &&
p->rxlen[p->gotrxhead - 1] > 0x7f) {
if (p->gotrxhead == NNI_NANO_MAX_HEADER_SIZE) {
rv = NNG_EMSGSIZE;
goto recv_error;
}
iov[0].iov_buf = &p->rxlen[p->gotrxhead];
iov[0].iov_len = 1;
nni_aio_set_iov(rxaio, 1, iov);
nng_stream_recv(p->conn, rxaio);
nni_mtx_unlock(&p->mtx);
return;
} else if (len == 0 && n == 2) {
if ((p->rxlen[0] & 0XFF) == CMD_PINGREQ) {
nng_aio_wait(p->rpaio);
p->txlen[0] = CMD_PINGRESP;
p->txlen[1] = 0x00;
iov[0].iov_len = 2;
iov[0].iov_buf = &p->txlen;
nni_aio_set_iov(p->rpaio, 1, iov);
nng_stream_send(p->conn, p->rpaio);
goto notify;
}
}
p->wantrxhead = len + p->gotrxhead;
cparam        = p->tcp_cparam;
if (p->rxmsg == NULL) {
log_trace(""pipe %p header got: %x %x %x %x %x, %ld!!\n"", p,
p->rxlen[0], p->rxlen[1], p->rxlen[2], p->rxlen[3],
p->rxlen[4], p->wantrxhead);
if (len > p->conf->max_packet_size) {
log_error(""size error 0x95\n"");
rv = NMQ_PACKET_TOO_LARGE;
goto recv_error;
}
if ((rv = nni_msg_alloc(&p->rxmsg, (size_t) len)) != 0) {
log_error(""mem error %ld\n"", (size_t) len);
rv = NMQ_SERVER_UNAVAILABLE;
goto recv_error;
}
if (len != 0) {
iov[0].iov_buf = nni_msg_body(p->rxmsg);
iov[0].iov_len = (size_t) len;
nni_aio_set_iov(rxaio, 1, iov);
nng_stream_recv(p->conn, rxaio);
nni_mtx_unlock(&p->mtx);
return;
}
}
nni_aio_list_remove(aio);
msg      = p->rxmsg;
p->rxmsg = NULL;
n        = nni_msg_len(msg);
type     = p->rxlen[0] & 0xf0;
fixed_header_adaptor(p->rxlen, msg);
nni_msg_set_conn_param(msg, cparam);
nni_msg_set_remaining_len(msg, len);
nni_msg_set_cmd_type(msg, type);
log_trace(""remain_len %d cparam %p clientid %s username %s proto %d\n"",
len, cparam, cparam->clientid.body, cparam->username.body,
cparam->pro_ver);
log_trace(""The type of msg is %x"", type);
uint16_t  packet_id   = 0;
uint8_t   reason_code = 0;
property *prop        = NULL;
uint8_t   ack_cmd     = 0;
if (type == CMD_PUBLISH) {
nni_msg_set_timestamp(msg, nng_clock());
uint8_t qos_pac = nni_msg_get_pub_qos(msg);
if (qos_pac > 0) {
if (p->tcp_cparam->pro_ver == 5) {
if (p->qrecv_quota > 0) {
p->qrecv_quota--;
} else {
rv = NMQ_RECEIVE_MAXIMUM_EXCEEDED;
goto recv_error;
}
}
if (qos_pac == 1) {
ack_cmd = CMD_PUBACK;
} else if (qos_pac == 2) {
ack_cmd = CMD_PUBREC;
}
packet_id = nni_msg_get_pub_pid(msg);
ack       = true;
}
} else if (type == CMD_PUBREC) {
if (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code, &prop,
cparam->pro_ver) != 0) {
log_error(""decode PUBREC variable header failed!"");
}
ack_cmd = CMD_PUBREL;
ack     = true;
} else if (type == CMD_PUBREL) {
if (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code, &prop,
cparam->pro_ver) != 0) {
log_error(""decode PUBREL variable header failed!"");
}
ack_cmd = CMD_PUBCOMP;
ack     = true;
} else if (type == CMD_PUBACK || type == CMD_PUBCOMP) {
if (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code, &prop,
cparam->pro_ver) != 0) {
log_error(""decode PUBACK or PUBCOMP variable header ""
""failed!"");
}
if (p->tcp_cparam->pro_ver == 5) {
property_free(prop);
p->qsend_quota++;
}
}
if (ack == true) {
if ((rv = nni_msg_alloc(&qmsg, 0)) != 0) {
ack = false;
rv  = NMQ_SERVER_BUSY;
goto recv_error;
}
nni_msg_set_cmd_type(qmsg, ack_cmd);
nni_mqtt_msgack_encode(
qmsg, packet_id, reason_code, prop, cparam->pro_ver);
nni_mqtt_pubres_header_encode(qmsg, ack_cmd);
if (p->busy == false) {
if (nni_aio_begin(aio) != 0) {
log_error(""ACK aio error!!"");
}
nni_msg_insert(qmsg, nni_msg_header(qmsg),
nni_msg_header_len(qmsg));
iov[0].iov_len = nni_msg_len(qmsg);
iov[0].iov_buf = nni_msg_body(qmsg);
p->busy        = true;
nni_aio_set_msg(p->qsaio, qmsg);
nni_aio_set_iov(p->qsaio, 1, iov);
nng_stream_send(p->conn, p->qsaio);
log_trace(""QoS ACK msg sent!"");
} else {
if (nni_lmq_full(&p->rslmq)) {
if (nni_lmq_cap(&p->rslmq) <=
NANO_MAX_QOS_PACKET) {
if ((rv = nni_lmq_resize(&p->rslmq,
nni_lmq_cap(&p->rslmq) *
2)) == 0) {
nni_lmq_put(&p->rslmq, qmsg);
} else {
nni_msg_free(qmsg);
}
} else {
nni_msg *old;
(void) nni_lmq_get(&p->rslmq, &old);
nni_msg_free(old);
nni_lmq_put(&p->rslmq, qmsg);
}
} else {
nni_lmq_put(&p->rslmq, qmsg);
}
}
ack = false;
}
if (!nni_list_empty(&p->recvq)) {
tlstran_pipe_recv_start(p);
}
nni_pipe_bump_rx(p->npipe, n);
nni_mtx_unlock(&p->mtx);
nni_aio_set_msg(aio, msg);
nni_aio_finish_sync(aio, 0, n);
log_trace(""end of tlstran_pipe_recv_cb: synch! %p\n"", p);
return;
recv_error:
nni_aio_list_remove(aio);
msg      = p->rxmsg;
p->rxmsg = NULL;
nni_pipe_bump_error(p->npipe, rv);
nni_mtx_unlock(&p->mtx);
nni_msg_free(msg);
nni_aio_finish_error(aio, rv);
log_trace(""tlstran_pipe_recv_cb: recv error rv: %d\n"", rv);
return;
notify:
nni_aio_list_remove(aio);
nni_mtx_unlock(&p->mtx);
nni_aio_set_msg(aio, NULL);
nni_aio_finish(aio, 0, 0);
return;
}","static void
tlstran_pipe_recv_cb(void *VAR_0)
{
nni_aio *     VAR_1;
nni_iov       VAR_2[2];
uint8_t       VAR_3;
uint8_t       VAR_4;
uint32_t      VAR_5 = 1;
uint64_t      VAR_6 = 0;
size_t        VAR_7;
nni_msg      *VAR_8, *VAR_9;
tlstran_pipe *VAR_10     = VAR_0;
nni_aio *     VAR_11 = VAR_10->rxaio;
conn_param *  VAR_12;
bool          VAR_13   = false;
log_trace(""tlstran_pipe_recv_cb %p\n"", VAR_10);
nni_mtx_lock(&VAR_10->mtx);
VAR_1 = nni_list_first(&VAR_10->recvq);
if ((VAR_4 = nni_aio_result(VAR_11)) != 0) {
log_warn("" recv aio error %s"", nng_strerror(VAR_4));
VAR_4 = VAR_14;
goto recv_error;
}
VAR_7 = nni_aio_count(VAR_11);
VAR_10->gotrxhead += VAR_7;
nni_aio_iov_advance(VAR_11, VAR_7);
VAR_6 = get_var_integer(VAR_10->rxlen, &VAR_5);
log_trace(""new %ld recevied %ld header %x %d pos: %d len : %d"", VAR_7,
VAR_10->gotrxhead, VAR_10->rxlen[0], VAR_10->rxlen[1], VAR_5, VAR_6);
log_trace(""still need byte count:%ld > 0\n"", nni_aio_iov_count(VAR_11));
if (nni_aio_iov_count(VAR_11) > 0) {
log_trace(""got: %x %x, %ld!!\n"", VAR_10->rxlen[0], VAR_10->rxlen[1],
strlen((char *) VAR_10->rxlen));
nng_stream_recv(VAR_10->conn, VAR_11);
nni_mtx_unlock(&VAR_10->mtx);
return;
} else if (VAR_10->gotrxhead <= VAR_15 &&
VAR_10->rxlen[VAR_10->gotrxhead - 1] > 0x7f) {
if (VAR_10->gotrxhead == VAR_15) {
VAR_4 = VAR_16;
goto recv_error;
}
VAR_2[0].iov_buf = &VAR_10->rxlen[VAR_10->gotrxhead];
VAR_2[0].iov_len = 1;
nni_aio_set_iov(VAR_11, 1, VAR_2);
nng_stream_recv(VAR_10->conn, VAR_11);
nni_mtx_unlock(&VAR_10->mtx);
return;
} else if (VAR_6 == 0 && VAR_7 == 2) {
if ((VAR_10->rxlen[0] & 0VAR_17) == VAR_18) {
nng_aio_wait(VAR_10->rpaio);
VAR_10->txlen[0] = VAR_19;
VAR_10->txlen[1] = 0x00;
VAR_2[0].iov_len = 2;
VAR_2[0].iov_buf = &VAR_10->txlen;
nni_aio_set_iov(VAR_10->rpaio, 1, VAR_2);
nng_stream_send(VAR_10->conn, VAR_10->rpaio);
goto notify;
}
}
VAR_10->wantrxhead = VAR_6 + VAR_10->gotrxhead;
VAR_12        = VAR_10->tcp_cparam;
if (VAR_10->rxmsg == NULL) {
log_trace(""pipe %p header got: %x %x %x %x %x, %ld!!\n"", VAR_10,
VAR_10->rxlen[0], VAR_10->rxlen[1], VAR_10->rxlen[2], VAR_10->rxlen[3],
VAR_10->rxlen[4], VAR_10->wantrxhead);
if (VAR_6 > VAR_10->conf->max_packet_size) {
log_error(""size error 0x95\n"");
VAR_4 = VAR_20;
goto recv_error;
}
if ((VAR_4 = nni_msg_alloc(&VAR_10->rxmsg, (size_t) VAR_6)) != 0) {
log_error(""mem error %ld\n"", (size_t) VAR_6);
VAR_4 = VAR_21;
goto recv_error;
}
if (VAR_6 != 0) {
VAR_2[0].iov_buf = nni_msg_body(VAR_10->rxmsg);
VAR_2[0].iov_len = (size_t) VAR_6;
nni_aio_set_iov(VAR_11, 1, VAR_2);
nng_stream_recv(VAR_10->conn, VAR_11);
nni_mtx_unlock(&VAR_10->mtx);
return;
}
}
nni_aio_list_remove(VAR_1);
VAR_8      = VAR_10->rxmsg;
VAR_10->rxmsg = NULL;
VAR_7        = nni_msg_len(VAR_8);
VAR_3     = VAR_10->rxlen[0] & 0xf0;
fixed_header_adaptor(VAR_10->rxlen, VAR_8);
nni_msg_set_conn_param(VAR_8, VAR_12);
nni_msg_set_remaining_len(VAR_8, VAR_6);
nni_msg_set_cmd_type(VAR_8, VAR_3);
log_trace(""remain_len %d cparam %p clientid %s username %s proto %d\n"",
VAR_6, VAR_12, VAR_12->clientid.body, VAR_12->username.body,
VAR_12->pro_ver);
log_trace(""The type of msg is %x"", VAR_3);
uint16_t  VAR_22   = 0;
uint8_t   VAR_23 = 0;
property *VAR_24        = NULL;
uint8_t   VAR_25     = 0;
if (VAR_3 == VAR_26) {
nni_msg_set_timestamp(VAR_8, nng_clock());
uint8_t VAR_27 = nni_msg_get_pub_qos(VAR_8);
if (VAR_27 > 0) {
if (VAR_10->tcp_cparam->pro_ver == 5) {
if (VAR_10->qrecv_quota > 0) {
VAR_10->qrecv_quota--;
} else {
VAR_4 = VAR_28;
goto recv_error;
}
}
if (VAR_27 == 1) {
VAR_25 = VAR_29;
} else if (VAR_27 == 2) {
VAR_25 = VAR_30;
}
VAR_22 = nni_msg_get_pub_pid(VAR_8);
VAR_13       = true;
}
} else if (VAR_3 == VAR_30) {
if (nni_mqtt_pubres_decode(VAR_8, &VAR_22, &VAR_23, &VAR_24,
VAR_12->pro_ver) != 0) {
log_error(""decode PUBREC variable header failed!"");
}
VAR_25 = VAR_31;
VAR_13     = true;
} else if (VAR_3 == VAR_31) {
if (nni_mqtt_pubres_decode(VAR_8, &VAR_22, &VAR_23, &VAR_24,
VAR_12->pro_ver) != 0) {
log_error(""decode PUBREL variable header failed!"");
}
VAR_25 = VAR_32;
VAR_13     = true;
} else if (VAR_3 == VAR_29 || VAR_3 == VAR_32) {
if (nni_mqtt_pubres_decode(VAR_8, &VAR_22, &VAR_23, &VAR_24,
VAR_12->pro_ver) != 0) {
log_error(""decode PUBACK or PUBCOMP variable header ""
""failed!"");
}
if (VAR_10->tcp_cparam->pro_ver == 5) {
property_free(VAR_24);
VAR_10->qsend_quota++;
}
}
if (VAR_13 == true) {
if ((VAR_4 = nni_msg_alloc(&VAR_9, 0)) != 0) {
VAR_13 = false;
VAR_4  = VAR_14;
goto recv_error;
}
nni_msg_set_cmd_type(VAR_9, VAR_25);
nni_mqtt_msgack_encode(
VAR_9, VAR_22, VAR_23, VAR_24, VAR_12->pro_ver);
nni_mqtt_pubres_header_encode(VAR_9, VAR_25);
if (VAR_10->busy == false) {
if (nni_aio_begin(VAR_1) != 0) {
log_error(""ACK aio error!!"");
}
nni_msg_insert(VAR_9, nni_msg_header(VAR_9),
nni_msg_header_len(VAR_9));
VAR_2[0].iov_len = nni_msg_len(VAR_9);
VAR_2[0].iov_buf = nni_msg_body(VAR_9);
VAR_10->busy        = true;
nni_aio_set_msg(VAR_10->qsaio, VAR_9);
nni_aio_set_iov(VAR_10->qsaio, 1, VAR_2);
nng_stream_send(VAR_10->conn, VAR_10->qsaio);
log_trace(""QoS ACK msg sent!"");
} else {
if (nni_lmq_full(&VAR_10->rslmq)) {
if (nni_lmq_cap(&VAR_10->rslmq) <=
VAR_33) {
if ((VAR_4 = nni_lmq_resize(&VAR_10->rslmq,
nni_lmq_cap(&VAR_10->rslmq) *
2)) == 0) {
nni_lmq_put(&VAR_10->rslmq, VAR_9);
} else {
nni_msg_free(VAR_9);
}
} else {
nni_msg *VAR_34;
(void) nni_lmq_get(&VAR_10->rslmq, &VAR_34);
nni_msg_free(VAR_34);
nni_lmq_put(&VAR_10->rslmq, VAR_9);
}
} else {
nni_lmq_put(&VAR_10->rslmq, VAR_9);
}
}
VAR_13 = false;
}
if (!nni_list_empty(&VAR_10->recvq)) {
tlstran_pipe_recv_start(VAR_10);
}
nni_pipe_bump_rx(VAR_10->npipe, VAR_7);
nni_mtx_unlock(&VAR_10->mtx);
nni_aio_set_msg(VAR_1, VAR_8);
nni_aio_finish_sync(VAR_1, 0, VAR_7);
log_trace(""end of tlstran_pipe_recv_cb: synch! %p\n"", VAR_10);
return;
recv_error:
nni_aio_list_remove(VAR_1);
VAR_8      = VAR_10->rxmsg;
VAR_10->rxmsg = NULL;
nni_pipe_bump_error(VAR_10->npipe, VAR_4);
nni_mtx_unlock(&VAR_10->mtx);
nni_msg_free(VAR_8);
nni_aio_finish_error(VAR_1, VAR_4);
log_trace(""tlstran_pipe_recv_cb: recv error rv: %d\n"", VAR_4);
return;
notify:
nni_aio_list_remove(VAR_1);
nni_mtx_unlock(&VAR_10->mtx);
nni_aio_set_msg(VAR_1, NULL);
nni_aio_finish(VAR_1, 0, 0);
return;
}",nanomq/NanoNNG/657e6c81c474bdee0e6413483b990e90610030c1/broker_tls.c/vul/before/0.json,"static void
tlstran_pipe_recv_cb(void *arg)
{
	nni_aio *     aio;
	nni_iov       iov[2];
	uint8_t       type;
	uint8_t       rv;
	uint32_t      pos = 1;
	uint64_t      len = 0;
	size_t        n;
	nni_msg      *msg, *qmsg;
	tlstran_pipe *p     = arg;
	nni_aio *     rxaio = p->rxaio;
	conn_param *  cparam;
	bool          ack   = false;

	log_trace(""tlstran_pipe_recv_cb %p\n"", p);
	nni_mtx_lock(&p->mtx);

	aio = nni_list_first(&p->recvq);

	if ((rv = nni_aio_result(rxaio)) != 0) {
		log_warn("" recv aio error %s"", nng_strerror(rv));
		rv = NMQ_SERVER_BUSY;
		goto recv_error;
	}

	n = nni_aio_count(rxaio);
	p->gotrxhead += n;

	nni_aio_iov_advance(rxaio, n);
	// not receive enough bytes, deal with remaining length
	len = get_var_integer(p->rxlen, &pos);
	log_trace(""new %ld recevied %ld header %x %d pos: %d len : %d"", n,
	    p->gotrxhead, p->rxlen[0], p->rxlen[1], pos, len);
	log_trace(""still need byte count:%ld > 0\n"", nni_aio_iov_count(rxaio));

	if (nni_aio_iov_count(rxaio) > 0) {
		log_trace(""got: %x %x, %ld!!\n"", p->rxlen[0], p->rxlen[1],
		    strlen((char *) p->rxlen));
		nng_stream_recv(p->conn, rxaio);
		nni_mtx_unlock(&p->mtx);
		return;
	} else if (p->gotrxhead <= NNI_NANO_MAX_HEADER_SIZE &&
	    p->rxlen[p->gotrxhead - 1] > 0x7f) {
		// length error
		if (p->gotrxhead == NNI_NANO_MAX_HEADER_SIZE) {
			rv = NNG_EMSGSIZE;
			goto recv_error;
		}
		// same packet, continue receving next byte of remaining length
		iov[0].iov_buf = &p->rxlen[p->gotrxhead];
		iov[0].iov_len = 1;
		nni_aio_set_iov(rxaio, 1, iov);
		nng_stream_recv(p->conn, rxaio);
		nni_mtx_unlock(&p->mtx);
		return;
	} else if (len == 0 && n == 2) {
		if ((p->rxlen[0] & 0XFF) == CMD_PINGREQ) {
			nng_aio_wait(p->rpaio);
			p->txlen[0] = CMD_PINGRESP;
			p->txlen[1] = 0x00;
			iov[0].iov_len = 2;
			iov[0].iov_buf = &p->txlen;
			// send it down...
			nni_aio_set_iov(p->rpaio, 1, iov);
			nng_stream_send(p->conn, p->rpaio);
			goto notify;
		}
	}

	// finish fixed header
	p->wantrxhead = len + p->gotrxhead;
	cparam        = p->tcp_cparam;

	if (p->rxmsg == NULL) {
		// We should have gotten a message header. len -> remaining
		// length to define how many bytes left
		log_trace(""pipe %p header got: %x %x %x %x %x, %ld!!\n"", p,
		    p->rxlen[0], p->rxlen[1], p->rxlen[2], p->rxlen[3],
		    p->rxlen[4], p->wantrxhead);
		// Make sure the message payload is not too big.  If it is
		// the caller will shut down the pipe.
		if (len > p->conf->max_packet_size) {
			log_error(""size error 0x95\n"");
			rv = NMQ_PACKET_TOO_LARGE;
			goto recv_error;
		}

		if ((rv = nni_msg_alloc(&p->rxmsg, (size_t) len)) != 0) {
			log_error(""mem error %ld\n"", (size_t) len);
			rv = NMQ_SERVER_UNAVAILABLE;
			goto recv_error;
		}

		// Submit the rest of the data for a read -- seperate Fixed
		// header with variable header and so on
		//  we want to read the entire message now.
		if (len != 0) {
			iov[0].iov_buf = nni_msg_body(p->rxmsg);
			iov[0].iov_len = (size_t) len;

			nni_aio_set_iov(rxaio, 1, iov);
			// second recv action
			nng_stream_recv(p->conn, rxaio);
			nni_mtx_unlock(&p->mtx);
			return;
		}
	}

	// We read a message completely.  Let the user know the good news. use
	// as application message callback of users
	nni_aio_list_remove(aio);
	msg      = p->rxmsg;
	p->rxmsg = NULL;
	n        = nni_msg_len(msg);
	type     = p->rxlen[0] & 0xf0;

	fixed_header_adaptor(p->rxlen, msg);
	nni_msg_set_conn_param(msg, cparam);
	// duplicated with fixed_header_adaptor
	nni_msg_set_remaining_len(msg, len);
	nni_msg_set_cmd_type(msg, type);
	log_trace(""remain_len %d cparam %p clientid %s username %s proto %d\n"",
	    len, cparam, cparam->clientid.body, cparam->username.body,
	    cparam->pro_ver);

	// set the payload pointer of msg according to packet_type
	log_trace(""The type of msg is %x"", type);
	uint16_t  packet_id   = 0;
	uint8_t   reason_code = 0;
	property *prop        = NULL;
	uint8_t   ack_cmd     = 0;
	if (type == CMD_PUBLISH) {
		nni_msg_set_timestamp(msg, nng_clock());
		uint8_t qos_pac = nni_msg_get_pub_qos(msg);
		if (qos_pac > 0) {
			// flow control, check rx_max
			// recv_quota as length of lmq
			if (p->tcp_cparam->pro_ver == 5) {
				if (p->qrecv_quota > 0) {
					p->qrecv_quota--;
				} else {
					rv = NMQ_RECEIVE_MAXIMUM_EXCEEDED;
					goto recv_error;
				}
			}
			if (qos_pac == 1) {
				ack_cmd = CMD_PUBACK;
			} else if (qos_pac == 2) {
				ack_cmd = CMD_PUBREC;
			} else {
				log_warn(""Wrong QoS level!"");
				rv = PROTOCOL_ERROR;
				goto recv_error;
			}
			if ((packet_id = nni_msg_get_pub_pid(msg)) == 0) {
				rv = PROTOCOL_ERROR;
				goto recv_error;
			}
			ack       = true;
		}
	} else if (type == CMD_PUBREC) {
		if (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code, &prop,
		        cparam->pro_ver) != 0) {
			log_error(""decode PUBREC variable header failed!"");
		}
		ack_cmd = CMD_PUBREL;
		ack     = true;
	} else if (type == CMD_PUBREL) {
		if (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code, &prop,
		        cparam->pro_ver) != 0) {
			log_error(""decode PUBREL variable header failed!"");
		}
		ack_cmd = CMD_PUBCOMP;
		ack     = true;
	} else if (type == CMD_PUBACK || type == CMD_PUBCOMP) {
		if (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code, &prop,
		        cparam->pro_ver) != 0) {
			log_error(""decode PUBACK or PUBCOMP variable header ""
			          ""failed!"");
		}
		// MQTT V5 flow control
		if (p->tcp_cparam->pro_ver == 5) {
			property_free(prop);
			p->qsend_quota++;
		}
	}
	if (ack == true) {
		// alloc a msg here costs memory. However we must do it for the
		// sake of compatibility with nng.
		if ((rv = nni_msg_alloc(&qmsg, 0)) != 0) {
			ack = false;
			rv  = NMQ_SERVER_BUSY;
			goto recv_error;
		}
		// TODO set reason code or property here if necessary

		nni_msg_set_cmd_type(qmsg, ack_cmd);
		nni_mqtt_msgack_encode(
		    qmsg, packet_id, reason_code, prop, cparam->pro_ver);
		nni_mqtt_pubres_header_encode(qmsg, ack_cmd);
		// if (prop != NULL) {
		// nni_msg_proto_set_property(qmsg, prop);
		// }
		// aio_begin?
		if (p->busy == false) {
			// nni_msg_insert(qmsg, nni_msg_header(qmsg),
			//     nni_msg_header_len(qmsg));
			if (nni_aio_begin(aio) != 0) {
				log_error(""ACK aio error!!"");
			}
			nni_msg_insert(qmsg, nni_msg_header(qmsg),
			    nni_msg_header_len(qmsg));
			iov[0].iov_len = nni_msg_len(qmsg);
			iov[0].iov_buf = nni_msg_body(qmsg);
			p->busy        = true;
			nni_aio_set_msg(p->qsaio, qmsg);
			// send ACK down...
			nni_aio_set_iov(p->qsaio, 1, iov);
			nng_stream_send(p->conn, p->qsaio);
			log_trace(""QoS ACK msg sent!"");
		} else {
			if (nni_lmq_full(&p->rslmq)) {
				// Make space for the new message. TODO add max
				// limit of msgq len in conf
				if (nni_lmq_cap(&p->rslmq) <=
				    NANO_MAX_QOS_PACKET) {
					if ((rv = nni_lmq_resize(&p->rslmq,
					         nni_lmq_cap(&p->rslmq) *
					             2)) == 0) {
						nni_lmq_put(&p->rslmq, qmsg);
					} else {
						// memory error.
						nni_msg_free(qmsg);
					}
				} else {
					nni_msg *old;
					(void) nni_lmq_get(&p->rslmq, &old);
					nni_msg_free(old);
					nni_lmq_put(&p->rslmq, qmsg);
				}
			} else {
				nni_lmq_put(&p->rslmq, qmsg);
			}
		}
		ack = false;
	}

	// keep connection & Schedule next receive
	// nni_pipe_bump_rx(p->npipe, n);
	if (!nni_list_empty(&p->recvq)) {
		tlstran_pipe_recv_start(p);
	}
	nni_pipe_bump_rx(p->npipe, n);
	nni_mtx_unlock(&p->mtx);

	nni_aio_set_msg(aio, msg);
	nni_aio_finish_sync(aio, 0, n);
	log_trace(""end of tlstran_pipe_recv_cb: synch! %p\n"", p);
	return;

recv_error:
	nni_aio_list_remove(aio);
	msg      = p->rxmsg;
	p->rxmsg = NULL;
	nni_pipe_bump_error(p->npipe, rv);
	nni_mtx_unlock(&p->mtx);

	nni_msg_free(msg);
	nni_aio_finish_error(aio, rv);
	log_trace(""tlstran_pipe_recv_cb: recv error rv: %d\n"", rv);
	return;
notify:
	// nni_pipe_bump_rx(p->npipe, n);
	nni_aio_list_remove(aio);
	// tlstran_pipe_recv_start(p);
	nni_mtx_unlock(&p->mtx);
	nni_aio_set_msg(aio, NULL);
	nni_aio_finish(aio, 0, 0);
	return;
}","static void
tlstran_pipe_recv_cb(void *VAR_0)
{
	nni_aio *     VAR_1;
	nni_iov       VAR_2[2];
	uint8_t       VAR_3;
	uint8_t       VAR_4;
	uint32_t      VAR_5 = 1;
	uint64_t      VAR_6 = 0;
	size_t        VAR_7;
	nni_msg      *VAR_8, *VAR_9;
	tlstran_pipe *VAR_10     = VAR_0;
	nni_aio *     VAR_11 = VAR_10->rxaio;
	conn_param *  VAR_12;
	bool          VAR_13   = false;

	log_trace(""tlstran_pipe_recv_cb %p\n"", VAR_10);
	nni_mtx_lock(&VAR_10->mtx);

	VAR_1 = nni_list_first(&VAR_10->recvq);

	if ((VAR_4 = nni_aio_result(VAR_11)) != 0) {
		log_warn("" recv aio error %s"", nng_strerror(VAR_4));
		VAR_4 = VAR_14;
		goto recv_error;
	}

	VAR_7 = nni_aio_count(VAR_11);
	VAR_10->gotrxhead += VAR_7;

	nni_aio_iov_advance(VAR_11, VAR_7);
	/* COMMENT_0 */
	VAR_6 = get_var_integer(VAR_10->rxlen, &VAR_5);
	log_trace(""new %ld recevied %ld header %x %d pos: %d len : %d"", VAR_7,
	    VAR_10->gotrxhead, VAR_10->rxlen[0], VAR_10->rxlen[1], VAR_5, VAR_6);
	log_trace(""still need byte count:%ld > 0\n"", nni_aio_iov_count(VAR_11));

	if (nni_aio_iov_count(VAR_11) > 0) {
		log_trace(""got: %x %x, %ld!!\n"", VAR_10->rxlen[0], VAR_10->rxlen[1],
		    strlen((char *) VAR_10->rxlen));
		nng_stream_recv(VAR_10->conn, VAR_11);
		nni_mtx_unlock(&VAR_10->mtx);
		return;
	} else if (VAR_10->gotrxhead <= VAR_15 &&
	    VAR_10->rxlen[VAR_10->gotrxhead - 1] > 0x7f) {
		/* COMMENT_1 */
		if (VAR_10->gotrxhead == VAR_15) {
			VAR_4 = VAR_16;
			goto recv_error;
		}
		/* COMMENT_2 */
		VAR_2[0].iov_buf = &VAR_10->rxlen[VAR_10->gotrxhead];
		VAR_2[0].iov_len = 1;
		nni_aio_set_iov(VAR_11, 1, VAR_2);
		nng_stream_recv(VAR_10->conn, VAR_11);
		nni_mtx_unlock(&VAR_10->mtx);
		return;
	} else if (VAR_6 == 0 && VAR_7 == 2) {
		if ((VAR_10->rxlen[0] & 0VAR_17) == VAR_18) {
			nng_aio_wait(VAR_10->rpaio);
			VAR_10->txlen[0] = VAR_19;
			VAR_10->txlen[1] = 0x00;
			VAR_2[0].iov_len = 2;
			VAR_2[0].iov_buf = &VAR_10->txlen;
			/* COMMENT_3 */
			nni_aio_set_iov(VAR_10->rpaio, 1, VAR_2);
			nng_stream_send(VAR_10->conn, VAR_10->rpaio);
			goto notify;
		}
	}

	/* COMMENT_4 */
	VAR_10->wantrxhead = VAR_6 + VAR_10->gotrxhead;
	VAR_12        = VAR_10->tcp_cparam;

	if (VAR_10->rxmsg == NULL) {
		/* COMMENT_5 */
		/* COMMENT_6 */
		log_trace(""pipe %p header got: %x %x %x %x %x, %ld!!\n"", VAR_10,
		    VAR_10->rxlen[0], VAR_10->rxlen[1], VAR_10->rxlen[2], VAR_10->rxlen[3],
		    VAR_10->rxlen[4], VAR_10->wantrxhead);
		/* COMMENT_7 */
		/* COMMENT_8 */
		if (VAR_6 > VAR_10->conf->max_packet_size) {
			log_error(""size error 0x95\n"");
			VAR_4 = VAR_20;
			goto recv_error;
		}

		if ((VAR_4 = nni_msg_alloc(&VAR_10->rxmsg, (size_t) VAR_6)) != 0) {
			log_error(""mem error %ld\n"", (size_t) VAR_6);
			VAR_4 = VAR_21;
			goto recv_error;
		}

		/* COMMENT_9 */
		/* COMMENT_10 */
		/* COMMENT_11 */
		if (VAR_6 != 0) {
			VAR_2[0].iov_buf = nni_msg_body(VAR_10->rxmsg);
			VAR_2[0].iov_len = (size_t) VAR_6;

			nni_aio_set_iov(VAR_11, 1, VAR_2);
			/* COMMENT_12 */
			nng_stream_recv(VAR_10->conn, VAR_11);
			nni_mtx_unlock(&VAR_10->mtx);
			return;
		}
	}

	/* COMMENT_13 */
	/* COMMENT_14 */
	nni_aio_list_remove(VAR_1);
	VAR_8      = VAR_10->rxmsg;
	VAR_10->rxmsg = NULL;
	VAR_7        = nni_msg_len(VAR_8);
	VAR_3     = VAR_10->rxlen[0] & 0xf0;

	fixed_header_adaptor(VAR_10->rxlen, VAR_8);
	nni_msg_set_conn_param(VAR_8, VAR_12);
	/* COMMENT_15 */
	nni_msg_set_remaining_len(VAR_8, VAR_6);
	nni_msg_set_cmd_type(VAR_8, VAR_3);
	log_trace(""remain_len %d cparam %p clientid %s username %s proto %d\n"",
	    VAR_6, VAR_12, VAR_12->clientid.body, VAR_12->username.body,
	    VAR_12->pro_ver);

	/* COMMENT_16 */
	log_trace(""The type of msg is %x"", VAR_3);
	uint16_t  VAR_22   = 0;
	uint8_t   VAR_23 = 0;
	property *VAR_24        = NULL;
	uint8_t   VAR_25     = 0;
	if (VAR_3 == VAR_26) {
		nni_msg_set_timestamp(VAR_8, nng_clock());
		uint8_t VAR_27 = nni_msg_get_pub_qos(VAR_8);
		if (VAR_27 > 0) {
			/* COMMENT_17 */
			/* COMMENT_18 */
			if (VAR_10->tcp_cparam->pro_ver == 5) {
				if (VAR_10->qrecv_quota > 0) {
					VAR_10->qrecv_quota--;
				} else {
					VAR_4 = VAR_28;
					goto recv_error;
				}
			}
			if (VAR_27 == 1) {
				VAR_25 = VAR_29;
			} else if (VAR_27 == 2) {
				VAR_25 = VAR_30;
			} else {
				log_warn(""Wrong QoS level!"");
				VAR_4 = VAR_31;
				goto recv_error;
			}
			if ((VAR_22 = nni_msg_get_pub_pid(VAR_8)) == 0) {
				VAR_4 = VAR_31;
				goto recv_error;
			}
			VAR_13       = true;
		}
	} else if (VAR_3 == VAR_30) {
		if (nni_mqtt_pubres_decode(VAR_8, &VAR_22, &VAR_23, &VAR_24,
		        VAR_12->pro_ver) != 0) {
			log_error(""decode PUBREC variable header failed!"");
		}
		VAR_25 = VAR_32;
		VAR_13     = true;
	} else if (VAR_3 == VAR_32) {
		if (nni_mqtt_pubres_decode(VAR_8, &VAR_22, &VAR_23, &VAR_24,
		        VAR_12->pro_ver) != 0) {
			log_error(""decode PUBREL variable header failed!"");
		}
		VAR_25 = VAR_33;
		VAR_13     = true;
	} else if (VAR_3 == VAR_29 || VAR_3 == VAR_33) {
		if (nni_mqtt_pubres_decode(VAR_8, &VAR_22, &VAR_23, &VAR_24,
		        VAR_12->pro_ver) != 0) {
			log_error(""decode PUBACK or PUBCOMP variable header ""
			          ""failed!"");
		}
		/* COMMENT_19 */
		if (VAR_10->tcp_cparam->pro_ver == 5) {
			property_free(VAR_24);
			VAR_10->qsend_quota++;
		}
	}
	if (VAR_13 == true) {
		/* COMMENT_20 */
		/* COMMENT_21 */
		if ((VAR_4 = nni_msg_alloc(&VAR_9, 0)) != 0) {
			VAR_13 = false;
			VAR_4  = VAR_14;
			goto recv_error;
		}
		/* COMMENT_22 */

		nni_msg_set_cmd_type(VAR_9, VAR_25);
		nni_mqtt_msgack_encode(
		    VAR_9, VAR_22, VAR_23, VAR_24, VAR_12->pro_ver);
		nni_mqtt_pubres_header_encode(VAR_9, VAR_25);
		/* COMMENT_23 */
		/* COMMENT_24 */
		/* COMMENT_25 */
		/* COMMENT_26 */
		if (VAR_10->busy == false) {
			/* COMMENT_27 */
			/* COMMENT_28 */
			if (nni_aio_begin(VAR_1) != 0) {
				log_error(""ACK aio error!!"");
			}
			nni_msg_insert(VAR_9, nni_msg_header(VAR_9),
			    nni_msg_header_len(VAR_9));
			VAR_2[0].iov_len = nni_msg_len(VAR_9);
			VAR_2[0].iov_buf = nni_msg_body(VAR_9);
			VAR_10->busy        = true;
			nni_aio_set_msg(VAR_10->qsaio, VAR_9);
			/* COMMENT_29 */
			nni_aio_set_iov(VAR_10->qsaio, 1, VAR_2);
			nng_stream_send(VAR_10->conn, VAR_10->qsaio);
			log_trace(""QoS ACK msg sent!"");
		} else {
			if (nni_lmq_full(&VAR_10->rslmq)) {
				/* COMMENT_30 */
				/* COMMENT_31 */
				if (nni_lmq_cap(&VAR_10->rslmq) <=
				    VAR_34) {
					if ((VAR_4 = nni_lmq_resize(&VAR_10->rslmq,
					         nni_lmq_cap(&VAR_10->rslmq) *
					             2)) == 0) {
						nni_lmq_put(&VAR_10->rslmq, VAR_9);
					} else {
						/* COMMENT_32 */
						nni_msg_free(VAR_9);
					}
				} else {
					nni_msg *VAR_35;
					(void) nni_lmq_get(&VAR_10->rslmq, &VAR_35);
					nni_msg_free(VAR_35);
					nni_lmq_put(&VAR_10->rslmq, VAR_9);
				}
			} else {
				nni_lmq_put(&VAR_10->rslmq, VAR_9);
			}
		}
		VAR_13 = false;
	}

	/* COMMENT_33 */
	/* COMMENT_34 */
	if (!nni_list_empty(&VAR_10->recvq)) {
		tlstran_pipe_recv_start(VAR_10);
	}
	nni_pipe_bump_rx(VAR_10->npipe, VAR_7);
	nni_mtx_unlock(&VAR_10->mtx);

	nni_aio_set_msg(VAR_1, VAR_8);
	nni_aio_finish_sync(VAR_1, 0, VAR_7);
	log_trace(""end of tlstran_pipe_recv_cb: synch! %p\n"", VAR_10);
	return;

recv_error:
	nni_aio_list_remove(VAR_1);
	VAR_8      = VAR_10->rxmsg;
	VAR_10->rxmsg = NULL;
	nni_pipe_bump_error(VAR_10->npipe, VAR_4);
	nni_mtx_unlock(&VAR_10->mtx);

	nni_msg_free(VAR_8);
	nni_aio_finish_error(VAR_1, VAR_4);
	log_trace(""tlstran_pipe_recv_cb: recv error rv: %d\n"", VAR_4);
	return;
notify:
	/* COMMENT_34 */
	nni_aio_list_remove(VAR_1);
	/* COMMENT_35 */
	nni_mtx_unlock(&VAR_10->mtx);
	nni_aio_set_msg(VAR_1, NULL);
	nni_aio_finish(VAR_1, 0, 0);
	return;
}",nanomq/NanoNNG/657e6c81c474bdee0e6413483b990e90610030c1/broker_tls.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -149,8 +149,15 @@
 				ack_cmd = CMD_PUBACK;
 			} else if (qos_pac == 2) {
 				ack_cmd = CMD_PUBREC;
-			}
-			packet_id = nni_msg_get_pub_pid(msg);
+			} else {
+				log_warn(""Wrong QoS level!"");
+				rv = PROTOCOL_ERROR;
+				goto recv_error;
+			}
+			if ((packet_id = nni_msg_get_pub_pid(msg)) == 0) {
+				rv = PROTOCOL_ERROR;
+				goto recv_error;
+			}
 			ack       = true;
 		}
 	} else if (type == CMD_PUBREC) {","{'deleted_lines': ['\t\t\t}', '\t\t\tpacket_id = nni_msg_get_pub_pid(msg);'], 'added_lines': ['\t\t\t} else {', '\t\t\t\tlog_warn(""Wrong QoS level!"");', '\t\t\t\trv = PROTOCOL_ERROR;', '\t\t\t\tgoto recv_error;', '\t\t\t}', '\t\t\tif ((packet_id = nni_msg_get_pub_pid(msg)) == 0) {', '\t\t\t\trv = PROTOCOL_ERROR;', '\t\t\t\tgoto recv_error;', '\t\t\t}']}",True,A heap buffer overflow vulnerability exists in NanoMQ 0.17.2. The vulnerability can be triggered by calling the function nni_msg_get_pub_pid() in the file message.c. An attacker could exploit this vulnerability to cause a denial of service attack.,7.5,HIGH,2,test,2023-04-15T07:35:17Z,4
CVE-2023-33658,['CWE-787'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,nanomq/NanoNNG,* FIX [mqtt_tcp] fix https://github.com/emqx/nanomq/issues/1153 for nanosdk,971b7d0264a706d2bd091125e2efe6599aa13756,https://github.com/nanomq/NanoNNG/commit/971b7d0264a706d2bd091125e2efe6599aa13756,src/mqtt/transport/tcp/mqtt_tcp.c,mqtt_tcptran_pipe_recv_cb,"static void
mqtt_tcptran_pipe_recv_cb(void *arg)
{
nni_aio *          aio;
nni_iov            iov[2];
uint8_t            type, pos, flags;
uint32_t           len = 0, rv;
size_t             n;
nni_msg *          msg, *qmsg;
mqtt_tcptran_pipe *p     = arg;
nni_aio *          rxaio = p->rxaio;
bool               ack   = false;
nni_mtx_lock(&p->mtx);
aio = nni_list_first(&p->recvq);
if ((rv = nni_aio_result(rxaio)) != 0) {
rv = SERVER_UNAVAILABLE;
goto recv_error;
}
n = nni_aio_count(rxaio);
p->gotrxhead += n;
nni_aio_iov_advance(rxaio, n);
if (nni_aio_iov_count(rxaio) > 0) {
nng_stream_recv(p->conn, rxaio);
nni_mtx_unlock(&p->mtx);
return;
}
rv = mqtt_get_remaining_length(p->rxlen, p->gotrxhead, &len, &pos);
p->wantrxhead = len + 1 + pos;
if (p->gotrxhead <= 5 && p->rxlen[p->gotrxhead - 1] > 0x7f) {
if (p->gotrxhead == NNI_NANO_MAX_HEADER_SIZE) {
rv = PACKET_TOO_LARGE;
goto recv_error;
}
iov[0].iov_buf = &p->rxlen[p->gotrxhead];
iov[0].iov_len = 1;
nni_aio_set_iov(rxaio, 1, iov);
nng_stream_recv(p->conn, rxaio);
nni_mtx_unlock(&p->mtx);
return;
}
if (NULL == p->rxmsg) {
if ((len > p->rcvmax) && (p->rcvmax > 0)) {
rv = PACKET_TOO_LARGE;
goto recv_error;
}
if ((rv = nni_msg_alloc(&p->rxmsg, (size_t) len)) != 0) {
rv = UNSPECIFIED_ERROR;
goto recv_error;
}
nni_msg_set_remaining_len(p->rxmsg, len);
if (len != 0) {
iov[0].iov_buf = nni_msg_body(p->rxmsg);
iov[0].iov_len = (size_t) len;
nni_aio_set_iov(rxaio, 1, iov);
nng_stream_recv(p->conn, rxaio);
nni_mtx_unlock(&p->mtx);
return;
}
}
nni_aio_list_remove(aio);
nni_msg_header_append(p->rxmsg, p->rxlen, pos + 1);
msg      = p->rxmsg;
p->rxmsg = NULL;
n        = nni_msg_len(msg);
type     = p->rxlen[0] & 0xf0;
flags    = p->rxlen[0] & 0x0f;
uint8_t   qos_pac;
uint16_t  packet_id   = 0;
uint8_t   reason_code = 0;
property *prop        = NULL;
uint8_t   ack_cmd     = 0;
switch (type) {
case CMD_PUBLISH:
qos_pac = nni_msg_get_pub_qos(msg);
if (qos_pac > 0) {
if (qos_pac == 1) {
ack_cmd = CMD_PUBACK;
} else if (qos_pac == 2) {
ack_cmd = CMD_PUBREC;
}
packet_id = nni_msg_get_pub_pid(msg);
ack = true;
}
break;
case CMD_PUBREC:
if (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code, &prop,
p->proto) != 0) {
rv = PROTOCOL_ERROR;
goto recv_error;
}
ack_cmd = CMD_PUBREL;
ack     = true;
break;
case CMD_PUBREL:
if (flags == 0x02) {
if (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code,
&prop, p->proto) != 0) {
rv = PROTOCOL_ERROR;
goto recv_error;
}
ack_cmd = CMD_PUBCOMP;
ack     = true;
break;
} else {
rv = PROTOCOL_ERROR;
goto recv_error;
}
case CMD_PUBACK:
case CMD_PUBCOMP:
if (nni_mqtt_pubres_decode(
msg, &packet_id, &reason_code, &prop, p->proto) != 0) {
rv = PROTOCOL_ERROR;
goto recv_error;
}
if (p->proto == MQTT_PROTOCOL_VERSION_v5) {
p->sndmax++;
}
break;
case CMD_PINGRESP:
break;
case CMD_DISCONNECT:
break;
default:
break;
}
if (ack == true) {
if ((rv = nni_msg_alloc(&qmsg, 0)) != 0) {
ack = false;
rv  = UNSPECIFIED_ERROR;
goto recv_error;
}
nni_mqtt_msgack_encode(
qmsg, packet_id, reason_code, prop, p->proto);
nni_mqtt_pubres_header_encode(qmsg, ack_cmd);
if (p->proto == MQTT_PROTOCOL_VERSION_v5) {
property_free(prop);
}
if (p->busy == false) {
iov[0].iov_len = nni_msg_header_len(qmsg);
iov[0].iov_buf = nni_msg_header(qmsg);
iov[1].iov_len = nni_msg_len(qmsg);
iov[1].iov_buf = nni_msg_body(qmsg);
p->busy        = true;
nni_aio_set_msg(p->qsaio, qmsg);
nni_aio_set_iov(p->qsaio, 2, iov);
nng_stream_send(p->conn, p->qsaio);
} else {
if (nni_lmq_full(&p->rslmq)) {
if (nni_lmq_cap(&p->rslmq) <=
NNG_TRAN_MAX_LMQ_SIZE) {
if ((rv = nni_lmq_resize(&p->rslmq,
nni_lmq_cap(&p->rslmq) *
2)) == 0) {
nni_lmq_put(&p->rslmq, qmsg);
} else {
nni_msg_free(qmsg);
}
} else {
nni_msg *old;
(void) nni_lmq_get(&p->rslmq, &old);
nni_msg_free(old);
nni_lmq_put(&p->rslmq, qmsg);
}
} else {
nni_lmq_put(&p->rslmq, qmsg);
}
}
ack = false;
}
nni_pipe_bump_rx(p->npipe, n);
if (!nni_list_empty(&p->recvq)) {
mqtt_tcptran_pipe_recv_start(p);
}
#ifdef NNG_HAVE_MQTT_BROKER
nni_msg_set_conn_param(msg, p->cparam);
#endif
nni_aio_set_msg(aio, msg);
p->pingcnt = 0;
nni_mtx_unlock(&p->mtx);
nni_aio_finish_sync(aio, 0, n);
return;
recv_error:
nni_aio_list_remove(aio);
msg      = p->rxmsg;
p->rxmsg = NULL;
nni_pipe_bump_error(p->npipe, rv);
nni_mtx_unlock(&p->mtx);
nni_msg_free(msg);
nni_aio_finish_error(aio, SERVER_UNAVAILABLE);
}","static void
mqtt_tcptran_pipe_recv_cb(void *VAR_0)
{
nni_aio *          VAR_1;
nni_iov            VAR_2[2];
uint8_t            VAR_3, VAR_4, VAR_5;
uint32_t           VAR_6 = 0, VAR_7;
size_t             VAR_8;
nni_msg *          VAR_9, *VAR_10;
mqtt_tcptran_pipe *VAR_11     = VAR_0;
nni_aio *          VAR_12 = VAR_11->rxaio;
bool               VAR_13   = false;
nni_mtx_lock(&VAR_11->mtx);
VAR_1 = nni_list_first(&VAR_11->recvq);
if ((VAR_7 = nni_aio_result(VAR_12)) != 0) {
VAR_7 = VAR_14;
goto recv_error;
}
VAR_8 = nni_aio_count(VAR_12);
VAR_11->gotrxhead += VAR_8;
nni_aio_iov_advance(VAR_12, VAR_8);
if (nni_aio_iov_count(VAR_12) > 0) {
nng_stream_recv(VAR_11->conn, VAR_12);
nni_mtx_unlock(&VAR_11->mtx);
return;
}
VAR_7 = mqtt_get_remaining_length(VAR_11->rxlen, VAR_11->gotrxhead, &VAR_6, &VAR_4);
VAR_11->wantrxhead = VAR_6 + 1 + VAR_4;
if (VAR_11->gotrxhead <= 5 && VAR_11->rxlen[VAR_11->gotrxhead - 1] > 0x7f) {
if (VAR_11->gotrxhead == VAR_15) {
VAR_7 = VAR_16;
goto recv_error;
}
VAR_2[0].iov_buf = &VAR_11->rxlen[VAR_11->gotrxhead];
VAR_2[0].iov_len = 1;
nni_aio_set_iov(VAR_12, 1, VAR_2);
nng_stream_recv(VAR_11->conn, VAR_12);
nni_mtx_unlock(&VAR_11->mtx);
return;
}
if (NULL == VAR_11->rxmsg) {
if ((VAR_6 > VAR_11->rcvmax) && (VAR_11->rcvmax > 0)) {
VAR_7 = VAR_16;
goto recv_error;
}
if ((VAR_7 = nni_msg_alloc(&VAR_11->rxmsg, (size_t) VAR_6)) != 0) {
VAR_7 = VAR_17;
goto recv_error;
}
nni_msg_set_remaining_len(VAR_11->rxmsg, VAR_6);
if (VAR_6 != 0) {
VAR_2[0].iov_buf = nni_msg_body(VAR_11->rxmsg);
VAR_2[0].iov_len = (size_t) VAR_6;
nni_aio_set_iov(VAR_12, 1, VAR_2);
nng_stream_recv(VAR_11->conn, VAR_12);
nni_mtx_unlock(&VAR_11->mtx);
return;
}
}
nni_aio_list_remove(VAR_1);
nni_msg_header_append(VAR_11->rxmsg, VAR_11->rxlen, VAR_4 + 1);
VAR_9      = VAR_11->rxmsg;
VAR_11->rxmsg = NULL;
VAR_8        = nni_msg_len(VAR_9);
VAR_3     = VAR_11->rxlen[0] & 0xf0;
VAR_5    = VAR_11->rxlen[0] & 0x0f;
uint8_t   VAR_18;
uint16_t  VAR_19   = 0;
uint8_t   VAR_20 = 0;
property *VAR_21        = NULL;
uint8_t   VAR_22     = 0;
switch (VAR_3) {
case VAR_23:
VAR_18 = nni_msg_get_pub_qos(VAR_9);
if (VAR_18 > 0) {
if (VAR_18 == 1) {
VAR_22 = VAR_24;
} else if (VAR_18 == 2) {
VAR_22 = VAR_25;
}
VAR_19 = nni_msg_get_pub_pid(VAR_9);
VAR_13 = true;
}
break;
case VAR_25:
if (nni_mqtt_pubres_decode(VAR_9, &VAR_19, &VAR_20, &VAR_21,
VAR_11->proto) != 0) {
VAR_7 = VAR_26;
goto recv_error;
}
VAR_22 = VAR_27;
VAR_13     = true;
break;
case VAR_27:
if (VAR_5 == 0x02) {
if (nni_mqtt_pubres_decode(VAR_9, &VAR_19, &VAR_20,
&VAR_21, VAR_11->proto) != 0) {
VAR_7 = VAR_26;
goto recv_error;
}
VAR_22 = VAR_28;
VAR_13     = true;
break;
} else {
VAR_7 = VAR_26;
goto recv_error;
}
case VAR_24:
case VAR_28:
if (nni_mqtt_pubres_decode(
VAR_9, &VAR_19, &VAR_20, &VAR_21, VAR_11->proto) != 0) {
VAR_7 = VAR_26;
goto recv_error;
}
if (VAR_11->proto == VAR_29) {
VAR_11->sndmax++;
}
break;
case VAR_30:
break;
case VAR_31:
break;
default:
break;
}
if (VAR_13 == true) {
if ((VAR_7 = nni_msg_alloc(&VAR_10, 0)) != 0) {
VAR_13 = false;
VAR_7  = VAR_17;
goto recv_error;
}
nni_mqtt_msgack_encode(
VAR_10, VAR_19, VAR_20, VAR_21, VAR_11->proto);
nni_mqtt_pubres_header_encode(VAR_10, VAR_22);
if (VAR_11->proto == VAR_29) {
property_free(VAR_21);
}
if (VAR_11->busy == false) {
VAR_2[0].iov_len = nni_msg_header_len(VAR_10);
VAR_2[0].iov_buf = nni_msg_header(VAR_10);
VAR_2[1].iov_len = nni_msg_len(VAR_10);
VAR_2[1].iov_buf = nni_msg_body(VAR_10);
VAR_11->busy        = true;
nni_aio_set_msg(VAR_11->qsaio, VAR_10);
nni_aio_set_iov(VAR_11->qsaio, 2, VAR_2);
nng_stream_send(VAR_11->conn, VAR_11->qsaio);
} else {
if (nni_lmq_full(&VAR_11->rslmq)) {
if (nni_lmq_cap(&VAR_11->rslmq) <=
VAR_32) {
if ((VAR_7 = nni_lmq_resize(&VAR_11->rslmq,
nni_lmq_cap(&VAR_11->rslmq) *
2)) == 0) {
nni_lmq_put(&VAR_11->rslmq, VAR_10);
} else {
nni_msg_free(VAR_10);
}
} else {
nni_msg *VAR_33;
(void) nni_lmq_get(&VAR_11->rslmq, &VAR_33);
nni_msg_free(VAR_33);
nni_lmq_put(&VAR_11->rslmq, VAR_10);
}
} else {
nni_lmq_put(&VAR_11->rslmq, VAR_10);
}
}
VAR_13 = false;
}
nni_pipe_bump_rx(VAR_11->npipe, VAR_8);
if (!nni_list_empty(&VAR_11->recvq)) {
mqtt_tcptran_pipe_recv_start(VAR_11);
}
#ifdef VAR_34
nni_msg_set_conn_param(VAR_9, VAR_11->cparam);
#endif
nni_aio_set_msg(VAR_1, VAR_9);
VAR_11->pingcnt = 0;
nni_mtx_unlock(&VAR_11->mtx);
nni_aio_finish_sync(VAR_1, 0, VAR_8);
return;
recv_error:
nni_aio_list_remove(VAR_1);
VAR_9      = VAR_11->rxmsg;
VAR_11->rxmsg = NULL;
nni_pipe_bump_error(VAR_11->npipe, VAR_7);
nni_mtx_unlock(&VAR_11->mtx);
nni_msg_free(VAR_9);
nni_aio_finish_error(VAR_1, VAR_14);
}",nanomq/NanoNNG/971b7d0264a706d2bd091125e2efe6599aa13756/mqtt_tcp.c/vul/before/0.json,"static void
mqtt_tcptran_pipe_recv_cb(void *arg)
{
	nni_aio *          aio;
	nni_iov            iov[2];
	uint8_t            type, pos, flags;
	uint32_t           len = 0, rv;
	size_t             n;
	nni_msg *          msg, *qmsg;
	mqtt_tcptran_pipe *p     = arg;
	nni_aio *          rxaio = p->rxaio;
	bool               ack   = false;

	nni_mtx_lock(&p->mtx);

	aio = nni_list_first(&p->recvq);

	if ((rv = nni_aio_result(rxaio)) != 0) {
		rv = SERVER_UNAVAILABLE;
		goto recv_error;
	}

	n = nni_aio_count(rxaio);
	p->gotrxhead += n;

	nni_aio_iov_advance(rxaio, n);
	if (nni_aio_iov_count(rxaio) > 0) {
		nng_stream_recv(p->conn, rxaio);
		nni_mtx_unlock(&p->mtx);
		return;
	}

	rv = mqtt_get_remaining_length(p->rxlen, p->gotrxhead, &len, &pos);
	p->wantrxhead = len + 1 + pos;
	if (p->gotrxhead <= 5 && p->rxlen[p->gotrxhead - 1] > 0x7f) {
		if (p->gotrxhead == NNI_NANO_MAX_HEADER_SIZE) {
			rv = PACKET_TOO_LARGE;
			goto recv_error;
		}
		// same packet, continue receving next byte of remaining length
		iov[0].iov_buf = &p->rxlen[p->gotrxhead];
		iov[0].iov_len = 1;
		nni_aio_set_iov(rxaio, 1, iov);
		nng_stream_recv(p->conn, rxaio);
		nni_mtx_unlock(&p->mtx);
		return;
	}

	// fixed header finished
	if (NULL == p->rxmsg) {
		// Make sure the message payload is not too big.  If it is
		// the caller will shut down the pipe.
		if ((len > p->rcvmax) && (p->rcvmax > 0)) {
			rv = PACKET_TOO_LARGE;
			goto recv_error;
		}

		if ((rv = nni_msg_alloc(&p->rxmsg, (size_t) len)) != 0) {
			rv = UNSPECIFIED_ERROR;
			goto recv_error;
		}
		// set remaining length for bridging
		nni_msg_set_remaining_len(p->rxmsg, len);

		// Submit the rest of the data for a read -- seperate Fixed
		// header with variable header and so on
		//  we want to read the entire message now.
		if (len != 0) {
			iov[0].iov_buf = nni_msg_body(p->rxmsg);
			iov[0].iov_len = (size_t) len;

			nni_aio_set_iov(rxaio, 1, iov);
			// second recv action
			nng_stream_recv(p->conn, rxaio);
			nni_mtx_unlock(&p->mtx);
			return;
		}
	}

	// We read a message completely.  Let the user know the good news. use
	// as application message callback of users
	nni_aio_list_remove(aio);
	nni_msg_header_append(p->rxmsg, p->rxlen, pos + 1);
	msg      = p->rxmsg;
	p->rxmsg = NULL;
	n        = nni_msg_len(msg);
	type     = p->rxlen[0] & 0xf0;
	flags    = p->rxlen[0] & 0x0f;

	// set the payload pointer of msg according to packet_type
	uint8_t   qos_pac;
	uint16_t  packet_id   = 0;
	uint8_t   reason_code = 0;
	property *prop        = NULL;
	uint8_t   ack_cmd     = 0;
	switch (type) {
	case CMD_PUBLISH:
		// should we seperate the 2 phase work of QoS into 2 aios?
		// TODO MQTT v5 qos
		qos_pac = nni_msg_get_pub_qos(msg);
		if (qos_pac > 0) {
			if (qos_pac == 1) {
				ack_cmd = CMD_PUBACK;
			} else if (qos_pac == 2) {
				ack_cmd = CMD_PUBREC;
			} else {
				rv = PROTOCOL_ERROR;
				goto recv_error;
			}
			if ((packet_id = nni_msg_get_pub_pid(msg)) == 0) {
				rv = PROTOCOL_ERROR;
				goto recv_error;
			}
			ack = true;
		}
		break;
	case CMD_PUBREC:
		if (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code, &prop,
		        p->proto) != 0) {
			rv = PROTOCOL_ERROR;
			goto recv_error;
		}
		ack_cmd = CMD_PUBREL;
		ack     = true;
		break;
	case CMD_PUBREL:
		if (flags == 0x02) {
			if (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code,
			        &prop, p->proto) != 0) {
				rv = PROTOCOL_ERROR;
				goto recv_error;
			}
			ack_cmd = CMD_PUBCOMP;
			ack     = true;
			break;
		} else {
			rv = PROTOCOL_ERROR;
			goto recv_error;
		}
	case CMD_PUBACK:
		// TODO set property for user callback
	case CMD_PUBCOMP:
		if (nni_mqtt_pubres_decode(
		        msg, &packet_id, &reason_code, &prop, p->proto) != 0) {
			rv = PROTOCOL_ERROR;
			goto recv_error;
		}
		if (p->proto == MQTT_PROTOCOL_VERSION_v5) {
			p->sndmax++;
		}
		break;
	case CMD_PINGRESP:
		//free here?
		break;
	case CMD_DISCONNECT:
		break;
	default:
		break;
	}

	if (ack == true) {
		// alloc a msg here costs memory. However we must do it for the
		// sake of compatibility with nng.
		if ((rv = nni_msg_alloc(&qmsg, 0)) != 0) {
			ack = false;
			rv  = UNSPECIFIED_ERROR;
			goto recv_error;
		}
		// TODO set reason code or property here if necessary
		nni_mqtt_msgack_encode(
		    qmsg, packet_id, reason_code, prop, p->proto);
		nni_mqtt_pubres_header_encode(qmsg, ack_cmd);
		if (p->proto == MQTT_PROTOCOL_VERSION_v5) {
			property_free(prop);
		}
		// aio_begin?
		if (p->busy == false) {
			iov[0].iov_len = nni_msg_header_len(qmsg);
			iov[0].iov_buf = nni_msg_header(qmsg);
			iov[1].iov_len = nni_msg_len(qmsg);
			iov[1].iov_buf = nni_msg_body(qmsg);
			p->busy        = true;
			nni_aio_set_msg(p->qsaio, qmsg);
			// send ACK down...
			nni_aio_set_iov(p->qsaio, 2, iov);
			nng_stream_send(p->conn, p->qsaio);
		} else {
			if (nni_lmq_full(&p->rslmq)) {
				// Make space for the new message. TODO add max
				// limit of msgq len in conf
				if (nni_lmq_cap(&p->rslmq) <=
				    NNG_TRAN_MAX_LMQ_SIZE) {
					if ((rv = nni_lmq_resize(&p->rslmq,
					         nni_lmq_cap(&p->rslmq) *
					             2)) == 0) {
						nni_lmq_put(&p->rslmq, qmsg);
					} else {
						// memory error.
						nni_msg_free(qmsg);
					}
				} else {
					nni_msg *old;
					(void) nni_lmq_get(&p->rslmq, &old);
					nni_msg_free(old);
					nni_lmq_put(&p->rslmq, qmsg);
				}
			} else {
				nni_lmq_put(&p->rslmq, qmsg);
			}
		}
		ack = false;
	}

	// keep connection & Schedule next receive
	nni_pipe_bump_rx(p->npipe, n);
	if (!nni_list_empty(&p->recvq)) {
		mqtt_tcptran_pipe_recv_start(p);
	}
#ifdef NNG_HAVE_MQTT_BROKER
	nni_msg_set_conn_param(msg, p->cparam);
#endif
	nni_aio_set_msg(aio, msg);
	p->pingcnt = 0;
	nni_mtx_unlock(&p->mtx);
	nni_aio_finish_sync(aio, 0, n);
	return;

recv_error:
	nni_aio_list_remove(aio);
	msg      = p->rxmsg;
	p->rxmsg = NULL;
	nni_pipe_bump_error(p->npipe, rv);
	nni_mtx_unlock(&p->mtx);

	nni_msg_free(msg);
	nni_aio_finish_error(aio, SERVER_UNAVAILABLE);
}","static void
mqtt_tcptran_pipe_recv_cb(void *VAR_0)
{
	nni_aio *          VAR_1;
	nni_iov            VAR_2[2];
	uint8_t            VAR_3, VAR_4, VAR_5;
	uint32_t           VAR_6 = 0, VAR_7;
	size_t             VAR_8;
	nni_msg *          VAR_9, *VAR_10;
	mqtt_tcptran_pipe *VAR_11     = VAR_0;
	nni_aio *          VAR_12 = VAR_11->rxaio;
	bool               VAR_13   = false;

	nni_mtx_lock(&VAR_11->mtx);

	VAR_1 = nni_list_first(&VAR_11->recvq);

	if ((VAR_7 = nni_aio_result(VAR_12)) != 0) {
		VAR_7 = VAR_14;
		goto recv_error;
	}

	VAR_8 = nni_aio_count(VAR_12);
	VAR_11->gotrxhead += VAR_8;

	nni_aio_iov_advance(VAR_12, VAR_8);
	if (nni_aio_iov_count(VAR_12) > 0) {
		nng_stream_recv(VAR_11->conn, VAR_12);
		nni_mtx_unlock(&VAR_11->mtx);
		return;
	}

	VAR_7 = mqtt_get_remaining_length(VAR_11->rxlen, VAR_11->gotrxhead, &VAR_6, &VAR_4);
	VAR_11->wantrxhead = VAR_6 + 1 + VAR_4;
	if (VAR_11->gotrxhead <= 5 && VAR_11->rxlen[VAR_11->gotrxhead - 1] > 0x7f) {
		if (VAR_11->gotrxhead == VAR_15) {
			VAR_7 = VAR_16;
			goto recv_error;
		}
		/* COMMENT_0 */
		VAR_2[0].iov_buf = &VAR_11->rxlen[VAR_11->gotrxhead];
		VAR_2[0].iov_len = 1;
		nni_aio_set_iov(VAR_12, 1, VAR_2);
		nng_stream_recv(VAR_11->conn, VAR_12);
		nni_mtx_unlock(&VAR_11->mtx);
		return;
	}

	/* COMMENT_1 */
	if (NULL == VAR_11->rxmsg) {
		/* COMMENT_2 */
		/* COMMENT_3 */
		if ((VAR_6 > VAR_11->rcvmax) && (VAR_11->rcvmax > 0)) {
			VAR_7 = VAR_16;
			goto recv_error;
		}

		if ((VAR_7 = nni_msg_alloc(&VAR_11->rxmsg, (size_t) VAR_6)) != 0) {
			VAR_7 = VAR_17;
			goto recv_error;
		}
		/* COMMENT_4 */
		nni_msg_set_remaining_len(VAR_11->rxmsg, VAR_6);

		/* COMMENT_5 */
		/* COMMENT_6 */
		/* COMMENT_7 */
		if (VAR_6 != 0) {
			VAR_2[0].iov_buf = nni_msg_body(VAR_11->rxmsg);
			VAR_2[0].iov_len = (size_t) VAR_6;

			nni_aio_set_iov(VAR_12, 1, VAR_2);
			/* COMMENT_8 */
			nng_stream_recv(VAR_11->conn, VAR_12);
			nni_mtx_unlock(&VAR_11->mtx);
			return;
		}
	}

	/* COMMENT_9 */
	/* COMMENT_10 */
	nni_aio_list_remove(VAR_1);
	nni_msg_header_append(VAR_11->rxmsg, VAR_11->rxlen, VAR_4 + 1);
	VAR_9      = VAR_11->rxmsg;
	VAR_11->rxmsg = NULL;
	VAR_8        = nni_msg_len(VAR_9);
	VAR_3     = VAR_11->rxlen[0] & 0xf0;
	VAR_5    = VAR_11->rxlen[0] & 0x0f;

	/* COMMENT_11 */
	uint8_t   VAR_18;
	uint16_t  VAR_19   = 0;
	uint8_t   VAR_20 = 0;
	property *VAR_21        = NULL;
	uint8_t   VAR_22     = 0;
	switch (VAR_3) {
	case VAR_23:
		/* COMMENT_12 */
		/* COMMENT_13 */
		VAR_18 = nni_msg_get_pub_qos(VAR_9);
		if (VAR_18 > 0) {
			if (VAR_18 == 1) {
				VAR_22 = VAR_24;
			} else if (VAR_18 == 2) {
				VAR_22 = VAR_25;
			} else {
				VAR_7 = VAR_26;
				goto recv_error;
			}
			if ((VAR_19 = nni_msg_get_pub_pid(VAR_9)) == 0) {
				VAR_7 = VAR_26;
				goto recv_error;
			}
			VAR_13 = true;
		}
		break;
	case VAR_25:
		if (nni_mqtt_pubres_decode(VAR_9, &VAR_19, &VAR_20, &VAR_21,
		        VAR_11->proto) != 0) {
			VAR_7 = VAR_26;
			goto recv_error;
		}
		VAR_22 = VAR_27;
		VAR_13     = true;
		break;
	case VAR_27:
		if (VAR_5 == 0x02) {
			if (nni_mqtt_pubres_decode(VAR_9, &VAR_19, &VAR_20,
			        &VAR_21, VAR_11->proto) != 0) {
				VAR_7 = VAR_26;
				goto recv_error;
			}
			VAR_22 = VAR_28;
			VAR_13     = true;
			break;
		} else {
			VAR_7 = VAR_26;
			goto recv_error;
		}
	case VAR_24:
		/* COMMENT_14 */
	case VAR_28:
		if (nni_mqtt_pubres_decode(
		        VAR_9, &VAR_19, &VAR_20, &VAR_21, VAR_11->proto) != 0) {
			VAR_7 = VAR_26;
			goto recv_error;
		}
		if (VAR_11->proto == VAR_29) {
			VAR_11->sndmax++;
		}
		break;
	case VAR_30:
		/* COMMENT_15 */
		break;
	case VAR_31:
		break;
	default:
		break;
	}

	if (VAR_13 == true) {
		/* COMMENT_16 */
		/* COMMENT_17 */
		if ((VAR_7 = nni_msg_alloc(&VAR_10, 0)) != 0) {
			VAR_13 = false;
			VAR_7  = VAR_17;
			goto recv_error;
		}
		/* COMMENT_18 */
		nni_mqtt_msgack_encode(
		    VAR_10, VAR_19, VAR_20, VAR_21, VAR_11->proto);
		nni_mqtt_pubres_header_encode(VAR_10, VAR_22);
		if (VAR_11->proto == VAR_29) {
			property_free(VAR_21);
		}
		/* COMMENT_19 */
		if (VAR_11->busy == false) {
			VAR_2[0].iov_len = nni_msg_header_len(VAR_10);
			VAR_2[0].iov_buf = nni_msg_header(VAR_10);
			VAR_2[1].iov_len = nni_msg_len(VAR_10);
			VAR_2[1].iov_buf = nni_msg_body(VAR_10);
			VAR_11->busy        = true;
			nni_aio_set_msg(VAR_11->qsaio, VAR_10);
			/* COMMENT_20 */
			nni_aio_set_iov(VAR_11->qsaio, 2, VAR_2);
			nng_stream_send(VAR_11->conn, VAR_11->qsaio);
		} else {
			if (nni_lmq_full(&VAR_11->rslmq)) {
				/* COMMENT_21 */
				/* COMMENT_22 */
				if (nni_lmq_cap(&VAR_11->rslmq) <=
				    VAR_32) {
					if ((VAR_7 = nni_lmq_resize(&VAR_11->rslmq,
					         nni_lmq_cap(&VAR_11->rslmq) *
					             2)) == 0) {
						nni_lmq_put(&VAR_11->rslmq, VAR_10);
					} else {
						/* COMMENT_23 */
						nni_msg_free(VAR_10);
					}
				} else {
					nni_msg *VAR_33;
					(void) nni_lmq_get(&VAR_11->rslmq, &VAR_33);
					nni_msg_free(VAR_33);
					nni_lmq_put(&VAR_11->rslmq, VAR_10);
				}
			} else {
				nni_lmq_put(&VAR_11->rslmq, VAR_10);
			}
		}
		VAR_13 = false;
	}

	/* COMMENT_24 */
	nni_pipe_bump_rx(VAR_11->npipe, VAR_8);
	if (!nni_list_empty(&VAR_11->recvq)) {
		mqtt_tcptran_pipe_recv_start(VAR_11);
	}
#ifdef VAR_34
	nni_msg_set_conn_param(VAR_9, VAR_11->cparam);
#endif
	nni_aio_set_msg(VAR_1, VAR_9);
	VAR_11->pingcnt = 0;
	nni_mtx_unlock(&VAR_11->mtx);
	nni_aio_finish_sync(VAR_1, 0, VAR_8);
	return;

recv_error:
	nni_aio_list_remove(VAR_1);
	VAR_9      = VAR_11->rxmsg;
	VAR_11->rxmsg = NULL;
	nni_pipe_bump_error(VAR_11->npipe, VAR_7);
	nni_mtx_unlock(&VAR_11->mtx);

	nni_msg_free(VAR_9);
	nni_aio_finish_error(VAR_1, VAR_14);
}",nanomq/NanoNNG/971b7d0264a706d2bd091125e2efe6599aa13756/mqtt_tcp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -103,8 +103,14 @@
 				ack_cmd = CMD_PUBACK;
 			} else if (qos_pac == 2) {
 				ack_cmd = CMD_PUBREC;
-			}
-			packet_id = nni_msg_get_pub_pid(msg);
+			} else {
+				rv = PROTOCOL_ERROR;
+				goto recv_error;
+			}
+			if ((packet_id = nni_msg_get_pub_pid(msg)) == 0) {
+				rv = PROTOCOL_ERROR;
+				goto recv_error;
+			}
 			ack = true;
 		}
 		break;","{'deleted_lines': ['\t\t\t}', '\t\t\tpacket_id = nni_msg_get_pub_pid(msg);'], 'added_lines': ['\t\t\t} else {', '\t\t\t\trv = PROTOCOL_ERROR;', '\t\t\t\tgoto recv_error;', '\t\t\t}', '\t\t\tif ((packet_id = nni_msg_get_pub_pid(msg)) == 0) {', '\t\t\t\trv = PROTOCOL_ERROR;', '\t\t\t\tgoto recv_error;', '\t\t\t}']}",True,A heap buffer overflow vulnerability exists in NanoMQ 0.17.2. The vulnerability can be triggered by calling the function nni_msg_get_pub_pid() in the file message.c. An attacker could exploit this vulnerability to cause a denial of service attack.,7.5,HIGH,2,test,2023-04-15T07:36:11Z,4
CVE-2023-33457,['CWE-120'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,sogou/workflow,Fix URIParser bug.,a1b83adfd0174e8d9fd5e67092f41b4bcade14ce,https://github.com/sogou/workflow/commit/a1b83adfd0174e8d9fd5e67092f41b4bcade14ce,src/util/URIParser.cc,URIParser::parse,"int URIParser::parse(const char *str, ParsedURI& uri)
{
uri.state = URI_STATE_INVALID;
int start_idx[URI_PART_ELEMENTS] = {0};
int end_idx[URI_PART_ELEMENTS] = {0};
int pre_state = URI_SCHEME;;
int i;
bool in_ipv6 = false;
for (i = 0; str[i]; i++)
{
if (str[i] == ':')
{
end_idx[URI_SCHEME] = i++;
break;
}
}
if (end_idx[URI_SCHEME] == 0)
return -1;
if (str[i] == '/' && str[i + 1] == '/')
{
pre_state = URI_HOST;
i += 2;
if (str[i] == '[')
in_ipv6= true;
else
start_idx[URI_USERINFO] = i;
start_idx[URI_HOST] = i;
}
else
{
pre_state = URI_PATH;
start_idx[URI_PATH] = i;
}
bool skip_path = false;
if (start_idx[URI_PATH] == 0)
{
for (; ; i++)
{
switch (authority_map[(unsigned char)str[i]])
{
case 0:
continue;
case URI_USERINFO:
if (str[i + 1] == '[')
in_ipv6 = true;
end_idx[URI_USERINFO] = i;
start_idx[URI_HOST] = i + 1;
pre_state = URI_HOST;
continue;
case URI_HOST:
if (str[i - 1] == ']')
in_ipv6 = false;
if (!in_ipv6)
{
end_idx[URI_HOST] = i;
start_idx[URI_PORT] = i + 1;
pre_state = URI_PORT;
}
continue;
case URI_QUERY:
end_idx[pre_state] = i;
start_idx[URI_QUERY] = i + 1;
pre_state = URI_QUERY;
skip_path = true;
continue;
case URI_FRAGMENT:
end_idx[pre_state] = i;
start_idx[URI_FRAGMENT] = i + 1;
end_idx[URI_FRAGMENT] = i + strlen(str + i);
pre_state = URI_PART_ELEMENTS;
skip_path = true;
break;
case URI_PATH:
if (skip_path)
continue;
start_idx[URI_PATH] = i;
break;
case URI_PART_ELEMENTS:
skip_path = true;
break;
}
break;
}
}
if (pre_state != URI_PART_ELEMENTS)
end_idx[pre_state] = i;
if (!skip_path)
{
pre_state = URI_PATH;
for (; str[i]; i++)
{
if (str[i] == '?')
{
end_idx[URI_PATH] = i;
start_idx[URI_QUERY] = i + 1;
pre_state = URI_QUERY;
while (str[i + 1])
{
if (str[++i] == '#')
break;
}
}
if (str[i] == '#')
{
end_idx[pre_state] = i;
start_idx[URI_FRAGMENT] = i + 1;
pre_state = URI_FRAGMENT;
break;
}
}
end_idx[pre_state] = i + strlen(str + i);
}
for (int i = 0; i < URI_QUERY; i++)
{
for (int j = start_idx[i]; j < end_idx[i]; j++)
{
if (!valid_char[i][(unsigned char)str[j]])
return -1;}
}
char **dst[URI_PART_ELEMENTS] = {&uri.scheme, &uri.userinfo, &uri.host, &uri.port,
&uri.query, &uri.fragment, &uri.path};
for (int i = 0; i < URI_PART_ELEMENTS; i++)
{
if (end_idx[i] > start_idx[i])
{
size_t len = end_idx[i] - start_idx[i];
*dst[i] = (char *)realloc(*dst[i], len + 1);
if (*dst[i] == NULL)
{
uri.state = URI_STATE_ERROR;
uri.error = errno;
return -1;
}
if (i == URI_HOST && str[start_idx[i]] == '[')
{
len -= 2;
memcpy(*dst[i], str + start_idx[i] + 1, len);
}
else
memcpy(*dst[i], str + start_idx[i], len);
(*dst[i])[len] = '\0';
}
else
{
free(*dst[i]);
*dst[i] = NULL;
}
}
uri.state = URI_STATE_SUCCESS;
return 0;
}","int URIParser::parse(const char *VAR_0, ParsedURI& VAR_1)
{
VAR_1.state = VAR_2;
int VAR_3[VAR_4] = {0};
int VAR_5[VAR_4] = {0};
int VAR_6 = VAR_7;;
int VAR_8;
bool VAR_9 = false;
for (VAR_8 = 0; VAR_0[VAR_8]; VAR_8++)
{
if (VAR_0[VAR_8] == ':')
{
VAR_5[VAR_7] = VAR_8++;
break;
}
}
if (VAR_5[VAR_7] == 0)
return -1;
if (VAR_0[VAR_8] == '/' && VAR_0[VAR_8 + 1] == '/')
{
VAR_6 = VAR_10;
VAR_8 += 2;
if (VAR_0[VAR_8] == '[')
VAR_9= true;
else
VAR_3[VAR_11] = VAR_8;
VAR_3[VAR_10] = VAR_8;
}
else
{
VAR_6 = VAR_12;
VAR_3[VAR_12] = VAR_8;
}
bool VAR_13 = false;
if (VAR_3[VAR_12] == 0)
{
for (; ; VAR_8++)
{
switch (VAR_14[(unsigned char)VAR_0[VAR_8]])
{
case 0:
continue;
case VAR_11:
if (VAR_0[VAR_8 + 1] == '[')
VAR_9 = true;
VAR_5[VAR_11] = VAR_8;
VAR_3[VAR_10] = VAR_8 + 1;
VAR_6 = VAR_10;
continue;
case VAR_10:
if (VAR_0[VAR_8 - 1] == ']')
VAR_9 = false;
if (!VAR_9)
{
VAR_5[VAR_10] = VAR_8;
VAR_3[VAR_15] = VAR_8 + 1;
VAR_6 = VAR_15;
}
continue;
case VAR_16:
VAR_5[VAR_6] = VAR_8;
VAR_3[VAR_16] = VAR_8 + 1;
VAR_6 = VAR_16;
VAR_13 = true;
continue;
case VAR_17:
VAR_5[VAR_6] = VAR_8;
VAR_3[VAR_17] = VAR_8 + 1;
VAR_5[VAR_17] = VAR_8 + strlen(VAR_0 + VAR_8);
VAR_6 = VAR_4;
VAR_13 = true;
break;
case VAR_12:
if (VAR_13)
continue;
VAR_3[VAR_12] = VAR_8;
break;
case VAR_4:
VAR_13 = true;
break;
}
break;
}
}
if (VAR_6 != VAR_4)
VAR_5[VAR_6] = VAR_8;
if (!VAR_13)
{
VAR_6 = VAR_12;
for (; VAR_0[VAR_8]; VAR_8++)
{
if (VAR_0[VAR_8] == '?')
{
VAR_5[VAR_12] = VAR_8;
VAR_3[VAR_16] = VAR_8 + 1;
VAR_6 = VAR_16;
while (VAR_0[VAR_8 + 1])
{
if (VAR_0[++VAR_8] == '#')
break;
}
}
if (VAR_0[VAR_8] == '#')
{
VAR_5[VAR_6] = VAR_8;
VAR_3[VAR_17] = VAR_8 + 1;
VAR_6 = VAR_17;
break;
}
}
VAR_5[VAR_6] = VAR_8 + strlen(VAR_0 + VAR_8);
}
for (int VAR_8 = 0; VAR_8 < VAR_16; VAR_8++)
{
for (int VAR_18 = VAR_3[VAR_8]; VAR_18 < VAR_5[VAR_8]; VAR_18++)
{
if (!VAR_19[VAR_8][(unsigned char)VAR_0[VAR_18]])
return -1;
}
}
char **VAR_20[VAR_4] = {&VAR_1.scheme, &VAR_1.userinfo, &VAR_1.host, &VAR_1.port,
&VAR_1.query, &VAR_1.fragment, &VAR_1.path};
for (int VAR_8 = 0; VAR_8 < VAR_4; VAR_8++)
{
if (VAR_5[VAR_8] > VAR_3[VAR_8])
{
size_t VAR_21 = VAR_5[VAR_8] - VAR_3[VAR_8];
*VAR_20[VAR_8] = (char *)realloc(*VAR_20[VAR_8], VAR_21 + 1);
if (*VAR_20[VAR_8] == NULL)
{
VAR_1.state = VAR_22;
VAR_1.error = VAR_23;
return -1;
}
if (VAR_8 == VAR_10 && VAR_0[VAR_3[VAR_8]] == '[')
{
VAR_21 -= 2;
memcpy(*VAR_20[VAR_8], VAR_0 + VAR_3[VAR_8] + 1, VAR_21);
}
else
memcpy(*VAR_20[VAR_8], VAR_0 + VAR_3[VAR_8], VAR_21);
(*VAR_20[VAR_8])[VAR_21] = '\0';
}
else
{
free(*VAR_20[VAR_8]);
*VAR_20[VAR_8] = NULL;
}
}
VAR_1.state = VAR_24;
return 0;
}",sogou/workflow/a1b83adfd0174e8d9fd5e67092f41b4bcade14ce/URIParser.cc/vul/before/0.json,"int URIParser::parse(const char *str, ParsedURI& uri)
{
	uri.state = URI_STATE_INVALID;

	int start_idx[URI_PART_ELEMENTS] = {0};
	int end_idx[URI_PART_ELEMENTS] = {0};
	int pre_state = URI_SCHEME;
	bool in_ipv6 = false;
	int i;

	for (i = 0; str[i]; i++)
	{
		if (str[i] == ':')
		{
			end_idx[URI_SCHEME] = i++;
			break;
		}
	}

	if (end_idx[URI_SCHEME] == 0)
		return -1;

	if (str[i] == '/' && str[i + 1] == '/')
	{
		pre_state = URI_HOST;
		i += 2;
		if (str[i] == '[')
			in_ipv6 = true;
		else
			start_idx[URI_USERINFO] = i;

		start_idx[URI_HOST] = i;
	}
	else
	{
		pre_state = URI_PATH;
		start_idx[URI_PATH] = i;
	}

	bool skip_path = false;
	if (start_idx[URI_PATH] == 0)
	{
		for (; ; i++)
		{
			switch (authority_map[(unsigned char)str[i]])
			{
				case 0:
					continue;

				case URI_USERINFO:
					if (str[i + 1] == '[')
						in_ipv6 = true;

					end_idx[URI_USERINFO] = i;
					start_idx[URI_HOST] = i + 1;
					pre_state = URI_HOST;
					continue;

				case URI_HOST:
					if (str[i - 1] == ']')
						in_ipv6 = false;

					if (!in_ipv6)
					{
						end_idx[URI_HOST] = i;
						start_idx[URI_PORT] = i + 1;
						pre_state = URI_PORT;
					}
					continue;

				case URI_QUERY:
					end_idx[pre_state] = i;
					start_idx[URI_QUERY] = i + 1;
					pre_state = URI_QUERY;
					skip_path = true;
					continue;

				case URI_FRAGMENT:
					end_idx[pre_state] = i;
					start_idx[URI_FRAGMENT] = i + 1;
					end_idx[URI_FRAGMENT] = i + strlen(str + i);
					pre_state = URI_PART_ELEMENTS;
					skip_path = true;
					break;

				case URI_PATH:
					if (skip_path)
						continue;

					start_idx[URI_PATH] = i;
					break;

				case URI_PART_ELEMENTS:
					skip_path = true;
					break;
			}

			break;
		}
	}

	if (pre_state != URI_PART_ELEMENTS)
		end_idx[pre_state] = i;

	if (!skip_path)
	{
		pre_state = URI_PATH;
		for (; str[i]; i++)
		{
			if (str[i] == '?')
			{
				end_idx[URI_PATH] = i;
				start_idx[URI_QUERY] = i + 1;
				pre_state = URI_QUERY;
				while (str[i + 1])
				{
					if (str[++i] == '#')
						break;
				}
			}

			if (str[i] == '#')
			{
				end_idx[pre_state] = i;
				start_idx[URI_FRAGMENT] = i + 1;
				pre_state = URI_FRAGMENT;
				break;
			}
		}

		end_idx[pre_state] = i + strlen(str + i);
	}

	for (int i = 0; i < URI_QUERY; i++)
	{
		for (int j = start_idx[i]; j < end_idx[i]; j++)
		{
			if (!valid_char[i][(unsigned char)str[j]])
				return -1;//invalid char
		}
	}

	char **dst[URI_PART_ELEMENTS] = {&uri.scheme, &uri.userinfo, &uri.host, &uri.port,
					 &uri.query, &uri.fragment, &uri.path};

	for (int i = 0; i < URI_PART_ELEMENTS; i++)
	{
		if (end_idx[i] > start_idx[i])
		{
			size_t len = end_idx[i] - start_idx[i];

			*dst[i] = (char *)realloc(*dst[i], len + 1);
			if (*dst[i] == NULL)
			{
				uri.state = URI_STATE_ERROR;
				uri.error = errno;
				return -1;
			}

			if (i == URI_HOST && str[start_idx[i]] == '[' &&
				str[end_idx[i] - 1] == ']')
			{
				len -= 2;
				memcpy(*dst[i], str + start_idx[i] + 1, len);
			}
			else
				memcpy(*dst[i], str + start_idx[i], len);

			(*dst[i])[len] = '\0';
		}
		else
		{
			free(*dst[i]);
			*dst[i] = NULL;
		}
	}

	uri.state = URI_STATE_SUCCESS;
	return 0;
}","int URIParser::parse(const char *VAR_0, ParsedURI& VAR_1)
{
	VAR_1.state = VAR_2;

	int VAR_3[VAR_4] = {0};
	int VAR_5[VAR_4] = {0};
	int VAR_6 = VAR_7;
	bool VAR_8 = false;
	int VAR_9;

	for (VAR_9 = 0; VAR_0[VAR_9]; VAR_9++)
	{
		if (VAR_0[VAR_9] == ':')
		{
			VAR_5[VAR_7] = VAR_9++;
			break;
		}
	}

	if (VAR_5[VAR_7] == 0)
		return -1;

	if (VAR_0[VAR_9] == '/' && VAR_0[VAR_9 + 1] == '/')
	{
		VAR_6 = VAR_10;
		VAR_9 += 2;
		if (VAR_0[VAR_9] == '[')
			VAR_8 = true;
		else
			VAR_3[VAR_11] = VAR_9;

		VAR_3[VAR_10] = VAR_9;
	}
	else
	{
		VAR_6 = VAR_12;
		VAR_3[VAR_12] = VAR_9;
	}

	bool VAR_13 = false;
	if (VAR_3[VAR_12] == 0)
	{
		for (; ; VAR_9++)
		{
			switch (VAR_14[(unsigned char)VAR_0[VAR_9]])
			{
				case 0:
					continue;

				case VAR_11:
					if (VAR_0[VAR_9 + 1] == '[')
						VAR_8 = true;

					VAR_5[VAR_11] = VAR_9;
					VAR_3[VAR_10] = VAR_9 + 1;
					VAR_6 = VAR_10;
					continue;

				case VAR_10:
					if (VAR_0[VAR_9 - 1] == ']')
						VAR_8 = false;

					if (!VAR_8)
					{
						VAR_5[VAR_10] = VAR_9;
						VAR_3[VAR_15] = VAR_9 + 1;
						VAR_6 = VAR_15;
					}
					continue;

				case VAR_16:
					VAR_5[VAR_6] = VAR_9;
					VAR_3[VAR_16] = VAR_9 + 1;
					VAR_6 = VAR_16;
					VAR_13 = true;
					continue;

				case VAR_17:
					VAR_5[VAR_6] = VAR_9;
					VAR_3[VAR_17] = VAR_9 + 1;
					VAR_5[VAR_17] = VAR_9 + strlen(VAR_0 + VAR_9);
					VAR_6 = VAR_4;
					VAR_13 = true;
					break;

				case VAR_12:
					if (VAR_13)
						continue;

					VAR_3[VAR_12] = VAR_9;
					break;

				case VAR_4:
					VAR_13 = true;
					break;
			}

			break;
		}
	}

	if (VAR_6 != VAR_4)
		VAR_5[VAR_6] = VAR_9;

	if (!VAR_13)
	{
		VAR_6 = VAR_12;
		for (; VAR_0[VAR_9]; VAR_9++)
		{
			if (VAR_0[VAR_9] == '?')
			{
				VAR_5[VAR_12] = VAR_9;
				VAR_3[VAR_16] = VAR_9 + 1;
				VAR_6 = VAR_16;
				while (VAR_0[VAR_9 + 1])
				{
					if (VAR_0[++VAR_9] == '#')
						break;
				}
			}

			if (VAR_0[VAR_9] == '#')
			{
				VAR_5[VAR_6] = VAR_9;
				VAR_3[VAR_17] = VAR_9 + 1;
				VAR_6 = VAR_17;
				break;
			}
		}

		VAR_5[VAR_6] = VAR_9 + strlen(VAR_0 + VAR_9);
	}

	for (int VAR_9 = 0; VAR_9 < VAR_16; VAR_9++)
	{
		for (int VAR_18 = VAR_3[VAR_9]; VAR_18 < VAR_5[VAR_9]; VAR_18++)
		{
			if (!VAR_19[VAR_9][(unsigned char)VAR_0[VAR_18]])
				return -1;/* COMMENT_0 */
		}
	}

	char **VAR_20[VAR_4] = {&VAR_1.scheme, &VAR_1.userinfo, &VAR_1.host, &VAR_1.port,
					 &VAR_1.query, &VAR_1.fragment, &VAR_1.path};

	for (int VAR_9 = 0; VAR_9 < VAR_4; VAR_9++)
	{
		if (VAR_5[VAR_9] > VAR_3[VAR_9])
		{
			size_t VAR_21 = VAR_5[VAR_9] - VAR_3[VAR_9];

			*VAR_20[VAR_9] = (char *)realloc(*VAR_20[VAR_9], VAR_21 + 1);
			if (*VAR_20[VAR_9] == NULL)
			{
				VAR_1.state = VAR_22;
				VAR_1.error = VAR_23;
				return -1;
			}

			if (VAR_9 == VAR_10 && VAR_0[VAR_3[VAR_9]] == '[' &&
				VAR_0[VAR_5[VAR_9] - 1] == ']')
			{
				VAR_21 -= 2;
				memcpy(*VAR_20[VAR_9], VAR_0 + VAR_3[VAR_9] + 1, VAR_21);
			}
			else
				memcpy(*VAR_20[VAR_9], VAR_0 + VAR_3[VAR_9], VAR_21);

			(*VAR_20[VAR_9])[VAR_21] = '\0';
		}
		else
		{
			free(*VAR_20[VAR_9]);
			*VAR_20[VAR_9] = NULL;
		}
	}

	VAR_1.state = VAR_24;
	return 0;
}",sogou/workflow/a1b83adfd0174e8d9fd5e67092f41b4bcade14ce/URIParser.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,9 +4,9 @@
 
 	int start_idx[URI_PART_ELEMENTS] = {0};
 	int end_idx[URI_PART_ELEMENTS] = {0};
-	int pre_state = URI_SCHEME;;
+	int pre_state = URI_SCHEME;
+	bool in_ipv6 = false;
 	int i;
-	bool in_ipv6 = false;
 
 	for (i = 0; str[i]; i++)
 	{
@@ -25,7 +25,7 @@
 		pre_state = URI_HOST;
 		i += 2;
 		if (str[i] == '[')
-			in_ipv6= true;
+			in_ipv6 = true;
 		else
 			start_idx[URI_USERINFO] = i;
 
@@ -98,6 +98,7 @@
 			break;
 		}
 	}
+
 	if (pre_state != URI_PART_ELEMENTS)
 		end_idx[pre_state] = i;
 
@@ -126,6 +127,7 @@
 				break;
 			}
 		}
+
 		end_idx[pre_state] = i + strlen(str + i);
 	}
 
@@ -155,13 +157,15 @@
 				return -1;
 			}
 
-			if (i == URI_HOST && str[start_idx[i]] == '[')
+			if (i == URI_HOST && str[start_idx[i]] == '[' &&
+				str[end_idx[i] - 1] == ']')
 			{
 				len -= 2;
 				memcpy(*dst[i], str + start_idx[i] + 1, len);
 			}
 			else
 				memcpy(*dst[i], str + start_idx[i], len);
+
 			(*dst[i])[len] = '\0';
 		}
 		else","{'deleted_lines': ['\tint pre_state = URI_SCHEME;;', '\tbool in_ipv6 = false;', '\t\t\tin_ipv6= true;', ""\t\t\tif (i == URI_HOST && str[start_idx[i]] == '[')""], 'added_lines': ['\tint pre_state = URI_SCHEME;', '\tbool in_ipv6 = false;', '\t\t\tin_ipv6 = true;', '', '', ""\t\t\tif (i == URI_HOST && str[start_idx[i]] == '[' &&"", ""\t\t\t\tstr[end_idx[i] - 1] == ']')"", '']}",True,"In Sogou Workflow v0.10.6, memcpy a negtive size in URIParser::parse , may cause buffer-overflow and crash.",8.8,HIGH,2,test,2023-05-05T12:33:13Z,4
CVE-2023-2610,['CWE-190'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,vim,"patch 9.0.1532: crash when expanding ""~"" in substitute causes very long text

Problem:    Crash when expanding ""~"" in substitute causes very long text.
Solution:   Limit the text length to MAXCOL.",ab9a2d884b3a4abe319606ea95a5a6d6b01cd73a,https://github.com/vim/vim/commit/ab9a2d884b3a4abe319606ea95a5a6d6b01cd73a,src/regexp.c,regtilde,"char_u *
regtilde(char_u *source, int magic)
{
char_u*newsub = source;
char_u*tmpsub;
char_u*p;
intlen;
intprevlen;
for (p = newsub; *p; ++p)
{
if ((*p == '~' && magic) || (*p == '\\' && *(p + 1) == '~' && !magic))
{
if (reg_prev_sub != NULL)
{
prevlen = (int)STRLEN(reg_prev_sub);
tmpsub = alloc(STRLEN(newsub) + prevlen);
if (tmpsub != NULL)
{
len = (int)(p - newsub);    mch_memmove(tmpsub, newsub, (size_t)len);
mch_memmove(tmpsub + len, reg_prev_sub, (size_t)prevlen);
if (!magic)
++p;    STRCPY(tmpsub + len + prevlen, p + 1);
if (newsub != source)vim_free(newsub);
newsub = tmpsub;
p = newsub + len + prevlen;
}
}
else if (magic)
STRMOVE(p, p + 1);    else
STRMOVE(p, p + 2);    --p;
}
else
{
if (*p == '\\' && p[1])++p;
if (has_mbyte)
p += (*mb_ptr2len)(p) - 1;
}
}
vim_free(reg_prev_sub);
reg_prev_sub = vim_strsave(newsub);
return newsub;
}","char_u *
regtilde(char_u *VAR_0, int VAR_1)
{
char_u*VAR_2 = VAR_0;
char_u*VAR_3;
char_u*VAR_4;
intVAR_5;
intVAR_6;
for (VAR_4 = VAR_2; *VAR_4; ++VAR_4)
{
if ((*VAR_4 == '~' && VAR_1) || (*VAR_4 == '\\' && *(VAR_4 + 1) == '~' && !VAR_1))
{
if (VAR_7 != NULL)
{
VAR_6 = (int)STRLEN(VAR_7);
VAR_3 = alloc(STRLEN(VAR_2) + VAR_6);
if (VAR_3 != NULL)
{
VAR_5 = (int)(VAR_4 - VAR_2);
mch_memmove(VAR_3, VAR_2, (size_t)VAR_5);
mch_memmove(VAR_3 + VAR_5, VAR_7, (size_t)VAR_6);
if (!VAR_1)
++VAR_4;
STRCPY(VAR_3 + VAR_5 + VAR_6, VAR_4 + 1);
if (VAR_2 != VAR_0)
vim_free(VAR_2);
VAR_2 = VAR_3;
VAR_4 = VAR_2 + VAR_5 + VAR_6;
}
}
else if (VAR_1)
STRMOVE(VAR_4, VAR_4 + 1);
else
STRMOVE(VAR_4, VAR_4 + 2);
--VAR_4;
}
else
{
if (*VAR_4 == '\\' && VAR_4[1])
++VAR_4;
if (VAR_8)
VAR_4 += (*VAR_9)(VAR_4) - 1;
}
}
vim_free(VAR_7);
VAR_7 = vim_strsave(VAR_2);
return VAR_2;
}",vim/ab9a2d884b3a4abe319606ea95a5a6d6b01cd73a/regexp.c/vul/before/0.json,"char_u *
regtilde(char_u *source, int magic)
{
    char_u	*newsub = source;
    char_u	*p;

    for (p = newsub; *p; ++p)
    {
	if ((*p == '~' && magic) || (*p == '\\' && *(p + 1) == '~' && !magic))
	{
	    if (reg_prev_sub != NULL)
	    {
		// length = len(newsub) - 1 + len(prev_sub) + 1
		// Avoid making the text longer than MAXCOL, it will cause
		// trouble at some point.
		size_t	prevsublen = STRLEN(reg_prev_sub);
		size_t  newsublen = STRLEN(newsub);
		if (prevsublen > MAXCOL || newsublen > MAXCOL
					    || newsublen + prevsublen > MAXCOL)
		{
		    emsg(_(e_resulting_text_too_long));
		    break;
		}

		char_u *tmpsub = alloc(newsublen + prevsublen);
		if (tmpsub != NULL)
		{
		    // copy prefix
		    size_t prefixlen = p - newsub;	// not including ~
		    mch_memmove(tmpsub, newsub, prefixlen);
		    // interpret tilde
		    mch_memmove(tmpsub + prefixlen, reg_prev_sub,
							       prevsublen);
		    // copy postfix
		    if (!magic)
			++p;			// back off backslash
		    STRCPY(tmpsub + prefixlen + prevsublen, p + 1);

		    if (newsub != source)	// allocated newsub before
			vim_free(newsub);
		    newsub = tmpsub;
		    p = newsub + prefixlen + prevsublen;
		}
	    }
	    else if (magic)
		STRMOVE(p, p + 1);	// remove '~'
	    else
		STRMOVE(p, p + 2);	// remove '\~'
	    --p;
	}
	else
	{
	    if (*p == '\\' && p[1])		// skip escaped characters
		++p;
	    if (has_mbyte)
		p += (*mb_ptr2len)(p) - 1;
	}
    }

    // Store a copy of newsub  in reg_prev_sub.  It is always allocated,
    // because recursive calls may make the returned string invalid.
    vim_free(reg_prev_sub);
    reg_prev_sub = vim_strsave(newsub);

    return newsub;
}","char_u *
regtilde(char_u *VAR_0, int VAR_1)
{
    char_u	*VAR_2 = VAR_0;
    char_u	*VAR_3;

    for (VAR_3 = VAR_2; *VAR_3; ++VAR_3)
    {
	if ((*VAR_3 == '~' && VAR_1) || (*VAR_3 == '\\' && *(VAR_3 + 1) == '~' && !VAR_1))
	{
	    if (VAR_4 != NULL)
	    {
		/* COMMENT_0 */
		/* COMMENT_1 */
		/* COMMENT_2 */
		size_t	VAR_5 = STRLEN(VAR_4);
		size_t  VAR_6 = STRLEN(VAR_2);
		if (VAR_5 > VAR_7 || VAR_6 > VAR_7
					    || VAR_6 + VAR_5 > VAR_7)
		{
		    emsg(_(VAR_8));
		    break;
		}

		char_u *VAR_9 = alloc(VAR_6 + VAR_5);
		if (VAR_9 != NULL)
		{
		    /* COMMENT_3 */
		    size_t VAR_10 = VAR_3 - VAR_2;	/* COMMENT_4 */
		    mch_memmove(VAR_9, VAR_2, VAR_10);
		    /* COMMENT_5 */
		    mch_memmove(VAR_9 + VAR_10, VAR_4,
							       VAR_5);
		    /* COMMENT_6 */
		    if (!VAR_1)
			++VAR_3;			/* COMMENT_7 */
		    STRCPY(VAR_9 + VAR_10 + VAR_5, VAR_3 + 1);

		    if (VAR_2 != VAR_0)	/* COMMENT_8 */
			vim_free(VAR_2);
		    VAR_2 = VAR_9;
		    VAR_3 = VAR_2 + VAR_10 + VAR_5;
		}
	    }
	    else if (VAR_1)
		STRMOVE(VAR_3, VAR_3 + 1);	/* COMMENT_9 */
	    else
		STRMOVE(VAR_3, VAR_3 + 2);	/* COMMENT_10 */
	    --VAR_3;
	}
	else
	{
	    if (*VAR_3 == '\\' && VAR_3[1])		/* COMMENT_11 */
		++VAR_3;
	    if (VAR_11)
		VAR_3 += (*VAR_12)(VAR_3) - 1;
	}
    }

    /* COMMENT_12 */
    /* COMMENT_13 */
    vim_free(VAR_4);
    VAR_4 = vim_strsave(VAR_2);

    return VAR_2;
}",vim/ab9a2d884b3a4abe319606ea95a5a6d6b01cd73a/regexp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,10 +2,7 @@
 regtilde(char_u *source, int magic)
 {
     char_u	*newsub = source;
-    char_u	*tmpsub;
     char_u	*p;
-    int		len;
-    int		prevlen;
 
     for (p = newsub; *p; ++p)
     {
@@ -14,24 +11,35 @@
 	    if (reg_prev_sub != NULL)
 	    {
 		// length = len(newsub) - 1 + len(prev_sub) + 1
-		prevlen = (int)STRLEN(reg_prev_sub);
-		tmpsub = alloc(STRLEN(newsub) + prevlen);
+		// Avoid making the text longer than MAXCOL, it will cause
+		// trouble at some point.
+		size_t	prevsublen = STRLEN(reg_prev_sub);
+		size_t  newsublen = STRLEN(newsub);
+		if (prevsublen > MAXCOL || newsublen > MAXCOL
+					    || newsublen + prevsublen > MAXCOL)
+		{
+		    emsg(_(e_resulting_text_too_long));
+		    break;
+		}
+
+		char_u *tmpsub = alloc(newsublen + prevsublen);
 		if (tmpsub != NULL)
 		{
 		    // copy prefix
-		    len = (int)(p - newsub);	// not including ~
-		    mch_memmove(tmpsub, newsub, (size_t)len);
+		    size_t prefixlen = p - newsub;	// not including ~
+		    mch_memmove(tmpsub, newsub, prefixlen);
 		    // interpret tilde
-		    mch_memmove(tmpsub + len, reg_prev_sub, (size_t)prevlen);
+		    mch_memmove(tmpsub + prefixlen, reg_prev_sub,
+							       prevsublen);
 		    // copy postfix
 		    if (!magic)
 			++p;			// back off backslash
-		    STRCPY(tmpsub + len + prevlen, p + 1);
+		    STRCPY(tmpsub + prefixlen + prevsublen, p + 1);
 
-		    if (newsub != source)	// already allocated newsub
+		    if (newsub != source)	// allocated newsub before
 			vim_free(newsub);
 		    newsub = tmpsub;
-		    p = newsub + len + prevlen;
+		    p = newsub + prefixlen + prevsublen;
 		}
 	    }
 	    else if (magic)","{'deleted_lines': ['    char_u\t*tmpsub;', '    int\t\tlen;', '    int\t\tprevlen;', '\t\tprevlen = (int)STRLEN(reg_prev_sub);', '\t\ttmpsub = alloc(STRLEN(newsub) + prevlen);', '\t\t    len = (int)(p - newsub);\t// not including ~', '\t\t    mch_memmove(tmpsub, newsub, (size_t)len);', '\t\t    mch_memmove(tmpsub + len, reg_prev_sub, (size_t)prevlen);', '\t\t    STRCPY(tmpsub + len + prevlen, p + 1);', '\t\t    if (newsub != source)\t// already allocated newsub', '\t\t    p = newsub + len + prevlen;'], 'added_lines': ['\t\t// Avoid making the text longer than MAXCOL, it will cause', '\t\t// trouble at some point.', '\t\tsize_t\tprevsublen = STRLEN(reg_prev_sub);', '\t\tsize_t  newsublen = STRLEN(newsub);', '\t\tif (prevsublen > MAXCOL || newsublen > MAXCOL', '\t\t\t\t\t    || newsublen + prevsublen > MAXCOL)', '\t\t{', '\t\t    emsg(_(e_resulting_text_too_long));', '\t\t    break;', '\t\t}', '', '\t\tchar_u *tmpsub = alloc(newsublen + prevsublen);', '\t\t    size_t prefixlen = p - newsub;\t// not including ~', '\t\t    mch_memmove(tmpsub, newsub, prefixlen);', '\t\t    mch_memmove(tmpsub + prefixlen, reg_prev_sub,', '\t\t\t\t\t\t\t       prevsublen);', '\t\t    STRCPY(tmpsub + prefixlen + prevsublen, p + 1);', '\t\t    if (newsub != source)\t// allocated newsub before', '\t\t    p = newsub + prefixlen + prevsublen;']}",True,Integer Overflow or Wraparound in GitHub repository vim/vim prior to 9.0.1532.,7.8,HIGH,2,test,2023-05-09T20:15:30Z,4
CVE-2023-32690,['CWE-20'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,DMTF/libspdm,"Prevent undefined behavior

Fix #2068 in main branch.

Signed-off-by: Steven Bellock <sbellock@nvidia.com>",48debe26f633e3b16809255d6ca7ce18db649a13,https://github.com/DMTF/libspdm/commit/48debe26f633e3b16809255d6ca7ce18db649a13,library/spdm_responder_lib/libspdm_rsp_capabilities.c,libspdm_get_response_capabilities,"libspdm_return_t libspdm_get_response_capabilities(libspdm_context_t *spdm_context,
size_t request_size,
const void *request,
size_t *response_size,
void *response)
{
const spdm_get_capabilities_request_t *spdm_request;
spdm_capabilities_response_t *spdm_response;
libspdm_return_t status;
spdm_request = request;
if (spdm_context->response_state != LIBSPDM_RESPONSE_STATE_NORMAL) {
return libspdm_responder_handle_response_state(
spdm_context, spdm_request->header.request_response_code,  response_size, response);
}
if (spdm_context->connection_info.connection_state != LIBSPDM_CONNECTION_STATE_AFTER_VERSION) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_UNEXPECTED_REQUEST,
0, response_size, response);
}
if (!libspdm_check_request_version_compatibility(
spdm_context, spdm_request->header.spdm_version)) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_VERSION_MISMATCH, 0,
response_size, response);
}
if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_12) {
if (request_size < sizeof(spdm_get_capabilities_request_t)) {
return libspdm_generate_error_response(
spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST, 0, response_size, response);
} else {
request_size = sizeof(spdm_get_capabilities_request_t);
}
} else if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_11) {
if (request_size < sizeof(spdm_get_capabilities_request_t) -
sizeof(spdm_request->data_transfer_size) - sizeof(spdm_request->max_spdm_msg_size)) {
return libspdm_generate_error_response(
spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST, 0, response_size, response);
} else {
request_size = sizeof(spdm_get_capabilities_request_t) -
sizeof(spdm_request->data_transfer_size) -
sizeof(spdm_request->max_spdm_msg_size);
}
} else {
if (request_size < sizeof(spdm_message_header_t)) {
return libspdm_generate_error_response(
spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST, 0, response_size, response);
} else {
request_size = sizeof(spdm_message_header_t);
}
}
if (!libspdm_check_request_flag_compatibility(
spdm_request->flags, spdm_request->header.spdm_version)) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_INVALID_REQUEST, 0,
response_size, response);
}
if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_12) {
if ((spdm_request->data_transfer_size < SPDM_MIN_DATA_TRANSFER_SIZE_VERSION_12) ||
(spdm_request->data_transfer_size > spdm_request->max_spdm_msg_size)) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_INVALID_REQUEST, 0,
response_size, response);
}
if (((spdm_request->flags & SPDM_GET_CAPABILITIES_REQUEST_FLAGS_CHUNK_CAP) == 0) &&
(spdm_request->data_transfer_size != spdm_request->max_spdm_msg_size)) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_INVALID_REQUEST, 0,
response_size, response);
}
}
libspdm_reset_message_buffer_via_request_code(spdm_context, NULL,
spdm_request->header.request_response_code);
LIBSPDM_ASSERT(*response_size >= sizeof(spdm_capabilities_response_t));
*response_size = sizeof(spdm_capabilities_response_t);
libspdm_zero_mem(response, *response_size);
spdm_response = response;
spdm_response->header.spdm_version = spdm_request->header.spdm_version;
spdm_response->header.request_response_code = SPDM_CAPABILITIES;
spdm_response->header.param1 = 0;
spdm_response->header.param2 = 0;
spdm_response->ct_exponent = spdm_context->local_context.capability.ct_exponent;
spdm_response->flags = spdm_context->local_context.capability.flags;
spdm_response->data_transfer_size = spdm_context->local_context.capability.data_transfer_size;
spdm_response->max_spdm_msg_size = spdm_context->local_context.capability.max_spdm_msg_size;
if (spdm_response->header.spdm_version >= SPDM_MESSAGE_VERSION_12) {
*response_size = sizeof(spdm_capabilities_response_t);
} else {
*response_size = sizeof(spdm_capabilities_response_t) -
sizeof(spdm_response->data_transfer_size) -
sizeof(spdm_response->max_spdm_msg_size);
}
status = libspdm_append_message_a(spdm_context, spdm_request, request_size);
if (LIBSPDM_STATUS_IS_ERROR(status)) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_UNSPECIFIED, 0,
response_size, response);
}
status = libspdm_append_message_a(spdm_context, spdm_response, *response_size);
if (LIBSPDM_STATUS_IS_ERROR(status)) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_UNSPECIFIED, 0,
response_size, response);
}
if (spdm_response->header.spdm_version >= SPDM_MESSAGE_VERSION_11) {
spdm_context->connection_info.capability.ct_exponent = spdm_request->ct_exponent;
spdm_context->connection_info.capability.flags = spdm_request->flags;
} else {
spdm_context->connection_info.capability.ct_exponent = 0;
spdm_context->connection_info.capability.flags = 0;
}
if (spdm_response->header.spdm_version >= SPDM_MESSAGE_VERSION_12) {
spdm_context->connection_info.capability.data_transfer_size =
spdm_request->data_transfer_size;
spdm_context->connection_info.capability.max_spdm_msg_size =
spdm_request->max_spdm_msg_size;
} else {
spdm_context->connection_info.capability.data_transfer_size = 0;
spdm_context->connection_info.capability.max_spdm_msg_size = 0;
}
libspdm_set_connection_state(spdm_context, LIBSPDM_CONNECTION_STATE_AFTER_CAPABILITIES);
return LIBSPDM_STATUS_SUCCESS;
}","libspdm_return_t libspdm_get_response_capabilities(libspdm_context_t *VAR_0,
size_t VAR_1,
const void *VAR_2,
size_t *VAR_3,
void *VAR_4)
{
const spdm_get_capabilities_request_t *VAR_5;
spdm_capabilities_response_t *VAR_6;
libspdm_return_t VAR_7;
VAR_5 = VAR_2;
if (VAR_0->response_state != VAR_8) {
return libspdm_responder_handle_response_state(
VAR_0, VAR_5->header.request_response_code,  VAR_3, VAR_4);
}
if (VAR_0->connection_info.connection_state != VAR_9) {
return libspdm_generate_error_response(VAR_0,
VAR_10,
0, VAR_3, VAR_4);
}
if (!libspdm_check_request_version_compatibility(
VAR_0, VAR_5->header.spdm_version)) {
return libspdm_generate_error_response(VAR_0,
VAR_11, 0,
VAR_3, VAR_4);
}
if (VAR_5->header.spdm_version >= VAR_12) {
if (VAR_1 < sizeof(spdm_get_capabilities_request_t)) {
return libspdm_generate_error_response(
VAR_0, VAR_13, 0, VAR_3, VAR_4);
} else {
VAR_1 = sizeof(spdm_get_capabilities_request_t);
}
} else if (VAR_5->header.spdm_version >= VAR_14) {
if (VAR_1 < sizeof(spdm_get_capabilities_request_t) -
sizeof(VAR_5->data_transfer_size) - sizeof(VAR_5->max_spdm_msg_size)) {
return libspdm_generate_error_response(
VAR_0, VAR_13, 0, VAR_3, VAR_4);
} else {
VAR_1 = sizeof(spdm_get_capabilities_request_t) -
sizeof(VAR_5->data_transfer_size) -
sizeof(VAR_5->max_spdm_msg_size);
}
} else {
if (VAR_1 < sizeof(VAR_15)) {
return libspdm_generate_error_response(
VAR_0, VAR_13, 0, VAR_3, VAR_4);
} else {
VAR_1 = sizeof(VAR_15);
}
}
if (!libspdm_check_request_flag_compatibility(
VAR_5->flags, VAR_5->header.spdm_version)) {
return libspdm_generate_error_response(VAR_0,
VAR_13, 0,
VAR_3, VAR_4);
}
if (VAR_5->header.spdm_version >= VAR_12) {
if ((VAR_5->data_transfer_size < VAR_16) ||
(VAR_5->data_transfer_size > VAR_5->max_spdm_msg_size)) {
return libspdm_generate_error_response(VAR_0,
VAR_13, 0,
VAR_3, VAR_4);
}
if (((VAR_5->flags & VAR_17) == 0) &&
(VAR_5->data_transfer_size != VAR_5->max_spdm_msg_size)) {
return libspdm_generate_error_response(VAR_0,
VAR_13, 0,
VAR_3, VAR_4);
}
}
libspdm_reset_message_buffer_via_request_code(VAR_0, NULL,
VAR_5->header.request_response_code);
LIBSPDM_ASSERT(*VAR_3 >= sizeof(spdm_capabilities_response_t));
*VAR_3 = sizeof(spdm_capabilities_response_t);
libspdm_zero_mem(VAR_4, *VAR_3);
VAR_6 = VAR_4;
VAR_6->header.spdm_version = VAR_5->header.spdm_version;
VAR_6->header.request_response_code = VAR_18;
VAR_6->header.param1 = 0;
VAR_6->header.param2 = 0;
VAR_6->ct_exponent = VAR_0->local_context.capability.ct_exponent;
VAR_6->flags = VAR_0->local_context.capability.flags;
VAR_6->data_transfer_size = VAR_0->local_context.capability.data_transfer_size;
VAR_6->max_spdm_msg_size = VAR_0->local_context.capability.max_spdm_msg_size;
if (VAR_6->header.spdm_version >= VAR_12) {
*VAR_3 = sizeof(spdm_capabilities_response_t);
} else {
*VAR_3 = sizeof(spdm_capabilities_response_t) -
sizeof(VAR_6->data_transfer_size) -
sizeof(VAR_6->max_spdm_msg_size);
}
VAR_7 = libspdm_append_message_a(VAR_0, VAR_5, VAR_1);
if (LIBSPDM_STATUS_IS_ERROR(VAR_7)) {
return libspdm_generate_error_response(VAR_0,
VAR_19, 0,
VAR_3, VAR_4);
}
VAR_7 = libspdm_append_message_a(VAR_0, VAR_6, *VAR_3);
if (LIBSPDM_STATUS_IS_ERROR(VAR_7)) {
return libspdm_generate_error_response(VAR_0,
VAR_19, 0,
VAR_3, VAR_4);
}
if (VAR_6->header.spdm_version >= VAR_14) {
VAR_0->connection_info.capability.ct_exponent = VAR_5->ct_exponent;
VAR_0->connection_info.capability.flags = VAR_5->flags;
} else {
VAR_0->connection_info.capability.ct_exponent = 0;
VAR_0->connection_info.capability.flags = 0;
}
if (VAR_6->header.spdm_version >= VAR_12) {
VAR_0->connection_info.capability.data_transfer_size =
VAR_5->data_transfer_size;
VAR_0->connection_info.capability.max_spdm_msg_size =
VAR_5->max_spdm_msg_size;
} else {
VAR_0->connection_info.capability.data_transfer_size = 0;
VAR_0->connection_info.capability.max_spdm_msg_size = 0;
}
libspdm_set_connection_state(VAR_0, VAR_20);
return VAR_21;
}",DMTF/libspdm/48debe26f633e3b16809255d6ca7ce18db649a13/libspdm_rsp_capabilities.c/vul/before/0.json,"libspdm_return_t libspdm_get_response_capabilities(libspdm_context_t *spdm_context,
                                                   size_t request_size,
                                                   const void *request,
                                                   size_t *response_size,
                                                   void *response)
{
    const spdm_get_capabilities_request_t *spdm_request;
    spdm_capabilities_response_t *spdm_response;
    libspdm_return_t status;

    spdm_request = request;

    /* -=[Verify State Phase]=- */
    if (spdm_context->response_state != LIBSPDM_RESPONSE_STATE_NORMAL) {
        return libspdm_responder_handle_response_state(
            spdm_context, spdm_request->header.request_response_code,  response_size, response);
    }
    if (spdm_context->connection_info.connection_state != LIBSPDM_CONNECTION_STATE_AFTER_VERSION) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST,
                                               0, response_size, response);
    }

    /* -=[Validate Request Phase]=- */
    if (!libspdm_check_request_version_compatibility(
            spdm_context, spdm_request->header.spdm_version)) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_VERSION_MISMATCH, 0,
                                               response_size, response);
    }
    if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_12) {
        if (request_size < sizeof(spdm_get_capabilities_request_t)) {
            return libspdm_generate_error_response(
                spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST, 0, response_size, response);
        } else {
            request_size = sizeof(spdm_get_capabilities_request_t);
        }
    } else if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_11) {
        if (request_size < sizeof(spdm_get_capabilities_request_t) -
            sizeof(spdm_request->data_transfer_size) - sizeof(spdm_request->max_spdm_msg_size)) {
            return libspdm_generate_error_response(
                spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST, 0, response_size, response);
        } else {
            request_size = sizeof(spdm_get_capabilities_request_t) -
                           sizeof(spdm_request->data_transfer_size) -
                           sizeof(spdm_request->max_spdm_msg_size);
        }
    } else {
        if (request_size < sizeof(spdm_message_header_t)) {
            return libspdm_generate_error_response(
                spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST, 0, response_size, response);
        } else {
            request_size = sizeof(spdm_message_header_t);
        }
    }
    if (!libspdm_check_request_flag_compatibility(
            spdm_request->flags, spdm_request->header.spdm_version)) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                                               response_size, response);
    }
    if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_12) {
        if ((spdm_request->data_transfer_size < SPDM_MIN_DATA_TRANSFER_SIZE_VERSION_12) ||
            (spdm_request->data_transfer_size > spdm_request->max_spdm_msg_size)) {
            return libspdm_generate_error_response(spdm_context,
                                                   SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                                                   response_size, response);
        }
        if (((spdm_request->flags & SPDM_GET_CAPABILITIES_REQUEST_FLAGS_CHUNK_CAP) == 0) &&
            (spdm_request->data_transfer_size != spdm_request->max_spdm_msg_size)) {
            return libspdm_generate_error_response(spdm_context,
                                                   SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                                                   response_size, response);
        }
    }
    if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_11) {
        if (spdm_request->ct_exponent > LIBSPDM_MAX_CT_EXPONENT) {
            return libspdm_generate_error_response(spdm_context,
                                                   SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                                                   response_size, response);
        }
    }

    libspdm_reset_message_buffer_via_request_code(spdm_context, NULL,
                                                  spdm_request->header.request_response_code);

    /* -=[Construct Response Phase]=- */
    LIBSPDM_ASSERT(*response_size >= sizeof(spdm_capabilities_response_t));
    *response_size = sizeof(spdm_capabilities_response_t);
    libspdm_zero_mem(response, *response_size);
    spdm_response = response;

    spdm_response->header.spdm_version = spdm_request->header.spdm_version;
    spdm_response->header.request_response_code = SPDM_CAPABILITIES;
    spdm_response->header.param1 = 0;
    spdm_response->header.param2 = 0;
    spdm_response->ct_exponent = spdm_context->local_context.capability.ct_exponent;
    spdm_response->flags = spdm_context->local_context.capability.flags;
    spdm_response->data_transfer_size = spdm_context->local_context.capability.data_transfer_size;
    spdm_response->max_spdm_msg_size = spdm_context->local_context.capability.max_spdm_msg_size;

    if (spdm_response->header.spdm_version >= SPDM_MESSAGE_VERSION_12) {
        *response_size = sizeof(spdm_capabilities_response_t);
    } else {
        *response_size = sizeof(spdm_capabilities_response_t) -
                         sizeof(spdm_response->data_transfer_size) -
                         sizeof(spdm_response->max_spdm_msg_size);
    }

    /* -=[Process Request Phase]=- */
    status = libspdm_append_message_a(spdm_context, spdm_request, request_size);
    if (LIBSPDM_STATUS_IS_ERROR(status)) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,
                                               response_size, response);
    }
    status = libspdm_append_message_a(spdm_context, spdm_response, *response_size);

    if (LIBSPDM_STATUS_IS_ERROR(status)) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,
                                               response_size, response);
    }
    if (spdm_response->header.spdm_version >= SPDM_MESSAGE_VERSION_11) {
        spdm_context->connection_info.capability.ct_exponent = spdm_request->ct_exponent;
        spdm_context->connection_info.capability.flags = spdm_request->flags;
    } else {
        spdm_context->connection_info.capability.ct_exponent = 0;
        spdm_context->connection_info.capability.flags = 0;
    }
    if (spdm_response->header.spdm_version >= SPDM_MESSAGE_VERSION_12) {
        spdm_context->connection_info.capability.data_transfer_size =
            spdm_request->data_transfer_size;
        spdm_context->connection_info.capability.max_spdm_msg_size =
            spdm_request->max_spdm_msg_size;
    } else {
        spdm_context->connection_info.capability.data_transfer_size = 0;
        spdm_context->connection_info.capability.max_spdm_msg_size = 0;
    }

    /* -=[Update State Phase]=- */
    libspdm_set_connection_state(spdm_context, LIBSPDM_CONNECTION_STATE_AFTER_CAPABILITIES);

    return LIBSPDM_STATUS_SUCCESS;
}","libspdm_return_t libspdm_get_response_capabilities(libspdm_context_t *VAR_0,
                                                   size_t VAR_1,
                                                   const void *VAR_2,
                                                   size_t *VAR_3,
                                                   void *VAR_4)
{
    const spdm_get_capabilities_request_t *VAR_5;
    spdm_capabilities_response_t *VAR_6;
    libspdm_return_t VAR_7;

    VAR_5 = VAR_2;

    /* COMMENT_0 */
    if (VAR_0->response_state != VAR_8) {
        return libspdm_responder_handle_response_state(
            VAR_0, VAR_5->header.request_response_code,  VAR_3, VAR_4);
    }
    if (VAR_0->connection_info.connection_state != VAR_9) {
        return libspdm_generate_error_response(VAR_0,
                                               VAR_10,
                                               0, VAR_3, VAR_4);
    }

    /* COMMENT_1 */
    if (!libspdm_check_request_version_compatibility(
            VAR_0, VAR_5->header.spdm_version)) {
        return libspdm_generate_error_response(VAR_0,
                                               VAR_11, 0,
                                               VAR_3, VAR_4);
    }
    if (VAR_5->header.spdm_version >= VAR_12) {
        if (VAR_1 < sizeof(spdm_get_capabilities_request_t)) {
            return libspdm_generate_error_response(
                VAR_0, VAR_13, 0, VAR_3, VAR_4);
        } else {
            VAR_1 = sizeof(spdm_get_capabilities_request_t);
        }
    } else if (VAR_5->header.spdm_version >= VAR_14) {
        if (VAR_1 < sizeof(spdm_get_capabilities_request_t) -
            sizeof(VAR_5->data_transfer_size) - sizeof(VAR_5->max_spdm_msg_size)) {
            return libspdm_generate_error_response(
                VAR_0, VAR_13, 0, VAR_3, VAR_4);
        } else {
            VAR_1 = sizeof(spdm_get_capabilities_request_t) -
                           sizeof(VAR_5->data_transfer_size) -
                           sizeof(VAR_5->max_spdm_msg_size);
        }
    } else {
        if (VAR_1 < sizeof(VAR_15)) {
            return libspdm_generate_error_response(
                VAR_0, VAR_13, 0, VAR_3, VAR_4);
        } else {
            VAR_1 = sizeof(VAR_15);
        }
    }
    if (!libspdm_check_request_flag_compatibility(
            VAR_5->flags, VAR_5->header.spdm_version)) {
        return libspdm_generate_error_response(VAR_0,
                                               VAR_13, 0,
                                               VAR_3, VAR_4);
    }
    if (VAR_5->header.spdm_version >= VAR_12) {
        if ((VAR_5->data_transfer_size < VAR_16) ||
            (VAR_5->data_transfer_size > VAR_5->max_spdm_msg_size)) {
            return libspdm_generate_error_response(VAR_0,
                                                   VAR_13, 0,
                                                   VAR_3, VAR_4);
        }
        if (((VAR_5->flags & VAR_17) == 0) &&
            (VAR_5->data_transfer_size != VAR_5->max_spdm_msg_size)) {
            return libspdm_generate_error_response(VAR_0,
                                                   VAR_13, 0,
                                                   VAR_3, VAR_4);
        }
    }
    if (VAR_5->header.spdm_version >= VAR_14) {
        if (VAR_5->ct_exponent > VAR_18) {
            return libspdm_generate_error_response(VAR_0,
                                                   VAR_13, 0,
                                                   VAR_3, VAR_4);
        }
    }

    libspdm_reset_message_buffer_via_request_code(VAR_0, NULL,
                                                  VAR_5->header.request_response_code);

    /* COMMENT_2 */
    LIBSPDM_ASSERT(*VAR_3 >= sizeof(spdm_capabilities_response_t));
    *VAR_3 = sizeof(spdm_capabilities_response_t);
    libspdm_zero_mem(VAR_4, *VAR_3);
    VAR_6 = VAR_4;

    VAR_6->header.spdm_version = VAR_5->header.spdm_version;
    VAR_6->header.request_response_code = VAR_19;
    VAR_6->header.param1 = 0;
    VAR_6->header.param2 = 0;
    VAR_6->ct_exponent = VAR_0->local_context.capability.ct_exponent;
    VAR_6->flags = VAR_0->local_context.capability.flags;
    VAR_6->data_transfer_size = VAR_0->local_context.capability.data_transfer_size;
    VAR_6->max_spdm_msg_size = VAR_0->local_context.capability.max_spdm_msg_size;

    if (VAR_6->header.spdm_version >= VAR_12) {
        *VAR_3 = sizeof(spdm_capabilities_response_t);
    } else {
        *VAR_3 = sizeof(spdm_capabilities_response_t) -
                         sizeof(VAR_6->data_transfer_size) -
                         sizeof(VAR_6->max_spdm_msg_size);
    }

    /* COMMENT_3 */
    VAR_7 = libspdm_append_message_a(VAR_0, VAR_5, VAR_1);
    if (LIBSPDM_STATUS_IS_ERROR(VAR_7)) {
        return libspdm_generate_error_response(VAR_0,
                                               VAR_20, 0,
                                               VAR_3, VAR_4);
    }
    VAR_7 = libspdm_append_message_a(VAR_0, VAR_6, *VAR_3);

    if (LIBSPDM_STATUS_IS_ERROR(VAR_7)) {
        return libspdm_generate_error_response(VAR_0,
                                               VAR_20, 0,
                                               VAR_3, VAR_4);
    }
    if (VAR_6->header.spdm_version >= VAR_14) {
        VAR_0->connection_info.capability.ct_exponent = VAR_5->ct_exponent;
        VAR_0->connection_info.capability.flags = VAR_5->flags;
    } else {
        VAR_0->connection_info.capability.ct_exponent = 0;
        VAR_0->connection_info.capability.flags = 0;
    }
    if (VAR_6->header.spdm_version >= VAR_12) {
        VAR_0->connection_info.capability.data_transfer_size =
            VAR_5->data_transfer_size;
        VAR_0->connection_info.capability.max_spdm_msg_size =
            VAR_5->max_spdm_msg_size;
    } else {
        VAR_0->connection_info.capability.data_transfer_size = 0;
        VAR_0->connection_info.capability.max_spdm_msg_size = 0;
    }

    /* COMMENT_4 */
    libspdm_set_connection_state(VAR_0, VAR_21);

    return VAR_22;
}",DMTF/libspdm/48debe26f633e3b16809255d6ca7ce18db649a13/libspdm_rsp_capabilities.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -73,6 +73,13 @@
                                                    response_size, response);
         }
     }
+    if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_11) {
+        if (spdm_request->ct_exponent > LIBSPDM_MAX_CT_EXPONENT) {
+            return libspdm_generate_error_response(spdm_context,
+                                                   SPDM_ERROR_CODE_INVALID_REQUEST, 0,
+                                                   response_size, response);
+        }
+    }
 
     libspdm_reset_message_buffer_via_request_code(spdm_context, NULL,
                                                   spdm_request->header.request_response_code);","{'deleted_lines': [], 'added_lines': ['    if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_11) {', '        if (spdm_request->ct_exponent > LIBSPDM_MAX_CT_EXPONENT) {', '            return libspdm_generate_error_response(spdm_context,', '                                                   SPDM_ERROR_CODE_INVALID_REQUEST, 0,', '                                                   response_size, response);', '        }', '    }']}",True,"libspdm is a sample implementation that follows the DMTF SPDM specifications. Prior to versions 2.3.3 and 3.0, following a successful CAPABILITIES response, a libspdm Requester stores the Responder's CTExponent into its context without validation. If the Requester sends a request message that requires a cryptography operation by the Responder, such as CHALLENGE, libspdm will calculate the timeout value using the Responder's unvalidated CTExponent.

A patch is available in version 2.3.3. A workaround is also available. After completion of VCA, the Requester can check the value of the Responder's CTExponent. If it greater than or equal to 64, then the Requester can stop communication with the Responder.",5.7,MEDIUM,1,test,2023-05-28T23:22:15Z,4
CVE-2023-32690,['CWE-20'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,DMTF/libspdm,"Prevent undefined behavior

Fix #2068 in main branch.

Signed-off-by: Steven Bellock <sbellock@nvidia.com>",48debe26f633e3b16809255d6ca7ce18db649a13,https://github.com/DMTF/libspdm/commit/48debe26f633e3b16809255d6ca7ce18db649a13,library/spdm_requester_lib/libspdm_req_get_capabilities.c,libspdm_try_get_capabilities,"static libspdm_return_t libspdm_try_get_capabilities(libspdm_context_t *spdm_context)
{
libspdm_return_t status;
spdm_get_capabilities_request_t *spdm_request;
size_t spdm_request_size;
spdm_capabilities_response_t *spdm_response;
size_t spdm_response_size;
uint8_t *message;
size_t message_size;
size_t transport_header_size;
if (spdm_context->connection_info.connection_state != LIBSPDM_CONNECTION_STATE_AFTER_VERSION) {
return LIBSPDM_STATUS_INVALID_STATE_LOCAL;
}
libspdm_reset_message_buffer_via_request_code(spdm_context, NULL, SPDM_GET_CAPABILITIES);
transport_header_size = spdm_context->transport_get_header_size(spdm_context);
status = libspdm_acquire_sender_buffer (spdm_context, &message_size, (void **)&message);
if (LIBSPDM_STATUS_IS_ERROR(status)) {
return status;
}
LIBSPDM_ASSERT (message_size >= transport_header_size);
spdm_request = (void *)(message + transport_header_size);
libspdm_zero_mem(spdm_request, sizeof(spdm_get_capabilities_request_t));
spdm_request->header.spdm_version = libspdm_get_connection_version (spdm_context);
if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_12) {
spdm_request_size = sizeof(spdm_get_capabilities_request_t);
} else if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_11) {
spdm_request_size = sizeof(spdm_get_capabilities_request_t) -
sizeof(spdm_request->data_transfer_size) -
sizeof(spdm_request->max_spdm_msg_size);
} else {
spdm_request_size = sizeof(spdm_request->header);
}
spdm_request->header.request_response_code = SPDM_GET_CAPABILITIES;
spdm_request->header.param1 = 0;
spdm_request->header.param2 = 0;
spdm_request->ct_exponent = spdm_context->local_context.capability.ct_exponent;
spdm_request->flags = spdm_context->local_context.capability.flags;
spdm_request->data_transfer_size = spdm_context->local_context.capability.data_transfer_size;
spdm_request->max_spdm_msg_size = spdm_context->local_context.capability.max_spdm_msg_size;
status = libspdm_send_spdm_request(spdm_context, NULL, spdm_request_size, spdm_request);
if (LIBSPDM_STATUS_IS_ERROR(status)) {
libspdm_release_sender_buffer (spdm_context);
return status;
}
libspdm_release_sender_buffer (spdm_context);
spdm_request = (void *)spdm_context->last_spdm_request;
status = libspdm_acquire_receiver_buffer (spdm_context, &message_size, (void **)&message);
if (LIBSPDM_STATUS_IS_ERROR(status)) {
return status;
}
LIBSPDM_ASSERT (message_size >= transport_header_size);
spdm_response = (void *)(message);
spdm_response_size = message_size;
libspdm_zero_mem(spdm_response, spdm_response_size);
status = libspdm_receive_spdm_response(spdm_context, NULL, &spdm_response_size,
(void **)&spdm_response);
if (LIBSPDM_STATUS_IS_ERROR(status)) {
goto receive_done;
}
if (spdm_response_size < sizeof(spdm_message_header_t)) {
status = LIBSPDM_STATUS_INVALID_MSG_SIZE;
goto receive_done;
}
if (spdm_response->header.spdm_version != spdm_request->header.spdm_version) {
status = LIBSPDM_STATUS_INVALID_MSG_FIELD;
goto receive_done;
}
if (spdm_response->header.request_response_code == SPDM_ERROR) {
status = libspdm_handle_simple_error_response(
spdm_context, spdm_response->header.param1);
if (LIBSPDM_STATUS_IS_ERROR(status)) {
goto receive_done;
}
} else if (spdm_response->header.request_response_code != SPDM_CAPABILITIES) {
status = LIBSPDM_STATUS_INVALID_MSG_FIELD;
goto receive_done;
}
if (spdm_response->header.spdm_version >= SPDM_MESSAGE_VERSION_12) {
if (spdm_response_size < sizeof(spdm_capabilities_response_t)) {
status = LIBSPDM_STATUS_INVALID_MSG_SIZE;
goto receive_done;
}
} else {
if (spdm_response_size < sizeof(spdm_capabilities_response_t) -
sizeof(spdm_response->data_transfer_size) - sizeof(spdm_response->max_spdm_msg_size)) {
status = LIBSPDM_STATUS_INVALID_MSG_SIZE;
goto receive_done;
}
}
if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_12) {
spdm_response_size = sizeof(spdm_capabilities_response_t);
} else {
spdm_response_size = sizeof(spdm_capabilities_response_t) -
sizeof(spdm_response->data_transfer_size) -
sizeof(spdm_response->max_spdm_msg_size);
}
if (!validate_responder_capability(spdm_response->flags, spdm_response->header.spdm_version)) {
status = LIBSPDM_STATUS_INVALID_MSG_FIELD;
goto receive_done;
}
if (spdm_response->header.spdm_version >= SPDM_MESSAGE_VERSION_12) {
if ((spdm_response->data_transfer_size < SPDM_MIN_DATA_TRANSFER_SIZE_VERSION_12) ||
(spdm_response->data_transfer_size > spdm_response->max_spdm_msg_size)) {
status = LIBSPDM_STATUS_INVALID_MSG_FIELD;
goto receive_done;
}
if (((spdm_response->flags & SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_CHUNK_CAP) == 0) &&
(spdm_response->data_transfer_size != spdm_response->max_spdm_msg_size)) {
status = LIBSPDM_STATUS_INVALID_MSG_FIELD;
goto receive_done;
}
}
status = libspdm_append_message_a(spdm_context, spdm_request, spdm_request_size);
if (LIBSPDM_STATUS_IS_ERROR(status)) {
status = LIBSPDM_STATUS_BUFFER_FULL;
goto receive_done;
}
status = libspdm_append_message_a(spdm_context, spdm_response, spdm_response_size);
if (LIBSPDM_STATUS_IS_ERROR(status)) {
status = LIBSPDM_STATUS_BUFFER_FULL;
goto receive_done;
}
spdm_context->connection_info.capability.ct_exponent = spdm_response->ct_exponent;
spdm_context->connection_info.capability.flags = spdm_response->flags;
if (spdm_response->header.spdm_version >= SPDM_MESSAGE_VERSION_12) {
spdm_context->connection_info.capability.data_transfer_size =
spdm_response->data_transfer_size;
spdm_context->connection_info.capability.max_spdm_msg_size =
spdm_response->max_spdm_msg_size;
} else {
spdm_context->connection_info.capability.data_transfer_size = 0;
spdm_context->connection_info.capability.max_spdm_msg_size = 0;
}
spdm_context->connection_info.connection_state = LIBSPDM_CONNECTION_STATE_AFTER_CAPABILITIES;
status = LIBSPDM_STATUS_SUCCESS;
#if LIBSPDM_ENABLE_MSG_LOG
libspdm_append_msg_log(spdm_context, spdm_response, spdm_response_size);
#endif 
receive_done:
libspdm_release_receiver_buffer (spdm_context);
return status;
}","static libspdm_return_t libspdm_try_get_capabilities(libspdm_context_t *VAR_0)
{
libspdm_return_t VAR_1;
spdm_get_capabilities_request_t *VAR_2;
size_t VAR_3;
spdm_capabilities_response_t *VAR_4;
size_t VAR_5;
uint8_t *VAR_6;
size_t VAR_7;
size_t VAR_8;
if (VAR_0->connection_info.connection_state != VAR_9) {
return VAR_10;
}
libspdm_reset_message_buffer_via_request_code(VAR_0, NULL, VAR_11);
VAR_8 = VAR_0->transport_get_header_size(VAR_0);
VAR_1 = libspdm_acquire_sender_buffer (VAR_0, &VAR_7, (void **)&VAR_6);
if (LIBSPDM_STATUS_IS_ERROR(VAR_1)) {
return VAR_1;
}
LIBSPDM_ASSERT (VAR_7 >= VAR_8);
VAR_2 = (void *)(VAR_6 + VAR_8);
libspdm_zero_mem(VAR_2, sizeof(spdm_get_capabilities_request_t));
VAR_2->header.spdm_version = libspdm_get_connection_version (VAR_0);
if (VAR_2->header.spdm_version >= VAR_12) {
VAR_3 = sizeof(spdm_get_capabilities_request_t);
} else if (VAR_2->header.spdm_version >= VAR_13) {
VAR_3 = sizeof(spdm_get_capabilities_request_t) -
sizeof(VAR_2->data_transfer_size) -
sizeof(VAR_2->max_spdm_msg_size);
} else {
VAR_3 = sizeof(VAR_2->header);
}
VAR_2->header.request_response_code = VAR_11;
VAR_2->header.param1 = 0;
VAR_2->header.param2 = 0;
VAR_2->ct_exponent = VAR_0->local_context.capability.ct_exponent;
VAR_2->flags = VAR_0->local_context.capability.flags;
VAR_2->data_transfer_size = VAR_0->local_context.capability.data_transfer_size;
VAR_2->max_spdm_msg_size = VAR_0->local_context.capability.max_spdm_msg_size;
VAR_1 = libspdm_send_spdm_request(VAR_0, NULL, VAR_3, VAR_2);
if (LIBSPDM_STATUS_IS_ERROR(VAR_1)) {
libspdm_release_sender_buffer (VAR_0);
return VAR_1;
}
libspdm_release_sender_buffer (VAR_0);
VAR_2 = (void *)VAR_0->last_spdm_request;
VAR_1 = libspdm_acquire_receiver_buffer (VAR_0, &VAR_7, (void **)&VAR_6);
if (LIBSPDM_STATUS_IS_ERROR(VAR_1)) {
return VAR_1;
}
LIBSPDM_ASSERT (VAR_7 >= VAR_8);
VAR_4 = (void *)(VAR_6);
VAR_5 = VAR_7;
libspdm_zero_mem(VAR_4, VAR_5);
VAR_1 = libspdm_receive_spdm_response(VAR_0, NULL, &VAR_5,
(void **)&VAR_4);
if (LIBSPDM_STATUS_IS_ERROR(VAR_1)) {
goto receive_done;
}
if (VAR_5 < sizeof(VAR_14)) {
VAR_1 = VAR_15;
goto receive_done;
}
if (VAR_4->header.spdm_version != VAR_2->header.spdm_version) {
VAR_1 = VAR_16;
goto receive_done;
}
if (VAR_4->header.request_response_code == VAR_17) {
VAR_1 = libspdm_handle_simple_error_response(
VAR_0, VAR_4->header.param1);
if (LIBSPDM_STATUS_IS_ERROR(VAR_1)) {
goto receive_done;
}
} else if (VAR_4->header.request_response_code != VAR_18) {
VAR_1 = VAR_16;
goto receive_done;
}
if (VAR_4->header.spdm_version >= VAR_12) {
if (VAR_5 < sizeof(spdm_capabilities_response_t)) {
VAR_1 = VAR_15;
goto receive_done;
}
} else {
if (VAR_5 < sizeof(spdm_capabilities_response_t) -
sizeof(VAR_4->data_transfer_size) - sizeof(VAR_4->max_spdm_msg_size)) {
VAR_1 = VAR_15;
goto receive_done;
}
}
if (VAR_2->header.spdm_version >= VAR_12) {
VAR_5 = sizeof(spdm_capabilities_response_t);
} else {
VAR_5 = sizeof(spdm_capabilities_response_t) -
sizeof(VAR_4->data_transfer_size) -
sizeof(VAR_4->max_spdm_msg_size);
}
if (!validate_responder_capability(VAR_4->flags, VAR_4->header.spdm_version)) {
VAR_1 = VAR_16;
goto receive_done;
}
if (VAR_4->header.spdm_version >= VAR_12) {
if ((VAR_4->data_transfer_size < VAR_19) ||
(VAR_4->data_transfer_size > VAR_4->max_spdm_msg_size)) {
VAR_1 = VAR_16;
goto receive_done;
}
if (((VAR_4->flags & VAR_20) == 0) &&
(VAR_4->data_transfer_size != VAR_4->max_spdm_msg_size)) {
VAR_1 = VAR_16;
goto receive_done;
}
}
VAR_1 = libspdm_append_message_a(VAR_0, VAR_2, VAR_3);
if (LIBSPDM_STATUS_IS_ERROR(VAR_1)) {
VAR_1 = VAR_21;
goto receive_done;
}
VAR_1 = libspdm_append_message_a(VAR_0, VAR_4, VAR_5);
if (LIBSPDM_STATUS_IS_ERROR(VAR_1)) {
VAR_1 = VAR_21;
goto receive_done;
}
VAR_0->connection_info.capability.ct_exponent = VAR_4->ct_exponent;
VAR_0->connection_info.capability.flags = VAR_4->flags;
if (VAR_4->header.spdm_version >= VAR_12) {
VAR_0->connection_info.capability.data_transfer_size =
VAR_4->data_transfer_size;
VAR_0->connection_info.capability.max_spdm_msg_size =
VAR_4->max_spdm_msg_size;
} else {
VAR_0->connection_info.capability.data_transfer_size = 0;
VAR_0->connection_info.capability.max_spdm_msg_size = 0;
}
VAR_0->connection_info.connection_state = VAR_22;
VAR_1 = VAR_23;
#if VAR_24
libspdm_append_msg_log(VAR_0, VAR_4, VAR_5);
#endif 
receive_done:
libspdm_release_receiver_buffer (VAR_0);
return VAR_1;
}",DMTF/libspdm/48debe26f633e3b16809255d6ca7ce18db649a13/libspdm_req_get_capabilities.c/vul/before/0.json,"static libspdm_return_t libspdm_try_get_capabilities(libspdm_context_t *spdm_context)
{
    libspdm_return_t status;
    spdm_get_capabilities_request_t *spdm_request;
    size_t spdm_request_size;
    spdm_capabilities_response_t *spdm_response;
    size_t spdm_response_size;
    uint8_t *message;
    size_t message_size;
    size_t transport_header_size;

    /* -=[Verify State Phase]=- */
    if (spdm_context->connection_info.connection_state != LIBSPDM_CONNECTION_STATE_AFTER_VERSION) {
        return LIBSPDM_STATUS_INVALID_STATE_LOCAL;
    }
    libspdm_reset_message_buffer_via_request_code(spdm_context, NULL, SPDM_GET_CAPABILITIES);

    /* -=[Construct Request Phase]=- */
    transport_header_size = spdm_context->transport_get_header_size(spdm_context);
    status = libspdm_acquire_sender_buffer (spdm_context, &message_size, (void **)&message);
    if (LIBSPDM_STATUS_IS_ERROR(status)) {
        return status;
    }
    LIBSPDM_ASSERT (message_size >= transport_header_size);
    spdm_request = (void *)(message + transport_header_size);

    libspdm_zero_mem(spdm_request, sizeof(spdm_get_capabilities_request_t));
    spdm_request->header.spdm_version = libspdm_get_connection_version (spdm_context);
    if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_12) {
        spdm_request_size = sizeof(spdm_get_capabilities_request_t);
    } else if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_11) {
        spdm_request_size = sizeof(spdm_get_capabilities_request_t) -
                            sizeof(spdm_request->data_transfer_size) -
                            sizeof(spdm_request->max_spdm_msg_size);
    } else {
        spdm_request_size = sizeof(spdm_request->header);
    }
    spdm_request->header.request_response_code = SPDM_GET_CAPABILITIES;
    spdm_request->header.param1 = 0;
    spdm_request->header.param2 = 0;
    spdm_request->ct_exponent = spdm_context->local_context.capability.ct_exponent;
    spdm_request->flags = spdm_context->local_context.capability.flags;
    spdm_request->data_transfer_size = spdm_context->local_context.capability.data_transfer_size;
    spdm_request->max_spdm_msg_size = spdm_context->local_context.capability.max_spdm_msg_size;

    /* -=[Send Request Phase]=- */
    status = libspdm_send_spdm_request(spdm_context, NULL, spdm_request_size, spdm_request);
    if (LIBSPDM_STATUS_IS_ERROR(status)) {
        libspdm_release_sender_buffer (spdm_context);
        return status;
    }
    libspdm_release_sender_buffer (spdm_context);
    spdm_request = (void *)spdm_context->last_spdm_request;

    /* -=[Receive Response Phase]=- */
    status = libspdm_acquire_receiver_buffer (spdm_context, &message_size, (void **)&message);
    if (LIBSPDM_STATUS_IS_ERROR(status)) {
        return status;
    }
    LIBSPDM_ASSERT (message_size >= transport_header_size);
    spdm_response = (void *)(message);
    spdm_response_size = message_size;

    libspdm_zero_mem(spdm_response, spdm_response_size);
    status = libspdm_receive_spdm_response(spdm_context, NULL, &spdm_response_size,
                                           (void **)&spdm_response);
    if (LIBSPDM_STATUS_IS_ERROR(status)) {
        goto receive_done;
    }

    /* -=[Validate Response Phase]=- */
    if (spdm_response_size < sizeof(spdm_message_header_t)) {
        status = LIBSPDM_STATUS_INVALID_MSG_SIZE;
        goto receive_done;
    }
    if (spdm_response->header.spdm_version != spdm_request->header.spdm_version) {
        status = LIBSPDM_STATUS_INVALID_MSG_FIELD;
        goto receive_done;
    }
    if (spdm_response->header.request_response_code == SPDM_ERROR) {
        status = libspdm_handle_simple_error_response(
            spdm_context, spdm_response->header.param1);
        if (LIBSPDM_STATUS_IS_ERROR(status)) {
            goto receive_done;
        }
    } else if (spdm_response->header.request_response_code != SPDM_CAPABILITIES) {
        status = LIBSPDM_STATUS_INVALID_MSG_FIELD;
        goto receive_done;
    }
    if (spdm_response->header.spdm_version >= SPDM_MESSAGE_VERSION_12) {
        if (spdm_response_size < sizeof(spdm_capabilities_response_t)) {
            status = LIBSPDM_STATUS_INVALID_MSG_SIZE;
            goto receive_done;
        }
    } else {
        if (spdm_response_size < sizeof(spdm_capabilities_response_t) -
            sizeof(spdm_response->data_transfer_size) - sizeof(spdm_response->max_spdm_msg_size)) {
            status = LIBSPDM_STATUS_INVALID_MSG_SIZE;
            goto receive_done;
        }
    }
    if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_12) {
        spdm_response_size = sizeof(spdm_capabilities_response_t);
    } else {
        spdm_response_size = sizeof(spdm_capabilities_response_t) -
                             sizeof(spdm_response->data_transfer_size) -
                             sizeof(spdm_response->max_spdm_msg_size);
    }

    if (!validate_responder_capability(spdm_response->flags, spdm_response->header.spdm_version)) {
        status = LIBSPDM_STATUS_INVALID_MSG_FIELD;
        goto receive_done;
    }
    if (spdm_response->header.spdm_version >= SPDM_MESSAGE_VERSION_12) {
        if ((spdm_response->data_transfer_size < SPDM_MIN_DATA_TRANSFER_SIZE_VERSION_12) ||
            (spdm_response->data_transfer_size > spdm_response->max_spdm_msg_size)) {
            status = LIBSPDM_STATUS_INVALID_MSG_FIELD;
            goto receive_done;
        }

        if (((spdm_response->flags & SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_CHUNK_CAP) == 0) &&
            (spdm_response->data_transfer_size != spdm_response->max_spdm_msg_size)) {
            status = LIBSPDM_STATUS_INVALID_MSG_FIELD;
            goto receive_done;
        }
    }

    if (spdm_response->ct_exponent > LIBSPDM_MAX_CT_EXPONENT) {
        status = LIBSPDM_STATUS_INVALID_MSG_FIELD;
        goto receive_done;
    }

    /* -=[Process Response Phase]=- */
    status = libspdm_append_message_a(spdm_context, spdm_request, spdm_request_size);
    if (LIBSPDM_STATUS_IS_ERROR(status)) {
        status = LIBSPDM_STATUS_BUFFER_FULL;
        goto receive_done;
    }

    status = libspdm_append_message_a(spdm_context, spdm_response, spdm_response_size);
    if (LIBSPDM_STATUS_IS_ERROR(status)) {
        status = LIBSPDM_STATUS_BUFFER_FULL;
        goto receive_done;
    }

    spdm_context->connection_info.capability.ct_exponent = spdm_response->ct_exponent;
    spdm_context->connection_info.capability.flags = spdm_response->flags;

    if (spdm_response->header.spdm_version >= SPDM_MESSAGE_VERSION_12) {
        spdm_context->connection_info.capability.data_transfer_size =
            spdm_response->data_transfer_size;
        spdm_context->connection_info.capability.max_spdm_msg_size =
            spdm_response->max_spdm_msg_size;
    } else {
        spdm_context->connection_info.capability.data_transfer_size = 0;
        spdm_context->connection_info.capability.max_spdm_msg_size = 0;
    }

    /* -=[Update State Phase]=- */
    spdm_context->connection_info.connection_state = LIBSPDM_CONNECTION_STATE_AFTER_CAPABILITIES;
    status = LIBSPDM_STATUS_SUCCESS;

    /* -=[Log Message Phase]=- */
    #if LIBSPDM_ENABLE_MSG_LOG
    libspdm_append_msg_log(spdm_context, spdm_response, spdm_response_size);
    #endif /* LIBSPDM_ENABLE_MSG_LOG */

receive_done:
    libspdm_release_receiver_buffer (spdm_context);
    return status;
}","static libspdm_return_t libspdm_try_get_capabilities(libspdm_context_t *VAR_0)
{
    libspdm_return_t VAR_1;
    spdm_get_capabilities_request_t *VAR_2;
    size_t VAR_3;
    spdm_capabilities_response_t *VAR_4;
    size_t VAR_5;
    uint8_t *VAR_6;
    size_t VAR_7;
    size_t VAR_8;

    /* COMMENT_0 */
    if (VAR_0->connection_info.connection_state != VAR_9) {
        return VAR_10;
    }
    libspdm_reset_message_buffer_via_request_code(VAR_0, NULL, VAR_11);

    /* COMMENT_1 */
    VAR_8 = VAR_0->transport_get_header_size(VAR_0);
    VAR_1 = libspdm_acquire_sender_buffer (VAR_0, &VAR_7, (void **)&VAR_6);
    if (LIBSPDM_STATUS_IS_ERROR(VAR_1)) {
        return VAR_1;
    }
    LIBSPDM_ASSERT (VAR_7 >= VAR_8);
    VAR_2 = (void *)(VAR_6 + VAR_8);

    libspdm_zero_mem(VAR_2, sizeof(spdm_get_capabilities_request_t));
    VAR_2->header.spdm_version = libspdm_get_connection_version (VAR_0);
    if (VAR_2->header.spdm_version >= VAR_12) {
        VAR_3 = sizeof(spdm_get_capabilities_request_t);
    } else if (VAR_2->header.spdm_version >= VAR_13) {
        VAR_3 = sizeof(spdm_get_capabilities_request_t) -
                            sizeof(VAR_2->data_transfer_size) -
                            sizeof(VAR_2->max_spdm_msg_size);
    } else {
        VAR_3 = sizeof(VAR_2->header);
    }
    VAR_2->header.request_response_code = VAR_11;
    VAR_2->header.param1 = 0;
    VAR_2->header.param2 = 0;
    VAR_2->ct_exponent = VAR_0->local_context.capability.ct_exponent;
    VAR_2->flags = VAR_0->local_context.capability.flags;
    VAR_2->data_transfer_size = VAR_0->local_context.capability.data_transfer_size;
    VAR_2->max_spdm_msg_size = VAR_0->local_context.capability.max_spdm_msg_size;

    /* COMMENT_2 */
    VAR_1 = libspdm_send_spdm_request(VAR_0, NULL, VAR_3, VAR_2);
    if (LIBSPDM_STATUS_IS_ERROR(VAR_1)) {
        libspdm_release_sender_buffer (VAR_0);
        return VAR_1;
    }
    libspdm_release_sender_buffer (VAR_0);
    VAR_2 = (void *)VAR_0->last_spdm_request;

    /* COMMENT_3 */
    VAR_1 = libspdm_acquire_receiver_buffer (VAR_0, &VAR_7, (void **)&VAR_6);
    if (LIBSPDM_STATUS_IS_ERROR(VAR_1)) {
        return VAR_1;
    }
    LIBSPDM_ASSERT (VAR_7 >= VAR_8);
    VAR_4 = (void *)(VAR_6);
    VAR_5 = VAR_7;

    libspdm_zero_mem(VAR_4, VAR_5);
    VAR_1 = libspdm_receive_spdm_response(VAR_0, NULL, &VAR_5,
                                           (void **)&VAR_4);
    if (LIBSPDM_STATUS_IS_ERROR(VAR_1)) {
        goto receive_done;
    }

    /* COMMENT_4 */
    if (VAR_5 < sizeof(VAR_14)) {
        VAR_1 = VAR_15;
        goto receive_done;
    }
    if (VAR_4->header.spdm_version != VAR_2->header.spdm_version) {
        VAR_1 = VAR_16;
        goto receive_done;
    }
    if (VAR_4->header.request_response_code == VAR_17) {
        VAR_1 = libspdm_handle_simple_error_response(
            VAR_0, VAR_4->header.param1);
        if (LIBSPDM_STATUS_IS_ERROR(VAR_1)) {
            goto receive_done;
        }
    } else if (VAR_4->header.request_response_code != VAR_18) {
        VAR_1 = VAR_16;
        goto receive_done;
    }
    if (VAR_4->header.spdm_version >= VAR_12) {
        if (VAR_5 < sizeof(spdm_capabilities_response_t)) {
            VAR_1 = VAR_15;
            goto receive_done;
        }
    } else {
        if (VAR_5 < sizeof(spdm_capabilities_response_t) -
            sizeof(VAR_4->data_transfer_size) - sizeof(VAR_4->max_spdm_msg_size)) {
            VAR_1 = VAR_15;
            goto receive_done;
        }
    }
    if (VAR_2->header.spdm_version >= VAR_12) {
        VAR_5 = sizeof(spdm_capabilities_response_t);
    } else {
        VAR_5 = sizeof(spdm_capabilities_response_t) -
                             sizeof(VAR_4->data_transfer_size) -
                             sizeof(VAR_4->max_spdm_msg_size);
    }

    if (!validate_responder_capability(VAR_4->flags, VAR_4->header.spdm_version)) {
        VAR_1 = VAR_16;
        goto receive_done;
    }
    if (VAR_4->header.spdm_version >= VAR_12) {
        if ((VAR_4->data_transfer_size < VAR_19) ||
            (VAR_4->data_transfer_size > VAR_4->max_spdm_msg_size)) {
            VAR_1 = VAR_16;
            goto receive_done;
        }

        if (((VAR_4->flags & VAR_20) == 0) &&
            (VAR_4->data_transfer_size != VAR_4->max_spdm_msg_size)) {
            VAR_1 = VAR_16;
            goto receive_done;
        }
    }

    if (VAR_4->ct_exponent > VAR_21) {
        VAR_1 = VAR_16;
        goto receive_done;
    }

    /* COMMENT_5 */
    VAR_1 = libspdm_append_message_a(VAR_0, VAR_2, VAR_3);
    if (LIBSPDM_STATUS_IS_ERROR(VAR_1)) {
        VAR_1 = VAR_22;
        goto receive_done;
    }

    VAR_1 = libspdm_append_message_a(VAR_0, VAR_4, VAR_5);
    if (LIBSPDM_STATUS_IS_ERROR(VAR_1)) {
        VAR_1 = VAR_22;
        goto receive_done;
    }

    VAR_0->connection_info.capability.ct_exponent = VAR_4->ct_exponent;
    VAR_0->connection_info.capability.flags = VAR_4->flags;

    if (VAR_4->header.spdm_version >= VAR_12) {
        VAR_0->connection_info.capability.data_transfer_size =
            VAR_4->data_transfer_size;
        VAR_0->connection_info.capability.max_spdm_msg_size =
            VAR_4->max_spdm_msg_size;
    } else {
        VAR_0->connection_info.capability.data_transfer_size = 0;
        VAR_0->connection_info.capability.max_spdm_msg_size = 0;
    }

    /* COMMENT_6 */
    VAR_0->connection_info.connection_state = VAR_23;
    VAR_1 = VAR_24;

    /* COMMENT_7 */
    #if VAR_25
    libspdm_append_msg_log(VAR_0, VAR_4, VAR_5);
    #endif /* COMMENT_8 */

receive_done:
    libspdm_release_receiver_buffer (VAR_0);
    return VAR_1;
}",DMTF/libspdm/48debe26f633e3b16809255d6ca7ce18db649a13/libspdm_req_get_capabilities.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -125,6 +125,11 @@
         }
     }
 
+    if (spdm_response->ct_exponent > LIBSPDM_MAX_CT_EXPONENT) {
+        status = LIBSPDM_STATUS_INVALID_MSG_FIELD;
+        goto receive_done;
+    }
+
     /* -=[Process Response Phase]=- */
     status = libspdm_append_message_a(spdm_context, spdm_request, spdm_request_size);
     if (LIBSPDM_STATUS_IS_ERROR(status)) {","{'deleted_lines': [], 'added_lines': ['    if (spdm_response->ct_exponent > LIBSPDM_MAX_CT_EXPONENT) {', '        status = LIBSPDM_STATUS_INVALID_MSG_FIELD;', '        goto receive_done;', '    }', '']}",True,"libspdm is a sample implementation that follows the DMTF SPDM specifications. Prior to versions 2.3.3 and 3.0, following a successful CAPABILITIES response, a libspdm Requester stores the Responder's CTExponent into its context without validation. If the Requester sends a request message that requires a cryptography operation by the Responder, such as CHALLENGE, libspdm will calculate the timeout value using the Responder's unvalidated CTExponent.

A patch is available in version 2.3.3. A workaround is also available. After completion of VCA, the Requester can check the value of the Responder's CTExponent. If it greater than or equal to 64, then the Requester can stop communication with the Responder.",5.7,MEDIUM,1,test,2023-05-28T23:22:15Z,4
CVE-2023-32690,['CWE-20'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,DMTF/libspdm,"Prevent undefined behavior

Fix #2068 in main branch.

Signed-off-by: Steven Bellock <sbellock@nvidia.com>",48debe26f633e3b16809255d6ca7ce18db649a13,https://github.com/DMTF/libspdm/commit/48debe26f633e3b16809255d6ca7ce18db649a13,library/spdm_requester_lib/libspdm_req_handle_error_response.c,libspdm_handle_response_not_ready,"static libspdm_return_t libspdm_handle_response_not_ready(libspdm_context_t *spdm_context,
const uint32_t *session_id,
size_t *response_size,
void **response,
uint8_t original_request_code,
uint8_t expected_response_code)
{
spdm_error_response_t *spdm_response;
spdm_error_data_response_not_ready_t *extend_error_data;
if(*response_size < sizeof(spdm_error_response_t) +
sizeof(spdm_error_data_response_not_ready_t)) {
return LIBSPDM_STATUS_INVALID_MSG_SIZE;
}
spdm_response = *response;
extend_error_data = (spdm_error_data_response_not_ready_t *)(spdm_response + 1);
LIBSPDM_ASSERT(spdm_response->header.request_response_code == SPDM_ERROR);
LIBSPDM_ASSERT(spdm_response->header.param1 == SPDM_ERROR_CODE_RESPONSE_NOT_READY);
if (extend_error_data->request_code != original_request_code) {
return LIBSPDM_STATUS_INVALID_MSG_FIELD;
}
if (extend_error_data->rd_tm <= 1) {
return LIBSPDM_STATUS_INVALID_MSG_FIELD;
}
spdm_context->error_data.rd_exponent = extend_error_data->rd_exponent;
spdm_context->error_data.request_code = extend_error_data->request_code;
spdm_context->error_data.token = extend_error_data->token;
spdm_context->error_data.rd_tm = extend_error_data->rd_tm;
libspdm_sleep((2 << extend_error_data->rd_exponent));
return libspdm_requester_respond_if_ready(spdm_context, session_id,
response_size, response,
expected_response_code);
}","static libspdm_return_t libspdm_handle_response_not_ready(libspdm_context_t *VAR_0,
const uint32_t *VAR_1,
size_t *VAR_2,
void **VAR_3,
uint8_t VAR_4,
uint8_t VAR_5)
{
spdm_error_response_t *VAR_6;
spdm_error_data_response_not_ready_t *VAR_7;
if(*VAR_2 < sizeof(spdm_error_response_t) +
sizeof(spdm_error_data_response_not_ready_t)) {
return VAR_8;
}
VAR_6 = *VAR_3;
VAR_7 = (spdm_error_data_response_not_ready_t *)(VAR_6 + 1);
LIBSPDM_ASSERT(VAR_6->header.request_response_code == VAR_9);
LIBSPDM_ASSERT(VAR_6->header.param1 == VAR_10);
if (VAR_7->request_code != VAR_4) {
return VAR_11;
}
if (VAR_7->rd_tm <= 1) {
return VAR_11;
}
VAR_0->error_data.rd_exponent = VAR_7->rd_exponent;
VAR_0->error_data.request_code = VAR_7->request_code;
VAR_0->error_data.token = VAR_7->token;
VAR_0->error_data.rd_tm = VAR_7->rd_tm;
libspdm_sleep((2 << VAR_7->rd_exponent));
return libspdm_requester_respond_if_ready(VAR_0, VAR_1,
VAR_2, VAR_3,
VAR_5);
}",DMTF/libspdm/48debe26f633e3b16809255d6ca7ce18db649a13/libspdm_req_handle_error_response.c/vul/before/0.json,"static libspdm_return_t libspdm_handle_response_not_ready(libspdm_context_t *spdm_context,
                                                          const uint32_t *session_id,
                                                          size_t *response_size,
                                                          void **response,
                                                          uint8_t original_request_code,
                                                          uint8_t expected_response_code)
{
    spdm_error_response_t *spdm_response;
    spdm_error_data_response_not_ready_t *extend_error_data;

    if(*response_size < sizeof(spdm_error_response_t) +
       sizeof(spdm_error_data_response_not_ready_t)) {
        return LIBSPDM_STATUS_INVALID_MSG_SIZE;
    }

    spdm_response = *response;
    extend_error_data = (spdm_error_data_response_not_ready_t *)(spdm_response + 1);
    LIBSPDM_ASSERT(spdm_response->header.request_response_code == SPDM_ERROR);
    LIBSPDM_ASSERT(spdm_response->header.param1 == SPDM_ERROR_CODE_RESPONSE_NOT_READY);

    if (extend_error_data->request_code != original_request_code) {
        return LIBSPDM_STATUS_INVALID_MSG_FIELD;
    }
    if (extend_error_data->rd_tm <= 1) {
        return LIBSPDM_STATUS_INVALID_MSG_FIELD;
    }
    if (extend_error_data->rd_exponent > LIBSPDM_MAX_RDT_EXPONENT) {
        return LIBSPDM_STATUS_INVALID_MSG_FIELD;
    }

    spdm_context->error_data.rd_exponent = extend_error_data->rd_exponent;
    spdm_context->error_data.request_code = extend_error_data->request_code;
    spdm_context->error_data.token = extend_error_data->token;
    spdm_context->error_data.rd_tm = extend_error_data->rd_tm;

    libspdm_sleep((uint64_t)1 << extend_error_data->rd_exponent);

    return libspdm_requester_respond_if_ready(spdm_context, session_id,
                                              response_size, response,
                                              expected_response_code);
}","static libspdm_return_t libspdm_handle_response_not_ready(libspdm_context_t *VAR_0,
                                                          const uint32_t *VAR_1,
                                                          size_t *VAR_2,
                                                          void **VAR_3,
                                                          uint8_t VAR_4,
                                                          uint8_t VAR_5)
{
    spdm_error_response_t *VAR_6;
    spdm_error_data_response_not_ready_t *VAR_7;

    if(*VAR_2 < sizeof(spdm_error_response_t) +
       sizeof(spdm_error_data_response_not_ready_t)) {
        return VAR_8;
    }

    VAR_6 = *VAR_3;
    VAR_7 = (spdm_error_data_response_not_ready_t *)(VAR_6 + 1);
    LIBSPDM_ASSERT(VAR_6->header.request_response_code == VAR_9);
    LIBSPDM_ASSERT(VAR_6->header.param1 == VAR_10);

    if (VAR_7->request_code != VAR_4) {
        return VAR_11;
    }
    if (VAR_7->rd_tm <= 1) {
        return VAR_11;
    }
    if (VAR_7->rd_exponent > VAR_12) {
        return VAR_11;
    }

    VAR_0->error_data.rd_exponent = VAR_7->rd_exponent;
    VAR_0->error_data.request_code = VAR_7->request_code;
    VAR_0->error_data.token = VAR_7->token;
    VAR_0->error_data.rd_tm = VAR_7->rd_tm;

    libspdm_sleep((uint64_t)1 << VAR_7->rd_exponent);

    return libspdm_requester_respond_if_ready(VAR_0, VAR_1,
                                              VAR_2, VAR_3,
                                              VAR_5);
}",DMTF/libspdm/48debe26f633e3b16809255d6ca7ce18db649a13/libspdm_req_handle_error_response.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,11 +17,14 @@
     extend_error_data = (spdm_error_data_response_not_ready_t *)(spdm_response + 1);
     LIBSPDM_ASSERT(spdm_response->header.request_response_code == SPDM_ERROR);
     LIBSPDM_ASSERT(spdm_response->header.param1 == SPDM_ERROR_CODE_RESPONSE_NOT_READY);
+
     if (extend_error_data->request_code != original_request_code) {
         return LIBSPDM_STATUS_INVALID_MSG_FIELD;
     }
-
     if (extend_error_data->rd_tm <= 1) {
+        return LIBSPDM_STATUS_INVALID_MSG_FIELD;
+    }
+    if (extend_error_data->rd_exponent > LIBSPDM_MAX_RDT_EXPONENT) {
         return LIBSPDM_STATUS_INVALID_MSG_FIELD;
     }
 
@@ -30,7 +33,8 @@
     spdm_context->error_data.token = extend_error_data->token;
     spdm_context->error_data.rd_tm = extend_error_data->rd_tm;
 
-    libspdm_sleep((2 << extend_error_data->rd_exponent));
+    libspdm_sleep((uint64_t)1 << extend_error_data->rd_exponent);
+
     return libspdm_requester_respond_if_ready(spdm_context, session_id,
                                               response_size, response,
                                               expected_response_code);","{'deleted_lines': ['', '    libspdm_sleep((2 << extend_error_data->rd_exponent));'], 'added_lines': ['', '        return LIBSPDM_STATUS_INVALID_MSG_FIELD;', '    }', '    if (extend_error_data->rd_exponent > LIBSPDM_MAX_RDT_EXPONENT) {', '    libspdm_sleep((uint64_t)1 << extend_error_data->rd_exponent);', '']}",True,"libspdm is a sample implementation that follows the DMTF SPDM specifications. Prior to versions 2.3.3 and 3.0, following a successful CAPABILITIES response, a libspdm Requester stores the Responder's CTExponent into its context without validation. If the Requester sends a request message that requires a cryptography operation by the Responder, such as CHALLENGE, libspdm will calculate the timeout value using the Responder's unvalidated CTExponent.

A patch is available in version 2.3.3. A workaround is also available. After completion of VCA, the Requester can check the value of the Responder's CTExponent. If it greater than or equal to 64, then the Requester can stop communication with the Responder.",5.7,MEDIUM,1,test,2023-05-28T23:22:15Z,4
CVE-2023-32690,['CWE-20'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,DMTF/libspdm,"Prevent undefined behavior

Fix #2068 in main branch.

Signed-off-by: Steven Bellock <sbellock@nvidia.com>",48debe26f633e3b16809255d6ca7ce18db649a13,https://github.com/DMTF/libspdm/commit/48debe26f633e3b16809255d6ca7ce18db649a13,library/spdm_requester_lib/libspdm_req_send_receive.c,libspdm_receive_response,"libspdm_return_t libspdm_receive_response(void *spdm_context, const uint32_t *session_id,
bool is_app_message,
size_t *response_size,
void **response)
{
libspdm_context_t *context;
void *temp_session_context;
libspdm_return_t status;
uint8_t *message;
size_t message_size;
uint32_t *message_session_id;
bool is_message_app_message;
uint64_t timeout;
size_t transport_header_size;
uint8_t *scratch_buffer;
size_t scratch_buffer_size;
void *backup_response;
size_t backup_response_size;
bool reset_key_update;
bool result;
context = spdm_context;
if (context->crypto_request) {
timeout = context->local_context.capability.rtt +
((uint64_t)2 << context->connection_info.capability.ct_exponent);
} else {
timeout = context->local_context.capability.rtt +
context->local_context.capability.st1;
}
message = *response;
message_size = *response_size;
status = context->receive_message(context, &message_size,
(void **)&message, timeout);
if (LIBSPDM_STATUS_IS_ERROR(status)) {
LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO,
""libspdm_receive_spdm_response[%x] status - %p\n"",
(session_id != NULL) ? *session_id : 0x0, status));
return status;
}
message_session_id = NULL;
is_message_app_message = false;
transport_header_size = context->transport_get_header_size(context);
libspdm_get_scratch_buffer (context, (void **)&scratch_buffer, &scratch_buffer_size);
#if LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP
*response = scratch_buffer + libspdm_get_scratch_buffer_secure_message_offset(context) +
transport_header_size;
*response_size = libspdm_get_scratch_buffer_secure_message_capacity(context) -
transport_header_size;
#else
*response = scratch_buffer + transport_header_size;
*response_size = scratch_buffer_size - transport_header_size;
#endif
backup_response = *response;
backup_response_size = *response_size;
status = context->transport_decode_message(
context, &message_session_id, &is_message_app_message,
false, message_size, message, response_size, response);
reset_key_update = false;
temp_session_context = NULL;
if (status == LIBSPDM_STATUS_SESSION_TRY_DISCARD_KEY_UPDATE) {
if (message_session_id == NULL) {
return LIBSPDM_STATUS_INVALID_STATE_LOCAL;
}
temp_session_context = libspdm_get_secured_message_context_via_session_id(
context, *message_session_id);
if (temp_session_context == NULL) {
return LIBSPDM_STATUS_INVALID_STATE_LOCAL;
}
result = libspdm_activate_update_session_data_key(
temp_session_context, LIBSPDM_KEY_UPDATE_ACTION_RESPONDER, false);
if (!result) {
return LIBSPDM_STATUS_INVALID_STATE_LOCAL;
}
message_session_id = NULL;
is_message_app_message = false;
*response = backup_response;
*response_size = backup_response_size;
status = context->transport_decode_message(
context, &message_session_id, &is_message_app_message,
false, message_size, message, response_size, response);
reset_key_update = true;
}
if (session_id != NULL) {
if (message_session_id == NULL) {
LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO,
""libspdm_receive_spdm_response[%x] GetSessionId - NULL\n"",
(session_id != NULL) ? *session_id : 0x0));
goto error;
}
if (*message_session_id != *session_id) {
LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO,
""libspdm_receive_spdm_response[%x] GetSessionId - %x\n"",
(session_id != NULL) ? *session_id : 0x0,
*message_session_id));
goto error;
}
} else {
if (message_session_id != NULL) {
LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO,
""libspdm_receive_spdm_response[%x] GetSessionId - %x\n"",
(session_id != NULL) ? *session_id : 0x0,
*message_session_id));
goto error;
}
}
if ((is_app_message && !is_message_app_message) ||
(!is_app_message && is_message_app_message)) {
LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO,
""libspdm_receive_spdm_response[%x] app_message mismatch\n"",
(session_id != NULL) ? *session_id : 0x0));
goto error;
}
if (LIBSPDM_STATUS_IS_ERROR(status)) {
LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO,
""libspdm_receive_spdm_response[%x] status - %p\n"",
(session_id != NULL) ? *session_id : 0x0, status));
} else {
LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO,
""libspdm_receive_spdm_response[%x] msg %s(0x%x), size (0x%x): \n"",
(session_id != NULL) ? *session_id : 0x0,
libspdm_get_code_str(((spdm_message_header_t *)*response)->
request_response_code),
((spdm_message_header_t *)*response)->request_response_code,
*response_size));
LIBSPDM_INTERNAL_DUMP_HEX(*response, *response_size);
}
if (reset_key_update)
{
if (temp_session_context == NULL || message_session_id == NULL) {
return LIBSPDM_STATUS_INVALID_STATE_LOCAL;
}
result = libspdm_create_update_session_data_key(
temp_session_context, LIBSPDM_KEY_UPDATE_ACTION_RESPONDER);
if (!result) {
return LIBSPDM_STATUS_INVALID_STATE_LOCAL;
}
}
return status;
error:
if (context->last_spdm_error.error_code == SPDM_ERROR_CODE_DECRYPT_ERROR) {
return LIBSPDM_STATUS_SESSION_MSG_ERROR;
} else {
return LIBSPDM_STATUS_RECEIVE_FAIL;
}
}","libspdm_return_t libspdm_receive_response(void *VAR_0, const uint32_t *VAR_1,
bool VAR_2,
size_t *VAR_3,
void **VAR_4)
{
libspdm_context_t *VAR_5;
void *VAR_6;
libspdm_return_t VAR_7;
uint8_t *VAR_8;
size_t VAR_9;
uint32_t *VAR_10;
bool VAR_11;
uint64_t VAR_12;
size_t VAR_13;
uint8_t *VAR_14;
size_t VAR_15;
void *VAR_16;
size_t VAR_17;
bool VAR_18;
bool VAR_19;
VAR_5 = VAR_0;
if (VAR_5->crypto_request) {
VAR_12 = VAR_5->local_context.capability.rtt +
((uint64_t)2 << VAR_5->connection_info.capability.ct_exponent);
} else {
VAR_12 = VAR_5->local_context.capability.rtt +
VAR_5->local_context.capability.st1;
}
VAR_8 = *VAR_4;
VAR_9 = *VAR_3;
VAR_7 = VAR_5->receive_message(VAR_5, &VAR_9,
(void **)&VAR_8, VAR_12);
if (LIBSPDM_STATUS_IS_ERROR(VAR_7)) {
LIBSPDM_DEBUG((VAR_20,
""libspdm_receive_spdm_response[%x] status - %p\n"",
(VAR_1 != NULL) ? *VAR_1 : 0x0, VAR_7));
return VAR_7;
}
VAR_10 = NULL;
VAR_11 = false;
VAR_13 = VAR_5->transport_get_header_size(VAR_5);
libspdm_get_scratch_buffer (VAR_5, (void **)&VAR_14, &VAR_15);
#if VAR_21
*VAR_4 = VAR_14 + libspdm_get_scratch_buffer_secure_message_offset(VAR_5) +
VAR_13;
*VAR_3 = libspdm_get_scratch_buffer_secure_message_capacity(VAR_5) -
VAR_13;
#else
*VAR_4 = VAR_14 + VAR_13;
*VAR_3 = VAR_15 - VAR_13;
#endif
VAR_16 = *VAR_4;
VAR_17 = *VAR_3;
VAR_7 = VAR_5->transport_decode_message(
VAR_5, &VAR_10, &VAR_11,
false, VAR_9, VAR_8, VAR_3, VAR_4);
VAR_18 = false;
VAR_6 = NULL;
if (VAR_7 == VAR_22) {
if (VAR_10 == NULL) {
return VAR_23;
}
VAR_6 = libspdm_get_secured_message_context_via_session_id(
VAR_5, *VAR_10);
if (VAR_6 == NULL) {
return VAR_23;
}
VAR_19 = libspdm_activate_update_session_data_key(
VAR_6, VAR_24, false);
if (!VAR_19) {
return VAR_23;
}
VAR_10 = NULL;
VAR_11 = false;
*VAR_4 = VAR_16;
*VAR_3 = VAR_17;
VAR_7 = VAR_5->transport_decode_message(
VAR_5, &VAR_10, &VAR_11,
false, VAR_9, VAR_8, VAR_3, VAR_4);
VAR_18 = true;
}
if (VAR_1 != NULL) {
if (VAR_10 == NULL) {
LIBSPDM_DEBUG((VAR_20,
""libspdm_receive_spdm_response[%x] GetSessionId - NULL\n"",
(VAR_1 != NULL) ? *VAR_1 : 0x0));
goto error;
}
if (*VAR_10 != *VAR_1) {
LIBSPDM_DEBUG((VAR_20,
""libspdm_receive_spdm_response[%x] GetSessionId - %x\n"",
(VAR_1 != NULL) ? *VAR_1 : 0x0,
*VAR_10));
goto error;
}
} else {
if (VAR_10 != NULL) {
LIBSPDM_DEBUG((VAR_20,
""libspdm_receive_spdm_response[%x] GetSessionId - %x\n"",
(VAR_1 != NULL) ? *VAR_1 : 0x0,
*VAR_10));
goto error;
}
}
if ((VAR_2 && !VAR_11) ||
(!VAR_2 && VAR_11)) {
LIBSPDM_DEBUG((VAR_20,
""libspdm_receive_spdm_response[%x] app_message mismatch\n"",
(VAR_1 != NULL) ? *VAR_1 : 0x0));
goto error;
}
if (LIBSPDM_STATUS_IS_ERROR(VAR_7)) {
LIBSPDM_DEBUG((VAR_20,
""libspdm_receive_spdm_response[%x] status - %p\n"",
(VAR_1 != NULL) ? *VAR_1 : 0x0, VAR_7));
} else {
LIBSPDM_DEBUG((VAR_20,
""libspdm_receive_spdm_response[%x] msg %s(0x%x), size (0x%x): \n"",
(VAR_1 != NULL) ? *VAR_1 : 0x0,
libspdm_get_code_str(((spdm_message_header_t *)*VAR_4)->
request_response_code),
((spdm_message_header_t *)*VAR_4)->request_response_code,
*VAR_3));
LIBSPDM_INTERNAL_DUMP_HEX(*VAR_4, *VAR_3);
}
if (VAR_18)
{
if (VAR_6 == NULL || VAR_10 == NULL) {
return VAR_23;
}
VAR_19 = libspdm_create_update_session_data_key(
VAR_6, VAR_24);
if (!VAR_19) {
return VAR_23;
}
}
return VAR_7;
error:
if (VAR_5->last_spdm_error.error_code == VAR_25) {
return VAR_26;
} else {
return VAR_27;
}
}",DMTF/libspdm/48debe26f633e3b16809255d6ca7ce18db649a13/libspdm_req_send_receive.c/vul/before/0.json,"libspdm_return_t libspdm_receive_response(void *spdm_context, const uint32_t *session_id,
                                          bool is_app_message,
                                          size_t *response_size,
                                          void **response)
{
    libspdm_context_t *context;
    void *temp_session_context;
    libspdm_return_t status;
    uint8_t *message;
    size_t message_size;
    uint32_t *message_session_id;
    bool is_message_app_message;
    uint64_t timeout;
    size_t transport_header_size;
    uint8_t *scratch_buffer;
    size_t scratch_buffer_size;
    void *backup_response;
    size_t backup_response_size;
    bool reset_key_update;
    bool result;

    context = spdm_context;

    if (context->crypto_request) {
        timeout = context->local_context.capability.rtt +
                  ((uint64_t)1 << context->connection_info.capability.ct_exponent);
    } else {
        timeout = context->local_context.capability.rtt +
                  context->local_context.capability.st1;
    }

    message = *response;
    message_size = *response_size;
    status = context->receive_message(context, &message_size,
                                      (void **)&message, timeout);
    if (LIBSPDM_STATUS_IS_ERROR(status)) {
        LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO,
                       ""libspdm_receive_spdm_response[%x] status - %p\n"",
                       (session_id != NULL) ? *session_id : 0x0, status));
        return status;
    }

    message_session_id = NULL;
    is_message_app_message = false;

    /* always use scratch buffer to response.
     * if it is secured message, this scratch buffer will be used.
     * if it is normal message, the response ptr will point to receiver buffer. */
    transport_header_size = context->transport_get_header_size(context);
    libspdm_get_scratch_buffer (context, (void **)&scratch_buffer, &scratch_buffer_size);
    #if LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP
    *response = scratch_buffer + libspdm_get_scratch_buffer_secure_message_offset(context) +
                transport_header_size;
    *response_size = libspdm_get_scratch_buffer_secure_message_capacity(context) -
                     transport_header_size;
    #else
    *response = scratch_buffer + transport_header_size;
    *response_size = scratch_buffer_size - transport_header_size;
    #endif

    backup_response = *response;
    backup_response_size = *response_size;

    status = context->transport_decode_message(
        context, &message_session_id, &is_message_app_message,
        false, message_size, message, response_size, response);

    reset_key_update = false;
    temp_session_context = NULL;

    if (status == LIBSPDM_STATUS_SESSION_TRY_DISCARD_KEY_UPDATE) {
        /* Failed to decode, but have backup keys. Try rolling back before aborting.
         * message_session_id must be valid for us to have attempted decryption. */
        if (message_session_id == NULL) {
            return LIBSPDM_STATUS_INVALID_STATE_LOCAL;
        }
        temp_session_context = libspdm_get_secured_message_context_via_session_id(
            context, *message_session_id);
        if (temp_session_context == NULL) {
            return LIBSPDM_STATUS_INVALID_STATE_LOCAL;
        }

        result = libspdm_activate_update_session_data_key(
            temp_session_context, LIBSPDM_KEY_UPDATE_ACTION_RESPONDER, false);
        if (!result) {
            return LIBSPDM_STATUS_INVALID_STATE_LOCAL;
        }

        /* Retry decoding message with backup Requester key.
         * Must reset some of the parameters in case they were modified */
        message_session_id = NULL;
        is_message_app_message = false;
        *response = backup_response;
        *response_size = backup_response_size;
        status = context->transport_decode_message(
            context, &message_session_id, &is_message_app_message,
            false, message_size, message, response_size, response);

        reset_key_update = true;
    }

    if (session_id != NULL) {
        if (message_session_id == NULL) {
            LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO,
                           ""libspdm_receive_spdm_response[%x] GetSessionId - NULL\n"",
                           (session_id != NULL) ? *session_id : 0x0));
            goto error;
        }
        if (*message_session_id != *session_id) {
            LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO,
                           ""libspdm_receive_spdm_response[%x] GetSessionId - %x\n"",
                           (session_id != NULL) ? *session_id : 0x0,
                           *message_session_id));
            goto error;
        }
    } else {
        if (message_session_id != NULL) {
            LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO,
                           ""libspdm_receive_spdm_response[%x] GetSessionId - %x\n"",
                           (session_id != NULL) ? *session_id : 0x0,
                           *message_session_id));
            goto error;
        }
    }

    if ((is_app_message && !is_message_app_message) ||
        (!is_app_message && is_message_app_message)) {
        LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO,
                       ""libspdm_receive_spdm_response[%x] app_message mismatch\n"",
                       (session_id != NULL) ? *session_id : 0x0));
        goto error;
    }

    if (LIBSPDM_STATUS_IS_ERROR(status)) {
        LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO,
                       ""libspdm_receive_spdm_response[%x] status - %p\n"",
                       (session_id != NULL) ? *session_id : 0x0, status));
    } else {
        LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO,
                       ""libspdm_receive_spdm_response[%x] msg %s(0x%x), size (0x%x): \n"",
                       (session_id != NULL) ? *session_id : 0x0,
                       libspdm_get_code_str(((spdm_message_header_t *)*response)->
                                            request_response_code),
                       ((spdm_message_header_t *)*response)->request_response_code,
                       *response_size));
        LIBSPDM_INTERNAL_DUMP_HEX(*response, *response_size);
    }

    /* Handle special case:
     * If the Responder returns RESPONSE_NOT_READY error to KEY_UPDATE, the Requester needs
     * to activate backup key to parse the error. Then later the Responder will return SUCCESS,
     * the Requester needs new key. So we need to restore the environment by
     * libspdm_create_update_session_data_key() again.*/
    if (reset_key_update)
    {
        /* temp_session_context and message_session_id must necessarily
         * be valid for us to reach here. */
        if (temp_session_context == NULL || message_session_id == NULL) {
            return LIBSPDM_STATUS_INVALID_STATE_LOCAL;
        }
        result = libspdm_create_update_session_data_key(
            temp_session_context, LIBSPDM_KEY_UPDATE_ACTION_RESPONDER);
        if (!result) {
            return LIBSPDM_STATUS_INVALID_STATE_LOCAL;
        }
    }

    return status;

error:
    if (context->last_spdm_error.error_code == SPDM_ERROR_CODE_DECRYPT_ERROR) {
        return LIBSPDM_STATUS_SESSION_MSG_ERROR;
    } else {
        return LIBSPDM_STATUS_RECEIVE_FAIL;
    }
}","libspdm_return_t libspdm_receive_response(void *VAR_0, const uint32_t *VAR_1,
                                          bool VAR_2,
                                          size_t *VAR_3,
                                          void **VAR_4)
{
    libspdm_context_t *VAR_5;
    void *VAR_6;
    libspdm_return_t VAR_7;
    uint8_t *VAR_8;
    size_t VAR_9;
    uint32_t *VAR_10;
    bool VAR_11;
    uint64_t VAR_12;
    size_t VAR_13;
    uint8_t *VAR_14;
    size_t VAR_15;
    void *VAR_16;
    size_t VAR_17;
    bool VAR_18;
    bool VAR_19;

    VAR_5 = VAR_0;

    if (VAR_5->crypto_request) {
        VAR_12 = VAR_5->local_context.capability.rtt +
                  ((uint64_t)1 << VAR_5->connection_info.capability.ct_exponent);
    } else {
        VAR_12 = VAR_5->local_context.capability.rtt +
                  VAR_5->local_context.capability.st1;
    }

    VAR_8 = *VAR_4;
    VAR_9 = *VAR_3;
    VAR_7 = VAR_5->receive_message(VAR_5, &VAR_9,
                                      (void **)&VAR_8, VAR_12);
    if (LIBSPDM_STATUS_IS_ERROR(VAR_7)) {
        LIBSPDM_DEBUG((VAR_20,
                       ""libspdm_receive_spdm_response[%x] status - %p\n"",
                       (VAR_1 != NULL) ? *VAR_1 : 0x0, VAR_7));
        return VAR_7;
    }

    VAR_10 = NULL;
    VAR_11 = false;

    /* COMMENT_0 */
                                                                  
                                                                                  
    VAR_13 = VAR_5->transport_get_header_size(VAR_5);
    libspdm_get_scratch_buffer (VAR_5, (void **)&VAR_14, &VAR_15);
    #if VAR_21
    *VAR_4 = VAR_14 + libspdm_get_scratch_buffer_secure_message_offset(VAR_5) +
                VAR_13;
    *VAR_3 = libspdm_get_scratch_buffer_secure_message_capacity(VAR_5) -
                     VAR_13;
    #else
    *VAR_4 = VAR_14 + VAR_13;
    *VAR_3 = VAR_15 - VAR_13;
    #endif

    VAR_16 = *VAR_4;
    VAR_17 = *VAR_3;

    VAR_7 = VAR_5->transport_decode_message(
        VAR_5, &VAR_10, &VAR_11,
        false, VAR_9, VAR_8, VAR_3, VAR_4);

    VAR_18 = false;
    VAR_6 = NULL;

    if (VAR_7 == VAR_22) {
        /* COMMENT_3 */
                                                                                   
        if (VAR_10 == NULL) {
            return VAR_23;
        }
        VAR_6 = libspdm_get_secured_message_context_via_session_id(
            VAR_5, *VAR_10);
        if (VAR_6 == NULL) {
            return VAR_23;
        }

        VAR_19 = libspdm_activate_update_session_data_key(
            VAR_6, VAR_24, false);
        if (!VAR_19) {
            return VAR_23;
        }

        /* COMMENT_5 */
                                                                          
        VAR_10 = NULL;
        VAR_11 = false;
        *VAR_4 = VAR_16;
        *VAR_3 = VAR_17;
        VAR_7 = VAR_5->transport_decode_message(
            VAR_5, &VAR_10, &VAR_11,
            false, VAR_9, VAR_8, VAR_3, VAR_4);

        VAR_18 = true;
    }

    if (VAR_1 != NULL) {
        if (VAR_10 == NULL) {
            LIBSPDM_DEBUG((VAR_20,
                           ""libspdm_receive_spdm_response[%x] GetSessionId - NULL\n"",
                           (VAR_1 != NULL) ? *VAR_1 : 0x0));
            goto error;
        }
        if (*VAR_10 != *VAR_1) {
            LIBSPDM_DEBUG((VAR_20,
                           ""libspdm_receive_spdm_response[%x] GetSessionId - %x\n"",
                           (VAR_1 != NULL) ? *VAR_1 : 0x0,
                           *VAR_10));
            goto error;
        }
    } else {
        if (VAR_10 != NULL) {
            LIBSPDM_DEBUG((VAR_20,
                           ""libspdm_receive_spdm_response[%x] GetSessionId - %x\n"",
                           (VAR_1 != NULL) ? *VAR_1 : 0x0,
                           *VAR_10));
            goto error;
        }
    }

    if ((VAR_2 && !VAR_11) ||
        (!VAR_2 && VAR_11)) {
        LIBSPDM_DEBUG((VAR_20,
                       ""libspdm_receive_spdm_response[%x] app_message mismatch\n"",
                       (VAR_1 != NULL) ? *VAR_1 : 0x0));
        goto error;
    }

    if (LIBSPDM_STATUS_IS_ERROR(VAR_7)) {
        LIBSPDM_DEBUG((VAR_20,
                       ""libspdm_receive_spdm_response[%x] status - %p\n"",
                       (VAR_1 != NULL) ? *VAR_1 : 0x0, VAR_7));
    } else {
        LIBSPDM_DEBUG((VAR_20,
                       ""libspdm_receive_spdm_response[%x] msg %s(0x%x), size (0x%x): \n"",
                       (VAR_1 != NULL) ? *VAR_1 : 0x0,
                       libspdm_get_code_str(((spdm_message_header_t *)*VAR_4)->
                                            request_response_code),
                       ((spdm_message_header_t *)*VAR_4)->request_response_code,
                       *VAR_3));
        LIBSPDM_INTERNAL_DUMP_HEX(*VAR_4, *VAR_3);
    }

    /* COMMENT_7 */
                                                                                           
                                                                                               
                                                                            
                                                        
    if (VAR_18)
    {
        /* COMMENT_12 */
                                            
        if (VAR_6 == NULL || VAR_10 == NULL) {
            return VAR_23;
        }
        VAR_19 = libspdm_create_update_session_data_key(
            VAR_6, VAR_24);
        if (!VAR_19) {
            return VAR_23;
        }
    }

    return VAR_7;

error:
    if (VAR_5->last_spdm_error.error_code == VAR_25) {
        return VAR_26;
    } else {
        return VAR_27;
    }
}",DMTF/libspdm/48debe26f633e3b16809255d6ca7ce18db649a13/libspdm_req_send_receive.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -23,7 +23,7 @@
 
     if (context->crypto_request) {
         timeout = context->local_context.capability.rtt +
-                  ((uint64_t)2 << context->connection_info.capability.ct_exponent);
+                  ((uint64_t)1 << context->connection_info.capability.ct_exponent);
     } else {
         timeout = context->local_context.capability.rtt +
                   context->local_context.capability.st1;","{'deleted_lines': ['                  ((uint64_t)2 << context->connection_info.capability.ct_exponent);'], 'added_lines': ['                  ((uint64_t)1 << context->connection_info.capability.ct_exponent);']}",True,"libspdm is a sample implementation that follows the DMTF SPDM specifications. Prior to versions 2.3.3 and 3.0, following a successful CAPABILITIES response, a libspdm Requester stores the Responder's CTExponent into its context without validation. If the Requester sends a request message that requires a cryptography operation by the Responder, such as CHALLENGE, libspdm will calculate the timeout value using the Responder's unvalidated CTExponent.

A patch is available in version 2.3.3. A workaround is also available. After completion of VCA, the Requester can check the value of the Responder's CTExponent. If it greater than or equal to 64, then the Requester can stop communication with the Responder.",5.7,MEDIUM,1,test,2023-05-28T23:22:15Z,4
CVE-2023-40283,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"Bluetooth: L2CAP: Fix use-after-free in l2cap_sock_ready_cb

l2cap_sock_release(sk) frees sk. However, sk's children are still alive
and point to the already free'd sk's address.
To fix this, l2cap_sock_release(sk) also cleans sk's children.

==================================================================
BUG: KASAN: use-after-free in l2cap_sock_ready_cb+0xb7/0x100 net/bluetooth/l2cap_sock.c:1650
Read of size 8 at addr ffff888104617aa8 by task kworker/u3:0/276

CPU: 0 PID: 276 Comm: kworker/u3:0 Not tainted 6.2.0-00001-gef397bd4d5fb-dirty #59
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014
Workqueue: hci2 hci_rx_work
Call Trace:
 <TASK>
 __dump_stack lib/dump_stack.c:88 [inline]
 dump_stack_lvl+0x72/0x95 lib/dump_stack.c:106
 print_address_description mm/kasan/report.c:306 [inline]
 print_report+0x175/0x478 mm/kasan/report.c:417
 kasan_report+0xb1/0x130 mm/kasan/report.c:517
 l2cap_sock_ready_cb+0xb7/0x100 net/bluetooth/l2cap_sock.c:1650
 l2cap_chan_ready+0x10e/0x1e0 net/bluetooth/l2cap_core.c:1386
 l2cap_config_req+0x753/0x9f0 net/bluetooth/l2cap_core.c:4480
 l2cap_bredr_sig_cmd net/bluetooth/l2cap_core.c:5739 [inline]
 l2cap_sig_channel net/bluetooth/l2cap_core.c:6509 [inline]
 l2cap_recv_frame+0xe2e/0x43c0 net/bluetooth/l2cap_core.c:7788
 l2cap_recv_acldata+0x6ed/0x7e0 net/bluetooth/l2cap_core.c:8506
 hci_acldata_packet net/bluetooth/hci_core.c:3813 [inline]
 hci_rx_work+0x66e/0xbc0 net/bluetooth/hci_core.c:4048
 process_one_work+0x4ea/0x8e0 kernel/workqueue.c:2289
 worker_thread+0x364/0x8e0 kernel/workqueue.c:2436
 kthread+0x1b9/0x200 kernel/kthread.c:376
 ret_from_fork+0x2c/0x50 arch/x86/entry/entry_64.S:308
 </TASK>

Allocated by task 288:
 kasan_save_stack+0x22/0x50 mm/kasan/common.c:45
 kasan_set_track+0x25/0x30 mm/kasan/common.c:52
 ____kasan_kmalloc mm/kasan/common.c:374 [inline]
 __kasan_kmalloc+0x82/0x90 mm/kasan/common.c:383
 kasan_kmalloc include/linux/kasan.h:211 [inline]
 __do_kmalloc_node mm/slab_common.c:968 [inline]
 __kmalloc+0x5a/0x140 mm/slab_common.c:981
 kmalloc include/linux/slab.h:584 [inline]
 sk_prot_alloc+0x113/0x1f0 net/core/sock.c:2040
 sk_alloc+0x36/0x3c0 net/core/sock.c:2093
 l2cap_sock_alloc.constprop.0+0x39/0x1c0 net/bluetooth/l2cap_sock.c:1852
 l2cap_sock_create+0x10d/0x220 net/bluetooth/l2cap_sock.c:1898
 bt_sock_create+0x183/0x290 net/bluetooth/af_bluetooth.c:132
 __sock_create+0x226/0x380 net/socket.c:1518
 sock_create net/socket.c:1569 [inline]
 __sys_socket_create net/socket.c:1606 [inline]
 __sys_socket_create net/socket.c:1591 [inline]
 __sys_socket+0x112/0x200 net/socket.c:1639
 __do_sys_socket net/socket.c:1652 [inline]
 __se_sys_socket net/socket.c:1650 [inline]
 __x64_sys_socket+0x40/0x50 net/socket.c:1650
 do_syscall_x64 arch/x86/entry/common.c:50 [inline]
 do_syscall_64+0x3f/0x90 arch/x86/entry/common.c:80
 entry_SYSCALL_64_after_hwframe+0x72/0xdc

Freed by task 288:
 kasan_save_stack+0x22/0x50 mm/kasan/common.c:45
 kasan_set_track+0x25/0x30 mm/kasan/common.c:52
 kasan_save_free_info+0x2e/0x50 mm/kasan/generic.c:523
 ____kasan_slab_free mm/kasan/common.c:236 [inline]
 ____kasan_slab_free mm/kasan/common.c:200 [inline]
 __kasan_slab_free+0x10a/0x190 mm/kasan/common.c:244
 kasan_slab_free include/linux/kasan.h:177 [inline]
 slab_free_hook mm/slub.c:1781 [inline]
 slab_free_freelist_hook mm/slub.c:1807 [inline]
 slab_free mm/slub.c:3787 [inline]
 __kmem_cache_free+0x88/0x1f0 mm/slub.c:3800
 sk_prot_free net/core/sock.c:2076 [inline]
 __sk_destruct+0x347/0x430 net/core/sock.c:2168
 sk_destruct+0x9c/0xb0 net/core/sock.c:2183
 __sk_free+0x82/0x220 net/core/sock.c:2194
 sk_free+0x7c/0xa0 net/core/sock.c:2205
 sock_put include/net/sock.h:1991 [inline]
 l2cap_sock_kill+0x256/0x2b0 net/bluetooth/l2cap_sock.c:1257
 l2cap_sock_release+0x1a7/0x220 net/bluetooth/l2cap_sock.c:1428
 __sock_release+0x80/0x150 net/socket.c:650
 sock_close+0x19/0x30 net/socket.c:1368
 __fput+0x17a/0x5c0 fs/file_table.c:320
 task_work_run+0x132/0x1c0 kernel/task_work.c:179
 resume_user_mode_work include/linux/resume_user_mode.h:49 [inline]
 exit_to_user_mode_loop kernel/entry/common.c:171 [inline]
 exit_to_user_mode_prepare+0x113/0x120 kernel/entry/common.c:203
 __syscall_exit_to_user_mode_work kernel/entry/common.c:285 [inline]
 syscall_exit_to_user_mode+0x21/0x50 kernel/entry/common.c:296
 do_syscall_64+0x4c/0x90 arch/x86/entry/common.c:86
 entry_SYSCALL_64_after_hwframe+0x72/0xdc

The buggy address belongs to the object at ffff888104617800
 which belongs to the cache kmalloc-1k of size 1024
The buggy address is located 680 bytes inside of
 1024-byte region [ffff888104617800, ffff888104617c00)

The buggy address belongs to the physical page:
page:00000000dbca6a80 refcount:1 mapcount:0 mapping:0000000000000000 index:0xffff888104614000 pfn:0x104614
head:00000000dbca6a80 order:2 compound_mapcount:0 subpages_mapcount:0 compound_pincount:0
flags: 0x200000000010200(slab|head|node=0|zone=2)
raw: 0200000000010200 ffff888100041dc0 ffffea0004212c10 ffffea0004234b10
raw: ffff888104614000 0000000000080002 00000001ffffffff 0000000000000000
page dumped because: kasan: bad access detected

Memory state around the buggy address:
 ffff888104617980: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 ffff888104617a00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
>ffff888104617a80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                  ^
 ffff888104617b00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 ffff888104617b80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
==================================================================

Ack: This bug is found by FuzzBT with a modified Syzkaller. Other
contributors are Ruoyu Wu and Hui Peng.
Signed-off-by: Sungwoo Kim <iam@sung-woo.kim>
Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
Signed-off-by: Jakub Kicinski <kuba@kernel.org>",1728137b33c00d5a2b5110ed7aafb42e7c32e4a1,https://github.com/torvalds/linux/commit/1728137b33c00d5a2b5110ed7aafb42e7c32e4a1,net/bluetooth/l2cap_sock.c,l2cap_sock_release,"static int l2cap_sock_release(struct socket *sock)
{
struct sock *sk = sock->sk;
int err;
struct l2cap_chan *chan;
BT_DBG(""sock %p, sk %p"", sock, sk);
if (!sk)
return 0;
bt_sock_unlink(&l2cap_sk_list, sk);
err = l2cap_sock_shutdown(sock, SHUT_RDWR);
chan = l2cap_pi(sk)->chan;
l2cap_chan_hold(chan);
l2cap_chan_lock(chan);
sock_orphan(sk);
l2cap_sock_kill(sk);
l2cap_chan_unlock(chan);
l2cap_chan_put(chan);
return err;
}","static int l2cap_sock_release(struct socket *VAR_0)
{
struct sock *VAR_1 = sock->sk;
int VAR_2;
struct l2cap_chan *VAR_3;
BT_DBG(""sock %p, sk %p"", sock, VAR_1);
if (!VAR_1)
return 0;
bt_sock_unlink(&VAR_4, VAR_1);
VAR_2 = l2cap_sock_shutdown(sock, VAR_5);
VAR_3 = l2cap_pi(VAR_1)->chan;
l2cap_chan_hold(VAR_3);
l2cap_chan_lock(VAR_3);
sock_orphan(VAR_1);
l2cap_sock_kill(VAR_1);
l2cap_chan_unlock(VAR_3);
l2cap_chan_put(VAR_3);
return VAR_2;
}",torvalds/linux/1728137b33c00d5a2b5110ed7aafb42e7c32e4a1/l2cap_sock.c/vul/before/0.json,"static int l2cap_sock_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	int err;
	struct l2cap_chan *chan;

	BT_DBG(""sock %p, sk %p"", sock, sk);

	if (!sk)
		return 0;

	l2cap_sock_cleanup_listen(sk);
	bt_sock_unlink(&l2cap_sk_list, sk);

	err = l2cap_sock_shutdown(sock, SHUT_RDWR);
	chan = l2cap_pi(sk)->chan;

	l2cap_chan_hold(chan);
	l2cap_chan_lock(chan);

	sock_orphan(sk);
	l2cap_sock_kill(sk);

	l2cap_chan_unlock(chan);
	l2cap_chan_put(chan);

	return err;
}","static int l2cap_sock_release(struct socket *VAR_0)
{
	struct sock *VAR_1 = sock->sk;
	int VAR_2;
	struct l2cap_chan *VAR_3;

	BT_DBG(""sock %p, sk %p"", sock, VAR_1);

	if (!VAR_1)
		return 0;

	l2cap_sock_cleanup_listen(VAR_1);
	bt_sock_unlink(&VAR_4, VAR_1);

	VAR_2 = l2cap_sock_shutdown(sock, VAR_5);
	VAR_3 = l2cap_pi(VAR_1)->chan;

	l2cap_chan_hold(VAR_3);
	l2cap_chan_lock(VAR_3);

	sock_orphan(VAR_1);
	l2cap_sock_kill(VAR_1);

	l2cap_chan_unlock(VAR_3);
	l2cap_chan_put(VAR_3);

	return VAR_2;
}",torvalds/linux/1728137b33c00d5a2b5110ed7aafb42e7c32e4a1/l2cap_sock.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,6 +9,7 @@
 	if (!sk)
 		return 0;
 
+	l2cap_sock_cleanup_listen(sk);
 	bt_sock_unlink(&l2cap_sk_list, sk);
 
 	err = l2cap_sock_shutdown(sock, SHUT_RDWR);","{'deleted_lines': [], 'added_lines': ['\tl2cap_sock_cleanup_listen(sk);']}",True,An issue was discovered in l2cap_sock_release in net/bluetooth/l2cap_sock.c in the Linux kernel before 6.4.10. There is a use-after-free because the children of an sk are mishandled.,7.8,HIGH,2,test,2023-05-31T05:39:56Z,4
CVE-2023-36664,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,ArtifexSoftware/ghostpdl,"Bug 706761: Don't ""reduce"" %pipe% file names for permission validation

For regular file names, we try to simplfy relative paths before we use them.

Because the %pipe% device can, effectively, accept command line calls, we
shouldn't be simplifying that string, because the command line syntax can end
up confusing the path simplifying code. That can result in permitting a pipe
command which does not match what was originally permitted.

Special case ""%pipe"" in the validation code so we always deal with the entire
string.",505eab7782b429017eb434b2b95120855f2b0e3c,https://github.com/ArtifexSoftware/ghostpdl/commit/505eab7782b429017eb434b2b95120855f2b0e3c,base/gpmisc.c,gp_validate_path_len,"int
gp_validate_path_len(const gs_memory_t *mem,
const char        *path,
const uint         len,
const char        *mode)
{
char *buffer, *bufferfull;
uint rlen;
int code = 0;
const char *cdirstr = gp_file_name_current();
int cdirstrl = strlen(cdirstr);
const char *dirsepstr = gp_file_name_separator();
int dirsepstrl = strlen(dirsepstr);
int prefix_len = cdirstrl + dirsepstrl;
if (mem->gs_lib_ctx == NULL ||
mem->gs_lib_ctx->core->path_control_active == 0)
return 0;
if (gp_file_name_is_absolute(path, len)) {
prefix_len = cdirstrl = dirsepstrl = 0;
}
else if (len > prefix_len && !memcmp(path, cdirstr, cdirstrl)
&& !memcmp(path + cdirstrl, dirsepstr, dirsepstrl)) {
prefix_len = 0;
}
rlen = len+1;
bufferfull = (char *)gs_alloc_bytes(mem->thread_safe_memory, rlen + prefix_len, ""gp_validate_path"");
if (bufferfull == NULL)
return gs_error_VMerror;
buffer = bufferfull + prefix_len;
if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
return gs_error_invalidfileaccess;
buffer[rlen] = 0;
while (1) {
switch (mode[0])
{
case 'r': 
code = validate(mem, buffer, gs_permit_file_reading);
break;
case 'w': 
code = validate(mem, buffer, gs_permit_file_writing);
break;
case 'a': 
code = (validate(mem, buffer, gs_permit_file_reading) |
validate(mem, buffer, gs_permit_file_writing));
break;
case 'c': 
code =  validate(mem, buffer, gs_permit_file_control);
break;
case 'd': 
code =  validate(mem, buffer, gs_permit_file_control);
break;
case 'f': 
code = (validate(mem, buffer, gs_permit_file_writing) |
validate(mem, buffer, gs_permit_file_control));
break;
case 't': 
code = (validate(mem, buffer, gs_permit_file_writing) |
validate(mem, buffer, gs_permit_file_control));
break;
default:
errprintf(mem, ""gp_validate_path: Unknown mode='%s'\n"", mode);
code = gs_note_error(gs_error_invalidfileaccess);
}
if (code < 0 && prefix_len > 0 && buffer > bufferfull) {
buffer = bufferfull;
memcpy(buffer, cdirstr, cdirstrl);
memcpy(buffer + cdirstrl, dirsepstr, dirsepstrl);
continue;
}
else if (code < 0 && cdirstrl > 0 && prefix_len == 0 && buffer == bufferfull) {
buffer = bufferfull + cdirstrl + dirsepstrl;
continue;
}
break;
}
if (code > 0 && (mode[0] == 'd' || mode[0] == 'f') &&
(code & gs_path_control_flag_is_scratch_file) != 0) {
(void)gs_remove_control_path_flags(mem, gs_permit_file_reading, buffer,
gs_path_control_flag_is_scratch_file);
(void)gs_remove_control_path_flags(mem, gs_permit_file_writing, buffer,
gs_path_control_flag_is_scratch_file);
(void)gs_remove_control_path_flags(mem, gs_permit_file_control, buffer,
gs_path_control_flag_is_scratch_file);
}
gs_free_object(mem->thread_safe_memory, bufferfull, ""gp_validate_path"");
#ifdef EACCES
if (code == gs_error_invalidfileaccess)
errno = EACCES;
#endif
return code < 0 ? code : 0;
}","int
gp_validate_path_len(const gs_memory_t *VAR_0,
const char        *VAR_1,
const uint         VAR_2,
const char        *VAR_3)
{
char *VAR_4, *VAR_5;
uint VAR_6;
int VAR_7 = 0;
const char *VAR_8 = gp_file_name_current();
int VAR_9 = strlen(VAR_8);
const char *VAR_10 = gp_file_name_separator();
int VAR_11 = strlen(VAR_10);
int VAR_12 = VAR_9 + VAR_11;
if (VAR_0->gs_lib_ctx == NULL ||
VAR_0->gs_lib_ctx->core->path_control_active == 0)
return 0;
if (gp_file_name_is_absolute(VAR_1, VAR_2)) {
VAR_12 = VAR_9 = VAR_11 = 0;
}
else if (VAR_2 > VAR_12 && !memcmp(VAR_1, VAR_8, VAR_9)
&& !memcmp(VAR_1 + VAR_9, VAR_10, VAR_11)) {
VAR_12 = 0;
}
VAR_6 = VAR_2+1;
VAR_5 = (char *)gs_alloc_bytes(VAR_0->thread_safe_memory, VAR_6 + VAR_12, ""gp_validate_path"");
if (VAR_5 == NULL)
return VAR_13;
VAR_4 = VAR_5 + VAR_12;
if (gp_file_name_reduce(VAR_1, (uint)VAR_2, VAR_4, &VAR_6) != VAR_14)
return VAR_15;
VAR_4[VAR_6] = 0;
while (1) {
switch (VAR_3[0])
{
case 'r': 
VAR_7 = validate(VAR_0, VAR_4, VAR_16);
break;
case 'w': 
VAR_7 = validate(VAR_0, VAR_4, VAR_17);
break;
case 'a': 
VAR_7 = (validate(VAR_0, VAR_4, VAR_16) |
validate(VAR_0, VAR_4, VAR_17));
break;
case 'c': 
VAR_7 =  validate(VAR_0, VAR_4, VAR_18);
break;
case 'd': 
VAR_7 =  validate(VAR_0, VAR_4, VAR_18);
break;
case 'f': 
VAR_7 = (validate(VAR_0, VAR_4, VAR_17) |
validate(VAR_0, VAR_4, VAR_18));
break;
case 't': 
VAR_7 = (validate(VAR_0, VAR_4, VAR_17) |
validate(VAR_0, VAR_4, VAR_18));
break;
default:
errprintf(VAR_0, ""gp_validate_path: Unknown mode='%s'\n"", VAR_3);
VAR_7 = gs_note_error(VAR_15);
}
if (VAR_7 < 0 && VAR_12 > 0 && VAR_4 > VAR_5) {
VAR_4 = VAR_5;
memcpy(VAR_4, VAR_8, VAR_9);
memcpy(VAR_4 + VAR_9, VAR_10, VAR_11);
continue;
}
else if (VAR_7 < 0 && VAR_9 > 0 && VAR_12 == 0 && VAR_4 == VAR_5) {
VAR_4 = VAR_5 + VAR_9 + VAR_11;
continue;
}
break;
}
if (VAR_7 > 0 && (VAR_3[0] == 'd' || VAR_3[0] == 'f') &&
(VAR_7 & VAR_19) != 0) {
(void)gs_remove_control_path_flags(VAR_0, VAR_16, VAR_4,
VAR_19);
(void)gs_remove_control_path_flags(VAR_0, VAR_17, VAR_4,
VAR_19);
(void)gs_remove_control_path_flags(VAR_0, VAR_18, VAR_4,
VAR_19);
}
gs_free_object(VAR_0->thread_safe_memory, VAR_5, ""gp_validate_path"");
#ifdef VAR_20
if (VAR_7 == VAR_15)
VAR_21 = VAR_20;
#endif
return VAR_7 < 0 ? VAR_7 : 0;
}",ArtifexSoftware/ghostpdl/505eab7782b429017eb434b2b95120855f2b0e3c/gpmisc.c/vul/before/0.json,"int
gp_validate_path_len(const gs_memory_t *mem,
                     const char        *path,
                     const uint         len,
                     const char        *mode)
{
    char *buffer, *bufferfull;
    uint rlen;
    int code = 0;
    const char *cdirstr = gp_file_name_current();
    int cdirstrl = strlen(cdirstr);
    const char *dirsepstr = gp_file_name_separator();
    int dirsepstrl = strlen(dirsepstr);
    int prefix_len = cdirstrl + dirsepstrl;

    /* mem->gs_lib_ctx can be NULL when we're called from mkromfs */
    if (mem->gs_lib_ctx == NULL ||
        mem->gs_lib_ctx->core->path_control_active == 0)
        return 0;

    /* For current directory accesses, we need handle both a ""bare"" name,
     * and one with a cwd prefix (in Unix terms, both ""myfile.ps"" and
     * ""./myfile.ps"".
     *
     * So we check up front if it's absolute, then just use that.
     * If it includes cwd prefix, we try that, then remove the prefix
     * and try again.
     * If it doesn't include the cwd prefix, we try it, then add the
     * prefix and try again.
     * To facilitate that, we allocate a large enough buffer to take
     * the path *and* the prefix up front.
     */
    if (gp_file_name_is_absolute(path, len)) {
       /* Absolute path, we don't need anything extra */
       prefix_len = cdirstrl = dirsepstrl = 0;
    }
    else if (len > prefix_len && !memcmp(path, cdirstr, cdirstrl)
             && !memcmp(path + cdirstrl, dirsepstr, dirsepstrl)) {
          prefix_len = 0;
    }

    /* ""%pipe%"" do not follow the normal rules for path definitions, so we
       don't ""reduce"" them to avoid unexpected results
     */
    if (len > 5 && memcmp(path, ""%pipe"", 5) != 0) {
        bufferfull = buffer = (char *)gs_alloc_bytes(mem->thread_safe_memory, len + 1, ""gp_validate_path"");
        if (buffer == NULL)
            return gs_error_VMerror;
        memcpy(buffer, path, len);
        buffer[len] = 0;
        rlen = len;
    }
    else {
        rlen = len+1;
        bufferfull = (char *)gs_alloc_bytes(mem->thread_safe_memory, rlen + prefix_len, ""gp_validate_path"");
        if (bufferfull == NULL)
            return gs_error_VMerror;

        buffer = bufferfull + prefix_len;
        if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
            return gs_error_invalidfileaccess;
        buffer[rlen] = 0;
    }
    while (1) {
        switch (mode[0])
        {
        case 'r': /* Read */
            code = validate(mem, buffer, gs_permit_file_reading);
            break;
        case 'w': /* Write */
            code = validate(mem, buffer, gs_permit_file_writing);
            break;
        case 'a': /* Append needs reading and writing */
            code = (validate(mem, buffer, gs_permit_file_reading) |
                    validate(mem, buffer, gs_permit_file_writing));
            break;
        case 'c': /* ""Control"" */
            code =  validate(mem, buffer, gs_permit_file_control);
            break;
        case 'd': /* ""Delete"" (special case of control) */
            code =  validate(mem, buffer, gs_permit_file_control);
            break;
        case 'f': /* ""Rename from"" */
            code = (validate(mem, buffer, gs_permit_file_writing) |
                    validate(mem, buffer, gs_permit_file_control));
            break;
        case 't': /* ""Rename to"" */
            code = (validate(mem, buffer, gs_permit_file_writing) |
                    validate(mem, buffer, gs_permit_file_control));
            break;
        default:
            errprintf(mem, ""gp_validate_path: Unknown mode='%s'\n"", mode);
            code = gs_note_error(gs_error_invalidfileaccess);
        }
        if (code < 0 && prefix_len > 0 && buffer > bufferfull) {
            buffer = bufferfull;
            memcpy(buffer, cdirstr, cdirstrl);
            memcpy(buffer + cdirstrl, dirsepstr, dirsepstrl);
            continue;
        }
        else if (code < 0 && cdirstrl > 0 && prefix_len == 0 && buffer == bufferfull) {
            buffer = bufferfull + cdirstrl + dirsepstrl;
            continue;
        }
        break;
    }
    if (code > 0 && (mode[0] == 'd' || mode[0] == 'f') &&
        (code & gs_path_control_flag_is_scratch_file) != 0) {
        (void)gs_remove_control_path_flags(mem, gs_permit_file_reading, buffer,
                                           gs_path_control_flag_is_scratch_file);
        (void)gs_remove_control_path_flags(mem, gs_permit_file_writing, buffer,
                                           gs_path_control_flag_is_scratch_file);
        (void)gs_remove_control_path_flags(mem, gs_permit_file_control, buffer,
                                           gs_path_control_flag_is_scratch_file);
    }

    gs_free_object(mem->thread_safe_memory, bufferfull, ""gp_validate_path"");
#ifdef EACCES
    if (code == gs_error_invalidfileaccess)
        errno = EACCES;
#endif

    return code < 0 ? code : 0;
}","int
gp_validate_path_len(const gs_memory_t *VAR_0,
                     const char        *VAR_1,
                     const uint         VAR_2,
                     const char        *VAR_3)
{
    char *VAR_4, *VAR_5;
    uint VAR_6;
    int VAR_7 = 0;
    const char *VAR_8 = gp_file_name_current();
    int VAR_9 = strlen(VAR_8);
    const char *VAR_10 = gp_file_name_separator();
    int VAR_11 = strlen(VAR_10);
    int VAR_12 = VAR_9 + VAR_11;

    /* COMMENT_0 */
    if (VAR_0->gs_lib_ctx == NULL ||
        VAR_0->gs_lib_ctx->core->path_control_active == 0)
        return 0;

    /* COMMENT_1 */
                                                                     
                     
      
                                                                 
                                                                     
                     
                                                                    
                            
                                                                    
                                          
       
    if (gp_file_name_is_absolute(VAR_1, VAR_2)) {
       /* COMMENT_13 */
       VAR_12 = VAR_9 = VAR_11 = 0;
    }
    else if (VAR_2 > VAR_12 && !memcmp(VAR_1, VAR_8, VAR_9)
             && !memcmp(VAR_1 + VAR_9, VAR_10, VAR_11)) {
          VAR_12 = 0;
    }

    /* COMMENT_14 */
                                                      
       
    if (VAR_2 > 5 && memcmp(VAR_1, ""%pipe"", 5) != 0) {
        VAR_5 = VAR_4 = (char *)gs_alloc_bytes(VAR_0->thread_safe_memory, VAR_2 + 1, ""gp_validate_path"");
        if (VAR_4 == NULL)
            return VAR_13;
        memcpy(VAR_4, VAR_1, VAR_2);
        VAR_4[VAR_2] = 0;
        VAR_6 = VAR_2;
    }
    else {
        VAR_6 = VAR_2+1;
        VAR_5 = (char *)gs_alloc_bytes(VAR_0->thread_safe_memory, VAR_6 + VAR_12, ""gp_validate_path"");
        if (VAR_5 == NULL)
            return VAR_13;

        VAR_4 = VAR_5 + VAR_12;
        if (gp_file_name_reduce(VAR_1, (uint)VAR_2, VAR_4, &VAR_6) != VAR_14)
            return VAR_15;
        VAR_4[VAR_6] = 0;
    }
    while (1) {
        switch (VAR_3[0])
        {
        case 'r': /* COMMENT_17 */
            VAR_7 = validate(VAR_0, VAR_4, VAR_16);
            break;
        case 'w': /* COMMENT_18 */
            VAR_7 = validate(VAR_0, VAR_4, VAR_17);
            break;
        case 'a': /* COMMENT_19 */
            VAR_7 = (validate(VAR_0, VAR_4, VAR_16) |
                    validate(VAR_0, VAR_4, VAR_17));
            break;
        case 'c': /* COMMENT_20 */
            VAR_7 =  validate(VAR_0, VAR_4, VAR_18);
            break;
        case 'd': /* COMMENT_21 */
            VAR_7 =  validate(VAR_0, VAR_4, VAR_18);
            break;
        case 'f': /* COMMENT_22 */
            VAR_7 = (validate(VAR_0, VAR_4, VAR_17) |
                    validate(VAR_0, VAR_4, VAR_18));
            break;
        case 't': /* COMMENT_23 */
            VAR_7 = (validate(VAR_0, VAR_4, VAR_17) |
                    validate(VAR_0, VAR_4, VAR_18));
            break;
        default:
            errprintf(VAR_0, ""gp_validate_path: Unknown mode='%s'\n"", VAR_3);
            VAR_7 = gs_note_error(VAR_15);
        }
        if (VAR_7 < 0 && VAR_12 > 0 && VAR_4 > VAR_5) {
            VAR_4 = VAR_5;
            memcpy(VAR_4, VAR_8, VAR_9);
            memcpy(VAR_4 + VAR_9, VAR_10, VAR_11);
            continue;
        }
        else if (VAR_7 < 0 && VAR_9 > 0 && VAR_12 == 0 && VAR_4 == VAR_5) {
            VAR_4 = VAR_5 + VAR_9 + VAR_11;
            continue;
        }
        break;
    }
    if (VAR_7 > 0 && (VAR_3[0] == 'd' || VAR_3[0] == 'f') &&
        (VAR_7 & VAR_19) != 0) {
        (void)gs_remove_control_path_flags(VAR_0, VAR_16, VAR_4,
                                           VAR_19);
        (void)gs_remove_control_path_flags(VAR_0, VAR_17, VAR_4,
                                           VAR_19);
        (void)gs_remove_control_path_flags(VAR_0, VAR_18, VAR_4,
                                           VAR_19);
    }

    gs_free_object(VAR_0->thread_safe_memory, VAR_5, ""gp_validate_path"");
#ifdef VAR_20
    if (VAR_7 == VAR_15)
        VAR_21 = VAR_20;
#endif

    return VAR_7 < 0 ? VAR_7 : 0;
}",ArtifexSoftware/ghostpdl/505eab7782b429017eb434b2b95120855f2b0e3c/gpmisc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -38,16 +38,29 @@
              && !memcmp(path + cdirstrl, dirsepstr, dirsepstrl)) {
           prefix_len = 0;
     }
-    rlen = len+1;
-    bufferfull = (char *)gs_alloc_bytes(mem->thread_safe_memory, rlen + prefix_len, ""gp_validate_path"");
-    if (bufferfull == NULL)
-        return gs_error_VMerror;
 
-    buffer = bufferfull + prefix_len;
-    if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
-        return gs_error_invalidfileaccess;
-    buffer[rlen] = 0;
+    /* ""%pipe%"" do not follow the normal rules for path definitions, so we
+       don't ""reduce"" them to avoid unexpected results
+     */
+    if (len > 5 && memcmp(path, ""%pipe"", 5) != 0) {
+        bufferfull = buffer = (char *)gs_alloc_bytes(mem->thread_safe_memory, len + 1, ""gp_validate_path"");
+        if (buffer == NULL)
+            return gs_error_VMerror;
+        memcpy(buffer, path, len);
+        buffer[len] = 0;
+        rlen = len;
+    }
+    else {
+        rlen = len+1;
+        bufferfull = (char *)gs_alloc_bytes(mem->thread_safe_memory, rlen + prefix_len, ""gp_validate_path"");
+        if (bufferfull == NULL)
+            return gs_error_VMerror;
 
+        buffer = bufferfull + prefix_len;
+        if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
+            return gs_error_invalidfileaccess;
+        buffer[rlen] = 0;
+    }
     while (1) {
         switch (mode[0])
         {","{'deleted_lines': ['    rlen = len+1;', '    bufferfull = (char *)gs_alloc_bytes(mem->thread_safe_memory, rlen + prefix_len, ""gp_validate_path"");', '    if (bufferfull == NULL)', '        return gs_error_VMerror;', '    buffer = bufferfull + prefix_len;', '    if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)', '        return gs_error_invalidfileaccess;', '    buffer[rlen] = 0;'], 'added_lines': ['    /* ""%pipe%"" do not follow the normal rules for path definitions, so we', '       don\'t ""reduce"" them to avoid unexpected results', '     */', '    if (len > 5 && memcmp(path, ""%pipe"", 5) != 0) {', '        bufferfull = buffer = (char *)gs_alloc_bytes(mem->thread_safe_memory, len + 1, ""gp_validate_path"");', '        if (buffer == NULL)', '            return gs_error_VMerror;', '        memcpy(buffer, path, len);', '        buffer[len] = 0;', '        rlen = len;', '    }', '    else {', '        rlen = len+1;', '        bufferfull = (char *)gs_alloc_bytes(mem->thread_safe_memory, rlen + prefix_len, ""gp_validate_path"");', '        if (bufferfull == NULL)', '            return gs_error_VMerror;', '        buffer = bufferfull + prefix_len;', '        if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)', '            return gs_error_invalidfileaccess;', '        buffer[rlen] = 0;', '    }']}",True,Artifex Ghostscript through 10.01.2 mishandles permission validation for pipe devices (with the %pipe% prefix or the | pipe character prefix).,7.8,HIGH,2,test,2023-06-07T09:23:06Z,4
CVE-2023-36664,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,ArtifexSoftware/ghostpdl,"Bug 706761: Don't ""reduce"" %pipe% file names for permission validation

For regular file names, we try to simplfy relative paths before we use them.

Because the %pipe% device can, effectively, accept command line calls, we
shouldn't be simplifying that string, because the command line syntax can end
up confusing the path simplifying code. That can result in permitting a pipe
command which does not match what was originally permitted.

Special case ""%pipe"" in the validation code so we always deal with the entire
string.",505eab7782b429017eb434b2b95120855f2b0e3c,https://github.com/ArtifexSoftware/ghostpdl/commit/505eab7782b429017eb434b2b95120855f2b0e3c,base/gslibctx.c,gs_add_control_path_len_flags,"int
gs_add_control_path_len_flags(const gs_memory_t *mem, gs_path_control_t type, const char *path, size_t len, int flags)
{
gs_path_control_set_t *control;
unsigned int n, i;
gs_lib_ctx_core_t *core;
char *buffer;
uint rlen;
if (path == NULL || len == 0)
return 0;
if (mem == NULL || mem->gs_lib_ctx == NULL ||
(core = mem->gs_lib_ctx->core) == NULL)
return gs_error_unknownerror;
switch(type) {
case gs_permit_file_reading:
control = &core->permit_reading;
break;
case gs_permit_file_writing:
control = &core->permit_writing;
break;
case gs_permit_file_control:
control = &core->permit_control;
break;
default:
return gs_error_rangecheck;
}
rlen = len+1;
buffer = (char *)gs_alloc_bytes(core->memory, rlen, ""gp_validate_path"");
if (buffer == NULL)
return gs_error_VMerror;
if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
return gs_error_invalidfileaccess;
buffer[rlen] = 0;
n = control->num;
for (i = 0; i < n; i++)
{
if (strncmp(control->entry[i].path, buffer, rlen) == 0 &&
control->entry[i].path[rlen] == 0) {
gs_free_object(core->memory, buffer, ""gs_add_control_path_len"");
return 0; 
}
}
if (control->num == control->max) {
gs_path_control_entry_t *p;
n = control->max * 2;
if (n == 0) {
n = 4;
p = (gs_path_control_entry_t *)gs_alloc_bytes(core->memory, sizeof(*p)*n, ""gs_lib_ctx(entries)"");
} else
p = (gs_path_control_entry_t *)gs_resize_object(core->memory, control->entry, sizeof(*p)*n, ""gs_lib_ctx(entries)"");
if (p == NULL) {
gs_free_object(core->memory, buffer, ""gs_add_control_path_len"");
return gs_error_VMerror;
}
control->entry = p;
control->max = n;
}
n = control->num;
control->entry[n].path = buffer;
control->entry[n].path[len] = 0;
control->entry[n].flags = flags;
control->num++;
return 0;
}","int
gs_add_control_path_len_flags(const gs_memory_t *VAR_0, gs_path_control_t VAR_1, const char *VAR_2, size_t VAR_3, int VAR_4)
{
gs_path_control_set_t *VAR_5;
unsigned int VAR_6, VAR_7;
gs_lib_ctx_core_t *VAR_8;
char *VAR_9;
uint VAR_10;
if (VAR_2 == NULL || VAR_3 == 0)
return 0;
if (VAR_0 == NULL || VAR_0->gs_lib_ctx == NULL ||
(VAR_8 = VAR_0->gs_lib_ctx->core) == NULL)
return VAR_11;
switch(VAR_1) {
case VAR_12:
VAR_5 = &VAR_8->permit_reading;
break;
case VAR_13:
VAR_5 = &VAR_8->permit_writing;
break;
case VAR_14:
VAR_5 = &VAR_8->permit_control;
break;
default:
return VAR_15;
}
VAR_10 = VAR_3+1;
VAR_9 = (char *)gs_alloc_bytes(VAR_8->memory, VAR_10, ""gp_validate_path"");
if (VAR_9 == NULL)
return VAR_16;
if (gp_file_name_reduce(VAR_2, (uint)VAR_3, VAR_9, &VAR_10) != VAR_17)
return VAR_18;
VAR_9[VAR_10] = 0;
VAR_6 = VAR_5->num;
for (VAR_7 = 0; VAR_7 < VAR_6; VAR_7++)
{
if (strncmp(VAR_5->entry[VAR_7].path, VAR_9, VAR_10) == 0 &&
VAR_5->entry[VAR_7].path[VAR_10] == 0) {
gs_free_object(VAR_8->memory, VAR_9, ""gs_add_control_path_len"");
return 0; 
}
}
if (VAR_5->num == VAR_5->max) {
gs_path_control_entry_t *VAR_19;
VAR_6 = VAR_5->max * 2;
if (VAR_6 == 0) {
VAR_6 = 4;
VAR_19 = (gs_path_control_entry_t *)gs_alloc_bytes(VAR_8->memory, sizeof(*VAR_19)*VAR_6, ""gs_lib_ctx(entries)"");
} else
VAR_19 = (gs_path_control_entry_t *)gs_resize_object(VAR_8->memory, VAR_5->entry, sizeof(*VAR_19)*VAR_6, ""gs_lib_ctx(entries)"");
if (VAR_19 == NULL) {
gs_free_object(VAR_8->memory, VAR_9, ""gs_add_control_path_len"");
return VAR_16;
}
VAR_5->entry = VAR_19;
VAR_5->max = VAR_6;
}
VAR_6 = VAR_5->num;
VAR_5->entry[VAR_6].path = VAR_9;
VAR_5->entry[VAR_6].path[VAR_3] = 0;
VAR_5->entry[VAR_6].flags = VAR_4;
VAR_5->num++;
return 0;
}",ArtifexSoftware/ghostpdl/505eab7782b429017eb434b2b95120855f2b0e3c/gslibctx.c/vul/before/1.json,"int
gs_add_control_path_len_flags(const gs_memory_t *mem, gs_path_control_t type, const char *path, size_t len, int flags)
{
    gs_path_control_set_t *control;
    unsigned int n, i;
    gs_lib_ctx_core_t *core;
    char *buffer;
    uint rlen;

    if (path == NULL || len == 0)
        return 0;

    if (mem == NULL || mem->gs_lib_ctx == NULL ||
        (core = mem->gs_lib_ctx->core) == NULL)
        return gs_error_unknownerror;

    switch(type) {
        case gs_permit_file_reading:
            control = &core->permit_reading;
            break;
        case gs_permit_file_writing:
            control = &core->permit_writing;
            break;
        case gs_permit_file_control:
            control = &core->permit_control;
            break;
        default:
            return gs_error_rangecheck;
    }

    /* ""%pipe%"" do not follow the normal rules for path definitions, so we
       don't ""reduce"" them to avoid unexpected results
     */
    if (len > 5 && memcmp(path, ""%pipe"", 5) != 0) {
        buffer = (char *)gs_alloc_bytes(core->memory, len + 1, ""gs_add_control_path_len"");
        if (buffer == NULL)
            return gs_error_VMerror;
        memcpy(buffer, path, len);
        buffer[len] = 0;
        rlen = len;
    }
    else {
        rlen = len + 1;

        buffer = (char *)gs_alloc_bytes(core->memory, rlen, ""gs_add_control_path_len"");
        if (buffer == NULL)
            return gs_error_VMerror;

        if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
            return gs_error_invalidfileaccess;
        buffer[rlen] = 0;
    }

    n = control->num;
    for (i = 0; i < n; i++)
    {
        if (strncmp(control->entry[i].path, buffer, rlen) == 0 &&
            control->entry[i].path[rlen] == 0) {
            gs_free_object(core->memory, buffer, ""gs_add_control_path_len"");
            return 0; /* Already there! */
        }
    }

    if (control->num == control->max) {
        gs_path_control_entry_t *p;

        n = control->max * 2;
        if (n == 0) {
            n = 4;
            p = (gs_path_control_entry_t *)gs_alloc_bytes(core->memory, sizeof(*p)*n, ""gs_lib_ctx(entries)"");
        } else
            p = (gs_path_control_entry_t *)gs_resize_object(core->memory, control->entry, sizeof(*p)*n, ""gs_lib_ctx(entries)"");
        if (p == NULL) {
            gs_free_object(core->memory, buffer, ""gs_add_control_path_len"");
            return gs_error_VMerror;
        }
        control->entry = p;
        control->max = n;
    }

    n = control->num;
    control->entry[n].path = buffer;
    control->entry[n].path[len] = 0;
    control->entry[n].flags = flags;
    control->num++;

    return 0;
}","int
gs_add_control_path_len_flags(const gs_memory_t *VAR_0, gs_path_control_t VAR_1, const char *VAR_2, size_t VAR_3, int VAR_4)
{
    gs_path_control_set_t *VAR_5;
    unsigned int VAR_6, VAR_7;
    gs_lib_ctx_core_t *VAR_8;
    char *VAR_9;
    uint VAR_10;

    if (VAR_2 == NULL || VAR_3 == 0)
        return 0;

    if (VAR_0 == NULL || VAR_0->gs_lib_ctx == NULL ||
        (VAR_8 = VAR_0->gs_lib_ctx->core) == NULL)
        return VAR_11;

    switch(VAR_1) {
        case VAR_12:
            VAR_5 = &VAR_8->permit_reading;
            break;
        case VAR_13:
            VAR_5 = &VAR_8->permit_writing;
            break;
        case VAR_14:
            VAR_5 = &VAR_8->permit_control;
            break;
        default:
            return VAR_15;
    }

    /* COMMENT_0 */
                                                      
       
    if (VAR_3 > 5 && memcmp(VAR_2, ""%pipe"", 5) != 0) {
        VAR_9 = (char *)gs_alloc_bytes(VAR_8->memory, VAR_3 + 1, ""gs_add_control_path_len"");
        if (VAR_9 == NULL)
            return VAR_16;
        memcpy(VAR_9, VAR_2, VAR_3);
        VAR_9[VAR_3] = 0;
        VAR_10 = VAR_3;
    }
    else {
        VAR_10 = VAR_3 + 1;

        VAR_9 = (char *)gs_alloc_bytes(VAR_8->memory, VAR_10, ""gs_add_control_path_len"");
        if (VAR_9 == NULL)
            return VAR_16;

        if (gp_file_name_reduce(VAR_2, (uint)VAR_3, VAR_9, &VAR_10) != VAR_17)
            return VAR_18;
        VAR_9[VAR_10] = 0;
    }

    VAR_6 = VAR_5->num;
    for (VAR_7 = 0; VAR_7 < VAR_6; VAR_7++)
    {
        if (strncmp(VAR_5->entry[VAR_7].path, VAR_9, VAR_10) == 0 &&
            VAR_5->entry[VAR_7].path[VAR_10] == 0) {
            gs_free_object(VAR_8->memory, VAR_9, ""gs_add_control_path_len"");
            return 0; /* COMMENT_3 */
        }
    }

    if (VAR_5->num == VAR_5->max) {
        gs_path_control_entry_t *VAR_19;

        VAR_6 = VAR_5->max * 2;
        if (VAR_6 == 0) {
            VAR_6 = 4;
            VAR_19 = (gs_path_control_entry_t *)gs_alloc_bytes(VAR_8->memory, sizeof(*VAR_19)*VAR_6, ""gs_lib_ctx(entries)"");
        } else
            VAR_19 = (gs_path_control_entry_t *)gs_resize_object(VAR_8->memory, VAR_5->entry, sizeof(*VAR_19)*VAR_6, ""gs_lib_ctx(entries)"");
        if (VAR_19 == NULL) {
            gs_free_object(VAR_8->memory, VAR_9, ""gs_add_control_path_len"");
            return VAR_16;
        }
        VAR_5->entry = VAR_19;
        VAR_5->max = VAR_6;
    }

    VAR_6 = VAR_5->num;
    VAR_5->entry[VAR_6].path = VAR_9;
    VAR_5->entry[VAR_6].path[VAR_3] = 0;
    VAR_5->entry[VAR_6].flags = VAR_4;
    VAR_5->num++;

    return 0;
}",ArtifexSoftware/ghostpdl/505eab7782b429017eb434b2b95120855f2b0e3c/gslibctx.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -28,14 +28,28 @@
             return gs_error_rangecheck;
     }
 
-    rlen = len+1;
-    buffer = (char *)gs_alloc_bytes(core->memory, rlen, ""gp_validate_path"");
-    if (buffer == NULL)
-        return gs_error_VMerror;
+    /* ""%pipe%"" do not follow the normal rules for path definitions, so we
+       don't ""reduce"" them to avoid unexpected results
+     */
+    if (len > 5 && memcmp(path, ""%pipe"", 5) != 0) {
+        buffer = (char *)gs_alloc_bytes(core->memory, len + 1, ""gs_add_control_path_len"");
+        if (buffer == NULL)
+            return gs_error_VMerror;
+        memcpy(buffer, path, len);
+        buffer[len] = 0;
+        rlen = len;
+    }
+    else {
+        rlen = len + 1;
 
-    if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
-        return gs_error_invalidfileaccess;
-    buffer[rlen] = 0;
+        buffer = (char *)gs_alloc_bytes(core->memory, rlen, ""gs_add_control_path_len"");
+        if (buffer == NULL)
+            return gs_error_VMerror;
+
+        if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
+            return gs_error_invalidfileaccess;
+        buffer[rlen] = 0;
+    }
 
     n = control->num;
     for (i = 0; i < n; i++)","{'deleted_lines': ['    rlen = len+1;', '    buffer = (char *)gs_alloc_bytes(core->memory, rlen, ""gp_validate_path"");', '    if (buffer == NULL)', '        return gs_error_VMerror;', '    if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)', '        return gs_error_invalidfileaccess;', '    buffer[rlen] = 0;'], 'added_lines': ['    /* ""%pipe%"" do not follow the normal rules for path definitions, so we', '       don\'t ""reduce"" them to avoid unexpected results', '     */', '    if (len > 5 && memcmp(path, ""%pipe"", 5) != 0) {', '        buffer = (char *)gs_alloc_bytes(core->memory, len + 1, ""gs_add_control_path_len"");', '        if (buffer == NULL)', '            return gs_error_VMerror;', '        memcpy(buffer, path, len);', '        buffer[len] = 0;', '        rlen = len;', '    }', '    else {', '        rlen = len + 1;', '        buffer = (char *)gs_alloc_bytes(core->memory, rlen, ""gs_add_control_path_len"");', '        if (buffer == NULL)', '            return gs_error_VMerror;', '', '        if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)', '            return gs_error_invalidfileaccess;', '        buffer[rlen] = 0;', '    }']}",True,Artifex Ghostscript through 10.01.2 mishandles permission validation for pipe devices (with the %pipe% prefix or the | pipe character prefix).,7.8,HIGH,2,test,2023-06-07T09:23:06Z,4
CVE-2023-36664,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,ArtifexSoftware/ghostpdl,"Bug 706761: Don't ""reduce"" %pipe% file names for permission validation

For regular file names, we try to simplfy relative paths before we use them.

Because the %pipe% device can, effectively, accept command line calls, we
shouldn't be simplifying that string, because the command line syntax can end
up confusing the path simplifying code. That can result in permitting a pipe
command which does not match what was originally permitted.

Special case ""%pipe"" in the validation code so we always deal with the entire
string.",505eab7782b429017eb434b2b95120855f2b0e3c,https://github.com/ArtifexSoftware/ghostpdl/commit/505eab7782b429017eb434b2b95120855f2b0e3c,base/gslibctx.c,gs_remove_control_path_len_flags,"int
gs_remove_control_path_len_flags(const gs_memory_t *mem, gs_path_control_t type, const char *path, size_t len, int flags)
{
gs_path_control_set_t *control;
unsigned int n, i;
gs_lib_ctx_core_t *core;
char *buffer;
uint rlen;
if (path == NULL || len == 0)
return 0;
if (mem == NULL || mem->gs_lib_ctx == NULL ||
(core = mem->gs_lib_ctx->core) == NULL)
return gs_error_unknownerror;
switch(type) {
case gs_permit_file_reading:
control = &core->permit_reading;
break;
case gs_permit_file_writing:
control = &core->permit_writing;
break;
case gs_permit_file_control:
control = &core->permit_control;
break;
default:
return gs_error_rangecheck;
}
rlen = len+1;
buffer = (char *)gs_alloc_bytes(core->memory, rlen, ""gp_validate_path"");
if (buffer == NULL)
return gs_error_VMerror;
if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
return gs_error_invalidfileaccess;
buffer[rlen] = 0;
n = control->num;
for (i = 0; i < n; i++) {
if (control->entry[i].flags == flags &&
strncmp(control->entry[i].path, buffer, len) == 0 &&
control->entry[i].path[len] == 0)
break;
}
gs_free_object(core->memory, buffer, ""gs_remove_control_path_len"");
if (i == n)
return 0;
gs_free_object(core->memory, control->entry[i].path, ""gs_lib_ctx(path)"");
for (;i < n-1; i++)
control->entry[i] = control->entry[i+1];
control->num = n-1;
return 0;
}","int
gs_remove_control_path_len_flags(const gs_memory_t *VAR_0, gs_path_control_t VAR_1, const char *VAR_2, size_t VAR_3, int VAR_4)
{
gs_path_control_set_t *VAR_5;
unsigned int VAR_6, VAR_7;
gs_lib_ctx_core_t *VAR_8;
char *VAR_9;
uint VAR_10;
if (VAR_2 == NULL || VAR_3 == 0)
return 0;
if (VAR_0 == NULL || VAR_0->gs_lib_ctx == NULL ||
(VAR_8 = VAR_0->gs_lib_ctx->core) == NULL)
return VAR_11;
switch(VAR_1) {
case VAR_12:
VAR_5 = &VAR_8->permit_reading;
break;
case VAR_13:
VAR_5 = &VAR_8->permit_writing;
break;
case VAR_14:
VAR_5 = &VAR_8->permit_control;
break;
default:
return VAR_15;
}
VAR_10 = VAR_3+1;
VAR_9 = (char *)gs_alloc_bytes(VAR_8->memory, VAR_10, ""gp_validate_path"");
if (VAR_9 == NULL)
return VAR_16;
if (gp_file_name_reduce(VAR_2, (uint)VAR_3, VAR_9, &VAR_10) != VAR_17)
return VAR_18;
VAR_9[VAR_10] = 0;
VAR_6 = VAR_5->num;
for (VAR_7 = 0; VAR_7 < VAR_6; VAR_7++) {
if (VAR_5->entry[VAR_7].flags == VAR_4 &&
strncmp(VAR_5->entry[VAR_7].path, VAR_9, VAR_3) == 0 &&
VAR_5->entry[VAR_7].path[VAR_3] == 0)
break;
}
gs_free_object(VAR_8->memory, VAR_9, ""gs_remove_control_path_len"");
if (VAR_7 == VAR_6)
return 0;
gs_free_object(VAR_8->memory, VAR_5->entry[VAR_7].path, ""gs_lib_ctx(path)"");
for (;VAR_7 < VAR_6-1; VAR_7++)
VAR_5->entry[VAR_7] = VAR_5->entry[VAR_7+1];
VAR_5->num = VAR_6-1;
return 0;
}",ArtifexSoftware/ghostpdl/505eab7782b429017eb434b2b95120855f2b0e3c/gslibctx.c/vul/before/0.json,"int
gs_remove_control_path_len_flags(const gs_memory_t *mem, gs_path_control_t type, const char *path, size_t len, int flags)
{
    gs_path_control_set_t *control;
    unsigned int n, i;
    gs_lib_ctx_core_t *core;
    char *buffer;
    uint rlen;

    if (path == NULL || len == 0)
        return 0;

    if (mem == NULL || mem->gs_lib_ctx == NULL ||
        (core = mem->gs_lib_ctx->core) == NULL)
        return gs_error_unknownerror;

    switch(type) {
        case gs_permit_file_reading:
            control = &core->permit_reading;
            break;
        case gs_permit_file_writing:
            control = &core->permit_writing;
            break;
        case gs_permit_file_control:
            control = &core->permit_control;
            break;
        default:
            return gs_error_rangecheck;
    }

    /* ""%pipe%"" do not follow the normal rules for path definitions, so we
       don't ""reduce"" them to avoid unexpected results
     */
    if (len > 5 && memcmp(path, ""%pipe"", 5) != 0) {
        buffer = (char *)gs_alloc_bytes(core->memory, len + 1, ""gs_remove_control_path_len"");
        if (buffer == NULL)
            return gs_error_VMerror;
        memcpy(buffer, path, len);
        buffer[len] = 0;
        rlen = len;
    }
    else {
        rlen = len+1;

        buffer = (char *)gs_alloc_bytes(core->memory, rlen, ""gs_remove_control_path_len"");
        if (buffer == NULL)
            return gs_error_VMerror;

        if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
            return gs_error_invalidfileaccess;
        buffer[rlen] = 0;
    }

    n = control->num;
    for (i = 0; i < n; i++) {
        if (control->entry[i].flags == flags &&
            strncmp(control->entry[i].path, buffer, len) == 0 &&
            control->entry[i].path[len] == 0)
            break;
    }
    gs_free_object(core->memory, buffer, ""gs_remove_control_path_len"");
    if (i == n)
        return 0;

    gs_free_object(core->memory, control->entry[i].path, ""gs_lib_ctx(path)"");
    for (;i < n-1; i++)
        control->entry[i] = control->entry[i+1];
    control->num = n-1;

    return 0;
}","int
gs_remove_control_path_len_flags(const gs_memory_t *VAR_0, gs_path_control_t VAR_1, const char *VAR_2, size_t VAR_3, int VAR_4)
{
    gs_path_control_set_t *VAR_5;
    unsigned int VAR_6, VAR_7;
    gs_lib_ctx_core_t *VAR_8;
    char *VAR_9;
    uint VAR_10;

    if (VAR_2 == NULL || VAR_3 == 0)
        return 0;

    if (VAR_0 == NULL || VAR_0->gs_lib_ctx == NULL ||
        (VAR_8 = VAR_0->gs_lib_ctx->core) == NULL)
        return VAR_11;

    switch(VAR_1) {
        case VAR_12:
            VAR_5 = &VAR_8->permit_reading;
            break;
        case VAR_13:
            VAR_5 = &VAR_8->permit_writing;
            break;
        case VAR_14:
            VAR_5 = &VAR_8->permit_control;
            break;
        default:
            return VAR_15;
    }

    /* COMMENT_0 */
                                                      
       
    if (VAR_3 > 5 && memcmp(VAR_2, ""%pipe"", 5) != 0) {
        VAR_9 = (char *)gs_alloc_bytes(VAR_8->memory, VAR_3 + 1, ""gs_remove_control_path_len"");
        if (VAR_9 == NULL)
            return VAR_16;
        memcpy(VAR_9, VAR_2, VAR_3);
        VAR_9[VAR_3] = 0;
        VAR_10 = VAR_3;
    }
    else {
        VAR_10 = VAR_3+1;

        VAR_9 = (char *)gs_alloc_bytes(VAR_8->memory, VAR_10, ""gs_remove_control_path_len"");
        if (VAR_9 == NULL)
            return VAR_16;

        if (gp_file_name_reduce(VAR_2, (uint)VAR_3, VAR_9, &VAR_10) != VAR_17)
            return VAR_18;
        VAR_9[VAR_10] = 0;
    }

    VAR_6 = VAR_5->num;
    for (VAR_7 = 0; VAR_7 < VAR_6; VAR_7++) {
        if (VAR_5->entry[VAR_7].flags == VAR_4 &&
            strncmp(VAR_5->entry[VAR_7].path, VAR_9, VAR_3) == 0 &&
            VAR_5->entry[VAR_7].path[VAR_3] == 0)
            break;
    }
    gs_free_object(VAR_8->memory, VAR_9, ""gs_remove_control_path_len"");
    if (VAR_7 == VAR_6)
        return 0;

    gs_free_object(VAR_8->memory, VAR_5->entry[VAR_7].path, ""gs_lib_ctx(path)"");
    for (;VAR_7 < VAR_6-1; VAR_7++)
        VAR_5->entry[VAR_7] = VAR_5->entry[VAR_7+1];
    VAR_5->num = VAR_6-1;

    return 0;
}",ArtifexSoftware/ghostpdl/505eab7782b429017eb434b2b95120855f2b0e3c/gslibctx.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -28,14 +28,28 @@
             return gs_error_rangecheck;
     }
 
-    rlen = len+1;
-    buffer = (char *)gs_alloc_bytes(core->memory, rlen, ""gp_validate_path"");
-    if (buffer == NULL)
-        return gs_error_VMerror;
+    /* ""%pipe%"" do not follow the normal rules for path definitions, so we
+       don't ""reduce"" them to avoid unexpected results
+     */
+    if (len > 5 && memcmp(path, ""%pipe"", 5) != 0) {
+        buffer = (char *)gs_alloc_bytes(core->memory, len + 1, ""gs_remove_control_path_len"");
+        if (buffer == NULL)
+            return gs_error_VMerror;
+        memcpy(buffer, path, len);
+        buffer[len] = 0;
+        rlen = len;
+    }
+    else {
+        rlen = len+1;
 
-    if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
-        return gs_error_invalidfileaccess;
-    buffer[rlen] = 0;
+        buffer = (char *)gs_alloc_bytes(core->memory, rlen, ""gs_remove_control_path_len"");
+        if (buffer == NULL)
+            return gs_error_VMerror;
+
+        if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
+            return gs_error_invalidfileaccess;
+        buffer[rlen] = 0;
+    }
 
     n = control->num;
     for (i = 0; i < n; i++) {","{'deleted_lines': ['    rlen = len+1;', '    buffer = (char *)gs_alloc_bytes(core->memory, rlen, ""gp_validate_path"");', '    if (buffer == NULL)', '        return gs_error_VMerror;', '    if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)', '        return gs_error_invalidfileaccess;', '    buffer[rlen] = 0;'], 'added_lines': ['    /* ""%pipe%"" do not follow the normal rules for path definitions, so we', '       don\'t ""reduce"" them to avoid unexpected results', '     */', '    if (len > 5 && memcmp(path, ""%pipe"", 5) != 0) {', '        buffer = (char *)gs_alloc_bytes(core->memory, len + 1, ""gs_remove_control_path_len"");', '        if (buffer == NULL)', '            return gs_error_VMerror;', '        memcpy(buffer, path, len);', '        buffer[len] = 0;', '        rlen = len;', '    }', '    else {', '        rlen = len+1;', '        buffer = (char *)gs_alloc_bytes(core->memory, rlen, ""gs_remove_control_path_len"");', '        if (buffer == NULL)', '            return gs_error_VMerror;', '', '        if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)', '            return gs_error_invalidfileaccess;', '        buffer[rlen] = 0;', '    }']}",True,Artifex Ghostscript through 10.01.2 mishandles permission validation for pipe devices (with the %pipe% prefix or the | pipe character prefix).,7.8,HIGH,2,test,2023-06-07T09:23:06Z,4
CVE-2023-28366,['CWE-401'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,eclipse/mosquitto,Fix for CVE-2023-28366,6113eac95a9df634fbc858be542c4a0456bfe7b9,https://github.com/eclipse/mosquitto/commit/6113eac95a9df634fbc858be542c4a0456bfe7b9,src/database.c,db__message_insert,"int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)
{
struct mosquitto_client_msg *msg;
struct mosquitto_msg_data *msg_data;
enum mosquitto_msg_state state = mosq_ms_invalid;
int rc = 0;
int i;
char **dest_ids;
assert(stored);
if(!context) return MOSQ_ERR_INVAL;
if(!context->id) return MOSQ_ERR_SUCCESS; 
if(dir == mosq_md_out){
msg_data = &context->msgs_out;
}else{
msg_data = &context->msgs_in;
}
if(context->protocol != mosq_p_mqtt5
&& db.config->allow_duplicate_messages == false
&& dir == mosq_md_out && retain == false && stored->dest_ids){
for(i=0; i<stored->dest_id_count; i++){
if(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){
mosquitto_property_free_all(&properties);
return MOSQ_ERR_SUCCESS;
}
}
}
if(context->sock == INVALID_SOCKET){
if(qos == 0 && !db.config->queue_qos0_messages){
if(!context->bridge){
mosquitto_property_free_all(&properties);
return 2;
}else{
if(context->bridge->start_type != bst_lazy){
mosquitto_property_free_all(&properties);
return 2;
}
}
}
if(context->bridge && context->bridge->clean_start_local == true){
mosquitto_property_free_all(&properties);
return 2;
}
}
if(context->sock != INVALID_SOCKET){
if(db__ready_for_flight(context, dir, qos)){
if(dir == mosq_md_out){
switch(qos){
case 0:
state = mosq_ms_publish_qos0;
break;
case 1:
state = mosq_ms_publish_qos1;
break;
case 2:
state = mosq_ms_publish_qos2;
break;
}
}else{
if(qos == 2){
state = mosq_ms_wait_for_pubrel;
}else{
mosquitto_property_free_all(&properties);
return 1;
}
}
}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){
state = mosq_ms_queued;
rc = 2;
}else{
if(context->is_dropping == false){
context->is_dropping = true;
log__printf(NULL, MOSQ_LOG_NOTICE,
""Outgoing messages are being dropped for client %s."",
context->id);
}
G_MSGS_DROPPED_INC();
mosquitto_property_free_all(&properties);
return 2;
}
}else{
if (db__ready_for_queue(context, qos, msg_data)){
state = mosq_ms_queued;
}else{
G_MSGS_DROPPED_INC();
if(context->is_dropping == false){
context->is_dropping = true;
log__printf(NULL, MOSQ_LOG_NOTICE,
""Outgoing messages are being dropped for client %s."",
context->id);
}
mosquitto_property_free_all(&properties);
return 2;
}
}
assert(state != mosq_ms_invalid);
#ifdef WITH_PERSISTENCE
if(state == mosq_ms_queued){
db.persistence_changes++;
}
#endif
msg = mosquitto__malloc(sizeof(struct mosquitto_client_msg));
if(!msg) return MOSQ_ERR_NOMEM;
msg->prev = NULL;
msg->next = NULL;
msg->store = stored;
db__msg_store_ref_inc(msg->store);
msg->mid = mid;
msg->timestamp = db.now_s;
msg->direction = dir;
msg->state = state;
msg->dup = false;
if(qos > context->max_qos){
msg->qos = context->max_qos;
}else{
msg->qos = qos;
}
msg->retain = retain;
msg->properties = properties;
if(state == mosq_ms_queued){
DL_APPEND(msg_data->queued, msg);
db__msg_add_to_queued_stats(msg_data, msg);
}else{
DL_APPEND(msg_data->inflight, msg);
db__msg_add_to_inflight_stats(msg_data, msg);
}
if(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){
dest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));
if(dest_ids){
stored->dest_ids = dest_ids;
stored->dest_id_count++;
stored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);
if(!stored->dest_ids[stored->dest_id_count-1]){
return MOSQ_ERR_NOMEM;
}
}else{
return MOSQ_ERR_NOMEM;
}
}
#ifdef WITH_BRIDGE
if(context->bridge && context->bridge->start_type == bst_lazy
&& context->sock == INVALID_SOCKET
&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){
context->bridge->lazy_reconnect = true;
}
#endif
if(dir == mosq_md_out && msg->qos > 0 && state != mosq_ms_queued){
util__decrement_send_quota(context);
}
if(dir == mosq_md_out && update){
rc = db__message_write_inflight_out_latest(context);
if(rc) return rc;
rc = db__message_write_queued_out(context);
if(rc) return rc;
}
return rc;
}","int db__message_insert(struct mosquitto *VAR_0, uint16_t VAR_1, enum mosquitto_msg_direction VAR_2, uint8_t VAR_3, bool VAR_4, struct mosquitto_msg_store *VAR_5, mosquitto_property *VAR_6, bool VAR_7)
{
struct mosquitto_client_msg *VAR_8;
struct mosquitto_msg_data *VAR_9;
enum mosquitto_msg_state VAR_10 = VAR_11;
int VAR_12 = 0;
int VAR_13;
char **VAR_14;
assert(VAR_5);
if(!VAR_0) return VAR_15;
if(!VAR_0->id) return VAR_16; 
if(VAR_2 == VAR_17){
VAR_9 = &VAR_0->msgs_out;
}else{
VAR_9 = &VAR_0->msgs_in;
}
if(VAR_0->protocol != VAR_18
&& VAR_19.config->allow_duplicate_messages == false
&& VAR_2 == VAR_17 && VAR_4 == false && VAR_5->dest_ids){
for(VAR_13=0; VAR_13<VAR_5->dest_id_count; VAR_13++){
if(VAR_5->dest_ids[VAR_13] && !strcmp(VAR_5->dest_ids[VAR_13], VAR_0->id)){
mosquitto_property_free_all(&VAR_6);
return VAR_16;
}
}
}
if(VAR_0->sock == VAR_20){
if(VAR_3 == 0 && !VAR_19.config->queue_qos0_messages){
if(!VAR_0->bridge){
mosquitto_property_free_all(&VAR_6);
return 2;
}else{
if(VAR_0->bridge->start_type != VAR_21){
mosquitto_property_free_all(&VAR_6);
return 2;
}
}
}
if(VAR_0->bridge && VAR_0->bridge->clean_start_local == true){
mosquitto_property_free_all(&VAR_6);
return 2;
}
}
if(VAR_0->sock != VAR_20){
if(db__ready_for_flight(VAR_0, VAR_2, VAR_3)){
if(VAR_2 == VAR_17){
switch(VAR_3){
case 0:
VAR_10 = VAR_22;
break;
case 1:
VAR_10 = VAR_23;
break;
case 2:
VAR_10 = VAR_24;
break;
}
}else{
if(VAR_3 == 2){
VAR_10 = VAR_25;
}else{
mosquitto_property_free_all(&VAR_6);
return 1;
}
}
}else if(VAR_3 != 0 && db__ready_for_queue(VAR_0, VAR_3, VAR_9)){
VAR_10 = VAR_26;
VAR_12 = 2;
}else{
if(VAR_0->is_dropping == false){
VAR_0->is_dropping = true;
log__printf(NULL, VAR_27,
""Outgoing messages are being dropped for client %s."",
VAR_0->id);
}
G_MSGS_DROPPED_INC();
mosquitto_property_free_all(&VAR_6);
return 2;
}
}else{
if (db__ready_for_queue(VAR_0, VAR_3, VAR_9)){
VAR_10 = VAR_26;
}else{
G_MSGS_DROPPED_INC();
if(VAR_0->is_dropping == false){
VAR_0->is_dropping = true;
log__printf(NULL, VAR_27,
""Outgoing messages are being dropped for client %s."",
VAR_0->id);
}
mosquitto_property_free_all(&VAR_6);
return 2;
}
}
assert(VAR_10 != VAR_11);
#ifdef VAR_28
if(VAR_10 == VAR_26){
VAR_19.persistence_changes++;
}
#endif
VAR_8 = mosquitto__malloc(sizeof(struct mosquitto_client_msg));
if(!VAR_8) return VAR_29;
VAR_8->prev = NULL;
VAR_8->next = NULL;
VAR_8->store = VAR_5;
db__msg_store_ref_inc(VAR_8->store);
VAR_8->mid = VAR_1;
VAR_8->timestamp = VAR_19.now_s;
VAR_8->direction = VAR_2;
VAR_8->state = VAR_10;
VAR_8->dup = false;
if(VAR_3 > VAR_0->max_qos){
VAR_8->qos = VAR_0->max_qos;
}else{
VAR_8->qos = VAR_3;
}
VAR_8->retain = VAR_4;
VAR_8->properties = VAR_6;
if(VAR_10 == VAR_26){
DL_APPEND(VAR_9->queued, VAR_8);
db__msg_add_to_queued_stats(VAR_9, VAR_8);
}else{
DL_APPEND(VAR_9->inflight, VAR_8);
db__msg_add_to_inflight_stats(VAR_9, VAR_8);
}
if(VAR_19.config->allow_duplicate_messages == false && VAR_2 == VAR_17 && VAR_4 == false){
VAR_14 = mosquitto__realloc(VAR_5->dest_ids, sizeof(char *)*(size_t)(VAR_5->dest_id_count+1));
if(VAR_14){
VAR_5->dest_ids = VAR_14;
VAR_5->dest_id_count++;
VAR_5->dest_ids[VAR_5->dest_id_count-1] = mosquitto__strdup(VAR_0->id);
if(!VAR_5->dest_ids[VAR_5->dest_id_count-1]){
return VAR_29;
}
}else{
return VAR_29;
}
}
#ifdef VAR_30
if(VAR_0->bridge && VAR_0->bridge->start_type == VAR_21
&& VAR_0->sock == VAR_20
&& VAR_0->msgs_out.inflight_count + VAR_0->msgs_out.queued_count >= VAR_0->bridge->threshold){
VAR_0->bridge->lazy_reconnect = true;
}
#endif
if(VAR_2 == VAR_17 && VAR_8->qos > 0 && VAR_10 != VAR_26){
util__decrement_send_quota(VAR_0);
}
if(VAR_2 == VAR_17 && VAR_7){
VAR_12 = db__message_write_inflight_out_latest(VAR_0);
if(VAR_12) return VAR_12;
VAR_12 = db__message_write_queued_out(VAR_0);
if(VAR_12) return VAR_12;
}
return VAR_12;
}",eclipse/mosquitto/6113eac95a9df634fbc858be542c4a0456bfe7b9/database.c/vul/before/0.json,"int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)
{
	struct mosquitto_client_msg *msg;
	struct mosquitto_msg_data *msg_data;
	enum mosquitto_msg_state state = mosq_ms_invalid;
	int rc = 0;
	int i;
	char **dest_ids;

	assert(stored);
	if(!context) return MOSQ_ERR_INVAL;
	if(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely ""client is disconnected but not entirely freed"" scenario */

	if(dir == mosq_md_out){
		msg_data = &context->msgs_out;
	}else{
		msg_data = &context->msgs_in;
	}

	/* Check whether we've already sent this message to this client
	 * for outgoing messages only.
	 * If retain==true then this is a stale retained message and so should be
	 * sent regardless. FIXME - this does mean retained messages will received
	 * multiple times for overlapping subscriptions, although this is only the
	 * case for SUBSCRIPTION with multiple subs in so is a minor concern.
	 */
	if(context->protocol != mosq_p_mqtt5
			&& db.config->allow_duplicate_messages == false
			&& dir == mosq_md_out && retain == false && stored->dest_ids){

		for(i=0; i<stored->dest_id_count; i++){
			if(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){
				/* We have already sent this message to this client. */
				mosquitto_property_free_all(&properties);
				return MOSQ_ERR_SUCCESS;
			}
		}
	}
	if(context->sock == INVALID_SOCKET){
		/* Client is not connected only queue messages with QoS>0. */
		if(qos == 0 && !db.config->queue_qos0_messages){
			if(!context->bridge){
				mosquitto_property_free_all(&properties);
				return 2;
			}else{
				if(context->bridge->start_type != bst_lazy){
					mosquitto_property_free_all(&properties);
					return 2;
				}
			}
		}
		if(context->bridge && context->bridge->clean_start_local == true){
			mosquitto_property_free_all(&properties);
			return 2;
		}
	}

	if(context->sock != INVALID_SOCKET){
		if(db__ready_for_flight(context, dir, qos)){
			if(dir == mosq_md_out){
				switch(qos){
					case 0:
						state = mosq_ms_publish_qos0;
						break;
					case 1:
						state = mosq_ms_publish_qos1;
						break;
					case 2:
						state = mosq_ms_publish_qos2;
						break;
				}
			}else{
				if(qos == 2){
					state = mosq_ms_wait_for_pubrel;
				}else{
					mosquitto_property_free_all(&properties);
					return 1;
				}
			}
		}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){
			state = mosq_ms_queued;
			rc = 2;
		}else{
			/* Dropping message due to full queue. */
			if(context->is_dropping == false){
				context->is_dropping = true;
				log__printf(NULL, MOSQ_LOG_NOTICE,
						""Outgoing messages are being dropped for client %s."",
						context->id);
			}
			G_MSGS_DROPPED_INC();
			mosquitto_property_free_all(&properties);
			return 2;
		}
	}else{
		if (db__ready_for_queue(context, qos, msg_data)){
			state = mosq_ms_queued;
		}else{
			G_MSGS_DROPPED_INC();
			if(context->is_dropping == false){
				context->is_dropping = true;
				log__printf(NULL, MOSQ_LOG_NOTICE,
						""Outgoing messages are being dropped for client %s."",
						context->id);
			}
			mosquitto_property_free_all(&properties);
			return 2;
		}
	}
	assert(state != mosq_ms_invalid);

#ifdef WITH_PERSISTENCE
	if(state == mosq_ms_queued){
		db.persistence_changes++;
	}
#endif

	msg = mosquitto__calloc(1, sizeof(struct mosquitto_client_msg));
	if(!msg) return MOSQ_ERR_NOMEM;
	msg->prev = NULL;
	msg->next = NULL;
	msg->store = stored;
	db__msg_store_ref_inc(msg->store);
	msg->mid = mid;
	msg->timestamp = db.now_s;
	msg->direction = dir;
	msg->state = state;
	msg->dup = false;
	if(qos > context->max_qos){
		msg->qos = context->max_qos;
	}else{
		msg->qos = qos;
	}
	msg->retain = retain;
	msg->properties = properties;

	if(state == mosq_ms_queued){
		DL_APPEND(msg_data->queued, msg);
		db__msg_add_to_queued_stats(msg_data, msg);
	}else{
		DL_APPEND(msg_data->inflight, msg);
		db__msg_add_to_inflight_stats(msg_data, msg);
	}

	if(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){
		/* Record which client ids this message has been sent to so we can avoid duplicates.
		 * Outgoing messages only.
		 * If retain==true then this is a stale retained message and so should be
		 * sent regardless. FIXME - this does mean retained messages will received
		 * multiple times for overlapping subscriptions, although this is only the
		 * case for SUBSCRIPTION with multiple subs in so is a minor concern.
		 */
		dest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));
		if(dest_ids){
			stored->dest_ids = dest_ids;
			stored->dest_id_count++;
			stored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);
			if(!stored->dest_ids[stored->dest_id_count-1]){
				return MOSQ_ERR_NOMEM;
			}
		}else{
			return MOSQ_ERR_NOMEM;
		}
	}
#ifdef WITH_BRIDGE
	if(context->bridge && context->bridge->start_type == bst_lazy
			&& context->sock == INVALID_SOCKET
			&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){

		context->bridge->lazy_reconnect = true;
	}
#endif

	if(dir == mosq_md_out && msg->qos > 0 && state != mosq_ms_queued){
		util__decrement_send_quota(context);
	}else if(dir == mosq_md_in && msg->qos > 0 && state != mosq_ms_queued){
		util__decrement_receive_quota(context);
	}

	if(dir == mosq_md_out && update){
		rc = db__message_write_inflight_out_latest(context);
		if(rc) return rc;
		rc = db__message_write_queued_out(context);
		if(rc) return rc;
	}

	return rc;
}","int db__message_insert(struct mosquitto *VAR_0, uint16_t VAR_1, enum mosquitto_msg_direction VAR_2, uint8_t VAR_3, bool VAR_4, struct mosquitto_msg_store *VAR_5, mosquitto_property *VAR_6, bool VAR_7)
{
	struct mosquitto_client_msg *VAR_8;
	struct mosquitto_msg_data *VAR_9;
	enum mosquitto_msg_state VAR_10 = VAR_11;
	int VAR_12 = 0;
	int VAR_13;
	char **VAR_14;

	assert(VAR_5);
	if(!VAR_0) return VAR_15;
	if(!VAR_0->id) return VAR_16; /* COMMENT_0 */

	if(VAR_2 == VAR_17){
		VAR_9 = &VAR_0->msgs_out;
	}else{
		VAR_9 = &VAR_0->msgs_in;
	}

	/* COMMENT_1 */
                               
                                                                          
                                                                           
                                                                           
                                                                      
    
	if(VAR_0->protocol != VAR_18
			&& VAR_19.config->allow_duplicate_messages == false
			&& VAR_2 == VAR_17 && VAR_4 == false && VAR_5->dest_ids){

		for(VAR_13=0; VAR_13<VAR_5->dest_id_count; VAR_13++){
			if(VAR_5->dest_ids[VAR_13] && !strcmp(VAR_5->dest_ids[VAR_13], VAR_0->id)){
				/* COMMENT_8 */
				mosquitto_property_free_all(&VAR_6);
				return VAR_16;
			}
		}
	}
	if(VAR_0->sock == VAR_20){
		/* COMMENT_9 */
		if(VAR_3 == 0 && !VAR_19.config->queue_qos0_messages){
			if(!VAR_0->bridge){
				mosquitto_property_free_all(&VAR_6);
				return 2;
			}else{
				if(VAR_0->bridge->start_type != VAR_21){
					mosquitto_property_free_all(&VAR_6);
					return 2;
				}
			}
		}
		if(VAR_0->bridge && VAR_0->bridge->clean_start_local == true){
			mosquitto_property_free_all(&VAR_6);
			return 2;
		}
	}

	if(VAR_0->sock != VAR_20){
		if(db__ready_for_flight(VAR_0, VAR_2, VAR_3)){
			if(VAR_2 == VAR_17){
				switch(VAR_3){
					case 0:
						VAR_10 = VAR_22;
						break;
					case 1:
						VAR_10 = VAR_23;
						break;
					case 2:
						VAR_10 = VAR_24;
						break;
				}
			}else{
				if(VAR_3 == 2){
					VAR_10 = VAR_25;
				}else{
					mosquitto_property_free_all(&VAR_6);
					return 1;
				}
			}
		}else if(VAR_3 != 0 && db__ready_for_queue(VAR_0, VAR_3, VAR_9)){
			VAR_10 = VAR_26;
			VAR_12 = 2;
		}else{
			/* COMMENT_10 */
			if(VAR_0->is_dropping == false){
				VAR_0->is_dropping = true;
				log__printf(NULL, VAR_27,
						""Outgoing messages are being dropped for client %s."",
						VAR_0->id);
			}
			G_MSGS_DROPPED_INC();
			mosquitto_property_free_all(&VAR_6);
			return 2;
		}
	}else{
		if (db__ready_for_queue(VAR_0, VAR_3, VAR_9)){
			VAR_10 = VAR_26;
		}else{
			G_MSGS_DROPPED_INC();
			if(VAR_0->is_dropping == false){
				VAR_0->is_dropping = true;
				log__printf(NULL, VAR_27,
						""Outgoing messages are being dropped for client %s."",
						VAR_0->id);
			}
			mosquitto_property_free_all(&VAR_6);
			return 2;
		}
	}
	assert(VAR_10 != VAR_11);

#ifdef VAR_28
	if(VAR_10 == VAR_26){
		VAR_19.persistence_changes++;
	}
#endif

	VAR_8 = mosquitto__calloc(1, sizeof(struct mosquitto_client_msg));
	if(!VAR_8) return VAR_29;
	VAR_8->prev = NULL;
	VAR_8->next = NULL;
	VAR_8->store = VAR_5;
	db__msg_store_ref_inc(VAR_8->store);
	VAR_8->mid = VAR_1;
	VAR_8->timestamp = VAR_19.now_s;
	VAR_8->direction = VAR_2;
	VAR_8->state = VAR_10;
	VAR_8->dup = false;
	if(VAR_3 > VAR_0->max_qos){
		VAR_8->qos = VAR_0->max_qos;
	}else{
		VAR_8->qos = VAR_3;
	}
	VAR_8->retain = VAR_4;
	VAR_8->properties = VAR_6;

	if(VAR_10 == VAR_26){
		DL_APPEND(VAR_9->queued, VAR_8);
		db__msg_add_to_queued_stats(VAR_9, VAR_8);
	}else{
		DL_APPEND(VAR_9->inflight, VAR_8);
		db__msg_add_to_inflight_stats(VAR_9, VAR_8);
	}

	if(VAR_19.config->allow_duplicate_messages == false && VAR_2 == VAR_17 && VAR_4 == false){
		/* COMMENT_11 */
                            
                                                                           
                                                                            
                                                                            
                                                                       
     
		VAR_14 = mosquitto__realloc(VAR_5->dest_ids, sizeof(char *)*(size_t)(VAR_5->dest_id_count+1));
		if(VAR_14){
			VAR_5->dest_ids = VAR_14;
			VAR_5->dest_id_count++;
			VAR_5->dest_ids[VAR_5->dest_id_count-1] = mosquitto__strdup(VAR_0->id);
			if(!VAR_5->dest_ids[VAR_5->dest_id_count-1]){
				return VAR_29;
			}
		}else{
			return VAR_29;
		}
	}
#ifdef VAR_30
	if(VAR_0->bridge && VAR_0->bridge->start_type == VAR_21
			&& VAR_0->sock == VAR_20
			&& VAR_0->msgs_out.inflight_count + VAR_0->msgs_out.queued_count >= VAR_0->bridge->threshold){

		VAR_0->bridge->lazy_reconnect = true;
	}
#endif

	if(VAR_2 == VAR_17 && VAR_8->qos > 0 && VAR_10 != VAR_26){
		util__decrement_send_quota(VAR_0);
	}else if(VAR_2 == VAR_31 && VAR_8->qos > 0 && VAR_10 != VAR_26){
		util__decrement_receive_quota(VAR_0);
	}

	if(VAR_2 == VAR_17 && VAR_7){
		VAR_12 = db__message_write_inflight_out_latest(VAR_0);
		if(VAR_12) return VAR_12;
		VAR_12 = db__message_write_queued_out(VAR_0);
		if(VAR_12) return VAR_12;
	}

	return VAR_12;
}",eclipse/mosquitto/6113eac95a9df634fbc858be542c4a0456bfe7b9/database.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -115,7 +115,7 @@
 	}
 #endif
 
-	msg = mosquitto__malloc(sizeof(struct mosquitto_client_msg));
+	msg = mosquitto__calloc(1, sizeof(struct mosquitto_client_msg));
 	if(!msg) return MOSQ_ERR_NOMEM;
 	msg->prev = NULL;
 	msg->next = NULL;
@@ -173,6 +173,8 @@
 
 	if(dir == mosq_md_out && msg->qos > 0 && state != mosq_ms_queued){
 		util__decrement_send_quota(context);
+	}else if(dir == mosq_md_in && msg->qos > 0 && state != mosq_ms_queued){
+		util__decrement_receive_quota(context);
 	}
 
 	if(dir == mosq_md_out && update){","{'deleted_lines': ['\tmsg = mosquitto__malloc(sizeof(struct mosquitto_client_msg));'], 'added_lines': ['\tmsg = mosquitto__calloc(1, sizeof(struct mosquitto_client_msg));', '\t}else if(dir == mosq_md_in && msg->qos > 0 && state != mosq_ms_queued){', '\t\tutil__decrement_receive_quota(context);']}",True,"The broker in Eclipse Mosquitto 1.3.2 through 2.x before 2.0.16 has a memory leak that can be abused remotely when a client sends many QoS 2 messages with duplicate message IDs, and fails to respond to PUBREC commands. This occurs because of mishandling of EAGAIN from the libc send function.",7.5,HIGH,2,test,2023-06-13T10:22:03Z,4
CVE-2023-28366,['CWE-401'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,eclipse/mosquitto,Fix for CVE-2023-28366,6113eac95a9df634fbc858be542c4a0456bfe7b9,https://github.com/eclipse/mosquitto/commit/6113eac95a9df634fbc858be542c4a0456bfe7b9,lib/packet_mosq.c,packet__queue,"int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)
{
#ifndef WITH_BROKER
char sockpair_data = 0;
#endif
assert(mosq);
assert(packet);
packet->pos = 0;
packet->to_process = packet->packet_length;
packet->next = NULL;
pthread_mutex_lock(&mosq->out_packet_mutex);
if(mosq->out_packet){
mosq->out_packet_last->next = packet;
}else{
mosq->out_packet = packet;
}
mosq->out_packet_last = packet;
mosq->out_packet_count++;
pthread_mutex_unlock(&mosq->out_packet_mutex);
#ifdef WITH_BROKER
#  ifdef WITH_WEBSOCKETS
if(mosq->wsi){
lws_callback_on_writable(mosq->wsi);
return MOSQ_ERR_SUCCESS;
}else{
return packet__write(mosq);
}
#  else
return packet__write(mosq);
#  endif
#else
if(mosq->sockpairW != INVALID_SOCKET){
#ifndef WIN32
if(write(mosq->sockpairW, &sockpair_data, 1)){
}
#else
send(mosq->sockpairW, &sockpair_data, 1, 0);
#endif
}
if(mosq->in_callback == false && mosq->threaded == mosq_ts_none){
return packet__write(mosq);
}else{
return MOSQ_ERR_SUCCESS;
}
#endif
}","int packet__queue(struct mosquitto *VAR_0, struct mosquitto__packet *VAR_1)
{
#ifndef VAR_2
char VAR_3 = 0;
#endif
assert(VAR_0);
assert(VAR_1);
VAR_1->pos = 0;
VAR_1->to_process = VAR_1->packet_length;
VAR_1->next = NULL;
pthread_mutex_lock(&VAR_0->out_packet_mutex);
if(VAR_0->out_packet){
VAR_0->out_packet_last->next = VAR_1;
}else{
VAR_0->out_packet = VAR_1;
}
VAR_0->out_packet_last = VAR_1;
VAR_0->out_packet_count++;
pthread_mutex_unlock(&VAR_0->out_packet_mutex);
#ifdef VAR_2
#  ifdef VAR_4
if(VAR_0->wsi){
lws_callback_on_writable(VAR_0->wsi);
return VAR_5;
}else{
return packet__write(VAR_0);
}
#  else
return packet__write(VAR_0);
#  endif
#else
if(VAR_0->sockpairW != VAR_6){
#ifndef VAR_7
if(write(VAR_0->sockpairW, &VAR_3, 1)){
}
#else
send(VAR_0->sockpairW, &VAR_3, 1, 0);
#endif
}
if(VAR_0->in_callback == false && VAR_0->threaded == VAR_8){
return packet__write(VAR_0);
}else{
return VAR_5;
}
#endif
}",eclipse/mosquitto/6113eac95a9df634fbc858be542c4a0456bfe7b9/packet_mosq.c/vul/before/0.json,"int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)
{
#ifndef WITH_BROKER
	char sockpair_data = 0;
#endif
	assert(mosq);
	assert(packet);

	packet->pos = 0;
	packet->to_process = packet->packet_length;

	packet->next = NULL;
	pthread_mutex_lock(&mosq->out_packet_mutex);

#ifdef WITH_BROKER
	if(mosq->out_packet_count >= db.config->max_queued_messages){
		mosquitto__free(packet);
		if(mosq->is_dropping == false){
			mosq->is_dropping = true;
			log__printf(NULL, MOSQ_LOG_NOTICE,
					""Outgoing messages are being dropped for client %s."",
					mosq->id);
		}
		G_MSGS_DROPPED_INC();
		return MOSQ_ERR_SUCCESS;
	}
#endif

	if(mosq->out_packet){
		mosq->out_packet_last->next = packet;
	}else{
		mosq->out_packet = packet;
	}
	mosq->out_packet_last = packet;
	mosq->out_packet_count++;
	pthread_mutex_unlock(&mosq->out_packet_mutex);
#ifdef WITH_BROKER
#  ifdef WITH_WEBSOCKETS
	if(mosq->wsi){
		lws_callback_on_writable(mosq->wsi);
		return MOSQ_ERR_SUCCESS;
	}else{
		return packet__write(mosq);
	}
#  else
	return packet__write(mosq);
#  endif
#else

	/* Write a single byte to sockpairW (connected to sockpairR) to break out
	 * of select() if in threaded mode. */
	if(mosq->sockpairW != INVALID_SOCKET){
#ifndef WIN32
		if(write(mosq->sockpairW, &sockpair_data, 1)){
		}
#else
		send(mosq->sockpairW, &sockpair_data, 1, 0);
#endif
	}

	if(mosq->in_callback == false && mosq->threaded == mosq_ts_none){
		return packet__write(mosq);
	}else{
		return MOSQ_ERR_SUCCESS;
	}
#endif
}","int packet__queue(struct mosquitto *VAR_0, struct mosquitto__packet *VAR_1)
{
#ifndef VAR_2
	char VAR_3 = 0;
#endif
	assert(VAR_0);
	assert(VAR_1);

	VAR_1->pos = 0;
	VAR_1->to_process = VAR_1->packet_length;

	VAR_1->next = NULL;
	pthread_mutex_lock(&VAR_0->out_packet_mutex);

#ifdef VAR_2
	if(VAR_0->out_packet_count >= VAR_4.config->max_queued_messages){
		mosquitto__free(VAR_1);
		if(VAR_0->is_dropping == false){
			VAR_0->is_dropping = true;
			log__printf(NULL, VAR_5,
					""Outgoing messages are being dropped for client %s."",
					VAR_0->id);
		}
		G_MSGS_DROPPED_INC();
		return VAR_6;
	}
#endif

	if(VAR_0->out_packet){
		VAR_0->out_packet_last->next = VAR_1;
	}else{
		VAR_0->out_packet = VAR_1;
	}
	VAR_0->out_packet_last = VAR_1;
	VAR_0->out_packet_count++;
	pthread_mutex_unlock(&VAR_0->out_packet_mutex);
#ifdef VAR_2
#  ifdef VAR_7
	if(VAR_0->wsi){
		lws_callback_on_writable(VAR_0->wsi);
		return VAR_6;
	}else{
		return packet__write(VAR_0);
	}
#  else
	return packet__write(VAR_0);
#  endif
#else

	/* COMMENT_0 */
                                       
	if(VAR_0->sockpairW != VAR_8){
#ifndef VAR_9
		if(write(VAR_0->sockpairW, &VAR_3, 1)){
		}
#else
		send(VAR_0->sockpairW, &VAR_3, 1, 0);
#endif
	}

	if(VAR_0->in_callback == false && VAR_0->threaded == VAR_10){
		return packet__write(VAR_0);
	}else{
		return VAR_6;
	}
#endif
}",eclipse/mosquitto/6113eac95a9df634fbc858be542c4a0456bfe7b9/packet_mosq.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,6 +11,21 @@
 
 	packet->next = NULL;
 	pthread_mutex_lock(&mosq->out_packet_mutex);
+
+#ifdef WITH_BROKER
+	if(mosq->out_packet_count >= db.config->max_queued_messages){
+		mosquitto__free(packet);
+		if(mosq->is_dropping == false){
+			mosq->is_dropping = true;
+			log__printf(NULL, MOSQ_LOG_NOTICE,
+					""Outgoing messages are being dropped for client %s."",
+					mosq->id);
+		}
+		G_MSGS_DROPPED_INC();
+		return MOSQ_ERR_SUCCESS;
+	}
+#endif
+
 	if(mosq->out_packet){
 		mosq->out_packet_last->next = packet;
 	}else{","{'deleted_lines': [], 'added_lines': ['', '#ifdef WITH_BROKER', '\tif(mosq->out_packet_count >= db.config->max_queued_messages){', '\t\tmosquitto__free(packet);', '\t\tif(mosq->is_dropping == false){', '\t\t\tmosq->is_dropping = true;', '\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,', '\t\t\t\t\t""Outgoing messages are being dropped for client %s."",', '\t\t\t\t\tmosq->id);', '\t\t}', '\t\tG_MSGS_DROPPED_INC();', '\t\treturn MOSQ_ERR_SUCCESS;', '\t}', '#endif', '']}",True,"The broker in Eclipse Mosquitto 1.3.2 through 2.x before 2.0.16 has a memory leak that can be abused remotely when a client sends many QoS 2 messages with duplicate message IDs, and fails to respond to PUBREC commands. This occurs because of mishandling of EAGAIN from the libc send function.",7.5,HIGH,2,test,2023-06-13T10:22:03Z,4
CVE-2023-28366,['CWE-401'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,eclipse/mosquitto,Fix for CVE-2023-28366,6113eac95a9df634fbc858be542c4a0456bfe7b9,https://github.com/eclipse/mosquitto/commit/6113eac95a9df634fbc858be542c4a0456bfe7b9,src/database.c,db__message_reconnect_reset_incoming,"static int db__message_reconnect_reset_incoming(struct mosquitto *context)
{
struct mosquitto_client_msg *msg, *tmp;
context->msgs_in.inflight_bytes = 0;
context->msgs_in.inflight_bytes12 = 0;
context->msgs_in.inflight_count = 0;
context->msgs_in.inflight_count12 = 0;
context->msgs_in.queued_bytes = 0;
context->msgs_in.queued_bytes12 = 0;
context->msgs_in.queued_count = 0;
context->msgs_in.queued_count12 = 0;
context->msgs_in.inflight_quota = context->msgs_in.inflight_maximum;
DL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){
db__msg_add_to_inflight_stats(&context->msgs_in, msg);
if(msg->qos > 0){
util__decrement_receive_quota(context);
}
if(msg->qos != 2){
db__message_remove_from_inflight(&context->msgs_in, msg);
}else{
}
}
DL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){
db__msg_add_to_queued_stats(&context->msgs_in, msg);
if(db__ready_for_flight(context, mosq_md_in, msg->qos)){
switch(msg->qos){
case 0:
msg->state = mosq_ms_publish_qos0;
break;
case 1:
msg->state = mosq_ms_publish_qos1;
break;
case 2:
msg->state = mosq_ms_publish_qos2;
break;
}
db__message_dequeue_first(context, &context->msgs_in);
}
}
return MOSQ_ERR_SUCCESS;
}","static int db__message_reconnect_reset_incoming(struct mosquitto *VAR_0)
{
struct mosquitto_client_msg *VAR_1, *VAR_2;
VAR_0->msgs_in.inflight_bytes = 0;
VAR_0->msgs_in.inflight_bytes12 = 0;
VAR_0->msgs_in.inflight_count = 0;
VAR_0->msgs_in.inflight_count12 = 0;
VAR_0->msgs_in.queued_bytes = 0;
VAR_0->msgs_in.queued_bytes12 = 0;
VAR_0->msgs_in.queued_count = 0;
VAR_0->msgs_in.queued_count12 = 0;
VAR_0->msgs_in.inflight_quota = VAR_0->msgs_in.inflight_maximum;
DL_FOREACH_SAFE(VAR_0->msgs_in.inflight, VAR_1, VAR_2){
db__msg_add_to_inflight_stats(&VAR_0->msgs_in, VAR_1);
if(VAR_1->qos > 0){
util__decrement_receive_quota(VAR_0);
}
if(VAR_1->qos != 2){
db__message_remove_from_inflight(&VAR_0->msgs_in, VAR_1);
}else{
}
}
DL_FOREACH_SAFE(VAR_0->msgs_in.queued, VAR_1, VAR_2){
db__msg_add_to_queued_stats(&VAR_0->msgs_in, VAR_1);
if(db__ready_for_flight(VAR_0, VAR_3, VAR_1->qos)){
switch(VAR_1->qos){
case 0:
VAR_1->state = VAR_4;
break;
case 1:
VAR_1->state = VAR_5;
break;
case 2:
VAR_1->state = VAR_6;
break;
}
db__message_dequeue_first(VAR_0, &VAR_0->msgs_in);
}
}
return VAR_7;
}",eclipse/mosquitto/6113eac95a9df634fbc858be542c4a0456bfe7b9/database.c/vul/before/2.json,"static int db__message_reconnect_reset_incoming(struct mosquitto *context)
{
	struct mosquitto_client_msg *msg, *tmp;

	context->msgs_in.inflight_bytes = 0;
	context->msgs_in.inflight_bytes12 = 0;
	context->msgs_in.inflight_count = 0;
	context->msgs_in.inflight_count12 = 0;
	context->msgs_in.queued_bytes = 0;
	context->msgs_in.queued_bytes12 = 0;
	context->msgs_in.queued_count = 0;
	context->msgs_in.queued_count12 = 0;
	context->msgs_in.inflight_quota = context->msgs_in.inflight_maximum;

	DL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){
		db__msg_add_to_inflight_stats(&context->msgs_in, msg);
		if(msg->qos > 0){
			util__decrement_receive_quota(context);
		}

		if(msg->qos != 2){
			/* Anything <QoS 2 can be completely retried by the client at
			 * no harm. */
			db__message_remove_from_inflight(&context->msgs_in, msg);
		}else{
			/* Message state can be preserved here because it should match
			 * whatever the client has got. */
			msg->dup = 0;
		}
	}

	/* Messages received when the client was disconnected are put
	 * in the mosq_ms_queued state. If we don't change them to the
	 * appropriate ""publish"" state, then the queued messages won't
	 * get sent until the client next receives a message - and they
	 * will be sent out of order.
	 */
	DL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){
		msg->dup = 0;
		db__msg_add_to_queued_stats(&context->msgs_in, msg);
		if(db__ready_for_flight(context, mosq_md_in, msg->qos)){
			switch(msg->qos){
				case 0:
					msg->state = mosq_ms_publish_qos0;
					break;
				case 1:
					msg->state = mosq_ms_publish_qos1;
					break;
				case 2:
					msg->state = mosq_ms_publish_qos2;
					break;
			}
			db__message_dequeue_first(context, &context->msgs_in);
		}
	}

	return MOSQ_ERR_SUCCESS;
}","static int db__message_reconnect_reset_incoming(struct mosquitto *VAR_0)
{
	struct mosquitto_client_msg *VAR_1, *VAR_2;

	VAR_0->msgs_in.inflight_bytes = 0;
	VAR_0->msgs_in.inflight_bytes12 = 0;
	VAR_0->msgs_in.inflight_count = 0;
	VAR_0->msgs_in.inflight_count12 = 0;
	VAR_0->msgs_in.queued_bytes = 0;
	VAR_0->msgs_in.queued_bytes12 = 0;
	VAR_0->msgs_in.queued_count = 0;
	VAR_0->msgs_in.queued_count12 = 0;
	VAR_0->msgs_in.inflight_quota = VAR_0->msgs_in.inflight_maximum;

	DL_FOREACH_SAFE(VAR_0->msgs_in.inflight, VAR_1, VAR_2){
		db__msg_add_to_inflight_stats(&VAR_0->msgs_in, VAR_1);
		if(VAR_1->qos > 0){
			util__decrement_receive_quota(VAR_0);
		}

		if(VAR_1->qos != 2){
			/* COMMENT_0 */
                 
			db__message_remove_from_inflight(&VAR_0->msgs_in, VAR_1);
		}else{
			/* COMMENT_2 */
                                     
			VAR_1->dup = 0;
		}
	}

	/* COMMENT_4 */
                                                               
                                                               
                                                                
                              
    
	DL_FOREACH_SAFE(VAR_0->msgs_in.queued, VAR_1, VAR_2){
		VAR_1->dup = 0;
		db__msg_add_to_queued_stats(&VAR_0->msgs_in, VAR_1);
		if(db__ready_for_flight(VAR_0, VAR_3, VAR_1->qos)){
			switch(VAR_1->qos){
				case 0:
					VAR_1->state = VAR_4;
					break;
				case 1:
					VAR_1->state = VAR_5;
					break;
				case 2:
					VAR_1->state = VAR_6;
					break;
			}
			db__message_dequeue_first(VAR_0, &VAR_0->msgs_in);
		}
	}

	return VAR_7;
}",eclipse/mosquitto/6113eac95a9df634fbc858be542c4a0456bfe7b9/database.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -25,6 +25,7 @@
 		}else{
 			/* Message state can be preserved here because it should match
 			 * whatever the client has got. */
+			msg->dup = 0;
 		}
 	}
 
@@ -35,6 +36,7 @@
 	 * will be sent out of order.
 	 */
 	DL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){
+		msg->dup = 0;
 		db__msg_add_to_queued_stats(&context->msgs_in, msg);
 		if(db__ready_for_flight(context, mosq_md_in, msg->qos)){
 			switch(msg->qos){","{'deleted_lines': [], 'added_lines': ['\t\t\tmsg->dup = 0;', '\t\tmsg->dup = 0;']}",True,"The broker in Eclipse Mosquitto 1.3.2 through 2.x before 2.0.16 has a memory leak that can be abused remotely when a client sends many QoS 2 messages with duplicate message IDs, and fails to respond to PUBREC commands. This occurs because of mishandling of EAGAIN from the libc send function.",7.5,HIGH,2,test,2023-06-13T10:22:03Z,4
CVE-2023-28366,['CWE-401'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,eclipse/mosquitto,Fix for CVE-2023-28366,6113eac95a9df634fbc858be542c4a0456bfe7b9,https://github.com/eclipse/mosquitto/commit/6113eac95a9df634fbc858be542c4a0456bfe7b9,src/context.c,context__cleanup,"void context__cleanup(struct mosquitto *context, bool force_free)
{
struct mosquitto__packet *packet;
if(!context) return;
if(force_free){
context->clean_start = true;
}
#ifdef WITH_BRIDGE
if(context->bridge){
bridge__cleanup(context);
}
#endif
alias__free_all(context);
mosquitto__free(context->auth_method);
context->auth_method = NULL;
mosquitto__free(context->username);
context->username = NULL;
mosquitto__free(context->password);
context->password = NULL;
net__socket_close(context);
if(force_free){
sub__clean_session(context);
}
db__messages_delete(context, force_free);
mosquitto__free(context->address);
context->address = NULL;
context__send_will(context);
if(context->id){
context__remove_from_by_id(context);
mosquitto__free(context->id);
context->id = NULL;
}
packet__cleanup(&(context->in_packet));
if(context->current_out_packet){
packet__cleanup(context->current_out_packet);
mosquitto__free(context->current_out_packet);
context->current_out_packet = NULL;
}
while(context->out_packet){
packet__cleanup(context->out_packet);
packet = context->out_packet;
context->out_packet = context->out_packet->next;
mosquitto__free(packet);
}
context->out_packet_count = 0;
#if defined(WITH_BROKER) && defined(__GLIBC__) && defined(WITH_ADNS)
if(context->adns){
gai_cancel(context->adns);
mosquitto__free((struct addrinfo *)context->adns->ar_request);
mosquitto__free(context->adns);
}
#endif
if(force_free){
mosquitto__free(context);
}
}","void context__cleanup(struct mosquitto *VAR_0, bool VAR_1)
{
struct mosquitto__packet *VAR_2;
if(!VAR_0) return;
if(VAR_1){
VAR_0->clean_start = true;
}
#ifdef VAR_3
if(VAR_0->bridge){
bridge__cleanup(VAR_0);
}
#endif
alias__free_all(VAR_0);
mosquitto__free(VAR_0->auth_method);
VAR_0->auth_method = NULL;
mosquitto__free(VAR_0->username);
VAR_0->username = NULL;
mosquitto__free(VAR_0->password);
VAR_0->password = NULL;
net__socket_close(VAR_0);
if(VAR_1){
sub__clean_session(VAR_0);
}
db__messages_delete(VAR_0, VAR_1);
mosquitto__free(VAR_0->address);
VAR_0->address = NULL;
context__send_will(VAR_0);
if(VAR_0->id){
context__remove_from_by_id(VAR_0);
mosquitto__free(VAR_0->id);
VAR_0->id = NULL;
}
packet__cleanup(&(VAR_0->in_packet));
if(VAR_0->current_out_packet){
packet__cleanup(VAR_0->current_out_packet);
mosquitto__free(VAR_0->current_out_packet);
VAR_0->current_out_packet = NULL;
}
while(VAR_0->out_packet){
packet__cleanup(VAR_0->out_packet);
VAR_2 = VAR_0->out_packet;
VAR_0->out_packet = VAR_0->out_packet->next;
mosquitto__free(VAR_2);
}
VAR_0->out_packet_count = 0;
#if defined(VAR_4) && defined(VAR_5) && defined(VAR_6)
if(VAR_0->adns){
gai_cancel(VAR_0->adns);
mosquitto__free((struct addrinfo *)VAR_0->adns->ar_request);
mosquitto__free(VAR_0->adns);
}
#endif
if(VAR_1){
mosquitto__free(VAR_0);
}
}",eclipse/mosquitto/6113eac95a9df634fbc858be542c4a0456bfe7b9/context.c/vul/before/1.json,"void context__cleanup(struct mosquitto *context, bool force_free)
{
	if(!context) return;

	if(force_free){
		context->clean_start = true;
	}

#ifdef WITH_BRIDGE
	if(context->bridge){
		bridge__cleanup(context);
	}
#endif

	alias__free_all(context);
	context__cleanup_out_packets(context);

	mosquitto__free(context->auth_method);
	context->auth_method = NULL;

	mosquitto__free(context->username);
	context->username = NULL;

	mosquitto__free(context->password);
	context->password = NULL;

	net__socket_close(context);
	if(force_free){
		sub__clean_session(context);
	}
	db__messages_delete(context, force_free);

	mosquitto__free(context->address);
	context->address = NULL;

	context__send_will(context);

	if(context->id){
		context__remove_from_by_id(context);
		mosquitto__free(context->id);
		context->id = NULL;
	}
	packet__cleanup(&(context->in_packet));
	context__cleanup_out_packets(context);
#if defined(WITH_BROKER) && defined(__GLIBC__) && defined(WITH_ADNS)
	if(context->adns){
		gai_cancel(context->adns);
		mosquitto__free((struct addrinfo *)context->adns->ar_request);
		mosquitto__free(context->adns);
	}
#endif
	if(force_free){
		mosquitto__free(context);
	}
}","void context__cleanup(struct mosquitto *VAR_0, bool VAR_1)
{
	if(!VAR_0) return;

	if(VAR_1){
		VAR_0->clean_start = true;
	}

#ifdef VAR_2
	if(VAR_0->bridge){
		bridge__cleanup(VAR_0);
	}
#endif

	alias__free_all(VAR_0);
	context__cleanup_out_packets(VAR_0);

	mosquitto__free(VAR_0->auth_method);
	VAR_0->auth_method = NULL;

	mosquitto__free(VAR_0->username);
	VAR_0->username = NULL;

	mosquitto__free(VAR_0->password);
	VAR_0->password = NULL;

	net__socket_close(VAR_0);
	if(VAR_1){
		sub__clean_session(VAR_0);
	}
	db__messages_delete(VAR_0, VAR_1);

	mosquitto__free(VAR_0->address);
	VAR_0->address = NULL;

	context__send_will(VAR_0);

	if(VAR_0->id){
		context__remove_from_by_id(VAR_0);
		mosquitto__free(VAR_0->id);
		VAR_0->id = NULL;
	}
	packet__cleanup(&(VAR_0->in_packet));
	context__cleanup_out_packets(VAR_0);
#if defined(VAR_3) && defined(VAR_4) && defined(VAR_5)
	if(VAR_0->adns){
		gai_cancel(VAR_0->adns);
		mosquitto__free((struct addrinfo *)VAR_0->adns->ar_request);
		mosquitto__free(VAR_0->adns);
	}
#endif
	if(VAR_1){
		mosquitto__free(VAR_0);
	}
}",eclipse/mosquitto/6113eac95a9df634fbc858be542c4a0456bfe7b9/context.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,7 +1,5 @@
 void context__cleanup(struct mosquitto *context, bool force_free)
 {
-	struct mosquitto__packet *packet;
-
 	if(!context) return;
 
 	if(force_free){
@@ -15,6 +13,7 @@
 #endif
 
 	alias__free_all(context);
+	context__cleanup_out_packets(context);
 
 	mosquitto__free(context->auth_method);
 	context->auth_method = NULL;
@@ -42,18 +41,7 @@
 		context->id = NULL;
 	}
 	packet__cleanup(&(context->in_packet));
-	if(context->current_out_packet){
-		packet__cleanup(context->current_out_packet);
-		mosquitto__free(context->current_out_packet);
-		context->current_out_packet = NULL;
-	}
-	while(context->out_packet){
-		packet__cleanup(context->out_packet);
-		packet = context->out_packet;
-		context->out_packet = context->out_packet->next;
-		mosquitto__free(packet);
-	}
-	context->out_packet_count = 0;
+	context__cleanup_out_packets(context);
 #if defined(WITH_BROKER) && defined(__GLIBC__) && defined(WITH_ADNS)
 	if(context->adns){
 		gai_cancel(context->adns);","{'deleted_lines': ['\tstruct mosquitto__packet *packet;', '', '\tif(context->current_out_packet){', '\t\tpacket__cleanup(context->current_out_packet);', '\t\tmosquitto__free(context->current_out_packet);', '\t\tcontext->current_out_packet = NULL;', '\t}', '\twhile(context->out_packet){', '\t\tpacket__cleanup(context->out_packet);', '\t\tpacket = context->out_packet;', '\t\tcontext->out_packet = context->out_packet->next;', '\t\tmosquitto__free(packet);', '\t}', '\tcontext->out_packet_count = 0;'], 'added_lines': ['\tcontext__cleanup_out_packets(context);', '\tcontext__cleanup_out_packets(context);']}",True,"The broker in Eclipse Mosquitto 1.3.2 through 2.x before 2.0.16 has a memory leak that can be abused remotely when a client sends many QoS 2 messages with duplicate message IDs, and fails to respond to PUBREC commands. This occurs because of mishandling of EAGAIN from the libc send function.",7.5,HIGH,2,test,2023-06-13T10:22:03Z,4
CVE-2023-28366,['CWE-401'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,eclipse/mosquitto,Fix for CVE-2023-28366,6113eac95a9df634fbc858be542c4a0456bfe7b9,https://github.com/eclipse/mosquitto/commit/6113eac95a9df634fbc858be542c4a0456bfe7b9,src/database.c,db__message_store_find,"int db__message_store_find(struct mosquitto *context, uint16_t mid, struct mosquitto_msg_store **stored)
{
struct mosquitto_client_msg *tail;
if(!context) return MOSQ_ERR_INVAL;
*stored = NULL;
DL_FOREACH(context->msgs_in.inflight, tail){
if(tail->store->source_mid == mid){
*stored = tail->store;
return MOSQ_ERR_SUCCESS;
}
}
DL_FOREACH(context->msgs_in.queued, tail){
if(tail->store->source_mid == mid){
*stored = tail->store;
return MOSQ_ERR_SUCCESS;
}
}
return 1;
}","int db__message_store_find(struct mosquitto *VAR_0, uint16_t VAR_1, struct mosquitto_msg_store **VAR_2)
{
struct mosquitto_client_msg *VAR_3;
if(!VAR_0) return VAR_4;
*VAR_2 = NULL;
DL_FOREACH(VAR_0->msgs_in.inflight, VAR_3){
if(VAR_3->store->source_mid == VAR_1){
*VAR_2 = VAR_3->store;
return VAR_5;
}
}
DL_FOREACH(VAR_0->msgs_in.queued, VAR_3){
if(VAR_3->store->source_mid == VAR_1){
*VAR_2 = VAR_3->store;
return VAR_5;
}
}
return 1;
}",eclipse/mosquitto/6113eac95a9df634fbc858be542c4a0456bfe7b9/database.c/vul/before/1.json,"int db__message_store_find(struct mosquitto *context, uint16_t mid, struct mosquitto_client_msg **client_msg)
{
	struct mosquitto_client_msg *cmsg;

	*client_msg = NULL;

	if(!context) return MOSQ_ERR_INVAL;

	DL_FOREACH(context->msgs_in.inflight, cmsg){
		if(cmsg->store->source_mid == mid){
			*client_msg = cmsg;
			return MOSQ_ERR_SUCCESS;
		}
	}

	DL_FOREACH(context->msgs_in.queued, cmsg){
		if(cmsg->store->source_mid == mid){
			*client_msg = cmsg;
			return MOSQ_ERR_SUCCESS;
		}
	}

	return 1;
}","int db__message_store_find(struct mosquitto *VAR_0, uint16_t VAR_1, struct mosquitto_client_msg **VAR_2)
{
	struct mosquitto_client_msg *VAR_3;

	*VAR_2 = NULL;

	if(!VAR_0) return VAR_4;

	DL_FOREACH(VAR_0->msgs_in.inflight, VAR_3){
		if(VAR_3->store->source_mid == VAR_1){
			*VAR_2 = VAR_3;
			return VAR_5;
		}
	}

	DL_FOREACH(VAR_0->msgs_in.queued, VAR_3){
		if(VAR_3->store->source_mid == VAR_1){
			*VAR_2 = VAR_3;
			return VAR_5;
		}
	}

	return 1;
}",eclipse/mosquitto/6113eac95a9df634fbc858be542c4a0456bfe7b9/database.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,20 +1,21 @@
-int db__message_store_find(struct mosquitto *context, uint16_t mid, struct mosquitto_msg_store **stored)
+int db__message_store_find(struct mosquitto *context, uint16_t mid, struct mosquitto_client_msg **client_msg)
 {
-	struct mosquitto_client_msg *tail;
+	struct mosquitto_client_msg *cmsg;
+
+	*client_msg = NULL;
 
 	if(!context) return MOSQ_ERR_INVAL;
 
-	*stored = NULL;
-	DL_FOREACH(context->msgs_in.inflight, tail){
-		if(tail->store->source_mid == mid){
-			*stored = tail->store;
+	DL_FOREACH(context->msgs_in.inflight, cmsg){
+		if(cmsg->store->source_mid == mid){
+			*client_msg = cmsg;
 			return MOSQ_ERR_SUCCESS;
 		}
 	}
 
-	DL_FOREACH(context->msgs_in.queued, tail){
-		if(tail->store->source_mid == mid){
-			*stored = tail->store;
+	DL_FOREACH(context->msgs_in.queued, cmsg){
+		if(cmsg->store->source_mid == mid){
+			*client_msg = cmsg;
 			return MOSQ_ERR_SUCCESS;
 		}
 	}","{'deleted_lines': ['int db__message_store_find(struct mosquitto *context, uint16_t mid, struct mosquitto_msg_store **stored)', '\tstruct mosquitto_client_msg *tail;', '\t*stored = NULL;', '\tDL_FOREACH(context->msgs_in.inflight, tail){', '\t\tif(tail->store->source_mid == mid){', '\t\t\t*stored = tail->store;', '\tDL_FOREACH(context->msgs_in.queued, tail){', '\t\tif(tail->store->source_mid == mid){', '\t\t\t*stored = tail->store;'], 'added_lines': ['int db__message_store_find(struct mosquitto *context, uint16_t mid, struct mosquitto_client_msg **client_msg)', '\tstruct mosquitto_client_msg *cmsg;', '', '\t*client_msg = NULL;', '\tDL_FOREACH(context->msgs_in.inflight, cmsg){', '\t\tif(cmsg->store->source_mid == mid){', '\t\t\t*client_msg = cmsg;', '\tDL_FOREACH(context->msgs_in.queued, cmsg){', '\t\tif(cmsg->store->source_mid == mid){', '\t\t\t*client_msg = cmsg;']}",True,"The broker in Eclipse Mosquitto 1.3.2 through 2.x before 2.0.16 has a memory leak that can be abused remotely when a client sends many QoS 2 messages with duplicate message IDs, and fails to respond to PUBREC commands. This occurs because of mishandling of EAGAIN from the libc send function.",7.5,HIGH,2,test,2023-06-13T10:22:03Z,4
CVE-2023-28366,['CWE-401'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,eclipse/mosquitto,Fix for CVE-2023-28366,6113eac95a9df634fbc858be542c4a0456bfe7b9,https://github.com/eclipse/mosquitto/commit/6113eac95a9df634fbc858be542c4a0456bfe7b9,src/handle_publish.c,handle__publish,"int handle__publish(struct mosquitto *context)
{
uint8_t dup;
int rc = 0;
int rc2;
uint8_t header = context->in_packet.command;
int res = 0;
struct mosquitto_msg_store *msg, *stored = NULL;
size_t len;
uint16_t slen;
char *topic_mount;
mosquitto_property *properties = NULL;
mosquitto_property *p, *p_prev;
mosquitto_property *msg_properties_last;
uint32_t message_expiry_interval = 0;
int topic_alias = -1;
uint8_t reason_code = 0;
uint16_t mid = 0;
if(context->state != mosq_cs_active){
return MOSQ_ERR_PROTOCOL;
}
msg = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));
if(msg == NULL){
return MOSQ_ERR_NOMEM;
}
dup = (header & 0x08)>>3;
msg->qos = (header & 0x06)>>1;
if(dup == 1 && msg->qos == 0){
log__printf(NULL, MOSQ_LOG_INFO,
""Invalid PUBLISH (QoS=0 and DUP=1) from %s, disconnecting."", context->id);
db__msg_store_free(msg);
return MOSQ_ERR_MALFORMED_PACKET;
}
if(msg->qos == 3){
log__printf(NULL, MOSQ_LOG_INFO,
""Invalid QoS in PUBLISH from %s, disconnecting."", context->id);
db__msg_store_free(msg);
return MOSQ_ERR_MALFORMED_PACKET;
}
if(msg->qos > context->max_qos){
log__printf(NULL, MOSQ_LOG_INFO,
""Too high QoS in PUBLISH from %s, disconnecting."", context->id);
db__msg_store_free(msg);
return MOSQ_ERR_QOS_NOT_SUPPORTED;
}
msg->retain = (header & 0x01);
if(msg->retain && db.config->retain_available == false){
db__msg_store_free(msg);
return MOSQ_ERR_RETAIN_NOT_SUPPORTED;
}
if(packet__read_string(&context->in_packet, &msg->topic, &slen)){
db__msg_store_free(msg);
return MOSQ_ERR_MALFORMED_PACKET;
}
if(!slen && context->protocol != mosq_p_mqtt5){
db__msg_store_free(msg);
return MOSQ_ERR_MALFORMED_PACKET;
}
if(msg->qos > 0){
if(packet__read_uint16(&context->in_packet, &mid)){
db__msg_store_free(msg);
return MOSQ_ERR_MALFORMED_PACKET;
}
if(mid == 0){
db__msg_store_free(msg);
return MOSQ_ERR_PROTOCOL;
}
msg->source_mid = mid;
}
if(context->protocol == mosq_p_mqtt5){
rc = property__read_all(CMD_PUBLISH, &context->in_packet, &properties);
if(rc){
db__msg_store_free(msg);
return rc;
}
p = properties;
p_prev = NULL;
msg->properties = NULL;
msg_properties_last = NULL;
while(p){
switch(p->identifier){
case MQTT_PROP_CONTENT_TYPE:
case MQTT_PROP_CORRELATION_DATA:
case MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:
case MQTT_PROP_RESPONSE_TOPIC:
case MQTT_PROP_USER_PROPERTY:
if(msg->properties){
msg_properties_last->next = p;
msg_properties_last = p;
}else{
msg->properties = p;
msg_properties_last = p;
}
if(p_prev){
p_prev->next = p->next;
p = p_prev->next;
}else{
properties = p->next;
p = properties;
}
msg_properties_last->next = NULL;
break;
case MQTT_PROP_TOPIC_ALIAS:
topic_alias = p->value.i16;
p_prev = p;
p = p->next;
break;
case MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:
message_expiry_interval = p->value.i32;
p_prev = p;
p = p->next;
break;
case MQTT_PROP_SUBSCRIPTION_IDENTIFIER:
p_prev = p;
p = p->next;
break;
default:
p = p->next;
break;
}
}
}
mosquitto_property_free_all(&properties);
if(topic_alias == 0 || (context->listener && topic_alias > context->listener->max_topic_alias)){
db__msg_store_free(msg);
return MOSQ_ERR_TOPIC_ALIAS_INVALID;
}else if(topic_alias > 0){
if(msg->topic){
rc = alias__add(context, msg->topic, (uint16_t)topic_alias);
if(rc){
db__msg_store_free(msg);
return rc;
}
}else{
rc = alias__find(context, &msg->topic, (uint16_t)topic_alias);
if(rc){
db__msg_store_free(msg);
return MOSQ_ERR_PROTOCOL;
}
}
}
#ifdef WITH_BRIDGE
rc = bridge__remap_topic_in(context, &msg->topic);
if(rc){
db__msg_store_free(msg);
return rc;
}
#endif
if(mosquitto_pub_topic_check(msg->topic) != MOSQ_ERR_SUCCESS){
db__msg_store_free(msg);
return MOSQ_ERR_MALFORMED_PACKET;
}
msg->payloadlen = context->in_packet.remaining_length - context->in_packet.pos;
G_PUB_BYTES_RECEIVED_INC(msg->payloadlen);
if(context->listener && context->listener->mount_point){
len = strlen(context->listener->mount_point) + strlen(msg->topic) + 1;
topic_mount = mosquitto__malloc(len+1);
if(!topic_mount){
db__msg_store_free(msg);
return MOSQ_ERR_NOMEM;
}
snprintf(topic_mount, len, ""%s%s"", context->listener->mount_point, msg->topic);
topic_mount[len] = '\0';
mosquitto__free(msg->topic);
msg->topic = topic_mount;
}
if(msg->payloadlen){
if(db.config->message_size_limit && msg->payloadlen > db.config->message_size_limit){
log__printf(NULL, MOSQ_LOG_DEBUG, ""Dropped too large PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);
reason_code = MQTT_RC_PACKET_TOO_LARGE;
goto process_bad_message;
}
msg->payload = mosquitto__malloc(msg->payloadlen+1);
if(msg->payload == NULL){
db__msg_store_free(msg);
return MOSQ_ERR_NOMEM;
}
((uint8_t *)msg->payload)[msg->payloadlen] = 0;
if(packet__read_bytes(&context->in_packet, msg->payload, msg->payloadlen)){
db__msg_store_free(msg);
return MOSQ_ERR_MALFORMED_PACKET;
}
}
rc = mosquitto_acl_check(context, msg->topic, msg->payloadlen, msg->payload, msg->qos, msg->retain, MOSQ_ACL_WRITE);
if(rc == MOSQ_ERR_ACL_DENIED){
log__printf(NULL, MOSQ_LOG_DEBUG,
""Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"",
context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,
(long)msg->payloadlen);
reason_code = MQTT_RC_NOT_AUTHORIZED;
goto process_bad_message;
}else if(rc != MOSQ_ERR_SUCCESS){
db__msg_store_free(msg);
return rc;
}
log__printf(NULL, MOSQ_LOG_DEBUG, ""Received PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);
if(!strncmp(msg->topic, ""$CONTROL/"", 9)){
#ifdef WITH_CONTROL
rc = control__process(context, msg);
db__msg_store_free(msg);
return rc;
#else
reason_code = MQTT_RC_IMPLEMENTATION_SPECIFIC;
goto process_bad_message;
#endif
}
{
rc = plugin__handle_message(context, msg);
if(rc == MOSQ_ERR_ACL_DENIED){
log__printf(NULL, MOSQ_LOG_DEBUG,
""Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"",
context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,
(long)msg->payloadlen);
reason_code = MQTT_RC_NOT_AUTHORIZED;
goto process_bad_message;
}else if(rc != MOSQ_ERR_SUCCESS){
db__msg_store_free(msg);
return rc;
}
}
if(msg->qos > 0){
db__message_store_find(context, msg->source_mid, &stored);
}
if(stored && msg->source_mid != 0 &&
(stored->qos != msg->qos
|| stored->payloadlen != msg->payloadlen
|| strcmp(stored->topic, msg->topic)
|| memcmp(stored->payload, msg->payload, msg->payloadlen) )){
log__printf(NULL, MOSQ_LOG_WARNING, ""Reused message ID %u from %s detected. Clearing from storage."", msg->source_mid, context->id);
db__message_remove_incoming(context, msg->source_mid);
stored = NULL;
}
if(!stored){
if(msg->qos == 0
|| db__ready_for_flight(context, mosq_md_in, msg->qos)
|| db__ready_for_queue(context, msg->qos, &context->msgs_in)){
dup = 0;
rc = db__message_store(context, msg, message_expiry_interval, 0, mosq_mo_client);
if(rc) return rc;
}else{
reason_code = MQTT_RC_QUOTA_EXCEEDED;
goto process_bad_message;
}
stored = msg;
msg = NULL;
}else{
db__msg_store_free(msg);
msg = NULL;
dup = 1;
}
switch(stored->qos){
case 0:
rc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);
if(rc2 > 0) rc = 1;
break;
case 1:
util__decrement_receive_quota(context);
rc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);
if(rc2 == MOSQ_ERR_SUCCESS || context->protocol != mosq_p_mqtt5){
if(send__puback(context, mid, 0, NULL)) rc = 1;
}else if(rc2 == MOSQ_ERR_NO_SUBSCRIBERS){
if(send__puback(context, mid, MQTT_RC_NO_MATCHING_SUBSCRIBERS, NULL)) rc = 1;
}else{
rc = rc2;
}
break;
case 2:
if(dup == 0){
res = db__message_insert(context, stored->source_mid, mosq_md_in, stored->qos, stored->retain, stored, NULL, false);
}else{
res = 0;
}
if(!res){
if(send__pubrec(context, stored->source_mid, 0, NULL)) rc = 1;
}else if(res == 1){
rc = 1;
}
break;
}
db__message_write_queued_in(context);
return rc;
process_bad_message:
rc = 1;
if(msg){
switch(msg->qos){
case 0:
rc = MOSQ_ERR_SUCCESS;
break;
case 1:
rc = send__puback(context, msg->source_mid, reason_code, NULL);
break;
case 2:
rc = send__pubrec(context, msg->source_mid, reason_code, NULL);
break;
}
db__msg_store_free(msg);
}
return rc;
}","int handle__publish(struct mosquitto *VAR_0)
{
uint8_t VAR_1;
int VAR_2 = 0;
int VAR_3;
uint8_t VAR_4 = VAR_0->in_packet.command;
int VAR_5 = 0;
struct mosquitto_msg_store *VAR_6, *VAR_7 = NULL;
size_t VAR_8;
uint16_t VAR_9;
char *VAR_10;
mosquitto_property *VAR_11 = NULL;
mosquitto_property *VAR_12, *VAR_13;
mosquitto_property *VAR_14;
uint32_t VAR_15 = 0;
int VAR_16 = -1;
uint8_t VAR_17 = 0;
uint16_t VAR_18 = 0;
if(VAR_0->state != VAR_19){
return VAR_20;
}
VAR_6 = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));
if(VAR_6 == NULL){
return VAR_21;
}
VAR_1 = (VAR_4 & 0x08)>>3;
VAR_6->qos = (VAR_4 & 0x06)>>1;
if(VAR_1 == 1 && VAR_6->qos == 0){
log__printf(NULL, VAR_22,
""Invalid PUBLISH (QoS=0 and DUP=1) from %s, disconnecting."", VAR_0->id);
db__msg_store_free(VAR_6);
return VAR_23;
}
if(VAR_6->qos == 3){
log__printf(NULL, VAR_22,
""Invalid QoS in PUBLISH from %s, disconnecting."", VAR_0->id);
db__msg_store_free(VAR_6);
return VAR_23;
}
if(VAR_6->qos > VAR_0->max_qos){
log__printf(NULL, VAR_22,
""Too high QoS in PUBLISH from %s, disconnecting."", VAR_0->id);
db__msg_store_free(VAR_6);
return VAR_24;
}
VAR_6->retain = (VAR_4 & 0x01);
if(VAR_6->retain && VAR_25.config->retain_available == false){
db__msg_store_free(VAR_6);
return VAR_26;
}
if(packet__read_string(&VAR_0->in_packet, &VAR_6->topic, &VAR_9)){
db__msg_store_free(VAR_6);
return VAR_23;
}
if(!VAR_9 && VAR_0->protocol != VAR_27){
db__msg_store_free(VAR_6);
return VAR_23;
}
if(VAR_6->qos > 0){
if(packet__read_uint16(&VAR_0->in_packet, &VAR_18)){
db__msg_store_free(VAR_6);
return VAR_23;
}
if(VAR_18 == 0){
db__msg_store_free(VAR_6);
return VAR_20;
}
VAR_6->source_mid = VAR_18;
}
if(VAR_0->protocol == VAR_27){
VAR_2 = property__read_all(VAR_28, &VAR_0->in_packet, &VAR_11);
if(VAR_2){
db__msg_store_free(VAR_6);
return VAR_2;
}
VAR_12 = VAR_11;
VAR_13 = NULL;
VAR_6->properties = NULL;
VAR_14 = NULL;
while(VAR_12){
switch(VAR_12->identifier){
case VAR_29:
case VAR_30:
case VAR_31:
case VAR_32:
case VAR_33:
if(VAR_6->properties){
VAR_14->next = VAR_12;
VAR_14 = VAR_12;
}else{
VAR_6->properties = VAR_12;
VAR_14 = VAR_12;
}
if(VAR_13){
VAR_13->next = VAR_12->next;
VAR_12 = VAR_13->next;
}else{
VAR_11 = VAR_12->next;
VAR_12 = VAR_11;
}
VAR_14->next = NULL;
break;
case VAR_34:
VAR_16 = VAR_12->value.i16;
VAR_13 = VAR_12;
VAR_12 = VAR_12->next;
break;
case VAR_35:
VAR_15 = VAR_12->value.i32;
VAR_13 = VAR_12;
VAR_12 = VAR_12->next;
break;
case VAR_36:
VAR_13 = VAR_12;
VAR_12 = VAR_12->next;
break;
default:
VAR_12 = VAR_12->next;
break;
}
}
}
mosquitto_property_free_all(&VAR_11);
if(VAR_16 == 0 || (VAR_0->listener && VAR_16 > VAR_0->listener->max_topic_alias)){
db__msg_store_free(VAR_6);
return VAR_37;
}else if(VAR_16 > 0){
if(VAR_6->topic){
VAR_2 = alias__add(VAR_0, VAR_6->topic, (uint16_t)VAR_16);
if(VAR_2){
db__msg_store_free(VAR_6);
return VAR_2;
}
}else{
VAR_2 = alias__find(VAR_0, &VAR_6->topic, (uint16_t)VAR_16);
if(VAR_2){
db__msg_store_free(VAR_6);
return VAR_20;
}
}
}
#ifdef VAR_38
VAR_2 = bridge__remap_topic_in(VAR_0, &VAR_6->topic);
if(VAR_2){
db__msg_store_free(VAR_6);
return VAR_2;
}
#endif
if(mosquitto_pub_topic_check(VAR_6->topic) != VAR_39){
db__msg_store_free(VAR_6);
return VAR_23;
}
VAR_6->payloadlen = VAR_0->in_packet.remaining_length - VAR_0->in_packet.pos;
G_PUB_BYTES_RECEIVED_INC(VAR_6->payloadlen);
if(VAR_0->listener && VAR_0->listener->mount_point){
VAR_8 = strlen(VAR_0->listener->mount_point) + strlen(VAR_6->topic) + 1;
VAR_10 = mosquitto__malloc(VAR_8+1);
if(!VAR_10){
db__msg_store_free(VAR_6);
return VAR_21;
}
snprintf(VAR_10, VAR_8, ""%s%s"", VAR_0->listener->mount_point, VAR_6->topic);
VAR_10[VAR_8] = '\0';
mosquitto__free(VAR_6->topic);
VAR_6->topic = VAR_10;
}
if(VAR_6->payloadlen){
if(VAR_25.config->message_size_limit && VAR_6->payloadlen > VAR_25.config->message_size_limit){
log__printf(NULL, VAR_40, ""Dropped too large PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"", VAR_0->id, VAR_1, VAR_6->qos, VAR_6->retain, VAR_6->source_mid, VAR_6->topic, (long)VAR_6->payloadlen);
VAR_17 = VAR_41;
goto process_bad_message;
}
VAR_6->payload = mosquitto__malloc(VAR_6->payloadlen+1);
if(VAR_6->payload == NULL){
db__msg_store_free(VAR_6);
return VAR_21;
}
((uint8_t *)VAR_6->payload)[VAR_6->payloadlen] = 0;
if(packet__read_bytes(&VAR_0->in_packet, VAR_6->payload, VAR_6->payloadlen)){
db__msg_store_free(VAR_6);
return VAR_23;
}
}
VAR_2 = mosquitto_acl_check(VAR_0, VAR_6->topic, VAR_6->payloadlen, VAR_6->payload, VAR_6->qos, VAR_6->retain, VAR_42);
if(VAR_2 == VAR_43){
log__printf(NULL, VAR_40,
""Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"",
VAR_0->id, VAR_1, VAR_6->qos, VAR_6->retain, VAR_6->source_mid, VAR_6->topic,
(long)VAR_6->payloadlen);
VAR_17 = VAR_44;
goto process_bad_message;
}else if(VAR_2 != VAR_39){
db__msg_store_free(VAR_6);
return VAR_2;
}
log__printf(NULL, VAR_40, ""Received PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"", VAR_0->id, VAR_1, VAR_6->qos, VAR_6->retain, VAR_6->source_mid, VAR_6->topic, (long)VAR_6->payloadlen);
if(!strncmp(VAR_6->topic, ""$CONTROL/"", 9)){
#ifdef VAR_45
VAR_2 = control__process(VAR_0, VAR_6);
db__msg_store_free(VAR_6);
return VAR_2;
#else
VAR_17 = VAR_46;
goto process_bad_message;
#endif
}
{
VAR_2 = plugin__handle_message(VAR_0, VAR_6);
if(VAR_2 == VAR_43){
log__printf(NULL, VAR_40,
""Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"",
VAR_0->id, VAR_1, VAR_6->qos, VAR_6->retain, VAR_6->source_mid, VAR_6->topic,
(long)VAR_6->payloadlen);
VAR_17 = VAR_44;
goto process_bad_message;
}else if(VAR_2 != VAR_39){
db__msg_store_free(VAR_6);
return VAR_2;
}
}
if(VAR_6->qos > 0){
db__message_store_find(VAR_0, VAR_6->source_mid, &VAR_7);
}
if(VAR_7 && VAR_6->source_mid != 0 &&
(VAR_7->qos != VAR_6->qos
|| VAR_7->payloadlen != VAR_6->payloadlen
|| strcmp(VAR_7->topic, VAR_6->topic)
|| memcmp(VAR_7->payload, VAR_6->payload, VAR_6->payloadlen) )){
log__printf(NULL, VAR_47, ""Reused message ID %u from %s detected. Clearing from storage."", VAR_6->source_mid, VAR_0->id);
db__message_remove_incoming(VAR_0, VAR_6->source_mid);
VAR_7 = NULL;
}
if(!VAR_7){
if(VAR_6->qos == 0
|| db__ready_for_flight(VAR_0, VAR_48, VAR_6->qos)
|| db__ready_for_queue(VAR_0, VAR_6->qos, &VAR_0->msgs_in)){
VAR_1 = 0;
VAR_2 = db__message_store(VAR_0, VAR_6, VAR_15, 0, VAR_49);
if(VAR_2) return VAR_2;
}else{
VAR_17 = VAR_50;
goto process_bad_message;
}
VAR_7 = VAR_6;
VAR_6 = NULL;
}else{
db__msg_store_free(VAR_6);
VAR_6 = NULL;
VAR_1 = 1;
}
switch(VAR_7->qos){
case 0:
VAR_3 = sub__messages_queue(VAR_0->id, VAR_7->topic, VAR_7->qos, VAR_7->retain, &VAR_7);
if(VAR_3 > 0) VAR_2 = 1;
break;
case 1:
util__decrement_receive_quota(VAR_0);
VAR_3 = sub__messages_queue(VAR_0->id, VAR_7->topic, VAR_7->qos, VAR_7->retain, &VAR_7);
if(VAR_3 == VAR_39 || VAR_0->protocol != VAR_27){
if(send__puback(VAR_0, VAR_18, 0, NULL)) VAR_2 = 1;
}else if(VAR_3 == VAR_51){
if(send__puback(VAR_0, VAR_18, VAR_52, NULL)) VAR_2 = 1;
}else{
VAR_2 = VAR_3;
}
break;
case 2:
if(VAR_1 == 0){
VAR_5 = db__message_insert(VAR_0, VAR_7->source_mid, VAR_48, VAR_7->qos, VAR_7->retain, VAR_7, NULL, false);
}else{
VAR_5 = 0;
}
if(!VAR_5){
if(send__pubrec(VAR_0, VAR_7->source_mid, 0, NULL)) VAR_2 = 1;
}else if(VAR_5 == 1){
VAR_2 = 1;
}
break;
}
db__message_write_queued_in(VAR_0);
return VAR_2;
process_bad_message:
VAR_2 = 1;
if(VAR_6){
switch(VAR_6->qos){
case 0:
VAR_2 = VAR_39;
break;
case 1:
VAR_2 = send__puback(VAR_0, VAR_6->source_mid, VAR_17, NULL);
break;
case 2:
VAR_2 = send__pubrec(VAR_0, VAR_6->source_mid, VAR_17, NULL);
break;
}
db__msg_store_free(VAR_6);
}
return VAR_2;
}",eclipse/mosquitto/6113eac95a9df634fbc858be542c4a0456bfe7b9/handle_publish.c/vul/before/0.json,"int handle__publish(struct mosquitto *context)
{
	uint8_t dup;
	int rc = 0;
	int rc2;
	uint8_t header = context->in_packet.command;
	int res = 0;
	struct mosquitto_msg_store *msg, *stored = NULL;
	struct mosquitto_client_msg *cmsg_stored = NULL;
	size_t len;
	uint16_t slen;
	char *topic_mount;
	mosquitto_property *properties = NULL;
	mosquitto_property *p, *p_prev;
	mosquitto_property *msg_properties_last;
	uint32_t message_expiry_interval = 0;
	int topic_alias = -1;
	uint8_t reason_code = 0;
	uint16_t mid = 0;

	if(context->state != mosq_cs_active){
		return MOSQ_ERR_PROTOCOL;
	}

	msg = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));
	if(msg == NULL){
		return MOSQ_ERR_NOMEM;
	}

	dup = (header & 0x08)>>3;
	msg->qos = (header & 0x06)>>1;
	if(dup == 1 && msg->qos == 0){
		log__printf(NULL, MOSQ_LOG_INFO,
				""Invalid PUBLISH (QoS=0 and DUP=1) from %s, disconnecting."", context->id);
		db__msg_store_free(msg);
		return MOSQ_ERR_MALFORMED_PACKET;
	}
	if(msg->qos == 3){
		log__printf(NULL, MOSQ_LOG_INFO,
				""Invalid QoS in PUBLISH from %s, disconnecting."", context->id);
		db__msg_store_free(msg);
		return MOSQ_ERR_MALFORMED_PACKET;
	}
	if(msg->qos > context->max_qos){
		log__printf(NULL, MOSQ_LOG_INFO,
				""Too high QoS in PUBLISH from %s, disconnecting."", context->id);
		db__msg_store_free(msg);
		return MOSQ_ERR_QOS_NOT_SUPPORTED;
	}
	msg->retain = (header & 0x01);

	if(msg->retain && db.config->retain_available == false){
		db__msg_store_free(msg);
		return MOSQ_ERR_RETAIN_NOT_SUPPORTED;
	}

	if(packet__read_string(&context->in_packet, &msg->topic, &slen)){
		db__msg_store_free(msg);
		return MOSQ_ERR_MALFORMED_PACKET;
	}
	if(!slen && context->protocol != mosq_p_mqtt5){
		/* Invalid publish topic, disconnect client. */
		db__msg_store_free(msg);
		return MOSQ_ERR_MALFORMED_PACKET;
	}

	if(msg->qos > 0){
		if(packet__read_uint16(&context->in_packet, &mid)){
			db__msg_store_free(msg);
			return MOSQ_ERR_MALFORMED_PACKET;
		}
		if(mid == 0){
			db__msg_store_free(msg);
			return MOSQ_ERR_PROTOCOL;
		}
		/* It is important to have a separate copy of mid, because msg may be
		 * freed before we want to send a PUBACK/PUBREC. */
		msg->source_mid = mid;
	}

	/* Handle properties */
	if(context->protocol == mosq_p_mqtt5){
		rc = property__read_all(CMD_PUBLISH, &context->in_packet, &properties);
		if(rc){
			db__msg_store_free(msg);
			return rc;
		}

		p = properties;
		p_prev = NULL;
		msg->properties = NULL;
		msg_properties_last = NULL;
		while(p){
			switch(p->identifier){
				case MQTT_PROP_CONTENT_TYPE:
				case MQTT_PROP_CORRELATION_DATA:
				case MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:
				case MQTT_PROP_RESPONSE_TOPIC:
				case MQTT_PROP_USER_PROPERTY:
					if(msg->properties){
						msg_properties_last->next = p;
						msg_properties_last = p;
					}else{
						msg->properties = p;
						msg_properties_last = p;
					}
					if(p_prev){
						p_prev->next = p->next;
						p = p_prev->next;
					}else{
						properties = p->next;
						p = properties;
					}
					msg_properties_last->next = NULL;
					break;

				case MQTT_PROP_TOPIC_ALIAS:
					topic_alias = p->value.i16;
					p_prev = p;
					p = p->next;
					break;

				case MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:
					message_expiry_interval = p->value.i32;
					p_prev = p;
					p = p->next;
					break;

				case MQTT_PROP_SUBSCRIPTION_IDENTIFIER:
					p_prev = p;
					p = p->next;
					break;

				default:
					p = p->next;
					break;
			}
		}
	}
	mosquitto_property_free_all(&properties);

	if(topic_alias == 0 || (context->listener && topic_alias > context->listener->max_topic_alias)){
		db__msg_store_free(msg);
		return MOSQ_ERR_TOPIC_ALIAS_INVALID;
	}else if(topic_alias > 0){
		if(msg->topic){
			rc = alias__add(context, msg->topic, (uint16_t)topic_alias);
			if(rc){
				db__msg_store_free(msg);
				return rc;
			}
		}else{
			rc = alias__find(context, &msg->topic, (uint16_t)topic_alias);
			if(rc){
				db__msg_store_free(msg);
				return MOSQ_ERR_PROTOCOL;
			}
		}
	}

#ifdef WITH_BRIDGE
	rc = bridge__remap_topic_in(context, &msg->topic);
	if(rc){
		db__msg_store_free(msg);
		return rc;
	}

#endif
	if(mosquitto_pub_topic_check(msg->topic) != MOSQ_ERR_SUCCESS){
		/* Invalid publish topic, just swallow it. */
		db__msg_store_free(msg);
		return MOSQ_ERR_MALFORMED_PACKET;
	}

	msg->payloadlen = context->in_packet.remaining_length - context->in_packet.pos;
	G_PUB_BYTES_RECEIVED_INC(msg->payloadlen);
	if(context->listener && context->listener->mount_point){
		len = strlen(context->listener->mount_point) + strlen(msg->topic) + 1;
		topic_mount = mosquitto__malloc(len+1);
		if(!topic_mount){
			db__msg_store_free(msg);
			return MOSQ_ERR_NOMEM;
		}
		snprintf(topic_mount, len, ""%s%s"", context->listener->mount_point, msg->topic);
		topic_mount[len] = '\0';

		mosquitto__free(msg->topic);
		msg->topic = topic_mount;
	}

	if(msg->payloadlen){
		if(db.config->message_size_limit && msg->payloadlen > db.config->message_size_limit){
			log__printf(NULL, MOSQ_LOG_DEBUG, ""Dropped too large PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);
			reason_code = MQTT_RC_PACKET_TOO_LARGE;
			goto process_bad_message;
		}
		msg->payload = mosquitto__malloc(msg->payloadlen+1);
		if(msg->payload == NULL){
			db__msg_store_free(msg);
			return MOSQ_ERR_NOMEM;
		}
		/* Ensure payload is always zero terminated, this is the reason for the extra byte above */
		((uint8_t *)msg->payload)[msg->payloadlen] = 0;

		if(packet__read_bytes(&context->in_packet, msg->payload, msg->payloadlen)){
			db__msg_store_free(msg);
			return MOSQ_ERR_MALFORMED_PACKET;
		}
	}

	/* Check for topic access */
	rc = mosquitto_acl_check(context, msg->topic, msg->payloadlen, msg->payload, msg->qos, msg->retain, MOSQ_ACL_WRITE);
	if(rc == MOSQ_ERR_ACL_DENIED){
		log__printf(NULL, MOSQ_LOG_DEBUG,
				""Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"",
				context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,
				(long)msg->payloadlen);
		reason_code = MQTT_RC_NOT_AUTHORIZED;
		goto process_bad_message;
	}else if(rc != MOSQ_ERR_SUCCESS){
		db__msg_store_free(msg);
		return rc;
	}

	log__printf(NULL, MOSQ_LOG_DEBUG, ""Received PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);

	if(!strncmp(msg->topic, ""$CONTROL/"", 9)){
#ifdef WITH_CONTROL
		rc = control__process(context, msg);
		db__msg_store_free(msg);
		return rc;
#else
		reason_code = MQTT_RC_IMPLEMENTATION_SPECIFIC;
		goto process_bad_message;
#endif
	}

	{
		rc = plugin__handle_message(context, msg);
		if(rc == MOSQ_ERR_ACL_DENIED){
			log__printf(NULL, MOSQ_LOG_DEBUG,
					""Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"",
					context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,
					(long)msg->payloadlen);

			reason_code = MQTT_RC_NOT_AUTHORIZED;
			goto process_bad_message;
		}else if(rc != MOSQ_ERR_SUCCESS){
			db__msg_store_free(msg);
			return rc;
		}
	}

	if(msg->qos > 0){
		db__message_store_find(context, msg->source_mid, &cmsg_stored);
	}

	if(cmsg_stored && cmsg_stored->store && msg->source_mid != 0 &&
			(cmsg_stored->store->qos != msg->qos
			 || cmsg_stored->store->payloadlen != msg->payloadlen
			 || strcmp(cmsg_stored->store->topic, msg->topic)
			 || memcmp(cmsg_stored->store->payload, msg->payload, msg->payloadlen) )){

		log__printf(NULL, MOSQ_LOG_WARNING, ""Reused message ID %u from %s detected. Clearing from storage."", msg->source_mid, context->id);
		db__message_remove_incoming(context, msg->source_mid);
		cmsg_stored = NULL;
	}

	if(!cmsg_stored){
		if(msg->qos == 0
				|| db__ready_for_flight(context, mosq_md_in, msg->qos)
				){

			dup = 0;
			rc = db__message_store(context, msg, message_expiry_interval, 0, mosq_mo_client);
			if(rc) return rc;
		}else{
			/* Client isn't allowed any more incoming messages, so fail early */
			reason_code = MQTT_RC_QUOTA_EXCEEDED;
			goto process_bad_message;
		}
		stored = msg;
		msg = NULL;
		dup = 0;
	}else{
		db__msg_store_free(msg);
		msg = NULL;
		stored = cmsg_stored->store;
		cmsg_stored->dup++;
		dup = cmsg_stored->dup;
	}

	switch(stored->qos){
		case 0:
			rc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);
			if(rc2 > 0) rc = 1;
			break;
		case 1:
			util__decrement_receive_quota(context);
			rc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);
			/* stored may now be free, so don't refer to it */
			if(rc2 == MOSQ_ERR_SUCCESS || context->protocol != mosq_p_mqtt5){
				if(send__puback(context, mid, 0, NULL)) rc = 1;
			}else if(rc2 == MOSQ_ERR_NO_SUBSCRIBERS){
				if(send__puback(context, mid, MQTT_RC_NO_MATCHING_SUBSCRIBERS, NULL)) rc = 1;
			}else{
				rc = rc2;
			}
			break;
		case 2:
			if(dup == 0){
				res = db__message_insert(context, stored->source_mid, mosq_md_in, stored->qos, stored->retain, stored, NULL, false);
			}else{
				res = 0;
			}

			/* db__message_insert() returns 2 to indicate dropped message
			 * due to queue. This isn't an error so don't disconnect them. */
			/* FIXME - this is no longer necessary due to failing early above */
			if(!res){
				if(dup == 0 || dup == 1){
					rc2 = send__pubrec(context, stored->source_mid, 0, NULL);
					if(rc2) rc = rc2;
				}else{
					return MOSQ_ERR_PROTOCOL;
				}
			}else if(res == 1){
				rc = 1;
			}
			break;
	}

	db__message_write_queued_in(context);
	return rc;
process_bad_message:
	rc = 1;
	if(msg){
		switch(msg->qos){
			case 0:
				rc = MOSQ_ERR_SUCCESS;
				break;
			case 1:
				rc = send__puback(context, msg->source_mid, reason_code, NULL);
				break;
			case 2:
				rc = send__pubrec(context, msg->source_mid, reason_code, NULL);
				break;
		}
		db__msg_store_free(msg);
	}
	if(context->out_packet_count >= db.config->max_queued_messages){
		rc = MQTT_RC_QUOTA_EXCEEDED;
	}
	return rc;
}","int handle__publish(struct mosquitto *VAR_0)
{
	uint8_t VAR_1;
	int VAR_2 = 0;
	int VAR_3;
	uint8_t VAR_4 = VAR_0->in_packet.command;
	int VAR_5 = 0;
	struct mosquitto_msg_store *VAR_6, *VAR_7 = NULL;
	struct mosquitto_client_msg *VAR_8 = NULL;
	size_t VAR_9;
	uint16_t VAR_10;
	char *VAR_11;
	mosquitto_property *VAR_12 = NULL;
	mosquitto_property *VAR_13, *VAR_14;
	mosquitto_property *VAR_15;
	uint32_t VAR_16 = 0;
	int VAR_17 = -1;
	uint8_t VAR_18 = 0;
	uint16_t VAR_19 = 0;

	if(VAR_0->state != VAR_20){
		return VAR_21;
	}

	VAR_6 = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));
	if(VAR_6 == NULL){
		return VAR_22;
	}

	VAR_1 = (VAR_4 & 0x08)>>3;
	VAR_6->qos = (VAR_4 & 0x06)>>1;
	if(VAR_1 == 1 && VAR_6->qos == 0){
		log__printf(NULL, VAR_23,
				""Invalid PUBLISH (QoS=0 and DUP=1) from %s, disconnecting."", VAR_0->id);
		db__msg_store_free(VAR_6);
		return VAR_24;
	}
	if(VAR_6->qos == 3){
		log__printf(NULL, VAR_23,
				""Invalid QoS in PUBLISH from %s, disconnecting."", VAR_0->id);
		db__msg_store_free(VAR_6);
		return VAR_24;
	}
	if(VAR_6->qos > VAR_0->max_qos){
		log__printf(NULL, VAR_23,
				""Too high QoS in PUBLISH from %s, disconnecting."", VAR_0->id);
		db__msg_store_free(VAR_6);
		return VAR_25;
	}
	VAR_6->retain = (VAR_4 & 0x01);

	if(VAR_6->retain && VAR_26.config->retain_available == false){
		db__msg_store_free(VAR_6);
		return VAR_27;
	}

	if(packet__read_string(&VAR_0->in_packet, &VAR_6->topic, &VAR_10)){
		db__msg_store_free(VAR_6);
		return VAR_24;
	}
	if(!VAR_10 && VAR_0->protocol != VAR_28){
		/* COMMENT_0 */
		db__msg_store_free(VAR_6);
		return VAR_24;
	}

	if(VAR_6->qos > 0){
		if(packet__read_uint16(&VAR_0->in_packet, &VAR_19)){
			db__msg_store_free(VAR_6);
			return VAR_24;
		}
		if(VAR_19 == 0){
			db__msg_store_free(VAR_6);
			return VAR_21;
		}
		/* COMMENT_1 */
                                                     
		VAR_6->source_mid = VAR_19;
	}

	/* COMMENT_3 */
	if(VAR_0->protocol == VAR_28){
		VAR_2 = property__read_all(VAR_29, &VAR_0->in_packet, &VAR_12);
		if(VAR_2){
			db__msg_store_free(VAR_6);
			return VAR_2;
		}

		VAR_13 = VAR_12;
		VAR_14 = NULL;
		VAR_6->properties = NULL;
		VAR_15 = NULL;
		while(VAR_13){
			switch(VAR_13->identifier){
				case VAR_30:
				case VAR_31:
				case VAR_32:
				case VAR_33:
				case VAR_34:
					if(VAR_6->properties){
						VAR_15->next = VAR_13;
						VAR_15 = VAR_13;
					}else{
						VAR_6->properties = VAR_13;
						VAR_15 = VAR_13;
					}
					if(VAR_14){
						VAR_14->next = VAR_13->next;
						VAR_13 = VAR_14->next;
					}else{
						VAR_12 = VAR_13->next;
						VAR_13 = VAR_12;
					}
					VAR_15->next = NULL;
					break;

				case VAR_35:
					VAR_17 = VAR_13->value.i16;
					VAR_14 = VAR_13;
					VAR_13 = VAR_13->next;
					break;

				case VAR_36:
					VAR_16 = VAR_13->value.i32;
					VAR_14 = VAR_13;
					VAR_13 = VAR_13->next;
					break;

				case VAR_37:
					VAR_14 = VAR_13;
					VAR_13 = VAR_13->next;
					break;

				default:
					VAR_13 = VAR_13->next;
					break;
			}
		}
	}
	mosquitto_property_free_all(&VAR_12);

	if(VAR_17 == 0 || (VAR_0->listener && VAR_17 > VAR_0->listener->max_topic_alias)){
		db__msg_store_free(VAR_6);
		return VAR_38;
	}else if(VAR_17 > 0){
		if(VAR_6->topic){
			VAR_2 = alias__add(VAR_0, VAR_6->topic, (uint16_t)VAR_17);
			if(VAR_2){
				db__msg_store_free(VAR_6);
				return VAR_2;
			}
		}else{
			VAR_2 = alias__find(VAR_0, &VAR_6->topic, (uint16_t)VAR_17);
			if(VAR_2){
				db__msg_store_free(VAR_6);
				return VAR_21;
			}
		}
	}

#ifdef VAR_39
	VAR_2 = bridge__remap_topic_in(VAR_0, &VAR_6->topic);
	if(VAR_2){
		db__msg_store_free(VAR_6);
		return VAR_2;
	}

#endif
	if(mosquitto_pub_topic_check(VAR_6->topic) != VAR_40){
		/* COMMENT_4 */
		db__msg_store_free(VAR_6);
		return VAR_24;
	}

	VAR_6->payloadlen = VAR_0->in_packet.remaining_length - VAR_0->in_packet.pos;
	G_PUB_BYTES_RECEIVED_INC(VAR_6->payloadlen);
	if(VAR_0->listener && VAR_0->listener->mount_point){
		VAR_9 = strlen(VAR_0->listener->mount_point) + strlen(VAR_6->topic) + 1;
		VAR_11 = mosquitto__malloc(VAR_9+1);
		if(!VAR_11){
			db__msg_store_free(VAR_6);
			return VAR_22;
		}
		snprintf(VAR_11, VAR_9, ""%s%s"", VAR_0->listener->mount_point, VAR_6->topic);
		VAR_11[VAR_9] = '\0';

		mosquitto__free(VAR_6->topic);
		VAR_6->topic = VAR_11;
	}

	if(VAR_6->payloadlen){
		if(VAR_26.config->message_size_limit && VAR_6->payloadlen > VAR_26.config->message_size_limit){
			log__printf(NULL, VAR_41, ""Dropped too large PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"", VAR_0->id, VAR_1, VAR_6->qos, VAR_6->retain, VAR_6->source_mid, VAR_6->topic, (long)VAR_6->payloadlen);
			VAR_18 = VAR_42;
			goto process_bad_message;
		}
		VAR_6->payload = mosquitto__malloc(VAR_6->payloadlen+1);
		if(VAR_6->payload == NULL){
			db__msg_store_free(VAR_6);
			return VAR_22;
		}
		/* COMMENT_5 */
		((uint8_t *)VAR_6->payload)[VAR_6->payloadlen] = 0;

		if(packet__read_bytes(&VAR_0->in_packet, VAR_6->payload, VAR_6->payloadlen)){
			db__msg_store_free(VAR_6);
			return VAR_24;
		}
	}

	/* COMMENT_6 */
	VAR_2 = mosquitto_acl_check(VAR_0, VAR_6->topic, VAR_6->payloadlen, VAR_6->payload, VAR_6->qos, VAR_6->retain, VAR_43);
	if(VAR_2 == VAR_44){
		log__printf(NULL, VAR_41,
				""Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"",
				VAR_0->id, VAR_1, VAR_6->qos, VAR_6->retain, VAR_6->source_mid, VAR_6->topic,
				(long)VAR_6->payloadlen);
		VAR_18 = VAR_45;
		goto process_bad_message;
	}else if(VAR_2 != VAR_40){
		db__msg_store_free(VAR_6);
		return VAR_2;
	}

	log__printf(NULL, VAR_41, ""Received PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"", VAR_0->id, VAR_1, VAR_6->qos, VAR_6->retain, VAR_6->source_mid, VAR_6->topic, (long)VAR_6->payloadlen);

	if(!strncmp(VAR_6->topic, ""$CONTROL/"", 9)){
#ifdef VAR_46
		VAR_2 = control__process(VAR_0, VAR_6);
		db__msg_store_free(VAR_6);
		return VAR_2;
#else
		VAR_18 = VAR_47;
		goto process_bad_message;
#endif
	}

	{
		VAR_2 = plugin__handle_message(VAR_0, VAR_6);
		if(VAR_2 == VAR_44){
			log__printf(NULL, VAR_41,
					""Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"",
					VAR_0->id, VAR_1, VAR_6->qos, VAR_6->retain, VAR_6->source_mid, VAR_6->topic,
					(long)VAR_6->payloadlen);

			VAR_18 = VAR_45;
			goto process_bad_message;
		}else if(VAR_2 != VAR_40){
			db__msg_store_free(VAR_6);
			return VAR_2;
		}
	}

	if(VAR_6->qos > 0){
		db__message_store_find(VAR_0, VAR_6->source_mid, &VAR_8);
	}

	if(VAR_8 && VAR_8->store && VAR_6->source_mid != 0 &&
			(VAR_8->store->qos != VAR_6->qos
			 || VAR_8->store->payloadlen != VAR_6->payloadlen
			 || strcmp(VAR_8->store->topic, VAR_6->topic)
			 || memcmp(VAR_8->store->payload, VAR_6->payload, VAR_6->payloadlen) )){

		log__printf(NULL, VAR_48, ""Reused message ID %u from %s detected. Clearing from storage."", VAR_6->source_mid, VAR_0->id);
		db__message_remove_incoming(VAR_0, VAR_6->source_mid);
		VAR_8 = NULL;
	}

	if(!VAR_8){
		if(VAR_6->qos == 0
				|| db__ready_for_flight(VAR_0, VAR_49, VAR_6->qos)
				){

			VAR_1 = 0;
			VAR_2 = db__message_store(VAR_0, VAR_6, VAR_16, 0, VAR_50);
			if(VAR_2) return VAR_2;
		}else{
			/* COMMENT_7 */
			VAR_18 = VAR_51;
			goto process_bad_message;
		}
		VAR_7 = VAR_6;
		VAR_6 = NULL;
		VAR_1 = 0;
	}else{
		db__msg_store_free(VAR_6);
		VAR_6 = NULL;
		VAR_7 = VAR_8->store;
		VAR_8->dup++;
		VAR_1 = VAR_8->dup;
	}

	switch(VAR_7->qos){
		case 0:
			VAR_3 = sub__messages_queue(VAR_0->id, VAR_7->topic, VAR_7->qos, VAR_7->retain, &VAR_7);
			if(VAR_3 > 0) VAR_2 = 1;
			break;
		case 1:
			util__decrement_receive_quota(VAR_0);
			VAR_3 = sub__messages_queue(VAR_0->id, VAR_7->topic, VAR_7->qos, VAR_7->retain, &VAR_7);
			/* COMMENT_8 */
			if(VAR_3 == VAR_40 || VAR_0->protocol != VAR_28){
				if(send__puback(VAR_0, VAR_19, 0, NULL)) VAR_2 = 1;
			}else if(VAR_3 == VAR_52){
				if(send__puback(VAR_0, VAR_19, VAR_53, NULL)) VAR_2 = 1;
			}else{
				VAR_2 = VAR_3;
			}
			break;
		case 2:
			if(VAR_1 == 0){
				VAR_5 = db__message_insert(VAR_0, VAR_7->source_mid, VAR_49, VAR_7->qos, VAR_7->retain, VAR_7, NULL, false);
			}else{
				VAR_5 = 0;
			}

			/* COMMENT_9 */
                                                                    
			/* COMMENT_11 */
			if(!VAR_5){
				if(VAR_1 == 0 || VAR_1 == 1){
					VAR_3 = send__pubrec(VAR_0, VAR_7->source_mid, 0, NULL);
					if(VAR_3) VAR_2 = VAR_3;
				}else{
					return VAR_21;
				}
			}else if(VAR_5 == 1){
				VAR_2 = 1;
			}
			break;
	}

	db__message_write_queued_in(VAR_0);
	return VAR_2;
process_bad_message:
	VAR_2 = 1;
	if(VAR_6){
		switch(VAR_6->qos){
			case 0:
				VAR_2 = VAR_40;
				break;
			case 1:
				VAR_2 = send__puback(VAR_0, VAR_6->source_mid, VAR_18, NULL);
				break;
			case 2:
				VAR_2 = send__pubrec(VAR_0, VAR_6->source_mid, VAR_18, NULL);
				break;
		}
		db__msg_store_free(VAR_6);
	}
	if(VAR_0->out_packet_count >= VAR_26.config->max_queued_messages){
		VAR_2 = VAR_51;
	}
	return VAR_2;
}",eclipse/mosquitto/6113eac95a9df634fbc858be542c4a0456bfe7b9/handle_publish.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,6 +6,7 @@
 	uint8_t header = context->in_packet.command;
 	int res = 0;
 	struct mosquitto_msg_store *msg, *stored = NULL;
+	struct mosquitto_client_msg *cmsg_stored = NULL;
 	size_t len;
 	uint16_t slen;
 	char *topic_mount;
@@ -251,24 +252,24 @@
 	}
 
 	if(msg->qos > 0){
-		db__message_store_find(context, msg->source_mid, &stored);
-	}
-
-	if(stored && msg->source_mid != 0 &&
-			(stored->qos != msg->qos
-			 || stored->payloadlen != msg->payloadlen
-			 || strcmp(stored->topic, msg->topic)
-			 || memcmp(stored->payload, msg->payload, msg->payloadlen) )){
+		db__message_store_find(context, msg->source_mid, &cmsg_stored);
+	}
+
+	if(cmsg_stored && cmsg_stored->store && msg->source_mid != 0 &&
+			(cmsg_stored->store->qos != msg->qos
+			 || cmsg_stored->store->payloadlen != msg->payloadlen
+			 || strcmp(cmsg_stored->store->topic, msg->topic)
+			 || memcmp(cmsg_stored->store->payload, msg->payload, msg->payloadlen) )){
 
 		log__printf(NULL, MOSQ_LOG_WARNING, ""Reused message ID %u from %s detected. Clearing from storage."", msg->source_mid, context->id);
 		db__message_remove_incoming(context, msg->source_mid);
-		stored = NULL;
-	}
-
-	if(!stored){
+		cmsg_stored = NULL;
+	}
+
+	if(!cmsg_stored){
 		if(msg->qos == 0
 				|| db__ready_for_flight(context, mosq_md_in, msg->qos)
-				|| db__ready_for_queue(context, msg->qos, &context->msgs_in)){
+				){
 
 			dup = 0;
 			rc = db__message_store(context, msg, message_expiry_interval, 0, mosq_mo_client);
@@ -280,10 +281,13 @@
 		}
 		stored = msg;
 		msg = NULL;
+		dup = 0;
 	}else{
 		db__msg_store_free(msg);
 		msg = NULL;
-		dup = 1;
+		stored = cmsg_stored->store;
+		cmsg_stored->dup++;
+		dup = cmsg_stored->dup;
 	}
 
 	switch(stored->qos){
@@ -309,11 +313,17 @@
 			}else{
 				res = 0;
 			}
+
 			/* db__message_insert() returns 2 to indicate dropped message
 			 * due to queue. This isn't an error so don't disconnect them. */
 			/* FIXME - this is no longer necessary due to failing early above */
 			if(!res){
-				if(send__pubrec(context, stored->source_mid, 0, NULL)) rc = 1;
+				if(dup == 0 || dup == 1){
+					rc2 = send__pubrec(context, stored->source_mid, 0, NULL);
+					if(rc2) rc = rc2;
+				}else{
+					return MOSQ_ERR_PROTOCOL;
+				}
 			}else if(res == 1){
 				rc = 1;
 			}
@@ -338,5 +348,8 @@
 		}
 		db__msg_store_free(msg);
 	}
+	if(context->out_packet_count >= db.config->max_queued_messages){
+		rc = MQTT_RC_QUOTA_EXCEEDED;
+	}
 	return rc;
 }","{'deleted_lines': ['\t\tdb__message_store_find(context, msg->source_mid, &stored);', '\t}', '', '\tif(stored && msg->source_mid != 0 &&', '\t\t\t(stored->qos != msg->qos', '\t\t\t || stored->payloadlen != msg->payloadlen', '\t\t\t || strcmp(stored->topic, msg->topic)', '\t\t\t || memcmp(stored->payload, msg->payload, msg->payloadlen) )){', '\t\tstored = NULL;', '\t}', '', '\tif(!stored){', '\t\t\t\t|| db__ready_for_queue(context, msg->qos, &context->msgs_in)){', '\t\tdup = 1;', '\t\t\t\tif(send__pubrec(context, stored->source_mid, 0, NULL)) rc = 1;'], 'added_lines': ['\tstruct mosquitto_client_msg *cmsg_stored = NULL;', '\t\tdb__message_store_find(context, msg->source_mid, &cmsg_stored);', '\t}', '', '\tif(cmsg_stored && cmsg_stored->store && msg->source_mid != 0 &&', '\t\t\t(cmsg_stored->store->qos != msg->qos', '\t\t\t || cmsg_stored->store->payloadlen != msg->payloadlen', '\t\t\t || strcmp(cmsg_stored->store->topic, msg->topic)', '\t\t\t || memcmp(cmsg_stored->store->payload, msg->payload, msg->payloadlen) )){', '\t\tcmsg_stored = NULL;', '\t}', '', '\tif(!cmsg_stored){', '\t\t\t\t){', '\t\tdup = 0;', '\t\tstored = cmsg_stored->store;', '\t\tcmsg_stored->dup++;', '\t\tdup = cmsg_stored->dup;', '', '\t\t\t\tif(dup == 0 || dup == 1){', '\t\t\t\t\trc2 = send__pubrec(context, stored->source_mid, 0, NULL);', '\t\t\t\t\tif(rc2) rc = rc2;', '\t\t\t\t}else{', '\t\t\t\t\treturn MOSQ_ERR_PROTOCOL;', '\t\t\t\t}', '\tif(context->out_packet_count >= db.config->max_queued_messages){', '\t\trc = MQTT_RC_QUOTA_EXCEEDED;', '\t}']}",True,"The broker in Eclipse Mosquitto 1.3.2 through 2.x before 2.0.16 has a memory leak that can be abused remotely when a client sends many QoS 2 messages with duplicate message IDs, and fails to respond to PUBREC commands. This occurs because of mishandling of EAGAIN from the libc send function.",7.5,HIGH,2,test,2023-06-13T10:22:03Z,4
CVE-2023-28366,['CWE-401'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,eclipse/mosquitto,Fix for CVE-2023-28366,6113eac95a9df634fbc858be542c4a0456bfe7b9,https://github.com/eclipse/mosquitto/commit/6113eac95a9df634fbc858be542c4a0456bfe7b9,src/context.c,context__init,"struct mosquitto *context__init(mosq_sock_t sock)
{
struct mosquitto *context;
char address[1024];
context = mosquitto__calloc(1, sizeof(struct mosquitto));
if(!context) return NULL;
#ifdef WITH_EPOLL
context->ident = id_client;
#else
context->pollfd_index = -1;
#endif
mosquitto__set_state(context, mosq_cs_new);
context->sock = sock;
context->last_msg_in = db.now_s;
context->next_msg_out = db.now_s + 60;
context->keepalive = 60; 
context->clean_start = true;
context->id = NULL;
context->last_mid = 0;
context->will = NULL;
context->username = NULL;
context->password = NULL;
context->listener = NULL;
context->acl_list = NULL;
context->retain_available = true;
context->is_bridge = false;
context->in_packet.payload = NULL;
packet__cleanup(&context->in_packet);
context->out_packet = NULL;
context->current_out_packet = NULL;
context->out_packet_count = 0;
context->address = NULL;
if((int)sock >= 0){
if(!net__socket_get_address(sock, address, 1024, &context->remote_port)){
context->address = mosquitto__strdup(address);
}
if(!context->address){
mosquitto__free(context);
return NULL;
}
}
context->bridge = NULL;
context->msgs_in.inflight_maximum = db.config->max_inflight_messages;
context->msgs_out.inflight_maximum = db.config->max_inflight_messages;
context->msgs_in.inflight_quota = db.config->max_inflight_messages;
context->msgs_out.inflight_quota = db.config->max_inflight_messages;
context->max_qos = 2;
#ifdef WITH_TLS
context->ssl = NULL;
#endif
if((int)context->sock >= 0){
HASH_ADD(hh_sock, db.contexts_by_sock, sock, sizeof(context->sock), context);
}
return context;
}","struct mosquitto *context__init(mosq_sock_t VAR_0)
{
struct mosquitto *VAR_1;
char VAR_2[1024];
VAR_1 = mosquitto__calloc(1, sizeof(struct mosquitto));
if(!VAR_1) return NULL;
#ifdef VAR_3
VAR_1->ident = VAR_4;
#else
VAR_1->pollfd_index = -1;
#endif
mosquitto__set_state(VAR_1, VAR_5);
VAR_1->sock = VAR_0;
VAR_1->last_msg_in = VAR_6.now_s;
VAR_1->next_msg_out = VAR_6.now_s + 60;
VAR_1->keepalive = 60; 
VAR_1->clean_start = true;
VAR_1->id = NULL;
VAR_1->last_mid = 0;
VAR_1->will = NULL;
VAR_1->username = NULL;
VAR_1->password = NULL;
VAR_1->listener = NULL;
VAR_1->acl_list = NULL;
VAR_1->retain_available = true;
VAR_1->is_bridge = false;
VAR_1->in_packet.payload = NULL;
packet__cleanup(&VAR_1->in_packet);
VAR_1->out_packet = NULL;
VAR_1->current_out_packet = NULL;
VAR_1->out_packet_count = 0;
VAR_1->address = NULL;
if((int)VAR_0 >= 0){
if(!net__socket_get_address(VAR_0, VAR_2, 1024, &VAR_1->remote_port)){
VAR_1->address = mosquitto__strdup(VAR_2);
}
if(!VAR_1->address){
mosquitto__free(VAR_1);
return NULL;
}
}
VAR_1->bridge = NULL;
VAR_1->msgs_in.inflight_maximum = VAR_6.config->max_inflight_messages;
VAR_1->msgs_out.inflight_maximum = VAR_6.config->max_inflight_messages;
VAR_1->msgs_in.inflight_quota = VAR_6.config->max_inflight_messages;
VAR_1->msgs_out.inflight_quota = VAR_6.config->max_inflight_messages;
VAR_1->max_qos = 2;
#ifdef VAR_7
VAR_1->ssl = NULL;
#endif
if((int)VAR_1->sock >= 0){
HASH_ADD(VAR_8, VAR_6.contexts_by_sock, VAR_0, sizeof(VAR_1->sock), VAR_1);
}
return VAR_1;
}",eclipse/mosquitto/6113eac95a9df634fbc858be542c4a0456bfe7b9/context.c/vul/before/0.json,"struct mosquitto *context__init(mosq_sock_t sock)
{
	struct mosquitto *context;
	char address[1024];

	context = mosquitto__calloc(1, sizeof(struct mosquitto));
	if(!context) return NULL;

#ifdef WITH_EPOLL
	context->ident = id_client;
#else
	context->pollfd_index = -1;
#endif
	mosquitto__set_state(context, mosq_cs_new);
	context->sock = sock;
	context->last_msg_in = db.now_s;
	context->next_msg_out = db.now_s + 60;
	context->keepalive = 60; /* Default to 60s */
	context->clean_start = true;
	context->id = NULL;
	context->last_mid = 0;
	context->will = NULL;
	context->username = NULL;
	context->password = NULL;
	context->listener = NULL;
	context->acl_list = NULL;
	context->retain_available = true;

	/* is_bridge records whether this client is a bridge or not. This could be
	 * done by looking at context->bridge for bridges that we create ourself,
	 * but incoming bridges need some other way of being recorded. */
	context->is_bridge = false;

	context->in_packet.payload = NULL;
	packet__cleanup(&context->in_packet);
	context->out_packet = NULL;
	context->current_out_packet = NULL;
	context->out_packet_count = 0;

	context->address = NULL;
	if((int)sock >= 0){
		if(!net__socket_get_address(sock, address, 1024, &context->remote_port)){
			context->address = mosquitto__strdup(address);
		}
		if(!context->address){
			/* getpeername and inet_ntop failed and not a bridge */
			mosquitto__free(context);
			return NULL;
		}
	}
	context->bridge = NULL;
	context->msgs_in.inflight_maximum = 1;
	context->msgs_out.inflight_maximum = db.config->max_inflight_messages;
	context->msgs_in.inflight_quota = 1;
	context->msgs_out.inflight_quota = db.config->max_inflight_messages;
	context->max_qos = 2;
#ifdef WITH_TLS
	context->ssl = NULL;
#endif

	if((int)context->sock >= 0){
		HASH_ADD(hh_sock, db.contexts_by_sock, sock, sizeof(context->sock), context);
	}
	return context;
}","struct mosquitto *context__init(mosq_sock_t VAR_0)
{
	struct mosquitto *VAR_1;
	char VAR_2[1024];

	VAR_1 = mosquitto__calloc(1, sizeof(struct mosquitto));
	if(!VAR_1) return NULL;

#ifdef VAR_3
	VAR_1->ident = VAR_4;
#else
	VAR_1->pollfd_index = -1;
#endif
	mosquitto__set_state(VAR_1, VAR_5);
	VAR_1->sock = VAR_0;
	VAR_1->last_msg_in = VAR_6.now_s;
	VAR_1->next_msg_out = VAR_6.now_s + 60;
	VAR_1->keepalive = 60; /* COMMENT_0 */
	VAR_1->clean_start = true;
	VAR_1->id = NULL;
	VAR_1->last_mid = 0;
	VAR_1->will = NULL;
	VAR_1->username = NULL;
	VAR_1->password = NULL;
	VAR_1->listener = NULL;
	VAR_1->acl_list = NULL;
	VAR_1->retain_available = true;

	/* COMMENT_1 */
                                                                          
                                                                  
	VAR_1->is_bridge = false;

	VAR_1->in_packet.payload = NULL;
	packet__cleanup(&VAR_1->in_packet);
	VAR_1->out_packet = NULL;
	VAR_1->current_out_packet = NULL;
	VAR_1->out_packet_count = 0;

	VAR_1->address = NULL;
	if((int)VAR_0 >= 0){
		if(!net__socket_get_address(VAR_0, VAR_2, 1024, &VAR_1->remote_port)){
			VAR_1->address = mosquitto__strdup(VAR_2);
		}
		if(!VAR_1->address){
			/* COMMENT_4 */
			mosquitto__free(VAR_1);
			return NULL;
		}
	}
	VAR_1->bridge = NULL;
	VAR_1->msgs_in.inflight_maximum = 1;
	VAR_1->msgs_out.inflight_maximum = VAR_6.config->max_inflight_messages;
	VAR_1->msgs_in.inflight_quota = 1;
	VAR_1->msgs_out.inflight_quota = VAR_6.config->max_inflight_messages;
	VAR_1->max_qos = 2;
#ifdef VAR_7
	VAR_1->ssl = NULL;
#endif

	if((int)VAR_1->sock >= 0){
		HASH_ADD(VAR_8, VAR_6.contexts_by_sock, VAR_0, sizeof(VAR_1->sock), VAR_1);
	}
	return VAR_1;
}",eclipse/mosquitto/6113eac95a9df634fbc858be542c4a0456bfe7b9/context.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -49,9 +49,9 @@
 		}
 	}
 	context->bridge = NULL;
-	context->msgs_in.inflight_maximum = db.config->max_inflight_messages;
+	context->msgs_in.inflight_maximum = 1;
 	context->msgs_out.inflight_maximum = db.config->max_inflight_messages;
-	context->msgs_in.inflight_quota = db.config->max_inflight_messages;
+	context->msgs_in.inflight_quota = 1;
 	context->msgs_out.inflight_quota = db.config->max_inflight_messages;
 	context->max_qos = 2;
 #ifdef WITH_TLS","{'deleted_lines': ['\tcontext->msgs_in.inflight_maximum = db.config->max_inflight_messages;', '\tcontext->msgs_in.inflight_quota = db.config->max_inflight_messages;'], 'added_lines': ['\tcontext->msgs_in.inflight_maximum = 1;', '\tcontext->msgs_in.inflight_quota = 1;']}",True,"The broker in Eclipse Mosquitto 1.3.2 through 2.x before 2.0.16 has a memory leak that can be abused remotely when a client sends many QoS 2 messages with duplicate message IDs, and fails to respond to PUBREC commands. This occurs because of mishandling of EAGAIN from the libc send function.",7.5,HIGH,2,test,2023-06-13T10:22:03Z,4
CVE-2023-36664,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,ArtifexSoftware/ghostpdl,"Bug 706778: 706761 revisit

Two problems with the original commit. The first a silly typo inverting the
logic of a test.

The second was forgetting that we actually actually validate two candidate
strings for pipe devices. One with the expected ""%pipe%"" prefix, the other
using the pipe character prefix: ""|"".

This addresses both those.",0974e4f2ac0005d3731e0b5c13ebc7e965540f4d,https://github.com/ArtifexSoftware/ghostpdl/commit/0974e4f2ac0005d3731e0b5c13ebc7e965540f4d,base/gslibctx.c,gs_add_control_path_len_flags,"int
gs_add_control_path_len_flags(const gs_memory_t *mem, gs_path_control_t type, const char *path, size_t len, int flags)
{
gs_path_control_set_t *control;
unsigned int n, i;
gs_lib_ctx_core_t *core;
char *buffer;
uint rlen;
if (path == NULL || len == 0)
return 0;
if (mem == NULL || mem->gs_lib_ctx == NULL ||
(core = mem->gs_lib_ctx->core) == NULL)
return gs_error_unknownerror;
switch(type) {
case gs_permit_file_reading:
control = &core->permit_reading;
break;
case gs_permit_file_writing:
control = &core->permit_writing;
break;
case gs_permit_file_control:
control = &core->permit_control;
break;
default:
return gs_error_rangecheck;
}
if (len > 5 && memcmp(path, ""%pipe"", 5) != 0) {
buffer = (char *)gs_alloc_bytes(core->memory, len + 1, ""gs_add_control_path_len"");
if (buffer == NULL)
return gs_error_VMerror;
memcpy(buffer, path, len);
buffer[len] = 0;
rlen = len;
}
else {
rlen = len + 1;
buffer = (char *)gs_alloc_bytes(core->memory, rlen, ""gs_add_control_path_len"");
if (buffer == NULL)
return gs_error_VMerror;
if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
return gs_error_invalidfileaccess;
buffer[rlen] = 0;
}
n = control->num;
for (i = 0; i < n; i++)
{
if (strncmp(control->entry[i].path, buffer, rlen) == 0 &&
control->entry[i].path[rlen] == 0) {
gs_free_object(core->memory, buffer, ""gs_add_control_path_len"");
return 0; 
}
}
if (control->num == control->max) {
gs_path_control_entry_t *p;
n = control->max * 2;
if (n == 0) {
n = 4;
p = (gs_path_control_entry_t *)gs_alloc_bytes(core->memory, sizeof(*p)*n, ""gs_lib_ctx(entries)"");
} else
p = (gs_path_control_entry_t *)gs_resize_object(core->memory, control->entry, sizeof(*p)*n, ""gs_lib_ctx(entries)"");
if (p == NULL) {
gs_free_object(core->memory, buffer, ""gs_add_control_path_len"");
return gs_error_VMerror;
}
control->entry = p;
control->max = n;
}
n = control->num;
control->entry[n].path = buffer;
control->entry[n].path[len] = 0;
control->entry[n].flags = flags;
control->num++;
return 0;
}","int
gs_add_control_path_len_flags(const gs_memory_t *VAR_0, gs_path_control_t VAR_1, const char *VAR_2, size_t VAR_3, int VAR_4)
{
gs_path_control_set_t *VAR_5;
unsigned int VAR_6, VAR_7;
gs_lib_ctx_core_t *VAR_8;
char *VAR_9;
uint VAR_10;
if (VAR_2 == NULL || VAR_3 == 0)
return 0;
if (VAR_0 == NULL || VAR_0->gs_lib_ctx == NULL ||
(VAR_8 = VAR_0->gs_lib_ctx->core) == NULL)
return VAR_11;
switch(VAR_1) {
case VAR_12:
VAR_5 = &VAR_8->permit_reading;
break;
case VAR_13:
VAR_5 = &VAR_8->permit_writing;
break;
case VAR_14:
VAR_5 = &VAR_8->permit_control;
break;
default:
return VAR_15;
}
if (VAR_3 > 5 && memcmp(VAR_2, ""%pipe"", 5) != 0) {
VAR_9 = (char *)gs_alloc_bytes(VAR_8->memory, VAR_3 + 1, ""gs_add_control_path_len"");
if (VAR_9 == NULL)
return VAR_16;
memcpy(VAR_9, VAR_2, VAR_3);
VAR_9[VAR_3] = 0;
VAR_10 = VAR_3;
}
else {
VAR_10 = VAR_3 + 1;
VAR_9 = (char *)gs_alloc_bytes(VAR_8->memory, VAR_10, ""gs_add_control_path_len"");
if (VAR_9 == NULL)
return VAR_16;
if (gp_file_name_reduce(VAR_2, (uint)VAR_3, VAR_9, &VAR_10) != VAR_17)
return VAR_18;
VAR_9[VAR_10] = 0;
}
VAR_6 = VAR_5->num;
for (VAR_7 = 0; VAR_7 < VAR_6; VAR_7++)
{
if (strncmp(VAR_5->entry[VAR_7].path, VAR_9, VAR_10) == 0 &&
VAR_5->entry[VAR_7].path[VAR_10] == 0) {
gs_free_object(VAR_8->memory, VAR_9, ""gs_add_control_path_len"");
return 0; 
}
}
if (VAR_5->num == VAR_5->max) {
gs_path_control_entry_t *VAR_19;
VAR_6 = VAR_5->max * 2;
if (VAR_6 == 0) {
VAR_6 = 4;
VAR_19 = (gs_path_control_entry_t *)gs_alloc_bytes(VAR_8->memory, sizeof(*VAR_19)*VAR_6, ""gs_lib_ctx(entries)"");
} else
VAR_19 = (gs_path_control_entry_t *)gs_resize_object(VAR_8->memory, VAR_5->entry, sizeof(*VAR_19)*VAR_6, ""gs_lib_ctx(entries)"");
if (VAR_19 == NULL) {
gs_free_object(VAR_8->memory, VAR_9, ""gs_add_control_path_len"");
return VAR_16;
}
VAR_5->entry = VAR_19;
VAR_5->max = VAR_6;
}
VAR_6 = VAR_5->num;
VAR_5->entry[VAR_6].path = VAR_9;
VAR_5->entry[VAR_6].path[VAR_3] = 0;
VAR_5->entry[VAR_6].flags = VAR_4;
VAR_5->num++;
return 0;
}",ArtifexSoftware/ghostpdl/0974e4f2ac0005d3731e0b5c13ebc7e965540f4d/gslibctx.c/vul/before/1.json,"int
gs_add_control_path_len_flags(const gs_memory_t *mem, gs_path_control_t type, const char *path, size_t len, int flags)
{
    gs_path_control_set_t *control;
    unsigned int n, i;
    gs_lib_ctx_core_t *core;
    char *buffer;
    uint rlen;

    if (path == NULL || len == 0)
        return 0;

    if (mem == NULL || mem->gs_lib_ctx == NULL ||
        (core = mem->gs_lib_ctx->core) == NULL)
        return gs_error_unknownerror;

    switch(type) {
        case gs_permit_file_reading:
            control = &core->permit_reading;
            break;
        case gs_permit_file_writing:
            control = &core->permit_writing;
            break;
        case gs_permit_file_control:
            control = &core->permit_control;
            break;
        default:
            return gs_error_rangecheck;
    }

    /* ""%pipe%"" do not follow the normal rules for path definitions, so we
       don't ""reduce"" them to avoid unexpected results
     */
    if (path[0] == '|' || (len > 5 && memcmp(path, ""%pipe"", 5) == 0)) {
        buffer = (char *)gs_alloc_bytes(core->memory, len + 1, ""gs_add_control_path_len"");
        if (buffer == NULL)
            return gs_error_VMerror;
        memcpy(buffer, path, len);
        buffer[len] = 0;
        rlen = len;
    }
    else {
        rlen = len + 1;

        buffer = (char *)gs_alloc_bytes(core->memory, rlen, ""gs_add_control_path_len"");
        if (buffer == NULL)
            return gs_error_VMerror;

        if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
            return gs_error_invalidfileaccess;
        buffer[rlen] = 0;
    }

    n = control->num;
    for (i = 0; i < n; i++)
    {
        if (strncmp(control->entry[i].path, buffer, rlen) == 0 &&
            control->entry[i].path[rlen] == 0) {
            gs_free_object(core->memory, buffer, ""gs_add_control_path_len"");
            return 0; /* Already there! */
        }
    }

    if (control->num == control->max) {
        gs_path_control_entry_t *p;

        n = control->max * 2;
        if (n == 0) {
            n = 4;
            p = (gs_path_control_entry_t *)gs_alloc_bytes(core->memory, sizeof(*p)*n, ""gs_lib_ctx(entries)"");
        } else
            p = (gs_path_control_entry_t *)gs_resize_object(core->memory, control->entry, sizeof(*p)*n, ""gs_lib_ctx(entries)"");
        if (p == NULL) {
            gs_free_object(core->memory, buffer, ""gs_add_control_path_len"");
            return gs_error_VMerror;
        }
        control->entry = p;
        control->max = n;
    }

    n = control->num;
    control->entry[n].path = buffer;
    control->entry[n].path[len] = 0;
    control->entry[n].flags = flags;
    control->num++;

    return 0;
}","int
gs_add_control_path_len_flags(const gs_memory_t *VAR_0, gs_path_control_t VAR_1, const char *VAR_2, size_t VAR_3, int VAR_4)
{
    gs_path_control_set_t *VAR_5;
    unsigned int VAR_6, VAR_7;
    gs_lib_ctx_core_t *VAR_8;
    char *VAR_9;
    uint VAR_10;

    if (VAR_2 == NULL || VAR_3 == 0)
        return 0;

    if (VAR_0 == NULL || VAR_0->gs_lib_ctx == NULL ||
        (VAR_8 = VAR_0->gs_lib_ctx->core) == NULL)
        return VAR_11;

    switch(VAR_1) {
        case VAR_12:
            VAR_5 = &VAR_8->permit_reading;
            break;
        case VAR_13:
            VAR_5 = &VAR_8->permit_writing;
            break;
        case VAR_14:
            VAR_5 = &VAR_8->permit_control;
            break;
        default:
            return VAR_15;
    }

    /* COMMENT_0 */
                                                      
       
    if (VAR_2[0] == '|' || (VAR_3 > 5 && memcmp(VAR_2, ""%pipe"", 5) == 0)) {
        VAR_9 = (char *)gs_alloc_bytes(VAR_8->memory, VAR_3 + 1, ""gs_add_control_path_len"");
        if (VAR_9 == NULL)
            return VAR_16;
        memcpy(VAR_9, VAR_2, VAR_3);
        VAR_9[VAR_3] = 0;
        VAR_10 = VAR_3;
    }
    else {
        VAR_10 = VAR_3 + 1;

        VAR_9 = (char *)gs_alloc_bytes(VAR_8->memory, VAR_10, ""gs_add_control_path_len"");
        if (VAR_9 == NULL)
            return VAR_16;

        if (gp_file_name_reduce(VAR_2, (uint)VAR_3, VAR_9, &VAR_10) != VAR_17)
            return VAR_18;
        VAR_9[VAR_10] = 0;
    }

    VAR_6 = VAR_5->num;
    for (VAR_7 = 0; VAR_7 < VAR_6; VAR_7++)
    {
        if (strncmp(VAR_5->entry[VAR_7].path, VAR_9, VAR_10) == 0 &&
            VAR_5->entry[VAR_7].path[VAR_10] == 0) {
            gs_free_object(VAR_8->memory, VAR_9, ""gs_add_control_path_len"");
            return 0; /* COMMENT_3 */
        }
    }

    if (VAR_5->num == VAR_5->max) {
        gs_path_control_entry_t *VAR_19;

        VAR_6 = VAR_5->max * 2;
        if (VAR_6 == 0) {
            VAR_6 = 4;
            VAR_19 = (gs_path_control_entry_t *)gs_alloc_bytes(VAR_8->memory, sizeof(*VAR_19)*VAR_6, ""gs_lib_ctx(entries)"");
        } else
            VAR_19 = (gs_path_control_entry_t *)gs_resize_object(VAR_8->memory, VAR_5->entry, sizeof(*VAR_19)*VAR_6, ""gs_lib_ctx(entries)"");
        if (VAR_19 == NULL) {
            gs_free_object(VAR_8->memory, VAR_9, ""gs_add_control_path_len"");
            return VAR_16;
        }
        VAR_5->entry = VAR_19;
        VAR_5->max = VAR_6;
    }

    VAR_6 = VAR_5->num;
    VAR_5->entry[VAR_6].path = VAR_9;
    VAR_5->entry[VAR_6].path[VAR_3] = 0;
    VAR_5->entry[VAR_6].flags = VAR_4;
    VAR_5->num++;

    return 0;
}",ArtifexSoftware/ghostpdl/0974e4f2ac0005d3731e0b5c13ebc7e965540f4d/gslibctx.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -31,7 +31,7 @@
     /* ""%pipe%"" do not follow the normal rules for path definitions, so we
        don't ""reduce"" them to avoid unexpected results
      */
-    if (len > 5 && memcmp(path, ""%pipe"", 5) != 0) {
+    if (path[0] == '|' || (len > 5 && memcmp(path, ""%pipe"", 5) == 0)) {
         buffer = (char *)gs_alloc_bytes(core->memory, len + 1, ""gs_add_control_path_len"");
         if (buffer == NULL)
             return gs_error_VMerror;","{'deleted_lines': ['    if (len > 5 && memcmp(path, ""%pipe"", 5) != 0) {'], 'added_lines': ['    if (path[0] == \'|\' || (len > 5 && memcmp(path, ""%pipe"", 5) == 0)) {']}",True,Artifex Ghostscript through 10.01.2 mishandles permission validation for pipe devices (with the %pipe% prefix or the | pipe character prefix).,7.8,HIGH,2,test,2023-06-14T08:08:12Z,4
CVE-2023-36664,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,ArtifexSoftware/ghostpdl,"Bug 706778: 706761 revisit

Two problems with the original commit. The first a silly typo inverting the
logic of a test.

The second was forgetting that we actually actually validate two candidate
strings for pipe devices. One with the expected ""%pipe%"" prefix, the other
using the pipe character prefix: ""|"".

This addresses both those.",0974e4f2ac0005d3731e0b5c13ebc7e965540f4d,https://github.com/ArtifexSoftware/ghostpdl/commit/0974e4f2ac0005d3731e0b5c13ebc7e965540f4d,base/gslibctx.c,gs_remove_control_path_len_flags,"int
gs_remove_control_path_len_flags(const gs_memory_t *mem, gs_path_control_t type, const char *path, size_t len, int flags)
{
gs_path_control_set_t *control;
unsigned int n, i;
gs_lib_ctx_core_t *core;
char *buffer;
uint rlen;
if (path == NULL || len == 0)
return 0;
if (mem == NULL || mem->gs_lib_ctx == NULL ||
(core = mem->gs_lib_ctx->core) == NULL)
return gs_error_unknownerror;
switch(type) {
case gs_permit_file_reading:
control = &core->permit_reading;
break;
case gs_permit_file_writing:
control = &core->permit_writing;
break;
case gs_permit_file_control:
control = &core->permit_control;
break;
default:
return gs_error_rangecheck;
}
if (len > 5 && memcmp(path, ""%pipe"", 5) != 0) {
buffer = (char *)gs_alloc_bytes(core->memory, len + 1, ""gs_remove_control_path_len"");
if (buffer == NULL)
return gs_error_VMerror;
memcpy(buffer, path, len);
buffer[len] = 0;
rlen = len;
}
else {
rlen = len+1;
buffer = (char *)gs_alloc_bytes(core->memory, rlen, ""gs_remove_control_path_len"");
if (buffer == NULL)
return gs_error_VMerror;
if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
return gs_error_invalidfileaccess;
buffer[rlen] = 0;
}
n = control->num;
for (i = 0; i < n; i++) {
if (control->entry[i].flags == flags &&
strncmp(control->entry[i].path, buffer, len) == 0 &&
control->entry[i].path[len] == 0)
break;
}
gs_free_object(core->memory, buffer, ""gs_remove_control_path_len"");
if (i == n)
return 0;
gs_free_object(core->memory, control->entry[i].path, ""gs_lib_ctx(path)"");
for (;i < n-1; i++)
control->entry[i] = control->entry[i+1];
control->num = n-1;
return 0;
}","int
gs_remove_control_path_len_flags(const gs_memory_t *VAR_0, gs_path_control_t VAR_1, const char *VAR_2, size_t VAR_3, int VAR_4)
{
gs_path_control_set_t *VAR_5;
unsigned int VAR_6, VAR_7;
gs_lib_ctx_core_t *VAR_8;
char *VAR_9;
uint VAR_10;
if (VAR_2 == NULL || VAR_3 == 0)
return 0;
if (VAR_0 == NULL || VAR_0->gs_lib_ctx == NULL ||
(VAR_8 = VAR_0->gs_lib_ctx->core) == NULL)
return VAR_11;
switch(VAR_1) {
case VAR_12:
VAR_5 = &VAR_8->permit_reading;
break;
case VAR_13:
VAR_5 = &VAR_8->permit_writing;
break;
case VAR_14:
VAR_5 = &VAR_8->permit_control;
break;
default:
return VAR_15;
}
if (VAR_3 > 5 && memcmp(VAR_2, ""%pipe"", 5) != 0) {
VAR_9 = (char *)gs_alloc_bytes(VAR_8->memory, VAR_3 + 1, ""gs_remove_control_path_len"");
if (VAR_9 == NULL)
return VAR_16;
memcpy(VAR_9, VAR_2, VAR_3);
VAR_9[VAR_3] = 0;
VAR_10 = VAR_3;
}
else {
VAR_10 = VAR_3+1;
VAR_9 = (char *)gs_alloc_bytes(VAR_8->memory, VAR_10, ""gs_remove_control_path_len"");
if (VAR_9 == NULL)
return VAR_16;
if (gp_file_name_reduce(VAR_2, (uint)VAR_3, VAR_9, &VAR_10) != VAR_17)
return VAR_18;
VAR_9[VAR_10] = 0;
}
VAR_6 = VAR_5->num;
for (VAR_7 = 0; VAR_7 < VAR_6; VAR_7++) {
if (VAR_5->entry[VAR_7].flags == VAR_4 &&
strncmp(VAR_5->entry[VAR_7].path, VAR_9, VAR_3) == 0 &&
VAR_5->entry[VAR_7].path[VAR_3] == 0)
break;
}
gs_free_object(VAR_8->memory, VAR_9, ""gs_remove_control_path_len"");
if (VAR_7 == VAR_6)
return 0;
gs_free_object(VAR_8->memory, VAR_5->entry[VAR_7].path, ""gs_lib_ctx(path)"");
for (;VAR_7 < VAR_6-1; VAR_7++)
VAR_5->entry[VAR_7] = VAR_5->entry[VAR_7+1];
VAR_5->num = VAR_6-1;
return 0;
}",ArtifexSoftware/ghostpdl/0974e4f2ac0005d3731e0b5c13ebc7e965540f4d/gslibctx.c/vul/before/0.json,"int
gs_remove_control_path_len_flags(const gs_memory_t *mem, gs_path_control_t type, const char *path, size_t len, int flags)
{
    gs_path_control_set_t *control;
    unsigned int n, i;
    gs_lib_ctx_core_t *core;
    char *buffer;
    uint rlen;

    if (path == NULL || len == 0)
        return 0;

    if (mem == NULL || mem->gs_lib_ctx == NULL ||
        (core = mem->gs_lib_ctx->core) == NULL)
        return gs_error_unknownerror;

    switch(type) {
        case gs_permit_file_reading:
            control = &core->permit_reading;
            break;
        case gs_permit_file_writing:
            control = &core->permit_writing;
            break;
        case gs_permit_file_control:
            control = &core->permit_control;
            break;
        default:
            return gs_error_rangecheck;
    }

    /* ""%pipe%"" do not follow the normal rules for path definitions, so we
       don't ""reduce"" them to avoid unexpected results
     */
    if (path[0] == '|' || (len > 5 && memcmp(path, ""%pipe"", 5) == 0)) {
        buffer = (char *)gs_alloc_bytes(core->memory, len + 1, ""gs_remove_control_path_len"");
        if (buffer == NULL)
            return gs_error_VMerror;
        memcpy(buffer, path, len);
        buffer[len] = 0;
        rlen = len;
    }
    else {
        rlen = len+1;

        buffer = (char *)gs_alloc_bytes(core->memory, rlen, ""gs_remove_control_path_len"");
        if (buffer == NULL)
            return gs_error_VMerror;

        if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
            return gs_error_invalidfileaccess;
        buffer[rlen] = 0;
    }

    n = control->num;
    for (i = 0; i < n; i++) {
        if (control->entry[i].flags == flags &&
            strncmp(control->entry[i].path, buffer, len) == 0 &&
            control->entry[i].path[len] == 0)
            break;
    }
    gs_free_object(core->memory, buffer, ""gs_remove_control_path_len"");
    if (i == n)
        return 0;

    gs_free_object(core->memory, control->entry[i].path, ""gs_lib_ctx(path)"");
    for (;i < n-1; i++)
        control->entry[i] = control->entry[i+1];
    control->num = n-1;

    return 0;
}","int
gs_remove_control_path_len_flags(const gs_memory_t *VAR_0, gs_path_control_t VAR_1, const char *VAR_2, size_t VAR_3, int VAR_4)
{
    gs_path_control_set_t *VAR_5;
    unsigned int VAR_6, VAR_7;
    gs_lib_ctx_core_t *VAR_8;
    char *VAR_9;
    uint VAR_10;

    if (VAR_2 == NULL || VAR_3 == 0)
        return 0;

    if (VAR_0 == NULL || VAR_0->gs_lib_ctx == NULL ||
        (VAR_8 = VAR_0->gs_lib_ctx->core) == NULL)
        return VAR_11;

    switch(VAR_1) {
        case VAR_12:
            VAR_5 = &VAR_8->permit_reading;
            break;
        case VAR_13:
            VAR_5 = &VAR_8->permit_writing;
            break;
        case VAR_14:
            VAR_5 = &VAR_8->permit_control;
            break;
        default:
            return VAR_15;
    }

    /* COMMENT_0 */
                                                      
       
    if (VAR_2[0] == '|' || (VAR_3 > 5 && memcmp(VAR_2, ""%pipe"", 5) == 0)) {
        VAR_9 = (char *)gs_alloc_bytes(VAR_8->memory, VAR_3 + 1, ""gs_remove_control_path_len"");
        if (VAR_9 == NULL)
            return VAR_16;
        memcpy(VAR_9, VAR_2, VAR_3);
        VAR_9[VAR_3] = 0;
        VAR_10 = VAR_3;
    }
    else {
        VAR_10 = VAR_3+1;

        VAR_9 = (char *)gs_alloc_bytes(VAR_8->memory, VAR_10, ""gs_remove_control_path_len"");
        if (VAR_9 == NULL)
            return VAR_16;

        if (gp_file_name_reduce(VAR_2, (uint)VAR_3, VAR_9, &VAR_10) != VAR_17)
            return VAR_18;
        VAR_9[VAR_10] = 0;
    }

    VAR_6 = VAR_5->num;
    for (VAR_7 = 0; VAR_7 < VAR_6; VAR_7++) {
        if (VAR_5->entry[VAR_7].flags == VAR_4 &&
            strncmp(VAR_5->entry[VAR_7].path, VAR_9, VAR_3) == 0 &&
            VAR_5->entry[VAR_7].path[VAR_3] == 0)
            break;
    }
    gs_free_object(VAR_8->memory, VAR_9, ""gs_remove_control_path_len"");
    if (VAR_7 == VAR_6)
        return 0;

    gs_free_object(VAR_8->memory, VAR_5->entry[VAR_7].path, ""gs_lib_ctx(path)"");
    for (;VAR_7 < VAR_6-1; VAR_7++)
        VAR_5->entry[VAR_7] = VAR_5->entry[VAR_7+1];
    VAR_5->num = VAR_6-1;

    return 0;
}",ArtifexSoftware/ghostpdl/0974e4f2ac0005d3731e0b5c13ebc7e965540f4d/gslibctx.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -31,7 +31,7 @@
     /* ""%pipe%"" do not follow the normal rules for path definitions, so we
        don't ""reduce"" them to avoid unexpected results
      */
-    if (len > 5 && memcmp(path, ""%pipe"", 5) != 0) {
+    if (path[0] == '|' || (len > 5 && memcmp(path, ""%pipe"", 5) == 0)) {
         buffer = (char *)gs_alloc_bytes(core->memory, len + 1, ""gs_remove_control_path_len"");
         if (buffer == NULL)
             return gs_error_VMerror;","{'deleted_lines': ['    if (len > 5 && memcmp(path, ""%pipe"", 5) != 0) {'], 'added_lines': ['    if (path[0] == \'|\' || (len > 5 && memcmp(path, ""%pipe"", 5) == 0)) {']}",True,Artifex Ghostscript through 10.01.2 mishandles permission validation for pipe devices (with the %pipe% prefix or the | pipe character prefix).,7.8,HIGH,2,test,2023-06-14T08:08:12Z,4
CVE-2023-36664,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,ArtifexSoftware/ghostpdl,"Bug 706778: 706761 revisit

Two problems with the original commit. The first a silly typo inverting the
logic of a test.

The second was forgetting that we actually actually validate two candidate
strings for pipe devices. One with the expected ""%pipe%"" prefix, the other
using the pipe character prefix: ""|"".

This addresses both those.",0974e4f2ac0005d3731e0b5c13ebc7e965540f4d,https://github.com/ArtifexSoftware/ghostpdl/commit/0974e4f2ac0005d3731e0b5c13ebc7e965540f4d,base/gpmisc.c,gp_validate_path_len,"int
gp_validate_path_len(const gs_memory_t *mem,
const char        *path,
const uint         len,
const char        *mode)
{
char *buffer, *bufferfull;
uint rlen;
int code = 0;
const char *cdirstr = gp_file_name_current();
int cdirstrl = strlen(cdirstr);
const char *dirsepstr = gp_file_name_separator();
int dirsepstrl = strlen(dirsepstr);
int prefix_len = cdirstrl + dirsepstrl;
if (path == NULL || mem->gs_lib_ctx == NULL ||
mem->gs_lib_ctx->core->path_control_active == 0)
return 0;
if (gp_file_name_is_absolute(path, len)) {
prefix_len = cdirstrl = dirsepstrl = 0;
}
else if (len > prefix_len && !memcmp(path, cdirstr, cdirstrl)
&& !memcmp(path + cdirstrl, dirsepstr, dirsepstrl)) {
prefix_len = 0;
}
if (len > 5 && memcmp(path, ""%pipe"", 5) != 0) {
bufferfull = buffer = (char *)gs_alloc_bytes(mem->thread_safe_memory, len + 1, ""gp_validate_path"");
if (buffer == NULL)
return gs_error_VMerror;
memcpy(buffer, path, len);
buffer[len] = 0;
rlen = len;
}
else {
rlen = len+1;
bufferfull = (char *)gs_alloc_bytes(mem->thread_safe_memory, rlen + prefix_len, ""gp_validate_path"");
if (bufferfull == NULL)
return gs_error_VMerror;
buffer = bufferfull + prefix_len;
if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
return gs_error_invalidfileaccess;
buffer[rlen] = 0;
}
while (1) {
switch (mode[0])
{
case 'r': 
code = validate(mem, buffer, gs_permit_file_reading);
break;
case 'w': 
code = validate(mem, buffer, gs_permit_file_writing);
break;
case 'a': 
code = (validate(mem, buffer, gs_permit_file_reading) |
validate(mem, buffer, gs_permit_file_writing));
break;
case 'c': 
code =  validate(mem, buffer, gs_permit_file_control);
break;
case 'd': 
code =  validate(mem, buffer, gs_permit_file_control);
break;
case 'f': 
code = (validate(mem, buffer, gs_permit_file_writing) |
validate(mem, buffer, gs_permit_file_control));
break;
case 't': 
code = (validate(mem, buffer, gs_permit_file_writing) |
validate(mem, buffer, gs_permit_file_control));
break;
default:
errprintf(mem, ""gp_validate_path: Unknown mode='%s'\n"", mode);
code = gs_note_error(gs_error_invalidfileaccess);
}
if (code < 0 && prefix_len > 0 && buffer > bufferfull) {
buffer = bufferfull;
memcpy(buffer, cdirstr, cdirstrl);
memcpy(buffer + cdirstrl, dirsepstr, dirsepstrl);
continue;
}
else if (code < 0 && cdirstrl > 0 && prefix_len == 0 && buffer == bufferfull) {
buffer = bufferfull + cdirstrl + dirsepstrl;
continue;
}
break;
}
if (code > 0 && (mode[0] == 'd' || mode[0] == 'f') &&
(code & gs_path_control_flag_is_scratch_file) != 0) {
(void)gs_remove_control_path_flags(mem, gs_permit_file_reading, buffer,
gs_path_control_flag_is_scratch_file);
(void)gs_remove_control_path_flags(mem, gs_permit_file_writing, buffer,
gs_path_control_flag_is_scratch_file);
(void)gs_remove_control_path_flags(mem, gs_permit_file_control, buffer,
gs_path_control_flag_is_scratch_file);
}
gs_free_object(mem->thread_safe_memory, bufferfull, ""gp_validate_path"");
#ifdef EACCES
if (code == gs_error_invalidfileaccess)
errno = EACCES;
#endif
return code < 0 ? code : 0;
}","int
gp_validate_path_len(const gs_memory_t *VAR_0,
const char        *VAR_1,
const uint         VAR_2,
const char        *VAR_3)
{
char *VAR_4, *VAR_5;
uint VAR_6;
int VAR_7 = 0;
const char *VAR_8 = gp_file_name_current();
int VAR_9 = strlen(VAR_8);
const char *VAR_10 = gp_file_name_separator();
int VAR_11 = strlen(VAR_10);
int VAR_12 = VAR_9 + VAR_11;
if (VAR_1 == NULL || VAR_0->gs_lib_ctx == NULL ||
VAR_0->gs_lib_ctx->core->path_control_active == 0)
return 0;
if (gp_file_name_is_absolute(VAR_1, VAR_2)) {
VAR_12 = VAR_9 = VAR_11 = 0;
}
else if (VAR_2 > VAR_12 && !memcmp(VAR_1, VAR_8, VAR_9)
&& !memcmp(VAR_1 + VAR_9, VAR_10, VAR_11)) {
VAR_12 = 0;
}
if (VAR_2 > 5 && memcmp(VAR_1, ""%pipe"", 5) != 0) {
VAR_5 = VAR_4 = (char *)gs_alloc_bytes(VAR_0->thread_safe_memory, VAR_2 + 1, ""gp_validate_path"");
if (VAR_4 == NULL)
return VAR_13;
memcpy(VAR_4, VAR_1, VAR_2);
VAR_4[VAR_2] = 0;
VAR_6 = VAR_2;
}
else {
VAR_6 = VAR_2+1;
VAR_5 = (char *)gs_alloc_bytes(VAR_0->thread_safe_memory, VAR_6 + VAR_12, ""gp_validate_path"");
if (VAR_5 == NULL)
return VAR_13;
VAR_4 = VAR_5 + VAR_12;
if (gp_file_name_reduce(VAR_1, (uint)VAR_2, VAR_4, &VAR_6) != VAR_14)
return VAR_15;
VAR_4[VAR_6] = 0;
}
while (1) {
switch (VAR_3[0])
{
case 'r': 
VAR_7 = validate(VAR_0, VAR_4, VAR_16);
break;
case 'w': 
VAR_7 = validate(VAR_0, VAR_4, VAR_17);
break;
case 'a': 
VAR_7 = (validate(VAR_0, VAR_4, VAR_16) |
validate(VAR_0, VAR_4, VAR_17));
break;
case 'c': 
VAR_7 =  validate(VAR_0, VAR_4, VAR_18);
break;
case 'd': 
VAR_7 =  validate(VAR_0, VAR_4, VAR_18);
break;
case 'f': 
VAR_7 = (validate(VAR_0, VAR_4, VAR_17) |
validate(VAR_0, VAR_4, VAR_18));
break;
case 't': 
VAR_7 = (validate(VAR_0, VAR_4, VAR_17) |
validate(VAR_0, VAR_4, VAR_18));
break;
default:
errprintf(VAR_0, ""gp_validate_path: Unknown mode='%s'\n"", VAR_3);
VAR_7 = gs_note_error(VAR_15);
}
if (VAR_7 < 0 && VAR_12 > 0 && VAR_4 > VAR_5) {
VAR_4 = VAR_5;
memcpy(VAR_4, VAR_8, VAR_9);
memcpy(VAR_4 + VAR_9, VAR_10, VAR_11);
continue;
}
else if (VAR_7 < 0 && VAR_9 > 0 && VAR_12 == 0 && VAR_4 == VAR_5) {
VAR_4 = VAR_5 + VAR_9 + VAR_11;
continue;
}
break;
}
if (VAR_7 > 0 && (VAR_3[0] == 'd' || VAR_3[0] == 'f') &&
(VAR_7 & VAR_19) != 0) {
(void)gs_remove_control_path_flags(VAR_0, VAR_16, VAR_4,
VAR_19);
(void)gs_remove_control_path_flags(VAR_0, VAR_17, VAR_4,
VAR_19);
(void)gs_remove_control_path_flags(VAR_0, VAR_18, VAR_4,
VAR_19);
}
gs_free_object(VAR_0->thread_safe_memory, VAR_5, ""gp_validate_path"");
#ifdef VAR_20
if (VAR_7 == VAR_15)
VAR_21 = VAR_20;
#endif
return VAR_7 < 0 ? VAR_7 : 0;
}",ArtifexSoftware/ghostpdl/0974e4f2ac0005d3731e0b5c13ebc7e965540f4d/gpmisc.c/vul/before/0.json,"int
gp_validate_path_len(const gs_memory_t *mem,
                     const char        *path,
                     const uint         len,
                     const char        *mode)
{
    char *buffer, *bufferfull;
    uint rlen;
    int code = 0;
    const char *cdirstr = gp_file_name_current();
    int cdirstrl = strlen(cdirstr);
    const char *dirsepstr = gp_file_name_separator();
    int dirsepstrl = strlen(dirsepstr);
    int prefix_len = cdirstrl + dirsepstrl;

    /* mem->gs_lib_ctx can be NULL when we're called from mkromfs */
    /* If path == NULL, don't care */
    if (path == NULL || mem->gs_lib_ctx == NULL ||
        mem->gs_lib_ctx->core->path_control_active == 0)
        return 0;

    /* For current directory accesses, we need handle both a ""bare"" name,
     * and one with a cwd prefix (in Unix terms, both ""myfile.ps"" and
     * ""./myfile.ps"".
     *
     * So we check up front if it's absolute, then just use that.
     * If it includes cwd prefix, we try that, then remove the prefix
     * and try again.
     * If it doesn't include the cwd prefix, we try it, then add the
     * prefix and try again.
     * To facilitate that, we allocate a large enough buffer to take
     * the path *and* the prefix up front.
     */
    if (gp_file_name_is_absolute(path, len)) {
       /* Absolute path, we don't need anything extra */
       prefix_len = cdirstrl = dirsepstrl = 0;
    }
    else if (len > prefix_len && !memcmp(path, cdirstr, cdirstrl)
             && !memcmp(path + cdirstrl, dirsepstr, dirsepstrl)) {
          prefix_len = 0;
    }

    /* ""%pipe%"" do not follow the normal rules for path definitions, so we
       don't ""reduce"" them to avoid unexpected results
     */
    if (path[0] == '|' || (len > 5 && memcmp(path, ""%pipe"", 5) == 0)) {
        bufferfull = buffer = (char *)gs_alloc_bytes(mem->thread_safe_memory, len + 1, ""gp_validate_path"");
        if (buffer == NULL)
            return gs_error_VMerror;
        memcpy(buffer, path, len);
        buffer[len] = 0;
        rlen = len;
    }
    else {
        rlen = len+1;
        bufferfull = (char *)gs_alloc_bytes(mem->thread_safe_memory, rlen + prefix_len, ""gp_validate_path"");
        if (bufferfull == NULL)
            return gs_error_VMerror;

        buffer = bufferfull + prefix_len;
        if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
            return gs_error_invalidfileaccess;
        buffer[rlen] = 0;
    }
    while (1) {
        switch (mode[0])
        {
        case 'r': /* Read */
            code = validate(mem, buffer, gs_permit_file_reading);
            break;
        case 'w': /* Write */
            code = validate(mem, buffer, gs_permit_file_writing);
            break;
        case 'a': /* Append needs reading and writing */
            code = (validate(mem, buffer, gs_permit_file_reading) |
                    validate(mem, buffer, gs_permit_file_writing));
            break;
        case 'c': /* ""Control"" */
            code =  validate(mem, buffer, gs_permit_file_control);
            break;
        case 'd': /* ""Delete"" (special case of control) */
            code =  validate(mem, buffer, gs_permit_file_control);
            break;
        case 'f': /* ""Rename from"" */
            code = (validate(mem, buffer, gs_permit_file_writing) |
                    validate(mem, buffer, gs_permit_file_control));
            break;
        case 't': /* ""Rename to"" */
            code = (validate(mem, buffer, gs_permit_file_writing) |
                    validate(mem, buffer, gs_permit_file_control));
            break;
        default:
            errprintf(mem, ""gp_validate_path: Unknown mode='%s'\n"", mode);
            code = gs_note_error(gs_error_invalidfileaccess);
        }
        if (code < 0 && prefix_len > 0 && buffer > bufferfull) {
            buffer = bufferfull;
            memcpy(buffer, cdirstr, cdirstrl);
            memcpy(buffer + cdirstrl, dirsepstr, dirsepstrl);
            continue;
        }
        else if (code < 0 && cdirstrl > 0 && prefix_len == 0 && buffer == bufferfull) {
            buffer = bufferfull + cdirstrl + dirsepstrl;
            continue;
        }
        break;
    }
    if (code > 0 && (mode[0] == 'd' || mode[0] == 'f') &&
        (code & gs_path_control_flag_is_scratch_file) != 0) {
        (void)gs_remove_control_path_flags(mem, gs_permit_file_reading, buffer,
                                           gs_path_control_flag_is_scratch_file);
        (void)gs_remove_control_path_flags(mem, gs_permit_file_writing, buffer,
                                           gs_path_control_flag_is_scratch_file);
        (void)gs_remove_control_path_flags(mem, gs_permit_file_control, buffer,
                                           gs_path_control_flag_is_scratch_file);
    }

    gs_free_object(mem->thread_safe_memory, bufferfull, ""gp_validate_path"");
#ifdef EACCES
    if (code == gs_error_invalidfileaccess)
        errno = EACCES;
#endif

    return code < 0 ? code : 0;
}","int
gp_validate_path_len(const gs_memory_t *VAR_0,
                     const char        *VAR_1,
                     const uint         VAR_2,
                     const char        *VAR_3)
{
    char *VAR_4, *VAR_5;
    uint VAR_6;
    int VAR_7 = 0;
    const char *VAR_8 = gp_file_name_current();
    int VAR_9 = strlen(VAR_8);
    const char *VAR_10 = gp_file_name_separator();
    int VAR_11 = strlen(VAR_10);
    int VAR_12 = VAR_9 + VAR_11;

    /* COMMENT_0 */
    /* COMMENT_1 */
    if (VAR_1 == NULL || VAR_0->gs_lib_ctx == NULL ||
        VAR_0->gs_lib_ctx->core->path_control_active == 0)
        return 0;

    /* COMMENT_2 */
                                                                     
                     
      
                                                                 
                                                                     
                     
                                                                    
                            
                                                                    
                                          
       
    if (gp_file_name_is_absolute(VAR_1, VAR_2)) {
       /* COMMENT_14 */
       VAR_12 = VAR_9 = VAR_11 = 0;
    }
    else if (VAR_2 > VAR_12 && !memcmp(VAR_1, VAR_8, VAR_9)
             && !memcmp(VAR_1 + VAR_9, VAR_10, VAR_11)) {
          VAR_12 = 0;
    }

    /* COMMENT_15 */
                                                      
       
    if (VAR_1[0] == '|' || (VAR_2 > 5 && memcmp(VAR_1, ""%pipe"", 5) == 0)) {
        VAR_5 = VAR_4 = (char *)gs_alloc_bytes(VAR_0->thread_safe_memory, VAR_2 + 1, ""gp_validate_path"");
        if (VAR_4 == NULL)
            return VAR_13;
        memcpy(VAR_4, VAR_1, VAR_2);
        VAR_4[VAR_2] = 0;
        VAR_6 = VAR_2;
    }
    else {
        VAR_6 = VAR_2+1;
        VAR_5 = (char *)gs_alloc_bytes(VAR_0->thread_safe_memory, VAR_6 + VAR_12, ""gp_validate_path"");
        if (VAR_5 == NULL)
            return VAR_13;

        VAR_4 = VAR_5 + VAR_12;
        if (gp_file_name_reduce(VAR_1, (uint)VAR_2, VAR_4, &VAR_6) != VAR_14)
            return VAR_15;
        VAR_4[VAR_6] = 0;
    }
    while (1) {
        switch (VAR_3[0])
        {
        case 'r': /* COMMENT_18 */
            VAR_7 = validate(VAR_0, VAR_4, VAR_16);
            break;
        case 'w': /* COMMENT_19 */
            VAR_7 = validate(VAR_0, VAR_4, VAR_17);
            break;
        case 'a': /* COMMENT_20 */
            VAR_7 = (validate(VAR_0, VAR_4, VAR_16) |
                    validate(VAR_0, VAR_4, VAR_17));
            break;
        case 'c': /* COMMENT_21 */
            VAR_7 =  validate(VAR_0, VAR_4, VAR_18);
            break;
        case 'd': /* COMMENT_22 */
            VAR_7 =  validate(VAR_0, VAR_4, VAR_18);
            break;
        case 'f': /* COMMENT_23 */
            VAR_7 = (validate(VAR_0, VAR_4, VAR_17) |
                    validate(VAR_0, VAR_4, VAR_18));
            break;
        case 't': /* COMMENT_24 */
            VAR_7 = (validate(VAR_0, VAR_4, VAR_17) |
                    validate(VAR_0, VAR_4, VAR_18));
            break;
        default:
            errprintf(VAR_0, ""gp_validate_path: Unknown mode='%s'\n"", VAR_3);
            VAR_7 = gs_note_error(VAR_15);
        }
        if (VAR_7 < 0 && VAR_12 > 0 && VAR_4 > VAR_5) {
            VAR_4 = VAR_5;
            memcpy(VAR_4, VAR_8, VAR_9);
            memcpy(VAR_4 + VAR_9, VAR_10, VAR_11);
            continue;
        }
        else if (VAR_7 < 0 && VAR_9 > 0 && VAR_12 == 0 && VAR_4 == VAR_5) {
            VAR_4 = VAR_5 + VAR_9 + VAR_11;
            continue;
        }
        break;
    }
    if (VAR_7 > 0 && (VAR_3[0] == 'd' || VAR_3[0] == 'f') &&
        (VAR_7 & VAR_19) != 0) {
        (void)gs_remove_control_path_flags(VAR_0, VAR_16, VAR_4,
                                           VAR_19);
        (void)gs_remove_control_path_flags(VAR_0, VAR_17, VAR_4,
                                           VAR_19);
        (void)gs_remove_control_path_flags(VAR_0, VAR_18, VAR_4,
                                           VAR_19);
    }

    gs_free_object(VAR_0->thread_safe_memory, VAR_5, ""gp_validate_path"");
#ifdef VAR_20
    if (VAR_7 == VAR_15)
        VAR_21 = VAR_20;
#endif

    return VAR_7 < 0 ? VAR_7 : 0;
}",ArtifexSoftware/ghostpdl/0974e4f2ac0005d3731e0b5c13ebc7e965540f4d/gpmisc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -43,7 +43,7 @@
     /* ""%pipe%"" do not follow the normal rules for path definitions, so we
        don't ""reduce"" them to avoid unexpected results
      */
-    if (len > 5 && memcmp(path, ""%pipe"", 5) != 0) {
+    if (path[0] == '|' || (len > 5 && memcmp(path, ""%pipe"", 5) == 0)) {
         bufferfull = buffer = (char *)gs_alloc_bytes(mem->thread_safe_memory, len + 1, ""gp_validate_path"");
         if (buffer == NULL)
             return gs_error_VMerror;","{'deleted_lines': ['    if (len > 5 && memcmp(path, ""%pipe"", 5) != 0) {'], 'added_lines': ['    if (path[0] == \'|\' || (len > 5 && memcmp(path, ""%pipe"", 5) == 0)) {']}",True,Artifex Ghostscript through 10.01.2 mishandles permission validation for pipe devices (with the %pipe% prefix or the | pipe character prefix).,7.8,HIGH,2,test,2023-06-14T08:08:12Z,4
CVE-2023-36364,['CWE-Other'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,MonetDB,"add test and fix for bug #7386, lookup of alias columns fixed",6880f193583f0c80a58d477f6339958e7f078a89,https://github.com/MonetDB/MonetDB/commit/6880f193583f0c80a58d477f6339958e7f078a89,sql/server/rel_rel.c,rel_deps,"static int
rel_deps(mvc *sql, sql_rel *r, list *refs, list *l)
{
if (mvc_highwater(sql)) {
(void) sql_error(sql, 10, SQLSTATE(42000) ""Query too complex: running out of stack space"");
return -1;
}
if (!r)
return 0;
if (rel_is_ref(r) && refs_find_rel(refs, r)) 
return 0;
switch (r->op) {
case op_basetable: {
sql_table *t = r->l;
cond_append(l, &t->base);
for (node *en = r->exps->h; en; en = en->next) {
sql_exp *exp = en->data;
const char *oname = exp->r;
assert(!is_func(exp->type));
if (oname[0] == '%' && strcmp(oname, TID) == 0) {
continue;
} else if (oname[0] == '%') {
sql_idx *i = find_sql_idx(t, oname+1);
cond_append(l, &i->base);
} else {
sql_column *c = find_sql_column(t, oname);
cond_append(l, &c->base);
}
}
} break;
case op_table: {
if ((IS_TABLE_PROD_FUNC(r->flag) || r->flag == TABLE_FROM_RELATION) && r->r) { 
sql_exp *op = r->r;
sql_subfunc *f = op->f;
cond_append(l, &f->func->base);
}
} break;
case op_join:
case op_left:
case op_right:
case op_full:
case op_semi:
case op_anti:
case op_union:
case op_except:
case op_inter:
case op_insert:
case op_update:
case op_delete:
case op_merge:
if (rel_deps(sql, r->l, refs, l) != 0 ||
rel_deps(sql, r->r, refs, l) != 0)
return -1;
break;
case op_project:
case op_select:
case op_groupby:
case op_topn:
case op_sample:
case op_truncate:
if (rel_deps(sql, r->l, refs, l) != 0)
return -1;
break;
case op_ddl:
if (r->flag == ddl_output || r->flag == ddl_create_seq || r->flag == ddl_alter_seq || r->flag == ddl_alter_table || r->flag == ddl_create_table || r->flag == ddl_create_view) {
if (rel_deps(sql, r->l, refs, l) != 0)
return -1;
} else if (r->flag == ddl_list || r->flag == ddl_exception) {
if (rel_deps(sql, r->l, refs, l) != 0 ||
rel_deps(sql, r->r, refs, l) != 0)
return -1;
}
break;
}
if (!is_base(r->op) && r->exps) {
if (exps_deps(sql, r->exps, refs, l) != 0)
return -1;
}
if ((is_simple_project(r->op) || is_groupby(r->op)) && r->r) {
if (exps_deps(sql, r->r, refs, l) != 0)
return -1;
}
if (rel_is_ref(r)) {
list_append(refs, r);
list_append(refs, l);
}
return 0;
}","static int
rel_deps(mvc *VAR_0, sql_rel *VAR_1, list *VAR_2, list *VAR_3)
{
if (mvc_highwater(VAR_0)) {
(void) sql_error(VAR_0, 10, SQLSTATE(42000) ""Query too complex: running out of stack space"");
return -1;
}
if (!VAR_1)
return 0;
if (rel_is_ref(VAR_1) && refs_find_rel(VAR_2, VAR_1)) 
return 0;
switch (VAR_1->op) {
case VAR_4: {
sql_table *VAR_5 = VAR_1->l;
cond_append(VAR_3, &VAR_5->base);
for (node *VAR_6 = VAR_1->exps->h; VAR_6; VAR_6 = VAR_6->next) {
sql_exp *VAR_7 = VAR_6->data;
const char *VAR_8 = VAR_7->r;
assert(!is_func(VAR_7->type));
if (VAR_8[0] == '%' && strcmp(VAR_8, VAR_9) == 0) {
continue;
} else if (VAR_8[0] == '%') {
sql_idx *VAR_10 = find_sql_idx(VAR_5, VAR_8+1);
cond_append(VAR_3, &VAR_10->base);
} else {
sql_column *VAR_11 = find_sql_column(VAR_5, VAR_8);
cond_append(VAR_3, &VAR_11->base);
}
}
} break;
case VAR_12: {
if ((IS_TABLE_PROD_FUNC(VAR_1->flag) || VAR_1->flag == VAR_13) && VAR_1->r) { 
sql_exp *VAR_14 = VAR_1->r;
sql_subfunc *VAR_15 = VAR_14->f;
cond_append(VAR_3, &VAR_15->func->base);
}
} break;
case VAR_16:
case VAR_17:
case VAR_18:
case VAR_19:
case VAR_20:
case VAR_21:
case VAR_22:
case VAR_23:
case VAR_24:
case VAR_25:
case VAR_26:
case VAR_27:
case VAR_28:
if (rel_deps(VAR_0, VAR_1->l, VAR_2, VAR_3) != 0 ||
rel_deps(VAR_0, VAR_1->r, VAR_2, VAR_3) != 0)
return -1;
break;
case VAR_29:
case VAR_30:
case VAR_31:
case VAR_32:
case VAR_33:
case VAR_34:
if (rel_deps(VAR_0, VAR_1->l, VAR_2, VAR_3) != 0)
return -1;
break;
case VAR_35:
if (VAR_1->flag == VAR_36 || VAR_1->flag == VAR_37 || VAR_1->flag == VAR_38 || VAR_1->flag == VAR_39 || VAR_1->flag == VAR_40 || VAR_1->flag == VAR_41) {
if (rel_deps(VAR_0, VAR_1->l, VAR_2, VAR_3) != 0)
return -1;
} else if (VAR_1->flag == VAR_42 || VAR_1->flag == VAR_43) {
if (rel_deps(VAR_0, VAR_1->l, VAR_2, VAR_3) != 0 ||
rel_deps(VAR_0, VAR_1->r, VAR_2, VAR_3) != 0)
return -1;
}
break;
}
if (!is_base(VAR_1->op) && VAR_1->exps) {
if (exps_deps(VAR_0, VAR_1->exps, VAR_2, VAR_3) != 0)
return -1;
}
if ((is_simple_project(VAR_1->op) || is_groupby(VAR_1->op)) && VAR_1->r) {
if (exps_deps(VAR_0, VAR_1->r, VAR_2, VAR_3) != 0)
return -1;
}
if (rel_is_ref(VAR_1)) {
list_append(VAR_2, VAR_1);
list_append(VAR_2, VAR_3);
}
return 0;
}",MonetDB/6880f193583f0c80a58d477f6339958e7f078a89/rel_rel.c/vul/before/1.json,"static int
rel_deps(mvc *sql, sql_rel *r, list *refs, list *l)
{
	if (mvc_highwater(sql)) {
		(void) sql_error(sql, 10, SQLSTATE(42000) ""Query too complex: running out of stack space"");
		return -1;
	}

	if (!r)
		return 0;

	if (rel_is_ref(r) && refs_find_rel(refs, r)) /* already handled */
		return 0;
	switch (r->op) {
	case op_basetable: {
		sql_table *t = r->l;

		cond_append(l, &t->base);
		/* find all used columns */
		for (node *en = r->exps->h; en; en = en->next) {
			sql_exp *exp = en->data;
			const char *oname = exp->r;

			assert(!is_func(exp->type));
			if (oname[0] == '%' && strcmp(oname, TID) == 0) {
				continue;
			} else if (oname[0] == '%') {
				sql_idx *i = find_sql_idx(t, oname+1);
				if (i) {
					cond_append(l, &i->base);
					continue;
				}
			}
			sql_column *c = find_sql_column(t, oname);
			if (!c)
				return -1;
			cond_append(l, &c->base);
		}
	} break;
	case op_table: {
		if ((IS_TABLE_PROD_FUNC(r->flag) || r->flag == TABLE_FROM_RELATION) && r->r) { /* table producing function, excluding rel_relational_func cases */
			sql_exp *op = r->r;
			sql_subfunc *f = op->f;
			cond_append(l, &f->func->base);
		}
	} break;
	case op_join:
	case op_left:
	case op_right:
	case op_full:
	case op_semi:
	case op_anti:
	case op_union:
	case op_except:
	case op_inter:

	case op_insert:
	case op_update:
	case op_delete:
	case op_merge:
		if (rel_deps(sql, r->l, refs, l) != 0 ||
			rel_deps(sql, r->r, refs, l) != 0)
			return -1;
		break;
	case op_project:
	case op_select:
	case op_groupby:
	case op_topn:
	case op_sample:
	case op_truncate:
		if (rel_deps(sql, r->l, refs, l) != 0)
			return -1;
		break;
	case op_ddl:
		if (r->flag == ddl_output || r->flag == ddl_create_seq || r->flag == ddl_alter_seq || r->flag == ddl_alter_table || r->flag == ddl_create_table || r->flag == ddl_create_view) {
			if (rel_deps(sql, r->l, refs, l) != 0)
				return -1;
		} else if (r->flag == ddl_list || r->flag == ddl_exception) {
			if (rel_deps(sql, r->l, refs, l) != 0 ||
				rel_deps(sql, r->r, refs, l) != 0)
				return -1;
		}
		break;
	}
	if (!is_base(r->op) && r->exps) {
		if (exps_deps(sql, r->exps, refs, l) != 0)
			return -1;
	}
	if ((is_simple_project(r->op) || is_groupby(r->op)) && r->r) {
		if (exps_deps(sql, r->r, refs, l) != 0)
			return -1;
	}
	if (rel_is_ref(r)) {
		list_append(refs, r);
		list_append(refs, l);
	}
	return 0;
}","static int
rel_deps(mvc *VAR_0, sql_rel *VAR_1, list *VAR_2, list *VAR_3)
{
	if (mvc_highwater(VAR_0)) {
		(void) sql_error(VAR_0, 10, SQLSTATE(42000) ""Query too complex: running out of stack space"");
		return -1;
	}

	if (!VAR_1)
		return 0;

	if (rel_is_ref(VAR_1) && refs_find_rel(VAR_2, VAR_1)) /* COMMENT_0 */
		return 0;
	switch (VAR_1->op) {
	case VAR_4: {
		sql_table *VAR_5 = VAR_1->l;

		cond_append(VAR_3, &VAR_5->base);
		/* COMMENT_1 */
		for (node *VAR_6 = VAR_1->exps->h; VAR_6; VAR_6 = VAR_6->next) {
			sql_exp *VAR_7 = VAR_6->data;
			const char *VAR_8 = VAR_7->r;

			assert(!is_func(VAR_7->type));
			if (VAR_8[0] == '%' && strcmp(VAR_8, VAR_9) == 0) {
				continue;
			} else if (VAR_8[0] == '%') {
				sql_idx *VAR_10 = find_sql_idx(VAR_5, VAR_8+1);
				if (VAR_10) {
					cond_append(VAR_3, &VAR_10->base);
					continue;
				}
			}
			sql_column *VAR_11 = find_sql_column(VAR_5, VAR_8);
			if (!VAR_11)
				return -1;
			cond_append(VAR_3, &VAR_11->base);
		}
	} break;
	case VAR_12: {
		if ((IS_TABLE_PROD_FUNC(VAR_1->flag) || VAR_1->flag == VAR_13) && VAR_1->r) { /* COMMENT_2 */
			sql_exp *VAR_14 = VAR_1->r;
			sql_subfunc *VAR_15 = VAR_14->f;
			cond_append(VAR_3, &VAR_15->func->base);
		}
	} break;
	case VAR_16:
	case VAR_17:
	case VAR_18:
	case VAR_19:
	case VAR_20:
	case VAR_21:
	case VAR_22:
	case VAR_23:
	case VAR_24:

	case VAR_25:
	case VAR_26:
	case VAR_27:
	case VAR_28:
		if (rel_deps(VAR_0, VAR_1->l, VAR_2, VAR_3) != 0 ||
			rel_deps(VAR_0, VAR_1->r, VAR_2, VAR_3) != 0)
			return -1;
		break;
	case VAR_29:
	case VAR_30:
	case VAR_31:
	case VAR_32:
	case VAR_33:
	case VAR_34:
		if (rel_deps(VAR_0, VAR_1->l, VAR_2, VAR_3) != 0)
			return -1;
		break;
	case VAR_35:
		if (VAR_1->flag == VAR_36 || VAR_1->flag == VAR_37 || VAR_1->flag == VAR_38 || VAR_1->flag == VAR_39 || VAR_1->flag == VAR_40 || VAR_1->flag == VAR_41) {
			if (rel_deps(VAR_0, VAR_1->l, VAR_2, VAR_3) != 0)
				return -1;
		} else if (VAR_1->flag == VAR_42 || VAR_1->flag == VAR_43) {
			if (rel_deps(VAR_0, VAR_1->l, VAR_2, VAR_3) != 0 ||
				rel_deps(VAR_0, VAR_1->r, VAR_2, VAR_3) != 0)
				return -1;
		}
		break;
	}
	if (!is_base(VAR_1->op) && VAR_1->exps) {
		if (exps_deps(VAR_0, VAR_1->exps, VAR_2, VAR_3) != 0)
			return -1;
	}
	if ((is_simple_project(VAR_1->op) || is_groupby(VAR_1->op)) && VAR_1->r) {
		if (exps_deps(VAR_0, VAR_1->r, VAR_2, VAR_3) != 0)
			return -1;
	}
	if (rel_is_ref(VAR_1)) {
		list_append(VAR_2, VAR_1);
		list_append(VAR_2, VAR_3);
	}
	return 0;
}",MonetDB/6880f193583f0c80a58d477f6339958e7f078a89/rel_rel.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -26,11 +26,15 @@
 				continue;
 			} else if (oname[0] == '%') {
 				sql_idx *i = find_sql_idx(t, oname+1);
-				cond_append(l, &i->base);
-			} else {
-				sql_column *c = find_sql_column(t, oname);
-				cond_append(l, &c->base);
+				if (i) {
+					cond_append(l, &i->base);
+					continue;
+				}
 			}
+			sql_column *c = find_sql_column(t, oname);
+			if (!c)
+				return -1;
+			cond_append(l, &c->base);
 		}
 	} break;
 	case op_table: {","{'deleted_lines': ['\t\t\t\tcond_append(l, &i->base);', '\t\t\t} else {', '\t\t\t\tsql_column *c = find_sql_column(t, oname);', '\t\t\t\tcond_append(l, &c->base);'], 'added_lines': ['\t\t\t\tif (i) {', '\t\t\t\t\tcond_append(l, &i->base);', '\t\t\t\t\tcontinue;', '\t\t\t\t}', '\t\t\tsql_column *c = find_sql_column(t, oname);', '\t\t\tif (!c)', '\t\t\t\treturn -1;', '\t\t\tcond_append(l, &c->base);']}",True,An issue in the rel_deps component of MonetDB Server v11.45.17 and v11.46.0 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.,7.5,HIGH,2,test,2023-06-18T15:21:58Z,4
CVE-2023-36364,['CWE-Other'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,MonetDB,"add test and fix for bug #7386, lookup of alias columns fixed",6880f193583f0c80a58d477f6339958e7f078a89,https://github.com/MonetDB/MonetDB/commit/6880f193583f0c80a58d477f6339958e7f078a89,sql/server/rel_rel.c,rel_groupby,"sql_rel *
rel_groupby(mvc *sql, sql_rel *l, list *groupbyexps )
{
sql_rel *rel = rel_create(sql->sa);
list *aggrs = new_exp_list(sql->sa);
node *en;
if(!rel || !aggrs) {
rel_destroy(rel);
return NULL;
}
rel->card = CARD_ATOM;
if (groupbyexps && list_length(groupbyexps) > 1) {
list *gexps = sa_list(sql->sa);
for (en = groupbyexps->h; en; en = en->next) {
sql_exp *e = en->data, *ne = exps_find_exp(gexps, e);
if (!ne) {
list_append(gexps, e);
} else {
const char *ername = exp_relname(e), *nername = exp_relname(ne), *ename = exp_name(e), *nename = exp_name(ne);
if ((ername && !nername) || (!ername && nername) || 
(ername && nername && strcmp(ername,nername) != 0) || strcmp(ename,nename) != 0)
list_append(gexps, e);
}
}
groupbyexps = gexps;
}
if (groupbyexps) {
rel->card = CARD_AGGR;
for (en = groupbyexps->h; en; en = en->next) {
sql_exp *e = en->data, *ne;
e->card = MIN(e->card, rel->card); 
ne = exp_ref(sql, e);
ne = exp_propagate(sql->sa, ne, e);
append(aggrs, ne);
}
}
rel->l = l;
rel->r = groupbyexps;
rel->exps = aggrs;
rel->nrcols = aggrs?list_length(aggrs):0;
rel->op = op_groupby;
rel->grouped = 1;
return rel;
}","sql_rel *
rel_groupby(mvc *VAR_0, sql_rel *VAR_1, list *VAR_2 )
{
sql_rel *VAR_3 = rel_create(VAR_0->sa);
list *VAR_4 = new_exp_list(VAR_0->sa);
node *VAR_5;
if(!VAR_3 || !VAR_4) {
rel_destroy(VAR_3);
return NULL;
}
VAR_3->card = VAR_6;
if (VAR_2 && list_length(VAR_2) > 1) {
list *VAR_7 = sa_list(VAR_0->sa);
for (VAR_5 = VAR_2->h; VAR_5; VAR_5 = VAR_5->next) {
sql_exp *VAR_8 = VAR_5->data, *VAR_9 = exps_find_exp(VAR_7, VAR_8);
if (!VAR_9) {
list_append(VAR_7, VAR_8);
} else {
const char *VAR_10 = exp_relname(VAR_8), *VAR_11 = exp_relname(VAR_9), *VAR_12 = exp_name(VAR_8), *VAR_13 = exp_name(VAR_9);
if ((VAR_10 && !VAR_11) || (!VAR_10 && VAR_11) || 
(VAR_10 && VAR_11 && strcmp(VAR_10,VAR_11) != 0) || strcmp(VAR_12,VAR_13) != 0)
list_append(VAR_7, VAR_8);
}
}
VAR_2 = VAR_7;
}
if (VAR_2) {
VAR_3->card = VAR_14;
for (VAR_5 = VAR_2->h; VAR_5; VAR_5 = VAR_5->next) {
sql_exp *VAR_8 = VAR_5->data, *VAR_9;
VAR_8->card = MIN(VAR_8->card, VAR_3->card); 
VAR_9 = exp_ref(VAR_0, VAR_8);
VAR_9 = exp_propagate(VAR_0->sa, VAR_9, VAR_8);
append(VAR_4, VAR_9);
}
}
VAR_3->l = VAR_1;
VAR_3->r = VAR_2;
VAR_3->exps = VAR_4;
VAR_3->nrcols = VAR_4?list_length(VAR_4):0;
VAR_3->op = VAR_15;
VAR_3->grouped = 1;
return VAR_3;
}",MonetDB/6880f193583f0c80a58d477f6339958e7f078a89/rel_rel.c/vul/before/0.json,"sql_rel *
rel_groupby(mvc *sql, sql_rel *l, list *groupbyexps )
{
	sql_rel *rel = rel_create(sql->sa);
	list *aggrs = new_exp_list(sql->sa);
	node *en;
	if(!rel || !aggrs) {
		rel_destroy(rel);
		return NULL;
	}

	rel->card = CARD_ATOM;
	/* reduce duplicates in groupbyexps */
	if (groupbyexps && list_length(groupbyexps) > 1) {
		list *gexps = sa_list(sql->sa);

		for (en = groupbyexps->h; en; en = en->next) {
			sql_exp *e = en->data, *ne = exps_find_exp(gexps, e);

			if (!ne) {
				list_append(gexps, e);
			} else {
				const char *ername = exp_relname(e), *nername = exp_relname(ne), *ename = exp_name(e), *nename = exp_name(ne);
				if ((ername && !nername) || (!ername && nername) ||
					(ername && nername && strcmp(ername,nername) != 0) || strcmp(ename,nename) != 0)
					list_append(gexps, e);
			}
		}
		groupbyexps = gexps;
	}

	if (groupbyexps) {
		rel->card = CARD_AGGR;
		for (en = groupbyexps->h; en; en = en->next) {
			sql_exp *e = en->data, *ne;

			/* after the group by the cardinality reduces */
			e->card = MIN(e->card, rel->card); /* if the column is an atom, the cardinality should not change */
			ne = exp_ref(sql, e);
			ne = exp_propagate(sql->sa, ne, e);
			append(aggrs, ne);
		}
	}
	rel->l = l;
	rel->r = groupbyexps;
	rel->exps = aggrs;
	rel->nrcols = aggrs?list_length(aggrs):0;
	rel->op = op_groupby;
	rel->grouped = 1;
	return rel;
}","sql_rel *
rel_groupby(mvc *VAR_0, sql_rel *VAR_1, list *VAR_2 )
{
	sql_rel *VAR_3 = rel_create(VAR_0->sa);
	list *VAR_4 = new_exp_list(VAR_0->sa);
	node *VAR_5;
	if(!VAR_3 || !VAR_4) {
		rel_destroy(VAR_3);
		return NULL;
	}

	VAR_3->card = VAR_6;
	/* COMMENT_0 */
	if (VAR_2 && list_length(VAR_2) > 1) {
		list *VAR_7 = sa_list(VAR_0->sa);

		for (VAR_5 = VAR_2->h; VAR_5; VAR_5 = VAR_5->next) {
			sql_exp *VAR_8 = VAR_5->data, *VAR_9 = exps_find_exp(VAR_7, VAR_8);

			if (!VAR_9) {
				list_append(VAR_7, VAR_8);
			} else {
				const char *VAR_10 = exp_relname(VAR_8), *VAR_11 = exp_relname(VAR_9), *VAR_12 = exp_name(VAR_8), *VAR_13 = exp_name(VAR_9);
				if ((VAR_10 && !VAR_11) || (!VAR_10 && VAR_11) ||
					(VAR_10 && VAR_11 && strcmp(VAR_10,VAR_11) != 0) || strcmp(VAR_12,VAR_13) != 0)
					list_append(VAR_7, VAR_8);
			}
		}
		VAR_2 = VAR_7;
	}

	if (VAR_2) {
		VAR_3->card = VAR_14;
		for (VAR_5 = VAR_2->h; VAR_5; VAR_5 = VAR_5->next) {
			sql_exp *VAR_8 = VAR_5->data, *VAR_9;

			/* COMMENT_1 */
			VAR_8->card = MIN(VAR_8->card, VAR_3->card); /* COMMENT_2 */
			VAR_9 = exp_ref(VAR_0, VAR_8);
			VAR_9 = exp_propagate(VAR_0->sa, VAR_9, VAR_8);
			append(VAR_4, VAR_9);
		}
	}
	VAR_3->l = VAR_1;
	VAR_3->r = VAR_2;
	VAR_3->exps = VAR_4;
	VAR_3->nrcols = VAR_4?list_length(VAR_4):0;
	VAR_3->op = VAR_15;
	VAR_3->grouped = 1;
	return VAR_3;
}",MonetDB/6880f193583f0c80a58d477f6339958e7f078a89/rel_rel.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -21,7 +21,7 @@
 				list_append(gexps, e);
 			} else {
 				const char *ername = exp_relname(e), *nername = exp_relname(ne), *ename = exp_name(e), *nename = exp_name(ne);
-				if ((ername && !nername) || (!ername && nername) || 
+				if ((ername && !nername) || (!ername && nername) ||
 					(ername && nername && strcmp(ername,nername) != 0) || strcmp(ename,nename) != 0)
 					list_append(gexps, e);
 			}","{'deleted_lines': ['\t\t\t\tif ((ername && !nername) || (!ername && nername) || '], 'added_lines': ['\t\t\t\tif ((ername && !nername) || (!ername && nername) ||']}",True,An issue in the rel_deps component of MonetDB Server v11.45.17 and v11.46.0 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.,7.5,HIGH,2,test,2023-06-18T15:21:58Z,4
CVE-2023-37186,['CWE-476'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Blosc/c-blosc2,Fix #522,d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3,https://github.com/Blosc/c-blosc2/commit/d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3,plugins/codecs/ndlz/ndlz4x4.c,ndlz4_compress,"int ndlz4_compress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,
uint8_t meta, blosc2_cparams *cparams) {
BLOSC_UNUSED_PARAM(meta);
uint8_t *smeta;
int32_t smeta_len;
if (blosc2_meta_get(cparams->schunk, ""b2nd"", &smeta, &smeta_len) < 0) {
BLOSC_TRACE_ERROR(""b2nd layer not found!"");
return BLOSC2_ERROR_FAILURE;
}
int8_t ndim;
int64_t *shape = malloc(8 * sizeof(int64_t));
int32_t *chunkshape = malloc(8 * sizeof(int32_t));
int32_t *blockshape = malloc(8 * sizeof(int32_t));
deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);
free(smeta);
if (ndim != 2) {
BLOSC_TRACE_ERROR(""This codec only works for ndim = 2"");
return BLOSC2_ERROR_FAILURE;
}
if (input_len != (blockshape[0] * blockshape[1])) {
BLOSC_TRACE_ERROR(""Length not equal to blocksize"");
return BLOSC2_ERROR_FAILURE;
}
if (NDLZ_UNEXPECT_CONDITIONAL(output_len < (int) (1 + ndim * sizeof(int32_t)))) {
BLOSC_TRACE_ERROR(""Output too small"");
return BLOSC2_ERROR_FAILURE;
}
uint8_t *ip = (uint8_t *) input;
uint8_t *op = (uint8_t *) output;
uint8_t *op_limit;
uint32_t hval, hash_cell;
uint32_t hash_triple[2] = {0};
uint32_t hash_pair[3] = {0};
uint8_t bufarea[16];
uint8_t *buf_cell = bufarea;
uint8_t buf_triple[12];
uint8_t buf_pair[8];
uint8_t *buf_aux;
uint32_t tab_cell[1U << 12U] = {0};
uint32_t tab_triple[1U << 12U] = {0};
uint32_t tab_pair[1U << 12U] = {0};
uint32_t update_triple[2] = {0};
uint32_t update_pair[3] = {0};
op_limit = op + output_len;
for (unsigned i = 0; i < (1U << 12U); i++) {
tab_cell[i] = 0;
}
int overhead = 17 + (blockshape[0] * blockshape[1] / 16 - 1) * 2;
if (input_len < 16 || output_len < overhead) {
BLOSC_TRACE_ERROR(""Incorrect length or maxout"");
return 0;
}
uint8_t *obase = op;
*op++ = ndim;
memcpy(op, &blockshape[0], 4);
op += 4;
memcpy(op, &blockshape[1], 4);
op += 4;
uint32_t i_stop[2];
for (int i = 0; i < 2; ++i) {
i_stop[i] = (blockshape[i] + 3) / 4;
}
uint32_t padding[2];
uint32_t ii[2];
for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {
for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {            uint8_t token;
for (int h = 0; h < 2; h++) {                 update_triple[h] = 0;
update_pair[h] = 0;
}
update_pair[2] = 0;
if (NDLZ_UNEXPECT_CONDITIONAL(op + 16 + 1 > op_limit)) {
free(shape);
free(chunkshape);
free(blockshape);
return 0;
}
uint32_t orig = ii[0] * 4 * blockshape[1] + ii[1] * 4;
if (((blockshape[0] % 4 != 0) && (ii[0] == i_stop[0] - 1)) ||
((blockshape[1] % 4 != 0) && (ii[1] == i_stop[1] - 1))) {
token = 0;                                           *op++ = token;
if (ii[0] == i_stop[0] - 1) {
padding[0] = (blockshape[0] % 4 == 0) ? 4 : blockshape[0] % 4;
} else {
padding[0] = 4;
}
if (ii[1] == i_stop[1] - 1) {
padding[1] = (blockshape[1] % 4 == 0) ? 4 : blockshape[1] % 4;
} else {
padding[1] = 4;
}
for (uint32_t i = 0; i < padding[0]; i++) {
memcpy(op, &ip[orig + i * blockshape[1]], padding[1]);
op += padding[1];
}
} else {
for (uint64_t i = 0; i < 4; i++) {                     uint64_t ind = orig + i * blockshape[1];
memcpy(buf_cell, &ip[ind], 4);
buf_cell += 4;
}
buf_cell -= 16;
const uint8_t *ref;
uint32_t distance;
uint8_t *anchor = op;    
hash_cell = XXH32(buf_cell, 16, 1);                hash_cell >>= 32U - 12U;
ref = obase + tab_cell[hash_cell];
if (tab_cell[hash_cell] == 0) {
distance = 0;
} else {
bool same = true;
buf_aux = obase + tab_cell[hash_cell];
for (int i = 0; i < 16; i++) {
if (buf_cell[i] != buf_aux[i]) {
same = false;
break;
}
}
if (same) {
distance = (int32_t) (anchor - ref);
} else {
distance = 0;
}
}
bool alleq = true;
for (int i = 1; i < 16; i++) {
if (buf_cell[i] != buf_cell[0]) {
alleq = false;
break;
}
}
if (alleq) {                                        token = (uint8_t) (1U << 6U);
*op++ = token;
*op++ = buf_cell[0];
} else if (distance == 0 || (distance >= MAX_DISTANCE)) {             bool literal = true;
for (int j = 1; j < 4; j++) {
memcpy(buf_pair, buf_cell, 4);
memcpy(&buf_pair[4], &buf_cell[j * 4], 4);
hval = XXH32(buf_pair, 8, 1);                    hval >>= 32U - 12U;
ref = obase + tab_pair[hval];
bool same = true;
uint16_t offset;
if (tab_pair[hval] != 0) {
buf_aux = obase + tab_pair[hval];
for (int k = 0; k < 8; k++) {
if (buf_pair[k] != buf_aux[k]) {
same = false;
break;
}
}
offset = (uint16_t) (anchor - obase - tab_pair[hval]);
} else {
same = false;
}
if (same) {
distance = (int32_t) (anchor - ref);
} else {
distance = 0;
}
if ((distance != 0) && (distance < MAX_DISTANCE)) {     
int k, m, l = -1;
for (k = 1; k < 4; k++) {
if (k != j) {
if (l == -1) {
l = k;
} else {
m = k;
}
}
}
memcpy(buf_pair, &buf_cell[l * 4], 4);
memcpy(&buf_pair[4], &buf_cell[m * 4], 4);
hval = XXH32(buf_pair, 8, 1);                      hval >>= 32U - 12U;
ref = obase + tab_pair[hval];
same = true;
if (tab_pair[hval] != 0) {
buf_aux = obase + tab_pair[hval];
for (k = 0; k < 8; k++) {
if (buf_pair[k] != buf_aux[k]) {
same = false;
break;
}
}
} else {
same = false;
}
if (same) {
distance = (int32_t) (anchor + l * 4 - ref);
} else {
distance = 0;
}
if ((distance != 0) && (distance < MAX_DISTANCE)) {   
literal = false;
token = (uint8_t) ((1U << 5U) | (j << 3U));
*op++ = token;
uint16_t offset_2 = (uint16_t) (anchor - obase - tab_pair[hval]);
*(uint16_t *) op = offset;
op += sizeof(offset);
*(uint16_t *) op = offset_2;
op += sizeof(offset_2);
goto match;
}
}
}
for (int i = 0; i < 2; i++) {
memcpy(buf_triple, &buf_cell[i * 4], 4);
for (int j = i + 1; j < 3; j++) {
memcpy(&buf_triple[4], &buf_cell[j * 4], 4);
for (int k = j + 1; k < 4; k++) {
memcpy(&buf_triple[8], &buf_cell[k * 4], 4);
hval = XXH32(buf_triple, 12, 1);                        hval >>= 32U - 12U;
bool same = true;
uint16_t offset;
if (tab_triple[hval] != 0) {
buf_aux = obase + tab_triple[hval];
for (int l = 0; l < 12; l++) {
if (buf_triple[l] != buf_aux[l]) {
same = false;
break;
}
}
offset = (uint16_t) (anchor - obase - tab_triple[hval]);
} else {
same = false;
if ((j - i == 1) && (k - j == 1)) {
update_triple[i] = (uint32_t) (anchor + 1 + i * 4 - obase);     
hash_triple[i] = hval;
}
}
ref = obase + tab_triple[hval];
if (same) {
distance = (int32_t) (anchor + i * 4 - ref);
} else {
distance = 0;
}
if ((distance != 0) && (distance < MAX_DISTANCE)) {
literal = false;
if (i == 1) {
token = (uint8_t) (7U << 5U);
} else {
token = (uint8_t) ((7U << 5U) | ((j + k - 2) << 3U));
}
*op++ = token;
memcpy(op, &offset, 2);
op += 2;
for (int l = 0; l < 4; l++) {
if ((l != i) && (l != j) && (l != k)) {
memcpy(op, &buf_cell[4 * l], 4);
op += 4;
goto match;
}
}
}
}
}
}
for (int i = 0; i < 3; i++) {
memcpy(buf_pair, &buf_cell[i * 4], 4);
for (int j = i + 1; j < 4; j++) {
memcpy(&buf_pair[4], &buf_cell[j * 4], 4);
hval = XXH32(buf_pair, 8, 1);                      hval >>= 32U - 12U;
ref = obase + tab_pair[hval];
bool same = true;
uint16_t offset;
if (tab_pair[hval] != 0) {
buf_aux = obase + tab_pair[hval];
for (int k = 0; k < 8; k++) {
if (buf_pair[k] != buf_aux[k]) {
same = false;
break;
}
}
offset = (uint16_t) (anchor - obase - tab_pair[hval]);
} else {
same = false;
if (j - i == 1) {
update_pair[i] = (uint32_t) (anchor + 1 + i * 4 - obase);     
hash_pair[i] = hval;
}
}
if (same) {
distance = (int32_t) (anchor + i * 4 - ref);
} else {
distance = 0;
}
if ((distance != 0) && (distance < MAX_DISTANCE)) {     
literal = false;
if (i == 2) {
token = (uint8_t) (1U << 7U);
} else {
token = (uint8_t) ((1U << 7U) | (i << 5U) | (j << 3U));
}
*op++ = token;
memcpy(op, &offset, 2);
op += 2;
for (int k = 0; k < 4; k++) {
if ((k != i) && (k != j)) {
memcpy(op, &buf_cell[4 * k], 4);
op += 4;
}
}
goto match;
}
}
}
match:
if (literal) {
tab_cell[hash_cell] = (uint32_t) (anchor + 1 - obase);     
if (update_triple[0] != 0) {
for (int h = 0; h < 2; h++) {
tab_triple[hash_triple[h]] = update_triple[h];
}
}
if (update_pair[0] != 0) {
for (int h = 0; h < 3; h++) {
tab_pair[hash_pair[h]] = update_pair[h];
}
}
token = 0;
*op++ = token;
memcpy(op, buf_cell, 16);
op += 16;
}
} else {             token = (uint8_t) ((1U << 7U) | (1U << 6U));
*op++ = token;
uint16_t offset = (uint16_t) (anchor - obase - tab_cell[hash_cell]);
memcpy(op, &offset, 2);
op += 2;
}
}
if ((op - obase) > input_len) {
BLOSC_TRACE_ERROR(""Compressed data is bigger than input!"");
return 0;
}
}
}
free(shape);
free(chunkshape);
free(blockshape);
return (int) (op - obase);
}","int ndlz4_compress(const uint8_t *VAR_0, int32_t VAR_1, uint8_t *VAR_2, int32_t VAR_3,
uint8_t VAR_4, blosc2_cparams *VAR_5) {
BLOSC_UNUSED_PARAM(VAR_4);
uint8_t *VAR_6;
int32_t VAR_7;
if (blosc2_meta_get(VAR_5->schunk, ""b2nd"", &VAR_6, &VAR_7) < 0) {
BLOSC_TRACE_ERROR(""b2nd layer not found!"");
return VAR_8;
}
int8_t VAR_9;
int64_t *VAR_10 = malloc(8 * sizeof(int64_t));
int32_t *VAR_11 = malloc(8 * sizeof(int32_t));
int32_t *VAR_12 = malloc(8 * sizeof(int32_t));
deserialize_meta(VAR_6, VAR_7, &VAR_9, VAR_10, VAR_11, VAR_12);
free(VAR_6);
if (VAR_9 != 2) {
BLOSC_TRACE_ERROR(""This codec only works for ndim = 2"");
return VAR_8;
}
if (VAR_1 != (VAR_12[0] * VAR_12[1])) {
BLOSC_TRACE_ERROR(""Length not equal to blocksize"");
return VAR_8;
}
if (NDLZ_UNEXPECT_CONDITIONAL(VAR_3 < (int) (1 + VAR_9 * sizeof(int32_t)))) {
BLOSC_TRACE_ERROR(""Output too small"");
return VAR_8;
}
uint8_t *VAR_13 = (uint8_t *) VAR_0;
uint8_t *VAR_14 = (uint8_t *) VAR_2;
uint8_t *VAR_15;
uint32_t VAR_16, VAR_17;
uint32_t VAR_18[2] = {0};
uint32_t VAR_19[3] = {0};
uint8_t VAR_20[16];
uint8_t *VAR_21 = VAR_20;
uint8_t VAR_22[12];
uint8_t VAR_23[8];
uint8_t *VAR_24;
uint32_t VAR_25[1U << 12U] = {0};
uint32_t VAR_26[1U << 12U] = {0};
uint32_t VAR_27[1U << 12U] = {0};
uint32_t VAR_28[2] = {0};
uint32_t VAR_29[3] = {0};
VAR_15 = VAR_14 + VAR_3;
for (unsigned VAR_30 = 0; VAR_30 < (1U << 12U); VAR_30++) {
VAR_25[VAR_30] = 0;
}
int VAR_31 = 17 + (VAR_12[0] * VAR_12[1] / 16 - 1) * 2;
if (VAR_1 < 16 || VAR_3 < VAR_31) {
BLOSC_TRACE_ERROR(""Incorrect length or maxout"");
return 0;
}
uint8_t *VAR_32 = VAR_14;
*VAR_14++ = VAR_9;
memcpy(VAR_14, &VAR_12[0], 4);
VAR_14 += 4;
memcpy(VAR_14, &VAR_12[1], 4);
VAR_14 += 4;
uint32_t VAR_33[2];
for (int VAR_30 = 0; VAR_30 < 2; ++VAR_30) {
VAR_33[VAR_30] = (VAR_12[VAR_30] + 3) / 4;
}
uint32_t VAR_34[2];
uint32_t VAR_35[2];
for (VAR_35[0] = 0; VAR_35[0] < VAR_33[0]; ++VAR_35[0]) {
for (VAR_35[1] = 0; VAR_35[1] < VAR_33[1]; ++VAR_35[1]) {      
uint8_t VAR_36;
for (int VAR_37 = 0; VAR_37 < 2; VAR_37++) {         
VAR_28[VAR_37] = 0;
VAR_29[VAR_37] = 0;
}
VAR_29[2] = 0;
if (NDLZ_UNEXPECT_CONDITIONAL(VAR_14 + 16 + 1 > VAR_15)) {
free(VAR_10);
free(VAR_11);
free(VAR_12);
return 0;
}
uint32_t VAR_38 = VAR_35[0] * 4 * VAR_12[1] + VAR_35[1] * 4;
if (((VAR_12[0] % 4 != 0) && (VAR_35[0] == VAR_33[0] - 1)) ||
((VAR_12[1] % 4 != 0) && (VAR_35[1] == VAR_33[1] - 1))) {
VAR_36 = 0;                                   
*VAR_14++ = VAR_36;
if (VAR_35[0] == VAR_33[0] - 1) {
VAR_34[0] = (VAR_12[0] % 4 == 0) ? 4 : VAR_12[0] % 4;
} else {
VAR_34[0] = 4;
}
if (VAR_35[1] == VAR_33[1] - 1) {
VAR_34[1] = (VAR_12[1] % 4 == 0) ? 4 : VAR_12[1] % 4;
} else {
VAR_34[1] = 4;
}
for (uint32_t VAR_30 = 0; VAR_30 < VAR_34[0]; VAR_30++) {
memcpy(VAR_14, &VAR_13[VAR_38 + VAR_30 * VAR_12[1]], VAR_34[1]);
VAR_14 += VAR_34[1];
}
} else {
for (uint64_t VAR_30 = 0; VAR_30 < 4; VAR_30++) {           
uint64_t VAR_39 = VAR_38 + VAR_30 * VAR_12[1];
memcpy(VAR_21, &VAR_13[VAR_39], 4);
VAR_21 += 4;
}
VAR_21 -= 16;
const uint8_t *VAR_40;
uint32_t VAR_41;
uint8_t *VAR_42 = VAR_14;    
VAR_17 = XXH32(VAR_21, 16, 1);        
VAR_17 >>= 32U - 12U;
VAR_40 = VAR_32 + VAR_25[VAR_17];
if (VAR_25[VAR_17] == 0) {
VAR_41 = 0;
} else {
bool VAR_43 = true;
VAR_24 = VAR_32 + VAR_25[VAR_17];
for (int VAR_30 = 0; VAR_30 < 16; VAR_30++) {
if (VAR_21[VAR_30] != VAR_24[VAR_30]) {
VAR_43 = false;
break;
}
}
if (VAR_43) {
VAR_41 = (int32_t) (VAR_42 - VAR_40);
} else {
VAR_41 = 0;
}
}
bool VAR_44 = true;
for (int VAR_30 = 1; VAR_30 < 16; VAR_30++) {
if (VAR_21[VAR_30] != VAR_21[0]) {
VAR_44 = false;
break;
}
}
if (VAR_44) {                              
VAR_36 = (uint8_t) (1U << 6U);
*VAR_14++ = VAR_36;
*VAR_14++ = VAR_21[0];
} else if (VAR_41 == 0 || (VAR_41 >= VAR_45)) {   
bool VAR_46 = true;
for (int VAR_47 = 1; VAR_47 < 4; VAR_47++) {
memcpy(VAR_23, VAR_21, 4);
memcpy(&VAR_23[4], &VAR_21[VAR_47 * 4], 4);
VAR_16 = XXH32(VAR_23, 8, 1);        
VAR_16 >>= 32U - 12U;
VAR_40 = VAR_32 + VAR_27[VAR_16];
bool VAR_43 = true;
uint16_t VAR_48;
if (VAR_27[VAR_16] != 0) {
VAR_24 = VAR_32 + VAR_27[VAR_16];
for (int VAR_49 = 0; VAR_49 < 8; VAR_49++) {
if (VAR_23[VAR_49] != VAR_24[VAR_49]) {
VAR_43 = false;
break;
}
}
VAR_48 = (uint16_t) (VAR_42 - VAR_32 - VAR_27[VAR_16]);
} else {
VAR_43 = false;
}
if (VAR_43) {
VAR_41 = (int32_t) (VAR_42 - VAR_40);
} else {
VAR_41 = 0;
}
if ((VAR_41 != 0) && (VAR_41 < VAR_45)) {     
int VAR_49, VAR_50, VAR_51 = -1;
for (VAR_49 = 1; VAR_49 < 4; VAR_49++) {
if (VAR_49 != VAR_47) {
if (VAR_51 == -1) {
VAR_51 = VAR_49;
} else {
VAR_50 = VAR_49;
}
}
}
memcpy(VAR_23, &VAR_21[VAR_51 * 4], 4);
memcpy(&VAR_23[4], &VAR_21[VAR_50 * 4], 4);
VAR_16 = XXH32(VAR_23, 8, 1);        
VAR_16 >>= 32U - 12U;
VAR_40 = VAR_32 + VAR_27[VAR_16];
VAR_43 = true;
if (VAR_27[VAR_16] != 0) {
VAR_24 = VAR_32 + VAR_27[VAR_16];
for (VAR_49 = 0; VAR_49 < 8; VAR_49++) {
if (VAR_23[VAR_49] != VAR_24[VAR_49]) {
VAR_43 = false;
break;
}
}
} else {
VAR_43 = false;
}
if (VAR_43) {
VAR_41 = (int32_t) (VAR_42 + VAR_51 * 4 - VAR_40);
} else {
VAR_41 = 0;
}
if ((VAR_41 != 0) && (VAR_41 < VAR_45)) {   
VAR_46 = false;
VAR_36 = (uint8_t) ((1U << 5U) | (VAR_47 << 3U));
*VAR_14++ = VAR_36;
uint16_t VAR_52 = (uint16_t) (VAR_42 - VAR_32 - VAR_27[VAR_16]);
*(uint16_t *) VAR_14 = VAR_48;
VAR_14 += sizeof(VAR_48);
*(uint16_t *) VAR_14 = VAR_52;
VAR_14 += sizeof(VAR_52);
goto match;
}
}
}
for (int VAR_30 = 0; VAR_30 < 2; VAR_30++) {
memcpy(VAR_22, &VAR_21[VAR_30 * 4], 4);
for (int VAR_47 = VAR_30 + 1; VAR_47 < 3; VAR_47++) {
memcpy(&VAR_22[4], &VAR_21[VAR_47 * 4], 4);
for (int VAR_49 = VAR_47 + 1; VAR_49 < 4; VAR_49++) {
memcpy(&VAR_22[8], &VAR_21[VAR_49 * 4], 4);
VAR_16 = XXH32(VAR_22, 12, 1);        
VAR_16 >>= 32U - 12U;
bool VAR_43 = true;
uint16_t VAR_48;
if (VAR_26[VAR_16] != 0) {
VAR_24 = VAR_32 + VAR_26[VAR_16];
for (int VAR_51 = 0; VAR_51 < 12; VAR_51++) {
if (VAR_22[VAR_51] != VAR_24[VAR_51]) {
VAR_43 = false;
break;
}
}
VAR_48 = (uint16_t) (VAR_42 - VAR_32 - VAR_26[VAR_16]);
} else {
VAR_43 = false;
if ((VAR_47 - VAR_30 == 1) && (VAR_49 - VAR_47 == 1)) {
VAR_28[VAR_30] = (uint32_t) (VAR_42 + 1 + VAR_30 * 4 - VAR_32);     
VAR_18[VAR_30] = VAR_16;
}
}
VAR_40 = VAR_32 + VAR_26[VAR_16];
if (VAR_43) {
VAR_41 = (int32_t) (VAR_42 + VAR_30 * 4 - VAR_40);
} else {
VAR_41 = 0;
}
if ((VAR_41 != 0) && (VAR_41 < VAR_45)) {
VAR_46 = false;
if (VAR_30 == 1) {
VAR_36 = (uint8_t) (7U << 5U);
} else {
VAR_36 = (uint8_t) ((7U << 5U) | ((VAR_47 + VAR_49 - 2) << 3U));
}
*VAR_14++ = VAR_36;
memcpy(VAR_14, &VAR_48, 2);
VAR_14 += 2;
for (int VAR_51 = 0; VAR_51 < 4; VAR_51++) {
if ((VAR_51 != VAR_30) && (VAR_51 != VAR_47) && (VAR_51 != VAR_49)) {
memcpy(VAR_14, &VAR_21[4 * VAR_51], 4);
VAR_14 += 4;
goto match;
}
}
}
}
}
}
for (int VAR_30 = 0; VAR_30 < 3; VAR_30++) {
memcpy(VAR_23, &VAR_21[VAR_30 * 4], 4);
for (int VAR_47 = VAR_30 + 1; VAR_47 < 4; VAR_47++) {
memcpy(&VAR_23[4], &VAR_21[VAR_47 * 4], 4);
VAR_16 = XXH32(VAR_23, 8, 1);        
VAR_16 >>= 32U - 12U;
VAR_40 = VAR_32 + VAR_27[VAR_16];
bool VAR_43 = true;
uint16_t VAR_48;
if (VAR_27[VAR_16] != 0) {
VAR_24 = VAR_32 + VAR_27[VAR_16];
for (int VAR_49 = 0; VAR_49 < 8; VAR_49++) {
if (VAR_23[VAR_49] != VAR_24[VAR_49]) {
VAR_43 = false;
break;
}
}
VAR_48 = (uint16_t) (VAR_42 - VAR_32 - VAR_27[VAR_16]);
} else {
VAR_43 = false;
if (VAR_47 - VAR_30 == 1) {
VAR_29[VAR_30] = (uint32_t) (VAR_42 + 1 + VAR_30 * 4 - VAR_32);     
VAR_19[VAR_30] = VAR_16;
}
}
if (VAR_43) {
VAR_41 = (int32_t) (VAR_42 + VAR_30 * 4 - VAR_40);
} else {
VAR_41 = 0;
}
if ((VAR_41 != 0) && (VAR_41 < VAR_45)) {     
VAR_46 = false;
if (VAR_30 == 2) {
VAR_36 = (uint8_t) (1U << 7U);
} else {
VAR_36 = (uint8_t) ((1U << 7U) | (VAR_30 << 5U) | (VAR_47 << 3U));
}
*VAR_14++ = VAR_36;
memcpy(VAR_14, &VAR_48, 2);
VAR_14 += 2;
for (int VAR_49 = 0; VAR_49 < 4; VAR_49++) {
if ((VAR_49 != VAR_30) && (VAR_49 != VAR_47)) {
memcpy(VAR_14, &VAR_21[4 * VAR_49], 4);
VAR_14 += 4;
}
}
goto match;
}
}
}
match:
if (VAR_46) {
VAR_25[VAR_17] = (uint32_t) (VAR_42 + 1 - VAR_32);     
if (VAR_28[0] != 0) {
for (int VAR_37 = 0; VAR_37 < 2; VAR_37++) {
VAR_26[VAR_18[VAR_37]] = VAR_28[VAR_37];
}
}
if (VAR_29[0] != 0) {
for (int VAR_37 = 0; VAR_37 < 3; VAR_37++) {
VAR_27[VAR_19[VAR_37]] = VAR_29[VAR_37];
}
}
VAR_36 = 0;
*VAR_14++ = VAR_36;
memcpy(VAR_14, VAR_21, 16);
VAR_14 += 16;
}
} else {   
VAR_36 = (uint8_t) ((1U << 7U) | (1U << 6U));
*VAR_14++ = VAR_36;
uint16_t VAR_48 = (uint16_t) (VAR_42 - VAR_32 - VAR_25[VAR_17]);
memcpy(VAR_14, &VAR_48, 2);
VAR_14 += 2;
}
}
if ((VAR_14 - VAR_32) > VAR_1) {
BLOSC_TRACE_ERROR(""Compressed data is bigger than input!"");
return 0;
}
}
}
free(VAR_10);
free(VAR_11);
free(VAR_12);
return (int) (VAR_14 - VAR_32);
}",Blosc/c-blosc2/d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3/ndlz4x4.c/vul/before/0.json,"int ndlz4_compress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,
                   uint8_t meta, blosc2_cparams *cparams) {
  BLOSC_UNUSED_PARAM(meta);
  BLOSC_ERROR_NULL(cparams, BLOSC2_ERROR_NULL_POINTER);
  BLOSC_ERROR_NULL(cparams->schunk, BLOSC2_ERROR_NULL_POINTER);
  uint8_t *smeta;
  int32_t smeta_len;

  if (blosc2_meta_get(cparams->schunk, ""b2nd"", &smeta, &smeta_len) < 0) {
    BLOSC_TRACE_ERROR(""b2nd layer not found!"");
    return BLOSC2_ERROR_FAILURE;
  }

  int8_t ndim;
  int64_t *shape = malloc(8 * sizeof(int64_t));
  int32_t *chunkshape = malloc(8 * sizeof(int32_t));
  int32_t *blockshape = malloc(8 * sizeof(int32_t));
  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);
  free(smeta);

  if (ndim != 2) {
    BLOSC_TRACE_ERROR(""This codec only works for ndim = 2"");
    return BLOSC2_ERROR_FAILURE;
  }

  if (input_len != (blockshape[0] * blockshape[1])) {
    BLOSC_TRACE_ERROR(""Length not equal to blocksize"");
    return BLOSC2_ERROR_FAILURE;
  }

  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < (int) (1 + ndim * sizeof(int32_t)))) {
    BLOSC_TRACE_ERROR(""Output too small"");
    return BLOSC2_ERROR_FAILURE;
  }

  uint8_t *ip = (uint8_t *) input;
  uint8_t *op = (uint8_t *) output;
  uint8_t *op_limit;
  uint32_t hval, hash_cell;
  uint32_t hash_triple[2] = {0};
  uint32_t hash_pair[3] = {0};
  uint8_t bufarea[16];
  uint8_t *buf_cell = bufarea;
  uint8_t buf_triple[12];
  uint8_t buf_pair[8];
  uint8_t *buf_aux;
  uint32_t tab_cell[1U << 12U] = {0};
  uint32_t tab_triple[1U << 12U] = {0};
  uint32_t tab_pair[1U << 12U] = {0};
  uint32_t update_triple[2] = {0};
  uint32_t update_pair[3] = {0};

  // Minimum cratios before issuing and _early giveup_
  // Remind that ndlz is not meant for cratios <= 2 (too costly to decompress)

  op_limit = op + output_len;

  // Initialize the hash table to distances of 0
  for (unsigned i = 0; i < (1U << 12U); i++) {
    tab_cell[i] = 0;
  }

  /* input and output buffer cannot be less than 16 and 66 bytes or we can get into trouble */
  int overhead = 17 + (blockshape[0] * blockshape[1] / 16 - 1) * 2;
  if (input_len < 16 || output_len < overhead) {
    BLOSC_TRACE_ERROR(""Incorrect length or maxout"");
    return 0;
  }

  uint8_t *obase = op;

  /* we start with literal copy */
  *op++ = ndim;
  memcpy(op, &blockshape[0], 4);
  op += 4;
  memcpy(op, &blockshape[1], 4);
  op += 4;

  uint32_t i_stop[2];
  for (int i = 0; i < 2; ++i) {
    i_stop[i] = (blockshape[i] + 3) / 4;
  }

  /* main loop */
  uint32_t padding[2];
  uint32_t ii[2];
  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {
    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell
      uint8_t token;
      for (int h = 0; h < 2; h++) {         // new cell -> new possible references
        update_triple[h] = 0;
        update_pair[h] = 0;
      }
      update_pair[2] = 0;

      if (NDLZ_UNEXPECT_CONDITIONAL(op + 16 + 1 > op_limit)) {
        free(shape);
        free(chunkshape);
        free(blockshape);
        return 0;
      }

      uint32_t orig = ii[0] * 4 * blockshape[1] + ii[1] * 4;
      if (((blockshape[0] % 4 != 0) && (ii[0] == i_stop[0] - 1)) ||
          ((blockshape[1] % 4 != 0) && (ii[1] == i_stop[1] - 1))) {
        token = 0;                                   // padding -> literal copy
        *op++ = token;
        if (ii[0] == i_stop[0] - 1) {
          padding[0] = (blockshape[0] % 4 == 0) ? 4 : blockshape[0] % 4;
        } else {
          padding[0] = 4;
        }
        if (ii[1] == i_stop[1] - 1) {
          padding[1] = (blockshape[1] % 4 == 0) ? 4 : blockshape[1] % 4;
        } else {
          padding[1] = 4;
        }
        for (uint32_t i = 0; i < padding[0]; i++) {
          memcpy(op, &ip[orig + i * blockshape[1]], padding[1]);
          op += padding[1];
        }
      } else {
        for (uint64_t i = 0; i < 4; i++) {           // fill cell buffer
          uint64_t ind = orig + i * blockshape[1];
          memcpy(buf_cell, &ip[ind], 4);
          buf_cell += 4;
        }
        buf_cell -= 16;

        const uint8_t *ref;
        uint32_t distance;
        uint8_t *anchor = op;    /* comparison starting-point */

        /* find potential match */
        hash_cell = XXH32(buf_cell, 16, 1);        // calculate cell hash
        hash_cell >>= 32U - 12U;
        ref = obase + tab_cell[hash_cell];

        /* calculate distance to the match */
        if (tab_cell[hash_cell] == 0) {
          distance = 0;
        } else {
          bool same = true;
          buf_aux = obase + tab_cell[hash_cell];
          for (int i = 0; i < 16; i++) {
            if (buf_cell[i] != buf_aux[i]) {
              same = false;
              break;
            }
          }
          if (same) {
            distance = (int32_t) (anchor - ref);
          } else {
            distance = 0;
          }
        }

        bool alleq = true;
        for (int i = 1; i < 16; i++) {
          if (buf_cell[i] != buf_cell[0]) {
            alleq = false;
            break;
          }
        }
        if (alleq) {                              // all elements of the cell equal
          token = (uint8_t) (1U << 6U);
          *op++ = token;
          *op++ = buf_cell[0];

        } else if (distance == 0 || (distance >= MAX_DISTANCE)) {   // no cell match
          bool literal = true;

          // 2 rows pairs matches
          for (int j = 1; j < 4; j++) {
            memcpy(buf_pair, buf_cell, 4);
            memcpy(&buf_pair[4], &buf_cell[j * 4], 4);
            hval = XXH32(buf_pair, 8, 1);        // calculate rows pair hash
            hval >>= 32U - 12U;
            ref = obase + tab_pair[hval];
            /* calculate distance to the match */
            bool same = true;
            uint16_t offset;
            if (tab_pair[hval] != 0) {
              buf_aux = obase + tab_pair[hval];
              for (int k = 0; k < 8; k++) {
                if (buf_pair[k] != buf_aux[k]) {
                  same = false;
                  break;
                }
              }
              offset = (uint16_t) (anchor - obase - tab_pair[hval]);
            } else {
              same = false;
            }
            if (same) {
              distance = (int32_t) (anchor - ref);
            } else {
              distance = 0;
            }
            if ((distance != 0) && (distance < MAX_DISTANCE)) {     /* rows pair match */
              int k, m, l = -1;
              for (k = 1; k < 4; k++) {
                if (k != j) {
                  if (l == -1) {
                    l = k;
                  } else {
                    m = k;
                  }
                }
              }
              memcpy(buf_pair, &buf_cell[l * 4], 4);
              memcpy(&buf_pair[4], &buf_cell[m * 4], 4);
              hval = XXH32(buf_pair, 8, 1);        // calculate rows pair hash
              hval >>= 32U - 12U;
              ref = obase + tab_pair[hval];
              same = true;
              if (tab_pair[hval] != 0) {
                buf_aux = obase + tab_pair[hval];
                for (k = 0; k < 8; k++) {
                  if (buf_pair[k] != buf_aux[k]) {
                    same = false;
                    break;
                  }
                }
              } else {
                same = false;
              }
              if (same) {
                distance = (int32_t) (anchor + l * 4 - ref);
              } else {
                distance = 0;
              }
              if ((distance != 0) && (distance < MAX_DISTANCE)) {   /* 2 pair matches */
                literal = false;
                token = (uint8_t) ((1U << 5U) | (j << 3U));
                *op++ = token;
                uint16_t offset_2 = (uint16_t) (anchor - obase - tab_pair[hval]);
                *(uint16_t *) op = offset;
                op += sizeof(offset);
                *(uint16_t *) op = offset_2;
                op += sizeof(offset_2);
                goto match;
              }
            }
          }

          // rows triples
          for (int i = 0; i < 2; i++) {
            memcpy(buf_triple, &buf_cell[i * 4], 4);
            for (int j = i + 1; j < 3; j++) {
              memcpy(&buf_triple[4], &buf_cell[j * 4], 4);
              for (int k = j + 1; k < 4; k++) {
                memcpy(&buf_triple[8], &buf_cell[k * 4], 4);
                hval = XXH32(buf_triple, 12, 1);        // calculate triple hash
                hval >>= 32U - 12U;
                /* calculate distance to the match */
                bool same = true;
                uint16_t offset;
                if (tab_triple[hval] != 0) {
                  buf_aux = obase + tab_triple[hval];
                  for (int l = 0; l < 12; l++) {
                    if (buf_triple[l] != buf_aux[l]) {
                      same = false;
                      break;
                    }
                  }
                  offset = (uint16_t) (anchor - obase - tab_triple[hval]);
                } else {
                  same = false;
                  if ((j - i == 1) && (k - j == 1)) {
                    update_triple[i] = (uint32_t) (anchor + 1 + i * 4 - obase);     /* update hash table */
                    hash_triple[i] = hval;
                  }
                }
                ref = obase + tab_triple[hval];

                if (same) {
                  distance = (int32_t) (anchor + i * 4 - ref);
                } else {
                  distance = 0;
                }
                if ((distance != 0) && (distance < MAX_DISTANCE)) {
                  literal = false;
                  if (i == 1) {
                    token = (uint8_t) (7U << 5U);
                  } else {
                    token = (uint8_t) ((7U << 5U) | ((j + k - 2) << 3U));
                  }
                  *op++ = token;
                  memcpy(op, &offset, 2);
                  op += 2;
                  for (int l = 0; l < 4; l++) {
                    if ((l != i) && (l != j) && (l != k)) {
                      memcpy(op, &buf_cell[4 * l], 4);
                      op += 4;
                      goto match;
                    }
                  }
                }
              }
            }
          }

          // rows pairs
          for (int i = 0; i < 3; i++) {
            memcpy(buf_pair, &buf_cell[i * 4], 4);
            for (int j = i + 1; j < 4; j++) {
              memcpy(&buf_pair[4], &buf_cell[j * 4], 4);
              hval = XXH32(buf_pair, 8, 1);        // calculate rows pair hash
              hval >>= 32U - 12U;
              ref = obase + tab_pair[hval];
              /* calculate distance to the match */
              bool same = true;
              uint16_t offset;
              if (tab_pair[hval] != 0) {
                buf_aux = obase + tab_pair[hval];
                for (int k = 0; k < 8; k++) {
                  if (buf_pair[k] != buf_aux[k]) {
                    same = false;
                    break;
                  }
                }
                offset = (uint16_t) (anchor - obase - tab_pair[hval]);
              } else {
                same = false;
                if (j - i == 1) {
                  update_pair[i] = (uint32_t) (anchor + 1 + i * 4 - obase);     /* update hash table */
                  hash_pair[i] = hval;
                }
              }
              if (same) {
                distance = (int32_t) (anchor + i * 4 - ref);
              } else {
                distance = 0;
              }
              if ((distance != 0) && (distance < MAX_DISTANCE)) {     /* rows pair match */
                literal = false;
                if (i == 2) {
                  token = (uint8_t) (1U << 7U);
                } else {
                  token = (uint8_t) ((1U << 7U) | (i << 5U) | (j << 3U));
                }
                *op++ = token;
                memcpy(op, &offset, 2);
                op += 2;
                for (int k = 0; k < 4; k++) {
                  if ((k != i) && (k != j)) {
                    memcpy(op, &buf_cell[4 * k], 4);
                    op += 4;
                  }
                }
                goto match;
              }
            }
          }

          match:
          if (literal) {
            tab_cell[hash_cell] = (uint32_t) (anchor + 1 - obase);     /* update hash tables */
            if (update_triple[0] != 0) {
              for (int h = 0; h < 2; h++) {
                tab_triple[hash_triple[h]] = update_triple[h];
              }
            }
            if (update_pair[0] != 0) {
              for (int h = 0; h < 3; h++) {
                tab_pair[hash_pair[h]] = update_pair[h];
              }
            }
            token = 0;
            *op++ = token;
            memcpy(op, buf_cell, 16);
            op += 16;
          }

        } else {   // cell match
          token = (uint8_t) ((1U << 7U) | (1U << 6U));
          *op++ = token;
          uint16_t offset = (uint16_t) (anchor - obase - tab_cell[hash_cell]);
          memcpy(op, &offset, 2);
          op += 2;
        }

      }
      if ((op - obase) > input_len) {
        BLOSC_TRACE_ERROR(""Compressed data is bigger than input!"");
        return 0;
      }
    }
  }

  free(shape);
  free(chunkshape);
  free(blockshape);

  return (int) (op - obase);
}","int ndlz4_compress(const uint8_t *VAR_0, int32_t VAR_1, uint8_t *VAR_2, int32_t VAR_3,
                   uint8_t VAR_4, blosc2_cparams *VAR_5) {
  BLOSC_UNUSED_PARAM(VAR_4);
  BLOSC_ERROR_NULL(VAR_5, VAR_6);
  BLOSC_ERROR_NULL(VAR_5->schunk, VAR_6);
  uint8_t *VAR_7;
  int32_t VAR_8;

  if (blosc2_meta_get(VAR_5->schunk, ""b2nd"", &VAR_7, &VAR_8) < 0) {
    BLOSC_TRACE_ERROR(""b2nd layer not found!"");
    return VAR_9;
  }

  int8_t VAR_10;
  int64_t *VAR_11 = malloc(8 * sizeof(int64_t));
  int32_t *VAR_12 = malloc(8 * sizeof(int32_t));
  int32_t *VAR_13 = malloc(8 * sizeof(int32_t));
  deserialize_meta(VAR_7, VAR_8, &VAR_10, VAR_11, VAR_12, VAR_13);
  free(VAR_7);

  if (VAR_10 != 2) {
    BLOSC_TRACE_ERROR(""This codec only works for ndim = 2"");
    return VAR_9;
  }

  if (VAR_1 != (VAR_13[0] * VAR_13[1])) {
    BLOSC_TRACE_ERROR(""Length not equal to blocksize"");
    return VAR_9;
  }

  if (NDLZ_UNEXPECT_CONDITIONAL(VAR_3 < (int) (1 + VAR_10 * sizeof(int32_t)))) {
    BLOSC_TRACE_ERROR(""Output too small"");
    return VAR_9;
  }

  uint8_t *VAR_14 = (uint8_t *) VAR_0;
  uint8_t *VAR_15 = (uint8_t *) VAR_2;
  uint8_t *VAR_16;
  uint32_t VAR_17, VAR_18;
  uint32_t VAR_19[2] = {0};
  uint32_t VAR_20[3] = {0};
  uint8_t VAR_21[16];
  uint8_t *VAR_22 = VAR_21;
  uint8_t VAR_23[12];
  uint8_t VAR_24[8];
  uint8_t *VAR_25;
  uint32_t VAR_26[1U << 12U] = {0};
  uint32_t VAR_27[1U << 12U] = {0};
  uint32_t VAR_28[1U << 12U] = {0};
  uint32_t VAR_29[2] = {0};
  uint32_t VAR_30[3] = {0};

  /* COMMENT_0 */
  /* COMMENT_1 */

  VAR_16 = VAR_15 + VAR_3;

  /* COMMENT_2 */
  for (unsigned VAR_31 = 0; VAR_31 < (1U << 12U); VAR_31++) {
    VAR_26[VAR_31] = 0;
  }

  /* COMMENT_3 */
  int VAR_32 = 17 + (VAR_13[0] * VAR_13[1] / 16 - 1) * 2;
  if (VAR_1 < 16 || VAR_3 < VAR_32) {
    BLOSC_TRACE_ERROR(""Incorrect length or maxout"");
    return 0;
  }

  uint8_t *VAR_33 = VAR_15;

  /* COMMENT_4 */
  *VAR_15++ = VAR_10;
  memcpy(VAR_15, &VAR_13[0], 4);
  VAR_15 += 4;
  memcpy(VAR_15, &VAR_13[1], 4);
  VAR_15 += 4;

  uint32_t VAR_34[2];
  for (int VAR_31 = 0; VAR_31 < 2; ++VAR_31) {
    VAR_34[VAR_31] = (VAR_13[VAR_31] + 3) / 4;
  }

  /* COMMENT_5 */
  uint32_t VAR_35[2];
  uint32_t VAR_36[2];
  for (VAR_36[0] = 0; VAR_36[0] < VAR_34[0]; ++VAR_36[0]) {
    for (VAR_36[1] = 0; VAR_36[1] < VAR_34[1]; ++VAR_36[1]) {      /* COMMENT_6 */
      uint8_t VAR_37;
      for (int VAR_38 = 0; VAR_38 < 2; VAR_38++) {         /* COMMENT_7 */
        VAR_29[VAR_38] = 0;
        VAR_30[VAR_38] = 0;
      }
      VAR_30[2] = 0;

      if (NDLZ_UNEXPECT_CONDITIONAL(VAR_15 + 16 + 1 > VAR_16)) {
        free(VAR_11);
        free(VAR_12);
        free(VAR_13);
        return 0;
      }

      uint32_t VAR_39 = VAR_36[0] * 4 * VAR_13[1] + VAR_36[1] * 4;
      if (((VAR_13[0] % 4 != 0) && (VAR_36[0] == VAR_34[0] - 1)) ||
          ((VAR_13[1] % 4 != 0) && (VAR_36[1] == VAR_34[1] - 1))) {
        VAR_37 = 0;                                   /* COMMENT_8 */
        *VAR_15++ = VAR_37;
        if (VAR_36[0] == VAR_34[0] - 1) {
          VAR_35[0] = (VAR_13[0] % 4 == 0) ? 4 : VAR_13[0] % 4;
        } else {
          VAR_35[0] = 4;
        }
        if (VAR_36[1] == VAR_34[1] - 1) {
          VAR_35[1] = (VAR_13[1] % 4 == 0) ? 4 : VAR_13[1] % 4;
        } else {
          VAR_35[1] = 4;
        }
        for (uint32_t VAR_31 = 0; VAR_31 < VAR_35[0]; VAR_31++) {
          memcpy(VAR_15, &VAR_14[VAR_39 + VAR_31 * VAR_13[1]], VAR_35[1]);
          VAR_15 += VAR_35[1];
        }
      } else {
        for (uint64_t VAR_31 = 0; VAR_31 < 4; VAR_31++) {           /* COMMENT_9 */
          uint64_t VAR_40 = VAR_39 + VAR_31 * VAR_13[1];
          memcpy(VAR_22, &VAR_14[VAR_40], 4);
          VAR_22 += 4;
        }
        VAR_22 -= 16;

        const uint8_t *VAR_41;
        uint32_t VAR_42;
        uint8_t *VAR_43 = VAR_15;    /* COMMENT_10 */

        /* COMMENT_11 */
        VAR_18 = XXH32(VAR_22, 16, 1);        /* COMMENT_12 */
        VAR_18 >>= 32U - 12U;
        VAR_41 = VAR_33 + VAR_26[VAR_18];

        /* COMMENT_13 */
        if (VAR_26[VAR_18] == 0) {
          VAR_42 = 0;
        } else {
          bool VAR_44 = true;
          VAR_25 = VAR_33 + VAR_26[VAR_18];
          for (int VAR_31 = 0; VAR_31 < 16; VAR_31++) {
            if (VAR_22[VAR_31] != VAR_25[VAR_31]) {
              VAR_44 = false;
              break;
            }
          }
          if (VAR_44) {
            VAR_42 = (int32_t) (VAR_43 - VAR_41);
          } else {
            VAR_42 = 0;
          }
        }

        bool VAR_45 = true;
        for (int VAR_31 = 1; VAR_31 < 16; VAR_31++) {
          if (VAR_22[VAR_31] != VAR_22[0]) {
            VAR_45 = false;
            break;
          }
        }
        if (VAR_45) {                              /* COMMENT_14 */
          VAR_37 = (uint8_t) (1U << 6U);
          *VAR_15++ = VAR_37;
          *VAR_15++ = VAR_22[0];

        } else if (VAR_42 == 0 || (VAR_42 >= VAR_46)) {   /* COMMENT_15 */
          bool VAR_47 = true;

          /* COMMENT_16 */
          for (int VAR_48 = 1; VAR_48 < 4; VAR_48++) {
            memcpy(VAR_24, VAR_22, 4);
            memcpy(&VAR_24[4], &VAR_22[VAR_48 * 4], 4);
            VAR_17 = XXH32(VAR_24, 8, 1);        /* COMMENT_17 */
            VAR_17 >>= 32U - 12U;
            VAR_41 = VAR_33 + VAR_28[VAR_17];
            /* COMMENT_13 */
            bool VAR_44 = true;
            uint16_t VAR_49;
            if (VAR_28[VAR_17] != 0) {
              VAR_25 = VAR_33 + VAR_28[VAR_17];
              for (int VAR_50 = 0; VAR_50 < 8; VAR_50++) {
                if (VAR_24[VAR_50] != VAR_25[VAR_50]) {
                  VAR_44 = false;
                  break;
                }
              }
              VAR_49 = (uint16_t) (VAR_43 - VAR_33 - VAR_28[VAR_17]);
            } else {
              VAR_44 = false;
            }
            if (VAR_44) {
              VAR_42 = (int32_t) (VAR_43 - VAR_41);
            } else {
              VAR_42 = 0;
            }
            if ((VAR_42 != 0) && (VAR_42 < VAR_46)) {     /* COMMENT_18 */
              int VAR_50, VAR_51, VAR_52 = -1;
              for (VAR_50 = 1; VAR_50 < 4; VAR_50++) {
                if (VAR_50 != VAR_48) {
                  if (VAR_52 == -1) {
                    VAR_52 = VAR_50;
                  } else {
                    VAR_51 = VAR_50;
                  }
                }
              }
              memcpy(VAR_24, &VAR_22[VAR_52 * 4], 4);
              memcpy(&VAR_24[4], &VAR_22[VAR_51 * 4], 4);
              VAR_17 = XXH32(VAR_24, 8, 1);        /* COMMENT_17 */
              VAR_17 >>= 32U - 12U;
              VAR_41 = VAR_33 + VAR_28[VAR_17];
              VAR_44 = true;
              if (VAR_28[VAR_17] != 0) {
                VAR_25 = VAR_33 + VAR_28[VAR_17];
                for (VAR_50 = 0; VAR_50 < 8; VAR_50++) {
                  if (VAR_24[VAR_50] != VAR_25[VAR_50]) {
                    VAR_44 = false;
                    break;
                  }
                }
              } else {
                VAR_44 = false;
              }
              if (VAR_44) {
                VAR_42 = (int32_t) (VAR_43 + VAR_52 * 4 - VAR_41);
              } else {
                VAR_42 = 0;
              }
              if ((VAR_42 != 0) && (VAR_42 < VAR_46)) {   /* COMMENT_19 */
                VAR_47 = false;
                VAR_37 = (uint8_t) ((1U << 5U) | (VAR_48 << 3U));
                *VAR_15++ = VAR_37;
                uint16_t VAR_53 = (uint16_t) (VAR_43 - VAR_33 - VAR_28[VAR_17]);
                *(uint16_t *) VAR_15 = VAR_49;
                VAR_15 += sizeof(VAR_49);
                *(uint16_t *) VAR_15 = VAR_53;
                VAR_15 += sizeof(VAR_53);
                goto match;
              }
            }
          }

          /* COMMENT_20 */
          for (int VAR_31 = 0; VAR_31 < 2; VAR_31++) {
            memcpy(VAR_23, &VAR_22[VAR_31 * 4], 4);
            for (int VAR_48 = VAR_31 + 1; VAR_48 < 3; VAR_48++) {
              memcpy(&VAR_23[4], &VAR_22[VAR_48 * 4], 4);
              for (int VAR_50 = VAR_48 + 1; VAR_50 < 4; VAR_50++) {
                memcpy(&VAR_23[8], &VAR_22[VAR_50 * 4], 4);
                VAR_17 = XXH32(VAR_23, 12, 1);        /* COMMENT_21 */
                VAR_17 >>= 32U - 12U;
                /* COMMENT_13 */
                bool VAR_44 = true;
                uint16_t VAR_49;
                if (VAR_27[VAR_17] != 0) {
                  VAR_25 = VAR_33 + VAR_27[VAR_17];
                  for (int VAR_52 = 0; VAR_52 < 12; VAR_52++) {
                    if (VAR_23[VAR_52] != VAR_25[VAR_52]) {
                      VAR_44 = false;
                      break;
                    }
                  }
                  VAR_49 = (uint16_t) (VAR_43 - VAR_33 - VAR_27[VAR_17]);
                } else {
                  VAR_44 = false;
                  if ((VAR_48 - VAR_31 == 1) && (VAR_50 - VAR_48 == 1)) {
                    VAR_29[VAR_31] = (uint32_t) (VAR_43 + 1 + VAR_31 * 4 - VAR_33);     /* COMMENT_22 */
                    VAR_19[VAR_31] = VAR_17;
                  }
                }
                VAR_41 = VAR_33 + VAR_27[VAR_17];

                if (VAR_44) {
                  VAR_42 = (int32_t) (VAR_43 + VAR_31 * 4 - VAR_41);
                } else {
                  VAR_42 = 0;
                }
                if ((VAR_42 != 0) && (VAR_42 < VAR_46)) {
                  VAR_47 = false;
                  if (VAR_31 == 1) {
                    VAR_37 = (uint8_t) (7U << 5U);
                  } else {
                    VAR_37 = (uint8_t) ((7U << 5U) | ((VAR_48 + VAR_50 - 2) << 3U));
                  }
                  *VAR_15++ = VAR_37;
                  memcpy(VAR_15, &VAR_49, 2);
                  VAR_15 += 2;
                  for (int VAR_52 = 0; VAR_52 < 4; VAR_52++) {
                    if ((VAR_52 != VAR_31) && (VAR_52 != VAR_48) && (VAR_52 != VAR_50)) {
                      memcpy(VAR_15, &VAR_22[4 * VAR_52], 4);
                      VAR_15 += 4;
                      goto match;
                    }
                  }
                }
              }
            }
          }

          /* COMMENT_23 */
          for (int VAR_31 = 0; VAR_31 < 3; VAR_31++) {
            memcpy(VAR_24, &VAR_22[VAR_31 * 4], 4);
            for (int VAR_48 = VAR_31 + 1; VAR_48 < 4; VAR_48++) {
              memcpy(&VAR_24[4], &VAR_22[VAR_48 * 4], 4);
              VAR_17 = XXH32(VAR_24, 8, 1);        /* COMMENT_17 */
              VAR_17 >>= 32U - 12U;
              VAR_41 = VAR_33 + VAR_28[VAR_17];
              /* COMMENT_13 */
              bool VAR_44 = true;
              uint16_t VAR_49;
              if (VAR_28[VAR_17] != 0) {
                VAR_25 = VAR_33 + VAR_28[VAR_17];
                for (int VAR_50 = 0; VAR_50 < 8; VAR_50++) {
                  if (VAR_24[VAR_50] != VAR_25[VAR_50]) {
                    VAR_44 = false;
                    break;
                  }
                }
                VAR_49 = (uint16_t) (VAR_43 - VAR_33 - VAR_28[VAR_17]);
              } else {
                VAR_44 = false;
                if (VAR_48 - VAR_31 == 1) {
                  VAR_30[VAR_31] = (uint32_t) (VAR_43 + 1 + VAR_31 * 4 - VAR_33);     /* COMMENT_22 */
                  VAR_20[VAR_31] = VAR_17;
                }
              }
              if (VAR_44) {
                VAR_42 = (int32_t) (VAR_43 + VAR_31 * 4 - VAR_41);
              } else {
                VAR_42 = 0;
              }
              if ((VAR_42 != 0) && (VAR_42 < VAR_46)) {     /* COMMENT_18 */
                VAR_47 = false;
                if (VAR_31 == 2) {
                  VAR_37 = (uint8_t) (1U << 7U);
                } else {
                  VAR_37 = (uint8_t) ((1U << 7U) | (VAR_31 << 5U) | (VAR_48 << 3U));
                }
                *VAR_15++ = VAR_37;
                memcpy(VAR_15, &VAR_49, 2);
                VAR_15 += 2;
                for (int VAR_50 = 0; VAR_50 < 4; VAR_50++) {
                  if ((VAR_50 != VAR_31) && (VAR_50 != VAR_48)) {
                    memcpy(VAR_15, &VAR_22[4 * VAR_50], 4);
                    VAR_15 += 4;
                  }
                }
                goto match;
              }
            }
          }

          match:
          if (VAR_47) {
            VAR_26[VAR_18] = (uint32_t) (VAR_43 + 1 - VAR_33);     /* COMMENT_24 */
            if (VAR_29[0] != 0) {
              for (int VAR_38 = 0; VAR_38 < 2; VAR_38++) {
                VAR_27[VAR_19[VAR_38]] = VAR_29[VAR_38];
              }
            }
            if (VAR_30[0] != 0) {
              for (int VAR_38 = 0; VAR_38 < 3; VAR_38++) {
                VAR_28[VAR_20[VAR_38]] = VAR_30[VAR_38];
              }
            }
            VAR_37 = 0;
            *VAR_15++ = VAR_37;
            memcpy(VAR_15, VAR_22, 16);
            VAR_15 += 16;
          }

        } else {   /* COMMENT_25 */
          VAR_37 = (uint8_t) ((1U << 7U) | (1U << 6U));
          *VAR_15++ = VAR_37;
          uint16_t VAR_49 = (uint16_t) (VAR_43 - VAR_33 - VAR_26[VAR_18]);
          memcpy(VAR_15, &VAR_49, 2);
          VAR_15 += 2;
        }

      }
      if ((VAR_15 - VAR_33) > VAR_1) {
        BLOSC_TRACE_ERROR(""Compressed data is bigger than input!"");
        return 0;
      }
    }
  }

  free(VAR_11);
  free(VAR_12);
  free(VAR_13);

  return (int) (VAR_15 - VAR_33);
}",Blosc/c-blosc2/d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3/ndlz4x4.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,8 @@
 int ndlz4_compress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,
                    uint8_t meta, blosc2_cparams *cparams) {
   BLOSC_UNUSED_PARAM(meta);
+  BLOSC_ERROR_NULL(cparams, BLOSC2_ERROR_NULL_POINTER);
+  BLOSC_ERROR_NULL(cparams->schunk, BLOSC2_ERROR_NULL_POINTER);
   uint8_t *smeta;
   int32_t smeta_len;
 ","{'deleted_lines': [], 'added_lines': ['  BLOSC_ERROR_NULL(cparams, BLOSC2_ERROR_NULL_POINTER);', '  BLOSC_ERROR_NULL(cparams->schunk, BLOSC2_ERROR_NULL_POINTER);']}",True,C-blosc2 before 2.9.3 was discovered to contain a NULL pointer dereference in ndlz/ndlz8x8.c via a NULL pointer to memset.,7.5,HIGH,2,test,2023-06-21T09:17:51Z,4
CVE-2023-37186,['CWE-476'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Blosc/c-blosc2,Fix #522,d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3,https://github.com/Blosc/c-blosc2/commit/d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3,plugins/codecs/ndlz/ndlz4x4.c,ndlz4_decompress,"int ndlz4_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,
uint8_t meta, blosc2_dparams *dparams) {
BLOSC_UNUSED_PARAM(meta);
BLOSC_UNUSED_PARAM(dparams);
uint8_t *ip = (uint8_t *) input;
uint8_t *ip_limit = ip + input_len;
uint8_t *op = (uint8_t *) output;
uint8_t ndim;
uint32_t blockshape[2];
uint32_t eshape[2];
uint8_t *buffercpy;
uint8_t local_buffer[16];
uint8_t token;
if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {
return 0;
}
ndim = *ip;
ip++;
if (ndim != 2) {
BLOSC_TRACE_ERROR(""This codec only works for ndim = 2"");
return BLOSC2_ERROR_FAILURE;
}
memcpy(&blockshape[0], ip, 4);
ip += 4;
memcpy(&blockshape[1], ip, 4);
ip += 4;
eshape[0] = ((blockshape[0] + 3) / 4) * 4;
eshape[1] = ((blockshape[1] + 3) / 4) * 4;
if (NDLZ_UNEXPECT_CONDITIONAL(output_len < (int32_t) (blockshape[0] * blockshape[1]))) {
return 0;
}
memset(op, 0, blockshape[0] * blockshape[1]);
uint32_t i_stop[2];
for (int i = 0; i < 2; ++i) {
i_stop[i] = eshape[i] / 4;
}
uint32_t ii[2];
uint32_t padding[2] = {0};
uint32_t ind = 0;
uint8_t cell_aux[16];
for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {
for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {            if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {
BLOSC_TRACE_ERROR(""Exceeding input length"");
return BLOSC2_ERROR_FAILURE;
}
if (ii[0] == i_stop[0] - 1) {
padding[0] = (blockshape[0] % 4 == 0) ? 4 : blockshape[0] % 4;
} else {
padding[0] = 4;
}
if (ii[1] == i_stop[1] - 1) {
padding[1] = (blockshape[1] % 4 == 0) ? 4 : blockshape[1] % 4;
} else {
padding[1] = 4;
}
token = *ip++;
if (token == 0) {            buffercpy = ip;
ip += padding[0] * padding[1];
} else if (token == (uint8_t) ((1U << 7U) | (1U << 6U))) {          uint16_t offset = *((uint16_t *) ip);
buffercpy = ip - offset - 1;
ip += 2;
} else if (token == (uint8_t) (1U << 6U)) {         buffercpy = cell_aux;
memset(buffercpy, *ip, 16);
ip++;
} else if (token >= 224) {         buffercpy = local_buffer;
uint16_t offset = *((uint16_t *) ip);
offset += 3;
ip += 2;
int i, j, k;
if ((token >> 3U) == 28) {
i = 1;
j = 2;
k = 3;
} else {
i = 0;
if ((token >> 3U) < 30) {
j = 1;
k = 2;
} else {
k = 3;
if ((token >> 3U) == 30) {
j = 1;
} else {
j = 2;
}
}
}
memcpy(&buffercpy[i * 4], ip - offset, 4);
memcpy(&buffercpy[j * 4], ip - offset + 4, 4);
memcpy(&buffercpy[k * 4], ip - offset + 8, 4);
for (int l = 0; l < 4; l++) {
if ((l != i) && (l != j) && (l != k)) {
memcpy(&buffercpy[l * 4], ip, 4);
ip += 4;
break;
}
}
} else if ((token >= 128) && (token <= 191)) {         buffercpy = local_buffer;
uint16_t offset = *((uint16_t *) ip);
offset += 3;
ip += 2;
int i, j;
if (token == 128) {
i = 2;
j = 3;
} else {
i = (token - 128) >> 5U;
j = ((token - 128) >> 3U) - (i << 2U);
}
memcpy(&buffercpy[i * 4], ip - offset, 4);
memcpy(&buffercpy[j * 4], ip - offset + 4, 4);
for (int k = 0; k < 4; k++) {
if ((k != i) && (k != j)) {
memcpy(&buffercpy[k * 4], ip, 4);
ip += 4;
}
}
} else if ((token >= 40) && (token <= 63)) {          buffercpy = local_buffer;
uint16_t offset_1 = *((uint16_t *) ip);
offset_1 += 5;
ip += 2;
uint16_t offset_2 = *((uint16_t *) ip);
offset_2 += 5;
ip += 2;
int i, j, k, l, m;
i = 0;
j = ((token - 32) >> 3U);
l = -1;
for (k = 1; k < 4; k++) {
if ((k != i) && (k != j)) {
if (l == -1) {
l = k;
} else {
m = k;
}
}
}
memcpy(&buffercpy[i * 4], ip - offset_1, 4);
memcpy(&buffercpy[j * 4], ip - offset_1 + 4, 4);
memcpy(&buffercpy[l * 4], ip - offset_2, 4);
memcpy(&buffercpy[m * 4], ip - offset_2 + 4, 4);
} else {
BLOSC_TRACE_ERROR(""Invalid token: %u at cell [%d, %d]\n"", token, ii[0], ii[1]);
return BLOSC2_ERROR_FAILURE;
}
uint32_t orig = ii[0] * 4 * blockshape[1] + ii[1] * 4;
for (uint32_t i = 0; i < 4; i++) {
if (i < padding[0]) {
ind = orig + i * blockshape[1];
memcpy(&op[ind], buffercpy, padding[1]);
}
buffercpy += padding[1];
}
if (ind > (uint32_t) output_len) {
BLOSC_TRACE_ERROR(""Exceeding output size"");
return BLOSC2_ERROR_FAILURE;
}
}
}
ind += padding[1];
if (ind != (blockshape[0] * blockshape[1])) {
BLOSC_TRACE_ERROR(""Output size is not compatible with embedded blockshape"");
return BLOSC2_ERROR_FAILURE;
}
if (ind > (uint32_t) output_len) {
BLOSC_TRACE_ERROR(""Exceeding output size"");
return BLOSC2_ERROR_FAILURE;
}
return (int) ind;
}","int ndlz4_decompress(const uint8_t *VAR_0, int32_t VAR_1, uint8_t *VAR_2, int32_t VAR_3,
uint8_t VAR_4, blosc2_dparams *VAR_5) {
BLOSC_UNUSED_PARAM(VAR_4);
BLOSC_UNUSED_PARAM(VAR_5);
uint8_t *VAR_6 = (uint8_t *) VAR_0;
uint8_t *VAR_7 = VAR_6 + VAR_1;
uint8_t *VAR_8 = (uint8_t *) VAR_2;
uint8_t VAR_9;
uint32_t VAR_10[2];
uint32_t VAR_11[2];
uint8_t *VAR_12;
uint8_t VAR_13[16];
uint8_t VAR_14;
if (NDLZ_UNEXPECT_CONDITIONAL(VAR_1 < 8)) {
return 0;
}
VAR_9 = *VAR_6;
VAR_6++;
if (VAR_9 != 2) {
BLOSC_TRACE_ERROR(""This codec only works for ndim = 2"");
return VAR_15;
}
memcpy(&VAR_10[0], VAR_6, 4);
VAR_6 += 4;
memcpy(&VAR_10[1], VAR_6, 4);
VAR_6 += 4;
VAR_11[0] = ((VAR_10[0] + 3) / 4) * 4;
VAR_11[1] = ((VAR_10[1] + 3) / 4) * 4;
if (NDLZ_UNEXPECT_CONDITIONAL(VAR_3 < (int32_t) (VAR_10[0] * VAR_10[1]))) {
return 0;
}
memset(VAR_8, 0, VAR_10[0] * VAR_10[1]);
uint32_t VAR_16[2];
for (int VAR_17 = 0; VAR_17 < 2; ++VAR_17) {
VAR_16[VAR_17] = VAR_11[VAR_17] / 4;
}
uint32_t VAR_18[2];
uint32_t VAR_19[2] = {0};
uint32_t VAR_20 = 0;
uint8_t VAR_21[16];
for (VAR_18[0] = 0; VAR_18[0] < VAR_16[0]; ++VAR_18[0]) {
for (VAR_18[1] = 0; VAR_18[1] < VAR_16[1]; ++VAR_18[1]) {      
if (NDLZ_UNEXPECT_CONDITIONAL(VAR_6 > VAR_7)) {
BLOSC_TRACE_ERROR(""Exceeding input length"");
return VAR_15;
}
if (VAR_18[0] == VAR_16[0] - 1) {
VAR_19[0] = (VAR_10[0] % 4 == 0) ? 4 : VAR_10[0] % 4;
} else {
VAR_19[0] = 4;
}
if (VAR_18[1] == VAR_16[1] - 1) {
VAR_19[1] = (VAR_10[1] % 4 == 0) ? 4 : VAR_10[1] % 4;
} else {
VAR_19[1] = 4;
}
VAR_14 = *VAR_6++;
if (VAR_14 == 0) {    
VAR_12 = VAR_6;
VAR_6 += VAR_19[0] * VAR_19[1];
} else if (VAR_14 == (uint8_t) ((1U << 7U) | (1U << 6U))) {  
uint16_t VAR_22 = *((uint16_t *) VAR_6);
VAR_12 = VAR_6 - VAR_22 - 1;
VAR_6 += 2;
} else if (VAR_14 == (uint8_t) (1U << 6U)) { 
VAR_12 = VAR_21;
memset(VAR_12, *VAR_6, 16);
VAR_6++;
} else if (VAR_14 >= 224) { 
VAR_12 = VAR_13;
uint16_t VAR_22 = *((uint16_t *) VAR_6);
VAR_22 += 3;
VAR_6 += 2;
int VAR_17, VAR_23, VAR_24;
if ((VAR_14 >> 3U) == 28) {
VAR_17 = 1;
VAR_23 = 2;
VAR_24 = 3;
} else {
VAR_17 = 0;
if ((VAR_14 >> 3U) < 30) {
VAR_23 = 1;
VAR_24 = 2;
} else {
VAR_24 = 3;
if ((VAR_14 >> 3U) == 30) {
VAR_23 = 1;
} else {
VAR_23 = 2;
}
}
}
memcpy(&VAR_12[VAR_17 * 4], VAR_6 - VAR_22, 4);
memcpy(&VAR_12[VAR_23 * 4], VAR_6 - VAR_22 + 4, 4);
memcpy(&VAR_12[VAR_24 * 4], VAR_6 - VAR_22 + 8, 4);
for (int VAR_25 = 0; VAR_25 < 4; VAR_25++) {
if ((VAR_25 != VAR_17) && (VAR_25 != VAR_23) && (VAR_25 != VAR_24)) {
memcpy(&VAR_12[VAR_25 * 4], VAR_6, 4);
VAR_6 += 4;
break;
}
}
} else if ((VAR_14 >= 128) && (VAR_14 <= 191)) { 
VAR_12 = VAR_13;
uint16_t VAR_22 = *((uint16_t *) VAR_6);
VAR_22 += 3;
VAR_6 += 2;
int VAR_17, VAR_23;
if (VAR_14 == 128) {
VAR_17 = 2;
VAR_23 = 3;
} else {
VAR_17 = (VAR_14 - 128) >> 5U;
VAR_23 = ((VAR_14 - 128) >> 3U) - (VAR_17 << 2U);
}
memcpy(&VAR_12[VAR_17 * 4], VAR_6 - VAR_22, 4);
memcpy(&VAR_12[VAR_23 * 4], VAR_6 - VAR_22 + 4, 4);
for (int VAR_24 = 0; VAR_24 < 4; VAR_24++) {
if ((VAR_24 != VAR_17) && (VAR_24 != VAR_23)) {
memcpy(&VAR_12[VAR_24 * 4], VAR_6, 4);
VAR_6 += 4;
}
}
} else if ((VAR_14 >= 40) && (VAR_14 <= 63)) {  
VAR_12 = VAR_13;
uint16_t VAR_26 = *((uint16_t *) VAR_6);
VAR_26 += 5;
VAR_6 += 2;
uint16_t VAR_27 = *((uint16_t *) VAR_6);
VAR_27 += 5;
VAR_6 += 2;
int VAR_17, VAR_23, VAR_24, VAR_25, VAR_28;
VAR_17 = 0;
VAR_23 = ((VAR_14 - 32) >> 3U);
VAR_25 = -1;
for (VAR_24 = 1; VAR_24 < 4; VAR_24++) {
if ((VAR_24 != VAR_17) && (VAR_24 != VAR_23)) {
if (VAR_25 == -1) {
VAR_25 = VAR_24;
} else {
VAR_28 = VAR_24;
}
}
}
memcpy(&VAR_12[VAR_17 * 4], VAR_6 - VAR_26, 4);
memcpy(&VAR_12[VAR_23 * 4], VAR_6 - VAR_26 + 4, 4);
memcpy(&VAR_12[VAR_25 * 4], VAR_6 - VAR_27, 4);
memcpy(&VAR_12[VAR_28 * 4], VAR_6 - VAR_27 + 4, 4);
} else {
BLOSC_TRACE_ERROR(""Invalid token: %u at cell [%d, %d]\n"", VAR_14, VAR_18[0], VAR_18[1]);
return VAR_15;
}
uint32_t VAR_29 = VAR_18[0] * 4 * VAR_10[1] + VAR_18[1] * 4;
for (uint32_t VAR_17 = 0; VAR_17 < 4; VAR_17++) {
if (VAR_17 < VAR_19[0]) {
VAR_20 = VAR_29 + VAR_17 * VAR_10[1];
memcpy(&VAR_8[VAR_20], VAR_12, VAR_19[1]);
}
VAR_12 += VAR_19[1];
}
if (VAR_20 > (uint32_t) VAR_3) {
BLOSC_TRACE_ERROR(""Exceeding output size"");
return VAR_15;
}
}
}
VAR_20 += VAR_19[1];
if (VAR_20 != (VAR_10[0] * VAR_10[1])) {
BLOSC_TRACE_ERROR(""Output size is not compatible with embedded blockshape"");
return VAR_15;
}
if (VAR_20 > (uint32_t) VAR_3) {
BLOSC_TRACE_ERROR(""Exceeding output size"");
return VAR_15;
}
return (int) VAR_20;
}",Blosc/c-blosc2/d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3/ndlz4x4.c/vul/before/1.json,"int ndlz4_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,
                     uint8_t meta, blosc2_dparams *dparams) {
  BLOSC_UNUSED_PARAM(meta);
  BLOSC_UNUSED_PARAM(dparams);
  BLOSC_ERROR_NULL(input, BLOSC2_ERROR_NULL_POINTER);
  BLOSC_ERROR_NULL(output, BLOSC2_ERROR_NULL_POINTER);

  uint8_t *ip = (uint8_t *) input;
  uint8_t *ip_limit = ip + input_len;
  uint8_t *op = (uint8_t *) output;
  uint8_t ndim;
  uint32_t blockshape[2];
  uint32_t eshape[2];
  uint8_t *buffercpy;
  uint8_t local_buffer[16];
  uint8_t token;
  if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {
    return 0;
  }

  /* we start with literal copy */
  ndim = *ip;
  ip++;
  if (ndim != 2) {
    BLOSC_TRACE_ERROR(""This codec only works for ndim = 2"");
    return BLOSC2_ERROR_FAILURE;
  }
  memcpy(&blockshape[0], ip, 4);
  ip += 4;
  memcpy(&blockshape[1], ip, 4);
  ip += 4;
  eshape[0] = ((blockshape[0] + 3) / 4) * 4;
  eshape[1] = ((blockshape[1] + 3) / 4) * 4;

  if (NDLZ_UNEXPECT_CONDITIONAL((int64_t)output_len < (int64_t)blockshape[0] * (int64_t)blockshape[1])) {
    return 0;
  }
  memset(op, 0, blockshape[0] * blockshape[1]);

  uint32_t i_stop[2];
  for (int i = 0; i < 2; ++i) {
    i_stop[i] = eshape[i] / 4;
  }

  /* main loop */
  uint32_t ii[2];
  uint32_t padding[2] = {0};
  uint32_t ind = 0;
  uint8_t cell_aux[16];
  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {
    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell
      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {
        BLOSC_TRACE_ERROR(""Exceeding input length"");
        return BLOSC2_ERROR_FAILURE;
      }
      if (ii[0] == i_stop[0] - 1) {
        padding[0] = (blockshape[0] % 4 == 0) ? 4 : blockshape[0] % 4;
      } else {
        padding[0] = 4;
      }
      if (ii[1] == i_stop[1] - 1) {
        padding[1] = (blockshape[1] % 4 == 0) ? 4 : blockshape[1] % 4;
      } else {
        padding[1] = 4;
      }
      token = *ip++;
      if (token == 0) {    // no match
        buffercpy = ip;
        ip += padding[0] * padding[1];
      } else if (token == (uint8_t) ((1U << 7U) | (1U << 6U))) {  // cell match
        uint16_t offset = *((uint16_t *) ip);
        buffercpy = ip - offset - 1;
        ip += 2;
      } else if (token == (uint8_t) (1U << 6U)) { // whole cell of same element
        buffercpy = cell_aux;
        memset(buffercpy, *ip, 16);
        ip++;
      } else if (token >= 224) { // three rows match
        buffercpy = local_buffer;
        uint16_t offset = *((uint16_t *) ip);
        offset += 3;
        ip += 2;
        int i, j, k;
        if ((token >> 3U) == 28) {
          i = 1;
          j = 2;
          k = 3;
        } else {
          i = 0;
          if ((token >> 3U) < 30) {
            j = 1;
            k = 2;
          } else {
            k = 3;
            if ((token >> 3U) == 30) {
              j = 1;
            } else {
              j = 2;
            }
          }
        }
        memcpy(&buffercpy[i * 4], ip - offset, 4);
        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);
        memcpy(&buffercpy[k * 4], ip - offset + 8, 4);
        for (int l = 0; l < 4; l++) {
          if ((l != i) && (l != j) && (l != k)) {
            memcpy(&buffercpy[l * 4], ip, 4);
            ip += 4;
            break;
          }
        }

      } else if ((token >= 128) && (token <= 191)) { // rows pair match
        buffercpy = local_buffer;
        uint16_t offset = *((uint16_t *) ip);
        offset += 3;
        ip += 2;
        int i, j;
        if (token == 128) {
          i = 2;
          j = 3;
        } else {
          i = (token - 128) >> 5U;
          j = ((token - 128) >> 3U) - (i << 2U);
        }
        memcpy(&buffercpy[i * 4], ip - offset, 4);
        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);
        for (int k = 0; k < 4; k++) {
          if ((k != i) && (k != j)) {
            memcpy(&buffercpy[k * 4], ip, 4);
            ip += 4;
          }
        }
      } else if ((token >= 40) && (token <= 63)) {  // 2 rows pair matches
        buffercpy = local_buffer;
        uint16_t offset_1 = *((uint16_t *) ip);
        offset_1 += 5;
        ip += 2;
        uint16_t offset_2 = *((uint16_t *) ip);
        offset_2 += 5;
        ip += 2;
        int i, j, k, l, m;
        i = 0;
        j = ((token - 32) >> 3U);
        l = -1;
        for (k = 1; k < 4; k++) {
          if ((k != i) && (k != j)) {
            if (l == -1) {
              l = k;
            } else {
              m = k;
            }
          }
        }
        memcpy(&buffercpy[i * 4], ip - offset_1, 4);
        memcpy(&buffercpy[j * 4], ip - offset_1 + 4, 4);
        memcpy(&buffercpy[l * 4], ip - offset_2, 4);
        memcpy(&buffercpy[m * 4], ip - offset_2 + 4, 4);

      } else {
        BLOSC_TRACE_ERROR(""Invalid token: %u at cell [%d, %d]\n"", token, ii[0], ii[1]);
        return BLOSC2_ERROR_FAILURE;
      }
      // fill op with buffercpy
      uint32_t orig = ii[0] * 4 * blockshape[1] + ii[1] * 4;
      for (uint32_t i = 0; i < 4; i++) {
        if (i < padding[0]) {
          ind = orig + i * blockshape[1];
          memcpy(&op[ind], buffercpy, padding[1]);
        }
        buffercpy += padding[1];
      }
      if (ind > (uint32_t) output_len) {
        BLOSC_TRACE_ERROR(""Exceeding output size"");
        return BLOSC2_ERROR_FAILURE;
      }
    }
  }
  ind += padding[1];

  if (ind != (blockshape[0] * blockshape[1])) {
    BLOSC_TRACE_ERROR(""Output size is not compatible with embedded blockshape"");
    return BLOSC2_ERROR_FAILURE;
  }
  if (ind > (uint32_t) output_len) {
    BLOSC_TRACE_ERROR(""Exceeding output size"");
    return BLOSC2_ERROR_FAILURE;
  }

  return (int) ind;
}","int ndlz4_decompress(const uint8_t *VAR_0, int32_t VAR_1, uint8_t *VAR_2, int32_t VAR_3,
                     uint8_t VAR_4, blosc2_dparams *VAR_5) {
  BLOSC_UNUSED_PARAM(VAR_4);
  BLOSC_UNUSED_PARAM(VAR_5);
  BLOSC_ERROR_NULL(VAR_0, VAR_6);
  BLOSC_ERROR_NULL(VAR_2, VAR_6);

  uint8_t *VAR_7 = (uint8_t *) VAR_0;
  uint8_t *VAR_8 = VAR_7 + VAR_1;
  uint8_t *VAR_9 = (uint8_t *) VAR_2;
  uint8_t VAR_10;
  uint32_t VAR_11[2];
  uint32_t VAR_12[2];
  uint8_t *VAR_13;
  uint8_t VAR_14[16];
  uint8_t VAR_15;
  if (NDLZ_UNEXPECT_CONDITIONAL(VAR_1 < 8)) {
    return 0;
  }

  /* COMMENT_0 */
  VAR_10 = *VAR_7;
  VAR_7++;
  if (VAR_10 != 2) {
    BLOSC_TRACE_ERROR(""This codec only works for ndim = 2"");
    return VAR_16;
  }
  memcpy(&VAR_11[0], VAR_7, 4);
  VAR_7 += 4;
  memcpy(&VAR_11[1], VAR_7, 4);
  VAR_7 += 4;
  VAR_12[0] = ((VAR_11[0] + 3) / 4) * 4;
  VAR_12[1] = ((VAR_11[1] + 3) / 4) * 4;

  if (NDLZ_UNEXPECT_CONDITIONAL((int64_t)VAR_3 < (int64_t)VAR_11[0] * (int64_t)VAR_11[1])) {
    return 0;
  }
  memset(VAR_9, 0, VAR_11[0] * VAR_11[1]);

  uint32_t VAR_17[2];
  for (int VAR_18 = 0; VAR_18 < 2; ++VAR_18) {
    VAR_17[VAR_18] = VAR_12[VAR_18] / 4;
  }

  /* COMMENT_1 */
  uint32_t VAR_19[2];
  uint32_t VAR_20[2] = {0};
  uint32_t VAR_21 = 0;
  uint8_t VAR_22[16];
  for (VAR_19[0] = 0; VAR_19[0] < VAR_17[0]; ++VAR_19[0]) {
    for (VAR_19[1] = 0; VAR_19[1] < VAR_17[1]; ++VAR_19[1]) {      /* COMMENT_2 */
      if (NDLZ_UNEXPECT_CONDITIONAL(VAR_7 > VAR_8)) {
        BLOSC_TRACE_ERROR(""Exceeding input length"");
        return VAR_16;
      }
      if (VAR_19[0] == VAR_17[0] - 1) {
        VAR_20[0] = (VAR_11[0] % 4 == 0) ? 4 : VAR_11[0] % 4;
      } else {
        VAR_20[0] = 4;
      }
      if (VAR_19[1] == VAR_17[1] - 1) {
        VAR_20[1] = (VAR_11[1] % 4 == 0) ? 4 : VAR_11[1] % 4;
      } else {
        VAR_20[1] = 4;
      }
      VAR_15 = *VAR_7++;
      if (VAR_15 == 0) {    /* COMMENT_3 */
        VAR_13 = VAR_7;
        VAR_7 += VAR_20[0] * VAR_20[1];
      } else if (VAR_15 == (uint8_t) ((1U << 7U) | (1U << 6U))) {  /* COMMENT_4 */
        uint16_t VAR_23 = *((uint16_t *) VAR_7);
        VAR_13 = VAR_7 - VAR_23 - 1;
        VAR_7 += 2;
      } else if (VAR_15 == (uint8_t) (1U << 6U)) { /* COMMENT_5 */
        VAR_13 = VAR_22;
        memset(VAR_13, *VAR_7, 16);
        VAR_7++;
      } else if (VAR_15 >= 224) { /* COMMENT_6 */
        VAR_13 = VAR_14;
        uint16_t VAR_23 = *((uint16_t *) VAR_7);
        VAR_23 += 3;
        VAR_7 += 2;
        int VAR_18, VAR_24, VAR_25;
        if ((VAR_15 >> 3U) == 28) {
          VAR_18 = 1;
          VAR_24 = 2;
          VAR_25 = 3;
        } else {
          VAR_18 = 0;
          if ((VAR_15 >> 3U) < 30) {
            VAR_24 = 1;
            VAR_25 = 2;
          } else {
            VAR_25 = 3;
            if ((VAR_15 >> 3U) == 30) {
              VAR_24 = 1;
            } else {
              VAR_24 = 2;
            }
          }
        }
        memcpy(&VAR_13[VAR_18 * 4], VAR_7 - VAR_23, 4);
        memcpy(&VAR_13[VAR_24 * 4], VAR_7 - VAR_23 + 4, 4);
        memcpy(&VAR_13[VAR_25 * 4], VAR_7 - VAR_23 + 8, 4);
        for (int VAR_26 = 0; VAR_26 < 4; VAR_26++) {
          if ((VAR_26 != VAR_18) && (VAR_26 != VAR_24) && (VAR_26 != VAR_25)) {
            memcpy(&VAR_13[VAR_26 * 4], VAR_7, 4);
            VAR_7 += 4;
            break;
          }
        }

      } else if ((VAR_15 >= 128) && (VAR_15 <= 191)) { /* COMMENT_7 */
        VAR_13 = VAR_14;
        uint16_t VAR_23 = *((uint16_t *) VAR_7);
        VAR_23 += 3;
        VAR_7 += 2;
        int VAR_18, VAR_24;
        if (VAR_15 == 128) {
          VAR_18 = 2;
          VAR_24 = 3;
        } else {
          VAR_18 = (VAR_15 - 128) >> 5U;
          VAR_24 = ((VAR_15 - 128) >> 3U) - (VAR_18 << 2U);
        }
        memcpy(&VAR_13[VAR_18 * 4], VAR_7 - VAR_23, 4);
        memcpy(&VAR_13[VAR_24 * 4], VAR_7 - VAR_23 + 4, 4);
        for (int VAR_25 = 0; VAR_25 < 4; VAR_25++) {
          if ((VAR_25 != VAR_18) && (VAR_25 != VAR_24)) {
            memcpy(&VAR_13[VAR_25 * 4], VAR_7, 4);
            VAR_7 += 4;
          }
        }
      } else if ((VAR_15 >= 40) && (VAR_15 <= 63)) {  /* COMMENT_8 */
        VAR_13 = VAR_14;
        uint16_t VAR_27 = *((uint16_t *) VAR_7);
        VAR_27 += 5;
        VAR_7 += 2;
        uint16_t VAR_28 = *((uint16_t *) VAR_7);
        VAR_28 += 5;
        VAR_7 += 2;
        int VAR_18, VAR_24, VAR_25, VAR_26, VAR_29;
        VAR_18 = 0;
        VAR_24 = ((VAR_15 - 32) >> 3U);
        VAR_26 = -1;
        for (VAR_25 = 1; VAR_25 < 4; VAR_25++) {
          if ((VAR_25 != VAR_18) && (VAR_25 != VAR_24)) {
            if (VAR_26 == -1) {
              VAR_26 = VAR_25;
            } else {
              VAR_29 = VAR_25;
            }
          }
        }
        memcpy(&VAR_13[VAR_18 * 4], VAR_7 - VAR_27, 4);
        memcpy(&VAR_13[VAR_24 * 4], VAR_7 - VAR_27 + 4, 4);
        memcpy(&VAR_13[VAR_26 * 4], VAR_7 - VAR_28, 4);
        memcpy(&VAR_13[VAR_29 * 4], VAR_7 - VAR_28 + 4, 4);

      } else {
        BLOSC_TRACE_ERROR(""Invalid token: %u at cell [%d, %d]\n"", VAR_15, VAR_19[0], VAR_19[1]);
        return VAR_16;
      }
      /* COMMENT_9 */
      uint32_t VAR_30 = VAR_19[0] * 4 * VAR_11[1] + VAR_19[1] * 4;
      for (uint32_t VAR_18 = 0; VAR_18 < 4; VAR_18++) {
        if (VAR_18 < VAR_20[0]) {
          VAR_21 = VAR_30 + VAR_18 * VAR_11[1];
          memcpy(&VAR_9[VAR_21], VAR_13, VAR_20[1]);
        }
        VAR_13 += VAR_20[1];
      }
      if (VAR_21 > (uint32_t) VAR_3) {
        BLOSC_TRACE_ERROR(""Exceeding output size"");
        return VAR_16;
      }
    }
  }
  VAR_21 += VAR_20[1];

  if (VAR_21 != (VAR_11[0] * VAR_11[1])) {
    BLOSC_TRACE_ERROR(""Output size is not compatible with embedded blockshape"");
    return VAR_16;
  }
  if (VAR_21 > (uint32_t) VAR_3) {
    BLOSC_TRACE_ERROR(""Exceeding output size"");
    return VAR_16;
  }

  return (int) VAR_21;
}",Blosc/c-blosc2/d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3/ndlz4x4.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -2,6 +2,8 @@
                      uint8_t meta, blosc2_dparams *dparams) {
   BLOSC_UNUSED_PARAM(meta);
   BLOSC_UNUSED_PARAM(dparams);
+  BLOSC_ERROR_NULL(input, BLOSC2_ERROR_NULL_POINTER);
+  BLOSC_ERROR_NULL(output, BLOSC2_ERROR_NULL_POINTER);
 
   uint8_t *ip = (uint8_t *) input;
   uint8_t *ip_limit = ip + input_len;
@@ -30,7 +32,7 @@
   eshape[0] = ((blockshape[0] + 3) / 4) * 4;
   eshape[1] = ((blockshape[1] + 3) / 4) * 4;
 
-  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < (int32_t) (blockshape[0] * blockshape[1]))) {
+  if (NDLZ_UNEXPECT_CONDITIONAL((int64_t)output_len < (int64_t)blockshape[0] * (int64_t)blockshape[1])) {
     return 0;
   }
   memset(op, 0, blockshape[0] * blockshape[1]);","{'deleted_lines': ['  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < (int32_t) (blockshape[0] * blockshape[1]))) {'], 'added_lines': ['  BLOSC_ERROR_NULL(input, BLOSC2_ERROR_NULL_POINTER);', '  BLOSC_ERROR_NULL(output, BLOSC2_ERROR_NULL_POINTER);', '  if (NDLZ_UNEXPECT_CONDITIONAL((int64_t)output_len < (int64_t)blockshape[0] * (int64_t)blockshape[1])) {']}",True,C-blosc2 before 2.9.3 was discovered to contain a NULL pointer dereference in ndlz/ndlz8x8.c via a NULL pointer to memset.,7.5,HIGH,2,test,2023-06-21T09:17:51Z,4
CVE-2023-37186,['CWE-476'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Blosc/c-blosc2,Fix #522,d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3,https://github.com/Blosc/c-blosc2/commit/d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3,plugins/codecs/ndlz/ndlz8x8.c,ndlz8_decompress,"int ndlz8_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,
uint8_t meta, blosc2_dparams *dparams) {
BLOSC_UNUSED_PARAM(meta);
BLOSC_UNUSED_PARAM(dparams);
const int cell_shape = 8;
const int cell_size = 64;
uint8_t *ip = (uint8_t *) input;
uint8_t *ip_limit = ip + input_len;
uint8_t *op = (uint8_t *) output;
uint8_t ndim;
int32_t blockshape[2];
int32_t eshape[2];
uint8_t *buffercpy;
uint8_t token;
if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {
return 0;
}
ndim = *ip;
ip++;
if (ndim != 2) {
BLOSC_TRACE_ERROR(""This codec only works for ndim = 2"");
return BLOSC2_ERROR_FAILURE;
}
memcpy(&blockshape[0], ip, 4);
ip += 4;
memcpy(&blockshape[1], ip, 4);
ip += 4;
eshape[0] = ((blockshape[0] + 7) / cell_shape) * cell_shape;
eshape[1] = ((blockshape[1] + 7) / cell_shape) * cell_shape;
if (NDLZ_UNEXPECT_CONDITIONAL(output_len < blockshape[0] * blockshape[1])) {
return 0;
}
memset(op, 0, blockshape[0] * blockshape[1]);
int32_t i_stop[2];
for (int i = 0; i < 2; ++i) {
i_stop[i] = eshape[i] / cell_shape;
}
int32_t ii[2];
int32_t padding[2] = {0};
int32_t ind = 0;
uint8_t *local_buffer = malloc(cell_size);
uint8_t *cell_aux = malloc(cell_size);
for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {
for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {            if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {
free(local_buffer);
free(cell_aux);
BLOSC_TRACE_ERROR(""Exceeding input length"");
return BLOSC2_ERROR_FAILURE;
}
if (ii[0] == i_stop[0] - 1) {
padding[0] = (blockshape[0] % cell_shape == 0) ? cell_shape : blockshape[0] % cell_shape;
} else {
padding[0] = cell_shape;
}
if (ii[1] == i_stop[1] - 1) {
padding[1] = (blockshape[1] % cell_shape == 0) ? cell_shape : blockshape[1] % cell_shape;
} else {
padding[1] = cell_shape;
}
token = *ip++;
uint8_t match_type = (token >> 3U);
if (token == 0) {            buffercpy = ip;
ip += padding[0] * padding[1];
} else if (token == (uint8_t) ((1U << 7U) | (1U << 6U))) {          uint16_t offset = *((uint16_t *) ip);
buffercpy = ip - offset - 1;
ip += 2;
} else if (token == (uint8_t) (1U << 6U)) {         buffercpy = cell_aux;
memset(buffercpy, *ip, cell_size);
ip++;
} else if (match_type == 21) {            buffercpy = local_buffer;
int row = (int) (token & 7);
uint16_t offset = *((uint16_t *) ip);
ip += 2;
for (int l = 0; l < 3; l++) {
memcpy(&buffercpy[(row + l) * cell_shape],
ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);
}
for (int l = 0; l < cell_shape; l++) {
if ((l < row) || (l > row + 2)) {
memcpy(&buffercpy[l * cell_shape], ip, cell_shape);
ip += cell_shape;
}
}
} else if (match_type == 17) {            buffercpy = local_buffer;
int row = (int) (token & 7);
uint16_t offset = *((uint16_t *) ip);
ip += 2;
for (int l = 0; l < 2; l++) {
memcpy(&buffercpy[(row + l) * cell_shape],
ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);
}
for (int l = 0; l < cell_shape; l++) {
if ((l < row) || (l > row + 1)) {
memcpy(&buffercpy[l * cell_shape], ip, cell_shape);
ip += cell_shape;
}
}
} else {
free(local_buffer);
free(cell_aux);
BLOSC_TRACE_ERROR(""Invalid token: %u at cell [%d, %d]\n"", token, ii[0], ii[1]);
return BLOSC2_ERROR_FAILURE;
}
int32_t orig = ii[0] * cell_shape * blockshape[1] + ii[1] * cell_shape;
for (int32_t i = 0; i < (int32_t) cell_shape; i++) {
if (i < padding[0]) {
ind = orig + i * blockshape[1];
memcpy(&op[ind], buffercpy, padding[1]);
}
buffercpy += padding[1];
}
if (ind > output_len) {
free(local_buffer);
free(cell_aux);
BLOSC_TRACE_ERROR(""Exceeding output size"");
return BLOSC2_ERROR_FAILURE;
}
}
}
ind += padding[1];
free(cell_aux);
free(local_buffer);
if (ind != (blockshape[0] * blockshape[1])) {
BLOSC_TRACE_ERROR(""Output size is not compatible with embedded blockshape"");
return BLOSC2_ERROR_FAILURE;
}
if (ind > output_len) {
BLOSC_TRACE_ERROR(""Exceeding output size"");
return BLOSC2_ERROR_FAILURE;
}
return (int) ind;
}","int ndlz8_decompress(const uint8_t *VAR_0, int32_t VAR_1, uint8_t *VAR_2, int32_t VAR_3,
uint8_t VAR_4, blosc2_dparams *VAR_5) {
BLOSC_UNUSED_PARAM(VAR_4);
BLOSC_UNUSED_PARAM(VAR_5);
const int VAR_6 = 8;
const int VAR_7 = 64;
uint8_t *VAR_8 = (uint8_t *) VAR_0;
uint8_t *VAR_9 = VAR_8 + VAR_1;
uint8_t *VAR_10 = (uint8_t *) VAR_2;
uint8_t VAR_11;
int32_t VAR_12[2];
int32_t VAR_13[2];
uint8_t *VAR_14;
uint8_t VAR_15;
if (NDLZ_UNEXPECT_CONDITIONAL(VAR_1 < 8)) {
return 0;
}
VAR_11 = *VAR_8;
VAR_8++;
if (VAR_11 != 2) {
BLOSC_TRACE_ERROR(""This codec only works for ndim = 2"");
return VAR_16;
}
memcpy(&VAR_12[0], VAR_8, 4);
VAR_8 += 4;
memcpy(&VAR_12[1], VAR_8, 4);
VAR_8 += 4;
VAR_13[0] = ((VAR_12[0] + 7) / VAR_6) * VAR_6;
VAR_13[1] = ((VAR_12[1] + 7) / VAR_6) * VAR_6;
if (NDLZ_UNEXPECT_CONDITIONAL(VAR_3 < VAR_12[0] * VAR_12[1])) {
return 0;
}
memset(VAR_10, 0, VAR_12[0] * VAR_12[1]);
int32_t VAR_17[2];
for (int VAR_18 = 0; VAR_18 < 2; ++VAR_18) {
VAR_17[VAR_18] = VAR_13[VAR_18] / VAR_6;
}
int32_t VAR_19[2];
int32_t VAR_20[2] = {0};
int32_t VAR_21 = 0;
uint8_t *VAR_22 = malloc(VAR_7);
uint8_t *VAR_23 = malloc(VAR_7);
for (VAR_19[0] = 0; VAR_19[0] < VAR_17[0]; ++VAR_19[0]) {
for (VAR_19[1] = 0; VAR_19[1] < VAR_17[1]; ++VAR_19[1]) {      
if (NDLZ_UNEXPECT_CONDITIONAL(VAR_8 > VAR_9)) {
free(VAR_22);
free(VAR_23);
BLOSC_TRACE_ERROR(""Exceeding input length"");
return VAR_16;
}
if (VAR_19[0] == VAR_17[0] - 1) {
VAR_20[0] = (VAR_12[0] % VAR_6 == 0) ? VAR_6 : VAR_12[0] % VAR_6;
} else {
VAR_20[0] = VAR_6;
}
if (VAR_19[1] == VAR_17[1] - 1) {
VAR_20[1] = (VAR_12[1] % VAR_6 == 0) ? VAR_6 : VAR_12[1] % VAR_6;
} else {
VAR_20[1] = VAR_6;
}
VAR_15 = *VAR_8++;
uint8_t VAR_24 = (VAR_15 >> 3U);
if (VAR_15 == 0) {    
VAR_14 = VAR_8;
VAR_8 += VAR_20[0] * VAR_20[1];
} else if (VAR_15 == (uint8_t) ((1U << 7U) | (1U << 6U))) {  
uint16_t VAR_25 = *((uint16_t *) VAR_8);
VAR_14 = VAR_8 - VAR_25 - 1;
VAR_8 += 2;
} else if (VAR_15 == (uint8_t) (1U << 6U)) { 
VAR_14 = VAR_23;
memset(VAR_14, *VAR_8, VAR_7);
VAR_8++;
} else if (VAR_24 == 21) {    
VAR_14 = VAR_22;
int VAR_26 = (int) (VAR_15 & 7);
uint16_t VAR_25 = *((uint16_t *) VAR_8);
VAR_8 += 2;
for (int VAR_27 = 0; VAR_27 < 3; VAR_27++) {
memcpy(&VAR_14[(VAR_26 + VAR_27) * VAR_6],
VAR_8 - sizeof(VAR_15) - sizeof(VAR_25) - VAR_25 + VAR_27 * VAR_6, VAR_6);
}
for (int VAR_27 = 0; VAR_27 < VAR_6; VAR_27++) {
if ((VAR_27 < VAR_26) || (VAR_27 > VAR_26 + 2)) {
memcpy(&VAR_14[VAR_27 * VAR_6], VAR_8, VAR_6);
VAR_8 += VAR_6;
}
}
} else if (VAR_24 == 17) {    
VAR_14 = VAR_22;
int VAR_26 = (int) (VAR_15 & 7);
uint16_t VAR_25 = *((uint16_t *) VAR_8);
VAR_8 += 2;
for (int VAR_27 = 0; VAR_27 < 2; VAR_27++) {
memcpy(&VAR_14[(VAR_26 + VAR_27) * VAR_6],
VAR_8 - sizeof(VAR_15) - sizeof(VAR_25) - VAR_25 + VAR_27 * VAR_6, VAR_6);
}
for (int VAR_27 = 0; VAR_27 < VAR_6; VAR_27++) {
if ((VAR_27 < VAR_26) || (VAR_27 > VAR_26 + 1)) {
memcpy(&VAR_14[VAR_27 * VAR_6], VAR_8, VAR_6);
VAR_8 += VAR_6;
}
}
} else {
free(VAR_22);
free(VAR_23);
BLOSC_TRACE_ERROR(""Invalid token: %u at cell [%d, %d]\n"", VAR_15, VAR_19[0], VAR_19[1]);
return VAR_16;
}
int32_t VAR_28 = VAR_19[0] * VAR_6 * VAR_12[1] + VAR_19[1] * VAR_6;
for (int32_t VAR_18 = 0; VAR_18 < (int32_t) VAR_6; VAR_18++) {
if (VAR_18 < VAR_20[0]) {
VAR_21 = VAR_28 + VAR_18 * VAR_12[1];
memcpy(&VAR_10[VAR_21], VAR_14, VAR_20[1]);
}
VAR_14 += VAR_20[1];
}
if (VAR_21 > VAR_3) {
free(VAR_22);
free(VAR_23);
BLOSC_TRACE_ERROR(""Exceeding output size"");
return VAR_16;
}
}
}
VAR_21 += VAR_20[1];
free(VAR_23);
free(VAR_22);
if (VAR_21 != (VAR_12[0] * VAR_12[1])) {
BLOSC_TRACE_ERROR(""Output size is not compatible with embedded blockshape"");
return VAR_16;
}
if (VAR_21 > VAR_3) {
BLOSC_TRACE_ERROR(""Exceeding output size"");
return VAR_16;
}
return (int) VAR_21;
}",Blosc/c-blosc2/d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3/ndlz8x8.c/vul/before/0.json,"int ndlz8_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,
                     uint8_t meta, blosc2_dparams *dparams) {
  BLOSC_UNUSED_PARAM(meta);
  BLOSC_UNUSED_PARAM(dparams);
  BLOSC_ERROR_NULL(input, BLOSC2_ERROR_NULL_POINTER);
  BLOSC_ERROR_NULL(output, BLOSC2_ERROR_NULL_POINTER);

  const int cell_shape = 8;
  const int cell_size = 64;
  uint8_t *ip = (uint8_t *) input;
  uint8_t *ip_limit = ip + input_len;
  uint8_t *op = (uint8_t *) output;
  uint8_t ndim;
  int32_t blockshape[2];
  int32_t eshape[2];
  uint8_t *buffercpy;
  uint8_t token;
  if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {
    return 0;
  }

  /* we start with literal copy */
  ndim = *ip;
  ip++;
  if (ndim != 2) {
    BLOSC_TRACE_ERROR(""This codec only works for ndim = 2"");
    return BLOSC2_ERROR_FAILURE;
  }
  memcpy(&blockshape[0], ip, 4);
  ip += 4;
  memcpy(&blockshape[1], ip, 4);
  ip += 4;
  eshape[0] = ((blockshape[0] + 7) / cell_shape) * cell_shape;
  eshape[1] = ((blockshape[1] + 7) / cell_shape) * cell_shape;
  if (NDLZ_UNEXPECT_CONDITIONAL((int64_t)output_len < (int64_t)blockshape[0] * (int64_t)blockshape[1])) {
    return 0;
  }
  memset(op, 0, blockshape[0] * blockshape[1]);

  int32_t i_stop[2];
  for (int i = 0; i < 2; ++i) {
    i_stop[i] = eshape[i] / cell_shape;
  }

  /* main loop */
  int32_t ii[2];
  int32_t padding[2] = {0};
  int32_t ind = 0;
  uint8_t *local_buffer = malloc(cell_size);
  uint8_t *cell_aux = malloc(cell_size);
  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {
    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell
      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {
        free(local_buffer);
        free(cell_aux);
        BLOSC_TRACE_ERROR(""Exceeding input length"");
        return BLOSC2_ERROR_FAILURE;
      }
      if (ii[0] == i_stop[0] - 1) {
        padding[0] = (blockshape[0] % cell_shape == 0) ? cell_shape : blockshape[0] % cell_shape;
      } else {
        padding[0] = cell_shape;
      }
      if (ii[1] == i_stop[1] - 1) {
        padding[1] = (blockshape[1] % cell_shape == 0) ? cell_shape : blockshape[1] % cell_shape;
      } else {
        padding[1] = cell_shape;
      }
      token = *ip++;
      uint8_t match_type = (token >> 3U);
      if (token == 0) {    // no match
        buffercpy = ip;
        ip += padding[0] * padding[1];
      } else if (token == (uint8_t) ((1U << 7U) | (1U << 6U))) {  // cell match
        uint16_t offset = *((uint16_t *) ip);
        buffercpy = ip - offset - 1;
        ip += 2;
      } else if (token == (uint8_t) (1U << 6U)) { // whole cell of same element
        buffercpy = cell_aux;
        memset(buffercpy, *ip, cell_size);
        ip++;
      } else if (match_type == 21) {    // triple match
        buffercpy = local_buffer;
        int row = (int) (token & 7);
        uint16_t offset = *((uint16_t *) ip);
        ip += 2;
        for (int l = 0; l < 3; l++) {
          memcpy(&buffercpy[(row + l) * cell_shape],
                 ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);
        }
        for (int l = 0; l < cell_shape; l++) {
          if ((l < row) || (l > row + 2)) {
            memcpy(&buffercpy[l * cell_shape], ip, cell_shape);
            ip += cell_shape;
          }
        }
      } else if (match_type == 17) {    // pair match
        buffercpy = local_buffer;
        int row = (int) (token & 7);
        uint16_t offset = *((uint16_t *) ip);
        ip += 2;
        for (int l = 0; l < 2; l++) {
          memcpy(&buffercpy[(row + l) * cell_shape],
                 ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);
        }
        for (int l = 0; l < cell_shape; l++) {
          if ((l < row) || (l > row + 1)) {
            memcpy(&buffercpy[l * cell_shape], ip, cell_shape);
            ip += cell_shape;
          }
        }
      } else {
        free(local_buffer);
        free(cell_aux);
        BLOSC_TRACE_ERROR(""Invalid token: %u at cell [%d, %d]\n"", token, ii[0], ii[1]);
        return BLOSC2_ERROR_FAILURE;
      }

      int32_t orig = ii[0] * cell_shape * blockshape[1] + ii[1] * cell_shape;
      for (int32_t i = 0; i < (int32_t) cell_shape; i++) {
        if (i < padding[0]) {
          ind = orig + i * blockshape[1];
          memcpy(&op[ind], buffercpy, padding[1]);
        }
        buffercpy += padding[1];
      }
      if (ind > output_len) {
        free(local_buffer);
        free(cell_aux);
        BLOSC_TRACE_ERROR(""Exceeding output size"");
        return BLOSC2_ERROR_FAILURE;
      }
    }
  }
  ind += padding[1];

  free(cell_aux);
  free(local_buffer);

  if (ind != (blockshape[0] * blockshape[1])) {
    BLOSC_TRACE_ERROR(""Output size is not compatible with embedded blockshape"");
    return BLOSC2_ERROR_FAILURE;
  }
  if (ind > output_len) {
    BLOSC_TRACE_ERROR(""Exceeding output size"");
    return BLOSC2_ERROR_FAILURE;
  }

  return (int) ind;
}","int ndlz8_decompress(const uint8_t *VAR_0, int32_t VAR_1, uint8_t *VAR_2, int32_t VAR_3,
                     uint8_t VAR_4, blosc2_dparams *VAR_5) {
  BLOSC_UNUSED_PARAM(VAR_4);
  BLOSC_UNUSED_PARAM(VAR_5);
  BLOSC_ERROR_NULL(VAR_0, VAR_6);
  BLOSC_ERROR_NULL(VAR_2, VAR_6);

  const int VAR_7 = 8;
  const int VAR_8 = 64;
  uint8_t *VAR_9 = (uint8_t *) VAR_0;
  uint8_t *VAR_10 = VAR_9 + VAR_1;
  uint8_t *VAR_11 = (uint8_t *) VAR_2;
  uint8_t VAR_12;
  int32_t VAR_13[2];
  int32_t VAR_14[2];
  uint8_t *VAR_15;
  uint8_t VAR_16;
  if (NDLZ_UNEXPECT_CONDITIONAL(VAR_1 < 8)) {
    return 0;
  }

  /* COMMENT_0 */
  VAR_12 = *VAR_9;
  VAR_9++;
  if (VAR_12 != 2) {
    BLOSC_TRACE_ERROR(""This codec only works for ndim = 2"");
    return VAR_17;
  }
  memcpy(&VAR_13[0], VAR_9, 4);
  VAR_9 += 4;
  memcpy(&VAR_13[1], VAR_9, 4);
  VAR_9 += 4;
  VAR_14[0] = ((VAR_13[0] + 7) / VAR_7) * VAR_7;
  VAR_14[1] = ((VAR_13[1] + 7) / VAR_7) * VAR_7;
  if (NDLZ_UNEXPECT_CONDITIONAL((int64_t)VAR_3 < (int64_t)VAR_13[0] * (int64_t)VAR_13[1])) {
    return 0;
  }
  memset(VAR_11, 0, VAR_13[0] * VAR_13[1]);

  int32_t VAR_18[2];
  for (int VAR_19 = 0; VAR_19 < 2; ++VAR_19) {
    VAR_18[VAR_19] = VAR_14[VAR_19] / VAR_7;
  }

  /* COMMENT_1 */
  int32_t VAR_20[2];
  int32_t VAR_21[2] = {0};
  int32_t VAR_22 = 0;
  uint8_t *VAR_23 = malloc(VAR_8);
  uint8_t *VAR_24 = malloc(VAR_8);
  for (VAR_20[0] = 0; VAR_20[0] < VAR_18[0]; ++VAR_20[0]) {
    for (VAR_20[1] = 0; VAR_20[1] < VAR_18[1]; ++VAR_20[1]) {      /* COMMENT_2 */
      if (NDLZ_UNEXPECT_CONDITIONAL(VAR_9 > VAR_10)) {
        free(VAR_23);
        free(VAR_24);
        BLOSC_TRACE_ERROR(""Exceeding input length"");
        return VAR_17;
      }
      if (VAR_20[0] == VAR_18[0] - 1) {
        VAR_21[0] = (VAR_13[0] % VAR_7 == 0) ? VAR_7 : VAR_13[0] % VAR_7;
      } else {
        VAR_21[0] = VAR_7;
      }
      if (VAR_20[1] == VAR_18[1] - 1) {
        VAR_21[1] = (VAR_13[1] % VAR_7 == 0) ? VAR_7 : VAR_13[1] % VAR_7;
      } else {
        VAR_21[1] = VAR_7;
      }
      VAR_16 = *VAR_9++;
      uint8_t VAR_25 = (VAR_16 >> 3U);
      if (VAR_16 == 0) {    /* COMMENT_3 */
        VAR_15 = VAR_9;
        VAR_9 += VAR_21[0] * VAR_21[1];
      } else if (VAR_16 == (uint8_t) ((1U << 7U) | (1U << 6U))) {  /* COMMENT_4 */
        uint16_t VAR_26 = *((uint16_t *) VAR_9);
        VAR_15 = VAR_9 - VAR_26 - 1;
        VAR_9 += 2;
      } else if (VAR_16 == (uint8_t) (1U << 6U)) { /* COMMENT_5 */
        VAR_15 = VAR_24;
        memset(VAR_15, *VAR_9, VAR_8);
        VAR_9++;
      } else if (VAR_25 == 21) {    /* COMMENT_6 */
        VAR_15 = VAR_23;
        int VAR_27 = (int) (VAR_16 & 7);
        uint16_t VAR_26 = *((uint16_t *) VAR_9);
        VAR_9 += 2;
        for (int VAR_28 = 0; VAR_28 < 3; VAR_28++) {
          memcpy(&VAR_15[(VAR_27 + VAR_28) * VAR_7],
                 VAR_9 - sizeof(VAR_16) - sizeof(VAR_26) - VAR_26 + VAR_28 * VAR_7, VAR_7);
        }
        for (int VAR_28 = 0; VAR_28 < VAR_7; VAR_28++) {
          if ((VAR_28 < VAR_27) || (VAR_28 > VAR_27 + 2)) {
            memcpy(&VAR_15[VAR_28 * VAR_7], VAR_9, VAR_7);
            VAR_9 += VAR_7;
          }
        }
      } else if (VAR_25 == 17) {    /* COMMENT_7 */
        VAR_15 = VAR_23;
        int VAR_27 = (int) (VAR_16 & 7);
        uint16_t VAR_26 = *((uint16_t *) VAR_9);
        VAR_9 += 2;
        for (int VAR_28 = 0; VAR_28 < 2; VAR_28++) {
          memcpy(&VAR_15[(VAR_27 + VAR_28) * VAR_7],
                 VAR_9 - sizeof(VAR_16) - sizeof(VAR_26) - VAR_26 + VAR_28 * VAR_7, VAR_7);
        }
        for (int VAR_28 = 0; VAR_28 < VAR_7; VAR_28++) {
          if ((VAR_28 < VAR_27) || (VAR_28 > VAR_27 + 1)) {
            memcpy(&VAR_15[VAR_28 * VAR_7], VAR_9, VAR_7);
            VAR_9 += VAR_7;
          }
        }
      } else {
        free(VAR_23);
        free(VAR_24);
        BLOSC_TRACE_ERROR(""Invalid token: %u at cell [%d, %d]\n"", VAR_16, VAR_20[0], VAR_20[1]);
        return VAR_17;
      }

      int32_t VAR_29 = VAR_20[0] * VAR_7 * VAR_13[1] + VAR_20[1] * VAR_7;
      for (int32_t VAR_19 = 0; VAR_19 < (int32_t) VAR_7; VAR_19++) {
        if (VAR_19 < VAR_21[0]) {
          VAR_22 = VAR_29 + VAR_19 * VAR_13[1];
          memcpy(&VAR_11[VAR_22], VAR_15, VAR_21[1]);
        }
        VAR_15 += VAR_21[1];
      }
      if (VAR_22 > VAR_3) {
        free(VAR_23);
        free(VAR_24);
        BLOSC_TRACE_ERROR(""Exceeding output size"");
        return VAR_17;
      }
    }
  }
  VAR_22 += VAR_21[1];

  free(VAR_24);
  free(VAR_23);

  if (VAR_22 != (VAR_13[0] * VAR_13[1])) {
    BLOSC_TRACE_ERROR(""Output size is not compatible with embedded blockshape"");
    return VAR_17;
  }
  if (VAR_22 > VAR_3) {
    BLOSC_TRACE_ERROR(""Exceeding output size"");
    return VAR_17;
  }

  return (int) VAR_22;
}",Blosc/c-blosc2/d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3/ndlz8x8.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,6 +2,8 @@
                      uint8_t meta, blosc2_dparams *dparams) {
   BLOSC_UNUSED_PARAM(meta);
   BLOSC_UNUSED_PARAM(dparams);
+  BLOSC_ERROR_NULL(input, BLOSC2_ERROR_NULL_POINTER);
+  BLOSC_ERROR_NULL(output, BLOSC2_ERROR_NULL_POINTER);
 
   const int cell_shape = 8;
   const int cell_size = 64;
@@ -30,8 +32,7 @@
   ip += 4;
   eshape[0] = ((blockshape[0] + 7) / cell_shape) * cell_shape;
   eshape[1] = ((blockshape[1] + 7) / cell_shape) * cell_shape;
-
-  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < blockshape[0] * blockshape[1])) {
+  if (NDLZ_UNEXPECT_CONDITIONAL((int64_t)output_len < (int64_t)blockshape[0] * (int64_t)blockshape[1])) {
     return 0;
   }
   memset(op, 0, blockshape[0] * blockshape[1]);","{'deleted_lines': ['', '  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < blockshape[0] * blockshape[1])) {'], 'added_lines': ['  BLOSC_ERROR_NULL(input, BLOSC2_ERROR_NULL_POINTER);', '  BLOSC_ERROR_NULL(output, BLOSC2_ERROR_NULL_POINTER);', '  if (NDLZ_UNEXPECT_CONDITIONAL((int64_t)output_len < (int64_t)blockshape[0] * (int64_t)blockshape[1])) {']}",True,C-blosc2 before 2.9.3 was discovered to contain a NULL pointer dereference in ndlz/ndlz8x8.c via a NULL pointer to memset.,7.5,HIGH,2,test,2023-06-21T09:17:51Z,4
CVE-2023-37186,['CWE-476'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Blosc/c-blosc2,Fix #522,d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3,https://github.com/Blosc/c-blosc2/commit/d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3,plugins/codecs/ndlz/ndlz8x8.c,ndlz8_compress,"int ndlz8_compress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,
uint8_t meta, blosc2_cparams *cparams) {
BLOSC_UNUSED_PARAM(meta);
uint8_t *smeta;
int32_t smeta_len;
if (blosc2_meta_get(cparams->schunk, ""b2nd"", &smeta, &smeta_len) < 0) {
BLOSC_TRACE_ERROR(""b2nd layer not found!"");
return BLOSC2_ERROR_FAILURE;
}
const int cell_shape = 8;
const int cell_size = 64;
int8_t ndim;
int64_t *shape = malloc(8 * sizeof(int64_t));
int32_t *chunkshape = malloc(8 * sizeof(int32_t));
int32_t *blockshape = malloc(8 * sizeof(int32_t));
deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);
free(smeta);
if (ndim != 2) {
BLOSC_TRACE_ERROR(""This codec only works for ndim = 2"");
return BLOSC2_ERROR_FAILURE;
}
if (input_len != (blockshape[0] * blockshape[1])) {
BLOSC_TRACE_ERROR(""Length not equal to blocksize"");
return BLOSC2_ERROR_FAILURE;
}
if (NDLZ_UNEXPECT_CONDITIONAL(output_len < (int) (1 + ndim * sizeof(int32_t)))) {
BLOSC_TRACE_ERROR(""Output too small"");
return BLOSC2_ERROR_FAILURE;
}
uint8_t *ip = (uint8_t *) input;
uint8_t *op = (uint8_t *) output;
uint8_t *op_limit;
uint32_t hval, hash_cell;
uint32_t hash_triple[6] = {0};
uint32_t hash_pair[7] = {0};
uint8_t *bufarea = malloc(cell_size);
uint8_t *buf_cell = bufarea;
uint8_t *buf_aux;
uint32_t tab_cell[1U << 12U] = {0};
uint32_t tab_triple[1U << 12U] = {0};
uint32_t tab_pair[1U << 12U] = {0};
uint32_t update_triple[6] = {0};
uint32_t update_pair[7] = {0};
op_limit = op + output_len;
for (unsigned i = 0; i < (1U << 12U); i++) {
tab_cell[i] = 0;
tab_triple[i] = 0;
tab_pair[i] = 0;
}
int overhead = 17 + (blockshape[0] * blockshape[1] / cell_size - 1) * 2;
if (input_len < cell_size || output_len < overhead) {
BLOSC_TRACE_ERROR(""Incorrect length or maxout"");
return 0;
}
uint8_t *obase = op;
*op++ = ndim;
memcpy(op, &blockshape[0], 4);
op += 4;
memcpy(op, &blockshape[1], 4);
op += 4;
uint32_t i_stop[2];
for (int i = 0; i < 2; ++i) {
i_stop[i] = (blockshape[i] + cell_shape - 1) / cell_shape;
}
uint32_t padding[2];
uint32_t ii[2];
for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {
for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {            for (int h = 0; h < 7; h++) {                 update_pair[h] = 0;
if (h != 6) {
update_triple[h] = 0;
}
}
if (NDLZ_UNEXPECT_CONDITIONAL(op + cell_size + 1 > op_limit)) {
free(shape);
free(chunkshape);
free(blockshape);
free(bufarea);
return 0;
}
uint32_t orig = ii[0] * cell_shape * blockshape[1] + ii[1] * cell_shape;
if (((blockshape[0] % cell_shape != 0) && (ii[0] == i_stop[0] - 1)) ||
((blockshape[1] % cell_shape != 0) && (ii[1] == i_stop[1] - 1))) {
uint8_t token = 0;                                           *op++ = token;
if (ii[0] == i_stop[0] - 1) {
padding[0] = (blockshape[0] % cell_shape == 0) ? cell_shape : blockshape[0] % cell_shape;
} else {
padding[0] = cell_shape;
}
if (ii[1] == i_stop[1] - 1) {
padding[1] = (blockshape[1] % cell_shape == 0) ? cell_shape : blockshape[1] % cell_shape;
} else {
padding[1] = cell_shape;
}
for (uint32_t i = 0; i < padding[0]; i++) {
memcpy(op, &ip[orig + i * blockshape[1]], padding[1]);
op += padding[1];
}
} else {
for (uint64_t i = 0; i < (uint64_t) cell_shape; i++) {                     uint64_t ind = orig + i * blockshape[1];
memcpy(buf_cell, &ip[ind], cell_shape);
buf_cell += cell_shape;
}
buf_cell -= cell_size;
const uint8_t *ref;
uint32_t distance;
uint8_t *anchor = op;    
hash_cell = XXH32(buf_cell, cell_size, 1);                hash_cell >>= 32U - 12U;
ref = obase + tab_cell[hash_cell];
if (tab_cell[hash_cell] == 0) {
distance = 0;
} else {
bool same = true;
buf_aux = obase + tab_cell[hash_cell];
for (int i = 0; i < cell_size; i++) {
if (buf_cell[i] != buf_aux[i]) {
same = false;
break;
}
}
if (same) {
distance = (int32_t) (anchor - ref);
} else {
distance = 0;
}
}
bool alleq = true;
for (int i = 1; i < cell_size; i++) {
if (buf_cell[i] != buf_cell[0]) {
alleq = false;
break;
}
}
if (alleq) {                                        uint8_t token = (uint8_t) (1U << 6U);
*op++ = token;
*op++ = buf_cell[0];
} else if (distance == 0 || (distance >= MAX_DISTANCE)) {             bool literal = true;
for (int i = 0; i < 6; i++) {
int triple_start = i * cell_shape;
hval = XXH32(&buf_cell[triple_start], 24, 1);                    hval >>= 32U - 12U;
bool same = true;
uint16_t offset;
if (tab_triple[hval] != 0) {
buf_aux = obase + tab_triple[hval];
for (int l = 0; l < 24; l++) {
if (buf_cell[triple_start + l] != buf_aux[l]) {
same = false;
break;
}
}
offset = (uint16_t) (anchor - obase - tab_triple[hval]);
} else {
same = false;
update_triple[i] = (uint32_t) (anchor + 1 + triple_start - obase);     
hash_triple[i] = hval;
}
ref = obase + tab_triple[hval];
if (same) {
distance = (int32_t) (anchor + triple_start - ref);
} else {
distance = 0;
}
if ((distance != 0) && (distance < MAX_DISTANCE)) {                   literal = false;
uint8_t token = (uint8_t) ((21 << 3U) | i);
*op++ = token;
memcpy(op, &offset, 2);
op += 2;
for (int l = 0; l < 8; l++) {
if ((l < i) || (l > i + 2)) {
memcpy(op, &buf_cell[l * cell_shape], cell_shape);
op += cell_shape;
}
}
goto match;
}
}
for (int i = 0; i < 7; i++) {
int pair_start = i * cell_shape;
hval = XXH32(&buf_cell[pair_start], 16, 1);                    hval >>= 32U - 12U;
ref = obase + tab_pair[hval];
bool same = true;
uint16_t offset;
if (tab_pair[hval] != 0) {
buf_aux = obase + tab_pair[hval];
for (int k = 0; k < 16; k++) {
if (buf_cell[pair_start + k] != buf_aux[k]) {
same = false;
break;
}
}
offset = (uint16_t) (anchor - obase - tab_pair[hval]);
} else {
same = false;
update_pair[i] = (uint32_t) (anchor + 1 + pair_start - obase);     
hash_pair[i] = hval;
}
if (same) {
distance = (int32_t) (anchor + pair_start - ref);
} else {
distance = 0;
}
if ((distance != 0) && (distance < MAX_DISTANCE)) {     
literal = false;
uint8_t token = (uint8_t) ((17 << 3U) | i);
*op++ = token;
offset = (uint16_t) (anchor - obase - tab_pair[hval]);
memcpy(op, &offset, 2);
op += 2;
for (int l = 0; l < 8; l++) {
if ((l < i) || (l > i + 1)) {
memcpy(op, &buf_cell[l * cell_shape], cell_shape);
op += cell_shape;
}
}
goto match;
}
}
match:
if (literal) {
tab_cell[hash_cell] = (uint32_t) (anchor + 1 - obase);     
if (update_triple[0] != 0) {
for (int h = 0; h < 6; h++) {
tab_triple[hash_triple[h]] = update_triple[h];
}
}
if (update_pair[0] != 0) {
for (int h = 0; h < 7; h++) {
tab_pair[hash_pair[h]] = update_pair[h];
}
}
uint8_t token = 0;
*op++ = token;
memcpy(op, buf_cell, cell_size);
op += cell_size;
}
} else {             uint8_t token = (uint8_t) ((1U << 7U) | (1U << 6U));
*op++ = token;
uint16_t offset = (uint16_t) (anchor - obase - tab_cell[hash_cell]);
memcpy(op, &offset, 2);
op += 2;
}
}
if ((op - obase) > input_len) {
free(shape);
free(chunkshape);
free(blockshape);
free(bufarea);
BLOSC_TRACE_ERROR(""Compressed data is bigger than input!"");
return 0;
}
}
}
free(shape);
free(chunkshape);
free(blockshape);
free(bufarea);
return (int) (op - obase);
}","int ndlz8_compress(const uint8_t *VAR_0, int32_t VAR_1, uint8_t *VAR_2, int32_t VAR_3,
uint8_t VAR_4, blosc2_cparams *VAR_5) {
BLOSC_UNUSED_PARAM(VAR_4);
uint8_t *VAR_6;
int32_t VAR_7;
if (blosc2_meta_get(VAR_5->schunk, ""b2nd"", &VAR_6, &VAR_7) < 0) {
BLOSC_TRACE_ERROR(""b2nd layer not found!"");
return VAR_8;
}
const int VAR_9 = 8;
const int VAR_10 = 64;
int8_t VAR_11;
int64_t *VAR_12 = malloc(8 * sizeof(int64_t));
int32_t *VAR_13 = malloc(8 * sizeof(int32_t));
int32_t *VAR_14 = malloc(8 * sizeof(int32_t));
deserialize_meta(VAR_6, VAR_7, &VAR_11, VAR_12, VAR_13, VAR_14);
free(VAR_6);
if (VAR_11 != 2) {
BLOSC_TRACE_ERROR(""This codec only works for ndim = 2"");
return VAR_8;
}
if (VAR_1 != (VAR_14[0] * VAR_14[1])) {
BLOSC_TRACE_ERROR(""Length not equal to blocksize"");
return VAR_8;
}
if (NDLZ_UNEXPECT_CONDITIONAL(VAR_3 < (int) (1 + VAR_11 * sizeof(int32_t)))) {
BLOSC_TRACE_ERROR(""Output too small"");
return VAR_8;
}
uint8_t *VAR_15 = (uint8_t *) VAR_0;
uint8_t *VAR_16 = (uint8_t *) VAR_2;
uint8_t *VAR_17;
uint32_t VAR_18, VAR_19;
uint32_t VAR_20[6] = {0};
uint32_t VAR_21[7] = {0};
uint8_t *VAR_22 = malloc(VAR_10);
uint8_t *VAR_23 = VAR_22;
uint8_t *VAR_24;
uint32_t VAR_25[1U << 12U] = {0};
uint32_t VAR_26[1U << 12U] = {0};
uint32_t VAR_27[1U << 12U] = {0};
uint32_t VAR_28[6] = {0};
uint32_t VAR_29[7] = {0};
VAR_17 = VAR_16 + VAR_3;
for (unsigned VAR_30 = 0; VAR_30 < (1U << 12U); VAR_30++) {
VAR_25[VAR_30] = 0;
VAR_26[VAR_30] = 0;
VAR_27[VAR_30] = 0;
}
int VAR_31 = 17 + (VAR_14[0] * VAR_14[1] / VAR_10 - 1) * 2;
if (VAR_1 < VAR_10 || VAR_3 < VAR_31) {
BLOSC_TRACE_ERROR(""Incorrect length or maxout"");
return 0;
}
uint8_t *VAR_32 = VAR_16;
*VAR_16++ = VAR_11;
memcpy(VAR_16, &VAR_14[0], 4);
VAR_16 += 4;
memcpy(VAR_16, &VAR_14[1], 4);
VAR_16 += 4;
uint32_t VAR_33[2];
for (int VAR_30 = 0; VAR_30 < 2; ++VAR_30) {
VAR_33[VAR_30] = (VAR_14[VAR_30] + VAR_9 - 1) / VAR_9;
}
uint32_t VAR_34[2];
uint32_t VAR_35[2];
for (VAR_35[0] = 0; VAR_35[0] < VAR_33[0]; ++VAR_35[0]) {
for (VAR_35[1] = 0; VAR_35[1] < VAR_33[1]; ++VAR_35[1]) {      
for (int VAR_36 = 0; VAR_36 < 7; VAR_36++) {         
VAR_29[VAR_36] = 0;
if (VAR_36 != 6) {
VAR_28[VAR_36] = 0;
}
}
if (NDLZ_UNEXPECT_CONDITIONAL(VAR_16 + VAR_10 + 1 > VAR_17)) {
free(VAR_12);
free(VAR_13);
free(VAR_14);
free(VAR_22);
return 0;
}
uint32_t VAR_37 = VAR_35[0] * VAR_9 * VAR_14[1] + VAR_35[1] * VAR_9;
if (((VAR_14[0] % VAR_9 != 0) && (VAR_35[0] == VAR_33[0] - 1)) ||
((VAR_14[1] % VAR_9 != 0) && (VAR_35[1] == VAR_33[1] - 1))) {
uint8_t VAR_38 = 0;                                   
*VAR_16++ = VAR_38;
if (VAR_35[0] == VAR_33[0] - 1) {
VAR_34[0] = (VAR_14[0] % VAR_9 == 0) ? VAR_9 : VAR_14[0] % VAR_9;
} else {
VAR_34[0] = VAR_9;
}
if (VAR_35[1] == VAR_33[1] - 1) {
VAR_34[1] = (VAR_14[1] % VAR_9 == 0) ? VAR_9 : VAR_14[1] % VAR_9;
} else {
VAR_34[1] = VAR_9;
}
for (uint32_t VAR_30 = 0; VAR_30 < VAR_34[0]; VAR_30++) {
memcpy(VAR_16, &VAR_15[VAR_37 + VAR_30 * VAR_14[1]], VAR_34[1]);
VAR_16 += VAR_34[1];
}
} else {
for (uint64_t VAR_30 = 0; VAR_30 < (uint64_t) VAR_9; VAR_30++) {           
uint64_t VAR_39 = VAR_37 + VAR_30 * VAR_14[1];
memcpy(VAR_23, &VAR_15[VAR_39], VAR_9);
VAR_23 += VAR_9;
}
VAR_23 -= VAR_10;
const uint8_t *VAR_40;
uint32_t VAR_41;
uint8_t *VAR_42 = VAR_16;    
VAR_19 = XXH32(VAR_23, VAR_10, 1);        
VAR_19 >>= 32U - 12U;
VAR_40 = VAR_32 + VAR_25[VAR_19];
if (VAR_25[VAR_19] == 0) {
VAR_41 = 0;
} else {
bool VAR_43 = true;
VAR_24 = VAR_32 + VAR_25[VAR_19];
for (int VAR_30 = 0; VAR_30 < VAR_10; VAR_30++) {
if (VAR_23[VAR_30] != VAR_24[VAR_30]) {
VAR_43 = false;
break;
}
}
if (VAR_43) {
VAR_41 = (int32_t) (VAR_42 - VAR_40);
} else {
VAR_41 = 0;
}
}
bool VAR_44 = true;
for (int VAR_30 = 1; VAR_30 < VAR_10; VAR_30++) {
if (VAR_23[VAR_30] != VAR_23[0]) {
VAR_44 = false;
break;
}
}
if (VAR_44) {                              
uint8_t VAR_38 = (uint8_t) (1U << 6U);
*VAR_16++ = VAR_38;
*VAR_16++ = VAR_23[0];
} else if (VAR_41 == 0 || (VAR_41 >= VAR_45)) {   
bool VAR_46 = true;
for (int VAR_30 = 0; VAR_30 < 6; VAR_30++) {
int VAR_47 = VAR_30 * VAR_9;
VAR_18 = XXH32(&VAR_23[VAR_47], 24, 1);        
VAR_18 >>= 32U - 12U;
bool VAR_43 = true;
uint16_t VAR_48;
if (VAR_26[VAR_18] != 0) {
VAR_24 = VAR_32 + VAR_26[VAR_18];
for (int VAR_49 = 0; VAR_49 < 24; VAR_49++) {
if (VAR_23[VAR_47 + VAR_49] != VAR_24[VAR_49]) {
VAR_43 = false;
break;
}
}
VAR_48 = (uint16_t) (VAR_42 - VAR_32 - VAR_26[VAR_18]);
} else {
VAR_43 = false;
VAR_28[VAR_30] = (uint32_t) (VAR_42 + 1 + VAR_47 - VAR_32);     
VAR_20[VAR_30] = VAR_18;
}
VAR_40 = VAR_32 + VAR_26[VAR_18];
if (VAR_43) {
VAR_41 = (int32_t) (VAR_42 + VAR_47 - VAR_40);
} else {
VAR_41 = 0;
}
if ((VAR_41 != 0) && (VAR_41 < VAR_45)) {     
VAR_46 = false;
uint8_t VAR_38 = (uint8_t) ((21 << 3U) | VAR_30);
*VAR_16++ = VAR_38;
memcpy(VAR_16, &VAR_48, 2);
VAR_16 += 2;
for (int VAR_49 = 0; VAR_49 < 8; VAR_49++) {
if ((VAR_49 < VAR_30) || (VAR_49 > VAR_30 + 2)) {
memcpy(VAR_16, &VAR_23[VAR_49 * VAR_9], VAR_9);
VAR_16 += VAR_9;
}
}
goto match;
}
}
for (int VAR_30 = 0; VAR_30 < 7; VAR_30++) {
int VAR_50 = VAR_30 * VAR_9;
VAR_18 = XXH32(&VAR_23[VAR_50], 16, 1);        
VAR_18 >>= 32U - 12U;
VAR_40 = VAR_32 + VAR_27[VAR_18];
bool VAR_43 = true;
uint16_t VAR_48;
if (VAR_27[VAR_18] != 0) {
VAR_24 = VAR_32 + VAR_27[VAR_18];
for (int VAR_51 = 0; VAR_51 < 16; VAR_51++) {
if (VAR_23[VAR_50 + VAR_51] != VAR_24[VAR_51]) {
VAR_43 = false;
break;
}
}
VAR_48 = (uint16_t) (VAR_42 - VAR_32 - VAR_27[VAR_18]);
} else {
VAR_43 = false;
VAR_29[VAR_30] = (uint32_t) (VAR_42 + 1 + VAR_50 - VAR_32);     
VAR_21[VAR_30] = VAR_18;
}
if (VAR_43) {
VAR_41 = (int32_t) (VAR_42 + VAR_50 - VAR_40);
} else {
VAR_41 = 0;
}
if ((VAR_41 != 0) && (VAR_41 < VAR_45)) {     
VAR_46 = false;
uint8_t VAR_38 = (uint8_t) ((17 << 3U) | VAR_30);
*VAR_16++ = VAR_38;
VAR_48 = (uint16_t) (VAR_42 - VAR_32 - VAR_27[VAR_18]);
memcpy(VAR_16, &VAR_48, 2);
VAR_16 += 2;
for (int VAR_49 = 0; VAR_49 < 8; VAR_49++) {
if ((VAR_49 < VAR_30) || (VAR_49 > VAR_30 + 1)) {
memcpy(VAR_16, &VAR_23[VAR_49 * VAR_9], VAR_9);
VAR_16 += VAR_9;
}
}
goto match;
}
}
match:
if (VAR_46) {
VAR_25[VAR_19] = (uint32_t) (VAR_42 + 1 - VAR_32);     
if (VAR_28[0] != 0) {
for (int VAR_36 = 0; VAR_36 < 6; VAR_36++) {
VAR_26[VAR_20[VAR_36]] = VAR_28[VAR_36];
}
}
if (VAR_29[0] != 0) {
for (int VAR_36 = 0; VAR_36 < 7; VAR_36++) {
VAR_27[VAR_21[VAR_36]] = VAR_29[VAR_36];
}
}
uint8_t VAR_38 = 0;
*VAR_16++ = VAR_38;
memcpy(VAR_16, VAR_23, VAR_10);
VAR_16 += VAR_10;
}
} else {   
uint8_t VAR_38 = (uint8_t) ((1U << 7U) | (1U << 6U));
*VAR_16++ = VAR_38;
uint16_t VAR_48 = (uint16_t) (VAR_42 - VAR_32 - VAR_25[VAR_19]);
memcpy(VAR_16, &VAR_48, 2);
VAR_16 += 2;
}
}
if ((VAR_16 - VAR_32) > VAR_1) {
free(VAR_12);
free(VAR_13);
free(VAR_14);
free(VAR_22);
BLOSC_TRACE_ERROR(""Compressed data is bigger than input!"");
return 0;
}
}
}
free(VAR_12);
free(VAR_13);
free(VAR_14);
free(VAR_22);
return (int) (VAR_16 - VAR_32);
}",Blosc/c-blosc2/d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3/ndlz8x8.c/vul/before/1.json,"int ndlz8_compress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,
                   uint8_t meta, blosc2_cparams *cparams) {
  BLOSC_UNUSED_PARAM(meta);
  BLOSC_ERROR_NULL(cparams, BLOSC2_ERROR_NULL_POINTER);
  BLOSC_ERROR_NULL(cparams->schunk, BLOSC2_ERROR_NULL_POINTER);
  uint8_t *smeta;
  int32_t smeta_len;

  if (blosc2_meta_get(cparams->schunk, ""b2nd"", &smeta, &smeta_len) < 0) {
    BLOSC_TRACE_ERROR(""b2nd layer not found!"");
    return BLOSC2_ERROR_FAILURE;
  }

  const int cell_shape = 8;
  const int cell_size = 64;
  int8_t ndim;
  int64_t *shape = malloc(8 * sizeof(int64_t));
  int32_t *chunkshape = malloc(8 * sizeof(int32_t));
  int32_t *blockshape = malloc(8 * sizeof(int32_t));
  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);
  free(smeta);

  if (ndim != 2) {
    BLOSC_TRACE_ERROR(""This codec only works for ndim = 2"");
    return BLOSC2_ERROR_FAILURE;
  }

  if (input_len != (blockshape[0] * blockshape[1])) {
    BLOSC_TRACE_ERROR(""Length not equal to blocksize"");
    return BLOSC2_ERROR_FAILURE;
  }

  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < (int) (1 + ndim * sizeof(int32_t)))) {
    BLOSC_TRACE_ERROR(""Output too small"");
    return BLOSC2_ERROR_FAILURE;
  }

  uint8_t *ip = (uint8_t *) input;
  uint8_t *op = (uint8_t *) output;
  uint8_t *op_limit;
  uint32_t hval, hash_cell;
  uint32_t hash_triple[6] = {0};
  uint32_t hash_pair[7] = {0};
  uint8_t *bufarea = malloc(cell_size);
  uint8_t *buf_cell = bufarea;
  uint8_t *buf_aux;
  uint32_t tab_cell[1U << 12U] = {0};
  uint32_t tab_triple[1U << 12U] = {0};
  uint32_t tab_pair[1U << 12U] = {0};
  uint32_t update_triple[6] = {0};
  uint32_t update_pair[7] = {0};

  // Minimum cratios before issuing and _early giveup_
  // Remind that ndlz is not meant for cratios <= 2 (too costly to decompress)

  op_limit = op + output_len;

  // Initialize the hash table to distances of 0
  for (unsigned i = 0; i < (1U << 12U); i++) {
    tab_cell[i] = 0;
    tab_triple[i] = 0;
    tab_pair[i] = 0;
  }

  /* input and output buffer cannot be less than 64 (cells are 8x8) */
  int overhead = 17 + (blockshape[0] * blockshape[1] / cell_size - 1) * 2;
  if (input_len < cell_size || output_len < overhead) {
    BLOSC_TRACE_ERROR(""Incorrect length or maxout"");
    return 0;
  }

  uint8_t *obase = op;

  /* we start with literal copy */
  *op++ = ndim;
  memcpy(op, &blockshape[0], 4);
  op += 4;
  memcpy(op, &blockshape[1], 4);
  op += 4;

  uint32_t i_stop[2];
  for (int i = 0; i < 2; ++i) {
    i_stop[i] = (blockshape[i] + cell_shape - 1) / cell_shape;
  }


  /* main loop */
  uint32_t padding[2];
  uint32_t ii[2];
  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {
    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell
      for (int h = 0; h < 7; h++) {         // new cell -> new possible references
        update_pair[h] = 0;
        if (h != 6) {
          update_triple[h] = 0;
        }
      }

      if (NDLZ_UNEXPECT_CONDITIONAL(op + cell_size + 1 > op_limit)) {
        free(shape);
        free(chunkshape);
        free(blockshape);
        free(bufarea);
        return 0;
      }

      uint32_t orig = ii[0] * cell_shape * blockshape[1] + ii[1] * cell_shape;
      if (((blockshape[0] % cell_shape != 0) && (ii[0] == i_stop[0] - 1)) ||
          ((blockshape[1] % cell_shape != 0) && (ii[1] == i_stop[1] - 1))) {
        uint8_t token = 0;                                   // padding -> literal copy
        *op++ = token;
        if (ii[0] == i_stop[0] - 1) {
          padding[0] = (blockshape[0] % cell_shape == 0) ? cell_shape : blockshape[0] % cell_shape;
        } else {
          padding[0] = cell_shape;
        }
        if (ii[1] == i_stop[1] - 1) {
          padding[1] = (blockshape[1] % cell_shape == 0) ? cell_shape : blockshape[1] % cell_shape;
        } else {
          padding[1] = cell_shape;
        }
        for (uint32_t i = 0; i < padding[0]; i++) {
          memcpy(op, &ip[orig + i * blockshape[1]], padding[1]);
          op += padding[1];
        }
      } else {
        for (uint64_t i = 0; i < (uint64_t) cell_shape; i++) {           // fill cell buffer
          uint64_t ind = orig + i * blockshape[1];
          memcpy(buf_cell, &ip[ind], cell_shape);
          buf_cell += cell_shape;
        }
        buf_cell -= cell_size;

        const uint8_t *ref;
        uint32_t distance;
        uint8_t *anchor = op;    /* comparison starting-point */

        /* find potential match */
        hash_cell = XXH32(buf_cell, cell_size, 1);        // calculate cell hash
        hash_cell >>= 32U - 12U;
        ref = obase + tab_cell[hash_cell];

        /* calculate distance to the match */
        if (tab_cell[hash_cell] == 0) {
          distance = 0;
        } else {
          bool same = true;
          buf_aux = obase + tab_cell[hash_cell];
          for (int i = 0; i < cell_size; i++) {
            if (buf_cell[i] != buf_aux[i]) {
              same = false;
              break;
            }
          }
          if (same) {
            distance = (int32_t) (anchor - ref);
          } else {
            distance = 0;
          }
        }

        bool alleq = true;
        for (int i = 1; i < cell_size; i++) {
          if (buf_cell[i] != buf_cell[0]) {
            alleq = false;
            break;
          }
        }
        if (alleq) {                              // all elements of the cell equal
          uint8_t token = (uint8_t) (1U << 6U);
          *op++ = token;
          *op++ = buf_cell[0];

        } else if (distance == 0 || (distance >= MAX_DISTANCE)) {   // no cell match
          bool literal = true;

          // rows triples matches
          for (int i = 0; i < 6; i++) {
            int triple_start = i * cell_shape;
            hval = XXH32(&buf_cell[triple_start], 24, 1);        // calculate triple hash
            hval >>= 32U - 12U;
            /* calculate distance to the match */
            bool same = true;
            uint16_t offset;
            if (tab_triple[hval] != 0) {
              buf_aux = obase + tab_triple[hval];
              for (int l = 0; l < 24; l++) {
                if (buf_cell[triple_start + l] != buf_aux[l]) {
                  same = false;
                  break;
                }
              }
              offset = (uint16_t) (anchor - obase - tab_triple[hval]);
            } else {
              same = false;
              update_triple[i] = (uint32_t) (anchor + 1 + triple_start - obase);     /* update hash table */
              hash_triple[i] = hval;
            }
            ref = obase + tab_triple[hval];
            if (same) {
              distance = (int32_t) (anchor + triple_start - ref);
            } else {
              distance = 0;
            }
            if ((distance != 0) && (distance < MAX_DISTANCE)) {     // 3 rows match
              literal = false;
              uint8_t token = (uint8_t) ((21 << 3U) | i);
              *op++ = token;
              memcpy(op, &offset, 2);
              op += 2;
              for (int l = 0; l < 8; l++) {
                if ((l < i) || (l > i + 2)) {
                  memcpy(op, &buf_cell[l * cell_shape], cell_shape);
                  op += cell_shape;
                }
              }
              goto match;
            }
          }

          // rows pairs matches
          for (int i = 0; i < 7; i++) {
            int pair_start = i * cell_shape;
            hval = XXH32(&buf_cell[pair_start], 16, 1);        // calculate rows pair hash
            hval >>= 32U - 12U;
            ref = obase + tab_pair[hval];
            /* calculate distance to the match */
            bool same = true;
            uint16_t offset;
            if (tab_pair[hval] != 0) {
              buf_aux = obase + tab_pair[hval];
              for (int k = 0; k < 16; k++) {
                if (buf_cell[pair_start + k] != buf_aux[k]) {
                  same = false;
                  break;
                }
              }
              offset = (uint16_t) (anchor - obase - tab_pair[hval]);
            } else {
              same = false;
              update_pair[i] = (uint32_t) (anchor + 1 + pair_start - obase);     /* update hash table */
              hash_pair[i] = hval;
            }
            if (same) {
              distance = (int32_t) (anchor + pair_start - ref);
            } else {
              distance = 0;
            }
            if ((distance != 0) && (distance < MAX_DISTANCE)) {     /* 1 rows pair match */
              literal = false;
              uint8_t token = (uint8_t) ((17 << 3U) | i);
              *op++ = token;
              offset = (uint16_t) (anchor - obase - tab_pair[hval]);
              memcpy(op, &offset, 2);
              op += 2;
              for (int l = 0; l < 8; l++) {
                if ((l < i) || (l > i + 1)) {
                  memcpy(op, &buf_cell[l * cell_shape], cell_shape);
                  op += cell_shape;
                }
              }
              goto match;
            }
          }

          match:
          if (literal) {
            tab_cell[hash_cell] = (uint32_t) (anchor + 1 - obase);     /* update hash tables */

            if (update_triple[0] != 0) {
              for (int h = 0; h < 6; h++) {
                tab_triple[hash_triple[h]] = update_triple[h];
              }
            }
            if (update_pair[0] != 0) {
              for (int h = 0; h < 7; h++) {
                tab_pair[hash_pair[h]] = update_pair[h];
              }
            }
            uint8_t token = 0;
            *op++ = token;
            memcpy(op, buf_cell, cell_size);
            op += cell_size;

          }

        } else {   // cell match
          uint8_t token = (uint8_t) ((1U << 7U) | (1U << 6U));
          *op++ = token;
          uint16_t offset = (uint16_t) (anchor - obase - tab_cell[hash_cell]);
          memcpy(op, &offset, 2);
          op += 2;

        }

      }
      if ((op - obase) > input_len) {
        free(shape);
        free(chunkshape);
        free(blockshape);
        free(bufarea);
        BLOSC_TRACE_ERROR(""Compressed data is bigger than input!"");
        return 0;
      }
    }
  }

  free(shape);
  free(chunkshape);
  free(blockshape);
  free(bufarea);

  return (int) (op - obase);
}","int ndlz8_compress(const uint8_t *VAR_0, int32_t VAR_1, uint8_t *VAR_2, int32_t VAR_3,
                   uint8_t VAR_4, blosc2_cparams *VAR_5) {
  BLOSC_UNUSED_PARAM(VAR_4);
  BLOSC_ERROR_NULL(VAR_5, VAR_6);
  BLOSC_ERROR_NULL(VAR_5->schunk, VAR_6);
  uint8_t *VAR_7;
  int32_t VAR_8;

  if (blosc2_meta_get(VAR_5->schunk, ""b2nd"", &VAR_7, &VAR_8) < 0) {
    BLOSC_TRACE_ERROR(""b2nd layer not found!"");
    return VAR_9;
  }

  const int VAR_10 = 8;
  const int VAR_11 = 64;
  int8_t VAR_12;
  int64_t *VAR_13 = malloc(8 * sizeof(int64_t));
  int32_t *VAR_14 = malloc(8 * sizeof(int32_t));
  int32_t *VAR_15 = malloc(8 * sizeof(int32_t));
  deserialize_meta(VAR_7, VAR_8, &VAR_12, VAR_13, VAR_14, VAR_15);
  free(VAR_7);

  if (VAR_12 != 2) {
    BLOSC_TRACE_ERROR(""This codec only works for ndim = 2"");
    return VAR_9;
  }

  if (VAR_1 != (VAR_15[0] * VAR_15[1])) {
    BLOSC_TRACE_ERROR(""Length not equal to blocksize"");
    return VAR_9;
  }

  if (NDLZ_UNEXPECT_CONDITIONAL(VAR_3 < (int) (1 + VAR_12 * sizeof(int32_t)))) {
    BLOSC_TRACE_ERROR(""Output too small"");
    return VAR_9;
  }

  uint8_t *VAR_16 = (uint8_t *) VAR_0;
  uint8_t *VAR_17 = (uint8_t *) VAR_2;
  uint8_t *VAR_18;
  uint32_t VAR_19, VAR_20;
  uint32_t VAR_21[6] = {0};
  uint32_t VAR_22[7] = {0};
  uint8_t *VAR_23 = malloc(VAR_11);
  uint8_t *VAR_24 = VAR_23;
  uint8_t *VAR_25;
  uint32_t VAR_26[1U << 12U] = {0};
  uint32_t VAR_27[1U << 12U] = {0};
  uint32_t VAR_28[1U << 12U] = {0};
  uint32_t VAR_29[6] = {0};
  uint32_t VAR_30[7] = {0};

  /* COMMENT_0 */
  /* COMMENT_1 */

  VAR_18 = VAR_17 + VAR_3;

  /* COMMENT_2 */
  for (unsigned VAR_31 = 0; VAR_31 < (1U << 12U); VAR_31++) {
    VAR_26[VAR_31] = 0;
    VAR_27[VAR_31] = 0;
    VAR_28[VAR_31] = 0;
  }

  /* COMMENT_3 */
  int VAR_32 = 17 + (VAR_15[0] * VAR_15[1] / VAR_11 - 1) * 2;
  if (VAR_1 < VAR_11 || VAR_3 < VAR_32) {
    BLOSC_TRACE_ERROR(""Incorrect length or maxout"");
    return 0;
  }

  uint8_t *VAR_33 = VAR_17;

  /* COMMENT_4 */
  *VAR_17++ = VAR_12;
  memcpy(VAR_17, &VAR_15[0], 4);
  VAR_17 += 4;
  memcpy(VAR_17, &VAR_15[1], 4);
  VAR_17 += 4;

  uint32_t VAR_34[2];
  for (int VAR_31 = 0; VAR_31 < 2; ++VAR_31) {
    VAR_34[VAR_31] = (VAR_15[VAR_31] + VAR_10 - 1) / VAR_10;
  }


  /* COMMENT_5 */
  uint32_t VAR_35[2];
  uint32_t VAR_36[2];
  for (VAR_36[0] = 0; VAR_36[0] < VAR_34[0]; ++VAR_36[0]) {
    for (VAR_36[1] = 0; VAR_36[1] < VAR_34[1]; ++VAR_36[1]) {      /* COMMENT_6 */
      for (int VAR_37 = 0; VAR_37 < 7; VAR_37++) {         /* COMMENT_7 */
        VAR_30[VAR_37] = 0;
        if (VAR_37 != 6) {
          VAR_29[VAR_37] = 0;
        }
      }

      if (NDLZ_UNEXPECT_CONDITIONAL(VAR_17 + VAR_11 + 1 > VAR_18)) {
        free(VAR_13);
        free(VAR_14);
        free(VAR_15);
        free(VAR_23);
        return 0;
      }

      uint32_t VAR_38 = VAR_36[0] * VAR_10 * VAR_15[1] + VAR_36[1] * VAR_10;
      if (((VAR_15[0] % VAR_10 != 0) && (VAR_36[0] == VAR_34[0] - 1)) ||
          ((VAR_15[1] % VAR_10 != 0) && (VAR_36[1] == VAR_34[1] - 1))) {
        uint8_t VAR_39 = 0;                                   /* COMMENT_8 */
        *VAR_17++ = VAR_39;
        if (VAR_36[0] == VAR_34[0] - 1) {
          VAR_35[0] = (VAR_15[0] % VAR_10 == 0) ? VAR_10 : VAR_15[0] % VAR_10;
        } else {
          VAR_35[0] = VAR_10;
        }
        if (VAR_36[1] == VAR_34[1] - 1) {
          VAR_35[1] = (VAR_15[1] % VAR_10 == 0) ? VAR_10 : VAR_15[1] % VAR_10;
        } else {
          VAR_35[1] = VAR_10;
        }
        for (uint32_t VAR_31 = 0; VAR_31 < VAR_35[0]; VAR_31++) {
          memcpy(VAR_17, &VAR_16[VAR_38 + VAR_31 * VAR_15[1]], VAR_35[1]);
          VAR_17 += VAR_35[1];
        }
      } else {
        for (uint64_t VAR_31 = 0; VAR_31 < (uint64_t) VAR_10; VAR_31++) {           /* COMMENT_9 */
          uint64_t VAR_40 = VAR_38 + VAR_31 * VAR_15[1];
          memcpy(VAR_24, &VAR_16[VAR_40], VAR_10);
          VAR_24 += VAR_10;
        }
        VAR_24 -= VAR_11;

        const uint8_t *VAR_41;
        uint32_t VAR_42;
        uint8_t *VAR_43 = VAR_17;    /* COMMENT_10 */

        /* COMMENT_11 */
        VAR_20 = XXH32(VAR_24, VAR_11, 1);        /* COMMENT_12 */
        VAR_20 >>= 32U - 12U;
        VAR_41 = VAR_33 + VAR_26[VAR_20];

        /* COMMENT_13 */
        if (VAR_26[VAR_20] == 0) {
          VAR_42 = 0;
        } else {
          bool VAR_44 = true;
          VAR_25 = VAR_33 + VAR_26[VAR_20];
          for (int VAR_31 = 0; VAR_31 < VAR_11; VAR_31++) {
            if (VAR_24[VAR_31] != VAR_25[VAR_31]) {
              VAR_44 = false;
              break;
            }
          }
          if (VAR_44) {
            VAR_42 = (int32_t) (VAR_43 - VAR_41);
          } else {
            VAR_42 = 0;
          }
        }

        bool VAR_45 = true;
        for (int VAR_31 = 1; VAR_31 < VAR_11; VAR_31++) {
          if (VAR_24[VAR_31] != VAR_24[0]) {
            VAR_45 = false;
            break;
          }
        }
        if (VAR_45) {                              /* COMMENT_14 */
          uint8_t VAR_39 = (uint8_t) (1U << 6U);
          *VAR_17++ = VAR_39;
          *VAR_17++ = VAR_24[0];

        } else if (VAR_42 == 0 || (VAR_42 >= VAR_46)) {   /* COMMENT_15 */
          bool VAR_47 = true;

          /* COMMENT_16 */
          for (int VAR_31 = 0; VAR_31 < 6; VAR_31++) {
            int VAR_48 = VAR_31 * VAR_10;
            VAR_19 = XXH32(&VAR_24[VAR_48], 24, 1);        /* COMMENT_17 */
            VAR_19 >>= 32U - 12U;
            /* COMMENT_13 */
            bool VAR_44 = true;
            uint16_t VAR_49;
            if (VAR_27[VAR_19] != 0) {
              VAR_25 = VAR_33 + VAR_27[VAR_19];
              for (int VAR_50 = 0; VAR_50 < 24; VAR_50++) {
                if (VAR_24[VAR_48 + VAR_50] != VAR_25[VAR_50]) {
                  VAR_44 = false;
                  break;
                }
              }
              VAR_49 = (uint16_t) (VAR_43 - VAR_33 - VAR_27[VAR_19]);
            } else {
              VAR_44 = false;
              VAR_29[VAR_31] = (uint32_t) (VAR_43 + 1 + VAR_48 - VAR_33);     /* COMMENT_18 */
              VAR_21[VAR_31] = VAR_19;
            }
            VAR_41 = VAR_33 + VAR_27[VAR_19];
            if (VAR_44) {
              VAR_42 = (int32_t) (VAR_43 + VAR_48 - VAR_41);
            } else {
              VAR_42 = 0;
            }
            if ((VAR_42 != 0) && (VAR_42 < VAR_46)) {     /* COMMENT_19 */
              VAR_47 = false;
              uint8_t VAR_39 = (uint8_t) ((21 << 3U) | VAR_31);
              *VAR_17++ = VAR_39;
              memcpy(VAR_17, &VAR_49, 2);
              VAR_17 += 2;
              for (int VAR_50 = 0; VAR_50 < 8; VAR_50++) {
                if ((VAR_50 < VAR_31) || (VAR_50 > VAR_31 + 2)) {
                  memcpy(VAR_17, &VAR_24[VAR_50 * VAR_10], VAR_10);
                  VAR_17 += VAR_10;
                }
              }
              goto match;
            }
          }

          /* COMMENT_20 */
          for (int VAR_31 = 0; VAR_31 < 7; VAR_31++) {
            int VAR_51 = VAR_31 * VAR_10;
            VAR_19 = XXH32(&VAR_24[VAR_51], 16, 1);        /* COMMENT_21 */
            VAR_19 >>= 32U - 12U;
            VAR_41 = VAR_33 + VAR_28[VAR_19];
            /* COMMENT_13 */
            bool VAR_44 = true;
            uint16_t VAR_49;
            if (VAR_28[VAR_19] != 0) {
              VAR_25 = VAR_33 + VAR_28[VAR_19];
              for (int VAR_52 = 0; VAR_52 < 16; VAR_52++) {
                if (VAR_24[VAR_51 + VAR_52] != VAR_25[VAR_52]) {
                  VAR_44 = false;
                  break;
                }
              }
              VAR_49 = (uint16_t) (VAR_43 - VAR_33 - VAR_28[VAR_19]);
            } else {
              VAR_44 = false;
              VAR_30[VAR_31] = (uint32_t) (VAR_43 + 1 + VAR_51 - VAR_33);     /* COMMENT_18 */
              VAR_22[VAR_31] = VAR_19;
            }
            if (VAR_44) {
              VAR_42 = (int32_t) (VAR_43 + VAR_51 - VAR_41);
            } else {
              VAR_42 = 0;
            }
            if ((VAR_42 != 0) && (VAR_42 < VAR_46)) {     /* COMMENT_22 */
              VAR_47 = false;
              uint8_t VAR_39 = (uint8_t) ((17 << 3U) | VAR_31);
              *VAR_17++ = VAR_39;
              VAR_49 = (uint16_t) (VAR_43 - VAR_33 - VAR_28[VAR_19]);
              memcpy(VAR_17, &VAR_49, 2);
              VAR_17 += 2;
              for (int VAR_50 = 0; VAR_50 < 8; VAR_50++) {
                if ((VAR_50 < VAR_31) || (VAR_50 > VAR_31 + 1)) {
                  memcpy(VAR_17, &VAR_24[VAR_50 * VAR_10], VAR_10);
                  VAR_17 += VAR_10;
                }
              }
              goto match;
            }
          }

          match:
          if (VAR_47) {
            VAR_26[VAR_20] = (uint32_t) (VAR_43 + 1 - VAR_33);     /* COMMENT_23 */

            if (VAR_29[0] != 0) {
              for (int VAR_37 = 0; VAR_37 < 6; VAR_37++) {
                VAR_27[VAR_21[VAR_37]] = VAR_29[VAR_37];
              }
            }
            if (VAR_30[0] != 0) {
              for (int VAR_37 = 0; VAR_37 < 7; VAR_37++) {
                VAR_28[VAR_22[VAR_37]] = VAR_30[VAR_37];
              }
            }
            uint8_t VAR_39 = 0;
            *VAR_17++ = VAR_39;
            memcpy(VAR_17, VAR_24, VAR_11);
            VAR_17 += VAR_11;

          }

        } else {   /* COMMENT_24 */
          uint8_t VAR_39 = (uint8_t) ((1U << 7U) | (1U << 6U));
          *VAR_17++ = VAR_39;
          uint16_t VAR_49 = (uint16_t) (VAR_43 - VAR_33 - VAR_26[VAR_20]);
          memcpy(VAR_17, &VAR_49, 2);
          VAR_17 += 2;

        }

      }
      if ((VAR_17 - VAR_33) > VAR_1) {
        free(VAR_13);
        free(VAR_14);
        free(VAR_15);
        free(VAR_23);
        BLOSC_TRACE_ERROR(""Compressed data is bigger than input!"");
        return 0;
      }
    }
  }

  free(VAR_13);
  free(VAR_14);
  free(VAR_15);
  free(VAR_23);

  return (int) (VAR_17 - VAR_33);
}",Blosc/c-blosc2/d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3/ndlz8x8.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,6 +1,8 @@
 int ndlz8_compress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,
                    uint8_t meta, blosc2_cparams *cparams) {
   BLOSC_UNUSED_PARAM(meta);
+  BLOSC_ERROR_NULL(cparams, BLOSC2_ERROR_NULL_POINTER);
+  BLOSC_ERROR_NULL(cparams->schunk, BLOSC2_ERROR_NULL_POINTER);
   uint8_t *smeta;
   int32_t smeta_len;
 ","{'deleted_lines': [], 'added_lines': ['  BLOSC_ERROR_NULL(cparams, BLOSC2_ERROR_NULL_POINTER);', '  BLOSC_ERROR_NULL(cparams->schunk, BLOSC2_ERROR_NULL_POINTER);']}",True,C-blosc2 before 2.9.3 was discovered to contain a NULL pointer dereference in ndlz/ndlz8x8.c via a NULL pointer to memset.,7.5,HIGH,2,test,2023-06-21T09:17:51Z,4
CVE-2023-37174,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,gpac,fixed #2505,549ff4484246f2bc4d5fec6760332b43774db483,https://github.com/gpac/gpac/commit/549ff4484246f2bc4d5fec6760332b43774db483,src/laser/lsr_dec.c,lsr_read_update_value_indexed,"static void *lsr_read_update_value_indexed(GF_LASeRCodec *lsr, GF_Node*node, u32 fieldType, void *rep_val, u32 idx, Bool is_insert, Bool is_com, u32 *single_field_type)
{
Fixed *f_val;
SVG_Number num;
switch (fieldType) {
case SVG_Points_datatype:
{
SVG_Point *pt;
ListOfXXX *res;
GF_SAFEALLOC(res, ListOfXXX);
if (!res) {
lsr->last_error = GF_OUT_OF_MEM;
return NULL;
}
*res = gf_list_new();
pt = (SVG_Point*)gf_malloc(sizeof(SVG_Point));
if (!pt) {
lsr->last_error = GF_OUT_OF_MEM;
} else {
lsr_read_coordinate(lsr, &num, 0, ""coordX"");
pt->x = num.value;
lsr_read_coordinate(lsr, &num, 0, ""coordY"");
pt->y = num.value;
gf_list_add(*res, pt);
}
return res;
}
case SMIL_KeySplines_datatype:
{
ListOfXXX *res;
GF_SAFEALLOC(res, ListOfXXX);
if (!res) {
lsr->last_error = GF_OUT_OF_MEM;
return NULL;
}
*res = gf_list_new();
f_val = (Fixed*)gf_malloc(sizeof(Fixed));
if (!f_val) {
lsr->last_error = GF_OUT_OF_MEM;
} else {
*f_val = lsr_read_fixed_16_8(lsr, ""floatValue"");
gf_list_add(*res, f_val);
}
return res;
}
case SVG_StrokeDashArray_datatype:
case SVG_ViewBox_datatype:
f_val = (Fixed*)gf_malloc(sizeof(Fixed));
if (!f_val) {
lsr->last_error = GF_OUT_OF_MEM;
} else {
*f_val = lsr_read_fixed_16_8(lsr, ""floatValue"");
}
return f_val;
case SMIL_KeyTimes_datatype:
{
ListOfXXX *res;
GF_SAFEALLOC(res, ListOfXXX);
if (!res) {
lsr->last_error = GF_OUT_OF_MEM;
return NULL;
}
*res = gf_list_new();
f_val = lsr_read_fraction_12_item(lsr);
if (f_val) gf_list_add(*res, f_val);
return res;
}
case SMIL_KeyPoints_datatype:
{
ListOfXXX *res;
GF_SAFEALLOC(res, ListOfXXX);
if (!res) {
lsr->last_error = GF_OUT_OF_MEM;
return NULL;
}
*res = gf_list_new();
f_val = (Fixed*)gf_malloc(sizeof(Fixed));
if (!f_val) {
lsr->last_error = GF_OUT_OF_MEM;
} else {
*f_val = lsr_read_fixed_clamp(lsr, ""value"");
gf_list_add(*res, f_val);
}
return res;
}
case SMIL_Times_datatype:
{
ListOfXXX *res;
GF_SAFEALLOC(res, ListOfXXX);
if (!res) {
lsr->last_error = GF_OUT_OF_MEM;
return NULL;
}
*res = gf_list_new();
if (! *res) {
lsr->last_error = GF_OUT_OF_MEM;
} else {
gf_list_add(*res, lsr_read_smil_time(lsr, node) );
}
return res;
}
default:
lsr_read_extension(lsr, ""privateData"");
break;
}
return NULL;
}","static void *lsr_read_update_value_indexed(GF_LASeRCodec *VAR_0, GF_Node*VAR_1, u32 VAR_2, void *VAR_3, u32 VAR_4, Bool VAR_5, Bool VAR_6, u32 *VAR_7)
{
Fixed *VAR_8;
SVG_Number VAR_9;
switch (VAR_2) {
case VAR_10:
{
SVG_Point *VAR_11;
ListOfXXX *VAR_12;
GF_SAFEALLOC(VAR_12, ListOfXXX);
if (!VAR_12) {
VAR_0->last_error = VAR_13;
return NULL;
}
*VAR_12 = gf_list_new();
VAR_11 = (SVG_Point*)gf_malloc(sizeof(SVG_Point));
if (!VAR_11) {
VAR_0->last_error = VAR_13;
} else {
lsr_read_coordinate(VAR_0, &VAR_9, 0, ""coordX"");
VAR_11->x = VAR_9.value;
lsr_read_coordinate(VAR_0, &VAR_9, 0, ""coordY"");
VAR_11->y = VAR_9.value;
gf_list_add(*VAR_12, VAR_11);
}
return VAR_12;
}
case VAR_14:
{
ListOfXXX *VAR_12;
GF_SAFEALLOC(VAR_12, ListOfXXX);
if (!VAR_12) {
VAR_0->last_error = VAR_13;
return NULL;
}
*VAR_12 = gf_list_new();
VAR_8 = (Fixed*)gf_malloc(sizeof(Fixed));
if (!VAR_8) {
VAR_0->last_error = VAR_13;
} else {
*VAR_8 = lsr_read_fixed_16_8(VAR_0, ""floatValue"");
gf_list_add(*VAR_12, VAR_8);
}
return VAR_12;
}
case VAR_15:
case VAR_16:
VAR_8 = (Fixed*)gf_malloc(sizeof(Fixed));
if (!VAR_8) {
VAR_0->last_error = VAR_13;
} else {
*VAR_8 = lsr_read_fixed_16_8(VAR_0, ""floatValue"");
}
return VAR_8;
case VAR_17:
{
ListOfXXX *VAR_12;
GF_SAFEALLOC(VAR_12, ListOfXXX);
if (!VAR_12) {
VAR_0->last_error = VAR_13;
return NULL;
}
*VAR_12 = gf_list_new();
VAR_8 = lsr_read_fraction_12_item(VAR_0);
if (VAR_8) gf_list_add(*VAR_12, VAR_8);
return VAR_12;
}
case VAR_18:
{
ListOfXXX *VAR_12;
GF_SAFEALLOC(VAR_12, ListOfXXX);
if (!VAR_12) {
VAR_0->last_error = VAR_13;
return NULL;
}
*VAR_12 = gf_list_new();
VAR_8 = (Fixed*)gf_malloc(sizeof(Fixed));
if (!VAR_8) {
VAR_0->last_error = VAR_13;
} else {
*VAR_8 = lsr_read_fixed_clamp(VAR_0, ""value"");
gf_list_add(*VAR_12, VAR_8);
}
return VAR_12;
}
case VAR_19:
{
ListOfXXX *VAR_12;
GF_SAFEALLOC(VAR_12, ListOfXXX);
if (!VAR_12) {
VAR_0->last_error = VAR_13;
return NULL;
}
*VAR_12 = gf_list_new();
if (! *VAR_12) {
VAR_0->last_error = VAR_13;
} else {
gf_list_add(*VAR_12, lsr_read_smil_time(VAR_0, VAR_1) );
}
return VAR_12;
}
default:
lsr_read_extension(VAR_0, ""privateData"");
break;
}
return NULL;
}",gpac/549ff4484246f2bc4d5fec6760332b43774db483/lsr_dec.c/vul/before/0.json,"static void *lsr_read_update_value_indexed(GF_LASeRCodec *lsr, GF_Node*node, u32 fieldType, void *rep_val, u32 idx, Bool is_insert, Bool is_com, u32 *single_field_type)
{
	Fixed *f_val;
	SVG_Number num;

	switch (fieldType) {
	case SVG_Points_datatype/*ITYPE_point*/:
	{
		SVG_Point *pt;
		ListOfXXX *res;
		GF_SAFEALLOC(res, ListOfXXX);
		if (!res) {
			lsr->last_error = GF_OUT_OF_MEM;
			return NULL;
		}
		*res = gf_list_new();
		pt = (SVG_Point*)gf_malloc(sizeof(SVG_Point));
		if (!pt) {
			lsr->last_error = GF_OUT_OF_MEM;
		} else {
			lsr_read_coordinate(lsr, &num, 0, ""coordX"");
			pt->x = num.value;
			lsr_read_coordinate(lsr, &num, 0, ""coordY"");
			pt->y = num.value;
			gf_list_add(*res, pt);
		}
		return res;
	}
	case SMIL_KeySplines_datatype/*ITYPE_float*/:
	{
		ListOfXXX *res;
		GF_SAFEALLOC(res, ListOfXXX);
		if (!res) {
			lsr->last_error = GF_OUT_OF_MEM;
			return NULL;
		}
		*res = gf_list_new();
		f_val = (Fixed*)gf_malloc(sizeof(Fixed));
		if (!f_val) {
			lsr->last_error = GF_OUT_OF_MEM;
		} else {
			*f_val = lsr_read_fixed_16_8(lsr, ""floatValue"");
			gf_list_add(*res, f_val);
		}
		return res;
	}
	case SVG_StrokeDashArray_datatype:
	{
		SVG_StrokeDashArray *da;
		GF_SAFEALLOC(da, SVG_StrokeDashArray);
		if (!da) {
			lsr->last_error = GF_OUT_OF_MEM;
		} else {
			da->array.vals = (Fixed*)gf_malloc(sizeof(Fixed));
			da->array.count = 1;
			if (da->array.vals) da->array.vals[0] = lsr_read_fixed_16_8(lsr, ""floatValue"");
		}
		return da;
	}
	case SVG_ViewBox_datatype:
		f_val = (Fixed*)gf_malloc(sizeof(Fixed));
		if (!f_val) {
			lsr->last_error = GF_OUT_OF_MEM;
		} else {
			*f_val = lsr_read_fixed_16_8(lsr, ""floatValue"");
		}
		return f_val;
	case SMIL_KeyTimes_datatype/*ITYPE_keyTime*/:
	{
		ListOfXXX *res;
		GF_SAFEALLOC(res, ListOfXXX);
		if (!res) {
			lsr->last_error = GF_OUT_OF_MEM;
			return NULL;
		}
		*res = gf_list_new();
		f_val = lsr_read_fraction_12_item(lsr);
		if (f_val) gf_list_add(*res, f_val);
		return res;
	}
	case SMIL_KeyPoints_datatype/*ITYPE_0to1 - keyPoints*/:
	{
		ListOfXXX *res;
		GF_SAFEALLOC(res, ListOfXXX);
		if (!res) {
			lsr->last_error = GF_OUT_OF_MEM;
			return NULL;
		}
		*res = gf_list_new();
		f_val = (Fixed*)gf_malloc(sizeof(Fixed));
		if (!f_val) {
			lsr->last_error = GF_OUT_OF_MEM;
		} else {
			*f_val = lsr_read_fixed_clamp(lsr, ""value"");
			gf_list_add(*res, f_val);
		}
		return res;
	}
	case SMIL_Times_datatype/*ITYPE_smil_time*/:
	{
		ListOfXXX *res;
		GF_SAFEALLOC(res, ListOfXXX);
		if (!res) {
			lsr->last_error = GF_OUT_OF_MEM;
			return NULL;
		}
		*res = gf_list_new();
		if (! *res) {
			lsr->last_error = GF_OUT_OF_MEM;
		} else {
			gf_list_add(*res, lsr_read_smil_time(lsr, node) );
		}
		return res;
	}
	default:
		lsr_read_extension(lsr, ""privateData"");
		break;
	}
	return NULL;
}","static void *lsr_read_update_value_indexed(GF_LASeRCodec *VAR_0, GF_Node*VAR_1, u32 VAR_2, void *VAR_3, u32 VAR_4, Bool VAR_5, Bool VAR_6, u32 *VAR_7)
{
	Fixed *VAR_8;
	SVG_Number VAR_9;

	switch (VAR_2) {
	case VAR_10/* COMMENT_0 */:
	{
		SVG_Point *VAR_11;
		ListOfXXX *VAR_12;
		GF_SAFEALLOC(VAR_12, ListOfXXX);
		if (!VAR_12) {
			VAR_0->last_error = VAR_13;
			return NULL;
		}
		*VAR_12 = gf_list_new();
		VAR_11 = (SVG_Point*)gf_malloc(sizeof(SVG_Point));
		if (!VAR_11) {
			VAR_0->last_error = VAR_13;
		} else {
			lsr_read_coordinate(VAR_0, &VAR_9, 0, ""coordX"");
			VAR_11->x = VAR_9.value;
			lsr_read_coordinate(VAR_0, &VAR_9, 0, ""coordY"");
			VAR_11->y = VAR_9.value;
			gf_list_add(*VAR_12, VAR_11);
		}
		return VAR_12;
	}
	case VAR_14/* COMMENT_1 */:
	{
		ListOfXXX *VAR_12;
		GF_SAFEALLOC(VAR_12, ListOfXXX);
		if (!VAR_12) {
			VAR_0->last_error = VAR_13;
			return NULL;
		}
		*VAR_12 = gf_list_new();
		VAR_8 = (Fixed*)gf_malloc(sizeof(Fixed));
		if (!VAR_8) {
			VAR_0->last_error = VAR_13;
		} else {
			*VAR_8 = lsr_read_fixed_16_8(VAR_0, ""floatValue"");
			gf_list_add(*VAR_12, VAR_8);
		}
		return VAR_12;
	}
	case VAR_15:
	{
		SVG_StrokeDashArray *VAR_16;
		GF_SAFEALLOC(VAR_16, SVG_StrokeDashArray);
		if (!VAR_16) {
			VAR_0->last_error = VAR_13;
		} else {
			VAR_16->array.vals = (Fixed*)gf_malloc(sizeof(Fixed));
			VAR_16->array.count = 1;
			if (VAR_16->array.vals) VAR_16->array.vals[0] = lsr_read_fixed_16_8(VAR_0, ""floatValue"");
		}
		return VAR_16;
	}
	case VAR_17:
		VAR_8 = (Fixed*)gf_malloc(sizeof(Fixed));
		if (!VAR_8) {
			VAR_0->last_error = VAR_13;
		} else {
			*VAR_8 = lsr_read_fixed_16_8(VAR_0, ""floatValue"");
		}
		return VAR_8;
	case VAR_18/* COMMENT_2 */:
	{
		ListOfXXX *VAR_12;
		GF_SAFEALLOC(VAR_12, ListOfXXX);
		if (!VAR_12) {
			VAR_0->last_error = VAR_13;
			return NULL;
		}
		*VAR_12 = gf_list_new();
		VAR_8 = lsr_read_fraction_12_item(VAR_0);
		if (VAR_8) gf_list_add(*VAR_12, VAR_8);
		return VAR_12;
	}
	case VAR_19/* COMMENT_3 */:
	{
		ListOfXXX *VAR_12;
		GF_SAFEALLOC(VAR_12, ListOfXXX);
		if (!VAR_12) {
			VAR_0->last_error = VAR_13;
			return NULL;
		}
		*VAR_12 = gf_list_new();
		VAR_8 = (Fixed*)gf_malloc(sizeof(Fixed));
		if (!VAR_8) {
			VAR_0->last_error = VAR_13;
		} else {
			*VAR_8 = lsr_read_fixed_clamp(VAR_0, ""value"");
			gf_list_add(*VAR_12, VAR_8);
		}
		return VAR_12;
	}
	case VAR_20/* COMMENT_4 */:
	{
		ListOfXXX *VAR_12;
		GF_SAFEALLOC(VAR_12, ListOfXXX);
		if (!VAR_12) {
			VAR_0->last_error = VAR_13;
			return NULL;
		}
		*VAR_12 = gf_list_new();
		if (! *VAR_12) {
			VAR_0->last_error = VAR_13;
		} else {
			gf_list_add(*VAR_12, lsr_read_smil_time(VAR_0, VAR_1) );
		}
		return VAR_12;
	}
	default:
		lsr_read_extension(VAR_0, ""privateData"");
		break;
	}
	return NULL;
}",gpac/549ff4484246f2bc4d5fec6760332b43774db483/lsr_dec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -45,6 +45,18 @@
 		return res;
 	}
 	case SVG_StrokeDashArray_datatype:
+	{
+		SVG_StrokeDashArray *da;
+		GF_SAFEALLOC(da, SVG_StrokeDashArray);
+		if (!da) {
+			lsr->last_error = GF_OUT_OF_MEM;
+		} else {
+			da->array.vals = (Fixed*)gf_malloc(sizeof(Fixed));
+			da->array.count = 1;
+			if (da->array.vals) da->array.vals[0] = lsr_read_fixed_16_8(lsr, ""floatValue"");
+		}
+		return da;
+	}
 	case SVG_ViewBox_datatype:
 		f_val = (Fixed*)gf_malloc(sizeof(Fixed));
 		if (!f_val) {","{'deleted_lines': [], 'added_lines': ['\t{', '\t\tSVG_StrokeDashArray *da;', '\t\tGF_SAFEALLOC(da, SVG_StrokeDashArray);', '\t\tif (!da) {', '\t\t\tlsr->last_error = GF_OUT_OF_MEM;', '\t\t} else {', '\t\t\tda->array.vals = (Fixed*)gf_malloc(sizeof(Fixed));', '\t\t\tda->array.count = 1;', '\t\t\tif (da->array.vals) da->array.vals[0] = lsr_read_fixed_16_8(lsr, ""floatValue"");', '\t\t}', '\t\treturn da;', '\t}']}",True,GPAC v2.3-DEV-rev381-g817a848f6-master was discovered to contain a segmentation violation in the dump_isom_scene function at /mp4box/filedump.c.,5.5,MEDIUM,1,test,2023-06-27T13:29:42Z,4
CVE-2023-37765,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,gpac,fixed #2515,36e1b9900ff638576cb88636bbbe2116ed06dfdc,https://github.com/gpac/gpac/commit/36e1b9900ff638576cb88636bbbe2116ed06dfdc,src/scenegraph/vrml_tools.c,gf_sg_vrml_is_sf_field,"GF_EXPORT
Bool gf_sg_vrml_is_sf_field(u32 FieldType)
{
return (FieldType<GF_SG_VRML_FIRST_MF);
}","GF_EXPORT
VAR_0 gf_sg_vrml_is_sf_field(u32 VAR_1)
{
return (VAR_1<VAR_2);
}",,"GF_EXPORT
Bool gf_sg_vrml_is_sf_field(u32 FieldType)
{
	//special case for AttrRef declared after first MF
	if (FieldType==GF_SG_VRML_SFATTRREF) return GF_TRUE;
	return (FieldType<GF_SG_VRML_FIRST_MF);
}","GF_EXPORT
VAR_0 gf_sg_vrml_is_sf_field(u32 VAR_1)
{
	/* COMMENT_0 */
	if (VAR_1==VAR_2) return VAR_3;
	return (VAR_1<VAR_4);
}",,"--- func_before
+++ func_after
@@ -1,5 +1,7 @@
 GF_EXPORT
 Bool gf_sg_vrml_is_sf_field(u32 FieldType)
 {
+	//special case for AttrRef declared after first MF
+	if (FieldType==GF_SG_VRML_SFATTRREF) return GF_TRUE;
 	return (FieldType<GF_SG_VRML_FIRST_MF);
 }","{'deleted_lines': [], 'added_lines': ['\t//special case for AttrRef declared after first MF', '\tif (FieldType==GF_SG_VRML_SFATTRREF) return GF_TRUE;']}",True,GPAC v2.3-DEV-rev381-g817a848f6-master was discovered to contain a segmentation violation in the gf_dump_vrml_sffield function at /lib/libgpac.so.,5.5,MEDIUM,1,test,2023-07-04T14:59:15Z,4
CVE-2023-39150,['CWE-Other'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,Maximus5/ConEmu,gh-2536: Do not emit control characters in title reports (capability fix).,60683a186628ffaa7689fcb64b3c38ced69287c1,https://github.com/Maximus5/ConEmu/commit/60683a186628ffaa7689fcb64b3c38ced69287c1,src/ConEmuCD/ConAnsiImpl.cpp,SrvAnsiImpl::ReportString,"bool SrvAnsiImpl::ReportString(LPCWSTR asRet)
{
if (!asRet || !*asRet)
return FALSE;
INPUT_RECORD ir[16] = {};
int nLen = lstrlen(asRet);
INPUT_RECORD* pir = (nLen <= (int)countof(ir)) ? ir : (INPUT_RECORD*)calloc(nLen,sizeof(INPUT_RECORD));
if (!pir)
return FALSE;
INPUT_RECORD* p = pir;
LPCWSTR pc = asRet;
for (int i = 0; i < nLen; i++, p++, pc++)
{
const char ch = *pc >= 0x20 ? *pc : L' ';
p->EventType = KEY_EVENT;
p->Event.KeyEvent.bKeyDown = TRUE;
p->Event.KeyEvent.wRepeatCount = 1;
p->Event.KeyEvent.uChar.UnicodeChar = ch;
}
DumpKnownEscape(asRet, nLen, SrvAnsi::de_Report);
DWORD nWritten = 0;
HANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);
bool bSuccess = WriteConsoleInput(hIn, pir, nLen, &nWritten) && (nWritten == nLen);
if (pir != ir)
free(pir);
return bSuccess;
}","bool SrvAnsiImpl::ReportString(LPCWSTR VAR_0)
{
if (!VAR_0 || !*VAR_0)
return FALSE;
INPUT_RECORD VAR_1[16] = {};
int VAR_2 = lstrlen(VAR_0);
INPUT_RECORD* VAR_3 = (VAR_2 <= (int)countof(VAR_1)) ? VAR_1 : (INPUT_RECORD*)calloc(VAR_2,sizeof(INPUT_RECORD));
if (!VAR_3)
return FALSE;
INPUT_RECORD* VAR_4 = VAR_3;
LPCWSTR VAR_5 = VAR_0;
for (int VAR_6 = 0; VAR_6 < VAR_2; VAR_6++, VAR_4++, VAR_5++)
{
const char VAR_7 = *VAR_5 >= 0x20 ? *VAR_5 : L' ';
VAR_4->EventType = VAR_8;
VAR_4->Event.KeyEvent.bKeyDown = TRUE;
VAR_4->Event.KeyEvent.wRepeatCount = 1;
VAR_4->Event.KeyEvent.uChar.UnicodeChar = VAR_7;
}
DumpKnownEscape(VAR_0, VAR_2, SrvAnsi::de_Report);
DWORD VAR_9 = 0;
HANDLE VAR_10 = GetStdHandle(VAR_11);
bool VAR_12 = WriteConsoleInput(VAR_10, VAR_3, VAR_2, &VAR_9) && (VAR_9 == VAR_2);
if (VAR_3 != VAR_1)
free(VAR_3);
return VAR_12;
}",Maximus5/ConEmu/60683a186628ffaa7689fcb64b3c38ced69287c1/ConAnsiImpl.cpp/vul/before/0.json,"bool SrvAnsiImpl::ReportString(LPCWSTR asRet)
{
	if (!asRet || !*asRet)
		return FALSE;
	INPUT_RECORD ir[16] = {};
	int nLen = lstrlen(asRet);
	INPUT_RECORD* pir = (nLen <= (int)countof(ir)) ? ir : (INPUT_RECORD*)calloc(nLen,sizeof(INPUT_RECORD));
	if (!pir)
		return FALSE;

	INPUT_RECORD* p = pir;
	LPCWSTR pc = asRet;
	for (int i = 0; i < nLen; i++, p++, pc++)
	{
		const char ch = (*pc == 0x1B || *pc >= 0x20) ? *pc : L' ';
		p->EventType = KEY_EVENT;
		p->Event.KeyEvent.bKeyDown = TRUE;
		p->Event.KeyEvent.wRepeatCount = 1;
		p->Event.KeyEvent.uChar.UnicodeChar = ch;
	}

	DumpKnownEscape(asRet, nLen, SrvAnsi::de_Report);

	DWORD nWritten = 0;
	HANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);
	bool bSuccess = WriteConsoleInput(hIn, pir, nLen, &nWritten) && (nWritten == nLen);

	if (pir != ir)
		free(pir);
	return bSuccess;
}","bool SrvAnsiImpl::ReportString(LPCWSTR VAR_0)
{
	if (!VAR_0 || !*VAR_0)
		return FALSE;
	INPUT_RECORD VAR_1[16] = {};
	int VAR_2 = lstrlen(VAR_0);
	INPUT_RECORD* VAR_3 = (VAR_2 <= (int)countof(VAR_1)) ? VAR_1 : (INPUT_RECORD*)calloc(VAR_2,sizeof(INPUT_RECORD));
	if (!VAR_3)
		return FALSE;

	INPUT_RECORD* VAR_4 = VAR_3;
	LPCWSTR VAR_5 = VAR_0;
	for (int VAR_6 = 0; VAR_6 < VAR_2; VAR_6++, VAR_4++, VAR_5++)
	{
		const char VAR_7 = (*VAR_5 == 0x1B || *VAR_5 >= 0x20) ? *VAR_5 : L' ';
		VAR_4->EventType = VAR_8;
		VAR_4->Event.KeyEvent.bKeyDown = TRUE;
		VAR_4->Event.KeyEvent.wRepeatCount = 1;
		VAR_4->Event.KeyEvent.uChar.UnicodeChar = VAR_7;
	}

	DumpKnownEscape(VAR_0, VAR_2, SrvAnsi::de_Report);

	DWORD VAR_9 = 0;
	HANDLE VAR_10 = GetStdHandle(VAR_11);
	bool VAR_12 = WriteConsoleInput(VAR_10, VAR_3, VAR_2, &VAR_9) && (VAR_9 == VAR_2);

	if (VAR_3 != VAR_1)
		free(VAR_3);
	return VAR_12;
}",Maximus5/ConEmu/60683a186628ffaa7689fcb64b3c38ced69287c1/ConAnsiImpl.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,7 +12,7 @@
 	LPCWSTR pc = asRet;
 	for (int i = 0; i < nLen; i++, p++, pc++)
 	{
-		const char ch = *pc >= 0x20 ? *pc : L' ';
+		const char ch = (*pc == 0x1B || *pc >= 0x20) ? *pc : L' ';
 		p->EventType = KEY_EVENT;
 		p->Event.KeyEvent.bKeyDown = TRUE;
 		p->Event.KeyEvent.wRepeatCount = 1;","{'deleted_lines': [""\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';""], 'added_lines': [""\t\tconst char ch = (*pc == 0x1B || *pc >= 0x20) ? *pc : L' ';""]}",True,"ConEmu before commit 230724 does not sanitize title responses correctly for control characters, potentially leading to arbitrary code execution. This is related to an incomplete fix for CVE-2022-46387.",9.8,CRITICAL,3,test,2023-07-23T23:00:49Z,4
CVE-2023-39150,['CWE-Other'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,Maximus5/ConEmu,gh-2536: Do not emit control characters in title reports (capability fix).,60683a186628ffaa7689fcb64b3c38ced69287c1,https://github.com/Maximus5/ConEmu/commit/60683a186628ffaa7689fcb64b3c38ced69287c1,src/ConEmuHk/Ansi.cpp,CEAnsi::ReportString,"BOOL CEAnsi::ReportString(LPCWSTR asRet)
{
if (!asRet || !*asRet)
return FALSE;
INPUT_RECORD ir[16] = {};
const size_t nLen = wcslen(asRet);
if (nLen > std::numeric_limits<DWORD>::max())
return false;
INPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));
if (!pir)
return FALSE;
INPUT_RECORD* p = pir;
LPCWSTR pc = asRet;
for (size_t i = 0; i < nLen; i++, p++, pc++)
{
const char ch = *pc >= 0x20 ? *pc : L' ';
p->EventType = KEY_EVENT;
p->Event.KeyEvent.bKeyDown = TRUE;
p->Event.KeyEvent.wRepeatCount = 1;
p->Event.KeyEvent.uChar.UnicodeChar = ch;
}
DumpKnownEscape(asRet, nLen, de_Report);
DWORD nWritten = 0;
HANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);
const BOOL bSuccess = WriteConsoleInput(hIn, pir, static_cast<DWORD>(nLen), &nWritten) && (nWritten == nLen);
if (pir != ir)
free(pir);
return bSuccess;
}","BOOL CEAnsi::ReportString(LPCWSTR VAR_0)
{
if (!VAR_0 || !*VAR_0)
return FALSE;
INPUT_RECORD VAR_1[16] = {};
const size_t VAR_2 = wcslen(VAR_0);
if (VAR_2 > std::numeric_limits<DWORD>::max())
return false;
INPUT_RECORD* VAR_3 = (VAR_2 <= VAR_4<int>(countof(VAR_1))) ? VAR_1 : VAR_4<INPUT_RECORD*>(calloc(VAR_2, sizeof(INPUT_RECORD)));
if (!VAR_3)
return FALSE;
INPUT_RECORD* VAR_5 = VAR_3;
LPCWSTR VAR_6 = VAR_0;
for (size_t VAR_7 = 0; VAR_7 < VAR_2; VAR_7++, VAR_5++, VAR_6++)
{
const char VAR_8 = *VAR_6 >= 0x20 ? *VAR_6 : L' ';
VAR_5->EventType = VAR_9;
VAR_5->Event.KeyEvent.bKeyDown = TRUE;
VAR_5->Event.KeyEvent.wRepeatCount = 1;
VAR_5->Event.KeyEvent.uChar.UnicodeChar = VAR_8;
}
DumpKnownEscape(VAR_0, VAR_2, VAR_10);
DWORD VAR_11 = 0;
HANDLE VAR_12 = GetStdHandle(VAR_13);
const BOOL VAR_14 = WriteConsoleInput(VAR_12, VAR_3, VAR_4<DWORD>(VAR_2), &VAR_11) && (VAR_11 == VAR_2);
if (VAR_3 != VAR_1)
free(VAR_3);
return VAR_14;
}",Maximus5/ConEmu/60683a186628ffaa7689fcb64b3c38ced69287c1/Ansi.cpp/vul/before/0.json,"BOOL CEAnsi::ReportString(LPCWSTR asRet)
{
	if (!asRet || !*asRet)
		return FALSE;
	INPUT_RECORD ir[16] = {};
	const size_t nLen = wcslen(asRet);
	if (nLen > std::numeric_limits<DWORD>::max())
		return false;
	INPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));
	if (!pir)
		return FALSE;

	INPUT_RECORD* p = pir;
	LPCWSTR pc = asRet;
	for (size_t i = 0; i < nLen; i++, p++, pc++)
	{
		const char ch = (*pc == 0x1B || *pc >= 0x20) ? *pc : L' ';
		p->EventType = KEY_EVENT;
		p->Event.KeyEvent.bKeyDown = TRUE;
		p->Event.KeyEvent.wRepeatCount = 1;
		p->Event.KeyEvent.uChar.UnicodeChar = ch;
	}

	DumpKnownEscape(asRet, nLen, de_Report);

	DWORD nWritten = 0;
	// ReSharper disable once CppLocalVariableMayBeConst
	HANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);
	const BOOL bSuccess = WriteConsoleInput(hIn, pir, static_cast<DWORD>(nLen), &nWritten) && (nWritten == nLen);

	if (pir != ir)
		free(pir);
	return bSuccess;
}","BOOL CEAnsi::ReportString(LPCWSTR VAR_0)
{
	if (!VAR_0 || !*VAR_0)
		return FALSE;
	INPUT_RECORD VAR_1[16] = {};
	const size_t VAR_2 = wcslen(VAR_0);
	if (VAR_2 > std::numeric_limits<DWORD>::max())
		return false;
	INPUT_RECORD* VAR_3 = (VAR_2 <= VAR_4<int>(countof(VAR_1))) ? VAR_1 : VAR_4<INPUT_RECORD*>(calloc(VAR_2, sizeof(INPUT_RECORD)));
	if (!VAR_3)
		return FALSE;

	INPUT_RECORD* VAR_5 = VAR_3;
	LPCWSTR VAR_6 = VAR_0;
	for (size_t VAR_7 = 0; VAR_7 < VAR_2; VAR_7++, VAR_5++, VAR_6++)
	{
		const char VAR_8 = (*VAR_6 == 0x1B || *VAR_6 >= 0x20) ? *VAR_6 : L' ';
		VAR_5->EventType = VAR_9;
		VAR_5->Event.KeyEvent.bKeyDown = TRUE;
		VAR_5->Event.KeyEvent.wRepeatCount = 1;
		VAR_5->Event.KeyEvent.uChar.UnicodeChar = VAR_8;
	}

	DumpKnownEscape(VAR_0, VAR_2, VAR_10);

	DWORD VAR_11 = 0;
	/* COMMENT_0 */
	HANDLE VAR_12 = GetStdHandle(VAR_13);
	const BOOL VAR_14 = WriteConsoleInput(VAR_12, VAR_3, VAR_4<DWORD>(VAR_2), &VAR_11) && (VAR_11 == VAR_2);

	if (VAR_3 != VAR_1)
		free(VAR_3);
	return VAR_14;
}",Maximus5/ConEmu/60683a186628ffaa7689fcb64b3c38ced69287c1/Ansi.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,7 +14,7 @@
 	LPCWSTR pc = asRet;
 	for (size_t i = 0; i < nLen; i++, p++, pc++)
 	{
-		const char ch = *pc >= 0x20 ? *pc : L' ';
+		const char ch = (*pc == 0x1B || *pc >= 0x20) ? *pc : L' ';
 		p->EventType = KEY_EVENT;
 		p->Event.KeyEvent.bKeyDown = TRUE;
 		p->Event.KeyEvent.wRepeatCount = 1;","{'deleted_lines': [""\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';""], 'added_lines': [""\t\tconst char ch = (*pc == 0x1B || *pc >= 0x20) ? *pc : L' ';""]}",True,"ConEmu before commit 230724 does not sanitize title responses correctly for control characters, potentially leading to arbitrary code execution. This is related to an incomplete fix for CVE-2022-46387.",9.8,CRITICAL,3,test,2023-07-23T23:00:49Z,4
CVE-2023-46852,['CWE-120'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,memcached,"proxy: fix buffer overflow with multiget syntax

""get[200 spaces]key1 key2\r\n"" would overflow a temporary buffer used to
process multiget syntax.

To exploit this you must first pass the check in try_read_command_proxy:
- The request before the first newline must be less than 1024 bytes.
- If it is more than 1024 bytes there is a limit of 100 spaces.
- The key length is still checked at 250 bytes
- Meaning you have up to 772 spaces and then the key to create stack
  corruption.

So the amount of data you can shove in here isn't unlimited.

The fix caps the amount of data pre-key to be reasonable. Something like
GAT needs space for a 32bit TTL which is at most going to be 15 bytes +
spaces, so we limit it to 20 bytes.

I hate hate hate hate hate the multiget syntax. hate it.",76a6c363c18cfe7b6a1524ae64202ac9db330767,https://github.com/memcached/memcached/commit/76a6c363c18cfe7b6a1524ae64202ac9db330767,proto_proxy.c,proxy_process_command,"static void proxy_process_command(conn *c, char *command, size_t cmdlen, bool multiget) {
assert(c != NULL);
LIBEVENT_THREAD *thr = c->thread;
struct proxy_hook *hooks = thr->proxy_hooks;
lua_State *L = thr->L;
proxy_ctx_t *ctx = thr->proxy_ctx;
mcp_parser_t pr = {0};
int ret = process_request(&pr, command, cmdlen);
if (ret != 0) {
WSTAT_INCR(c->thread, proxy_conn_errors, 1);
if (!resp_start(c)) {
conn_set_state(c, conn_closing);
return;
}
proxy_out_errstring(c->resp, PROXY_CLIENT_ERROR, ""parsing request"");
if (ret == -2) {
conn_set_state(c, conn_closing);
}
return;
}
struct proxy_hook *hook = &hooks[pr.command];
int hook_ref = hook->lua_ref;
if (c->tag && hook->tagged) {
struct proxy_hook_tagged *pht = hook->tagged;
while (pht->lua_ref) {
if (c->tag == pht->tag) {
hook_ref = pht->lua_ref;
break;
}
pht++;
}
}
if (!hook_ref) {
if (cmdlen > 1 && command[cmdlen-2] == '\r') {
command[cmdlen-2] = '\0';
} else {
command[cmdlen-1] = '\0';
}
c->proxy_coro_ref = 0;
process_command_ascii(c, command);
return;
}
if (!multiget && pr.cmd_type == CMD_TYPE_GET && pr.has_space) {
uint32_t keyoff = pr.tokens[pr.keytoken];
while (pr.klen != 0) {
char temp[KEY_MAX_LENGTH + 30];
char *cur = temp;
if (pr.klen > KEY_MAX_LENGTH) {
if (!resp_start(c)) {
conn_set_state(c, conn_closing);
return;
}
proxy_out_errstring(c->resp, PROXY_CLIENT_ERROR, ""key too long"");
} else {
memcpy(cur, pr.request, pr.tokens[pr.keytoken]);
cur += pr.tokens[pr.keytoken];
memcpy(cur, &pr.request[keyoff], pr.klen);
cur += pr.klen;
memcpy(cur, ""\r\n"", 2);
cur += 2;
*cur = '\0';
P_DEBUG(""%s: new multiget sub request: %s [%u/%u]\n"", __func__, temp, keyoff, pr.klen);
proxy_process_command(c, temp, cur - temp, PROCESS_MULTIGET);
}
keyoff = _process_request_next_key(&pr);
}
if (!resp_start(c)) {
conn_set_state(c, conn_closing);
return;
}
memcpy(c->resp->wbuf, ENDSTR, ENDLEN);
resp_add_iov(c->resp, c->resp->wbuf, ENDLEN);
return;
}
if (cmdlen >= MCP_REQUEST_MAXLEN) {
WSTAT_INCR(c->thread, proxy_conn_errors, 1);
if (!resp_start(c)) {
conn_set_state(c, conn_closing);
return;
}
proxy_out_errstring(c->resp, PROXY_CLIENT_ERROR, ""request too long"");
conn_set_state(c, conn_closing);
return;
}
if (!resp_start(c)) {
conn_set_state(c, conn_closing);
return;
}
struct proxy_int_stats *istats = c->thread->proxy_int_stats;
uint64_t active_reqs = 0;
WSTAT_L(c->thread);
istats->counters[pr.command]++;
c->thread->stats.proxy_conn_requests++;
c->thread->stats.proxy_req_active++;
active_reqs = c->thread->stats.proxy_req_active;
WSTAT_UL(c->thread);
if (active_reqs > ctx->active_req_limit) {
proxy_out_errstring(c->resp, PROXY_SERVER_ERROR, ""active request limit reached"");
WSTAT_DECR(c->thread, proxy_req_active, 1);
if (pr.vlen != 0) {
c->sbytes = pr.vlen;
conn_set_state(c, conn_swallow);
}
return;
}
lua_newthread(L);
lua_State *Lc = lua_tothread(L, -1);
lua_rawgeti(Lc, LUA_REGISTRYINDEX, hook_ref);
mcp_request_t *rq = mcp_new_request(Lc, &pr, command, cmdlen);
rq->ascii_multiget = multiget;
if (rq->pr.vlen != 0) {
c->item = NULL;
bool oom = proxy_bufmem_checkadd(c->thread, 0);
if (!oom) {
c->item = malloc(rq->pr.vlen);
}
if (c->item == NULL) {
lua_settop(L, 0);
proxy_out_errstring(c->resp, PROXY_SERVER_ERROR, ""out of memory"");
WSTAT_DECR(c->thread, proxy_req_active, 1);
c->sbytes = rq->pr.vlen;
conn_set_state(c, conn_swallow);
return;
}
c->item_malloced = true;
c->ritem = c->item;
c->rlbytes = rq->pr.vlen;
c->proxy_coro_ref = luaL_ref(L, LUA_REGISTRYINDEX); 
conn_set_state(c, conn_nread);
return;
} else {
conn_set_state(c, conn_new_cmd);
}
proxy_run_coroutine(Lc, c->resp, NULL, c);
lua_settop(L, 0); }","static void proxy_process_command(conn *VAR_0, char *VAR_1, size_t VAR_2, bool VAR_3) {
assert(VAR_0 != NULL);
LIBEVENT_THREAD *VAR_4 = VAR_0->thread;
struct proxy_hook *VAR_5 = VAR_4->proxy_hooks;
lua_State *VAR_6 = VAR_4->L;
proxy_ctx_t *VAR_7 = VAR_4->proxy_ctx;
mcp_parser_t VAR_8 = {0};
int VAR_9 = process_request(&VAR_8, VAR_1, VAR_2);
if (VAR_9 != 0) {
WSTAT_INCR(VAR_0->thread, VAR_10, 1);
if (!resp_start(VAR_0)) {
conn_set_state(VAR_0, VAR_11);
return;
}
proxy_out_errstring(VAR_0->resp, VAR_12, ""parsing request"");
if (VAR_9 == -2) {
conn_set_state(VAR_0, VAR_11);
}
return;
}
struct proxy_hook *VAR_13 = &VAR_5[VAR_8.command];
int VAR_14 = VAR_13->lua_ref;
if (VAR_0->tag && VAR_13->tagged) {
struct proxy_hook_tagged *VAR_15 = VAR_13->tagged;
while (VAR_15->lua_ref) {
if (VAR_0->tag == VAR_15->tag) {
VAR_14 = VAR_15->lua_ref;
break;
}
VAR_15++;
}
}
if (!VAR_14) {
if (VAR_2 > 1 && VAR_1[VAR_2-2] == '\r') {
VAR_1[VAR_2-2] = '\0';
} else {
VAR_1[VAR_2-1] = '\0';
}
VAR_0->proxy_coro_ref = 0;
process_command_ascii(VAR_0, VAR_1);
return;
}
if (!VAR_3 && VAR_8.cmd_type == VAR_16 && VAR_8.has_space) {
uint32_t VAR_17 = VAR_8.tokens[VAR_8.keytoken];
while (VAR_8.klen != 0) {
char VAR_18[VAR_19 + 30];
char *VAR_20 = VAR_18;
if (VAR_8.klen > VAR_19) {
if (!resp_start(VAR_0)) {
conn_set_state(VAR_0, VAR_11);
return;
}
proxy_out_errstring(VAR_0->resp, VAR_12, ""key too long"");
} else {
memcpy(VAR_20, VAR_8.request, VAR_8.tokens[VAR_8.keytoken]);
VAR_20 += VAR_8.tokens[VAR_8.keytoken];
memcpy(VAR_20, &VAR_8.request[VAR_17], VAR_8.klen);
VAR_20 += VAR_8.klen;
memcpy(VAR_20, ""\r\n"", 2);
VAR_20 += 2;
*VAR_20 = '\0';
P_DEBUG(""%s: new multiget sub request: %s [%u/%u]\n"", VAR_21, VAR_18, VAR_17, VAR_8.klen);
proxy_process_command(VAR_0, VAR_18, VAR_20 - VAR_18, VAR_22);
}
VAR_17 = _process_request_next_key(&VAR_8);
}
if (!resp_start(VAR_0)) {
conn_set_state(VAR_0, VAR_11);
return;
}
memcpy(VAR_0->resp->wbuf, VAR_23, VAR_24);
resp_add_iov(VAR_0->resp, VAR_0->resp->wbuf, VAR_24);
return;
}
if (VAR_2 >= VAR_25) {
WSTAT_INCR(VAR_0->thread, VAR_10, 1);
if (!resp_start(VAR_0)) {
conn_set_state(VAR_0, VAR_11);
return;
}
proxy_out_errstring(VAR_0->resp, VAR_12, ""request too long"");
conn_set_state(VAR_0, VAR_11);
return;
}
if (!resp_start(VAR_0)) {
conn_set_state(VAR_0, VAR_11);
return;
}
struct proxy_int_stats *VAR_26 = VAR_0->thread->proxy_int_stats;
uint64_t VAR_27 = 0;
WSTAT_L(VAR_0->thread);
VAR_26->counters[VAR_8.command]++;
VAR_0->thread->stats.proxy_conn_requests++;
VAR_0->thread->stats.proxy_req_active++;
VAR_27 = VAR_0->thread->stats.proxy_req_active;
WSTAT_UL(VAR_0->thread);
if (VAR_27 > VAR_7->active_req_limit) {
proxy_out_errstring(VAR_0->resp, VAR_28, ""active request limit reached"");
WSTAT_DECR(VAR_0->thread, VAR_29, 1);
if (VAR_8.vlen != 0) {
VAR_0->sbytes = VAR_8.vlen;
conn_set_state(VAR_0, VAR_30);
}
return;
}
lua_newthread(VAR_6);
lua_State *VAR_31 = lua_tothread(VAR_6, -1);
lua_rawgeti(VAR_31, VAR_32, VAR_14);
mcp_request_t *VAR_33 = mcp_new_request(VAR_31, &VAR_8, VAR_1, VAR_2);
VAR_33->ascii_multiget = VAR_3;
if (VAR_33->pr.vlen != 0) {
VAR_0->item = NULL;
bool VAR_34 = proxy_bufmem_checkadd(VAR_0->thread, 0);
if (!VAR_34) {
VAR_0->item = malloc(VAR_33->pr.vlen);
}
if (VAR_0->item == NULL) {
lua_settop(VAR_6, 0);
proxy_out_errstring(VAR_0->resp, VAR_28, ""out of memory"");
WSTAT_DECR(VAR_0->thread, VAR_29, 1);
VAR_0->sbytes = VAR_33->pr.vlen;
conn_set_state(VAR_0, VAR_30);
return;
}
VAR_0->item_malloced = true;
VAR_0->ritem = VAR_0->item;
VAR_0->rlbytes = VAR_33->pr.vlen;
VAR_0->proxy_coro_ref = luaL_ref(VAR_6, VAR_32); 
conn_set_state(VAR_0, VAR_35);
return;
} else {
conn_set_state(VAR_0, VAR_36);
}
proxy_run_coroutine(VAR_31, VAR_0->resp, NULL, VAR_0);
lua_settop(VAR_6, 0); 
}",memcached/76a6c363c18cfe7b6a1524ae64202ac9db330767/proto_proxy.c/vul/before/0.json,"static void proxy_process_command(conn *c, char *command, size_t cmdlen, bool multiget) {
    assert(c != NULL);
    LIBEVENT_THREAD *thr = c->thread;
    struct proxy_hook *hooks = thr->proxy_hooks;
    lua_State *L = thr->L;
    proxy_ctx_t *ctx = thr->proxy_ctx;
    mcp_parser_t pr = {0};

    // Avoid doing resp_start() here, instead do it a bit later or as-needed.
    // This allows us to hop over to the internal text protocol parser, which
    // also calls resp_start().
    // Tighter integration later should obviate the need for this, it is not a
    // permanent solution.
    int ret = process_request(&pr, command, cmdlen);
    if (ret != 0) {
        WSTAT_INCR(c->thread, proxy_conn_errors, 1);
        if (!resp_start(c)) {
            conn_set_state(c, conn_closing);
            return;
        }
        proxy_out_errstring(c->resp, PROXY_CLIENT_ERROR, ""parsing request"");
        if (ret == -2) {
            // Kill connection on more critical parse failure.
            conn_set_state(c, conn_closing);
        }
        return;
    }

    struct proxy_hook *hook = &hooks[pr.command];
    int hook_ref = hook->lua_ref;
    // if client came from a tagged listener, scan for a more specific hook.
    // TODO: (v2) avoiding a hash table lookup here, but maybe some other
    // datastructure would suffice. for 4-8 tags this is perfectly fast.
    if (c->tag && hook->tagged) {
        struct proxy_hook_tagged *pht = hook->tagged;
        while (pht->lua_ref) {
            if (c->tag == pht->tag) {
                hook_ref = pht->lua_ref;
                break;
            }
            pht++;
        }
    }

    if (!hook_ref) {
        // need to pass our command string into the internal handler.
        // to minimize the code change, this means allowing it to tokenize the
        // full command. The proxy's indirect parser should be built out to
        // become common code for both proxy and ascii handlers.
        // For now this means we have to null-terminate the command string,
        // then call into text protocol handler.
        // FIXME (v2): use a ptr or something; don't like this code.
        if (cmdlen > 1 && command[cmdlen-2] == '\r') {
            command[cmdlen-2] = '\0';
        } else {
            command[cmdlen-1] = '\0';
        }
        // lets nread_proxy know we're in ascii mode.
        c->proxy_coro_ref = 0;
        process_command_ascii(c, command);
        return;
    }

    // If ascii multiget, we turn this into a self-calling loop :(
    // create new request with next key, call this func again, then advance
    // original string.
    // might be better to split this function; the below bits turn into a
    // function call, then we don't re-process the above bits in the same way?
    // The way this is detected/passed on is very fragile.
    if (!multiget && pr.cmd_type == CMD_TYPE_GET && pr.has_space) {
        uint32_t keyoff = pr.tokens[pr.keytoken];
        while (pr.klen != 0) {
            char temp[KEY_MAX_LENGTH + MAX_CMD_PREFIX + 30];
            char *cur = temp;
            // Core daemon can abort the entire command if one key is bad, but
            // we cannot from the proxy. Instead we have to inject errors into
            // the stream. This should, thankfully, be rare at least.
            if (pr.tokens[pr.keytoken] > MAX_CMD_PREFIX) {
                if (!resp_start(c)) {
                    conn_set_state(c, conn_closing);
                    return;
                }
                proxy_out_errstring(c->resp, PROXY_CLIENT_ERROR, ""malformed request"");
            } else if (pr.klen > KEY_MAX_LENGTH) {
                if (!resp_start(c)) {
                    conn_set_state(c, conn_closing);
                    return;
                }
                proxy_out_errstring(c->resp, PROXY_CLIENT_ERROR, ""key too long"");
            } else {
                // copy original request up until the original key token.
                memcpy(cur, pr.request, pr.tokens[pr.keytoken]);
                cur += pr.tokens[pr.keytoken];

                // now copy in our ""current"" key.
                memcpy(cur, &pr.request[keyoff], pr.klen);
                cur += pr.klen;

                memcpy(cur, ""\r\n"", 2);
                cur += 2;

                *cur = '\0';
                P_DEBUG(""%s: new multiget sub request: %s [%u/%u]\n"", __func__, temp, keyoff, pr.klen);
                proxy_process_command(c, temp, cur - temp, PROCESS_MULTIGET);
            }

            // now advance to the next key.
            keyoff = _process_request_next_key(&pr);
        }

        if (!resp_start(c)) {
            conn_set_state(c, conn_closing);
            return;
        }

        // The above recursions should have created c->resp's in dispatch
        // order.
        // So now we add another one at the end to create the capping END
        // string.
        memcpy(c->resp->wbuf, ENDSTR, ENDLEN);
        resp_add_iov(c->resp, c->resp->wbuf, ENDLEN);

        return;
    }

    // We test the command length all the way down here because multigets can
    // be very long, and they're chopped up by now.
    if (cmdlen >= MCP_REQUEST_MAXLEN) {
        WSTAT_INCR(c->thread, proxy_conn_errors, 1);
        if (!resp_start(c)) {
            conn_set_state(c, conn_closing);
            return;
        }
        proxy_out_errstring(c->resp, PROXY_CLIENT_ERROR, ""request too long"");
        conn_set_state(c, conn_closing);
        return;
    }

    if (!resp_start(c)) {
        conn_set_state(c, conn_closing);
        return;
    }

    // Count requests handled by proxy vs local.
    // Also batch the counts down this far so we can lock once for the active
    // counter instead of twice.
    struct proxy_int_stats *istats = c->thread->proxy_int_stats;
    uint64_t active_reqs = 0;
    WSTAT_L(c->thread);
    istats->counters[pr.command]++;
    c->thread->stats.proxy_conn_requests++;
    c->thread->stats.proxy_req_active++;
    active_reqs = c->thread->stats.proxy_req_active;
    WSTAT_UL(c->thread);

    if (active_reqs > ctx->active_req_limit) {
        proxy_out_errstring(c->resp, PROXY_SERVER_ERROR, ""active request limit reached"");
        WSTAT_DECR(c->thread, proxy_req_active, 1);
        if (pr.vlen != 0) {
            c->sbytes = pr.vlen;
            conn_set_state(c, conn_swallow);
        }
        return;
    }

    // start a coroutine.
    // TODO (v2): This can pull a thread from a cache.
    lua_newthread(L);
    lua_State *Lc = lua_tothread(L, -1);
    // leave the thread first on the stack, so we can reference it if needed.
    // pull the lua hook function onto the stack.
    lua_rawgeti(Lc, LUA_REGISTRYINDEX, hook_ref);

    mcp_request_t *rq = mcp_new_request(Lc, &pr, command, cmdlen);
    rq->ascii_multiget = multiget;
    // NOTE: option 1) copy c->tag into rq->tag here.
    // add req:listen_tag() to retrieve in top level route.

    // TODO (v2): lift this to a post-processor?
    if (rq->pr.vlen != 0) {
        c->item = NULL;
        // Need to add the used memory later due to needing an extra callback
        // handler on error during nread.
        bool oom = proxy_bufmem_checkadd(c->thread, 0);

        // relying on temporary malloc's not having fragmentation
        if (!oom) {
            c->item = malloc(rq->pr.vlen);
        }
        if (c->item == NULL) {
            lua_settop(L, 0);
            proxy_out_errstring(c->resp, PROXY_SERVER_ERROR, ""out of memory"");
            WSTAT_DECR(c->thread, proxy_req_active, 1);
            c->sbytes = rq->pr.vlen;
            conn_set_state(c, conn_swallow);
            return;
        }
        c->item_malloced = true;
        c->ritem = c->item;
        c->rlbytes = rq->pr.vlen;
        c->proxy_coro_ref = luaL_ref(L, LUA_REGISTRYINDEX); // pops coroutine.

        conn_set_state(c, conn_nread);
        return;
    } else {
        conn_set_state(c, conn_new_cmd);
    }

    proxy_run_coroutine(Lc, c->resp, NULL, c);

    lua_settop(L, 0); // clear anything remaining on the main thread.
}","static void proxy_process_command(conn *VAR_0, char *VAR_1, size_t VAR_2, bool VAR_3) {
    assert(VAR_0 != NULL);
    LIBEVENT_THREAD *VAR_4 = VAR_0->thread;
    struct proxy_hook *VAR_5 = VAR_4->proxy_hooks;
    lua_State *VAR_6 = VAR_4->L;
    proxy_ctx_t *VAR_7 = VAR_4->proxy_ctx;
    mcp_parser_t VAR_8 = {0};

    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    /* COMMENT_3 */
    /* COMMENT_4 */
    int VAR_9 = process_request(&VAR_8, VAR_1, VAR_2);
    if (VAR_9 != 0) {
        WSTAT_INCR(VAR_0->thread, VAR_10, 1);
        if (!resp_start(VAR_0)) {
            conn_set_state(VAR_0, VAR_11);
            return;
        }
        proxy_out_errstring(VAR_0->resp, VAR_12, ""parsing request"");
        if (VAR_9 == -2) {
            /* COMMENT_5 */
            conn_set_state(VAR_0, VAR_11);
        }
        return;
    }

    struct proxy_hook *VAR_13 = &VAR_5[VAR_8.command];
    int VAR_14 = VAR_13->lua_ref;
    /* COMMENT_6 */
    /* COMMENT_7 */
    /* COMMENT_8 */
    if (VAR_0->tag && VAR_13->tagged) {
        struct proxy_hook_tagged *VAR_15 = VAR_13->tagged;
        while (VAR_15->lua_ref) {
            if (VAR_0->tag == VAR_15->tag) {
                VAR_14 = VAR_15->lua_ref;
                break;
            }
            VAR_15++;
        }
    }

    if (!VAR_14) {
        /* COMMENT_9 */
        /* COMMENT_10 */
        /* COMMENT_11 */
        /* COMMENT_12 */
        /* COMMENT_13 */
        /* COMMENT_14 */
        /* COMMENT_15 */
        if (VAR_2 > 1 && VAR_1[VAR_2-2] == '\r') {
            VAR_1[VAR_2-2] = '\0';
        } else {
            VAR_1[VAR_2-1] = '\0';
        }
        /* COMMENT_16 */
        VAR_0->proxy_coro_ref = 0;
        process_command_ascii(VAR_0, VAR_1);
        return;
    }

    /* COMMENT_17 */
    /* COMMENT_18 */
    /* COMMENT_19 */
    /* COMMENT_20 */
    /* COMMENT_21 */
    /* COMMENT_22 */
    if (!VAR_3 && VAR_8.cmd_type == VAR_16 && VAR_8.has_space) {
        uint32_t VAR_17 = VAR_8.tokens[VAR_8.keytoken];
        while (VAR_8.klen != 0) {
            char VAR_18[VAR_19 + VAR_20 + 30];
            char *VAR_21 = VAR_18;
            /* COMMENT_23 */
            /* COMMENT_24 */
            /* COMMENT_25 */
            if (VAR_8.tokens[VAR_8.keytoken] > VAR_20) {
                if (!resp_start(VAR_0)) {
                    conn_set_state(VAR_0, VAR_11);
                    return;
                }
                proxy_out_errstring(VAR_0->resp, VAR_12, ""malformed request"");
            } else if (VAR_8.klen > VAR_19) {
                if (!resp_start(VAR_0)) {
                    conn_set_state(VAR_0, VAR_11);
                    return;
                }
                proxy_out_errstring(VAR_0->resp, VAR_12, ""key too long"");
            } else {
                /* COMMENT_26 */
                memcpy(VAR_21, VAR_8.request, VAR_8.tokens[VAR_8.keytoken]);
                VAR_21 += VAR_8.tokens[VAR_8.keytoken];

                /* COMMENT_27 */
                memcpy(VAR_21, &VAR_8.request[VAR_17], VAR_8.klen);
                VAR_21 += VAR_8.klen;

                memcpy(VAR_21, ""\r\n"", 2);
                VAR_21 += 2;

                *VAR_21 = '\0';
                P_DEBUG(""%s: new multiget sub request: %s [%u/%u]\n"", VAR_22, VAR_18, VAR_17, VAR_8.klen);
                proxy_process_command(VAR_0, VAR_18, VAR_21 - VAR_18, VAR_23);
            }

            /* COMMENT_28 */
            VAR_17 = _process_request_next_key(&VAR_8);
        }

        if (!resp_start(VAR_0)) {
            conn_set_state(VAR_0, VAR_11);
            return;
        }

        /* COMMENT_29 */
        /* COMMENT_30 */
        /* COMMENT_31 */
        /* COMMENT_32 */
        memcpy(VAR_0->resp->wbuf, VAR_24, VAR_25);
        resp_add_iov(VAR_0->resp, VAR_0->resp->wbuf, VAR_25);

        return;
    }

    /* COMMENT_33 */
    /* COMMENT_34 */
    if (VAR_2 >= VAR_26) {
        WSTAT_INCR(VAR_0->thread, VAR_10, 1);
        if (!resp_start(VAR_0)) {
            conn_set_state(VAR_0, VAR_11);
            return;
        }
        proxy_out_errstring(VAR_0->resp, VAR_12, ""request too long"");
        conn_set_state(VAR_0, VAR_11);
        return;
    }

    if (!resp_start(VAR_0)) {
        conn_set_state(VAR_0, VAR_11);
        return;
    }

    /* COMMENT_35 */
    /* COMMENT_36 */
    /* COMMENT_37 */
    struct proxy_int_stats *VAR_27 = VAR_0->thread->proxy_int_stats;
    uint64_t VAR_28 = 0;
    WSTAT_L(VAR_0->thread);
    VAR_27->counters[VAR_8.command]++;
    VAR_0->thread->stats.proxy_conn_requests++;
    VAR_0->thread->stats.proxy_req_active++;
    VAR_28 = VAR_0->thread->stats.proxy_req_active;
    WSTAT_UL(VAR_0->thread);

    if (VAR_28 > VAR_7->active_req_limit) {
        proxy_out_errstring(VAR_0->resp, VAR_29, ""active request limit reached"");
        WSTAT_DECR(VAR_0->thread, VAR_30, 1);
        if (VAR_8.vlen != 0) {
            VAR_0->sbytes = VAR_8.vlen;
            conn_set_state(VAR_0, VAR_31);
        }
        return;
    }

    /* COMMENT_38 */
    /* COMMENT_39 */
    lua_newthread(VAR_6);
    lua_State *VAR_32 = lua_tothread(VAR_6, -1);
    /* COMMENT_40 */
    /* COMMENT_41 */
    lua_rawgeti(VAR_32, VAR_33, VAR_14);

    mcp_request_t *VAR_34 = mcp_new_request(VAR_32, &VAR_8, VAR_1, VAR_2);
    VAR_34->ascii_multiget = VAR_3;
    /* COMMENT_42 */
    /* COMMENT_43 */

    /* COMMENT_44 */
    if (VAR_34->pr.vlen != 0) {
        VAR_0->item = NULL;
        /* COMMENT_45 */
        /* COMMENT_46 */
        bool VAR_35 = proxy_bufmem_checkadd(VAR_0->thread, 0);

        /* COMMENT_47 */
        if (!VAR_35) {
            VAR_0->item = malloc(VAR_34->pr.vlen);
        }
        if (VAR_0->item == NULL) {
            lua_settop(VAR_6, 0);
            proxy_out_errstring(VAR_0->resp, VAR_29, ""out of memory"");
            WSTAT_DECR(VAR_0->thread, VAR_30, 1);
            VAR_0->sbytes = VAR_34->pr.vlen;
            conn_set_state(VAR_0, VAR_31);
            return;
        }
        VAR_0->item_malloced = true;
        VAR_0->ritem = VAR_0->item;
        VAR_0->rlbytes = VAR_34->pr.vlen;
        VAR_0->proxy_coro_ref = luaL_ref(VAR_6, VAR_33); /* COMMENT_48 */

        conn_set_state(VAR_0, VAR_36);
        return;
    } else {
        conn_set_state(VAR_0, VAR_37);
    }

    proxy_run_coroutine(VAR_32, VAR_0->resp, NULL, VAR_0);

    lua_settop(VAR_6, 0); /* COMMENT_49 */
}",memcached/76a6c363c18cfe7b6a1524ae64202ac9db330767/proto_proxy.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -70,12 +70,18 @@
     if (!multiget && pr.cmd_type == CMD_TYPE_GET && pr.has_space) {
         uint32_t keyoff = pr.tokens[pr.keytoken];
         while (pr.klen != 0) {
-            char temp[KEY_MAX_LENGTH + 30];
+            char temp[KEY_MAX_LENGTH + MAX_CMD_PREFIX + 30];
             char *cur = temp;
             // Core daemon can abort the entire command if one key is bad, but
             // we cannot from the proxy. Instead we have to inject errors into
             // the stream. This should, thankfully, be rare at least.
-            if (pr.klen > KEY_MAX_LENGTH) {
+            if (pr.tokens[pr.keytoken] > MAX_CMD_PREFIX) {
+                if (!resp_start(c)) {
+                    conn_set_state(c, conn_closing);
+                    return;
+                }
+                proxy_out_errstring(c->resp, PROXY_CLIENT_ERROR, ""malformed request"");
+            } else if (pr.klen > KEY_MAX_LENGTH) {
                 if (!resp_start(c)) {
                     conn_set_state(c, conn_closing);
                     return;","{'deleted_lines': ['            char temp[KEY_MAX_LENGTH + 30];', '            if (pr.klen > KEY_MAX_LENGTH) {'], 'added_lines': ['            char temp[KEY_MAX_LENGTH + MAX_CMD_PREFIX + 30];', '            if (pr.tokens[pr.keytoken] > MAX_CMD_PREFIX) {', '                if (!resp_start(c)) {', '                    conn_set_state(c, conn_closing);', '                    return;', '                }', '                proxy_out_errstring(c->resp, PROXY_CLIENT_ERROR, ""malformed request"");', '            } else if (pr.klen > KEY_MAX_LENGTH) {']}",True,"In Memcached before 1.6.22, a buffer overflow exists when processing multiget requests in proxy mode, if there are many spaces after the ""get"" substring.",7.5,HIGH,2,test,2023-07-28T17:32:16Z,4
CVE-2023-31439,['CWE-354'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N,1,systemd,"journalctl: verify that old entries are not sealed with too recent key

When verifying seals produced with forward secure sealing, the verification
currently does not check that old entries are only sealed with the key for
their epoch and not a more recent one. This missing check allows an attacker
to remove seals, and create new ones with the currently available key, and
verify will claim everything is in order, although all entries could have
been modified.

This resolves CVE-2023-31439.",540e35ef8ae259744ce18d272a232d56c2445279,https://github.com/systemd/systemd/commit/540e35ef8ae259744ce18d272a232d56c2445279,src/libsystemd/sd-journal/journal-verify.c,journal_file_verify,"int journal_file_verify(
JournalFile *f,
const char *key,
usec_t *first_contained, usec_t *last_validated, usec_t *last_contained,
bool show_progress) {
int r;
Object *o;
uint64_t p = 0, last_epoch = 0, last_tag_realtime = 0, last_sealed_realtime = 0;
uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0;
sd_id128_t entry_boot_id = {};  
bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, found_main_entry_array = false;
uint64_t n_objects = 0, n_entries = 0, n_data = 0, n_fields = 0, n_data_hash_tables = 0, n_field_hash_tables = 0, n_entry_arrays = 0, n_tags = 0;
usec_t last_usec = 0;
_cleanup_close_ int data_fd = -EBADF, entry_fd = -EBADF, entry_array_fd = -EBADF;
_cleanup_fclose_ FILE *data_fp = NULL, *entry_fp = NULL, *entry_array_fp = NULL;
MMapFileDescriptor *cache_data_fd = NULL, *cache_entry_fd = NULL, *cache_entry_array_fd = NULL;
unsigned i;
bool found_last = false;
const char *tmp_dir = NULL;
MMapCache *m;
#if HAVE_GCRYPT
uint64_t last_tag = 0;
#endif
assert(f);
if (key) {
#if HAVE_GCRYPT
r = journal_file_parse_verification_key(f, key);
if (r < 0) {
log_error(""Failed to parse seed."");
return r;
}
#else
return -EOPNOTSUPP;
#endif
} else if (JOURNAL_HEADER_SEALED(f->header))
return -ENOKEY;
r = var_tmp_dir(&tmp_dir);
if (r < 0) {
log_error_errno(r, ""Failed to determine temporary directory: %m"");
goto fail;
}
data_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);
if (data_fd < 0) {
r = log_error_errno(data_fd, ""Failed to create data file: %m"");
goto fail;
}
entry_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);
if (entry_fd < 0) {
r = log_error_errno(entry_fd, ""Failed to create entry file: %m"");
goto fail;
}
entry_array_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);
if (entry_array_fd < 0) {
r = log_error_errno(entry_array_fd,
""Failed to create entry array file: %m"");
goto fail;
}
m = mmap_cache_fd_cache(f->cache_fd);
cache_data_fd = mmap_cache_add_fd(m, data_fd, PROT_READ|PROT_WRITE);
if (!cache_data_fd) {
r = log_oom();
goto fail;
}
cache_entry_fd = mmap_cache_add_fd(m, entry_fd, PROT_READ|PROT_WRITE);
if (!cache_entry_fd) {
r = log_oom();
goto fail;
}
cache_entry_array_fd = mmap_cache_add_fd(m, entry_array_fd, PROT_READ|PROT_WRITE);
if (!cache_entry_array_fd) {
r = log_oom();
goto fail;
}
r = take_fdopen_unlocked(&data_fd, ""w+"", &data_fp);
if (r < 0) {
log_error_errno(r, ""Failed to open data file stream: %m"");
goto fail;
}
r = take_fdopen_unlocked(&entry_fd, ""w+"", &entry_fp);
if (r < 0) {
log_error_errno(r, ""Failed to open entry file stream: %m"");
goto fail;
}
r = take_fdopen_unlocked(&entry_array_fd, ""w+"", &entry_array_fp);
if (r < 0) {
log_error_errno(r, ""Failed to open entry array file stream: %m"");
goto fail;
}
if (le32toh(f->header->compatible_flags) & ~HEADER_COMPATIBLE_SUPPORTED) {
log_error(""Cannot verify file with unknown extensions."");
r = -EOPNOTSUPP;
goto fail;
}
for (i = 0; i < sizeof(f->header->reserved); i++)
if (f->header->reserved[i] != 0) {
error(offsetof(Header, reserved[i]), ""Reserved field is non-zero"");
r = -EBADMSG;
goto fail;
}
p = le64toh(f->header->header_size);
for (;;) {
if (le64toh(f->header->tail_object_offset) == 0)
break;
if (show_progress)
draw_progress(scale_progress(0x7FFF, p, le64toh(f->header->tail_object_offset)), &last_usec);
r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);
if (r < 0) {
error_errno(p, r, ""Invalid object: %m"");
goto fail;
}
if (p > le64toh(f->header->tail_object_offset)) {
error(offsetof(Header, tail_object_offset),
""Invalid tail object pointer (%""PRIu64"" > %""PRIu64"")"",
p,
le64toh(f->header->tail_object_offset));
r = -EBADMSG;
goto fail;
}
n_objects++;
r = journal_file_object_verify(f, p, o);
if (r < 0) {
error_errno(p, r, ""Invalid object contents: %m"");
goto fail;
}
if (!!(o->object.flags & OBJECT_COMPRESSED_XZ) +
!!(o->object.flags & OBJECT_COMPRESSED_LZ4) +
!!(o->object.flags & OBJECT_COMPRESSED_ZSTD) > 1) {
error(p, ""Object has multiple compression flags set (flags: 0x%x)"", o->object.flags);
r = -EINVAL;
goto fail;
}
if ((o->object.flags & OBJECT_COMPRESSED_XZ) && !JOURNAL_HEADER_COMPRESSED_XZ(f->header)) {
error(p, ""XZ compressed object in file without XZ compression"");
r = -EBADMSG;
goto fail;
}
if ((o->object.flags & OBJECT_COMPRESSED_LZ4) && !JOURNAL_HEADER_COMPRESSED_LZ4(f->header)) {
error(p, ""LZ4 compressed object in file without LZ4 compression"");
r = -EBADMSG;
goto fail;
}
if ((o->object.flags & OBJECT_COMPRESSED_ZSTD) && !JOURNAL_HEADER_COMPRESSED_ZSTD(f->header)) {
error(p, ""ZSTD compressed object in file without ZSTD compression"");
r = -EBADMSG;
goto fail;
}
switch (o->object.type) {
case OBJECT_DATA:
r = write_uint64(data_fp, p);
if (r < 0)
goto fail;
n_data++;
break;
case OBJECT_FIELD:
n_fields++;
break;
case OBJECT_ENTRY:
if (JOURNAL_HEADER_SEALED(f->header) && n_tags <= 0) {
error(p, ""First entry before first tag"");
r = -EBADMSG;
goto fail;
}
r = write_uint64(entry_fp, p);
if (r < 0)
goto fail;
if (le64toh(o->entry.realtime) < last_tag_realtime) {
error(p,
""Older entry after newer tag (%""PRIu64"" < %""PRIu64"")"",
le64toh(o->entry.realtime),
last_tag_realtime);
r = -EBADMSG;
goto fail;
}
if (!entry_seqnum_set &&
le64toh(o->entry.seqnum) != le64toh(f->header->head_entry_seqnum)) {
error(p,
""Head entry sequence number incorrect (%""PRIu64"" != %""PRIu64"")"",
le64toh(o->entry.seqnum),
le64toh(f->header->head_entry_seqnum));
r = -EBADMSG;
goto fail;
}
if (entry_seqnum_set &&
entry_seqnum >= le64toh(o->entry.seqnum)) {
error(p,
""Entry sequence number out of synchronization (%""PRIu64"" >= %""PRIu64"")"",
entry_seqnum,
le64toh(o->entry.seqnum));
r = -EBADMSG;
goto fail;
}
entry_seqnum = le64toh(o->entry.seqnum);
entry_seqnum_set = true;
if (entry_monotonic_set &&
sd_id128_equal(entry_boot_id, o->entry.boot_id) &&
entry_monotonic > le64toh(o->entry.monotonic)) {
error(p,
""Entry timestamp out of synchronization (%""PRIu64"" > %""PRIu64"")"",
entry_monotonic,
le64toh(o->entry.monotonic));
r = -EBADMSG;
goto fail;
}
entry_monotonic = le64toh(o->entry.monotonic);
entry_boot_id = o->entry.boot_id;
entry_monotonic_set = true;
if (!entry_realtime_set &&
le64toh(o->entry.realtime) != le64toh(f->header->head_entry_realtime)) {
error(p,
""Head entry realtime timestamp incorrect (%""PRIu64"" != %""PRIu64"")"",
le64toh(o->entry.realtime),
le64toh(f->header->head_entry_realtime));
r = -EBADMSG;
goto fail;
}
entry_realtime = le64toh(o->entry.realtime);
entry_realtime_set = true;
n_entries++;
break;
case OBJECT_DATA_HASH_TABLE:
r = verify_hash_table(o, p, &n_data_hash_tables,
le64toh(f->header->data_hash_table_offset),
le64toh(f->header->data_hash_table_size));
if (r < 0)
goto fail;
break;
case OBJECT_FIELD_HASH_TABLE:
r = verify_hash_table(o, p, &n_field_hash_tables,
le64toh(f->header->field_hash_table_offset),
le64toh(f->header->field_hash_table_size));
if (r < 0)
goto fail;
break;
case OBJECT_ENTRY_ARRAY:
r = write_uint64(entry_array_fp, p);
if (r < 0)
goto fail;
if (p == le64toh(f->header->entry_array_offset)) {
if (found_main_entry_array) {
error(p, ""More than one main entry array"");
r = -EBADMSG;
goto fail;
}
found_main_entry_array = true;
}
n_entry_arrays++;
break;
case OBJECT_TAG:
if (!JOURNAL_HEADER_SEALED(f->header)) {
error(p, ""Tag object in file without sealing"");
r = -EBADMSG;
goto fail;
}
if (le64toh(o->tag.seqnum) != n_tags + 1) {
error(p,
""Tag sequence number out of synchronization (%""PRIu64"" != %""PRIu64"")"",
le64toh(o->tag.seqnum),
n_tags + 1);
r = -EBADMSG;
goto fail;
}
if (le64toh(o->tag.epoch) < last_epoch) {
error(p,
""Epoch sequence out of synchronization (%""PRIu64"" < %""PRIu64"")"",
le64toh(o->tag.epoch),
last_epoch);
r = -EBADMSG;
goto fail;
}
#if HAVE_GCRYPT
if (JOURNAL_HEADER_SEALED(f->header)) {
uint64_t q, rt;
debug(p, ""Checking tag %""PRIu64""..."", le64toh(o->tag.seqnum));
rt = f->fss_start_usec + le64toh(o->tag.epoch) * f->fss_interval_usec;
if (entry_realtime_set && entry_realtime >= rt + f->fss_interval_usec) {
error(p,
""tag/entry realtime timestamp out of synchronization (%""PRIu64"" >= %""PRIu64"")"",
entry_realtime,
rt + f->fss_interval_usec);
r = -EBADMSG;
goto fail;
}
r = journal_file_fsprg_seek(f, le64toh(o->tag.epoch));
if (r < 0)
goto fail;
r = journal_file_hmac_start(f);
if (r < 0)
goto fail;
if (last_tag == 0) {
r = journal_file_hmac_put_header(f);
if (r < 0)
goto fail;
q = le64toh(f->header->header_size);
} else
q = last_tag;
while (q <= p) {
r = journal_file_move_to_object(f, OBJECT_UNUSED, q, &o);
if (r < 0)
goto fail;
r = journal_file_hmac_put_object(f, OBJECT_UNUSED, o, q);
if (r < 0)
goto fail;
q = q + ALIGN64(le64toh(o->object.size));
}
r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);
if (r < 0)
goto fail;
if (memcmp(o->tag.tag, gcry_md_read(f->hmac, 0), TAG_LENGTH) != 0) {
error(p, ""Tag failed verification"");
r = -EBADMSG;
goto fail;
}
f->hmac_running = false;
last_tag_realtime = rt;
last_sealed_realtime = entry_realtime;
}
last_tag = p + ALIGN64(le64toh(o->object.size));
#endif
last_epoch = le64toh(o->tag.epoch);
n_tags++;
break;
}
if (p == le64toh(f->header->tail_object_offset)) {
found_last = true;
break;
}
p = p + ALIGN64(le64toh(o->object.size));
};
if (!found_last && le64toh(f->header->tail_object_offset) != 0) {
error(le64toh(f->header->tail_object_offset),
""Tail object pointer dead (%""PRIu64"" != 0)"",
le64toh(f->header->tail_object_offset));
r = -EBADMSG;
goto fail;
}
if (n_objects != le64toh(f->header->n_objects)) {
error(offsetof(Header, n_objects),
""Object number mismatch (%""PRIu64"" != %""PRIu64"")"",
n_objects,
le64toh(f->header->n_objects));
r = -EBADMSG;
goto fail;
}
if (n_entries != le64toh(f->header->n_entries)) {
error(offsetof(Header, n_entries),
""Entry number mismatch (%""PRIu64"" != %""PRIu64"")"",
n_entries,
le64toh(f->header->n_entries));
r = -EBADMSG;
goto fail;
}
if (JOURNAL_HEADER_CONTAINS(f->header, n_data) &&
n_data != le64toh(f->header->n_data)) {
error(offsetof(Header, n_data),
""Data number mismatch (%""PRIu64"" != %""PRIu64"")"",
n_data,
le64toh(f->header->n_data));
r = -EBADMSG;
goto fail;
}
if (JOURNAL_HEADER_CONTAINS(f->header, n_fields) &&
n_fields != le64toh(f->header->n_fields)) {
error(offsetof(Header, n_fields),
""Field number mismatch (%""PRIu64"" != %""PRIu64"")"",
n_fields,
le64toh(f->header->n_fields));
r = -EBADMSG;
goto fail;
}
if (JOURNAL_HEADER_CONTAINS(f->header, n_tags) &&
n_tags != le64toh(f->header->n_tags)) {
error(offsetof(Header, n_tags),
""Tag number mismatch (%""PRIu64"" != %""PRIu64"")"",
n_tags,
le64toh(f->header->n_tags));
r = -EBADMSG;
goto fail;
}
if (JOURNAL_HEADER_CONTAINS(f->header, n_entry_arrays) &&
n_entry_arrays != le64toh(f->header->n_entry_arrays)) {
error(offsetof(Header, n_entry_arrays),
""Entry array number mismatch (%""PRIu64"" != %""PRIu64"")"",
n_entry_arrays,
le64toh(f->header->n_entry_arrays));
r = -EBADMSG;
goto fail;
}
if (!found_main_entry_array && le64toh(f->header->entry_array_offset) != 0) {
error(0, ""Missing main entry array"");
r = -EBADMSG;
goto fail;
}
if (entry_seqnum_set &&
entry_seqnum != le64toh(f->header->tail_entry_seqnum)) {
error(offsetof(Header, tail_entry_seqnum),
""Tail entry sequence number incorrect (%""PRIu64"" != %""PRIu64"")"",
entry_seqnum,
le64toh(f->header->tail_entry_seqnum));
r = -EBADMSG;
goto fail;
}
if (entry_monotonic_set &&
(sd_id128_equal(entry_boot_id, f->header->tail_entry_boot_id) &&
JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(f->header) &&
entry_monotonic != le64toh(f->header->tail_entry_monotonic))) {
error(0,
""Invalid tail monotonic timestamp (%""PRIu64"" != %""PRIu64"")"",
entry_monotonic,
le64toh(f->header->tail_entry_monotonic));
r = -EBADMSG;
goto fail;
}
if (entry_realtime_set && entry_realtime != le64toh(f->header->tail_entry_realtime)) {
error(0,
""Invalid tail realtime timestamp (%""PRIu64"" != %""PRIu64"")"",
entry_realtime,
le64toh(f->header->tail_entry_realtime));
r = -EBADMSG;
goto fail;
}
if (fflush(data_fp) != 0) {
r = log_error_errno(errno, ""Failed to flush data file stream: %m"");
goto fail;
}
if (fflush(entry_fp) != 0) {
r = log_error_errno(errno, ""Failed to flush entry file stream: %m"");
goto fail;
}
if (fflush(entry_array_fp) != 0) {
r = log_error_errno(errno, ""Failed to flush entry array file stream: %m"");
goto fail;
}
r = verify_entry_array(f,
cache_data_fd, n_data,
cache_entry_fd, n_entries,
cache_entry_array_fd, n_entry_arrays,
&last_usec,
show_progress);
if (r < 0)
goto fail;
r = verify_data_hash_table(f,
cache_data_fd, n_data,
cache_entry_fd, n_entries,
cache_entry_array_fd, n_entry_arrays,
&last_usec,
show_progress);
if (r < 0)
goto fail;
if (show_progress)
flush_progress();
mmap_cache_fd_free(cache_data_fd);
mmap_cache_fd_free(cache_entry_fd);
mmap_cache_fd_free(cache_entry_array_fd);
if (first_contained)
*first_contained = le64toh(f->header->head_entry_realtime);
if (last_validated)
*last_validated = last_sealed_realtime;
if (last_contained)
*last_contained = le64toh(f->header->tail_entry_realtime);
return 0;
fail:
if (show_progress)
flush_progress();
log_error(""File corruption detected at %s:%""PRIu64"" (of %""PRIu64"" bytes, %""PRIu64""%%)."",
f->path,
p,
(uint64_t) f->last_stat.st_size,
100U * p / (uint64_t) f->last_stat.st_size);
if (cache_data_fd)
mmap_cache_fd_free(cache_data_fd);
if (cache_entry_fd)
mmap_cache_fd_free(cache_entry_fd);
if (cache_entry_array_fd)
mmap_cache_fd_free(cache_entry_array_fd);
return r;
}","int journal_file_verify(
JournalFile *VAR_0,
const char *VAR_1,
usec_t *VAR_2, usec_t *VAR_3, usec_t *VAR_4,
bool VAR_5) {
int VAR_6;
Object *VAR_7;
uint64_t VAR_8 = 0, VAR_9 = 0, VAR_10 = 0, VAR_11 = 0;
uint64_t VAR_12 = 0, VAR_13 = 0, VAR_14 = 0;
sd_id128_t VAR_15 = {};  
bool VAR_16 = false, VAR_17 = false, VAR_18 = false, VAR_19 = false;
uint64_t VAR_20 = 0, VAR_21 = 0, VAR_22 = 0, VAR_23 = 0, VAR_24 = 0, VAR_25 = 0, VAR_26 = 0, VAR_27 = 0;
usec_t VAR_28 = 0;
_cleanup_close_ int VAR_29 = -VAR_30, VAR_31 = -VAR_30, VAR_32 = -VAR_30;
_cleanup_fclose_ VAR_33 *VAR_34 = NULL, *VAR_35 = NULL, *VAR_36 = NULL;
MMapFileDescriptor *VAR_37 = NULL, *VAR_38 = NULL, *VAR_39 = NULL;
unsigned VAR_40;
bool VAR_41 = false;
const char *VAR_42 = NULL;
MMapCache *VAR_43;
#if VAR_44
uint64_t VAR_45 = 0;
#endif
assert(VAR_0);
if (VAR_1) {
#if VAR_44
VAR_6 = journal_file_parse_verification_key(VAR_0, VAR_1);
if (VAR_6 < 0) {
log_error(""Failed to parse seed."");
return VAR_6;
}
#else
return -VAR_46;
#endif
} else if (JOURNAL_HEADER_SEALED(VAR_0->header))
return -VAR_47;
VAR_6 = var_tmp_dir(&VAR_42);
if (VAR_6 < 0) {
log_error_errno(VAR_6, ""Failed to determine temporary directory: %m"");
goto fail;
}
VAR_29 = open_tmpfile_unlinkable(VAR_42, VAR_48 | VAR_49);
if (VAR_29 < 0) {
VAR_6 = log_error_errno(VAR_29, ""Failed to create data file: %m"");
goto fail;
}
VAR_31 = open_tmpfile_unlinkable(VAR_42, VAR_48 | VAR_49);
if (VAR_31 < 0) {
VAR_6 = log_error_errno(VAR_31, ""Failed to create entry file: %m"");
goto fail;
}
VAR_32 = open_tmpfile_unlinkable(VAR_42, VAR_48 | VAR_49);
if (VAR_32 < 0) {
VAR_6 = log_error_errno(VAR_32,
""Failed to create entry array file: %m"");
goto fail;
}
VAR_43 = mmap_cache_fd_cache(VAR_0->cache_fd);
VAR_37 = mmap_cache_add_fd(VAR_43, VAR_29, VAR_50|VAR_51);
if (!VAR_37) {
VAR_6 = log_oom();
goto fail;
}
VAR_38 = mmap_cache_add_fd(VAR_43, VAR_31, VAR_50|VAR_51);
if (!VAR_38) {
VAR_6 = log_oom();
goto fail;
}
VAR_39 = mmap_cache_add_fd(VAR_43, VAR_32, VAR_50|VAR_51);
if (!VAR_39) {
VAR_6 = log_oom();
goto fail;
}
VAR_6 = take_fdopen_unlocked(&VAR_29, ""w+"", &VAR_34);
if (VAR_6 < 0) {
log_error_errno(VAR_6, ""Failed to open data file stream: %m"");
goto fail;
}
VAR_6 = take_fdopen_unlocked(&VAR_31, ""w+"", &VAR_35);
if (VAR_6 < 0) {
log_error_errno(VAR_6, ""Failed to open entry file stream: %m"");
goto fail;
}
VAR_6 = take_fdopen_unlocked(&VAR_32, ""w+"", &VAR_36);
if (VAR_6 < 0) {
log_error_errno(VAR_6, ""Failed to open entry array file stream: %m"");
goto fail;
}
if (le32toh(VAR_0->header->compatible_flags) & ~VAR_52) {
log_error(""Cannot verify file with unknown extensions."");
VAR_6 = -VAR_46;
goto fail;
}
for (VAR_40 = 0; VAR_40 < sizeof(VAR_0->header->reserved); VAR_40++)
if (VAR_0->header->reserved[VAR_40] != 0) {
error(offsetof(VAR_53, VAR_54[VAR_40]), ""Reserved field is non-zero"");
VAR_6 = -VAR_55;
goto fail;
}
VAR_8 = le64toh(VAR_0->header->header_size);
for (;;) {
if (le64toh(VAR_0->header->tail_object_offset) == 0)
break;
if (VAR_5)
draw_progress(scale_progress(0x7FFF, VAR_8, le64toh(VAR_0->header->tail_object_offset)), &VAR_28);
VAR_6 = journal_file_move_to_object(VAR_0, VAR_56, VAR_8, &VAR_7);
if (VAR_6 < 0) {
error_errno(VAR_8, VAR_6, ""Invalid object: %m"");
goto fail;
}
if (VAR_8 > le64toh(VAR_0->header->tail_object_offset)) {
error(offsetof(VAR_53, VAR_57),
""Invalid tail object pointer (%""VAR_58"" > %""VAR_58"")"",
VAR_8,
le64toh(VAR_0->header->tail_object_offset));
VAR_6 = -VAR_55;
goto fail;
}
VAR_20++;
VAR_6 = journal_file_object_verify(VAR_0, VAR_8, VAR_7);
if (VAR_6 < 0) {
error_errno(VAR_8, VAR_6, ""Invalid object contents: %m"");
goto fail;
}
if (!!(VAR_7->object.flags & VAR_59) +
!!(VAR_7->object.flags & VAR_60) +
!!(VAR_7->object.flags & VAR_61) > 1) {
error(VAR_8, ""Object has multiple compression flags set (flags: 0x%x)"", VAR_7->object.flags);
VAR_6 = -VAR_62;
goto fail;
}
if ((VAR_7->object.flags & VAR_59) && !JOURNAL_HEADER_COMPRESSED_XZ(VAR_0->header)) {
error(VAR_8, ""XZ compressed object in file without XZ compression"");
VAR_6 = -VAR_55;
goto fail;
}
if ((VAR_7->object.flags & VAR_60) && !JOURNAL_HEADER_COMPRESSED_LZ4(VAR_0->header)) {
error(VAR_8, ""LZ4 compressed object in file without LZ4 compression"");
VAR_6 = -VAR_55;
goto fail;
}
if ((VAR_7->object.flags & VAR_61) && !JOURNAL_HEADER_COMPRESSED_ZSTD(VAR_0->header)) {
error(VAR_8, ""ZSTD compressed object in file without ZSTD compression"");
VAR_6 = -VAR_55;
goto fail;
}
switch (VAR_7->object.type) {
case VAR_63:
VAR_6 = write_uint64(VAR_34, VAR_8);
if (VAR_6 < 0)
goto fail;
VAR_22++;
break;
case VAR_64:
VAR_23++;
break;
case VAR_65:
if (JOURNAL_HEADER_SEALED(VAR_0->header) && VAR_27 <= 0) {
error(VAR_8, ""First entry before first tag"");
VAR_6 = -VAR_55;
goto fail;
}
VAR_6 = write_uint64(VAR_35, VAR_8);
if (VAR_6 < 0)
goto fail;
if (le64toh(VAR_7->entry.realtime) < VAR_10) {
error(VAR_8,
""Older entry after newer tag (%""VAR_58"" < %""VAR_58"")"",
le64toh(VAR_7->entry.realtime),
VAR_10);
VAR_6 = -VAR_55;
goto fail;
}
if (!VAR_16 &&
le64toh(VAR_7->entry.seqnum) != le64toh(VAR_0->header->head_entry_seqnum)) {
error(VAR_8,
""Head entry sequence number incorrect (%""VAR_58"" != %""VAR_58"")"",
le64toh(VAR_7->entry.seqnum),
le64toh(VAR_0->header->head_entry_seqnum));
VAR_6 = -VAR_55;
goto fail;
}
if (VAR_16 &&
VAR_12 >= le64toh(VAR_7->entry.seqnum)) {
error(VAR_8,
""Entry sequence number out of synchronization (%""VAR_58"" >= %""VAR_58"")"",
VAR_12,
le64toh(VAR_7->entry.seqnum));
VAR_6 = -VAR_55;
goto fail;
}
VAR_12 = le64toh(VAR_7->entry.seqnum);
VAR_16 = true;
if (VAR_17 &&
sd_id128_equal(VAR_15, VAR_7->entry.boot_id) &&
VAR_13 > le64toh(VAR_7->entry.monotonic)) {
error(VAR_8,
""Entry timestamp out of synchronization (%""VAR_58"" > %""VAR_58"")"",
VAR_13,
le64toh(VAR_7->entry.monotonic));
VAR_6 = -VAR_55;
goto fail;
}
VAR_13 = le64toh(VAR_7->entry.monotonic);
VAR_15 = VAR_7->entry.boot_id;
VAR_17 = true;
if (!VAR_18 &&
le64toh(VAR_7->entry.realtime) != le64toh(VAR_0->header->head_entry_realtime)) {
error(VAR_8,
""Head entry realtime timestamp incorrect (%""VAR_58"" != %""VAR_58"")"",
le64toh(VAR_7->entry.realtime),
le64toh(VAR_0->header->head_entry_realtime));
VAR_6 = -VAR_55;
goto fail;
}
VAR_14 = le64toh(VAR_7->entry.realtime);
VAR_18 = true;
VAR_21++;
break;
case VAR_66:
VAR_6 = verify_hash_table(VAR_7, VAR_8, &VAR_24,
le64toh(VAR_0->header->data_hash_table_offset),
le64toh(VAR_0->header->data_hash_table_size));
if (VAR_6 < 0)
goto fail;
break;
case VAR_67:
VAR_6 = verify_hash_table(VAR_7, VAR_8, &VAR_25,
le64toh(VAR_0->header->field_hash_table_offset),
le64toh(VAR_0->header->field_hash_table_size));
if (VAR_6 < 0)
goto fail;
break;
case VAR_68:
VAR_6 = write_uint64(VAR_36, VAR_8);
if (VAR_6 < 0)
goto fail;
if (VAR_8 == le64toh(VAR_0->header->entry_array_offset)) {
if (VAR_19) {
error(VAR_8, ""More than one main entry array"");
VAR_6 = -VAR_55;
goto fail;
}
VAR_19 = true;
}
VAR_26++;
break;
case VAR_69:
if (!JOURNAL_HEADER_SEALED(VAR_0->header)) {
error(VAR_8, ""Tag object in file without sealing"");
VAR_6 = -VAR_55;
goto fail;
}
if (le64toh(VAR_7->tag.seqnum) != VAR_27 + 1) {
error(VAR_8,
""Tag sequence number out of synchronization (%""VAR_58"" != %""VAR_58"")"",
le64toh(VAR_7->tag.seqnum),
VAR_27 + 1);
VAR_6 = -VAR_55;
goto fail;
}
if (le64toh(VAR_7->tag.epoch) < VAR_9) {
error(VAR_8,
""Epoch sequence out of synchronization (%""VAR_58"" < %""VAR_58"")"",
le64toh(VAR_7->tag.epoch),
VAR_9);
VAR_6 = -VAR_55;
goto fail;
}
#if VAR_44
if (JOURNAL_HEADER_SEALED(VAR_0->header)) {
uint64_t VAR_70, VAR_71;
debug(VAR_8, ""Checking tag %""VAR_58""..."", le64toh(VAR_7->tag.seqnum));
VAR_71 = VAR_0->fss_start_usec + le64toh(VAR_7->tag.epoch) * VAR_0->fss_interval_usec;
if (VAR_18 && VAR_14 >= VAR_71 + VAR_0->fss_interval_usec) {
error(VAR_8,
""tag/entry realtime timestamp out of synchronization (%""VAR_58"" >= %""VAR_58"")"",
VAR_14,
VAR_71 + VAR_0->fss_interval_usec);
VAR_6 = -VAR_55;
goto fail;
}
VAR_6 = journal_file_fsprg_seek(VAR_0, le64toh(VAR_7->tag.epoch));
if (VAR_6 < 0)
goto fail;
VAR_6 = journal_file_hmac_start(VAR_0);
if (VAR_6 < 0)
goto fail;
if (VAR_45 == 0) {
VAR_6 = journal_file_hmac_put_header(VAR_0);
if (VAR_6 < 0)
goto fail;
VAR_70 = le64toh(VAR_0->header->header_size);
} else
VAR_70 = VAR_45;
while (VAR_70 <= VAR_8) {
VAR_6 = journal_file_move_to_object(VAR_0, VAR_56, VAR_70, &VAR_7);
if (VAR_6 < 0)
goto fail;
VAR_6 = journal_file_hmac_put_object(VAR_0, VAR_56, VAR_7, VAR_70);
if (VAR_6 < 0)
goto fail;
VAR_70 = VAR_70 + ALIGN64(le64toh(VAR_7->object.size));
}
VAR_6 = journal_file_move_to_object(VAR_0, VAR_56, VAR_8, &VAR_7);
if (VAR_6 < 0)
goto fail;
if (memcmp(VAR_7->tag.tag, gcry_md_read(VAR_0->hmac, 0), VAR_72) != 0) {
error(VAR_8, ""Tag failed verification"");
VAR_6 = -VAR_55;
goto fail;
}
VAR_0->hmac_running = false;
VAR_10 = VAR_71;
VAR_11 = VAR_14;
}
VAR_45 = VAR_8 + ALIGN64(le64toh(VAR_7->object.size));
#endif
VAR_9 = le64toh(VAR_7->tag.epoch);
VAR_27++;
break;
}
if (VAR_8 == le64toh(VAR_0->header->tail_object_offset)) {
VAR_41 = true;
break;
}
VAR_8 = VAR_8 + ALIGN64(le64toh(VAR_7->object.size));
};
if (!VAR_41 && le64toh(VAR_0->header->tail_object_offset) != 0) {
error(le64toh(VAR_0->header->tail_object_offset),
""Tail object pointer dead (%""VAR_58"" != 0)"",
le64toh(VAR_0->header->tail_object_offset));
VAR_6 = -VAR_55;
goto fail;
}
if (VAR_20 != le64toh(VAR_0->header->n_objects)) {
error(offsetof(VAR_53, VAR_20),
""Object number mismatch (%""VAR_58"" != %""VAR_58"")"",
VAR_20,
le64toh(VAR_0->header->n_objects));
VAR_6 = -VAR_55;
goto fail;
}
if (VAR_21 != le64toh(VAR_0->header->n_entries)) {
error(offsetof(VAR_53, VAR_21),
""Entry number mismatch (%""VAR_58"" != %""VAR_58"")"",
VAR_21,
le64toh(VAR_0->header->n_entries));
VAR_6 = -VAR_55;
goto fail;
}
if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_22) &&
VAR_22 != le64toh(VAR_0->header->n_data)) {
error(offsetof(VAR_53, VAR_22),
""Data number mismatch (%""VAR_58"" != %""VAR_58"")"",
VAR_22,
le64toh(VAR_0->header->n_data));
VAR_6 = -VAR_55;
goto fail;
}
if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_23) &&
VAR_23 != le64toh(VAR_0->header->n_fields)) {
error(offsetof(VAR_53, VAR_23),
""Field number mismatch (%""VAR_58"" != %""VAR_58"")"",
VAR_23,
le64toh(VAR_0->header->n_fields));
VAR_6 = -VAR_55;
goto fail;
}
if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_27) &&
VAR_27 != le64toh(VAR_0->header->n_tags)) {
error(offsetof(VAR_53, VAR_27),
""Tag number mismatch (%""VAR_58"" != %""VAR_58"")"",
VAR_27,
le64toh(VAR_0->header->n_tags));
VAR_6 = -VAR_55;
goto fail;
}
if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_26) &&
VAR_26 != le64toh(VAR_0->header->n_entry_arrays)) {
error(offsetof(VAR_53, VAR_26),
""Entry array number mismatch (%""VAR_58"" != %""VAR_58"")"",
VAR_26,
le64toh(VAR_0->header->n_entry_arrays));
VAR_6 = -VAR_55;
goto fail;
}
if (!VAR_19 && le64toh(VAR_0->header->entry_array_offset) != 0) {
error(0, ""Missing main entry array"");
VAR_6 = -VAR_55;
goto fail;
}
if (VAR_16 &&
VAR_12 != le64toh(VAR_0->header->tail_entry_seqnum)) {
error(offsetof(VAR_53, VAR_73),
""Tail entry sequence number incorrect (%""VAR_58"" != %""VAR_58"")"",
VAR_12,
le64toh(VAR_0->header->tail_entry_seqnum));
VAR_6 = -VAR_55;
goto fail;
}
if (VAR_17 &&
(sd_id128_equal(VAR_15, VAR_0->header->tail_entry_boot_id) &&
JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(VAR_0->header) &&
VAR_13 != le64toh(VAR_0->header->tail_entry_monotonic))) {
error(0,
""Invalid tail monotonic timestamp (%""VAR_58"" != %""VAR_58"")"",
VAR_13,
le64toh(VAR_0->header->tail_entry_monotonic));
VAR_6 = -VAR_55;
goto fail;
}
if (VAR_18 && VAR_14 != le64toh(VAR_0->header->tail_entry_realtime)) {
error(0,
""Invalid tail realtime timestamp (%""VAR_58"" != %""VAR_58"")"",
VAR_14,
le64toh(VAR_0->header->tail_entry_realtime));
VAR_6 = -VAR_55;
goto fail;
}
if (fflush(VAR_34) != 0) {
VAR_6 = log_error_errno(VAR_74, ""Failed to flush data file stream: %m"");
goto fail;
}
if (fflush(VAR_35) != 0) {
VAR_6 = log_error_errno(VAR_74, ""Failed to flush entry file stream: %m"");
goto fail;
}
if (fflush(VAR_36) != 0) {
VAR_6 = log_error_errno(VAR_74, ""Failed to flush entry array file stream: %m"");
goto fail;
}
VAR_6 = verify_entry_array(VAR_0,
VAR_37, VAR_22,
VAR_38, VAR_21,
VAR_39, VAR_26,
&VAR_28,
VAR_5);
if (VAR_6 < 0)
goto fail;
VAR_6 = verify_data_hash_table(VAR_0,
VAR_37, VAR_22,
VAR_38, VAR_21,
VAR_39, VAR_26,
&VAR_28,
VAR_5);
if (VAR_6 < 0)
goto fail;
if (VAR_5)
flush_progress();
mmap_cache_fd_free(VAR_37);
mmap_cache_fd_free(VAR_38);
mmap_cache_fd_free(VAR_39);
if (VAR_2)
*VAR_2 = le64toh(VAR_0->header->head_entry_realtime);
if (VAR_3)
*VAR_3 = VAR_11;
if (VAR_4)
*VAR_4 = le64toh(VAR_0->header->tail_entry_realtime);
return 0;
fail:
if (VAR_5)
flush_progress();
log_error(""File corruption detected at %s:%""VAR_58"" (of %""VAR_58"" bytes, %""VAR_58""%%)."",
VAR_0->path,
VAR_8,
(uint64_t) VAR_0->last_stat.st_size,
100U * VAR_8 / (uint64_t) VAR_0->last_stat.st_size);
if (VAR_37)
mmap_cache_fd_free(VAR_37);
if (VAR_38)
mmap_cache_fd_free(VAR_38);
if (VAR_39)
mmap_cache_fd_free(VAR_39);
return VAR_6;
}",systemd/540e35ef8ae259744ce18d272a232d56c2445279/journal-verify.c/vul/before/0.json,"int journal_file_verify(
                JournalFile *f,
                const char *key,
                usec_t *first_contained, usec_t *last_validated, usec_t *last_contained,
                bool show_progress) {
        int r;
        Object *o;
        uint64_t p = 0, last_epoch = 0, last_tag_realtime = 0, last_sealed_realtime = 0;

        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0, min_entry_realtime = 0, max_entry_realtime = 0;
        sd_id128_t entry_boot_id = {};  /* Unnecessary initialization to appease gcc */
        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, min_entry_realtime_set = false, found_main_entry_array = false;
        uint64_t n_objects = 0, n_entries = 0, n_data = 0, n_fields = 0, n_data_hash_tables = 0, n_field_hash_tables = 0, n_entry_arrays = 0, n_tags = 0;
        usec_t last_usec = 0;
        _cleanup_close_ int data_fd = -EBADF, entry_fd = -EBADF, entry_array_fd = -EBADF;
        _cleanup_fclose_ FILE *data_fp = NULL, *entry_fp = NULL, *entry_array_fp = NULL;
        MMapFileDescriptor *cache_data_fd = NULL, *cache_entry_fd = NULL, *cache_entry_array_fd = NULL;
        unsigned i;
        bool found_last = false;
        const char *tmp_dir = NULL;
        MMapCache *m;

#if HAVE_GCRYPT
        uint64_t last_tag = 0;
#endif
        assert(f);

        if (key) {
#if HAVE_GCRYPT
                r = journal_file_parse_verification_key(f, key);
                if (r < 0) {
                        log_error(""Failed to parse seed."");
                        return r;
                }
#else
                return -EOPNOTSUPP;
#endif
        } else if (JOURNAL_HEADER_SEALED(f->header))
                return -ENOKEY;

        r = var_tmp_dir(&tmp_dir);
        if (r < 0) {
                log_error_errno(r, ""Failed to determine temporary directory: %m"");
                goto fail;
        }

        data_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);
        if (data_fd < 0) {
                r = log_error_errno(data_fd, ""Failed to create data file: %m"");
                goto fail;
        }

        entry_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);
        if (entry_fd < 0) {
                r = log_error_errno(entry_fd, ""Failed to create entry file: %m"");
                goto fail;
        }

        entry_array_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);
        if (entry_array_fd < 0) {
                r = log_error_errno(entry_array_fd,
                                    ""Failed to create entry array file: %m"");
                goto fail;
        }

        m = mmap_cache_fd_cache(f->cache_fd);
        cache_data_fd = mmap_cache_add_fd(m, data_fd, PROT_READ|PROT_WRITE);
        if (!cache_data_fd) {
                r = log_oom();
                goto fail;
        }

        cache_entry_fd = mmap_cache_add_fd(m, entry_fd, PROT_READ|PROT_WRITE);
        if (!cache_entry_fd) {
                r = log_oom();
                goto fail;
        }

        cache_entry_array_fd = mmap_cache_add_fd(m, entry_array_fd, PROT_READ|PROT_WRITE);
        if (!cache_entry_array_fd) {
                r = log_oom();
                goto fail;
        }

        r = take_fdopen_unlocked(&data_fd, ""w+"", &data_fp);
        if (r < 0) {
                log_error_errno(r, ""Failed to open data file stream: %m"");
                goto fail;
        }

        r = take_fdopen_unlocked(&entry_fd, ""w+"", &entry_fp);
        if (r < 0) {
                log_error_errno(r, ""Failed to open entry file stream: %m"");
                goto fail;
        }

        r = take_fdopen_unlocked(&entry_array_fd, ""w+"", &entry_array_fp);
        if (r < 0) {
                log_error_errno(r, ""Failed to open entry array file stream: %m"");
                goto fail;
        }

        if (le32toh(f->header->compatible_flags) & ~HEADER_COMPATIBLE_SUPPORTED) {
                log_error(""Cannot verify file with unknown extensions."");
                r = -EOPNOTSUPP;
                goto fail;
        }

        for (i = 0; i < sizeof(f->header->reserved); i++)
                if (f->header->reserved[i] != 0) {
                        error(offsetof(Header, reserved[i]), ""Reserved field is non-zero"");
                        r = -EBADMSG;
                        goto fail;
                }

        /* First iteration: we go through all objects, verify the
         * superficial structure, headers, hashes. */

        p = le64toh(f->header->header_size);
        for (;;) {
                /* Early exit if there are no objects in the file, at all */
                if (le64toh(f->header->tail_object_offset) == 0)
                        break;

                if (show_progress)
                        draw_progress(scale_progress(0x7FFF, p, le64toh(f->header->tail_object_offset)), &last_usec);

                r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);
                if (r < 0) {
                        error_errno(p, r, ""Invalid object: %m"");
                        goto fail;
                }

                if (p > le64toh(f->header->tail_object_offset)) {
                        error(offsetof(Header, tail_object_offset),
                              ""Invalid tail object pointer (%""PRIu64"" > %""PRIu64"")"",
                              p,
                              le64toh(f->header->tail_object_offset));
                        r = -EBADMSG;
                        goto fail;
                }

                n_objects++;

                r = journal_file_object_verify(f, p, o);
                if (r < 0) {
                        error_errno(p, r, ""Invalid object contents: %m"");
                        goto fail;
                }

                if (!!(o->object.flags & OBJECT_COMPRESSED_XZ) +
                    !!(o->object.flags & OBJECT_COMPRESSED_LZ4) +
                    !!(o->object.flags & OBJECT_COMPRESSED_ZSTD) > 1) {
                        error(p, ""Object has multiple compression flags set (flags: 0x%x)"", o->object.flags);
                        r = -EINVAL;
                        goto fail;
                }

                if ((o->object.flags & OBJECT_COMPRESSED_XZ) && !JOURNAL_HEADER_COMPRESSED_XZ(f->header)) {
                        error(p, ""XZ compressed object in file without XZ compression"");
                        r = -EBADMSG;
                        goto fail;
                }

                if ((o->object.flags & OBJECT_COMPRESSED_LZ4) && !JOURNAL_HEADER_COMPRESSED_LZ4(f->header)) {
                        error(p, ""LZ4 compressed object in file without LZ4 compression"");
                        r = -EBADMSG;
                        goto fail;
                }

                if ((o->object.flags & OBJECT_COMPRESSED_ZSTD) && !JOURNAL_HEADER_COMPRESSED_ZSTD(f->header)) {
                        error(p, ""ZSTD compressed object in file without ZSTD compression"");
                        r = -EBADMSG;
                        goto fail;
                }

                switch (o->object.type) {

                case OBJECT_DATA:
                        r = write_uint64(data_fp, p);
                        if (r < 0)
                                goto fail;

                        n_data++;
                        break;

                case OBJECT_FIELD:
                        n_fields++;
                        break;

                case OBJECT_ENTRY:
                        if (JOURNAL_HEADER_SEALED(f->header) && n_tags <= 0) {
                                error(p, ""First entry before first tag"");
                                r = -EBADMSG;
                                goto fail;
                        }

                        r = write_uint64(entry_fp, p);
                        if (r < 0)
                                goto fail;

                        if (le64toh(o->entry.realtime) < last_tag_realtime) {
                                error(p,
                                      ""Older entry after newer tag (%""PRIu64"" < %""PRIu64"")"",
                                      le64toh(o->entry.realtime),
                                      last_tag_realtime);
                                r = -EBADMSG;
                                goto fail;
                        }

                        if (!entry_seqnum_set &&
                            le64toh(o->entry.seqnum) != le64toh(f->header->head_entry_seqnum)) {
                                error(p,
                                      ""Head entry sequence number incorrect (%""PRIu64"" != %""PRIu64"")"",
                                      le64toh(o->entry.seqnum),
                                      le64toh(f->header->head_entry_seqnum));
                                r = -EBADMSG;
                                goto fail;
                        }

                        if (entry_seqnum_set &&
                            entry_seqnum >= le64toh(o->entry.seqnum)) {
                                error(p,
                                      ""Entry sequence number out of synchronization (%""PRIu64"" >= %""PRIu64"")"",
                                      entry_seqnum,
                                      le64toh(o->entry.seqnum));
                                r = -EBADMSG;
                                goto fail;
                        }

                        entry_seqnum = le64toh(o->entry.seqnum);
                        entry_seqnum_set = true;

                        if (entry_monotonic_set &&
                            sd_id128_equal(entry_boot_id, o->entry.boot_id) &&
                            entry_monotonic > le64toh(o->entry.monotonic)) {
                                error(p,
                                      ""Entry timestamp out of synchronization (%""PRIu64"" > %""PRIu64"")"",
                                      entry_monotonic,
                                      le64toh(o->entry.monotonic));
                                r = -EBADMSG;
                                goto fail;
                        }

                        entry_monotonic = le64toh(o->entry.monotonic);
                        entry_boot_id = o->entry.boot_id;
                        entry_monotonic_set = true;

                        if (!entry_realtime_set &&
                            le64toh(o->entry.realtime) != le64toh(f->header->head_entry_realtime)) {
                                error(p,
                                      ""Head entry realtime timestamp incorrect (%""PRIu64"" != %""PRIu64"")"",
                                      le64toh(o->entry.realtime),
                                      le64toh(f->header->head_entry_realtime));
                                r = -EBADMSG;
                                goto fail;
                        }

                        entry_realtime = le64toh(o->entry.realtime);
                        entry_realtime_set = true;

                        if (max_entry_realtime < le64toh(o->entry.realtime))
                                max_entry_realtime = le64toh(o->entry.realtime);
                        if (!min_entry_realtime_set || min_entry_realtime > le64toh(o->entry.realtime)) {
                                min_entry_realtime = le64toh(o->entry.realtime);
                                min_entry_realtime_set = true;
                        }

                        n_entries++;
                        break;

                case OBJECT_DATA_HASH_TABLE:
                        r = verify_hash_table(o, p, &n_data_hash_tables,
                                              le64toh(f->header->data_hash_table_offset),
                                              le64toh(f->header->data_hash_table_size));
                        if (r < 0)
                                goto fail;
                        break;

                case OBJECT_FIELD_HASH_TABLE:
                        r = verify_hash_table(o, p, &n_field_hash_tables,
                                              le64toh(f->header->field_hash_table_offset),
                                              le64toh(f->header->field_hash_table_size));
                        if (r < 0)
                                goto fail;

                        break;

                case OBJECT_ENTRY_ARRAY:
                        r = write_uint64(entry_array_fp, p);
                        if (r < 0)
                                goto fail;

                        if (p == le64toh(f->header->entry_array_offset)) {
                                if (found_main_entry_array) {
                                        error(p, ""More than one main entry array"");
                                        r = -EBADMSG;
                                        goto fail;
                                }

                                found_main_entry_array = true;
                        }

                        n_entry_arrays++;
                        break;

                case OBJECT_TAG:
                        if (!JOURNAL_HEADER_SEALED(f->header)) {
                                error(p, ""Tag object in file without sealing"");
                                r = -EBADMSG;
                                goto fail;
                        }

                        if (le64toh(o->tag.seqnum) != n_tags + 1) {
                                error(p,
                                      ""Tag sequence number out of synchronization (%""PRIu64"" != %""PRIu64"")"",
                                      le64toh(o->tag.seqnum),
                                      n_tags + 1);
                                r = -EBADMSG;
                                goto fail;
                        }

                        if (le64toh(o->tag.epoch) < last_epoch) {
                                error(p,
                                      ""Epoch sequence out of synchronization (%""PRIu64"" < %""PRIu64"")"",
                                      le64toh(o->tag.epoch),
                                      last_epoch);
                                r = -EBADMSG;
                                goto fail;
                        }

#if HAVE_GCRYPT
                        if (JOURNAL_HEADER_SEALED(f->header)) {
                                uint64_t q, rt;

                                debug(p, ""Checking tag %""PRIu64""..."", le64toh(o->tag.seqnum));

                                rt = f->fss_start_usec + le64toh(o->tag.epoch) * f->fss_interval_usec;
                                if (entry_realtime_set && entry_realtime >= rt + f->fss_interval_usec) {
                                        error(p,
                                              ""tag/entry realtime timestamp out of synchronization (%""PRIu64"" >= %""PRIu64"")"",
                                              entry_realtime,
                                              rt + f->fss_interval_usec);
                                        r = -EBADMSG;
                                        goto fail;
                                }
                                if (max_entry_realtime >= rt + f->fss_interval_usec) {
                                        error(p,
                                              ""entry realtime timestamp too late with respect to tag (%""PRIu64"" < %""PRIu64"")"",
                                              max_entry_realtime,
                                              rt + f->fss_interval_usec);
                                        r = -EBADMSG;
                                        goto fail;
                                }
                                if (min_entry_realtime_set && min_entry_realtime < rt) {
                                        error(p,
                                              ""entry realtime timestamp too early with respect to tag out of synchronization (%""PRIu64"" >= %""PRIu64"")"",
                                              min_entry_realtime,
                                              rt);
                                        r = -EBADMSG;
                                        goto fail;
                                }
                                min_entry_realtime_set = false;

                                /* OK, now we know the epoch. So let's now set
                                 * it, and calculate the HMAC for everything
                                 * since the last tag. */
                                r = journal_file_fsprg_seek(f, le64toh(o->tag.epoch));
                                if (r < 0)
                                        goto fail;

                                r = journal_file_hmac_start(f);
                                if (r < 0)
                                        goto fail;

                                if (last_tag == 0) {
                                        r = journal_file_hmac_put_header(f);
                                        if (r < 0)
                                                goto fail;

                                        q = le64toh(f->header->header_size);
                                } else
                                        q = last_tag;

                                while (q <= p) {
                                        r = journal_file_move_to_object(f, OBJECT_UNUSED, q, &o);
                                        if (r < 0)
                                                goto fail;

                                        r = journal_file_hmac_put_object(f, OBJECT_UNUSED, o, q);
                                        if (r < 0)
                                                goto fail;

                                        q = q + ALIGN64(le64toh(o->object.size));
                                }

                                /* Position might have changed, let's reposition things */
                                r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);
                                if (r < 0)
                                        goto fail;

                                if (memcmp(o->tag.tag, gcry_md_read(f->hmac, 0), TAG_LENGTH) != 0) {
                                        error(p, ""Tag failed verification"");
                                        r = -EBADMSG;
                                        goto fail;
                                }

                                f->hmac_running = false;
                                last_tag_realtime = rt;
                                last_sealed_realtime = entry_realtime;
                        }

                        last_tag = p + ALIGN64(le64toh(o->object.size));
#endif

                        last_epoch = le64toh(o->tag.epoch);

                        n_tags++;
                        break;
                }

                if (p == le64toh(f->header->tail_object_offset)) {
                        found_last = true;
                        break;
                }

                p = p + ALIGN64(le64toh(o->object.size));
        };

        if (!found_last && le64toh(f->header->tail_object_offset) != 0) {
                error(le64toh(f->header->tail_object_offset),
                      ""Tail object pointer dead (%""PRIu64"" != 0)"",
                      le64toh(f->header->tail_object_offset));
                r = -EBADMSG;
                goto fail;
        }

        if (n_objects != le64toh(f->header->n_objects)) {
                error(offsetof(Header, n_objects),
                      ""Object number mismatch (%""PRIu64"" != %""PRIu64"")"",
                      n_objects,
                      le64toh(f->header->n_objects));
                r = -EBADMSG;
                goto fail;
        }

        if (n_entries != le64toh(f->header->n_entries)) {
                error(offsetof(Header, n_entries),
                      ""Entry number mismatch (%""PRIu64"" != %""PRIu64"")"",
                      n_entries,
                      le64toh(f->header->n_entries));
                r = -EBADMSG;
                goto fail;
        }

        if (JOURNAL_HEADER_CONTAINS(f->header, n_data) &&
            n_data != le64toh(f->header->n_data)) {
                error(offsetof(Header, n_data),
                      ""Data number mismatch (%""PRIu64"" != %""PRIu64"")"",
                      n_data,
                      le64toh(f->header->n_data));
                r = -EBADMSG;
                goto fail;
        }

        if (JOURNAL_HEADER_CONTAINS(f->header, n_fields) &&
            n_fields != le64toh(f->header->n_fields)) {
                error(offsetof(Header, n_fields),
                      ""Field number mismatch (%""PRIu64"" != %""PRIu64"")"",
                      n_fields,
                      le64toh(f->header->n_fields));
                r = -EBADMSG;
                goto fail;
        }

        if (JOURNAL_HEADER_CONTAINS(f->header, n_tags) &&
            n_tags != le64toh(f->header->n_tags)) {
                error(offsetof(Header, n_tags),
                      ""Tag number mismatch (%""PRIu64"" != %""PRIu64"")"",
                      n_tags,
                      le64toh(f->header->n_tags));
                r = -EBADMSG;
                goto fail;
        }

        if (JOURNAL_HEADER_CONTAINS(f->header, n_entry_arrays) &&
            n_entry_arrays != le64toh(f->header->n_entry_arrays)) {
                error(offsetof(Header, n_entry_arrays),
                      ""Entry array number mismatch (%""PRIu64"" != %""PRIu64"")"",
                      n_entry_arrays,
                      le64toh(f->header->n_entry_arrays));
                r = -EBADMSG;
                goto fail;
        }

        if (!found_main_entry_array && le64toh(f->header->entry_array_offset) != 0) {
                error(0, ""Missing main entry array"");
                r = -EBADMSG;
                goto fail;
        }

        if (entry_seqnum_set &&
            entry_seqnum != le64toh(f->header->tail_entry_seqnum)) {
                error(offsetof(Header, tail_entry_seqnum),
                      ""Tail entry sequence number incorrect (%""PRIu64"" != %""PRIu64"")"",
                      entry_seqnum,
                      le64toh(f->header->tail_entry_seqnum));
                r = -EBADMSG;
                goto fail;
        }

        if (entry_monotonic_set &&
            (sd_id128_equal(entry_boot_id, f->header->tail_entry_boot_id) &&
             JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(f->header) &&
             entry_monotonic != le64toh(f->header->tail_entry_monotonic))) {
                error(0,
                      ""Invalid tail monotonic timestamp (%""PRIu64"" != %""PRIu64"")"",
                      entry_monotonic,
                      le64toh(f->header->tail_entry_monotonic));
                r = -EBADMSG;
                goto fail;
        }

        if (entry_realtime_set && entry_realtime != le64toh(f->header->tail_entry_realtime)) {
                error(0,
                      ""Invalid tail realtime timestamp (%""PRIu64"" != %""PRIu64"")"",
                      entry_realtime,
                      le64toh(f->header->tail_entry_realtime));
                r = -EBADMSG;
                goto fail;
        }

        if (fflush(data_fp) != 0) {
                r = log_error_errno(errno, ""Failed to flush data file stream: %m"");
                goto fail;
        }

        if (fflush(entry_fp) != 0) {
                r = log_error_errno(errno, ""Failed to flush entry file stream: %m"");
                goto fail;
        }

        if (fflush(entry_array_fp) != 0) {
                r = log_error_errno(errno, ""Failed to flush entry array file stream: %m"");
                goto fail;
        }

        /* Second iteration: we follow all objects referenced from the
         * two entry points: the object hash table and the entry
         * array. We also check that everything referenced (directly
         * or indirectly) in the data hash table also exists in the
         * entry array, and vice versa. Note that we do not care for
         * unreferenced objects. We only care that everything that is
         * referenced is consistent. */

        r = verify_entry_array(f,
                               cache_data_fd, n_data,
                               cache_entry_fd, n_entries,
                               cache_entry_array_fd, n_entry_arrays,
                               &last_usec,
                               show_progress);
        if (r < 0)
                goto fail;

        r = verify_data_hash_table(f,
                                   cache_data_fd, n_data,
                                   cache_entry_fd, n_entries,
                                   cache_entry_array_fd, n_entry_arrays,
                                   &last_usec,
                                   show_progress);
        if (r < 0)
                goto fail;

        if (show_progress)
                flush_progress();

        mmap_cache_fd_free(cache_data_fd);
        mmap_cache_fd_free(cache_entry_fd);
        mmap_cache_fd_free(cache_entry_array_fd);

        if (first_contained)
                *first_contained = le64toh(f->header->head_entry_realtime);
        if (last_validated)
                *last_validated = last_sealed_realtime;
        if (last_contained)
                *last_contained = le64toh(f->header->tail_entry_realtime);

        return 0;

fail:
        if (show_progress)
                flush_progress();

        log_error(""File corruption detected at %s:%""PRIu64"" (of %""PRIu64"" bytes, %""PRIu64""%%)."",
                  f->path,
                  p,
                  (uint64_t) f->last_stat.st_size,
                  100U * p / (uint64_t) f->last_stat.st_size);

        if (cache_data_fd)
                mmap_cache_fd_free(cache_data_fd);

        if (cache_entry_fd)
                mmap_cache_fd_free(cache_entry_fd);

        if (cache_entry_array_fd)
                mmap_cache_fd_free(cache_entry_array_fd);

        return r;
}","int journal_file_verify(
                JournalFile *VAR_0,
                const char *VAR_1,
                usec_t *VAR_2, usec_t *VAR_3, usec_t *VAR_4,
                bool VAR_5) {
        int VAR_6;
        Object *VAR_7;
        uint64_t VAR_8 = 0, VAR_9 = 0, VAR_10 = 0, VAR_11 = 0;

        uint64_t VAR_12 = 0, VAR_13 = 0, VAR_14 = 0, VAR_15 = 0, VAR_16 = 0;
        sd_id128_t VAR_17 = {};  /* COMMENT_0 */
        bool VAR_18 = false, VAR_19 = false, VAR_20 = false, VAR_21 = false, VAR_22 = false;
        uint64_t VAR_23 = 0, VAR_24 = 0, VAR_25 = 0, VAR_26 = 0, VAR_27 = 0, VAR_28 = 0, VAR_29 = 0, VAR_30 = 0;
        usec_t VAR_31 = 0;
        _cleanup_close_ int VAR_32 = -VAR_33, VAR_34 = -VAR_33, VAR_35 = -VAR_33;
        _cleanup_fclose_ VAR_36 *VAR_37 = NULL, *VAR_38 = NULL, *VAR_39 = NULL;
        MMapFileDescriptor *VAR_40 = NULL, *VAR_41 = NULL, *VAR_42 = NULL;
        unsigned VAR_43;
        bool VAR_44 = false;
        const char *VAR_45 = NULL;
        MMapCache *VAR_46;

#if VAR_47
        uint64_t VAR_48 = 0;
#endif
        assert(VAR_0);

        if (VAR_1) {
#if VAR_47
                VAR_6 = journal_file_parse_verification_key(VAR_0, VAR_1);
                if (VAR_6 < 0) {
                        log_error(""Failed to parse seed."");
                        return VAR_6;
                }
#else
                return -VAR_49;
#endif
        } else if (JOURNAL_HEADER_SEALED(VAR_0->header))
                return -VAR_50;

        VAR_6 = var_tmp_dir(&VAR_45);
        if (VAR_6 < 0) {
                log_error_errno(VAR_6, ""Failed to determine temporary directory: %m"");
                goto fail;
        }

        VAR_32 = open_tmpfile_unlinkable(VAR_45, VAR_51 | VAR_52);
        if (VAR_32 < 0) {
                VAR_6 = log_error_errno(VAR_32, ""Failed to create data file: %m"");
                goto fail;
        }

        VAR_34 = open_tmpfile_unlinkable(VAR_45, VAR_51 | VAR_52);
        if (VAR_34 < 0) {
                VAR_6 = log_error_errno(VAR_34, ""Failed to create entry file: %m"");
                goto fail;
        }

        VAR_35 = open_tmpfile_unlinkable(VAR_45, VAR_51 | VAR_52);
        if (VAR_35 < 0) {
                VAR_6 = log_error_errno(VAR_35,
                                    ""Failed to create entry array file: %m"");
                goto fail;
        }

        VAR_46 = mmap_cache_fd_cache(VAR_0->cache_fd);
        VAR_40 = mmap_cache_add_fd(VAR_46, VAR_32, VAR_53|VAR_54);
        if (!VAR_40) {
                VAR_6 = log_oom();
                goto fail;
        }

        VAR_41 = mmap_cache_add_fd(VAR_46, VAR_34, VAR_53|VAR_54);
        if (!VAR_41) {
                VAR_6 = log_oom();
                goto fail;
        }

        VAR_42 = mmap_cache_add_fd(VAR_46, VAR_35, VAR_53|VAR_54);
        if (!VAR_42) {
                VAR_6 = log_oom();
                goto fail;
        }

        VAR_6 = take_fdopen_unlocked(&VAR_32, ""w+"", &VAR_37);
        if (VAR_6 < 0) {
                log_error_errno(VAR_6, ""Failed to open data file stream: %m"");
                goto fail;
        }

        VAR_6 = take_fdopen_unlocked(&VAR_34, ""w+"", &VAR_38);
        if (VAR_6 < 0) {
                log_error_errno(VAR_6, ""Failed to open entry file stream: %m"");
                goto fail;
        }

        VAR_6 = take_fdopen_unlocked(&VAR_35, ""w+"", &VAR_39);
        if (VAR_6 < 0) {
                log_error_errno(VAR_6, ""Failed to open entry array file stream: %m"");
                goto fail;
        }

        if (le32toh(VAR_0->header->compatible_flags) & ~VAR_55) {
                log_error(""Cannot verify file with unknown extensions."");
                VAR_6 = -VAR_49;
                goto fail;
        }

        for (VAR_43 = 0; VAR_43 < sizeof(VAR_0->header->reserved); VAR_43++)
                if (VAR_0->header->reserved[VAR_43] != 0) {
                        error(offsetof(VAR_56, VAR_57[VAR_43]), ""Reserved field is non-zero"");
                        VAR_6 = -VAR_58;
                        goto fail;
                }

        /* COMMENT_1 */
                                                     

        VAR_8 = le64toh(VAR_0->header->header_size);
        for (;;) {
                /* COMMENT_3 */
                if (le64toh(VAR_0->header->tail_object_offset) == 0)
                        break;

                if (VAR_5)
                        draw_progress(scale_progress(0x7FFF, VAR_8, le64toh(VAR_0->header->tail_object_offset)), &VAR_31);

                VAR_6 = journal_file_move_to_object(VAR_0, VAR_59, VAR_8, &VAR_7);
                if (VAR_6 < 0) {
                        error_errno(VAR_8, VAR_6, ""Invalid object: %m"");
                        goto fail;
                }

                if (VAR_8 > le64toh(VAR_0->header->tail_object_offset)) {
                        error(offsetof(VAR_56, VAR_60),
                              ""Invalid tail object pointer (%""VAR_61"" > %""VAR_61"")"",
                              VAR_8,
                              le64toh(VAR_0->header->tail_object_offset));
                        VAR_6 = -VAR_58;
                        goto fail;
                }

                VAR_23++;

                VAR_6 = journal_file_object_verify(VAR_0, VAR_8, VAR_7);
                if (VAR_6 < 0) {
                        error_errno(VAR_8, VAR_6, ""Invalid object contents: %m"");
                        goto fail;
                }

                if (!!(VAR_7->object.flags & VAR_62) +
                    !!(VAR_7->object.flags & VAR_63) +
                    !!(VAR_7->object.flags & VAR_64) > 1) {
                        error(VAR_8, ""Object has multiple compression flags set (flags: 0x%x)"", VAR_7->object.flags);
                        VAR_6 = -VAR_65;
                        goto fail;
                }

                if ((VAR_7->object.flags & VAR_62) && !JOURNAL_HEADER_COMPRESSED_XZ(VAR_0->header)) {
                        error(VAR_8, ""XZ compressed object in file without XZ compression"");
                        VAR_6 = -VAR_58;
                        goto fail;
                }

                if ((VAR_7->object.flags & VAR_63) && !JOURNAL_HEADER_COMPRESSED_LZ4(VAR_0->header)) {
                        error(VAR_8, ""LZ4 compressed object in file without LZ4 compression"");
                        VAR_6 = -VAR_58;
                        goto fail;
                }

                if ((VAR_7->object.flags & VAR_64) && !JOURNAL_HEADER_COMPRESSED_ZSTD(VAR_0->header)) {
                        error(VAR_8, ""ZSTD compressed object in file without ZSTD compression"");
                        VAR_6 = -VAR_58;
                        goto fail;
                }

                switch (VAR_7->object.type) {

                case VAR_66:
                        VAR_6 = write_uint64(VAR_37, VAR_8);
                        if (VAR_6 < 0)
                                goto fail;

                        VAR_25++;
                        break;

                case VAR_67:
                        VAR_26++;
                        break;

                case VAR_68:
                        if (JOURNAL_HEADER_SEALED(VAR_0->header) && VAR_30 <= 0) {
                                error(VAR_8, ""First entry before first tag"");
                                VAR_6 = -VAR_58;
                                goto fail;
                        }

                        VAR_6 = write_uint64(VAR_38, VAR_8);
                        if (VAR_6 < 0)
                                goto fail;

                        if (le64toh(VAR_7->entry.realtime) < VAR_10) {
                                error(VAR_8,
                                      ""Older entry after newer tag (%""VAR_61"" < %""VAR_61"")"",
                                      le64toh(VAR_7->entry.realtime),
                                      VAR_10);
                                VAR_6 = -VAR_58;
                                goto fail;
                        }

                        if (!VAR_18 &&
                            le64toh(VAR_7->entry.seqnum) != le64toh(VAR_0->header->head_entry_seqnum)) {
                                error(VAR_8,
                                      ""Head entry sequence number incorrect (%""VAR_61"" != %""VAR_61"")"",
                                      le64toh(VAR_7->entry.seqnum),
                                      le64toh(VAR_0->header->head_entry_seqnum));
                                VAR_6 = -VAR_58;
                                goto fail;
                        }

                        if (VAR_18 &&
                            VAR_12 >= le64toh(VAR_7->entry.seqnum)) {
                                error(VAR_8,
                                      ""Entry sequence number out of synchronization (%""VAR_61"" >= %""VAR_61"")"",
                                      VAR_12,
                                      le64toh(VAR_7->entry.seqnum));
                                VAR_6 = -VAR_58;
                                goto fail;
                        }

                        VAR_12 = le64toh(VAR_7->entry.seqnum);
                        VAR_18 = true;

                        if (VAR_19 &&
                            sd_id128_equal(VAR_17, VAR_7->entry.boot_id) &&
                            VAR_13 > le64toh(VAR_7->entry.monotonic)) {
                                error(VAR_8,
                                      ""Entry timestamp out of synchronization (%""VAR_61"" > %""VAR_61"")"",
                                      VAR_13,
                                      le64toh(VAR_7->entry.monotonic));
                                VAR_6 = -VAR_58;
                                goto fail;
                        }

                        VAR_13 = le64toh(VAR_7->entry.monotonic);
                        VAR_17 = VAR_7->entry.boot_id;
                        VAR_19 = true;

                        if (!VAR_20 &&
                            le64toh(VAR_7->entry.realtime) != le64toh(VAR_0->header->head_entry_realtime)) {
                                error(VAR_8,
                                      ""Head entry realtime timestamp incorrect (%""VAR_61"" != %""VAR_61"")"",
                                      le64toh(VAR_7->entry.realtime),
                                      le64toh(VAR_0->header->head_entry_realtime));
                                VAR_6 = -VAR_58;
                                goto fail;
                        }

                        VAR_14 = le64toh(VAR_7->entry.realtime);
                        VAR_20 = true;

                        if (VAR_16 < le64toh(VAR_7->entry.realtime))
                                VAR_16 = le64toh(VAR_7->entry.realtime);
                        if (!VAR_21 || VAR_15 > le64toh(VAR_7->entry.realtime)) {
                                VAR_15 = le64toh(VAR_7->entry.realtime);
                                VAR_21 = true;
                        }

                        VAR_24++;
                        break;

                case VAR_69:
                        VAR_6 = verify_hash_table(VAR_7, VAR_8, &VAR_27,
                                              le64toh(VAR_0->header->data_hash_table_offset),
                                              le64toh(VAR_0->header->data_hash_table_size));
                        if (VAR_6 < 0)
                                goto fail;
                        break;

                case VAR_70:
                        VAR_6 = verify_hash_table(VAR_7, VAR_8, &VAR_28,
                                              le64toh(VAR_0->header->field_hash_table_offset),
                                              le64toh(VAR_0->header->field_hash_table_size));
                        if (VAR_6 < 0)
                                goto fail;

                        break;

                case VAR_71:
                        VAR_6 = write_uint64(VAR_39, VAR_8);
                        if (VAR_6 < 0)
                                goto fail;

                        if (VAR_8 == le64toh(VAR_0->header->entry_array_offset)) {
                                if (VAR_22) {
                                        error(VAR_8, ""More than one main entry array"");
                                        VAR_6 = -VAR_58;
                                        goto fail;
                                }

                                VAR_22 = true;
                        }

                        VAR_29++;
                        break;

                case VAR_72:
                        if (!JOURNAL_HEADER_SEALED(VAR_0->header)) {
                                error(VAR_8, ""Tag object in file without sealing"");
                                VAR_6 = -VAR_58;
                                goto fail;
                        }

                        if (le64toh(VAR_7->tag.seqnum) != VAR_30 + 1) {
                                error(VAR_8,
                                      ""Tag sequence number out of synchronization (%""VAR_61"" != %""VAR_61"")"",
                                      le64toh(VAR_7->tag.seqnum),
                                      VAR_30 + 1);
                                VAR_6 = -VAR_58;
                                goto fail;
                        }

                        if (le64toh(VAR_7->tag.epoch) < VAR_9) {
                                error(VAR_8,
                                      ""Epoch sequence out of synchronization (%""VAR_61"" < %""VAR_61"")"",
                                      le64toh(VAR_7->tag.epoch),
                                      VAR_9);
                                VAR_6 = -VAR_58;
                                goto fail;
                        }

#if VAR_47
                        if (JOURNAL_HEADER_SEALED(VAR_0->header)) {
                                uint64_t VAR_73, VAR_74;

                                debug(VAR_8, ""Checking tag %""VAR_61""..."", le64toh(VAR_7->tag.seqnum));

                                VAR_74 = VAR_0->fss_start_usec + le64toh(VAR_7->tag.epoch) * VAR_0->fss_interval_usec;
                                if (VAR_20 && VAR_14 >= VAR_74 + VAR_0->fss_interval_usec) {
                                        error(VAR_8,
                                              ""tag/entry realtime timestamp out of synchronization (%""VAR_61"" >= %""VAR_61"")"",
                                              VAR_14,
                                              VAR_74 + VAR_0->fss_interval_usec);
                                        VAR_6 = -VAR_58;
                                        goto fail;
                                }
                                if (VAR_16 >= VAR_74 + VAR_0->fss_interval_usec) {
                                        error(VAR_8,
                                              ""entry realtime timestamp too late with respect to tag (%""VAR_61"" < %""VAR_61"")"",
                                              VAR_16,
                                              VAR_74 + VAR_0->fss_interval_usec);
                                        VAR_6 = -VAR_58;
                                        goto fail;
                                }
                                if (VAR_21 && VAR_15 < VAR_74) {
                                        error(VAR_8,
                                              ""entry realtime timestamp too early with respect to tag out of synchronization (%""VAR_61"" >= %""VAR_61"")"",
                                              VAR_15,
                                              VAR_74);
                                        VAR_6 = -VAR_58;
                                        goto fail;
                                }
                                VAR_21 = false;

                                /* COMMENT_4 */
                                                                            
                                                         
                                VAR_6 = journal_file_fsprg_seek(VAR_0, le64toh(VAR_7->tag.epoch));
                                if (VAR_6 < 0)
                                        goto fail;

                                VAR_6 = journal_file_hmac_start(VAR_0);
                                if (VAR_6 < 0)
                                        goto fail;

                                if (VAR_48 == 0) {
                                        VAR_6 = journal_file_hmac_put_header(VAR_0);
                                        if (VAR_6 < 0)
                                                goto fail;

                                        VAR_73 = le64toh(VAR_0->header->header_size);
                                } else
                                        VAR_73 = VAR_48;

                                while (VAR_73 <= VAR_8) {
                                        VAR_6 = journal_file_move_to_object(VAR_0, VAR_59, VAR_73, &VAR_7);
                                        if (VAR_6 < 0)
                                                goto fail;

                                        VAR_6 = journal_file_hmac_put_object(VAR_0, VAR_59, VAR_7, VAR_73);
                                        if (VAR_6 < 0)
                                                goto fail;

                                        VAR_73 = VAR_73 + ALIGN64(le64toh(VAR_7->object.size));
                                }

                                /* COMMENT_7 */
                                VAR_6 = journal_file_move_to_object(VAR_0, VAR_59, VAR_8, &VAR_7);
                                if (VAR_6 < 0)
                                        goto fail;

                                if (memcmp(VAR_7->tag.tag, gcry_md_read(VAR_0->hmac, 0), VAR_75) != 0) {
                                        error(VAR_8, ""Tag failed verification"");
                                        VAR_6 = -VAR_58;
                                        goto fail;
                                }

                                VAR_0->hmac_running = false;
                                VAR_10 = VAR_74;
                                VAR_11 = VAR_14;
                        }

                        VAR_48 = VAR_8 + ALIGN64(le64toh(VAR_7->object.size));
#endif

                        VAR_9 = le64toh(VAR_7->tag.epoch);

                        VAR_30++;
                        break;
                }

                if (VAR_8 == le64toh(VAR_0->header->tail_object_offset)) {
                        VAR_44 = true;
                        break;
                }

                VAR_8 = VAR_8 + ALIGN64(le64toh(VAR_7->object.size));
        };

        if (!VAR_44 && le64toh(VAR_0->header->tail_object_offset) != 0) {
                error(le64toh(VAR_0->header->tail_object_offset),
                      ""Tail object pointer dead (%""VAR_61"" != 0)"",
                      le64toh(VAR_0->header->tail_object_offset));
                VAR_6 = -VAR_58;
                goto fail;
        }

        if (VAR_23 != le64toh(VAR_0->header->n_objects)) {
                error(offsetof(VAR_56, VAR_23),
                      ""Object number mismatch (%""VAR_61"" != %""VAR_61"")"",
                      VAR_23,
                      le64toh(VAR_0->header->n_objects));
                VAR_6 = -VAR_58;
                goto fail;
        }

        if (VAR_24 != le64toh(VAR_0->header->n_entries)) {
                error(offsetof(VAR_56, VAR_24),
                      ""Entry number mismatch (%""VAR_61"" != %""VAR_61"")"",
                      VAR_24,
                      le64toh(VAR_0->header->n_entries));
                VAR_6 = -VAR_58;
                goto fail;
        }

        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_25) &&
            VAR_25 != le64toh(VAR_0->header->n_data)) {
                error(offsetof(VAR_56, VAR_25),
                      ""Data number mismatch (%""VAR_61"" != %""VAR_61"")"",
                      VAR_25,
                      le64toh(VAR_0->header->n_data));
                VAR_6 = -VAR_58;
                goto fail;
        }

        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_26) &&
            VAR_26 != le64toh(VAR_0->header->n_fields)) {
                error(offsetof(VAR_56, VAR_26),
                      ""Field number mismatch (%""VAR_61"" != %""VAR_61"")"",
                      VAR_26,
                      le64toh(VAR_0->header->n_fields));
                VAR_6 = -VAR_58;
                goto fail;
        }

        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_30) &&
            VAR_30 != le64toh(VAR_0->header->n_tags)) {
                error(offsetof(VAR_56, VAR_30),
                      ""Tag number mismatch (%""VAR_61"" != %""VAR_61"")"",
                      VAR_30,
                      le64toh(VAR_0->header->n_tags));
                VAR_6 = -VAR_58;
                goto fail;
        }

        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_29) &&
            VAR_29 != le64toh(VAR_0->header->n_entry_arrays)) {
                error(offsetof(VAR_56, VAR_29),
                      ""Entry array number mismatch (%""VAR_61"" != %""VAR_61"")"",
                      VAR_29,
                      le64toh(VAR_0->header->n_entry_arrays));
                VAR_6 = -VAR_58;
                goto fail;
        }

        if (!VAR_22 && le64toh(VAR_0->header->entry_array_offset) != 0) {
                error(0, ""Missing main entry array"");
                VAR_6 = -VAR_58;
                goto fail;
        }

        if (VAR_18 &&
            VAR_12 != le64toh(VAR_0->header->tail_entry_seqnum)) {
                error(offsetof(VAR_56, VAR_76),
                      ""Tail entry sequence number incorrect (%""VAR_61"" != %""VAR_61"")"",
                      VAR_12,
                      le64toh(VAR_0->header->tail_entry_seqnum));
                VAR_6 = -VAR_58;
                goto fail;
        }

        if (VAR_19 &&
            (sd_id128_equal(VAR_17, VAR_0->header->tail_entry_boot_id) &&
             JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(VAR_0->header) &&
             VAR_13 != le64toh(VAR_0->header->tail_entry_monotonic))) {
                error(0,
                      ""Invalid tail monotonic timestamp (%""VAR_61"" != %""VAR_61"")"",
                      VAR_13,
                      le64toh(VAR_0->header->tail_entry_monotonic));
                VAR_6 = -VAR_58;
                goto fail;
        }

        if (VAR_20 && VAR_14 != le64toh(VAR_0->header->tail_entry_realtime)) {
                error(0,
                      ""Invalid tail realtime timestamp (%""VAR_61"" != %""VAR_61"")"",
                      VAR_14,
                      le64toh(VAR_0->header->tail_entry_realtime));
                VAR_6 = -VAR_58;
                goto fail;
        }

        if (fflush(VAR_37) != 0) {
                VAR_6 = log_error_errno(VAR_77, ""Failed to flush data file stream: %m"");
                goto fail;
        }

        if (fflush(VAR_38) != 0) {
                VAR_6 = log_error_errno(VAR_77, ""Failed to flush entry file stream: %m"");
                goto fail;
        }

        if (fflush(VAR_39) != 0) {
                VAR_6 = log_error_errno(VAR_77, ""Failed to flush entry array file stream: %m"");
                goto fail;
        }

        /* COMMENT_8 */
                                                                
                                                                    
                                                                   
                                                                    
                                                                     
                                       

        VAR_6 = verify_entry_array(VAR_0,
                               VAR_40, VAR_25,
                               VAR_41, VAR_24,
                               VAR_42, VAR_29,
                               &VAR_31,
                               VAR_5);
        if (VAR_6 < 0)
                goto fail;

        VAR_6 = verify_data_hash_table(VAR_0,
                                   VAR_40, VAR_25,
                                   VAR_41, VAR_24,
                                   VAR_42, VAR_29,
                                   &VAR_31,
                                   VAR_5);
        if (VAR_6 < 0)
                goto fail;

        if (VAR_5)
                flush_progress();

        mmap_cache_fd_free(VAR_40);
        mmap_cache_fd_free(VAR_41);
        mmap_cache_fd_free(VAR_42);

        if (VAR_2)
                *VAR_2 = le64toh(VAR_0->header->head_entry_realtime);
        if (VAR_3)
                *VAR_3 = VAR_11;
        if (VAR_4)
                *VAR_4 = le64toh(VAR_0->header->tail_entry_realtime);

        return 0;

fail:
        if (VAR_5)
                flush_progress();

        log_error(""File corruption detected at %s:%""VAR_61"" (of %""VAR_61"" bytes, %""VAR_61""%%)."",
                  VAR_0->path,
                  VAR_8,
                  (uint64_t) VAR_0->last_stat.st_size,
                  100U * VAR_8 / (uint64_t) VAR_0->last_stat.st_size);

        if (VAR_40)
                mmap_cache_fd_free(VAR_40);

        if (VAR_41)
                mmap_cache_fd_free(VAR_41);

        if (VAR_42)
                mmap_cache_fd_free(VAR_42);

        return VAR_6;
}",systemd/540e35ef8ae259744ce18d272a232d56c2445279/journal-verify.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,9 +7,9 @@
         Object *o;
         uint64_t p = 0, last_epoch = 0, last_tag_realtime = 0, last_sealed_realtime = 0;
 
-        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0;
+        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0, min_entry_realtime = 0, max_entry_realtime = 0;
         sd_id128_t entry_boot_id = {};  /* Unnecessary initialization to appease gcc */
-        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, found_main_entry_array = false;
+        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, min_entry_realtime_set = false, found_main_entry_array = false;
         uint64_t n_objects = 0, n_entries = 0, n_data = 0, n_fields = 0, n_data_hash_tables = 0, n_field_hash_tables = 0, n_entry_arrays = 0, n_tags = 0;
         usec_t last_usec = 0;
         _cleanup_close_ int data_fd = -EBADF, entry_fd = -EBADF, entry_array_fd = -EBADF;
@@ -259,6 +259,13 @@
                         entry_realtime = le64toh(o->entry.realtime);
                         entry_realtime_set = true;
 
+                        if (max_entry_realtime < le64toh(o->entry.realtime))
+                                max_entry_realtime = le64toh(o->entry.realtime);
+                        if (!min_entry_realtime_set || min_entry_realtime > le64toh(o->entry.realtime)) {
+                                min_entry_realtime = le64toh(o->entry.realtime);
+                                min_entry_realtime_set = true;
+                        }
+
                         n_entries++;
                         break;
 
@@ -337,6 +344,23 @@
                                         r = -EBADMSG;
                                         goto fail;
                                 }
+                                if (max_entry_realtime >= rt + f->fss_interval_usec) {
+                                        error(p,
+                                              ""entry realtime timestamp too late with respect to tag (%""PRIu64"" < %""PRIu64"")"",
+                                              max_entry_realtime,
+                                              rt + f->fss_interval_usec);
+                                        r = -EBADMSG;
+                                        goto fail;
+                                }
+                                if (min_entry_realtime_set && min_entry_realtime < rt) {
+                                        error(p,
+                                              ""entry realtime timestamp too early with respect to tag out of synchronization (%""PRIu64"" >= %""PRIu64"")"",
+                                              min_entry_realtime,
+                                              rt);
+                                        r = -EBADMSG;
+                                        goto fail;
+                                }
+                                min_entry_realtime_set = false;
 
                                 /* OK, now we know the epoch. So let's now set
                                  * it, and calculate the HMAC for everything","{'deleted_lines': ['        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0;', '        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, found_main_entry_array = false;'], 'added_lines': ['        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0, min_entry_realtime = 0, max_entry_realtime = 0;', '        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, min_entry_realtime_set = false, found_main_entry_array = false;', '                        if (max_entry_realtime < le64toh(o->entry.realtime))', '                                max_entry_realtime = le64toh(o->entry.realtime);', '                        if (!min_entry_realtime_set || min_entry_realtime > le64toh(o->entry.realtime)) {', '                                min_entry_realtime = le64toh(o->entry.realtime);', '                                min_entry_realtime_set = true;', '                        }', '', '                                if (max_entry_realtime >= rt + f->fss_interval_usec) {', '                                        error(p,', '                                              ""entry realtime timestamp too late with respect to tag (%""PRIu64"" < %""PRIu64"")"",', '                                              max_entry_realtime,', '                                              rt + f->fss_interval_usec);', '                                        r = -EBADMSG;', '                                        goto fail;', '                                }', '                                if (min_entry_realtime_set && min_entry_realtime < rt) {', '                                        error(p,', '                                              ""entry realtime timestamp too early with respect to tag out of synchronization (%""PRIu64"" >= %""PRIu64"")"",', '                                              min_entry_realtime,', '                                              rt);', '                                        r = -EBADMSG;', '                                        goto fail;', '                                }', '                                min_entry_realtime_set = false;']}",True,"An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""",5.3,MEDIUM,1,test,2023-08-18T07:58:03Z,4
CVE-2023-41358,['CWE-476'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,FRRouting/frr,"bgpd: Do not process NLRIs if the attribute length is zero

```
3  0x00007f423aa42476 in __GI_raise (sig=sig@entry=11) at ../sysdeps/posix/raise.c:26
4  0x00007f423aef9740 in core_handler (signo=11, siginfo=0x7fffc414deb0, context=<optimized out>) at lib/sigevent.c:246
5  <signal handler called>
6  0x0000564dea2fc71e in route_set_aspath_prepend (rule=0x564debd66d50, prefix=0x7fffc414ea30, object=0x7fffc414e400)
    at bgpd/bgp_routemap.c:2258
7  0x00007f423aeec7e0 in route_map_apply_ext (map=<optimized out>, prefix=prefix@entry=0x7fffc414ea30,
    match_object=match_object@entry=0x7fffc414e400, set_object=set_object@entry=0x7fffc414e400, pref=pref@entry=0x0) at lib/routemap.c:2690
8  0x0000564dea2d277e in bgp_input_modifier (peer=peer@entry=0x7f4238f59010, p=p@entry=0x7fffc414ea30, attr=attr@entry=0x7fffc414e770,
    afi=afi@entry=AFI_IP, safi=safi@entry=SAFI_UNICAST, rmap_name=rmap_name@entry=0x0, label=0x0, num_labels=0, dest=0x564debdd5130)
    at bgpd/bgp_route.c:1772
9  0x0000564dea2df762 in bgp_update (peer=peer@entry=0x7f4238f59010, p=p@entry=0x7fffc414ea30, addpath_id=addpath_id@entry=0,
    attr=0x7fffc414eb50, afi=afi@entry=AFI_IP, safi=<optimized out>, safi@entry=SAFI_UNICAST, type=9, sub_type=0, prd=0x0, label=0x0,
    num_labels=0, soft_reconfig=0, evpn=0x0) at bgpd/bgp_route.c:4374
10 0x0000564dea2e2047 in bgp_nlri_parse_ip (peer=0x7f4238f59010, attr=attr@entry=0x7fffc414eb50, packet=0x7fffc414eaf0)
    at bgpd/bgp_route.c:6249
11 0x0000564dea2c5a58 in bgp_nlri_parse (peer=peer@entry=0x7f4238f59010, attr=attr@entry=0x7fffc414eb50,
    packet=packet@entry=0x7fffc414eaf0, mp_withdraw=mp_withdraw@entry=false) at bgpd/bgp_packet.c:339
12 0x0000564dea2c5d66 in bgp_update_receive (peer=peer@entry=0x7f4238f59010, size=size@entry=109) at bgpd/bgp_packet.c:2024
13 0x0000564dea2c901d in bgp_process_packet (thread=<optimized out>) at bgpd/bgp_packet.c:2933
14 0x00007f423af0bf71 in event_call (thread=thread@entry=0x7fffc414ee40) at lib/event.c:1995
15 0x00007f423aebb198 in frr_run (master=0x564deb73c670) at lib/libfrr.c:1213
16 0x0000564dea261b83 in main (argc=<optimized out>, argv=<optimized out>) at bgpd/bgp_main.c:505
```

With the configuration:

```
frr version 9.1-dev-MyOwnFRRVersion
frr defaults traditional
hostname ip-172-31-13-140
log file /tmp/debug.log
log syslog
service integrated-vtysh-config
!
debug bgp keepalives
debug bgp neighbor-events
debug bgp updates in
debug bgp updates out
!
router bgp 100
 bgp router-id 9.9.9.9
 no bgp ebgp-requires-policy
 bgp bestpath aigp
 neighbor 172.31.2.47 remote-as 200
 !
 address-family ipv4 unicast
  neighbor 172.31.2.47 default-originate
  neighbor 172.31.2.47 route-map RM_IN in
 exit-address-family
exit
!
route-map RM_IN permit 10
 set as-path prepend 200
exit
!
```

The issue is that we try to process NLRIs even if the attribute length is 0.

Later bgp_update() will handle route-maps and a crash occurs because all the
attributes are NULL, including aspath, where we dereference.

According to the RFC 4271:

A value of 0 indicates that neither the Network Layer
         Reachability Information field nor the Path Attribute field is
         present in this UPDATE message.

But with a fuzzed UPDATE message this can be faked. I think it's reasonable
to skip processing NLRIs if both update_len and attribute_len are 0.

Reported-by: Iggy Frankovic <iggyfran@amazon.com>
Signed-off-by: Donatas Abraitis <donatas@opensourcerouting.org>",28ccc24d38df1d51ed8a563507e5d6f6171fdd38,https://github.com/FRRouting/frr/commit/28ccc24d38df1d51ed8a563507e5d6f6171fdd38,bgpd/bgp_packet.c,bgp_update_receive,"static int bgp_update_receive(struct peer *peer, bgp_size_t size)
{
int ret, nlri_ret;
uint8_t *end;
struct stream *s;
struct attr attr;
bgp_size_t attribute_len;
bgp_size_t update_len;
bgp_size_t withdraw_len;
bool restart = false;
enum NLRI_TYPES {
NLRI_UPDATE,
NLRI_WITHDRAW,
NLRI_MP_UPDATE,
NLRI_MP_WITHDRAW,
NLRI_TYPE_MAX
};
struct bgp_nlri nlris[NLRI_TYPE_MAX];
if (!peer_established(peer)) {
flog_err(EC_BGP_INVALID_STATUS,
""%s [FSM] Update packet received under status %s"",
peer->host,
lookup_msg(bgp_status_msg, peer->connection->status,
NULL));
bgp_notify_send(peer, BGP_NOTIFY_FSM_ERR,
bgp_fsm_error_subcode(peer->connection->status));
return BGP_Stop;
}
memset(&attr, 0, sizeof(attr));
attr.label_index = BGP_INVALID_LABEL_INDEX;
attr.label = MPLS_INVALID_LABEL;
memset(&nlris, 0, sizeof(nlris));
memset(peer->rcvd_attr_str, 0, BUFSIZ);
peer->rcvd_attr_printed = 0;
s = peer->curr;
end = stream_pnt(s) + size;
if (stream_pnt(s) + 2 > end) {
flog_err(EC_BGP_UPDATE_RCV,
""%s [Error] Update packet error (packet length is short for unfeasible length)"",
peer->host);
bgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,
BGP_NOTIFY_UPDATE_MAL_ATTR);
return BGP_Stop;
}
withdraw_len = stream_getw(s);
if (stream_pnt(s) + withdraw_len > end) {
flog_err(EC_BGP_UPDATE_RCV,
""%s [Error] Update packet error (packet unfeasible length overflow %d)"",
peer->host, withdraw_len);
bgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,
BGP_NOTIFY_UPDATE_MAL_ATTR);
return BGP_Stop;
}
if (withdraw_len > 0) {
nlris[NLRI_WITHDRAW].afi = AFI_IP;
nlris[NLRI_WITHDRAW].safi = SAFI_UNICAST;
nlris[NLRI_WITHDRAW].nlri = stream_pnt(s);
nlris[NLRI_WITHDRAW].length = withdraw_len;
stream_forward_getp(s, withdraw_len);
}
if (stream_pnt(s) + 2 > end) {
flog_warn(
EC_BGP_UPDATE_PACKET_SHORT,
""%s [Error] Packet Error (update packet is short for attribute length)"",
peer->host);
bgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,
BGP_NOTIFY_UPDATE_MAL_ATTR);
return BGP_Stop;
}
attribute_len = stream_getw(s);
if (stream_pnt(s) + attribute_len > end) {
flog_warn(
EC_BGP_UPDATE_PACKET_LONG,
""%s [Error] Packet Error (update packet attribute length overflow %d)"",
peer->host, attribute_len);
bgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,
BGP_NOTIFY_UPDATE_MAL_ATTR);
return BGP_Stop;
}
enum bgp_attr_parse_ret attr_parse_ret = BGP_ATTR_PARSE_PROCEED;
#define NLRI_ATTR_ARG (attr_parse_ret != BGP_ATTR_PARSE_WITHDRAW ? &attr : NULL)
if (attribute_len) {
attr_parse_ret = bgp_attr_parse(peer, &attr, attribute_len,
&nlris[NLRI_MP_UPDATE],
&nlris[NLRI_MP_WITHDRAW]);
if (attr_parse_ret == BGP_ATTR_PARSE_ERROR) {
bgp_attr_unintern_sub(&attr);
return BGP_Stop;
}
}
if (attr_parse_ret == BGP_ATTR_PARSE_WITHDRAW
|| BGP_DEBUG(update, UPDATE_IN)
|| BGP_DEBUG(update, UPDATE_PREFIX)) {
ret = bgp_dump_attr(&attr, peer->rcvd_attr_str,
sizeof(peer->rcvd_attr_str));
peer->stat_upd_7606++;
if (attr_parse_ret == BGP_ATTR_PARSE_WITHDRAW)
flog_err(
EC_BGP_UPDATE_RCV,
""%pBP rcvd UPDATE with errors in attr(s)!! Withdrawing route."",
peer);
if (ret && bgp_debug_update(peer, NULL, NULL, 1)) {
zlog_debug(""%pBP rcvd UPDATE w/ attr: %s"", peer,
peer->rcvd_attr_str);
peer->rcvd_attr_printed = 1;
}
}
update_len = end - stream_pnt(s);
if (update_len) {
nlris[NLRI_UPDATE].afi = AFI_IP;
nlris[NLRI_UPDATE].safi = SAFI_UNICAST;
nlris[NLRI_UPDATE].nlri = stream_pnt(s);
nlris[NLRI_UPDATE].length = update_len;
stream_forward_getp(s, update_len);
if (CHECK_FLAG(attr.flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) {
if (bgp_attr_nexthop_valid(peer, &attr) < 0) {
bgp_attr_unintern_sub(&attr);
return BGP_Stop;
}
}
}
if (BGP_DEBUG(update, UPDATE_IN))
zlog_debug(""%pBP rcvd UPDATE wlen %d attrlen %d alen %d"", peer,
withdraw_len, attribute_len, update_len);
for (int i = NLRI_UPDATE; i < NLRI_TYPE_MAX; i++) {
if (!nlris[i].nlri)
continue;
if (!peer->afc[nlris[i].afi][nlris[i].safi]) {
zlog_info(
""%s [Info] UPDATE for non-enabled AFI/SAFI %u/%u"",
peer->host, nlris[i].afi, nlris[i].safi);
continue;
}
if (nlris[i].length == 0)
continue;
switch (i) {
case NLRI_UPDATE:
case NLRI_MP_UPDATE:
nlri_ret = bgp_nlri_parse(peer, NLRI_ATTR_ARG,
&nlris[i], 0);
break;
case NLRI_WITHDRAW:
case NLRI_MP_WITHDRAW:
nlri_ret = bgp_nlri_parse(peer, NLRI_ATTR_ARG,
&nlris[i], 1);
break;
default:
nlri_ret = BGP_NLRI_PARSE_ERROR;
}
if (nlri_ret < BGP_NLRI_PARSE_OK
&& nlri_ret != BGP_NLRI_PARSE_ERROR_PREFIX_OVERFLOW) {
flog_err(EC_BGP_UPDATE_RCV,
""%s [Error] Error parsing NLRI"", peer->host);
if (peer_established(peer))
bgp_notify_send(
peer, BGP_NOTIFY_UPDATE_ERR,
i <= NLRI_WITHDRAW
? BGP_NOTIFY_UPDATE_INVAL_NETWORK
: BGP_NOTIFY_UPDATE_OPT_ATTR_ERR);
bgp_attr_unintern_sub(&attr);
return BGP_Stop;
}
}
if ((!update_len && !withdraw_len && nlris[NLRI_MP_UPDATE].length == 0)
|| (attr_parse_ret == BGP_ATTR_PARSE_EOR)) {
afi_t afi = 0;
safi_t safi;
struct graceful_restart_info *gr_info;
if (BGP_PEER_GRACEFUL_RESTART_CAPABLE(peer)
&& BGP_PEER_RESTARTING_MODE(peer))
restart = true;
if (!attribute_len) {
afi = AFI_IP;
safi = SAFI_UNICAST;
} else if (attr.flag & ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI)
&& nlris[NLRI_MP_WITHDRAW].length == 0) {
afi = nlris[NLRI_MP_WITHDRAW].afi;
safi = nlris[NLRI_MP_WITHDRAW].safi;
} else if (attr_parse_ret == BGP_ATTR_PARSE_EOR) {
afi = nlris[NLRI_MP_UPDATE].afi;
safi = nlris[NLRI_MP_UPDATE].safi;
}
if (afi && peer->afc[afi][safi]) {
struct vrf *vrf = vrf_lookup_by_id(peer->bgp->vrf_id);
if (!CHECK_FLAG(peer->af_sflags[afi][safi],
PEER_STATUS_EOR_RECEIVED)) {
SET_FLAG(peer->af_sflags[afi][safi],
PEER_STATUS_EOR_RECEIVED);
bgp_update_explicit_eors(peer);
gr_info = &(peer->bgp->gr_info[afi][safi]);
if (restart)
gr_info->eor_received++;
if (gr_info->eor_required
== gr_info->eor_received) {
if (bgp_debug_neighbor_events(peer))
zlog_debug(
""%s %d, %s %d"",
""EOR REQ"",
gr_info->eor_required,
""EOR RCV"",
gr_info->eor_received);
if (gr_info->t_select_deferral) {
void *info = EVENT_ARG(
gr_info->t_select_deferral);
XFREE(MTYPE_TMP, info);
}
EVENT_OFF(gr_info->t_select_deferral);
gr_info->eor_required = 0;
gr_info->eor_received = 0;
bgp_best_path_select_defer(peer->bgp,
afi, safi);
}
}
if (peer->nsf[afi][safi])
bgp_clear_stale_route(peer, afi, safi);
zlog_info(
""%s: rcvd End-of-RIB for %s from %s in vrf %s"",
__func__, get_afi_safi_str(afi, safi, false),
peer->host, vrf ? vrf->name : VRF_DEFAULT_NAME);
}
}
bgp_attr_unintern_sub(&attr);
peer->update_time = monotime(NULL);
peer->advmap_table_change = true;
return Receive_UPDATE_message;
}","static int bgp_update_receive(struct peer *peer, bgp_size_t VAR_0)
{
int VAR_1, VAR_2;
uint8_t *VAR_3;
struct stream *VAR_4;
struct attr attr;
bgp_size_t VAR_5;
bgp_size_t VAR_6;
bgp_size_t VAR_7;
bool VAR_8 = false;
enum NLRI_TYPES {
VAR_9,
VAR_10,
VAR_11,
VAR_12,
VAR_13
};
struct bgp_nlri VAR_14[VAR_13];
if (!peer_established(peer)) {
flog_err(VAR_15,
""%s [FSM] Update packet received under status %s"",
peer->host,
lookup_msg(VAR_16, peer->connection->status,
NULL));
bgp_notify_send(peer, VAR_17,
bgp_fsm_error_subcode(peer->connection->status));
return VAR_18;
}
memset(&attr, 0, sizeof(attr));
attr.label_index = VAR_19;
attr.label = VAR_20;
memset(&VAR_14, 0, sizeof(VAR_14));
memset(peer->rcvd_attr_str, 0, VAR_21);
peer->rcvd_attr_printed = 0;
VAR_4 = peer->curr;
VAR_3 = stream_pnt(VAR_4) + VAR_0;
if (stream_pnt(VAR_4) + 2 > VAR_3) {
flog_err(VAR_22,
""%s [Error] Update packet error (packet length is short for unfeasible length)"",
peer->host);
bgp_notify_send(peer, VAR_23,
VAR_24);
return VAR_18;
}
VAR_7 = stream_getw(VAR_4);
if (stream_pnt(VAR_4) + VAR_7 > VAR_3) {
flog_err(VAR_22,
""%s [Error] Update packet error (packet unfeasible length overflow %d)"",
peer->host, VAR_7);
bgp_notify_send(peer, VAR_23,
VAR_24);
return VAR_18;
}
if (VAR_7 > 0) {
VAR_14[VAR_10].afi = VAR_25;
VAR_14[VAR_10].safi = VAR_26;
VAR_14[VAR_10].nlri = stream_pnt(VAR_4);
VAR_14[VAR_10].length = VAR_7;
stream_forward_getp(VAR_4, VAR_7);
}
if (stream_pnt(VAR_4) + 2 > VAR_3) {
flog_warn(
VAR_27,
""%s [Error] Packet Error (update packet is short for attribute length)"",
peer->host);
bgp_notify_send(peer, VAR_23,
VAR_24);
return VAR_18;
}
VAR_5 = stream_getw(VAR_4);
if (stream_pnt(VAR_4) + VAR_5 > VAR_3) {
flog_warn(
VAR_28,
""%s [Error] Packet Error (update packet attribute length overflow %d)"",
peer->host, VAR_5);
bgp_notify_send(peer, VAR_23,
VAR_24);
return VAR_18;
}
enum bgp_attr_parse_ret VAR_29 = VAR_30;
#define VAR_31 (attr_parse_ret != BGP_ATTR_PARSE_WITHDRAW ? &attr : NULL)
if (VAR_5) {
VAR_29 = bgp_attr_parse(peer, &attr, VAR_5,
&VAR_14[VAR_11],
&VAR_14[VAR_12]);
if (VAR_29 == VAR_32) {
bgp_attr_unintern_sub(&attr);
return VAR_18;
}
}
if (VAR_29 == VAR_33
|| BGP_DEBUG(VAR_34, VAR_35)
|| BGP_DEBUG(VAR_34, VAR_36)) {
VAR_1 = bgp_dump_attr(&attr, peer->rcvd_attr_str,
sizeof(peer->rcvd_attr_str));
peer->stat_upd_7606++;
if (VAR_29 == VAR_33)
flog_err(
VAR_22,
""%pBP rcvd UPDATE with errors in attr(s)!! Withdrawing route."",
peer);
if (VAR_1 && bgp_debug_update(peer, NULL, NULL, 1)) {
zlog_debug(""%pBP rcvd UPDATE w/ attr: %s"", peer,
peer->rcvd_attr_str);
peer->rcvd_attr_printed = 1;
}
}
VAR_6 = VAR_3 - stream_pnt(VAR_4);
if (VAR_6) {
VAR_14[VAR_9].afi = VAR_25;
VAR_14[VAR_9].safi = VAR_26;
VAR_14[VAR_9].nlri = stream_pnt(VAR_4);
VAR_14[VAR_9].length = VAR_6;
stream_forward_getp(VAR_4, VAR_6);
if (CHECK_FLAG(attr.flag, ATTR_FLAG_BIT(VAR_37))) {
if (bgp_attr_nexthop_valid(peer, &attr) < 0) {
bgp_attr_unintern_sub(&attr);
return VAR_18;
}
}
}
if (BGP_DEBUG(VAR_34, VAR_35))
zlog_debug(""%pBP rcvd UPDATE wlen %d attrlen %d alen %d"", peer,
VAR_7, VAR_5, VAR_6);
for (int VAR_38 = VAR_9; VAR_38 < VAR_13; VAR_38++) {
if (!VAR_14[VAR_38].nlri)
continue;
if (!peer->afc[VAR_14[VAR_38].afi][VAR_14[VAR_38].safi]) {
zlog_info(
""%s [Info] UPDATE for non-enabled AFI/SAFI %u/%u"",
peer->host, VAR_14[VAR_38].afi, VAR_14[VAR_38].safi);
continue;
}
if (VAR_14[VAR_38].length == 0)
continue;
switch (VAR_38) {
case VAR_9:
case VAR_11:
VAR_2 = bgp_nlri_parse(peer, VAR_31,
&VAR_14[VAR_38], 0);
break;
case VAR_10:
case VAR_12:
VAR_2 = bgp_nlri_parse(peer, VAR_31,
&VAR_14[VAR_38], 1);
break;
default:
VAR_2 = VAR_39;
}
if (VAR_2 < VAR_40
&& VAR_2 != VAR_41) {
flog_err(VAR_22,
""%s [Error] Error parsing NLRI"", peer->host);
if (peer_established(peer))
bgp_notify_send(
peer, VAR_23,
VAR_38 <= VAR_10
? VAR_42
: VAR_43);
bgp_attr_unintern_sub(&attr);
return VAR_18;
}
}
if ((!VAR_6 && !VAR_7 && VAR_14[VAR_11].length == 0)
|| (VAR_29 == VAR_44)) {
afi_t VAR_45 = 0;
safi_t VAR_46;
struct graceful_restart_info *VAR_47;
if (BGP_PEER_GRACEFUL_RESTART_CAPABLE(peer)
&& BGP_PEER_RESTARTING_MODE(peer))
VAR_8 = true;
if (!VAR_5) {
VAR_45 = VAR_25;
VAR_46 = VAR_26;
} else if (attr.flag & ATTR_FLAG_BIT(VAR_48)
&& VAR_14[VAR_12].length == 0) {
VAR_45 = VAR_14[VAR_12].afi;
VAR_46 = VAR_14[VAR_12].safi;
} else if (VAR_29 == VAR_44) {
VAR_45 = VAR_14[VAR_11].afi;
VAR_46 = VAR_14[VAR_11].safi;
}
if (VAR_45 && peer->afc[VAR_45][VAR_46]) {
struct vrf *vrf = vrf_lookup_by_id(peer->bgp->vrf_id);
if (!CHECK_FLAG(peer->af_sflags[VAR_45][VAR_46],
VAR_49)) {
SET_FLAG(peer->af_sflags[VAR_45][VAR_46],
VAR_49);
bgp_update_explicit_eors(peer);
VAR_47 = &(peer->bgp->gr_info[VAR_45][VAR_46]);
if (VAR_8)
VAR_47->eor_received++;
if (VAR_47->eor_required
== VAR_47->eor_received) {
if (bgp_debug_neighbor_events(peer))
zlog_debug(
""%s %d, %s %d"",
""EOR REQ"",
VAR_47->eor_required,
""EOR RCV"",
VAR_47->eor_received);
if (VAR_47->t_select_deferral) {
void *VAR_50 = EVENT_ARG(
VAR_47->t_select_deferral);
XFREE(VAR_51, VAR_50);
}
EVENT_OFF(VAR_47->t_select_deferral);
VAR_47->eor_required = 0;
VAR_47->eor_received = 0;
bgp_best_path_select_defer(peer->bgp,
VAR_45, VAR_46);
}
}
if (peer->nsf[VAR_45][VAR_46])
bgp_clear_stale_route(peer, VAR_45, VAR_46);
zlog_info(
""%s: rcvd End-of-RIB for %s from %s in vrf %s"",
VAR_52, get_afi_safi_str(VAR_45, VAR_46, false),
peer->host, vrf ? vrf->name : VAR_53);
}
}
bgp_attr_unintern_sub(&attr);
peer->update_time = monotime(NULL);
peer->advmap_table_change = true;
return VAR_54;
}",FRRouting/frr/28ccc24d38df1d51ed8a563507e5d6f6171fdd38/bgp_packet.c/vul/before/0.json,"static int bgp_update_receive(struct peer *peer, bgp_size_t size)
{
	int ret, nlri_ret;
	uint8_t *end;
	struct stream *s;
	struct attr attr;
	bgp_size_t attribute_len;
	bgp_size_t update_len;
	bgp_size_t withdraw_len;
	bool restart = false;

	enum NLRI_TYPES {
		NLRI_UPDATE,
		NLRI_WITHDRAW,
		NLRI_MP_UPDATE,
		NLRI_MP_WITHDRAW,
		NLRI_TYPE_MAX
	};
	struct bgp_nlri nlris[NLRI_TYPE_MAX];

	/* Status must be Established. */
	if (!peer_established(peer)) {
		flog_err(EC_BGP_INVALID_STATUS,
			 ""%s [FSM] Update packet received under status %s"",
			 peer->host,
			 lookup_msg(bgp_status_msg, peer->connection->status,
				    NULL));
		bgp_notify_send(peer, BGP_NOTIFY_FSM_ERR,
				bgp_fsm_error_subcode(peer->connection->status));
		return BGP_Stop;
	}

	/* Set initial values. */
	memset(&attr, 0, sizeof(attr));
	attr.label_index = BGP_INVALID_LABEL_INDEX;
	attr.label = MPLS_INVALID_LABEL;
	memset(&nlris, 0, sizeof(nlris));
	memset(peer->rcvd_attr_str, 0, BUFSIZ);
	peer->rcvd_attr_printed = 0;

	s = peer->curr;
	end = stream_pnt(s) + size;

	/* RFC1771 6.3 If the Unfeasible Routes Length or Total Attribute
	   Length is too large (i.e., if Unfeasible Routes Length + Total
	   Attribute Length + 23 exceeds the message Length), then the Error
	   Subcode is set to Malformed Attribute List.  */
	if (stream_pnt(s) + 2 > end) {
		flog_err(EC_BGP_UPDATE_RCV,
			 ""%s [Error] Update packet error (packet length is short for unfeasible length)"",
			 peer->host);
		bgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,
				BGP_NOTIFY_UPDATE_MAL_ATTR);
		return BGP_Stop;
	}

	/* Unfeasible Route Length. */
	withdraw_len = stream_getw(s);

	/* Unfeasible Route Length check. */
	if (stream_pnt(s) + withdraw_len > end) {
		flog_err(EC_BGP_UPDATE_RCV,
			 ""%s [Error] Update packet error (packet unfeasible length overflow %d)"",
			 peer->host, withdraw_len);
		bgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,
				BGP_NOTIFY_UPDATE_MAL_ATTR);
		return BGP_Stop;
	}

	/* Unfeasible Route packet format check. */
	if (withdraw_len > 0) {
		nlris[NLRI_WITHDRAW].afi = AFI_IP;
		nlris[NLRI_WITHDRAW].safi = SAFI_UNICAST;
		nlris[NLRI_WITHDRAW].nlri = stream_pnt(s);
		nlris[NLRI_WITHDRAW].length = withdraw_len;
		stream_forward_getp(s, withdraw_len);
	}

	/* Attribute total length check. */
	if (stream_pnt(s) + 2 > end) {
		flog_warn(
			EC_BGP_UPDATE_PACKET_SHORT,
			""%s [Error] Packet Error (update packet is short for attribute length)"",
			peer->host);
		bgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,
				BGP_NOTIFY_UPDATE_MAL_ATTR);
		return BGP_Stop;
	}

	/* Fetch attribute total length. */
	attribute_len = stream_getw(s);

	/* Attribute length check. */
	if (stream_pnt(s) + attribute_len > end) {
		flog_warn(
			EC_BGP_UPDATE_PACKET_LONG,
			""%s [Error] Packet Error (update packet attribute length overflow %d)"",
			peer->host, attribute_len);
		bgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,
				BGP_NOTIFY_UPDATE_MAL_ATTR);
		return BGP_Stop;
	}

	/* Certain attribute parsing errors should not be considered bad enough
	 * to reset the session for, most particularly any partial/optional
	 * attributes that have 'tunneled' over speakers that don't understand
	 * them. Instead we withdraw only the prefix concerned.
	 *
	 * Complicates the flow a little though..
	 */
	enum bgp_attr_parse_ret attr_parse_ret = BGP_ATTR_PARSE_PROCEED;
/* This define morphs the update case into a withdraw when lower levels
 * have signalled an error condition where this is best.
 */
#define NLRI_ATTR_ARG (attr_parse_ret != BGP_ATTR_PARSE_WITHDRAW ? &attr : NULL)

	/* Parse attribute when it exists. */
	if (attribute_len) {
		attr_parse_ret = bgp_attr_parse(peer, &attr, attribute_len,
						&nlris[NLRI_MP_UPDATE],
						&nlris[NLRI_MP_WITHDRAW]);
		if (attr_parse_ret == BGP_ATTR_PARSE_ERROR) {
			bgp_attr_unintern_sub(&attr);
			return BGP_Stop;
		}
	}

	/* Logging the attribute. */
	if (attr_parse_ret == BGP_ATTR_PARSE_WITHDRAW
	    || BGP_DEBUG(update, UPDATE_IN)
	    || BGP_DEBUG(update, UPDATE_PREFIX)) {
		ret = bgp_dump_attr(&attr, peer->rcvd_attr_str,
				    sizeof(peer->rcvd_attr_str));

		peer->stat_upd_7606++;

		if (attr_parse_ret == BGP_ATTR_PARSE_WITHDRAW)
			flog_err(
				EC_BGP_UPDATE_RCV,
				""%pBP rcvd UPDATE with errors in attr(s)!! Withdrawing route."",
				peer);

		if (ret && bgp_debug_update(peer, NULL, NULL, 1)) {
			zlog_debug(""%pBP rcvd UPDATE w/ attr: %s"", peer,
				   peer->rcvd_attr_str);
			peer->rcvd_attr_printed = 1;
		}
	}

	/* Network Layer Reachability Information. */
	update_len = end - stream_pnt(s);

	if (update_len && attribute_len) {
		/* Set NLRI portion to structure. */
		nlris[NLRI_UPDATE].afi = AFI_IP;
		nlris[NLRI_UPDATE].safi = SAFI_UNICAST;
		nlris[NLRI_UPDATE].nlri = stream_pnt(s);
		nlris[NLRI_UPDATE].length = update_len;
		stream_forward_getp(s, update_len);

		if (CHECK_FLAG(attr.flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) {
			/*
			 * We skipped nexthop attribute validation earlier so
			 * validate the nexthop now.
			 */
			if (bgp_attr_nexthop_valid(peer, &attr) < 0) {
				bgp_attr_unintern_sub(&attr);
				return BGP_Stop;
			}
		}
	}

	if (BGP_DEBUG(update, UPDATE_IN))
		zlog_debug(""%pBP rcvd UPDATE wlen %d attrlen %d alen %d"", peer,
			   withdraw_len, attribute_len, update_len);

	/* Parse any given NLRIs */
	for (int i = NLRI_UPDATE; i < NLRI_TYPE_MAX; i++) {
		if (!nlris[i].nlri)
			continue;

		/* NLRI is processed iff the peer if configured for the specific
		 * afi/safi */
		if (!peer->afc[nlris[i].afi][nlris[i].safi]) {
			zlog_info(
				""%s [Info] UPDATE for non-enabled AFI/SAFI %u/%u"",
				peer->host, nlris[i].afi, nlris[i].safi);
			continue;
		}

		/* EoR handled later */
		if (nlris[i].length == 0)
			continue;

		switch (i) {
		case NLRI_UPDATE:
		case NLRI_MP_UPDATE:
			nlri_ret = bgp_nlri_parse(peer, NLRI_ATTR_ARG,
						  &nlris[i], 0);
			break;
		case NLRI_WITHDRAW:
		case NLRI_MP_WITHDRAW:
			nlri_ret = bgp_nlri_parse(peer, NLRI_ATTR_ARG,
						  &nlris[i], 1);
			break;
		default:
			nlri_ret = BGP_NLRI_PARSE_ERROR;
		}

		if (nlri_ret < BGP_NLRI_PARSE_OK
		    && nlri_ret != BGP_NLRI_PARSE_ERROR_PREFIX_OVERFLOW) {
			flog_err(EC_BGP_UPDATE_RCV,
				 ""%s [Error] Error parsing NLRI"", peer->host);
			if (peer_established(peer))
				bgp_notify_send(
					peer, BGP_NOTIFY_UPDATE_ERR,
					i <= NLRI_WITHDRAW
						? BGP_NOTIFY_UPDATE_INVAL_NETWORK
						: BGP_NOTIFY_UPDATE_OPT_ATTR_ERR);
			bgp_attr_unintern_sub(&attr);
			return BGP_Stop;
		}
	}

	/* EoR checks
	 *
	 * Non-MP IPv4/Unicast EoR is a completely empty UPDATE
	 * and MP EoR should have only an empty MP_UNREACH
	 */
	if ((!update_len && !withdraw_len && nlris[NLRI_MP_UPDATE].length == 0)
	    || (attr_parse_ret == BGP_ATTR_PARSE_EOR)) {
		afi_t afi = 0;
		safi_t safi;
		struct graceful_restart_info *gr_info;

		/* Restarting router */
		if (BGP_PEER_GRACEFUL_RESTART_CAPABLE(peer)
		    && BGP_PEER_RESTARTING_MODE(peer))
			restart = true;

		/* Non-MP IPv4/Unicast is a completely emtpy UPDATE - already
		 * checked
		 * update and withdraw NLRI lengths are 0.
		 */
		if (!attribute_len) {
			afi = AFI_IP;
			safi = SAFI_UNICAST;
		} else if (attr.flag & ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI)
			   && nlris[NLRI_MP_WITHDRAW].length == 0) {
			afi = nlris[NLRI_MP_WITHDRAW].afi;
			safi = nlris[NLRI_MP_WITHDRAW].safi;
		} else if (attr_parse_ret == BGP_ATTR_PARSE_EOR) {
			afi = nlris[NLRI_MP_UPDATE].afi;
			safi = nlris[NLRI_MP_UPDATE].safi;
		}

		if (afi && peer->afc[afi][safi]) {
			struct vrf *vrf = vrf_lookup_by_id(peer->bgp->vrf_id);

			/* End-of-RIB received */
			if (!CHECK_FLAG(peer->af_sflags[afi][safi],
					PEER_STATUS_EOR_RECEIVED)) {
				SET_FLAG(peer->af_sflags[afi][safi],
					 PEER_STATUS_EOR_RECEIVED);
				bgp_update_explicit_eors(peer);
				/* Update graceful restart information */
				gr_info = &(peer->bgp->gr_info[afi][safi]);
				if (restart)
					gr_info->eor_received++;
				/* If EOR received from all peers and selection
				 * deferral timer is running, cancel the timer
				 * and invoke the best path calculation
				 */
				if (gr_info->eor_required
				    == gr_info->eor_received) {
					if (bgp_debug_neighbor_events(peer))
						zlog_debug(
							""%s %d, %s %d"",
							""EOR REQ"",
							gr_info->eor_required,
							""EOR RCV"",
							gr_info->eor_received);
					if (gr_info->t_select_deferral) {
						void *info = EVENT_ARG(
							gr_info->t_select_deferral);
						XFREE(MTYPE_TMP, info);
					}
					EVENT_OFF(gr_info->t_select_deferral);
					gr_info->eor_required = 0;
					gr_info->eor_received = 0;
					/* Best path selection */
					bgp_best_path_select_defer(peer->bgp,
								   afi, safi);
				}
			}

			/* NSF delete stale route */
			if (peer->nsf[afi][safi])
				bgp_clear_stale_route(peer, afi, safi);

			zlog_info(
				""%s: rcvd End-of-RIB for %s from %s in vrf %s"",
				__func__, get_afi_safi_str(afi, safi, false),
				peer->host, vrf ? vrf->name : VRF_DEFAULT_NAME);
		}
	}

	/* Everything is done.  We unintern temporary structures which
	   interned in bgp_attr_parse(). */
	bgp_attr_unintern_sub(&attr);

	peer->update_time = monotime(NULL);

	/* Notify BGP Conditional advertisement scanner process */
	peer->advmap_table_change = true;

	return Receive_UPDATE_message;
}","static int bgp_update_receive(struct peer *peer, bgp_size_t VAR_0)
{
	int VAR_1, VAR_2;
	uint8_t *VAR_3;
	struct stream *VAR_4;
	struct attr attr;
	bgp_size_t VAR_5;
	bgp_size_t VAR_6;
	bgp_size_t VAR_7;
	bool VAR_8 = false;

	enum NLRI_TYPES {
		VAR_9,
		VAR_10,
		VAR_11,
		VAR_12,
		VAR_13
	};
	struct bgp_nlri VAR_14[VAR_13];

	/* COMMENT_0 */
	if (!peer_established(peer)) {
		flog_err(VAR_15,
			 ""%s [FSM] Update packet received under status %s"",
			 peer->host,
			 lookup_msg(VAR_16, peer->connection->status,
				    NULL));
		bgp_notify_send(peer, VAR_17,
				bgp_fsm_error_subcode(peer->connection->status));
		return VAR_18;
	}

	/* COMMENT_1 */
	memset(&attr, 0, sizeof(attr));
	attr.label_index = VAR_19;
	attr.label = VAR_20;
	memset(&VAR_14, 0, sizeof(VAR_14));
	memset(peer->rcvd_attr_str, 0, VAR_21);
	peer->rcvd_attr_printed = 0;

	VAR_4 = peer->curr;
	VAR_3 = stream_pnt(VAR_4) + VAR_0;

	/* COMMENT_2 */
                                                                  
                                                                     
                                                   
	if (stream_pnt(VAR_4) + 2 > VAR_3) {
		flog_err(VAR_22,
			 ""%s [Error] Update packet error (packet length is short for unfeasible length)"",
			 peer->host);
		bgp_notify_send(peer, VAR_23,
				VAR_24);
		return VAR_18;
	}

	/* COMMENT_6 */
	VAR_7 = stream_getw(VAR_4);

	/* COMMENT_7 */
	if (stream_pnt(VAR_4) + VAR_7 > VAR_3) {
		flog_err(VAR_22,
			 ""%s [Error] Update packet error (packet unfeasible length overflow %d)"",
			 peer->host, VAR_7);
		bgp_notify_send(peer, VAR_23,
				VAR_24);
		return VAR_18;
	}

	/* COMMENT_8 */
	if (VAR_7 > 0) {
		VAR_14[VAR_10].afi = VAR_25;
		VAR_14[VAR_10].safi = VAR_26;
		VAR_14[VAR_10].nlri = stream_pnt(VAR_4);
		VAR_14[VAR_10].length = VAR_7;
		stream_forward_getp(VAR_4, VAR_7);
	}

	/* COMMENT_9 */
	if (stream_pnt(VAR_4) + 2 > VAR_3) {
		flog_warn(
			VAR_27,
			""%s [Error] Packet Error (update packet is short for attribute length)"",
			peer->host);
		bgp_notify_send(peer, VAR_23,
				VAR_24);
		return VAR_18;
	}

	/* COMMENT_10 */
	VAR_5 = stream_getw(VAR_4);

	/* COMMENT_11 */
	if (stream_pnt(VAR_4) + VAR_5 > VAR_3) {
		flog_warn(
			VAR_28,
			""%s [Error] Packet Error (update packet attribute length overflow %d)"",
			peer->host, VAR_5);
		bgp_notify_send(peer, VAR_23,
				VAR_24);
		return VAR_18;
	}

	/* COMMENT_12 */
                                                                    
                                                                       
                                                        
   
                                          
    
	enum bgp_attr_parse_ret VAR_29 = VAR_30;
/* COMMENT_19 */
                                                        
   
#define VAR_31 (attr_parse_ret != BGP_ATTR_PARSE_WITHDRAW ? &attr : NULL)

	/* COMMENT_22 */
	if (VAR_5) {
		VAR_29 = bgp_attr_parse(peer, &attr, VAR_5,
						&VAR_14[VAR_11],
						&VAR_14[VAR_12]);
		if (VAR_29 == VAR_32) {
			bgp_attr_unintern_sub(&attr);
			return VAR_18;
		}
	}

	/* COMMENT_23 */
	if (VAR_29 == VAR_33
	    || BGP_DEBUG(VAR_34, VAR_35)
	    || BGP_DEBUG(VAR_34, VAR_36)) {
		VAR_1 = bgp_dump_attr(&attr, peer->rcvd_attr_str,
				    sizeof(peer->rcvd_attr_str));

		peer->stat_upd_7606++;

		if (VAR_29 == VAR_33)
			flog_err(
				VAR_22,
				""%pBP rcvd UPDATE with errors in attr(s)!! Withdrawing route."",
				peer);

		if (VAR_1 && bgp_debug_update(peer, NULL, NULL, 1)) {
			zlog_debug(""%pBP rcvd UPDATE w/ attr: %s"", peer,
				   peer->rcvd_attr_str);
			peer->rcvd_attr_printed = 1;
		}
	}

	/* COMMENT_24 */
	VAR_6 = VAR_3 - stream_pnt(VAR_4);

	if (VAR_6 && VAR_5) {
		/* COMMENT_25 */
		VAR_14[VAR_9].afi = VAR_25;
		VAR_14[VAR_9].safi = VAR_26;
		VAR_14[VAR_9].nlri = stream_pnt(VAR_4);
		VAR_14[VAR_9].length = VAR_6;
		stream_forward_getp(VAR_4, VAR_6);

		if (CHECK_FLAG(attr.flag, ATTR_FLAG_BIT(VAR_37))) {
			/* COMMENT_26 */
                                                        
                               
      
			if (bgp_attr_nexthop_valid(peer, &attr) < 0) {
				bgp_attr_unintern_sub(&attr);
				return VAR_18;
			}
		}
	}

	if (BGP_DEBUG(VAR_34, VAR_35))
		zlog_debug(""%pBP rcvd UPDATE wlen %d attrlen %d alen %d"", peer,
			   VAR_7, VAR_5, VAR_6);

	/* COMMENT_30 */
	for (int VAR_38 = VAR_9; VAR_38 < VAR_13; VAR_38++) {
		if (!VAR_14[VAR_38].nlri)
			continue;

		/* COMMENT_31 */
                
		if (!peer->afc[VAR_14[VAR_38].afi][VAR_14[VAR_38].safi]) {
			zlog_info(
				""%s [Info] UPDATE for non-enabled AFI/SAFI %u/%u"",
				peer->host, VAR_14[VAR_38].afi, VAR_14[VAR_38].safi);
			continue;
		}

		/* COMMENT_33 */
		if (VAR_14[VAR_38].length == 0)
			continue;

		switch (VAR_38) {
		case VAR_9:
		case VAR_11:
			VAR_2 = bgp_nlri_parse(peer, VAR_31,
						  &VAR_14[VAR_38], 0);
			break;
		case VAR_10:
		case VAR_12:
			VAR_2 = bgp_nlri_parse(peer, VAR_31,
						  &VAR_14[VAR_38], 1);
			break;
		default:
			VAR_2 = VAR_39;
		}

		if (VAR_2 < VAR_40
		    && VAR_2 != VAR_41) {
			flog_err(VAR_22,
				 ""%s [Error] Error parsing NLRI"", peer->host);
			if (peer_established(peer))
				bgp_notify_send(
					peer, VAR_23,
					VAR_38 <= VAR_10
						? VAR_42
						: VAR_43);
			bgp_attr_unintern_sub(&attr);
			return VAR_18;
		}
	}

	/* COMMENT_34 */
   
                                                        
                                                   
    
	if ((!VAR_6 && !VAR_7 && VAR_14[VAR_11].length == 0)
	    || (VAR_29 == VAR_44)) {
		afi_t VAR_45 = 0;
		safi_t VAR_46;
		struct graceful_restart_info *VAR_47;

		/* COMMENT_39 */
		if (BGP_PEER_GRACEFUL_RESTART_CAPABLE(peer)
		    && BGP_PEER_RESTARTING_MODE(peer))
			VAR_8 = true;

		/* COMMENT_40 */
            
                                            
     
		if (!VAR_5) {
			VAR_45 = VAR_25;
			VAR_46 = VAR_26;
		} else if (attr.flag & ATTR_FLAG_BIT(VAR_48)
			   && VAR_14[VAR_12].length == 0) {
			VAR_45 = VAR_14[VAR_12].afi;
			VAR_46 = VAR_14[VAR_12].safi;
		} else if (VAR_29 == VAR_44) {
			VAR_45 = VAR_14[VAR_11].afi;
			VAR_46 = VAR_14[VAR_11].safi;
		}

		if (VAR_45 && peer->afc[VAR_45][VAR_46]) {
			struct vrf *vrf = vrf_lookup_by_id(peer->bgp->vrf_id);

			/* COMMENT_44 */
			if (!CHECK_FLAG(peer->af_sflags[VAR_45][VAR_46],
					VAR_49)) {
				SET_FLAG(peer->af_sflags[VAR_45][VAR_46],
					 VAR_49);
				bgp_update_explicit_eors(peer);
				/* COMMENT_45 */
				VAR_47 = &(peer->bgp->gr_info[VAR_45][VAR_46]);
				if (VAR_8)
					VAR_47->eor_received++;
				/* COMMENT_46 */
                                                  
                                           
       
				if (VAR_47->eor_required
				    == VAR_47->eor_received) {
					if (bgp_debug_neighbor_events(peer))
						zlog_debug(
							""%s %d, %s %d"",
							""EOR REQ"",
							VAR_47->eor_required,
							""EOR RCV"",
							VAR_47->eor_received);
					if (VAR_47->t_select_deferral) {
						void *VAR_50 = EVENT_ARG(
							VAR_47->t_select_deferral);
						XFREE(VAR_51, VAR_50);
					}
					EVENT_OFF(VAR_47->t_select_deferral);
					VAR_47->eor_required = 0;
					VAR_47->eor_received = 0;
					/* COMMENT_50 */
					bgp_best_path_select_defer(peer->bgp,
								   VAR_45, VAR_46);
				}
			}

			/* COMMENT_51 */
			if (peer->nsf[VAR_45][VAR_46])
				bgp_clear_stale_route(peer, VAR_45, VAR_46);

			zlog_info(
				""%s: rcvd End-of-RIB for %s from %s in vrf %s"",
				VAR_52, get_afi_safi_str(VAR_45, VAR_46, false),
				peer->host, vrf ? vrf->name : VAR_53);
		}
	}

	/* COMMENT_52 */
                                    
	bgp_attr_unintern_sub(&attr);

	peer->update_time = monotime(NULL);

	/* COMMENT_54 */
	peer->advmap_table_change = true;

	return VAR_54;
}",FRRouting/frr/28ccc24d38df1d51ed8a563507e5d6f6171fdd38/bgp_packet.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -150,7 +150,7 @@
 	/* Network Layer Reachability Information. */
 	update_len = end - stream_pnt(s);
 
-	if (update_len) {
+	if (update_len && attribute_len) {
 		/* Set NLRI portion to structure. */
 		nlris[NLRI_UPDATE].afi = AFI_IP;
 		nlris[NLRI_UPDATE].safi = SAFI_UNICAST;","{'deleted_lines': ['\tif (update_len) {'], 'added_lines': ['\tif (update_len && attribute_len) {']}",True,An issue was discovered in FRRouting FRR through 9.0. bgpd/bgp_packet.c processes NLRIs if the attribute length is zero.,7.5,HIGH,2,test,2023-08-22T19:52:04Z,4
CVE-2022-47022,['CWE-476'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,open-mpi/hwloc,"linux: handle glibc cpuset allocation failures

Closes #544
CVE-2022-47022

Signed-off-by: Brice Goglin <Brice.Goglin@inria.fr>",ac1f8db9a0790d2bf153711ff4cbf6101f89aace,https://github.com/open-mpi/hwloc/commit/ac1f8db9a0790d2bf153711ff4cbf6101f89aace,hwloc/topology-linux.c,hwloc_linux_set_thread_cpubind,"static int
hwloc_linux_set_thread_cpubind(hwloc_topology_t topology, pthread_t tid, hwloc_const_bitmap_t hwloc_set, int flags __hwloc_attribute_unused)
{
int err;
if (topology->pid) {
errno = ENOSYS;
return -1;
}
if (!pthread_self) {
errno = ENOSYS;
return -1;
}
if (tid == pthread_self())
return hwloc_linux_set_tid_cpubind(topology, 0, hwloc_set);
if (!pthread_setaffinity_np) {
errno = ENOSYS;
return -1;
}
#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)
{
cpu_set_t *plinux_set;
unsigned cpu;
int last;
size_t setsize;
last = hwloc_bitmap_last(hwloc_set);
if (last == -1) {
errno = EINVAL;
return -1;
}
setsize = CPU_ALLOC_SIZE(last+1);
plinux_set = CPU_ALLOC(last+1);
CPU_ZERO_S(setsize, plinux_set);
hwloc_bitmap_foreach_begin(cpu, hwloc_set)
CPU_SET_S(cpu, setsize, plinux_set);
hwloc_bitmap_foreach_end();
err = pthread_setaffinity_np(tid, setsize, plinux_set);
CPU_FREE(plinux_set);
}
#elif defined(HWLOC_HAVE_CPU_SET)
{
cpu_set_t linux_set;
unsigned cpu;
CPU_ZERO(&linux_set);
hwloc_bitmap_foreach_begin(cpu, hwloc_set)
CPU_SET(cpu, &linux_set);
hwloc_bitmap_foreach_end();
#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY
err = pthread_setaffinity_np(tid, &linux_set);
#else 
err = pthread_setaffinity_np(tid, sizeof(linux_set), &linux_set);
#endif 
}
#else 
{
unsigned long mask = hwloc_bitmap_to_ulong(hwloc_set);
#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY
err = pthread_setaffinity_np(tid, (void*) &mask);
#else 
err = pthread_setaffinity_np(tid, sizeof(mask), (void*) &mask);
#endif 
}
#endif 
if (err) {
errno = err;
return -1;
}
return 0;
}","static int
hwloc_linux_set_thread_cpubind(hwloc_topology_t VAR_0, pthread_t VAR_1, hwloc_const_bitmap_t VAR_2, int VAR_3 VAR_4)
{
int VAR_5;
if (VAR_0->pid) {
VAR_6 = VAR_7;
return -1;
}
if (!VAR_8) {
VAR_6 = VAR_7;
return -1;
}
if (VAR_1 == VAR_8())
return hwloc_linux_set_tid_cpubind(VAR_0, 0, VAR_2);
if (!VAR_9) {
VAR_6 = VAR_7;
return -1;
}
#if defined(VAR_10) && !defined(VAR_11)
{
cpu_set_t *VAR_12;
unsigned VAR_13;
int VAR_14;
size_t VAR_15;
VAR_14 = hwloc_bitmap_last(VAR_2);
if (VAR_14 == -1) {
VAR_6 = VAR_16;
return -1;
}
VAR_15 = CPU_ALLOC_SIZE(VAR_14+1);
VAR_12 = CPU_ALLOC(VAR_14+1);
CPU_ZERO_S(VAR_15, VAR_12);
hwloc_bitmap_foreach_begin(VAR_13, VAR_2)
CPU_SET_S(VAR_13, VAR_15, VAR_12);
hwloc_bitmap_foreach_end();
VAR_5 = VAR_9(VAR_1, VAR_15, VAR_12);
CPU_FREE(VAR_12);
}
#elif defined(VAR_17)
{
cpu_set_t VAR_18;
unsigned VAR_13;
CPU_ZERO(&VAR_18);
hwloc_bitmap_foreach_begin(VAR_13, VAR_2)
CPU_SET(VAR_13, &VAR_18);
hwloc_bitmap_foreach_end();
#ifdef VAR_11
VAR_5 = VAR_9(VAR_1, &VAR_18);
#else 
VAR_5 = VAR_9(VAR_1, sizeof(VAR_18), &VAR_18);
#endif 
}
#else 
{
unsigned long VAR_19 = hwloc_bitmap_to_ulong(VAR_2);
#ifdef VAR_11
VAR_5 = VAR_9(VAR_1, (void*) &VAR_19);
#else 
VAR_5 = VAR_9(VAR_1, sizeof(VAR_19), (void*) &VAR_19);
#endif 
}
#endif 
if (VAR_5) {
VAR_6 = VAR_5;
return -1;
}
return 0;
}",,"static int
hwloc_linux_set_thread_cpubind(hwloc_topology_t topology, pthread_t tid, hwloc_const_bitmap_t hwloc_set, int flags __hwloc_attribute_unused)
{
  int err;

  if (topology->pid) {
    errno = ENOSYS;
    return -1;
  }

  if (!pthread_self) {
    /* ?! Application uses set_thread_cpubind, but doesn't link against libpthread ?! */
    errno = ENOSYS;
    return -1;
  }
  if (tid == pthread_self())
    return hwloc_linux_set_tid_cpubind(topology, 0, hwloc_set);

  if (!pthread_setaffinity_np) {
    errno = ENOSYS;
    return -1;
  }

#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)
  /* Use a separate block so that we can define specific variable
     types here */
  {
     cpu_set_t *plinux_set;
     unsigned cpu;
     int last;
     size_t setsize;

     last = hwloc_bitmap_last(hwloc_set);
     if (last == -1) {
       errno = EINVAL;
       return -1;
     }

     setsize = CPU_ALLOC_SIZE(last+1);
     plinux_set = CPU_ALLOC(last+1);
     if (!plinux_set)
       return -1;

     CPU_ZERO_S(setsize, plinux_set);
     hwloc_bitmap_foreach_begin(cpu, hwloc_set)
         CPU_SET_S(cpu, setsize, plinux_set);
     hwloc_bitmap_foreach_end();

     err = pthread_setaffinity_np(tid, setsize, plinux_set);

     CPU_FREE(plinux_set);
  }
#elif defined(HWLOC_HAVE_CPU_SET)
  /* Use a separate block so that we can define specific variable
     types here */
  {
     cpu_set_t linux_set;
     unsigned cpu;

     CPU_ZERO(&linux_set);
     hwloc_bitmap_foreach_begin(cpu, hwloc_set)
         CPU_SET(cpu, &linux_set);
     hwloc_bitmap_foreach_end();

#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY
     err = pthread_setaffinity_np(tid, &linux_set);
#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */
     err = pthread_setaffinity_np(tid, sizeof(linux_set), &linux_set);
#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */
  }
#else /* CPU_SET */
  /* Use a separate block so that we can define specific variable
     types here */
  {
      unsigned long mask = hwloc_bitmap_to_ulong(hwloc_set);

#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY
      err = pthread_setaffinity_np(tid, (void*) &mask);
#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */
      err = pthread_setaffinity_np(tid, sizeof(mask), (void*) &mask);
#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */
  }
#endif /* CPU_SET */

  if (err) {
    errno = err;
    return -1;
  }
  return 0;
}","static int
hwloc_linux_set_thread_cpubind(hwloc_topology_t VAR_0, pthread_t VAR_1, hwloc_const_bitmap_t VAR_2, int VAR_3 VAR_4)
{
  int VAR_5;

  if (VAR_0->pid) {
    VAR_6 = VAR_7;
    return -1;
  }

  if (!VAR_8) {
    /* COMMENT_0 */
    VAR_6 = VAR_7;
    return -1;
  }
  if (VAR_1 == VAR_8())
    return hwloc_linux_set_tid_cpubind(VAR_0, 0, VAR_2);

  if (!VAR_9) {
    VAR_6 = VAR_7;
    return -1;
  }

#if defined(VAR_10) && !defined(VAR_11)
  /* COMMENT_1 */
                  
  {
     cpu_set_t *VAR_12;
     unsigned VAR_13;
     int VAR_14;
     size_t VAR_15;

     VAR_14 = hwloc_bitmap_last(VAR_2);
     if (VAR_14 == -1) {
       VAR_6 = VAR_16;
       return -1;
     }

     VAR_15 = CPU_ALLOC_SIZE(VAR_14+1);
     VAR_12 = CPU_ALLOC(VAR_14+1);
     if (!VAR_12)
       return -1;

     CPU_ZERO_S(VAR_15, VAR_12);
     hwloc_bitmap_foreach_begin(VAR_13, VAR_2)
         CPU_SET_S(VAR_13, VAR_15, VAR_12);
     hwloc_bitmap_foreach_end();

     VAR_5 = VAR_9(VAR_1, VAR_15, VAR_12);

     CPU_FREE(VAR_12);
  }
#elif defined(VAR_17)
  /* COMMENT_3 */
                  
  {
     cpu_set_t VAR_18;
     unsigned VAR_13;

     CPU_ZERO(&VAR_18);
     hwloc_bitmap_foreach_begin(VAR_13, VAR_2)
         CPU_SET(VAR_13, &VAR_18);
     hwloc_bitmap_foreach_end();

#ifdef VAR_11
     VAR_5 = VAR_9(VAR_1, &VAR_18);
#else /* COMMENT_5 */
     VAR_5 = VAR_9(VAR_1, sizeof(VAR_18), &VAR_18);
#endif /* COMMENT_5 */
  }
#else /* COMMENT_6 */
  /* COMMENT_7 */
                  
  {
      unsigned long VAR_19 = hwloc_bitmap_to_ulong(VAR_2);

#ifdef VAR_11
      VAR_5 = VAR_9(VAR_1, (void*) &VAR_19);
#else /* COMMENT_5 */
      VAR_5 = VAR_9(VAR_1, sizeof(VAR_19), (void*) &VAR_19);
#endif /* COMMENT_5 */
  }
#endif /* COMMENT_6 */

  if (VAR_5) {
    VAR_6 = VAR_5;
    return -1;
  }
  return 0;
}",,"--- func_before
+++ func_after
@@ -38,6 +38,8 @@
 
      setsize = CPU_ALLOC_SIZE(last+1);
      plinux_set = CPU_ALLOC(last+1);
+     if (!plinux_set)
+       return -1;
 
      CPU_ZERO_S(setsize, plinux_set);
      hwloc_bitmap_foreach_begin(cpu, hwloc_set)","{'deleted_lines': [], 'added_lines': ['     if (!plinux_set)', '       return -1;']}",True,An issue was discovered in open-mpi hwloc 2.1.0 allows attackers to cause a denial of service or other unspecified impacts via glibc-cpuset in topology-linux.c.,4.7,MEDIUM,1,test,2023-08-23T17:52:47Z,4
CVE-2022-47022,['CWE-476'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,open-mpi/hwloc,"linux: handle glibc cpuset allocation failures

Closes #544
CVE-2022-47022

Signed-off-by: Brice Goglin <Brice.Goglin@inria.fr>",ac1f8db9a0790d2bf153711ff4cbf6101f89aace,https://github.com/open-mpi/hwloc/commit/ac1f8db9a0790d2bf153711ff4cbf6101f89aace,hwloc/topology-linux.c,hwloc_linux_get_tid_cpubind,"int
hwloc_linux_get_tid_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, pid_t tid __hwloc_attribute_unused, hwloc_bitmap_t hwloc_set __hwloc_attribute_unused)
{
int err __hwloc_attribute_unused;
#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)
cpu_set_t *plinux_set;
unsigned cpu;
int last;
size_t setsize;
int kernel_nr_cpus;
kernel_nr_cpus = hwloc_linux_find_kernel_nr_cpus(topology);
setsize = CPU_ALLOC_SIZE(kernel_nr_cpus);
plinux_set = CPU_ALLOC(kernel_nr_cpus);
err = sched_getaffinity(tid, setsize, plinux_set);
if (err < 0) {
CPU_FREE(plinux_set);
return -1;
}
last = -1;
if (topology->levels[0][0]->complete_cpuset)
last = hwloc_bitmap_last(topology->levels[0][0]->complete_cpuset);
if (last == -1)
last = kernel_nr_cpus-1;
hwloc_bitmap_zero(hwloc_set);
for(cpu=0; cpu<=(unsigned) last; cpu++)
if (CPU_ISSET_S(cpu, setsize, plinux_set))
hwloc_bitmap_set(hwloc_set, cpu);
CPU_FREE(plinux_set);
#elif defined(HWLOC_HAVE_CPU_SET)
cpu_set_t linux_set;
unsigned cpu;
#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY
err = sched_getaffinity(tid, &linux_set);
#else 
err = sched_getaffinity(tid, sizeof(linux_set), &linux_set);
#endif 
if (err < 0)
return -1;
hwloc_bitmap_zero(hwloc_set);
for(cpu=0; cpu<CPU_SETSIZE; cpu++)
if (CPU_ISSET(cpu, &linux_set))
hwloc_bitmap_set(hwloc_set, cpu);
#elif defined(HWLOC_HAVE_SYSCALL)
unsigned long mask;
#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY
err = sched_getaffinity(tid, (void*) &mask);
#else 
err = sched_getaffinity(tid, sizeof(mask), (void*) &mask);
#endif 
if (err < 0)
return -1;
hwloc_bitmap_from_ulong(hwloc_set, mask);
#else 
errno = ENOSYS;
return -1;
#endif 
return 0;
}","int
hwloc_linux_get_tid_cpubind(hwloc_topology_t VAR_0 VAR_1, pid_t VAR_2 VAR_1, hwloc_bitmap_t VAR_3 VAR_1)
{
int VAR_4 VAR_1;
#if defined(VAR_5) && !defined(VAR_6)
cpu_set_t *VAR_7;
unsigned VAR_8;
int VAR_9;
size_t VAR_10;
int VAR_11;
VAR_11 = hwloc_linux_find_kernel_nr_cpus(VAR_0);
VAR_10 = CPU_ALLOC_SIZE(VAR_11);
VAR_7 = CPU_ALLOC(VAR_11);
VAR_4 = sched_getaffinity(VAR_2, VAR_10, VAR_7);
if (VAR_4 < 0) {
CPU_FREE(VAR_7);
return -1;
}
VAR_9 = -1;
if (VAR_0->levels[0][0]->complete_cpuset)
VAR_9 = hwloc_bitmap_last(VAR_0->levels[0][0]->complete_cpuset);
if (VAR_9 == -1)
VAR_9 = VAR_11-1;
hwloc_bitmap_zero(VAR_3);
for(VAR_8=0; VAR_8<=(unsigned) VAR_9; VAR_8++)
if (CPU_ISSET_S(VAR_8, VAR_10, VAR_7))
hwloc_bitmap_set(VAR_3, VAR_8);
CPU_FREE(VAR_7);
#elif defined(VAR_12)
cpu_set_t VAR_13;
unsigned VAR_8;
#ifdef VAR_6
VAR_4 = sched_getaffinity(VAR_2, &VAR_13);
#else 
VAR_4 = sched_getaffinity(VAR_2, sizeof(VAR_13), &VAR_13);
#endif 
if (VAR_4 < 0)
return -1;
hwloc_bitmap_zero(VAR_3);
for(VAR_8=0; VAR_8<VAR_14; VAR_8++)
if (CPU_ISSET(VAR_8, &VAR_13))
hwloc_bitmap_set(VAR_3, VAR_8);
#elif defined(VAR_15)
unsigned long VAR_16;
#ifdef VAR_6
VAR_4 = sched_getaffinity(VAR_2, (void*) &VAR_16);
#else 
VAR_4 = sched_getaffinity(VAR_2, sizeof(VAR_16), (void*) &VAR_16);
#endif 
if (VAR_4 < 0)
return -1;
hwloc_bitmap_from_ulong(VAR_3, VAR_16);
#else 
VAR_17 = VAR_18;
return -1;
#endif 
return 0;
}",,"int
hwloc_linux_get_tid_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, pid_t tid __hwloc_attribute_unused, hwloc_bitmap_t hwloc_set __hwloc_attribute_unused)
{
  int err __hwloc_attribute_unused;

#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)
  cpu_set_t *plinux_set;
  unsigned cpu;
  int last;
  size_t setsize;
  int kernel_nr_cpus;

  /* find the kernel nr_cpus so as to use a large enough cpu_set size */
  kernel_nr_cpus = hwloc_linux_find_kernel_nr_cpus(topology);
  if (kernel_nr_cpus < 0)
    return -1;
  setsize = CPU_ALLOC_SIZE(kernel_nr_cpus);
  plinux_set = CPU_ALLOC(kernel_nr_cpus);
  if (!plinux_set)
    return -1;

  err = sched_getaffinity(tid, setsize, plinux_set);

  if (err < 0) {
    CPU_FREE(plinux_set);
    return -1;
  }

  last = -1;
  if (topology->levels[0][0]->complete_cpuset)
    last = hwloc_bitmap_last(topology->levels[0][0]->complete_cpuset);
  if (last == -1)
    /* round the maximal support number, the topology isn't ready yet (complete_cpuset is missing or empty)*/
    last = kernel_nr_cpus-1;

  hwloc_bitmap_zero(hwloc_set);
  for(cpu=0; cpu<=(unsigned) last; cpu++)
    if (CPU_ISSET_S(cpu, setsize, plinux_set))
      hwloc_bitmap_set(hwloc_set, cpu);

  CPU_FREE(plinux_set);
#elif defined(HWLOC_HAVE_CPU_SET)
  cpu_set_t linux_set;
  unsigned cpu;

#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY
  err = sched_getaffinity(tid, &linux_set);
#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */
  err = sched_getaffinity(tid, sizeof(linux_set), &linux_set);
#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */
  if (err < 0)
    return -1;

  hwloc_bitmap_zero(hwloc_set);
  for(cpu=0; cpu<CPU_SETSIZE; cpu++)
    if (CPU_ISSET(cpu, &linux_set))
      hwloc_bitmap_set(hwloc_set, cpu);
#elif defined(HWLOC_HAVE_SYSCALL)
  unsigned long mask;

#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY
  err = sched_getaffinity(tid, (void*) &mask);
#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */
  err = sched_getaffinity(tid, sizeof(mask), (void*) &mask);
#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */
  if (err < 0)
    return -1;

  hwloc_bitmap_from_ulong(hwloc_set, mask);
#else /* !SYSCALL */
  errno = ENOSYS;
  return -1;
#endif /* !SYSCALL */

  return 0;
}","int
hwloc_linux_get_tid_cpubind(hwloc_topology_t VAR_0 VAR_1, pid_t VAR_2 VAR_1, hwloc_bitmap_t VAR_3 VAR_1)
{
  int VAR_4 VAR_1;

#if defined(VAR_5) && !defined(VAR_6)
  cpu_set_t *VAR_7;
  unsigned VAR_8;
  int VAR_9;
  size_t VAR_10;
  int VAR_11;

  /* COMMENT_0 */
  VAR_11 = hwloc_linux_find_kernel_nr_cpus(VAR_0);
  if (VAR_11 < 0)
    return -1;
  VAR_10 = CPU_ALLOC_SIZE(VAR_11);
  VAR_7 = CPU_ALLOC(VAR_11);
  if (!VAR_7)
    return -1;

  VAR_4 = sched_getaffinity(VAR_2, VAR_10, VAR_7);

  if (VAR_4 < 0) {
    CPU_FREE(VAR_7);
    return -1;
  }

  VAR_9 = -1;
  if (VAR_0->levels[0][0]->complete_cpuset)
    VAR_9 = hwloc_bitmap_last(VAR_0->levels[0][0]->complete_cpuset);
  if (VAR_9 == -1)
    /* COMMENT_1 */
    VAR_9 = VAR_11-1;

  hwloc_bitmap_zero(VAR_3);
  for(VAR_8=0; VAR_8<=(unsigned) VAR_9; VAR_8++)
    if (CPU_ISSET_S(VAR_8, VAR_10, VAR_7))
      hwloc_bitmap_set(VAR_3, VAR_8);

  CPU_FREE(VAR_7);
#elif defined(VAR_12)
  cpu_set_t VAR_13;
  unsigned VAR_8;

#ifdef VAR_6
  VAR_4 = sched_getaffinity(VAR_2, &VAR_13);
#else /* COMMENT_2 */
  VAR_4 = sched_getaffinity(VAR_2, sizeof(VAR_13), &VAR_13);
#endif /* COMMENT_2 */
  if (VAR_4 < 0)
    return -1;

  hwloc_bitmap_zero(VAR_3);
  for(VAR_8=0; VAR_8<VAR_14; VAR_8++)
    if (CPU_ISSET(VAR_8, &VAR_13))
      hwloc_bitmap_set(VAR_3, VAR_8);
#elif defined(VAR_15)
  unsigned long VAR_16;

#ifdef VAR_6
  VAR_4 = sched_getaffinity(VAR_2, (void*) &VAR_16);
#else /* COMMENT_2 */
  VAR_4 = sched_getaffinity(VAR_2, sizeof(VAR_16), (void*) &VAR_16);
#endif /* COMMENT_2 */
  if (VAR_4 < 0)
    return -1;

  hwloc_bitmap_from_ulong(VAR_3, VAR_16);
#else /* COMMENT_3 */
  VAR_17 = VAR_18;
  return -1;
#endif /* COMMENT_3 */

  return 0;
}",,"--- func_before
+++ func_after
@@ -12,8 +12,12 @@
 
   /* find the kernel nr_cpus so as to use a large enough cpu_set size */
   kernel_nr_cpus = hwloc_linux_find_kernel_nr_cpus(topology);
+  if (kernel_nr_cpus < 0)
+    return -1;
   setsize = CPU_ALLOC_SIZE(kernel_nr_cpus);
   plinux_set = CPU_ALLOC(kernel_nr_cpus);
+  if (!plinux_set)
+    return -1;
 
   err = sched_getaffinity(tid, setsize, plinux_set);
 ","{'deleted_lines': [], 'added_lines': ['  if (kernel_nr_cpus < 0)', '    return -1;', '  if (!plinux_set)', '    return -1;']}",True,An issue was discovered in open-mpi hwloc 2.1.0 allows attackers to cause a denial of service or other unspecified impacts via glibc-cpuset in topology-linux.c.,4.7,MEDIUM,1,test,2023-08-23T17:52:47Z,4
CVE-2022-47022,['CWE-476'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,open-mpi/hwloc,"linux: handle glibc cpuset allocation failures

Closes #544
CVE-2022-47022

Signed-off-by: Brice Goglin <Brice.Goglin@inria.fr>",ac1f8db9a0790d2bf153711ff4cbf6101f89aace,https://github.com/open-mpi/hwloc/commit/ac1f8db9a0790d2bf153711ff4cbf6101f89aace,hwloc/topology-linux.c,hwloc_linux_get_thread_cpubind,"static int
hwloc_linux_get_thread_cpubind(hwloc_topology_t topology, pthread_t tid, hwloc_bitmap_t hwloc_set, int flags __hwloc_attribute_unused)
{
int err;
if (topology->pid) {
errno = ENOSYS;
return -1;
}
if (!pthread_self) {
errno = ENOSYS;
return -1;
}
if (tid == pthread_self())
return hwloc_linux_get_tid_cpubind(topology, 0, hwloc_set);
if (!pthread_getaffinity_np) {
errno = ENOSYS;
return -1;
}
#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)
{
cpu_set_t *plinux_set;
unsigned cpu;
int last;
size_t setsize;
last = hwloc_bitmap_last(topology->levels[0][0]->complete_cpuset);
assert (last != -1);
setsize = CPU_ALLOC_SIZE(last+1);
plinux_set = CPU_ALLOC(last+1);
err = pthread_getaffinity_np(tid, setsize, plinux_set);
if (err) {
CPU_FREE(plinux_set);
errno = err;
return -1;
}
hwloc_bitmap_zero(hwloc_set);
for(cpu=0; cpu<=(unsigned) last; cpu++)
if (CPU_ISSET_S(cpu, setsize, plinux_set))
hwloc_bitmap_set(hwloc_set, cpu);
CPU_FREE(plinux_set);
}
#elif defined(HWLOC_HAVE_CPU_SET)
{
cpu_set_t linux_set;
unsigned cpu;
#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY
err = pthread_getaffinity_np(tid, &linux_set);
#else 
err = pthread_getaffinity_np(tid, sizeof(linux_set), &linux_set);
#endif 
if (err) {
errno = err;
return -1;
}
hwloc_bitmap_zero(hwloc_set);
for(cpu=0; cpu<CPU_SETSIZE; cpu++)
if (CPU_ISSET(cpu, &linux_set))
hwloc_bitmap_set(hwloc_set, cpu);
}
#else 
{
unsigned long mask;
#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY
err = pthread_getaffinity_np(tid, (void*) &mask);
#else 
err = pthread_getaffinity_np(tid, sizeof(mask), (void*) &mask);
#endif 
if (err) {
errno = err;
return -1;
}
hwloc_bitmap_from_ulong(hwloc_set, mask);
}
#endif 
return 0;
}","static int
hwloc_linux_get_thread_cpubind(hwloc_topology_t VAR_0, pthread_t VAR_1, hwloc_bitmap_t VAR_2, int VAR_3 VAR_4)
{
int VAR_5;
if (VAR_0->pid) {
VAR_6 = VAR_7;
return -1;
}
if (!VAR_8) {
VAR_6 = VAR_7;
return -1;
}
if (VAR_1 == VAR_8())
return hwloc_linux_get_tid_cpubind(VAR_0, 0, VAR_2);
if (!VAR_9) {
VAR_6 = VAR_7;
return -1;
}
#if defined(VAR_10) && !defined(VAR_11)
{
cpu_set_t *VAR_12;
unsigned VAR_13;
int VAR_14;
size_t VAR_15;
VAR_14 = hwloc_bitmap_last(VAR_0->levels[0][0]->complete_cpuset);
assert (VAR_14 != -1);
VAR_15 = CPU_ALLOC_SIZE(VAR_14+1);
VAR_12 = CPU_ALLOC(VAR_14+1);
VAR_5 = VAR_9(VAR_1, VAR_15, VAR_12);
if (VAR_5) {
CPU_FREE(VAR_12);
VAR_6 = VAR_5;
return -1;
}
hwloc_bitmap_zero(VAR_2);
for(VAR_13=0; VAR_13<=(unsigned) VAR_14; VAR_13++)
if (CPU_ISSET_S(VAR_13, VAR_15, VAR_12))
hwloc_bitmap_set(VAR_2, VAR_13);
CPU_FREE(VAR_12);
}
#elif defined(VAR_16)
{
cpu_set_t VAR_17;
unsigned VAR_13;
#ifdef VAR_11
VAR_5 = VAR_9(VAR_1, &VAR_17);
#else 
VAR_5 = VAR_9(VAR_1, sizeof(VAR_17), &VAR_17);
#endif 
if (VAR_5) {
VAR_6 = VAR_5;
return -1;
}
hwloc_bitmap_zero(VAR_2);
for(VAR_13=0; VAR_13<VAR_18; VAR_13++)
if (CPU_ISSET(VAR_13, &VAR_17))
hwloc_bitmap_set(VAR_2, VAR_13);
}
#else 
{
unsigned long VAR_19;
#ifdef VAR_11
VAR_5 = VAR_9(VAR_1, (void*) &VAR_19);
#else 
VAR_5 = VAR_9(VAR_1, sizeof(VAR_19), (void*) &VAR_19);
#endif 
if (VAR_5) {
VAR_6 = VAR_5;
return -1;
}
hwloc_bitmap_from_ulong(VAR_2, VAR_19);
}
#endif 
return 0;
}",,"static int
hwloc_linux_get_thread_cpubind(hwloc_topology_t topology, pthread_t tid, hwloc_bitmap_t hwloc_set, int flags __hwloc_attribute_unused)
{
  int err;

  if (topology->pid) {
    errno = ENOSYS;
    return -1;
  }

  if (!pthread_self) {
    /* ?! Application uses set_thread_cpubind, but doesn't link against libpthread ?! */
    errno = ENOSYS;
    return -1;
  }
  if (tid == pthread_self())
    return hwloc_linux_get_tid_cpubind(topology, 0, hwloc_set);

  if (!pthread_getaffinity_np) {
    errno = ENOSYS;
    return -1;
  }

#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)
  /* Use a separate block so that we can define specific variable
     types here */
  {
     cpu_set_t *plinux_set;
     unsigned cpu;
     int last;
     size_t setsize;

     last = hwloc_bitmap_last(topology->levels[0][0]->complete_cpuset);
     assert (last != -1);

     setsize = CPU_ALLOC_SIZE(last+1);
     plinux_set = CPU_ALLOC(last+1);
     if (!plinux_set)
       return -1;

     err = pthread_getaffinity_np(tid, setsize, plinux_set);
     if (err) {
        CPU_FREE(plinux_set);
        errno = err;
        return -1;
     }

     hwloc_bitmap_zero(hwloc_set);
     for(cpu=0; cpu<=(unsigned) last; cpu++)
       if (CPU_ISSET_S(cpu, setsize, plinux_set))
	 hwloc_bitmap_set(hwloc_set, cpu);

     CPU_FREE(plinux_set);
  }
#elif defined(HWLOC_HAVE_CPU_SET)
  /* Use a separate block so that we can define specific variable
     types here */
  {
     cpu_set_t linux_set;
     unsigned cpu;

#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY
     err = pthread_getaffinity_np(tid, &linux_set);
#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */
     err = pthread_getaffinity_np(tid, sizeof(linux_set), &linux_set);
#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */
     if (err) {
        errno = err;
        return -1;
     }

     hwloc_bitmap_zero(hwloc_set);
     for(cpu=0; cpu<CPU_SETSIZE; cpu++)
       if (CPU_ISSET(cpu, &linux_set))
	 hwloc_bitmap_set(hwloc_set, cpu);
  }
#else /* CPU_SET */
  /* Use a separate block so that we can define specific variable
     types here */
  {
      unsigned long mask;

#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY
      err = pthread_getaffinity_np(tid, (void*) &mask);
#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */
      err = pthread_getaffinity_np(tid, sizeof(mask), (void*) &mask);
#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */
      if (err) {
        errno = err;
        return -1;
      }

     hwloc_bitmap_from_ulong(hwloc_set, mask);
  }
#endif /* CPU_SET */

  return 0;
}","static int
hwloc_linux_get_thread_cpubind(hwloc_topology_t VAR_0, pthread_t VAR_1, hwloc_bitmap_t VAR_2, int VAR_3 VAR_4)
{
  int VAR_5;

  if (VAR_0->pid) {
    VAR_6 = VAR_7;
    return -1;
  }

  if (!VAR_8) {
    /* COMMENT_0 */
    VAR_6 = VAR_7;
    return -1;
  }
  if (VAR_1 == VAR_8())
    return hwloc_linux_get_tid_cpubind(VAR_0, 0, VAR_2);

  if (!VAR_9) {
    VAR_6 = VAR_7;
    return -1;
  }

#if defined(VAR_10) && !defined(VAR_11)
  /* COMMENT_1 */
                  
  {
     cpu_set_t *VAR_12;
     unsigned VAR_13;
     int VAR_14;
     size_t VAR_15;

     VAR_14 = hwloc_bitmap_last(VAR_0->levels[0][0]->complete_cpuset);
     assert (VAR_14 != -1);

     VAR_15 = CPU_ALLOC_SIZE(VAR_14+1);
     VAR_12 = CPU_ALLOC(VAR_14+1);
     if (!VAR_12)
       return -1;

     VAR_5 = VAR_9(VAR_1, VAR_15, VAR_12);
     if (VAR_5) {
        CPU_FREE(VAR_12);
        VAR_6 = VAR_5;
        return -1;
     }

     hwloc_bitmap_zero(VAR_2);
     for(VAR_13=0; VAR_13<=(unsigned) VAR_14; VAR_13++)
       if (CPU_ISSET_S(VAR_13, VAR_15, VAR_12))
	 hwloc_bitmap_set(VAR_2, VAR_13);

     CPU_FREE(VAR_12);
  }
#elif defined(VAR_16)
  /* COMMENT_3 */
                  
  {
     cpu_set_t VAR_17;
     unsigned VAR_13;

#ifdef VAR_11
     VAR_5 = VAR_9(VAR_1, &VAR_17);
#else /* COMMENT_5 */
     VAR_5 = VAR_9(VAR_1, sizeof(VAR_17), &VAR_17);
#endif /* COMMENT_5 */
     if (VAR_5) {
        VAR_6 = VAR_5;
        return -1;
     }

     hwloc_bitmap_zero(VAR_2);
     for(VAR_13=0; VAR_13<VAR_18; VAR_13++)
       if (CPU_ISSET(VAR_13, &VAR_17))
	 hwloc_bitmap_set(VAR_2, VAR_13);
  }
#else /* COMMENT_6 */
  /* COMMENT_7 */
                  
  {
      unsigned long VAR_19;

#ifdef VAR_11
      VAR_5 = VAR_9(VAR_1, (void*) &VAR_19);
#else /* COMMENT_5 */
      VAR_5 = VAR_9(VAR_1, sizeof(VAR_19), (void*) &VAR_19);
#endif /* COMMENT_5 */
      if (VAR_5) {
        VAR_6 = VAR_5;
        return -1;
      }

     hwloc_bitmap_from_ulong(VAR_2, VAR_19);
  }
#endif /* COMMENT_6 */

  return 0;
}",,"--- func_before
+++ func_after
@@ -35,6 +35,8 @@
 
      setsize = CPU_ALLOC_SIZE(last+1);
      plinux_set = CPU_ALLOC(last+1);
+     if (!plinux_set)
+       return -1;
 
      err = pthread_getaffinity_np(tid, setsize, plinux_set);
      if (err) {","{'deleted_lines': [], 'added_lines': ['     if (!plinux_set)', '       return -1;']}",True,An issue was discovered in open-mpi hwloc 2.1.0 allows attackers to cause a denial of service or other unspecified impacts via glibc-cpuset in topology-linux.c.,4.7,MEDIUM,1,test,2023-08-23T17:52:47Z,4
CVE-2022-47022,['CWE-476'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,open-mpi/hwloc,"linux: handle glibc cpuset allocation failures

Closes #544
CVE-2022-47022

Signed-off-by: Brice Goglin <Brice.Goglin@inria.fr>",ac1f8db9a0790d2bf153711ff4cbf6101f89aace,https://github.com/open-mpi/hwloc/commit/ac1f8db9a0790d2bf153711ff4cbf6101f89aace,hwloc/topology-linux.c,hwloc_linux_set_tid_cpubind,"int
hwloc_linux_set_tid_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, pid_t tid __hwloc_attribute_unused, hwloc_const_bitmap_t hwloc_set __hwloc_attribute_unused)
{
#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)
cpu_set_t *plinux_set;
unsigned cpu;
int last;
size_t setsize;
int err;
last = hwloc_bitmap_last(hwloc_set);
if (last == -1) {
errno = EINVAL;
return -1;
}
setsize = CPU_ALLOC_SIZE(last+1);
plinux_set = CPU_ALLOC(last+1);
CPU_ZERO_S(setsize, plinux_set);
hwloc_bitmap_foreach_begin(cpu, hwloc_set)
CPU_SET_S(cpu, setsize, plinux_set);
hwloc_bitmap_foreach_end();
err = sched_setaffinity(tid, setsize, plinux_set);
CPU_FREE(plinux_set);
return err;
#elif defined(HWLOC_HAVE_CPU_SET)
cpu_set_t linux_set;
unsigned cpu;
CPU_ZERO(&linux_set);
hwloc_bitmap_foreach_begin(cpu, hwloc_set)
CPU_SET(cpu, &linux_set);
hwloc_bitmap_foreach_end();
#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY
return sched_setaffinity(tid, &linux_set);
#else 
return sched_setaffinity(tid, sizeof(linux_set), &linux_set);
#endif 
#elif defined(HWLOC_HAVE_SYSCALL)
unsigned long mask = hwloc_bitmap_to_ulong(hwloc_set);
#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY
return sched_setaffinity(tid, (void*) &mask);
#else 
return sched_setaffinity(tid, sizeof(mask), (void*) &mask);
#endif 
#else 
errno = ENOSYS;
return -1;
#endif 
}","int
hwloc_linux_set_tid_cpubind(hwloc_topology_t VAR_0 VAR_1, pid_t VAR_2 VAR_1, hwloc_const_bitmap_t VAR_3 VAR_1)
{
#if defined(VAR_4) && !defined(VAR_5)
cpu_set_t *VAR_6;
unsigned VAR_7;
int VAR_8;
size_t VAR_9;
int VAR_10;
VAR_8 = hwloc_bitmap_last(VAR_3);
if (VAR_8 == -1) {
VAR_11 = VAR_12;
return -1;
}
VAR_9 = CPU_ALLOC_SIZE(VAR_8+1);
VAR_6 = CPU_ALLOC(VAR_8+1);
CPU_ZERO_S(VAR_9, VAR_6);
hwloc_bitmap_foreach_begin(VAR_7, VAR_3)
CPU_SET_S(VAR_7, VAR_9, VAR_6);
hwloc_bitmap_foreach_end();
VAR_10 = sched_setaffinity(VAR_2, VAR_9, VAR_6);
CPU_FREE(VAR_6);
return VAR_10;
#elif defined(VAR_13)
cpu_set_t VAR_14;
unsigned VAR_7;
CPU_ZERO(&VAR_14);
hwloc_bitmap_foreach_begin(VAR_7, VAR_3)
CPU_SET(VAR_7, &VAR_14);
hwloc_bitmap_foreach_end();
#ifdef VAR_5
return sched_setaffinity(VAR_2, &VAR_14);
#else 
return sched_setaffinity(VAR_2, sizeof(VAR_14), &VAR_14);
#endif 
#elif defined(VAR_15)
unsigned long VAR_16 = hwloc_bitmap_to_ulong(VAR_3);
#ifdef VAR_5
return sched_setaffinity(VAR_2, (void*) &VAR_16);
#else 
return sched_setaffinity(VAR_2, sizeof(VAR_16), (void*) &VAR_16);
#endif 
#else 
VAR_11 = VAR_17;
return -1;
#endif 
}",,"int
hwloc_linux_set_tid_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, pid_t tid __hwloc_attribute_unused, hwloc_const_bitmap_t hwloc_set __hwloc_attribute_unused)
{
  /* The resulting binding is always strict */

#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)
  cpu_set_t *plinux_set;
  unsigned cpu;
  int last;
  size_t setsize;
  int err;

  last = hwloc_bitmap_last(hwloc_set);
  if (last == -1) {
    errno = EINVAL;
    return -1;
  }

  setsize = CPU_ALLOC_SIZE(last+1);
  plinux_set = CPU_ALLOC(last+1);
  if (!plinux_set)
    return -1;

  CPU_ZERO_S(setsize, plinux_set);
  hwloc_bitmap_foreach_begin(cpu, hwloc_set)
    CPU_SET_S(cpu, setsize, plinux_set);
  hwloc_bitmap_foreach_end();

  err = sched_setaffinity(tid, setsize, plinux_set);

  CPU_FREE(plinux_set);
  return err;
#elif defined(HWLOC_HAVE_CPU_SET)
  cpu_set_t linux_set;
  unsigned cpu;

  CPU_ZERO(&linux_set);
  hwloc_bitmap_foreach_begin(cpu, hwloc_set)
    CPU_SET(cpu, &linux_set);
  hwloc_bitmap_foreach_end();

#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY
  return sched_setaffinity(tid, &linux_set);
#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */
  return sched_setaffinity(tid, sizeof(linux_set), &linux_set);
#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */
#elif defined(HWLOC_HAVE_SYSCALL)
  unsigned long mask = hwloc_bitmap_to_ulong(hwloc_set);

#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY
  return sched_setaffinity(tid, (void*) &mask);
#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */
  return sched_setaffinity(tid, sizeof(mask), (void*) &mask);
#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */
#else /* !SYSCALL */
  errno = ENOSYS;
  return -1;
#endif /* !SYSCALL */
}","int
hwloc_linux_set_tid_cpubind(hwloc_topology_t VAR_0 VAR_1, pid_t VAR_2 VAR_1, hwloc_const_bitmap_t VAR_3 VAR_1)
{
  /* COMMENT_0 */

#if defined(VAR_4) && !defined(VAR_5)
  cpu_set_t *VAR_6;
  unsigned VAR_7;
  int VAR_8;
  size_t VAR_9;
  int VAR_10;

  VAR_8 = hwloc_bitmap_last(VAR_3);
  if (VAR_8 == -1) {
    VAR_11 = VAR_12;
    return -1;
  }

  VAR_9 = CPU_ALLOC_SIZE(VAR_8+1);
  VAR_6 = CPU_ALLOC(VAR_8+1);
  if (!VAR_6)
    return -1;

  CPU_ZERO_S(VAR_9, VAR_6);
  hwloc_bitmap_foreach_begin(VAR_7, VAR_3)
    CPU_SET_S(VAR_7, VAR_9, VAR_6);
  hwloc_bitmap_foreach_end();

  VAR_10 = sched_setaffinity(VAR_2, VAR_9, VAR_6);

  CPU_FREE(VAR_6);
  return VAR_10;
#elif defined(VAR_13)
  cpu_set_t VAR_14;
  unsigned VAR_7;

  CPU_ZERO(&VAR_14);
  hwloc_bitmap_foreach_begin(VAR_7, VAR_3)
    CPU_SET(VAR_7, &VAR_14);
  hwloc_bitmap_foreach_end();

#ifdef VAR_5
  return sched_setaffinity(VAR_2, &VAR_14);
#else /* COMMENT_1 */
  return sched_setaffinity(VAR_2, sizeof(VAR_14), &VAR_14);
#endif /* COMMENT_1 */
#elif defined(VAR_15)
  unsigned long VAR_16 = hwloc_bitmap_to_ulong(VAR_3);

#ifdef VAR_5
  return sched_setaffinity(VAR_2, (void*) &VAR_16);
#else /* COMMENT_1 */
  return sched_setaffinity(VAR_2, sizeof(VAR_16), (void*) &VAR_16);
#endif /* COMMENT_1 */
#else /* COMMENT_2 */
  VAR_11 = VAR_17;
  return -1;
#endif /* COMMENT_2 */
}",,"--- func_before
+++ func_after
@@ -18,6 +18,8 @@
 
   setsize = CPU_ALLOC_SIZE(last+1);
   plinux_set = CPU_ALLOC(last+1);
+  if (!plinux_set)
+    return -1;
 
   CPU_ZERO_S(setsize, plinux_set);
   hwloc_bitmap_foreach_begin(cpu, hwloc_set)","{'deleted_lines': [], 'added_lines': ['  if (!plinux_set)', '    return -1;']}",True,An issue was discovered in open-mpi hwloc 2.1.0 allows attackers to cause a denial of service or other unspecified impacts via glibc-cpuset in topology-linux.c.,4.7,MEDIUM,1,test,2023-08-23T17:52:47Z,4
CVE-2022-47022,['CWE-476'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,1,open-mpi/hwloc,"linux: handle glibc cpuset allocation failures

Closes #544
CVE-2022-47022

Signed-off-by: Brice Goglin <Brice.Goglin@inria.fr>",ac1f8db9a0790d2bf153711ff4cbf6101f89aace,https://github.com/open-mpi/hwloc/commit/ac1f8db9a0790d2bf153711ff4cbf6101f89aace,hwloc/topology-linux.c,hwloc_linux_find_kernel_nr_cpus,"static int
hwloc_linux_find_kernel_nr_cpus(hwloc_topology_t topology)
{
static int _nr_cpus = -1;
int nr_cpus = _nr_cpus;
hwloc_bitmap_t possible_bitmap;
if (nr_cpus != -1)
return nr_cpus;
if (topology->levels[0][0]->complete_cpuset)
nr_cpus = hwloc_bitmap_last(topology->levels[0][0]->complete_cpuset) + 1;
if (nr_cpus <= 0)
nr_cpus = 1;
possible_bitmap = hwloc__alloc_read_path_as_cpulist(""/sys/devices/system/cpu/possible"", -1); 
if (possible_bitmap) {
int max_possible = hwloc_bitmap_last(possible_bitmap);
hwloc_debug_bitmap(""possible CPUs are %s\n"", possible_bitmap);
if (nr_cpus < max_possible + 1)
nr_cpus = max_possible + 1;
hwloc_bitmap_free(possible_bitmap);
}
while (1) {
cpu_set_t *set = CPU_ALLOC(nr_cpus);
size_t setsize = CPU_ALLOC_SIZE(nr_cpus);
int err = sched_getaffinity(0, setsize, set); 
CPU_FREE(set);
nr_cpus = setsize * 8; 
if (!err)
return _nr_cpus = nr_cpus;
nr_cpus *= 2;
}
}","static int
hwloc_linux_find_kernel_nr_cpus(hwloc_topology_t VAR_0)
{
static int VAR_1 = -1;
int VAR_2 = VAR_1;
hwloc_bitmap_t VAR_3;
if (VAR_2 != -1)
return VAR_2;
if (VAR_0->levels[0][0]->complete_cpuset)
VAR_2 = hwloc_bitmap_last(VAR_0->levels[0][0]->complete_cpuset) + 1;
if (VAR_2 <= 0)
VAR_2 = 1;
VAR_3 = hwloc__alloc_read_path_as_cpulist(""/sys/devices/system/cpu/possible"", -1); 
if (VAR_3) {
int VAR_4 = hwloc_bitmap_last(VAR_3);
hwloc_debug_bitmap(""possible CPUs are %s\n"", VAR_3);
if (VAR_2 < VAR_4 + 1)
VAR_2 = VAR_4 + 1;
hwloc_bitmap_free(VAR_3);
}
while (1) {
cpu_set_t *VAR_5 = CPU_ALLOC(VAR_2);
size_t VAR_6 = CPU_ALLOC_SIZE(VAR_2);
int VAR_7 = sched_getaffinity(0, VAR_6, VAR_5); 
CPU_FREE(VAR_5);
VAR_2 = VAR_6 * 8; 
if (!VAR_7)
return VAR_1 = VAR_2;
VAR_2 *= 2;
}
}",open-mpi/hwloc/ac1f8db9a0790d2bf153711ff4cbf6101f89aace/topology-linux.c/vul/before/1.json,"static int
hwloc_linux_find_kernel_nr_cpus(hwloc_topology_t topology)
{
  static int _nr_cpus = -1;
  int nr_cpus = _nr_cpus;
  hwloc_bitmap_t possible_bitmap;

  if (nr_cpus != -1)
    /* already computed */
    return nr_cpus;

  if (topology->levels[0][0]->complete_cpuset)
    /* start with a nr_cpus that may contain the whole topology */
    nr_cpus = hwloc_bitmap_last(topology->levels[0][0]->complete_cpuset) + 1;
  if (nr_cpus <= 0)
    /* start from scratch, the topology isn't ready yet (complete_cpuset is missing (-1) or empty (0))*/
    nr_cpus = 1;

  /* reading /sys/devices/system/cpu/kernel_max would be easier (single value to parse instead of a list),
   * but its value may be way too large (5119 on CentOS7).
   * /sys/devices/system/cpu/possible is better because it matches the current hardware.
   */

  possible_bitmap = hwloc__alloc_read_path_as_cpulist(""/sys/devices/system/cpu/possible"", -1); /* binding only supported in real fsroot, no need for data->root_fd */
  if (possible_bitmap) {
    int max_possible = hwloc_bitmap_last(possible_bitmap);
    hwloc_debug_bitmap(""possible CPUs are %s\n"", possible_bitmap);
    if (nr_cpus < max_possible + 1)
      nr_cpus = max_possible + 1;
    hwloc_bitmap_free(possible_bitmap);
  }

  while (1) {
    cpu_set_t *set = CPU_ALLOC(nr_cpus);
    size_t setsize = CPU_ALLOC_SIZE(nr_cpus);
    int err;
    if (!set)
      return -1; /* caller will return an error, and we'll try again later */
    err = sched_getaffinity(0, setsize, set); /* always works, unless setsize is too small */
    CPU_FREE(set);
    nr_cpus = setsize * 8; /* that's the value that was actually tested */
    if (!err)
      /* Found it. Only update the static value with the final one,
       * to avoid sharing intermediate values that we modify,
       * in case there's ever multiple concurrent calls.
       */
      return _nr_cpus = nr_cpus;
    nr_cpus *= 2;
  }
}","static int
hwloc_linux_find_kernel_nr_cpus(hwloc_topology_t VAR_0)
{
  static int VAR_1 = -1;
  int VAR_2 = VAR_1;
  hwloc_bitmap_t VAR_3;

  if (VAR_2 != -1)
    /* COMMENT_0 */
    return VAR_2;

  if (VAR_0->levels[0][0]->complete_cpuset)
    /* COMMENT_1 */
    VAR_2 = hwloc_bitmap_last(VAR_0->levels[0][0]->complete_cpuset) + 1;
  if (VAR_2 <= 0)
    /* COMMENT_2 */
    VAR_2 = 1;

  /* COMMENT_3 */
                                                          
                                                                                        
     

  VAR_3 = hwloc__alloc_read_path_as_cpulist(""/sys/devices/system/cpu/possible"", -1); /* COMMENT_7 */
  if (VAR_3) {
    int VAR_4 = hwloc_bitmap_last(VAR_3);
    hwloc_debug_bitmap(""possible CPUs are %s\n"", VAR_3);
    if (VAR_2 < VAR_4 + 1)
      VAR_2 = VAR_4 + 1;
    hwloc_bitmap_free(VAR_3);
  }

  while (1) {
    cpu_set_t *VAR_5 = CPU_ALLOC(VAR_2);
    size_t VAR_6 = CPU_ALLOC_SIZE(VAR_2);
    int VAR_7;
    if (!VAR_5)
      return -1; /* COMMENT_8 */
    VAR_7 = sched_getaffinity(0, VAR_6, VAR_5); /* COMMENT_9 */
    CPU_FREE(VAR_5);
    VAR_2 = VAR_6 * 8; /* COMMENT_10 */
    if (!VAR_7)
      /* COMMENT_11 */
                                                             
                                                        
         
      return VAR_1 = VAR_2;
    VAR_2 *= 2;
  }
}",open-mpi/hwloc/ac1f8db9a0790d2bf153711ff4cbf6101f89aace/topology-linux.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -33,7 +33,10 @@
   while (1) {
     cpu_set_t *set = CPU_ALLOC(nr_cpus);
     size_t setsize = CPU_ALLOC_SIZE(nr_cpus);
-    int err = sched_getaffinity(0, setsize, set); /* always works, unless setsize is too small */
+    int err;
+    if (!set)
+      return -1; /* caller will return an error, and we'll try again later */
+    err = sched_getaffinity(0, setsize, set); /* always works, unless setsize is too small */
     CPU_FREE(set);
     nr_cpus = setsize * 8; /* that's the value that was actually tested */
     if (!err)","{'deleted_lines': ['    int err = sched_getaffinity(0, setsize, set); /* always works, unless setsize is too small */'], 'added_lines': ['    int err;', '    if (!set)', ""      return -1; /* caller will return an error, and we'll try again later */"", '    err = sched_getaffinity(0, setsize, set); /* always works, unless setsize is too small */']}",True,An issue was discovered in open-mpi hwloc 2.1.0 allows attackers to cause a denial of service or other unspecified impacts via glibc-cpuset in topology-linux.c.,4.7,MEDIUM,1,test,2023-08-23T17:52:47Z,4
CVE-2023-4721,['CWE-125'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,gpac,Fixed #2580,3ec93d73d048ed7b46fe6e9f307cc7a0cc13db63,https://github.com/gpac/gpac/commit/3ec93d73d048ed7b46fe6e9f307cc7a0cc13db63,src/media_tools/mpeg2_ps.c,MPEG12_ParseSeqHdr,"int MPEG12_ParseSeqHdr(unsigned char *pbuffer, u32 buflen, s32 *have_mpeg2, u32 *height, u32 *width,
Double *frame_rate, Double *bitrate, u32 *aspect_ratio)
{
u32 aspect_code;
u32 framerate_code;
u32 bitrate_int;
u32 bitrate_ext;
u32 scode, ix;
s32 found = -1;
*have_mpeg2 = 0;
buflen -= 6;
bitrate_int = 0;
for (ix = 0; ix < buflen; ix++, pbuffer++) {
scode = ((u32)pbuffer[0] << 24) | (pbuffer[1] << 16) | (pbuffer[2] << 8) |
pbuffer[3];
if (scode == MPEG12_SEQUENCE_START_CODE) {
pbuffer += sizeof(u32);
*width = (pbuffer[0]);
*width <<= 4;
*width |= ((pbuffer[1] >> 4) &0xf);
*height = (pbuffer[1] & 0xf);
*height <<= 8;
*height |= pbuffer[2];
aspect_code = (pbuffer[3] >> 4) & 0xf;
if (aspect_ratio != NULL) {
u32 par = 0;
switch (aspect_code) {
default:
*aspect_ratio = 0;
break;
case 2:
par = 4;
par<<=16;
par |= 3;
break;
case 3:
par = 16;
par<<=16;
par |= 9;
break;
case 4:
par = 2;
par<<=16;
par |= 21;
break;
}
*aspect_ratio = par;
}
framerate_code = pbuffer[3] & 0xf;
*frame_rate = mpeg12_frame_rate_table[framerate_code];
bitrate_int = (pbuffer[4] << 10) |
(pbuffer[5] << 2) |
((pbuffer[6] >> 6) & 0x3);
*bitrate = bitrate_int;
*bitrate *= 400.0;
ix += sizeof(u32) + 7;
pbuffer += 7;
found = 0;
} else if (found == 0) {
if (scode == MPEG12_EXT_START_CODE) {
pbuffer += sizeof(u32);
ix += sizeof(u32);
switch ((pbuffer[0] >> 4) & 0xf) {
case SEQ_ID:
*have_mpeg2 = 1;
*height = ((pbuffer[1] & 0x1) << 13) |
((pbuffer[2] & 0x80) << 5) |
(*height & 0x0fff);
*width = (((pbuffer[2] >> 5) & 0x3) << 12) | (*width & 0x0fff);
bitrate_ext = (pbuffer[2] & 0x1f) << 7;
bitrate_ext |= (pbuffer[3] >> 1) & 0x7f;
bitrate_int |= (bitrate_ext << 18);
*bitrate = bitrate_int;
*bitrate *= 400.0;
break;
default:
break;
}
pbuffer++;
ix++;
} else if (scode == MPEG12_PICTURE_START_CODE) {
return found;
}
}
}
return found;
}","int MPEG12_ParseSeqHdr(unsigned char *VAR_0, u32 VAR_1, s32 *VAR_2, u32 *VAR_3, u32 *VAR_4,
Double *VAR_5, Double *VAR_6, u32 *VAR_7)
{
u32 VAR_8;
u32 VAR_9;
u32 VAR_10;
u32 VAR_11;
u32 VAR_12, VAR_13;
s32 VAR_14 = -1;
*VAR_2 = 0;
VAR_1 -= 6;
VAR_10 = 0;
for (VAR_13 = 0; VAR_13 < VAR_1; VAR_13++, VAR_0++) {
VAR_12 = ((u32)VAR_0[0] << 24) | (VAR_0[1] << 16) | (VAR_0[2] << 8) |
VAR_0[3];
if (VAR_12 == VAR_15) {
VAR_0 += sizeof(u32);
*VAR_4 = (VAR_0[0]);
*VAR_4 <<= 4;
*VAR_4 |= ((VAR_0[1] >> 4) &0xf);
*VAR_3 = (VAR_0[1] & 0xf);
*VAR_3 <<= 8;
*VAR_3 |= VAR_0[2];
VAR_8 = (VAR_0[3] >> 4) & 0xf;
if (VAR_7 != NULL) {
u32 VAR_16 = 0;
switch (VAR_8) {
default:
*VAR_7 = 0;
break;
case 2:
VAR_16 = 4;
VAR_16<<=16;
VAR_16 |= 3;
break;
case 3:
VAR_16 = 16;
VAR_16<<=16;
VAR_16 |= 9;
break;
case 4:
VAR_16 = 2;
VAR_16<<=16;
VAR_16 |= 21;
break;
}
*VAR_7 = VAR_16;
}
VAR_9 = VAR_0[3] & 0xf;
*VAR_5 = VAR_17[VAR_9];
VAR_10 = (VAR_0[4] << 10) |
(VAR_0[5] << 2) |
((VAR_0[6] >> 6) & 0x3);
*VAR_6 = VAR_10;
*VAR_6 *= 400.0;
VAR_13 += sizeof(u32) + 7;
VAR_0 += 7;
VAR_14 = 0;
} else if (VAR_14 == 0) {
if (VAR_12 == VAR_18) {
VAR_0 += sizeof(u32);
VAR_13 += sizeof(u32);
switch ((VAR_0[0] >> 4) & 0xf) {
case VAR_19:
*VAR_2 = 1;
*VAR_3 = ((VAR_0[1] & 0x1) << 13) |
((VAR_0[2] & 0x80) << 5) |
(*VAR_3 & 0x0fff);
*VAR_4 = (((VAR_0[2] >> 5) & 0x3) << 12) | (*VAR_4 & 0x0fff);
VAR_11 = (VAR_0[2] & 0x1f) << 7;
VAR_11 |= (VAR_0[3] >> 1) & 0x7f;
VAR_10 |= (VAR_11 << 18);
*VAR_6 = VAR_10;
*VAR_6 *= 400.0;
break;
default:
break;
}
VAR_0++;
VAR_13++;
} else if (VAR_12 == VAR_20) {
return VAR_14;
}
}
}
return VAR_14;
}",gpac/3ec93d73d048ed7b46fe6e9f307cc7a0cc13db63/mpeg2_ps.c/vul/before/0.json,"int MPEG12_ParseSeqHdr(unsigned char *pbuffer, u32 buflen, s32 *have_mpeg2, u32 *height, u32 *width,
                       Double *frame_rate, Double *bitrate, u32 *aspect_ratio)
{
	u32 aspect_code;
	u32 framerate_code;
	u32 bitrate_int;
	u32 bitrate_ext;
	u32 scode, ix;
	s32 found = -1;
	*have_mpeg2 = 0;
	if (buflen<6) return found;

	buflen -= 6;
	bitrate_int = 0;
	for (ix = 0; ix < buflen; ix++, pbuffer++) {
		scode = ((u32)pbuffer[0] << 24) | (pbuffer[1] << 16) | (pbuffer[2] << 8) |
		        pbuffer[3];

		if (scode == MPEG12_SEQUENCE_START_CODE) {
			pbuffer += sizeof(u32);
			*width = (pbuffer[0]);
			*width <<= 4;
			*width |= ((pbuffer[1] >> 4) &0xf);
			*height = (pbuffer[1] & 0xf);
			*height <<= 8;
			*height |= pbuffer[2];
			aspect_code = (pbuffer[3] >> 4) & 0xf;
			if (aspect_ratio != NULL) {
				u32 par = 0;
				switch (aspect_code) {
				default:
					*aspect_ratio = 0;
					break;
				case 2:
					par = 4;
					par<<=16;
					par |= 3;
					break;
				case 3:
					par = 16;
					par<<=16;
					par |= 9;
					break;
				case 4:
					par = 2;
					par<<=16;
					par |= 21;
					break;
				}
				*aspect_ratio = par;
			}


			framerate_code = pbuffer[3] & 0xf;
			*frame_rate = mpeg12_frame_rate_table[framerate_code];
			// 18 bits
			bitrate_int = (pbuffer[4] << 10) |
			              (pbuffer[5] << 2) |
			              ((pbuffer[6] >> 6) & 0x3);
			*bitrate = bitrate_int;
			*bitrate *= 400.0;
			ix += sizeof(u32) + 7;
			pbuffer += 7;
			found = 0;
		} else if (found == 0) {
			if (scode == MPEG12_EXT_START_CODE) {
				pbuffer += sizeof(u32);
				ix += sizeof(u32);
				switch ((pbuffer[0] >> 4) & 0xf) {
				case SEQ_ID:
					*have_mpeg2 = 1;
					*height = ((pbuffer[1] & 0x1) << 13) |
					          ((pbuffer[2] & 0x80) << 5) |
					          (*height & 0x0fff);
					*width = (((pbuffer[2] >> 5) & 0x3) << 12) | (*width & 0x0fff);
					bitrate_ext = (pbuffer[2] & 0x1f) << 7;
					bitrate_ext |= (pbuffer[3] >> 1) & 0x7f;
					bitrate_int |= (bitrate_ext << 18);
					*bitrate = bitrate_int;
					*bitrate *= 400.0;
					break;
				default:
					break;
				}
				pbuffer++;
				ix++;
			} else if (scode == MPEG12_PICTURE_START_CODE) {
				return found;
			}
		}
	}
	return found;
}","int MPEG12_ParseSeqHdr(unsigned char *VAR_0, u32 VAR_1, s32 *VAR_2, u32 *VAR_3, u32 *VAR_4,
                       Double *VAR_5, Double *VAR_6, u32 *VAR_7)
{
	u32 VAR_8;
	u32 VAR_9;
	u32 VAR_10;
	u32 VAR_11;
	u32 VAR_12, VAR_13;
	s32 VAR_14 = -1;
	*VAR_2 = 0;
	if (VAR_1<6) return VAR_14;

	VAR_1 -= 6;
	VAR_10 = 0;
	for (VAR_13 = 0; VAR_13 < VAR_1; VAR_13++, VAR_0++) {
		VAR_12 = ((u32)VAR_0[0] << 24) | (VAR_0[1] << 16) | (VAR_0[2] << 8) |
		        VAR_0[3];

		if (VAR_12 == VAR_15) {
			VAR_0 += sizeof(u32);
			*VAR_4 = (VAR_0[0]);
			*VAR_4 <<= 4;
			*VAR_4 |= ((VAR_0[1] >> 4) &0xf);
			*VAR_3 = (VAR_0[1] & 0xf);
			*VAR_3 <<= 8;
			*VAR_3 |= VAR_0[2];
			VAR_8 = (VAR_0[3] >> 4) & 0xf;
			if (VAR_7 != NULL) {
				u32 VAR_16 = 0;
				switch (VAR_8) {
				default:
					*VAR_7 = 0;
					break;
				case 2:
					VAR_16 = 4;
					VAR_16<<=16;
					VAR_16 |= 3;
					break;
				case 3:
					VAR_16 = 16;
					VAR_16<<=16;
					VAR_16 |= 9;
					break;
				case 4:
					VAR_16 = 2;
					VAR_16<<=16;
					VAR_16 |= 21;
					break;
				}
				*VAR_7 = VAR_16;
			}


			VAR_9 = VAR_0[3] & 0xf;
			*VAR_5 = VAR_17[VAR_9];
			/* COMMENT_0 */
			VAR_10 = (VAR_0[4] << 10) |
			              (VAR_0[5] << 2) |
			              ((VAR_0[6] >> 6) & 0x3);
			*VAR_6 = VAR_10;
			*VAR_6 *= 400.0;
			VAR_13 += sizeof(u32) + 7;
			VAR_0 += 7;
			VAR_14 = 0;
		} else if (VAR_14 == 0) {
			if (VAR_12 == VAR_18) {
				VAR_0 += sizeof(u32);
				VAR_13 += sizeof(u32);
				switch ((VAR_0[0] >> 4) & 0xf) {
				case VAR_19:
					*VAR_2 = 1;
					*VAR_3 = ((VAR_0[1] & 0x1) << 13) |
					          ((VAR_0[2] & 0x80) << 5) |
					          (*VAR_3 & 0x0fff);
					*VAR_4 = (((VAR_0[2] >> 5) & 0x3) << 12) | (*VAR_4 & 0x0fff);
					VAR_11 = (VAR_0[2] & 0x1f) << 7;
					VAR_11 |= (VAR_0[3] >> 1) & 0x7f;
					VAR_10 |= (VAR_11 << 18);
					*VAR_6 = VAR_10;
					*VAR_6 *= 400.0;
					break;
				default:
					break;
				}
				VAR_0++;
				VAR_13++;
			} else if (VAR_12 == VAR_20) {
				return VAR_14;
			}
		}
	}
	return VAR_14;
}",gpac/3ec93d73d048ed7b46fe6e9f307cc7a0cc13db63/mpeg2_ps.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,6 +8,8 @@
 	u32 scode, ix;
 	s32 found = -1;
 	*have_mpeg2 = 0;
+	if (buflen<6) return found;
+
 	buflen -= 6;
 	bitrate_int = 0;
 	for (ix = 0; ix < buflen; ix++, pbuffer++) {","{'deleted_lines': [], 'added_lines': ['\tif (buflen<6) return found;', '']}",True,Out-of-bounds Read in GitHub repository gpac/gpac prior to 2.3-DEV.,5.5,MEDIUM,1,test,2023-09-01T10:04:54Z,4
CVE-2023-4756,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,gpac,Fixed #2584,6914d016e2b540bac2c471c4aea156ddef8e8e01,https://github.com/gpac/gpac/commit/6914d016e2b540bac2c471c4aea156ddef8e8e01,src/scene_manager/loader_bt.c,gf_bt_check_line,"void gf_bt_check_line(GF_BTParser *parser)
{
while (1) {
switch (parser->line_buffer[parser->line_pos]) {
case ' ':
case '\t':
case '\n':
case '\r':
parser->line_pos++;
continue;
default:
break;
}
break;
}
if (parser->line_buffer[parser->line_pos]=='#') {
parser->line_size = parser->line_pos;
}
else if ((parser->line_buffer[parser->line_pos]=='/') && (parser->line_buffer[parser->line_pos+1]=='/') ) parser->line_size = parser->line_pos;
if (parser->line_size == parser->line_pos) {
if (!parser->gz_in) {
parser->done = 1;
return;
}
next_line:
parser->line_start_pos = (s32) gf_gztell(parser->gz_in);
parser->line_buffer[0] = 0;
if (parser->unicode_type) {
u8 c1, c2;
unsigned short wchar;
unsigned short l[BT_LINE_SIZE];
unsigned short *dst = l;
Bool is_ret = 0;
u32 last_space_pos, last_space_pos_stream;
u32 go = BT_LINE_SIZE - 1;
last_space_pos = last_space_pos_stream = 0;
while (go && !gf_gzeof(parser->gz_in) ) {
c1 = gf_gzgetc(parser->gz_in);
c2 = gf_gzgetc(parser->gz_in);
if (parser->unicode_type==2) {
if (c2) {
wchar = c2;
wchar <<=8;
wchar |= c1;
}
else wchar = c1;
} else {
wchar = c1;
if (c2) {
wchar <<= 8;
wchar |= c2;
}
}
*dst = wchar;
if (wchar=='\r') is_ret = 1;
else if (wchar=='\n') {
dst++;
break;
}
else if (is_ret) {
u32 fpos = (u32) gf_gztell(parser->gz_in);
gf_gzseek(parser->gz_in, fpos-2, SEEK_SET);
break;
}
if (wchar==' ') {
last_space_pos = (u32) (dst - l);
}
dst++;
go--;
}
*dst = 0;
if (!go) {
u32 rew_pos = (u32)  (gf_gztell(parser->gz_in) - 2*(dst - &l[last_space_pos]) );
gf_gzseek(parser->gz_in, rew_pos, SEEK_SET);
l[last_space_pos+1] = 0;
}
if (l[0]==0xFFFF) {
parser->done = 1;
return;
}
dst = l;
gf_utf8_wcstombs(parser->line_buffer, BT_LINE_SIZE, (const unsigned short **) &dst);
if (!strlen(parser->line_buffer) && gf_gzeof(parser->gz_in)) {
parser->done = 1;
return;
}
} else {
if ((gf_gzgets(parser->gz_in, parser->line_buffer, BT_LINE_SIZE) == NULL)
|| (!strlen(parser->line_buffer) && gf_gzeof(parser->gz_in))) {
parser->done = 1;
return;
}
if (1 + strlen(parser->line_buffer) == BT_LINE_SIZE) {
u32 rew, pos, go;
rew = 0;
go = 1;
while (go) {
switch (parser->line_buffer[strlen(parser->line_buffer)-1]) {
case ' ':
case ',':
case '[':
case ']':
go = 0;
break;
default:
parser->line_buffer[strlen(parser->line_buffer)-1] = 0;
rew++;
break;
}
}
pos = (u32) gf_gztell(parser->gz_in);
gf_gzseek(parser->gz_in, pos-rew, SEEK_SET);
}
}
while (1) {
char c;
u32 len = (u32) strlen(parser->line_buffer);
if (!len) break;
c = parser->line_buffer[len-1];
if (!strchr(""\n\r\t"", c)) break;
parser->line_buffer[len-1] = 0;
}
parser->line_size = (u32) strlen(parser->line_buffer);
parser->line_pos = 0;
parser->line++;
{
u32 pos = (u32) gf_gztell(parser->gz_in);
if (pos>=parser->file_pos) {
parser->file_pos = pos;
if (parser->line>1) gf_set_progress(""BT Parsing"", pos, parser->file_size);
}
}
while ((parser->line_buffer[parser->line_pos]==' ') || (parser->line_buffer[parser->line_pos]=='\t'))
parser->line_pos++;
if ( (parser->line_buffer[parser->line_pos]=='#')
|| ( (parser->line_buffer[parser->line_pos]=='/') && (parser->line_buffer[parser->line_pos+1]=='/')) ) {
if (parser->line==1) {
if (strstr(parser->line_buffer, ""VRML"")) {
if (strstr(parser->line_buffer, ""VRML V2.0"")) parser->is_wrl = 1;
else if (strstr(parser->line_buffer, ""VRML2.0"")) parser->is_wrl = 1;
else {
gf_bt_report(parser, GF_NOT_SUPPORTED, ""%s: VRML Version Not Supported"", parser->line_buffer);
return;
}
}
else if (strstr(parser->line_buffer, ""X3D"")) {
if (strstr(parser->line_buffer, ""X3D V3.0"")) parser->is_wrl = 2;
else {
gf_bt_report(parser, GF_NOT_SUPPORTED, ""%s: X3D Version Not Supported"", parser->line_buffer);
return;
}
}
}
if (!strnicmp(parser->line_buffer+parser->line_pos, ""#define "", 8) && !parser->block_comment) {
char *buf, *sep;
parser->line_pos+=8;
buf = parser->line_buffer+parser->line_pos;
sep = strchr(buf, ' ');
if (sep && (sep[1]!='\n') ) {
BTDefSymbol *def;
GF_SAFEALLOC(def, BTDefSymbol);
if (!def) {
GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (""Fail to allocate DEF node\n""));
return;
}
sep[0] = 0;
def->name = gf_strdup(buf);
sep[0] = ' ';
buf = sep+1;
while (strchr("" \t"", buf[0])) buf++;
def->value = gf_strdup(buf);
gf_list_add(parser->def_symbols, def);
}
}
else if (!strnicmp(parser->line_buffer+parser->line_pos, ""#if "", 4)) {
u32 len = 0;
parser->line_pos+=4;
while (1) {
if (parser->line_pos+(s32)len==parser->line_size) break;
if (strchr("" \n\t"", parser->line_buffer[parser->line_pos+len]))
break;
len++;
}
if (len) {
if (len==1) {
if (!strnicmp(parser->line_buffer+parser->line_pos, ""0"", 1)) {
parser->block_comment++;
}
} else {
u32 i, count;
char *keyWord = NULL;
count = gf_list_count(parser->def_symbols);
for (i=0; i<count; i++) {
BTDefSymbol *def = (BTDefSymbol *)gf_list_get(parser->def_symbols, i);
if (!strnicmp(parser->line_buffer+parser->line_pos, def->name, len)) {
keyWord = def->value;
break;
}
}
if (keyWord && !strcmp(keyWord, ""0"")) {
parser->block_comment++;
}
}
}
}
else if (!strnicmp(parser->line_buffer+parser->line_pos, ""#endif"", 6)) {
if (parser->block_comment) parser->block_comment--;
}
else if (!strnicmp(parser->line_buffer+parser->line_pos, ""#else"", 5)) {
if (parser->block_comment)
parser->block_comment--;
else
parser->block_comment++;
}
else if (!strnicmp(parser->line_buffer+parser->line_pos, ""#size"", 5)) {
char *buf;
parser->line_pos+=6;
buf = parser->line_buffer+parser->line_pos;
while (strchr("" \t"", buf[0]))
buf++;
sscanf(buf, ""%dx%d"", &parser->def_w, &parser->def_h);
}
goto next_line;
}
if (parser->block_comment)
goto next_line;
if (parser->line_pos < parser->line_size) {
u32 i, count;
count = gf_list_count(parser->def_symbols);
while (1) {
Bool found = 0;
for (i=0; i<count; i++) {
u32 symb_len, val_len, copy_len;
BTDefSymbol *def = (BTDefSymbol *)gf_list_get(parser->def_symbols, i);
char *start = strstr(parser->line_buffer, def->name);
if (!start) continue;
symb_len = (u32) strlen(def->name);
if (!strchr("" \n\r\t,[]{}\'\"""", start[symb_len])) continue;
val_len = (u32) strlen(def->value);
copy_len = (u32) strlen(start + symb_len) + 1;
memmove(start + val_len, start + symb_len, sizeof(char)*copy_len);
memcpy(start, def->value, sizeof(char)*val_len);
parser->line_size = (u32) strlen(parser->line_buffer);
found = 1;
}
if (!found) break;
}
}
}
if (!parser->line_size) {
if (!gf_gzeof(parser->gz_in)) gf_bt_check_line(parser);
else parser->done = 1;
}
else if (!parser->done && (parser->line_size == parser->line_pos)) gf_bt_check_line(parser);
}","void gf_bt_check_line(GF_BTParser *VAR_0)
{
while (1) {
switch (VAR_0->line_buffer[VAR_0->line_pos]) {
case ' ':
case '\t':
case '\n':
case '\r':
VAR_0->line_pos++;
continue;
default:
break;
}
break;
}
if (VAR_0->line_buffer[VAR_0->line_pos]=='#') {
VAR_0->line_size = VAR_0->line_pos;
}
else if ((VAR_0->line_buffer[VAR_0->line_pos]=='/') && (VAR_0->line_buffer[VAR_0->line_pos+1]=='/') ) VAR_0->line_size = VAR_0->line_pos;
if (VAR_0->line_size == VAR_0->line_pos) {
if (!VAR_0->gz_in) {
VAR_0->done = 1;
return;
}
next_line:
VAR_0->line_start_pos = (s32) gf_gztell(VAR_0->gz_in);
VAR_0->line_buffer[0] = 0;
if (VAR_0->unicode_type) {
u8 VAR_1, VAR_2;
unsigned short VAR_3;
unsigned short VAR_4[VAR_5];
unsigned short *VAR_6 = VAR_4;
Bool VAR_7 = 0;
u32 VAR_8, VAR_9;
u32 VAR_10 = VAR_5 - 1;
VAR_8 = VAR_9 = 0;
while (VAR_10 && !gf_gzeof(VAR_0->gz_in) ) {
VAR_1 = gf_gzgetc(VAR_0->gz_in);
VAR_2 = gf_gzgetc(VAR_0->gz_in);
if (VAR_0->unicode_type==2) {
if (VAR_2) {
VAR_3 = VAR_2;
VAR_3 <<=8;
VAR_3 |= VAR_1;
}
else VAR_3 = VAR_1;
} else {
VAR_3 = VAR_1;
if (VAR_2) {
VAR_3 <<= 8;
VAR_3 |= VAR_2;
}
}
*VAR_6 = VAR_3;
if (VAR_3=='\r') VAR_7 = 1;
else if (VAR_3=='\n') {
VAR_6++;
break;
}
else if (VAR_7) {
u32 VAR_11 = (u32) gf_gztell(VAR_0->gz_in);
gf_gzseek(VAR_0->gz_in, VAR_11-2, VAR_12);
break;
}
if (VAR_3==' ') {
VAR_8 = (u32) (VAR_6 - VAR_4);
}
VAR_6++;
VAR_10--;
}
*VAR_6 = 0;
if (!VAR_10) {
u32 VAR_13 = (u32)  (gf_gztell(VAR_0->gz_in) - 2*(VAR_6 - &VAR_4[VAR_8]) );
gf_gzseek(VAR_0->gz_in, VAR_13, VAR_12);
VAR_4[VAR_8+1] = 0;
}
if (VAR_4[0]==0xFFFF) {
VAR_0->done = 1;
return;
}
VAR_6 = VAR_4;
gf_utf8_wcstombs(VAR_0->line_buffer, VAR_5, (const unsigned short **) &VAR_6);
if (!strlen(VAR_0->line_buffer) && gf_gzeof(VAR_0->gz_in)) {
VAR_0->done = 1;
return;
}
} else {
if ((gf_gzgets(VAR_0->gz_in, VAR_0->line_buffer, VAR_5) == NULL)
|| (!strlen(VAR_0->line_buffer) && gf_gzeof(VAR_0->gz_in))) {
VAR_0->done = 1;
return;
}
if (1 + strlen(VAR_0->line_buffer) == VAR_5) {
u32 VAR_14, VAR_15, VAR_10;
VAR_14 = 0;
VAR_10 = 1;
while (VAR_10) {
switch (VAR_0->line_buffer[strlen(VAR_0->line_buffer)-1]) {
case ' ':
case ',':
case '[':
case ']':
VAR_10 = 0;
break;
default:
VAR_0->line_buffer[strlen(VAR_0->line_buffer)-1] = 0;
VAR_14++;
break;
}
}
VAR_15 = (u32) gf_gztell(VAR_0->gz_in);
gf_gzseek(VAR_0->gz_in, VAR_15-VAR_14, VAR_12);
}
}
while (1) {
char VAR_16;
u32 VAR_17 = (u32) strlen(VAR_0->line_buffer);
if (!VAR_17) break;
VAR_16 = VAR_0->line_buffer[VAR_17-1];
if (!strchr(""\n\r\t"", VAR_16)) break;
VAR_0->line_buffer[VAR_17-1] = 0;
}
VAR_0->line_size = (u32) strlen(VAR_0->line_buffer);
VAR_0->line_pos = 0;
VAR_0->line++;
{
u32 VAR_15 = (u32) gf_gztell(VAR_0->gz_in);
if (VAR_15>=VAR_0->file_pos) {
VAR_0->file_pos = VAR_15;
if (VAR_0->line>1) gf_set_progress(""BT Parsing"", VAR_15, VAR_0->file_size);
}
}
while ((VAR_0->line_buffer[VAR_0->line_pos]==' ') || (VAR_0->line_buffer[VAR_0->line_pos]=='\t'))
VAR_0->line_pos++;
if ( (VAR_0->line_buffer[VAR_0->line_pos]=='#')
|| ( (VAR_0->line_buffer[VAR_0->line_pos]=='/') && (VAR_0->line_buffer[VAR_0->line_pos+1]=='/')) ) {
if (VAR_0->line==1) {
if (strstr(VAR_0->line_buffer, ""VRML"")) {
if (strstr(VAR_0->line_buffer, ""VRML V2.0"")) VAR_0->is_wrl = 1;
else if (strstr(VAR_0->line_buffer, ""VRML2.0"")) VAR_0->is_wrl = 1;
else {
gf_bt_report(VAR_0, VAR_18, ""%s: VRML Version Not Supported"", VAR_0->line_buffer);
return;
}
}
else if (strstr(VAR_0->line_buffer, ""X3D"")) {
if (strstr(VAR_0->line_buffer, ""X3D V3.0"")) VAR_0->is_wrl = 2;
else {
gf_bt_report(VAR_0, VAR_18, ""%s: X3D Version Not Supported"", VAR_0->line_buffer);
return;
}
}
}
if (!strnicmp(VAR_0->line_buffer+VAR_0->line_pos, ""#define "", 8) && !VAR_0->block_comment) {
char *VAR_19, *VAR_20;
VAR_0->line_pos+=8;
VAR_19 = VAR_0->line_buffer+VAR_0->line_pos;
VAR_20 = strchr(VAR_19, ' ');
if (VAR_20 && (VAR_20[1]!='\n') ) {
BTDefSymbol *VAR_21;
GF_SAFEALLOC(VAR_21, BTDefSymbol);
if (!VAR_21) {
GF_LOG(VAR_22, VAR_23, (""Fail to allocate DEF node\n""));
return;
}
VAR_20[0] = 0;
VAR_21->name = gf_strdup(VAR_19);
VAR_20[0] = ' ';
VAR_19 = VAR_20+1;
while (strchr("" \t"", VAR_19[0])) VAR_19++;
VAR_21->value = gf_strdup(VAR_19);
gf_list_add(VAR_0->def_symbols, VAR_21);
}
}
else if (!strnicmp(VAR_0->line_buffer+VAR_0->line_pos, ""#if "", 4)) {
u32 VAR_17 = 0;
VAR_0->line_pos+=4;
while (1) {
if (VAR_0->line_pos+(s32)VAR_17==VAR_0->line_size) break;
if (strchr("" \n\t"", VAR_0->line_buffer[VAR_0->line_pos+VAR_17]))
break;
VAR_17++;
}
if (VAR_17) {
if (VAR_17==1) {
if (!strnicmp(VAR_0->line_buffer+VAR_0->line_pos, ""0"", 1)) {
VAR_0->block_comment++;
}
} else {
u32 VAR_24, VAR_25;
char *VAR_26 = NULL;
VAR_25 = gf_list_count(VAR_0->def_symbols);
for (VAR_24=0; VAR_24<VAR_25; VAR_24++) {
BTDefSymbol *VAR_21 = (BTDefSymbol *)gf_list_get(VAR_0->def_symbols, VAR_24);
if (!strnicmp(VAR_0->line_buffer+VAR_0->line_pos, VAR_21->name, VAR_17)) {
VAR_26 = VAR_21->value;
break;
}
}
if (VAR_26 && !strcmp(VAR_26, ""0"")) {
VAR_0->block_comment++;
}
}
}
}
else if (!strnicmp(VAR_0->line_buffer+VAR_0->line_pos, ""#endif"", 6)) {
if (VAR_0->block_comment) VAR_0->block_comment--;
}
else if (!strnicmp(VAR_0->line_buffer+VAR_0->line_pos, ""#else"", 5)) {
if (VAR_0->block_comment)
VAR_0->block_comment--;
else
VAR_0->block_comment++;
}
else if (!strnicmp(VAR_0->line_buffer+VAR_0->line_pos, ""#size"", 5)) {
char *VAR_19;
VAR_0->line_pos+=6;
VAR_19 = VAR_0->line_buffer+VAR_0->line_pos;
while (strchr("" \t"", VAR_19[0]))
VAR_19++;
sscanf(VAR_19, ""%dx%d"", &VAR_0->def_w, &VAR_0->def_h);
}
goto next_line;
}
if (VAR_0->block_comment)
goto next_line;
if (VAR_0->line_pos < VAR_0->line_size) {
u32 VAR_24, VAR_25;
VAR_25 = gf_list_count(VAR_0->def_symbols);
while (1) {
Bool VAR_27 = 0;
for (VAR_24=0; VAR_24<VAR_25; VAR_24++) {
u32 VAR_28, VAR_29, VAR_30;
BTDefSymbol *VAR_21 = (BTDefSymbol *)gf_list_get(VAR_0->def_symbols, VAR_24);
char *VAR_31 = strstr(VAR_0->line_buffer, VAR_21->name);
if (!VAR_31) continue;
VAR_28 = (u32) strlen(VAR_21->name);
if (!strchr("" \n\r\t,[]{}\'\"""", VAR_31[VAR_28])) continue;
VAR_29 = (u32) strlen(VAR_21->value);
VAR_30 = (u32) strlen(VAR_31 + VAR_28) + 1;
memmove(VAR_31 + VAR_29, VAR_31 + VAR_28, sizeof(char)*VAR_30);
memcpy(VAR_31, VAR_21->value, sizeof(char)*VAR_29);
VAR_0->line_size = (u32) strlen(VAR_0->line_buffer);
VAR_27 = 1;
}
if (!VAR_27) break;
}
}
}
if (!VAR_0->line_size) {
if (!gf_gzeof(VAR_0->gz_in)) gf_bt_check_line(VAR_0);
else VAR_0->done = 1;
}
else if (!VAR_0->done && (VAR_0->line_size == VAR_0->line_pos)) gf_bt_check_line(VAR_0);
}",gpac/6914d016e2b540bac2c471c4aea156ddef8e8e01/loader_bt.c/vul/before/0.json,"void gf_bt_check_line(GF_BTParser *parser)
{
reload_line:
	while (parser->line_pos < parser->line_size) {
		switch (parser->line_buffer[parser->line_pos]) {
		case ' ':
		case '\t':
		case '\n':
		case '\r':
			parser->line_pos++;
			continue;
		case '\0':
			parser->line_pos = parser->line_size;
		default:
			break;
		}
		break;
	}

	if (parser->line_pos < parser->line_size) {
		if (parser->line_buffer[parser->line_pos]=='#') {
			parser->line_size = parser->line_pos;
		}
		else if ((parser->line_buffer[parser->line_pos]=='/') && (parser->line_buffer[parser->line_pos+1]=='/') ) {
			parser->line_size = parser->line_pos;
		}
	}

	if (parser->line_size == parser->line_pos) {
		/*string based input - done*/
		if (!parser->gz_in) {
			parser->done = 1;
			return;
		}

next_line:
		parser->line_start_pos = (s32) gf_gztell(parser->gz_in);
		parser->line_buffer[0] = 0;
		if (parser->unicode_type) {
			u8 c1, c2;
			unsigned short wchar;
			unsigned short l[BT_LINE_SIZE];
			unsigned short *dst = l;
			Bool is_ret = 0;
			u32 last_space_pos, last_space_pos_stream;
			u32 go = BT_LINE_SIZE - 1;
			last_space_pos = last_space_pos_stream = 0;
			while (go && !gf_gzeof(parser->gz_in) ) {
				c1 = gf_gzgetc(parser->gz_in);
				c2 = gf_gzgetc(parser->gz_in);
				/*Little-endian order*/
				if (parser->unicode_type==2) {
					if (c2) {
						wchar = c2;
						wchar <<=8;
						wchar |= c1;
					}
					else wchar = c1;
				} else {
					wchar = c1;
					if (c2) {
						wchar <<= 8;
						wchar |= c2;
					}
				}
				*dst = wchar;
				if (wchar=='\r') is_ret = 1;
				else if (wchar=='\n') {
					dst++;
					break;
				}
				else if (is_ret) {
					u32 fpos = (u32) gf_gztell(parser->gz_in);
					gf_gzseek(parser->gz_in, fpos-2, SEEK_SET);
					break;
				}
				if (wchar==' ') {
					//last_space_pos_stream = (u32) gf_gztell(parser->gz_in);
					last_space_pos = (u32) (dst - l);
				}
				dst++;
				go--;

			}
			*dst = 0;
			/*long line, rewind stream to last space*/
			if (!go) {
				u32 rew_pos = (u32)  (gf_gztell(parser->gz_in) - 2*(dst - &l[last_space_pos]) );
				gf_gzseek(parser->gz_in, rew_pos, SEEK_SET);
				l[last_space_pos+1] = 0;
			}
			/*check eof*/
			if (l[0]==0xFFFF) {
				parser->done = 1;
				return;
			}
			/*convert to mbc string*/
			dst = l;
			gf_utf8_wcstombs(parser->line_buffer, BT_LINE_SIZE, (const unsigned short **) &dst);

			if (!strlen(parser->line_buffer) && gf_gzeof(parser->gz_in)) {
				parser->done = 1;
				return;
			}
		} else {
			if ((gf_gzgets(parser->gz_in, parser->line_buffer, BT_LINE_SIZE) == NULL)
			        || (!strlen(parser->line_buffer) && gf_gzeof(parser->gz_in))) {
				parser->done = 1;
				return;
			}
			/*watchout for long lines*/
			if (1 + strlen(parser->line_buffer) == BT_LINE_SIZE) {
				u32 rew, pos, go;
				rew = 0;
				go = 1;
				while (go) {
					switch (parser->line_buffer[strlen(parser->line_buffer)-1]) {
					case ' ':
					case ',':
					case '[':
					case ']':
						go = 0;
						break;
					default:
						parser->line_buffer[strlen(parser->line_buffer)-1] = 0;
						rew++;
						break;
					}
				}
				pos = (u32) gf_gztell(parser->gz_in);
				gf_gzseek(parser->gz_in, pos-rew, SEEK_SET);
			}
		}


		while (1) {
			char c;
			u32 len = (u32) strlen(parser->line_buffer);
			if (!len) break;
			c = parser->line_buffer[len-1];
			if (!strchr(""\n\r\t"", c)) break;
			parser->line_buffer[len-1] = 0;
		}


		parser->line_size = (u32) strlen(parser->line_buffer);
		parser->line_pos = 0;
		parser->line++;

		{
			u32 pos = (u32) gf_gztell(parser->gz_in);
			if (pos>=parser->file_pos) {
				parser->file_pos = pos;
				if (parser->line>1) gf_set_progress(""BT Parsing"", pos, parser->file_size);
			}
		}

		while ((parser->line_buffer[parser->line_pos]==' ') || (parser->line_buffer[parser->line_pos]=='\t'))
			parser->line_pos++;
		if ( (parser->line_buffer[parser->line_pos]=='#')
		        || ( (parser->line_buffer[parser->line_pos]=='/') && (parser->line_buffer[parser->line_pos+1]=='/')) ) {

			if (parser->line==1) {
				if (strstr(parser->line_buffer, ""VRML"")) {
					if (strstr(parser->line_buffer, ""VRML V2.0"")) parser->is_wrl = 1;
					/*although not std, many files use this*/
					else if (strstr(parser->line_buffer, ""VRML2.0"")) parser->is_wrl = 1;
					else {
						gf_bt_report(parser, GF_NOT_SUPPORTED, ""%s: VRML Version Not Supported"", parser->line_buffer);
						return;
					}
				}
				else if (strstr(parser->line_buffer, ""X3D"")) {
					if (strstr(parser->line_buffer, ""X3D V3.0"")) parser->is_wrl = 2;
					else {
						gf_bt_report(parser, GF_NOT_SUPPORTED, ""%s: X3D Version Not Supported"", parser->line_buffer);
						return;
					}
				}
			}
			if (!strnicmp(parser->line_buffer+parser->line_pos, ""#define "", 8) && !parser->block_comment) {
				char *buf, *sep;
				parser->line_pos+=8;
				buf = parser->line_buffer+parser->line_pos;
				sep = strchr(buf, ' ');
				if (sep && (sep[1]!='\n') ) {
					BTDefSymbol *def;
					GF_SAFEALLOC(def, BTDefSymbol);
					if (!def) {
						GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (""Fail to allocate DEF node\n""));
						return;
					}
					sep[0] = 0;
					def->name = gf_strdup(buf);
					sep[0] = ' ';
					buf = sep+1;
					while (strchr("" \t"", buf[0])) buf++;
					def->value = gf_strdup(buf);
					gf_list_add(parser->def_symbols, def);
				}
			}
			else if (!strnicmp(parser->line_buffer+parser->line_pos, ""#if "", 4)) {
				u32 len = 0;
				parser->line_pos+=4;
				while (1) {
					if (parser->line_pos+(s32)len==parser->line_size) break;
					if (strchr("" \n\t"", parser->line_buffer[parser->line_pos+len]))
						break;
					len++;
				}
				if (len) {
					if (len==1) {
						if (!strnicmp(parser->line_buffer+parser->line_pos, ""0"", 1)) {
							parser->block_comment++;
						}
					} else {
						u32 i, count;
						char *keyWord = NULL;
						count = gf_list_count(parser->def_symbols);
						for (i=0; i<count; i++) {
							BTDefSymbol *def = (BTDefSymbol *)gf_list_get(parser->def_symbols, i);
							if (!strnicmp(parser->line_buffer+parser->line_pos, def->name, len)) {
								keyWord = def->value;
								break;
							}
						}
						if (keyWord && !strcmp(keyWord, ""0"")) {
							parser->block_comment++;
						}
					}
				}
			}
			else if (!strnicmp(parser->line_buffer+parser->line_pos, ""#endif"", 6)) {
				if (parser->block_comment) parser->block_comment--;
			}
			else if (!strnicmp(parser->line_buffer+parser->line_pos, ""#else"", 5)) {
				if (parser->block_comment)
					parser->block_comment--;
				else
					parser->block_comment++;
			}
			else if (!strnicmp(parser->line_buffer+parser->line_pos, ""#size"", 5)) {
				char *buf;
				parser->line_pos+=6;
				buf = parser->line_buffer+parser->line_pos;
				while (strchr("" \t"", buf[0]))
					buf++;
				sscanf(buf, ""%dx%d"", &parser->def_w, &parser->def_h);
			}
			goto next_line;
		}

		if (parser->block_comment)
			goto next_line;

		/*brute-force replacement of defined symbols (!!FIXME - no mem checking done !!)*/
		if (parser->line_pos < parser->line_size) {
			u32 i, count;
			count = gf_list_count(parser->def_symbols);
			while (1) {
				Bool found = 0;
				for (i=0; i<count; i++) {
					u32 symb_len, val_len, copy_len;
					BTDefSymbol *def = (BTDefSymbol *)gf_list_get(parser->def_symbols, i);
					char *start = strstr(parser->line_buffer, def->name);
					if (!start) continue;
					symb_len = (u32) strlen(def->name);
					if (!strchr("" \n\r\t,[]{}\'\"""", start[symb_len])) continue;
					val_len = (u32) strlen(def->value);
					copy_len = (u32) strlen(start + symb_len) + 1;
					memmove(start + val_len, start + symb_len, sizeof(char)*copy_len);
					memcpy(start, def->value, sizeof(char)*val_len);
					parser->line_size = (u32) strlen(parser->line_buffer);
					found = 1;
				}
				if (!found) break;
			}
		}
	}
	if (!parser->line_size) {
		if (!gf_gzeof(parser->gz_in))
			//avoid recursion
			goto reload_line;
		else
			parser->done = 1;
	}
	else if (!parser->done && (parser->line_size == parser->line_pos))
		//avoid recursion
		goto reload_line;
}","void gf_bt_check_line(GF_BTParser *VAR_0)
{
reload_line:
	while (VAR_0->line_pos < VAR_0->line_size) {
		switch (VAR_0->line_buffer[VAR_0->line_pos]) {
		case ' ':
		case '\t':
		case '\n':
		case '\r':
			VAR_0->line_pos++;
			continue;
		case '\0':
			VAR_0->line_pos = VAR_0->line_size;
		default:
			break;
		}
		break;
	}

	if (VAR_0->line_pos < VAR_0->line_size) {
		if (VAR_0->line_buffer[VAR_0->line_pos]=='#') {
			VAR_0->line_size = VAR_0->line_pos;
		}
		else if ((VAR_0->line_buffer[VAR_0->line_pos]=='/') && (VAR_0->line_buffer[VAR_0->line_pos+1]=='/') ) {
			VAR_0->line_size = VAR_0->line_pos;
		}
	}

	if (VAR_0->line_size == VAR_0->line_pos) {
		/* COMMENT_0 */
		if (!VAR_0->gz_in) {
			VAR_0->done = 1;
			return;
		}

next_line:
		VAR_0->line_start_pos = (s32) gf_gztell(VAR_0->gz_in);
		VAR_0->line_buffer[0] = 0;
		if (VAR_0->unicode_type) {
			u8 VAR_1, VAR_2;
			unsigned short VAR_3;
			unsigned short VAR_4[VAR_5];
			unsigned short *VAR_6 = VAR_4;
			Bool VAR_7 = 0;
			u32 VAR_8, VAR_9;
			u32 VAR_10 = VAR_5 - 1;
			VAR_8 = VAR_9 = 0;
			while (VAR_10 && !gf_gzeof(VAR_0->gz_in) ) {
				VAR_1 = gf_gzgetc(VAR_0->gz_in);
				VAR_2 = gf_gzgetc(VAR_0->gz_in);
				/* COMMENT_1 */
				if (VAR_0->unicode_type==2) {
					if (VAR_2) {
						VAR_3 = VAR_2;
						VAR_3 <<=8;
						VAR_3 |= VAR_1;
					}
					else VAR_3 = VAR_1;
				} else {
					VAR_3 = VAR_1;
					if (VAR_2) {
						VAR_3 <<= 8;
						VAR_3 |= VAR_2;
					}
				}
				*VAR_6 = VAR_3;
				if (VAR_3=='\r') VAR_7 = 1;
				else if (VAR_3=='\n') {
					VAR_6++;
					break;
				}
				else if (VAR_7) {
					u32 VAR_11 = (u32) gf_gztell(VAR_0->gz_in);
					gf_gzseek(VAR_0->gz_in, VAR_11-2, VAR_12);
					break;
				}
				if (VAR_3==' ') {
					/* COMMENT_2 */
					VAR_8 = (u32) (VAR_6 - VAR_4);
				}
				VAR_6++;
				VAR_10--;

			}
			*VAR_6 = 0;
			/* COMMENT_3 */
			if (!VAR_10) {
				u32 VAR_13 = (u32)  (gf_gztell(VAR_0->gz_in) - 2*(VAR_6 - &VAR_4[VAR_8]) );
				gf_gzseek(VAR_0->gz_in, VAR_13, VAR_12);
				VAR_4[VAR_8+1] = 0;
			}
			/* COMMENT_4 */
			if (VAR_4[0]==0xFFFF) {
				VAR_0->done = 1;
				return;
			}
			/* COMMENT_5 */
			VAR_6 = VAR_4;
			gf_utf8_wcstombs(VAR_0->line_buffer, VAR_5, (const unsigned short **) &VAR_6);

			if (!strlen(VAR_0->line_buffer) && gf_gzeof(VAR_0->gz_in)) {
				VAR_0->done = 1;
				return;
			}
		} else {
			if ((gf_gzgets(VAR_0->gz_in, VAR_0->line_buffer, VAR_5) == NULL)
			        || (!strlen(VAR_0->line_buffer) && gf_gzeof(VAR_0->gz_in))) {
				VAR_0->done = 1;
				return;
			}
			/* COMMENT_6 */
			if (1 + strlen(VAR_0->line_buffer) == VAR_5) {
				u32 VAR_14, VAR_15, VAR_10;
				VAR_14 = 0;
				VAR_10 = 1;
				while (VAR_10) {
					switch (VAR_0->line_buffer[strlen(VAR_0->line_buffer)-1]) {
					case ' ':
					case ',':
					case '[':
					case ']':
						VAR_10 = 0;
						break;
					default:
						VAR_0->line_buffer[strlen(VAR_0->line_buffer)-1] = 0;
						VAR_14++;
						break;
					}
				}
				VAR_15 = (u32) gf_gztell(VAR_0->gz_in);
				gf_gzseek(VAR_0->gz_in, VAR_15-VAR_14, VAR_12);
			}
		}


		while (1) {
			char VAR_16;
			u32 VAR_17 = (u32) strlen(VAR_0->line_buffer);
			if (!VAR_17) break;
			VAR_16 = VAR_0->line_buffer[VAR_17-1];
			if (!strchr(""\n\r\t"", VAR_16)) break;
			VAR_0->line_buffer[VAR_17-1] = 0;
		}


		VAR_0->line_size = (u32) strlen(VAR_0->line_buffer);
		VAR_0->line_pos = 0;
		VAR_0->line++;

		{
			u32 VAR_15 = (u32) gf_gztell(VAR_0->gz_in);
			if (VAR_15>=VAR_0->file_pos) {
				VAR_0->file_pos = VAR_15;
				if (VAR_0->line>1) gf_set_progress(""BT Parsing"", VAR_15, VAR_0->file_size);
			}
		}

		while ((VAR_0->line_buffer[VAR_0->line_pos]==' ') || (VAR_0->line_buffer[VAR_0->line_pos]=='\t'))
			VAR_0->line_pos++;
		if ( (VAR_0->line_buffer[VAR_0->line_pos]=='#')
		        || ( (VAR_0->line_buffer[VAR_0->line_pos]=='/') && (VAR_0->line_buffer[VAR_0->line_pos+1]=='/')) ) {

			if (VAR_0->line==1) {
				if (strstr(VAR_0->line_buffer, ""VRML"")) {
					if (strstr(VAR_0->line_buffer, ""VRML V2.0"")) VAR_0->is_wrl = 1;
					/* COMMENT_7 */
					else if (strstr(VAR_0->line_buffer, ""VRML2.0"")) VAR_0->is_wrl = 1;
					else {
						gf_bt_report(VAR_0, VAR_18, ""%s: VRML Version Not Supported"", VAR_0->line_buffer);
						return;
					}
				}
				else if (strstr(VAR_0->line_buffer, ""X3D"")) {
					if (strstr(VAR_0->line_buffer, ""X3D V3.0"")) VAR_0->is_wrl = 2;
					else {
						gf_bt_report(VAR_0, VAR_18, ""%s: X3D Version Not Supported"", VAR_0->line_buffer);
						return;
					}
				}
			}
			if (!strnicmp(VAR_0->line_buffer+VAR_0->line_pos, ""#define "", 8) && !VAR_0->block_comment) {
				char *VAR_19, *VAR_20;
				VAR_0->line_pos+=8;
				VAR_19 = VAR_0->line_buffer+VAR_0->line_pos;
				VAR_20 = strchr(VAR_19, ' ');
				if (VAR_20 && (VAR_20[1]!='\n') ) {
					BTDefSymbol *VAR_21;
					GF_SAFEALLOC(VAR_21, BTDefSymbol);
					if (!VAR_21) {
						GF_LOG(VAR_22, VAR_23, (""Fail to allocate DEF node\n""));
						return;
					}
					VAR_20[0] = 0;
					VAR_21->name = gf_strdup(VAR_19);
					VAR_20[0] = ' ';
					VAR_19 = VAR_20+1;
					while (strchr("" \t"", VAR_19[0])) VAR_19++;
					VAR_21->value = gf_strdup(VAR_19);
					gf_list_add(VAR_0->def_symbols, VAR_21);
				}
			}
			else if (!strnicmp(VAR_0->line_buffer+VAR_0->line_pos, ""#if "", 4)) {
				u32 VAR_17 = 0;
				VAR_0->line_pos+=4;
				while (1) {
					if (VAR_0->line_pos+(s32)VAR_17==VAR_0->line_size) break;
					if (strchr("" \n\t"", VAR_0->line_buffer[VAR_0->line_pos+VAR_17]))
						break;
					VAR_17++;
				}
				if (VAR_17) {
					if (VAR_17==1) {
						if (!strnicmp(VAR_0->line_buffer+VAR_0->line_pos, ""0"", 1)) {
							VAR_0->block_comment++;
						}
					} else {
						u32 VAR_24, VAR_25;
						char *VAR_26 = NULL;
						VAR_25 = gf_list_count(VAR_0->def_symbols);
						for (VAR_24=0; VAR_24<VAR_25; VAR_24++) {
							BTDefSymbol *VAR_21 = (BTDefSymbol *)gf_list_get(VAR_0->def_symbols, VAR_24);
							if (!strnicmp(VAR_0->line_buffer+VAR_0->line_pos, VAR_21->name, VAR_17)) {
								VAR_26 = VAR_21->value;
								break;
							}
						}
						if (VAR_26 && !strcmp(VAR_26, ""0"")) {
							VAR_0->block_comment++;
						}
					}
				}
			}
			else if (!strnicmp(VAR_0->line_buffer+VAR_0->line_pos, ""#endif"", 6)) {
				if (VAR_0->block_comment) VAR_0->block_comment--;
			}
			else if (!strnicmp(VAR_0->line_buffer+VAR_0->line_pos, ""#else"", 5)) {
				if (VAR_0->block_comment)
					VAR_0->block_comment--;
				else
					VAR_0->block_comment++;
			}
			else if (!strnicmp(VAR_0->line_buffer+VAR_0->line_pos, ""#size"", 5)) {
				char *VAR_19;
				VAR_0->line_pos+=6;
				VAR_19 = VAR_0->line_buffer+VAR_0->line_pos;
				while (strchr("" \t"", VAR_19[0]))
					VAR_19++;
				sscanf(VAR_19, ""%dx%d"", &VAR_0->def_w, &VAR_0->def_h);
			}
			goto next_line;
		}

		if (VAR_0->block_comment)
			goto next_line;

		/* COMMENT_8 */
		if (VAR_0->line_pos < VAR_0->line_size) {
			u32 VAR_24, VAR_25;
			VAR_25 = gf_list_count(VAR_0->def_symbols);
			while (1) {
				Bool VAR_27 = 0;
				for (VAR_24=0; VAR_24<VAR_25; VAR_24++) {
					u32 VAR_28, VAR_29, VAR_30;
					BTDefSymbol *VAR_21 = (BTDefSymbol *)gf_list_get(VAR_0->def_symbols, VAR_24);
					char *VAR_31 = strstr(VAR_0->line_buffer, VAR_21->name);
					if (!VAR_31) continue;
					VAR_28 = (u32) strlen(VAR_21->name);
					if (!strchr("" \n\r\t,[]{}\'\"""", VAR_31[VAR_28])) continue;
					VAR_29 = (u32) strlen(VAR_21->value);
					VAR_30 = (u32) strlen(VAR_31 + VAR_28) + 1;
					memmove(VAR_31 + VAR_29, VAR_31 + VAR_28, sizeof(char)*VAR_30);
					memcpy(VAR_31, VAR_21->value, sizeof(char)*VAR_29);
					VAR_0->line_size = (u32) strlen(VAR_0->line_buffer);
					VAR_27 = 1;
				}
				if (!VAR_27) break;
			}
		}
	}
	if (!VAR_0->line_size) {
		if (!gf_gzeof(VAR_0->gz_in))
			/* COMMENT_9 */
			goto reload_line;
		else
			VAR_0->done = 1;
	}
	else if (!VAR_0->done && (VAR_0->line_size == VAR_0->line_pos))
		/* COMMENT_9 */
		goto reload_line;
}",gpac/6914d016e2b540bac2c471c4aea156ddef8e8e01/loader_bt.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,7 @@
 void gf_bt_check_line(GF_BTParser *parser)
 {
-	while (1) {
+reload_line:
+	while (parser->line_pos < parser->line_size) {
 		switch (parser->line_buffer[parser->line_pos]) {
 		case ' ':
 		case '\t':
@@ -8,16 +9,22 @@
 		case '\r':
 			parser->line_pos++;
 			continue;
+		case '\0':
+			parser->line_pos = parser->line_size;
 		default:
 			break;
 		}
 		break;
 	}
 
-	if (parser->line_buffer[parser->line_pos]=='#') {
-		parser->line_size = parser->line_pos;
-	}
-	else if ((parser->line_buffer[parser->line_pos]=='/') && (parser->line_buffer[parser->line_pos+1]=='/') ) parser->line_size = parser->line_pos;
+	if (parser->line_pos < parser->line_size) {
+		if (parser->line_buffer[parser->line_pos]=='#') {
+			parser->line_size = parser->line_pos;
+		}
+		else if ((parser->line_buffer[parser->line_pos]=='/') && (parser->line_buffer[parser->line_pos+1]=='/') ) {
+			parser->line_size = parser->line_pos;
+		}
+	}
 
 	if (parser->line_size == parser->line_pos) {
 		/*string based input - done*/
@@ -271,8 +278,13 @@
 		}
 	}
 	if (!parser->line_size) {
-		if (!gf_gzeof(parser->gz_in)) gf_bt_check_line(parser);
-		else parser->done = 1;
-	}
-	else if (!parser->done && (parser->line_size == parser->line_pos)) gf_bt_check_line(parser);
+		if (!gf_gzeof(parser->gz_in))
+			//avoid recursion
+			goto reload_line;
+		else
+			parser->done = 1;
+	}
+	else if (!parser->done && (parser->line_size == parser->line_pos))
+		//avoid recursion
+		goto reload_line;
 }","{'deleted_lines': ['\twhile (1) {', ""\tif (parser->line_buffer[parser->line_pos]=='#') {"", '\t\tparser->line_size = parser->line_pos;', '\t}', ""\telse if ((parser->line_buffer[parser->line_pos]=='/') && (parser->line_buffer[parser->line_pos+1]=='/') ) parser->line_size = parser->line_pos;"", '\t\tif (!gf_gzeof(parser->gz_in)) gf_bt_check_line(parser);', '\t\telse parser->done = 1;', '\t}', '\telse if (!parser->done && (parser->line_size == parser->line_pos)) gf_bt_check_line(parser);'], 'added_lines': ['reload_line:', '\twhile (parser->line_pos < parser->line_size) {', ""\t\tcase '\\0':"", '\t\t\tparser->line_pos = parser->line_size;', '\tif (parser->line_pos < parser->line_size) {', ""\t\tif (parser->line_buffer[parser->line_pos]=='#') {"", '\t\t\tparser->line_size = parser->line_pos;', '\t\t}', ""\t\telse if ((parser->line_buffer[parser->line_pos]=='/') && (parser->line_buffer[parser->line_pos+1]=='/') ) {"", '\t\t\tparser->line_size = parser->line_pos;', '\t\t}', '\t}', '\t\tif (!gf_gzeof(parser->gz_in))', '\t\t\t//avoid recursion', '\t\t\tgoto reload_line;', '\t\telse', '\t\t\tparser->done = 1;', '\t}', '\telse if (!parser->done && (parser->line_size == parser->line_pos))', '\t\t//avoid recursion', '\t\tgoto reload_line;']}",True,Stack-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.3-DEV.,5.5,MEDIUM,1,test,2023-09-04T07:35:27Z,4
CVE-2023-50428,['CWE-Other'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L,1,bitcoin,Apply -datacarriersize to all datacarrying,f2c0396cd434797c76eecc1180c5f4ba98aee246,https://github.com/bitcoin/bitcoin/commit/f2c0396cd434797c76eecc1180c5f4ba98aee246,src/validation.cpp,MemPoolAccept::PreChecks,"bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)
{
AssertLockHeld(cs_main);
AssertLockHeld(m_pool.cs);
const CTransactionRef& ptx = ws.m_ptx;
const CTransaction& tx = *ws.m_ptx;
const Txid& hash = ws.m_hash;
const int64_t nAcceptTime = args.m_accept_time;
const bool bypass_limits = args.m_bypass_limits;
std::vector<COutPoint>& coins_to_uncache = args.m_coins_to_uncache;
TxValidationState& state = ws.m_state;
std::unique_ptr<CTxMemPoolEntry>& entry = ws.m_entry;
if (!CheckTransaction(tx, state)) {
return false;     }
if (tx.IsCoinBase())
return state.Invalid(TxValidationResult::TX_CONSENSUS, ""coinbase"");
std::string reason;
if (m_pool.m_require_standard && !IsStandardTx(tx, m_pool.m_max_datacarrier_bytes, m_pool.m_permit_bare_multisig, m_pool.m_dust_relay_feerate, reason)) {
return state.Invalid(TxValidationResult::TX_NOT_STANDARD, reason);
}
if (::GetSerializeSize(TX_NO_WITNESS(tx)) < MIN_STANDARD_TX_NONWITNESS_SIZE)
return state.Invalid(TxValidationResult::TX_NOT_STANDARD, ""tx-size-small"");
if (!CheckFinalTxAtTip(*Assert(m_active_chainstate.m_chain.Tip()), tx)) {
return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, ""non-final"");
}
if (m_pool.exists(GenTxid::Wtxid(tx.GetWitnessHash()))) {
return state.Invalid(TxValidationResult::TX_CONFLICT, ""txn-already-in-mempool"");
} else if (m_pool.exists(GenTxid::Txid(tx.GetHash()))) {
return state.Invalid(TxValidationResult::TX_CONFLICT, ""txn-same-nonwitness-data-in-mempool"");
}
for (const CTxIn &txin : tx.vin)
{
const CTransaction* ptxConflicting = m_pool.GetConflictTx(txin.prevout);
if (ptxConflicting) {
if (!args.m_allow_replacement) {
return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, ""bip125-replacement-disallowed"");
}
if (!ws.m_conflicts.count(ptxConflicting->GetHash()))
{
if (!m_pool.m_full_rbf && !SignalsOptInRBF(*ptxConflicting)) {
return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, ""txn-mempool-conflict"");
}
ws.m_conflicts.insert(ptxConflicting->GetHash());
}
}
}
m_view.SetBackend(m_viewmempool);
const CCoinsViewCache& coins_cache = m_active_chainstate.CoinsTip();
for (const CTxIn& txin : tx.vin) {
if (!coins_cache.HaveCoinInCache(txin.prevout)) {
coins_to_uncache.push_back(txin.prevout);
}
if (!m_view.HaveCoin(txin.prevout)) {
for (size_t out = 0; out < tx.vout.size(); out++) {
if (coins_cache.HaveCoinInCache(COutPoint(hash, out))) {
return state.Invalid(TxValidationResult::TX_CONFLICT, ""txn-already-known"");
}
}
return state.Invalid(TxValidationResult::TX_MISSING_INPUTS, ""bad-txns-inputs-missingorspent"");
}
}
m_view.GetBestBlock();
m_view.SetBackend(m_dummy);
assert(m_active_chainstate.m_blockman.LookupBlockIndex(m_view.GetBestBlock()) == m_active_chainstate.m_chain.Tip());
const std::optional<LockPoints> lock_points{CalculateLockPointsAtTip(m_active_chainstate.m_chain.Tip(), m_view, tx)};
if (!lock_points.has_value() || !CheckSequenceLocksAtTip(m_active_chainstate.m_chain.Tip(), *lock_points)) {
return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, ""non-BIP68-final"");
}
if (!Consensus::CheckTxInputs(tx, state, m_view, m_active_chainstate.m_chain.Height() + 1, ws.m_base_fees)) {
return false;     }
if (m_pool.m_require_standard && !AreInputsStandard(tx, m_view)) {
return state.Invalid(TxValidationResult::TX_INPUTS_NOT_STANDARD, ""bad-txns-nonstandard-inputs"");
}
if (tx.HasWitness() && m_pool.m_require_standard && !IsWitnessStandard(tx, m_view)) {
return state.Invalid(TxValidationResult::TX_WITNESS_MUTATED, ""bad-witness-nonstandard"");
}
int64_t nSigOpsCost = GetTransactionSigOpCost(tx, m_view, STANDARD_SCRIPT_VERIFY_FLAGS);
ws.m_modified_fees = ws.m_base_fees;
m_pool.ApplyDelta(hash, ws.m_modified_fees);
bool fSpendsCoinbase = false;
for (const CTxIn &txin : tx.vin) {
const Coin &coin = m_view.AccessCoin(txin.prevout);
if (coin.IsCoinBase()) {
fSpendsCoinbase = true;
break;
}
}
const uint64_t entry_sequence = bypass_limits ? 0 : m_pool.GetSequence();
entry.reset(new CTxMemPoolEntry(ptx, ws.m_base_fees, nAcceptTime, m_active_chainstate.m_chain.Height(), entry_sequence,
fSpendsCoinbase, nSigOpsCost, lock_points.value()));
ws.m_vsize = entry->GetTxSize();
if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)
return state.Invalid(TxValidationResult::TX_NOT_STANDARD, ""bad-txns-too-many-sigops"",
strprintf(""%d"", nSigOpsCost));
if (!bypass_limits && ws.m_modified_fees < m_pool.m_min_relay_feerate.GetFee(ws.m_vsize)) {
return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, ""min relay fee not met"",
strprintf(""%d < %d"", ws.m_modified_fees, m_pool.m_min_relay_feerate.GetFee(ws.m_vsize)));
}
if (!bypass_limits && !args.m_package_feerates && !CheckFeeRate(ws.m_vsize, ws.m_modified_fees, state)) return false;
ws.m_iters_conflicting = m_pool.GetIterSet(ws.m_conflicts);
CTxMemPool::Limits maybe_rbf_limits = m_pool.m_limits;
if (ws.m_conflicts.size() == 1) {
assert(ws.m_iters_conflicting.size() == 1);
CTxMemPool::txiter conflict = *ws.m_iters_conflicting.begin();
maybe_rbf_limits.descendant_count += 1;
maybe_rbf_limits.descendant_size_vbytes += conflict->GetSizeWithDescendants();
}
auto ancestors{m_pool.CalculateMemPoolAncestors(*entry, maybe_rbf_limits)};
if (!ancestors) {
CTxMemPool::Limits cpfp_carve_out_limits{
.ancestor_count = 2,
.ancestor_size_vbytes = maybe_rbf_limits.ancestor_size_vbytes,
.descendant_count = maybe_rbf_limits.descendant_count + 1,
.descendant_size_vbytes = maybe_rbf_limits.descendant_size_vbytes + EXTRA_DESCENDANT_TX_SIZE_LIMIT,
};
const auto error_message{util::ErrorString(ancestors).original};
if (ws.m_vsize > EXTRA_DESCENDANT_TX_SIZE_LIMIT) {
return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, ""too-long-mempool-chain"", error_message);
}
ancestors = m_pool.CalculateMemPoolAncestors(*entry, cpfp_carve_out_limits);
if (!ancestors) return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, ""too-long-mempool-chain"", error_message);
}
ws.m_ancestors = *ancestors;
if (const auto err_string{EntriesAndTxidsDisjoint(ws.m_ancestors, ws.m_conflicts, hash)}) {
return state.Invalid(TxValidationResult::TX_CONSENSUS, ""bad-txns-spends-conflicting-tx"", *err_string);
}
m_rbf = !ws.m_conflicts.empty();
return true;
}","bool MemPoolAccept::PreChecks(ATMPArgs& VAR_0, Workspace& VAR_1)
{
AssertLockHeld(VAR_2);
AssertLockHeld(VAR_3.cs);
const CTransactionRef& VAR_4 = VAR_1.m_ptx;
const CTransaction& VAR_5 = *VAR_1.m_ptx;
const Txid& VAR_6 = VAR_1.m_hash;
const int64_t VAR_7 = VAR_0.m_accept_time;
const bool VAR_8 = VAR_0.m_bypass_limits;
std::vector<COutPoint>& VAR_9 = VAR_0.m_coins_to_uncache;
TxValidationState& VAR_10 = VAR_1.m_state;
std::unique_ptr<CTxMemPoolEntry>& VAR_11 = VAR_1.m_entry;
if (!CheckTransaction(VAR_5, VAR_10)) {
return false; 
}
if (VAR_5.IsCoinBase())
return VAR_10.Invalid(TxValidationResult::TX_CONSENSUS, ""coinbase"");
std::string VAR_12;
if (VAR_3.m_require_standard && !IsStandardTx(VAR_5, VAR_3.m_max_datacarrier_bytes, VAR_3.m_permit_bare_multisig, VAR_3.m_dust_relay_feerate, VAR_12)) {
return VAR_10.Invalid(TxValidationResult::TX_NOT_STANDARD, VAR_12);
}
if (::GetSerializeSize(TX_NO_WITNESS(VAR_5)) < VAR_13)
return VAR_10.Invalid(TxValidationResult::TX_NOT_STANDARD, ""tx-size-small"");
if (!CheckFinalTxAtTip(*Assert(VAR_14.m_chain.Tip()), VAR_5)) {
return VAR_10.Invalid(TxValidationResult::TX_PREMATURE_SPEND, ""non-final"");
}
if (VAR_3.exists(GenTxid::Wtxid(VAR_5.GetWitnessHash()))) {
return VAR_10.Invalid(TxValidationResult::TX_CONFLICT, ""txn-already-in-mempool"");
} else if (VAR_3.exists(GenTxid::Txid(VAR_5.GetHash()))) {
return VAR_10.Invalid(TxValidationResult::TX_CONFLICT, ""txn-same-nonwitness-data-in-mempool"");
}
for (const CTxIn &VAR_15 : VAR_5.vin)
{
const CTransaction* VAR_16 = VAR_3.GetConflictTx(VAR_15.prevout);
if (VAR_16) {
if (!VAR_0.m_allow_replacement) {
return VAR_10.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, ""bip125-replacement-disallowed"");
}
if (!VAR_1.m_conflicts.count(VAR_16->GetHash()))
{
if (!VAR_3.m_full_rbf && !SignalsOptInRBF(*VAR_16)) {
return VAR_10.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, ""txn-mempool-conflict"");
}
VAR_1.m_conflicts.insert(VAR_16->GetHash());
}
}
}
VAR_17.SetBackend(VAR_18);
const CCoinsViewCache& VAR_19 = VAR_14.CoinsTip();
for (const CTxIn& VAR_15 : VAR_5.vin) {
if (!VAR_19.HaveCoinInCache(VAR_15.prevout)) {
VAR_9.push_back(VAR_15.prevout);
}
if (!VAR_17.HaveCoin(VAR_15.prevout)) {
for (size_t VAR_20 = 0; VAR_20 < VAR_5.vout.size(); VAR_20++) {
if (VAR_19.HaveCoinInCache(COutPoint(VAR_6, VAR_20))) {
return VAR_10.Invalid(TxValidationResult::TX_CONFLICT, ""txn-already-known"");
}
}
return VAR_10.Invalid(TxValidationResult::TX_MISSING_INPUTS, ""bad-txns-inputs-missingorspent"");
}
}
VAR_17.GetBestBlock();
VAR_17.SetBackend(VAR_21);
assert(VAR_14.m_blockman.LookupBlockIndex(VAR_17.GetBestBlock()) == VAR_14.m_chain.Tip());
const std::optional<LockPoints> VAR_22{CalculateLockPointsAtTip(VAR_14.m_chain.Tip(), VAR_17, VAR_5)};
if (!VAR_22.has_value() || !CheckSequenceLocksAtTip(VAR_14.m_chain.Tip(), *VAR_22)) {
return VAR_10.Invalid(TxValidationResult::TX_PREMATURE_SPEND, ""non-BIP68-final"");
}
if (!Consensus::CheckTxInputs(VAR_5, VAR_10, VAR_17, VAR_14.m_chain.Height() + 1, VAR_1.m_base_fees)) {
return false; 
}
if (VAR_3.m_require_standard && !AreInputsStandard(VAR_5, VAR_17)) {
return VAR_10.Invalid(TxValidationResult::TX_INPUTS_NOT_STANDARD, ""bad-txns-nonstandard-inputs"");
}
if (VAR_5.HasWitness() && VAR_3.m_require_standard && !IsWitnessStandard(VAR_5, VAR_17)) {
return VAR_10.Invalid(TxValidationResult::TX_WITNESS_MUTATED, ""bad-witness-nonstandard"");
}
int64_t VAR_23 = GetTransactionSigOpCost(VAR_5, VAR_17, VAR_24);
VAR_1.m_modified_fees = VAR_1.m_base_fees;
VAR_3.ApplyDelta(VAR_6, VAR_1.m_modified_fees);
bool VAR_25 = false;
for (const CTxIn &VAR_15 : VAR_5.vin) {
const Coin &VAR_26 = VAR_17.AccessCoin(VAR_15.prevout);
if (VAR_26.IsCoinBase()) {
VAR_25 = true;
break;
}
}
const uint64_t VAR_27 = VAR_8 ? 0 : VAR_3.GetSequence();
VAR_11.reset(new CTxMemPoolEntry(VAR_4, VAR_1.m_base_fees, VAR_7, VAR_14.m_chain.Height(), VAR_27,
VAR_25, VAR_23, VAR_22.value()));
VAR_1.m_vsize = VAR_11->GetTxSize();
if (VAR_23 > VAR_28)
return VAR_10.Invalid(TxValidationResult::TX_NOT_STANDARD, ""bad-txns-too-many-sigops"",
strprintf(""%d"", VAR_23));
if (!VAR_8 && VAR_1.m_modified_fees < VAR_3.m_min_relay_feerate.GetFee(VAR_1.m_vsize)) {
return VAR_10.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, ""min relay fee not met"",
strprintf(""%d < %d"", VAR_1.m_modified_fees, VAR_3.m_min_relay_feerate.GetFee(VAR_1.m_vsize)));
}
if (!VAR_8 && !VAR_0.m_package_feerates && !CheckFeeRate(VAR_1.m_vsize, VAR_1.m_modified_fees, VAR_10)) return false;
VAR_1.m_iters_conflicting = VAR_3.GetIterSet(VAR_1.m_conflicts);
CTxMemPool::Limits VAR_29 = VAR_3.m_limits;
if (VAR_1.m_conflicts.size() == 1) {
assert(VAR_1.m_iters_conflicting.size() == 1);
CTxMemPool::txiter VAR_30 = *VAR_1.m_iters_conflicting.begin();
VAR_29.descendant_count += 1;
VAR_29.descendant_size_vbytes += VAR_30->GetSizeWithDescendants();
}
auto VAR_31{VAR_3.CalculateMemPoolAncestors(*VAR_11, VAR_29)};
if (!VAR_31) {
CTxMemPool::Limits VAR_32{
.ancestor_count = 2,
.ancestor_size_vbytes = VAR_29.ancestor_size_vbytes,
.descendant_count = VAR_29.descendant_count + 1,
.descendant_size_vbytes = VAR_29.descendant_size_vbytes + VAR_33,
};
const auto VAR_34{util::ErrorString(VAR_31).original};
if (VAR_1.m_vsize > VAR_33) {
return VAR_10.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, ""too-long-mempool-chain"", VAR_34);
}
VAR_31 = VAR_3.CalculateMemPoolAncestors(*VAR_11, VAR_32);
if (!VAR_31) return VAR_10.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, ""too-long-mempool-chain"", VAR_34);
}
VAR_1.m_ancestors = *VAR_31;
if (const auto VAR_35{EntriesAndTxidsDisjoint(VAR_1.m_ancestors, VAR_1.m_conflicts, VAR_6)}) {
return VAR_10.Invalid(TxValidationResult::TX_CONSENSUS, ""bad-txns-spends-conflicting-tx"", *VAR_35);
}
VAR_36 = !VAR_1.m_conflicts.empty();
return true;
}",bitcoin/f2c0396cd434797c76eecc1180c5f4ba98aee246/validation.cpp/vul/before/0.json,"bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)
{
    AssertLockHeld(cs_main);
    AssertLockHeld(m_pool.cs);
    const CTransactionRef& ptx = ws.m_ptx;
    const CTransaction& tx = *ws.m_ptx;
    const Txid& hash = ws.m_hash;

    // Copy/alias what we need out of args
    const int64_t nAcceptTime = args.m_accept_time;
    const bool bypass_limits = args.m_bypass_limits;
    std::vector<COutPoint>& coins_to_uncache = args.m_coins_to_uncache;

    // Alias what we need out of ws
    TxValidationState& state = ws.m_state;
    std::unique_ptr<CTxMemPoolEntry>& entry = ws.m_entry;

    if (!CheckTransaction(tx, state)) {
        return false; // state filled in by CheckTransaction
    }

    // Coinbase is only valid in a block, not as a loose transaction
    if (tx.IsCoinBase())
        return state.Invalid(TxValidationResult::TX_CONSENSUS, ""coinbase"");

    // Rather not work on nonstandard transactions (unless -testnet/-regtest)
    std::string reason;
    if (m_pool.m_require_standard && !IsStandardTx(tx, m_pool.m_max_datacarrier_bytes, m_pool.m_permit_bare_multisig, m_pool.m_dust_relay_feerate, reason)) {
        return state.Invalid(TxValidationResult::TX_NOT_STANDARD, reason);
    }

    // Transactions smaller than 65 non-witness bytes are not relayed to mitigate CVE-2017-12842.
    if (::GetSerializeSize(TX_NO_WITNESS(tx)) < MIN_STANDARD_TX_NONWITNESS_SIZE)
        return state.Invalid(TxValidationResult::TX_NOT_STANDARD, ""tx-size-small"");

    // Only accept nLockTime-using transactions that can be mined in the next
    // block; we don't want our mempool filled up with transactions that can't
    // be mined yet.
    if (!CheckFinalTxAtTip(*Assert(m_active_chainstate.m_chain.Tip()), tx)) {
        return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, ""non-final"");
    }

    if (m_pool.exists(GenTxid::Wtxid(tx.GetWitnessHash()))) {
        // Exact transaction already exists in the mempool.
        return state.Invalid(TxValidationResult::TX_CONFLICT, ""txn-already-in-mempool"");
    } else if (m_pool.exists(GenTxid::Txid(tx.GetHash()))) {
        // Transaction with the same non-witness data but different witness (same txid, different
        // wtxid) already exists in the mempool.
        return state.Invalid(TxValidationResult::TX_CONFLICT, ""txn-same-nonwitness-data-in-mempool"");
    }

    // Check for conflicts with in-memory transactions
    for (const CTxIn &txin : tx.vin)
    {
        const CTransaction* ptxConflicting = m_pool.GetConflictTx(txin.prevout);
        if (ptxConflicting) {
            if (!args.m_allow_replacement) {
                // Transaction conflicts with a mempool tx, but we're not allowing replacements.
                return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, ""bip125-replacement-disallowed"");
            }
            if (!ws.m_conflicts.count(ptxConflicting->GetHash()))
            {
                // Transactions that don't explicitly signal replaceability are
                // *not* replaceable with the current logic, even if one of their
                // unconfirmed ancestors signals replaceability. This diverges
                // from BIP125's inherited signaling description (see CVE-2021-31876).
                // Applications relying on first-seen mempool behavior should
                // check all unconfirmed ancestors; otherwise an opt-in ancestor
                // might be replaced, causing removal of this descendant.
                //
                // If replaceability signaling is ignored due to node setting,
                // replacement is always allowed.
                if (!m_pool.m_full_rbf && !SignalsOptInRBF(*ptxConflicting)) {
                    return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, ""txn-mempool-conflict"");
                }

                ws.m_conflicts.insert(ptxConflicting->GetHash());
            }
        }
    }

    m_view.SetBackend(m_viewmempool);

    const CCoinsViewCache& coins_cache = m_active_chainstate.CoinsTip();
    // do all inputs exist?
    for (const CTxIn& txin : tx.vin) {
        if (!coins_cache.HaveCoinInCache(txin.prevout)) {
            coins_to_uncache.push_back(txin.prevout);
        }

        // Note: this call may add txin.prevout to the coins cache
        // (coins_cache.cacheCoins) by way of FetchCoin(). It should be removed
        // later (via coins_to_uncache) if this tx turns out to be invalid.
        if (!m_view.HaveCoin(txin.prevout)) {
            // Are inputs missing because we already have the tx?
            for (size_t out = 0; out < tx.vout.size(); out++) {
                // Optimistically just do efficient check of cache for outputs
                if (coins_cache.HaveCoinInCache(COutPoint(hash, out))) {
                    return state.Invalid(TxValidationResult::TX_CONFLICT, ""txn-already-known"");
                }
            }
            // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet
            return state.Invalid(TxValidationResult::TX_MISSING_INPUTS, ""bad-txns-inputs-missingorspent"");
        }
    }

    // This is const, but calls into the back end CoinsViews. The CCoinsViewDB at the bottom of the
    // hierarchy brings the best block into scope. See CCoinsViewDB::GetBestBlock().
    m_view.GetBestBlock();

    // we have all inputs cached now, so switch back to dummy (to protect
    // against bugs where we pull more inputs from disk that miss being added
    // to coins_to_uncache)
    m_view.SetBackend(m_dummy);

    assert(m_active_chainstate.m_blockman.LookupBlockIndex(m_view.GetBestBlock()) == m_active_chainstate.m_chain.Tip());

    // Only accept BIP68 sequence locked transactions that can be mined in the next
    // block; we don't want our mempool filled up with transactions that can't
    // be mined yet.
    // Pass in m_view which has all of the relevant inputs cached. Note that, since m_view's
    // backend was removed, it no longer pulls coins from the mempool.
    const std::optional<LockPoints> lock_points{CalculateLockPointsAtTip(m_active_chainstate.m_chain.Tip(), m_view, tx)};
    if (!lock_points.has_value() || !CheckSequenceLocksAtTip(m_active_chainstate.m_chain.Tip(), *lock_points)) {
        return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, ""non-BIP68-final"");
    }

    // The mempool holds txs for the next block, so pass height+1 to CheckTxInputs
    if (!Consensus::CheckTxInputs(tx, state, m_view, m_active_chainstate.m_chain.Height() + 1, ws.m_base_fees)) {
        return false; // state filled in by CheckTxInputs
    }

    if (m_pool.m_require_standard && !AreInputsStandard(tx, m_view)) {
        return state.Invalid(TxValidationResult::TX_INPUTS_NOT_STANDARD, ""bad-txns-nonstandard-inputs"");
    }

    if (DatacarrierBytes(tx, m_view) > m_pool.m_max_datacarrier_bytes.value_or(0)) {
        return state.Invalid(TxValidationResult::TX_INPUTS_NOT_STANDARD, ""txn-datacarrier-exceeded"");
    }

    // Check for non-standard witnesses.
    if (tx.HasWitness() && m_pool.m_require_standard && !IsWitnessStandard(tx, m_view)) {
        return state.Invalid(TxValidationResult::TX_WITNESS_MUTATED, ""bad-witness-nonstandard"");
    }

    int64_t nSigOpsCost = GetTransactionSigOpCost(tx, m_view, STANDARD_SCRIPT_VERIFY_FLAGS);

    // ws.m_modified_fees includes any fee deltas from PrioritiseTransaction
    ws.m_modified_fees = ws.m_base_fees;
    m_pool.ApplyDelta(hash, ws.m_modified_fees);

    // Keep track of transactions that spend a coinbase, which we re-scan
    // during reorgs to ensure COINBASE_MATURITY is still met.
    bool fSpendsCoinbase = false;
    for (const CTxIn &txin : tx.vin) {
        const Coin &coin = m_view.AccessCoin(txin.prevout);
        if (coin.IsCoinBase()) {
            fSpendsCoinbase = true;
            break;
        }
    }

    // Set entry_sequence to 0 when bypass_limits is used; this allows txs from a block
    // reorg to be marked earlier than any child txs that were already in the mempool.
    const uint64_t entry_sequence = bypass_limits ? 0 : m_pool.GetSequence();
    entry.reset(new CTxMemPoolEntry(ptx, ws.m_base_fees, nAcceptTime, m_active_chainstate.m_chain.Height(), entry_sequence,
                                    fSpendsCoinbase, nSigOpsCost, lock_points.value()));
    ws.m_vsize = entry->GetTxSize();

    if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)
        return state.Invalid(TxValidationResult::TX_NOT_STANDARD, ""bad-txns-too-many-sigops"",
                strprintf(""%d"", nSigOpsCost));

    // No individual transactions are allowed below the min relay feerate except from disconnected blocks.
    // This requirement, unlike CheckFeeRate, cannot be bypassed using m_package_feerates because,
    // while a tx could be package CPFP'd when entering the mempool, we do not have a DoS-resistant
    // method of ensuring the tx remains bumped. For example, the fee-bumping child could disappear
    // due to a replacement.
    if (!bypass_limits && ws.m_modified_fees < m_pool.m_min_relay_feerate.GetFee(ws.m_vsize)) {
        // Even though this is a fee-related failure, this result is TX_MEMPOOL_POLICY, not
        // TX_RECONSIDERABLE, because it cannot be bypassed using package validation.
        return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, ""min relay fee not met"",
                             strprintf(""%d < %d"", ws.m_modified_fees, m_pool.m_min_relay_feerate.GetFee(ws.m_vsize)));
    }
    // No individual transactions are allowed below the mempool min feerate except from disconnected
    // blocks and transactions in a package. Package transactions will be checked using package
    // feerate later.
    if (!bypass_limits && !args.m_package_feerates && !CheckFeeRate(ws.m_vsize, ws.m_modified_fees, state)) return false;

    ws.m_iters_conflicting = m_pool.GetIterSet(ws.m_conflicts);

    // Note that these modifications are only applicable to single transaction scenarios;
    // carve-outs and package RBF are disabled for multi-transaction evaluations.
    CTxMemPool::Limits maybe_rbf_limits = m_pool.m_limits;

    // Calculate in-mempool ancestors, up to a limit.
    if (ws.m_conflicts.size() == 1) {
        // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we
        // would meet the chain limits after the conflicts have been removed. However, there isn't a practical
        // way to do this short of calculating the ancestor and descendant sets with an overlay cache of
        // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't
        // very realistic, thus we only ensure a limited set of transactions are RBF'able despite mempool
        // conflicts here. Importantly, we need to ensure that some transactions which were accepted using
        // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides
        // for off-chain contract systems (see link in the comment below).
        //
        // Specifically, the subset of RBF transactions which we allow despite chain limits are those which
        // conflict directly with exactly one other transaction (but may evict children of said transaction),
        // and which are not adding any new mempool dependencies. Note that the ""no new mempool dependencies""
        // check is accomplished later, so we don't bother doing anything about it here, but if our
        // policy changes, we may need to move that check to here instead of removing it wholesale.
        //
        // Such transactions are clearly not merging any existing packages, so we are only concerned with
        // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are
        // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed
        // to.
        //
        // To check these we first check if we meet the RBF criteria, above, and increment the descendant
        // limits by the direct conflict and its descendants (as these are recalculated in
        // CalculateMempoolAncestors by assuming the new transaction being added is a new descendant, with no
        // removals, of each parent's existing dependent set). The ancestor count limits are unmodified (as
        // the ancestor limits should be the same for both our new transaction and any conflicts).
        // We don't bother incrementing m_limit_descendants by the full removal count as that limit never comes
        // into force here (as we're only adding a single transaction).
        assert(ws.m_iters_conflicting.size() == 1);
        CTxMemPool::txiter conflict = *ws.m_iters_conflicting.begin();

        maybe_rbf_limits.descendant_count += 1;
        maybe_rbf_limits.descendant_size_vbytes += conflict->GetSizeWithDescendants();
    }

    auto ancestors{m_pool.CalculateMemPoolAncestors(*entry, maybe_rbf_limits)};
    if (!ancestors) {
        // If CalculateMemPoolAncestors fails second time, we want the original error string.
        // Contracting/payment channels CPFP carve-out:
        // If the new transaction is relatively small (up to 40k weight)
        // and has at most one ancestor (ie ancestor limit of 2, including
        // the new transaction), allow it if its parent has exactly the
        // descendant limit descendants.
        //
        // This allows protocols which rely on distrusting counterparties
        // being able to broadcast descendants of an unconfirmed transaction
        // to be secure by simply only having two immediately-spendable
        // outputs - one for each counterparty. For more info on the uses for
        // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html
        CTxMemPool::Limits cpfp_carve_out_limits{
            .ancestor_count = 2,
            .ancestor_size_vbytes = maybe_rbf_limits.ancestor_size_vbytes,
            .descendant_count = maybe_rbf_limits.descendant_count + 1,
            .descendant_size_vbytes = maybe_rbf_limits.descendant_size_vbytes + EXTRA_DESCENDANT_TX_SIZE_LIMIT,
        };
        const auto error_message{util::ErrorString(ancestors).original};
        if (ws.m_vsize > EXTRA_DESCENDANT_TX_SIZE_LIMIT) {
            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, ""too-long-mempool-chain"", error_message);
        }
        ancestors = m_pool.CalculateMemPoolAncestors(*entry, cpfp_carve_out_limits);
        if (!ancestors) return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, ""too-long-mempool-chain"", error_message);
    }

    ws.m_ancestors = *ancestors;

    // A transaction that spends outputs that would be replaced by it is invalid. Now
    // that we have the set of all ancestors we can detect this
    // pathological case by making sure ws.m_conflicts and ws.m_ancestors don't
    // intersect.
    if (const auto err_string{EntriesAndTxidsDisjoint(ws.m_ancestors, ws.m_conflicts, hash)}) {
        // We classify this as a consensus error because a transaction depending on something it
        // conflicts with would be inconsistent.
        return state.Invalid(TxValidationResult::TX_CONSENSUS, ""bad-txns-spends-conflicting-tx"", *err_string);
    }

    m_rbf = !ws.m_conflicts.empty();
    return true;
}","bool MemPoolAccept::PreChecks(ATMPArgs& VAR_0, Workspace& VAR_1)
{
    AssertLockHeld(VAR_2);
    AssertLockHeld(VAR_3.cs);
    const CTransactionRef& VAR_4 = VAR_1.m_ptx;
    const CTransaction& VAR_5 = *VAR_1.m_ptx;
    const Txid& VAR_6 = VAR_1.m_hash;

    /* COMMENT_0 */
    const int64_t VAR_7 = VAR_0.m_accept_time;
    const bool VAR_8 = VAR_0.m_bypass_limits;
    std::vector<COutPoint>& VAR_9 = VAR_0.m_coins_to_uncache;

    /* COMMENT_1 */
    TxValidationState& VAR_10 = VAR_1.m_state;
    std::unique_ptr<CTxMemPoolEntry>& VAR_11 = VAR_1.m_entry;

    if (!CheckTransaction(VAR_5, VAR_10)) {
        return false; /* COMMENT_2 */
    }

    /* COMMENT_3 */
    if (VAR_5.IsCoinBase())
        return VAR_10.Invalid(TxValidationResult::TX_CONSENSUS, ""coinbase"");

    /* COMMENT_4 */
    std::string VAR_12;
    if (VAR_3.m_require_standard && !IsStandardTx(VAR_5, VAR_3.m_max_datacarrier_bytes, VAR_3.m_permit_bare_multisig, VAR_3.m_dust_relay_feerate, VAR_12)) {
        return VAR_10.Invalid(TxValidationResult::TX_NOT_STANDARD, VAR_12);
    }

    /* COMMENT_5 */
    if (::GetSerializeSize(TX_NO_WITNESS(VAR_5)) < VAR_13)
        return VAR_10.Invalid(TxValidationResult::TX_NOT_STANDARD, ""tx-size-small"");

    /* COMMENT_6 */
    /* COMMENT_7 */
    /* COMMENT_8 */
    if (!CheckFinalTxAtTip(*Assert(VAR_14.m_chain.Tip()), VAR_5)) {
        return VAR_10.Invalid(TxValidationResult::TX_PREMATURE_SPEND, ""non-final"");
    }

    if (VAR_3.exists(GenTxid::Wtxid(VAR_5.GetWitnessHash()))) {
        /* COMMENT_9 */
        return VAR_10.Invalid(TxValidationResult::TX_CONFLICT, ""txn-already-in-mempool"");
    } else if (VAR_3.exists(GenTxid::Txid(VAR_5.GetHash()))) {
        /* COMMENT_10 */
        /* COMMENT_11 */
        return VAR_10.Invalid(TxValidationResult::TX_CONFLICT, ""txn-same-nonwitness-data-in-mempool"");
    }

    /* COMMENT_12 */
    for (const CTxIn &VAR_15 : VAR_5.vin)
    {
        const CTransaction* VAR_16 = VAR_3.GetConflictTx(VAR_15.prevout);
        if (VAR_16) {
            if (!VAR_0.m_allow_replacement) {
                /* COMMENT_13 */
                return VAR_10.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, ""bip125-replacement-disallowed"");
            }
            if (!VAR_1.m_conflicts.count(VAR_16->GetHash()))
            {
                /* COMMENT_14 */
                /* COMMENT_15 */
                /* COMMENT_16 */
                /* COMMENT_17 */
                /* COMMENT_18 */
                /* COMMENT_19 */
                /* COMMENT_20 */
                /* COMMENT_21 */
                /* COMMENT_22 */
                /* COMMENT_23 */
                if (!VAR_3.m_full_rbf && !SignalsOptInRBF(*VAR_16)) {
                    return VAR_10.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, ""txn-mempool-conflict"");
                }

                VAR_1.m_conflicts.insert(VAR_16->GetHash());
            }
        }
    }

    VAR_17.SetBackend(VAR_18);

    const CCoinsViewCache& VAR_19 = VAR_14.CoinsTip();
    /* COMMENT_24 */
    for (const CTxIn& VAR_15 : VAR_5.vin) {
        if (!VAR_19.HaveCoinInCache(VAR_15.prevout)) {
            VAR_9.push_back(VAR_15.prevout);
        }

        /* COMMENT_25 */
        /* COMMENT_26 */
        /* COMMENT_27 */
        if (!VAR_17.HaveCoin(VAR_15.prevout)) {
            /* COMMENT_28 */
            for (size_t VAR_20 = 0; VAR_20 < VAR_5.vout.size(); VAR_20++) {
                /* COMMENT_29 */
                if (VAR_19.HaveCoinInCache(COutPoint(VAR_6, VAR_20))) {
                    return VAR_10.Invalid(TxValidationResult::TX_CONFLICT, ""txn-already-known"");
                }
            }
            /* COMMENT_30 */
            return VAR_10.Invalid(TxValidationResult::TX_MISSING_INPUTS, ""bad-txns-inputs-missingorspent"");
        }
    }

    /* COMMENT_31 */
    /* COMMENT_32 */
    VAR_17.GetBestBlock();

    /* COMMENT_33 */
    /* COMMENT_34 */
    /* COMMENT_35 */
    VAR_17.SetBackend(VAR_21);

    assert(VAR_14.m_blockman.LookupBlockIndex(VAR_17.GetBestBlock()) == VAR_14.m_chain.Tip());

    /* COMMENT_36 */
    /* COMMENT_7 */
    /* COMMENT_8 */
    /* COMMENT_37 */
    /* COMMENT_38 */
    const std::optional<LockPoints> VAR_22{CalculateLockPointsAtTip(VAR_14.m_chain.Tip(), VAR_17, VAR_5)};
    if (!VAR_22.has_value() || !CheckSequenceLocksAtTip(VAR_14.m_chain.Tip(), *VAR_22)) {
        return VAR_10.Invalid(TxValidationResult::TX_PREMATURE_SPEND, ""non-BIP68-final"");
    }

    /* COMMENT_39 */
    if (!Consensus::CheckTxInputs(VAR_5, VAR_10, VAR_17, VAR_14.m_chain.Height() + 1, VAR_1.m_base_fees)) {
        return false; /* COMMENT_40 */
    }

    if (VAR_3.m_require_standard && !AreInputsStandard(VAR_5, VAR_17)) {
        return VAR_10.Invalid(TxValidationResult::TX_INPUTS_NOT_STANDARD, ""bad-txns-nonstandard-inputs"");
    }

    if (DatacarrierBytes(VAR_5, VAR_17) > VAR_3.m_max_datacarrier_bytes.value_or(0)) {
        return VAR_10.Invalid(TxValidationResult::TX_INPUTS_NOT_STANDARD, ""txn-datacarrier-exceeded"");
    }

    /* COMMENT_41 */
    if (VAR_5.HasWitness() && VAR_3.m_require_standard && !IsWitnessStandard(VAR_5, VAR_17)) {
        return VAR_10.Invalid(TxValidationResult::TX_WITNESS_MUTATED, ""bad-witness-nonstandard"");
    }

    int64_t VAR_23 = GetTransactionSigOpCost(VAR_5, VAR_17, VAR_24);

    /* COMMENT_42 */
    VAR_1.m_modified_fees = VAR_1.m_base_fees;
    VAR_3.ApplyDelta(VAR_6, VAR_1.m_modified_fees);

    /* COMMENT_43 */
    /* COMMENT_44 */
    bool VAR_25 = false;
    for (const CTxIn &VAR_15 : VAR_5.vin) {
        const Coin &VAR_26 = VAR_17.AccessCoin(VAR_15.prevout);
        if (VAR_26.IsCoinBase()) {
            VAR_25 = true;
            break;
        }
    }

    /* COMMENT_45 */
    /* COMMENT_46 */
    const uint64_t VAR_27 = VAR_8 ? 0 : VAR_3.GetSequence();
    VAR_11.reset(new CTxMemPoolEntry(VAR_4, VAR_1.m_base_fees, VAR_7, VAR_14.m_chain.Height(), VAR_27,
                                    VAR_25, VAR_23, VAR_22.value()));
    VAR_1.m_vsize = VAR_11->GetTxSize();

    if (VAR_23 > VAR_28)
        return VAR_10.Invalid(TxValidationResult::TX_NOT_STANDARD, ""bad-txns-too-many-sigops"",
                strprintf(""%d"", VAR_23));

    /* COMMENT_47 */
    /* COMMENT_48 */
    /* COMMENT_49 */
    /* COMMENT_50 */
    /* COMMENT_51 */
    if (!VAR_8 && VAR_1.m_modified_fees < VAR_3.m_min_relay_feerate.GetFee(VAR_1.m_vsize)) {
        /* COMMENT_52 */
        /* COMMENT_53 */
        return VAR_10.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, ""min relay fee not met"",
                             strprintf(""%d < %d"", VAR_1.m_modified_fees, VAR_3.m_min_relay_feerate.GetFee(VAR_1.m_vsize)));
    }
    /* COMMENT_54 */
    /* COMMENT_55 */
    /* COMMENT_56 */
    if (!VAR_8 && !VAR_0.m_package_feerates && !CheckFeeRate(VAR_1.m_vsize, VAR_1.m_modified_fees, VAR_10)) return false;

    VAR_1.m_iters_conflicting = VAR_3.GetIterSet(VAR_1.m_conflicts);

    /* COMMENT_57 */
    /* COMMENT_58 */
    CTxMemPool::Limits VAR_29 = VAR_3.m_limits;

    /* COMMENT_59 */
    if (VAR_1.m_conflicts.size() == 1) {
        /* COMMENT_60 */
        /* COMMENT_61 */
        /* COMMENT_62 */
        /* COMMENT_63 */
        /* COMMENT_64 */
        /* COMMENT_65 */
        /* COMMENT_66 */
        /* COMMENT_67 */
        /* COMMENT_21 */
        /* COMMENT_68 */
        /* COMMENT_69 */
        /* COMMENT_70 */
        /* COMMENT_71 */
        /* COMMENT_72 */
        /* COMMENT_21 */
        /* COMMENT_73 */
        /* COMMENT_74 */
        /* COMMENT_75 */
        /* COMMENT_76 */
        /* COMMENT_21 */
        /* COMMENT_77 */
        /* COMMENT_78 */
        /* COMMENT_79 */
        /* COMMENT_80 */
        /* COMMENT_81 */
        /* COMMENT_82 */
        /* COMMENT_83 */
        assert(VAR_1.m_iters_conflicting.size() == 1);
        CTxMemPool::txiter VAR_30 = *VAR_1.m_iters_conflicting.begin();

        VAR_29.descendant_count += 1;
        VAR_29.descendant_size_vbytes += VAR_30->GetSizeWithDescendants();
    }

    auto VAR_31{VAR_3.CalculateMemPoolAncestors(*VAR_11, VAR_29)};
    if (!VAR_31) {
        /* COMMENT_84 */
        /* COMMENT_85 */
        /* COMMENT_86 */
        /* COMMENT_87 */
        /* COMMENT_88 */
        /* COMMENT_89 */
        /* COMMENT_21 */
        /* COMMENT_90 */
        /* COMMENT_91 */
        /* COMMENT_92 */
        /* COMMENT_93 */
        /* COMMENT_94 */
        CTxMemPool::Limits VAR_32{
            .ancestor_count = 2,
            .ancestor_size_vbytes = VAR_29.ancestor_size_vbytes,
            .descendant_count = VAR_29.descendant_count + 1,
            .descendant_size_vbytes = VAR_29.descendant_size_vbytes + VAR_33,
        };
        const auto VAR_34{util::ErrorString(VAR_31).original};
        if (VAR_1.m_vsize > VAR_33) {
            return VAR_10.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, ""too-long-mempool-chain"", VAR_34);
        }
        VAR_31 = VAR_3.CalculateMemPoolAncestors(*VAR_11, VAR_32);
        if (!VAR_31) return VAR_10.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, ""too-long-mempool-chain"", VAR_34);
    }

    VAR_1.m_ancestors = *VAR_31;

    /* COMMENT_95 */
    /* COMMENT_96 */
    /* COMMENT_97 */
    /* COMMENT_98 */
    if (const auto VAR_35{EntriesAndTxidsDisjoint(VAR_1.m_ancestors, VAR_1.m_conflicts, VAR_6)}) {
        /* COMMENT_99 */
        /* COMMENT_100 */
        return VAR_10.Invalid(TxValidationResult::TX_CONSENSUS, ""bad-txns-spends-conflicting-tx"", *VAR_35);
    }

    VAR_36 = !VAR_1.m_conflicts.empty();
    return true;
}",bitcoin/f2c0396cd434797c76eecc1180c5f4ba98aee246/validation.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -134,6 +134,10 @@
         return state.Invalid(TxValidationResult::TX_INPUTS_NOT_STANDARD, ""bad-txns-nonstandard-inputs"");
     }
 
+    if (DatacarrierBytes(tx, m_view) > m_pool.m_max_datacarrier_bytes.value_or(0)) {
+        return state.Invalid(TxValidationResult::TX_INPUTS_NOT_STANDARD, ""txn-datacarrier-exceeded"");
+    }
+
     // Check for non-standard witnesses.
     if (tx.HasWitness() && m_pool.m_require_standard && !IsWitnessStandard(tx, m_view)) {
         return state.Invalid(TxValidationResult::TX_WITNESS_MUTATED, ""bad-witness-nonstandard"");","{'deleted_lines': [], 'added_lines': ['    if (DatacarrierBytes(tx, m_view) > m_pool.m_max_datacarrier_bytes.value_or(0)) {', '        return state.Invalid(TxValidationResult::TX_INPUTS_NOT_STANDARD, ""txn-datacarrier-exceeded"");', '    }', '']}",True,"In Bitcoin Core through 26.0 and Bitcoin Knots before 25.1.knots20231115, datacarrier size limits can be bypassed by obfuscating data as code (e.g., with OP_FALSE OP_IF), as exploited in the wild by Inscriptions in 2022 and 2023. NOTE: although this is a vulnerability from the perspective of the Bitcoin Knots project, some others consider it ""not a bug.""",5.3,MEDIUM,1,test,2023-09-05T00:54:20Z,4
CVE-2023-42465,['CWE-Other'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,sudo-project/sudo,"Try to make sudo less vulnerable to ROWHAMMER attacks.

We now use ROWHAMMER-resistent values for ALLOW, DENY, AUTH_SUCCESS,
AUTH_FAILURE, AUTH_ERROR and AUTH_NONINTERACTIVE.  In addition, we
explicitly test for expected values instead of using a negated test
against an error value.  In the parser match functions this means
explicitly checking for ALLOW or DENY instead of accepting anything
that is not set to UNSPEC.

Thanks to Andrew J. Adiletta, M. Caner Tol, Yarkin Doroz, and Berk
Sunar, all affiliated with the Vernam Applied Cryptography and
Cybersecurity Lab at Worcester Polytechnic Institute, for the report.
Paper preprint: https://arxiv.org/abs/2309.02545",7873f8334c8d31031f8cfa83bd97ac6029309e4f,https://github.com/sudo-project/sudo/commit/7873f8334c8d31031f8cfa83bd97ac6029309e4f,plugins/sudoers/match.c,user_matches,"int
user_matches(const struct sudoers_parse_tree *parse_tree,
const struct passwd *pw, const struct member *m)
{
const struct sudoers_context *ctx = parse_tree->ctx;
const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;
const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;
int matched = UNSPEC;
struct alias *a;
debug_decl(user_matches, SUDOERS_DEBUG_MATCH);
switch (m->type) {
case ALL:
matched = m->negated ? DENY : ALLOW;
break;
case NETGROUP:
if (netgr_matches(parse_tree->nss, m->name,
def_netgroup_tuple ? lhost : NULL,
def_netgroup_tuple ? shost : NULL, pw->pw_name))
matched = m->negated ? DENY : ALLOW;
break;
case USERGROUP:
if (usergr_matches(m->name, pw->pw_name, pw))
matched = m->negated ? DENY : ALLOW;
break;
case ALIAS:
if ((a = alias_get(parse_tree, m->name, USERALIAS)) != NULL) {
const int rc = userlist_matches(parse_tree, pw, &a->members);
if (rc != UNSPEC) {
if (m->negated) {
matched = rc == ALLOW ? DENY : ALLOW;
} else {
matched = rc;
}
}
alias_put(a);
break;
}
FALLTHROUGH;
case WORD:
if (userpw_matches(m->name, pw->pw_name, pw))
matched = m->negated ? DENY : ALLOW;
break;
}
debug_return_int(matched);
}","int
user_matches(const struct sudoers_parse_tree *VAR_0,
const struct passwd *VAR_1, const struct member *VAR_2)
{
const struct sudoers_context *VAR_3 = VAR_0->ctx;
const char *VAR_4 = VAR_0->lhost ? VAR_0->lhost : VAR_3->runas.host;
const char *VAR_5 = VAR_0->shost ? VAR_0->shost : VAR_3->runas.shost;
int VAR_6 = VAR_7;
struct alias *VAR_8;
debug_decl(VAR_9, VAR_10);
switch (VAR_2->type) {
case VAR_11:
VAR_6 = VAR_2->negated ? VAR_12 : VAR_13;
break;
case VAR_14:
if (netgr_matches(VAR_0->nss, VAR_2->name,
VAR_15 ? VAR_4 : NULL,
VAR_15 ? VAR_5 : NULL, VAR_1->pw_name))
VAR_6 = VAR_2->negated ? VAR_12 : VAR_13;
break;
case VAR_16:
if (usergr_matches(VAR_2->name, VAR_1->pw_name, VAR_1))
VAR_6 = VAR_2->negated ? VAR_12 : VAR_13;
break;
case VAR_17:
if ((VAR_8 = alias_get(VAR_0, VAR_2->name, VAR_18)) != NULL) {
const int VAR_19 = userlist_matches(VAR_0, VAR_1, &VAR_8->members);
if (VAR_19 != VAR_7) {
if (VAR_2->negated) {
VAR_6 = VAR_19 == VAR_13 ? VAR_12 : VAR_13;
} else {
VAR_6 = VAR_19;
}
}
alias_put(VAR_8);
break;
}
VAR_20;
case VAR_21:
if (userpw_matches(VAR_2->name, VAR_1->pw_name, VAR_1))
VAR_6 = VAR_2->negated ? VAR_12 : VAR_13;
break;
}
debug_return_int(VAR_6);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/match.c/vul/before/1.json,"int
user_matches(const struct sudoers_parse_tree *parse_tree,
    const struct passwd *pw, const struct member *m)
{
    const struct sudoers_context *ctx = parse_tree->ctx;
    const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;
    const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;
    int matched = UNSPEC;
    struct alias *a;
    debug_decl(user_matches, SUDOERS_DEBUG_MATCH);

    switch (m->type) {
	case ALL:
	    matched = m->negated ? DENY : ALLOW;
	    break;
	case NETGROUP:
	    if (netgr_matches(parse_tree->nss, m->name,
		def_netgroup_tuple ? lhost : NULL,
		def_netgroup_tuple ? shost : NULL, pw->pw_name))
		matched = m->negated ? DENY : ALLOW;
	    break;
	case USERGROUP:
	    if (usergr_matches(m->name, pw->pw_name, pw))
		matched = m->negated ? DENY : ALLOW;
	    break;
	case ALIAS:
	    if ((a = alias_get(parse_tree, m->name, USERALIAS)) != NULL) {
		/* XXX */
		const int rc = userlist_matches(parse_tree, pw, &a->members);
		if (SPECIFIED(rc)) {
		    if (m->negated) {
			matched = rc == ALLOW ? DENY : ALLOW;
		    } else {
			matched = rc;
		    }
		}
		alias_put(a);
		break;
	    }
	    FALLTHROUGH;
	case WORD:
	    if (userpw_matches(m->name, pw->pw_name, pw))
		matched = m->negated ? DENY : ALLOW;
	    break;
    }
    debug_return_int(matched);
}","int
user_matches(const struct sudoers_parse_tree *VAR_0,
    const struct passwd *VAR_1, const struct member *VAR_2)
{
    const struct sudoers_context *VAR_3 = VAR_0->ctx;
    const char *VAR_4 = VAR_0->lhost ? VAR_0->lhost : VAR_3->runas.host;
    const char *VAR_5 = VAR_0->shost ? VAR_0->shost : VAR_3->runas.shost;
    int VAR_6 = VAR_7;
    struct alias *VAR_8;
    debug_decl(VAR_9, VAR_10);

    switch (VAR_2->type) {
	case VAR_11:
	    VAR_6 = VAR_2->negated ? VAR_12 : VAR_13;
	    break;
	case VAR_14:
	    if (netgr_matches(VAR_0->nss, VAR_2->name,
		VAR_15 ? VAR_4 : NULL,
		VAR_15 ? VAR_5 : NULL, VAR_1->pw_name))
		VAR_6 = VAR_2->negated ? VAR_12 : VAR_13;
	    break;
	case VAR_16:
	    if (usergr_matches(VAR_2->name, VAR_1->pw_name, VAR_1))
		VAR_6 = VAR_2->negated ? VAR_12 : VAR_13;
	    break;
	case VAR_17:
	    if ((VAR_8 = alias_get(VAR_0, VAR_2->name, VAR_18)) != NULL) {
		/* COMMENT_0 */
		const int VAR_19 = userlist_matches(VAR_0, VAR_1, &VAR_8->members);
		if (SPECIFIED(VAR_19)) {
		    if (VAR_2->negated) {
			VAR_6 = VAR_19 == VAR_13 ? VAR_12 : VAR_13;
		    } else {
			VAR_6 = VAR_19;
		    }
		}
		alias_put(VAR_8);
		break;
	    }
	    VAR_20;
	case VAR_21:
	    if (userpw_matches(VAR_2->name, VAR_1->pw_name, VAR_1))
		VAR_6 = VAR_2->negated ? VAR_12 : VAR_13;
	    break;
    }
    debug_return_int(VAR_6);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/match.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -27,7 +27,7 @@
 	    if ((a = alias_get(parse_tree, m->name, USERALIAS)) != NULL) {
 		/* XXX */
 		const int rc = userlist_matches(parse_tree, pw, &a->members);
-		if (rc != UNSPEC) {
+		if (SPECIFIED(rc)) {
 		    if (m->negated) {
 			matched = rc == ALLOW ? DENY : ALLOW;
 		    } else {","{'deleted_lines': ['\t\tif (rc != UNSPEC) {'], 'added_lines': ['\t\tif (SPECIFIED(rc)) {']}",True,"Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.",7.0,HIGH,2,test,2023-09-09T20:07:04Z,4
CVE-2023-42465,['CWE-Other'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,sudo-project/sudo,"Try to make sudo less vulnerable to ROWHAMMER attacks.

We now use ROWHAMMER-resistent values for ALLOW, DENY, AUTH_SUCCESS,
AUTH_FAILURE, AUTH_ERROR and AUTH_NONINTERACTIVE.  In addition, we
explicitly test for expected values instead of using a negated test
against an error value.  In the parser match functions this means
explicitly checking for ALLOW or DENY instead of accepting anything
that is not set to UNSPEC.

Thanks to Andrew J. Adiletta, M. Caner Tol, Yarkin Doroz, and Berk
Sunar, all affiliated with the Vernam Applied Cryptography and
Cybersecurity Lab at Worcester Polytechnic Institute, for the report.
Paper preprint: https://arxiv.org/abs/2309.02545",7873f8334c8d31031f8cfa83bd97ac6029309e4f,https://github.com/sudo-project/sudo/commit/7873f8334c8d31031f8cfa83bd97ac6029309e4f,plugins/sudoers/match.c,host_matches,"int
host_matches(const struct sudoers_parse_tree *parse_tree,
const struct passwd *pw, const char *lhost, const char *shost,
const struct member *m)
{
struct alias *a;
int matched = UNSPEC;
debug_decl(host_matches, SUDOERS_DEBUG_MATCH);
switch (m->type) {
case ALL:
matched = m->negated ? DENY : ALLOW;
break;
case NETGROUP:
if (netgr_matches(parse_tree->nss, m->name, lhost, shost,
def_netgroup_tuple ? pw->pw_name : NULL))
matched = m->negated ? DENY : ALLOW;
break;
case NTWKADDR:
if (addr_matches(m->name))
matched = m->negated ? DENY : ALLOW;
break;
case ALIAS:
a = alias_get(parse_tree, m->name, HOSTALIAS);
if (a != NULL) {
const int rc = hostlist_matches_int(parse_tree, pw, lhost,
shost, &a->members);
if (rc != UNSPEC) {
if (m->negated) {
matched = rc == ALLOW ? DENY : ALLOW;
} else {
matched = rc;
}
}
alias_put(a);
break;
}
FALLTHROUGH;
case WORD:
if (hostname_matches(shost, lhost, m->name))
matched = m->negated ? DENY : ALLOW;
break;
}
sudo_debug_printf(SUDO_DEBUG_DEBUG,
""host %s (%s) matches sudoers host %s%s: %s"", lhost, shost,
m->negated ? ""!"" : """", m->name ? m->name : ""ALL"",
matched == true ? ""true"" : ""false"");
debug_return_int(matched);
}","int
host_matches(const struct sudoers_parse_tree *VAR_0,
const struct passwd *VAR_1, const char *VAR_2, const char *VAR_3,
const struct member *VAR_4)
{
struct alias *VAR_5;
int VAR_6 = VAR_7;
debug_decl(VAR_8, VAR_9);
switch (VAR_4->type) {
case VAR_10:
VAR_6 = VAR_4->negated ? VAR_11 : VAR_12;
break;
case VAR_13:
if (netgr_matches(VAR_0->nss, VAR_4->name, VAR_2, VAR_3,
VAR_14 ? VAR_1->pw_name : NULL))
VAR_6 = VAR_4->negated ? VAR_11 : VAR_12;
break;
case VAR_15:
if (addr_matches(VAR_4->name))
VAR_6 = VAR_4->negated ? VAR_11 : VAR_12;
break;
case VAR_16:
VAR_5 = alias_get(VAR_0, VAR_4->name, VAR_17);
if (VAR_5 != NULL) {
const int VAR_18 = hostlist_matches_int(VAR_0, VAR_1, VAR_2,
VAR_3, &VAR_5->members);
if (VAR_18 != VAR_7) {
if (VAR_4->negated) {
VAR_6 = VAR_18 == VAR_12 ? VAR_11 : VAR_12;
} else {
VAR_6 = VAR_18;
}
}
alias_put(VAR_5);
break;
}
VAR_19;
case VAR_20:
if (hostname_matches(VAR_3, VAR_2, VAR_4->name))
VAR_6 = VAR_4->negated ? VAR_11 : VAR_12;
break;
}
sudo_debug_printf(VAR_21,
""host %s (%s) matches sudoers host %s%s: %s"", VAR_2, VAR_3,
VAR_4->negated ? ""!"" : """", VAR_4->name ? VAR_4->name : ""ALL"",
VAR_6 == true ? ""true"" : ""false"");
debug_return_int(VAR_6);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/match.c/vul/before/0.json,"int
host_matches(const struct sudoers_parse_tree *parse_tree,
    const struct passwd *pw, const char *lhost, const char *shost,
    const struct member *m)
{
    struct alias *a;
    int matched = UNSPEC;
    debug_decl(host_matches, SUDOERS_DEBUG_MATCH);

    switch (m->type) {
	case ALL:
	    matched = m->negated ? DENY : ALLOW;
	    break;
	case NETGROUP:
	    if (netgr_matches(parse_tree->nss, m->name, lhost, shost,
		def_netgroup_tuple ? pw->pw_name : NULL))
		matched = m->negated ? DENY : ALLOW;
	    break;
	case NTWKADDR:
	    if (addr_matches(m->name))
		matched = m->negated ? DENY : ALLOW;
	    break;
	case ALIAS:
	    a = alias_get(parse_tree, m->name, HOSTALIAS);
	    if (a != NULL) {
		/* XXX */
		const int rc = hostlist_matches_int(parse_tree, pw, lhost,
		    shost, &a->members);
		if (SPECIFIED(rc)) {
		    if (m->negated) {
			matched = rc == ALLOW ? DENY : ALLOW;
		    } else {
			matched = rc;
		    }
		}
		alias_put(a);
		break;
	    }
	    FALLTHROUGH;
	case WORD:
	    if (hostname_matches(shost, lhost, m->name))
		matched = m->negated ? DENY : ALLOW;
	    break;
    }
    sudo_debug_printf(SUDO_DEBUG_DEBUG,
	""host %s (%s) matches sudoers host %s%s: %s"", lhost, shost,
	m->negated ? ""!"" : """", m->name ? m->name : ""ALL"",
	matched == true ? ""true"" : ""false"");
    debug_return_int(matched);
}","int
host_matches(const struct sudoers_parse_tree *VAR_0,
    const struct passwd *VAR_1, const char *VAR_2, const char *VAR_3,
    const struct member *VAR_4)
{
    struct alias *VAR_5;
    int VAR_6 = VAR_7;
    debug_decl(VAR_8, VAR_9);

    switch (VAR_4->type) {
	case VAR_10:
	    VAR_6 = VAR_4->negated ? VAR_11 : VAR_12;
	    break;
	case VAR_13:
	    if (netgr_matches(VAR_0->nss, VAR_4->name, VAR_2, VAR_3,
		VAR_14 ? VAR_1->pw_name : NULL))
		VAR_6 = VAR_4->negated ? VAR_11 : VAR_12;
	    break;
	case VAR_15:
	    if (addr_matches(VAR_4->name))
		VAR_6 = VAR_4->negated ? VAR_11 : VAR_12;
	    break;
	case VAR_16:
	    VAR_5 = alias_get(VAR_0, VAR_4->name, VAR_17);
	    if (VAR_5 != NULL) {
		/* COMMENT_0 */
		const int VAR_18 = hostlist_matches_int(VAR_0, VAR_1, VAR_2,
		    VAR_3, &VAR_5->members);
		if (SPECIFIED(VAR_18)) {
		    if (VAR_4->negated) {
			VAR_6 = VAR_18 == VAR_12 ? VAR_11 : VAR_12;
		    } else {
			VAR_6 = VAR_18;
		    }
		}
		alias_put(VAR_5);
		break;
	    }
	    VAR_19;
	case VAR_20:
	    if (hostname_matches(VAR_3, VAR_2, VAR_4->name))
		VAR_6 = VAR_4->negated ? VAR_11 : VAR_12;
	    break;
    }
    sudo_debug_printf(VAR_21,
	""host %s (%s) matches sudoers host %s%s: %s"", VAR_2, VAR_3,
	VAR_4->negated ? ""!"" : """", VAR_4->name ? VAR_4->name : ""ALL"",
	VAR_6 == true ? ""true"" : ""false"");
    debug_return_int(VAR_6);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/match.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -26,7 +26,7 @@
 		/* XXX */
 		const int rc = hostlist_matches_int(parse_tree, pw, lhost,
 		    shost, &a->members);
-		if (rc != UNSPEC) {
+		if (SPECIFIED(rc)) {
 		    if (m->negated) {
 			matched = rc == ALLOW ? DENY : ALLOW;
 		    } else {","{'deleted_lines': ['\t\tif (rc != UNSPEC) {'], 'added_lines': ['\t\tif (SPECIFIED(rc)) {']}",True,"Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.",7.0,HIGH,2,test,2023-09-09T20:07:04Z,4
CVE-2023-42465,['CWE-Other'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,sudo-project/sudo,"Try to make sudo less vulnerable to ROWHAMMER attacks.

We now use ROWHAMMER-resistent values for ALLOW, DENY, AUTH_SUCCESS,
AUTH_FAILURE, AUTH_ERROR and AUTH_NONINTERACTIVE.  In addition, we
explicitly test for expected values instead of using a negated test
against an error value.  In the parser match functions this means
explicitly checking for ALLOW or DENY instead of accepting anything
that is not set to UNSPEC.

Thanks to Andrew J. Adiletta, M. Caner Tol, Yarkin Doroz, and Berk
Sunar, all affiliated with the Vernam Applied Cryptography and
Cybersecurity Lab at Worcester Polytechnic Institute, for the report.
Paper preprint: https://arxiv.org/abs/2309.02545",7873f8334c8d31031f8cfa83bd97ac6029309e4f,https://github.com/sudo-project/sudo/commit/7873f8334c8d31031f8cfa83bd97ac6029309e4f,plugins/sudoers/lookup.c,sudoers_lookup,"unsigned int
sudoers_lookup(struct sudo_nss_list *snl, struct sudoers_context *ctx,
time_t now, sudoers_lookup_callback_fn_t callback, void *cb_data,
int *cmnd_status, int pwflag)
{
struct defaults_list *defs = NULL;
struct sudoers_parse_tree *parse_tree = NULL;
struct cmndspec *cs = NULL;
struct sudo_nss *nss;
struct cmnd_info info;
unsigned int validated = FLAG_NO_USER | FLAG_NO_HOST;
int m, match = UNSPEC;
debug_decl(sudoers_lookup, SUDOERS_DEBUG_PARSER);
if (pwflag) {
debug_return_uint(sudoers_lookup_pseudo(snl, ctx, now, callback,
cb_data, pwflag));
}
if (!set_perms(ctx, PERM_RUNAS))
debug_return_uint(validated);
TAILQ_FOREACH(nss, snl, entries) {
if (nss->query(ctx, nss, ctx->user.pw) == -1) {
SET(validated, VALIDATE_ERROR);
break;
}
m = sudoers_lookup_check(nss, ctx, &validated, &info, now, callback,
cb_data, &cs, &defs);
if (m != UNSPEC) {
match = m;
parse_tree = nss->parse_tree;
}
if (!sudo_nss_can_continue(nss, m))
break;
}
if (match != UNSPEC) {
if (info.cmnd_path != NULL) {
free(ctx->user.cmnd);
ctx->user.cmnd = info.cmnd_path;
if (ctx->user.cmnd_stat != NULL)
*ctx->user.cmnd_stat = info.cmnd_stat;
*cmnd_status = info.status;
}
if (defs != NULL)
(void)update_defaults(ctx, parse_tree, defs, SETDEF_GENERIC, false);
if (!apply_cmndspec(ctx, cs))
SET(validated, VALIDATE_ERROR);
else if (match == ALLOW)
SET(validated, VALIDATE_SUCCESS);
else
SET(validated, VALIDATE_FAILURE);
}
if (!restore_perms())
SET(validated, VALIDATE_ERROR);
debug_return_uint(validated);
}","unsigned int
sudoers_lookup(struct sudo_nss_list *VAR_0, struct sudoers_context *VAR_1,
time_t VAR_2, sudoers_lookup_callback_fn_t VAR_3, void *VAR_4,
int *VAR_5, int VAR_6)
{
struct defaults_list *VAR_7 = NULL;
struct sudoers_parse_tree *VAR_8 = NULL;
struct cmndspec *VAR_9 = NULL;
struct sudo_nss *VAR_10;
struct cmnd_info VAR_11;
unsigned int VAR_12 = VAR_13 | VAR_14;
int VAR_15, VAR_16 = VAR_17;
debug_decl(VAR_18, VAR_19);
if (VAR_6) {
debug_return_uint(sudoers_lookup_pseudo(VAR_0, VAR_1, VAR_2, VAR_3,
VAR_4, VAR_6));
}
if (!set_perms(VAR_1, VAR_20))
debug_return_uint(VAR_12);
TAILQ_FOREACH(VAR_10, VAR_0, VAR_21) {
if (VAR_10->query(VAR_1, VAR_10, VAR_1->user.pw) == -1) {
SET(VAR_12, VAR_22);
break;
}
VAR_15 = sudoers_lookup_check(VAR_10, VAR_1, &VAR_12, &VAR_11, VAR_2, VAR_3,
VAR_4, &VAR_9, &VAR_7);
if (VAR_15 != VAR_17) {
VAR_16 = VAR_15;
VAR_8 = VAR_10->parse_tree;
}
if (!sudo_nss_can_continue(VAR_10, VAR_15))
break;
}
if (VAR_16 != VAR_17) {
if (VAR_11.cmnd_path != NULL) {
free(VAR_1->user.cmnd);
VAR_1->user.cmnd = VAR_11.cmnd_path;
if (VAR_1->user.cmnd_stat != NULL)
*VAR_1->user.cmnd_stat = VAR_11.cmnd_stat;
*VAR_5 = VAR_11.status;
}
if (VAR_7 != NULL)
(void)update_defaults(VAR_1, VAR_8, VAR_7, VAR_23, false);
if (!apply_cmndspec(VAR_1, VAR_9))
SET(VAR_12, VAR_22);
else if (VAR_16 == VAR_24)
SET(VAR_12, VAR_25);
else
SET(VAR_12, VAR_26);
}
if (!restore_perms())
SET(VAR_12, VAR_22);
debug_return_uint(VAR_12);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/lookup.c/vul/before/2.json,"unsigned int
sudoers_lookup(struct sudo_nss_list *snl, struct sudoers_context *ctx,
    time_t now, sudoers_lookup_callback_fn_t callback, void *cb_data,
    int *cmnd_status, int pwflag)
{
    struct defaults_list *defs = NULL;
    struct sudoers_parse_tree *parse_tree = NULL;
    struct cmndspec *cs = NULL;
    struct sudo_nss *nss;
    struct cmnd_info info;
    unsigned int validated = FLAG_NO_USER | FLAG_NO_HOST;
    int m, match = UNSPEC;
    debug_decl(sudoers_lookup, SUDOERS_DEBUG_PARSER);

    /*
     * Special case checking the ""validate"", ""list"" and ""kill"" pseudo-commands.
     */
    if (pwflag) {
	debug_return_uint(sudoers_lookup_pseudo(snl, ctx, now, callback,
	    cb_data, pwflag));
    }

    /* Need to be runas user while stat'ing things. */
    if (!set_perms(ctx, PERM_RUNAS))
	debug_return_uint(validated);

    /* Query each sudoers source and check the user. */
    TAILQ_FOREACH(nss, snl, entries) {
	if (nss->query(ctx, nss, ctx->user.pw) == -1) {
	    /* The query function should have printed an error message. */
	    SET(validated, VALIDATE_ERROR);
	    break;
	}

	m = sudoers_lookup_check(nss, ctx, &validated, &info, now, callback,
	    cb_data, &cs, &defs);
	if (SPECIFIED(m)) {
	    match = m;
	    parse_tree = nss->parse_tree;
	}

	if (!sudo_nss_can_continue(nss, m))
	    break;
    }
    if (SPECIFIED(match)) {
	if (info.cmnd_path != NULL) {
	    /* Update cmnd, cmnd_stat, cmnd_status from matching entry. */
	    free(ctx->user.cmnd);
	    ctx->user.cmnd = info.cmnd_path;
	    if (ctx->user.cmnd_stat != NULL)
		*ctx->user.cmnd_stat = info.cmnd_stat;
	    *cmnd_status = info.status;
	}
	if (defs != NULL)
	    (void)update_defaults(ctx, parse_tree, defs, SETDEF_GENERIC, false);
	if (!apply_cmndspec(ctx, cs))
	    SET(validated, VALIDATE_ERROR);
	else if (match == ALLOW)
	    SET(validated, VALIDATE_SUCCESS);
	else
	    SET(validated, VALIDATE_FAILURE);
    }
    if (!restore_perms())
	SET(validated, VALIDATE_ERROR);
    debug_return_uint(validated);
}","unsigned int
sudoers_lookup(struct sudo_nss_list *VAR_0, struct sudoers_context *VAR_1,
    time_t VAR_2, sudoers_lookup_callback_fn_t VAR_3, void *VAR_4,
    int *VAR_5, int VAR_6)
{
    struct defaults_list *VAR_7 = NULL;
    struct sudoers_parse_tree *VAR_8 = NULL;
    struct cmndspec *VAR_9 = NULL;
    struct sudo_nss *VAR_10;
    struct cmnd_info VAR_11;
    unsigned int VAR_12 = VAR_13 | VAR_14;
    int VAR_15, VAR_16 = VAR_17;
    debug_decl(VAR_18, VAR_19);

    /* COMMENT_0 */
                                                                               
       
    if (VAR_6) {
	debug_return_uint(sudoers_lookup_pseudo(VAR_0, VAR_1, VAR_2, VAR_3,
	    VAR_4, VAR_6));
    }

    /* COMMENT_3 */
    if (!set_perms(VAR_1, VAR_20))
	debug_return_uint(VAR_12);

    /* COMMENT_4 */
    TAILQ_FOREACH(VAR_10, VAR_0, VAR_21) {
	if (VAR_10->query(VAR_1, VAR_10, VAR_1->user.pw) == -1) {
	    /* COMMENT_5 */
	    SET(VAR_12, VAR_22);
	    break;
	}

	VAR_15 = sudoers_lookup_check(VAR_10, VAR_1, &VAR_12, &VAR_11, VAR_2, VAR_3,
	    VAR_4, &VAR_9, &VAR_7);
	if (SPECIFIED(VAR_15)) {
	    VAR_16 = VAR_15;
	    VAR_8 = VAR_10->parse_tree;
	}

	if (!sudo_nss_can_continue(VAR_10, VAR_15))
	    break;
    }
    if (SPECIFIED(VAR_16)) {
	if (VAR_11.cmnd_path != NULL) {
	    /* COMMENT_6 */
	    free(VAR_1->user.cmnd);
	    VAR_1->user.cmnd = VAR_11.cmnd_path;
	    if (VAR_1->user.cmnd_stat != NULL)
		*VAR_1->user.cmnd_stat = VAR_11.cmnd_stat;
	    *VAR_5 = VAR_11.status;
	}
	if (VAR_7 != NULL)
	    (void)update_defaults(VAR_1, VAR_8, VAR_7, VAR_23, false);
	if (!apply_cmndspec(VAR_1, VAR_9))
	    SET(VAR_12, VAR_22);
	else if (VAR_16 == VAR_24)
	    SET(VAR_12, VAR_25);
	else
	    SET(VAR_12, VAR_26);
    }
    if (!restore_perms())
	SET(VAR_12, VAR_22);
    debug_return_uint(VAR_12);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/lookup.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -34,7 +34,7 @@
 
 	m = sudoers_lookup_check(nss, ctx, &validated, &info, now, callback,
 	    cb_data, &cs, &defs);
-	if (m != UNSPEC) {
+	if (SPECIFIED(m)) {
 	    match = m;
 	    parse_tree = nss->parse_tree;
 	}
@@ -42,7 +42,7 @@
 	if (!sudo_nss_can_continue(nss, m))
 	    break;
     }
-    if (match != UNSPEC) {
+    if (SPECIFIED(match)) {
 	if (info.cmnd_path != NULL) {
 	    /* Update cmnd, cmnd_stat, cmnd_status from matching entry. */
 	    free(ctx->user.cmnd);","{'deleted_lines': ['\tif (m != UNSPEC) {', '    if (match != UNSPEC) {'], 'added_lines': ['\tif (SPECIFIED(m)) {', '    if (SPECIFIED(match)) {']}",True,"Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.",7.0,HIGH,2,test,2023-09-09T20:07:04Z,4
CVE-2023-42465,['CWE-Other'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,sudo-project/sudo,"Try to make sudo less vulnerable to ROWHAMMER attacks.

We now use ROWHAMMER-resistent values for ALLOW, DENY, AUTH_SUCCESS,
AUTH_FAILURE, AUTH_ERROR and AUTH_NONINTERACTIVE.  In addition, we
explicitly test for expected values instead of using a negated test
against an error value.  In the parser match functions this means
explicitly checking for ALLOW or DENY instead of accepting anything
that is not set to UNSPEC.

Thanks to Andrew J. Adiletta, M. Caner Tol, Yarkin Doroz, and Berk
Sunar, all affiliated with the Vernam Applied Cryptography and
Cybersecurity Lab at Worcester Polytechnic Institute, for the report.
Paper preprint: https://arxiv.org/abs/2309.02545",7873f8334c8d31031f8cfa83bd97ac6029309e4f,https://github.com/sudo-project/sudo/commit/7873f8334c8d31031f8cfa83bd97ac6029309e4f,plugins/sudoers/match.c,cmnd_matches_all,"int
cmnd_matches_all(const struct sudoers_parse_tree *parse_tree,
const struct member *m, const char *runchroot, struct cmnd_info *info)
{
const bool negated = m->negated;
struct sudo_command *c;
int matched = UNSPEC;
struct alias *a;
debug_decl(cmnd_matches_all, SUDOERS_DEBUG_MATCH);
switch (m->type) {
case ALL:
c = (struct sudo_command *)m->name;
if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,
info, &c->digests))
matched = negated ? DENY : ALLOW;
break;
case ALIAS:
a = alias_get(parse_tree, m->name, CMNDALIAS);
if (a != NULL) {
TAILQ_FOREACH_REVERSE(m, &a->members, member_list, entries) {
matched = cmnd_matches_all(parse_tree, m, runchroot, info);
if (matched != UNSPEC) {
if (negated)
matched = matched == ALLOW ? DENY : ALLOW;
break;
}
}
alias_put(a);
}
break;
}
debug_return_int(matched);
}","int
cmnd_matches_all(const struct sudoers_parse_tree *VAR_0,
const struct member *VAR_1, const char *VAR_2, struct cmnd_info *VAR_3)
{
const bool VAR_4 = VAR_1->negated;
struct sudo_command *VAR_5;
int VAR_6 = VAR_7;
struct alias *VAR_8;
debug_decl(VAR_9, VAR_10);
switch (VAR_1->type) {
case VAR_11:
VAR_5 = (struct sudo_command *)VAR_1->name;
if (command_matches(VAR_0->ctx, VAR_5->cmnd, VAR_5->args, VAR_2,
VAR_3, &VAR_5->digests))
VAR_6 = VAR_4 ? VAR_12 : VAR_13;
break;
case VAR_14:
VAR_8 = alias_get(VAR_0, VAR_1->name, VAR_15);
if (VAR_8 != NULL) {
TAILQ_FOREACH_REVERSE(VAR_1, &VAR_8->members, VAR_16, VAR_17) {
VAR_6 = VAR_9(VAR_0, VAR_1, VAR_2, VAR_3);
if (VAR_6 != VAR_7) {
if (VAR_4)
VAR_6 = VAR_6 == VAR_13 ? VAR_12 : VAR_13;
break;
}
}
alias_put(VAR_8);
}
break;
}
debug_return_int(VAR_6);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/match.c/vul/before/2.json,"int
cmnd_matches_all(const struct sudoers_parse_tree *parse_tree,
    const struct member *m, const char *runchroot, struct cmnd_info *info)
{
    const bool negated = m->negated;
    struct sudo_command *c;
    int matched = UNSPEC;
    struct alias *a;
    debug_decl(cmnd_matches_all, SUDOERS_DEBUG_MATCH);

    switch (m->type) {
	case ALL:
	    c = (struct sudo_command *)m->name;
	    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,
		    info, &c->digests))
		matched = negated ? DENY : ALLOW;
	    break;
	case ALIAS:
	    a = alias_get(parse_tree, m->name, CMNDALIAS);
	    if (a != NULL) {
		TAILQ_FOREACH_REVERSE(m, &a->members, member_list, entries) {
		    matched = cmnd_matches_all(parse_tree, m, runchroot, info);
		    if (SPECIFIED(matched)) {
			if (negated)
			    matched = matched == ALLOW ? DENY : ALLOW;
			break;
		    }
		}
		alias_put(a);
	    }
	    break;
    }
    debug_return_int(matched);
}","int
cmnd_matches_all(const struct sudoers_parse_tree *VAR_0,
    const struct member *VAR_1, const char *VAR_2, struct cmnd_info *VAR_3)
{
    const bool VAR_4 = VAR_1->negated;
    struct sudo_command *VAR_5;
    int VAR_6 = VAR_7;
    struct alias *VAR_8;
    debug_decl(VAR_9, VAR_10);

    switch (VAR_1->type) {
	case VAR_11:
	    VAR_5 = (struct sudo_command *)VAR_1->name;
	    if (command_matches(VAR_0->ctx, VAR_5->cmnd, VAR_5->args, VAR_2,
		    VAR_3, &VAR_5->digests))
		VAR_6 = VAR_4 ? VAR_12 : VAR_13;
	    break;
	case VAR_14:
	    VAR_8 = alias_get(VAR_0, VAR_1->name, VAR_15);
	    if (VAR_8 != NULL) {
		TAILQ_FOREACH_REVERSE(VAR_1, &VAR_8->members, VAR_16, VAR_17) {
		    VAR_6 = VAR_9(VAR_0, VAR_1, VAR_2, VAR_3);
		    if (SPECIFIED(VAR_6)) {
			if (VAR_4)
			    VAR_6 = VAR_6 == VAR_13 ? VAR_12 : VAR_13;
			break;
		    }
		}
		alias_put(VAR_8);
	    }
	    break;
    }
    debug_return_int(VAR_6);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/match.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -20,7 +20,7 @@
 	    if (a != NULL) {
 		TAILQ_FOREACH_REVERSE(m, &a->members, member_list, entries) {
 		    matched = cmnd_matches_all(parse_tree, m, runchroot, info);
-		    if (matched != UNSPEC) {
+		    if (SPECIFIED(matched)) {
 			if (negated)
 			    matched = matched == ALLOW ? DENY : ALLOW;
 			break;","{'deleted_lines': ['\t\t    if (matched != UNSPEC) {'], 'added_lines': ['\t\t    if (SPECIFIED(matched)) {']}",True,"Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.",7.0,HIGH,2,test,2023-09-09T20:07:04Z,4
CVE-2023-42465,['CWE-Other'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,sudo-project/sudo,"Try to make sudo less vulnerable to ROWHAMMER attacks.

We now use ROWHAMMER-resistent values for ALLOW, DENY, AUTH_SUCCESS,
AUTH_FAILURE, AUTH_ERROR and AUTH_NONINTERACTIVE.  In addition, we
explicitly test for expected values instead of using a negated test
against an error value.  In the parser match functions this means
explicitly checking for ALLOW or DENY instead of accepting anything
that is not set to UNSPEC.

Thanks to Andrew J. Adiletta, M. Caner Tol, Yarkin Doroz, and Berk
Sunar, all affiliated with the Vernam Applied Cryptography and
Cybersecurity Lab at Worcester Polytechnic Institute, for the report.
Paper preprint: https://arxiv.org/abs/2309.02545",7873f8334c8d31031f8cfa83bd97ac6029309e4f,https://github.com/sudo-project/sudo/commit/7873f8334c8d31031f8cfa83bd97ac6029309e4f,plugins/sudoers/match.c,cmndlist_matches,"int
cmndlist_matches(const struct sudoers_parse_tree *parse_tree,
const struct member_list *list, const char *runchroot,
struct cmnd_info *info)
{
struct member *m;
int matched = UNSPEC;
debug_decl(cmndlist_matches, SUDOERS_DEBUG_MATCH);
TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {
matched = cmnd_matches(parse_tree, m, runchroot, info);
if (matched != UNSPEC)
break;
}
debug_return_int(matched);
}","int
cmndlist_matches(const struct sudoers_parse_tree *VAR_0,
const struct member_list *VAR_1, const char *VAR_2,
struct cmnd_info *VAR_3)
{
struct member *VAR_4;
int VAR_5 = VAR_6;
debug_decl(VAR_7, VAR_8);
TAILQ_FOREACH_REVERSE(VAR_4, VAR_1, member_list, VAR_9) {
VAR_5 = cmnd_matches(VAR_0, VAR_4, VAR_2, VAR_3);
if (VAR_5 != VAR_6)
break;
}
debug_return_int(VAR_5);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/match.c/vul/before/4.json,"int
cmndlist_matches(const struct sudoers_parse_tree *parse_tree,
    const struct member_list *list, const char *runchroot,
    struct cmnd_info *info)
{
    struct member *m;
    int matched = UNSPEC;
    debug_decl(cmndlist_matches, SUDOERS_DEBUG_MATCH);

    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {
	matched = cmnd_matches(parse_tree, m, runchroot, info);
	if (SPECIFIED(matched))
	    break;
    }
    debug_return_int(matched);
}","int
cmndlist_matches(const struct sudoers_parse_tree *VAR_0,
    const struct member_list *VAR_1, const char *VAR_2,
    struct cmnd_info *VAR_3)
{
    struct member *VAR_4;
    int VAR_5 = VAR_6;
    debug_decl(VAR_7, VAR_8);

    TAILQ_FOREACH_REVERSE(VAR_4, VAR_1, member_list, VAR_9) {
	VAR_5 = cmnd_matches(VAR_0, VAR_4, VAR_2, VAR_3);
	if (SPECIFIED(VAR_5))
	    break;
    }
    debug_return_int(VAR_5);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/match.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -9,7 +9,7 @@
 
     TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {
 	matched = cmnd_matches(parse_tree, m, runchroot, info);
-	if (matched != UNSPEC)
+	if (SPECIFIED(matched))
 	    break;
     }
     debug_return_int(matched);","{'deleted_lines': ['\tif (matched != UNSPEC)'], 'added_lines': ['\tif (SPECIFIED(matched))']}",True,"Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.",7.0,HIGH,2,test,2023-09-09T20:07:04Z,4
CVE-2023-42465,['CWE-Other'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,sudo-project/sudo,"Try to make sudo less vulnerable to ROWHAMMER attacks.

We now use ROWHAMMER-resistent values for ALLOW, DENY, AUTH_SUCCESS,
AUTH_FAILURE, AUTH_ERROR and AUTH_NONINTERACTIVE.  In addition, we
explicitly test for expected values instead of using a negated test
against an error value.  In the parser match functions this means
explicitly checking for ALLOW or DENY instead of accepting anything
that is not set to UNSPEC.

Thanks to Andrew J. Adiletta, M. Caner Tol, Yarkin Doroz, and Berk
Sunar, all affiliated with the Vernam Applied Cryptography and
Cybersecurity Lab at Worcester Polytechnic Institute, for the report.
Paper preprint: https://arxiv.org/abs/2309.02545",7873f8334c8d31031f8cfa83bd97ac6029309e4f,https://github.com/sudo-project/sudo/commit/7873f8334c8d31031f8cfa83bd97ac6029309e4f,plugins/sudoers/match.c,hostlist_matches_int,"static int
hostlist_matches_int(const struct sudoers_parse_tree *parse_tree,
const struct passwd *pw, const char *lhost, const char *shost,
const struct member_list *list)
{
struct member *m;
int matched = UNSPEC;
debug_decl(hostlist_matches, SUDOERS_DEBUG_MATCH);
TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {
matched = host_matches(parse_tree, pw, lhost, shost, m);
if (matched != UNSPEC)
break;
}
debug_return_int(matched);
}","static int
hostlist_matches_int(const struct sudoers_parse_tree *VAR_0,
const struct passwd *VAR_1, const char *VAR_2, const char *VAR_3,
const struct member_list *VAR_4)
{
struct member *VAR_5;
int VAR_6 = VAR_7;
debug_decl(VAR_8, VAR_9);
TAILQ_FOREACH_REVERSE(VAR_5, VAR_4, member_list, VAR_10) {
VAR_6 = host_matches(VAR_0, VAR_1, VAR_2, VAR_3, VAR_5);
if (VAR_6 != VAR_7)
break;
}
debug_return_int(VAR_6);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/match.c/vul/before/3.json,"static int
hostlist_matches_int(const struct sudoers_parse_tree *parse_tree,
    const struct passwd *pw, const char *lhost, const char *shost,
    const struct member_list *list)
{
    struct member *m;
    int matched = UNSPEC;
    debug_decl(hostlist_matches, SUDOERS_DEBUG_MATCH);

    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {
	matched = host_matches(parse_tree, pw, lhost, shost, m);
	if (SPECIFIED(matched))
	    break;
    }
    debug_return_int(matched);
}","static int
hostlist_matches_int(const struct sudoers_parse_tree *VAR_0,
    const struct passwd *VAR_1, const char *VAR_2, const char *VAR_3,
    const struct member_list *VAR_4)
{
    struct member *VAR_5;
    int VAR_6 = VAR_7;
    debug_decl(VAR_8, VAR_9);

    TAILQ_FOREACH_REVERSE(VAR_5, VAR_4, member_list, VAR_10) {
	VAR_6 = host_matches(VAR_0, VAR_1, VAR_2, VAR_3, VAR_5);
	if (SPECIFIED(VAR_6))
	    break;
    }
    debug_return_int(VAR_6);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/match.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -9,7 +9,7 @@
 
     TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {
 	matched = host_matches(parse_tree, pw, lhost, shost, m);
-	if (matched != UNSPEC)
+	if (SPECIFIED(matched))
 	    break;
     }
     debug_return_int(matched);","{'deleted_lines': ['\tif (matched != UNSPEC)'], 'added_lines': ['\tif (SPECIFIED(matched))']}",True,"Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.",7.0,HIGH,2,test,2023-09-09T20:07:04Z,4
CVE-2023-42465,['CWE-Other'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,sudo-project/sudo,"Try to make sudo less vulnerable to ROWHAMMER attacks.

We now use ROWHAMMER-resistent values for ALLOW, DENY, AUTH_SUCCESS,
AUTH_FAILURE, AUTH_ERROR and AUTH_NONINTERACTIVE.  In addition, we
explicitly test for expected values instead of using a negated test
against an error value.  In the parser match functions this means
explicitly checking for ALLOW or DENY instead of accepting anything
that is not set to UNSPEC.

Thanks to Andrew J. Adiletta, M. Caner Tol, Yarkin Doroz, and Berk
Sunar, all affiliated with the Vernam Applied Cryptography and
Cybersecurity Lab at Worcester Polytechnic Institute, for the report.
Paper preprint: https://arxiv.org/abs/2309.02545",7873f8334c8d31031f8cfa83bd97ac6029309e4f,https://github.com/sudo-project/sudo/commit/7873f8334c8d31031f8cfa83bd97ac6029309e4f,plugins/sudoers/lookup.c,sudoers_lookup_pseudo,"static unsigned int
sudoers_lookup_pseudo(struct sudo_nss_list *snl, struct sudoers_context *ctx,
time_t now, sudoers_lookup_callback_fn_t callback, void *cb_data,
int pwflag)
{
char *saved_runchroot;
struct passwd *root_pw = NULL;
struct sudo_nss *nss;
struct cmndspec *cs;
struct privilege *priv;
struct userspec *us;
struct defaults *def;
int nopass, match = DENY;
unsigned int validated = 0;
enum def_tuple pwcheck;
debug_decl(sudoers_lookup_pseudo, SUDOERS_DEBUG_PARSER);
pwcheck = (pwflag == -1) ? never : sudo_defs_table[pwflag].sd_un.tuple;
nopass = (pwcheck == never || pwcheck == all) ? true : false;
if (ctx->runas.list_pw != NULL) {
root_pw = sudo_getpwuid(ROOT_UID);
if (root_pw == NULL)
sudo_warnx(U_(""unknown uid %u""), ROOT_UID);
} else {
SET(validated, FLAG_NO_CHECK);
}
saved_runchroot = def_runchroot;
def_runchroot = NULL;
TAILQ_FOREACH(nss, snl, entries) {
if (nss->query(ctx, nss, ctx->user.pw) == -1) {
SET(validated, VALIDATE_ERROR);
break;
}
TAILQ_FOREACH(us, &nss->parse_tree->userspecs, entries) {
int user_match = userlist_matches(nss->parse_tree, ctx->user.pw,
&us->users);
if (user_match != ALLOW) {
if (callback != NULL && user_match != UNSPEC) {
callback(nss->parse_tree, us, user_match, NULL, UNSPEC,
NULL, UNSPEC, UNSPEC, UNSPEC, cb_data);
}
continue;
}
TAILQ_FOREACH(priv, &us->privileges, entries) {
int priv_nopass = UNSPEC;
int host_match = hostlist_matches(nss->parse_tree, ctx->user.pw,
&priv->hostlist);
if (host_match != ALLOW) {
if (callback != NULL) {
callback(nss->parse_tree, us, user_match, priv,
host_match, NULL, UNSPEC, UNSPEC, UNSPEC, cb_data);
}
continue;
}
TAILQ_FOREACH(def, &priv->defaults, entries) {
if (strcmp(def->var, ""authenticate"") == 0) {
priv_nopass = !def->op;
break;
}
}
TAILQ_FOREACH(cs, &priv->cmndlist, entries) {
int cmnd_match = UNSPEC;
int date_match = UNSPEC;
int runas_match = UNSPEC;
if (pwcheck == any) {
if (cs->tags.nopasswd == true || priv_nopass == true)
nopass = true;
} else if (pwcheck == all) {
if (cs->tags.nopasswd != true && priv_nopass != true)
nopass = false;
}
if (cs->notbefore != UNSPEC) {
date_match = now < cs->notbefore ? DENY : ALLOW;
}
if (cs->notafter != UNSPEC) {
date_match = now > cs->notafter ? DENY : ALLOW;
}
if (ctx->user.uid == 0 || ctx->runas.list_pw == NULL ||
ctx->user.uid == ctx->runas.list_pw->pw_uid) {
cmnd_match = ALLOW;
runas_match = ALLOW;
} else if (date_match != DENY) {
runas_match = runas_matches_pw(nss->parse_tree, cs,
ctx->runas.list_pw);
switch (runas_match) {
case DENY:
break;
case ALLOW:
cmnd_match = cmnd_matches(nss->parse_tree,
cs->cmnd, cs->runchroot, NULL);
break;
default:
if (root_pw != NULL &&
runas_matches_pw(nss->parse_tree, cs,
root_pw) == ALLOW) {
runas_match = ALLOW;
cmnd_match = cmnd_matches_all(nss->parse_tree,
cs->cmnd, cs->runchroot, NULL);
}
break;
}
}
if (callback != NULL) {
callback(nss->parse_tree, us, user_match, priv,
host_match, cs, date_match, runas_match,
cmnd_match, cb_data);
}
if (cmnd_match != UNSPEC) {
match = cmnd_match;
}
}
}
}
if (!sudo_nss_can_continue(nss, match))
break;
}
if (root_pw != NULL)
sudo_pw_delref(root_pw);
if (match == ALLOW || ctx->user.uid == 0) {
SET(validated, VALIDATE_SUCCESS);
} else if (match == DENY)
SET(validated, VALIDATE_FAILURE);
if (pwcheck == always && def_authenticate)
SET(validated, FLAG_CHECK_USER);
else if (nopass == true)
def_authenticate = false;
def_runchroot = saved_runchroot;
debug_return_uint(validated);
}","static unsigned int
sudoers_lookup_pseudo(struct sudo_nss_list *VAR_0, struct sudoers_context *VAR_1,
time_t VAR_2, sudoers_lookup_callback_fn_t VAR_3, void *VAR_4,
int VAR_5)
{
char *VAR_6;
struct passwd *VAR_7 = NULL;
struct sudo_nss *VAR_8;
struct cmndspec *VAR_9;
struct privilege *VAR_10;
struct userspec *VAR_11;
struct defaults *VAR_12;
int VAR_13, VAR_14 = VAR_15;
unsigned int VAR_16 = 0;
enum def_tuple VAR_17;
debug_decl(VAR_18, VAR_19);
VAR_17 = (VAR_5 == -1) ? VAR_20 : VAR_21[VAR_5].sd_un.tuple;
VAR_13 = (VAR_17 == VAR_20 || VAR_17 == VAR_22) ? true : false;
if (VAR_1->runas.list_pw != NULL) {
VAR_7 = sudo_getpwuid(VAR_23);
if (VAR_7 == NULL)
sudo_warnx(U_(""unknown uid %u""), VAR_23);
} else {
SET(VAR_16, VAR_24);
}
VAR_6 = VAR_25;
VAR_25 = NULL;
TAILQ_FOREACH(VAR_8, VAR_0, VAR_26) {
if (VAR_8->query(VAR_1, VAR_8, VAR_1->user.pw) == -1) {
SET(VAR_16, VAR_27);
break;
}
TAILQ_FOREACH(VAR_11, &VAR_8->parse_tree->userspecs, VAR_26) {
int VAR_28 = userlist_matches(VAR_8->parse_tree, VAR_1->user.pw,
&VAR_11->users);
if (VAR_28 != VAR_29) {
if (VAR_3 != NULL && VAR_28 != VAR_30) {
VAR_3(VAR_8->parse_tree, VAR_11, VAR_28, NULL, VAR_30,
NULL, VAR_30, VAR_30, VAR_30, VAR_4);
}
continue;
}
TAILQ_FOREACH(VAR_10, &VAR_11->privileges, VAR_26) {
int VAR_31 = VAR_30;
int VAR_32 = hostlist_matches(VAR_8->parse_tree, VAR_1->user.pw,
&VAR_10->hostlist);
if (VAR_32 != VAR_29) {
if (VAR_3 != NULL) {
VAR_3(VAR_8->parse_tree, VAR_11, VAR_28, VAR_10,
VAR_32, NULL, VAR_30, VAR_30, VAR_30, VAR_4);
}
continue;
}
TAILQ_FOREACH(VAR_12, &VAR_10->defaults, VAR_26) {
if (strcmp(VAR_12->var, ""authenticate"") == 0) {
VAR_31 = !VAR_12->op;
break;
}
}
TAILQ_FOREACH(VAR_9, &VAR_10->cmndlist, VAR_26) {
int VAR_33 = VAR_30;
int VAR_34 = VAR_30;
int VAR_35 = VAR_30;
if (VAR_17 == VAR_36) {
if (VAR_9->tags.nopasswd == true || VAR_31 == true)
VAR_13 = true;
} else if (VAR_17 == VAR_22) {
if (VAR_9->tags.nopasswd != true && VAR_31 != true)
VAR_13 = false;
}
if (VAR_9->notbefore != VAR_30) {
VAR_34 = VAR_2 < VAR_9->notbefore ? VAR_15 : VAR_29;
}
if (VAR_9->notafter != VAR_30) {
VAR_34 = VAR_2 > VAR_9->notafter ? VAR_15 : VAR_29;
}
if (VAR_1->user.uid == 0 || VAR_1->runas.list_pw == NULL ||
VAR_1->user.uid == VAR_1->runas.list_pw->pw_uid) {
VAR_33 = VAR_29;
VAR_35 = VAR_29;
} else if (VAR_34 != VAR_15) {
VAR_35 = runas_matches_pw(VAR_8->parse_tree, VAR_9,
VAR_1->runas.list_pw);
switch (VAR_35) {
case VAR_15:
break;
case VAR_29:
VAR_33 = cmnd_matches(VAR_8->parse_tree,
VAR_9->cmnd, VAR_9->runchroot, NULL);
break;
default:
if (VAR_7 != NULL &&
runas_matches_pw(VAR_8->parse_tree, VAR_9,
VAR_7) == VAR_29) {
VAR_35 = VAR_29;
VAR_33 = cmnd_matches_all(VAR_8->parse_tree,
VAR_9->cmnd, VAR_9->runchroot, NULL);
}
break;
}
}
if (VAR_3 != NULL) {
VAR_3(VAR_8->parse_tree, VAR_11, VAR_28, VAR_10,
VAR_32, VAR_9, VAR_34, VAR_35,
VAR_33, VAR_4);
}
if (VAR_33 != VAR_30) {
VAR_14 = VAR_33;
}
}
}
}
if (!sudo_nss_can_continue(VAR_8, VAR_14))
break;
}
if (VAR_7 != NULL)
sudo_pw_delref(VAR_7);
if (VAR_14 == VAR_29 || VAR_1->user.uid == 0) {
SET(VAR_16, VAR_37);
} else if (VAR_14 == VAR_15)
SET(VAR_16, VAR_38);
if (VAR_17 == VAR_39 && VAR_40)
SET(VAR_16, VAR_41);
else if (VAR_13 == true)
VAR_40 = false;
VAR_25 = VAR_6;
debug_return_uint(VAR_16);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/lookup.c/vul/before/0.json,"static unsigned int
sudoers_lookup_pseudo(struct sudo_nss_list *snl, struct sudoers_context *ctx,
    time_t now, sudoers_lookup_callback_fn_t callback, void *cb_data,
    int pwflag)
{
    char *saved_runchroot;
    struct passwd *root_pw = NULL;
    struct sudo_nss *nss;
    struct cmndspec *cs;
    struct privilege *priv;
    struct userspec *us;
    struct defaults *def;
    int nopass, match = DENY;
    unsigned int validated = 0;
    enum def_tuple pwcheck;
    debug_decl(sudoers_lookup_pseudo, SUDOERS_DEBUG_PARSER);

    pwcheck = (pwflag == -1) ? never : sudo_defs_table[pwflag].sd_un.tuple;
    nopass = (pwcheck == never || pwcheck == all) ? true : false;

    if (ctx->runas.list_pw != NULL) {
	root_pw = sudo_getpwuid(ROOT_UID);
	if (root_pw == NULL)
	    sudo_warnx(U_(""unknown uid %u""), ROOT_UID);
    } else {
	SET(validated, FLAG_NO_CHECK);
    }

    /* Don't use chroot setting for pseudo-commands. */
    saved_runchroot = def_runchroot;
    def_runchroot = NULL;

    TAILQ_FOREACH(nss, snl, entries) {
	if (nss->query(ctx, nss, ctx->user.pw) == -1) {
	    /* The query function should have printed an error message. */
	    SET(validated, VALIDATE_ERROR);
	    break;
	}

	/*
	 * We have to traverse the policy forwards, not in reverse,
	 * to support the ""pwcheck == all"" case.
	 */
	TAILQ_FOREACH(us, &nss->parse_tree->userspecs, entries) {
	    int user_match = userlist_matches(nss->parse_tree, ctx->user.pw,
		&us->users);
	    if (user_match != ALLOW) {
		if (callback != NULL && user_match == DENY) {
		    callback(nss->parse_tree, us, user_match, NULL, UNSPEC,
			NULL, UNSPEC, UNSPEC, UNSPEC, cb_data);
		}
		continue;
	    }
	    TAILQ_FOREACH(priv, &us->privileges, entries) {
		int priv_nopass = UNSPEC;
		int host_match = hostlist_matches(nss->parse_tree, ctx->user.pw,
		    &priv->hostlist);
		if (host_match != ALLOW) {
		    if (callback != NULL) {
			callback(nss->parse_tree, us, user_match, priv,
			    host_match, NULL, UNSPEC, UNSPEC, UNSPEC, cb_data);
		    }
		    continue;
		}
		TAILQ_FOREACH(def, &priv->defaults, entries) {
		    if (strcmp(def->var, ""authenticate"") == 0) {
			priv_nopass = !def->op;
			break;
		    }
		}
		TAILQ_FOREACH(cs, &priv->cmndlist, entries) {
		    int cmnd_match = UNSPEC;
		    int date_match = UNSPEC;
		    int runas_match = UNSPEC;

		    if (pwcheck == any) {
			if (cs->tags.nopasswd == true || priv_nopass == true)
			    nopass = true;
		    } else if (pwcheck == all) {
			if (cs->tags.nopasswd != true && priv_nopass != true)
			    nopass = false;
		    }

		    if (cs->notbefore != UNSPEC) {
			date_match = now < cs->notbefore ? DENY : ALLOW;
		    }
		    if (cs->notafter != UNSPEC) {
			date_match = now > cs->notafter ? DENY : ALLOW;
		    }
		    /*
		     * Root can list any user's privileges.
		     * A user may always list their own privileges.
		     */
		    if (ctx->user.uid == 0 || ctx->runas.list_pw == NULL ||
			    ctx->user.uid == ctx->runas.list_pw->pw_uid) {
			cmnd_match = ALLOW;
			runas_match = ALLOW;
		    } else if (date_match != DENY) {
			/*
			 * To list another user's prilileges, the runas
			 * user must match the list user or root.
			 */
			runas_match = runas_matches_pw(nss->parse_tree, cs,
			    ctx->runas.list_pw);
			switch (runas_match) {
			case DENY:
			    break;
			case ALLOW:
			    /*
			     * RunAs user matches list user.
			     * Match on command ""list"" or ALL.
			     */
			    cmnd_match = cmnd_matches(nss->parse_tree,
				cs->cmnd, cs->runchroot, NULL);
			    break;
			default:
			    /*
			     * RunAs user doesn't match list user.
			     * Only allow listing if the user has
			     * ""sudo ALL"" for root.
			     */
			    if (root_pw != NULL &&
				    runas_matches_pw(nss->parse_tree, cs,
				    root_pw) == ALLOW) {
				runas_match = ALLOW;
				cmnd_match = cmnd_matches_all(nss->parse_tree,
				    cs->cmnd, cs->runchroot, NULL);
			    }
			    break;
			}
		    }
		    if (callback != NULL) {
			callback(nss->parse_tree, us, user_match, priv,
			    host_match, cs, date_match, runas_match,
			    cmnd_match, cb_data);
		    }
		    if (SPECIFIED(cmnd_match)) {
			/*
			 * We take the last match but must process
			 * the entire policy for pwcheck == all.
			 */
			match = cmnd_match;
		    }
		}
	    }
	}
	if (!sudo_nss_can_continue(nss, match))
	    break;
    }
    if (root_pw != NULL)
	sudo_pw_delref(root_pw);
    if (match == ALLOW || ctx->user.uid == 0) {
	/* User has an entry for this host. */
	SET(validated, VALIDATE_SUCCESS);
    } else if (match == DENY)
	SET(validated, VALIDATE_FAILURE);
    if (pwcheck == always && def_authenticate)
	SET(validated, FLAG_CHECK_USER);
    else if (nopass == true)
	def_authenticate = false;

    /* Restore original def_runchroot. */
    def_runchroot = saved_runchroot;

    debug_return_uint(validated);
}","static unsigned int
sudoers_lookup_pseudo(struct sudo_nss_list *VAR_0, struct sudoers_context *VAR_1,
    time_t VAR_2, sudoers_lookup_callback_fn_t VAR_3, void *VAR_4,
    int VAR_5)
{
    char *VAR_6;
    struct passwd *VAR_7 = NULL;
    struct sudo_nss *VAR_8;
    struct cmndspec *VAR_9;
    struct privilege *VAR_10;
    struct userspec *VAR_11;
    struct defaults *VAR_12;
    int VAR_13, VAR_14 = VAR_15;
    unsigned int VAR_16 = 0;
    enum def_tuple VAR_17;
    debug_decl(VAR_18, VAR_19);

    VAR_17 = (VAR_5 == -1) ? VAR_20 : VAR_21[VAR_5].sd_un.tuple;
    VAR_13 = (VAR_17 == VAR_20 || VAR_17 == VAR_22) ? true : false;

    if (VAR_1->runas.list_pw != NULL) {
	VAR_7 = sudo_getpwuid(VAR_23);
	if (VAR_7 == NULL)
	    sudo_warnx(U_(""unknown uid %u""), VAR_23);
    } else {
	SET(VAR_16, VAR_24);
    }

    /* COMMENT_0 */
    VAR_6 = VAR_25;
    VAR_25 = NULL;

    TAILQ_FOREACH(VAR_8, VAR_0, VAR_26) {
	if (VAR_8->query(VAR_1, VAR_8, VAR_1->user.pw) == -1) {
	    /* COMMENT_1 */
	    SET(VAR_16, VAR_27);
	    break;
	}

	/* COMMENT_2 */
                                                            
                                         
    
	TAILQ_FOREACH(VAR_11, &VAR_8->parse_tree->userspecs, VAR_26) {
	    int VAR_28 = userlist_matches(VAR_8->parse_tree, VAR_1->user.pw,
		&VAR_11->users);
	    if (VAR_28 != VAR_29) {
		if (VAR_3 != NULL && VAR_28 == VAR_15) {
		    VAR_3(VAR_8->parse_tree, VAR_11, VAR_28, NULL, VAR_30,
			NULL, VAR_30, VAR_30, VAR_30, VAR_4);
		}
		continue;
	    }
	    TAILQ_FOREACH(VAR_10, &VAR_11->privileges, VAR_26) {
		int VAR_31 = VAR_30;
		int VAR_32 = hostlist_matches(VAR_8->parse_tree, VAR_1->user.pw,
		    &VAR_10->hostlist);
		if (VAR_32 != VAR_29) {
		    if (VAR_3 != NULL) {
			VAR_3(VAR_8->parse_tree, VAR_11, VAR_28, VAR_10,
			    VAR_32, NULL, VAR_30, VAR_30, VAR_30, VAR_4);
		    }
		    continue;
		}
		TAILQ_FOREACH(VAR_12, &VAR_10->defaults, VAR_26) {
		    if (strcmp(VAR_12->var, ""authenticate"") == 0) {
			VAR_31 = !VAR_12->op;
			break;
		    }
		}
		TAILQ_FOREACH(VAR_9, &VAR_10->cmndlist, VAR_26) {
		    int VAR_33 = VAR_30;
		    int VAR_34 = VAR_30;
		    int VAR_35 = VAR_30;

		    if (VAR_17 == VAR_36) {
			if (VAR_9->tags.nopasswd == true || VAR_31 == true)
			    VAR_13 = true;
		    } else if (VAR_17 == VAR_22) {
			if (VAR_9->tags.nopasswd != true && VAR_31 != true)
			    VAR_13 = false;
		    }

		    if (VAR_9->notbefore != VAR_30) {
			VAR_34 = VAR_2 < VAR_9->notbefore ? VAR_15 : VAR_29;
		    }
		    if (VAR_9->notafter != VAR_30) {
			VAR_34 = VAR_2 > VAR_9->notafter ? VAR_15 : VAR_29;
		    }
		    /* COMMENT_6 */
                                             
                                                     
         
		    if (VAR_1->user.uid == 0 || VAR_1->runas.list_pw == NULL ||
			    VAR_1->user.uid == VAR_1->runas.list_pw->pw_uid) {
			VAR_33 = VAR_29;
			VAR_35 = VAR_29;
		    } else if (VAR_34 != VAR_15) {
			/* COMMENT_10 */
                                                  
                                            
      
			VAR_35 = runas_matches_pw(VAR_8->parse_tree, VAR_9,
			    VAR_1->runas.list_pw);
			switch (VAR_35) {
			case VAR_15:
			    break;
			case VAR_29:
			    /* COMMENT_14 */
                                       
                                         
          
			    VAR_33 = cmnd_matches(VAR_8->parse_tree,
				VAR_9->cmnd, VAR_9->runchroot, NULL);
			    break;
			default:
			    /* COMMENT_18 */
                                             
                                            
                              
          
			    if (VAR_7 != NULL &&
				    runas_matches_pw(VAR_8->parse_tree, VAR_9,
				    VAR_7) == VAR_29) {
				VAR_35 = VAR_29;
				VAR_33 = cmnd_matches_all(VAR_8->parse_tree,
				    VAR_9->cmnd, VAR_9->runchroot, NULL);
			    }
			    break;
			}
		    }
		    if (VAR_3 != NULL) {
			VAR_3(VAR_8->parse_tree, VAR_11, VAR_28, VAR_10,
			    VAR_32, VAR_9, VAR_34, VAR_35,
			    VAR_33, VAR_4);
		    }
		    if (SPECIFIED(VAR_33)) {
			/* COMMENT_23 */
                                             
                                           
      
			VAR_14 = VAR_33;
		    }
		}
	    }
	}
	if (!sudo_nss_can_continue(VAR_8, VAR_14))
	    break;
    }
    if (VAR_7 != NULL)
	sudo_pw_delref(VAR_7);
    if (VAR_14 == VAR_29 || VAR_1->user.uid == 0) {
	/* COMMENT_27 */
	SET(VAR_16, VAR_37);
    } else if (VAR_14 == VAR_15)
	SET(VAR_16, VAR_38);
    if (VAR_17 == VAR_39 && VAR_40)
	SET(VAR_16, VAR_41);
    else if (VAR_13 == true)
	VAR_40 = false;

    /* COMMENT_28 */
    VAR_25 = VAR_6;

    debug_return_uint(VAR_16);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/lookup.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -45,7 +45,7 @@
 	    int user_match = userlist_matches(nss->parse_tree, ctx->user.pw,
 		&us->users);
 	    if (user_match != ALLOW) {
-		if (callback != NULL && user_match != UNSPEC) {
+		if (callback != NULL && user_match == DENY) {
 		    callback(nss->parse_tree, us, user_match, NULL, UNSPEC,
 			NULL, UNSPEC, UNSPEC, UNSPEC, cb_data);
 		}
@@ -134,7 +134,7 @@
 			    host_match, cs, date_match, runas_match,
 			    cmnd_match, cb_data);
 		    }
-		    if (cmnd_match != UNSPEC) {
+		    if (SPECIFIED(cmnd_match)) {
 			/*
 			 * We take the last match but must process
 			 * the entire policy for pwcheck == all.","{'deleted_lines': ['\t\tif (callback != NULL && user_match != UNSPEC) {', '\t\t    if (cmnd_match != UNSPEC) {'], 'added_lines': ['\t\tif (callback != NULL && user_match == DENY) {', '\t\t    if (SPECIFIED(cmnd_match)) {']}",True,"Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.",7.0,HIGH,2,test,2023-09-09T20:07:04Z,4
CVE-2023-42465,['CWE-Other'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,sudo-project/sudo,"Try to make sudo less vulnerable to ROWHAMMER attacks.

We now use ROWHAMMER-resistent values for ALLOW, DENY, AUTH_SUCCESS,
AUTH_FAILURE, AUTH_ERROR and AUTH_NONINTERACTIVE.  In addition, we
explicitly test for expected values instead of using a negated test
against an error value.  In the parser match functions this means
explicitly checking for ALLOW or DENY instead of accepting anything
that is not set to UNSPEC.

Thanks to Andrew J. Adiletta, M. Caner Tol, Yarkin Doroz, and Berk
Sunar, all affiliated with the Vernam Applied Cryptography and
Cybersecurity Lab at Worcester Polytechnic Institute, for the report.
Paper preprint: https://arxiv.org/abs/2309.02545",7873f8334c8d31031f8cfa83bd97ac6029309e4f,https://github.com/sudo-project/sudo/commit/7873f8334c8d31031f8cfa83bd97ac6029309e4f,plugins/sudoers/match.c,userlist_matches,"int
userlist_matches(const struct sudoers_parse_tree *parse_tree,
const struct passwd *pw, const struct member_list *list)
{
struct member *m;
int matched = UNSPEC;
debug_decl(userlist_matches, SUDOERS_DEBUG_MATCH);
TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {
if ((matched = user_matches(parse_tree, pw, m)) != UNSPEC)
break;
}
debug_return_int(matched);
}","int
userlist_matches(const struct sudoers_parse_tree *VAR_0,
const struct passwd *VAR_1, const struct member_list *VAR_2)
{
struct member *VAR_3;
int VAR_4 = VAR_5;
debug_decl(VAR_6, VAR_7);
TAILQ_FOREACH_REVERSE(VAR_3, VAR_2, member_list, VAR_8) {
if ((VAR_4 = user_matches(VAR_0, VAR_1, VAR_3)) != VAR_5)
break;
}
debug_return_int(VAR_4);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/match.c/vul/before/5.json,"int
userlist_matches(const struct sudoers_parse_tree *parse_tree,
    const struct passwd *pw, const struct member_list *list)
{
    struct member *m;
    int matched = UNSPEC;
    debug_decl(userlist_matches, SUDOERS_DEBUG_MATCH);

    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {
	matched = user_matches(parse_tree, pw, m);
	if (SPECIFIED(matched))
	    break;
    }
    debug_return_int(matched);
}","int
userlist_matches(const struct sudoers_parse_tree *VAR_0,
    const struct passwd *VAR_1, const struct member_list *VAR_2)
{
    struct member *VAR_3;
    int VAR_4 = VAR_5;
    debug_decl(VAR_6, VAR_7);

    TAILQ_FOREACH_REVERSE(VAR_3, VAR_2, member_list, VAR_8) {
	VAR_4 = user_matches(VAR_0, VAR_1, VAR_3);
	if (SPECIFIED(VAR_4))
	    break;
    }
    debug_return_int(VAR_4);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/match.c/vul/after/5.json,"--- func_before
+++ func_after
@@ -7,7 +7,8 @@
     debug_decl(userlist_matches, SUDOERS_DEBUG_MATCH);
 
     TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {
-	if ((matched = user_matches(parse_tree, pw, m)) != UNSPEC)
+	matched = user_matches(parse_tree, pw, m);
+	if (SPECIFIED(matched))
 	    break;
     }
     debug_return_int(matched);","{'deleted_lines': ['\tif ((matched = user_matches(parse_tree, pw, m)) != UNSPEC)'], 'added_lines': ['\tmatched = user_matches(parse_tree, pw, m);', '\tif (SPECIFIED(matched))']}",True,"Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.",7.0,HIGH,2,test,2023-09-09T20:07:04Z,4
CVE-2023-42465,['CWE-Other'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,sudo-project/sudo,"Try to make sudo less vulnerable to ROWHAMMER attacks.

We now use ROWHAMMER-resistent values for ALLOW, DENY, AUTH_SUCCESS,
AUTH_FAILURE, AUTH_ERROR and AUTH_NONINTERACTIVE.  In addition, we
explicitly test for expected values instead of using a negated test
against an error value.  In the parser match functions this means
explicitly checking for ALLOW or DENY instead of accepting anything
that is not set to UNSPEC.

Thanks to Andrew J. Adiletta, M. Caner Tol, Yarkin Doroz, and Berk
Sunar, all affiliated with the Vernam Applied Cryptography and
Cybersecurity Lab at Worcester Polytechnic Institute, for the report.
Paper preprint: https://arxiv.org/abs/2309.02545",7873f8334c8d31031f8cfa83bd97ac6029309e4f,https://github.com/sudo-project/sudo/commit/7873f8334c8d31031f8cfa83bd97ac6029309e4f,plugins/sudoers/match.c,cmnd_matches,"int
cmnd_matches(const struct sudoers_parse_tree *parse_tree,
const struct member *m, const char *runchroot, struct cmnd_info *info)
{
struct alias *a;
struct sudo_command *c;
int rc, matched = UNSPEC;
debug_decl(cmnd_matches, SUDOERS_DEBUG_MATCH);
switch (m->type) {
case ALL:
case COMMAND:
c = (struct sudo_command *)m->name;
if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,
info, &c->digests))
matched = m->negated ? DENY : ALLOW;
break;
case ALIAS:
a = alias_get(parse_tree, m->name, CMNDALIAS);
if (a != NULL) {
rc = cmndlist_matches(parse_tree, &a->members, runchroot, info);
if (rc != UNSPEC) {
if (m->negated) {
matched = rc == ALLOW ? DENY : ALLOW;
} else {
matched = rc;
}
}
alias_put(a);
}
break;
}
debug_return_int(matched);
}","int
cmnd_matches(const struct sudoers_parse_tree *VAR_0,
const struct member *VAR_1, const char *VAR_2, struct cmnd_info *VAR_3)
{
struct alias *VAR_4;
struct sudo_command *VAR_5;
int VAR_6, VAR_7 = VAR_8;
debug_decl(VAR_9, VAR_10);
switch (VAR_1->type) {
case VAR_11:
case VAR_12:
VAR_5 = (struct sudo_command *)VAR_1->name;
if (command_matches(VAR_0->ctx, VAR_5->cmnd, VAR_5->args, VAR_2,
VAR_3, &VAR_5->digests))
VAR_7 = VAR_1->negated ? VAR_13 : VAR_14;
break;
case VAR_15:
VAR_4 = alias_get(VAR_0, VAR_1->name, VAR_16);
if (VAR_4 != NULL) {
VAR_6 = cmndlist_matches(VAR_0, &VAR_4->members, VAR_2, VAR_3);
if (VAR_6 != VAR_8) {
if (VAR_1->negated) {
VAR_7 = VAR_6 == VAR_14 ? VAR_13 : VAR_14;
} else {
VAR_7 = VAR_6;
}
}
alias_put(VAR_4);
}
break;
}
debug_return_int(VAR_7);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/match.c/vul/before/6.json,"int
cmnd_matches(const struct sudoers_parse_tree *parse_tree,
    const struct member *m, const char *runchroot, struct cmnd_info *info)
{
    struct alias *a;
    struct sudo_command *c;
    int rc, matched = UNSPEC;
    debug_decl(cmnd_matches, SUDOERS_DEBUG_MATCH);

    switch (m->type) {
	case ALL:
	case COMMAND:
	    c = (struct sudo_command *)m->name;
	    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,
		    info, &c->digests))
		matched = m->negated ? DENY : ALLOW;
	    break;
	case ALIAS:
	    a = alias_get(parse_tree, m->name, CMNDALIAS);
	    if (a != NULL) {
		rc = cmndlist_matches(parse_tree, &a->members, runchroot, info);
		if (SPECIFIED(rc)) {
		    if (m->negated) {
			matched = rc == ALLOW ? DENY : ALLOW;
		    } else {
			matched = rc;
		    }
		}
		alias_put(a);
	    }
	    break;
    }
    debug_return_int(matched);
}","int
cmnd_matches(const struct sudoers_parse_tree *VAR_0,
    const struct member *VAR_1, const char *VAR_2, struct cmnd_info *VAR_3)
{
    struct alias *VAR_4;
    struct sudo_command *VAR_5;
    int VAR_6, VAR_7 = VAR_8;
    debug_decl(VAR_9, VAR_10);

    switch (VAR_1->type) {
	case VAR_11:
	case VAR_12:
	    VAR_5 = (struct sudo_command *)VAR_1->name;
	    if (command_matches(VAR_0->ctx, VAR_5->cmnd, VAR_5->args, VAR_2,
		    VAR_3, &VAR_5->digests))
		VAR_7 = VAR_1->negated ? VAR_13 : VAR_14;
	    break;
	case VAR_15:
	    VAR_4 = alias_get(VAR_0, VAR_1->name, VAR_16);
	    if (VAR_4 != NULL) {
		VAR_6 = cmndlist_matches(VAR_0, &VAR_4->members, VAR_2, VAR_3);
		if (SPECIFIED(VAR_6)) {
		    if (VAR_1->negated) {
			VAR_7 = VAR_6 == VAR_14 ? VAR_13 : VAR_14;
		    } else {
			VAR_7 = VAR_6;
		    }
		}
		alias_put(VAR_4);
	    }
	    break;
    }
    debug_return_int(VAR_7);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/match.c/vul/after/6.json,"--- func_before
+++ func_after
@@ -19,7 +19,7 @@
 	    a = alias_get(parse_tree, m->name, CMNDALIAS);
 	    if (a != NULL) {
 		rc = cmndlist_matches(parse_tree, &a->members, runchroot, info);
-		if (rc != UNSPEC) {
+		if (SPECIFIED(rc)) {
 		    if (m->negated) {
 			matched = rc == ALLOW ? DENY : ALLOW;
 		    } else {","{'deleted_lines': ['\t\tif (rc != UNSPEC) {'], 'added_lines': ['\t\tif (SPECIFIED(rc)) {']}",True,"Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.",7.0,HIGH,2,test,2023-09-09T20:07:04Z,4
CVE-2023-42465,['CWE-Other'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,sudo-project/sudo,"Try to make sudo less vulnerable to ROWHAMMER attacks.

We now use ROWHAMMER-resistent values for ALLOW, DENY, AUTH_SUCCESS,
AUTH_FAILURE, AUTH_ERROR and AUTH_NONINTERACTIVE.  In addition, we
explicitly test for expected values instead of using a negated test
against an error value.  In the parser match functions this means
explicitly checking for ALLOW or DENY instead of accepting anything
that is not set to UNSPEC.

Thanks to Andrew J. Adiletta, M. Caner Tol, Yarkin Doroz, and Berk
Sunar, all affiliated with the Vernam Applied Cryptography and
Cybersecurity Lab at Worcester Polytechnic Institute, for the report.
Paper preprint: https://arxiv.org/abs/2309.02545",7873f8334c8d31031f8cfa83bd97ac6029309e4f,https://github.com/sudo-project/sudo/commit/7873f8334c8d31031f8cfa83bd97ac6029309e4f,plugins/sudoers/match.c,runas_grouplist_matches,"static int
runas_grouplist_matches(const struct sudoers_parse_tree *parse_tree,
const struct member_list *group_list, struct member **matching_group)
{
const struct sudoers_context *ctx = parse_tree->ctx;
int group_matched = UNSPEC;
struct member *m;
struct alias *a;
debug_decl(runas_grouplist_matches, SUDOERS_DEBUG_MATCH);
if (group_list != NULL) {
TAILQ_FOREACH_REVERSE(m, group_list, member_list, entries) {
switch (m->type) {
case ALL:
group_matched = m->negated ? DENY : ALLOW;
break;
case ALIAS:
a = alias_get(parse_tree, m->name, RUNASALIAS);
if (a != NULL) {
const int rc = runas_grouplist_matches(parse_tree,
&a->members, matching_group);
if (rc != UNSPEC) {
if (m->negated) {
group_matched = rc == ALLOW ? DENY : ALLOW;
} else {
group_matched = rc;
}
}
alias_put(a);
break;
}
FALLTHROUGH;
case WORD:
if (group_matches(m->name, ctx->runas.gr))
group_matched = m->negated ? DENY : ALLOW;
break;
}
if (group_matched != UNSPEC) {
if (matching_group != NULL && m->type != ALIAS)
*matching_group = m;
break;
}
}
}
if (group_matched == UNSPEC) {
struct gid_list *runas_groups;
if (ctx->runas.pw->pw_gid == ctx->runas.gr->gr_gid) {
group_matched = ALLOW;
} else if ((runas_groups = runas_getgroups(ctx)) != NULL) {
int i;
for (i = 0; i < runas_groups->ngids; i++) {
if (runas_groups->gids[i] == ctx->runas.gr->gr_gid) {
group_matched = ALLOW;
break;
}
}
sudo_gidlist_delref(runas_groups);
}
}
debug_return_int(group_matched);
}","static int
runas_grouplist_matches(const struct sudoers_parse_tree *VAR_0,
const struct member_list *VAR_1, struct member **VAR_2)
{
const struct sudoers_context *VAR_3 = VAR_0->ctx;
int VAR_4 = VAR_5;
struct member *VAR_6;
struct alias *VAR_7;
debug_decl(VAR_8, VAR_9);
if (VAR_1 != NULL) {
TAILQ_FOREACH_REVERSE(VAR_6, VAR_1, member_list, VAR_10) {
switch (VAR_6->type) {
case VAR_11:
VAR_4 = VAR_6->negated ? VAR_12 : VAR_13;
break;
case VAR_14:
VAR_7 = alias_get(VAR_0, VAR_6->name, VAR_15);
if (VAR_7 != NULL) {
const int VAR_16 = VAR_8(VAR_0,
&VAR_7->members, VAR_2);
if (VAR_16 != VAR_5) {
if (VAR_6->negated) {
VAR_4 = VAR_16 == VAR_13 ? VAR_12 : VAR_13;
} else {
VAR_4 = VAR_16;
}
}
alias_put(VAR_7);
break;
}
VAR_17;
case VAR_18:
if (group_matches(VAR_6->name, VAR_3->runas.gr))
VAR_4 = VAR_6->negated ? VAR_12 : VAR_13;
break;
}
if (VAR_4 != VAR_5) {
if (VAR_2 != NULL && VAR_6->type != VAR_14)
*VAR_2 = VAR_6;
break;
}
}
}
if (VAR_4 == VAR_5) {
struct gid_list *VAR_19;
if (VAR_3->runas.pw->pw_gid == VAR_3->runas.gr->gr_gid) {
VAR_4 = VAR_13;
} else if ((VAR_19 = runas_getgroups(VAR_3)) != NULL) {
int VAR_20;
for (VAR_20 = 0; VAR_20 < VAR_19->ngids; VAR_20++) {
if (VAR_19->gids[VAR_20] == VAR_3->runas.gr->gr_gid) {
VAR_4 = VAR_13;
break;
}
}
sudo_gidlist_delref(VAR_19);
}
}
debug_return_int(VAR_4);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/match.c/vul/before/7.json,"static int
runas_grouplist_matches(const struct sudoers_parse_tree *parse_tree,
    const struct member_list *group_list, struct member **matching_group)
{
    const struct sudoers_context *ctx = parse_tree->ctx;
    int group_matched = UNSPEC;
    struct member *m;
    struct alias *a;
    debug_decl(runas_grouplist_matches, SUDOERS_DEBUG_MATCH);

    if (group_list != NULL) {
	TAILQ_FOREACH_REVERSE(m, group_list, member_list, entries) {
	    switch (m->type) {
		case ALL:
		    group_matched = m->negated ? DENY : ALLOW;
		    break;
		case ALIAS:
		    a = alias_get(parse_tree, m->name, RUNASALIAS);
		    if (a != NULL) {
			const int rc = runas_grouplist_matches(parse_tree,
			    &a->members, matching_group);
			if (SPECIFIED(rc)) {
			    if (m->negated) {
				group_matched = rc == ALLOW ? DENY : ALLOW;
			    } else {
				group_matched = rc;
			    }
			}
			alias_put(a);
			break;
		    }
		    FALLTHROUGH;
		case WORD:
		    if (group_matches(m->name, ctx->runas.gr))
			group_matched = m->negated ? DENY : ALLOW;
		    break;
	    }
	    if (SPECIFIED(group_matched)) {
		if (matching_group != NULL && m->type != ALIAS)
		    *matching_group = m;
		break;
	    }
	}
    }
    if (!SPECIFIED(group_matched)) {
	struct gid_list *runas_groups;
	/*
	 * The runas group was not explicitly allowed by sudoers.
	 * Check whether it is one of the target user's groups.
	 */
	if (ctx->runas.pw->pw_gid == ctx->runas.gr->gr_gid) {
	    group_matched = ALLOW;	/* runas group matches passwd db */
	} else if ((runas_groups = runas_getgroups(ctx)) != NULL) {
	    int i;

	    for (i = 0; i < runas_groups->ngids; i++) {
		if (runas_groups->gids[i] == ctx->runas.gr->gr_gid) {
		    group_matched = ALLOW;	/* matched aux group vector */
		    break;
		}
	    }
	    sudo_gidlist_delref(runas_groups);
	}
    }

    debug_return_int(group_matched);
}","static int
runas_grouplist_matches(const struct sudoers_parse_tree *VAR_0,
    const struct member_list *VAR_1, struct member **VAR_2)
{
    const struct sudoers_context *VAR_3 = VAR_0->ctx;
    int VAR_4 = VAR_5;
    struct member *VAR_6;
    struct alias *VAR_7;
    debug_decl(VAR_8, VAR_9);

    if (VAR_1 != NULL) {
	TAILQ_FOREACH_REVERSE(VAR_6, VAR_1, member_list, VAR_10) {
	    switch (VAR_6->type) {
		case VAR_11:
		    VAR_4 = VAR_6->negated ? VAR_12 : VAR_13;
		    break;
		case VAR_14:
		    VAR_7 = alias_get(VAR_0, VAR_6->name, VAR_15);
		    if (VAR_7 != NULL) {
			const int VAR_16 = VAR_8(VAR_0,
			    &VAR_7->members, VAR_2);
			if (SPECIFIED(VAR_16)) {
			    if (VAR_6->negated) {
				VAR_4 = VAR_16 == VAR_13 ? VAR_12 : VAR_13;
			    } else {
				VAR_4 = VAR_16;
			    }
			}
			alias_put(VAR_7);
			break;
		    }
		    VAR_17;
		case VAR_18:
		    if (group_matches(VAR_6->name, VAR_3->runas.gr))
			VAR_4 = VAR_6->negated ? VAR_12 : VAR_13;
		    break;
	    }
	    if (SPECIFIED(VAR_4)) {
		if (VAR_2 != NULL && VAR_6->type != VAR_14)
		    *VAR_2 = VAR_6;
		break;
	    }
	}
    }
    if (!SPECIFIED(VAR_4)) {
	struct gid_list *VAR_19;
	/* COMMENT_0 */
                                                          
                                                        
    
	if (VAR_3->runas.pw->pw_gid == VAR_3->runas.gr->gr_gid) {
	    VAR_4 = VAR_13;	/* COMMENT_4 */
	} else if ((VAR_19 = runas_getgroups(VAR_3)) != NULL) {
	    int VAR_20;

	    for (VAR_20 = 0; VAR_20 < VAR_19->ngids; VAR_20++) {
		if (VAR_19->gids[VAR_20] == VAR_3->runas.gr->gr_gid) {
		    VAR_4 = VAR_13;	/* COMMENT_5 */
		    break;
		}
	    }
	    sudo_gidlist_delref(VAR_19);
	}
    }

    debug_return_int(VAR_4);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/match.c/vul/after/7.json,"--- func_before
+++ func_after
@@ -19,7 +19,7 @@
 		    if (a != NULL) {
 			const int rc = runas_grouplist_matches(parse_tree,
 			    &a->members, matching_group);
-			if (rc != UNSPEC) {
+			if (SPECIFIED(rc)) {
 			    if (m->negated) {
 				group_matched = rc == ALLOW ? DENY : ALLOW;
 			    } else {
@@ -35,14 +35,14 @@
 			group_matched = m->negated ? DENY : ALLOW;
 		    break;
 	    }
-	    if (group_matched != UNSPEC) {
+	    if (SPECIFIED(group_matched)) {
 		if (matching_group != NULL && m->type != ALIAS)
 		    *matching_group = m;
 		break;
 	    }
 	}
     }
-    if (group_matched == UNSPEC) {
+    if (!SPECIFIED(group_matched)) {
 	struct gid_list *runas_groups;
 	/*
 	 * The runas group was not explicitly allowed by sudoers.","{'deleted_lines': ['\t\t\tif (rc != UNSPEC) {', '\t    if (group_matched != UNSPEC) {', '    if (group_matched == UNSPEC) {'], 'added_lines': ['\t\t\tif (SPECIFIED(rc)) {', '\t    if (SPECIFIED(group_matched)) {', '    if (!SPECIFIED(group_matched)) {']}",True,"Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.",7.0,HIGH,2,test,2023-09-09T20:07:04Z,4
CVE-2023-42465,['CWE-Other'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,sudo-project/sudo,"Try to make sudo less vulnerable to ROWHAMMER attacks.

We now use ROWHAMMER-resistent values for ALLOW, DENY, AUTH_SUCCESS,
AUTH_FAILURE, AUTH_ERROR and AUTH_NONINTERACTIVE.  In addition, we
explicitly test for expected values instead of using a negated test
against an error value.  In the parser match functions this means
explicitly checking for ALLOW or DENY instead of accepting anything
that is not set to UNSPEC.

Thanks to Andrew J. Adiletta, M. Caner Tol, Yarkin Doroz, and Berk
Sunar, all affiliated with the Vernam Applied Cryptography and
Cybersecurity Lab at Worcester Polytechnic Institute, for the report.
Paper preprint: https://arxiv.org/abs/2309.02545",7873f8334c8d31031f8cfa83bd97ac6029309e4f,https://github.com/sudo-project/sudo/commit/7873f8334c8d31031f8cfa83bd97ac6029309e4f,plugins/sudoers/match.c,runas_userlist_matches,"static int
runas_userlist_matches(const struct sudoers_parse_tree *parse_tree,
const struct member_list *user_list, struct member **matching_user)
{
const struct sudoers_context *ctx = parse_tree->ctx;
const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;
const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;
int user_matched = UNSPEC;
struct member *m;
struct alias *a;
debug_decl(runas_userlist_matches, SUDOERS_DEBUG_MATCH);
TAILQ_FOREACH_REVERSE(m, user_list, member_list, entries) {
switch (m->type) {
case ALL:
user_matched = m->negated ? DENY : ALLOW;
break;
case NETGROUP:
if (netgr_matches(parse_tree->nss, m->name,
def_netgroup_tuple ? lhost : NULL,
def_netgroup_tuple ? shost : NULL,
ctx->runas.pw->pw_name))
user_matched = m->negated ? DENY : ALLOW;
break;
case USERGROUP:
if (usergr_matches(m->name, ctx->runas.pw->pw_name, ctx->runas.pw))
user_matched = m->negated ? DENY : ALLOW;
break;
case ALIAS:
a = alias_get(parse_tree, m->name, RUNASALIAS);
if (a != NULL) {
const int rc = runas_userlist_matches(parse_tree,
&a->members, matching_user);
if (rc != UNSPEC) {
if (m->negated) {
user_matched = rc == ALLOW ? DENY : ALLOW;
} else {
user_matched = rc;
}
}
alias_put(a);
break;
}
FALLTHROUGH;
case WORD:
if (userpw_matches(m->name, ctx->runas.pw->pw_name, ctx->runas.pw))
user_matched = m->negated ? DENY : ALLOW;
break;
case MYSELF:
if ((!ISSET(ctx->settings.flags, RUNAS_USER_SPECIFIED) &&
ISSET(ctx->settings.flags, RUNAS_GROUP_SPECIFIED)) ||
strcmp(ctx->user.name, ctx->runas.pw->pw_name) == 0)
user_matched = m->negated ? DENY : ALLOW;
break;
}
if (user_matched != UNSPEC) {
if (matching_user != NULL && m->type != ALIAS)
*matching_user = m;
break;
}
}
debug_return_int(user_matched);
}","static int
runas_userlist_matches(const struct sudoers_parse_tree *VAR_0,
const struct member_list *VAR_1, struct member **VAR_2)
{
const struct sudoers_context *VAR_3 = VAR_0->ctx;
const char *VAR_4 = VAR_0->lhost ? VAR_0->lhost : VAR_3->runas.host;
const char *VAR_5 = VAR_0->shost ? VAR_0->shost : VAR_3->runas.shost;
int VAR_6 = VAR_7;
struct member *VAR_8;
struct alias *VAR_9;
debug_decl(VAR_10, VAR_11);
TAILQ_FOREACH_REVERSE(VAR_8, VAR_1, member_list, VAR_12) {
switch (VAR_8->type) {
case VAR_13:
VAR_6 = VAR_8->negated ? VAR_14 : VAR_15;
break;
case VAR_16:
if (netgr_matches(VAR_0->nss, VAR_8->name,
VAR_17 ? VAR_4 : NULL,
VAR_17 ? VAR_5 : NULL,
VAR_3->runas.pw->pw_name))
VAR_6 = VAR_8->negated ? VAR_14 : VAR_15;
break;
case VAR_18:
if (usergr_matches(VAR_8->name, VAR_3->runas.pw->pw_name, VAR_3->runas.pw))
VAR_6 = VAR_8->negated ? VAR_14 : VAR_15;
break;
case VAR_19:
VAR_9 = alias_get(VAR_0, VAR_8->name, VAR_20);
if (VAR_9 != NULL) {
const int VAR_21 = VAR_10(VAR_0,
&VAR_9->members, VAR_2);
if (VAR_21 != VAR_7) {
if (VAR_8->negated) {
VAR_6 = VAR_21 == VAR_15 ? VAR_14 : VAR_15;
} else {
VAR_6 = VAR_21;
}
}
alias_put(VAR_9);
break;
}
VAR_22;
case VAR_23:
if (userpw_matches(VAR_8->name, VAR_3->runas.pw->pw_name, VAR_3->runas.pw))
VAR_6 = VAR_8->negated ? VAR_14 : VAR_15;
break;
case VAR_24:
if ((!ISSET(VAR_3->settings.flags, VAR_25) &&
ISSET(VAR_3->settings.flags, VAR_26)) ||
strcmp(VAR_3->user.name, VAR_3->runas.pw->pw_name) == 0)
VAR_6 = VAR_8->negated ? VAR_14 : VAR_15;
break;
}
if (VAR_6 != VAR_7) {
if (VAR_2 != NULL && VAR_8->type != VAR_19)
*VAR_2 = VAR_8;
break;
}
}
debug_return_int(VAR_6);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/match.c/vul/before/8.json,"static int
runas_userlist_matches(const struct sudoers_parse_tree *parse_tree,
    const struct member_list *user_list, struct member **matching_user)
{
    const struct sudoers_context *ctx = parse_tree->ctx;
    const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;
    const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;
    int user_matched = UNSPEC;
    struct member *m;
    struct alias *a;
    debug_decl(runas_userlist_matches, SUDOERS_DEBUG_MATCH);

    TAILQ_FOREACH_REVERSE(m, user_list, member_list, entries) {
	switch (m->type) {
	    case ALL:
		user_matched = m->negated ? DENY : ALLOW;
		break;
	    case NETGROUP:
		if (netgr_matches(parse_tree->nss, m->name,
		    def_netgroup_tuple ? lhost : NULL,
		    def_netgroup_tuple ? shost : NULL,
		    ctx->runas.pw->pw_name))
		    user_matched = m->negated ? DENY : ALLOW;
		break;
	    case USERGROUP:
		if (usergr_matches(m->name, ctx->runas.pw->pw_name, ctx->runas.pw))
		    user_matched = m->negated ? DENY : ALLOW;
		break;
	    case ALIAS:
		a = alias_get(parse_tree, m->name, RUNASALIAS);
		if (a != NULL) {
		    const int rc = runas_userlist_matches(parse_tree,
			&a->members, matching_user);
		    if (SPECIFIED(rc)) {
			if (m->negated) {
			    user_matched = rc == ALLOW ? DENY : ALLOW;
			} else {
			    user_matched = rc;
			}
		    }
		    alias_put(a);
		    break;
		}
		FALLTHROUGH;
	    case WORD:
		if (userpw_matches(m->name, ctx->runas.pw->pw_name, ctx->runas.pw))
		    user_matched = m->negated ? DENY : ALLOW;
		break;
	    case MYSELF:
		/*
		 * Only match a rule with an empty runas user if a group
		 * was specified on the command line without a user _or_
		 * the user specified their own name on the command line.
		 */
		if ((!ISSET(ctx->settings.flags, RUNAS_USER_SPECIFIED) &&
			ISSET(ctx->settings.flags, RUNAS_GROUP_SPECIFIED)) ||
			strcmp(ctx->user.name, ctx->runas.pw->pw_name) == 0)
		    user_matched = m->negated ? DENY : ALLOW;
		break;
	}
	if (SPECIFIED(user_matched)) {
	    if (matching_user != NULL && m->type != ALIAS)
		*matching_user = m;
	    break;
	}
    }
    debug_return_int(user_matched);
}","static int
runas_userlist_matches(const struct sudoers_parse_tree *VAR_0,
    const struct member_list *VAR_1, struct member **VAR_2)
{
    const struct sudoers_context *VAR_3 = VAR_0->ctx;
    const char *VAR_4 = VAR_0->lhost ? VAR_0->lhost : VAR_3->runas.host;
    const char *VAR_5 = VAR_0->shost ? VAR_0->shost : VAR_3->runas.shost;
    int VAR_6 = VAR_7;
    struct member *VAR_8;
    struct alias *VAR_9;
    debug_decl(VAR_10, VAR_11);

    TAILQ_FOREACH_REVERSE(VAR_8, VAR_1, member_list, VAR_12) {
	switch (VAR_8->type) {
	    case VAR_13:
		VAR_6 = VAR_8->negated ? VAR_14 : VAR_15;
		break;
	    case VAR_16:
		if (netgr_matches(VAR_0->nss, VAR_8->name,
		    VAR_17 ? VAR_4 : NULL,
		    VAR_17 ? VAR_5 : NULL,
		    VAR_3->runas.pw->pw_name))
		    VAR_6 = VAR_8->negated ? VAR_14 : VAR_15;
		break;
	    case VAR_18:
		if (usergr_matches(VAR_8->name, VAR_3->runas.pw->pw_name, VAR_3->runas.pw))
		    VAR_6 = VAR_8->negated ? VAR_14 : VAR_15;
		break;
	    case VAR_19:
		VAR_9 = alias_get(VAR_0, VAR_8->name, VAR_20);
		if (VAR_9 != NULL) {
		    const int VAR_21 = VAR_10(VAR_0,
			&VAR_9->members, VAR_2);
		    if (SPECIFIED(VAR_21)) {
			if (VAR_8->negated) {
			    VAR_6 = VAR_21 == VAR_15 ? VAR_14 : VAR_15;
			} else {
			    VAR_6 = VAR_21;
			}
		    }
		    alias_put(VAR_9);
		    break;
		}
		VAR_22;
	    case VAR_23:
		if (userpw_matches(VAR_8->name, VAR_3->runas.pw->pw_name, VAR_3->runas.pw))
		    VAR_6 = VAR_8->negated ? VAR_14 : VAR_15;
		break;
	    case VAR_24:
		/* COMMENT_0 */
                                                          
                                                          
                                                           
     
		if ((!ISSET(VAR_3->settings.flags, VAR_25) &&
			ISSET(VAR_3->settings.flags, VAR_26)) ||
			strcmp(VAR_3->user.name, VAR_3->runas.pw->pw_name) == 0)
		    VAR_6 = VAR_8->negated ? VAR_14 : VAR_15;
		break;
	}
	if (SPECIFIED(VAR_6)) {
	    if (VAR_2 != NULL && VAR_8->type != VAR_19)
		*VAR_2 = VAR_8;
	    break;
	}
    }
    debug_return_int(VAR_6);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/match.c/vul/after/8.json,"--- func_before
+++ func_after
@@ -31,7 +31,7 @@
 		if (a != NULL) {
 		    const int rc = runas_userlist_matches(parse_tree,
 			&a->members, matching_user);
-		    if (rc != UNSPEC) {
+		    if (SPECIFIED(rc)) {
 			if (m->negated) {
 			    user_matched = rc == ALLOW ? DENY : ALLOW;
 			} else {
@@ -58,7 +58,7 @@
 		    user_matched = m->negated ? DENY : ALLOW;
 		break;
 	}
-	if (user_matched != UNSPEC) {
+	if (SPECIFIED(user_matched)) {
 	    if (matching_user != NULL && m->type != ALIAS)
 		*matching_user = m;
 	    break;","{'deleted_lines': ['\t\t    if (rc != UNSPEC) {', '\tif (user_matched != UNSPEC) {'], 'added_lines': ['\t\t    if (SPECIFIED(rc)) {', '\tif (SPECIFIED(user_matched)) {']}",True,"Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.",7.0,HIGH,2,test,2023-09-09T20:07:04Z,4
CVE-2023-42465,['CWE-Other'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,sudo-project/sudo,"Try to make sudo less vulnerable to ROWHAMMER attacks.

We now use ROWHAMMER-resistent values for ALLOW, DENY, AUTH_SUCCESS,
AUTH_FAILURE, AUTH_ERROR and AUTH_NONINTERACTIVE.  In addition, we
explicitly test for expected values instead of using a negated test
against an error value.  In the parser match functions this means
explicitly checking for ALLOW or DENY instead of accepting anything
that is not set to UNSPEC.

Thanks to Andrew J. Adiletta, M. Caner Tol, Yarkin Doroz, and Berk
Sunar, all affiliated with the Vernam Applied Cryptography and
Cybersecurity Lab at Worcester Polytechnic Institute, for the report.
Paper preprint: https://arxiv.org/abs/2309.02545",7873f8334c8d31031f8cfa83bd97ac6029309e4f,https://github.com/sudo-project/sudo/commit/7873f8334c8d31031f8cfa83bd97ac6029309e4f,plugins/sudoers/auth/sudo_auth.c,sudo_auth_init,"int
sudo_auth_init(const struct sudoers_context *ctx, struct passwd *pw,
unsigned int mode)
{
sudo_auth *auth;
int status = AUTH_SUCCESS;
debug_decl(sudo_auth_init, SUDOERS_DEBUG_AUTH);
if (auth_switch[0].name == NULL)
debug_return_int(0);
for (auth = auth_switch; auth->name; auth++) {
if (ISSET(mode, MODE_NONINTERACTIVE))
SET(auth->flags, FLAG_NONINTERACTIVE);
if (auth->init && !IS_DISABLED(auth)) {
status = (auth->init)(ctx, pw, auth);
if (status == AUTH_FAILURE)
SET(auth->flags, FLAG_DISABLED);
else if (status == AUTH_ERROR)
break;
}
}
if ((standalone = IS_STANDALONE(&auth_switch[0]))) {
bool found = false;
for (auth = auth_switch; auth->name; auth++) {
if (IS_DISABLED(auth))
continue;
if (!IS_STANDALONE(auth)) {
audit_failure(ctx, ctx->runas.argv,
N_(""invalid authentication methods""));
log_warningx(ctx, SLOG_SEND_MAIL,
N_(""Invalid authentication methods compiled into sudo!  ""
""You may not mix standalone and non-standalone authentication.""));
debug_return_int(-1);
}
if (!found) {
found = true;
continue;
}
SET(auth->flags, FLAG_DISABLED);
}
}
for (auth = auth_switch; auth->name; auth++) {
if (!IS_DISABLED(auth)) {
sudo_auth *first = auth;
for (; auth->name; auth++) {
if (!IS_DISABLED(auth))
break;
}
if (auth->name == NULL)
SET(first->flags, FLAG_ONEANDONLY);
break;
}
}
debug_return_int(status == AUTH_ERROR ? -1 : 0);
}","int
sudo_auth_init(const struct sudoers_context *VAR_0, struct passwd *VAR_1,
unsigned int VAR_2)
{
sudo_auth *VAR_3;
int VAR_4 = VAR_5;
debug_decl(VAR_6, VAR_7);
if (VAR_8[0].name == NULL)
debug_return_int(0);
for (VAR_3 = VAR_8; VAR_3->name; VAR_3++) {
if (ISSET(VAR_2, VAR_9))
SET(VAR_3->flags, VAR_10);
if (VAR_3->init && !IS_DISABLED(VAR_3)) {
VAR_4 = (VAR_3->init)(VAR_0, VAR_1, VAR_3);
if (VAR_4 == VAR_11)
SET(VAR_3->flags, VAR_12);
else if (VAR_4 == VAR_13)
break;
}
}
if ((VAR_14 = IS_STANDALONE(&VAR_8[0]))) {
bool VAR_15 = false;
for (VAR_3 = VAR_8; VAR_3->name; VAR_3++) {
if (IS_DISABLED(VAR_3))
continue;
if (!IS_STANDALONE(VAR_3)) {
audit_failure(VAR_0, VAR_0->runas.argv,
N_(""invalid authentication methods""));
log_warningx(VAR_0, VAR_16,
N_(""Invalid authentication methods compiled into sudo!  ""
""You may not mix standalone and non-standalone authentication.""));
debug_return_int(-1);
}
if (!VAR_15) {
VAR_15 = true;
continue;
}
SET(VAR_3->flags, VAR_12);
}
}
for (VAR_3 = VAR_8; VAR_3->name; VAR_3++) {
if (!IS_DISABLED(VAR_3)) {
sudo_auth *VAR_17 = VAR_3;
for (; VAR_3->name; VAR_3++) {
if (!IS_DISABLED(VAR_3))
break;
}
if (VAR_3->name == NULL)
SET(VAR_17->flags, VAR_18);
break;
}
}
debug_return_int(VAR_4 == VAR_13 ? -1 : 0);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/sudo_auth.c/vul/before/0.json,"int
sudo_auth_init(const struct sudoers_context *ctx, struct passwd *pw,
    unsigned int mode)
{
    sudo_auth *auth;
    int status = AUTH_SUCCESS;
    debug_decl(sudo_auth_init, SUDOERS_DEBUG_AUTH);

    if (auth_switch[0].name == NULL)
	debug_return_int(0);

    /* Initialize auth methods and unconfigure the method if necessary. */
    for (auth = auth_switch; auth->name; auth++) {
	if (ISSET(mode, MODE_NONINTERACTIVE))
	    SET(auth->flags, FLAG_NONINTERACTIVE);
	if (auth->init && !IS_DISABLED(auth)) {
	    /* Disable if it failed to init unless there was a fatal error. */
	    status = (auth->init)(ctx, pw, auth);
	    switch (status) {
	    case AUTH_SUCCESS:
		break;
	    case AUTH_FAILURE:
		SET(auth->flags, FLAG_DISABLED);
		break;
	    default:
		/* Assume error msg already printed. */
		debug_return_int(-1);
	    }
	}
    }

    /*
     * Make sure we haven't mixed standalone and shared auth methods.
     * If there are multiple standalone methods, only use the first one.
     */
    if ((standalone = IS_STANDALONE(&auth_switch[0]))) {
	bool found = false;
	for (auth = auth_switch; auth->name; auth++) {
	    if (IS_DISABLED(auth))
		continue;
	    if (!IS_STANDALONE(auth)) {
		audit_failure(ctx, ctx->runas.argv,
		    N_(""invalid authentication methods""));
		log_warningx(ctx, SLOG_SEND_MAIL,
		    N_(""Invalid authentication methods compiled into sudo!  ""
		    ""You may not mix standalone and non-standalone authentication.""));
		debug_return_int(-1);
	    }
	    if (!found) {
		/* Found first standalone method. */
		found = true;
		continue;
	    }
	    /* Disable other standalone methods. */
	    SET(auth->flags, FLAG_DISABLED);
	}
    }

    /* Set FLAG_ONEANDONLY if there is only one auth method. */
    for (auth = auth_switch; auth->name; auth++) {
	/* Find first enabled auth method. */
	if (!IS_DISABLED(auth)) {
	    sudo_auth *first = auth;
	    /* Check for others. */
	    for (; auth->name; auth++) {
		if (!IS_DISABLED(auth))
		    break;
	    }
	    if (auth->name == NULL)
		SET(first->flags, FLAG_ONEANDONLY);
	    break;
	}
    }

    debug_return_int(0);
}","int
sudo_auth_init(const struct sudoers_context *VAR_0, struct passwd *VAR_1,
    unsigned int VAR_2)
{
    sudo_auth *VAR_3;
    int VAR_4 = VAR_5;
    debug_decl(VAR_6, VAR_7);

    if (VAR_8[0].name == NULL)
	debug_return_int(0);

    /* COMMENT_0 */
    for (VAR_3 = VAR_8; VAR_3->name; VAR_3++) {
	if (ISSET(VAR_2, VAR_9))
	    SET(VAR_3->flags, VAR_10);
	if (VAR_3->init && !IS_DISABLED(VAR_3)) {
	    /* COMMENT_1 */
	    VAR_4 = (VAR_3->init)(VAR_0, VAR_1, VAR_3);
	    switch (VAR_4) {
	    case VAR_5:
		break;
	    case VAR_11:
		SET(VAR_3->flags, VAR_12);
		break;
	    default:
		/* COMMENT_2 */
		debug_return_int(-1);
	    }
	}
    }

    /* COMMENT_3 */
                                                                     
                                                                        
       
    if ((VAR_13 = IS_STANDALONE(&VAR_8[0]))) {
	bool VAR_14 = false;
	for (VAR_3 = VAR_8; VAR_3->name; VAR_3++) {
	    if (IS_DISABLED(VAR_3))
		continue;
	    if (!IS_STANDALONE(VAR_3)) {
		audit_failure(VAR_0, VAR_0->runas.argv,
		    N_(""invalid authentication methods""));
		log_warningx(VAR_0, VAR_15,
		    N_(""Invalid authentication methods compiled into sudo!  ""
		    ""You may not mix standalone and non-standalone authentication.""));
		debug_return_int(-1);
	    }
	    if (!VAR_14) {
		/* COMMENT_7 */
		VAR_14 = true;
		continue;
	    }
	    /* COMMENT_8 */
	    SET(VAR_3->flags, VAR_12);
	}
    }

    /* COMMENT_9 */
    for (VAR_3 = VAR_8; VAR_3->name; VAR_3++) {
	/* COMMENT_10 */
	if (!IS_DISABLED(VAR_3)) {
	    sudo_auth *VAR_16 = VAR_3;
	    /* COMMENT_11 */
	    for (; VAR_3->name; VAR_3++) {
		if (!IS_DISABLED(VAR_3))
		    break;
	    }
	    if (VAR_3->name == NULL)
		SET(VAR_16->flags, VAR_17);
	    break;
	}
    }

    debug_return_int(0);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/sudo_auth.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -16,10 +16,16 @@
 	if (auth->init && !IS_DISABLED(auth)) {
 	    /* Disable if it failed to init unless there was a fatal error. */
 	    status = (auth->init)(ctx, pw, auth);
-	    if (status == AUTH_FAILURE)
+	    switch (status) {
+	    case AUTH_SUCCESS:
+		break;
+	    case AUTH_FAILURE:
 		SET(auth->flags, FLAG_DISABLED);
-	    else if (status == AUTH_ERROR)
-		break;		/* assume error msg already printed */
+		break;
+	    default:
+		/* Assume error msg already printed. */
+		debug_return_int(-1);
+	    }
 	}
     }
 
@@ -66,5 +72,5 @@
 	}
     }
 
-    debug_return_int(status == AUTH_ERROR ? -1 : 0);
+    debug_return_int(0);
 }","{'deleted_lines': ['\t    if (status == AUTH_FAILURE)', '\t    else if (status == AUTH_ERROR)', '\t\tbreak;\t\t/* assume error msg already printed */', '    debug_return_int(status == AUTH_ERROR ? -1 : 0);'], 'added_lines': ['\t    switch (status) {', '\t    case AUTH_SUCCESS:', '\t\tbreak;', '\t    case AUTH_FAILURE:', '\t\tbreak;', '\t    default:', '\t\t/* Assume error msg already printed. */', '\t\tdebug_return_int(-1);', '\t    }', '    debug_return_int(0);']}",True,"Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.",7.0,HIGH,2,test,2023-09-09T20:07:04Z,4
CVE-2023-42465,['CWE-Other'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,sudo-project/sudo,"Try to make sudo less vulnerable to ROWHAMMER attacks.

We now use ROWHAMMER-resistent values for ALLOW, DENY, AUTH_SUCCESS,
AUTH_FAILURE, AUTH_ERROR and AUTH_NONINTERACTIVE.  In addition, we
explicitly test for expected values instead of using a negated test
against an error value.  In the parser match functions this means
explicitly checking for ALLOW or DENY instead of accepting anything
that is not set to UNSPEC.

Thanks to Andrew J. Adiletta, M. Caner Tol, Yarkin Doroz, and Berk
Sunar, all affiliated with the Vernam Applied Cryptography and
Cybersecurity Lab at Worcester Polytechnic Institute, for the report.
Paper preprint: https://arxiv.org/abs/2309.02545",7873f8334c8d31031f8cfa83bd97ac6029309e4f,https://github.com/sudo-project/sudo/commit/7873f8334c8d31031f8cfa83bd97ac6029309e4f,plugins/sudoers/auth/sudo_auth.c,sudo_auth_begin_session,"int
sudo_auth_begin_session(const struct sudoers_context *ctx, struct passwd *pw,
char **user_env[])
{
sudo_auth *auth;
debug_decl(sudo_auth_begin_session, SUDOERS_DEBUG_AUTH);
for (auth = auth_switch; auth->name; auth++) {
if (auth->begin_session && !IS_DISABLED(auth)) {
int status = (auth->begin_session)(ctx, pw, user_env, auth);
if (status != AUTH_SUCCESS) {
debug_return_int(-1);
}
}
}
debug_return_int(1);
}","int
sudo_auth_begin_session(const struct sudoers_context *VAR_0, struct passwd *VAR_1,
char **VAR_2[])
{
sudo_auth *VAR_3;
debug_decl(VAR_4, VAR_5);
for (VAR_3 = VAR_6; VAR_3->name; VAR_3++) {
if (VAR_3->begin_session && !IS_DISABLED(VAR_3)) {
int VAR_7 = (VAR_3->begin_session)(VAR_0, VAR_1, VAR_2, VAR_3);
if (VAR_7 != VAR_8) {
debug_return_int(-1);
}
}
}
debug_return_int(1);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/sudo_auth.c/vul/before/1.json,"int
sudo_auth_begin_session(const struct sudoers_context *ctx, struct passwd *pw,
    char **user_env[])
{
    sudo_auth *auth;
    int ret = true;
    debug_decl(sudo_auth_begin_session, SUDOERS_DEBUG_AUTH);

    for (auth = auth_switch; auth->name; auth++) {
	if (auth->begin_session && !IS_DISABLED(auth)) {
	    int status = (auth->begin_session)(ctx, pw, user_env, auth);
	    switch (status) {
	    case AUTH_SUCCESS:
		break;
	    case AUTH_FAILURE:
		ret = false;
		break;
	    default:
		/* Assume error msg already printed. */
		ret = -1;
		break;
	    }
	}
    }
    debug_return_int(ret);
}","int
sudo_auth_begin_session(const struct sudoers_context *VAR_0, struct passwd *VAR_1,
    char **VAR_2[])
{
    sudo_auth *VAR_3;
    int VAR_4 = true;
    debug_decl(VAR_5, VAR_6);

    for (VAR_3 = VAR_7; VAR_3->name; VAR_3++) {
	if (VAR_3->begin_session && !IS_DISABLED(VAR_3)) {
	    int VAR_8 = (VAR_3->begin_session)(VAR_0, VAR_1, VAR_2, VAR_3);
	    switch (VAR_8) {
	    case VAR_9:
		break;
	    case VAR_10:
		VAR_4 = false;
		break;
	    default:
		/* COMMENT_0 */
		VAR_4 = -1;
		break;
	    }
	}
    }
    debug_return_int(VAR_4);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/sudo_auth.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -3,16 +3,24 @@
     char **user_env[])
 {
     sudo_auth *auth;
+    int ret = true;
     debug_decl(sudo_auth_begin_session, SUDOERS_DEBUG_AUTH);
 
     for (auth = auth_switch; auth->name; auth++) {
 	if (auth->begin_session && !IS_DISABLED(auth)) {
 	    int status = (auth->begin_session)(ctx, pw, user_env, auth);
-	    if (status != AUTH_SUCCESS) {
+	    switch (status) {
+	    case AUTH_SUCCESS:
+		break;
+	    case AUTH_FAILURE:
+		ret = false;
+		break;
+	    default:
 		/* Assume error msg already printed. */
-		debug_return_int(-1);
+		ret = -1;
+		break;
 	    }
 	}
     }
-    debug_return_int(1);
+    debug_return_int(ret);
 }","{'deleted_lines': ['\t    if (status != AUTH_SUCCESS) {', '\t\tdebug_return_int(-1);', '    debug_return_int(1);'], 'added_lines': ['    int ret = true;', '\t    switch (status) {', '\t    case AUTH_SUCCESS:', '\t\tbreak;', '\t    case AUTH_FAILURE:', '\t\tret = false;', '\t\tbreak;', '\t    default:', '\t\tret = -1;', '\t\tbreak;', '    debug_return_int(ret);']}",True,"Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.",7.0,HIGH,2,test,2023-09-09T20:07:04Z,4
CVE-2023-42465,['CWE-Other'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,sudo-project/sudo,"Try to make sudo less vulnerable to ROWHAMMER attacks.

We now use ROWHAMMER-resistent values for ALLOW, DENY, AUTH_SUCCESS,
AUTH_FAILURE, AUTH_ERROR and AUTH_NONINTERACTIVE.  In addition, we
explicitly test for expected values instead of using a negated test
against an error value.  In the parser match functions this means
explicitly checking for ALLOW or DENY instead of accepting anything
that is not set to UNSPEC.

Thanks to Andrew J. Adiletta, M. Caner Tol, Yarkin Doroz, and Berk
Sunar, all affiliated with the Vernam Applied Cryptography and
Cybersecurity Lab at Worcester Polytechnic Institute, for the report.
Paper preprint: https://arxiv.org/abs/2309.02545",7873f8334c8d31031f8cfa83bd97ac6029309e4f,https://github.com/sudo-project/sudo/commit/7873f8334c8d31031f8cfa83bd97ac6029309e4f,plugins/sudoers/auth/sudo_auth.c,sudo_auth_end_session,"int
sudo_auth_end_session(void)
{
sudo_auth *auth;
int status;
debug_decl(sudo_auth_end_session, SUDOERS_DEBUG_AUTH);
for (auth = auth_switch; auth->name; auth++) {
if (auth->end_session && !IS_DISABLED(auth)) {
status = (auth->end_session)(auth);
if (status == AUTH_ERROR) {
debug_return_int(-1);
}
}
}
debug_return_int(1);
}","int
sudo_auth_end_session(void)
{
sudo_auth *VAR_0;
int VAR_1;
debug_decl(VAR_2, VAR_3);
for (VAR_0 = VAR_4; VAR_0->name; VAR_0++) {
if (VAR_0->end_session && !IS_DISABLED(VAR_0)) {
VAR_1 = (VAR_0->end_session)(VAR_0);
if (VAR_1 == VAR_5) {
debug_return_int(-1);
}
}
}
debug_return_int(1);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/sudo_auth.c/vul/before/2.json,"int
sudo_auth_end_session(void)
{
    sudo_auth *auth;
    int ret = true;
    int status;
    debug_decl(sudo_auth_end_session, SUDOERS_DEBUG_AUTH);

    for (auth = auth_switch; auth->name; auth++) {
	if (auth->end_session && !IS_DISABLED(auth)) {
	    status = (auth->end_session)(auth);
	    switch (status) {
	    case AUTH_SUCCESS:
		break;
	    case AUTH_FAILURE:
		ret = false;
		break;
	    default:
		/* Assume error msg already printed. */
		ret = -1;
		break;
	    }
	}
    }
    debug_return_int(ret);
}","int
sudo_auth_end_session(void)
{
    sudo_auth *VAR_0;
    int VAR_1 = true;
    int VAR_2;
    debug_decl(VAR_3, VAR_4);

    for (VAR_0 = VAR_5; VAR_0->name; VAR_0++) {
	if (VAR_0->end_session && !IS_DISABLED(VAR_0)) {
	    VAR_2 = (VAR_0->end_session)(VAR_0);
	    switch (VAR_2) {
	    case VAR_6:
		break;
	    case VAR_7:
		VAR_1 = false;
		break;
	    default:
		/* COMMENT_0 */
		VAR_1 = -1;
		break;
	    }
	}
    }
    debug_return_int(VAR_1);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/sudo_auth.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -2,17 +2,25 @@
 sudo_auth_end_session(void)
 {
     sudo_auth *auth;
+    int ret = true;
     int status;
     debug_decl(sudo_auth_end_session, SUDOERS_DEBUG_AUTH);
 
     for (auth = auth_switch; auth->name; auth++) {
 	if (auth->end_session && !IS_DISABLED(auth)) {
 	    status = (auth->end_session)(auth);
-	    if (status == AUTH_ERROR) {
+	    switch (status) {
+	    case AUTH_SUCCESS:
+		break;
+	    case AUTH_FAILURE:
+		ret = false;
+		break;
+	    default:
 		/* Assume error msg already printed. */
-		debug_return_int(-1);
+		ret = -1;
+		break;
 	    }
 	}
     }
-    debug_return_int(1);
+    debug_return_int(ret);
 }","{'deleted_lines': ['\t    if (status == AUTH_ERROR) {', '\t\tdebug_return_int(-1);', '    debug_return_int(1);'], 'added_lines': ['    int ret = true;', '\t    switch (status) {', '\t    case AUTH_SUCCESS:', '\t\tbreak;', '\t    case AUTH_FAILURE:', '\t\tret = false;', '\t\tbreak;', '\t    default:', '\t\tret = -1;', '\t\tbreak;', '    debug_return_int(ret);']}",True,"Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.",7.0,HIGH,2,test,2023-09-09T20:07:04Z,4
CVE-2023-42465,['CWE-Other'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,sudo-project/sudo,"Try to make sudo less vulnerable to ROWHAMMER attacks.

We now use ROWHAMMER-resistent values for ALLOW, DENY, AUTH_SUCCESS,
AUTH_FAILURE, AUTH_ERROR and AUTH_NONINTERACTIVE.  In addition, we
explicitly test for expected values instead of using a negated test
against an error value.  In the parser match functions this means
explicitly checking for ALLOW or DENY instead of accepting anything
that is not set to UNSPEC.

Thanks to Andrew J. Adiletta, M. Caner Tol, Yarkin Doroz, and Berk
Sunar, all affiliated with the Vernam Applied Cryptography and
Cybersecurity Lab at Worcester Polytechnic Institute, for the report.
Paper preprint: https://arxiv.org/abs/2309.02545",7873f8334c8d31031f8cfa83bd97ac6029309e4f,https://github.com/sudo-project/sudo/commit/7873f8334c8d31031f8cfa83bd97ac6029309e4f,plugins/sudoers/auth/sudo_auth.c,verify_user,"int
verify_user(const struct sudoers_context *ctx, struct passwd *pw, char *prompt,
unsigned int validated, struct sudo_conv_callback *callback)
{
unsigned int ntries;
int ret, status, success = AUTH_FAILURE;
sudo_auth *auth;
sigset_t mask, omask;
struct sigaction sa, saved_sigtstp;
debug_decl(verify_user, SUDOERS_DEBUG_AUTH);
if (auth_switch[0].name == NULL) {
audit_failure(ctx, ctx->runas.argv, N_(""no authentication methods""));
log_warningx(ctx, SLOG_SEND_MAIL,
N_(""There are no authentication methods compiled into sudo!  ""
""If you want to turn off authentication, use the ""
""--disable-authentication configure option.""));
debug_return_int(-1);
}
sigemptyset(&sa.sa_mask);
sa.sa_flags = SA_RESTART;
sa.sa_handler = SIG_DFL;
(void) sigaction(SIGTSTP, &sa, &saved_sigtstp);
sigemptyset(&mask);
sigaddset(&mask, SIGINT);
sigaddset(&mask, SIGQUIT);
(void) sigprocmask(SIG_BLOCK, &mask, &omask);
for (ntries = 0; ntries < def_passwd_tries; ntries++) {
int num_methods = 0;
char *pass = NULL;
if (user_interrupted())
goto done;
if (ntries != 0)
pass_warn();
for (auth = auth_switch; auth->name; auth++) {
if (IS_DISABLED(auth))
continue;
num_methods++;
if (auth->setup != NULL) {
status = (auth->setup)(ctx, pw, &prompt, auth);
if (status == AUTH_FAILURE)
SET(auth->flags, FLAG_DISABLED);
else if (status == AUTH_NONINTERACTIVE)
goto done;
else if (status == AUTH_ERROR || user_interrupted())
goto done;
}
}
if (num_methods == 0) {
audit_failure(ctx, ctx->runas.argv,
N_(""no authentication methods""));
log_warningx(ctx, SLOG_SEND_MAIL,
N_(""Unable to initialize authentication methods.""));
debug_return_int(-1);
}
if (!standalone) {
if (IS_NONINTERACTIVE(&auth_switch[0])) {
success = AUTH_NONINTERACTIVE;
goto done;
}
pass = auth_getpass(prompt, SUDO_CONV_PROMPT_ECHO_OFF, callback);
if (pass == NULL)
break;
}
for (auth = auth_switch; auth->name; auth++) {
if (IS_DISABLED(auth))
continue;
success = auth->status = (auth->verify)(ctx, pw,
standalone ? prompt : pass, auth, callback);
if (success != AUTH_FAILURE)
break;
}
if (pass != NULL)
freezero(pass, strlen(pass));
if (success != AUTH_FAILURE)
goto done;
}
done:
(void) sigaction(SIGTSTP, &saved_sigtstp, NULL);
(void) sigprocmask(SIG_SETMASK, &omask, NULL);
switch (success) {
case AUTH_SUCCESS:
ret = true;
break;
case AUTH_INTR:
case AUTH_FAILURE:
if (ntries != 0)
SET(validated, FLAG_BAD_PASSWORD);
log_auth_failure(ctx, validated, ntries);
ret = false;
break;
case AUTH_NONINTERACTIVE:
SET(validated, FLAG_NO_USER_INPUT);
FALLTHROUGH;
case AUTH_ERROR:
default:
log_auth_failure(ctx, validated, 0);
ret = -1;
break;
}
debug_return_int(ret);
}","int
verify_user(const struct sudoers_context *VAR_0, struct passwd *VAR_1, char *VAR_2,
unsigned int VAR_3, struct sudo_conv_callback *VAR_4)
{
unsigned int VAR_5;
int VAR_6, VAR_7, VAR_8 = VAR_9;
sudo_auth *VAR_10;
sigset_t VAR_11, VAR_12;
struct sigaction VAR_13, VAR_14;
debug_decl(VAR_15, VAR_16);
if (VAR_17[0].name == NULL) {
audit_failure(VAR_0, VAR_0->runas.argv, N_(""no authentication methods""));
log_warningx(VAR_0, VAR_18,
N_(""There are no authentication methods compiled into sudo!  ""
""If you want to turn off authentication, use the ""
""--disable-authentication configure option.""));
debug_return_int(-1);
}
sigemptyset(&VAR_13.sa_mask);
VAR_13.sa_flags = VAR_19;
VAR_13.sa_handler = VAR_20;
(void) sigaction(VAR_21, &VAR_13, &VAR_14);
sigemptyset(&VAR_11);
sigaddset(&VAR_11, VAR_22);
sigaddset(&VAR_11, VAR_23);
(void) sigprocmask(VAR_24, &VAR_11, &VAR_12);
for (VAR_5 = 0; VAR_5 < VAR_25; VAR_5++) {
int VAR_26 = 0;
char *VAR_27 = NULL;
if (user_interrupted())
goto done;
if (VAR_5 != 0)
pass_warn();
for (VAR_10 = VAR_17; VAR_10->name; VAR_10++) {
if (IS_DISABLED(VAR_10))
continue;
VAR_26++;
if (VAR_10->setup != NULL) {
VAR_7 = (VAR_10->setup)(VAR_0, VAR_1, &VAR_2, VAR_10);
if (VAR_7 == VAR_9)
SET(VAR_10->flags, VAR_28);
else if (VAR_7 == VAR_29)
goto done;
else if (VAR_7 == VAR_30 || user_interrupted())
goto done;
}
}
if (VAR_26 == 0) {
audit_failure(VAR_0, VAR_0->runas.argv,
N_(""no authentication methods""));
log_warningx(VAR_0, VAR_18,
N_(""Unable to initialize authentication methods.""));
debug_return_int(-1);
}
if (!VAR_31) {
if (IS_NONINTERACTIVE(&VAR_17[0])) {
VAR_8 = VAR_29;
goto done;
}
VAR_27 = auth_getpass(VAR_2, VAR_32, VAR_4);
if (VAR_27 == NULL)
break;
}
for (VAR_10 = VAR_17; VAR_10->name; VAR_10++) {
if (IS_DISABLED(VAR_10))
continue;
VAR_8 = VAR_10->status = (VAR_10->verify)(VAR_0, VAR_1,
VAR_31 ? VAR_2 : VAR_27, VAR_10, VAR_4);
if (VAR_8 != VAR_9)
break;
}
if (VAR_27 != NULL)
freezero(VAR_27, strlen(VAR_27));
if (VAR_8 != VAR_9)
goto done;
}
done:
(void) sigaction(VAR_21, &VAR_14, NULL);
(void) sigprocmask(VAR_33, &VAR_12, NULL);
switch (VAR_8) {
case VAR_34:
VAR_6 = true;
break;
case VAR_35:
case VAR_9:
if (VAR_5 != 0)
SET(VAR_3, VAR_36);
log_auth_failure(VAR_0, VAR_3, VAR_5);
VAR_6 = false;
break;
case VAR_29:
SET(VAR_3, VAR_37);
VAR_38;
case VAR_30:
default:
log_auth_failure(VAR_0, VAR_3, 0);
VAR_6 = -1;
break;
}
debug_return_int(VAR_6);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/sudo_auth.c/vul/before/3.json,"int
verify_user(const struct sudoers_context *ctx, struct passwd *pw, char *prompt,
    unsigned int validated, struct sudo_conv_callback *callback)
{
    unsigned int ntries;
    int ret, status, success = AUTH_FAILURE;
    sudo_auth *auth;
    sigset_t mask, omask;
    struct sigaction sa, saved_sigtstp;
    debug_decl(verify_user, SUDOERS_DEBUG_AUTH);

    /* Make sure we have at least one auth method. */
    if (auth_switch[0].name == NULL) {
	audit_failure(ctx, ctx->runas.argv, N_(""no authentication methods""));
    	log_warningx(ctx, SLOG_SEND_MAIL,
	    N_(""There are no authentication methods compiled into sudo!  ""
	    ""If you want to turn off authentication, use the ""
	    ""--disable-authentication configure option.""));
	debug_return_int(-1);
    }

    /* Enable suspend during password entry. */
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = SIG_DFL;
    (void) sigaction(SIGTSTP, &sa, &saved_sigtstp);

    /*
     * We treat authentication as a critical section and block
     * keyboard-generated signals such as SIGINT and SIGQUIT
     * which might otherwise interrupt a sleep(3).
     * They are temporarily unblocked by auth_getpass().
     */
    sigemptyset(&mask);
    sigaddset(&mask, SIGINT);
    sigaddset(&mask, SIGQUIT);
    (void) sigprocmask(SIG_BLOCK, &mask, &omask);

    for (ntries = 0; ntries < def_passwd_tries; ntries++) {
	int num_methods = 0;
	char *pass = NULL;

	/* If user attempted to interrupt password verify, quit now. */
	if (user_interrupted())
	    goto done;

	if (ntries != 0)
	    pass_warn();

	/* Do any per-method setup and unconfigure the method if needed */
	for (auth = auth_switch; auth->name; auth++) {
	    if (IS_DISABLED(auth))
		continue;
	    num_methods++;
	    if (auth->setup != NULL) {
		status = (auth->setup)(ctx, pw, &prompt, auth);
		if (status == AUTH_FAILURE)
		    SET(auth->flags, FLAG_DISABLED);
		else if (status == AUTH_NONINTERACTIVE)
		    goto done;
		else if (status != AUTH_SUCCESS || user_interrupted())
		    goto done;		/* assume error msg already printed */
	    }
	}
	if (num_methods == 0) {
	    audit_failure(ctx, ctx->runas.argv,
		N_(""no authentication methods""));
	    log_warningx(ctx, SLOG_SEND_MAIL,
		N_(""Unable to initialize authentication methods.""));
	    debug_return_int(-1);
	}

	/* Get the password unless the auth function will do it for us */
	if (!standalone) {
	    if (IS_NONINTERACTIVE(&auth_switch[0])) {
		success = AUTH_NONINTERACTIVE;
		goto done;
	    }
	    pass = auth_getpass(prompt, SUDO_CONV_PROMPT_ECHO_OFF, callback);
	    if (pass == NULL)
		break;
	}

	/* Call authentication functions. */
	for (auth = auth_switch; auth->name; auth++) {
	    if (IS_DISABLED(auth))
		continue;

	    success = auth->status = (auth->verify)(ctx, pw,
		standalone ? prompt : pass, auth, callback);
	    if (success != AUTH_FAILURE)
		break;
	}
	if (pass != NULL)
	    freezero(pass, strlen(pass));

	if (success != AUTH_FAILURE)
	    goto done;
    }

done:
    /* Restore signal handlers and signal mask. */
    (void) sigaction(SIGTSTP, &saved_sigtstp, NULL);
    (void) sigprocmask(SIG_SETMASK, &omask, NULL);

    switch (success) {
	case AUTH_SUCCESS:
	    ret = true;
	    break;
	case AUTH_INTR:
	case AUTH_FAILURE:
	    if (ntries != 0)
		SET(validated, FLAG_BAD_PASSWORD);
	    log_auth_failure(ctx, validated, ntries);
	    ret = false;
	    break;
	case AUTH_NONINTERACTIVE:
	    SET(validated, FLAG_NO_USER_INPUT);
	    FALLTHROUGH;
	default:
	    log_auth_failure(ctx, validated, 0);
	    ret = -1;
	    break;
    }

    debug_return_int(ret);
}","int
verify_user(const struct sudoers_context *VAR_0, struct passwd *VAR_1, char *VAR_2,
    unsigned int VAR_3, struct sudo_conv_callback *VAR_4)
{
    unsigned int VAR_5;
    int VAR_6, VAR_7, VAR_8 = VAR_9;
    sudo_auth *VAR_10;
    sigset_t VAR_11, VAR_12;
    struct sigaction VAR_13, VAR_14;
    debug_decl(VAR_15, VAR_16);

    /* COMMENT_0 */
    if (VAR_17[0].name == NULL) {
	audit_failure(VAR_0, VAR_0->runas.argv, N_(""no authentication methods""));
    	log_warningx(VAR_0, VAR_18,
	    N_(""There are no authentication methods compiled into sudo!  ""
	    ""If you want to turn off authentication, use the ""
	    ""--disable-authentication configure option.""));
	debug_return_int(-1);
    }

    /* COMMENT_1 */
    sigemptyset(&VAR_13.sa_mask);
    VAR_13.sa_flags = VAR_19;
    VAR_13.sa_handler = VAR_20;
    (void) sigaction(VAR_21, &VAR_13, &VAR_14);

    /* COMMENT_2 */
                                                              
                                                            
                                                  
                                                        
       
    sigemptyset(&VAR_11);
    sigaddset(&VAR_11, VAR_22);
    sigaddset(&VAR_11, VAR_23);
    (void) sigprocmask(VAR_24, &VAR_11, &VAR_12);

    for (VAR_5 = 0; VAR_5 < VAR_25; VAR_5++) {
	int VAR_26 = 0;
	char *VAR_27 = NULL;

	/* COMMENT_8 */
	if (user_interrupted())
	    goto done;

	if (VAR_5 != 0)
	    pass_warn();

	/* COMMENT_9 */
	for (VAR_10 = VAR_17; VAR_10->name; VAR_10++) {
	    if (IS_DISABLED(VAR_10))
		continue;
	    VAR_26++;
	    if (VAR_10->setup != NULL) {
		VAR_7 = (VAR_10->setup)(VAR_0, VAR_1, &VAR_2, VAR_10);
		if (VAR_7 == VAR_9)
		    SET(VAR_10->flags, VAR_28);
		else if (VAR_7 == VAR_29)
		    goto done;
		else if (VAR_7 != VAR_30 || user_interrupted())
		    goto done;		/* COMMENT_10 */
	    }
	}
	if (VAR_26 == 0) {
	    audit_failure(VAR_0, VAR_0->runas.argv,
		N_(""no authentication methods""));
	    log_warningx(VAR_0, VAR_18,
		N_(""Unable to initialize authentication methods.""));
	    debug_return_int(-1);
	}

	/* COMMENT_11 */
	if (!VAR_31) {
	    if (IS_NONINTERACTIVE(&VAR_17[0])) {
		VAR_8 = VAR_29;
		goto done;
	    }
	    VAR_27 = auth_getpass(VAR_2, VAR_32, VAR_4);
	    if (VAR_27 == NULL)
		break;
	}

	/* COMMENT_12 */
	for (VAR_10 = VAR_17; VAR_10->name; VAR_10++) {
	    if (IS_DISABLED(VAR_10))
		continue;

	    VAR_8 = VAR_10->status = (VAR_10->verify)(VAR_0, VAR_1,
		VAR_31 ? VAR_2 : VAR_27, VAR_10, VAR_4);
	    if (VAR_8 != VAR_9)
		break;
	}
	if (VAR_27 != NULL)
	    freezero(VAR_27, strlen(VAR_27));

	if (VAR_8 != VAR_9)
	    goto done;
    }

done:
    /* COMMENT_13 */
    (void) sigaction(VAR_21, &VAR_14, NULL);
    (void) sigprocmask(VAR_33, &VAR_12, NULL);

    switch (VAR_8) {
	case VAR_30:
	    VAR_6 = true;
	    break;
	case VAR_34:
	case VAR_9:
	    if (VAR_5 != 0)
		SET(VAR_3, VAR_35);
	    log_auth_failure(VAR_0, VAR_3, VAR_5);
	    VAR_6 = false;
	    break;
	case VAR_29:
	    SET(VAR_3, VAR_36);
	    VAR_37;
	default:
	    log_auth_failure(VAR_0, VAR_3, 0);
	    VAR_6 = -1;
	    break;
    }

    debug_return_int(VAR_6);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/sudo_auth.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -58,7 +58,7 @@
 		    SET(auth->flags, FLAG_DISABLED);
 		else if (status == AUTH_NONINTERACTIVE)
 		    goto done;
-		else if (status == AUTH_ERROR || user_interrupted())
+		else if (status != AUTH_SUCCESS || user_interrupted())
 		    goto done;		/* assume error msg already printed */
 	    }
 	}
@@ -117,7 +117,6 @@
 	case AUTH_NONINTERACTIVE:
 	    SET(validated, FLAG_NO_USER_INPUT);
 	    FALLTHROUGH;
-	case AUTH_ERROR:
 	default:
 	    log_auth_failure(ctx, validated, 0);
 	    ret = -1;","{'deleted_lines': ['\t\telse if (status == AUTH_ERROR || user_interrupted())', '\tcase AUTH_ERROR:'], 'added_lines': ['\t\telse if (status != AUTH_SUCCESS || user_interrupted())']}",True,"Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.",7.0,HIGH,2,test,2023-09-09T20:07:04Z,4
CVE-2023-42465,['CWE-Other'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,sudo-project/sudo,"Try to make sudo less vulnerable to ROWHAMMER attacks.

We now use ROWHAMMER-resistent values for ALLOW, DENY, AUTH_SUCCESS,
AUTH_FAILURE, AUTH_ERROR and AUTH_NONINTERACTIVE.  In addition, we
explicitly test for expected values instead of using a negated test
against an error value.  In the parser match functions this means
explicitly checking for ALLOW or DENY instead of accepting anything
that is not set to UNSPEC.

Thanks to Andrew J. Adiletta, M. Caner Tol, Yarkin Doroz, and Berk
Sunar, all affiliated with the Vernam Applied Cryptography and
Cybersecurity Lab at Worcester Polytechnic Institute, for the report.
Paper preprint: https://arxiv.org/abs/2309.02545",7873f8334c8d31031f8cfa83bd97ac6029309e4f,https://github.com/sudo-project/sudo/commit/7873f8334c8d31031f8cfa83bd97ac6029309e4f,plugins/sudoers/auth/sudo_auth.c,sudo_auth_cleanup,"int
sudo_auth_cleanup(const struct sudoers_context *ctx, struct passwd *pw,
bool force)
{
sudo_auth *auth;
debug_decl(sudo_auth_cleanup, SUDOERS_DEBUG_AUTH);
for (auth = auth_switch; auth->name; auth++) {
if (auth->cleanup && !IS_DISABLED(auth)) {
int status = (auth->cleanup)(ctx, pw, auth, force);
if (status == AUTH_ERROR) {
debug_return_int(-1);
}
}
}
debug_return_int(0);
}","int
sudo_auth_cleanup(const struct sudoers_context *VAR_0, struct passwd *VAR_1,
bool VAR_2)
{
sudo_auth *VAR_3;
debug_decl(VAR_4, VAR_5);
for (VAR_3 = VAR_6; VAR_3->name; VAR_3++) {
if (VAR_3->cleanup && !IS_DISABLED(VAR_3)) {
int VAR_7 = (VAR_3->cleanup)(VAR_0, VAR_1, VAR_3, VAR_2);
if (VAR_7 == VAR_8) {
debug_return_int(-1);
}
}
}
debug_return_int(0);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/sudo_auth.c/vul/before/4.json,"int
sudo_auth_cleanup(const struct sudoers_context *ctx, struct passwd *pw,
    bool force)
{
    sudo_auth *auth;
    debug_decl(sudo_auth_cleanup, SUDOERS_DEBUG_AUTH);

    /* Call cleanup routines. */
    for (auth = auth_switch; auth->name; auth++) {
	if (auth->cleanup && !IS_DISABLED(auth)) {
	    int status = (auth->cleanup)(ctx, pw, auth, force);
	    if (status != AUTH_SUCCESS) {
		/* Assume error msg already printed. */
		debug_return_int(-1);
	    }
	}
    }
    debug_return_int(0);
}","int
sudo_auth_cleanup(const struct sudoers_context *VAR_0, struct passwd *VAR_1,
    bool VAR_2)
{
    sudo_auth *VAR_3;
    debug_decl(VAR_4, VAR_5);

    /* COMMENT_0 */
    for (VAR_3 = VAR_6; VAR_3->name; VAR_3++) {
	if (VAR_3->cleanup && !IS_DISABLED(VAR_3)) {
	    int VAR_7 = (VAR_3->cleanup)(VAR_0, VAR_1, VAR_3, VAR_2);
	    if (VAR_7 != VAR_8) {
		/* COMMENT_1 */
		debug_return_int(-1);
	    }
	}
    }
    debug_return_int(0);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/sudo_auth.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -9,7 +9,7 @@
     for (auth = auth_switch; auth->name; auth++) {
 	if (auth->cleanup && !IS_DISABLED(auth)) {
 	    int status = (auth->cleanup)(ctx, pw, auth, force);
-	    if (status == AUTH_ERROR) {
+	    if (status != AUTH_SUCCESS) {
 		/* Assume error msg already printed. */
 		debug_return_int(-1);
 	    }","{'deleted_lines': ['\t    if (status == AUTH_ERROR) {'], 'added_lines': ['\t    if (status != AUTH_SUCCESS) {']}",True,"Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.",7.0,HIGH,2,test,2023-09-09T20:07:04Z,4
CVE-2023-42465,['CWE-Other'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,sudo-project/sudo,"Try to make sudo less vulnerable to ROWHAMMER attacks.

We now use ROWHAMMER-resistent values for ALLOW, DENY, AUTH_SUCCESS,
AUTH_FAILURE, AUTH_ERROR and AUTH_NONINTERACTIVE.  In addition, we
explicitly test for expected values instead of using a negated test
against an error value.  In the parser match functions this means
explicitly checking for ALLOW or DENY instead of accepting anything
that is not set to UNSPEC.

Thanks to Andrew J. Adiletta, M. Caner Tol, Yarkin Doroz, and Berk
Sunar, all affiliated with the Vernam Applied Cryptography and
Cybersecurity Lab at Worcester Polytechnic Institute, for the report.
Paper preprint: https://arxiv.org/abs/2309.02545",7873f8334c8d31031f8cfa83bd97ac6029309e4f,https://github.com/sudo-project/sudo/commit/7873f8334c8d31031f8cfa83bd97ac6029309e4f,plugins/sudoers/lookup.c,sudoers_lookup_check,"static int
sudoers_lookup_check(struct sudo_nss *nss, struct sudoers_context *ctx,
unsigned int *validated, struct cmnd_info *info, time_t now,
sudoers_lookup_callback_fn_t callback, void *cb_data,
struct cmndspec **matching_cs, struct defaults_list **defs)
{
struct cmndspec *cs;
struct privilege *priv;
struct userspec *us;
struct member *matching_user;
debug_decl(sudoers_lookup_check, SUDOERS_DEBUG_PARSER);
init_cmnd_info(ctx, info);
TAILQ_FOREACH_REVERSE(us, &nss->parse_tree->userspecs, userspec_list, entries) {
int user_match = userlist_matches(nss->parse_tree, ctx->user.pw, &us->users);
if (user_match != ALLOW) {
if (callback != NULL && user_match != UNSPEC) {
callback(nss->parse_tree, us, user_match, NULL, UNSPEC, NULL,
UNSPEC, UNSPEC, UNSPEC, cb_data);
}
continue;
}
CLR(*validated, FLAG_NO_USER);
TAILQ_FOREACH_REVERSE(priv, &us->privileges, privilege_list, entries) {
int host_match = hostlist_matches(nss->parse_tree, ctx->user.pw,
&priv->hostlist);
if (host_match == ALLOW) {
CLR(*validated, FLAG_NO_HOST);
} else {
if (callback != NULL) {
callback(nss->parse_tree, us, user_match, priv, host_match,
NULL, UNSPEC, UNSPEC, UNSPEC, cb_data);
}
continue;
}
TAILQ_FOREACH_REVERSE(cs, &priv->cmndlist, cmndspec_list, entries) {
int cmnd_match = UNSPEC;
int date_match = UNSPEC;
int runas_match = UNSPEC;
if (cs->notbefore != UNSPEC) {
date_match = now < cs->notbefore ? DENY : ALLOW;
}
if (cs->notafter != UNSPEC) {
date_match = now > cs->notafter ? DENY : ALLOW;
}
if (date_match != DENY) {
matching_user = NULL;
runas_match = runaslist_matches(nss->parse_tree,
cs->runasuserlist, cs->runasgrouplist, &matching_user,
NULL);
if (runas_match == ALLOW) {
cmnd_match = cmnd_matches(nss->parse_tree, cs->cmnd,
cs->runchroot, info);
}
}
if (callback != NULL) {
callback(nss->parse_tree, us, user_match, priv, host_match,
cs, date_match, runas_match, cmnd_match, cb_data);
}
if (cmnd_match != UNSPEC) {
if (matching_user && matching_user->type == MYSELF) {
sudo_pw_delref(ctx->runas.pw);
sudo_pw_addref(ctx->user.pw);
ctx->runas.pw = ctx->user.pw;
}
*matching_cs = cs;
*defs = &priv->defaults;
sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO,
""userspec matched @ %s:%d:%d: %s"",
us->file ? us->file : ""???"", us->line, us->column,
cmnd_match ? ""allowed"" : ""denied"");
debug_return_int(cmnd_match);
}
free(info->cmnd_path);
init_cmnd_info(ctx, info);
}
}
}
debug_return_int(UNSPEC);
}","static int
sudoers_lookup_check(struct sudo_nss *VAR_0, struct sudoers_context *VAR_1,
unsigned int *VAR_2, struct cmnd_info *VAR_3, time_t VAR_4,
sudoers_lookup_callback_fn_t VAR_5, void *VAR_6,
struct cmndspec **VAR_7, struct defaults_list **VAR_8)
{
struct cmndspec *VAR_9;
struct privilege *VAR_10;
struct userspec *VAR_11;
struct member *VAR_12;
debug_decl(VAR_13, VAR_14);
init_cmnd_info(VAR_1, VAR_3);
TAILQ_FOREACH_REVERSE(VAR_11, &VAR_0->parse_tree->userspecs, VAR_15, VAR_16) {
int VAR_17 = userlist_matches(VAR_0->parse_tree, VAR_1->user.pw, &VAR_11->users);
if (VAR_17 != VAR_18) {
if (VAR_5 != NULL && VAR_17 != VAR_19) {
VAR_5(VAR_0->parse_tree, VAR_11, VAR_17, NULL, VAR_19, NULL,
VAR_19, VAR_19, VAR_19, VAR_6);
}
continue;
}
CLR(*VAR_2, VAR_20);
TAILQ_FOREACH_REVERSE(VAR_10, &VAR_11->privileges, VAR_21, VAR_16) {
int VAR_22 = hostlist_matches(VAR_0->parse_tree, VAR_1->user.pw,
&VAR_10->hostlist);
if (VAR_22 == VAR_18) {
CLR(*VAR_2, VAR_23);
} else {
if (VAR_5 != NULL) {
VAR_5(VAR_0->parse_tree, VAR_11, VAR_17, VAR_10, VAR_22,
NULL, VAR_19, VAR_19, VAR_19, VAR_6);
}
continue;
}
TAILQ_FOREACH_REVERSE(VAR_9, &VAR_10->cmndlist, VAR_24, VAR_16) {
int VAR_25 = VAR_19;
int VAR_26 = VAR_19;
int VAR_27 = VAR_19;
if (VAR_9->notbefore != VAR_19) {
VAR_26 = VAR_4 < VAR_9->notbefore ? VAR_28 : VAR_18;
}
if (VAR_9->notafter != VAR_19) {
VAR_26 = VAR_4 > VAR_9->notafter ? VAR_28 : VAR_18;
}
if (VAR_26 != VAR_28) {
VAR_12 = NULL;
VAR_27 = runaslist_matches(VAR_0->parse_tree,
VAR_9->runasuserlist, VAR_9->runasgrouplist, &VAR_12,
NULL);
if (VAR_27 == VAR_18) {
VAR_25 = cmnd_matches(VAR_0->parse_tree, VAR_9->cmnd,
VAR_9->runchroot, VAR_3);
}
}
if (VAR_5 != NULL) {
VAR_5(VAR_0->parse_tree, VAR_11, VAR_17, VAR_10, VAR_22,
VAR_9, VAR_26, VAR_27, VAR_25, VAR_6);
}
if (VAR_25 != VAR_19) {
if (VAR_12 && VAR_12->type == VAR_29) {
sudo_pw_delref(VAR_1->runas.pw);
sudo_pw_addref(VAR_1->user.pw);
VAR_1->runas.pw = VAR_1->user.pw;
}
*VAR_7 = VAR_9;
*VAR_8 = &VAR_10->defaults;
sudo_debug_printf(VAR_30|VAR_31,
""userspec matched @ %s:%d:%d: %s"",
VAR_11->file ? VAR_11->file : ""???"", VAR_11->line, VAR_11->column,
VAR_25 ? ""allowed"" : ""denied"");
debug_return_int(VAR_25);
}
free(VAR_3->cmnd_path);
init_cmnd_info(VAR_1, VAR_3);
}
}
}
debug_return_int(VAR_19);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/lookup.c/vul/before/1.json,"static int
sudoers_lookup_check(struct sudo_nss *nss, struct sudoers_context *ctx,
    unsigned int *validated, struct cmnd_info *info, time_t now,
    sudoers_lookup_callback_fn_t callback, void *cb_data,
    struct cmndspec **matching_cs, struct defaults_list **defs)
{
    struct cmndspec *cs;
    struct privilege *priv;
    struct userspec *us;
    struct member *matching_user;
    debug_decl(sudoers_lookup_check, SUDOERS_DEBUG_PARSER);

    init_cmnd_info(ctx, info);

    TAILQ_FOREACH_REVERSE(us, &nss->parse_tree->userspecs, userspec_list, entries) {
	int user_match = userlist_matches(nss->parse_tree, ctx->user.pw, &us->users);
	if (user_match != ALLOW) {
	    if (callback != NULL && user_match == DENY) {
		callback(nss->parse_tree, us, user_match, NULL, UNSPEC, NULL,
		    UNSPEC, UNSPEC, UNSPEC, cb_data);
	    }
	    continue;
	}
	CLR(*validated, FLAG_NO_USER);
	TAILQ_FOREACH_REVERSE(priv, &us->privileges, privilege_list, entries) {
	    int host_match = hostlist_matches(nss->parse_tree, ctx->user.pw,
		&priv->hostlist);
	    if (host_match == ALLOW) {
		CLR(*validated, FLAG_NO_HOST);
	    } else {
		if (callback != NULL) {
		    callback(nss->parse_tree, us, user_match, priv, host_match,
			NULL, UNSPEC, UNSPEC, UNSPEC, cb_data);
		}
		continue;
	    }
	    TAILQ_FOREACH_REVERSE(cs, &priv->cmndlist, cmndspec_list, entries) {
		int cmnd_match = UNSPEC;
		int date_match = UNSPEC;
		int runas_match = UNSPEC;

		if (cs->notbefore != UNSPEC) {
		    date_match = now < cs->notbefore ? DENY : ALLOW;
		}
		if (cs->notafter != UNSPEC) {
		    date_match = now > cs->notafter ? DENY : ALLOW;
		}
		if (date_match != DENY) {
		    matching_user = NULL;
		    runas_match = runaslist_matches(nss->parse_tree,
			cs->runasuserlist, cs->runasgrouplist, &matching_user,
			NULL);
		    if (runas_match == ALLOW) {
			cmnd_match = cmnd_matches(nss->parse_tree, cs->cmnd,
			    cs->runchroot, info);
		    }
		}
		if (callback != NULL) {
		    callback(nss->parse_tree, us, user_match, priv, host_match,
			cs, date_match, runas_match, cmnd_match, cb_data);
		}

		if (SPECIFIED(cmnd_match)) {
		    /*
		     * If user is running command as themselves,
		     * set ctx->runas.pw = ctx->user.pw.
		     * XXX - hack, want more general solution
		     */
		    if (matching_user && matching_user->type == MYSELF) {
			sudo_pw_delref(ctx->runas.pw);
			sudo_pw_addref(ctx->user.pw);
			ctx->runas.pw = ctx->user.pw;
		    }
		    *matching_cs = cs;
		    *defs = &priv->defaults;
		    sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO,
			""userspec matched @ %s:%d:%d: %s"",
			us->file ? us->file : ""???"", us->line, us->column,
			cmnd_match ? ""allowed"" : ""denied"");
		    debug_return_int(cmnd_match);
		}
		free(info->cmnd_path);
		init_cmnd_info(ctx, info);
	    }
	}
    }
    debug_return_int(UNSPEC);
}","static int
sudoers_lookup_check(struct sudo_nss *VAR_0, struct sudoers_context *VAR_1,
    unsigned int *VAR_2, struct cmnd_info *VAR_3, time_t VAR_4,
    sudoers_lookup_callback_fn_t VAR_5, void *VAR_6,
    struct cmndspec **VAR_7, struct defaults_list **VAR_8)
{
    struct cmndspec *VAR_9;
    struct privilege *VAR_10;
    struct userspec *VAR_11;
    struct member *VAR_12;
    debug_decl(VAR_13, VAR_14);

    init_cmnd_info(VAR_1, VAR_3);

    TAILQ_FOREACH_REVERSE(VAR_11, &VAR_0->parse_tree->userspecs, VAR_15, VAR_16) {
	int VAR_17 = userlist_matches(VAR_0->parse_tree, VAR_1->user.pw, &VAR_11->users);
	if (VAR_17 != VAR_18) {
	    if (VAR_5 != NULL && VAR_17 == VAR_19) {
		VAR_5(VAR_0->parse_tree, VAR_11, VAR_17, NULL, VAR_20, NULL,
		    VAR_20, VAR_20, VAR_20, VAR_6);
	    }
	    continue;
	}
	CLR(*VAR_2, VAR_21);
	TAILQ_FOREACH_REVERSE(VAR_10, &VAR_11->privileges, VAR_22, VAR_16) {
	    int VAR_23 = hostlist_matches(VAR_0->parse_tree, VAR_1->user.pw,
		&VAR_10->hostlist);
	    if (VAR_23 == VAR_18) {
		CLR(*VAR_2, VAR_24);
	    } else {
		if (VAR_5 != NULL) {
		    VAR_5(VAR_0->parse_tree, VAR_11, VAR_17, VAR_10, VAR_23,
			NULL, VAR_20, VAR_20, VAR_20, VAR_6);
		}
		continue;
	    }
	    TAILQ_FOREACH_REVERSE(VAR_9, &VAR_10->cmndlist, VAR_25, VAR_16) {
		int VAR_26 = VAR_20;
		int VAR_27 = VAR_20;
		int VAR_28 = VAR_20;

		if (VAR_9->notbefore != VAR_20) {
		    VAR_27 = VAR_4 < VAR_9->notbefore ? VAR_19 : VAR_18;
		}
		if (VAR_9->notafter != VAR_20) {
		    VAR_27 = VAR_4 > VAR_9->notafter ? VAR_19 : VAR_18;
		}
		if (VAR_27 != VAR_19) {
		    VAR_12 = NULL;
		    VAR_28 = runaslist_matches(VAR_0->parse_tree,
			VAR_9->runasuserlist, VAR_9->runasgrouplist, &VAR_12,
			NULL);
		    if (VAR_28 == VAR_18) {
			VAR_26 = cmnd_matches(VAR_0->parse_tree, VAR_9->cmnd,
			    VAR_9->runchroot, VAR_3);
		    }
		}
		if (VAR_5 != NULL) {
		    VAR_5(VAR_0->parse_tree, VAR_11, VAR_17, VAR_10, VAR_23,
			VAR_9, VAR_27, VAR_28, VAR_26, VAR_6);
		}

		if (SPECIFIED(VAR_26)) {
		    /* COMMENT_0 */
                                                  
                                          
                                               
         
		    if (VAR_12 && VAR_12->type == VAR_29) {
			sudo_pw_delref(VAR_1->runas.pw);
			sudo_pw_addref(VAR_1->user.pw);
			VAR_1->runas.pw = VAR_1->user.pw;
		    }
		    *VAR_7 = VAR_9;
		    *VAR_8 = &VAR_10->defaults;
		    sudo_debug_printf(VAR_30|VAR_31,
			""userspec matched @ %s:%d:%d: %s"",
			VAR_11->file ? VAR_11->file : ""???"", VAR_11->line, VAR_11->column,
			VAR_26 ? ""allowed"" : ""denied"");
		    debug_return_int(VAR_26);
		}
		free(VAR_3->cmnd_path);
		init_cmnd_info(VAR_1, VAR_3);
	    }
	}
    }
    debug_return_int(VAR_20);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/lookup.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -15,7 +15,7 @@
     TAILQ_FOREACH_REVERSE(us, &nss->parse_tree->userspecs, userspec_list, entries) {
 	int user_match = userlist_matches(nss->parse_tree, ctx->user.pw, &us->users);
 	if (user_match != ALLOW) {
-	    if (callback != NULL && user_match != UNSPEC) {
+	    if (callback != NULL && user_match == DENY) {
 		callback(nss->parse_tree, us, user_match, NULL, UNSPEC, NULL,
 		    UNSPEC, UNSPEC, UNSPEC, cb_data);
 	    }
@@ -60,7 +60,7 @@
 			cs, date_match, runas_match, cmnd_match, cb_data);
 		}
 
-		if (cmnd_match != UNSPEC) {
+		if (SPECIFIED(cmnd_match)) {
 		    /*
 		     * If user is running command as themselves,
 		     * set ctx->runas.pw = ctx->user.pw.","{'deleted_lines': ['\t    if (callback != NULL && user_match != UNSPEC) {', '\t\tif (cmnd_match != UNSPEC) {'], 'added_lines': ['\t    if (callback != NULL && user_match == DENY) {', '\t\tif (SPECIFIED(cmnd_match)) {']}",True,"Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.",7.0,HIGH,2,test,2023-09-09T20:07:04Z,4
CVE-2023-42465,['CWE-Other'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,sudo-project/sudo,"Try to make sudo less vulnerable to ROWHAMMER attacks.

We now use ROWHAMMER-resistent values for ALLOW, DENY, AUTH_SUCCESS,
AUTH_FAILURE, AUTH_ERROR and AUTH_NONINTERACTIVE.  In addition, we
explicitly test for expected values instead of using a negated test
against an error value.  In the parser match functions this means
explicitly checking for ALLOW or DENY instead of accepting anything
that is not set to UNSPEC.

Thanks to Andrew J. Adiletta, M. Caner Tol, Yarkin Doroz, and Berk
Sunar, all affiliated with the Vernam Applied Cryptography and
Cybersecurity Lab at Worcester Polytechnic Institute, for the report.
Paper preprint: https://arxiv.org/abs/2309.02545",7873f8334c8d31031f8cfa83bd97ac6029309e4f,https://github.com/sudo-project/sudo/commit/7873f8334c8d31031f8cfa83bd97ac6029309e4f,plugins/sudoers/auth/passwd.c,sudo_passwd_verify,"int
sudo_passwd_verify(const struct sudoers_context *ctx, struct passwd *pw,
const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback)
{
char des_pass[9], *epass;
char *pw_epasswd = auth->data;
size_t pw_len;
int matched = 0;
debug_decl(sudo_passwd_verify, SUDOERS_DEBUG_AUTH);
if (pass[0] == '\0')
debug_return_int(pw_epasswd[0] ? AUTH_FAILURE : AUTH_SUCCESS);
pw_len = strlen(pw_epasswd);
if (pw_len == DESLEN || HAS_AGEINFO(pw_epasswd, pw_len)) {
strlcpy(des_pass, pass, sizeof(des_pass));
pass = des_pass;
}
epass = (char *) crypt(pass, pw_epasswd);
if (epass != NULL) {
if (HAS_AGEINFO(pw_epasswd, pw_len) && strlen(epass) == DESLEN)
matched = !strncmp(pw_epasswd, epass, DESLEN);
else
matched = !strcmp(pw_epasswd, epass);
}
explicit_bzero(des_pass, sizeof(des_pass));
debug_return_int(matched ? AUTH_SUCCESS : AUTH_FAILURE);
}","int
sudo_passwd_verify(const struct sudoers_context *VAR_0, struct passwd *VAR_1,
const char *VAR_2, sudo_auth *VAR_3, struct sudo_conv_callback *VAR_4)
{
char VAR_5[9], *VAR_6;
char *VAR_7 = VAR_3->data;
size_t VAR_8;
int VAR_9 = 0;
debug_decl(VAR_10, VAR_11);
if (VAR_2[0] == '\0')
debug_return_int(VAR_7[0] ? VAR_12 : VAR_13);
VAR_8 = strlen(VAR_7);
if (VAR_8 == VAR_14 || HAS_AGEINFO(VAR_7, VAR_8)) {
strlcpy(VAR_5, VAR_2, sizeof(VAR_5));
VAR_2 = VAR_5;
}
VAR_6 = (char *) crypt(VAR_2, VAR_7);
if (VAR_6 != NULL) {
if (HAS_AGEINFO(VAR_7, VAR_8) && strlen(VAR_6) == VAR_14)
VAR_9 = !strncmp(VAR_7, VAR_6, VAR_14);
else
VAR_9 = !strcmp(VAR_7, VAR_6);
}
explicit_bzero(VAR_5, sizeof(VAR_5));
debug_return_int(VAR_9 ? VAR_13 : VAR_12);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/passwd.c/vul/before/0.json,"int
sudo_passwd_verify(const struct sudoers_context *ctx, struct passwd *pw,
    const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback)
{
    char des_pass[9], *epass;
    char *pw_epasswd = auth->data;
    size_t pw_len;
    int ret;
    debug_decl(sudo_passwd_verify, SUDOERS_DEBUG_AUTH);

    /* An empty plain-text password must match an empty encrypted password. */
    if (pass[0] == '\0')
	debug_return_int(pw_epasswd[0] ? AUTH_FAILURE : AUTH_SUCCESS);

    /*
     * Truncate to 8 chars if standard DES since not all crypt()'s do this.
     */
    pw_len = strlen(pw_epasswd);
    if (pw_len == DESLEN || HAS_AGEINFO(pw_epasswd, pw_len)) {
	(void)strlcpy(des_pass, pass, sizeof(des_pass));
	pass = des_pass;
    }

    /*
     * Normal UN*X password check.
     * HP-UX may add aging info (separated by a ',') at the end so
     * only compare the first DESLEN characters in that case.
     */
    epass = (char *) crypt(pass, pw_epasswd);
    ret = AUTH_FAILURE;
    if (epass != NULL) {
	if (HAS_AGEINFO(pw_epasswd, pw_len) && strlen(epass) == DESLEN) {
	    if (strncmp(pw_epasswd, epass, DESLEN) == 0)
		ret = AUTH_SUCCESS;
	} else {
	    if (strcmp(pw_epasswd, epass) == 0)
		ret = AUTH_SUCCESS;
	}
    }

    explicit_bzero(des_pass, sizeof(des_pass));

    debug_return_int(ret);
}","int
sudo_passwd_verify(const struct sudoers_context *VAR_0, struct passwd *VAR_1,
    const char *VAR_2, sudo_auth *VAR_3, struct sudo_conv_callback *VAR_4)
{
    char VAR_5[9], *VAR_6;
    char *VAR_7 = VAR_3->data;
    size_t VAR_8;
    int VAR_9;
    debug_decl(VAR_10, VAR_11);

    /* COMMENT_0 */
    if (VAR_2[0] == '\0')
	debug_return_int(VAR_7[0] ? VAR_12 : VAR_13);

    /* COMMENT_1 */
                                                                           
       
    VAR_8 = strlen(VAR_7);
    if (VAR_8 == VAR_14 || HAS_AGEINFO(VAR_7, VAR_8)) {
	(void)strlcpy(VAR_5, VAR_2, sizeof(VAR_5));
	VAR_2 = VAR_5;
    }

    /* COMMENT_4 */
                                  
                                                                  
                                                             
       
    VAR_6 = (char *) crypt(VAR_2, VAR_7);
    VAR_9 = VAR_12;
    if (VAR_6 != NULL) {
	if (HAS_AGEINFO(VAR_7, VAR_8) && strlen(VAR_6) == VAR_14) {
	    if (strncmp(VAR_7, VAR_6, VAR_14) == 0)
		VAR_9 = VAR_13;
	} else {
	    if (strcmp(VAR_7, VAR_6) == 0)
		VAR_9 = VAR_13;
	}
    }

    explicit_bzero(VAR_5, sizeof(VAR_5));

    debug_return_int(VAR_9);
}",sudo-project/sudo/7873f8334c8d31031f8cfa83bd97ac6029309e4f/passwd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
     char des_pass[9], *epass;
     char *pw_epasswd = auth->data;
     size_t pw_len;
-    int matched = 0;
+    int ret;
     debug_decl(sudo_passwd_verify, SUDOERS_DEBUG_AUTH);
 
     /* An empty plain-text password must match an empty encrypted password. */
@@ -17,7 +17,7 @@
      */
     pw_len = strlen(pw_epasswd);
     if (pw_len == DESLEN || HAS_AGEINFO(pw_epasswd, pw_len)) {
-	strlcpy(des_pass, pass, sizeof(des_pass));
+	(void)strlcpy(des_pass, pass, sizeof(des_pass));
 	pass = des_pass;
     }
 
@@ -27,14 +27,18 @@
      * only compare the first DESLEN characters in that case.
      */
     epass = (char *) crypt(pass, pw_epasswd);
+    ret = AUTH_FAILURE;
     if (epass != NULL) {
-	if (HAS_AGEINFO(pw_epasswd, pw_len) && strlen(epass) == DESLEN)
-	    matched = !strncmp(pw_epasswd, epass, DESLEN);
-	else
-	    matched = !strcmp(pw_epasswd, epass);
+	if (HAS_AGEINFO(pw_epasswd, pw_len) && strlen(epass) == DESLEN) {
+	    if (strncmp(pw_epasswd, epass, DESLEN) == 0)
+		ret = AUTH_SUCCESS;
+	} else {
+	    if (strcmp(pw_epasswd, epass) == 0)
+		ret = AUTH_SUCCESS;
+	}
     }
 
     explicit_bzero(des_pass, sizeof(des_pass));
 
-    debug_return_int(matched ? AUTH_SUCCESS : AUTH_FAILURE);
+    debug_return_int(ret);
 }","{'deleted_lines': ['    int matched = 0;', '\tstrlcpy(des_pass, pass, sizeof(des_pass));', '\tif (HAS_AGEINFO(pw_epasswd, pw_len) && strlen(epass) == DESLEN)', '\t    matched = !strncmp(pw_epasswd, epass, DESLEN);', '\telse', '\t    matched = !strcmp(pw_epasswd, epass);', '    debug_return_int(matched ? AUTH_SUCCESS : AUTH_FAILURE);'], 'added_lines': ['    int ret;', '\t(void)strlcpy(des_pass, pass, sizeof(des_pass));', '    ret = AUTH_FAILURE;', '\tif (HAS_AGEINFO(pw_epasswd, pw_len) && strlen(epass) == DESLEN) {', '\t    if (strncmp(pw_epasswd, epass, DESLEN) == 0)', '\t\tret = AUTH_SUCCESS;', '\t} else {', '\t    if (strcmp(pw_epasswd, epass) == 0)', '\t\tret = AUTH_SUCCESS;', '\t}', '    debug_return_int(ret);']}",True,"Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.",7.0,HIGH,2,test,2023-09-09T20:07:04Z,4
CVE-2023-43641,['CWE-787'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,lipnitsk/libcue,"Check that the array index isn't negative. This fixes CVE-2023-43641.

Signed-off-by: Kevin Backhouse <kevinbackhouse@github.com>",fdf72c8bded8d24cfa0608b8e97f2eed210a920e,https://github.com/lipnitsk/libcue/commit/fdf72c8bded8d24cfa0608b8e97f2eed210a920e,cd.c,track_set_index,"void track_set_index(Track *track, int i, long ind)
{
if (i > MAXINDEX) {
fprintf(stderr, ""too many indexes\n"");
return;
}
track->index[i] = ind;
}","void track_set_index(Track *VAR_0, int VAR_1, long VAR_2)
{
if (VAR_1 > VAR_3) {
fprintf(VAR_4, ""too many indexes\n"");
return;
}
VAR_0->index[VAR_1] = VAR_2;
}",lipnitsk/libcue/fdf72c8bded8d24cfa0608b8e97f2eed210a920e/cd.c/vul/before/0.json,"void track_set_index(Track *track, int i, long ind)
{
	if (i < 0 || i > MAXINDEX) {
		fprintf(stderr, ""too many indexes\n"");
                return;
        }

	track->index[i] = ind;
}","void track_set_index(Track *VAR_0, int VAR_1, long VAR_2)
{
	if (VAR_1 < 0 || VAR_1 > VAR_3) {
		fprintf(VAR_4, ""too many indexes\n"");
                return;
        }

	VAR_0->index[VAR_1] = VAR_2;
}",lipnitsk/libcue/fdf72c8bded8d24cfa0608b8e97f2eed210a920e/cd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 void track_set_index(Track *track, int i, long ind)
 {
-	if (i > MAXINDEX) {
+	if (i < 0 || i > MAXINDEX) {
 		fprintf(stderr, ""too many indexes\n"");
                 return;
         }","{'deleted_lines': ['\tif (i > MAXINDEX) {'], 'added_lines': ['\tif (i < 0 || i > MAXINDEX) {']}",True,"libcue provides an API for parsing and extracting data from CUE sheets. Versions 2.2.1 and prior are vulnerable to out-of-bounds array access. A user of the GNOME desktop environment can be exploited by downloading a cue sheet from a malicious webpage. Because the file is saved to `~/Downloads`, it is then automatically scanned by tracker-miners. And because it has a .cue filename extension, tracker-miners use libcue to parse the file. The file exploits the vulnerability in libcue to gain code execution. This issue is patched in version 2.3.0.",8.8,HIGH,2,test,2023-09-27T19:22:43Z,4
CVE-2023-31439,['CWE-354'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N,1,systemd,journalctl: address review comments,3c896258067991832a1e896093b748aebfc873e1,https://github.com/systemd/systemd/commit/3c896258067991832a1e896093b748aebfc873e1,src/libsystemd/sd-journal/journal-verify.c,journal_file_verify,"int journal_file_verify(
JournalFile *f,
const char *key,
usec_t *first_contained, usec_t *last_validated, usec_t *last_contained,
bool show_progress) {
int r;
Object *o;
uint64_t p = 0, last_epoch = 0, last_tag_realtime = 0, last_sealed_realtime = 0;
uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0, min_entry_realtime = 0, max_entry_realtime = 0;
sd_id128_t entry_boot_id = {};  
bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, min_entry_realtime_set = false, found_main_entry_array = false;
uint64_t n_objects = 0, n_entries = 0, n_data = 0, n_fields = 0, n_data_hash_tables = 0, n_field_hash_tables = 0, n_entry_arrays = 0, n_tags = 0;
usec_t last_usec = 0;
_cleanup_close_ int data_fd = -EBADF, entry_fd = -EBADF, entry_array_fd = -EBADF;
_cleanup_fclose_ FILE *data_fp = NULL, *entry_fp = NULL, *entry_array_fp = NULL;
MMapFileDescriptor *cache_data_fd = NULL, *cache_entry_fd = NULL, *cache_entry_array_fd = NULL;
unsigned i;
bool found_last = false;
const char *tmp_dir = NULL;
MMapCache *m;
#if HAVE_GCRYPT
uint64_t last_tag = 0;
#endif
assert(f);
if (key) {
#if HAVE_GCRYPT
r = journal_file_parse_verification_key(f, key);
if (r < 0) {
log_error(""Failed to parse seed."");
return r;
}
#else
return -EOPNOTSUPP;
#endif
} else if (JOURNAL_HEADER_SEALED(f->header))
return -ENOKEY;
r = var_tmp_dir(&tmp_dir);
if (r < 0) {
log_error_errno(r, ""Failed to determine temporary directory: %m"");
goto fail;
}
data_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);
if (data_fd < 0) {
r = log_error_errno(data_fd, ""Failed to create data file: %m"");
goto fail;
}
entry_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);
if (entry_fd < 0) {
r = log_error_errno(entry_fd, ""Failed to create entry file: %m"");
goto fail;
}
entry_array_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);
if (entry_array_fd < 0) {
r = log_error_errno(entry_array_fd,
""Failed to create entry array file: %m"");
goto fail;
}
m = mmap_cache_fd_cache(f->cache_fd);
cache_data_fd = mmap_cache_add_fd(m, data_fd, PROT_READ|PROT_WRITE);
if (!cache_data_fd) {
r = log_oom();
goto fail;
}
cache_entry_fd = mmap_cache_add_fd(m, entry_fd, PROT_READ|PROT_WRITE);
if (!cache_entry_fd) {
r = log_oom();
goto fail;
}
cache_entry_array_fd = mmap_cache_add_fd(m, entry_array_fd, PROT_READ|PROT_WRITE);
if (!cache_entry_array_fd) {
r = log_oom();
goto fail;
}
r = take_fdopen_unlocked(&data_fd, ""w+"", &data_fp);
if (r < 0) {
log_error_errno(r, ""Failed to open data file stream: %m"");
goto fail;
}
r = take_fdopen_unlocked(&entry_fd, ""w+"", &entry_fp);
if (r < 0) {
log_error_errno(r, ""Failed to open entry file stream: %m"");
goto fail;
}
r = take_fdopen_unlocked(&entry_array_fd, ""w+"", &entry_array_fp);
if (r < 0) {
log_error_errno(r, ""Failed to open entry array file stream: %m"");
goto fail;
}
if (le32toh(f->header->compatible_flags) & ~HEADER_COMPATIBLE_SUPPORTED) {
log_error(""Cannot verify file with unknown extensions."");
r = -EOPNOTSUPP;
goto fail;
}
for (i = 0; i < sizeof(f->header->reserved); i++)
if (f->header->reserved[i] != 0) {
error(offsetof(Header, reserved[i]), ""Reserved field is non-zero"");
r = -EBADMSG;
goto fail;
}
p = le64toh(f->header->header_size);
for (;;) {
if (le64toh(f->header->tail_object_offset) == 0)
break;
if (show_progress)
draw_progress(scale_progress(0x7FFF, p, le64toh(f->header->tail_object_offset)), &last_usec);
r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);
if (r < 0) {
error_errno(p, r, ""Invalid object: %m"");
goto fail;
}
if (p > le64toh(f->header->tail_object_offset)) {
error(offsetof(Header, tail_object_offset),
""Invalid tail object pointer (%""PRIu64"" > %""PRIu64"")"",
p,
le64toh(f->header->tail_object_offset));
r = -EBADMSG;
goto fail;
}
n_objects++;
r = journal_file_object_verify(f, p, o);
if (r < 0) {
error_errno(p, r, ""Invalid object contents: %m"");
goto fail;
}
if (!!(o->object.flags & OBJECT_COMPRESSED_XZ) +
!!(o->object.flags & OBJECT_COMPRESSED_LZ4) +
!!(o->object.flags & OBJECT_COMPRESSED_ZSTD) > 1) {
error(p, ""Object has multiple compression flags set (flags: 0x%x)"", o->object.flags);
r = -EINVAL;
goto fail;
}
if ((o->object.flags & OBJECT_COMPRESSED_XZ) && !JOURNAL_HEADER_COMPRESSED_XZ(f->header)) {
error(p, ""XZ compressed object in file without XZ compression"");
r = -EBADMSG;
goto fail;
}
if ((o->object.flags & OBJECT_COMPRESSED_LZ4) && !JOURNAL_HEADER_COMPRESSED_LZ4(f->header)) {
error(p, ""LZ4 compressed object in file without LZ4 compression"");
r = -EBADMSG;
goto fail;
}
if ((o->object.flags & OBJECT_COMPRESSED_ZSTD) && !JOURNAL_HEADER_COMPRESSED_ZSTD(f->header)) {
error(p, ""ZSTD compressed object in file without ZSTD compression"");
r = -EBADMSG;
goto fail;
}
switch (o->object.type) {
case OBJECT_DATA:
r = write_uint64(data_fp, p);
if (r < 0)
goto fail;
n_data++;
break;
case OBJECT_FIELD:
n_fields++;
break;
case OBJECT_ENTRY:
if (JOURNAL_HEADER_SEALED(f->header) && n_tags <= 0) {
error(p, ""First entry before first tag"");
r = -EBADMSG;
goto fail;
}
r = write_uint64(entry_fp, p);
if (r < 0)
goto fail;
if (le64toh(o->entry.realtime) < last_tag_realtime) {
error(p,
""Older entry after newer tag (%""PRIu64"" < %""PRIu64"")"",
le64toh(o->entry.realtime),
last_tag_realtime);
r = -EBADMSG;
goto fail;
}
if (!entry_seqnum_set &&
le64toh(o->entry.seqnum) != le64toh(f->header->head_entry_seqnum)) {
error(p,
""Head entry sequence number incorrect (%""PRIu64"" != %""PRIu64"")"",
le64toh(o->entry.seqnum),
le64toh(f->header->head_entry_seqnum));
r = -EBADMSG;
goto fail;
}
if (entry_seqnum_set &&
entry_seqnum >= le64toh(o->entry.seqnum)) {
error(p,
""Entry sequence number out of synchronization (%""PRIu64"" >= %""PRIu64"")"",
entry_seqnum,
le64toh(o->entry.seqnum));
r = -EBADMSG;
goto fail;
}
entry_seqnum = le64toh(o->entry.seqnum);
entry_seqnum_set = true;
if (entry_monotonic_set &&
sd_id128_equal(entry_boot_id, o->entry.boot_id) &&
entry_monotonic > le64toh(o->entry.monotonic)) {
error(p,
""Entry timestamp out of synchronization (%""PRIu64"" > %""PRIu64"")"",
entry_monotonic,
le64toh(o->entry.monotonic));
r = -EBADMSG;
goto fail;
}
entry_monotonic = le64toh(o->entry.monotonic);
entry_boot_id = o->entry.boot_id;
entry_monotonic_set = true;
if (!entry_realtime_set &&
le64toh(o->entry.realtime) != le64toh(f->header->head_entry_realtime)) {
error(p,
""Head entry realtime timestamp incorrect (%""PRIu64"" != %""PRIu64"")"",
le64toh(o->entry.realtime),
le64toh(f->header->head_entry_realtime));
r = -EBADMSG;
goto fail;
}
entry_realtime = le64toh(o->entry.realtime);
entry_realtime_set = true;
if (max_entry_realtime < le64toh(o->entry.realtime))
max_entry_realtime = le64toh(o->entry.realtime);
if (!min_entry_realtime_set || min_entry_realtime > le64toh(o->entry.realtime)) {
min_entry_realtime = le64toh(o->entry.realtime);
min_entry_realtime_set = true;
}
n_entries++;
break;
case OBJECT_DATA_HASH_TABLE:
r = verify_hash_table(o, p, &n_data_hash_tables,
le64toh(f->header->data_hash_table_offset),
le64toh(f->header->data_hash_table_size));
if (r < 0)
goto fail;
break;
case OBJECT_FIELD_HASH_TABLE:
r = verify_hash_table(o, p, &n_field_hash_tables,
le64toh(f->header->field_hash_table_offset),
le64toh(f->header->field_hash_table_size));
if (r < 0)
goto fail;
break;
case OBJECT_ENTRY_ARRAY:
r = write_uint64(entry_array_fp, p);
if (r < 0)
goto fail;
if (p == le64toh(f->header->entry_array_offset)) {
if (found_main_entry_array) {
error(p, ""More than one main entry array"");
r = -EBADMSG;
goto fail;
}
found_main_entry_array = true;
}
n_entry_arrays++;
break;
case OBJECT_TAG:
if (!JOURNAL_HEADER_SEALED(f->header)) {
error(p, ""Tag object in file without sealing"");
r = -EBADMSG;
goto fail;
}
if (le64toh(o->tag.seqnum) != n_tags + 1) {
error(p,
""Tag sequence number out of synchronization (%""PRIu64"" != %""PRIu64"")"",
le64toh(o->tag.seqnum),
n_tags + 1);
r = -EBADMSG;
goto fail;
}
if (le64toh(o->tag.epoch) < last_epoch) {
error(p,
""Epoch sequence out of synchronization (%""PRIu64"" < %""PRIu64"")"",
le64toh(o->tag.epoch),
last_epoch);
r = -EBADMSG;
goto fail;
}
#if HAVE_GCRYPT
if (JOURNAL_HEADER_SEALED(f->header)) {
uint64_t q, rt;
debug(p, ""Checking tag %""PRIu64""..."", le64toh(o->tag.seqnum));
rt = f->fss_start_usec + le64toh(o->tag.epoch) * f->fss_interval_usec;
if (entry_realtime_set && entry_realtime >= rt + f->fss_interval_usec) {
error(p,
""tag/entry realtime timestamp out of synchronization (%""PRIu64"" >= %""PRIu64"")"",
entry_realtime,
rt + f->fss_interval_usec);
r = -EBADMSG;
goto fail;
}
if (max_entry_realtime >= rt + f->fss_interval_usec) {
error(p,
""entry realtime timestamp too late with respect to tag (%""PRIu64"" < %""PRIu64"")"",
max_entry_realtime,
rt + f->fss_interval_usec);
r = -EBADMSG;
goto fail;
}
if (min_entry_realtime_set && min_entry_realtime < rt) {
error(p,
""entry realtime timestamp too early with respect to tag out of synchronization (%""PRIu64"" >= %""PRIu64"")"",
min_entry_realtime,
rt);
r = -EBADMSG;
goto fail;
}
min_entry_realtime_set = false;
r = journal_file_fsprg_seek(f, le64toh(o->tag.epoch));
if (r < 0)
goto fail;
r = journal_file_hmac_start(f);
if (r < 0)
goto fail;
if (last_tag == 0) {
r = journal_file_hmac_put_header(f);
if (r < 0)
goto fail;
q = le64toh(f->header->header_size);
} else
q = last_tag;
while (q <= p) {
r = journal_file_move_to_object(f, OBJECT_UNUSED, q, &o);
if (r < 0)
goto fail;
r = journal_file_hmac_put_object(f, OBJECT_UNUSED, o, q);
if (r < 0)
goto fail;
q = q + ALIGN64(le64toh(o->object.size));
}
r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);
if (r < 0)
goto fail;
if (memcmp(o->tag.tag, gcry_md_read(f->hmac, 0), TAG_LENGTH) != 0) {
error(p, ""Tag failed verification"");
r = -EBADMSG;
goto fail;
}
f->hmac_running = false;
last_tag_realtime = rt;
last_sealed_realtime = entry_realtime;
}
last_tag = p + ALIGN64(le64toh(o->object.size));
#endif
last_epoch = le64toh(o->tag.epoch);
n_tags++;
break;
}
if (p == le64toh(f->header->tail_object_offset)) {
found_last = true;
break;
}
p = p + ALIGN64(le64toh(o->object.size));
};
if (!found_last && le64toh(f->header->tail_object_offset) != 0) {
error(le64toh(f->header->tail_object_offset),
""Tail object pointer dead (%""PRIu64"" != 0)"",
le64toh(f->header->tail_object_offset));
r = -EBADMSG;
goto fail;
}
if (n_objects != le64toh(f->header->n_objects)) {
error(offsetof(Header, n_objects),
""Object number mismatch (%""PRIu64"" != %""PRIu64"")"",
n_objects,
le64toh(f->header->n_objects));
r = -EBADMSG;
goto fail;
}
if (n_entries != le64toh(f->header->n_entries)) {
error(offsetof(Header, n_entries),
""Entry number mismatch (%""PRIu64"" != %""PRIu64"")"",
n_entries,
le64toh(f->header->n_entries));
r = -EBADMSG;
goto fail;
}
if (JOURNAL_HEADER_CONTAINS(f->header, n_data) &&
n_data != le64toh(f->header->n_data)) {
error(offsetof(Header, n_data),
""Data number mismatch (%""PRIu64"" != %""PRIu64"")"",
n_data,
le64toh(f->header->n_data));
r = -EBADMSG;
goto fail;
}
if (JOURNAL_HEADER_CONTAINS(f->header, n_fields) &&
n_fields != le64toh(f->header->n_fields)) {
error(offsetof(Header, n_fields),
""Field number mismatch (%""PRIu64"" != %""PRIu64"")"",
n_fields,
le64toh(f->header->n_fields));
r = -EBADMSG;
goto fail;
}
if (JOURNAL_HEADER_CONTAINS(f->header, n_tags) &&
n_tags != le64toh(f->header->n_tags)) {
error(offsetof(Header, n_tags),
""Tag number mismatch (%""PRIu64"" != %""PRIu64"")"",
n_tags,
le64toh(f->header->n_tags));
r = -EBADMSG;
goto fail;
}
if (JOURNAL_HEADER_CONTAINS(f->header, n_entry_arrays) &&
n_entry_arrays != le64toh(f->header->n_entry_arrays)) {
error(offsetof(Header, n_entry_arrays),
""Entry array number mismatch (%""PRIu64"" != %""PRIu64"")"",
n_entry_arrays,
le64toh(f->header->n_entry_arrays));
r = -EBADMSG;
goto fail;
}
if (!found_main_entry_array && le64toh(f->header->entry_array_offset) != 0) {
error(0, ""Missing main entry array"");
r = -EBADMSG;
goto fail;
}
if (entry_seqnum_set &&
entry_seqnum != le64toh(f->header->tail_entry_seqnum)) {
error(offsetof(Header, tail_entry_seqnum),
""Tail entry sequence number incorrect (%""PRIu64"" != %""PRIu64"")"",
entry_seqnum,
le64toh(f->header->tail_entry_seqnum));
r = -EBADMSG;
goto fail;
}
if (entry_monotonic_set &&
(sd_id128_equal(entry_boot_id, f->header->tail_entry_boot_id) &&
JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(f->header) &&
entry_monotonic != le64toh(f->header->tail_entry_monotonic))) {
error(0,
""Invalid tail monotonic timestamp (%""PRIu64"" != %""PRIu64"")"",
entry_monotonic,
le64toh(f->header->tail_entry_monotonic));
r = -EBADMSG;
goto fail;
}
if (entry_realtime_set && entry_realtime != le64toh(f->header->tail_entry_realtime)) {
error(0,
""Invalid tail realtime timestamp (%""PRIu64"" != %""PRIu64"")"",
entry_realtime,
le64toh(f->header->tail_entry_realtime));
r = -EBADMSG;
goto fail;
}
if (fflush(data_fp) != 0) {
r = log_error_errno(errno, ""Failed to flush data file stream: %m"");
goto fail;
}
if (fflush(entry_fp) != 0) {
r = log_error_errno(errno, ""Failed to flush entry file stream: %m"");
goto fail;
}
if (fflush(entry_array_fp) != 0) {
r = log_error_errno(errno, ""Failed to flush entry array file stream: %m"");
goto fail;
}
r = verify_entry_array(f,
cache_data_fd, n_data,
cache_entry_fd, n_entries,
cache_entry_array_fd, n_entry_arrays,
&last_usec,
show_progress);
if (r < 0)
goto fail;
r = verify_data_hash_table(f,
cache_data_fd, n_data,
cache_entry_fd, n_entries,
cache_entry_array_fd, n_entry_arrays,
&last_usec,
show_progress);
if (r < 0)
goto fail;
if (show_progress)
flush_progress();
mmap_cache_fd_free(cache_data_fd);
mmap_cache_fd_free(cache_entry_fd);
mmap_cache_fd_free(cache_entry_array_fd);
if (first_contained)
*first_contained = le64toh(f->header->head_entry_realtime);
if (last_validated)
*last_validated = last_sealed_realtime;
if (last_contained)
*last_contained = le64toh(f->header->tail_entry_realtime);
return 0;
fail:
if (show_progress)
flush_progress();
log_error(""File corruption detected at %s:%""PRIu64"" (of %""PRIu64"" bytes, %""PRIu64""%%)."",
f->path,
p,
(uint64_t) f->last_stat.st_size,
100U * p / (uint64_t) f->last_stat.st_size);
if (cache_data_fd)
mmap_cache_fd_free(cache_data_fd);
if (cache_entry_fd)
mmap_cache_fd_free(cache_entry_fd);
if (cache_entry_array_fd)
mmap_cache_fd_free(cache_entry_array_fd);
return r;
}","int journal_file_verify(
JournalFile *VAR_0,
const char *VAR_1,
usec_t *VAR_2, usec_t *VAR_3, usec_t *VAR_4,
bool VAR_5) {
int VAR_6;
Object *VAR_7;
uint64_t VAR_8 = 0, VAR_9 = 0, VAR_10 = 0, VAR_11 = 0;
uint64_t VAR_12 = 0, VAR_13 = 0, VAR_14 = 0, VAR_15 = 0, VAR_16 = 0;
sd_id128_t VAR_17 = {};  
bool VAR_18 = false, VAR_19 = false, VAR_20 = false, VAR_21 = false, VAR_22 = false;
uint64_t VAR_23 = 0, VAR_24 = 0, VAR_25 = 0, VAR_26 = 0, VAR_27 = 0, VAR_28 = 0, VAR_29 = 0, VAR_30 = 0;
usec_t VAR_31 = 0;
_cleanup_close_ int VAR_32 = -VAR_33, VAR_34 = -VAR_33, VAR_35 = -VAR_33;
_cleanup_fclose_ VAR_36 *VAR_37 = NULL, *VAR_38 = NULL, *VAR_39 = NULL;
MMapFileDescriptor *VAR_40 = NULL, *VAR_41 = NULL, *VAR_42 = NULL;
unsigned VAR_43;
bool VAR_44 = false;
const char *VAR_45 = NULL;
MMapCache *VAR_46;
#if VAR_47
uint64_t VAR_48 = 0;
#endif
assert(VAR_0);
if (VAR_1) {
#if VAR_47
VAR_6 = journal_file_parse_verification_key(VAR_0, VAR_1);
if (VAR_6 < 0) {
log_error(""Failed to parse seed."");
return VAR_6;
}
#else
return -VAR_49;
#endif
} else if (JOURNAL_HEADER_SEALED(VAR_0->header))
return -VAR_50;
VAR_6 = var_tmp_dir(&VAR_45);
if (VAR_6 < 0) {
log_error_errno(VAR_6, ""Failed to determine temporary directory: %m"");
goto fail;
}
VAR_32 = open_tmpfile_unlinkable(VAR_45, VAR_51 | VAR_52);
if (VAR_32 < 0) {
VAR_6 = log_error_errno(VAR_32, ""Failed to create data file: %m"");
goto fail;
}
VAR_34 = open_tmpfile_unlinkable(VAR_45, VAR_51 | VAR_52);
if (VAR_34 < 0) {
VAR_6 = log_error_errno(VAR_34, ""Failed to create entry file: %m"");
goto fail;
}
VAR_35 = open_tmpfile_unlinkable(VAR_45, VAR_51 | VAR_52);
if (VAR_35 < 0) {
VAR_6 = log_error_errno(VAR_35,
""Failed to create entry array file: %m"");
goto fail;
}
VAR_46 = mmap_cache_fd_cache(VAR_0->cache_fd);
VAR_40 = mmap_cache_add_fd(VAR_46, VAR_32, VAR_53|VAR_54);
if (!VAR_40) {
VAR_6 = log_oom();
goto fail;
}
VAR_41 = mmap_cache_add_fd(VAR_46, VAR_34, VAR_53|VAR_54);
if (!VAR_41) {
VAR_6 = log_oom();
goto fail;
}
VAR_42 = mmap_cache_add_fd(VAR_46, VAR_35, VAR_53|VAR_54);
if (!VAR_42) {
VAR_6 = log_oom();
goto fail;
}
VAR_6 = take_fdopen_unlocked(&VAR_32, ""w+"", &VAR_37);
if (VAR_6 < 0) {
log_error_errno(VAR_6, ""Failed to open data file stream: %m"");
goto fail;
}
VAR_6 = take_fdopen_unlocked(&VAR_34, ""w+"", &VAR_38);
if (VAR_6 < 0) {
log_error_errno(VAR_6, ""Failed to open entry file stream: %m"");
goto fail;
}
VAR_6 = take_fdopen_unlocked(&VAR_35, ""w+"", &VAR_39);
if (VAR_6 < 0) {
log_error_errno(VAR_6, ""Failed to open entry array file stream: %m"");
goto fail;
}
if (le32toh(VAR_0->header->compatible_flags) & ~VAR_55) {
log_error(""Cannot verify file with unknown extensions."");
VAR_6 = -VAR_49;
goto fail;
}
for (VAR_43 = 0; VAR_43 < sizeof(VAR_0->header->reserved); VAR_43++)
if (VAR_0->header->reserved[VAR_43] != 0) {
error(offsetof(VAR_56, VAR_57[VAR_43]), ""Reserved field is non-zero"");
VAR_6 = -VAR_58;
goto fail;
}
VAR_8 = le64toh(VAR_0->header->header_size);
for (;;) {
if (le64toh(VAR_0->header->tail_object_offset) == 0)
break;
if (VAR_5)
draw_progress(scale_progress(0x7FFF, VAR_8, le64toh(VAR_0->header->tail_object_offset)), &VAR_31);
VAR_6 = journal_file_move_to_object(VAR_0, VAR_59, VAR_8, &VAR_7);
if (VAR_6 < 0) {
error_errno(VAR_8, VAR_6, ""Invalid object: %m"");
goto fail;
}
if (VAR_8 > le64toh(VAR_0->header->tail_object_offset)) {
error(offsetof(VAR_56, VAR_60),
""Invalid tail object pointer (%""VAR_61"" > %""VAR_61"")"",
VAR_8,
le64toh(VAR_0->header->tail_object_offset));
VAR_6 = -VAR_58;
goto fail;
}
VAR_23++;
VAR_6 = journal_file_object_verify(VAR_0, VAR_8, VAR_7);
if (VAR_6 < 0) {
error_errno(VAR_8, VAR_6, ""Invalid object contents: %m"");
goto fail;
}
if (!!(VAR_7->object.flags & VAR_62) +
!!(VAR_7->object.flags & VAR_63) +
!!(VAR_7->object.flags & VAR_64) > 1) {
error(VAR_8, ""Object has multiple compression flags set (flags: 0x%x)"", VAR_7->object.flags);
VAR_6 = -VAR_65;
goto fail;
}
if ((VAR_7->object.flags & VAR_62) && !JOURNAL_HEADER_COMPRESSED_XZ(VAR_0->header)) {
error(VAR_8, ""XZ compressed object in file without XZ compression"");
VAR_6 = -VAR_58;
goto fail;
}
if ((VAR_7->object.flags & VAR_63) && !JOURNAL_HEADER_COMPRESSED_LZ4(VAR_0->header)) {
error(VAR_8, ""LZ4 compressed object in file without LZ4 compression"");
VAR_6 = -VAR_58;
goto fail;
}
if ((VAR_7->object.flags & VAR_64) && !JOURNAL_HEADER_COMPRESSED_ZSTD(VAR_0->header)) {
error(VAR_8, ""ZSTD compressed object in file without ZSTD compression"");
VAR_6 = -VAR_58;
goto fail;
}
switch (VAR_7->object.type) {
case VAR_66:
VAR_6 = write_uint64(VAR_37, VAR_8);
if (VAR_6 < 0)
goto fail;
VAR_25++;
break;
case VAR_67:
VAR_26++;
break;
case VAR_68:
if (JOURNAL_HEADER_SEALED(VAR_0->header) && VAR_30 <= 0) {
error(VAR_8, ""First entry before first tag"");
VAR_6 = -VAR_58;
goto fail;
}
VAR_6 = write_uint64(VAR_38, VAR_8);
if (VAR_6 < 0)
goto fail;
if (le64toh(VAR_7->entry.realtime) < VAR_10) {
error(VAR_8,
""Older entry after newer tag (%""VAR_61"" < %""VAR_61"")"",
le64toh(VAR_7->entry.realtime),
VAR_10);
VAR_6 = -VAR_58;
goto fail;
}
if (!VAR_18 &&
le64toh(VAR_7->entry.seqnum) != le64toh(VAR_0->header->head_entry_seqnum)) {
error(VAR_8,
""Head entry sequence number incorrect (%""VAR_61"" != %""VAR_61"")"",
le64toh(VAR_7->entry.seqnum),
le64toh(VAR_0->header->head_entry_seqnum));
VAR_6 = -VAR_58;
goto fail;
}
if (VAR_18 &&
VAR_12 >= le64toh(VAR_7->entry.seqnum)) {
error(VAR_8,
""Entry sequence number out of synchronization (%""VAR_61"" >= %""VAR_61"")"",
VAR_12,
le64toh(VAR_7->entry.seqnum));
VAR_6 = -VAR_58;
goto fail;
}
VAR_12 = le64toh(VAR_7->entry.seqnum);
VAR_18 = true;
if (VAR_19 &&
sd_id128_equal(VAR_17, VAR_7->entry.boot_id) &&
VAR_13 > le64toh(VAR_7->entry.monotonic)) {
error(VAR_8,
""Entry timestamp out of synchronization (%""VAR_61"" > %""VAR_61"")"",
VAR_13,
le64toh(VAR_7->entry.monotonic));
VAR_6 = -VAR_58;
goto fail;
}
VAR_13 = le64toh(VAR_7->entry.monotonic);
VAR_17 = VAR_7->entry.boot_id;
VAR_19 = true;
if (!VAR_20 &&
le64toh(VAR_7->entry.realtime) != le64toh(VAR_0->header->head_entry_realtime)) {
error(VAR_8,
""Head entry realtime timestamp incorrect (%""VAR_61"" != %""VAR_61"")"",
le64toh(VAR_7->entry.realtime),
le64toh(VAR_0->header->head_entry_realtime));
VAR_6 = -VAR_58;
goto fail;
}
VAR_14 = le64toh(VAR_7->entry.realtime);
VAR_20 = true;
if (VAR_16 < le64toh(VAR_7->entry.realtime))
VAR_16 = le64toh(VAR_7->entry.realtime);
if (!VAR_21 || VAR_15 > le64toh(VAR_7->entry.realtime)) {
VAR_15 = le64toh(VAR_7->entry.realtime);
VAR_21 = true;
}
VAR_24++;
break;
case VAR_69:
VAR_6 = verify_hash_table(VAR_7, VAR_8, &VAR_27,
le64toh(VAR_0->header->data_hash_table_offset),
le64toh(VAR_0->header->data_hash_table_size));
if (VAR_6 < 0)
goto fail;
break;
case VAR_70:
VAR_6 = verify_hash_table(VAR_7, VAR_8, &VAR_28,
le64toh(VAR_0->header->field_hash_table_offset),
le64toh(VAR_0->header->field_hash_table_size));
if (VAR_6 < 0)
goto fail;
break;
case VAR_71:
VAR_6 = write_uint64(VAR_39, VAR_8);
if (VAR_6 < 0)
goto fail;
if (VAR_8 == le64toh(VAR_0->header->entry_array_offset)) {
if (VAR_22) {
error(VAR_8, ""More than one main entry array"");
VAR_6 = -VAR_58;
goto fail;
}
VAR_22 = true;
}
VAR_29++;
break;
case VAR_72:
if (!JOURNAL_HEADER_SEALED(VAR_0->header)) {
error(VAR_8, ""Tag object in file without sealing"");
VAR_6 = -VAR_58;
goto fail;
}
if (le64toh(VAR_7->tag.seqnum) != VAR_30 + 1) {
error(VAR_8,
""Tag sequence number out of synchronization (%""VAR_61"" != %""VAR_61"")"",
le64toh(VAR_7->tag.seqnum),
VAR_30 + 1);
VAR_6 = -VAR_58;
goto fail;
}
if (le64toh(VAR_7->tag.epoch) < VAR_9) {
error(VAR_8,
""Epoch sequence out of synchronization (%""VAR_61"" < %""VAR_61"")"",
le64toh(VAR_7->tag.epoch),
VAR_9);
VAR_6 = -VAR_58;
goto fail;
}
#if VAR_47
if (JOURNAL_HEADER_SEALED(VAR_0->header)) {
uint64_t VAR_73, VAR_74;
debug(VAR_8, ""Checking tag %""VAR_61""..."", le64toh(VAR_7->tag.seqnum));
VAR_74 = VAR_0->fss_start_usec + le64toh(VAR_7->tag.epoch) * VAR_0->fss_interval_usec;
if (VAR_20 && VAR_14 >= VAR_74 + VAR_0->fss_interval_usec) {
error(VAR_8,
""tag/entry realtime timestamp out of synchronization (%""VAR_61"" >= %""VAR_61"")"",
VAR_14,
VAR_74 + VAR_0->fss_interval_usec);
VAR_6 = -VAR_58;
goto fail;
}
if (VAR_16 >= VAR_74 + VAR_0->fss_interval_usec) {
error(VAR_8,
""entry realtime timestamp too late with respect to tag (%""VAR_61"" < %""VAR_61"")"",
VAR_16,
VAR_74 + VAR_0->fss_interval_usec);
VAR_6 = -VAR_58;
goto fail;
}
if (VAR_21 && VAR_15 < VAR_74) {
error(VAR_8,
""entry realtime timestamp too early with respect to tag out of synchronization (%""VAR_61"" >= %""VAR_61"")"",
VAR_15,
VAR_74);
VAR_6 = -VAR_58;
goto fail;
}
VAR_21 = false;
VAR_6 = journal_file_fsprg_seek(VAR_0, le64toh(VAR_7->tag.epoch));
if (VAR_6 < 0)
goto fail;
VAR_6 = journal_file_hmac_start(VAR_0);
if (VAR_6 < 0)
goto fail;
if (VAR_48 == 0) {
VAR_6 = journal_file_hmac_put_header(VAR_0);
if (VAR_6 < 0)
goto fail;
VAR_73 = le64toh(VAR_0->header->header_size);
} else
VAR_73 = VAR_48;
while (VAR_73 <= VAR_8) {
VAR_6 = journal_file_move_to_object(VAR_0, VAR_59, VAR_73, &VAR_7);
if (VAR_6 < 0)
goto fail;
VAR_6 = journal_file_hmac_put_object(VAR_0, VAR_59, VAR_7, VAR_73);
if (VAR_6 < 0)
goto fail;
VAR_73 = VAR_73 + ALIGN64(le64toh(VAR_7->object.size));
}
VAR_6 = journal_file_move_to_object(VAR_0, VAR_59, VAR_8, &VAR_7);
if (VAR_6 < 0)
goto fail;
if (memcmp(VAR_7->tag.tag, gcry_md_read(VAR_0->hmac, 0), VAR_75) != 0) {
error(VAR_8, ""Tag failed verification"");
VAR_6 = -VAR_58;
goto fail;
}
VAR_0->hmac_running = false;
VAR_10 = VAR_74;
VAR_11 = VAR_14;
}
VAR_48 = VAR_8 + ALIGN64(le64toh(VAR_7->object.size));
#endif
VAR_9 = le64toh(VAR_7->tag.epoch);
VAR_30++;
break;
}
if (VAR_8 == le64toh(VAR_0->header->tail_object_offset)) {
VAR_44 = true;
break;
}
VAR_8 = VAR_8 + ALIGN64(le64toh(VAR_7->object.size));
};
if (!VAR_44 && le64toh(VAR_0->header->tail_object_offset) != 0) {
error(le64toh(VAR_0->header->tail_object_offset),
""Tail object pointer dead (%""VAR_61"" != 0)"",
le64toh(VAR_0->header->tail_object_offset));
VAR_6 = -VAR_58;
goto fail;
}
if (VAR_23 != le64toh(VAR_0->header->n_objects)) {
error(offsetof(VAR_56, VAR_23),
""Object number mismatch (%""VAR_61"" != %""VAR_61"")"",
VAR_23,
le64toh(VAR_0->header->n_objects));
VAR_6 = -VAR_58;
goto fail;
}
if (VAR_24 != le64toh(VAR_0->header->n_entries)) {
error(offsetof(VAR_56, VAR_24),
""Entry number mismatch (%""VAR_61"" != %""VAR_61"")"",
VAR_24,
le64toh(VAR_0->header->n_entries));
VAR_6 = -VAR_58;
goto fail;
}
if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_25) &&
VAR_25 != le64toh(VAR_0->header->n_data)) {
error(offsetof(VAR_56, VAR_25),
""Data number mismatch (%""VAR_61"" != %""VAR_61"")"",
VAR_25,
le64toh(VAR_0->header->n_data));
VAR_6 = -VAR_58;
goto fail;
}
if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_26) &&
VAR_26 != le64toh(VAR_0->header->n_fields)) {
error(offsetof(VAR_56, VAR_26),
""Field number mismatch (%""VAR_61"" != %""VAR_61"")"",
VAR_26,
le64toh(VAR_0->header->n_fields));
VAR_6 = -VAR_58;
goto fail;
}
if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_30) &&
VAR_30 != le64toh(VAR_0->header->n_tags)) {
error(offsetof(VAR_56, VAR_30),
""Tag number mismatch (%""VAR_61"" != %""VAR_61"")"",
VAR_30,
le64toh(VAR_0->header->n_tags));
VAR_6 = -VAR_58;
goto fail;
}
if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_29) &&
VAR_29 != le64toh(VAR_0->header->n_entry_arrays)) {
error(offsetof(VAR_56, VAR_29),
""Entry array number mismatch (%""VAR_61"" != %""VAR_61"")"",
VAR_29,
le64toh(VAR_0->header->n_entry_arrays));
VAR_6 = -VAR_58;
goto fail;
}
if (!VAR_22 && le64toh(VAR_0->header->entry_array_offset) != 0) {
error(0, ""Missing main entry array"");
VAR_6 = -VAR_58;
goto fail;
}
if (VAR_18 &&
VAR_12 != le64toh(VAR_0->header->tail_entry_seqnum)) {
error(offsetof(VAR_56, VAR_76),
""Tail entry sequence number incorrect (%""VAR_61"" != %""VAR_61"")"",
VAR_12,
le64toh(VAR_0->header->tail_entry_seqnum));
VAR_6 = -VAR_58;
goto fail;
}
if (VAR_19 &&
(sd_id128_equal(VAR_17, VAR_0->header->tail_entry_boot_id) &&
JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(VAR_0->header) &&
VAR_13 != le64toh(VAR_0->header->tail_entry_monotonic))) {
error(0,
""Invalid tail monotonic timestamp (%""VAR_61"" != %""VAR_61"")"",
VAR_13,
le64toh(VAR_0->header->tail_entry_monotonic));
VAR_6 = -VAR_58;
goto fail;
}
if (VAR_20 && VAR_14 != le64toh(VAR_0->header->tail_entry_realtime)) {
error(0,
""Invalid tail realtime timestamp (%""VAR_61"" != %""VAR_61"")"",
VAR_14,
le64toh(VAR_0->header->tail_entry_realtime));
VAR_6 = -VAR_58;
goto fail;
}
if (fflush(VAR_37) != 0) {
VAR_6 = log_error_errno(VAR_77, ""Failed to flush data file stream: %m"");
goto fail;
}
if (fflush(VAR_38) != 0) {
VAR_6 = log_error_errno(VAR_77, ""Failed to flush entry file stream: %m"");
goto fail;
}
if (fflush(VAR_39) != 0) {
VAR_6 = log_error_errno(VAR_77, ""Failed to flush entry array file stream: %m"");
goto fail;
}
VAR_6 = verify_entry_array(VAR_0,
VAR_40, VAR_25,
VAR_41, VAR_24,
VAR_42, VAR_29,
&VAR_31,
VAR_5);
if (VAR_6 < 0)
goto fail;
VAR_6 = verify_data_hash_table(VAR_0,
VAR_40, VAR_25,
VAR_41, VAR_24,
VAR_42, VAR_29,
&VAR_31,
VAR_5);
if (VAR_6 < 0)
goto fail;
if (VAR_5)
flush_progress();
mmap_cache_fd_free(VAR_40);
mmap_cache_fd_free(VAR_41);
mmap_cache_fd_free(VAR_42);
if (VAR_2)
*VAR_2 = le64toh(VAR_0->header->head_entry_realtime);
if (VAR_3)
*VAR_3 = VAR_11;
if (VAR_4)
*VAR_4 = le64toh(VAR_0->header->tail_entry_realtime);
return 0;
fail:
if (VAR_5)
flush_progress();
log_error(""File corruption detected at %s:%""VAR_61"" (of %""VAR_61"" bytes, %""VAR_61""%%)."",
VAR_0->path,
VAR_8,
(uint64_t) VAR_0->last_stat.st_size,
100U * VAR_8 / (uint64_t) VAR_0->last_stat.st_size);
if (VAR_40)
mmap_cache_fd_free(VAR_40);
if (VAR_41)
mmap_cache_fd_free(VAR_41);
if (VAR_42)
mmap_cache_fd_free(VAR_42);
return VAR_6;
}",systemd/3c896258067991832a1e896093b748aebfc873e1/journal-verify.c/vul/before/0.json,"int journal_file_verify(
                JournalFile *f,
                const char *key,
                usec_t *first_contained, usec_t *last_validated, usec_t *last_contained,
                bool show_progress) {
        int r;
        Object *o;
        uint64_t p = 0, last_epoch = 0, last_tag_realtime = 0, last_sealed_realtime = 0;

        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0;
        usec_t min_entry_realtime = USEC_INFINITY, max_entry_realtime = 0;
        sd_id128_t entry_boot_id = {};  /* Unnecessary initialization to appease gcc */
        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, found_main_entry_array = false;
        uint64_t n_objects = 0, n_entries = 0, n_data = 0, n_fields = 0, n_data_hash_tables = 0, n_field_hash_tables = 0, n_entry_arrays = 0, n_tags = 0;
        usec_t last_usec = 0;
        _cleanup_close_ int data_fd = -EBADF, entry_fd = -EBADF, entry_array_fd = -EBADF;
        _cleanup_fclose_ FILE *data_fp = NULL, *entry_fp = NULL, *entry_array_fp = NULL;
        MMapFileDescriptor *cache_data_fd = NULL, *cache_entry_fd = NULL, *cache_entry_array_fd = NULL;
        unsigned i;
        bool found_last = false;
        const char *tmp_dir = NULL;
        MMapCache *m;

#if HAVE_GCRYPT
        uint64_t last_tag = 0;
#endif
        assert(f);

        if (key) {
#if HAVE_GCRYPT
                r = journal_file_parse_verification_key(f, key);
                if (r < 0) {
                        log_error(""Failed to parse seed."");
                        return r;
                }
#else
                return -EOPNOTSUPP;
#endif
        } else if (JOURNAL_HEADER_SEALED(f->header))
                return -ENOKEY;

        r = var_tmp_dir(&tmp_dir);
        if (r < 0) {
                log_error_errno(r, ""Failed to determine temporary directory: %m"");
                goto fail;
        }

        data_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);
        if (data_fd < 0) {
                r = log_error_errno(data_fd, ""Failed to create data file: %m"");
                goto fail;
        }

        entry_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);
        if (entry_fd < 0) {
                r = log_error_errno(entry_fd, ""Failed to create entry file: %m"");
                goto fail;
        }

        entry_array_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);
        if (entry_array_fd < 0) {
                r = log_error_errno(entry_array_fd,
                                    ""Failed to create entry array file: %m"");
                goto fail;
        }

        m = mmap_cache_fd_cache(f->cache_fd);
        cache_data_fd = mmap_cache_add_fd(m, data_fd, PROT_READ|PROT_WRITE);
        if (!cache_data_fd) {
                r = log_oom();
                goto fail;
        }

        cache_entry_fd = mmap_cache_add_fd(m, entry_fd, PROT_READ|PROT_WRITE);
        if (!cache_entry_fd) {
                r = log_oom();
                goto fail;
        }

        cache_entry_array_fd = mmap_cache_add_fd(m, entry_array_fd, PROT_READ|PROT_WRITE);
        if (!cache_entry_array_fd) {
                r = log_oom();
                goto fail;
        }

        r = take_fdopen_unlocked(&data_fd, ""w+"", &data_fp);
        if (r < 0) {
                log_error_errno(r, ""Failed to open data file stream: %m"");
                goto fail;
        }

        r = take_fdopen_unlocked(&entry_fd, ""w+"", &entry_fp);
        if (r < 0) {
                log_error_errno(r, ""Failed to open entry file stream: %m"");
                goto fail;
        }

        r = take_fdopen_unlocked(&entry_array_fd, ""w+"", &entry_array_fp);
        if (r < 0) {
                log_error_errno(r, ""Failed to open entry array file stream: %m"");
                goto fail;
        }

        if (le32toh(f->header->compatible_flags) & ~HEADER_COMPATIBLE_SUPPORTED) {
                log_error(""Cannot verify file with unknown extensions."");
                r = -EOPNOTSUPP;
                goto fail;
        }

        for (i = 0; i < sizeof(f->header->reserved); i++)
                if (f->header->reserved[i] != 0) {
                        error(offsetof(Header, reserved[i]), ""Reserved field is non-zero"");
                        r = -EBADMSG;
                        goto fail;
                }

        /* First iteration: we go through all objects, verify the
         * superficial structure, headers, hashes. */

        p = le64toh(f->header->header_size);
        for (;;) {
                /* Early exit if there are no objects in the file, at all */
                if (le64toh(f->header->tail_object_offset) == 0)
                        break;

                if (show_progress)
                        draw_progress(scale_progress(0x7FFF, p, le64toh(f->header->tail_object_offset)), &last_usec);

                r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);
                if (r < 0) {
                        error_errno(p, r, ""Invalid object: %m"");
                        goto fail;
                }

                if (p > le64toh(f->header->tail_object_offset)) {
                        error(offsetof(Header, tail_object_offset),
                              ""Invalid tail object pointer (%""PRIu64"" > %""PRIu64"")"",
                              p,
                              le64toh(f->header->tail_object_offset));
                        r = -EBADMSG;
                        goto fail;
                }

                n_objects++;

                r = journal_file_object_verify(f, p, o);
                if (r < 0) {
                        error_errno(p, r, ""Invalid object contents: %m"");
                        goto fail;
                }

                if (!!(o->object.flags & OBJECT_COMPRESSED_XZ) +
                    !!(o->object.flags & OBJECT_COMPRESSED_LZ4) +
                    !!(o->object.flags & OBJECT_COMPRESSED_ZSTD) > 1) {
                        error(p, ""Object has multiple compression flags set (flags: 0x%x)"", o->object.flags);
                        r = -EINVAL;
                        goto fail;
                }

                if ((o->object.flags & OBJECT_COMPRESSED_XZ) && !JOURNAL_HEADER_COMPRESSED_XZ(f->header)) {
                        error(p, ""XZ compressed object in file without XZ compression"");
                        r = -EBADMSG;
                        goto fail;
                }

                if ((o->object.flags & OBJECT_COMPRESSED_LZ4) && !JOURNAL_HEADER_COMPRESSED_LZ4(f->header)) {
                        error(p, ""LZ4 compressed object in file without LZ4 compression"");
                        r = -EBADMSG;
                        goto fail;
                }

                if ((o->object.flags & OBJECT_COMPRESSED_ZSTD) && !JOURNAL_HEADER_COMPRESSED_ZSTD(f->header)) {
                        error(p, ""ZSTD compressed object in file without ZSTD compression"");
                        r = -EBADMSG;
                        goto fail;
                }

                switch (o->object.type) {

                case OBJECT_DATA:
                        r = write_uint64(data_fp, p);
                        if (r < 0)
                                goto fail;

                        n_data++;
                        break;

                case OBJECT_FIELD:
                        n_fields++;
                        break;

                case OBJECT_ENTRY:
                        if (JOURNAL_HEADER_SEALED(f->header) && n_tags <= 0) {
                                error(p, ""First entry before first tag"");
                                r = -EBADMSG;
                                goto fail;
                        }

                        r = write_uint64(entry_fp, p);
                        if (r < 0)
                                goto fail;

                        if (le64toh(o->entry.realtime) < last_tag_realtime) {
                                error(p,
                                      ""Older entry after newer tag (%""PRIu64"" < %""PRIu64"")"",
                                      le64toh(o->entry.realtime),
                                      last_tag_realtime);
                                r = -EBADMSG;
                                goto fail;
                        }

                        if (!entry_seqnum_set &&
                            le64toh(o->entry.seqnum) != le64toh(f->header->head_entry_seqnum)) {
                                error(p,
                                      ""Head entry sequence number incorrect (%""PRIu64"" != %""PRIu64"")"",
                                      le64toh(o->entry.seqnum),
                                      le64toh(f->header->head_entry_seqnum));
                                r = -EBADMSG;
                                goto fail;
                        }

                        if (entry_seqnum_set &&
                            entry_seqnum >= le64toh(o->entry.seqnum)) {
                                error(p,
                                      ""Entry sequence number out of synchronization (%""PRIu64"" >= %""PRIu64"")"",
                                      entry_seqnum,
                                      le64toh(o->entry.seqnum));
                                r = -EBADMSG;
                                goto fail;
                        }

                        entry_seqnum = le64toh(o->entry.seqnum);
                        entry_seqnum_set = true;

                        if (entry_monotonic_set &&
                            sd_id128_equal(entry_boot_id, o->entry.boot_id) &&
                            entry_monotonic > le64toh(o->entry.monotonic)) {
                                error(p,
                                      ""Entry timestamp out of synchronization (%""PRIu64"" > %""PRIu64"")"",
                                      entry_monotonic,
                                      le64toh(o->entry.monotonic));
                                r = -EBADMSG;
                                goto fail;
                        }

                        entry_monotonic = le64toh(o->entry.monotonic);
                        entry_boot_id = o->entry.boot_id;
                        entry_monotonic_set = true;

                        if (!entry_realtime_set &&
                            le64toh(o->entry.realtime) != le64toh(f->header->head_entry_realtime)) {
                                error(p,
                                      ""Head entry realtime timestamp incorrect (%""PRIu64"" != %""PRIu64"")"",
                                      le64toh(o->entry.realtime),
                                      le64toh(f->header->head_entry_realtime));
                                r = -EBADMSG;
                                goto fail;
                        }

                        entry_realtime = le64toh(o->entry.realtime);
                        entry_realtime_set = true;

                        max_entry_realtime = MAX(max_entry_realtime, le64toh(o->entry.realtime));
                        min_entry_realtime = MIN(min_entry_realtime, le64toh(o->entry.realtime));

                        n_entries++;
                        break;

                case OBJECT_DATA_HASH_TABLE:
                        r = verify_hash_table(o, p, &n_data_hash_tables,
                                              le64toh(f->header->data_hash_table_offset),
                                              le64toh(f->header->data_hash_table_size));
                        if (r < 0)
                                goto fail;
                        break;

                case OBJECT_FIELD_HASH_TABLE:
                        r = verify_hash_table(o, p, &n_field_hash_tables,
                                              le64toh(f->header->field_hash_table_offset),
                                              le64toh(f->header->field_hash_table_size));
                        if (r < 0)
                                goto fail;

                        break;

                case OBJECT_ENTRY_ARRAY:
                        r = write_uint64(entry_array_fp, p);
                        if (r < 0)
                                goto fail;

                        if (p == le64toh(f->header->entry_array_offset)) {
                                if (found_main_entry_array) {
                                        error(p, ""More than one main entry array"");
                                        r = -EBADMSG;
                                        goto fail;
                                }

                                found_main_entry_array = true;
                        }

                        n_entry_arrays++;
                        break;

                case OBJECT_TAG:
                        if (!JOURNAL_HEADER_SEALED(f->header)) {
                                error(p, ""Tag object in file without sealing"");
                                r = -EBADMSG;
                                goto fail;
                        }

                        if (le64toh(o->tag.seqnum) != n_tags + 1) {
                                error(p,
                                      ""Tag sequence number out of synchronization (%""PRIu64"" != %""PRIu64"")"",
                                      le64toh(o->tag.seqnum),
                                      n_tags + 1);
                                r = -EBADMSG;
                                goto fail;
                        }

                        if (le64toh(o->tag.epoch) < last_epoch) {
                                error(p,
                                      ""Epoch sequence out of synchronization (%""PRIu64"" < %""PRIu64"")"",
                                      le64toh(o->tag.epoch),
                                      last_epoch);
                                r = -EBADMSG;
                                goto fail;
                        }

#if HAVE_GCRYPT
                        if (JOURNAL_HEADER_SEALED(f->header)) {
                                uint64_t q, rt, rt_end;

                                debug(p, ""Checking tag %""PRIu64""..."", le64toh(o->tag.seqnum));

                                rt = f->fss_start_usec + le64toh(o->tag.epoch) * f->fss_interval_usec;
                                rt_end = usec_add(rt, f->fss_interval_usec);
                                if (entry_realtime_set && entry_realtime >= rt_end) {
                                        error(p,
                                              ""tag/entry realtime timestamp out of synchronization (%""PRIu64"" >= %""PRIu64"")"",
                                              entry_realtime,
                                              rt + f->fss_interval_usec);
                                        r = -EBADMSG;
                                        goto fail;
                                }
                                if (max_entry_realtime >= rt_end) {
                                        error(p,
                                              ""Entry realtime (%""PRIu64"", %s) is too late with respect to tag (%""PRIu64"", %s)"",
                                              max_entry_realtime, FORMAT_TIMESTAMP(max_entry_realtime),
                                              rt_end, FORMAT_TIMESTAMP(rt_end));
                                        r = -EBADMSG;
                                        goto fail;
                                }
                                if (min_entry_realtime < rt) {
                                        error(p,
                                              ""Entry realtime (%""PRIu64"", %s) is too early with respect to tag (%""PRIu64"", %s)"",
                                              min_entry_realtime, FORMAT_TIMESTAMP(min_entry_realtime),
                                              rt, FORMAT_TIMESTAMP(rt));
                                        r = -EBADMSG;
                                        goto fail;
                                }
                                min_entry_realtime = USEC_INFINITY;

                                /* OK, now we know the epoch. So let's now set
                                 * it, and calculate the HMAC for everything
                                 * since the last tag. */
                                r = journal_file_fsprg_seek(f, le64toh(o->tag.epoch));
                                if (r < 0)
                                        goto fail;

                                r = journal_file_hmac_start(f);
                                if (r < 0)
                                        goto fail;

                                if (last_tag == 0) {
                                        r = journal_file_hmac_put_header(f);
                                        if (r < 0)
                                                goto fail;

                                        q = le64toh(f->header->header_size);
                                } else
                                        q = last_tag;

                                while (q <= p) {
                                        r = journal_file_move_to_object(f, OBJECT_UNUSED, q, &o);
                                        if (r < 0)
                                                goto fail;

                                        r = journal_file_hmac_put_object(f, OBJECT_UNUSED, o, q);
                                        if (r < 0)
                                                goto fail;

                                        q = q + ALIGN64(le64toh(o->object.size));
                                }

                                /* Position might have changed, let's reposition things */
                                r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);
                                if (r < 0)
                                        goto fail;

                                if (memcmp(o->tag.tag, gcry_md_read(f->hmac, 0), TAG_LENGTH) != 0) {
                                        error(p, ""Tag failed verification"");
                                        r = -EBADMSG;
                                        goto fail;
                                }

                                f->hmac_running = false;
                                last_tag_realtime = rt;
                                last_sealed_realtime = entry_realtime;
                        }

                        last_tag = p + ALIGN64(le64toh(o->object.size));
#endif

                        last_epoch = le64toh(o->tag.epoch);

                        n_tags++;
                        break;
                }

                if (p == le64toh(f->header->tail_object_offset)) {
                        found_last = true;
                        break;
                }

                p = p + ALIGN64(le64toh(o->object.size));
        };

        if (!found_last && le64toh(f->header->tail_object_offset) != 0) {
                error(le64toh(f->header->tail_object_offset),
                      ""Tail object pointer dead (%""PRIu64"" != 0)"",
                      le64toh(f->header->tail_object_offset));
                r = -EBADMSG;
                goto fail;
        }

        if (n_objects != le64toh(f->header->n_objects)) {
                error(offsetof(Header, n_objects),
                      ""Object number mismatch (%""PRIu64"" != %""PRIu64"")"",
                      n_objects,
                      le64toh(f->header->n_objects));
                r = -EBADMSG;
                goto fail;
        }

        if (n_entries != le64toh(f->header->n_entries)) {
                error(offsetof(Header, n_entries),
                      ""Entry number mismatch (%""PRIu64"" != %""PRIu64"")"",
                      n_entries,
                      le64toh(f->header->n_entries));
                r = -EBADMSG;
                goto fail;
        }

        if (JOURNAL_HEADER_CONTAINS(f->header, n_data) &&
            n_data != le64toh(f->header->n_data)) {
                error(offsetof(Header, n_data),
                      ""Data number mismatch (%""PRIu64"" != %""PRIu64"")"",
                      n_data,
                      le64toh(f->header->n_data));
                r = -EBADMSG;
                goto fail;
        }

        if (JOURNAL_HEADER_CONTAINS(f->header, n_fields) &&
            n_fields != le64toh(f->header->n_fields)) {
                error(offsetof(Header, n_fields),
                      ""Field number mismatch (%""PRIu64"" != %""PRIu64"")"",
                      n_fields,
                      le64toh(f->header->n_fields));
                r = -EBADMSG;
                goto fail;
        }

        if (JOURNAL_HEADER_CONTAINS(f->header, n_tags) &&
            n_tags != le64toh(f->header->n_tags)) {
                error(offsetof(Header, n_tags),
                      ""Tag number mismatch (%""PRIu64"" != %""PRIu64"")"",
                      n_tags,
                      le64toh(f->header->n_tags));
                r = -EBADMSG;
                goto fail;
        }

        if (JOURNAL_HEADER_CONTAINS(f->header, n_entry_arrays) &&
            n_entry_arrays != le64toh(f->header->n_entry_arrays)) {
                error(offsetof(Header, n_entry_arrays),
                      ""Entry array number mismatch (%""PRIu64"" != %""PRIu64"")"",
                      n_entry_arrays,
                      le64toh(f->header->n_entry_arrays));
                r = -EBADMSG;
                goto fail;
        }

        if (!found_main_entry_array && le64toh(f->header->entry_array_offset) != 0) {
                error(0, ""Missing main entry array"");
                r = -EBADMSG;
                goto fail;
        }

        if (entry_seqnum_set &&
            entry_seqnum != le64toh(f->header->tail_entry_seqnum)) {
                error(offsetof(Header, tail_entry_seqnum),
                      ""Tail entry sequence number incorrect (%""PRIu64"" != %""PRIu64"")"",
                      entry_seqnum,
                      le64toh(f->header->tail_entry_seqnum));
                r = -EBADMSG;
                goto fail;
        }

        if (entry_monotonic_set &&
            (sd_id128_equal(entry_boot_id, f->header->tail_entry_boot_id) &&
             JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(f->header) &&
             entry_monotonic != le64toh(f->header->tail_entry_monotonic))) {
                error(0,
                      ""Invalid tail monotonic timestamp (%""PRIu64"" != %""PRIu64"")"",
                      entry_monotonic,
                      le64toh(f->header->tail_entry_monotonic));
                r = -EBADMSG;
                goto fail;
        }

        if (entry_realtime_set && entry_realtime != le64toh(f->header->tail_entry_realtime)) {
                error(0,
                      ""Invalid tail realtime timestamp (%""PRIu64"" != %""PRIu64"")"",
                      entry_realtime,
                      le64toh(f->header->tail_entry_realtime));
                r = -EBADMSG;
                goto fail;
        }

        if (fflush(data_fp) != 0) {
                r = log_error_errno(errno, ""Failed to flush data file stream: %m"");
                goto fail;
        }

        if (fflush(entry_fp) != 0) {
                r = log_error_errno(errno, ""Failed to flush entry file stream: %m"");
                goto fail;
        }

        if (fflush(entry_array_fp) != 0) {
                r = log_error_errno(errno, ""Failed to flush entry array file stream: %m"");
                goto fail;
        }

        /* Second iteration: we follow all objects referenced from the
         * two entry points: the object hash table and the entry
         * array. We also check that everything referenced (directly
         * or indirectly) in the data hash table also exists in the
         * entry array, and vice versa. Note that we do not care for
         * unreferenced objects. We only care that everything that is
         * referenced is consistent. */

        r = verify_entry_array(f,
                               cache_data_fd, n_data,
                               cache_entry_fd, n_entries,
                               cache_entry_array_fd, n_entry_arrays,
                               &last_usec,
                               show_progress);
        if (r < 0)
                goto fail;

        r = verify_data_hash_table(f,
                                   cache_data_fd, n_data,
                                   cache_entry_fd, n_entries,
                                   cache_entry_array_fd, n_entry_arrays,
                                   &last_usec,
                                   show_progress);
        if (r < 0)
                goto fail;

        if (show_progress)
                flush_progress();

        mmap_cache_fd_free(cache_data_fd);
        mmap_cache_fd_free(cache_entry_fd);
        mmap_cache_fd_free(cache_entry_array_fd);

        if (first_contained)
                *first_contained = le64toh(f->header->head_entry_realtime);
        if (last_validated)
                *last_validated = last_sealed_realtime;
        if (last_contained)
                *last_contained = le64toh(f->header->tail_entry_realtime);

        return 0;

fail:
        if (show_progress)
                flush_progress();

        log_error(""File corruption detected at %s:%""PRIu64"" (of %""PRIu64"" bytes, %""PRIu64""%%)."",
                  f->path,
                  p,
                  (uint64_t) f->last_stat.st_size,
                  100U * p / (uint64_t) f->last_stat.st_size);

        if (cache_data_fd)
                mmap_cache_fd_free(cache_data_fd);

        if (cache_entry_fd)
                mmap_cache_fd_free(cache_entry_fd);

        if (cache_entry_array_fd)
                mmap_cache_fd_free(cache_entry_array_fd);

        return r;
}","int journal_file_verify(
                JournalFile *VAR_0,
                const char *VAR_1,
                usec_t *VAR_2, usec_t *VAR_3, usec_t *VAR_4,
                bool VAR_5) {
        int VAR_6;
        Object *VAR_7;
        uint64_t VAR_8 = 0, VAR_9 = 0, VAR_10 = 0, VAR_11 = 0;

        uint64_t VAR_12 = 0, VAR_13 = 0, VAR_14 = 0;
        usec_t VAR_15 = VAR_16, VAR_17 = 0;
        sd_id128_t VAR_18 = {};  /* COMMENT_0 */
        bool VAR_19 = false, VAR_20 = false, VAR_21 = false, VAR_22 = false;
        uint64_t VAR_23 = 0, VAR_24 = 0, VAR_25 = 0, VAR_26 = 0, VAR_27 = 0, VAR_28 = 0, VAR_29 = 0, VAR_30 = 0;
        usec_t VAR_31 = 0;
        _cleanup_close_ int VAR_32 = -VAR_33, VAR_34 = -VAR_33, VAR_35 = -VAR_33;
        _cleanup_fclose_ VAR_36 *VAR_37 = NULL, *VAR_38 = NULL, *VAR_39 = NULL;
        MMapFileDescriptor *VAR_40 = NULL, *VAR_41 = NULL, *VAR_42 = NULL;
        unsigned VAR_43;
        bool VAR_44 = false;
        const char *VAR_45 = NULL;
        MMapCache *VAR_46;

#if VAR_47
        uint64_t VAR_48 = 0;
#endif
        assert(VAR_0);

        if (VAR_1) {
#if VAR_47
                VAR_6 = journal_file_parse_verification_key(VAR_0, VAR_1);
                if (VAR_6 < 0) {
                        log_error(""Failed to parse seed."");
                        return VAR_6;
                }
#else
                return -VAR_49;
#endif
        } else if (JOURNAL_HEADER_SEALED(VAR_0->header))
                return -VAR_50;

        VAR_6 = var_tmp_dir(&VAR_45);
        if (VAR_6 < 0) {
                log_error_errno(VAR_6, ""Failed to determine temporary directory: %m"");
                goto fail;
        }

        VAR_32 = open_tmpfile_unlinkable(VAR_45, VAR_51 | VAR_52);
        if (VAR_32 < 0) {
                VAR_6 = log_error_errno(VAR_32, ""Failed to create data file: %m"");
                goto fail;
        }

        VAR_34 = open_tmpfile_unlinkable(VAR_45, VAR_51 | VAR_52);
        if (VAR_34 < 0) {
                VAR_6 = log_error_errno(VAR_34, ""Failed to create entry file: %m"");
                goto fail;
        }

        VAR_35 = open_tmpfile_unlinkable(VAR_45, VAR_51 | VAR_52);
        if (VAR_35 < 0) {
                VAR_6 = log_error_errno(VAR_35,
                                    ""Failed to create entry array file: %m"");
                goto fail;
        }

        VAR_46 = mmap_cache_fd_cache(VAR_0->cache_fd);
        VAR_40 = mmap_cache_add_fd(VAR_46, VAR_32, VAR_53|VAR_54);
        if (!VAR_40) {
                VAR_6 = log_oom();
                goto fail;
        }

        VAR_41 = mmap_cache_add_fd(VAR_46, VAR_34, VAR_53|VAR_54);
        if (!VAR_41) {
                VAR_6 = log_oom();
                goto fail;
        }

        VAR_42 = mmap_cache_add_fd(VAR_46, VAR_35, VAR_53|VAR_54);
        if (!VAR_42) {
                VAR_6 = log_oom();
                goto fail;
        }

        VAR_6 = take_fdopen_unlocked(&VAR_32, ""w+"", &VAR_37);
        if (VAR_6 < 0) {
                log_error_errno(VAR_6, ""Failed to open data file stream: %m"");
                goto fail;
        }

        VAR_6 = take_fdopen_unlocked(&VAR_34, ""w+"", &VAR_38);
        if (VAR_6 < 0) {
                log_error_errno(VAR_6, ""Failed to open entry file stream: %m"");
                goto fail;
        }

        VAR_6 = take_fdopen_unlocked(&VAR_35, ""w+"", &VAR_39);
        if (VAR_6 < 0) {
                log_error_errno(VAR_6, ""Failed to open entry array file stream: %m"");
                goto fail;
        }

        if (le32toh(VAR_0->header->compatible_flags) & ~VAR_55) {
                log_error(""Cannot verify file with unknown extensions."");
                VAR_6 = -VAR_49;
                goto fail;
        }

        for (VAR_43 = 0; VAR_43 < sizeof(VAR_0->header->reserved); VAR_43++)
                if (VAR_0->header->reserved[VAR_43] != 0) {
                        error(offsetof(VAR_56, VAR_57[VAR_43]), ""Reserved field is non-zero"");
                        VAR_6 = -VAR_58;
                        goto fail;
                }

        /* COMMENT_1 */
                                                     

        VAR_8 = le64toh(VAR_0->header->header_size);
        for (;;) {
                /* COMMENT_3 */
                if (le64toh(VAR_0->header->tail_object_offset) == 0)
                        break;

                if (VAR_5)
                        draw_progress(scale_progress(0x7FFF, VAR_8, le64toh(VAR_0->header->tail_object_offset)), &VAR_31);

                VAR_6 = journal_file_move_to_object(VAR_0, VAR_59, VAR_8, &VAR_7);
                if (VAR_6 < 0) {
                        error_errno(VAR_8, VAR_6, ""Invalid object: %m"");
                        goto fail;
                }

                if (VAR_8 > le64toh(VAR_0->header->tail_object_offset)) {
                        error(offsetof(VAR_56, VAR_60),
                              ""Invalid tail object pointer (%""VAR_61"" > %""VAR_61"")"",
                              VAR_8,
                              le64toh(VAR_0->header->tail_object_offset));
                        VAR_6 = -VAR_58;
                        goto fail;
                }

                VAR_23++;

                VAR_6 = journal_file_object_verify(VAR_0, VAR_8, VAR_7);
                if (VAR_6 < 0) {
                        error_errno(VAR_8, VAR_6, ""Invalid object contents: %m"");
                        goto fail;
                }

                if (!!(VAR_7->object.flags & VAR_62) +
                    !!(VAR_7->object.flags & VAR_63) +
                    !!(VAR_7->object.flags & VAR_64) > 1) {
                        error(VAR_8, ""Object has multiple compression flags set (flags: 0x%x)"", VAR_7->object.flags);
                        VAR_6 = -VAR_65;
                        goto fail;
                }

                if ((VAR_7->object.flags & VAR_62) && !JOURNAL_HEADER_COMPRESSED_XZ(VAR_0->header)) {
                        error(VAR_8, ""XZ compressed object in file without XZ compression"");
                        VAR_6 = -VAR_58;
                        goto fail;
                }

                if ((VAR_7->object.flags & VAR_63) && !JOURNAL_HEADER_COMPRESSED_LZ4(VAR_0->header)) {
                        error(VAR_8, ""LZ4 compressed object in file without LZ4 compression"");
                        VAR_6 = -VAR_58;
                        goto fail;
                }

                if ((VAR_7->object.flags & VAR_64) && !JOURNAL_HEADER_COMPRESSED_ZSTD(VAR_0->header)) {
                        error(VAR_8, ""ZSTD compressed object in file without ZSTD compression"");
                        VAR_6 = -VAR_58;
                        goto fail;
                }

                switch (VAR_7->object.type) {

                case VAR_66:
                        VAR_6 = write_uint64(VAR_37, VAR_8);
                        if (VAR_6 < 0)
                                goto fail;

                        VAR_25++;
                        break;

                case VAR_67:
                        VAR_26++;
                        break;

                case VAR_68:
                        if (JOURNAL_HEADER_SEALED(VAR_0->header) && VAR_30 <= 0) {
                                error(VAR_8, ""First entry before first tag"");
                                VAR_6 = -VAR_58;
                                goto fail;
                        }

                        VAR_6 = write_uint64(VAR_38, VAR_8);
                        if (VAR_6 < 0)
                                goto fail;

                        if (le64toh(VAR_7->entry.realtime) < VAR_10) {
                                error(VAR_8,
                                      ""Older entry after newer tag (%""VAR_61"" < %""VAR_61"")"",
                                      le64toh(VAR_7->entry.realtime),
                                      VAR_10);
                                VAR_6 = -VAR_58;
                                goto fail;
                        }

                        if (!VAR_19 &&
                            le64toh(VAR_7->entry.seqnum) != le64toh(VAR_0->header->head_entry_seqnum)) {
                                error(VAR_8,
                                      ""Head entry sequence number incorrect (%""VAR_61"" != %""VAR_61"")"",
                                      le64toh(VAR_7->entry.seqnum),
                                      le64toh(VAR_0->header->head_entry_seqnum));
                                VAR_6 = -VAR_58;
                                goto fail;
                        }

                        if (VAR_19 &&
                            VAR_12 >= le64toh(VAR_7->entry.seqnum)) {
                                error(VAR_8,
                                      ""Entry sequence number out of synchronization (%""VAR_61"" >= %""VAR_61"")"",
                                      VAR_12,
                                      le64toh(VAR_7->entry.seqnum));
                                VAR_6 = -VAR_58;
                                goto fail;
                        }

                        VAR_12 = le64toh(VAR_7->entry.seqnum);
                        VAR_19 = true;

                        if (VAR_20 &&
                            sd_id128_equal(VAR_18, VAR_7->entry.boot_id) &&
                            VAR_13 > le64toh(VAR_7->entry.monotonic)) {
                                error(VAR_8,
                                      ""Entry timestamp out of synchronization (%""VAR_61"" > %""VAR_61"")"",
                                      VAR_13,
                                      le64toh(VAR_7->entry.monotonic));
                                VAR_6 = -VAR_58;
                                goto fail;
                        }

                        VAR_13 = le64toh(VAR_7->entry.monotonic);
                        VAR_18 = VAR_7->entry.boot_id;
                        VAR_20 = true;

                        if (!VAR_21 &&
                            le64toh(VAR_7->entry.realtime) != le64toh(VAR_0->header->head_entry_realtime)) {
                                error(VAR_8,
                                      ""Head entry realtime timestamp incorrect (%""VAR_61"" != %""VAR_61"")"",
                                      le64toh(VAR_7->entry.realtime),
                                      le64toh(VAR_0->header->head_entry_realtime));
                                VAR_6 = -VAR_58;
                                goto fail;
                        }

                        VAR_14 = le64toh(VAR_7->entry.realtime);
                        VAR_21 = true;

                        VAR_17 = MAX(VAR_17, le64toh(VAR_7->entry.realtime));
                        VAR_15 = MIN(VAR_15, le64toh(VAR_7->entry.realtime));

                        VAR_24++;
                        break;

                case VAR_69:
                        VAR_6 = verify_hash_table(VAR_7, VAR_8, &VAR_27,
                                              le64toh(VAR_0->header->data_hash_table_offset),
                                              le64toh(VAR_0->header->data_hash_table_size));
                        if (VAR_6 < 0)
                                goto fail;
                        break;

                case VAR_70:
                        VAR_6 = verify_hash_table(VAR_7, VAR_8, &VAR_28,
                                              le64toh(VAR_0->header->field_hash_table_offset),
                                              le64toh(VAR_0->header->field_hash_table_size));
                        if (VAR_6 < 0)
                                goto fail;

                        break;

                case VAR_71:
                        VAR_6 = write_uint64(VAR_39, VAR_8);
                        if (VAR_6 < 0)
                                goto fail;

                        if (VAR_8 == le64toh(VAR_0->header->entry_array_offset)) {
                                if (VAR_22) {
                                        error(VAR_8, ""More than one main entry array"");
                                        VAR_6 = -VAR_58;
                                        goto fail;
                                }

                                VAR_22 = true;
                        }

                        VAR_29++;
                        break;

                case VAR_72:
                        if (!JOURNAL_HEADER_SEALED(VAR_0->header)) {
                                error(VAR_8, ""Tag object in file without sealing"");
                                VAR_6 = -VAR_58;
                                goto fail;
                        }

                        if (le64toh(VAR_7->tag.seqnum) != VAR_30 + 1) {
                                error(VAR_8,
                                      ""Tag sequence number out of synchronization (%""VAR_61"" != %""VAR_61"")"",
                                      le64toh(VAR_7->tag.seqnum),
                                      VAR_30 + 1);
                                VAR_6 = -VAR_58;
                                goto fail;
                        }

                        if (le64toh(VAR_7->tag.epoch) < VAR_9) {
                                error(VAR_8,
                                      ""Epoch sequence out of synchronization (%""VAR_61"" < %""VAR_61"")"",
                                      le64toh(VAR_7->tag.epoch),
                                      VAR_9);
                                VAR_6 = -VAR_58;
                                goto fail;
                        }

#if VAR_47
                        if (JOURNAL_HEADER_SEALED(VAR_0->header)) {
                                uint64_t VAR_73, VAR_74, VAR_75;

                                debug(VAR_8, ""Checking tag %""VAR_61""..."", le64toh(VAR_7->tag.seqnum));

                                VAR_74 = VAR_0->fss_start_usec + le64toh(VAR_7->tag.epoch) * VAR_0->fss_interval_usec;
                                VAR_75 = usec_add(VAR_74, VAR_0->fss_interval_usec);
                                if (VAR_21 && VAR_14 >= VAR_75) {
                                        error(VAR_8,
                                              ""tag/entry realtime timestamp out of synchronization (%""VAR_61"" >= %""VAR_61"")"",
                                              VAR_14,
                                              VAR_74 + VAR_0->fss_interval_usec);
                                        VAR_6 = -VAR_58;
                                        goto fail;
                                }
                                if (VAR_17 >= VAR_75) {
                                        error(VAR_8,
                                              ""Entry realtime (%""VAR_61"", %s) is too late with respect to tag (%""VAR_61"", %s)"",
                                              VAR_17, FORMAT_TIMESTAMP(VAR_17),
                                              VAR_75, FORMAT_TIMESTAMP(VAR_75));
                                        VAR_6 = -VAR_58;
                                        goto fail;
                                }
                                if (VAR_15 < VAR_74) {
                                        error(VAR_8,
                                              ""Entry realtime (%""VAR_61"", %s) is too early with respect to tag (%""VAR_61"", %s)"",
                                              VAR_15, FORMAT_TIMESTAMP(VAR_15),
                                              VAR_74, FORMAT_TIMESTAMP(VAR_74));
                                        VAR_6 = -VAR_58;
                                        goto fail;
                                }
                                VAR_15 = VAR_16;

                                /* COMMENT_4 */
                                                                            
                                                         
                                VAR_6 = journal_file_fsprg_seek(VAR_0, le64toh(VAR_7->tag.epoch));
                                if (VAR_6 < 0)
                                        goto fail;

                                VAR_6 = journal_file_hmac_start(VAR_0);
                                if (VAR_6 < 0)
                                        goto fail;

                                if (VAR_48 == 0) {
                                        VAR_6 = journal_file_hmac_put_header(VAR_0);
                                        if (VAR_6 < 0)
                                                goto fail;

                                        VAR_73 = le64toh(VAR_0->header->header_size);
                                } else
                                        VAR_73 = VAR_48;

                                while (VAR_73 <= VAR_8) {
                                        VAR_6 = journal_file_move_to_object(VAR_0, VAR_59, VAR_73, &VAR_7);
                                        if (VAR_6 < 0)
                                                goto fail;

                                        VAR_6 = journal_file_hmac_put_object(VAR_0, VAR_59, VAR_7, VAR_73);
                                        if (VAR_6 < 0)
                                                goto fail;

                                        VAR_73 = VAR_73 + ALIGN64(le64toh(VAR_7->object.size));
                                }

                                /* COMMENT_7 */
                                VAR_6 = journal_file_move_to_object(VAR_0, VAR_59, VAR_8, &VAR_7);
                                if (VAR_6 < 0)
                                        goto fail;

                                if (memcmp(VAR_7->tag.tag, gcry_md_read(VAR_0->hmac, 0), VAR_76) != 0) {
                                        error(VAR_8, ""Tag failed verification"");
                                        VAR_6 = -VAR_58;
                                        goto fail;
                                }

                                VAR_0->hmac_running = false;
                                VAR_10 = VAR_74;
                                VAR_11 = VAR_14;
                        }

                        VAR_48 = VAR_8 + ALIGN64(le64toh(VAR_7->object.size));
#endif

                        VAR_9 = le64toh(VAR_7->tag.epoch);

                        VAR_30++;
                        break;
                }

                if (VAR_8 == le64toh(VAR_0->header->tail_object_offset)) {
                        VAR_44 = true;
                        break;
                }

                VAR_8 = VAR_8 + ALIGN64(le64toh(VAR_7->object.size));
        };

        if (!VAR_44 && le64toh(VAR_0->header->tail_object_offset) != 0) {
                error(le64toh(VAR_0->header->tail_object_offset),
                      ""Tail object pointer dead (%""VAR_61"" != 0)"",
                      le64toh(VAR_0->header->tail_object_offset));
                VAR_6 = -VAR_58;
                goto fail;
        }

        if (VAR_23 != le64toh(VAR_0->header->n_objects)) {
                error(offsetof(VAR_56, VAR_23),
                      ""Object number mismatch (%""VAR_61"" != %""VAR_61"")"",
                      VAR_23,
                      le64toh(VAR_0->header->n_objects));
                VAR_6 = -VAR_58;
                goto fail;
        }

        if (VAR_24 != le64toh(VAR_0->header->n_entries)) {
                error(offsetof(VAR_56, VAR_24),
                      ""Entry number mismatch (%""VAR_61"" != %""VAR_61"")"",
                      VAR_24,
                      le64toh(VAR_0->header->n_entries));
                VAR_6 = -VAR_58;
                goto fail;
        }

        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_25) &&
            VAR_25 != le64toh(VAR_0->header->n_data)) {
                error(offsetof(VAR_56, VAR_25),
                      ""Data number mismatch (%""VAR_61"" != %""VAR_61"")"",
                      VAR_25,
                      le64toh(VAR_0->header->n_data));
                VAR_6 = -VAR_58;
                goto fail;
        }

        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_26) &&
            VAR_26 != le64toh(VAR_0->header->n_fields)) {
                error(offsetof(VAR_56, VAR_26),
                      ""Field number mismatch (%""VAR_61"" != %""VAR_61"")"",
                      VAR_26,
                      le64toh(VAR_0->header->n_fields));
                VAR_6 = -VAR_58;
                goto fail;
        }

        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_30) &&
            VAR_30 != le64toh(VAR_0->header->n_tags)) {
                error(offsetof(VAR_56, VAR_30),
                      ""Tag number mismatch (%""VAR_61"" != %""VAR_61"")"",
                      VAR_30,
                      le64toh(VAR_0->header->n_tags));
                VAR_6 = -VAR_58;
                goto fail;
        }

        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_29) &&
            VAR_29 != le64toh(VAR_0->header->n_entry_arrays)) {
                error(offsetof(VAR_56, VAR_29),
                      ""Entry array number mismatch (%""VAR_61"" != %""VAR_61"")"",
                      VAR_29,
                      le64toh(VAR_0->header->n_entry_arrays));
                VAR_6 = -VAR_58;
                goto fail;
        }

        if (!VAR_22 && le64toh(VAR_0->header->entry_array_offset) != 0) {
                error(0, ""Missing main entry array"");
                VAR_6 = -VAR_58;
                goto fail;
        }

        if (VAR_19 &&
            VAR_12 != le64toh(VAR_0->header->tail_entry_seqnum)) {
                error(offsetof(VAR_56, VAR_77),
                      ""Tail entry sequence number incorrect (%""VAR_61"" != %""VAR_61"")"",
                      VAR_12,
                      le64toh(VAR_0->header->tail_entry_seqnum));
                VAR_6 = -VAR_58;
                goto fail;
        }

        if (VAR_20 &&
            (sd_id128_equal(VAR_18, VAR_0->header->tail_entry_boot_id) &&
             JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(VAR_0->header) &&
             VAR_13 != le64toh(VAR_0->header->tail_entry_monotonic))) {
                error(0,
                      ""Invalid tail monotonic timestamp (%""VAR_61"" != %""VAR_61"")"",
                      VAR_13,
                      le64toh(VAR_0->header->tail_entry_monotonic));
                VAR_6 = -VAR_58;
                goto fail;
        }

        if (VAR_21 && VAR_14 != le64toh(VAR_0->header->tail_entry_realtime)) {
                error(0,
                      ""Invalid tail realtime timestamp (%""VAR_61"" != %""VAR_61"")"",
                      VAR_14,
                      le64toh(VAR_0->header->tail_entry_realtime));
                VAR_6 = -VAR_58;
                goto fail;
        }

        if (fflush(VAR_37) != 0) {
                VAR_6 = log_error_errno(VAR_78, ""Failed to flush data file stream: %m"");
                goto fail;
        }

        if (fflush(VAR_38) != 0) {
                VAR_6 = log_error_errno(VAR_78, ""Failed to flush entry file stream: %m"");
                goto fail;
        }

        if (fflush(VAR_39) != 0) {
                VAR_6 = log_error_errno(VAR_78, ""Failed to flush entry array file stream: %m"");
                goto fail;
        }

        /* COMMENT_8 */
                                                                
                                                                    
                                                                   
                                                                    
                                                                     
                                       

        VAR_6 = verify_entry_array(VAR_0,
                               VAR_40, VAR_25,
                               VAR_41, VAR_24,
                               VAR_42, VAR_29,
                               &VAR_31,
                               VAR_5);
        if (VAR_6 < 0)
                goto fail;

        VAR_6 = verify_data_hash_table(VAR_0,
                                   VAR_40, VAR_25,
                                   VAR_41, VAR_24,
                                   VAR_42, VAR_29,
                                   &VAR_31,
                                   VAR_5);
        if (VAR_6 < 0)
                goto fail;

        if (VAR_5)
                flush_progress();

        mmap_cache_fd_free(VAR_40);
        mmap_cache_fd_free(VAR_41);
        mmap_cache_fd_free(VAR_42);

        if (VAR_2)
                *VAR_2 = le64toh(VAR_0->header->head_entry_realtime);
        if (VAR_3)
                *VAR_3 = VAR_11;
        if (VAR_4)
                *VAR_4 = le64toh(VAR_0->header->tail_entry_realtime);

        return 0;

fail:
        if (VAR_5)
                flush_progress();

        log_error(""File corruption detected at %s:%""VAR_61"" (of %""VAR_61"" bytes, %""VAR_61""%%)."",
                  VAR_0->path,
                  VAR_8,
                  (uint64_t) VAR_0->last_stat.st_size,
                  100U * VAR_8 / (uint64_t) VAR_0->last_stat.st_size);

        if (VAR_40)
                mmap_cache_fd_free(VAR_40);

        if (VAR_41)
                mmap_cache_fd_free(VAR_41);

        if (VAR_42)
                mmap_cache_fd_free(VAR_42);

        return VAR_6;
}",systemd/3c896258067991832a1e896093b748aebfc873e1/journal-verify.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,9 +7,10 @@
         Object *o;
         uint64_t p = 0, last_epoch = 0, last_tag_realtime = 0, last_sealed_realtime = 0;
 
-        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0, min_entry_realtime = 0, max_entry_realtime = 0;
+        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0;
+        usec_t min_entry_realtime = USEC_INFINITY, max_entry_realtime = 0;
         sd_id128_t entry_boot_id = {};  /* Unnecessary initialization to appease gcc */
-        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, min_entry_realtime_set = false, found_main_entry_array = false;
+        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, found_main_entry_array = false;
         uint64_t n_objects = 0, n_entries = 0, n_data = 0, n_fields = 0, n_data_hash_tables = 0, n_field_hash_tables = 0, n_entry_arrays = 0, n_tags = 0;
         usec_t last_usec = 0;
         _cleanup_close_ int data_fd = -EBADF, entry_fd = -EBADF, entry_array_fd = -EBADF;
@@ -259,12 +260,8 @@
                         entry_realtime = le64toh(o->entry.realtime);
                         entry_realtime_set = true;
 
-                        if (max_entry_realtime < le64toh(o->entry.realtime))
-                                max_entry_realtime = le64toh(o->entry.realtime);
-                        if (!min_entry_realtime_set || min_entry_realtime > le64toh(o->entry.realtime)) {
-                                min_entry_realtime = le64toh(o->entry.realtime);
-                                min_entry_realtime_set = true;
-                        }
+                        max_entry_realtime = MAX(max_entry_realtime, le64toh(o->entry.realtime));
+                        min_entry_realtime = MIN(min_entry_realtime, le64toh(o->entry.realtime));
 
                         n_entries++;
                         break;
@@ -331,12 +328,13 @@
 
 #if HAVE_GCRYPT
                         if (JOURNAL_HEADER_SEALED(f->header)) {
-                                uint64_t q, rt;
+                                uint64_t q, rt, rt_end;
 
                                 debug(p, ""Checking tag %""PRIu64""..."", le64toh(o->tag.seqnum));
 
                                 rt = f->fss_start_usec + le64toh(o->tag.epoch) * f->fss_interval_usec;
-                                if (entry_realtime_set && entry_realtime >= rt + f->fss_interval_usec) {
+                                rt_end = usec_add(rt, f->fss_interval_usec);
+                                if (entry_realtime_set && entry_realtime >= rt_end) {
                                         error(p,
                                               ""tag/entry realtime timestamp out of synchronization (%""PRIu64"" >= %""PRIu64"")"",
                                               entry_realtime,
@@ -344,23 +342,23 @@
                                         r = -EBADMSG;
                                         goto fail;
                                 }
-                                if (max_entry_realtime >= rt + f->fss_interval_usec) {
+                                if (max_entry_realtime >= rt_end) {
                                         error(p,
-                                              ""entry realtime timestamp too late with respect to tag (%""PRIu64"" < %""PRIu64"")"",
-                                              max_entry_realtime,
-                                              rt + f->fss_interval_usec);
+                                              ""Entry realtime (%""PRIu64"", %s) is too late with respect to tag (%""PRIu64"", %s)"",
+                                              max_entry_realtime, FORMAT_TIMESTAMP(max_entry_realtime),
+                                              rt_end, FORMAT_TIMESTAMP(rt_end));
                                         r = -EBADMSG;
                                         goto fail;
                                 }
-                                if (min_entry_realtime_set && min_entry_realtime < rt) {
+                                if (min_entry_realtime < rt) {
                                         error(p,
-                                              ""entry realtime timestamp too early with respect to tag out of synchronization (%""PRIu64"" >= %""PRIu64"")"",
-                                              min_entry_realtime,
-                                              rt);
+                                              ""Entry realtime (%""PRIu64"", %s) is too early with respect to tag (%""PRIu64"", %s)"",
+                                              min_entry_realtime, FORMAT_TIMESTAMP(min_entry_realtime),
+                                              rt, FORMAT_TIMESTAMP(rt));
                                         r = -EBADMSG;
                                         goto fail;
                                 }
-                                min_entry_realtime_set = false;
+                                min_entry_realtime = USEC_INFINITY;
 
                                 /* OK, now we know the epoch. So let's now set
                                  * it, and calculate the HMAC for everything","{'deleted_lines': ['        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0, min_entry_realtime = 0, max_entry_realtime = 0;', '        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, min_entry_realtime_set = false, found_main_entry_array = false;', '                        if (max_entry_realtime < le64toh(o->entry.realtime))', '                                max_entry_realtime = le64toh(o->entry.realtime);', '                        if (!min_entry_realtime_set || min_entry_realtime > le64toh(o->entry.realtime)) {', '                                min_entry_realtime = le64toh(o->entry.realtime);', '                                min_entry_realtime_set = true;', '                        }', '                                uint64_t q, rt;', '                                if (entry_realtime_set && entry_realtime >= rt + f->fss_interval_usec) {', '                                if (max_entry_realtime >= rt + f->fss_interval_usec) {', '                                              ""entry realtime timestamp too late with respect to tag (%""PRIu64"" < %""PRIu64"")"",', '                                              max_entry_realtime,', '                                              rt + f->fss_interval_usec);', '                                if (min_entry_realtime_set && min_entry_realtime < rt) {', '                                              ""entry realtime timestamp too early with respect to tag out of synchronization (%""PRIu64"" >= %""PRIu64"")"",', '                                              min_entry_realtime,', '                                              rt);', '                                min_entry_realtime_set = false;'], 'added_lines': ['        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0;', '        usec_t min_entry_realtime = USEC_INFINITY, max_entry_realtime = 0;', '        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, found_main_entry_array = false;', '                        max_entry_realtime = MAX(max_entry_realtime, le64toh(o->entry.realtime));', '                        min_entry_realtime = MIN(min_entry_realtime, le64toh(o->entry.realtime));', '                                uint64_t q, rt, rt_end;', '                                rt_end = usec_add(rt, f->fss_interval_usec);', '                                if (entry_realtime_set && entry_realtime >= rt_end) {', '                                if (max_entry_realtime >= rt_end) {', '                                              ""Entry realtime (%""PRIu64"", %s) is too late with respect to tag (%""PRIu64"", %s)"",', '                                              max_entry_realtime, FORMAT_TIMESTAMP(max_entry_realtime),', '                                              rt_end, FORMAT_TIMESTAMP(rt_end));', '                                if (min_entry_realtime < rt) {', '                                              ""Entry realtime (%""PRIu64"", %s) is too early with respect to tag (%""PRIu64"", %s)"",', '                                              min_entry_realtime, FORMAT_TIMESTAMP(min_entry_realtime),', '                                              rt, FORMAT_TIMESTAMP(rt));', '                                min_entry_realtime = USEC_INFINITY;']}",True,"An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""",5.3,MEDIUM,1,test,2023-10-03T08:09:58Z,4
CVE-2023-5590,['CWE-476'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,SeleniumHQ/selenium,[IEDriver] Fix potential null pointer access in CookieManager,023a0d52f106321838ab1c0997e76693f4dcbdf6,https://github.com/SeleniumHQ/selenium/commit/023a0d52f106321838ab1c0997e76693f4dcbdf6,cpp/iedriver/CookieManager.cpp,CookieWndProc,"LRESULT CALLBACK CookieWndProc(int nCode, WPARAM wParam, LPARAM lParam) {
CWPSTRUCT* call_window_proc_struct = reinterpret_cast<CWPSTRUCT*>(lParam);
if (WM_COPYDATA == call_window_proc_struct->message) {
COPYDATASTRUCT* data = reinterpret_cast<COPYDATASTRUCT*>(call_window_proc_struct->lParam);
webdriver::HookProcessor::CopyDataToBuffer(data->cbData, data->lpData);
} else if (WD_GET_ALL_COOKIES == call_window_proc_struct->message) {
std::wstring url = webdriver::HookProcessor::CopyWStringFromBuffer();
int driver_process_id = static_cast<int>(call_window_proc_struct->wParam);
CComPtr<IUri> uri_pointer;
HRESULT hr = ::CreateUri(url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &uri_pointer);
DWORD scheme = 0;
uri_pointer->GetScheme(&scheme);
CComBSTR scheme_bstr;
uri_pointer->GetSchemeName(&scheme_bstr);
CComBSTR host_bstr;
uri_pointer->GetHost(&host_bstr);
CComBSTR path_bstr;
uri_pointer->GetPath(&path_bstr);
std::wstring parsed_uri = scheme_bstr;
parsed_uri.append(L"":    parsed_uri.append(host_bstr);
parsed_uri.append(path_bstr);
InternetGetCookieEx2Proc get_cookie_proc = NULL;
InternetFreeCookiesProc free_cookies_proc = NULL;
HMODULE wininet_handle = ::GetModuleHandle(L""wininet"");
if (wininet_handle) {
get_cookie_proc = reinterpret_cast<InternetGetCookieEx2Proc>(::GetProcAddress(wininet_handle, ""InternetGetCookieEx2""));
free_cookies_proc = reinterpret_cast<InternetFreeCookiesProc>(::GetProcAddress(wininet_handle, ""InternetFreeCookies""));
}
DWORD cookie_count = 0;
INTERNETCOOKIE2* cookie_pointer = NULL;
DWORD success = 1;
if (get_cookie_proc) {
success = get_cookie_proc(parsed_uri.c_str(),
NULL,
INTERNET_COOKIE_NON_SCRIPT,
&cookie_pointer,
&cookie_count);
}
if (success == 0) {
std::wstring all_cookies = L"""";
for (DWORD cookie_index = 0; cookie_index < cookie_count; ++cookie_index) {
if (all_cookies.size() > 0) {
all_cookies.append(L""\n*\n"");
}
INTERNETCOOKIE2* current_cookie = cookie_pointer + cookie_index;
std::wstring cookie_name = current_cookie->pwszName;
std::wstring cookie_value = L"""";
if (current_cookie->pwszValue) {
cookie_value = current_cookie->pwszValue;
}
std::wstring cookie_domain = L"""";
if (current_cookie->pwszDomain) {
cookie_domain = current_cookie->pwszDomain;
}
std::wstring cookie_path = L"""";
if (current_cookie->pwszPath) {
cookie_path = current_cookie->pwszPath;
}
DWORD flags = current_cookie->dwFlags;
FILETIME expires = current_cookie->ftExpires;
all_cookies.append(cookie_name).append(L""\n"");
all_cookies.append(cookie_value).append(L""\n"");
all_cookies.append(cookie_domain).append(L""/"").append(cookie_path).append(L""\n"");
all_cookies.append(std::to_wstring(flags)).append(L""\n"");
if (current_cookie->fExpiresSet) {
all_cookies.append(std::to_wstring(expires.dwLowDateTime)).append(L""\n"");
all_cookies.append(std::to_wstring(expires.dwHighDateTime)).append(L""\n"");
} else {
all_cookies.append(L""\n\n"");
}
}
free_cookies_proc(cookie_pointer, cookie_count);
webdriver::HookProcessor::CopyWStringToBuffer(all_cookies);
} else {
webdriver::HookProcessor::SetDataBufferSize(sizeof(wchar_t));
}
webdriver::HookProcessor::WriteBufferToPipe(driver_process_id);
} else if (WD_GET_HTTPONLY_COOKIES == call_window_proc_struct->message ||
WD_GET_SCRIPTABLE_COOKIES == call_window_proc_struct->message ||
WD_GET_SECURE_COOKIES == call_window_proc_struct->message) {
std::wstring url = webdriver::HookProcessor::CopyWStringFromBuffer();
int driver_process_id = static_cast<int>(call_window_proc_struct->wParam);
DWORD get_cookie_flags = 0;
if (WD_GET_HTTPONLY_COOKIES == call_window_proc_struct->message ||
WD_GET_SECURE_COOKIES == call_window_proc_struct->message) {
get_cookie_flags = INTERNET_COOKIE_HTTPONLY;
}
CComPtr<IUri> uri_pointer;
HRESULT hr = ::CreateUri(url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &uri_pointer);
DWORD scheme = 0;
uri_pointer->GetScheme(&scheme);
CComBSTR scheme_bstr;
uri_pointer->GetSchemeName(&scheme_bstr);
CComBSTR host_bstr;
uri_pointer->GetHost(&host_bstr);
CComBSTR path_bstr;
uri_pointer->GetPath(&path_bstr);
std::wstring parsed_uri = L""http"";
if ((WD_GET_SECURE_COOKIES == call_window_proc_struct->message ||
WD_GET_SCRIPTABLE_COOKIES == call_window_proc_struct->message) &&
URL_SCHEME_HTTPS == scheme) {
parsed_uri.append(L""s"");
}
parsed_uri.append(L"":    parsed_uri.append(host_bstr);
parsed_uri.append(path_bstr);
DWORD buffer_size = 0;
BOOL success = ::InternetGetCookieEx(parsed_uri.c_str(),
NULL,
NULL,
&buffer_size,
get_cookie_flags,
NULL);
if (success) {
webdriver::HookProcessor::SetDataBufferSize(buffer_size);
::InternetGetCookieEx(parsed_uri.c_str(),
NULL,
reinterpret_cast<LPTSTR>(webdriver::HookProcessor::GetDataBufferAddress()),
&buffer_size,
get_cookie_flags,
NULL);
webdriver::HookProcessor::WriteBufferToPipe(driver_process_id);
} else {
if (ERROR_NO_MORE_ITEMS == ::GetLastError()) {
webdriver::HookProcessor::SetDataBufferSize(sizeof(wchar_t));
webdriver::HookProcessor::WriteBufferToPipe(driver_process_id);
}
}
} else if (WD_GET_COOKIE_CACHE_FILES == call_window_proc_struct->message) {
int driver_process_id = static_cast<int>(call_window_proc_struct->wParam);
std::wstring file_list = L"""";
std::wstring url = webdriver::HookProcessor::CopyWStringFromBuffer();
CComPtr<IUri> uri_pointer;
HRESULT hr = ::CreateUri(url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &uri_pointer);
CComBSTR host_bstr;
uri_pointer->GetHost(&host_bstr);
CComBSTR path_bstr;
uri_pointer->GetPath(&path_bstr);
std::wstring parsed_uri = host_bstr;
parsed_uri.append(path_bstr);
HANDLE cache_enum_handle = NULL;
DWORD entry_size = 2048;
LPINTERNET_CACHE_ENTRY_INFO entry = NULL;
std::vector<char> entry_buffer(entry_size);
entry = reinterpret_cast<INTERNET_CACHE_ENTRY_INFO*>(&entry_buffer[0]);
cache_enum_handle = ::FindFirstUrlCacheEntry(L""cookie:"",
entry,
&entry_size);
if (cache_enum_handle == NULL &&
ERROR_INSUFFICIENT_BUFFER == ::GetLastError()) {
entry_buffer.resize(entry_size);
entry = reinterpret_cast<INTERNET_CACHE_ENTRY_INFO*>(&entry_buffer[0]);
cache_enum_handle = ::FindFirstUrlCacheEntry(L""cookie:"",
entry,
&entry_size);
}
while (cache_enum_handle != NULL) {
if (COOKIE_CACHE_ENTRY == (entry->CacheEntryType & COOKIE_CACHE_ENTRY)) {
std::wstring name = entry->lpszSourceUrlName;
size_t name_separator_pos(name.find_first_of(L""@""));
std::wstring domain = name.substr(name_separator_pos + 1);
if (parsed_uri.find(domain) != std::wstring::npos) {
if (file_list.size() > 0) {
file_list.append(L""|"");
}
file_list.append(entry->lpszLocalFileName);
}
}
BOOL success = ::FindNextUrlCacheEntry(cache_enum_handle,
entry,
&entry_size);
if (!success) {
DWORD error = ::GetLastError();
if (ERROR_INSUFFICIENT_BUFFER == error) {
entry_buffer.resize(entry_size);
BOOL other_success = ::FindNextUrlCacheEntry(cache_enum_handle,
entry,
&entry_size);
} else if (ERROR_NO_MORE_ITEMS == error) {
::FindCloseUrlCache(cache_enum_handle);
cache_enum_handle = NULL;
}
}
}
webdriver::HookProcessor::CopyWStringToBuffer(file_list);
webdriver::HookProcessor::WriteBufferToPipe(driver_process_id);
} else if (WD_SET_COOKIE == call_window_proc_struct->message) {
DWORD set_cookie_flags = static_cast<DWORD>(call_window_proc_struct->wParam);
std::wstring cookie_data = webdriver::HookProcessor::CopyWStringFromBuffer();
size_t url_separator_pos = cookie_data.find_first_of(L""|"");
std::wstring url = cookie_data.substr(0, url_separator_pos);
std::wstring cookie = cookie_data.substr(url_separator_pos + 1);
CComPtr<IUri> uri_pointer;
HRESULT hr = ::CreateUri(url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &uri_pointer);
CComBSTR scheme_bstr;
uri_pointer->GetSchemeName(&scheme_bstr);
CComBSTR host_bstr;
uri_pointer->GetHost(&host_bstr);
std::wstring parsed_uri = scheme_bstr;
parsed_uri.append(L"":    parsed_uri.append(host_bstr);
DWORD cookie_set = ::InternetSetCookieEx(parsed_uri.c_str(),
NULL,
cookie.c_str(),
set_cookie_flags,
NULL);
if (cookie_set) {
webdriver::HookProcessor::SetDataBufferSize(0);
} else {
DWORD error = ::GetLastError();
webdriver::HookProcessor::SetDataBufferSize(error);
}
}
return ::CallNextHookEx(NULL, nCode, wParam, lParam);
}","LRESULT VAR_0 CookieWndProc(int VAR_1, WPARAM VAR_2, LPARAM VAR_3) {
CWPSTRUCT* VAR_4 = VAR_5<CWPSTRUCT*>(VAR_3);
if (VAR_6 == VAR_4->message) {
COPYDATASTRUCT* VAR_7 = VAR_5<COPYDATASTRUCT*>(VAR_4->lParam);
webdriver::HookProcessor::CopyDataToBuffer(VAR_7->cbData, VAR_7->lpData);
} else if (VAR_8 == VAR_4->message) {
std::wstring VAR_9 = webdriver::HookProcessor::CopyWStringFromBuffer();
int VAR_10 = VAR_11<int>(VAR_4->wParam);
CComPtr<IUri> VAR_12;
HRESULT VAR_13 = ::CreateUri(VAR_9.c_str(), VAR_14, 0, &VAR_12);
DWORD VAR_15 = 0;
VAR_12->GetScheme(&VAR_15);
CComBSTR VAR_16;
VAR_12->GetSchemeName(&VAR_16);
CComBSTR VAR_17;
VAR_12->GetHost(&VAR_17);
CComBSTR VAR_18;
VAR_12->GetPath(&VAR_18);
std::wstring VAR_19 = VAR_16;
VAR_19.append(L""://"");
VAR_19.append(VAR_17);
VAR_19.append(VAR_18);
InternetGetCookieEx2Proc VAR_20 = NULL;
InternetFreeCookiesProc VAR_21 = NULL;
HMODULE VAR_22 = ::GetModuleHandle(L""wininet"");
if (VAR_22) {
VAR_20 = VAR_5<InternetGetCookieEx2Proc>(::GetProcAddress(VAR_22, ""InternetGetCookieEx2""));
VAR_21 = VAR_5<InternetFreeCookiesProc>(::GetProcAddress(VAR_22, ""InternetFreeCookies""));
}
DWORD VAR_23 = 0;
INTERNETCOOKIE2* VAR_24 = NULL;
DWORD VAR_25 = 1;
if (VAR_20) {
VAR_25 = VAR_20(VAR_19.c_str(),
NULL,
VAR_26,
&VAR_24,
&VAR_23);
}
if (VAR_25 == 0) {
std::wstring VAR_27 = L"""";
for (DWORD VAR_28 = 0; VAR_28 < VAR_23; ++VAR_28) {
if (VAR_27.size() > 0) {
VAR_27.append(L""\n*\n"");
}
INTERNETCOOKIE2* VAR_29 = VAR_24 + VAR_28;
std::wstring VAR_30 = VAR_29->pwszName;
std::wstring VAR_31 = L"""";
if (VAR_29->pwszValue) {
VAR_31 = VAR_29->pwszValue;
}
std::wstring VAR_32 = L"""";
if (VAR_29->pwszDomain) {
VAR_32 = VAR_29->pwszDomain;
}
std::wstring VAR_33 = L"""";
if (VAR_29->pwszPath) {
VAR_33 = VAR_29->pwszPath;
}
DWORD VAR_34 = VAR_29->dwFlags;
FILETIME VAR_35 = VAR_29->ftExpires;
VAR_27.append(VAR_30).append(L""\n"");
VAR_27.append(VAR_31).append(L""\n"");
VAR_27.append(VAR_32).append(L""/"").append(VAR_33).append(L""\n"");
VAR_27.append(std::to_wstring(VAR_34)).append(L""\n"");
if (VAR_29->fExpiresSet) {
VAR_27.append(std::to_wstring(VAR_35.dwLowDateTime)).append(L""\n"");
VAR_27.append(std::to_wstring(VAR_35.dwHighDateTime)).append(L""\n"");
} else {
VAR_27.append(L""\n\n"");
}
}
VAR_21(VAR_24, VAR_23);
webdriver::HookProcessor::CopyWStringToBuffer(VAR_27);
} else {
webdriver::HookProcessor::SetDataBufferSize(sizeof(VAR_36));
}
webdriver::HookProcessor::WriteBufferToPipe(VAR_10);
} else if (VAR_37 == VAR_4->message ||
VAR_38 == VAR_4->message ||
VAR_39 == VAR_4->message) {
std::wstring VAR_9 = webdriver::HookProcessor::CopyWStringFromBuffer();
int VAR_10 = VAR_11<int>(VAR_4->wParam);
DWORD VAR_40 = 0;
if (VAR_37 == VAR_4->message ||
VAR_39 == VAR_4->message) {
VAR_40 = VAR_41;
}
CComPtr<IUri> VAR_12;
HRESULT VAR_13 = ::CreateUri(VAR_9.c_str(), VAR_14, 0, &VAR_12);
DWORD VAR_15 = 0;
VAR_12->GetScheme(&VAR_15);
CComBSTR VAR_16;
VAR_12->GetSchemeName(&VAR_16);
CComBSTR VAR_17;
VAR_12->GetHost(&VAR_17);
CComBSTR VAR_18;
VAR_12->GetPath(&VAR_18);
std::wstring VAR_19 = L""http"";
if ((VAR_39 == VAR_4->message ||
VAR_38 == VAR_4->message) &&
VAR_42 == VAR_15) {
VAR_19.append(L""s"");
}
VAR_19.append(L""://"");
VAR_19.append(VAR_17);
VAR_19.append(VAR_18);
DWORD VAR_43 = 0;
BOOL VAR_25 = ::InternetGetCookieEx(VAR_19.c_str(),
NULL,
NULL,
&VAR_43,
VAR_40,
NULL);
if (VAR_25) {
webdriver::HookProcessor::SetDataBufferSize(VAR_43);
::InternetGetCookieEx(VAR_19.c_str(),
NULL,
VAR_5<LPTSTR>(webdriver::HookProcessor::GetDataBufferAddress()),
&VAR_43,
VAR_40,
NULL);
webdriver::HookProcessor::WriteBufferToPipe(VAR_10);
} else {
if (VAR_44 == ::GetLastError()) {
webdriver::HookProcessor::SetDataBufferSize(sizeof(VAR_36));
webdriver::HookProcessor::WriteBufferToPipe(VAR_10);
}
}
} else if (VAR_45 == VAR_4->message) {
int VAR_10 = VAR_11<int>(VAR_4->wParam);
std::wstring VAR_46 = L"""";
std::wstring VAR_9 = webdriver::HookProcessor::CopyWStringFromBuffer();
CComPtr<IUri> VAR_12;
HRESULT VAR_13 = ::CreateUri(VAR_9.c_str(), VAR_14, 0, &VAR_12);
CComBSTR VAR_17;
VAR_12->GetHost(&VAR_17);
CComBSTR VAR_18;
VAR_12->GetPath(&VAR_18);
std::wstring VAR_19 = VAR_17;
VAR_19.append(VAR_18);
HANDLE VAR_47 = NULL;
DWORD VAR_48 = 2048;
LPINTERNET_CACHE_ENTRY_INFO VAR_49 = NULL;
std::vector<char> entry_buffer(entry_size);
VAR_49 = VAR_5<INTERNET_CACHE_ENTRY_INFO*>(&VAR_50[0]);
VAR_47 = ::FindFirstUrlCacheEntry(L""cookie:"",
VAR_49,
&entry_size);
if (VAR_47 == NULL &&
VAR_51 == ::GetLastError()) {
VAR_50.resize(entry_size);
VAR_49 = VAR_5<INTERNET_CACHE_ENTRY_INFO*>(&VAR_50[0]);
VAR_47 = ::FindFirstUrlCacheEntry(L""cookie:"",
VAR_49,
&entry_size);
}
while (VAR_47 != NULL) {
if (VAR_52 == (VAR_49->CacheEntryType & VAR_52)) {
std::wstring VAR_53 = VAR_49->lpszSourceUrlName;
size_t VAR_54(VAR_53.find_first_of(L""@""));
std::wstring VAR_55 = VAR_53.substr(VAR_54 + 1);
if (VAR_19.find(VAR_55) != std::wstring::npos) {
if (VAR_46.size() > 0) {
VAR_46.append(L""|"");
}
VAR_46.append(VAR_49->lpszLocalFileName);
}
}
BOOL VAR_25 = ::FindNextUrlCacheEntry(VAR_47,
VAR_49,
&entry_size);
if (!VAR_25) {
DWORD VAR_56 = ::GetLastError();
if (VAR_51 == VAR_56) {
VAR_50.resize(entry_size);
BOOL VAR_57 = ::FindNextUrlCacheEntry(VAR_47,
VAR_49,
&entry_size);
} else if (VAR_44 == VAR_56) {
::FindCloseUrlCache(VAR_47);
VAR_47 = NULL;
}
}
}
webdriver::HookProcessor::CopyWStringToBuffer(VAR_46);
webdriver::HookProcessor::WriteBufferToPipe(VAR_10);
} else if (VAR_58 == VAR_4->message) {
DWORD VAR_59 = VAR_11<DWORD>(VAR_4->wParam);
std::wstring VAR_60 = webdriver::HookProcessor::CopyWStringFromBuffer();
size_t VAR_61 = VAR_60.find_first_of(L""|"");
std::wstring VAR_9 = VAR_60.substr(0, VAR_61);
std::wstring VAR_62 = VAR_60.substr(VAR_61 + 1);
CComPtr<IUri> VAR_12;
HRESULT VAR_13 = ::CreateUri(VAR_9.c_str(), VAR_14, 0, &VAR_12);
CComBSTR VAR_16;
VAR_12->GetSchemeName(&VAR_16);
CComBSTR VAR_17;
VAR_12->GetHost(&VAR_17);
std::wstring VAR_19 = VAR_16;
VAR_19.append(L""://"");
VAR_19.append(VAR_17);
DWORD VAR_63 = ::InternetSetCookieEx(VAR_19.c_str(),
NULL,
VAR_62.c_str(),
VAR_59,
NULL);
if (VAR_63) {
webdriver::HookProcessor::SetDataBufferSize(0);
} else {
DWORD VAR_56 = ::GetLastError();
webdriver::HookProcessor::SetDataBufferSize(VAR_56);
}
}
return ::CallNextHookEx(NULL, VAR_1, VAR_2, VAR_3);
}",,"LRESULT CALLBACK CookieWndProc(int nCode, WPARAM wParam, LPARAM lParam) {
  CWPSTRUCT* call_window_proc_struct = reinterpret_cast<CWPSTRUCT*>(lParam);
  if (WM_COPYDATA == call_window_proc_struct->message) {
    COPYDATASTRUCT* data = reinterpret_cast<COPYDATASTRUCT*>(call_window_proc_struct->lParam);
    webdriver::HookProcessor::CopyDataToBuffer(data->cbData, data->lpData);
  } else if (WD_GET_ALL_COOKIES == call_window_proc_struct->message) {
    std::wstring url = webdriver::HookProcessor::CopyWStringFromBuffer();
    int driver_process_id = static_cast<int>(call_window_proc_struct->wParam);

    CComPtr<IUri> uri_pointer;
    HRESULT hr = ::CreateUri(url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &uri_pointer);
    DWORD scheme = 0;
    uri_pointer->GetScheme(&scheme);
    CComBSTR scheme_bstr;
    uri_pointer->GetSchemeName(&scheme_bstr);
    CComBSTR host_bstr;
    uri_pointer->GetHost(&host_bstr);
    CComBSTR path_bstr;
    uri_pointer->GetPath(&path_bstr);
    
    std::wstring parsed_uri = scheme_bstr;
    parsed_uri.append(L""://"");
    parsed_uri.append(host_bstr);
    parsed_uri.append(path_bstr);

    InternetGetCookieEx2Proc get_cookie_proc = NULL;
    InternetFreeCookiesProc free_cookies_proc = NULL;
    HMODULE wininet_handle = ::GetModuleHandle(L""wininet"");
    if (wininet_handle) {
      get_cookie_proc = reinterpret_cast<InternetGetCookieEx2Proc>(::GetProcAddress(wininet_handle, ""InternetGetCookieEx2""));
      free_cookies_proc = reinterpret_cast<InternetFreeCookiesProc>(::GetProcAddress(wininet_handle, ""InternetFreeCookies""));
    }

    DWORD cookie_count = 0;
    INTERNETCOOKIE2* cookie_pointer = NULL;
    DWORD success = 1;
    if (get_cookie_proc) {
      success = get_cookie_proc(parsed_uri.c_str(),
                                NULL,
                                INTERNET_COOKIE_NON_SCRIPT,
                                &cookie_pointer,
                                &cookie_count);
    }

    if (success == 0) {
      // Mimic the format of the old persistent cookie files for ease of
      // transmission back to the driver and parsing.
      std::wstring all_cookies = L"""";
      for (DWORD cookie_index = 0; cookie_index < cookie_count; ++cookie_index) {
        if (all_cookies.size() > 0) {
          all_cookies.append(L""\n*\n"");
        }
        INTERNETCOOKIE2* current_cookie = cookie_pointer + cookie_index;
        std::wstring cookie_name = L"""";
        if (current_cookie->pwszName) {
          // Note that the spec appears to allow ""nameless"" cookies,
          // which clients like Selenium may not support.
          cookie_name = current_cookie->pwszName;
        }
        std::wstring cookie_value = L"""";
        if (current_cookie->pwszValue) {
          cookie_value = current_cookie->pwszValue;
        }

        // TODO: The spec does not allow a cookie with an empty name
        // and value. It's unclear what the driver could do in this
        // case, but we should probably handle it somehow in the off
        // chance it ever comes up.
        std::wstring cookie_domain = L"""";
        if (current_cookie->pwszDomain) {
          cookie_domain = current_cookie->pwszDomain;
        }
        std::wstring cookie_path = L"""";
        if (current_cookie->pwszPath) {
          cookie_path = current_cookie->pwszPath;
        }
        DWORD flags = current_cookie->dwFlags;
        FILETIME expires = current_cookie->ftExpires;
        all_cookies.append(cookie_name).append(L""\n"");
        all_cookies.append(cookie_value).append(L""\n"");
        all_cookies.append(cookie_domain).append(L""/"").append(cookie_path).append(L""\n"");
        all_cookies.append(std::to_wstring(flags)).append(L""\n"");
        // If the expiration time is set, add it to the string for the cookie.
        // If not, append empty fields to the record so subsequent parsing
        // of the string will still work.
        if (current_cookie->fExpiresSet) {
          all_cookies.append(std::to_wstring(expires.dwLowDateTime)).append(L""\n"");
          all_cookies.append(std::to_wstring(expires.dwHighDateTime)).append(L""\n"");
        } else {
          all_cookies.append(L""\n\n"");
        }
      }
      free_cookies_proc(cookie_pointer, cookie_count);
      webdriver::HookProcessor::CopyWStringToBuffer(all_cookies);
    } else {
      webdriver::HookProcessor::SetDataBufferSize(sizeof(wchar_t));
    }
    webdriver::HookProcessor::WriteBufferToPipe(driver_process_id);
  } else if (WD_GET_HTTPONLY_COOKIES == call_window_proc_struct->message ||
             WD_GET_SCRIPTABLE_COOKIES == call_window_proc_struct->message ||
             WD_GET_SECURE_COOKIES == call_window_proc_struct->message) {
    std::wstring url = webdriver::HookProcessor::CopyWStringFromBuffer();
    int driver_process_id = static_cast<int>(call_window_proc_struct->wParam);

    DWORD get_cookie_flags = 0;
    if (WD_GET_HTTPONLY_COOKIES == call_window_proc_struct->message ||
      WD_GET_SECURE_COOKIES == call_window_proc_struct->message) {
      get_cookie_flags = INTERNET_COOKIE_HTTPONLY;
    }

    CComPtr<IUri> uri_pointer;
    HRESULT hr = ::CreateUri(url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &uri_pointer);
    DWORD scheme = 0;
    uri_pointer->GetScheme(&scheme);
    CComBSTR scheme_bstr;
    uri_pointer->GetSchemeName(&scheme_bstr);
    CComBSTR host_bstr;
    uri_pointer->GetHost(&host_bstr);
    CComBSTR path_bstr;
    uri_pointer->GetPath(&path_bstr);

    // Get only the cookies for the base URL, omitting port, if there is one.
    // N.B., we only return cookies secure cookies when browsing a site using
    // SSL. The browser won't see cookies with the 'secure' flag for sites
    // visited using plain http.
    std::wstring parsed_uri = L""http"";
    if ((WD_GET_SECURE_COOKIES == call_window_proc_struct->message ||
         WD_GET_SCRIPTABLE_COOKIES == call_window_proc_struct->message) &&
        URL_SCHEME_HTTPS == scheme) {
      parsed_uri.append(L""s"");
    }
    parsed_uri.append(L""://"");
    parsed_uri.append(host_bstr);
    parsed_uri.append(path_bstr);

    // Call InternetGetCookieEx once to get the size of the buffer needed,
    // then call again with the appropriately sized buffer allocated.
    DWORD buffer_size = 0;
    BOOL success = ::InternetGetCookieEx(parsed_uri.c_str(),
                                         NULL,
                                         NULL,
                                         &buffer_size,
                                         get_cookie_flags,
                                         NULL);
    if (success) {
      webdriver::HookProcessor::SetDataBufferSize(buffer_size);
      ::InternetGetCookieEx(parsed_uri.c_str(),
                            NULL,
                            reinterpret_cast<LPTSTR>(webdriver::HookProcessor::GetDataBufferAddress()),
                            &buffer_size,
                            get_cookie_flags,
                            NULL);

      webdriver::HookProcessor::WriteBufferToPipe(driver_process_id);
    } else {
      if (ERROR_NO_MORE_ITEMS == ::GetLastError()) {
        webdriver::HookProcessor::SetDataBufferSize(sizeof(wchar_t));
        webdriver::HookProcessor::WriteBufferToPipe(driver_process_id);
      }
    }
  } else if (WD_GET_COOKIE_CACHE_FILES == call_window_proc_struct->message) {
    int driver_process_id = static_cast<int>(call_window_proc_struct->wParam);
    std::wstring file_list = L"""";
    std::wstring url = webdriver::HookProcessor::CopyWStringFromBuffer();

    // We need to remove the port to find the entry in the cache.
    CComPtr<IUri> uri_pointer;
    HRESULT hr = ::CreateUri(url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &uri_pointer);
    CComBSTR host_bstr;
    uri_pointer->GetHost(&host_bstr);
    CComBSTR path_bstr;
    uri_pointer->GetPath(&path_bstr);
    std::wstring parsed_uri = host_bstr;
    parsed_uri.append(path_bstr);

    // A 2048-byte buffer should be large enough to handle cookie
    // cache entries in all but the most extreme cases.
    HANDLE cache_enum_handle = NULL;
    DWORD entry_size = 2048;
    LPINTERNET_CACHE_ENTRY_INFO entry = NULL;
    std::vector<char> entry_buffer(entry_size);
    entry = reinterpret_cast<INTERNET_CACHE_ENTRY_INFO*>(&entry_buffer[0]);
    cache_enum_handle = ::FindFirstUrlCacheEntry(L""cookie:"",
                                                 entry,
                                                 &entry_size);
    if (cache_enum_handle == NULL &&
        ERROR_INSUFFICIENT_BUFFER == ::GetLastError()) {
      entry_buffer.resize(entry_size);
      entry = reinterpret_cast<INTERNET_CACHE_ENTRY_INFO*>(&entry_buffer[0]);
      cache_enum_handle = ::FindFirstUrlCacheEntry(L""cookie:"",
                                                   entry,
                                                   &entry_size);
    }
    while (cache_enum_handle != NULL) {
      if (COOKIE_CACHE_ENTRY == (entry->CacheEntryType & COOKIE_CACHE_ENTRY)) {
        std::wstring name = entry->lpszSourceUrlName;
        size_t name_separator_pos(name.find_first_of(L""@""));
        std::wstring domain = name.substr(name_separator_pos + 1);
        if (parsed_uri.find(domain) != std::wstring::npos) {
          if (file_list.size() > 0) {
            file_list.append(L""|"");
          }
          file_list.append(entry->lpszLocalFileName);
        }
      }
      BOOL success = ::FindNextUrlCacheEntry(cache_enum_handle,
                                             entry,
                                             &entry_size);
      if (!success) {
        DWORD error = ::GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER == error) {
          entry_buffer.resize(entry_size);
          BOOL other_success = ::FindNextUrlCacheEntry(cache_enum_handle,
                                                       entry,
                                                       &entry_size);
        } else if (ERROR_NO_MORE_ITEMS == error) {
          ::FindCloseUrlCache(cache_enum_handle);
          cache_enum_handle = NULL;
        }
      }
    }
    webdriver::HookProcessor::CopyWStringToBuffer(file_list);
    webdriver::HookProcessor::WriteBufferToPipe(driver_process_id);
  } else if (WD_SET_COOKIE == call_window_proc_struct->message) {
    DWORD set_cookie_flags = static_cast<DWORD>(call_window_proc_struct->wParam);
    std::wstring cookie_data = webdriver::HookProcessor::CopyWStringFromBuffer();
    size_t url_separator_pos = cookie_data.find_first_of(L""|"");
    std::wstring url = cookie_data.substr(0, url_separator_pos);
    std::wstring cookie = cookie_data.substr(url_separator_pos + 1);

    CComPtr<IUri> uri_pointer;
    HRESULT hr = ::CreateUri(url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &uri_pointer);
    CComBSTR scheme_bstr;
    uri_pointer->GetSchemeName(&scheme_bstr);
    CComBSTR host_bstr;
    uri_pointer->GetHost(&host_bstr);
    std::wstring parsed_uri = scheme_bstr;
    parsed_uri.append(L""://"");
    parsed_uri.append(host_bstr);

    // Leverage the shared data buffer size to return the error code
    // back to the driver, if necessary.
    DWORD cookie_set = ::InternetSetCookieEx(parsed_uri.c_str(),
                                             NULL,
                                             cookie.c_str(),
                                             set_cookie_flags,
                                             NULL);
    if (cookie_set) {
      webdriver::HookProcessor::SetDataBufferSize(0);
    } else {
      DWORD error = ::GetLastError();
      webdriver::HookProcessor::SetDataBufferSize(error);
    }
  }
  return ::CallNextHookEx(NULL, nCode, wParam, lParam);
}","LRESULT VAR_0 CookieWndProc(int VAR_1, WPARAM VAR_2, LPARAM VAR_3) {
  CWPSTRUCT* VAR_4 = VAR_5<CWPSTRUCT*>(VAR_3);
  if (VAR_6 == VAR_4->message) {
    COPYDATASTRUCT* VAR_7 = VAR_5<COPYDATASTRUCT*>(VAR_4->lParam);
    webdriver::HookProcessor::CopyDataToBuffer(VAR_7->cbData, VAR_7->lpData);
  } else if (VAR_8 == VAR_4->message) {
    std::wstring VAR_9 = webdriver::HookProcessor::CopyWStringFromBuffer();
    int VAR_10 = VAR_11<int>(VAR_4->wParam);

    CComPtr<IUri> VAR_12;
    HRESULT VAR_13 = ::CreateUri(VAR_9.c_str(), VAR_14, 0, &VAR_12);
    DWORD VAR_15 = 0;
    VAR_12->GetScheme(&VAR_15);
    CComBSTR VAR_16;
    VAR_12->GetSchemeName(&VAR_16);
    CComBSTR VAR_17;
    VAR_12->GetHost(&VAR_17);
    CComBSTR VAR_18;
    VAR_12->GetPath(&VAR_18);
    
    std::wstring VAR_19 = VAR_16;
    VAR_19.append(L""://"");
    VAR_19.append(VAR_17);
    VAR_19.append(VAR_18);

    InternetGetCookieEx2Proc VAR_20 = NULL;
    InternetFreeCookiesProc VAR_21 = NULL;
    HMODULE VAR_22 = ::GetModuleHandle(L""wininet"");
    if (VAR_22) {
      VAR_20 = VAR_5<InternetGetCookieEx2Proc>(::GetProcAddress(VAR_22, ""InternetGetCookieEx2""));
      VAR_21 = VAR_5<InternetFreeCookiesProc>(::GetProcAddress(VAR_22, ""InternetFreeCookies""));
    }

    DWORD VAR_23 = 0;
    INTERNETCOOKIE2* VAR_24 = NULL;
    DWORD VAR_25 = 1;
    if (VAR_20) {
      VAR_25 = VAR_20(VAR_19.c_str(),
                                NULL,
                                VAR_26,
                                &VAR_24,
                                &VAR_23);
    }

    if (VAR_25 == 0) {
      /* COMMENT_0 */
      /* COMMENT_1 */
      std::wstring VAR_27 = L"""";
      for (DWORD VAR_28 = 0; VAR_28 < VAR_23; ++VAR_28) {
        if (VAR_27.size() > 0) {
          VAR_27.append(L""\n*\n"");
        }
        INTERNETCOOKIE2* VAR_29 = VAR_24 + VAR_28;
        std::wstring VAR_30 = L"""";
        if (VAR_29->pwszName) {
          /* COMMENT_2 */
          /* COMMENT_3 */
          VAR_30 = VAR_29->pwszName;
        }
        std::wstring VAR_31 = L"""";
        if (VAR_29->pwszValue) {
          VAR_31 = VAR_29->pwszValue;
        }

        /* COMMENT_4 */
        /* COMMENT_5 */
        /* COMMENT_6 */
        /* COMMENT_7 */
        std::wstring VAR_32 = L"""";
        if (VAR_29->pwszDomain) {
          VAR_32 = VAR_29->pwszDomain;
        }
        std::wstring VAR_33 = L"""";
        if (VAR_29->pwszPath) {
          VAR_33 = VAR_29->pwszPath;
        }
        DWORD VAR_34 = VAR_29->dwFlags;
        FILETIME VAR_35 = VAR_29->ftExpires;
        VAR_27.append(VAR_30).append(L""\n"");
        VAR_27.append(VAR_31).append(L""\n"");
        VAR_27.append(VAR_32).append(L""/"").append(VAR_33).append(L""\n"");
        VAR_27.append(std::to_wstring(VAR_34)).append(L""\n"");
        /* COMMENT_8 */
        /* COMMENT_9 */
        /* COMMENT_10 */
        if (VAR_29->fExpiresSet) {
          VAR_27.append(std::to_wstring(VAR_35.dwLowDateTime)).append(L""\n"");
          VAR_27.append(std::to_wstring(VAR_35.dwHighDateTime)).append(L""\n"");
        } else {
          VAR_27.append(L""\n\n"");
        }
      }
      VAR_21(VAR_24, VAR_23);
      webdriver::HookProcessor::CopyWStringToBuffer(VAR_27);
    } else {
      webdriver::HookProcessor::SetDataBufferSize(sizeof(VAR_36));
    }
    webdriver::HookProcessor::WriteBufferToPipe(VAR_10);
  } else if (VAR_37 == VAR_4->message ||
             VAR_38 == VAR_4->message ||
             VAR_39 == VAR_4->message) {
    std::wstring VAR_9 = webdriver::HookProcessor::CopyWStringFromBuffer();
    int VAR_10 = VAR_11<int>(VAR_4->wParam);

    DWORD VAR_40 = 0;
    if (VAR_37 == VAR_4->message ||
      VAR_39 == VAR_4->message) {
      VAR_40 = VAR_41;
    }

    CComPtr<IUri> VAR_12;
    HRESULT VAR_13 = ::CreateUri(VAR_9.c_str(), VAR_14, 0, &VAR_12);
    DWORD VAR_15 = 0;
    VAR_12->GetScheme(&VAR_15);
    CComBSTR VAR_16;
    VAR_12->GetSchemeName(&VAR_16);
    CComBSTR VAR_17;
    VAR_12->GetHost(&VAR_17);
    CComBSTR VAR_18;
    VAR_12->GetPath(&VAR_18);

    /* COMMENT_11 */
    /* COMMENT_12 */
    /* COMMENT_13 */
    /* COMMENT_14 */
    std::wstring VAR_19 = L""http"";
    if ((VAR_39 == VAR_4->message ||
         VAR_38 == VAR_4->message) &&
        VAR_42 == VAR_15) {
      VAR_19.append(L""s"");
    }
    VAR_19.append(L""://"");
    VAR_19.append(VAR_17);
    VAR_19.append(VAR_18);

    /* COMMENT_15 */
    /* COMMENT_16 */
    DWORD VAR_43 = 0;
    BOOL VAR_25 = ::InternetGetCookieEx(VAR_19.c_str(),
                                         NULL,
                                         NULL,
                                         &VAR_43,
                                         VAR_40,
                                         NULL);
    if (VAR_25) {
      webdriver::HookProcessor::SetDataBufferSize(VAR_43);
      ::InternetGetCookieEx(VAR_19.c_str(),
                            NULL,
                            VAR_5<LPTSTR>(webdriver::HookProcessor::GetDataBufferAddress()),
                            &VAR_43,
                            VAR_40,
                            NULL);

      webdriver::HookProcessor::WriteBufferToPipe(VAR_10);
    } else {
      if (VAR_44 == ::GetLastError()) {
        webdriver::HookProcessor::SetDataBufferSize(sizeof(VAR_36));
        webdriver::HookProcessor::WriteBufferToPipe(VAR_10);
      }
    }
  } else if (VAR_45 == VAR_4->message) {
    int VAR_10 = VAR_11<int>(VAR_4->wParam);
    std::wstring VAR_46 = L"""";
    std::wstring VAR_9 = webdriver::HookProcessor::CopyWStringFromBuffer();

    /* COMMENT_17 */
    CComPtr<IUri> VAR_12;
    HRESULT VAR_13 = ::CreateUri(VAR_9.c_str(), VAR_14, 0, &VAR_12);
    CComBSTR VAR_17;
    VAR_12->GetHost(&VAR_17);
    CComBSTR VAR_18;
    VAR_12->GetPath(&VAR_18);
    std::wstring VAR_19 = VAR_17;
    VAR_19.append(VAR_18);

    /* COMMENT_18 */
    /* COMMENT_19 */
    HANDLE VAR_47 = NULL;
    DWORD VAR_48 = 2048;
    LPINTERNET_CACHE_ENTRY_INFO VAR_49 = NULL;
    std::vector<char> entry_buffer(entry_size);
    VAR_49 = VAR_5<INTERNET_CACHE_ENTRY_INFO*>(&VAR_50[0]);
    VAR_47 = ::FindFirstUrlCacheEntry(L""cookie:"",
                                                 VAR_49,
                                                 &entry_size);
    if (VAR_47 == NULL &&
        VAR_51 == ::GetLastError()) {
      VAR_50.resize(entry_size);
      VAR_49 = VAR_5<INTERNET_CACHE_ENTRY_INFO*>(&VAR_50[0]);
      VAR_47 = ::FindFirstUrlCacheEntry(L""cookie:"",
                                                   VAR_49,
                                                   &entry_size);
    }
    while (VAR_47 != NULL) {
      if (VAR_52 == (VAR_49->CacheEntryType & VAR_52)) {
        std::wstring VAR_53 = VAR_49->lpszSourceUrlName;
        size_t VAR_54(VAR_53.find_first_of(L""@""));
        std::wstring VAR_55 = VAR_53.substr(VAR_54 + 1);
        if (VAR_19.find(VAR_55) != std::wstring::npos) {
          if (VAR_46.size() > 0) {
            VAR_46.append(L""|"");
          }
          VAR_46.append(VAR_49->lpszLocalFileName);
        }
      }
      BOOL VAR_25 = ::FindNextUrlCacheEntry(VAR_47,
                                             VAR_49,
                                             &entry_size);
      if (!VAR_25) {
        DWORD VAR_56 = ::GetLastError();
        if (VAR_51 == VAR_56) {
          VAR_50.resize(entry_size);
          BOOL VAR_57 = ::FindNextUrlCacheEntry(VAR_47,
                                                       VAR_49,
                                                       &entry_size);
        } else if (VAR_44 == VAR_56) {
          ::FindCloseUrlCache(VAR_47);
          VAR_47 = NULL;
        }
      }
    }
    webdriver::HookProcessor::CopyWStringToBuffer(VAR_46);
    webdriver::HookProcessor::WriteBufferToPipe(VAR_10);
  } else if (VAR_58 == VAR_4->message) {
    DWORD VAR_59 = VAR_11<DWORD>(VAR_4->wParam);
    std::wstring VAR_60 = webdriver::HookProcessor::CopyWStringFromBuffer();
    size_t VAR_61 = VAR_60.find_first_of(L""|"");
    std::wstring VAR_9 = VAR_60.substr(0, VAR_61);
    std::wstring VAR_62 = VAR_60.substr(VAR_61 + 1);

    CComPtr<IUri> VAR_12;
    HRESULT VAR_13 = ::CreateUri(VAR_9.c_str(), VAR_14, 0, &VAR_12);
    CComBSTR VAR_16;
    VAR_12->GetSchemeName(&VAR_16);
    CComBSTR VAR_17;
    VAR_12->GetHost(&VAR_17);
    std::wstring VAR_19 = VAR_16;
    VAR_19.append(L""://"");
    VAR_19.append(VAR_17);

    /* COMMENT_20 */
    /* COMMENT_21 */
    DWORD VAR_63 = ::InternetSetCookieEx(VAR_19.c_str(),
                                             NULL,
                                             VAR_62.c_str(),
                                             VAR_59,
                                             NULL);
    if (VAR_63) {
      webdriver::HookProcessor::SetDataBufferSize(0);
    } else {
      DWORD VAR_56 = ::GetLastError();
      webdriver::HookProcessor::SetDataBufferSize(VAR_56);
    }
  }
  return ::CallNextHookEx(NULL, VAR_1, VAR_2, VAR_3);
}",,"--- func_before
+++ func_after
@@ -51,11 +51,21 @@
           all_cookies.append(L""\n*\n"");
         }
         INTERNETCOOKIE2* current_cookie = cookie_pointer + cookie_index;
-        std::wstring cookie_name = current_cookie->pwszName;
+        std::wstring cookie_name = L"""";
+        if (current_cookie->pwszName) {
+          // Note that the spec appears to allow ""nameless"" cookies,
+          // which clients like Selenium may not support.
+          cookie_name = current_cookie->pwszName;
+        }
         std::wstring cookie_value = L"""";
         if (current_cookie->pwszValue) {
           cookie_value = current_cookie->pwszValue;
         }
+
+        // TODO: The spec does not allow a cookie with an empty name
+        // and value. It's unclear what the driver could do in this
+        // case, but we should probably handle it somehow in the off
+        // chance it ever comes up.
         std::wstring cookie_domain = L"""";
         if (current_cookie->pwszDomain) {
           cookie_domain = current_cookie->pwszDomain;","{'deleted_lines': ['        std::wstring cookie_name = current_cookie->pwszName;'], 'added_lines': ['        std::wstring cookie_name = L"""";', '        if (current_cookie->pwszName) {', '          // Note that the spec appears to allow ""nameless"" cookies,', '          // which clients like Selenium may not support.', '          cookie_name = current_cookie->pwszName;', '        }', '', '        // TODO: The spec does not allow a cookie with an empty name', ""        // and value. It's unclear what the driver could do in this"", '        // case, but we should probably handle it somehow in the off', '        // chance it ever comes up.']}",True,NULL Pointer Dereference in GitHub repository seleniumhq/selenium prior to 4.14.0.,7.5,HIGH,2,test,2023-10-07T15:13:19Z,4
CVE-2023-45511,['CWE-401'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,justdan96/tsMuxer,Partial fix for issue #780.,78dd8fe480cdeb764f3ddc7c877f7528170661d8,https://github.com/justdan96/tsMuxer/commit/78dd8fe480cdeb764f3ddc7c877f7528170661d8,tsMuxer/h264StreamReader.cpp,H264StreamReader::checkStream,"CheckStreamRez H264StreamReader::checkStream(uint8_t *buffer, int len)
{
SEIUnit lastSEI;
SliceUnit slice;
CheckStreamRez rez;
uint8_t *end = buffer + len;
std::string tmpDescr;
bool pulldownInserted = false;
bool offsetsInserted = false;
for (uint8_t *nal = NALUnit::findNextNAL(buffer, end); nal < end - 4; nal = NALUnit::findNextNAL(nal, end))
{
if (*nal & 0x80)
return rez;
auto nalType = static_cast<NALUnit::NALType>(*nal & 0x1f);
const uint8_t *nextNal = NALUnit::findNALWithStartCode(nal, end, true);
if (!m_eof && nextNal == end)
break;
switch (nalType)
{
case NALUnit::NALType::nuSubSPS:
m_mvcSubStream = true;
[[fallthrough]];
case NALUnit::NALType::nuSPS:
{
if (nalType == NALUnit::NALType::nuSPS)
m_mvcPrimaryStream = true;
auto sps = new SPSUnit();
sps->decodeBuffer(nal, nextNal);
if (sps->deserialize() != 0)
{
delete sps;
return rez;
}
m_spsMap.insert(make_pair(sps->seq_parameter_set_id, sps));
if (tmpDescr.empty())
tmpDescr = sps->getStreamDescr();
break;
}
case NALUnit::NALType::nuPPS:
{
auto pps = new PPSUnit();
pps->decodeBuffer(nal, nextNal);
if (pps->deserialize() != 0)
{
delete pps;
return rez;
}
if (m_spsMap.find(pps->seq_parameter_set_id) == m_spsMap.end())
{
delete pps;
break;
}
m_ppsMap.insert(make_pair(pps->pic_parameter_set_id, pps));
break;
}
case NALUnit::NALType::nuSEI:
if (!m_spsMap.empty())
{
SPSUnit *sps = m_spsMap.begin()->second;
lastSEI.decodeBuffer(nal, nextNal);
lastSEI.deserialize(*sps, sps->nalHrdParams.isPresent || sps->vclHrdParams.isPresent);
if (lastSEI.pic_struct == 5 || lastSEI.pic_struct == 6 || lastSEI.pic_struct == 7 ||
lastSEI.pic_struct == 8)
{
if (!pulldownInserted)
{
pulldownInserted = true;
tmpDescr = sps->getStreamDescr();
tmpDescr += "" (pulldown)"";
}
}
if (!offsetsInserted && lastSEI.number_of_offset_sequences >= 0)
{
offsetsInserted = true;
tmpDescr += ""  3d-pg-planes: "" + int32ToStr(lastSEI.number_of_offset_sequences);
}
}
break;
case NALUnit::NALType::nuSliceIDR:
case NALUnit::NALType::nuSliceNonIDR:
case NALUnit::NALType::nuSliceA:
case NALUnit::NALType::nuSliceB:
case NALUnit::NALType::nuSliceC:
case NALUnit::NALType::nuSliceExt:
if (m_ppsMap.empty() || m_spsMap.empty())
break;
try
{
uint8_t tmpBuffer[512];
int toDecode = static_cast<int>(FFMIN(sizeof(tmpBuffer) - 8, nextNal - nal));
int decodedLen = SliceUnit::decodeNAL(nal, nal + toDecode, tmpBuffer, sizeof(tmpBuffer));
int nalRez = slice.deserialize(tmpBuffer, tmpBuffer + decodedLen, m_spsMap, m_ppsMap);
if (nalRez != 0)
return rez;
if (m_mvcSubStream)
rez.codecInfo = h264DepCodecInfo;
else
rez.codecInfo = h264CodecInfo;
rez.streamDescr = tmpDescr;
}
catch (BitStreamException &e)
{
(void)e;
return rez;
}
break;
default:
break;
}
}
if (m_mvcSubStream && m_mvcPrimaryStream)
rez.multiSubStream = true;
return rez;
}","CheckStreamRez H264StreamReader::checkStream(uint8_t *VAR_0, int VAR_1)
{
SEIUnit VAR_2;
SliceUnit VAR_3;
CheckStreamRez VAR_4;
uint8_t *VAR_5 = VAR_0 + VAR_1;
std::string VAR_6;
bool VAR_7 = false;
bool VAR_8 = false;
for (uint8_t *VAR_9 = NALUnit::findNextNAL(VAR_0, VAR_5); VAR_9 < VAR_5 - 4; VAR_9 = NALUnit::findNextNAL(VAR_9, VAR_5))
{
if (*VAR_9 & 0x80)
return VAR_4;
auto VAR_10 = VAR_11<NALUnit::NALType>(*VAR_9 & 0x1f);
const uint8_t *VAR_12 = NALUnit::findNALWithStartCode(VAR_9, VAR_5, true);
if (!VAR_13 && VAR_12 == VAR_5)
break;
switch (VAR_10)
{
case NALUnit::NALType::nuSubSPS:
VAR_14 = true;
[[VAR_15]];
case NALUnit::NALType::nuSPS:
{
if (VAR_10 == NALUnit::NALType::nuSPS)
VAR_16 = true;
auto VAR_17 = new SPSUnit();
VAR_17->decodeBuffer(VAR_9, VAR_12);
if (VAR_17->deserialize() != 0)
{
delete VAR_17;
return VAR_4;
}
VAR_18.insert(make_pair(VAR_17->seq_parameter_set_id, VAR_17));
if (VAR_6.empty())
VAR_6 = VAR_17->getStreamDescr();
break;
}
case NALUnit::NALType::nuPPS:
{
auto VAR_19 = new PPSUnit();
VAR_19->decodeBuffer(VAR_9, VAR_12);
if (VAR_19->deserialize() != 0)
{
delete VAR_19;
return VAR_4;
}
if (VAR_18.find(VAR_19->seq_parameter_set_id) == VAR_18.end())
{
delete VAR_19;
break;
}
VAR_20.insert(make_pair(VAR_19->pic_parameter_set_id, VAR_19));
break;
}
case NALUnit::NALType::nuSEI:
if (!VAR_18.empty())
{
SPSUnit *VAR_17 = VAR_18.begin()->second;
VAR_2.decodeBuffer(VAR_9, VAR_12);
VAR_2.deserialize(*VAR_17, VAR_17->nalHrdParams.isPresent || VAR_17->vclHrdParams.isPresent);
if (VAR_2.pic_struct == 5 || VAR_2.pic_struct == 6 || VAR_2.pic_struct == 7 ||
VAR_2.pic_struct == 8)
{
if (!VAR_7)
{
VAR_7 = true;
VAR_6 = VAR_17->getStreamDescr();
VAR_6 += "" (pulldown)"";
}
}
if (!VAR_8 && VAR_2.number_of_offset_sequences >= 0)
{
VAR_8 = true;
VAR_6 += ""  3d-pg-planes: "" + int32ToStr(VAR_2.number_of_offset_sequences);
}
}
break;
case NALUnit::NALType::nuSliceIDR:
case NALUnit::NALType::nuSliceNonIDR:
case NALUnit::NALType::nuSliceA:
case NALUnit::NALType::nuSliceB:
case NALUnit::NALType::nuSliceC:
case NALUnit::NALType::nuSliceExt:
if (VAR_20.empty() || VAR_18.empty())
break;
try
{
uint8_t VAR_21[512];
int VAR_22 = VAR_11<int>(FFMIN(sizeof(VAR_21) - 8, VAR_12 - VAR_9));
int VAR_23 = SliceUnit::decodeNAL(VAR_9, VAR_9 + VAR_22, VAR_21, sizeof(VAR_21));
int VAR_24 = VAR_3.deserialize(VAR_21, VAR_21 + VAR_23, VAR_18, VAR_20);
if (VAR_24 != 0)
return VAR_4;
if (VAR_14)
VAR_4.codecInfo = VAR_25;
else
VAR_4.codecInfo = VAR_26;
VAR_4.streamDescr = VAR_6;
}
catch (BitStreamException &VAR_27)
{
(void)VAR_27;
return VAR_4;
}
break;
default:
break;
}
}
if (VAR_14 && VAR_16)
VAR_4.multiSubStream = true;
return VAR_4;
}",justdan96/tsMuxer/78dd8fe480cdeb764f3ddc7c877f7528170661d8/h264StreamReader.cpp/vul/before/0.json,"CheckStreamRez H264StreamReader::checkStream(uint8_t *buffer, int len)
{
    SEIUnit lastSEI;
    SliceUnit slice;
    CheckStreamRez rez;
    uint8_t *end = buffer + len;
    std::string tmpDescr;
    bool pulldownInserted = false;
    bool offsetsInserted = false;

    for (uint8_t *nal = NALUnit::findNextNAL(buffer, end); nal < end - 4; nal = NALUnit::findNextNAL(nal, end))
    {
        if (*nal & 0x80)
            return rez;
        auto nalType = static_cast<NALUnit::NALType>(*nal & 0x1f);
        const uint8_t *nextNal = NALUnit::findNALWithStartCode(nal, end, true);
        if (!m_eof && nextNal == end)
            break;

        switch (nalType)
        {
        case NALUnit::NALType::nuSubSPS:
            m_mvcSubStream = true;
            [[fallthrough]];
        case NALUnit::NALType::nuSPS:
        {
            if (nalType == NALUnit::NALType::nuSPS)
                m_mvcPrimaryStream = true;
            auto sps = new SPSUnit();
            sps->decodeBuffer(nal, nextNal);
            if (sps->deserialize() != 0)
            {
                delete sps;
                return rez;
            }
            if (m_spsMap.find(sps->seq_parameter_set_id) != m_spsMap.end())
            {
                delete sps;
                break;
            }
            m_spsMap.insert(make_pair(sps->seq_parameter_set_id, sps));
            if (tmpDescr.empty())
                tmpDescr = sps->getStreamDescr();
            break;
        }
        case NALUnit::NALType::nuPPS:
        {
            auto pps = new PPSUnit();
            pps->decodeBuffer(nal, nextNal);
            if (pps->deserialize() != 0)
            {
                delete pps;
                return rez;
            }
            if (m_spsMap.find(pps->seq_parameter_set_id) == m_spsMap.end() ||
                m_ppsMap.find(pps->pic_parameter_set_id) != m_ppsMap.end())
            {
                delete pps;
                break;
            }
            m_ppsMap.insert(make_pair(pps->pic_parameter_set_id, pps));
            break;
        }
        case NALUnit::NALType::nuSEI:
            if (!m_spsMap.empty())
            {
                SPSUnit *sps = m_spsMap.begin()->second;
                lastSEI.decodeBuffer(nal, nextNal);
                lastSEI.deserialize(*sps, sps->nalHrdParams.isPresent || sps->vclHrdParams.isPresent);
                if (lastSEI.pic_struct == 5 || lastSEI.pic_struct == 6 || lastSEI.pic_struct == 7 ||
                    lastSEI.pic_struct == 8)
                {
                    if (!pulldownInserted)
                    {
                        pulldownInserted = true;
                        tmpDescr = sps->getStreamDescr();
                        tmpDescr += "" (pulldown)"";
                    }
                }
                if (!offsetsInserted && lastSEI.number_of_offset_sequences >= 0)
                {
                    offsetsInserted = true;
                    tmpDescr += ""  3d-pg-planes: "" + int32ToStr(lastSEI.number_of_offset_sequences);
                }
            }
            break;

        case NALUnit::NALType::nuSliceIDR:
            // m_openGOP = false;
        case NALUnit::NALType::nuSliceNonIDR:
        case NALUnit::NALType::nuSliceA:
        case NALUnit::NALType::nuSliceB:
        case NALUnit::NALType::nuSliceC:
        case NALUnit::NALType::nuSliceExt:
            if (m_ppsMap.empty() || m_spsMap.empty())
                break;
            try
            {
                uint8_t tmpBuffer[512];
                int toDecode = static_cast<int>(FFMIN(sizeof(tmpBuffer) - 8, nextNal - nal));
                int decodedLen = SliceUnit::decodeNAL(nal, nal + toDecode, tmpBuffer, sizeof(tmpBuffer));
                int nalRez = slice.deserialize(tmpBuffer, tmpBuffer + decodedLen, m_spsMap, m_ppsMap);
                if (nalRez != 0)
                    return rez;

                if (m_mvcSubStream)
                    rez.codecInfo = h264DepCodecInfo;
                else
                    rez.codecInfo = h264CodecInfo;
                rez.streamDescr = tmpDescr;
            }
            catch (BitStreamException &e)
            {
                (void)e;
                return rez;
            }
            break;
        default:
            break;
        }
    }
    if (m_mvcSubStream && m_mvcPrimaryStream)
        rez.multiSubStream = true;

    return rez;
}","CheckStreamRez H264StreamReader::checkStream(uint8_t *VAR_0, int VAR_1)
{
    SEIUnit VAR_2;
    SliceUnit VAR_3;
    CheckStreamRez VAR_4;
    uint8_t *VAR_5 = VAR_0 + VAR_1;
    std::string VAR_6;
    bool VAR_7 = false;
    bool VAR_8 = false;

    for (uint8_t *VAR_9 = NALUnit::findNextNAL(VAR_0, VAR_5); VAR_9 < VAR_5 - 4; VAR_9 = NALUnit::findNextNAL(VAR_9, VAR_5))
    {
        if (*VAR_9 & 0x80)
            return VAR_4;
        auto VAR_10 = VAR_11<NALUnit::NALType>(*VAR_9 & 0x1f);
        const uint8_t *VAR_12 = NALUnit::findNALWithStartCode(VAR_9, VAR_5, true);
        if (!VAR_13 && VAR_12 == VAR_5)
            break;

        switch (VAR_10)
        {
        case NALUnit::NALType::nuSubSPS:
            VAR_14 = true;
            [[VAR_15]];
        case NALUnit::NALType::nuSPS:
        {
            if (VAR_10 == NALUnit::NALType::nuSPS)
                VAR_16 = true;
            auto VAR_17 = new SPSUnit();
            VAR_17->decodeBuffer(VAR_9, VAR_12);
            if (VAR_17->deserialize() != 0)
            {
                delete VAR_17;
                return VAR_4;
            }
            if (VAR_18.find(VAR_17->seq_parameter_set_id) != VAR_18.end())
            {
                delete VAR_17;
                break;
            }
            VAR_18.insert(make_pair(VAR_17->seq_parameter_set_id, VAR_17));
            if (VAR_6.empty())
                VAR_6 = VAR_17->getStreamDescr();
            break;
        }
        case NALUnit::NALType::nuPPS:
        {
            auto VAR_19 = new PPSUnit();
            VAR_19->decodeBuffer(VAR_9, VAR_12);
            if (VAR_19->deserialize() != 0)
            {
                delete VAR_19;
                return VAR_4;
            }
            if (VAR_18.find(VAR_19->seq_parameter_set_id) == VAR_18.end() ||
                VAR_20.find(VAR_19->pic_parameter_set_id) != VAR_20.end())
            {
                delete VAR_19;
                break;
            }
            VAR_20.insert(make_pair(VAR_19->pic_parameter_set_id, VAR_19));
            break;
        }
        case NALUnit::NALType::nuSEI:
            if (!VAR_18.empty())
            {
                SPSUnit *VAR_17 = VAR_18.begin()->second;
                VAR_2.decodeBuffer(VAR_9, VAR_12);
                VAR_2.deserialize(*VAR_17, VAR_17->nalHrdParams.isPresent || VAR_17->vclHrdParams.isPresent);
                if (VAR_2.pic_struct == 5 || VAR_2.pic_struct == 6 || VAR_2.pic_struct == 7 ||
                    VAR_2.pic_struct == 8)
                {
                    if (!VAR_7)
                    {
                        VAR_7 = true;
                        VAR_6 = VAR_17->getStreamDescr();
                        VAR_6 += "" (pulldown)"";
                    }
                }
                if (!VAR_8 && VAR_2.number_of_offset_sequences >= 0)
                {
                    VAR_8 = true;
                    VAR_6 += ""  3d-pg-planes: "" + int32ToStr(VAR_2.number_of_offset_sequences);
                }
            }
            break;

        case NALUnit::NALType::nuSliceIDR:
            /* COMMENT_0 */
        case NALUnit::NALType::nuSliceNonIDR:
        case NALUnit::NALType::nuSliceA:
        case NALUnit::NALType::nuSliceB:
        case NALUnit::NALType::nuSliceC:
        case NALUnit::NALType::nuSliceExt:
            if (VAR_20.empty() || VAR_18.empty())
                break;
            try
            {
                uint8_t VAR_21[512];
                int VAR_22 = VAR_11<int>(FFMIN(sizeof(VAR_21) - 8, VAR_12 - VAR_9));
                int VAR_23 = SliceUnit::decodeNAL(VAR_9, VAR_9 + VAR_22, VAR_21, sizeof(VAR_21));
                int VAR_24 = VAR_3.deserialize(VAR_21, VAR_21 + VAR_23, VAR_18, VAR_20);
                if (VAR_24 != 0)
                    return VAR_4;

                if (VAR_14)
                    VAR_4.codecInfo = VAR_25;
                else
                    VAR_4.codecInfo = VAR_26;
                VAR_4.streamDescr = VAR_6;
            }
            catch (BitStreamException &VAR_27)
            {
                (void)VAR_27;
                return VAR_4;
            }
            break;
        default:
            break;
        }
    }
    if (VAR_14 && VAR_16)
        VAR_4.multiSubStream = true;

    return VAR_4;
}",justdan96/tsMuxer/78dd8fe480cdeb764f3ddc7c877f7528170661d8/h264StreamReader.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -33,6 +33,11 @@
                 delete sps;
                 return rez;
             }
+            if (m_spsMap.find(sps->seq_parameter_set_id) != m_spsMap.end())
+            {
+                delete sps;
+                break;
+            }
             m_spsMap.insert(make_pair(sps->seq_parameter_set_id, sps));
             if (tmpDescr.empty())
                 tmpDescr = sps->getStreamDescr();
@@ -47,7 +52,8 @@
                 delete pps;
                 return rez;
             }
-            if (m_spsMap.find(pps->seq_parameter_set_id) == m_spsMap.end())
+            if (m_spsMap.find(pps->seq_parameter_set_id) == m_spsMap.end() ||
+                m_ppsMap.find(pps->pic_parameter_set_id) != m_ppsMap.end())
             {
                 delete pps;
                 break;","{'deleted_lines': ['            if (m_spsMap.find(pps->seq_parameter_set_id) == m_spsMap.end())'], 'added_lines': ['            if (m_spsMap.find(sps->seq_parameter_set_id) != m_spsMap.end())', '            {', '                delete sps;', '                break;', '            }', '            if (m_spsMap.find(pps->seq_parameter_set_id) == m_spsMap.end() ||', '                m_ppsMap.find(pps->pic_parameter_set_id) != m_ppsMap.end())']}",True,A memory leak in tsMuxer version git-2539d07 allows attackers to cause a Denial of Service (DoS) via a crafted MP4 file.,5.5,MEDIUM,1,test,2023-10-10T13:45:21Z,4
CVE-2023-5535,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,vim,"patch 9.0.2010: [security] use-after-free from buf_contents_changed()

Problem:  [security] use-after-free from buf_contents_changed()
Solution: block autocommands

Signed-off-by: Christian Brabandt <cb@256bit.org>",41e6f7d6ba67b61d911f9b1d76325cd79224753d,https://github.com/vim/vim/commit/41e6f7d6ba67b61d911f9b1d76325cd79224753d,src/buffer.c,buf_contents_changed,"int
buf_contents_changed(buf_T *buf)
{
buf_T*newbuf;
intdiffer = TRUE;
linenr_Tlnum;
aco_save_Taco;
exarg_Tea;
newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);
if (newbuf == NULL)
return TRUE;
if (prep_exarg(&ea, buf) == FAIL)
{
wipe_buffer(newbuf, FALSE);
return TRUE;
}
aucmd_prepbuf(&aco, newbuf);
if (curbuf != newbuf)
{
wipe_buffer(newbuf, FALSE);
return TRUE;
}
if (ml_open(curbuf) == OK
&& readfile(buf->b_ffname, buf->b_fname,
(linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM,
&ea, READ_NEW | READ_DUMMY) == OK)
{
if (buf->b_ml.ml_line_count == curbuf->b_ml.ml_line_count)
{
differ = FALSE;
for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)
if (STRCMP(ml_get_buf(buf, lnum, FALSE), ml_get(lnum)) != 0)
{
differ = TRUE;
break;
}
}
}
vim_free(ea.cmd);
aucmd_restbuf(&aco);
if (curbuf != newbuf)wipe_buffer(newbuf, FALSE);
return differ;
}","int
buf_contents_changed(buf_T *VAR_0)
{
buf_T*VAR_1;
intVAR_2 = TRUE;
linenr_TVAR_3;
aco_save_TVAR_4;
exarg_TVAR_5;
VAR_1 = buflist_new(NULL, NULL, (linenr_T)1, VAR_6);
if (VAR_1 == NULL)
return TRUE;
if (prep_exarg(&VAR_5, VAR_0) == VAR_7)
{
wipe_buffer(VAR_1, FALSE);
return TRUE;
}
aucmd_prepbuf(&VAR_4, VAR_1);
if (VAR_8 != VAR_1)
{
wipe_buffer(VAR_1, FALSE);
return TRUE;
}
if (ml_open(VAR_8) == VAR_9
&& readfile(VAR_0->b_ffname, VAR_0->b_fname,
(linenr_T)0, (linenr_T)0, (linenr_T)VAR_10,
&VAR_5, VAR_11 | VAR_12) == VAR_9)
{
if (VAR_0->b_ml.ml_line_count == VAR_8->b_ml.ml_line_count)
{
VAR_2 = FALSE;
for (VAR_3 = 1; VAR_3 <= VAR_8->b_ml.ml_line_count; ++VAR_3)
if (STRCMP(ml_get_buf(VAR_0, VAR_3, FALSE), ml_get(VAR_3)) != 0)
{
VAR_2 = TRUE;
break;
}
}
}
vim_free(VAR_5.cmd);
aucmd_restbuf(&VAR_4);
if (VAR_8 != VAR_1)
wipe_buffer(VAR_1, FALSE);
return VAR_2;
}",vim/41e6f7d6ba67b61d911f9b1d76325cd79224753d/buffer.c/vul/before/0.json,"int
buf_contents_changed(buf_T *buf)
{
    buf_T	*newbuf;
    int		differ = TRUE;
    linenr_T	lnum;
    aco_save_T	aco;
    exarg_T	ea;

    // Allocate a buffer without putting it in the buffer list.
    newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);
    if (newbuf == NULL)
	return TRUE;

    // Force the 'fileencoding' and 'fileformat' to be equal.
    if (prep_exarg(&ea, buf) == FAIL)
    {
	wipe_buffer(newbuf, FALSE);
	return TRUE;
    }

    // Set curwin/curbuf to buf and save a few things.
    aucmd_prepbuf(&aco, newbuf);
    if (curbuf != newbuf)
    {
	// Failed to find a window for ""newbuf"".
	wipe_buffer(newbuf, FALSE);
	return TRUE;
    }

    // We don't want to trigger autocommands now, they may have nasty
    // side-effects like wiping buffers
    block_autocmds();
    if (ml_open(curbuf) == OK
	    && readfile(buf->b_ffname, buf->b_fname,
				  (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM,
					    &ea, READ_NEW | READ_DUMMY) == OK)
    {
	// compare the two files line by line
	if (buf->b_ml.ml_line_count == curbuf->b_ml.ml_line_count)
	{
	    differ = FALSE;
	    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)
		if (STRCMP(ml_get_buf(buf, lnum, FALSE), ml_get(lnum)) != 0)
		{
		    differ = TRUE;
		    break;
		}
	}
    }
    vim_free(ea.cmd);

    // restore curwin/curbuf and a few other things
    aucmd_restbuf(&aco);

    if (curbuf != newbuf)	// safety check
	wipe_buffer(newbuf, FALSE);

    unblock_autocmds();

    return differ;
}","int
buf_contents_changed(buf_T *VAR_0)
{
    buf_T	*VAR_1;
    int		VAR_2 = TRUE;
    linenr_T	VAR_3;
    aco_save_T	VAR_4;
    exarg_T	VAR_5;

    /* COMMENT_0 */
    VAR_1 = buflist_new(NULL, NULL, (linenr_T)1, VAR_6);
    if (VAR_1 == NULL)
	return TRUE;

    /* COMMENT_1 */
    if (prep_exarg(&VAR_5, VAR_0) == VAR_7)
    {
	wipe_buffer(VAR_1, FALSE);
	return TRUE;
    }

    /* COMMENT_2 */
    aucmd_prepbuf(&VAR_4, VAR_1);
    if (VAR_8 != VAR_1)
    {
	/* COMMENT_3 */
	wipe_buffer(VAR_1, FALSE);
	return TRUE;
    }

    /* COMMENT_4 */
    /* COMMENT_5 */
    block_autocmds();
    if (ml_open(VAR_8) == VAR_9
	    && readfile(VAR_0->b_ffname, VAR_0->b_fname,
				  (linenr_T)0, (linenr_T)0, (linenr_T)VAR_10,
					    &VAR_5, VAR_11 | VAR_12) == VAR_9)
    {
	/* COMMENT_6 */
	if (VAR_0->b_ml.ml_line_count == VAR_8->b_ml.ml_line_count)
	{
	    VAR_2 = FALSE;
	    for (VAR_3 = 1; VAR_3 <= VAR_8->b_ml.ml_line_count; ++VAR_3)
		if (STRCMP(ml_get_buf(VAR_0, VAR_3, FALSE), ml_get(VAR_3)) != 0)
		{
		    VAR_2 = TRUE;
		    break;
		}
	}
    }
    vim_free(VAR_5.cmd);

    /* COMMENT_7 */
    aucmd_restbuf(&VAR_4);

    if (VAR_8 != VAR_1)	/* COMMENT_8 */
	wipe_buffer(VAR_1, FALSE);

    unblock_autocmds();

    return VAR_2;
}",vim/41e6f7d6ba67b61d911f9b1d76325cd79224753d/buffer.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -28,6 +28,9 @@
 	return TRUE;
     }
 
+    // We don't want to trigger autocommands now, they may have nasty
+    // side-effects like wiping buffers
+    block_autocmds();
     if (ml_open(curbuf) == OK
 	    && readfile(buf->b_ffname, buf->b_fname,
 				  (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM,
@@ -53,5 +56,7 @@
     if (curbuf != newbuf)	// safety check
 	wipe_buffer(newbuf, FALSE);
 
+    unblock_autocmds();
+
     return differ;
 }","{'deleted_lines': [], 'added_lines': [""    // We don't want to trigger autocommands now, they may have nasty"", '    // side-effects like wiping buffers', '    block_autocmds();', '    unblock_autocmds();', '']}",True,Use After Free in GitHub repository vim/vim prior to v9.0.2010.,7.8,HIGH,2,test,2023-10-11T19:08:13Z,4
CVE-2023-45511,['CWE-401'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,justdan96/tsMuxer,"Regression on Mov File Seek

Until unforeseen issues are solved (with some mp4, fail to complete muxing see issue #780).",bb607142cb1b621c2287dfee9da24ecb144c24b1,https://github.com/justdan96/tsMuxer/commit/bb607142cb1b621c2287dfee9da24ecb144c24b1,tsMuxer/ioContextDemuxer.cpp,IOContextDemuxer::skip_bytes,"void IOContextDemuxer::skip_bytes(const int64_t size)
{
if (size == 0)
return;
uint32_t readedBytes = 0;
int readRez = 0;
int64_t skipLeft = size;
if (m_curPos < m_bufEnd)
{
const int64_t copyLen = min(m_bufEnd - m_curPos, skipLeft);
skipLeft -= copyLen;
m_curPos += copyLen;
m_processedBytes += copyLen;
}
while (skipLeft > 4LL * m_fileBlockSize)
{
m_bufferedReader->seek(m_readerID, m_fileBlockSize);
m_processedBytes += m_fileBlockSize;
skipLeft -= m_fileBlockSize;
}
while (skipLeft > 0)
{
uint8_t* data = m_bufferedReader->readBlock(m_readerID, readedBytes, readRez);
if (readedBytes > 0 && readRez == 0)
m_bufferedReader->notify(m_readerID, readedBytes);
m_curPos = data + 188;
m_bufEnd = m_curPos + readedBytes;
if (readedBytes == 0)
break;
const int64_t copyLen = min(readedBytes, skipLeft);
m_curPos += copyLen;
m_processedBytes += copyLen;
skipLeft -= copyLen;
}
}","void IOContextDemuxer::skip_bytes(const int64_t VAR_0)
{
if (VAR_0 == 0)
return;
uint32_t VAR_1 = 0;
int VAR_2 = 0;
int64_t VAR_3 = VAR_0;
if (VAR_4 < VAR_5)
{
const int64_t VAR_6 = min(VAR_5 - VAR_4, VAR_3);
VAR_3 -= VAR_6;
VAR_4 += VAR_6;
VAR_7 += VAR_6;
}
while (VAR_3 > 4LL * VAR_8)
{
VAR_9->seek(VAR_10, VAR_8);
VAR_7 += VAR_8;
VAR_3 -= VAR_8;
}
while (VAR_3 > 0)
{
uint8_t* VAR_11 = VAR_9->readBlock(VAR_10, VAR_1, VAR_2);
if (VAR_1 > 0 && VAR_2 == 0)
VAR_9->notify(VAR_10, VAR_1);
VAR_4 = VAR_11 + 188;
VAR_5 = VAR_4 + VAR_1;
if (VAR_1 == 0)
break;
const int64_t VAR_6 = min(VAR_1, VAR_3);
VAR_4 += VAR_6;
VAR_7 += VAR_6;
VAR_3 -= VAR_6;
}
}",justdan96/tsMuxer/bb607142cb1b621c2287dfee9da24ecb144c24b1/ioContextDemuxer.cpp/vul/before/0.json,"void IOContextDemuxer::skip_bytes(const int64_t size)
{
    if (size == 0)
        return;
    uint32_t readedBytes = 0;
    int readRez = 0;
    int64_t skipLeft = size;

    if (m_curPos < m_bufEnd)
    {
        const int64_t copyLen = min(m_bufEnd - m_curPos, skipLeft);
        skipLeft -= copyLen;
        m_curPos += copyLen;
        m_processedBytes += copyLen;
    }
    /*
    while (skipLeft > 4LL * m_fileBlockSize)
    {
        m_bufferedReader->seek(m_readerID, m_fileBlockSize);
        m_processedBytes += m_fileBlockSize;
        skipLeft -= m_fileBlockSize;
    }
    */
    while (skipLeft > 0)
    {
        uint8_t* data = m_bufferedReader->readBlock(m_readerID, readedBytes, readRez);
        if (readedBytes > 0 && readRez == 0)
            m_bufferedReader->notify(m_readerID, readedBytes);
        m_curPos = data + 188;
        m_bufEnd = m_curPos + readedBytes;
        if (readedBytes == 0)
            break;
        const int64_t copyLen = min(readedBytes, skipLeft);
        m_curPos += copyLen;
        m_processedBytes += copyLen;
        skipLeft -= copyLen;
    }
}","void IOContextDemuxer::skip_bytes(const int64_t VAR_0)
{
    if (VAR_0 == 0)
        return;
    uint32_t VAR_1 = 0;
    int VAR_2 = 0;
    int64_t VAR_3 = VAR_0;

    if (VAR_4 < VAR_5)
    {
        const int64_t VAR_6 = min(VAR_5 - VAR_4, VAR_3);
        VAR_3 -= VAR_6;
        VAR_4 += VAR_6;
        VAR_7 += VAR_6;
    }
    /* COMMENT_0 */
                                            
     
                                                            
                                            
                                    
     
      
    while (VAR_3 > 0)
    {
        uint8_t* VAR_8 = VAR_9->readBlock(VAR_10, VAR_1, VAR_2);
        if (VAR_1 > 0 && VAR_2 == 0)
            VAR_9->notify(VAR_10, VAR_1);
        VAR_4 = VAR_8 + 188;
        VAR_5 = VAR_4 + VAR_1;
        if (VAR_1 == 0)
            break;
        const int64_t VAR_6 = min(VAR_1, VAR_3);
        VAR_4 += VAR_6;
        VAR_7 += VAR_6;
        VAR_3 -= VAR_6;
    }
}",justdan96/tsMuxer/bb607142cb1b621c2287dfee9da24ecb144c24b1/ioContextDemuxer.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -13,14 +13,14 @@
         m_curPos += copyLen;
         m_processedBytes += copyLen;
     }
-    
+    /*
     while (skipLeft > 4LL * m_fileBlockSize)
     {
         m_bufferedReader->seek(m_readerID, m_fileBlockSize);
         m_processedBytes += m_fileBlockSize;
         skipLeft -= m_fileBlockSize;
     }
-    
+    */
     while (skipLeft > 0)
     {
         uint8_t* data = m_bufferedReader->readBlock(m_readerID, readedBytes, readRez);","{'deleted_lines': ['    ', '    '], 'added_lines': ['    /*', '    */']}",True,A memory leak in tsMuxer version git-2539d07 allows attackers to cause a Denial of Service (DoS) via a crafted MP4 file.,5.5,MEDIUM,1,test,2023-10-18T07:02:50Z,4
CVE-2023-46931,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,gpac,ffdmx: fix loop index mismatch on side data parsing (fixes #2664),671976fccc971b3dff8d3dcf6ebd600472ca64bf,https://github.com/gpac/gpac/commit/671976fccc971b3dff8d3dcf6ebd600472ca64bf,src/filters/ff_dmx.c,ffdmx_init_common,"GF_Err ffdmx_init_common(GF_Filter *filter, GF_FFDemuxCtx *ctx, u32 grab_type)
{
u32 i;
u32 nb_a, nb_v, nb_t, clock_id;
char szName[50];
if (gf_filter_is_temporary(filter)) {
gf_filter_meta_set_instances(filter, ctx->demuxer->av_class->class_name);
return GF_OK;
}
#if (LIBAVCODEC_VERSION_MAJOR >= 59)
ctx->pkt = av_packet_alloc();
#endif
ctx->pids_ctx = gf_malloc(sizeof(PidCtx)*ctx->demuxer->nb_streams);
memset(ctx->pids_ctx, 0, sizeof(PidCtx)*ctx->demuxer->nb_streams);
ctx->nb_streams = ctx->demuxer->nb_streams;
clock_id = 0;
for (i = 0; i < ctx->demuxer->nb_streams; i++) {
AVStream *stream = ctx->demuxer->streams[i];
#if (LIBAVFORMAT_VERSION_MAJOR < 59)
AVCodecContext *codec = stream->codec;
u32 codec_type = codec->codec_type;
#else
u32 codec_type = stream->codecpar->codec_type;
#endif
switch(codec_type) {
case AVMEDIA_TYPE_AUDIO:
if (!clock_id) clock_id = stream->id ? stream->id : i+1;
break;
case AVMEDIA_TYPE_VIDEO:
clock_id = stream->id ? stream->id : i+1;
break;
}
}
nb_a = nb_v = nb_t = 0;
for (i = 0; i < ctx->demuxer->nb_streams; i++) {
GF_FilterPid *pid=NULL;
PidCtx *pctx;
u32 j;
u32 force_reframer = 0;
Bool expose_ffdec=GF_FALSE;
u32 gpac_codec_id;
AVStream *stream = ctx->demuxer->streams[i];
#if (LIBAVFORMAT_VERSION_MAJOR < 59)
AVCodecContext *codec = stream->codec;
u32 codec_type = codec->codec_type;
u32 codec_id = codec->codec_id;
const uint8_t *exdata = codec->extradata;
u32 exdata_size = codec->extradata_size;
u32 codec_sample_rate = codec->sample_rate;
u32 codec_frame_size = codec->frame_size;
u32 codec_channels = codec->channels;
u32 codec_width = codec->width;
u32 codec_height = codec->height;
u32 codec_field_order = codec->field_order;
u32 codec_tag = codec->codec_tag;
u32 codec_pixfmt = codec->pix_fmt;
u32 codec_blockalign = 0;
AVRational codec_framerate = {0, 0};
#if LIBAVCODEC_VERSION_MAJOR >= 58
codec_framerate = codec->framerate;
#endif
s32 codec_sample_fmt = codec->sample_fmt;
u32 codec_bitrate = (u32) codec->bit_rate;
#else
u32 codec_type = stream->codecpar->codec_type;
u32 codec_id = stream->codecpar->codec_id;
const uint8_t *exdata = stream->codecpar->extradata;
u32 exdata_size = stream->codecpar->extradata_size;
u32 codec_sample_rate = stream->codecpar->sample_rate;
u32 codec_frame_size = stream->codecpar->frame_size;
u32 codec_channels = stream->codecpar->channels;
u32 codec_width = stream->codecpar->width;
u32 codec_height = stream->codecpar->height;
u32 codec_field_order = stream->codecpar->field_order;
u32 codec_tag = stream->codecpar->codec_tag;
u32 codec_pixfmt = (codec_type==AVMEDIA_TYPE_VIDEO) ? stream->codecpar->format : 0;
s32 codec_sample_fmt = (codec_type==AVMEDIA_TYPE_AUDIO) ? stream->codecpar->format : 0;
u32 codec_bitrate = (u32) stream->codecpar->bit_rate;
u32 codec_blockalign = (u32) stream->codecpar->block_align;
AVRational codec_framerate = stream->r_frame_rate;
if (!stream->r_frame_rate.num || !stream->r_frame_rate.den)
codec_framerate = stream->avg_frame_rate;
#endif
if (ctx->fps_forced.num) {
codec_framerate.num = ctx->fps_forced.num;
codec_framerate.den = ctx->fps_forced.den;
}
switch(codec_type) {
case AVMEDIA_TYPE_AUDIO:
pid = gf_filter_pid_new(filter);
if (!pid) return GF_OUT_OF_MEM;
gf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_AUDIO) );
nb_a++;
sprintf(szName, ""audio%d"", nb_a);
if (ctx->audio_idx<0)
ctx->audio_idx = i;
break;
case AVMEDIA_TYPE_VIDEO:
pid = gf_filter_pid_new(filter);
if (!pid) return GF_OUT_OF_MEM;
gf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_VISUAL) );
nb_v++;
sprintf(szName, ""video%d"", nb_v);
if (ctx->video_idx<0)
ctx->video_idx = i;
break;
case AVMEDIA_TYPE_SUBTITLE:
pid = gf_filter_pid_new(filter);
if (!pid) return GF_OUT_OF_MEM;
gf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );
nb_t++;
sprintf(szName, ""text%d"", nb_t);
break;
default:
sprintf(szName, ""ffdmx%d"", i+1);
break;
}
if (!pid) continue;
pctx = &ctx->pids_ctx[i];
pctx->pid = pid;
pctx->ts_offset = 0;
gf_filter_pid_set_udta(pid, stream);
gf_filter_pid_set_property(pid, GF_PROP_PID_ID, &PROP_UINT( (stream->id ? stream->id : i+1)) );
gf_filter_pid_set_name(pid, szName);
if (ctx->raw_data && ctx->sclock) {
gf_filter_pid_set_property(pid, GF_PROP_PID_TIMESCALE, &PROP_UINT(1000000) );
} else {
gf_filter_pid_set_property(pid, GF_PROP_PID_TIMESCALE, &PROP_UINT(stream->time_base.den) );
}
if (clock_id)
gf_filter_pid_set_property(pid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(clock_id) );
if (!ctx->raw_data) {
if (stream->duration>=0)
gf_filter_pid_set_property(pid, GF_PROP_PID_DURATION, &PROP_FRAC64_INT(stream->duration, stream->time_base.den) );
else if (ctx->demuxer->duration>=0)
gf_filter_pid_set_property(pid, GF_PROP_PID_DURATION, &PROP_FRAC64_INT(ctx->demuxer->duration, AV_TIME_BASE) );
}
if (stream->sample_aspect_ratio.num && stream->sample_aspect_ratio.den)
gf_filter_pid_set_property(pid, GF_PROP_PID_SAR, &PROP_FRAC_INT( stream->sample_aspect_ratio.num, stream->sample_aspect_ratio.den ) );
ffmpeg_tags_to_gpac(stream->metadata, pid);
gpac_codec_id = ffmpeg_codecid_to_gpac(codec_id);
if (!gpac_codec_id) {
gf_filter_pid_set_property(pid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_FFMPEG) );
expose_ffdec = GF_TRUE;
} else {
gf_filter_pid_set_property(pid, GF_PROP_PID_CODECID, &PROP_UINT(gpac_codec_id) );
}
if (grab_type)
gf_filter_pid_set_property(pid, GF_PROP_PID_RAWGRAB, &PROP_UINT(grab_type) );
else if (ctx->demuxer->iformat) {
if ((ctx->demuxer->iformat->flags & AVFMT_SEEK_TO_PTS) || ctx->demuxer->iformat->read_seek)
gf_filter_pid_set_property(pid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) );
}
u32 lt = gf_log_get_tool_level(GF_LOG_CODING);
gf_log_set_tool_level(GF_LOG_CODING, GF_LOG_QUIET);
force_reframer = ffdmx_valid_should_reframe(gpac_codec_id, (u8 *) exdata, exdata_size);
gf_log_set_tool_level(GF_LOG_CODING, lt);
if (expose_ffdec) {
const char *cname = avcodec_get_name(codec_id);
#if (LIBAVFORMAT_VERSION_MAJOR < 59)
gf_filter_pid_set_property(pid, GF_PROP_PID_META_DEMUX_CODEC_ID, &PROP_POINTER( (void*)codec ) );
#else
gf_filter_pid_set_property(pid, GF_PROP_PID_META_DEMUX_CODEC_ID, &PROP_UINT( codec_id ) );
if (exdata) {
gf_filter_pid_set_property(pid, GF_PROP_PID_DECODER_CONFIG, &PROP_CONST_DATA( (char *)exdata, exdata_size) );
}
#endif
if (cname)
gf_filter_pid_set_property(pid, GF_PROP_PID_META_DEMUX_CODEC_NAME, &PROP_STRING(cname ) );
} else if (exdata_size) {
if (ctx->demuxer->iformat) {
if (!strcmp(ctx->demuxer->iformat->name, ""h264"")
|| !strcmp(ctx->demuxer->iformat->name, ""hevc"")
|| !strcmp(ctx->demuxer->iformat->name, ""vvc"")
) {
force_reframer = 1;
}
}
if (force_reframer!=1) {
ffdmx_set_decoder_config(pctx, exdata, exdata_size, gpac_codec_id);
}
}
if (force_reframer) {
gf_filter_pid_set_property(pid, GF_PROP_PID_UNFRAMED, &PROP_BOOL(GF_TRUE) );
}
else if (!gf_sys_is_test_mode() ){
switch (gpac_codec_id) {
case GF_CODECID_AVC:
case GF_CODECID_HEVC:
case GF_CODECID_LHVC:
case GF_CODECID_VVC:
case GF_CODECID_AV1:
if (ctx->reparse
#ifdef FFMPEG_NO_DOVI
|| 1
#endif
) {
gf_filter_pid_set_property(pid, GF_PROP_PID_FORCE_UNFRAME, &PROP_BOOL(GF_TRUE) );
gf_filter_pid_set_property(pid, GF_PROP_PID_UNFRAMED, &PROP_BOOL(GF_TRUE) );
}
break;
}
}
if (codec_sample_rate)
gf_filter_pid_set_property(pid, GF_PROP_PID_SAMPLE_RATE, &PROP_UINT( codec_sample_rate ) );
if (codec_frame_size)
gf_filter_pid_set_property(pid, GF_PROP_PID_SAMPLES_PER_FRAME, &PROP_UINT( codec_frame_size ) );
if (codec_channels)
gf_filter_pid_set_property(pid, GF_PROP_PID_NUM_CHANNELS, &PROP_UINT( codec_channels ) );
if (codec_width)
gf_filter_pid_set_property(pid, GF_PROP_PID_WIDTH, &PROP_UINT( codec_width ) );
if (codec_height)
gf_filter_pid_set_property(pid, GF_PROP_PID_HEIGHT, &PROP_UINT( codec_height ) );
#if (LIBAVFORMAT_VERSION_MAJOR >= 59)
ffmpeg_codec_par_to_gpac(stream->codecpar, pid, 0);
if (gpac_codec_id!=GF_CODECID_RAW) {
gf_filter_pid_set_property(pid, GF_PROP_PID_PIXFMT, NULL);
gf_filter_pid_set_property(pid, GF_PROP_PID_AUDIO_FORMAT, NULL);
}
#endif
if (codec_width && codec_height) {
if (codec_framerate.num && codec_framerate.den) {
gf_media_get_reduced_frame_rate(&codec_framerate.num, &codec_framerate.den);
gf_filter_pid_set_property(pid, GF_PROP_PID_FPS, &PROP_FRAC_INT( codec_framerate.num, codec_framerate.den ) );
} else {
GF_LOG(GF_LOG_WARNING, ctx->log_class, (""[%s] Unknown frame rate, will use 25 fps - use `:#FPS=VAL` to force frame rate signaling\n"", ctx->fname));
gf_filter_pid_set_property(pid, GF_PROP_PID_FPS, &PROP_FRAC_INT( 25, 1 ) );
}
}
if (codec_field_order>AV_FIELD_PROGRESSIVE)
gf_filter_pid_set_property(pid, GF_PROP_PID_INTERLACED, &PROP_BOOL(GF_TRUE) );
if ((codec_type==AVMEDIA_TYPE_VIDEO)
&& (codec_pixfmt || ((codec_id==AV_CODEC_ID_RAWVIDEO) && codec_tag))
) {
Bool is_full_range = GF_FALSE;
u32 pfmt = 0;
if (codec_pixfmt) {
pfmt = ffmpeg_pixfmt_to_gpac(codec_pixfmt, GF_FALSE);
is_full_range = ffmpeg_pixfmt_is_fullrange(codec_pixfmt);
} else if (codec_tag) {
pfmt = ffmpeg_pixfmt_from_codec_tag(codec_tag, &is_full_range);
}
if (!pfmt) {
GF_LOG(GF_LOG_WARNING, ctx->log_class, (""[%s] Unsupported pixel format %d\n"", ctx->fname, codec_pixfmt));
} else {
gf_filter_pid_set_property(pid, GF_PROP_PID_PIXFMT, &PROP_UINT( pfmt) );
if (is_full_range)
gf_filter_pid_set_property(pid, GF_PROP_PID_COLR_RANGE, &PROP_BOOL( GF_TRUE ) );
}
}
if (codec_type==AVMEDIA_TYPE_SUBTITLE) {
gf_filter_pid_set_property(pid, GF_PROP_PID_SUBTYPE, &PROP_UINT(GF_4CC('s','b','t','l')));
}
ctx->pids_ctx[i].mkv_webvtt = GF_FALSE;
if ((gpac_codec_id==GF_CODECID_WEBVTT) && strstr(ctx->demuxer->iformat->name, ""matroska""))
ctx->pids_ctx[i].mkv_webvtt = GF_TRUE;
if (codec_sample_fmt>0) {
u32 sfmt = 0;
switch (codec_sample_fmt) {
case AV_SAMPLE_FMT_U8: sfmt = GF_AUDIO_FMT_U8; break;
case AV_SAMPLE_FMT_S16: sfmt = GF_AUDIO_FMT_S16; break;
case AV_SAMPLE_FMT_S32: sfmt = GF_AUDIO_FMT_S32; break;
case AV_SAMPLE_FMT_FLT: sfmt = GF_AUDIO_FMT_FLT; break;
case AV_SAMPLE_FMT_DBL: sfmt = GF_AUDIO_FMT_DBL; break;
case AV_SAMPLE_FMT_U8P: sfmt = GF_AUDIO_FMT_U8P; break;
case AV_SAMPLE_FMT_S16P: sfmt = GF_AUDIO_FMT_S16P; break;
case AV_SAMPLE_FMT_S32P: sfmt = GF_AUDIO_FMT_S32P; break;
case AV_SAMPLE_FMT_FLTP: sfmt = GF_AUDIO_FMT_FLTP; break;
case AV_SAMPLE_FMT_DBLP: sfmt = GF_AUDIO_FMT_DBLP; break;
default:
GF_LOG(GF_LOG_WARNING, ctx->log_class, (""[%s] Unsupported sample format %d\n"", ctx->fname, codec_sample_fmt));
}
if (gpac_codec_id==GF_CODECID_RAW) {
u32 res = ffmpeg_codecid_to_gpac_audio_fmt(codec_id);
if (res) sfmt = res;
}
gf_filter_pid_set_property(pid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT( sfmt) );
}
if (codec_bitrate)
gf_filter_pid_set_property(pid, GF_PROP_PID_BITRATE, &PROP_UINT( (u32) codec_bitrate ) );
gf_filter_pid_set_property(pid, GF_PROP_PID_URL, &PROP_STRING( AVFMT_URL(ctx->demuxer) ));
if (gf_file_exists(ctx->src)) {
gf_filter_pid_set_property(pid, GF_PROP_PID_FILE_CACHED, &PROP_BOOL(GF_TRUE));
}
if (codec_blockalign)
gf_filter_pid_set_property(pid, GF_PROP_PID_META_DEMUX_OPAQUE, &PROP_UINT(codec_blockalign));
if ((stream->disposition & AV_DISPOSITION_DEFAULT) && !gf_sys_is_test_mode()) {
gf_filter_pid_set_property(pid, GF_PROP_PID_IS_DEFAULT, &PROP_BOOL(GF_TRUE));
}
gf_filter_pid_set_property(pid, GF_PROP_PID_MUX_INDEX, &PROP_UINT(i+1));
for (j=0; j<(u32) stream->nb_side_data; j++) {
ffdmx_parse_side_data(&stream->side_data[i], pid);
}
if (ctx->demuxer->nb_chapters) {
GF_PropertyValue p;
GF_PropUIntList times;
GF_PropStringList names;
u32 nb_c = ctx->demuxer->nb_chapters;
times.vals = gf_malloc(sizeof(u32)*nb_c);
names.vals = gf_malloc(sizeof(char *)*nb_c);
memset(names.vals, 0, sizeof(char *)*nb_c);
times.nb_items = names.nb_items = nb_c;
for (j=0; j<ctx->demuxer->nb_chapters; j++) {
AVChapter *c = ctx->demuxer->chapters[j];
u64 start = gf_timestamp_rescale(c->start * c->time_base.num, c->time_base.den, 1000);
times.vals[j] = (u32) start;
AVDictionaryEntry *ent = NULL;
while (c->metadata) {
ent = av_dict_get(c->metadata, """", ent, AV_DICT_IGNORE_SUFFIX);
if (!ent) break;
if (!strcmp(ent->key, ""title"")) {
names.vals[j] = gf_strdup(ent->value);
}
}
if (!names.vals[j]) names.vals[j] = gf_strdup(""Unknwon"");
}
p.type = GF_PROP_UINT_LIST;
p.value.uint_list = times;
gf_filter_pid_set_property(pid, GF_PROP_PID_CHAP_TIMES, &p);
gf_free(times.vals);
p.type = GF_PROP_STRING_LIST;
p.value.string_list = names;
gf_filter_pid_set_property(pid, GF_PROP_PID_CHAP_NAMES, &p);
}
}
if (!nb_a && !nb_v && !nb_t)
return GF_NOT_SUPPORTED;
return GF_OK;
}","GF_Err ffdmx_init_common(GF_Filter *VAR_0, GF_FFDemuxCtx *VAR_1, u32 VAR_2)
{
u32 VAR_3;
u32 VAR_4, VAR_5, VAR_6, VAR_7;
char VAR_8[50];
if (gf_filter_is_temporary(VAR_0)) {
gf_filter_meta_set_instances(VAR_0, VAR_1->demuxer->av_class->class_name);
return VAR_9;
}
#if (VAR_10 >= 59)
VAR_1->pkt = av_packet_alloc();
#endif
VAR_1->pids_ctx = gf_malloc(sizeof(VAR_11)*VAR_1->demuxer->nb_streams);
memset(VAR_1->pids_ctx, 0, sizeof(VAR_11)*VAR_1->demuxer->nb_streams);
VAR_1->nb_streams = VAR_1->demuxer->nb_streams;
VAR_7 = 0;
for (VAR_3 = 0; VAR_3 < VAR_1->demuxer->nb_streams; VAR_3++) {
AVStream *VAR_12 = VAR_1->demuxer->streams[VAR_3];
#if (VAR_13 < 59)
AVCodecContext *VAR_14 = VAR_12->codec;
u32 VAR_15 = VAR_14->codec_type;
#else
u32 VAR_15 = VAR_12->codecpar->codec_type;
#endif
switch(VAR_15) {
case VAR_16:
if (!VAR_7) VAR_7 = VAR_12->id ? VAR_12->id : VAR_3+1;
break;
case VAR_17:
VAR_7 = VAR_12->id ? VAR_12->id : VAR_3+1;
break;
}
}
VAR_4 = VAR_5 = VAR_6 = 0;
for (VAR_3 = 0; VAR_3 < VAR_1->demuxer->nb_streams; VAR_3++) {
GF_FilterPid *VAR_18=NULL;
PidCtx *VAR_19;
u32 VAR_20;
u32 VAR_21 = 0;
Bool VAR_22=VAR_23;
u32 VAR_24;
AVStream *VAR_12 = VAR_1->demuxer->streams[VAR_3];
#if (VAR_13 < 59)
AVCodecContext *VAR_14 = VAR_12->codec;
u32 VAR_15 = VAR_14->codec_type;
u32 VAR_25 = VAR_14->codec_id;
const uint8_t *VAR_26 = VAR_14->extradata;
u32 VAR_27 = VAR_14->extradata_size;
u32 VAR_28 = VAR_14->sample_rate;
u32 VAR_29 = VAR_14->frame_size;
u32 VAR_30 = VAR_14->channels;
u32 VAR_31 = VAR_14->width;
u32 VAR_32 = VAR_14->height;
u32 VAR_33 = VAR_14->field_order;
u32 VAR_34 = VAR_14->codec_tag;
u32 VAR_35 = VAR_14->pix_fmt;
u32 VAR_36 = 0;
AVRational VAR_37 = {0, 0};
#if VAR_10 >= 58
VAR_37 = VAR_14->framerate;
#endif
s32 VAR_38 = VAR_14->sample_fmt;
u32 VAR_39 = (u32) VAR_14->bit_rate;
#else
u32 VAR_15 = VAR_12->codecpar->codec_type;
u32 VAR_25 = VAR_12->codecpar->codec_id;
const uint8_t *VAR_26 = VAR_12->codecpar->extradata;
u32 VAR_27 = VAR_12->codecpar->extradata_size;
u32 VAR_28 = VAR_12->codecpar->sample_rate;
u32 VAR_29 = VAR_12->codecpar->frame_size;
u32 VAR_30 = VAR_12->codecpar->channels;
u32 VAR_31 = VAR_12->codecpar->width;
u32 VAR_32 = VAR_12->codecpar->height;
u32 VAR_33 = VAR_12->codecpar->field_order;
u32 VAR_34 = VAR_12->codecpar->codec_tag;
u32 VAR_35 = (VAR_15==VAR_17) ? VAR_12->codecpar->format : 0;
s32 VAR_38 = (VAR_15==VAR_16) ? VAR_12->codecpar->format : 0;
u32 VAR_39 = (u32) VAR_12->codecpar->bit_rate;
u32 VAR_36 = (u32) VAR_12->codecpar->block_align;
AVRational VAR_37 = VAR_12->r_frame_rate;
if (!VAR_12->r_frame_rate.num || !VAR_12->r_frame_rate.den)
VAR_37 = VAR_12->avg_frame_rate;
#endif
if (VAR_1->fps_forced.num) {
VAR_37.num = VAR_1->fps_forced.num;
VAR_37.den = VAR_1->fps_forced.den;
}
switch(VAR_15) {
case VAR_16:
VAR_18 = gf_filter_pid_new(VAR_0);
if (!VAR_18) return VAR_40;
gf_filter_pid_set_property(VAR_18, VAR_41, &PROP_UINT(VAR_42) );
VAR_4++;
sprintf(VAR_8, ""audio%d"", VAR_4);
if (VAR_1->audio_idx<0)
VAR_1->audio_idx = VAR_3;
break;
case VAR_17:
VAR_18 = gf_filter_pid_new(VAR_0);
if (!VAR_18) return VAR_40;
gf_filter_pid_set_property(VAR_18, VAR_41, &PROP_UINT(VAR_43) );
VAR_5++;
sprintf(VAR_8, ""video%d"", VAR_5);
if (VAR_1->video_idx<0)
VAR_1->video_idx = VAR_3;
break;
case VAR_44:
VAR_18 = gf_filter_pid_new(VAR_0);
if (!VAR_18) return VAR_40;
gf_filter_pid_set_property(VAR_18, VAR_41, &PROP_UINT(VAR_45) );
VAR_6++;
sprintf(VAR_8, ""text%d"", VAR_6);
break;
default:
sprintf(VAR_8, ""ffdmx%d"", VAR_3+1);
break;
}
if (!VAR_18) continue;
VAR_19 = &VAR_1->pids_ctx[VAR_3];
VAR_19->pid = VAR_18;
VAR_19->ts_offset = 0;
gf_filter_pid_set_udta(VAR_18, VAR_12);
gf_filter_pid_set_property(VAR_18, VAR_46, &PROP_UINT( (VAR_12->id ? VAR_12->id : VAR_3+1)) );
gf_filter_pid_set_name(VAR_18, VAR_8);
if (VAR_1->raw_data && VAR_1->sclock) {
gf_filter_pid_set_property(VAR_18, VAR_47, &PROP_UINT(1000000) );
} else {
gf_filter_pid_set_property(VAR_18, VAR_47, &PROP_UINT(VAR_12->time_base.den) );
}
if (VAR_7)
gf_filter_pid_set_property(VAR_18, VAR_48, &PROP_UINT(VAR_7) );
if (!VAR_1->raw_data) {
if (VAR_12->duration>=0)
gf_filter_pid_set_property(VAR_18, VAR_49, &PROP_FRAC64_INT(VAR_12->duration, VAR_12->time_base.den) );
else if (VAR_1->demuxer->duration>=0)
gf_filter_pid_set_property(VAR_18, VAR_49, &PROP_FRAC64_INT(VAR_1->demuxer->duration, VAR_50) );
}
if (VAR_12->sample_aspect_ratio.num && VAR_12->sample_aspect_ratio.den)
gf_filter_pid_set_property(VAR_18, VAR_51, &PROP_FRAC_INT( VAR_12->sample_aspect_ratio.num, VAR_12->sample_aspect_ratio.den ) );
ffmpeg_tags_to_gpac(VAR_12->metadata, VAR_18);
VAR_24 = ffmpeg_codecid_to_gpac(VAR_25);
if (!VAR_24) {
gf_filter_pid_set_property(VAR_18, VAR_52, &PROP_UINT(VAR_53) );
VAR_22 = VAR_54;
} else {
gf_filter_pid_set_property(VAR_18, VAR_52, &PROP_UINT(VAR_24) );
}
if (VAR_2)
gf_filter_pid_set_property(VAR_18, VAR_55, &PROP_UINT(VAR_2) );
else if (VAR_1->demuxer->iformat) {
if ((VAR_1->demuxer->iformat->flags & VAR_56) || VAR_1->demuxer->iformat->read_seek)
gf_filter_pid_set_property(VAR_18, VAR_57, &PROP_UINT(VAR_58 ) );
}
u32 VAR_59 = gf_log_get_tool_level(VAR_60);
gf_log_set_tool_level(VAR_60, VAR_61);
VAR_21 = ffdmx_valid_should_reframe(VAR_24, (u8 *) VAR_26, VAR_27);
gf_log_set_tool_level(VAR_60, VAR_59);
if (VAR_22) {
const char *VAR_62 = avcodec_get_name(VAR_25);
#if (VAR_13 < 59)
gf_filter_pid_set_property(VAR_18, VAR_63, &PROP_POINTER( (void*)VAR_14 ) );
#else
gf_filter_pid_set_property(VAR_18, VAR_63, &PROP_UINT( VAR_25 ) );
if (VAR_26) {
gf_filter_pid_set_property(VAR_18, VAR_64, &PROP_CONST_DATA( (char *)VAR_26, VAR_27) );
}
#endif
if (VAR_62)
gf_filter_pid_set_property(VAR_18, VAR_65, &PROP_STRING(VAR_62 ) );
} else if (VAR_27) {
if (VAR_1->demuxer->iformat) {
if (!strcmp(VAR_1->demuxer->iformat->name, ""h264"")
|| !strcmp(VAR_1->demuxer->iformat->name, ""hevc"")
|| !strcmp(VAR_1->demuxer->iformat->name, ""vvc"")
) {
VAR_21 = 1;
}
}
if (VAR_21!=1) {
ffdmx_set_decoder_config(VAR_19, VAR_26, VAR_27, VAR_24);
}
}
if (VAR_21) {
gf_filter_pid_set_property(VAR_18, VAR_66, &PROP_BOOL(VAR_54) );
}
else if (!gf_sys_is_test_mode() ){
switch (VAR_24) {
case VAR_67:
case VAR_68:
case VAR_69:
case VAR_70:
case VAR_71:
if (VAR_1->reparse
#ifdef VAR_72
|| 1
#endif
) {
gf_filter_pid_set_property(VAR_18, VAR_73, &PROP_BOOL(VAR_54) );
gf_filter_pid_set_property(VAR_18, VAR_66, &PROP_BOOL(VAR_54) );
}
break;
}
}
if (VAR_28)
gf_filter_pid_set_property(VAR_18, VAR_74, &PROP_UINT( VAR_28 ) );
if (VAR_29)
gf_filter_pid_set_property(VAR_18, VAR_75, &PROP_UINT( VAR_29 ) );
if (VAR_30)
gf_filter_pid_set_property(VAR_18, VAR_76, &PROP_UINT( VAR_30 ) );
if (VAR_31)
gf_filter_pid_set_property(VAR_18, VAR_77, &PROP_UINT( VAR_31 ) );
if (VAR_32)
gf_filter_pid_set_property(VAR_18, VAR_78, &PROP_UINT( VAR_32 ) );
#if (VAR_13 >= 59)
ffmpeg_codec_par_to_gpac(VAR_12->codecpar, VAR_18, 0);
if (VAR_24!=VAR_79) {
gf_filter_pid_set_property(VAR_18, VAR_80, NULL);
gf_filter_pid_set_property(VAR_18, VAR_81, NULL);
}
#endif
if (VAR_31 && VAR_32) {
if (VAR_37.num && VAR_37.den) {
gf_media_get_reduced_frame_rate(&VAR_37.num, &VAR_37.den);
gf_filter_pid_set_property(VAR_18, VAR_82, &PROP_FRAC_INT( VAR_37.num, VAR_37.den ) );
} else {
GF_LOG(VAR_83, VAR_1->log_class, (""[%s] Unknown frame rate, will use 25 fps - use `:#FPS=VAL` to force frame rate signaling\n"", VAR_1->fname));
gf_filter_pid_set_property(VAR_18, VAR_82, &PROP_FRAC_INT( 25, 1 ) );
}
}
if (VAR_33>VAR_84)
gf_filter_pid_set_property(VAR_18, VAR_85, &PROP_BOOL(VAR_54) );
if ((VAR_15==VAR_17)
&& (VAR_35 || ((VAR_25==VAR_86) && VAR_34))
) {
Bool VAR_87 = VAR_23;
u32 VAR_88 = 0;
if (VAR_35) {
VAR_88 = ffmpeg_pixfmt_to_gpac(VAR_35, VAR_23);
VAR_87 = ffmpeg_pixfmt_is_fullrange(VAR_35);
} else if (VAR_34) {
VAR_88 = ffmpeg_pixfmt_from_codec_tag(VAR_34, &VAR_87);
}
if (!VAR_88) {
GF_LOG(VAR_83, VAR_1->log_class, (""[%s] Unsupported pixel format %d\n"", VAR_1->fname, VAR_35));
} else {
gf_filter_pid_set_property(VAR_18, VAR_80, &PROP_UINT( VAR_88) );
if (VAR_87)
gf_filter_pid_set_property(VAR_18, VAR_89, &PROP_BOOL( VAR_54 ) );
}
}
if (VAR_15==VAR_44) {
gf_filter_pid_set_property(VAR_18, VAR_90, &PROP_UINT(GF_4CC('s','b','t','l')));
}
VAR_1->pids_ctx[VAR_3].mkv_webvtt = VAR_23;
if ((VAR_24==VAR_91) && strstr(VAR_1->demuxer->iformat->name, ""matroska""))
VAR_1->pids_ctx[VAR_3].mkv_webvtt = VAR_54;
if (VAR_38>0) {
u32 VAR_92 = 0;
switch (VAR_38) {
case VAR_93: VAR_92 = VAR_94; break;
case VAR_95: VAR_92 = VAR_96; break;
case VAR_97: VAR_92 = VAR_98; break;
case VAR_99: VAR_92 = VAR_100; break;
case VAR_101: VAR_92 = VAR_102; break;
case VAR_103: VAR_92 = VAR_104; break;
case VAR_105: VAR_92 = VAR_106; break;
case VAR_107: VAR_92 = VAR_108; break;
case VAR_109: VAR_92 = VAR_110; break;
case VAR_111: VAR_92 = VAR_112; break;
default:
GF_LOG(VAR_83, VAR_1->log_class, (""[%s] Unsupported sample format %d\n"", VAR_1->fname, VAR_38));
}
if (VAR_24==VAR_79) {
u32 VAR_113 = ffmpeg_codecid_to_gpac_audio_fmt(VAR_25);
if (VAR_113) VAR_92 = VAR_113;
}
gf_filter_pid_set_property(VAR_18, VAR_81, &PROP_UINT( VAR_92) );
}
if (VAR_39)
gf_filter_pid_set_property(VAR_18, VAR_114, &PROP_UINT( (u32) VAR_39 ) );
gf_filter_pid_set_property(VAR_18, VAR_115, &PROP_STRING( AVFMT_URL(VAR_1->demuxer) ));
if (gf_file_exists(VAR_1->src)) {
gf_filter_pid_set_property(VAR_18, VAR_116, &PROP_BOOL(VAR_54));
}
if (VAR_36)
gf_filter_pid_set_property(VAR_18, VAR_117, &PROP_UINT(VAR_36));
if ((VAR_12->disposition & VAR_118) && !gf_sys_is_test_mode()) {
gf_filter_pid_set_property(VAR_18, VAR_119, &PROP_BOOL(VAR_54));
}
gf_filter_pid_set_property(VAR_18, VAR_120, &PROP_UINT(VAR_3+1));
for (VAR_20=0; VAR_20<(u32) VAR_12->nb_side_data; VAR_20++) {
ffdmx_parse_side_data(&VAR_12->side_data[VAR_3], VAR_18);
}
if (VAR_1->demuxer->nb_chapters) {
GF_PropertyValue VAR_121;
GF_PropUIntList VAR_122;
GF_PropStringList VAR_123;
u32 VAR_124 = VAR_1->demuxer->nb_chapters;
VAR_122.vals = gf_malloc(sizeof(u32)*VAR_124);
VAR_123.vals = gf_malloc(sizeof(char *)*VAR_124);
memset(VAR_123.vals, 0, sizeof(char *)*VAR_124);
VAR_122.nb_items = VAR_123.nb_items = VAR_124;
for (VAR_20=0; VAR_20<VAR_1->demuxer->nb_chapters; VAR_20++) {
AVChapter *VAR_125 = VAR_1->demuxer->chapters[VAR_20];
u64 VAR_126 = gf_timestamp_rescale(VAR_125->start * VAR_125->time_base.num, VAR_125->time_base.den, 1000);
VAR_122.vals[VAR_20] = (u32) VAR_126;
AVDictionaryEntry *VAR_127 = NULL;
while (VAR_125->metadata) {
VAR_127 = av_dict_get(VAR_125->metadata, """", VAR_127, VAR_128);
if (!VAR_127) break;
if (!strcmp(VAR_127->key, ""title"")) {
VAR_123.vals[VAR_20] = gf_strdup(VAR_127->value);
}
}
if (!VAR_123.vals[VAR_20]) VAR_123.vals[VAR_20] = gf_strdup(""Unknwon"");
}
VAR_121.type = VAR_129;
VAR_121.value.uint_list = VAR_122;
gf_filter_pid_set_property(VAR_18, VAR_130, &VAR_121);
gf_free(VAR_122.vals);
VAR_121.type = VAR_131;
VAR_121.value.string_list = VAR_123;
gf_filter_pid_set_property(VAR_18, VAR_132, &VAR_121);
}
}
if (!VAR_4 && !VAR_5 && !VAR_6)
return VAR_133;
return VAR_9;
}",gpac/671976fccc971b3dff8d3dcf6ebd600472ca64bf/ff_dmx.c/vul/before/0.json,"GF_Err ffdmx_init_common(GF_Filter *filter, GF_FFDemuxCtx *ctx, u32 grab_type)
{
	u32 i;
	u32 nb_a, nb_v, nb_t, clock_id;
	char szName[50];


	if (gf_filter_is_temporary(filter)) {
		gf_filter_meta_set_instances(filter, ctx->demuxer->av_class->class_name);
		return GF_OK;
	}

#if (LIBAVCODEC_VERSION_MAJOR >= 59)
	ctx->pkt = av_packet_alloc();
#endif

	ctx->pids_ctx = gf_malloc(sizeof(PidCtx)*ctx->demuxer->nb_streams);
	memset(ctx->pids_ctx, 0, sizeof(PidCtx)*ctx->demuxer->nb_streams);
	ctx->nb_streams = ctx->demuxer->nb_streams;

	clock_id = 0;
	for (i = 0; i < ctx->demuxer->nb_streams; i++) {
		AVStream *stream = ctx->demuxer->streams[i];
#if (LIBAVFORMAT_VERSION_MAJOR < 59)
		AVCodecContext *codec = stream->codec;
		u32 codec_type = codec->codec_type;
#else
		u32 codec_type = stream->codecpar->codec_type;
#endif
		switch(codec_type) {
		case AVMEDIA_TYPE_AUDIO:
			if (!clock_id) clock_id = stream->id ? stream->id : i+1;
			break;
		case AVMEDIA_TYPE_VIDEO:
			clock_id = stream->id ? stream->id : i+1;
			break;
		}
	}

	nb_a = nb_v = nb_t = 0;
	for (i = 0; i < ctx->demuxer->nb_streams; i++) {
		GF_FilterPid *pid=NULL;
		PidCtx *pctx;
		u32 j;
		u32 force_reframer = 0;
		Bool expose_ffdec=GF_FALSE;
		u32 gpac_codec_id;
		AVStream *stream = ctx->demuxer->streams[i];
#if (LIBAVFORMAT_VERSION_MAJOR < 59)
		AVCodecContext *codec = stream->codec;
		u32 codec_type = codec->codec_type;
		u32 codec_id = codec->codec_id;
		const uint8_t *exdata = codec->extradata;
		u32 exdata_size = codec->extradata_size;
		u32 codec_sample_rate = codec->sample_rate;
		u32 codec_frame_size = codec->frame_size;
		u32 codec_channels = codec->channels;
		u32 codec_width = codec->width;
		u32 codec_height = codec->height;
		u32 codec_field_order = codec->field_order;
		u32 codec_tag = codec->codec_tag;
		u32 codec_pixfmt = codec->pix_fmt;
		u32 codec_blockalign = 0;
		AVRational codec_framerate = {0, 0};
#if LIBAVCODEC_VERSION_MAJOR >= 58
		codec_framerate = codec->framerate;
#endif
		s32 codec_sample_fmt = codec->sample_fmt;
		u32 codec_bitrate = (u32) codec->bit_rate;

#else
		u32 codec_type = stream->codecpar->codec_type;
		u32 codec_id = stream->codecpar->codec_id;
		const uint8_t *exdata = stream->codecpar->extradata;
		u32 exdata_size = stream->codecpar->extradata_size;
		u32 codec_sample_rate = stream->codecpar->sample_rate;
		u32 codec_frame_size = stream->codecpar->frame_size;
		u32 codec_channels = stream->codecpar->channels;
		u32 codec_width = stream->codecpar->width;
		u32 codec_height = stream->codecpar->height;
		u32 codec_field_order = stream->codecpar->field_order;
		u32 codec_tag = stream->codecpar->codec_tag;
		u32 codec_pixfmt = (codec_type==AVMEDIA_TYPE_VIDEO) ? stream->codecpar->format : 0;
		s32 codec_sample_fmt = (codec_type==AVMEDIA_TYPE_AUDIO) ? stream->codecpar->format : 0;
		u32 codec_bitrate = (u32) stream->codecpar->bit_rate;
		u32 codec_blockalign = (u32) stream->codecpar->block_align;
		AVRational codec_framerate = stream->r_frame_rate;
		if (!stream->r_frame_rate.num || !stream->r_frame_rate.den)
			codec_framerate = stream->avg_frame_rate;
#endif

		//if fps was detected by ffavin, use it (r_frame_rate is unreliable, just a guess)
		if (ctx->fps_forced.num) {
			codec_framerate.num = ctx->fps_forced.num;
			codec_framerate.den = ctx->fps_forced.den;
		}
		switch(codec_type) {
		case AVMEDIA_TYPE_AUDIO:
			pid = gf_filter_pid_new(filter);
			if (!pid) return GF_OUT_OF_MEM;
			gf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_AUDIO) );
			nb_a++;
			sprintf(szName, ""audio%d"", nb_a);
			if (ctx->audio_idx<0)
				ctx->audio_idx = i;
			break;

		case AVMEDIA_TYPE_VIDEO:
			pid = gf_filter_pid_new(filter);
			if (!pid) return GF_OUT_OF_MEM;
			gf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_VISUAL) );
			nb_v++;
			sprintf(szName, ""video%d"", nb_v);
			if (ctx->video_idx<0)
				ctx->video_idx = i;
			break;
		case AVMEDIA_TYPE_SUBTITLE:
			pid = gf_filter_pid_new(filter);
			if (!pid) return GF_OUT_OF_MEM;
			gf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );
			nb_t++;
			sprintf(szName, ""text%d"", nb_t);
			break;
		default:
			sprintf(szName, ""ffdmx%d"", i+1);
			break;
		}
		if (!pid) continue;
		pctx = &ctx->pids_ctx[i];
		pctx->pid = pid;
		pctx->ts_offset = 0;
		gf_filter_pid_set_udta(pid, stream);

		gf_filter_pid_set_property(pid, GF_PROP_PID_ID, &PROP_UINT( (stream->id ? stream->id : i+1)) );
		gf_filter_pid_set_name(pid, szName);

		if (ctx->raw_data && ctx->sclock) {
			gf_filter_pid_set_property(pid, GF_PROP_PID_TIMESCALE, &PROP_UINT(1000000) );
		} else {
			gf_filter_pid_set_property(pid, GF_PROP_PID_TIMESCALE, &PROP_UINT(stream->time_base.den) );
		}
		if (clock_id)
			gf_filter_pid_set_property(pid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(clock_id) );

		if (!ctx->raw_data) {
			if (stream->duration>=0)
				gf_filter_pid_set_property(pid, GF_PROP_PID_DURATION, &PROP_FRAC64_INT(stream->duration, stream->time_base.den) );
			else if (ctx->demuxer->duration>=0)
				gf_filter_pid_set_property(pid, GF_PROP_PID_DURATION, &PROP_FRAC64_INT(ctx->demuxer->duration, AV_TIME_BASE) );
		}

		if (stream->sample_aspect_ratio.num && stream->sample_aspect_ratio.den)
			gf_filter_pid_set_property(pid, GF_PROP_PID_SAR, &PROP_FRAC_INT( stream->sample_aspect_ratio.num, stream->sample_aspect_ratio.den ) );

		ffmpeg_tags_to_gpac(stream->metadata, pid);

		gpac_codec_id = ffmpeg_codecid_to_gpac(codec_id);
		if (!gpac_codec_id) {
			gf_filter_pid_set_property(pid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_FFMPEG) );
			expose_ffdec = GF_TRUE;
		} else {
			gf_filter_pid_set_property(pid, GF_PROP_PID_CODECID, &PROP_UINT(gpac_codec_id) );
		}

		if (grab_type)
			gf_filter_pid_set_property(pid, GF_PROP_PID_RAWGRAB, &PROP_UINT(grab_type) );
		else if (ctx->demuxer->iformat) {
			if ((ctx->demuxer->iformat->flags & AVFMT_SEEK_TO_PTS) || ctx->demuxer->iformat->read_seek)
				gf_filter_pid_set_property(pid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) );
		}


		u32 lt = gf_log_get_tool_level(GF_LOG_CODING);
		gf_log_set_tool_level(GF_LOG_CODING, GF_LOG_QUIET);
		force_reframer = ffdmx_valid_should_reframe(gpac_codec_id, (u8 *) exdata, exdata_size);
		gf_log_set_tool_level(GF_LOG_CODING, lt);

		if (expose_ffdec) {
			const char *cname = avcodec_get_name(codec_id);
#if (LIBAVFORMAT_VERSION_MAJOR < 59)
			gf_filter_pid_set_property(pid, GF_PROP_PID_META_DEMUX_CODEC_ID, &PROP_POINTER( (void*)codec ) );
#else
			gf_filter_pid_set_property(pid, GF_PROP_PID_META_DEMUX_CODEC_ID, &PROP_UINT( codec_id ) );
			if (exdata) {
				//expose as const data
				gf_filter_pid_set_property(pid, GF_PROP_PID_DECODER_CONFIG, &PROP_CONST_DATA( (char *)exdata, exdata_size) );
			}
#endif

			if (cname)
				gf_filter_pid_set_property(pid, GF_PROP_PID_META_DEMUX_CODEC_NAME, &PROP_STRING(cname ) );
		} else if (exdata_size) {

			//avc/hevc read by ffmpeg is still in annex B format
			if (ctx->demuxer->iformat) {
				if (!strcmp(ctx->demuxer->iformat->name, ""h264"")
					|| !strcmp(ctx->demuxer->iformat->name, ""hevc"")
					|| !strcmp(ctx->demuxer->iformat->name, ""vvc"")
				) {
					force_reframer = 1;
				}
			}

			//set extra data if desired
			if (force_reframer!=1) {
				ffdmx_set_decoder_config(pctx, exdata, exdata_size, gpac_codec_id);
			}
		}

		if (force_reframer) {
			gf_filter_pid_set_property(pid, GF_PROP_PID_UNFRAMED, &PROP_BOOL(GF_TRUE) );
		}
		else if (!gf_sys_is_test_mode() ){
			//force reparse of nalu-base codecs if no dovi support
			switch (gpac_codec_id) {
			case GF_CODECID_AVC:
			case GF_CODECID_HEVC:
			case GF_CODECID_LHVC:
			case GF_CODECID_VVC:
			case GF_CODECID_AV1:
				if (ctx->reparse
#ifdef FFMPEG_NO_DOVI
				 || 1
#endif
				) {
					gf_filter_pid_set_property(pid, GF_PROP_PID_FORCE_UNFRAME, &PROP_BOOL(GF_TRUE) );
					gf_filter_pid_set_property(pid, GF_PROP_PID_UNFRAMED, &PROP_BOOL(GF_TRUE) );
				}
				break;
			}
		}


		if (codec_sample_rate)
			gf_filter_pid_set_property(pid, GF_PROP_PID_SAMPLE_RATE, &PROP_UINT( codec_sample_rate ) );
		if (codec_frame_size)
			gf_filter_pid_set_property(pid, GF_PROP_PID_SAMPLES_PER_FRAME, &PROP_UINT( codec_frame_size ) );
		if (codec_channels)
			gf_filter_pid_set_property(pid, GF_PROP_PID_NUM_CHANNELS, &PROP_UINT( codec_channels ) );

		if (codec_width)
			gf_filter_pid_set_property(pid, GF_PROP_PID_WIDTH, &PROP_UINT( codec_width ) );
		if (codec_height)
			gf_filter_pid_set_property(pid, GF_PROP_PID_HEIGHT, &PROP_UINT( codec_height ) );


#if (LIBAVFORMAT_VERSION_MAJOR >= 59)
		ffmpeg_codec_par_to_gpac(stream->codecpar, pid, 0);
		if (gpac_codec_id!=GF_CODECID_RAW) {
			gf_filter_pid_set_property(pid, GF_PROP_PID_PIXFMT, NULL);
			gf_filter_pid_set_property(pid, GF_PROP_PID_AUDIO_FORMAT, NULL);
		}
#endif

		if (codec_width && codec_height) {
			if (codec_framerate.num && codec_framerate.den) {
				gf_media_get_reduced_frame_rate(&codec_framerate.num, &codec_framerate.den);
				gf_filter_pid_set_property(pid, GF_PROP_PID_FPS, &PROP_FRAC_INT( codec_framerate.num, codec_framerate.den ) );
			} else {
				GF_LOG(GF_LOG_WARNING, ctx->log_class, (""[%s] Unknown frame rate, will use 25 fps - use `:#FPS=VAL` to force frame rate signaling\n"", ctx->fname));
				gf_filter_pid_set_property(pid, GF_PROP_PID_FPS, &PROP_FRAC_INT( 25, 1 ) );
			}
		}

		if (codec_field_order>AV_FIELD_PROGRESSIVE)
			gf_filter_pid_set_property(pid, GF_PROP_PID_INTERLACED, &PROP_BOOL(GF_TRUE) );

		if ((codec_type==AVMEDIA_TYPE_VIDEO)
			&& (codec_pixfmt || ((codec_id==AV_CODEC_ID_RAWVIDEO) && codec_tag))
		) {
			Bool is_full_range = GF_FALSE;
			u32 pfmt = 0;

			if (codec_pixfmt) {
				pfmt = ffmpeg_pixfmt_to_gpac(codec_pixfmt, GF_FALSE);
				is_full_range = ffmpeg_pixfmt_is_fullrange(codec_pixfmt);
			} else if (codec_tag) {
				pfmt = ffmpeg_pixfmt_from_codec_tag(codec_tag, &is_full_range);
			}

			if (!pfmt) {
				GF_LOG(GF_LOG_WARNING, ctx->log_class, (""[%s] Unsupported pixel format %d\n"", ctx->fname, codec_pixfmt));
			} else {
				gf_filter_pid_set_property(pid, GF_PROP_PID_PIXFMT, &PROP_UINT( pfmt) );
				if (is_full_range)
					gf_filter_pid_set_property(pid, GF_PROP_PID_COLR_RANGE, &PROP_BOOL( GF_TRUE ) );
			}
		}

		if (codec_type==AVMEDIA_TYPE_SUBTITLE) {
			gf_filter_pid_set_property(pid, GF_PROP_PID_SUBTYPE, &PROP_UINT(GF_4CC('s','b','t','l')));
		}

		ctx->pids_ctx[i].mkv_webvtt = GF_FALSE;
		if ((gpac_codec_id==GF_CODECID_WEBVTT) && strstr(ctx->demuxer->iformat->name, ""matroska""))
			ctx->pids_ctx[i].mkv_webvtt = GF_TRUE;

		if (codec_sample_fmt>0) {
			u32 sfmt = 0;
			switch (codec_sample_fmt) {
			case AV_SAMPLE_FMT_U8: sfmt = GF_AUDIO_FMT_U8; break;
			case AV_SAMPLE_FMT_S16: sfmt = GF_AUDIO_FMT_S16; break;
			case AV_SAMPLE_FMT_S32: sfmt = GF_AUDIO_FMT_S32; break;
			case AV_SAMPLE_FMT_FLT: sfmt = GF_AUDIO_FMT_FLT; break;
			case AV_SAMPLE_FMT_DBL: sfmt = GF_AUDIO_FMT_DBL; break;
			case AV_SAMPLE_FMT_U8P: sfmt = GF_AUDIO_FMT_U8P; break;
			case AV_SAMPLE_FMT_S16P: sfmt = GF_AUDIO_FMT_S16P; break;
			case AV_SAMPLE_FMT_S32P: sfmt = GF_AUDIO_FMT_S32P; break;
			case AV_SAMPLE_FMT_FLTP: sfmt = GF_AUDIO_FMT_FLTP; break;
			case AV_SAMPLE_FMT_DBLP: sfmt = GF_AUDIO_FMT_DBLP; break;
			default:
				GF_LOG(GF_LOG_WARNING, ctx->log_class, (""[%s] Unsupported sample format %d\n"", ctx->fname, codec_sample_fmt));
			}
			if (gpac_codec_id==GF_CODECID_RAW) {
				u32 res = ffmpeg_codecid_to_gpac_audio_fmt(codec_id);
				if (res) sfmt = res;
			}
			gf_filter_pid_set_property(pid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT( sfmt) );
		}

		if (codec_bitrate)
			gf_filter_pid_set_property(pid, GF_PROP_PID_BITRATE, &PROP_UINT( (u32) codec_bitrate ) );

		gf_filter_pid_set_property(pid, GF_PROP_PID_URL, &PROP_STRING( AVFMT_URL(ctx->demuxer) ));

		if (gf_file_exists(ctx->src)) {
			gf_filter_pid_set_property(pid, GF_PROP_PID_FILE_CACHED, &PROP_BOOL(GF_TRUE));
		}

		if (codec_blockalign)
			gf_filter_pid_set_property(pid, GF_PROP_PID_META_DEMUX_OPAQUE, &PROP_UINT(codec_blockalign));

		if ((stream->disposition & AV_DISPOSITION_DEFAULT) && !gf_sys_is_test_mode()) {
			gf_filter_pid_set_property(pid, GF_PROP_PID_IS_DEFAULT, &PROP_BOOL(GF_TRUE));
		}
		gf_filter_pid_set_property(pid, GF_PROP_PID_MUX_INDEX, &PROP_UINT(i+1));

		for (j=0; j<(u32) stream->nb_side_data; j++) {
			ffdmx_parse_side_data(&stream->side_data[j], pid);
		}

		if (ctx->demuxer->nb_chapters) {
			GF_PropertyValue p;
			GF_PropUIntList times;
			GF_PropStringList names;
			u32 nb_c = ctx->demuxer->nb_chapters;

			times.vals = gf_malloc(sizeof(u32)*nb_c);
			names.vals = gf_malloc(sizeof(char *)*nb_c);
			memset(names.vals, 0, sizeof(char *)*nb_c);
			times.nb_items = names.nb_items = nb_c;

			for (j=0; j<ctx->demuxer->nb_chapters; j++) {
				AVChapter *c = ctx->demuxer->chapters[j];
				u64 start = gf_timestamp_rescale(c->start * c->time_base.num, c->time_base.den, 1000);
				times.vals[j] = (u32) start;
				AVDictionaryEntry *ent = NULL;
				while (c->metadata) {
					ent = av_dict_get(c->metadata, """", ent, AV_DICT_IGNORE_SUFFIX);
					if (!ent) break;
					if (!strcmp(ent->key, ""title"")) {
						names.vals[j] = gf_strdup(ent->value);
					}
				}
				if (!names.vals[j]) names.vals[j] = gf_strdup(""Unknwon"");
			}
			p.type = GF_PROP_UINT_LIST;
			p.value.uint_list = times;
			gf_filter_pid_set_property(pid, GF_PROP_PID_CHAP_TIMES, &p);
			gf_free(times.vals);

			p.type = GF_PROP_STRING_LIST;
			p.value.string_list = names;
			gf_filter_pid_set_property(pid, GF_PROP_PID_CHAP_NAMES, &p);
			//no free for string lists
		}
	}

	if (!nb_a && !nb_v && !nb_t)
		return GF_NOT_SUPPORTED;

	return GF_OK;
}","GF_Err ffdmx_init_common(GF_Filter *VAR_0, GF_FFDemuxCtx *VAR_1, u32 VAR_2)
{
	u32 VAR_3;
	u32 VAR_4, VAR_5, VAR_6, VAR_7;
	char VAR_8[50];


	if (gf_filter_is_temporary(VAR_0)) {
		gf_filter_meta_set_instances(VAR_0, VAR_1->demuxer->av_class->class_name);
		return VAR_9;
	}

#if (VAR_10 >= 59)
	VAR_1->pkt = av_packet_alloc();
#endif

	VAR_1->pids_ctx = gf_malloc(sizeof(VAR_11)*VAR_1->demuxer->nb_streams);
	memset(VAR_1->pids_ctx, 0, sizeof(VAR_11)*VAR_1->demuxer->nb_streams);
	VAR_1->nb_streams = VAR_1->demuxer->nb_streams;

	VAR_7 = 0;
	for (VAR_3 = 0; VAR_3 < VAR_1->demuxer->nb_streams; VAR_3++) {
		AVStream *VAR_12 = VAR_1->demuxer->streams[VAR_3];
#if (VAR_13 < 59)
		AVCodecContext *VAR_14 = VAR_12->codec;
		u32 VAR_15 = VAR_14->codec_type;
#else
		u32 VAR_15 = VAR_12->codecpar->codec_type;
#endif
		switch(VAR_15) {
		case VAR_16:
			if (!VAR_7) VAR_7 = VAR_12->id ? VAR_12->id : VAR_3+1;
			break;
		case VAR_17:
			VAR_7 = VAR_12->id ? VAR_12->id : VAR_3+1;
			break;
		}
	}

	VAR_4 = VAR_5 = VAR_6 = 0;
	for (VAR_3 = 0; VAR_3 < VAR_1->demuxer->nb_streams; VAR_3++) {
		GF_FilterPid *VAR_18=NULL;
		PidCtx *VAR_19;
		u32 VAR_20;
		u32 VAR_21 = 0;
		Bool VAR_22=VAR_23;
		u32 VAR_24;
		AVStream *VAR_12 = VAR_1->demuxer->streams[VAR_3];
#if (VAR_13 < 59)
		AVCodecContext *VAR_14 = VAR_12->codec;
		u32 VAR_15 = VAR_14->codec_type;
		u32 VAR_25 = VAR_14->codec_id;
		const uint8_t *VAR_26 = VAR_14->extradata;
		u32 VAR_27 = VAR_14->extradata_size;
		u32 VAR_28 = VAR_14->sample_rate;
		u32 VAR_29 = VAR_14->frame_size;
		u32 VAR_30 = VAR_14->channels;
		u32 VAR_31 = VAR_14->width;
		u32 VAR_32 = VAR_14->height;
		u32 VAR_33 = VAR_14->field_order;
		u32 VAR_34 = VAR_14->codec_tag;
		u32 VAR_35 = VAR_14->pix_fmt;
		u32 VAR_36 = 0;
		AVRational VAR_37 = {0, 0};
#if VAR_10 >= 58
		VAR_37 = VAR_14->framerate;
#endif
		s32 VAR_38 = VAR_14->sample_fmt;
		u32 VAR_39 = (u32) VAR_14->bit_rate;

#else
		u32 VAR_15 = VAR_12->codecpar->codec_type;
		u32 VAR_25 = VAR_12->codecpar->codec_id;
		const uint8_t *VAR_26 = VAR_12->codecpar->extradata;
		u32 VAR_27 = VAR_12->codecpar->extradata_size;
		u32 VAR_28 = VAR_12->codecpar->sample_rate;
		u32 VAR_29 = VAR_12->codecpar->frame_size;
		u32 VAR_30 = VAR_12->codecpar->channels;
		u32 VAR_31 = VAR_12->codecpar->width;
		u32 VAR_32 = VAR_12->codecpar->height;
		u32 VAR_33 = VAR_12->codecpar->field_order;
		u32 VAR_34 = VAR_12->codecpar->codec_tag;
		u32 VAR_35 = (VAR_15==VAR_17) ? VAR_12->codecpar->format : 0;
		s32 VAR_38 = (VAR_15==VAR_16) ? VAR_12->codecpar->format : 0;
		u32 VAR_39 = (u32) VAR_12->codecpar->bit_rate;
		u32 VAR_36 = (u32) VAR_12->codecpar->block_align;
		AVRational VAR_37 = VAR_12->r_frame_rate;
		if (!VAR_12->r_frame_rate.num || !VAR_12->r_frame_rate.den)
			VAR_37 = VAR_12->avg_frame_rate;
#endif

		/* COMMENT_0 */
		if (VAR_1->fps_forced.num) {
			VAR_37.num = VAR_1->fps_forced.num;
			VAR_37.den = VAR_1->fps_forced.den;
		}
		switch(VAR_15) {
		case VAR_16:
			VAR_18 = gf_filter_pid_new(VAR_0);
			if (!VAR_18) return VAR_40;
			gf_filter_pid_set_property(VAR_18, VAR_41, &PROP_UINT(VAR_42) );
			VAR_4++;
			sprintf(VAR_8, ""audio%d"", VAR_4);
			if (VAR_1->audio_idx<0)
				VAR_1->audio_idx = VAR_3;
			break;

		case VAR_17:
			VAR_18 = gf_filter_pid_new(VAR_0);
			if (!VAR_18) return VAR_40;
			gf_filter_pid_set_property(VAR_18, VAR_41, &PROP_UINT(VAR_43) );
			VAR_5++;
			sprintf(VAR_8, ""video%d"", VAR_5);
			if (VAR_1->video_idx<0)
				VAR_1->video_idx = VAR_3;
			break;
		case VAR_44:
			VAR_18 = gf_filter_pid_new(VAR_0);
			if (!VAR_18) return VAR_40;
			gf_filter_pid_set_property(VAR_18, VAR_41, &PROP_UINT(VAR_45) );
			VAR_6++;
			sprintf(VAR_8, ""text%d"", VAR_6);
			break;
		default:
			sprintf(VAR_8, ""ffdmx%d"", VAR_3+1);
			break;
		}
		if (!VAR_18) continue;
		VAR_19 = &VAR_1->pids_ctx[VAR_3];
		VAR_19->pid = VAR_18;
		VAR_19->ts_offset = 0;
		gf_filter_pid_set_udta(VAR_18, VAR_12);

		gf_filter_pid_set_property(VAR_18, VAR_46, &PROP_UINT( (VAR_12->id ? VAR_12->id : VAR_3+1)) );
		gf_filter_pid_set_name(VAR_18, VAR_8);

		if (VAR_1->raw_data && VAR_1->sclock) {
			gf_filter_pid_set_property(VAR_18, VAR_47, &PROP_UINT(1000000) );
		} else {
			gf_filter_pid_set_property(VAR_18, VAR_47, &PROP_UINT(VAR_12->time_base.den) );
		}
		if (VAR_7)
			gf_filter_pid_set_property(VAR_18, VAR_48, &PROP_UINT(VAR_7) );

		if (!VAR_1->raw_data) {
			if (VAR_12->duration>=0)
				gf_filter_pid_set_property(VAR_18, VAR_49, &PROP_FRAC64_INT(VAR_12->duration, VAR_12->time_base.den) );
			else if (VAR_1->demuxer->duration>=0)
				gf_filter_pid_set_property(VAR_18, VAR_49, &PROP_FRAC64_INT(VAR_1->demuxer->duration, VAR_50) );
		}

		if (VAR_12->sample_aspect_ratio.num && VAR_12->sample_aspect_ratio.den)
			gf_filter_pid_set_property(VAR_18, VAR_51, &PROP_FRAC_INT( VAR_12->sample_aspect_ratio.num, VAR_12->sample_aspect_ratio.den ) );

		ffmpeg_tags_to_gpac(VAR_12->metadata, VAR_18);

		VAR_24 = ffmpeg_codecid_to_gpac(VAR_25);
		if (!VAR_24) {
			gf_filter_pid_set_property(VAR_18, VAR_52, &PROP_UINT(VAR_53) );
			VAR_22 = VAR_54;
		} else {
			gf_filter_pid_set_property(VAR_18, VAR_52, &PROP_UINT(VAR_24) );
		}

		if (VAR_2)
			gf_filter_pid_set_property(VAR_18, VAR_55, &PROP_UINT(VAR_2) );
		else if (VAR_1->demuxer->iformat) {
			if ((VAR_1->demuxer->iformat->flags & VAR_56) || VAR_1->demuxer->iformat->read_seek)
				gf_filter_pid_set_property(VAR_18, VAR_57, &PROP_UINT(VAR_58 ) );
		}


		u32 VAR_59 = gf_log_get_tool_level(VAR_60);
		gf_log_set_tool_level(VAR_60, VAR_61);
		VAR_21 = ffdmx_valid_should_reframe(VAR_24, (u8 *) VAR_26, VAR_27);
		gf_log_set_tool_level(VAR_60, VAR_59);

		if (VAR_22) {
			const char *VAR_62 = avcodec_get_name(VAR_25);
#if (VAR_13 < 59)
			gf_filter_pid_set_property(VAR_18, VAR_63, &PROP_POINTER( (void*)VAR_14 ) );
#else
			gf_filter_pid_set_property(VAR_18, VAR_63, &PROP_UINT( VAR_25 ) );
			if (VAR_26) {
				/* COMMENT_1 */
				gf_filter_pid_set_property(VAR_18, VAR_64, &PROP_CONST_DATA( (char *)VAR_26, VAR_27) );
			}
#endif

			if (VAR_62)
				gf_filter_pid_set_property(VAR_18, VAR_65, &PROP_STRING(VAR_62 ) );
		} else if (VAR_27) {

			/* COMMENT_2 */
			if (VAR_1->demuxer->iformat) {
				if (!strcmp(VAR_1->demuxer->iformat->name, ""h264"")
					|| !strcmp(VAR_1->demuxer->iformat->name, ""hevc"")
					|| !strcmp(VAR_1->demuxer->iformat->name, ""vvc"")
				) {
					VAR_21 = 1;
				}
			}

			/* COMMENT_3 */
			if (VAR_21!=1) {
				ffdmx_set_decoder_config(VAR_19, VAR_26, VAR_27, VAR_24);
			}
		}

		if (VAR_21) {
			gf_filter_pid_set_property(VAR_18, VAR_66, &PROP_BOOL(VAR_54) );
		}
		else if (!gf_sys_is_test_mode() ){
			/* COMMENT_4 */
			switch (VAR_24) {
			case VAR_67:
			case VAR_68:
			case VAR_69:
			case VAR_70:
			case VAR_71:
				if (VAR_1->reparse
#ifdef VAR_72
				 || 1
#endif
				) {
					gf_filter_pid_set_property(VAR_18, VAR_73, &PROP_BOOL(VAR_54) );
					gf_filter_pid_set_property(VAR_18, VAR_66, &PROP_BOOL(VAR_54) );
				}
				break;
			}
		}


		if (VAR_28)
			gf_filter_pid_set_property(VAR_18, VAR_74, &PROP_UINT( VAR_28 ) );
		if (VAR_29)
			gf_filter_pid_set_property(VAR_18, VAR_75, &PROP_UINT( VAR_29 ) );
		if (VAR_30)
			gf_filter_pid_set_property(VAR_18, VAR_76, &PROP_UINT( VAR_30 ) );

		if (VAR_31)
			gf_filter_pid_set_property(VAR_18, VAR_77, &PROP_UINT( VAR_31 ) );
		if (VAR_32)
			gf_filter_pid_set_property(VAR_18, VAR_78, &PROP_UINT( VAR_32 ) );


#if (VAR_13 >= 59)
		ffmpeg_codec_par_to_gpac(VAR_12->codecpar, VAR_18, 0);
		if (VAR_24!=VAR_79) {
			gf_filter_pid_set_property(VAR_18, VAR_80, NULL);
			gf_filter_pid_set_property(VAR_18, VAR_81, NULL);
		}
#endif

		if (VAR_31 && VAR_32) {
			if (VAR_37.num && VAR_37.den) {
				gf_media_get_reduced_frame_rate(&VAR_37.num, &VAR_37.den);
				gf_filter_pid_set_property(VAR_18, VAR_82, &PROP_FRAC_INT( VAR_37.num, VAR_37.den ) );
			} else {
				GF_LOG(VAR_83, VAR_1->log_class, (""[%s] Unknown frame rate, will use 25 fps - use `:#FPS=VAL` to force frame rate signaling\n"", VAR_1->fname));
				gf_filter_pid_set_property(VAR_18, VAR_82, &PROP_FRAC_INT( 25, 1 ) );
			}
		}

		if (VAR_33>VAR_84)
			gf_filter_pid_set_property(VAR_18, VAR_85, &PROP_BOOL(VAR_54) );

		if ((VAR_15==VAR_17)
			&& (VAR_35 || ((VAR_25==VAR_86) && VAR_34))
		) {
			Bool VAR_87 = VAR_23;
			u32 VAR_88 = 0;

			if (VAR_35) {
				VAR_88 = ffmpeg_pixfmt_to_gpac(VAR_35, VAR_23);
				VAR_87 = ffmpeg_pixfmt_is_fullrange(VAR_35);
			} else if (VAR_34) {
				VAR_88 = ffmpeg_pixfmt_from_codec_tag(VAR_34, &VAR_87);
			}

			if (!VAR_88) {
				GF_LOG(VAR_83, VAR_1->log_class, (""[%s] Unsupported pixel format %d\n"", VAR_1->fname, VAR_35));
			} else {
				gf_filter_pid_set_property(VAR_18, VAR_80, &PROP_UINT( VAR_88) );
				if (VAR_87)
					gf_filter_pid_set_property(VAR_18, VAR_89, &PROP_BOOL( VAR_54 ) );
			}
		}

		if (VAR_15==VAR_44) {
			gf_filter_pid_set_property(VAR_18, VAR_90, &PROP_UINT(GF_4CC('s','b','t','l')));
		}

		VAR_1->pids_ctx[VAR_3].mkv_webvtt = VAR_23;
		if ((VAR_24==VAR_91) && strstr(VAR_1->demuxer->iformat->name, ""matroska""))
			VAR_1->pids_ctx[VAR_3].mkv_webvtt = VAR_54;

		if (VAR_38>0) {
			u32 VAR_92 = 0;
			switch (VAR_38) {
			case VAR_93: VAR_92 = VAR_94; break;
			case VAR_95: VAR_92 = VAR_96; break;
			case VAR_97: VAR_92 = VAR_98; break;
			case VAR_99: VAR_92 = VAR_100; break;
			case VAR_101: VAR_92 = VAR_102; break;
			case VAR_103: VAR_92 = VAR_104; break;
			case VAR_105: VAR_92 = VAR_106; break;
			case VAR_107: VAR_92 = VAR_108; break;
			case VAR_109: VAR_92 = VAR_110; break;
			case VAR_111: VAR_92 = VAR_112; break;
			default:
				GF_LOG(VAR_83, VAR_1->log_class, (""[%s] Unsupported sample format %d\n"", VAR_1->fname, VAR_38));
			}
			if (VAR_24==VAR_79) {
				u32 VAR_113 = ffmpeg_codecid_to_gpac_audio_fmt(VAR_25);
				if (VAR_113) VAR_92 = VAR_113;
			}
			gf_filter_pid_set_property(VAR_18, VAR_81, &PROP_UINT( VAR_92) );
		}

		if (VAR_39)
			gf_filter_pid_set_property(VAR_18, VAR_114, &PROP_UINT( (u32) VAR_39 ) );

		gf_filter_pid_set_property(VAR_18, VAR_115, &PROP_STRING( AVFMT_URL(VAR_1->demuxer) ));

		if (gf_file_exists(VAR_1->src)) {
			gf_filter_pid_set_property(VAR_18, VAR_116, &PROP_BOOL(VAR_54));
		}

		if (VAR_36)
			gf_filter_pid_set_property(VAR_18, VAR_117, &PROP_UINT(VAR_36));

		if ((VAR_12->disposition & VAR_118) && !gf_sys_is_test_mode()) {
			gf_filter_pid_set_property(VAR_18, VAR_119, &PROP_BOOL(VAR_54));
		}
		gf_filter_pid_set_property(VAR_18, VAR_120, &PROP_UINT(VAR_3+1));

		for (VAR_20=0; VAR_20<(u32) VAR_12->nb_side_data; VAR_20++) {
			ffdmx_parse_side_data(&VAR_12->side_data[VAR_20], VAR_18);
		}

		if (VAR_1->demuxer->nb_chapters) {
			GF_PropertyValue VAR_121;
			GF_PropUIntList VAR_122;
			GF_PropStringList VAR_123;
			u32 VAR_124 = VAR_1->demuxer->nb_chapters;

			VAR_122.vals = gf_malloc(sizeof(u32)*VAR_124);
			VAR_123.vals = gf_malloc(sizeof(char *)*VAR_124);
			memset(VAR_123.vals, 0, sizeof(char *)*VAR_124);
			VAR_122.nb_items = VAR_123.nb_items = VAR_124;

			for (VAR_20=0; VAR_20<VAR_1->demuxer->nb_chapters; VAR_20++) {
				AVChapter *VAR_125 = VAR_1->demuxer->chapters[VAR_20];
				u64 VAR_126 = gf_timestamp_rescale(VAR_125->start * VAR_125->time_base.num, VAR_125->time_base.den, 1000);
				VAR_122.vals[VAR_20] = (u32) VAR_126;
				AVDictionaryEntry *VAR_127 = NULL;
				while (VAR_125->metadata) {
					VAR_127 = av_dict_get(VAR_125->metadata, """", VAR_127, VAR_128);
					if (!VAR_127) break;
					if (!strcmp(VAR_127->key, ""title"")) {
						VAR_123.vals[VAR_20] = gf_strdup(VAR_127->value);
					}
				}
				if (!VAR_123.vals[VAR_20]) VAR_123.vals[VAR_20] = gf_strdup(""Unknwon"");
			}
			VAR_121.type = VAR_129;
			VAR_121.value.uint_list = VAR_122;
			gf_filter_pid_set_property(VAR_18, VAR_130, &VAR_121);
			gf_free(VAR_122.vals);

			VAR_121.type = VAR_131;
			VAR_121.value.string_list = VAR_123;
			gf_filter_pid_set_property(VAR_18, VAR_132, &VAR_121);
			/* COMMENT_5 */
		}
	}

	if (!VAR_4 && !VAR_5 && !VAR_6)
		return VAR_133;

	return VAR_9;
}",gpac/671976fccc971b3dff8d3dcf6ebd600472ca64bf/ff_dmx.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -336,7 +336,7 @@
 		gf_filter_pid_set_property(pid, GF_PROP_PID_MUX_INDEX, &PROP_UINT(i+1));
 
 		for (j=0; j<(u32) stream->nb_side_data; j++) {
-			ffdmx_parse_side_data(&stream->side_data[i], pid);
+			ffdmx_parse_side_data(&stream->side_data[j], pid);
 		}
 
 		if (ctx->demuxer->nb_chapters) {","{'deleted_lines': ['\t\t\tffdmx_parse_side_data(&stream->side_data[i], pid);'], 'added_lines': ['\t\t\tffdmx_parse_side_data(&stream->side_data[j], pid);']}",True,GPAC 2.3-DEV-rev605-gfc9e29089-master contains a heap-buffer-overflow in ffdmx_parse_side_data /afltest/gpac/src/filters/ff_dmx.c:202:14 in gpac/MP4Box.,5.5,MEDIUM,1,test,2023-10-26T10:28:38Z,4
CVE-2023-48106,['CWE-787'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,zlib-ng/minizip-ng,"Fix for filenames of the form ""x/../y""

https://github.com/zlib-ng/minizip-ng/issues/740",3920698d13681c35f2daf929c1c7f70f12d2ab13,https://github.com/zlib-ng/minizip-ng/commit/3920698d13681c35f2daf929c1c7f70f12d2ab13,mz_os.c,mz_path_resolve,"int32_t mz_path_resolve(const char *path, char *output, int32_t max_output) {
const char *source = path;
const char *check = output;
char *target = output;
if (max_output <= 0)
return MZ_PARAM_ERROR;
while (*source != 0 && max_output > 1) {
check = source;
if ((*check == '\\') || (*check == '/'))
check += 1;
if ((source == path) || (target == output) || (check != source)) {
if ((*check == '\\') || (*check == '/')) {
source += 1;
continue;
}
if (*check == '.') {
check += 1;
if ((*check == 0) && (source != path && target != output)) {
*target = *source;
target += 1;
max_output -= 1;
source += (check - source);
continue;
}
else if ((*check == '\\') || (*check == '/')) {
source += (check - source);
if (target == output && *source != 0)
source += 1;
continue;
}
else if (*check == '.') {
check += 1;
if ((*check == 0) || (*check == '\\' || *check == '/')) {
source += (check - source);
if (target != output) {
target -= 1;
do {
if ((*target == '\\') || (*target == '/'))
break;
target -= 1;
max_output += 1;
} while (target > output);
}
if ((target == output) && (*source != 0))
source += 1;
if ((*target == '\\' || *target == '/') && (*source == 0))
target += 1;
*target = 0;
continue;
}
}
}
}
*target = *source;
source += 1;
target += 1;
max_output -= 1;
}
*target = 0;
if (*path == 0)
return MZ_INTERNAL_ERROR;
return MZ_OK;
}","int32_t mz_path_resolve(const char *VAR_0, char *VAR_1, int32_t VAR_2) {
const char *VAR_3 = VAR_0;
const char *VAR_4 = VAR_1;
char *VAR_5 = VAR_1;
if (VAR_2 <= 0)
return VAR_6;
while (*VAR_3 != 0 && VAR_2 > 1) {
VAR_4 = VAR_3;
if ((*VAR_4 == '\\') || (*VAR_4 == '/'))
VAR_4 += 1;
if ((VAR_3 == VAR_0) || (VAR_5 == VAR_1) || (VAR_4 != VAR_3)) {
if ((*VAR_4 == '\\') || (*VAR_4 == '/')) {
VAR_3 += 1;
continue;
}
if (*VAR_4 == '.') {
VAR_4 += 1;
if ((*VAR_4 == 0) && (VAR_3 != VAR_0 && VAR_5 != VAR_1)) {
*VAR_5 = *VAR_3;
VAR_5 += 1;
VAR_2 -= 1;
VAR_3 += (VAR_4 - VAR_3);
continue;
}
else if ((*VAR_4 == '\\') || (*VAR_4 == '/')) {
VAR_3 += (VAR_4 - VAR_3);
if (VAR_5 == VAR_1 && *VAR_3 != 0)
VAR_3 += 1;
continue;
}
else if (*VAR_4 == '.') {
VAR_4 += 1;
if ((*VAR_4 == 0) || (*VAR_4 == '\\' || *VAR_4 == '/')) {
VAR_3 += (VAR_4 - VAR_3);
if (VAR_5 != VAR_1) {
VAR_5 -= 1;
do {
if ((*VAR_5 == '\\') || (*VAR_5 == '/'))
break;
VAR_5 -= 1;
VAR_2 += 1;
} while (VAR_5 > VAR_1);
}
if ((VAR_5 == VAR_1) && (*VAR_3 != 0))
VAR_3 += 1;
if ((*VAR_5 == '\\' || *VAR_5 == '/') && (*VAR_3 == 0))
VAR_5 += 1;
*VAR_5 = 0;
continue;
}
}
}
}
*VAR_5 = *VAR_3;
VAR_3 += 1;
VAR_5 += 1;
VAR_2 -= 1;
}
*VAR_5 = 0;
if (*VAR_0 == 0)
return VAR_7;
return VAR_8;
}",zlib-ng/minizip-ng/3920698d13681c35f2daf929c1c7f70f12d2ab13/mz_os.c/vul/before/0.json,"int32_t mz_path_resolve(const char *path, char *output, int32_t max_output) {
    const char *source = path;
    const char *check = output;
    char *target = output;

    if (max_output <= 0)
        return MZ_PARAM_ERROR;

    while (*source != 0 && max_output > 1) {
        check = source;
        if ((*check == '\\') || (*check == '/'))
            check += 1;

        if ((source == path) || (target == output) || (check != source)) {
            /* Skip double paths */
            if ((*check == '\\') || (*check == '/')) {
                source += 1;
                continue;
            }
            if (*check == '.') {
                check += 1;

                /* Remove . if at end of string and not at the beginning */
                if ((*check == 0) && (source != path && target != output)) {
                    /* Copy last slash */
                    *target = *source;
                    target += 1;
                    max_output -= 1;
                    source += (check - source);
                    continue;
                }
                /* Remove . if not at end of string */
                else if ((*check == '\\') || (*check == '/')) {
                    source += (check - source);
                    /* Skip slash if at beginning of string */
                    if (target == output && *source != 0)
                        source += 1;
                    continue;
                }
                /* Go to parent directory .. */
                else if (*check == '.') {
                    check += 1;
                    if ((*check == 0) || (*check == '\\' || *check == '/')) {
                        source += (check - source);

                        /* Search backwards for previous slash or the start of the output string */
                        if (target != output) {
                            target -= 1;
                            do {
                                if ((target == output) ||(*target == '\\') || (*target == '/'))
                                    break;

                                target -= 1;
                                max_output += 1;
                            } while (target > output);
                        }

                        if ((target == output) && (*source != 0))
                            source += 1;
                        if ((*target == '\\' || *target == '/') && (*source == 0))
                            target += 1;

                        *target = 0;
                        continue;
                    }
                }
            }
        }

        *target = *source;

        source += 1;
        target += 1;
        max_output -= 1;
    }

    *target = 0;

    if (*path == 0)
        return MZ_INTERNAL_ERROR;

    return MZ_OK;
}","int32_t mz_path_resolve(const char *VAR_0, char *VAR_1, int32_t VAR_2) {
    const char *VAR_3 = VAR_0;
    const char *VAR_4 = VAR_1;
    char *VAR_5 = VAR_1;

    if (VAR_2 <= 0)
        return VAR_6;

    while (*VAR_3 != 0 && VAR_2 > 1) {
        VAR_4 = VAR_3;
        if ((*VAR_4 == '\\') || (*VAR_4 == '/'))
            VAR_4 += 1;

        if ((VAR_3 == VAR_0) || (VAR_5 == VAR_1) || (VAR_4 != VAR_3)) {
            /* COMMENT_0 */
            if ((*VAR_4 == '\\') || (*VAR_4 == '/')) {
                VAR_3 += 1;
                continue;
            }
            if (*VAR_4 == '.') {
                VAR_4 += 1;

                /* COMMENT_1 */
                if ((*VAR_4 == 0) && (VAR_3 != VAR_0 && VAR_5 != VAR_1)) {
                    /* COMMENT_2 */
                    *VAR_5 = *VAR_3;
                    VAR_5 += 1;
                    VAR_2 -= 1;
                    VAR_3 += (VAR_4 - VAR_3);
                    continue;
                }
                /* COMMENT_3 */
                else if ((*VAR_4 == '\\') || (*VAR_4 == '/')) {
                    VAR_3 += (VAR_4 - VAR_3);
                    /* COMMENT_4 */
                    if (VAR_5 == VAR_1 && *VAR_3 != 0)
                        VAR_3 += 1;
                    continue;
                }
                /* COMMENT_5 */
                else if (*VAR_4 == '.') {
                    VAR_4 += 1;
                    if ((*VAR_4 == 0) || (*VAR_4 == '\\' || *VAR_4 == '/')) {
                        VAR_3 += (VAR_4 - VAR_3);

                        /* COMMENT_6 */
                        if (VAR_5 != VAR_1) {
                            VAR_5 -= 1;
                            do {
                                if ((VAR_5 == VAR_1) ||(*VAR_5 == '\\') || (*VAR_5 == '/'))
                                    break;

                                VAR_5 -= 1;
                                VAR_2 += 1;
                            } while (VAR_5 > VAR_1);
                        }

                        if ((VAR_5 == VAR_1) && (*VAR_3 != 0))
                            VAR_3 += 1;
                        if ((*VAR_5 == '\\' || *VAR_5 == '/') && (*VAR_3 == 0))
                            VAR_5 += 1;

                        *VAR_5 = 0;
                        continue;
                    }
                }
            }
        }

        *VAR_5 = *VAR_3;

        VAR_3 += 1;
        VAR_5 += 1;
        VAR_2 -= 1;
    }

    *VAR_5 = 0;

    if (*VAR_0 == 0)
        return VAR_7;

    return VAR_8;
}",zlib-ng/minizip-ng/3920698d13681c35f2daf929c1c7f70f12d2ab13/mz_os.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -43,11 +43,11 @@
                     if ((*check == 0) || (*check == '\\' || *check == '/')) {
                         source += (check - source);
 
-                        /* Search backwards for previous slash */
+                        /* Search backwards for previous slash or the start of the output string */
                         if (target != output) {
                             target -= 1;
                             do {
-                                if ((*target == '\\') || (*target == '/'))
+                                if ((target == output) ||(*target == '\\') || (*target == '/'))
                                     break;
 
                                 target -= 1;","{'deleted_lines': ['                        /* Search backwards for previous slash */', ""                                if ((*target == '\\\\') || (*target == '/'))""], 'added_lines': ['                        /* Search backwards for previous slash or the start of the output string */', ""                                if ((target == output) ||(*target == '\\\\') || (*target == '/'))""]}",True,Buffer Overflow vulnerability in zlib-ng minizip-ng v.4.0.2 allows an attacker to execute arbitrary code via a crafted file to the mz_path_resolve function in the mz_os.c file.,8.8,HIGH,2,test,2023-11-12T20:43:27Z,4
CVE-2023-48947,['CWE-Other'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,openlink/virtuoso-opensource,"Fixed issue with chash (fixes #1179)

chash does not work on union where branche has const, use memhash instead",36e7592269366e8f0e3637e5ddb828ed5363ccbe,https://github.com/openlink/virtuoso-opensource/commit/36e7592269366e8f0e3637e5ddb828ed5363ccbe,libsrc/Wi/chash.c,setp_chash_distinct,"int
setp_chash_distinct (setp_node_t * setp, caddr_t * inst)
{
index_tree_t *tree;
hash_area_t *ha = setp->setp_ha;
int inx, n_slots = BOX_ELEMENTS (ha->ha_slots);
data_col_t *sets = QST_BOX (data_col_t *, inst, setp->setp_ssa.ssa_set_no->ssl_index);
chash_t *cha = NULL;
QNCAST (query_instance_t, qi, inst);
if (!enable_chash_distinct || (!cluster_enable && !setp->setp_set_no_in_key && 1 != sets->dc_n_values))
return 0;
qi->qi_set = 0;
tree = qst_tree (inst, ha->ha_tree, setp->setp_ssa.ssa_set_no);
if (tree)
{
cha = tree->it_hi->hi_chash;
if (!cha)
return 0;
}
if (cha && cha->cha_oversized)
goto no;
if (ha->ha_n_keys >= CHASH_GB_MAX_KEYS)
goto no;
for (inx = 0; inx < n_slots; inx++)
{
state_slot_t *ssl = ha->ha_slots[inx];
data_col_t *dc;
if (SSL_CONSTANT == ssl->ssl_type)
{
if (inx < ha->ha_n_keys)
goto no;
continue;
}
if (ssl->ssl_type < SSL_VEC)
goto no;
dc = QST_BOX (data_col_t *, inst, ssl->ssl_index);
if (cha && inx < cha->cha_n_keys && dc->dc_dtp != cha->cha_sqt[inx].sqt_dtp
&& !((DCT_BOXES & dc->dc_type) && DV_ANY == cha->cha_sqt[inx].sqt_dtp))
goto no;
}
if (!cha)
{
tree = cha_allocate (setp, inst, 0);
cha = tree->it_hi->hi_chash;
}
setp_chash_distinct_run (setp, inst, tree);
if (cha->cha_pool->mp_bytes > cha_max_gb_bytes && (cha->cha_pool->mp_bytes + mp_large_in_use) > c_max_large_vec)
cha->cha_oversized = 1;
return 1;
no:
if (cha)
chash_to_memcache (inst, tree, ha);
return 0;
}","int
setp_chash_distinct (setp_node_t * VAR_0, caddr_t * VAR_1)
{
index_tree_t *VAR_2;
hash_area_t *VAR_3 = VAR_0->setp_ha;
int VAR_4, VAR_5 = BOX_ELEMENTS (VAR_3->ha_slots);
data_col_t *VAR_6 = QST_BOX (data_col_t *, VAR_1, VAR_0->setp_ssa.ssa_set_no->ssl_index);
chash_t *VAR_7 = NULL;
QNCAST (VAR_8, VAR_9, VAR_1);
if (!VAR_10 || (!VAR_11 && !VAR_0->setp_set_no_in_key && 1 != VAR_6->dc_n_values))
return 0;
VAR_9->qi_set = 0;
VAR_2 = qst_tree (VAR_1, VAR_3->ha_tree, VAR_0->setp_ssa.ssa_set_no);
if (VAR_2)
{
VAR_7 = VAR_2->it_hi->hi_chash;
if (!VAR_7)
return 0;
}
if (VAR_7 && VAR_7->cha_oversized)
goto no;
if (VAR_3->ha_n_keys >= VAR_12)
goto no;
for (VAR_4 = 0; VAR_4 < VAR_5; VAR_4++)
{
state_slot_t *VAR_13 = VAR_3->ha_slots[VAR_4];
data_col_t *VAR_14;
if (VAR_15 == VAR_13->ssl_type)
{
if (VAR_4 < VAR_3->ha_n_keys)
goto no;
continue;
}
if (VAR_13->ssl_type < VAR_16)
goto no;
VAR_14 = QST_BOX (data_col_t *, VAR_1, VAR_13->ssl_index);
if (VAR_7 && VAR_4 < VAR_7->cha_n_keys && VAR_14->dc_dtp != VAR_7->cha_sqt[VAR_4].sqt_dtp
&& !((VAR_17 & VAR_14->dc_type) && VAR_18 == VAR_7->cha_sqt[VAR_4].sqt_dtp))
goto no;
}
if (!VAR_7)
{
VAR_2 = cha_allocate (VAR_0, VAR_1, 0);
VAR_7 = VAR_2->it_hi->hi_chash;
}
setp_chash_distinct_run (VAR_0, VAR_1, VAR_2);
if (VAR_7->cha_pool->mp_bytes > VAR_19 && (VAR_7->cha_pool->mp_bytes + VAR_20) > VAR_21)
VAR_7->cha_oversized = 1;
return 1;
no:
if (VAR_7)
chash_to_memcache (VAR_1, VAR_2, VAR_3);
return 0;
}",openlink/virtuoso-opensource/36e7592269366e8f0e3637e5ddb828ed5363ccbe/chash.c/vul/before/0.json,"int
setp_chash_distinct (setp_node_t * setp, caddr_t * inst)
{
  index_tree_t *tree;
  hash_area_t *ha = setp->setp_ha;
  int inx, n_slots = BOX_ELEMENTS (ha->ha_slots);
  data_col_t *sets = QST_BOX (data_col_t *, inst, setp->setp_ssa.ssa_set_no->ssl_index);
  chash_t *cha = NULL;
  QNCAST (query_instance_t, qi, inst);

  if (!enable_chash_distinct || (!cluster_enable && !setp->setp_set_no_in_key && 1 != sets->dc_n_values))
    return 0;
  qi->qi_set = 0;
  tree = qst_tree (inst, ha->ha_tree, setp->setp_ssa.ssa_set_no);
  if (tree)
    {
      cha = tree->it_hi->hi_chash;
      if (!cha)
	return 0;
    }
  if (cha && cha->cha_n_keys != ha->ha_n_keys)
    goto no;
  if (cha && cha->cha_oversized)
    goto no;
  if (ha->ha_n_keys >= CHASH_GB_MAX_KEYS)
    goto no;
  for (inx = 0; inx < n_slots; inx++)
    {
      state_slot_t *ssl = ha->ha_slots[inx];
      data_col_t *dc;
      if (SSL_CONSTANT == ssl->ssl_type)
	{
	  if (inx < ha->ha_n_keys)
	    goto no;
	  continue;
	}
      if (ssl->ssl_type < SSL_VEC)
	goto no;
      dc = QST_BOX (data_col_t *, inst, ssl->ssl_index);
      if (cha && inx < cha->cha_n_keys && dc->dc_dtp != cha->cha_sqt[inx].sqt_dtp
	  && !((DCT_BOXES & dc->dc_type) && DV_ANY == cha->cha_sqt[inx].sqt_dtp))
	goto no;
    }
  if (!cha)
    {
      tree = cha_allocate (setp, inst, 0);
      cha = tree->it_hi->hi_chash;
    }
  setp_chash_distinct_run (setp, inst, tree);
  if (cha->cha_pool->mp_bytes > cha_max_gb_bytes && (cha->cha_pool->mp_bytes + mp_large_in_use) > c_max_large_vec)
    cha->cha_oversized = 1;
  return 1;
no:
  if (cha)
    chash_to_memcache (inst, tree, ha);
  return 0;
}","int
setp_chash_distinct (setp_node_t * VAR_0, caddr_t * VAR_1)
{
  index_tree_t *VAR_2;
  hash_area_t *VAR_3 = VAR_0->setp_ha;
  int VAR_4, VAR_5 = BOX_ELEMENTS (VAR_3->ha_slots);
  data_col_t *VAR_6 = QST_BOX (data_col_t *, VAR_1, VAR_0->setp_ssa.ssa_set_no->ssl_index);
  chash_t *VAR_7 = NULL;
  QNCAST (VAR_8, VAR_9, VAR_1);

  if (!VAR_10 || (!VAR_11 && !VAR_0->setp_set_no_in_key && 1 != VAR_6->dc_n_values))
    return 0;
  VAR_9->qi_set = 0;
  VAR_2 = qst_tree (VAR_1, VAR_3->ha_tree, VAR_0->setp_ssa.ssa_set_no);
  if (VAR_2)
    {
      VAR_7 = VAR_2->it_hi->hi_chash;
      if (!VAR_7)
	return 0;
    }
  if (VAR_7 && VAR_7->cha_n_keys != VAR_3->ha_n_keys)
    goto no;
  if (VAR_7 && VAR_7->cha_oversized)
    goto no;
  if (VAR_3->ha_n_keys >= VAR_12)
    goto no;
  for (VAR_4 = 0; VAR_4 < VAR_5; VAR_4++)
    {
      state_slot_t *VAR_13 = VAR_3->ha_slots[VAR_4];
      data_col_t *VAR_14;
      if (VAR_15 == VAR_13->ssl_type)
	{
	  if (VAR_4 < VAR_3->ha_n_keys)
	    goto no;
	  continue;
	}
      if (VAR_13->ssl_type < VAR_16)
	goto no;
      VAR_14 = QST_BOX (data_col_t *, VAR_1, VAR_13->ssl_index);
      if (VAR_7 && VAR_4 < VAR_7->cha_n_keys && VAR_14->dc_dtp != VAR_7->cha_sqt[VAR_4].sqt_dtp
	  && !((VAR_17 & VAR_14->dc_type) && VAR_18 == VAR_7->cha_sqt[VAR_4].sqt_dtp))
	goto no;
    }
  if (!VAR_7)
    {
      VAR_2 = cha_allocate (VAR_0, VAR_1, 0);
      VAR_7 = VAR_2->it_hi->hi_chash;
    }
  setp_chash_distinct_run (VAR_0, VAR_1, VAR_2);
  if (VAR_7->cha_pool->mp_bytes > VAR_19 && (VAR_7->cha_pool->mp_bytes + VAR_20) > VAR_21)
    VAR_7->cha_oversized = 1;
  return 1;
no:
  if (VAR_7)
    chash_to_memcache (VAR_1, VAR_2, VAR_3);
  return 0;
}",openlink/virtuoso-opensource/36e7592269366e8f0e3637e5ddb828ed5363ccbe/chash.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -18,6 +18,8 @@
       if (!cha)
 	return 0;
     }
+  if (cha && cha->cha_n_keys != ha->ha_n_keys)
+    goto no;
   if (cha && cha->cha_oversized)
     goto no;
   if (ha->ha_n_keys >= CHASH_GB_MAX_KEYS)","{'deleted_lines': [], 'added_lines': ['  if (cha && cha->cha_n_keys != ha->ha_n_keys)', '    goto no;']}",True,An issue in the cha_cmp function of openlink virtuoso-opensource v7.2.11 allows attackers to cause a Denial of Service (DoS) after running a SELECT statement.,7.5,HIGH,2,test,2023-11-16T15:40:00Z,4
CVE-2023-7158,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,micropython,"py/objslice: Validate that the argument to indices() is an integer.

Otherwise passing in a non-integer can lead to an invalid memory access.

Thanks to Junwha Hong and Wonil Jang @S2Lab, UNIST for finding the issue.

Fixes issue #13007.

Signed-off-by: Damien George <damien@micropython.org>",f397a3ec318f3ad05aa287764ae7cef32202380f,https://github.com/micropython/micropython/commit/f397a3ec318f3ad05aa287764ae7cef32202380f,py/objslice.c,slice_indices,"STATIC mp_obj_t slice_indices(mp_obj_t self_in, mp_obj_t length_obj) {
mp_int_t length = mp_obj_int_get_checked(length_obj);
mp_bound_slice_t bound_indices;
mp_obj_slice_indices(self_in, length, &bound_indices);
mp_obj_t results[3] = {
MP_OBJ_NEW_SMALL_INT(bound_indices.start),
MP_OBJ_NEW_SMALL_INT(bound_indices.stop),
MP_OBJ_NEW_SMALL_INT(bound_indices.step),
};
return mp_obj_new_tuple(3, results);
}","STATIC VAR_0 slice_indices(mp_obj_t VAR_1, mp_obj_t VAR_2) {
mp_int_t VAR_3 = mp_obj_int_get_checked(VAR_2);
mp_bound_slice_t VAR_4;
mp_obj_slice_indices(VAR_1, VAR_3, &VAR_4);
mp_obj_t VAR_5[3] = {
MP_OBJ_NEW_SMALL_INT(VAR_4.start),
MP_OBJ_NEW_SMALL_INT(VAR_4.stop),
MP_OBJ_NEW_SMALL_INT(VAR_4.step),
};
return mp_obj_new_tuple(3, VAR_5);
}",,"STATIC mp_obj_t slice_indices(mp_obj_t self_in, mp_obj_t length_obj) {
    mp_int_t length = mp_obj_get_int(length_obj);
    mp_bound_slice_t bound_indices;
    mp_obj_slice_indices(self_in, length, &bound_indices);

    mp_obj_t results[3] = {
        MP_OBJ_NEW_SMALL_INT(bound_indices.start),
        MP_OBJ_NEW_SMALL_INT(bound_indices.stop),
        MP_OBJ_NEW_SMALL_INT(bound_indices.step),
    };
    return mp_obj_new_tuple(3, results);
}","STATIC VAR_0 slice_indices(mp_obj_t VAR_1, mp_obj_t VAR_2) {
    mp_int_t VAR_3 = mp_obj_get_int(VAR_2);
    mp_bound_slice_t VAR_4;
    mp_obj_slice_indices(VAR_1, VAR_3, &VAR_4);

    mp_obj_t VAR_5[3] = {
        MP_OBJ_NEW_SMALL_INT(VAR_4.start),
        MP_OBJ_NEW_SMALL_INT(VAR_4.stop),
        MP_OBJ_NEW_SMALL_INT(VAR_4.step),
    };
    return mp_obj_new_tuple(3, VAR_5);
}",,"--- func_before
+++ func_after
@@ -1,5 +1,5 @@
 STATIC mp_obj_t slice_indices(mp_obj_t self_in, mp_obj_t length_obj) {
-    mp_int_t length = mp_obj_int_get_checked(length_obj);
+    mp_int_t length = mp_obj_get_int(length_obj);
     mp_bound_slice_t bound_indices;
     mp_obj_slice_indices(self_in, length, &bound_indices);
 ","{'deleted_lines': ['    mp_int_t length = mp_obj_int_get_checked(length_obj);'], 'added_lines': ['    mp_int_t length = mp_obj_get_int(length_obj);']}",True,A vulnerability was found in MicroPython up to 1.21.0. It has been classified as critical. Affected is the function slice_indices of the file objslice.c. The manipulation leads to heap-based buffer overflow. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used. Upgrading to version 1.22.0 is able to address this issue. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-249180.,9.8,CRITICAL,3,test,2023-11-21T11:28:57Z,4
CVE-2023-31922,['CWE-787'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,bellard/quickjs,fixed js_proxy_isArray stack overflow (github issue #178),03cc5ecc88f8534a5db5c911df4b712a21d08fb8,https://github.com/bellard/quickjs/commit/03cc5ecc88f8534a5db5c911df4b712a21d08fb8,quickjs.c,js_proxy_isArray,"static int js_proxy_isArray(JSContext *ctx, JSValueConst obj)
{
JSProxyData *s = JS_GetOpaque(obj, JS_CLASS_PROXY);
if (!s)
return FALSE;
if (s->is_revoked) {
JS_ThrowTypeErrorRevokedProxy(ctx);
return -1;
}
return JS_IsArray(ctx, s->target);
}","static int js_proxy_isArray(JSContext *VAR_0, JSValueConst VAR_1)
{
JSProxyData *VAR_2 = JS_GetOpaque(VAR_1, VAR_3);
if (!VAR_2)
return FALSE;
if (VAR_2->is_revoked) {
JS_ThrowTypeErrorRevokedProxy(VAR_0);
return -1;
}
return JS_IsArray(VAR_0, VAR_2->target);
}",bellard/quickjs/03cc5ecc88f8534a5db5c911df4b712a21d08fb8/quickjs.c/vul/before/0.json,"static int js_proxy_isArray(JSContext *ctx, JSValueConst obj)
{
    JSProxyData *s = JS_GetOpaque(obj, JS_CLASS_PROXY);
    if (!s)
        return FALSE;
    if (js_check_stack_overflow(ctx->rt, 0)) {
        JS_ThrowStackOverflow(ctx);
        return -1;
    }
    if (s->is_revoked) {
        JS_ThrowTypeErrorRevokedProxy(ctx);
        return -1;
    }
    return JS_IsArray(ctx, s->target);
}","static int js_proxy_isArray(JSContext *VAR_0, JSValueConst VAR_1)
{
    JSProxyData *VAR_2 = JS_GetOpaque(VAR_1, VAR_3);
    if (!VAR_2)
        return FALSE;
    if (js_check_stack_overflow(VAR_0->rt, 0)) {
        JS_ThrowStackOverflow(VAR_0);
        return -1;
    }
    if (VAR_2->is_revoked) {
        JS_ThrowTypeErrorRevokedProxy(VAR_0);
        return -1;
    }
    return JS_IsArray(VAR_0, VAR_2->target);
}",bellard/quickjs/03cc5ecc88f8534a5db5c911df4b712a21d08fb8/quickjs.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,6 +3,10 @@
     JSProxyData *s = JS_GetOpaque(obj, JS_CLASS_PROXY);
     if (!s)
         return FALSE;
+    if (js_check_stack_overflow(ctx->rt, 0)) {
+        JS_ThrowStackOverflow(ctx);
+        return -1;
+    }
     if (s->is_revoked) {
         JS_ThrowTypeErrorRevokedProxy(ctx);
         return -1;","{'deleted_lines': [], 'added_lines': ['    if (js_check_stack_overflow(ctx->rt, 0)) {', '        JS_ThrowStackOverflow(ctx);', '        return -1;', '    }']}",True,QuickJS commit 2788d71 was discovered to contain a stack-overflow via the component js_proxy_isArray at quickjs.c.,7.5,HIGH,2,test,2023-12-01T17:15:03Z,4
CVE-2023-49284,['CWE-436'],CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:U/C:H/I:N/A:H,1,fish-shell,Encode all ENCODE_DIRECT codepoints with encode_direct,09986f5563e31e2c900a606438f1d60d008f3a14,https://github.com/fish-shell/fish-shell/commit/09986f5563e31e2c900a606438f1d60d008f3a14,src/common.cpp,str2wcs_internal,"static wcstring str2wcs_internal(const char *in, const size_t in_len) {
if (in_len == 0) return wcstring();
assert(in != nullptr);
wcstring result;
result.reserve(in_len);
size_t in_pos = 0;
mbstate_t state = {};
while (in_pos < in_len) {
size_t ascii_prefix_length = count_ascii_prefix(&in[in_pos], in_len - in_pos);
result.insert(result.end(), &in[in_pos], &in[in_pos + ascii_prefix_length]);
in_pos += ascii_prefix_length;
assert(in_pos <= in_len && ""Position overflowed length"");
if (in_pos == in_len) break;
bool use_encode_direct = false;
size_t ret = 0;
wchar_t wc = 0;
if (false) {
#if defined(HAVE_BROKEN_MBRTOWC_UTF8)
} else if ((in[in_pos] & 0xF8) == 0xF8) {
use_encode_direct = true;
#endif
} else if (sizeof(wchar_t) == 2 &&                     (in[in_pos] & 0xF8) == 0xF0) {
use_encode_direct = true;
} else {
ret = std::mbrtowc(&wc, &in[in_pos], in_len - in_pos, &state);
if (wc >= ENCODE_DIRECT_BASE && wc < ENCODE_DIRECT_BASE + 256) {
use_encode_direct = true;
} else if (wc == INTERNAL_SEPARATOR) {
use_encode_direct = true;
} else if (ret == static_cast<size_t>(-2)) {
use_encode_direct = true;
} else if (ret == static_cast<size_t>(-1)) {
use_encode_direct = true;
} else if (ret > in_len - in_pos) {
use_encode_direct = true;
} else if (sizeof(wchar_t) == 2 && wc >= 0xD800 &&                         wc <= 0xDFFF) {
use_encode_direct = true;
}
}
if (use_encode_direct) {
wc = ENCODE_DIRECT_BASE + static_cast<unsigned char>(in[in_pos]);
result.push_back(wc);
in_pos++;
std::memset(&state, 0, sizeof state);
} else if (ret == 0) {              result.push_back(L'\0');
in_pos++;
std::memset(&state, 0, sizeof state);
} else {              result.push_back(wc);
in_pos += ret;
}
}
return result;
}","static wcstring str2wcs_internal(const char *VAR_0, const size_t VAR_1) {
if (VAR_1 == 0) return wcstring();
assert(VAR_0 != nullptr);
wcstring VAR_2;
VAR_2.reserve(VAR_1);
size_t VAR_3 = 0;
mbstate_t VAR_4 = {};
while (VAR_3 < VAR_1) {
size_t VAR_5 = count_ascii_prefix(&VAR_0[VAR_3], VAR_1 - VAR_3);
VAR_2.insert(VAR_2.end(), &VAR_0[VAR_3], &VAR_0[VAR_3 + VAR_5]);
VAR_3 += VAR_5;
assert(VAR_3 <= VAR_1 && ""Position overflowed length"");
if (VAR_3 == VAR_1) break;
bool VAR_6 = false;
size_t VAR_7 = 0;
wchar_t VAR_8 = 0;
if (false) {
#if defined(VAR_9)
} else if ((VAR_0[VAR_3] & 0xF8) == 0xF8) {
VAR_6 = true;
#endif
} else if (sizeof(wchar_t) == 2 &&  //!OCLINT(constant if expression)
(VAR_0[VAR_3] & 0xF8) == 0xF0) {
VAR_6 = true;
} else {
VAR_7 = std::mbrtowc(&VAR_8, &VAR_0[VAR_3], VAR_1 - VAR_3, &VAR_4);
if (VAR_8 >= VAR_10 && VAR_8 < VAR_10 + 256) {
VAR_6 = true;
} else if (VAR_8 == VAR_11) {
VAR_6 = true;
} else if (VAR_7 == VAR_12<size_t>(-2)) {
VAR_6 = true;
} else if (VAR_7 == VAR_12<size_t>(-1)) {
VAR_6 = true;
} else if (VAR_7 > VAR_1 - VAR_3) {
VAR_6 = true;
} else if (sizeof(wchar_t) == 2 && VAR_8 >= 0xD800 &&  
VAR_8 <= 0xDFFF) {
VAR_6 = true;
}
}
if (VAR_6) {
VAR_8 = VAR_10 + VAR_12<unsigned char>(VAR_0[VAR_3]);
VAR_2.push_back(VAR_8);
VAR_3++;
std::memset(&VAR_4, 0, sizeof VAR_4);
} else if (VAR_7 == 0) {  
VAR_2.push_back(L'\0');
VAR_3++;
std::memset(&VAR_4, 0, sizeof VAR_4);
} else {  
VAR_2.push_back(VAR_8);
VAR_3 += VAR_7;
}
}
return VAR_2;
}",fish-shell/09986f5563e31e2c900a606438f1d60d008f3a14/common.cpp/vul/before/0.json,"static wcstring str2wcs_internal(const char *in, const size_t in_len) {
    if (in_len == 0) return wcstring();
    assert(in != nullptr);

    wcstring result;
    result.reserve(in_len);

    size_t in_pos = 0;
    mbstate_t state = {};
    while (in_pos < in_len) {
        // Append any initial sequence of ascii characters.
        // Note we do not support character sets which are not supersets of ASCII.
        size_t ascii_prefix_length = count_ascii_prefix(&in[in_pos], in_len - in_pos);
        result.insert(result.end(), &in[in_pos], &in[in_pos + ascii_prefix_length]);
        in_pos += ascii_prefix_length;
        assert(in_pos <= in_len && ""Position overflowed length"");
        if (in_pos == in_len) break;

        // We have found a non-ASCII character.
        bool use_encode_direct = false;
        size_t ret = 0;
        wchar_t wc = 0;

        if (false) {
#if defined(HAVE_BROKEN_MBRTOWC_UTF8)
        } else if ((in[in_pos] & 0xF8) == 0xF8) {
            // Protect against broken std::mbrtowc() implementations which attempt to encode UTF-8
            // sequences longer than four bytes (e.g., OS X Snow Leopard).
            use_encode_direct = true;
#endif
        } else if (sizeof(wchar_t) == 2 &&  //!OCLINT(constant if expression)
                   (in[in_pos] & 0xF8) == 0xF0) {
            // Assume we are in a UTF-16 environment (e.g., Cygwin) using a UTF-8 encoding.
            // The bits set check will be true for a four byte UTF-8 sequence that requires
            // two UTF-16 chars. Something that doesn't work with our simple use of std::mbrtowc().
            use_encode_direct = true;
        } else {
            ret = std::mbrtowc(&wc, &in[in_pos], in_len - in_pos, &state);
            // Determine whether to encode this character with our crazy scheme.
            if (fish_reserved_codepoint(wc)) {
                use_encode_direct = true;
            } else if (ret == static_cast<size_t>(-2)) {
                // Incomplete sequence.
                use_encode_direct = true;
            } else if (ret == static_cast<size_t>(-1)) {
                // Invalid data.
                use_encode_direct = true;
            } else if (ret > in_len - in_pos) {
                // Other error codes? Terrifying, should never happen.
                use_encode_direct = true;
            } else if (sizeof(wchar_t) == 2 && wc >= 0xD800 &&  //!OCLINT(constant if expression)
                       wc <= 0xDFFF) {
                // If we get a surrogate pair char on a UTF-16 system (e.g., Cygwin) then
                // it's guaranteed the UTF-8 decoding is wrong so use direct encoding.
                use_encode_direct = true;
            }
        }

        if (use_encode_direct) {
            wc = ENCODE_DIRECT_BASE + static_cast<unsigned char>(in[in_pos]);
            result.push_back(wc);
            in_pos++;
            std::memset(&state, 0, sizeof state);
        } else if (ret == 0) {  // embedded null byte!
            result.push_back(L'\0');
            in_pos++;
            std::memset(&state, 0, sizeof state);
        } else {  // normal case
            result.push_back(wc);
            in_pos += ret;
        }
    }

    return result;
}","static wcstring str2wcs_internal(const char *VAR_0, const size_t VAR_1) {
    if (VAR_1 == 0) return wcstring();
    assert(VAR_0 != nullptr);

    wcstring VAR_2;
    VAR_2.reserve(VAR_1);

    size_t VAR_3 = 0;
    mbstate_t VAR_4 = {};
    while (VAR_3 < VAR_1) {
        /* COMMENT_0 */
        /* COMMENT_1 */
        size_t VAR_5 = count_ascii_prefix(&VAR_0[VAR_3], VAR_1 - VAR_3);
        VAR_2.insert(VAR_2.end(), &VAR_0[VAR_3], &VAR_0[VAR_3 + VAR_5]);
        VAR_3 += VAR_5;
        assert(VAR_3 <= VAR_1 && ""Position overflowed length"");
        if (VAR_3 == VAR_1) break;

        /* COMMENT_2 */
        bool VAR_6 = false;
        size_t VAR_7 = 0;
        wchar_t VAR_8 = 0;

        if (false) {
#if defined(VAR_9)
        } else if ((VAR_0[VAR_3] & 0xF8) == 0xF8) {
            /* COMMENT_3 */
            /* COMMENT_4 */
            VAR_6 = true;
#endif
        } else if (sizeof(wchar_t) == 2 &&  //!OCLINT(constant if expression)
                   (VAR_0[VAR_3] & 0xF8) == 0xF0) {
            /* COMMENT_5 */
            /* COMMENT_6 */
            /* COMMENT_7 */
            VAR_6 = true;
        } else {
            VAR_7 = std::mbrtowc(&VAR_8, &VAR_0[VAR_3], VAR_1 - VAR_3, &VAR_4);
            /* COMMENT_8 */
            if (fish_reserved_codepoint(VAR_8)) {
                VAR_6 = true;
            } else if (VAR_7 == VAR_10<size_t>(-2)) {
                /* COMMENT_9 */
                VAR_6 = true;
            } else if (VAR_7 == VAR_10<size_t>(-1)) {
                /* COMMENT_10 */
                VAR_6 = true;
            } else if (VAR_7 > VAR_1 - VAR_3) {
                /* COMMENT_11 */
                VAR_6 = true;
            } else if (sizeof(wchar_t) == 2 && VAR_8 >= 0xD800 &&  /* COMMENT_12 */
                       VAR_8 <= 0xDFFF) {
                /* COMMENT_13 */
                /* COMMENT_14 */
                VAR_6 = true;
            }
        }

        if (VAR_6) {
            VAR_8 = VAR_11 + VAR_10<unsigned char>(VAR_0[VAR_3]);
            VAR_2.push_back(VAR_8);
            VAR_3++;
            std::memset(&VAR_4, 0, sizeof VAR_4);
        } else if (VAR_7 == 0) {  /* COMMENT_15 */
            VAR_2.push_back(L'\0');
            VAR_3++;
            std::memset(&VAR_4, 0, sizeof VAR_4);
        } else {  /* COMMENT_16 */
            VAR_2.push_back(VAR_8);
            VAR_3 += VAR_7;
        }
    }

    return VAR_2;
}",fish-shell/09986f5563e31e2c900a606438f1d60d008f3a14/common.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -37,9 +37,7 @@
         } else {
             ret = std::mbrtowc(&wc, &in[in_pos], in_len - in_pos, &state);
             // Determine whether to encode this character with our crazy scheme.
-            if (wc >= ENCODE_DIRECT_BASE && wc < ENCODE_DIRECT_BASE + 256) {
-                use_encode_direct = true;
-            } else if (wc == INTERNAL_SEPARATOR) {
+            if (fish_reserved_codepoint(wc)) {
                 use_encode_direct = true;
             } else if (ret == static_cast<size_t>(-2)) {
                 // Incomplete sequence.","{'deleted_lines': ['            if (wc >= ENCODE_DIRECT_BASE && wc < ENCODE_DIRECT_BASE + 256) {', '                use_encode_direct = true;', '            } else if (wc == INTERNAL_SEPARATOR) {'], 'added_lines': ['            if (fish_reserved_codepoint(wc)) {']}",True,"fish is a smart and user-friendly command line shell for macOS, Linux, and the rest of the family. fish shell uses certain Unicode non-characters internally for marking wildcards and expansions. It will incorrectly allow these markers to be read on command substitution output, rather than transforming them into a safe internal representation. While this may cause unexpected behavior with direct input (for example, echo \UFDD2HOME has the same output as echo $HOME), this may become a minor security problem if the output is being fed from an external program into a command substitution where this output may not be expected. This design flaw was introduced in very early versions of fish, predating the version control system, and is thought to be present in every version of fish released in the last 15 years or more, although with different characters. Code execution does not appear to be possible, but denial of service (through large brace expansion) or information disclosure (such as variable expansion) is potentially possible under certain circumstances. fish shell 3.6.2 has been released to correct this issue. Users are advised to upgrade. There are no known workarounds for this vulnerability.",3.9,LOW,0,test,2023-12-02T10:06:07Z,4
CVE-2023-49284,['CWE-436'],CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:U/C:H/I:N/A:H,1,fish-shell,Encode all ENCODE_DIRECT codepoints with encode_direct,09986f5563e31e2c900a606438f1d60d008f3a14,https://github.com/fish-shell/fish-shell/commit/09986f5563e31e2c900a606438f1d60d008f3a14,src/common.cpp,read_unquoted_escape,"maybe_t<size_t> read_unquoted_escape(const wchar_t *input, wcstring *result, bool allow_incomplete,
bool unescape_special) {
assert(input[0] == L'\\' && ""Not an escape"");
maybe_t<wchar_t> result_char_or_none = none();
bool errored = false;
size_t in_pos = 1;                          
std::string byte_buff;
while (true) {
const wchar_t c = input[in_pos++];
switch (c) {
case L'\0': {
assert(in_pos > 0);
in_pos--;
if (!allow_incomplete) errored = true;
break;
}
case L'0':
case L'1':
case L'2':
case L'3':
case L'4':
case L'5':
case L'6':
case L'7':
case L'u':
case L'U':
case L'x':
case L'X': {
long long res = 0;
size_t chars = 2;
int base = 16;
bool byte_literal = false;
wchar_t max_val = ASCII_MAX;
switch (c) {
case L'u': {
chars = 4;
max_val = UCS2_MAX;
break;
}
case L'U': {
chars = 8;
max_val = WCHAR_MAX;
if (0x10FFFF < max_val) max_val = static_cast<wchar_t>(0x10FFFF);
break;
}
case L'x':
case L'X': {
byte_literal = true;
max_val = BYTE_MAX;
break;
}
default: {
base = 8;
chars = 3;
assert(in_pos > 0);
in_pos--;
break;
}
}
for (size_t i = 0; i < chars; i++) {
long d = convert_digit(input[in_pos], base);
if (d < 0) {
if (i == 0) errored = true;
break;
}
res = (res * base) + d;
in_pos++;
}
if (!errored && res <= max_val) {
if (byte_literal) {
byte_buff.push_back(static_cast<char>(res));
result_char_or_none = none();
if (input[in_pos] == L'\\'
&& (input[in_pos + 1] == L'X' || input[in_pos + 1] == L'x')) {
in_pos++;
continue;
}
} else {
result_char_or_none = static_cast<wchar_t>(res);
}
} else {
errored = true;
}
break;
}
case L'a': {
result_char_or_none = L'\a';
break;
}
case L'b': {
result_char_or_none = L'\b';
break;
}
case L'c': {
const wchar_t sequence_char = input[in_pos++];
if (sequence_char >= L'a' && sequence_char <= (L'a' + 32)) {
result_char_or_none = sequence_char - L'a' + 1;
} else if (sequence_char >= L'A' && sequence_char <= (L'A' + 32)) {
result_char_or_none = sequence_char - L'A' + 1;
} else {
errored = true;
}
break;
}
case L'e': {
result_char_or_none = L'\x1B';
break;
}
case L'f': {
result_char_or_none = L'\f';
break;
}
case L'n': {
result_char_or_none = L'\n';
break;
}
case L'r': {
result_char_or_none = L'\r';
break;
}
case L't': {
result_char_or_none = L'\t';
break;
}
case L'v': {
result_char_or_none = L'\v';
break;
}
case L'\n': {
result_char_or_none = none();
break;
}
default: {
if (unescape_special) result->push_back(INTERNAL_SEPARATOR);
result_char_or_none = c;
break;
}
}
if (errored) return none();
if (!byte_buff.empty()) {
result->append(str2wcstring(byte_buff));
}
break;
}
if (result_char_or_none.has_value()) {
result->push_back(*result_char_or_none);
}
return in_pos;
}","maybe_t<size_t> read_unquoted_escape(const wchar_t *VAR_0, wcstring *VAR_1, bool VAR_2,
bool VAR_3) {
assert(VAR_0[0] == L'\\' && ""Not an escape"");
maybe_t<wchar_t> VAR_4 = none();
bool VAR_5 = false;
size_t VAR_6 = 1;  
std::string VAR_7;
while (true) {
const wchar_t VAR_8 = VAR_0[VAR_6++];
switch (VAR_8) {
case L'\0': {
assert(VAR_6 > 0);
VAR_6--;
if (!VAR_2) VAR_5 = true;
break;
}
case L'0':
case L'1':
case L'2':
case L'3':
case L'4':
case L'5':
case L'6':
case L'7':
case L'u':
case L'U':
case L'x':
case L'X': {
long long VAR_9 = 0;
size_t VAR_10 = 2;
int VAR_11 = 16;
bool VAR_12 = false;
wchar_t VAR_13 = VAR_14;
switch (VAR_8) {
case L'u': {
VAR_10 = 4;
VAR_13 = VAR_15;
break;
}
case L'U': {
VAR_10 = 8;
VAR_13 = VAR_16;
if (0x10FFFF < VAR_13) VAR_13 = VAR_17<wchar_t>(0x10FFFF);
break;
}
case L'x':
case L'X': {
VAR_12 = true;
VAR_13 = VAR_18;
break;
}
default: {
VAR_11 = 8;
VAR_10 = 3;
assert(VAR_6 > 0);
VAR_6--;
break;
}
}
for (size_t VAR_19 = 0; VAR_19 < VAR_10; VAR_19++) {
long VAR_20 = convert_digit(VAR_0[VAR_6], VAR_11);
if (VAR_20 < 0) {
if (VAR_19 == 0) VAR_5 = true;
break;
}
VAR_9 = (VAR_9 * VAR_11) + VAR_20;
VAR_6++;
}
if (!VAR_5 && VAR_9 <= VAR_13) {
if (VAR_12) {
VAR_7.push_back(VAR_17<char>(VAR_9));
VAR_4 = none();
if (VAR_0[VAR_6] == L'\\'
&& (VAR_0[VAR_6 + 1] == L'X' || VAR_0[VAR_6 + 1] == L'x')) {
VAR_6++;
continue;
}
} else {
VAR_4 = VAR_17<wchar_t>(VAR_9);
}
} else {
VAR_5 = true;
}
break;
}
case L'a': {
VAR_4 = L'\a';
break;
}
case L'b': {
VAR_4 = L'\b';
break;
}
case L'c': {
const wchar_t VAR_21 = VAR_0[VAR_6++];
if (VAR_21 >= L'a' && VAR_21 <= (L'a' + 32)) {
VAR_4 = VAR_21 - L'a' + 1;
} else if (VAR_21 >= L'A' && VAR_21 <= (L'A' + 32)) {
VAR_4 = VAR_21 - L'A' + 1;
} else {
VAR_5 = true;
}
break;
}
case L'e': {
VAR_4 = L'\x1B';
break;
}
case L'f': {
VAR_4 = L'\f';
break;
}
case L'n': {
VAR_4 = L'\n';
break;
}
case L'r': {
VAR_4 = L'\r';
break;
}
case L't': {
VAR_4 = L'\t';
break;
}
case L'v': {
VAR_4 = L'\v';
break;
}
case L'\n': {
VAR_4 = none();
break;
}
default: {
if (VAR_3) VAR_1->push_back(VAR_22);
VAR_4 = VAR_8;
break;
}
}
if (VAR_5) return none();
if (!VAR_7.empty()) {
VAR_1->append(str2wcstring(VAR_7));
}
break;
}
if (VAR_4.has_value()) {
VAR_1->push_back(*VAR_4);
}
return VAR_6;
}",fish-shell/09986f5563e31e2c900a606438f1d60d008f3a14/common.cpp/vul/before/1.json,"maybe_t<size_t> read_unquoted_escape(const wchar_t *input, wcstring *result, bool allow_incomplete,
                                     bool unescape_special) {
    assert(input[0] == L'\\' && ""Not an escape"");

    // Here's the character we'll ultimately append, or none. Note that L'\0' is a
    // valid thing to append.
    maybe_t<wchar_t> result_char_or_none = none();

    bool errored = false;
    size_t in_pos = 1;  // in_pos always tracks the next character to read (and therefore the number
                        // of characters read so far)

    // For multibyte \X sequences.
    std::string byte_buff;
    while (true) {
        const wchar_t c = input[in_pos++];
        switch (c) {
                // A null character after a backslash is an error.
            case L'\0': {
                // Adjust in_pos to only include the backslash.
                assert(in_pos > 0);
                in_pos--;

                // It's an error, unless we're allowing incomplete escapes.
                if (!allow_incomplete) errored = true;
                break;
            }
                // Numeric escape sequences. No prefix means octal escape, otherwise hexadecimal.
            case L'0':
            case L'1':
            case L'2':
            case L'3':
            case L'4':
            case L'5':
            case L'6':
            case L'7':
            case L'u':
            case L'U':
            case L'x':
            case L'X': {
                long long res = 0;
                size_t chars = 2;
                int base = 16;
                bool byte_literal = false;
                wchar_t max_val = ASCII_MAX;

                switch (c) {
                    case L'u': {
                        chars = 4;
                        max_val = UCS2_MAX;
                        break;
                    }
                    case L'U': {
                        chars = 8;
                        max_val = WCHAR_MAX;

                        // Don't exceed the largest Unicode code point - see #1107.
                        if (0x10FFFF < max_val) max_val = static_cast<wchar_t>(0x10FFFF);
                        break;
                    }
                    case L'x':
                    case L'X': {
                        byte_literal = true;
                        max_val = BYTE_MAX;
                        break;
                    }
                    default: {
                        base = 8;
                        chars = 3;
                        // Note that in_pos currently is just after the first post-backslash
                        // character; we want to start our escape from there.
                        assert(in_pos > 0);
                        in_pos--;
                        break;
                    }
                }

                for (size_t i = 0; i < chars; i++) {
                    long d = convert_digit(input[in_pos], base);
                    if (d < 0) {
                        // If we have no digit, this is a tokenizer error.
                        if (i == 0) errored = true;
                        break;
                    }

                    res = (res * base) + d;
                    in_pos++;
                }

                if (!errored && res <= max_val) {
                    if (byte_literal) {
                        // Multibyte encodings necessitate that we keep adjacent byte escapes.
                        // - `\Xc3\Xb6` is """", but only together.
                        // (this assumes a valid codepoint can't consist of multiple bytes
                        // that are valid on their own, which is true for UTF-8)
                        byte_buff.push_back(static_cast<char>(res));
                        result_char_or_none = none();
                        if (input[in_pos] == L'\\'
                            && (input[in_pos + 1] == L'X' || input[in_pos + 1] == L'x')) {
                            in_pos++;
                            continue;
                        }
                    } else {
                        result_char_or_none = static_cast<wchar_t>(res);
                    }
                } else {
                    errored = true;
                }

                break;
            }
                // \a means bell (alert).
            case L'a': {
                result_char_or_none = L'\a';
                break;
            }
                // \b means backspace.
            case L'b': {
                result_char_or_none = L'\b';
                break;
            }
                // \cX means control sequence X.
            case L'c': {
                const wchar_t sequence_char = input[in_pos++];
                if (sequence_char >= L'a' && sequence_char <= (L'a' + 32)) {
                    result_char_or_none = sequence_char - L'a' + 1;
                } else if (sequence_char >= L'A' && sequence_char <= (L'A' + 32)) {
                    result_char_or_none = sequence_char - L'A' + 1;
                } else {
                    errored = true;
                }
                break;
            }
                // \x1B means escape.
            case L'e': {
                result_char_or_none = L'\x1B';
                break;
            }
                // \f means form feed.
            case L'f': {
                result_char_or_none = L'\f';
                break;
            }
                // \n means newline.
            case L'n': {
                result_char_or_none = L'\n';
                break;
            }
                // \r means carriage return.
            case L'r': {
                result_char_or_none = L'\r';
                break;
            }
                // \t means tab.
            case L't': {
                result_char_or_none = L'\t';
                break;
            }
                // \v means vertical tab.
            case L'v': {
                result_char_or_none = L'\v';
                break;
            }
                // If a backslash is followed by an actual newline, swallow them both.
            case L'\n': {
                result_char_or_none = none();
                break;
            }
            default: {
                if (unescape_special) result->push_back(INTERNAL_SEPARATOR);
                result_char_or_none = c;
                break;
            }
        }

        if (errored) return none();

        if (!byte_buff.empty()) {
            result->append(str2wcstring(byte_buff));
        }

        break;
    }

    if (result_char_or_none.has_value()) {
        if (fish_reserved_codepoint(*result_char_or_none)) {
            return none();
        }
        result->push_back(*result_char_or_none);
    }

    return in_pos;
}","maybe_t<size_t> read_unquoted_escape(const wchar_t *VAR_0, wcstring *VAR_1, bool VAR_2,
                                     bool VAR_3) {
    assert(VAR_0[0] == L'\\' && ""Not an escape"");

    /* COMMENT_0 */
    /* COMMENT_1 */
    maybe_t<wchar_t> VAR_4 = none();

    bool VAR_5 = false;
    size_t VAR_6 = 1;  /* COMMENT_2 */
                        /* COMMENT_3 */

    /* COMMENT_4 */
    std::string VAR_7;
    while (true) {
        const wchar_t VAR_8 = VAR_0[VAR_6++];
        switch (VAR_8) {
                /* COMMENT_5 */
            case L'\0': {
                /* COMMENT_6 */
                assert(VAR_6 > 0);
                VAR_6--;

                /* COMMENT_7 */
                if (!VAR_2) VAR_5 = true;
                break;
            }
                /* COMMENT_8 */
            case L'0':
            case L'1':
            case L'2':
            case L'3':
            case L'4':
            case L'5':
            case L'6':
            case L'7':
            case L'u':
            case L'U':
            case L'x':
            case L'X': {
                long long VAR_9 = 0;
                size_t VAR_10 = 2;
                int VAR_11 = 16;
                bool VAR_12 = false;
                wchar_t VAR_13 = VAR_14;

                switch (VAR_8) {
                    case L'u': {
                        VAR_10 = 4;
                        VAR_13 = VAR_15;
                        break;
                    }
                    case L'U': {
                        VAR_10 = 8;
                        VAR_13 = VAR_16;

                        /* COMMENT_9 */
                        if (0x10FFFF < VAR_13) VAR_13 = VAR_17<wchar_t>(0x10FFFF);
                        break;
                    }
                    case L'x':
                    case L'X': {
                        VAR_12 = true;
                        VAR_13 = VAR_18;
                        break;
                    }
                    default: {
                        VAR_11 = 8;
                        VAR_10 = 3;
                        /* COMMENT_10 */
                        /* COMMENT_11 */
                        assert(VAR_6 > 0);
                        VAR_6--;
                        break;
                    }
                }

                for (size_t VAR_19 = 0; VAR_19 < VAR_10; VAR_19++) {
                    long VAR_20 = convert_digit(VAR_0[VAR_6], VAR_11);
                    if (VAR_20 < 0) {
                        /* COMMENT_12 */
                        if (VAR_19 == 0) VAR_5 = true;
                        break;
                    }

                    VAR_9 = (VAR_9 * VAR_11) + VAR_20;
                    VAR_6++;
                }

                if (!VAR_5 && VAR_9 <= VAR_13) {
                    if (VAR_12) {
                        /* COMMENT_13 */
                        /* COMMENT_14 */
                        /* COMMENT_15 */
                        /* COMMENT_16 */
                        VAR_7.push_back(VAR_17<char>(VAR_9));
                        VAR_4 = none();
                        if (VAR_0[VAR_6] == L'\\'
                            && (VAR_0[VAR_6 + 1] == L'X' || VAR_0[VAR_6 + 1] == L'x')) {
                            VAR_6++;
                            continue;
                        }
                    } else {
                        VAR_4 = VAR_17<wchar_t>(VAR_9);
                    }
                } else {
                    VAR_5 = true;
                }

                break;
            }
                /* COMMENT_17 */
            case L'a': {
                VAR_4 = L'\a';
                break;
            }
                /* COMMENT_18 */
            case L'b': {
                VAR_4 = L'\b';
                break;
            }
                /* COMMENT_19 */
            case L'c': {
                const wchar_t VAR_21 = VAR_0[VAR_6++];
                if (VAR_21 >= L'a' && VAR_21 <= (L'a' + 32)) {
                    VAR_4 = VAR_21 - L'a' + 1;
                } else if (VAR_21 >= L'A' && VAR_21 <= (L'A' + 32)) {
                    VAR_4 = VAR_21 - L'A' + 1;
                } else {
                    VAR_5 = true;
                }
                break;
            }
                /* COMMENT_20 */
            case L'e': {
                VAR_4 = L'\x1B';
                break;
            }
                /* COMMENT_21 */
            case L'f': {
                VAR_4 = L'\f';
                break;
            }
                /* COMMENT_22 */
            case L'n': {
                VAR_4 = L'\n';
                break;
            }
                /* COMMENT_23 */
            case L'r': {
                VAR_4 = L'\r';
                break;
            }
                /* COMMENT_24 */
            case L't': {
                VAR_4 = L'\t';
                break;
            }
                /* COMMENT_25 */
            case L'v': {
                VAR_4 = L'\v';
                break;
            }
                /* COMMENT_26 */
            case L'\n': {
                VAR_4 = none();
                break;
            }
            default: {
                if (VAR_3) VAR_1->push_back(VAR_22);
                VAR_4 = VAR_8;
                break;
            }
        }

        if (VAR_5) return none();

        if (!VAR_7.empty()) {
            VAR_1->append(str2wcstring(VAR_7));
        }

        break;
    }

    if (VAR_4.has_value()) {
        if (fish_reserved_codepoint(*VAR_4)) {
            return none();
        }
        VAR_1->push_back(*VAR_4);
    }

    return VAR_6;
}",fish-shell/09986f5563e31e2c900a606438f1d60d008f3a14/common.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -183,6 +183,9 @@
     }
 
     if (result_char_or_none.has_value()) {
+        if (fish_reserved_codepoint(*result_char_or_none)) {
+            return none();
+        }
         result->push_back(*result_char_or_none);
     }
 ","{'deleted_lines': [], 'added_lines': ['        if (fish_reserved_codepoint(*result_char_or_none)) {', '            return none();', '        }']}",True,"fish is a smart and user-friendly command line shell for macOS, Linux, and the rest of the family. fish shell uses certain Unicode non-characters internally for marking wildcards and expansions. It will incorrectly allow these markers to be read on command substitution output, rather than transforming them into a safe internal representation. While this may cause unexpected behavior with direct input (for example, echo \UFDD2HOME has the same output as echo $HOME), this may become a minor security problem if the output is being fed from an external program into a command substitution where this output may not be expected. This design flaw was introduced in very early versions of fish, predating the version control system, and is thought to be present in every version of fish released in the last 15 years or more, although with different characters. Code execution does not appear to be possible, but denial of service (through large brace expansion) or information disclosure (such as variable expansion) is potentially possible under certain circumstances. fish shell 3.6.2 has been released to correct this issue. Users are advised to upgrade. There are no known workarounds for this vulnerability.",3.9,LOW,0,test,2023-12-02T10:06:07Z,4
CVE-2023-50628,['CWE-120'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,libming,Fix #289: Memory leaks at parser.c,8fcecb2a18dd7ad72a40154d07f715de9be96cc1,https://github.com/libming/libming/commit/8fcecb2a18dd7ad72a40154d07f715de9be96cc1,util/parser.c,parseSWF_GLYPHENTRY,"void
parseSWF_GLYPHENTRY (FILE * f, SWF_GLYPHENTRY *gerec, int glyphbits, int advancebits)
{
unsigned int i;
size_t nmalloc = ( glyphbits < 1 ? 1 : ((glyphbits+31)/32) ) * sizeof(UI32);
gerec->GlyphIndex = malloc(nmalloc);
gerec->GlyphIndex[0] = 0; 
for( i=0; glyphbits; i++ ) {
if (i < (nmalloc / sizeof(UI32))) {
if( glyphbits > 32 ) {
gerec->GlyphIndex[i] = readBits(f, 32);
glyphbits -= 32;
} else {
gerec->GlyphIndex[i] = readBits(f, glyphbits);
glyphbits = 0;
}
} else {
SWF_error(""unexpected end of file"");
}
}
nmalloc = ( advancebits < 1 ? 1 : ((advancebits+31)/32) ) * sizeof(UI32);
gerec->GlyphAdvance = malloc(nmalloc);
gerec->GlyphAdvance[0] = 0; 
for( i=0; advancebits; i++ ) {
if (i < (nmalloc / sizeof(UI32))) {
if( advancebits > 32 ) {
gerec->GlyphAdvance[i] = readBits(f, 32);
advancebits -= 32;
} else {
gerec->GlyphAdvance[i] = readBits(f, advancebits);
advancebits = 0;
}
} else {
SWF_error(""unexpected end of file"");
}
}
}","void
parseSWF_GLYPHENTRY (FILE * VAR_0, SWF_GLYPHENTRY *VAR_1, int VAR_2, int VAR_3)
{
unsigned int VAR_4;
size_t VAR_5 = ( VAR_2 < 1 ? 1 : ((VAR_2+31)/32) ) * sizeof(VAR_6);
VAR_1->GlyphIndex = malloc(VAR_5);
VAR_1->GlyphIndex[0] = 0; 
for( VAR_4=0; VAR_2; VAR_4++ ) {
if (VAR_4 < (VAR_5 / sizeof(VAR_6))) {
if( VAR_2 > 32 ) {
VAR_1->GlyphIndex[VAR_4] = readBits(VAR_0, 32);
VAR_2 -= 32;
} else {
VAR_1->GlyphIndex[VAR_4] = readBits(VAR_0, VAR_2);
VAR_2 = 0;
}
} else {
SWF_error(""unexpected end of file"");
}
}
VAR_5 = ( VAR_3 < 1 ? 1 : ((VAR_3+31)/32) ) * sizeof(VAR_6);
VAR_1->GlyphAdvance = malloc(VAR_5);
VAR_1->GlyphAdvance[0] = 0; 
for( VAR_4=0; VAR_3; VAR_4++ ) {
if (VAR_4 < (VAR_5 / sizeof(VAR_6))) {
if( VAR_3 > 32 ) {
VAR_1->GlyphAdvance[VAR_4] = readBits(VAR_0, 32);
VAR_3 -= 32;
} else {
VAR_1->GlyphAdvance[VAR_4] = readBits(VAR_0, VAR_3);
VAR_3 = 0;
}
} else {
SWF_error(""unexpected end of file"");
}
}
}",libming/8fcecb2a18dd7ad72a40154d07f715de9be96cc1/parser.c/vul/before/0.json,"void
parseSWF_GLYPHENTRY (FILE * f, SWF_GLYPHENTRY *gerec, int glyphbits, int advancebits)
{
  unsigned int i;

  size_t nmalloc = ( glyphbits < 1 ? 1 : ((glyphbits+31)/32) ) * sizeof(UI32);

  /* Check memory access */
  if (mprotect(gerec, nmalloc, PROT_READ | PROT_WRITE) != 0) {
    printf(""Inaccessible Memory Address"");
    exit(-1);
  }

  gerec->GlyphIndex = malloc(nmalloc);
  gerec->GlyphIndex[0] = 0; /* for glyphbits == 0 */
  for( i=0; glyphbits; i++ ) {
    if (i < (nmalloc / sizeof(UI32))) {
	  if( glyphbits > 32 ) {
	  	gerec->GlyphIndex[i] = readBits(f, 32);
	  	glyphbits -= 32;
  	} else {
	 	gerec->GlyphIndex[i] = readBits(f, glyphbits);
	 	glyphbits = 0;
  	}
    } else {
      SWF_error(""unexpected end of file"");
    }
  }

  nmalloc = ( advancebits < 1 ? 1 : ((advancebits+31)/32) ) * sizeof(UI32);
  gerec->GlyphAdvance = malloc(nmalloc);
  gerec->GlyphAdvance[0] = 0; /* for advancebits == 0 */
  for( i=0; advancebits; i++ ) {
    if (i < (nmalloc / sizeof(UI32))) {
	  if( advancebits > 32 ) {
	  	gerec->GlyphAdvance[i] = readBits(f, 32);
	  	advancebits -= 32;
  	} else {
	 	gerec->GlyphAdvance[i] = readBits(f, advancebits);
	 	advancebits = 0;
  	}
    } else {
      SWF_error(""unexpected end of file"");
    }
  }
}","void
parseSWF_GLYPHENTRY (FILE * VAR_0, SWF_GLYPHENTRY *VAR_1, int VAR_2, int VAR_3)
{
  unsigned int VAR_4;

  size_t VAR_5 = ( VAR_2 < 1 ? 1 : ((VAR_2+31)/32) ) * sizeof(VAR_6);

  /* COMMENT_0 */
  if (mprotect(VAR_1, VAR_5, VAR_7 | VAR_8) != 0) {
    printf(""Inaccessible Memory Address"");
    exit(-1);
  }

  VAR_1->GlyphIndex = malloc(VAR_5);
  VAR_1->GlyphIndex[0] = 0; /* COMMENT_1 */
  for( VAR_4=0; VAR_2; VAR_4++ ) {
    if (VAR_4 < (VAR_5 / sizeof(VAR_6))) {
	  if( VAR_2 > 32 ) {
	  	VAR_1->GlyphIndex[VAR_4] = readBits(VAR_0, 32);
	  	VAR_2 -= 32;
  	} else {
	 	VAR_1->GlyphIndex[VAR_4] = readBits(VAR_0, VAR_2);
	 	VAR_2 = 0;
  	}
    } else {
      SWF_error(""unexpected end of file"");
    }
  }

  VAR_5 = ( VAR_3 < 1 ? 1 : ((VAR_3+31)/32) ) * sizeof(VAR_6);
  VAR_1->GlyphAdvance = malloc(VAR_5);
  VAR_1->GlyphAdvance[0] = 0; /* COMMENT_2 */
  for( VAR_4=0; VAR_3; VAR_4++ ) {
    if (VAR_4 < (VAR_5 / sizeof(VAR_6))) {
	  if( VAR_3 > 32 ) {
	  	VAR_1->GlyphAdvance[VAR_4] = readBits(VAR_0, 32);
	  	VAR_3 -= 32;
  	} else {
	 	VAR_1->GlyphAdvance[VAR_4] = readBits(VAR_0, VAR_3);
	 	VAR_3 = 0;
  	}
    } else {
      SWF_error(""unexpected end of file"");
    }
  }
}",libming/8fcecb2a18dd7ad72a40154d07f715de9be96cc1/parser.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,6 +4,13 @@
   unsigned int i;
 
   size_t nmalloc = ( glyphbits < 1 ? 1 : ((glyphbits+31)/32) ) * sizeof(UI32);
+
+  /* Check memory access */
+  if (mprotect(gerec, nmalloc, PROT_READ | PROT_WRITE) != 0) {
+    printf(""Inaccessible Memory Address"");
+    exit(-1);
+  }
+
   gerec->GlyphIndex = malloc(nmalloc);
   gerec->GlyphIndex[0] = 0; /* for glyphbits == 0 */
   for( i=0; glyphbits; i++ ) {","{'deleted_lines': [], 'added_lines': ['', '  /* Check memory access */', '  if (mprotect(gerec, nmalloc, PROT_READ | PROT_WRITE) != 0) {', '    printf(""Inaccessible Memory Address"");', '    exit(-1);', '  }', '']}",True,"Buffer Overflow vulnerability in libming version 0.4.8, allows attackers to execute arbitrary code and obtain sensitive information via parser.c component.",9.8,CRITICAL,3,test,2023-12-07T19:55:50Z,4
CVE-2023-50245,['CWE-120'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,afichet/openexr-viewer,"Early catch potential overflow issue #43

`m_width` and `m_height` are of `int` type in the OpenEXR library. We
currently keep the same types in our class but this may case issue
when mapping 1D memory. In the most favorable case, they are
multiplied together (Y framebuffer). For RGB(A) case, the required
memory can also be 4 time larger. We check if resp. `m_width *
m_height` and `4 * m_width * m_heigh` stay within the `int` higher
limit. Thanks to @GAP-dev for bringing this issue.

This commit also cleans a bit raw memory allocation in favor of
`std::vector` container.",d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9,https://github.com/afichet/openexr-viewer/commit/d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9,src/model/framebuffer/FramebufferModel.cpp,FramebufferModel::~FramebufferModel,"FramebufferModel::~FramebufferModel()
{
delete[] m_pixelBuffer;
}","FramebufferModel::~VAR_0()
{
delete[] VAR_1;
}",afichet/openexr-viewer/d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9/FramebufferModel.cpp/vul/before/1.json,FramebufferModel::~FramebufferModel() {},FramebufferModel::~VAR_0() {},afichet/openexr-viewer/d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9/FramebufferModel.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,4 +1 @@
-FramebufferModel::~FramebufferModel()
-{
-    delete[] m_pixelBuffer;
-}
+FramebufferModel::~FramebufferModel() {}","{'deleted_lines': ['FramebufferModel::~FramebufferModel()', '{', '    delete[] m_pixelBuffer;', '}'], 'added_lines': ['FramebufferModel::~FramebufferModel() {}']}",True,OpenEXR-viewer is a viewer for OpenEXR files with detailed metadata probing. Versions prior to 0.6.1 have a memory overflow vulnerability. This issue is fixed in version 0.6.1.,9.8,CRITICAL,3,test,2023-12-09T13:13:36Z,4
CVE-2023-50245,['CWE-120'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,afichet/openexr-viewer,"Early catch potential overflow issue #43

`m_width` and `m_height` are of `int` type in the OpenEXR library. We
currently keep the same types in our class but this may case issue
when mapping 1D memory. In the most favorable case, they are
multiplied together (Y framebuffer). For RGB(A) case, the required
memory can also be 4 time larger. We check if resp. `m_width *
m_height` and `4 * m_width * m_heigh` stay within the `int` higher
limit. Thanks to @GAP-dev for bringing this issue.

This commit also cleans a bit raw memory allocation in favor of
`std::vector` container.",d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9,https://github.com/afichet/openexr-viewer/commit/d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9,src/model/framebuffer/FramebufferModel.cpp,FramebufferModel::FramebufferModel,"FramebufferModel::FramebufferModel(QObject* parent)
: QObject(parent)
, m_pixelBuffer(nullptr)
, m_width(0)
, m_height(0)
, m_isImageLoaded(false)
, m_exposure(0)
, m_imageLoadingWatcher(new QFutureWatcher<void>(this))
, m_imageEditingWatcher(new QFutureWatcher<void>(this))
, m_pixelAspectRatio(1.f)
{}","FramebufferModel::FramebufferModel(QObject* VAR_0)
: QObject(VAR_0)
, m_pixelBuffer(nullptr)
, m_width(0)
, m_height(0)
, m_isImageLoaded(false)
, m_exposure(0)
, m_imageLoadingWatcher(new QFutureWatcher<void>(this))
, m_imageEditingWatcher(new QFutureWatcher<void>(this))
, m_pixelAspectRatio(1.f)
{}",afichet/openexr-viewer/d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9/FramebufferModel.cpp/vul/before/0.json,"FramebufferModel::FramebufferModel(QObject* parent)
  : QObject(parent)
  , m_width(0)
  , m_height(0)
  , m_isImageLoaded(false)
  , m_exposure(0)
  , m_imageLoadingWatcher(new QFutureWatcher<void>(this))
  , m_imageEditingWatcher(new QFutureWatcher<void>(this))
  , m_pixelAspectRatio(1.f)
{}","FramebufferModel::FramebufferModel(QObject* VAR_0)
  : QObject(VAR_0)
  , m_width(0)
  , m_height(0)
  , m_isImageLoaded(false)
  , m_exposure(0)
  , m_imageLoadingWatcher(new QFutureWatcher<void>(this))
  , m_imageEditingWatcher(new QFutureWatcher<void>(this))
  , m_pixelAspectRatio(1.f)
{}",afichet/openexr-viewer/d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9/FramebufferModel.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,5 @@
 FramebufferModel::FramebufferModel(QObject* parent)
   : QObject(parent)
-  , m_pixelBuffer(nullptr)
   , m_width(0)
   , m_height(0)
   , m_isImageLoaded(false)","{'deleted_lines': ['  , m_pixelBuffer(nullptr)'], 'added_lines': []}",True,OpenEXR-viewer is a viewer for OpenEXR files with detailed metadata probing. Versions prior to 0.6.1 have a memory overflow vulnerability. This issue is fixed in version 0.6.1.,9.8,CRITICAL,3,test,2023-12-09T13:13:36Z,4
CVE-2023-50245,['CWE-120'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,afichet/openexr-viewer,"Early catch potential overflow issue #43

`m_width` and `m_height` are of `int` type in the OpenEXR library. We
currently keep the same types in our class but this may case issue
when mapping 1D memory. In the most favorable case, they are
multiplied together (Y framebuffer). For RGB(A) case, the required
memory can also be 4 time larger. We check if resp. `m_width *
m_height` and `4 * m_width * m_heigh` stay within the `int` higher
limit. Thanks to @GAP-dev for bringing this issue.

This commit also cleans a bit raw memory allocation in favor of
`std::vector` container.",d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9,https://github.com/afichet/openexr-viewer/commit/d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9,src/model/framebuffer/RGBFramebufferModel.cpp,RGBFramebufferModel::load,"void RGBFramebufferModel::load(
Imf::MultiPartInputFile& file, int partId, bool hasAlpha)
{
QFuture<void> imageLoading = QtConcurrent::run([this,
&file,
partId,
hasAlpha]() {
try {
Imf::InputPart part(file, partId);
Imath::Box2i datW = part.header().dataWindow();
m_width           = datW.max.x - datW.min.x + 1;
m_height          = datW.max.y - datW.min.y + 1;
m_pixelAspectRatio = part.header().pixelAspectRatio();
m_dataWindow = QRect(datW.min.x, datW.min.y, m_width, m_height);
Imath::Box2i dispW = part.header().displayWindow();
int dispW_width  = dispW.max.x - dispW.min.x + 1;
int dispW_height = dispW.max.y - dispW.min.y + 1;
m_displayWindow
= QRect(dispW.min.x, dispW.min.y, dispW_width, dispW_height);
const Imf::ChromaticitiesAttribute* c
= part.header().findTypedAttribute<Imf::ChromaticitiesAttribute>(
""chromaticities"");
Imf::Chromaticities chromaticities;
if (c != nullptr) {
chromaticities = c->value();
}
m_pixelBuffer = new float[4 * m_width * m_height];
if (hasAlpha) {
std::string      aLayer = m_parentLayer + ""A"";
Imf::FrameBuffer framebuffer;
Imf::Slice aSlice = Imf::Slice::Make(
Imf::PixelType::FLOAT,
&m_pixelBuffer[3],
datW,
4 * sizeof(float),
4 * m_width * sizeof(float));
framebuffer.insert(aLayer, aSlice);
part.setFrameBuffer(framebuffer);
part.readPixels(datW.min.y, datW.max.y);
} else {
for (int y = 0; y < m_height; y++) {
for (int x = 0; x < m_width; x++) {
m_pixelBuffer[4 * (y * m_width + x) + 3] = 1.f;
}
}
}
switch (m_layerType) {
case Layer_RGB: {
std::string rLayer = m_parentLayer + ""R"";
std::string gLayer = m_parentLayer + ""G"";
std::string bLayer = m_parentLayer + ""B"";
Imf::FrameBuffer framebuffer;
Imf::Slice rSlice = Imf::Slice::Make(
Imf::PixelType::FLOAT,
&m_pixelBuffer[0],
datW,
4 * sizeof(float),
4 * m_width * sizeof(float));
Imf::Slice gSlice = Imf::Slice::Make(
Imf::PixelType::FLOAT,
&m_pixelBuffer[1],
datW,
4 * sizeof(float),
4 * m_width * sizeof(float));
Imf::Slice bSlice = Imf::Slice::Make(
Imf::PixelType::FLOAT,
&m_pixelBuffer[2],
datW,
4 * sizeof(float),
4 * m_width * sizeof(float));
framebuffer.insert(rLayer, rSlice);
framebuffer.insert(gLayer, gSlice);
framebuffer.insert(bLayer, bSlice);
part.setFrameBuffer(framebuffer);
part.readPixels(datW.min.y, datW.max.y);
Imath::M44f RGB_XYZ = Imf::RGBtoXYZ(chromaticities, 1.f);
Imath::M44f XYZ_RGB
= Imf::XYZtoRGB(Imf::Chromaticities(), 1.f);
Imath::M44f conversionMatrix = RGB_XYZ * XYZ_RGB;
#pragma omp parallel for
for (int y = 0; y < m_height; y++) {
for (int x = 0; x < m_width; x++) {
const float r
= m_pixelBuffer[4 * (y * m_width + x) + 0];
const float g
= m_pixelBuffer[4 * (y * m_width + x) + 1];
const float b
= m_pixelBuffer[4 * (y * m_width + x) + 2];
Imath::V3f rgb(r, g, b);
rgb *= conversionMatrix;
m_pixelBuffer[4 * (y * m_width + x) + 0] = rgb.x;
m_pixelBuffer[4 * (y * m_width + x) + 1] = rgb.y;
m_pixelBuffer[4 * (y * m_width + x) + 2] = rgb.z;
}
}
} break;
case Layer_YC: {
std::string yLayer  = m_parentLayer + ""Y"";
std::string ryLayer = m_parentLayer + ""RY"";
std::string byLayer = m_parentLayer + ""BY"";
Imf::FrameBuffer framebuffer;
Imf::Rgba* buff1 = new Imf::Rgba[m_width * m_height];
Imf::Rgba* buff2 = new Imf::Rgba[m_width * m_height];
float* yBuffer  = new float[m_width * m_height];
float* ryBuffer = new float[m_width / 2 * m_height / 2];
float* byBuffer = new float[m_width / 2 * m_height / 2];
Imf::Slice ySlice = Imf::Slice::Make(
Imf::PixelType::FLOAT,
&yBuffer[0],
datW,
sizeof(float),
m_width * sizeof(float));
Imf::Slice rySlice = Imf::Slice::Make(
Imf::PixelType::FLOAT,
&ryBuffer[0],
datW,
sizeof(float),
m_width / 2 * sizeof(float),
2,
2);
Imf::Slice bySlice = Imf::Slice::Make(
Imf::PixelType::FLOAT,
&byBuffer[0],
datW,
sizeof(float),
m_width / 2 * sizeof(float),
2,
2);
framebuffer.insert(yLayer, ySlice);
framebuffer.insert(ryLayer, rySlice);
framebuffer.insert(byLayer, bySlice);
part.setFrameBuffer(framebuffer);
part.readPixels(datW.min.y, datW.max.y);
#pragma omp parallel for
for (int y = 0; y < m_height; y++) {
for (int x = 0; x < m_width; x++) {
const float l = yBuffer[y * m_width + x];
const float ry
= ryBuffer[y / 2 * m_width / 2 + x / 2];
const float by
= byBuffer[y / 2 * m_width / 2 + x / 2];
buff1[y * m_width + x].r = ry;
buff1[y * m_width + x].g = l;
buff1[y * m_width + x].b = by;
buff1[y * m_width + x].a
= m_pixelBuffer[4 * (y * m_width + x) + 3];
}
}
Imath::V3f yw = Imf::RgbaYca::computeYw(chromaticities);
#pragma omp parallel for
for (int y = 0; y < m_height; y++) {
Imf::RgbaYca::YCAtoRGBA(
yw,
m_width,
&buff1[y * m_width],
&buff1[y * m_width]);
}
#pragma omp parallel for
for (int y = 0; y < m_height; y++) {
const Imf::Rgba* scanlines[3];
if (y == 0) {
scanlines[0] = &buff1[(y + 1) * m_width];
} else {
scanlines[0] = &buff1[(y - 1) * m_width];
}
scanlines[1] = &buff1[y * m_width];
if (y == m_height - 1) {
scanlines[2] = &buff1[(y - 1) * m_width];
} else {
scanlines[2] = &buff1[(y + 1) * m_width];
}
Imf::RgbaYca::fixSaturation(
yw,
m_width,
scanlines,
&buff2[y * m_width]);
}
Imath::M44f RGB_XYZ = Imf::RGBtoXYZ(chromaticities, 1.f);
Imath::M44f XYZ_RGB
= Imf::XYZtoRGB(Imf::Chromaticities(), 1.f);
Imath::M44f conversionMatrix = RGB_XYZ * XYZ_RGB;
#pragma omp parallel for
for (int y = 0; y < m_height; y++) {
for (int x = 0; x < m_width; x++) {
Imath::V3f rgb(
buff2[y * m_width + x].r,
buff2[y * m_width + x].g,
buff2[y * m_width + x].b);
rgb = rgb * conversionMatrix;
m_pixelBuffer[4 * (y * m_width + x) + 0] = rgb.x;
m_pixelBuffer[4 * (y * m_width + x) + 1] = rgb.y;
m_pixelBuffer[4 * (y * m_width + x) + 2] = rgb.z;
}
}
delete[] yBuffer;
delete[] ryBuffer;
delete[] byBuffer;
delete[] buff1;
delete[] buff2;
}
break;
case Layer_Y: {
std::string yLayer = m_parentLayer;
Imf::FrameBuffer framebuffer;
Imf::Slice ySlice = Imf::Slice::Make(
Imf::PixelType::FLOAT,
&m_pixelBuffer[0],
datW,
4 * sizeof(float),
4 * m_width * sizeof(float));
framebuffer.insert(yLayer, ySlice);
part.setFrameBuffer(framebuffer);
part.readPixels(datW.min.y, datW.max.y);
#pragma omp parallel for
for (int i = 0; i < m_height * m_width; i++) {
m_pixelBuffer[4 * i + 1] = m_pixelBuffer[4 * i + 0];
m_pixelBuffer[4 * i + 2] = m_pixelBuffer[4 * i + 0];
m_pixelBuffer[4 * i + 3] = 1.f;
}
} break;
}
m_image = QImage(m_width, m_height, QImage::Format_RGBA8888);
m_isImageLoaded = true;
emit imageLoaded();
updateImage();
} catch (std::exception& e) {
emit loadFailed(e.what());
return;
}
});
m_imageLoadingWatcher->setFuture(imageLoading);
}","void RGBFramebufferModel::load(
Imf::MultiPartInputFile& VAR_0, int VAR_1, bool VAR_2)
{
QFuture<void> VAR_3 = QtConcurrent::run([this,
&VAR_0,
VAR_1,
VAR_2]() {
try {
Imf::InputPart part(file, partId);
Imath::Box2i VAR_4 = VAR_5.header().dataWindow();
VAR_6           = VAR_4.max.x - VAR_4.min.x + 1;
VAR_7          = VAR_4.max.y - VAR_4.min.y + 1;
VAR_8 = VAR_5.header().pixelAspectRatio();
VAR_9 = QRect(VAR_4.min.x, VAR_4.min.y, VAR_6, VAR_7);
Imath::Box2i VAR_10 = VAR_5.header().displayWindow();
int VAR_11  = VAR_10.max.x - VAR_10.min.x + 1;
int VAR_12 = VAR_10.max.y - VAR_10.min.y + 1;
VAR_13
= QRect(VAR_10.min.x, VAR_10.min.y, VAR_11, VAR_12);
const Imf::ChromaticitiesAttribute* VAR_14
= VAR_5.header().findTypedAttribute<Imf::ChromaticitiesAttribute>(
""chromaticities"");
Imf::Chromaticities VAR_15;
if (VAR_14 != nullptr) {
VAR_15 = VAR_14->value();
}
VAR_16 = new float[4 * VAR_6 * VAR_7];
if (VAR_2) {
std::string      VAR_17 = VAR_18 + ""A"";
Imf::FrameBuffer VAR_19;
Imf::Slice VAR_20 = Imf::Slice::Make(
Imf::PixelType::FLOAT,
&VAR_16[3],
VAR_4,
4 * sizeof(float),
4 * VAR_6 * sizeof(float));
VAR_19.insert(VAR_17, VAR_20);
VAR_5.setFrameBuffer(VAR_19);
VAR_5.readPixels(VAR_4.min.y, VAR_4.max.y);
} else {
for (int VAR_21 = 0; VAR_21 < VAR_7; VAR_21++) {
for (int VAR_22 = 0; VAR_22 < VAR_6; VAR_22++) {
VAR_16[4 * (VAR_21 * VAR_6 + VAR_22) + 3] = 1.f;
}
}
}
switch (VAR_23) {
case VAR_24: {
std::string VAR_25 = VAR_18 + ""R"";
std::string VAR_26 = VAR_18 + ""G"";
std::string VAR_27 = VAR_18 + ""B"";
Imf::FrameBuffer VAR_19;
Imf::Slice VAR_28 = Imf::Slice::Make(
Imf::PixelType::FLOAT,
&VAR_16[0],
VAR_4,
4 * sizeof(float),
4 * VAR_6 * sizeof(float));
Imf::Slice VAR_29 = Imf::Slice::Make(
Imf::PixelType::FLOAT,
&VAR_16[1],
VAR_4,
4 * sizeof(float),
4 * VAR_6 * sizeof(float));
Imf::Slice VAR_30 = Imf::Slice::Make(
Imf::PixelType::FLOAT,
&VAR_16[2],
VAR_4,
4 * sizeof(float),
4 * VAR_6 * sizeof(float));
VAR_19.insert(VAR_25, VAR_28);
VAR_19.insert(VAR_26, VAR_29);
VAR_19.insert(VAR_27, VAR_30);
VAR_5.setFrameBuffer(VAR_19);
VAR_5.readPixels(VAR_4.min.y, VAR_4.max.y);
Imath::M44f VAR_31 = Imf::RGBtoXYZ(VAR_15, 1.f);
Imath::M44f VAR_32
= Imf::XYZtoRGB(Imf::Chromaticities(), 1.f);
Imath::M44f VAR_33 = VAR_31 * VAR_32;
#pragma omp parallel for
for (int VAR_21 = 0; VAR_21 < VAR_7; VAR_21++) {
for (int VAR_22 = 0; VAR_22 < VAR_6; VAR_22++) {
const float VAR_34
= VAR_16[4 * (VAR_21 * VAR_6 + VAR_22) + 0];
const float VAR_35
= VAR_16[4 * (VAR_21 * VAR_6 + VAR_22) + 1];
const float VAR_36
= VAR_16[4 * (VAR_21 * VAR_6 + VAR_22) + 2];
Imath::V3f rgb(r, g, b);
VAR_37 *= VAR_33;
VAR_16[4 * (VAR_21 * VAR_6 + VAR_22) + 0] = VAR_37.x;
VAR_16[4 * (VAR_21 * VAR_6 + VAR_22) + 1] = VAR_37.y;
VAR_16[4 * (VAR_21 * VAR_6 + VAR_22) + 2] = VAR_37.z;
}
}
} break;
case VAR_38: {
std::string VAR_39  = VAR_18 + ""Y"";
std::string VAR_40 = VAR_18 + ""RY"";
std::string VAR_41 = VAR_18 + ""BY"";
Imf::FrameBuffer VAR_19;
Imf::Rgba* VAR_42 = new Imf::Rgba[VAR_6 * VAR_7];
Imf::Rgba* VAR_43 = new Imf::Rgba[VAR_6 * VAR_7];
float* VAR_44  = new float[VAR_6 * VAR_7];
float* VAR_45 = new float[VAR_6 / 2 * VAR_7 / 2];
float* VAR_46 = new float[VAR_6 / 2 * VAR_7 / 2];
Imf::Slice VAR_47 = Imf::Slice::Make(
Imf::PixelType::FLOAT,
&VAR_44[0],
VAR_4,
sizeof(float),
VAR_6 * sizeof(float));
Imf::Slice VAR_48 = Imf::Slice::Make(
Imf::PixelType::FLOAT,
&VAR_45[0],
VAR_4,
sizeof(float),
VAR_6 / 2 * sizeof(float),
2,
2);
Imf::Slice VAR_49 = Imf::Slice::Make(
Imf::PixelType::FLOAT,
&VAR_46[0],
VAR_4,
sizeof(float),
VAR_6 / 2 * sizeof(float),
2,
2);
VAR_19.insert(VAR_39, VAR_47);
VAR_19.insert(VAR_40, VAR_48);
VAR_19.insert(VAR_41, VAR_49);
VAR_5.setFrameBuffer(VAR_19);
VAR_5.readPixels(VAR_4.min.y, VAR_4.max.y);
#pragma omp parallel for
for (int VAR_21 = 0; VAR_21 < VAR_7; VAR_21++) {
for (int VAR_22 = 0; VAR_22 < VAR_6; VAR_22++) {
const float VAR_50 = VAR_44[VAR_21 * VAR_6 + VAR_22];
const float VAR_51
= VAR_45[VAR_21 / 2 * VAR_6 / 2 + VAR_22 / 2];
const float VAR_52
= VAR_46[VAR_21 / 2 * VAR_6 / 2 + VAR_22 / 2];
VAR_42[VAR_21 * VAR_6 + VAR_22].r = VAR_51;
VAR_42[VAR_21 * VAR_6 + VAR_22].g = VAR_50;
VAR_42[VAR_21 * VAR_6 + VAR_22].b = VAR_52;
VAR_42[VAR_21 * VAR_6 + VAR_22].a
= VAR_16[4 * (VAR_21 * VAR_6 + VAR_22) + 3];
}
}
Imath::V3f VAR_53 = Imf::RgbaYca::computeYw(VAR_15);
#pragma omp parallel for
for (int VAR_21 = 0; VAR_21 < VAR_7; VAR_21++) {
Imf::RgbaYca::YCAtoRGBA(
VAR_53,
VAR_6,
&VAR_42[VAR_21 * VAR_6],
&VAR_42[VAR_21 * VAR_6]);
}
#pragma omp parallel for
for (int VAR_21 = 0; VAR_21 < VAR_7; VAR_21++) {
const Imf::Rgba* VAR_54[3];
if (VAR_21 == 0) {
VAR_54[0] = &VAR_42[(VAR_21 + 1) * VAR_6];
} else {
VAR_54[0] = &VAR_42[(VAR_21 - 1) * VAR_6];
}
VAR_54[1] = &VAR_42[VAR_21 * VAR_6];
if (VAR_21 == VAR_7 - 1) {
VAR_54[2] = &VAR_42[(VAR_21 - 1) * VAR_6];
} else {
VAR_54[2] = &VAR_42[(VAR_21 + 1) * VAR_6];
}
Imf::RgbaYca::fixSaturation(
VAR_53,
VAR_6,
VAR_54,
&VAR_43[VAR_21 * VAR_6]);
}
Imath::M44f VAR_31 = Imf::RGBtoXYZ(VAR_15, 1.f);
Imath::M44f VAR_32
= Imf::XYZtoRGB(Imf::Chromaticities(), 1.f);
Imath::M44f VAR_33 = VAR_31 * VAR_32;
#pragma omp parallel for
for (int VAR_21 = 0; VAR_21 < VAR_7; VAR_21++) {
for (int VAR_22 = 0; VAR_22 < VAR_6; VAR_22++) {
Imath::V3f VAR_37(
VAR_43[VAR_21 * VAR_6 + VAR_22].r,
VAR_43[VAR_21 * VAR_6 + VAR_22].g,
VAR_43[VAR_21 * VAR_6 + VAR_22].b);
VAR_37 = VAR_37 * VAR_33;
VAR_16[4 * (VAR_21 * VAR_6 + VAR_22) + 0] = VAR_37.x;
VAR_16[4 * (VAR_21 * VAR_6 + VAR_22) + 1] = VAR_37.y;
VAR_16[4 * (VAR_21 * VAR_6 + VAR_22) + 2] = VAR_37.z;
}
}
delete[] VAR_44;
delete[] VAR_45;
delete[] VAR_46;
delete[] VAR_42;
delete[] VAR_43;
}
break;
case VAR_55: {
std::string VAR_39 = VAR_18;
Imf::FrameBuffer VAR_19;
Imf::Slice VAR_47 = Imf::Slice::Make(
Imf::PixelType::FLOAT,
&VAR_16[0],
VAR_4,
4 * sizeof(float),
4 * VAR_6 * sizeof(float));
VAR_19.insert(VAR_39, VAR_47);
VAR_5.setFrameBuffer(VAR_19);
VAR_5.readPixels(VAR_4.min.y, VAR_4.max.y);
#pragma omp parallel for
for (int VAR_56 = 0; VAR_56 < VAR_7 * VAR_6; VAR_56++) {
VAR_16[4 * VAR_56 + 1] = VAR_16[4 * VAR_56 + 0];
VAR_16[4 * VAR_56 + 2] = VAR_16[4 * VAR_56 + 0];
VAR_16[4 * VAR_56 + 3] = 1.f;
}
} break;
}
VAR_57 = QImage(VAR_6, VAR_7, QImage::Format_RGBA8888);
VAR_58 = true;
emit imageLoaded();
updateImage();
} catch (std::exception& VAR_59) {
emit VAR_60(VAR_59.what());
return;
}
});
VAR_61->setFuture(VAR_3);
}",afichet/openexr-viewer/d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9/RGBFramebufferModel.cpp/vul/before/0.json,"void RGBFramebufferModel::load(
  Imf::MultiPartInputFile& file, int partId, bool hasAlpha)
{
    QFuture<void> imageLoading = QtConcurrent::run([this,
                                                    &file,
                                                    partId,
                                                    hasAlpha]() {
        try {
            Imf::InputPart part(file, partId);

            Imath::Box2i datW = part.header().dataWindow();
            m_width           = datW.max.x - datW.min.x + 1;
            m_height          = datW.max.y - datW.min.y + 1;

            m_pixelAspectRatio = part.header().pixelAspectRatio();

            m_dataWindow = QRect(datW.min.x, datW.min.y, m_width, m_height);

            Imath::Box2i dispW = part.header().displayWindow();

            int dispW_width  = dispW.max.x - dispW.min.x + 1;
            int dispW_height = dispW.max.y - dispW.min.y + 1;

            m_displayWindow
              = QRect(dispW.min.x, dispW.min.y, dispW_width, dispW_height);

            // Check to avoid type overflow, width and height are 32bits int
            // representing a 2 dimentional image. Can overflow the type when
            // multiplied together.
            // 0x1FFFFFFF is a save limit for 4 * 0x7FFFFFFF the max
            // representable int since we need 4 channels.
            // TODO: Use larger type when manipulating framebuffer
            const uint64_t partial_size
              = (uint64_t)m_width * (uint64_t)m_height;

            if (partial_size > 0x1FFFFFFF) {
                throw std::runtime_error(
                  ""The total image size is too large. May be supported in a ""
                  ""future revision."");
            }

            m_pixelBuffer.resize(4 * m_width * m_height);

            // Check if there is specific chromaticities tied to the color
            // representation in this part.
            const Imf::ChromaticitiesAttribute* c
              = part.header().findTypedAttribute<Imf::ChromaticitiesAttribute>(
                ""chromaticities"");

            Imf::Chromaticities chromaticities;

            if (c != nullptr) {
                chromaticities = c->value();
            }

            // Check if there is alpha channel
            if (hasAlpha) {
                std::string      aLayer = m_parentLayer + ""A"";
                Imf::FrameBuffer framebuffer;

                Imf::Slice aSlice = Imf::Slice::Make(
                  Imf::PixelType::FLOAT,
                  &m_pixelBuffer[3],
                  datW,
                  4 * sizeof(float),
                  4 * m_width * sizeof(float));

                framebuffer.insert(aLayer, aSlice);

                part.setFrameBuffer(framebuffer);
                part.readPixels(datW.min.y, datW.max.y);

            } else {
                for (int y = 0; y < m_height; y++) {
                    for (int x = 0; x < m_width; x++) {
                        m_pixelBuffer[4 * (y * m_width + x) + 3] = 1.f;
                    }
                }
            }

            switch (m_layerType) {
                case Layer_RGB: {
                    std::string rLayer = m_parentLayer + ""R"";
                    std::string gLayer = m_parentLayer + ""G"";
                    std::string bLayer = m_parentLayer + ""B"";

                    Imf::FrameBuffer framebuffer;

                    Imf::Slice rSlice = Imf::Slice::Make(
                      Imf::PixelType::FLOAT,
                      &m_pixelBuffer[0],
                      datW,
                      4 * sizeof(float),
                      4 * m_width * sizeof(float));

                    Imf::Slice gSlice = Imf::Slice::Make(
                      Imf::PixelType::FLOAT,
                      &m_pixelBuffer[1],
                      datW,
                      4 * sizeof(float),
                      4 * m_width * sizeof(float));

                    Imf::Slice bSlice = Imf::Slice::Make(
                      Imf::PixelType::FLOAT,
                      &m_pixelBuffer[2],
                      datW,
                      4 * sizeof(float),
                      4 * m_width * sizeof(float));

                    framebuffer.insert(rLayer, rSlice);
                    framebuffer.insert(gLayer, gSlice);
                    framebuffer.insert(bLayer, bSlice);

                    part.setFrameBuffer(framebuffer);
                    part.readPixels(datW.min.y, datW.max.y);

                    // Handle custom chromaticities
                    Imath::M44f RGB_XYZ = Imf::RGBtoXYZ(chromaticities, 1.f);
                    Imath::M44f XYZ_RGB
                      = Imf::XYZtoRGB(Imf::Chromaticities(), 1.f);

                    Imath::M44f conversionMatrix = RGB_XYZ * XYZ_RGB;

                    #pragma omp parallel for
                    for (int y = 0; y < m_height; y++) {
                        for (int x = 0; x < m_width; x++) {
                            const float r
                              = m_pixelBuffer[4 * (y * m_width + x) + 0];
                            const float g
                              = m_pixelBuffer[4 * (y * m_width + x) + 1];
                            const float b
                              = m_pixelBuffer[4 * (y * m_width + x) + 2];

                            Imath::V3f rgb(r, g, b);
                            rgb *= conversionMatrix;

                            m_pixelBuffer[4 * (y * m_width + x) + 0] = rgb.x;
                            m_pixelBuffer[4 * (y * m_width + x) + 1] = rgb.y;
                            m_pixelBuffer[4 * (y * m_width + x) + 2] = rgb.z;
                        }
                    }
                } break;

                case Layer_YC: {
                    std::string yLayer  = m_parentLayer + ""Y"";
                    std::string ryLayer = m_parentLayer + ""RY"";
                    std::string byLayer = m_parentLayer + ""BY"";

                    Imf::FrameBuffer framebuffer;

                    std::vector<Imf::Rgba> buff1(m_width * m_height);
                    std::vector<Imf::Rgba> buff2(m_width * m_height);

                    std::vector<float> yBuffer(m_width * m_height);
                    std::vector<float> ryBuffer(m_width / 2 * m_height / 2);
                    std::vector<float> byBuffer(m_width / 2 * m_height / 2);

                    Imf::Slice ySlice = Imf::Slice::Make(
                      Imf::PixelType::FLOAT,
                      &yBuffer[0],
                      datW,
                      sizeof(float),
                      m_width * sizeof(float));

                    Imf::Slice rySlice = Imf::Slice::Make(
                      Imf::PixelType::FLOAT,
                      &ryBuffer[0],
                      datW,
                      sizeof(float),
                      m_width / 2 * sizeof(float),
                      2,
                      2);

                    Imf::Slice bySlice = Imf::Slice::Make(
                      Imf::PixelType::FLOAT,
                      &byBuffer[0],
                      datW,
                      sizeof(float),
                      m_width / 2 * sizeof(float),
                      2,
                      2);

                    framebuffer.insert(yLayer, ySlice);
                    framebuffer.insert(ryLayer, rySlice);
                    framebuffer.insert(byLayer, bySlice);

                    part.setFrameBuffer(framebuffer);
                    part.readPixels(datW.min.y, datW.max.y);

                    // Filling missing values for chroma in the image
                    // TODO: now, naive reconstruction.
                    // Use later Imf::RgbaYca::reconstructChromaHoriz and
                    // Imf::RgbaYca::reconstructChromaVert to reconstruct missing
                    // pixels
                    #pragma omp parallel for
                    for (int y = 0; y < m_height; y++) {
                        for (int x = 0; x < m_width; x++) {
                            const float l = yBuffer[y * m_width + x];

                            /*
                            float ry = 0, by = 0;

                            if (y % 2 == 0) {
                                if (x % 2 == 0) {
                                    ry = ryBuffer[y / 2 * m_width / 2 + x / 2];
                                    by = byBuffer[y / 2 * m_width / 2 + x / 2];
                                } else {
                                    ry = .5 * (ryBuffer[y / 2 * m_width / 2 + x / 2] + ryBuffer[y / 2 * m_width / 2 + x / 2 + 1]);
                                    by = .5 * (byBuffer[y / 2 * m_width / 2 + x / 2] + byBuffer[y / 2 * m_width / 2 + x / 2 + 1]);
                                }
                            } else {
                                if (x % 2 == 0) {
                                    ry = .5 * (ryBuffer[y / 2 * m_width / 2 + x / 2] + ryBuffer[(y / 2 + 1) * m_width / 2 + x / 2]);
                                    by = .5 * (byBuffer[y / 2 * m_width / 2 + x / 2] + byBuffer[(y / 2 + 1) * m_width / 2 + x / 2]);
                                } else {
                                    ry = .25 * (ryBuffer[y / 2 * m_width / 2 + x / 2] + ryBuffer[(y / 2 + 1) * m_width / 2 + x / 2] + ryBuffer[y / 2 * m_width / 2 + x / 2 + 1] + ryBuffer[(y / 2 + 1) * m_width / 2 + x / 2 + 1]);
                                    by = .25 * (byBuffer[y / 2 * m_width / 2 + x / 2] + byBuffer[(y / 2 + 1) * m_width / 2 + x / 2] + byBuffer[y / 2 * m_width / 2 + x / 2 + 1] + byBuffer[(y / 2 + 1) * m_width / 2 + x / 2 + 1]);
                                }
                            }
                            */

                            const float ry
                              = ryBuffer[y / 2 * m_width / 2 + x / 2];
                            const float by
                              = byBuffer[y / 2 * m_width / 2 + x / 2];

                            buff1[y * m_width + x].r = ry;
                            buff1[y * m_width + x].g = l;
                            buff1[y * m_width + x].b = by;
                            // Do not forget the alpha values read earlier
                            buff1[y * m_width + x].a
                              = m_pixelBuffer[4 * (y * m_width + x) + 3];
                        }
                    }

                    Imath::V3f yw = Imf::RgbaYca::computeYw(chromaticities);

                    // Proceed to the YCA -> RGBA conversion
                    #pragma omp parallel for
                    for (int y = 0; y < m_height; y++) {
                        Imf::RgbaYca::YCAtoRGBA(
                          yw,
                          m_width,
                          &buff1[y * m_width],
                          &buff1[y * m_width]);
                    }

                    // Fix over saturated pixels
                    #pragma omp parallel for
                    for (int y = 0; y < m_height; y++) {
                        const Imf::Rgba* scanlines[3];

                        if (y == 0) {
                            scanlines[0] = &buff1[(y + 1) * m_width];
                        } else {
                            scanlines[0] = &buff1[(y - 1) * m_width];
                        }

                        scanlines[1] = &buff1[y * m_width];

                        if (y == m_height - 1) {
                            scanlines[2] = &buff1[(y - 1) * m_width];
                        } else {
                            scanlines[2] = &buff1[(y + 1) * m_width];
                        }

                        Imf::RgbaYca::fixSaturation(
                          yw,
                          m_width,
                          scanlines,
                          &buff2[y * m_width]);
                    }

                    // Handle custom chromaticities
                    Imath::M44f RGB_XYZ = Imf::RGBtoXYZ(chromaticities, 1.f);
                    Imath::M44f XYZ_RGB
                      = Imf::XYZtoRGB(Imf::Chromaticities(), 1.f);

                    Imath::M44f conversionMatrix = RGB_XYZ * XYZ_RGB;

                    #pragma omp parallel for
                    for (int y = 0; y < m_height; y++) {
                        for (int x = 0; x < m_width; x++) {
                            Imath::V3f rgb(
                              buff2[y * m_width + x].r,
                              buff2[y * m_width + x].g,
                              buff2[y * m_width + x].b);

                            rgb = rgb * conversionMatrix;

                            m_pixelBuffer[4 * (y * m_width + x) + 0] = rgb.x;
                            m_pixelBuffer[4 * (y * m_width + x) + 1] = rgb.y;
                            m_pixelBuffer[4 * (y * m_width + x) + 2] = rgb.z;
                        }
                    }
                }

                break;

                case Layer_Y: {
                    std::string yLayer = m_parentLayer;

                    Imf::FrameBuffer framebuffer;

                    Imf::Slice ySlice = Imf::Slice::Make(
                      Imf::PixelType::FLOAT,
                      &m_pixelBuffer[0],
                      datW,
                      4 * sizeof(float),
                      4 * m_width * sizeof(float));

                    framebuffer.insert(yLayer, ySlice);

                    part.setFrameBuffer(framebuffer);
                    part.readPixels(datW.min.y, datW.max.y);

                    #pragma omp parallel for
                    for (int i = 0; i < m_height * m_width; i++) {
                        m_pixelBuffer[4 * i + 1] = m_pixelBuffer[4 * i + 0];
                        m_pixelBuffer[4 * i + 2] = m_pixelBuffer[4 * i + 0];
                        m_pixelBuffer[4 * i + 3] = 1.f;
                    }
                } break;
            }

            m_image = QImage(m_width, m_height, QImage::Format_RGBA8888);
            m_isImageLoaded = true;

            emit imageLoaded();

            updateImage();
        } catch (std::exception& e) {
            emit loadFailed(e.what());
            return;
        }
    });

    m_imageLoadingWatcher->setFuture(imageLoading);
}","void RGBFramebufferModel::load(
  Imf::MultiPartInputFile& VAR_0, int VAR_1, bool VAR_2)
{
    QFuture<void> VAR_3 = QtConcurrent::run([this,
                                                    &VAR_0,
                                                    VAR_1,
                                                    VAR_2]() {
        try {
            Imf::InputPart part(file, partId);

            Imath::Box2i VAR_4 = VAR_5.header().dataWindow();
            VAR_6           = VAR_4.max.x - VAR_4.min.x + 1;
            VAR_7          = VAR_4.max.y - VAR_4.min.y + 1;

            VAR_8 = VAR_5.header().pixelAspectRatio();

            VAR_9 = QRect(VAR_4.min.x, VAR_4.min.y, VAR_6, VAR_7);

            Imath::Box2i VAR_10 = VAR_5.header().displayWindow();

            int VAR_11  = VAR_10.max.x - VAR_10.min.x + 1;
            int VAR_12 = VAR_10.max.y - VAR_10.min.y + 1;

            VAR_13
              = QRect(VAR_10.min.x, VAR_10.min.y, VAR_11, VAR_12);

            /* COMMENT_0 */
            /* COMMENT_1 */
            /* COMMENT_2 */
            /* COMMENT_3 */
            /* COMMENT_4 */
            /* COMMENT_5 */
            const uint64_t VAR_14
              = (uint64_t)VAR_6 * (uint64_t)VAR_7;

            if (VAR_14 > 0x1FFFFFFF) {
                throw std::runtime_error(
                  ""The total image size is too large. May be supported in a ""
                  ""future revision."");
            }

            VAR_15.resize(4 * VAR_6 * VAR_7);

            /* COMMENT_6 */
            /* COMMENT_7 */
            const Imf::ChromaticitiesAttribute* VAR_16
              = VAR_5.header().findTypedAttribute<Imf::ChromaticitiesAttribute>(
                ""chromaticities"");

            Imf::Chromaticities VAR_17;

            if (VAR_16 != nullptr) {
                VAR_17 = VAR_16->value();
            }

            /* COMMENT_8 */
            if (VAR_2) {
                std::string      VAR_18 = VAR_19 + ""A"";
                Imf::FrameBuffer VAR_20;

                Imf::Slice VAR_21 = Imf::Slice::Make(
                  Imf::PixelType::FLOAT,
                  &VAR_15[3],
                  VAR_4,
                  4 * sizeof(float),
                  4 * VAR_6 * sizeof(float));

                VAR_20.insert(VAR_18, VAR_21);

                VAR_5.setFrameBuffer(VAR_20);
                VAR_5.readPixels(VAR_4.min.y, VAR_4.max.y);

            } else {
                for (int VAR_22 = 0; VAR_22 < VAR_7; VAR_22++) {
                    for (int VAR_23 = 0; VAR_23 < VAR_6; VAR_23++) {
                        VAR_15[4 * (VAR_22 * VAR_6 + VAR_23) + 3] = 1.f;
                    }
                }
            }

            switch (VAR_24) {
                case VAR_25: {
                    std::string VAR_26 = VAR_19 + ""R"";
                    std::string VAR_27 = VAR_19 + ""G"";
                    std::string VAR_28 = VAR_19 + ""B"";

                    Imf::FrameBuffer VAR_20;

                    Imf::Slice VAR_29 = Imf::Slice::Make(
                      Imf::PixelType::FLOAT,
                      &VAR_15[0],
                      VAR_4,
                      4 * sizeof(float),
                      4 * VAR_6 * sizeof(float));

                    Imf::Slice VAR_30 = Imf::Slice::Make(
                      Imf::PixelType::FLOAT,
                      &VAR_15[1],
                      VAR_4,
                      4 * sizeof(float),
                      4 * VAR_6 * sizeof(float));

                    Imf::Slice VAR_31 = Imf::Slice::Make(
                      Imf::PixelType::FLOAT,
                      &VAR_15[2],
                      VAR_4,
                      4 * sizeof(float),
                      4 * VAR_6 * sizeof(float));

                    VAR_20.insert(VAR_26, VAR_29);
                    VAR_20.insert(VAR_27, VAR_30);
                    VAR_20.insert(VAR_28, VAR_31);

                    VAR_5.setFrameBuffer(VAR_20);
                    VAR_5.readPixels(VAR_4.min.y, VAR_4.max.y);

                    /* COMMENT_9 */
                    Imath::M44f VAR_32 = Imf::RGBtoXYZ(VAR_17, 1.f);
                    Imath::M44f VAR_33
                      = Imf::XYZtoRGB(Imf::Chromaticities(), 1.f);

                    Imath::M44f VAR_34 = VAR_32 * VAR_33;

                    #pragma omp parallel for
                    for (int VAR_22 = 0; VAR_22 < VAR_7; VAR_22++) {
                        for (int VAR_23 = 0; VAR_23 < VAR_6; VAR_23++) {
                            const float VAR_35
                              = VAR_15[4 * (VAR_22 * VAR_6 + VAR_23) + 0];
                            const float VAR_36
                              = VAR_15[4 * (VAR_22 * VAR_6 + VAR_23) + 1];
                            const float VAR_37
                              = VAR_15[4 * (VAR_22 * VAR_6 + VAR_23) + 2];

                            Imath::V3f rgb(r, g, b);
                            VAR_38 *= VAR_34;

                            VAR_15[4 * (VAR_22 * VAR_6 + VAR_23) + 0] = VAR_38.x;
                            VAR_15[4 * (VAR_22 * VAR_6 + VAR_23) + 1] = VAR_38.y;
                            VAR_15[4 * (VAR_22 * VAR_6 + VAR_23) + 2] = VAR_38.z;
                        }
                    }
                } break;

                case VAR_39: {
                    std::string VAR_40  = VAR_19 + ""Y"";
                    std::string VAR_41 = VAR_19 + ""RY"";
                    std::string VAR_42 = VAR_19 + ""BY"";

                    Imf::FrameBuffer VAR_20;

                    std::vector<Imf::Rgba> buff1(m_width * VAR_7);
                    std::vector<Imf::Rgba> buff2(m_width * VAR_7);

                    std::vector<float> yBuffer(m_width * VAR_7);
                    std::vector<float> VAR_43(m_width / 2 * VAR_7 / 2);
                    std::vector<float> VAR_44(m_width / 2 * VAR_7 / 2);

                    Imf::Slice VAR_45 = Imf::Slice::Make(
                      Imf::PixelType::FLOAT,
                      &VAR_46[0],
                      VAR_4,
                      sizeof(float),
                      m_width * sizeof(float));

                    Imf::Slice VAR_47 = Imf::Slice::Make(
                      Imf::PixelType::FLOAT,
                      &VAR_43[0],
                      VAR_4,
                      sizeof(float),
                      m_width / 2 * sizeof(float),
                      2,
                      2);

                    Imf::Slice VAR_48 = Imf::Slice::Make(
                      Imf::PixelType::FLOAT,
                      &VAR_44[0],
                      VAR_4,
                      sizeof(float),
                      m_width / 2 * sizeof(float),
                      2,
                      2);

                    VAR_20.insert(VAR_40, VAR_45);
                    VAR_20.insert(VAR_41, VAR_47);
                    VAR_20.insert(VAR_42, VAR_48);

                    VAR_5.setFrameBuffer(VAR_20);
                    VAR_5.readPixels(VAR_4.min.y, VAR_4.max.y);

                    /* COMMENT_10 */
                    /* COMMENT_11 */
                    /* COMMENT_12 */
                    /* COMMENT_13 */
                    /* COMMENT_14 */
                    #pragma omp parallel for
                    for (int VAR_22 = 0; VAR_22 < VAR_7; VAR_22++) {
                        for (int VAR_23 = 0; VAR_23 < m_width; VAR_23++) {
                            const float VAR_49 = VAR_46[VAR_22 * m_width + VAR_23];

                            /* COMMENT_15 */
                                                 

                                             
                                                 
                                                                               
                                                                               
                                        
                                                                                                                                  
                                                                                                                                  
                                 
                                    
                                                 
                                                                                                                                    
                                                                                                                                    
                                        
                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                   
                                 
                             
                              

                            const float VAR_50
                              = VAR_43[VAR_22 / 2 * m_width / 2 + VAR_23 / 2];
                            const float VAR_51
                              = VAR_44[VAR_22 / 2 * m_width / 2 + VAR_23 / 2];

                            VAR_52[VAR_22 * m_width + VAR_23].r = VAR_50;
                            VAR_52[VAR_22 * m_width + VAR_23].g = VAR_49;
                            VAR_52[VAR_22 * m_width + VAR_23].b = VAR_51;
                            /* COMMENT_33 */
                            VAR_52[VAR_22 * m_width + VAR_23].a
                              = VAR_15[4 * (VAR_22 * m_width + VAR_23) + 3];
                        }
                    }

                    Imath::V3f VAR_53 = Imf::RgbaYca::computeYw(VAR_17);

                    /* COMMENT_34 */
                    #pragma omp parallel for
                    for (int VAR_22 = 0; VAR_22 < VAR_7; VAR_22++) {
                        Imf::RgbaYca::YCAtoRGBA(
                          VAR_53,
                          m_width,
                          &VAR_52[VAR_22 * m_width],
                          &VAR_52[VAR_22 * m_width]);
                    }

                    /* COMMENT_35 */
                    #pragma omp parallel for
                    for (int VAR_22 = 0; VAR_22 < VAR_7; VAR_22++) {
                        const Imf::Rgba* VAR_54[3];

                        if (VAR_22 == 0) {
                            VAR_54[0] = &VAR_52[(VAR_22 + 1) * m_width];
                        } else {
                            VAR_54[0] = &VAR_52[(VAR_22 - 1) * m_width];
                        }

                        VAR_54[1] = &VAR_52[VAR_22 * m_width];

                        if (VAR_22 == VAR_7 - 1) {
                            VAR_54[2] = &VAR_52[(VAR_22 - 1) * m_width];
                        } else {
                            VAR_54[2] = &VAR_52[(VAR_22 + 1) * m_width];
                        }

                        Imf::RgbaYca::fixSaturation(
                          VAR_53,
                          m_width,
                          VAR_54,
                          &VAR_55[VAR_22 * m_width]);
                    }

                    /* COMMENT_9 */
                    Imath::M44f VAR_32 = Imf::RGBtoXYZ(VAR_17, 1.f);
                    Imath::M44f VAR_33
                      = Imf::XYZtoRGB(Imf::Chromaticities(), 1.f);

                    Imath::M44f VAR_34 = VAR_32 * VAR_33;

                    #pragma omp parallel for
                    for (int VAR_22 = 0; VAR_22 < VAR_7; VAR_22++) {
                        for (int VAR_23 = 0; VAR_23 < m_width; VAR_23++) {
                            Imath::V3f VAR_38(
                              VAR_55[VAR_22 * m_width + VAR_23].r,
                              VAR_55[VAR_22 * m_width + VAR_23].g,
                              VAR_55[VAR_22 * m_width + VAR_23].b);

                            VAR_38 = VAR_38 * VAR_34;

                            VAR_15[4 * (VAR_22 * m_width + VAR_23) + 0] = VAR_38.x;
                            VAR_15[4 * (VAR_22 * m_width + VAR_23) + 1] = VAR_38.y;
                            VAR_15[4 * (VAR_22 * m_width + VAR_23) + 2] = VAR_38.z;
                        }
                    }
                }

                break;

                case VAR_56: {
                    std::string VAR_40 = VAR_19;

                    Imf::FrameBuffer VAR_20;

                    Imf::Slice VAR_45 = Imf::Slice::Make(
                      Imf::PixelType::FLOAT,
                      &VAR_15[0],
                      VAR_4,
                      4 * sizeof(float),
                      4 * m_width * sizeof(float));

                    VAR_20.insert(VAR_40, VAR_45);

                    VAR_5.setFrameBuffer(VAR_20);
                    VAR_5.readPixels(VAR_4.min.y, VAR_4.max.y);

                    #pragma omp parallel for
                    for (int VAR_57 = 0; VAR_57 < VAR_7 * m_width; VAR_57++) {
                        VAR_15[4 * VAR_57 + 1] = VAR_15[4 * VAR_57 + 0];
                        VAR_15[4 * VAR_57 + 2] = VAR_15[4 * VAR_57 + 0];
                        VAR_15[4 * VAR_57 + 3] = 1.f;
                    }
                } break;
            }

            VAR_58 = QImage(m_width, VAR_7, QImage::Format_RGBA8888);
            VAR_59 = true;

            emit imageLoaded();

            updateImage();
        } catch (std::exception& VAR_60) {
            emit VAR_61(VAR_60.what());
            return;
        }
    });

    VAR_62->setFuture(VAR_3);
}",afichet/openexr-viewer/d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9/RGBFramebufferModel.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -24,6 +24,23 @@
             m_displayWindow
               = QRect(dispW.min.x, dispW.min.y, dispW_width, dispW_height);
 
+            // Check to avoid type overflow, width and height are 32bits int
+            // representing a 2 dimentional image. Can overflow the type when
+            // multiplied together.
+            // 0x1FFFFFFF is a save limit for 4 * 0x7FFFFFFF the max
+            // representable int since we need 4 channels.
+            // TODO: Use larger type when manipulating framebuffer
+            const uint64_t partial_size
+              = (uint64_t)m_width * (uint64_t)m_height;
+
+            if (partial_size > 0x1FFFFFFF) {
+                throw std::runtime_error(
+                  ""The total image size is too large. May be supported in a ""
+                  ""future revision."");
+            }
+
+            m_pixelBuffer.resize(4 * m_width * m_height);
+
             // Check if there is specific chromaticities tied to the color
             // representation in this part.
             const Imf::ChromaticitiesAttribute* c
@@ -35,8 +52,6 @@
             if (c != nullptr) {
                 chromaticities = c->value();
             }
-
-            m_pixelBuffer = new float[4 * m_width * m_height];
 
             // Check if there is alpha channel
             if (hasAlpha) {
@@ -133,12 +148,12 @@
 
                     Imf::FrameBuffer framebuffer;
 
-                    Imf::Rgba* buff1 = new Imf::Rgba[m_width * m_height];
-                    Imf::Rgba* buff2 = new Imf::Rgba[m_width * m_height];
-
-                    float* yBuffer  = new float[m_width * m_height];
-                    float* ryBuffer = new float[m_width / 2 * m_height / 2];
-                    float* byBuffer = new float[m_width / 2 * m_height / 2];
+                    std::vector<Imf::Rgba> buff1(m_width * m_height);
+                    std::vector<Imf::Rgba> buff2(m_width * m_height);
+
+                    std::vector<float> yBuffer(m_width * m_height);
+                    std::vector<float> ryBuffer(m_width / 2 * m_height / 2);
+                    std::vector<float> byBuffer(m_width / 2 * m_height / 2);
 
                     Imf::Slice ySlice = Imf::Slice::Make(
                       Imf::PixelType::FLOAT,
@@ -278,12 +293,6 @@
                             m_pixelBuffer[4 * (y * m_width + x) + 2] = rgb.z;
                         }
                     }
-
-                    delete[] yBuffer;
-                    delete[] ryBuffer;
-                    delete[] byBuffer;
-                    delete[] buff1;
-                    delete[] buff2;
                 }
 
                 break;","{'deleted_lines': ['', '            m_pixelBuffer = new float[4 * m_width * m_height];', '                    Imf::Rgba* buff1 = new Imf::Rgba[m_width * m_height];', '                    Imf::Rgba* buff2 = new Imf::Rgba[m_width * m_height];', '', '                    float* yBuffer  = new float[m_width * m_height];', '                    float* ryBuffer = new float[m_width / 2 * m_height / 2];', '                    float* byBuffer = new float[m_width / 2 * m_height / 2];', '', '                    delete[] yBuffer;', '                    delete[] ryBuffer;', '                    delete[] byBuffer;', '                    delete[] buff1;', '                    delete[] buff2;'], 'added_lines': ['            // Check to avoid type overflow, width and height are 32bits int', '            // representing a 2 dimentional image. Can overflow the type when', '            // multiplied together.', '            // 0x1FFFFFFF is a save limit for 4 * 0x7FFFFFFF the max', '            // representable int since we need 4 channels.', '            // TODO: Use larger type when manipulating framebuffer', '            const uint64_t partial_size', '              = (uint64_t)m_width * (uint64_t)m_height;', '', '            if (partial_size > 0x1FFFFFFF) {', '                throw std::runtime_error(', '                  ""The total image size is too large. May be supported in a ""', '                  ""future revision."");', '            }', '', '            m_pixelBuffer.resize(4 * m_width * m_height);', '', '                    std::vector<Imf::Rgba> buff1(m_width * m_height);', '                    std::vector<Imf::Rgba> buff2(m_width * m_height);', '', '                    std::vector<float> yBuffer(m_width * m_height);', '                    std::vector<float> ryBuffer(m_width / 2 * m_height / 2);', '                    std::vector<float> byBuffer(m_width / 2 * m_height / 2);']}",True,OpenEXR-viewer is a viewer for OpenEXR files with detailed metadata probing. Versions prior to 0.6.1 have a memory overflow vulnerability. This issue is fixed in version 0.6.1.,9.8,CRITICAL,3,test,2023-12-09T13:13:36Z,4
CVE-2023-50245,['CWE-120'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,afichet/openexr-viewer,"Early catch potential overflow issue #43

`m_width` and `m_height` are of `int` type in the OpenEXR library. We
currently keep the same types in our class but this may case issue
when mapping 1D memory. In the most favorable case, they are
multiplied together (Y framebuffer). For RGB(A) case, the required
memory can also be 4 time larger. We check if resp. `m_width *
m_height` and `4 * m_width * m_heigh` stay within the `int` higher
limit. Thanks to @GAP-dev for bringing this issue.

This commit also cleans a bit raw memory allocation in favor of
`std::vector` container.",d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9,https://github.com/afichet/openexr-viewer/commit/d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9,src/model/framebuffer/YFramebufferModel.cpp,YFramebufferModel::load,"void YFramebufferModel::load(Imf::MultiPartInputFile& file, int partId)
{
QFuture<void> imageLoading = QtConcurrent::run([this, &file, partId]() {
try {
Imf::InputPart part(file, partId);
Imath::Box2i datW = part.header().dataWindow();
m_width           = datW.max.x - datW.min.x + 1;
m_height          = datW.max.y - datW.min.y + 1;
m_pixelAspectRatio = part.header().pixelAspectRatio();
Imf::Slice graySlice;
if (m_layer == ""BY"" || m_layer == ""RY"") {
m_width /= 2;
m_height /= 2;
m_dataWindow = QRect(datW.min.x, datW.min.y, m_width, m_height);
Imath::Box2i dispW = part.header().displayWindow();
int dispW_width  = dispW.max.x - dispW.min.x + 1;
int dispW_height = dispW.max.y - dispW.min.y + 1;
m_displayWindow = QRect(
dispW.min.x,
dispW.min.y,
dispW_width / 2,
dispW_height / 2);
m_pixelBuffer = new float[m_width * m_height];
graySlice = Imf::Slice::Make(
Imf::PixelType::FLOAT,
m_pixelBuffer,
datW,
sizeof(float),
m_width * sizeof(float),
2,
2);
} else {
m_dataWindow = QRect(datW.min.x, datW.min.y, m_width, m_height);
Imath::Box2i dispW = part.header().displayWindow();
int dispW_width  = dispW.max.x - dispW.min.x + 1;
int dispW_height = dispW.max.y - dispW.min.y + 1;
m_displayWindow
= QRect(dispW.min.x, dispW.min.y, dispW_width, dispW_height);
m_pixelBuffer = new float[m_width * m_height];
graySlice = Imf::Slice::Make(
Imf::PixelType::FLOAT,
m_pixelBuffer,
datW);
}
Imf::FrameBuffer framebuffer;
framebuffer.insert(m_layer, graySlice);
part.setFrameBuffer(framebuffer);
part.readPixels(datW.min.y, datW.max.y);
m_datasetMin = std::numeric_limits<double>::infinity();
m_datasetMax = -std::numeric_limits<double>::infinity();
for (int i = 0; i < m_width * m_height; i++) {
m_datasetMin = std::min(m_datasetMin, (double)m_pixelBuffer[i]);
m_datasetMax = std::max(m_datasetMax, (double)m_pixelBuffer[i]);
}
m_image         = QImage(m_width, m_height, QImage::Format_RGB888);
m_isImageLoaded = true;
emit imageLoaded();
updateImage();
} catch (std::exception& e) {
emit loadFailed(e.what());
return;
}
});
m_imageLoadingWatcher->setFuture(imageLoading);
}","void YFramebufferModel::load(Imf::MultiPartInputFile& VAR_0, int VAR_1)
{
QFuture<void> VAR_2 = QtConcurrent::run([this, &VAR_0, VAR_1]() {
try {
Imf::InputPart part(file, partId);
Imath::Box2i VAR_3 = VAR_4.header().dataWindow();
VAR_5           = VAR_3.max.x - VAR_3.min.x + 1;
VAR_6          = VAR_3.max.y - VAR_3.min.y + 1;
VAR_7 = VAR_4.header().pixelAspectRatio();
Imf::Slice VAR_8;
if (VAR_9 == ""BY"" || VAR_9 == ""RY"") {
VAR_5 /= 2;
VAR_6 /= 2;
VAR_10 = QRect(VAR_3.min.x, VAR_3.min.y, VAR_5, VAR_6);
Imath::Box2i VAR_11 = VAR_4.header().displayWindow();
int VAR_12  = VAR_11.max.x - VAR_11.min.x + 1;
int VAR_13 = VAR_11.max.y - VAR_11.min.y + 1;
VAR_14 = QRect(
VAR_11.min.x,
VAR_11.min.y,
VAR_12 / 2,
VAR_13 / 2);
VAR_15 = new float[VAR_5 * VAR_6];
VAR_8 = Imf::Slice::Make(
Imf::PixelType::FLOAT,
VAR_15,
VAR_3,
sizeof(float),
VAR_5 * sizeof(float),
2,
2);
} else {
VAR_10 = QRect(VAR_3.min.x, VAR_3.min.y, VAR_5, VAR_6);
Imath::Box2i VAR_11 = VAR_4.header().displayWindow();
int VAR_12  = VAR_11.max.x - VAR_11.min.x + 1;
int VAR_13 = VAR_11.max.y - VAR_11.min.y + 1;
VAR_14
= QRect(VAR_11.min.x, VAR_11.min.y, VAR_12, VAR_13);
VAR_15 = new float[VAR_5 * VAR_6];
VAR_8 = Imf::Slice::Make(
Imf::PixelType::FLOAT,
VAR_15,
VAR_3);
}
Imf::FrameBuffer VAR_16;
VAR_16.insert(VAR_9, VAR_8);
VAR_4.setFrameBuffer(VAR_16);
VAR_4.readPixels(VAR_3.min.y, VAR_3.max.y);
VAR_17 = std::numeric_limits<double>::infinity();
VAR_18 = -std::numeric_limits<double>::infinity();
for (int VAR_19 = 0; VAR_19 < VAR_5 * VAR_6; VAR_19++) {
VAR_17 = std::min(VAR_17, (double)VAR_15[VAR_19]);
VAR_18 = std::max(VAR_18, (double)VAR_15[VAR_19]);
}
VAR_20         = QImage(VAR_5, VAR_6, QImage::Format_RGB888);
VAR_21 = true;
emit imageLoaded();
updateImage();
} catch (std::exception& VAR_22) {
emit VAR_23(VAR_22.what());
return;
}
});
VAR_24->setFuture(VAR_2);
}",afichet/openexr-viewer/d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9/YFramebufferModel.cpp/vul/before/0.json,"void YFramebufferModel::load(Imf::MultiPartInputFile& file, int partId)
{
    QFuture<void> imageLoading = QtConcurrent::run([this, &file, partId]() {
        try {
            Imf::InputPart part(file, partId);

            Imath::Box2i datW = part.header().dataWindow();
            m_width           = datW.max.x - datW.min.x + 1;
            m_height          = datW.max.y - datW.min.y + 1;

            m_pixelAspectRatio = part.header().pixelAspectRatio();

            Imf::Slice graySlice;
            // TODO: Check it that can be guess from the header
            // also, check if this can be nested
            if (m_layer == ""BY"" || m_layer == ""RY"") {
                m_width /= 2;
                m_height /= 2;

                m_dataWindow = QRect(datW.min.x, datW.min.y, m_width, m_height);

                Imath::Box2i dispW = part.header().displayWindow();

                int dispW_width  = dispW.max.x - dispW.min.x + 1;
                int dispW_height = dispW.max.y - dispW.min.y + 1;

                m_displayWindow = QRect(
                  dispW.min.x,
                  dispW.min.y,
                  dispW_width / 2,
                  dispW_height / 2);

                // Check to avoid type overflow, width and height are 32bits int
                // representing a 2 dimentional image. Can overflow the type when
                // multiplied together
                // TODO: Use larger type when manipulating framebuffer
                const uint64_t partial_size
                  = (uint64_t)m_width * (uint64_t)m_height;

                if (partial_size > 0x7FFFFFFF) {
                    throw std::runtime_error(
                      ""The total image size is too large. May be supported in ""
                      ""a future revision."");
                }

                m_pixelBuffer.resize(m_width * m_height);

                // Luminance Chroma channels
                graySlice = Imf::Slice::Make(
                  Imf::PixelType::FLOAT,
                  m_pixelBuffer.data(),
                  datW,
                  sizeof(float),
                  m_width * sizeof(float),
                  2,
                  2);
            } else {
                m_dataWindow = QRect(datW.min.x, datW.min.y, m_width, m_height);

                Imath::Box2i dispW = part.header().displayWindow();

                int dispW_width  = dispW.max.x - dispW.min.x + 1;
                int dispW_height = dispW.max.y - dispW.min.y + 1;

                m_displayWindow
                  = QRect(dispW.min.x, dispW.min.y, dispW_width, dispW_height);

                m_pixelBuffer.resize(m_width * m_height);

                graySlice = Imf::Slice::Make(
                  Imf::PixelType::FLOAT,
                  m_pixelBuffer.data(),
                  datW);
            }

            Imf::FrameBuffer framebuffer;

            framebuffer.insert(m_layer, graySlice);

            part.setFrameBuffer(framebuffer);
            part.readPixels(datW.min.y, datW.max.y);

            // Determine min and max of the dataset
            m_datasetMin = std::numeric_limits<double>::infinity();
            m_datasetMax = -std::numeric_limits<double>::infinity();

            for (int i = 0; i < m_width * m_height; i++) {
                m_datasetMin = std::min(m_datasetMin, (double)m_pixelBuffer[i]);
                m_datasetMax = std::max(m_datasetMax, (double)m_pixelBuffer[i]);
            }

            m_image         = QImage(m_width, m_height, QImage::Format_RGB888);
            m_isImageLoaded = true;

            emit imageLoaded();

            updateImage();
        } catch (std::exception& e) {
            emit loadFailed(e.what());
            return;
        }
    });

    m_imageLoadingWatcher->setFuture(imageLoading);
}","void YFramebufferModel::load(Imf::MultiPartInputFile& VAR_0, int VAR_1)
{
    QFuture<void> VAR_2 = QtConcurrent::run([this, &VAR_0, VAR_1]() {
        try {
            Imf::InputPart part(file, partId);

            Imath::Box2i VAR_3 = VAR_4.header().dataWindow();
            VAR_5           = VAR_3.max.x - VAR_3.min.x + 1;
            VAR_6          = VAR_3.max.y - VAR_3.min.y + 1;

            VAR_7 = VAR_4.header().pixelAspectRatio();

            Imf::Slice VAR_8;
            /* COMMENT_0 */
            /* COMMENT_1 */
            if (VAR_9 == ""BY"" || VAR_9 == ""RY"") {
                VAR_5 /= 2;
                VAR_6 /= 2;

                VAR_10 = QRect(VAR_3.min.x, VAR_3.min.y, VAR_5, VAR_6);

                Imath::Box2i VAR_11 = VAR_4.header().displayWindow();

                int VAR_12  = VAR_11.max.x - VAR_11.min.x + 1;
                int VAR_13 = VAR_11.max.y - VAR_11.min.y + 1;

                VAR_14 = QRect(
                  VAR_11.min.x,
                  VAR_11.min.y,
                  VAR_12 / 2,
                  VAR_13 / 2);

                /* COMMENT_2 */
                /* COMMENT_3 */
                /* COMMENT_4 */
                /* COMMENT_5 */
                const uint64_t VAR_15
                  = (uint64_t)VAR_5 * (uint64_t)VAR_6;

                if (VAR_15 > 0x7FFFFFFF) {
                    throw std::runtime_error(
                      ""The total image size is too large. May be supported in ""
                      ""a future revision."");
                }

                VAR_16.resize(VAR_5 * VAR_6);

                /* COMMENT_6 */
                VAR_8 = Imf::Slice::Make(
                  Imf::PixelType::FLOAT,
                  VAR_16.data(),
                  VAR_3,
                  sizeof(float),
                  VAR_5 * sizeof(float),
                  2,
                  2);
            } else {
                VAR_10 = QRect(VAR_3.min.x, VAR_3.min.y, VAR_5, VAR_6);

                Imath::Box2i VAR_11 = VAR_4.header().displayWindow();

                int VAR_12  = VAR_11.max.x - VAR_11.min.x + 1;
                int VAR_13 = VAR_11.max.y - VAR_11.min.y + 1;

                VAR_14
                  = QRect(VAR_11.min.x, VAR_11.min.y, VAR_12, VAR_13);

                VAR_16.resize(VAR_5 * VAR_6);

                VAR_8 = Imf::Slice::Make(
                  Imf::PixelType::FLOAT,
                  VAR_16.data(),
                  VAR_3);
            }

            Imf::FrameBuffer VAR_17;

            VAR_17.insert(VAR_9, VAR_8);

            VAR_4.setFrameBuffer(VAR_17);
            VAR_4.readPixels(VAR_3.min.y, VAR_3.max.y);

            /* COMMENT_7 */
            VAR_18 = std::numeric_limits<double>::infinity();
            VAR_19 = -std::numeric_limits<double>::infinity();

            for (int VAR_20 = 0; VAR_20 < VAR_5 * VAR_6; VAR_20++) {
                VAR_18 = std::min(VAR_18, (double)VAR_16[VAR_20]);
                VAR_19 = std::max(VAR_19, (double)VAR_16[VAR_20]);
            }

            VAR_21         = QImage(VAR_5, VAR_6, QImage::Format_RGB888);
            VAR_22 = true;

            emit imageLoaded();

            updateImage();
        } catch (std::exception& VAR_23) {
            emit VAR_24(VAR_23.what());
            return;
        }
    });

    VAR_25->setFuture(VAR_2);
}",afichet/openexr-viewer/d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9/YFramebufferModel.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -30,12 +30,25 @@
                   dispW_width / 2,
                   dispW_height / 2);
 
-                m_pixelBuffer = new float[m_width * m_height];
+                // Check to avoid type overflow, width and height are 32bits int
+                // representing a 2 dimentional image. Can overflow the type when
+                // multiplied together
+                // TODO: Use larger type when manipulating framebuffer
+                const uint64_t partial_size
+                  = (uint64_t)m_width * (uint64_t)m_height;
+
+                if (partial_size > 0x7FFFFFFF) {
+                    throw std::runtime_error(
+                      ""The total image size is too large. May be supported in ""
+                      ""a future revision."");
+                }
+
+                m_pixelBuffer.resize(m_width * m_height);
 
                 // Luminance Chroma channels
                 graySlice = Imf::Slice::Make(
                   Imf::PixelType::FLOAT,
-                  m_pixelBuffer,
+                  m_pixelBuffer.data(),
                   datW,
                   sizeof(float),
                   m_width * sizeof(float),
@@ -52,11 +65,11 @@
                 m_displayWindow
                   = QRect(dispW.min.x, dispW.min.y, dispW_width, dispW_height);
 
-                m_pixelBuffer = new float[m_width * m_height];
+                m_pixelBuffer.resize(m_width * m_height);
 
                 graySlice = Imf::Slice::Make(
                   Imf::PixelType::FLOAT,
-                  m_pixelBuffer,
+                  m_pixelBuffer.data(),
                   datW);
             }
 ","{'deleted_lines': ['                m_pixelBuffer = new float[m_width * m_height];', '                  m_pixelBuffer,', '                m_pixelBuffer = new float[m_width * m_height];', '                  m_pixelBuffer,'], 'added_lines': ['                // Check to avoid type overflow, width and height are 32bits int', '                // representing a 2 dimentional image. Can overflow the type when', '                // multiplied together', '                // TODO: Use larger type when manipulating framebuffer', '                const uint64_t partial_size', '                  = (uint64_t)m_width * (uint64_t)m_height;', '', '                if (partial_size > 0x7FFFFFFF) {', '                    throw std::runtime_error(', '                      ""The total image size is too large. May be supported in ""', '                      ""a future revision."");', '                }', '', '                m_pixelBuffer.resize(m_width * m_height);', '                  m_pixelBuffer.data(),', '                m_pixelBuffer.resize(m_width * m_height);', '                  m_pixelBuffer.data(),']}",True,OpenEXR-viewer is a viewer for OpenEXR files with detailed metadata probing. Versions prior to 0.6.1 have a memory overflow vulnerability. This issue is fixed in version 0.6.1.,9.8,CRITICAL,3,test,2023-12-09T13:13:36Z,4
CVE-2021-3575,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,uclouvain/openjpeg,"opj_decompress: fix off-by-one read heap-buffer-overflow in sycc420_to_rgb() when x0 and y0 are odd (CVE-2021-3575, fixes #1347)",7bd884f8750892de4f50bf4642fcfbe7011c6bdf,https://github.com/uclouvain/openjpeg/commit/7bd884f8750892de4f50bf4642fcfbe7011c6bdf,src/bin/common/color.c,sycc420_to_rgb,"static void sycc420_to_rgb(opj_image_t *img)
{
int *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;
const int *y, *cb, *cr, *ny;
size_t maxw, maxh, max, offx, loopmaxw, offy, loopmaxh;
int offset, upb;
size_t i;
upb = (int)img->comps[0].prec;
offset = 1 << (upb - 1);
upb = (1 << upb) - 1;
maxw = (size_t)img->comps[0].w;
maxh = (size_t)img->comps[0].h;
max = maxw * maxh;
y = img->comps[0].data;
cb = img->comps[1].data;
cr = img->comps[2].data;
d0 = r = (int*)opj_image_data_alloc(sizeof(int) * max);
d1 = g = (int*)opj_image_data_alloc(sizeof(int) * max);
d2 = b = (int*)opj_image_data_alloc(sizeof(int) * max);
if (r == NULL || g == NULL || b == NULL) {
goto fails;
}
offx = img->x0 & 1U;
loopmaxw = maxw - offx;
offy = img->y0 & 1U;
loopmaxh = maxh - offy;
if (offy > 0U) {
size_t j;
for (j = 0; j < maxw; ++j) {
sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);
++y;
++r;
++g;
++b;
}
}
for (i = 0U; i < (loopmaxh & ~(size_t)1U); i += 2U) {
size_t j;
ny = y + maxw;
nr = r + maxw;
ng = g + maxw;
nb = b + maxw;
if (offx > 0U) {
sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);
++y;
++r;
++g;
++b;
sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
++ny;
++nr;
++ng;
++nb;
}
for (j = 0; j < (loopmaxw & ~(size_t)1U); j += 2U) {
sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
++y;
++r;
++g;
++b;
sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
++y;
++r;
++g;
++b;
sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
++ny;
++nr;
++ng;
++nb;
sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
++ny;
++nr;
++ng;
++nb;
++cb;
++cr;
}
if (j < loopmaxw) {
sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
++y;
++r;
++g;
++b;
sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
++ny;
++nr;
++ng;
++nb;
++cb;
++cr;
}
y += maxw;
r += maxw;
g += maxw;
b += maxw;
}
if (i < loopmaxh) {
size_t j;
for (j = 0U; j < (maxw & ~(size_t)1U); j += 2U) {
sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
++y;
++r;
++g;
++b;
sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
++y;
++r;
++g;
++b;
++cb;
++cr;
}
if (j < maxw) {
sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
}
}
opj_image_data_free(img->comps[0].data);
img->comps[0].data = d0;
opj_image_data_free(img->comps[1].data);
img->comps[1].data = d1;
opj_image_data_free(img->comps[2].data);
img->comps[2].data = d2;
img->comps[1].w = img->comps[2].w = img->comps[0].w;
img->comps[1].h = img->comps[2].h = img->comps[0].h;
img->comps[1].dx = img->comps[2].dx = img->comps[0].dx;
img->comps[1].dy = img->comps[2].dy = img->comps[0].dy;
img->color_space = OPJ_CLRSPC_SRGB;
return;
fails:
opj_image_data_free(r);
opj_image_data_free(g);
opj_image_data_free(b);
}","static void sycc420_to_rgb(opj_image_t *VAR_0)
{
int *VAR_1, *VAR_2, *VAR_3, *VAR_4, *VAR_5, *VAR_6, *VAR_7, *VAR_8, *VAR_9;
const int *VAR_10, *VAR_11, *VAR_12, *VAR_13;
size_t VAR_14, VAR_15, VAR_16, VAR_17, VAR_18, VAR_19, VAR_20;
int VAR_21, VAR_22;
size_t VAR_23;
VAR_22 = (int)VAR_0->comps[0].prec;
VAR_21 = 1 << (VAR_22 - 1);
VAR_22 = (1 << VAR_22) - 1;
VAR_14 = (size_t)VAR_0->comps[0].w;
VAR_15 = (size_t)VAR_0->comps[0].h;
VAR_16 = VAR_14 * VAR_15;
VAR_10 = VAR_0->comps[0].data;
VAR_11 = VAR_0->comps[1].data;
VAR_12 = VAR_0->comps[2].data;
VAR_1 = VAR_4 = (int*)opj_image_data_alloc(sizeof(int) * VAR_16);
VAR_2 = VAR_5 = (int*)opj_image_data_alloc(sizeof(int) * VAR_16);
VAR_3 = VAR_6 = (int*)opj_image_data_alloc(sizeof(int) * VAR_16);
if (VAR_4 == NULL || VAR_5 == NULL || VAR_6 == NULL) {
goto fails;
}
VAR_17 = VAR_0->x0 & 1U;
VAR_18 = VAR_14 - VAR_17;
VAR_19 = VAR_0->y0 & 1U;
VAR_20 = VAR_15 - VAR_19;
if (VAR_19 > 0U) {
size_t VAR_24;
for (VAR_24 = 0; VAR_24 < VAR_14; ++VAR_24) {
sycc_to_rgb(VAR_21, VAR_22, *VAR_10, 0, 0, VAR_4, VAR_5, VAR_6);
++VAR_10;
++VAR_4;
++VAR_5;
++VAR_6;
}
}
for (VAR_23 = 0U; VAR_23 < (VAR_20 & ~(size_t)1U); VAR_23 += 2U) {
size_t VAR_24;
VAR_13 = VAR_10 + VAR_14;
VAR_7 = VAR_4 + VAR_14;
VAR_8 = VAR_5 + VAR_14;
VAR_9 = VAR_6 + VAR_14;
if (VAR_17 > 0U) {
sycc_to_rgb(VAR_21, VAR_22, *VAR_10, 0, 0, VAR_4, VAR_5, VAR_6);
++VAR_10;
++VAR_4;
++VAR_5;
++VAR_6;
sycc_to_rgb(VAR_21, VAR_22, *VAR_13, *VAR_11, *VAR_12, VAR_7, VAR_8, VAR_9);
++VAR_13;
++VAR_7;
++VAR_8;
++VAR_9;
}
for (VAR_24 = 0; VAR_24 < (VAR_18 & ~(size_t)1U); VAR_24 += 2U) {
sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);
++VAR_10;
++VAR_4;
++VAR_5;
++VAR_6;
sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);
++VAR_10;
++VAR_4;
++VAR_5;
++VAR_6;
sycc_to_rgb(VAR_21, VAR_22, *VAR_13, *VAR_11, *VAR_12, VAR_7, VAR_8, VAR_9);
++VAR_13;
++VAR_7;
++VAR_8;
++VAR_9;
sycc_to_rgb(VAR_21, VAR_22, *VAR_13, *VAR_11, *VAR_12, VAR_7, VAR_8, VAR_9);
++VAR_13;
++VAR_7;
++VAR_8;
++VAR_9;
++VAR_11;
++VAR_12;
}
if (VAR_24 < VAR_18) {
sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);
++VAR_10;
++VAR_4;
++VAR_5;
++VAR_6;
sycc_to_rgb(VAR_21, VAR_22, *VAR_13, *VAR_11, *VAR_12, VAR_7, VAR_8, VAR_9);
++VAR_13;
++VAR_7;
++VAR_8;
++VAR_9;
++VAR_11;
++VAR_12;
}
VAR_10 += VAR_14;
VAR_4 += VAR_14;
VAR_5 += VAR_14;
VAR_6 += VAR_14;
}
if (VAR_23 < VAR_20) {
size_t VAR_24;
for (VAR_24 = 0U; VAR_24 < (VAR_14 & ~(size_t)1U); VAR_24 += 2U) {
sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);
++VAR_10;
++VAR_4;
++VAR_5;
++VAR_6;
sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);
++VAR_10;
++VAR_4;
++VAR_5;
++VAR_6;
++VAR_11;
++VAR_12;
}
if (VAR_24 < VAR_14) {
sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);
}
}
opj_image_data_free(VAR_0->comps[0].data);
VAR_0->comps[0].data = VAR_1;
opj_image_data_free(VAR_0->comps[1].data);
VAR_0->comps[1].data = VAR_2;
opj_image_data_free(VAR_0->comps[2].data);
VAR_0->comps[2].data = VAR_3;
VAR_0->comps[1].w = VAR_0->comps[2].w = VAR_0->comps[0].w;
VAR_0->comps[1].h = VAR_0->comps[2].h = VAR_0->comps[0].h;
VAR_0->comps[1].dx = VAR_0->comps[2].dx = VAR_0->comps[0].dx;
VAR_0->comps[1].dy = VAR_0->comps[2].dy = VAR_0->comps[0].dy;
VAR_0->color_space = VAR_25;
return;
fails:
opj_image_data_free(VAR_4);
opj_image_data_free(VAR_5);
opj_image_data_free(VAR_6);
}",uclouvain/openjpeg/7bd884f8750892de4f50bf4642fcfbe7011c6bdf/color.c/vul/before/0.json,"static void sycc420_to_rgb(opj_image_t *img)
{
    int *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;
    const int *y, *cb, *cr, *ny;
    size_t maxw, maxh, max, offx, loopmaxw, offy, loopmaxh;
    int offset, upb;
    size_t i;

    upb = (int)img->comps[0].prec;
    offset = 1 << (upb - 1);
    upb = (1 << upb) - 1;

    maxw = (size_t)img->comps[0].w;
    maxh = (size_t)img->comps[0].h;
    max = maxw * maxh;

    y = img->comps[0].data;
    cb = img->comps[1].data;
    cr = img->comps[2].data;

    d0 = r = (int*)opj_image_data_alloc(sizeof(int) * max);
    d1 = g = (int*)opj_image_data_alloc(sizeof(int) * max);
    d2 = b = (int*)opj_image_data_alloc(sizeof(int) * max);

    if (r == NULL || g == NULL || b == NULL) {
        goto fails;
    }

    /* if img->x0 is odd, then first column shall use Cb/Cr = 0 */
    offx = img->x0 & 1U;
    loopmaxw = maxw - offx;
    /* if img->y0 is odd, then first line shall use Cb/Cr = 0 */
    offy = img->y0 & 1U;
    loopmaxh = maxh - offy;

    if (offy > 0U) {
        size_t j;

        for (j = 0; j < maxw; ++j) {
            sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);
            ++y;
            ++r;
            ++g;
            ++b;
        }
    }

    for (i = 0U; i < (loopmaxh & ~(size_t)1U); i += 2U) {
        size_t j;

        ny = y + maxw;
        nr = r + maxw;
        ng = g + maxw;
        nb = b + maxw;

        if (offx > 0U) {
            sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);
            ++y;
            ++r;
            ++g;
            ++b;
            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
            ++ny;
            ++nr;
            ++ng;
            ++nb;
        }

        for (j = 0; j < (loopmaxw & ~(size_t)1U); j += 2U) {
            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
            ++y;
            ++r;
            ++g;
            ++b;
            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
            ++y;
            ++r;
            ++g;
            ++b;

            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
            ++ny;
            ++nr;
            ++ng;
            ++nb;
            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
            ++ny;
            ++nr;
            ++ng;
            ++nb;
            ++cb;
            ++cr;
        }
        if (j < loopmaxw) {
            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
            ++y;
            ++r;
            ++g;
            ++b;

            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
            ++ny;
            ++nr;
            ++ng;
            ++nb;
            ++cb;
            ++cr;
        }
        y += maxw;
        r += maxw;
        g += maxw;
        b += maxw;
    }
    if (i < loopmaxh) {
        size_t j;

        if (offx > 0U) {
            sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);
            ++y;
            ++r;
            ++g;
            ++b;
        }

        for (j = 0U; j < (loopmaxw & ~(size_t)1U); j += 2U) {
            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);

            ++y;
            ++r;
            ++g;
            ++b;

            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);

            ++y;
            ++r;
            ++g;
            ++b;
            ++cb;
            ++cr;
        }
        if (j < loopmaxw) {
            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
        }
    }

    opj_image_data_free(img->comps[0].data);
    img->comps[0].data = d0;
    opj_image_data_free(img->comps[1].data);
    img->comps[1].data = d1;
    opj_image_data_free(img->comps[2].data);
    img->comps[2].data = d2;

    img->comps[1].w = img->comps[2].w = img->comps[0].w;
    img->comps[1].h = img->comps[2].h = img->comps[0].h;
    img->comps[1].dx = img->comps[2].dx = img->comps[0].dx;
    img->comps[1].dy = img->comps[2].dy = img->comps[0].dy;
    img->color_space = OPJ_CLRSPC_SRGB;
    return;

fails:
    opj_image_data_free(r);
    opj_image_data_free(g);
    opj_image_data_free(b);
}","static void sycc420_to_rgb(opj_image_t *VAR_0)
{
    int *VAR_1, *VAR_2, *VAR_3, *VAR_4, *VAR_5, *VAR_6, *VAR_7, *VAR_8, *VAR_9;
    const int *VAR_10, *VAR_11, *VAR_12, *VAR_13;
    size_t VAR_14, VAR_15, VAR_16, VAR_17, VAR_18, VAR_19, VAR_20;
    int VAR_21, VAR_22;
    size_t VAR_23;

    VAR_22 = (int)VAR_0->comps[0].prec;
    VAR_21 = 1 << (VAR_22 - 1);
    VAR_22 = (1 << VAR_22) - 1;

    VAR_14 = (size_t)VAR_0->comps[0].w;
    VAR_15 = (size_t)VAR_0->comps[0].h;
    VAR_16 = VAR_14 * VAR_15;

    VAR_10 = VAR_0->comps[0].data;
    VAR_11 = VAR_0->comps[1].data;
    VAR_12 = VAR_0->comps[2].data;

    VAR_1 = VAR_4 = (int*)opj_image_data_alloc(sizeof(int) * VAR_16);
    VAR_2 = VAR_5 = (int*)opj_image_data_alloc(sizeof(int) * VAR_16);
    VAR_3 = VAR_6 = (int*)opj_image_data_alloc(sizeof(int) * VAR_16);

    if (VAR_4 == NULL || VAR_5 == NULL || VAR_6 == NULL) {
        goto fails;
    }

    /* COMMENT_0 */
    VAR_17 = VAR_0->x0 & 1U;
    VAR_18 = VAR_14 - VAR_17;
    /* COMMENT_1 */
    VAR_19 = VAR_0->y0 & 1U;
    VAR_20 = VAR_15 - VAR_19;

    if (VAR_19 > 0U) {
        size_t VAR_24;

        for (VAR_24 = 0; VAR_24 < VAR_14; ++VAR_24) {
            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, 0, 0, VAR_4, VAR_5, VAR_6);
            ++VAR_10;
            ++VAR_4;
            ++VAR_5;
            ++VAR_6;
        }
    }

    for (VAR_23 = 0U; VAR_23 < (VAR_20 & ~(size_t)1U); VAR_23 += 2U) {
        size_t VAR_24;

        VAR_13 = VAR_10 + VAR_14;
        VAR_7 = VAR_4 + VAR_14;
        VAR_8 = VAR_5 + VAR_14;
        VAR_9 = VAR_6 + VAR_14;

        if (VAR_17 > 0U) {
            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, 0, 0, VAR_4, VAR_5, VAR_6);
            ++VAR_10;
            ++VAR_4;
            ++VAR_5;
            ++VAR_6;
            sycc_to_rgb(VAR_21, VAR_22, *VAR_13, *VAR_11, *VAR_12, VAR_7, VAR_8, VAR_9);
            ++VAR_13;
            ++VAR_7;
            ++VAR_8;
            ++VAR_9;
        }

        for (VAR_24 = 0; VAR_24 < (VAR_18 & ~(size_t)1U); VAR_24 += 2U) {
            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);
            ++VAR_10;
            ++VAR_4;
            ++VAR_5;
            ++VAR_6;
            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);
            ++VAR_10;
            ++VAR_4;
            ++VAR_5;
            ++VAR_6;

            sycc_to_rgb(VAR_21, VAR_22, *VAR_13, *VAR_11, *VAR_12, VAR_7, VAR_8, VAR_9);
            ++VAR_13;
            ++VAR_7;
            ++VAR_8;
            ++VAR_9;
            sycc_to_rgb(VAR_21, VAR_22, *VAR_13, *VAR_11, *VAR_12, VAR_7, VAR_8, VAR_9);
            ++VAR_13;
            ++VAR_7;
            ++VAR_8;
            ++VAR_9;
            ++VAR_11;
            ++VAR_12;
        }
        if (VAR_24 < VAR_18) {
            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);
            ++VAR_10;
            ++VAR_4;
            ++VAR_5;
            ++VAR_6;

            sycc_to_rgb(VAR_21, VAR_22, *VAR_13, *VAR_11, *VAR_12, VAR_7, VAR_8, VAR_9);
            ++VAR_13;
            ++VAR_7;
            ++VAR_8;
            ++VAR_9;
            ++VAR_11;
            ++VAR_12;
        }
        VAR_10 += VAR_14;
        VAR_4 += VAR_14;
        VAR_5 += VAR_14;
        VAR_6 += VAR_14;
    }
    if (VAR_23 < VAR_20) {
        size_t VAR_24;

        if (VAR_17 > 0U) {
            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, 0, 0, VAR_4, VAR_5, VAR_6);
            ++VAR_10;
            ++VAR_4;
            ++VAR_5;
            ++VAR_6;
        }

        for (VAR_24 = 0U; VAR_24 < (VAR_18 & ~(size_t)1U); VAR_24 += 2U) {
            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);

            ++VAR_10;
            ++VAR_4;
            ++VAR_5;
            ++VAR_6;

            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);

            ++VAR_10;
            ++VAR_4;
            ++VAR_5;
            ++VAR_6;
            ++VAR_11;
            ++VAR_12;
        }
        if (VAR_24 < VAR_18) {
            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);
        }
    }

    opj_image_data_free(VAR_0->comps[0].data);
    VAR_0->comps[0].data = VAR_1;
    opj_image_data_free(VAR_0->comps[1].data);
    VAR_0->comps[1].data = VAR_2;
    opj_image_data_free(VAR_0->comps[2].data);
    VAR_0->comps[2].data = VAR_3;

    VAR_0->comps[1].w = VAR_0->comps[2].w = VAR_0->comps[0].w;
    VAR_0->comps[1].h = VAR_0->comps[2].h = VAR_0->comps[0].h;
    VAR_0->comps[1].dx = VAR_0->comps[2].dx = VAR_0->comps[0].dx;
    VAR_0->comps[1].dy = VAR_0->comps[2].dy = VAR_0->comps[0].dy;
    VAR_0->color_space = VAR_25;
    return;

fails:
    opj_image_data_free(VAR_4);
    opj_image_data_free(VAR_5);
    opj_image_data_free(VAR_6);
}",uclouvain/openjpeg/7bd884f8750892de4f50bf4642fcfbe7011c6bdf/color.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -114,7 +114,15 @@
     if (i < loopmaxh) {
         size_t j;
 
-        for (j = 0U; j < (maxw & ~(size_t)1U); j += 2U) {
+        if (offx > 0U) {
+            sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);
+            ++y;
+            ++r;
+            ++g;
+            ++b;
+        }
+
+        for (j = 0U; j < (loopmaxw & ~(size_t)1U); j += 2U) {
             sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
 
             ++y;
@@ -131,7 +139,7 @@
             ++cb;
             ++cr;
         }
-        if (j < maxw) {
+        if (j < loopmaxw) {
             sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
         }
     }","{'deleted_lines': ['        for (j = 0U; j < (maxw & ~(size_t)1U); j += 2U) {', '        if (j < maxw) {'], 'added_lines': ['        if (offx > 0U) {', '            sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);', '            ++y;', '            ++r;', '            ++g;', '            ++b;', '        }', '', '        for (j = 0U; j < (loopmaxw & ~(size_t)1U); j += 2U) {', '        if (j < loopmaxw) {']}",True,A heap-based buffer overflow was found in openjpeg in color.c:379:42 in sycc420_to_rgb when decompressing a crafted .j2k file. An attacker could use this to execute arbitrary code with the permissions of the application compiled against openjpeg.,7.8,HIGH,2,test,2024-02-18T16:02:25Z,4
